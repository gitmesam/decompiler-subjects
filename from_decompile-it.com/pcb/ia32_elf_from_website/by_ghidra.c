typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long double    longdouble;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[15];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct stat stat, *Pstat;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    ulong __unused4;
    ulong __unused5;
};

typedef struct _GNode _GNode, *P_GNode;

typedef void * gpointer;

typedef struct _GNode GNode;

struct _GNode {
    gpointer data;
    GNode * next;
    GNode * prev;
    GNode * parent;
    GNode * children;
};

typedef struct rect_s rect_s, *Prect_s;

struct rect_s {
    int x1;
    int y1;
    int x2;
    int y2;
};

typedef struct corner_s corner_s, *Pcorner_s;

typedef struct PinType PinType, *PPinType;

typedef struct PadType PadType, *PPadType;

typedef struct line_s line_s, *Pline_s;

typedef struct BoxType BoxType, *PBoxType;

typedef struct FlagType FlagType, *PFlagType;

typedef struct LibraryEntryType LibraryEntryType, *PLibraryEntryType;

typedef int BDimension;

typedef int LocationType;

typedef struct PointType PointType, *PPointType;

typedef struct LineType LineType, *PLineType;

struct corner_s {
    int layer;
    struct corner_s * next;
    int x;
    int y;
    int net;
    struct PinType * via;
    struct PadType * pad;
    struct PinType * pin;
    int miter;
    int n_lines;
    struct line_s * * lines;
};

struct LibraryEntryType {
    char * ListEntry;
    char * AllocatedMemory;
    char * Template;
    char * Package;
    char * Value;
    char * Description;
};

struct PointType {
    LocationType X;
    LocationType Y;
    LocationType X2;
    LocationType Y2;
    long ID;
};

struct BoxType {
    LocationType X1;
    LocationType Y1;
    LocationType X2;
    LocationType Y2;
};

struct FlagType {
    ulong f;
    uchar t[8];
};

struct PinType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    BDimension Mask;
    BDimension DrillingHole;
    LocationType X;
    LocationType Y;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct PadType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    BDimension Mask;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct LineType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    char * Number;
};

struct line_s {
    int layer;
    struct line_s * next;
    struct corner_s * s;
    struct corner_s * e;
    struct LineType * line;
};

typedef enum GdkVisualType {
    GDK_VISUAL_DIRECT_COLOR=5,
    GDK_VISUAL_GRAYSCALE=1,
    GDK_VISUAL_PSEUDO_COLOR=3,
    GDK_VISUAL_STATIC_COLOR=2,
    GDK_VISUAL_STATIC_GRAY=0,
    GDK_VISUAL_TRUE_COLOR=4
} GdkVisualType;

typedef union anon_union.conflict5 anon_union.conflict5, *Panon_union.conflict5;

typedef char gchar;

typedef uchar guchar;

typedef int gint;

typedef gint gboolean;

typedef uint guint;

typedef long glong;

typedef ulong gulong;

typedef float gfloat;

typedef double gdouble;

typedef struct _GtkObject _GtkObject, *P_GtkObject;

typedef struct _GtkObject GtkObject;

typedef struct anon_struct.conflict51 anon_struct.conflict51, *Panon_struct.conflict51;

typedef struct _GObject _GObject, *P_GObject;

typedef struct _GObject GInitiallyUnowned;

typedef uint guint32;

typedef struct _GTypeInstance _GTypeInstance, *P_GTypeInstance;

typedef struct _GTypeInstance GTypeInstance;

typedef struct _GData _GData, *P_GData;

typedef struct _GData GData;

typedef struct _GTypeClass _GTypeClass, *P_GTypeClass;

typedef struct _GTypeClass GTypeClass;

typedef uint gsize;

typedef gsize GType;

struct anon_struct.conflict51 {
    void (* f)(void);
    gpointer d;
};

union anon_union.conflict5 {
    gchar char_data;
    guchar uchar_data;
    gboolean bool_data;
    gint int_data;
    guint uint_data;
    glong long_data;
    gulong ulong_data;
    gfloat float_data;
    gdouble double_data;
    gchar * string_data;
    GtkObject * object_data;
    gpointer pointer_data;
    struct anon_struct.conflict51 signal_data;
};

struct _GTypeClass {
    GType g_type;
};

struct _GData {
};

struct _GTypeInstance {
    GTypeClass * g_class;
};

struct _GObject {
    GTypeInstance g_type_instance;
    guint ref_count;
    GData * qdata;
};

struct _GtkObject {
    GInitiallyUnowned parent_instance;
    guint32 flags;
};

typedef struct _GtkArg _GtkArg, *P_GtkArg;

typedef struct _GtkArg GtkArg;

typedef union anon_union_for_d anon_union_for_d, *Panon_union_for_d;

union anon_union_for_d {
    gchar char_data;
    guchar uchar_data;
    gboolean bool_data;
    gint int_data;
    guint uint_data;
    glong long_data;
    gulong ulong_data;
    gfloat float_data;
    gdouble double_data;
    gchar * string_data;
    GtkObject * object_data;
    gpointer pointer_data;
    struct anon_struct.conflict51 signal_data;
};

struct _GtkArg {
    GType type;
    gchar * name;
    union anon_union_for_d d;
};

typedef struct _GObjectConstructParam _GObjectConstructParam, *P_GObjectConstructParam;

typedef struct _GParamSpec _GParamSpec, *P_GParamSpec;

typedef struct _GParamSpec GParamSpec;

typedef struct _GValue _GValue, *P_GValue;

typedef struct _GValue GValue;

typedef enum GParamFlags {
    G_PARAM_CONSTRUCT=4,
    G_PARAM_CONSTRUCT_ONLY=8,
    G_PARAM_DEPRECATED=-8,
    G_PARAM_LAX_VALIDATION=16,
    G_PARAM_PRIVATE=32,
    G_PARAM_READABLE=1,
    G_PARAM_STATIC_BLURB=128,
    G_PARAM_STATIC_NAME=32,
    G_PARAM_STATIC_NICK=64,
    G_PARAM_WRITABLE=2
} GParamFlags;

typedef union anon_union.conflict3 anon_union.conflict3, *Panon_union.conflict3;

typedef longlong gint64;

typedef ulonglong guint64;

struct _GObjectConstructParam {
    GParamSpec * pspec;
    GValue * value;
};

struct _GParamSpec {
    GTypeInstance g_type_instance;
    gchar * name;
    enum GParamFlags flags;
    GType value_type;
    GType owner_type;
    gchar * _nick;
    gchar * _blurb;
    GData * qdata;
    guint ref_count;
    guint param_id;
};

union anon_union.conflict3 {
    gint v_int;
    guint v_uint;
    glong v_long;
    gulong v_ulong;
    gint64 v_int64;
    guint64 v_uint64;
    gfloat v_float;
    gdouble v_double;
    gpointer v_pointer;
};

struct _GValue {
    GType g_type;
    union anon_union.conflict3 data[2];
};

typedef struct _GObjectConstructParam GObjectConstructParam;

typedef struct _GObjectClass _GObjectClass, *P_GObjectClass;

typedef struct _GObject GObject;

typedef struct _GObjectClass GInitiallyUnownedClass;

typedef struct _GSList _GSList, *P_GSList;

typedef struct _GSList GSList;

struct _GSList {
    gpointer data;
    GSList * next;
};

struct _GObjectClass {
    GTypeClass g_type_class;
    GSList * construct_properties;
    GObject * (* constructor)(GType, guint, GObjectConstructParam *);
    void (* set_property)(GObject *, guint, GValue *, GParamSpec *);
    void (* get_property)(GObject *, guint, GValue *, GParamSpec *);
    void (* dispose)(GObject *);
    void (* finalize)(GObject *);
    void (* dispatch_properties_changed)(GObject *, guint, GParamSpec * *);
    void (* notify)(GObject *, GParamSpec *);
    void (* constructed)(GObject *);
    gsize flags;
    gpointer pdummy[6];
};

typedef struct _GObjectClass GObjectClass;

typedef struct HID_AttrNode HID_AttrNode, *PHID_AttrNode;

typedef struct HID_Attribute HID_Attribute, *PHID_Attribute;

typedef enum anon_enum_32_for_type {
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3
} anon_enum_32_for_type;

typedef struct HID_Attr_Val HID_Attr_Val, *PHID_Attr_Val;

struct HID_Attr_Val {
    int int_value;
    char * str_value;
    double real_value;
};

struct HID_Attribute {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

struct HID_AttrNode {
    struct HID_AttrNode * next;
    struct HID_Attribute * attributes;
    int n;
};

typedef struct _GtkButton _GtkButton, *P_GtkButton;

typedef struct _GtkBin _GtkBin, *P_GtkBin;

typedef struct _GtkBin GtkBin;

typedef struct _GdkDrawable _GdkDrawable, *P_GdkDrawable;

typedef struct _GdkDrawable GdkWindow;

typedef struct _GtkContainer _GtkContainer, *P_GtkContainer;

typedef struct _GtkContainer GtkContainer;

typedef struct _GtkWidget _GtkWidget, *P_GtkWidget;

typedef struct _GtkWidget GtkWidget;

typedef ushort guint16;

typedef uchar guint8;

typedef struct _GtkStyle _GtkStyle, *P_GtkStyle;

typedef struct _GtkStyle GtkStyle;

typedef struct _GtkRequisition _GtkRequisition, *P_GtkRequisition;

typedef struct _GtkRequisition GtkRequisition;

typedef struct _GdkRectangle _GdkRectangle, *P_GdkRectangle;

typedef struct _GdkRectangle GdkRectangle;

typedef GdkRectangle GtkAllocation;

typedef struct _GdkColor _GdkColor, *P_GdkColor;

typedef struct _GdkColor GdkColor;

typedef struct _PangoFontDescription _PangoFontDescription, *P_PangoFontDescription;

typedef struct _PangoFontDescription PangoFontDescription;

typedef struct _GdkGC _GdkGC, *P_GdkGC;

typedef struct _GdkGC GdkGC;

typedef struct _GdkDrawable GdkPixmap;

typedef struct _GdkColormap _GdkColormap, *P_GdkColormap;

typedef struct _GdkColormap GdkColormap;

typedef struct _GdkFont _GdkFont, *P_GdkFont;

typedef struct _GdkFont GdkFont;

typedef struct _GtkRcStyle _GtkRcStyle, *P_GtkRcStyle;

typedef struct _GtkRcStyle GtkRcStyle;

typedef struct _GArray _GArray, *P_GArray;

typedef struct _GArray GArray;

typedef struct _GdkVisual _GdkVisual, *P_GdkVisual;

typedef struct _GdkVisual GdkVisual;

typedef enum GdkFontType {
    GDK_FONT_FONT=0,
    GDK_FONT_FONTSET=1
} GdkFontType;

typedef enum GtkRcFlags {
    GTK_RC_BASE=8,
    GTK_RC_BG=2,
    GTK_RC_FG=1,
    GTK_RC_TEXT=4
} GtkRcFlags;

typedef enum GdkByteOrder {
    GDK_LSB_FIRST=0,
    GDK_MSB_FIRST=1
} GdkByteOrder;

struct _GdkRectangle {
    gint x;
    gint y;
    gint width;
    gint height;
};

struct _GtkRequisition {
    gint width;
    gint height;
};

struct _GtkWidget {
    GtkObject object;
    guint16 private_flags;
    guint8 state;
    guint8 saved_state;
    gchar * name;
    GtkStyle * style;
    GtkRequisition requisition;
    GtkAllocation allocation;
    GdkWindow * window;
    GtkWidget * parent;
};

struct _GtkContainer {
    GtkWidget widget;
    GtkWidget * focus_child;
    guint border_width:16;
    guint need_resize:1;
    guint resize_mode:2;
    guint reallocate_redraws:1;
    guint has_focus_chain:1;
    undefined field_0x43;
};

struct _GtkBin {
    GtkContainer container;
    GtkWidget * child;
};

struct _GdkVisual {
    GObject parent_instance;
    enum GdkVisualType type;
    gint depth;
    enum GdkByteOrder byte_order;
    gint colormap_size;
    gint bits_per_rgb;
    guint32 red_mask;
    gint red_shift;
    gint red_prec;
    guint32 green_mask;
    gint green_shift;
    gint green_prec;
    guint32 blue_mask;
    gint blue_shift;
    gint blue_prec;
};

struct _PangoFontDescription {
};

struct _GdkFont {
    enum GdkFontType type;
    gint ascent;
    gint descent;
};

struct _GdkColormap {
    GObject parent_instance;
    gint size;
    GdkColor * colors;
    GdkVisual * visual;
    gpointer windowing_data;
};

struct _GArray {
    gchar * data;
    guint len;
};

struct _GdkColor {
    guint32 pixel;
    guint16 red;
    guint16 green;
    guint16 blue;
    undefined field_0xa;
    undefined field_0xb;
};

struct _GtkRcStyle {
    GObject parent_instance;
    gchar * name;
    gchar * bg_pixmap_name[5];
    PangoFontDescription * font_desc;
    enum GtkRcFlags color_flags[5];
    GdkColor fg[5];
    GdkColor bg[5];
    GdkColor text[5];
    GdkColor base[5];
    gint xthickness;
    gint ythickness;
    GArray * rc_properties;
    GSList * rc_style_lists;
    GSList * icon_factories;
    guint engine_specified:1;
    undefined field_0x141;
    undefined field_0x142;
    undefined field_0x143;
};

struct _GtkButton {
    GtkBin bin;
    GdkWindow * event_window;
    gchar * label_text;
    guint activate_timeout;
    guint constructed:1;
    guint in_button:1;
    guint button_down:1;
    guint relief:2;
    guint use_underline:1;
    guint use_stock:1;
    guint depressed:1;
    guint depress_on_activate:1;
    guint focus_on_click:1;
    undefined field_0x56;
    undefined field_0x57;
};

struct _GdkDrawable {
    GObject parent_instance;
};

struct _GtkStyle {
    GObject parent_instance;
    GdkColor fg[5];
    GdkColor bg[5];
    GdkColor light[5];
    GdkColor dark[5];
    GdkColor mid[5];
    GdkColor text[5];
    GdkColor base[5];
    GdkColor text_aa[5];
    GdkColor black;
    GdkColor white;
    PangoFontDescription * font_desc;
    gint xthickness;
    gint ythickness;
    GdkGC * fg_gc[5];
    GdkGC * bg_gc[5];
    GdkGC * light_gc[5];
    GdkGC * dark_gc[5];
    GdkGC * mid_gc[5];
    GdkGC * text_gc[5];
    GdkGC * base_gc[5];
    GdkGC * text_aa_gc[5];
    GdkGC * black_gc;
    GdkGC * white_gc;
    GdkPixmap * bg_pixmap[5];
    gint attach_count;
    gint depth;
    GdkColormap * colormap;
    GdkFont * private_font;
    PangoFontDescription * private_font_desc;
    GtkRcStyle * rc_style;
    GSList * styles;
    GArray * property_cache;
    GSList * icon_factories;
};

struct _GdkGC {
    GObject parent_instance;
    gint clip_x_origin;
    gint clip_y_origin;
    gint ts_x_origin;
    gint ts_y_origin;
    GdkColormap * colormap;
};

typedef struct _GtkButton GtkButton;

typedef struct _GtkTextMark _GtkTextMark, *P_GtkTextMark;

struct _GtkTextMark {
    GObject parent_instance;
    gpointer segment;
};

typedef struct _GtkTextMark GtkTextMark;

typedef struct rlp_info rlp_info, *Prlp_info;

typedef struct __jmp_buf_tag __jmp_buf_tag, *P__jmp_buf_tag;

typedef struct LineType * LineTypePtr;

typedef struct PointType * PointTypePtr;

typedef int __jmp_buf[6];

typedef struct __sigset_t __sigset_t, *P__sigset_t;

struct __sigset_t {
    ulong __val[32];
};

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    struct __sigset_t __saved_mask;
};

struct rlp_info {
    jmp_buf env;
    LineTypePtr line;
    PointTypePtr point;
};

typedef struct __jmp_buf_tag jmp_buf[1];

typedef struct ggnfnn_task ggnfnn_task, *Pggnfnn_task;

typedef struct LibraryMenuType LibraryMenuType, *PLibraryMenuType;

typedef struct _GtkTreeIter _GtkTreeIter, *P_GtkTreeIter;

typedef struct _GtkTreeIter GtkTreeIter;

typedef uint Cardinal;

typedef struct LibraryEntryTypePtr LibraryEntryTypePtr, *PLibraryEntryTypePtr;

struct LibraryMenuType {
    char * Name;
    char * directory;
    char * Style;
    Cardinal EntryN;
    Cardinal EntryMax;
    struct LibraryEntryTypePtr * Entry;
    char flag;
    char internal;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct _GtkTreeIter {
    gint stamp;
    gpointer user_data;
    gpointer user_data2;
    gpointer user_data3;
};

struct LibraryEntryTypePtr {
    char * ListEntry;
    char * AllocatedMemory;
    char * Template;
    char * Package;
    char * Value;
    char * Description;
};

struct ggnfnn_task {
    gboolean enabled_only;
    gchar * node_name;
    struct LibraryMenuType * found_net;
    GtkTreeIter iter;
};

typedef struct _GtkMessageDialog _GtkMessageDialog, *P_GtkMessageDialog;

typedef struct _GtkDialog _GtkDialog, *P_GtkDialog;

typedef struct _GtkDialog GtkDialog;

typedef struct _GtkWindow _GtkWindow, *P_GtkWindow;

typedef struct _GtkWindow GtkWindow;

typedef struct _GtkWindowGeometryInfo _GtkWindowGeometryInfo, *P_GtkWindowGeometryInfo;

typedef struct _GtkWindowGeometryInfo GtkWindowGeometryInfo;

typedef struct _GtkWindowGroup _GtkWindowGroup, *P_GtkWindowGroup;

typedef struct _GtkWindowGroup GtkWindowGroup;

typedef enum GdkModifierType {
    GDK_BUTTON1_MASK=256,
    GDK_BUTTON2_MASK=512,
    GDK_BUTTON3_MASK=1024,
    GDK_BUTTON4_MASK=2048,
    GDK_BUTTON5_MASK=4096,
    GDK_CONTROL_MASK=4,
    GDK_HYPER_MASK=134217728,
    GDK_LOCK_MASK=2,
    GDK_META_MASK=268435456,
    GDK_MOD1_MASK=8,
    GDK_MOD2_MASK=16,
    GDK_MOD3_MASK=32,
    GDK_MOD4_MASK=64,
    GDK_MOD5_MASK=128,
    GDK_MODIFIER_MASK=1543512063,
    GDK_RELEASE_MASK=1073741824,
    GDK_SHIFT_MASK=1,
    GDK_SUPER_MASK=67108864
} GdkModifierType;

typedef struct _GdkScreen _GdkScreen, *P_GdkScreen;

typedef struct _GdkScreen GdkScreen;

typedef struct _cairo_font_options _cairo_font_options, *P_cairo_font_options;

typedef struct _cairo_font_options cairo_font_options_t;

struct _GtkWindow {
    GtkBin bin;
    gchar * title;
    gchar * wmclass_name;
    gchar * wmclass_class;
    gchar * wm_role;
    GtkWidget * focus_widget;
    GtkWidget * default_widget;
    GtkWindow * transient_parent;
    GtkWindowGeometryInfo * geometry_info;
    GdkWindow * frame;
    GtkWindowGroup * group;
    guint16 configure_request_count;
    guint allow_shrink:1;
    guint allow_grow:1;
    guint configure_notify_received:1;
    guint need_default_position:1;
    guint need_default_size:1;
    guint position:3;
    guint type:4;
    guint has_user_ref_count:1;
    guint has_focus:1;
    guint modal:1;
    guint destroy_with_parent:1;
    guint has_frame:1;
    guint iconify_initially:1;
    guint stick_initially:1;
    guint maximize_initially:1;
    guint decorated:1;
    guint type_hint:3;
    guint gravity:5;
    guint is_active:1;
    guint has_toplevel_focus:1;
    undefined field_0x76;
    undefined field_0x77;
    guint frame_left;
    guint frame_top;
    guint frame_right;
    guint frame_bottom;
    guint keys_changed_handler;
    enum GdkModifierType mnemonic_modifier;
    GdkScreen * screen;
};

struct _GtkDialog {
    GtkWindow window;
    GtkWidget * vbox;
    GtkWidget * action_area;
    GtkWidget * separator;
};

struct _GtkMessageDialog {
    GtkDialog parent_instance;
    GtkWidget * image;
    GtkWidget * label;
};

struct _GtkWindowGeometryInfo {
};

struct _cairo_font_options {
};

struct _GdkScreen {
    GObject parent_instance;
    guint closed:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    GdkGC * normal_gcs[32];
    GdkGC * exposure_gcs[32];
    GdkGC * subwindow_gcs[32];
    cairo_font_options_t * font_options;
    double resolution;
};

struct _GtkWindowGroup {
    GObject parent_instance;
    GSList * grabs;
};

typedef struct anon_struct.conflict32 anon_struct.conflict32, *Panon_struct.conflict32;

typedef char Boolean;

struct anon_struct.conflict32 {
    Boolean ElementOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean ViaOn;
    Boolean RatOn;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    int LayerStack[16];
    Boolean LayerOn[16];
    int cnt;
};

typedef struct _GPtrArray _GPtrArray, *P_GPtrArray;

typedef struct _GPtrArray GPtrArray;

struct _GPtrArray {
    gpointer * pdata;
    guint len;
};

typedef struct _GtkButtonBox _GtkButtonBox, *P_GtkButtonBox;

typedef struct _GtkBox _GtkBox, *P_GtkBox;

typedef struct _GtkBox GtkBox;

typedef enum GtkButtonBoxStyle {
    GTK_BUTTONBOX_CENTER=5,
    GTK_BUTTONBOX_DEFAULT_STYLE=0,
    GTK_BUTTONBOX_EDGE=2,
    GTK_BUTTONBOX_END=4,
    GTK_BUTTONBOX_SPREAD=1,
    GTK_BUTTONBOX_START=3
} GtkButtonBoxStyle;

typedef struct _GList _GList, *P_GList;

typedef struct _GList GList;

typedef short gint16;

struct _GtkBox {
    GtkContainer container;
    GList * children;
    gint16 spacing;
    guint homogeneous:1;
    undefined field_0x4b;
};

struct _GtkButtonBox {
    GtkBox box;
    gint child_min_width;
    gint child_min_height;
    gint child_ipad_x;
    gint child_ipad_y;
    enum GtkButtonBoxStyle layout_style;
};

struct _GList {
    gpointer data;
    GList * next;
    GList * prev;
};

typedef struct _GtkTooltip _GtkTooltip, *P_GtkTooltip;

typedef struct _GtkTooltip GtkTooltip;

struct _GtkTooltip {
};

typedef enum GtkWidgetHelpType {
    GTK_WIDGET_HELP_TOOLTIP=0,
    GTK_WIDGET_HELP_WHATS_THIS=1
} GtkWidgetHelpType;

typedef struct _GtkWidgetClass _GtkWidgetClass, *P_GtkWidgetClass;

typedef enum GtkStateType {
    GTK_STATE_ACTIVE=1,
    GTK_STATE_INSENSITIVE=4,
    GTK_STATE_NORMAL=0,
    GTK_STATE_PRELIGHT=2,
    GTK_STATE_SELECTED=3
} GtkStateType;

typedef enum GtkTextDirection {
    GTK_TEXT_DIR_LTR=1,
    GTK_TEXT_DIR_NONE=0,
    GTK_TEXT_DIR_RTL=2
} GtkTextDirection;

typedef enum GtkDirectionType {
    GTK_DIR_DOWN=3,
    GTK_DIR_LEFT=4,
    GTK_DIR_RIGHT=5,
    GTK_DIR_TAB_BACKWARD=1,
    GTK_DIR_TAB_FORWARD=0,
    GTK_DIR_UP=2
} GtkDirectionType;

typedef union _GdkEvent _GdkEvent, *P_GdkEvent;

typedef union _GdkEvent GdkEvent;

typedef struct _GdkEventButton _GdkEventButton, *P_GdkEventButton;

typedef struct _GdkEventButton GdkEventButton;

typedef struct _GdkEventScroll _GdkEventScroll, *P_GdkEventScroll;

typedef struct _GdkEventScroll GdkEventScroll;

typedef struct _GdkEventMotion _GdkEventMotion, *P_GdkEventMotion;

typedef struct _GdkEventMotion GdkEventMotion;

typedef struct _GdkEventAny _GdkEventAny, *P_GdkEventAny;

typedef struct _GdkEventAny GdkEventAny;

typedef struct _GdkEventExpose _GdkEventExpose, *P_GdkEventExpose;

typedef struct _GdkEventExpose GdkEventExpose;

typedef struct _GdkEventKey _GdkEventKey, *P_GdkEventKey;

typedef struct _GdkEventKey GdkEventKey;

typedef struct _GdkEventCrossing _GdkEventCrossing, *P_GdkEventCrossing;

typedef struct _GdkEventCrossing GdkEventCrossing;

typedef struct _GdkEventConfigure _GdkEventConfigure, *P_GdkEventConfigure;

typedef struct _GdkEventConfigure GdkEventConfigure;

typedef struct _GdkEventFocus _GdkEventFocus, *P_GdkEventFocus;

typedef struct _GdkEventFocus GdkEventFocus;

typedef struct _GdkEventProperty _GdkEventProperty, *P_GdkEventProperty;

typedef struct _GdkEventProperty GdkEventProperty;

typedef struct _GdkEventSelection _GdkEventSelection, *P_GdkEventSelection;

typedef struct _GdkEventSelection GdkEventSelection;

typedef struct _GdkEventProximity _GdkEventProximity, *P_GdkEventProximity;

typedef struct _GdkEventProximity GdkEventProximity;

typedef struct _GdkEventVisibility _GdkEventVisibility, *P_GdkEventVisibility;

typedef struct _GdkEventVisibility GdkEventVisibility;

typedef struct _GdkEventClient _GdkEventClient, *P_GdkEventClient;

typedef struct _GdkEventClient GdkEventClient;

typedef struct _GdkEventWindowState _GdkEventWindowState, *P_GdkEventWindowState;

typedef struct _GdkEventWindowState GdkEventWindowState;

typedef struct _GtkSelectionData _GtkSelectionData, *P_GtkSelectionData;

typedef struct _GtkSelectionData GtkSelectionData;

typedef struct _GdkDragContext _GdkDragContext, *P_GdkDragContext;

typedef struct _GdkDragContext GdkDragContext;

typedef struct _AtkObject _AtkObject, *P_AtkObject;

typedef struct _AtkObject AtkObject;

typedef struct _GdkEventGrabBroken _GdkEventGrabBroken, *P_GdkEventGrabBroken;

typedef struct _GdkEventGrabBroken GdkEventGrabBroken;

typedef struct _GtkWidgetClass GtkWidgetClass;

typedef struct _GtkObjectClass _GtkObjectClass, *P_GtkObjectClass;

typedef struct _GtkObjectClass GtkObjectClass;

typedef enum GdkEventType {
    GDK_2BUTTON_PRESS=5,
    GDK_3BUTTON_PRESS=6,
    GDK_BUTTON_PRESS=4,
    GDK_BUTTON_RELEASE=7,
    GDK_CLIENT_EVENT=28,
    GDK_CONFIGURE=13,
    GDK_DAMAGE=36,
    GDK_DELETE=0,
    GDK_DESTROY=1,
    GDK_DRAG_ENTER=22,
    GDK_DRAG_LEAVE=23,
    GDK_DRAG_MOTION=24,
    GDK_DRAG_STATUS=25,
    GDK_DROP_FINISHED=27,
    GDK_DROP_START=26,
    GDK_ENTER_NOTIFY=10,
    GDK_EVENT_LAST=37,
    GDK_EXPOSE=2,
    GDK_FOCUS_CHANGE=12,
    GDK_GRAB_BROKEN=35,
    GDK_KEY_PRESS=8,
    GDK_KEY_RELEASE=9,
    GDK_LEAVE_NOTIFY=11,
    GDK_MAP=14,
    GDK_MOTION_NOTIFY=3,
    GDK_NOTHING=-1,
    GDK_NO_EXPOSE=30,
    GDK_OWNER_CHANGE=34,
    GDK_PROPERTY_NOTIFY=16,
    GDK_PROXIMITY_IN=20,
    GDK_PROXIMITY_OUT=21,
    GDK_SCROLL=31,
    GDK_SELECTION_CLEAR=17,
    GDK_SELECTION_NOTIFY=19,
    GDK_SELECTION_REQUEST=18,
    GDK_SETTING=33,
    GDK_UNMAP=15,
    GDK_VISIBILITY_NOTIFY=29,
    GDK_WINDOW_STATE=32
} GdkEventType;

typedef struct _GdkEventNoExpose _GdkEventNoExpose, *P_GdkEventNoExpose;

typedef struct _GdkEventNoExpose GdkEventNoExpose;

typedef struct _GdkEventOwnerChange _GdkEventOwnerChange, *P_GdkEventOwnerChange;

typedef struct _GdkEventOwnerChange GdkEventOwnerChange;

typedef struct _GdkEventDND _GdkEventDND, *P_GdkEventDND;

typedef struct _GdkEventDND GdkEventDND;

typedef struct _GdkEventSetting _GdkEventSetting, *P_GdkEventSetting;

typedef struct _GdkEventSetting GdkEventSetting;

typedef char gint8;

typedef struct _GdkDevice _GdkDevice, *P_GdkDevice;

typedef struct _GdkDevice GdkDevice;

typedef enum GdkScrollDirection {
    GDK_SCROLL_DOWN=1,
    GDK_SCROLL_LEFT=2,
    GDK_SCROLL_RIGHT=3,
    GDK_SCROLL_UP=0
} GdkScrollDirection;

typedef struct _GdkRegion _GdkRegion, *P_GdkRegion;

typedef struct _GdkRegion GdkRegion;

typedef enum GdkCrossingMode {
    GDK_CROSSING_GRAB=1,
    GDK_CROSSING_GTK_GRAB=3,
    GDK_CROSSING_GTK_UNGRAB=4,
    GDK_CROSSING_NORMAL=0,
    GDK_CROSSING_STATE_CHANGED=5,
    GDK_CROSSING_UNGRAB=2
} GdkCrossingMode;

typedef enum GdkNotifyType {
    GDK_NOTIFY_ANCESTOR=0,
    GDK_NOTIFY_INFERIOR=2,
    GDK_NOTIFY_NONLINEAR=3,
    GDK_NOTIFY_NONLINEAR_VIRTUAL=4,
    GDK_NOTIFY_UNKNOWN=5,
    GDK_NOTIFY_VIRTUAL=1
} GdkNotifyType;

typedef struct _GdkAtom _GdkAtom, *P_GdkAtom;

typedef struct _GdkAtom * GdkAtom;

typedef guint32 GdkNativeWindow;

typedef enum GdkVisibilityState {
    GDK_VISIBILITY_FULLY_OBSCURED=2,
    GDK_VISIBILITY_PARTIAL=1,
    GDK_VISIBILITY_UNOBSCURED=0
} GdkVisibilityState;

typedef ushort gushort;

typedef union anon_union_for_data anon_union_for_data, *Panon_union_for_data;

typedef enum GdkWindowState {
    GDK_WINDOW_STATE_ABOVE=32,
    GDK_WINDOW_STATE_BELOW=64,
    GDK_WINDOW_STATE_FULLSCREEN=16,
    GDK_WINDOW_STATE_ICONIFIED=2,
    GDK_WINDOW_STATE_MAXIMIZED=4,
    GDK_WINDOW_STATE_STICKY=8,
    GDK_WINDOW_STATE_WITHDRAWN=1
} GdkWindowState;

typedef struct _GdkDisplay _GdkDisplay, *P_GdkDisplay;

typedef struct _GdkDisplay GdkDisplay;

typedef enum GdkDragProtocol {
    GDK_DRAG_PROTO_LOCAL=6,
    GDK_DRAG_PROTO_MOTIF=0,
    GDK_DRAG_PROTO_NONE=3,
    GDK_DRAG_PROTO_OLE2=5,
    GDK_DRAG_PROTO_ROOTWIN=2,
    GDK_DRAG_PROTO_WIN32_DROPFILES=4,
    GDK_DRAG_PROTO_XDND=1
} GdkDragProtocol;

typedef enum GdkDragAction {
    GDK_ACTION_ASK=32,
    GDK_ACTION_COPY=2,
    GDK_ACTION_DEFAULT=1,
    GDK_ACTION_LINK=8,
    GDK_ACTION_MOVE=4,
    GDK_ACTION_PRIVATE=16
} GdkDragAction;

typedef enum AtkRole {
    ATK_ROLE_ACCEL_LABEL=1,
    ATK_ROLE_ALERT=2,
    ATK_ROLE_ANIMATION=3,
    ATK_ROLE_APPLICATION=73,
    ATK_ROLE_ARROW=4,
    ATK_ROLE_AUTOCOMPLETE=74,
    ATK_ROLE_CALENDAR=5,
    ATK_ROLE_CANVAS=6,
    ATK_ROLE_CAPTION=79,
    ATK_ROLE_CHART=78,
    ATK_ROLE_CHECK_BOX=7,
    ATK_ROLE_CHECK_MENU_ITEM=8,
    ATK_ROLE_COLOR_CHOOSER=9,
    ATK_ROLE_COLUMN_HEADER=10,
    ATK_ROLE_COMBO_BOX=11,
    ATK_ROLE_DATE_EDITOR=12,
    ATK_ROLE_DESKTOP_FRAME=14,
    ATK_ROLE_DESKTOP_ICON=13,
    ATK_ROLE_DIAL=15,
    ATK_ROLE_DIALOG=16,
    ATK_ROLE_DIRECTORY_PANE=17,
    ATK_ROLE_DOCUMENT_FRAME=80,
    ATK_ROLE_DRAWING_AREA=18,
    ATK_ROLE_EDITBAR=75,
    ATK_ROLE_EMBEDDED=76,
    ATK_ROLE_ENTRY=77,
    ATK_ROLE_FILE_CHOOSER=19,
    ATK_ROLE_FILLER=20,
    ATK_ROLE_FONT_CHOOSER=21,
    ATK_ROLE_FOOTER=70,
    ATK_ROLE_FORM=85,
    ATK_ROLE_FRAME=22,
    ATK_ROLE_GLASS_PANE=23,
    ATK_ROLE_HEADER=69,
    ATK_ROLE_HEADING=81,
    ATK_ROLE_HTML_CONTAINER=24,
    ATK_ROLE_ICON=25,
    ATK_ROLE_IMAGE=26,
    ATK_ROLE_INPUT_METHOD_WINDOW=87,
    ATK_ROLE_INTERNAL_FRAME=27,
    ATK_ROLE_INVALID=0,
    ATK_ROLE_LABEL=28,
    ATK_ROLE_LAST_DEFINED=88,
    ATK_ROLE_LAYERED_PANE=29,
    ATK_ROLE_LINK=86,
    ATK_ROLE_LIST=30,
    ATK_ROLE_LIST_ITEM=31,
    ATK_ROLE_MENU=32,
    ATK_ROLE_MENU_BAR=33,
    ATK_ROLE_MENU_ITEM=34,
    ATK_ROLE_OPTION_PANE=35,
    ATK_ROLE_PAGE=82,
    ATK_ROLE_PAGE_TAB=36,
    ATK_ROLE_PAGE_TAB_LIST=37,
    ATK_ROLE_PANEL=38,
    ATK_ROLE_PARAGRAPH=71,
    ATK_ROLE_PASSWORD_TEXT=39,
    ATK_ROLE_POPUP_MENU=40,
    ATK_ROLE_PROGRESS_BAR=41,
    ATK_ROLE_PUSH_BUTTON=42,
    ATK_ROLE_RADIO_BUTTON=43,
    ATK_ROLE_RADIO_MENU_ITEM=44,
    ATK_ROLE_REDUNDANT_OBJECT=84,
    ATK_ROLE_ROOT_PANE=45,
    ATK_ROLE_ROW_HEADER=46,
    ATK_ROLE_RULER=72,
    ATK_ROLE_SCROLL_BAR=47,
    ATK_ROLE_SCROLL_PANE=48,
    ATK_ROLE_SECTION=83,
    ATK_ROLE_SEPARATOR=49,
    ATK_ROLE_SLIDER=50,
    ATK_ROLE_SPIN_BUTTON=52,
    ATK_ROLE_SPLIT_PANE=51,
    ATK_ROLE_STATUSBAR=53,
    ATK_ROLE_TABLE=54,
    ATK_ROLE_TABLE_CELL=55,
    ATK_ROLE_TABLE_COLUMN_HEADER=56,
    ATK_ROLE_TABLE_ROW_HEADER=57,
    ATK_ROLE_TEAR_OFF_MENU_ITEM=58,
    ATK_ROLE_TERMINAL=59,
    ATK_ROLE_TEXT=60,
    ATK_ROLE_TOGGLE_BUTTON=61,
    ATK_ROLE_TOOL_BAR=62,
    ATK_ROLE_TOOL_TIP=63,
    ATK_ROLE_TREE=64,
    ATK_ROLE_TREE_TABLE=65,
    ATK_ROLE_UNKNOWN=66,
    ATK_ROLE_VIEWPORT=67,
    ATK_ROLE_WINDOW=68
} AtkRole;

typedef struct _AtkRelationSet _AtkRelationSet, *P_AtkRelationSet;

typedef struct _AtkRelationSet AtkRelationSet;

typedef enum AtkLayer {
    ATK_LAYER_BACKGROUND=1,
    ATK_LAYER_CANVAS=2,
    ATK_LAYER_INVALID=0,
    ATK_LAYER_MDI=4,
    ATK_LAYER_OVERLAY=6,
    ATK_LAYER_POPUP=5,
    ATK_LAYER_WIDGET=3,
    ATK_LAYER_WINDOW=7
} AtkLayer;

typedef enum GdkOwnerChange {
    GDK_OWNER_CHANGE_CLOSE=2,
    GDK_OWNER_CHANGE_DESTROY=1,
    GDK_OWNER_CHANGE_NEW_OWNER=0
} GdkOwnerChange;

typedef short gshort;

typedef enum GdkSettingAction {
    GDK_SETTING_ACTION_CHANGED=1,
    GDK_SETTING_ACTION_DELETED=2,
    GDK_SETTING_ACTION_NEW=0
} GdkSettingAction;

typedef enum GdkInputSource {
    GDK_SOURCE_CURSOR=3,
    GDK_SOURCE_ERASER=2,
    GDK_SOURCE_MOUSE=0,
    GDK_SOURCE_PEN=1
} GdkInputSource;

typedef enum GdkInputMode {
    GDK_MODE_DISABLED=0,
    GDK_MODE_SCREEN=1,
    GDK_MODE_WINDOW=2
} GdkInputMode;

typedef struct _GdkDeviceAxis _GdkDeviceAxis, *P_GdkDeviceAxis;

typedef struct _GdkDeviceAxis GdkDeviceAxis;

typedef struct _GdkDeviceKey _GdkDeviceKey, *P_GdkDeviceKey;

typedef struct _GdkDeviceKey GdkDeviceKey;

typedef struct _GdkDisplayPointerHooks _GdkDisplayPointerHooks, *P_GdkDisplayPointerHooks;

typedef struct _GdkDisplayPointerHooks GdkDisplayPointerHooks;

typedef struct GdkKeyboardGrabInfo GdkKeyboardGrabInfo, *PGdkKeyboardGrabInfo;

typedef struct GdkPointerWindowInfo GdkPointerWindowInfo, *PGdkPointerWindowInfo;

typedef enum GdkAxisUse {
    GDK_AXIS_IGNORE=0,
    GDK_AXIS_LAST=7,
    GDK_AXIS_PRESSURE=3,
    GDK_AXIS_WHEEL=6,
    GDK_AXIS_X=1,
    GDK_AXIS_XTILT=4,
    GDK_AXIS_Y=2,
    GDK_AXIS_YTILT=5
} GdkAxisUse;

struct GdkKeyboardGrabInfo {
    GdkWindow * window;
    GdkWindow * native_window;
    gulong serial;
    gboolean owner_events;
    guint32 time;
};

struct GdkPointerWindowInfo {
    GdkWindow * toplevel_under_pointer;
    GdkWindow * window_under_pointer;
    gdouble toplevel_x;
    gdouble toplevel_y;
    guint32 state;
    guint32 button;
    gulong motion_hint_serial;
};

struct _GdkDisplay {
    GObject parent_instance;
    GList * queued_events;
    GList * queued_tail;
    guint32 button_click_time[2];
    GdkWindow * button_window[2];
    gint button_number[2];
    guint double_click_time;
    GdkDevice * core_pointer;
    GdkDisplayPointerHooks * pointer_hooks;
    guint closed:1;
    guint ignore_core_events:1;
    undefined field_0x39;
    undefined field_0x3a;
    undefined field_0x3b;
    guint double_click_distance;
    gint button_x[2];
    gint button_y[2];
    GList * pointer_grabs;
    struct GdkKeyboardGrabInfo keyboard_grab;
    struct GdkPointerWindowInfo pointer_info;
    guint32 last_event_time;
};

struct _GdkEventScroll {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    guint32 time;
    gdouble x;
    gdouble y;
    guint state;
    enum GdkScrollDirection direction;
    GdkDevice * device;
    gdouble x_root;
    gdouble y_root;
};

struct _GdkEventCrossing {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkWindow * subwindow;
    guint32 time;
    gdouble x;
    gdouble y;
    gdouble x_root;
    gdouble y_root;
    enum GdkCrossingMode mode;
    enum GdkNotifyType detail;
    gboolean focus;
    guint state;
};

struct _GdkEventGrabBroken {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    gboolean keyboard;
    gboolean implicit;
    GdkWindow * grab_window;
};

union anon_union_for_data {
    char b[20];
    short s[10];
    long l[5];
};

struct _GdkDragContext {
    GObject parent_instance;
    enum GdkDragProtocol protocol;
    gboolean is_source;
    GdkWindow * source_window;
    GdkWindow * dest_window;
    GList * targets;
    enum GdkDragAction actions;
    enum GdkDragAction suggested_action;
    enum GdkDragAction action;
    guint32 start_time;
    gpointer windowing_data;
};

struct _GdkDeviceKey {
    guint keyval;
    enum GdkModifierType modifiers;
};

struct _GdkEventMotion {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    guint32 time;
    gdouble x;
    gdouble y;
    gdouble * axes;
    guint state;
    gint16 is_hint;
    undefined field_0x2a;
    undefined field_0x2b;
    GdkDevice * device;
    gdouble x_root;
    gdouble y_root;
};

struct _GdkEventKey {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    guint32 time;
    guint state;
    guint keyval;
    gint length;
    gchar * string;
    guint16 hardware_keycode;
    guint8 group;
    guint is_modifier:1;
};

struct _GdkEventProperty {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkAtom atom;
    guint32 time;
    guint state;
};

struct _GdkEventProximity {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    guint32 time;
    GdkDevice * device;
};

struct _GdkEventExpose {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkRectangle area;
    GdkRegion * region;
    gint count;
};

struct _AtkObject {
    GObject parent;
    gchar * description;
    gchar * name;
    AtkObject * accessible_parent;
    enum AtkRole role;
    AtkRelationSet * relation_set;
    enum AtkLayer layer;
};

struct _GdkAtom {
};

struct _GdkEventWindowState {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    enum GdkWindowState changed_mask;
    enum GdkWindowState new_window_state;
};

struct _AtkRelationSet {
    GObject parent;
    GPtrArray * relations;
};

struct _GdkEventDND {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkDragContext * context;
    guint32 time;
    gshort x_root;
    gshort y_root;
};

struct _GdkEventClient {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkAtom message_type;
    gushort data_format;
    undefined field_0x12;
    undefined field_0x13;
    union anon_union_for_data data;
};

struct _GdkEventConfigure {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    gint x;
    gint y;
    gint width;
    gint height;
};

struct _GdkEventSelection {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkAtom selection;
    GdkAtom target;
    GdkAtom property;
    guint32 time;
    GdkNativeWindow requestor;
};

struct _GdkEventOwnerChange {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    GdkNativeWindow owner;
    enum GdkOwnerChange reason;
    GdkAtom selection;
    guint32 time;
    guint32 selection_time;
};

struct _GdkEventFocus {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    gint16 in;
};

struct _GdkEventAny {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

struct _GdkEventVisibility {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    enum GdkVisibilityState state;
};

struct _GdkEventButton {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    guint32 time;
    gdouble x;
    gdouble y;
    gdouble * axes;
    guint state;
    guint button;
    GdkDevice * device;
    gdouble x_root;
    gdouble y_root;
};

struct _GdkEventSetting {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    enum GdkSettingAction action;
    char * name;
};

struct _GdkEventNoExpose {
    enum GdkEventType type;
    GdkWindow * window;
    gint8 send_event;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

union _GdkEvent {
    enum GdkEventType type;
    GdkEventAny any;
    GdkEventExpose expose;
    GdkEventNoExpose no_expose;
    GdkEventVisibility visibility;
    GdkEventMotion motion;
    GdkEventButton button;
    GdkEventScroll scroll;
    GdkEventKey key;
    GdkEventCrossing crossing;
    GdkEventFocus focus_change;
    GdkEventConfigure configure;
    GdkEventProperty property;
    GdkEventSelection selection;
    GdkEventOwnerChange owner_change;
    GdkEventProximity proximity;
    GdkEventClient client;
    GdkEventDND dnd;
    GdkEventWindowState window_state;
    GdkEventSetting setting;
    GdkEventGrabBroken grab_broken;
};

struct _GdkDisplayPointerHooks {
    void (* get_pointer)(GdkDisplay *, GdkScreen * *, gint *, gint *, enum GdkModifierType *);
    GdkWindow * (* window_get_pointer)(GdkDisplay *, GdkWindow *, gint *, gint *, enum GdkModifierType *);
    GdkWindow * (* window_at_pointer)(GdkDisplay *, gint *, gint *);
};

struct _GtkObjectClass {
    GInitiallyUnownedClass parent_class;
    void (* set_arg)(GtkObject *, GtkArg *, guint);
    void (* get_arg)(GtkObject *, GtkArg *, guint);
    void (* destroy)(GtkObject *);
};

struct _GtkWidgetClass {
    GtkObjectClass parent_class;
    guint activate_signal;
    guint set_scroll_adjustments_signal;
    void (* dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec * *);
    void (* show)(GtkWidget *);
    void (* show_all)(GtkWidget *);
    void (* hide)(GtkWidget *);
    void (* hide_all)(GtkWidget *);
    void (* map)(GtkWidget *);
    void (* unmap)(GtkWidget *);
    void (* realize)(GtkWidget *);
    void (* unrealize)(GtkWidget *);
    void (* size_request)(GtkWidget *, GtkRequisition *);
    void (* size_allocate)(GtkWidget *, GtkAllocation *);
    void (* state_changed)(GtkWidget *, enum GtkStateType);
    void (* parent_set)(GtkWidget *, GtkWidget *);
    void (* hierarchy_changed)(GtkWidget *, GtkWidget *);
    void (* style_set)(GtkWidget *, GtkStyle *);
    void (* direction_changed)(GtkWidget *, enum GtkTextDirection);
    void (* grab_notify)(GtkWidget *, gboolean);
    void (* child_notify)(GtkWidget *, GParamSpec *);
    gboolean (* mnemonic_activate)(GtkWidget *, gboolean);
    void (* grab_focus)(GtkWidget *);
    gboolean (* focus)(GtkWidget *, enum GtkDirectionType);
    gboolean (* event)(GtkWidget *, GdkEvent *);
    gboolean (* button_press_event)(GtkWidget *, GdkEventButton *);
    gboolean (* button_release_event)(GtkWidget *, GdkEventButton *);
    gboolean (* scroll_event)(GtkWidget *, GdkEventScroll *);
    gboolean (* motion_notify_event)(GtkWidget *, GdkEventMotion *);
    gboolean (* delete_event)(GtkWidget *, GdkEventAny *);
    gboolean (* destroy_event)(GtkWidget *, GdkEventAny *);
    gboolean (* expose_event)(GtkWidget *, GdkEventExpose *);
    gboolean (* key_press_event)(GtkWidget *, GdkEventKey *);
    gboolean (* key_release_event)(GtkWidget *, GdkEventKey *);
    gboolean (* enter_notify_event)(GtkWidget *, GdkEventCrossing *);
    gboolean (* leave_notify_event)(GtkWidget *, GdkEventCrossing *);
    gboolean (* configure_event)(GtkWidget *, GdkEventConfigure *);
    gboolean (* focus_in_event)(GtkWidget *, GdkEventFocus *);
    gboolean (* focus_out_event)(GtkWidget *, GdkEventFocus *);
    gboolean (* map_event)(GtkWidget *, GdkEventAny *);
    gboolean (* unmap_event)(GtkWidget *, GdkEventAny *);
    gboolean (* property_notify_event)(GtkWidget *, GdkEventProperty *);
    gboolean (* selection_clear_event)(GtkWidget *, GdkEventSelection *);
    gboolean (* selection_request_event)(GtkWidget *, GdkEventSelection *);
    gboolean (* selection_notify_event)(GtkWidget *, GdkEventSelection *);
    gboolean (* proximity_in_event)(GtkWidget *, GdkEventProximity *);
    gboolean (* proximity_out_event)(GtkWidget *, GdkEventProximity *);
    gboolean (* visibility_notify_event)(GtkWidget *, GdkEventVisibility *);
    gboolean (* client_event)(GtkWidget *, GdkEventClient *);
    gboolean (* no_expose_event)(GtkWidget *, GdkEventAny *);
    gboolean (* window_state_event)(GtkWidget *, GdkEventWindowState *);
    void (* selection_get)(GtkWidget *, GtkSelectionData *, guint, guint);
    void (* selection_received)(GtkWidget *, GtkSelectionData *, guint);
    void (* drag_begin)(GtkWidget *, GdkDragContext *);
    void (* drag_end)(GtkWidget *, GdkDragContext *);
    void (* drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint);
    void (* drag_data_delete)(GtkWidget *, GdkDragContext *);
    void (* drag_leave)(GtkWidget *, GdkDragContext *, guint);
    gboolean (* drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint);
    gboolean (* drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint);
    void (* drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint);
    gboolean (* popup_menu)(GtkWidget *);
    gboolean (* show_help)(GtkWidget *, enum GtkWidgetHelpType);
    AtkObject * (* get_accessible)(GtkWidget *);
    void (* screen_changed)(GtkWidget *, GdkScreen *);
    gboolean (* can_activate_accel)(GtkWidget *, guint);
    gboolean (* grab_broken_event)(GtkWidget *, GdkEventGrabBroken *);
    void (* composited_changed)(GtkWidget *);
    gboolean (* query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *);
    void (* _gtk_reserved5)(void);
    void (* _gtk_reserved6)(void);
    void (* _gtk_reserved7)(void);
};

struct _GdkDevice {
    GObject parent_instance;
    gchar * name;
    enum GdkInputSource source;
    enum GdkInputMode mode;
    gboolean has_cursor;
    gint num_axes;
    GdkDeviceAxis * axes;
    gint num_keys;
    GdkDeviceKey * keys;
};

struct _GdkRegion {
};

struct _GtkSelectionData {
    GdkAtom selection;
    GdkAtom target;
    GdkAtom type;
    gint format;
    guchar * data;
    gint length;
    GdkDisplay * display;
};

struct _GdkDeviceAxis {
    enum GdkAxisUse use;
    gdouble min;
    gdouble max;
};

typedef char * __gnuc_va_list;

typedef struct DBusTimeout DBusTimeout, *PDBusTimeout;

struct DBusTimeout {
};

typedef enum DBusDispatchStatus {
    DBUS_DISPATCH_COMPLETE=1,
    DBUS_DISPATCH_DATA_REMAINS=0,
    DBUS_DISPATCH_NEED_MEMORY=2
} DBusDispatchStatus;

typedef struct DBusWatch DBusWatch, *PDBusWatch;

struct DBusWatch {
};

typedef struct DBusConnection DBusConnection, *PDBusConnection;

struct DBusConnection {
};

typedef struct DBusObjectPathVTable DBusObjectPathVTable, *PDBusObjectPathVTable;

typedef enum DBusHandlerResult {
    DBUS_HANDLER_RESULT_HANDLED=0,
    DBUS_HANDLER_RESULT_NEED_MEMORY=2,
    DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1
} DBusHandlerResult;

typedef struct DBusMessage DBusMessage, *PDBusMessage;

struct DBusMessage {
};

struct DBusObjectPathVTable {
    void (* unregister_function)(struct DBusConnection *, void *);
    DBusHandlerResult (* message_function)(struct DBusConnection *, struct DBusMessage *, void *);
    void (* dbus_internal_pad1)(void *);
    void (* dbus_internal_pad2)(void *);
    void (* dbus_internal_pad3)(void *);
    void (* dbus_internal_pad4)(void *);
};

typedef struct _StringList _StringList, *P_StringList;

typedef struct _StringList StringList;

struct _StringList {
    char * str;
    struct _StringList * next;
};

typedef struct _BomList _BomList, *P_BomList;

struct _BomList {
    char * descr;
    char * value;
    int num;
    StringList * refdes;
    struct _BomList * next;
};

typedef struct _BomList BomList;

typedef guint32 gunichar;

typedef struct _GtkTextPendingScroll _GtkTextPendingScroll, *P_GtkTextPendingScroll;

typedef struct _GtkTextPendingScroll GtkTextPendingScroll;

struct _GtkTextPendingScroll {
};

typedef struct _GtkTextView _GtkTextView, *P_GtkTextView;

typedef struct _GtkTextLayout _GtkTextLayout, *P_GtkTextLayout;

typedef struct _GtkTextBuffer _GtkTextBuffer, *P_GtkTextBuffer;

typedef struct _GtkTextBuffer GtkTextBuffer;

typedef enum GtkWrapMode {
    GTK_WRAP_CHAR=1,
    GTK_WRAP_NONE=0,
    GTK_WRAP_WORD=2,
    GTK_WRAP_WORD_CHAR=3
} GtkWrapMode;

typedef enum GtkJustification {
    GTK_JUSTIFY_CENTER=2,
    GTK_JUSTIFY_FILL=3,
    GTK_JUSTIFY_LEFT=0,
    GTK_JUSTIFY_RIGHT=1
} GtkJustification;

typedef struct _PangoTabArray _PangoTabArray, *P_PangoTabArray;

typedef struct _PangoTabArray PangoTabArray;

typedef struct _GtkTextWindow _GtkTextWindow, *P_GtkTextWindow;

typedef struct _GtkTextWindow GtkTextWindow;

typedef struct _GtkAdjustment _GtkAdjustment, *P_GtkAdjustment;

typedef struct _GtkAdjustment GtkAdjustment;

typedef struct _GtkIMContext _GtkIMContext, *P_GtkIMContext;

typedef struct _GtkIMContext GtkIMContext;

typedef struct _GtkTextTagTable _GtkTextTagTable, *P_GtkTextTagTable;

typedef struct _GtkTextTagTable GtkTextTagTable;

typedef struct _GtkTextBTree _GtkTextBTree, *P_GtkTextBTree;

typedef struct _GtkTextBTree GtkTextBTree;

typedef struct _GtkTextLogAttrCache _GtkTextLogAttrCache, *P_GtkTextLogAttrCache;

typedef struct _GtkTextLogAttrCache GtkTextLogAttrCache;

typedef struct _GHashTable _GHashTable, *P_GHashTable;

typedef struct _GHashTable GHashTable;

struct _GHashTable {
};

struct _GtkTextView {
    GtkContainer parent_instance;
    struct _GtkTextLayout * layout;
    GtkTextBuffer * buffer;
    guint selection_drag_handler;
    guint scroll_timeout;
    gint pixels_above_lines;
    gint pixels_below_lines;
    gint pixels_inside_wrap;
    enum GtkWrapMode wrap_mode;
    enum GtkJustification justify;
    gint left_margin;
    gint right_margin;
    gint indent;
    PangoTabArray * tabs;
    guint editable:1;
    guint overwrite_mode:1;
    guint cursor_visible:1;
    guint need_im_reset:1;
    guint accepts_tab:1;
    guint width_changed:1;
    guint onscreen_validated:1;
    guint mouse_cursor_obscured:1;
    undefined field_0x79;
    undefined field_0x7a;
    undefined field_0x7b;
    GtkTextWindow * text_window;
    GtkTextWindow * left_window;
    GtkTextWindow * right_window;
    GtkTextWindow * top_window;
    GtkTextWindow * bottom_window;
    GtkAdjustment * hadjustment;
    GtkAdjustment * vadjustment;
    gint xoffset;
    gint yoffset;
    gint width;
    gint height;
    gint virtual_cursor_x;
    gint virtual_cursor_y;
    GtkTextMark * first_para_mark;
    gint first_para_pixels;
    GtkTextMark * dnd_mark;
    guint blink_timeout;
    guint first_validate_idle;
    guint incremental_validate_idle;
    GtkIMContext * im_context;
    GtkWidget * popup_menu;
    gint drag_start_x;
    gint drag_start_y;
    GSList * children;
    GtkTextPendingScroll * pending_scroll;
    gint pending_place_cursor_button;
};

struct _GtkTextLogAttrCache {
};

struct _GtkTextBTree {
};

struct _GtkTextBuffer {
    GObject parent_instance;
    GtkTextTagTable * tag_table;
    GtkTextBTree * btree;
    GSList * clipboard_contents_buffers;
    GSList * selection_clipboards;
    GtkTextLogAttrCache * log_attr_cache;
    guint user_action_count;
    guint modified:1;
    guint has_selection:1;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
};

struct _GtkTextTagTable {
    GObject parent_instance;
    GHashTable * hash;
    GSList * anonymous;
    gint anon_count;
    GSList * buffers;
};

struct _GtkTextLayout {
};

struct _GtkAdjustment {
    GtkObject parent_instance;
    gdouble lower;
    gdouble upper;
    gdouble value;
    gdouble step_increment;
    gdouble page_increment;
    gdouble page_size;
};

struct _GtkIMContext {
    GObject parent_instance;
};

struct _PangoTabArray {
};

struct _GtkTextWindow {
};

typedef enum GIOStatus {
    G_IO_STATUS_AGAIN=3,
    G_IO_STATUS_EOF=2,
    G_IO_STATUS_ERROR=0,
    G_IO_STATUS_NORMAL=1
} GIOStatus;

typedef struct _GIOChannel _GIOChannel, *P_GIOChannel;

typedef struct _GIOFuncs _GIOFuncs, *P_GIOFuncs;

typedef struct _GIOChannel GIOChannel;

typedef struct _GError _GError, *P_GError;

typedef struct _GError GError;

typedef enum GSeekType {
    G_SEEK_CUR=0,
    G_SEEK_END=2,
    G_SEEK_SET=1
} GSeekType;

typedef struct _GSource _GSource, *P_GSource;

typedef struct _GSource GSource;

typedef enum GIOCondition {
    G_IO_ERR=8,
    G_IO_HUP=16,
    G_IO_IN=1,
    G_IO_NVAL=32,
    G_IO_OUT=4,
    G_IO_PRI=2
} GIOCondition;

typedef enum GIOFlags {
    G_IO_FLAG_APPEND=1,
    G_IO_FLAG_GET_MASK=31,
    G_IO_FLAG_IS_READABLE=4,
    G_IO_FLAG_IS_SEEKABLE=16,
    G_IO_FLAG_IS_WRITEABLE=8,
    G_IO_FLAG_MASK=31,
    G_IO_FLAG_NONBLOCK=2,
    G_IO_FLAG_SET_MASK=3
} GIOFlags;

typedef struct _GIOFuncs GIOFuncs;

typedef struct _GIConv _GIConv, *P_GIConv;

typedef struct _GIConv * GIConv;

typedef struct _GString _GString, *P_GString;

typedef struct _GString GString;

typedef guint32 GQuark;

typedef struct _GSourceCallbackFuncs _GSourceCallbackFuncs, *P_GSourceCallbackFuncs;

typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;

typedef struct _GSourceFuncs _GSourceFuncs, *P_GSourceFuncs;

typedef struct _GSourceFuncs GSourceFuncs;

typedef struct _GMainContext _GMainContext, *P_GMainContext;

typedef struct _GMainContext GMainContext;

struct _GMainContext {
};

struct _GSourceFuncs {
    gboolean (* prepare)(GSource *, gint *);
    gboolean (* check)(GSource *);
    gboolean (* dispatch)(GSource *, gboolean (* )(gpointer), gpointer);
    void (* finalize)(GSource *);
    gboolean (* closure_callback)(gpointer);
    void (* closure_marshal)(void);
};

struct _GSource {
    gpointer callback_data;
    GSourceCallbackFuncs * callback_funcs;
    GSourceFuncs * source_funcs;
    guint ref_count;
    GMainContext * context;
    gint priority;
    guint flags;
    guint source_id;
    GSList * poll_fds;
    GSource * prev;
    GSource * next;
    char * name;
    gpointer reserved2;
};

struct _GString {
    gchar * str;
    gsize len;
    gsize allocated_len;
};

struct _GIConv {
};

struct _GIOChannel {
    gint ref_count;
    GIOFuncs * funcs;
    gchar * encoding;
    GIConv read_cd;
    GIConv write_cd;
    gchar * line_term;
    guint line_term_len;
    gsize buf_size;
    GString * read_buf;
    GString * encoded_read_buf;
    GString * write_buf;
    gchar partial_write_buf[6];
    guint use_buffer:1;
    guint do_encode:1;
    guint close_on_unref:1;
    guint is_readable:1;
    guint is_writeable:1;
    guint is_seekable:1;
    undefined field_0x33;
    gpointer reserved1;
    gpointer reserved2;
};

struct _GError {
    GQuark domain;
    gint code;
    gchar * message;
};

struct _GSourceCallbackFuncs {
    void (* ref)(gpointer);
    void (* unref)(gpointer);
    void (* get)(gpointer, GSource *, gboolean (** )(gpointer), gpointer *);
};

struct _GIOFuncs {
    GIOStatus (* io_read)(GIOChannel *, gchar *, gsize, gsize *, GError * *);
    GIOStatus (* io_write)(GIOChannel *, gchar *, gsize, gsize *, GError * *);
    GIOStatus (* io_seek)(GIOChannel *, gint64, enum GSeekType, GError * *);
    GIOStatus (* io_close)(GIOChannel *, GError * *);
    GSource * (* io_create_watch)(GIOChannel *, enum GIOCondition);
    void (* io_free)(GIOChannel *);
    GIOStatus (* io_set_flags)(GIOChannel *, enum GIOFlags, GError * *);
    GIOFlags (* io_get_flags)(GIOChannel *);
};

typedef struct _GtkPanedPrivate _GtkPanedPrivate, *P_GtkPanedPrivate;

typedef struct _GtkPanedPrivate GtkPanedPrivate;

struct _GtkPanedPrivate {
};

typedef struct _GtkPaned _GtkPaned, *P_GtkPaned;

typedef enum GdkCursorType {
    GDK_ARROW=2,
    GDK_BASED_ARROW_DOWN=4,
    GDK_BASED_ARROW_UP=6,
    GDK_BLANK_CURSOR=-2,
    GDK_BOAT=8,
    GDK_BOGOSITY=10,
    GDK_BOTTOM_LEFT_CORNER=12,
    GDK_BOTTOM_RIGHT_CORNER=14,
    GDK_BOTTOM_SIDE=16,
    GDK_BOTTOM_TEE=18,
    GDK_BOX_SPIRAL=20,
    GDK_CENTER_PTR=22,
    GDK_CIRCLE=24,
    GDK_CLOCK=26,
    GDK_COFFEE_MUG=28,
    GDK_CROSS=30,
    GDK_CROSSHAIR=34,
    GDK_CROSS_REVERSE=32,
    GDK_CURSOR_IS_PIXMAP=-1,
    GDK_DIAMOND_CROSS=36,
    GDK_DOT=38,
    GDK_DOTBOX=40,
    GDK_DOUBLE_ARROW=42,
    GDK_DRAFT_LARGE=44,
    GDK_DRAFT_SMALL=46,
    GDK_DRAPED_BOX=48,
    GDK_EXCHANGE=50,
    GDK_FLEUR=52,
    GDK_GOBBLER=54,
    GDK_GUMBY=56,
    GDK_HAND1=58,
    GDK_HAND2=60,
    GDK_HEART=62,
    GDK_ICON=64,
    GDK_IRON_CROSS=66,
    GDK_LAST_CURSOR=153,
    GDK_LEFTBUTTON=74,
    GDK_LEFT_PTR=68,
    GDK_LEFT_SIDE=70,
    GDK_LEFT_TEE=72,
    GDK_LL_ANGLE=76,
    GDK_LR_ANGLE=78,
    GDK_MAN=80,
    GDK_MIDDLEBUTTON=82,
    GDK_MOUSE=84,
    GDK_PENCIL=86,
    GDK_PIRATE=88,
    GDK_PLUS=90,
    GDK_QUESTION_ARROW=92,
    GDK_RIGHTBUTTON=100,
    GDK_RIGHT_PTR=94,
    GDK_RIGHT_SIDE=96,
    GDK_RIGHT_TEE=98,
    GDK_RTL_LOGO=102,
    GDK_SAILBOAT=104,
    GDK_SB_DOWN_ARROW=106,
    GDK_SB_H_DOUBLE_ARROW=108,
    GDK_SB_LEFT_ARROW=110,
    GDK_SB_RIGHT_ARROW=112,
    GDK_SB_UP_ARROW=114,
    GDK_SB_V_DOUBLE_ARROW=116,
    GDK_SHUTTLE=118,
    GDK_SIZING=120,
    GDK_SPIDER=122,
    GDK_SPRAYCAN=124,
    GDK_STAR=126,
    GDK_TARGET=128,
    GDK_TCROSS=130,
    GDK_TOP_LEFT_ARROW=132,
    GDK_TOP_LEFT_CORNER=134,
    GDK_TOP_RIGHT_CORNER=136,
    GDK_TOP_SIDE=138,
    GDK_TOP_TEE=140,
    GDK_TREK=142,
    GDK_UL_ANGLE=144,
    GDK_UMBRELLA=146,
    GDK_UR_ANGLE=148,
    GDK_WATCH=150,
    GDK_XTERM=152,
    GDK_X_CURSOR=0
} GdkCursorType;

struct _GtkPaned {
    GtkContainer container;
    GtkWidget * child1;
    GtkWidget * child2;
    GdkWindow * handle;
    GdkGC * xor_gc;
    enum GdkCursorType cursor_type;
    GdkRectangle handle_pos;
    gint child1_size;
    gint last_allocation;
    gint min_position;
    gint max_position;
    guint position_set:1;
    guint in_drag:1;
    guint child1_shrink:1;
    guint child1_resize:1;
    guint child2_shrink:1;
    guint child2_resize:1;
    guint orientation:1;
    guint in_recursion:1;
    guint handle_prelit:1;
    undefined field_0x7a;
    undefined field_0x7b;
    GtkWidget * last_child1_focus;
    GtkWidget * last_child2_focus;
    GtkPanedPrivate * priv;
    gint drag_pos;
    gint original_position;
};

typedef struct _GtkFrame _GtkFrame, *P_GtkFrame;

struct _GtkFrame {
    GtkBin bin;
    GtkWidget * label_widget;
    gint16 shadow_type;
    undefined field_0x4e;
    undefined field_0x4f;
    gfloat label_xalign;
    gfloat label_yalign;
    GtkAllocation child_allocation;
};

typedef struct re_pattern_buffer re_pattern_buffer, *Pre_pattern_buffer;

typedef ulong reg_syntax_t;


// WARNING! conflicting data type names: /DWARF/stddef.h/size_t - /stddef.h/size_t

struct re_pattern_buffer {
    uchar * buffer;
    ulong allocated;
    ulong used;
    reg_syntax_t syntax;
    char * fastmap;
    uchar * translate;
    size_t re_nsub;
    uint can_be_null:1;
    uint regs_allocated:2;
    uint fastmap_accurate:1;
    uint no_sub:1;
    uint not_bol:1;
    uint not_eol:1;
    uint newline_anchor:1;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct re_pattern_buffer regex_t;

typedef int regoff_t;

typedef struct regmatch_t regmatch_t, *Pregmatch_t;

struct regmatch_t {
    regoff_t rm_so;
    regoff_t rm_eo;
};

typedef struct BlockHookSource BlockHookSource, *PBlockHookSource;

typedef union hidval hidval, *Phidval;

union hidval {
    long lval;
    void * ptr;
};

struct BlockHookSource {
    GSource source;
    void (* func)(union hidval);
    union hidval user_data;
};

typedef struct GuiTimer GuiTimer, *PGuiTimer;

struct GuiTimer {
    void (* func)(...);
    gint id;
    union hidval user_data;
};

typedef struct GuiWatch GuiWatch, *PGuiWatch;

struct GuiWatch {
    void (* func)(union hidval, int, uint, union hidval);
    union hidval user_data;
    int fd;
    GIOChannel * channel;
    gint id;
};

typedef struct ColorCache ColorCache, *PColorCache;

struct ColorCache {
    int color_set;
    GdkColor color;
    int xor_set;
    GdkColor xor_color;
};

typedef struct RemovedPointType RemovedPointType, *PRemovedPointType;

struct RemovedPointType {
    LocationType X;
    LocationType Y;
    int ID;
    Cardinal Index;
};

typedef struct LayerChangeType LayerChangeType, *PLayerChangeType;

typedef struct LayerChangeType * LayerChangeTypePtr;

struct LayerChangeType {
    int old_index;
    int new_index;
};

typedef struct ChangeNameType ChangeNameType, *PChangeNameType;

struct ChangeNameType {
    char * Name;
};

typedef struct anon_struct.conflict48 anon_struct.conflict48, *Panon_struct.conflict48;

typedef union anon_union_for_Data anon_union_for_Data, *Panon_union_for_Data;

typedef struct MoveType MoveType, *PMoveType;

typedef struct RotateType RotateType, *PRotateType;

typedef struct MoveToLayerType MoveToLayerType, *PMoveToLayerType;

typedef struct ClearPolyType ClearPolyType, *PClearPolyType;

typedef struct NetlistChangeType NetlistChangeType, *PNetlistChangeType;

typedef uchar BYTE;

typedef struct LayerType LayerType, *PLayerType;

typedef struct LayerType * LayerTypePtr;

typedef struct LibraryType LibraryType, *PLibraryType;

typedef struct LibraryType * LibraryTypePtr;

typedef struct TextType TextType, *PTextType;

typedef struct TextType * TextTypePtr;

typedef struct polygon_st polygon_st, *Ppolygon_st;

typedef struct polygon_st * PolygonTypePtr;

typedef struct ArcTypePtr ArcTypePtr, *PArcTypePtr;

typedef struct rtree rtree, *Prtree;

typedef struct rtree rtree_t;

typedef struct AttributeListType AttributeListType, *PAttributeListType;

typedef struct LibraryMenuTypePtr LibraryMenuTypePtr, *PLibraryMenuTypePtr;

typedef struct POLYAREA POLYAREA, *PPOLYAREA;

typedef struct PLINE PLINE, *PPLINE;

typedef struct rtree_node rtree_node, *Prtree_node;

typedef struct AttributeType AttributeType, *PAttributeType;

typedef struct VNODE VNODE, *PVNODE;

typedef struct anon_struct_for_Flags anon_struct_for_Flags, *Panon_struct_for_Flags;

typedef struct anon_struct_for_flags anon_struct_for_flags, *Panon_struct_for_flags;

typedef union anon_union_for_u anon_union_for_u, *Panon_union_for_u;


// WARNING! conflicting data type names: /DWARF/polyarea.h/VNODE/anon_struct_for_Flags - /DWARF/polyarea.h/PLINE/anon_struct_for_Flags

typedef struct CVCList CVCList, *PCVCList;

typedef int vertex[2];

typedef vertex Vector;

typedef struct Rentry Rentry, *PRentry;

struct POLYAREA {
    struct POLYAREA * f;
    struct POLYAREA * b;
    struct PLINE * contours;
};

struct anon_struct_for_Flags {
    uint status:3;
    uint orient:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

struct anon_struct_for_flags {
    uint is_leaf:1;
    uint manage:31;
};

struct Rentry {
    struct BoxType * bptr;
    struct BoxType bounds;
};

union anon_union_for_u {
    struct rtree_node * kids[7];
    struct Rentry rects[7];
};

struct rtree_node {
    struct BoxType box;
    struct rtree_node * parent;
    struct anon_struct_for_flags flags;
    union anon_union_for_u u;
};

struct LibraryMenuTypePtr {
    char * Name;
    char * directory;
    char * Style;
    Cardinal EntryN;
    Cardinal EntryMax;
    struct LibraryEntryTypePtr * Entry;
    char flag;
    char internal;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct VNODE {
    struct VNODE * next;
    struct VNODE * prev;
    struct VNODE * shared;
    struct anon_struct_for_Flags Flags;
    struct CVCList * cvc_prev;
    struct CVCList * cvc_next;
    Vector point;
};

struct PLINE {
    int xmin;
    int ymin;
    int xmax;
    int ymax;
    struct PLINE * next;
    struct VNODE head;
    uint Count;
    double area;
    rtree_t * tree;
    struct anon_struct_for_Flags Flags;
};

struct ArcTypePtr {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    LocationType Width;
    LocationType Height;
    LocationType X;
    LocationType Y;
    long StartAngle;
    long Delta;
};

struct MoveToLayerType {
    Cardinal OriginalLayer;
};

struct RotateType {
    LocationType CenterX;
    LocationType CenterY;
    BYTE Steps;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

struct MoveType {
    LocationType DX;
    LocationType DY;
};

struct NetlistChangeType {
    LibraryTypePtr old;
    LibraryTypePtr lib;
};

struct ClearPolyType {
    Boolean Clear;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    LayerTypePtr Layer;
};

union anon_union_for_Data {
    struct ChangeNameType ChangeName;
    struct MoveType Move;
    struct RemovedPointType RemovedPoint;
    struct RotateType Rotate;
    struct MoveToLayerType MoveToLayer;
    struct FlagType Flags;
    BDimension Size;
    struct LayerChangeType LayerChange;
    struct ClearPolyType ClearPoly;
    struct NetlistChangeType NetlistChange;
};

struct AttributeListType {
    int Number;
    int Max;
    struct AttributeType * List;
};

struct AttributeType {
    char * name;
    char * value;
};

struct LibraryType {
    Cardinal MenuN;
    Cardinal MenuMax;
    struct LibraryMenuTypePtr * Menu;
};

struct anon_struct.conflict48 {
    int Serial;
    int Type;
    int Kind;
    int ID;
    union anon_union_for_Data Data;
};

struct rtree {
    struct rtree_node * root;
    int size;
};

struct TextType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Scale;
    LocationType X;
    LocationType Y;
    BYTE Direction;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
    char * TextString;
    void * Element;
};

struct LayerType {
    char * Name;
    Cardinal LineN;
    Cardinal TextN;
    Cardinal PolygonN;
    Cardinal ArcN;
    Cardinal LineMax;
    Cardinal TextMax;
    Cardinal PolygonMax;
    Cardinal ArcMax;
    LineTypePtr Line;
    TextTypePtr Text;
    PolygonTypePtr Polygon;
    struct ArcTypePtr * Arc;
    rtree_t * line_tree;
    rtree_t * text_tree;
    rtree_t * polygon_tree;
    rtree_t * arc_tree;
    Boolean On;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    char * Color;
    char * SelectedColor;
    struct AttributeListType Attributes;
};

struct polygon_st {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    Cardinal PointN;
    Cardinal PointMax;
    struct POLYAREA * Clipped;
    struct PLINE * NoHoles;
    int NoHolesValid;
    PointTypePtr Points;
};

struct CVCList {
    double angle;
    struct VNODE * parent;
    struct CVCList * prev;
    struct CVCList * next;
    struct CVCList * head;
    char poly;
    char side;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct NetlistChangeType * NetlistChangeTypePtr;

typedef struct UndoListTypePtr UndoListTypePtr, *PUndoListTypePtr;

struct UndoListTypePtr {
    int Serial;
    int Type;
    int Kind;
    int ID;
    union anon_union_for_Data Data;
};

typedef union anon_union.conflict2 anon_union.conflict2, *Panon_union.conflict2;

union anon_union.conflict2 {
    struct ChangeNameType ChangeName;
    struct MoveType Move;
    struct RemovedPointType RemovedPoint;
    struct RotateType Rotate;
    struct MoveToLayerType MoveToLayer;
    struct FlagType Flags;
    BDimension Size;
    struct LayerChangeType LayerChange;
    struct ClearPolyType ClearPoly;
    struct NetlistChangeType NetlistChange;
};

typedef struct _GtsVertex _GtsVertex, *P_GtsVertex;

typedef struct _GtsVertex GtsVertex;

typedef struct _GtsPoint _GtsPoint, *P_GtsPoint;

typedef struct _GtsPoint GtsPoint;

typedef struct _GtsObject _GtsObject, *P_GtsObject;

typedef struct _GtsObject GtsObject;

typedef struct _GtsObjectClass _GtsObjectClass, *P_GtsObjectClass;

typedef struct _GtsFile _GtsFile, *P_GtsFile;

typedef struct _GtsFile GtsFile;


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct _IO_FILE FILE;

typedef struct _GtsColor _GtsColor, *P_GtsColor;

typedef struct _GtsColor GtsColor;

typedef struct _GtsObjectClass GtsObjectClass;

typedef struct _GtsObjectClassInfo _GtsObjectClassInfo, *P_GtsObjectClassInfo;

typedef struct _GtsObjectClassInfo GtsObjectClassInfo;

typedef enum GtsTokenType {
    GTS_DOUBLE=4096,
    GTS_ERROR=32768,
    GTS_FILE=16384,
    GTS_FLOAT=2048,
    GTS_INT=512,
    GTS_NONE=256,
    GTS_STRING=8192,
    GTS_UINT=1024
} GtsTokenType;

typedef void (* GtsObjectInitFunc)(GtsObject *);

typedef void (* GtsArgSetFunc)(GtsObject *);

typedef void (* GtsArgGetFunc)(GtsObject *);

struct _GtsObject {
    GtsObjectClass * klass;
    gpointer reserved;
    guint32 flags;
};

struct _GtsPoint {
    GtsObject object;
    gdouble x;
    gdouble y;
    gdouble z;
};

struct _GtsColor {
    gfloat r;
    gfloat g;
    gfloat b;
};

struct _GtsObjectClassInfo {
    gchar name[40];
    guint object_size;
    guint class_size;
    void (* class_init_func)(GtsObjectClass *);
    GtsObjectInitFunc object_init_func;
    GtsArgSetFunc arg_set_func;
    GtsArgGetFunc arg_get_func;
};

struct _GtsObjectClass {
    GtsObjectClassInfo info;
    GtsObjectClass * parent_class;
    void (* clone)(GtsObject *, GtsObject *);
    void (* destroy)(GtsObject *);
    void (* read)(GtsObject * *, GtsFile *);
    void (* write)(GtsObject *, FILE *);
    GtsColor (* color)(GtsObject *);
    void (* attributes)(GtsObject *, GtsObject *);
};

struct _GtsFile {
    FILE * fp;
    gchar * s;
    gchar * s1;
    guint line;
    guint pos;
    GString * token;
    enum GtsTokenType type;
    gchar * error;
    guint curline;
    guint curpos;
    guint scope;
    guint scope_max;
    gint next_token;
    gchar * delimiters;
    gchar * comments;
    gchar * tokens;
};

struct _GtsVertex {
    GtsPoint p;
    GSList * segments;
};

typedef gdouble GtsVector4[4];

typedef GtsVector4 GtsMatrix;

typedef struct _GtsSurface _GtsSurface, *P_GtsSurface;

typedef struct _GtsSurface GtsSurface;

typedef struct _GtsFaceClass _GtsFaceClass, *P_GtsFaceClass;

typedef struct _GtsFaceClass GtsFaceClass;

typedef struct _GtsEdgeClass _GtsEdgeClass, *P_GtsEdgeClass;

typedef struct _GtsEdgeClass GtsEdgeClass;

typedef struct _GtsVertexClass _GtsVertexClass, *P_GtsVertexClass;

typedef struct _GtsVertexClass GtsVertexClass;

typedef struct _GtsTriangleClass _GtsTriangleClass, *P_GtsTriangleClass;

typedef struct _GtsTriangleClass GtsTriangleClass;

typedef struct _GtsSegmentClass _GtsSegmentClass, *P_GtsSegmentClass;

typedef struct _GtsSegmentClass GtsSegmentClass;

typedef struct _GtsPointClass _GtsPointClass, *P_GtsPointClass;

typedef struct _GtsPointClass GtsPointClass;

struct _GtsTriangleClass {
    GtsObjectClass parent_class;
};

struct _GtsFaceClass {
    GtsTriangleClass parent_class;
};

struct _GtsPointClass {
    GtsObjectClass parent_class;
    gboolean binary;
};

struct _GtsVertexClass {
    GtsPointClass parent_class;
    void (* intersection_attributes)(GtsVertex *, GtsObject *, GtsObject *);
};

struct _GtsSurface {
    GtsObject object;
    GHashTable * faces;
    GtsFaceClass * face_class;
    GtsEdgeClass * edge_class;
    GtsVertexClass * vertex_class;
    gboolean keep_faces;
};

struct _GtsSegmentClass {
    GtsObjectClass parent_class;
};

struct _GtsEdgeClass {
    GtsSegmentClass parent_class;
};

typedef gdouble GtsVector[3];

typedef struct _GtsFileVariable _GtsFileVariable, *P_GtsFileVariable;

typedef struct _GtsFileVariable GtsFileVariable;

struct _GtsFileVariable {
    enum GtsTokenType type;
    gchar name[30];
    undefined field_0x22;
    undefined field_0x23;
    gboolean unique;
    gpointer data;
    gboolean set;
    guint line;
    guint pos;
};

typedef struct _GtsTriangle _GtsTriangle, *P_GtsTriangle;

typedef struct _GtsEdge _GtsEdge, *P_GtsEdge;

typedef struct _GtsEdge GtsEdge;

typedef struct _GtsSegment _GtsSegment, *P_GtsSegment;

typedef struct _GtsSegment GtsSegment;

struct _GtsTriangle {
    GtsObject object;
    GtsEdge * e1;
    GtsEdge * e2;
    GtsEdge * e3;
};

struct _GtsSegment {
    GtsObject object;
    GtsVertex * v1;
    GtsVertex * v2;
};

struct _GtsEdge {
    GtsSegment segment;
    GSList * triangles;
};

typedef struct _GtsEHeapPair _GtsEHeapPair, *P_GtsEHeapPair;

struct _GtsEHeapPair {
    gpointer data;
    gdouble key;
    guint pos;
};

typedef struct _GtsSurfaceClass _GtsSurfaceClass, *P_GtsSurfaceClass;

typedef struct _GtsFace _GtsFace, *P_GtsFace;

typedef struct _GtsFace GtsFace;

typedef struct _GtsSurfaceClass GtsSurfaceClass;

typedef struct _GtsTriangle GtsTriangle;

struct _GtsFace {
    GtsTriangle triangle;
    GSList * surfaces;
};

struct _GtsSurfaceClass {
    GtsObjectClass parent_class;
    void (* add_face)(GtsSurface *, GtsFace *);
    void (* remove_face)(GtsSurface *, GtsFace *);
};

typedef struct _GtsConstraintClass _GtsConstraintClass, *P_GtsConstraintClass;

struct _GtsConstraintClass {
    GtsEdgeClass parent_class;
};

typedef struct _GtsSurfaceTraverse _GtsSurfaceTraverse, *P_GtsSurfaceTraverse;

typedef struct _GtsSurfaceTraverse GtsSurfaceTraverse;

typedef struct _GtsFifo _GtsFifo, *P_GtsFifo;

typedef struct _GtsFifo GtsFifo;

struct _GtsSurfaceTraverse {
    GtsFifo * q;
    GtsSurface * s;
};

struct _GtsFifo {
    GList * head;
    GList * tail;
};

typedef struct _GtsRange _GtsRange, *P_GtsRange;

typedef struct _GtsRange GtsRange;

struct _GtsRange {
    gdouble min;
    gdouble max;
    gdouble sum;
    gdouble sum2;
    gdouble mean;
    gdouble stddev;
    guint n;
};

typedef struct _GtsSurfaceStats _GtsSurfaceStats, *P_GtsSurfaceStats;

typedef struct _GtsSurfaceStats GtsSurfaceStats;

struct _GtsSurfaceStats {
    guint n_faces;
    guint n_incompatible_faces;
    guint n_duplicate_faces;
    guint n_duplicate_edges;
    guint n_boundary_edges;
    guint n_non_manifold_edges;
    GtsRange edges_per_vertex;
    GtsRange faces_per_edge;
    GtsSurface * parent;
};

typedef struct _GtsListFace _GtsListFace, *P_GtsListFace;

typedef struct _GtsListFace GtsListFace;

struct _GtsListFace {
    GtsFace parent;
    GSList * points;
};

typedef struct _GtsBBox _GtsBBox, *P_GtsBBox;

struct _GtsBBox {
    GtsObject object;
    gpointer bounded;
    gdouble x1;
    gdouble y1;
    gdouble z1;
    gdouble x2;
    gdouble y2;
    gdouble z2;
};

typedef struct _GtsSurfaceQualityStats _GtsSurfaceQualityStats, *P_GtsSurfaceQualityStats;

struct _GtsSurfaceQualityStats {
    GtsRange face_quality;
    GtsRange face_area;
    GtsRange edge_length;
    GtsRange edge_angle;
    GtsSurface * parent;
};

typedef struct _GtsEHeapPair GtsEHeapPair;

typedef struct _GtsBBox GtsBBox;

typedef struct _GtsConstraintClass GtsConstraintClass;

typedef struct _GtsEHeap _GtsEHeap, *P_GtsEHeap;

typedef struct _GtsEHeap GtsEHeap;

struct _GtsEHeap {
    GPtrArray * elts;
    gdouble (* func)(gpointer, gpointer);
    gpointer data;
    gboolean frozen;
    gboolean randomized;
};

typedef struct _GtsConstraint _GtsConstraint, *P_GtsConstraint;

typedef struct _GtsConstraint GtsConstraint;

struct _GtsConstraint {
    GtsEdge edge;
};

typedef GtsVertex * (* GtsCoarsenFunc)(GtsEdge *, GtsVertexClass *, gpointer);

typedef struct _GtsBBoxClass _GtsBBoxClass, *P_GtsBBoxClass;

typedef struct _GtsBBoxClass GtsBBoxClass;

struct _GtsBBoxClass {
    GtsObjectClass parent_class;
};

typedef struct _GtsVertexNormal _GtsVertexNormal, *P_GtsVertexNormal;

struct _GtsVertexNormal {
    GtsVertex parent;
    GtsVector n;
};

typedef GtsVertex * (* GtsRefineFunc)(GtsEdge *, GtsVertexClass *, gpointer);

typedef enum GtsIntersect {
    GTS_IN=1,
    GTS_ON=0,
    GTS_OUT=-1
} GtsIntersect;

typedef struct _GtsSurfaceQualityStats GtsSurfaceQualityStats;


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef struct DBusError DBusError, *PDBusError;

struct DBusError {
    char * name;
    char * message;
    uint dummy1:1;
    uint dummy2:1;
    uint dummy3:1;
    uint dummy4:1;
    uint dummy5:1;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    void * padding1;
};

typedef struct _GhidPinoutPreviewClass _GhidPinoutPreviewClass, *P_GhidPinoutPreviewClass;

typedef struct _GtkDrawingAreaClass _GtkDrawingAreaClass, *P_GtkDrawingAreaClass;

typedef struct _GtkDrawingAreaClass GtkDrawingAreaClass;

struct _GtkDrawingAreaClass {
    GtkWidgetClass parent_class;
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

struct _GhidPinoutPreviewClass {
    GtkDrawingAreaClass parent_class;
};

typedef struct _GhidPinoutPreviewClass GhidPinoutPreviewClass;

typedef struct _GhidPinoutPreview _GhidPinoutPreview, *P_GhidPinoutPreview;

typedef struct _GtkDrawingArea _GtkDrawingArea, *P_GtkDrawingArea;

typedef struct _GtkDrawingArea GtkDrawingArea;

typedef struct ElementType.conflict ElementType.conflict, *PElementType.conflict;

typedef struct PinTypePtr PinTypePtr, *PPinTypePtr;

typedef struct PadTypePtr PadTypePtr, *PPadTypePtr;

typedef struct LineTypePtr.conflict LineTypePtr.conflict, *PLineTypePtr.conflict;

struct _GtkDrawingArea {
    GtkWidget widget;
    gpointer draw_data;
};

struct PadTypePtr {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    BDimension Mask;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

struct LineTypePtr.conflict {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    char * Number;
};

struct ElementType.conflict {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    struct LineTypePtr.conflict * Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

struct _GhidPinoutPreview {
    GtkDrawingArea parent_instance;
    struct ElementType.conflict element;
    gfloat zoom;
    gfloat scale;
    gint x_max;
    gint y_max;
    gint w_pixels;
    gint h_pixels;
};

struct PinTypePtr {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    BDimension Mask;
    BDimension DrillingHole;
    LocationType X;
    LocationType Y;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

typedef struct _GhidPinoutPreview GhidPinoutPreview;

typedef struct vector_struct vector_struct, *Pvector_struct;

typedef struct vector_struct vector_t;

typedef void * vector_element_t;

struct vector_struct {
    vector_element_t * element;
    int size;
    int max;
};

typedef struct _TimeoutHandler _TimeoutHandler, *P_TimeoutHandler;

typedef struct _TimeoutHandler TimeoutHandler;

struct _TimeoutHandler {
    struct DBusTimeout * dbus_timeout;
    union hidval pcb_timer;
    int interval;
};

typedef struct _IOWatchHandler _IOWatchHandler, *P_IOWatchHandler;

typedef struct _IOWatchHandler IOWatchHandler;

struct _IOWatchHandler {
    struct DBusWatch * dbus_watch;
    union hidval pcb_watch;
};

typedef struct HID_ActionContext HID_ActionContext, *PHID_ActionContext;

typedef struct HID_Action HID_Action, *PHID_Action;

struct HID_Action {
    char * name;
    char * need_coord_msg;
    int (* trigger_cb)(int, char * *, int, int);
    char * description;
    char * syntax;
};

struct HID_ActionContext {
    struct HID_Action action;
    void * context;
};

typedef struct HID_ActionNode HID_ActionNode, *PHID_ActionNode;

struct HID_ActionNode {
    struct HID_ActionNode * next;
    struct HID_Action * actions;
    int n;
    void * context;
    int dynamic;
};

typedef union yyalloc.conflict yyalloc.conflict, *Pyyalloc.conflict;

typedef short yytype_int16;

typedef union YYSTYPE.conflict YYSTYPE.conflict, *PYYSTYPE.conflict;

union YYSTYPE.conflict {
    int number;
    float floating;
    char * string;
    struct FlagType flagtype;
};

union yyalloc.conflict {
    yytype_int16 yyss;
    union YYSTYPE.conflict yyvs;
};

typedef struct _GtkWindowClass _GtkWindowClass, *P_GtkWindowClass;

typedef struct _GtkBinClass _GtkBinClass, *P_GtkBinClass;

typedef struct _GtkBinClass GtkBinClass;

typedef struct _GtkContainerClass _GtkContainerClass, *P_GtkContainerClass;

typedef struct _GtkContainerClass GtkContainerClass;

struct _GtkContainerClass {
    GtkWidgetClass parent_class;
    void (* add)(GtkContainer *, GtkWidget *);
    void (* remove)(GtkContainer *, GtkWidget *);
    void (* check_resize)(GtkContainer *);
    void (* forall)(GtkContainer *, gboolean, void (* )(GtkWidget *, gpointer), gpointer);
    void (* set_focus_child)(GtkContainer *, GtkWidget *);
    GType (* child_type)(GtkContainer *);
    gchar * (* composite_name)(GtkContainer *, GtkWidget *);
    void (* set_child_property)(GtkContainer *, GtkWidget *, guint, GValue *, GParamSpec *);
    void (* get_child_property)(GtkContainer *, GtkWidget *, guint, GValue *, GParamSpec *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

struct _GtkBinClass {
    GtkContainerClass parent_class;
};

struct _GtkWindowClass {
    GtkBinClass parent_class;
    void (* set_focus)(GtkWindow *, GtkWidget *);
    gboolean (* frame_event)(GtkWindow *, GdkEvent *);
    void (* activate_focus)(GtkWindow *);
    void (* activate_default)(GtkWindow *);
    void (* move_focus)(GtkWindow *, enum GtkDirectionType);
    void (* keys_changed)(GtkWindow *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

typedef struct _GtkWindowClass GtkWindowClass;

typedef struct timeval timeval, *Ptimeval;

typedef long __suseconds_t;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef __time_t time_t;

typedef struct _GtkScale _GtkScale, *P_GtkScale;

typedef struct _GtkRange _GtkRange, *P_GtkRange;

typedef struct _GtkRange GtkRange;

typedef enum GtkUpdateType {
    GTK_UPDATE_CONTINUOUS=0,
    GTK_UPDATE_DELAYED=2,
    GTK_UPDATE_DISCONTINUOUS=1
} GtkUpdateType;

typedef enum GtkOrientation {
    GTK_ORIENTATION_HORIZONTAL=0,
    GTK_ORIENTATION_VERTICAL=1
} GtkOrientation;

typedef struct _GtkRangeLayout _GtkRangeLayout, *P_GtkRangeLayout;

typedef struct _GtkRangeLayout GtkRangeLayout;

typedef struct _GtkRangeStepTimer _GtkRangeStepTimer, *P_GtkRangeStepTimer;

typedef struct _GtkRangeStepTimer GtkRangeStepTimer;

struct _GtkRange {
    GtkWidget widget;
    GtkAdjustment * adjustment;
    enum GtkUpdateType update_policy;
    guint inverted:1;
    guint flippable:1;
    guint has_stepper_a:1;
    guint has_stepper_b:1;
    guint has_stepper_c:1;
    guint has_stepper_d:1;
    guint need_recalc:1;
    guint slider_size_fixed:1;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    gint min_slider_size;
    enum GtkOrientation orientation;
    GdkRectangle range_rect;
    gint slider_start;
    gint slider_end;
    gint round_digits;
    guint trough_click_forward:1;
    guint update_pending:1;
    undefined field_0x6d;
    undefined field_0x6e;
    undefined field_0x6f;
    GtkRangeLayout * layout;
    GtkRangeStepTimer * timer;
    gint slide_initial_slider_position;
    gint slide_initial_coordinate;
    guint update_timeout_id;
    GdkWindow * event_window;
};

struct _GtkScale {
    GtkRange range;
    gint digits;
    guint draw_value:1;
    guint value_pos:2;
    undefined field_0x8d;
    undefined field_0x8e;
    undefined field_0x8f;
};

struct _GtkRangeLayout {
};

struct _GtkRangeStepTimer {
};

typedef struct _GtkScrolledWindow _GtkScrolledWindow, *P_GtkScrolledWindow;

struct _GtkScrolledWindow {
    GtkBin container;
    GtkWidget * hscrollbar;
    GtkWidget * vscrollbar;
    guint hscrollbar_policy:2;
    guint vscrollbar_policy:2;
    guint hscrollbar_visible:1;
    guint vscrollbar_visible:1;
    guint window_placement:2;
    guint focus_out:1;
    guint16 shadow_type;
};

typedef struct _GtkTable _GtkTable, *P_GtkTable;

typedef struct _GtkTableRowCol _GtkTableRowCol, *P_GtkTableRowCol;

typedef struct _GtkTableRowCol GtkTableRowCol;

struct _GtkTable {
    GtkContainer container;
    GList * children;
    GtkTableRowCol * rows;
    GtkTableRowCol * cols;
    guint16 nrows;
    guint16 ncols;
    guint16 column_spacing;
    guint16 row_spacing;
    guint homogeneous:1;
    undefined field_0x59;
    undefined field_0x5a;
    undefined field_0x5b;
};

struct _GtkTableRowCol {
    guint16 requisition;
    guint16 allocation;
    guint16 spacing;
    guint need_expand:1;
    guint need_shrink:1;
    guint expand:1;
    guint shrink:1;
    guint empty:1;
    undefined field_0x7;
};

typedef struct _GtkToggleButton _GtkToggleButton, *P_GtkToggleButton;

typedef struct _GtkToggleButton GtkToggleButton;

struct _GtkToggleButton {
    GtkButton button;
    guint active:1;
    guint draw_indicator:1;
    guint inconsistent:1;
    undefined field_0x59;
    undefined field_0x5a;
    undefined field_0x5b;
};

typedef struct _GtkTreePath _GtkTreePath, *P_GtkTreePath;

typedef struct _GtkTreePath GtkTreePath;

struct _GtkTreePath {
};

typedef struct _GtkTreeModel _GtkTreeModel, *P_GtkTreeModel;

typedef struct _GtkTreeModel GtkTreeModel;

struct _GtkTreeModel {
};

typedef struct _GtkTreeRowReference _GtkTreeRowReference, *P_GtkTreeRowReference;

typedef struct _GtkTreeRowReference GtkTreeRowReference;

struct _GtkTreeRowReference {
};

typedef struct _GtkToggleActionPrivate _GtkToggleActionPrivate, *P_GtkToggleActionPrivate;

typedef struct _GtkToggleActionPrivate GtkToggleActionPrivate;

struct _GtkToggleActionPrivate {
};

typedef struct _GtkToggleAction _GtkToggleAction, *P_GtkToggleAction;

typedef struct _GtkAction _GtkAction, *P_GtkAction;

typedef struct _GtkAction GtkAction;

typedef struct _GtkActionPrivate _GtkActionPrivate, *P_GtkActionPrivate;

typedef struct _GtkActionPrivate GtkActionPrivate;

struct _GtkAction {
    GObject object;
    GtkActionPrivate * private_data;
};

struct _GtkActionPrivate {
};

struct _GtkToggleAction {
    GtkAction parent;
    GtkToggleActionPrivate * private_data;
};

typedef struct _GtkToggleAction GtkToggleAction;

typedef struct _GtkTreeSelection.conflict _GtkTreeSelection.conflict, *P_GtkTreeSelection.conflict;

typedef struct _GtkTreeSelection _GtkTreeSelection, *P_GtkTreeSelection;

typedef struct _GtkTreeSelection GtkTreeSelection;

typedef struct _GtkTreeSelection.conflict GtkTreeSelection.conflict;

typedef struct _GtkTreeView _GtkTreeView, *P_GtkTreeView;

typedef struct _GtkTreeView GtkTreeView;

typedef enum GtkSelectionMode {
    GTK_SELECTION_BROWSE=2,
    GTK_SELECTION_EXTENDED=3,
    GTK_SELECTION_MULTIPLE=3,
    GTK_SELECTION_NONE=0,
    GTK_SELECTION_SINGLE=1
} GtkSelectionMode;

typedef void (* GDestroyNotify.conflict)(gpointer);

typedef struct _GtkTreeViewPrivate _GtkTreeViewPrivate, *P_GtkTreeViewPrivate;

typedef struct _GtkTreeViewPrivate GtkTreeViewPrivate;

struct _GtkTreeSelection {
    GObject parent;
    GtkTreeView * tree_view;
    enum GtkSelectionMode type;
    gboolean (* user_func)(GtkTreeSelection *, GtkTreeModel *, GtkTreePath *, gboolean, gpointer);
    gpointer user_data;
    void (* destroy)(gpointer);
};

struct _GtkTreeViewPrivate {
};

struct _GtkTreeView {
    GtkContainer parent;
    GtkTreeViewPrivate * priv;
};

struct _GtkTreeSelection.conflict {
    GObject parent;
    GtkTreeView * tree_view;
    enum GtkSelectionMode type;
    gboolean (* user_func)(GtkTreeSelection *, GtkTreeModel *, GtkTreePath *, gboolean, gpointer);
    gpointer user_data;
    GDestroyNotify.conflict destroy;
};

typedef struct cheap_point cheap_point, *Pcheap_point;

typedef struct cheap_point CheapPointType;

struct cheap_point {
    LocationType X;
    LocationType Y;
};

typedef enum direction_t {
    ALL=8,
    EAST=1,
    NE=4,
    NORTH=0,
    NW=7,
    SE=5,
    SOUTH=2,
    SW=6,
    WEST=3
} direction_t;

typedef struct cpInfo cpInfo, *PcpInfo;

typedef struct DataType DataType, *PDataType;

typedef struct polygon_st PolygonType;

typedef struct ElementType ElementType, *PElementType;

typedef struct ElementType * ElementTypePtr.conflict;

typedef struct RatTypePtr RatTypePtr, *PRatTypePtr;

typedef struct PCBType PCBType, *PPCBType;

typedef struct LayerType.conflict LayerType.conflict, *PLayerType.conflict;

typedef struct PinType * PinTypePtr.conflict;

typedef struct PadType * PadTypePtr.conflict;

typedef struct FontType FontType, *PFontType;

typedef struct LayerGroupType LayerGroupType, *PLayerGroupType;

typedef struct RouteStyleType RouteStyleType, *PRouteStyleType;

typedef struct DataTypePtr DataTypePtr, *PDataTypePtr;

typedef struct SymbolType SymbolType, *PSymbolType;

typedef struct ElementTypePtr ElementTypePtr, *PElementTypePtr;

struct cpInfo {
    struct BoxType * other;
    struct DataType * data;
    struct LayerType * layer;
    PolygonType * polygon;
    Boolean solder;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
    jmp_buf env;
};

struct RouteStyleType {
    BDimension Thick;
    BDimension Diameter;
    BDimension Hole;
    BDimension Keepaway;
    char * Name;
    int index;
};

struct RatTypePtr {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    Cardinal group1;
    Cardinal group2;
};

struct ElementTypePtr {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    LineTypePtr Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

struct SymbolType {
    LineTypePtr Line;
    Boolean Valid;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    Cardinal LineN;
    Cardinal LineMax;
    BDimension Width;
    BDimension Height;
    BDimension Delta;
};

struct FontType {
    LocationType MaxHeight;
    LocationType MaxWidth;
    struct BoxType DefaultSymbol;
    struct SymbolType Symbol[256];
    Boolean Valid;
    undefined field_0x1c19;
    undefined field_0x1c1a;
    undefined field_0x1c1b;
};

struct LayerGroupType {
    Cardinal Number[16];
    Cardinal Entries[16][18];
};

struct PCBType {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType NetlistLib;
    struct AttributeListType Attributes;
    struct DataTypePtr * Data;
};

struct LayerType.conflict {
    char * Name;
    Cardinal LineN;
    Cardinal TextN;
    Cardinal PolygonN;
    Cardinal ArcN;
    Cardinal LineMax;
    Cardinal TextMax;
    Cardinal PolygonMax;
    Cardinal ArcMax;
    struct LineTypePtr.conflict * Line;
    TextTypePtr Text;
    PolygonTypePtr Polygon;
    struct ArcTypePtr * Arc;
    rtree_t * line_tree;
    rtree_t * text_tree;
    rtree_t * polygon_tree;
    rtree_t * arc_tree;
    Boolean On;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    char * Color;
    char * SelectedColor;
    struct AttributeListType Attributes;
};

struct DataType {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    ElementTypePtr.conflict Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict Layer[18];
};

struct ElementType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    PinTypePtr.conflict Pin;
    PadTypePtr.conflict Pad;
    LineTypePtr Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

struct DataTypePtr {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    undefined field_0x48;
    undefined field_0x49;
    undefined field_0x4a;
    undefined field_0x4b;
    undefined field_0x4c;
    undefined field_0x4d;
    undefined field_0x4e;
    undefined field_0x4f;
    undefined field_0x50;
    undefined field_0x51;
    undefined field_0x52;
    undefined field_0x53;
    undefined field_0x54;
    undefined field_0x55;
    undefined field_0x56;
    undefined field_0x57;
    undefined field_0x58;
    undefined field_0x59;
    undefined field_0x5a;
    undefined field_0x5b;
    undefined field_0x5c;
    undefined field_0x5d;
    undefined field_0x5e;
    undefined field_0x5f;
    undefined field_0x60;
    undefined field_0x61;
    undefined field_0x62;
    undefined field_0x63;
    undefined field_0x64;
    undefined field_0x65;
    undefined field_0x66;
    undefined field_0x67;
    undefined field_0x68;
    undefined field_0x69;
    undefined field_0x6a;
    undefined field_0x6b;
    undefined field_0x6c;
    undefined field_0x6d;
    undefined field_0x6e;
    undefined field_0x6f;
    undefined field_0x70;
    undefined field_0x71;
    undefined field_0x72;
    undefined field_0x73;
    undefined field_0x74;
    undefined field_0x75;
    undefined field_0x76;
    undefined field_0x77;
    undefined field_0x78;
    undefined field_0x79;
    undefined field_0x7a;
    undefined field_0x7b;
    undefined field_0x7c;
    undefined field_0x7d;
    undefined field_0x7e;
    undefined field_0x7f;
    undefined field_0x80;
    undefined field_0x81;
    undefined field_0x82;
    undefined field_0x83;
    undefined field_0x84;
    undefined field_0x85;
    undefined field_0x86;
    undefined field_0x87;
    undefined field_0x88;
    undefined field_0x89;
    undefined field_0x8a;
    undefined field_0x8b;
    undefined field_0x8c;
    undefined field_0x8d;
    undefined field_0x8e;
    undefined field_0x8f;
    undefined field_0x90;
    undefined field_0x91;
    undefined field_0x92;
    undefined field_0x93;
    undefined field_0x94;
    undefined field_0x95;
    undefined field_0x96;
    undefined field_0x97;
    undefined field_0x98;
    undefined field_0x99;
    undefined field_0x9a;
    undefined field_0x9b;
    undefined field_0x9c;
    undefined field_0x9d;
    undefined field_0x9e;
    undefined field_0x9f;
    undefined field_0xa0;
    undefined field_0xa1;
    undefined field_0xa2;
    undefined field_0xa3;
    undefined field_0xa4;
    undefined field_0xa5;
    undefined field_0xa6;
    undefined field_0xa7;
    undefined field_0xa8;
    undefined field_0xa9;
    undefined field_0xaa;
    undefined field_0xab;
    undefined field_0xac;
    undefined field_0xad;
    undefined field_0xae;
    undefined field_0xaf;
    undefined field_0xb0;
    undefined field_0xb1;
    undefined field_0xb2;
    undefined field_0xb3;
    undefined field_0xb4;
    undefined field_0xb5;
    undefined field_0xb6;
    undefined field_0xb7;
    undefined field_0xb8;
    undefined field_0xb9;
    undefined field_0xba;
    undefined field_0xbb;
    undefined field_0xbc;
    undefined field_0xbd;
    undefined field_0xbe;
    undefined field_0xbf;
    undefined field_0xc0;
    undefined field_0xc1;
    undefined field_0xc2;
    undefined field_0xc3;
    undefined field_0xc4;
    undefined field_0xc5;
    undefined field_0xc6;
    undefined field_0xc7;
    undefined field_0xc8;
    undefined field_0xc9;
    undefined field_0xca;
    undefined field_0xcb;
    undefined field_0xcc;
    undefined field_0xcd;
    undefined field_0xce;
    undefined field_0xcf;
    undefined field_0xd0;
    undefined field_0xd1;
    undefined field_0xd2;
    undefined field_0xd3;
    undefined field_0xd4;
    undefined field_0xd5;
    undefined field_0xd6;
    undefined field_0xd7;
    undefined field_0xd8;
    undefined field_0xd9;
    undefined field_0xda;
    undefined field_0xdb;
    undefined field_0xdc;
    undefined field_0xdd;
    undefined field_0xde;
    undefined field_0xdf;
    undefined field_0xe0;
    undefined field_0xe1;
    undefined field_0xe2;
    undefined field_0xe3;
    undefined field_0xe4;
    undefined field_0xe5;
    undefined field_0xe6;
    undefined field_0xe7;
    undefined field_0xe8;
    undefined field_0xe9;
    undefined field_0xea;
    undefined field_0xeb;
    undefined field_0xec;
    undefined field_0xed;
    undefined field_0xee;
    undefined field_0xef;
    undefined field_0xf0;
    undefined field_0xf1;
    undefined field_0xf2;
    undefined field_0xf3;
    undefined field_0xf4;
    undefined field_0xf5;
    undefined field_0xf6;
    undefined field_0xf7;
    undefined field_0xf8;
    undefined field_0xf9;
    undefined field_0xfa;
    undefined field_0xfb;
    undefined field_0xfc;
    undefined field_0xfd;
    undefined field_0xfe;
    undefined field_0xff;
    undefined field_0x100;
    undefined field_0x101;
    undefined field_0x102;
    undefined field_0x103;
    undefined field_0x104;
    undefined field_0x105;
    undefined field_0x106;
    undefined field_0x107;
    undefined field_0x108;
    undefined field_0x109;
    undefined field_0x10a;
    undefined field_0x10b;
    undefined field_0x10c;
    undefined field_0x10d;
    undefined field_0x10e;
    undefined field_0x10f;
    undefined field_0x110;
    undefined field_0x111;
    undefined field_0x112;
    undefined field_0x113;
    undefined field_0x114;
    undefined field_0x115;
    undefined field_0x116;
    undefined field_0x117;
    undefined field_0x118;
    undefined field_0x119;
    undefined field_0x11a;
    undefined field_0x11b;
    undefined field_0x11c;
    undefined field_0x11d;
    undefined field_0x11e;
    undefined field_0x11f;
    undefined field_0x120;
    undefined field_0x121;
    undefined field_0x122;
    undefined field_0x123;
    undefined field_0x124;
    undefined field_0x125;
    undefined field_0x126;
    undefined field_0x127;
    undefined field_0x128;
    undefined field_0x129;
    undefined field_0x12a;
    undefined field_0x12b;
    undefined field_0x12c;
    undefined field_0x12d;
    undefined field_0x12e;
    undefined field_0x12f;
    undefined field_0x130;
    undefined field_0x131;
    undefined field_0x132;
    undefined field_0x133;
    undefined field_0x134;
    undefined field_0x135;
    undefined field_0x136;
    undefined field_0x137;
    undefined field_0x138;
    undefined field_0x139;
    undefined field_0x13a;
    undefined field_0x13b;
    undefined field_0x13c;
    undefined field_0x13d;
    undefined field_0x13e;
    undefined field_0x13f;
    undefined field_0x140;
    undefined field_0x141;
    undefined field_0x142;
    undefined field_0x143;
    undefined field_0x144;
    undefined field_0x145;
    undefined field_0x146;
    undefined field_0x147;
    undefined field_0x148;
    undefined field_0x149;
    undefined field_0x14a;
    undefined field_0x14b;
    undefined field_0x14c;
    undefined field_0x14d;
    undefined field_0x14e;
    undefined field_0x14f;
    undefined field_0x150;
    undefined field_0x151;
    undefined field_0x152;
    undefined field_0x153;
    undefined field_0x154;
    undefined field_0x155;
    undefined field_0x156;
    undefined field_0x157;
    undefined field_0x158;
    undefined field_0x159;
    undefined field_0x15a;
    undefined field_0x15b;
    undefined field_0x15c;
    undefined field_0x15d;
    undefined field_0x15e;
    undefined field_0x15f;
    undefined field_0x160;
    undefined field_0x161;
    undefined field_0x162;
    undefined field_0x163;
    undefined field_0x164;
    undefined field_0x165;
    undefined field_0x166;
    undefined field_0x167;
    undefined field_0x168;
    undefined field_0x169;
    undefined field_0x16a;
    undefined field_0x16b;
    undefined field_0x16c;
    undefined field_0x16d;
    undefined field_0x16e;
    undefined field_0x16f;
    undefined field_0x170;
    undefined field_0x171;
    undefined field_0x172;
    undefined field_0x173;
    undefined field_0x174;
    undefined field_0x175;
    undefined field_0x176;
    undefined field_0x177;
    undefined field_0x178;
    undefined field_0x179;
    undefined field_0x17a;
    undefined field_0x17b;
    undefined field_0x17c;
    undefined field_0x17d;
    undefined field_0x17e;
    undefined field_0x17f;
    undefined field_0x180;
    undefined field_0x181;
    undefined field_0x182;
    undefined field_0x183;
    undefined field_0x184;
    undefined field_0x185;
    undefined field_0x186;
    undefined field_0x187;
    undefined field_0x188;
    undefined field_0x189;
    undefined field_0x18a;
    undefined field_0x18b;
    undefined field_0x18c;
    undefined field_0x18d;
    undefined field_0x18e;
    undefined field_0x18f;
    undefined field_0x190;
    undefined field_0x191;
    undefined field_0x192;
    undefined field_0x193;
    undefined field_0x194;
    undefined field_0x195;
    undefined field_0x196;
    undefined field_0x197;
    undefined field_0x198;
    undefined field_0x199;
    undefined field_0x19a;
    undefined field_0x19b;
    undefined field_0x19c;
    undefined field_0x19d;
    undefined field_0x19e;
    undefined field_0x19f;
    undefined field_0x1a0;
    undefined field_0x1a1;
    undefined field_0x1a2;
    undefined field_0x1a3;
    undefined field_0x1a4;
    undefined field_0x1a5;
    undefined field_0x1a6;
    undefined field_0x1a7;
    undefined field_0x1a8;
    undefined field_0x1a9;
    undefined field_0x1aa;
    undefined field_0x1ab;
    undefined field_0x1ac;
    undefined field_0x1ad;
    undefined field_0x1ae;
    undefined field_0x1af;
    undefined field_0x1b0;
    undefined field_0x1b1;
    undefined field_0x1b2;
    undefined field_0x1b3;
    undefined field_0x1b4;
    undefined field_0x1b5;
    undefined field_0x1b6;
    undefined field_0x1b7;
    undefined field_0x1b8;
    undefined field_0x1b9;
    undefined field_0x1ba;
    undefined field_0x1bb;
    undefined field_0x1bc;
    undefined field_0x1bd;
    undefined field_0x1be;
    undefined field_0x1bf;
    undefined field_0x1c0;
    undefined field_0x1c1;
    undefined field_0x1c2;
    undefined field_0x1c3;
    undefined field_0x1c4;
    undefined field_0x1c5;
    undefined field_0x1c6;
    undefined field_0x1c7;
    undefined field_0x1c8;
    undefined field_0x1c9;
    undefined field_0x1ca;
    undefined field_0x1cb;
    undefined field_0x1cc;
    undefined field_0x1cd;
    undefined field_0x1ce;
    undefined field_0x1cf;
    undefined field_0x1d0;
    undefined field_0x1d1;
    undefined field_0x1d2;
    undefined field_0x1d3;
    undefined field_0x1d4;
    undefined field_0x1d5;
    undefined field_0x1d6;
    undefined field_0x1d7;
    undefined field_0x1d8;
    undefined field_0x1d9;
    undefined field_0x1da;
    undefined field_0x1db;
    undefined field_0x1dc;
    undefined field_0x1dd;
    undefined field_0x1de;
    undefined field_0x1df;
    undefined field_0x1e0;
    undefined field_0x1e1;
    undefined field_0x1e2;
    undefined field_0x1e3;
    undefined field_0x1e4;
    undefined field_0x1e5;
    undefined field_0x1e6;
    undefined field_0x1e7;
    undefined field_0x1e8;
    undefined field_0x1e9;
    undefined field_0x1ea;
    undefined field_0x1eb;
    undefined field_0x1ec;
    undefined field_0x1ed;
    undefined field_0x1ee;
    undefined field_0x1ef;
    undefined field_0x1f0;
    undefined field_0x1f1;
    undefined field_0x1f2;
    undefined field_0x1f3;
    undefined field_0x1f4;
    undefined field_0x1f5;
    undefined field_0x1f6;
    undefined field_0x1f7;
    undefined field_0x1f8;
    undefined field_0x1f9;
    undefined field_0x1fa;
    undefined field_0x1fb;
    undefined field_0x1fc;
    undefined field_0x1fd;
    undefined field_0x1fe;
    undefined field_0x1ff;
    undefined field_0x200;
    undefined field_0x201;
    undefined field_0x202;
    undefined field_0x203;
    undefined field_0x204;
    undefined field_0x205;
    undefined field_0x206;
    undefined field_0x207;
    undefined field_0x208;
    undefined field_0x209;
    undefined field_0x20a;
    undefined field_0x20b;
    undefined field_0x20c;
    undefined field_0x20d;
    undefined field_0x20e;
    undefined field_0x20f;
    undefined field_0x210;
    undefined field_0x211;
    undefined field_0x212;
    undefined field_0x213;
    undefined field_0x214;
    undefined field_0x215;
    undefined field_0x216;
    undefined field_0x217;
    undefined field_0x218;
    undefined field_0x219;
    undefined field_0x21a;
    undefined field_0x21b;
    undefined field_0x21c;
    undefined field_0x21d;
    undefined field_0x21e;
    undefined field_0x21f;
    undefined field_0x220;
    undefined field_0x221;
    undefined field_0x222;
    undefined field_0x223;
    undefined field_0x224;
    undefined field_0x225;
    undefined field_0x226;
    undefined field_0x227;
    undefined field_0x228;
    undefined field_0x229;
    undefined field_0x22a;
    undefined field_0x22b;
    undefined field_0x22c;
    undefined field_0x22d;
    undefined field_0x22e;
    undefined field_0x22f;
    undefined field_0x230;
    undefined field_0x231;
    undefined field_0x232;
    undefined field_0x233;
    undefined field_0x234;
    undefined field_0x235;
    undefined field_0x236;
    undefined field_0x237;
    undefined field_0x238;
    undefined field_0x239;
    undefined field_0x23a;
    undefined field_0x23b;
    undefined field_0x23c;
    undefined field_0x23d;
    undefined field_0x23e;
    undefined field_0x23f;
    undefined field_0x240;
    undefined field_0x241;
    undefined field_0x242;
    undefined field_0x243;
    undefined field_0x244;
    undefined field_0x245;
    undefined field_0x246;
    undefined field_0x247;
    undefined field_0x248;
    undefined field_0x249;
    undefined field_0x24a;
    undefined field_0x24b;
    undefined field_0x24c;
    undefined field_0x24d;
    undefined field_0x24e;
    undefined field_0x24f;
    undefined field_0x250;
    undefined field_0x251;
    undefined field_0x252;
    undefined field_0x253;
    undefined field_0x254;
    undefined field_0x255;
    undefined field_0x256;
    undefined field_0x257;
    undefined field_0x258;
    undefined field_0x259;
    undefined field_0x25a;
    undefined field_0x25b;
    undefined field_0x25c;
    undefined field_0x25d;
    undefined field_0x25e;
    undefined field_0x25f;
    undefined field_0x260;
    undefined field_0x261;
    undefined field_0x262;
    undefined field_0x263;
    undefined field_0x264;
    undefined field_0x265;
    undefined field_0x266;
    undefined field_0x267;
    undefined field_0x268;
    undefined field_0x269;
    undefined field_0x26a;
    undefined field_0x26b;
    undefined field_0x26c;
    undefined field_0x26d;
    undefined field_0x26e;
    undefined field_0x26f;
    undefined field_0x270;
    undefined field_0x271;
    undefined field_0x272;
    undefined field_0x273;
    undefined field_0x274;
    undefined field_0x275;
    undefined field_0x276;
    undefined field_0x277;
    undefined field_0x278;
    undefined field_0x279;
    undefined field_0x27a;
    undefined field_0x27b;
    undefined field_0x27c;
    undefined field_0x27d;
    undefined field_0x27e;
    undefined field_0x27f;
    undefined field_0x280;
    undefined field_0x281;
    undefined field_0x282;
    undefined field_0x283;
    undefined field_0x284;
    undefined field_0x285;
    undefined field_0x286;
    undefined field_0x287;
    undefined field_0x288;
    undefined field_0x289;
    undefined field_0x28a;
    undefined field_0x28b;
    undefined field_0x28c;
    undefined field_0x28d;
    undefined field_0x28e;
    undefined field_0x28f;
    undefined field_0x290;
    undefined field_0x291;
    undefined field_0x292;
    undefined field_0x293;
    undefined field_0x294;
    undefined field_0x295;
    undefined field_0x296;
    undefined field_0x297;
    undefined field_0x298;
    undefined field_0x299;
    undefined field_0x29a;
    undefined field_0x29b;
    undefined field_0x29c;
    undefined field_0x29d;
    undefined field_0x29e;
    undefined field_0x29f;
    undefined field_0x2a0;
    undefined field_0x2a1;
    undefined field_0x2a2;
    undefined field_0x2a3;
    undefined field_0x2a4;
    undefined field_0x2a5;
    undefined field_0x2a6;
    undefined field_0x2a7;
    undefined field_0x2a8;
    undefined field_0x2a9;
    undefined field_0x2aa;
    undefined field_0x2ab;
    undefined field_0x2ac;
    undefined field_0x2ad;
    undefined field_0x2ae;
    undefined field_0x2af;
    undefined field_0x2b0;
    undefined field_0x2b1;
    undefined field_0x2b2;
    undefined field_0x2b3;
    undefined field_0x2b4;
    undefined field_0x2b5;
    undefined field_0x2b6;
    undefined field_0x2b7;
    undefined field_0x2b8;
    undefined field_0x2b9;
    undefined field_0x2ba;
    undefined field_0x2bb;
    undefined field_0x2bc;
    undefined field_0x2bd;
    undefined field_0x2be;
    undefined field_0x2bf;
    undefined field_0x2c0;
    undefined field_0x2c1;
    undefined field_0x2c2;
    undefined field_0x2c3;
    undefined field_0x2c4;
    undefined field_0x2c5;
    undefined field_0x2c6;
    undefined field_0x2c7;
    undefined field_0x2c8;
    undefined field_0x2c9;
    undefined field_0x2ca;
    undefined field_0x2cb;
    undefined field_0x2cc;
    undefined field_0x2cd;
    undefined field_0x2ce;
    undefined field_0x2cf;
    undefined field_0x2d0;
    undefined field_0x2d1;
    undefined field_0x2d2;
    undefined field_0x2d3;
    undefined field_0x2d4;
    undefined field_0x2d5;
    undefined field_0x2d6;
    undefined field_0x2d7;
    undefined field_0x2d8;
    undefined field_0x2d9;
    undefined field_0x2da;
    undefined field_0x2db;
    undefined field_0x2dc;
    undefined field_0x2dd;
    undefined field_0x2de;
    undefined field_0x2df;
    undefined field_0x2e0;
    undefined field_0x2e1;
    undefined field_0x2e2;
    undefined field_0x2e3;
    undefined field_0x2e4;
    undefined field_0x2e5;
    undefined field_0x2e6;
    undefined field_0x2e7;
    undefined field_0x2e8;
    undefined field_0x2e9;
    undefined field_0x2ea;
    undefined field_0x2eb;
    undefined field_0x2ec;
    undefined field_0x2ed;
    undefined field_0x2ee;
    undefined field_0x2ef;
    undefined field_0x2f0;
    undefined field_0x2f1;
    undefined field_0x2f2;
    undefined field_0x2f3;
    undefined field_0x2f4;
    undefined field_0x2f5;
    undefined field_0x2f6;
    undefined field_0x2f7;
    undefined field_0x2f8;
    undefined field_0x2f9;
    undefined field_0x2fa;
    undefined field_0x2fb;
    undefined field_0x2fc;
    undefined field_0x2fd;
    undefined field_0x2fe;
    undefined field_0x2ff;
    undefined field_0x300;
    undefined field_0x301;
    undefined field_0x302;
    undefined field_0x303;
    undefined field_0x304;
    undefined field_0x305;
    undefined field_0x306;
    undefined field_0x307;
    undefined field_0x308;
    undefined field_0x309;
    undefined field_0x30a;
    undefined field_0x30b;
    undefined field_0x30c;
    undefined field_0x30d;
    undefined field_0x30e;
    undefined field_0x30f;
    undefined field_0x310;
    undefined field_0x311;
    undefined field_0x312;
    undefined field_0x313;
    undefined field_0x314;
    undefined field_0x315;
    undefined field_0x316;
    undefined field_0x317;
    undefined field_0x318;
    undefined field_0x319;
    undefined field_0x31a;
    undefined field_0x31b;
    undefined field_0x31c;
    undefined field_0x31d;
    undefined field_0x31e;
    undefined field_0x31f;
    undefined field_0x320;
    undefined field_0x321;
    undefined field_0x322;
    undefined field_0x323;
    undefined field_0x324;
    undefined field_0x325;
    undefined field_0x326;
    undefined field_0x327;
    undefined field_0x328;
    undefined field_0x329;
    undefined field_0x32a;
    undefined field_0x32b;
    undefined field_0x32c;
    undefined field_0x32d;
    undefined field_0x32e;
    undefined field_0x32f;
    undefined field_0x330;
    undefined field_0x331;
    undefined field_0x332;
    undefined field_0x333;
    undefined field_0x334;
    undefined field_0x335;
    undefined field_0x336;
    undefined field_0x337;
    undefined field_0x338;
    undefined field_0x339;
    undefined field_0x33a;
    undefined field_0x33b;
    undefined field_0x33c;
    undefined field_0x33d;
    undefined field_0x33e;
    undefined field_0x33f;
    undefined field_0x340;
    undefined field_0x341;
    undefined field_0x342;
    undefined field_0x343;
    undefined field_0x344;
    undefined field_0x345;
    undefined field_0x346;
    undefined field_0x347;
    undefined field_0x348;
    undefined field_0x349;
    undefined field_0x34a;
    undefined field_0x34b;
    undefined field_0x34c;
    undefined field_0x34d;
    undefined field_0x34e;
    undefined field_0x34f;
    undefined field_0x350;
    undefined field_0x351;
    undefined field_0x352;
    undefined field_0x353;
    undefined field_0x354;
    undefined field_0x355;
    undefined field_0x356;
    undefined field_0x357;
    undefined field_0x358;
    undefined field_0x359;
    undefined field_0x35a;
    undefined field_0x35b;
    undefined field_0x35c;
    undefined field_0x35d;
    undefined field_0x35e;
    undefined field_0x35f;
    undefined field_0x360;
    undefined field_0x361;
    undefined field_0x362;
    undefined field_0x363;
    undefined field_0x364;
    undefined field_0x365;
    undefined field_0x366;
    undefined field_0x367;
    undefined field_0x368;
    undefined field_0x369;
    undefined field_0x36a;
    undefined field_0x36b;
    undefined field_0x36c;
    undefined field_0x36d;
    undefined field_0x36e;
    undefined field_0x36f;
    undefined field_0x370;
    undefined field_0x371;
    undefined field_0x372;
    undefined field_0x373;
    undefined field_0x374;
    undefined field_0x375;
    undefined field_0x376;
    undefined field_0x377;
    undefined field_0x378;
    undefined field_0x379;
    undefined field_0x37a;
    undefined field_0x37b;
    undefined field_0x37c;
    undefined field_0x37d;
    undefined field_0x37e;
    undefined field_0x37f;
    undefined field_0x380;
    undefined field_0x381;
    undefined field_0x382;
    undefined field_0x383;
    undefined field_0x384;
    undefined field_0x385;
    undefined field_0x386;
    undefined field_0x387;
    undefined field_0x388;
    undefined field_0x389;
    undefined field_0x38a;
    undefined field_0x38b;
    undefined field_0x38c;
    undefined field_0x38d;
    undefined field_0x38e;
    undefined field_0x38f;
    undefined field_0x390;
    undefined field_0x391;
    undefined field_0x392;
    undefined field_0x393;
    undefined field_0x394;
    undefined field_0x395;
    undefined field_0x396;
    undefined field_0x397;
    undefined field_0x398;
    undefined field_0x399;
    undefined field_0x39a;
    undefined field_0x39b;
    undefined field_0x39c;
    undefined field_0x39d;
    undefined field_0x39e;
    undefined field_0x39f;
    undefined field_0x3a0;
    undefined field_0x3a1;
    undefined field_0x3a2;
    undefined field_0x3a3;
    undefined field_0x3a4;
    undefined field_0x3a5;
    undefined field_0x3a6;
    undefined field_0x3a7;
    undefined field_0x3a8;
    undefined field_0x3a9;
    undefined field_0x3aa;
    undefined field_0x3ab;
    undefined field_0x3ac;
    undefined field_0x3ad;
    undefined field_0x3ae;
    undefined field_0x3af;
    undefined field_0x3b0;
    undefined field_0x3b1;
    undefined field_0x3b2;
    undefined field_0x3b3;
    undefined field_0x3b4;
    undefined field_0x3b5;
    undefined field_0x3b6;
    undefined field_0x3b7;
    undefined field_0x3b8;
    undefined field_0x3b9;
    undefined field_0x3ba;
    undefined field_0x3bb;
    undefined field_0x3bc;
    undefined field_0x3bd;
    undefined field_0x3be;
    undefined field_0x3bf;
    undefined field_0x3c0;
    undefined field_0x3c1;
    undefined field_0x3c2;
    undefined field_0x3c3;
    undefined field_0x3c4;
    undefined field_0x3c5;
    undefined field_0x3c6;
    undefined field_0x3c7;
    undefined field_0x3c8;
    undefined field_0x3c9;
    undefined field_0x3ca;
    undefined field_0x3cb;
    undefined field_0x3cc;
    undefined field_0x3cd;
    undefined field_0x3ce;
    undefined field_0x3cf;
    undefined field_0x3d0;
    undefined field_0x3d1;
    undefined field_0x3d2;
    undefined field_0x3d3;
    undefined field_0x3d4;
    undefined field_0x3d5;
    undefined field_0x3d6;
    undefined field_0x3d7;
    undefined field_0x3d8;
    undefined field_0x3d9;
    undefined field_0x3da;
    undefined field_0x3db;
    undefined field_0x3dc;
    undefined field_0x3dd;
    undefined field_0x3de;
    undefined field_0x3df;
    undefined field_0x3e0;
    undefined field_0x3e1;
    undefined field_0x3e2;
    undefined field_0x3e3;
    undefined field_0x3e4;
    undefined field_0x3e5;
    undefined field_0x3e6;
    undefined field_0x3e7;
    undefined field_0x3e8;
    undefined field_0x3e9;
    undefined field_0x3ea;
    undefined field_0x3eb;
    undefined field_0x3ec;
    undefined field_0x3ed;
    undefined field_0x3ee;
    undefined field_0x3ef;
    undefined field_0x3f0;
    undefined field_0x3f1;
    undefined field_0x3f2;
    undefined field_0x3f3;
    undefined field_0x3f4;
    undefined field_0x3f5;
    undefined field_0x3f6;
    undefined field_0x3f7;
    undefined field_0x3f8;
    undefined field_0x3f9;
    undefined field_0x3fa;
    undefined field_0x3fb;
    undefined field_0x3fc;
    undefined field_0x3fd;
    undefined field_0x3fe;
    undefined field_0x3ff;
    undefined field_0x400;
    undefined field_0x401;
    undefined field_0x402;
    undefined field_0x403;
    undefined field_0x404;
    undefined field_0x405;
    undefined field_0x406;
    undefined field_0x407;
    undefined field_0x408;
    undefined field_0x409;
    undefined field_0x40a;
    undefined field_0x40b;
    undefined field_0x40c;
    undefined field_0x40d;
    undefined field_0x40e;
    undefined field_0x40f;
    undefined field_0x410;
    undefined field_0x411;
    undefined field_0x412;
    undefined field_0x413;
    undefined field_0x414;
    undefined field_0x415;
    undefined field_0x416;
    undefined field_0x417;
    undefined field_0x418;
    undefined field_0x419;
    undefined field_0x41a;
    undefined field_0x41b;
    undefined field_0x41c;
    undefined field_0x41d;
    undefined field_0x41e;
    undefined field_0x41f;
    undefined field_0x420;
    undefined field_0x421;
    undefined field_0x422;
    undefined field_0x423;
    undefined field_0x424;
    undefined field_0x425;
    undefined field_0x426;
    undefined field_0x427;
    undefined field_0x428;
    undefined field_0x429;
    undefined field_0x42a;
    undefined field_0x42b;
    undefined field_0x42c;
    undefined field_0x42d;
    undefined field_0x42e;
    undefined field_0x42f;
    undefined field_0x430;
    undefined field_0x431;
    undefined field_0x432;
    undefined field_0x433;
    undefined field_0x434;
    undefined field_0x435;
    undefined field_0x436;
    undefined field_0x437;
    undefined field_0x438;
    undefined field_0x439;
    undefined field_0x43a;
    undefined field_0x43b;
    undefined field_0x43c;
    undefined field_0x43d;
    undefined field_0x43e;
    undefined field_0x43f;
    undefined field_0x440;
    undefined field_0x441;
    undefined field_0x442;
    undefined field_0x443;
    undefined field_0x444;
    undefined field_0x445;
    undefined field_0x446;
    undefined field_0x447;
    undefined field_0x448;
    undefined field_0x449;
    undefined field_0x44a;
    undefined field_0x44b;
    undefined field_0x44c;
    undefined field_0x44d;
    undefined field_0x44e;
    undefined field_0x44f;
    undefined field_0x450;
    undefined field_0x451;
    undefined field_0x452;
    undefined field_0x453;
    undefined field_0x454;
    undefined field_0x455;
    undefined field_0x456;
    undefined field_0x457;
    undefined field_0x458;
    undefined field_0x459;
    undefined field_0x45a;
    undefined field_0x45b;
    undefined field_0x45c;
    undefined field_0x45d;
    undefined field_0x45e;
    undefined field_0x45f;
    undefined field_0x460;
    undefined field_0x461;
    undefined field_0x462;
    undefined field_0x463;
    undefined field_0x464;
    undefined field_0x465;
    undefined field_0x466;
    undefined field_0x467;
    undefined field_0x468;
    undefined field_0x469;
    undefined field_0x46a;
    undefined field_0x46b;
    undefined field_0x46c;
    undefined field_0x46d;
    undefined field_0x46e;
    undefined field_0x46f;
    undefined field_0x470;
    undefined field_0x471;
    undefined field_0x472;
    undefined field_0x473;
    undefined field_0x474;
    undefined field_0x475;
    undefined field_0x476;
    undefined field_0x477;
    undefined field_0x478;
    undefined field_0x479;
    undefined field_0x47a;
    undefined field_0x47b;
    undefined field_0x47c;
    undefined field_0x47d;
    undefined field_0x47e;
    undefined field_0x47f;
    undefined field_0x480;
    undefined field_0x481;
    undefined field_0x482;
    undefined field_0x483;
    undefined field_0x484;
    undefined field_0x485;
    undefined field_0x486;
    undefined field_0x487;
    undefined field_0x488;
    undefined field_0x489;
    undefined field_0x48a;
    undefined field_0x48b;
    undefined field_0x48c;
    undefined field_0x48d;
    undefined field_0x48e;
    undefined field_0x48f;
    undefined field_0x490;
    undefined field_0x491;
    undefined field_0x492;
    undefined field_0x493;
    undefined field_0x494;
    undefined field_0x495;
    undefined field_0x496;
    undefined field_0x497;
    undefined field_0x498;
    undefined field_0x499;
    undefined field_0x49a;
    undefined field_0x49b;
    undefined field_0x49c;
    undefined field_0x49d;
    undefined field_0x49e;
    undefined field_0x49f;
    undefined field_0x4a0;
    undefined field_0x4a1;
    undefined field_0x4a2;
    undefined field_0x4a3;
    undefined field_0x4a4;
    undefined field_0x4a5;
    undefined field_0x4a6;
    undefined field_0x4a7;
    undefined field_0x4a8;
    undefined field_0x4a9;
    undefined field_0x4aa;
    undefined field_0x4ab;
    undefined field_0x4ac;
    undefined field_0x4ad;
    undefined field_0x4ae;
    undefined field_0x4af;
    undefined field_0x4b0;
    undefined field_0x4b1;
    undefined field_0x4b2;
    undefined field_0x4b3;
    undefined field_0x4b4;
    undefined field_0x4b5;
    undefined field_0x4b6;
    undefined field_0x4b7;
    undefined field_0x4b8;
    undefined field_0x4b9;
    undefined field_0x4ba;
    undefined field_0x4bb;
    undefined field_0x4bc;
    undefined field_0x4bd;
    undefined field_0x4be;
    undefined field_0x4bf;
    undefined field_0x4c0;
    undefined field_0x4c1;
    undefined field_0x4c2;
    undefined field_0x4c3;
    undefined field_0x4c4;
    undefined field_0x4c5;
    undefined field_0x4c6;
    undefined field_0x4c7;
    undefined field_0x4c8;
    undefined field_0x4c9;
    undefined field_0x4ca;
    undefined field_0x4cb;
    undefined field_0x4cc;
    undefined field_0x4cd;
    undefined field_0x4ce;
    undefined field_0x4cf;
    undefined field_0x4d0;
    undefined field_0x4d1;
    undefined field_0x4d2;
    undefined field_0x4d3;
    undefined field_0x4d4;
    undefined field_0x4d5;
    undefined field_0x4d6;
    undefined field_0x4d7;
    undefined field_0x4d8;
    undefined field_0x4d9;
    undefined field_0x4da;
    undefined field_0x4db;
    undefined field_0x4dc;
    undefined field_0x4dd;
    undefined field_0x4de;
    undefined field_0x4df;
    undefined field_0x4e0;
    undefined field_0x4e1;
    undefined field_0x4e2;
    undefined field_0x4e3;
    undefined field_0x4e4;
    undefined field_0x4e5;
    undefined field_0x4e6;
    undefined field_0x4e7;
    undefined field_0x4e8;
    undefined field_0x4e9;
    undefined field_0x4ea;
    undefined field_0x4eb;
    undefined field_0x4ec;
    undefined field_0x4ed;
    undefined field_0x4ee;
    undefined field_0x4ef;
    undefined field_0x4f0;
    undefined field_0x4f1;
    undefined field_0x4f2;
    undefined field_0x4f3;
    undefined field_0x4f4;
    undefined field_0x4f5;
    undefined field_0x4f6;
    undefined field_0x4f7;
    undefined field_0x4f8;
    undefined field_0x4f9;
    undefined field_0x4fa;
    undefined field_0x4fb;
    undefined field_0x4fc;
    undefined field_0x4fd;
    undefined field_0x4fe;
    undefined field_0x4ff;
    undefined field_0x500;
    undefined field_0x501;
    undefined field_0x502;
    undefined field_0x503;
    undefined field_0x504;
    undefined field_0x505;
    undefined field_0x506;
    undefined field_0x507;
    undefined field_0x508;
    undefined field_0x509;
    undefined field_0x50a;
    undefined field_0x50b;
    undefined field_0x50c;
    undefined field_0x50d;
    undefined field_0x50e;
    undefined field_0x50f;
    undefined field_0x510;
    undefined field_0x511;
    undefined field_0x512;
    undefined field_0x513;
    undefined field_0x514;
    undefined field_0x515;
    undefined field_0x516;
    undefined field_0x517;
    undefined field_0x518;
    undefined field_0x519;
    undefined field_0x51a;
    undefined field_0x51b;
    undefined field_0x51c;
    undefined field_0x51d;
    undefined field_0x51e;
    undefined field_0x51f;
    undefined field_0x520;
    undefined field_0x521;
    undefined field_0x522;
    undefined field_0x523;
    undefined field_0x524;
    undefined field_0x525;
    undefined field_0x526;
    undefined field_0x527;
    undefined field_0x528;
    undefined field_0x529;
    undefined field_0x52a;
    undefined field_0x52b;
    undefined field_0x52c;
    undefined field_0x52d;
    undefined field_0x52e;
    undefined field_0x52f;
    undefined field_0x530;
    undefined field_0x531;
    undefined field_0x532;
    undefined field_0x533;
    undefined field_0x534;
    undefined field_0x535;
    undefined field_0x536;
    undefined field_0x537;
    undefined field_0x538;
    undefined field_0x539;
    undefined field_0x53a;
    undefined field_0x53b;
    undefined field_0x53c;
    undefined field_0x53d;
    undefined field_0x53e;
    undefined field_0x53f;
    undefined field_0x540;
    undefined field_0x541;
    undefined field_0x542;
    undefined field_0x543;
    undefined field_0x544;
    undefined field_0x545;
    undefined field_0x546;
    undefined field_0x547;
    undefined field_0x548;
    undefined field_0x549;
    undefined field_0x54a;
    undefined field_0x54b;
    undefined field_0x54c;
    undefined field_0x54d;
    undefined field_0x54e;
    undefined field_0x54f;
    undefined field_0x550;
    undefined field_0x551;
    undefined field_0x552;
    undefined field_0x553;
    undefined field_0x554;
    undefined field_0x555;
    undefined field_0x556;
    undefined field_0x557;
    undefined field_0x558;
    undefined field_0x559;
    undefined field_0x55a;
    undefined field_0x55b;
    undefined field_0x55c;
    undefined field_0x55d;
    undefined field_0x55e;
    undefined field_0x55f;
    undefined field_0x560;
    undefined field_0x561;
    undefined field_0x562;
    undefined field_0x563;
    undefined field_0x564;
    undefined field_0x565;
    undefined field_0x566;
    undefined field_0x567;
    undefined field_0x568;
    undefined field_0x569;
    undefined field_0x56a;
    undefined field_0x56b;
    undefined field_0x56c;
    undefined field_0x56d;
    undefined field_0x56e;
    undefined field_0x56f;
    undefined field_0x570;
    undefined field_0x571;
    undefined field_0x572;
    undefined field_0x573;
    undefined field_0x574;
    undefined field_0x575;
    undefined field_0x576;
    undefined field_0x577;
    undefined field_0x578;
    undefined field_0x579;
    undefined field_0x57a;
    undefined field_0x57b;
    undefined field_0x57c;
    undefined field_0x57d;
    undefined field_0x57e;
    undefined field_0x57f;
    undefined field_0x580;
    undefined field_0x581;
    undefined field_0x582;
    undefined field_0x583;
    undefined field_0x584;
    undefined field_0x585;
    undefined field_0x586;
    undefined field_0x587;
    undefined field_0x588;
    undefined field_0x589;
    undefined field_0x58a;
    undefined field_0x58b;
    undefined field_0x58c;
    undefined field_0x58d;
    undefined field_0x58e;
    undefined field_0x58f;
    undefined field_0x590;
    undefined field_0x591;
    undefined field_0x592;
    undefined field_0x593;
    undefined field_0x594;
    undefined field_0x595;
    undefined field_0x596;
    undefined field_0x597;
    undefined field_0x598;
    undefined field_0x599;
    undefined field_0x59a;
    undefined field_0x59b;
    undefined field_0x59c;
    undefined field_0x59d;
    undefined field_0x59e;
    undefined field_0x59f;
    undefined field_0x5a0;
    undefined field_0x5a1;
    undefined field_0x5a2;
    undefined field_0x5a3;
    undefined field_0x5a4;
    undefined field_0x5a5;
    undefined field_0x5a6;
    undefined field_0x5a7;
    undefined field_0x5a8;
    undefined field_0x5a9;
    undefined field_0x5aa;
    undefined field_0x5ab;
    undefined field_0x5ac;
    undefined field_0x5ad;
    undefined field_0x5ae;
    undefined field_0x5af;
    undefined field_0x5b0;
    undefined field_0x5b1;
    undefined field_0x5b2;
    undefined field_0x5b3;
    undefined field_0x5b4;
    undefined field_0x5b5;
    undefined field_0x5b6;
    undefined field_0x5b7;
    undefined field_0x5b8;
    undefined field_0x5b9;
    undefined field_0x5ba;
    undefined field_0x5bb;
    undefined field_0x5bc;
    undefined field_0x5bd;
    undefined field_0x5be;
    undefined field_0x5bf;
    undefined field_0x5c0;
    undefined field_0x5c1;
    undefined field_0x5c2;
    undefined field_0x5c3;
    undefined field_0x5c4;
    undefined field_0x5c5;
    undefined field_0x5c6;
    undefined field_0x5c7;
    undefined field_0x5c8;
    undefined field_0x5c9;
    undefined field_0x5ca;
    undefined field_0x5cb;
    undefined field_0x5cc;
    undefined field_0x5cd;
    undefined field_0x5ce;
    undefined field_0x5cf;
    undefined field_0x5d0;
    undefined field_0x5d1;
    undefined field_0x5d2;
    undefined field_0x5d3;
    undefined field_0x5d4;
    undefined field_0x5d5;
    undefined field_0x5d6;
    undefined field_0x5d7;
    undefined field_0x5d8;
    undefined field_0x5d9;
    undefined field_0x5da;
    undefined field_0x5db;
    undefined field_0x5dc;
    undefined field_0x5dd;
    undefined field_0x5de;
    undefined field_0x5df;
    undefined field_0x5e0;
    undefined field_0x5e1;
    undefined field_0x5e2;
    undefined field_0x5e3;
    undefined field_0x5e4;
    undefined field_0x5e5;
    undefined field_0x5e6;
    undefined field_0x5e7;
    undefined field_0x5e8;
    undefined field_0x5e9;
    undefined field_0x5ea;
    undefined field_0x5eb;
    undefined field_0x5ec;
    undefined field_0x5ed;
    undefined field_0x5ee;
    undefined field_0x5ef;
    undefined field_0x5f0;
    undefined field_0x5f1;
    undefined field_0x5f2;
    undefined field_0x5f3;
    undefined field_0x5f4;
    undefined field_0x5f5;
    undefined field_0x5f6;
    undefined field_0x5f7;
    undefined field_0x5f8;
    undefined field_0x5f9;
    undefined field_0x5fa;
    undefined field_0x5fb;
    undefined field_0x5fc;
    undefined field_0x5fd;
    undefined field_0x5fe;
    undefined field_0x5ff;
    undefined field_0x600;
    undefined field_0x601;
    undefined field_0x602;
    undefined field_0x603;
    undefined field_0x604;
    undefined field_0x605;
    undefined field_0x606;
    undefined field_0x607;
    undefined field_0x608;
    undefined field_0x609;
    undefined field_0x60a;
    undefined field_0x60b;
    undefined field_0x60c;
    undefined field_0x60d;
    undefined field_0x60e;
    undefined field_0x60f;
    undefined field_0x610;
    undefined field_0x611;
    undefined field_0x612;
    undefined field_0x613;
    undefined field_0x614;
    undefined field_0x615;
    undefined field_0x616;
    undefined field_0x617;
    undefined field_0x618;
    undefined field_0x619;
    undefined field_0x61a;
    undefined field_0x61b;
    undefined field_0x61c;
    undefined field_0x61d;
    undefined field_0x61e;
    undefined field_0x61f;
    undefined field_0x620;
    undefined field_0x621;
    undefined field_0x622;
    undefined field_0x623;
    undefined field_0x624;
    undefined field_0x625;
    undefined field_0x626;
    undefined field_0x627;
    undefined field_0x628;
    undefined field_0x629;
    undefined field_0x62a;
    undefined field_0x62b;
    undefined field_0x62c;
    undefined field_0x62d;
    undefined field_0x62e;
    undefined field_0x62f;
    undefined field_0x630;
    undefined field_0x631;
    undefined field_0x632;
    undefined field_0x633;
    undefined field_0x634;
    undefined field_0x635;
    undefined field_0x636;
    undefined field_0x637;
    undefined field_0x638;
    undefined field_0x639;
    undefined field_0x63a;
    undefined field_0x63b;
    undefined field_0x63c;
    undefined field_0x63d;
    undefined field_0x63e;
    undefined field_0x63f;
    undefined field_0x640;
    undefined field_0x641;
    undefined field_0x642;
    undefined field_0x643;
    undefined field_0x644;
    undefined field_0x645;
    undefined field_0x646;
    undefined field_0x647;
    undefined field_0x648;
    undefined field_0x649;
    undefined field_0x64a;
    undefined field_0x64b;
    undefined field_0x64c;
    undefined field_0x64d;
    undefined field_0x64e;
    undefined field_0x64f;
    undefined field_0x650;
    undefined field_0x651;
    undefined field_0x652;
    undefined field_0x653;
    undefined field_0x654;
    undefined field_0x655;
    undefined field_0x656;
    undefined field_0x657;
    undefined field_0x658;
    undefined field_0x659;
    undefined field_0x65a;
    undefined field_0x65b;
    undefined field_0x65c;
    undefined field_0x65d;
    undefined field_0x65e;
    undefined field_0x65f;
    undefined field_0x660;
    undefined field_0x661;
    undefined field_0x662;
    undefined field_0x663;
    undefined field_0x664;
    undefined field_0x665;
    undefined field_0x666;
    undefined field_0x667;
    undefined field_0x668;
    undefined field_0x669;
    undefined field_0x66a;
    undefined field_0x66b;
    undefined field_0x66c;
    undefined field_0x66d;
    undefined field_0x66e;
    undefined field_0x66f;
    undefined field_0x670;
    undefined field_0x671;
    undefined field_0x672;
    undefined field_0x673;
    undefined field_0x674;
    undefined field_0x675;
    undefined field_0x676;
    undefined field_0x677;
    undefined field_0x678;
    undefined field_0x679;
    undefined field_0x67a;
    undefined field_0x67b;
    undefined field_0x67c;
    undefined field_0x67d;
    undefined field_0x67e;
    undefined field_0x67f;
    undefined field_0x680;
    undefined field_0x681;
    undefined field_0x682;
    undefined field_0x683;
    undefined field_0x684;
    undefined field_0x685;
    undefined field_0x686;
    undefined field_0x687;
    undefined field_0x688;
    undefined field_0x689;
    undefined field_0x68a;
    undefined field_0x68b;
    undefined field_0x68c;
    undefined field_0x68d;
    undefined field_0x68e;
    undefined field_0x68f;
    undefined field_0x690;
    undefined field_0x691;
    undefined field_0x692;
    undefined field_0x693;
    undefined field_0x694;
    undefined field_0x695;
    undefined field_0x696;
    undefined field_0x697;
    undefined field_0x698;
    undefined field_0x699;
    undefined field_0x69a;
    undefined field_0x69b;
    undefined field_0x69c;
    undefined field_0x69d;
    undefined field_0x69e;
    undefined field_0x69f;
    undefined field_0x6a0;
    undefined field_0x6a1;
    undefined field_0x6a2;
    undefined field_0x6a3;
    undefined field_0x6a4;
    undefined field_0x6a5;
    undefined field_0x6a6;
    undefined field_0x6a7;
    undefined field_0x6a8;
    undefined field_0x6a9;
    undefined field_0x6aa;
    undefined field_0x6ab;
    undefined field_0x6ac;
    undefined field_0x6ad;
    undefined field_0x6ae;
    undefined field_0x6af;
    undefined field_0x6b0;
    undefined field_0x6b1;
    undefined field_0x6b2;
    undefined field_0x6b3;
    undefined field_0x6b4;
    undefined field_0x6b5;
    undefined field_0x6b6;
    undefined field_0x6b7;
    undefined field_0x6b8;
    undefined field_0x6b9;
    undefined field_0x6ba;
    undefined field_0x6bb;
    undefined field_0x6bc;
    undefined field_0x6bd;
    undefined field_0x6be;
    undefined field_0x6bf;
    undefined field_0x6c0;
    undefined field_0x6c1;
    undefined field_0x6c2;
    undefined field_0x6c3;
};

typedef struct plow_info plow_info, *Pplow_info;

typedef struct DataType * DataTypePtr.conflict;

struct plow_info {
    int type;
    void * ptr1;
    void * ptr2;
    LayerTypePtr layer;
    DataTypePtr.conflict data;
    int (* callback)(DataTypePtr.conflict, LayerTypePtr, PolygonTypePtr, int, void *, void *);
};

typedef enum anon_enum_32 {
    Uin=3,
    Umil=2,
    Umm=1,
    Upcb=0
} anon_enum_32;

typedef void (* GBaseFinalizeFunc)(gpointer);

typedef struct _GTypeValueTable _GTypeValueTable, *P_GTypeValueTable;

typedef union _GTypeCValue _GTypeCValue, *P_GTypeCValue;

typedef union _GTypeCValue GTypeCValue;

struct _GTypeValueTable {
    void (* value_init)(GValue *);
    void (* value_free)(GValue *);
    void (* value_copy)(GValue *, GValue *);
    gpointer (* value_peek_pointer)(GValue *);
    gchar * collect_format;
    gchar * (* collect_value)(GValue *, guint, GTypeCValue *, guint);
    gchar * lcopy_format;
    gchar * (* lcopy_value)(GValue *, guint, GTypeCValue *, guint);
};

union _GTypeCValue {
};

typedef void (* GBaseInitFunc)(gpointer);

typedef struct _GTypeValueTable GTypeValueTable;

typedef void (* GClassFinalizeFunc)(gpointer, gpointer);

typedef struct _GTypeInfo _GTypeInfo, *P_GTypeInfo;

typedef struct _GTypeInfo GTypeInfo;

typedef void (* GClassInitFunc)(gpointer, gpointer);

typedef void * gconstpointer;

struct _GTypeInfo {
    guint16 class_size;
    undefined field_0x2;
    undefined field_0x3;
    GBaseInitFunc base_init;
    GBaseFinalizeFunc base_finalize;
    GClassInitFunc class_init;
    GClassFinalizeFunc class_finalize;
    gconstpointer class_data;
    guint16 instance_size;
    guint16 n_preallocs;
    void (* instance_init)(GTypeInstance *, gpointer);
    GTypeValueTable * value_table;
};

typedef struct _GtkRadioAction _GtkRadioAction, *P_GtkRadioAction;

typedef struct _GtkRadioActionPrivate _GtkRadioActionPrivate, *P_GtkRadioActionPrivate;

typedef struct _GtkRadioActionPrivate GtkRadioActionPrivate;

struct _GtkRadioActionPrivate {
};

struct _GtkRadioAction {
    GtkToggleAction parent;
    GtkRadioActionPrivate * private_data;
};

typedef struct _GtkRadioAction GtkRadioAction;

typedef struct drc_info drc_info, *Pdrc_info;

struct drc_info {
    LineTypePtr line;
    Boolean solder;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    jmp_buf env;
};

typedef struct _GSourceFuncs.conflict _GSourceFuncs.conflict, *P_GSourceFuncs.conflict;

typedef void (* GSourceDummyMarshal.conflict)(void);

struct _GSourceFuncs.conflict {
    gboolean (* prepare)(GSource *, gint *);
    gboolean (* check)(GSource *);
    gboolean (* dispatch)(GSource *, gboolean (* )(gpointer), gpointer);
    void (* finalize)(GSource *);
    gboolean (* closure_callback)(gpointer);
    GSourceDummyMarshal.conflict closure_marshal;
};

typedef struct _GSourceFuncs.conflict GSourceFuncs.conflict;

typedef struct _GMainLoop _GMainLoop, *P_GMainLoop;

typedef struct _GMainLoop GMainLoop;

struct _GMainLoop {
};

typedef struct _GtkToggleActionEntry _GtkToggleActionEntry, *P_GtkToggleActionEntry;

typedef struct _GtkToggleActionEntry GtkToggleActionEntry;

typedef void (* GCallback.conflict)(void);

struct _GtkToggleActionEntry {
    gchar * name;
    gchar * stock_id;
    gchar * label;
    gchar * accelerator;
    gchar * tooltip;
    GCallback.conflict callback;
    gboolean is_active;
};

typedef struct _GtkActionGroup _GtkActionGroup, *P_GtkActionGroup;

typedef struct _GtkActionGroupPrivate _GtkActionGroupPrivate, *P_GtkActionGroupPrivate;

typedef struct _GtkActionGroupPrivate GtkActionGroupPrivate;

struct _GtkActionGroup {
    GObject parent;
    GtkActionGroupPrivate * private_data;
};

struct _GtkActionGroupPrivate {
};

typedef struct _GtkRadioActionEntry _GtkRadioActionEntry, *P_GtkRadioActionEntry;

typedef struct _GtkRadioActionEntry GtkRadioActionEntry;

struct _GtkRadioActionEntry {
    gchar * name;
    gchar * stock_id;
    gchar * label;
    gchar * accelerator;
    gchar * tooltip;
    gint value;
};

typedef struct _GtkActionEntry _GtkActionEntry, *P_GtkActionEntry;

struct _GtkActionEntry {
    gchar * name;
    gchar * stock_id;
    gchar * label;
    gchar * accelerator;
    gchar * tooltip;
    GCallback.conflict callback;
};

typedef struct _GtkActionGroup GtkActionGroup;

typedef struct _GtkActionEntry GtkActionEntry;

typedef struct ghid_file_history_struct ghid_file_history_struct, *Pghid_file_history_struct;

typedef struct ghid_file_history_struct ghid_file_history;

struct ghid_file_history_struct {
    char * id;
    char * history[8];
};

typedef struct _GtkTextIter _GtkTextIter, *P_GtkTextIter;

typedef struct _GtkTextIter GtkTextIter;

struct _GtkTextIter {
    gpointer dummy1;
    gpointer dummy2;
    gint dummy3;
    gint dummy4;
    gint dummy5;
    gint dummy6;
    gint dummy7;
    gint dummy8;
    gpointer dummy9;
    gpointer dummy10;
    gint dummy11;
    gint dummy12;
    gint dummy13;
    gpointer dummy14;
};

typedef struct FlagHolder FlagHolder, *PFlagHolder;

struct FlagHolder {
    struct FlagType Flags;
};

typedef struct anon_struct.conflict47 anon_struct.conflict47, *Panon_struct.conflict47;

struct anon_struct.conflict47 {
    char * ptr;
    int len;
};

typedef struct FlagBitsType FlagBitsType, *PFlagBitsType;

struct FlagBitsType {
    int mask;
    char * name;
    int nlen;
    int object_types;
};

typedef struct _GtkNotebookPage _GtkNotebookPage, *P_GtkNotebookPage;

typedef struct _GtkNotebookPage GtkNotebookPage;

struct _GtkNotebookPage {
};

typedef struct _GtkNotebook _GtkNotebook, *P_GtkNotebook;

struct _GtkNotebook {
    GtkContainer container;
    GtkNotebookPage * cur_page;
    GList * children;
    GList * first_tab;
    GList * focus_tab;
    GtkWidget * menu;
    GdkWindow * event_window;
    guint32 timer;
    guint16 tab_hborder;
    guint16 tab_vborder;
    guint show_tabs:1;
    guint homogeneous:1;
    guint show_border:1;
    guint tab_pos:2;
    guint scrollable:1;
    guint in_child:3;
    guint click_child:3;
    guint button:2;
    guint need_timer:1;
    guint child_has_focus:1;
    guint have_visible_child:1;
    guint focus_out:1;
    guint has_before_previous:1;
    guint has_before_next:1;
    guint has_after_previous:1;
    guint has_after_next:1;
    undefined field_0x67;
};

typedef struct _GtkNotebook GtkNotebook;

typedef struct _PangoLayout _PangoLayout, *P_PangoLayout;

typedef struct _PangoLayout PangoLayout;

struct _PangoLayout {
};

typedef struct vetting vetting, *Pvetting;

typedef union heap_or_vector heap_or_vector, *Pheap_or_vector;

typedef struct heap_struct heap_struct, *Pheap_struct;

typedef struct heap_struct heap_t;

typedef struct heap_element heap_element, *Pheap_element;

typedef double cost_t;

union heap_or_vector {
    vector_t * v;
    heap_t * h;
};

struct vetting {
    union heap_or_vector untested;
    union heap_or_vector no_fix;
    union heap_or_vector no_hi;
    union heap_or_vector hi_candidate;
    BDimension radius;
    BDimension keepaway;
    CheapPointType desired;
};

struct heap_struct {
    struct heap_element * element;
    int size;
    int max;
};

struct heap_element {
    cost_t cost;
    void * data;
};

typedef struct mtspace mtspace, *Pmtspace;

typedef struct mtspace mtspace_t;

struct mtspace {
    rtree_t * ftree;
    rtree_t * etree;
    rtree_t * otree;
};

typedef enum mtspace_type_t {
    EVEN=2,
    FIXED=0,
    ODD=1
} mtspace_type_t;

typedef struct vetting vetting_t;

typedef struct _GtkTreeViewColumn _GtkTreeViewColumn, *P_GtkTreeViewColumn;

typedef struct _GtkTreeViewColumn GtkTreeViewColumn;

typedef struct _GtkCellEditable _GtkCellEditable, *P_GtkCellEditable;

typedef struct _GtkCellEditable GtkCellEditable;

typedef enum GtkTreeViewColumnSizing {
    GTK_TREE_VIEW_COLUMN_AUTOSIZE=1,
    GTK_TREE_VIEW_COLUMN_FIXED=2,
    GTK_TREE_VIEW_COLUMN_GROW_ONLY=0
} GtkTreeViewColumnSizing;

typedef enum GtkSortType {
    GTK_SORT_ASCENDING=0,
    GTK_SORT_DESCENDING=1
} GtkSortType;

struct _GtkTreeViewColumn {
    GtkObject parent;
    GtkWidget * tree_view;
    GtkWidget * button;
    GtkWidget * child;
    GtkWidget * arrow;
    GtkWidget * alignment;
    GdkWindow * window;
    GtkCellEditable * editable_widget;
    gfloat xalign;
    guint property_changed_signal;
    gint spacing;
    enum GtkTreeViewColumnSizing column_type;
    gint requested_width;
    gint button_request;
    gint resized_width;
    gint width;
    gint fixed_width;
    gint min_width;
    gint max_width;
    gint drag_x;
    gint drag_y;
    gchar * title;
    GList * cell_list;
    guint sort_clicked_signal;
    guint sort_column_changed_signal;
    gint sort_column_id;
    enum GtkSortType sort_order;
    guint visible:1;
    guint resizable:1;
    guint clickable:1;
    guint dirty:1;
    guint show_sort_indicator:1;
    guint maybe_reordered:1;
    guint reorderable:1;
    guint use_resized_width:1;
    guint expand:1;
    undefined field_0x7a;
    undefined field_0x7b;
};

struct _GtkCellEditable {
};

typedef struct query_closure query_closure, *Pquery_closure;

struct query_closure {
    struct BoxType * cbox;
    union heap_or_vector checking;
    union heap_or_vector touching;
    CheapPointType * desired;
    BDimension radius;
    BDimension keepaway;
    jmp_buf env;
    Boolean touch_is_vec;
    undefined field_0xb5;
    undefined field_0xb6;
    undefined field_0xb7;
};

typedef struct mtspacebox mtspacebox, *Pmtspacebox;

typedef struct mtspacebox mtspacebox_t;

struct mtspacebox {
    struct BoxType box;
    BDimension keepaway;
};

typedef struct mts_info mts_info, *Pmts_info;

struct mts_info {
    BDimension keepaway;
    struct BoxType box;
    rtree_t * tree;
    jmp_buf env;
};

typedef struct r_neighbor_info r_neighbor_info, *Pr_neighbor_info;

struct r_neighbor_info {
    struct BoxType * neighbor;
    struct BoxType trap;
    enum direction_t search_dir;
};

typedef struct anon_struct.conflict18 anon_struct.conflict18, *Panon_struct.conflict18;

struct anon_struct.conflict18 {
    float via_cost;
    float congestion_penalty;
    float overlap_penalty_min;
    float overlap_penalty_max;
    float out_of_bounds_penalty;
    float overall_area_penalty;
    float matching_neighbor_bonus;
    float aligned_neighbor_bonus;
    float oriented_neighbor_bonus;
    float m;
    float gamma;
    int good_ratio;
    Boolean fast;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
    int large_grid_size;
    int small_grid_size;
};

typedef struct PerturbationType PerturbationType, *PPerturbationType;

typedef enum anon_enum_32_for_which {
    EXCHANGE=2,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    ROTATE=1,
    SHIFT=0
} anon_enum_32_for_which;

struct PerturbationType {
    struct ElementTypePtr * element;
    enum anon_enum_32_for_which which;
    LocationType DX;
    LocationType DY;
    BYTE rotate;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
    struct ElementTypePtr * other;
};

typedef struct ebox ebox, *Pebox;

struct ebox {
    struct BoxType box;
    struct ElementTypePtr * element;
};

typedef struct _SFindClosest _SFindClosest, *P_SFindClosest;

typedef struct _SFindClosest SFindClosest;

struct _SFindClosest {
    gdouble dmin;
    GtsFace * closest;
    GtsPoint * p;
    gint stop;
};

typedef struct ecache ecache, *Pecache;

struct ecache {
    struct ecache * next;
    char * name;
    union hidval val;
};

typedef struct ccache ccache, *Pccache;

struct ccache {
    struct ecache * colors[31];
    struct ecache * lru;
};

typedef struct DynamicStringType DynamicStringType, *PDynamicStringType;

struct DynamicStringType {
    size_t MaxLength;
    char * Data;
};

typedef struct anon_struct.conflict39 anon_struct.conflict39, *Panon_struct.conflict39;

struct anon_struct.conflict39 {
    size_t MaxLength;
    char * Data;
};

typedef struct DynamicStringTypePtr.conflict DynamicStringTypePtr.conflict, *PDynamicStringTypePtr.conflict;

struct DynamicStringTypePtr.conflict {
    size_t MaxLength;
    char * Data;
};

typedef struct DynamicStringType * DynamicStringTypePtr;

typedef struct _GtkTreeStore.conflict _GtkTreeStore.conflict, *P_GtkTreeStore.conflict;

typedef struct _GtkTreeStore.conflict GtkTreeStore.conflict;

struct _GtkTreeStore.conflict {
    GObject parent;
    gint stamp;
    gpointer root;
    gpointer last;
    gint n_columns;
    gint sort_column_id;
    GList * sort_list;
    enum GtkSortType order;
    GType * column_headers;
    gint (* default_sort_func)(GtkTreeModel *, GtkTreeIter *, GtkTreeIter *, gpointer);
    gpointer default_sort_data;
    GDestroyNotify.conflict default_sort_destroy;
    guint columns_dirty:1;
    undefined field_0x39;
    undefined field_0x3a;
    undefined field_0x3b;
};

typedef struct _GtkTreeStore _GtkTreeStore, *P_GtkTreeStore;

struct _GtkTreeStore {
    GObject parent;
    gint stamp;
    gpointer root;
    gpointer last;
    gint n_columns;
    gint sort_column_id;
    GList * sort_list;
    enum GtkSortType order;
    GType * column_headers;
    gint (* default_sort_func)(GtkTreeModel *, GtkTreeIter *, GtkTreeIter *, gpointer);
    gpointer default_sort_data;
    void (* default_sort_destroy)(gpointer);
    guint columns_dirty:1;
    undefined field_0x39;
    undefined field_0x3a;
    undefined field_0x3b;
};

typedef struct _GtkTreeStore GtkTreeStore;

typedef struct _GtkColorButton _GtkColorButton, *P_GtkColorButton;

typedef struct _GtkColorButtonPrivate _GtkColorButtonPrivate, *P_GtkColorButtonPrivate;

typedef struct _GtkColorButtonPrivate GtkColorButtonPrivate;

struct _GtkColorButtonPrivate {
};

struct _GtkColorButton {
    GtkButton button;
    GtkColorButtonPrivate * priv;
};

typedef enum GtkPolicyType {
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2
} GtkPolicyType;

typedef enum GtkPositionType {
    GTK_POS_BOTTOM=3,
    GTK_POS_LEFT=0,
    GTK_POS_RIGHT=1,
    GTK_POS_TOP=2
} GtkPositionType;

typedef enum GtkShadowType {
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2
} GtkShadowType;

typedef struct color_struct color_struct, *Pcolor_struct;

struct color_struct {
    int c;
    uint r;
    uint g;
    uint b;
};

typedef struct _GtkLabelSelectionInfo _GtkLabelSelectionInfo, *P_GtkLabelSelectionInfo;

typedef struct _GtkLabelSelectionInfo GtkLabelSelectionInfo;

struct _GtkLabelSelectionInfo {
};

typedef struct _GtkLabel _GtkLabel, *P_GtkLabel;

typedef struct _GtkMisc _GtkMisc, *P_GtkMisc;

typedef struct _GtkMisc GtkMisc;

typedef struct _PangoAttrList _PangoAttrList, *P_PangoAttrList;

typedef struct _PangoAttrList PangoAttrList;

struct _PangoAttrList {
};

struct _GtkMisc {
    GtkWidget widget;
    gfloat xalign;
    gfloat yalign;
    guint16 xpad;
    guint16 ypad;
};

struct _GtkLabel {
    GtkMisc misc;
    gchar * label;
    guint jtype:2;
    guint wrap:1;
    guint use_underline:1;
    guint use_markup:1;
    guint ellipsize:3;
    guint single_line_mode:1;
    guint have_transform:1;
    guint in_click:1;
    guint wrap_mode:3;
    guint pattern_set:1;
    guint track_links:1;
    undefined field_0x4e;
    undefined field_0x4f;
    guint mnemonic_keyval;
    gchar * text;
    PangoAttrList * attrs;
    PangoAttrList * effective_attrs;
    PangoLayout * layout;
    GtkWidget * mnemonic_widget;
    GtkWindow * mnemonic_window;
    GtkLabelSelectionInfo * select_info;
};

typedef union yyalloc yyalloc, *Pyyalloc;

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef struct _pair_list _pair_list, *P_pair_list;

typedef struct _pair_list pair_list;

typedef struct _str_pair _str_pair, *P_str_pair;

typedef struct _str_pair str_pair;

union YYSTYPE {
    char * s;
    pair_list * pl;
    str_pair * ps;
};

union yyalloc {
    yytype_int16 yyss;
    union YYSTYPE yyvs;
};

struct _pair_list {
    char * name;
    str_pair * list;
};

struct _str_pair {
    char * str1;
    char * str2;
    struct _str_pair * next;
};

typedef ushort yytype_uint16;

typedef uchar yytype_uint8;

typedef struct Keyword Keyword, *PKeyword;

struct Keyword {
    struct Keyword * Next;
    char * String;
};

typedef struct Token Token, *PToken;

struct Token {
    char * Name;
    int Code;
    struct Token * Next;
};

typedef union anon_union.conflict anon_union.conflict, *Panon_union.conflict;

typedef struct UsedCar UsedCar, *PUsedCar;

union anon_union.conflict {
    int Single;
    struct UsedCar * Used;
};

struct UsedCar {
    struct UsedCar * Next;
    short Code;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct Binder Binder, *PBinder;

struct Binder {
    short * Follower;
    short Origin;
    short FollowerSize;
};

typedef struct Tie Tie, *PTie;

struct Tie {
    short * Enable;
    short Origin;
    short EnableSize;
};

typedef struct Context Context, *PContext;

typedef struct ContextCar ContextCar, *PContextCar;

typedef struct TokenCar TokenCar, *PTokenCar;


// WARNING! conflicting data type names: /DWARF/edif.y/ContextCar/anon_union_for_u - /DWARF/global.h/rtree_node/anon_union_for_u

struct Context {
    char * Name;
    short Code;
    short Flags;
    struct ContextCar * Context;
    struct TokenCar * Token;
    struct Context * Next;
};

struct ContextCar {
    struct ContextCar * Next;
    struct Context * Context;
    union anon_union_for_u u;
};

struct TokenCar {
    struct TokenCar * Next;
    struct Token * Token;
};

typedef struct Bucket Bucket, *PBucket;

struct Bucket {
    struct Bucket * Next;
    int Index;
    char Data[64];
};

typedef struct MediaType MediaType, *PMediaType;

struct MediaType {
    char * name;
    long Width;
    long Height;
    long MarginX;
    long MarginY;
};

typedef struct FindPairCallbackStruct FindPairCallbackStruct, *PFindPairCallbackStruct;

typedef struct Extra Extra, *PExtra;

typedef struct End End, *PEnd;

struct End {
    struct Extra * next;
    void * pin;
    uchar in_pin:1;
    uchar at_pin:1;
    uchar is_pad:1;
    uchar pending:1;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    int x;
    int y;
    struct End * waiting_for;
};

struct Extra {
    struct End start;
    struct End end;
    uchar found:1;
    uchar deleted:1;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
};

struct FindPairCallbackStruct {
    void * me;
    int x;
    int y;
    int is_arc;
    struct Extra * * extra_ptr;
};

typedef struct _GtkTreeModelFilter _GtkTreeModelFilter, *P_GtkTreeModelFilter;

typedef struct _GtkTreeModelFilterPrivate _GtkTreeModelFilterPrivate, *P_GtkTreeModelFilterPrivate;

typedef struct _GtkTreeModelFilterPrivate GtkTreeModelFilterPrivate;

struct _GtkTreeModelFilter {
    GObject parent;
    GtkTreeModelFilterPrivate * priv;
};

struct _GtkTreeModelFilterPrivate {
};

typedef struct _GtkFileFilter _GtkFileFilter, *P_GtkFileFilter;

typedef struct _GtkFileFilter GtkFileFilter;

struct _GtkFileFilter {
};

typedef uint yy_size_t;

typedef uchar YY_CHAR;

typedef int yy_state_type;

typedef struct yy_buffer_state yy_buffer_state, *Pyy_buffer_state;

struct yy_buffer_state {
    FILE * yy_input_file;
    char * yy_ch_buf;
    char * yy_buf_pos;
    yy_size_t yy_buf_size;
    int yy_n_chars;
    int yy_is_our_buffer;
    int yy_is_interactive;
    int yy_at_bol;
    int yy_fill_buffer;
    int yy_buffer_status;
};

typedef struct yy_buffer_state * YY_BUFFER_STATE;

typedef struct __dirstream __dirstream, *P__dirstream;

typedef struct __dirstream DIR;

struct __dirstream {
};

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino_t d_ino;
    __off_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
    undefined field_0x10b;
};

typedef struct _GtkTooltipsData _GtkTooltipsData, *P_GtkTooltipsData;

typedef struct _GtkTooltipsData GtkTooltipsData;

typedef struct _GtkTooltips _GtkTooltips, *P_GtkTooltips;

typedef struct _GtkTooltips GtkTooltips;

typedef struct _GTimeVal _GTimeVal, *P_GTimeVal;

typedef struct _GTimeVal GTimeVal;

struct _GtkTooltipsData {
    GtkTooltips * tooltips;
    GtkWidget * widget;
    gchar * tip_text;
    gchar * tip_private;
};

struct _GTimeVal {
    glong tv_sec;
    glong tv_usec;
};

struct _GtkTooltips {
    GtkObject parent_instance;
    GtkWidget * tip_window;
    GtkWidget * tip_label;
    GtkTooltipsData * active_tips_data;
    GList * tips_data_list;
    guint delay:30;
    guint enabled:1;
    guint have_grab:1;
    guint use_sticky_delay:1;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    gint timer_tag;
    GTimeVal last_popdown;
};

typedef struct routeone_state routeone_state, *Prouteone_state;

typedef struct routebox routebox, *Proutebox;

typedef struct routebox routebox_t;

typedef union anon_union_for_parent anon_union_for_parent, *Panon_union_for_parent;


// WARNING! conflicting data type names: /DWARF/autoroute.c/routebox/anon_enum_32_for_type - /DWARF/hid.h/HID_Attribute/anon_enum_32_for_type


// WARNING! conflicting data type names: /DWARF/autoroute.c/routebox/anon_struct_for_flags - /DWARF/global.h/rtree_node/anon_struct_for_flags

typedef struct routebox_list routebox_list, *Proutebox_list;

struct routeone_state {
    heap_t * workheap;
    routebox_t * best_path;
    routebox_t * best_target;
    cost_t best_cost;
};

struct routebox_list {
    struct routebox * next;
    struct routebox * prev;
};

union anon_union_for_parent {
    struct PadTypePtr * pad;
    struct PinTypePtr * pin;
    struct PinTypePtr * via;
};

struct routebox {
    struct BoxType box;
    struct BoxType sbox;
    union anon_union_for_parent parent;
    ushort group;
    ushort layer;
    enum anon_enum_32_for_type type;
    struct anon_struct_for_flags flags;
    cost_t cost;
    CheapPointType cost_point;
    int refcount;
    vector_t * conflicts_with;
    struct RouteStyleType * style;
    uchar n;
    uchar e;
    uchar s;
    uchar w;
    uchar pass;
    undefined field_0x55;
    undefined field_0x56;
    undefined field_0x57;
    enum direction_t came_from;
    struct routebox_list same_net;
    struct routebox_list same_subnet;
    struct routebox_list original_subnet;
    struct routebox_list different_net;
};

typedef struct broken_boxes broken_boxes, *Pbroken_boxes;

struct broken_boxes {
    struct BoxType left;
    struct BoxType center;
    struct BoxType right;
    Boolean is_valid_left;
    Boolean is_valid_center;
    Boolean is_valid_right;
    undefined field_0x33;
};

typedef struct mincost_target_closure mincost_target_closure, *Pmincost_target_closure;

struct mincost_target_closure {
    CheapPointType * CostPoint;
    Cardinal CostPointLayer;
    routebox_t * nearest;
    cost_t nearest_cost;
};

typedef union anon_union anon_union, *Panon_union;

union anon_union {
    struct PadTypePtr * pad;
    struct PinTypePtr * pin;
    struct PinTypePtr * via;
    struct routebox * via_shadow;
    LineTypePtr line;
    void * generic;
    struct routebox * expansion_area;
};

typedef struct routeone_via_site_state routeone_via_site_state, *Prouteone_via_site_state;

struct routeone_via_site_state {
    vector_t * free_space_vec;
    vector_t * lo_conflict_space_vec;
    vector_t * hi_conflict_space_vec;
};

typedef struct edge_struct edge_struct, *Pedge_struct;


// WARNING! conflicting data type names: /DWARF/autoroute.c/edge_struct/anon_struct_for_flags - /DWARF/global.h/rtree_node/anon_struct_for_flags

struct edge_struct {
    routebox_t * rb;
    CheapPointType cost_point;
    cost_t cost_to_point;
    cost_t cost;
    routebox_t * mincost_target;
    vetting_t * work;
    enum direction_t expand_dir;
    struct anon_struct_for_flags flags;
};

typedef struct fpin_info fpin_info, *Pfpin_info;

struct fpin_info {
    struct PinTypePtr * pin;
    LocationType X;
    LocationType Y;
    jmp_buf env;
};

typedef struct routeall_status routeall_status, *Prouteall_status;

struct routeall_status {
    int total_subnets;
    int routed_subnets;
    int conflict_subnets;
    int failed;
    int ripped;
    int total_nets_routed;
};

typedef struct E_result E_result, *PE_result;

struct E_result {
    routebox_t * parent;
    routebox_t * n;
    routebox_t * e;
    routebox_t * s;
    routebox_t * w;
    BDimension keep;
    BDimension bloat;
    struct BoxType inflated;
    struct BoxType orig;
    int done;
};

typedef struct routeone_status routeone_status, *Prouteone_status;

struct routeone_status {
    Boolean found_route;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int route_had_conflicts;
    cost_t best_route_cost;
    Boolean net_completely_routed;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct break_info break_info, *Pbreak_info;

struct break_info {
    heap_t * heap;
    routebox_t * parent;
    struct BoxType box;
    enum direction_t dir;
    Boolean ignore_source;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct foib_info foib_info, *Pfoib_info;

struct foib_info {
    struct BoxType * box;
    routebox_t * intersect;
    jmp_buf env;
};

typedef struct routedata routedata, *Proutedata;

typedef struct routedata routedata_t;

struct routedata {
    rtree_t * layergrouptree[16];
    routebox_t * first_net;
    struct RouteStyleType defaultstyle;
    struct RouteStyleType * styles[5];
    BDimension max_bloat;
    BDimension max_keep;
    mtspace_t * mtspace;
};

typedef struct rb_info rb_info, *Prb_info;

struct rb_info {
    struct BoxType query;
    routebox_t * winner;
    jmp_buf env;
};

typedef struct edge_struct edge_t;

typedef struct therm_info therm_info, *Ptherm_info;

struct therm_info {
    routebox_t * plane;
    struct BoxType query;
    jmp_buf env;
};

typedef enum boxlist {
    DIFFERENT_NET=3,
    NET=0,
    ORIGINAL=2,
    SUBNET=1
} boxlist;

typedef enum conflict_t {
    HI_CONFLICT=2,
    LO_CONFLICT=1,
    NO_CONFLICT=0
} conflict_t;

typedef struct anon_struct.conflict21 anon_struct.conflict21, *Panon_struct.conflict21;

struct anon_struct.conflict21 {
    struct RouteStyleType * style;
    BDimension bloat;
    cost_t ViaCost;
    cost_t LastConflictPenalty;
    cost_t ConflictPenalty;
    cost_t JogPenalty;
    cost_t CongestionPenalty;
    cost_t NewLayerPenalty;
    cost_t MinPenalty;
    int hi_conflict;
    Boolean use_vias;
    Boolean is_odd;
    Boolean with_conflicts;
    Boolean is_smoothing;
    Boolean rip_always;
    Boolean last_smooth;
    uchar pass;
    undefined field_0x4b;
};

typedef struct anon_struct.conflict20 anon_struct.conflict20, *Panon_struct.conflict20;

struct anon_struct.conflict20 {
    uint is_via:1;
    enum conflict_t via_conflict_level:2;
    uint is_interior:1;
    uint via_search:1;
    uint in_plane:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

typedef struct anon_struct.conflict19 anon_struct.conflict19, *Panon_struct.conflict19;

struct anon_struct.conflict19 {
    uint nonstraight:1;
    uint fixed:1;
    uint source:1;
    uint target:1;
    uint nobloat:1;
    uint circular:1;
    uint homeless:1;
    uint is_odd:1;
    uint touched:1;
    uint subnet_processed:1;
    uint is_via:1;
    uint bl_to_ur:1;
    uint clear_poly:1;
    uint is_bad:1;
    uint inited:1;
    undefined field_0x2;
    undefined field_0x3;
    uint is_thermal;
};

typedef struct pin_info pin_info, *Ppin_info;

struct pin_info {
    Boolean arg;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    LayerTypePtr Layer;
};

typedef struct FloatPolyType FloatPolyType, *PFloatPolyType;

struct FloatPolyType {
    double X;
    double Y;
};

typedef struct HoleCountStruct HoleCountStruct, *PHoleCountStruct;

struct HoleCountStruct {
    int nplated;
    int nunplated;
};

typedef struct _GtkMenuShell _GtkMenuShell, *P_GtkMenuShell;

typedef struct _GtkMenuShell GtkMenuShell;

struct _GtkMenuShell {
    GtkContainer container;
    GList * children;
    GtkWidget * active_menu_item;
    GtkWidget * parent_menu_shell;
    guint button;
    guint32 activate_time;
    guint active:1;
    guint have_grab:1;
    guint have_xgrab:1;
    guint ignore_leave:1;
    guint menu_flag:1;
    guint ignore_enter:1;
    guint keyboard_mode:1;
    undefined field_0x59;
    undefined field_0x5a;
    undefined field_0x5b;
};

typedef enum GdkInterpType {
    GDK_INTERP_BILINEAR=2,
    GDK_INTERP_HYPER=3,
    GDK_INTERP_NEAREST=0,
    GDK_INTERP_TILES=1
} GdkInterpType;

typedef struct _GtkUIManager _GtkUIManager, *P_GtkUIManager;

typedef struct _GtkUIManager GtkUIManager;

typedef struct _GtkUIManagerPrivate _GtkUIManagerPrivate, *P_GtkUIManagerPrivate;

typedef struct _GtkUIManagerPrivate GtkUIManagerPrivate;

struct _GtkUIManagerPrivate {
};

struct _GtkUIManager {
    GObject parent;
    GtkUIManagerPrivate * private_data;
};

typedef struct HID_FlagNode HID_FlagNode, *PHID_FlagNode;

typedef struct HID_Flag HID_Flag, *PHID_Flag;

struct HID_Flag {
    char * name;
    int (* function)(int);
    int parm;
};

struct HID_FlagNode {
    struct HID_FlagNode * next;
    struct HID_Flag * flags;
    int n;
};

typedef struct _GtkComboBoxPrivate _GtkComboBoxPrivate, *P_GtkComboBoxPrivate;

typedef struct _GtkComboBoxPrivate GtkComboBoxPrivate;

struct _GtkComboBoxPrivate {
};

typedef struct _GtkComboBox _GtkComboBox, *P_GtkComboBox;

struct _GtkComboBox {
    GtkBin parent_instance;
    GtkComboBoxPrivate * priv;
};

typedef struct Resource Resource, *PResource;

typedef struct ResourceVal ResourceVal, *PResourceVal;

struct Resource {
    struct Resource * parent;
    void * user_ptr;
    int flags;
    int c;
    struct ResourceVal * v;
};

struct ResourceVal {
    char * name;
    char * value;
    struct Resource * subres;
};

typedef struct _GtkCellRendererClass _GtkCellRendererClass, *P_GtkCellRendererClass;

typedef struct _GtkCellRenderer _GtkCellRenderer, *P_GtkCellRenderer;

typedef struct _GtkCellRenderer GtkCellRenderer;

typedef struct _GdkDrawable GdkDrawable;

typedef enum GtkCellRendererState {
    GTK_CELL_RENDERER_FOCUSED=16,
    GTK_CELL_RENDERER_INSENSITIVE=4,
    GTK_CELL_RENDERER_PRELIT=2,
    GTK_CELL_RENDERER_SELECTED=1,
    GTK_CELL_RENDERER_SORTED=8
} GtkCellRendererState;

typedef struct _GtkCellRendererClass GtkCellRendererClass;

struct _GtkCellRenderer {
    GtkObject parent;
    gfloat xalign;
    gfloat yalign;
    gint width;
    gint height;
    guint16 xpad;
    guint16 ypad;
    guint mode:2;
    guint visible:1;
    guint is_expander:1;
    guint is_expanded:1;
    guint cell_background_set:1;
    guint sensitive:1;
    guint editing:1;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
};

struct _GtkCellRendererClass {
    GtkObjectClass parent_class;
    void (* get_size)(GtkCellRenderer *, GtkWidget *, GdkRectangle *, gint *, gint *, gint *, gint *);
    void (* render)(GtkCellRenderer *, GdkDrawable *, GtkWidget *, GdkRectangle *, GdkRectangle *, GdkRectangle *, enum GtkCellRendererState);
    gboolean (* activate)(GtkCellRenderer *, GdkEvent *, GtkWidget *, gchar *, GdkRectangle *, GdkRectangle *, enum GtkCellRendererState);
    GtkCellEditable * (* start_editing)(GtkCellRenderer *, GdkEvent *, GtkWidget *, gchar *, GdkRectangle *, GdkRectangle *, enum GtkCellRendererState);
    void (* editing_canceled)(GtkCellRenderer *);
    void (* editing_started)(GtkCellRenderer *, GtkCellEditable *, gchar *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
};

typedef struct object_list object_list, *Pobject_list;

struct object_list {
    int count;
    long * id_list;
    int * type_list;
};

typedef __gnuc_va_list va_list;

typedef struct _GhidViolationRendererClass _GhidViolationRendererClass, *P_GhidViolationRendererClass;

typedef struct _GhidViolationRendererClass GhidViolationRendererClass;

typedef struct _GtkCellRendererTextClass _GtkCellRendererTextClass, *P_GtkCellRendererTextClass;

typedef struct _GtkCellRendererText _GtkCellRendererText, *P_GtkCellRendererText;

typedef struct _GtkCellRendererText GtkCellRendererText;

typedef struct _GtkCellRendererTextClass GtkCellRendererTextClass;

typedef struct _PangoColor _PangoColor, *P_PangoColor;

typedef struct _PangoColor PangoColor;

typedef enum PangoUnderline {
    PANGO_UNDERLINE_DOUBLE=2,
    PANGO_UNDERLINE_ERROR=4,
    PANGO_UNDERLINE_LOW=3,
    PANGO_UNDERLINE_NONE=0,
    PANGO_UNDERLINE_SINGLE=1
} PangoUnderline;

struct _GtkCellRendererTextClass {
    GtkCellRendererClass parent_class;
    void (* edited)(GtkCellRendererText *, gchar *, gchar *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

struct _GhidViolationRendererClass {
    GtkCellRendererTextClass parent_class;
};

struct _PangoColor {
    guint16 red;
    guint16 green;
    guint16 blue;
};

struct _GtkCellRendererText {
    GtkCellRenderer parent;
    gchar * text;
    PangoFontDescription * font;
    gdouble font_scale;
    PangoColor foreground;
    PangoColor background;
    PangoAttrList * extra_attrs;
    enum PangoUnderline underline_style;
    gint rise;
    gint fixed_height_rows;
    guint strikethrough:1;
    guint editable:1;
    guint scale_set:1;
    guint foreground_set:1;
    guint background_set:1;
    guint underline_set:1;
    guint rise_set:1;
    guint strikethrough_set:1;
    guint editable_set:1;
    guint calc_fixed_height:1;
    undefined field_0x56;
    undefined field_0x57;
};

typedef struct _GhidDrcViolation _GhidDrcViolation, *P_GhidDrcViolation;

struct _GhidDrcViolation {
    GObject parent_instance;
    char * title;
    char * explanation;
    int x_coord;
    int y_coord;
    int angle;
    int have_measured;
    double measured_value;
    double required_value;
    int value_digits;
    char * value_units;
    int object_count;
    long * object_id_list;
    int * object_type_list;
    GdkDrawable * pixmap;
};

typedef struct _GhidViolationRenderer _GhidViolationRenderer, *P_GhidViolationRenderer;

typedef struct _GhidDrcViolation GhidDrcViolation;

struct _GhidViolationRenderer {
    GtkCellRendererText parent_instance;
    GhidDrcViolation * violation;
};

typedef struct _GhidViolationRenderer GhidViolationRenderer;

typedef struct _GClosureNotifyData _GClosureNotifyData, *P_GClosureNotifyData;

typedef struct _GClosure _GClosure, *P_GClosure;

typedef struct _GClosure GClosure;

typedef struct _GClosureNotifyData GClosureNotifyData;

struct _GClosureNotifyData {
    gpointer data;
    void (* notify)(gpointer, GClosure *);
};

struct _GClosure {
    guint ref_count:15;
    guint meta_marshal:1;
    guint n_guards:1;
    guint n_fnotifiers:2;
    guint n_inotifiers:8;
    guint in_inotify:1;
    guint floating:1;
    guint derivative_flag:1;
    guint in_marshal:1;
    guint is_invalid:1;
    void (* marshal)(GClosure *, GValue *, guint, GValue *, gpointer, gpointer);
    gpointer data;
    GClosureNotifyData * notifiers;
};

typedef struct HID_DRC_GUI HID_DRC_GUI, *PHID_DRC_GUI;

typedef struct drc_violation_st drc_violation_st, *Pdrc_violation_st;

typedef struct drc_violation_st DrcViolationType;

struct HID_DRC_GUI {
    int log_drc_overview;
    int log_drc_violations;
    void (* reset_drc_dialog_message)(void);
    void (* append_drc_violation)(DrcViolationType *);
    int (* throw_drc_dialog)(void);
};

struct drc_violation_st {
    char * title;
    char * explanation;
    int x;
    int y;
    int angle;
    int have_measured;
    double measured_value;
    double required_value;
    int value_digits;
    char * value_units;
    int object_count;
    long * object_id_list;
    int * object_type_list;
};

typedef struct HID_Attribute.conflict HID_Attribute.conflict, *PHID_Attribute.conflict;

typedef enum anon_enum_32_for_type.conflict {
    EXCHANGE=2,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    ROTATE=1,
    SHIFT=0
} anon_enum_32_for_type.conflict;

struct HID_Attribute.conflict {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict10 HID_Attribute.conflict10, *PHID_Attribute.conflict10;

typedef enum anon_enum_32_for_type.conflict10 {
    CONFIG_NAME_COLUMN=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    DRC_VIOLATION_NUM_COL=0,
    DRC_VIOLATION_OBJ_COL=1,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_EQUIV=9,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SET=15,
    GDK_XOR=2,
    GTK_APP_PAINTABLE=524288,
    GTK_ARROW_DOWN=1,
    GTK_ARROW_LEFT=2,
    GTK_ARROW_NONE=4,
    GTK_ARROW_RIGHT=3,
    GTK_ARROW_UP=0,
    GTK_BUTTONS_CANCEL=3,
    GTK_BUTTONS_CLOSE=2,
    GTK_BUTTONS_NONE=0,
    GTK_BUTTONS_OK=1,
    GTK_BUTTONS_OK_CANCEL=5,
    GTK_BUTTONS_YES_NO=4,
    GTK_CAN_DEFAULT=8192,
    GTK_CAN_FOCUS=2048,
    GTK_COMPOSITE_CHILD=131072,
    GTK_DIALOG_DESTROY_WITH_PARENT=2,
    GTK_DIALOG_MODAL=1,
    GTK_DIALOG_NO_SEPARATOR=4,
    GTK_DOUBLE_BUFFERED=2097152,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3,
    GTK_FILE_CHOOSER_ACTION_OPEN=0,
    GTK_FILE_CHOOSER_ACTION_SAVE=1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2,
    GTK_HAS_DEFAULT=16384,
    GTK_HAS_FOCUS=4096,
    GTK_HAS_GRAB=32768,
    GTK_ICON_SIZE_BUTTON=4,
    GTK_ICON_SIZE_DIALOG=6,
    GTK_ICON_SIZE_DND=5,
    GTK_ICON_SIZE_INVALID=0,
    GTK_ICON_SIZE_LARGE_TOOLBAR=3,
    GTK_ICON_SIZE_MENU=1,
    GTK_ICON_SIZE_SMALL_TOOLBAR=2,
    GTK_MAPPED=128,
    GTK_MESSAGE_ERROR=3,
    GTK_MESSAGE_INFO=0,
    GTK_MESSAGE_OTHER=4,
    GTK_MESSAGE_QUESTION=2,
    GTK_MESSAGE_WARNING=1,
    GTK_NO_REPARENT=262144,
    GTK_NO_SHOW_ALL=4194304,
    GTK_NO_WINDOW=32,
    GTK_PARENT_SENSITIVE=1024,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_RC_STYLE=65536,
    GTK_REALIZED=64,
    GTK_RECEIVES_DEFAULT=1048576,
    GTK_RELIEF_HALF=1,
    GTK_RELIEF_NONE=2,
    GTK_RELIEF_NORMAL=0,
    GTK_RESPONSE_ACCEPT=-3,
    GTK_RESPONSE_APPLY=-10,
    GTK_RESPONSE_CANCEL=-6,
    GTK_RESPONSE_CLOSE=-7,
    GTK_RESPONSE_DELETE_EVENT=-4,
    GTK_RESPONSE_HELP=-11,
    GTK_RESPONSE_NO=-9,
    GTK_RESPONSE_NONE=-1,
    GTK_RESPONSE_OK=-5,
    GTK_RESPONSE_REJECT=-2,
    GTK_RESPONSE_YES=-8,
    GTK_SENSITIVE=512,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2,
    GTK_TOPLEVEL=16,
    GTK_VISIBLE=256,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    GTK_WIN_POS_CENTER=1,
    GTK_WIN_POS_CENTER_ALWAYS=3,
    GTK_WIN_POS_CENTER_ON_PARENT=4,
    GTK_WIN_POS_MOUSE=2,
    GTK_WIN_POS_NONE=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_EXISTS=16,
    G_FILE_TEST_IS_DIR=4,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_FILE_TEST_IS_REGULAR=1,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_LOG_FLAG_RECURSION=1,
    G_LOG_LEVEL_CRITICAL=8,
    G_LOG_LEVEL_DEBUG=128,
    G_LOG_LEVEL_ERROR=4,
    G_LOG_LEVEL_INFO=64,
    G_LOG_LEVEL_MASK=-4,
    G_LOG_LEVEL_MESSAGE=32,
    G_LOG_LEVEL_WARNING=16,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    MENU_ENTRY_COLUMN=2,
    MENU_LIBRARY_COLUMN=1,
    MENU_NAME_COLUMN=0,
    NUM_DRC_COLUMNS=2,
    N_CONFIG_COLUMNS=2,
    N_MENU_COLUMNS=3,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    PROP_ANGLE=5,
    PROP_EXPLANATION=2,
    PROP_HAVE_MEASURED=6,
    PROP_MEASURED_VALUE=7,
    PROP_OBJECT_LIST=11,
    PROP_PIXMAP=12,
    PROP_REQUIRED_VALUE=8,
    PROP_TITLE=1,
    PROP_VALUE_DIGITS=9,
    PROP_VALUE_UNITS=10,
    PROP_VIOLATION=1,
    PROP_X_COORD=3,
    PROP_Y_COORD=4,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict10;

struct HID_Attribute.conflict10 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict10 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict14 HID_Attribute.conflict14, *PHID_Attribute.conflict14;

typedef enum anon_enum_32_for_type.conflict14 {
    CONFIG_NAME_COLUMN=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    DRC_VIOLATION_NUM_COL=0,
    DRC_VIOLATION_OBJ_COL=1,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_ALL_EVENTS_MASK=4194302,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_BUTTON1_MOTION_MASK=32,
    GDK_BUTTON2_MOTION_MASK=64,
    GDK_BUTTON3_MOTION_MASK=128,
    GDK_BUTTON_MOTION_MASK=16,
    GDK_BUTTON_PRESS_MASK=256,
    GDK_BUTTON_RELEASE_MASK=512,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_ENTER_NOTIFY_MASK=4096,
    GDK_EQUIV=9,
    GDK_EXPOSURE_MASK=2,
    GDK_FOCUS_CHANGE_MASK=16384,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_KEY_PRESS_MASK=1024,
    GDK_KEY_RELEASE_MASK=2048,
    GDK_LEAVE_NOTIFY_MASK=8192,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_POINTER_MOTION_HINT_MASK=8,
    GDK_POINTER_MOTION_MASK=4,
    GDK_PROPERTY_CHANGE_MASK=65536,
    GDK_PROXIMITY_IN_MASK=262144,
    GDK_PROXIMITY_OUT_MASK=524288,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SCROLL_MASK=2097152,
    GDK_SET=15,
    GDK_STRUCTURE_MASK=32768,
    GDK_SUBSTRUCTURE_MASK=1048576,
    GDK_VISIBILITY_NOTIFY_MASK=131072,
    GDK_XOR=2,
    GTK_APP_PAINTABLE=524288,
    GTK_ARROW_DOWN=1,
    GTK_ARROW_LEFT=2,
    GTK_ARROW_NONE=4,
    GTK_ARROW_RIGHT=3,
    GTK_ARROW_UP=0,
    GTK_BUTTONS_CANCEL=3,
    GTK_BUTTONS_CLOSE=2,
    GTK_BUTTONS_NONE=0,
    GTK_BUTTONS_OK=1,
    GTK_BUTTONS_OK_CANCEL=5,
    GTK_BUTTONS_YES_NO=4,
    GTK_CAN_DEFAULT=8192,
    GTK_CAN_FOCUS=2048,
    GTK_COMPOSITE_CHILD=131072,
    GTK_DIALOG_DESTROY_WITH_PARENT=2,
    GTK_DIALOG_MODAL=1,
    GTK_DIALOG_NO_SEPARATOR=4,
    GTK_DOUBLE_BUFFERED=2097152,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3,
    GTK_FILE_CHOOSER_ACTION_OPEN=0,
    GTK_FILE_CHOOSER_ACTION_SAVE=1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2,
    GTK_HAS_DEFAULT=16384,
    GTK_HAS_FOCUS=4096,
    GTK_HAS_GRAB=32768,
    GTK_ICON_SIZE_BUTTON=4,
    GTK_ICON_SIZE_DIALOG=6,
    GTK_ICON_SIZE_DND=5,
    GTK_ICON_SIZE_INVALID=0,
    GTK_ICON_SIZE_LARGE_TOOLBAR=3,
    GTK_ICON_SIZE_MENU=1,
    GTK_ICON_SIZE_SMALL_TOOLBAR=2,
    GTK_MAPPED=128,
    GTK_MESSAGE_ERROR=3,
    GTK_MESSAGE_INFO=0,
    GTK_MESSAGE_OTHER=4,
    GTK_MESSAGE_QUESTION=2,
    GTK_MESSAGE_WARNING=1,
    GTK_NO_REPARENT=262144,
    GTK_NO_SHOW_ALL=4194304,
    GTK_NO_WINDOW=32,
    GTK_PARENT_SENSITIVE=1024,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_RC_STYLE=65536,
    GTK_REALIZED=64,
    GTK_RECEIVES_DEFAULT=1048576,
    GTK_RELIEF_HALF=1,
    GTK_RELIEF_NONE=2,
    GTK_RELIEF_NORMAL=0,
    GTK_RESPONSE_ACCEPT=-3,
    GTK_RESPONSE_APPLY=-10,
    GTK_RESPONSE_CANCEL=-6,
    GTK_RESPONSE_CLOSE=-7,
    GTK_RESPONSE_DELETE_EVENT=-4,
    GTK_RESPONSE_HELP=-11,
    GTK_RESPONSE_NO=-9,
    GTK_RESPONSE_NONE=-1,
    GTK_RESPONSE_OK=-5,
    GTK_RESPONSE_REJECT=-2,
    GTK_RESPONSE_YES=-8,
    GTK_SENSITIVE=512,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2,
    GTK_STATE_ACTIVE=1,
    GTK_STATE_INSENSITIVE=4,
    GTK_STATE_NORMAL=0,
    GTK_STATE_PRELIGHT=2,
    GTK_STATE_SELECTED=3,
    GTK_TOPLEVEL=16,
    GTK_VISIBLE=256,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    GTK_WIN_POS_CENTER=1,
    GTK_WIN_POS_CENTER_ALWAYS=3,
    GTK_WIN_POS_CENTER_ON_PARENT=4,
    GTK_WIN_POS_MOUSE=2,
    GTK_WIN_POS_NONE=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_EXISTS=16,
    G_FILE_TEST_IS_DIR=4,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_FILE_TEST_IS_REGULAR=1,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_LOG_FLAG_RECURSION=1,
    G_LOG_LEVEL_CRITICAL=8,
    G_LOG_LEVEL_DEBUG=128,
    G_LOG_LEVEL_ERROR=4,
    G_LOG_LEVEL_INFO=64,
    G_LOG_LEVEL_MASK=-4,
    G_LOG_LEVEL_MESSAGE=32,
    G_LOG_LEVEL_WARNING=16,
    G_PARAM_CONSTRUCT=4,
    G_PARAM_CONSTRUCT_ONLY=8,
    G_PARAM_DEPRECATED=-8,
    G_PARAM_LAX_VALIDATION=16,
    G_PARAM_PRIVATE=32,
    G_PARAM_READABLE=1,
    G_PARAM_STATIC_BLURB=128,
    G_PARAM_STATIC_NAME=32,
    G_PARAM_STATIC_NICK=64,
    G_PARAM_WRITABLE=2,
    G_SIGNAL_ACTION=32,
    G_SIGNAL_DETAILED=16,
    G_SIGNAL_NO_HOOKS=64,
    G_SIGNAL_NO_RECURSE=8,
    G_SIGNAL_RUN_CLEANUP=4,
    G_SIGNAL_RUN_FIRST=1,
    G_SIGNAL_RUN_LAST=2,
    G_TOKEN_BINARY=259,
    G_TOKEN_CHAR=258,
    G_TOKEN_COMMA=44,
    G_TOKEN_COMMENT_MULTI=269,
    G_TOKEN_COMMENT_SINGLE=268,
    G_TOKEN_EOF=0,
    G_TOKEN_EQUAL_SIGN=61,
    G_TOKEN_ERROR=257,
    G_TOKEN_FLOAT=263,
    G_TOKEN_HEX=262,
    G_TOKEN_IDENTIFIER=266,
    G_TOKEN_IDENTIFIER_NULL=267,
    G_TOKEN_INT=261,
    G_TOKEN_LAST=270,
    G_TOKEN_LEFT_BRACE=91,
    G_TOKEN_LEFT_CURLY=123,
    G_TOKEN_LEFT_PAREN=40,
    G_TOKEN_NONE=256,
    G_TOKEN_OCTAL=260,
    G_TOKEN_RIGHT_BRACE=93,
    G_TOKEN_RIGHT_CURLY=125,
    G_TOKEN_RIGHT_PAREN=41,
    G_TOKEN_STRING=264,
    G_TOKEN_SYMBOL=265,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    MENU_ENTRY_COLUMN=2,
    MENU_LIBRARY_COLUMN=1,
    MENU_NAME_COLUMN=0,
    NET_ENABLED_COLUMN=0,
    NET_LIBRARY_COLUMN=2,
    NET_NAME_COLUMN=1,
    NODE_LIBRARY_COLUMN=1,
    NODE_NAME_COLUMN=0,
    NUM_DRC_COLUMNS=2,
    N_CONFIG_COLUMNS=2,
    N_MENU_COLUMNS=3,
    N_NET_COLUMNS=3,
    N_NODE_COLUMNS=2,
    ODD=1,
    OTHER=5,
    PAD=0,
    PANGO_STYLE_ITALIC=2,
    PANGO_STYLE_NORMAL=0,
    PANGO_STYLE_OBLIQUE=1,
    PANGO_UNDERLINE_DOUBLE=2,
    PANGO_UNDERLINE_ERROR=4,
    PANGO_UNDERLINE_LOW=3,
    PANGO_UNDERLINE_NONE=0,
    PANGO_UNDERLINE_SINGLE=1,
    PANGO_WEIGHT_BOLD=700,
    PANGO_WEIGHT_BOOK=380,
    PANGO_WEIGHT_HEAVY=900,
    PANGO_WEIGHT_LIGHT=300,
    PANGO_WEIGHT_MEDIUM=500,
    PANGO_WEIGHT_NORMAL=400,
    PANGO_WEIGHT_SEMIBOLD=600,
    PANGO_WEIGHT_THIN=100,
    PANGO_WEIGHT_ULTRABOLD=800,
    PANGO_WEIGHT_ULTRAHEAVY=1000,
    PANGO_WEIGHT_ULTRALIGHT=200,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    PROP_ANGLE=5,
    PROP_ELEMENT_DATA=1,
    PROP_EXPLANATION=2,
    PROP_HAVE_MEASURED=6,
    PROP_MEASURED_VALUE=7,
    PROP_OBJECT_LIST=11,
    PROP_PIXMAP=12,
    PROP_REQUIRED_VALUE=8,
    PROP_TITLE=1,
    PROP_VALUE_DIGITS=9,
    PROP_VALUE_UNITS=10,
    PROP_VIOLATION=1,
    PROP_X_COORD=3,
    PROP_Y_COORD=4,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict14;

struct HID_Attribute.conflict14 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict14 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict13 HID_Attribute.conflict13, *PHID_Attribute.conflict13;

typedef enum anon_enum_32_for_type.conflict13 {
    CONFIG_NAME_COLUMN=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    DRC_VIOLATION_NUM_COL=0,
    DRC_VIOLATION_OBJ_COL=1,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_ALL_EVENTS_MASK=4194302,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_BUTTON1_MOTION_MASK=32,
    GDK_BUTTON2_MOTION_MASK=64,
    GDK_BUTTON3_MOTION_MASK=128,
    GDK_BUTTON_MOTION_MASK=16,
    GDK_BUTTON_PRESS_MASK=256,
    GDK_BUTTON_RELEASE_MASK=512,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_ENTER_NOTIFY_MASK=4096,
    GDK_EQUIV=9,
    GDK_EXPOSURE_MASK=2,
    GDK_FOCUS_CHANGE_MASK=16384,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_KEY_PRESS_MASK=1024,
    GDK_KEY_RELEASE_MASK=2048,
    GDK_LEAVE_NOTIFY_MASK=8192,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_POINTER_MOTION_HINT_MASK=8,
    GDK_POINTER_MOTION_MASK=4,
    GDK_PROPERTY_CHANGE_MASK=65536,
    GDK_PROXIMITY_IN_MASK=262144,
    GDK_PROXIMITY_OUT_MASK=524288,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SCROLL_MASK=2097152,
    GDK_SET=15,
    GDK_STRUCTURE_MASK=32768,
    GDK_SUBSTRUCTURE_MASK=1048576,
    GDK_VISIBILITY_NOTIFY_MASK=131072,
    GDK_XOR=2,
    GTK_APP_PAINTABLE=524288,
    GTK_ARROW_DOWN=1,
    GTK_ARROW_LEFT=2,
    GTK_ARROW_NONE=4,
    GTK_ARROW_RIGHT=3,
    GTK_ARROW_UP=0,
    GTK_BUTTONS_CANCEL=3,
    GTK_BUTTONS_CLOSE=2,
    GTK_BUTTONS_NONE=0,
    GTK_BUTTONS_OK=1,
    GTK_BUTTONS_OK_CANCEL=5,
    GTK_BUTTONS_YES_NO=4,
    GTK_CAN_DEFAULT=8192,
    GTK_CAN_FOCUS=2048,
    GTK_COMPOSITE_CHILD=131072,
    GTK_DIALOG_DESTROY_WITH_PARENT=2,
    GTK_DIALOG_MODAL=1,
    GTK_DIALOG_NO_SEPARATOR=4,
    GTK_DOUBLE_BUFFERED=2097152,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3,
    GTK_FILE_CHOOSER_ACTION_OPEN=0,
    GTK_FILE_CHOOSER_ACTION_SAVE=1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2,
    GTK_HAS_DEFAULT=16384,
    GTK_HAS_FOCUS=4096,
    GTK_HAS_GRAB=32768,
    GTK_ICON_SIZE_BUTTON=4,
    GTK_ICON_SIZE_DIALOG=6,
    GTK_ICON_SIZE_DND=5,
    GTK_ICON_SIZE_INVALID=0,
    GTK_ICON_SIZE_LARGE_TOOLBAR=3,
    GTK_ICON_SIZE_MENU=1,
    GTK_ICON_SIZE_SMALL_TOOLBAR=2,
    GTK_MAPPED=128,
    GTK_MESSAGE_ERROR=3,
    GTK_MESSAGE_INFO=0,
    GTK_MESSAGE_OTHER=4,
    GTK_MESSAGE_QUESTION=2,
    GTK_MESSAGE_WARNING=1,
    GTK_NO_REPARENT=262144,
    GTK_NO_SHOW_ALL=4194304,
    GTK_NO_WINDOW=32,
    GTK_PARENT_SENSITIVE=1024,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_RC_STYLE=65536,
    GTK_REALIZED=64,
    GTK_RECEIVES_DEFAULT=1048576,
    GTK_RELIEF_HALF=1,
    GTK_RELIEF_NONE=2,
    GTK_RELIEF_NORMAL=0,
    GTK_RESPONSE_ACCEPT=-3,
    GTK_RESPONSE_APPLY=-10,
    GTK_RESPONSE_CANCEL=-6,
    GTK_RESPONSE_CLOSE=-7,
    GTK_RESPONSE_DELETE_EVENT=-4,
    GTK_RESPONSE_HELP=-11,
    GTK_RESPONSE_NO=-9,
    GTK_RESPONSE_NONE=-1,
    GTK_RESPONSE_OK=-5,
    GTK_RESPONSE_REJECT=-2,
    GTK_RESPONSE_YES=-8,
    GTK_SENSITIVE=512,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2,
    GTK_STATE_ACTIVE=1,
    GTK_STATE_INSENSITIVE=4,
    GTK_STATE_NORMAL=0,
    GTK_STATE_PRELIGHT=2,
    GTK_STATE_SELECTED=3,
    GTK_TOPLEVEL=16,
    GTK_VISIBLE=256,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    GTK_WIN_POS_CENTER=1,
    GTK_WIN_POS_CENTER_ALWAYS=3,
    GTK_WIN_POS_CENTER_ON_PARENT=4,
    GTK_WIN_POS_MOUSE=2,
    GTK_WIN_POS_NONE=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_EXISTS=16,
    G_FILE_TEST_IS_DIR=4,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_FILE_TEST_IS_REGULAR=1,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_LOG_FLAG_RECURSION=1,
    G_LOG_LEVEL_CRITICAL=8,
    G_LOG_LEVEL_DEBUG=128,
    G_LOG_LEVEL_ERROR=4,
    G_LOG_LEVEL_INFO=64,
    G_LOG_LEVEL_MASK=-4,
    G_LOG_LEVEL_MESSAGE=32,
    G_LOG_LEVEL_WARNING=16,
    G_PARAM_CONSTRUCT=4,
    G_PARAM_CONSTRUCT_ONLY=8,
    G_PARAM_DEPRECATED=-8,
    G_PARAM_LAX_VALIDATION=16,
    G_PARAM_PRIVATE=32,
    G_PARAM_READABLE=1,
    G_PARAM_STATIC_BLURB=128,
    G_PARAM_STATIC_NAME=32,
    G_PARAM_STATIC_NICK=64,
    G_PARAM_WRITABLE=2,
    G_SIGNAL_ACTION=32,
    G_SIGNAL_DETAILED=16,
    G_SIGNAL_NO_HOOKS=64,
    G_SIGNAL_NO_RECURSE=8,
    G_SIGNAL_RUN_CLEANUP=4,
    G_SIGNAL_RUN_FIRST=1,
    G_SIGNAL_RUN_LAST=2,
    G_TOKEN_BINARY=259,
    G_TOKEN_CHAR=258,
    G_TOKEN_COMMA=44,
    G_TOKEN_COMMENT_MULTI=269,
    G_TOKEN_COMMENT_SINGLE=268,
    G_TOKEN_EOF=0,
    G_TOKEN_EQUAL_SIGN=61,
    G_TOKEN_ERROR=257,
    G_TOKEN_FLOAT=263,
    G_TOKEN_HEX=262,
    G_TOKEN_IDENTIFIER=266,
    G_TOKEN_IDENTIFIER_NULL=267,
    G_TOKEN_INT=261,
    G_TOKEN_LAST=270,
    G_TOKEN_LEFT_BRACE=91,
    G_TOKEN_LEFT_CURLY=123,
    G_TOKEN_LEFT_PAREN=40,
    G_TOKEN_NONE=256,
    G_TOKEN_OCTAL=260,
    G_TOKEN_RIGHT_BRACE=93,
    G_TOKEN_RIGHT_CURLY=125,
    G_TOKEN_RIGHT_PAREN=41,
    G_TOKEN_STRING=264,
    G_TOKEN_SYMBOL=265,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    MENU_ENTRY_COLUMN=2,
    MENU_LIBRARY_COLUMN=1,
    MENU_NAME_COLUMN=0,
    NET_ENABLED_COLUMN=0,
    NET_LIBRARY_COLUMN=2,
    NET_NAME_COLUMN=1,
    NODE_LIBRARY_COLUMN=1,
    NODE_NAME_COLUMN=0,
    NUM_DRC_COLUMNS=2,
    N_CONFIG_COLUMNS=2,
    N_MENU_COLUMNS=3,
    N_NET_COLUMNS=3,
    N_NODE_COLUMNS=2,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    PROP_ANGLE=5,
    PROP_ELEMENT_DATA=1,
    PROP_EXPLANATION=2,
    PROP_HAVE_MEASURED=6,
    PROP_MEASURED_VALUE=7,
    PROP_OBJECT_LIST=11,
    PROP_PIXMAP=12,
    PROP_REQUIRED_VALUE=8,
    PROP_TITLE=1,
    PROP_VALUE_DIGITS=9,
    PROP_VALUE_UNITS=10,
    PROP_VIOLATION=1,
    PROP_X_COORD=3,
    PROP_Y_COORD=4,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict13;

struct HID_Attribute.conflict13 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict13 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict9 HID_Attribute.conflict9, *PHID_Attribute.conflict9;

typedef enum anon_enum_32_for_type.conflict9 {
    CONFIG_NAME_COLUMN=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_EQUIV=9,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SET=15,
    GDK_XOR=2,
    GTK_APP_PAINTABLE=524288,
    GTK_ARROW_DOWN=1,
    GTK_ARROW_LEFT=2,
    GTK_ARROW_NONE=4,
    GTK_ARROW_RIGHT=3,
    GTK_ARROW_UP=0,
    GTK_CAN_DEFAULT=8192,
    GTK_CAN_FOCUS=2048,
    GTK_COMPOSITE_CHILD=131072,
    GTK_DOUBLE_BUFFERED=2097152,
    GTK_HAS_DEFAULT=16384,
    GTK_HAS_FOCUS=4096,
    GTK_HAS_GRAB=32768,
    GTK_MAPPED=128,
    GTK_NO_REPARENT=262144,
    GTK_NO_SHOW_ALL=4194304,
    GTK_NO_WINDOW=32,
    GTK_PARENT_SENSITIVE=1024,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_RC_STYLE=65536,
    GTK_REALIZED=64,
    GTK_RECEIVES_DEFAULT=1048576,
    GTK_SENSITIVE=512,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2,
    GTK_TOPLEVEL=16,
    GTK_VISIBLE=256,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_EXISTS=16,
    G_FILE_TEST_IS_DIR=4,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_FILE_TEST_IS_REGULAR=1,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_LOG_FLAG_RECURSION=1,
    G_LOG_LEVEL_CRITICAL=8,
    G_LOG_LEVEL_DEBUG=128,
    G_LOG_LEVEL_ERROR=4,
    G_LOG_LEVEL_INFO=64,
    G_LOG_LEVEL_MASK=-4,
    G_LOG_LEVEL_MESSAGE=32,
    G_LOG_LEVEL_WARNING=16,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    N_CONFIG_COLUMNS=2,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict9;

struct HID_Attribute.conflict9 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict9 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict8 HID_Attribute.conflict8, *PHID_Attribute.conflict8;

typedef enum anon_enum_32_for_type.conflict8 {
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_EQUIV=9,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SET=15,
    GDK_XOR=2,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict8;

struct HID_Attribute.conflict8 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict8 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict3 HID_Attribute.conflict3, *PHID_Attribute.conflict3;

typedef enum anon_enum_32_for_type.conflict3 {
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_type.conflict3;

struct HID_Attribute.conflict3 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict3 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct hid_gc_struct.conflict2 hid_gc_struct.conflict2, *Phid_gc_struct.conflict2;

typedef struct HID HID, *PHID;

typedef struct hid_gc_struct hid_gc_struct, *Phid_gc_struct;

typedef struct hid_gc_struct * hidGC;

typedef enum EndCapStyle {
    Beveled_Cap=3,
    Round_Cap=2,
    Square_Cap=1,
    Trace_Cap=0
} EndCapStyle;

typedef struct gdImageStruct gdImageStruct, *PgdImageStruct;

typedef struct gdImageStruct gdImage;

typedef gdImage * gdImagePtr;

struct hid_gc_struct {
    int nothing_interesting_here;
};

struct gdImageStruct {
    uchar * * pixels;
    int sx;
    int sy;
    int colorsTotal;
    int red[256];
    int green[256];
    int blue[256];
    int open[256];
    int transparent;
    int * polyInts;
    int polyAllocated;
    struct gdImageStruct * brush;
    struct gdImageStruct * tile;
    int brushColorMap[256];
    int tileColorMap[256];
    int styleLength;
    int stylePos;
    int * style;
    int interlace;
    int thick;
    int alpha[256];
    int trueColor;
    int * * tpixels;
    int alphaBlendingFlag;
    int saveAlphaFlag;
    int AA;
    int AA_color;
    int AA_dont_blend;
    int cx1;
    int cy1;
    int cx2;
    int cy2;
};

struct HID {
    int struct_size;
    char * name;
    char * description;
    char gui:1;
    char printer:1;
    char exporter:1;
    char poly_before:1;
    char poly_after:1;
    char poly_dicer:1;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    HID_Attribute * (* get_export_options)(int *);
    void (* do_export)(struct HID_Attr_Val *);
    void (* parse_arguments)(int *, char * * *);
    void (* invalidate_wh)(int, int, int, int, int);
    void (* invalidate_lr)(int, int, int, int, int);
    void (* invalidate_all)(void);
    int (* set_layer)(char *, int, int);
    hidGC (* make_gc)(void);
    void (* destroy_gc)(hidGC);
    void (* use_mask)(int);
    void (* set_color)(hidGC, char *);
    void (* set_line_cap)(hidGC, enum EndCapStyle);
    void (* set_line_width)(hidGC, int);
    void (* set_draw_xor)(hidGC, int);
    void (* set_draw_faded)(hidGC, int);
    void (* set_line_cap_angle)(hidGC, int, int, int, int);
    void (* draw_line)(hidGC, int, int, int, int);
    void (* draw_arc)(hidGC, int, int, int, int, int, int);
    void (* draw_rect)(hidGC, int, int, int, int);
    void (* fill_circle)(hidGC, int, int, int);
    void (* fill_polygon)(hidGC, int, int *, int *);
    void (* fill_pcb_polygon)(hidGC, PolygonType *, struct BoxType *);
    void (* thindraw_pcb_polygon)(hidGC, PolygonType *, struct BoxType *);
    void (* fill_rect)(hidGC, int, int, int, int);
    void (* calibrate)(double, double);
    int (* shift_is_pressed)(void);
    int (* control_is_pressed)(void);
    int (* mod1_is_pressed)(void);
    void (* get_coords)(char *, int *, int *);
    void (* set_crosshair)(int, int, int);
    hidval (* add_timer)(void (* )(union hidval), ulong, union hidval);
    void (* stop_timer)(union hidval);
    hidval (* watch_file)(int, uint, void (* )(union hidval, int, uint, union hidval), union hidval);
    void (* unwatch_file)(union hidval);
    hidval (* add_block_hook)(void (* )(union hidval), union hidval);
    void (* stop_block_hook)(union hidval);
    void (* log)(char *, ...);
    void (* logv)(char *, va_list);
    int (* confirm_dialog)(char *, ...);
    int (* close_confirm_dialog)(...);
    void (* report_dialog)(char *, char *);
    char * (* prompt_for)(char *, char *);
    char * (* fileselect)(char *, char *, char *, char *, char *, int);
    int (* attribute_dialog)(struct HID_Attribute *, int, struct HID_Attr_Val *, char *, char *);
    void (* show_item)(void *);
    void (* beep)(void);
    int (* progress)(int, int, char *);
    struct HID_DRC_GUI * drc_gui;
};

struct hid_gc_struct.conflict2 {
    struct HID * me_pointer;
    enum EndCapStyle cap;
    int width;
    uchar r;
    uchar g;
    uchar b;
    undefined field_0xf;
    int erase;
    int faded;
    struct color_struct * color;
    gdImagePtr brush;
};

typedef struct HID_Attribute.conflict2 HID_Attribute.conflict2, *PHID_Attribute.conflict2;

typedef enum anon_enum_32_for_type.conflict2 {
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096
} anon_enum_32_for_type.conflict2;

struct HID_Attribute.conflict2 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict2 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct hid_gc_struct.conflict3 hid_gc_struct.conflict3, *Phid_gc_struct.conflict3;

struct hid_gc_struct.conflict3 {
    struct HID * me_pointer;
    enum EndCapStyle cap;
    int width;
    uchar r;
    uchar g;
    uchar b;
    undefined field_0xf;
    int erase;
    int faded;
};

typedef struct HID_Attribute.conflict1 HID_Attribute.conflict1, *PHID_Attribute.conflict1;

typedef enum anon_enum_32_for_type.conflict1 {
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3
} anon_enum_32_for_type.conflict1;

struct HID_Attribute.conflict1 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict1 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct hid_gc_struct.conflict1 hid_gc_struct.conflict1, *Phid_gc_struct.conflict1;

struct hid_gc_struct.conflict1 {
    enum EndCapStyle cap;
    int width;
    int color;
    int erase;
    int drill;
};

typedef struct HID_Attribute.conflict7 HID_Attribute.conflict7, *PHID_Attribute.conflict7;

typedef enum anon_enum_32_for_type.conflict7 {
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_EQUIV=9,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SET=15,
    GDK_XOR=2,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict7;

struct HID_Attribute.conflict7 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict7 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict6 HID_Attribute.conflict6, *PHID_Attribute.conflict6;

typedef enum anon_enum_32_for_type.conflict6 {
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict6;

struct HID_Attribute.conflict6 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict6 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict5 HID_Attribute.conflict5, *PHID_Attribute.conflict5;

typedef enum anon_enum_32_for_type.conflict5 {
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict5;

struct HID_Attribute.conflict5 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict5 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict4 HID_Attribute.conflict4, *PHID_Attribute.conflict4;

typedef enum anon_enum_32_for_type.conflict4 {
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    ODD=1,
    OTHER=5,
    PAD=0,
    PIN=1,
    PLANE=7,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict4;

struct HID_Attribute.conflict4 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict4 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct hid_gc_struct.conflict hid_gc_struct.conflict, *Phid_gc_struct.conflict;

struct hid_gc_struct.conflict {
    struct HID * me_pointer;
    GdkGC * gc;
    gchar * colorname;
    gint width;
    gint cap;
    gint join;
    gchar xor;
    gchar erase;
    undefined field_0x1a;
    undefined field_0x1b;
    gint mask_seq;
};

typedef struct hid_gc_struct.conflict4 hid_gc_struct.conflict4, *Phid_gc_struct.conflict4;

struct hid_gc_struct.conflict4 {
    enum EndCapStyle cap;
    int width;
    int color;
    int erase;
};

typedef struct HID_Attribute.conflict12 HID_Attribute.conflict12, *PHID_Attribute.conflict12;

typedef enum anon_enum_32_for_type.conflict12 {
    CONFIG_NAME_COLUMN=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    DRC_VIOLATION_NUM_COL=0,
    DRC_VIOLATION_OBJ_COL=1,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_EQUIV=9,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SET=15,
    GDK_XOR=2,
    GTK_APP_PAINTABLE=524288,
    GTK_ARROW_DOWN=1,
    GTK_ARROW_LEFT=2,
    GTK_ARROW_NONE=4,
    GTK_ARROW_RIGHT=3,
    GTK_ARROW_UP=0,
    GTK_BUTTONS_CANCEL=3,
    GTK_BUTTONS_CLOSE=2,
    GTK_BUTTONS_NONE=0,
    GTK_BUTTONS_OK=1,
    GTK_BUTTONS_OK_CANCEL=5,
    GTK_BUTTONS_YES_NO=4,
    GTK_CAN_DEFAULT=8192,
    GTK_CAN_FOCUS=2048,
    GTK_COMPOSITE_CHILD=131072,
    GTK_DIALOG_DESTROY_WITH_PARENT=2,
    GTK_DIALOG_MODAL=1,
    GTK_DIALOG_NO_SEPARATOR=4,
    GTK_DOUBLE_BUFFERED=2097152,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3,
    GTK_FILE_CHOOSER_ACTION_OPEN=0,
    GTK_FILE_CHOOSER_ACTION_SAVE=1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2,
    GTK_HAS_DEFAULT=16384,
    GTK_HAS_FOCUS=4096,
    GTK_HAS_GRAB=32768,
    GTK_ICON_SIZE_BUTTON=4,
    GTK_ICON_SIZE_DIALOG=6,
    GTK_ICON_SIZE_DND=5,
    GTK_ICON_SIZE_INVALID=0,
    GTK_ICON_SIZE_LARGE_TOOLBAR=3,
    GTK_ICON_SIZE_MENU=1,
    GTK_ICON_SIZE_SMALL_TOOLBAR=2,
    GTK_MAPPED=128,
    GTK_MESSAGE_ERROR=3,
    GTK_MESSAGE_INFO=0,
    GTK_MESSAGE_OTHER=4,
    GTK_MESSAGE_QUESTION=2,
    GTK_MESSAGE_WARNING=1,
    GTK_NO_REPARENT=262144,
    GTK_NO_SHOW_ALL=4194304,
    GTK_NO_WINDOW=32,
    GTK_PARENT_SENSITIVE=1024,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_RC_STYLE=65536,
    GTK_REALIZED=64,
    GTK_RECEIVES_DEFAULT=1048576,
    GTK_RELIEF_HALF=1,
    GTK_RELIEF_NONE=2,
    GTK_RELIEF_NORMAL=0,
    GTK_RESPONSE_ACCEPT=-3,
    GTK_RESPONSE_APPLY=-10,
    GTK_RESPONSE_CANCEL=-6,
    GTK_RESPONSE_CLOSE=-7,
    GTK_RESPONSE_DELETE_EVENT=-4,
    GTK_RESPONSE_HELP=-11,
    GTK_RESPONSE_NO=-9,
    GTK_RESPONSE_NONE=-1,
    GTK_RESPONSE_OK=-5,
    GTK_RESPONSE_REJECT=-2,
    GTK_RESPONSE_YES=-8,
    GTK_SENSITIVE=512,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2,
    GTK_TOPLEVEL=16,
    GTK_VISIBLE=256,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    GTK_WIN_POS_CENTER=1,
    GTK_WIN_POS_CENTER_ALWAYS=3,
    GTK_WIN_POS_CENTER_ON_PARENT=4,
    GTK_WIN_POS_MOUSE=2,
    GTK_WIN_POS_NONE=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_EXISTS=16,
    G_FILE_TEST_IS_DIR=4,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_FILE_TEST_IS_REGULAR=1,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_LOG_FLAG_RECURSION=1,
    G_LOG_LEVEL_CRITICAL=8,
    G_LOG_LEVEL_DEBUG=128,
    G_LOG_LEVEL_ERROR=4,
    G_LOG_LEVEL_INFO=64,
    G_LOG_LEVEL_MASK=-4,
    G_LOG_LEVEL_MESSAGE=32,
    G_LOG_LEVEL_WARNING=16,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    MENU_ENTRY_COLUMN=2,
    MENU_LIBRARY_COLUMN=1,
    MENU_NAME_COLUMN=0,
    NET_ENABLED_COLUMN=0,
    NET_LIBRARY_COLUMN=2,
    NET_NAME_COLUMN=1,
    NODE_LIBRARY_COLUMN=1,
    NODE_NAME_COLUMN=0,
    NUM_DRC_COLUMNS=2,
    N_CONFIG_COLUMNS=2,
    N_MENU_COLUMNS=3,
    N_NET_COLUMNS=3,
    N_NODE_COLUMNS=2,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    PROP_ANGLE=5,
    PROP_ELEMENT_DATA=1,
    PROP_EXPLANATION=2,
    PROP_HAVE_MEASURED=6,
    PROP_MEASURED_VALUE=7,
    PROP_OBJECT_LIST=11,
    PROP_PIXMAP=12,
    PROP_REQUIRED_VALUE=8,
    PROP_TITLE=1,
    PROP_VALUE_DIGITS=9,
    PROP_VALUE_UNITS=10,
    PROP_VIOLATION=1,
    PROP_X_COORD=3,
    PROP_Y_COORD=4,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict12;

struct HID_Attribute.conflict12 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict12 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};

typedef struct HID_Attribute.conflict11 HID_Attribute.conflict11, *PHID_Attribute.conflict11;

typedef enum anon_enum_32_for_type.conflict11 {
    CONFIG_NAME_COLUMN=0,
    CONFIG_PAGE_COLUMN=1,
    DBUS_BUS_SESSION=0,
    DBUS_BUS_STARTER=2,
    DBUS_BUS_SYSTEM=1,
    DBUS_WATCH_ERROR=4,
    DBUS_WATCH_HANGUP=8,
    DBUS_WATCH_READABLE=1,
    DBUS_WATCH_WRITABLE=2,
    DRC_VIOLATION_NUM_COL=0,
    DRC_VIOLATION_OBJ_COL=1,
    EVEN=2,
    EXCHANGE=2,
    EXPANSION_AREA=6,
    FALSE=0,
    FIXED=0,
    FL_BACK=-2,
    FL_MASK=-1,
    FL_PINS=-5,
    FL_RATS=-4,
    FL_SILK=-6,
    FL_VIAS=-3,
    GDK_AND=4,
    GDK_AND_INVERT=6,
    GDK_AND_REVERSE=5,
    GDK_CAP_BUTT=1,
    GDK_CAP_NOT_LAST=0,
    GDK_CAP_PROJECTING=3,
    GDK_CAP_ROUND=2,
    GDK_CLEAR=3,
    GDK_COPY=0,
    GDK_COPY_INVERT=11,
    GDK_EQUIV=9,
    GDK_INVERT=1,
    GDK_JOIN_BEVEL=2,
    GDK_JOIN_MITER=0,
    GDK_JOIN_ROUND=1,
    GDK_LINE_DOUBLE_DASH=2,
    GDK_LINE_ON_OFF_DASH=1,
    GDK_LINE_SOLID=0,
    GDK_NAND=13,
    GDK_NOOP=7,
    GDK_NOR=14,
    GDK_OR=8,
    GDK_OR_INVERT=12,
    GDK_OR_REVERSE=10,
    GDK_RGB_DITHER_MAX=2,
    GDK_RGB_DITHER_NONE=0,
    GDK_RGB_DITHER_NORMAL=1,
    GDK_SET=15,
    GDK_XOR=2,
    GTK_APP_PAINTABLE=524288,
    GTK_ARROW_DOWN=1,
    GTK_ARROW_LEFT=2,
    GTK_ARROW_NONE=4,
    GTK_ARROW_RIGHT=3,
    GTK_ARROW_UP=0,
    GTK_BUTTONS_CANCEL=3,
    GTK_BUTTONS_CLOSE=2,
    GTK_BUTTONS_NONE=0,
    GTK_BUTTONS_OK=1,
    GTK_BUTTONS_OK_CANCEL=5,
    GTK_BUTTONS_YES_NO=4,
    GTK_CAN_DEFAULT=8192,
    GTK_CAN_FOCUS=2048,
    GTK_COMPOSITE_CHILD=131072,
    GTK_DIALOG_DESTROY_WITH_PARENT=2,
    GTK_DIALOG_MODAL=1,
    GTK_DIALOG_NO_SEPARATOR=4,
    GTK_DOUBLE_BUFFERED=2097152,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3,
    GTK_FILE_CHOOSER_ACTION_OPEN=0,
    GTK_FILE_CHOOSER_ACTION_SAVE=1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2,
    GTK_HAS_DEFAULT=16384,
    GTK_HAS_FOCUS=4096,
    GTK_HAS_GRAB=32768,
    GTK_ICON_SIZE_BUTTON=4,
    GTK_ICON_SIZE_DIALOG=6,
    GTK_ICON_SIZE_DND=5,
    GTK_ICON_SIZE_INVALID=0,
    GTK_ICON_SIZE_LARGE_TOOLBAR=3,
    GTK_ICON_SIZE_MENU=1,
    GTK_ICON_SIZE_SMALL_TOOLBAR=2,
    GTK_MAPPED=128,
    GTK_MESSAGE_ERROR=3,
    GTK_MESSAGE_INFO=0,
    GTK_MESSAGE_OTHER=4,
    GTK_MESSAGE_QUESTION=2,
    GTK_MESSAGE_WARNING=1,
    GTK_NO_REPARENT=262144,
    GTK_NO_SHOW_ALL=4194304,
    GTK_NO_WINDOW=32,
    GTK_PARENT_SENSITIVE=1024,
    GTK_POLICY_ALWAYS=0,
    GTK_POLICY_AUTOMATIC=1,
    GTK_POLICY_NEVER=2,
    GTK_RC_STYLE=65536,
    GTK_REALIZED=64,
    GTK_RECEIVES_DEFAULT=1048576,
    GTK_RELIEF_HALF=1,
    GTK_RELIEF_NONE=2,
    GTK_RELIEF_NORMAL=0,
    GTK_RESPONSE_ACCEPT=-3,
    GTK_RESPONSE_APPLY=-10,
    GTK_RESPONSE_CANCEL=-6,
    GTK_RESPONSE_CLOSE=-7,
    GTK_RESPONSE_DELETE_EVENT=-4,
    GTK_RESPONSE_HELP=-11,
    GTK_RESPONSE_NO=-9,
    GTK_RESPONSE_NONE=-1,
    GTK_RESPONSE_OK=-5,
    GTK_RESPONSE_REJECT=-2,
    GTK_RESPONSE_YES=-8,
    GTK_SENSITIVE=512,
    GTK_SHADOW_ETCHED_IN=3,
    GTK_SHADOW_ETCHED_OUT=4,
    GTK_SHADOW_IN=1,
    GTK_SHADOW_NONE=0,
    GTK_SHADOW_OUT=2,
    GTK_TOPLEVEL=16,
    GTK_VISIBLE=256,
    GTK_WINDOW_POPUP=1,
    GTK_WINDOW_TOPLEVEL=0,
    GTK_WIN_POS_CENTER=1,
    GTK_WIN_POS_CENTER_ALWAYS=3,
    GTK_WIN_POS_CENTER_ON_PARENT=4,
    GTK_WIN_POS_MOUSE=2,
    GTK_WIN_POS_NONE=0,
    G_CONNECT_AFTER=1,
    G_CONNECT_SWAPPED=2,
    G_FILE_TEST_EXISTS=16,
    G_FILE_TEST_IS_DIR=4,
    G_FILE_TEST_IS_EXECUTABLE=8,
    G_FILE_TEST_IS_REGULAR=1,
    G_FILE_TEST_IS_SYMLINK=2,
    G_LOG_FLAG_FATAL=2,
    G_LOG_FLAG_RECURSION=1,
    G_LOG_LEVEL_CRITICAL=8,
    G_LOG_LEVEL_DEBUG=128,
    G_LOG_LEVEL_ERROR=4,
    G_LOG_LEVEL_INFO=64,
    G_LOG_LEVEL_MASK=-4,
    G_LOG_LEVEL_MESSAGE=32,
    G_LOG_LEVEL_WARNING=16,
    HID_Boolean=4,
    HID_Enum=5,
    HID_Integer=1,
    HID_Label=0,
    HID_Mixed=6,
    HID_Path=7,
    HID_Real=2,
    HID_String=3,
    LINE=4,
    MENU_ENTRY_COLUMN=2,
    MENU_LIBRARY_COLUMN=1,
    MENU_NAME_COLUMN=0,
    NET_ENABLED_COLUMN=0,
    NET_LIBRARY_COLUMN=2,
    NET_NAME_COLUMN=1,
    NODE_LIBRARY_COLUMN=1,
    NODE_NAME_COLUMN=0,
    NUM_DRC_COLUMNS=2,
    N_CONFIG_COLUMNS=2,
    N_MENU_COLUMNS=3,
    N_NET_COLUMNS=3,
    N_NODE_COLUMNS=2,
    ODD=1,
    OTHER=5,
    PAD=0,
    PCB_WATCH_ERROR=4,
    PCB_WATCH_HANGUP=8,
    PCB_WATCH_READABLE=1,
    PCB_WATCH_WRITABLE=2,
    PIN=1,
    PLANE=7,
    PROP_ANGLE=5,
    PROP_EXPLANATION=2,
    PROP_HAVE_MEASURED=6,
    PROP_MEASURED_VALUE=7,
    PROP_OBJECT_LIST=11,
    PROP_PIXMAP=12,
    PROP_REQUIRED_VALUE=8,
    PROP_TITLE=1,
    PROP_VALUE_DIGITS=9,
    PROP_VALUE_UNITS=10,
    PROP_VIOLATION=1,
    PROP_X_COORD=3,
    PROP_Y_COORD=4,
    ROTATE=1,
    SHIFT=0,
    THERMAL=8,
    TRUE=1,
    VIA=2,
    VIA_SHADOW=3,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    err_bad_parm=3,
    err_no_memory=2,
    err_ok=0
} anon_enum_32_for_type.conflict11;

struct HID_Attribute.conflict11 {
    char * name;
    char * help_text;
    enum anon_enum_32_for_type.conflict11 type;
    int min_val;
    int max_val;
    struct HID_Attr_Val default_val;
    char * * enumerations;
    void * value;
    int hash;
};


// WARNING! conflicting data type names: /DWARF/hid.h/anon_enum_32 - /DWARF/report.c/ReportAllNetLengths/anon_enum_32

typedef struct SizesDialog SizesDialog, *PSizesDialog;

struct SizesDialog {
    GtkWidget * name_entry;
    GtkWidget * line_width_spin_button;
    GtkWidget * via_hole_spin_button;
    GtkWidget * via_size_spin_button;
    GtkWidget * clearance_spin_button;
    GtkWidget * set_temp1_button;
    GtkWidget * set_temp2_button;
    gboolean units_mm;
};

typedef struct pv_info pv_info, *Ppv_info;

struct pv_info {
    Cardinal layer;
    struct PinType pv;
    jmp_buf env;
};

typedef struct ListType ListType, *PListType;

struct ListType {
    void * * Data;
    Cardinal Location;
    Cardinal DrawLocation;
    Cardinal Number;
    Cardinal Size;
};

typedef struct rat_info rat_info, *Prat_info;

struct rat_info {
    Cardinal layer;
    PointTypePtr Point;
    jmp_buf env;
};

typedef struct lo_info lo_info, *Plo_info;

typedef struct ArcType ArcType, *PArcType;

typedef struct RatType RatType, *PRatType;

struct RatType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    Cardinal group1;
    Cardinal group2;
};

struct ArcType {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    LocationType Width;
    LocationType Height;
    LocationType X;
    LocationType Y;
    long StartAngle;
    long Delta;
};

struct lo_info {
    Cardinal layer;
    struct LineType line;
    struct PadType pad;
    struct ArcType arc;
    PolygonType polygon;
    struct RatType rat;
    jmp_buf env;
};

typedef struct line_info.conflict line_info.conflict, *Pline_info.conflict;

struct line_info.conflict {
    LineTypePtr * Line;
    PointTypePtr * Point;
    float least;
    jmp_buf env;
    int locked;
};

typedef struct ans_info ans_info, *Pans_info;

struct ans_info {
    void * * ptr1;
    void * * ptr2;
    void * * ptr3;
    Boolean BackToo;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    float area;
    jmp_buf env;
    int locked;
};

typedef struct arc_info arc_info, *Parc_info;

struct arc_info {
    struct ArcTypePtr * * Arc;
    struct ArcTypePtr * * Dummy;
    jmp_buf env;
    int locked;
};

typedef struct LayerType.conflict2 LayerType.conflict2, *PLayerType.conflict2;

typedef struct ArcType * ArcTypePtr.conflict;

struct LayerType.conflict2 {
    char * Name;
    Cardinal LineN;
    Cardinal TextN;
    Cardinal PolygonN;
    Cardinal ArcN;
    Cardinal LineMax;
    Cardinal TextMax;
    Cardinal PolygonMax;
    Cardinal ArcMax;
    LineTypePtr Line;
    TextTypePtr Text;
    PolygonTypePtr Polygon;
    ArcTypePtr.conflict Arc;
    rtree_t * line_tree;
    rtree_t * text_tree;
    rtree_t * polygon_tree;
    rtree_t * arc_tree;
    Boolean On;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    char * Color;
    char * SelectedColor;
    struct AttributeListType Attributes;
};

typedef struct BoxType * BoxTypePtr;

typedef struct LayerType.conflict1 LayerType.conflict1, *PLayerType.conflict1;

struct LayerType.conflict1 {
    char * Name;
    Cardinal LineN;
    Cardinal TextN;
    Cardinal PolygonN;
    Cardinal ArcN;
    Cardinal LineMax;
    Cardinal TextMax;
    Cardinal PolygonMax;
    Cardinal ArcMax;
    struct LineTypePtr.conflict * Line;
    TextTypePtr Text;
    PolygonTypePtr Polygon;
    ArcTypePtr.conflict Arc;
    rtree_t * line_tree;
    rtree_t * text_tree;
    rtree_t * polygon_tree;
    rtree_t * arc_tree;
    Boolean On;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    char * Color;
    char * SelectedColor;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict17 anon_struct.conflict17, *Panon_struct.conflict17;

typedef struct NetTypePtr NetTypePtr, *PNetTypePtr;

typedef struct ConnectionTypePtr ConnectionTypePtr, *PConnectionTypePtr;

typedef struct RouteStyleType * RouteStyleTypePtr;

struct anon_struct.conflict17 {
    Cardinal NetN;
    Cardinal NetMax;
    struct NetTypePtr * Net;
};

struct ConnectionTypePtr {
    LocationType X;
    LocationType Y;
    long type;
    void * ptr1;
    void * ptr2;
    Cardinal group;
    struct LibraryMenuType * menu;
};

struct NetTypePtr {
    Cardinal ConnectionN;
    Cardinal ConnectionMax;
    struct ConnectionTypePtr * Connection;
    RouteStyleTypePtr Style;
};

typedef struct BoxListTypePtr.conflict BoxListTypePtr.conflict, *PBoxListTypePtr.conflict;

struct BoxListTypePtr.conflict {
    Cardinal BoxN;
    Cardinal BoxMax;
    BoxTypePtr Box;
};

typedef struct anon_struct.conflict16 anon_struct.conflict16, *Panon_struct.conflict16;

struct anon_struct.conflict16 {
    Cardinal ConnectionN;
    Cardinal ConnectionMax;
    struct ConnectionTypePtr * Connection;
    RouteStyleTypePtr Style;
};

typedef struct anon_struct.conflict15 anon_struct.conflict15, *Panon_struct.conflict15;

struct anon_struct.conflict15 {
    LocationType X;
    LocationType Y;
    long type;
    void * ptr1;
    void * ptr2;
    Cardinal group;
    struct LibraryMenuType * menu;
};

typedef char * String;

typedef struct anon_struct.conflict14 anon_struct.conflict14, *Panon_struct.conflict14;

struct anon_struct.conflict14 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict Layer[18];
};

typedef struct anon_struct.conflict13 anon_struct.conflict13, *Panon_struct.conflict13;

struct anon_struct.conflict13 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    struct LineTypePtr.conflict * Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict12 anon_struct.conflict12, *Panon_struct.conflict12;

struct anon_struct.conflict12 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    char * Number;
};

typedef struct anon_struct.conflict36 anon_struct.conflict36, *Panon_struct.conflict36;

typedef struct DrillTypePtr.conflict DrillTypePtr.conflict, *PDrillTypePtr.conflict;

struct anon_struct.conflict36 {
    Cardinal DrillN;
    Cardinal DrillMax;
    struct DrillTypePtr.conflict * Drill;
};

struct DrillTypePtr.conflict {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    struct PinTypePtr * * Pin;
    struct ElementTypePtr * * Element;
};

typedef struct polygon_st.conflict polygon_st.conflict, *Ppolygon_st.conflict;

typedef struct polygon_st.conflict PolygonType.conflict;

typedef struct PointTypePtr.conflict PointTypePtr.conflict, *PPointTypePtr.conflict;

struct PointTypePtr.conflict {
    LocationType X;
    LocationType Y;
    LocationType X2;
    LocationType Y2;
    long ID;
};

struct polygon_st.conflict {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    Cardinal PointN;
    Cardinal PointMax;
    struct POLYAREA * Clipped;
    struct PLINE * NoHoles;
    int NoHolesValid;
    struct PointTypePtr.conflict * Points;
};

typedef struct PinTypeHandle PinTypeHandle, *PPinTypeHandle;

struct PinTypeHandle {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    BDimension Mask;
    BDimension DrillingHole;
    LocationType X;
    LocationType Y;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

typedef struct AttachedLineType AttachedLineType, *PAttachedLineType;

typedef struct AttachedLineType * AttachedLineTypePtr;

struct AttachedLineType {
    struct PointType Point1;
    struct PointType Point2;
    long State;
    Boolean draw;
    undefined field_0x2d;
    undefined field_0x2e;
    undefined field_0x2f;
};

typedef struct DrillInfoTypePtr DrillInfoTypePtr, *PDrillInfoTypePtr;

typedef struct DrillType DrillType, *PDrillType;

typedef struct DrillType * DrillTypePtr;

struct DrillType {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    struct PinTypePtr * * Pin;
    struct ElementTypePtr * * Element;
};

struct DrillInfoTypePtr {
    Cardinal DrillN;
    Cardinal DrillMax;
    DrillTypePtr Drill;
};

typedef struct anon_struct.conflict1 anon_struct.conflict1, *Panon_struct.conflict1;

struct anon_struct.conflict1 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    LocationType Width;
    LocationType Height;
    LocationType X;
    LocationType Y;
    long StartAngle;
    long Delta;
};

typedef struct NetListListTypePtr NetListListTypePtr, *PNetListListTypePtr;

typedef struct NetListTypePtr NetListTypePtr, *PNetListTypePtr;

struct NetListListTypePtr {
    Cardinal NetListN;
    Cardinal NetListMax;
    struct NetListTypePtr * NetList;
};

struct NetListTypePtr {
    Cardinal NetN;
    Cardinal NetMax;
    struct NetTypePtr * Net;
};

typedef struct anon_struct.conflict24 anon_struct.conflict24, *Panon_struct.conflict24;

struct anon_struct.conflict24 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict1 Layer[18];
};

typedef struct BufferType BufferType, *PBufferType;

struct BufferType {
    LocationType X;
    LocationType Y;
    struct BoxType BoundingBox;
    struct DataTypePtr * Data;
};

typedef struct anon_struct.conflict9 anon_struct.conflict9, *Panon_struct.conflict9;

struct anon_struct.conflict9 {
    LayerTypePtr Layer;
    LineTypePtr Line;
    PointTypePtr MovedPoint;
};

typedef struct anon_struct.conflict50 anon_struct.conflict50, *Panon_struct.conflict50;

typedef struct RatType * RatTypePtr.conflict;

struct anon_struct.conflict50 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr.conflict Via;
    struct ElementTypePtr * Element;
    RatTypePtr.conflict Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType Layer[18];
};

typedef struct ConnectionType ConnectionType, *PConnectionType;

typedef struct ConnectionType * ConnectionTypePtr.conflict;

struct ConnectionType {
    LocationType X;
    LocationType Y;
    long type;
    void * ptr1;
    void * ptr2;
    Cardinal group;
    struct LibraryMenuType * menu;
};

typedef struct BoxListType BoxListType, *PBoxListType;

typedef struct BoxListType * BoxListTypePtr;

struct BoxListType {
    Cardinal BoxN;
    Cardinal BoxMax;
    BoxTypePtr Box;
};

typedef struct anon_struct.conflict35 anon_struct.conflict35, *Panon_struct.conflict35;

struct anon_struct.conflict35 {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    struct PinTypePtr * * Pin;
    struct ElementTypePtr * * Element;
};

typedef struct ElementTypeHandle ElementTypeHandle, *PElementTypeHandle;

struct ElementTypeHandle {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    struct LineTypePtr.conflict * Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict23 anon_struct.conflict23, *Panon_struct.conflict23;

struct anon_struct.conflict23 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    struct LineTypePtr.conflict * Line;
    ArcTypePtr.conflict Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict8 anon_struct.conflict8, *Panon_struct.conflict8;

struct anon_struct.conflict8 {
    char * Name;
    char * directory;
    char * Style;
    Cardinal EntryN;
    Cardinal EntryMax;
    struct LibraryEntryTypePtr * Entry;
    char flag;
    char internal;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct anon_struct.conflict46 anon_struct.conflict46, *Panon_struct.conflict46;

struct anon_struct.conflict46 {
    void * (* Line)(LayerTypePtr, LineTypePtr);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(struct PinTypePtr *);
    void * (* Element)(struct ElementTypePtr *);
    void * (* ElementName)(struct ElementTypePtr *);
    void * (* Pin)(struct ElementTypePtr *, struct PinTypePtr *);
    void * (* Pad)(struct ElementTypePtr *, struct PadTypePtr *);
    void * (* LinePoint)(LayerTypePtr, LineTypePtr, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, ArcTypePtr.conflict);
    void * (* Rat)(struct RatTypePtr *);
};

typedef struct PCBType.conflict PCBType.conflict, *PPCBType.conflict;

typedef struct FontType.conflict FontType.conflict, *PFontType.conflict;

typedef struct LibraryType.conflict LibraryType.conflict, *PLibraryType.conflict;

typedef struct SymbolType.conflict SymbolType.conflict, *PSymbolType.conflict;

typedef struct LibraryMenuType * LibraryMenuTypePtr.conflict;

struct LibraryType.conflict {
    Cardinal MenuN;
    Cardinal MenuMax;
    LibraryMenuTypePtr.conflict Menu;
};

struct SymbolType.conflict {
    struct LineTypePtr.conflict * Line;
    Boolean Valid;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    Cardinal LineN;
    Cardinal LineMax;
    BDimension Width;
    BDimension Height;
    BDimension Delta;
};

struct FontType.conflict {
    LocationType MaxHeight;
    LocationType MaxWidth;
    struct BoxType DefaultSymbol;
    struct SymbolType.conflict Symbol[256];
    Boolean Valid;
    undefined field_0x1c19;
    undefined field_0x1c1a;
    undefined field_0x1c1b;
};

struct PCBType.conflict {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType.conflict Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType.conflict NetlistLib;
    struct AttributeListType Attributes;
    struct DataTypePtr * Data;
};

typedef enum crosshair_shape {
    Basic_Crosshair_Shape=0,
    Crosshair_Shapes_Number=3,
    Dozen_Crosshair_Shape=2,
    Union_Jack_Crosshair_Shape=1
} crosshair_shape;

typedef struct NetListListType NetListListType, *PNetListListType;

struct NetListListType {
    Cardinal NetListN;
    Cardinal NetListMax;
    struct NetListTypePtr * NetList;
};

typedef struct anon_struct.conflict53 anon_struct.conflict53, *Panon_struct.conflict53;

struct anon_struct.conflict53 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    ElementTypePtr.conflict Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict Layer[18];
};

typedef struct anon_struct.conflict52 anon_struct.conflict52, *Panon_struct.conflict52;

typedef struct LibraryEntryType * LibraryEntryTypePtr.conflict;

struct anon_struct.conflict52 {
    char * Name;
    char * directory;
    char * Style;
    Cardinal EntryN;
    Cardinal EntryMax;
    LibraryEntryTypePtr.conflict Entry;
    char flag;
    char internal;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct PointerListType PointerListType, *PPointerListType;

struct PointerListType {
    Cardinal PtrN;
    Cardinal PtrMax;
    void * * Ptr;
};

typedef struct anon_struct.conflict34 anon_struct.conflict34, *Panon_struct.conflict34;

struct anon_struct.conflict34 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr.conflict Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict Layer[18];
};

typedef struct anon_struct.conflict43 anon_struct.conflict43, *Panon_struct.conflict43;

struct anon_struct.conflict43 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    PadTypePtr.conflict Pad;
    LineTypePtr Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict3 anon_struct.conflict3, *Panon_struct.conflict3;

struct anon_struct.conflict3 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    BDimension Mask;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

typedef struct anon_struct.conflict41 anon_struct.conflict41, *Panon_struct.conflict41;

struct anon_struct.conflict41 {
    Cardinal ConnectionN;
    Cardinal ConnectionMax;
    ConnectionTypePtr.conflict Connection;
    RouteStyleTypePtr Style;
};

typedef struct anon_struct.conflict40 anon_struct.conflict40, *Panon_struct.conflict40;

struct anon_struct.conflict40 {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    struct PinTypePtr * Pin;
    struct ElementTypePtr * * Element;
};

typedef struct anon_struct.conflict45 anon_struct.conflict45, *Panon_struct.conflict45;

struct anon_struct.conflict45 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict2 Layer[18];
};

typedef struct PointerListType * PointerListTypePtr;

typedef struct anon_struct.conflict49 anon_struct.conflict49, *Panon_struct.conflict49;

struct anon_struct.conflict49 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    PinTypePtr.conflict Pin;
    PadTypePtr.conflict Pad;
    LineTypePtr Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct RubberbandTypePtr RubberbandTypePtr, *PRubberbandTypePtr;

struct RubberbandTypePtr {
    LayerTypePtr Layer;
    LineTypePtr Line;
    PointTypePtr MovedPoint;
};

typedef struct anon_struct.conflict22 anon_struct.conflict22, *Panon_struct.conflict22;

struct anon_struct.conflict22 {
    LayerTypePtr Layer;
    struct LineTypePtr.conflict * Line;
    PointTypePtr MovedPoint;
};

typedef struct anon_struct.conflict44 anon_struct.conflict44, *Panon_struct.conflict44;

struct anon_struct.conflict44 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    LineTypePtr Line;
    ArcTypePtr.conflict Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct CrosshairType CrosshairType, *PCrosshairType;

typedef struct AttachedBoxType AttachedBoxType, *PAttachedBoxType;

typedef struct AttachedObjectType AttachedObjectType, *PAttachedObjectType;

struct AttachedObjectType {
    LocationType X;
    LocationType Y;
    struct BoxType BoundingBox;
    long Type;
    long State;
    void * Ptr1;
    void * Ptr2;
    void * Ptr3;
    Cardinal RubberbandN;
    Cardinal RubberbandMax;
    struct RubberbandTypePtr * Rubberband;
};

struct AttachedBoxType {
    struct PointType Point1;
    struct PointType Point2;
    long State;
    Boolean otherway;
    undefined field_0x2d;
    undefined field_0x2e;
    undefined field_0x2f;
};

struct CrosshairType {
    hidGC GC;
    hidGC AttachGC;
    LocationType X;
    LocationType Y;
    LocationType MinX;
    LocationType MinY;
    LocationType MaxX;
    LocationType MaxY;
    Boolean On;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    struct AttachedLineType AttachedLine;
    struct AttachedBoxType AttachedBox;
    PolygonType AttachedPolygon;
    struct AttachedObjectType AttachedObject;
    enum crosshair_shape shape;
};

typedef struct anon_struct.conflict31 anon_struct.conflict31, *Panon_struct.conflict31;

struct anon_struct.conflict31 {
    Cardinal BoxN;
    Cardinal BoxMax;
    BoxTypePtr Box;
};

typedef struct anon_struct.conflict30 anon_struct.conflict30, *Panon_struct.conflict30;

struct anon_struct.conflict30 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr.conflict Via;
    struct ElementTypePtr * Element;
    RatTypePtr.conflict Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict2 Layer[18];
};

typedef struct anon_struct.conflict33 anon_struct.conflict33, *Panon_struct.conflict33;

struct anon_struct.conflict33 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    PinTypePtr.conflict Pin;
    struct PadTypePtr * Pad;
    struct LineTypePtr.conflict * Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict38 anon_struct.conflict38, *Panon_struct.conflict38;

struct anon_struct.conflict38 {
    Cardinal PtrN;
    Cardinal PtrMax;
    void * * Ptr;
};

typedef struct anon_struct.conflict37 anon_struct.conflict37, *Panon_struct.conflict37;

struct anon_struct.conflict37 {
    Cardinal NetListN;
    Cardinal NetListMax;
    struct NetListTypePtr * NetList;
};

typedef struct DataType.conflict DataType.conflict, *PDataType.conflict;

struct DataType.conflict {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr.conflict Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType.conflict2 Layer[18];
};

typedef struct DrillTypePtr.conflict1 DrillTypePtr.conflict1, *PDrillTypePtr.conflict1;

struct DrillTypePtr.conflict1 {
    BDimension DrillSize;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal PinCount;
    Cardinal ViaCount;
    Cardinal UnplatedCount;
    Cardinal PinN;
    Cardinal PinMax;
    struct PinTypePtr * Pin;
    struct ElementTypePtr * * Element;
};

typedef struct anon_struct.conflict2 anon_struct.conflict2, *Panon_struct.conflict2;

struct anon_struct.conflict2 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    struct PointType Point1;
    struct PointType Point2;
    Cardinal group1;
    Cardinal group2;
};

typedef struct anon_struct.conflict29 anon_struct.conflict29, *Panon_struct.conflict29;

struct anon_struct.conflict29 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    PinTypePtr.conflict Pin;
    PadTypePtr.conflict Pad;
    LineTypePtr Line;
    ArcTypePtr.conflict Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct anon_struct.conflict28 anon_struct.conflict28, *Panon_struct.conflict28;

struct anon_struct.conflict28 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
};

typedef struct anon_struct.conflict27 anon_struct.conflict27, *Panon_struct.conflict27;

struct anon_struct.conflict27 {
    LocationType X;
    LocationType Y;
    LocationType X2;
    LocationType Y2;
    long ID;
};

typedef struct anon_struct.conflict26 anon_struct.conflict26, *Panon_struct.conflict26;

struct anon_struct.conflict26 {
    Cardinal DrillN;
    Cardinal DrillMax;
    DrillTypePtr Drill;
};

typedef struct anon_struct.conflict25 anon_struct.conflict25, *Panon_struct.conflict25;

struct anon_struct.conflict25 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    PinTypePtr.conflict Via;
    ElementTypePtr.conflict Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType Layer[18];
};

typedef struct PCBType * PCBTypePtr;

typedef struct ObjectFunctionTypePtr ObjectFunctionTypePtr, *PObjectFunctionTypePtr;

struct ObjectFunctionTypePtr {
    void * (* Line)(LayerTypePtr, LineTypePtr);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(struct PinTypePtr *);
    void * (* Element)(struct ElementTypePtr *);
    void * (* ElementName)(struct ElementTypePtr *);
    void * (* Pin)(struct ElementTypePtr *, struct PinTypePtr *);
    void * (* Pad)(struct ElementTypePtr *, struct PadTypePtr *);
    void * (* LinePoint)(LayerTypePtr, LineTypePtr, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, ArcTypePtr.conflict);
    void * (* Rat)(struct RatTypePtr *);
};

typedef struct PointerListTypePtr.conflict PointerListTypePtr.conflict, *PPointerListTypePtr.conflict;

struct PointerListTypePtr.conflict {
    Cardinal PtrN;
    Cardinal PtrMax;
    void * * Ptr;
};

typedef struct ObjectFunctionType.conflict ObjectFunctionType.conflict, *PObjectFunctionType.conflict;

struct ObjectFunctionType.conflict {
    void * (* Line)(LayerTypePtr, LineTypePtr);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(struct PinTypePtr *);
    void * (* Element)(struct ElementTypePtr *);
    void * (* ElementName)(struct ElementTypePtr *);
    void * (* Pin)(struct ElementTypePtr *, struct PinTypePtr *);
    void * (* Pad)(struct ElementTypePtr *, struct PadTypePtr *);
    void * (* LinePoint)(LayerTypePtr, LineTypePtr, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, struct ArcTypePtr *);
    void * (* Rat)(struct RatTypePtr *);
};

typedef struct OutputType OutputType, *POutputType;

struct OutputType {
    hidGC bgGC;
    hidGC fgGC;
    hidGC pmGC;
    hidGC GridGC;
    int Width;
    int Height;
    int oldObjState;
    int oldLineState;
    int oldBoxState;
};

typedef struct anon_struct.conflict5 anon_struct.conflict5, *Panon_struct.conflict5;

struct anon_struct.conflict5 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    struct TextType Name[3];
    LocationType MarkX;
    LocationType MarkY;
    Cardinal PinN;
    Cardinal PinMax;
    Cardinal PadN;
    Cardinal PadMax;
    Cardinal LineN;
    Cardinal LineMax;
    Cardinal ArcN;
    Cardinal ArcMax;
    struct PinTypePtr * Pin;
    struct PadTypePtr * Pad;
    LineTypePtr Line;
    struct ArcTypePtr * Arc;
    struct BoxType VBox;
    struct AttributeListType Attributes;
};

typedef struct BufferType * BufferTypePtr;

typedef struct AttributeType * AttributeTypePtr;

typedef struct MarkType MarkType, *PMarkType;

struct MarkType {
    Boolean status;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    long X;
    long Y;
};

typedef struct anon_struct.conflict4 anon_struct.conflict4, *Panon_struct.conflict4;

struct anon_struct.conflict4 {
    struct BoxType BoundingBox;
    long ID;
    struct FlagType Flags;
    struct LibraryEntryType * net;
    BDimension Thickness;
    BDimension Clearance;
    BDimension Mask;
    BDimension DrillingHole;
    LocationType X;
    LocationType Y;
    char * Name;
    char * Number;
    void * Element;
    void * Spare;
};

typedef struct AttributeListType * AttributeListTypePtr;

typedef struct ObjectFunctionType ObjectFunctionType, *PObjectFunctionType;

struct ObjectFunctionType {
    void * (* Line)(LayerTypePtr, struct LineTypePtr.conflict *);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(struct PinTypePtr *);
    void * (* Element)(struct ElementTypePtr *);
    void * (* ElementName)(struct ElementTypePtr *);
    void * (* Pin)(struct ElementTypePtr *, struct PinTypePtr *);
    void * (* Pad)(struct ElementTypePtr *, struct PadTypePtr *);
    void * (* LinePoint)(LayerTypePtr, struct LineTypePtr.conflict *, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, struct ArcTypePtr *);
    void * (* Rat)(struct RatTypePtr *);
};

typedef short Dimension;

typedef struct SymbolType * SymbolTypePtr;

typedef struct PCBType.conflict4 PCBType.conflict4, *PPCBType.conflict4;

struct PCBType.conflict4 {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType NetlistLib;
    struct AttributeListType Attributes;
    DataTypePtr.conflict Data;
};

typedef struct PCBType.conflict3 PCBType.conflict3, *PPCBType.conflict3;

struct PCBType.conflict3 {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType.conflict Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType NetlistLib;
    struct AttributeListType Attributes;
    DataTypePtr.conflict Data;
};

typedef struct PCBType.conflict2 PCBType.conflict2, *PPCBType.conflict2;

struct PCBType.conflict2 {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType.conflict Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType NetlistLib;
    struct AttributeListType Attributes;
    struct DataTypePtr * Data;
};

typedef struct PCBType.conflict1 PCBType.conflict1, *PPCBType.conflict1;

struct PCBType.conflict1 {
    long ID;
    struct FlagType Flags;
    char * Name;
    char * Filename;
    char * PrintFilename;
    char * Netlistname;
    char ThermStyle;
    Boolean Changed;
    Boolean ViaOn;
    Boolean ElementOn;
    Boolean RatOn;
    Boolean InvisibleObjectsOn;
    Boolean PinOn;
    Boolean SilkActive;
    Boolean RatDraw;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * WarnColor;
    char * MaskColor;
    long CursorX;
    long CursorY;
    long Clipping;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    int GridOffsetX;
    int GridOffsetY;
    int MaxWidth;
    int MaxHeight;
    double Grid;
    double Zoom;
    double IsleArea;
    double ThermScale;
    struct FontType Font;
    struct LayerGroupType LayerGroups;
    struct RouteStyleType RouteStyle[4];
    struct LibraryType.conflict NetlistLib;
    struct AttributeListType Attributes;
    struct DataTypePtr * Data;
};

typedef struct SettingType SettingType, *PSettingType;

struct SettingType {
    Boolean grid_units_mm;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int verbose;
    char * BlackColor;
    char * WhiteColor;
    char * BackgroundColor;
    char * CrosshairColor;
    char * CrossColor;
    char * ViaColor;
    char * ViaSelectedColor;
    char * PinColor;
    char * PinSelectedColor;
    char * PinNameColor;
    char * ElementColor;
    char * RatColor;
    char * InvisibleObjectsColor;
    char * InvisibleMarkColor;
    char * ElementSelectedColor;
    char * RatSelectedColor;
    char * ConnectedColor;
    char * OffLimitColor;
    char * GridColor;
    char * LayerColor[16];
    char * LayerSelectedColor[16];
    char * WarnColor;
    char * MaskColor;
    int ViaThickness;
    int ViaDrillingHole;
    int LineThickness;
    int RatThickness;
    int Keepaway;
    int MaxWidth;
    int MaxHeight;
    int TextScale;
    int AlignmentDistance;
    int Bloat;
    int Shrink;
    int minWid;
    int minSlk;
    int minDrill;
    int minRing;
    double Grid;
    double IsleArea;
    double grid_increment_mm;
    double grid_increment_mil;
    double size_increment_mm;
    double size_increment_mil;
    double line_increment_mm;
    double line_increment_mil;
    double clear_increment_mm;
    double clear_increment_mil;
    double Zoom;
    double PinoutZoom;
    int PinoutNameLength;
    int Volume;
    int CharPerLine;
    int Mode;
    int BufferNumber;
    int GridFactor;
    int BackupInterval;
    char * DefaultLayerName[16];
    char * FontCommand;
    char * FileCommand;
    char * ElementCommand;
    char * PrintFile;
    char * LibraryCommandDir;
    char * LibraryCommand;
    char * LibraryContentsCommand;
    char * LibraryTree;
    char * SaveCommand;
    char * LibraryFilename;
    char * FontFile;
    char * Groups;
    char * Routes;
    char * FilePath;
    char * RatPath;
    char * RatCommand;
    char * FontPath;
    char * PinoutFont;
    char * ElementPath;
    char * LibraryPath;
    char * Size;
    char * Media;
    char * MenuFile;
    char * BackgroundImage;
    char * ScriptFilename;
    char * ActionString;
    char * FabAuthor;
    char * InitialLayerStack;
    Boolean DumpMenuFile;
    undefined field_0x245;
    undefined field_0x246;
    undefined field_0x247;
    LocationType PinoutOffsetX;
    LocationType PinoutOffsetY;
    int PinoutTextOffsetX;
    int PinoutTextOffsetY;
    struct RouteStyleType RouteStyle[4];
    struct LayerGroupType LayerGroups;
    Boolean ClearLine;
    Boolean FullPoly;
    Boolean UniqueNames;
    Boolean SnapPin;
    Boolean ShowSolderSide;
    Boolean SaveLastCommand;
    Boolean SaveInTMP;
    Boolean DrawGrid;
    Boolean RatWarn;
    Boolean StipplePolygons;
    Boolean AllDirectionLines;
    Boolean RubberBandMode;
    Boolean SwapStartDirection;
    Boolean ShowDRC;
    Boolean AutoDRC;
    Boolean ShowNumber;
    Boolean OrthogonalMoves;
    Boolean ResetAfterElement;
    Boolean liveRouting;
    Boolean RingBellWhenFinished;
    Boolean AutoPlace;
    undefined field_0x78d;
    undefined field_0x78e;
    undefined field_0x78f;
    int HistorySize;
    int init_done;
};

typedef struct anon_struct.conflict7 anon_struct.conflict7, *Panon_struct.conflict7;

struct anon_struct.conflict7 {
    char * ListEntry;
    char * AllocatedMemory;
    char * Template;
    char * Package;
    char * Value;
    char * Description;
};

typedef struct anon_struct.conflict6 anon_struct.conflict6, *Panon_struct.conflict6;

struct anon_struct.conflict6 {
    Cardinal ViaN;
    Cardinal ViaMax;
    Cardinal ElementN;
    Cardinal ElementMax;
    Cardinal RatN;
    Cardinal RatMax;
    int LayerN;
    struct PinTypePtr * Via;
    struct ElementTypePtr * Element;
    struct RatTypePtr * Rat;
    rtree_t * via_tree;
    rtree_t * element_tree;
    rtree_t * pin_tree;
    rtree_t * pad_tree;
    rtree_t * name_tree[3];
    rtree_t * rat_tree;
    struct PCBType * pcb;
    struct LayerType Layer[18];
};

typedef struct ObjectFunctionType.conflict1 ObjectFunctionType.conflict1, *PObjectFunctionType.conflict1;

struct ObjectFunctionType.conflict1 {
    void * (* Line)(LayerTypePtr, struct LineTypePtr.conflict *);
    void * (* Text)(LayerTypePtr, TextTypePtr);
    void * (* Polygon)(LayerTypePtr, PolygonTypePtr);
    void * (* Via)(PinTypePtr.conflict);
    void * (* Element)(struct ElementTypePtr *);
    void * (* ElementName)(struct ElementTypePtr *);
    void * (* Pin)(struct ElementTypePtr *, PinTypePtr.conflict);
    void * (* Pad)(struct ElementTypePtr *, struct PadTypePtr *);
    void * (* LinePoint)(LayerTypePtr, struct LineTypePtr.conflict *, PointTypePtr);
    void * (* Point)(LayerTypePtr, PolygonTypePtr, PointTypePtr);
    void * (* Arc)(LayerTypePtr, struct ArcTypePtr *);
    void * (* Rat)(struct RatTypePtr *);
};

typedef struct LibraryMenuType.conflict LibraryMenuType.conflict, *PLibraryMenuType.conflict;

struct LibraryMenuType.conflict {
    char * Name;
    char * directory;
    char * Style;
    Cardinal EntryN;
    Cardinal EntryMax;
    LibraryEntryTypePtr.conflict Entry;
    char flag;
    char internal;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct FontType * FontTypePtr;

typedef struct LayerGroupType * LayerGroupTypePtr;

typedef struct toporouter_heap_search_data_t toporouter_heap_search_data_t, *Ptoporouter_heap_search_data_t;

typedef struct _toporouter_vertex_t _toporouter_vertex_t, *P_toporouter_vertex_t;

typedef struct _toporouter_vertex_t toporouter_vertex_t;

typedef struct _toporouter_bbox_t _toporouter_bbox_t, *P_toporouter_bbox_t;

typedef struct _toporouter_edge_t _toporouter_edge_t, *P_toporouter_edge_t;

typedef struct _toporouter_edge_t toporouter_edge_t;

typedef struct _toporouter_arc_t _toporouter_arc_t, *P_toporouter_arc_t;

typedef struct _toporouter_oproute_t _toporouter_oproute_t, *P_toporouter_oproute_t;

typedef struct _toporouter_route_t _toporouter_route_t, *P_toporouter_route_t;

typedef enum toporouter_term_t {
    ARC=3,
    BOARD=7,
    EXPANSION_AREA=8,
    LINE=5,
    OTHER=6,
    PAD=0,
    PIN=1,
    POLYGON=9,
    TEMP=10,
    VIA=2,
    VIA_SHADOW=4
} toporouter_term_t;

typedef struct _toporouter_cluster_t _toporouter_cluster_t, *P_toporouter_cluster_t;

typedef struct _toporouter_oproute_t toporouter_oproute_t;

typedef struct _toporouter_serpintine_t _toporouter_serpintine_t, *P_toporouter_serpintine_t;

typedef struct _toporouter_serpintine_t toporouter_serpintine_t;

typedef struct _toporouter_netlist_t _toporouter_netlist_t, *P_toporouter_netlist_t;

typedef struct _toporouter_netlist_t toporouter_netlist_t;

struct _toporouter_serpintine_t {
    GList * arcs;
    gdouble x;
    gdouble y;
    gdouble x0;
    gdouble y0;
    gdouble x1;
    gdouble y1;
    gpointer start;
    gdouble halfa;
    gdouble radius;
    guint nhalfcycles;
};

struct _toporouter_route_t {
    struct _toporouter_netlist_t * netlist;
    struct _toporouter_cluster_t * src;
    struct _toporouter_cluster_t * dest;
    struct _toporouter_cluster_t * psrc;
    struct _toporouter_cluster_t * pdest;
    gdouble score;
    gdouble detourscore;
    toporouter_vertex_t * curpoint;
    GHashTable * alltemppoints;
    GList * path;
    guint flags;
    GList * destvertices;
    GList * srcvertices;
    GList * topopath;
    gdouble pscore;
    GList * ppath;
    gint * ppathindices;
};

struct _toporouter_arc_t {
    GtsObject object;
    gdouble x0;
    gdouble y0;
    gdouble x1;
    gdouble y1;
    toporouter_vertex_t * centre;
    toporouter_vertex_t * v;
    gdouble r;
    gint dir;
    GList * clearance;
    toporouter_oproute_t * oproute;
    toporouter_vertex_t * v1;
    toporouter_vertex_t * v2;
};

struct _toporouter_oproute_t {
    GList * arcs;
    toporouter_vertex_t * term1;
    toporouter_vertex_t * term2;
    char * style;
    char * netlist;
    guint layergroup;
    gdouble tof;
    GList * path;
    toporouter_serpintine_t * serp;
};

struct _toporouter_netlist_t {
    GPtrArray * clusters;
    GPtrArray * routes;
    char * netlist;
    char * style;
    GList * routed;
};

struct _toporouter_edge_t {
    GtsEdge e;
    guint flags;
    GList * routing;
};

struct _toporouter_bbox_t {
    GtsBBox b;
    enum toporouter_term_t type;
    void * data;
    int layer;
    GtsSurface * surface;
    GtsTriangle * enclosing;
    GList * constraints;
    GtsPoint * point;
    GtsPoint * realpoint;
    struct _toporouter_cluster_t * cluster;
};

struct toporouter_heap_search_data_t {
    toporouter_vertex_t * key;
    toporouter_vertex_t * result;
};

struct _toporouter_cluster_t {
    gint c;
    gint pc;
    GPtrArray * boxes;
    toporouter_netlist_t * netlist;
};

struct _toporouter_vertex_t {
    GtsVertex v;
    struct _toporouter_bbox_t * bbox;
    struct _toporouter_vertex_t * parent;
    struct _toporouter_vertex_t * child;
    toporouter_edge_t * routingedge;
    guint flags;
    gdouble gcost;
    gdouble hcost;
    guint gn;
    struct _toporouter_arc_t * arc;
    struct _toporouter_oproute_t * oproute;
    struct _toporouter_route_t * route;
    gdouble thickness;
};

typedef struct line_info line_info, *Pline_info;

struct line_info {
    LocationType X1;
    LocationType X2;
    LocationType Y1;
    LocationType Y2;
    BDimension Thickness;
    struct FlagType Flags;
    struct LineType test;
    struct LineType * ans;
    jmp_buf env;
};

typedef struct _toporouter_vertex_class_t _toporouter_vertex_class_t, *P_toporouter_vertex_class_t;

typedef struct _toporouter_vertex_class_t toporouter_vertex_class_t;

struct _toporouter_vertex_class_t {
    GtsVertexClass parent_class;
};

typedef struct _toporouter_cluster_t toporouter_cluster_t;

typedef struct _toporouter_bbox_t toporouter_bbox_t;

typedef struct _toporouter_constraint_t _toporouter_constraint_t, *P_toporouter_constraint_t;

typedef struct _toporouter_constraint_t toporouter_constraint_t;

struct _toporouter_constraint_t {
    GtsConstraint c;
    toporouter_bbox_t * box;
    GList * routing;
};

typedef struct toporouter_netscore_t toporouter_netscore_t, *Ptoporouter_netscore_t;

typedef struct _toporouter_route_t toporouter_route_t;

typedef struct _toporouter_t _toporouter_t, *P_toporouter_t;

typedef struct _toporouter_t toporouter_t;

typedef struct toporouter_layer_t toporouter_layer_t, *Ptoporouter_layer_t;

struct toporouter_layer_t {
    GtsSurface * surface;
    GList * vertices;
    GList * constraints;
    GList * edges;
};

struct toporouter_netscore_t {
    guint id;
    guint * pairwise_nodetour;
    gdouble pairwise_detour_sum;
    gdouble score;
    guint pairwise_fails;
    toporouter_route_t * routedata;
    toporouter_t * r;
};

struct _toporouter_t {
    GSList * bboxes;
    GNode * bboxtree;
    struct toporouter_layer_t * layers;
    GList * paths;
    GList * keepoutlayers;
    guint flags;
    GList * destboxes;
    GList * consumeddestboxes;
    guint viamax;
    gdouble viacost;
    gdouble stublength;
    gdouble serpintine_half_amplitude;
    gdouble wiring_score;
    GPtrArray * routes;
    GPtrArray * netlists;
    GList * routednets;
    GList * failednets;
    gint (* netsort)(struct toporouter_netscore_t * *, struct toporouter_netscore_t * *);
    struct timeval starttime;
    FILE * debug;
};

typedef struct _toporouter_edge_class_t _toporouter_edge_class_t, *P_toporouter_edge_class_t;

typedef struct _toporouter_edge_class_t toporouter_edge_class_t;

struct _toporouter_edge_class_t {
    GtsEdgeClass parent_class;
};

typedef struct toporouter_spoint_t toporouter_spoint_t, *Ptoporouter_spoint_t;

struct toporouter_spoint_t {
    gdouble x;
    gdouble y;
};

typedef struct _toporouter_bbox_class_t _toporouter_bbox_class_t, *P_toporouter_bbox_class_t;

struct _toporouter_bbox_class_t {
    GtsBBoxClass parent_class;
};

typedef struct _toporouter_constraint_class_t _toporouter_constraint_class_t, *P_toporouter_constraint_class_t;

typedef struct _toporouter_constraint_class_t toporouter_constraint_class_t;

struct _toporouter_constraint_class_t {
    GtsConstraintClass parent_class;
};

typedef struct _toporouter_arc_class_t _toporouter_arc_class_t, *P_toporouter_arc_class_t;

typedef struct _toporouter_arc_class_t toporouter_arc_class_t;

struct _toporouter_arc_class_t {
    GtsObjectClass parent_class;
    gboolean binary;
};

typedef struct _toporouter_rubberband_arc_t _toporouter_rubberband_arc_t, *P_toporouter_rubberband_arc_t;

struct _toporouter_rubberband_arc_t {
    toporouter_vertex_t * pathv;
    toporouter_vertex_t * arcv;
    gdouble r;
    gdouble d;
    gint wind;
    GList * list;
};

typedef struct drawing_context_t drawing_context_t, *Pdrawing_context_t;

struct drawing_context_t {
    double s;
    int mode;
    void * data;
    char * filename;
    double iw;
    double ih;
};

typedef struct toporouter_vertex_region_t toporouter_vertex_region_t, *Ptoporouter_vertex_region_t;

struct toporouter_vertex_region_t {
    GList * points;
    toporouter_vertex_t * v1;
    toporouter_vertex_t * v2;
    toporouter_vertex_t * origin;
};

typedef struct _toporouter_rubberband_arc_t toporouter_rubberband_arc_t;

typedef struct _toporouter_bbox_class_t toporouter_bbox_class_t;

typedef struct _toporouter_arc_t toporouter_arc_t;

typedef struct PendingDrills PendingDrills, *PPendingDrills;

struct PendingDrills {
    int diam;
    int x;
    int y;
};

typedef struct Apertures Apertures, *PApertures;

struct Apertures {
    int some_apertures;
    int aperture_used[2560];
};

typedef enum ApertureShape {
    OCTAGON=1,
    ROUND=0,
    ROUNDCLEAR=3,
    SQUARE=2,
    SQUARECLEAR=4,
    THERMAL=5
} ApertureShape;

typedef uint dbus_uint32_t;

typedef struct _GtkCheckButton _GtkCheckButton, *P_GtkCheckButton;

typedef struct _GtkCheckButton GtkCheckButton;

struct _GtkCheckButton {
    GtkToggleButton toggle_button;
};

typedef struct color_struct.conflict color_struct.conflict, *Pcolor_struct.conflict;

struct color_struct.conflict {
    int c;
    uint r;
    uint g;
    uint b;
    uint a;
};


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef union YYSTYPE.conflict1 YYSTYPE.conflict1, *PYYSTYPE.conflict1;

union YYSTYPE.conflict1 {
    int ival;
    char * sval;
    struct Resource * rval;
};

typedef struct anon_struct anon_struct, *Panon_struct;

struct anon_struct {
    uint status:3;
    uint mark:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

typedef int BOOLp;

typedef struct anon_struct.conflict anon_struct.conflict, *Panon_struct.conflict;

struct anon_struct.conflict {
    uint status:3;
    uint orient:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

typedef enum PolygonBooleanOperation {
    PBO_ISECT=1,
    PBO_SUB=2,
    PBO_UNITE=0,
    PBO_XOR=3
} PolygonBooleanOperation;

typedef struct rubber_info rubber_info, *Prubber_info;

struct rubber_info {
    int radius;
    LocationType X;
    LocationType Y;
    struct LineTypePtr.conflict * line;
    struct BoxType box;
    LayerTypePtr layer;
};

typedef struct rinfo rinfo, *Prinfo;

struct rinfo {
    int type;
    Cardinal group;
    struct PinTypePtr * pin;
    struct PadTypePtr * pad;
    PointTypePtr point;
};

typedef char yytype_int8;

typedef union yyalloc.conflict1 yyalloc.conflict1, *Pyyalloc.conflict1;

union yyalloc.conflict1 {
    yytype_int16 yyss;
    union YYSTYPE.conflict1 yyvs;
};

typedef struct _GtkDialogClass _GtkDialogClass, *P_GtkDialogClass;

struct _GtkDialogClass {
    GtkWindowClass parent_class;
    void (* response)(GtkDialog *, gint);
    void (* close)(GtkDialog *);
    void (* _gtk_reserved1)(void);
    void (* _gtk_reserved2)(void);
    void (* _gtk_reserved3)(void);
    void (* _gtk_reserved4)(void);
};

typedef struct _GtkDialogClass GtkDialogClass;

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct GHidPort GHidPort, *PGHidPort;

typedef struct _GdkCursor _GdkCursor, *P_GdkCursor;

typedef struct _GdkCursor GdkCursor;

struct GHidPort {
    GtkWidget * top_window;
    GtkWidget * drawing_area;
    GdkPixmap * pixmap;
    GdkPixmap * mask;
    GdkDrawable * drawable;
    gint width;
    gint height;
    GdkGC * bg_gc;
    GdkGC * offlimits_gc;
    GdkGC * mask_gc;
    GdkGC * u_gc;
    GdkGC * grid_gc;
    GdkColor bg_color;
    GdkColor offlimits_color;
    GdkColor grid_color;
    GdkColormap * colormap;
    GdkCursor * X_cursor;
    enum GdkCursorType X_cursor_shape;
    gboolean has_entered;
    gboolean panning;
    gdouble zoom;
    gint view_x0;
    gint view_y0;
    gint view_width;
    gint view_height;
    gint view_x;
    gint view_y;
    gint x_crosshair;
    gint y_crosshair;
};

struct _GdkCursor {
    enum GdkCursorType type;
    guint ref_count;
};

typedef struct GhidGui GhidGui, *PGhidGui;

typedef struct _GtkEntry _GtkEntry, *P_GtkEntry;

typedef struct _GtkEntry GtkEntry;

typedef struct _GdkPixbuf _GdkPixbuf, *P_GdkPixbuf;

typedef struct _GdkPixbuf GdkPixbuf;

struct _GdkPixbuf {
};

struct _GtkEntry {
    GtkWidget widget;
    gchar * text;
    guint editable:1;
    guint visible:1;
    guint overwrite_mode:1;
    guint in_drag:1;
    undefined field_0x41;
    guint16 text_length;
    guint16 text_max_length;
    undefined field_0x46;
    undefined field_0x47;
    GdkWindow * text_area;
    GtkIMContext * im_context;
    GtkWidget * popup_menu;
    gint current_pos;
    gint selection_bound;
    PangoLayout * cached_layout;
    guint cache_includes_preedit:1;
    guint need_im_reset:1;
    guint has_frame:1;
    guint activates_default:1;
    guint cursor_visible:1;
    guint in_click:1;
    guint is_cell_renderer:1;
    guint editing_canceled:1;
    guint mouse_cursor_obscured:1;
    guint select_words:1;
    guint select_lines:1;
    guint resolved_dir:4;
    guint truncate_multiline:1;
    undefined field_0x62;
    undefined field_0x63;
    guint button;
    guint blink_timeout;
    guint recompute_idle;
    gint scroll_offset;
    gint ascent;
    gint descent;
    guint16 x_text_size;
    guint16 x_n_bytes;
    guint16 preedit_length;
    guint16 preedit_cursor;
    gint dnd_position;
    gint drag_start_x;
    gint drag_start_y;
    gunichar invisible_char;
    gint width_chars;
};

struct GhidGui {
    GtkUIManager * ui_manager;
    GtkActionGroup * main_actions;
    GtkActionGroup * grid_actions;
    GtkActionGroup * change_selected_actions;
    GtkActionGroup * displayed_name_actions;
    GtkWidget * name_label;
    GtkWidget * status_line_label;
    GtkWidget * cursor_position_relative_label;
    GtkWidget * cursor_position_absolute_label;
    GtkWidget * grid_units_label;
    GtkWidget * status_line_hbox;
    GtkWidget * command_combo_box;
    GtkEntry * command_entry;
    GtkWidget * top_hbox;
    GtkWidget * menu_hbox;
    GtkWidget * compact_vbox;
    GtkWidget * compact_hbox;
    GtkWidget * position_hbox;
    GtkWidget * label_hbox;
    GtkWidget * mode_buttons0_vbox;
    GtkWidget * mode_buttons1_hbox;
    GtkWidget * mode_buttons1_vbox;
    GtkWidget * mode_buttons0_frame;
    GtkWidget * mode_buttons1_frame;
    GtkWidget * mode_buttons0_frame_vbox;
    GtkWidget * h_range;
    GtkWidget * v_range;
    GtkObject * h_adjustment;
    GtkObject * v_adjustment;
    GdkPixbuf * bg_pixbuf;
    gchar * name_label_string;
    gboolean adjustment_changed_holdoff;
    gboolean toggle_holdoff;
    gboolean command_entry_status_line_active;
    gboolean auto_pan_on;
    gboolean in_popup;
    gboolean combine_adjustments;
    gboolean config_modified;
    gboolean small_label_markup;
    gboolean compact_horizontal;
    gboolean compact_vertical;
    gboolean ghid_title_window;
    gboolean use_command_window;
    gboolean need_restore_crosshair;
    gboolean creating;
    gint n_mode_button_columns;
    gint top_window_width;
    gint top_window_height;
    gint log_window_width;
    gint log_window_height;
    gint drc_window_width;
    gint drc_window_height;
    gint keyref_window_width;
    gint keyref_window_height;
    gint library_window_width;
    gint library_window_height;
    gint netlist_window_height;
    gint history_size;
    gint settings_mode;
    gint auto_pan_speed;
};

typedef enum ModifierKeysState {
    CONTROL_MOD1_PRESSED=6,
    CONTROL_PRESSED=2,
    MOD1_PRESSED=4,
    NONE_PRESSED=0,
    SHIFT_CONTROL_MOD1_PRESSED=7,
    SHIFT_CONTROL_PRESSED=3,
    SHIFT_MOD1_PRESSED=5,
    SHIFT_PRESSED=1
} ModifierKeysState;

typedef enum ButtonState {
    BUTTON1_PRESSED=1,
    BUTTON2_PRESSED=2,
    BUTTON3_PRESSED=3,
    NO_BUTTON_PRESSED=0
} ButtonState;

typedef struct ConfigColor ConfigColor, *PConfigColor;

typedef enum ColorTypes {
    LAYER_COLOR=2,
    LAYER_SELECTED_COLOR=3,
    MISC_COLOR=0,
    MISC_SELECTED_COLOR=1
} ColorTypes;

struct ConfigColor {
    struct HID_Attribute * attributes;
    enum ColorTypes type;
    GdkColor color;
    gboolean color_is_mapped;
};

typedef enum ConfigType {
    CONFIG_Boolean=0,
    CONFIG_Integer=1,
    CONFIG_Real=2,
    CONFIG_String=3,
    CONFIG_Unused=4
} ConfigType;

typedef struct ConfigAttribute ConfigAttribute, *PConfigAttribute;

struct ConfigAttribute {
    gchar * name;
    enum ConfigType type;
    void * value;
};

typedef struct DBusMessageIter DBusMessageIter, *PDBusMessageIter;

struct DBusMessageIter {
    void * dummy1;
    void * dummy2;
    dbus_uint32_t dummy3;
    int dummy4;
    int dummy5;
    int dummy6;
    int dummy7;
    int dummy8;
    int dummy9;
    int dummy10;
    int dummy11;
    int pad1;
    int pad2;
    void * pad3;
};

typedef struct _GtkFileChooser _GtkFileChooser, *P_GtkFileChooser;

struct _GtkFileChooser {
};

typedef struct _GtkEditable _GtkEditable, *P_GtkEditable;

struct _GtkEditable {
};

typedef struct _GtkMenu _GtkMenu, *P_GtkMenu;

typedef struct _GtkMenu GtkMenu;

typedef struct _GtkAccelGroup _GtkAccelGroup, *P_GtkAccelGroup;

typedef struct _GtkAccelGroup GtkAccelGroup;

typedef struct _GtkAccelGroupEntry _GtkAccelGroupEntry, *P_GtkAccelGroupEntry;

typedef struct _GtkAccelGroupEntry GtkAccelGroupEntry;

typedef struct _GtkAccelKey _GtkAccelKey, *P_GtkAccelKey;

typedef struct _GtkAccelKey GtkAccelKey;

struct _GtkAccelKey {
    guint accel_key;
    enum GdkModifierType accel_mods;
    guint accel_flags:16;
    undefined field_0xa;
    undefined field_0xb;
};

struct _GtkAccelGroupEntry {
    GtkAccelKey key;
    GClosure * closure;
    GQuark accel_path_quark;
};

struct _GtkMenu {
    GtkMenuShell menu_shell;
    GtkWidget * parent_menu_item;
    GtkWidget * old_active_menu_item;
    GtkAccelGroup * accel_group;
    gchar * accel_path;
    void (* position_func)(GtkMenu *, gint *, gint *, gboolean *, gpointer);
    gpointer position_func_data;
    guint toggle_size;
    GtkWidget * toplevel;
    GtkWidget * tearoff_window;
    GtkWidget * tearoff_hbox;
    GtkWidget * tearoff_scrollbar;
    GtkAdjustment * tearoff_adjustment;
    GdkWindow * view_window;
    GdkWindow * bin_window;
    gint scroll_offset;
    gint saved_scroll_offset;
    gint scroll_step;
    guint timeout_id;
    GdkRegion * navigation_region;
    guint navigation_timeout;
    guint needs_destruction_ref_count:1;
    guint torn_off:1;
    guint tearoff_active:1;
    guint scroll_fast:1;
    guint upper_arrow_visible:1;
    guint lower_arrow_visible:1;
    guint upper_arrow_prelight:1;
    guint lower_arrow_prelight:1;
    undefined field_0xad;
    undefined field_0xae;
    undefined field_0xaf;
};

struct _GtkAccelGroup {
    GObject parent;
    guint lock_count;
    enum GdkModifierType modifier_mask;
    GSList * acceleratables;
    guint n_accels;
    GtkAccelGroupEntry * priv_accels;
};

typedef struct _GtkTreeSortable _GtkTreeSortable, *P_GtkTreeSortable;

struct _GtkTreeSortable {
};

typedef struct gdPoint gdPoint, *PgdPoint;

struct gdPoint {
    int x;
    int y;
};

typedef struct _GtkEditable GtkEditable;

typedef struct _GtkListStore _GtkListStore, *P_GtkListStore;

typedef struct _GtkListStore GtkListStore;

struct _GtkListStore {
    GObject parent;
    gint stamp;
    gpointer seq;
    gpointer _gtk_reserved1;
    GList * sort_list;
    gint n_columns;
    gint sort_column_id;
    enum GtkSortType order;
    GType * column_headers;
    gint length;
    gint (* default_sort_func)(GtkTreeModel *, GtkTreeIter *, GtkTreeIter *, gpointer);
    gpointer default_sort_data;
    GDestroyNotify.conflict default_sort_destroy;
    guint columns_dirty:1;
    undefined field_0x3d;
    undefined field_0x3e;
    undefined field_0x3f;
};

typedef struct _GtkListStore.conflict _GtkListStore.conflict, *P_GtkListStore.conflict;

struct _GtkListStore.conflict {
    GObject parent;
    gint stamp;
    gpointer seq;
    gpointer _gtk_reserved1;
    GList * sort_list;
    gint n_columns;
    gint sort_column_id;
    enum GtkSortType order;
    GType * column_headers;
    gint length;
    gint (* default_sort_func)(GtkTreeModel *, GtkTreeIter *, GtkTreeIter *, gpointer);
    gpointer default_sort_data;
    void (* default_sort_destroy)(gpointer);
    guint columns_dirty:1;
    undefined field_0x3d;
    undefined field_0x3e;
    undefined field_0x3f;
};

typedef struct _GtkListStore.conflict GtkListStore.conflict;

typedef struct _GtkViewport _GtkViewport, *P_GtkViewport;

struct _GtkViewport {
    GtkBin bin;
    enum GtkShadowType shadow_type;
    GdkWindow * view_window;
    GdkWindow * bin_window;
    GtkAdjustment * hadjustment;
    GtkAdjustment * vadjustment;
};

typedef struct _GtkRadioButton _GtkRadioButton, *P_GtkRadioButton;

struct _GtkRadioButton {
    GtkCheckButton check_button;
    GSList * group;
};

typedef struct _GdkPoint _GdkPoint, *P_GdkPoint;

typedef struct _GdkPoint GdkPoint;

struct _GdkPoint {
    gint x;
    gint y;
};

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    int h_addrtype;
    int h_length;
    char * * h_addr_list;
};

typedef struct _GhidLibraryWindowClass _GhidLibraryWindowClass, *P_GhidLibraryWindowClass;

typedef struct _GhidLibraryWindowClass GhidLibraryWindowClass;

struct _GhidLibraryWindowClass {
    GtkDialogClass parent_class;
};

typedef struct _GhidLibraryWindow _GhidLibraryWindow, *P_GhidLibraryWindow;

typedef struct _GhidLibraryWindow GhidLibraryWindow;

struct _GhidLibraryWindow {
    GtkDialog parent_instance;
    GtkWidget * hpaned;
    GtkTreeView * libtreeview;
    GtkNotebook * viewtabs;
    GtkWidget * preview;
    GtkEntry * entry_filter;
    GtkButton * button_clear;
    guint filter_timeout;
};

typedef struct mptlc mptlc, *Pmptlc;

struct mptlc {
    Cardinal snum;
    Cardinal dnum;
    int type;
    PolygonTypePtr polygon;
};

typedef struct via_info via_info, *Pvia_info;

struct via_info {
    LocationType X;
    LocationType Y;
    jmp_buf env;
};

typedef struct pip pip, *Ppip;

struct pip {
    int f;
    Vector p;
    jmp_buf env;
};

typedef struct seg seg, *Pseg;

struct seg {
    struct BoxType box;
    struct VNODE * v;
    struct PLINE * p;
};

typedef struct info info, *Pinfo;

struct info {
    double m;
    double b;
    rtree_t * tree;
    struct VNODE * v;
    struct seg * s;
    jmp_buf env;
    jmp_buf sego;
    jmp_buf * touch;
};

typedef enum DIRECTION {
    BACKW=1,
    FORW=0
} DIRECTION;

typedef struct ModeButton ModeButton, *PModeButton;

struct ModeButton {
    GtkWidget * button;
    GtkWidget * box0;
    GtkWidget * box1;
    gchar * name;
    gint mode;
    gchar * * xpm;
};

typedef struct LayerButtonSet LayerButtonSet, *PLayerButtonSet;

struct LayerButtonSet {
    GtkWidget * radio_select_button;
    GtkWidget * layer_enable_button;
    GtkWidget * layer_enable_ebox;
    GtkWidget * label;
    gchar * text;
    gint index;
};

typedef struct RouteStyleButton RouteStyleButton, *PRouteStyleButton;

struct RouteStyleButton {
    GtkWidget * button;
    struct RouteStyleType route_style;
    gboolean shown;
};

typedef struct KeyTable KeyTable, *PKeyTable;

struct KeyTable {
    char in;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    char * out;
};

typedef struct ToggleFlagType ToggleFlagType, *PToggleFlagType;

typedef enum MenuFlagType {
    GHID_FLAG_ACTIVE=0,
    GHID_FLAG_CHECKED=1,
    GHID_FLAG_VISIBLE=2
} MenuFlagType;

struct ToggleFlagType {
    char * actionname;
    char * flagname;
    enum MenuFlagType flagtype;
    int oldval;
    char * xres;
};


// WARNING! conflicting data type names: /DWARF/gui-top-window.c/add_resource_to_menu/lexical_block_0/anon_enum_32 - /DWARF/report.c/ReportAllNetLengths/anon_enum_32

typedef struct SegmentTree SegmentTree, *PSegmentTree;

typedef struct SegmentTreeNode SegmentTreeNode, *PSegmentTreeNode;

struct SegmentTree {
    struct SegmentTreeNode * nodes;
    int size;
};

struct SegmentTreeNode {
    LocationType left;
    LocationType right;
    int covered;
    int area;
};

typedef struct LocationList LocationList, *PLocationList;

struct LocationList {
    LocationType * p;
    int size;
};

typedef enum FunctionID {
    F_AddSelected=0,
    F_All=1,
    F_AllConnections=2,
    F_AllRats=3,
    F_AllUnusedPins=4,
    F_Arc=5,
    F_Arrow=6,
    F_Block=7,
    F_Cancel=9,
    F_Center=10,
    F_Clear=11,
    F_ClearAndRedraw=12,
    F_ClearList=13,
    F_Close=14,
    F_Connection=15,
    F_Convert=16,
    F_Copy=17,
    F_CycleClip=18,
    F_CycleCrosshair=19,
    F_DeleteRats=20,
    F_Description=8,
    F_Drag=21,
    F_DrillReport=22,
    F_Element=23,
    F_ElementByName=24,
    F_ElementConnections=25,
    F_ElementToBuffer=26,
    F_Escape=27,
    F_Find=28,
    F_FlipElement=29,
    F_FoundPins=30,
    F_Grid=31,
    F_InsertPoint=32,
    F_Layer=33,
    F_Layout=34,
    F_LayoutAs=35,
    F_LayoutToBuffer=36,
    F_Line=37,
    F_LineSize=38,
    F_Lock=39,
    F_Mirror=40,
    F_Move=41,
    F_NameOnPCB=42,
    F_Netlist=43,
    F_None=44,
    F_Notify=45,
    F_Object=46,
    F_ObjectByName=47,
    F_PadByName=49,
    F_PasteBuffer=48,
    F_PinByName=50,
    F_PinOrPadName=51,
    F_Pinout=52,
    F_Polygon=53,
    F_PreviousPoint=54,
    F_RatsNest=55,
    F_Rectangle=56,
    F_Redraw=57,
    F_Release=58,
    F_Remove=60,
    F_RemoveSelected=61,
    F_Report=62,
    F_Reset=63,
    F_ResetLinesAndPolygons=64,
    F_ResetPinsViasAndPads=65,
    F_Restore=66,
    F_Revert=59,
    F_Rotate=67,
    F_Save=68,
    F_Scroll=69,
    F_Selected=70,
    F_SelectedArcs=71,
    F_SelectedElements=72,
    F_SelectedLines=73,
    F_SelectedNames=74,
    F_SelectedObjects=75,
    F_SelectedPads=76,
    F_SelectedPins=77,
    F_SelectedRats=80,
    F_SelectedTexts=78,
    F_SelectedVias=79,
    F_Stroke=81,
    F_Text=82,
    F_TextByName=83,
    F_TextScale=84,
    F_Thermal=85,
    F_ToLayout=86,
    F_ToggleAllDirections=87,
    F_ToggleAutoDRC=88,
    F_ToggleCheckPlanes=107,
    F_ToggleClearLine=89,
    F_ToggleFullPoly=90,
    F_ToggleGrid=91,
    F_ToggleHideNames=92,
    F_ToggleLiveRoute=97,
    F_ToggleLocalRef=106,
    F_ToggleLockNames=102,
    F_ToggleMask=93,
    F_ToggleName=94,
    F_ToggleObject=95,
    F_ToggleOnlyNames=103,
    F_ToggleOrthoMove=105,
    F_ToggleRubberBandMode=98,
    F_ToggleShowDRC=96,
    F_ToggleSnapPin=100,
    F_ToggleStartDirection=99,
    F_ToggleThindraw=101,
    F_ToggleThindrawPoly=104,
    F_ToggleUniqueNames=108,
    F_Value=111,
    F_Via=109,
    F_ViaByName=110,
    F_ViaDrillingHole=112,
    F_ViaSize=113,
    F_Zoom=114
} FunctionID;

typedef struct anon_struct.conflict10 anon_struct.conflict10, *Panon_struct.conflict10;

struct anon_struct.conflict10 {
    PolygonTypePtr poly;
    struct LineType line;
};

typedef struct anon_struct.conflict11 anon_struct.conflict11, *Panon_struct.conflict11;

struct anon_struct.conflict11 {
    int X;
    int Y;
    Cardinal Buffer;
    Boolean Click;
    Boolean Moving;
    undefined field_0xe;
    undefined field_0xf;
    int Hit;
    void * ptr1;
    void * ptr2;
    void * ptr3;
};

typedef struct FunctionType FunctionType, *PFunctionType;

struct FunctionType {
    char * Identifier;
    enum FunctionID ID;
};

typedef struct _cnt_list _cnt_list, *P_cnt_list;

struct _cnt_list {
    char * name;
    uint cnt;
};

typedef union anon_union.conflict4 anon_union.conflict4, *Panon_union.conflict4;

union anon_union.conflict4 {
    char b[20];
    short s[10];
    long l[5];
};

typedef struct centroid centroid, *Pcentroid;

struct centroid {
    float x;
    float y;
    float area;
};

typedef struct anon_struct.conflict42 anon_struct.conflict42, *Panon_struct.conflict42;

struct anon_struct.conflict42 {
    uint is_leaf:1;
    uint manage:31;
};

typedef struct r_arg r_arg, *Pr_arg;

struct r_arg {
    int (* check_it)(struct BoxType *, void *);
    int (* found_it)(struct BoxType *, void *);
    void * closure;
};

typedef union anon_union.conflict1 anon_union.conflict1, *Panon_union.conflict1;

union anon_union.conflict1 {
    struct rtree_node * kids[7];
    struct Rentry rects[7];
};

typedef struct _GtkSpinButton _GtkSpinButton, *P_GtkSpinButton;

typedef enum GtkSpinButtonUpdatePolicy {
    GTK_UPDATE_ALWAYS=0,
    GTK_UPDATE_IF_VALID=1
} GtkSpinButtonUpdatePolicy;

struct _GtkSpinButton {
    GtkEntry entry;
    GtkAdjustment * adjustment;
    GdkWindow * panel;
    guint32 timer;
    gdouble climb_rate;
    gdouble timer_step;
    enum GtkSpinButtonUpdatePolicy update_policy;
    guint in_child:2;
    guint click_child:2;
    guint button:2;
    guint need_timer:1;
    guint timer_calls:3;
    guint digits:10;
    guint numeric:1;
    guint wrap:1;
    guint snap_to_ticks:1;
    undefined field_0xbb;
};

typedef struct _GtkSpinButton GtkSpinButton;

typedef dbus_uint32_t dbus_bool_t;


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval

typedef struct timezone timezone, *Ptimezone;

typedef struct timezone * __timezone_ptr_t;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};


// WARNING! conflicting data type names: /pthread.h/__jmp_buf_tag - /DWARF/setjmp.h/__jmp_buf_tag


// WARNING! conflicting data type names: /stdio.h/FILE - /DWARF/stdio.h/FILE

typedef int __pid_t;

typedef int __int32_t;


// WARNING! conflicting data type names: /bio.h/hostent - /DWARF/netdb.h/hostent


// WARNING! conflicting data type names: /pwd.h/passwd - /DWARF/pwd.h/passwd

typedef void (* __sighandler_t)(int);

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;


// WARNING! conflicting data type names: /sigset.h/__sigset_t - /DWARF/sigset.h/__sigset_t


// WARNING! conflicting data type names: /dirent.h/__dirstream - /DWARF/_UNCATEGORIZED_/__dirstream


// WARNING! conflicting data type names: /dirent.h/DIR - /DWARF/dirent.h/DIR


// WARNING! conflicting data type names: /dirent.h/dirent - /DWARF/dirent.h/dirent


// WARNING! conflicting data type names: /regex.h/re_pattern_buffer - /DWARF/regex.h/re_pattern_buffer


// WARNING! conflicting data type names: /regex.h/regmatch_t - /DWARF/regex.h/regmatch_t


// WARNING! conflicting data type names: /regex.h/regex_t - /DWARF/regex.h/regex_t

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_CHECKSUM=1879048184,
    SHT_DYNAMIC=6,
    SHT_DYNSYM=11,
    SHT_FINI_ARRAY=15,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191,
    SHT_GROUP=17,
    SHT_HASH=5,
    SHT_INIT_ARRAY=14,
    SHT_NOBITS=8,
    SHT_NOTE=7,
    SHT_NULL=0,
    SHT_PREINIT_ARRAY=16,
    SHT_PROGBITS=1,
    SHT_REL=9,
    SHT_RELA=4,
    SHT_SHLIB=10,
    SHT_STRTAB=3,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_syminfo=1879048188,
    SHT_SYMTAB=2,
    SHT_SYMTAB_SHNDX=18
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_AUDIT=1879047932,
    DT_AUXILIARY=2147483645,
    DT_BIND_NOW=24,
    DT_CHECKSUM=1879047672,
    DT_CONFIG=1879047930,
    DT_DEBUG=21,
    DT_DEPAUDIT=1879047931,
    DT_ENCODING=32,
    DT_FEATURE_1=1879047676,
    DT_FILTER=2147483647,
    DT_FINI=13,
    DT_FINI_ARRAY=26,
    DT_FINI_ARRAYSZ=28,
    DT_FLAGS=30,
    DT_FLAGS_1=1879048187,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_HASH=1879047925,
    DT_GNU_LIBLIST=1879047929,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_GNU_PRELINKED=1879047669,
    DT_HASH=4,
    DT_INIT=12,
    DT_INIT_ARRAY=25,
    DT_INIT_ARRAYSZ=27,
    DT_JMPREL=23,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_MOVETAB=1879047934,
    DT_NEEDED=1,
    DT_NULL=0,
    DT_PLTGOT=3,
    DT_PLTPAD=1879047933,
    DT_PLTPADSZ=1879047673,
    DT_PLTREL=20,
    DT_PLTRELSZ=2,
    DT_POSFLAG_1=1879047677,
    DT_PREINIT_ARRAYSZ=33,
    DT_REL=17,
    DT_RELA=7,
    DT_RELACOUNT=1879048185,
    DT_RELAENT=9,
    DT_RELASZ=8,
    DT_RELCOUNT=1879048186,
    DT_RELENT=19,
    DT_RELSZ=18,
    DT_RPATH=15,
    DT_RUNPATH=29,
    DT_SONAME=14,
    DT_STRSZ=10,
    DT_STRTAB=5,
    DT_SYMBOLIC=16,
    DT_SYMENT=11,
    DT_SYMINENT=1879047679,
    DT_SYMINFO=1879047935,
    DT_SYMINSZ=1879047678,
    DT_SYMTAB=6,
    DT_TEXTREL=22,
    DT_TLSDESC_GOT=1879047927,
    DT_TLSDESC_PLT=1879047926,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_VERSYM=1879048176
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_DYNAMIC=2,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_RELRO=1685382482,
    PT_GNU_STACK=1685382481,
    PT_INTERP=3,
    PT_LOAD=1,
    PT_NOTE=4,
    PT_NULL=0,
    PT_PHDR=6,
    PT_SHLIB=5,
    PT_TLS=7
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_pad[9];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iStack12;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return iStack12;
}



void g_param_spec_object(void)

{
  g_param_spec_object();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void g_utf8_validate(void)

{
  g_utf8_validate();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



void gtk_tree_view_get_model(void)

{
  gtk_tree_view_get_model();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



void g_free(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gdk_window_invalidate_rect(void)

{
  gdk_window_invalidate_rect();
  return;
}



void gtk_tree_view_column_set_attributes(void)

{
  gtk_tree_view_column_set_attributes();
  return;
}



void gdk_color_parse(void)

{
  gdk_color_parse();
  return;
}



void gtk_tree_row_reference_free(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_get_current_event_time(void)

{
  gtk_get_current_event_time();
  return;
}



void gtk_label_set_use_markup(void)

{
  gtk_label_set_use_markup();
  return;
}



void gdImageFillToBorder(void)

{
  gdImageFillToBorder();
  return;
}



void g_slist_remove(void)

{
  g_slist_remove();
  return;
}



void gdk_draw_polygon(void)

{
  gdk_draw_polygon();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



void g_value_unset(void)

{
  g_value_unset();
  return;
}



void gtk_text_view_get_type(void)

{
  gtk_text_view_get_type();
  return;
}



void gtk_tree_selection_select_path(void)

{
  gtk_tree_selection_select_path();
  return;
}



void g_io_channel_shutdown(void)

{
  g_io_channel_shutdown();
  return;
}



void g_path_get_dirname(void)

{
  g_path_get_dirname();
  return;
}



void gtk_tree_model_get_iter_first(void)

{
  gtk_tree_model_get_iter_first();
  return;
}



void gtk_table_attach_defaults(void)

{
  gtk_table_attach_defaults();
  return;
}



void gtk_entry_new(void)

{
  gtk_entry_new();
  return;
}



void g_param_spec_string(void)

{
  g_param_spec_string();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



void g_list_find(void)

{
  g_list_find();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



void dbus_connection_unref(void)

{
  dbus_connection_unref();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void setbuf(FILE *__stream,char *__buf)

{
  setbuf(__stream,__buf);
  return;
}



void __cxa_atexit(void)

{
  __cxa_atexit();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void regfree(regex_t *__preg)

{
  regfree(__preg);
  return;
}



void gtk_vbox_get_type(void)

{
  gtk_vbox_get_type();
  return;
}



void gtk_dialog_set_default_response(void)

{
  gtk_dialog_set_default_response();
  return;
}



void gtk_bin_get_child(void)

{
  gtk_bin_get_child();
  return;
}



void gdk_display_get_default(void)

{
  gdk_display_get_default();
  return;
}



void gtk_box_get_type(void)

{
  gtk_box_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



void g_direct_equal(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_scale_set_digits(void)

{
  gtk_scale_set_digits();
  return;
}



void gtk_window_new(void)

{
  gtk_window_new();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double asin(double __x)

{
  float10 extraout_ST0;
  
  asin(__x);
  return (double)extraout_ST0;
}



void gdImageDestroy(void)

{
  gdImageDestroy();
  return;
}



void gdk_pixbuf_get_height(void)

{
  gdk_pixbuf_get_height();
  return;
}



void g_slist_free(void)

{
  g_slist_free();
  return;
}



void __longjmp_chk(void)

{
                    // WARNING: Subroutine does not return
  __longjmp_chk();
}



// WARNING: Unknown calling convention yet parameter storage is locked

long random(void)

{
  long lVar1;
  
  lVar1 = random();
  return lVar1;
}



void g_value_dup_string(void)

{
  g_value_dup_string();
  return;
}



void gtk_scale_get_type(void)

{
  gtk_scale_get_type();
  return;
}



void g_hash_table_destroy(void)

{
  g_hash_table_destroy();
  return;
}



void g_str_hash(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_color_button_set_title(void)

{
  gtk_color_button_set_title();
  return;
}



void g_path_get_basename(void)

{
  g_path_get_basename();
  return;
}



void gtk_tree_view_expand_row(void)

{
  gtk_tree_view_expand_row();
  return;
}



void gdk_gc_copy(void)

{
  gdk_gc_copy();
  return;
}



void g_main_loop_quit(void)

{
  g_main_loop_quit();
  return;
}



void g_io_channel_unix_new(void)

{
  g_io_channel_unix_new();
  return;
}



void gtk_window_get_position(void)

{
  gtk_window_get_position();
  return;
}



void gdk_pixbuf_new_from_file(void)

{
  gdk_pixbuf_new_from_file();
  return;
}



void gtk_tree_sortable_get_type(void)

{
  gtk_tree_sortable_get_type();
  return;
}



void __fprintf_chk(void)

{
  __fprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

float sqrtf(float __x)

{
  float10 extraout_ST0;
  
  sqrtf(__x);
  return (float)extraout_ST0;
}



void gtk_toggle_button_get_active(void)

{
  gtk_toggle_button_get_active();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat(__ver,__filename,__stat_buf);
  return iVar1;
}



void gtk_cell_renderer_text_new(void)

{
  gtk_cell_renderer_text_new();
  return;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



void gtk_tooltips_new(void)

{
  gtk_tooltips_new();
  return;
}



void gtk_button_box_get_type(void)

{
  gtk_button_box_get_type();
  return;
}



void g_object_unref(void)

{
  g_object_unref();
  return;
}



void gtk_label_new(void)

{
  gtk_label_new();
  return;
}



void gtk_dialog_response(void)

{
  gtk_dialog_response();
  return;
}



void gtk_table_get_type(void)

{
  gtk_table_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



void g_slist_reverse(void)

{
  g_slist_reverse();
  return;
}



void gtk_window_remove_accel_group(void)

{
  gtk_window_remove_accel_group();
  return;
}



void gtk_file_filter_add_mime_type(void)

{
  gtk_file_filter_add_mime_type();
  return;
}



void gtk_signal_connect_full(void)

{
  gtk_signal_connect_full();
  return;
}



void gtk_vbox_new(void)

{
  gtk_vbox_new();
  return;
}



void gtk_range_set_increments(void)

{
  gtk_range_set_increments();
  return;
}



void __isoc99_sscanf(void)

{
  __isoc99_sscanf();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



void g_strdup(void)

{
  g_strdup();
  return;
}



void gdk_drawable_get_depth(void)

{
  gdk_drawable_get_depth();
  return;
}



void dbus_shutdown(void)

{
  dbus_shutdown();
  return;
}



void gtk_entry_set_text(void)

{
  gtk_entry_set_text();
  return;
}



void g_value_set_boolean(void)

{
  g_value_set_boolean();
  return;
}



void gtk_combo_box_new_text(void)

{
  gtk_combo_box_new_text();
  return;
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



void gtk_tree_view_insert_column_with_attributes(void)

{
  gtk_tree_view_insert_column_with_attributes();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __isinf(double __value)

{
  int iVar1;
  
  iVar1 = __isinf(__value);
  return iVar1;
}



void gtk_ui_manager_new(void)

{
  gtk_ui_manager_new();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  float10 extraout_ST0;
  
  strtod(__nptr,__endptr);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



void dbus_message_new_method_return(void)

{
  dbus_message_new_method_return();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



void gtk_main(void)

{
  gtk_main();
  return;
}



void g_value_get_double(void)

{
  g_value_get_double();
  return;
}



void dbus_error_init(void)

{
  dbus_error_init();
  return;
}



void gdk_gc_set_function(void)

{
  gdk_gc_set_function();
  return;
}



void gtk_widget_get_type(void)

{
  gtk_widget_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



void gdk_drawable_get_type(void)

{
  gdk_drawable_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



void gtk_widget_modify_fg(void)

{
  gtk_widget_modify_fg();
  return;
}



void gtk_widget_destroy(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_button_new(void)

{
  gtk_button_new();
  return;
}



void dbus_watch_set_data(void)

{
  dbus_watch_set_data();
  return;
}



void dbus_watch_get_enabled(void)

{
  dbus_watch_get_enabled();
  return;
}



void g_list_foreach(void)

{
  g_list_foreach();
  return;
}



void g_hash_table_insert(void)

{
  g_hash_table_insert();
  return;
}



void g_list_free(void)

{
  g_list_free();
  return;
}



void gtk_image_new_from_stock(void)

{
  gtk_image_new_from_stock();
  return;
}



void gtk_combo_box_entry_new_text(void)

{
  gtk_combo_box_entry_new_text();
  return;
}



void g_ptr_array_remove_index(void)

{
  g_ptr_array_remove_index();
  return;
}



void gdk_flush(void)

{
  gdk_flush();
  return;
}



void g_strconcat(void)

{
  g_strconcat();
  return;
}



void gdk_cursor_new_from_pixmap(void)

{
  gdk_cursor_new_from_pixmap();
  return;
}



void gtk_ui_manager_insert_action_group(void)

{
  gtk_ui_manager_insert_action_group();
  return;
}



void dbus_watch_get_unix_fd(void)

{
  dbus_watch_get_unix_fd();
  return;
}



void dbus_bus_release_name(void)

{
  dbus_bus_release_name();
  return;
}



void gtk_label_set_justify(void)

{
  gtk_label_set_justify();
  return;
}



void g_node_prepend(void)

{
  g_node_prepend();
  return;
}



void gtk_tree_sortable_set_sort_column_id(void)

{
  gtk_tree_sortable_set_sort_column_id();
  return;
}



void gtk_notebook_get_nth_page(void)

{
  gtk_notebook_get_nth_page();
  return;
}



void gtk_file_chooser_get_type(void)

{
  gtk_file_chooser_get_type();
  return;
}



void gtk_toggle_action_set_active(void)

{
  gtk_toggle_action_set_active();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



void g_hash_table_find(void)

{
  g_hash_table_find();
  return;
}



void dbus_bus_get_private(void)

{
  dbus_bus_get_private();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int regexec(regex_t *__preg,char *__string,size_t __nmatch,regmatch_t *__pmatch,int __eflags)

{
  int iVar1;
  
  iVar1 = regexec(__preg,__string,__nmatch,__pmatch,__eflags);
  return iVar1;
}



void gtk_notebook_new(void)

{
  gtk_notebook_new();
  return;
}



void dbus_error_is_set(void)

{
  dbus_error_is_set();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



void gdk_cursor_new(void)

{
  gdk_cursor_new();
  return;
}



void dbus_watch_get_flags(void)

{
  dbus_watch_get_flags();
  return;
}



void dbus_connection_send(void)

{
  dbus_connection_send();
  return;
}



void gtk_file_filter_new(void)

{
  gtk_file_filter_new();
  return;
}



void gtk_dialog_get_type(void)

{
  gtk_dialog_get_type();
  return;
}



void gdk_colormap_free_colors(void)

{
  gdk_colormap_free_colors();
  return;
}



void gtk_scrolled_window_set_policy(void)

{
  gtk_scrolled_window_set_policy();
  return;
}



void dbus_connection_flush(void)

{
  dbus_connection_flush();
  return;
}



void gdk_draw_arc(void)

{
  gdk_draw_arc();
  return;
}



void gtk_tree_view_column_get_type(void)

{
  gtk_tree_view_column_get_type();
  return;
}



void g_object_class_install_property(void)

{
  g_object_class_install_property();
  return;
}



void gtk_hscrollbar_new(void)

{
  gtk_hscrollbar_new();
  return;
}



void gtk_text_buffer_create_tag(void)

{
  gtk_text_buffer_create_tag();
  return;
}



void gtk_editable_get_chars(void)

{
  gtk_editable_get_chars();
  return;
}



void gtk_widget_modify_bg(void)

{
  gtk_widget_modify_bg();
  return;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



void gtk_tree_store_new(void)

{
  gtk_tree_store_new();
  return;
}



void gtk_table_new(void)

{
  gtk_table_new();
  return;
}



void g_ptr_array_foreach(void)

{
  g_ptr_array_foreach();
  return;
}



void gdImageGif(void)

{
  gdImageGif();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



void g_malloc(void)

{
  g_malloc();
  return;
}



void gtk_dialog_new_with_buttons(void)

{
  gtk_dialog_new_with_buttons();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double floor(double __x)

{
  float10 extraout_ST0;
  
  floor(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * stpcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = stpcpy(__dest,__src);
  return pcVar1;
}



void gdk_cursor_unref(void)

{
  gdk_cursor_unref();
  return;
}



void gdImageFilledEllipse(void)

{
  gdImageFilledEllipse();
  return;
}



void gtk_timeout_add(void)

{
  gtk_timeout_add();
  return;
}



void gtk_menu_get_type(void)

{
  gtk_menu_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



void dbus_message_unref(void)

{
  dbus_message_unref();
  return;
}



void g_string_new(void)

{
  g_string_new();
  return;
}



void gtk_notebook_append_page(void)

{
  gtk_notebook_append_page();
  return;
}



void g_hash_table_remove(void)

{
  g_hash_table_remove();
  return;
}



void gtk_file_chooser_get_current_folder(void)

{
  gtk_file_chooser_get_current_folder();
  return;
}



void gtk_message_dialog_new(void)

{
  gtk_message_dialog_new();
  return;
}



void gtk_file_chooser_set_current_folder(void)

{
  gtk_file_chooser_set_current_folder();
  return;
}



void gtk_viewport_new(void)

{
  gtk_viewport_new();
  return;
}



void gtk_spin_button_get_value_as_int(void)

{
  gtk_spin_button_get_value_as_int();
  return;
}



void g_list_copy(void)

{
  g_list_copy();
  return;
}



void bindtextdomain(void)

{
  bindtextdomain();
  return;
}



void dbus_bus_request_name(void)

{
  dbus_bus_request_name();
  return;
}



void gtk_entry_get_text(void)

{
  gtk_entry_get_text();
  return;
}



void gdk_pixbuf_render_to_drawable(void)

{
  gdk_pixbuf_render_to_drawable();
  return;
}



void gtk_message_dialog_set_markup(void)

{
  gtk_message_dialog_set_markup();
  return;
}



void gtk_frame_new(void)

{
  gtk_frame_new();
  return;
}



void gdk_display_get_default_screen(void)

{
  gdk_display_get_default_screen();
  return;
}



void __vsnprintf_chk(void)

{
  __vsnprintf_chk();
  return;
}



void gtk_tree_model_filter_set_visible_func(void)

{
  gtk_tree_model_filter_set_visible_func();
  return;
}



void g_source_new(void)

{
  g_source_new();
  return;
}



void gtk_widget_get_colormap(void)

{
  gtk_widget_get_colormap();
  return;
}



void g_main_loop_new(void)

{
  g_main_loop_new();
  return;
}



void gtk_list_store_clear(void)

{
  gtk_list_store_clear();
  return;
}



void gdk_color_white(void)

{
  gdk_color_white();
  return;
}



void g_param_spec_int(void)

{
  g_param_spec_int();
  return;
}



void gdImageArc(void)

{
  gdImageArc();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void perror(char *__s)

{
  perror(__s);
  return;
}



void gtk_text_view_set_editable(void)

{
  gtk_text_view_set_editable();
  return;
}



void g_io_channel_read_line(void)

{
  g_io_channel_read_line();
  return;
}



void gdk_bitmap_create_from_data(void)

{
  gdk_bitmap_create_from_data();
  return;
}



void __strcat_chk(void)

{
  __strcat_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double exp(double __x)

{
  float10 extraout_ST0;
  
  exp(__x);
  return (double)extraout_ST0;
}



void g_strv_length(void)

{
  g_strv_length();
  return;
}



void gtk_box_pack_start_defaults(void)

{
  gtk_box_pack_start_defaults();
  return;
}



void gdImageLine(void)

{
  gdImageLine();
  return;
}



void dbus_connection_set_dispatch_status_function(void)

{
  dbus_connection_set_dispatch_status_function();
  return;
}



void gdk_color_alloc(void)

{
  gdk_color_alloc();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

dirent * readdir(DIR *__dirp)

{
  dirent *pdVar1;
  
  pdVar1 = readdir(__dirp);
  return pdVar1;
}



void gtk_text_view_new(void)

{
  gtk_text_view_new();
  return;
}



void g_ptr_array_add(void)

{
  g_ptr_array_add();
  return;
}



void gtk_combo_box_get_type(void)

{
  gtk_combo_box_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



void gdk_gc_new(void)

{
  gdk_gc_new();
  return;
}



void gtk_text_buffer_insert(void)

{
  gtk_text_buffer_insert();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



void g_malloc0_n(void)

{
  g_malloc0_n();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__int32_t ** __ctype_toupper_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_toupper_loc();
  return pp_Var1;
}



void gtk_widget_show_all(void)

{
  gtk_widget_show_all();
  return;
}



void gtk_tree_model_filter_get_type(void)

{
  gtk_tree_model_filter_get_type();
  return;
}



void gtk_range_get_type(void)

{
  gtk_range_get_type();
  return;
}



void gtk_widget_set_sensitive(void)

{
  gtk_widget_set_sensitive();
  return;
}



void gtk_frame_set_shadow_type(void)

{
  gtk_frame_set_shadow_type();
  return;
}



void gtk_action_group_add_actions(void)

{
  gtk_action_group_add_actions();
  return;
}



void gtk_tree_view_scroll_to_cell(void)

{
  gtk_tree_view_scroll_to_cell();
  return;
}



void g_assertion_message_expr(void)

{
                    // WARNING: Subroutine does not return
  g_assertion_message_expr();
}



void gtk_tree_view_new_with_model(void)

{
  gtk_tree_view_new_with_model();
  return;
}



void gtk_viewport_get_type(void)

{
  gtk_viewport_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void free(void *__ptr)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void g_object_new(void)

{
  g_object_new();
  return;
}



void gtk_container_get_type(void)

{
  gtk_container_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double atan(double __x)

{
  float10 extraout_ST0;
  
  atan(__x);
  return (double)extraout_ST0;
}



void g_list_length(void)

{
  g_list_length();
  return;
}



void g_object_ref(void)

{
  g_object_ref();
  return;
}



void g_slist_append(void)

{
  g_slist_append();
  return;
}



void gtk_tree_model_iter_has_child(void)

{
  gtk_tree_model_iter_has_child();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int scanf(char *__format,...)

{
  int iVar1;
  
  iVar1 = scanf(__format);
  return iVar1;
}



void gtk_action_group_set_translation_domain(void)

{
  gtk_action_group_set_translation_domain();
  return;
}



void dcgettext(void)

{
  dcgettext();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int access(char *__name,int __type)

{
  int iVar1;
  
  iVar1 = access(__name,__type);
  return iVar1;
}



void gdk_display_warp_pointer(void)

{
  gdk_display_warp_pointer();
  return;
}



void gdk_pixbuf_get_width(void)

{
  gdk_pixbuf_get_width();
  return;
}



void g_strdup_printf(void)

{
  g_strdup_printf();
  return;
}



void gtk_tree_view_new(void)

{
  gtk_tree_view_new();
  return;
}



void dlsym(void)

{
  dlsym();
  return;
}



void gdk_pixbuf_scale_simple(void)

{
  gdk_pixbuf_scale_simple();
  return;
}



void gtk_tree_view_expand_all(void)

{
  gtk_tree_view_expand_all();
  return;
}



void g_value_set_string(void)

{
  g_value_set_string();
  return;
}



void gtk_tree_view_append_column(void)

{
  gtk_tree_view_append_column();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



void g_string_free(void)

{
  g_string_free();
  return;
}



void gtk_set_locale(void)

{
  gtk_set_locale();
  return;
}



void gdk_draw_points(void)

{
  gdk_draw_points();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double sqrt(double __x)

{
  float10 extraout_ST0;
  
  sqrt(__x);
  return (double)extraout_ST0;
}



void gtk_events_pending(void)

{
  gtk_events_pending();
  return;
}



void __vfprintf_chk(void)

{
  __vfprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int regcomp(regex_t *__preg,char *__pattern,int __cflags)

{
  int iVar1;
  
  iVar1 = regcomp(__preg,__pattern,__cflags);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



void g_type_check_class_cast(void)

{
  g_type_check_class_cast();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



void g_ptr_array_free(void)

{
  g_ptr_array_free();
  return;
}



void g_hash_table_size(void)

{
  g_hash_table_size();
  return;
}



void g_hash_table_new(void)

{
  g_hash_table_new();
  return;
}



void g_node_depth(void)

{
  g_node_depth();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



void gtk_window_set_title(void)

{
  gtk_window_set_title();
  return;
}



void gtk_window_set_default_size(void)

{
  gtk_window_set_default_size();
  return;
}



void g_hash_table_new_full(void)

{
  g_hash_table_new_full();
  return;
}



void __vsprintf_chk(void)

{
  __vsprintf_chk();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



void gtk_adjustment_get_type(void)

{
  gtk_adjustment_get_type();
  return;
}



void gdk_gc_set_line_attributes(void)

{
  gdk_gc_set_line_attributes();
  return;
}



void g_param_spec_pointer(void)

{
  g_param_spec_pointer();
  return;
}



void gtk_combo_box_set_active(void)

{
  gtk_combo_box_set_active();
  return;
}



void gdk_window_get_pointer(void)

{
  gdk_window_get_pointer();
  return;
}



void gtk_paned_pack2(void)

{
  gtk_paned_pack2();
  return;
}



void gtk_widget_set_events(void)

{
  gtk_widget_set_events();
  return;
}



void gtk_ui_manager_get_accel_group(void)

{
  gtk_ui_manager_get_accel_group();
  return;
}



void gtk_tree_view_collapse_row(void)

{
  gtk_tree_view_collapse_row();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _setjmp(__jmp_buf_tag *__env)

{
  int iVar1;
  
  iVar1 = _setjmp(__env);
  return iVar1;
}



void gdk_draw_rectangle(void)

{
  gdk_draw_rectangle();
  return;
}



void gtk_editable_get_type(void)

{
  gtk_editable_get_type();
  return;
}



void gtk_window_get_type(void)

{
  gtk_window_get_type();
  return;
}



void g_hash_table_foreach(void)

{
  g_hash_table_foreach();
  return;
}



void gdk_window_set_back_pixmap(void)

{
  gdk_window_set_back_pixmap();
  return;
}



void gtk_window_move(void)

{
  gtk_window_move();
  return;
}



void gtk_file_chooser_set_current_name(void)

{
  gtk_file_chooser_set_current_name();
  return;
}



void gtk_combo_box_remove_text(void)

{
  gtk_combo_box_remove_text();
  return;
}



void gtk_dialog_add_buttons(void)

{
  gtk_dialog_add_buttons();
  return;
}



void g_slist_prepend(void)

{
  g_slist_prepend();
  return;
}



void gtk_text_buffer_get_end_iter(void)

{
  gtk_text_buffer_get_end_iter();
  return;
}



void gtk_file_chooser_add_shortcut_folder(void)

{
  gtk_file_chooser_add_shortcut_folder();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double acos(double __x)

{
  float10 extraout_ST0;
  
  acos(__x);
  return (double)extraout_ST0;
}



void gtk_hbox_get_type(void)

{
  gtk_hbox_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



void g_io_add_watch(void)

{
  g_io_add_watch();
  return;
}



void gtk_action_get_name(void)

{
  gtk_action_get_name();
  return;
}



void gdk_draw_drawable(void)

{
  gdk_draw_drawable();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void gtk_tree_view_insert_column(void)

{
  gtk_tree_view_insert_column();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



void g_strdup_vprintf(void)

{
  g_strdup_vprintf();
  return;
}



void gtk_signal_emit_by_name(void)

{
  gtk_signal_emit_by_name();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double cos(double __x)

{
  float10 extraout_ST0;
  
  cos(__x);
  return (double)extraout_ST0;
}



void gdImageColorTransparent(void)

{
  gdImageColorTransparent();
  return;
}



void gtk_tree_store_append(void)

{
  gtk_tree_store_append();
  return;
}



void dbus_message_get_interface(void)

{
  dbus_message_get_interface();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



void gtk_notebook_get_current_page(void)

{
  gtk_notebook_get_current_page();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



void gdImageGetPixel(void)

{
  gdImageGetPixel();
  return;
}



void gdImageColorAllocateAlpha(void)

{
  gdImageColorAllocateAlpha();
  return;
}



void gtk_editable_select_region(void)

{
  gtk_editable_select_region();
  return;
}



void gtk_spin_button_set_value(void)

{
  gtk_spin_button_set_value();
  return;
}



void gdk_window_get_geometry(void)

{
  gdk_window_get_geometry();
  return;
}



void g_return_if_fail_warning(void)

{
  g_return_if_fail_warning();
  return;
}



void g_list_concat(void)

{
  g_list_concat();
  return;
}



void g_type_register_static(void)

{
  g_type_register_static();
  return;
}



void g_value_get_pointer(void)

{
  g_value_get_pointer();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



void gtk_widget_grab_default(void)

{
  gtk_widget_grab_default();
  return;
}



void g_object_set(void)

{
  g_object_set();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fgetc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fgetc(__stream);
  return iVar1;
}



void gtk_hpaned_get_type(void)

{
  gtk_hpaned_get_type();
  return;
}



void g_list_insert(void)

{
  g_list_insert();
  return;
}



void g_list_remove_link(void)

{
  g_list_remove_link();
  return;
}



void gtk_paned_get_type(void)

{
  gtk_paned_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



void gtk_text_view_scroll_to_mark(void)

{
  gtk_text_view_scroll_to_mark();
  return;
}



void dlopen(void)

{
  dlopen();
  return;
}



void gtk_file_filter_add_pattern(void)

{
  gtk_file_filter_add_pattern();
  return;
}



void g_slist_find(void)

{
  g_slist_find();
  return;
}



void gtk_init(void)

{
  gtk_init();
  return;
}



void dbus_connection_set_watch_functions(void)

{
  dbus_connection_set_watch_functions();
  return;
}



void g_list_free_1(void)

{
  g_list_free_1();
  return;
}



void gtk_file_filter_set_name(void)

{
  gtk_file_filter_set_name();
  return;
}



void gtk_widget_hide(void)

{
  gtk_widget_hide();
  return;
}



void gtk_file_chooser_get_filename(void)

{
  gtk_file_chooser_get_filename();
  return;
}



void gtk_dialog_set_alternative_button_order(void)

{
  gtk_dialog_set_alternative_button_order();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



void gtk_arrow_new(void)

{
  gtk_arrow_new();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



void gtk_tree_model_get_type(void)

{
  gtk_tree_model_get_type();
  return;
}



void dbus_connection_register_object_path(void)

{
  dbus_connection_register_object_path();
  return;
}



void gtk_menu_popup(void)

{
  gtk_menu_popup();
  return;
}



void gtk_list_store_append(void)

{
  gtk_list_store_append();
  return;
}



void gtk_check_button_new(void)

{
  gtk_check_button_new();
  return;
}



void gtk_window_present(void)

{
  gtk_window_present();
  return;
}



void gtk_tree_selection_get_selected(void)

{
  gtk_tree_selection_get_selected();
  return;
}



void g_signal_handler_disconnect(void)

{
  g_signal_handler_disconnect();
  return;
}



void g_main_loop_is_running(void)

{
  g_main_loop_is_running();
  return;
}



void gtk_adjustment_new(void)

{
  gtk_adjustment_new();
  return;
}



void gtk_check_button_new_with_label(void)

{
  gtk_check_button_new_with_label();
  return;
}



void gtk_widget_realize(void)

{
  gtk_widget_realize();
  return;
}



void pango_layout_get_pixel_size(void)

{
  pango_layout_get_pixel_size();
  return;
}



void __strcpy_chk(void)

{
  __strcpy_chk();
  return;
}



void gtk_window_add_accel_group(void)

{
  gtk_window_add_accel_group();
  return;
}



void gdk_display_sync(void)

{
  gdk_display_sync();
  return;
}



void gtk_label_get_type(void)

{
  gtk_label_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}



void gtk_object_get_type(void)

{
  gtk_object_get_type();
  return;
}



void gtk_entry_set_width_chars(void)

{
  gtk_entry_set_width_chars();
  return;
}



void g_list_sort(void)

{
  g_list_sort();
  return;
}



void gtk_spin_button_set_numeric(void)

{
  gtk_spin_button_set_numeric();
  return;
}



void g_type_check_instance_is_a(void)

{
  g_type_check_instance_is_a();
  return;
}



void gtk_action_group_add_toggle_actions(void)

{
  gtk_action_group_add_toggle_actions();
  return;
}



void dbus_connection_get_dispatch_status(void)

{
  dbus_connection_get_dispatch_status();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t regerror(int __errcode,regex_t *__preg,char *__errbuf,size_t __errbuf_size)

{
  size_t sVar1;
  
  sVar1 = regerror(__errcode,__preg,__errbuf,__errbuf_size);
  return sVar1;
}



void gtk_button_get_type(void)

{
  gtk_button_get_type();
  return;
}



void g_list_last(void)

{
  g_list_last();
  return;
}



void gdImageColorResolve(void)

{
  gdImageColorResolve();
  return;
}



void g_list_index(void)

{
  g_list_index();
  return;
}



void g_list_append(void)

{
  g_list_append();
  return;
}



void g_slist_foreach(void)

{
  g_slist_foreach();
  return;
}



void gtk_tree_view_set_model(void)

{
  gtk_tree_view_set_model();
  return;
}



void gtk_widget_grab_focus(void)

{
  gtk_widget_grab_focus();
  return;
}



void gtk_tree_selection_get_tree_view(void)

{
  gtk_tree_selection_get_tree_view();
  return;
}



void gtk_tree_model_foreach(void)

{
  gtk_tree_model_foreach();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



void gtk_tree_store_get_type(void)

{
  gtk_tree_store_get_type();
  return;
}



void gtk_entry_set_activates_default(void)

{
  gtk_entry_set_activates_default();
  return;
}



void gtk_radio_button_new_with_label(void)

{
  gtk_radio_button_new_with_label();
  return;
}



void gtk_widget_set_size_request(void)

{
  gtk_widget_set_size_request();
  return;
}



void g_value_dup_object(void)

{
  g_value_dup_object();
  return;
}



void gtk_table_set_col_spacings(void)

{
  gtk_table_set_col_spacings();
  return;
}



void g_param_spec_double(void)

{
  g_param_spec_double();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



void gtk_alignment_get_type(void)

{
  gtk_alignment_get_type();
  return;
}



void g_type_name(void)

{
  g_type_name();
  return;
}



void gtk_tooltips_set_tip(void)

{
  gtk_tooltips_set_tip();
  return;
}



void gtk_button_box_set_layout(void)

{
  gtk_button_box_set_layout();
  return;
}



void gtk_entry_get_type(void)

{
  gtk_entry_get_type();
  return;
}



void g_source_remove(void)

{
  g_source_remove();
  return;
}



void gtk_scrolled_window_add_with_viewport(void)

{
  gtk_scrolled_window_add_with_viewport();
  return;
}



void g_signal_connect_data(void)

{
  g_signal_connect_data();
  return;
}



void gdk_gc_set_foreground(void)

{
  gdk_gc_set_foreground();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void gtk_window_set_resizable(void)

{
  gtk_window_set_resizable();
  return;
}



void gdk_pixbuf_new_from_xpm_data(void)

{
  gdk_pixbuf_new_from_xpm_data();
  return;
}



void g_strjoinv(void)

{
  g_strjoinv();
  return;
}



void gtk_text_buffer_create_mark(void)

{
  gtk_text_buffer_create_mark();
  return;
}



void dbus_connection_close(void)

{
  dbus_connection_close();
  return;
}



void g_slist_length(void)

{
  g_slist_length();
  return;
}



void gtk_tree_model_filter_refilter(void)

{
  gtk_tree_model_filter_refilter();
  return;
}



void dbus_connection_set_timeout_functions(void)

{
  dbus_connection_set_timeout_functions();
  return;
}



void gdk_draw_layout(void)

{
  gdk_draw_layout();
  return;
}



void gdImageRectangle(void)

{
  gdImageRectangle();
  return;
}



void gtk_tree_view_column_pack_start(void)

{
  gtk_tree_view_column_pack_start();
  return;
}



void gtk_file_chooser_add_filter(void)

{
  gtk_file_chooser_add_filter();
  return;
}



void g_type_check_instance_cast(void)

{
  g_type_check_instance_cast();
  return;
}



void gtk_widget_show(void)

{
  gtk_widget_show();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void dbus_message_get_member(void)

{
  dbus_message_get_member();
  return;
}



void gdk_pixmap_new(void)

{
  gdk_pixmap_new();
  return;
}



void gtk_paned_pack1(void)

{
  gtk_paned_pack1();
  return;
}



void gtk_notebook_set_current_page(void)

{
  gtk_notebook_set_current_page();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int gethostname(char *__name,size_t __len)

{
  int iVar1;
  
  iVar1 = gethostname(__name,__len);
  return iVar1;
}



void pango_layout_set_font_description(void)

{
  pango_layout_set_font_description();
  return;
}



void gtk_list_store_new(void)

{
  gtk_list_store_new();
  return;
}



void g_ptr_array_sort(void)

{
  g_ptr_array_sort();
  return;
}



void gtk_action_group_add_radio_actions(void)

{
  gtk_action_group_add_radio_actions();
  return;
}



void gtk_toggle_button_set_mode(void)

{
  gtk_toggle_button_set_mode();
  return;
}



void gtk_action_group_new(void)

{
  gtk_action_group_new();
  return;
}



void gtk_color_button_get_type(void)

{
  gtk_color_button_get_type();
  return;
}



void gtk_main_iteration(void)

{
  gtk_main_iteration();
  return;
}



void gtk_radio_action_get_current_value(void)

{
  gtk_radio_action_get_current_value();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double atan2(double __y,double __x)

{
  float10 extraout_ST0;
  
  atan2(__y,__x);
  return (double)extraout_ST0;
}



void gtk_dialog_run(void)

{
  gtk_dialog_run();
  return;
}



void gdk_window_set_cursor(void)

{
  gdk_window_set_cursor();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



void gdImageColorResolveAlpha(void)

{
  gdImageColorResolveAlpha();
  return;
}



void gtk_radio_button_new(void)

{
  gtk_radio_button_new();
  return;
}



void gtk_tree_view_set_expander_column(void)

{
  gtk_tree_view_set_expander_column();
  return;
}



void gtk_scale_set_value_pos(void)

{
  gtk_scale_set_value_pos();
  return;
}



void gdk_draw_line(void)

{
  gdk_draw_line();
  return;
}



void g_locale_to_utf8(void)

{
  g_locale_to_utf8();
  return;
}



void dlerror(void)

{
  dlerror();
  return;
}



void g_list_reverse(void)

{
  g_list_reverse();
  return;
}



void g_slist_free_1(void)

{
  g_slist_free_1();
  return;
}



void gtk_tree_view_row_expanded(void)

{
  gtk_tree_view_row_expanded();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strtok(char *__s,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strtok(__s,__delim);
  return pcVar1;
}



void gtk_hbox_new(void)

{
  gtk_hbox_new();
  return;
}



void gtk_expander_new(void)

{
  gtk_expander_new();
  return;
}



void gtk_frame_get_type(void)

{
  gtk_frame_get_type();
  return;
}



void g_ascii_strup(void)

{
  g_ascii_strup();
  return;
}



void g_strsplit(void)

{
  g_strsplit();
  return;
}



void gtk_container_add(void)

{
  gtk_container_add();
  return;
}



void g_hash_table_lookup(void)

{
  g_hash_table_lookup();
  return;
}



void gtk_radio_button_get_group(void)

{
  gtk_radio_button_get_group();
  return;
}



void g_direct_hash(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gdImageFilledPolygon(void)

{
  gdImageFilledPolygon();
  return;
}



void gtk_text_view_get_buffer(void)

{
  gtk_text_view_get_buffer();
  return;
}



void dbus_message_get_args(void)

{
  dbus_message_get_args();
  return;
}



void gtk_timeout_remove(void)

{
  gtk_timeout_remove();
  return;
}



void gdImageJpeg(void)

{
  gdImageJpeg();
  return;
}



void gtk_event_box_new(void)

{
  gtk_event_box_new();
  return;
}



void gtk_toggle_button_set_active(void)

{
  gtk_toggle_button_set_active();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strncasecmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncasecmp(__s1,__s2,__n);
  return iVar1;
}



void dbus_message_iter_append_basic(void)

{
  dbus_message_iter_append_basic();
  return;
}



void gtk_file_chooser_dialog_new(void)

{
  gtk_file_chooser_dialog_new();
  return;
}



void gtk_drawing_area_new(void)

{
  gtk_drawing_area_new();
  return;
}



void gtk_toggle_button_get_type(void)

{
  gtk_toggle_button_get_type();
  return;
}



void gtk_scrolled_window_new(void)

{
  gtk_scrolled_window_new();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



void g_malloc0(void)

{
  g_malloc0();
  return;
}



void gtk_list_store_set(void)

{
  gtk_list_store_set();
  return;
}



void gtk_box_pack_start(void)

{
  gtk_box_pack_start();
  return;
}



void g_ptr_array_sized_new(void)

{
  g_ptr_array_sized_new();
  return;
}



void gtk_cell_renderer_text_get_type(void)

{
  gtk_cell_renderer_text_get_type();
  return;
}



void g_value_init(void)

{
  g_value_init();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__int32_t ** __ctype_tolower_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_tolower_loc();
  return pp_Var1;
}



void g_list_prepend(void)

{
  g_list_prepend();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



void gtk_ui_manager_set_add_tearoffs(void)

{
  gtk_ui_manager_set_add_tearoffs();
  return;
}



void gtk_disable_setlocale(void)

{
  gtk_disable_setlocale();
  return;
}



void pango_layout_set_markup(void)

{
  pango_layout_set_markup();
  return;
}



void g_string_insert_c(void)

{
  g_string_insert_c();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



void gtk_misc_get_type(void)

{
  gtk_misc_get_type();
  return;
}



void dbus_timeout_get_enabled(void)

{
  dbus_timeout_get_enabled();
  return;
}



void dbus_message_iter_init_append(void)

{
  dbus_message_iter_init_append();
  return;
}



void g_build_filename(void)

{
  g_build_filename();
  return;
}



void g_main_loop_unref(void)

{
  g_main_loop_unref();
  return;
}



void gtk_range_set_value(void)

{
  gtk_range_set_value();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * asctime(tm *__tp)

{
  char *pcVar1;
  
  pcVar1 = asctime(__tp);
  return pcVar1;
}



void gtk_cell_renderer_get_type(void)

{
  gtk_cell_renderer_get_type();
  return;
}



void gdk_display_get_pointer(void)

{
  gdk_display_get_pointer();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double log(double __x)

{
  float10 extraout_ST0;
  
  log(__x);
  return (double)extraout_ST0;
}



void gdk_drawable_get_display(void)

{
  gdk_drawable_get_display();
  return;
}



void gtk_viewport_set_shadow_type(void)

{
  gtk_viewport_set_shadow_type();
  return;
}



void gtk_tree_view_get_type(void)

{
  gtk_tree_view_get_type();
  return;
}



void g_io_channel_unref(void)

{
  g_io_channel_unref();
  return;
}



void gtk_tree_model_get_path(void)

{
  gtk_tree_model_get_path();
  return;
}



void g_idle_add(void)

{
  g_idle_add();
  return;
}



void gtk_image_new_from_pixbuf(void)

{
  gtk_image_new_from_pixbuf();
  return;
}



void textdomain(void)

{
  textdomain();
  return;
}



void g_slist_concat(void)

{
  g_slist_concat();
  return;
}



void gtk_button_new_with_label(void)

{
  gtk_button_new_with_label();
  return;
}



void dbus_error_free(void)

{
  dbus_error_free();
  return;
}



void g_build_path(void)

{
  g_build_path();
  return;
}



void gtk_widget_is_ancestor(void)

{
  gtk_widget_is_ancestor();
  return;
}



void g_assertion_message(void)

{
                    // WARNING: Subroutine does not return
  g_assertion_message();
}



void gtk_notebook_get_type(void)

{
  gtk_notebook_get_type();
  return;
}



void gtk_widget_create_pango_layout(void)

{
  gtk_widget_create_pango_layout();
  return;
}



void gtk_tree_row_reference_new(void)

{
  gtk_tree_row_reference_new();
  return;
}



void gtk_tree_model_get(void)

{
  gtk_tree_model_get();
  return;
}



void g_list_nth_data(void)

{
  g_list_nth_data();
  return;
}



void gtk_button_new_from_stock(void)

{
  gtk_button_new_from_stock();
  return;
}



void gtk_color_button_get_color(void)

{
  gtk_color_button_get_color();
  return;
}



void gtk_combo_box_get_active(void)

{
  gtk_combo_box_get_active();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int rand(void)

{
  int iVar1;
  
  iVar1 = rand();
  return iVar1;
}



void gtk_vscrollbar_new(void)

{
  gtk_vscrollbar_new();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sscanf(__s,__format);
  return iVar1;
}



void g_source_attach(void)

{
  g_source_attach();
  return;
}



void gtk_adjustment_get_value(void)

{
  gtk_adjustment_get_value();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * gmtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = gmtime(__timer);
  return ptVar1;
}



void g_get_home_dir(void)

{
  g_get_home_dir();
  return;
}



void gdImageSetThickness(void)

{
  gdImageSetThickness();
  return;
}



void gtk_tree_selection_set_mode(void)

{
  gtk_tree_selection_set_mode();
  return;
}



void gtk_scrolled_window_get_type(void)

{
  gtk_scrolled_window_get_type();
  return;
}



void __sprintf_chk(void)

{
  __sprintf_chk();
  return;
}



void gdImageSetPixel(void)

{
  gdImageSetPixel();
  return;
}



void gtk_range_set_update_policy(void)

{
  gtk_range_set_update_policy();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



void __realpath_chk(void)

{
  __realpath_chk();
  return;
}



void g_node_new(void)

{
  g_node_new();
  return;
}



void gtk_tree_view_get_selection(void)

{
  gtk_tree_view_get_selection();
  return;
}



void __snprintf_chk(void)

{
  __snprintf_chk();
  return;
}



void g_error_free(void)

{
  g_error_free();
  return;
}



void dbus_connection_unregister_object_path(void)

{
  dbus_connection_unregister_object_path();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



void gtk_tree_model_get_iter(void)

{
  gtk_tree_model_get_iter();
  return;
}



void gdk_window_get_origin(void)

{
  gdk_window_get_origin();
  return;
}



void g_strfreev(void)

{
  g_strfreev();
  return;
}



void gtk_spin_button_new(void)

{
  gtk_spin_button_new();
  return;
}



void g_ptr_array_new(void)

{
  g_ptr_array_new();
  return;
}



void gtk_tree_view_column_new_with_attributes(void)

{
  gtk_tree_view_column_new_with_attributes();
  return;
}



void gtk_window_set_default_icon(void)

{
  gtk_window_set_default_icon();
  return;
}



void g_malloc_n(void)

{
  g_malloc_n();
  return;
}



void gtk_message_dialog_get_type(void)

{
  gtk_message_dialog_get_type();
  return;
}



void gtk_text_buffer_insert_with_tags_by_name(void)

{
  gtk_text_buffer_insert_with_tags_by_name();
  return;
}



void g_timeout_add(void)

{
  g_timeout_add();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



void gtk_action_group_get_action(void)

{
  gtk_action_group_get_action();
  return;
}



void g_value_get_int(void)

{
  g_value_get_int();
  return;
}



void gtk_tree_store_set(void)

{
  gtk_tree_store_set();
  return;
}



void gdImagePng(void)

{
  gdImagePng();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)

{
  size_t sVar1;
  
  sVar1 = strftime(__s,__maxsize,__format,__tp);
  return sVar1;
}



void gtk_table_set_row_spacings(void)

{
  gtk_table_set_row_spacings();
  return;
}



void g_object_set_property(void)

{
  g_object_set_property();
  return;
}



void gtk_hseparator_new(void)

{
  gtk_hseparator_new();
  return;
}



void gdImageCreate(void)

{
  gdImageCreate();
  return;
}



void g_list_insert_sorted_with_data(void)

{
  g_list_insert_sorted_with_data();
  return;
}



void bind_textdomain_codeset(void)

{
  bind_textdomain_codeset();
  return;
}



void gtk_window_set_wmclass(void)

{
  gtk_window_set_wmclass();
  return;
}



void gtk_tree_row_reference_get_path(void)

{
  gtk_tree_row_reference_get_path();
  return;
}



void gtk_combo_box_prepend_text(void)

{
  gtk_combo_box_prepend_text();
  return;
}



void g_hash_table_foreach_remove(void)

{
  g_hash_table_foreach_remove();
  return;
}



void gtk_vscale_new(void)

{
  gtk_vscale_new();
  return;
}



void gtk_toggle_action_get_type(void)

{
  gtk_toggle_action_get_type();
  return;
}



void gtk_notebook_set_show_tabs(void)

{
  gtk_notebook_set_show_tabs();
  return;
}



void gtk_ui_manager_add_ui_from_string(void)

{
  gtk_ui_manager_add_ui_from_string();
  return;
}



void gtk_container_remove(void)

{
  gtk_container_remove();
  return;
}



void gtk_tree_store_clear(void)

{
  gtk_tree_store_clear();
  return;
}



void dbus_free_string_array(void)

{
  dbus_free_string_array();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double sin(double __x)

{
  float10 extraout_ST0;
  
  sin(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

hostent * gethostbyname(char *__name)

{
  hostent *phVar1;
  
  phVar1 = gethostbyname(__name);
  return phVar1;
}



void gtk_box_set_spacing(void)

{
  gtk_box_set_spacing();
  return;
}



void g_main_loop_run(void)

{
  g_main_loop_run();
  return;
}



void gtk_editable_set_editable(void)

{
  gtk_editable_set_editable();
  return;
}



void gdImageFilledRectangle(void)

{
  gdImageFilledRectangle();
  return;
}



void g_list_remove(void)

{
  g_list_remove();
  return;
}



void gtk_tree_model_iter_children(void)

{
  gtk_tree_model_iter_children();
  return;
}



void gtk_spin_button_get_type(void)

{
  gtk_spin_button_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



void gtk_bin_get_type(void)

{
  gtk_bin_get_type();
  return;
}



void gtk_widget_set_uposition(void)

{
  gtk_widget_set_uposition();
  return;
}



void gtk_combo_box_append_text(void)

{
  gtk_combo_box_append_text();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double rint(double __x)

{
  float10 extraout_ST0;
  
  rint(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void gtk_widget_add_events(void)

{
  gtk_widget_add_events();
  return;
}



void dbus_timeout_set_data(void)

{
  dbus_timeout_set_data();
  return;
}



void g_node_destroy(void)

{
  g_node_destroy();
  return;
}



void g_type_class_peek_parent(void)

{
  g_type_class_peek_parent();
  return;
}



void __strdup(void)

{
  __strdup();
  return;
}



void gtk_radio_button_get_type(void)

{
  gtk_radio_button_get_type();
  return;
}



void gtk_label_set_markup(void)

{
  gtk_label_set_markup();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



void gtk_range_get_adjustment(void)

{
  gtk_range_get_adjustment();
  return;
}



void g_log(void)

{
  g_log();
  return;
}



void gtk_tree_view_set_rules_hint(void)

{
  gtk_tree_view_set_rules_hint();
  return;
}



void gdk_gc_set_clip_mask(void)

{
  gdk_gc_set_clip_mask();
  return;
}



void g_str_equal(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void gtk_container_set_border_width(void)

{
  gtk_container_set_border_width();
  return;
}



void dbus_message_get_type(void)

{
  dbus_message_get_type();
  return;
}



void gtk_hbutton_box_new(void)

{
  gtk_hbutton_box_new();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = pclose(__stream);
  return iVar1;
}



void g_file_test(void)

{
  g_file_test();
  return;
}



void gtk_ui_manager_get_widget(void)

{
  gtk_ui_manager_get_widget();
  return;
}



void __strncat_chk(void)

{
  __strncat_chk();
  return;
}



void gtk_drawing_area_get_type(void)

{
  gtk_drawing_area_get_type();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void sincos(double __x,double *__sinx,double *__cosx)

{
  sincos(__x,__sinx,__cosx);
  return;
}



void g_pattern_match_simple(void)

{
  g_pattern_match_simple();
  return;
}



void gtk_ui_manager_remove_action_group(void)

{
  gtk_ui_manager_remove_action_group();
  return;
}



void gtk_text_buffer_delete_mark(void)

{
  gtk_text_buffer_delete_mark();
  return;
}



void gtk_hscale_new(void)

{
  gtk_hscale_new();
  return;
}



void gtk_misc_set_alignment(void)

{
  gtk_misc_set_alignment();
  return;
}



void gtk_color_button_new_with_color(void)

{
  gtk_color_button_new_with_color();
  return;
}



void gtk_tree_model_iter_next(void)

{
  gtk_tree_model_iter_next();
  return;
}



void g_ascii_strcasecmp(void)

{
  g_ascii_strcasecmp();
  return;
}



void gdImageColorAllocate(void)

{
  gdImageColorAllocate();
  return;
}



void g_slist_nth(void)

{
  g_slist_nth();
  return;
}



void gtk_scale_set_draw_value(void)

{
  gtk_scale_set_draw_value();
  return;
}



void dbus_timeout_get_interval(void)

{
  dbus_timeout_get_interval();
  return;
}



void gtk_box_pack_end(void)

{
  gtk_box_pack_end();
  return;
}



void gtk_spin_button_get_value(void)

{
  gtk_spin_button_get_value();
  return;
}



void gdImageSetBrush(void)

{
  gdImageSetBrush();
  return;
}



void _start(void)

{
  __libc_start_main(main);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x08060eea)
// WARNING: Removing unreachable block (ram,0x08060ef0)

void __do_global_dtors_aux(void)

{
  if (completed_7065 == '\0') {
    completed_7065 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08060f38)

void frame_dummy(void)

{
  return;
}



int FlagHaveRegex(int parm)

{
  return 1;
}



// WARNING: Exceeded maximum restarts with more pending

void ActionBell(char *volume)

{
                    // WARNING: Could not recover jumptable at 0x08060f72. Too many branches
                    // WARNING: Treating indirect jump as call
  (*gui->beep)();
  return;
}



int ActionPSCalib(int argc,char **argv,int x,int y)

{
  HID *pHVar1;
  
  pHVar1 = hid_find_exporter("ps");
  (*pHVar1->calibrate)(0.00000000,0.00000000);
  return 0;
}



void NotifyBlock(void)

{
  HideCrosshair('\x01');
  if (Crosshair.AttachedBox.State == 0) {
    Crosshair.AttachedBox.State = 1;
    Crosshair.AttachedBox.Point2.X = Crosshair.X;
    Crosshair.AttachedBox.Point1.X = Crosshair.X;
    Crosshair.AttachedBox.Point2.Y = Crosshair.Y;
    Crosshair.AttachedBox.Point1.Y = Crosshair.Y;
  }
  else {
    if (Crosshair.AttachedBox.State == 1) {
      Crosshair.AttachedBox.State = 2;
      RestoreCrosshair('\x01');
      return;
    }
  }
  RestoreCrosshair('\x01');
  return;
}



int ActionNew(int argc,char **argv,int x,int y)

{
  PCBTypePtr pcb;
  int iVar1;
  char *S;
  
  S = (char *)0x0;
  if (0 < argc) {
    S = *argv;
  }
  HideCrosshair('\x01');
  if (PCB->Changed != '\0') {
    iVar1 = (*gui->confirm_dialog)("OK to clear layout data?",0);
    if (iVar1 == 0) goto LAB_080611a2;
  }
  if (S == (char *)0x0) {
    S = (*gui->prompt_for)("Enter the layout name:","");
  }
  else {
    S = MyStrdup(S,"ActionNew");
  }
  if (S != (char *)0x0) {
    if ((PCB->Changed != '\0') && (Settings.SaveInTMP != '\0')) {
      SaveInTMP();
    }
    RemovePCB(PCB);
    pcb = CreateNewPCB('\x01');
    PCB = pcb;
    pcb->Data->LayerN = 8;
    CreateNewPCBPost(pcb,1);
    PCB->Name = S;
    ResetStackAndVisibility();
    CreateDefaultFont();
    SetCrosshairRange(0,0,PCB->MaxWidth,PCB->MaxHeight);
    CenterDisplay(PCB->MaxWidth / 2,PCB->MaxHeight / 2,'\0');
    ClearAndRedrawOutput();
    hid_action("PCBChanged");
    RestoreCrosshair('\x01');
    return 0;
  }
LAB_080611a2:
  RestoreCrosshair('\x01');
  return 1;
}



int __regparm3 hashfunc(String s)

{
  char cVar1;
  __int32_t **pp_Var2;
  uint uVar3;
  uint uVar4;
  
  uVar3 = 0;
  uVar4 = 0;
  cVar1 = *s;
  if (cVar1 != '\0') {
    do {
      uVar3 = SEXT14(cVar1);
      if (uVar3 + 0x80 < 0x180) {
        pp_Var2 = __ctype_tolower_loc();
        uVar3 = (*pp_Var2)[uVar3];
      }
      s = s + 1;
      uVar4 = uVar3 & 0xff ^ ((int)uVar4 >> 0x10 ^ uVar4) * 0xd;
      cVar1 = *s;
    } while (cVar1 != '\0');
    uVar3 = uVar4 % 0x101;
  }
  return uVar3;
}



int __regparm3 GetFunctionID(String Ident)

{
  char cVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (Ident != (String)0x0) {
    if (hash_initted == 0) {
      hash_initted = 1;
      iVar3 = 0x73;
      do {
        iVar2 = hashfunc(*(String *)
                          (
                          "ChangeFlag(Object|Selected|SelectedObjects, flag, value)\nChangeFlag(SelectedLines|SelectedPins|SelectedVias, flag, value)\nChangeFlag(SelectedPads|SelectedTexts|SelectedNames, flag, value)\nChangeFlag(SelectedElements, flag, value)\nflag = square | octagon | thermal | join\nvalue = 0 | 1"
                          + iVar3 * 8 + 0x118));
        cVar1 = function_hash[iVar2];
        while (cVar1 != '\0') {
          iVar2 = (iVar2 + 1) % 0x101;
          cVar1 = function_hash[iVar2];
        }
        iVar4 = iVar3 + -1;
        function_hash[iVar2] = (char)iVar3;
        iVar3 = iVar4;
      } while (iVar4 != 0);
    }
    iVar3 = hashfunc(Ident);
    cVar1 = function_hash[iVar3];
    while (cVar1 != '\0') {
      iVar2 = strcasecmp(Ident,Functions[(int)cVar1 + -1].Identifier);
      if (iVar2 == 0) {
        return Functions[(int)cVar1 + -1].ID;
      }
      iVar3 = (iVar3 + 1) % 0x101;
      cVar1 = function_hash[iVar3];
    }
  }
  return -1;
}



int ActionMoveToCurrentLayer(int argc,char **argv,int x,int y)

{
  String Ident;
  Boolean BVar1;
  int Type;
  LayerTypePtr Target;
  void *pvVar2;
  void *local_18;
  void *local_14;
  void *local_10 [2];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  if ((Type == 0x46) || (Type == 0x4b)) {
    if (PCB->SilkActive == '\0') {
      Target = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Target = (LayerTypePtr)
               (&PCB->Data->field_0x4c +
               ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    BVar1 = MoveSelectedObjectsToLayer(Target);
    if (BVar1 == '\0') goto LAB_080613b9;
  }
  else {
    if (Type != 0x2e) goto LAB_080613b9;
    (*gui->get_coords)("Select an Object",&x,&y);
    Type = SearchScreen(x,y,0x403c,local_10,&local_14,&local_18);
    if (Type == 0) goto LAB_080613b9;
    if (PCB->SilkActive == '\0') {
      Target = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Target = (LayerTypePtr)
               (&PCB->Data->field_0x4c +
               ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    pvVar2 = MoveObjectToLayer(Type,local_10[0],local_14,local_18,Target,'\0');
    if (pvVar2 == (void *)0x0) goto LAB_080613b9;
  }
  SetChangedFlag('\x01');
LAB_080613b9:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionMessage(int argc,char **argv,int x,int y)

{
  char **ppcVar1;
  int iVar2;
  
  iVar2 = 0;
  if (argc < 1) {
    Message("Syntax error.  Usage:\n%s\n","Message(message)");
    iVar2 = 1;
  }
  else {
    do {
      ppcVar1 = argv + iVar2;
      iVar2 = iVar2 + 1;
      Message(*ppcVar1);
      Message("\n");
    } while (iVar2 < argc);
    iVar2 = 0;
  }
  return iVar2;
}



int ActionMoveObject(int argc,char **argv,int x,int y)

{
  int Type;
  char *val;
  char *units;
  int DX;
  int DY;
  char *val_00;
  float fVar1;
  float fVar2;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1e;
  Boolean local_1d [13];
  
  if (argc < 1) {
    val_00 = (char *)0x0;
  }
  else {
    val_00 = *argv;
    if (argc != 1) {
      units = (char *)0x0;
      val = argv[1];
      if (argc != 2) {
        units = argv[2];
      }
      goto LAB_080615a2;
    }
  }
  val = (char *)0x0;
  units = (char *)0x0;
LAB_080615a2:
  fVar1 = GetValue(val,units,local_1d);
  fVar2 = GetValue(val_00,units,&local_1e);
  Type = SearchScreen(x,y,0x5c1f,&local_24,&local_28,&local_2c);
  if (Type == 0) {
    Message("Nothing found under crosshair\n");
    return 1;
  }
  Crosshair.AttachedObject.RubberbandN = 0;
  DX = (int)ROUND(fVar2);
  if (local_1d[0] != '\0') {
    DX = (int)ROUND(fVar2) - x;
  }
  DY = (int)ROUND(fVar1);
  if (local_1e != '\0') {
    DY = (int)ROUND(fVar1) - y;
  }
  if ((*(byte *)&(PCB->Flags).f & 0x10) != 0) {
    LookupRubberbandLines(Type,local_24,local_28,local_2c);
  }
  if (Type == 2) {
    LookupRatLines(2,local_24,local_28,local_2c);
  }
  MoveObjectAndRubberband(Type,local_24,local_28,local_2c,DX,DY);
  SetChangedFlag('\x01');
  return 0;
}



int ActionRouteStyle(int argc,char **argv,int x,int y)

{
  long lVar1;
  long *plVar2;
  
  if ((0 < argc) && (*argv != (char *)0x0)) {
    lVar1 = strtol(*argv,(char **)0x0,10);
    if (lVar1 - 1U < 4) {
      plVar2 = &PCB->ID + (lVar1 - 1U) * 6;
      SetLineSize(plVar2[0x865]);
      SetViaSize(plVar2[0x866],'\x01');
      SetViaDrillingHole(plVar2[0x867],'\x01');
      SetKeepawayWidth(plVar2[0x868]);
      hid_action("RouteStylesChanged");
      return 0;
    }
  }
  return 0;
}



int ActionPolygon(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  
  if (((0 < argc) && (Ident = *argv, Ident != (String)0x0)) && (Settings.Mode == 4)) {
    HideCrosshair('\x01');
    iVar1 = GetFunctionID(Ident);
    if (iVar1 == 0xe) {
      ClosePolygon();
    }
    else {
      if (iVar1 == 0x36) {
        GoToPreviousPoint();
      }
    }
    RestoreCrosshair('\x01');
    return 0;
  }
  return 0;
}



void __regparm3 ChangeFlag(char *what,char *flag_name,int value,char *cmd_name)

{
  char cVar1;
  int iVar2;
  code *pcVar3;
  char *pcVar4;
  code *pcVar5;
  char *pcVar6;
  bool bVar7;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  bVar7 = flag_name == (char *)0x0;
  if (bVar7) {
LAB_080619c0:
    Message("%s():  Flag \"%s\" is not valid\n",cmd_name,flag_name);
    return;
  }
  iVar2 = 7;
  pcVar4 = flag_name;
  pcVar6 = "square";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar7 = *pcVar4 == *pcVar6;
    pcVar4 = pcVar4 + 1;
    pcVar6 = pcVar6 + 1;
  } while (bVar7);
  if (bVar7) {
    pcVar3 = ClrSelectedSquare;
    pcVar5 = ClrObjectSquare;
    if (value != 0) {
      pcVar3 = SetSelectedSquare;
      pcVar5 = SetObjectSquare;
    }
  }
  else {
    iVar2 = 8;
    pcVar4 = flag_name;
    pcVar6 = "octagon";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar7 = *pcVar4 == *pcVar6;
      pcVar4 = pcVar4 + 1;
      pcVar6 = pcVar6 + 1;
    } while (bVar7);
    if (bVar7) {
      pcVar3 = ClrSelectedOctagon;
      pcVar5 = ClrObjectOctagon;
      if (value != 0) {
        pcVar3 = SetSelectedOctagon;
        pcVar5 = SetObjectOctagon;
      }
    }
    else {
      iVar2 = 5;
      pcVar4 = flag_name;
      pcVar6 = "join";
      do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        bVar7 = *pcVar4 == *pcVar6;
        pcVar4 = pcVar4 + 1;
        pcVar6 = pcVar6 + 1;
      } while (bVar7);
      if (!bVar7) goto LAB_080619c0;
      pcVar3 = SetSelectedJoin;
      pcVar5 = SetObjectJoin;
      if (value != 0) {
        pcVar3 = ClrSelectedJoin;
        pcVar5 = ClrObjectJoin;
      }
    }
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(what);
  switch(iVar2) {
  case 0x2e:
    iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,0x471f,local_20,&local_24,&local_28);
    if ((iVar2 != 0) && ((*(byte *)((int)local_24 + 0x15) & 0x20) != 0)) {
      Message("Sorry, the object is locked\n");
    }
    cVar1 = (*pcVar5)(iVar2,local_20[0],local_24,local_28);
    break;
  default:
    goto switchD_080618d6_caseD_2f;
  case 0x46:
  case 0x4b:
    cVar1 = (*pcVar3)(0x471f);
    goto joined_r0x08061a28;
  case 0x48:
    cVar1 = (*pcVar3)(2);
joined_r0x08061a28:
    if (cVar1 == '\0') goto switchD_080618d6_caseD_2f;
    goto LAB_08061960;
  case 0x49:
    cVar1 = (*pcVar3)(4);
    break;
  case 0x4a:
    cVar1 = (*pcVar3)(0x400);
    break;
  case 0x4c:
    cVar1 = (*pcVar3)(0x200);
    break;
  case 0x4d:
    cVar1 = (*pcVar3)(0x100);
    break;
  case 0x4e:
    cVar1 = (*pcVar3)(0x10);
    break;
  case 0x4f:
    cVar1 = (*pcVar3)(1);
  }
  if (cVar1 != '\0') {
LAB_08061960:
    SetChangedFlag('\x01');
  }
switchD_080618d6_caseD_2f:
  RestoreCrosshair('\x01');
  return;
}



int ActionChangeFlag(int argc,char **argv,int x,int y)

{
  char *what;
  char *flag_name;
  uint value;
  
  if (((0 < argc) && (what = *argv, argc != 1)) && (flag_name = argv[1], argc != 2)) {
    value = strtol(argv[2],(char **)0x0,10);
    if (value < 2) {
      ChangeFlag(what,flag_name,value,"ChangeFlag");
      return 0;
    }
  }
  Message("Syntax error.  Usage:\n%s\n",
                    
          "ChangeFlag(Object|Selected|SelectedObjects, flag, value)\nChangeFlag(SelectedLines|SelectedPins|SelectedVias, flag, value)\nChangeFlag(SelectedPads|SelectedTexts|SelectedNames, flag, value)\nChangeFlag(SelectedElements, flag, value)\nflag = square | octagon | thermal | join\nvalue = 0 | 1"
         );
  return 1;
}



int ActionClrFlag(int argc,char **argv,int x,int y)

{
  char *what;
  char *flag_name;
  
  what = (char *)0x0;
  flag_name = (char *)0x0;
  if ((0 < argc) && (what = *argv, argc != 1)) {
    flag_name = argv[1];
  }
  ChangeFlag(what,flag_name,0,"ClrFlag");
  return 0;
}



int ActionSetFlag(int argc,char **argv,int x,int y)

{
  char *what;
  char *flag_name;
  
  what = (char *)0x0;
  flag_name = (char *)0x0;
  if ((0 < argc) && (what = *argv, argc != 1)) {
    flag_name = argv[1];
  }
  ChangeFlag(what,flag_name,1,"SetFlag");
  return 0;
}



int ActionSetSquare(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  if (*Ident == '\0') {
    return 0;
  }
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an object",&x,&y);
    Type = SearchScreen(x,y,0x302,local_10,&local_14,&local_18);
    if (Type == 0) {
      return 0;
    }
    BVar2 = SetObjectSquare(Type,local_10[0],local_14,local_18);
    if (BVar2 == '\0') {
      return 0;
    }
    goto LAB_08061c59;
  default:
    goto switchD_08061c40_caseD_2f;
  case 0x46:
  case 0x4b:
  case 0x4d:
    cVar1 = SetSelectedSquare(0x300);
    break;
  case 0x48:
    cVar1 = SetSelectedSquare(2);
  }
  if (cVar1 != '\0') {
LAB_08061c59:
    SetChangedFlag('\x01');
  }
switchD_08061c40_caseD_2f:
  return 0;
}



int ActionClearSquare(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  if (*Ident == '\0') {
    return 0;
  }
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an Object",&x,&y);
    Type = SearchScreen(x,y,0x302,local_10,&local_14,&local_18);
    if (Type == 0) {
      return 0;
    }
    BVar2 = ClrObjectSquare(Type,local_10[0],local_14,local_18);
    if (BVar2 == '\0') {
      return 0;
    }
    goto LAB_08061d59;
  default:
    goto switchD_08061d40_caseD_2f;
  case 0x46:
  case 0x4b:
  case 0x4d:
    cVar1 = ClrSelectedSquare(0x300);
    break;
  case 0x48:
    cVar1 = ClrSelectedSquare(2);
  }
  if (cVar1 != '\0') {
LAB_08061d59:
    SetChangedFlag('\x01');
  }
switchD_08061d40_caseD_2f:
  return 0;
}



int ActionSetOctagon(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if ((0 < argc) && (*argv != (String)0x0)) {
    Type = GetFunctionID(*argv);
    switch(Type) {
    case 0x2e:
    case 0x5f:
      (*gui->get_coords)("Select an object",&x,&y);
      Type = SearchScreen(x,y,0x103,local_10,&local_14,&local_18);
      if (Type == 0) {
        return 0;
      }
      BVar2 = SetObjectOctagon(Type,local_10[0],local_14,local_18);
      if (BVar2 == '\0') {
        return 0;
      }
      goto LAB_08061e82;
    default:
      goto switchD_08061e38_caseD_2f;
    case 0x46:
    case 0x4b:
      cVar1 = SetSelectedOctagon(0x101);
      break;
    case 0x48:
      cVar1 = SetSelectedOctagon(2);
      break;
    case 0x4d:
      cVar1 = SetSelectedOctagon(0x100);
      break;
    case 0x4f:
      cVar1 = SetSelectedOctagon(1);
    }
    if (cVar1 != '\0') {
LAB_08061e82:
      SetChangedFlag('\x01');
      return 0;
    }
  }
switchD_08061e38_caseD_2f:
  return 0;
}



int ActionClearOctagon(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if ((0 < argc) && (*argv != (String)0x0)) {
    Type = GetFunctionID(*argv);
    switch(Type) {
    case 0x2e:
    case 0x5f:
      (*gui->get_coords)("Select an Object",&x,&y);
      Type = SearchScreen(Crosshair.X,Crosshair.Y,0x103,local_10,&local_14,&local_18);
      if (Type == 0) {
        return 0;
      }
      BVar2 = ClrObjectOctagon(Type,local_10[0],local_14,local_18);
      if (BVar2 == '\0') {
        return 0;
      }
      goto LAB_08061fb2;
    default:
      goto switchD_08061f68_caseD_2f;
    case 0x46:
    case 0x4b:
      cVar1 = ClrSelectedOctagon(0x101);
      break;
    case 0x48:
      cVar1 = ClrSelectedOctagon(2);
      break;
    case 0x4d:
      cVar1 = ClrSelectedOctagon(0x100);
      break;
    case 0x4f:
      cVar1 = ClrSelectedOctagon(1);
    }
    if (cVar1 != '\0') {
LAB_08061fb2:
      SetChangedFlag('\x01');
      return 0;
    }
  }
switchD_08061f68_caseD_2f:
  return 0;
}



int ActionSetSame(int argc,char **argv,int x,int y)

{
  int Layer;
  LayerTypePtr pLVar1;
  void *ptr3;
  void *local_14;
  LayerTypePtr local_10 [2];
  
  if (PCB->SilkActive == '\0') {
    pLVar1 = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    pLVar1 = (LayerTypePtr)
             (&PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  Layer = SearchScreen(x,y,0x400d,local_10,&local_14,&ptr3);
  if (Layer == 4) {
    HideCrosshair('\x01');
    Settings.LineThickness = *(int *)((int)local_14 + 0x24);
    Settings.Keepaway = *(int *)((int)local_14 + 0x28) / 2;
    if (Settings.Mode != 2) {
      SetMode(2);
    }
LAB_08062168:
    RestoreCrosshair('\x01');
    hid_action("RouteStylesChanged");
LAB_08062180:
    if (PCB->SilkActive == '\0') {
      pLVar1 = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      pLVar1 = (LayerTypePtr)
               (&PCB->Data->field_0x4c +
               ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    Layer = 0;
    if (pLVar1 != local_10[0]) {
      Layer = GetLayerNumber(PCB->Data,local_10[0]);
      ChangeGroupVisibility(Layer,'\x01','\x01');
      ClearAndRedrawOutput();
      return 0;
    }
  }
  else {
    if (Layer < 5) {
      if (Layer == 1) {
        HideCrosshair('\x01');
        Settings.ViaThickness = *(int *)((int)local_14 + 0x24);
        Settings.ViaDrillingHole = *(int *)((int)local_14 + 0x30);
        Settings.Keepaway = *(int *)((int)local_14 + 0x28) / 2;
        local_10[0] = pLVar1;
        if (Settings.Mode != 1) {
          SetMode(1);
        }
        goto LAB_08062168;
      }
    }
    else {
      if (Layer == 8) goto LAB_08062180;
      if (Layer == 0x4000) {
        HideCrosshair('\x01');
        Settings.LineThickness = *(int *)((int)local_14 + 0x24);
        Settings.Keepaway = *(int *)((int)local_14 + 0x28) / 2;
        if (Settings.Mode != 0x6d) {
          SetMode(0x6d);
        }
        goto LAB_08062168;
      }
    }
    Layer = 1;
  }
  return Layer;
}



int ActionRedo(int argc,char **argv,int x,int y)

{
  DataTypePtr *pDVar1;
  int iVar2;
  int iVar3;
  
  if (((Settings.Mode != 4) || (Crosshair.AttachedPolygon.PointN == 0)) &&
     (Crosshair.AttachedLine.State != 1)) {
    HideCrosshair('\x01');
    iVar2 = Redo('\x01');
    if (iVar2 != 0) {
      SetChangedFlag('\x01');
      if ((Settings.Mode == 2) && (Crosshair.AttachedLine.State != 0)) {
        if (PCB->SilkActive == '\0') {
          iVar3 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
          iVar2 = *(int *)(&PCB->Data->field_0x70 + LayerStack[0] * 0x5c);
        }
        else {
          pDVar1 = PCB->Data;
          iVar2 = ((uint)(Settings.ShowSolderSide == '\0') + pDVar1->LayerN) * 0x5c;
          iVar3 = &pDVar1->field_0x4c + iVar2;
          iVar2 = *(int *)(&pDVar1->field_0x70 + iVar2);
        }
        iVar2 = iVar2 + (*(int *)(iVar3 + 4) + -1) * 0x58;
        Crosshair.AttachedLine.Point1.X = *(LocationType *)(iVar2 + 0x40);
        Crosshair.AttachedLine.Point1.Y = *(LocationType *)(iVar2 + 0x44);
        addedLines = addedLines + 1;
        Crosshair.AttachedLine.Point2.X = Crosshair.AttachedLine.Point1.X;
        Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedLine.Point1.Y;
      }
    }
    RestoreCrosshair('\x01');
    return 0;
  }
  return 1;
}



int ActionToggleHideName(int argc,char **argv,int x,int y)

{
  String Ident;
  uint uVar1;
  bool bVar2;
  int Type;
  DataTypePtr *pDVar3;
  ElementTypePtr *Element;
  int iVar4;
  void *local_28;
  ElementTypePtr *local_24;
  void *local_20 [4];
  
  if (((0 < argc) && (Ident = *argv, Ident != (String)0x0)) && (PCB->ElementOn != '\0')) {
    HideCrosshair('\x01');
    Type = GetFunctionID(Ident);
    if ((Type == 0x46) || (Type == 0x48)) {
      pDVar3 = PCB->Data;
      Type = pDVar3->ElementN - 1;
      if (Type != -1) {
        bVar2 = false;
        iVar4 = pDVar3->ElementN * 300;
        while( true ) {
          Element = (ElementTypePtr *)((int)&pDVar3->Element[-1].BoundingBox.X1 + iVar4);
          uVar1 = (Element->Flags).f;
          if ((((uVar1 & 0x40) != 0) || ((*(byte *)&Element->Name[1].Flags.f & 0x40) != 0)) &&
             (((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide || (PCB->InvisibleObjectsOn != '\0')
              ))) {
            AddObjectToFlagUndoList(2,Element,Element,Element);
            EraseElementName(Element);
            (Element->Flags).f = (Element->Flags).f ^ 0x10;
            DrawElementName(Element,0);
            bVar2 = true;
          }
          Type = Type + -1;
          if (Type == -1) break;
          pDVar3 = PCB->Data;
          iVar4 = iVar4 + -300;
        }
        if (bVar2) {
          Draw();
          IncrementUndoSerialNumber();
        }
      }
    }
    else {
      if (Type == 0x2e) {
        (*gui->get_coords)("Select an Object",&x,&y);
        Type = SearchScreen(x,y,2,local_20,&local_24,&local_28);
        if (Type != 0) {
          AddObjectToFlagUndoList(Type,local_20[0],local_24,local_28);
          EraseElementName(local_24);
          (local_24->Flags).f = (local_24->Flags).f ^ 0x10;
          DrawElementName(local_24,0);
          Draw();
          IncrementUndoSerialNumber();
        }
      }
    }
    RestoreCrosshair('\x01');
    return 0;
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x08062974)
// WARNING: Removing unreachable block (ram,0x08062784)
// WARNING: Removing unreachable block (ram,0x080627c0)

int ActionSetValue(int argc,char **argv,int x,int y)

{
  String Ident;
  char *val;
  float fVar1;
  int iVar2;
  char *units;
  float Grid;
  Boolean local_1d [13];
  
  if ((argc < 1) || (Ident = *argv, argc == 1)) goto LAB_08062670;
  units = (char *)0x0;
  val = argv[1];
  if (argc != 2) {
    units = argv[2];
  }
  if ((val == (char *)0x0) || (Ident == (String)0x0)) goto LAB_08062670;
  HideCrosshair('\x01');
  Grid = GetValue(val,units,local_1d);
  iVar2 = GetFunctionID(Ident);
  if (iVar2 == 0x52) {
LAB_080626e8:
    Grid = Grid / 45.00000000;
    if (local_1d[0] == '\0') {
      Grid = (float)Settings.TextScale + Grid;
    }
    SetTextScale((short)ROUND(Grid));
    goto LAB_08062858;
  }
  if (iVar2 < 0x53) {
    if (iVar2 == 0x1f) {
      if (local_1d[0] == '\0') {
        if (Grid == (float)(int)ROUND(Grid)) {
          fVar1 = (float)PCB->Grid;
          if (fVar1 != (float)(int)ROUND(fVar1)) goto LAB_08062788;
        }
        else {
          fVar1 = (float)PCB->Grid;
LAB_08062788:
          if (((Grid == (float)(int)ROUND(Grid)) || (fVar1 == (float)(int)ROUND(fVar1))) &&
             (fVar1 != 1.00000000)) {
            Message("Don\'t combine metric/English grids like that!\n");
            goto LAB_08062858;
          }
        }
        if (fVar1 + Grid < 1.00000000) {
          SetGrid(1.00000000,'\0');
          goto LAB_08062858;
        }
        if (fVar1 != 1.00000000) {
          SetGrid(fVar1 + Grid,'\0');
          goto LAB_08062858;
        }
      }
      SetGrid(Grid,'\0');
LAB_08062858:
      RestoreCrosshair('\x01');
      return 0;
    }
    if ((0x1e < iVar2) && (iVar2 - 0x25U < 2)) {
      if (local_1d[0] == '\0') {
        Grid = (float)Settings.LineThickness + Grid;
      }
      SetLineSize((int)ROUND(Grid));
      hid_action("RouteStylesChanged");
      goto LAB_08062858;
    }
  }
  else {
    if (iVar2 == 0x6d) {
LAB_08062816:
      if (local_1d[0] == '\0') {
        Grid = (float)Settings.ViaThickness + Grid;
      }
      SetViaSize((int)ROUND(Grid),'\0');
      hid_action("RouteStylesChanged");
      goto LAB_08062858;
    }
    if (iVar2 < 0x6e) {
      if (iVar2 == 0x54) goto LAB_080626e8;
    }
    else {
      if (iVar2 == 0x70) {
        if (local_1d[0] == '\0') {
          Grid = (float)Settings.ViaDrillingHole + Grid;
        }
        SetViaDrillingHole((int)ROUND(Grid),'\0');
        hid_action("RouteStylesChanged");
        goto LAB_08062858;
      }
      if (iVar2 == 0x71) goto LAB_08062816;
    }
  }
  RestoreCrosshair('\x01');
LAB_08062670:
  Message("Syntax error.  Usage:\n%s\n",
          "SetValue(Grid|Line|LineSize|Text|TextScale|ViaDrillingHole|Via|ViaSize, delta)");
  return 1;
}



int ActionSetThermal(int argc,char **argv,int x,int y)

{
  int therm_style;
  String Ident;
  int Type;
  char *val;
  float fVar1;
  void *local_1c;
  void *local_18;
  void *local_14;
  Boolean local_d;
  
  if (argc < 1) goto LAB_080629f8;
  Ident = *argv;
  if (argc == 1) {
    val = (char *)0x0;
  }
  else {
    val = argv[1];
  }
  if ((((Ident == (String)0x0) || (val == (char *)0x0)) || (*Ident == '\0')) || (*val == '\0'))
  goto LAB_080629f8;
  fVar1 = GetValue(val,(char *)0x0,&local_d);
  HideCrosshair('\x01');
  if (local_d == '\0') {
switchD_08062a8b_caseD_2f:
    RestoreCrosshair('\x01');
LAB_080629f8:
    Message("Syntax error.  Usage:\n%s\n",
            "SetThermal(Object|SelectedPins|SelectedVias|Selected, Style)");
    return 1;
  }
  therm_style = (int)ROUND(fVar1);
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
    Type = SearchScreen(Crosshair.X,Crosshair.Y,0x101,&local_14,&local_18,&local_1c);
    if (Type != 0) {
      ChangeObjectThermal(Type,local_14,local_18,local_1c,therm_style);
      IncrementUndoSerialNumber();
      Draw();
    }
    break;
  default:
    goto switchD_08062a8b_caseD_2f;
  case 0x46:
  case 0x48:
    ChangeSelectedThermals(0x101,therm_style);
    break;
  case 0x4d:
    ChangeSelectedThermals(0x100,therm_style);
    break;
  case 0x4f:
    ChangeSelectedThermals(1,therm_style);
  }
  RestoreCrosshair('\x01');
  return 0;
}



int ActionSaveTo(int argc,char **argv,int x,int y)

{
  char *S;
  PCBTypePtr pPVar1;
  char "ActionSaveTo" [13];
  int iVar2;
  char *__s1;
  FILE *FP;
  ElementTypePtr *local_14;
  Boolean result;
  
  __s1 = *argv;
  S = argv[1];
  iVar2 = strcasecmp(__s1,"Layout");
  if (iVar2 == 0) {
LAB_08062c58:
    SavePCB(PCB->Filename);
    return 0;
  }
  if (argc == 2) {
    iVar2 = strcasecmp(__s1,"LayoutAs");
    if (iVar2 == 0) {
      SaveFree(PCB->Filename);
      pPVar1 = PCB;
      PCB->Filename = (char *)0x0;
      __s1 = MyStrdup(S,"ActionSaveTo");
      pPVar1->Filename = __s1;
      goto LAB_08062c58;
    }
    iVar2 = strcasecmp(__s1,"AllConnections");
    if (iVar2 == 0) {
      FP = CheckAndOpenFile(S,'\x01','\0',&result,(Boolean *)0x0);
      if (FP != (FILE *)0x0) {
        LookupConnectionsToAllElements(FP);
LAB_08062cb1:
        fclose((FILE *)FP);
        SetChangedFlag('\x01');
        return 0;
      }
    }
    else {
      iVar2 = strcasecmp(__s1,"AllUnusedPins");
      if (iVar2 == 0) {
        FP = CheckAndOpenFile(S,'\x01','\0',&result,(Boolean *)0x0);
        if (FP != (FILE *)0x0) {
          LookupUnusedPins(FP);
          goto LAB_08062cb1;
        }
      }
      else {
        iVar2 = strcasecmp(__s1,"ElementConnections");
        if (iVar2 != 0) {
          iVar2 = strcasecmp(__s1,"PasteBuffer");
          if (iVar2 == 0) {
            iVar2 = SaveBufferElements(S);
            return iVar2;
          }
          goto LAB_08062c08;
        }
        iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,2,&local_14,&local_14,&local_14);
        if ((iVar2 != 0) &&
           (FP = CheckAndOpenFile(S,'\x01','\0',&result,(Boolean *)0x0), FP != (FILE *)0x0)) {
          LookupElementConnections(local_14,FP);
          fclose((FILE *)FP);
          SetChangedFlag('\x01');
          return 0;
        }
      }
    }
    iVar2 = 0;
  }
  else {
LAB_08062c08:
    Message("Syntax error.  Usage:\n%s\n",
                        
            "SaveTo(Layout|LayoutAs,filename)\nSaveTo(AllConnections|AllUnusedPins|ElementConnections,filename)\nSaveTo(PasteBuffer,filename)"
           );
    iVar2 = 1;
  }
  return iVar2;
}



int ActionSaveSettings(int argc,char **argv,int x,int y)

{
  uint locally;
  int iVar1;
  
  locally = 0;
  if (0 < argc) {
    iVar1 = strncasecmp(*argv,"local",5);
    locally = (uint)(iVar1 == 0);
  }
  hid_save_settings(locally);
  return 0;
}



int ActionUnselect(int argc,char **argv,int x,int y)

{
  String Ident;
  Boolean BVar1;
  int Type;
  char *Pattern;
  BoxType box;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    return 0;
  }
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  if (Type == 0x2f) {
    Type = -1;
  }
  else {
    if (Type < 0x30) {
      if (Type == 7) {
        box.X1 = Crosshair.AttachedBox.Point2.X;
        if (Crosshair.AttachedBox.Point1.X <= Crosshair.AttachedBox.Point2.X) {
          box.X1 = Crosshair.AttachedBox.Point1.X;
        }
        box.Y1 = Crosshair.AttachedBox.Point2.Y;
        if (Crosshair.AttachedBox.Point1.Y <= Crosshair.AttachedBox.Point2.Y) {
          box.Y1 = Crosshair.AttachedBox.Point1.Y;
        }
        box.X2 = Crosshair.AttachedBox.Point2.X;
        if (Crosshair.AttachedBox.Point2.X <= Crosshair.AttachedBox.Point1.X) {
          box.X2 = Crosshair.AttachedBox.Point1.X;
        }
        box.Y2 = Crosshair.AttachedBox.Point2.Y;
        if (Crosshair.AttachedBox.Point2.Y <= Crosshair.AttachedBox.Point1.Y) {
          box.Y2 = Crosshair.AttachedBox.Point1.Y;
        }
        NotifyBlock();
        if ((Crosshair.AttachedBox.State == 2) &&
           (BVar1 = SelectBlock((BoxTypePtr)&box,'\0'), BVar1 != '\0')) {
          SetChangedFlag('\x01');
          Crosshair.AttachedBox.State = 0;
        }
        goto LAB_08062f36;
      }
      if (Type < 8) {
        if (Type != 1) {
LAB_08062e46:
          RestoreCrosshair('\x01');
          Message("Syntax error.  Usage:\n%s\n",
                                    
                  "Unselect(All|Block|Connection)\nUnselect(ElementByName|ObjectByName|PadByName|PinByName)\nUnselect(ElementByName|ObjectByName|PadByName|PinByName, Name)\nUnselect(TextByName|ViaByName)\nUnselect(TextByName|ViaByName, Name)\n"
                 );
          return 1;
        }
        box.X1 = -10000000;
        box.Y1 = -10000000;
        box.X2 = 10000000;
        box.Y2 = 10000000;
        BVar1 = SelectBlock((BoxTypePtr)&box,'\0');
        if (BVar1 == '\0') goto LAB_08062f36;
      }
      else {
        if (Type != 0xf) {
          if (Type != 0x18) goto LAB_08062e46;
          Type = 2;
          goto commonByName;
        }
        BVar1 = SelectConnection('\0');
        if (BVar1 == '\0') goto LAB_08062f36;
        IncrementUndoSerialNumber();
      }
      SetChangedFlag('\x01');
      goto LAB_08062f36;
    }
    if (Type == 0x32) {
      Type = 0x100;
    }
    else {
      if (Type < 0x33) {
        if (Type != 0x31) goto LAB_08062e46;
        Type = 0x200;
      }
      else {
        if (Type == 0x53) {
          Type = 0x10;
        }
        else {
          if (Type != 0x6e) goto LAB_08062e46;
          Type = 1;
        }
      }
    }
  }
commonByName:
  if (((argc != 1) && (Pattern = argv[1], Pattern != (char *)0x0)) ||
     (Pattern = (*gui->prompt_for)("Enter pattern:",""), Pattern != (char *)0x0)) {
    BVar1 = SelectObjectByName(Type,Pattern,'\0');
    if (BVar1 != '\0') {
      SetChangedFlag('\x01');
    }
    if ((argc == 1) || (argv[1] == (char *)0x0)) {
      free(Pattern);
    }
  }
LAB_08062f36:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionRemoveSelected(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  
  HideCrosshair('\x01');
  BVar1 = RemoveSelected();
  if (BVar1 != '\0') {
    SetChangedFlag('\x01');
  }
  RestoreCrosshair('\x01');
  return 0;
}



int ActionAtomic(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  if (argc != 1) {
    Message("Syntax error.  Usage:\n%s\n","Atomic(Save|Restore|Close|Block)");
    return 1;
  }
  iVar1 = GetFunctionID(*argv);
  if (iVar1 == 0xe) {
    RestoreUndoSerialNumber();
    IncrementUndoSerialNumber();
    return 0;
  }
  if (iVar1 < 0xf) {
    if (iVar1 == 7) {
      RestoreUndoSerialNumber();
      if (Bumped != '\0') {
        IncrementUndoSerialNumber();
        return 0;
      }
    }
  }
  else {
    if (iVar1 == 0x42) {
      RestoreUndoSerialNumber();
      return 0;
    }
    if (iVar1 == 0x44) {
      SaveUndoSerialNumber();
      return 0;
    }
  }
  return 0;
}



int ActionSelect(int argc,char **argv,int x,int y)

{
  double dVar1;
  String Ident;
  Boolean BVar2;
  char cVar3;
  int Type;
  char *Pattern;
  BoxType box;
  int local_24;
  int local_20 [4];
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    return 0;
  }
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  switch(Type) {
  default:
    RestoreCrosshair('\x01');
    Message("Syntax error.  Usage:\n%s\n",
                        
            "Select(ToggleObject)\nSelect(All|Block|Connection)\nSelect(ElementByName|ObjectByName|PadByName|PinByName)\nSelect(ElementByName|ObjectByName|PadByName|PinByName, Name)\nSelect(TextByName|ViaByName)\nSelect(TextByName|ViaByName, Name)\nSelect(Convert)"
           );
    return 1;
  case 1:
    box.X1 = -10000000;
    box.Y1 = -10000000;
    box.X2 = 10000000;
    box.Y2 = 10000000;
    cVar3 = SelectBlock((BoxTypePtr)&box,'\x01');
    goto joined_r0x080632b0;
  case 7:
    box.X1 = Crosshair.AttachedBox.Point2.X;
    if (Crosshair.AttachedBox.Point1.X <= Crosshair.AttachedBox.Point2.X) {
      box.X1 = Crosshair.AttachedBox.Point1.X;
    }
    box.Y1 = Crosshair.AttachedBox.Point2.Y;
    if (Crosshair.AttachedBox.Point1.Y <= Crosshair.AttachedBox.Point2.Y) {
      box.Y1 = Crosshair.AttachedBox.Point1.Y;
    }
    box.X2 = Crosshair.AttachedBox.Point2.X;
    if (Crosshair.AttachedBox.Point2.X <= Crosshair.AttachedBox.Point1.X) {
      box.X2 = Crosshair.AttachedBox.Point1.X;
    }
    box.Y2 = Crosshair.AttachedBox.Point2.Y;
    if (Crosshair.AttachedBox.Point2.Y <= Crosshair.AttachedBox.Point1.Y) {
      box.Y2 = Crosshair.AttachedBox.Point1.Y;
    }
    NotifyBlock();
    if ((Crosshair.AttachedBox.State == 2) &&
       (BVar2 = SelectBlock((BoxTypePtr)&box,'\x01'), BVar2 != '\0')) {
      SetChangedFlag('\x01');
      Crosshair.AttachedBox.State = 0;
    }
    goto LAB_08063266;
  case 0xf:
    BVar2 = SelectConnection('\x01');
    if (BVar2 == '\0') goto LAB_08063266;
    IncrementUndoSerialNumber();
    goto LAB_080632b2;
  case 0x10:
    Note.Buffer = Settings.BufferNumber;
    SetBufferNumber(4);
    ClearBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber));
    (*gui->get_coords)("Select the Element\'s Mark Location",local_20,&local_24);
    dVar1 = PCB->Grid;
    local_20[0] = (int)ROUND((double)PCB->GridOffsetX +
                             (double)(int)ROUND(((double)(local_20[0] - PCB->GridOffsetX) +
                                                dVar1 * 0.50000000) / dVar1) * dVar1 + 0.50000000);
    local_24 = (int)ROUND((double)PCB->GridOffsetY +
                          (double)(int)ROUND(((double)(local_24 - PCB->GridOffsetY) +
                                             dVar1 * 0.50000000) / dVar1) * dVar1 + 0.50000000);
    AddSelectedToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),local_20[0],local_24,'\x01'
                       );
    SaveUndoSerialNumber();
    RemoveSelected();
    ConvertBufferToElement((BufferTypePtr)(Buffers + Settings.BufferNumber));
    RestoreUndoSerialNumber();
    CopyPastebufferToLayout(local_20[0],local_24);
    SetBufferNumber(Note.Buffer);
    goto LAB_08063266;
  case 0x18:
    Type = 2;
    break;
  case 0x2e:
  case 0x5f:
    cVar3 = SelectObject();
joined_r0x080632b0:
    if (cVar3 != '\0') {
LAB_080632b2:
      SetChangedFlag('\x01');
    }
    goto LAB_08063266;
  case 0x2f:
    Type = -1;
    break;
  case 0x31:
    Type = 0x200;
    break;
  case 0x32:
    Type = 0x100;
    break;
  case 0x53:
    Type = 0x10;
    break;
  case 0x6e:
    Type = 1;
  }
  if (((argc != 1) && (Pattern = argv[1], Pattern != (char *)0x0)) ||
     (Pattern = (*gui->prompt_for)("Enter pattern:",""), Pattern != (char *)0x0)) {
    BVar2 = SelectObjectByName(Type,Pattern,'\x01');
    if (BVar2 != '\0') {
      SetChangedFlag('\x01');
    }
    if ((argc == 1) || (argv[1] == (char *)0x0)) {
      free(Pattern);
    }
  }
LAB_08063266:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionRipUp(int argc,char **argv,int x,int y)

{
  String Ident;
  uint uVar1;
  bool bVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  uint uVar5;
  DataTypePtr *pDVar6;
  void *Ptr2;
  PinTypePtr *Ptr1;
  DataTypePtr *pDVar7;
  uint uVar8;
  int iVar9;
  void *Ptr1_00;
  uint local_30;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar3 = GetFunctionID(Ident);
  if (iVar3 == 0x17) {
    iVar3 = SearchScreen(Crosshair.X,Crosshair.Y,2,local_20,&local_24,&local_28);
    if (iVar3 != 0) {
      Note.Buffer = Settings.BufferNumber;
      SetBufferNumber(4);
      ClearBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber));
      CopyObjectToBuffer(Buffers[Settings.BufferNumber].Data,PCB->Data,2,local_20[0],local_24,
                         local_28);
      SmashBufferElement((BufferTypePtr)(Buffers + Settings.BufferNumber));
      iVar3 = Settings.BufferNumber;
      Buffers[Settings.BufferNumber].X = 0;
      Buffers[iVar3].Y = 0;
      SaveUndoSerialNumber();
      EraseObject(2,local_20[0],local_20[0]);
      MoveObjectToRemoveUndoList(2,local_20[0],local_24,local_28);
      RestoreUndoSerialNumber();
      CopyPastebufferToLayout(0,0);
      SetBufferNumber(Note.Buffer);
      SetChangedFlag('\x01');
    }
  }
  else {
    if (iVar3 == 0x46) {
      bVar2 = false;
      pDVar7 = PCB->Data;
      Ptr1_00 = (void *)&pDVar7->field_0x4c;
      pPVar4 = PCB;
      if (pDVar7->LayerN != -2) {
        uVar5 = 0;
        do {
          if (*(char *)((int)Ptr1_00 + 0x44) != '\0') {
            iVar3 = *(int *)((int)Ptr1_00 + 4) + -1;
            if (iVar3 != -1) {
              iVar9 = *(int *)((int)Ptr1_00 + 4) * 0x58 + -0x58;
              do {
                while (Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x24) + iVar9),
                      (*(uint *)((int)Ptr2 + 0x14) & 0x20c0) == 0xc0) {
                  iVar3 = iVar3 + -1;
                  iVar9 = iVar9 + -0x58;
                  RemoveObject(4,Ptr1_00,Ptr2,Ptr2);
                  bVar2 = true;
                  pPVar4 = PCB;
                  if (iVar3 == -1) goto LAB_08063678;
                }
                iVar3 = iVar3 + -1;
                iVar9 = iVar9 + -0x58;
                pPVar4 = PCB;
              } while (iVar3 != -1);
            }
          }
LAB_08063678:
          pDVar7 = pPVar4->Data;
          uVar5 = uVar5 + 1;
          if (pDVar7->LayerN + 2U <= uVar5) break;
          Ptr1_00 = (void *)((int)Ptr1_00 + 0x5c);
        } while( true );
      }
      if (pPVar4->ViaOn != '\0') {
        pDVar6 = pPVar4->Data;
        if (pDVar6->ViaN != 0) {
          uVar8 = 0;
          uVar5 = pDVar7->ViaN;
          do {
            Ptr1 = pDVar6->Via + uVar8;
            if (((Ptr1->Flags).f & 0x20c0) == 0xc0) {
              RemoveObject(1,Ptr1,Ptr1,Ptr1);
              bVar2 = true;
              pPVar4 = PCB;
            }
            pDVar6 = pPVar4->Data;
            uVar1 = pDVar6->ViaN;
          } while ((uVar1 != 0) &&
                  (uVar8 = (uVar1 + 1 + uVar8) - uVar5, uVar5 = uVar1, uVar8 < uVar1));
        }
      }
    }
    else {
      if (iVar3 != 1) goto LAB_080635c6;
      local_30 = 0;
      bVar2 = false;
      pDVar7 = PCB->Data;
      Ptr1_00 = (void *)&pDVar7->field_0x4c;
      pPVar4 = PCB;
      if (pDVar7->LayerN != -2) {
        bVar2 = false;
        do {
          iVar3 = *(int *)((int)Ptr1_00 + 4) + -1;
          if (iVar3 != -1) {
            iVar9 = *(int *)((int)Ptr1_00 + 4) * 0x58 + -0x58;
            do {
              while (Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x24) + iVar9),
                    (*(uint *)((int)Ptr2 + 0x14) & 0x2080) == 0x80) {
                iVar3 = iVar3 + -1;
                iVar9 = iVar9 + -0x58;
                RemoveObject(4,Ptr1_00,Ptr2,Ptr2);
                bVar2 = true;
                pPVar4 = PCB;
                if (iVar3 == -1) goto LAB_080637b5;
              }
              iVar3 = iVar3 + -1;
              iVar9 = iVar9 + -0x58;
              pPVar4 = PCB;
            } while (iVar3 != -1);
          }
LAB_080637b5:
          pDVar7 = pPVar4->Data;
          local_30 = local_30 + 1;
          if (pDVar7->LayerN + 2U <= local_30) break;
          Ptr1_00 = (void *)((int)Ptr1_00 + 0x5c);
        } while( true );
      }
      if (pDVar7->ViaN != 0) {
        uVar8 = 0;
        uVar5 = pDVar7->ViaN;
        do {
          Ptr1 = pDVar7->Via + uVar8;
          if (((Ptr1->Flags).f & 0x2080) == 0x80) {
            RemoveObject(1,Ptr1,Ptr1,Ptr1);
            bVar2 = true;
            pPVar4 = PCB;
          }
          pDVar7 = pPVar4->Data;
          uVar1 = pDVar7->ViaN;
        } while ((uVar1 != 0) && (uVar8 = (uVar1 + 1 + uVar8) - uVar5, uVar5 = uVar1, uVar8 < uVar1)
                );
      }
    }
    if (bVar2) {
      IncrementUndoSerialNumber();
      SetChangedFlag('\x01');
    }
  }
LAB_080635c6:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionChangePinName(int argc,char **argv,int x,int y)

{
  void *Ptr3;
  char *__s1;
  char *__s1_00;
  char *pcVar1;
  bool bVar2;
  DataTypePtr *pDVar3;
  int iVar4;
  uint uVar5;
  undefined4 uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  int local_30;
  int local_2c;
  
  if (argc != 3) {
    Message("Syntax error.  Usage:\n%s\n","ChangePinName(ElementName,PinNumber,PinName)");
    return 1;
  }
  __s1 = *argv;
  __s1_00 = argv[1];
  pcVar1 = argv[2];
  pDVar3 = PCB->Data;
  local_2c = pDVar3->ElementN - 1;
  if (local_2c != -1) {
    bVar2 = false;
    iVar9 = pDVar3->ElementN * 300;
    while( true ) {
      local_30 = iVar9 + -300;
      if (__s1 != (char *)0x0) {
        iVar9 = (int)&pDVar3->Element[-1].BoundingBox.X1 + iVar9;
        if ((*(char **)(iVar9 + 0x94) != (char *)0x0) &&
           (iVar4 = strcmp(__s1,*(char **)(iVar9 + 0x94)), iVar4 == 0)) {
          if (*(uint *)(iVar9 + 0xe0) != 0) {
            uVar7 = 0;
            uVar5 = *(uint *)(iVar9 + 0xe0);
            do {
              uVar8 = uVar5;
              if (__s1_00 != (char *)0x0) {
                Ptr3 = (void *)(*(int *)(iVar9 + 0x100) + uVar7 * 0x4c);
                if (*(char **)((int)Ptr3 + 0x40) != (char *)0x0) {
                  iVar4 = strcmp(__s1_00,*(char **)((int)Ptr3 + 0x40));
                  if (iVar4 == 0) {
                    AddObjectToChangeNameUndoList
                              (0x100,(void *)0x0,(void *)0x0,Ptr3,*(char **)((int)Ptr3 + 0x3c));
                    uVar6 = __strdup(pcVar1);
                    *(undefined4 *)((int)Ptr3 + 0x3c) = uVar6;
                    SetChangedFlag('\x01');
                    bVar2 = true;
                  }
                  uVar8 = *(uint *)(iVar9 + 0xe0);
                }
              }
            } while ((uVar8 != 0) &&
                    (uVar7 = (uVar7 + 1 + uVar8) - uVar5, uVar5 = uVar8, uVar7 < uVar8));
          }
          uVar5 = *(uint *)(iVar9 + 0xe8);
          uVar8 = 0;
          uVar7 = uVar5;
          while ((uVar7 != 0 && (uVar8 < uVar7))) {
            if (__s1_00 != (char *)0x0) {
              Ptr3 = (void *)(*(int *)(iVar9 + 0x104) + uVar8 * 0x68);
              if ((*(char **)((int)Ptr3 + 0x5c) != (char *)0x0) &&
                 (iVar4 = strcmp(__s1_00,*(char **)((int)Ptr3 + 0x5c)), iVar4 == 0)) {
                AddObjectToChangeNameUndoList
                          (0x200,(void *)0x0,(void *)0x0,Ptr3,*(char **)((int)Ptr3 + 0x58));
                uVar6 = __strdup(pcVar1);
                *(undefined4 *)((int)Ptr3 + 0x58) = uVar6;
                SetChangedFlag('\x01');
                bVar2 = true;
                uVar7 = *(uint *)(iVar9 + 0xe8);
              }
            }
            uVar8 = uVar8 + (uVar5 == uVar7);
          }
        }
      }
      local_2c = local_2c + -1;
      if (local_2c == -1) break;
      pDVar3 = PCB->Data;
      iVar9 = local_30;
    }
    if (bVar2) {
      IncrementUndoSerialNumber();
      (*gui->invalidate_all)();
      return 0;
    }
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

int ActionRenumber(int argc,char **argv,int x,int y)

{
  char cVar1;
  Cardinal CVar2;
  char "ActionRenumber" [15];
  char *default_file;
  FILE *__stream;
  int iVar3;
  ElementTypePtr **__ptr;
  void *__ptr_00;
  void *pvVar4;
  void *pvVar5;
  uint uVar6;
  char *__s1;
  size_t __size;
  undefined4 uVar7;
  char **ppcVar8;
  size_t sVar9;
  void *pvVar10;
  int iVar11;
  ElementTypePtr **ppEVar12;
  ElementTypePtr *__s2;
  uint uVar13;
  ElementTypePtr **ppEVar14;
  PCBTypePtr pPVar15;
  ElementTypePtr *local_88;
  ElementTypePtr **ppEVar16;
  int iVar17;
  bool bVar18;
  char *local_84;
  uint local_58;
  uint local_4c;
  char **local_44;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  PCBTypePtr local_28;
  int local_24;
  
  if (argc < 1) {
    local_84 = (*gui->fileselect)("Save Renumber Annotation File As ...",
                                                                    
                                  "Choose a file to record the renumbering to.\nThis file may be used to back annotate the\nchange to the schematics.\n"
                                  ,default_file,".eco","eco",0);
    bVar18 = local_84 != (char *)0x0;
  }
  else {
    bVar18 = false;
    local_84 = *argv;
  }
  if (default_file != (char *)0x0) {
    free(default_file);
    default_file = (char *)0x0;
  }
  if ((local_84 != (char *)0x0) && (*local_84 != '\0')) {
    default_file = (char *)__strdup(local_84);
  }
  __stream = fopen(local_84,"r");
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
    iVar3 = (*gui->confirm_dialog)("File exists!  Ok to overwrite?",0);
    if (iVar3 == 0) {
      if (!bVar18) {
        return 0;
      }
      free(local_84);
      return 0;
    }
  }
  __stream = fopen(local_84,"w");
  if (__stream == (FILE *)0x0) {
    Message("Could not open %s\n",local_84);
    if (!bVar18) {
      return 1;
    }
    free(local_84);
    return 1;
  }
  if (bVar18) {
    free(local_84);
  }
  __fprintf_chk(__stream,1,"*COMMENT* PCB Annotation File\n");
  local_84 = "*FILEVERSION* 20061031\n";
  __fprintf_chk(__stream,1,"*FILEVERSION* 20061031\n");
  __ptr = (ElementTypePtr **)calloc(PCB->Data->ElementN,4);
  __ptr_00 = calloc(PCB->Data->ElementN,4);
  pvVar4 = calloc(PCB->Data->ElementN,4);
  pvVar5 = calloc(PCB->Data->ElementN,4);
  if ((((__ptr_00 == (void *)0x0) || (__ptr == (ElementTypePtr **)0x0)) || (pvVar5 == (void *)0x0))
     || (pvVar4 == (void *)0x0)) {
    local_84 = "calloc() failed in %s\n";
LAB_080646b7:
    __fprintf_chk(stderr,1,local_84,0x813c705);
                    // WARNING: Subroutine does not return
    exit(1);
  }
  local_28 = PCB;
  CVar2 = PCB->Data->ElementN;
  local_24 = CVar2 - 1;
  if (local_24 != -1) {
    local_4c = 0;
    local_30 = 0;
    local_2c = CVar2 * 300 + -300;
    local_88 = PCB->Data->Element + (CVar2 - 1);
    if ((*(byte *)((int)&local_88->Name[0].Flags.f + 1) & 0x20) != 0) goto LAB_08063ec8;
    do {
      if ((*(byte *)((int)&(local_88->Flags).f + 1) & 0x20) != 0) goto LAB_08063ec8;
      uVar6 = 0;
      __s2 = *__ptr;
      ppEVar14 = __ptr;
      if (__s2 != (ElementTypePtr *)0x0) {
        iVar3 = local_88->MarkY;
        iVar17 = __s2->MarkY;
        if (iVar17 < iVar3) {
          uVar6 = 0;
          do {
            ppEVar14 = ppEVar14 + 1;
            __s2 = *ppEVar14;
            uVar6 = uVar6 + 1;
            if (__s2 == (ElementTypePtr *)0x0) goto LAB_08063e5f;
            iVar17 = __s2->MarkY;
          } while (iVar17 < iVar3);
        }
        else {
          uVar6 = 0;
        }
        if ((iVar3 == iVar17) && (__s2->MarkX < local_88->MarkX)) {
          uVar6 = uVar6 + 1;
          ppEVar14 = __ptr + uVar6;
          while (((__s2 = *ppEVar14, __s2 != (ElementTypePtr *)0x0 && (__s2->MarkY == iVar3)) &&
                 (__s2->MarkX < local_88->MarkX))) {
            uVar6 = uVar6 + 1;
            ppEVar14 = ppEVar14 + 1;
          }
        }
      }
LAB_08063e5f:
      if (uVar6 < local_4c) {
        ppEVar16 = __ptr + (local_4c - 1);
        ppEVar12 = __ptr + local_4c;
        uVar13 = local_4c;
        do {
          __s2 = *ppEVar16;
          uVar13 = uVar13 - 1;
          ppEVar16 = ppEVar16 + -1;
          *ppEVar12 = __s2;
          ppEVar12 = ppEVar12 + -1;
        } while (uVar6 < uVar13);
      }
      local_4c = local_4c + 1;
      *ppEVar14 = local_88;
      while( true ) {
        uVar6 = local_30;
        local_24 = local_24 + -1;
        iVar3 = local_2c + -300;
        if (local_24 == -1) {
          local_58 = (local_28->Flags).f;
          (local_28->Flags).f = local_58 & 0xfffffbff;
          local_58 = local_58 & 0x400;
          local_88 = (ElementTypePtr *)&DAT_00000008;
          local_44 = (char **)calloc(100,8);
          if (local_4c == 0) goto LAB_08064697;
          local_2c = 0;
          local_30 = 100;
          local_38 = 0;
          bVar18 = false;
          goto LAB_08063ff0;
        }
        local_88 = (ElementTypePtr *)((int)&local_28->Data->Element[-1].BoundingBox.X1 + local_2c);
        local_2c = iVar3;
        if ((*(byte *)((int)&local_88->Name[0].Flags.f + 1) & 0x20) == 0) break;
LAB_08063ec8:
        __s1 = local_88->Name[1].TextString;
        if ((__s1 == (char *)0x0) || (*__s1 == '\0')) {
          __s1 = "(unknown)";
        }
        local_84 = "*WARN* Element \"%s\" at (%d,%d) is locked and will not be renumbered.\n";
        __fprintf_chk(__stream,1,
                      "*WARN* Element \"%s\" at (%d,%d) is locked and will not be renumbered.\n",
                      __s1,local_88->MarkX,local_88->MarkY);
        *(ElementTypePtr **)((int)__ptr_00 + local_30 * 4) = local_88;
        local_28 = PCB;
        local_30 = local_30 + 1;
      }
    } while( true );
  }
  local_58 = (PCB->Flags).f;
  (PCB->Flags).f = local_58 & 0xfffffbff;
  local_58 = local_58 & 0x400;
  local_44 = (char **)calloc(100,8);
LAB_08064697:
  local_2c = 0;
  bVar18 = false;
LAB_0806428f:
  fclose(__stream);
  if (local_58 != 0) {
    (PCB->Flags).f = (PCB->Flags).f | 0x400;
  }
  if (bVar18) {
    AddNetlistLibToUndoList((LibraryTypePtr)&PCB->NetlistLib);
    if ((PCB->NetlistLib).MenuN != 0) {
      local_28 = (PCBTypePtr)0x0;
      local_38 = 0;
      pPVar15 = PCB;
      do {
        iVar17 = 0;
        iVar3 = (int)&((pPVar15->NetlistLib).Menu)->Name + (int)local_28;
        local_34 = 0;
        if (*(int *)(iVar3 + 0xc) != 0) {
          do {
            local_84 = (char *)__strdup(*(undefined4 *)(*(int *)(iVar3 + 0x14) + iVar17));
            if ((*local_84 == '\0') || (iVar3 = 0, *local_84 == '-')) {
              iVar11 = 1;
              __s1 = local_84;
            }
            else {
              do {
                iVar11 = iVar3;
                iVar3 = iVar11 + 1;
                __s1 = local_84 + iVar3;
                if (local_84[iVar3] == '-') break;
              } while (local_84[iVar3] != '\0');
              iVar11 = iVar11 + 2;
            }
            *__s1 = '\0';
            if (local_2c != 0) {
              uVar6 = 0;
              do {
                while( true ) {
                  iVar3 = strcmp(local_84,*(char **)((int)pvVar4 + uVar6 * 4));
                  if (iVar3 != 0) break;
                  free(*(void **)(*(int *)((int)&((PCB->NetlistLib).Menu)->Entry + (int)local_28) +
                                 iVar17));
                  iVar3 = *(int *)((int)&((PCB->NetlistLib).Menu)->Entry + (int)local_28);
                  ppcVar8 = (char **)((int)pvVar5 + uVar6 * 4);
                  __size = strlen(*ppcVar8);
                  sVar9 = strlen(local_84 + iVar11);
                  pvVar10 = calloc(1,__size + 2 + sVar9);
                  *(void **)(iVar17 + iVar3) = pvVar10;
                  __sprintf_chk(*(undefined4 *)
                                 (*(int *)((int)&((PCB->NetlistLib).Menu)->Entry + (int)local_28) +
                                 iVar17),1,0xffffffff,"%s-%s",*ppcVar8,local_84 + iVar11);
                  uVar6 = local_2c + 1;
                  if (local_2c <= uVar6) goto LAB_08064551;
                }
                uVar6 = uVar6 + 1;
              } while (uVar6 < local_2c);
            }
LAB_08064551:
            iVar17 = iVar17 + 0x18;
            free(local_84);
            local_34 = local_34 + 1;
            iVar3 = (int)&((PCB->NetlistLib).Menu)->Name + (int)local_28;
            pPVar15 = PCB;
          } while (local_34 <= *(uint *)(iVar3 + 0xc) && *(uint *)(iVar3 + 0xc) != local_34);
        }
        local_38 = local_38 + 1;
        local_28 = (PCBTypePtr)((int)local_28 + 0x1c);
      } while (local_38 <= (pPVar15->NetlistLib).MenuN && (pPVar15->NetlistLib).MenuN != local_38);
    }
    if (local_2c != 0) {
      uVar6 = 0;
      do {
        free(*(void **)((int)pvVar4 + uVar6 * 4));
        iVar3 = uVar6 * 4;
        uVar6 = uVar6 + 1;
        free(*(void **)((int)pvVar5 + iVar3));
      } while (uVar6 < local_2c);
    }
    hid_action("NetlistChanged");
    IncrementUndoSerialNumber();
    SetChangedFlag('\x01');
  }
  free(__ptr_00);
  free(__ptr);
  free(local_44);
  return 0;
LAB_08063ff0:
  do {
    __s2 = __ptr[local_38];
    __s1 = __s2->Name[1].TextString;
    if (__s1 == (char *)0x0) {
      local_84 = "*WARN* Element at (%d,%d) has no name.\n";
      local_88 = (ElementTypePtr *)&DAT_00000001;
      __fprintf_chk(__stream,1,"*WARN* Element at (%d,%d) has no name.\n",__s2->MarkX,__s2->MarkY);
    }
    else {
      local_28 = (PCBTypePtr)__strdup(__s1,local_88,local_84);
      cVar1 = *(char *)local_28;
      local_84 = (char *)local_28;
      if ((9 < (byte)(cVar1 - 0x30U)) && (cVar1 != '\0')) {
        while (cVar1 != '?') {
          local_84 = local_84 + 1;
          cVar1 = *local_84;
          if (((byte)(cVar1 - 0x30U) < 10) || (cVar1 == '\0')) break;
        }
      }
      *local_84 = '\0';
      local_24 = 0;
      uVar13 = 0;
      local_84 = *local_44;
      if (local_84 != (char *)0x0) {
        local_24 = 0;
        do {
          iVar3 = strcmp(local_84,(char *)local_28);
          if ((iVar3 == 0) || (local_30 <= uVar13)) break;
          uVar13 = uVar13 + 1;
          local_84 = local_44[uVar13 * 2];
          local_24 = uVar13 * 8;
        } while (local_84 != (char *)0x0);
      }
      if (uVar13 == local_30) {
        local_30 = local_30 + 100;
        local_44 = (char **)realloc(local_44,local_30);
        if (local_44 == (char **)0x0) {
          local_84 = "realloc failed() in %s\n";
          goto LAB_080646b7;
        }
        ppcVar8 = local_44 + uVar13 * 2;
        if (local_30 <= uVar13) goto LAB_080640b0;
        do {
          uVar13 = uVar13 + 1;
          *ppcVar8 = (char *)0x0;
          ppcVar8[1] = (char *)0x0;
          ppcVar8 = ppcVar8 + 2;
        } while (uVar13 < local_30);
        ppcVar8 = (char **)((int)local_44 + local_24);
        local_84 = *ppcVar8;
      }
      else {
LAB_080640b0:
        ppcVar8 = (char **)((int)local_44 + local_24);
        local_84 = *ppcVar8;
      }
      if (local_84 == (char *)0x0) {
        local_84 = (char *)__strdup(local_28);
        ppcVar8[1] = (char *)0x0;
        *ppcVar8 = local_84;
        local_84 = (char *)0x0;
        goto LAB_080640c3;
      }
      while( true ) {
        local_84 = ppcVar8[1];
LAB_080640c3:
        ppcVar8[1] = local_84 + 1;
        free(local_28);
        __size = strlen(*ppcVar8);
        local_84 = ppcVar8[1];
        __size = __size + 2;
        while ((char *)0xa < local_84) {
          __size = __size + 1;
          local_84 = (char *)((uint)local_84 / 10);
        }
        local_28 = (PCBTypePtr)calloc(1,__size);
        local_84 = (char *)0xffffffff;
        __sprintf_chk(local_28,1,0xffffffff,&DAT_08139f46,*ppcVar8,ppcVar8[1]);
        if (uVar6 == 0) break;
        uVar13 = 0;
        while( true ) {
          __s1 = *(char **)(*(int *)((int)__ptr_00 + uVar13 * 4) + 0x94);
          if ((__s1 == (char *)0x0) || (*__s1 == '\0')) {
            __s1 = "(unknown)";
          }
          iVar3 = strcmp(__s1,(char *)local_28);
          if (iVar3 == 0) break;
          uVar13 = uVar13 + 1;
          if (uVar6 <= uVar13) goto LAB_08064198;
        }
      }
LAB_08064198:
      __s2 = (ElementTypePtr *)__ptr[local_38]->Name[1].TextString;
      local_88 = __s2;
      iVar3 = strcmp((char *)local_28,(char *)__s2);
      if (iVar3 == 0) {
        free(local_28);
      }
      else {
        __fprintf_chk(__stream,1,"*RENAME* \"%s\" \"%s\"\n",__s2,local_28);
        uVar7 = __strdup(__ptr[local_38]->Name[1].TextString);
        *(undefined4 *)((int)pvVar4 + local_2c * 4) = uVar7;
        uVar7 = __strdup(local_28);
        *(undefined4 *)((int)pvVar5 + local_2c * 4) = uVar7;
        local_2c = local_2c + 1;
        AddObjectToChangeNameUndoList
                  (2,(void *)0x0,(void *)0x0,__ptr[local_38],__ptr[local_38]->Name[1].TextString);
        local_84 = (char *)0x0;
        local_88 = __ptr[local_38];
        ChangeObjectName(2,local_88,(void *)0x0,(void *)0x0,(char *)local_28);
        bVar18 = true;
      }
    }
    local_38 = local_38 + 1;
  } while (local_38 < local_4c);
  goto LAB_0806428f;
}



int ActionQuit(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  if ((0 < argc) && (*argv != (char *)0x0)) {
    iVar1 = strcasecmp(*argv,"force");
    if (iVar1 == 0) {
      PCB->Changed = '\0';
                    // WARNING: Subroutine does not return
      exit(0);
    }
  }
  if (PCB->Changed != '\0') {
    iVar1 = (*gui->close_confirm_dialog)();
    if (iVar1 != 1) {
      return 1;
    }
  }
  QuitApplication();
  return 1;
}



int ActionPasteBuffer(int argc,char **argv,int x,int y)

{
  char *default_file;
  Boolean BVar1;
  int iVar2;
  long lVar3;
  char *__filename;
  FILE *__stream;
  char *Filename;
  String Ident;
  int X;
  bool bVar4;
  float fVar5;
  char *local_38;
  Boolean local_1d [13];
  int oldy;
  int oldx;
  
  if (argc == 0) {
    Ident = "";
    HideCrosshair('\x01');
    local_38 = "";
    iVar2 = GetFunctionID("");
    X = iVar2 + -0x28;
    bVar4 = X == 0;
    if (bVar4) {
LAB_08064944:
      MirrorBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber));
      goto LAB_08064900;
    }
  }
  else {
    Ident = *argv;
    if (argc < 2) {
      local_38 = "";
    }
    else {
      local_38 = argv[1];
    }
    HideCrosshair('\x01');
    if (Ident == (String)0x0) goto LAB_08064900;
    iVar2 = GetFunctionID(Ident);
    X = iVar2 + -0x28;
    bVar4 = iVar2 == 0x28;
    if (bVar4) goto LAB_08064944;
  }
  if (bVar4 || SBORROW4(iVar2,0x28) != X < 0) {
    if (iVar2 == 0xb) {
      ClearBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber));
      goto LAB_08064900;
    }
    if (iVar2 == 0x10) {
      ConvertBufferToElement((BufferTypePtr)(Buffers + Settings.BufferNumber));
      goto LAB_08064900;
    }
    if (iVar2 == 0) {
      AddSelectedToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),0,0,'\0');
      goto LAB_08064900;
    }
    goto LAB_080649b1;
  }
  if (iVar2 == 0x43) {
    if (local_38 != (char *)0x0) {
      lVar3 = strtol(local_38,(char **)0x0,10);
      RotateBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),(BYTE)lVar3);
      SetCrosshairRangeToBuffer();
    }
    goto LAB_08064900;
  }
  if (iVar2 < 0x44) {
    if (iVar2 == 0x42) {
      SmashBufferElement((BufferTypePtr)(Buffers + Settings.BufferNumber));
      goto LAB_08064900;
    }
  }
  else {
    if (iVar2 == 0x44) {
      if ((Buffers[Settings.BufferNumber].Data)->ElementN == 0) {
        Message("Buffer has no elements!\n");
        goto LAB_08064900;
      }
      if (argc < 2) {
        Filename = (*gui->fileselect)("Save Paste Buffer As ...",
                                                                            
                                      "Choose a file to save the contents of the\npaste buffer to.\n"
                                      ,default_file,".fp","footprint",0);
        if (default_file != (char *)0x0) {
          free(default_file);
          default_file = (char *)0x0;
        }
        bVar4 = false;
        __filename = (char *)0x0;
        if ((Filename != (char *)0x0) && (bVar4 = true, __filename = Filename, *Filename != '\0')) {
          default_file = (char *)__strdup(Filename);
        }
      }
      else {
        Filename = argv[1];
        bVar4 = false;
        __filename = Filename;
      }
      __stream = fopen(__filename,"r");
      if (__stream == (FILE *)0x0) {
LAB_08064b48:
        SaveBufferElements(Filename);
      }
      else {
        fclose(__stream);
        X = (*gui->confirm_dialog)("File exists!  Ok to overwrite?",0);
        if (X != 0) goto LAB_08064b48;
      }
      if (bVar4) {
        free(Filename);
      }
      goto LAB_08064900;
    }
    if (iVar2 == 0x56) {
      if (argc == 1) {
        oldy = 0;
        X = 0;
      }
      else {
        if (1 < argc - 3U) {
          RestoreCrosshair('\x01');
          Message("Syntax error.  Usage:\n%s\n",
                                    
                  "PasteBuffer(AddSelected|Clear|1..MAX_BUFFER)\nPasteBuffer(Rotate, 1..3)\nPasteBuffer(Convert|Save|Restore|Mirror)\nPasteBuffer(ToLayout, X, Y, units)"
                 );
          return 1;
        }
        Filename = (char *)0x0;
        if (argc == 4) {
          Filename = argv[3];
        }
        fVar5 = GetValue(argv[1],Filename,local_1d);
        X = (int)ROUND(fVar5);
        if (local_1d[0] == '\0') {
          X = oldx + (int)ROUND(fVar5);
        }
        Filename = (char *)0x0;
        if (argc == 4) {
          Filename = argv[3];
        }
        fVar5 = GetValue(argv[2],Filename,local_1d);
        iVar2 = oldy + (int)ROUND(fVar5);
        oldy = (int)ROUND(fVar5);
        if (local_1d[0] == '\0') {
          oldy = iVar2;
        }
      }
      oldx = X;
      BVar1 = CopyPastebufferToLayout(X,oldy);
      if (BVar1 != '\0') {
        SetChangedFlag('\x01');
      }
      goto LAB_08064900;
    }
  }
LAB_080649b1:
  lVar3 = strtol(Ident,(char **)0x0,10);
  if (lVar3 != 0) {
    SetBufferNumber(lVar3 + -1);
  }
LAB_08064900:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionMorphPolygon(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  PolygonTypePtr poly;
  PCBTypePtr pPVar2;
  undefined *puVar3;
  LayerTypePtr layer;
  uint local_30;
  PolygonTypePtr local_28;
  void *ptr2;
  LayerTypePtr local_20 [4];
  
  if ((0 < argc) && (Ident = *argv, Ident != (String)0x0)) {
    HideCrosshair('\x01');
    iVar1 = GetFunctionID(Ident);
    if ((iVar1 == 0x46) || (iVar1 == 0x4b)) {
      layer = (LayerTypePtr)&PCB->Data->field_0x4c;
      if (PCB->Data->LayerN == -2) {
LAB_08064d5c:
        Draw();
        IncrementUndoSerialNumber();
        return 0;
      }
      local_30 = 0;
      pPVar2 = PCB;
      do {
        iVar1 = layer->PolygonN - 1;
        if (iVar1 != -1) {
          puVar3 = &DAT_ffffffc4 + layer->PolygonN * 0x3c;
          do {
            while (poly = (PolygonTypePtr)(puVar3 + (int)&(layer->Polygon->BoundingBox).X1),
                  (*(byte *)&(poly->Flags).f & 0x40) == 0) {
              iVar1 = iVar1 + -1;
              puVar3 = &DAT_ffffffc4 + (int)puVar3;
              pPVar2 = PCB;
              if (iVar1 == -1) goto LAB_08064cca;
            }
            iVar1 = iVar1 + -1;
            puVar3 = &DAT_ffffffc4 + (int)puVar3;
            MorphPolygon(layer,poly);
            pPVar2 = PCB;
          } while (iVar1 != -1);
        }
LAB_08064cca:
        local_30 = local_30 + 1;
        if (pPVar2->Data->LayerN + 2U <= local_30) goto LAB_08064d5c;
        layer = layer + 1;
      } while( true );
    }
    if (iVar1 == 0x2e) {
      (*gui->get_coords)("Select an Object",&x,&y);
      iVar1 = SearchScreen(x,y,8,local_20,&ptr2,&local_28);
      if (iVar1 != 0) {
        MorphPolygon(local_20[0],local_28);
        Draw();
        IncrementUndoSerialNumber();
      }
    }
  }
  return 0;
}



void click_cb(hidval hv)

{
  Boolean BVar1;
  int iVar2;
  BoxType box;
  
  if (Note.Click != '\0') {
    Note.Click = '\0';
    if (Note.Moving != '\0') {
      iVar2 = (*gui->shift_is_pressed)();
      if (iVar2 == 0) {
        HideCrosshair('\x01');
        Note.Buffer = Settings.BufferNumber;
        SetBufferNumber(4);
        ClearBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber));
        AddSelectedToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),Note.X,Note.Y,'\x01');
        SaveUndoSerialNumber();
        RemoveSelected();
        SaveMode();
        saved_mode = '\x01';
        SetMode(5);
        RestoreCrosshair('\x01');
        return;
      }
    }
    if (Note.Hit != 0) {
      iVar2 = (*gui->shift_is_pressed)();
      if (iVar2 == 0) {
        HideCrosshair('\x01');
        SaveMode();
        saved_mode = '\x01';
        iVar2 = (*gui->control_is_pressed)();
        SetMode(0x69 - (uint)(iVar2 == 0));
        Crosshair.AttachedObject.Ptr1 = Note.ptr1;
        Crosshair.AttachedObject.Ptr2 = Note.ptr2;
        Crosshair.AttachedObject.Ptr3 = Note.ptr3;
        Crosshair.AttachedObject.Type = Note.Hit;
        AttachForCopy(Note.X,Note.Y);
        RestoreCrosshair('\x01');
        return;
      }
    }
    Note.Hit = 0;
    Note.Moving = '\0';
    HideCrosshair('\x01');
    SaveUndoSerialNumber();
    box.X1 = -10000000;
    box.Y1 = -10000000;
    box.X2 = 10000000;
    box.Y2 = 10000000;
    iVar2 = (*gui->shift_is_pressed)();
    if (iVar2 == 0) {
      BVar1 = SelectBlock((BoxTypePtr)&box,'\0');
      if (BVar1 != '\0') {
        SetChangedFlag('\x01');
      }
    }
    NotifyBlock();
    Crosshair.AttachedBox.Point1.X = Note.X;
    Crosshair.AttachedBox.Point1.Y = Note.Y;
    RestoreCrosshair('\x01');
  }
  return;
}



void ClearWarnings(void)

{
  uint uVar1;
  PinTypePtr *Pin;
  DataTypePtr *pDVar2;
  PCBTypePtr pPVar3;
  uint uVar4;
  PadTypePtr *Pad;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  int local_28;
  int local_24;
  int local_20;
  
  Settings.RatWarn = '\0';
  pDVar2 = PCB->Data;
  local_20 = pDVar2->ElementN - 1;
  if (local_20 != -1) {
    pPVar3 = PCB;
    iVar7 = pDVar2->ElementN * 300;
    while( true ) {
      local_24 = iVar7 + -300;
      iVar7 = (int)&pDVar2->Element[-1].BoundingBox.X1 + iVar7;
      if (*(uint *)(iVar7 + 0xe0) != 0) {
        uVar5 = 0;
        uVar4 = *(uint *)(iVar7 + 0xe0);
        do {
          Pin = (PinTypePtr *)(uVar5 * 0x4c + *(int *)(iVar7 + 0x100));
          uVar6 = (Pin->Flags).f;
          uVar1 = uVar4;
          pPVar3 = PCB;
          if ((uVar6 & 0x200) != 0) {
            (Pin->Flags).f = uVar6 & 0xfffffdff;
            DrawPin(Pin,0);
            uVar1 = *(uint *)(iVar7 + 0xe0);
            pPVar3 = PCB;
          }
          PCB = pPVar3;
        } while ((uVar1 != 0) && (uVar5 = (uVar5 + 1 + uVar1) - uVar4, uVar4 = uVar1, uVar5 < uVar1)
                );
        pDVar2 = pPVar3->Data;
      }
      local_20 = local_20 + -1;
      if (local_20 == -1) break;
      pDVar2 = pPVar3->Data;
      iVar7 = local_24;
    }
    local_24 = pDVar2->ElementN - 1;
    if (local_24 != -1) {
      iVar7 = pDVar2->ElementN * 300;
      while( true ) {
        local_28 = iVar7 + -300;
        iVar8 = 0;
        uVar6 = 0;
        iVar7 = (int)&pDVar2->Element[-1].BoundingBox.X1 + iVar7;
        uVar4 = *(uint *)(iVar7 + 0xe8);
        uVar5 = uVar4;
        while ((uVar5 != 0 && (uVar6 < uVar5))) {
          Pad = (PadTypePtr *)(*(int *)(iVar7 + 0x104) + iVar8);
          uVar1 = (Pad->Flags).f;
          if ((uVar1 & 0x200) != 0) {
            (Pad->Flags).f = uVar1 & 0xfffffdff;
            DrawPad(Pad,0);
            uVar5 = *(uint *)(iVar7 + 0xe8);
          }
          if (uVar4 == uVar5) {
            uVar6 = uVar6 + 1;
            iVar8 = iVar8 + 0x68;
            uVar5 = uVar4;
          }
        }
        local_24 = local_24 + -1;
        if (local_24 == -1) break;
        pDVar2 = PCB->Data;
        iVar7 = local_28;
      }
    }
  }
  Draw();
  return;
}



void NotifyLine(void)

{
  int iVar1;
  float10 fVar2;
  float10 fVar3;
  float10 fVar4;
  float10 fVar5;
  void *ptr3;
  void *local_14;
  void *ptr1;
  
  if ((Marked.status == '\0') || ((*(byte *)&(PCB->Flags).f & 2) != 0)) {
    SetLocalRef(Crosshair.X,Crosshair.Y,'\x01');
    if (Crosshair.AttachedLine.State != 0) goto LAB_080651bf;
  }
  else {
    if (Crosshair.AttachedLine.State != 0) {
LAB_080651bf:
      if (Crosshair.AttachedLine.State == 1) {
        if (PCB->SilkActive == '\0') {
          lastLayer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          lastLayer = (LayerTypePtr)
                      (&PCB->Data->field_0x4c +
                      ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
      }
      Crosshair.AttachedLine.State = 2;
      return;
    }
  }
  if (PCB->RatDraw != '\0') {
    iVar1 = SearchScreen(Crosshair.X,Crosshair.Y,0x300,&ptr1,&ptr1,&ptr1);
    if (iVar1 == 0) {
      (*gui->beep)();
      return;
    }
  }
  if ((*(char *)&(PCB->Flags).f < '\0') && (Settings.Mode == 2)) {
    iVar1 = SearchScreen(Crosshair.X,Crosshair.Y,0x301,&ptr1,&local_14,&ptr3);
    LookupConnection(Crosshair.X,Crosshair.Y,'\x01',(int)ROUND(1.00000000 / Zoom_Multiplier),4);
    if ((iVar1 == 1) || (iVar1 == 0x100)) {
      Crosshair.AttachedLine.Point1.X = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point1.Y = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.State = 1;
      return;
    }
    if (iVar1 == 0x200) {
      fVar2 = (float10)(Crosshair.X - *(int *)((int)local_14 + 0x2c));
      fVar3 = (float10)(Crosshair.Y - *(int *)((int)local_14 + 0x30));
      fVar4 = (float10)(Crosshair.X - *(int *)((int)local_14 + 0x40));
      fVar5 = (float10)(Crosshair.Y - *(int *)((int)local_14 + 0x44));
      if (fVar5 * fVar5 + fVar4 * fVar4 < fVar3 * fVar3 + fVar2 * fVar2) {
        Crosshair.AttachedLine.Point1.X = *(LocationType *)((int)local_14 + 0x40);
        Crosshair.AttachedLine.Point1.Y = *(LocationType *)((int)local_14 + 0x44);
        Crosshair.AttachedLine.Point1.X2 = *(LocationType *)((int)local_14 + 0x48);
        Crosshair.AttachedLine.Point1.Y2 = *(LocationType *)((int)local_14 + 0x4c);
        Crosshair.AttachedLine.Point1.ID = *(long *)((int)local_14 + 0x50);
        Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)local_14 + 0x40);
        Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)local_14 + 0x44);
        Crosshair.AttachedLine.Point2.X2 = *(LocationType *)((int)local_14 + 0x48);
        Crosshair.AttachedLine.Point2.Y2 = *(LocationType *)((int)local_14 + 0x4c);
        Crosshair.AttachedLine.Point2.ID = *(long *)((int)local_14 + 0x50);
        Crosshair.AttachedLine.State = 1;
        return;
      }
      Crosshair.AttachedLine.Point1.X = *(LocationType *)((int)local_14 + 0x2c);
      Crosshair.AttachedLine.Point1.Y = *(LocationType *)((int)local_14 + 0x30);
      Crosshair.AttachedLine.Point1.X2 = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point1.Y2 = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.Point1.ID = *(long *)((int)local_14 + 0x3c);
      Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)local_14 + 0x2c);
      Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)local_14 + 0x30);
      Crosshair.AttachedLine.Point2.X2 = *(LocationType *)((int)local_14 + 0x34);
      Crosshair.AttachedLine.Point2.Y2 = *(LocationType *)((int)local_14 + 0x38);
      Crosshair.AttachedLine.Point2.ID = *(long *)((int)local_14 + 0x3c);
      Crosshair.AttachedLine.State = 1;
      return;
    }
  }
  Crosshair.AttachedLine.Point1.X = Crosshair.X;
  Crosshair.AttachedLine.Point1.Y = Crosshair.Y;
  Crosshair.AttachedLine.Point2.X = Crosshair.X;
  Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
  Crosshair.AttachedLine.State = 1;
  return;
}



int ActionMinClearGap(int argc,char **argv,int x,int y)

{
  uint uVar1;
  int Difference;
  void *Ptr2;
  PCBTypePtr pPVar2;
  PinTypePtr *Ptr1;
  void *Ptr1_00;
  char *val;
  uint uVar3;
  DataTypePtr *pDVar4;
  char *pcVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  char *__s1;
  char *units;
  int iVar9;
  float fVar10;
  int local_48;
  int local_44;
  uint local_38;
  Boolean r;
  
  if (argc < 1) {
    __s1 = (char *)0x0;
LAB_0806580b:
    pcVar5 = (char *)0x0;
    units = (char *)0x0;
  }
  else {
    __s1 = *argv;
    if (argc == 1) goto LAB_0806580b;
    units = (char *)0x0;
    pcVar5 = argv[1];
    if (argc != 2) {
      units = argv[2];
    }
  }
  if (__s1 == (char *)0x0) {
    return 1;
  }
  uVar6 = 0x40;
  Difference = strcasecmp(__s1,"Selected");
  val = pcVar5;
  if (Difference != 0) {
    uVar6 = 0;
    val = __s1;
    units = pcVar5;
  }
  fVar10 = GetValue(val,units,&r);
  Difference = (int)ROUND(fVar10 + fVar10);
  HideCrosshair('\x01');
  SaveUndoSerialNumber();
  pDVar4 = PCB->Data;
  local_44 = pDVar4->ElementN - 1;
  if (local_44 != -1) {
    iVar8 = pDVar4->ElementN * 300;
    while( true ) {
      local_48 = iVar8 + -300;
      Ptr1_00 = (void *)((int)&pDVar4->Element[-1].BoundingBox.X1 + iVar8);
      if (*(uint *)((int)Ptr1_00 + 0xe0) != 0) {
        uVar7 = 0;
        uVar3 = *(uint *)((int)Ptr1_00 + 0xe0);
        do {
          Ptr2 = (void *)(uVar7 * 0x4c + *(int *)((int)Ptr1_00 + 0x100));
          uVar1 = uVar3;
          if (((*(uint *)((int)Ptr2 + 0x14) & uVar6) == uVar6) &&
             (*(int *)((int)Ptr2 + 0x28) < Difference)) {
            ChangeObjectClearSize(0x100,Ptr1_00,Ptr2,(void *)0x0,Difference,'\x01');
            RestoreUndoSerialNumber();
            uVar1 = *(uint *)((int)Ptr1_00 + 0xe0);
          }
        } while ((uVar1 != 0) && (uVar7 = (uVar7 + 1 + uVar1) - uVar3, uVar3 = uVar1, uVar7 < uVar1)
                );
      }
      uVar3 = *(uint *)((int)Ptr1_00 + 0xe8);
      local_38 = 0;
      iVar8 = 0;
      uVar7 = uVar3;
      while ((uVar7 != 0 && (local_38 < uVar7))) {
        Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x104) + iVar8);
        if ((uVar6 == (*(uint *)((int)Ptr2 + 0x14) & uVar6)) &&
           (*(int *)((int)Ptr2 + 0x28) < Difference)) {
          ChangeObjectClearSize(0x200,Ptr1_00,Ptr2,(void *)0x0,Difference,'\x01');
          RestoreUndoSerialNumber();
          uVar7 = *(uint *)((int)Ptr1_00 + 0xe8);
        }
        if (uVar3 == uVar7) {
          local_38 = local_38 + 1;
          iVar8 = iVar8 + 0x68;
          uVar7 = uVar3;
        }
      }
      local_44 = local_44 + -1;
      if (local_44 == -1) break;
      pDVar4 = PCB->Data;
      iVar8 = local_48;
    }
    pDVar4 = PCB->Data;
  }
  pPVar2 = PCB;
  if (pDVar4->ViaN != 0) {
    uVar7 = 0;
    uVar3 = pDVar4->ViaN;
    do {
      Ptr1 = pDVar4->Via + uVar7;
      if ((((Ptr1->Flags).f & uVar6) == uVar6) && (Ptr1->Clearance < Difference)) {
        ChangeObjectClearSize(1,Ptr1,(void *)0x0,(void *)0x0,Difference,'\x01');
        RestoreUndoSerialNumber();
        pDVar4 = PCB->Data;
        uVar1 = pDVar4->ViaN;
        pPVar2 = PCB;
      }
      else {
        pDVar4 = pPVar2->Data;
        uVar1 = pDVar4->ViaN;
      }
    } while ((uVar1 != 0) && (uVar7 = (uVar1 + 1 + uVar7) - uVar3, uVar3 = uVar1, uVar7 < uVar1));
  }
  Ptr1_00 = (void *)&pDVar4->field_0x4c;
  if (pDVar4->LayerN != -2) {
    local_38 = 0;
    do {
      iVar8 = *(int *)((int)Ptr1_00 + 4) + -1;
      if (iVar8 != -1) {
        iVar9 = *(int *)((int)Ptr1_00 + 4) * 0x58 + -0x58;
        do {
          while ((Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x24) + iVar9),
                 (*(uint *)((int)Ptr2 + 0x14) & uVar6) == uVar6 &&
                 (*(int *)((int)Ptr2 + 0x28) < Difference))) {
            iVar8 = iVar8 + -1;
            iVar9 = iVar9 + -0x58;
            ChangeObjectClearSize(4,Ptr1_00,Ptr2,(void *)0x0,Difference,'\x01');
            RestoreUndoSerialNumber();
            pPVar2 = PCB;
            if (iVar8 == -1) goto LAB_0806572d;
          }
          iVar8 = iVar8 + -1;
          iVar9 = iVar9 + -0x58;
          pPVar2 = PCB;
        } while (iVar8 != -1);
      }
LAB_0806572d:
      local_38 = local_38 + 1;
      iVar8 = pPVar2->Data->LayerN;
      if (iVar8 + 2U <= local_38) goto LAB_0806574a;
      Ptr1_00 = (void *)((int)Ptr1_00 + 0x5c);
    } while( true );
  }
LAB_080655f9:
  RestoreUndoSerialNumber();
  IncrementUndoSerialNumber();
  return 0;
LAB_0806574a:
  Ptr1_00 = (void *)&pPVar2->Data->field_0x4c;
  if (iVar8 != -2) {
    local_38 = 0;
    do {
      iVar8 = *(int *)((int)Ptr1_00 + 0x10) + -1;
      if (iVar8 != -1) {
        iVar9 = *(int *)((int)Ptr1_00 + 0x10) * 0x44 + -0x44;
        do {
          while ((Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x30) + iVar9),
                 (*(uint *)((int)Ptr2 + 0x14) & uVar6) == uVar6 &&
                 (*(int *)((int)Ptr2 + 0x28) < Difference))) {
            iVar8 = iVar8 + -1;
            iVar9 = iVar9 + -0x44;
            ChangeObjectClearSize(0x4000,Ptr1_00,Ptr2,(void *)0x0,Difference,'\x01');
            RestoreUndoSerialNumber();
            pPVar2 = PCB;
            if (iVar8 == -1) goto LAB_080657dd;
          }
          iVar8 = iVar8 + -1;
          iVar9 = iVar9 + -0x44;
          pPVar2 = PCB;
        } while (iVar8 != -1);
      }
LAB_080657dd:
      local_38 = local_38 + 1;
      if (pPVar2->Data->LayerN + 2U <= local_38) break;
      Ptr1_00 = (void *)((int)Ptr1_00 + 0x5c);
    } while( true );
  }
  goto LAB_080655f9;
}



int ActionMinMaskGap(int argc,char **argv,int x,int y)

{
  uint uVar1;
  int iVar2;
  void *Ptr2;
  DataTypePtr *pDVar3;
  int Difference;
  int Difference_00;
  PCBTypePtr pPVar4;
  char *val;
  uint uVar5;
  PinTypePtr *Ptr1;
  char *pcVar6;
  uint uVar7;
  char *__s1;
  uint uVar8;
  char *units;
  void *Ptr1_00;
  float fVar9;
  int local_48;
  int local_44;
  uint local_38;
  Boolean r;
  
  if (argc < 1) {
    __s1 = (char *)0x0;
  }
  else {
    __s1 = *argv;
    if (argc != 1) {
      units = (char *)0x0;
      pcVar6 = argv[1];
      if (argc != 2) {
        units = argv[2];
      }
      goto LAB_0806584f;
    }
  }
  pcVar6 = (char *)0x0;
  units = (char *)0x0;
LAB_0806584f:
  iVar2 = 1;
  if (__s1 != (char *)0x0) {
    uVar8 = 0x40;
    iVar2 = strcasecmp(__s1,"Selected");
    val = pcVar6;
    if (iVar2 != 0) {
      uVar8 = 0;
      val = __s1;
      units = pcVar6;
    }
    fVar9 = GetValue(val,units,&r);
    iVar2 = (int)ROUND(fVar9 + fVar9);
    HideCrosshair('\x01');
    SaveUndoSerialNumber();
    pDVar3 = PCB->Data;
    local_44 = pDVar3->ElementN - 1;
    if (local_44 != -1) {
      Difference = pDVar3->ElementN * 300;
      while( true ) {
        local_48 = Difference + -300;
        Ptr1_00 = (void *)((int)&pDVar3->Element[-1].BoundingBox.X1 + Difference);
        if (*(uint *)((int)Ptr1_00 + 0xe0) != 0) {
          uVar7 = 0;
          uVar5 = *(uint *)((int)Ptr1_00 + 0xe0);
          do {
            Ptr2 = (void *)(uVar7 * 0x4c + *(int *)((int)Ptr1_00 + 0x100));
            uVar1 = uVar5;
            if (((*(uint *)((int)Ptr2 + 0x14) & uVar8) == uVar8) &&
               (Difference = iVar2 + *(int *)((int)Ptr2 + 0x24),
               *(int *)((int)Ptr2 + 0x2c) < Difference)) {
              ChangeObjectMaskSize(0x100,Ptr1_00,Ptr2,(void *)0x0,Difference,'\x01');
              RestoreUndoSerialNumber();
              uVar1 = *(uint *)((int)Ptr1_00 + 0xe0);
            }
          } while ((uVar1 != 0) &&
                  (uVar7 = (uVar7 + 1 + uVar1) - uVar5, uVar5 = uVar1, uVar7 < uVar1));
        }
        uVar5 = *(uint *)((int)Ptr1_00 + 0xe8);
        Difference = 0;
        local_38 = 0;
        uVar7 = uVar5;
        while ((uVar7 != 0 && (local_38 < uVar7))) {
          Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x104) + Difference);
          if ((uVar8 == (*(uint *)((int)Ptr2 + 0x14) & uVar8)) &&
             (Difference_00 = iVar2 + *(int *)((int)Ptr2 + 0x24),
             *(int *)((int)Ptr2 + 0x54) < Difference_00)) {
            ChangeObjectMaskSize(0x200,Ptr1_00,Ptr2,(void *)0x0,Difference_00,'\x01');
            RestoreUndoSerialNumber();
            uVar7 = *(uint *)((int)Ptr1_00 + 0xe8);
          }
          if (uVar5 == uVar7) {
            local_38 = local_38 + 1;
            Difference = Difference + 0x68;
            uVar7 = uVar5;
          }
        }
        local_44 = local_44 + -1;
        if (local_44 == -1) break;
        pDVar3 = PCB->Data;
        Difference = local_48;
      }
      pDVar3 = PCB->Data;
    }
    if (pDVar3->ViaN != 0) {
      uVar7 = 0;
      pPVar4 = PCB;
      uVar5 = pDVar3->ViaN;
      do {
        Ptr1 = pDVar3->Via + uVar7;
        if (((((Ptr1->Flags).f & uVar8) == uVar8) && (Ptr1->Mask != 0)) &&
           (Difference = iVar2 + Ptr1->Thickness, Ptr1->Mask < Difference)) {
          ChangeObjectMaskSize(1,Ptr1,(void *)0x0,(void *)0x0,Difference,'\x01');
          RestoreUndoSerialNumber();
          pPVar4 = PCB;
        }
        pDVar3 = pPVar4->Data;
        uVar1 = pDVar3->ViaN;
      } while ((uVar1 != 0) && (uVar7 = (uVar1 + 1 + uVar7) - uVar5, uVar5 = uVar1, uVar7 < uVar1));
    }
    RestoreUndoSerialNumber();
    IncrementUndoSerialNumber();
    iVar2 = 0;
  }
  return iVar2;
}



int ActionMarkCrosshair(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  
  if (((argc < 1) || (Ident = *argv, Ident == (String)0x0)) || (*Ident == '\0')) {
    if (Marked.status != '\0') {
      DrawMark('\x01');
      Marked.status = '\0';
      return 0;
    }
  }
  else {
    iVar1 = GetFunctionID(Ident);
    if (iVar1 != 10) {
      return 0;
    }
    DrawMark('\x01');
  }
  Marked.status = '\x01';
  Marked.X = Crosshair.X;
  Marked.Y = Crosshair.Y;
  DrawMark('\0');
  return 0;
}



int ActionLoadFrom(int argc,char **argv,int x,int y)

{
  int iVar1;
  char *Name;
  PCBTypePtr pPVar2;
  char cVar3;
  int iVar4;
  char *__s1;
  int in_GS_OFFSET;
  char fname [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (argc < 2) {
    Message("Syntax error.  Usage:\n%s\n",
            "LoadFrom(Layout|LayoutToBuffer|ElementToBuffer|Netlist|Revert,filename)");
    iVar4 = 1;
    goto LAB_08065c0e;
  }
  __s1 = *argv;
  Name = argv[1];
  HideCrosshair('\x01');
  iVar4 = strcasecmp(__s1,"ElementToBuffer");
  if (iVar4 == 0) {
    cVar3 = LoadElementToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),Name,'\x01');
joined_r0x08065c4a:
    if (cVar3 != '\0') {
      SetMode(5);
    }
  }
  else {
    iVar4 = strcasecmp(__s1,"LayoutToBuffer");
    if (iVar4 == 0) {
      cVar3 = LoadLayoutToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),Name);
      goto joined_r0x08065c4a;
    }
    iVar4 = strcasecmp(__s1,"Layout");
    if (iVar4 == 0) {
      if ((PCB->Changed == '\0') ||
         (iVar4 = (*gui->confirm_dialog)("OK to override layout data?",0), iVar4 != 0)) {
        LoadPCB(Name);
      }
    }
    else {
      iVar4 = strcasecmp(__s1,"Netlist");
      if (iVar4 == 0) {
        if (PCB->Netlistname != (char *)0x0) {
          SaveFree(PCB->Netlistname);
        }
        pPVar2 = PCB;
        __s1 = StripWhiteSpaceAndDup(Name);
        pPVar2->Netlistname = __s1;
        FreeLibraryMemory((LibraryTypePtr)&PCB->NetlistLib);
        iVar4 = ImportNetlist(PCB->Netlistname);
        if (iVar4 == 0) {
          hid_action("NetlistChanged");
        }
      }
      else {
        iVar4 = strcasecmp(__s1,"Revert");
        if ((iVar4 == 0) && (__s1 = PCB->Filename, __s1 != (char *)0x0)) {
          if (PCB->Changed != '\0') {
            iVar4 = (*gui->confirm_dialog)("OK to override changes?",0);
            if (iVar4 == 0) goto LAB_08065c00;
            __s1 = PCB->Filename;
          }
          __strcpy_chk(fname,__s1,0x100);
          LoadPCB(fname);
        }
      }
    }
  }
LAB_08065c00:
  RestoreCrosshair('\x01');
  iVar4 = 0;
LAB_08065c0e:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int ActionFlip(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  ElementTypePtr *local_10 [2];
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
LAB_08065e25:
    Message("Syntax error.  Usage:\n%s\n","Flip(Object|Selected|SelectedElements)");
    iVar1 = 1;
  }
  else {
    HideCrosshair('\x01');
    iVar1 = GetFunctionID(Ident);
    if ((iVar1 == 0x46) || (iVar1 == 0x48)) {
      ChangeSelectedElementSide();
    }
    else {
      if (iVar1 != 0x2e) {
        RestoreCrosshair('\x01');
        goto LAB_08065e25;
      }
      iVar1 = SearchScreen(x,y,2,local_10,local_10,local_10);
      if (iVar1 != 0) {
        ChangeElementSide(local_10[0],Crosshair.Y * 2 - PCB->MaxHeight);
        IncrementUndoSerialNumber();
        Draw();
      }
    }
    RestoreCrosshair('\x01');
    iVar1 = 0;
  }
  return iVar1;
}



int ActionExecuteFile(int argc,char **argv,int x,int y)

{
  char *__filename;
  char cVar1;
  int iVar2;
  FILE *__stream;
  char *rstr;
  int in_GS_OFFSET;
  char line [256];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (argc == 1) {
    __filename = *argv;
    __stream = fopen(__filename,"r");
    if (__stream == (FILE *)0x0) {
      __fprintf_chk(stderr,1,"Could not open actions file \"%s\".\n",__filename);
      iVar2 = 1;
    }
    else {
      iVar2 = 0;
LAB_08065f40:
      rstr = fgets(line,0x100,__stream);
      if (rstr != (char *)0x0) {
        iVar2 = iVar2 + 1;
        rstr = line;
        if ((line[0] != '\r') && (cVar1 = line[0], line[0] != '\0')) {
          while (cVar1 != '\n') {
            rstr = rstr + 1;
            cVar1 = *rstr;
            if ((cVar1 == '\r') || (cVar1 == '\0')) break;
          }
        }
        *rstr = '\0';
        if (line[0] != '\0') {
          rstr = line;
          if ((line[0] == ' ') || (cVar1 = line[0], line[0] == '\t')) {
            do {
              rstr = rstr + 1;
              cVar1 = *rstr;
              if (cVar1 == '\0') goto LAB_08065f40;
            } while ((cVar1 == '\t') || (cVar1 == ' '));
          }
          if ((cVar1 != '#') && (cVar1 != '\0')) {
            Message("%s : line %-3d : \"%s\"\n",__filename,iVar2,rstr);
            hid_parse_actions(rstr,(anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0);
          }
        }
        goto LAB_08065f40;
      }
      fclose(__stream);
      iVar2 = 0;
    }
  }
  else {
    Message("Syntax error.  Usage:\n%s\n","ExecuteFile(filename)");
    iVar2 = 1;
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int ActionDumpLibrary(int argc,char **argv,int x,int y)

{
  char *pcVar1;
  char *pcVar2;
  LibraryEntryTypePtr *pLVar3;
  char *pcVar4;
  uint uVar5;
  char *pcVar6;
  char *pcVar7;
  uint local_24;
  
  __printf_chk(1,"**** Do not count on this format.  It will change ****\n\n");
  __printf_chk(1,"MenuN   = %d\n",Library.MenuN);
  __printf_chk(1,"MenuMax = %d\n",Library.MenuMax);
  if (Library.MenuN != 0) {
    local_24 = 0;
    do {
      __printf_chk(1,"Library #%d:\n",local_24);
      __printf_chk(1,"    EntryN    = %d\n",Library.Menu[local_24].EntryN);
      __printf_chk(1,"    EntryMax  = %d\n",Library.Menu[local_24].EntryMax);
      pcVar1 = Library.Menu[local_24].Name;
      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
        pcVar1 = "(unknown)";
      }
      __printf_chk(1,"    Name      = \"%s\"\n",pcVar1);
      pcVar1 = Library.Menu[local_24].directory;
      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
        pcVar1 = "(unknown)";
      }
      __printf_chk(1,"    directory = \"%s\"\n",pcVar1);
      pcVar1 = Library.Menu[local_24].Style;
      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
        pcVar1 = "(unknown)";
      }
      __printf_chk(1,"    Style     = \"%s\"\n",pcVar1);
      __printf_chk(1,"    flag      = %d\n",(int)Library.Menu[local_24].flag);
      if (Library.Menu[local_24].EntryN != 0) {
        uVar5 = 0;
        do {
          __printf_chk(1,"    #%4d: ",uVar5);
          pLVar3 = Library.Menu[local_24].Entry + uVar5;
          pcVar1 = pLVar3->Template;
          if (pcVar1 == (char *)0xffffffff) {
            pcVar1 = pLVar3->ListEntry;
            if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
              pcVar1 = "(unknown)";
            }
            __printf_chk(1,"newlib: \"%s\"\n",pcVar1);
          }
          else {
            pcVar7 = pLVar3->Description;
            if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\0')) {
              pcVar7 = "(unknown)";
            }
            pcVar6 = pLVar3->Value;
            if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\0')) {
              pcVar6 = "(unknown)";
            }
            pcVar4 = pLVar3->Package;
            if ((pcVar4 == (char *)0x0) || (*pcVar4 == '\0')) {
              pcVar4 = "(unknown)";
            }
            if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
              pcVar1 = "(unknown)";
            }
            pcVar2 = pLVar3->ListEntry;
            if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
              pcVar2 = "(unknown)";
            }
            __printf_chk(1,"\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"\n",pcVar2,pcVar1,pcVar4,pcVar6,
                         pcVar7);
          }
          uVar5 = uVar5 + 1;
        } while (uVar5 <= Library.Menu[local_24].EntryN && Library.Menu[local_24].EntryN != uVar5);
      }
      local_24 = local_24 + 1;
    } while (local_24 < Library.MenuN);
  }
  return 0;
}



int ActionDRCheck(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  if ((gui->drc_gui == (HID_DRC_GUI *)0x0) || (gui->drc_gui->log_drc_overview != 0)) {
    iVar1 = PCB->Bloat + 1;
    Message(
            "Rules are minspace %d.%02d, minoverlap %d.%d minwidth %d.%02d, minsilk %d.%02d\nmin drill %d.%02d, min annular ring %d.%02d\n"
            ,iVar1 / 100,iVar1 % 100,PCB->Shrink / 100,PCB->Shrink % 100,PCB->minWid / 100,
            PCB->minWid % 100,PCB->minSlk / 100,PCB->minSlk % 100,PCB->minDrill / 100,
            PCB->minDrill % 100,PCB->minRing / 100,PCB->minRing % 100);
  }
  HideCrosshair('\x01');
  iVar1 = DRCAll();
  if ((gui->drc_gui == (HID_DRC_GUI *)0x0) || (gui->drc_gui->log_drc_overview != 0)) {
    if (iVar1 == 0) {
      Message("No DRC problems found.\n");
    }
    else {
      if (iVar1 < 1) {
        Message("Aborted DRC after %d design rule errors.\n",-iVar1);
      }
      else {
        Message("Found %d design rule errors.\n",iVar1);
      }
    }
  }
  RestoreCrosshair('\x01');
  return 0;
}



int ActionConnection(int argc,char **argv,int x,int y)

{
  String Ident;
  int iVar1;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    Message("Syntax error.  Usage:\n%s\n",
            "Connection(Find|ResetLinesAndPolygons|ResetPinsAndVias|Reset)");
    return 1;
  }
  HideCrosshair('\x01');
  iVar1 = GetFunctionID(Ident);
  if (iVar1 == 0x3f) {
    SaveUndoSerialNumber();
    ResetFoundPinsViasAndPads('\x01');
    RestoreUndoSerialNumber();
  }
  else {
    if (iVar1 < 0x40) {
      if (iVar1 == 0x1c) {
        (*gui->get_coords)("Click on a connection",&x,&y);
        LookupConnection(x,y,'\x01',1,4);
      }
      goto LAB_08066560;
    }
    if (iVar1 != 0x40) {
      if (iVar1 == 0x41) {
        ResetFoundPinsViasAndPads('\x01');
      }
      goto LAB_08066560;
    }
  }
  ResetFoundLinesAndPolygons('\x01');
LAB_08066560:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionDisperseElements(int argc,char **argv,int x,int y)

{
  String Ident;
  uint uVar1;
  bool bVar2;
  int iVar3;
  int DY;
  int DX;
  int iVar4;
  ElementTypePtr *Element;
  DataTypePtr *Data;
  int local_4c;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_2c;
  
  if (((0 < argc) && (Ident = *argv, Ident != (String)0x0)) && (*Ident != '\0')) {
    iVar3 = GetFunctionID(Ident);
    if (iVar3 == 1) {
      bVar2 = true;
    }
    else {
      bVar2 = false;
      if (iVar3 != 0x46) goto LAB_080665fe;
    }
    Data = PCB->Data;
    local_2c = Data->ElementN - 1;
    if (local_2c != -1) {
      local_34 = 10000;
      local_4c = 10000;
      local_40 = 10000;
      iVar3 = Data->ElementN * 300;
      do {
        Element = (ElementTypePtr *)((int)&Data->Element[-1].BoundingBox.X1 + iVar3);
        uVar1 = (Element->Flags).f;
        if (((uVar1 & 0x2000) == 0) && ((bVar2 || ((uVar1 & 0x40) != 0)))) {
          DX = (Element->BoundingBox).X1;
          local_3c = local_40 - DX;
          local_38 = local_3c + Element->MarkX;
          DY = (int)ROUND(PCB->Grid);
          if (PCB->MaxWidth < (DY + 10000 + (Element->BoundingBox).X2 + local_3c) - local_38 % DY) {
            local_3c = 10000 - DX;
            local_40 = 10000;
            local_4c = local_34 + 10000;
            local_38 = local_3c + Element->MarkX;
          }
          iVar4 = local_4c - (Element->BoundingBox).Y1;
          DX = (local_3c + DY) - local_38 % DY;
          DY = (iVar4 + DY) - (iVar4 + Element->MarkY) % DY;
          MoveElementLowLevel(Data,Element,DX,DY);
          AddObjectToMoveUndoList(2,(void *)0x0,(void *)0x0,Element,DX,DY);
          local_40 = local_40 + (((Element->BoundingBox).X2 + 10000) - (Element->BoundingBox).X1);
          DY = (Element->BoundingBox).Y2;
          if (DY <= local_34) goto LAB_080667c8;
        }
        else {
LAB_080667c8:
          DY = local_34;
        }
        local_2c = local_2c + -1;
        if (local_2c == -1) break;
        Data = PCB->Data;
        iVar3 = iVar3 + -300;
        local_34 = DY;
      } while( true );
    }
    IncrementUndoSerialNumber();
    ClearAndRedrawOutput();
    SetChangedFlag('\x01');
    return 0;
  }
LAB_080665fe:
  Message("Syntax error.  Usage:\n%s\n","DisperseElements(All|Selected)");
  return 1;
}



int ActionDeleteRats(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  if (Settings.RatWarn != '\0') {
    ClearWarnings();
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if ((iVar2 == 0x46) || (iVar2 == 0x50)) {
    cVar1 = DeleteRats('\x01');
  }
  else {
    if (iVar2 != 3) goto LAB_08066852;
    cVar1 = DeleteRats('\0');
  }
  if (cVar1 != '\0') {
    SetChangedFlag('\x01');
  }
LAB_08066852:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionChangeOctagon(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [3];
  
  if ((0 < argc) && (*argv != (String)0x0)) {
    Type = GetFunctionID(*argv);
    switch(Type) {
    case 0x2e:
    case 0x5f:
      (*gui->get_coords)("Select an Object",&x,&y);
      Type = SearchScreen(x,y,0x103,local_10,&local_14,&local_18);
      if (Type == 0) {
        return 0;
      }
      BVar2 = ChangeObjectOctagon(Type,local_10[0],local_14,local_18);
      if (BVar2 == '\0') {
        return 0;
      }
      goto LAB_08066922;
    default:
      goto switchD_080668d8_caseD_2f;
    case 0x46:
    case 0x4b:
      cVar1 = ChangeSelectedOctagon(0x101);
      break;
    case 0x48:
      cVar1 = ChangeSelectedOctagon(2);
      break;
    case 0x4d:
      cVar1 = ChangeSelectedOctagon(0x100);
      break;
    case 0x4f:
      cVar1 = ChangeSelectedOctagon(1);
    }
    if (cVar1 != '\0') {
LAB_08066922:
      SetChangedFlag('\x01');
      return 0;
    }
  }
switchD_080668d8_caseD_2f:
  return 0;
}



int ActionChangeSquare(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [2];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an Object",&x,&y);
    Type = SearchScreen(x,y,0x302,local_10,&local_14,&local_18);
    if ((Type == 0) ||
       (BVar2 = ChangeObjectSquare(Type,local_10[0],local_14,local_18), BVar2 == '\0'))
    goto switchD_08066a28_caseD_2f;
    goto LAB_08066a42;
  default:
    goto switchD_08066a28_caseD_2f;
  case 0x46:
  case 0x4b:
  case 0x4d:
    cVar1 = ChangeSelectedSquare(0x300);
    break;
  case 0x48:
    cVar1 = ChangeSelectedSquare(2);
  }
  if (cVar1 != '\0') {
LAB_08066a42:
    SetChangedFlag('\x01');
  }
switchD_08066a28_caseD_2f:
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Type propagation algorithm not settling

int ActionChangeSize(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int Type;
  char *units;
  float fVar2;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1d [13];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    return 0;
  }
  units = (char *)0x0;
  if (argc != 2) {
    units = argv[2];
  }
  if (argv[1] == (char *)0x0) {
    return 0;
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  fVar2 = GetValue(argv[1],units,local_1d);
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
    Type = SearchScreen(Crosshair.X,Crosshair.Y,0x471f,&local_24,&local_28,&local_2c);
    if ((Type != 0) && ((*(byte *)((int)local_28 + 0x15) & 0x20) != 0)) {
      Message("Sorry, the object is locked\n");
    }
    cVar1 = ChangeObjectSize(Type,local_24,local_28,local_2c,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
  case 0x35:
  case 0x36:
  case 0x37:
  case 0x38:
  case 0x39:
  case 0x3a:
  case 0x3b:
  case 0x3c:
  case 0x3d:
  case 0x3e:
  case 0x3f:
  case 0x40:
  case 0x41:
  case 0x42:
  case 0x43:
  case 0x44:
  case 0x45:
    goto switchD_08066b98_caseD_22;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelectedSize(0x471f,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x47:
    cVar1 = ChangeSelectedSize(0x4000,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x48:
    cVar1 = ChangeSelectedSize(2,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x49:
    cVar1 = ChangeSelectedSize(4,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x4a:
    cVar1 = ChangeSelectedSize(0x400,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x4c:
    cVar1 = ChangeSelectedSize(0x200,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x4d:
    cVar1 = ChangeSelectedSize(0x100,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x4e:
    cVar1 = ChangeSelectedSize(0x10,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x4f:
    cVar1 = ChangeSelectedSize(1,(int)ROUND(fVar2),local_1d[0]);
    break;
  default:
    goto switchD_08066b98_caseD_22;
  }
  if (cVar1 == '\0') {
switchD_08066b98_caseD_22:
    RestoreCrosshair('\x01');
  }
  else {
    SetChangedFlag('\x01');
    RestoreCrosshair('\x01');
  }
  return 0;
}



int ActionChangePaste(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  int iVar2;
  PadTypePtr *local_18;
  void *ptr2;
  void *ptr1;
  
  if (argc < 1) {
    return 0;
  }
  if (*argv == (String)0x0) {
    return 0;
  }
  iVar2 = GetFunctionID(*argv);
  if (iVar2 == 0x46) {
code_r0x08066f29:
    BVar1 = ChangeSelectedPaste();
    if (BVar1 != '\0') {
      SetChangedFlag('\x01');
      return 0;
    }
  }
  else {
    if (iVar2 < 0x47) {
      if (iVar2 != 0x2e) {
        return 0;
      }
    }
    else {
      if (iVar2 == 0x4c) goto code_r0x08066f29;
      if (iVar2 != 0x5f) {
        return 0;
      }
    }
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,0x200,&ptr1,&ptr2,&local_18);
    if ((iVar2 != 0) && (BVar1 = ChangePaste(local_18), BVar1 != '\0')) {
      IncrementUndoSerialNumber();
    }
  }
  return 0;
}



int ActionChangeJoin(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int Type;
  void *local_18;
  void *local_14;
  void *local_10 [2];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
  case 0x5f:
    (*gui->get_coords)("Select an Object",&x,&y);
    Type = SearchScreen(x,y,0x4014,local_10,&local_14,&local_18);
    if (Type == 0) goto switchD_08066f98_caseD_2f;
    cVar1 = ChangeObjectJoin(Type,local_10[0],local_14,local_18);
    break;
  default:
    goto switchD_08066f98_caseD_2f;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelectedJoin(0x4014);
    break;
  case 0x47:
    cVar1 = ChangeSelectedJoin(0x4000);
    goto joined_r0x08066fb0;
  case 0x49:
    cVar1 = ChangeSelectedJoin(4);
joined_r0x08066fb0:
    if (cVar1 == '\0') goto switchD_08066f98_caseD_2f;
    goto LAB_08066fb2;
  }
  if (cVar1 != '\0') {
LAB_08066fb2:
    SetChangedFlag('\x01');
  }
switchD_08066f98_caseD_2f:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionChangeHole(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  int iVar2;
  PinTypePtr *local_18;
  void *ptr2;
  void *ptr1;
  
  if (argc < 1) {
    return 0;
  }
  if (*argv == (String)0x0) {
    return 0;
  }
  iVar2 = GetFunctionID(*argv);
  if (iVar2 == 0x46) {
code_r0x08067149:
    BVar1 = ChangeSelectedHole();
    if (BVar1 != '\0') {
      SetChangedFlag('\x01');
      return 0;
    }
  }
  else {
    if (iVar2 < 0x47) {
      if (iVar2 != 0x2e) {
        return 0;
      }
    }
    else {
      if (iVar2 == 0x4f) goto code_r0x08067149;
      if (iVar2 != 0x5f) {
        return 0;
      }
    }
    (*gui->get_coords)("Select an Object",&x,&y);
    iVar2 = SearchScreen(x,y,1,&ptr1,&ptr2,&local_18);
    if ((iVar2 != 0) && (BVar1 = ChangeHole(local_18), BVar1 != '\0')) {
      IncrementUndoSerialNumber();
    }
  }
  return 0;
}



int ActionChange2ndSize(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int Type;
  char *units;
  float fVar2;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1d [13];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    return 0;
  }
  units = (char *)0x0;
  if (argc != 2) {
    units = argv[2];
  }
  if (argv[1] == (char *)0x0) {
    return 0;
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  fVar2 = GetValue(argv[1],units,local_1d);
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
    (*gui->get_coords)("Select an Object",&x,&y);
    Type = SearchScreen(x,y,0x103,&local_24,&local_28,&local_2c);
    if (Type == 0) goto switchD_080671f8_caseD_2f;
    cVar1 = ChangeObject2ndSize(Type,local_24,local_28,local_2c,(int)ROUND(fVar2),local_1d[0],'\x01'
                               );
    break;
  default:
    goto switchD_080671f8_caseD_2f;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelected2ndSize(0x101,(int)ROUND(fVar2),local_1d[0]);
    break;
  case 0x4d:
    cVar1 = ChangeSelected2ndSize(0x100,(int)ROUND(fVar2),local_1d[0]);
    goto joined_r0x08067230;
  case 0x4f:
    cVar1 = ChangeSelected2ndSize(1,(int)ROUND(fVar2),local_1d[0]);
joined_r0x08067230:
    if (cVar1 == '\0') goto switchD_080671f8_caseD_2f;
    goto LAB_08067232;
  }
  if (cVar1 != '\0') {
LAB_08067232:
    SetChangedFlag('\x01');
  }
switchD_080671f8_caseD_2f:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionChangeClearSize(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  Boolean BVar2;
  int Type;
  char *units;
  float fVar3;
  void *local_2c;
  void *local_28;
  void *local_24;
  Boolean local_1d [13];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    return 0;
  }
  units = (char *)0x0;
  if (argc != 2) {
    units = argv[2];
  }
  if (argv[1] == (char *)0x0) {
    return 0;
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  fVar3 = GetValue(argv[1],units,local_1d);
  fVar3 = fVar3 + fVar3;
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  switch(Type) {
  case 0x2e:
    (*gui->get_coords)("Select an Object",&x,&y);
    Type = SearchScreen(x,y,0x4305,&local_24,&local_28,&local_2c);
    if ((Type == 0) ||
       (BVar2 = ChangeObjectClearSize(Type,local_24,local_28,local_2c,(int)ROUND(fVar3),local_1d[0])
       , BVar2 == '\0')) goto switchD_08067410_caseD_22;
    goto LAB_08067448;
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
  case 0x35:
  case 0x36:
  case 0x37:
  case 0x38:
  case 0x39:
  case 0x3a:
  case 0x3b:
  case 0x3c:
  case 0x3d:
  case 0x3e:
  case 0x3f:
  case 0x40:
  case 0x41:
  case 0x42:
  case 0x43:
  case 0x44:
  case 0x45:
  case 0x48:
  case 0x4a:
  case 0x4e:
    goto switchD_08067410_caseD_22;
  case 0x46:
  case 0x4b:
    cVar1 = ChangeSelectedClearSize(0x4305,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x47:
    cVar1 = ChangeSelectedClearSize(0x4000,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x49:
    cVar1 = ChangeSelectedClearSize(4,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4c:
    cVar1 = ChangeSelectedClearSize(0x200,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4d:
    cVar1 = ChangeSelectedClearSize(0x100,(int)ROUND(fVar3),local_1d[0]);
    break;
  case 0x4f:
    cVar1 = ChangeSelectedClearSize(1,(int)ROUND(fVar3),local_1d[0]);
    break;
  default:
    goto switchD_08067410_caseD_22;
  }
  if (cVar1 != '\0') {
LAB_08067448:
    SetChangedFlag('\x01');
  }
switchD_08067410_caseD_22:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionAutoRoute(int argc,char **argv,int x,int y)

{
  String Ident;
  char cVar1;
  int iVar2;
  
  if (argc < 1) {
    hid_action("Busy");
    return 0;
  }
  Ident = *argv;
  hid_action("Busy");
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  if ((iVar2 == 0x46) || (iVar2 == 0x50)) {
    cVar1 = AutoRoute('\x01');
  }
  else {
    if (iVar2 != 3) goto LAB_08067667;
    cVar1 = AutoRoute('\0');
  }
  if (cVar1 != '\0') {
    SetChangedFlag('\x01');
  }
LAB_08067667:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionAutoPlaceSelected(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  int iVar2;
  
  hid_action("Busy");
  iVar2 = (*gui->confirm_dialog)
                    ("Auto-placement can NOT be undone.\nDo you want to continue anyway?\n",0);
  if (iVar2 == 0) {
    return 0;
  }
  HideCrosshair('\x01');
  BVar1 = AutoPlaceSelected();
  if (BVar1 != '\0') {
    SetChangedFlag('\x01');
  }
  RestoreCrosshair('\x01');
  return 0;
}



int ActionAddRats(int argc,char **argv,int x,int y)

{
  String Ident;
  Cardinal CVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  char cVar5;
  int iVar6;
  RatTypePtr *pRVar7;
  RatTypePtr *Line;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    return 0;
  }
  if (Settings.RatWarn != '\0') {
    ClearWarnings();
  }
  HideCrosshair('\x01');
  iVar6 = GetFunctionID(Ident);
  if (iVar6 == 0xe) {
    CVar1 = PCB->Data->RatN;
    iVar6 = CVar1 - 1;
    if (iVar6 != -1) {
      fVar2 = 100000000376832.00000000;
      Line = (RatTypePtr *)0x0;
      pRVar7 = PCB->Data->Rat + (CVar1 - 1);
      do {
        if (((*(byte *)&(pRVar7->Flags).f & 0x40) == 0) &&
           (fVar3 = (float)((pRVar7->Point1).X - (pRVar7->Point2).X),
           fVar4 = (float)((pRVar7->Point1).Y - (pRVar7->Point2).Y),
           fVar3 = fVar4 * fVar4 + fVar3 * fVar3, fVar3 < fVar2)) {
          Line = pRVar7;
          fVar2 = fVar3;
        }
        iVar6 = iVar6 + -1;
        pRVar7 = pRVar7 + -1;
      } while (iVar6 != -1);
      if (Line != (RatTypePtr *)0x0) {
        AddObjectToFlagUndoList(0x20,Line,Line,Line);
        (Line->Flags).f = (Line->Flags).f | 0x40;
        DrawRat(Line,0);
        Draw();
        CenterDisplay(((Line->Point1).X + (Line->Point2).X) / 2,
                      ((Line->Point1).Y + (Line->Point2).Y) / 2,'\0');
      }
    }
  }
  else {
    if (iVar6 < 0xf) {
      if (iVar6 != 3) goto LAB_080677f5;
      cVar5 = AddAllRats('\0',(anon_subr_void *)0x0);
    }
    else {
      if ((iVar6 != 0x46) && (iVar6 != 0x50)) goto LAB_080677f5;
      cVar5 = AddAllRats('\x01',(anon_subr_void *)0x0);
    }
    if (cVar5 != '\0') {
      SetChangedFlag('\x01');
      RestoreCrosshair('\x01');
      return 0;
    }
  }
LAB_080677f5:
  RestoreCrosshair('\x01');
  return 0;
}



void register_action_action_list(void)

{
  hid_register_actions(action_action_list,0x3a);
  return;
}



int ActionChangeName(int argc,char **argv,int x,int y)

{
  String Ident;
  LineTypePtr Ptr1;
  char cVar1;
  int Type;
  void *pvVar2;
  char **ppcVar3;
  char *Name;
  LayerTypePtr Layer;
  RubberbandTypePtr *pRVar4;
  uint uVar5;
  int *piVar6;
  void *local_18;
  void *local_14;
  void *local_10;
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (Ident == (String)0x0) {
    return 0;
  }
  HideCrosshair('\x01');
  Type = GetFunctionID(Ident);
  if (Type == 0x22) {
    Name = PCB->Name;
    if (Name == (char *)0x0) {
      Name = "";
    }
    Name = (*gui->prompt_for)("Enter the layout name:",Name);
    if (Name == (char *)0x0) goto LAB_08067996;
    cVar1 = ChangeLayoutName(Name);
  }
  else {
    if (Type == 0x2e) {
      (*gui->get_coords)("Select an Object",&x,&y);
      Type = SearchScreen(x,y,0x717,&local_10,&local_14,&local_18);
      if (Type != 0) {
        SaveUndoSerialNumber();
        pvVar2 = QueryInputAndChangeObjectName(Type,local_10,local_14,local_18);
        if ((pvVar2 != (void *)0x0) && (SetChangedFlag('\x01'), Type == 2)) {
          RestoreUndoSerialNumber();
          Crosshair.AttachedObject.RubberbandN = 0;
          LookupRatLines(2,local_10,local_14,local_18);
          if (Crosshair.AttachedObject.RubberbandN != 0) {
            uVar5 = 0;
            pRVar4 = Crosshair.AttachedObject.Rubberband;
            while( true ) {
              if (PCB->RatOn != '\0') {
                EraseRat((RatTypePtr *)pRVar4->Line);
              }
              Ptr1 = pRVar4->Line;
              uVar5 = uVar5 + 1;
              MoveObjectToRemoveUndoList(0x20,Ptr1,Ptr1,Ptr1);
              if (Crosshair.AttachedObject.RubberbandN <= uVar5) break;
              pRVar4 = pRVar4 + 1;
            }
          }
          IncrementUndoSerialNumber();
          Draw();
        }
      }
      goto LAB_08067996;
    }
    if (Type != 0x21) goto LAB_08067996;
    if (PCB->SilkActive == '\0') {
      piVar6 = (int *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      piVar6 = (int *)(&PCB->Data->field_0x4c +
                      ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    Name = "";
    if (*piVar6 != 0) {
      if (PCB->SilkActive == '\0') {
        ppcVar3 = (char **)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        ppcVar3 = (char **)(&PCB->Data->field_0x4c +
                           ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      Name = *ppcVar3;
    }
    Name = (*gui->prompt_for)("Enter the layer name:",Name);
    if (Name == (char *)0x0) goto LAB_08067996;
    if (PCB->SilkActive == '\0') {
      Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Layer = (LayerTypePtr)
              (&PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    cVar1 = ChangeLayerName(Layer,Name);
  }
  if (cVar1 != '\0') {
    SetChangedFlag('\x01');
  }
LAB_08067996:
  RestoreCrosshair('\x01');
  return 0;
}



void AdjustAttachedObjects(void)

{
  PointTypePtr pPVar1;
  int iVar2;
  
  if (Settings.Mode == 4) {
LAB_08067cd2:
    AdjustAttachedLine();
    return;
  }
  if (Settings.Mode < 5) {
    if (Settings.Mode == 2) {
      if ((PCB->RatDraw == '\0') && (PCB->Clipping != 0)) {
        AdjustTwoLine(PCB->Clipping + -1);
        return;
      }
      goto LAB_08067cd2;
    }
    if (2 < Settings.Mode) {
      if (Settings.Mode != 0x6d) {
        if (Crosshair.AttachedBox.State == 1) {
          Crosshair.AttachedBox.Point2.X = Crosshair.X;
          Crosshair.AttachedBox.Point2.Y = Crosshair.Y;
          return;
        }
        return;
      }
      goto LAB_08067d30;
    }
    if (Settings.Mode != 0) {
      return;
    }
  }
  else {
    if (Settings.Mode == 0x6d) {
LAB_08067d30:
      iVar2 = (*gui->shift_is_pressed)();
      Crosshair.AttachedBox.otherway = (Boolean)iVar2;
      return;
    }
    if (Settings.Mode != 0x6e) {
      if (Settings.Mode != 0x6a) {
        return;
      }
      pPVar1 = AdjustInsertPoint();
      if (pPVar1 == (PointTypePtr)0x0) {
        return;
      }
      InsertedPoint.X = pPVar1->X;
      InsertedPoint.Y = pPVar1->Y;
      InsertedPoint.X2 = pPVar1->X2;
      InsertedPoint.Y2 = pPVar1->Y2;
      InsertedPoint.ID = pPVar1->ID;
      return;
    }
  }
  if (Crosshair.AttachedBox.State == 0) {
    return;
  }
  Crosshair.AttachedBox.Point2.X = Crosshair.X;
  Crosshair.AttachedBox.Point2.Y = Crosshair.Y;
  return;
}



int ActionUndo(int argc,char **argv,int x,int y)

{
  String Ident;
  PCBTypePtr pPVar1;
  int iVar2;
  uint uVar3;
  BoxTypePtr pBVar4;
  LayerTypePtr Layer;
  void *ptr3_1;
  void *ptr3;
  void *ptr1;
  
  if (((argc < 1) || (Ident = *argv, Ident == (String)0x0)) || (*Ident == '\0')) {
    if ((Crosshair.AttachedObject.State != 0) ||
       ((Crosshair.AttachedBox.State != 0 && (Settings.Mode != 0x6d)))) {
      return 1;
    }
    HideCrosshair('\x01');
    if (Settings.Mode == 4) {
      if (Crosshair.AttachedPolygon.PointN != 0) {
        GoToPreviousPoint();
        RestoreCrosshair('\x01');
        return 0;
      }
    }
    else {
      if (Settings.Mode == 2) {
        if (Crosshair.AttachedLine.State == 1) {
          if (*(char *)&(PCB->Flags).f < '\0') {
            Undo('\x01');
          }
          Crosshair.AttachedLine.State = 0;
          SetLocalRef(0,0,'\0');
          RestoreCrosshair('\x01');
          return 0;
        }
        if (Crosshair.AttachedLine.State == 2) {
          SearchObjectByLocation
                    (0x24,&ptr3_1,&ptr1,&ptr3,Crosshair.AttachedLine.Point1.X,
                     Crosshair.AttachedLine.Point1.Y,0);
          Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)ptr1 + 0x2c);
          Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)ptr1 + 0x30);
          uVar3 = Undo('\x01');
          if ((uVar3 == 0) || (SetChangedFlag('\x01'), (uVar3 & 0x40) == 0)) {
            Crosshair.AttachedLine.Point2.X = Crosshair.AttachedLine.Point1.X;
            Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedLine.Point1.Y;
            RestoreCrosshair('\x01');
            return 0;
          }
          Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
          Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
          if ((uVar3 & 4) != 0) {
            SearchObjectByLocation
                      (0x24,&ptr3_1,&ptr1,&ptr3,Crosshair.AttachedLine.Point2.X,
                       Crosshair.AttachedLine.Point2.Y,0);
            pPVar1 = PCB;
            if (*(char *)&(PCB->Flags).f < '\0') {
              *(uint *)((int)ptr1 + 0x14) = *(uint *)((int)ptr1 + 0x14) | 4;
              if (pPVar1->SilkActive == '\0') {
                Layer = (LayerTypePtr)(&pPVar1->Data->field_0x4c + LayerStack[0] * 0x5c);
              }
              else {
                Layer = (LayerTypePtr)
                        (&pPVar1->Data->field_0x4c +
                        ((uint)(Settings.ShowSolderSide == '\0') + pPVar1->Data->LayerN) * 0x5c);
              }
              DrawLine(Layer,(LineTypePtr)ptr1,0);
            }
            Crosshair.AttachedLine.Point2.X = *(LocationType *)((int)ptr1 + 0x40);
            Crosshair.AttachedLine.Point2.Y = *(LocationType *)((int)ptr1 + 0x44);
          }
          Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
          Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
          FitCrosshairIntoGrid(Crosshair.X,Crosshair.Y);
          AdjustAttachedObjects();
          addedLines = addedLines + -1;
          if (addedLines == 0) {
            Crosshair.AttachedLine.State = 1;
            if (PCB->SilkActive == '\0') {
              lastLayer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
            }
            else {
              lastLayer = (LayerTypePtr)
                          (&PCB->Data->field_0x4c +
                          ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
            }
          }
          else {
            SearchObjectByLocation
                      (0x24,&ptr3_1,&ptr1,&ptr3,Crosshair.AttachedLine.Point1.X,
                       Crosshair.AttachedLine.Point1.Y,0);
            lastLayer = (LayerTypePtr)ptr3_1;
          }
          goto LAB_08067d76;
        }
      }
      else {
        if (Settings.Mode == 0x6d) {
          if (Crosshair.AttachedBox.State == 1) {
            Crosshair.AttachedBox.State = 0;
            goto LAB_08067d76;
          }
          if (Crosshair.AttachedBox.State == 2) {
            SearchObjectByLocation
                      (0x4000,&ptr1,&ptr3,&ptr3_1,Crosshair.AttachedBox.Point1.X,
                       Crosshair.AttachedBox.Point1.Y,0);
            pBVar4 = GetArcEnds((ArcTypePtr *)ptr3);
            Crosshair.AttachedBox.Point1.X = pBVar4->X1;
            Crosshair.AttachedBox.Point1.Y = pBVar4->Y1;
            Crosshair.AttachedBox.Point2.X = Crosshair.AttachedBox.Point1.X;
            Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedBox.Point1.Y;
            AdjustAttachedObjects();
            addedLines = addedLines + -1;
            if (addedLines == 0) {
              Crosshair.AttachedBox.State = 1;
            }
          }
        }
      }
    }
    iVar2 = Undo('\x01');
    if (iVar2 != 0) {
      SetChangedFlag('\x01');
    }
  }
  else {
    iVar2 = GetFunctionID(Ident);
    if (iVar2 == 0xd) {
      ClearUndoList('\0');
    }
  }
LAB_08067d76:
  RestoreCrosshair('\x01');
  return 0;
}



int ActionDisplay(int argc,char **argv,int childX,int childY)

{
  double dVar1;
  String Ident;
  PCBTypePtr pPVar2;
  Boolean BVar3;
  int local_8c;
  long lVar4;
  DataTypePtr *pDVar5;
  uint uVar6;
  crosshair_shape cVar7;
  char *pcVar8;
  int iVar9;
  PinTypePtr *Pin;
  PadTypePtr *Pad;
  int iVar10;
  uint uVar11;
  uint uVar12;
  BoxType area;
  void *local_30;
  PadTypePtr *local_2c;
  void *local_28;
  int local_24;
  int local_20 [4];
  
  if (argc < 1) {
    return 0;
  }
  Ident = *argv;
  if (argc == 1) {
    pcVar8 = (char *)0x0;
  }
  else {
    pcVar8 = argv[1];
  }
  if (Ident == (String)0x0) {
    return 0;
  }
  if ((pcVar8 != (char *)0x0) && (*pcVar8 != '\0')) {
    local_8c = GetFunctionID(Ident);
    pPVar2 = PCB;
    if (local_8c == 0x5b) {
      if (argc < 3) {
        return 0;
      }
      lVar4 = strtol(argv[1],(char **)0x0,10);
      pPVar2->GridOffsetX = lVar4;
      pPVar2 = PCB;
      lVar4 = strtol(argv[2],(char **)0x0,10);
      pPVar2->GridOffsetY = lVar4;
      if (Settings.DrawGrid == '\0') {
        return 0;
      }
      UpdateAll();
      return 0;
    }
LAB_080681e8:
    Message("Syntax error.  Usage:\n%s\n",
                        
            "Display(NameOnPCB|Description|Value)\nDisplay(Grid|Redraw)\nDisplay(CycleClip|CycleCrosshair|Toggle45Degree|ToggleStartDirection)\nDisplay(ToggleGrid|ToggleRubberBandMode|ToggleUniqueNames)\nDisplay(ToggleMask|ToggleName|ToggleClearLine|ToggleFullPoly|ToggleSnapPin)\nDisplay(ToggleThindraw|ToggleThindrawPoly|ToggleOrthoMove|ToggleLocalRef)\nDisplay(ToggleCheckPlanes|ToggleShowDRC|ToggleAutoDRC)\nDisplay(ToggleLiveRoute|LockNames|OnlyNames)\nDisplay(Pinout|PinOrPadName)\nDisplay(Scroll, Direction)"
           );
    return 1;
  }
  HideCrosshair('\x01');
  local_8c = GetFunctionID(Ident);
  pPVar2 = PCB;
  switch(local_8c) {
  case 8:
  case 0x2a:
  case 0x6f:
    pDVar5 = PCB->Data;
    iVar9 = pDVar5->ElementN - 1;
    if (iVar9 != -1) {
      iVar10 = pDVar5->ElementN * 300;
      while( true ) {
        iVar9 = iVar9 + -1;
        EraseElementName((ElementTypePtr *)((int)&pDVar5->Element[-1].BoundingBox.X1 + iVar10));
        if (iVar9 == -1) break;
        pDVar5 = PCB->Data;
        iVar10 = iVar10 + -300;
      }
    }
    pPVar2 = PCB;
    (PCB->Flags).f = (PCB->Flags).f & 0xffffff9f;
    if (local_8c == 8) {
      (pPVar2->Flags).f = (pPVar2->Flags).f | 0x20;
    }
    else {
      if (local_8c == 0x2a) {
        (pPVar2->Flags).f = (pPVar2->Flags).f | 0x40;
      }
    }
    pDVar5 = pPVar2->Data;
    local_8c = pDVar5->ElementN - 1;
    if (local_8c != -1) {
      iVar9 = pDVar5->ElementN * 300;
      while( true ) {
        local_8c = local_8c + -1;
        DrawElementName((ElementTypePtr *)((int)&pDVar5->Element[-1].BoundingBox.X1 + iVar9),0);
        if (local_8c == -1) break;
        pDVar5 = PCB->Data;
        iVar9 = iVar9 + -300;
      }
    }
    goto LAB_0806835f;
  default:
    RestoreCrosshair('\x01');
    goto LAB_080681e8;
  case 0xc:
    (*gui->invalidate_all)();
    break;
  case 0x12:
    uVar6 = (PCB->Flags).f;
    if ((uVar6 & 0x100) == 0) {
      PCB->Clipping = (PCB->Clipping + 1) % 3;
    }
    else {
      (PCB->Flags).f = uVar6 ^ 0x100;
      pPVar2->Clipping = 0;
    }
    AdjustAttachedObjects();
    break;
  case 0x13:
    cVar7 = Crosshair.shape + Union_Jack_Crosshair_Shape;
    Crosshair.shape = Basic_Crosshair_Shape;
    if (cVar7 != Crosshair_Shapes_Number) {
      Crosshair.shape = cVar7;
    }
    break;
  case 0x1f:
    Settings.DrawGrid = Settings.DrawGrid == '\0';
    UpdateAll();
    break;
  case 0x33:
    local_8c = SearchScreen(Crosshair.X,Crosshair.Y,0x303,&local_28,&local_2c,&local_30);
    if (local_8c == 2) {
      if (*(uint *)((int)local_28 + 0xe0) != 0) {
        uVar11 = 0;
        uVar6 = *(uint *)((int)local_28 + 0xe0);
        do {
          Pin = (PinTypePtr *)(uVar11 * 0x4c + *(int *)((int)local_28 + 0x100));
          if ((*(byte *)&(Pin->Flags).f & 0x20) == 0) {
            DrawPinName(Pin,0);
          }
          else {
            ErasePinName(Pin);
          }
          AddObjectToFlagUndoList(0x100,local_28,Pin,Pin);
          (Pin->Flags).f = (Pin->Flags).f ^ 0x20;
          uVar12 = *(uint *)((int)local_28 + 0xe0);
        } while ((uVar12 != 0) &&
                (uVar11 = (uVar12 + 1 + uVar11) - uVar6, uVar6 = uVar12, uVar11 < uVar12));
      }
      uVar6 = *(uint *)((int)local_28 + 0xe8);
      local_8c = 0;
      uVar12 = 0;
      uVar11 = uVar6;
      while ((uVar11 != 0 && (uVar12 < uVar11))) {
        Pad = (PadTypePtr *)(*(int *)((int)local_28 + 0x104) + local_8c);
        if ((*(byte *)&(Pad->Flags).f & 0x20) == 0) {
          DrawPadName(Pad,0);
        }
        else {
          ErasePadName(Pad);
        }
        AddObjectToFlagUndoList(0x200,local_28,Pad,Pad);
        (Pad->Flags).f = (Pad->Flags).f ^ 0x20;
        uVar11 = *(uint *)((int)local_28 + 0xe8);
        if (uVar11 == uVar6) {
          uVar12 = uVar12 + 1;
          local_8c = local_8c + 0x68;
        }
      }
    }
    else {
      if (local_8c < 3) {
        if (local_8c != 1) break;
        if ((*(byte *)&(local_2c->Flags).f & 0x20) == 0) {
          DrawViaName((PinTypePtr *)local_2c,0);
        }
        else {
          EraseViaName((PinTypePtr *)local_2c);
        }
        local_8c = 1;
      }
      else {
        if (local_8c == 0x100) {
          if ((*(byte *)&(local_2c->Flags).f & 0x20) == 0) {
            DrawPinName((PinTypePtr *)local_2c,0);
          }
          else {
            ErasePinName((PinTypePtr *)local_2c);
          }
          AddObjectToFlagUndoList(0x100,local_28,local_2c,local_30);
          (local_2c->Flags).f = (local_2c->Flags).f ^ 0x20;
          goto LAB_08068466;
        }
        if (local_8c != 0x200) break;
        if ((*(byte *)&(local_2c->Flags).f & 0x20) == 0) {
          DrawPadName(local_2c,0);
        }
        else {
          ErasePadName(local_2c);
        }
        local_8c = 0x200;
      }
      AddObjectToFlagUndoList(local_8c,local_28,local_2c,local_30);
      (local_2c->Flags).f = (local_2c->Flags).f ^ 0x20;
    }
LAB_08068466:
    SetChangedFlag('\x01');
    IncrementUndoSerialNumber();
LAB_0806835f:
    Draw();
    break;
  case 0x34:
    (*gui->get_coords)("Click on an element",local_20,&local_24);
    local_8c = SearchScreen(local_20[0],local_24,2,&local_28,&local_28,&local_28);
    if (local_8c != 0) {
      (*gui->show_item)(local_28);
    }
    break;
  case 0x39:
    area.X1 = 0;
    area.Y1 = 0;
    area.X2 = Output.Width;
    area.Y2 = Output.Height;
    RedrawOutput((BoxTypePtr)&area);
    break;
  case 0x57:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x100;
    AdjustAttachedObjects();
    break;
  case 0x58:
    uVar6 = (PCB->Flags).f ^ 0x80;
    (PCB->Flags).f = uVar6;
    if (((char)uVar6 < '\0') && (Settings.Mode == 2)) {
      SaveUndoSerialNumber();
      ResetFoundPinsViasAndPads('\x01');
      RestoreUndoSerialNumber();
      ResetFoundLinesAndPolygons('\x01');
      if (Crosshair.AttachedLine.State != 0) {
        LookupConnection(Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,'\x01',1,4)
        ;
      }
    }
    break;
  case 0x59:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x800;
    break;
  case 0x5a:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x100000;
    break;
  case 0x5b:
    dVar1 = PCB->Grid;
    PCB->Grid = 1.00000000;
    BVar3 = MoveCrosshairAbsolute(childX,childY);
    if (BVar3 != '\0') {
      RestoreCrosshair('\0');
    }
    SetGrid((float)dVar1,'\x01');
    break;
  case 0x5c:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x200000;
    ClearAndRedrawOutput();
    break;
  case 0x5d:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x2000;
    UpdateAll();
    break;
  case 0x5e:
    (PCB->Flags).f = (PCB->Flags).f ^ 1;
    UpdateAll();
    break;
  case 0x60:
    (PCB->Flags).f = (PCB->Flags).f ^ 8;
    break;
  case 0x61:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x10000;
    break;
  case 0x62:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x10;
    break;
  case 99:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x200;
    break;
  case 100:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x1000;
    break;
  case 0x65:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x4000;
    ClearAndRedrawOutput();
    break;
  case 0x66:
    (PCB->Flags).f = ((PCB->Flags).f ^ 0x40000) & 0xfff7ffff;
    break;
  case 0x67:
    (PCB->Flags).f = ((PCB->Flags).f ^ 0x80000) & 0xfffbffff;
    break;
  case 0x68:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x20000;
    ClearAndRedrawOutput();
    break;
  case 0x69:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x8000;
    break;
  case 0x6a:
    (PCB->Flags).f = (PCB->Flags).f ^ 2;
    break;
  case 0x6b:
    (PCB->Flags).f = (PCB->Flags).f ^ 4;
    ClearAndRedrawOutput();
    break;
  case 0x6c:
    (PCB->Flags).f = (PCB->Flags).f ^ 0x400;
  }
  RestoreCrosshair('\x01');
  return 0;
}



void EventMoveCrosshair(int ev_x,int ev_y)

{
  Boolean BVar1;
  
  if (IgnoreMotionEvents == '\0') {
    BVar1 = MoveCrosshairAbsolute(ev_x,ev_y);
    if (BVar1 != '\0') {
      AdjustAttachedObjects();
      RestoreCrosshair('\0');
      return;
    }
  }
  else {
    IgnoreMotionEvents = '\0';
  }
  return;
}



void ActionMovePointer(char *deltax,char *deltay)

{
  int DeltaX;
  LocationType LVar1;
  LocationType LVar2;
  long lVar3;
  int DeltaY;
  int DeltaY_00;
  
  LVar2 = Crosshair.Y;
  LVar1 = Crosshair.X;
  lVar3 = strtol(deltax,(char **)0x0,10);
  DeltaX = (int)ROUND((double)lVar3 * PCB->Grid);
  lVar3 = strtol(deltay,(char **)0x0,10);
  DeltaY = (int)ROUND((double)lVar3 * PCB->Grid);
  DeltaY_00 = DeltaY;
  if (Settings.ShowSolderSide != '\0') {
    DeltaY_00 = -DeltaY;
  }
  MoveCrosshairRelative(DeltaX,DeltaY_00);
  FitCrosshairIntoGrid(Crosshair.X,Crosshair.Y);
  Crosshair.X = LVar1;
  Crosshair.Y = LVar2;
  HideCrosshair('\0');
  if (Settings.ShowSolderSide != '\0') {
    DeltaY = -DeltaY;
  }
  MoveCrosshairRelative(DeltaX,DeltaY);
  AdjustAttachedObjects();
  RestoreCrosshair('\0');
  return;
}



void NotifyMode(void)

{
  char cVar1;
  Boolean BVar2;
  BYTE Steps;
  LineTypePtr Line;
  LayerTypePtr Layer;
  void *Ptr1;
  int type;
  PolygonTypePtr Polygon;
  LocationType *pLVar3;
  char *TextString;
  TextTypePtr Text;
  PointTypePtr pPVar4;
  ArcTypePtr *Arc;
  BoxTypePtr pBVar5;
  RatTypePtr *Line_00;
  Cardinal Layer_00;
  PinTypePtr *Via;
  int width;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  ElementTypePtr *Element;
  TextType *box;
  uint local_17c;
  RubberbandTypePtr *pRVar9;
  undefined *puVar10;
  TextType *pTVar11;
  int in_GS_OFFSET;
  byte bVar12;
  int local_150;
  TextType *local_14c;
  uint local_148;
  LayerTypePtr local_144;
  undefined local_140 [12];
  TextType estr [3];
  void *local_80;
  ElementTypePtr *local_7c;
  ElementTypePtr *local_78;
  ulong local_74;
  undefined4 local_70;
  undefined4 local_6c;
  ulong local_68;
  undefined4 local_64;
  undefined4 local_60;
  ulong local_5c;
  undefined4 local_58;
  undefined4 local_54;
  ulong local_50;
  undefined4 local_4c;
  undefined4 local_48;
  ulong local_44;
  undefined4 local_40;
  undefined4 local_3c;
  ulong local_38;
  undefined4 local_34;
  undefined4 local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  bVar12 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (Settings.RatWarn != '\0') {
    ClearWarnings();
  }
  pPVar4 = Crosshair.AttachedPolygon.Points;
  Layer_00 = Crosshair.AttachedPolygon.PointN;
  puVar10 = &stack0xfffffe74;
  switch(Settings.Mode) {
  case 1:
    if (PCB->ViaOn == '\0') {
      Message("You must turn via visibility on before\nyou can place vias\n");
      puVar10 = &stack0xfffffe74;
    }
    else {
      MakeFlags((FlagType *)&local_2c,0);
      Via = CreateNewVia(PCB->Data,Note.X,Note.Y,Settings.ViaThickness,Settings.Keepaway * 2,0,
                         Settings.ViaDrillingHole,(char *)0x0,
                         (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
      puVar10 = &stack0xfffffe74;
      if (Via != (PinTypePtr *)0x0) {
        AddObjectToCreateUndoList(1,Via,Via,Via);
        type = (*gui->shift_is_pressed)();
        if (type != 0) {
          ChangeObjectThermal(1,Via,Via,Via,(int)PCB->ThermStyle);
        }
        IncrementUndoSerialNumber();
        DrawVia(Via,0);
        Draw();
        puVar10 = &stack0xfffffe74;
      }
    }
    break;
  case 2:
    NotifyLine();
    puVar10 = &stack0xfffffe74;
    if (Crosshair.AttachedLine.State != 2) break;
    if ((Crosshair.X == Crosshair.AttachedLine.Point1.X) &&
       (Crosshair.Y == Crosshair.AttachedLine.Point1.Y)) {
      SetMode(2);
      puVar10 = &stack0xfffffe74;
      break;
    }
    if (PCB->RatDraw != '\0') {
      Line_00 = AddNet();
      puVar10 = &stack0xfffffe74;
      if (Line_00 != (RatTypePtr *)0x0) {
        addedLines = addedLines + 1;
        AddObjectToCreateUndoList(0x20,Line_00,Line_00,Line_00);
        IncrementUndoSerialNumber();
        DrawRat(Line_00,0);
        Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
        Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
        Draw();
        puVar10 = &stack0xfffffe74;
      }
      break;
    }
    if (PCB->Clipping == 0) {
LAB_08068b66:
      if ((Crosshair.AttachedLine.Point1.X != Crosshair.AttachedLine.Point2.X) ||
         (Crosshair.AttachedLine.Point1.Y != Crosshair.AttachedLine.Point2.Y)) {
LAB_08068b6e:
        local_17c = (PCB->Flags).f;
        MakeFlags((FlagType *)&local_44,
                  ~-(uint)((local_17c & 0x800) == 0) & 0x20 | ~-(uint)((local_17c & 0x80) == 0) & 4)
        ;
        local_148 = Crosshair.AttachedLine.Point1.X;
        local_144 = (LayerTypePtr)Settings.Keepaway;
        if (PCB->SilkActive == '\0') {
          Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Layer = (LayerTypePtr)
                  (&PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        Line = CreateDrawnLineOnLayer
                         (Layer,Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                          Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                          Settings.LineThickness,Settings.Keepaway * 2,
                          (FlagType)CONCAT48(local_3c,CONCAT44(local_40,local_44)));
        if (Line != (LineTypePtr)0x0) {
          addedLines = addedLines + 1;
          if (PCB->SilkActive == '\0') {
            Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            Ptr1 = (void *)(&PCB->Data->field_0x4c +
                           ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
          }
          AddObjectToCreateUndoList(4,Ptr1,Line,Line);
          if (PCB->SilkActive == '\0') {
            Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            Layer = (LayerTypePtr)
                    (&PCB->Data->field_0x4c +
                    ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
          }
          DrawLine(Layer,Line,0);
          if (PCB->ViaOn != '\0') {
            if (PCB->SilkActive == '\0') {
              Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
            }
            else {
              Layer = (LayerTypePtr)
                      (&PCB->Data->field_0x4c +
                      ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
            }
            type = GetLayerGroupNumberByPointer(Layer);
            width = GetLayerGroupNumberByPointer(lastLayer);
            if ((type != width) && (type = SearchObjectByLocation(), type == 0)) {
              MakeFlags((FlagType *)&local_50,0);
              Via = CreateNewVia(PCB->Data,Crosshair.AttachedLine.Point1.X,
                                 Crosshair.AttachedLine.Point1.Y,Settings.ViaThickness,
                                 Settings.Keepaway * 2,0,Settings.ViaDrillingHole,(char *)0x0,
                                 (FlagType)CONCAT48(local_48,CONCAT44(local_4c,local_50)));
              if (Via != (PinTypePtr *)0x0) {
                AddObjectToCreateUndoList(1,Via,Via,Via);
                DrawVia(Via,0);
              }
            }
          }
          Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
          Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
          IncrementUndoSerialNumber();
          if (PCB->SilkActive == '\0') {
            lastLayer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            lastLayer = (LayerTypePtr)
                        (&PCB->Data->field_0x4c +
                        ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
          }
        }
      }
      if (PCB->Clipping == 0) goto LAB_08068f75;
    }
    else {
      if ((Crosshair.AttachedLine.Point1.X != Crosshair.AttachedLine.Point2.X) ||
         (Crosshair.AttachedLine.Point1.Y != Crosshair.AttachedLine.Point2.Y)) goto LAB_08068b6e;
      if ((Crosshair.AttachedLine.Point1.X != Note.X) || (Crosshair.AttachedLine.Point1.Y != Note.Y)
         ) {
        Crosshair.AttachedLine.Point2.Y = Note.Y;
        Crosshair.AttachedLine.Point2.X = Note.X;
        goto LAB_08068b66;
      }
    }
    if ((Note.X != Crosshair.AttachedLine.Point2.X) || (Note.Y != Crosshair.AttachedLine.Point2.Y))
    {
      local_17c = (PCB->Flags).f;
      MakeFlags((FlagType *)&local_5c,
                ~-(uint)((local_17c & 0x800) == 0) & 0x20 | ~-(uint)((local_17c & 0x80) == 0) & 4);
      local_148 = Settings.Keepaway;
      local_144 = (LayerTypePtr)Crosshair.AttachedLine.Point2.X;
      if (PCB->SilkActive == '\0') {
        Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Layer = (LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      Line = CreateDrawnLineOnLayer
                       (Layer,Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,Note.X
                        ,Note.Y,Settings.LineThickness,Settings.Keepaway * 2,
                        (FlagType)CONCAT48(local_54,CONCAT44(local_58,local_5c)));
      if (Line != (LineTypePtr)0x0) {
        addedLines = addedLines + 1;
        if (PCB->SilkActive == '\0') {
          Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Ptr1 = (void *)(&PCB->Data->field_0x4c +
                         ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        AddObjectToCreateUndoList(4,Ptr1,Line,Line);
        IncrementUndoSerialNumber();
        if (PCB->SilkActive == '\0') {
          Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Layer = (LayerTypePtr)
                  (&PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        DrawLine(Layer,Line,0);
        Crosshair.AttachedLine.Point1.Y = Note.Y;
        Crosshair.AttachedLine.Point2.Y = Note.Y;
        Crosshair.AttachedLine.Point1.X = Note.X;
        Crosshair.AttachedLine.Point2.X = Note.X;
        if ((*(byte *)((int)&(PCB->Flags).f + 1) & 2) != 0) {
          PCB->Clipping = PCB->Clipping ^ 3;
        }
      }
    }
LAB_08068f75:
    Draw();
    puVar10 = &stack0xfffffe74;
    break;
  case 3:
    NotifyBlock();
    puVar10 = &stack0xfffffe74;
    if (((Crosshair.AttachedBox.State == 2) &&
        (puVar10 = &stack0xfffffe74,
        Crosshair.AttachedBox.Point1.X != Crosshair.AttachedBox.Point2.X)) &&
       (puVar10 = &stack0xfffffe74, Crosshair.AttachedBox.Point1.Y != Crosshair.AttachedBox.Point2.Y
       )) {
      MakeFlags((FlagType *)&local_68,
                (-(uint)(((PCB->Flags).f & 0x100000) == 0) & 0xffffffe0) + 0x30);
      if (PCB->SilkActive == '\0') {
        Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Layer = (LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      Polygon = CreateNewPolygonFromRectangle
                          (Layer,Crosshair.AttachedBox.Point1.X,Crosshair.AttachedBox.Point1.Y,
                           Crosshair.AttachedBox.Point2.X,Crosshair.AttachedBox.Point2.Y,
                           (FlagType)CONCAT48(local_60,CONCAT44(local_64,local_68)));
      if (Polygon != (PolygonTypePtr)0x0) {
        if (PCB->SilkActive == '\0') {
          Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Ptr1 = (void *)(&PCB->Data->field_0x4c +
                         ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        AddObjectToCreateUndoList(8,Ptr1,Polygon,Polygon);
        IncrementUndoSerialNumber();
        if (PCB->SilkActive == '\0') {
          Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Layer = (LayerTypePtr)
                  (&PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        DrawPolygon(Layer,Polygon,0);
        Draw();
      }
      Crosshair.AttachedBox.State = 0;
      puVar10 = &stack0xfffffe74;
    }
    break;
  case 4:
    NotifyLine();
    type = Crosshair.AttachedLine.Point2.X;
    if (Layer_00 < 3) {
      if (Layer_00 != 0) goto LAB_080692d7;
    }
    else {
      if ((pPVar4->X == Crosshair.AttachedLine.Point2.X) &&
         (type = pPVar4->X, pPVar4->Y == Crosshair.AttachedLine.Point2.Y)) {
        CopyAttachedPolygonToLayer();
        goto LAB_08068f75;
      }
LAB_080692d7:
      if ((type == (&pPVar4->X)[Layer_00 * 5 + -5]) &&
         (puVar10 = &stack0xfffffe74,
         Crosshair.AttachedLine.Point2.Y == (&pPVar4->X + Layer_00 * 5 + -5)[1])) break;
    }
    CreateNewPointInPolygon
              ((PolygonTypePtr)&Crosshair.AttachedPolygon,type,Crosshair.AttachedLine.Point2.Y);
    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
    Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedLine.Point2.Y;
    puVar10 = &stack0xfffffe74;
    break;
  case 5:
    type = (*gui->shift_is_pressed)();
    if ((type == 0) ||
       (type = SearchScreen(Note.X,Note.Y,2,&local_78,&local_7c,&local_80), Element = local_78,
       type != 2)) {
      Element = (ElementTypePtr *)0x0;
    }
    else {
      if (local_78 != (ElementTypePtr *)0x0) {
        local_14c = estr;
        type = 0x2d;
        box = local_78->Name;
        pTVar11 = local_14c;
        while (type != 0) {
          type = type + -1;
          (pTVar11->BoundingBox).X1 = (box->BoundingBox).X1;
          box = (TextType *)((int)box + (uint)bVar12 * -8 + 4);
          pTVar11 = (TextType *)((int)pTVar11 + (uint)bVar12 * -8 + 4);
        }
        estr[0].TextString = (char *)__strdup();
        estr[1].TextString = (char *)__strdup();
        estr[2].TextString = (char *)__strdup();
        RemoveElement(Element);
      }
    }
    BVar2 = CopyPastebufferToLayout(Note.X,Note.Y);
    if (BVar2 != '\0') {
      SetChangedFlag('\x01');
    }
    puVar10 = &stack0xfffffe74;
    if (((Element != (ElementTypePtr *)0x0) &&
        (type = SearchScreen(Note.X,Note.Y,2,&local_78,&local_7c,&local_80),
        puVar10 = &stack0xfffffe74, type == 2)) &&
       (puVar10 = &stack0xfffffe74, local_78 != (ElementTypePtr *)0x0)) {
      local_148 = 1;
      local_17c = (PCB->Flags).f;
      if ((local_17c & 0x40) == 0) {
        local_148 = -(uint)((local_17c & 0x20) == 0) & 2;
      }
      local_14c = estr;
      local_17c = 0;
      box = local_78->Name;
      local_144 = (LayerTypePtr)0x0;
      do {
        if (local_17c == local_148) {
          EraseElementName(local_78);
        }
        local_150 = local_17c + 0xc;
        r_delete_entry((rtree_t *)(&PCB->Data->ElementN)[local_150],(BoxType *)box);
        pLVar3 = (LocationType *)((int)&(local_14c->BoundingBox).X1 + (int)&local_144->Name);
        (box->BoundingBox).X1 = *pLVar3;
        (box->BoundingBox).Y1 = pLVar3[1];
        (box->BoundingBox).X2 = pLVar3[2];
        (box->BoundingBox).Y2 = pLVar3[3];
        box->ID = pLVar3[4];
        (box->Flags).f = pLVar3[5];
        *(LocationType *)(box->Flags).t = pLVar3[6];
        *(LocationType *)((box->Flags).t + 4) = pLVar3[7];
        box->net = (LibraryEntryType *)pLVar3[8];
        box->Scale = pLVar3[9];
        box->X = pLVar3[10];
        box->Y = pLVar3[0xb];
        *(LocationType *)&box->Direction = pLVar3[0xc];
        box->TextString = (char *)pLVar3[0xd];
        box->Element = (void *)pLVar3[0xe];
        *(ElementTypePtr **)((int)((int)local_78 + 0x5c) + (int)local_144) = local_78;
        SetTextBoundingBox((FontTypePtr)&PCB->Font,(TextTypePtr)(local_78->Name + local_17c));
        r_insert_entry((rtree_t *)(&PCB->Data->ElementN)[local_150],(BoxType *)box,0);
        if (local_17c == local_148) {
          DrawElementName(local_78,0);
        }
        local_17c = local_17c + 1;
        box = box + 1;
        local_144 = (LayerTypePtr)&local_144->polygon_tree;
        puVar10 = &stack0xfffffe74;
      } while (local_17c != 3);
    }
    break;
  case 6:
    TextString = (*gui->prompt_for)("Enter text:","");
    puVar10 = &stack0xfffffe74;
    if (TextString != (char *)0x0) {
      if (*TextString != '\0') {
        Layer_00 = LayerStack[0];
        if (PCB->SilkActive != '\0') {
          Layer_00 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        type = GetLayerGroupNumberByNumber(Layer_00);
        width = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
        local_17c = 0x80;
        if (type != width) {
          local_17c = 0;
        }
        MakeFlags((FlagType *)&local_74,local_17c);
        local_148 = Note.X;
        if (PCB->SilkActive == '\0') {
          local_144 = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          local_144 = (LayerTypePtr)
                      (&PCB->Data->field_0x4c +
                      ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        Text = CreateNewText(local_144,(FontTypePtr)&PCB->Font,Note.X,Note.Y,'\0',Settings.TextScale
                             ,TextString,(FlagType)CONCAT48(local_6c,CONCAT44(local_70,local_74)));
        if (Text != (TextTypePtr)0x0) {
          if (PCB->SilkActive == '\0') {
            Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            Ptr1 = (void *)(&PCB->Data->field_0x4c +
                           ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
          }
          AddObjectToCreateUndoList(0x10,Ptr1,Text,Text);
          IncrementUndoSerialNumber();
          if (PCB->SilkActive == '\0') {
            Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            Layer = (LayerTypePtr)
                    (&PCB->Data->field_0x4c +
                    ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
          }
          DrawText(Layer,Text,0);
          Draw();
        }
      }
      free(TextString);
      puVar10 = &stack0xfffffe74;
    }
    break;
  case 0x66:
    (*gui->shift_is_pressed)();
    if (Settings.ShowSolderSide == '\0') {
      Steps = '\x03';
    }
    else {
      Steps = '\x01';
    }
    RotateScreenObject(Note.X,Note.Y,Steps);
    puVar10 = &stack0xfffffe74;
    break;
  case 0x67:
    type = SearchScreen(Note.X,Note.Y,0x583f,&local_78,&local_7c,&local_80);
    puVar10 = &stack0xfffffe74;
    if (type != 0) {
      if ((*(byte *)((int)&(local_7c->Flags).f + 1) & 0x20) == 0) {
        if (type == 2) {
          local_17c = 0;
          Crosshair.AttachedObject.RubberbandN = 0;
          LookupRatLines(2,local_78,local_7c,local_80);
          pRVar9 = Crosshair.AttachedObject.Rubberband;
          if (Crosshair.AttachedObject.RubberbandN != 0) {
            while( true ) {
              if (PCB->RatOn != '\0') {
                EraseRat((RatTypePtr *)pRVar9->Line);
              }
              Line = pRVar9->Line;
              uVar8 = (Line->Flags).f;
              if ((uVar8 & 0x200) == 0) {
                (Line->Flags).f = uVar8 ^ 0x200;
              }
              else {
                MoveObjectToRemoveUndoList(0x20,Line,Line,Line);
              }
              local_17c = local_17c + 1;
              if (Crosshair.AttachedObject.RubberbandN <= local_17c) break;
              pRVar9 = pRVar9 + 1;
            }
          }
        }
        RemoveObject(type,local_78,local_7c,local_80);
        IncrementUndoSerialNumber();
        SetChangedFlag('\x01');
        puVar10 = &stack0xfffffe74;
      }
      else {
        Message("Sorry, the object is locked\n");
        puVar10 = &stack0xfffffe74;
      }
    }
    break;
  case 0x68:
  case 0x69:
    if (Crosshair.AttachedObject.State != 0) {
      puVar10 = &stack0xfffffe74;
      if (Crosshair.AttachedObject.State != 1) break;
      if (Settings.Mode == 0x69) {
        CopyObject(Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3,
                   Note.X - Crosshair.AttachedObject.X,Note.Y - Crosshair.AttachedObject.Y);
      }
      else {
        MoveObjectAndRubberband
                  (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3,
                   Note.X - Crosshair.AttachedObject.X,Note.Y - Crosshair.AttachedObject.Y);
        SetLocalRef(0,0,'\0');
      }
LAB_08069d2f:
      SetChangedFlag('\x01');
      Crosshair.AttachedObject.Type = 0;
      Crosshair.AttachedObject.State = 0;
      puVar10 = &stack0xfffffe74;
      break;
    }
    type = 0x5c1f;
    if (Settings.Mode == 0x69) {
      type = 0x441f;
    }
    Crosshair.AttachedObject.Type =
         SearchScreen(Note.X,Note.Y,type,&Crosshair.AttachedObject.Ptr1,
                      &Crosshair.AttachedObject.Ptr2,&Crosshair.AttachedObject.Ptr3);
    puVar10 = &stack0xfffffe74;
    if (Crosshair.AttachedObject.Type == 0) break;
    if ((Settings.Mode != 0x68) ||
       ((*(byte *)((int)Crosshair.AttachedObject.Ptr2 + 0x15) & 0x20) == 0)) {
      AttachForCopy(Note.X,Note.Y);
      puVar10 = &stack0xfffffe74;
      break;
    }
    goto LAB_0806a437;
  case 0x6a:
    if (Crosshair.AttachedObject.State != 0) {
      puVar10 = &stack0xfffffe74;
      if (Crosshair.AttachedObject.State != 1) break;
      if (Crosshair.AttachedObject.Type == 8) {
        InsertPointIntoObject
                  (8,Crosshair.AttachedObject.Ptr1,fake.poly,&polyIndex,InsertedPoint.X,
                   InsertedPoint.Y,'\0');
      }
      else {
        InsertPointIntoObject
                  (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,&polyIndex,InsertedPoint.X,InsertedPoint.Y,'\0');
      }
      goto LAB_08069d2f;
    }
    Crosshair.AttachedObject.Type =
         SearchScreen(Note.X,Note.Y,0x2c,&Crosshair.AttachedObject.Ptr1,
                      &Crosshair.AttachedObject.Ptr2,&Crosshair.AttachedObject.Ptr3);
    puVar10 = &stack0xfffffe74;
    if (Crosshair.AttachedObject.Type == 0) break;
    if ((*(byte *)((int)Crosshair.AttachedObject.Ptr2 + 0x15) & 0x20) == 0) {
      if (Crosshair.AttachedObject.Type == 8) {
        fake.poly = (PolygonTypePtr)Crosshair.AttachedObject.Ptr2;
        polyIndex = GetLowestDistancePolygonPoint
                              ((PolygonTypePtr)Crosshair.AttachedObject.Ptr2,Note.X,Note.Y);
        pPVar4 = (fake.poly)->Points;
        fake.line.Point1.X = pPVar4[polyIndex].X;
        fake.line.Point1.Y = pPVar4[polyIndex].Y;
        fake.line.Point1.X2 = pPVar4[polyIndex].X2;
        fake.line.Point1.Y2 = pPVar4[polyIndex].Y2;
        fake.line.Point1.ID = pPVar4[polyIndex].ID;
        Layer_00 = polyIndex;
        if (polyIndex == 0) {
          Layer_00 = (fake.poly)->PointN;
        }
        type = Layer_00 * 5 + -5;
        fake.line.Point2.X = (&pPVar4->X)[type];
        Crosshair.AttachedObject.Ptr2 = &fake.line;
        fake.line.Point2.Y = (&pPVar4->Y)[type];
        fake.line.Point2.X2 = (&pPVar4->X2)[type];
        fake.line.Point2.Y2 = (&pPVar4->Y2)[type];
        fake.line.Point2.ID = (&pPVar4->ID)[type];
      }
      Crosshair.AttachedObject.State = 1;
      pPVar4 = AdjustInsertPoint();
      InsertedPoint.X = pPVar4->X;
      InsertedPoint.Y = pPVar4->Y;
      InsertedPoint.X2 = pPVar4->X2;
      InsertedPoint.Y2 = pPVar4->Y2;
      InsertedPoint.ID = pPVar4->ID;
      puVar10 = &stack0xfffffe74;
      break;
    }
LAB_0806a437:
    Message("Sorry, the object is locked\n");
    Crosshair.AttachedObject.Type = 0;
    puVar10 = &stack0xfffffe74;
    break;
  case 0x6c:
    type = SearchScreen(Note.X,Note.Y,0x101,&local_78,&local_7c,&local_80);
    puVar10 = &stack0xfffffe74;
    if ((type != 0) && (puVar10 = &stack0xfffffe74, (*(byte *)((int)local_80 + 0x14) & 8) == 0)) {
      width = (*gui->shift_is_pressed)();
      if (width == 0) {
        width = LayerStack[0];
        if (PCB->SilkActive != '\0') {
          width = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        cVar1 = (char)(width >> 0x1f);
        if (((int)(uint)*(byte *)((int)local_80 + width / 2 + 0x18) >>
             ((((char)width - cVar1 & 1U) + cVar1) * '\x04' & 0x1f) & 0xfU) == 0) {
          local_17c = SEXT14(PCB->ThermStyle);
        }
        else {
          local_17c = 0;
        }
      }
      else {
        width = LayerStack[0];
        if (PCB->SilkActive != '\0') {
          width = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
        }
        cVar1 = (char)(width >> 0x1f);
        local_17c = ((int)(uint)*(byte *)((int)local_80 + width / 2 + 0x18) >>
                     ((((char)width - cVar1 & 1U) + cVar1) * '\x04' & 0x1f) & 0xfU) + 1;
        if (5 < local_17c) {
          local_17c = 1;
        }
      }
      ChangeObjectThermal(type,local_78,local_7c,local_80,local_17c);
      puVar10 = &stack0xfffffe74;
    }
    break;
  case 0x6d:
    if (Crosshair.AttachedBox.State == 0) {
      Crosshair.AttachedBox.Point1.X = Note.X;
      Crosshair.AttachedBox.State = 1;
      Crosshair.AttachedBox.Point1.Y = Note.Y;
      puVar10 = &stack0xfffffe74;
      Crosshair.AttachedBox.Point2.X = Crosshair.AttachedBox.Point1.X;
      Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedBox.Point1.Y;
      break;
    }
    puVar10 = &stack0xfffffe74;
    if ((Crosshair.AttachedBox.State < 0) ||
       (puVar10 = &stack0xfffffe74, 2 < Crosshair.AttachedBox.State)) break;
    uVar6 = Note.X - Crosshair.AttachedBox.Point1.X;
    local_17c = Note.Y - Crosshair.AttachedBox.Point1.Y;
    uVar8 = (int)local_17c >> 0x1f;
    uVar7 = (int)uVar6 >> 0x1f;
    if (Crosshair.AttachedBox.otherway == '\0') {
      type = (uVar8 ^ local_17c) - uVar8;
      width = (uVar7 ^ uVar6) - uVar7;
      if (type <= width) goto LAB_0806a053;
LAB_080698ed:
      width = type;
      if ((int)uVar6 < 0) {
        type = -width;
        local_17c = 0xffffffff;
        local_144 = (LayerTypePtr)0xb4;
      }
      else {
        local_17c = 1;
        local_144 = (LayerTypePtr)0x0;
        type = width;
      }
      Crosshair.AttachedBox.Point2.X = type + Crosshair.AttachedBox.Point1.X;
      type = -0x5a;
      if (local_17c == (uVar8 | 1)) {
        type = 0x5a;
      }
    }
    else {
      type = (uVar8 ^ local_17c) - uVar8;
      width = (uVar7 ^ uVar6) - uVar7;
      if (type <= width) goto LAB_080698ed;
LAB_0806a053:
      if ((int)local_17c < 0) {
        type = -width;
        local_144 = (LayerTypePtr)0x5a;
      }
      else {
        local_144 = (LayerTypePtr)0xffffffa6;
        type = width;
      }
      Crosshair.AttachedBox.Point2.Y = type + Crosshair.AttachedBox.Point1.Y;
      type = 0x5a;
      if ((uVar7 | 1) == (uVar8 | 1)) {
        type = -0x5a;
      }
    }
    puVar10 = &stack0xfffffe74;
    if (width != 0) {
      MakeFlags((FlagType *)&local_38,~-(uint)(((PCB->Flags).f & 0x800) == 0) & 0x20);
      local_14c = (TextType *)Crosshair.AttachedBox.Point2.X;
      local_148 = Settings.Keepaway;
      if (PCB->SilkActive == '\0') {
        Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Layer = (LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      Arc = CreateNewArcOnLayer(Layer,Crosshair.AttachedBox.Point2.X,Crosshair.AttachedBox.Point2.Y,
                                width,width,(int)local_144,type,Settings.LineThickness,
                                Settings.Keepaway * 2,
                                (FlagType)CONCAT48(local_30,CONCAT44(local_34,local_38)));
      puVar10 = &stack0xfffffe74;
      if (Arc != (ArcTypePtr *)0x0) {
        pBVar5 = GetArcEnds(Arc);
        Crosshair.AttachedBox.Point1.X = pBVar5->X2;
        Crosshair.AttachedBox.Point1.Y = pBVar5->Y2;
        if (PCB->SilkActive == '\0') {
          Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Ptr1 = (void *)(&PCB->Data->field_0x4c +
                         ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        Crosshair.AttachedBox.Point2.X = Crosshair.AttachedBox.Point1.X;
        Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedBox.Point1.Y;
        AddObjectToCreateUndoList(0x4000,Ptr1,Arc,Arc);
        IncrementUndoSerialNumber();
        addedLines = addedLines + 1;
        if (PCB->SilkActive == '\0') {
          Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Layer = (LayerTypePtr)
                  (&PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        DrawArc(Layer,Arc,0);
        Draw();
        Crosshair.AttachedBox.State = 2;
        puVar10 = &stack0xfffffe74;
      }
    }
    break;
  case 0x6e:
    local_17c = 0x5f1f;
    Note.Click = '\x01';
    (*gui->add_timer)((anon_subr_void_hidval *)local_140,(ulong)click_cb,200);
    do {
      uVar8 = SearchScreen(Note.X,Note.Y,local_17c,&local_78,&local_7c,&local_80);
      if (((Note.Hit == 0) && ((uVar8 & 0x5c1f) != 0)) &&
         ((*(byte *)((int)&(local_7c->Flags).f + 1) & 0x20) == 0)) {
        Note.ptr2 = local_7c;
        Note.ptr1 = local_78;
        Note.ptr3 = local_80;
        Note.Hit = uVar8;
      }
      if (((Note.Moving == '\0') && ((uVar8 & 0x473f) != 0)) &&
         ((*(byte *)&(local_7c->Flags).f & 0x40) != 0)) {
        Note.Moving = '\x01';
      }
    } while (((Note.Hit == 0) || (puVar10 = &stack0xfffffe70, Note.Moving == '\0')) &&
            ((puVar10 = &stack0xfffffe70, uVar8 != 0 &&
             (local_17c = local_17c & ~uVar8, puVar10 = &stack0xfffffe70, local_17c != 0))));
    break;
  case 0x6f:
    type = SearchScreen(Note.X,Note.Y,0x1441f,&local_78,&local_7c,&local_80);
    if (type == 2) {
      local_17c = local_7c->PinN;
      (local_7c->Flags).f = (local_7c->Flags).f ^ 0x2000;
      if (local_17c != 0) {
        Via = local_7c->Pin;
        uVar8 = 0;
        (Via->Flags).f = ((Via->Flags).f ^ 0x2000) & 0xffffffbf;
        while (uVar8 = uVar8 + 1, uVar8 < local_17c) {
          Via[uVar8].Flags.f = (Via[uVar8].Flags.f ^ 0x2000) & 0xffffffbf;
        }
      }
      local_17c = local_7c->PadN;
      type = 0;
      uVar8 = 0;
      while ((local_17c != 0 && (uVar8 < local_17c))) {
        uVar8 = uVar8 + 1;
        width = (int)&(local_7c->Pad->BoundingBox).X1 + type;
        type = type + 0x68;
        *(uint *)(width + 0x14) = (*(uint *)(width + 0x14) ^ 0x2000) & 0xffffffbf;
      }
      (local_7c->Flags).f = (local_7c->Flags).f & 0xffffffbf;
      DrawElement(local_7c,0);
      Draw();
      hid_actionl("Report");
      puVar10 = &stack0xfffffe74;
    }
    else {
      puVar10 = &stack0xfffffe74;
      if (type != 0) {
        local_17c = *(uint *)((int)local_80 + 0x14) ^ 0x2000;
        *(uint *)((int)local_80 + 0x14) = local_17c;
        if ((local_17c & 0x2040) == 0x2040) {
          *(uint *)((int)local_80 + 0x14) = local_17c & 0xffffffbf;
          DrawObject(type,local_78,local_7c,0);
          Draw();
        }
        hid_actionl("Report");
        puVar10 = &stack0xfffffe74;
      }
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)(puVar10 + -4) = 0x806a6a2;
    __stack_chk_fail();
  }
  return;
}



int ActionMode(int argc,char **argv,int x,int y)

{
  String Ident;
  Boolean BVar1;
  int iVar2;
  int Mode;
  BoxType box_1;
  BoxType box;
  
  if ((argc < 1) || (Ident = *argv, Ident == (String)0x0)) {
    Message("Syntax error.  Usage:\n%s\n",
                        
            "Mode(Arc|Arrow|Copy|InsertPoint|Line|Lock|Move|None|PasteBuffer)\nMode(Polygon|Rectangle|Remove|Rotate|Text|Thermal|Via)\nMode(Notify|Release|Cancel|Stroke)\nMode(Save|Restore)"
           );
    return 1;
  }
  Note.X = Crosshair.X;
  Note.Y = Crosshair.Y;
  HideCrosshair('\x01');
  iVar2 = GetFunctionID(Ident);
  Mode = Settings.Mode;
  switch(iVar2) {
  case 5:
switchD_0806a728_caseD_5:
    SetMode(0x6d);
    break;
  case 6:
    goto switchD_0806a728_caseD_6;
  case 9:
    SetMode(0);
    SetMode(Mode);
    break;
  case 0x11:
    SetMode(0x69);
    break;
  case 0x1b:
    if (Settings.Mode < 7) {
      if (4 < Settings.Mode) goto LAB_0806a797;
      if (Settings.Mode == 2) {
        if (Crosshair.AttachedLine.State != 0) {
          SetMode(0);
          SetMode(2);
          break;
        }
      }
      else {
        if (Settings.Mode < 3) {
          if (Settings.Mode != 1) break;
          goto LAB_0806a797;
        }
        if (Settings.Mode == 3) {
          if (Crosshair.AttachedBox.State != 0) {
            SetMode(0);
            SetMode(3);
            break;
          }
        }
        else {
          if (Settings.Mode != 4) break;
          if (Crosshair.AttachedLine.State != 0) {
            SetMode(0);
            SetMode(4);
            break;
          }
        }
      }
    }
    else {
      if (Settings.Mode == 0x6d) {
        if (Crosshair.AttachedBox.State == 0) goto switchD_0806a728_caseD_6;
        SetMode(0);
        goto switchD_0806a728_caseD_5;
      }
      if (Settings.Mode < 0x6e) {
        if (Settings.Mode < 0x66) break;
      }
      else {
        if (Settings.Mode != 0x6f) break;
      }
LAB_0806a797:
      SetMode(0);
    }
switchD_0806a728_caseD_6:
    SetMode(0x6e);
    break;
  case 0x20:
    SetMode(0x6a);
    break;
  case 0x25:
switchD_0806a728_caseD_25:
    SetMode(2);
    break;
  case 0x27:
    SetMode(0x6f);
    break;
  case 0x29:
    SetMode(0x68);
    break;
  case 0x2c:
    SetMode(0);
    break;
  case 0x30:
    SetMode(5);
    break;
  case 0x35:
switchD_0806a728_caseD_35:
    SetMode(4);
    break;
  case 0x38:
switchD_0806a728_caseD_38:
    SetMode(3);
    break;
  case 0x3a:
    if (Note.Click == '\0') {
      if (Note.Moving == '\0') {
        if (Note.Hit == 0) {
          if (Settings.Mode == 0x6e) {
            box.X1 = Crosshair.AttachedBox.Point2.X;
            if (Crosshair.AttachedBox.Point1.X <= Crosshair.AttachedBox.Point2.X) {
              box.X1 = Crosshair.AttachedBox.Point1.X;
            }
            box.Y1 = Crosshair.AttachedBox.Point2.Y;
            if (Crosshair.AttachedBox.Point1.Y <= Crosshair.AttachedBox.Point2.Y) {
              box.Y1 = Crosshair.AttachedBox.Point1.Y;
            }
            box.X2 = Crosshair.AttachedBox.Point2.X;
            if (Crosshair.AttachedBox.Point2.X <= Crosshair.AttachedBox.Point1.X) {
              box.X2 = Crosshair.AttachedBox.Point1.X;
            }
            box.Y2 = Crosshair.AttachedBox.Point2.Y;
            if (Crosshair.AttachedBox.Point2.Y <= Crosshair.AttachedBox.Point1.Y) {
              box.Y2 = Crosshair.AttachedBox.Point1.Y;
            }
            RestoreUndoSerialNumber();
            BVar1 = SelectBlock((BoxTypePtr)&box,'\x01');
            if (BVar1 == '\0') {
              if (Bumped != '\0') {
                IncrementUndoSerialNumber();
              }
            }
            else {
              SetChangedFlag('\x01');
            }
            Crosshair.AttachedBox.State = 0;
          }
        }
        else {
          NotifyMode();
          Note.Hit = 0;
        }
      }
      else {
        RestoreUndoSerialNumber();
        NotifyMode();
        ClearBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber));
        SetBufferNumber(Note.Buffer);
        Note.Moving = '\0';
        Note.Hit = 0;
      }
    }
    else {
      box_1.X1 = -10000000;
      box_1.Y1 = -10000000;
      box_1.X2 = 10000000;
      box_1.Y2 = 10000000;
      Note.Click = '\0';
      SaveUndoSerialNumber();
      Mode = (*gui->shift_is_pressed)();
      if (Mode == 0) {
        BVar1 = SelectBlock((BoxTypePtr)&box_1,'\0');
        if (BVar1 != '\0') {
          SetChangedFlag('\x01');
        }
        if (Note.Moving != '\0') {
          Note.Moving = '\0';
          Note.Hit = 0;
          break;
        }
      }
      RestoreUndoSerialNumber();
      BVar1 = SelectObject();
      if (BVar1 != '\0') {
        SetChangedFlag('\x01');
      }
      Note.Hit = 0;
      Note.Moving = '\0';
    }
    if (saved_mode != '\0') {
      RestoreMode();
    }
    saved_mode = '\0';
    break;
  case 0x3c:
    SetMode(0x67);
    break;
  case 0x42:
    RestoreMode();
    break;
  case 0x43:
    SetMode(0x66);
    break;
  case 0x44:
    SaveMode();
    break;
  case 0x51:
    if (Settings.Mode == 2) {
      if (Crosshair.AttachedLine.State != 0) goto switchD_0806a728_caseD_25;
    }
    else {
      if (Settings.Mode == 0x6d) {
        if (Crosshair.AttachedBox.State != 0) goto switchD_0806a728_caseD_5;
      }
      else {
        if (Settings.Mode == 3) {
          if (Crosshair.AttachedBox.State != 0) goto switchD_0806a728_caseD_38;
        }
        else {
          if ((Settings.Mode == 4) && (Crosshair.AttachedLine.State != 0))
          goto switchD_0806a728_caseD_35;
        }
      }
    }
    SaveMode();
    saved_mode = '\x01';
    SetMode(0x6e);
  case 0x2d:
    NotifyMode();
    break;
  case 0x52:
    SetMode(6);
    break;
  case 0x55:
    SetMode(0x6c);
    break;
  case 0x6d:
    SetMode(1);
  }
  RestoreCrosshair('\x01');
  return 0;
}



int ActionDelete(int argc,char **argv,int x,int y)

{
  char cVar1;
  Boolean BVar2;
  String Ident;
  int iVar3;
  
  Ident = (String)0x0;
  if (0 < argc) {
    Ident = *argv;
  }
  iVar3 = GetFunctionID(Ident);
  Note.X = Crosshair.X;
  Note.Y = Crosshair.Y;
  if (iVar3 == -1) {
    BVar2 = RemoveSelected();
    if (BVar2 != '\0') {
      HideCrosshair('\x01');
      goto LAB_0806ad50;
    }
    HideCrosshair('\x01');
  }
  else {
    HideCrosshair('\x01');
    if (iVar3 != 0x2e) {
      if (iVar3 < 0x2f) {
        if (iVar3 != 3) goto LAB_0806ad50;
        cVar1 = DeleteRats('\0');
      }
      else {
        if (iVar3 == 0x46) {
          RemoveSelected();
          goto LAB_0806ad50;
        }
        if (iVar3 != 0x50) goto LAB_0806ad50;
        cVar1 = DeleteRats('\x01');
      }
      if (cVar1 != '\0') {
        SetChangedFlag('\x01');
      }
      goto LAB_0806ad50;
    }
  }
  SaveMode();
  SetMode(0x67);
  NotifyMode();
  RestoreMode();
LAB_0806ad50:
  RestoreCrosshair('\x01');
  return 0;
}



int __r_find_neighbor_reg_in_sea(BoxType *region,void *cl)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int local_18;
  int local_14;
  
  iVar5 = *(int *)((int)cl + 0x14);
  iVar1 = region->Y2;
  local_14 = region->X2;
  iVar2 = region->Y1;
  local_18 = region->X1;
  if (iVar5 == 2) {
    iVar5 = -local_14;
    local_14 = -local_18;
    iVar4 = -iVar2;
    iVar6 = -iVar1;
    local_18 = iVar5;
  }
  else {
    if (iVar5 == 3) {
      iVar4 = local_14;
      iVar6 = local_18;
      local_18 = -iVar1;
      local_14 = -iVar2;
    }
    else {
      iVar4 = iVar1;
      iVar6 = iVar2;
      if (iVar5 == 1) {
        iVar4 = -local_18;
        iVar6 = -local_14;
        local_18 = iVar2;
        local_14 = iVar1;
      }
    }
  }
  if (((*(int *)((int)cl + 8) < iVar4) && (iVar5 = *(int *)((int)cl + 0x10), iVar6 < iVar5)) &&
     (*(int *)((int)cl + 4) + iVar6 < local_14 + iVar5)) {
    uVar3 = (uint)(iVar6 + local_18 < iVar5 + *(int *)((int)cl + 0xc));
  }
  else {
    uVar3 = 0;
  }
  return uVar3;
}



int __r_find_neighbor_rect_in_reg(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int local_1c;
  int local_18;
  
  local_18 = box->X2;
  iVar2 = box->Y2;
  iVar1 = box->Y1;
  local_1c = box->X1;
  iVar5 = *(int *)((int)cl + 0x14);
  if (iVar5 == 2) {
    iVar5 = -local_1c;
    local_1c = -local_18;
    iVar3 = -iVar2;
    iVar4 = -iVar1;
    local_18 = iVar5;
  }
  else {
    if (iVar5 == 3) {
      iVar3 = local_1c;
      iVar4 = local_18;
      local_1c = -iVar2;
      local_18 = -iVar1;
    }
    else {
      iVar3 = iVar1;
      iVar4 = iVar2;
      if (iVar5 == 1) {
        iVar3 = -local_18;
        iVar4 = -local_1c;
        local_1c = iVar1;
        local_18 = iVar2;
      }
    }
  }
  if ((((*(int *)((int)cl + 8) < iVar4) && (iVar2 = *(int *)((int)cl + 0x10), iVar3 < iVar2)) &&
      (*(int *)((int)cl + 4) + iVar3 < local_18 + iVar2)) &&
     ((iVar3 + local_1c < *(int *)((int)cl + 0xc) + iVar2 && (iVar4 <= iVar2)))) {
    *(BoxType **)cl = box;
    iVar2 = 1;
    *(int *)((int)cl + 8) = iVar4;
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Removing unreachable block (ram,0x0806b3bd)
// WARNING: Removing unreachable block (ram,0x0806b438)
// WARNING: Removing unreachable block (ram,0x0806b418)
// WARNING: Removing unreachable block (ram,0x0806b044)
// WARNING: Removing unreachable block (ram,0x0806b34c)
// WARNING: Removing unreachable block (ram,0x0806b458)
// WARNING: Removing unreachable block (ram,0x0806b478)
// WARNING: Removing unreachable block (ram,0x0806b270)
// WARNING: Removing unreachable block (ram,0x0806b265)
// WARNING: Removing unreachable block (ram,0x0806b272)
// WARNING: Removing unreachable block (ram,0x0806b472)
// WARNING: Removing unreachable block (ram,0x0806b47a)
// WARNING: Removing unreachable block (ram,0x0806b452)
// WARNING: Removing unreachable block (ram,0x0806b45a)
// WARNING: Removing unreachable block (ram,0x0806b352)
// WARNING: Removing unreachable block (ram,0x0806b358)
// WARNING: Removing unreachable block (ram,0x0806b048)
// WARNING: Removing unreachable block (ram,0x0806b050)
// WARNING: Removing unreachable block (ram,0x0806b414)
// WARNING: Removing unreachable block (ram,0x0806b41a)
// WARNING: Removing unreachable block (ram,0x0806b42f)
// WARNING: Removing unreachable block (ram,0x0806b43a)
// WARNING: Removing unreachable block (ram,0x0806b3c2)
// WARNING: Removing unreachable block (ram,0x0806b3c8)

PerturbationType *
createPerturbation(PerturbationType *__return_storage_ptr__,PointerListTypePtr selected,double T)

{
  void **ppvVar1;
  ElementTypePtr *pEVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  uint uVar6;
  long lVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  ElementTypePtr *pEVar12;
  int iVar13;
  uint uVar14;
  anon_enum_32_for_which aVar15;
  uint local_38;
  double local_34;
  byte local_2c;
  
  ppvVar1 = selected->Ptr;
  uVar6 = random();
  pEVar2 = (ElementTypePtr *)ppvVar1[uVar6 % selected->PtrN];
  lVar7 = random();
  iVar11 = lVar7 % (3 - (uint)(selected->PtrN < 2));
  if (iVar11 == 1) {
    if (pEVar2->PadN == 0) {
      lVar7 = random();
      aVar15 = ROTATE;
      pEVar12 = (ElementTypePtr *)0x0;
      iVar11 = 0;
      local_2c = (char)lVar7 + (char)(lVar7 / 3) * -3 + 1;
      iVar10 = 0;
    }
    else {
      lVar7 = random();
      aVar15 = ROTATE;
      iVar10 = 0;
      pEVar12 = (ElementTypePtr *)0x0;
      local_2c = (byte)lVar7 & 3;
      iVar11 = 0;
    }
  }
  else {
    if (iVar11 == 2) {
      ppvVar1 = selected->Ptr;
      uVar6 = random();
      uVar14 = selected->PtrN - 1;
      pEVar12 = (ElementTypePtr *)ppvVar1[uVar6 % uVar14];
      if (pEVar2 == pEVar12) {
        pEVar12 = (ElementTypePtr *)selected->Ptr[uVar14];
      }
      if (((pEVar2->PinN != 0) && (*(char *)&(pEVar12->Flags).f < '\0')) ||
         ((pEVar12->PinN != 0 && (*(char *)&(pEVar2->Flags).f < '\0')))) {
        createPerturbation(__return_storage_ptr__,selected,T);
        return __return_storage_ptr__;
      }
      aVar15 = HID_Real;
      iVar10 = 0;
      iVar11 = 0;
      local_2c = 0;
    }
    else {
      if (iVar11 == 0) {
        dVar3 = SQRT(T);
        dVar4 = (double)(PCB->MaxWidth / 3);
        dVar5 = dVar3;
        if (dVar4 <= dVar3) {
          dVar5 = dVar4;
        }
        if (250.00000000 <= dVar5) {
          iVar11 = PCB->MaxWidth / 3;
          local_34 = (double)iVar11;
          if (dVar3 < (double)iVar11) {
            local_34 = dVar3;
          }
        }
        else {
          local_34 = 250.00000000;
        }
        dVar4 = (double)(PCB->MaxHeight / 3);
        dVar5 = dVar3;
        if (dVar4 <= dVar3) {
          dVar5 = dVar4;
        }
        if (250.00000000 <= dVar5) {
          dVar4 = (double)(PCB->MaxHeight / 3);
          if (dVar3 < dVar4) {
            dVar4 = dVar3;
          }
        }
        else {
          dVar4 = 250.00000000;
        }
        iVar11 = 10;
        lVar7 = random();
        iVar10 = (int)ROUND((local_34 + local_34) *
                            ((double)lVar7 / 2147483647.00000000 - 0.50000000));
        lVar7 = random();
        uVar6 = 1;
        iVar13 = (int)ROUND(((double)lVar7 / 2147483647.00000000 - 0.50000000) * (dVar4 + dVar4));
        if (1000.00000000 < (float)T) {
          iVar11 = 100;
        }
        if (iVar10 < 1) {
          uVar6 = ~-(uint)(iVar10 == 0);
        }
        local_38 = 1;
        if (iVar13 < 1) {
          local_38 = ~-(uint)(iVar13 == 0);
        }
        local_2c = 0;
        iVar9 = (pEVar2->VBox).X1;
        iVar10 = (uVar6 + iVar10 / iVar11) * iVar11;
        iVar8 = -iVar9;
        if (SBORROW4(iVar10,iVar8) != iVar10 + iVar9 < 0) {
          iVar10 = iVar8;
        }
        iVar9 = PCB->MaxWidth - (pEVar2->VBox).X2;
        if (iVar9 < iVar10) {
          iVar10 = iVar9;
        }
        iVar9 = (pEVar2->VBox).Y1;
        iVar8 = -iVar9;
        iVar11 = (iVar13 / iVar11 + local_38) * iVar11;
        if (SBORROW4(iVar11,iVar8) != iVar11 + iVar9 < 0) {
          iVar11 = iVar8;
        }
        iVar13 = PCB->MaxHeight - (pEVar2->VBox).Y2;
        if (iVar13 < iVar11) {
          iVar11 = iVar13;
        }
        aVar15 = SHIFT;
        pEVar12 = (ElementTypePtr *)0x0;
      }
      else {
        aVar15 = SHIFT;
        iVar10 = 0;
        iVar11 = 0;
        pEVar12 = (ElementTypePtr *)0x0;
        local_2c = 0;
      }
    }
  }
  __return_storage_ptr__->other = pEVar12;
  __return_storage_ptr__->DY = iVar11;
  __return_storage_ptr__->DX = iVar10;
  __return_storage_ptr__->which = aVar15;
  __return_storage_ptr__->rotate = local_2c;
  __return_storage_ptr__->element = pEVar2;
  return __return_storage_ptr__;
}



// WARNING: Removing unreachable block (ram,0x0806c420)
// WARNING: Removing unreachable block (ram,0x0806c41b)
// WARNING: Removing unreachable block (ram,0x0806c422)

double __regparm1 ComputeCost(NetListTypePtr *Nets,double T0,double T)

{
  Cardinal *pCVar1;
  undefined4 uVar2;
  direction_t dVar3;
  Cardinal CVar4;
  double dVar5;
  BoxListTypePtr_conflict *Boxes;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  bool bVar9;
  char "ComputeCost" [12];
  int iVar10;
  int iVar11;
  NetTypePtr *pNVar12;
  ConnectionTypePtr *pCVar13;
  BoxTypePtr pBVar14;
  BoxListTypePtr_conflict *Boxes_00;
  BoxTypePtr pBVar15;
  DataTypePtr *pDVar16;
  PointerListTypePtr_conflict *list;
  void **ppvVar17;
  undefined4 *puVar18;
  BoxType *pBVar19;
  uint uVar20;
  LocationType LVar21;
  int iVar22;
  LocationType LVar23;
  int iVar24;
  int iVar25;
  int iVar26;
  uint uVar27;
  uint uVar28;
  int iVar29;
  int iVar30;
  uint uVar31;
  LocationType LVar32;
  int iVar33;
  LocationType LVar34;
  double dVar35;
  double dVar36;
  double dVar37;
  double local_f4;
  double local_ec;
  BoxListTypePtr_conflict *local_e0;
  BoxListTypePtr_conflict *local_dc;
  int local_d4;
  int local_d0;
  uint local_cc;
  uint local_c8;
  int local_b8;
  double local_b4;
  rtree_t *local_a8;
  uint local_a4;
  int local_a0;
  r_neighbor_info ni;
  direction_t dir [4];
  PointerListType ceboxes;
  PointerListType seboxes;
  BoxListType componentside;
  BoxListType solderside;
  BoxListType bounds;
  rtree_t *local_24;
  rtree_t *local_20 [4];
  
  bounds.BoxN = 0;
  bounds.BoxMax = 0;
  solderside.BoxN = 0;
  solderside.BoxMax = 0;
  componentside.BoxN = 0;
  componentside.BoxMax = 0;
  bounds.Box = (BoxTypePtr)0x0;
  solderside.Box = (BoxTypePtr)0x0;
  componentside.Box = (BoxTypePtr)0x0;
  iVar10 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar11 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  local_a4 = 0;
  if (Nets->NetN == 0) {
LAB_0806c42f:
    local_ec = 0.00000000;
  }
  else {
    do {
      iVar24 = 0;
      uVar28 = 0;
      pNVar12 = Nets->Net + local_a4;
      if (pNVar12->ConnectionN != 0) {
        do {
          puVar18 = (undefined4 *)((int)&pNVar12->Connection->X + iVar24);
          if (puVar18[2] == 0x100) {
            puVar18[5] = iVar10;
            *puVar18 = *(undefined4 *)(puVar18[4] + 0x34);
            puVar18[1] = *(undefined4 *)(puVar18[4] + 0x38);
          }
          else {
            if (puVar18[2] == 0x200) {
              iVar33 = iVar11;
              if (*(char *)(puVar18[3] + 0x14) < '\0') {
                iVar33 = iVar10;
              }
              puVar18[5] = iVar33;
              *puVar18 = *(undefined4 *)(puVar18[4] + 0x2c);
              puVar18[1] = *(undefined4 *)(puVar18[4] + 0x30);
            }
            else {
              Message("Odd connection type encountered in UpdateXY");
            }
          }
          uVar28 = uVar28 + 1;
          iVar24 = iVar24 + 0x1c;
          pNVar12 = Nets->Net + local_a4;
        } while (uVar28 < pNVar12->ConnectionN);
      }
      local_a4 = local_a4 + 1;
    } while (local_a4 < Nets->NetN);
    if (Nets->NetN == 0) goto LAB_0806c42f;
    local_c8 = 0;
    local_ec = 0.00000000;
    do {
      uVar28 = Nets->Net[local_c8].ConnectionN;
      if (1 < uVar28) {
        pCVar13 = Nets->Net[local_c8].Connection;
        local_cc = 1;
        pCVar1 = &pCVar13->group;
        iVar10 = pCVar13->X;
        LVar32 = pCVar13->Y;
        iVar24 = LVar32;
        iVar11 = iVar10;
        bVar7 = true;
        bVar9 = pCVar13->type == 0x200;
        do {
          iVar33 = pCVar13[1].X;
          if (iVar33 < iVar10) {
            iVar10 = iVar33;
          }
          if (iVar33 <= iVar11) {
            iVar33 = iVar11;
          }
          iVar11 = pCVar13[1].Y;
          if (iVar11 < iVar24) {
            iVar24 = iVar11;
          }
          if (LVar32 < iVar11) {
            LVar32 = iVar11;
          }
          bVar8 = false;
          if (pCVar13[1].type == 0x200) {
            bVar8 = bVar9;
          }
          bVar6 = false;
          if (pCVar13[1].group == *pCVar1) {
            bVar6 = bVar7;
          }
          pCVar13 = pCVar13 + 1;
          local_cc = local_cc + 1;
          iVar11 = iVar33;
          bVar7 = bVar6;
          bVar9 = bVar8;
        } while (local_cc != uVar28);
        pBVar14 = GetBoxMemory((BoxListTypePtr_conflict *)&bounds);
        pBVar14->X1 = iVar10;
        pBVar14->Y1 = iVar24;
        pBVar14->X2 = iVar33;
        pBVar14->Y2 = LVar32;
        if ((bVar6) || (!bVar8)) {
          dVar35 = 0.00000000;
        }
        else {
          dVar35 = 3000.00000000;
        }
        local_ec = local_ec + (double)((LVar32 - iVar24) / 100 + (iVar33 - iVar10) / 100) + dVar35;
      }
      local_c8 = local_c8 + 1;
    } while (local_c8 <= Nets->NetN && Nets->NetN != local_c8);
  }
  dVar35 = ComputeIntersectionArea((BoxListTypePtr_conflict *)&bounds);
  FreeBoxListMemory((BoxListTypePtr_conflict *)&bounds);
  pDVar16 = PCB->Data;
  local_d0 = pDVar16->ElementN - 1;
  if (local_d0 != -1) {
    local_f4 = 0.00000000;
    iVar10 = pDVar16->ElementN * 300;
    do {
      local_d4 = iVar10 + -300;
      iVar10 = (int)&pDVar16->Element[-1].BoundingBox.X1 + iVar10;
      Boxes_00 = (BoxListTypePtr_conflict *)&componentside;
      Boxes = (BoxListTypePtr_conflict *)&solderside;
      if ((*(uint *)(iVar10 + 0x14) & 0x80) != 0) {
        Boxes_00 = (BoxListTypePtr_conflict *)&solderside;
        Boxes = (BoxListTypePtr_conflict *)&componentside;
      }
      pBVar14 = GetBoxMemory(Boxes_00);
      if ((*(int *)(iVar10 + 0xe0) != 0) || (*(int *)(iVar10 + 0xe8) != 0)) {
        pBVar14->X1 = 10000000;
        pBVar14->Y1 = 10000000;
        pBVar14->X2 = -10000000;
        pBVar14->Y2 = -10000000;
        if (*(uint *)(iVar10 + 0xe0) != 0) {
          iVar11 = *(int *)(iVar10 + 0x100);
          uVar20 = 0;
          iVar33 = -10000000;
          local_a0 = 10000000;
          local_a4 = -10000000;
          uVar28 = *(uint *)(iVar10 + 0xe0);
          iVar24 = 10000000;
          do {
            iVar22 = uVar20 * 0x4c + iVar11;
            iVar25 = *(int *)(iVar22 + 0x24) / 2 + *(int *)(iVar22 + 0x28) * 2;
            iVar29 = *(int *)(iVar22 + 0x34) - iVar25;
            if (iVar24 <= iVar29) {
              iVar29 = iVar24;
            }
            pBVar14->X1 = iVar29;
            iVar24 = *(int *)(iVar22 + 0x38) - iVar25;
            if (local_a0 < iVar24) {
              iVar24 = local_a0;
            }
            pBVar14->Y1 = iVar24;
            iVar30 = *(int *)(iVar22 + 0x34) + iVar25;
            if (iVar30 < (int)local_a4) {
              iVar30 = local_a4;
            }
            pBVar14->X2 = iVar30;
            iVar25 = iVar25 + *(int *)(iVar22 + 0x38);
            if (iVar33 <= iVar25) {
              iVar33 = iVar25;
            }
            pBVar14->Y2 = iVar33;
            uVar31 = *(uint *)(iVar10 + 0xe0);
          } while ((uVar31 != 0) &&
                  (uVar20 = (uVar31 + 1 + uVar20) - uVar28, local_a4 = iVar30, local_a0 = iVar24,
                  uVar28 = uVar31, iVar24 = iVar29, uVar20 < uVar31));
        }
        uVar28 = *(uint *)(iVar10 + 0xe8);
        local_a0 = 0;
        uVar20 = 0;
        uVar31 = uVar28;
        while ((uVar31 != 0 && (uVar20 < uVar31))) {
          iVar33 = local_a0 + *(int *)(iVar10 + 0x104);
          iVar11 = *(int *)(iVar33 + 0x24) / 2 + *(int *)(iVar33 + 0x28) * 2;
          iVar24 = *(int *)(iVar33 + 0x40);
          if (*(int *)(iVar33 + 0x2c) == iVar24 || *(int *)(iVar33 + 0x2c) < iVar24) {
            iVar24 = *(int *)(iVar33 + 0x2c);
          }
          iVar25 = iVar24 - iVar11;
          if (pBVar14->X1 < iVar24 - iVar11) {
            iVar25 = pBVar14->X1;
          }
          pBVar14->X1 = iVar25;
          iVar24 = *(int *)(iVar33 + 0x44);
          if (*(int *)(iVar33 + 0x30) == iVar24 || *(int *)(iVar33 + 0x30) < iVar24) {
            iVar24 = *(int *)(iVar33 + 0x30);
          }
          iVar25 = iVar24 - iVar11;
          if (pBVar14->Y1 < iVar24 - iVar11) {
            iVar25 = pBVar14->Y1;
          }
          pBVar14->Y1 = iVar25;
          iVar24 = *(int *)(iVar33 + 0x40);
          if (iVar24 <= *(int *)(iVar33 + 0x2c)) {
            iVar24 = *(int *)(iVar33 + 0x2c);
          }
          iVar25 = pBVar14->X2;
          if (pBVar14->X2 <= iVar11 + iVar24) {
            iVar25 = iVar11 + iVar24;
          }
          pBVar14->X2 = iVar25;
          iVar24 = *(int *)(iVar33 + 0x44);
          if (iVar24 <= *(int *)(iVar33 + 0x30)) {
            iVar24 = *(int *)(iVar33 + 0x30);
          }
          iVar33 = iVar11 + iVar24;
          if (iVar11 + iVar24 < pBVar14->Y2) {
            iVar33 = pBVar14->Y2;
          }
          pBVar14->Y2 = iVar33;
          uVar31 = *(uint *)(iVar10 + 0xe8);
          if (*(uint *)(iVar10 + 0xe8) == uVar28) {
            uVar20 = uVar20 + 1;
            local_a0 = local_a0 + 0x68;
            uVar31 = uVar28;
          }
        }
        if (*(uint *)(iVar10 + 0xe0) != 0) {
          uVar20 = 0;
          uVar28 = *(uint *)(iVar10 + 0xe0);
          pBVar14 = (BoxTypePtr)0x0;
          do {
            iVar25 = uVar20 * 0x4c + *(int *)(iVar10 + 0x100);
            pBVar15 = GetBoxMemory(Boxes);
            iVar11 = *(int *)(iVar25 + 0x28);
            iVar33 = *(int *)(iVar25 + 0x24) / 2;
            iVar24 = *(int *)(iVar25 + 0x34) - iVar33;
            pBVar15->X1 = iVar24;
            iVar29 = *(int *)(iVar25 + 0x38) - iVar33;
            pBVar15->Y1 = iVar29;
            iVar22 = *(int *)(iVar25 + 0x34) + iVar33;
            pBVar15->X2 = iVar22;
            iVar33 = iVar33 + *(int *)(iVar25 + 0x38);
            pBVar15->Y2 = iVar33;
            if (pBVar14 != (BoxTypePtr)0x0) {
              iVar25 = pBVar14->X1;
              iVar11 = iVar11 * 2;
              if (iVar24 == iVar25) {
                if (iVar22 != pBVar14->X2) {
                  local_a8 = (rtree_t *)pBVar14->Y1;
                  if ((rtree_t *)iVar29 != local_a8) goto LAB_0806bb6f;
                  goto LAB_0806bc59;
                }
                local_a8 = (rtree_t *)pBVar14->Y1;
                uVar31 = (int)local_a8 - iVar33 >> 0x1f;
                iVar26 = ((int)local_a8 - iVar33 ^ uVar31) - uVar31;
                uVar31 = iVar29 - pBVar14->Y2;
                uVar27 = (int)uVar31 >> 0x1f;
                iVar30 = (uVar31 ^ uVar27) - uVar27;
                if (iVar26 <= iVar30) {
                  iVar30 = iVar26;
                }
                if (iVar11 <= iVar30) goto LAB_0806bb57;
LAB_0806bcc4:
                if (iVar25 < iVar24) {
                  iVar24 = iVar25;
                }
                pBVar14->X1 = iVar24;
                if (iVar29 <= (int)local_a8) {
                  local_a8 = (rtree_t *)iVar29;
                }
                iVar11 = pBVar14->X2;
                if (pBVar14->X2 <= iVar22) {
                  iVar11 = iVar22;
                }
                *(rtree_t **)&pBVar14->Y1 = local_a8;
                pBVar14->X2 = iVar11;
                if (iVar33 < pBVar14->Y2) {
                  iVar33 = pBVar14->Y2;
                }
                pBVar14->Y2 = iVar33;
                Boxes->BoxN = Boxes->BoxN - 1;
                pBVar15 = pBVar14;
              }
              else {
                local_a8 = (rtree_t *)pBVar14->Y1;
LAB_0806bb57:
                if ((rtree_t *)iVar29 == local_a8) {
LAB_0806bc59:
                  if (iVar33 == pBVar14->Y2) {
                    uVar31 = iVar25 - iVar22 >> 0x1f;
                    iVar26 = (iVar25 - iVar22 ^ uVar31) - uVar31;
                    uVar31 = iVar24 - pBVar14->X2;
                    uVar27 = (int)uVar31 >> 0x1f;
                    iVar30 = (uVar31 ^ uVar27) - uVar27;
                    if (iVar26 <= iVar30) {
                      iVar30 = iVar26;
                    }
                    if (iVar30 < iVar11) goto LAB_0806bcc4;
                  }
                }
              }
            }
LAB_0806bb6f:
            uVar31 = *(uint *)(iVar10 + 0xe0);
          } while ((uVar31 != 0) &&
                  (uVar20 = (uVar31 + 1 + uVar20) - uVar28, uVar28 = uVar31, pBVar14 = pBVar15,
                  uVar20 < uVar31));
        }
        if ((*(int *)(iVar10 + 0x110) < 0) ||
           (((*(int *)(iVar10 + 0x114) < 0 || (PCB->MaxWidth < *(int *)(iVar10 + 0x118))) ||
            (PCB->MaxHeight < *(int *)(iVar10 + 0x11c))))) {
          local_f4 = local_f4 + 1000.00000000;
        }
      }
      local_d0 = local_d0 + -1;
      if (local_d0 == -1) goto LAB_0806bda2;
      pDVar16 = PCB->Data;
      iVar10 = local_d4;
    } while( true );
  }
  local_f4 = 0.00000000;
LAB_0806bda2:
  local_dc = (BoxListTypePtr_conflict *)&componentside;
  local_e0 = (BoxListTypePtr_conflict *)&solderside;
  dVar36 = ComputeIntersectionArea(local_e0);
  dVar37 = ComputeIntersectionArea(local_dc);
  FreeBoxListMemory(local_e0);
  FreeBoxListMemory(local_dc);
  seboxes.PtrN = 0;
  seboxes.PtrMax = 0;
  ceboxes.PtrN = 0;
  pDVar16 = PCB->Data;
  ceboxes.PtrMax = 0;
  seboxes.Ptr = (void **)0x0;
  ceboxes.Ptr = (void **)0x0;
  dir[0] = NORTH;
  dir[1] = EAST;
  dir[2] = SOUTH;
  iVar10 = pDVar16->ElementN - 1;
  dir[3] = WEST;
  if (iVar10 != -1) {
    iVar11 = pDVar16->ElementN * 300;
    while( true ) {
      iVar24 = (int)&pDVar16->Element[-1].BoundingBox.X1 + iVar11;
      list = (PointerListTypePtr_conflict *)&ceboxes;
      if (*(char *)(iVar24 + 0x14) < '\0') {
        list = (PointerListTypePtr_conflict *)&seboxes;
      }
      ppvVar17 = GetPointerMemory(list);
      puVar18 = (undefined4 *)calloc(1,0x14);
      *(undefined4 **)ppvVar17 = puVar18;
      if (puVar18 == (undefined4 *)0x0) {
        __fprintf_chk(stderr,1,"malloc() failed in %s\n","ComputeCost");
                    // WARNING: Subroutine does not return
        exit(1);
      }
      uVar2 = *(undefined4 *)(iVar24 + 0x110);
      iVar10 = iVar10 + -1;
      puVar18[4] = iVar24;
      *puVar18 = uVar2;
      puVar18[1] = *(undefined4 *)(iVar24 + 0x114);
      puVar18[2] = *(undefined4 *)(iVar24 + 0x118);
      puVar18[3] = *(undefined4 *)(iVar24 + 0x11c);
      if (iVar10 == -1) break;
      pDVar16 = PCB->Data;
      iVar11 = iVar11 + -300;
    }
  }
  local_20[0] = r_create_tree((BoxType **)seboxes.Ptr,seboxes.PtrN,1);
  local_24 = r_create_tree((BoxType **)ceboxes.Ptr,ceboxes.PtrN,1);
  FreePointerListMemory((PointerListTypePtr_conflict *)&seboxes);
  FreePointerListMemory((PointerListTypePtr_conflict *)&ceboxes);
  local_b8 = 0;
  local_b4 = 0.00000000;
  do {
    pDVar16 = PCB->Data;
    local_a0 = pDVar16->ElementN - 1;
    if (local_a0 != -1) {
      dVar3 = dir[local_b8];
      iVar10 = pDVar16->ElementN * 300;
      do {
        local_a4 = iVar10 + -300;
        iVar10 = (int)&pDVar16->Element[-1].BoundingBox.X1 + iVar10;
        if (*(char *)(iVar10 + 0x14) < '\0') {
          local_a8 = local_20[0];
        }
        else {
          local_a8 = local_24;
        }
        iVar11 = *(int *)(iVar10 + 0x110);
        ni.neighbor = (BoxType *)0x0;
        iVar24 = *(int *)(iVar10 + 0x114);
        iVar33 = *(int *)(iVar10 + 0x118);
        iVar25 = *(int *)(iVar10 + 0x11c);
        if (dVar3 == EAST) {
          ni.trap.Y1 = -PCB->MaxWidth;
LAB_0806c1f8:
          ni.trap.Y2 = -iVar33;
          ni.trap.X1 = iVar24;
          ni.trap.X2 = iVar25;
        }
        else {
          if (dVar3 == SOUTH) {
            ni.trap.X2 = -iVar11;
            ni.trap.Y1 = -PCB->MaxHeight;
            ni.trap.Y2 = -iVar25;
            ni.trap.X1 = -iVar33;
          }
          else {
            if (dVar3 == WEST) {
              ni.trap.X1 = -iVar25;
              ni.trap.X2 = -iVar24;
              ni.trap.Y1 = 0;
              ni.trap.Y2 = iVar11;
            }
            else {
              ni.trap.Y1 = 0;
              ni.trap.Y2 = iVar24;
              ni.trap.X1 = iVar11;
              ni.trap.X2 = iVar33;
              if (dVar3 == EAST) goto LAB_0806c1f8;
            }
          }
        }
        ni.search_dir = dVar3;
        r_search(local_a8,(BoxType *)0x0,__r_find_neighbor_reg_in_sea,__r_find_neighbor_rect_in_reg,
                 &ni);
        if (ni.neighbor != (BoxType *)0x0) {
          if (*(char **)(iVar10 + 0x58) == (char *)0x0) {
            iVar11 = ni.neighbor[1].X1;
            iVar24 = 1;
LAB_0806c0c0:
            if (*(char *)(iVar10 + 0x54) == *(char *)(iVar11 + 0x54)) {
LAB_0806c1b2:
              local_b4 = (double)iVar24 + local_b4;
            }
          }
          else {
            iVar11 = ni.neighbor[1].X1;
            if ((*(char **)(iVar11 + 0x58) != (char *)0x0) &&
               (iVar24 = strcmp(*(char **)(iVar10 + 0x58),*(char **)(iVar11 + 0x58)), iVar24 == 0))
            {
              iVar24 = 2;
              local_b4 = local_b4 + 1.00000000;
              goto LAB_0806c0c0;
            }
            iVar24 = 1;
            if (*(char *)(iVar10 + 0x54) == *(char *)(iVar11 + 0x54)) goto LAB_0806c1b2;
          }
          if (((*(int *)(iVar10 + 0x110) != *(int *)(iVar11 + 0x110)) &&
              (*(int *)(iVar10 + 0x110) != *(int *)(iVar11 + 0x118))) &&
             ((*(int *)(iVar11 + 0x110) != *(int *)(iVar10 + 0x118) &&
              (*(int *)(iVar11 + 0x118) != *(int *)(iVar10 + 0x118))))) {
            if ((((*(int *)(iVar10 + 0x114) != *(int *)(iVar11 + 0x114)) &&
                 (*(int *)(iVar10 + 0x114) != *(int *)(iVar11 + 0x11c))) &&
                (*(int *)(iVar11 + 0x114) != *(int *)(iVar10 + 0x11c))) &&
               (*(int *)(iVar11 + 0x11c) != *(int *)(iVar10 + 0x11c))) goto LAB_0806c130;
          }
          local_b4 = (double)iVar24 + local_b4;
        }
LAB_0806c130:
        local_a0 = local_a0 + -1;
        if (local_a0 == -1) break;
        pDVar16 = PCB->Data;
        iVar10 = local_a4;
      } while( true );
    }
    local_b8 = local_b8 + 1;
  } while (local_b8 != 4);
  r_destroy_tree(local_20);
  r_destroy_tree(&local_24);
  CVar4 = PCB->Data->ElementN;
  iVar10 = CVar4 - 1;
  if (iVar10 != -1) {
    LVar21 = -10000000;
    LVar34 = -10000000;
    LVar23 = 10000000;
    LVar32 = 10000000;
    pBVar19 = &PCB->Data->Element[CVar4 - 1].VBox;
    do {
      if (pBVar19->X1 < LVar32) {
        LVar32 = pBVar19->X1;
      }
      if (pBVar19->Y1 < LVar23) {
        LVar23 = pBVar19->Y1;
      }
      if (LVar34 < pBVar19->X2) {
        LVar34 = pBVar19->X2;
      }
      if (LVar21 < pBVar19->Y2) {
        LVar21 = pBVar19->Y2;
      }
      pBVar19 = (BoxType *)&pBVar19[-0x13].Y1;
      iVar10 = iVar10 + -1;
    } while (iVar10 != -1);
    if ((LVar23 < LVar21) && (LVar32 < LVar34)) {
      dVar5 = SQRT((double)(LVar21 - LVar23) * (double)(LVar34 - LVar32) * 0.00010000);
      goto LAB_0806c2d5;
    }
  }
  dVar5 = 0.00000000;
LAB_0806c2d5:
  dVar35 = SQRT(ABS(dVar35)) * 0.02000000;
  dVar36 = ((1.00000000 - T / T0) * 100.00000000 + 0.01000000) * SQRT(ABS(dVar37 + dVar36));
  if ((float)T == 5.00000000) {
    dVar37 = ((local_ec + dVar35 + dVar36 + local_f4) - local_b4) + dVar5;
    __printf_chk(1,"cost components are %.3f %.3f %.3f %.3f %.3f %.3f\n",local_ec / dVar37,
                 dVar35 / dVar37,dVar36 / dVar37,local_f4 / dVar37,-local_b4 / dVar37,dVar5 / dVar37
                );
  }
  return ((dVar36 + dVar35 + local_f4) - local_b4) + dVar5 + local_ec;
}



void doPerturb(PerturbationType *pt,Boolean undo)

{
  anon_enum_32_for_which aVar1;
  int iVar2;
  int iVar3;
  ElementTypePtr *Element;
  byte Number;
  int local_64;
  int local_60;
  PerturbationType mypt;
  
  Element = pt->element;
  local_64 = (Element->VBox).X1;
  local_60 = (Element->VBox).Y1;
  aVar1 = pt->which;
  if (aVar1 == ROTATE) {
    Number = pt->rotate;
    if (undo != '\0') {
      Number = -Number & 3;
    }
    if (Number != 0) {
      RotateElementLowLevel
                (PCB->Data,Element,(local_64 + (Element->VBox).X2) / 2,
                 (local_60 + (Element->VBox).Y2) / 2,Number);
      return;
    }
    MirrorElementCoordinates(PCB->Data,Element,0);
    Element = pt->element;
    local_60 = local_60 - (Element->VBox).Y1;
    local_64 = 0;
  }
  else {
    if (aVar1 != SHIFT) {
      if (aVar1 != HID_Real) {
        return;
      }
      iVar2 = (pt->other->BoundingBox).X1;
      iVar3 = (pt->other->BoundingBox).Y1;
      MoveElementLowLevel(PCB->Data,Element,iVar2 - local_64,iVar3 - local_60);
      MoveElementLowLevel(PCB->Data,pt->other,local_64 - iVar2,local_60 - iVar3);
      mypt.element = pt->element;
      if (((((mypt.element)->Flags).f ^ (pt->other->Flags).f) & 0x80) == 0) {
        return;
      }
      mypt.which = ROTATE;
      mypt.rotate = '\0';
      doPerturb(&mypt,undo);
      mypt.element = pt->other;
      doPerturb(&mypt,undo);
      return;
    }
    local_64 = pt->DX;
    local_60 = pt->DY;
    if (undo != '\0') {
      local_64 = -local_64;
      local_60 = -local_60;
    }
  }
  MoveElementLowLevel(PCB->Data,Element,local_64,local_60);
  return;
}



Boolean AutoPlaceSelected(void)

{
  float fVar1;
  double __x;
  ulonglong uVar2;
  NetListTypePtr *Nets;
  DataTypePtr *pDVar3;
  void **ppvVar4;
  long lVar5;
  Boolean BVar6;
  int iVar7;
  int iVar8;
  void *pvVar9;
  double T0;
  double dVar10;
  double dVar11;
  PointerListTypePtr_conflict *local_a8;
  int local_98;
  double local_94;
  double local_8c;
  ElementTypePtr *local_6c;
  anon_enum_32_for_which local_68;
  LocationType local_64;
  LocationType local_60;
  undefined4 local_5c;
  ElementTypePtr *local_58;
  PerturbationType pt;
  PointerListType list;
  PointerListType Selected;
  
  Selected.PtrN = 0;
  Selected.PtrMax = 0;
  Selected.Ptr = (void **)0x0;
  Nets = ProcNetlist((LibraryTypePtr)&PCB->NetlistLib);
  if (Nets == (NetListTypePtr *)0x0) {
    Message("Can\'t add rat lines because no netlist is loaded.\n");
  }
  else {
    list.PtrN = 0;
    list.PtrMax = 0;
    list.Ptr = (void **)0x0;
    pDVar3 = PCB->Data;
    iVar7 = pDVar3->ElementN - 1;
    if (iVar7 == -1) {
      Selected.Ptr = (void **)0x0;
      Selected.PtrMax = 0;
      Selected.PtrN = 0;
    }
    else {
      iVar8 = pDVar3->ElementN * 300;
      while( true ) {
        pvVar9 = (void *)((int)&pDVar3->Element[-1].BoundingBox.X1 + iVar8);
        if ((*(byte *)((int)pvVar9 + 0x14) & 0x40) != 0) {
          ppvVar4 = GetPointerMemory((PointerListTypePtr_conflict *)&list);
          *ppvVar4 = pvVar9;
        }
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        pDVar3 = PCB->Data;
        iVar8 = iVar8 + -300;
      }
      Selected.PtrN = list.PtrN;
      Selected.PtrMax = list.PtrMax;
      Selected.Ptr = list.Ptr;
      if (list.PtrN != 0) {
        iVar7 = 0;
        T0 = ComputeCost(Nets,300000.00000000,300000.00000000);
        local_8c = 0.00000000;
        do {
          iVar7 = iVar7 + 1;
          createPerturbation((PerturbationType *)&local_6c,(PointerListTypePtr)&Selected,
                             1000000.00000000);
          pt.element = local_6c;
          pt.which = local_68;
          pt.DX = local_64;
          pt.DY = local_60;
          pt._16_4_ = local_5c;
          pt.other = local_58;
          doPerturb(&pt,'\0');
          dVar10 = ComputeCost(Nets,300000.00000000,300000.00000000);
          local_8c = ABS(dVar10 - T0) + local_8c;
          doPerturb(&pt,'\x01');
        } while (iVar7 != 10);
        iVar7 = 0;
        T0 = (local_8c / -10.00000000) / -0.05129329;
        __printf_chk(1,"Initial T: %f\n",T0);
        uVar2 = (ulonglong)Selected.PtrN;
        dVar10 = ComputeCost(Nets,T0,5.00000000);
        __printf_chk(1,"Starting cost is %.0f\n",dVar10);
        local_94 = ComputeCost(Nets,T0,T0);
        local_98 = 0;
        iVar8 = 0;
        local_8c = T0;
        while( true ) {
          do {
            createPerturbation((PerturbationType *)&local_6c,(PointerListTypePtr)&Selected,local_8c)
            ;
            pt.element = local_6c;
            pt.which = local_68;
            pt.DX = local_64;
            pt.DY = local_60;
            pt._16_4_ = local_5c;
            pt.other = local_58;
            doPerturb(&pt,'\0');
            dVar10 = ComputeCost(Nets,T0,local_8c);
            if (local_94 <= dVar10) {
              lVar5 = random();
              dVar11 = (local_94 - dVar10) / local_8c;
              __x = -20.00000000;
              if ((-20.00000000 <= dVar11) &&
                 (__x = 20.00000000, dVar11 <= 20.00000000 || dVar11 != 20.00000000)) {
                __x = dVar11;
              }
              dVar11 = exp(__x);
              if (dVar11 <= (double)lVar5 / 2147483647.00000000) {
                doPerturb(&pt,'\x01');
              }
              else {
                local_98 = local_98 + 1;
                local_94 = dVar10;
              }
            }
            else {
              local_98 = local_98 + 1;
              iVar8 = iVar8 + 1;
              local_94 = dVar10;
            }
            iVar7 = iVar7 + 1;
          } while ((iVar8 < (int)ROUND((float)uVar2 * 20.00000000)) &&
                  (iVar7 < (int)ROUND((float)uVar2 * 20.00000000) * 2));
          __printf_chk(1,"END OF STAGE: COST %.0f\tGOOD_MOVES %d\tMOVES %d\tT: %.1f\n",local_94,
                       iVar8,iVar7,local_8c);
          if (((float)local_8c < 5.00000000) || (iVar8 < iVar7 / 0x28)) break;
          fVar1 = (float)local_8c * 0.75000000;
          iVar7 = 0;
          iVar8 = 0;
          local_8c = (double)fVar1;
          local_94 = ComputeCost(Nets,T0,(double)fVar1);
        }
        BVar6 = '\0';
        if (0 < local_98) {
          BVar6 = '\x01';
          DeleteRats('\0');
          AddAllRats('\0',(anon_subr_void *)0x0);
          ClearAndRedrawOutput();
        }
        goto LAB_0806ca47;
      }
    }
    list.PtrN = Selected.PtrN;
    list.PtrMax = Selected.PtrMax;
    list.Ptr = Selected.Ptr;
    Message("No elements selected to autoplace.\n");
  }
  BVar6 = '\0';
LAB_0806ca47:
  local_a8 = (PointerListTypePtr_conflict *)&Selected;
  FreePointerListMemory(local_a8);
  return BVar6;
}



void __regparm3 InitLists(routebox_t *r)

{
  int iVar1;
  boxlist all [4];
  boxlist *p;
  int iVar2;
  routebox_list *prVar3;
  
  iVar2 = 0;
  do {
    iVar1 = *(int *)((int)(boxlist *)&ram0x08163e88 + iVar2);
    prVar3 = &r->original_subnet;
    if (((iVar1 != 2) && (prVar3 = &r->different_net, iVar1 != 3)) &&
       (prVar3 = &r->same_net, iVar1 == 1)) {
      prVar3 = &r->same_subnet;
    }
    iVar2 = iVar2 + 4;
    *(routebox_t **)&prVar3->next = r;
    *(routebox_t **)&prVar3->prev = r;
  } while (iVar2 != 0x10);
  return;
}



void __regparm3 MergeNets(routebox_t *a,routebox_t *b,boxlist which)

{
  routebox_list *prVar1;
  routebox *prVar2;
  routebox *prVar3;
  routebox_list *local_1c;
  routebox_list *local_18;
  routebox_list *local_14;
  
  if (which == ORIGINAL) {
    local_1c = &a->original_subnet;
LAB_0806ccae:
    local_18 = &b->original_subnet;
    prVar3 = local_1c->next;
    prVar2 = (b->original_subnet).next;
LAB_0806ccbc:
    local_14 = &prVar3->original_subnet;
  }
  else {
    if (which == DIFFERENT_NET) {
      local_1c = &a->different_net;
LAB_0806ccce:
      local_18 = &b->different_net;
      prVar2 = (b->different_net).next;
      prVar3 = local_1c->next;
LAB_0806ccdc:
      local_14 = &prVar3->different_net;
LAB_0806cce2:
      prVar1 = &prVar2->different_net;
      goto LAB_0806cc85;
    }
    if (which == SUBNET) {
      local_1c = &a->same_subnet;
LAB_0806cc6e:
      local_18 = &b->same_subnet;
      prVar2 = (b->same_subnet).next;
      prVar3 = local_1c->next;
LAB_0806cc7c:
      local_14 = &prVar3->same_subnet;
LAB_0806cc82:
      prVar1 = &prVar2->same_subnet;
      goto LAB_0806cc85;
    }
    local_1c = &a->same_net;
    if (which == ORIGINAL) goto LAB_0806ccae;
    if (which == DIFFERENT_NET) goto LAB_0806ccce;
    if (which == SUBNET) goto LAB_0806cc6e;
    local_18 = &b->same_net;
    prVar3 = (a->same_net).next;
    prVar2 = (b->same_net).next;
    if (which == ORIGINAL) goto LAB_0806ccbc;
    if (which == DIFFERENT_NET) goto LAB_0806ccdc;
    if (which == SUBNET) goto LAB_0806cc7c;
    local_14 = &prVar3->same_net;
    if (which != ORIGINAL) {
      if (which != DIFFERENT_NET) {
        if (which != SUBNET) {
          prVar1 = &prVar2->same_net;
          goto LAB_0806cc85;
        }
        goto LAB_0806cc82;
      }
      goto LAB_0806cce2;
    }
  }
  prVar1 = &prVar2->original_subnet;
LAB_0806cc85:
  local_18->next = prVar3;
  *(routebox_t **)&local_14->prev = b;
  local_1c->next = prVar2;
  *(routebox_t **)&prVar1->prev = a;
  return;
}



void __regparm3 RemoveFromNet(routebox_t *a,boxlist which)

{
  routebox_t *prVar1;
  routebox *prVar2;
  routebox_list *prVar3;
  routebox_list *prVar4;
  routebox_list *prVar5;
  
  prVar3 = &a->original_subnet;
  if ((which != ORIGINAL) && (prVar3 = &a->different_net, which != DIFFERENT_NET)) {
    prVar3 = &a->same_net;
    if (which == SUBNET) {
      prVar3 = &a->same_subnet;
    }
  }
  prVar1 = (routebox_t *)prVar3->prev;
  prVar2 = prVar3->next;
  if (prVar1 == a) {
    return;
  }
  if (prVar2 == (routebox *)a) {
    return;
  }
  if (which == ORIGINAL) {
    prVar5 = &prVar2->original_subnet;
LAB_0806cd73:
    prVar4 = &prVar1->original_subnet;
  }
  else {
    if (which == DIFFERENT_NET) {
      prVar5 = &prVar2->different_net;
LAB_0806cd93:
      prVar4 = &prVar1->different_net;
      goto LAB_0806cd76;
    }
    if (which == SUBNET) {
      prVar5 = &prVar2->same_subnet;
    }
    else {
      prVar5 = &prVar2->same_net;
      if (which == ORIGINAL) goto LAB_0806cd73;
      if (which == DIFFERENT_NET) goto LAB_0806cd93;
      if (which != SUBNET) {
        *(routebox_t **)&(prVar2->same_net).prev = prVar1;
        (prVar1->same_net).next = prVar2;
        *(routebox_t **)&prVar3->prev = a;
        *(routebox_t **)&prVar3->next = a;
        return;
      }
    }
    prVar4 = &prVar1->same_subnet;
  }
LAB_0806cd76:
  *(routebox_t **)&prVar5->prev = prVar1;
  prVar4->next = prVar2;
  *(routebox_t **)&prVar3->prev = a;
  *(routebox_t **)&prVar3->next = a;
  return;
}



Boolean TargetPoint(CheapPointType *nextpoint,routebox_t *target)

{
  int iVar1;
  Boolean BVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  
  if (target->type == TRUE) {
    nextpoint->X = *(LocationType *)(target->parent + 0x34);
    nextpoint->Y = *(LocationType *)(target->parent + 0x38);
    BVar2 = '\x01';
  }
  else {
    if (target->type == SHIFT) {
      iVar7 = *(int *)(target->parent + 0x2c);
      iVar1 = *(int *)(target->parent + 0x40);
      uVar6 = iVar7 - nextpoint->X;
      uVar3 = (int)uVar6 >> 0x1f;
      uVar4 = iVar1 - nextpoint->X;
      uVar5 = (int)uVar4 >> 0x1f;
      if ((int)((uVar4 ^ uVar5) - uVar5) <= (int)((uVar6 ^ uVar3) - uVar3)) {
        iVar7 = iVar1;
      }
      nextpoint->X = iVar7;
      iVar7 = *(int *)(target->parent + 0x30);
      iVar1 = *(int *)(target->parent + 0x44);
      uVar3 = iVar7 - nextpoint->Y;
      uVar4 = (int)uVar3 >> 0x1f;
      uVar5 = iVar1 - nextpoint->Y;
      uVar6 = (int)uVar5 >> 0x1f;
      if ((int)((uVar3 ^ uVar4) - uVar4) < (int)((uVar5 ^ uVar6) - uVar6)) {
        nextpoint->Y = iVar7;
        BVar2 = '\x01';
      }
      else {
        nextpoint->Y = iVar1;
        BVar2 = '\x01';
      }
    }
    else {
      iVar7 = (target->sbox).X1;
      nextpoint->X = ((target->sbox).X2 - iVar7) / 2 + iVar7;
      iVar7 = (target->sbox).Y1;
      nextpoint->Y = ((target->sbox).Y2 - iVar7) / 2 + iVar7;
      BVar2 = '\0';
    }
  }
  return BVar2;
}



float10 __regparm3 cost_to_routebox(int *p,uint point_layer,int rb)

{
  uint *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  float10 fVar8;
  uint local_24;
  int local_20;
  uint local_18;
  
  iVar2 = *p;
  iVar7 = *(int *)(rb + 0x10);
  if (iVar2 < iVar7) {
LAB_0806cf7b:
    local_24 = iVar7 - iVar2;
  }
  else {
    local_24 = 0;
    iVar7 = iVar2;
    if (*(int *)(rb + 0x18) <= iVar2) {
      iVar7 = *(int *)(rb + 0x18) + -1;
      goto LAB_0806cf7b;
    }
  }
  iVar3 = p[1];
  local_20 = *(int *)(rb + 0x14);
  if (local_20 <= iVar3) {
    if (iVar3 < *(int *)(rb + 0x1c)) {
      iVar4 = 0;
      local_18 = 0;
      local_20 = iVar3;
      goto LAB_0806cefb;
    }
    local_20 = *(int *)(rb + 0x1c) + -1;
  }
  local_18 = local_20 - iVar3;
  iVar4 = (iVar7 - iVar2) * local_18;
LAB_0806cefb:
  if ((usedGroup[point_layer] == '\0') || (usedGroup[*(ushort *)(rb + 0x24)] == '\0')) {
    fVar8 = (float10)(double)AutoRouteParameters.NewLayerPenalty;
  }
  else {
    fVar8 = (float10)0;
  }
  if (iVar4 != 0) {
    fVar8 = fVar8 + (float10)(double)AutoRouteParameters.JogPenalty;
  }
  puVar1 = (uint *)&PCB->Data->LayerN;
  uVar5 = (int)local_18 >> 0x1f;
  uVar6 = (int)local_24 >> 0x1f;
  if ((point_layer < *puVar1 || point_layer == *puVar1) &&
     ((uint)*(ushort *)(rb + 0x24) != point_layer)) {
    if ((iVar2 != iVar7) || (iVar3 != local_20)) {
      return (float10)(((local_18 ^ uVar5) - uVar5) + ((local_24 ^ uVar6) - uVar6)) +
             fVar8 + (float10)(double)AutoRouteParameters.ViaCost;
    }
    fVar8 = fVar8 + (float10)1.00000000;
  }
  else {
    fVar8 = (float10)((local_18 ^ uVar5) - uVar5) + (float10)((local_24 ^ uVar6) - uVar6) + fVar8;
  }
  return fVar8;
}



BoxType * __regparm3 bloat_routebox(BoxType *__return_storage_ptr__,routebox_t *rb)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if ((*(byte *)&rb->flags & 0x10) == 0) {
    iVar4 = rb->style->Keepaway;
    if (iVar4 <= (AutoRouteParameters.style)->Keepaway) {
      iVar4 = (AutoRouteParameters.style)->Keepaway;
    }
    iVar1 = (rb->sbox).X2;
    iVar4 = ((AutoRouteParameters.style)->Thick + 1) / 2 + iVar4;
    iVar2 = (rb->sbox).Y2;
    __return_storage_ptr__->Y1 = (rb->sbox).Y1 + -iVar4;
    iVar3 = (rb->sbox).X1;
    __return_storage_ptr__->X2 = iVar1 + iVar4;
    __return_storage_ptr__->Y2 = iVar2 + iVar4;
    __return_storage_ptr__->X1 = -iVar4 + iVar3;
  }
  else {
    __return_storage_ptr__->X1 = (rb->sbox).X1;
    __return_storage_ptr__->Y1 = (rb->sbox).Y1;
    __return_storage_ptr__->X2 = (rb->sbox).X2;
    __return_storage_ptr__->Y2 = (rb->sbox).Y2;
  }
  return __return_storage_ptr__;
}



int __region_within_guess(BoxType *region,void *cl)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  double dVar4;
  double dVar5;
  int iVar6;
  
  if (*(int *)((int)cl + 8) == 0) {
    return 1;
  }
  iVar6 = region->X1;
  iVar1 = **(int **)cl;
  if (iVar6 <= iVar1) {
    if (iVar1 < region->X2) {
      dVar5 = 0.00000000;
      bVar2 = false;
      goto LAB_0806d0c5;
    }
    iVar6 = region->X2 + -1;
  }
  dVar5 = (double)(iVar6 - iVar1);
  bVar2 = dVar5 < 0.00000000;
LAB_0806d0c5:
  iVar6 = (*(int **)cl)[1];
  if (iVar6 < region->Y1) {
    dVar4 = (double)(region->Y1 - iVar6);
    bVar3 = dVar4 < 0.00000000;
  }
  else {
    if (iVar6 < region->Y2) {
      dVar4 = 0.00000000;
      bVar3 = false;
    }
    else {
      dVar4 = (double)((region->Y2 + -1) - iVar6);
      bVar3 = dVar4 < 0.00000000;
    }
  }
  if (bVar2) {
    dVar5 = -dVar5;
  }
  if (bVar3) {
    dVar4 = -dVar4;
  }
  if (dVar4 <= dVar5) {
    dVar4 = (double)AutoRouteParameters.MinPenalty * dVar4 + dVar5;
  }
  else {
    dVar4 = dVar4 + (double)AutoRouteParameters.MinPenalty * dVar5;
  }
  return (uint)(dVar4 < *(double *)((int)cl + 0xc));
}



int __found_new_guess(BoxType *box,void *cl)

{
  double dVar1;
  float10 fVar2;
  
  fVar2 = (float10)cost_to_routebox(*(undefined4 *)cl,*(undefined4 *)((int)cl + 4),box);
  dVar1 = *(double *)((int)cl + 0xc);
  if (fVar2 < (float10)dVar1) {
    *(BoxType **)((int)cl + 8) = box;
    *(double *)((int)cl + 0xc) = (double)fVar2;
  }
  return (uint)(fVar2 < (float10)dVar1);
}



float10 __regparm1 edge_cost(int *e,double too_big)

{
  double dVar1;
  int iVar2;
  float10 fVar3;
  
  iVar2 = *e;
  dVar1 = *(double *)(e + 3);
  fVar3 = (float10)dVar1;
  if (((*(int *)(iVar2 + 0x30) == 0) && (*(int *)(iVar2 + 0x28) != 7)) &&
     (fVar3 <= (float10)too_big)) {
    fVar3 = (float10)cost_to_routebox(e + 1,(uint)*(ushort *)(iVar2 + 0x24),e[7]);
    return (float10)dVar1 + fVar3;
  }
  return fVar3;
}



broken_boxes * __regparm3
break_box_edge(broken_boxes *__return_storage_ptr__,BoxType *original,direction_t which_edge,
              routebox_t *breaker)

{
  int iVar1;
  int iVar2;
  LocationType local_58;
  LocationType local_54;
  int local_50;
  bool local_4b;
  bool local_4a;
  bool local_49;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  LocationType local_30;
  int local_2c;
  int local_28;
  int local_24;
  BoxType breakbox;
  
  local_2c = original->Y2;
  iVar2 = original->X2;
  local_34 = original->Y1;
  local_40 = original->X1;
  bloat_routebox(&breakbox,breaker);
  local_28 = breakbox.X1;
  if (which_edge == SOUTH) {
    iVar1 = -iVar2;
    iVar2 = -local_40;
    local_30 = -local_2c;
    local_40 = iVar1;
LAB_0806d45a:
    local_28 = -breakbox.X2;
    local_38 = local_30 + 1;
    breakbox.X2 = -breakbox.X1;
    local_54 = local_28;
    if (local_28 <= local_40) {
      local_54 = local_40;
    }
    local_58 = breakbox.X2;
    if (iVar2 == breakbox.X2 || SBORROW4(iVar2,breakbox.X2) != iVar2 + breakbox.X1 < 0) {
      local_58 = iVar2;
    }
    local_4b = local_40 < local_28;
    local_4a = local_54 < local_58;
    local_49 = breakbox.X2 < iVar2;
LAB_0806d499:
    iVar1 = -local_40;
    local_40 = -local_28;
    local_34 = -local_38;
    local_3c = -local_30;
    local_2c = local_3c;
    local_28 = iVar1;
    local_24 = local_34;
LAB_0806d4c2:
    iVar1 = -local_54;
    local_54 = -local_58;
    local_48 = local_2c;
    local_44 = local_24;
    local_58 = iVar1;
  }
  else {
    if (which_edge == WEST) {
      iVar2 = -local_34;
      local_3c = -local_2c;
      local_30 = local_40;
LAB_0806d4f5:
      local_28 = -breakbox.Y2;
      breakbox.X2 = -breakbox.Y1;
      local_38 = local_30 + 1;
      local_54 = local_28;
      if (SBORROW4(local_3c,local_28) == local_3c + breakbox.Y2 < 0) {
        local_54 = local_3c;
      }
      local_58 = breakbox.X2;
      if (iVar2 == breakbox.X2 || SBORROW4(iVar2,breakbox.X2) != iVar2 + breakbox.Y1 < 0) {
        local_58 = iVar2;
      }
      local_4b = local_3c < local_28;
      local_4a = local_54 < local_58;
      local_49 = breakbox.X2 < iVar2;
LAB_0806d52d:
      local_3c = -local_3c;
      local_34 = -local_28;
      local_40 = local_30;
      local_28 = local_38;
LAB_0806d546:
      local_48 = -local_54;
      local_44 = -local_58;
      local_58 = local_38;
      local_54 = local_30;
LAB_0806d55c:
      local_24 = -iVar2;
      local_50 = local_38;
      local_2c = -breakbox.X2;
      goto LAB_0806d3e9;
    }
    if (which_edge == EAST) {
      local_30 = -iVar2;
      local_40 = local_34;
LAB_0806d36b:
      local_38 = local_30 + 1;
      local_28 = breakbox.Y1;
      local_54 = breakbox.Y1;
      if (breakbox.Y1 <= local_40) {
        local_54 = local_40;
      }
      local_58 = breakbox.Y2;
      if (local_2c <= breakbox.Y2) {
        local_58 = local_2c;
      }
      local_4b = local_40 < breakbox.Y1;
      local_4a = local_54 < local_58;
      local_49 = breakbox.Y2 < local_2c;
      breakbox.X2 = breakbox.Y2;
LAB_0806d3a6:
      local_50 = -local_30;
      local_3c = local_28;
      local_44 = local_54;
      local_54 = -local_38;
      iVar2 = -local_38;
      local_34 = local_40;
      local_28 = local_50;
LAB_0806d3cb:
      local_40 = iVar2;
      local_48 = local_58;
      local_58 = local_50;
      local_30 = local_54;
      local_24 = breakbox.X2;
      goto LAB_0806d3e9;
    }
    local_30 = local_34;
    if (which_edge == SOUTH) goto LAB_0806d45a;
    local_3c = local_40;
    if (which_edge == WEST) goto LAB_0806d4f5;
    local_2c = iVar2;
    if (which_edge == EAST) goto LAB_0806d36b;
    local_48 = local_34 + 1;
    local_54 = breakbox.X1;
    if (breakbox.X1 < local_40) {
      local_54 = local_40;
    }
    local_58 = iVar2;
    if (breakbox.X2 <= iVar2) {
      local_58 = breakbox.X2;
    }
    local_4b = local_40 < breakbox.X1;
    local_4a = local_54 < local_58;
    local_49 = breakbox.X2 < iVar2;
    local_38 = local_48;
    if (which_edge == SOUTH) goto LAB_0806d499;
    if (which_edge == WEST) goto LAB_0806d52d;
    if (which_edge == EAST) goto LAB_0806d3a6;
    local_3c = local_48;
    if (which_edge == SOUTH) {
      local_24 = -local_48;
      local_2c = -local_34;
      goto LAB_0806d4c2;
    }
    if (which_edge == WEST) goto LAB_0806d546;
    if (which_edge == EAST) {
      local_50 = -local_34;
      local_44 = local_54;
      local_54 = -local_48;
      iVar2 = local_40;
      goto LAB_0806d3cb;
    }
    local_44 = local_34;
    if (which_edge != SOUTH) {
      if (which_edge != WEST) {
        local_30 = breakbox.X2;
        local_50 = iVar2;
        local_2c = local_48;
        local_24 = local_34;
        if (which_edge == EAST) {
          local_30 = -local_48;
          local_50 = -local_34;
          local_2c = iVar2;
          local_24 = breakbox.X2;
        }
        goto LAB_0806d3e9;
      }
      goto LAB_0806d55c;
    }
    local_24 = -local_48;
    local_2c = -local_34;
  }
  local_30 = -iVar2;
  local_50 = -breakbox.X2;
LAB_0806d3e9:
  (__return_storage_ptr__->center).X1 = local_54;
  (__return_storage_ptr__->right).X2 = local_50;
  *(bool *)&__return_storage_ptr__->is_valid_right = local_49;
  *(bool *)&__return_storage_ptr__->is_valid_center = local_4a;
  (__return_storage_ptr__->center).Y2 = local_48;
  (__return_storage_ptr__->right).X1 = local_30;
  *(bool *)&__return_storage_ptr__->is_valid_left = local_4b;
  (__return_storage_ptr__->right).Y2 = local_2c;
  (__return_storage_ptr__->left).X1 = local_40;
  (__return_storage_ptr__->right).Y1 = local_24;
  (__return_storage_ptr__->center).X2 = local_58;
  (__return_storage_ptr__->center).Y1 = local_44;
  (__return_storage_ptr__->left).X2 = local_28;
  (__return_storage_ptr__->left).Y2 = local_3c;
  (__return_storage_ptr__->left).Y1 = local_34;
  return __return_storage_ptr__;
}



int __Expand_this_rect(BoxType *box,void *cl)

{
  byte bVar1;
  BoxType *pBVar2;
  uint uVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  int iVar7;
  LocationType local_30;
  int local_28;
  int local_24;
  LocationType local_20;
  LocationType local_1c;
  int local_18;
  int local_14;
  
  bVar1 = *(byte *)((int)&box[2].Y2 + 1);
  if ((bVar1 & 1) == 0) {
    if ((*(byte *)&box[2].Y2 & 0x10) == 0) {
      iVar7 = *(int *)(box[4].Y2 + 0xc);
      if (*(int *)((int)cl + 0x14) < iVar7) {
        iVar7 = *(int *)((int)cl + 0x14) - iVar7;
        local_1c = iVar7 + box[1].X1;
        local_20 = iVar7 + box[1].Y1;
        iVar6 = box[1].X2 - iVar7;
        local_30 = box[1].Y2 - iVar7;
      }
      else {
        local_30 = box[1].Y2;
        local_20 = box[1].Y1;
        local_1c = box[1].X1;
        iVar6 = box[1].X2;
      }
      if (iVar6 <= *(int *)((int)cl + 0x1c)) {
        return 0;
      }
      if (*(int *)((int)cl + 0x24) == local_1c || *(int *)((int)cl + 0x24) < local_1c) {
        return 0;
      }
      if (*(int *)((int)cl + 0x28) == local_20 || *(int *)((int)cl + 0x28) < local_20) {
        return 0;
      }
      if (local_30 <= *(int *)((int)cl + 0x20)) {
        return 0;
      }
      local_18 = 0;
    }
    else {
      local_30 = box[1].Y2;
      local_20 = box[1].Y1;
      local_1c = box[1].X1;
      local_18 = *(int *)((int)cl + 0x18);
      iVar6 = box[1].X2;
      if (iVar6 <= local_18 + *(int *)((int)cl + 0x1c)) {
        return 0;
      }
      if (*(int *)((int)cl + 0x24) - local_18 <= local_1c) {
        return 0;
      }
      if (*(int *)((int)cl + 0x28) - local_18 <= local_20) {
        return 0;
      }
      if (local_30 <= local_18 + *(int *)((int)cl + 0x20)) {
        return 0;
      }
    }
    pBVar2 = *(BoxType **)cl;
    if ((pBVar2 != box) && (pBVar2 != (BoxType *)box[2].X1)) {
      if ((*(byte *)&pBVar2[2].Y2 & 4) == 0) {
        iVar7 = box[2].X2;
      }
      else {
        if ((*(byte *)&box[2].Y2 & 4) != 0) {
          return 0;
        }
        iVar7 = box[2].X2;
        if ((iVar7 == 6) && ((*(byte *)&((BoxType *)box[2].X1)[2].Y2 & 4) != 0)) {
          return 0;
        }
      }
      if (((bVar1 & 4) == 0) || (iVar7 != 6)) {
        if (((iVar7 == 7) &&
            (((local_1c < *(int *)((int)cl + 0x2c) && (*(int *)((int)cl + 0x34) < iVar6)) &&
             (local_20 < *(int *)((int)cl + 0x30))))) && (*(int *)((int)cl + 0x38) < local_30)) {
          iVar7 = *(int *)((int)cl + 0x18);
          *(int *)((int)cl + 0x1c) = -iVar7 + *(int *)((int)cl + 0x2c);
          *(int *)((int)cl + 0x24) = *(int *)((int)cl + 0x34) + iVar7;
          *(int *)((int)cl + 0x28) = *(int *)((int)cl + 0x38) + iVar7;
          *(int *)((int)cl + 0x20) = -iVar7 + *(int *)((int)cl + 0x30);
          return 1;
        }
        uVar3 = *(uint *)((int)cl + 0x3c);
        if ((((uVar3 & 1) == 0) && (local_20 <= *(int *)((int)cl + 0x30))) &&
           (*(int *)((int)cl + 0x20) < local_30)) {
          local_14 = *(int *)((int)cl + 0x30) - local_30;
          bVar4 = local_14 < 1;
        }
        else {
          bVar4 = true;
          local_14 = 0;
        }
        if ((((uVar3 & 2) == 0) && (*(int *)((int)cl + 0x34) <= iVar6)) &&
           (*(int *)((int)cl + 0x24) != local_1c && local_1c <= *(int *)((int)cl + 0x24))) {
          local_28 = local_1c - *(int *)((int)cl + 0x34);
          bVar5 = local_28 < 1;
        }
        else {
          bVar5 = true;
          local_28 = 0;
        }
        if ((((uVar3 & 4) == 0) && (*(int *)((int)cl + 0x38) <= local_30)) &&
           (*(int *)((int)cl + 0x28) != local_20 && local_20 <= *(int *)((int)cl + 0x28))) {
          local_24 = local_20 - *(int *)((int)cl + 0x38);
        }
        else {
          local_24 = 0;
        }
        if ((((uVar3 & 8) == 0) && (local_1c <= *(int *)((int)cl + 0x2c))) &&
           (*(int *)((int)cl + 0x1c) < iVar6)) {
          iVar7 = *(int *)((int)cl + 0x2c) - iVar6;
        }
        else {
          iVar7 = 0;
        }
        if (((bVar5) && (bVar4)) && ((iVar7 < 1 && (local_24 < 1)))) {
          return 1;
        }
        if (((local_24 <= local_14) && (local_28 <= local_14)) && (iVar7 <= local_14)) {
          *(BoxType **)((int)cl + 4) = box;
          *(int *)((int)cl + 0x20) = local_30 - local_18;
          return 1;
        }
        if ((iVar7 <= local_28) && (local_24 <= local_28)) {
          *(BoxType **)((int)cl + 8) = box;
          *(int *)((int)cl + 0x24) = local_1c + local_18;
          return 1;
        }
        if (iVar7 <= local_24) {
          *(BoxType **)((int)cl + 0xc) = box;
          *(int *)((int)cl + 0x28) = local_20 + local_18;
          return 1;
        }
        *(BoxType **)((int)cl + 0x10) = box;
        *(int *)((int)cl + 0x1c) = iVar6 - local_18;
        return 1;
      }
    }
  }
  return 0;
}



void __regparm3
InitAutoRouteParameters
          (int pass,RouteStyleType *style,Boolean with_conflicts,Boolean is_smoothing,
          Boolean lastpass)

{
  float fVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  if (is_smoothing == '\0') {
    iVar4 = style->Diameter * 0x1e;
    iVar5 = pass * 400 >> 0x1f;
    iVar5 = ((((pass * 400) / 6 + iVar5 >> 1) - iVar5) + 2) / (pass + 1);
    fVar1 = 4000.00000000;
  }
  else {
    iVar4 = style->Diameter * 0x50;
    iVar5 = pass * 400 >> 0x1f;
    iVar5 = ((((pass * 400) / 6 + iVar5 >> 1) - iVar5) + 2) / (pass + 1);
    fVar1 = 20000.00000000;
  }
  AutoRouteParameters.LastConflictPenalty = (cost_t)(double)iVar5;
  AutoRouteParameters.ConflictPenalty =
       (cost_t)((double)AutoRouteParameters.LastConflictPenalty * 4.00000000);
  AutoRouteParameters.ViaCost = (cost_t)(double)(iVar4 + 350000);
  AutoRouteParameters.JogPenalty = (cost_t)(double)fVar1;
  dVar2 = 30000000000000000948382466048.00000000;
  AutoRouteParameters.MinPenalty = 30000000000000000948382466048.00000000;
  iVar5 = PCB->Data->LayerN;
  if (0 < iVar5) {
    iVar6 = 0;
    do {
      if (is_layer_group_active[iVar6] != '\0') {
        dVar3 = (double)x_cost[iVar6];
        if (dVar3 <= dVar2 || dVar2 != dVar3) {
          dVar2 = dVar3;
        }
        dVar3 = (double)y_cost[iVar6];
        if (dVar3 <= dVar2 || dVar2 != dVar3) {
          dVar2 = dVar3;
        }
      }
      iVar6 = iVar6 + 1;
      AutoRouteParameters.MinPenalty = (cost_t)dVar2;
    } while (iVar6 != iVar5);
  }
  if (is_smoothing == '\0') {
    fVar1 = (float)(iVar4 + 350000) * 10.00000000;
  }
  else {
    fVar1 = 14999999753475345011185811456.00000000;
  }
  iVar5 = (0xd - pass) * 8;
  AutoRouteParameters.hi_conflict = 6;
  if (5 < iVar5) {
    AutoRouteParameters.hi_conflict = iVar5;
  }
  AutoRouteParameters.NewLayerPenalty = (cost_t)(double)fVar1;
  AutoRouteParameters.style = style;
  AutoRouteParameters.bloat = (style->Thick + 1) / 2 + style->Keepaway;
  AutoRouteParameters.CongestionPenalty = 1000000.00000000;
  AutoRouteParameters.is_odd = (byte)pass & 1;
  AutoRouteParameters.with_conflicts = with_conflicts;
  AutoRouteParameters.is_smoothing = is_smoothing;
  AutoRouteParameters.rip_always = is_smoothing;
  AutoRouteParameters.last_smooth = '\0';
  AutoRouteParameters.pass = (byte)pass + 1;
  return;
}



routebox_t * __regparm3
AddPad(PointerListType *layergroupboxes,ElementTypePtr *element,PadTypePtr *pad,
      RouteStyleType *style)

{
  int *piVar1;
  byte *pbVar2;
  routebox_t **pprVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  Cardinal CVar9;
  int iVar10;
  routebox_t *r;
  byte bVar11;
  
  bVar11 = 0;
  CVar9 = back;
  if (-1 < *(char *)&(pad->Flags).f) {
    CVar9 = front;
  }
  pprVar3 = (routebox_t **)
            GetPointerMemory((PointerListTypePtr_conflict *)(layergroupboxes + CVar9));
  r = (routebox_t *)calloc(1,0x7c);
  iVar4 = 0x1f;
  *pprVar3 = r;
  while (iVar4 != 0) {
    iVar4 = iVar4 + -1;
    (r->box).X1 = 0;
    r = (routebox_t *)((int)r + (uint)bVar11 * -8 + 4);
  }
  r = *pprVar3;
  r->group = (ushort)CVar9;
  iVar10 = (pad->Thickness + 1) / 2;
  iVar4 = style->Keepaway;
  iVar5 = (pad->Point2).Y;
  if (iVar5 <= (pad->Point1).Y) {
    iVar5 = (pad->Point1).Y;
  }
  iVar6 = (pad->Point2).X;
  if (iVar6 <= (pad->Point1).X) {
    iVar6 = (pad->Point1).X;
  }
  iVar7 = (pad->Point2).Y;
  piVar1 = &(pad->Point1).Y;
  if (*piVar1 == iVar7 || *piVar1 < iVar7) {
    iVar7 = (pad->Point1).Y;
  }
  iVar8 = (pad->Point2).X;
  if ((pad->Point1).X == iVar8 || (pad->Point1).X < iVar8) {
    iVar8 = (pad->Point1).X;
  }
  (r->box).X1 = (iVar8 - iVar10) - iVar4;
  (r->sbox).X1 = iVar8 - iVar10;
  (r->box).Y1 = (iVar7 - iVar10) - iVar4;
  (r->box).X2 = iVar10 + iVar6 + iVar4;
  (r->box).Y2 = iVar4 + iVar10 + iVar5;
  (r->sbox).Y1 = iVar7 - iVar10;
  pbVar2 = (byte *)&(r->flags).field_0x1;
  *pbVar2 = *pbVar2 | 0x40;
  (r->sbox).X2 = iVar10 + iVar6;
  (r->sbox).Y2 = iVar10 + iVar5;
  if (((pad->Point1).X != (pad->Point2).X) && ((pad->Point1).Y != (pad->Point2).Y)) {
    *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 1;
  }
  r = *pprVar3;
  *(PadTypePtr **)&r->parent = pad;
  r->type = SHIFT;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 2;
  r = *pprVar3;
  r->came_from = ALL;
  r->style = style;
  InitLists(r);
  return *pprVar3;
}



// WARNING: Could not reconcile some variable overlaps

routebox_t * __regparm3
AddPin(PointerListType *layergroupboxes,PinTypePtr *pin,Boolean is_via,RouteStyleType *style)

{
  int *piVar1;
  byte *pbVar2;
  uint uVar3;
  int iVar4;
  routebox_t **pprVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  routebox_t *prVar9;
  int iVar10;
  byte bVar11;
  PointerListTypePtr_conflict *local_2c;
  int local_28;
  routebox_t *local_24;
  
  bVar11 = 0;
  local_24 = (routebox_t *)0x0;
  if (0 < PCB->Data->LayerN) {
    local_28 = 0;
    local_2c = (PointerListTypePtr_conflict *)layergroupboxes;
    do {
      pprVar5 = (routebox_t **)GetPointerMemory(local_2c);
      prVar9 = (routebox_t *)calloc(1,0x7c);
      iVar6 = 0x1f;
      *pprVar5 = prVar9;
      while (iVar6 != 0) {
        iVar6 = iVar6 + -1;
        (prVar9->box).X1 = 0;
        prVar9 = (routebox_t *)((int)prVar9 + (uint)bVar11 * -8 + 4);
      }
      iVar6 = pin->DrillingHole;
      prVar9 = *pprVar5;
      if (iVar6 <= pin->Thickness) {
        iVar6 = pin->Thickness;
      }
      prVar9->group = (ushort)local_28;
      iVar4 = style->Keepaway;
      iVar10 = (iVar6 + 1) / 2;
      iVar6 = pin->Y + iVar10;
      iVar7 = pin->X + iVar10;
      iVar8 = pin->Y - iVar10;
      iVar10 = pin->X - iVar10;
      (prVar9->box).X1 = iVar10 - iVar4;
      (prVar9->sbox).X1 = iVar10;
      (prVar9->box).Y1 = iVar8 - iVar4;
      (prVar9->box).X2 = iVar7 + iVar4;
      (prVar9->box).Y2 = iVar4 + iVar6;
      (prVar9->sbox).X2 = iVar7;
      (prVar9->sbox).Y1 = iVar8;
      pbVar2 = (byte *)&(prVar9->flags).field_0x1;
      *pbVar2 = *pbVar2 | 0x40;
      (prVar9->sbox).Y2 = iVar6;
      if (is_via == '\0') {
        prVar9 = *pprVar5;
        prVar9->type = TRUE;
        *(PinTypePtr **)&prVar9->parent = pin;
      }
      else {
        prVar9 = *pprVar5;
        prVar9->type = VIA;
        *(PinTypePtr **)&prVar9->parent = pin;
      }
      *(byte *)&(*pprVar5)->flags = *(byte *)&(*pprVar5)->flags | 2;
      prVar9 = *pprVar5;
      prVar9->style = style;
      uVar3 = (pin->Flags).f;
      prVar9->came_from = ALL;
      *(byte *)&prVar9->flags = *(byte *)&prVar9->flags & 0xdf | (byte)(((uVar3 >> 8 ^ 1) & 1) << 5)
      ;
      InitLists(*pprVar5);
      if (local_24 != (routebox_t *)0x0) {
        MergeNets(*pprVar5,local_24,NET);
        MergeNets(*pprVar5,local_24,SUBNET);
        MergeNets(*pprVar5,local_24,ORIGINAL);
      }
      local_28 = local_28 + 1;
      local_24 = *pprVar5;
      local_2c = local_2c + 1;
      piVar1 = &PCB->Data->LayerN;
    } while (*piVar1 != local_28 && local_28 <= *piVar1);
  }
  return local_24;
}



routebox_t * __regparm3
AddLine(PointerListType *layergroupboxes,int layergroup,LineTypePtr line,LineTypePtr ptr,
       RouteStyleType *style)

{
  int *piVar1;
  byte *pbVar2;
  routebox_t **pprVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  routebox_t *r;
  int iVar9;
  byte bVar10;
  
  bVar10 = 0;
  pprVar3 = (routebox_t **)
            GetPointerMemory((PointerListTypePtr_conflict *)(layergroupboxes + layergroup));
  r = (routebox_t *)calloc(1,0x7c);
  iVar4 = 0x1f;
  *pprVar3 = r;
  while (iVar4 != 0) {
    iVar4 = iVar4 + -1;
    (r->box).X1 = 0;
    r = (routebox_t *)((int)r + (uint)bVar10 * -8 + 4);
  }
  r = *pprVar3;
  r->group = (ushort)layergroup;
  iVar4 = style->Keepaway;
  iVar9 = (line->Point2).Y;
  iVar5 = (line->Thickness + 1) / 2;
  if (iVar9 <= (line->Point1).Y) {
    iVar9 = (line->Point1).Y;
  }
  iVar8 = (line->Point2).X;
  if (iVar8 <= (line->Point1).X) {
    iVar8 = (line->Point1).X;
  }
  iVar6 = (line->Point2).Y;
  piVar1 = &(line->Point1).Y;
  if (*piVar1 == iVar6 || *piVar1 < iVar6) {
    iVar6 = (line->Point1).Y;
  }
  iVar6 = -iVar5 + iVar6;
  iVar7 = (line->Point2).X;
  if ((line->Point1).X == iVar7 || (line->Point1).X < iVar7) {
    iVar7 = (line->Point1).X;
  }
  iVar7 = -iVar5 + iVar7;
  (r->box).X1 = iVar7 - iVar4;
  (r->sbox).X1 = iVar7;
  (r->box).Y1 = iVar6 - iVar4;
  (r->box).X2 = iVar5 + iVar8 + iVar4;
  (r->box).Y2 = iVar4 + iVar5 + iVar9;
  (r->sbox).Y1 = iVar6;
  pbVar2 = (byte *)&(r->flags).field_0x1;
  *pbVar2 = *pbVar2 | 0x40;
  (r->sbox).X2 = iVar5 + iVar8;
  (r->sbox).Y2 = iVar5 + iVar9;
  if (((line->Point1).X != (line->Point2).X) && ((line->Point1).Y != (line->Point2).Y)) {
    *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 1;
    iVar4 = (line->Point1).Y;
    iVar9 = (line->Point2).Y;
    iVar5 = (line->Point1).X;
    iVar8 = (line->Point2).X;
    if (iVar4 <= iVar9) {
      iVar9 = iVar4;
    }
    if (iVar5 <= iVar8) {
      iVar8 = iVar5;
    }
    *(byte *)&((*pprVar3)->flags).field_0x1 =
         *(byte *)&((*pprVar3)->flags).field_0x1 & 0xf7 |
         ((iVar4 == iVar9) != (iVar5 == iVar8)) << 3;
  }
  r = *pprVar3;
  r->type = LINE;
  *(LineTypePtr *)&r->parent = ptr;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 2;
  r = *pprVar3;
  r->came_from = ALL;
  r->style = style;
  InitLists(r);
  return *pprVar3;
}



routebox_t * __regparm3
AddIrregularObstacle
          (PointerListType *layergroupboxes,LocationType X1,LocationType Y1,LocationType X2,
          LocationType Y2,Cardinal layergroup,void *parent,RouteStyleType *style)

{
  byte *pbVar1;
  int iVar2;
  routebox_t **pprVar3;
  int iVar4;
  routebox_t *r;
  byte bVar5;
  
  bVar5 = 0;
  iVar2 = style->Keepaway;
  pprVar3 = (routebox_t **)
            GetPointerMemory((PointerListTypePtr_conflict *)(layergroupboxes + layergroup));
  r = (routebox_t *)calloc(1,0x7c);
  iVar4 = 0x1f;
  *pprVar3 = r;
  while (iVar4 != 0) {
    iVar4 = iVar4 + -1;
    (r->box).X1 = 0;
    r = (routebox_t *)((int)r + (uint)bVar5 * -8 + 4);
  }
  r = *pprVar3;
  r->group = (ushort)layergroup;
  (r->box).X1 = X1 - iVar2;
  (r->box).Y1 = Y1 - iVar2;
  (r->box).X2 = X2 + iVar2;
  (r->sbox).X1 = X1;
  (r->sbox).Y1 = Y1;
  pbVar1 = (byte *)&(r->flags).field_0x1;
  *pbVar1 = *pbVar1 | 0x40;
  (r->box).Y2 = iVar2 + Y2;
  (r->sbox).X2 = X2;
  (r->sbox).Y2 = Y2;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 1;
  r = *pprVar3;
  r->type = OTHER;
  *(void **)&r->parent = parent;
  *(byte *)&(*pprVar3)->flags = *(byte *)&(*pprVar3)->flags | 2;
  r = *pprVar3;
  r->style = style;
  InitLists(r);
  return *pprVar3;
}



routebox_t * __regparm3
AddPolygon(PointerListType *layergroupboxes,Cardinal layer,PolygonTypePtr polygon,
          RouteStyleType *style)

{
  byte *pbVar1;
  PointTypePtr pPVar2;
  bool bVar3;
  Cardinal layergroup;
  routebox_t *prVar4;
  byte bVar5;
  
  layergroup = GetLayerGroupNumberByNumber(layer);
  prVar4 = AddIrregularObstacle
                     (layergroupboxes,(polygon->BoundingBox).X1,(polygon->BoundingBox).Y1,
                      (polygon->BoundingBox).X2,(polygon->BoundingBox).Y2,layergroup,polygon,style);
  if (polygon->PointN == 4) {
    pPVar2 = polygon->Points;
    if ((pPVar2->X == pPVar2[1].X) || (pPVar2->Y == pPVar2[1].Y)) {
      if ((pPVar2[1].X == pPVar2[2].X) || (pPVar2[1].Y == pPVar2[2].Y)) {
        if (((pPVar2[2].X == pPVar2[3].X) || (pPVar2[2].Y == pPVar2[3].Y)) &&
           ((pPVar2->X == pPVar2[3].X || (pPVar2[3].Y == pPVar2->Y)))) {
          bVar5 = 0;
          bVar3 = false;
          goto LAB_0806e10f;
        }
      }
    }
  }
  bVar5 = 1;
  bVar3 = true;
LAB_0806e10f:
  prVar4->layer = (ushort)layer;
  prVar4->came_from = ALL;
  *(byte *)&prVar4->flags = *(byte *)&prVar4->flags & 0xfe | bVar5;
  if (((*(byte *)&(polygon->Flags).f & 0x10) != 0) &&
     (pbVar1 = (byte *)&(prVar4->flags).field_0x1, *pbVar1 = *pbVar1 | 0x10, !bVar3)) {
    prVar4->type = PLANE;
  }
  return prVar4;
}



void __regparm3 RB_down_count(routebox_t *rb)

{
  int iVar1;
  
  iVar1 = rb->refcount + -1;
  rb->refcount = iVar1;
  if (iVar1 == 0) {
    if ((*(byte *)&((routebox_t *)rb->parent)->flags & 0x40) != 0) {
      RB_down_count((routebox_t *)rb->parent);
    }
    free(rb);
  }
  return;
}



void __regparm3 best_path_candidate(routeone_state *s,edge_t *e,routebox_t *best_target)

{
  routebox_t *rb;
  float10 fVar1;
  
  fVar1 = (float10)edge_cost(e,0x45d83bdac6ae9bc2);
  rb = s->best_path;
  *(double *)&e->cost = (double)fVar1;
  if (rb != (routebox_t *)0x0) {
    if ((float10)(double)s->best_cost <= fVar1) {
      return;
    }
    if ((*(byte *)&rb->flags & 0x40) != 0) {
      RB_down_count(rb);
      fVar1 = (float10)(double)e->cost;
    }
  }
  rb = e->rb;
  *(double *)&s->best_cost = (double)fVar1;
  s->best_target = best_target;
  s->best_path = rb;
  if ((*(byte *)&rb->flags & 0x40) != 0) {
    rb->refcount = rb->refcount + 1;
  }
  return;
}



int __regparm3 blocker_to_heap(heap_t *heap,routebox_t *rb,BoxType *box,direction_t dir)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_24;
  
  local_24 = (rb->sbox).Y2;
  iVar3 = (rb->sbox).X1;
  iVar1 = (rb->sbox).Y1;
  iVar2 = (rb->sbox).X2;
  iVar4 = rb->style->Keepaway;
  if ((AutoRouteParameters.style)->Keepaway < iVar4) {
    iVar4 = (AutoRouteParameters.style)->Keepaway - iVar4;
    local_24 = local_24 - iVar4;
    iVar3 = iVar3 + iVar4;
    iVar1 = iVar1 + iVar4;
    iVar2 = iVar2 - iVar4;
  }
  iVar4 = box->X1;
  if (box->X1 <= iVar3) {
    iVar4 = iVar3;
  }
  if (box->X2 < iVar2) {
    iVar2 = box->X2;
  }
  if (iVar1 < box->Y1) {
    iVar1 = box->Y1;
  }
  iVar3 = box->Y2;
  if (local_24 <= box->Y2) {
    iVar3 = local_24;
  }
  if (dir == EAST) {
    heap_insert(heap,(cost_t)(double)((float)iVar1 - (float)iVar1 / ((float)iVar3 + 1.00000000)),rb)
    ;
  }
  else {
    if (dir == NORTH) {
      heap_insert(heap,(cost_t)(double)((float)iVar4 - (float)iVar4 / ((float)iVar2 + 1.00000000)),
                  rb);
    }
    else {
      if (dir == SOUTH) {
        heap_insert(heap,(cost_t)(double)-((float)iVar4 / ((float)iVar2 + 1.00000000) + (float)iVar2
                                          ),rb);
      }
      else {
        if (dir == WEST) {
          heap_insert(heap,(cost_t)(double)-((float)iVar1 / ((float)iVar3 + 1.00000000) +
                                            (float)iVar3),rb);
        }
      }
    }
  }
  return (uint)((*(byte *)&rb->flags & 0xe) == 2);
}



int __GatherBlockers(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_24;
  int local_20;
  
  if ((((*(BoxType **)((int)cl + 4) != box) && ((*(byte *)((int)&box[2].Y2 + 1) & 1) == 0)) &&
      ((BoxType *)(*(BoxType **)((int)cl + 4))[2].X1 != box)) &&
     (((*(byte *)&box[2].Y2 & 4) == 0 || (*(char *)((int)cl + 0x1c) == '\0')))) {
    local_24 = box[1].Y2;
    local_20 = box[1].Y1;
    iVar1 = box[1].X1;
    iVar2 = box[1].X2;
    iVar3 = *(int *)(box[4].Y2 + 0xc);
    if ((AutoRouteParameters.style)->Keepaway < iVar3) {
      iVar3 = (AutoRouteParameters.style)->Keepaway - iVar3;
      iVar1 = iVar1 + iVar3;
      iVar2 = iVar2 - iVar3;
      local_20 = local_20 + iVar3;
      local_24 = local_24 - iVar3;
    }
    if (((*(int *)((int)cl + 8) < iVar2) &&
        (*(int *)((int)cl + 0x10) != iVar1 && iVar1 <= *(int *)((int)cl + 0x10))) &&
       ((*(int *)((int)cl + 0x14) != local_20 && local_20 <= *(int *)((int)cl + 0x14) &&
        (*(int *)((int)cl + 0xc) < local_24)))) {
      iVar1 = blocker_to_heap(*(heap_t **)cl,(routebox_t *)box,(BoxType *)((int)cl + 8),
                              *(direction_t *)((int)cl + 0x18));
      return iVar1;
    }
  }
  return 0;
}



void __regparm3
RD_DrawThermal(routedata_t *rd,LocationType X,LocationType Y,Cardinal group,Cardinal layer,
              routebox_t *subnet,Boolean is_bad)

{
  routebox_t *r;
  int iVar1;
  routebox_t *prVar2;
  byte bVar3;
  
  bVar3 = 0;
  r = (routebox_t *)calloc(1,0x7c);
  iVar1 = 0x1f;
  prVar2 = r;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    (prVar2->box).X1 = 0;
    prVar2 = (routebox_t *)((int)prVar2 + (uint)bVar3 * -8 + 4);
  }
  (r->box).X1 = X;
  (r->box).X2 = X + 1;
  (r->sbox).X1 = X;
  (r->sbox).X2 = X + 1;
  r->type = THERMAL;
  (r->box).Y2 = Y + 1;
  (r->sbox).Y2 = Y + 1;
  (r->box).Y1 = Y;
  (r->sbox).Y1 = Y;
  r->group = (ushort)group;
  r->layer = (ushort)layer;
  *(byte *)&(r->flags).field_0x1 = (byte)(((uint)(byte)is_bad & 1) << 5) | 0x40;
  *(Boolean *)&r->flags = AutoRouteParameters.is_odd << 7;
  r->style = AutoRouteParameters.style;
  InitLists(r);
  MergeNets(r,subnet,NET);
  MergeNets(r,subnet,SUBNET);
  r_insert_entry(rd->layergrouptree[r->group],(BoxType *)r,1);
  *(byte *)&r->flags = *(byte *)&r->flags & 0xbf;
  return;
}



void __regparm3
RD_DrawLine(routedata_t *rd,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
           BDimension halfthick,Cardinal group,routebox_t *subnet,Boolean is_bad,Boolean is_45)

{
  int iVar1;
  DataTypePtr *pDVar2;
  Cardinal CVar3;
  LocationType LVar4;
  LocationType LVar5;
  LocationType LVar6;
  Boolean BVar7;
  LocationType qX1;
  routebox_t *qsn;
  Boolean qis_bad;
  Boolean qis_45;
  Cardinal qgroup;
  BDimension qhthick;
  LocationType qY2;
  LocationType qX2;
  LocationType qY1;
  routebox_t *r;
  LocationType LVar8;
  LocationType LVar9;
  int iVar10;
  int iVar11;
  uint uVar12;
  byte bVar13;
  routebox_t *prVar14;
  
  bVar13 = 0;
  iVar1 = (AutoRouteParameters.style)->Keepaway;
  if ((Y1 != Y2) || (X1 != X2)) {
    if (qX1 == -1) {
      return;
    }
    if ((((X1 != qX2) || (Y1 != qY2)) || (qhthick != halfthick)) ||
       ((qgroup != group || (((X1 != X2 || (X1 != qX1)) && ((Y1 != Y2 || (Y1 != qY1)))))))) {
      r = (routebox_t *)calloc(1,0x7c);
      iVar10 = 0x1f;
      prVar14 = r;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        (prVar14->box).X1 = 0;
        prVar14 = (routebox_t *)((int)prVar14 + (uint)bVar13 * -8 + 4);
      }
      r->type = LINE;
      LVar6 = qY1;
      LVar5 = qY2;
      LVar4 = qX1;
      iVar10 = qhthick + 1;
      LVar8 = qY2;
      if (qY2 <= qY1) {
        LVar8 = qY1;
      }
      (r->sbox).Y2 = iVar10 + LVar8;
      LVar8 = qX2;
      LVar9 = qX2;
      if (qX2 <= LVar4) {
        LVar9 = LVar4;
      }
      (r->sbox).X2 = LVar9 + iVar10;
      LVar9 = LVar5;
      if (LVar6 <= LVar5) {
        LVar9 = LVar6;
      }
      iVar10 = LVar9 - qhthick;
      LVar9 = LVar8;
      if (LVar4 <= LVar8) {
        LVar9 = LVar4;
      }
      iVar11 = LVar9 - qhthick;
      (r->sbox).Y1 = iVar10;
      (r->sbox).X1 = iVar11;
      (r->box).X1 = iVar11 - iVar1;
      (r->box).Y1 = iVar10 - iVar1;
      (r->box).X2 = (r->sbox).X2 + iVar1;
      (r->box).Y2 = (r->sbox).Y2 + iVar1;
      r->group = (ushort)qgroup;
      BVar7 = AutoRouteParameters.is_odd;
      bVar13 = (byte)(((uint)(byte)qis_bad & 1) << 5) | 0x40;
      *(byte *)&(r->flags).field_0x1 = bVar13;
      r->came_from = ALL;
      *(byte *)&r->flags = BVar7 << 7 | qis_45 & 1U;
      if (LVar8 < LVar4) {
        uVar12 = (uint)(LVar6 <= LVar5);
      }
      else {
        uVar12 = 1;
        if (LVar6 < LVar5) {
          uVar12 = (uint)(LVar8 <= LVar4);
        }
      }
      *(byte *)&(r->flags).field_0x1 = (byte)(uVar12 << 3) | bVar13;
      r->style = AutoRouteParameters.style;
      r->pass = AutoRouteParameters.pass;
      InitLists(r);
      MergeNets(r,qsn,NET);
      MergeNets(r,qsn,SUBNET);
      r_insert_entry(rd->layergrouptree[r->group],(BoxType *)r,1);
      if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
        pDVar2 = PCB->Data;
        CVar3 = (PCB->LayerGroups).Entries[(uint)r->group * 0x12];
        (*gui->set_line_width)(ar_gc,qhthick * 2);
        (*gui->set_color)(ar_gc,*(char **)(&pDVar2->field_0x94 + CVar3 * 0x5c));
        (*gui->draw_line)(ar_gc,qX1,qY1,qX2,qY2);
      }
      if (AutoRouteParameters.use_vias != '\0') {
        mtspace_add(rd->mtspace,(BoxType *)r,~-(uint)((*(byte *)&r->flags & 0x80) == 0) + EVEN,
                    r->style->Keepaway);
      }
      usedGroup[r->group] = '\x01';
    }
  }
  return;
}



Boolean __regparm3
RD_DrawManhattanLine
          (routedata_t *rd,BoxType *box1,BoxType *box2,CheapPointType start,CheapPointType end,
          BDimension halfthick,Cardinal group,routebox_t *subnet,Boolean is_bad,Boolean last_was_x)

{
  Boolean local_2a;
  LocationType local_24;
  LocationType local_20;
  
  local_20 = end.X;
  local_24 = start.Y;
  if (end.X == start.X) {
    RD_DrawLine(rd,end.X,start.Y,end.X,end.Y,halfthick,group,subnet,is_bad,'\0');
    local_2a = '\0';
  }
  else {
    if (end.Y == start.Y) {
      RD_DrawLine(rd,start.X,end.Y,end.X,end.Y,halfthick,group,subnet,is_bad,'\0');
      local_2a = '\x01';
    }
    else {
      if ((((((end.X < box1->X1) || (box1->Y1 != start.Y && start.Y <= box1->Y1)) ||
            (box1->X2 == end.X || box1->X2 < end.X)) || (box1->Y2 == start.Y || box1->Y2 < start.Y))
          && (((box2->X1 != end.X && end.X <= box2->X1 ||
               (box2->Y1 != start.Y && start.Y <= box2->Y1)) ||
              ((box2->X2 == end.X || box2->X2 < end.X || (box2->Y2 == start.Y || box2->Y2 < start.Y)
               ))))) ||
         ((last_was_x == '\0' &&
          ((((box1->X1 <= start.X && (box1->Y1 == end.Y || box1->Y1 < end.Y)) &&
            ((box1->X2 != start.X && start.X <= box1->X2 && (box1->Y2 != end.Y && end.Y <= box1->Y2)
             ))) || ((((box2->X1 == start.X || box2->X1 < start.X &&
                       (box2->Y1 == end.Y || box2->Y1 < end.Y)) &&
                      (box2->X2 != start.X && start.X <= box2->X2)) &&
                     (box2->Y2 != end.Y && end.Y <= box2->Y2)))))))) {
        local_20 = start.X;
        local_24 = end.Y;
        local_2a = '\x01';
      }
      else {
        local_2a = '\0';
      }
      RD_DrawLine(rd,start.X,start.Y,local_20,local_24,halfthick,group,subnet,is_bad,'\0');
      RD_DrawLine(rd,local_20,local_24,end.X,end.Y,halfthick,group,subnet,is_bad,'\0');
    }
  }
  return local_2a;
}



routebox_t * __regparm3
mincost_target_to_point
          (CheapPointType *CostPoint,Cardinal CostPointLayer,rtree_t *targets,
          routebox_t *target_guess)

{
  float10 fVar1;
  mincost_target_closure mtc;
  
  mtc.nearest = target_guess;
  mtc.CostPoint = CostPoint;
  mtc.CostPointLayer = CostPointLayer;
  if (target_guess == (routebox_t *)0x0) {
    mtc.nearest_cost = 30000000000000000948382466048.00000000;
  }
  else {
    fVar1 = (float10)cost_to_routebox();
    mtc.nearest_cost = (cost_t)(double)fVar1;
  }
  r_search(targets,(BoxType *)0x0,__region_within_guess,__found_new_guess,&mtc);
  return mtc.nearest;
}



edge_t * __regparm3
CreateEdge(routebox_t *rb,LocationType CostPointX,LocationType CostPointY,cost_t cost_to_point,
          routebox_t *mincost_target_guess,direction_t expand_dir,rtree_t *targets)

{
  edge_t *peVar1;
  routebox_t *prVar2;
  int iVar3;
  edge_t *peVar4;
  byte bVar5;
  
  bVar5 = 0;
  peVar1 = (edge_t *)calloc(1,0x2c);
  iVar3 = 0xb;
  peVar4 = peVar1;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    peVar4->rb = (routebox_t *)0x0;
    peVar4 = (edge_t *)((int)peVar4 + (uint)bVar5 * -8 + 4);
  }
  peVar1->rb = rb;
  if ((*(byte *)&rb->flags & 0x40) != 0) {
    rb->refcount = rb->refcount + 1;
  }
  peVar1->cost_to_point = cost_to_point;
  *(byte *)&peVar1->flags = *(byte *)&peVar1->flags & 0xef;
  (peVar1->cost_point).X = CostPointX;
  (peVar1->cost_point).Y = CostPointY;
  if (targets == (rtree_t *)0x0) {
    peVar1->mincost_target = mincost_target_guess;
  }
  else {
    prVar2 = mincost_target_to_point
                       (&peVar1->cost_point,(uint)rb->group,targets,mincost_target_guess);
    peVar1->mincost_target = prVar2;
  }
  peVar1->expand_dir = expand_dir;
  return peVar1;
}



vector_t * __regparm3 path_conflicts(routebox_t *rb,routebox_t *conflictor,Boolean branch)

{
  vector_t *vector;
  
  if (branch == '\0') {
    vector = rb->conflicts_with;
    if (vector == (vector_t *)0x0) {
      vector = vector_create();
      rb->conflicts_with = vector;
    }
  }
  else {
    vector = vector_duplicate(rb->conflicts_with);
    rb->conflicts_with = vector;
  }
  vector_append(vector,conflictor);
  return rb->conflicts_with;
}



routebox_t * __regparm3 FindOneInBox(rtree_t *rtree,routebox_t *rb)

{
  int iVar1;
  foib_info foib;
  BoxType r;
  
  r.X1 = (rb->sbox).X1;
  foib.intersect = (routebox_t *)0x0;
  r.Y1 = (rb->sbox).Y1;
  r.X2 = (rb->sbox).X2;
  r.Y2 = (rb->sbox).Y2;
  foib.box = &r;
  iVar1 = _setjmp((__jmp_buf_tag *)foib.env);
  if (iVar1 == 0) {
    r_search(rtree,&r,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,foib_rect_in_reg,&foib);
  }
  return foib.intersect;
}



routebox_t * __regparm3
FindRouteBoxOnLayerGroup(routedata_t *rd,LocationType X,LocationType Y,Cardinal layergroup)

{
  int iVar1;
  rb_info info;
  
  info.query.X2 = X + 1;
  info.query.Y2 = Y + 1;
  info.winner = (routebox_t *)0x0;
  info.query.X1 = X;
  info.query.Y1 = Y;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(rd->layergrouptree[layergroup],(BoxType *)&info,
             (anon_subr_int_BoxType_ptr_void_ptr *)0x0,__found_one_on_lg,&info);
  }
  return info.winner;
}



int __regparm3 FindPin(BoxType *box,PinTypePtr **pin)

{
  int iVar1;
  fpin_info info;
  
  info.X = box->X1;
  info.pin = (PinTypePtr *)0x0;
  info.Y = box->Y1;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    *pin = info.pin;
    return 0x100;
  }
  r_search(PCB->Data->pin_tree,box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,fpin_rect,&info);
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    *pin = info.pin;
    return 1;
  }
  r_search(PCB->Data->via_tree,box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,fpin_rect,&info);
  *pin = (PinTypePtr *)0x0;
  return 0;
}



routebox_t * FindThermable(rtree_t *rtree,routebox_t *rb)

{
  int iVar1;
  therm_info info;
  
  info.query.X2 = (rb->sbox).X2;
  info.query.Y1 = (rb->sbox).Y1;
  info.query.X1 = (rb->sbox).X1;
  info.plane = rb;
  info.query.Y2 = (rb->sbox).Y2;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(rtree,&info.query,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,ftherm_rect_in_reg,&info);
    info.plane = (routebox_t *)0x0;
  }
  return info.plane;
}



int foib_rect_in_reg(BoxType *box,void *cl)

{
  int *piVar1;
  BoxType rbox;
  
  if ((*(byte *)((int)&box[2].Y2 + 1) & 1) == 0) {
    bloat_routebox(&rbox,(routebox_t *)box);
    piVar1 = *(int **)cl;
    if ((((rbox.X1 < piVar1[2]) && (*piVar1 < rbox.X2)) && (rbox.Y1 < piVar1[3])) &&
       (piVar1[1] < rbox.Y2)) {
      *(BoxType **)((int)cl + 4) = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 0;
}



int __found_one_on_lg(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  
  if ((*(byte *)&box[2].Y2 & 1) == 0) {
    iVar1 = *(int *)(box[4].Y2 + 0xc);
    if ((((*(int *)cl < box->X2 - iVar1) &&
         (iVar2 = box->X1 + iVar1, *(int *)((int)cl + 8) != iVar2 && iVar2 <= *(int *)((int)cl + 8))
         ) && (*(int *)((int)cl + 4) < box->Y2 - iVar1)) &&
       (iVar1 = iVar1 + box->Y1,
       *(int *)((int)cl + 0xc) != iVar1 && iVar1 <= *(int *)((int)cl + 0xc))) {
      iVar1 = box[2].X2;
      *(BoxType **)((int)cl + 0x10) = box;
      if (iVar1 == 7) {
        return 1;
      }
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



int fpin_rect(BoxType *b,void *cl)

{
  if ((b[3].Y1 == *(int *)((int)cl + 4)) && (b[3].X2 == *(int *)((int)cl + 8))) {
    *(BoxType **)cl = b;
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0xc,1);
  }
  return 0;
}



int ftherm_rect_in_reg(BoxType *box,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_40;
  int local_30;
  int local_2c;
  int local_24;
  int local_20;
  
  iVar1 = box[2].X2;
  if ((iVar1 - 1U < 3) && (*(short *)&box[2].Y1 == *(short *)(*(int *)cl + 0x24))) {
    iVar2 = box[1].X2;
    iVar3 = box[1].Y1;
    local_20 = box[1].X1;
    if (iVar1 == 2) {
      if ((*(byte *)&box[2].Y2 & 2) == 0) {
        local_24 = *(int *)(box[4].Y2 + 4);
        local_2c = local_24 + *(int *)((int)cl + 4);
        local_30 = local_24 + *(int *)((int)cl + 8);
        local_40 = *(int *)((int)cl + 0xc) - local_24;
        local_24 = *(int *)((int)cl + 0x10) - local_24;
        local_20 = local_20 + (iVar2 - local_20) / 2;
        iVar3 = (box[1].Y2 - iVar3) / 2 + iVar3;
      }
      else {
        iVar1 = box[2].X1;
        local_2c = *(int *)(iVar1 + 0x24) + *(int *)((int)cl + 4);
        local_30 = *(int *)(iVar1 + 0x24) + *(int *)((int)cl + 8);
        local_40 = *(int *)((int)cl + 0xc) - *(int *)(iVar1 + 0x24);
        local_24 = *(int *)((int)cl + 0x10) - *(int *)(iVar1 + 0x24);
        local_20 = *(int *)(iVar1 + 0x34);
        iVar3 = *(int *)(iVar1 + 0x38);
      }
      if (local_40 <= local_20) {
        return 0;
      }
      if (iVar2 <= local_2c) {
        return 0;
      }
      if (local_24 <= iVar3) {
        return 0;
      }
    }
    else {
      if (iVar1 == 3) {
        local_30 = *(int *)(box[4].Y2 + 4);
      }
      else {
        local_30 = *(int *)(box[2].X1 + 0x24);
      }
      if (*(int *)((int)cl + 0xc) - local_30 <= local_20) {
        return 0;
      }
      if (iVar2 <= *(int *)((int)cl + 4) + local_30) {
        return 0;
      }
      if (*(int *)((int)cl + 0x10) - local_30 <= iVar3) {
        return 0;
      }
      local_30 = *(int *)((int)cl + 8) + local_30;
    }
    if (local_30 < box[1].Y2) {
      *(BoxType **)cl = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



void __regparm3 touch_conflicts(vector_t *conflicts,int touch)

{
  vector_element_t *ppvVar1;
  int last_size;
  vector_t *last;
  int iVar2;
  vector_element_t pvVar3;
  vector_element_t pvVar4;
  int N;
  byte local_28;
  
  N = 0;
  if (touch != 0) {
    if ((last != (vector_t *)0x0) && (last != conflicts)) {
      touch_conflicts(last,0);
    }
    N = last_size;
    last = conflicts;
    if (conflicts == (vector_t *)0x0) {
      return;
    }
  }
  iVar2 = vector_size(conflicts);
  if (N < iVar2) {
    local_28 = (byte)touch;
    do {
      pvVar3 = vector_element(conflicts,N);
      pvVar4 = pvVar3;
      if (pvVar3 != (vector_element_t)0x0) {
        do {
          ppvVar1 = (vector_element_t *)((int)pvVar4 + 0x5c);
          if ((*(byte *)((int)pvVar4 + 0x2c) & 2) == 0) {
            *(byte *)((int)pvVar4 + 0x2d) = *(byte *)((int)pvVar4 + 0x2d) & 0xfe | local_28 & 1;
          }
          pvVar4 = *ppvVar1;
        } while (pvVar3 != *ppvVar1);
      }
      N = N + 1;
    } while (N < iVar2);
  }
  if (touch != 0) {
    return;
  }
  return;
}



int __conflict_source(BoxType *box,void *cl)

{
  bool bVar1;
  
  bVar1 = (*(ushort *)&box[2].Y2 & 0x102) == 0;
  if (bVar1) {
    path_conflicts((routebox_t *)cl,(routebox_t *)box,'\0');
    touch_conflicts(*(vector_t **)((int)cl + 0x48),1);
  }
  return (uint)bVar1;
}



void KillEdge(void *edge)

{
  if ((*(byte *)&(*(routebox_t **)edge)->flags & 0x40) != 0) {
    RB_down_count(*(routebox_t **)edge);
  }
  if ((*(byte *)((int)edge + 0x28) & 0x10) != 0) {
    mtsFreeWork((vetting_t **)((int)edge + 0x20));
  }
  free(edge);
  return;
}



void __regparm3 add_or_destroy_edge(routeone_state *s,edge_t *e)

{
  float10 fVar1;
  
  fVar1 = (float10)edge_cost(e,SUB84(s->best_cost,0),(int)((ulonglong)s->best_cost >> 0x20));
  *(double *)&e->cost = (double)fVar1;
  if ((float10)(double)s->best_cost <= fVar1) {
    KillEdge(e);
    return;
  }
  heap_insert(s->workheap,(cost_t)(double)fVar1,e);
  return;
}



void __regparm3
CreateSearchEdge(routeone_state *s,vetting_t *work,edge_t *parent,routebox_t *rb,conflict_t conflict
                ,rtree_t *targets,Boolean in_plane)

{
  routebox_t *prVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  routebox_t *prVar5;
  bool bVar6;
  bool bVar7;
  double cost;
  double dVar8;
  byte bVar9;
  routebox_t **data;
  int iVar10;
  int iVar11;
  routebox_t **pprVar12;
  routebox_t *local_20 [4];
  
  bVar9 = 0;
  prVar1 = parent->mincost_target;
  iVar11 = (prVar1->sbox).Y2;
  iVar2 = (prVar1->sbox).X2;
  iVar3 = (rb->cost_point).X;
  iVar4 = (prVar1->sbox).X1;
  iVar10 = (prVar1->sbox).Y1;
  if (iVar3 < iVar4) {
    cost = (double)(iVar4 - iVar3);
    bVar6 = cost < 0.00000000;
  }
  else {
    if (iVar3 < iVar2) {
      cost = 0.00000000;
      bVar6 = false;
    }
    else {
      cost = (double)((iVar2 + -1) - iVar3);
      bVar6 = cost < 0.00000000;
    }
  }
  iVar2 = (rb->cost_point).Y;
  if (iVar10 <= iVar2) {
    if (iVar2 < iVar11) {
      dVar8 = 0.00000000;
      bVar7 = false;
      goto LAB_0806f4bb;
    }
    iVar10 = iVar11 + -1;
  }
  dVar8 = (double)(iVar10 - iVar2);
  bVar7 = dVar8 < 0.00000000;
LAB_0806f4bb:
  if (bVar6) {
    cost = -cost;
  }
  if (bVar7) {
    dVar8 = -dVar8;
  }
  if (dVar8 <= cost) {
    cost = (double)AutoRouteParameters.MinPenalty * dVar8 + cost;
  }
  else {
    cost = dVar8 + (double)AutoRouteParameters.MinPenalty * cost;
  }
  cost = cost + (double)AutoRouteParameters.ViaCost + (double)parent->cost_to_point;
  local_20[0] = (routebox_t *)work;
  if (cost < (double)s->best_cost) {
    data = (routebox_t **)calloc(1,0x2c);
    iVar11 = 0xb;
    pprVar12 = data;
    while (iVar11 != 0) {
      iVar11 = iVar11 + -1;
      *pprVar12 = (routebox_t *)0x0;
      pprVar12 = pprVar12 + (uint)bVar9 * 0x3ffffffe + 1;
    }
    bVar9 = (byte)(((uint)(byte)in_plane & 1) << 5) | 0x10;
    *(byte *)(data + 10) = bVar9;
    *data = rb;
    if ((*(byte *)&rb->flags & 0x40) != 0) {
      rb->refcount = rb->refcount + 1;
    }
    data[7] = prVar1;
    data[8] = local_20[0];
    *(byte *)(data + 10) = ((byte)conflict & 3) * '\x02' | bVar9;
    prVar1 = (routebox_t *)(parent->cost_point).Y;
    prVar5 = (routebox_t *)(parent->cost_point).X;
    *(cost_t *)(data + 3) = parent->cost_to_point;
    *(double *)(data + 5) = cost;
    data[2] = prVar1;
    data[1] = prVar5;
    heap_insert(s->workheap,(cost_t)cost,data);
    return;
  }
  mtsFreeWork((vetting_t **)local_20);
  return;
}



Boolean IronDownAllUnfixedPaths(routedata_t *rd)

{
  char cVar1;
  routebox *prVar2;
  routebox *prVar3;
  DataTypePtr *pDVar4;
  Cardinal CVar5;
  LocationType LVar6;
  routebox *prVar7;
  int iVar8;
  RouteStyleType *pRVar9;
  float fVar10;
  float fVar11;
  uint uVar12;
  anon_enum_32_for_type aVar13;
  int iVar14;
  LineTypePtr Ptr2;
  PinTypePtr *Ptr1;
  sbyte sVar15;
  int Y1;
  Cardinal *pCVar16;
  uint uVar17;
  int X2;
  LayerTypePtr Layer;
  routebox_t *prVar18;
  routebox *box;
  int iVar19;
  int Y2;
  int in_GS_OFFSET;
  Boolean local_5d;
  int local_58;
  routebox_t *local_54;
  routebox_t *local_48;
  PinTypePtr *local_3c;
  ulong local_38;
  undefined4 local_34;
  undefined4 local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_5d = '\0';
  local_54 = rd->first_net;
  if (rd->first_net != (routebox_t *)0x0) {
    do {
      prVar2 = (local_54->different_net).next;
      local_48 = local_54;
      do {
        while (prVar3 = (local_48->same_net).next, box = prVar3,
              (*(byte *)&local_48->flags & 2) != 0) {
LAB_0806f6ca:
          local_48 = (routebox_t *)prVar3;
          if (prVar3 == (routebox *)local_54) goto LAB_0806f743;
        }
        Layer = (LayerTypePtr)0x0;
        uVar12 = (uint)local_48->group;
        uVar17 = (PCB->LayerGroups).Number[uVar12];
        if (uVar17 != 0) {
          pDVar4 = PCB->Data;
          Y1 = (PCB->LayerGroups).Entries[uVar12 * 0x12] * 0x5c;
          pCVar16 = (PCB->LayerGroups).Entries + uVar12 * 0x12 + 1;
          uVar12 = 0;
          cVar1 = *(char *)(&pDVar4->field_0x90 + Y1);
          Layer = (LayerTypePtr)(&pDVar4->field_0x4c + Y1);
          while ((cVar1 == '\0' && (uVar12 = uVar12 + 1, uVar12 < uVar17))) {
            CVar5 = *pCVar16;
            pCVar16 = pCVar16 + 1;
            cVar1 = *(char *)(&pDVar4->field_0x90 + CVar5 * 0x5c);
            Layer = (LayerTypePtr)(&pDVar4->field_0x4c + CVar5 * 0x5c);
          }
        }
        aVar13 = local_48->type;
        if (aVar13 == LINE) {
          iVar14 = (local_48->style->Thick + 1) / 2;
          Y2 = (local_48->sbox).Y2;
          Y1 = (local_48->sbox).X1;
          X2 = (local_48->sbox).X2;
          iVar8 = (local_48->sbox).Y1;
          fVar11 = (float)(iVar14 * 2 + 1);
          iVar19 = X2 - iVar14;
          local_58 = iVar14 + Y1;
          fVar10 = (float)(X2 - Y1) - fVar11;
          Y1 = iVar14 + iVar8;
          fVar11 = (float)(Y2 - iVar8) - fVar11;
          Y2 = Y2 - iVar14;
          if (local_58 + 1 == iVar19) {
            iVar19 = local_58;
          }
          if (Y1 + 1 == Y2) {
            Y2 = Y1;
          }
          total_wire_length = SQRT(fVar11 * fVar11 + fVar10 * fVar10) + total_wire_length;
          X2 = iVar19;
          if ((*(byte *)&(local_48->flags).field_0x1 & 8) != 0) {
            X2 = local_58;
            local_58 = iVar19;
          }
          MakeFlags((FlagType *)&local_2c,
                    (-(uint)(((PCB->Flags).f & 0x800) == 0) & 0xffffffe0) + 0xa0);
          Ptr2 = CreateDrawnLineOnLayer
                           (Layer,local_58,Y1,X2,Y2,local_48->style->Thick,
                            local_48->style->Keepaway * 2,
                            (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
          *(LineTypePtr *)&local_48->parent = Ptr2;
          if (Ptr2 != (LineTypePtr)0x0) {
            AddObjectToCreateUndoList(4,Layer,Ptr2,Ptr2);
            local_5d = '\x01';
          }
          goto LAB_0806f6ca;
        }
        if (1 < aVar13 + ~TRUE) goto LAB_0806f6ca;
        prVar18 = local_48;
        if (aVar13 == VIA_SHADOW) {
          prVar18 = (routebox_t *)local_48->parent;
        }
        Y1 = (local_48->sbox).X1;
        Y2 = (local_48->sbox).Y1;
        total_via_count = total_via_count + 1;
        if (prVar18->parent == 0) {
          X2 = (prVar18->style->Diameter + 1) / 2;
          MakeFlags((FlagType *)&local_38,0x80);
          pRVar9 = prVar18->style;
          Ptr1 = CreateNewVia(PCB->Data,X2 + Y1,X2 + Y2,pRVar9->Diameter,pRVar9->Keepaway * 2,0,
                              pRVar9->Hole,(char *)0x0,
                              (FlagType)CONCAT48(local_30,CONCAT44(local_34,local_38)));
          *(PinTypePtr **)&prVar18->parent = Ptr1;
          if (Ptr1 == (PinTypePtr *)0x0) {
            aVar13 = local_48->type;
          }
          else {
            AddObjectToCreateUndoList(1,Ptr1,Ptr1,Ptr1);
            local_5d = '\x01';
            aVar13 = local_48->type;
          }
        }
        if (aVar13 != VIA_SHADOW) goto LAB_0806f6ca;
        LVar6 = prVar18->parent;
        local_48->type = VIA;
        local_48->parent = LVar6;
        local_48 = (routebox_t *)prVar3;
      } while (prVar3 != (routebox *)local_54);
LAB_0806f743:
      do {
        prVar7 = (box->same_net).next;
        if (box->type != THERMAL) {
LAB_0806f738:
          box = prVar7;
          if (prVar3 == prVar7) break;
          goto LAB_0806f743;
        }
        local_3c = (PinTypePtr *)0x0;
        Y1 = FindPin((BoxType *)box,&local_3c);
        if (local_3c == (PinTypePtr *)0x0) goto LAB_0806f738;
        Ptr1 = (PinTypePtr *)local_3c->Element;
        if ((PinTypePtr *)local_3c->Element == (PinTypePtr *)0x0) {
          Ptr1 = local_3c;
        }
        AddObjectToClearPolyUndoList(Y1,Ptr1,local_3c,local_3c,'\0');
        RestoreToPolygon((DataType *)PCB->Data,1,((DataType *)PCB->Data)->Layer + box->layer,
                         local_3c);
        Ptr1 = (PinTypePtr *)local_3c->Element;
        if ((PinTypePtr *)local_3c->Element == (PinTypePtr *)0x0) {
          Ptr1 = local_3c;
        }
        AddObjectToFlagUndoList(Y1,Ptr1,local_3c,local_3c);
        uVar17 = (uint)(box->layer >> 1);
        sVar15 = (sbyte)(((uint)box->layer & 1) << 2);
        (local_3c->Flags).t[uVar17] =
             ~(byte)(0xf << sVar15) & (local_3c->Flags).t[uVar17] |
             (byte)((int)PCB->ThermStyle << sVar15);
        Ptr1 = (PinTypePtr *)local_3c->Element;
        if ((PinTypePtr *)local_3c->Element == (PinTypePtr *)0x0) {
          Ptr1 = local_3c;
        }
        AddObjectToClearPolyUndoList(Y1,Ptr1,local_3c,local_3c,'\x01');
        ClearFromPolygon((DataType *)PCB->Data,1,((DataType *)PCB->Data)->Layer + box->layer,
                         local_3c);
        local_5d = '\x01';
        box = prVar7;
      } while (prVar3 != prVar7);
      local_54 = (routebox_t *)prVar2;
    } while (prVar2 != (routebox *)rd->first_net);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_5d;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void add_via_sites(routeone_state *s,routeone_via_site_state *vss,mtspace_t *mtspace,
                  routebox_t *within,conflict_t within_conflict_level,edge_t *parent_edge,
                  rtree_t *targets,BDimension shrink,Boolean in_plane)

{
  vetting_t *work;
  BoxType region;
  
  region.X1 = (within->sbox).X1;
  region.Y1 = (within->sbox).Y1;
  region.X2 = (within->sbox).X2;
  region.Y2 = (within->sbox).Y2;
  work = mtspace_query_rect(mtspace,&region,((AutoRouteParameters.style)->Diameter + 1) / 2,
                            (AutoRouteParameters.style)->Keepaway,(vetting_t *)0x0,
                            vss->free_space_vec,vss->lo_conflict_space_vec,
                            vss->hi_conflict_space_vec,AutoRouteParameters.is_odd,
                            AutoRouteParameters.with_conflicts,&parent_edge->cost_point);
  if (work != (vetting_t *)0x0) {
    CreateSearchEdge(s,work,parent_edge,within,within_conflict_level,targets,in_plane);
  }
  return;
}



void DestroyRouteData(routedata_t **rd)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
  if (0 < PCB->Data->LayerN) {
    iVar2 = 0;
    do {
      iVar3 = iVar2 + 1;
      r_destroy_tree((*rd)->layergrouptree + iVar2);
      piVar1 = &PCB->Data->LayerN;
      iVar2 = iVar3;
    } while (*piVar1 != iVar3 && iVar3 <= *piVar1);
  }
  if (AutoRouteParameters.use_vias != '\0') {
    mtspace_destroy(&(*rd)->mtspace);
  }
  free(*rd);
  *rd = (routedata_t *)0x0;
  return;
}



Boolean __regparm3 boink_box(routebox_t *rb,direction_t dir)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
  iVar2 = rb->style->Keepaway;
  iVar3 = 0;
  if (ans.keep < iVar2) {
    iVar3 = ans.keep - iVar2;
  }
  if ((*(byte *)&rb->flags & 0x10) != 0) {
    iVar3 = ans.bloat;
  }
  if (dir != EAST) {
    if ((dir == NORTH) || (dir == SOUTH)) {
      piVar1 = &(rb->sbox).X2;
      if (*piVar1 == ans.inflated.X1 + iVar3 || *piVar1 < ans.inflated.X1 + iVar3) {
        return '\0';
      }
      return (rb->sbox).X1 < ans.inflated.X2 - iVar3;
    }
    if (dir != WEST) {
      return '\0';
    }
  }
  if (ans.inflated.Y2 - iVar3 <= (rb->sbox).Y1) {
    return '\0';
  }
  piVar1 = &(rb->sbox).Y2;
  return *piVar1 != iVar3 + ans.inflated.Y1 && iVar3 + ans.inflated.Y1 <= *piVar1;
}



E_result * Expand(rtree_t *rtree,edge_t *e,BoxType *box)

{
  ushort uVar1;
  direction_t dVar2;
  E_result ans;
  Boolean BVar3;
  uint uVar4;
  
  ans.w = (routebox_t *)0x0;
  ans.s = (routebox_t *)0x0;
  ans.bloat = AutoRouteParameters.bloat;
  ans.orig.X1 = box->X1;
  ans.e = (routebox_t *)0x0;
  ans.n = (routebox_t *)0x0;
  ans.orig.Y1 = box->Y1;
  ans.orig.X2 = box->X2;
  ans.orig.Y2 = box->Y2;
  if (ALL < e->expand_dir) {
    ans.done = 0;
    goto LAB_0806fd2a;
  }
  switch(e->expand_dir) {
  case NORTH:
    ans.done = 0xe;
    ans.inflated.Y1 = 0;
    ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    ans.inflated.X2 = AutoRouteParameters.bloat + box->X2;
    ans.inflated.Y2 = box->Y2;
    ans.parent = e->rb;
    break;
  case EAST:
    ans.done = 0xd;
    ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
    ans.inflated.X1 = box->X1;
    ans.inflated.X2 = PCB->MaxWidth;
    ans.parent = e->rb;
    break;
  case SOUTH:
    ans.done = 0xb;
    ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    ans.inflated.X2 = AutoRouteParameters.bloat + box->X2;
    ans.inflated.Y1 = box->Y1;
    ans.inflated.Y2 = PCB->MaxHeight;
    ans.parent = e->rb;
    break;
  case WEST:
    ans.done = 7;
    ans.inflated.X1 = 0;
    ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
    ans.inflated.X2 = box->X2;
    ans.parent = e->rb;
    break;
  case NE:
    ans.done = 0xc;
    ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
    ans.inflated.X2 = PCB->MaxWidth;
    ans.inflated.Y1 = 0;
    goto LAB_0806fd2a;
  case SE:
    ans.done = 9;
    ans.inflated.X1 = box->X1 - AutoRouteParameters.bloat;
    ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    ans.inflated.X2 = PCB->MaxWidth;
    ans.inflated.Y2 = PCB->MaxHeight;
    goto LAB_0806fd2a;
  case SW:
    ans.done = 3;
    ans.inflated.X1 = 0;
    ans.inflated.X2 = box->X2 + AutoRouteParameters.bloat;
    ans.inflated.Y1 = box->Y1 - AutoRouteParameters.bloat;
    ans.inflated.Y2 = PCB->MaxHeight;
    goto LAB_0806fd2a;
  case NW:
    ans.done = 6;
    ans.inflated.X1 = 0;
    ans.inflated.Y1 = 0;
    ans.inflated.X2 = box->X2 + AutoRouteParameters.bloat;
    ans.inflated.Y2 = AutoRouteParameters.bloat + box->Y2;
LAB_0806fd2a:
    ans.parent = e->rb;
    break;
  case ALL:
    ans.parent = e->rb;
    dVar2 = (ans.parent)->came_from;
    if (dVar2 == EAST) {
      ans.inflated.Y1 = 0;
      ans.inflated.X2 = PCB->MaxWidth;
      ans.inflated.Y2 = PCB->MaxHeight;
      ans.done = 8;
      ans.inflated.X1 = ans.orig.X1;
      break;
    }
    ans.inflated.X1 = 0;
    if (dVar2 == SOUTH) {
      ans.inflated.X2 = PCB->MaxWidth;
      ans.inflated.Y2 = PCB->MaxHeight;
      ans.inflated.Y1 = ans.orig.Y1;
LAB_08070226:
      ans.done = 1;
    }
    else {
      ans.inflated.Y1 = 0;
      if (dVar2 == WEST) {
        ans.inflated.Y2 = PCB->MaxHeight;
        ans.inflated.X2 = ans.orig.X2;
      }
      else {
        ans.inflated.X2 = PCB->MaxWidth;
        if (dVar2 == NORTH) {
          ans.done = 4;
          ans.inflated.Y2 = ans.orig.Y2;
          break;
        }
        ans.inflated.Y2 = PCB->MaxHeight;
        if (dVar2 == SOUTH) goto LAB_08070226;
        if (dVar2 != WEST) {
          ans.done = 0;
          break;
        }
      }
      ans.done = 2;
    }
  }
  ans.keep = (ans.parent)->style->Keepaway;
  uVar1 = *(ushort *)&(ans.parent)->flags;
  while (((uVar1 & 0x440) == 0x40 && (((ans.parent)->flags).is_thermal == 0))) {
    ans.parent = (routebox_t *)(ans.parent)->parent;
    uVar1 = *(ushort *)&(ans.parent)->flags;
  }
  r_search(rtree,(BoxType *)0x816b71c,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,__Expand_this_rect,
           (void *)0x816b700);
  if ((ans.n == (routebox_t *)0x0) || (BVar3 = boink_box(ans.n,NORTH), BVar3 != '\0')) {
    ans.done = ans.done | 1;
  }
  else {
    ans.inflated.Y1 = 0;
  }
  uVar4 = ans.done;
  if ((ans.e == (routebox_t *)0x0) || (BVar3 = boink_box(ans.e,EAST), BVar3 != '\0')) {
    uVar4 = uVar4 | 2;
    ans.done = uVar4;
  }
  else {
    ans.inflated.X2 = PCB->MaxWidth;
  }
  if ((ans.s == (routebox_t *)0x0) || (BVar3 = boink_box(ans.s,SOUTH), BVar3 != '\0')) {
    uVar4 = uVar4 | 4;
    ans.done = uVar4;
  }
  else {
    ans.inflated.Y2 = PCB->MaxHeight;
  }
  if ((ans.w == (routebox_t *)0x0) || (BVar3 = boink_box(ans.w,WEST), BVar3 != '\0')) {
    uVar4 = uVar4 | 8;
    ans.done = uVar4;
  }
  else {
    ans.inflated.X1 = 0;
  }
  if (uVar4 != 0xf) {
    r_search(rtree,(BoxType *)0x816b71c,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,__Expand_this_rect
             ,(void *)0x816b700);
  }
  return (E_result *)0x816b700;
}



routebox_t * __regparm3
CreateExpansionArea(BoxType *area,Cardinal group,routebox_t *parent,Boolean relax_edge_requirements,
                   edge_t *src_edge)

{
  byte *pbVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  double dVar5;
  double dVar6;
  RouteStyleType *pRVar7;
  routebox_t *prVar8;
  routebox_t *prVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  byte bVar13;
  ushort local_28;
  
  bVar13 = 0;
  prVar8 = (routebox_t *)calloc(1,0x7c);
  iVar10 = 0x1f;
  prVar9 = prVar8;
  while (iVar10 != 0) {
    iVar10 = iVar10 + -1;
    (prVar9->box).X1 = 0;
    prVar9 = (routebox_t *)((int)prVar9 + (uint)bVar13 * -8 + 4);
  }
  prVar8->type = HID_Mixed;
  local_28 = (ushort)group;
  iVar10 = area->Y2;
  iVar2 = area->X2;
  iVar12 = area->Y1;
  iVar11 = area->X1;
  prVar8->group = local_28;
  pbVar1 = (byte *)&(prVar8->flags).field_0x1;
  *pbVar1 = *pbVar1 | 0x40;
  (prVar8->box).X1 = iVar11;
  (prVar8->box).Y1 = iVar12;
  (prVar8->box).X2 = iVar2;
  (prVar8->box).Y2 = iVar10;
  (prVar8->sbox).X1 = iVar11;
  (prVar8->sbox).Y1 = iVar12;
  (prVar8->sbox).X2 = iVar2;
  (prVar8->sbox).Y2 = iVar10;
  prVar9 = parent;
  if ((*(ushort *)&parent->flags & 0x440) == 0x40) {
    uVar3 = (parent->flags).is_thermal;
    while ((uVar3 == 0 &&
           (prVar9 = (routebox_t *)prVar9->parent, (*(ushort *)&prVar9->flags & 0x440) == 0x40))) {
      uVar3 = (prVar9->flags).is_thermal;
    }
  }
  iVar4 = (prVar9->cost_point).X;
  *(routebox_t **)&prVar8->parent = prVar9;
  if ((iVar11 <= iVar4) && (iVar11 = iVar4, iVar2 <= iVar4)) {
    iVar11 = iVar2 + -1;
  }
  iVar2 = (prVar9->cost_point).Y;
  if ((iVar12 <= iVar2) && (iVar12 = iVar2, iVar10 <= iVar2)) {
    iVar12 = iVar10 + -1;
  }
  (prVar8->cost_point).X = iVar11;
  iVar10 = (prVar9->cost_point).X;
  (prVar8->cost_point).Y = iVar12;
  iVar2 = (prVar9->cost_point).Y;
  dVar6 = (double)x_cost[group & 0xffff] * (double)(iVar10 - iVar11);
  dVar5 = (double)y_cost[group & 0xffff] * (double)(iVar2 - iVar12);
  if (dVar6 < 0.00000000) {
    dVar6 = -dVar6;
  }
  if (dVar5 < 0.00000000) {
    dVar5 = -dVar5;
  }
  dVar5 = dVar5 + dVar6;
  if ((iVar11 != iVar10) && (iVar12 != iVar2)) {
    dVar5 = dVar5 + (double)AutoRouteParameters.JogPenalty;
  }
  *(double *)&prVar8->cost = dVar5 + (double)prVar9->cost;
  if ((*(byte *)&prVar9->flags & 0x40) != 0) {
    prVar9->refcount = prVar9->refcount + 1;
  }
  pRVar7 = AutoRouteParameters.style;
  *(byte *)&prVar8->flags = *(byte *)&prVar8->flags | 0x50;
  prVar8->style = pRVar7;
  prVar8->conflicts_with = parent->conflicts_with;
  prVar8->came_from = src_edge->expand_dir;
  return prVar8;
}



routebox_t * __regparm3 CreateBridge(BoxType *area,routebox_t *parent,direction_t dir)

{
  byte *pbVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  RouteStyleType *pRVar7;
  double dVar8;
  double dVar9;
  routebox_t *prVar10;
  int iVar11;
  routebox_t *prVar12;
  int iVar13;
  int iVar14;
  byte bVar15;
  
  bVar15 = 0;
  prVar10 = (routebox_t *)calloc(1,0x7c);
  iVar13 = 0x1f;
  prVar12 = prVar10;
  while (iVar13 != 0) {
    iVar13 = iVar13 + -1;
    (prVar12->box).X1 = 0;
    prVar12 = (routebox_t *)((int)prVar12 + (uint)bVar15 * -8 + 4);
  }
  prVar10->type = HID_Mixed;
  iVar13 = area->Y2;
  iVar4 = area->X2;
  iVar14 = area->Y1;
  iVar11 = area->X1;
  pbVar1 = (byte *)&(prVar10->flags).field_0x1;
  *pbVar1 = *pbVar1 | 0x40;
  (prVar10->box).X1 = iVar11;
  (prVar10->box).Y2 = iVar13;
  (prVar10->sbox).Y2 = iVar13;
  uVar3 = parent->group;
  (prVar10->box).Y1 = iVar14;
  (prVar10->box).X2 = iVar4;
  (prVar10->sbox).X1 = iVar11;
  prVar10->group = uVar3;
  (prVar10->sbox).Y1 = iVar14;
  (prVar10->sbox).X2 = iVar4;
  prVar10->came_from = dir;
  iVar5 = (parent->cost_point).X;
  if ((iVar11 <= iVar5) && (iVar11 = iVar4 + -1, iVar5 < iVar4)) {
    iVar11 = iVar5;
  }
  iVar4 = (parent->cost_point).Y;
  if ((iVar14 <= iVar4) && (iVar14 = iVar13 + -1, iVar4 < iVar13)) {
    iVar14 = iVar4;
  }
  dVar2 = (double)parent->cost;
  (prVar10->cost_point).X = iVar11;
  (prVar10->cost_point).Y = iVar14;
  dVar9 = (double)x_cost[uVar3] * (double)(iVar5 - iVar11);
  dVar8 = (double)y_cost[uVar3] * (double)(iVar4 - iVar14);
  if (dVar9 < 0.00000000) {
    dVar9 = -dVar9;
  }
  if (dVar8 < 0.00000000) {
    dVar8 = -dVar8;
  }
  dVar8 = dVar8 + dVar9;
  if ((iVar11 != iVar5) && (iVar14 != iVar4)) {
    dVar8 = dVar8 + (double)AutoRouteParameters.JogPenalty;
  }
  uVar3 = *(ushort *)&parent->flags;
  *(double *)&prVar10->cost = dVar8 + dVar2;
  prVar12 = parent;
  if ((uVar3 & 0x440) == 0x40) {
    uVar6 = (parent->flags).is_thermal;
    while ((uVar6 == 0 &&
           (prVar12 = (routebox_t *)prVar12->parent, (*(ushort *)&prVar12->flags & 0x440) == 0x40)))
    {
      uVar6 = (prVar12->flags).is_thermal;
    }
  }
  *(routebox_t **)&prVar10->parent = prVar12;
  if ((*(byte *)&prVar12->flags & 0x40) != 0) {
    prVar12->refcount = prVar12->refcount + 1;
  }
  pRVar7 = parent->style;
  *(byte *)&prVar10->flags = *(byte *)&prVar10->flags | 0x50;
  prVar10->style = pRVar7;
  prVar10->conflicts_with = parent->conflicts_with;
  return prVar10;
}



edge_t * __regparm3
CreateEdge2(routebox_t *rb,direction_t expand_dir,edge_t *previous_edge,routebox_t *guess)

{
  double dVar1;
  double dVar2;
  edge_t *peVar3;
  int CostPointY;
  int CostPointX;
  int local_34;
  int local_30;
  int local_2c;
  LocationType local_28;
  int local_24;
  
  local_2c = (rb->sbox).X2;
  local_34 = (rb->sbox).Y2;
  CostPointX = (rb->sbox).X1;
  CostPointY = (rb->sbox).Y1;
  if (expand_dir == EAST) {
    local_28 = (previous_edge->cost_point).Y;
    local_24 = (previous_edge->cost_point).X;
    CostPointX = local_2c + -1;
    if (CostPointX <= local_24) goto LAB_08070769;
LAB_08070682:
    local_30 = local_24 - CostPointX;
  }
  else {
    if (expand_dir == NORTH) {
      local_34 = CostPointY + 1;
    }
    else {
      if (expand_dir == SOUTH) {
        CostPointY = local_34 + -1;
      }
      else {
        if (expand_dir == WEST) {
          local_2c = CostPointX + 1;
        }
      }
    }
    local_28 = (previous_edge->cost_point).Y;
    local_24 = (previous_edge->cost_point).X;
    if (local_24 < CostPointX) goto LAB_08070682;
LAB_08070769:
    local_30 = 0;
    CostPointX = local_24;
    if (local_2c <= local_24) {
      CostPointX = local_2c + -1;
      local_30 = local_24 - CostPointX;
    }
  }
  if (CostPointY <= local_28) {
    local_2c = 0;
    CostPointY = local_28;
    if (local_28 < local_34) goto LAB_080706a3;
    CostPointY = local_34 + -1;
  }
  local_2c = local_28 - CostPointY;
LAB_080706a3:
  dVar2 = (double)x_cost[rb->group] * (double)local_30;
  dVar1 = (double)y_cost[rb->group] * (double)local_2c;
  if (dVar2 < 0.00000000) {
    dVar2 = -dVar2;
  }
  if (dVar1 < 0.00000000) {
    dVar1 = -dVar1;
  }
  dVar1 = dVar1 + dVar2;
  if ((CostPointX != local_24) && (CostPointY != local_28)) {
    dVar1 = dVar1 + (double)AutoRouteParameters.JogPenalty;
  }
  if (expand_dir != previous_edge->expand_dir) {
    dVar1 = dVar1 + (double)AutoRouteParameters.JogPenalty;
  }
  if (guess == (routebox_t *)0x0) {
    guess = previous_edge->mincost_target;
  }
  peVar3 = CreateEdge(rb,CostPointX,CostPointY,
                      (cost_t)(dVar1 + (double)previous_edge->cost_to_point),guess,expand_dir,
                      (rtree_t *)0x0);
  return peVar3;
}



void do_via_search(edge_t *search,routeone_state *s,routeone_via_site_state *vss,mtspace_t *mtspace,
                  rtree_t *targets)

{
  Cardinal *pCVar1;
  byte *pbVar2;
  byte bVar3;
  int iVar4;
  int iVar5;
  routebox_t *rb;
  int iVar6;
  int iVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  byte bVar11;
  vetting_t *work;
  int CostPointY;
  int *__ptr;
  routebox_t *rb_00;
  uint uVar12;
  edge_t *e;
  routebox_t *mincost_target_guess;
  int CostPointY_00;
  int iVar13;
  PCBTypePtr pPVar14;
  int CostPointX;
  Cardinal group;
  vector_t *local_78;
  int local_6c;
  int local_68;
  int local_64;
  cost_t scale [3];
  BoxType cliparea;
  CheapPointType pnt;
  
  iVar4 = (AutoRouteParameters.style)->Diameter;
  iVar5 = (AutoRouteParameters.style)->Keepaway;
  work = mtspace_query_rect(mtspace,(BoxType *)0x0,0,0,search->work,vss->free_space_vec,
                            vss->lo_conflict_space_vec,vss->hi_conflict_space_vec,
                            AutoRouteParameters.is_odd,AutoRouteParameters.with_conflicts,
                            (CheapPointType *)0x0);
  rb = search->rb;
  local_6c = 0;
  bVar11 = *(byte *)&search->flags >> 1 & 3;
LAB_08070882:
  if (local_6c == 0) {
    local_78 = vss->free_space_vec;
  }
  else {
    if (local_6c == 1) {
      local_78 = vss->lo_conflict_space_vec;
    }
    else {
      local_78 = vss->hi_conflict_space_vec;
    }
  }
  iVar13 = (iVar4 + 1) / 2 + iVar5;
  do {
    do {
      CostPointY = vector_is_empty(local_78);
      while( true ) {
        if (CostPointY != 0) {
          local_6c = local_6c + 1;
          if (local_6c == 3) {
            bVar3 = *(byte *)&search->flags;
            *(byte *)&search->flags = bVar3 & 0xef;
            if (work != (vetting_t *)0x0) {
              CreateSearchEdge(s,work,search,rb,(uint)bVar11,targets,bVar3 >> 5 & 1);
            }
            return;
          }
          goto LAB_08070882;
        }
        __ptr = (int *)vector_remove_last(local_78);
        if ((local_6c == 0) || (AutoRouteParameters.with_conflicts != '\0')) break;
        free(__ptr);
        CostPointY = vector_is_empty(local_78);
      }
      cliparea.Y1 = iVar13 + __ptr[1];
      cliparea.X1 = iVar13 + *__ptr;
      cliparea.Y2 = (__ptr[3] + 1) - iVar13;
      cliparea.X2 = (__ptr[2] + 1) - iVar13;
      free(__ptr);
    } while (PCB->Data->LayerN < 1);
    group = 0;
    pPVar14 = PCB;
    do {
      if (((uint)rb->group != group) && (is_layer_group_active[group] != '\0')) {
        scale[0] = 1.00000000;
        scale[1] = AutoRouteParameters.LastConflictPenalty;
        scale[2] = AutoRouteParameters.ConflictPenalty;
        rb_00 = CreateExpansionArea(&cliparea,group,rb,'\x01',search);
        pbVar2 = (byte *)&(rb_00->flags).field_0x1;
        *pbVar2 = *pbVar2 | 4;
        rb_00->came_from = ALL;
        if ((*(byte *)&search->flags & 0x20) == 0) {
          CostPointX = (search->cost_point).X;
          CostPointY = (rb_00->sbox).X1;
          mincost_target_guess = search->mincost_target;
          if (CostPointX < CostPointY) {
            local_68 = CostPointY - CostPointX;
          }
          else {
            CostPointY_00 = (rb_00->sbox).X2;
            local_68 = 0;
            CostPointY = CostPointX;
            if (CostPointY_00 <= CostPointX) {
              CostPointY = CostPointY_00 + -1;
              local_68 = CostPointY - CostPointX;
            }
          }
          iVar6 = (search->cost_point).Y;
          CostPointY_00 = (rb_00->sbox).Y1;
          if (iVar6 < CostPointY_00) {
LAB_080709c9:
            local_64 = CostPointY_00 - iVar6;
          }
          else {
            iVar7 = (rb_00->sbox).Y2;
            local_64 = 0;
            CostPointY_00 = iVar6;
            if (iVar7 <= iVar6) {
              CostPointY_00 = iVar7 + -1;
              goto LAB_080709c9;
            }
          }
          uVar12 = (uint)search->rb->group;
          dVar9 = (double)x_cost[uVar12] * (double)local_68;
          dVar8 = (double)y_cost[uVar12] * (double)local_64;
          if (dVar9 < 0.00000000) {
            dVar9 = -dVar9;
          }
          if (dVar8 < 0.00000000) {
            dVar8 = -dVar8;
          }
          dVar8 = dVar8 + dVar9;
          if ((CostPointX != CostPointY) && (iVar6 != CostPointY_00)) {
            dVar8 = dVar8 + (double)AutoRouteParameters.JogPenalty;
          }
          dVar10 = (double)x_cost[group] * 0.00000000;
          dVar9 = (double)y_cost[group] * 0.00000000;
          if (dVar10 < 0.00000000) {
            dVar10 = -dVar10;
          }
          if (dVar9 < 0.00000000) {
            dVar9 = -dVar9;
          }
          dVar9 = dVar9 + dVar10;
          if (uVar12 != group) {
            dVar9 = dVar9 + (double)AutoRouteParameters.ViaCost;
          }
          dVar8 = (double)scale[local_6c] * dVar9 + dVar8 * (double)scale[(uint)bVar11];
          if ((uint)mincost_target_guess->group == group) {
            if (((((mincost_target_guess->sbox).X1 <= CostPointY) &&
                 ((mincost_target_guess->sbox).Y1 <= CostPointY_00)) &&
                (CostPointY < (mincost_target_guess->sbox).X2)) &&
               (CostPointY_00 < (mincost_target_guess->sbox).Y2)) {
              dVar8 = (double)AutoRouteParameters.ViaCost * -0.50000000 + dVar8;
            }
          }
          e = CreateEdge(rb_00,CostPointY,CostPointY_00,
                         (cost_t)(dVar8 + (double)search->cost_to_point),mincost_target_guess,ALL,
                         targets);
        }
        else {
          pnt.X = (cliparea.X2 - cliparea.X1) / 2 + cliparea.X1;
          pnt.Y = (cliparea.Y2 - cliparea.Y1) / 2 + cliparea.Y1;
          mincost_target_guess =
               mincost_target_to_point(&pnt,(uint)rb_00->group,targets,search->mincost_target);
          CostPointY = (mincost_target_guess->box).X1;
          pnt.X = ((mincost_target_guess->box).X2 - CostPointY) / 2 + CostPointY;
          CostPointY = (mincost_target_guess->box).Y1;
          CostPointX = (rb_00->sbox).X1;
          pnt.Y = ((mincost_target_guess->box).Y2 - CostPointY) / 2 + CostPointY;
          if ((CostPointX <= pnt.X) &&
             (CostPointY = (rb_00->sbox).X2, CostPointX = CostPointY + -1, pnt.X < CostPointY)) {
            CostPointX = pnt.X;
          }
          CostPointY = (rb_00->sbox).Y1;
          if ((CostPointY <= pnt.Y) &&
             (CostPointY_00 = (rb_00->sbox).Y2, CostPointY = CostPointY_00 + -1,
             pnt.Y < CostPointY_00)) {
            CostPointY = pnt.Y;
          }
          dVar9 = (double)x_cost[group] * 0.00000000;
          dVar8 = (double)y_cost[group] * 0.00000000;
          if (dVar9 < 0.00000000) {
            dVar9 = -dVar9;
          }
          if (dVar8 < 0.00000000) {
            dVar8 = -dVar8;
          }
          dVar8 = dVar8 + dVar9;
          if ((uint)search->rb->group != group) {
            dVar8 = dVar8 + (double)AutoRouteParameters.ViaCost;
          }
          e = CreateEdge(rb_00,CostPointX,CostPointY,
                         (cost_t)(dVar8 * (double)scale[local_6c] + (double)search->cost_to_point),
                         mincost_target_guess,ALL,(rtree_t *)0x0);
          e->mincost_target = mincost_target_guess;
        }
        *(byte *)&e->flags = *(byte *)&e->flags & 0xf9 | 1 | bVar11 * '\x02';
        add_or_destroy_edge(s,e);
        pPVar14 = PCB;
      }
      group = group + 1;
      pCVar1 = (Cardinal *)&pPVar14->Data->LayerN;
    } while (*pCVar1 != group && (int)group <= (int)*pCVar1);
  } while( true );
}



void moveable_edge(vector_t *result,BoxType *box,direction_t dir,routebox_t *rb,routebox_t *blocker,
                  edge_t *e,rtree_t *targets,routeone_state *s,rtree_t *tree,vector_t *area_vec)

{
  cost_t cost_to_point;
  ushort uVar1;
  routebox_t *prVar2;
  int iVar3;
  double cost_to_point_00;
  double dVar4;
  double dVar5;
  routebox_t *rb_00;
  edge_t *e_00;
  int iVar6;
  int CostPointX;
  int CostPointY;
  int iVar7;
  LocationType CostPointY_00;
  LocationType CostPointX_00;
  int local_40;
  int local_3c;
  int local_34;
  BoxType b;
  
  b.X1 = box->X1;
  b.Y1 = box->Y1;
  b.X2 = box->X2;
  b.Y2 = box->Y2;
  switch(dir) {
  case NORTH:
    iVar6 = b.Y1 + -1;
    b.Y2 = b.Y1;
    CostPointX = iVar6;
    goto joined_r0x080711b2;
  case EAST:
    iVar6 = b.X2 + 1;
    b.X1 = b.X2;
    b.X2 = iVar6;
    if (PCB->MaxWidth - AutoRouteParameters.bloat <= iVar6) {
      return;
    }
    break;
  case SOUTH:
    iVar6 = b.Y2 + 1;
    b.Y1 = b.Y2;
    b.Y2 = iVar6;
    if (PCB->MaxHeight - AutoRouteParameters.bloat <= iVar6) {
      return;
    }
    break;
  case WEST:
    CostPointX = b.X1 + -1;
    b.X2 = b.X1;
    iVar6 = b.Y1;
    b.X1 = CostPointX;
joined_r0x080711b2:
    b.Y1 = iVar6;
    if (CostPointX <= AutoRouteParameters.bloat) {
      return;
    }
    break;
  case NE:
    if (AutoRouteParameters.bloat + 1 < b.Y1) {
      if (~AutoRouteParameters.bloat + PCB->MaxWidth <= b.X2) {
        dir = NORTH;
      }
      break;
    }
    iVar6 = ~AutoRouteParameters.bloat + PCB->MaxWidth;
    goto joined_r0x0807121e;
  case SE:
    if (b.Y2 < ~AutoRouteParameters.bloat + PCB->MaxHeight) {
      if (b.X2 < ~AutoRouteParameters.bloat + PCB->MaxWidth) break;
LAB_08071261:
      dir = SOUTH;
      break;
    }
    iVar6 = ~AutoRouteParameters.bloat + PCB->MaxWidth;
joined_r0x0807121e:
    if (iVar6 <= b.X2) {
      return;
    }
    dir = EAST;
    break;
  case SW:
    if (b.Y2 < ~AutoRouteParameters.bloat + PCB->MaxHeight) {
      if (AutoRouteParameters.bloat + 1 < b.X1) break;
      goto LAB_08071261;
    }
    goto joined_r0x08071114;
  case NW:
    if (AutoRouteParameters.bloat + 1 < b.Y1) {
      if (b.X1 <= AutoRouteParameters.bloat + 1) {
        dir = NORTH;
      }
      break;
    }
joined_r0x08071114:
    if (b.X1 <= AutoRouteParameters.bloat + 1) {
      return;
    }
    dir = WEST;
  }
  if (blocker == (routebox_t *)0x0) {
    rb_00 = CreateBridge(&b,rb,dir);
    if (dir + ~WEST < 4) {
      iVar6 = (rb_00->cost_point).X;
      prVar2 = e->mincost_target;
      CostPointX = (prVar2->sbox).X1;
      if ((CostPointX <= iVar6) &&
         (CostPointY = (prVar2->sbox).X2, CostPointX = CostPointY + -1, iVar6 < CostPointY)) {
        CostPointX = iVar6;
      }
      CostPointY = (rb_00->cost_point).Y;
      iVar7 = (prVar2->sbox).Y1;
      if ((iVar7 <= CostPointY) &&
         (iVar3 = (prVar2->sbox).Y2, iVar7 = CostPointY, iVar3 <= CostPointY)) {
        iVar7 = iVar3 + -1;
      }
      CostPointX_00 = b.X1;
      if ((b.X1 <= CostPointX) && (CostPointX_00 = CostPointX, b.X2 <= CostPointX)) {
        CostPointX_00 = b.X2 + -1;
      }
      CostPointY_00 = b.Y1;
      if ((b.Y1 <= iVar7) && (CostPointY_00 = iVar7, b.Y2 <= iVar7)) {
        CostPointY_00 = b.Y2 + -1;
      }
      dVar4 = (double)x_cost[rb_00->group] * (double)(CostPointX_00 - iVar6);
      cost_to_point_00 = (double)y_cost[rb_00->group] * (double)(CostPointY_00 - CostPointY);
      if (dVar4 < 0.00000000) {
        dVar4 = -dVar4;
      }
      if (cost_to_point_00 < 0.00000000) {
        cost_to_point_00 = -cost_to_point_00;
      }
      cost_to_point_00 = cost_to_point_00 + dVar4;
      if ((iVar6 != CostPointX_00) && (CostPointY != CostPointY_00)) {
        cost_to_point_00 = cost_to_point_00 + (double)AutoRouteParameters.JogPenalty;
      }
      cost_to_point = (cost_t)(cost_to_point_00 + (double)rb_00->cost);
      (rb_00->cost_point).Y = CostPointY_00;
      (rb_00->cost_point).X = CostPointX_00;
      rb_00->cost = cost_to_point;
    }
    else {
      cost_to_point = rb_00->cost;
      CostPointY_00 = (rb_00->cost_point).Y;
      CostPointX_00 = (rb_00->cost_point).X;
    }
    e_00 = CreateEdge(rb_00,CostPointX_00,CostPointY_00,cost_to_point,(routebox_t *)0x0,dir,targets)
    ;
    vector_append(result,e_00);
  }
  else {
    if ((AutoRouteParameters.with_conflicts == '\0') || ((*(ushort *)&blocker->flags & 0x10e) != 0))
    {
      if (blocker->type != HID_Mixed) {
        if ((*(byte *)&blocker->flags & 8) == 0) {
          return;
        }
        local_3c = b.Y1 + -1;
        iVar6 = b.X1 + -1;
        local_40 = b.Y2 + 1;
        local_34 = b.X2 + 1;
        if (((((blocker->sbox).X2 <= iVar6) || (local_34 <= (blocker->sbox).X1)) ||
            ((blocker->sbox).Y2 <= local_3c)) || (local_40 <= (blocker->sbox).Y1)) {
          if (dir == EAST) {
            local_34 = b.X2 + 2 + AutoRouteParameters.bloat;
          }
          else {
            if (dir == NORTH) {
              local_3c = local_3c + ~AutoRouteParameters.bloat;
            }
            else {
              if (dir == SOUTH) {
                local_40 = b.Y2 + 2 + AutoRouteParameters.bloat;
              }
              else {
                if (dir == WEST) {
                  iVar6 = iVar6 + ~AutoRouteParameters.bloat;
                }
              }
            }
          }
        }
        b.X1 = iVar6 + 1;
        b.X2 = local_34 + -1;
        b.Y1 = local_3c + 1;
        b.Y2 = local_40 + -1;
        rb_00 = CreateBridge(&b,rb,dir);
        r_insert_entry(tree,(BoxType *)rb_00,1);
        vector_append(area_vec,rb_00);
        CostPointY_00 = (rb_00->cost_point).Y;
        CostPointX_00 = (rb_00->cost_point).X;
        *(byte *)&rb_00->flags = *(byte *)&rb_00->flags & 0xbf;
        e_00 = CreateEdge(rb_00,CostPointX_00,CostPointY_00,rb_00->cost,blocker,dir,(rtree_t *)0x0);
        best_path_candidate(s,e_00,blocker);
        KillEdge(e_00);
        return;
      }
    }
    else {
      if (blocker->type != HID_Mixed) {
        if (dir == EAST) {
          b.X2 = (blocker->sbox).X1 + 1;
        }
        else {
          if (dir == NORTH) {
            b.Y1 = (blocker->sbox).Y2 + -1;
          }
          else {
            if (dir == SOUTH) {
              b.Y2 = (blocker->sbox).Y1 + 1;
            }
            else {
              if (dir == WEST) {
                b.X1 = (blocker->sbox).X2 + -1;
              }
            }
          }
        }
        if (b.X2 <= b.X1) {
          return;
        }
        if (b.Y2 <= b.Y1) {
          return;
        }
        rb_00 = CreateBridge(&b,rb,dir);
        r_insert_entry(tree,(BoxType *)rb_00,1);
        vector_append(area_vec,rb_00);
        *(byte *)&rb_00->flags = *(byte *)&rb_00->flags & 0xbf;
        path_conflicts(rb_00,blocker,'\x01');
        iVar6 = (rb_00->cost_point).X;
        CostPointX = (blocker->sbox).X1;
        if ((CostPointX <= iVar6) &&
           (CostPointY = (blocker->sbox).X2, CostPointX = iVar6, CostPointY <= iVar6)) {
          CostPointX = CostPointY + -1;
        }
        iVar6 = (rb_00->cost_point).Y;
        CostPointY = (blocker->sbox).Y1;
        if ((CostPointY <= iVar6) &&
           (iVar7 = (blocker->sbox).Y2, CostPointY = iVar6, iVar7 <= iVar6)) {
          CostPointY = iVar7 + -1;
        }
        uVar1 = rb_00->group;
        (rb_00->cost_point).X = CostPointX;
        cost_to_point_00 = (double)rb_00->cost;
        (rb_00->cost_point).Y = CostPointY;
        iVar6 = *(int *)(rb_00->parent + 0x3c);
        iVar7 = *(int *)(rb_00->parent + 0x40);
        dVar5 = (double)x_cost[uVar1] * (double)(iVar6 - CostPointX);
        dVar4 = (double)y_cost[uVar1] * (double)(iVar7 - CostPointY);
        if (dVar5 < 0.00000000) {
          dVar5 = -dVar5;
        }
        if (dVar4 < 0.00000000) {
          dVar4 = -dVar4;
        }
        dVar4 = dVar4 + dVar5;
        if ((CostPointX != iVar6) && (CostPointY != iVar7)) {
          dVar4 = dVar4 + (double)AutoRouteParameters.JogPenalty;
        }
        dVar5 = (double)AutoRouteParameters.ConflictPenalty;
        if ((uint)(*(byte *)&blocker->flags >> 7) != (int)AutoRouteParameters.is_odd) {
          dVar5 = (double)AutoRouteParameters.LastConflictPenalty;
        }
        cost_to_point_00 = (double)(uint)blocker->pass * dVar5 * dVar4 + cost_to_point_00;
        *(double *)&rb_00->cost = cost_to_point_00;
        e_00 = CreateEdge(rb_00,CostPointX,CostPointY,(cost_t)cost_to_point_00,(routebox_t *)0x0,ALL
                          ,targets);
        *(byte *)&e_00->flags = *(byte *)&e_00->flags | 8;
        vector_append(result,e_00);
        return;
      }
    }
    if ((double)rb->cost <= (double)blocker->cost) {
      iVar6 = (blocker->cost_point).X;
      CostPointX = (rb->cost_point).X;
      CostPointY = (blocker->cost_point).Y;
      iVar7 = (rb->cost_point).Y;
      dVar4 = (double)x_cost[rb->group] * (double)(iVar6 - CostPointX);
      cost_to_point_00 = (double)y_cost[rb->group] * (double)(CostPointY - iVar7);
      if (dVar4 < 0.00000000) {
        dVar4 = -dVar4;
      }
      if (cost_to_point_00 < 0.00000000) {
        cost_to_point_00 = -cost_to_point_00;
      }
      cost_to_point_00 = cost_to_point_00 + dVar4;
      if ((iVar6 != CostPointX) && (CostPointY != iVar7)) {
        cost_to_point_00 = cost_to_point_00 + (double)AutoRouteParameters.JogPenalty;
      }
      if (((cost_to_point_00 + (double)rb->cost < (double)blocker->cost) &&
          (blocker->conflicts_with == (vector_t *)0x0)) && (rb->conflicts_with == (vector_t *)0x0))
      {
        if ((*(byte *)&((routebox_t *)blocker->parent)->flags & 0x40) != 0) {
          RB_down_count((routebox_t *)blocker->parent);
        }
        *(routebox_t **)&blocker->parent = rb;
      }
    }
  }
  return;
}



vector_t *
BreakManyEdges(routeone_state *s,rtree_t *targets,rtree_t *tree,vector_t *area_vec,E_result *ans,
              routebox_t *rb,edge_t *e)

{
  LocationType LVar1;
  int iVar2;
  int iVar3;
  LocationType LVar4;
  LocationType LVar5;
  LocationType LVar6;
  LocationType LVar7;
  LocationType LVar8;
  LocationType LVar9;
  vector_t *result;
  uint uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  direction_t local_1c4;
  direction_t which_edge;
  heap_t **heap_00;
  direction_t dVar14;
  LocationType LVar15;
  int iVar16;
  routebox_t *breaker;
  byte bVar17;
  LocationType local_170;
  direction_t local_164;
  LocationType local_15c;
  LocationType local_158;
  LocationType local_154;
  LocationType local_150;
  LocationType local_14c;
  LocationType local_148;
  LocationType local_144;
  LocationType local_140;
  LocationType local_13c;
  LocationType local_138;
  LocationType local_134;
  LocationType local_130;
  undefined4 local_12c;
  routebox_t fake;
  broken_boxes broke;
  break_info bi;
  BoxType db;
  BoxType b;
  heap_t *heap [4];
  heap_t *local_1c [3];
  
  bVar17 = 0;
  result = vector_create();
  bi.parent = rb;
  bi.ignore_source = *(byte *)(rb->parent + 0x2c) >> 2 & 1;
  uVar10 = AutoRouteParameters.bloat + 2;
  which_edge = e->expand_dir;
  if (which_edge + ~WEST < 4) {
    iVar11 = 0x1f;
    breaker = &fake;
    while (iVar11 != 0) {
      iVar11 = iVar11 + -1;
      (breaker->box).X1 = 0;
      breaker = (routebox_t *)((int)breaker + (uint)bVar17 * -8 + 4);
    }
    fake.type = LINE;
    breaker = e->rb;
    fake.sbox.X1 = (breaker->sbox).X1;
    fake.sbox.Y1 = (breaker->sbox).Y1;
    fake.sbox.X2 = (breaker->sbox).X2;
    fake.sbox.Y2 = (breaker->sbox).Y2;
    fake.flags._0_1_ = fake.flags._0_1_ | 2;
    fake.style = AutoRouteParameters.style;
  }
  dVar14 = SOUTH;
  local_1c4 = NORTH;
  do {
    if ((dVar14 & WEST) == which_edge) {
      heap[local_1c4] = (heap_t *)0x0;
    }
    else {
      bi.heap = heap_create();
      bi.box.X1 = -uVar10 + (rb->sbox).X1;
      bi.box.Y1 = -uVar10 + (rb->sbox).Y1;
      iVar11 = (rb->sbox).X2;
      heap[local_1c4] = bi.heap;
      bi.box.X2 = iVar11 + uVar10;
      bi.box.Y2 = (rb->sbox).Y2 + uVar10;
      bi.dir = local_1c4;
      if (local_1c4 == SOUTH) {
        bi.box.Y1 = bi.box.Y2 + ~uVar10;
        which_edge = e->expand_dir;
        if ((which_edge == NW) || (which_edge == NE)) {
          blocker_to_heap(bi.heap,&fake,&bi.box,SOUTH);
          which_edge = e->expand_dir;
          if (which_edge != NE) goto LAB_08071da1;
          bi.box.X1 = (e->rb->sbox).X2;
        }
        else {
LAB_08071da1:
          if (which_edge == NW) {
            bi.box.X2 = (e->rb->sbox).X1;
          }
        }
        iVar11 = r_search(tree,&bi.box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,
                          &bi);
        rb->s = (uchar)iVar11;
      }
      else {
        if (local_1c4 != WEST) {
          if (local_1c4 == EAST) {
            bi.box.X1 = bi.box.X2 + ~uVar10;
            which_edge = e->expand_dir;
            if (which_edge + ~SE < 2) {
              blocker_to_heap(bi.heap,&fake,&bi.box,EAST);
              which_edge = e->expand_dir;
              if (which_edge != SW) goto LAB_08071ce1;
              bi.box.Y1 = (e->rb->sbox).Y2;
            }
            else {
LAB_08071ce1:
              if (which_edge == NW) {
                bi.box.Y2 = (e->rb->sbox).Y1;
              }
            }
            iVar11 = r_search(tree,&bi.box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                              __GatherBlockers,&bi);
            rb->e = (uchar)iVar11;
            goto joined_r0x080718a1;
          }
          bi.box.Y2 = bi.box.Y1 + 1 + uVar10;
          which_edge = e->expand_dir;
          if (which_edge + ~NE < 2) {
            blocker_to_heap(bi.heap,&fake,&bi.box,NORTH);
            which_edge = e->expand_dir;
            if (which_edge != SE) goto LAB_080715ae;
            bi.box.X1 = (e->rb->sbox).X2;
          }
          else {
LAB_080715ae:
            if (which_edge == SW) {
              bi.box.X2 = (e->rb->sbox).X1;
            }
          }
          iVar11 = r_search(tree,&bi.box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,
                            &bi);
          rb->n = (uchar)iVar11;
          goto joined_r0x080718a1;
        }
        bi.box.X2 = bi.box.X1 + 1 + uVar10;
        which_edge = e->expand_dir;
        if (which_edge + ~WEST < 2) {
          blocker_to_heap(bi.heap,&fake,&bi.box,WEST);
          which_edge = e->expand_dir;
          if (which_edge != SE) goto LAB_08071d45;
          bi.box.Y1 = (e->rb->sbox).Y2;
        }
        else {
LAB_08071d45:
          if (which_edge == NE) {
            bi.box.Y2 = (e->rb->sbox).Y1;
          }
        }
        iVar11 = r_search(tree,&bi.box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,__GatherBlockers,
                          &bi);
        rb->w = (uchar)iVar11;
      }
    }
joined_r0x080718a1:
    if (dVar14 == SE) break;
    dVar14 = dVar14 + EAST;
    local_1c4 = local_1c4 + EAST;
    which_edge = e->expand_dir;
  } while( true );
  which_edge = NORTH;
  LVar15 = -1;
  local_164 = ~NORTH;
  local_170 = -1;
  *(double *)&rb->cost =
       ((double)((uint)rb->e + (uint)rb->n + (uint)rb->s + (uint)rb->w) *
       (double)AutoRouteParameters.CongestionPenalty) /
       ((double)((rb->sbox).Y2 - (rb->sbox).Y1) * (double)((rb->sbox).X2 - (rb->sbox).X1)) +
       (double)rb->cost;
  do {
    if ((heap[which_edge] == (heap_t *)0x0) ||
       (iVar11 = heap_is_empty(heap[which_edge]), iVar11 != 0)) {
      local_1c4 = e->expand_dir;
      if (local_1c4 == ALL) {
        local_1c4 = e->rb->came_from;
      }
      if (local_1c4 != (local_164 + WEST & WEST)) {
        moveable_edge(result,&rb->sbox,which_edge,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                      (vector_t *)0x0);
      }
      if (LVar15 < 1) goto LAB_080718c8;
      iVar11 = (rb->sbox).X2;
      LVar1 = (rb->sbox).Y2;
      iVar2 = (rb->sbox).Y1;
      iVar3 = (rb->sbox).X1;
      iVar12 = iVar3;
      iVar13 = LVar15;
      iVar16 = iVar11;
      if (((which_edge != SOUTH) && (iVar13 = iVar2, iVar16 = LVar15, which_edge != WEST)) &&
         (iVar12 = LVar15, iVar16 = iVar11, which_edge != EAST)) {
        Message("previous edge bogus direction!");
        iVar12 = iVar3;
      }
      LVar15 = -1;
      db.X1 = iVar12;
      db.Y1 = iVar13;
      db.X2 = iVar16;
      db.Y2 = LVar1;
      moveable_edge(result,&db,local_164,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                    (vector_t *)0x0);
    }
    else {
      breaker = (routebox_t *)heap_remove_smallest(heap[which_edge]);
      b.X1 = (rb->sbox).X1;
      b.Y1 = (rb->sbox).Y1;
      b.X2 = (rb->sbox).X2;
      b.Y2 = (rb->sbox).Y2;
      break_box_edge(&broke,&b,which_edge,breaker);
      if (broke.is_valid_left == '\0') {
        if (0 < LVar15) {
          LVar1 = (rb->sbox).X2;
          LVar4 = (rb->sbox).Y2;
          LVar5 = (rb->sbox).Y1;
          LVar6 = (rb->sbox).X1;
          local_1c4 = local_164;
          LVar7 = LVar6;
          LVar8 = LVar15;
          LVar9 = LVar1;
          if (((which_edge != SOUTH) && (LVar8 = LVar5, LVar9 = LVar15, which_edge != WEST)) &&
             (LVar7 = LVar15, LVar9 = LVar1, which_edge != EAST)) {
            Message("previous edge bogus direction!");
            LVar7 = LVar6;
          }
          goto LAB_08071a96;
        }
      }
      else {
        if (LVar15 < 1) {
          if (which_edge == NORTH) {
            local_170 = broke.left.X2;
            if (broke.left.X2 <= b.X1) {
              local_170 = b.X1;
            }
          }
          else {
            moveable_edge(result,(BoxType *)&broke,which_edge,rb,(routebox_t *)0x0,e,targets,s,
                          (rtree_t *)0x0,(vector_t *)0x0);
          }
        }
        else {
          db.X1 = b.X1;
          db.Y1 = b.Y1;
          db.X2 = b.X2;
          db.Y2 = b.Y2;
          if (which_edge == SOUTH) {
            db.X1 = broke.left.X1;
            db.Y1 = LVar15;
            if (broke.left.X1 <= b.X1) {
              db.X1 = b.X1;
            }
          }
          else {
            if (which_edge == WEST) {
              db.Y1 = broke.left.Y1;
              db.X2 = LVar15;
              if (broke.left.Y1 <= b.Y1) {
                db.Y1 = b.Y1;
              }
            }
            else {
              if ((which_edge == EAST) &&
                 (db.X1 = LVar15, db.Y2 = broke.left.Y2, b.Y2 <= broke.left.Y2)) {
                db.Y2 = b.Y2;
              }
            }
          }
          local_1c4 = local_164 + NE;
          LVar7 = db.X1;
          LVar8 = db.Y1;
          LVar9 = db.X2;
          LVar4 = db.Y2;
LAB_08071a96:
          db.Y2 = LVar4;
          db.X2 = LVar9;
          db.Y1 = LVar8;
          db.X1 = LVar7;
          moveable_edge(result,&db,local_1c4,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                        (vector_t *)0x0);
        }
      }
      if (broke.is_valid_center != '\0') {
        bVar17 = *(byte *)&breaker->flags;
        goto joined_r0x08071abb;
      }
      while (broke.is_valid_right != '\0') {
        if (which_edge == SOUTH) {
          LVar15 = b.X2;
          if (broke.right.X2 <= b.X2) {
            LVar15 = broke.right.X2;
            b.X2 = broke.right.X2;
          }
        }
        else {
          if (which_edge == WEST) {
            LVar15 = b.Y2;
            if (broke.right.Y2 <= b.Y2) {
              LVar15 = broke.right.Y2;
              b.Y2 = broke.right.Y2;
            }
          }
          else {
            if (which_edge == EAST) {
              LVar15 = b.Y1;
              if (b.Y1 <= broke.right.Y1) {
                LVar15 = broke.right.Y1;
                b.Y1 = broke.right.Y1;
              }
            }
            else {
              LVar15 = b.X1;
              if (b.X1 <= broke.right.X1) {
                LVar15 = broke.right.X1;
                b.X1 = broke.right.X1;
              }
            }
          }
        }
        iVar11 = heap_is_empty(heap[which_edge]);
        if (iVar11 != 0) {
          if (broke.is_valid_right != '\0') goto LAB_080717bf;
          break;
        }
        breaker = (routebox_t *)heap_remove_smallest(heap[which_edge]);
        break_box_edge((broken_boxes *)&local_15c,&b,which_edge,breaker);
        broke.left.X1 = local_15c;
        broke.left.Y1 = local_158;
        broke.left.X2 = local_154;
        broke.left.Y2 = local_150;
        broke.center.X1 = local_14c;
        broke.center.Y1 = local_148;
        broke.center.X2 = local_144;
        broke.center.Y2 = local_140;
        broke.right.X1 = local_13c;
        broke.right.Y1 = local_138;
        broke.right.X2 = local_134;
        broke.right.Y2 = local_130;
        broke._48_4_ = local_12c;
        if ((char)local_12c != '\0') {
          moveable_edge(result,(BoxType *)&broke,which_edge,rb,(routebox_t *)0x0,e,targets,s,
                        (rtree_t *)0x0,(vector_t *)0x0);
        }
        if (broke.is_valid_center != '\0') {
          bVar17 = *(byte *)&breaker->flags;
joined_r0x08071abb:
          if ((bVar17 & 4) == 0) {
            moveable_edge(result,&broke.center,which_edge,rb,breaker,e,targets,s,tree,area_vec);
          }
        }
      }
LAB_080718c8:
      LVar15 = -1;
    }
LAB_080717bf:
    local_164 = local_164 + EAST;
    which_edge = which_edge + EAST;
    if (local_164 == WEST) {
      if (LVar15 < 1) {
        if (0 < local_170) {
          db.X1 = (rb->sbox).X1;
          db.Y1 = (rb->sbox).Y1;
          db.Y2 = (rb->sbox).Y2;
          db.X2 = local_170;
          moveable_edge(result,&db,NORTH,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                        (vector_t *)0x0);
        }
      }
      else {
        if (0 < local_170) {
          db.X1 = (rb->sbox).X1;
          db.Y1 = (rb->sbox).Y1;
          db.X2 = local_170;
          which_edge = NW;
        }
        else {
          db.X1 = (rb->sbox).X1;
          db.Y1 = (rb->sbox).Y1;
          db.X2 = (rb->sbox).X2;
          which_edge = WEST;
        }
        db.Y2 = LVar15;
        moveable_edge(result,&db,which_edge,rb,(routebox_t *)0x0,e,targets,s,(rtree_t *)0x0,
                      (vector_t *)0x0);
      }
      heap_00 = heap;
      iVar11 = 0;
      do {
        if (heap[iVar11] != (heap_t *)0x0) {
          heap_destroy(heap_00);
        }
        heap_00 = heap_00 + 1;
        iVar11 = iVar11 + 1;
      } while (heap_00 != local_1c);
      return result;
    }
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps

routeone_status * __regparm3
RouteOne(routeone_status *__return_storage_ptr__,routedata_t *rd,routebox_t *from,routebox_t *to,
        int max_edges)

{
  byte *pbVar1;
  int *piVar2;
  anon_struct_for_flags *paVar3;
  ushort uVar4;
  routebox *prVar5;
  routebox *prVar6;
  direction_t expand_dir;
  anon_enum_32_for_type aVar7;
  RouteStyleType *pRVar8;
  cost_t cVar9;
  byte bVar10;
  Boolean in_plane;
  BoxType **boxlist;
  int CostPointX;
  edge_t *search;
  routebox *cl;
  int iVar11;
  E_result *ans;
  routebox_t *local_100;
  vector_element_t data;
  vector_t *vector;
  routebox_t *target;
  edge_t *local_f8;
  uint uVar12;
  int X1;
  int iVar13;
  int Y1;
  routebox_t *r;
  int iVar14;
  LocationType LVar15;
  PCBTypePtr pPVar16;
  int N;
  int CostPointY;
  BoxType *box;
  int iVar17;
  BoxType *pBVar18;
  byte bVar19;
  float10 fVar20;
  BDimension local_f0;
  Boolean local_ad;
  uint local_a0;
  routebox_t *local_8c;
  routebox_t *local_84;
  routeone_state s;
  BoxType b;
  routeone_via_site_state vss;
  CheapPointType nextpoint;
  CheapPointType lastpoint;
  vector_t *local_2c;
  vector_t *local_28;
  vector_t *local_24;
  rtree_t *local_20 [4];
  
  bVar19 = 0;
  local_100 = from;
  if (from != (routebox_t *)0x0) {
    do {
      target = (routebox_t *)(local_100->same_net).next;
      *(byte *)&local_100->flags = *(byte *)&local_100->flags | 0x10;
      r = from;
      local_100 = target;
    } while (from != target);
    do {
      local_100 = (routebox_t *)(r->same_subnet).next;
      if ((*(byte *)&r->flags & 1) == 0) {
        *(byte *)&r->flags = *(byte *)&r->flags | 4;
      }
      r = local_100;
    } while (target != local_100);
  }
  if (to == (routebox_t *)0x0) {
    if (from == (routebox_t *)0x0) goto LAB_0807249d;
    N = 0;
    local_100 = from;
    do {
      bVar10 = *(byte *)&local_100->flags;
      prVar5 = (local_100->same_net).next;
      if ((((bVar10 & 4) == 0) && (is_layer_group_active[local_100->group] != '\0')) &&
         ((bVar10 & 1) == 0)) {
        N = N + 1;
        *(byte *)&local_100->flags = bVar10 | 8;
      }
      local_100 = (routebox_t *)prVar5;
    } while (from != (routebox_t *)prVar5);
LAB_080721ae:
    if (N != 0) {
      boxlist = (BoxType **)calloc(1,N << 2);
      if (from == (routebox_t *)0x0) {
        local_20[0] = r_create_tree(boxlist,0,0);
        free(boxlist);
        local_24 = vector_create();
      }
      else {
        N = 0;
        local_100 = from;
        do {
          prVar5 = (local_100->same_net).next;
          if ((*(byte *)&local_100->flags & 8) != 0) {
            *(routebox_t **)(boxlist + N) = local_100;
            N = N + 1;
          }
          local_100 = (routebox_t *)prVar5;
        } while (from != (routebox_t *)prVar5);
        local_20[0] = r_create_tree(boxlist,N,0);
        free(boxlist);
        local_24 = vector_create();
        local_100 = from;
        do {
          prVar6 = (((routebox *)local_100)->same_subnet).next;
          pbVar1 = (byte *)&(((routebox *)local_100)->flags).field_0x1;
          *pbVar1 = *pbVar1 | 1;
          local_100 = (routebox_t *)prVar6;
          cl = prVar6;
        } while (prVar5 != prVar6);
        do {
          while ((prVar5 = (((routebox_t *)cl)->same_subnet).next,
                 (*(byte *)&((routebox_t *)cl)->flags & 4) == 0 ||
                 (is_layer_group_active[((routebox_t *)cl)->group] == '\0'))) {
            cl = prVar5;
            if (prVar6 == prVar5) goto LAB_0807236a;
          }
          N = (((routebox_t *)cl)->sbox).Y1;
          iVar11 = (((routebox_t *)cl)->sbox).X1;
          X1 = (((routebox_t *)cl)->sbox).Y2;
          Y1 = (((routebox_t *)cl)->sbox).X2;
          CostPointX = (Y1 - iVar11) / 2 + iVar11;
          CostPointY = (X1 - N) / 2 + N;
          search = CreateEdge((routebox_t *)cl,CostPointX,CostPointY,0.00000000,(routebox_t *)0x0,
                              ALL,local_20[0]);
          local_100 = search->mincost_target;
          iVar14 = (local_100->sbox).X1;
          if (CostPointX < iVar14) {
            CostPointX = (local_100->sbox).Y1;
          }
          else {
            iVar14 = CostPointX;
            if ((local_100->sbox).X2 <= CostPointX) {
              iVar14 = (local_100->sbox).X2 + -1;
            }
            CostPointX = (local_100->sbox).Y1;
          }
          if ((CostPointX <= CostPointY) &&
             (iVar17 = (local_100->sbox).Y2, CostPointX = CostPointY, iVar17 <= CostPointY)) {
            CostPointX = iVar17 + -1;
          }
          if ((iVar11 <= iVar14) && (iVar11 = Y1 + -1, iVar14 < Y1)) {
            iVar11 = iVar14;
          }
          if ((N <= CostPointX) && (N = CostPointX, X1 <= CostPointX)) {
            N = X1 + -1;
          }
          (search->cost_point).Y = N;
          (((routebox_t *)cl)->cost_point).Y = N;
          (search->cost_point).X = iVar11;
          (((routebox_t *)cl)->cost_point).X = iVar11;
          if (AutoRouteParameters.with_conflicts != '\0') {
            r_search(rd->layergrouptree[((routebox_t *)cl)->group],&((routebox_t *)cl)->sbox,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,__conflict_source,cl);
            touch_conflicts((vector_t *)0x0,1);
          }
          vector_append(local_24,search);
          cl = prVar5;
        } while (prVar6 != prVar5);
LAB_0807236a:
        do {
          prVar6 = (cl->same_subnet).next;
          pbVar1 = (byte *)&(cl->flags).field_0x1;
          *pbVar1 = *pbVar1 & 0xfe;
          cl = prVar6;
        } while (prVar5 != prVar6);
      }
      s.workheap = heap_create();
      while (N = vector_is_empty(local_24), N == 0) {
        data = vector_remove_last(local_24);
        fVar20 = (float10)edge_cost(data,0xc6ae9bc2,0x45d83bda);
        *(double *)((int)data + 0x14) = (double)fVar20;
        heap_insert(s.workheap,(cost_t)(double)fVar20,data);
      }
      vector_destroy(&local_24);
      s.best_path = (routebox_t *)0x0;
      s.best_cost = 30000000000000000948382466048.00000000;
      area_vec = vector_create();
      local_28 = vector_create();
      vss.free_space_vec = vector_create();
      vss.lo_conflict_space_vec = vector_create();
      vss.hi_conflict_space_vec = vector_create();
      N = 0;
      while (iVar11 = heap_is_empty(s.workheap), iVar11 == 0) {
        search = (edge_t *)heap_remove_smallest(s.workheap);
        if ((s.best_path == (routebox_t *)0x0) || ((double)search->cost < (double)s.best_cost)) {
          iVar11 = N + 1;
          if (N <= max_edges) {
            touch_conflicts(search->rb->conflicts_with,1);
            bVar10 = *(byte *)&search->flags;
            if ((bVar10 & 0x10) == 0) {
              local_100 = search->rb;
              if ((local_100->flags).is_thermal == 0) {
                if (local_100->type == PLANE) {
                  local_100 = FindThermable(local_20[0],local_100);
                  if (local_100 == (routebox_t *)0x0) {
                    if ((AutoRouteParameters.use_vias != '\0') &&
                       ((double)search->cost + (double)AutoRouteParameters.ViaCost <
                        (double)s.best_cost)) {
                      local_100 = search->rb;
                      local_100 = CreateExpansionArea(&local_100->sbox,(uint)local_100->group,
                                                      local_100,'\x01',search);
                      local_f8 = CreateEdge2(local_100,search->expand_dir,search,
                                             search->mincost_target);
                      (local_100->flags).is_thermal = 1;
                      in_plane = '\x01';
                      local_f0 = search->rb->style->Diameter;
                      goto LAB_080726cd;
                    }
                  }
                  else {
                    b.X1 = (local_100->sbox).X1;
                    b.Y1 = (local_100->sbox).Y1;
                    b.X2 = (local_100->sbox).X2;
                    b.Y2 = (local_100->sbox).Y2;
                    target = CreateExpansionArea(&b,(uint)search->rb->group,search->rb,'\x01',search
                                                );
                    (target->flags).is_thermal = 1;
                    (search->cost_point).X = b.X1;
                    (search->cost_point).Y = b.Y1;
                    local_f8 = CreateEdge2(target,search->expand_dir,search,local_100);
                    best_path_candidate(&s,local_f8,local_100);
                    KillEdge(local_f8);
                  }
                }
                else {
                  if ((bVar10 & 1) != 0) {
                    local_100 = FindOneInBox(rd->layergrouptree[local_100->group],local_100);
                    if (local_100 != (routebox_t *)0x0) {
                      if (((*(byte *)&local_100->flags & 8) != 0) && (local_100->type == PLANE)) {
                        target = search->rb;
                        N = 4;
                        uVar4 = target->group;
                        box = &target->sbox;
                        pBVar18 = &b;
                        while (N != 0) {
                          N = N + -1;
                          pBVar18->X1 = box->X1;
                          box = (BoxType *)((int)box + (uint)bVar19 * -8 + 4);
                          pBVar18 = (BoxType *)((int)pBVar18 + (uint)bVar19 * -8 + 4);
                        }
                        target = CreateExpansionArea(&b,(uint)uVar4,target,'\x01',search);
                        expand_dir = search->expand_dir;
                        (target->flags).is_thermal = 1;
                        local_f8 = CreateEdge2(target,expand_dir,search,local_100);
                        best_path_candidate(&s,local_f8,local_100);
                        KillEdge(local_f8);
                      }
                      goto LAB_0807242a;
                    }
                    r_insert_entry(rd->layergrouptree[*(ushort *)(&search->rb->parent + 1)],
                                   (BoxType *)search->rb,1);
                    paVar3 = &search->rb->flags;
                    *(byte *)paVar3 = *(byte *)paVar3 & 0xbf;
                    vector_append(area_vec,search->rb);
                    local_100 = search->rb;
                    local_100->refcount = 0;
                    bVar10 = *(byte *)&search->flags;
                  }
                  if ((bVar10 & 8) == 0) {
                    if ((*(byte *)&local_100->flags & 4) == 0) {
                      b.X1 = (local_100->sbox).X1;
                      b.Y1 = (local_100->sbox).Y1;
                      b.X2 = (local_100->sbox).X2;
                      b.Y2 = (local_100->sbox).Y2;
                    }
                    else {
                      N = (local_100->sbox).X1;
                      X1 = (local_100->sbox).Y1;
                      b.X1 = ((local_100->sbox).X2 - N) / 2 + N;
                      b.X2 = b.X1 + 1;
                      b.Y1 = ((local_100->sbox).Y2 - X1) / 2 + X1;
                      b.Y2 = b.Y1 + 1;
                    }
                  }
                  else {
                    b.X1 = (local_100->sbox).X1;
                    b.Y1 = (local_100->sbox).Y1;
                    b.X2 = (local_100->sbox).X2;
                    b.Y2 = (local_100->sbox).Y2;
                    expand_dir = local_100->came_from;
                    if (expand_dir == EAST) {
                      b.X1 = b.X2 + -1;
LAB_08072974:
                      b.Y1 = (b.Y2 - b.Y1) / 2 + b.Y1;
                      b.Y2 = b.Y1 + 1;
                    }
                    else {
                      if (expand_dir == NORTH) {
                        b.Y2 = b.Y1 + 1;
                      }
                      else {
                        if (expand_dir != SOUTH) {
                          if (expand_dir != WEST) goto LAB_08072551;
                          b.X2 = b.X1 + 1;
                          goto LAB_08072974;
                        }
                        b.Y1 = b.Y2 + -1;
                      }
                      b.X1 = (b.X2 - b.X1) / 2 + b.X1;
                      b.X2 = b.X1 + 1;
                    }
                  }
LAB_08072551:
                  ans = Expand(rd->layergrouptree[local_100->group],search,&b);
                  N = (ans->inflated).X1;
                  if (((((N < (ans->orig).X2) && (X1 = (ans->inflated).X2, (ans->orig).X1 < X1)) &&
                       (Y1 = (ans->inflated).Y1, Y1 < (ans->orig).Y2)) &&
                      ((iVar14 = (ans->inflated).Y2, (ans->orig).Y1 < iVar14 && (N < X1)))) &&
                     (Y1 < iVar14)) {
                    local_100 = CreateExpansionArea(&ans->inflated,(uint)search->rb->group,
                                                    search->rb,'\x01',search);
                    r_insert_entry(rd->layergrouptree[local_100->group],(BoxType *)local_100,1);
                    vector_append(area_vec,local_100);
                    *(byte *)&local_100->flags = *(byte *)&local_100->flags & 0xbf;
                    local_2c = BreakManyEdges(&s,local_20[0],rd->layergrouptree[local_100->group],
                                              area_vec,ans,local_100,search);
                    while (N = vector_is_empty(local_2c), N == 0) {
                      local_f8 = (edge_t *)vector_remove_last(local_2c);
                      add_or_destroy_edge(&s,local_f8);
                    }
                    vector_destroy(&local_2c);
                    if (((AutoRouteParameters.use_vias != '\0') &&
                        ((*(byte *)&(search->rb->flags).field_0x1 & 4) == 0)) &&
                       ((double)search->cost + (double)AutoRouteParameters.ViaCost <
                        (double)s.best_cost)) {
                      in_plane = '\0';
                      local_f0 = 0;
                      local_f8 = search;
LAB_080726cd:
                      add_via_sites(&s,&vss,rd->mtspace,local_100,NO_CONFLICT,local_f8,local_20[0],
                                    local_f0,in_plane);
                    }
                  }
                }
              }
              else {
                best_path_candidate(&s,search,search->mincost_target);
              }
            }
            else {
              do_via_search(search,&s,&vss,rd->mtspace,local_20[0]);
            }
          }
        }
        else {
          heap_free(s.workheap,KillEdge);
          iVar11 = N;
        }
LAB_0807242a:
        KillEdge(search);
        N = iVar11;
      }
      touch_conflicts((vector_t *)0x0,1);
      heap_destroy((heap_t **)&s);
      r_destroy_tree(local_20);
      vector_destroy(&local_28);
      cVar9 = s.best_cost;
      if (s.best_path == (routebox_t *)0x0) {
        in_plane = '\0';
        local_a0 = 0;
        goto LAB_080727ac;
      }
      if (AutoRouteParameters.with_conflicts == '\0') {
LAB_08072746:
        local_a0 = 0;
      }
      else {
        vector = (s.best_path)->conflicts_with;
        local_a0 = 0;
        if (vector == (vector_t *)0x0) goto LAB_08072746;
        while( true ) {
          N = vector_is_empty(vector);
          if (N != 0) break;
          data = vector_remove_last((s.best_path)->conflicts_with);
          *(byte *)((int)data + 0x2d) = *(byte *)((int)data + 0x2d) | 0x20;
          vector = (s.best_path)->conflicts_with;
          local_a0 = local_a0 + 1;
        }
      }
      local_100 = s.best_target;
      local_84 = s.best_path;
      in_plane = '\0';
      if ((int)local_a0 < AutoRouteParameters.hi_conflict) {
        iVar11 = ((AutoRouteParameters.style)->Diameter + 1) / 2;
        N = ((AutoRouteParameters.style)->Thick + 1) / 2;
        if (((s.best_path)->flags).is_thermal == 0) {
          X1 = ((s.best_target)->sbox).X1;
          lastpoint.X = (((s.best_target)->sbox).X2 - X1) / 2 + X1;
          X1 = ((s.best_target)->sbox).Y1;
          lastpoint.Y = (((s.best_target)->sbox).Y2 - X1) / 2 + X1;
          TargetPoint(&lastpoint,s.best_target);
          if ((((AutoRouteParameters.last_smooth != '\0') &&
               ((local_84->sbox).X1 <= (local_100->sbox).X1)) &&
              ((local_100->sbox).X2 <= (local_84->sbox).X2)) &&
             (((local_84->sbox).Y1 <= (local_100->sbox).Y1 &&
              ((local_100->sbox).Y2 <= (local_84->sbox).Y2)))) {
            local_84 = (routebox_t *)local_84->parent;
          }
          b.X1 = (local_84->sbox).X1;
          b.Y1 = (local_84->sbox).Y1;
          b.X2 = (local_84->sbox).X2;
          b.Y2 = (local_84->sbox).Y2;
          if ((*(byte *)&local_84->flags & 0x20) != 0) {
            X1 = b.Y2 - b.Y1;
            if (b.X2 - b.X1 <= b.Y2 - b.Y1) {
              X1 = b.X2 - b.X1;
            }
            X1 = X1 / 5;
            b.X1 = X1 + b.X1;
            b.Y1 = b.Y1 + X1;
            b.X2 = b.X2 - X1;
            b.Y2 = b.Y2 - X1;
          }
          nextpoint.X = b.X1;
          if ((b.X1 <= lastpoint.X) && (nextpoint.X = b.X2 + -1, lastpoint.X < b.X2)) {
            nextpoint.X = lastpoint.X;
          }
          nextpoint.Y = b.Y1;
          if ((b.Y1 <= lastpoint.Y) && (nextpoint.Y = b.Y2 + -1, lastpoint.Y < b.Y2)) {
            nextpoint.Y = lastpoint.Y;
          }
          if (AutoRouteParameters.last_smooth == '\0') {
            local_ad = RD_DrawManhattanLine
                                 (rd,&local_100->sbox,&local_84->sbox,
                                  (CheapPointType)CONCAT44(lastpoint.Y,lastpoint.X),
                                  (CheapPointType)CONCAT44(nextpoint.Y,nextpoint.X),N,
                                  (uint)local_84->group,from,(Boolean)local_a0,'\0');
          }
          else {
            RD_DrawLine(rd,lastpoint.X,lastpoint.Y,nextpoint.X,nextpoint.Y,N,(uint)local_84->group,
                        from,(Boolean)local_a0,'\x01');
            local_ad = '\0';
          }
        }
        else {
          X1 = ((s.best_path)->sbox).X1;
          nextpoint.X = (((s.best_path)->sbox).X2 - X1) / 2 + X1;
          X1 = ((s.best_path)->sbox).Y1;
          nextpoint.Y = (((s.best_path)->sbox).Y2 - X1) / 2 + X1;
          local_100 = (routebox_t *)(s.best_path)->parent;
          if ((*(byte *)&(local_100->flags).field_0x1 & 4) == 0) {
            TargetPoint(&nextpoint,s.best_target);
            LVar15 = nextpoint.Y;
          }
          else {
            target = s.best_path;
            if ((*(byte *)&(s.best_path)->flags & 4) == 0) {
              while ((target = local_100, local_100 != (routebox_t *)0x0 &&
                     ((*(byte *)&local_100->flags & 4) == 0))) {
                local_100 = (routebox_t *)local_100->parent;
              }
            }
            TargetPoint(&nextpoint,target);
            X1 = local_84->parent;
            b.X1 = *(int *)(X1 + 0x10);
            b.X2 = *(int *)(X1 + 0x18);
            if (b.X1 <= (local_84->sbox).X1) {
              b.X1 = (local_84->sbox).X1;
            }
            piVar2 = &(local_84->sbox).X2;
            if (*piVar2 == b.X2 || *piVar2 < b.X2) {
              b.X2 = (local_84->sbox).X2;
            }
            b.Y1 = *(int *)(X1 + 0x14);
            b.Y2 = *(int *)(X1 + 0x1c);
            if (b.Y1 <= (local_84->sbox).Y1) {
              b.Y1 = (local_84->sbox).Y1;
            }
            piVar2 = &(local_84->sbox).Y2;
            if (*piVar2 == b.Y2 || *piVar2 < b.Y2) {
              b.Y2 = (local_84->sbox).Y2;
            }
            LVar15 = b.X1;
            if ((b.X1 <= nextpoint.X) && (LVar15 = nextpoint.X, b.X2 <= nextpoint.X)) {
              LVar15 = b.X2 + -1;
            }
            nextpoint.X = LVar15;
            LVar15 = b.Y1;
            if ((b.Y1 <= nextpoint.Y) && (LVar15 = nextpoint.Y, b.Y2 <= nextpoint.Y)) {
              LVar15 = b.Y2 + -1;
            }
          }
          nextpoint.Y = LVar15;
          RD_DrawThermal(rd,nextpoint.X,nextpoint.Y,(uint)local_84->group,(uint)local_84->layer,from
                         ,(Boolean)local_a0);
          local_ad = '\0';
        }
        do {
          lastpoint.X = nextpoint.X;
          lastpoint.Y = nextpoint.Y;
          local_100 = (routebox_t *)local_84->parent;
          b.X1 = (local_100->sbox).X1;
          b.Y1 = (local_100->sbox).Y1;
          b.X2 = (local_100->sbox).X2;
          b.Y2 = (local_100->sbox).Y2;
          if ((*(byte *)&local_100->flags & 0x20) != 0) {
            X1 = b.X2 - b.X1;
            if (b.Y2 - b.Y1 < b.X2 - b.X1) {
              X1 = b.Y2 - b.Y1;
            }
            X1 = X1 / 5;
            b.X1 = X1 + b.X1;
            b.X2 = b.X2 - X1;
            b.Y1 = X1 + b.Y1;
            b.Y2 = b.Y2 - X1;
          }
          X1 = b.X1;
          if ((b.X1 <= nextpoint.X) && (X1 = nextpoint.X, b.X2 <= nextpoint.X)) {
            X1 = b.X2 + -1;
          }
          nextpoint.X = X1;
          X1 = b.Y1;
          if ((b.Y1 <= nextpoint.Y) && (X1 = nextpoint.Y, b.Y2 <= nextpoint.Y)) {
            X1 = b.Y2 + -1;
          }
          nextpoint.Y = X1;
          if (((*(byte *)&local_100->flags & 4) != 0) && (local_100->type != PLANE)) {
            TargetPoint(&nextpoint,local_100);
          }
          if (AutoRouteParameters.last_smooth == '\0') {
            local_ad = RD_DrawManhattanLine
                                 (rd,&local_84->sbox,&local_100->sbox,
                                  (CheapPointType)CONCAT44(lastpoint.Y,lastpoint.X),
                                  (CheapPointType)CONCAT44(nextpoint.Y,nextpoint.X),N,
                                  (uint)local_100->group,from,(Boolean)local_a0,local_ad);
            bVar10 = *(byte *)&(local_100->flags).field_0x1;
            pPVar16 = PCB;
            X1 = nextpoint.X;
            Y1 = nextpoint.Y;
          }
          else {
            RD_DrawLine(rd,lastpoint.X,lastpoint.Y,nextpoint.X,nextpoint.Y,N,(uint)local_100->group,
                        from,(Boolean)local_a0,'\x01');
            bVar10 = *(byte *)&(local_100->flags).field_0x1;
            pPVar16 = PCB;
            X1 = nextpoint.X;
            Y1 = nextpoint.Y;
          }
          PCB = pPVar16;
          nextpoint.X = X1;
          nextpoint.Y = Y1;
          if (((bVar10 & 4) != 0) &&
             (iVar14 = (AutoRouteParameters.style)->Keepaway, 0 < pPVar16->Data->LayerN)) {
            iVar17 = 0;
            local_8c = (routebox_t *)0x0;
            CostPointX = Y1 + 1 + iVar11;
            CostPointY = X1 + 1 + iVar11;
            do {
              if (is_layer_group_active[iVar17] != '\0') {
                r = (routebox_t *)calloc(1,0x7c);
                iVar13 = 0x1f;
                target = r;
                while (iVar13 != 0) {
                  iVar13 = iVar13 + -1;
                  (target->box).X1 = 0;
                  target = (routebox_t *)((int)target + (uint)bVar19 * -8 + 4);
                }
                r->group = (ushort)iVar17;
                (r->sbox).Y1 = Y1 - iVar11;
                (r->sbox).X1 = X1 - iVar11;
                (r->box).X1 = (X1 - iVar11) - iVar14;
                (r->sbox).X2 = CostPointY;
                (r->box).Y1 = (Y1 - iVar11) - iVar14;
                (r->sbox).Y2 = CostPointX;
                (r->box).X2 = CostPointY + iVar14;
                (r->box).Y2 = CostPointX + iVar14;
                uVar12 = (uint)(byte)AutoRouteParameters.is_odd;
                *(byte *)&(r->flags).field_0x1 = (byte)((local_a0 & 1) << 5) | 0x40;
                r->came_from = ALL;
                *(byte *)&r->flags = (byte)(uVar12 << 7) | 0x20;
                pRVar8 = AutoRouteParameters.style;
                r->style = AutoRouteParameters.style;
                r->pass = AutoRouteParameters.pass;
                if (local_8c == (routebox_t *)0x0) {
                  r->parent = 0;
                  local_f0 = pRVar8->Keepaway;
                  r->type = VIA;
                  mtspace_add(rd->mtspace,(BoxType *)r,~-(uint)((uVar12 << 7 & 0x80) == 0) + EVEN,
                              local_f0);
                  local_8c = r;
                }
                else {
                  r->type = VIA_SHADOW;
                  *(routebox_t **)&r->parent = local_8c;
                }
                InitLists(r);
                MergeNets(r,from,NET);
                MergeNets(r,from,SUBNET);
                r_insert_entry(rd->layergrouptree[r->group],(BoxType *)r,1);
                *(byte *)&r->flags = *(byte *)&r->flags & 0xbf;
                pPVar16 = PCB;
                if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
                  (*gui->set_color)(ar_gc,PCB->ViaColor);
                  (*gui->fill_circle)(ar_gc,X1,Y1,iVar11);
                  pPVar16 = PCB;
                }
              }
              iVar17 = iVar17 + 1;
            } while (iVar17 < pPVar16->Data->LayerN);
          }
          if (((local_100->flags).is_thermal != 0) || (aVar7 = local_100->type, aVar7 == PLANE)) {
            RD_DrawThermal(rd,lastpoint.X,lastpoint.Y,(uint)local_100->group,(uint)local_100->layer,
                           from,(Boolean)local_a0);
            aVar7 = local_100->type;
          }
          if ((((aVar7 == HID_Mixed) &&
               (target = (routebox_t *)local_100->parent, (*(byte *)&target->flags & 4) != 0)) &&
              (target->type != PLANE)) &&
             (in_plane = TargetPoint(&lastpoint,target), in_plane != '\0')) {
            X1 = (local_100->sbox).X1;
            if ((X1 <= lastpoint.X) &&
               (Y1 = (local_100->sbox).X2, X1 = lastpoint.X, Y1 <= lastpoint.X)) {
              X1 = Y1 + -1;
            }
            Y1 = (local_100->sbox).Y1;
            if ((Y1 <= lastpoint.Y) &&
               (iVar14 = (local_100->sbox).Y2, Y1 = lastpoint.Y, iVar14 <= lastpoint.Y)) {
              Y1 = iVar14 + -1;
            }
            b.X2 = (local_100->sbox).X2;
            b.Y1 = (local_100->sbox).Y1;
            b.X1 = (local_100->sbox).X1;
            b.Y2 = (local_100->sbox).Y2;
            lastpoint.X = X1;
            lastpoint.Y = Y1;
            if (AutoRouteParameters.last_smooth == '\0') {
              local_ad = RD_DrawManhattanLine
                                   (rd,&b,&b,(CheapPointType)CONCAT44(nextpoint.Y,nextpoint.X),
                                    (CheapPointType)CONCAT44(Y1,X1),N,(uint)local_100->group,from,
                                    (Boolean)local_a0,local_ad);
            }
            else {
              RD_DrawLine(rd,X1,Y1,nextpoint.X,nextpoint.Y,N,(uint)local_100->group,from,
                          (Boolean)local_a0,'\x01');
            }
            nextpoint.X = lastpoint.X;
            nextpoint.Y = lastpoint.Y;
          }
          local_84 = local_100;
        } while ((*(byte *)&local_100->flags & 4) == 0);
        RD_DrawLine(rd,-1,0,0,0,0,0,(routebox_t *)0x0,'\0','\0');
        if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
          (*gui->use_mask)(6);
        }
        in_plane = '\x01';
        MergeNets(from,s.best_target,SUBNET);
      }
LAB_080727ac:
      while (N = vector_is_empty(area_vec), N == 0) {
        box = (BoxType *)vector_remove_last(area_vec);
        if ((box[4].X2 != 0) && (box[4].X2 != *(int *)(box[2].X1 + 0x48))) {
          vector_destroy((vector_t **)&box[4].X2);
        }
        r_delete_entry(rd->layergrouptree[*(ushort *)&box[2].Y1],box);
      }
      vector_destroy(&area_vec);
      local_100 = from;
      if (from != (routebox_t *)0x0) {
        do {
          bVar19 = *(byte *)&local_100->flags;
          target = (routebox_t *)(local_100->same_net).next;
          if (((bVar19 & 4) != 0) && (local_100->conflicts_with != (vector_t *)0x0)) {
            vector_destroy(&local_100->conflicts_with);
            bVar19 = *(byte *)&local_100->flags;
          }
          pbVar1 = (byte *)&(local_100->flags).field_0x1;
          *pbVar1 = *pbVar1 & 0xfe;
          *(byte *)&local_100->flags = bVar19 & 0xe3;
          local_100 = target;
        } while (from != target);
      }
      vector_destroy((vector_t **)&vss);
      vector_destroy(&vss.lo_conflict_space_vec);
      vector_destroy(&vss.hi_conflict_space_vec);
      __return_storage_ptr__->net_completely_routed = '\0';
      __return_storage_ptr__->best_route_cost = cVar9;
      __return_storage_ptr__->found_route = in_plane;
      __return_storage_ptr__->route_had_conflicts = local_a0;
      return __return_storage_ptr__;
    }
  }
  else {
    bVar10 = *(byte *)&to->flags;
    if ((bVar10 & 4) == 0) {
      N = 0;
      local_100 = to;
      while( true ) {
        prVar5 = (local_100->same_subnet).next;
        if (((bVar10 & 1) == 0) && (is_layer_group_active[local_100->group] != '\0')) {
          *(byte *)&local_100->flags = *(byte *)&local_100->flags | 8;
          N = N + 1;
        }
        if (to == (routebox_t *)prVar5) break;
        bVar10 = *(byte *)&prVar5->flags;
        local_100 = (routebox_t *)prVar5;
      }
      goto LAB_080721ae;
    }
  }
  local_100 = from;
  if (from != (routebox_t *)0x0) {
    do {
      target = (routebox_t *)(local_100->same_net).next;
      *(byte *)&local_100->flags = *(byte *)&local_100->flags & 0xe3;
      local_100 = target;
    } while (from != target);
  }
LAB_0807249d:
  __return_storage_ptr__->best_route_cost = 0.00000000;
  __return_storage_ptr__->net_completely_routed = '\x01';
  __return_storage_ptr__->found_route = '\0';
  __return_storage_ptr__->route_had_conflicts = 0;
  return __return_storage_ptr__;
}



routeall_status * RouteAll(routeall_status *__return_storage_ptr__,routedata_t *rd)

{
  byte *pbVar1;
  int iVar2;
  routebox *prVar3;
  routebox *prVar4;
  float fVar5;
  bool bVar6;
  anon_struct_for_flags *paVar7;
  heap_t *phVar8;
  heap_t *phVar9;
  int iVar10;
  routebox *a;
  routebox *data;
  routebox *data_00;
  routebox_t *from;
  routebox_t *prVar11;
  int iVar12;
  routebox *data_01;
  int iVar13;
  int iVar14;
  Boolean BVar15;
  int local_74;
  int local_70;
  int local_6c;
  int local_68;
  int local_64;
  int local_60;
  LocationType local_5c;
  routebox_t *local_58;
  LocationType local_54;
  LocationType local_50;
  double local_4c;
  routeone_status ros;
  heap_t *local_28;
  heap_t *local_24;
  heap_t *local_20 [4];
  
  local_24 = heap_create();
  local_28 = heap_create();
  local_20[0] = heap_create();
  local_58 = rd->first_net;
  if (rd->first_net != (routebox_t *)0x0) {
    do {
      data_01 = (local_58->different_net).next;
      iVar10 = (local_58->sbox).Y2;
      iVar13 = (local_58->sbox).X2;
      iVar12 = (local_58->sbox).Y1;
      iVar14 = (local_58->sbox).X1;
      data_00 = (routebox *)local_58;
      local_5c = iVar14;
      local_54 = iVar10;
      local_50 = iVar13;
      iVar2 = iVar12;
      while( true ) {
        data_00 = (((routebox_t *)data_00)->same_net).next;
        if (local_5c < iVar14) {
          iVar14 = local_5c;
        }
        if (iVar2 < iVar12) {
          iVar12 = iVar2;
        }
        if (iVar13 < local_50) {
          iVar13 = local_50;
        }
        if (iVar10 < local_54) {
          iVar10 = local_54;
        }
        if (data_00 == (routebox *)local_58) break;
        local_5c = (data_00->sbox).X1;
        iVar2 = (data_00->sbox).Y1;
        local_50 = (data_00->sbox).X2;
        local_54 = (data_00->sbox).Y2;
      }
      heap_insert(local_24,(cost_t)((double)(iVar10 - iVar12) * (double)(iVar13 - iVar14)),local_58)
      ;
      local_58 = (routebox_t *)data_01;
    } while (data_01 != (routebox *)rd->first_net);
  }
  local_60 = 0;
  local_58 = (routebox_t *)0x0;
  phVar8 = local_28;
  phVar9 = local_24;
LAB_080737e8:
  do {
    local_24 = phVar9;
    local_28 = phVar8;
    local_70 = 0;
    local_74 = 0;
    local_50 = 0;
    local_54 = 0;
    local_64 = 0;
    iVar10 = heap_is_empty(local_24);
    while (iVar10 == 0) {
      data_00 = (routebox *)heap_remove_smallest(local_24);
      InitAutoRouteParameters(local_60,data_00->style,local_60 < 0xc,0xc < local_60,local_60 == 0xd)
      ;
      data_01 = data_00;
      if (local_60 == 0) {
LAB_080739d8:
        do {
          data_01 = (data_01->same_net).next;
          data = data_01;
        } while (data_00 != data_01);
        do {
          data_00 = (data->same_net).next;
          a = data;
          if ((*(byte *)&(data->flags).field_0x1 & 2) == 0) {
            do {
              prVar3 = (a->same_subnet).next;
              pbVar1 = (byte *)&(a->flags).field_0x1;
              *pbVar1 = *pbVar1 | 2;
              a = prVar3;
            } while (prVar3 != data);
            local_64 = local_64 + 1;
          }
          data = data_00;
        } while (data_01 != data_00);
        do {
          data_01 = (data->same_net).next;
          pbVar1 = (byte *)&(data->flags).field_0x1;
          *pbVar1 = *pbVar1 & 0xfd;
          data = data_01;
        } while (data_00 != data_01);
        local_64 = local_64 + -1;
        data_00 = data_01;
        if (local_64 == 0) {
          heap_insert(local_28,0.00000000,data_01);
        }
        else {
          do {
            data = (data_00->same_net).next;
            if (data_00->type == PLANE) {
              fVar5 = -1.00000000;
            }
            else {
              fVar5 = 10.00000000;
              if (data_00->type == SHIFT) {
                fVar5 = 1.00000000;
              }
            }
            heap_insert(local_20[0],
                        (cost_t)(double)((float)((data_00->sbox).Y2 - (data_00->sbox).Y1) *
                                         (float)((data_00->sbox).X2 - (data_00->sbox).X1) * fVar5),
                        data_00);
            data_00 = data;
          } while (data_01 != data);
          local_4c = 0.00000000;
          BVar15 = '\0';
LAB_08073bb8:
          iVar10 = heap_is_empty(local_20[0]);
          if (iVar10 == 0) {
LAB_08073bcb:
            from = (routebox_t *)heap_remove_smallest(local_20[0]);
            if ((((*(ushort *)&from->flags & 0x202) == 2) && (from->type != OTHER)) &&
               (BVar15 == '\0')) {
              while( true ) {
                RouteOne(&ros,rd,from,(routebox_t *)0x0,
                         routing_layers * (local_60 + 1) *
                         ((-(uint)(AutoRouteParameters.is_smoothing == '\0') & 0xfffffb50) + 2000));
                BVar15 = ros.net_completely_routed;
                local_4c = local_4c + (double)ros.best_route_cost;
                if (ros.found_route == '\0') break;
                if (ros.route_had_conflicts == 0) {
                  local_54 = local_54 + 1;
                  local_58 = (routebox_t *)((int)local_58 + 1);
                }
                else {
                  local_50 = local_50 + 1;
                }
                if (ros.net_completely_routed != '\0') goto LAB_08073c64;
              }
              local_74 = local_74 + (uint)(ros.net_completely_routed == '\0');
              prVar11 = from;
              do {
                data_00 = (prVar11->same_subnet).next;
                pbVar1 = (byte *)&(prVar11->flags).field_0x1;
                *pbVar1 = *pbVar1 | 2;
                prVar11 = (routebox_t *)data_00;
              } while (data_00 != (routebox *)from);
            }
            goto LAB_08073bb8;
          }
LAB_08073c80:
          if (BVar15 == '\0') {
            pbVar1 = (byte *)&(data->flags).field_0x1;
            *pbVar1 = *pbVar1 | 0x20;
          }
          heap_insert(local_28,(cost_t)local_4c,data);
          data_00 = data_01;
        }
        do {
          data = (data_00->same_net).next;
          pbVar1 = (byte *)&(data_00->flags).field_0x1;
          *pbVar1 = *pbVar1 & 0xfd;
          data_00 = data;
        } while (data_01 != data);
      }
      else {
        data = data_00;
        a = data_00;
        if (AutoRouteParameters.rip_always == '\0') {
          do {
            paVar7 = &data->flags;
            data = (data->same_net).next;
            if ((*(byte *)&paVar7->field_0x1 & 0x20) != 0) goto LAB_08073893;
          } while (data_00 != data);
          bVar6 = false;
        }
        else {
LAB_08073893:
          bVar6 = true;
        }
        do {
          pbVar1 = (byte *)&(((routebox_t *)a)->flags).field_0x1;
          *pbVar1 = *pbVar1 & 0xdf;
          data = (((routebox_t *)a)->same_net).next;
          if ((*(byte *)&((routebox_t *)a)->flags & 2) == 0) {
            if (bVar6) {
              RemoveFromNet((routebox_t *)a,NET);
              RemoveFromNet((routebox_t *)a,SUBNET);
            }
            if (((AutoRouteParameters.use_vias == '\0') || (((routebox_t *)a)->type == VIA_SHADOW))
               || (((routebox_t *)a)->type == PLANE)) {
              if (!bVar6) goto LAB_08073919;
            }
            else {
              mtspace_remove(rd->mtspace,(BoxType *)a,
                             ~-(uint)((*(byte *)&((routebox_t *)a)->flags & 0x80) == 0) + EVEN,
                             ((routebox_t *)a)->style->Keepaway);
              if (!bVar6) {
                mtspace_add(rd->mtspace,(BoxType *)a,
                            EVEN - (uint)((*(byte *)&((routebox_t *)a)->flags & 0x80) == 0),
                            ((routebox_t *)a)->style->Keepaway);
LAB_08073919:
                *(byte *)&((routebox_t *)a)->flags =
                     *(byte *)&((routebox_t *)a)->flags & 0x7f | AutoRouteParameters.is_odd << 7;
                goto joined_r0x08073931;
              }
            }
            if (((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) &&
               ((((routebox_t *)a)->type == VIA || (((routebox_t *)a)->type == LINE)))) {
              local_6c = (((routebox_t *)a)->box).X1;
              iVar10 = (((routebox_t *)a)->box).X2;
              iVar13 = (((routebox_t *)a)->box).Y1;
              iVar12 = iVar10 - local_6c;
              local_68 = (((routebox_t *)a)->box).Y2;
              iVar14 = local_68 - iVar13;
              if (iVar12 < iVar14) {
                local_6c = (local_6c + iVar10) / 2;
                iVar13 = iVar13 + iVar12 / 2;
                local_68 = local_68 - iVar12 / 2;
                local_5c = local_6c;
              }
              else {
                iVar13 = (iVar13 + local_68) / 2;
                local_6c = local_6c + iVar14 / 2;
                local_5c = iVar10 - iVar14 / 2;
                iVar12 = iVar14;
                local_68 = iVar13;
              }
              (*gui->set_line_width)(ar_gc,iVar12);
              (*gui->set_color)(ar_gc,Settings.BackgroundColor);
              (*gui->draw_line)(ar_gc,local_6c,iVar13,local_5c,local_68);
            }
            r_delete_entry(rd->layergrouptree[((routebox_t *)a)->group],(BoxType *)a);
          }
joined_r0x08073931:
          a = data;
        } while (data_00 != data);
        if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
          (*gui->use_mask)(6);
        }
        if (bVar6) {
          do {
            prVar3 = (a->same_net).next;
            prVar4 = (a->original_subnet).prev;
            (a->same_subnet).next = (a->original_subnet).next;
            (a->same_subnet).prev = prVar4;
            a = prVar3;
          } while (data != prVar3);
          local_70 = local_70 + 1;
          goto LAB_080739d8;
        }
        heap_insert(local_28,0.00000000,data);
      }
      iVar10 = heap_is_empty(local_24);
    }
    ro = 0;
    phVar8 = local_24;
    if ((local_50 == 0) && (local_64 == local_54)) {
      if (local_60 == 0xd) goto LAB_08073b37;
      local_60 = 0xd;
      phVar9 = local_28;
      goto LAB_080737e8;
    }
    local_60 = local_60 + 1;
    phVar9 = local_28;
    if (local_60 == 0xe) {
LAB_08073b37:
      phVar8 = local_28;
      local_28 = local_24;
      local_24 = phVar8;
      Message("%d of %d nets successfully routed.\n",local_54,local_64);
      heap_destroy(&local_24);
      heap_destroy(&local_28);
      heap_destroy(local_20);
      __return_storage_ptr__->total_subnets = local_64;
      __return_storage_ptr__->routed_subnets = local_54;
      __return_storage_ptr__->conflict_subnets = local_50;
      __return_storage_ptr__->failed = local_74;
      __return_storage_ptr__->ripped = local_70;
      *(routebox_t **)&__return_storage_ptr__->total_nets_routed = local_58;
      return __return_storage_ptr__;
    }
  } while( true );
LAB_08073c64:
  iVar10 = heap_is_empty(local_20[0]);
  if (iVar10 != 0) goto LAB_08073c80;
  goto LAB_08073bcb;
}



Boolean AutoRoute(Boolean selected)

{
  BoxType **ppBVar1;
  byte *pbVar2;
  LocationType *parent;
  uint *puVar3;
  routebox *prVar4;
  routebox *prVar5;
  routebox_t *prVar6;
  BoxType *box;
  Cardinal *pCVar7;
  PCBTypePtr pPVar8;
  uint uVar9;
  Cardinal CVar10;
  int *piVar11;
  int iVar12;
  Cardinal layer;
  rtree_t *prVar13;
  routebox *prVar14;
  routebox *prVar15;
  DataTypePtr *pDVar16;
  routebox_t *to;
  uint uVar17;
  mtspace_t *pmVar18;
  Boolean is_via;
  PadTypePtr *line;
  PolygonTypePtr polygon;
  PadTypePtr *pad;
  PinTypePtr *pin;
  routebox_t *prVar19;
  int iVar20;
  int *piVar21;
  int iVar22;
  uint uVar23;
  LineTypePtr line_00;
  undefined *puVar24;
  FlagType *pFVar25;
  routebox *prVar26;
  ElementTypePtr *element;
  RatTypePtr *pRVar27;
  int layergroup;
  NetListListType *pNVar28;
  routebox_t *a;
  LineTypePtr pLVar29;
  PointerListType *list;
  routebox *prVar30;
  routebox *prVar31;
  routedata_t *prVar32;
  NetListListType *pNVar33;
  LineType *pLVar34;
  uint uVar35;
  int in_GS_OFFSET;
  bool bVar36;
  byte bVar37;
  RouteStyleType *style;
  routebox_t *local_1d8;
  undefined *local_1cc;
  int local_1c8;
  int local_1c0;
  int local_1bc;
  Cardinal local_1b0;
  routebox_t *local_1a8;
  int local_1a4;
  int local_1a0;
  void ***local_19c;
  uint local_198;
  routebox_t *local_194;
  int local_190;
  NetListListType local_18c [2];
  PointerListType layergroupboxes [16];
  routeall_status local_b4;
  routeone_status local_9c;
  NetListListType Nets;
  routedata_t *local_7c;
  LineType fake_line;
  char *local_20;
  
  bVar37 = 0;
  local_20 = *(char **)(in_GS_OFFSET + 0x14);
  total_wire_length = 0.00000000;
  total_via_count = 0;
  if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
    (*gui->use_mask)(4);
  }
  if (ar_gc == (hidGC)0x0) {
    ar_gc = (*gui->make_gc)();
    (*gui->set_line_cap)(ar_gc,Round_Cap);
  }
  pPVar8 = PCB;
  do {
    if ((((pPVar8->RouteStyle[0].Thick == 0) || (PCB->RouteStyle[1].Diameter == 0)) ||
        (PCB->RouteStyle[1].Hole == 0)) || (pPVar8->RouteStyle[0].Keepaway == 0)) {
      bVar36 = false;
      Message("You must define proper routing styles\nbefore auto-routing.\n");
      goto LAB_08073ebd;
    }
    pPVar8 = (PCBTypePtr)&pPVar8->PrintFilename;
  } while (pPVar8 != (PCBTypePtr)&PCB->MaskColor);
  bVar36 = false;
  if (PCB->Data->RatN == 0) goto LAB_08073ebd;
  SaveFindFlag(0x1000);
  pPVar8 = PCB;
  routing_layers = 0;
  pDVar16 = PCB->Data;
  local_198 = pDVar16->LayerN;
  if ((int)local_198 < 1) {
LAB_0807407c:
    AutoRouteParameters.use_vias = '\0';
  }
  else {
    local_194 = (routebox_t *)0x0;
    iVar20 = 0;
    do {
      if ((pPVar8->LayerGroups).Number[iVar20] != 0) {
        uVar9 = 0;
        while( true ) {
          uVar23 = (&(pPVar8->Flags).f)[uVar9 + 0x744 + iVar20 * 0x12];
          if ((uVar23 < local_198) && (*(char *)(&pDVar16->field_0x90 + uVar23 * 0x5c) != '\0')) {
            is_layer_group_active[iVar20] = '\x01';
            pDVar16 = pPVar8->Data;
            local_194 = (routebox_t *)((int)local_194 + 1);
            local_198 = pDVar16->LayerN;
            goto LAB_08073fad;
          }
          is_layer_group_active[iVar20] = '\0';
          uVar9 = uVar9 + 1;
          puVar3 = (pPVar8->LayerGroups).Number + iVar20;
          if (*puVar3 < uVar9 || *puVar3 == uVar9) break;
          pDVar16 = pPVar8->Data;
          local_198 = pDVar16->LayerN;
        }
        pDVar16 = pPVar8->Data;
        local_198 = pDVar16->LayerN;
      }
LAB_08073fad:
      iVar20 = iVar20 + 1;
    } while (iVar20 < (int)local_198);
    routing_layers = (int)local_194;
    if (((int)local_194 < 2) || (AutoRouteParameters.use_vias = '\x01', pPVar8->ViaOn == '\0'))
    goto LAB_0807407c;
  }
  front = GetLayerGroupNumberByNumber(pPVar8->Data->LayerN + 1);
  CVar10 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  layer = front;
  pDVar16 = PCB->Data;
  back = CVar10;
  if (0 < pDVar16->LayerN) {
    uVar9 = 0;
    do {
      if (CVar10 == uVar9) {
        x_cost[CVar10] = 4;
        y_cost[CVar10] = 2;
      }
      else {
        if (layer == uVar9) {
          x_cost[layer] = 2;
          y_cost[layer] = 2;
        }
        else {
          if ((uVar9 & 1) == 0) {
            x_cost[uVar9] = 1;
            iVar20 = 2;
          }
          else {
            x_cost[uVar9] = 2;
            iVar20 = 1;
          }
          y_cost[uVar9] = iVar20;
        }
      }
      uVar9 = uVar9 + 1;
    } while ((int)uVar9 < pDVar16->LayerN);
  }
  local_7c = (routedata_t *)calloc(1,0x7c);
  iVar20 = 0x1f;
  prVar32 = local_7c;
  while (layergroup = Settings.LineThickness, iVar20 != 0) {
    iVar20 = iVar20 + -1;
    prVar32->layergrouptree[0] = (rtree_t *)0x0;
    prVar32 = (routedata_t *)((int)prVar32 + (uint)bVar37 * -8 + 4);
  }
  (local_7c->defaultstyle).Thick = Settings.LineThickness;
  (local_7c->defaultstyle).Diameter = Settings.ViaThickness;
  (local_7c->defaultstyle).Hole = Settings.ViaDrillingHole;
  iVar20 = Settings.Keepaway;
  (local_7c->defaultstyle).Keepaway = Settings.Keepaway;
  local_7c->max_keep = iVar20;
  pPVar8 = PCB;
  local_7c->max_bloat = (layergroup + 1) / 2 + iVar20;
  local_7c->styles[0] = pPVar8->RouteStyle;
  local_7c->styles[1] = pPVar8->RouteStyle + 1;
  local_7c->styles[2] = pPVar8->RouteStyle + 2;
  local_7c->styles[3] = pPVar8->RouteStyle + 3;
  local_7c->styles[4] = &local_7c->defaultstyle;
  pDVar16 = pPVar8->Data;
  if (0 < pDVar16->LayerN) {
    local_19c = &layergroupboxes[0].Ptr;
    local_190 = 0;
    do {
      iVar20 = *(int *)&pDVar16->field_0x48;
      local_19c[-2] = (void **)0x0;
      local_19c[-1] = (void **)0x0;
      *local_19c = (void **)0x0;
      layergroup = local_190 + 0x734;
      if (*(int *)(iVar20 + 4 + layergroup * 4) != 0) {
        uVar9 = 0;
LAB_08074214:
        do {
          uVar23 = *(uint *)(iVar20 + 4 + (uVar9 + 0x744 + local_190 * 0x12) * 4);
          if (uVar23 < (uint)pDVar16->LayerN) {
            if (((&pDVar16->ViaN + uVar23 * 0x17)[0x14] != 0) ||
               ((&pDVar16->ViaN + uVar23 * 0x17)[0x17] != 0)) {
              uVar9 = uVar9 + 1;
              usedGroup[local_190] = '\x01';
              pDVar16 = pPVar8->Data;
              iVar20 = *(int *)&pDVar16->field_0x48;
              if (*(uint *)(iVar20 + 4 + layergroup * 4) <= uVar9) break;
              goto LAB_08074214;
            }
            usedGroup[local_190] = '\0';
            pDVar16 = pPVar8->Data;
          }
          iVar20 = *(int *)&pDVar16->field_0x48;
          uVar9 = uVar9 + 1;
        } while (uVar9 < *(uint *)(iVar20 + 4 + layergroup * 4));
      }
      local_190 = local_190 + 1;
      local_19c = local_19c + 3;
    } while (local_190 < pDVar16->LayerN);
  }
  usedGroup[front] = '\x01';
  usedGroup[back] = '\x01';
  ResetFoundPinsViasAndPads('\0');
  ResetFoundLinesAndPolygons('\0');
  CollectSubnets(local_18c,'\0');
  iVar20 = 3;
  pNVar28 = local_18c;
  pNVar33 = &Nets;
  while (iVar20 != 0) {
    iVar20 = iVar20 + -1;
    pNVar33->NetListN = pNVar28->NetListN;
    pNVar28 = (NetListListType *)((int)pNVar28 + (uint)bVar37 * -8 + 4);
    pNVar33 = (NetListListType *)((int)pNVar33 + (uint)bVar37 * -8 + 4);
  }
  local_1a8 = (routebox_t *)0x0;
  local_1c8 = Nets.NetListN - 1;
  if (local_1c8 != -1) {
    local_1cc = (undefined *)(Nets.NetListN * 0xc);
    local_1d8 = (routebox_t *)0x0;
    do {
      local_1cc = &DAT_fffffff4 + (int)local_1cc;
      piVar21 = (int *)((int)&(Nets.NetList)->NetN + (int)local_1cc);
      iVar20 = *piVar21;
      local_1c0 = iVar20 + -1;
      local_1a8 = (routebox_t *)0x0;
      if (local_1c0 != -1) {
        local_1bc = (iVar20 + 0xfffffff) * 0x10;
        local_1a8 = (routebox_t *)0x0;
        do {
          piVar11 = (int *)(local_1bc + piVar21[2]);
          style = (RouteStyleType *)piVar11[3];
          iVar20 = 0;
          if (((style != local_7c->styles[0]) && (iVar20 = 1, style != local_7c->styles[1])) &&
             (iVar20 = 2, style != local_7c->styles[2])) {
            iVar20 = (uint)(style != local_7c->styles[3]) + 3;
          }
          local_194 = (routebox_t *)0x0;
          local_1a0 = *piVar11 + -1;
          if (local_1a0 == -1) {
            bVar36 = local_1a8 != (routebox_t *)0x0;
          }
          else {
            do {
              iVar22 = local_1a0 * 0x1c + piVar11[2];
              pad = *(PadTypePtr **)(iVar22 + 0x10);
              (pad->Flags).f = (pad->Flags).f | 0x1000;
              layergroup = *(int *)(iVar22 + 8);
              if (layergroup == 4) {
                local_1a0 = local_1a0 + -1;
                if (((pad->Point1).X == (pad->Point2).X) || ((pad->Point1).Y == (pad->Point2).Y)) {
                  layergroup = *(int *)(iVar22 + 0x14);
                  style = (RouteStyleType *)local_7c->layergrouptree[iVar20 + 0x17];
                  line = pad;
                }
                else {
                  layergroup = 0x16;
                  line = pad;
                  pLVar34 = &fake_line;
                  while (layergroup != 0) {
                    layergroup = layergroup + -1;
                    (pLVar34->BoundingBox).X1 = (line->BoundingBox).X1;
                    line = (PadTypePtr *)((int)line + (uint)bVar37 * -8 + 4);
                    pLVar34 = (LineType *)((int)pLVar34 + (uint)bVar37 * -8 + 4);
                  }
                  uVar9 = (pad->Point2).X - (pad->Point1).X;
                  uVar23 = (pad->Point2).Y - (pad->Point1).Y;
                  layergroup = ((int)uVar9 >> 0x1f ^ uVar9) - ((int)uVar9 >> 0x1f);
                  iVar12 = ((int)uVar23 >> 0x1f ^ uVar23) - ((int)uVar23 >> 0x1f);
                  if (layergroup < iVar12) {
                    layergroup = iVar12;
                  }
                  layergroup = layergroup /
                               ((((int)&(local_7c->layergrouptree[iVar20 + 0x17]->root->box).X1 + 1)
                                 / 2 + local_7c->layergrouptree[iVar20 + 0x17][1].size) * 4 + 1);
                  if (0 < layergroup) {
                    iVar12 = 0x20;
                    if (layergroup < 0x21) {
                      iVar12 = layergroup;
                    }
                    if (iVar12 != 1) {
                      layergroup = 0;
                      a = local_1a8;
                      do {
                        fake_line.Point2.X = (int)uVar9 / iVar12 + fake_line.Point1.X;
                        fake_line.Point2.Y = (int)uVar23 / iVar12 + fake_line.Point1.Y;
                        if ((fake_line.Point2.X == (pad->Point2).X) &&
                           (local_1a8 = a, fake_line.Point2.Y == (pad->Point2).Y)) break;
                        local_1a8 = AddLine(layergroupboxes,*(int *)(iVar22 + 0x14),
                                            (LineTypePtr)&fake_line,(LineTypePtr)pad,
                                            (RouteStyleType *)
                                            local_7c->layergrouptree[iVar20 + 0x17]);
                        if ((local_1a8 != local_194) && (local_194 != (routebox_t *)0x0)) {
                          MergeNets(local_194,local_1a8,ORIGINAL);
                        }
                        if ((local_1a8 != a) && (a != (routebox_t *)0x0)) {
                          MergeNets(a,local_1a8,NET);
                        }
                        layergroup = layergroup + 1;
                        fake_line.Point1.X = fake_line.Point2.X;
                        fake_line.Point1.Y = fake_line.Point2.Y;
                        fake_line.Point1.X2 = fake_line.Point2.X2;
                        fake_line.Point1.Y2 = fake_line.Point2.Y2;
                        fake_line.Point1.ID = fake_line.Point2.ID;
                        a = local_1a8;
                        local_194 = local_1a8;
                      } while (layergroup < iVar12 + -1);
                    }
                  }
                  fake_line.Point2.X = (pad->Point2).X;
                  fake_line.Point2.Y = (pad->Point2).Y;
                  fake_line.Point2.X2 = (pad->Point2).X2;
                  fake_line.Point2.Y2 = (pad->Point2).Y2;
                  fake_line.Point2.ID = (pad->Point2).ID;
                  style = (RouteStyleType *)local_7c->layergrouptree[iVar20 + 0x17];
                  layergroup = *(int *)(iVar22 + 0x14);
                  line = (PadTypePtr *)&fake_line;
                }
                a = AddLine(layergroupboxes,layergroup,(LineTypePtr)line,(LineTypePtr)pad,style);
                bVar36 = a != (routebox_t *)0x0;
              }
              else {
                if (layergroup == 8) {
                  style = (RouteStyleType *)local_7c->layergrouptree[iVar20 + 0x17];
                  layer = GetLayerNumber(PCB->Data,*(LayerTypePtr *)(iVar22 + 0xc));
                  a = AddPolygon(layergroupboxes,layer,(PolygonTypePtr)pad,style);
                  bVar36 = a != (routebox_t *)0x0;
                }
                else {
                  if (layergroup < 9) {
                    if (layergroup == 1) {
                      style = (RouteStyleType *)local_7c->layergrouptree[iVar20 + 0x17];
                      is_via = '\x01';
LAB_08074775:
                      a = AddPin(layergroupboxes,(PinTypePtr *)pad,is_via,style);
                      bVar36 = a != (routebox_t *)0x0;
                    }
                    else {
LAB_08074466:
                      bVar36 = false;
                      a = (routebox_t *)0x0;
                    }
                  }
                  else {
                    if (layergroup == 0x100) {
                      is_via = '\0';
                      style = (RouteStyleType *)local_7c->layergrouptree[iVar20 + 0x17];
                      goto LAB_08074775;
                    }
                    if (layergroup != 0x200) goto LAB_08074466;
                    a = AddPad(layergroupboxes,*(ElementTypePtr **)(iVar22 + 0xc),pad,
                               (RouteStyleType *)local_7c->layergrouptree[iVar20 + 0x17]);
                    bVar36 = a != (routebox_t *)0x0;
                  }
                }
              }
              if ((local_194 != a) && (local_194 != (routebox_t *)0x0)) {
                MergeNets(local_194,a,ORIGINAL);
              }
              if ((a != local_1a8) && (local_1a8 != (routebox_t *)0x0)) {
                MergeNets(local_1a8,a,NET);
              }
              style = a->style;
              layergroup = (style->Thick + 1) / 2 + style->Keepaway;
              if (layergroup < local_7c->max_bloat) {
                layergroup = local_7c->max_bloat;
              }
              local_7c->max_bloat = layergroup;
              layergroup = style->Keepaway;
              if (layergroup <= local_7c->max_keep) {
                layergroup = local_7c->max_keep;
              }
              local_1a0 = local_1a0 + -1;
              local_7c->max_keep = layergroup;
              local_1a8 = a;
              local_194 = a;
            } while (local_1a0 != -1);
          }
          local_1c0 = local_1c0 + -1;
          local_1bc = local_1bc + -0x10;
        } while (local_1c0 != -1);
        if ((bVar36) && (local_1d8 != (routebox_t *)0x0)) {
          MergeNets(local_1d8,local_1a8,DIFFERENT_NET);
        }
      }
      local_1c8 = local_1c8 + -1;
      local_1d8 = local_1a8;
    } while (local_1c8 != -1);
  }
  local_7c->first_net = local_1a8;
  FreeNetListListMemory((NetListListTypePtr *)&Nets);
  a = local_7c->first_net;
  if (local_7c->first_net != (routebox_t *)0x0) {
    do {
      prVar30 = (a->different_net).next;
      to = a;
      do {
        prVar4 = (to->same_net).next;
        prVar26 = (to->original_subnet).prev;
        (to->same_subnet).next = (to->original_subnet).next;
        (to->same_subnet).prev = prVar26;
        to = (routebox_t *)prVar4;
      } while (prVar4 != (routebox *)a);
      a = (routebox_t *)prVar30;
    } while (prVar30 != (routebox *)local_7c->first_net);
  }
  pDVar16 = PCB->Data;
  local_190 = pDVar16->ElementN - 1;
  pPVar8 = PCB;
  if (local_190 != -1) {
    iVar20 = pDVar16->ElementN * 300;
    while( true ) {
      local_194 = (routebox_t *)(iVar20 + -300);
      iVar20 = (int)&pDVar16->Element[-1].BoundingBox.X1 + iVar20;
      if (*(uint *)(iVar20 + 0xe0) != 0) {
        uVar23 = 0;
        uVar9 = *(uint *)(iVar20 + 0xe0);
        do {
          pin = (PinTypePtr *)(uVar23 * 0x4c + *(int *)(iVar20 + 0x100));
          uVar17 = (pin->Flags).f;
          if ((uVar17 & 0x1000) == 0) {
            AddPin(layergroupboxes,pin,'\0',local_7c->styles[4]);
            uVar17 = *(uint *)(iVar20 + 0xe0);
            pPVar8 = PCB;
          }
          else {
            (pin->Flags).f = uVar17 & 0xffffefff;
            uVar17 = uVar9;
            pPVar8 = PCB;
          }
          PCB = pPVar8;
        } while ((uVar17 != 0) &&
                (uVar23 = (uVar23 + 1 + uVar17) - uVar9, uVar9 = uVar17, uVar23 < uVar17));
        pDVar16 = pPVar8->Data;
      }
      local_190 = local_190 + -1;
      if (local_190 == -1) break;
      pDVar16 = pPVar8->Data;
      iVar20 = (int)local_194;
    }
    local_194 = (routebox_t *)(pDVar16->ElementN - 1);
    if (local_194 != (routebox_t *)0xffffffff) {
      iVar20 = pDVar16->ElementN * 300;
      while( true ) {
        local_19c = (void ***)(iVar20 + -300);
        layergroup = 0;
        uVar35 = 0;
        element = (ElementTypePtr *)((int)&pDVar16->Element[-1].BoundingBox.X1 + iVar20);
        uVar9 = element->PadN;
        uVar17 = uVar9;
        uVar23 = uVar9;
        while ((uVar17 != 0 && (uVar35 < uVar17))) {
          pad = (PadTypePtr *)((int)&(element->Pad->BoundingBox).X1 + layergroup);
          uVar17 = (pad->Flags).f;
          if ((uVar17 & 0x1000) == 0) {
            AddPad(layergroupboxes,element,pad,local_7c->styles[4]);
            uVar23 = element->PadN;
          }
          else {
            (pad->Flags).f = uVar17 & 0xffffefff;
          }
          uVar17 = uVar23;
          if (uVar9 == uVar23) {
            uVar35 = uVar35 + 1;
            layergroup = layergroup + 0x68;
            uVar17 = uVar9;
          }
        }
        local_194 = (routebox_t *)((int)local_194 + -1);
        if (local_194 == (routebox_t *)0xffffffff) break;
        pDVar16 = PCB->Data;
        iVar20 = (int)local_19c;
      }
      pDVar16 = PCB->Data;
      pPVar8 = PCB;
    }
  }
  if (pDVar16->ViaN != 0) {
    uVar23 = 0;
    uVar9 = pDVar16->ViaN;
    do {
      pin = pDVar16->Via + uVar23;
      uVar17 = (pin->Flags).f;
      if ((uVar17 & 0x1000) == 0) {
        AddPin(layergroupboxes,pin,'\x01',local_7c->styles[4]);
        pPVar8 = PCB;
      }
      else {
        (pin->Flags).f = uVar17 & 0xffffefff;
      }
      pDVar16 = pPVar8->Data;
      uVar17 = pDVar16->ViaN;
    } while ((uVar17 != 0) &&
            (uVar23 = (uVar17 + 1 + uVar23) - uVar9, uVar9 = uVar17, uVar23 < uVar17));
  }
  if (0 < pDVar16->LayerN) {
    local_1b0 = 0;
LAB_08074a72:
    layer = GetLayerGroupNumberByNumber(local_1b0);
    pDVar16 = PCB->Data;
    iVar20 = *(int *)(&pDVar16->field_0x50 + local_1b0 * 0x5c);
    local_1a4 = iVar20 + -1;
    pPVar8 = PCB;
    if (local_1a4 != -1) {
      local_1a8 = (routebox_t *)(iVar20 * 0x58);
      do {
        local_1a8 = (routebox_t *)((int)local_1a8 + -0x58);
        line_00 = (LineTypePtr)((int)local_1a8 + *(int *)(&pDVar16->field_0x70 + local_1b0 * 0x5c));
        uVar9 = (line_00->Flags).f;
        if ((uVar9 & 0x1000) == 0) {
          if (((line_00->Point1).X == (line_00->Point2).X) ||
             ((line_00->Point1).Y == (line_00->Point2).Y)) {
            AddLine(layergroupboxes,layer,line_00,line_00,local_7c->styles[4]);
            pPVar8 = PCB;
          }
          else {
            iVar20 = 0x16;
            pLVar29 = line_00;
            pLVar34 = &fake_line;
            while (iVar20 != 0) {
              iVar20 = iVar20 + -1;
              (pLVar34->BoundingBox).X1 = (pLVar29->BoundingBox).X1;
              pLVar29 = (LineTypePtr)((int)pLVar29 + (uint)bVar37 * -8 + 4);
              pLVar34 = (LineType *)((int)pLVar34 + (uint)bVar37 * -8 + 4);
            }
            uVar9 = (line_00->Point2).X - (line_00->Point1).X;
            uVar23 = (line_00->Point2).Y - (line_00->Point1).Y;
            iVar20 = ((int)uVar9 >> 0x1f ^ uVar9) - ((int)uVar9 >> 0x1f);
            layergroup = ((int)uVar23 >> 0x1f ^ uVar23) - ((int)uVar23 >> 0x1f);
            if (iVar20 < layergroup) {
              iVar20 = layergroup;
            }
            iVar20 = iVar20 / (local_7c->max_bloat * 4 + 1);
            if (0 < iVar20) {
              layergroup = 0x20;
              if (iVar20 < 0x21) {
                layergroup = iVar20;
              }
              if (layergroup != 1) {
                iVar20 = 0;
                do {
                  fake_line.Point2.X = (int)uVar9 / layergroup + fake_line.Point1.X;
                  fake_line.Point2.Y = (int)uVar23 / layergroup + fake_line.Point1.Y;
                  if ((fake_line.Point2.X == (line_00->Point2).X) &&
                     (fake_line.Point2.Y == (line_00->Point2).Y)) break;
                  iVar20 = iVar20 + 1;
                  AddLine(layergroupboxes,layer,(LineTypePtr)&fake_line,line_00,local_7c->styles[4])
                  ;
                  fake_line.Point1.X = fake_line.Point2.X;
                  fake_line.Point1.Y = fake_line.Point2.Y;
                  fake_line.Point1.X2 = fake_line.Point2.X2;
                  fake_line.Point1.Y2 = fake_line.Point2.Y2;
                  fake_line.Point1.ID = fake_line.Point2.ID;
                } while (iVar20 < layergroup + -1);
              }
            }
            fake_line.Point2.X = (line_00->Point2).X;
            fake_line.Point2.Y = (line_00->Point2).Y;
            fake_line.Point2.X2 = (line_00->Point2).X2;
            fake_line.Point2.Y2 = (line_00->Point2).Y2;
            fake_line.Point2.ID = (line_00->Point2).ID;
            AddLine(layergroupboxes,layer,(LineTypePtr)&fake_line,line_00,local_7c->styles[4]);
            pPVar8 = PCB;
          }
        }
        else {
          (line_00->Flags).f = uVar9 & 0xffffefff;
        }
        local_1a4 = local_1a4 + -1;
        if (local_1a4 == -1) goto LAB_08074c8e;
        pDVar16 = pPVar8->Data;
      } while( true );
    }
    goto LAB_08074c94;
  }
LAB_08074e8d:
  if (AutoRouteParameters.use_vias == '\0') {
    iVar20 = pPVar8->Data->LayerN;
LAB_08074ea3:
    if (0 < iVar20) {
      iVar20 = 0;
      list = layergroupboxes;
      do {
        iVar20 = iVar20 + 1;
        FreePointerListMemory((PointerListTypePtr_conflict *)list);
        list = (PointerListType *)((PointerListTypePtr_conflict *)list + 1);
        pPVar8 = PCB;
      } while (iVar20 < PCB->Data->LayerN);
    }
  }
  else {
    pmVar18 = mtspace_create();
    pPVar8 = PCB;
    local_7c->mtspace = pmVar18;
    if (0 < pPVar8->Data->LayerN) {
      list = layergroupboxes;
      local_190 = 0;
      do {
        iVar20 = list->PtrN - 1;
        if (iVar20 != -1) {
          layergroup = list->PtrN * 4 + -4;
          do {
            while (box = *(BoxType **)((int)list->Ptr + layergroup),
                  (*(byte *)((int)&box[2].Y2 + 1) & 0x10) == 0) {
              iVar20 = iVar20 + -1;
              layergroup = layergroup + -4;
              mtspace_add(local_7c->mtspace,box,FIXED,*(BDimension *)(box[4].Y2 + 0xc));
              pPVar8 = PCB;
              if (iVar20 == -1) goto LAB_080753d6;
            }
            iVar20 = iVar20 + -1;
            layergroup = layergroup + -4;
            pPVar8 = PCB;
          } while (iVar20 != -1);
        }
LAB_080753d6:
        list = list + 1;
        local_190 = local_190 + 1;
        iVar20 = pPVar8->Data->LayerN;
      } while (local_190 < iVar20);
      goto LAB_08074ea3;
    }
  }
  pDVar16 = pPVar8->Data;
  local_190 = pDVar16->RatN - 1;
  if (local_190 == -1) {
LAB_080750a3:
    bVar36 = false;
  }
  else {
    layergroup = 0;
    pRVar27 = pDVar16->Rat + (pDVar16->RatN - 1);
    pFVar25 = &pRVar27->Flags;
    iVar20 = local_190;
    do {
      if ((selected == '\0') || ((*(byte *)&pFVar25->f & 0x40) != 0)) {
        layergroup = layergroup + 1;
      }
      iVar20 = iVar20 + -1;
      pFVar25 = (FlagType *)pFVar25[-8].t;
    } while (iVar20 != -1);
    if (layergroup == 0) goto LAB_080750a3;
    if (layergroup == 1) {
      iVar20 = local_190;
      if (selected != '\0') {
        do {
          if (((pRVar27->Flags).f & 0x40) != 0) goto LAB_08075214;
          iVar20 = iVar20 + -1;
          pRVar27 = pRVar27 + -1;
        } while (iVar20 != -1);
        goto LAB_08074f29;
      }
LAB_08075214:
      a = FindRouteBoxOnLayerGroup(local_7c,(pRVar27->Point1).X,(pRVar27->Point1).Y,pRVar27->group1)
      ;
      to = FindRouteBoxOnLayerGroup
                     (local_7c,(pRVar27->Point2).X,(pRVar27->Point2).Y,pRVar27->group2);
      InitAutoRouteParameters(0,a->style,'\0','\x01','\x01');
      RouteOne(&local_9c,local_7c,a,to,150000);
      bVar36 = local_9c.found_route != '\0';
    }
    else {
LAB_08074f29:
      if (local_7c->first_net == (routebox_t *)0x0) {
LAB_0807500a:
        iVar20 = local_190 * 0x5c;
        while( true ) {
          layergroup = (int)&(pDVar16->Rat->BoundingBox).X1 + iVar20;
          if ((selected == '\0') || ((*(byte *)(layergroup + 0x14) & 0x40) != 0)) {
            a = FindRouteBoxOnLayerGroup
                          (local_7c,*(LocationType *)(layergroup + 0x2c),
                           *(LocationType *)(layergroup + 0x30),*(Cardinal *)(layergroup + 0x54));
            to = FindRouteBoxOnLayerGroup
                           (local_7c,*(LocationType *)(layergroup + 0x40),
                            *(LocationType *)(layergroup + 0x44),*(Cardinal *)(layergroup + 0x58));
            if ((to == (routebox_t *)0x0) || (a == (routebox_t *)0x0)) {
              Message("The rats nest is stale! Aborting autoroute...\n");
              goto LAB_080750a3;
            }
            MergeNets(a,to,NET);
          }
          local_190 = local_190 + -1;
          iVar20 = iVar20 + -0x5c;
          if (local_190 == -1) break;
          pDVar16 = PCB->Data;
        }
      }
      else {
        prVar30 = (routebox *)0x0;
        a = local_7c->first_net;
        do {
          prVar4 = (a->different_net).next;
          prVar26 = (routebox *)a;
          do {
            prVar26 = (((routebox_t *)prVar26)->same_net).next;
            prVar15 = prVar26;
            prVar31 = prVar30;
          } while (prVar26 != (routebox *)a);
          do {
            prVar5 = (prVar15->same_net).next;
            prVar14 = prVar15;
            prVar30 = prVar31;
            if ((*(byte *)&(prVar15->flags).field_0x1 & 2) == 0) {
              do {
                prVar30 = (prVar14->same_subnet).next;
                pbVar2 = (byte *)&(prVar14->flags).field_0x1;
                *pbVar2 = *pbVar2 | 2;
                prVar14 = prVar30;
              } while (prVar30 != prVar15);
              prVar30 = prVar15;
              if (prVar31 != (routebox *)0x0) {
                (prVar31->different_net).next = prVar15;
                (prVar15->different_net).prev = prVar31;
              }
            }
            prVar15 = prVar5;
            prVar31 = prVar30;
          } while (prVar26 != prVar5);
          do {
            prVar26 = (prVar15->same_net).next;
            pbVar2 = (byte *)&(prVar15->flags).field_0x1;
            *pbVar2 = *pbVar2 & 0xfd;
            prVar15 = prVar26;
          } while (prVar5 != prVar26);
          do {
            prVar31 = (prVar15->same_net).next;
            prVar5 = (prVar15->same_subnet).prev;
            (prVar15->same_net).next = (prVar15->same_subnet).next;
            (prVar15->same_net).prev = prVar5;
            prVar15 = prVar31;
          } while (prVar26 != prVar31);
          a = (routebox_t *)prVar4;
        } while (prVar4 != (routebox *)local_7c->first_net);
        if (prVar30 != (routebox *)0x0) {
          (prVar30->different_net).next = prVar4;
          (local_7c->first_net->different_net).prev = prVar30;
        }
        pDVar16 = PCB->Data;
        local_190 = pDVar16->RatN - 1;
        if (local_190 != -1) goto LAB_0807500a;
      }
      a = local_7c->first_net;
      if (local_7c->first_net != (routebox_t *)0x0) {
        do {
          to = (routebox_t *)(a->different_net).next;
          prVar19 = a;
          if ((*(byte *)&(a->flags).field_0x1 & 1) == 0) {
            do {
              prVar6 = (routebox_t *)(prVar19->same_net).next;
              pbVar2 = (byte *)&(prVar19->flags).field_0x1;
              *pbVar2 = *pbVar2 | 1;
              prVar19 = prVar6;
            } while (prVar6 != a);
          }
          else {
            RemoveFromNet(a,DIFFERENT_NET);
          }
          a = to;
        } while (to != local_7c->first_net);
        if (to != (routebox_t *)0x0) {
          do {
            prVar30 = (to->different_net).next;
            a = to;
            do {
              prVar4 = (a->same_net).next;
              pbVar2 = (byte *)&(a->flags).field_0x1;
              *pbVar2 = *pbVar2 & 0xfe;
              a = (routebox_t *)prVar4;
            } while (prVar4 != (routebox *)to);
            to = (routebox_t *)prVar30;
          } while (prVar30 != (routebox *)local_7c->first_net);
        }
      }
      RouteAll(&local_b4,local_7c);
      bVar36 = 0 < local_b4.total_nets_routed;
    }
    if (bVar36 != false) {
      bVar36 = (bool)IronDownAllUnfixedPaths(local_7c);
    }
  }
  Message("Total added wire length = %f inches, %d vias added\n",
          (double)(total_wire_length / 100000.00000000),total_via_count);
  DestroyRouteData(&local_7c);
  if ((*(byte *)((int)&(PCB->Flags).f + 2) & 1) != 0) {
    (*gui->use_mask)(5);
  }
  if (bVar36 != false) {
    SaveUndoSerialNumber();
    DeleteRats('\0');
    RestoreUndoSerialNumber();
    AddAllRats('\0',(anon_subr_void *)0x0);
    RestoreUndoSerialNumber();
    IncrementUndoSerialNumber();
    ClearAndRedrawOutput();
  }
  RestoreFindFlag();
LAB_08073ebd:
  if (local_20 == *(char **)(in_GS_OFFSET + 0x14)) {
    return (Boolean)bVar36;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_08074c8e:
  pDVar16 = pPVar8->Data;
LAB_08074c94:
  layergroup = *(int *)(&pDVar16->field_0x58 + local_1b0 * 0x5c);
  iVar20 = layergroup + -1;
  if (iVar20 != -1) {
    puVar24 = (undefined *)(layergroup * 0x3c);
    while( true ) {
      puVar24 = &DAT_ffffffc4 + (int)puVar24;
      polygon = (PolygonTypePtr)(puVar24 + *(int *)(&pDVar16->field_0x78 + local_1b0 * 0x5c));
      uVar9 = (polygon->Flags).f;
      if ((uVar9 & 0x1000) == 0) {
        AddPolygon(layergroupboxes,local_1b0,polygon,local_7c->styles[4]);
        pPVar8 = PCB;
      }
      else {
        (polygon->Flags).f = uVar9 & 0xffffefff;
      }
      if (iVar20 == 0) break;
      iVar20 = iVar20 + -1;
      pDVar16 = pPVar8->Data;
    }
    pDVar16 = pPVar8->Data;
  }
  layergroup = *(int *)(&pDVar16->field_0x54 + local_1b0 * 0x5c);
  iVar20 = layergroup + -1;
  if (iVar20 != -1) {
    puVar24 = (undefined *)(layergroup * 0x3c);
    while( true ) {
      puVar24 = &DAT_ffffffc4 + (int)puVar24;
      iVar20 = iVar20 + -1;
      parent = (LocationType *)(puVar24 + *(int *)(&pDVar16->field_0x74 + local_1b0 * 0x5c));
      AddIrregularObstacle
                (layergroupboxes,*parent,parent[1],parent[2],parent[3],layer,parent,
                 local_7c->styles[4]);
      if (iVar20 == -1) break;
      pDVar16 = PCB->Data;
    }
    pDVar16 = PCB->Data;
    pPVar8 = PCB;
  }
  layergroup = *(int *)(&pDVar16->field_0x5c + local_1b0 * 0x5c);
  iVar20 = layergroup + -1;
  if (iVar20 != -1) {
    layergroup = layergroup * 0x44;
    while( true ) {
      layergroup = layergroup + -0x44;
      iVar20 = iVar20 + -1;
      parent = (LocationType *)(layergroup + *(int *)(&pDVar16->field_0x7c + local_1b0 * 0x5c));
      AddIrregularObstacle
                (layergroupboxes,*parent,parent[1],parent[2],parent[3],layer,parent,
                 local_7c->styles[4]);
      if (iVar20 == -1) break;
      pDVar16 = PCB->Data;
    }
    pDVar16 = PCB->Data;
    pPVar8 = PCB;
  }
  local_1b0 = local_1b0 + 1;
  if (pDVar16->LayerN <= (int)local_1b0) goto code_r0x08074e47;
  goto LAB_08074a72;
code_r0x08074e47:
  if (0 < pDVar16->LayerN) {
    list = layergroupboxes;
    iVar20 = 0;
    do {
      pCVar7 = &list->PtrN;
      ppBVar1 = (BoxType **)&list->Ptr;
      list = list + 1;
      prVar13 = r_create_tree((BoxType **)*ppBVar1,*pCVar7,1);
      local_7c->layergrouptree[iVar20] = prVar13;
      iVar20 = iVar20 + 1;
      pPVar8 = PCB;
    } while (iVar20 < PCB->Data->LayerN);
  }
  goto LAB_08074e8d;
}



void register_rotate_action_list(void)

{
  hid_register_actions(rotate_action_list,1);
  return;
}



void * CopyObjectToBuffer(DataTypePtr *Destination,DataTypePtr *Src,int Type,void *Ptr1,void *Ptr2,
                         void *Ptr3)

{
  void *pvVar1;
  
  Dest = Destination;
  Source = Src;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&AddBufferFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



void * MoveObjectToBuffer(DataTypePtr *Destination,DataTypePtr *Src,int Type,void *Ptr1,void *Ptr2,
                         void *Ptr3)

{
  void *pvVar1;
  
  Dest = Destination;
  Source = Src;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&MoveBufferFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



void * AddRatToBuffer(RatTypePtr *Rat)

{
  RatTypePtr *pRVar1;
  int in_GS_OFFSET;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags((FlagType *)&local_1c,Rat->Flags,ExtraFlag | 4);
  pRVar1 = CreateNewRat(Dest,(Rat->Point1).X,(Rat->Point1).Y,(Rat->Point2).X,(Rat->Point2).Y,
                        Rat->group1,Rat->group2,Rat->Thickness,
                        (FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pRVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * AddArcToBuffer(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  DataTypePtr *pDVar1;
  int iVar2;
  ArcTypePtr *pAVar3;
  int in_GS_OFFSET;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  pDVar1 = Dest;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = GetLayerNumber(Source,Layer);
  MaskFlags((FlagType *)&local_2c,Arc->Flags,ExtraFlag | 4);
  pAVar3 = CreateNewArcOnLayer((LayerTypePtr)(&pDVar1->field_0x4c + iVar2 * 0x5c),Arc->X,Arc->Y,
                               Arc->Width,Arc->Height,Arc->StartAngle,Arc->Delta,Arc->Thickness,
                               Arc->Clearance,
                               (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pAVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * AddElementToBuffer(ElementTypePtr *Element)

{
  FlagType *pFVar1;
  int iVar2;
  ElementTypePtr *Dest;
  uint uVar3;
  PinTypePtr *pPVar4;
  PadTypePtr *pPVar5;
  uint uVar6;
  
  Dest = GetElementMemory(Dest);
  CopyElementLowLevel(Dest,Dest,Element,'\0',0,0);
  iVar2 = ExtraFlag;
  uVar3 = ~ExtraFlag;
  (Dest->Flags).f = (Dest->Flags).f & uVar3;
  if (iVar2 != 0) {
    uVar6 = Dest->PinN;
    pFVar1 = &Dest->Name[2].Flags;
    pFVar1->f = pFVar1->f & uVar3;
    pFVar1 = &Dest->Name[1].Flags;
    pFVar1->f = pFVar1->f & uVar3;
    pFVar1 = &Dest->Name[0].Flags;
    pFVar1->f = pFVar1->f & uVar3;
    if (uVar6 != 0) {
      pPVar4 = Dest->Pin;
      uVar3 = 1;
      pFVar1 = &pPVar4->Flags;
      pFVar1->f = pFVar1->f & ~(iVar2 | 4U);
      while (uVar3 < uVar6) {
        pPVar4[1].Flags.f = pPVar4[1].Flags.f & ~(iVar2 | 4U);
        uVar3 = uVar3 + 1;
        pPVar4 = pPVar4 + 1;
      }
    }
    uVar3 = Dest->PadN;
    if (uVar3 != 0) {
      pPVar5 = Dest->Pad;
      uVar6 = 1;
      pFVar1 = &pPVar5->Flags;
      pFVar1->f = pFVar1->f & ~(iVar2 | 4U);
      while (uVar6 < uVar3) {
        pPVar5[1].Flags.f = pPVar5[1].Flags.f & ~(iVar2 | 4U);
        uVar6 = uVar6 + 1;
        pPVar5 = pPVar5 + 1;
      }
    }
  }
  return Dest;
}



void * AddViaToBuffer(PinTypePtr *Via)

{
  PinTypePtr *pPVar1;
  int in_GS_OFFSET;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags((FlagType *)&local_1c,Via->Flags,ExtraFlag | 4);
  pPVar1 = CreateNewVia(Dest,Via->X,Via->Y,Via->Thickness,Via->Clearance,Via->Mask,Via->DrillingHole
                        ,Via->Name,(FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pPVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * AddPolygonToBuffer(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  DataTypePtr *pDVar1;
  int iVar2;
  PolygonTypePtr Dest;
  
  pDVar1 = Dest;
  iVar2 = GetLayerNumber(Source,Layer);
  Dest = GetPolygonMemory((LayerTypePtr)(&pDVar1->field_0x4c + iVar2 * 0x5c));
  CopyPolygonLowLevel(Dest,Polygon);
  (Dest->Flags).f = (Dest->Flags).f & ~(ExtraFlag | 4U);
  return Dest;
}



void * AddTextToBuffer(LayerTypePtr Layer,TextTypePtr Text)

{
  DataTypePtr *pDVar1;
  int iVar2;
  TextTypePtr pTVar3;
  int in_GS_OFFSET;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  pDVar1 = Dest;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = GetLayerNumber(Source,Layer);
  MaskFlags((FlagType *)&local_2c,Text->Flags,ExtraFlag);
  pTVar3 = CreateNewText((LayerTypePtr)(&pDVar1->field_0x4c + iVar2 * 0x5c),(FontTypePtr)&PCB->Font,
                         Text->X,Text->Y,Text->Direction,Text->Scale,Text->TextString,
                         (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pTVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * AddLineToBuffer(LayerTypePtr Layer,LineTypePtr Line)

{
  DataTypePtr *pDVar1;
  int iVar2;
  LineTypePtr pLVar3;
  char *pcVar4;
  int in_GS_OFFSET;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  pDVar1 = Dest;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = GetLayerNumber(Source,Layer);
  MaskFlags((FlagType *)&local_2c,Line->Flags,ExtraFlag | 4);
  pLVar3 = CreateNewLineOnLayer
                     ((LayerTypePtr)(&pDVar1->field_0x4c + iVar2 * 0x5c),(Line->Point1).X,
                      (Line->Point1).Y,(Line->Point2).X,(Line->Point2).Y,Line->Thickness,
                      Line->Clearance,(FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
  if ((pLVar3 != (LineTypePtr)0x0) && (Line->Number != (char *)0x0)) {
    pcVar4 = MyStrdup(Line->Number,"AddLineToBuffer");
    pLVar3->Number = pcVar4;
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * MoveRatToBuffer(RatTypePtr *Rat)

{
  RatTypePtr **ppRVar1;
  RatTypePtr *which;
  DataTypePtr *pDVar2;
  rtree_t *rtree;
  int iVar3;
  uint uVar4;
  uint uVar5;
  RatTypePtr *pRVar6;
  Cardinal CVar7;
  RatTypePtr *pRVar8;
  BoxType *pBVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  r_delete_entry(Source->rat_tree,(BoxType *)Rat);
  which = GetRatMemory(Dest);
  iVar3 = 0x17;
  pRVar6 = Rat;
  pRVar8 = which;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    (pRVar8->BoundingBox).X1 = (pRVar6->BoundingBox).X1;
    pRVar6 = (RatTypePtr *)((int)pRVar6 + (uint)bVar11 * -8 + 4);
    pRVar8 = (RatTypePtr *)((int)pRVar8 + (uint)bVar11 * -8 + 4);
  }
  (which->Flags).f = (which->Flags).f & 0xfffffffb;
  pDVar2 = Source;
  ppRVar1 = &Source->Rat;
  CVar7 = Source->RatN - 1;
  Source->RatN = CVar7;
  if (*ppRVar1 + CVar7 != Rat) {
    iVar3 = 0x17;
    pRVar6 = *ppRVar1 + CVar7;
    pRVar8 = Rat;
    while (iVar3 != 0) {
      iVar3 = iVar3 + -1;
      (pRVar8->BoundingBox).X1 = (pRVar6->BoundingBox).X1;
      pRVar6 = (RatTypePtr *)((int)pRVar6 + (uint)bVar11 * -8 + 4);
      pRVar8 = (RatTypePtr *)((int)pRVar8 + (uint)bVar11 * -8 + 4);
    }
    r_substitute(pDVar2->rat_tree,(BoxType *)(pDVar2->Rat + pDVar2->RatN),(BoxType *)Rat);
    CVar7 = Source->RatN;
    pDVar2 = Source;
  }
  pBVar9 = (BoxType *)((int)&pDVar2->Rat->BoundingBox + CVar7 * 0x5c);
  uVar5 = 0x5c;
  bVar10 = ((uint)pBVar9 & 1) != 0;
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 1);
    uVar5 = 0x5b;
  }
  if (((uint)pBVar9 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    uVar5 = uVar5 - 2;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  uVar4 = uVar5 >> 2;
  while (uVar4 != 0) {
    uVar4 = uVar4 - 1;
    pBVar9->X1 = 0;
    pBVar9 = (BoxType *)(&pBVar9->X1 + (uint)bVar11 * 0x3ffffffe + 1);
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
  }
  pDVar2 = Dest;
  rtree = Dest->rat_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    pDVar2->rat_tree = rtree;
    rtree = Dest->rat_tree;
  }
  r_insert_entry(rtree,(BoxType *)which,0);
  return which;
}



void * MovePolygonToBuffer(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PointTypePtr pPVar1;
  PolygonTypePtr ppVar2;
  DataTypePtr *pDVar3;
  int iVar4;
  PolygonTypePtr which;
  Cardinal CVar5;
  rtree_t *rtree;
  uint uVar6;
  uint uVar7;
  Cardinal *pCVar8;
  BoxType *pBVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
  pDVar3 = Dest;
  iVar4 = GetLayerNumber(Source,Layer);
  which = GetPolygonMemory((LayerTypePtr)(&pDVar3->field_0x4c + iVar4 * 0x5c));
  (which->BoundingBox).X1 = (Polygon->BoundingBox).X1;
  (which->BoundingBox).Y1 = (Polygon->BoundingBox).Y1;
  (which->BoundingBox).X2 = (Polygon->BoundingBox).X2;
  (which->BoundingBox).Y2 = (Polygon->BoundingBox).Y2;
  which->ID = Polygon->ID;
  (which->Flags).f = (Polygon->Flags).f;
  *(undefined4 *)(which->Flags).t = *(undefined4 *)(Polygon->Flags).t;
  *(undefined4 *)((which->Flags).t + 4) = *(undefined4 *)((Polygon->Flags).t + 4);
  which->net = Polygon->net;
  which->PointN = Polygon->PointN;
  which->PointMax = Polygon->PointMax;
  which->Clipped = Polygon->Clipped;
  which->NoHoles = Polygon->NoHoles;
  which->NoHolesValid = Polygon->NoHolesValid;
  pPVar1 = Polygon->Points;
  (which->Flags).f = (which->Flags).f & 0xfffffffb;
  which->Points = pPVar1;
  ppVar2 = Layer->Polygon;
  CVar5 = Layer->PolygonN - 1;
  Layer->PolygonN = CVar5;
  if (ppVar2 + CVar5 != Polygon) {
    (Polygon->BoundingBox).X1 = ppVar2[CVar5].BoundingBox.X1;
    (Polygon->BoundingBox).Y1 = ppVar2[CVar5].BoundingBox.Y1;
    (Polygon->BoundingBox).X2 = ppVar2[CVar5].BoundingBox.X2;
    (Polygon->BoundingBox).Y2 = ppVar2[CVar5].BoundingBox.Y2;
    Polygon->ID = ppVar2[CVar5].ID;
    (Polygon->Flags).f = ppVar2[CVar5].Flags.f;
    *(undefined4 *)(Polygon->Flags).t = *(undefined4 *)ppVar2[CVar5].Flags.t;
    *(undefined4 *)((Polygon->Flags).t + 4) = *(undefined4 *)(ppVar2[CVar5].Flags.t + 4);
    Polygon->net = ppVar2[CVar5].net;
    Polygon->PointN = ppVar2[CVar5].PointN;
    Polygon->PointMax = ppVar2[CVar5].PointMax;
    Polygon->Clipped = ppVar2[CVar5].Clipped;
    Polygon->NoHoles = ppVar2[CVar5].NoHoles;
    Polygon->NoHolesValid = ppVar2[CVar5].NoHolesValid;
    Polygon->Points = ppVar2[CVar5].Points;
    r_substitute(Layer->polygon_tree,(BoxType *)(Layer->Polygon + Layer->PolygonN),
                 (BoxType *)Polygon);
    CVar5 = Layer->PolygonN;
  }
  pBVar9 = (BoxType *)((int)&Layer->Polygon->BoundingBox + CVar5 * 0x3c);
  uVar7 = 0x3c;
  bVar10 = ((uint)pBVar9 & 1) != 0;
  if (bVar10) {
    uVar7 = 0x3b;
    *(undefined *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 1);
  }
  if (((uint)pBVar9 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    uVar7 = uVar7 - 2;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  uVar6 = uVar7 >> 2;
  while (uVar6 != 0) {
    uVar6 = uVar6 - 1;
    pBVar9->X1 = 0;
    pBVar9 = (BoxType *)(&pBVar9->X1 + (uint)bVar11 * 0x3ffffffe + 1);
  }
  if ((uVar7 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
  }
  pCVar8 = &pDVar3->ViaN + iVar4 * 0x17;
  rtree = (rtree_t *)pCVar8[0x22];
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    *(rtree_t **)(pCVar8 + 0x22) = rtree;
  }
  r_insert_entry(rtree,(BoxType *)which,0);
  return which;
}



void * MoveArcToBuffer(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  LayerTypePtr Layer_00;
  DataTypePtr *pDVar1;
  int iVar2;
  ArcTypePtr *ptr2;
  Cardinal CVar3;
  rtree_t *rtree;
  int iVar4;
  uint uVar5;
  uint uVar6;
  Cardinal *pCVar7;
  ArcTypePtr *pAVar8;
  ArcTypePtr *pAVar9;
  BoxType *pBVar10;
  bool bVar11;
  byte bVar12;
  
  bVar12 = 0;
  RestoreToPolygon((DataType *)Source,0x4000,Layer,Arc);
  r_delete_entry(Layer->arc_tree,(BoxType *)Arc);
  pDVar1 = Dest;
  iVar2 = GetLayerNumber(Source,Layer);
  Layer_00 = (LayerTypePtr)(&pDVar1->field_0x4c + iVar2 * 0x5c);
  ptr2 = GetArcMemory(Layer_00);
  iVar4 = 0x11;
  pAVar8 = Arc;
  pAVar9 = ptr2;
  while (iVar4 != 0) {
    iVar4 = iVar4 + -1;
    (pAVar9->BoundingBox).X1 = (pAVar8->BoundingBox).X1;
    pAVar8 = (ArcTypePtr *)((int)pAVar8 + (uint)bVar12 * -8 + 4);
    pAVar9 = (ArcTypePtr *)((int)pAVar9 + (uint)bVar12 * -8 + 4);
  }
  (ptr2->Flags).f = (ptr2->Flags).f & 0xfffffffb;
  CVar3 = Layer->ArcN - 1;
  Layer->ArcN = CVar3;
  if (Layer->Arc + CVar3 != Arc) {
    iVar4 = 0x11;
    pAVar8 = Layer->Arc + CVar3;
    pAVar9 = Arc;
    while (iVar4 != 0) {
      iVar4 = iVar4 + -1;
      (pAVar9->BoundingBox).X1 = (pAVar8->BoundingBox).X1;
      pAVar8 = (ArcTypePtr *)((int)pAVar8 + (uint)bVar12 * -8 + 4);
      pAVar9 = (ArcTypePtr *)((int)pAVar9 + (uint)bVar12 * -8 + 4);
    }
    r_substitute(Layer->arc_tree,(BoxType *)(Layer->Arc + Layer->ArcN),(BoxType *)Arc);
    CVar3 = Layer->ArcN;
  }
  pBVar10 = (BoxType *)((int)&Layer->Arc->BoundingBox + CVar3 * 0x44);
  uVar6 = 0x44;
  bVar11 = ((uint)pBVar10 & 1) != 0;
  if (bVar11) {
    *(undefined *)&pBVar10->X1 = 0;
    pBVar10 = (BoxType *)((int)&pBVar10->X1 + 1);
    uVar6 = 0x43;
  }
  if (((uint)pBVar10 & 2) != 0) {
    *(undefined2 *)&pBVar10->X1 = 0;
    uVar6 = uVar6 - 2;
    pBVar10 = (BoxType *)((int)&pBVar10->X1 + 2);
  }
  uVar5 = uVar6 >> 2;
  while (uVar5 != 0) {
    uVar5 = uVar5 - 1;
    pBVar10->X1 = 0;
    pBVar10 = (BoxType *)(&pBVar10->X1 + (uint)bVar12 * 0x3ffffffe + 1);
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)&pBVar10->X1 = 0;
    pBVar10 = (BoxType *)((int)&pBVar10->X1 + 2);
  }
  if (bVar11) {
    *(undefined *)&pBVar10->X1 = 0;
  }
  pCVar7 = &pDVar1->ViaN + iVar2 * 0x17;
  rtree = (rtree_t *)pCVar7[0x23];
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    *(rtree_t **)(pCVar7 + 0x23) = rtree;
  }
  r_insert_entry(rtree,(BoxType *)ptr2,0);
  ClearFromPolygon((DataType *)Dest,0x4000,Layer_00,ptr2);
  return ptr2;
}



void * MoveElementToBuffer(ElementTypePtr *Element)

{
  ElementTypePtr **ppEVar1;
  BoxType *before;
  rtree_t **pprVar2;
  uint uVar3;
  PCBTypePtr pPVar4;
  ElementTypePtr *ptr1;
  Cardinal CVar5;
  DataTypePtr *pDVar6;
  int iVar7;
  PinTypePtr *ptr2;
  void *ptr2_00;
  uint uVar8;
  ElementTypePtr *pEVar9;
  uint uVar10;
  Cardinal CVar11;
  ElementTypePtr *pEVar12;
  int iVar13;
  BoxType *after;
  bool bVar14;
  byte bVar15;
  uint local_20;
  
  bVar15 = 0;
  r_delete_element((DataType *)Source,(ElementType *)Element);
  ptr1 = GetElementMemory(Dest);
  iVar7 = 0x4b;
  pEVar9 = Element;
  pEVar12 = ptr1;
  while (iVar7 != 0) {
    iVar7 = iVar7 + -1;
    (pEVar12->BoundingBox).X1 = (pEVar9->BoundingBox).X1;
    pEVar9 = (ElementTypePtr *)((int)pEVar9 + (uint)bVar15 * -8 + 4);
    pEVar12 = (ElementTypePtr *)((int)pEVar12 + (uint)bVar15 * -8 + 4);
  }
  if (ptr1->PinN != 0) {
    uVar10 = 0;
    local_20 = ptr1->PinN;
    do {
      ptr2 = ptr1->Pin + uVar10;
      RestoreToPolygon((DataType *)Source,0x100,Element,ptr2);
      uVar8 = ptr1->PinN;
      (ptr2->Flags).f = (ptr2->Flags).f & 0xfffffdfb;
      *(ElementTypePtr **)&ptr2->Element = ptr1;
      if (uVar8 == 0) break;
      uVar10 = (uVar8 + 1 + uVar10) - local_20;
      local_20 = uVar8;
    } while (uVar10 < uVar8);
  }
  CVar11 = ptr1->PadN;
  uVar10 = 0;
  local_20 = 0;
  CVar5 = CVar11;
  while ((pPVar4 = PCB, CVar5 != 0 && (uVar10 < CVar5))) {
    ptr2_00 = (void *)((int)&(ptr1->Pad->BoundingBox).X1 + local_20);
    RestoreToPolygon((DataType *)Source,0x200,Element,ptr2_00);
    CVar5 = ptr1->PadN;
    *(uint *)((int)ptr2_00 + 0x14) = *(uint *)((int)ptr2_00 + 0x14) & 0xfffffdfb;
    *(ElementTypePtr **)((int)ptr2_00 + 0x60) = ptr1;
    if (CVar5 == CVar11) {
      uVar10 = uVar10 + 1;
      local_20 = local_20 + 0x68;
      CVar5 = CVar11;
    }
  }
  uVar8 = 0;
  *(ElementTypePtr **)&ptr1->Name[2].Element = ptr1;
  *(ElementTypePtr **)&ptr1->Name[1].Element = ptr1;
  *(ElementTypePtr **)&ptr1->Name[0].Element = ptr1;
  SetElementBoundingBox(Dest,(ElementTypePtr_conflict)ptr1,(FontTypePtr)&pPVar4->Font);
  uVar10 = ptr1->PinN;
  if (ptr1->PinN != 0) {
    do {
      ClearFromPolygon((DataType *)Dest,0x100,ptr1,ptr1->Pin + uVar8);
      uVar3 = ptr1->PinN;
      if (uVar3 == 0) break;
      uVar8 = (uVar3 + 1 + uVar8) - uVar10;
      uVar10 = uVar3;
    } while (uVar8 < uVar3);
  }
  CVar11 = ptr1->PadN;
  iVar7 = 0;
  uVar10 = 0;
  CVar5 = CVar11;
  while ((pDVar6 = Source, CVar5 != 0 && (uVar10 < CVar5))) {
    ClearFromPolygon((DataType *)Dest,0x200,ptr1,(void *)((int)&(ptr1->Pad->BoundingBox).X1 + iVar7)
                    );
    CVar5 = ptr1->PadN;
    if (ptr1->PadN == CVar11) {
      uVar10 = uVar10 + 1;
      iVar7 = iVar7 + 0x68;
      CVar5 = CVar11;
    }
  }
  ppEVar1 = &Source->Element;
  CVar11 = Source->ElementN - 1;
  Source->ElementN = CVar11;
  if (*ppEVar1 + CVar11 != Element) {
    iVar7 = 0x4b;
    pEVar9 = *ppEVar1 + CVar11;
    pEVar12 = Element;
    while (iVar7 != 0) {
      iVar7 = iVar7 + -1;
      (pEVar12->BoundingBox).X1 = (pEVar9->BoundingBox).X1;
      pEVar9 = (ElementTypePtr *)((int)pEVar9 + (uint)bVar15 * -8 + 4);
      pEVar12 = (ElementTypePtr *)((int)pEVar12 + (uint)bVar15 * -8 + 4);
    }
    iVar13 = 0;
    iVar7 = 0;
    r_substitute(pDVar6->element_tree,(BoxType *)(pDVar6->Element + pDVar6->ElementN),
                 (BoxType *)Element);
    do {
      after = (BoxType *)((int)&Element->Name[0].BoundingBox.X1 + iVar13);
      before = (BoxType *)((int)&Source->Element[Source->ElementN].Name[0].BoundingBox.X1 + iVar13);
      iVar13 = iVar13 + 0x3c;
      pprVar2 = Source->name_tree + iVar7;
      iVar7 = iVar7 + 1;
      r_substitute(*pprVar2,before,after);
    } while (iVar7 != 3);
    uVar10 = Element->PinN;
    *(ElementTypePtr **)&Element->Name[2].Element = Element;
    *(ElementTypePtr **)&Element->Name[1].Element = Element;
    *(ElementTypePtr **)&Element->Name[0].Element = Element;
    if (uVar10 != 0) {
      ptr2 = Element->Pin;
      *(ElementTypePtr **)&ptr2->Element = Element;
      uVar8 = 0;
      while (uVar8 = uVar8 + 1, uVar8 < uVar10) {
        *(ElementTypePtr **)&ptr2[uVar8].Element = Element;
      }
    }
    uVar8 = 0;
    uVar10 = Element->PadN;
    iVar7 = 0;
    while ((uVar10 != 0 && (uVar8 < uVar10))) {
      uVar8 = uVar8 + 1;
      *(ElementTypePtr **)((int)&Element->Pad->Element + iVar7) = Element;
      iVar7 = iVar7 + 0x68;
    }
    CVar11 = Source->ElementN;
    pDVar6 = Source;
  }
  after = (BoxType *)((int)&pDVar6->Element->BoundingBox + CVar11 * 300);
  uVar10 = 300;
  bVar14 = ((uint)after & 1) != 0;
  if (bVar14) {
    *(undefined *)&after->X1 = 0;
    uVar10 = 299;
    after = (BoxType *)((int)&after->X1 + 1);
  }
  if (((uint)after & 2) != 0) {
    *(undefined2 *)&after->X1 = 0;
    uVar10 = uVar10 - 2;
    after = (BoxType *)((int)&after->X1 + 2);
  }
  uVar8 = uVar10 >> 2;
  while (uVar8 != 0) {
    uVar8 = uVar8 - 1;
    after->X1 = 0;
    after = (BoxType *)(&after->X1 + (uint)bVar15 * 0x3ffffffe + 1);
  }
  if ((uVar10 & 2) != 0) {
    *(undefined2 *)&after->X1 = 0;
    after = (BoxType *)((int)&after->X1 + 2);
  }
  if (bVar14) {
    *(undefined *)&after->X1 = 0;
  }
  return ptr1;
}



void * MoveViaToBuffer(PinTypePtr *Via)

{
  PinTypePtr **ppPVar1;
  PinTypePtr *ptr1;
  DataTypePtr *pDVar2;
  rtree_t *rtree;
  int iVar3;
  uint uVar4;
  uint uVar5;
  PinTypePtr *pPVar6;
  Cardinal CVar7;
  PinTypePtr *pPVar8;
  BoxType *pBVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  RestoreToPolygon((DataType *)Source,1,Via,Via);
  r_delete_entry(Source->via_tree,(BoxType *)Via);
  ptr1 = GetViaMemory(Dest);
  iVar3 = 0x13;
  pPVar6 = Via;
  pPVar8 = ptr1;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    (pPVar8->BoundingBox).X1 = (pPVar6->BoundingBox).X1;
    pPVar6 = (PinTypePtr *)((int)pPVar6 + (uint)bVar11 * -8 + 4);
    pPVar8 = (PinTypePtr *)((int)pPVar8 + (uint)bVar11 * -8 + 4);
  }
  (ptr1->Flags).f = (ptr1->Flags).f & 0xfffffdfb;
  pDVar2 = Source;
  ppPVar1 = &Source->Via;
  CVar7 = Source->ViaN - 1;
  Source->ViaN = CVar7;
  if (*ppPVar1 + CVar7 != Via) {
    iVar3 = 0x13;
    pPVar6 = *ppPVar1 + CVar7;
    pPVar8 = Via;
    while (iVar3 != 0) {
      iVar3 = iVar3 + -1;
      (pPVar8->BoundingBox).X1 = (pPVar6->BoundingBox).X1;
      pPVar6 = (PinTypePtr *)((int)pPVar6 + (uint)bVar11 * -8 + 4);
      pPVar8 = (PinTypePtr *)((int)pPVar8 + (uint)bVar11 * -8 + 4);
    }
    r_substitute(pDVar2->via_tree,(BoxType *)(pDVar2->Via + pDVar2->ViaN),(BoxType *)Via);
    CVar7 = Source->ViaN;
    pDVar2 = Source;
  }
  pBVar9 = (BoxType *)((int)&pDVar2->Via->BoundingBox + CVar7 * 0x4c);
  uVar5 = 0x4c;
  bVar10 = ((uint)pBVar9 & 1) != 0;
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 1);
    uVar5 = 0x4b;
  }
  if (((uint)pBVar9 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    uVar5 = uVar5 - 2;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  uVar4 = uVar5 >> 2;
  while (uVar4 != 0) {
    uVar4 = uVar4 - 1;
    pBVar9->X1 = 0;
    pBVar9 = (BoxType *)(&pBVar9->X1 + (uint)bVar11 * 0x3ffffffe + 1);
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
  }
  pDVar2 = Dest;
  rtree = Dest->via_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    pDVar2->via_tree = rtree;
    rtree = Dest->via_tree;
  }
  r_insert_entry(rtree,(BoxType *)ptr1,0);
  ClearFromPolygon((DataType *)Dest,1,ptr1,ptr1);
  return ptr1;
}



void * MoveTextToBuffer(LayerTypePtr Layer,TextTypePtr Text)

{
  LayerTypePtr Layer_00;
  TextTypePtr pTVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  TextTypePtr ptr2;
  Cardinal CVar4;
  rtree_t *rtree;
  uint uVar5;
  uint uVar6;
  Cardinal *pCVar7;
  BoxType *pBVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  r_delete_entry(Layer->text_tree,(BoxType *)Text);
  RestoreToPolygon((DataType *)Source,0x10,Layer,Text);
  pDVar2 = Dest;
  iVar3 = GetLayerNumber(Source,Layer);
  Layer_00 = (LayerTypePtr)(&pDVar2->field_0x4c + iVar3 * 0x5c);
  ptr2 = GetTextMemory(Layer_00);
  (ptr2->BoundingBox).X1 = (Text->BoundingBox).X1;
  (ptr2->BoundingBox).Y1 = (Text->BoundingBox).Y1;
  (ptr2->BoundingBox).X2 = (Text->BoundingBox).X2;
  (ptr2->BoundingBox).Y2 = (Text->BoundingBox).Y2;
  ptr2->ID = Text->ID;
  (ptr2->Flags).f = (Text->Flags).f;
  *(undefined4 *)(ptr2->Flags).t = *(undefined4 *)(Text->Flags).t;
  *(undefined4 *)((ptr2->Flags).t + 4) = *(undefined4 *)((Text->Flags).t + 4);
  ptr2->net = Text->net;
  ptr2->Scale = Text->Scale;
  ptr2->X = Text->X;
  ptr2->Y = Text->Y;
  *(undefined4 *)&ptr2->Direction = *(undefined4 *)&Text->Direction;
  ptr2->TextString = Text->TextString;
  ptr2->Element = Text->Element;
  pTVar1 = Layer->Text;
  CVar4 = Layer->TextN - 1;
  Layer->TextN = CVar4;
  if (pTVar1 + CVar4 != Text) {
    (Text->BoundingBox).X1 = pTVar1[CVar4].BoundingBox.X1;
    (Text->BoundingBox).Y1 = pTVar1[CVar4].BoundingBox.Y1;
    (Text->BoundingBox).X2 = pTVar1[CVar4].BoundingBox.X2;
    (Text->BoundingBox).Y2 = pTVar1[CVar4].BoundingBox.Y2;
    Text->ID = pTVar1[CVar4].ID;
    (Text->Flags).f = pTVar1[CVar4].Flags.f;
    *(undefined4 *)(Text->Flags).t = *(undefined4 *)pTVar1[CVar4].Flags.t;
    *(undefined4 *)((Text->Flags).t + 4) = *(undefined4 *)(pTVar1[CVar4].Flags.t + 4);
    Text->net = pTVar1[CVar4].net;
    Text->Scale = pTVar1[CVar4].Scale;
    Text->X = pTVar1[CVar4].X;
    Text->Y = pTVar1[CVar4].Y;
    *(undefined4 *)&Text->Direction = *(undefined4 *)&pTVar1[CVar4].Direction;
    Text->TextString = pTVar1[CVar4].TextString;
    Text->Element = pTVar1[CVar4].Element;
    r_substitute(Layer->text_tree,(BoxType *)(Layer->Text + Layer->TextN),(BoxType *)Text);
    CVar4 = Layer->TextN;
  }
  pBVar8 = (BoxType *)((int)&Layer->Text->BoundingBox + CVar4 * 0x3c);
  uVar6 = 0x3c;
  bVar9 = ((uint)pBVar8 & 1) != 0;
  if (bVar9) {
    uVar6 = 0x3b;
    *(undefined *)&pBVar8->X1 = 0;
    pBVar8 = (BoxType *)((int)&pBVar8->X1 + 1);
  }
  if (((uint)pBVar8 & 2) != 0) {
    *(undefined2 *)&pBVar8->X1 = 0;
    uVar6 = uVar6 - 2;
    pBVar8 = (BoxType *)((int)&pBVar8->X1 + 2);
  }
  uVar5 = uVar6 >> 2;
  while (uVar5 != 0) {
    uVar5 = uVar5 - 1;
    pBVar8->X1 = 0;
    pBVar8 = (BoxType *)(&pBVar8->X1 + (uint)bVar10 * 0x3ffffffe + 1);
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)&pBVar8->X1 = 0;
    pBVar8 = (BoxType *)((int)&pBVar8->X1 + 2);
  }
  if (bVar9) {
    *(undefined *)&pBVar8->X1 = 0;
  }
  pCVar7 = &pDVar2->ViaN + iVar3 * 0x17;
  rtree = (rtree_t *)pCVar7[0x21];
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    *(rtree_t **)(pCVar7 + 0x21) = rtree;
  }
  r_insert_entry(rtree,(BoxType *)ptr2,0);
  ClearFromPolygon((DataType *)Dest,0x10,Layer_00,ptr2);
  return ptr2;
}



void * MoveLineToBuffer(LayerTypePtr Layer,LineTypePtr Line)

{
  LayerTypePtr Layer_00;
  DataTypePtr *pDVar1;
  int iVar2;
  LineTypePtr ptr2;
  rtree_t *rtree;
  int iVar3;
  uint uVar4;
  uint uVar5;
  Cardinal *pCVar6;
  LineTypePtr pLVar7;
  Cardinal CVar8;
  LineTypePtr pLVar9;
  BoxType *pBVar10;
  bool bVar11;
  byte bVar12;
  
  bVar12 = 0;
  RestoreToPolygon((DataType *)Source,4,Layer,Line);
  r_delete_entry(Layer->line_tree,(BoxType *)Line);
  pDVar1 = Dest;
  iVar2 = GetLayerNumber(Source,Layer);
  Layer_00 = (LayerTypePtr)(&pDVar1->field_0x4c + iVar2 * 0x5c);
  ptr2 = GetLineMemory(Layer_00);
  iVar3 = 0x16;
  pLVar7 = Line;
  pLVar9 = ptr2;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    (pLVar9->BoundingBox).X1 = (pLVar7->BoundingBox).X1;
    pLVar7 = (LineTypePtr)((int)pLVar7 + (uint)bVar12 * -8 + 4);
    pLVar9 = (LineTypePtr)((int)pLVar9 + (uint)bVar12 * -8 + 4);
  }
  CVar8 = Layer->LineN;
  pLVar7 = Layer->Line;
  (ptr2->Flags).f = (ptr2->Flags).f & 0xfffffffb;
  CVar8 = CVar8 - 1;
  Layer->LineN = CVar8;
  if (pLVar7 + CVar8 != Line) {
    iVar3 = 0x16;
    pLVar7 = pLVar7 + CVar8;
    pLVar9 = Line;
    while (iVar3 != 0) {
      iVar3 = iVar3 + -1;
      (pLVar9->BoundingBox).X1 = (pLVar7->BoundingBox).X1;
      pLVar7 = (LineTypePtr)((int)pLVar7 + (uint)bVar12 * -8 + 4);
      pLVar9 = (LineTypePtr)((int)pLVar9 + (uint)bVar12 * -8 + 4);
    }
    r_substitute(Layer->line_tree,(BoxType *)(Layer->Line + Layer->LineN),(BoxType *)Line);
    CVar8 = Layer->LineN;
  }
  pBVar10 = (BoxType *)((int)&Layer->Line->BoundingBox + CVar8 * 0x58);
  uVar5 = 0x58;
  bVar11 = ((uint)pBVar10 & 1) != 0;
  if (bVar11) {
    *(undefined *)&pBVar10->X1 = 0;
    pBVar10 = (BoxType *)((int)&pBVar10->X1 + 1);
    uVar5 = 0x57;
  }
  if (((uint)pBVar10 & 2) != 0) {
    *(undefined2 *)&pBVar10->X1 = 0;
    uVar5 = uVar5 - 2;
    pBVar10 = (BoxType *)((int)&pBVar10->X1 + 2);
  }
  uVar4 = uVar5 >> 2;
  while (uVar4 != 0) {
    uVar4 = uVar4 - 1;
    pBVar10->X1 = 0;
    pBVar10 = (BoxType *)(&pBVar10->X1 + (uint)bVar12 * 0x3ffffffe + 1);
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)&pBVar10->X1 = 0;
    pBVar10 = (BoxType *)((int)&pBVar10->X1 + 2);
  }
  if (bVar11) {
    *(undefined *)&pBVar10->X1 = 0;
  }
  pCVar6 = &pDVar1->ViaN + iVar2 * 0x17;
  rtree = (rtree_t *)pCVar6[0x20];
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    *(rtree_t **)(pCVar6 + 0x20) = rtree;
  }
  r_insert_entry(rtree,(BoxType *)ptr2,0);
  ClearFromPolygon((DataType *)Dest,4,Layer_00,ptr2);
  return ptr2;
}



void FreeRotateElementLowLevel
               (DataTypePtr *Data,ElementTypePtr *Element,LocationType X,LocationType Y,double cosa,
               double sina,double Angle)

{
  int iVar1;
  double dVar2;
  double dVar3;
  LineTypePtr Line;
  uint uVar4;
  FontTypePtr Font;
  int *piVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  PinTypePtr_conflict Pin;
  PadTypePtr *ptr2;
  double local_54;
  uint local_4c;
  double local_44;
  
  iVar7 = Element->LineN - 1;
  if (iVar7 != -1) {
    iVar8 = Element->LineN * 0x58;
    do {
      iVar7 = iVar7 + -1;
      Line = (LineTypePtr)((int)&Element->Line[-1].BoundingBox.X1 + iVar8);
      dVar2 = (double)((Line->Point1).X - X);
      dVar3 = (double)((Line->Point1).Y - Y);
      iVar1 = (Line->Point2).X;
      (Line->Point1).X = (int)ROUND(sina * dVar3 + cosa * dVar2 + (double)X);
      (Line->Point1).Y = (int)ROUND((dVar3 * cosa - dVar2 * sina) + (double)Y);
      dVar2 = (double)(iVar1 - X);
      dVar3 = (double)((Line->Point2).Y - Y);
      (Line->Point2).X = (int)ROUND(sina * dVar3 + cosa * dVar2 + (double)X);
      (Line->Point2).Y = (int)ROUND((dVar3 * cosa - dVar2 * sina) + (double)Y);
      SetLineBoundingBox(Line);
      iVar8 = iVar8 + -0x58;
    } while (iVar7 != -1);
  }
  local_44 = (double)X;
  local_54 = (double)Y;
  if (Element->PinN != 0) {
    uVar6 = 0;
    local_4c = Element->PinN;
    do {
      Pin = (PinTypePtr_conflict)(Element->Pin + uVar6);
      if (Data != (DataTypePtr *)0x0) {
        r_delete_entry(Data->pin_tree,(BoxType *)Pin);
      }
      RestoreToPolygon((DataType *)Data,0x100,Element,Pin);
      dVar3 = (double)(Pin->X - X);
      dVar2 = (double)(Pin->Y - Y);
      Pin->X = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
      Pin->Y = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
      SetPinBoundingBox(Pin);
      uVar4 = Element->PinN;
    } while ((uVar4 != 0) &&
            (uVar6 = (uVar4 + 1 + uVar6) - local_4c, local_4c = uVar4, uVar6 < uVar4));
  }
  uVar6 = Element->PadN;
  local_4c = 0;
  uVar4 = uVar6;
  while ((uVar4 != 0 && (local_4c < uVar4))) {
    ptr2 = Element->Pad + local_4c;
    if (Data != (DataTypePtr *)0x0) {
      r_delete_entry(Data->pad_tree,(BoxType *)ptr2);
    }
    RestoreToPolygon((DataType *)Data,0x200,Element,ptr2);
    dVar3 = (double)((ptr2->Point1).X - X);
    dVar2 = (double)((ptr2->Point1).Y - Y);
    iVar7 = (ptr2->Point2).X;
    (ptr2->Point1).X = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
    (ptr2->Point1).Y = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
    dVar3 = (double)(iVar7 - X);
    dVar2 = (double)((ptr2->Point2).Y - Y);
    (ptr2->Point2).X = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
    (ptr2->Point2).Y = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
    SetLineBoundingBox((LineTypePtr)ptr2);
    uVar4 = Element->PadN;
    if (Element->PadN == uVar6) {
      local_4c = local_4c + 1;
      uVar4 = uVar6;
    }
  }
  iVar7 = Element->ArcN - 1;
  if (iVar7 != -1) {
    piVar5 = &Element->Arc[Element->ArcN - 1].X;
    do {
      iVar8 = *piVar5;
      iVar7 = iVar7 + -1;
      *piVar5 = (int)ROUND(sina * (double)(piVar5[1] - Y) + cosa * (double)(iVar8 - X) + local_44);
      piVar5[1] = (int)ROUND(((double)(piVar5[1] - Y) * cosa - (double)(iVar8 - X) * sina) +
                             local_54);
      piVar5[2] = (int)ROUND((double)piVar5[2] + Angle) % 0x168;
      piVar5 = piVar5 + -0x11;
    } while (iVar7 != -1);
  }
  dVar3 = (double)(Element->MarkX - X);
  dVar2 = (double)(Element->MarkY - Y);
  Font = (FontTypePtr)&PCB->Font;
  Element->MarkX = (int)ROUND(sina * dVar2 + cosa * dVar3 + local_44);
  Element->MarkY = (int)ROUND((dVar2 * cosa - dVar3 * sina) + local_54);
  SetElementBoundingBox(Data,(ElementTypePtr_conflict)Element,Font);
  ClearFromPolygon((DataType *)Data,2,Element,Element);
  return;
}



void InitBuffers(void)

{
  Buffers[0].Data = CreateNewBuffer();
  Buffers[1].Data = CreateNewBuffer();
  Buffers[2].Data = CreateNewBuffer();
  Buffers[3].Data = CreateNewBuffer();
  Buffers[4].Data = CreateNewBuffer();
  return;
}



void RotateBuffer(BufferTypePtr Buffer,BYTE Number)

{
  uint uVar1;
  int iVar2;
  DataTypePtr *Data;
  PCBTypePtr pPVar3;
  byte bVar4;
  int iVar5;
  int iVar6;
  undefined *puVar7;
  PinTypePtr_conflict Pin;
  LineTypePtr Line;
  ArcTypePtr *Arc;
  TextTypePtr Text;
  PolygonTypePtr Polygon;
  uint uVar8;
  int iVar9;
  uint local_2c;
  uint local_24;
  
  Data = Buffer->Data;
  if (Data->ViaN != 0) {
    uVar8 = 0;
    bVar4 = Number & 3;
    local_2c = Data->ViaN;
    do {
      Pin = (PinTypePtr_conflict)(Data->Via + uVar8);
      r_delete_entry(Data->via_tree,(BoxType *)Pin);
      iVar9 = Buffer->Y;
      iVar6 = Buffer->X;
      iVar5 = Pin->Y - iVar9;
      iVar2 = Pin->X - iVar6;
      if (bVar4 == 2) {
        Pin->X = iVar6 - iVar2;
        Pin->Y = iVar9 - iVar5;
      }
      else {
        if (bVar4 == 3) {
          Pin->X = iVar6 - iVar5;
          Pin->Y = iVar2 + iVar9;
        }
        else {
          if (bVar4 == 1) {
            Pin->X = iVar5 + iVar6;
            Pin->Y = iVar9 - iVar2;
          }
        }
      }
      SetPinBoundingBox(Pin);
      r_insert_entry(Buffer->Data->via_tree,(BoxType *)Pin,0);
      Data = Buffer->Data;
      uVar1 = Data->ViaN;
    } while ((uVar1 != 0) &&
            (uVar8 = (uVar1 + 1 + uVar8) - local_2c, local_2c = uVar1, uVar8 < uVar1));
  }
  iVar9 = Data->ElementN - 1;
  if (iVar9 != -1) {
    iVar6 = Data->ElementN * 300;
    while( true ) {
      iVar9 = iVar9 + -1;
      RotateElementLowLevel
                (Data,(ElementTypePtr *)((int)&Data->Element[-1].BoundingBox.X1 + iVar6),Buffer->X,
                 Buffer->Y,Number);
      if (iVar9 == -1) break;
      Data = Buffer->Data;
      iVar6 = iVar6 + -300;
    }
    Data = Buffer->Data;
  }
  iVar9 = &Data->field_0x4c;
  if (PCB->Data->LayerN != -2) {
    local_24 = 0;
    pPVar3 = PCB;
    while( true ) {
      iVar6 = *(int *)(iVar9 + 4) + -1;
      if (iVar6 != -1) {
        iVar2 = *(int *)(iVar9 + 4) * 0x58;
        do {
          iVar2 = iVar2 + -0x58;
          Line = (LineTypePtr)(*(int *)(iVar9 + 0x24) + iVar2);
          r_delete_entry(*(rtree_t **)(iVar9 + 0x34),(BoxType *)Line);
          RotateLineLowLevel(Line,Buffer->X,Buffer->Y,Number);
          r_insert_entry(*(rtree_t **)(iVar9 + 0x34),(BoxType *)Line,0);
          iVar6 = iVar6 + -1;
          pPVar3 = PCB;
        } while (iVar6 != -1);
      }
      local_24 = local_24 + 1;
      iVar6 = pPVar3->Data->LayerN;
      if (iVar6 + 2U <= local_24) break;
      iVar9 = iVar9 + 0x5c;
    }
    iVar9 = &Buffer->Data->field_0x4c;
    if (iVar6 != -2) {
      local_24 = 0;
      while( true ) {
        iVar6 = *(int *)(iVar9 + 0x10) + -1;
        if (iVar6 != -1) {
          iVar2 = *(int *)(iVar9 + 0x10) * 0x44;
          do {
            iVar2 = iVar2 + -0x44;
            Arc = (ArcTypePtr *)(*(int *)(iVar9 + 0x30) + iVar2);
            r_delete_entry(*(rtree_t **)(iVar9 + 0x40),(BoxType *)Arc);
            RotateArcLowLevel(Arc,Buffer->X,Buffer->Y,Number);
            r_insert_entry(*(rtree_t **)(iVar9 + 0x40),(BoxType *)Arc,0);
            iVar6 = iVar6 + -1;
            pPVar3 = PCB;
          } while (iVar6 != -1);
        }
        local_24 = local_24 + 1;
        iVar6 = pPVar3->Data->LayerN;
        if (iVar6 + 2U <= local_24) break;
        iVar9 = iVar9 + 0x5c;
      }
      iVar9 = &Buffer->Data->field_0x4c;
      if (iVar6 != -2) {
        local_24 = 0;
        while( true ) {
          iVar6 = *(int *)(iVar9 + 8) + -1;
          if (iVar6 != -1) {
            puVar7 = (undefined *)(*(int *)(iVar9 + 8) * 0x3c);
            do {
              puVar7 = &DAT_ffffffc4 + (int)puVar7;
              Text = (TextTypePtr)(puVar7 + *(int *)(iVar9 + 0x28));
              r_delete_entry(*(rtree_t **)(iVar9 + 0x38),(BoxType *)Text);
              RotateTextLowLevel(Text,Buffer->X,Buffer->Y,Number);
              r_insert_entry(*(rtree_t **)(iVar9 + 0x38),(BoxType *)Text,0);
              iVar6 = iVar6 + -1;
              pPVar3 = PCB;
            } while (iVar6 != -1);
          }
          local_24 = local_24 + 1;
          iVar6 = pPVar3->Data->LayerN;
          if (iVar6 + 2U <= local_24) break;
          iVar9 = iVar9 + 0x5c;
        }
        iVar9 = &Buffer->Data->field_0x4c;
        if (iVar6 != -2) {
          local_24 = 0;
          while( true ) {
            iVar6 = *(int *)(iVar9 + 0xc) + -1;
            if (iVar6 != -1) {
              puVar7 = (undefined *)(*(int *)(iVar9 + 0xc) * 0x3c);
              do {
                puVar7 = &DAT_ffffffc4 + (int)puVar7;
                Polygon = (PolygonTypePtr)(puVar7 + *(int *)(iVar9 + 0x2c));
                r_delete_entry(*(rtree_t **)(iVar9 + 0x3c),(BoxType *)Polygon);
                RotatePolygonLowLevel(Polygon,Buffer->X,Buffer->Y,Number);
                r_insert_entry(*(rtree_t **)(iVar9 + 0x3c),(BoxType *)Polygon,0);
                iVar6 = iVar6 + -1;
                pPVar3 = PCB;
              } while (iVar6 != -1);
            }
            local_24 = local_24 + 1;
            if (pPVar3->Data->LayerN + 2U <= local_24) break;
            iVar9 = iVar9 + 0x5c;
          }
        }
      }
    }
  }
  RotateBoxLowLevel((BoxTypePtr)&Buffer->BoundingBox,Buffer->X,Buffer->Y,Number);
  return;
}



void AddSelectedToBuffer(BufferTypePtr Buffer,LocationType X,LocationType Y,Boolean LeaveSelected)

{
  if (LeaveSelected == '\0') {
    ExtraFlag = 0x40;
  }
  HideCrosshair('\x01');
  Source = PCB->Data;
  Dest = Buffer->Data;
  SelectedOperation((ObjectFunctionTypePtr *)&AddBufferFunctions,'\0',-1);
  if ((Y == 0) && (X == 0)) {
    Buffer->X = Crosshair.X;
    Buffer->Y = Crosshair.Y;
  }
  else {
    Buffer->X = X;
    Buffer->Y = Y;
  }
  RestoreCrosshair('\x01');
  ExtraFlag = 0;
  return;
}



void ClearBuffer(BufferTypePtr Buffer)

{
  if ((Buffer != (BufferTypePtr)0x0) && (Buffer->Data != (DataTypePtr *)0x0)) {
    FreeDataMemory(Buffer->Data);
    *(PCBTypePtr *)&Buffer->Data->field_0x48 = PCB;
  }
  return;
}



Boolean LoadLayoutToBuffer(BufferTypePtr Buffer,char *Filename)

{
  PCBTypePtr Ptr;
  int iVar1;
  
  Ptr = CreateNewPCB('\0');
  iVar1 = ParsePCB(Ptr,Filename);
  if (iVar1 != 0) {
    RemovePCB(Ptr);
    *(PCBTypePtr *)&Buffer->Data->field_0x48 = PCB;
    return '\0';
  }
  ClearBuffer(Buffer);
  SaveFree(Buffer->Data);
  Buffer->Data = Ptr->Data;
  Ptr->Data = (DataTypePtr *)0x0;
  Buffer->X = Ptr->CursorX;
  Buffer->Y = Ptr->CursorY;
  RemovePCB(Ptr);
  *(PCBTypePtr *)&Buffer->Data->field_0x48 = PCB;
  return '\x01';
}



Boolean SmashBufferElement(BufferTypePtr Buffer)

{
  int iVar1;
  DataTypePtr *pDVar2;
  ElementTypePtr *Element;
  uint uVar3;
  Cardinal CVar4;
  Cardinal CVar5;
  DataTypePtr *pDVar6;
  int iVar7;
  Boolean BVar8;
  char *pcVar9;
  Cardinal CVar10;
  PinTypePtr *pPVar11;
  Cardinal CVar12;
  LayerTypePtr Layer;
  LineTypePtr pLVar13;
  int iVar14;
  uint uVar15;
  int iVar16;
  int in_GS_OFFSET;
  LayerTypePtr slayer;
  int local_80;
  uint local_7c;
  FlagType local_6c [2];
  ulong local_50;
  undefined4 local_4c;
  undefined4 local_48;
  ulong local_44;
  undefined4 local_40;
  undefined4 local_3c;
  ulong local_38;
  undefined4 local_34;
  undefined4 local_30;
  FlagType f;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pDVar2 = Buffer->Data;
  if (pDVar2->ElementN == 1) {
    Element = pDVar2->Element;
    pDVar2->ElementN = 0;
    ClearBuffer(Buffer);
    iVar16 = Element->LineN - 1;
    if (iVar16 != -1) {
      iVar7 = Element->LineN * 0x58;
      do {
        iVar14 = (int)&Element->Line[-1].BoundingBox.X1 + iVar7;
        MakeFlags((FlagType *)&local_38,0);
        iVar16 = iVar16 + -1;
        CreateNewLineOnLayer
                  ((LayerTypePtr)
                   (&Buffer->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c),
                   *(LocationType *)(iVar14 + 0x2c),*(LocationType *)(iVar14 + 0x30),
                   *(LocationType *)(iVar14 + 0x40),*(LocationType *)(iVar14 + 0x44),
                   *(BDimension *)(iVar14 + 0x24),0,
                   (FlagType)CONCAT48(local_30,CONCAT44(local_34,local_38)));
        pcVar9 = MyStrdup(Element->Name[1].TextString,"SmashBuffer");
        *(char **)(iVar14 + 0x54) = pcVar9;
        iVar7 = iVar7 + -0x58;
      } while (iVar16 != -1);
    }
    iVar16 = Element->ArcN - 1;
    if (iVar16 != -1) {
      iVar7 = Element->ArcN * 0x44;
      do {
        iVar14 = (int)&Element->Arc[-1].BoundingBox.X1 + iVar7;
        MakeFlags((FlagType *)&local_44,0);
        iVar16 = iVar16 + -1;
        CreateNewArcOnLayer((LayerTypePtr)
                            (&Buffer->Data->field_0x4c +
                            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c),
                            *(LocationType *)(iVar14 + 0x34),*(LocationType *)(iVar14 + 0x38),
                            *(BDimension *)(iVar14 + 0x2c),*(BDimension *)(iVar14 + 0x30),
                            *(int *)(iVar14 + 0x3c),*(int *)(iVar14 + 0x40),
                            *(BDimension *)(iVar14 + 0x24),0,
                            (FlagType)CONCAT48(local_3c,CONCAT44(local_40,local_44)));
        iVar7 = iVar7 + -0x44;
      } while (iVar16 != -1);
    }
    if (Element->PinN != 0) {
      uVar15 = 0;
      CVar10 = Element->PinN;
      do {
        pPVar11 = Element->Pin + uVar15;
        MakeFlags(&f,0);
        AddFlags(local_6c,(FlagType)CONCAT48(f.t._4_4_,CONCAT44(f.t._0_4_,f.f)),2);
        if ((*(byte *)&(pPVar11->Flags).f & 8) != 0) {
          AddFlags(local_6c,(FlagType)CONCAT48(f.t._4_4_,CONCAT44(f.t._0_4_,f.f)),8);
        }
        CreateNewVia(Buffer->Data,pPVar11->X,pPVar11->Y,pPVar11->Thickness,pPVar11->Clearance,
                     pPVar11->Mask,pPVar11->DrillingHole,pPVar11->Number,
                     (FlagType)CONCAT48(f.t._4_4_,CONCAT44(f.t._0_4_,f.f)));
        uVar3 = Element->PinN;
      } while ((uVar3 != 0) &&
              (uVar15 = (uVar3 + 1 + uVar15) - CVar10, CVar10 = uVar3, uVar15 < uVar3));
    }
    iVar16 = GetLayerGroupNumberByNumber
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN);
    pDVar2 = Buffer->Data;
    CVar10 = (PCB->LayerGroups).Entries[iVar16 * 0x12];
    iVar16 = GetLayerGroupNumberByNumber
                       ((uint)(Settings.ShowSolderSide != '\0') + PCB->Data->LayerN);
    CVar4 = Element->PadN;
    local_80 = 0;
    local_7c = 0;
    CVar5 = (PCB->LayerGroups).Entries[iVar16 * 0x12];
    pDVar6 = Buffer->Data;
    CVar12 = CVar4;
    while ((CVar12 != 0 && (local_7c < CVar12))) {
      iVar16 = (int)&(Element->Pad->BoundingBox).X1 + local_80;
      MakeFlags((FlagType *)&local_50,0);
      Layer = (LayerTypePtr)(&pDVar6->field_0x4c + CVar5 * 0x5c);
      if (-1 < *(char *)(iVar16 + 0x14)) {
        Layer = (LayerTypePtr)(&pDVar2->field_0x4c + CVar10 * 0x5c);
      }
      pLVar13 = CreateNewLineOnLayer
                          (Layer,*(LocationType *)(iVar16 + 0x2c),*(LocationType *)(iVar16 + 0x30),
                           *(LocationType *)(iVar16 + 0x40),*(LocationType *)(iVar16 + 0x44),
                           *(BDimension *)(iVar16 + 0x24),*(BDimension *)(iVar16 + 0x28),
                           (FlagType)CONCAT48(local_48,CONCAT44(local_4c,local_50)));
      if (pLVar13 != (LineTypePtr)0x0) {
        pcVar9 = MyStrdup(*(char **)(iVar16 + 0x5c),"SmashBuffer");
        pLVar13->Number = pcVar9;
      }
      CVar12 = Element->PadN;
      if (Element->PadN == CVar4) {
        local_7c = local_7c + 1;
        local_80 = local_80 + 0x68;
        CVar12 = CVar4;
      }
    }
    FreeElementMemory(Element);
    SaveFree(Element);
    BVar8 = '\x01';
  }
  else {
    Message("Error!  Buffer doesn\'t contain a single element\n");
    BVar8 = '\0';
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar8;
}



void SetBufferBoundingBox(BufferTypePtr Buffer)

{
  BoxTypePtr pBVar1;
  
  pBVar1 = GetDataBoundingBox(Buffer->Data);
  if (pBVar1 != (BoxTypePtr)0x0) {
    (Buffer->BoundingBox).X1 = pBVar1->X1;
    (Buffer->BoundingBox).Y1 = pBVar1->Y1;
    (Buffer->BoundingBox).X2 = pBVar1->X2;
    (Buffer->BoundingBox).Y2 = pBVar1->Y2;
  }
  return;
}



void MirrorBuffer(BufferTypePtr Buffer)

{
  DataTypePtr *pDVar1;
  int iVar2;
  PinTypePtr *pPVar3;
  int iVar4;
  ArcTypePtr *Arc;
  PointTypePtr pPVar5;
  PCBTypePtr pPVar6;
  DataTypePtr *pDVar7;
  uint uVar8;
  int iVar9;
  DataTypePtr *pDVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  PolygonTypePtr Polygon;
  uint uVar14;
  undefined *puVar15;
  uint local_28;
  int local_24;
  PCBTypePtr local_20;
  
  pPVar6 = PCB;
  pDVar1 = Buffer->Data;
  if (pDVar1->ElementN == 0) {
    pDVar10 = PCB->Data;
    iVar13 = pDVar10->LayerN;
    if (iVar13 + 1 < 0) {
LAB_080778c8:
      iVar12 = PCB->MaxHeight;
      Buffer->Y = iVar12 - Buffer->Y;
      uVar14 = pDVar1->ViaN;
      if (uVar14 != 0) {
        pPVar3 = pDVar1->Via;
        pPVar3->Y = iVar12 - pPVar3->Y;
        uVar8 = 1;
        while (uVar8 < uVar14) {
          uVar8 = uVar8 + 1;
          pPVar3[1].Y = iVar12 - pPVar3[1].Y;
          pPVar3 = pPVar3 + 1;
        }
      }
      iVar2 = &pDVar1->field_0x4c;
      if (iVar13 != -2) {
        uVar14 = 0;
        iVar11 = iVar2;
        while( true ) {
          iVar9 = *(int *)(iVar11 + 4) + -1;
          if (iVar9 != -1) {
            iVar4 = *(int *)(iVar11 + 4) * 0x58 + *(int *)(iVar11 + 0x24) + -0x2c;
            do {
              iVar9 = iVar9 + -1;
              *(int *)(iVar4 + 4) = iVar12 - *(int *)(iVar4 + 4);
              *(int *)(iVar4 + 0x18) = iVar12 - *(int *)(iVar4 + 0x18);
              iVar4 = iVar4 + -0x58;
            } while (iVar9 != -1);
          }
          uVar14 = uVar14 + 1;
          if (iVar13 + 2U <= uVar14) break;
          iVar11 = iVar11 + 0x5c;
        }
      }
      if (iVar13 != -2) {
        uVar14 = 0;
        local_20 = pPVar6;
        while( true ) {
          iVar13 = *(int *)(iVar2 + 0x10) + -1;
          if (iVar13 != -1) {
            iVar12 = *(int *)(iVar2 + 0x10) * 0x44;
            do {
              iVar12 = iVar12 + -0x44;
              iVar13 = iVar13 + -1;
              iVar11 = pPVar6->MaxHeight;
              Arc = (ArcTypePtr *)(*(int *)(iVar2 + 0x30) + iVar12);
              Arc->StartAngle = -Arc->StartAngle;
              Arc->Delta = -Arc->Delta;
              Arc->Y = iVar11 - Arc->Y;
              SetArcBoundingBox(Arc);
              pPVar6 = PCB;
            } while (iVar13 != -1);
            pDVar10 = PCB->Data;
            local_20 = PCB;
          }
          uVar14 = uVar14 + 1;
          if (pDVar10->LayerN + 2U <= uVar14) break;
          iVar2 = iVar2 + 0x5c;
        }
        local_24 = &Buffer->Data->field_0x4c;
        if (pDVar10->LayerN != -2) {
          local_28 = 0;
          while( true ) {
            iVar13 = *(int *)(local_24 + 0xc) + -1;
            if (iVar13 != -1) {
              puVar15 = (undefined *)(*(int *)(local_24 + 0xc) * 0x3c);
              do {
                local_20 = (PCBTypePtr)iVar13;
                puVar15 = &DAT_ffffffc4 + (int)puVar15;
                Polygon = (PolygonTypePtr)(puVar15 + *(int *)(local_24 + 0x2c));
                iVar13 = Polygon->PointN - 1;
                if (iVar13 != -1) {
                  pPVar5 = Polygon->Points + (Polygon->PointN - 1);
                  iVar12 = PCB->MaxHeight;
                  do {
                    iVar13 = iVar13 + -1;
                    pPVar5->Y = iVar12 - pPVar5->Y;
                    pPVar5 = pPVar5 + -1;
                  } while (iVar13 != -1);
                }
                SetPolygonBoundingBox(Polygon);
                iVar13 = (int)local_20 + -1;
                local_20 = PCB;
              } while (iVar13 != -1);
            }
            local_28 = local_28 + 1;
            if (local_20->Data->LayerN + 2U <= local_28) break;
            local_24 = local_24 + 0x5c;
          }
        }
      }
      SetBufferBoundingBox(Buffer);
      return;
    }
    iVar12 = *(int *)&pDVar1->field_0x54;
    iVar2 = 0;
    pDVar7 = pDVar1;
    while (iVar12 == 0) {
      iVar2 = iVar2 + 1;
      if (iVar13 + 1 < iVar2) goto LAB_080778c8;
      iVar12 = *(int *)&pDVar7->field_0xb0;
      pDVar7 = (DataTypePtr *)&pDVar7->field_0x5c;
    }
    Buffer = (BufferTypePtr)0x813e250;
  }
  else {
    Buffer = (BufferTypePtr)0x813e220;
  }
  Message((char *)Buffer);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __regparm3 SwapBuffer(BufferTypePtr Buffer)

{
  byte bVar1;
  Cardinal Layer;
  DataTypePtr *pDVar2;
  Cardinal CVar3;
  DataType *data;
  PointTypePtr pPVar4;
  uint uVar5;
  sbyte sVar6;
  int iVar7;
  PCBTypePtr pPVar8;
  int iVar9;
  DataTypePtr *pDVar10;
  uint *puVar11;
  uint uVar12;
  byte *pbVar13;
  int iVar14;
  PinTypePtr_conflict Pin;
  LineTypePtr Line;
  PolygonTypePtr Polygon;
  LayerType_conflict *pLVar15;
  byte *pbVar16;
  uint uVar17;
  ArcTypePtr *Arc;
  TextTypePtr Text;
  char **ppcVar18;
  Cardinal *pCVar19;
  ElementType *element;
  LayerType_conflict *pLVar20;
  undefined *puVar21;
  Cardinal *pCVar22;
  uint uVar23;
  byte bVar24;
  int local_c4;
  Cardinal local_c0;
  uint *local_bc;
  uint local_b8;
  int local_a0;
  uint *local_9c;
  byte local_94;
  byte local_90;
  uint local_88;
  undefined *local_84;
  DataType *local_80;
  LayerType_conflict swap;
  
  bVar24 = 0;
  data = (DataType *)Buffer->Data;
  iVar14 = data->ElementN - 1;
  if (iVar14 != -1) {
    iVar7 = data->ElementN * 300;
    while( true ) {
      iVar14 = iVar14 + -1;
      element = (ElementType *)((int)&data->Element[-1].BoundingBox.X1 + iVar7);
      r_delete_element(data,element);
      MirrorElementCoordinates(Buffer->Data,(ElementTypePtr *)element,0);
      if (iVar14 == -1) break;
      data = (DataType *)Buffer->Data;
      iVar7 = iVar7 + -300;
    }
    data = (DataType *)Buffer->Data;
  }
  pPVar8 = PCB;
  Buffer->Y = PCB->MaxHeight - Buffer->Y;
  if (data->ViaN != 0) {
    uVar17 = 0;
    local_80 = (DataType *)data->ViaN;
    do {
      Pin = (PinTypePtr_conflict)(data->Via + uVar17);
      r_delete_entry(data->via_tree,(BoxType *)Pin);
      Pin->Y = PCB->MaxHeight - Pin->Y;
      SetPinBoundingBox(Pin);
      r_insert_entry(Buffer->Data->via_tree,(BoxType *)Pin,0);
      data = (DataType *)Buffer->Data;
      uVar12 = data->ViaN;
      pPVar8 = PCB;
      if (uVar12 == 0) break;
      uVar17 = (uVar12 + 1 + uVar17) - (int)local_80;
      local_80 = (DataType *)uVar12;
    } while (uVar17 < uVar12);
  }
  pLVar15 = data->Layer;
  if (pPVar8->Data->LayerN != -2) {
    local_80 = (DataType *)0x0;
    while( true ) {
      iVar14 = pLVar15->LineN - 1;
      if (iVar14 != -1) {
        iVar7 = pLVar15->LineN * 0x58;
        do {
          iVar14 = iVar14 + -1;
          Line = (LineTypePtr)((int)&pLVar15->Line[-1].BoundingBox.X1 + iVar7);
          r_delete_entry(pLVar15->line_tree,(BoxType *)Line);
          iVar9 = PCB->MaxHeight;
          (Line->Point2).Y = iVar9 - (Line->Point2).Y;
          (Line->Point1).Y = iVar9 - (Line->Point1).Y;
          SetLineBoundingBox(Line);
          r_insert_entry(pLVar15->line_tree,(BoxType *)Line,0);
          pPVar8 = PCB;
          iVar7 = iVar7 + -0x58;
        } while (iVar14 != -1);
      }
      local_80 = (DataType *)((int)local_80 + 1);
      iVar14 = pPVar8->Data->LayerN;
      if (iVar14 + 2U <= local_80) break;
      pLVar15 = pLVar15 + 1;
    }
    data = (DataType *)Buffer->Data;
    pLVar15 = data->Layer;
    if (iVar14 != -2) {
      local_80 = (DataType *)0x0;
      while( true ) {
        iVar14 = pLVar15->ArcN - 1;
        if (iVar14 != -1) {
          iVar7 = pLVar15->ArcN * 0x44;
          do {
            iVar14 = iVar14 + -1;
            Arc = (ArcTypePtr *)((int)&pLVar15->Arc[-1].BoundingBox.X1 + iVar7);
            r_delete_entry(pLVar15->arc_tree,(BoxType *)Arc);
            pPVar8 = PCB;
            Arc->StartAngle = -Arc->StartAngle;
            Arc->Delta = -Arc->Delta;
            Arc->Y = pPVar8->MaxHeight - Arc->Y;
            SetArcBoundingBox(Arc);
            r_insert_entry(pLVar15->arc_tree,(BoxType *)Arc,0);
            pPVar8 = PCB;
            iVar7 = iVar7 + -0x44;
          } while (iVar14 != -1);
        }
        pDVar10 = pPVar8->Data;
        local_80 = (DataType *)((int)local_80 + 1);
        iVar14 = pDVar10->LayerN;
        if (iVar14 + 2U <= local_80) break;
        pLVar15 = pLVar15 + 1;
      }
      pLVar15 = ((DataType *)Buffer->Data)->Layer;
      local_80 = (DataType *)Buffer->Data;
      if (iVar14 != -2) {
        local_88 = 0;
        while( true ) {
          local_80 = (DataType *)(pLVar15->PolygonN - 1);
          if (local_80 != (DataType *)0xffffffff) {
            local_84 = (undefined *)(pLVar15->PolygonN * 0x3c);
            do {
              local_84 = &DAT_ffffffc4 + (int)local_84;
              Polygon = (PolygonTypePtr)(local_84 + (int)&(pLVar15->Polygon->BoundingBox).X1);
              r_delete_entry(pLVar15->polygon_tree,(BoxType *)Polygon);
              iVar14 = Polygon->PointN - 1;
              if (iVar14 != -1) {
                pPVar4 = Polygon->Points + (Polygon->PointN - 1);
                iVar7 = PCB->MaxHeight;
                do {
                  iVar14 = iVar14 + -1;
                  pPVar4->Y = iVar7 - pPVar4->Y;
                  pPVar4 = pPVar4 + -1;
                } while (iVar14 != -1);
              }
              SetPolygonBoundingBox(Polygon);
              r_insert_entry(pLVar15->polygon_tree,(BoxType *)Polygon,0);
              local_80 = (DataType *)((int)local_80 + -1);
              pPVar8 = PCB;
            } while (local_80 != (DataType *)0xffffffff);
          }
          pDVar10 = pPVar8->Data;
          local_88 = local_88 + 1;
          iVar14 = pDVar10->LayerN;
          if (iVar14 + 2U <= local_88) break;
          pLVar15 = pLVar15 + 1;
        }
        pLVar15 = ((DataType *)Buffer->Data)->Layer;
        local_80 = (DataType *)Buffer->Data;
        if (iVar14 != -2) {
          local_80 = (DataType *)0x0;
          while( true ) {
            iVar14 = pLVar15->TextN - 1;
            if (iVar14 != -1) {
              puVar21 = (undefined *)(pLVar15->TextN * 0x3c);
              do {
                puVar21 = &DAT_ffffffc4 + (int)puVar21;
                iVar14 = iVar14 + -1;
                Text = (TextTypePtr)(puVar21 + (int)&(pLVar15->Text->BoundingBox).X1);
                r_delete_entry(pLVar15->text_tree,(BoxType *)Text);
                pPVar8 = PCB;
                (Text->Flags).f = (Text->Flags).f ^ 0x80;
                Text->Y = pPVar8->MaxHeight - Text->Y;
                SetTextBoundingBox((FontTypePtr)&pPVar8->Font,Text);
                r_insert_entry(pLVar15->text_tree,(BoxType *)Text,0);
                pPVar8 = PCB;
              } while (iVar14 != -1);
            }
            pDVar10 = pPVar8->Data;
            local_80 = (DataType *)((int)local_80 + 1);
            iVar14 = pDVar10->LayerN;
            if (iVar14 + 2U <= local_80) break;
            pLVar15 = pLVar15 + 1;
          }
          local_80 = (DataType *)Buffer->Data;
        }
      }
      goto LAB_08077e81;
    }
  }
  pDVar10 = pPVar8->Data;
  iVar14 = pDVar10->LayerN;
  local_80 = data;
LAB_08077e81:
  iVar7 = 0x17;
  ppcVar18 = (char **)(&local_80->ViaN + iVar14 * 0x17 + 0x13);
  pLVar15 = &swap;
  while (iVar7 != 0) {
    iVar7 = iVar7 + -1;
    pLVar15->Name = *ppcVar18;
    ppcVar18 = ppcVar18 + (uint)bVar24 * 0x3ffffffe + 1;
    pLVar15 = (LayerType_conflict *)((int)pLVar15 + (uint)bVar24 * -8 + 4);
  }
  Layer = pDVar10->LayerN;
  iVar7 = 0x17;
  pLVar15 = local_80->Layer + iVar14 + 1;
  ppcVar18 = (char **)(&local_80->ViaN + iVar14 * 0x17 + 0x13);
  while (iVar7 != 0) {
    iVar7 = iVar7 + -1;
    *ppcVar18 = pLVar15->Name;
    pLVar15 = (LayerType_conflict *)((int)pLVar15 + (uint)bVar24 * -8 + 4);
    ppcVar18 = ppcVar18 + (uint)bVar24 * 0x3ffffffe + 1;
  }
  iVar14 = 0x17;
  pLVar15 = &swap;
  pLVar20 = local_80->Layer + Layer + 1;
  while (iVar14 != 0) {
    iVar14 = iVar14 + -1;
    pLVar20->Name = pLVar15->Name;
    pLVar15 = (LayerType_conflict *)((int)pLVar15 + (uint)bVar24 * -8 + 4);
    pLVar20 = (LayerType_conflict *)((int)pLVar20 + (uint)bVar24 * -8 + 4);
  }
  iVar14 = GetLayerGroupNumberByNumber(Layer);
  iVar7 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  pPVar8 = PCB;
  Layer = (PCB->LayerGroups).Number[iVar7];
  if ((Layer == (PCB->LayerGroups).Number[iVar14]) && (Layer != 0)) {
    pDVar10 = PCB->Data;
    local_c4 = 0;
    local_bc = (PCB->LayerGroups).Entries + iVar14 * 0x12;
    local_c0 = 0;
    do {
      iVar14 = iVar7 * 0x12 + local_c4;
      local_b8 = (pPVar8->LayerGroups).Entries[iVar14];
      uVar17 = *local_bc;
      uVar12 = pDVar10->LayerN;
      if (uVar17 < uVar12) {
        pDVar2 = Buffer->Data;
        iVar9 = 0x17;
        ppcVar18 = (char **)(&pDVar2->field_0x4c + uVar17 * 0x5c);
        pLVar15 = &swap;
        while (iVar9 != 0) {
          iVar9 = iVar9 + -1;
          pLVar15->Name = *ppcVar18;
          ppcVar18 = ppcVar18 + (uint)bVar24 * 0x3ffffffe + 1;
          pLVar15 = (LayerType_conflict *)((int)pLVar15 + (uint)bVar24 * -8 + 4);
        }
        if (uVar12 <= local_b8) {
          puVar11 = (pPVar8->LayerGroups).Entries + iVar14 + 1;
          do {
            local_b8 = *puVar11;
            local_c4 = local_c4 + 1;
            puVar11 = puVar11 + 1;
          } while (uVar12 <= local_b8);
        }
        iVar14 = 0x17;
        pCVar19 = &pDVar2->ViaN + local_b8 * 0x17 + 0x13;
        pCVar22 = (Cardinal *)(&pDVar2->field_0x4c + uVar17 * 0x5c);
        while (iVar14 != 0) {
          iVar14 = iVar14 + -1;
          *pCVar22 = *pCVar19;
          pCVar19 = pCVar19 + (uint)bVar24 * 0x3ffffffe + 1;
          pCVar22 = pCVar22 + (uint)bVar24 * 0x3ffffffe + 1;
        }
        CVar3 = pDVar2->ElementN;
        iVar14 = 0x17;
        pLVar15 = &swap;
        ppcVar18 = (char **)(&pDVar2->ViaN + local_b8 * 0x17 + 0x13);
        while (iVar14 != 0) {
          iVar14 = iVar14 + -1;
          *ppcVar18 = pLVar15->Name;
          pLVar15 = (LayerType_conflict *)((int)pLVar15 + (uint)bVar24 * -8 + 4);
          ppcVar18 = ppcVar18 + (uint)bVar24 * 0x3ffffffe + 1;
        }
        local_a0 = CVar3 - 1;
        local_c4 = local_c4 + 1;
        if (local_a0 != -1) {
          local_88._0_1_ = (sbyte)((uVar17 & 1) << 2);
          sVar6 = (sbyte)((local_b8 & 1) << 2);
          uVar12 = 0xf << sVar6;
          local_94 = (byte)(0xf << (sbyte)local_88);
          local_90 = (byte)uVar12;
          local_9c = &pDVar2->Element[CVar3 - 1].PinN;
          do {
            uVar5 = *local_9c;
            if (uVar5 != 0) {
              uVar23 = 0;
              pbVar16 = (byte *)(local_9c[8] + (uVar17 >> 1) + 0x18);
              pbVar13 = (byte *)(local_9c[8] + (local_b8 >> 1) + 0x18);
              do {
                bVar1 = *pbVar16;
                *pbVar16 = ((uVar12 & *pbVar13) != 0) << (sbyte)local_88 | ~local_94 & bVar1;
                uVar23 = uVar23 + 1;
                pbVar16 = pbVar16 + 0x4c;
                *pbVar13 = ((0xf << (sbyte)local_88 & (uint)bVar1) != 0) << sVar6 |
                           ~local_90 & *pbVar13;
                pbVar13 = pbVar13 + 0x4c;
              } while (uVar23 < uVar5);
            }
            local_a0 = local_a0 + -1;
            local_9c = local_9c + -0x4b;
          } while (local_a0 != -1);
        }
        uVar12 = pDVar2->ViaN;
        if (uVar12 != 0) {
          uVar23 = 0;
          local_88._0_1_ = (sbyte)((uVar17 & 1) << 2);
          sVar6 = (sbyte)((local_b8 & 1) << 2);
          uVar5 = 0xf << sVar6;
          pbVar16 = (pDVar2->Via->Flags).t + (uVar17 >> 1);
          pbVar13 = (pDVar2->Via->Flags).t + (local_b8 >> 1);
          do {
            bVar1 = *pbVar16;
            *pbVar16 = ((uVar5 & *pbVar13) != 0) << (sbyte)local_88 |
                       ~(byte)(0xf << (sbyte)local_88) & bVar1;
            uVar23 = uVar23 + 1;
            pbVar16 = pbVar16 + 0x4c;
            *pbVar13 = ((0xf << (sbyte)local_88 & (uint)bVar1) != 0) << sVar6 |
                       ~(byte)uVar5 & *pbVar13;
            pbVar13 = pbVar13 + 0x4c;
          } while (uVar23 < uVar12);
        }
      }
      local_c0 = local_c0 + 1;
      local_bc = local_bc + 1;
    } while (local_c0 != Layer);
  }
  SetBufferBoundingBox(Buffer);
  return;
}



void SwapBuffers(void)

{
  BufferType *Buffer;
  BufferTypePtr pBVar1;
  
  Buffer = Buffers;
  do {
    pBVar1 = (BufferTypePtr)Buffer + 1;
    SwapBuffer((BufferTypePtr)Buffer);
    Buffer = (BufferType *)pBVar1;
  } while (pBVar1 != (BufferTypePtr)&Progname);
  SetCrosshairRangeToBuffer();
  return;
}



void FreeRotateBuffer(BufferTypePtr Buffer,double Angle)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  double dVar7;
  double dVar8;
  PointTypePtr pPVar9;
  PCBTypePtr pPVar10;
  DataTypePtr *Data;
  int iVar11;
  undefined *puVar12;
  PinTypePtr_conflict Pin;
  int iVar13;
  LineTypePtr Line;
  BoxType *box;
  PolygonTypePtr Polygon;
  uint uVar14;
  uint local_68;
  double local_2c;
  double local_24 [2];
  
  sincos((Angle * 3.14159265) / 180.00000000,local_24,&local_2c);
  Data = Buffer->Data;
  if (Data->ViaN != 0) {
    uVar14 = 0;
    uVar6 = Data->ViaN;
    do {
      Pin = (PinTypePtr_conflict)(Data->Via + uVar14);
      r_delete_entry(Data->via_tree,(BoxType *)Pin);
      iVar13 = Buffer->Y;
      dVar8 = (double)(Pin->X - Buffer->X);
      dVar7 = (double)(Pin->Y - iVar13);
      Pin->X = (int)ROUND((double)Buffer->X + local_24[0] * dVar7 + local_2c * dVar8);
      Pin->Y = (int)ROUND((double)iVar13 + (dVar7 * local_2c - dVar8 * local_24[0]));
      SetPinBoundingBox(Pin);
      r_insert_entry(Buffer->Data->via_tree,(BoxType *)Pin,0);
      Data = Buffer->Data;
      uVar2 = Data->ViaN;
      if (uVar2 == 0) break;
      uVar14 = (uVar2 + 1 + uVar14) - uVar6;
      uVar6 = uVar2;
    } while (uVar14 < uVar2);
  }
  iVar13 = Data->ElementN - 1;
  if (iVar13 != -1) {
    iVar1 = Data->ElementN * 300;
    while( true ) {
      iVar13 = iVar13 + -1;
      FreeRotateElementLowLevel
                (Data,(ElementTypePtr *)((int)&Data->Element[-1].BoundingBox.X1 + iVar1),Buffer->X,
                 Buffer->Y,local_2c,local_24[0],Angle);
      if (iVar13 == -1) break;
      Data = Buffer->Data;
      iVar1 = iVar1 + -300;
    }
    Data = Buffer->Data;
  }
  iVar13 = &Data->field_0x4c;
  if (PCB->Data->LayerN != -2) {
    uVar6 = 0;
    pPVar10 = PCB;
    while( true ) {
      iVar1 = *(int *)(iVar13 + 4) + -1;
      if (iVar1 != -1) {
        iVar11 = *(int *)(iVar13 + 4) * 0x58;
        do {
          iVar11 = iVar11 + -0x58;
          Line = (LineTypePtr)(*(int *)(iVar13 + 0x24) + iVar11);
          r_delete_entry(*(rtree_t **)(iVar13 + 0x34),(BoxType *)Line);
          iVar3 = Buffer->Y;
          iVar4 = Buffer->X;
          dVar7 = (double)((Line->Point1).X - iVar4);
          dVar8 = (double)((Line->Point1).Y - iVar3);
          (Line->Point1).X = (int)ROUND(local_24[0] * dVar8 + local_2c * dVar7 + (double)iVar4);
          iVar5 = (Line->Point2).X;
          (Line->Point1).Y = (int)ROUND((dVar8 * local_2c - dVar7 * local_24[0]) + (double)iVar3);
          dVar8 = (double)(iVar5 - iVar4);
          dVar7 = (double)((Line->Point2).Y - iVar3);
          (Line->Point2).X = (int)ROUND(local_24[0] * dVar7 + local_2c * dVar8 + (double)iVar4);
          (Line->Point2).Y = (int)ROUND((double)iVar3 + (dVar7 * local_2c - dVar8 * local_24[0]));
          SetLineBoundingBox(Line);
          r_insert_entry(*(rtree_t **)(iVar13 + 0x34),(BoxType *)Line,0);
          iVar1 = iVar1 + -1;
          pPVar10 = PCB;
        } while (iVar1 != -1);
      }
      uVar6 = uVar6 + 1;
      iVar1 = pPVar10->Data->LayerN;
      if (iVar1 + 2U <= uVar6) break;
      iVar13 = iVar13 + 0x5c;
    }
    iVar13 = &Buffer->Data->field_0x4c;
    if (iVar1 != -2) {
      local_68 = 0;
      while( true ) {
        iVar1 = *(int *)(iVar13 + 0x10) + -1;
        if (iVar1 != -1) {
          iVar11 = *(int *)(iVar13 + 0x10) * 0x44;
          do {
            iVar11 = iVar11 + -0x44;
            box = (BoxType *)(iVar11 + *(int *)(iVar13 + 0x30));
            r_delete_entry(*(rtree_t **)(iVar13 + 0x40),box);
            iVar3 = Buffer->Y;
            dVar8 = (double)(box[3].Y1 - Buffer->X);
            dVar7 = (double)(box[3].X2 - iVar3);
            box[3].Y1 = (int)ROUND((double)Buffer->X + local_24[0] * dVar7 + local_2c * dVar8);
            box[3].X2 = (int)ROUND((double)iVar3 + (dVar7 * local_2c - dVar8 * local_24[0]));
            box[3].Y2 = (int)ROUND((double)box[3].Y2 + Angle) % 0x168;
            r_insert_entry(*(rtree_t **)(iVar13 + 0x40),box,0);
            iVar1 = iVar1 + -1;
            pPVar10 = PCB;
          } while (iVar1 != -1);
        }
        local_68 = local_68 + 1;
        iVar1 = pPVar10->Data->LayerN;
        if (iVar1 + 2U <= local_68) break;
        iVar13 = iVar13 + 0x5c;
      }
      iVar13 = &Buffer->Data->field_0x4c;
      if (iVar1 != -2) {
        local_68 = 0;
        while( true ) {
          iVar1 = *(int *)(iVar13 + 0xc) + -1;
          if (iVar1 != -1) {
            puVar12 = (undefined *)(*(int *)(iVar13 + 0xc) * 0x3c);
            do {
              puVar12 = &DAT_ffffffc4 + (int)puVar12;
              Polygon = (PolygonTypePtr)(puVar12 + *(int *)(iVar13 + 0x2c));
              r_delete_entry(*(rtree_t **)(iVar13 + 0x3c),(BoxType *)Polygon);
              iVar11 = Polygon->PointN - 1;
              if (iVar11 != -1) {
                pPVar9 = Polygon->Points + (Polygon->PointN - 1);
                iVar3 = Buffer->Y;
                iVar4 = Buffer->X;
                do {
                  iVar11 = iVar11 + -1;
                  dVar7 = (double)(pPVar9->X - iVar4);
                  dVar8 = (double)(pPVar9->Y - iVar3);
                  pPVar9->X = (int)ROUND(local_24[0] * dVar8 + local_2c * dVar7 + (double)iVar4);
                  pPVar9->Y = (int)ROUND((dVar8 * local_2c - dVar7 * local_24[0]) + (double)iVar3);
                  pPVar9 = pPVar9 + -1;
                } while (iVar11 != -1);
              }
              SetPolygonBoundingBox(Polygon);
              r_insert_entry(*(rtree_t **)(iVar13 + 0x3c),(BoxType *)Polygon,0);
              iVar1 = iVar1 + -1;
              pPVar10 = PCB;
            } while (iVar1 != -1);
          }
          local_68 = local_68 + 1;
          if (pPVar10->Data->LayerN + 2U <= local_68) break;
          iVar13 = iVar13 + 0x5c;
        }
      }
    }
  }
  SetBufferBoundingBox(Buffer);
  return;
}



int ActionFreeRotateBuffer(int argc,char **argv,int x,int y)

{
  double Angle;
  
  HideCrosshair('\0');
  Angle = strtod(*argv,(char **)0x0);
  FreeRotateBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),Angle);
  RestoreCrosshair('\0');
  return 0;
}



Boolean ConvertBufferToElement(BufferTypePtr Buffer)

{
  uint *puVar1;
  LocationType TextY;
  LocationType TextX;
  uint uVar2;
  Cardinal CVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  Boolean BVar7;
  ElementTypePtr *Element;
  DataTypePtr *pDVar8;
  int iVar9;
  int *piVar10;
  char *Number;
  uint uVar11;
  PointType *pPVar12;
  undefined *puVar13;
  PinTypePtr *pPVar14;
  int iVar15;
  int *piVar16;
  int Y1;
  uint uVar17;
  int iVar18;
  int X1;
  int Thickness;
  int in_GS_OFFSET;
  byte bVar19;
  int local_fc;
  DataTypePtr *local_ec;
  uint local_e4;
  undefined *local_d4;
  DataTypePtr *local_d0;
  PointType temp [4];
  ulong local_7c;
  LocationType local_78;
  LocationType local_74;
  LocationType local_70;
  long local_6c;
  undefined4 local_68;
  ulong local_64;
  undefined4 local_60;
  undefined4 local_5c;
  ulong local_58;
  undefined4 local_54;
  undefined4 local_50;
  ulong local_4c;
  undefined4 local_48;
  undefined4 local_44;
  ulong local_40;
  undefined4 local_3c;
  undefined4 local_38;
  ulong local_34;
  undefined4 local_30;
  undefined4 local_2c;
  char num [8];
  int local_20;
  
  bVar19 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (*(int *)&Buffer->Data->field_0x48 == 0) {
    *(PCBTypePtr *)&Buffer->Data->field_0x48 = PCB;
  }
  MakeFlags((FlagType *)&local_34,~-(uint)(Settings.ShowSolderSide == '\0') & 0x80);
  TextY = Buffers[Settings.BufferNumber].Y;
  TextX = Buffers[Settings.BufferNumber].X;
  MakeFlags((FlagType *)&local_40,0);
  Element = CreateNewElement(PCB->Data,(ElementTypePtr *)0x0,(FontTypePtr)&PCB->Font,
                             (FlagType)CONCAT48(local_38,CONCAT44(local_3c,local_40)),(char *)0x0,
                             (char *)0x0,(char *)0x0,TextX,TextY,'\0',100,
                             (FlagType)CONCAT48(local_2c,CONCAT44(local_30,local_34)),'\0');
  BVar7 = '\0';
  if (Element != (ElementTypePtr *)0x0) {
    X1 = 1;
    bVar4 = false;
    local_fc = 1;
    pDVar8 = Buffer->Data;
    uVar17 = 0;
    local_d0 = (DataTypePtr *)pDVar8->ViaN;
    if (pDVar8->ViaN != 0) {
      do {
        pPVar14 = pDVar8->Via + uVar17;
        if (pPVar14->Mask < pPVar14->Thickness) {
          pPVar14->Mask = pPVar14->Thickness + 600;
        }
        if (pPVar14->Name == (char *)0x0) {
          __sprintf_chk(num,1,8,&DAT_081538d1,X1);
          MaskFlags((FlagType *)&local_58,pPVar14->Flags,0x246);
          CreateNewPin(Element,pPVar14->X,pPVar14->Y,pPVar14->Thickness,pPVar14->Clearance,
                       pPVar14->Mask,pPVar14->DrillingHole,(char *)0x0,num,
                       (FlagType)CONCAT48(local_50,CONCAT44(local_54,local_58)));
          pDVar8 = Buffer->Data;
          uVar2 = pDVar8->ViaN;
          X1 = X1 + 1;
        }
        else {
          MaskFlags((FlagType *)&local_4c,pPVar14->Flags,0x246);
          CreateNewPin(Element,pPVar14->X,pPVar14->Y,pPVar14->Thickness,pPVar14->Clearance,
                       pPVar14->Mask,pPVar14->DrillingHole,(char *)0x0,pPVar14->Name,
                       (FlagType)CONCAT48(local_44,CONCAT44(local_48,local_4c)));
          pDVar8 = Buffer->Data;
          uVar2 = pDVar8->ViaN;
        }
      } while ((uVar2 != 0) &&
              (uVar17 = (uVar2 + 1 + uVar17) - (int)local_d0, local_d0 = (DataTypePtr *)uVar2,
              uVar17 < uVar2));
      bVar4 = true;
      local_fc = X1;
    }
    iVar9 = GetLayerGroupNumberByNumber((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN)
    ;
    local_ec = Buffer->Data;
    X1 = *(int *)&local_ec->field_0x48;
    if (*(int *)(X1 + 4 + (iVar9 + 0x734) * 4) == 0) {
      bVar6 = false;
      uVar17 = PCB->Data->LayerN;
    }
    else {
      local_e4 = 0;
      bVar6 = false;
      uVar17 = PCB->Data->LayerN;
      do {
        uVar2 = *(uint *)(X1 + 4 + (local_e4 + 0x744 + iVar9 * 0x12) * 4);
        if (uVar2 < uVar17) {
          CVar3 = (&local_ec->ViaN + uVar2 * 0x17)[0x14];
          X1 = CVar3 - 1;
          if (X1 != -1) {
            Thickness = CVar3 * 0x58;
            Y1 = local_fc;
            do {
              Thickness = Thickness + -0x58;
              iVar15 = Thickness + (&local_ec->ViaN + uVar2 * 0x17)[0x1c];
              __sprintf_chk(num,1,8,&DAT_081538d1,Y1);
              MakeFlags((FlagType *)&local_64,~-(uint)(Settings.ShowSolderSide == '\0') & 0x80);
              Number = *(char **)(iVar15 + 0x54);
              if (*(char **)(iVar15 + 0x54) == (char *)0x0) {
                Number = num;
              }
              X1 = X1 + -1;
              CreateNewPad(Element,*(LocationType *)(iVar15 + 0x2c),*(LocationType *)(iVar15 + 0x30)
                           ,*(LocationType *)(iVar15 + 0x40),*(LocationType *)(iVar15 + 0x44),
                           *(int *)(iVar15 + 0x24),*(int *)(iVar15 + 0x28),
                           *(int *)(iVar15 + 0x28) + *(int *)(iVar15 + 0x24),(char *)0x0,Number,
                           (FlagType)CONCAT48(local_5c,CONCAT44(local_60,local_64)));
              Y1 = Y1 + 1;
            } while (X1 != -1);
            local_fc = local_fc + CVar3;
            bVar4 = true;
          }
          CVar3 = (&local_ec->ViaN + uVar2 * 0x17)[0x16];
          local_d0 = (DataTypePtr *)(CVar3 - 1);
          if (local_d0 == (DataTypePtr *)0xffffffff) {
            uVar17 = PCB->Data->LayerN;
            local_ec = Buffer->Data;
          }
          else {
            local_d4 = (undefined *)(CVar3 * 0x3c);
            do {
              local_d4 = &DAT_ffffffc4 + (int)local_d4;
              puVar13 = local_d4 + (&local_ec->ViaN + uVar2 * 0x17)[0x1e];
              if (*(int *)(puVar13 + 0x24) == 4) {
                piVar10 = *(int **)(puVar13 + 0x38);
                uVar17 = 0;
                uVar11 = 1;
                piVar16 = piVar10;
                do {
                  if ((piVar16[5] < piVar10[uVar17 * 5]) || (piVar16[6] < (piVar10 + uVar17 * 5)[1])
                     ) {
                    uVar17 = uVar11;
                  }
                  uVar11 = uVar11 + 1;
                  piVar16 = piVar16 + 5;
                } while (uVar11 != 4);
                pPVar12 = temp;
                do {
                  uVar11 = uVar17 & 3;
                  pPVar12->X = piVar10[uVar11 * 5];
                  pPVar12->Y = piVar10[uVar11 * 5 + 1];
                  pPVar12->X2 = piVar10[uVar11 * 5 + 2];
                  pPVar12->Y2 = piVar10[uVar11 * 5 + 3];
                  pPVar12->ID = piVar10[uVar11 * 5 + 4];
                  pPVar12 = pPVar12 + 1;
                  uVar17 = uVar17 + 1;
                } while (pPVar12 != (PointType *)&local_7c);
                if (temp[0].X == temp[1].X) {
                  X1 = 0x14;
                  pPVar12 = temp;
                  while (X1 != 0) {
                    X1 = X1 + -1;
                    *piVar10 = pPVar12->X;
                    pPVar12 = (PointType *)((int)pPVar12 + (uint)bVar19 * -8 + 4);
                    piVar10 = piVar10 + (uint)bVar19 * 0x3ffffffe + 1;
                  }
                  piVar10 = *(int **)(puVar13 + 0x38);
                }
                else {
                  *piVar10 = temp[0].X;
                  piVar10[1] = temp[0].Y;
                  piVar10[2] = temp[0].X2;
                  piVar10[3] = temp[0].Y2;
                  piVar10[4] = temp[0].ID;
                  piVar10[5] = temp[3].X;
                  piVar10[6] = temp[3].Y;
                  piVar10[7] = temp[3].X2;
                  piVar10[8] = temp[3].Y2;
                  piVar10[9] = temp[3].ID;
                  piVar10[10] = temp[2].X;
                  piVar10[0xb] = temp[2].Y;
                  piVar10[0xc] = temp[2].X2;
                  piVar10[0xd] = temp[2].Y2;
                  piVar10[0xe] = temp[2].ID;
                  piVar10[0xf] = temp[1].X;
                  piVar10[0x10] = temp[1].Y;
                  piVar10[0x11] = temp[1].X2;
                  piVar10[0x12] = temp[1].Y2;
                  piVar10[0x13] = temp[1].ID;
                }
                X1 = *piVar10;
                if ((((X1 != piVar10[5]) || (piVar10[6] != piVar10[0xb])) ||
                    (piVar10[10] != piVar10[0xf])) || (Y1 = piVar10[0x10], Y1 != piVar10[1]))
                goto LAB_08078f08;
                iVar15 = piVar10[6] - Y1;
                iVar18 = piVar10[10] - X1;
                Thickness = iVar18;
                if (iVar15 <= iVar18) {
                  Thickness = iVar15;
                }
                X1 = X1 + Thickness / 2;
                Y1 = Y1 + Thickness / 2;
                __sprintf_chk(num,1,8,&DAT_081538d1,local_fc);
                local_fc = local_fc + 1;
                MakeFlags((FlagType *)(&local_7c + 0xc),
                          (-(uint)(Settings.ShowSolderSide == '\0') & 0xffffff80) + 0x180);
                CreateNewPad(Element,X1,Y1,(iVar18 - Thickness) + X1,(iVar15 - Thickness) + Y1,
                             Thickness,Settings.Keepaway * 2,Thickness + Settings.Keepaway,
                             (char *)0x0,num,
                             (FlagType)CONCAT48(local_68,CONCAT44(local_6c,local_70)));
                bVar4 = true;
              }
              else {
LAB_08078f08:
                bVar6 = true;
              }
              local_d0 = (DataTypePtr *)((int)local_d0 + -1);
            } while (local_d0 != (DataTypePtr *)0xffffffff);
            local_ec = Buffer->Data;
            uVar17 = PCB->Data->LayerN;
          }
        }
        local_e4 = local_e4 + 1;
        X1 = *(int *)&local_ec->field_0x48;
        puVar1 = (uint *)(X1 + 4 + (iVar9 + 0x734) * 4);
      } while (local_e4 <= *puVar1 && *puVar1 != local_e4);
    }
    iVar9 = GetLayerGroupNumberByNumber(uVar17 + (Settings.ShowSolderSide != '\0'));
    local_ec = Buffer->Data;
    X1 = *(int *)&local_ec->field_0x48;
    if (*(int *)(X1 + 4 + (iVar9 + 0x734) * 4) == 0) {
      local_d0 = PCB->Data;
      uVar17 = local_d0->LayerN;
    }
    else {
      local_d0 = PCB->Data;
      local_e4 = 0;
      uVar17 = local_d0->LayerN;
      do {
        uVar2 = *(uint *)(X1 + 4 + (local_e4 + 0x744 + iVar9 * 0x12) * 4);
        if (uVar2 < uVar17) {
          CVar3 = (&local_ec->ViaN + uVar2 * 0x17)[0x14];
          X1 = CVar3 - 1;
          if (X1 != -1) {
            Thickness = CVar3 * 0x58;
            bVar5 = false;
            Y1 = local_fc;
            do {
              Thickness = Thickness + -0x58;
              iVar15 = Thickness + (&local_ec->ViaN + uVar2 * 0x17)[0x1c];
              __sprintf_chk(num,1,8,&DAT_081538d1,Y1);
              MakeFlags((FlagType *)&local_7c,-(uint)(Settings.ShowSolderSide == '\0') & 0x80);
              Number = *(char **)(iVar15 + 0x54);
              if (*(char **)(iVar15 + 0x54) == (char *)0x0) {
                Number = num;
              }
              CreateNewPad(Element,*(LocationType *)(iVar15 + 0x2c),*(LocationType *)(iVar15 + 0x30)
                           ,*(LocationType *)(iVar15 + 0x40),*(LocationType *)(iVar15 + 0x44),
                           *(int *)(iVar15 + 0x24),*(int *)(iVar15 + 0x28),
                           *(int *)(iVar15 + 0x28) + *(int *)(iVar15 + 0x24),(char *)0x0,Number,
                           (FlagType)CONCAT48(local_74,CONCAT44(local_78,local_7c)));
              if ((!bVar5) && (!bVar4)) {
                Message(
                       "Warning: All of the pads are on the opposite\nside from the component - that\'s probably not what\nyou wanted\n"
                       );
                bVar5 = true;
              }
              X1 = X1 + -1;
              bVar4 = true;
              Y1 = Y1 + 1;
            } while (X1 != -1);
            local_fc = local_fc + CVar3;
            local_d0 = PCB->Data;
            local_ec = Buffer->Data;
            uVar17 = local_d0->LayerN;
          }
        }
        X1 = *(int *)&local_ec->field_0x48;
        local_e4 = local_e4 + 1;
        puVar1 = (uint *)(X1 + 4 + (iVar9 + 0x734) * 4);
      } while (local_e4 <= *puVar1 && *puVar1 != local_e4);
    }
    iVar9 = uVar17 + (Settings.ShowSolderSide == '\0');
    Y1 = *(int *)(&local_ec->field_0x50 + iVar9 * 0x5c);
    X1 = Y1 + -1;
    if (X1 != -1) {
      Y1 = Y1 * 0x58;
      while( true ) {
        Y1 = Y1 + -0x58;
        iVar9 = *(int *)(&local_ec->field_0x70 + ((Settings.ShowSolderSide == '\0') + uVar17) * 0x5c
                        ) + Y1;
        if ((*(char **)(iVar9 + 0x54) != (char *)0x0) &&
           (Element->Name[1].TextString == (char *)0x0)) {
          Number = MyStrdup(*(char **)(iVar9 + 0x54),"ConvertBufferToElement");
          Element->Name[1].TextString = Number;
        }
        X1 = X1 + -1;
        CreateNewLineInElement
                  (Element,*(LocationType *)(iVar9 + 0x2c),*(LocationType *)(iVar9 + 0x30),
                   *(LocationType *)(iVar9 + 0x40),*(LocationType *)(iVar9 + 0x44),
                   *(BDimension *)(iVar9 + 0x24));
        if (X1 == -1) break;
        local_ec = Buffer->Data;
        uVar17 = PCB->Data->LayerN;
      }
      bVar4 = true;
      local_d0 = PCB->Data;
      uVar17 = local_d0->LayerN;
      iVar9 = (Settings.ShowSolderSide == '\0') + uVar17;
      local_ec = Buffer->Data;
    }
    iVar9 = *(int *)(&local_ec->field_0x5c + iVar9 * 0x5c);
    X1 = iVar9 + -1;
    if (X1 == -1) {
      if (!bVar4) {
        DestroyObject(local_d0,2,Element,Element,Element);
        Message("There was nothing to convert!\nElements must have some silk, pads or pins.\n");
        BVar7 = '\0';
        goto LAB_080791ee;
      }
    }
    else {
      iVar9 = iVar9 * 0x44;
      while( true ) {
        iVar9 = iVar9 + -0x44;
        X1 = X1 + -1;
        Y1 = iVar9 + *(int *)(&local_ec->field_0x7c +
                             ((Settings.ShowSolderSide == '\0') + uVar17) * 0x5c);
        CreateNewArcInElement
                  (Element,*(LocationType *)(Y1 + 0x34),*(LocationType *)(Y1 + 0x38),
                   *(BDimension *)(Y1 + 0x2c),*(BDimension *)(Y1 + 0x30),*(int *)(Y1 + 0x3c),
                   *(int *)(Y1 + 0x40),*(BDimension *)(Y1 + 0x24));
        if (X1 == -1) break;
        local_ec = Buffer->Data;
        uVar17 = PCB->Data->LayerN;
      }
    }
    if (bVar6) {
      Message(
             "There were polygons that can\'t be made into pins!\nSo they were not included in the element\n"
             );
    }
    Element->MarkX = Buffer->X;
    Element->MarkY = Buffer->Y;
    if (Settings.ShowSolderSide != '\0') {
      (Element->Flags).f = (Element->Flags).f | 0x80;
    }
    SetElementBoundingBox(PCB->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&PCB->Font);
    ClearBuffer(Buffer);
    MoveObjectToBuffer(Buffer->Data,PCB->Data,2,Element,Element,Element);
    SetBufferBoundingBox(Buffer);
    BVar7 = '\x01';
  }
LAB_080791ee:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar7;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean LoadElementToBuffer(BufferTypePtr Buffer,char *Name,Boolean FromFile)

{
  ElementTypePtr *Element;
  int iVar1;
  DataTypePtr *Data;
  
  ClearBuffer(Buffer);
  if (FromFile == '\0') {
    iVar1 = ParseLibraryEntry(Buffer->Data,Name);
    if ((iVar1 == 0) && (Data = Buffer->Data, Data->ElementN != 0)) {
      Element = Data->Element;
      if (Settings.ShowSolderSide != '\0') {
        MirrorElementCoordinates(Data,Element,0);
        Data = Buffer->Data;
      }
      SetElementBoundingBox(Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&PCB->Font);
      Buffer->X = Element->MarkX;
      Buffer->Y = Element->MarkY;
      SetBufferBoundingBox(Buffer);
      return '\x01';
    }
  }
  else {
    iVar1 = ParseElementFile(Buffer->Data,Name);
    if (iVar1 == 0) {
      if (Settings.ShowSolderSide != '\0') {
        SwapBuffer(Buffer);
      }
      SetBufferBoundingBox(Buffer);
      if (Buffer->Data->ElementN != 0) {
        Element = Buffer->Data->Element;
        Buffer->X = Element->MarkX;
        Buffer->Y = Element->MarkY;
        return '\x01';
      }
      Buffer->X = 0;
      Buffer->Y = 0;
      return '\x01';
    }
  }
  ClearBuffer(Buffer);
  return '\0';
}



void * ChangeLineName(LayerTypePtr Layer,LineTypePtr Line)

{
  char *pcVar1;
  
  pcVar1 = Line->Number;
  Line->Number = NewName;
  return pcVar1;
}



void ChangePCBSize(BDimension Width,BDimension Height)

{
  PCBTypePtr pPVar1;
  LocationType MaxX;
  LocationType MaxY;
  
  pPVar1 = PCB;
  PCB->MaxWidth = Width;
  pPVar1->MaxHeight = Height;
  if (Settings.Mode == 5) {
    MaxY = Height + (Buffers[Settings.BufferNumber].Y -
                    Buffers[Settings.BufferNumber].BoundingBox.Y2);
    if (MaxY < 0) {
      MaxY = 0;
    }
    MaxX = Width + (Buffers[Settings.BufferNumber].X - Buffers[Settings.BufferNumber].BoundingBox.X2
                   );
    if (MaxX < 0) {
      MaxX = 0;
    }
    SetCrosshairRange(Buffers[Settings.BufferNumber].X -
                      Buffers[Settings.BufferNumber].BoundingBox.X1,
                      Buffers[Settings.BufferNumber].Y -
                      Buffers[Settings.BufferNumber].BoundingBox.Y1,MaxX,MaxY);
  }
  else {
    SetCrosshairRange(0,0,Width,Height);
  }
  hid_action("PCBChanged");
  return;
}



Boolean ChangeLayerName(LayerTypePtr Layer,char *Name)

{
  char **ppcVar1;
  
  if (PCB->SilkActive == '\0') {
    ppcVar1 = (char **)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    ppcVar1 = (char **)(&PCB->Data->field_0x4c +
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  *ppcVar1 = Name;
  hid_action("LayersChanged");
  return '\x01';
}



Boolean ChangeLayoutName(char *Name)

{
  PCB->Name = Name;
  hid_action("PCBChanged");
  return '\x01';
}



Boolean ClrObjectOctagon(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ClrOctagonFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean SetObjectOctagon(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&SetOctagonFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ChangeObjectOctagon(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeOctagonFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ClrObjectSquare(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ClrSquareFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean SetObjectSquare(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&SetSquareFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ChangeObjectSquare(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeSquareFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ClrObjectJoin(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ClrJoinFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean SetObjectJoin(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&SetJoinFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ChangeObjectJoin(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeJoinFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



void * ChangeObjectName(int Type,void *Ptr1,void *Ptr2,void *Ptr3,char *Name)

{
  void *pvVar1;
  
  NewName = Name;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeNameFunctions,Type,Ptr1,Ptr2,Ptr3);
  Draw();
  return pvVar1;
}



void * QueryInputAndChangeObjectName(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  char *Name;
  undefined1 *puVar4;
  uint uVar5;
  void *pvVar6;
  int in_GS_OFFSET;
  char *local_23c;
  char *local_238;
  anon_subr_char_ptr_char_ptr_char_ptr_for_prompt_for *local_234;
  char msg [513];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pvVar3 = Ptr1;
  pvVar6 = Ptr1;
  if (Type == 0x400) {
LAB_08079e18:
    Ptr2 = pvVar3;
    uVar2 = (PCB->Flags).f;
    if ((uVar2 & 0x40) == 0) {
      uVar5 = -(uint)((uVar2 & 0x20) == 0) & 2;
    }
    else {
      uVar5 = 1;
    }
    Name = "";
    if (*(int *)((int)Ptr2 + uVar5 * 0x3c + 0x58) != 0) {
      uVar5 = 1;
      if ((uVar2 & 0x40) == 0) {
        uVar5 = -(uint)((uVar2 & 0x20) == 0) & 2;
      }
      Name = *(char **)((int)Ptr2 + uVar5 * 0x3c + 0x58);
    }
    Name = (*gui->prompt_for)("Elementname:",Name);
    Type = 2;
    Ptr3 = pvVar6;
LAB_08079efd:
    if (Name != (char *)0x0) {
      Name = (char *)ChangeObjectName(Type,Ptr1,Ptr2,Ptr3,Name);
      if (Name != (char *)0xffffffff) {
        AddObjectToChangeNameUndoList(Type,Ptr1,Ptr2,Ptr3,Name);
        IncrementUndoSerialNumber();
      }
      Draw();
      goto LAB_08079dd9;
    }
  }
  else {
    if (Type == 4) {
      Name = *(char **)((int)Ptr2 + 0x54);
      if (Name == (char *)0x0) {
        Name = "";
      }
      Name = (*gui->prompt_for)("Linename:",Name);
      goto LAB_08079efd;
    }
    if (4 < Type) {
      if (Type == 0x100) {
        puVar4 = *(undefined1 **)((int)Ptr2 + 0x40);
        if (puVar4 == (undefined1 *)0x0) {
          puVar4 = &DAT_0814741b;
        }
        __sprintf_chk(msg,1,0x201,"%s Pin Name:",puVar4);
        local_234 = gui->prompt_for;
        Name = *(char **)((int)Ptr2 + 0x3c);
      }
      else {
        if (Type != 0x200) {
          if (Type != 0x10) goto LAB_08079dd7;
          Name = *(char **)((int)Ptr2 + 0x34);
          if (Name == (char *)0x0) {
            Name = "";
          }
          Name = (*gui->prompt_for)("Enter text:",Name);
          goto LAB_08079efd;
        }
        puVar4 = *(undefined1 **)((int)Ptr2 + 0x5c);
        if (puVar4 == (undefined1 *)0x0) {
          puVar4 = &DAT_0814741b;
        }
        __sprintf_chk(msg,1,0x201,"%s Pad Name:",puVar4);
        local_234 = gui->prompt_for;
        Name = *(char **)((int)Ptr2 + 0x58);
      }
      local_238 = msg;
      local_23c = "";
      if (Name == (char *)0x0) {
        Name = local_23c;
      }
      Name = (*local_234)(local_238,Name);
      goto LAB_08079efd;
    }
    if (Type == 1) {
      Name = *(char **)((int)Ptr2 + 0x3c);
      if (Name == (char *)0x0) {
        Name = "";
      }
      Name = (*gui->prompt_for)("Vianame:",Name);
      goto LAB_08079efd;
    }
    pvVar3 = Ptr2;
    pvVar6 = Ptr3;
    if (Type == 2) goto LAB_08079e18;
  }
LAB_08079dd7:
  Ptr3 = (void *)0x0;
LAB_08079dd9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return Ptr3;
}



Boolean ChangeObjectMaskSize
                  (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,Boolean fixIt)

{
  void *pvVar1;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeMaskSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ChangeObject2ndSize(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,
                           Boolean fixIt,Boolean incundo)

{
  void *pvVar1;
  bool bVar2;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&Change2ndSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  bVar2 = pvVar1 != (void *)0x0;
  if (bVar2) {
    Draw();
    if (incundo != '\0') {
      IncrementUndoSerialNumber();
      return (Boolean)bVar2;
    }
  }
  return (Boolean)bVar2;
}



Boolean ChangeObjectThermal(int Type,void *Ptr1,void *Ptr2,void *Ptr3,int therm_type)

{
  void *pvVar1;
  
  Absolute = therm_type;
  Delta = therm_type;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeThermalFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ChangeObjectClearSize
                  (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,Boolean fixIt)

{
  void *pvVar1;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x20) == 0) {
    pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeClearSizeFunctions,Type,Ptr1,Ptr2,Ptr3)
    ;
  }
  else {
    pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeMaskSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  }
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



Boolean ChangeObjectSize(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType Difference,
                        Boolean fixIt)

{
  void *pvVar1;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&ChangeSizeFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)(pvVar1 != (void *)0x0);
}



void * ChangePinOctagon(ElementTypePtr *Element,PinTypePtr *Pin)

{
  PinTypePtr *pPVar1;
  
  pPVar1 = (PinTypePtr *)0x0;
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) {
    ErasePin(Pin);
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
    (Pin->Flags).f = (Pin->Flags).f ^ 0x800;
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    DrawPin(Pin,0);
    pPVar1 = Pin;
  }
  return pPVar1;
}



void * ClrPinOctagon(ElementTypePtr *Element,PinTypePtr *Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2800) != 0x800) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinOctagon(Element,Pin);
  return pvVar1;
}



void * ClrElementOctagon(ElementTypePtr *Element)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar2 = 0;
    uVar3 = Element->PinN;
    do {
      ClrPinOctagon(Element,Element->Pin + uVar2);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return Element;
      }
      uVar2 = (uVar1 + 1 + uVar2) - uVar3;
      uVar3 = uVar1;
    } while (uVar2 < uVar1);
    return Element;
  }
  return (void *)0x0;
}



void * SetPinOctagon(ElementTypePtr *Element,PinTypePtr *Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2800) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinOctagon(Element,Pin);
  return pvVar1;
}



void * SetElementOctagon(ElementTypePtr *Element)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar2 = 0;
    uVar3 = Element->PinN;
    do {
      SetPinOctagon(Element,Element->Pin + uVar2);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return Element;
      }
      uVar2 = (uVar1 + 1 + uVar2) - uVar3;
      uVar3 = uVar1;
    } while (uVar2 < uVar1);
    return Element;
  }
  return (void *)0x0;
}



void * ChangeElementOctagon(ElementTypePtr *Element)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar2 = 0;
    uVar3 = Element->PinN;
    do {
      ChangePinOctagon(Element,Element->Pin + uVar2);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return Element;
      }
      uVar2 = (uVar1 + 1 + uVar2) - uVar3;
      uVar3 = uVar1;
    } while (uVar2 < uVar1);
    return Element;
  }
  return (void *)0x0;
}



void * ChangePinSquare(ElementTypePtr *Element,PinTypePtr *Pin)

{
  PinTypePtr *pPVar1;
  
  pPVar1 = (PinTypePtr *)0x0;
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) {
    ErasePin(Pin);
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
    (Pin->Flags).f = (Pin->Flags).f ^ 0x100;
    AddObjectToClearPolyUndoList(0x100,Element,Pin,Pin,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    DrawPin(Pin,0);
    pPVar1 = Pin;
  }
  return pPVar1;
}



void * ClrPinSquare(ElementTypePtr *Element,PinTypePtr *Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2100) != 0x100) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinSquare(Element,Pin);
  return pvVar1;
}



void * SetPinSquare(ElementTypePtr *Element,PinTypePtr *Pin)

{
  void *pvVar1;
  
  if (((Pin->Flags).f & 0x2100) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangePinSquare(Element,Pin);
  return pvVar1;
}



void * ChangePinThermal(ElementTypePtr *element,PinTypePtr *Pin)

{
  char cVar1;
  DataType *Data;
  byte bVar2;
  int iVar3;
  LayerType_conflict *ptr1;
  
  AddObjectToClearPolyUndoList(0x100,element,Pin,Pin,'\0');
  if (PCB->SilkActive == '\0') {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + LayerStack[0];
  }
  else {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + Data->LayerN;
  }
  RestoreToPolygon(Data,1,ptr1,Pin);
  AddObjectToFlagUndoList(0x100,element,Pin,Pin);
  if (Delta == 0) {
    iVar3 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar3 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar3 >> 0x1f);
    (Pin->Flags).t[iVar3 / 2] =
         ~(byte)(0xf << ((((char)iVar3 - cVar1 & 1U) + cVar1) * '\x04' & 0x1f)) &
         (Pin->Flags).t[iVar3 / 2];
  }
  else {
    iVar3 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar3 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar3 >> 0x1f);
    bVar2 = (((char)iVar3 - cVar1 & 1U) + cVar1) * '\x04';
    (Pin->Flags).t[iVar3 / 2] =
         (byte)(Delta << (bVar2 & 0x1f)) |
         ~(byte)(0xf << (bVar2 & 0x1f)) & (Pin->Flags).t[iVar3 / 2];
  }
  AddObjectToClearPolyUndoList(0x100,element,Pin,Pin,'\x01');
  if (PCB->SilkActive == '\0') {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + LayerStack[0];
  }
  else {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + Data->LayerN;
  }
  ClearFromPolygon(Data,1,ptr1,Pin);
  DrawPin(Pin,0);
  return Pin;
}



void * ChangeViaOctagon(PinTypePtr *Via)

{
  PinTypePtr *pPVar1;
  
  pPVar1 = (PinTypePtr *)0x0;
  if ((*(byte *)((int)&(Via->Flags).f + 1) & 0x20) == 0) {
    EraseVia(Via);
    AddObjectToClearPolyUndoList(1,Via,Via,Via,'\0');
    RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
    AddObjectToFlagUndoList(1,Via,Via,Via);
    (Via->Flags).f = (Via->Flags).f ^ 0x800;
    AddObjectToClearPolyUndoList(1,Via,Via,Via,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
    DrawVia(Via,0);
    pPVar1 = Via;
  }
  return pPVar1;
}



void * ClrViaOctagon(PinTypePtr *Via)

{
  void *pvVar1;
  
  if (((Via->Flags).f & 0x2800) != 0x800) {
    return (void *)0x0;
  }
  pvVar1 = ChangeViaOctagon(Via);
  return pvVar1;
}



void * SetViaOctagon(PinTypePtr *Via)

{
  void *pvVar1;
  
  if (((Via->Flags).f & 0x2800) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeViaOctagon(Via);
  return pvVar1;
}



void * ChangeViaThermal(PinTypePtr *Via)

{
  char cVar1;
  DataType *Data;
  byte bVar2;
  int iVar3;
  LayerType_conflict *ptr1;
  
  AddObjectToClearPolyUndoList(1,Via,Via,Via,'\0');
  if (PCB->SilkActive == '\0') {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + LayerStack[0];
  }
  else {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + Data->LayerN;
  }
  RestoreToPolygon(Data,1,ptr1,Via);
  AddObjectToFlagUndoList(1,Via,Via,Via);
  if (Delta == 0) {
    iVar3 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar3 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar3 >> 0x1f);
    (Via->Flags).t[iVar3 / 2] =
         (Via->Flags).t[iVar3 / 2] &
         ~(byte)(0xf << ((((char)iVar3 - cVar1 & 1U) + cVar1) * '\x04' & 0x1f));
  }
  else {
    iVar3 = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      iVar3 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    cVar1 = (char)(iVar3 >> 0x1f);
    bVar2 = (((char)iVar3 - cVar1 & 1U) + cVar1) * '\x04';
    (Via->Flags).t[iVar3 / 2] =
         (byte)(Delta << (bVar2 & 0x1f)) |
         ~(byte)(0xf << (bVar2 & 0x1f)) & (Via->Flags).t[iVar3 / 2];
  }
  AddObjectToClearPolyUndoList(1,Via,Via,Via,'\x01');
  if (PCB->SilkActive == '\0') {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + LayerStack[0];
  }
  else {
    Data = (DataType *)PCB->Data;
    ptr1 = Data->Layer + (uint)(Settings.ShowSolderSide == '\0') + Data->LayerN;
  }
  ClearFromPolygon(Data,1,ptr1,Via);
  DrawVia(Via,0);
  return Via;
}



void * ChangePadSquare(ElementTypePtr *Element,PadTypePtr *Pad)

{
  PadTypePtr *pPVar1;
  
  pPVar1 = (PadTypePtr *)0x0;
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0) {
    ErasePad(Pad);
    AddObjectToClearPolyUndoList(0x200,Element,Pad,Pad,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    AddObjectToFlagUndoList(0x200,Element,Pad,Pad);
    (Pad->Flags).f = (Pad->Flags).f ^ 0x100;
    AddObjectToClearPolyUndoList(0x200,Element,Pad,Pad,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    DrawPad(Pad,0);
    pPVar1 = Pad;
  }
  return pPVar1;
}



void * ClrPadSquare(ElementTypePtr *Element,PadTypePtr *Pad)

{
  void *pvVar1;
  
  if (((Pad->Flags).f & 0x2100) != 0x100) {
    return (void *)0x0;
  }
  pvVar1 = ChangePadSquare(Element,Pad);
  return pvVar1;
}



void * ClrElementSquare(ElementTypePtr *Element)

{
  void *pvVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  pvVar1 = (void *)0x0;
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (Element->PinN != 0) {
      uVar2 = 0;
      uVar4 = Element->PinN;
      do {
        pvVar1 = ClrPinSquare(Element,Element->Pin + uVar2);
        uVar3 = Element->PinN;
        if (uVar3 == 0) break;
        uVar2 = (uVar3 + 1 + uVar2) - uVar4;
        uVar4 = uVar3;
      } while (uVar2 < uVar3);
    }
    uVar4 = Element->PadN;
    uVar3 = 0;
    uVar2 = uVar4;
    while ((uVar2 != 0 && (uVar3 < uVar2))) {
      pvVar1 = ClrPadSquare(Element,Element->Pad + uVar3);
      uVar2 = Element->PadN;
      uVar3 = uVar3 + (uVar2 == uVar4);
    }
  }
  return pvVar1;
}



void * SetPadSquare(ElementTypePtr *Element,PadTypePtr *Pad)

{
  void *pvVar1;
  
  if (((Pad->Flags).f & 0x2100) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangePadSquare(Element,Pad);
  return pvVar1;
}



void * SetElementSquare(ElementTypePtr *Element)

{
  void *pvVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  pvVar1 = (void *)0x0;
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (Element->PinN != 0) {
      uVar2 = 0;
      uVar4 = Element->PinN;
      do {
        pvVar1 = SetPinSquare(Element,Element->Pin + uVar2);
        uVar3 = Element->PinN;
        if (uVar3 == 0) break;
        uVar2 = (uVar3 + 1 + uVar2) - uVar4;
        uVar4 = uVar3;
      } while (uVar2 < uVar3);
    }
    uVar4 = Element->PadN;
    uVar3 = 0;
    uVar2 = uVar4;
    while ((uVar2 != 0 && (uVar3 < uVar2))) {
      pvVar1 = SetPadSquare(Element,Element->Pad + uVar3);
      uVar2 = Element->PadN;
      uVar3 = uVar3 + (uVar2 == uVar4);
    }
  }
  return pvVar1;
}



void * ChangeElementSquare(ElementTypePtr *Element)

{
  void *pvVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  pvVar1 = (void *)0x0;
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (Element->PinN != 0) {
      uVar2 = 0;
      uVar4 = Element->PinN;
      do {
        pvVar1 = ChangePinSquare(Element,Element->Pin + uVar2);
        uVar3 = Element->PinN;
        if (uVar3 == 0) break;
        uVar2 = (uVar3 + 1 + uVar2) - uVar4;
        uVar4 = uVar3;
      } while (uVar2 < uVar3);
    }
    uVar4 = Element->PadN;
    uVar3 = 0;
    uVar2 = uVar4;
    while ((uVar2 != 0 && (uVar3 < uVar2))) {
      pvVar1 = ChangePadSquare(Element,Element->Pad + uVar3);
      uVar2 = Element->PadN;
      uVar3 = uVar3 + (uVar2 == uVar4);
    }
  }
  return pvVar1;
}



Boolean ChangePaste(PadTypePtr *Pad)

{
  bool bVar1;
  
  bVar1 = (*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0;
  if (bVar1) {
    ErasePad(Pad);
    AddObjectToFlagUndoList(0x200,Pad,Pad,Pad);
    (Pad->Flags).f = (Pad->Flags).f ^ 8;
    DrawPad(Pad,0);
    Draw();
  }
  return (Boolean)bVar1;
}



Boolean ChangeSelectedPaste(void)

{
  uint uVar1;
  byte bVar2;
  DataTypePtr *pDVar3;
  PadTypePtr *Pad;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int local_28;
  int local_24;
  byte local_1d;
  
  local_1d = 0;
  pDVar3 = PCB->Data;
  local_24 = pDVar3->ElementN - 1;
  if (local_24 != -1) {
    iVar6 = pDVar3->ElementN * 300;
    while( true ) {
      local_28 = iVar6 + -300;
      uVar5 = 0;
      iVar6 = (int)&pDVar3->Element[-1].BoundingBox.X1 + iVar6;
      uVar1 = *(uint *)(iVar6 + 0xe8);
      uVar4 = uVar1;
      while ((uVar4 != 0 && (uVar5 < uVar4))) {
        Pad = (PadTypePtr *)(uVar5 * 0x68 + *(int *)(iVar6 + 0x104));
        if ((*(byte *)&(Pad->Flags).f & 0x40) != 0) {
          bVar2 = ChangePaste(Pad);
          uVar4 = *(uint *)(iVar6 + 0xe8);
          local_1d = local_1d | bVar2;
        }
        uVar5 = uVar5 + (uVar1 == uVar4);
      }
      local_24 = local_24 + -1;
      if (local_24 == -1) break;
      pDVar3 = PCB->Data;
      iVar6 = local_28;
    }
    if (local_1d != 0) {
      Draw();
      IncrementUndoSerialNumber();
    }
  }
  return (Boolean)local_1d;
}



void * ChangeArcJoin(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Arc->Flags).f + 1) & 0x20) != 0) {
    return (void *)0x0;
  }
  EraseArc(Arc);
  if ((*(byte *)&(Arc->Flags).f & 0x20) != 0) {
    RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    AddObjectToClearPolyUndoList(0x4000,Layer,Arc,Arc,'\0');
  }
  AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
  uVar1 = (Arc->Flags).f ^ 0x20;
  (Arc->Flags).f = uVar1;
  if ((uVar1 & 0x20) != 0) {
    ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    AddObjectToClearPolyUndoList(0x4000,Layer,Arc,Arc,'\x01');
  }
  DrawArc(Layer,Arc,0);
  return Arc;
}



void * ClrArcJoin(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  void *pvVar1;
  
  if (((Arc->Flags).f & 0x2020) != 0x20) {
    return (void *)0x0;
  }
  pvVar1 = ChangeArcJoin(Layer,Arc);
  return pvVar1;
}



void * SetArcJoin(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  void *pvVar1;
  
  if (((Arc->Flags).f & 0x2020) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeArcJoin(Layer,Arc);
  return pvVar1;
}



void * ChangeTextJoin(LayerTypePtr Layer,TextTypePtr Text)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) != 0) {
    return (void *)0x0;
  }
  EraseText(Layer,Text);
  if ((*(byte *)&(Text->Flags).f & 0x20) != 0) {
    AddObjectToClearPolyUndoList(0x10,Layer,Text,Text,'\0');
    RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  }
  AddObjectToFlagUndoList(4,Layer,Text,Text);
  uVar1 = (Text->Flags).f ^ 0x20;
  (Text->Flags).f = uVar1;
  if ((uVar1 & 0x20) != 0) {
    AddObjectToClearPolyUndoList(0x10,Layer,Text,Text,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  }
  DrawText(Layer,Text,0);
  return Text;
}



void * ClrTextJoin(LayerTypePtr Layer,TextTypePtr Text)

{
  void *pvVar1;
  
  if (((Text->Flags).f & 0x2020) != 0x20) {
    return (void *)0x0;
  }
  pvVar1 = ChangeTextJoin(Layer,Text);
  return pvVar1;
}



void * SetTextJoin(LayerTypePtr Layer,TextTypePtr Text)

{
  void *pvVar1;
  
  if (((Text->Flags).f & 0x2020) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeTextJoin(Layer,Text);
  return pvVar1;
}



void * ChangeLineJoin(LayerTypePtr Layer,LineTypePtr Line)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Line->Flags).f + 1) & 0x20) != 0) {
    return (void *)0x0;
  }
  EraseLine(Line);
  if ((*(byte *)&(Line->Flags).f & 0x20) != 0) {
    AddObjectToClearPolyUndoList(4,Layer,Line,Line,'\0');
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
  }
  AddObjectToFlagUndoList(4,Layer,Line,Line);
  uVar1 = (Line->Flags).f ^ 0x20;
  (Line->Flags).f = uVar1;
  if ((uVar1 & 0x20) != 0) {
    AddObjectToClearPolyUndoList(4,Layer,Line,Line,'\x01');
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
  }
  DrawLine(Layer,Line,0);
  return Line;
}



void * ClrLineJoin(LayerTypePtr Layer,LineTypePtr Line)

{
  void *pvVar1;
  
  if (((Line->Flags).f & 0x2020) != 0x20) {
    return (void *)0x0;
  }
  pvVar1 = ChangeLineJoin(Layer,Line);
  return pvVar1;
}



void * SetLineJoin(LayerTypePtr Layer,LineTypePtr Line)

{
  void *pvVar1;
  
  if (((Line->Flags).f & 0x2020) != 0) {
    return (void *)0x0;
  }
  pvVar1 = ChangeLineJoin(Layer,Line);
  return pvVar1;
}



void * ChangePadName(ElementTypePtr *Element,PadTypePtr *Pad)

{
  char *pcVar1;
  
  pcVar1 = Pad->Name;
  if ((*(byte *)&(Pad->Flags).f & 0x20) == 0) {
    Pad->Name = NewName;
    return pcVar1;
  }
  ErasePadName(Pad);
  Pad->Name = NewName;
  DrawPadName(Pad,0);
  return pcVar1;
}



void * ChangePinName(ElementTypePtr *Element,PinTypePtr *Pin)

{
  char *pcVar1;
  
  pcVar1 = Pin->Name;
  if ((*(byte *)&(Pin->Flags).f & 0x20) == 0) {
    Pin->Name = NewName;
    return pcVar1;
  }
  ErasePinName(Pin);
  Pin->Name = NewName;
  DrawPinName(Pin,0);
  return pcVar1;
}



void * ChangeViaName(PinTypePtr *Via)

{
  char *pcVar1;
  
  pcVar1 = Via->Name;
  if ((*(byte *)&(Via->Flags).f & 0x20) == 0) {
    Via->Name = NewName;
    return pcVar1;
  }
  ErasePinName(Via);
  Via->Name = NewName;
  DrawPinName(Via,0);
  return pcVar1;
}



void * ChangeTextName(LayerTypePtr Layer,TextTypePtr Text)

{
  char *pcVar1;
  char *pcVar2;
  
  pcVar1 = Text->TextString;
  pcVar2 = (char *)0x0;
  if ((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) == 0) {
    EraseText(Layer,Text);
    RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    Text->TextString = NewName;
    SetTextBoundingBox((FontTypePtr)&PCB->Font,Text);
    ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    DrawText(Layer,Text,0);
    pcVar2 = pcVar1;
  }
  return pcVar2;
}



void * ChangeElementName(ElementTypePtr *Element)

{
  uint uVar1;
  char *pcVar2;
  PCBTypePtr pPVar3;
  uint uVar4;
  int iVar5;
  char *pcVar6;
  DataTypePtr *pDVar7;
  TextType *box;
  TextType *local_20;
  
  uVar4 = 1;
  uVar1 = (PCB->Flags).f;
  if ((uVar1 & 0x40) == 0) {
    uVar4 = -(uint)((uVar1 & 0x20) == 0) & 2;
  }
  pcVar2 = Element->Name[uVar4].TextString;
  pcVar6 = (char *)0x0;
  if ((*(byte *)((int)&Element->Name[0].Flags.f + 1) & 0x20) == 0) {
    if (((uVar1 & 0x440) == 0x440) &&
       (pcVar6 = UniqueElementName(PCB->Data,NewName), pcVar6 != NewName)) {
      Message("Error: The name \"%s\" is not unique!\n",NewName);
      return (void *)0xffffffff;
    }
    local_20 = Element->Name;
    EraseElementName(Element);
    uVar1 = (PCB->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      if ((uVar1 & 0x20) == 0) {
        pDVar7 = PCB->Data;
        box = Element->Name + 2;
        iVar5 = 2;
      }
      else {
        pDVar7 = PCB->Data;
        iVar5 = 0;
        box = local_20;
      }
    }
    else {
      pDVar7 = PCB->Data;
      iVar5 = 1;
      box = Element->Name + 1;
    }
    r_delete_entry(pDVar7->name_tree[iVar5],(BoxType *)box);
    pPVar3 = PCB;
    uVar4 = 1;
    uVar1 = (PCB->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      uVar4 = -(uint)((uVar1 & 0x20) == 0) & 2;
    }
    Element->Name[uVar4].TextString = NewName;
    uVar4 = 0x3c;
    if ((uVar1 & 0x40) == 0) {
      uVar4 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
    }
    SetTextBoundingBox((FontTypePtr)&pPVar3->Font,
                       (TextTypePtr)((int)&(local_20->BoundingBox).X1 + uVar4));
    uVar1 = (PCB->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      if ((uVar1 & 0x20) == 0) {
        local_20 = Element->Name + 2;
        pDVar7 = PCB->Data;
        iVar5 = 2;
      }
      else {
        pDVar7 = PCB->Data;
        iVar5 = 0;
      }
    }
    else {
      local_20 = Element->Name + 1;
      pDVar7 = PCB->Data;
      iVar5 = 1;
    }
    r_insert_entry(pDVar7->name_tree[iVar5],(BoxType *)local_20,0);
    DrawElementName(Element,0);
    pcVar6 = pcVar2;
  }
  return pcVar6;
}



void * ChangePadMaskSize(ElementTypePtr *Element,PadTypePtr *Pad)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  
  if (Absolute == 0) {
    iVar2 = Pad->Mask;
    iVar3 = 0;
    if (-1 < Delta + iVar2) {
      iVar3 = Delta + iVar2;
    }
    if (iVar2 != iVar3) goto LAB_0807b8a7;
  }
  else {
    iVar2 = Pad->Mask;
    iVar3 = 0;
    if (-1 < Absolute) {
      iVar3 = Absolute;
    }
    if (iVar2 != iVar3) goto LAB_0807b8a7;
  }
  if ((Absolute != 0) || (iVar3 = Pad->Thickness, iVar2 == iVar3)) {
    return (void *)0x0;
  }
LAB_0807b8a7:
  AddObjectToMaskSizeUndoList(0x200,Element,Pad,Pad);
  ErasePad(Pad);
  r_delete_entry(PCB->Data->pad_tree,(BoxType *)Pad);
  pPVar1 = PCB;
  Pad->Mask = iVar3;
  SetElementBoundingBox(pPVar1->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&pPVar1->Font);
  DrawPad(Pad,0);
  return Pad;
}



void * ChangePinMaskSize(ElementTypePtr *Element,PinTypePtr *Pin)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  
  if (Absolute == 0) {
    iVar2 = Pin->Mask;
    iVar3 = 0;
    if (-1 < Delta + iVar2) {
      iVar3 = Delta + iVar2;
    }
    if (iVar2 != iVar3) goto LAB_0807b997;
  }
  else {
    iVar2 = Pin->Mask;
    iVar3 = 0;
    if (-1 < Absolute) {
      iVar3 = Absolute;
    }
    if (iVar2 != iVar3) goto LAB_0807b997;
  }
  if ((Absolute != 0) || (iVar3 = Pin->Thickness, iVar2 == iVar3)) {
    return (void *)0x0;
  }
LAB_0807b997:
  AddObjectToMaskSizeUndoList(0x100,Element,Pin,Pin);
  ErasePin(Pin);
  r_delete_entry(PCB->Data->pin_tree,(BoxType *)Pin);
  pPVar1 = PCB;
  Pin->Mask = iVar3;
  SetElementBoundingBox(pPVar1->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&pPVar1->Font);
  DrawPin(Pin,0);
  return Pin;
}



void * ChangeViaMaskSize(PinTypePtr *Via)

{
  PinTypePtr *pPVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (Absolute == 0) {
    iVar3 = Via->Mask;
    iVar2 = Delta + iVar3;
  }
  else {
    iVar3 = Via->Mask;
    iVar2 = Absolute;
  }
  iVar4 = 0;
  if (-1 < iVar2) {
    iVar4 = iVar2;
  }
  pPVar1 = (PinTypePtr *)0x0;
  if (iVar4 != iVar3) {
    AddObjectToMaskSizeUndoList(1,Via,Via,Via);
    EraseVia(Via);
    r_delete_entry(PCB->Data->via_tree,(BoxType *)Via);
    Via->Mask = iVar4;
    SetPinBoundingBox((PinTypePtr_conflict)Via);
    r_insert_entry(PCB->Data->via_tree,(BoxType *)Via,0);
    DrawVia(Via,0);
    pPVar1 = Via;
  }
  return pPVar1;
}



void * ChangePin2ndSize(ElementTypePtr *Element,PinTypePtr *Pin)

{
  uint uVar1;
  PCBTypePtr pPVar2;
  int iVar3;
  
  iVar3 = Absolute;
  if (Absolute == 0) {
    iVar3 = Delta + Pin->DrillingHole;
  }
  uVar1 = (Pin->Flags).f;
  if (((((uVar1 & 0x2000) == 0) && (iVar3 - 400U < 0x9894f1)) &&
      (((uVar1 & 8) != 0 || (iVar3 < Pin->Thickness + -399)))) && (iVar3 != Pin->DrillingHole)) {
    AddObjectTo2ndSizeUndoList(0x100,Element,Pin,Pin);
    ErasePin(Pin);
    Pin->DrillingHole = iVar3;
    DrawPin(Pin,0);
    if ((*(byte *)&(Pin->Flags).f & 8) != 0) {
      RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
      AddObjectToSizeUndoList(0x100,Element,Pin,Pin);
      pPVar2 = PCB;
      Pin->Thickness = iVar3;
      ClearFromPolygon((DataType *)pPVar2->Data,0x100,Element,Pin);
    }
  }
  else {
    Pin = (PinTypePtr *)0x0;
  }
  return Pin;
}



void * ChangeElement2ndSize(ElementTypePtr *Element)

{
  bool bVar1;
  PCBTypePtr pPVar2;
  uint uVar3;
  uint uVar4;
  PinTypePtr *Pin;
  uint uVar5;
  int iVar6;
  
  if (((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) && (Element->PinN != 0)) {
    uVar5 = 0;
    bVar1 = false;
    uVar4 = Element->PinN;
    do {
      Pin = Element->Pin + uVar5;
      iVar6 = Absolute;
      if (Absolute == 0) {
        iVar6 = Delta + Pin->DrillingHole;
      }
      uVar3 = uVar4;
      if ((iVar6 - 400U < 0x9894f1) &&
         ((((*(byte *)&(Pin->Flags).f & 8) != 0 || (iVar6 < Pin->Thickness + -399)) &&
          (iVar6 != Pin->DrillingHole)))) {
        AddObjectTo2ndSizeUndoList(0x100,Element,Pin,Pin);
        ErasePin(Pin);
        Pin->DrillingHole = iVar6;
        DrawPin(Pin,0);
        if ((*(byte *)&(Pin->Flags).f & 8) == 0) {
          uVar3 = Element->PinN;
          bVar1 = true;
        }
        else {
          RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
          AddObjectToSizeUndoList(0x100,Element,Pin,Pin);
          pPVar2 = PCB;
          Pin->Thickness = iVar6;
          ClearFromPolygon((DataType *)pPVar2->Data,0x100,Element,Pin);
          bVar1 = true;
          uVar3 = Element->PinN;
        }
      }
    } while ((uVar3 != 0) && (uVar5 = (uVar5 + 1 + uVar3) - uVar4, uVar4 = uVar3, uVar5 < uVar3));
    if (bVar1) {
      return Element;
    }
  }
  return (void *)0x0;
}



void * ChangeVia2ndSize(PinTypePtr *Via)

{
  byte bVar1;
  uint uVar2;
  PCBTypePtr pPVar3;
  int iVar4;
  
  iVar4 = Absolute;
  if (Absolute == 0) {
    iVar4 = Delta + Via->DrillingHole;
  }
  uVar2 = (Via->Flags).f;
  if (((((uVar2 & 0x2000) == 0) && (iVar4 - 400U < 0x9894f1)) &&
      (((uVar2 & 8) != 0 || (iVar4 < Via->Thickness + -399)))) && (iVar4 != Via->DrillingHole)) {
    AddObjectTo2ndSizeUndoList(1,Via,Via,Via);
    EraseVia(Via);
    bVar1 = *(byte *)&(Via->Flags).f;
    Via->DrillingHole = iVar4;
    if ((bVar1 & 8) != 0) {
      RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
      AddObjectToSizeUndoList(1,Via,Via,Via);
      pPVar3 = PCB;
      Via->Thickness = iVar4;
      ClearFromPolygon((DataType *)pPVar3->Data,1,Via,Via);
    }
    DrawVia(Via,0);
  }
  else {
    Via = (PinTypePtr *)0x0;
  }
  return Via;
}



void * ChangePadSize(ElementTypePtr *Element,PadTypePtr *Pad)

{
  int iVar1;
  int iVar2;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Pad->Thickness;
  }
  if ((((*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0) && (iVar2 - 100U < 0x98961d)) &&
     (iVar2 != Pad->Thickness)) {
    AddObjectToSizeUndoList(0x200,Element,Pad,Pad);
    AddObjectToMaskSizeUndoList(0x200,Element,Pad,Pad);
    RestoreToPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    ErasePad(Pad);
    r_delete_entry(PCB->Data->pad_tree,(BoxType *)Pad);
    iVar1 = Pad->Thickness;
    Pad->Thickness = iVar2;
    Pad->Mask = (Pad->Mask + iVar2) - iVar1;
    SetElementBoundingBox(PCB->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&PCB->Font);
    ClearFromPolygon((DataType *)PCB->Data,0x200,Element,Pad);
    DrawPad(Pad,0);
  }
  else {
    Pad = (PadTypePtr *)0x0;
  }
  return Pad;
}



void * ChangePinSize(ElementTypePtr *Element,PinTypePtr *Pin)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = Absolute;
  if (Absolute == 0) {
    iVar3 = Delta + Pin->Thickness;
  }
  uVar1 = (Pin->Flags).f;
  if (((((uVar1 & 0x2000) == 0) && (iVar3 < 0x989681)) && ((uVar1 & 8) == 0)) &&
     (((1999 < iVar3 && (Pin->DrillingHole + 399 < iVar3)) && (iVar3 != Pin->Thickness)))) {
    AddObjectToSizeUndoList(0x100,Element,Pin,Pin);
    AddObjectToMaskSizeUndoList(0x100,Element,Pin,Pin);
    ErasePin(Pin);
    r_delete_entry(PCB->Data->pin_tree,(BoxType *)Pin);
    RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    iVar2 = Pin->Thickness;
    Pin->Thickness = iVar3;
    Pin->Mask = (Pin->Mask + iVar3) - iVar2;
    SetElementBoundingBox(PCB->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&PCB->Font);
    ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
    DrawPin(Pin,0);
  }
  else {
    Pin = (PinTypePtr *)0x0;
  }
  return Pin;
}



void * ChangeElementNameSize(ElementTypePtr *Element)

{
  TextTypePtr Text;
  byte bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  ElementTypePtr *local_20;
  
  if (Absolute == 0) {
    iVar2 = Delta / 0x2d + Element->Name[0].Scale;
    bVar1 = *(byte *)((int)&Element->Name[0].Flags.f + 1);
  }
  else {
    iVar2 = Absolute / 0x2d;
    bVar1 = *(byte *)((int)&Element->Name[0].Flags.f + 1);
  }
  if (((bVar1 & 0x20) == 0) && (iVar2 - 10U < 0x2707)) {
    EraseElementName(Element);
    local_20 = Element;
    iVar3 = 2;
    do {
      iVar4 = iVar3 + -1;
      Text = (TextTypePtr)(Element->Name + iVar3);
      AddObjectToSizeUndoList(0x400,Element,Text,Text);
      r_delete_entry((rtree_t *)(&PCB->Data->ElementN)[iVar3 + 0xc],(BoxType *)Text);
      local_20->Name[2].Scale = iVar2;
      SetTextBoundingBox((FontTypePtr)&PCB->Font,Text);
      r_insert_entry((rtree_t *)(&PCB->Data->ElementN)[iVar3 + 0xc],(BoxType *)Text,0);
      local_20 = (ElementTypePtr *)&local_20[-1].LineN;
      iVar3 = iVar4;
    } while (iVar4 != -1);
    DrawElementName(Element,0);
  }
  else {
    Element = (ElementTypePtr *)0x0;
  }
  return Element;
}



void * ChangeViaSize(PinTypePtr *Via)

{
  uint uVar1;
  int iVar2;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Via->Thickness;
  }
  uVar1 = (Via->Flags).f;
  if (((((uVar1 & 0x2000) == 0) && (iVar2 < 0x989681)) && ((uVar1 & 8) == 0)) &&
     (((1999 < iVar2 && (Via->DrillingHole + 399 < iVar2)) && (iVar2 != Via->Thickness)))) {
    AddObjectToSizeUndoList(1,Via,Via,Via);
    EraseVia(Via);
    r_delete_entry(PCB->Data->via_tree,(BoxType *)Via);
    RestoreToPolygon((DataType *)PCB->Data,0x100,Via,Via);
    if (Via->Mask != 0) {
      AddObjectToMaskSizeUndoList(1,Via,Via,Via);
      Via->Mask = (Via->Mask + iVar2) - Via->Thickness;
    }
    Via->Thickness = iVar2;
    SetPinBoundingBox((PinTypePtr_conflict)Via);
    r_insert_entry(PCB->Data->via_tree,(BoxType *)Via,0);
    ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
    DrawVia(Via,0);
  }
  else {
    Via = (PinTypePtr *)0x0;
  }
  return Via;
}



void * ChangeTextSize(LayerTypePtr Layer,TextTypePtr Text)

{
  byte bVar1;
  PCBTypePtr pPVar2;
  int iVar3;
  
  if (Absolute == 0) {
    iVar3 = Delta / 0x2d + Text->Scale;
    bVar1 = *(byte *)((int)&(Text->Flags).f + 1);
  }
  else {
    iVar3 = Absolute / 0x2d;
    bVar1 = *(byte *)((int)&(Text->Flags).f + 1);
  }
  if ((((bVar1 & 0x20) == 0) && (iVar3 - 10U < 0x2707)) && (iVar3 != Text->Scale)) {
    AddObjectToSizeUndoList(0x10,Layer,Text,Text);
    EraseText(Layer,Text);
    r_delete_entry(Layer->text_tree,(BoxType *)Text);
    RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    pPVar2 = PCB;
    Text->Scale = iVar3;
    SetTextBoundingBox((FontTypePtr)&pPVar2->Font,Text);
    r_insert_entry(Layer->text_tree,(BoxType *)Text,0);
    ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
    DrawText(Layer,Text,0);
  }
  else {
    Text = (TextTypePtr)0x0;
  }
  return Text;
}



Boolean ChangeHole(PinTypePtr *Via)

{
  uint uVar1;
  
  if ((*(byte *)((int)&(Via->Flags).f + 1) & 0x20) != 0) {
    return '\0';
  }
  EraseVia(Via);
  AddObjectToFlagUndoList(1,Via,Via,Via);
  uVar1 = (Via->Flags).f ^ 8;
  (Via->Flags).f = uVar1;
  if ((uVar1 & 8) == 0) {
    AddObjectTo2ndSizeUndoList(1,Via,Via,Via);
    Via->DrillingHole = Via->Thickness + -400;
  }
  else {
    RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
    AddObjectToSizeUndoList(1,Via,Via,Via);
    Via->Mask = Via->DrillingHole;
    Via->Thickness = Via->DrillingHole;
    ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
  }
  DrawVia(Via,0);
  Draw();
  return '\x01';
}



Boolean ChangeSelectedHole(void)

{
  uint uVar1;
  byte bVar2;
  PCBTypePtr pPVar3;
  DataTypePtr *pDVar4;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  
  if (PCB->ViaOn != '\0') {
    pDVar4 = PCB->Data;
    if (pDVar4->ViaN != 0) {
      uVar5 = 0;
      bVar7 = 0;
      pPVar3 = PCB;
      uVar6 = pDVar4->ViaN;
      do {
        if ((*(byte *)&pDVar4->Via[uVar5].Flags.f & 0x40) == 0) {
          pDVar4 = pPVar3->Data;
          uVar1 = pDVar4->ViaN;
        }
        else {
          bVar2 = ChangeHole(pDVar4->Via + uVar5);
          pDVar4 = PCB->Data;
          bVar7 = bVar7 | bVar2;
          uVar1 = pDVar4->ViaN;
          pPVar3 = PCB;
        }
      } while ((uVar1 != 0) && (uVar5 = (uVar1 + 1 + uVar5) - uVar6, uVar6 = uVar1, uVar5 < uVar1));
      if (bVar7 == 0) {
        return '\0';
      }
      Draw();
      IncrementUndoSerialNumber();
      return (Boolean)bVar7;
    }
  }
  return '\0';
}



void * ChangePadClearSize(ElementTypePtr *Element,PadTypePtr *Pad)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Pad->Clearance;
  }
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 0x20) == 0) {
    iVar3 = PCB->Bloat * 2 + 2;
    if (iVar2 < iVar3) {
      iVar2 = iVar3;
    }
    iVar3 = 10000000;
    if (iVar2 < 0x989681) {
      iVar3 = iVar2;
    }
    if ((iVar3 - 100U < 0x98961d) && (Pad->Clearance != iVar3)) {
      AddObjectToClearSizeUndoList(0x200,Element,Pad,Pad);
      RestoreToPolygon((DataType *)PCB->Data,0x200,Element,Pad);
      ErasePad(Pad);
      r_delete_entry(PCB->Data->pad_tree,(BoxType *)Pad);
      pPVar1 = PCB;
      Pad->Clearance = iVar3;
      SetElementBoundingBox
                (pPVar1->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&pPVar1->Font);
      ClearFromPolygon((DataType *)PCB->Data,0x200,Element,Pad);
      DrawPad(Pad,0);
      return Pad;
    }
  }
  return (void *)0x0;
}



void * ChangePinClearSize(ElementTypePtr *Element,PinTypePtr *Pin)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  
  iVar2 = Absolute;
  if (Absolute == 0) {
    iVar2 = Delta + Pin->Clearance;
  }
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) {
    iVar3 = PCB->Bloat * 2 + 2;
    if (iVar2 < iVar3) {
      iVar2 = iVar3;
    }
    iVar3 = 10000000;
    if (iVar2 < 0x989681) {
      iVar3 = iVar2;
    }
    if (Pin->Clearance != iVar3) {
      RestoreToPolygon((DataType *)PCB->Data,0x100,Element,Pin);
      AddObjectToClearSizeUndoList(0x100,Element,Pin,Pin);
      ErasePin(Pin);
      r_delete_entry(PCB->Data->pin_tree,(BoxType *)Pin);
      pPVar1 = PCB;
      Pin->Clearance = iVar3;
      SetElementBoundingBox
                (pPVar1->Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&pPVar1->Font);
      ClearFromPolygon((DataType *)PCB->Data,0x100,Element,Pin);
      DrawPin(Pin,0);
      return Pin;
    }
  }
  return (void *)0x0;
}



void * ChangeViaClearSize(PinTypePtr *Via)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = Absolute;
  if (Absolute == 0) {
    uVar1 = Delta + Via->Clearance;
  }
  uVar2 = (Via->Flags).f & 0x2000;
  if (uVar2 != 0) {
    return (void *)0x0;
  }
  uVar3 = 10000000;
  if ((int)uVar1 < 0x989681) {
    uVar3 = uVar1;
  }
  if ((int)uVar3 < 0) {
    uVar3 = uVar2;
  }
  if (Delta < 0) {
    if (SBORROW4(uVar3,PCB->Bloat * 2) != (int)(uVar3 + PCB->Bloat * -2) < 0) {
      uVar3 = uVar2;
    }
LAB_0807ca50:
    if (Absolute == 0) goto LAB_0807c96a;
  }
  else {
    if (Delta == 0) goto LAB_0807ca50;
  }
  if ((int)uVar3 < PCB->Bloat * 2) {
    uVar3 = PCB->Bloat * 2 + 2;
  }
LAB_0807c96a:
  if (Via->Clearance == uVar3) {
    return (void *)0x0;
  }
  RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
  AddObjectToClearSizeUndoList(1,Via,Via,Via);
  EraseVia(Via);
  r_delete_entry(PCB->Data->via_tree,(BoxType *)Via);
  Via->Clearance = uVar3;
  SetPinBoundingBox((PinTypePtr_conflict)Via);
  r_insert_entry(PCB->Data->via_tree,(BoxType *)Via,0);
  ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
  DrawVia(Via,0);
  Via->Element = (void *)0x0;
  return Via;
}



void * ChangeArcClearSize(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  int iVar1;
  int iVar2;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Arc->Clearance;
  }
  if (((Arc->Flags).f & 0x2020) == 0x20) {
    iVar2 = PCB->Bloat * 2 + 2;
    if (iVar1 < iVar2) {
      iVar1 = iVar2;
    }
    iVar2 = 10000000;
    if (iVar1 < 0x989681) {
      iVar2 = iVar1;
    }
    if (Arc->Clearance != iVar2) {
      AddObjectToClearSizeUndoList(0x4000,Layer,Arc,Arc);
      EraseArc(Arc);
      r_delete_entry(Layer->arc_tree,(BoxType *)Arc);
      RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
      Arc->Clearance = iVar2;
      if (iVar2 == 0) {
        (Arc->Flags).f = (Arc->Flags).f & 0xffffffdf;
        Arc->Clearance = 1000;
      }
      SetArcBoundingBox(Arc);
      r_insert_entry(Layer->arc_tree,(BoxType *)Arc,0);
      ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
      DrawArc(Layer,Arc,0);
      return Arc;
    }
  }
  return (void *)0x0;
}



void * ChangeArcSize(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  int iVar1;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Arc->Thickness;
  }
  if ((((*(byte *)((int)&(Arc->Flags).f + 1) & 0x20) == 0) && (iVar1 - 1U < 10000000)) &&
     (iVar1 != Arc->Thickness)) {
    AddObjectToSizeUndoList(0x4000,Layer,Arc,Arc);
    EraseArc(Arc);
    r_delete_entry(Layer->arc_tree,(BoxType *)Arc);
    RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    Arc->Thickness = iVar1;
    SetArcBoundingBox(Arc);
    r_insert_entry(Layer->arc_tree,(BoxType *)Arc,0);
    ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    DrawArc(Layer,Arc,0);
  }
  else {
    Arc = (ArcTypePtr *)0x0;
  }
  return Arc;
}



void * ChangeLineClearSize(LayerTypePtr Layer,LineTypePtr Line)

{
  int iVar1;
  int iVar2;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Line->Clearance;
  }
  if (((Line->Flags).f & 0x2020) == 0x20) {
    iVar2 = PCB->Bloat * 2 + 2;
    if (iVar1 < iVar2) {
      iVar1 = iVar2;
    }
    iVar2 = 10000000;
    if (iVar1 < 0x989681) {
      iVar2 = iVar1;
    }
    if (Line->Clearance != iVar2) {
      AddObjectToClearSizeUndoList(4,Layer,Line,Line);
      RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
      EraseLine(Line);
      r_delete_entry(Layer->line_tree,(BoxType *)Line);
      Line->Clearance = iVar2;
      if (iVar2 == 0) {
        (Line->Flags).f = (Line->Flags).f & 0xffffffdf;
        Line->Clearance = 1000;
      }
      SetLineBoundingBox(Line);
      r_insert_entry(Layer->line_tree,(BoxType *)Line,0);
      ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
      DrawLine(Layer,Line,0);
      return Line;
    }
  }
  return (void *)0x0;
}



void * ChangeLineSize(LayerTypePtr Layer,LineTypePtr Line)

{
  int iVar1;
  
  iVar1 = Absolute;
  if (Absolute == 0) {
    iVar1 = Delta + Line->Thickness;
  }
  if ((((*(byte *)((int)&(Line->Flags).f + 1) & 0x20) == 0) && (iVar1 - 1U < 10000000)) &&
     (iVar1 != Line->Thickness)) {
    AddObjectToSizeUndoList(4,Layer,Line,Line);
    EraseLine(Line);
    r_delete_entry(Layer->line_tree,(BoxType *)Line);
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    Line->Thickness = iVar1;
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,(BoxType *)Line,0);
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
    DrawLine(Layer,Line,0);
  }
  else {
    Line = (LineTypePtr)0x0;
  }
  return Line;
}



void * ChangeElementSize(ElementTypePtr *Element)

{
  int iVar1;
  bool bVar2;
  void *ptr2;
  int iVar3;
  int iVar4;
  
  if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
    if (PCB->ElementOn != '\0') {
      EraseElement(Element);
    }
    bVar2 = false;
    iVar4 = Element->LineN - 1;
    if (iVar4 != -1) {
      iVar1 = Element->LineN * 0x58;
      do {
        ptr2 = (void *)((int)&Element->Line[-1].BoundingBox.X1 + iVar1);
        iVar3 = Absolute;
        if (Absolute == 0) {
          iVar3 = Delta + *(int *)((int)ptr2 + 0x24);
        }
        if ((iVar3 - 1U < 10000000) && (iVar3 != *(int *)((int)ptr2 + 0x24))) {
          AddObjectToSizeUndoList(0x2000,Element,ptr2,ptr2);
          bVar2 = true;
          *(int *)((int)ptr2 + 0x24) = iVar3;
        }
        iVar4 = iVar4 + -1;
        iVar1 = iVar1 + -0x58;
      } while (iVar4 != -1);
    }
    iVar4 = Element->ArcN - 1;
    if (iVar4 != -1) {
      iVar1 = Element->ArcN * 0x44;
      do {
        ptr2 = (void *)((int)&Element->Arc[-1].BoundingBox.X1 + iVar1);
        iVar3 = Absolute;
        if (Absolute == 0) {
          iVar3 = Delta + *(int *)((int)ptr2 + 0x24);
        }
        if ((iVar3 - 1U < 10000000) && (iVar3 != *(int *)((int)ptr2 + 0x24))) {
          AddObjectToSizeUndoList(0x8000,Element,ptr2,ptr2);
          bVar2 = true;
          *(int *)((int)ptr2 + 0x24) = iVar3;
        }
        iVar4 = iVar4 + -1;
        iVar1 = iVar1 + -0x44;
      } while (iVar4 != -1);
    }
    if (PCB->ElementOn != '\0') {
      DrawElement(Element,0);
    }
    if (bVar2) {
      return Element;
    }
  }
  return (void *)0x0;
}



void * ChangePolyClear(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PCBTypePtr pPVar1;
  PolygonTypePtr ppVar2;
  
  ppVar2 = (PolygonTypePtr)0x0;
  if ((*(byte *)((int)&(Polygon->Flags).f + 1) & 0x20) == 0) {
    AddObjectToClearPolyUndoList(8,Layer,Polygon,Polygon,'\x01');
    AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
    pPVar1 = PCB;
    (Polygon->Flags).f = (Polygon->Flags).f ^ 0x10;
    InitClip(pPVar1->Data,Layer,(PolygonType *)Polygon);
    DrawPolygon(Layer,Polygon,0);
    ppVar2 = Polygon;
  }
  return ppVar2;
}



Boolean ClrSelectedOctagon(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ClrOctagonFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean SetSelectedOctagon(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&SetOctagonFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeSelectedOctagon(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeOctagonFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ClrSelectedSquare(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ClrSquareFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean SetSelectedSquare(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&SetSquareFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeSelectedSquare(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeSquareFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ClrSelectedJoin(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ClrJoinFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean SetSelectedJoin(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&SetJoinFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeSelectedJoin(int types)

{
  Boolean BVar1;
  
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeJoinFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeSelected2ndSize(int types,LocationType Difference,Boolean fixIt)

{
  Boolean BVar1;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&Change2ndSizeFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeSelectedClearSize(int types,LocationType Difference,Boolean fixIt)

{
  char cVar1;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x20) == 0) {
    cVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeClearSizeFunctions,'\0',types);
  }
  else {
    cVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeMaskSizeFunctions,'\0',types);
  }
  if (cVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return (Boolean)cVar1;
}



Boolean ChangeSelectedSize(int types,LocationType Difference,Boolean fixIt)

{
  Boolean BVar1;
  
  Absolute = 0;
  if (fixIt != '\0') {
    Absolute = Difference;
  }
  Delta = Difference;
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeSizeFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeSelectedThermals(int types,int therm_style)

{
  Boolean BVar1;
  
  Delta = therm_style;
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&ChangeThermalFunctions,'\0',types);
  if (BVar1 == '\0') {
    return '\0';
  }
  Draw();
  IncrementUndoSerialNumber();
  return BVar1;
}



Boolean ChangeElementSide(ElementTypePtr *Element,LocationType yoff)

{
  bool bVar1;
  
  bVar1 = (*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0;
  if (bVar1) {
    EraseElement(Element);
    AddObjectToMirrorUndoList(2,Element,Element,Element,yoff);
    MirrorElementCoordinates(PCB->Data,Element,yoff);
    DrawElement(Element,0);
  }
  return (Boolean)bVar1;
}



Boolean ChangeSelectedElementSide(void)

{
  ElementTypePtr *Element;
  byte bVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  int iVar4;
  byte bVar5;
  
  if ((PCB->PinOn != '\0') && (PCB->ElementOn != '\0')) {
    pDVar2 = PCB->Data;
    iVar3 = pDVar2->ElementN - 1;
    if (iVar3 != -1) {
      bVar5 = 0;
      iVar4 = pDVar2->ElementN * 300;
      while( true ) {
        Element = (ElementTypePtr *)((int)&pDVar2->Element[-1].BoundingBox.X1 + iVar4);
        if ((*(byte *)&(Element->Flags).f & 0x40) != 0) {
          bVar1 = ChangeElementSide(Element,0);
          bVar5 = bVar5 | bVar1;
        }
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        pDVar2 = PCB->Data;
        iVar4 = iVar4 + -300;
      }
      if (bVar5 == 0) {
        return '\0';
      }
      Draw();
      IncrementUndoSerialNumber();
      return bVar5;
    }
  }
  return '\0';
}



Boolean ClipLine(double minx,double miny,double maxx,double maxy,double *x1,double *y1,double *x2,
                double *y2,double margin)

{
  double dVar1;
  double dVar2;
  Boolean BVar3;
  
  minx = minx - margin;
  dVar1 = *x1;
  if (minx <= dVar1) {
LAB_0807d67c:
    dVar2 = *x2;
    if (dVar2 < minx) {
      *x2 = minx;
      *y2 = ((minx - dVar2) / (dVar1 - dVar2)) * (*y1 - *y2) + *y2;
      dVar2 = *x2;
      dVar1 = *x1;
    }
    maxx = maxx + margin;
    if (maxx < dVar1) {
      if (maxx < dVar2) goto LAB_0807d808;
      *x1 = maxx;
      *y1 = (*y2 - *y1) * ((dVar2 - dVar1) / (maxx - dVar1)) + *y1;
      dVar2 = *x2;
    }
    if (maxx < dVar2) {
      dVar1 = *x1;
      *x2 = maxx;
      dVar1 = *y2 + (*y1 - *y2) * ((maxx - dVar2) / (dVar1 - dVar2));
      *y2 = dVar1;
    }
    else {
      dVar1 = *y2;
    }
    miny = miny - margin;
    dVar2 = *y1;
    if (dVar2 < miny) {
      if (dVar1 < miny) goto LAB_0807d808;
      *y1 = miny;
      *x1 = (*x2 - *x1) * ((dVar1 - dVar2) / (miny - dVar2)) + *x1;
      dVar2 = *y1;
      dVar1 = *y2;
    }
    if (dVar1 < miny) {
      *y2 = miny;
      *x2 = (*x1 - *x2) * ((dVar2 - dVar1) / (miny - dVar1)) + *x2;
      dVar1 = *y2;
      dVar2 = *y1;
    }
    margin = margin + maxy;
    if (margin < dVar2) {
      if (margin < dVar1) goto LAB_0807d808;
      *y1 = margin;
      *x1 = (*x2 - *x1) * ((dVar1 - dVar2) / (margin - dVar2)) + *x1;
      dVar1 = *y2;
    }
    BVar3 = '\x01';
    if (margin < dVar1) {
      dVar2 = *y1;
      *y2 = margin;
      *x2 = *x2 + (*x1 - *x2) * ((margin - dVar1) / (dVar2 - dVar1));
      return '\x01';
    }
  }
  else {
    dVar2 = *x2;
    if (minx <= dVar2) {
      *x1 = minx;
      *y1 = (*y2 - *y1) * ((dVar2 - dVar1) / (minx - dVar1)) + *y1;
      dVar1 = *x1;
      goto LAB_0807d67c;
    }
LAB_0807d808:
    BVar3 = '\0';
  }
  return BVar3;
}



int CommandSaveLayout(int argc,char **argv,int x,int y)

{
  if (argc == 0) {
    if (PCB->Filename == (char *)0x0) {
      Message("No filename to save to yet\n");
      return 0;
    }
    SavePCB(PCB->Filename);
  }
  else {
    if (argc != 1) {
      Message("Usage: s [name] | w [name]\n  saves layout data\n");
      return 1;
    }
    SavePCB(*argv);
  }
  return 0;
}



int CommandHelp(int argc,char **argv,int x,int y)

{
  Message(
         "following commands are supported:\n  Command()   execute an action command (too numerous to list)\n              see the manual for the list of action commands\n  h           display this help message\n  l  [file]   load layout\n  le [file]   load element to buffer\n  m  [file]   load layout to buffer (merge)\n  q           quits the application\n  q!          quits without save warning\n  rn [file]   read in a net-list file\n  s  [file]   save layout\n  w  [file]   save layout\n  wq [file]   save layout and quit\n"
         );
  return 0;
}



int CommandLoadNetlist(int argc,char **argv,int x,int y)

{
  PCBTypePtr pPVar1;
  char *S;
  
  if (argc != 1) {
    Message("Usage: rn [name]\n  reads in a netlist file\n");
    return 1;
  }
  S = *argv;
  if (PCB->Netlistname != (char *)0x0) {
    SaveFree(PCB->Netlistname);
  }
  pPVar1 = PCB;
  S = StripWhiteSpaceAndDup(S);
  pPVar1->Netlistname = S;
  free((void *)0x0);
  return 0;
}



int CommandReallyQuit(int argc,char **argv,int x,int y)

{
  QuitApplication();
  return 0;
}



int CommandQuit(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  if (PCB->Changed != '\0') {
    iVar1 = (*gui->close_confirm_dialog)();
    if (iVar1 != 1) {
      return 0;
    }
  }
  QuitApplication();
  return 0;
}



int CommandSaveLayoutAndQuit(int argc,char **argv,int x,int y)

{
  int iVar1;
  
  iVar1 = CommandSaveLayout(argc,argv,x,y);
  if (iVar1 != 0) {
    return 1;
  }
  iVar1 = CommandQuit(0,(char **)0x0,0,0);
  return iVar1;
}



int CommandLoadLayoutToBuffer(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  
  if (argc != 1) {
    Message("Usage: m [name]\n  loads layout data to buffer\n");
    return 1;
  }
  if (*argv != (char *)0x0) {
    BVar1 = LoadLayoutToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),*argv);
    if (BVar1 != '\0') {
      SetMode(5);
      return 0;
    }
  }
  return 0;
}



int CommandLoadElementToBuffer(int argc,char **argv,int x,int y)

{
  Boolean BVar1;
  
  if (argc != 1) {
    Message((char *)0x0,"Usage: le [name]\n  loads element data to buffer\n");
    return 1;
  }
  if (*argv != (char *)0x0) {
    BVar1 = LoadElementToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),*argv,'\x01');
    if (BVar1 != '\0') {
      SetMode(5);
      return 0;
    }
  }
  return 0;
}



int CommandLoadLayout(int argc,char **argv,int x,int y)

{
  char *Filename;
  int iVar1;
  
  if (argc == 1) {
    Filename = *argv;
    if ((PCB->Changed == '\0') ||
       (iVar1 = (*gui->confirm_dialog)("OK to override layout data?",0), iVar1 != 0)) {
      LoadPCB(Filename);
    }
    free((void *)0x0);
    return 0;
  }
  Message("Usage: l [name]\n  loads layout data\n");
  return 1;
}



void register_command_action_list(void)

{
  hid_register_actions(command_action_list,10);
  return;
}



void * CopyObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  void *pvVar1;
  
  DeltaX = DX;
  DeltaY = DY;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&CopyFunctions,Type,Ptr1,Ptr2,Ptr3);
  IncrementUndoSerialNumber();
  return pvVar1;
}



void * CopyArc(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  ArcTypePtr *Arc_00;
  ArcTypePtr *pAVar1;
  int in_GS_OFFSET;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags((FlagType *)&local_1c,Arc->Flags,4);
  Arc_00 = CreateNewArcOnLayer(Layer,DeltaX + Arc->X,DeltaY + Arc->Y,Arc->Width,Arc->Height,
                               Arc->StartAngle,Arc->Delta,Arc->Thickness,Arc->Clearance,
                               (FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  pAVar1 = (ArcTypePtr *)0x0;
  if (Arc_00 != (ArcTypePtr *)0x0) {
    DrawArc(Layer,Arc_00,0);
    AddObjectToCreateUndoList(0x4000,Layer,Arc_00,Arc_00);
    pAVar1 = Arc_00;
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pAVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * CopyVia(PinTypePtr *Via)

{
  PinTypePtr *Via_00;
  PinTypePtr *pPVar1;
  int in_GS_OFFSET;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags((FlagType *)&local_1c,Via->Flags,4);
  Via_00 = CreateNewVia(PCB->Data,DeltaX + Via->X,DeltaY + Via->Y,Via->Thickness,Via->Clearance,
                        Via->Mask,Via->DrillingHole,Via->Name,
                        (FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  pPVar1 = (PinTypePtr *)0x0;
  if (Via_00 != (PinTypePtr *)0x0) {
    DrawVia(Via_00,0);
    AddObjectToCreateUndoList(1,Via_00,Via_00,Via_00);
    pPVar1 = Via_00;
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pPVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * CopyText(LayerTypePtr Layer,TextTypePtr Text)

{
  TextTypePtr Text_00;
  int in_GS_OFFSET;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags((FlagType *)&local_1c,Text->Flags,4);
  Text_00 = CreateNewText(Layer,(FontTypePtr)&PCB->Font,DeltaX + Text->X,DeltaY + Text->Y,
                          Text->Direction,Text->Scale,Text->TextString,
                          (FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  DrawText(Layer,Text_00,0);
  AddObjectToCreateUndoList(0x10,Layer,Text_00,Text_00);
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Text_00;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * CopyLine(LayerTypePtr Layer,LineTypePtr Line)

{
  LineTypePtr Line_00;
  char *pcVar1;
  LineTypePtr pLVar2;
  int in_GS_OFFSET;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  MaskFlags((FlagType *)&local_2c,Line->Flags,4);
  Line_00 = CreateDrawnLineOnLayer
                      (Layer,DeltaX + (Line->Point1).X,DeltaY + (Line->Point1).Y,
                       (Line->Point2).X + DeltaX,(Line->Point2).Y + DeltaY,Line->Thickness,
                       Line->Clearance,(FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
  pLVar2 = (LineTypePtr)0x0;
  if (Line_00 != (LineTypePtr)0x0) {
    if (Line->Number != (char *)0x0) {
      pcVar1 = MyStrdup(Line->Number,"CopyLine");
      Line_00->Number = pcVar1;
    }
    DrawLine(Layer,Line_00,0);
    AddObjectToCreateUndoList(4,Layer,Line_00,Line_00);
    pLVar2 = Line_00;
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



ElementTypePtr *
CopyElementLowLevel(DataTypePtr *Data,ElementTypePtr *Dest,ElementTypePtr *Src,Boolean uniqueName,
                   LocationType dx,LocationType dy)

{
  BYTE Direction;
  char *Value;
  char *NameOnPCB;
  char *Description;
  uint uVar1;
  ElementTypePtr *Element;
  int iVar2;
  uint uVar3;
  PinTypePtr *pPVar4;
  PadTypePtr *pPVar5;
  AttributeType *pAVar6;
  int TextScale;
  uint uVar7;
  int iVar8;
  int in_GS_OFFSET;
  uint local_60;
  ulong local_50;
  undefined4 local_4c;
  undefined4 local_48;
  ulong local_44;
  undefined4 local_40;
  undefined4 local_3c;
  ulong local_38;
  undefined4 local_34;
  undefined4 local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (Dest != (ElementTypePtr *)0x0) {
    FreeElementMemory(Dest);
  }
  MaskFlags((FlagType *)&local_2c,Src->Name[0].Flags,4);
  TextScale = Src->Name[0].Scale;
  iVar8 = Src->Name[0].Y;
  Direction = Src->Name[0].Direction;
  iVar2 = Src->Name[0].X;
  Value = Src->Name[2].TextString;
  NameOnPCB = Src->Name[1].TextString;
  Description = Src->Name[0].TextString;
  MaskFlags((FlagType *)&local_38,Src->Flags,4);
  Element = CreateNewElement(Data,Dest,(FontTypePtr)&PCB->Font,
                             (FlagType)CONCAT48(local_30,CONCAT44(local_34,local_38)),Description,
                             NameOnPCB,Value,iVar2 + dx,iVar8 + dy,Direction,TextScale,
                             (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)),uniqueName);
  if (Element != (ElementTypePtr *)0x0) {
    TextScale = Src->LineN - 1;
    if (TextScale != -1) {
      iVar8 = Src->LineN * 0x58;
      do {
        TextScale = TextScale + -1;
        iVar2 = (int)&Src->Line[-1].BoundingBox.X1 + iVar8;
        CreateNewLineInElement
                  (Element,dx + *(int *)(iVar2 + 0x2c),*(int *)(iVar2 + 0x30) + dy,
                   *(int *)(iVar2 + 0x40) + dx,*(int *)(iVar2 + 0x44) + dy,
                   *(BDimension *)(iVar2 + 0x24));
        iVar8 = iVar8 + -0x58;
      } while (TextScale != -1);
    }
    if (Src->PinN != 0) {
      uVar7 = 0;
      uVar3 = Src->PinN;
      do {
        pPVar4 = Src->Pin + uVar7;
        MaskFlags((FlagType *)&local_44,pPVar4->Flags,4);
        CreateNewPin(Element,pPVar4->X + dx,dy + pPVar4->Y,pPVar4->Thickness,pPVar4->Clearance,
                     pPVar4->Mask,pPVar4->DrillingHole,pPVar4->Name,pPVar4->Number,
                     (FlagType)CONCAT48(local_3c,CONCAT44(local_40,local_44)));
        uVar1 = Src->PinN;
        if (uVar1 == 0) break;
        uVar7 = (uVar1 + 1 + uVar7) - uVar3;
        uVar3 = uVar1;
      } while (uVar7 < uVar1);
    }
    uVar3 = Src->PadN;
    local_60 = 0;
    uVar7 = uVar3;
    while ((uVar7 != 0 && (local_60 < uVar7))) {
      pPVar5 = Src->Pad + local_60;
      MaskFlags((FlagType *)&local_50,pPVar5->Flags,4);
      CreateNewPad(Element,dx + (pPVar5->Point1).X,(pPVar5->Point1).Y + dy,(pPVar5->Point2).X + dx,
                   (pPVar5->Point2).Y + dy,pPVar5->Thickness,pPVar5->Clearance,pPVar5->Mask,
                   pPVar5->Name,pPVar5->Number,
                   (FlagType)CONCAT48(local_48,CONCAT44(local_4c,local_50)));
      uVar7 = Src->PadN;
      if (Src->PadN == uVar3) {
        local_60 = local_60 + 1;
        uVar7 = uVar3;
      }
    }
    TextScale = Src->ArcN - 1;
    if (TextScale != -1) {
      iVar8 = Src->ArcN * 0x44;
      do {
        TextScale = TextScale + -1;
        iVar2 = (int)&Src->Arc[-1].BoundingBox.X1 + iVar8;
        CreateNewArcInElement
                  (Element,dx + *(int *)(iVar2 + 0x34),dy + *(int *)(iVar2 + 0x38),
                   *(BDimension *)(iVar2 + 0x2c),*(BDimension *)(iVar2 + 0x30),
                   *(int *)(iVar2 + 0x3c),*(int *)(iVar2 + 0x40),*(BDimension *)(iVar2 + 0x24));
        iVar8 = iVar8 + -0x44;
      } while (TextScale != -1);
    }
    if (0 < (Src->Attributes).Number) {
      TextScale = 0;
      do {
        iVar8 = TextScale + 1;
        pAVar6 = (Src->Attributes).List + TextScale;
        CreateNewAttribute((AttributeListTypePtr)&Element->Attributes,pAVar6->name,pAVar6->value);
        TextScale = iVar8;
      } while ((Src->Attributes).Number != iVar8 && iVar8 <= (Src->Attributes).Number);
    }
    TextScale = Src->MarkY;
    Element->MarkX = dx + Src->MarkX;
    Element->MarkY = dy + TextScale;
    SetElementBoundingBox(Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&PCB->Font);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Element;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * CopyElement(ElementTypePtr *Element)

{
  ElementTypePtr *Element_00;
  
  Element_00 = CopyElementLowLevel(PCB->Data,(ElementTypePtr *)0x0,Element,
                                   (byte)((PCB->Flags).f >> 10) & 1,DeltaX,DeltaY);
  AddObjectToCreateUndoList(2,Element_00,Element_00,Element_00);
  if ((PCB->ElementOn != '\0') &&
     ((((Element_00->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (PCB->InvisibleObjectsOn != '\0')))) {
    DrawElementName(Element_00,0);
    DrawElementPackage(Element_00,0);
  }
  if (PCB->PinOn != '\0') {
    DrawElementPinsAndPads(Element_00,0);
  }
  return Element_00;
}



PolygonTypePtr CopyPolygonLowLevel(PolygonTypePtr Dest,PolygonTypePtr Src)

{
  undefined4 uVar1;
  int iVar2;
  LocationType *pLVar3;
  int iVar4;
  
  iVar4 = Src->PointN - 1;
  if (iVar4 != -1) {
    iVar2 = Src->PointN * 0x14;
    do {
      iVar4 = iVar4 + -1;
      pLVar3 = (LocationType *)((int)&Src->Points[-1].X + iVar2);
      CreateNewPointInPolygon(Dest,*pLVar3,pLVar3[1]);
      iVar2 = iVar2 + -0x14;
    } while (iVar4 != -1);
  }
  SetPolygonBoundingBox(Dest);
  (Dest->Flags).f = (Src->Flags).f;
  *(undefined4 *)(Dest->Flags).t = *(undefined4 *)(Src->Flags).t;
  uVar1 = *(undefined4 *)((Src->Flags).t + 4);
  (Dest->Flags).f = (Dest->Flags).f & 0xfffffffb;
  *(undefined4 *)((Dest->Flags).t + 4) = uVar1;
  return Dest;
}



void * CopyPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PolygonTypePtr Dest;
  rtree_t *rtree;
  int in_GS_OFFSET;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags((FlagType *)&local_2c,0);
  Dest = CreateNewPolygon(Layer,(FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
  CopyPolygonLowLevel(Dest,Polygon);
  MovePolygonLowLevel(Dest,DeltaX,DeltaY);
  rtree = Layer->polygon_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Layer->polygon_tree = rtree;
  }
  r_insert_entry(rtree,(BoxType *)Dest,0);
  InitClip(PCB->Data,Layer,(PolygonType *)Dest);
  DrawPolygon(Layer,Dest,0);
  AddObjectToCreateUndoList(8,Layer,Dest,Dest);
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Dest;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean CopyPastebufferToLayout(LocationType X,LocationType Y)

{
  LayerTypePtr Layer;
  DataTypePtr *pDVar1;
  uint uVar2;
  int iVar3;
  Cardinal *pCVar4;
  Cardinal CVar5;
  DataTypePtr *pDVar6;
  ElementTypePtr *Element;
  PCBTypePtr pPVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  undefined *puVar11;
  bool local_2c;
  uint local_24;
  
  local_2c = false;
  DeltaY = Y - Buffers[Settings.BufferNumber].Y;
  DeltaX = X - Buffers[Settings.BufferNumber].X;
  pDVar6 = PCB->Data;
  pPVar7 = PCB;
  if (pDVar6->LayerN != -2) {
    local_24 = 0;
    local_2c = false;
    do {
      pDVar1 = Buffers[Settings.BufferNumber].Data;
      iVar3 = local_24 * 0x5c;
      if (*(char *)(&pDVar6->field_0x90 + iVar3) != '\0') {
        Layer = (LayerTypePtr)(&pDVar6->field_0x4c + iVar3);
        if (local_2c) {
          CVar5 = *(Cardinal *)(&pDVar1->field_0x50 + iVar3);
LAB_0807e8bf:
          iVar3 = CVar5 - 1;
          if (iVar3 == -1) {
LAB_0807e7c5:
            CVar5 = *(Cardinal *)(&pDVar1->field_0x5c + local_24 * 0x5c);
          }
          else {
            iVar10 = CVar5 * 0x58;
            do {
              iVar10 = iVar10 + -0x58;
              iVar3 = iVar3 + -1;
              CopyLine(Layer,(LineTypePtr)(iVar10 + (&pDVar1->ViaN + local_24 * 0x17)[0x1c]));
            } while (iVar3 != -1);
            CVar5 = (&pDVar1->ViaN + local_24 * 0x17)[0x17];
          }
          iVar3 = CVar5 - 1;
          if (iVar3 != -1) {
            iVar10 = CVar5 * 0x44;
            do {
              iVar10 = iVar10 + -0x44;
              iVar3 = iVar3 + -1;
              CopyArc(Layer,(ArcTypePtr *)(iVar10 + *(int *)(&pDVar1->field_0x7c + local_24 * 0x5c))
                     );
            } while (iVar3 != -1);
          }
          local_2c = true;
        }
        else {
          pCVar4 = &pDVar1->ViaN + local_24 * 0x17;
          CVar5 = pCVar4[0x14];
          if (CVar5 != 0) goto LAB_0807e8bf;
          if ((pCVar4[0x17] != 0) || (pCVar4[0x16] != 0)) goto LAB_0807e7c5;
          local_2c = pCVar4[0x15] != 0;
        }
        CVar5 = (&pDVar1->ViaN + local_24 * 0x17)[0x15];
        iVar3 = CVar5 - 1;
        if (iVar3 != -1) {
          puVar11 = (undefined *)(CVar5 * 0x3c);
          do {
            puVar11 = &DAT_ffffffc4 + (int)puVar11;
            iVar3 = iVar3 + -1;
            CopyText(Layer,(TextTypePtr)(puVar11 + (&pDVar1->ViaN + local_24 * 0x17)[0x1d]));
          } while (iVar3 != -1);
        }
        CVar5 = (&pDVar1->ViaN + local_24 * 0x17)[0x16];
        iVar3 = CVar5 - 1;
        pPVar7 = PCB;
        if (iVar3 != -1) {
          puVar11 = (undefined *)(CVar5 * 0x3c);
          do {
            puVar11 = &DAT_ffffffc4 + (int)puVar11;
            iVar3 = iVar3 + -1;
            CopyPolygon(Layer,(PolygonTypePtr)(puVar11 + (&pDVar1->ViaN + local_24 * 0x17)[0x1e]));
            pPVar7 = PCB;
          } while (iVar3 != -1);
        }
      }
      pDVar6 = pPVar7->Data;
      local_24 = local_24 + 1;
    } while (local_24 < pDVar6->LayerN + 2U);
  }
  if ((pPVar7->PinOn != '\0') && (pPVar7->ElementOn != '\0')) {
    pDVar6 = Buffers[Settings.BufferNumber].Data;
    iVar3 = pDVar6->ElementN - 1;
    if (iVar3 != -1) {
      iVar10 = pDVar6->ElementN * 300;
      while( true ) {
        Element = (ElementTypePtr *)((int)&pDVar6->Element[-1].BoundingBox.X1 + iVar10);
        if ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide) ||
           (PCB->InvisibleObjectsOn != '\0')) {
          local_2c = true;
          CopyElement(Element);
        }
        iVar3 = iVar3 + -1;
        pPVar7 = PCB;
        if (iVar3 == -1) break;
        pDVar6 = Buffers[Settings.BufferNumber].Data;
        iVar10 = iVar10 + -300;
      }
    }
  }
  if (pPVar7->ViaOn != '\0') {
    pDVar6 = Buffers[Settings.BufferNumber].Data;
    uVar9 = pDVar6->ViaN;
    local_2c = (bool)(local_2c | uVar9 != 0);
    if (uVar9 != 0) {
      uVar8 = 0;
      do {
        CopyVia(pDVar6->Via + uVar8);
        pDVar6 = Buffers[Settings.BufferNumber].Data;
        uVar2 = pDVar6->ViaN;
        if (uVar2 == 0) break;
        uVar8 = (uVar2 + 1 + uVar8) - uVar9;
        uVar9 = uVar2;
      } while (uVar8 < uVar2);
    }
  }
  if (local_2c != false) {
    Draw();
    IncrementUndoSerialNumber();
  }
  return (Boolean)local_2c;
}



void pcb_colors_from_settings(PCBTypePtr ptr)

{
  char **ppcVar1;
  DataTypePtr *pDVar2;
  DataTypePtr *pDVar3;
  char *pcVar4;
  char *pcVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  
  ptr->ConnectedColor = Settings.ConnectedColor;
  pcVar4 = Settings.ElementColor;
  ptr->ElementColor = Settings.ElementColor;
  ptr->RatColor = Settings.RatColor;
  pcVar8 = Settings.InvisibleObjectsColor;
  ptr->InvisibleObjectsColor = Settings.InvisibleObjectsColor;
  ptr->InvisibleMarkColor = Settings.InvisibleMarkColor;
  pcVar5 = Settings.ElementSelectedColor;
  ptr->ElementSelectedColor = Settings.ElementSelectedColor;
  ptr->RatSelectedColor = Settings.RatSelectedColor;
  ptr->PinColor = Settings.PinColor;
  ptr->PinSelectedColor = Settings.PinSelectedColor;
  ptr->PinNameColor = Settings.PinNameColor;
  ptr->ViaColor = Settings.ViaColor;
  ptr->ViaSelectedColor = Settings.ViaSelectedColor;
  ptr->WarnColor = Settings.WarnColor;
  ptr->MaskColor = Settings.MaskColor;
  pDVar2 = ptr->Data;
  iVar7 = 0;
  iVar6 = 0;
  do {
    *(char **)(&pDVar2->field_0x94 + iVar7) = Settings.LayerColor[iVar6];
    ppcVar1 = Settings.LayerSelectedColor + iVar6;
    iVar6 = iVar6 + 1;
    *(char **)(&pDVar2->field_0x98 + iVar7) = *ppcVar1;
    iVar7 = iVar7 + 0x5c;
  } while (iVar6 != 0x10);
  pDVar3 = PCB->Data;
  iVar6 = pDVar3->LayerN;
  iVar7 = iVar6 + 1;
  if (Settings.ShowSolderSide == '\0') {
    *(char **)(&pDVar2->ViaN + iVar7 * 0x17 + 0x25) = pcVar4;
    *(char **)(&pDVar2->ViaN + iVar7 * 0x17 + 0x26) = pcVar5;
  }
  else {
    *(char **)(&pDVar2->ViaN + iVar7 * 0x17 + 0x25) = pcVar8;
    *(char **)(&pDVar2->ViaN + iVar7 * 0x17 + 0x26) = pcVar5;
    pcVar8 = pcVar4;
  }
  *(char **)(&pDVar2->field_0x94 + iVar6 * 0x5c) = pcVar8;
  *(char **)(&pDVar2->field_0x98 + pDVar3->LayerN * 0x5c) = pcVar5;
  return;
}



AttributeTypePtr CreateNewAttribute(AttributeListTypePtr list,char *name,char *value)

{
  char *pcVar1;
  int iVar2;
  AttributeType *pAVar3;
  
  iVar2 = list->Number;
  if (iVar2 < list->Max) {
    pAVar3 = list->List;
  }
  else {
    iVar2 = list->Max + 10;
    list->Max = iVar2;
    pAVar3 = (AttributeType *)MyRealloc(list->List,iVar2 * 8,"CreateNewAttribute");
    iVar2 = list->Number;
    list->List = pAVar3;
  }
  pcVar1 = MyStrdup(name,"CreateNewAttribute");
  pAVar3[iVar2].name = pcVar1;
  iVar2 = list->Number;
  pAVar3 = list->List;
  pcVar1 = MyStrdup(value,"CreateNewAttribute");
  pAVar3[iVar2].value = pcVar1;
  iVar2 = list->Number;
  list->Number = iVar2 + 1;
  return (AttributeTypePtr)(list->List + iVar2);
}



LibraryEntryTypePtr * CreateNewConnection(LibraryMenuTypePtr *net,char *conn)

{
  LibraryEntryTypePtr *pLVar1;
  char *pcVar2;
  
  pLVar1 = GetLibraryEntryMemory(net);
  pcVar2 = MyStrdup(conn,"CreateNewConnection()");
  pLVar1->ListEntry = pcVar2;
  return pLVar1;
}



LibraryMenuTypePtr * CreateNewNet(LibraryTypePtr lib,char *name,char *style)

{
  int iVar1;
  LibraryMenuTypePtr *pLVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  int in_GS_OFFSET;
  bool bVar6;
  byte bVar7;
  char temp [64];
  
  bVar7 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __sprintf_chk(temp,1,0x40,0x8147369,name);
  pLVar2 = GetLibraryMenuMemory(lib);
  pcVar3 = MyStrdup(temp,"CreateNewNet()");
  pLVar2->flag = '\x01';
  bVar6 = style == (char *)0x0;
  pLVar2->Name = pcVar3;
  if (!bVar6) {
    iVar4 = 10;
    pcVar3 = "(unknown)";
    pcVar5 = style;
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar6 = *pcVar3 == *pcVar5;
      pcVar3 = pcVar3 + (uint)bVar7 * -2 + 1;
      pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
    } while (bVar6);
    if (bVar6) {
      pLVar2->Style = (char *)0x0;
      goto LAB_0807ecfa;
    }
  }
  pcVar3 = MyStrdup(style,"CreateNewNet()");
  pLVar2->Style = pcVar3;
LAB_0807ecfa:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



RubberbandTypePtr *
CreateNewRubberbandEntry(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr MovedPoint)

{
  RubberbandTypePtr *pRVar1;
  
  pRVar1 = GetRubberbandMemory();
  (Line->Flags).f = (Line->Flags).f ^ 0x200;
  pRVar1->Layer = Layer;
  pRVar1->Line = Line;
  pRVar1->MovedPoint = MovedPoint;
  return pRVar1;
}



void CreateDefaultFont(void)

{
  int iVar1;
  
  iVar1 = ParseFont((FontTypePtr)&PCB->Font,Settings.FontFile);
  if (iVar1 == 0) {
    return;
  }
  Message("Can\'t find font-symbol-file \'%s\'\n",Settings.FontFile);
  return;
}



LineTypePtr
CreateNewLineInSymbol
          (SymbolTypePtr Symbol,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness)

{
  Cardinal CVar1;
  uint uVar2;
  LineTypePtr Ptr;
  uint uVar3;
  LineTypePtr pLVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Symbol->LineN;
  Ptr = Symbol->Line;
  if (Symbol->LineMax <= uVar3) {
    CVar1 = Symbol->LineMax + 10;
    uVar3 = 0x370;
    Symbol->LineMax = CVar1;
    Ptr = (LineTypePtr)MyRealloc(Ptr,CVar1 * 0x58,"CreateNewLineInSymbol()");
    pLVar4 = Ptr + Symbol->LineN;
    bVar5 = ((uint)pLVar4 & 1) != 0;
    Symbol->Line = Ptr;
    if (bVar5) {
      *(undefined *)&(pLVar4->BoundingBox).X1 = 0;
      uVar3 = 0x36f;
      pLVar4 = (LineTypePtr)((int)&(pLVar4->BoundingBox).X1 + 1);
    }
    if (((uint)pLVar4 & 2) != 0) {
      *(undefined2 *)&(pLVar4->BoundingBox).X1 = 0;
      uVar3 = uVar3 - 2;
      pLVar4 = (LineTypePtr)((int)&(pLVar4->BoundingBox).X1 + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      (pLVar4->BoundingBox).X1 = 0;
      pLVar4 = (LineTypePtr)(&(pLVar4->BoundingBox).X1 + (uint)bVar6 * 0x3ffffffe + 1);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&(pLVar4->BoundingBox).X1 = 0;
      pLVar4 = (LineTypePtr)((int)&(pLVar4->BoundingBox).X1 + 2);
    }
    if (bVar5) {
      *(undefined *)&(pLVar4->BoundingBox).X1 = 0;
      uVar3 = Symbol->LineN;
    }
    else {
      uVar3 = Symbol->LineN;
    }
  }
  Symbol->LineN = uVar3 + 1;
  Ptr = Ptr + uVar3;
  (Ptr->Point1).X = X1;
  (Ptr->Point1).Y = Y1;
  (Ptr->Point2).X = X2;
  (Ptr->Point2).Y = Y2;
  Ptr->Thickness = Thickness;
  return Ptr;
}



ArcTypePtr *
CreateNewArcInElement
          (ElementTypePtr *Element,LocationType X,LocationType Y,BDimension Width,BDimension Height,
          int Angle,int Delta,BDimension Thickness)

{
  Cardinal CVar1;
  uint uVar2;
  uint uVar3;
  ArcTypePtr *pAVar4;
  bool bVar5;
  byte bVar6;
  ArcTypePtr *local_20;
  
  bVar6 = 0;
  local_20 = Element->Arc;
  uVar3 = Element->ArcN;
  if (Element->ArcMax <= uVar3) {
    CVar1 = Element->ArcMax + 5;
    Element->ArcMax = CVar1;
    local_20 = (ArcTypePtr *)MyRealloc(local_20,CVar1 * 0x44,"CreateNewArcInElement()");
    Element->Arc = local_20;
    uVar3 = 0x154;
    pAVar4 = local_20 + Element->ArcN;
    bVar5 = ((uint)pAVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&(pAVar4->BoundingBox).X1 = 0;
      uVar3 = 0x153;
      pAVar4 = (ArcTypePtr *)((int)&(pAVar4->BoundingBox).X1 + 1);
    }
    if (((uint)pAVar4 & 2) != 0) {
      *(undefined2 *)&(pAVar4->BoundingBox).X1 = 0;
      uVar3 = uVar3 - 2;
      pAVar4 = (ArcTypePtr *)((int)&(pAVar4->BoundingBox).X1 + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      (pAVar4->BoundingBox).X1 = 0;
      pAVar4 = (ArcTypePtr *)((int)pAVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&(pAVar4->BoundingBox).X1 = 0;
      pAVar4 = (ArcTypePtr *)((int)&(pAVar4->BoundingBox).X1 + 2);
    }
    if (bVar5) {
      *(undefined *)&(pAVar4->BoundingBox).X1 = 0;
      uVar3 = Element->ArcN;
    }
    else {
      uVar3 = Element->ArcN;
    }
  }
  Delta = Delta % 0x168;
  if (Delta == 0) {
    Delta = 0x168;
  }
  else {
    if (Delta < 0) {
      Angle = Angle + Delta;
      Delta = -Delta;
    }
  }
  Angle = Angle % 0x168;
  if (Angle < 0) {
    Angle = Angle + 0x168;
  }
  Element->ArcN = uVar3 + 1;
  local_20 = local_20 + uVar3;
  local_20->X = X;
  local_20->StartAngle = Angle;
  local_20->Delta = Delta;
  local_20->Y = Y;
  local_20->Width = Width;
  local_20->Thickness = Thickness;
  local_20->Height = Height;
  local_20->ID = ID;
  ID = ID + 1;
  return local_20;
}



PadTypePtr *
CreateNewPad(ElementTypePtr *Element,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2
            ,BDimension Thickness,BDimension Clearance,BDimension Mask,char *Name,char *Number,
            FlagType Flags)

{
  PadTypePtr *pPVar1;
  char *pcVar2;
  
  pPVar1 = GetPadMemory(Element);
  if ((X2 < X1) || ((Y2 < Y1 && (X1 == X2)))) {
    (pPVar1->Point1).X = X2;
    (pPVar1->Point1).Y = Y2;
    (pPVar1->Point2).X = X1;
    (pPVar1->Point2).Y = Y1;
  }
  else {
    (pPVar1->Point1).X = X1;
    (pPVar1->Point1).Y = Y1;
    (pPVar1->Point2).X = X2;
    (pPVar1->Point2).Y = Y2;
  }
  pPVar1->Thickness = Thickness;
  pPVar1->Clearance = Clearance;
  pPVar1->Mask = Mask;
  pcVar2 = MyStrdup(Name,"CreateNewPad()");
  pPVar1->Name = pcVar2;
  pcVar2 = MyStrdup(Number,"CreateNewPad()");
  pPVar1->Number = pcVar2;
  (pPVar1->Flags).t[7] = Flags.t[7];
  (pPVar1->Flags).t[6] = Flags.t[6];
  (pPVar1->Flags).t[5] = Flags.t[5];
  (pPVar1->Flags).t[4] = Flags.t[4];
  (pPVar1->Flags).t[3] = Flags.t[3];
  (pPVar1->Flags).t[2] = Flags.t[2];
  (pPVar1->Flags).t[1] = Flags.t[1];
  (pPVar1->Flags).t[0] = Flags.t[0];
  (pPVar1->Flags).f = Flags.f & 0xfffffdff;
  pPVar1->ID = ID;
  ID = ID + 1;
  *(ElementTypePtr **)&pPVar1->Element = Element;
  return pPVar1;
}



PinTypePtr *
CreateNewPin(ElementTypePtr *Element,LocationType X,LocationType Y,BDimension Thickness,
            BDimension Clearance,BDimension Mask,BDimension DrillingHole,char *Name,char *Number,
            FlagType Flags)

{
  Boolean BVar1;
  PinTypePtr *pPVar2;
  char *pcVar3;
  int iVar4;
  
  pPVar2 = GetPinMemory(Element);
  pPVar2->X = X;
  pPVar2->Y = Y;
  pPVar2->Thickness = Thickness;
  pPVar2->Clearance = Clearance;
  pPVar2->Mask = Mask;
  pcVar3 = MyStrdup(Name,"CreateNewPin()");
  pPVar2->Name = pcVar3;
  pcVar3 = MyStrdup(Number,"CreateNewPin()");
  *(ElementTypePtr **)&pPVar2->Element = Element;
  (pPVar2->Flags).t[7] = Flags.t[7];
  pPVar2->Number = pcVar3;
  (pPVar2->Flags).t[6] = Flags.t[6];
  (pPVar2->Flags).t[5] = Flags.t[5];
  (pPVar2->Flags).t[4] = Flags.t[4];
  (pPVar2->Flags).t[3] = Flags.t[3];
  (pPVar2->Flags).t[2] = Flags.t[2];
  (pPVar2->Flags).t[1] = Flags.t[1];
  (pPVar2->Flags).t[0] = Flags.t[0];
  (pPVar2->Flags).f = Flags.f & 0xfffffdff | 1;
  pPVar2->ID = ID;
  ID = ID + 1;
  iVar4 = vendorDrillMap(DrillingHole);
  pPVar2->DrillingHole = iVar4;
  BVar1 = vendorIsElementMappable(Element);
  if (BVar1 == '\0') {
    pPVar2->DrillingHole = DrillingHole;
  }
  else {
    iVar4 = pPVar2->DrillingHole;
    if (iVar4 < 2000) {
      if ((Name == (char *)0x0) || (*Name == '\0')) {
        Name = "(unknown)";
      }
      if ((Number == (char *)0x0) || (*Number == '\0')) {
        Number = "(unknown)";
      }
      Message(
              "Did not map pin #%s (%s) drill hole because %6.2f mil is below the minimum allowed size\n"
              ,Number,Name,(double)iVar4 * 0.01000000);
      pPVar2->DrillingHole = DrillingHole;
      return pPVar2;
    }
    if (10000000 < iVar4) {
      if ((Name == (char *)0x0) || (*Name == '\0')) {
        Name = "(unknown)";
      }
      if ((Number == (char *)0x0) || (*Number == '\0')) {
        Number = "(unknown)";
      }
      Message(
              "Did not map pin #%s (%s) drill hole because %6.2f mil is above the maximum allowed size\n"
              ,Number,Name,(double)iVar4 * 0.01000000);
      pPVar2->DrillingHole = DrillingHole;
      return pPVar2;
    }
    if (((*(byte *)&(pPVar2->Flags).f & 8) == 0) && (pPVar2->Thickness + -399 <= iVar4)) {
      if ((Name == (char *)0x0) || (*Name == '\0')) {
        Name = "(unknown)";
      }
      if ((Number == (char *)0x0) || (*Number == '\0')) {
        Number = "(unknown)";
      }
      Message("Did not map pin #%s (%s) drill hole because %6.2f mil does not leave enough copper\n"
              ,Number,Name,(double)iVar4 * 0.01000000);
      pPVar2->DrillingHole = DrillingHole;
    }
    else {
      if (DrillingHole != iVar4) {
        Message("Mapped pin drill hole to %.2f mils from %.2f mils per vendor table\n",
                (double)iVar4 * 0.01000000,(double)DrillingHole * 0.01000000);
        return pPVar2;
      }
    }
  }
  return pPVar2;
}



LineTypePtr
CreateNewLineInElement
          (ElementTypePtr *Element,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness)

{
  Cardinal CVar1;
  uint uVar2;
  LineTypePtr Ptr;
  LineTypePtr pLVar3;
  bool bVar4;
  byte bVar5;
  uint local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  bVar5 = 0;
  pLVar3 = (LineTypePtr)0x0;
  Ptr = Element->Line;
  if (Thickness != 0) {
    uVar2 = Element->LineN;
    if (Element->LineMax <= uVar2) {
      CVar1 = Element->LineMax + 10;
      Element->LineMax = CVar1;
      Ptr = (LineTypePtr)MyRealloc(Ptr,CVar1 * 0x58,"CreateNewLineInElement()");
      local_30 = 0x370;
      pLVar3 = Ptr + Element->LineN;
      bVar4 = ((uint)pLVar3 & 1) != 0;
      Element->Line = Ptr;
      if (bVar4) {
        *(undefined *)&(pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)&(pLVar3->BoundingBox).X1 + 1);
        local_30 = 0x36f;
      }
      if (((uint)pLVar3 & 2) != 0) {
        *(undefined2 *)&(pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)&(pLVar3->BoundingBox).X1 + 2);
        local_30 = local_30 - 2;
      }
      uVar2 = local_30 >> 2;
      while (uVar2 != 0) {
        uVar2 = uVar2 - 1;
        (pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)pLVar3 + (uint)bVar5 * -8 + 4);
      }
      if ((local_30 & 2) != 0) {
        *(undefined2 *)&(pLVar3->BoundingBox).X1 = 0;
        pLVar3 = (LineTypePtr)((int)&(pLVar3->BoundingBox).X1 + 2);
      }
      if (bVar4) {
        *(undefined *)&(pLVar3->BoundingBox).X1 = 0;
      }
      uVar2 = Element->LineN;
    }
    Element->LineN = uVar2 + 1;
    pLVar3 = Ptr + uVar2;
    (pLVar3->Point1).X = X1;
    (pLVar3->Point1).Y = Y1;
    (pLVar3->Point2).X = X2;
    pLVar3->Thickness = Thickness;
    (pLVar3->Point2).Y = Y2;
    MakeFlags((FlagType *)&local_2c,0);
    (pLVar3->Flags).f = local_2c;
    *(undefined4 *)(pLVar3->Flags).t = local_28;
    *(undefined4 *)((pLVar3->Flags).t + 4) = local_24;
    pLVar3->ID = ID;
    ID = ID + 1;
  }
  return pLVar3;
}



void __regparm3
AddTextToElement(TextTypePtr Text,FontTypePtr PCBFont,LocationType X,LocationType Y,BYTE Direction,
                char *TextString,int Scale,FlagType Flags)

{
  char *pcVar1;
  
  SaveFree(Text->TextString);
  Text->TextString = (char *)0x0;
  (Text->Flags).t[7] = Flags.t[7];
  Text->Direction = Direction;
  (Text->Flags).t[6] = Flags.t[6];
  Text->X = X;
  (Text->Flags).t[5] = Flags.t[5];
  (Text->Flags).t[4] = Flags.t[4];
  Text->Y = Y;
  (Text->Flags).t[3] = Flags.t[3];
  (Text->Flags).t[2] = Flags.t[2];
  (Text->Flags).t[1] = Flags.t[1];
  (Text->Flags).t[0] = Flags.t[0];
  (Text->Flags).f = Flags.f;
  Text->Scale = Scale;
  if ((TextString == (char *)0x0) || (*TextString == '\0')) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = MyStrdup(TextString,"AddTextToElement()");
  }
  Text->TextString = pcVar1;
  SetTextBoundingBox(PCBFont,Text);
  Text->ID = ID;
  ID = ID + 1;
  return;
}



ElementTypePtr *
CreateNewElement(DataTypePtr *Data,ElementTypePtr *Element,FontTypePtr PCBFont,FlagType Flags,
                char *Description,char *NameOnPCB,char *Value,LocationType TextX,LocationType TextY,
                BYTE Direction,int TextScale,FlagType TextFlags,Boolean uniqueName)

{
  int Scale;
  
  if (Element == (ElementTypePtr *)0x0) {
    Element = GetElementMemory(Data);
  }
  Scale = 10;
  if (9 < TextScale) {
    Scale = TextScale;
  }
  AddTextToElement((TextTypePtr)Element->Name,PCBFont,TextX,TextY,Direction,Description,Scale,
                   TextFlags);
  if (uniqueName != '\0') {
    NameOnPCB = UniqueElementName(Data,NameOnPCB);
  }
  AddTextToElement((TextTypePtr)(Element->Name + 1),PCBFont,TextX,TextY,Direction,NameOnPCB,Scale,
                   TextFlags);
  AddTextToElement((TextTypePtr)(Element->Name + 2),PCBFont,TextX,TextY,Direction,Value,Scale,
                   TextFlags);
  *(ElementTypePtr **)&Element->Name[0].Element = Element;
  *(ElementTypePtr **)&Element->Name[1].Element = Element;
  *(ElementTypePtr **)&Element->Name[2].Element = Element;
  (Element->Flags).t[7] = Flags.t[7];
  (Element->Flags).t[6] = Flags.t[6];
  (Element->Flags).t[5] = Flags.t[5];
  (Element->Flags).t[4] = Flags.t[4];
  (Element->Flags).t[3] = Flags.t[3];
  (Element->Flags).t[2] = Flags.t[2];
  (Element->Flags).t[1] = Flags.t[1];
  (Element->Flags).t[0] = Flags.t[0];
  (Element->Flags).f = Flags.f;
  Element->ID = ID;
  ID = ID + 1;
  return Element;
}



PointTypePtr CreateNewPointInPolygon(PolygonTypePtr Polygon,LocationType X,LocationType Y)

{
  PointTypePtr pPVar1;
  
  pPVar1 = GetPointMemoryInPolygon(Polygon);
  pPVar1->X = X;
  pPVar1->Y = Y;
  pPVar1->ID = ID;
  ID = ID + 1;
  return pPVar1;
}



PolygonTypePtr CreateNewPolygon(LayerTypePtr Layer,FlagType Flags)

{
  PolygonTypePtr ppVar1;
  
  ppVar1 = GetPolygonMemory(Layer);
  (ppVar1->Flags).t[7] = Flags.t[7];
  (ppVar1->Flags).t[6] = Flags.t[6];
  (ppVar1->Flags).t[5] = Flags.t[5];
  (ppVar1->Flags).t[4] = Flags.t[4];
  ppVar1->Clipped = (POLYAREA *)0x0;
  ppVar1->NoHoles = (PLINE *)0x0;
  (ppVar1->Flags).t[3] = Flags.t[3];
  (ppVar1->Flags).t[2] = Flags.t[2];
  (ppVar1->Flags).t[1] = Flags.t[1];
  (ppVar1->Flags).t[0] = Flags.t[0];
  (ppVar1->Flags).f = Flags.f;
  ppVar1->ID = ID;
  ID = ID + 1;
  ppVar1->NoHolesValid = 0;
  return ppVar1;
}



TextTypePtr
CreateNewText(LayerTypePtr Layer,FontTypePtr PCBFont,LocationType X,LocationType Y,BYTE Direction,
             int Scale,char *TextString,FlagType Flags)

{
  TextTypePtr Text;
  char *pcVar1;
  rtree_t *rtree;
  
  Text = GetTextMemory(Layer);
  if (Text != (TextTypePtr)0x0) {
    Text->X = X;
    Text->Y = Y;
    Text->Direction = Direction;
    (Text->Flags).t[7] = Flags.t[7];
    (Text->Flags).t[6] = Flags.t[6];
    (Text->Flags).t[5] = Flags.t[5];
    (Text->Flags).t[4] = Flags.t[4];
    (Text->Flags).t[3] = Flags.t[3];
    (Text->Flags).t[2] = Flags.t[2];
    (Text->Flags).t[1] = Flags.t[1];
    (Text->Flags).t[0] = Flags.t[0];
    (Text->Flags).f = Flags.f;
    Text->Scale = Scale;
    pcVar1 = MyStrdup(TextString,"CreateNewText()");
    Text->TextString = pcVar1;
    SetTextBoundingBox(PCBFont,Text);
    Text->ID = ID;
    ID = ID + 1;
    rtree = Layer->text_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->text_tree = rtree;
    }
    r_insert_entry(rtree,(BoxType *)Text,0);
  }
  return Text;
}



PolygonTypePtr
CreateNewPolygonFromRectangle
          (LayerTypePtr Layer,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          FlagType Flags)

{
  PolygonTypePtr Polygon;
  rtree_t *rtree;
  
  Polygon = CreateNewPolygon(Layer,Flags);
  if (Polygon != (PolygonTypePtr)0x0) {
    CreateNewPointInPolygon(Polygon,X1,Y1);
    CreateNewPointInPolygon(Polygon,X2,Y1);
    CreateNewPointInPolygon(Polygon,X2,Y2);
    CreateNewPointInPolygon(Polygon,X1,Y2);
    SetPolygonBoundingBox(Polygon);
    rtree = Layer->polygon_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->polygon_tree = rtree;
    }
    r_insert_entry(rtree,(BoxType *)Polygon,0);
  }
  return Polygon;
}



ArcTypePtr *
CreateNewArcOnLayer(LayerTypePtr Layer,LocationType X1,LocationType Y1,BDimension width,
                   BDimension height,int sa,int dir,BDimension Thickness,BDimension Clearance,
                   FlagType Flags)

{
  ArcTypePtr *Arc;
  rtree_t *rtree;
  int *piVar1;
  int iVar2;
  
  iVar2 = Layer->ArcN - 1;
  if (iVar2 != -1) {
    piVar1 = &Layer->Arc[Layer->ArcN - 1].X;
    do {
      if ((((*piVar1 == X1) && (piVar1[1] == Y1)) && (piVar1[-2] == width)) &&
         (((piVar1[2] + 0x168) % 0x168 == (sa + 0x168) % 0x168 && (piVar1[3] == dir)))) {
        return (ArcTypePtr *)0x0;
      }
      iVar2 = iVar2 + -1;
      piVar1 = piVar1 + -0x11;
    } while (iVar2 != -1);
  }
  Arc = GetArcMemory(Layer);
  if (Arc != (ArcTypePtr *)0x0) {
    Arc->ID = ID;
    ID = ID + 1;
    (Arc->Flags).t[7] = Flags.t[7];
    (Arc->Flags).t[6] = Flags.t[6];
    (Arc->Flags).t[5] = Flags.t[5];
    (Arc->Flags).t[4] = Flags.t[4];
    (Arc->Flags).t[3] = Flags.t[3];
    (Arc->Flags).t[2] = Flags.t[2];
    (Arc->Flags).t[1] = Flags.t[1];
    (Arc->Flags).t[0] = Flags.t[0];
    Arc->Thickness = Thickness;
    (Arc->Flags).f = Flags.f;
    Arc->X = X1;
    Arc->Y = Y1;
    Arc->Clearance = Clearance;
    Arc->StartAngle = sa;
    Arc->Width = width;
    Arc->Height = height;
    Arc->Delta = dir;
    SetArcBoundingBox(Arc);
    rtree = Layer->arc_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->arc_tree = rtree;
    }
    r_insert_entry(rtree,(BoxType *)Arc,0);
  }
  return Arc;
}



RatTypePtr *
CreateNewRat(DataTypePtr *Data,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
            Cardinal group1,Cardinal group2,BDimension Thickness,FlagType Flags)

{
  int iVar1;
  RatTypePtr *Line;
  rtree_t *rtree;
  
  Line = GetRatMemory(Data);
  if (Line != (RatTypePtr *)0x0) {
    (Line->Flags).t[7] = Flags.t[7];
    (Line->Flags).t[6] = Flags.t[6];
    Line->ID = ID;
    (Line->Point1).ID = ID + 1;
    iVar1 = ID + 2;
    ID = ID + 3;
    (Line->Point2).ID = iVar1;
    (Line->Flags).t[5] = Flags.t[5];
    (Line->Flags).t[4] = Flags.t[4];
    (Line->Flags).t[3] = Flags.t[3];
    (Line->Flags).t[2] = Flags.t[2];
    (Line->Flags).t[1] = Flags.t[1];
    (Line->Flags).t[0] = Flags.t[0];
    (Line->Flags).f = Flags.f | 0x10;
    Line->Thickness = Thickness;
    (Line->Point1).X = X1;
    (Line->Point1).Y = Y1;
    (Line->Point2).X = X2;
    (Line->Point2).Y = Y2;
    Line->group1 = group1;
    Line->group2 = group2;
    SetLineBoundingBox((LineTypePtr)Line);
    rtree = Data->rat_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Data->rat_tree = rtree;
    }
    r_insert_entry(rtree,(BoxType *)Line,0);
  }
  return Line;
}



LineTypePtr
CreateNewLineOnLayer
          (LayerTypePtr Layer,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness,BDimension Clearance,FlagType Flags)

{
  int iVar1;
  LineTypePtr Line;
  rtree_t *rtree;
  
  Line = GetLineMemory(Layer);
  if (Line != (LineTypePtr)0x0) {
    (Line->Flags).t[7] = Flags.t[7];
    (Line->Flags).t[6] = Flags.t[6];
    Line->ID = ID;
    (Line->Point1).ID = ID + 1;
    iVar1 = ID + 2;
    ID = ID + 3;
    (Line->Point2).ID = iVar1;
    (Line->Flags).t[5] = Flags.t[5];
    (Line->Flags).t[4] = Flags.t[4];
    (Line->Flags).t[3] = Flags.t[3];
    (Line->Flags).t[2] = Flags.t[2];
    (Line->Flags).t[1] = Flags.t[1];
    (Line->Flags).t[0] = Flags.t[0];
    (Line->Flags).f = Flags.f & 0xffffffef;
    Line->Thickness = Thickness;
    Line->Clearance = Clearance;
    (Line->Point1).X = X1;
    (Line->Point1).Y = Y1;
    (Line->Point2).X = X2;
    (Line->Point2).Y = Y2;
    SetLineBoundingBox(Line);
    rtree = Layer->line_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Layer->line_tree = rtree;
    }
    r_insert_entry(rtree,(BoxType *)Line,0);
  }
  return Line;
}



LineTypePtr
CreateDrawnLineOnLayer
          (LayerTypePtr Layer,LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
          BDimension Thickness,BDimension Clearance,FlagType Flags)

{
  int iVar1;
  int iVar2;
  LineTypePtr pLVar3;
  int in_GS_OFFSET;
  ulong local_14c;
  undefined4 local_148;
  undefined4 local_144;
  BoxType search;
  line_info info;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  search.X1 = X1;
  if (X2 <= X1) {
    search.X1 = X2;
  }
  search.X2 = X1;
  if (X1 <= X2) {
    search.X2 = X2;
  }
  search.Y1 = Y1;
  if (Y2 <= Y1) {
    search.Y1 = Y2;
  }
  search.Y2 = Y1;
  if (Y1 <= Y2) {
    search.Y2 = Y2;
  }
  if (search.Y1 == search.Y2) {
    search.Y2 = search.Y1 + 1;
  }
  if (search.X1 == search.X2) {
    search.X2 = search.X1 + 1;
  }
  info.test.Thickness = 0;
  info.X1 = X1;
  info.X2 = X2;
  info.Y1 = Y1;
  info.Y2 = Y2;
  info.Thickness = Thickness;
  info.Flags.f = Flags.f;
  MakeFlags((FlagType *)&local_14c,0);
  info.ans = (LineType *)0x0;
  info.test.Flags.f = local_14c;
  info.test.Flags.t._0_4_ = local_148;
  info.test.Flags.t._4_4_ = local_144;
  iVar2 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar2 == 0) {
    r_search(Layer->line_tree,&search,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,line_callback,&info)
    ;
  }
  else {
    pLVar3 = (LineTypePtr)0x0;
    if (info.ans == (LineType *)0xffffffff) goto LAB_0808019b;
    if (info.ans != (LineType *)0x0) {
      MoveObjectToRemoveUndoList(4,Layer,info.ans,info.ans);
      X1 = info.test.Point1.X;
      X2 = info.test.Point2.X;
      Y1 = info.test.Point1.Y;
      Y2 = info.test.Point2.Y;
    }
  }
  pLVar3 = CreateNewLineOnLayer(Layer,X1,Y1,X2,Y2,Thickness,Clearance,Flags);
LAB_0808019b:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pLVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int line_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  Boolean BVar3;
  LocationType LVar4;
  int iVar5;
  
  iVar1 = *(int *)cl;
  iVar2 = b[2].Y2;
  if (iVar2 == iVar1) {
    iVar5 = b[4].X1;
    if (((iVar5 == *(int *)((int)cl + 4)) && (b[3].X1 == *(int *)((int)cl + 8))) &&
       (b[4].Y1 == *(int *)((int)cl + 0xc))) goto LAB_08080331;
  }
  else {
    iVar5 = b[4].X1;
  }
  if (((iVar1 == iVar5) && (iVar2 == *(int *)((int)cl + 4))) &&
     ((b[4].Y1 == *(int *)((int)cl + 8) && (b[3].X1 == *(int *)((int)cl + 0xc))))) {
LAB_08080331:
    *(undefined4 *)((int)cl + 0x78) = 0xffffffff;
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x7c,1);
  }
  if ((b[2].Y1 == *(int *)((int)cl + 0x10)) && (((b[1].Y1 ^ *(uint *)((int)cl + 0x14)) & 0x20) == 0)
     ) {
    if ((iVar2 == iVar1) && (b[3].X1 == *(int *)((int)cl + 8))) {
      LVar4 = b[4].Y1;
      *(int *)((int)cl + 0x4c) = iVar5;
    }
    else {
      if ((iVar1 != iVar5) || (b[4].Y1 != *(int *)((int)cl + 8))) {
        if ((iVar2 == *(int *)((int)cl + 4)) && (b[3].X1 == *(int *)((int)cl + 0xc))) {
          *(int *)((int)cl + 0x4c) = iVar5;
          LVar4 = b[4].Y1;
        }
        else {
          if (iVar5 != *(int *)((int)cl + 4)) {
            return 0;
          }
          if (b[4].Y1 != *(int *)((int)cl + 0xc)) {
            return 0;
          }
          *(int *)((int)cl + 0x4c) = iVar2;
          LVar4 = b[3].X1;
        }
        *(int *)((int)cl + 0x60) = iVar1;
        *(LocationType *)((int)cl + 0x50) = LVar4;
        *(undefined4 *)((int)cl + 100) = *(undefined4 *)((int)cl + 8);
        BVar3 = IsPointOnLine((float)*(int *)((int)cl + 4),(float)*(int *)((int)cl + 0xc),0.00000000
                              ,(LineTypePtr)((int)cl + 0x20));
        if (BVar3 == '\0') {
          return 0;
        }
        goto LAB_080802f5;
      }
      *(int *)((int)cl + 0x4c) = iVar2;
      LVar4 = b[3].X1;
    }
    *(LocationType *)((int)cl + 0x50) = LVar4;
    *(undefined4 *)((int)cl + 0x60) = *(undefined4 *)((int)cl + 4);
    *(undefined4 *)((int)cl + 100) = *(undefined4 *)((int)cl + 0xc);
    BVar3 = IsPointOnLine((float)*(int *)cl,(float)*(int *)((int)cl + 8),0.00000000,
                          (LineTypePtr)((int)cl + 0x20));
    if (BVar3 != '\0') {
LAB_080802f5:
      *(BoxType **)((int)cl + 0x78) = b;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x7c,1);
    }
  }
  return 0;
}



PinTypePtr *
CreateNewVia(DataTypePtr *Data,LocationType X,LocationType Y,BDimension Thickness,
            BDimension Clearance,BDimension Mask,BDimension DrillingHole,char *Name,FlagType Flags)

{
  PinTypePtr *Pin;
  int iVar1;
  char *pcVar2;
  rtree_t *rtree;
  uint uVar3;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  
  if (Data->ViaN != 0) {
    Pin = Data->Via;
    uVar3 = 0;
    do {
      fVar4 = (float10)(Pin->X - X);
      fVar5 = (float10)(Pin->Y - Y);
      fVar6 = (float10)(Pin->Thickness / 2 + Thickness / 2);
      if (fVar5 * fVar5 + fVar4 * fVar4 <= fVar6 * fVar6) {
        Message("Dropping via at (%d, %d) because it would overlap with the viaat (%d, %d)\n",
                X / 100,Y / 100,Pin->X / 100,Pin->Y / 100);
        return (PinTypePtr *)0x0;
      }
      uVar3 = uVar3 + 1;
      Pin = Pin + 1;
    } while (uVar3 < Data->ViaN);
  }
  Pin = GetViaMemory(Data);
  if (Pin != (PinTypePtr *)0x0) {
    Pin->X = X;
    Pin->Y = Y;
    Pin->Thickness = Thickness;
    Pin->Clearance = Clearance;
    Pin->Mask = Mask;
    iVar1 = vendorDrillMap(DrillingHole);
    Pin->DrillingHole = iVar1;
    if (DrillingHole != iVar1) {
      Message("Mapped via drill hole to %.2f mils from %.2f mils per vendor table\n",
              (double)iVar1 * 0.01000000,(double)DrillingHole * 0.01000000);
    }
    pcVar2 = MyStrdup(Name,"CreateNewVia()");
    Pin->Name = pcVar2;
    (Pin->Flags).t[7] = Flags.t[7];
    (Pin->Flags).t[6] = Flags.t[6];
    (Pin->Flags).t[5] = Flags.t[5];
    (Pin->Flags).t[4] = Flags.t[4];
    (Pin->Flags).t[3] = Flags.t[3];
    (Pin->Flags).t[2] = Flags.t[2];
    (Pin->Flags).t[1] = Flags.t[1];
    (Pin->Flags).t[0] = Flags.t[0];
    Pin->ID = ID;
    ID = ID + 1;
    (Pin->Flags).f = Flags.f & 0xfffffdff | 2;
    if (((Flags & (undefined  [12])0x8) == (undefined  [12])0x0) &&
       (Pin->Thickness <= Pin->DrillingHole + 399)) {
      iVar1 = Pin->DrillingHole + 400;
      Pin->Thickness = iVar1;
      Message("Increased via thickness to %.2f mils to allow enough copper at (%.2f,%.2f).\n",
              (double)iVar1 * 0.01000000,(double)Pin->X * 0.01000000,(double)Pin->Y * 0.01000000);
    }
    SetPinBoundingBox((PinTypePtr_conflict)Pin);
    rtree = Data->via_tree;
    if (rtree == (rtree_t *)0x0) {
      rtree = r_create_tree((BoxType **)0x0,0,0);
      Data->via_tree = rtree;
    }
    r_insert_entry(rtree,(BoxType *)Pin,0);
  }
  return Pin;
}



int CreateNewPCBPost(PCBTypePtr pcb,int use_defaults)

{
  DataTypePtr *pDVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  
  pcb_colors_from_settings(pcb);
  iVar3 = 0;
  if (use_defaults != 0) {
    iVar4 = ParseGroupString(Settings.Groups,(LayerGroupTypePtr)&pcb->LayerGroups,8);
    iVar3 = 1;
    if (iVar4 == 0) {
      pDVar1 = pcb->Data;
      iVar3 = PCB->Data->LayerN;
      pcVar5 = MyStrdup("silk","CreateNewPCB()");
      pDVar2 = pcb->Data;
      *(char **)(&pDVar1->field_0x4c + (iVar3 + 1) * 0x5c) = pcVar5;
      iVar3 = PCB->Data->LayerN;
      pcVar5 = MyStrdup("silk","CreateNewPCB()");
      *(char **)(&pDVar2->field_0x4c + iVar3 * 0x5c) = pcVar5;
      iVar3 = 0;
    }
  }
  return iVar3;
}



DataTypePtr * CreateNewBuffer(void)

{
  DataTypePtr *pDVar1;
  
  pDVar1 = (DataTypePtr *)MyCalloc(1,0x6c4,"CreateNewBuffer()");
  *(PCBTypePtr *)&pDVar1->field_0x48 = PCB;
  return pDVar1;
}



PCBTypePtr CreateNewPCB(Boolean SetDefaultNames)

{
  uint uVar1;
  undefined4 uVar2;
  double dVar3;
  PCBTypePtr pPVar4;
  DataTypePtr *pDVar5;
  int iVar6;
  char *pcVar7;
  int iVar8;
  LayerGroupType *pLVar9;
  LayerGroupType *pLVar10;
  byte bVar11;
  
  bVar11 = 0;
  pPVar4 = (PCBTypePtr)MyCalloc(1,0x2210,"CreateNewPCB()");
  pDVar5 = CreateNewBuffer();
  *(PCBTypePtr *)&pDVar5->field_0x48 = pPVar4;
  pPVar4->Data = pDVar5;
  uVar1 = (pPVar4->Flags).f;
  pPVar4->ThermStyle = '\x04';
  pPVar4->IsleArea = 200000000.00000000;
  pPVar4->SilkActive = '\0';
  pPVar4->RatDraw = '\0';
  (pPVar4->Flags).f = uVar1 | 0x40;
  if (Settings.ShowNumber != '\0') {
    (pPVar4->Flags).f = uVar1 | 0x41;
  }
  if (Settings.AllDirectionLines != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x100;
  }
  pPVar4->Clipping = 1;
  if (Settings.RubberBandMode != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x10;
  }
  if (Settings.SwapStartDirection != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x200;
  }
  if (Settings.UniqueNames != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x400;
  }
  if (Settings.SnapPin != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x1000;
  }
  if (Settings.ClearLine != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x800;
  }
  if (Settings.FullPoly != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x100000;
  }
  if (Settings.OrthogonalMoves != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x8000;
  }
  if (Settings.liveRouting != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x10000;
  }
  if (Settings.ShowDRC != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 8;
  }
  if (Settings.AutoDRC != '\0') {
    (pPVar4->Flags).f = (pPVar4->Flags).f | 0x80;
  }
  dVar3 = Settings.Grid;
  iVar8 = 0x130;
  iVar6 = 0;
  pLVar9 = &Settings.LayerGroups;
  pLVar10 = &pPVar4->LayerGroups;
  while (iVar8 != 0) {
    iVar8 = iVar8 + -1;
    pLVar10->Number[0] = pLVar9->Number[0];
    pLVar9 = (LayerGroupType *)(pLVar9->Number + (uint)bVar11 * 0x3ffffffe + 1);
    pLVar10 = (LayerGroupType *)((int)pLVar10 + (uint)bVar11 * -8 + 4);
  }
  pPVar4->Grid = dVar3;
  iVar8 = 0;
  do {
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Thick + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Thick + iVar6);
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Diameter + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Diameter + iVar6);
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Hole + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Hole + iVar6);
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Keepaway + iVar6) =
         *(undefined4 *)((int)&Settings.RouteStyle[0].Keepaway + iVar6);
    uVar2 = *(undefined4 *)((int)&Settings.RouteStyle[0].Name + iVar6);
    *(int *)((int)&pPVar4->RouteStyle[0].index + iVar6) = iVar8;
    iVar8 = iVar8 + 1;
    *(undefined4 *)((int)&pPVar4->RouteStyle[0].Name + iVar6) = uVar2;
    iVar6 = iVar6 + 0x18;
  } while (iVar8 != 4);
  iVar8 = 0;
  hid_action("RouteStylesChanged");
  pPVar4->MaxWidth = Settings.MaxWidth;
  iVar6 = Settings.MaxHeight;
  pPVar4->Zoom = Settings.Zoom;
  pPVar4->MaxHeight = iVar6;
  pPVar4->ThermScale = 0.50000000;
  pPVar4->ID = ID;
  ID = ID + 1;
  pPVar4->Bloat = Settings.Bloat;
  pPVar4->Shrink = Settings.Shrink;
  pPVar4->minWid = Settings.minWid;
  pPVar4->minSlk = Settings.minSlk;
  pPVar4->minDrill = Settings.minDrill;
  pPVar4->minRing = Settings.minRing;
  do {
    pDVar5 = pPVar4->Data;
    pcVar7 = MyStrdup(Settings.DefaultLayerName[iVar8],"CreateNewPCB()");
    iVar6 = iVar8 * 0x5c;
    iVar8 = iVar8 + 1;
    *(char **)(&pDVar5->field_0x4c + iVar6) = pcVar7;
  } while (iVar8 != 0x10);
  return pPVar4;
}



void __regparm3 XORPolygon(PolygonTypePtr polygon,LocationType dx,LocationType dy)

{
  int *piVar1;
  PointTypePtr pPVar2;
  uint uVar3;
  uint uVar4;
  
  if (polygon->PointN != 1) {
    uVar3 = 0;
    do {
      uVar4 = uVar3 + 1;
      piVar1 = &polygon->Points->X + uVar3 * 5 + 5;
      pPVar2 = polygon->Points + uVar3;
      (*gui->draw_line)(Crosshair.GC,dx + pPVar2->X,dy + pPVar2->Y,dx + *piVar1,dy + piVar1[1]);
      uVar3 = uVar4;
    } while (uVar4 < polygon->PointN - 1);
    if (uVar4 != 1) {
      pPVar2 = polygon->Points;
      (*gui->draw_line)(Crosshair.GC,dx + pPVar2[uVar4].X,dy + pPVar2[uVar4].Y,dx + pPVar2->X,
                        pPVar2->Y + dy);
    }
  }
  return;
}



void __regparm3 XORDrawElement(ElementTypePtr *Element,LocationType DX,LocationType DY)

{
  uint uVar1;
  Cardinal CVar2;
  uint uVar3;
  PinTypePtr *pPVar4;
  int local_74;
  int iVar5;
  int local_70;
  Cardinal CVar6;
  int local_78;
  int local_6c;
  uint uVar7;
  int iVar8;
  int local_50;
  int local_34;
  uint local_30;
  
  CVar2 = Element->ArcN;
  if (CVar2 == 0) {
    CVar6 = Element->LineN;
    if (CVar6 == 0) {
      local_6c = (Element->BoundingBox).X1 + DX;
      (*gui->draw_line)(Crosshair.GC,local_6c,(Element->BoundingBox).Y1 + DY,local_6c,
                        (Element->BoundingBox).Y2 + DY);
      local_6c = (Element->BoundingBox).Y2 + DY;
      (*gui->draw_line)(Crosshair.GC,(Element->BoundingBox).X1 + DX,local_6c,
                        (Element->BoundingBox).X2 + DX,local_6c);
      local_6c = (Element->BoundingBox).X2 + DX;
      (*gui->draw_line)(Crosshair.GC,local_6c,(Element->BoundingBox).Y2 + DY,local_6c,
                        (Element->BoundingBox).Y1 + DY);
      local_6c = (Element->BoundingBox).Y1 + DY;
      (*gui->draw_line)(Crosshair.GC,(Element->BoundingBox).X2 + DX,local_6c,
                        (Element->BoundingBox).X1 + DX,local_6c);
      goto LAB_08080be6;
    }
  }
  else {
    CVar6 = Element->LineN;
  }
  local_6c = CVar6 - 1;
  if (local_6c != -1) {
    iVar5 = CVar6 * 0x58;
    do {
      local_6c = local_6c + -1;
      local_70 = (int)&Element->Line[-1].BoundingBox.X1 + iVar5;
      (*gui->draw_line)(Crosshair.GC,DX + *(int *)(local_70 + 0x2c),*(int *)(local_70 + 0x30) + DY,
                        *(int *)(local_70 + 0x40) + DX,*(int *)(local_70 + 0x44) + DY);
      iVar5 = iVar5 + -0x58;
    } while (local_6c != -1);
    CVar2 = Element->ArcN;
  }
  local_6c = CVar2 - 1;
  if (local_6c != -1) {
    iVar5 = CVar2 * 0x44;
    do {
      local_6c = local_6c + -1;
      local_70 = (int)&Element->Arc[-1].BoundingBox.X1 + iVar5;
      (*gui->draw_arc)(Crosshair.GC,DX + *(int *)(local_70 + 0x34),DY + *(int *)(local_70 + 0x38),
                       *(int *)(local_70 + 0x2c),*(int *)(local_70 + 0x30),*(int *)(local_70 + 0x3c)
                       ,*(int *)(local_70 + 0x40));
      iVar5 = iVar5 + -0x44;
    } while (local_6c != -1);
  }
LAB_08080be6:
  if (Element->PinN != 0) {
    uVar7 = 0;
    uVar3 = Element->PinN;
    do {
      pPVar4 = Element->Pin + uVar7;
      local_6c = pPVar4->Thickness / 2;
      (*gui->draw_arc)(Crosshair.GC,pPVar4->X + DX,DY + pPVar4->Y,local_6c,local_6c,0,0x168);
      uVar1 = Element->PinN;
      if (uVar1 == 0) break;
      uVar7 = (uVar1 + 1 + uVar7) - uVar3;
      uVar3 = uVar1;
    } while (uVar7 < uVar1);
  }
  CVar2 = Element->PadN;
  local_34 = 0;
  local_30 = 0;
  CVar6 = CVar2;
  do {
    if ((CVar6 == 0) || (CVar6 <= local_30)) {
      local_6c = Element->MarkX + DX;
      iVar5 = Element->MarkY + DY;
      (*gui->draw_line)(Crosshair.GC,local_6c + -1000,iVar5,local_6c,iVar5 + -1000);
      local_6c = Element->MarkX + DX;
      iVar5 = Element->MarkY + DY;
      (*gui->draw_line)(Crosshair.GC,local_6c + 1000,iVar5,local_6c,iVar5 + -1000);
      local_6c = Element->MarkX + DX;
      iVar5 = Element->MarkY + DY;
      (*gui->draw_line)(Crosshair.GC,local_6c + -1000,iVar5,local_6c,iVar5 + 1000);
      iVar5 = DY + Element->MarkY;
      local_6c = DX + Element->MarkX;
      (*gui->draw_line)(Crosshair.GC,local_6c + 1000,iVar5,local_6c,iVar5 + 1000);
      return;
    }
    local_6c = (int)&(Element->Pad->BoundingBox).X1 + local_34;
    if (((*(uint *)(local_6c + 0x14) >> 7 & 1) == (int)Settings.ShowSolderSide) ||
       (PCB->InvisibleObjectsOn != '\0')) {
      iVar5 = *(int *)(local_6c + 0x2c);
      local_70 = *(int *)(local_6c + 0x40);
      if (iVar5 == local_70) {
        local_74 = *(int *)(local_6c + 0x30);
        local_50 = *(int *)(local_6c + 0x44);
LAB_08080c9b:
        iVar8 = -(*(int *)(local_6c + 0x24) / 2);
        local_78 = iVar5;
        if (local_70 <= iVar5) {
          local_78 = local_70;
        }
        local_78 = local_78 + iVar8 + DX;
        local_6c = *(int *)(local_6c + 0x24) / 2;
        if (iVar5 <= local_70) {
          iVar5 = local_70;
        }
        local_70 = iVar5 + local_6c + DX;
        iVar5 = local_50;
        if (local_74 < local_50) {
          iVar5 = local_74;
        }
        iVar5 = iVar5 + DY + iVar8;
        if (local_50 < local_74) {
          local_50 = local_74;
        }
        local_74 = local_50 + DY + local_6c;
        (*gui->draw_line)(Crosshair.GC,local_78,iVar5,local_70,iVar5);
        (*gui->draw_line)(Crosshair.GC,local_78,iVar5,local_78,local_74);
        (*gui->draw_line)(Crosshair.GC,local_70,iVar5,local_70,local_74);
        local_6c = local_74;
      }
      else {
        local_74 = *(int *)(local_6c + 0x30);
        local_50 = local_74;
        if (local_74 == *(int *)(local_6c + 0x44)) goto LAB_08080c9b;
        local_70 = local_70 + DX;
        local_74 = local_74 + DY;
        local_78 = iVar5 + DX;
        local_6c = *(int *)(local_6c + 0x44) + DY;
      }
      (*gui->draw_line)(Crosshair.GC,local_78,local_74,local_70,local_6c);
      CVar6 = Element->PadN;
    }
    if (CVar2 == CVar6) {
      local_30 = local_30 + 1;
      local_34 = local_34 + 0x68;
      CVar6 = CVar2;
    }
  } while( true );
}



void DrawMark(Boolean ifvis)

{
  if ((ifvis != '\0') && (Marked.status == '\0')) {
    return;
  }
  (*gui->draw_line)(Crosshair.GC,Marked.X + -5000,Marked.Y + -5000,Marked.X + 5000,Marked.Y + 5000);
  (*gui->draw_line)(Crosshair.GC,Marked.X + 5000,Marked.Y + -5000,Marked.X + -5000,Marked.Y + 5000);
  return;
}



void InitCrosshair(void)

{
  Crosshair.GC = (*gui->make_gc)();
  (*gui->set_color)(Crosshair.GC,Settings.CrosshairColor);
  (*gui->set_draw_xor)(Crosshair.GC,1);
  (*gui->set_line_cap)(Crosshair.GC,Trace_Cap);
  (*gui->set_line_width)(Crosshair.GC,1);
  CrosshairStackLocation = 1;
  CrosshairStack[0] = '\x01';
  Marked.status = '\0';
  Crosshair.MinX = 0;
  Crosshair.MinY = 0;
  Crosshair.MaxX = PCB->MaxWidth;
  Crosshair.MaxY = PCB->MaxHeight;
  Crosshair.On = '\0';
  Crosshair.shape = Basic_Crosshair_Shape;
  return;
}



void FitCrosshairIntoGrid(LocationType X,LocationType Y)

{
  double dVar1;
  void *pvVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  char cVar11;
  int iVar12;
  int iVar13;
  float10 fVar14;
  float10 fVar15;
  float10 fVar16;
  float10 fVar17;
  int local_50;
  int local_44;
  uint local_40;
  int *local_28;
  void *local_24;
  void *local_20 [4];
  
  local_44 = PCB->MaxWidth;
  iVar4 = PCB->MaxHeight;
  if (X < Crosshair.MinX) {
    X = Crosshair.MinX;
  }
  Crosshair.X = X;
  if (Crosshair.MaxX < X) {
    Crosshair.X = Crosshair.MaxX;
  }
  if (Y < Crosshair.MinY) {
    Y = Crosshair.MinY;
  }
  Crosshair.Y = Y;
  if (Crosshair.MaxY < Y) {
    Crosshair.Y = Crosshair.MaxY;
  }
  if (PCB->RatDraw == '\0') {
    cVar11 = '\0';
    uVar3 = 0;
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x10) != 0) goto LAB_08081418;
LAB_080811d3:
    if (Settings.Mode != 0x68) goto LAB_080811e2;
LAB_080814ee:
    if (Crosshair.AttachedObject.Type == 1) {
      if ((uVar3 & 0x101) == 0) goto LAB_080811e2;
    }
    else {
      if (((Crosshair.AttachedObject.Type != 2) || ((uVar3 & 0x300) == 0)) ||
         (Crosshair.AttachedObject.Ptr1 != local_20[0])) goto LAB_080811e2;
    }
    local_40 = 0;
    uVar3 = 0;
  }
  else {
LAB_08081418:
    uVar3 = SearchScreen(Crosshair.X,Crosshair.Y,0x300,local_20,&local_24,&local_28);
    if (uVar3 == 0) {
      cVar11 = PCB->RatDraw;
      if (cVar11 != '\0') goto LAB_080811d3;
      uVar3 = SearchScreen(Crosshair.X,Crosshair.Y,0x1001,local_20,&local_24,&local_28);
      if (uVar3 == 0) {
        cVar11 = PCB->RatDraw;
        if (cVar11 != '\0') goto LAB_080811d3;
        uVar3 = SearchScreen(Crosshair.X,Crosshair.Y,2,local_20,&local_24,&local_28);
      }
    }
    cVar11 = PCB->RatDraw;
    if (Settings.Mode == 0x68) goto LAB_080814ee;
LAB_080811e2:
    local_40 = uVar3 & 0x200;
  }
  pvVar2 = local_24;
  local_50 = -600;
  iVar10 = -600;
  if (cVar11 == '\0') {
    if ((Crosshair.X < 0) || (local_44 < Crosshair.X)) {
      dVar1 = PCB->Grid;
      if ((double)(local_44 + 1) < dVar1) {
        local_44 = local_44 / 2;
        goto LAB_08081274;
      }
      local_44 = (int)ROUND((double)(int)ROUND((dVar1 * 0.50000000 +
                                               (dVar1 - (double)PCB->GridOffsetX)) / dVar1) * dVar1
                            + 0.50000000 + (double)PCB->GridOffsetX);
      if (-1 < Crosshair.Y) goto LAB_08081285;
LAB_08081690:
      if ((double)(iVar4 + 1) < dVar1) {
        local_50 = iVar4 / 2;
      }
      else {
        local_50 = (int)ROUND((double)PCB->GridOffsetY +
                              (double)(int)ROUND((dVar1 * 0.50000000 +
                                                 (dVar1 - (double)PCB->GridOffsetY)) / dVar1) *
                              dVar1 + 0.50000000);
      }
    }
    else {
      dVar1 = PCB->Grid;
      local_44 = (int)ROUND((double)PCB->GridOffsetX +
                            (double)(int)ROUND((dVar1 * 0.50000000 +
                                               (double)(Crosshair.X - PCB->GridOffsetX)) / dVar1) *
                            dVar1 + 0.50000000);
LAB_08081274:
      if (Crosshair.Y < 0) goto LAB_08081690;
LAB_08081285:
      if (iVar4 < Crosshair.Y) goto LAB_08081690;
      local_50 = (int)ROUND((double)PCB->GridOffsetY +
                            (double)(int)ROUND((dVar1 * 0.50000000 +
                                               (double)(Crosshair.Y - PCB->GridOffsetY)) / dVar1) *
                            dVar1 + 0.50000000);
    }
    iVar10 = local_44;
    if (((Marked.status != '\0') && (*(short *)&(PCB->Flags).f < 0)) &&
       (uVar7 = Crosshair.X - Marked.X >> 0x1f, uVar8 = Crosshair.Y - Marked.Y >> 0x1f,
       iVar10 = Marked.X,
       (int)((Crosshair.Y - Marked.Y ^ uVar8) - uVar8) <
       (int)((Crosshair.X - Marked.X ^ uVar7) - uVar7))) {
      iVar10 = local_44;
      local_50 = Marked.Y;
    }
  }
  if (local_40 == 0) {
    if ((uVar3 & 0x101) == 0) {
      if ((uVar3 & 0x1000) == 0) {
        if ((uVar3 & 2) != 0) {
          fVar14 = (float10)(*(int *)((int)local_20[0] + 0xd8) - Crosshair.X);
          fVar15 = (float10)(*(int *)((int)local_20[0] + 0xdc) - Crosshair.Y);
          iVar4 = *(int *)((int)local_20[0] + 0xd8);
          iVar12 = *(int *)((int)local_20[0] + 0xdc);
          if (fVar15 * fVar15 + fVar14 * fVar14 <
              (float10)(local_50 - Crosshair.Y) * (float10)(local_50 - Crosshair.Y) +
              (float10)(iVar10 - Crosshair.X) * (float10)(iVar10 - Crosshair.X)) goto LAB_080813c4;
        }
      }
      else {
        iVar6 = *local_28 - Crosshair.X;
        iVar9 = local_28[1] - Crosshair.Y;
        iVar4 = *local_28;
        iVar12 = local_28[1];
        if (iVar9 * iVar9 + iVar6 * iVar6 <
            (local_50 - Crosshair.Y) * (local_50 - Crosshair.Y) +
            (iVar10 - Crosshair.X) * (iVar10 - Crosshair.X)) goto LAB_080813c4;
      }
      iVar4 = iVar10;
      iVar12 = local_50;
      goto LAB_080813c4;
    }
    iVar4 = (*gui->shift_is_pressed)();
    if (iVar4 != 0) {
      iVar9 = *(int *)((int)pvVar2 + 0x34);
      iVar6 = iVar9 - Crosshair.X;
      iVar13 = *(int *)((int)pvVar2 + 0x38);
      iVar5 = iVar13 - Crosshair.Y;
      goto LAB_080815e6;
    }
    iVar9 = *(int *)((int)pvVar2 + 0x34);
    iVar13 = *(int *)((int)pvVar2 + 0x38);
  }
  else {
    fVar14 = (float10)(*(int *)((int)local_24 + 0x2c) - Crosshair.X);
    fVar15 = (float10)(*(int *)((int)local_24 + 0x30) - Crosshair.Y);
    fVar16 = (float10)(*(int *)((int)local_24 + 0x40) - Crosshair.X);
    fVar17 = (float10)(*(int *)((int)local_24 + 0x44) - Crosshair.Y);
    iVar9 = *(int *)((int)local_24 + 0x2c);
    iVar13 = *(int *)((int)local_24 + 0x30);
    if (fVar17 * fVar17 + fVar16 * fVar16 <= fVar15 * fVar15 + fVar14 * fVar14) {
      iVar9 = *(int *)((int)local_24 + 0x40);
      iVar13 = *(int *)((int)local_24 + 0x44);
    }
    iVar4 = (*gui->shift_is_pressed)();
    if (iVar4 != 0) {
      iVar6 = iVar9 - Crosshair.X;
      iVar5 = iVar13 - Crosshair.Y;
LAB_080815e6:
      iVar4 = iVar10;
      iVar12 = local_50;
      if ((float10)(local_50 - Crosshair.Y) * (float10)(local_50 - Crosshair.Y) +
          (float10)(iVar10 - Crosshair.X) * (float10)(iVar10 - Crosshair.X) <=
          (float10)iVar5 * (float10)iVar5 + (float10)iVar6 * (float10)iVar6) goto LAB_080813c4;
    }
  }
  iVar4 = iVar9;
  iVar12 = iVar13;
LAB_080813c4:
  if ((-1 < iVar12) && (-1 < iVar4)) {
    Crosshair.X = iVar4;
    Crosshair.Y = iVar12;
  }
  if (Settings.Mode == 0x6e) {
    iVar4 = SearchScreen(Crosshair.X,Crosshair.Y,0x1000,local_20,&local_24,&local_28);
    if (iVar4 == 0) {
      hid_action("PointCursor");
    }
    else {
      if ((*(byte *)((int)local_24 + 0x14) & 0x40) == 0) {
        hid_actionl("PointCursor",&DAT_0813ecf0,0);
      }
    }
  }
  if (((Settings.Mode == 2) && (Crosshair.AttachedLine.State != 0)) &&
     (*(char *)&(PCB->Flags).f < '\0')) {
    EnforceLineDRC();
  }
  (*gui->set_crosshair)(Crosshair.X,Crosshair.Y,0);
  return;
}



void MoveCrosshairRelative(LocationType DeltaX,LocationType DeltaY)

{
  FitCrosshairIntoGrid(DeltaX + Crosshair.X,DeltaY + Crosshair.Y);
  return;
}



void SetCrosshairRange(LocationType MinX,LocationType MinY,LocationType MaxX,LocationType MaxY)

{
  if (MinX < 0) {
    MinX = 0;
  }
  Crosshair.MinY = 0;
  if (-1 < MinY) {
    Crosshair.MinY = MinY;
  }
  Crosshair.MaxX = PCB->MaxWidth;
  if (MaxX <= PCB->MaxWidth) {
    Crosshair.MaxX = MaxX;
  }
  Crosshair.MaxY = PCB->MaxHeight;
  if (MaxY <= PCB->MaxHeight) {
    Crosshair.MaxY = MaxY;
  }
  Crosshair.MinX = MinX;
  MoveCrosshairRelative(0,0);
  return;
}



void __regparm3 XORDrawAttachedArc(BDimension thick)

{
  int iVar1;
  BoxTypePtr pBVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  anon_subr_void_hidGC_int_int_int_int_int_int_for_draw_arc *paVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  int in_GS_OFFSET;
  int local_70;
  ArcType arc;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  uVar4 = Crosshair.X - Crosshair.AttachedBox.Point1.X;
  uVar9 = Crosshair.Y - Crosshair.AttachedBox.Point1.Y;
  if ((uVar9 == 0) && (uVar4 == 0)) goto LAB_08081a9b;
  arc.X = Crosshair.AttachedBox.Point1.X;
  arc.Y = Crosshair.AttachedBox.Point1.Y;
  uVar5 = (int)uVar4 >> 0x1f;
  uVar10 = (int)uVar9 >> 0x1f;
  if (Crosshair.AttachedBox.otherway == '\0') {
    local_70 = (uVar9 ^ uVar10) - uVar10;
    iVar11 = (uVar5 ^ uVar4) - uVar5;
    if (local_70 <= iVar11) goto LAB_080819f9;
LAB_08081ae1:
    if ((int)uVar4 < 0) {
      iVar11 = -local_70;
      uVar4 = 0xffffffff;
      iVar8 = 0xb4;
    }
    else {
      uVar4 = 1;
      iVar8 = 0;
      iVar11 = local_70;
    }
    arc.X = iVar11 + Crosshair.AttachedBox.Point1.X;
    iVar11 = -0x5a;
    if (uVar4 == (uVar10 | 1)) {
      iVar11 = 0x5a;
    }
  }
  else {
    local_70 = (uVar9 ^ uVar10) - uVar10;
    iVar11 = (uVar5 ^ uVar4) - uVar5;
    if (local_70 <= iVar11) goto LAB_08081ae1;
LAB_080819f9:
    local_70 = iVar11;
    if ((int)uVar9 < 0) {
      iVar11 = -local_70;
      iVar8 = 0x5a;
    }
    else {
      iVar8 = -0x5a;
      iVar11 = local_70;
    }
    arc.Y = Crosshair.AttachedBox.Point1.Y + iVar11;
    iVar11 = 0x5a;
    if ((uVar5 | 1) == (uVar10 | 1)) {
      iVar11 = -0x5a;
    }
  }
  iVar6 = thick / 2;
  arc.Width = local_70;
  arc.Height = local_70;
  arc.StartAngle = iVar8;
  arc.Delta = iVar11;
  pBVar2 = GetArcEnds((ArcTypePtr *)&arc);
  (*gui->draw_arc)(Crosshair.GC,arc.X,arc.Y,local_70 + iVar6,local_70 + iVar6,iVar8,iVar11);
  if (pixel_slop < iVar6) {
    (*gui->draw_arc)(Crosshair.GC,arc.X,arc.Y,local_70 - iVar6,local_70 - iVar6,iVar8,iVar11);
    paVar7 = gui->draw_arc;
    if (iVar11 < 1) {
      if (iVar11 == 0) {
        (*paVar7)(Crosshair.GC,pBVar2->X1,pBVar2->Y1,iVar6,iVar6,iVar8,0);
        paVar7 = gui->draw_arc;
        iVar3 = 0;
      }
      else {
        (*paVar7)(Crosshair.GC,pBVar2->X1,pBVar2->Y1,iVar6,iVar6,iVar8,0xb4);
        paVar7 = gui->draw_arc;
        iVar3 = -0xb4;
      }
    }
    else {
      (*paVar7)(Crosshair.GC,pBVar2->X1,pBVar2->Y1,iVar6,iVar6,iVar8,-0xb4);
      paVar7 = gui->draw_arc;
      iVar3 = 0xb4;
    }
    (*paVar7)(Crosshair.GC,pBVar2->X2,pBVar2->Y2,iVar6,iVar6,iVar11 + iVar8,iVar3);
  }
LAB_08081a9b:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void __regparm3
XORDrawAttachedLine(LocationType x1,LocationType y1,LocationType x2,LocationType y2,BDimension thick
                   )

{
  uint uVar1;
  uint uVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  int iVar8;
  int iVar9;
  double dVar10;
  
  iVar8 = x2 - x1;
  iVar9 = y2 - y1;
  if ((iVar9 == 0) && (iVar8 == 0)) {
    fVar4 = 0.00000000;
    fVar5 = fVar4;
    fVar6 = fVar4;
    fVar7 = fVar4;
  }
  else {
    fVar5 = (float)iVar8;
    fVar7 = (float)iVar9;
    fVar6 = SQRT(fVar7 * fVar7 + fVar5 * fVar5) / ((float)thick * 0.50000000);
    fVar3 = 0.50000000;
    fVar4 = fVar7 * fVar6;
    if (0 < iVar9) goto LAB_08081d2c;
    if (iVar9 != 0) {
      fVar3 = -0.50000000;
      goto LAB_08081d2c;
    }
  }
  fVar3 = 0.00000000;
LAB_08081d2c:
  uVar1 = (uint)ROUND(fVar4 + fVar3);
  if (iVar8 < 1) {
    if (iVar8 == 0) {
      fVar3 = 0.00000000;
    }
    else {
      fVar3 = -0.50000000;
    }
  }
  else {
    fVar3 = 0.50000000;
  }
  uVar2 = (uint)ROUND(-(fVar6 * fVar5 + fVar3));
  (*gui->draw_line)(Crosshair.GC,uVar1 + x1,uVar2 + y1,uVar1 + x2,uVar2 + y2);
  if ((pixel_slop <= (int)(((int)uVar1 >> 0x1f ^ uVar1) - ((int)uVar1 >> 0x1f))) ||
     (pixel_slop <= (int)(((int)uVar2 >> 0x1f ^ uVar2) - ((int)uVar2 >> 0x1f)))) {
    dVar10 = atan2((double)fVar5,(double)fVar7);
    (*gui->draw_line)(Crosshair.GC,x1 - uVar1,y1 - uVar2,x2 - uVar1,y2 - uVar2);
    iVar8 = thick / 2;
    (*gui->draw_arc)(Crosshair.GC,x1,y1,iVar8,iVar8,(int)ROUND(dVar10 * 57.29577900) + -0xb4,0xb4);
    (*gui->draw_arc)(Crosshair.GC,x2,y2,iVar8,iVar8,(int)ROUND(dVar10 * 57.29577900),0xb4);
  }
  return;
}



void __regparm3 DrawAttached(Boolean BlockToo)

{
  ElementTypePtr *Element;
  LineTypePtr pLVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  void *pvVar5;
  void *pvVar6;
  int dy;
  PointTypePtr pPVar7;
  BDimension thick;
  DataTypePtr *pDVar8;
  uint uVar9;
  PinTypePtr *pPVar10;
  int local_50;
  int *piVar11;
  int dy_00;
  int local_4c;
  PCBTypePtr pPVar12;
  RubberbandTypePtr *pRVar13;
  Cardinal CVar14;
  int *piVar15;
  PointTypePtr pPVar16;
  undefined *puVar17;
  uint uVar18;
  int local_48;
  int local_44;
  uint local_28;
  
  pvVar6 = Crosshair.AttachedObject.Ptr3;
  pvVar5 = Crosshair.AttachedObject.Ptr2;
  dy = Settings.BufferNumber;
  if (Settings.Mode == 5) {
    dy_00 = Crosshair.Y - Buffers[Settings.BufferNumber].Y;
    local_44 = Crosshair.X - Buffers[Settings.BufferNumber].X;
    pDVar8 = PCB->Data;
    pPVar12 = PCB;
    if (pDVar8->LayerN != -2) {
      local_28 = 0;
      do {
        if (*(char *)(&pDVar8->field_0x90 + local_28 * 0x5c) != '\0') {
          pDVar8 = Buffers[dy].Data;
          CVar14 = (&pDVar8->ViaN + local_28 * 0x17)[0x14];
          local_48 = CVar14 - 1;
          if (local_48 != -1) {
            local_4c = CVar14 * 0x58;
            do {
              local_4c = local_4c + -0x58;
              local_48 = local_48 + -1;
              local_50 = local_4c + (&pDVar8->ViaN + local_28 * 0x17)[0x1c];
              (*gui->draw_line)(Crosshair.GC,local_44 + *(int *)(local_50 + 0x2c),
                                *(int *)(local_50 + 0x30) + dy_00,
                                *(int *)(local_50 + 0x40) + local_44,
                                *(int *)(local_50 + 0x44) + dy_00);
            } while (local_48 != -1);
          }
          CVar14 = (&pDVar8->ViaN + local_28 * 0x17)[0x17];
          local_48 = CVar14 - 1;
          if (local_48 != -1) {
            local_4c = CVar14 * 0x44;
            do {
              local_4c = local_4c + -0x44;
              local_48 = local_48 + -1;
              local_50 = local_4c + (&pDVar8->ViaN + local_28 * 0x17)[0x1f];
              (*gui->draw_arc)(Crosshair.GC,local_44 + *(int *)(local_50 + 0x34),
                               dy_00 + *(int *)(local_50 + 0x38),*(int *)(local_50 + 0x2c),
                               *(int *)(local_50 + 0x30),*(int *)(local_50 + 0x3c),
                               *(int *)(local_50 + 0x40));
            } while (local_48 != -1);
          }
          CVar14 = (&pDVar8->ViaN + local_28 * 0x17)[0x15];
          local_48 = CVar14 - 1;
          if (local_48 != -1) {
            puVar17 = (undefined *)(CVar14 * 0x3c);
            do {
              puVar17 = &DAT_ffffffc4 + (int)puVar17;
              local_48 = local_48 + -1;
              piVar15 = (int *)(puVar17 + (&pDVar8->ViaN + local_28 * 0x17)[0x1d]);
              (*gui->draw_rect)(Crosshair.GC,local_44 + *piVar15,piVar15[1] + dy_00,
                                piVar15[2] + local_44,piVar15[3] + dy_00);
            } while (local_48 != -1);
          }
          CVar14 = (&pDVar8->ViaN + local_28 * 0x17)[0x16];
          local_48 = CVar14 - 1;
          pPVar12 = PCB;
          if (local_48 != -1) {
            puVar17 = (undefined *)(CVar14 * 0x3c);
            do {
              puVar17 = &DAT_ffffffc4 + (int)puVar17;
              local_48 = local_48 + -1;
              XORPolygon((PolygonTypePtr)(puVar17 + (&pDVar8->ViaN + local_28 * 0x17)[0x1e]),
                         local_44,dy_00);
              pPVar12 = PCB;
            } while (local_48 != -1);
          }
        }
        pDVar8 = pPVar12->Data;
        local_28 = local_28 + 1;
      } while (local_28 < pDVar8->LayerN + 2U);
    }
    if ((pPVar12->PinOn != '\0') && (pPVar12->ElementOn != '\0')) {
      pDVar8 = Buffers[dy].Data;
      local_48 = pDVar8->ElementN - 1;
      if (local_48 != -1) {
        local_4c = pDVar8->ElementN * 300;
        while( true ) {
          Element = (ElementTypePtr *)((int)&pDVar8->Element[-1].BoundingBox.X1 + local_4c);
          if ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide) ||
             (PCB->InvisibleObjectsOn != '\0')) {
            XORDrawElement(Element,local_44,dy_00);
          }
          local_48 = local_48 + -1;
          pPVar12 = PCB;
          if (local_48 == -1) break;
          pDVar8 = Buffers[dy].Data;
          local_4c = local_4c + -300;
        }
      }
    }
    if (pPVar12->ViaOn != '\0') {
      pDVar8 = Buffers[dy].Data;
      if (pDVar8->ViaN != 0) {
        uVar18 = 0;
        uVar9 = pDVar8->ViaN;
        do {
          pPVar10 = pDVar8->Via + uVar18;
          local_48 = pPVar10->Thickness / 2;
          (*gui->draw_arc)(Crosshair.GC,pPVar10->X + local_44,pPVar10->Y + dy_00,local_48,local_48,0
                           ,0x168);
          pDVar8 = Buffers[dy].Data;
          uVar2 = pDVar8->ViaN;
          if (uVar2 == 0) break;
          uVar18 = (uVar2 + 1 + uVar18) - uVar9;
          uVar9 = uVar2;
        } while (uVar18 < uVar2);
      }
    }
LAB_08082090:
    if (Crosshair.AttachedBox.State == 1) goto LAB_08082140;
  }
  else {
    if (Settings.Mode < 6) {
      if (Settings.Mode == 2) {
        if ((Crosshair.AttachedLine.State != 0) && (Crosshair.AttachedLine.draw != '\0')) {
          thick = 10;
          if (PCB->RatDraw == '\0') {
            thick = Settings.LineThickness;
          }
          XORDrawAttachedLine(Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                              Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,thick)
          ;
          if (PCB->Clipping != 0) {
            thick = 10;
            if (PCB->RatDraw == '\0') {
              thick = Settings.LineThickness;
            }
            XORDrawAttachedLine(Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                                Crosshair.X,Crosshair.Y,thick);
          }
          if ((*(byte *)&(PCB->Flags).f & 8) != 0) {
            (*gui->set_color)(Crosshair.GC,Settings.CrossColor);
            thick = 10;
            if (PCB->RatDraw == '\0') {
              thick = PCB->Bloat * 2 + 2 + Settings.LineThickness;
            }
            XORDrawAttachedLine(Crosshair.AttachedLine.Point1.X,Crosshair.AttachedLine.Point1.Y,
                                Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                                thick);
            if (PCB->Clipping != 0) {
              thick = 10;
              if (PCB->RatDraw == '\0') {
                thick = PCB->Bloat * 2 + 2 + Settings.LineThickness;
              }
              XORDrawAttachedLine(Crosshair.AttachedLine.Point2.X,Crosshair.AttachedLine.Point2.Y,
                                  Crosshair.X,Crosshair.Y,thick);
            }
            goto LAB_08082381;
          }
        }
      }
      else {
        if (Settings.Mode == 4) {
          if (Crosshair.AttachedLine.State != 0) {
            (*gui->draw_line)(Crosshair.GC,Crosshair.AttachedLine.Point1.X,
                              Crosshair.AttachedLine.Point1.Y,Crosshair.AttachedLine.Point2.X,
                              Crosshair.AttachedLine.Point2.Y);
          }
          if (1 < Crosshair.AttachedPolygon.PointN) {
            XORPolygon((PolygonTypePtr)&Crosshair.AttachedPolygon,0,0);
          }
        }
        else {
          if ((Settings.Mode == 1) &&
             ((*gui->draw_arc)(Crosshair.GC,Crosshair.X,Crosshair.Y,Settings.ViaThickness / 2,
                               Settings.ViaThickness / 2,0,0x168),
             (*(byte *)&(PCB->Flags).f & 8) != 0)) {
            dy = PCB->Bloat + 1 + Settings.ViaThickness / 2;
            (*gui->set_color)(Crosshair.GC,Settings.CrossColor);
            (*gui->draw_arc)(Crosshair.GC,Crosshair.X,Crosshair.Y,dy,dy,0,0x168);
LAB_08082381:
            (*gui->set_color)(Crosshair.GC,Settings.CrosshairColor);
          }
        }
      }
      goto LAB_08082090;
    }
    if (Settings.Mode == 0x6a) {
      if (Crosshair.AttachedObject.Type != 0) {
        (*gui->draw_line)(Crosshair.GC,*(int *)Crosshair.AttachedObject.Ptr3,
                          *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4),
                          *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c),
                          *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30));
        (*gui->draw_line)(Crosshair.GC,*(int *)pvVar6,*(int *)((int)pvVar6 + 4),
                          *(int *)((int)pvVar5 + 0x40),*(int *)((int)pvVar5 + 0x44));
      }
      goto LAB_08082090;
    }
    if (Settings.Mode < 0x6b) {
      if (0x67 < Settings.Mode) {
        dy_00 = Crosshair.X - Crosshair.AttachedObject.X;
        dy = Crosshair.Y - Crosshair.AttachedObject.Y;
        if (Crosshair.AttachedObject.Type == 0x100) {
LAB_08082a2c:
          XORDrawElement((ElementTypePtr *)Crosshair.AttachedObject.Ptr2,dy_00,dy);
        }
        else {
          if (Crosshair.AttachedObject.Type < 0x101) {
            if (Crosshair.AttachedObject.Type == 4) {
              XORDrawAttachedLine(dy_00 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c),
                                  dy + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30),
                                  dy_00 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x40),
                                  *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x44) + dy,
                                  *(BDimension *)((int)Crosshair.AttachedObject.Ptr2 + 0x24));
            }
            else {
              if (Crosshair.AttachedObject.Type < 5) {
                if (Crosshair.AttachedObject.Type == 1) {
                  local_44 = 0x168;
                  local_48 = 0;
                  local_50 = *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0x24) / 2;
                  iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0x38);
                  iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr1 + 0x34);
                  local_4c = local_50;
LAB_080828b7:
                  (*gui->draw_arc)(Crosshair.GC,dy_00 + iVar4,dy + iVar3,local_50,local_4c,local_48,
                                   local_44);
                }
                else {
                  if (Crosshair.AttachedObject.Type == 2) goto LAB_08082a2c;
                }
              }
              else {
                if (Crosshair.AttachedObject.Type == 8) {
                  XORPolygon((PolygonTypePtr)Crosshair.AttachedObject.Ptr2,dy_00,dy);
                }
                else {
                  if (Crosshair.AttachedObject.Type == 0x10) {
LAB_080827c7:
                    (*gui->draw_rect)(Crosshair.GC,*(int *)Crosshair.AttachedObject.Ptr2 + dy_00,
                                      dy + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 4),
                                      dy_00 + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 8),
                                      dy + *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0xc));
                  }
                }
              }
            }
          }
          else {
            if (Crosshair.AttachedObject.Type == 0x800) {
              piVar15 = *(int **)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
              if ((int *)Crosshair.AttachedObject.Ptr3 == piVar15) {
                piVar15 = (int *)((int)Crosshair.AttachedObject.Ptr3 + 0x14);
                piVar11 = (int *)((int)Crosshair.AttachedObject.Ptr3 +
                                 (*(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x24) + -1) * 0x14);
              }
              else {
                if ((int *)Crosshair.AttachedObject.Ptr3 ==
                    piVar15 + (*(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x24) + -1) * 5) {
                  piVar11 = (int *)((int)Crosshair.AttachedObject.Ptr3 + -0x14);
                }
                else {
                  piVar11 = (int *)((int)Crosshair.AttachedObject.Ptr3 + -0x14);
                  piVar15 = (int *)((int)Crosshair.AttachedObject.Ptr3 + 0x14);
                }
              }
              (*gui->draw_line)(Crosshair.GC,*piVar11,piVar11[1],
                                dy_00 + *(int *)Crosshair.AttachedObject.Ptr3,
                                dy + *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4));
              (*gui->draw_line)(Crosshair.GC,dy_00 + *(int *)pvVar6,dy + *(int *)((int)pvVar6 + 4),
                                *piVar15,piVar15[1]);
            }
            else {
              if (Crosshair.AttachedObject.Type < 0x801) {
                if (Crosshair.AttachedObject.Type == 0x200) goto LAB_08082a2c;
                if (Crosshair.AttachedObject.Type == 0x400) {
                  (*gui->draw_line)(Crosshair.GC,*(int *)((int)Crosshair.AttachedObject.Ptr1 + 0xd8)
                                    ,*(int *)((int)Crosshair.AttachedObject.Ptr1 + 0xdc),Crosshair.X
                                    ,Crosshair.Y);
                  goto LAB_080827c7;
                }
              }
              else {
                if (Crosshair.AttachedObject.Type == 0x1000) {
                  if (Crosshair.AttachedObject.Ptr3 ==
                      (void *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c)) {
                    XORDrawAttachedLine(dy_00 + *(int *)Crosshair.AttachedObject.Ptr3,
                                        dy + *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4),
                                        *(LocationType *)((int)Crosshair.AttachedObject.Ptr2 + 0x40)
                                        ,*(LocationType *)
                                          ((int)Crosshair.AttachedObject.Ptr2 + 0x44),
                                        *(BDimension *)((int)Crosshair.AttachedObject.Ptr2 + 0x24));
                  }
                  else {
                    XORDrawAttachedLine(dy_00 + *(int *)Crosshair.AttachedObject.Ptr3,
                                        dy + *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4),
                                        *(LocationType *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c)
                                        ,*(LocationType *)
                                          ((int)Crosshair.AttachedObject.Ptr2 + 0x30),
                                        *(BDimension *)((int)Crosshair.AttachedObject.Ptr2 + 0x24));
                  }
                }
                else {
                  if (Crosshair.AttachedObject.Type == 0x4000) {
                    local_44 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x40);
                    local_48 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x3c);
                    local_4c = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30);
                    local_50 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c);
                    iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
                    iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x34);
                    goto LAB_080828b7;
                  }
                }
              }
            }
          }
        }
        pRVar13 = Crosshair.AttachedObject.Rubberband;
        CVar14 = Crosshair.AttachedObject.RubberbandN;
        if (Crosshair.AttachedObject.RubberbandN != 0) {
          while( true ) {
            pLVar1 = pRVar13->Line;
            uVar9 = (pLVar1->Flags).f;
            if ((uVar9 & 2) == 0) {
              if ((uVar9 & 0x200) == 0) {
                if ((PointType *)pRVar13->MovedPoint == &pLVar1->Point1) {
                  XORDrawAttachedLine(dy_00 + (pLVar1->Point1).X,dy + (pLVar1->Point1).Y,
                                      dy_00 + (pLVar1->Point2).X,(pLVar1->Point2).Y + dy,
                                      pLVar1->Thickness);
                }
              }
              else {
                pPVar16 = pRVar13->MovedPoint;
                pPVar7 = (PointTypePtr)&pLVar1->Point1;
                if (pPVar16 == pPVar7) {
                  pPVar7 = (PointTypePtr)&pLVar1->Point2;
                }
                else {
                  pPVar16 = (PointTypePtr)&pLVar1->Point2;
                }
                XORDrawAttachedLine(pPVar7->X,pPVar7->Y,dy_00 + pPVar16->X,dy + pPVar16->Y,
                                    pLVar1->Thickness);
              }
            }
            CVar14 = CVar14 - 1;
            if (CVar14 == 0) break;
            pRVar13 = pRVar13 + 1;
          }
        }
      }
      goto LAB_08082090;
    }
    if (Settings.Mode != 0x6d) goto LAB_08082090;
    if (Crosshair.AttachedBox.State != 0) {
      XORDrawAttachedArc(Settings.LineThickness);
      if ((*(byte *)&(PCB->Flags).f & 8) != 0) {
        (*gui->set_color)(Crosshair.GC,Settings.CrossColor);
        XORDrawAttachedArc(PCB->Bloat * 2 + 2 + Settings.LineThickness);
        goto LAB_08082381;
      }
      goto LAB_08082090;
    }
  }
  if ((BlockToo == '\0') || (Crosshair.AttachedBox.State != 2)) {
    return;
  }
LAB_08082140:
  (*gui->draw_rect)(Crosshair.GC,Crosshair.AttachedBox.Point1.X,Crosshair.AttachedBox.Point1.Y,
                    Crosshair.AttachedBox.Point2.X,Crosshair.AttachedBox.Point2.Y);
  return;
}



void CrosshairOff(Boolean BlockToo)

{
  if (Crosshair.On == '\0') {
    return;
  }
  Crosshair.On = '\0';
  DrawAttached(BlockToo);
  DrawMark('\x01');
  return;
}



void DestroyCrosshair(void)

{
  CrosshairOff('\x01');
  FreePolygonMemory((PolygonTypePtr)&Crosshair.AttachedPolygon);
  (*gui->destroy_gc)(Crosshair.GC);
  return;
}



void HideCrosshair(Boolean BlockToo)

{
  if (CrosshairStackLocation < 0x10) {
    CrosshairStack[CrosshairStackLocation] = Crosshair.On;
    CrosshairStackLocation = CrosshairStackLocation + 1;
    CrosshairOff(BlockToo);
    return;
  }
  __fprintf_chk(stderr,1,"Error: CrosshairStackLocation overflow\n");
  return;
}



Boolean MoveCrosshairAbsolute(LocationType X,LocationType Y)

{
  LocationType LVar1;
  LocationType LVar2;
  LocationType LVar3;
  LocationType LVar4;
  Boolean BVar5;
  
  LVar3 = Crosshair.Y;
  LVar1 = Crosshair.X;
  FitCrosshairIntoGrid(X,Y);
  LVar4 = Crosshair.Y;
  LVar2 = Crosshair.X;
  if ((Crosshair.X != LVar1) || (BVar5 = '\0', Crosshair.Y != LVar3)) {
    Crosshair.X = LVar1;
    Crosshair.Y = LVar3;
    HideCrosshair('\0');
    BVar5 = '\x01';
  }
  Crosshair.X = LVar2;
  Crosshair.Y = LVar4;
  return BVar5;
}



void CrosshairOn(Boolean BlockToo)

{
  if (Crosshair.On != '\0') {
    return;
  }
  Crosshair.On = '\x01';
  DrawAttached(BlockToo);
  DrawMark('\x01');
  return;
}



void RestoreCrosshair(Boolean BlockToo)

{
  int iVar1;
  
  if (CrosshairStackLocation < 1) {
    __fprintf_chk(stderr,1,"Error: CrosshairStackLocation underflow\n");
    return;
  }
  iVar1 = CrosshairStackLocation + 3;
  CrosshairStackLocation = CrosshairStackLocation + -1;
  if (*(char *)((int)&CrosshairStackLocation + iVar1) == '\0') {
    CrosshairOff(BlockToo);
    return;
  }
  CrosshairOn(BlockToo);
  return;
}



int djopt_set_auto_only(int argc,char **argv,int x,int y)

{
  autorouted_only = (uint)(autorouted_only == 0);
  return 0;
}



int djopt_get_auto_only(int dummy)

{
  return autorouted_only;
}



int sqr(int a)

{
  return a * a;
}



void __regparm3 add_point_to_rect(rect_s *rect,int x,int y,int w)

{
  int iVar1;
  
  iVar1 = x - w;
  if (rect->x1 != iVar1 && iVar1 <= rect->x1) {
    rect->x1 = iVar1;
  }
  if (rect->x2 < w + x) {
    rect->x2 = w + x;
  }
  iVar1 = y - w;
  if (rect->y1 != iVar1 && iVar1 <= rect->y1) {
    rect->y1 = iVar1;
  }
  if (rect->y2 < w + y) {
    rect->y2 = w + y;
  }
  return;
}



void __regparm3 add_line_to_rect(rect_s *rect,line_s *l)

{
  add_point_to_rect(rect,l->s->x,l->s->y,0);
  add_point_to_rect(rect,l->e->x,l->e->y,0);
  return;
}



int __regparm3 corner_radius(corner_s *c)

{
  PinType *pPVar1;
  LineType *pLVar2;
  int iVar3;
  int iVar4;
  BDimension BVar5;
  
  BVar5 = 0;
  pPVar1 = c->pin;
  if ((pPVar1 != (PinType *)0x0) && (-1 < pPVar1->Thickness)) {
    BVar5 = pPVar1->Thickness;
  }
  if ((c->via != (PinType *)0x0) && (iVar4 = c->via->Thickness, BVar5 < iVar4)) {
    BVar5 = iVar4;
  }
  if (0 < c->n_lines) {
    iVar4 = 0;
    do {
      pLVar2 = c->lines[iVar4]->line;
      if ((pLVar2 != (LineType *)0x0) && (iVar3 = pLVar2->Thickness, BVar5 < iVar3)) {
        BVar5 = iVar3;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 != c->n_lines);
  }
  return (BVar5 + 1) / 2;
}



int __regparm3 simple_corner(corner_s *c)

{
  line_s *plVar1;
  corner_s *pcVar2;
  byte bVar3;
  int iVar4;
  byte bVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int local_14;
  
  if ((((c->pad == (PadType *)0x0) && (c->pin == (PinType *)0x0)) && (c->via == (PinType *)0x0)) &&
     (c->n_lines == 2)) {
    plVar1 = *c->lines;
    pcVar2 = plVar1->s;
    if (c == pcVar2) {
      iVar7 = c->x;
      iVar4 = c->y;
      iVar6 = plVar1->e->x;
      local_14 = plVar1->e->y;
    }
    else {
      iVar7 = plVar1->e->x;
      iVar4 = plVar1->e->y;
      iVar6 = pcVar2->x;
      local_14 = pcVar2->y;
    }
    if (iVar7 == iVar6) {
      bVar5 = (iVar4 < local_14) * '\x04' + 0x24;
    }
    else {
      bVar5 = 0xf0;
      if (iVar4 == local_14) {
        bVar5 = (iVar7 < iVar6) + 0x11;
      }
    }
    plVar1 = c->lines[1];
    pcVar2 = plVar1->s;
    if (c == pcVar2) {
      iVar6 = c->x;
      iVar8 = c->y;
      iVar7 = plVar1->e->x;
      iVar4 = plVar1->e->y;
    }
    else {
      iVar7 = pcVar2->x;
      iVar4 = pcVar2->y;
      iVar6 = plVar1->e->x;
      iVar8 = plVar1->e->y;
    }
    if (iVar6 == iVar7) {
      bVar3 = (iVar8 < iVar4) * '\x04' + 0x24;
    }
    else {
      bVar3 = 0xf0;
      if (iVar8 == iVar4) {
        bVar3 = (iVar6 < iVar7) + 0x11;
      }
    }
    if ((((bVar3 ^ bVar5) & 0xf0) != 0) && ((bVar5 & 0xf0) != 0xf0)) {
      return (uint)((bVar3 & 0xf0) != 0xf0);
    }
  }
  return 0;
}



corner_s * __regparm3 find_corner(int x,int y,int l)

{
  int iVar1;
  line_s **pplVar2;
  corner_s *pcVar3;
  
  pcVar3 = corners;
  if (corners != (corner_s *)0x0) {
    do {
      iVar1 = pcVar3->layer;
      if ((((iVar1 != -0x21524111) && (pcVar3->x == x)) && (pcVar3->y == y)) &&
         (((iVar1 == -1 || (l == -1)) ||
          ((iVar1 == l || (layer_groupings[iVar1] == layer_groupings[l])))))) {
        return pcVar3;
      }
      pcVar3 = pcVar3->next;
    } while (pcVar3 != (corner_s *)0x0);
  }
  pcVar3 = (corner_s *)malloc(0x2c);
  pcVar3->x = x;
  pcVar3->y = y;
  pcVar3->net = 0;
  pcVar3->next = corners;
  pcVar3->via = (PinType *)0x0;
  pcVar3->pad = (PadType *)0x0;
  pcVar3->pin = (PinType *)0x0;
  pcVar3->layer = l;
  pcVar3->n_lines = 0;
  corners = pcVar3;
  pplVar2 = (line_s **)malloc(0x1c);
  pcVar3->lines = pplVar2;
  return pcVar3;
}



void __regparm3 remove_line(line_s *l)

{
  Cardinal *pCVar1;
  LineTypePtr Line;
  corner_s *pcVar2;
  int iVar3;
  line_s **pplVar4;
  corner_s *pcVar5;
  line_s *plVar6;
  int iVar7;
  int iVar8;
  LineType *pLVar9;
  
  pLVar9 = (LineType *)0x0;
  Line = (LineTypePtr)l->line;
  if (Line != (LineTypePtr)0x0) {
    pCVar1 = &PCB->Data->ViaN + l->layer * 0x17;
    pLVar9 = (LineType *)((pCVar1[0x14] - 1) * 0x58 + pCVar1[0x1c]);
    RemoveLine((LayerTypePtr)(&PCB->Data->field_0x4c + l->layer * 0x5c),Line);
  }
  plVar6 = lines;
  l->layer = -0x21524111;
  while (plVar6 != (line_s *)0x0) {
    while ((plVar6->layer == -0x21524111 || (plVar6->line != pLVar9))) {
      plVar6 = plVar6->next;
      if (plVar6 == (line_s *)0x0) goto LAB_08083088;
    }
    *(LineTypePtr *)&plVar6->line = Line;
    plVar6 = plVar6->next;
  }
LAB_08083088:
  pcVar2 = l->s;
  iVar8 = 0;
  iVar3 = pcVar2->n_lines;
  if (0 < iVar3) {
    iVar7 = 0;
    pplVar4 = pcVar2->lines;
    do {
      plVar6 = pplVar4[iVar7];
      if (plVar6 != l) {
        pplVar4[iVar8] = plVar6;
        iVar8 = iVar8 + 1;
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 < iVar3);
  }
  pcVar5 = l->e;
  pcVar2->n_lines = iVar8;
  iVar8 = 0;
  iVar3 = pcVar5->n_lines;
  if (0 < iVar3) {
    pplVar4 = pcVar5->lines;
    iVar7 = 0;
    do {
      plVar6 = pplVar4[iVar7];
      if (plVar6 != l) {
        pplVar4[iVar8] = plVar6;
        iVar8 = iVar8 + 1;
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 < iVar3);
  }
  pcVar5->n_lines = iVar8;
  return;
}



void __regparm3 add_line_to_corner(line_s *l,corner_s *c)

{
  int iVar1;
  line_s **pplVar2;
  
  pplVar2 = (line_s **)realloc(c->lines,(c->n_lines + 8U & 0xfffffff8) << 2);
  iVar1 = c->n_lines;
  pplVar2[iVar1] = l;
  c->lines = pplVar2;
  c->n_lines = iVar1 + 1;
  return;
}



int __regparm3 dist(int x1,int y1,int x2,int y2)

{
  double dVar1;
  
  dVar1 = rint(SQRT(((double)y1 - (double)y2) * ((double)y1 - (double)y2) +
                    ((double)x1 - (double)x2) * ((double)x1 - (double)x2)));
  return (int)ROUND(dVar1);
}



void __regparm3 add_corner_to_rect_if(rect_s *rect,corner_s *c,rect_s *e)

{
  int y2;
  int w;
  int x1;
  int x2;
  int y1;
  int local_28;
  int local_20;
  
  w = corner_radius(c);
  x2 = e->x1;
  y1 = c->y;
  x1 = c->x;
  if ((x1 < x2) && (w + x1 < x2)) {
    return;
  }
  local_20 = e->x2;
  if ((local_20 < x1) && (local_20 < x1 - w)) {
    return;
  }
  y2 = e->y1;
  if ((y1 < y2) && (w + y1 < y2)) {
    return;
  }
  if ((e->y2 < y1) && (e->y2 < y1 - w)) {
    return;
  }
  if ((x1 < x2) && (y1 < y2)) {
    x2 = dist(x1,y1,x2,y2);
    if (w < x2) {
      return;
    }
    local_20 = e->x2;
    y1 = c->y;
    x1 = c->x;
  }
  if (local_20 < x1) {
    if (y1 < e->y1) {
      x2 = dist(x1,y1,local_20,e->y1);
      if (w < x2) {
        return;
      }
      x1 = c->x;
      y1 = c->y;
      goto LAB_080832f0;
    }
    local_28 = e->x1;
    if (x1 < local_28) goto LAB_08083248;
LAB_08083301:
    x2 = e->x2;
    if (x1 <= x2) goto LAB_0808326c;
  }
  else {
LAB_080832f0:
    local_28 = e->x1;
    if (local_28 <= x1) goto LAB_08083301;
LAB_08083248:
    if (e->y2 < y1) {
      x2 = dist(x1,y1,local_28,e->y2);
      if (w < x2) {
        return;
      }
      y1 = c->y;
      x1 = c->x;
      goto LAB_08083301;
    }
    x2 = e->x2;
    if (x1 <= x2) goto LAB_0808326c;
  }
  if (e->y2 < y1) {
    x2 = dist(x1,y1,x2,e->y2);
    if (w < x2) {
      return;
    }
    y1 = c->y;
    x1 = c->x;
  }
LAB_0808326c:
  add_point_to_rect(rect,x1,y1,w);
  return;
}



int __regparm3 line_length(line_s *l)

{
  corner_s *pcVar1;
  corner_s *pcVar2;
  int x2;
  int x1;
  uint uVar3;
  uint uVar4;
  
  pcVar1 = l->s;
  pcVar2 = l->e;
  x1 = pcVar1->x;
  x2 = pcVar2->x;
  if (x1 == x2) {
    uVar3 = pcVar1->y - pcVar2->y;
    uVar4 = (int)uVar3 >> 0x1f;
    return (uVar3 ^ uVar4) - uVar4;
  }
  if (pcVar1->y != pcVar2->y) {
    x1 = dist(x1,pcVar1->y,x2,pcVar2->y);
    return x1;
  }
  uVar3 = x1 - x2 >> 0x1f;
  return (uVar3 ^ x1 - x2) - uVar3;
}



int __regparm3 dist_ltp2(int dx,int y,int y1,int y2)

{
  int y2_00;
  
  y2_00 = y1;
  if (y2 < y1) {
    y2_00 = y2;
    y2 = y1;
  }
  if (y2_00 <= y) {
    if (y <= y2) {
      return (dx ^ dx >> 0x1f) - (dx >> 0x1f);
    }
    y2_00 = dist(dx,y,0,y2);
    return y2_00;
  }
  y2_00 = dist(dx,y,0,y2_00);
  return y2_00;
}



LineType * __regparm3
create_pcb_line(int layer,int x1,int y1,int x2,int y2,int thick,int clear,FlagType flags)

{
  LayerTypePtr Layer;
  LineType *pLVar1;
  LineType *pLVar2;
  LineType *pLVar3;
  LineTypePtr Ptr2;
  line_s *plVar4;
  Cardinal *pCVar5;
  
  Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + layer * 0x5c);
  pCVar5 = &PCB->Data->ViaN + layer * 0x17;
  pLVar1 = (LineType *)pCVar5[0x1c];
  Ptr2 = CreateNewLineOnLayer(Layer,x1,y1,x2,y2,thick,clear,flags);
  AddObjectToCreateUndoList(4,Layer,Ptr2,Ptr2);
  pLVar2 = (LineType *)pCVar5[0x1c];
  if ((pLVar1 != pLVar2) && (lines != (line_s *)0x0)) {
    plVar4 = lines;
    do {
      if (((plVar4->layer != -0x21524111) && (pLVar3 = plVar4->line, pLVar1 <= pLVar3)) &&
         (pLVar3 <= pLVar1 + pCVar5[0x14])) {
        plVar4->line = (LineType *)((int)pLVar3 + (int)((int)pLVar2 - (int)pLVar1));
      }
      plVar4 = plVar4->next;
    } while (plVar4 != (line_s *)0x0);
  }
  return (LineType *)Ptr2;
}



void dj_abort(char *msg,...)

{
  __vfprintf_chk(stdout,1,msg,&stack0x00000008);
  fflush(stdout);
                    // WARNING: Subroutine does not return
  abort();
}



void __regparm3 new_line(corner_s *s,corner_s *e,int layer,LineType *example)

{
  int *piVar1;
  int y1;
  line_s *l;
  LineType *pLVar2;
  
  piVar1 = &PCB->Data->LayerN;
  if (*piVar1 == layer || *piVar1 < layer) {
    dj_abort("layer %d\n",layer);
  }
  if (example == (LineType *)0x0) {
    dj_abort("NULL example passed to new_line()\n",layer);
  }
  if ((s->x == e->x) && (s->y == e->y)) {
    return;
  }
  l = (line_s *)malloc(0x14);
  l->layer = layer;
  y1 = s->y;
  l->s = s;
  l->e = e;
  l->next = lines;
  lines = l;
  pLVar2 = create_pcb_line(layer,s->x,y1,e->x,e->y,example->Thickness,example->Clearance,
                           example->Flags);
  if (pLVar2 == (LineType *)0x0) {
    dj_abort("can\'t create new line!");
  }
  l->line = pLVar2;
  add_line_to_corner(l,s);
  add_line_to_corner(l,e);
  return;
}



corner_s * __regparm3 other_corner(line_s *l,corner_s *c)

{
  if (l->s == c) {
    return l->e;
  }
  if (l->e == c) {
    return l->s;
  }
  dj_abort("other_corner: neither corner passed\n");
  return (corner_s *)0x0;
}



void __regparm3 classify_corner(corner_s *c,int this_net)

{
  line_s **pplVar1;
  corner_s *c_00;
  int iVar2;
  
  if ((c->net != this_net) && (c->net = this_net, 0 < c->n_lines)) {
    iVar2 = 0;
    do {
      pplVar1 = c->lines + iVar2;
      iVar2 = iVar2 + 1;
      c_00 = other_corner(*pplVar1,c);
      classify_corner(c_00,this_net);
    } while (c->n_lines != iVar2 && iVar2 <= c->n_lines);
  }
  return;
}



int __regparm3 split_line(line_s *l,corner_s *c)

{
  int iVar1;
  PadType *pPVar2;
  PadType *pPVar3;
  PadType *pPVar4;
  LineType *Ptr2;
  line_s *l_00;
  line_s **pplVar5;
  int layer;
  corner_s *pcVar6;
  
  iVar1 = c->layer;
  layer = l->layer;
  if ((((iVar1 == -1) || (layer == -1)) || (iVar1 == layer)) ||
     (layer_groupings[layer] == layer_groupings[iVar1])) {
    pPVar2 = (PadType *)l->line;
    pPVar3 = l->s->pad;
    if (pPVar2 != pPVar3) {
      pPVar4 = c->pad;
      if (pPVar4 == (PadType *)0x0) {
        pcVar6 = l->e;
      }
      else {
        if (pPVar3 == pPVar4) {
          return 0;
        }
        pcVar6 = l->e;
        if (pPVar4 == pcVar6->pad) {
          return 0;
        }
      }
      Ptr2 = create_pcb_line(layer,c->x,c->y,pcVar6->x,pcVar6->y,pPVar2->Thickness,pPVar2->Clearance
                             ,pPVar2->Flags);
      if (Ptr2 != (LineType *)0x0) {
        l_00 = (line_s *)malloc(0x14);
        pcVar6 = l->e;
        l_00->next = lines;
        iVar1 = l->layer;
        l_00->line = Ptr2;
        lines = l_00;
        l_00->s = c;
        l_00->layer = iVar1;
        iVar1 = pcVar6->n_lines;
        l_00->e = pcVar6;
        if (0 < iVar1) {
          layer = 0;
          do {
            while (pplVar5 = pcVar6->lines + layer, *pplVar5 == l) {
              layer = layer + 1;
              *pplVar5 = l_00;
              if (iVar1 <= layer) goto LAB_08083813;
            }
            layer = layer + 1;
          } while (layer < iVar1);
        }
LAB_08083813:
        l->e = c;
        add_line_to_corner(l,c);
        add_line_to_corner(l_00,c);
        Ptr2 = l->line;
        MoveObject(0x1000,(void *)(&PCB->Data->field_0x4c + l->layer * 0x5c),Ptr2,&Ptr2->Point2,
                   c->x - (Ptr2->Point2).X,c->y - (Ptr2->Point2).Y);
        return 1;
      }
    }
  }
  return 0;
}



void __regparm3 remove_via_at(corner_s *c)

{
  PinType *Ptr1;
  Cardinal CVar1;
  PinTypePtr *pPVar2;
  corner_s *pcVar3;
  
  Ptr1 = c->via;
  CVar1 = PCB->Data->ViaN;
  pPVar2 = PCB->Data->Via;
  RemoveObject(1,Ptr1,(void *)0x0,(void *)0x0);
  pcVar3 = corners;
  c->via = (PinType *)0x0;
  do {
    if (pcVar3 == (corner_s *)0x0) {
      return;
    }
    while ((pcVar3->layer == -0x21524111 || (pcVar3->via != (PinType *)(pPVar2 + (CVar1 - 1))))) {
      pcVar3 = pcVar3->next;
      if (pcVar3 == (corner_s *)0x0) {
        return;
      }
    }
    pcVar3->via = Ptr1;
    pcVar3 = pcVar3->next;
  } while( true );
}



void __regparm3 merge_corners(corner_s *c1,corner_s *c2)

{
  int iVar1;
  int iVar2;
  corner_s *pcVar3;
  corner_s *pcVar4;
  line_s *plVar5;
  int iVar6;
  
  if (c1 == c2) {
                    // WARNING: Subroutine does not return
    abort();
  }
  if (0 < c2->n_lines) {
    plVar5 = (line_s *)c2->lines;
    iVar6 = 0;
    do {
      while( true ) {
        add_line_to_corner(((line_s **)plVar5)[iVar6],c1);
        plVar5 = (line_s *)c2->lines;
        iVar1 = *(int *)((int)&plVar5->layer + iVar6 * 4);
        if (*(corner_s **)(iVar1 + 8) == c2) break;
        if (*(corner_s **)(iVar1 + 0xc) != c2) goto LAB_0808395d;
LAB_08083990:
        iVar6 = iVar6 + 1;
        iVar2 = c2->n_lines;
        iVar2 = c2->n_lines;
        *(corner_s **)(iVar1 + 0xc) = c1;
        if (iVar2 == iVar6 || iVar2 < iVar6) goto LAB_080839a0;
      }
      *(corner_s **)(iVar1 + 8) = c1;
      if (*(corner_s **)(iVar1 + 0xc) == c2) goto LAB_08083990;
LAB_0808395d:
      iVar6 = iVar6 + 1;
    } while (c2->n_lines != iVar6 && iVar6 <= c2->n_lines);
  }
LAB_080839a0:
  if (c1->via == (PinType *)0x0) {
    if (c2->via != (PinType *)0x0) {
      c1->via = c2->via;
    }
  }
  else {
    if (c2->via != (PinType *)0x0) {
      remove_via_at(c2);
    }
  }
  if (c2->pad != (PadType *)0x0) {
    c1->pad = c2->pad;
  }
  if (c2->pin != (PinType *)0x0) {
    c1->pin = c2->pin;
  }
  if (c2->layer != c1->layer) {
    c1->layer = -1;
  }
  pcVar3 = corners;
  if (c2 == corners) {
    corners = c2->next;
    pcVar3 = corners;
  }
  while (pcVar4 = pcVar3, pcVar4 != (corner_s *)0x0) {
    if (pcVar4->layer == -0x21524111) {
      pcVar3 = pcVar4->next;
    }
    else {
      pcVar3 = pcVar4->next;
      if (c2 == pcVar4->next) {
        pcVar3 = c2->next;
        pcVar4->next = pcVar3;
      }
    }
  }
  if (c2 == next_corner) {
    next_corner = c2->next;
  }
  free(c2->lines);
  c2->lines = (line_s **)0x0;
  c2->layer = -0x21524111;
  return;
}



void __regparm3 move_corner(corner_s *c,int x,int y)

{
  PinType *Ptr1;
  line_s *l;
  LineType *Ptr2;
  int iVar1;
  corner_s *c2;
  PointType *Ptr3;
  int iVar2;
  int iVar3;
  bool bVar4;
  
  if ((c->pad != (PadType *)0x0) || (c->pin != (PinType *)0x0)) {
    dj_abort("move_corner: has pin or pad\n");
  }
  iVar2 = c->layer;
  c2 = corners;
  while (c2 != (corner_s *)0x0) {
    while (((iVar3 = c2->layer, iVar3 == -0x21524111 || (x != c2->x)) || (y != c2->y))) {
      c2 = c2->next;
      if (c2 == (corner_s *)0x0) goto LAB_08083c98;
    }
    if (((iVar3 == -1) || (iVar2 == -1)) ||
       ((iVar2 == iVar3 || (layer_groupings[iVar3] == layer_groupings[iVar2])))) {
      bVar4 = c != c2;
      goto LAB_08083b02;
    }
    c2 = c2->next;
  }
LAB_08083c98:
  bVar4 = false;
LAB_08083b02:
  c->x = x;
  Ptr1 = c->via;
  c->y = y;
  if (Ptr1 != (PinType *)0x0) {
    MoveObject(1,Ptr1,Ptr1,Ptr1,x - Ptr1->X,y - Ptr1->Y);
  }
  iVar2 = c->n_lines;
  if (0 < iVar2) {
    iVar3 = 0;
    do {
      l = c->lines[iVar3];
      Ptr2 = l->line;
      if (Ptr2 != (LineType *)0x0) {
        if (l->s == c) {
          iVar2 = (Ptr2->Point1).Y;
          iVar1 = (Ptr2->Point1).X;
          Ptr3 = &Ptr2->Point1;
        }
        else {
          iVar2 = (Ptr2->Point2).Y;
          iVar1 = (Ptr2->Point2).X;
          Ptr3 = &Ptr2->Point2;
        }
        MoveObject(0x1000,(void *)(&PCB->Data->field_0x4c + l->layer * 0x5c),Ptr2,Ptr3,x - iVar1,
                   y - iVar2);
        iVar2 = c->n_lines;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 < iVar2);
  }
  if (bVar4) {
LAB_08083c36:
    merge_corners(c,c2);
  }
  else {
    if (0 < iVar2) {
      iVar3 = 0;
      do {
        l = c->lines[iVar3];
        if ((l->s->x == l->e->x) && (l->s->y == l->e->y)) {
          c2 = other_corner(l,c);
          remove_line(c->lines[iVar3]);
          if (c != c2) goto LAB_08083c36;
          break;
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 < iVar2);
    }
  }
  (*gui->progress)(0,0,(char *)0x0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __regparm3 connect_corners(corner_s *c1,corner_s *c2)

{
  bool bVar1;
  int y;
  corner_s *e;
  int x;
  corner_s **ppcVar2;
  int layer;
  PadType *local_34;
  corner_s *c [2];
  
  ppcVar2 = c + 1;
  c[1] = c2;
  bVar1 = false;
  e = c1;
  while( true ) {
    if (0 < e->n_lines) {
      y = 0;
      do {
        local_34 = (PadType *)e->lines[y]->line;
        if (local_34 != e->pad) {
          layer = e->lines[y]->layer;
          x = (*ppcVar2)->layer;
          if ((((x == -1) || (layer == -1)) || (x == layer)) ||
             (layer_groupings[layer] == layer_groupings[x])) goto LAB_08083d26;
        }
        y = y + 1;
      } while (y < e->n_lines);
    }
    ppcVar2 = ppcVar2 + -1;
    if (bVar1) break;
    bVar1 = true;
    e = c[1];
  }
  local_34 = _DAT_00000010;
  layer = _DAT_00000000;
LAB_08083d26:
  c[0] = c1;
  if (((c1->pin != (PinType *)0x0) || (c1->pad != (PadType *)0x0)) ||
     ((c1->via != (PinType *)0x0 || (c1->n_lines != 1)))) {
    e = find_corner(c1->x,c2->y,layer);
    new_line(c1,e,layer,(LineType *)local_34);
    new_line(e,c2,layer,(LineType *)local_34);
    return 0;
  }
  if ((*c1->lines)->s->x == (*c1->lines)->e->x) {
    x = c1->x;
    y = c2->y;
    if (x == c2->x) goto LAB_08083e23;
  }
  else {
    y = c1->y;
    x = c2->x;
    if (y == c2->y) {
LAB_08083e23:
      move_corner(c1,x,y);
      return 1;
    }
  }
  move_corner(c1,x,y);
  new_line(c1,c2,layer,(LineType *)local_34);
  return 1;
}



// WARNING: Type propagation algorithm not settling

int __regparm3 orthopull_1(corner_s *c,int fdir,int rdir,int any_sel)

{
  line_s *l;
  int iVar1;
  corner_s *pcVar2;
  bool bVar3;
  byte bVar4;
  int lm;
  line_s **ls;
  int cm;
  corner_s **cs;
  int iVar5;
  int iVar6;
  int w;
  int iVar7;
  corner_s *pcVar8;
  corner_s *c_00;
  corner_s **ppcVar9;
  int iVar10;
  int iVar11;
  byte bVar12;
  int iVar13;
  int iVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  bool bVar18;
  bool bVar19;
  int local_84;
  size_t local_80;
  int local_74;
  int local_6c;
  int local_68;
  int local_64;
  int local_5c;
  line_s *local_58;
  int local_54;
  int local_50;
  int local_48;
  int local_40;
  corner_s *local_3c;
  corner_s **local_38;
  rect_s rr;
  
  if (cs == (corner_s **)0x0) {
    cs = (corner_s **)malloc(0x1b8);
    cm = 10;
    ls = (line_s **)malloc(200);
    lm = 10;
  }
  if (0 < c->n_lines) {
    iVar5 = 0;
    do {
      l = c->lines[iVar5];
      c_00 = l->s;
      if (c == c_00) {
        iVar11 = c->x;
        w = c->y;
        iVar13 = l->e->x;
        iVar6 = l->e->y;
      }
      else {
        iVar6 = c_00->y;
        iVar11 = l->e->x;
        w = l->e->y;
        iVar13 = c_00->x;
      }
      if (iVar11 == iVar13) {
        iVar10 = (uint)(w < iVar6) * 4 + 0x24;
      }
      else {
        iVar10 = 0xf0;
        if (w == iVar6) {
          iVar10 = (uint)(iVar11 < iVar13) + 0x11;
        }
      }
      if (rdir == iVar10) {
        return 0;
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 < c->n_lines);
  }
  local_50 = 0x24;
  local_54 = 0x28;
  if (fdir != 0x12) {
    local_50 = 0x11;
    local_54 = 0x12;
    if (fdir != 0x28) {
      dj_abort("fdir not right or down\n");
      local_50 = 0;
      local_54 = 0;
    }
  }
  if (c->pad != (PadType *)0x0) {
    return 0;
  }
  if (c->pin != (PinType *)0x0) {
    return 0;
  }
  if (c->n_lines < 2) {
    return 0;
  }
  local_6c = 0;
  iVar5 = 0;
  local_80 = 200;
  local_74 = 10;
  local_64 = 0;
  local_68 = 0;
  bVar3 = false;
  bVar19 = false;
  local_3c = c;
  if (cm < 1) goto LAB_08084190;
  while( true ) {
    *(corner_s **)((int)cs + local_64) = local_3c;
    iVar11 = local_6c + 1;
    iVar6 = corner_radius(local_3c);
    if (iVar6 <= local_68) {
      iVar6 = local_68;
    }
    if (local_3c->n_lines < 1) break;
    local_58 = (line_s *)0x0;
    w = 0;
    do {
      l = local_3c->lines[w];
      c_00 = l->s;
      if (local_3c == c_00) {
        local_38 = (corner_s **)local_3c->y;
        iVar13 = local_3c->x;
        iVar10 = l->e->x;
        iVar7 = l->e->y;
      }
      else {
        iVar13 = l->e->x;
        local_38 = (corner_s **)l->e->y;
        iVar10 = c_00->x;
        iVar7 = c_00->y;
      }
      if (iVar13 == iVar10) {
        iVar13 = (uint)((int)local_38 < iVar7) * 4 + 0x24;
      }
      else {
        if (local_38 != (corner_s **)iVar7) {
          return 0;
        }
        iVar13 = (uint)(iVar13 < iVar10) + 0x11;
      }
      if ((fdir == iVar13) && (bVar18 = local_58 != (line_s *)0x0, local_58 = l, bVar18)) {
        return 0;
      }
      if ((rdir == iVar13) && (l != *(line_s **)(local_64 + -4 + (int)ls))) {
        return 0;
      }
      w = w + 1;
      iVar5 = (iVar5 + (uint)(local_54 == iVar13)) - (uint)(local_50 == iVar13);
    } while (w < local_3c->n_lines);
    if (local_58 == (line_s *)0x0) break;
    uVar15 = (local_58->line->Flags).f;
    bVar18 = true;
    if ((uVar15 & 0x40) == 0) {
      bVar18 = bVar19;
    }
    bVar19 = bVar18;
    bVar18 = true;
    if (-1 < (char)uVar15) {
      bVar18 = bVar3;
    }
    bVar3 = bVar18;
    if (lm <= local_6c) {
      lm = local_74;
      ls = (line_s **)realloc(ls,local_80);
    }
    *(line_s **)((int)ls + local_64) = local_58;
    local_3c = other_corner(local_58,local_3c);
    local_6c = iVar11;
    if (local_3c == (corner_s *)0x0) break;
    if (local_3c->pad != (PadType *)0x0) {
      return 0;
    }
    if (local_3c->pin != (PinType *)0x0) {
      return 0;
    }
    local_64 = local_64 + 4;
    local_74 = local_74 + 1;
    local_80 = local_80 + 0x14;
    if (local_3c->n_lines < 2) {
      return 0;
    }
    local_68 = iVar6;
    if (cm <= iVar11) {
LAB_08084190:
      cm = local_74;
      cs = (corner_s **)realloc(cs,local_74 * 0x2c);
    }
  }
  if (iVar5 == 0) {
    return 0;
  }
  if (iVar11 < 2) {
    return 0;
  }
  if (bVar19) {
    if (any_sel == 0) goto LAB_08084245;
  }
  else {
    if (any_sel != 0) {
      return 0;
    }
LAB_08084245:
    if ((!bVar3) && (autorouted_only != 0)) {
      return 0;
    }
  }
  rr.y1 = 0x7fffffff;
  rr.x1 = 0x7fffffff;
  rr.y2 = -0x80000000;
  rr.x2 = -0x80000000;
  w = corner_radius(c);
  add_point_to_rect(&rr,c->x,c->y,w);
  w = corner_radius(local_3c);
  add_point_to_rect(&rr,local_3c->x,local_3c->y,w);
  bVar19 = fdir == 0x12;
  if (((((-1 < iVar5) || (bVar4 = 0x24, !bVar19)) && ((iVar5 < 1 || (bVar4 = 0x28, !bVar19)))) &&
      ((-1 < iVar5 || (bVar4 = 0x11, fdir != 0x28)))) &&
     ((iVar5 < 1 || (bVar4 = 0x12, fdir != 0x28)))) {
    bVar4 = 0;
  }
  local_58 = (line_s *)0x0;
  local_50 = 0;
  local_40 = -1;
  local_38 = cs;
  do {
    c_00 = local_38[(int)local_58];
    w = 0;
    if (0 < c_00->n_lines) {
      do {
        l = c_00->lines[w];
        pcVar2 = l->s;
        if (c_00 == pcVar2) {
          iVar13 = c_00->x;
          iVar10 = c_00->y;
          iVar7 = l->e->x;
          iVar14 = l->e->y;
        }
        else {
          iVar13 = l->e->x;
          iVar10 = l->e->y;
          iVar7 = pcVar2->x;
          iVar14 = pcVar2->y;
        }
        if (iVar13 == iVar7) {
          bVar12 = (iVar10 < iVar14) * '\x04' + 0x24;
LAB_08084384:
          if (bVar4 == bVar12) {
            local_50 = line_length(l);
            if ((local_50 < local_40) || (local_40 == -1)) {
              local_38 = cs;
              local_40 = local_50;
            }
            else {
              local_38 = cs;
            }
          }
        }
        else {
          if (iVar10 == iVar14) {
            bVar12 = (iVar13 < iVar7) + 0x11;
            goto LAB_08084384;
          }
        }
        w = w + 1;
        c_00 = local_38[(int)local_58];
      } while (c_00->n_lines != w && w <= c_00->n_lines);
    }
    local_58 = (line_s *)((int)local_58 + 1);
  } while ((int)local_58 < iVar11);
  if (bVar4 == 0x12) {
    rr.x2 = iVar6 + c->x + local_40;
  }
  else {
    if (bVar4 < 0x13) {
      if (bVar4 == 0x11) {
        rr.x1 = (c->x - iVar6) - local_40;
      }
    }
    else {
      if (bVar4 == 0x24) {
        rr.y1 = (c->y - iVar6) - local_40;
      }
      else {
        if (bVar4 == 0x28) {
          rr.y2 = iVar6 + c->y + local_40;
        }
      }
    }
  }
  bVar3 = false;
  rr.x1 = (rr.x1 - PCB->Bloat) + -2;
  rr.x2 = rr.x2 + PCB->Bloat + 2;
  rr.y1 = (rr.y1 + -2) - PCB->Bloat;
  rr.y2 = rr.y2 + PCB->Bloat + 2;
  c_00 = corners;
  ppcVar9 = local_38;
  while (l = lines, c_00 != (corner_s *)0x0) {
    if ((c_00->layer != -0x21524111) &&
       ((iVar6 = corner_radius(c_00), c_00->net != c->net || (c_00->pad != (PadType *)0x0)))) {
      local_84 = c_00->x;
      local_48 = c_00->y;
      if (((rr.x1 <= local_84) || (rr.x1 <= iVar6 + local_84)) &&
         ((((local_84 <= rr.x2 || (local_84 - iVar6 <= rr.x2)) &&
           ((rr.y1 <= local_48 || (rr.y1 <= iVar6 + local_48)))) &&
          ((local_48 <= rr.y2 || (local_48 - iVar6 <= rr.y2)))))) {
        if (bVar4 == 0x12) {
          w = 0;
          ppcVar9 = cs;
          do {
            iVar13 = c_00->layer;
            iVar10 = ppcVar9[w]->layer;
            if ((((iVar13 == -1) || (iVar10 == -1)) || (iVar13 == iVar10)) ||
               (layer_groupings[iVar10] == layer_groupings[iVar13])) {
              iVar10 = corner_radius(ppcVar9[w]);
              iVar13 = cs[w]->y;
              uVar15 = ~PCB->Bloat;
              local_48 = c_00->y;
              ppcVar9 = cs;
              if (((int)((uVar15 + iVar13) - iVar10) <= iVar6 + local_48) &&
                 (local_48 - iVar6 <= (int)(PCB->Bloat + 1U + iVar13 + iVar10))) {
                iVar13 = cs[w]->x;
                if ((iVar13 < c_00->x) &&
                   (uVar16 = c_00->x - iVar13, uVar17 = (int)uVar16 >> 0x1f,
                   iVar10 = (((uVar15 - 1) + ((uVar16 ^ uVar17) - uVar17)) - iVar6) - iVar10,
                   iVar10 < local_40)) {
                  bVar3 = true;
                  local_40 = iVar10;
                }
              }
            }
            w = w + 1;
          } while (w < iVar11);
          if (local_6c != 0) {
            w = c_00->layer;
            iVar13 = 0;
            do {
              iVar10 = ls[iVar13]->layer;
              if ((((iVar10 == -1) || (w == -1)) ||
                  ((iVar10 == w || (layer_groupings[iVar10] == layer_groupings[w])))) &&
                 (((ppcVar9[iVar13]->y < local_48 && (local_48 < ppcVar9[iVar13 + 1]->y)) &&
                  (uVar15 = c_00->x - ppcVar9[iVar13]->x, uVar16 = (int)uVar15 >> 0x1f,
                  iVar10 = ((~PCB->Bloat - ls[iVar13]->line->Thickness / 2) + -1 +
                           ((uVar15 ^ uVar16) - uVar16)) - iVar6, iVar10 < local_40)))) {
                bVar3 = true;
                local_40 = iVar10;
              }
              iVar13 = iVar13 + 1;
            } while (iVar13 != local_6c);
          }
        }
        else {
          if (bVar4 < 0x13) {
            if (bVar4 == 0x11) {
              w = 0;
              ppcVar9 = cs;
              do {
                iVar13 = c_00->layer;
                iVar10 = ppcVar9[w]->layer;
                if (((iVar13 == -1) || (iVar10 == -1)) ||
                   ((iVar13 == iVar10 || (layer_groupings[iVar10] == layer_groupings[iVar13])))) {
                  iVar10 = corner_radius(ppcVar9[w]);
                  iVar13 = cs[w]->y;
                  uVar15 = ~PCB->Bloat;
                  local_48 = c_00->y;
                  ppcVar9 = cs;
                  if (((int)((uVar15 + iVar13) - iVar10) <= iVar6 + local_48) &&
                     (local_48 - iVar6 <= (int)(PCB->Bloat + 1U + iVar13 + iVar10))) {
                    iVar13 = cs[w]->x;
                    if ((c_00->x < iVar13) &&
                       (uVar16 = c_00->x - iVar13, uVar17 = (int)uVar16 >> 0x1f,
                       iVar10 = (((uVar15 - 1) + ((uVar16 ^ uVar17) - uVar17)) - iVar6) - iVar10,
                       iVar10 < local_40)) {
                      bVar3 = true;
                      local_40 = iVar10;
                    }
                  }
                }
                w = w + 1;
              } while (w < iVar11);
              if (local_6c != 0) {
                w = c_00->layer;
                iVar13 = 0;
                do {
                  iVar10 = ls[iVar13]->layer;
                  if (((((iVar10 == -1) || (w == -1)) || (w == iVar10)) ||
                      (layer_groupings[iVar10] == layer_groupings[w])) &&
                     (((ppcVar9[iVar13]->y < local_48 && (local_48 < ppcVar9[iVar13 + 1]->y)) &&
                      (uVar15 = c_00->x - ppcVar9[iVar13]->x, uVar16 = (int)uVar15 >> 0x1f,
                      iVar10 = ((~PCB->Bloat - ls[iVar13]->line->Thickness / 2) + -1 +
                               ((uVar15 ^ uVar16) - uVar16)) - iVar6, iVar10 < local_40)))) {
                    bVar3 = true;
                    local_40 = iVar10;
                  }
                  iVar13 = iVar13 + 1;
                } while (iVar13 != local_6c);
              }
            }
          }
          else {
            if (bVar4 == 0x24) {
              w = 0;
              ppcVar9 = cs;
              do {
                iVar13 = c_00->layer;
                iVar10 = ppcVar9[w]->layer;
                if (((iVar13 == -1) || (iVar10 == -1)) ||
                   ((iVar13 == iVar10 || (layer_groupings[iVar10] == layer_groupings[iVar13])))) {
                  iVar10 = corner_radius(ppcVar9[w]);
                  iVar13 = cs[w]->x;
                  uVar15 = ~PCB->Bloat;
                  local_84 = c_00->x;
                  ppcVar9 = cs;
                  if (((int)((uVar15 + iVar13) - iVar10) <= iVar6 + local_84) &&
                     (local_84 - iVar6 <= (int)(PCB->Bloat + 1U + iVar13 + iVar10))) {
                    iVar13 = cs[w]->y;
                    if ((c_00->y < iVar13) &&
                       (uVar16 = c_00->y - iVar13, uVar17 = (int)uVar16 >> 0x1f,
                       iVar10 = (((uVar15 - 1) + ((uVar16 ^ uVar17) - uVar17)) - iVar6) - iVar10,
                       iVar10 < local_40)) {
                      bVar3 = true;
                      local_40 = iVar10;
                    }
                  }
                }
                w = w + 1;
              } while (w < iVar11);
              if (local_6c != 0) {
                w = c_00->layer;
                iVar13 = 0;
                do {
                  iVar10 = ls[iVar13]->layer;
                  if (((((iVar10 == -1) || (w == -1)) || (iVar10 == w)) ||
                      (layer_groupings[iVar10] == layer_groupings[w])) &&
                     (((ppcVar9[iVar13]->x < local_84 && (local_84 < ppcVar9[iVar13 + 1]->x)) &&
                      (uVar15 = c_00->y - ppcVar9[iVar13]->y, uVar16 = (int)uVar15 >> 0x1f,
                      iVar10 = ((~PCB->Bloat - ls[iVar13]->line->Thickness / 2) + -1 +
                               ((uVar15 ^ uVar16) - uVar16)) - iVar6, iVar10 < local_40)))) {
                    bVar3 = true;
                    local_40 = iVar10;
                  }
                  iVar13 = iVar13 + 1;
                } while (iVar13 != local_6c);
              }
            }
            else {
              if (bVar4 == 0x28) {
                w = 0;
                ppcVar9 = cs;
                do {
                  iVar13 = c_00->layer;
                  iVar10 = ppcVar9[w]->layer;
                  if (((iVar13 == -1) || (iVar10 == -1)) ||
                     ((iVar13 == iVar10 || (layer_groupings[iVar10] == layer_groupings[iVar13])))) {
                    iVar10 = corner_radius(ppcVar9[w]);
                    local_84 = c_00->x;
                    iVar13 = cs[w]->x;
                    uVar15 = ~PCB->Bloat;
                    ppcVar9 = cs;
                    if (((int)((uVar15 + iVar13) - iVar10) <= iVar6 + local_84) &&
                       (local_84 - iVar6 <= (int)(PCB->Bloat + 1U + iVar13 + iVar10))) {
                      iVar13 = cs[w]->y;
                      if ((iVar13 < c_00->y) &&
                         (uVar16 = c_00->y - iVar13, uVar17 = (int)uVar16 >> 0x1f,
                         iVar10 = (((uVar15 - 1) + ((uVar16 ^ uVar17) - uVar17)) - iVar6) - iVar10,
                         iVar10 < local_40)) {
                        bVar3 = true;
                        local_40 = iVar10;
                      }
                    }
                  }
                  w = w + 1;
                } while (w < iVar11);
                if (local_6c != 0) {
                  w = c_00->layer;
                  iVar13 = 0;
                  do {
                    iVar10 = ls[iVar13]->layer;
                    if ((((((iVar10 == -1) || (w == -1)) || (w == iVar10)) ||
                         (layer_groupings[iVar10] == layer_groupings[w])) &&
                        ((ppcVar9[iVar13]->x < local_84 && (local_84 < ppcVar9[iVar13 + 1]->x)))) &&
                       (uVar15 = c_00->y - ppcVar9[iVar13]->y, uVar16 = (int)uVar15 >> 0x1f,
                       iVar10 = ((~PCB->Bloat - ls[iVar13]->line->Thickness / 2) + -1 +
                                ((uVar15 ^ uVar16) - uVar16)) - iVar6, iVar10 < local_40)) {
                      bVar3 = true;
                      local_40 = iVar10;
                    }
                    iVar13 = iVar13 + 1;
                  } while (iVar13 != local_6c);
                }
              }
            }
          }
        }
      }
    }
    c_00 = c_00->next;
    ppcVar9 = cs;
  }
  while (l != (line_s *)0x0) {
    if ((l->layer != -0x21524111) && (c_00 = l->s, c_00->net != c->net)) {
      iVar6 = c_00->x;
      w = c_00->y;
      local_38 = (corner_s **)l->e->x;
      local_5c = l->e->y;
      if (local_38 == (corner_s **)iVar6) {
        iVar13 = (uint)(local_5c < w) * 4 + 0x24;
      }
      else {
        iVar13 = 0xf0;
        if (local_5c == w) {
          iVar13 = (uint)((int)local_38 < iVar6) + 0x11;
        }
      }
      local_68 = w;
      local_64 = iVar6;
      if (bVar19) {
        if ((iVar13 != 0x28) && (iVar13 != 0x24)) {
          if (iVar6 < (int)local_38) {
            local_68 = local_5c;
            local_64 = (int)local_38;
            local_5c = w;
            local_38 = (corner_s **)iVar6;
          }
          if (!bVar19) goto LAB_08084592;
          if ((c->x <= local_64) && ((int)local_38 <= local_3c->x)) goto LAB_0808459c;
        }
      }
      else {
        if (fdir == 0x28) {
          if (iVar13 - 0x11U < 2) goto LAB_080846e1;
          iVar13 = local_5c;
          iVar10 = (int)local_38;
          if (local_5c <= w) goto LAB_08084592;
LAB_08084900:
          local_38 = (corner_s **)iVar6;
          local_5c = w;
          local_64 = iVar10;
          local_68 = iVar13;
          if ((c->y != local_68 && local_68 <= c->y) || (local_3c->y < local_5c)) goto LAB_080846e1;
        }
        else {
LAB_08084592:
          iVar13 = local_68;
          iVar10 = local_64;
          w = local_5c;
          iVar6 = (int)local_38;
          if (fdir == 0x28) goto LAB_08084900;
        }
LAB_0808459c:
        if (bVar4 == 0x24) {
          if ((c->y < local_5c) && (c->y < local_68)) goto LAB_080846e1;
LAB_08084991:
          if (local_5c < local_68) {
LAB_0808499d:
            local_5c = local_68;
          }
        }
        else {
          if (bVar4 == 0x28) {
            if ((local_5c < c->y) && (local_68 < c->y)) goto LAB_080846e1;
LAB_08084c0a:
            if (local_68 < local_5c) goto LAB_0808499d;
          }
          else {
            if (bVar4 == 0x11) {
              if ((c->x < (int)local_38) && (c->x < local_64)) goto LAB_080846e1;
LAB_080845ce:
              if ((int)local_38 < local_64) {
LAB_080845d6:
                local_38 = (corner_s **)local_64;
              }
            }
            else {
              if (bVar4 == 0x12) {
                if (((int)local_38 < c->x) && (local_64 < c->x)) goto LAB_080846e1;
                if (local_64 < (int)local_38) goto LAB_080845d6;
              }
              else {
                if (bVar4 < 0x13) {
                  if (bVar4 == 0x11) goto LAB_080845ce;
                }
                else {
                  if (bVar4 == 0x24) goto LAB_08084991;
                  if (bVar4 == 0x28) goto LAB_08084c0a;
                }
              }
            }
          }
        }
        iVar6 = 0;
        do {
          iVar13 = l->line->Thickness;
          iVar10 = PCB->Bloat;
          iVar7 = corner_radius(ppcVar9[iVar6]);
          w = local_40;
          if (bVar19) {
            c_00 = cs[iVar6];
            if ((c_00->x <= local_64) && ((int)local_38 <= c_00->x)) goto LAB_0808464c;
          }
          else {
            if (fdir == 0x28) {
              c_00 = cs[iVar6];
              if ((local_68 < c_00->y) || (c_00->y < local_5c)) goto LAB_08084600;
            }
            else {
              c_00 = cs[iVar6];
            }
LAB_0808464c:
            iVar14 = l->layer;
            iVar1 = c_00->layer;
            if ((((iVar14 == -1) || (iVar1 == -1)) || (iVar14 == iVar1)) ||
               (layer_groupings[iVar1] == layer_groupings[iVar14])) {
              if (bVar4 == 0x12) {
                w = (int)local_38 - c->x;
              }
              else {
                if (bVar4 < 0x13) {
                  if (bVar4 == 0x11) {
                    w = c->x - (int)local_38;
                  }
                  else {
LAB_08084672:
                    w = 0;
                  }
                }
                else {
                  if (bVar4 == 0x24) {
                    w = c->y - local_5c;
                  }
                  else {
                    if (bVar4 != 0x28) goto LAB_08084672;
                    w = local_5c - c->y;
                  }
                }
              }
              w = (w - iVar7) + -2 + (-iVar13 - iVar10);
              if (w < 1) {
                return 0;
              }
              if (local_40 <= w) {
                w = local_40;
              }
            }
          }
LAB_08084600:
          local_40 = w;
          iVar6 = iVar6 + 1;
          ppcVar9 = cs;
        } while (iVar6 < iVar11);
      }
    }
LAB_080846e1:
    l = l->next;
  }
  do {
    local_48 = 0;
    bVar18 = true;
    do {
      iVar6 = 0;
      c_00 = ppcVar9[local_48];
      if (0 < c_00->n_lines) {
        do {
          l = c_00->lines[iVar6];
          pcVar8 = other_corner(l,c_00);
          pcVar2 = l->s;
          c_00 = cs[local_48];
          if (c_00 == pcVar2) {
            local_58 = (line_s *)c_00->y;
            local_3c = (corner_s *)c_00->x;
            local_38 = (corner_s **)l->e->x;
            w = l->e->y;
          }
          else {
            local_3c = (corner_s *)l->e->x;
            local_58 = (line_s *)l->e->y;
            local_38 = (corner_s **)pcVar2->x;
            w = pcVar2->y;
          }
          if (local_3c == (corner_s *)local_38) {
            bVar12 = ((int)local_58 < w) * '\x04' + 0x24;
LAB_08084791:
            if (bVar4 == bVar12) {
              local_50 = line_length(l);
              if ((pcVar8->pad == (PadType *)0x0) || (cs[local_48]->via == (PinType *)0x0)) {
                c_00 = l->s;
                if ((c_00->pin == (PinType *)0x0) &&
                   ((c_00->pad == (PadType *)0x0 && (c_00->via == (PinType *)0x0)))) {
                  c_00 = cs[local_48];
                }
                else {
                  pcVar2 = l->e;
                  if ((pcVar2->pin == (PinType *)0x0) &&
                     ((pcVar2->pad == (PadType *)0x0 && (pcVar2->via == (PinType *)0x0))))
                  goto LAB_08084d12;
                  if (local_40 != local_50) goto LAB_080847c5;
                  c_00 = cs[local_48];
                  local_50 = local_40;
                }
              }
              else {
                c_00 = l->s;
LAB_080847c5:
                w = corner_radius(c_00);
                iVar13 = corner_radius(l->e);
                local_50 = ((local_50 + (-2 - PCB->Bloat)) - w) - iVar13;
                if (local_50 < local_40) {
                  bVar18 = false;
                  c_00 = cs[local_48];
                  local_40 = local_50;
                }
                else {
LAB_08084d12:
                  c_00 = cs[local_48];
                }
              }
            }
          }
          else {
            if (local_58 == (line_s *)w) {
              bVar12 = ((int)local_3c < (int)local_38) + 0x11;
              goto LAB_08084791;
            }
          }
          iVar6 = iVar6 + 1;
          ppcVar9 = cs;
        } while (c_00->n_lines != iVar6 && iVar6 <= c_00->n_lines);
      }
      local_48 = local_48 + 1;
    } while (local_48 < iVar11);
  } while (!bVar18);
  if (local_40 < 1) {
    return 0;
  }
  if (bVar4 == 0x12) {
    local_50 = local_40 + c->x;
  }
  else {
    if (bVar4 < 0x13) {
      if (bVar4 == 0x11) {
        local_50 = c->x - local_40;
      }
    }
    else {
      if (bVar4 == 0x24) {
        local_50 = c->y - local_40;
      }
      else {
        if (bVar4 == 0x28) {
          local_50 = local_40 + c->y;
        }
      }
    }
  }
  if ((bVar3) && (Settings.Grid < (double)local_40)) {
    if (iVar5 < 0) {
      local_50 = (int)ROUND((Settings.Grid - 1.00000000) + (double)local_50);
    }
    local_50 = local_50 - local_50 % (int)ROUND(Settings.Grid);
  }
  if (bVar19) {
    iVar6 = (*ppcVar9)->y;
  }
  else {
    if (fdir != 0x28) goto LAB_08084a70;
    iVar6 = (*ppcVar9)->x;
  }
  if (iVar6 == local_50) {
    return 0;
  }
LAB_08084a70:
  iVar6 = 0;
  w = 0;
  do {
    if (bVar19) {
      c_00 = *(corner_s **)((int)ppcVar9 + iVar6);
      iVar13 = c_00->y;
      move_corner(c_00,c_00->x,local_50);
    }
    else {
      c_00 = *(corner_s **)((int)ppcVar9 + iVar6);
      iVar13 = c_00->x;
      move_corner(c_00,local_50,c_00->y);
    }
    local_38 = (corner_s **)(local_50 - iVar13);
    w = w + 1;
    iVar6 = iVar6 + 4;
    ppcVar9 = cs;
  } while (w < iVar11);
  return (int)local_38 * iVar5;
}



int __regparm3 canonicalize_line(line_s *l)

{
  corner_s **ppcVar1;
  corner_s *pcVar2;
  int y;
  int iVar3;
  Boolean BVar4;
  int iVar5;
  PinType *PV;
  corner_s *c;
  int iVar6;
  int x2;
  BDimension BVar7;
  corner_s *local_30;
  int local_28;
  int local_20;
  
  pcVar2 = l->e;
  local_30 = l->s;
  local_20 = pcVar2->x;
  iVar5 = local_30->x;
  c = corners;
  if (iVar5 == local_20) {
    local_20 = pcVar2->y;
    x2 = local_30->y;
    iVar6 = l->line->Thickness / 2;
    iVar5 = x2;
    if (local_20 < x2) {
      iVar5 = local_20;
      local_20 = x2;
    }
    if (corners != (corner_s *)0x0) {
      do {
        x2 = c->layer;
        if ((((x2 != -0x21524111) && (y = c->y, iVar5 < y)) && (y < local_20)) &&
           (((iVar3 = l->layer, x2 == -1 || (iVar3 == -1)) ||
            ((x2 == iVar3 || (layer_groupings[iVar3] == layer_groupings[x2])))))) {
          x2 = c->x;
          if (x2 == local_30->x) goto LAB_08085710;
          if (((x2 < iVar5 + iVar6) && (iVar5 - iVar6 < x2)) &&
             ((c->pad == (PadType *)0x0 && (c->pin == (PinType *)0x0)))) {
            move_corner(c,local_30->x,y);
            local_30 = l->s;
            if (c->x == local_30->x) goto LAB_08085710;
          }
        }
        ppcVar1 = &c->next;
        c = *ppcVar1;
      } while (*ppcVar1 != (corner_s *)0x0);
    }
  }
  else {
    local_28 = local_30->y;
    x2 = pcVar2->y;
    if (local_28 == x2) {
      iVar6 = l->line->Thickness / 2;
      x2 = iVar5;
      if (local_20 < iVar5) {
        x2 = local_20;
        local_20 = iVar5;
      }
      if (corners != (corner_s *)0x0) {
        do {
          iVar5 = c->layer;
          if ((((iVar5 != -0x21524111) && (y = c->x, x2 < y)) && (y < local_20)) &&
             (((iVar3 = l->layer, iVar5 == -1 || (iVar3 == -1)) ||
              ((iVar5 == iVar3 || (layer_groupings[iVar3] == layer_groupings[iVar5])))))) {
            iVar5 = c->y;
            if (iVar5 == local_30->y) goto LAB_08085710;
            if (((iVar5 < local_28 + iVar6) && (local_28 - iVar6 < iVar5)) &&
               ((c->pad == (PadType *)0x0 && (c->pin == (PinType *)0x0)))) {
              move_corner(c,y,local_30->y);
              local_30 = l->s;
              if (c->y == local_30->y) goto LAB_08085710;
            }
          }
          ppcVar1 = &c->next;
          c = *ppcVar1;
        } while (*ppcVar1 != (corner_s *)0x0);
      }
    }
    else {
      iVar6 = iVar5;
      if (local_20 < iVar5) {
        iVar6 = local_20;
        local_20 = iVar5;
      }
      local_30 = (corner_s *)x2;
      if (x2 < local_28) {
        local_30 = (corner_s *)local_28;
        local_28 = x2;
      }
      if (corners != (corner_s *)0x0) {
        do {
          while( true ) {
            iVar5 = c->layer;
            if (iVar5 == -0x21524111) goto LAB_080854a0;
            if ((c->via != (PinType *)0x0) || (c->pin != (PinType *)0x0)) break;
            c = c->next;
joined_r0x080854c8:
            if (c == (corner_s *)0x0) {
              return 0;
            }
          }
          x2 = c->x;
          if ((x2 <= iVar6) ||
             (((local_20 <= x2 || (y = c->y, y <= local_28)) || ((int)local_30 <= y)))) {
LAB_080854a0:
            c = c->next;
            goto joined_r0x080854c8;
          }
          iVar3 = l->layer;
          if ((((iVar5 == -1) || (iVar3 == -1)) || (iVar5 == iVar3)) ||
             (layer_groupings[iVar3] == layer_groupings[iVar5])) {
            if (c->pin == (PinType *)0x0) {
              BVar7 = c->via->Thickness;
            }
            else {
              BVar7 = c->pin->Thickness;
            }
            iVar5 = dist(l->s->x,l->s->y,x2,y);
            if ((BVar7 / 2 < iVar5) && (iVar5 = dist(l->e->x,l->e->y,c->x,c->y), BVar7 / 2 < iVar5))
            {
              PV = c->pin;
              if (PV == (PinType *)0x0) {
                PV = c->via;
              }
              BVar4 = PinLineIntersect((PinTypePtr *)PV,(LineTypePtr)l->line);
              if (BVar4 != '\0') {
LAB_08085710:
                iVar5 = split_line(l,c);
                return iVar5;
              }
            }
            goto LAB_080854a0;
          }
          c = c->next;
        } while (c != (corner_s *)0x0);
      }
    }
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

int simple_optimizations(void)

{
  LineType **ppLVar1;
  FlagType *pFVar2;
  line_s **pplVar3;
  corner_s *pcVar4;
  char cVar5;
  int iVar6;
  int iVar7;
  corner_s *pcVar8;
  char cVar9;
  line_s *plVar10;
  corner_s *c;
  int iVar11;
  int iVar12;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  iVar11 = 0;
  c = corners;
  if (corners != (corner_s *)0x0) {
    do {
      if (((c->layer != -0x21524111) && (c->pad == (PadType *)0x0)) && (c->pin == (PinType *)0x0)) {
        if (((c->via == (PinType *)0x0) || (iVar6 = mem_any_set((c->via->Flags).t,8), iVar6 != 0))
           || (c->via->Mask != 0)) {
          iVar6 = c->n_lines;
          iVar12 = 0;
        }
        else {
          iVar6 = c->n_lines;
          local_28 = 1;
          if (iVar6 < 2) {
LAB_080857e0:
            if (local_28 == iVar6) {
              iVar12 = 1;
              remove_via_at(c);
              iVar6 = c->n_lines;
              goto LAB_080857ff;
            }
          }
          else {
            pplVar3 = c->lines;
            if (pplVar3[1]->layer == (*pplVar3)->layer) {
              local_28 = 1;
              do {
                local_28 = local_28 + 1;
                if (iVar6 <= local_28) goto LAB_080857e0;
              } while (pplVar3[local_28]->layer == pplVar3[1]->layer);
              goto LAB_08085750;
            }
          }
          iVar12 = 0;
        }
LAB_080857ff:
        if ((iVar6 == 2) && (c->via == (PinType *)0x0)) {
          plVar10 = *c->lines;
          pcVar4 = plVar10->s;
          if (c == pcVar4) {
            local_24 = c->x;
            local_20 = plVar10->e->x;
            iVar7 = plVar10->e->y;
            iVar6 = c->y;
          }
          else {
            local_24 = plVar10->e->x;
            iVar6 = plVar10->e->y;
            local_20 = pcVar4->x;
            iVar7 = pcVar4->y;
          }
          if (local_24 == local_20) {
            cVar9 = (iVar6 < iVar7) * '\x04' + '$';
          }
          else {
            cVar9 = -0x10;
            if (iVar6 == iVar7) {
              cVar9 = (local_24 < local_20) + '\x11';
            }
          }
          pcVar8 = other_corner(c->lines[1],c);
          other_corner((line_s *)((line_s *)c->lines)->layer,c);
          pplVar3 = c->lines;
          plVar10 = pplVar3[1];
          pcVar4 = plVar10->s;
          if (pcVar8 == pcVar4) {
            local_34 = pcVar8->x;
            local_30 = pcVar8->y;
            local_2c = plVar10->e->x;
            local_28 = plVar10->e->y;
          }
          else {
            local_34 = plVar10->e->x;
            local_30 = plVar10->e->y;
            local_2c = pcVar4->x;
            local_28 = pcVar4->y;
          }
          if (local_34 == local_2c) {
            cVar5 = (local_30 < local_28) * '\x04' + '$';
          }
          else {
            cVar5 = -0x10;
            if (local_30 == local_28) {
              cVar5 = (local_34 < local_2c) + '\x11';
            }
          }
          if ((cVar9 == cVar5) && (cVar9 != -0x10)) {
            if ((*(byte *)&((*pplVar3)->line->Flags).f & 0x40) != 0) {
              ppLVar1 = &plVar10->line;
              plVar10 = pplVar3[1];
              pFVar2 = &(*ppLVar1)->Flags;
              pFVar2->f = pFVar2->f | 0x40;
            }
            if ((*(byte *)&(plVar10->line->Flags).f & 0x40) != 0) {
              pFVar2 = &(*pplVar3)->line->Flags;
              pFVar2->f = pFVar2->f | 0x40;
            }
            iVar11 = iVar11 + iVar12;
            move_corner(c,pcVar8->x,pcVar8->y);
            goto LAB_08085750;
          }
        }
        iVar11 = iVar11 + iVar12;
      }
LAB_08085750:
      c = c->next;
    } while (c != (corner_s *)0x0);
  }
  return iVar11;
}



int debumpify(void)

{
  line_s **pplVar1;
  LineType *pLVar2;
  corner_s *c;
  int iVar3;
  line_s *plVar4;
  int iVar5;
  corner_s *c_00;
  corner_s *pcVar6;
  byte bVar7;
  byte bVar8;
  line_s *l;
  byte bVar9;
  int iVar10;
  int iVar11;
  bool bVar12;
  int iVar13;
  bool bVar14;
  line_s *local_70;
  int local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  corner_s *local_50;
  int local_4c;
  int local_48;
  rect_s rp;
  rect_s rr;
  
  iVar13 = 0;
  plVar4 = lines;
  if (lines != (line_s *)0x0) {
    do {
      if (((plVar4->layer != -0x21524111) && (plVar4->line != (LineType *)0x0)) &&
         ((*(byte *)&(plVar4->line->Flags).f & 0x40) != 0)) {
        bVar12 = true;
        goto LAB_08085a32;
      }
      pplVar1 = &plVar4->next;
      plVar4 = *pplVar1;
    } while (*pplVar1 != (line_s *)0x0);
    bVar12 = false;
LAB_08085a32:
    iVar13 = 0;
    plVar4 = lines;
    do {
      while ((plVar4->layer == -0x21524111 || (pLVar2 = plVar4->line, pLVar2 == (LineType *)0x0))) {
LAB_08085a52:
        plVar4 = plVar4->next;
        if (plVar4 == (line_s *)0x0) goto LAB_08085a80;
      }
      if (!bVar12) {
        if ((autorouted_only == 0) || (*(char *)&(pLVar2->Flags).f < '\0')) goto LAB_08085a48;
        goto LAB_08085a52;
      }
      if ((*(byte *)&(pLVar2->Flags).f & 0x40) != 0) {
LAB_08085a48:
        c_00 = plVar4->s;
        if ((((c_00->pin == (PinType *)0x0) && (c_00->pad == (PadType *)0x0)) &&
            (pcVar6 = plVar4->e, pcVar6->pin == (PinType *)0x0)) && (pcVar6->pad == (PadType *)0x0))
        {
          local_58 = pcVar6->x;
          local_60 = pcVar6->y;
          local_5c = c_00->x;
          local_64 = c_00->y;
          if (local_58 == local_5c) {
            bVar7 = (local_60 < local_64) * '\x04' + 0x24;
          }
          else {
            if (local_60 != local_64) goto LAB_08085a52;
            bVar7 = (local_58 < local_5c) + 0x11;
          }
          if (c_00->via == (PinType *)0x0) {
            local_50 = (corner_s *)0x0;
            local_4c = 0;
            while (local_4c < c_00->n_lines) {
              local_70 = c_00->lines[local_4c];
              if (plVar4 == local_70) {
                local_70 = (line_s *)local_50;
              }
              else {
                if (local_50 != (corner_s *)0x0) goto LAB_08085a52;
              }
              local_50 = (corner_s *)local_70;
              local_4c = local_4c + 1;
            }
            if (local_50 != (corner_s *)0x0) {
              c = ((line_s *)local_50)->s;
              if (c_00 == c) {
                local_68 = ((line_s *)local_50)->e->x;
                iVar5 = ((line_s *)local_50)->e->y;
              }
              else {
                local_5c = ((line_s *)local_50)->e->x;
                local_64 = ((line_s *)local_50)->e->y;
                local_68 = c->x;
                iVar5 = c->y;
              }
              if (local_5c == local_68) {
                bVar9 = (local_64 < iVar5) * '\x04' + 0x24;
              }
              else {
                bVar9 = 0xf0;
                if (local_64 == iVar5) {
                  bVar9 = (local_5c < local_68) + 0x11;
                }
              }
              if (pcVar6->via == (PinType *)0x0) {
                local_5c = 0;
                l = (line_s *)0x0;
                while (local_5c < pcVar6->n_lines) {
                  if ((plVar4 != pcVar6->lines[local_5c]) &&
                     (bVar14 = l != (line_s *)0x0, l = pcVar6->lines[local_5c], bVar14))
                  goto LAB_08085a52;
                  local_5c = local_5c + 1;
                }
                if (l != (line_s *)0x0) {
                  c_00 = l->s;
                  if (pcVar6 == c_00) {
                    local_48 = l->e->x;
                    local_5c = l->e->y;
                  }
                  else {
                    local_58 = l->e->x;
                    local_60 = l->e->y;
                    local_48 = c_00->x;
                    local_5c = c_00->y;
                  }
                  if (local_58 == local_48) {
                    bVar8 = (local_60 < local_5c) * '\x04' + 0x24;
                  }
                  else {
                    bVar8 = 0xf0;
                    if (local_60 == local_5c) {
                      bVar8 = (local_58 < local_48) + 0x11;
                    }
                  }
                  if (((bVar9 == bVar8) && (((bVar9 ^ bVar7) & 0xf0) != 0)) && (bVar9 != 0xf0)) {
                    rr.y1 = 0x7fffffff;
                    rr.x1 = 0x7fffffff;
                    rr.y2 = -0x80000000;
                    rr.x2 = -0x80000000;
                    iVar5 = PCB->Bloat + 2 + pLVar2->Thickness / 2;
                    add_line_to_rect(&rr,(line_s *)local_50);
                    add_line_to_rect(&rr,l);
                    c_00 = plVar4->s;
                    if ((rr.x1 != c_00->x) && (rr.x1 != plVar4->e->x)) {
                      rr.x1 = rr.x1 - iVar5;
                    }
                    if ((c_00->x != rr.x2) && (rr.x2 != plVar4->e->x)) {
                      rr.x2 = iVar5 + rr.x2;
                    }
                    if ((rr.y1 != c_00->y) && (rr.y1 != plVar4->e->y)) {
                      rr.y1 = rr.y1 - iVar5;
                    }
                    if ((c_00->y != rr.y2) && (rr.y2 != plVar4->e->y)) {
                      rr.y2 = iVar5 + rr.y2;
                    }
                    c_00 = other_corner((line_s *)local_50,c_00);
                    pcVar6 = other_corner(l,plVar4->e);
                    rp.y1 = 0x7fffffff;
                    rp.x1 = 0x7fffffff;
                    rp.y2 = -0x80000000;
                    rp.x2 = -0x80000000;
                    local_50 = corners;
                    while (local_50 != (corner_s *)0x0) {
                      iVar3 = local_50->layer;
                      if (((iVar3 != -0x21524111) && (local_50->net != plVar4->s->net)) &&
                         ((iVar10 = plVar4->s->layer, iVar10 == -1 ||
                          (((iVar3 == -1 || (iVar3 == iVar10)) ||
                           (layer_groupings[iVar3] == layer_groupings[iVar10])))))) {
                        add_corner_to_rect_if(&rp,local_50,&rr);
                      }
                      local_50 = local_50->next;
                    }
                    if (rp.x1 == 0x7fffffff) {
                      rp.x1 = rr.x2;
                      rp.x2 = rr.x1;
                      rp.y1 = rr.y2;
                      rp.y2 = rr.y1;
                    }
                    if (bVar9 == 0x12) {
                      c = plVar4->s;
                      iVar3 = c->x;
                      iVar5 = (rp.x1 - iVar3) - iVar5;
                      local_48 = 0;
                      if (0 < iVar5) {
                        local_48 = iVar5 - iVar5 % (int)ROUND(Settings.Grid);
                      }
                      iVar5 = pcVar6->x - iVar3;
                      iVar10 = c_00->x - iVar3;
                      if (iVar10 < iVar5) {
                        iVar5 = iVar10;
                      }
                      if (local_48 < iVar5) {
                        iVar5 = local_48;
                      }
                      if (0 < iVar5) {
                        move_corner(c,iVar5 + iVar3,c->y);
                        c_00 = plVar4->e;
                        move_corner(c_00,iVar5 + c_00->x,c_00->y);
                        iVar13 = iVar13 + iVar5;
                      }
                    }
                    else {
                      if (bVar9 < 0x13) {
                        if (bVar9 == 0x11) {
                          c = plVar4->s;
                          local_5c = 0;
                          iVar3 = c->x;
                          iVar5 = (iVar3 - rp.x2) - iVar5;
                          if (0 < iVar5) {
                            local_5c = iVar5 - iVar5 % (int)ROUND(Settings.Grid);
                          }
                          iVar5 = iVar3 - pcVar6->x;
                          iVar10 = iVar3 - c_00->x;
                          if (iVar10 < iVar5) {
                            iVar5 = iVar10;
                          }
                          if (local_5c < iVar5) {
                            iVar5 = local_5c;
                          }
                          if (0 < iVar5) {
                            move_corner(c,iVar3 - iVar5,c->y);
                            c_00 = plVar4->e;
                            move_corner(c_00,c_00->x - iVar5,c_00->y);
                            iVar13 = iVar13 + iVar5;
                          }
                        }
                      }
                      else {
                        if (bVar9 == 0x24) {
                          if (rp.y2 == -0x80000000) {
                            rp.y2 = rr.y1;
                          }
                          c = plVar4->s;
                          iVar3 = c->y;
                          iVar10 = iVar3 - pcVar6->y;
                          iVar11 = iVar3 - c_00->y;
                          local_48 = (iVar3 - rp.y2) - iVar5;
                          iVar5 = iVar10;
                          if (iVar11 <= iVar10) {
                            iVar5 = iVar11;
                          }
                          if (iVar5 <= local_48) {
                            local_48 = iVar5;
                          }
                          if ((iVar10 != local_48) && (iVar11 != local_48)) {
                            if (local_48 < 1) goto LAB_08085a52;
                            local_48 = local_48 - local_48 % (int)ROUND(Settings.Grid);
                          }
                          if (0 < local_48) {
                            move_corner(c,c->x,iVar3 - local_48);
                            c_00 = plVar4->e;
                            move_corner(c_00,c_00->x,c_00->y - local_48);
                            iVar13 = iVar13 + local_48;
                          }
                        }
                        else {
                          if (bVar9 == 0x28) {
                            c = plVar4->s;
                            iVar3 = c->y;
                            iVar5 = (rp.y1 - iVar3) - iVar5;
                            local_48 = 0;
                            if (0 < iVar5) {
                              local_48 = iVar5 - iVar5 % (int)ROUND(Settings.Grid);
                            }
                            iVar5 = pcVar6->y - iVar3;
                            iVar10 = c_00->y - iVar3;
                            if (iVar10 < iVar5) {
                              iVar5 = iVar10;
                            }
                            if (local_48 < iVar5) {
                              iVar5 = local_48;
                            }
                            if (0 < iVar5) {
                              move_corner(c,c->x,iVar3 + iVar5);
                              c_00 = plVar4->e;
                              move_corner(c_00,c_00->x,iVar5 + c_00->y);
                              iVar13 = iVar13 + iVar5;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        goto LAB_08085a52;
      }
      plVar4 = plVar4->next;
    } while (plVar4 != (line_s *)0x0);
  }
LAB_08085a80:
  iVar5 = simple_optimizations();
  iVar13 = iVar13 + iVar5;
  if (iVar13 != 0) {
    __printf_chk(1,"debumpify: %d mils saved\n",iVar13 / 0x32);
  }
  return iVar13;
}



// WARNING: Type propagation algorithm not settling

int unjaggy(void)

{
  LineType *pLVar1;
  LineType *pLVar2;
  line_s **pplVar3;
  line_s *l;
  line_s *plVar4;
  bool bVar5;
  bool bVar6;
  char cVar7;
  int iVar8;
  corner_s *c;
  corner_s *c_00;
  int iVar9;
  int iVar10;
  undefined4 uVar11;
  int iVar12;
  char cVar13;
  char cVar14;
  int iVar15;
  bool bVar16;
  corner_s *c_01;
  corner_s *c_02;
  int local_80;
  int local_74;
  int local_70;
  int local_68;
  int local_64;
  int local_5c;
  int local_4c;
  int local_48;
  int local_44;
  rect_s rp;
  rect_s rr;
  
  local_70 = 0;
  local_68 = 0;
  l = lines;
joined_r0x080861f7:
  do {
    if (l == (line_s *)0x0) {
      bVar5 = false;
    }
    else {
      if (((l->layer == -0x21524111) || (l->line == (LineType *)0x0)) ||
         ((*(byte *)&(l->line->Flags).f & 0x40) == 0)) {
        l = l->next;
        goto joined_r0x080861f7;
      }
      bVar5 = true;
    }
    local_64 = 0;
    c_01 = corners;
joined_r0x08086236:
    if (c_01 != (corner_s *)0x0) {
LAB_08086240:
      if ((c_01->layer != -0x21524111) && (iVar8 = simple_corner(c_01), iVar8 != 0)) {
        l = (line_s *)((line_s *)c_01->lines)->layer;
        pLVar1 = l->line;
        if ((pLVar1 == (LineType *)0x0) ||
           (pLVar2 = ((line_s *)c_01->lines)->next->line, pLVar2 == (LineType *)0x0))
        goto LAB_08086488;
        if (!bVar5) {
          if (((autorouted_only == 0) || (*(char *)&(pLVar1->Flags).f < '\0')) ||
             (*(char *)&(pLVar2->Flags).f < '\0')) goto LAB_08086298;
          c_01 = c_01->next;
          goto joined_r0x08086520;
        }
        if (((*(byte *)&(pLVar1->Flags).f & 0x40) == 0) &&
           ((*(byte *)&(pLVar2->Flags).f & 0x40) == 0)) goto LAB_08086488;
LAB_08086298:
        c = other_corner(l,c_01);
        pplVar3 = c_01->lines;
        l = *pplVar3;
        c_02 = l->s;
        if (c_01 == c_02) {
          iVar8 = c_01->x;
          iVar10 = c_01->y;
          iVar15 = l->e->x;
          iVar9 = l->e->y;
        }
        else {
          iVar8 = l->e->x;
          iVar10 = l->e->y;
          iVar15 = c_02->x;
          iVar9 = c_02->y;
        }
        if (iVar8 == iVar15) {
          cVar7 = (iVar10 < iVar9) * '\x04' + '$';
        }
        else {
          cVar7 = -0x10;
          if (iVar10 == iVar9) {
            cVar7 = (iVar8 < iVar15) + '\x11';
          }
        }
        iVar8 = simple_corner(c);
        c_00 = other_corner(pplVar3[1],c_01);
        l = (line_s *)c_01->lines;
        plVar4 = l->next;
        c_02 = plVar4->s;
        if (c_01 == c_02) {
          iVar10 = c_01->x;
          iVar15 = c_01->y;
          iVar9 = plVar4->e->x;
          iVar12 = plVar4->e->y;
        }
        else {
          iVar10 = plVar4->e->x;
          iVar15 = plVar4->e->y;
          iVar9 = c_02->x;
          iVar12 = c_02->y;
        }
        if (iVar10 == iVar9) {
          cVar14 = (iVar15 < iVar12) * '\x04' + '$';
        }
        else {
          cVar14 = -0x10;
          if (iVar15 == iVar12) {
            cVar14 = (iVar10 < iVar9) + '\x11';
          }
        }
        iVar10 = simple_corner(c_00);
        if ((iVar10 != 0) || (iVar8 != 0)) {
          bVar16 = true;
          iVar8 = c->n_lines;
          if (0 < iVar8) {
            iVar10 = 0;
            do {
              while ((plVar4 = c->lines[iVar10], plVar4 != (line_s *)l->layer &&
                     (plVar4->layer == ((line_s *)l->layer)->layer))) {
                c_02 = plVar4->s;
                if (c == c_02) {
                  local_48 = c->x;
                  local_5c = c->y;
                  local_80 = plVar4->e->x;
                  local_4c = plVar4->e->y;
                }
                else {
                  local_48 = plVar4->e->x;
                  local_5c = plVar4->e->y;
                  local_80 = c_02->x;
                  local_4c = c_02->y;
                }
                if (local_48 == local_80) {
                  cVar13 = (local_5c < local_4c) * '\x04' + '$';
                }
                else {
                  cVar13 = -0x10;
                  if (local_5c == local_4c) {
                    cVar13 = (local_48 < local_80) + '\x11';
                  }
                }
                bVar6 = false;
                if (cVar14 != cVar13) {
                  bVar6 = bVar16;
                }
                bVar16 = bVar6;
                iVar10 = iVar10 + 1;
                if (iVar10 == iVar8) goto LAB_080863df;
              }
              iVar10 = iVar10 + 1;
            } while (iVar10 != iVar8);
          }
LAB_080863df:
          iVar8 = c_00->n_lines;
          if (0 < iVar8) {
            iVar10 = 0;
            do {
              while ((plVar4 = c_00->lines[iVar10], plVar4 != (line_s *)l->layer &&
                     (plVar4->layer == ((line_s *)l->layer)->layer))) {
                c_02 = plVar4->s;
                if (c_00 == c_02) {
                  local_44 = c_00->x;
                  local_4c = c_00->y;
                  local_74 = plVar4->e->x;
                  local_48 = plVar4->e->y;
                }
                else {
                  local_44 = plVar4->e->x;
                  local_4c = plVar4->e->y;
                  local_74 = c_02->x;
                  local_48 = c_02->y;
                }
                if (local_44 == local_74) {
                  cVar14 = (local_4c < local_48) * '\x04' + '$';
                }
                else {
                  cVar14 = -0x10;
                  if (local_4c == local_48) {
                    cVar14 = (local_44 < local_74) + '\x11';
                  }
                }
                bVar6 = false;
                if (cVar7 != cVar14) {
                  bVar6 = bVar16;
                }
                bVar16 = bVar6;
                iVar10 = iVar10 + 1;
                if (iVar10 == iVar8) goto LAB_08086477;
              }
              iVar10 = iVar10 + 1;
            } while (iVar10 != iVar8);
          }
LAB_08086477:
          if (bVar16) {
            rr.y1 = 0x7fffffff;
            rr.x1 = 0x7fffffff;
            rr.y2 = -0x80000000;
            iVar8 = PCB->Bloat + 2 + ((line_s *)l->layer)->line->Thickness / 2;
            rr.x2 = -0x80000000;
            add_line_to_rect(&rr,(line_s *)l->layer);
            add_line_to_rect(&rr,c_01->lines[1]);
            if (c_01->x == rr.x1) {
              rr.x2 = rr.x2 + iVar8;
            }
            else {
              rr.x1 = rr.x1 - iVar8;
            }
            if (c_01->y == rr.y1) {
              rr.y2 = rr.y2 + iVar8;
            }
            else {
              rr.y1 = rr.y1 - iVar8;
            }
            rp.y1 = 0x7fffffff;
            rp.x1 = 0x7fffffff;
            rp.y2 = -0x80000000;
            rp.x2 = -0x80000000;
            c_02 = corners;
            if (corners == (corner_s *)0x0) break;
            do {
              while (((iVar8 = c_02->layer, iVar8 != -0x21524111 && (c_02->net != c_01->net)) &&
                     ((iVar10 = c_01->layer, iVar10 == -1 ||
                      (((iVar8 == -1 || (iVar8 == iVar10)) ||
                       (layer_groupings[iVar8] == layer_groupings[iVar10]))))))) {
                add_corner_to_rect_if(&rp,c_02,&rr);
                c_02 = c_02->next;
                if (c_02 == (corner_s *)0x0) goto LAB_0808661d;
              }
              c_02 = c_02->next;
            } while (c_02 != (corner_s *)0x0);
LAB_0808661d:
            if (rp.x2 < rp.x1) break;
          }
        }
      }
LAB_08086488:
      c_01 = c_01->next;
joined_r0x08086520:
      if (c_01 == (corner_s *)0x0) goto LAB_08086493;
      goto LAB_08086240;
    }
LAB_08086493:
    iVar8 = simple_optimizations();
    if (iVar8 + local_64 == 0) goto LAB_080864ae;
    local_68 = local_68 + 1;
    local_70 = local_70 + iVar8 + local_64;
    l = lines;
    if (local_68 == 100) {
LAB_080864ae:
      if (local_70 != 0) {
        uVar11 = 0x8154f68;
        if (local_70 == 1) {
          uVar11 = 0x815d9c5;
        }
        __printf_chk(1,"%d unjagg%s    \n",local_70,uVar11);
      }
      return local_70;
    }
  } while( true );
  if (c_01->x == c->x) {
    move_corner(c_01,c_00->x,c->y);
  }
  else {
    move_corner(c_01,c->x,c_00->y);
  }
  c_01 = c_01->next;
  local_64 = local_64 + 1;
  goto joined_r0x08086236;
}



int viatrim(void)

{
  line_s **pplVar1;
  corner_s *pcVar2;
  corner_s *pcVar3;
  int iVar4;
  DataTypePtr *pDVar5;
  Cardinal CVar6;
  Cardinal CVar7;
  LineType *Ptr2;
  LineType *pLVar8;
  Cardinal CVar9;
  Cardinal CVar10;
  bool bVar11;
  line_s *plVar12;
  int iVar13;
  LineType *pLVar14;
  line_s *plVar15;
  Cardinal *pCVar16;
  LineType *pLVar17;
  int iVar18;
  bool bVar19;
  int local_50;
  rect_s lr;
  rect_s r;
  
  plVar12 = lines;
  if (lines == (line_s *)0x0) {
    iVar18 = simple_optimizations();
    local_50 = 0;
  }
  else {
    do {
      if (((plVar12->layer != -0x21524111) && (plVar12->line != (LineType *)0x0)) &&
         ((*(byte *)&(plVar12->line->Flags).f & 0x40) != 0)) {
        bVar11 = true;
        goto LAB_08086827;
      }
      pplVar1 = &plVar12->next;
      plVar12 = *pplVar1;
    } while (*pplVar1 != (line_s *)0x0);
    bVar11 = false;
LAB_08086827:
    local_50 = 0;
    plVar12 = lines;
LAB_08086830:
    do {
      if (((plVar12->layer == -0x21524111) || (pcVar2 = plVar12->s, pcVar2->via == (PinType *)0x0))
         || (pcVar3 = plVar12->e, pcVar3->via == (PinType *)0x0)) {
LAB_08086a08:
        plVar12 = plVar12->next;
      }
      else {
        if (bVar11) {
          if ((*(byte *)&(plVar12->line->Flags).f & 0x40) == 0) {
            plVar12 = plVar12->next;
            if (plVar12 == (line_s *)0x0) break;
            goto LAB_08086830;
          }
        }
        else {
          if ((autorouted_only != 0) && (-1 < *(char *)&(plVar12->line->Flags).f))
          goto LAB_08086a08;
        }
        if (pcVar2->n_lines < 1) {
LAB_08086a70:
          if (pcVar3->n_lines < 1) {
            iVar18 = -1;
          }
          else {
            iVar18 = -1;
            iVar13 = 0;
            do {
              if (pcVar3->lines[iVar13] != plVar12) {
                if (iVar18 == -1) {
                  iVar18 = pcVar2->lines[iVar13]->layer;
                }
                else {
                  iVar4 = pcVar3->lines[iVar13]->layer;
                  bVar19 = iVar4 != iVar18;
                  iVar18 = iVar4;
                  if (bVar19) goto LAB_08086a08;
                }
              }
              iVar13 = iVar13 + 1;
            } while (iVar13 < pcVar3->n_lines);
          }
        }
        else {
          iVar18 = -1;
          iVar13 = 0;
          while( true ) {
            plVar15 = pcVar2->lines[iVar13];
            if (plVar15 != plVar12) {
              if (iVar18 == -1) {
                iVar18 = plVar15->layer;
              }
              else {
                bVar19 = plVar15->layer != iVar18;
                iVar18 = plVar15->layer;
                if (bVar19) goto LAB_08086a70;
              }
            }
            if (pcVar2->n_lines <= iVar13 + 1) break;
            iVar13 = iVar13 + 1;
          }
          if (iVar18 == -1) goto LAB_08086a70;
        }
        r.y1 = 0x7fffffff;
        r.x1 = 0x7fffffff;
        r.y2 = -0x80000000;
        r.x2 = -0x80000000;
        add_point_to_rect(&r,pcVar2->x,pcVar2->y,plVar12->line->Thickness);
        add_point_to_rect(&r,plVar12->e->x,plVar12->e->y,plVar12->line->Thickness);
        plVar15 = lines;
        while (plVar15 != (line_s *)0x0) {
          if (((plVar15->layer != -0x21524111) &&
              (pcVar2 = plVar15->s, pcVar2->net != plVar12->s->net)) && (iVar18 == plVar15->layer))
          {
            lr.y1 = 0x7fffffff;
            lr.x1 = 0x7fffffff;
            lr.y2 = -0x80000000;
            lr.x2 = -0x80000000;
            add_point_to_rect(&lr,pcVar2->x,pcVar2->y,plVar15->line->Thickness / 2);
            add_point_to_rect(&lr,plVar15->e->x,plVar15->e->y,plVar15->line->Thickness / 2);
            if (lr.x1 < r.x1) {
              lr.x1 = r.x1;
            }
            if (r.x2 < lr.x2) {
              lr.x2 = r.x2;
            }
            if (lr.y1 < r.y1) {
              lr.y1 = r.y1;
            }
            if (r.y2 < lr.y2) {
              lr.y2 = r.y2;
            }
            if ((lr.x1 < lr.x2) && (lr.y1 < lr.y2)) goto LAB_08086a08;
          }
          plVar15 = plVar15->next;
        }
        iVar13 = plVar12->layer;
        if (iVar13 == iVar18) goto LAB_08086a08;
        pDVar5 = PCB->Data;
        pCVar16 = &pDVar5->ViaN + iVar18 * 0x17;
        CVar6 = (&pDVar5->ViaN + iVar13 * 0x17)[0x14];
        CVar7 = (&pDVar5->ViaN + iVar13 * 0x17)[0x1c];
        Ptr2 = plVar12->line;
        pLVar8 = (LineType *)pCVar16[0x1c];
        CVar9 = pCVar16[0x14];
        pLVar14 = (LineType *)
                  MoveObjectToLayer(4,(void *)(&pDVar5->field_0x4c + iVar13 * 0x5c),Ptr2,(void *)0x0
                                    ,(LayerTypePtr)(&pDVar5->field_0x4c + iVar18 * 0x5c),'\0');
        CVar10 = pCVar16[0x1c];
        if (lines != (line_s *)0x0) {
          plVar15 = lines;
          do {
            if (plVar15->layer != -0x21524111) {
              pLVar17 = plVar15->line;
              if ((LineType *)((CVar6 - 1) * 0x58 + CVar7) == plVar15->line) {
                plVar15->line = Ptr2;
                pLVar17 = Ptr2;
              }
              if ((pLVar8 <= pLVar17) && (pLVar17 < pLVar8 + CVar9)) {
                plVar15->line =
                     (LineType *)
                     ((int)&(pLVar17->BoundingBox).X1 + (CVar10 - (int)pLVar8 & 0xfffffff8));
              }
            }
            plVar15 = plVar15->next;
          } while (plVar15 != (line_s *)0x0);
        }
        plVar12->layer = iVar18;
        local_50 = local_50 + 1;
        plVar12->line = pLVar14;
        plVar12 = plVar12->next;
      }
    } while (plVar12 != (line_s *)0x0);
    iVar18 = simple_optimizations();
    if (local_50 != 0) {
      __printf_chk(1,"viatrim: %d traces moved, %d vias removed\n",local_50,iVar18);
    }
  }
  return iVar18 + local_50;
}



int orthopull(void)

{
  line_s **pplVar1;
  corner_s *pcVar2;
  corner_s *pcVar3;
  line_s *plVar4;
  int iVar5;
  corner_s *c;
  int iVar6;
  int any_sel;
  
  plVar4 = lines;
  if (lines != (line_s *)0x0) {
    do {
      if (((plVar4->layer != -0x21524111) && (plVar4->line != (LineType *)0x0)) &&
         ((*(byte *)&(plVar4->line->Flags).f & 0x40) != 0)) {
        any_sel = 1;
        goto LAB_08086c4a;
      }
      pplVar1 = &plVar4->next;
      plVar4 = *pplVar1;
    } while (*pplVar1 != (line_s *)0x0);
  }
  any_sel = 0;
LAB_08086c4a:
  iVar6 = 0;
  pcVar3 = corners;
LAB_08086c62:
  c = pcVar3;
  if (c == (corner_s *)0x0) {
    if (iVar6 != 0) {
      __printf_chk(1,"orthopull: %d mils saved\n",iVar6 / 100);
    }
    return iVar6;
  }
  if (c->layer == -0x21524111) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if ((c->pin == (PinType *)0x0) && (c->pad == (PadType *)0x0)) goto code_r0x08086c82;
  goto LAB_08086c5f;
code_r0x08086c82:
  next_corner = c;
  iVar5 = orthopull_1(c,0x12,0x11,any_sel);
  pcVar2 = next_corner;
  iVar6 = iVar6 + iVar5;
  pcVar3 = next_corner;
  if (next_corner == c) {
    iVar5 = orthopull_1(c,0x28,0x24,any_sel);
    iVar6 = iVar6 + iVar5;
    pcVar3 = next_corner;
    c = next_corner;
    if (pcVar2 == next_corner) {
LAB_08086c5f:
      pcVar3 = c->next;
    }
  }
  goto LAB_08086c62;
}



void register_djopt_action_list(void)

{
  hid_register_actions(djopt_action_list,2);
  return;
}



void register_djopt_flag_list(void)

{
  hid_register_flags(djopt_flag_list,1);
  return;
}



// WARNING: Removing unreachable block (ram,0x08086f34)
// WARNING: Removing unreachable block (ram,0x08086f30)
// WARNING: Could not reconcile some variable overlaps

int vianudge(void)

{
  corner_s **ppcVar1;
  uchar uVar2;
  corner_s *pcVar3;
  int y2;
  int x2;
  int x1;
  double dVar4;
  double dVar5;
  int y1;
  int y2_00;
  byte bVar6;
  byte bVar7;
  int y1_00;
  corner_s *c;
  line_s *l;
  int iVar8;
  corner_s *c_00;
  int in_GS_OFFSET;
  int local_78;
  int local_74;
  corner_s *local_70;
  int local_6c;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  uchar counts [16];
  uchar directions [16];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  directions._0_4_ = 0;
  directions._4_4_ = 0;
  directions._8_4_ = 0;
  directions._12_4_ = 0;
  counts._0_4_ = 0;
  counts._4_4_ = 0;
  counts._8_4_ = 0;
  counts._12_4_ = 0;
  local_6c = 0;
  c = corners;
  if (corners != (corner_s *)0x0) {
    do {
      if ((c->layer != -0x21524111) && (c->via != (PinType *)0x0)) {
        directions._0_4_ = 0;
        directions._4_4_ = 0;
        directions._8_4_ = 0;
        directions._12_4_ = 0;
        counts._0_4_ = 0;
        counts._4_4_ = 0;
        counts._8_4_ = 0;
        counts._12_4_ = 0;
        if (0 < c->n_lines) {
          iVar8 = 0;
          do {
            l = c->lines[iVar8];
            c_00 = l->s;
            if (c == c_00) {
              local_58 = c->x;
              local_5c = c->y;
              local_64 = l->e->x;
              local_60 = l->e->y;
            }
            else {
              local_58 = l->e->x;
              local_5c = l->e->y;
              local_64 = c_00->x;
              local_60 = c_00->y;
            }
            if (local_58 == local_64) {
              bVar6 = (local_5c < local_60) * '\x04' + 0x24;
            }
            else {
              bVar6 = 0xf0;
              if (local_5c == local_60) {
                bVar6 = (local_58 < local_64) + 0x11;
              }
            }
            y1 = iVar8 + 1;
            counts[l->layer] = counts[l->layer] + '\x01';
            directions[c->lines[iVar8]->layer] = directions[c->lines[iVar8]->layer] | bVar6;
            iVar8 = y1;
          } while (c->n_lines != y1 && y1 <= c->n_lines);
        }
        iVar8 = PCB->Data->LayerN;
        if (0 < iVar8) {
          y1 = 0;
          uVar2 = counts[0];
          while (uVar2 != '\x01') {
            if (iVar8 <= y1 + 1) goto LAB_08087050;
            uVar2 = counts[y1 + 1];
            y1 = y1 + 1;
          }
          bVar6 = directions[y1];
          if (bVar6 == 0x24) {
LAB_08087173:
            bVar7 = 0x2c;
LAB_08087135:
            y1 = 0;
            while( true ) {
              if (((counts[0] != '\0') && (bVar6 != directions[y1])) && (bVar7 != directions[y1]))
              goto LAB_08087050;
              if (iVar8 <= y1 + 1) break;
              counts[0] = counts[y1 + 1];
              y1 = y1 + 1;
            }
            if (c->n_lines < 1) {
              local_5c = 0;
              local_74 = 0;
              local_70 = (corner_s *)0x0;
            }
            else {
              local_5c = 0;
              iVar8 = 0;
              local_74 = 0;
              local_70 = (corner_s *)0x0;
              do {
                while( true ) {
                  y1 = line_length(c->lines[iVar8]);
                  l = c->lines[iVar8];
                  c_00 = l->s;
                  if (c == c_00) {
                    local_78 = c->x;
                    local_60 = c->y;
                    y2_00 = l->e->x;
                    local_64 = l->e->y;
                  }
                  else {
                    local_78 = l->e->x;
                    local_60 = l->e->y;
                    y2_00 = c_00->x;
                    local_64 = c_00->y;
                  }
                  if (local_78 == y2_00) break;
                  bVar7 = 0xf0;
                  if (local_60 == local_64) {
                    bVar7 = (local_78 < y2_00) + 0x11;
                  }
                  if (bVar6 == bVar7) goto LAB_08087216;
LAB_080871b6:
                  local_5c = local_5c + -1;
LAB_080871ba:
                  iVar8 = iVar8 + 1;
                  if (c->n_lines == iVar8 || c->n_lines < iVar8) goto LAB_08087241;
                }
                if (bVar6 != (byte)((local_60 < local_64) * '\x04' + 0x24U)) goto LAB_080871b6;
LAB_08087216:
                local_5c = local_5c + 1;
                if ((local_74 <= y1) && (local_70 != (corner_s *)0x0)) goto LAB_080871ba;
                iVar8 = iVar8 + 1;
                local_70 = other_corner(l,c);
                local_74 = y1;
              } while (c->n_lines != iVar8 && iVar8 <= c->n_lines);
            }
LAB_08087241:
            if (((local_70->pad == (PadType *)0x0) && (local_70->pin == (PinType *)0x0)) &&
               (local_70->via == (PinType *)0x0)) {
              iVar8 = PCB->Bloat + 2 + c->via->Thickness / 2;
              c_00 = corners;
              while (l = lines, c_00 != (corner_s *)0x0) {
                if ((c_00->layer != -0x21524111) &&
                   (((c_00->net != c->net &&
                     ((c_00->pin != (PinType *)0x0 || (c_00->via != (PinType *)0x0)))) ||
                    (c_00->pad != (PadType *)0x0)))) {
                  y1 = corner_radius(c_00);
                  y2_00 = dist(local_70->x,local_70->y,c_00->x,c_00->y);
                  if (y2_00 < y1 + iVar8) goto LAB_08087050;
                }
                c_00 = c_00->next;
              }
              while (l != (line_s *)0x0) {
                if ((l->layer != -0x21524111) && (c_00 = l->s, c_00->net != c->net)) {
                  pcVar3 = l->e;
                  y1 = c_00->x;
                  y2_00 = pcVar3->x;
                  if (y1 == y2_00) {
                    y1 = dist_ltp2(y1 - local_70->x,local_70->y,c_00->y,pcVar3->y);
                  }
                  else {
                    y1_00 = c_00->y;
                    if (y1_00 == pcVar3->y) {
                      y1 = dist_ltp2(y1_00 - local_70->y,local_70->x,y1,y2_00);
                    }
                    else {
                      y1_00 = y1_00 - pcVar3->y;
                      dVar4 = SQRT((double)(y1_00 * y1_00 + (y1 - y2_00) * (y1 - y2_00)));
                      if (dVar4 == 0.00000000) {
                        y1 = dist(c_00->x,c_00->y,local_70->x,local_70->y);
                      }
                      else {
                        y1 = c_00->y;
                        y2_00 = c_00->x;
                        y1_00 = l->e->y;
                        y2 = local_70->y;
                        x2 = local_70->x;
                        x1 = l->e->x;
                        dVar5 = (double)((y2_00 - x1) * (y2_00 - x2) + (y1 - y1_00) * (y1 - y2)) /
                                (dVar4 * dVar4);
                        if (dVar5 < 0.00000000) {
                          y1 = dist(y2_00,y1,x2,y2);
                        }
                        else {
                          if (1.00000000 < dVar5) {
                            y1 = dist(x1,y1_00,x2,y2);
                          }
                          else {
                            y1 = (int)ROUND((double)((y2 - y1) * (x1 - y2_00) +
                                                    y2_00 * x2 * (y1_00 - y1)) / dVar4);
                          }
                        }
                      }
                    }
                  }
                  if (y1 < l->line->Thickness / 2 + iVar8) goto LAB_08087050;
                }
                l = l->next;
              }
              local_6c = local_6c + local_5c * local_74;
              move_corner(c,local_70->x,local_70->y);
            }
          }
          else {
            if (bVar6 < 0x25) {
              if ((byte)(bVar6 - 0x11) < 2) {
                bVar7 = 0x13;
                goto LAB_08087135;
              }
            }
            else {
              if (bVar6 == 0x28) goto LAB_08087173;
            }
          }
        }
      }
LAB_08087050:
      ppcVar1 = &c->next;
      c = *ppcVar1;
    } while (*ppcVar1 != (corner_s *)0x0);
    if (local_6c != 0) {
      __printf_chk(1,"vianudge: %d mils saved\n",local_6c / 100);
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_6c;
}



// WARNING: Type propagation algorithm not settling

int ActionDJopt(int argc,char **argv,int x,int y)

{
  Cardinal CVar1;
  uint uVar2;
  line_s *l;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int y_00;
  corner_s *c1;
  corner_s *c;
  int x2;
  int y2;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  DataTypePtr *pDVar10;
  line_s *l_00;
  corner_s *c_00;
  LineType *pLVar11;
  PadTypePtr *pPVar12;
  uint *puVar13;
  Cardinal *pCVar14;
  PCBTypePtr pPVar15;
  byte bVar16;
  PinType *pPVar17;
  LineTypePtr Line;
  ElementTypePtr *pEVar18;
  byte bVar19;
  Cardinal CVar20;
  uint uVar21;
  PadType *pPVar22;
  PinTypePtr *pPVar23;
  uint *puVar24;
  uint uVar25;
  corner_s *c_01;
  char *local_e4;
  int local_e0;
  corner_s *local_d8;
  PCBTypePtr local_d4;
  corner_s *local_d0;
  corner_s *local_cc;
  int local_c8;
  PCBTypePtr local_c4;
  int local_c0;
  corner_s *best_c [17];
  int best_dist [17];
  rect_s r;
  
  local_e4 = (char *)0x0;
  if (0 < argc) {
    local_e4 = *argv;
  }
  hid_action("Busy");
  pPVar15 = PCB;
  lines = (line_s *)0x0;
  corners = (corner_s *)0x0;
  component_layer = -1;
  pDVar10 = PCB->Data;
  local_d4 = PCB;
  solder_layer = -1;
  if (0 < pDVar10->LayerN) {
    y_00 = 0;
    do {
      layer_type[y_00] = '\0';
      pDVar10 = pPVar15->Data;
      layer_groupings[y_00] = 0;
      y_00 = y_00 + 1;
      uVar25 = pDVar10->LayerN;
    } while (y_00 < (int)uVar25);
    if (0 < (int)uVar25) {
      local_c0 = 0;
      local_cc = (corner_s *)component_layer;
      local_d0 = (corner_s *)solder_layer;
      do {
        CVar1 = (pPVar15->LayerGroups).Number[local_c0];
        if (CVar1 != 0) {
          puVar13 = (pPVar15->LayerGroups).Entries + local_c0 * 0x12;
          bVar19 = 0;
          CVar20 = 0;
          puVar24 = puVar13;
          do {
            if (*puVar24 == uVar25) {
              bVar19 = bVar19 | 2;
            }
            if (*puVar24 == uVar25 + 1) {
              bVar19 = bVar19 | 1;
            }
            CVar20 = CVar20 + 1;
            puVar24 = puVar24 + 1;
          } while (CVar20 != CVar1);
          uVar21 = 0;
          while( true ) {
            if (*puVar13 < uVar25) {
              layer_type[*puVar13] = layer_type[*puVar13] | bVar19;
              layer_groupings[*puVar13] = local_c0;
              if ((local_d0 == (corner_s *)0xffffffff) && (bVar19 == 2)) {
                local_d0 = (corner_s *)*puVar13;
              }
              if ((local_cc == (corner_s *)0xffffffff) && (bVar19 == 1)) {
                local_cc = (corner_s *)*puVar13;
              }
              pDVar10 = pPVar15->Data;
              uVar25 = pDVar10->LayerN;
            }
            uVar21 = uVar21 + 1;
            puVar13 = puVar13 + 1;
            if ((pPVar15->LayerGroups).Number[local_c0] <= uVar21) break;
            pDVar10 = pPVar15->Data;
            uVar25 = pDVar10->LayerN;
          }
        }
        local_c0 = local_c0 + 1;
      } while (local_c0 < (int)uVar25);
      solder_layer = (int)local_d0;
      component_layer = (int)local_cc;
    }
  }
  local_d0 = (corner_s *)(pDVar10->ElementN - 1);
  if (local_d0 != (corner_s *)0xffffffff) {
    y_00 = pDVar10->ElementN * 300;
    do {
      local_d4 = (PCBTypePtr)(y_00 + -300);
      y_00 = (int)&pDVar10->Element[-1].BoundingBox.X1 + y_00;
      if (*(uint *)(y_00 + 0xe0) != 0) {
        uVar21 = 0;
        uVar25 = *(uint *)(y_00 + 0xe0);
        do {
          pPVar17 = (PinType *)(uVar21 * 0x4c + *(int *)(y_00 + 0x100));
          c1 = find_corner(pPVar17->X,pPVar17->Y,-1);
          c1->pin = pPVar17;
          uVar2 = *(uint *)(y_00 + 0xe0);
          if (uVar2 == 0) break;
          uVar21 = (uVar2 + 1 + uVar21) - uVar25;
          uVar25 = uVar2;
        } while (uVar21 < uVar2);
      }
      local_c8 = 0;
      local_c4 = (PCBTypePtr)0x0;
      uVar25 = *(uint *)(y_00 + 0xe8);
      uVar21 = uVar25;
      while ((uVar21 != 0 && (local_c4 < uVar21))) {
        pPVar22 = (PadType *)(local_c8 + *(int *)(y_00 + 0x104));
        x2 = solder_layer;
        if (-1 < *(char *)&(pPVar22->Flags).f) {
          x2 = component_layer;
        }
        l_00 = (line_s *)malloc(0x14);
        y2 = (pPVar22->Point1).Y;
        l_00->next = lines;
        lines = l_00;
        c1 = find_corner((pPVar22->Point1).X,y2,x2);
        y2 = (pPVar22->Point2).Y;
        l_00->s = c1;
        c1->pad = pPVar22;
        c = find_corner((pPVar22->Point2).X,y2,x2);
        c1 = l_00->s;
        l_00->layer = x2;
        *(PadType **)&l_00->line = pPVar22;
        l_00->e = c;
        c->pad = pPVar22;
        add_line_to_corner(l_00,c1);
        l_00->layer = x2;
        *(PadType **)&l_00->line = pPVar22;
        add_line_to_corner(l_00,l_00->s);
        add_line_to_corner(l_00,l_00->e);
        uVar21 = *(uint *)(y_00 + 0xe8);
        if (*(uint *)(y_00 + 0xe8) == uVar25) {
          local_c4 = (PCBTypePtr)((int)local_c4 + 1);
          local_c8 = local_c8 + 0x68;
          uVar21 = uVar25;
        }
      }
      local_d0 = (corner_s *)((int)local_d0 + -1);
      if (local_d0 == (corner_s *)0xffffffff) goto LAB_080877e2;
      pDVar10 = PCB->Data;
      y_00 = (int)local_d4;
    } while( true );
  }
LAB_080877f4:
  if (pDVar10->ViaN != 0) {
    uVar21 = 0;
    uVar25 = pDVar10->ViaN;
    do {
      pPVar23 = pDVar10->Via + uVar21;
      c1 = find_corner(pPVar23->X,pPVar23->Y,-1);
      local_d4 = PCB;
      pDVar10 = PCB->Data;
      *(PinTypePtr **)&c1->via = pPVar23;
      uVar2 = pDVar10->ViaN;
      if (uVar2 == 0) break;
      uVar21 = (uVar2 + 1 + uVar21) - uVar25;
      uVar25 = uVar2;
    } while (uVar21 < uVar2);
  }
  if ((local_e4 == (char *)0x0) || (y_00 = strcmp(local_e4,"splitlines"), y_00 != 0)) {
    local_c0 = 0;
    pDVar10 = local_d4->Data;
    if (0 < pDVar10->LayerN) {
      do {
        pCVar14 = &pDVar10->ViaN + local_c0 * 0x17;
        if (pCVar14[0x14] != 0) {
          uVar25 = 0;
          do {
            Line = (LineTypePtr)(uVar25 * 0x58 + pCVar14[0x1c]);
            if ((*(byte *)((int)&(Line->Flags).f + 1) & 4) == 0) {
              if (((Line->Point1).X == (Line->Point2).X) && ((Line->Point1).Y == (Line->Point2).Y))
              {
                uVar25 = uVar25 - 1;
                RemoveLine((LayerTypePtr)(&pDVar10->field_0x4c + local_c0 * 0x5c),Line);
              }
              else {
                l_00 = (line_s *)malloc(0x14);
                y_00 = (Line->Point1).Y;
                l_00->next = lines;
                lines = l_00;
                c1 = find_corner((Line->Point1).X,y_00,local_c0);
                y_00 = (Line->Point2).Y;
                l_00->s = c1;
                c1 = find_corner((Line->Point2).X,y_00,local_c0);
                *(LineTypePtr *)&l_00->line = Line;
                l_00->e = c1;
                add_line_to_corner(l_00,l_00->s);
                add_line_to_corner(l_00,l_00->e);
                l_00->layer = local_c0;
              }
            }
            uVar25 = uVar25 + 1;
            local_d4 = PCB;
          } while (uVar25 < pCVar14[0x14]);
        }
        pDVar10 = local_d4->Data;
        local_c0 = local_c0 + 1;
      } while (pDVar10->LayerN != local_c0 && local_c0 <= pDVar10->LayerN);
    }
    local_c0 = 0;
    local_d0 = (corner_s *)0x0;
    local_c8 = 0;
    local_c4 = (PCBTypePtr)0x0;
    local_cc = (corner_s *)0x0;
    c = corners;
    c1 = corners;
    do {
      if (c1 == (corner_s *)0x0) goto LAB_08087a0f;
      bVar3 = false;
      c_00 = c;
      local_d8 = c1;
      do {
        c = local_d8;
        if (c1->layer != -0x21524111) {
          local_d4 = (PCBTypePtr)c1->pin;
          if ((local_d4 == (PCBTypePtr)0x0) &&
             (local_d4 = (PCBTypePtr)c1->via, local_d4 == (PCBTypePtr)0x0)) {
            if (c1->pad == (PadType *)0x0) goto LAB_08087d08;
            pPVar22 = c1->pad;
            if (pPVar22 != (PadType *)0x0) {
              y_00 = (pPVar22->Point1).X;
              local_c0 = pPVar22->Thickness / 2 + 1;
              x2 = (pPVar22->Point2).X;
              y2 = x2;
              if (y_00 <= x2) {
                y2 = y_00;
              }
              local_cc = (corner_s *)(y2 - local_c0);
              y2 = x2;
              if (x2 <= y_00) {
                y2 = y_00;
              }
              y2 = y2 + local_c0;
              iVar6 = (pPVar22->Point2).Y;
              iVar7 = (pPVar22->Point1).Y;
              iVar8 = iVar6;
              if (iVar7 <= iVar6) {
                iVar8 = iVar7;
              }
              local_d0 = (corner_s *)(iVar8 - local_c0);
              iVar8 = iVar6;
              if (iVar6 <= iVar7) {
                iVar8 = iVar7;
              }
              iVar8 = iVar8 + local_c0;
              local_c8 = iVar8;
              local_c4 = (PCBTypePtr)y2;
              if (x2 == y_00) {
                local_c8 = (iVar7 + iVar6) / 2;
                if (local_c8 <= c1->y) {
                  local_d0 = (corner_s *)(local_c8 + 1);
                  local_c8 = iVar8;
                }
              }
              else {
                local_c4 = (PCBTypePtr)((y_00 + x2) / 2);
                if ((int)local_c4 <= c1->x) {
                  local_cc = (corner_s *)((int)local_c4 + 1);
                  local_c4 = (PCBTypePtr)y2;
                }
              }
            }
          }
          else {
            local_c0 = ((PinType *)local_d4)->Thickness / 2;
            local_cc = (corner_s *)(c1->x - local_c0);
            local_d0 = (corner_s *)(c1->y - local_c0);
            local_c8 = c1->y + local_c0;
            local_c4 = (PCBTypePtr)(c1->x + local_c0);
          }
          y_00 = PCB->Data->LayerN;
          if (-1 < y_00) {
            x2 = 0;
            do {
              best_dist[x2] = local_c0 * 2;
              best_c[x2] = (corner_s *)0x0;
              x2 = x2 + 1;
            } while (x2 <= y_00);
          }
          c = c_00;
          if (local_d8 != (corner_s *)0x0) {
            local_d8 = (corner_s *)0x0;
            do {
              if (c_00->layer == -0x21524111) goto LAB_08087cf5;
              y_00 = corner_radius(c_00);
              if ((((c1 == c_00) || (c_00->n_lines == 0)) || (c_00->pin != (PinType *)0x0)) ||
                 ((c_00->pad != (PadType *)0x0 || (c_00->via != (PinType *)0x0)))) {
LAB_08087cd8:
                if (((local_d8 == (corner_s *)0x0) &&
                    (c1->n_lines == (uint)(c1->pad != (PadType *)0x0))) && (-1 < PCB->Data->LayerN))
                {
                  y_00 = 0;
                  pPVar15 = PCB;
                  do {
                    if (best_c[y_00] != (corner_s *)0x0) {
                      connect_corners(best_c[y_00],c1);
                      bVar3 = true;
                      pPVar15 = PCB;
                    }
                    y_00 = y_00 + 1;
                  } while (y_00 <= pPVar15->Data->LayerN);
                }
              }
              else {
                x2 = c_00->layer;
                y2 = c1->layer;
                if ((((x2 != -1) && ((y2 != -1 && (x2 != y2)))) &&
                    (layer_groupings[y2] != layer_groupings[x2])) ||
                   ((((x2 = c_00->x, x2 < (int)local_cc - y_00 || (y_00 + (int)local_c4 < x2)) ||
                     (y2 = c_00->y, y2 < (int)local_d0 - y_00)) || (y_00 + local_c8 < y2))))
                goto LAB_08087cd8;
                x2 = dist(c1->x,c1->y,x2,y2);
                if ((local_d4 == (PCBTypePtr)0x0) ||
                   (x2 <= y_00 + ((PinType *)local_d4)->Thickness / 2)) {
                  y_00 = c_00->n_lines;
                  if (y_00 != 1) {
                    y2 = c_00->layer;
                    if (((best_c[y2] == (corner_s *)0x0) ||
                        (iVar6 = best_c[y2]->n_lines, y_00 < iVar6)) ||
                       ((x2 < best_dist[y2] && (y_00 <= iVar6)))) {
                      best_c[y2] = c_00;
                      best_dist[y2] = x2;
                    }
                    goto LAB_08087cd8;
                  }
                  local_d8 = (corner_s *)((int)local_d8 + 1);
                  connect_corners(c1,c_00);
                  bVar3 = true;
                }
              }
LAB_08087cf5:
              c_00 = c_00->next;
            } while (c_00 != (corner_s *)0x0);
            local_d8 = corners;
            c = corners;
          }
        }
LAB_08087d08:
        c1 = c1->next;
        c_00 = local_d8;
      } while (c1 != (corner_s *)0x0);
      c1 = local_d8;
      l_00 = lines;
    } while (bVar3);
    while (lines = l_00, c1 != (corner_s *)0x0) {
      if (((c1->layer != -0x21524111) && (c1->pin == (PinType *)0x0)) &&
         ((c1->via == (PinType *)0x0 && ((c1->pad == (PadType *)0x0 && (c1->n_lines == 1)))))) {
        l = *c1->lines;
        c = l->s;
        if (c1 == c) {
          y_00 = c1->x;
          x2 = c1->y;
          y2 = l->e->x;
          iVar6 = l->e->y;
        }
        else {
          y_00 = l->e->x;
          x2 = l->e->y;
          y2 = c->x;
          iVar6 = c->y;
        }
        if (y_00 == y2) {
          bVar19 = (x2 < iVar6) * '\x04' + 0x24;
        }
        else {
          bVar19 = 0xf0;
          if (x2 == iVar6) {
            bVar19 = (y_00 < y2) + 0x11;
          }
        }
        while (l_00 != (line_s *)0x0) {
          if ((l_00->layer != -0x21524111) && (l_00->layer == (*c1->lines)->layer)) {
            if (bVar19 == 0x12) {
              c = l_00->e;
              local_c4 = (PCBTypePtr)l_00->s->x;
              if (((local_c4 == (PCBTypePtr)c->x) && ((int)local_c4 < c1->x)) &&
                 (c1->x - (l_00->line->Thickness + l->line->Thickness) / 2 < (int)local_c4)) {
                x2 = l_00->s->y;
                y_00 = c1->y;
                if (((x2 < y_00) && (y_00 < c->y)) || ((c->y < y_00 && (y_00 < x2)))) {
LAB_08088b13:
                  move_corner(c1,(int)local_c4,y_00);
                }
              }
            }
            else {
              if (bVar19 < 0x13) {
                if (bVar19 == 0x11) {
                  c = l_00->e;
                  local_c4 = (PCBTypePtr)l_00->s->x;
                  if (((local_c4 == (PCBTypePtr)c->x) && (c1->x < (int)local_c4)) &&
                     ((int)local_c4 < (l_00->line->Thickness + l->line->Thickness) / 2 + c1->x)) {
                    x2 = l_00->s->y;
                    y_00 = c1->y;
                    if (x2 < y_00) {
                      y2 = c->y;
                      if (y_00 < y2) goto LAB_08088b13;
                    }
                    else {
                      y2 = c->y;
                    }
                    if ((y2 < y_00) && (y_00 < x2)) goto LAB_08088b13;
                  }
                }
              }
              else {
                if (bVar19 == 0x24) {
                  local_cc = l_00->s;
                  local_c4 = (PCBTypePtr)l_00->e;
                  local_d8 = (corner_s *)local_cc->y;
                  if (((local_d8 == (corner_s *)((corner_s *)local_c4)->y) &&
                      (c1->y < (int)local_d8)) &&
                     ((int)local_d8 < (l_00->line->Thickness + l->line->Thickness) / 2 + c1->y)) {
LAB_08088e57:
                    y_00 = c1->x;
                    if (((local_cc->x < y_00) && (y_00 < ((corner_s *)local_c4)->x)) ||
                       ((((corner_s *)local_c4)->x < y_00 && (y_00 < local_cc->x)))) {
                      move_corner(c1,y_00,(int)local_d8);
                    }
                  }
                }
                else {
                  if (bVar19 == 0x28) {
                    local_cc = l_00->s;
                    local_c4 = (PCBTypePtr)l_00->e;
                    local_d8 = (corner_s *)local_cc->y;
                    if (((local_d8 == (corner_s *)((corner_s *)local_c4)->y) &&
                        ((int)local_d8 < c1->y)) &&
                       (c1->y - (l_00->line->Thickness + l->line->Thickness) / 2 < (int)local_d8))
                    goto LAB_08088e57;
                  }
                }
              }
            }
          }
          l_00 = l_00->next;
        }
      }
      l_00 = lines;
      c1 = c1->next;
    }
LAB_08087a0f:
    do {
      c1 = corners;
      if (lines == (line_s *)0x0) break;
      y_00 = 0;
      l_00 = lines;
      do {
        if (l_00->layer != -0x21524111) {
          x2 = canonicalize_line(l_00);
          y_00 = y_00 + x2;
        }
        l_00 = l_00->next;
      } while (l_00 != (line_s *)0x0);
      c1 = corners;
    } while (y_00 != 0);
    while (c1 != (corner_s *)0x0) {
      while ((c1->layer != -0x21524111 && (c1->net == 0))) {
        classify_corner(c1,this_net);
        c1 = c1->next;
        this_net = this_net + 1;
        if (c1 == (corner_s *)0x0) goto LAB_08087a79;
      }
      c1 = c1->next;
    }
LAB_08087a79:
    if (local_e4 == (char *)0x0) {
LAB_08088425:
      __printf_chk(1,"unknown command: %s\n",local_e4);
      return 1;
    }
    y_00 = strcmp(local_e4,"debumpify");
    if (y_00 == 0) {
      local_e0 = debumpify();
      l_00 = lines;
    }
    else {
      y_00 = strcmp(local_e4,"unjaggy");
      if (y_00 == 0) {
        local_e0 = unjaggy();
        l_00 = lines;
      }
      else {
        y_00 = strcmp(local_e4,"simple");
        if (y_00 == 0) {
          local_e0 = simple_optimizations();
          l_00 = lines;
        }
        else {
          y_00 = strcmp(local_e4,"vianudge");
          if (y_00 == 0) {
            local_e0 = vianudge();
            l_00 = lines;
          }
          else {
            y_00 = strcmp(local_e4,"viatrim");
            if (y_00 == 0) {
              local_e0 = viatrim();
              l_00 = lines;
            }
            else {
              y_00 = strcmp(local_e4,"orthopull");
              if (y_00 == 0) {
                local_e0 = orthopull();
                l_00 = lines;
              }
              else {
                y_00 = strcmp(local_e4,"auto");
                if (y_00 == 0) {
                  x2 = 99;
                  y_00 = 1;
                  do {
                    y2 = debumpify();
                    iVar6 = unjaggy();
                    iVar7 = orthopull();
                    iVar8 = vianudge();
                    iVar9 = viatrim();
                    local_e0 = iVar6 + y2 + iVar7 + iVar8 + iVar9 + y_00;
                    if (local_e0 == y_00) break;
                    x2 = x2 + -1;
                    y_00 = local_e0;
                  } while (x2 != 0);
                  local_e0 = local_e0 + -1;
                  l_00 = lines;
                }
                else {
                  y_00 = strcmp(local_e4,"miter");
                  c1 = corners;
                  l_00 = lines;
                  if (y_00 != 0) goto LAB_08088425;
                  while (c = corners, l_00 != (line_s *)0x0) {
                    if (((l_00->layer != -0x21524111) && (l_00->line != (LineType *)0x0)) &&
                       ((*(byte *)&(l_00->line->Flags).f & 0x40) != 0)) {
                      bVar3 = true;
                      goto LAB_0808848c;
                    }
                    l_00 = l_00->next;
                  }
                  bVar3 = false;
LAB_0808848c:
                  while (c != (corner_s *)0x0) {
                    if (((c->layer != -0x21524111) && (c->miter = 0, c->n_lines == 2)) &&
                       ((c->via == (PinType *)0x0 && (c->pin == (PinType *)0x0)))) {
                      l_00 = *c->lines;
                      c_00 = l_00->s;
                      if (c == c_00) {
                        y_00 = c->x;
                        x2 = c->y;
                        local_c0 = l_00->e->x;
                        y2 = l_00->e->y;
                      }
                      else {
                        y_00 = l_00->e->x;
                        x2 = l_00->e->y;
                        local_c0 = c_00->x;
                        y2 = c_00->y;
                      }
                      if (y_00 == local_c0) {
                        bVar4 = true;
                        bVar19 = (x2 < y2) * '\x04' + 0x24;
                      }
                      else {
                        if (x2 == y2) {
                          bVar4 = true;
                          bVar19 = (y_00 < local_c0) + 0x11;
                        }
                        else {
                          bVar4 = false;
                          bVar19 = 0xf0;
                        }
                      }
                      l = c->lines[1];
                      c_00 = l->s;
                      if (c == c_00) {
                        local_c8 = c->y;
                        local_cc = (corner_s *)c->x;
                        local_c4 = (PCBTypePtr)l->e->x;
                        local_c0 = l->e->y;
                      }
                      else {
                        local_cc = (corner_s *)l->e->x;
                        local_c8 = l->e->y;
                        local_c4 = (PCBTypePtr)c_00->x;
                        local_c0 = c_00->y;
                      }
                      if ((PCBTypePtr)local_cc == local_c4) {
                        bVar16 = (local_c8 < local_c0) * '\x04' + 0x24;
                      }
                      else {
                        bVar16 = 0xf0;
                        if (local_c8 == local_c0) {
                          bVar16 = ((int)local_cc < (int)local_c4) + 0x11;
                        }
                      }
                      if (((((bVar19 ^ bVar16) & 0xf0) != 0) && (bVar4)) &&
                         ((bVar16 != 0xf0 && (l_00->line->Thickness == l->line->Thickness)))) {
                        c->miter = -1;
                      }
                    }
                    c = c->next;
                  }
                  local_e0 = 0;
                  do {
                    bVar4 = false;
                    bVar5 = true;
                    while (c1 != (corner_s *)0x0) {
                      if ((c1->layer != -0x21524111) && (c1->miter == -1)) {
                        y_00 = line_length((line_s *)((line_s *)c1->lines)->layer);
                        x2 = line_length(c1->lines[1]);
                        l_00 = (line_s *)((line_s *)c1->lines)->layer;
                        c = l_00->s;
                        if (c1 == c) {
                          iVar6 = c1->x;
                          iVar7 = c1->y;
                          local_c0 = l_00->e->x;
                          y2 = l_00->e->y;
                        }
                        else {
                          local_c0 = c->x;
                          y2 = c->y;
                          iVar6 = l_00->e->x;
                          iVar7 = l_00->e->y;
                        }
                        if (iVar6 == local_c0) {
                          uVar25 = (uint)(iVar7 < y2) * 4 + 0x24;
                        }
                        else {
                          uVar25 = 0xf0;
                          if (iVar7 == y2) {
                            uVar25 = (uint)(iVar6 < local_c0) + 0x11;
                          }
                        }
                        l = ((line_s *)c1->lines)->next;
                        c = l->s;
                        if (c1 == c) {
                          local_c4 = (PCBTypePtr)c1->x;
                          local_c0 = l->e->x;
                          iVar6 = l->e->y;
                          y2 = c1->y;
                        }
                        else {
                          local_c4 = (PCBTypePtr)l->e->x;
                          y2 = l->e->y;
                          local_c0 = c->x;
                          iVar6 = c->y;
                        }
                        if (local_c4 == (PCBTypePtr)local_c0) {
                          bVar19 = (y2 < iVar6) * '\x04' + 0x24;
                        }
                        else {
                          bVar19 = 0xf0;
                          if (y2 == iVar6) {
                            bVar19 = ((int)local_c4 < local_c0) + 0x11;
                          }
                        }
                        if (((c1->pad == (PadType *)0x0) && (c1->pin == (PinType *)0x0)) &&
                           (c1->via == (PinType *)0x0)) {
                          c = other_corner(l_00,c1);
                          c_00 = other_corner(c1->lines[1],c1);
                          if (bVar3) {
                            pLVar11 = (*c1->lines)->line;
                            if (((*(byte *)&(pLVar11->Flags).f & 0x40) == 0) &&
                               ((*(byte *)&(c1->lines[1]->line->Flags).f & 0x40) == 0))
                            goto LAB_0808878a;
                          }
                          else {
                            if (autorouted_only == 0) {
                              pLVar11 = (*c1->lines)->line;
                            }
                            else {
                              pLVar11 = (*c1->lines)->line;
                              if ((-1 < *(char *)&(pLVar11->Flags).f) &&
                                 (-1 < *(char *)&(c1->lines[1]->line->Flags).f)) goto LAB_0808878a;
                            }
                          }
                          uVar21 = uVar25 - 0x11;
                          if (uVar21 < 0x18) {
                            local_c4 = *(PCBTypePtr *)(CSWTCH_231 + uVar21 * 4);
                            local_d8 = *(corner_s **)(CSWTCH_232 + uVar21 * 4);
                          }
                          else {
                            local_d8 = (corner_s *)0x0;
                            local_c4 = (PCBTypePtr)0x0;
                          }
                          y2 = (int)local_d8;
                          if (bVar19 == 0x12) {
                            local_c4 = (PCBTypePtr)0x1;
                            iVar6 = (int)local_c4;
                          }
                          else {
                            iVar6 = (int)local_c4;
                            if (bVar19 < 0x13) {
                              iVar6 = -1;
                              if (bVar19 != 0x11) {
                                iVar6 = (int)local_c4;
                              }
                            }
                            else {
                              if (bVar19 == 0x24) {
                                local_d8 = (corner_s *)0xffffffff;
                                y2 = (int)local_d8;
                              }
                              else {
                                y2 = 1;
                                if (bVar19 != 0x28) {
                                  y2 = (int)local_d8;
                                }
                              }
                            }
                          }
                          local_c4 = (PCBTypePtr)iVar6;
                          local_d8 = (corner_s *)y2;
                          local_c0 = y_00;
                          if (x2 <= y_00) {
                            local_c0 = x2;
                          }
                          y_00 = c1->y;
                          x2 = pLVar11->Thickness;
                          y2 = c1->x;
                          iVar6 = PCB->Bloat;
                          local_d0 = (corner_s *)0x0;
                          c_01 = corners;
                          while (c_01 != (corner_s *)0x0) {
                            iVar7 = c_01->layer;
                            if (((((((iVar7 != -0x21524111) && (c != c_01)) && (c1 != c_01)) &&
                                  ((c_00 != c_01 &&
                                   (iVar9 = (int)local_c4 * c1->x, iVar8 = (int)local_c4 * c_01->x,
                                   iVar9 - iVar8 == 0 || iVar9 < iVar8)))) &&
                                 (iVar9 = c1->y * (int)local_d8, iVar8 = c_01->y * (int)local_d8,
                                 iVar9 - iVar8 == 0 || iVar9 < iVar8)) && (c1->net != c_01->net)) &&
                               (((iVar8 = c1->layer, iVar7 == -1 || (iVar8 == -1)) ||
                                ((iVar7 == iVar8 ||
                                 (layer_groupings[iVar8] == layer_groupings[iVar7])))))) {
                              iVar8 = corner_radius(c_01);
                              iVar7 = (((c_01->y * (int)local_d8 + (int)local_c4 * c_01->x) -
                                       ((iVar6 + 2 + x2 / 2) * 3) / 2) +
                                      (-((int)local_c4 * y2) - (int)local_d8 * y_00)) - iVar8;
                              if ((c_01->x != c1->x) && (c_01->y != c1->y)) {
                                iVar7 = iVar7 - iVar8;
                              }
                              if ((iVar7 < local_c0) ||
                                 ((iVar7 == local_c0 && (local_c0 = iVar7, c1->miter != -1)))) {
                                local_c0 = iVar7;
                                local_d0 = c_01;
                              }
                            }
                            c_01 = c_01->next;
                          }
                          if ((local_d0 == (corner_s *)0x0) || (local_d0->miter != -1)) {
                            if (local_c0 < 1) goto LAB_0808878a;
                            y_00 = c1->x;
                            x2 = c1->y;
                            if (uVar25 == 0x12) {
                              y_00 = y_00 + local_c0;
                            }
                            else {
                              if (uVar25 < 0x13) {
                                if (uVar25 == 0x11) {
                                  y_00 = y_00 - local_c0;
                                }
                              }
                              else {
                                if (uVar25 == 0x24) {
                                  x2 = x2 - local_c0;
                                }
                                else {
                                  if (uVar25 == 0x28) {
                                    x2 = x2 + local_c0;
                                  }
                                }
                              }
                            }
                            c = find_corner(y_00,x2,c1->layer);
                            c_00 = other_corner((line_s *)((line_s *)c1->lines)->layer,c1);
                            if (c != c_00) {
                              split_line((line_s *)((line_s *)c1->lines)->layer,c);
                            }
                            y_00 = c1->x;
                            x2 = c1->y;
                            if (bVar19 == 0x12) {
                              y_00 = y_00 + local_c0;
                            }
                            else {
                              if (bVar19 < 0x13) {
                                if (bVar19 == 0x11) {
                                  y_00 = y_00 - local_c0;
                                }
                              }
                              else {
                                if (bVar19 == 0x24) {
                                  x2 = x2 - local_c0;
                                }
                                else {
                                  if (bVar19 == 0x28) {
                                    x2 = x2 + local_c0;
                                  }
                                }
                              }
                            }
                            move_corner(c1,y_00,x2);
                            c1->miter = 0;
                            local_e0 = local_e0 + 1;
                            c->miter = 0;
                            bVar4 = true;
                          }
                          else {
                            bVar5 = false;
                          }
                        }
                        else {
LAB_0808878a:
                          c1->miter = 0;
                          bVar4 = true;
                        }
                      }
                      c1 = c1->next;
                    }
                    l_00 = lines;
                  } while ((bVar4) && (c1 = corners, !bVar5));
                }
              }
            }
          }
        }
      }
    }
joined_r0x08087e63:
    l = l_00;
    if (l != (line_s *)0x0) {
      l_00 = l->next;
      if ((l->layer != -0x21524111) &&
         (((pPVar22 = l->s->pad, pPVar22 == (PadType *)0x0 || (pPVar22 != l->e->pad)) &&
          (pDVar10 = PCB->Data, pDVar10->ElementN != 0)))) {
        local_cc = (corner_s *)0x0;
        local_c4 = PCB;
        do {
          pEVar18 = pDVar10->Element + (int)local_cc;
          if (pEVar18->PadN != 0) {
            uVar25 = 0;
LAB_08087ef1:
            do {
              if ((int)layer_type[l->layer] == 2 - (uint)(((pEVar18->Flags).f & 0x80) == 0)) {
                pPVar12 = pEVar18->Pad + uVar25;
                r.y1 = 0x7fffffff;
                r.x1 = 0x7fffffff;
                r.y2 = -0x80000000;
                r.x2 = -0x80000000;
                y_00 = pPVar12->Thickness / 2 + 1;
                add_point_to_rect(&r,(pPVar12->Point1).X,(pPVar12->Point1).Y,
                                  y_00 - (local_c4->Bloat + 1) / 2);
                add_point_to_rect(&r,(pPVar12->Point2).X,(pPVar12->Point2).Y,
                                  y_00 - (PCB->Bloat + 1) / 2);
                y_00 = l->s->y;
                x2 = l->s->x;
                if (r.x1 <= x2) {
                  if (((x2 <= r.x2) && (r.y1 <= y_00)) && (y_00 <= r.y2)) {
                    y2 = l->e->y;
                    iVar6 = l->e->x;
                    if (r.x1 <= iVar6) {
                      if (((r.x2 < iVar6) || (y2 < r.y1)) || (r.y2 < y2)) goto LAB_08088170;
                      local_c4 = (PCBTypePtr)0x20;
                      if ((x2 != iVar6) && (local_c4 = (PCBTypePtr)0x10, y_00 != y2)) {
                        local_c4 = (PCBTypePtr)0xf0;
                      }
                      y_00 = 0x20;
                      if (((pPVar12->Point1).X != (pPVar12->Point2).X) &&
                         (y_00 = 0xf0, (pPVar12->Point1).Y == (pPVar12->Point2).Y)) {
                        y_00 = 0x10;
                      }
                      if ((PCBTypePtr)y_00 == local_c4) {
                        remove_line(l);
                        goto joined_r0x08087e63;
                      }
                    }
                  }
                  local_c4 = PCB;
                  uVar25 = uVar25 + 1;
                  if (pEVar18->PadN < uVar25 || pEVar18->PadN == uVar25) break;
                  goto LAB_08087ef1;
                }
LAB_08088170:
                local_c4 = PCB;
              }
              uVar25 = uVar25 + 1;
            } while (uVar25 <= pEVar18->PadN && pEVar18->PadN != uVar25);
          }
          local_cc = (corner_s *)((int)local_cc + 1);
          pDVar10 = local_c4->Data;
        } while (local_cc <= pDVar10->ElementN && (corner_s *)pDVar10->ElementN != local_cc);
      }
      goto joined_r0x08087e63;
    }
  }
  else {
    local_e0 = 0;
    do {
      if (lines == (line_s *)0x0) break;
      y_00 = 0;
      l_00 = lines;
      do {
        if (l_00->layer != -0x21524111) {
          x2 = canonicalize_line(l_00);
          y_00 = y_00 + x2;
        }
        l_00 = l_00->next;
      } while (l_00 != (line_s *)0x0);
      local_e0 = local_e0 + y_00;
    } while (y_00 != 0);
  }
  if (local_e0 != 0) {
    IncrementUndoSerialNumber();
  }
  return 0;
LAB_080877e2:
  pDVar10 = PCB->Data;
  local_d4 = PCB;
  goto LAB_080877f4;
}



void __regparm3 SetPVColor(PinTypePtr *Pin,int Type)

{
  uint uVar1;
  char *pcVar2;
  
  if (Type == 1) {
    if ((doing_pinout != 0) || (uVar1 = (Pin->Flags).f, (uVar1 & 0x244) == 0)) {
      pcVar2 = PCB->ViaColor;
      goto LAB_08088fdd;
    }
    if ((uVar1 & 0x200) != 0) goto LAB_08089060;
    if ((uVar1 & 0x40) != 0) {
      pcVar2 = PCB->ViaSelectedColor;
      goto LAB_08088fdd;
    }
  }
  else {
    if ((doing_pinout != 0) || (uVar1 = (Pin->Flags).f, (uVar1 & 0x244) == 0)) {
      pcVar2 = PCB->PinColor;
      goto LAB_08088fdd;
    }
    if ((uVar1 & 0x200) != 0) {
LAB_08089060:
      pcVar2 = PCB->WarnColor;
      goto LAB_08088fdd;
    }
    if ((uVar1 & 0x40) != 0) {
      pcVar2 = PCB->PinSelectedColor;
      goto LAB_08088fdd;
    }
  }
  pcVar2 = PCB->ConnectedColor;
LAB_08088fdd:
  (*gui->set_color)(Output.fgGC,pcVar2);
  return;
}



void UpdateAll(void)

{
  (*gui->invalidate_all)();
  return;
}



void RedrawOutput(BoxTypePtr area)

{
  (*gui->invalidate_all)();
  Gathering = '\x01';
  render = '\0';
  return;
}



void ClearAndRedrawOutput(void)

{
  render = '\x01';
  Gathering = '\0';
  (*gui->invalidate_all)();
  return;
}



int hole_counting_callback(BoxType *b,void *cl)

{
  if ((*(byte *)&b[1].Y1 & 8) == 0) {
    *(int *)cl = *(int *)cl + 1;
    return 1;
  }
  *(int *)((int)cl + 4) = *(int *)((int)cl + 4) + 1;
  return 1;
}



int EMark_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  bool bVar5;
  int local_20;
  
  iVar1 = b[0xd].Y2;
  iVar2 = b[0xd].X2;
  bVar5 = ((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide;
  if ((bVar5) && (PCB->InvisibleObjectsOn == '\0')) {
    return 1;
  }
  if ((b[0xe].X1 == 0) || (local_20 = *(int *)(b[0x10].X1 + 0x24), 1999 < local_20)) {
    local_20 = 1000;
  }
  else {
    local_20 = local_20 / 2;
  }
  iVar4 = local_20;
  if ((b[0xe].X2 != 0) && (iVar4 = *(int *)(b[0x10].Y1 + 0x24) / 2, local_20 <= iVar4)) {
    iVar4 = local_20;
  }
  local_20 = iVar4;
  if (bVar5) {
    pcVar3 = PCB->InvisibleMarkColor;
  }
  else {
    pcVar3 = PCB->ElementColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar3);
  (*gui->set_line_cap)(Output.fgGC,Trace_Cap);
  (*gui->set_line_width)(Output.fgGC,0);
  (*gui->draw_line)(Output.fgGC,iVar2 - local_20,iVar1,iVar2,iVar1 - local_20);
  (*gui->draw_line)(Output.fgGC,local_20 + iVar2,iVar1,iVar2,iVar1 - local_20);
  (*gui->draw_line)(Output.fgGC,iVar2 - local_20,iVar1,iVar2,local_20 + iVar1);
  (*gui->draw_line)(Output.fgGC,local_20 + iVar2,iVar1,iVar2,local_20 + iVar1);
  if ((*(byte *)((int)&b[1].Y1 + 1) & 0x20) != 0) {
    (*gui->draw_line)(Output.fgGC,iVar2,iVar1,iVar2 + local_20 * 2,iVar1);
    (*gui->draw_line)(Output.fgGC,iVar2,iVar1,iVar2,iVar1 + local_20 * -4);
  }
  return 1;
}



void __regparm3
DrawSpecialPolygon(HID *hid,hidGC DrawGC,LocationType X,LocationType Y,int Thickness)

{
  FloatPolyType p [8];
  int scaled_y [8];
  int scaled_x [8];
  int special_size;
  int iVar1;
  int iVar2;
  int iStack104;
  int polygon_y [9];
  int polygon_x [9];
  
  if (Thickness != special_size) {
    special_size = Thickness;
    iVar1 = 0;
    do {
      *(int *)(iVar1 + 0x816b960) =
           (int)ROUND(*(double *)((int)&((FloatPolyType *)&ram0x0813f1e0)->X + iVar1 * 4) *
                      (double)Thickness);
      *(int *)(iVar1 + 0x816b940) =
           (int)ROUND(*(double *)(iVar1 * 4 + 0x813f1e8) * (double)Thickness);
      iVar1 = iVar1 + 4;
    } while (iVar1 != 0x20);
  }
  iVar1 = 0;
  do {
    polygon_x[iVar1] = *(int *)(iVar1 * 4 + 0x816b960) + X;
    polygon_y[iVar1] = *(int *)(iVar1 * 4 + 0x816b940) + Y;
    iVar1 = iVar1 + 1;
  } while (iVar1 != 8);
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
    (*hid->fill_polygon)(DrawGC,8,polygon_x,polygon_y);
    return;
  }
  (*hid->set_line_cap)(Output.fgGC,Round_Cap);
  (*hid->set_line_width)(Output.fgGC,0);
  polygon_y[8] = Y + scaled_y[0];
  polygon_x[8] = X + scaled_x[0];
  iVar1 = 0;
  do {
    iVar2 = iVar1 + 1;
    (*hid->draw_line)(DrawGC,polygon_y[iVar1 + 9],(&iStack104)[iVar2],polygon_x[iVar2],
                      polygon_y[iVar2]);
    iVar1 = iVar2;
  } while (iVar2 != 8);
  return;
}



void __regparm3 DrawPinOrViaLowLevel(PinTypePtr *Ptr,Boolean drawHole)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  BDimension BVar5;
  int iVar6;
  
  if (Gathering != '\0') {
    iVar2 = (Ptr->BoundingBox).X1;
    if (Block.X1 <= iVar2) {
      iVar2 = Block.X1;
    }
    iVar3 = (Ptr->BoundingBox).X2;
    if (iVar3 <= Block.X2) {
      iVar3 = Block.X2;
    }
    iVar4 = (Ptr->BoundingBox).Y1;
    if (Block.Y1 <= iVar4) {
      iVar4 = Block.Y1;
    }
    iVar6 = (Ptr->BoundingBox).Y2;
    if (Block.Y2 < iVar6) {
      Block.X1 = iVar2;
      Block.Y1 = iVar4;
      Block.X2 = iVar3;
      Block.Y2 = iVar6;
      return;
    }
    Block.X1 = iVar2;
    Block.Y1 = iVar4;
    Block.X2 = iVar3;
    return;
  }
  uVar1 = (Ptr->Flags).f;
  if ((uVar1 & 8) == 0) {
    if ((uVar1 & 0x100) == 0) {
      if ((uVar1 & 0x800) == 0) {
        if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
          (*gui->fill_circle)(Output.fgGC,Ptr->X,Ptr->Y,Ptr->Thickness / 2);
        }
        else {
          (*gui->set_line_cap)(Output.fgGC,Round_Cap);
          (*gui->set_line_width)(Output.fgGC,0);
          iVar2 = Ptr->Thickness / 2;
          (*gui->draw_arc)(Output.fgGC,Ptr->X,Ptr->Y,iVar2,iVar2,0,0x168);
        }
      }
      else {
        (*gui->set_line_cap)(Output.fgGC,Round_Cap);
        (*gui->set_line_width)(Output.fgGC,(Ptr->Thickness - Ptr->DrillingHole) / 2);
        DrawSpecialPolygon(gui,Output.fgGC,Ptr->X,Ptr->Y,Ptr->Thickness);
      }
    }
    else {
      iVar3 = Ptr->Thickness;
      iVar6 = Ptr->X + -(iVar3 / 2);
      iVar4 = -(iVar3 / 2) + Ptr->Y;
      iVar2 = iVar6 + iVar3;
      iVar3 = iVar4 + iVar3;
      if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
        (*gui->fill_rect)(Output.fgGC,iVar6,iVar4,iVar2,iVar3);
      }
      else {
        (*gui->set_line_cap)(Output.fgGC,Round_Cap);
        (*gui->set_line_width)(Output.fgGC,0);
        (*gui->draw_line)(Output.fgGC,iVar2,iVar3,iVar2,iVar4);
        (*gui->draw_line)(Output.fgGC,iVar6,iVar3,iVar6,iVar4);
        (*gui->draw_line)(Output.fgGC,iVar2,iVar3,iVar6,iVar3);
        (*gui->draw_line)(Output.fgGC,iVar2,iVar4,iVar6,iVar4);
      }
    }
    if (drawHole == '\0') {
      return;
    }
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->fill_circle)(Output.bgGC,Ptr->X,Ptr->Y,Ptr->DrillingHole / 2);
      return;
    }
    (*gui->set_line_cap)(Output.fgGC,Round_Cap);
    (*gui->set_line_width)(Output.fgGC,0);
    BVar5 = Ptr->DrillingHole;
  }
  else {
    if (drawHole == '\0') {
      return;
    }
    (*gui->fill_circle)(Output.bgGC,Ptr->X,Ptr->Y,Ptr->Thickness / 2);
    (*gui->set_line_cap)(Output.fgGC,Round_Cap);
    (*gui->set_line_width)(Output.fgGC,0);
    BVar5 = Ptr->Thickness;
  }
  (*gui->draw_arc)(Output.fgGC,Ptr->X,Ptr->Y,BVar5 / 2,BVar5 / 2,0,0x168);
  return;
}



int hole_callback(BoxType *b,void *cl)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  
  if (cl == (void *)0x0) {
LAB_08089905:
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) != 0) goto LAB_08089914;
LAB_080899e6:
    (*gui->fill_circle)(Output.bgGC,b[3].Y1,b[3].X2,b[3].X1 / 2);
  }
  else {
    if (*(int *)cl == 0) {
      if ((*(byte *)&b[1].Y1 & 8) == 0) {
        return 1;
      }
      goto LAB_08089905;
    }
    if (*(int *)cl != 1) goto LAB_08089905;
    if ((*(byte *)&b[1].Y1 & 8) != 0) {
      return 1;
    }
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) goto LAB_080899e6;
LAB_08089914:
    uVar1 = b[1].Y1;
    if ((uVar1 & 8) != 0) goto LAB_0808991f;
    (*gui->set_line_cap)(Output.fgGC,Round_Cap);
    (*gui->set_line_width)(Output.fgGC,0);
    iVar3 = b[3].X1 / 2;
    (*gui->draw_arc)(Output.fgGC,b[3].Y1,b[3].X2,iVar3,iVar3,0,0x168);
  }
  uVar1 = b[1].Y1;
  if ((uVar1 & 8) == 0) {
    return 1;
  }
LAB_0808991f:
  if ((uVar1 & 0x200) == 0) {
    pcVar2 = Settings.BlackColor;
    if ((uVar1 & 0x40) != 0) {
      pcVar2 = PCB->ViaSelectedColor;
    }
  }
  else {
    pcVar2 = PCB->WarnColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar2);
  (*gui->set_line_cap)(Output.fgGC,Round_Cap);
  (*gui->set_line_width)(Output.fgGC,0);
  iVar3 = b[3].X1 / 2;
  (*gui->draw_arc)(Output.fgGC,b[3].Y1,b[3].X2,iVar3,iVar3,0,0x168);
  return 1;
}



void ClearPin(PinTypePtr *Pin,int Type,int unused)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  if (Gathering == '\0') {
    uVar2 = (Pin->Flags).f;
    iVar6 = (Pin->Clearance + Pin->Thickness) / 2;
    if ((uVar2 & 0x100) == 0) {
      if ((uVar2 & 0x800) == 0) {
        (*gui->fill_circle)(Output.pmGC,Pin->X,Pin->Y,iVar6);
      }
      else {
        (*gui->set_line_cap)(Output.pmGC,Round_Cap);
        (*gui->set_line_width)
                  (Output.pmGC,((Pin->Thickness + Pin->Clearance) - Pin->DrillingHole) / 2);
        DrawSpecialPolygon(gui,Output.pmGC,Pin->X,Pin->Y,iVar6 * 2);
      }
    }
    else {
      iVar4 = Pin->X - iVar6;
      iVar5 = Pin->Y - iVar6;
      (*gui->fill_rect)(Output.pmGC,iVar4,iVar5,iVar6 * 2 + iVar4,iVar6 * 2 + iVar5);
    }
    if ((*(byte *)&(Pin->Flags).f & 1) == 0) {
      cVar1 = PCB->ViaOn;
    }
    else {
      cVar1 = PCB->PinOn;
    }
    iVar3 = Block.Y2;
    if ((cVar1 != '\0') && ((Type == 1 || (Type == 0x100)))) {
      SetPVColor(Pin,Type);
      DrawPinOrViaLowLevel(Pin,'\x01');
      return;
    }
  }
  else {
    iVar6 = (Pin->BoundingBox).X1;
    if (Block.X1 <= iVar6) {
      iVar6 = Block.X1;
    }
    iVar4 = (Pin->BoundingBox).X2;
    if (iVar4 <= Block.X2) {
      iVar4 = Block.X2;
    }
    iVar5 = (Pin->BoundingBox).Y1;
    if (Block.Y1 <= iVar5) {
      iVar5 = Block.Y1;
    }
    iVar3 = (Pin->BoundingBox).Y2;
    Block.X1 = iVar6;
    Block.Y1 = iVar5;
    Block.X2 = iVar4;
    if (iVar3 <= Block.Y2) {
      iVar3 = Block.Y2;
    }
  }
  Block.Y2 = iVar3;
  return;
}



void __regparm3 DrawLineLowLevel(LineTypePtr Line,Boolean HaveGathered)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if ((HaveGathered == '\0') && (Gathering != '\0')) {
    iVar1 = (Line->BoundingBox).X1;
    if (Block.X1 <= iVar1) {
      iVar1 = Block.X1;
    }
    iVar2 = (Line->BoundingBox).X2;
    if (iVar2 <= Block.X2) {
      iVar2 = Block.X2;
    }
    iVar3 = (Line->BoundingBox).Y1;
    if (Block.Y1 <= iVar3) {
      iVar3 = Block.Y1;
    }
    iVar4 = (Line->BoundingBox).Y2;
    if (iVar4 <= Block.Y2) {
      iVar4 = Block.Y2;
    }
    Block.X1 = iVar1;
    Block.Y1 = iVar3;
    Block.X2 = iVar2;
    Block.Y2 = iVar4;
    return;
  }
  (*gui->set_line_cap)(Output.fgGC,Trace_Cap);
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
    (*gui->set_line_width)(Output.fgGC,Line->Thickness);
  }
  else {
    (*gui->set_line_width)(Output.fgGC,0);
  }
  (*gui->draw_line)(Output.fgGC,(Line->Point1).X,(Line->Point1).Y,(Line->Point2).X,(Line->Point2).Y)
  ;
  return;
}



void __regparm3 DrawArcLowLevel(ArcTypePtr *Arc)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (Arc->Thickness != 0) {
    if (Gathering != '\0') {
      iVar1 = (Arc->BoundingBox).X1;
      if (Block.X1 <= iVar1) {
        iVar1 = Block.X1;
      }
      iVar2 = (Arc->BoundingBox).X2;
      if (iVar2 <= Block.X2) {
        iVar2 = Block.X2;
      }
      iVar3 = (Arc->BoundingBox).Y1;
      if (Block.Y1 <= iVar3) {
        iVar3 = Block.Y1;
      }
      iVar4 = (Arc->BoundingBox).Y2;
      if (iVar4 <= Block.Y2) {
        iVar4 = Block.Y2;
      }
      Block.X1 = iVar1;
      Block.Y1 = iVar3;
      Block.X2 = iVar2;
      Block.Y2 = iVar4;
      return;
    }
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->set_line_width)(Output.fgGC,Arc->Thickness);
    }
    else {
      (*gui->set_line_width)(Output.fgGC,0);
    }
    (*gui->set_line_cap)(Output.fgGC,Trace_Cap);
    (*gui->draw_arc)(Output.fgGC,Arc->X,Arc->Y,Arc->Width,Arc->Height,Arc->StartAngle,Arc->Delta);
  }
  return;
}



void DrawLine(LayerTypePtr Layer,LineTypePtr Line,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Gathering == '\0') {
    uVar1 = (Line->Flags).f;
    if ((uVar1 & 0x44) == 0) {
      pcVar2 = Layer->Color;
    }
    else {
      if ((uVar1 & 0x40) == 0) {
        pcVar2 = PCB->ConnectedColor;
      }
      else {
        pcVar2 = Layer->SelectedColor;
      }
    }
    (*gui->set_color)(Output.fgGC,pcVar2);
  }
  DrawLineLowLevel(Line,'\0');
  return;
}



int line_callback(BoxType *b,void *cl)

{
  DrawLine((LayerTypePtr)cl,(LineTypePtr)b,0);
  return 1;
}



void DrawRat(RatTypePtr *Line,int unused)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  int iVar7;
  
  if (Gathering == '\0') {
    uVar2 = (Line->Flags).f;
    if ((uVar2 & 0x44) == 0) {
      pcVar6 = PCB->RatColor;
    }
    else {
      if ((uVar2 & 0x40) == 0) {
        pcVar6 = PCB->ConnectedColor;
      }
      else {
        pcVar6 = PCB->RatSelectedColor;
      }
    }
    (*gui->set_color)(Output.fgGC,pcVar6);
  }
  if (Settings.RatThickness < 0x14) {
    Line->Thickness = Settings.RatThickness * pixel_slop;
  }
  if ((*(byte *)&(Line->Flags).f & 2) == 0) {
    DrawLineLowLevel((LineTypePtr)Line,'\0');
    return;
  }
  iVar3 = Line->Thickness;
  if (Gathering == '\0') {
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->set_line_width)(Output.fgGC,iVar3);
    }
    else {
      (*gui->set_line_width)(Output.fgGC,0);
    }
    (*gui->draw_arc)(Output.fgGC,(Line->Point1).X,(Line->Point1).Y,iVar3 * 2,iVar3 * 2,0,0x168);
  }
  else {
    iVar4 = (Line->Point1).X;
    iVar5 = (Line->Point1).Y;
    iVar7 = iVar3 * -2 - iVar3 / 2;
    iVar1 = iVar3 / 2 + iVar3 * 2;
    iVar3 = iVar7 + iVar4;
    if (iVar3 <= Block.X1) {
      Block.X1 = iVar3;
    }
    iVar4 = iVar1 + iVar4;
    if (Block.X2 <= iVar4) {
      Block.X2 = iVar4;
    }
    iVar7 = iVar7 + iVar5;
    iVar1 = iVar1 + iVar5;
    if (Block.Y1 < iVar7) {
      iVar7 = Block.Y1;
    }
    Block.Y1 = iVar7;
    if (Block.Y2 <= iVar1) {
      Block.Y2 = iVar1;
    }
  }
  return;
}



int rat_callback(BoxType *b,void *cl)

{
  DrawRat((RatTypePtr *)b,0);
  return 1;
}



void DrawArc(LayerTypePtr Layer,ArcTypePtr *Arc,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Arc->Thickness != 0) {
    if (Gathering == '\0') {
      uVar1 = (Arc->Flags).f;
      if ((uVar1 & 0x44) == 0) {
        pcVar2 = Layer->Color;
      }
      else {
        if ((uVar1 & 0x40) == 0) {
          pcVar2 = PCB->ConnectedColor;
        }
        else {
          pcVar2 = Layer->SelectedColor;
        }
      }
      (*gui->set_color)(Output.fgGC,pcVar2);
    }
    DrawArcLowLevel(Arc);
    return;
  }
  return;
}



int arc_callback(BoxType *b,void *cl)

{
  DrawArc((LayerTypePtr)cl,(ArcTypePtr *)b,0);
  return 1;
}



int cp_callback(BoxType *b,void *cl)

{
  ClearPin((PinTypePtr *)b,(int)cl,0);
  return 1;
}



// WARNING: Type propagation algorithm not settling

int poly_callback(BoxType *b,void *cl)

{
  int iVar1;
  uint uVar2;
  LocationType LVar3;
  anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_thindraw_pcb_polygon *paVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int in_GS_OFFSET;
  PolygonType poly;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  LVar3 = Block.Y2;
  if (b[2].Y2 != 0) {
    if (Gathering == '\0') {
      if ((b[1].Y1 & 0x40U) == 0) {
        if ((b[1].Y1 & 4U) == 0) {
          color = *(char **)(*(int *)((int)cl + 4) + 0x48);
        }
        else {
          color = PCB->ConnectedColor;
        }
      }
      else {
        color = *(char **)(*(int *)((int)cl + 4) + 0x4c);
      }
      (*gui->set_color)(Output.fgGC,color);
      if ((gui->thindraw_pcb_polygon ==
           (anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_thindraw_pcb_polygon *)0x0) ||
         (((PCB->Flags).f & 0x24000) == 0)) {
        (*gui->fill_pcb_polygon)(Output.fgGC,(PolygonType *)b,clip_box);
      }
      else {
        (*gui->thindraw_pcb_polygon)(Output.fgGC,(PolygonType *)b,clip_box);
      }
      paVar4 = gui->thindraw_pcb_polygon;
      LVar3 = Block.Y2;
      if (((paVar4 != (anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_thindraw_pcb_polygon *)
                      0x0) && ((*(byte *)&(PCB->Flags).f & 4) != 0)) &&
         (uVar2 = b[1].Y1, (uVar2 & 0x20) == 0)) {
        poly.BoundingBox.X1 = b->X1;
        poly.BoundingBox.Y1 = b->Y1;
        poly.BoundingBox.X2 = b->X2;
        poly.BoundingBox.Y2 = b->Y2;
        poly.ID = b[1].X1;
        poly.Flags.t._0_4_ = b[1].X2;
        poly.Flags.t._4_4_ = b[1].Y2;
        poly.net = (LibraryEntryType *)b[2].X1;
        poly.PointN = b[2].Y1;
        poly.PointMax = b[2].X2;
        poly.NoHoles = (PLINE *)b[3].X1;
        poly.NoHolesValid = b[3].Y1;
        poly.Points = (PointTypePtr)b[3].X2;
        poly.Clipped = ((POLYAREA *)b[2].Y2)->f;
        poly.Flags.f = uVar2;
        if (poly.Clipped != (POLYAREA *)b[2].Y2) {
          while( true ) {
            (*paVar4)(Output.fgGC,&poly,clip_box);
            poly.Clipped = (poly.Clipped)->f;
            LVar3 = Block.Y2;
            if (poly.Clipped == (POLYAREA *)b[2].Y2) break;
            paVar4 = gui->thindraw_pcb_polygon;
          }
        }
      }
    }
    else {
      iVar5 = b->X1;
      if (Block.X1 <= b->X1) {
        iVar5 = Block.X1;
      }
      iVar6 = b->X2;
      if (b->X2 <= Block.X2) {
        iVar6 = Block.X2;
      }
      iVar7 = b->Y1;
      if (Block.Y1 <= b->Y1) {
        iVar7 = Block.Y1;
      }
      Block.X1 = iVar5;
      Block.Y1 = iVar7;
      Block.X2 = iVar6;
      LVar3 = b->Y2;
      if (b->Y2 <= Block.Y2) {
        LVar3 = Block.Y2;
      }
    }
  }
  Block.Y2 = LVar3;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 1;
}



void DrawElementPackage(ElementTypePtr *Element,int unused)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  
  if ((doing_pinout == 0) && (doing_assy == 0)) {
    uVar1 = (Element->Flags).f;
    if ((uVar1 & 0x40) != 0) {
      pcVar2 = PCB->ElementSelectedColor;
      goto LAB_0808a43b;
    }
    if ((uVar1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
      pcVar2 = PCB->InvisibleObjectsColor;
      goto LAB_0808a43b;
    }
  }
  pcVar2 = PCB->ElementColor;
LAB_0808a43b:
  (*gui->set_color)(Output.fgGC,pcVar2);
  iVar3 = Element->LineN - 1;
  if (iVar3 != -1) {
    iVar4 = Element->LineN * 0x58;
    do {
      iVar3 = iVar3 + -1;
      DrawLineLowLevel((LineTypePtr)((int)&Element->Line[-1].BoundingBox.X1 + iVar4),'\0');
      iVar4 = iVar4 + -0x58;
    } while (iVar3 != -1);
  }
  iVar3 = Element->ArcN - 1;
  if (iVar3 != -1) {
    iVar4 = Element->ArcN * 0x44;
    do {
      iVar3 = iVar3 + -1;
      DrawArcLowLevel((ArcTypePtr *)((int)&Element->Arc[-1].BoundingBox.X1 + iVar4));
      iVar4 = iVar4 + -0x44;
    } while (iVar3 != -1);
  }
  return;
}



int frontE_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    return 1;
  }
  DrawElementPackage((ElementTypePtr *)b,0);
  return 1;
}



int backE_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    DrawElementPackage((ElementTypePtr *)b,0);
  }
  return 1;
}



void EraseRat(RatTypePtr *Rat)

{
  int iVar1;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  if ((*(byte *)&(Rat->Flags).f & 2) != 0) {
    iVar1 = Rat->Thickness;
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x40) == 0) {
      (*gui->set_line_width)(Output.fgGC,iVar1);
    }
    else {
      (*gui->set_line_width)(Output.fgGC,0);
    }
    iVar1 = iVar1 * 2;
    (*gui->draw_arc)(Output.fgGC,(Rat->Point1).X,(Rat->Point1).Y,iVar1,iVar1,0,0x168);
    Erasing = Erasing + -1;
    return;
  }
  DrawLineLowLevel((LineTypePtr)Rat,'\0');
  Erasing = Erasing + -1;
  return;
}



void EraseLine(LineTypePtr Line)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawLineLowLevel(Line,'\0');
  Erasing = Erasing + -1;
  return;
}



void EraseArc(ArcTypePtr *Arc)

{
  if (Arc->Thickness != 0) {
    Erasing = Erasing + 1;
    (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
    DrawArcLowLevel(Arc);
    Erasing = Erasing + -1;
  }
  return;
}



void __regparm3 DrawMask(BoxType *screen)

{
  pin_info info;
  
  info.arg = '\x01';
  if (((PCB->Flags).f & 0x24000) == 0) {
    if ((*(byte *)&gui->field_0xc & 8) != 0) {
      (*gui->use_mask)(1);
      (*gui->set_color)(Output.fgGC,PCB->MaskColor);
      (*gui->fill_rect)(Output.fgGC,0,0,PCB->MaxWidth,PCB->MaxHeight);
    }
    (*gui->use_mask)(2);
    r_search(PCB->Data->pin_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,
             &info);
    r_search(PCB->Data->via_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,
             &info);
    r_search(PCB->Data->pad_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,clearPad_callback,
             &info);
    if ((*(byte *)&gui->field_0xc & 0x10) != 0) {
      (*gui->use_mask)(3);
      (*gui->set_color)(Output.fgGC,PCB->MaskColor);
      (*gui->fill_rect)(Output.fgGC,0,0,PCB->MaxWidth,PCB->MaxHeight);
    }
    (*gui->use_mask)(0);
    return;
  }
  (*gui->set_color)(Output.pmGC,PCB->MaskColor);
  r_search(PCB->Data->pin_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,
           &info);
  r_search(PCB->Data->via_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,clearPin_callback,
           &info);
  r_search(PCB->Data->pad_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,clearPad_callback,
           &info);
  (*gui->set_color)(Output.pmGC,"erase");
  return;
}



void __regparm3 DrawTop(BoxType *screen)

{
  if ((PCB->PinOn != '\0') || (doing_assy != 0)) {
    r_search(PCB->Data->pin_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pin_callback,
             (void *)0x0);
    r_search(PCB->Data->pad_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pad_callback,
             (void *)0x0);
  }
  if ((PCB->ViaOn != '\0') || (doing_assy != 0)) {
    r_search(PCB->Data->via_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,via_callback,
             (void *)0x0);
    r_search(PCB->Data->via_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
             (void *)0x0);
  }
  if ((PCB->PinOn != '\0') || (doing_assy != 0)) {
    r_search(PCB->Data->pin_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,hole_callback,
             (void *)0x0);
  }
  return;
}



void DrawLayer(LayerTypePtr Layer,BoxType *screen)

{
  pin_info info;
  
  info.arg = '\0';
  info.Layer = Layer;
  clip_box = screen;
  r_search(Layer->polygon_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,poly_callback,&info)
  ;
  r_search(Layer->line_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,line_callback,Layer);
  r_search(Layer->arc_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,arc_callback,Layer);
  r_search(Layer->text_tree,screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,text_callback,Layer);
  clip_box = (BoxType *)0x0;
  return;
}



void __regparm3 DrawSilk(int new_swap,int layer,BoxTypePtr drawn_area)

{
  uint uVar1;
  Boolean BVar2;
  uint uVar3;
  
  BVar2 = Settings.ShowSolderSide;
  Settings.ShowSolderSide = (Boolean)new_swap;
  DrawLayer((LayerTypePtr)(&PCB->Data->field_0x4c + (layer + PCB->Data->LayerN) * 0x5c),
            (BoxType *)drawn_area);
  r_search(PCB->Data->element_tree,(BoxType *)drawn_area,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
           frontE_callback,(void *)0x0);
  uVar1 = (PCB->Flags).f;
  uVar3 = 1;
  if ((uVar1 & 0x40) == 0) {
    uVar3 = -(uint)((uVar1 & 0x20) == 0) & 2;
  }
  r_search(PCB->Data->name_tree[uVar3],(BoxType *)drawn_area,
           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,frontN_callback,(void *)0x0);
  Settings.ShowSolderSide = BVar2;
  return;
}



int __regparm3 DrawLayerGroup(int group,BoxType *screen)

{
  Cardinal *pCVar1;
  LayerTypePtr cl;
  Cardinal CVar2;
  Cardinal CVar3;
  DataTypePtr *pDVar4;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  char *pcVar8;
  bool bVar9;
  byte bVar10;
  int local_3c;
  PCBTypePtr local_38;
  Cardinal *local_34;
  int local_30;
  pin_info info;
  
  bVar10 = 0;
  local_3c = 1;
  CVar2 = (PCB->LayerGroups).Number[group];
  local_38 = PCB;
  local_30 = CVar2 - 1;
  clip_box = screen;
  if (local_30 < 0) {
LAB_0808ad46:
    iVar5 = 1;
    if ((int)CVar2 < 2) {
      iVar5 = local_3c;
    }
    return iVar5;
  }
  local_34 = (PCB->LayerGroups).Entries + group * 0x12 + local_30;
  do {
    bVar9 = local_30 == 0;
    CVar3 = *local_34;
    iVar5 = 8;
    pDVar4 = local_38->Data;
    pcVar7 = *(char **)(&pDVar4->field_0x4c + CVar3 * 0x5c);
    pcVar6 = pcVar7;
    pcVar8 = "outline";
    do {
      if (iVar5 == 0) break;
      iVar5 = iVar5 + -1;
      bVar9 = *pcVar6 == *pcVar8;
      pcVar6 = pcVar6 + (uint)bVar10 * -2 + 1;
      pcVar8 = pcVar8 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
LAB_0808ad01:
      local_3c = 0;
    }
    else {
      iVar5 = 6;
      pcVar6 = "route";
      do {
        if (iVar5 == 0) break;
        iVar5 = iVar5 + -1;
        bVar9 = *pcVar7 == *pcVar6;
        pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
        pcVar6 = pcVar6 + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      if (bVar9) goto LAB_0808ad01;
    }
    PCB = local_38;
    if ((int)CVar3 < pDVar4->LayerN) {
      pCVar1 = &pDVar4->ViaN + CVar3 * 0x17;
      if (*(char *)(pCVar1 + 0x24) != '\0') {
        cl = (LayerTypePtr)(&pDVar4->field_0x4c + CVar3 * 0x5c);
        if (pCVar1[0x16] != 0) {
          info.arg = '\x01';
          info.Layer = cl;
          r_search((rtree_t *)pCVar1[0x22],screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   poly_callback,&info);
          local_38 = PCB;
          info.arg = '\0';
        }
        PCB = local_38;
        if ((*(byte *)&(local_38->Flags).f & 4) == 0) {
          pCVar1 = &pDVar4->ViaN + CVar3 * 0x17;
          r_search((rtree_t *)pCVar1[0x20],screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   line_callback,cl);
          r_search((rtree_t *)pCVar1[0x23],screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   arc_callback,cl);
          r_search((rtree_t *)pCVar1[0x21],screen,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   text_callback,cl);
        }
      }
    }
    local_34 = local_34 + -1;
    local_30 = local_30 + -1;
    if (local_30 < 0) goto LAB_0808ad46;
    local_38 = PCB;
  } while( true );
}



void __regparm3 PrintAssembly(BoxType *drawn_area,int side_group,int swap_ident)

{
  Boolean BVar1;
  
  BVar1 = Settings.ShowSolderSide;
  (*gui->set_draw_faded)(Output.fgGC,1);
  Settings.ShowSolderSide = (Boolean)swap_ident;
  DrawLayerGroup(side_group,drawn_area);
  r_search(PCB->Data->via_tree,drawn_area,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,lowvia_callback,
           (void *)0x0);
  DrawTop(drawn_area);
  (*gui->set_draw_faded)(Output.fgGC,0);
  DrawSilk(swap_ident,(uint)(swap_ident == 0),(BoxTypePtr)drawn_area);
  Settings.ShowSolderSide = BVar1;
  return;
}



void __regparm3 DrawPadLowLevel(hidGC gc,PadTypePtr *Pad,Boolean clear,Boolean mask)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  double dVar15;
  int local_40;
  int local_3c;
  double local_2c;
  double local_24 [2];
  
  if (clear == '\0') {
    iVar9 = Pad->Thickness;
  }
  else {
    if (mask == '\0') {
      iVar9 = Pad->Clearance + Pad->Thickness;
    }
    else {
      iVar9 = Pad->Mask;
    }
  }
  if (Gathering == '\0') {
    uVar4 = (PCB->Flags).f;
    if (((uVar4 & 0x4000) == 0) && ((clear == '\0' || ((uVar4 & 0x20000) == 0)))) {
      iVar12 = (Pad->Point1).X;
      if ((iVar12 == (Pad->Point2).X) && (iVar11 = (Pad->Point1).Y, iVar11 == (Pad->Point2).Y)) {
        if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
          (*gui->fill_circle)(gc,iVar12,iVar11,iVar9 / 2);
        }
        else {
          iVar12 = iVar12 + -(iVar9 / 2);
          iVar11 = iVar11 + -(iVar9 / 2);
          (*gui->fill_rect)(gc,iVar12,iVar11,iVar12 + iVar9,iVar11 + iVar9);
        }
      }
      else {
        (*gui->set_line_cap)(gc,~-(uint)(((Pad->Flags).f & 0x100) == 0) + Round_Cap);
        (*gui->set_line_width)(gc,iVar9);
        (*gui->draw_line)(gc,(Pad->Point1).X,(Pad->Point1).Y,(Pad->Point2).X,(Pad->Point2).Y);
      }
    }
    else {
      local_3c = (Pad->Point2).X;
      iVar12 = (Pad->Point1).X;
      iVar14 = iVar9 / 2;
      iVar9 = iVar9 - iVar14;
      iVar11 = (Pad->Point1).Y;
      local_40 = (Pad->Point2).Y;
      if ((local_40 < iVar11) || (iVar10 = iVar11, iVar13 = iVar12, local_3c < iVar12)) {
        iVar10 = local_40;
        iVar13 = local_3c;
        local_40 = iVar11;
        local_3c = iVar12;
      }
      (*gui->set_line_cap)(gc,Round_Cap);
      (*gui->set_line_width)(gc,0);
      if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
        if (iVar10 == local_40) {
          if (iVar13 != local_3c) {
            (*gui->draw_line)(gc,iVar13,iVar10 - iVar14,local_3c,iVar10 - iVar14);
            (*gui->draw_line)(gc,iVar13,iVar10 + iVar9,local_3c,iVar10 + iVar9);
            (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,0x5a,-0xb4);
            (*gui->draw_arc)(gc,local_3c,iVar10,iVar14,iVar14,0x10e,-0xb4);
            return;
          }
          (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,0,0x168);
        }
        else {
          if (iVar13 == local_3c) {
            (*gui->draw_line)(gc,iVar13 - iVar14,iVar10,iVar13 - iVar14,local_40);
            (*gui->draw_line)(gc,iVar13 + iVar9,iVar10,iVar13 + iVar9,local_40);
            (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,0,-0xb4);
            (*gui->draw_arc)(gc,iVar13,local_40,iVar14,iVar14,0xb4,-0xb4);
          }
          else {
            iVar9 = local_3c - iVar13;
            fVar6 = (float)iVar9;
            iVar12 = local_40 - iVar10;
            fVar7 = (float)iVar12;
            fVar5 = (float)iVar14 / SQRT(fVar7 * fVar7 + fVar6 * fVar6);
            if (iVar12 < 1) {
              if (iVar12 == 0) {
                fVar8 = 0.00000000;
              }
              else {
                fVar8 = -0.50000000;
              }
            }
            else {
              fVar8 = 0.50000000;
            }
            uVar4 = (uint)ROUND(fVar7 * fVar5 + fVar8);
            if (iVar9 < 1) {
              if (iVar9 == 0) {
                fVar7 = 0.00000000;
              }
              else {
                fVar7 = -0.50000000;
              }
            }
            else {
              fVar7 = 0.50000000;
            }
            uVar3 = (uint)ROUND(-(fVar5 * fVar6 + fVar7));
            (*gui->draw_line)(gc,uVar4 + iVar13,uVar3 + iVar10,uVar4 + local_3c,uVar3 + local_40);
            if ((pixel_slop <= (int)(((int)uVar4 >> 0x1f ^ uVar4) - ((int)uVar4 >> 0x1f))) ||
               (pixel_slop <= (int)(((int)uVar3 >> 0x1f ^ uVar3) - ((int)uVar3 >> 0x1f)))) {
              dVar15 = atan2((double)iVar9,(double)iVar12);
              (*gui->draw_line)(gc,iVar13 - uVar4,iVar10 - uVar3,local_3c - uVar4,local_40 - uVar3);
              (*gui->draw_arc)(gc,iVar13,iVar10,iVar14,iVar14,
                               (int)ROUND(dVar15 * 57.29577900) + -0xb4,0xb4);
              (*gui->draw_arc)(gc,local_3c,local_40,iVar14,iVar14,(int)ROUND(dVar15 * 57.29577900),
                               0xb4);
            }
          }
        }
      }
      else {
        if ((iVar10 == local_40) || (iVar13 == local_3c)) {
          iVar10 = iVar10 - iVar14;
          iVar13 = iVar13 - iVar14;
          local_3c = local_3c + iVar9;
          local_40 = local_40 + iVar9;
          (*gui->draw_line)(gc,iVar13,iVar10,iVar13,local_40);
          (*gui->draw_line)(gc,iVar13,local_40,local_3c,local_40);
          (*gui->draw_line)(gc,local_3c,local_40,local_3c,iVar10);
          (*gui->draw_line)(gc,local_3c,iVar10,iVar13,iVar10);
        }
        else {
          dVar15 = atan2((double)(local_40 - iVar10),(double)(local_3c - iVar13));
          sincos((double)((float)dVar15 + 0.78539813),local_24,&local_2c);
          fVar5 = (float)local_2c * (float)iVar14 * 1.41421354;
          fVar6 = (float)local_24[0] * (float)iVar14 * 1.41421354;
          iVar9 = (int)ROUND((float)local_40 - fVar5);
          iVar12 = (int)ROUND((float)local_3c + fVar6);
          iVar11 = (int)ROUND((float)iVar10 - fVar6);
          iVar14 = (int)ROUND((float)iVar13 - fVar5);
          (*gui->draw_line)(gc,iVar14,iVar11,iVar12,iVar9);
          iVar1 = (int)ROUND((float)local_40 + fVar6);
          iVar2 = (int)ROUND((float)local_3c + fVar5);
          (*gui->draw_line)(gc,iVar12,iVar9,iVar2,iVar1);
          iVar9 = (int)ROUND((float)iVar10 + fVar5);
          iVar12 = (int)ROUND((float)iVar13 - fVar6);
          (*gui->draw_line)(gc,iVar2,iVar1,iVar12,iVar9);
          (*gui->draw_line)(gc,iVar12,iVar9,iVar14,iVar11);
        }
      }
    }
    return;
  }
  iVar9 = (Pad->BoundingBox).X1;
  if (Block.X1 <= iVar9) {
    iVar9 = Block.X1;
  }
  iVar12 = (Pad->BoundingBox).X2;
  if (iVar12 <= Block.X2) {
    iVar12 = Block.X2;
  }
  iVar11 = (Pad->BoundingBox).Y1;
  if (Block.Y1 <= iVar11) {
    iVar11 = Block.Y1;
  }
  iVar14 = (Pad->BoundingBox).Y2;
  if (iVar14 <= Block.Y2) {
    iVar14 = Block.Y2;
  }
  Block.X1 = iVar9;
  Block.Y1 = iVar11;
  Block.X2 = iVar12;
  Block.Y2 = iVar14;
  return;
}



int clearPad_callback(BoxType *b,void *cl)

{
  if (*(char *)&b[1].Y1 < '\0') {
    if (Settings.ShowSolderSide == '\0') {
      return 1;
    }
  }
  else {
    if (Settings.ShowSolderSide != '\0') {
      return 1;
    }
  }
  DrawPadLowLevel(Output.pmGC,(PadTypePtr *)b,'\x01','\x01');
  return 1;
}



void ErasePolygon(PolygonTypePtr Polygon)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  iVar1 = Block.Y2;
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    if (Gathering == '\0') {
      __printf_chk(1,"DrawPolygonLowLevel: Called without Gathering set!\n");
      Erasing = Erasing + -1;
      return;
    }
    iVar2 = (Polygon->BoundingBox).X1;
    if (Block.X1 <= iVar2) {
      iVar2 = Block.X1;
    }
    iVar3 = (Polygon->BoundingBox).X2;
    if (iVar3 <= Block.X2) {
      iVar3 = Block.X2;
    }
    iVar4 = (Polygon->BoundingBox).Y1;
    if (Block.Y1 <= iVar4) {
      iVar4 = Block.Y1;
    }
    iVar1 = (Polygon->BoundingBox).Y2;
    Block.X1 = iVar2;
    Block.Y1 = iVar4;
    Block.X2 = iVar3;
    if (iVar1 <= Block.Y2) {
      iVar1 = Block.Y2;
    }
  }
  Block.Y2 = iVar1;
  Erasing = Erasing + -1;
  return;
}



int thin_callback(PLINE *pl,LayerTypePtr lay,PolygonTypePtr poly)

{
  int *piVar1;
  int *__ptr;
  int *__ptr_00;
  uint uVar2;
  uint uVar3;
  VNODE *pVVar4;
  uint uVar5;
  
  __ptr = (int *)calloc(1,pl->Count << 2);
  __ptr_00 = (int *)calloc(1,pl->Count << 2);
  pVVar4 = &pl->head;
  if (pl->Count != 0) {
    uVar3 = 0;
    do {
      uVar2 = uVar3 + 1;
      __ptr[uVar3] = pVVar4->point[0];
      piVar1 = pVVar4->point;
      pVVar4 = pVVar4->next;
      __ptr_00[uVar3] = piVar1[1];
      uVar3 = uVar2;
    } while (uVar2 <= pl->Count && pl->Count != uVar2);
  }
  (*gui->set_line_cap)(Output.fgGC,Round_Cap);
  (*gui->set_line_width)(Output.fgGC,0);
  uVar3 = pl->Count - 1;
  if (pl->Count != 1) {
    uVar2 = 0;
    do {
      uVar5 = uVar2 + 1;
      (*gui->draw_line)(Output.fgGC,__ptr[uVar2],__ptr_00[uVar2],__ptr[uVar2 + 1],
                        __ptr_00[uVar2 + 1]);
      uVar3 = pl->Count - 1;
      uVar2 = uVar5;
    } while (uVar5 < uVar3);
  }
  (*gui->draw_line)(Output.fgGC,__ptr[uVar3],__ptr_00[uVar3],*__ptr,*__ptr_00);
  free(__ptr);
  free(__ptr_00);
  return 0;
}



void DrawPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon,int unused)

{
  uint uVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  uVar1 = (Polygon->Flags).f;
  if ((uVar1 & 0x44) == 0) {
    pcVar3 = Layer->Color;
  }
  else {
    if ((uVar1 & 0x40) == 0) {
      pcVar3 = PCB->ConnectedColor;
    }
    else {
      pcVar3 = Layer->SelectedColor;
    }
  }
  (*gui->set_color)(Output.fgGC,pcVar3);
  GetLayerNumber(PCB->Data,Layer);
  iVar2 = Block.Y2;
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    if (Gathering == '\0') {
      __printf_chk(1,"DrawPolygonLowLevel: Called without Gathering set!\n");
      iVar2 = Block.Y2;
    }
    else {
      iVar4 = (Polygon->BoundingBox).X1;
      if (Block.X1 <= iVar4) {
        iVar4 = Block.X1;
      }
      iVar5 = (Polygon->BoundingBox).X2;
      if (iVar5 <= Block.X2) {
        iVar5 = Block.X2;
      }
      iVar6 = (Polygon->BoundingBox).Y1;
      if (Block.Y1 <= iVar6) {
        iVar6 = Block.Y1;
      }
      iVar2 = (Polygon->BoundingBox).Y2;
      Block.X1 = iVar4;
      Block.Y1 = iVar6;
      Block.X2 = iVar5;
      if (iVar2 <= Block.Y2) {
        iVar2 = Block.Y2;
      }
    }
  }
  Block.Y2 = iVar2;
  if ((*(byte *)&(Polygon->Flags).f & 0x10) != 0) {
    r_search(PCB->Data->pin_tree,(BoxType *)Polygon,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             cp_callback,(void *)0x100);
    r_search(PCB->Data->via_tree,(BoxType *)Polygon,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             cp_callback,&DAT_00000001);
  }
  return;
}



void DrawTextLowLevel(TextTypePtr Text,int min_line_width)

{
  int iVar1;
  PCBTypePtr pPVar2;
  byte bVar3;
  long *plVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  LocationType *pLVar9;
  LineType *pLVar10;
  int in_GS_OFFSET;
  byte bVar11;
  byte *local_a0;
  int local_9c;
  int local_98;
  LocationType *local_94;
  BoxType defaultsymbol;
  LineType newline;
  
  pPVar2 = PCB;
  bVar11 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_a0 = (byte *)Text->TextString;
  iVar8 = Block.Y2;
  if (Gathering == '\0') {
    if (local_a0 != (byte *)0x0) {
      bVar3 = *local_a0;
      local_9c = 0;
      if (bVar3 != 0) {
        do {
          plVar4 = &pPVar2->ID + (uint)bVar3 * 7;
          if (*(char *)(plVar4 + 0x35) == '\0') {
            iVar8 = (PCB->Font).DefaultSymbol.X1;
            iVar5 = (PCB->Font).DefaultSymbol.X2;
            iVar6 = Text->Scale;
            defaultsymbol.X1 = ((local_9c + iVar8) * iVar6) / 100;
            defaultsymbol.Y1 = ((PCB->Font).DefaultSymbol.Y1 * iVar6) / 100;
            defaultsymbol.X2 = ((local_9c + iVar5) * iVar6) / 100;
            defaultsymbol.Y2 = ((PCB->Font).DefaultSymbol.Y2 * iVar6) / 100;
            RotateBoxLowLevel((BoxTypePtr)&defaultsymbol,0,0,Text->Direction);
            defaultsymbol.X1 = defaultsymbol.X1 + Text->X;
            defaultsymbol.X2 = Text->X + defaultsymbol.X2;
            defaultsymbol.Y1 = defaultsymbol.Y1 + Text->Y;
            defaultsymbol.Y2 = Text->Y + defaultsymbol.Y2;
            (*gui->fill_rect)(Output.fgGC,defaultsymbol.X1,defaultsymbol.Y1,defaultsymbol.X2,
                              defaultsymbol.Y2);
            local_9c = local_9c + ((iVar5 - iVar8) * 6) / 5;
          }
          else {
            local_94 = (LocationType *)plVar4[0x34];
            local_98 = plVar4[0x36];
            if (local_98 != 0) {
              while( true ) {
                iVar8 = 0x16;
                pLVar9 = local_94;
                pLVar10 = &newline;
                while (iVar8 != 0) {
                  iVar8 = iVar8 + -1;
                  (pLVar10->BoundingBox).X1 = *pLVar9;
                  pLVar9 = pLVar9 + (uint)bVar11 * 0x3ffffffe + 1;
                  pLVar10 = (LineType *)((int)pLVar10 + (uint)bVar11 * -8 + 4);
                }
                iVar8 = Text->Scale;
                newline.Point1.X = ((local_9c + newline.Point1.X) * iVar8) / 100;
                newline.Point1.Y = (newline.Point1.Y * iVar8) / 100;
                newline.Point2.X = ((local_9c + newline.Point2.X) * iVar8) / 100;
                newline.Point2.Y = (newline.Point2.Y * iVar8) / 100;
                newline.Thickness = (iVar8 * newline.Thickness) / 200;
                if (newline.Thickness < min_line_width) {
                  newline.Thickness = min_line_width;
                }
                RotateLineLowLevel((LineTypePtr)&newline,0,0,Text->Direction);
                if (*(char *)&(Text->Flags).f < '\0') {
                  newline.Point1.Y = -newline.Point1.Y;
                  newline.Point2.Y = -newline.Point2.Y;
                }
                newline.Point1.X = newline.Point1.X + Text->X;
                newline.Point1.Y = newline.Point1.Y + Text->Y;
                newline.Point2.X = newline.Point2.X + Text->X;
                newline.Point2.Y = newline.Point2.Y + Text->Y;
                DrawLineLowLevel((LineTypePtr)&newline,'\x01');
                local_98 = local_98 + -1;
                if (local_98 == 0) break;
                local_94 = local_94 + 0x16;
              }
            }
            local_9c = local_9c + (pPVar2->Font).Symbol[*local_a0].Delta +
                       (pPVar2->Font).Symbol[*local_a0].Width;
          }
          local_a0 = local_a0 + 1;
          iVar8 = Block.Y2;
        } while ((local_a0 != (byte *)0x0) && (bVar3 = *local_a0, bVar3 != 0));
      }
    }
  }
  else {
    iVar5 = (Text->BoundingBox).X1;
    if (Block.X1 <= iVar5) {
      iVar5 = Block.X1;
    }
    iVar6 = (Text->BoundingBox).X2;
    if (iVar6 <= Block.X2) {
      iVar6 = Block.X2;
    }
    iVar7 = (Text->BoundingBox).Y1;
    if (Block.Y1 <= iVar7) {
      iVar7 = Block.Y1;
    }
    iVar8 = (Text->BoundingBox).Y2;
    Block.X1 = iVar5;
    Block.Y1 = iVar7;
    Block.X2 = iVar6;
    if (iVar8 <= Block.Y2) {
      iVar8 = Block.Y2;
    }
  }
  Block.Y2 = iVar8;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int text_callback(BoxType *b,void *cl)

{
  DataTypePtr *pDVar1;
  char *pcVar2;
  int min_line_width;
  
  if ((*(byte *)&b[1].Y1 & 0x40) == 0) {
    pcVar2 = *(char **)((int)cl + 0x48);
  }
  else {
    pcVar2 = *(char **)((int)cl + 0x4c);
  }
  (*gui->set_color)(Output.fgGC,pcVar2);
  pDVar1 = PCB->Data;
  if ((cl == (void *)(&pDVar1->field_0x4c +
                     ((uint)(Settings.ShowSolderSide == '\0') + pDVar1->LayerN) * 0x5c)) ||
     (cl == (void *)(&pDVar1->field_0x4c +
                    ((uint)(Settings.ShowSolderSide != '\0') + pDVar1->LayerN) * 0x5c))) {
    min_line_width = PCB->minSlk;
  }
  else {
    min_line_width = PCB->minWid;
  }
  DrawTextLowLevel((TextTypePtr)b,min_line_width);
  return 1;
}



void __regparm3 DrawPinOrViaNameLowLevel(PinTypePtr *Ptr)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  char *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  ulong local_6c;
  undefined4 local_68;
  undefined4 local_64;
  TextType text;
  
  pcVar4 = Ptr->Name;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((((pcVar4 == (char *)0x0) || (*pcVar4 == '\0')) || ((*(byte *)&(PCB->Flags).f & 1) != 0)) &&
     (pcVar4 = Ptr->Number, pcVar4 == (char *)0x0)) {
    pcVar4 = "";
  }
  uVar2 = (Ptr->Flags).f >> 0xe & 1;
  if (uVar2 == 0) {
    iVar5 = Settings.PinoutTextOffsetX + Ptr->X + Ptr->DrillingHole / 2;
    iVar3 = (Settings.PinoutTextOffsetY + Ptr->Y) - Ptr->Thickness / 2;
  }
  else {
    iVar5 = (Settings.PinoutTextOffsetY + Ptr->X) - Ptr->Thickness / 2;
    iVar3 = (-Settings.PinoutTextOffsetX - Ptr->DrillingHole / 2) + Ptr->Y;
  }
  if (Gathering == '\0') {
    (*gui->set_color)(Output.fgGC,PCB->PinNameColor);
    MakeFlags((FlagType *)&local_6c,0);
    text.Flags.f = local_6c;
    text.Flags.t._0_4_ = local_68;
    text.Flags.t._4_4_ = local_64;
    if ((*(byte *)&gui->field_0xc & 1) != 0) {
      doing_pinout = doing_pinout + 1;
    }
    text.Scale = Ptr->Thickness / 0x50;
    text.X = iVar5;
    text.Y = iVar3;
    text.Direction = (BYTE)uVar2;
    text.TextString = pcVar4;
    DrawTextLowLevel((TextTypePtr)&text,0);
    iVar3 = Block.Y2;
    if ((*(byte *)&gui->field_0xc & 1) != 0) {
      doing_pinout = doing_pinout + -1;
    }
  }
  else {
    if (iVar5 <= Block.X1) {
      Block.X1 = iVar5;
    }
    if (iVar5 < Block.X2) {
      iVar5 = Block.X2;
    }
    if (iVar3 <= Block.Y1) {
      Block.Y1 = iVar3;
    }
    Block.X2 = iVar5;
    if (iVar3 < Block.Y2) {
      iVar3 = Block.Y2;
    }
  }
  Block.Y2 = iVar3;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int pin_callback(BoxType *b,void *cl)

{
  if (Gathering == '\0') {
    SetPVColor((PinTypePtr *)b,0x100);
  }
  DrawPinOrViaLowLevel((PinTypePtr *)b,'\0');
  if ((b[1].Y1 & 0x28U) != 0x20) {
    return 1;
  }
  DrawPinOrViaNameLowLevel((PinTypePtr *)b);
  return 1;
}



void ErasePinName(PinTypePtr *Pin)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaNameLowLevel(Pin);
  Erasing = Erasing + -1;
  return;
}



void ErasePin(PinTypePtr *Pin)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaLowLevel(Pin,'\0');
  if ((*(byte *)&(Pin->Flags).f & 0x20) != 0) {
    DrawPinOrViaNameLowLevel(Pin);
  }
  Erasing = Erasing + -1;
  return;
}



void EraseViaName(PinTypePtr *Via)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaNameLowLevel(Via);
  Erasing = Erasing + -1;
  return;
}



void EraseVia(PinTypePtr *Via)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPinOrViaLowLevel(Via,'\0');
  if ((*(byte *)&(Via->Flags).f & 0x20) != 0) {
    DrawPinOrViaNameLowLevel(Via);
  }
  Erasing = Erasing + -1;
  return;
}



void DrawPinName(PinTypePtr *Pin,int unused)

{
  char *pcVar1;
  
  if (Gathering == '\0') {
    if ((*(byte *)&(Pin->Flags).f & 0x40) == 0) {
      pcVar1 = PCB->PinColor;
    }
    else {
      pcVar1 = PCB->PinSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar1);
  }
  DrawPinOrViaNameLowLevel(Pin);
  return;
}



void DrawPin(PinTypePtr *Pin,int unused)

{
  if (Gathering == '\0') {
    SetPVColor(Pin,0x100);
  }
  DrawPinOrViaLowLevel(Pin,'\x01');
  if ((((Pin->Flags).f & 0x28) != 0x20) && (doing_pinout == 0)) {
    return;
  }
  DrawPinOrViaNameLowLevel(Pin);
  return;
}



void DrawViaName(PinTypePtr *Via,int unused)

{
  char *pcVar1;
  
  if (Gathering == '\0') {
    if ((*(byte *)&(Via->Flags).f & 0x40) == 0) {
      pcVar1 = PCB->ViaColor;
    }
    else {
      pcVar1 = PCB->ViaSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar1);
  }
  DrawPinOrViaNameLowLevel(Via);
  return;
}



void DrawVia(PinTypePtr *Via,int unused)

{
  if (Gathering == '\0') {
    SetPVColor(Via,1);
  }
  DrawPinOrViaLowLevel(Via,'\x01');
  if (((Via->Flags).f & 0x28) != 0x20) {
    return;
  }
  DrawPinOrViaNameLowLevel(Via);
  return;
}



void EraseElementName(ElementTypePtr *Element)

{
  uint uVar1;
  uint uVar2;
  
  if ((*(byte *)&(Element->Flags).f & 0x10) != 0) {
    return;
  }
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  uVar1 = (PCB->Flags).f;
  uVar2 = 0x3c;
  if ((uVar1 & 0x40) == 0) {
    uVar2 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
  }
  DrawTextLowLevel((TextTypePtr)((int)&Element->Name[0].BoundingBox.X1 + uVar2),PCB->minSlk);
  Erasing = Erasing + -1;
  return;
}



void __regparm3 DrawPadNameLowLevel(PadTypePtr *Pad)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  int iVar6;
  int iVar7;
  int in_GS_OFFSET;
  ulong local_6c;
  undefined4 local_68;
  undefined4 local_64;
  TextType text;
  
  pcVar5 = Pad->Name;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) || ((*(byte *)&(PCB->Flags).f & 1) != 0)) &&
     (pcVar5 = Pad->Number, pcVar5 == (char *)0x0)) {
    pcVar5 = "";
  }
  iVar2 = (Pad->Point1).X;
  iVar3 = (Pad->Point2).X;
  if (iVar2 == iVar3) {
    iVar4 = Pad->Thickness / 2;
    iVar6 = (iVar2 + Settings.PinoutTextOffsetY) - iVar4;
    iVar7 = (Pad->Point2).Y;
    if (iVar7 <= (Pad->Point1).Y) {
      iVar7 = (Pad->Point1).Y;
    }
    iVar4 = (iVar7 - Settings.PinoutTextOffsetX) + iVar4;
  }
  else {
    iVar7 = -(Pad->Thickness / 2);
    iVar4 = iVar2;
    if (iVar3 <= iVar2) {
      iVar4 = iVar3;
    }
    iVar6 = iVar4 + iVar7 + Settings.PinoutTextOffsetX;
    iVar4 = iVar7 + Settings.PinoutTextOffsetY + (Pad->Point1).Y;
  }
  if (Gathering == '\0') {
    (*gui->set_color)(Output.fgGC,PCB->PinNameColor);
    MakeFlags((FlagType *)&local_6c,0);
    text.Flags.f = local_6c;
    text.Flags.t._0_4_ = local_68;
    text.Flags.t._4_4_ = local_64;
    text.Scale = Pad->Thickness / 0x32;
    text.X = iVar6;
    text.Y = iVar4;
    text.Direction = iVar2 == iVar3;
    text.TextString = pcVar5;
    DrawTextLowLevel((TextTypePtr)&text,0);
    iVar4 = Block.Y2;
  }
  else {
    if (iVar6 <= Block.X1) {
      Block.X1 = iVar6;
    }
    if (iVar6 < Block.X2) {
      iVar6 = Block.X2;
    }
    if (iVar4 <= Block.Y1) {
      Block.Y1 = iVar4;
    }
    Block.X2 = iVar6;
    if (iVar4 < Block.Y2) {
      iVar4 = Block.Y2;
    }
  }
  Block.Y2 = iVar4;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void EraseElementPinsAndPads(ElementTypePtr *Element)

{
  uint uVar1;
  uint uVar2;
  PadTypePtr *Pad;
  PinTypePtr *Ptr;
  int iVar3;
  uint local_20;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  if (Element->PinN != 0) {
    uVar2 = 0;
    local_20 = Element->PinN;
    do {
      Ptr = Element->Pin + uVar2;
      DrawPinOrViaLowLevel(Ptr,'\0');
      if ((*(byte *)&(Ptr->Flags).f & 0x20) == 0) {
        uVar1 = Element->PinN;
      }
      else {
        DrawPinOrViaNameLowLevel(Ptr);
        uVar1 = Element->PinN;
      }
    } while ((uVar1 != 0) &&
            (uVar2 = (uVar1 + 1 + uVar2) - local_20, local_20 = uVar1, uVar2 < uVar1));
  }
  uVar2 = Element->PadN;
  iVar3 = 0;
  local_20 = 0;
  uVar1 = uVar2;
LAB_0808c82b:
  do {
    if ((uVar1 == 0) || (uVar1 <= local_20)) {
      Erasing = Erasing + -1;
      return;
    }
    Pad = (PadTypePtr *)((int)&(Element->Pad->BoundingBox).X1 + iVar3);
    DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
    if ((*(byte *)&(Pad->Flags).f & 0x20) == 0) goto LAB_0808c820;
    DrawPadNameLowLevel(Pad);
    uVar1 = Element->PadN;
  } while (Element->PadN != uVar2);
  goto LAB_0808c869;
LAB_0808c820:
  uVar1 = Element->PadN;
  if (Element->PadN == uVar2) {
LAB_0808c869:
    local_20 = local_20 + 1;
    iVar3 = iVar3 + 0x68;
    uVar1 = uVar2;
  }
  goto LAB_0808c82b;
}



void ErasePadName(PadTypePtr *Pad)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPadNameLowLevel(Pad);
  Erasing = Erasing + -1;
  return;
}



void ErasePad(PadTypePtr *Pad)

{
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
  if ((*(byte *)&(Pad->Flags).f & 0x20) != 0) {
    DrawPadNameLowLevel(Pad);
  }
  Erasing = Erasing + -1;
  return;
}



void DrawPadName(PadTypePtr *Pad,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Gathering == '\0') {
    uVar1 = (Pad->Flags).f;
    if ((uVar1 & 0x40) == 0) {
      if ((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) {
        pcVar2 = PCB->PinColor;
      }
      else {
        pcVar2 = PCB->InvisibleObjectsColor;
      }
    }
    else {
      pcVar2 = PCB->PinSelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar2);
  }
  DrawPadNameLowLevel(Pad);
  return;
}



void DrawPad(PadTypePtr *Pad,int unused)

{
  uint uVar1;
  char *pcVar2;
  
  if (Gathering != '\0') goto LAB_0808ca25;
  if (doing_pinout == 0) {
    uVar1 = (Pad->Flags).f;
    if ((uVar1 & 0x244) == 0) {
      if ((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) goto LAB_0808ca60;
      pcVar2 = PCB->InvisibleObjectsColor;
    }
    else {
      if ((uVar1 & 0x200) == 0) {
        if ((uVar1 & 0x40) == 0) {
          pcVar2 = PCB->ConnectedColor;
        }
        else {
          pcVar2 = PCB->PinSelectedColor;
        }
      }
      else {
        pcVar2 = PCB->WarnColor;
      }
    }
  }
  else {
LAB_0808ca60:
    pcVar2 = PCB->PinColor;
  }
  (*gui->set_color)(Output.fgGC,pcVar2);
LAB_0808ca25:
  DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
  if ((doing_pinout == 0) && ((*(byte *)&(Pad->Flags).f & 0x20) == 0)) {
    return;
  }
  DrawPadNameLowLevel(Pad);
  return;
}



int pad_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    return 1;
  }
  DrawPad((PadTypePtr *)b,0);
  return 1;
}



int backPad_callback(BoxType *b,void *cl)

{
  if (((uint)b[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide) {
    DrawPad((PadTypePtr *)b,0);
  }
  return 1;
}



void DrawElementPinsAndPads(ElementTypePtr *Element,int unused)

{
  uint uVar1;
  uint uVar2;
  PadTypePtr *Pad;
  uint uVar3;
  int local_24;
  uint local_20;
  
  local_24 = 0;
  local_20 = 0;
  uVar2 = Element->PadN;
  uVar3 = uVar2;
  while ((uVar3 != 0 && (local_20 < uVar3))) {
    Pad = (PadTypePtr *)((int)&(Element->Pad->BoundingBox).X1 + local_24);
    if ((doing_pinout != 0) ||
       (((doing_assy != 0 || (((Pad->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide)) ||
        (PCB->InvisibleObjectsOn != '\0')))) {
      DrawPad(Pad,unused);
      uVar3 = Element->PadN;
    }
    if (uVar2 == uVar3) {
      local_20 = local_20 + 1;
      local_24 = local_24 + 0x68;
      uVar3 = uVar2;
    }
  }
  if (Element->PinN != 0) {
    uVar3 = 0;
    uVar2 = Element->PinN;
    do {
      DrawPin(Element->Pin + uVar3,unused);
      uVar1 = Element->PinN;
      if (uVar1 == 0) {
        return;
      }
      uVar3 = (uVar1 + 1 + uVar3) - uVar2;
      uVar2 = uVar1;
    } while (uVar3 < uVar1);
  }
  return;
}



void EraseElement(ElementTypePtr *Element)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  iVar4 = Element->LineN - 1;
  if (iVar4 != -1) {
    iVar3 = Element->LineN * 0x58;
    do {
      iVar4 = iVar4 + -1;
      DrawLineLowLevel((LineTypePtr)((int)&Element->Line[-1].BoundingBox.X1 + iVar3),'\0');
      iVar3 = iVar3 + -0x58;
    } while (iVar4 != -1);
  }
  iVar4 = Element->ArcN - 1;
  if (iVar4 != -1) {
    iVar3 = Element->ArcN * 0x44;
    do {
      iVar4 = iVar4 + -1;
      DrawArcLowLevel((ArcTypePtr *)((int)&Element->Arc[-1].BoundingBox.X1 + iVar3));
      iVar3 = iVar3 + -0x44;
    } while (iVar4 != -1);
  }
  if ((*(byte *)&(Element->Flags).f & 0x10) == 0) {
    uVar1 = (PCB->Flags).f;
    uVar2 = 0x3c;
    if ((uVar1 & 0x40) == 0) {
      uVar2 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
    }
    DrawTextLowLevel((TextTypePtr)((int)&Element->Name[0].BoundingBox.X1 + uVar2),PCB->minSlk);
  }
  EraseElementPinsAndPads(Element);
  Erasing = Erasing + -1;
  return;
}



void EraseText(LayerTypePtr Layer,TextTypePtr Text)

{
  DataTypePtr *pDVar1;
  int min_line_width;
  
  Erasing = Erasing + 1;
  (*gui->set_color)(Output.fgGC,Settings.BackgroundColor);
  pDVar1 = PCB->Data;
  if (((LayerTypePtr)
       (&pDVar1->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + pDVar1->LayerN) * 0x5c) ==
       Layer) ||
     ((LayerTypePtr)
      (&pDVar1->field_0x4c + ((uint)(Settings.ShowSolderSide != '\0') + pDVar1->LayerN) * 0x5c) ==
      Layer)) {
    min_line_width = PCB->minSlk;
  }
  else {
    min_line_width = PCB->minWid;
  }
  DrawTextLowLevel(Text,min_line_width);
  Erasing = Erasing + -1;
  return;
}



void EraseObject(int type,void *lptr,void *ptr)

{
  if (type == 0x20) {
LAB_0808cde8:
    EraseLine((LineTypePtr)ptr);
    return;
  }
  if (type < 0x21) {
    if (type == 4) goto LAB_0808cde8;
    if (type < 5) {
      if (type == 1) goto LAB_0808ce88;
      if (type == 2) {
        EraseElement((ElementTypePtr *)ptr);
        return;
      }
    }
    else {
      if (type == 8) {
        ErasePolygon((PolygonTypePtr)ptr);
        return;
      }
      if (type == 0x10) goto LAB_0808ce12;
    }
  }
  else {
    if (type == 0x400) {
LAB_0808ce12:
      EraseText((LayerTypePtr)lptr,(TextTypePtr)ptr);
      return;
    }
    if (type < 0x401) {
      if (type == 0x100) {
LAB_0808ce88:
        ErasePin((PinTypePtr *)ptr);
        return;
      }
      if (type == 0x200) {
        ErasePad((PadTypePtr *)ptr);
        return;
      }
    }
    else {
      if ((type == 0x4000) || (type == 0x8000)) {
        EraseArc((ArcTypePtr *)ptr);
        return;
      }
      if (type == 0x2000) goto LAB_0808cde8;
    }
  }
  Message("hace: Internal ERROR, trying to erase an unknown type\n");
  return;
}



void DrawElementName(ElementTypePtr *Element,int unused)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  if ((((*(byte *)&gui->field_0xc & 1) == 0) || ((*(byte *)((int)&(PCB->Flags).f + 2) & 0x20) == 0))
     && (uVar1 = (Element->Flags).f, (uVar1 & 0x10) == 0)) {
    if ((doing_pinout == 0) && (doing_assy == 0)) {
      uVar3 = 0x3c;
      uVar2 = (PCB->Flags).f;
      if ((uVar2 & 0x40) == 0) {
        uVar3 = -(uint)((uVar2 & 0x20) == 0) & 0x78;
      }
      if ((*(byte *)((int)&Element->Name[0].Flags.f + uVar3) & 0x40) == 0) {
        if ((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) {
          (*gui->set_color)(Output.fgGC,PCB->ElementColor);
        }
        else {
          (*gui->set_color)(Output.fgGC,PCB->InvisibleObjectsColor);
        }
      }
      else {
        (*gui->set_color)(Output.fgGC,PCB->ElementSelectedColor);
      }
    }
    else {
      (*gui->set_color)(Output.fgGC,PCB->ElementColor);
    }
    uVar1 = (PCB->Flags).f;
    uVar2 = 0x3c;
    if ((uVar1 & 0x40) == 0) {
      uVar2 = -(uint)((uVar1 & 0x20) == 0) & 0x78;
    }
    DrawTextLowLevel((TextTypePtr)((int)&Element->Name[0].BoundingBox.X1 + uVar2),PCB->minSlk);
    return;
  }
  return;
}



int frontN_callback(BoxType *b,void *cl)

{
  uint uVar1;
  
  uVar1 = (((ElementTypePtr *)b[3].X2)->Flags).f;
  if (((uVar1 >> 7 & 1) == (int)Settings.ShowSolderSide) && ((uVar1 & 0x10) == 0)) {
    DrawElementName((ElementTypePtr *)b[3].X2,0);
    return 0;
  }
  return 0;
}



int backN_callback(BoxType *b,void *cl)

{
  uint uVar1;
  
  uVar1 = (((ElementTypePtr *)b[3].X2)->Flags).f;
  if (((uVar1 >> 7 & 1) != (int)Settings.ShowSolderSide) && ((uVar1 & 0x10) == 0)) {
    DrawElementName((ElementTypePtr *)b[3].X2,0);
    return 0;
  }
  return 0;
}



void DrawElement(ElementTypePtr *Element,int unused)

{
  DrawElementPackage(Element,unused);
  DrawElementName(Element,unused);
  DrawElementPinsAndPads(Element,unused);
  return;
}



void DrawText(LayerTypePtr Layer,TextTypePtr Text,int unused)

{
  DataTypePtr *pDVar1;
  char *pcVar2;
  int min_line_width;
  
  if (Layer->On != '\0') {
    if ((*(byte *)&(Text->Flags).f & 0x40) == 0) {
      pcVar2 = Layer->Color;
    }
    else {
      pcVar2 = Layer->SelectedColor;
    }
    (*gui->set_color)(Output.fgGC,pcVar2);
    pDVar1 = PCB->Data;
    if (((LayerTypePtr)
         (&pDVar1->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + pDVar1->LayerN) * 0x5c)
         == Layer) ||
       ((LayerTypePtr)
        (&pDVar1->field_0x4c + ((uint)(Settings.ShowSolderSide != '\0') + pDVar1->LayerN) * 0x5c) ==
        Layer)) {
      min_line_width = PCB->minSlk;
    }
    else {
      min_line_width = PCB->minWid;
    }
    DrawTextLowLevel(Text,min_line_width);
    return;
  }
  return;
}



void DrawObject(int type,void *ptr1,void *ptr2,int unused)

{
  if (type == 0x10) {
    if (*(char *)((int)ptr1 + 0x44) != '\0') {
      DrawText((LayerTypePtr)ptr1,(TextTypePtr)ptr2,0);
      return;
    }
  }
  else {
    if (type < 0x11) {
      if (type == 2) {
        if ((PCB->ElementOn != '\0') &&
           (((*(uint *)((int)ptr2 + 0x14) >> 7 & 1) == (int)Settings.ShowSolderSide ||
            (PCB->InvisibleObjectsOn != '\0')))) {
          DrawElement((ElementTypePtr *)ptr2,0);
          return;
        }
      }
      else {
        if (type < 3) {
          if ((type == 1) && (PCB->ViaOn != '\0')) {
            DrawVia((PinTypePtr *)ptr2,0);
            return;
          }
        }
        else {
          if (type == 4) {
            if (*(char *)((int)ptr1 + 0x44) != '\0') {
              DrawLine((LayerTypePtr)ptr1,(LineTypePtr)ptr2,0);
              return;
            }
          }
          else {
            if ((type == 8) && (*(char *)((int)ptr1 + 0x44) != '\0')) {
              DrawPolygon((LayerTypePtr)ptr1,(PolygonTypePtr)ptr2,0);
              return;
            }
          }
        }
      }
    }
    else {
      if (type == 0x200) {
        if (PCB->PinOn != '\0') {
          DrawPad((PadTypePtr *)ptr2,0);
          return;
        }
      }
      else {
        if (type < 0x201) {
          if (type == 0x20) {
            if (PCB->RatOn != '\0') {
              DrawRat((RatTypePtr *)ptr2,0);
              return;
            }
          }
          else {
            if ((type == 0x100) && (PCB->PinOn != '\0')) {
              DrawPin((PinTypePtr *)ptr2,0);
              return;
            }
          }
        }
        else {
          if (type == 0x400) {
            if ((PCB->ElementOn != '\0') &&
               (((*(uint *)((int)ptr2 + 0x14) >> 7 & 1) == (int)Settings.ShowSolderSide ||
                (PCB->InvisibleObjectsOn != '\0')))) {
              DrawElementName((ElementTypePtr *)ptr1,0);
              return;
            }
          }
          else {
            if ((type == 0x4000) && (*(char *)((int)ptr1 + 0x44) != '\0')) {
              DrawArc((LayerTypePtr)ptr1,(ArcTypePtr *)ptr2,0);
              return;
            }
          }
        }
      }
    }
  }
  return;
}



void Draw(void)

{
  render = '\x01';
  HideCrosshair('\x01');
  (*gui->invalidate_lr)(Block.X1,Block.X2,Block.Y1,Block.Y2,1);
  RestoreCrosshair('\x01');
  Block.X1 = 0;
  Block.Y1 = 0;
  Block.X2 = 0;
  Block.Y2 = 0;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void hid_expose_callback(HID *hid,BoxType *region,void *item)

{
  Cardinal Layer;
  HID *pHVar1;
  HID *pHVar2;
  Boolean BVar3;
  PCBTypePtr pPVar4;
  hidGC phVar5;
  hidGC phVar6;
  hidGC phVar7;
  int iVar8;
  int group;
  uint uVar9;
  DataTypePtr *pDVar10;
  int side_group;
  uint uVar11;
  uint uVar12;
  PadTypePtr *Pad;
  int side_group_00;
  int *piVar13;
  uint uVar14;
  byte bVar15;
  int local_c4;
  HID *local_c0;
  char local_b9;
  int local_b8;
  int local_b4;
  uint *local_b0;
  int drawn_groups [16];
  int do_group [16];
  HoleCountStruct hcs;
  undefined4 local_20 [4];
  
  phVar7 = Output.pmGC;
  phVar6 = Output.fgGC;
  phVar5 = Output.bgGC;
  pHVar1 = gui;
  bVar15 = 0;
  gui = hid;
  Output.fgGC = (*hid->make_gc)();
  Output.bgGC = (*gui->make_gc)();
  Output.pmGC = (*gui->make_gc)();
  render = '\x01';
  Gathering = '\0';
  (*hid->set_color)(Output.pmGC,"erase");
  (*hid->set_color)(Output.bgGC,"drill");
  pPVar4 = PCB;
  if (item == (void *)0x0) {
    pDVar10 = PCB->Data;
    *(char **)(&pDVar10->field_0x94 +
              ((uint)(Settings.ShowSolderSide == '\0') + pDVar10->LayerN) * 0x5c) =
         PCB->ElementColor;
    *(char **)(&pDVar10->field_0x94 +
              ((uint)(Settings.ShowSolderSide != '\0') + pDVar10->LayerN) * 0x5c) =
         pPVar4->InvisibleObjectsColor;
    side_group = 0x10;
    piVar13 = do_group;
    while (side_group != 0) {
      side_group = side_group + -1;
      *piVar13 = 0;
      piVar13 = piVar13 + (uint)bVar15 * 0x3ffffffe + 1;
    }
    local_b4 = -1;
    pDVar10 = pPVar4->Data;
    side_group = pDVar10->LayerN;
    if (0 < side_group) {
      local_b4 = 0;
      side_group_00 = 0;
      do {
        Layer = LayerStack[side_group_00];
        side_group = GetLayerGroupNumberByNumber(Layer);
        if ((*(char *)(&pDVar10->field_0x90 + Layer * 0x5c) != '\0') && (do_group[side_group] == 0))
        {
          do_group[side_group] = 1;
          drawn_groups[local_b4] = side_group;
          local_b4 = local_b4 + 1;
        }
        side_group_00 = side_group_00 + 1;
        pDVar10 = PCB->Data;
        side_group = pDVar10->LayerN;
      } while (side_group_00 < side_group);
      local_b4 = local_b4 + -1;
    }
    side_group = GetLayerGroupNumberByNumber(side_group + 1);
    side_group_00 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    if ((((*(byte *)&(PCB->Flags).f & 4) == 0) &&
        (group = (*gui->set_layer)("invisible",-4000,0), group != 0)) &&
       (r_search(PCB->Data->pad_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 backPad_callback,(void *)0x0), PCB->ElementOn != '\0')) {
      r_search(PCB->Data->element_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               backE_callback,(void *)0x0);
      uVar9 = (PCB->Flags).f;
      uVar12 = 1;
      if ((uVar9 & 0x40) == 0) {
        uVar12 = -(uint)((uVar9 & 0x20) == 0) & 2;
      }
      r_search(PCB->Data->name_tree[uVar12],region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               backN_callback,(void *)0x0);
      DrawLayer((LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide != '\0') + PCB->Data->LayerN) * 0x5c),region);
    }
    if (local_b4 != -1) {
      piVar13 = drawn_groups + local_b4;
      do {
        group = *piVar13;
        iVar8 = (*gui->set_layer)((char *)0x0,group,0);
        if (((iVar8 != 0) &&
            (iVar8 = DrawLayerGroup(group,region), BVar3 = Settings.ShowSolderSide,
            Settings.ShowSolderSide = BVar3, iVar8 != 0)) && ((*(byte *)&gui->field_0xc & 1) == 0))
        {
          r_search(PCB->Data->pin_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pin_callback
                   ,(void *)0x0);
          r_search(PCB->Data->via_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pin_callback
                   ,(void *)0x0);
          if ((side_group_00 == group) || (side_group == group)) {
            Settings.ShowSolderSide = side_group_00 == group;
            r_search(PCB->Data->pad_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     pad_callback,(void *)0x0);
          }
          Settings.ShowSolderSide = BVar3;
          if ((*(byte *)&gui->field_0xc & 1) == 0) {
            local_20[0] = 0xffffffff;
            r_search(PCB->Data->pin_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     hole_callback,local_20);
            r_search(PCB->Data->via_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     hole_callback,local_20);
          }
        }
        local_b4 = local_b4 + -1;
        piVar13 = piVar13 + -1;
      } while (local_b4 != -1);
    }
    if (((*(byte *)&(PCB->Flags).f & 4) == 0) || ((*(byte *)&gui->field_0xc & 1) == 0)) {
      if ((PCB->ViaOn != '\0') && ((*(byte *)&gui->field_0xc & 1) != 0)) {
        r_search(PCB->Data->via_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 lowvia_callback,(void *)0x0);
      }
      group = (*gui->set_layer)("componentmask",-0xfdf,0);
      BVar3 = Settings.ShowSolderSide;
      if (group != 0) {
        Settings.ShowSolderSide = '\0';
        DrawMask(region);
      }
      Settings.ShowSolderSide = BVar3;
      group = (*gui->set_layer)("soldermask",-0xfde,0);
      BVar3 = Settings.ShowSolderSide;
      if (group != 0) {
        Settings.ShowSolderSide = '\x01';
        DrawMask(region);
      }
      Settings.ShowSolderSide = BVar3;
      if ((*(byte *)&gui->field_0xc & 1) == 0) {
        hcs.nunplated = 0;
        hcs.nplated = 0;
        r_search(PCB->Data->pin_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 hole_counting_callback,&hcs);
        r_search(PCB->Data->via_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 hole_counting_callback,&hcs);
        if ((hcs.nplated != 0) && (group = (*gui->set_layer)("plated-drill",-0xfd0,0), group != 0))
        {
          local_20[0] = 1;
          r_search(PCB->Data->pin_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   hole_callback,local_20);
          r_search(PCB->Data->via_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   hole_callback,local_20);
        }
        if ((hcs.nunplated != 0) &&
           (group = (*gui->set_layer)("unplated-drill",-0xfc0,0), group != 0)) {
          local_20[0] = 0;
          r_search(PCB->Data->pin_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   hole_callback,local_20);
          r_search(PCB->Data->via_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   hole_callback,local_20);
        }
      }
      else {
        DrawTop(region);
      }
      group = (*gui->set_layer)("topsilk",-0xfef,0);
      if (group != 0) {
        DrawSilk(0,1,(BoxTypePtr)region);
      }
      group = (*gui->set_layer)("bottomsilk",-0xfee,0);
      if (group != 0) {
        DrawSilk(1,0,(BoxTypePtr)region);
      }
      local_c0 = gui;
      if ((*(byte *)&gui->field_0xc & 1) != 0) {
        if (PCB->PinOn != '\0') {
          r_search(PCB->Data->element_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   EMark_callback,(void *)0x0);
        }
        pPVar4 = PCB;
        pHVar2 = gui;
        local_c0 = gui;
        if (PCB->RatOn != '\0') {
          group = strcmp(gui->name,"lesstif");
          if (group == 0) {
            (*pHVar2->use_mask)(2);
            r_search(PCB->Data->rat_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     rat_callback,(void *)0x0);
            (*gui->use_mask)(0);
            local_c0 = gui;
          }
          else {
            r_search(pPVar4->Data->rat_tree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     rat_callback,(void *)0x0);
            local_c0 = gui;
          }
        }
      }
      local_b4 = 0;
      do {
        Layer = PCB->Data->ElementN;
        local_b8 = Layer - 1;
        group = 1;
        if (local_b8 != -1) {
          local_b9 = '\x01';
          local_b0 = &PCB->Data->Element[Layer - 1].PadN;
          do {
            if (*local_b0 != 0) {
              uVar9 = local_b0[7];
              uVar12 = *(uint *)(uVar9 + 0x14) & 0x80;
              if (((local_b4 == 0) && (uVar12 != 0)) || (((char)local_b4 != '\0' && (uVar12 == 0))))
              {
LAB_0808dbf0:
                local_b9 = '\0';
              }
              else {
                uVar12 = 1;
                while (uVar12 < *local_b0) {
                  uVar11 = *(uint *)(uVar9 + 0x7c) & 0x80;
                  if (((local_b4 == 0) && (uVar11 != 0)) ||
                     ((uVar9 = uVar9 + 0x68, (char)local_b4 != '\0' && (uVar11 == 0))))
                  goto LAB_0808dbf0;
                  uVar12 = uVar12 + 1;
                }
              }
            }
            local_b8 = local_b8 + -1;
            local_b0 = local_b0 + -0x4b;
          } while (local_b8 != -1);
          group = (int)local_b9;
        }
        gui = local_c0;
        if (local_b4 == 0) {
          group = (*local_c0->set_layer)("bottompaste",-0xfae,group);
        }
        else {
          group = (*local_c0->set_layer)("toppaste",-0xfaf,group);
        }
        if (group != 0) {
          (*gui->set_color)(Output.fgGC,PCB->ElementColor);
          pDVar10 = PCB->Data;
          local_c0 = (HID *)(pDVar10->ElementN - 1);
          if (local_c0 != (HID *)0xffffffff) {
            group = pDVar10->ElementN * 300;
            while( true ) {
              local_c4 = group + -300;
              iVar8 = 0;
              group = (int)&pDVar10->Element[-1].BoundingBox.X1 + group;
              local_b0 = (uint *)0x0;
              uVar9 = *(uint *)(group + 0xe8);
              uVar12 = uVar9;
              while ((uVar12 != 0 && (local_b0 < uVar12))) {
                Pad = (PadTypePtr *)(*(int *)(group + 0x104) + iVar8);
                uVar11 = (Pad->Flags).f;
                uVar14 = uVar11 & 0x80;
                if ((((local_b4 == 0) && (uVar14 != 0)) ||
                    (((char)local_b4 != '\0' && (uVar14 == 0)))) && ((uVar11 & 8) == 0)) {
                  DrawPadLowLevel(Output.fgGC,Pad,'\0','\0');
                  uVar12 = *(uint *)(group + 0xe8);
                }
                if (uVar9 == uVar12) {
                  local_b0 = (uint *)((int)local_b0 + 1);
                  iVar8 = iVar8 + 0x68;
                  uVar12 = uVar9;
                }
              }
              local_c0 = (HID *)((int)local_c0 + -1);
              if (local_c0 == (HID *)0xffffffff) break;
              pDVar10 = PCB->Data;
              group = local_c4;
            }
          }
        }
        local_b4 = local_b4 + 1;
        if (local_b4 == 2) goto LAB_0808dd8e;
        local_c0 = gui;
      } while( true );
    }
  }
  else {
    doing_pinout = 1;
    DrawElement((ElementTypePtr *)item,0);
    doing_pinout = 0;
  }
LAB_0808d529:
  (*gui->destroy_gc)(Output.fgGC);
  (*gui->destroy_gc)(Output.bgGC);
  (*gui->destroy_gc)(Output.pmGC);
  Gathering = '\x01';
  gui = pHVar1;
  Output.bgGC = phVar5;
  Output.fgGC = phVar6;
  Output.pmGC = phVar7;
  return;
LAB_0808dd8e:
  doing_assy = 1;
  group = (*gui->set_layer)("topassembly",-0xf7f,0);
  if (group != 0) {
    PrintAssembly(region,side_group,0);
  }
  side_group = (*gui->set_layer)("bottomassembly",-0xf7e,0);
  if (side_group != 0) {
    PrintAssembly(region,side_group_00,1);
  }
  doing_assy = 0;
  side_group = (*gui->set_layer)("fab",-0xf90,0);
  if (side_group != 0) {
    PrintFab();
  }
  goto LAB_0808d529;
}



void __regparm3 DrawPlainVia(PinTypePtr *Via)

{
  if (Gathering == '\0') {
    SetPVColor(Via,1);
  }
  DrawPinOrViaLowLevel(Via,'\0');
  if (((Via->Flags).f & 0x28) != 0x20) {
    return;
  }
  DrawPinOrViaNameLowLevel(Via);
  return;
}



int lowvia_callback(BoxType *b,void *cl)

{
  if (b[2].Y2 == 0) {
    DrawPlainVia((PinTypePtr *)b);
  }
  return 1;
}



int via_callback(BoxType *b,void *cl)

{
  if (b[2].Y2 != 0) {
    DrawPlainVia((PinTypePtr *)b);
  }
  return 1;
}



int clearPin_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if ((*(char *)cl != '\0') && (iVar2 = b[2].Y2 / 2, iVar2 != 0)) {
    if ((b[1].Y1 & 0x100U) == 0) {
      if ((b[1].Y1 & 0x800U) == 0) {
        if (((PCB->Flags).f & 0x24000) == 0) {
          (*gui->fill_circle)(Output.pmGC,b[3].Y1,b[3].X2,iVar2);
        }
        else {
          (*gui->draw_arc)(Output.pmGC,b[3].Y1,b[3].X2,iVar2,iVar2,0,0x168);
        }
      }
      else {
        (*gui->set_line_cap)(Output.pmGC,Round_Cap);
        (*gui->set_line_width)(Output.pmGC,(b[2].Y1 + b[2].X2) - b[3].X1);
        DrawSpecialPolygon(gui,Output.pmGC,b[3].Y1,b[3].X2,iVar2 * 2);
      }
    }
    else {
      iVar4 = b[3].Y1 - iVar2;
      iVar3 = b[3].X2 - iVar2;
      iVar1 = iVar2 * 2 + iVar4;
      iVar2 = iVar2 * 2 + iVar3;
      if (((PCB->Flags).f & 0x24000) == 0) {
        (*gui->fill_rect)(Output.pmGC,iVar4,iVar3,iVar1,iVar2);
      }
      else {
        (*gui->set_line_cap)(Output.pmGC,Round_Cap);
        (*gui->set_line_width)(Output.pmGC,0);
        (*gui->draw_line)(Output.pmGC,iVar1,iVar2,iVar1,iVar3);
        (*gui->draw_line)(Output.pmGC,iVar4,iVar2,iVar4,iVar3);
        (*gui->draw_line)(Output.pmGC,iVar1,iVar2,iVar4,iVar2);
        (*gui->draw_line)(Output.pmGC,iVar1,iVar3,iVar4,iVar3);
      }
    }
  }
  return 1;
}



int DrillQSort(void *va,void *vb)

{
  return *(int *)va - *(int *)vb;
}



void FreeDrillInfo(DrillInfoTypePtr *Drills)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  
  if (Drills->DrillN != 0) {
    iVar2 = 0;
    uVar3 = 0;
    do {
      iVar1 = (int)&Drills->Drill->DrillSize + iVar2;
      SaveFree(*(void **)(iVar1 + 0x24));
      *(undefined4 *)(iVar1 + 0x24) = 0;
      SaveFree(*(void **)(iVar1 + 0x20));
      *(undefined4 *)(iVar1 + 0x20) = 0;
      if (Drills->DrillN == 0) break;
      uVar3 = uVar3 + 1;
      iVar2 = iVar2 + 0x28;
    } while (uVar3 < Drills->DrillN);
  }
  SaveFree(Drills->Drill);
  Drills->Drill = (DrillTypePtr)0x0;
  SaveFree(Drills);
  return;
}



// WARNING: Type propagation algorithm not settling

void RoundDrillInfo(DrillInfoTypePtr *d,int roundto)

{
  int iVar1;
  DrillTypePtr pDVar2;
  PinTypePtr **ppPVar3;
  ElementTypePtr **ppEVar4;
  uint uVar5;
  uint uVar6;
  DrillTypePtr pDVar7;
  ElementTypePtr *pEVar8;
  Cardinal CVar9;
  uint uVar10;
  ElementTypePtr *pEVar11;
  uint uVar12;
  DrillTypePtr pDVar13;
  uint local_24;
  
  local_24 = 0;
  CVar9 = d->DrillN;
  do {
    while( true ) {
      if ((CVar9 == 0) || (CVar9 - 1 <= local_24)) {
        return;
      }
      pDVar13 = d->Drill + local_24;
      uVar6 = local_24 + 1;
      pDVar2 = d->Drill + uVar6;
      iVar1 = ((roundto / 2 + pDVar13->DrillSize) / roundto) * roundto;
      if (iVar1 == ((roundto / 2 + pDVar2->DrillSize) / roundto) * roundto) break;
      pDVar13->DrillSize = iVar1;
      CVar9 = d->DrillN;
      local_24 = uVar6;
    }
    CVar9 = pDVar2->ElementN + pDVar13->ElementN;
    pDVar13->ElementMax = CVar9;
    if (CVar9 != 0) {
      ppEVar4 = (ElementTypePtr **)MyRealloc(pDVar13->Element,CVar9 * 4,"RoundDrillInfo");
      pDVar7 = d->Drill;
      pDVar13->Element = ppEVar4;
      pDVar2 = pDVar7 + uVar6;
      if (pDVar2->ElementN != 0) {
        pDVar7 = pDVar7 + local_24;
        uVar12 = 0;
        do {
          uVar10 = pDVar7->ElementN;
          if (uVar10 == 0) {
            pEVar11 = (ElementTypePtr *)pDVar7->Element;
            pEVar8 = pDVar2->Element[uVar12];
            CVar9 = 1;
LAB_0808e79a:
            *(ElementTypePtr **)((int)pEVar11 + uVar10) = pEVar8;
            pDVar7->ElementN = CVar9;
          }
          else {
            pEVar11 = (ElementTypePtr *)pDVar7->Element;
            pEVar8 = pDVar2->Element[uVar12];
            uVar5 = 0;
            if (*(ElementTypePtr **)&pEVar11->BoundingBox != pEVar8) {
              do {
                uVar5 = uVar5;
                uVar5 = uVar5 + 1;
                if (uVar10 <= uVar5) break;
              } while (*(ElementTypePtr **)((int)&pEVar11->BoundingBox + uVar5 * 4) != pEVar8);
              if (uVar5 == uVar10) {
                uVar10 = uVar5 * 4;
                CVar9 = uVar5 + 2;
                goto LAB_0808e79a;
              }
            }
          }
          uVar12 = uVar12 + 1;
        } while (uVar12 <= pDVar2->ElementN && pDVar2->ElementN != uVar12);
      }
    }
    SaveFree(pDVar2->Element);
    pDVar13 = d->Drill;
    pDVar13[uVar6].Element = (ElementTypePtr **)0x0;
    pDVar2 = pDVar13 + local_24;
    pDVar2->PinMax = pDVar13[uVar6].PinN + pDVar2->PinN;
    ppPVar3 = (PinTypePtr **)MyRealloc(pDVar2->Pin,pDVar2->PinMax << 2,"RoundDrillInfo");
    pDVar13 = d->Drill + uVar6;
    pDVar7 = d->Drill + local_24;
    pDVar2->Pin = ppPVar3;
    memcpy(pDVar7->Pin + pDVar7->PinN,pDVar13->Pin,pDVar13->PinN << 2);
    pDVar2 = d->Drill;
    pDVar2[local_24].PinN = pDVar2[local_24].PinN + pDVar2[uVar6].PinN;
    SaveFree(pDVar2[uVar6].Pin);
    pDVar13 = d->Drill;
    pDVar2 = pDVar13 + local_24;
    pDVar2->PinCount = pDVar2->PinCount + pDVar13[uVar6].PinCount;
    pDVar2->ViaCount = pDVar2->ViaCount + pDVar13[uVar6].ViaCount;
    pDVar2->UnplatedCount = pDVar2->UnplatedCount + pDVar13[uVar6].UnplatedCount;
    pDVar13[uVar6].Pin = (PinTypePtr **)0x0;
    pDVar13[local_24].DrillSize = iVar1;
    memmove(pDVar13 + uVar6,pDVar13 + local_24 + 2,(d->DrillN - local_24) * 0x28 - 0x50);
    CVar9 = d->DrillN - 1;
    d->DrillN = CVar9;
  } while( true );
}



void __regparm3 InitializeDrill(DrillTypePtr drill,PinTypePtr *pin,ElementTypePtr *element)

{
  BDimension BVar1;
  PinTypeHandle **ppPVar2;
  ElementTypeHandle **ppEVar3;
  
  BVar1 = pin->DrillingHole;
  drill->Element = (ElementTypePtr **)0x0;
  drill->ElementN = 0;
  drill->ViaCount = 0;
  drill->DrillSize = BVar1;
  drill->PinCount = 0;
  drill->UnplatedCount = 0;
  drill->ElementMax = 0;
  drill->PinN = 0;
  drill->Pin = (PinTypePtr **)0x0;
  drill->PinMax = 0;
  ppPVar2 = GetDrillPinMemory((DrillTypePtr_conflict *)drill);
  *(PinTypePtr **)ppPVar2 = pin;
  if (element == (ElementTypePtr *)0x0) {
    drill->ViaCount = 1;
  }
  else {
    ppEVar3 = GetDrillElementMemory((DrillTypePtr_conflict *)drill);
    drill->PinCount = 1;
    *(ElementTypePtr **)ppEVar3 = element;
  }
  if ((*(byte *)&(pin->Flags).f & 8) != 0) {
    drill->UnplatedCount = 1;
  }
  return;
}



void __regparm3 FillDrill(DrillTypePtr Drill,ElementTypePtr *Element,PinTypePtr *Pin)

{
  ElementTypePtr *pEVar1;
  PinTypeHandle **ppPVar2;
  int iVar3;
  ElementTypeHandle **ppEVar4;
  ElementTypePtr **ppEVar5;
  
  ppPVar2 = GetDrillPinMemory((DrillTypePtr_conflict *)Drill);
  *(PinTypePtr **)ppPVar2 = Pin;
  if (Element == (ElementTypePtr *)0x0) {
    Drill->ViaCount = Drill->ViaCount + 1;
  }
  else {
    Drill->PinCount = Drill->PinCount + 1;
    iVar3 = Drill->ElementN - 1;
    if (iVar3 == -1) {
LAB_0808e8c1:
      ppEVar4 = GetDrillElementMemory((DrillTypePtr_conflict *)Drill);
      *(ElementTypePtr **)ppEVar4 = Element;
    }
    else {
      pEVar1 = Drill->Element[iVar3];
      ppEVar5 = Drill->Element + (Drill->ElementN - 2);
      while (pEVar1 != Element) {
        iVar3 = iVar3 + -1;
        if (iVar3 == -1) goto LAB_0808e8c1;
        pEVar1 = *ppEVar5;
        ppEVar5 = ppEVar5 + -1;
      }
    }
  }
  if ((*(byte *)&(Pin->Flags).f & 8) != 0) {
    Drill->UnplatedCount = Drill->UnplatedCount + 1;
  }
  return;
}



DrillInfoTypePtr * GetDrillInfo(DataTypePtr *top)

{
  ElementTypePtr **ppEVar1;
  PinTypePtr **ppPVar2;
  Cardinal CVar3;
  Cardinal CVar4;
  Cardinal CVar5;
  Cardinal CVar6;
  Cardinal CVar7;
  Cardinal CVar8;
  Cardinal CVar9;
  bool bVar10;
  bool bVar11;
  DrillInfoTypePtr *DrillInfo;
  PinTypePtr *pin;
  Cardinal CVar12;
  BDimension BVar13;
  DrillTypePtr_conflict *pDVar14;
  ElementTypePtr *element;
  int iVar15;
  uint uVar16;
  DrillTypePtr Drill;
  int iVar17;
  int local_90;
  int local_8c;
  uint local_84;
  DrillTypePtr local_80;
  uint local_78;
  uint local_58;
  uint local_50;
  DrillType swapdrill;
  
  DrillInfo = (DrillInfoTypePtr *)MyCalloc(1,0xc,"GetAllDrillInfo()");
  bVar11 = false;
  local_80 = (DrillTypePtr)0x0;
  local_8c = top->ElementN - 1;
  if (local_8c != -1) {
    iVar15 = top->ElementN * 300;
    do {
      local_90 = iVar15 + -300;
      element = (ElementTypePtr *)((int)&top->Element[-1].BoundingBox.X1 + iVar15);
      if (element->PinN != 0) {
        local_78 = 0;
        local_84 = element->PinN;
        do {
          pin = element->Pin + local_78;
          if (bVar11) {
            iVar15 = pin->DrillingHole;
            if (local_80->DrillSize == iVar15) {
              FillDrill(local_80,element,pin);
            }
            else {
              CVar12 = 0;
              if (DrillInfo->DrillN == 0) {
LAB_0808eae6:
                if ((&DrillInfo->Drill->DrillSize)[(CVar12 * 5 + -5) * 2] < iVar15) {
LAB_0808ec98:
                  local_80 = (DrillTypePtr)GetDrillInfoDrillMemory(DrillInfo);
                  InitializeDrill(local_80,pin,element);
                }
              }
              else {
                Drill = DrillInfo->Drill;
                BVar13 = Drill->DrillSize;
                if (iVar15 != BVar13) {
                  iVar17 = 0x28;
                  bVar10 = false;
                  local_50 = 0;
                  do {
                    if (BVar13 <= iVar15) {
                      iVar15 = pin->DrillingHole;
                      CVar12 = DrillInfo->DrillN;
                      if (CVar12 != 0) goto LAB_0808e9f0;
LAB_0808eae0:
                      iVar15 = pin->DrillingHole;
                      goto LAB_0808eae6;
                    }
                    if (bVar10) {
                      iVar15 = pin->DrillingHole;
                    }
                    else {
                      InitializeDrill((DrillTypePtr)&swapdrill,pin,element);
                      pDVar14 = GetDrillInfoDrillMemory(DrillInfo);
                      iVar15 = pin->DrillingHole;
                      pDVar14->DrillSize = iVar15 + 1;
                      BVar13 = Drill->DrillSize;
                      local_80 = Drill;
                    }
                    ppEVar1 = Drill->Element;
                    ppPVar2 = Drill->Pin;
                    CVar3 = Drill->PinMax;
                    CVar4 = Drill->PinN;
                    CVar5 = Drill->UnplatedCount;
                    CVar6 = Drill->ViaCount;
                    CVar7 = Drill->PinCount;
                    CVar8 = Drill->ElementMax;
                    CVar9 = Drill->ElementN;
                    Drill->DrillSize = swapdrill.DrillSize;
                    Drill->ElementN = swapdrill.ElementN;
                    Drill->ElementMax = swapdrill.ElementMax;
                    Drill->PinCount = swapdrill.PinCount;
                    Drill->ViaCount = swapdrill.ViaCount;
                    Drill->UnplatedCount = swapdrill.UnplatedCount;
                    Drill->PinN = swapdrill.PinN;
                    Drill->PinMax = swapdrill.PinMax;
                    Drill->Pin = swapdrill.Pin;
                    Drill->Element = swapdrill.Element;
                    CVar12 = DrillInfo->DrillN;
                    bVar10 = true;
                    swapdrill.DrillSize = BVar13;
                    swapdrill.ElementN = CVar9;
                    swapdrill.ElementMax = CVar8;
                    swapdrill.PinCount = CVar7;
                    swapdrill.ViaCount = CVar6;
                    swapdrill.UnplatedCount = CVar5;
                    swapdrill.PinN = CVar4;
                    swapdrill.PinMax = CVar3;
                    swapdrill.Pin = ppPVar2;
                    swapdrill.Element = ppEVar1;
                    if (CVar12 == 0) goto LAB_0808eae0;
LAB_0808e9f0:
                    local_50 = local_50 + 1;
                    if (CVar12 <= local_50) goto LAB_0808eae0;
                    Drill = (DrillTypePtr)((int)&DrillInfo->Drill->DrillSize + iVar17);
                    iVar17 = iVar17 + 0x28;
                    BVar13 = Drill->DrillSize;
                  } while (iVar15 != BVar13);
                }
                FillDrill(Drill,element,pin);
                local_80 = Drill;
                if ((&DrillInfo->Drill->DrillSize)[(DrillInfo->DrillN * 5 + -5) * 2] <
                    pin->DrillingHole) goto LAB_0808ec98;
              }
            }
            uVar16 = element->PinN;
          }
          else {
            local_80 = (DrillTypePtr)GetDrillInfoDrillMemory(DrillInfo);
            InitializeDrill(local_80,pin,element);
            bVar11 = true;
            uVar16 = element->PinN;
          }
        } while ((uVar16 != 0) &&
                (local_78 = (uVar16 + 1 + local_78) - local_84, local_84 = uVar16, local_78 < uVar16
                ));
      }
      local_8c = local_8c + -1;
      iVar15 = local_90;
    } while (local_8c != -1);
  }
  if (top->ViaN != 0) {
    local_50 = 0;
    local_58 = top->ViaN;
    do {
      pin = top->Via + local_50;
      if (bVar11) {
        iVar15 = pin->DrillingHole;
        if (local_80->DrillSize == iVar15) {
          FillDrill(local_80,(ElementTypePtr *)0x0,pin);
        }
        else {
          if (DrillInfo->DrillN != 0) {
            local_80 = DrillInfo->Drill;
            uVar16 = 1;
            if (iVar15 == local_80->DrillSize) {
LAB_0808ed30:
              FillDrill(local_80,(ElementTypePtr *)0x0,pin);
              if (local_80->DrillSize == pin->DrillingHole) goto LAB_0808ec3e;
            }
            else {
              while (local_80 = local_80 + 1, uVar16 < DrillInfo->DrillN) {
                if (iVar15 == local_80->DrillSize) goto LAB_0808ed30;
                uVar16 = uVar16 + 1;
              }
            }
          }
          local_80 = (DrillTypePtr)GetDrillInfoDrillMemory(DrillInfo);
          ((DrillTypePtr_conflict *)local_80)->DrillSize = pin->DrillingHole;
          FillDrill(local_80,(ElementTypePtr *)0x0,pin);
        }
LAB_0808ec3e:
        uVar16 = top->ViaN;
      }
      else {
        local_80 = (DrillTypePtr)GetDrillInfoDrillMemory(DrillInfo);
        ((DrillTypePtr_conflict *)local_80)->DrillSize = pin->DrillingHole;
        FillDrill(local_80,(ElementTypePtr *)0x0,pin);
        bVar11 = true;
        uVar16 = top->ViaN;
      }
    } while ((uVar16 != 0) &&
            (local_50 = (uVar16 + 1 + local_50) - local_58, local_58 = uVar16, local_50 < uVar16));
  }
  qsort(DrillInfo->Drill,DrillInfo->DrillN,0x28,DrillQSort);
  return DrillInfo;
}



Context * __regparm3 FindContext(int cod)

{
  Context *pCVar1;
  Context *pCVar2;
  Context *pCVar3;
  
  pCVar2 = ContextHash[cod % 0x7f];
  if ((pCVar2 != (Context *)0x0) && (pCVar1 = pCVar2, (int)pCVar2->Code != cod)) {
    while (pCVar3 = pCVar1, pCVar1 = pCVar3->Next, pCVar1 != (Context *)0x0) {
      if ((int)pCVar1->Code == cod) {
        pCVar3->Next = pCVar1->Next;
        pCVar1->Next = pCVar2;
        ContextHash[cod % 0x7f] = pCVar1;
        return pCVar1;
      }
    }
    pCVar2 = (Context *)0x0;
  }
  return pCVar2;
}



void __regparm3 EnterKeyword(char *str)

{
  Keyword *pKVar1;
  char cVar2;
  Keyword *pKVar3;
  uint uVar4;
  char *pcVar5;
  uint uVar6;
  
  uVar4 = 0;
  uVar6 = 0;
  cVar2 = *str;
  pcVar5 = str;
  if (cVar2 != '\0') {
    do {
      pcVar5 = pcVar5 + 1;
      uVar4 = (int)cVar2 + uVar4 * 2;
      cVar2 = *pcVar5;
    } while (cVar2 != '\0');
    uVar6 = uVar4 % 0x7f;
  }
  pKVar3 = (Keyword *)malloc(8);
  pKVar1 = KeywordTable[uVar6];
  pKVar3->String = str;
  pKVar3->Next = pKVar1;
  KeywordTable[uVar6] = pKVar3;
  return;
}



char * xmalloc(int siz)

{
  char *pcVar1;
  
  pcVar1 = (char *)malloc(siz);
  return pcVar1;
}



pair_list * new_pair_list(str_pair *ps)

{
  pair_list *ppVar1;
  
  ppVar1 = (pair_list *)malloc(8);
  ppVar1->list = ps;
  ppVar1->name = (char *)0x0;
  return ppVar1;
}



str_pair * new_str_pair(char *s1,char *s2)

{
  str_pair *psVar1;
  
  psVar1 = (str_pair *)malloc(0xc);
  psVar1->str1 = s1;
  psVar1->next = (_str_pair *)0x0;
  psVar1->str2 = s2;
  return psVar1;
}



void str_pair_free(str_pair *ps)

{
  _str_pair *p_Var1;
  
  if (ps != (str_pair *)0x0) {
    do {
      free(ps->str1);
      free(ps->str2);
      p_Var1 = ps->next;
      free(ps);
      ps = (str_pair *)p_Var1;
    } while (p_Var1 != (_str_pair *)0x0);
  }
  return;
}



void pair_list_free(pair_list *pl)

{
  str_pair_free(pl->list);
  free(pl->name);
  free(pl);
  return;
}



void define_pcb_net(str_pair *name,pair_list *nodes)

{
  _str_pair *p_Var1;
  LibraryMenuTypePtr *Menu;
  size_t sVar2;
  size_t sVar3;
  __int32_t **pp_Var4;
  LibraryEntryTypePtr *pLVar5;
  char cVar6;
  char *__s;
  _str_pair *__ptr;
  char *__dest;
  
  Menu = GetLibraryMenuMemory((LibraryTypePtr)&PCB->NetlistLib);
  if (name->str1 == (char *)0x0) {
    if (name->str2 != (char *)0x0) {
      free(name->str2);
    }
    free(name);
  }
  else {
    __dest = (char *)__strdup(name->str1);
    Menu->Name = __dest;
    free(name->str1);
    if (name->str2 != (char *)0x0) {
      free(name->str2);
    }
    free(name);
    __dest = (char *)malloc(0x100);
    if (__dest != (char *)0x0) {
      __ptr = (_str_pair *)nodes->list;
      free(nodes->name);
      free(nodes);
      if (__ptr == (_str_pair *)0x0) {
        return;
      }
      __s = __ptr->str1;
      if (__s == (char *)0x0) goto LAB_0808f0d7;
      do {
        sVar2 = strlen(__s);
        sVar3 = strlen(((str_pair *)__ptr)->str2);
        if (0xfd < (int)(sVar3 + sVar2)) {
          free(__dest);
          __dest = (char *)malloc(sVar3 + sVar2 + 3);
          if (__dest == (char *)0x0) {
            str_pair_free((str_pair *)__ptr);
            return;
          }
          __s = ((str_pair *)__ptr)->str1;
        }
        strcpy(__dest,__s);
        cVar6 = *__dest;
        __s = __dest;
        while (cVar6 != '\0') {
          if ((int)cVar6 + 0x80U < 0x180) {
            pp_Var4 = __ctype_toupper_loc();
            cVar6 = (char)(*pp_Var4)[(int)cVar6];
          }
          *__s = cVar6;
          __s = __s + 1;
          cVar6 = *__s;
        }
        sVar2 = strlen(((str_pair *)__ptr)->str1);
        __dest[sVar2] = '-';
        __s = ((str_pair *)__ptr)->str2;
        if (*__s == '&') {
          sVar2 = strlen(((str_pair *)__ptr)->str1);
          strcpy(__dest + sVar2 + 1,__s + 1);
        }
        else {
          sVar2 = strlen(((str_pair *)__ptr)->str1);
          strcpy(__dest + sVar2 + 1,__s);
        }
        free(((str_pair *)__ptr)->str1);
        free(((str_pair *)__ptr)->str2);
        pLVar5 = GetLibraryEntryMemory(Menu);
        __s = (char *)__strdup(__dest);
        pLVar5->ListEntry = __s;
        p_Var1 = ((str_pair *)__ptr)->next;
        free(__ptr);
        __ptr = p_Var1;
        while( true ) {
          if (__ptr == (_str_pair *)0x0) {
            return;
          }
          __s = __ptr->str1;
          if (__s != (char *)0x0) break;
LAB_0808f0d7:
          free(__ptr->str2);
          p_Var1 = __ptr->next;
          free(__ptr);
          __ptr = p_Var1;
        }
      } while( true );
    }
  }
  pair_list_free(nodes);
  return;
}



char * FindKeyword(void)

{
  Keyword *pKVar1;
  Keyword *pKVar2;
  char cVar3;
  __int32_t **pp_Var4;
  ushort **ppuVar5;
  int iVar6;
  char *__s1;
  Keyword *pKVar7;
  int iVar8;
  int in_GS_OFFSET;
  uint local_134;
  Keyword *local_130;
  char lower [256];
  int local_20;
  
  iVar8 = 0x816bec1;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  __s1 = lower;
  while( true ) {
    cVar3 = *(char *)(iVar8 + -1);
    if (cVar3 == '\0') break;
    ppuVar5 = __ctype_b_loc();
    iVar6 = (int)cVar3;
    if (((*(byte *)((int)*ppuVar5 + iVar6 * 2 + 1) & 1) != 0) && (iVar6 + 0x80U < 0x180)) {
      pp_Var4 = __ctype_tolower_loc();
      cVar3 = (char)(*pp_Var4)[iVar6];
    }
    *__s1 = cVar3;
    iVar8 = iVar8 + 1;
    __s1 = __s1 + 1;
  }
  *__s1 = '\0';
  local_134 = 0;
  if (lower[0] != '\0') {
    local_134 = 0;
    __s1 = lower;
    do {
      __s1 = __s1 + 1;
      local_134 = (int)lower[0] + local_134 * 2;
      lower[0] = *__s1;
    } while (lower[0] != '\0');
    local_134 = local_134 % 0x7f;
  }
  pKVar1 = KeywordTable[local_134];
  if (pKVar1 != (Keyword *)0x0) {
    local_130 = (Keyword *)0x0;
    pKVar2 = pKVar1;
    do {
      pKVar7 = pKVar2;
      __s1 = pKVar7->String;
      iVar8 = strcmp(__s1,lower);
      if (iVar8 == 0) {
        if (local_130 != (Keyword *)0x0) {
          __s1 = pKVar7->String;
          local_130->Next = pKVar7->Next;
          pKVar7->Next = pKVar1;
          KeywordTable[local_134] = pKVar7;
        }
        goto LAB_0808f2ba;
      }
      pKVar2 = pKVar7->Next;
      local_130 = pKVar7;
    } while (pKVar7->Next != (Keyword *)0x0);
  }
  __s1 = (char *)0x0;
LAB_0808f2ba:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return __s1;
}



// WARNING: Could not reconcile some variable overlaps

int edifparse(void)

{
  undefined4 *__dest;
  ushort uVar1;
  uint uVar2;
  undefined4 *puVar3;
  int iVar4;
  short *__dest_00;
  uint uVar5;
  int local_4f4;
  int local_4f0;
  undefined4 *local_4ec;
  short *local_4e4;
  uint local_4e0;
  uint local_4dc;
  undefined4 *local_4d8;
  short *local_4d4;
  YYSTYPE yyvsa [200];
  yytype_int16 yyssa [200];
  
  local_4ec = yyvsa;
  edifnerrs = 0;
  edifchar = -2;
  local_4e0 = 0;
  local_4dc = 200;
  local_4f4 = 0;
  local_4f0 = 199;
  local_4e4 = yyssa;
  local_4d8 = local_4ec;
  local_4d4 = yyssa;
yysetstate:
  *local_4d4 = (short)local_4e0;
  if (local_4e4 + local_4f0 <= local_4d4) {
    if (local_4dc < 10000) {
      local_4dc = local_4dc * 2;
      if (10000 < local_4dc) {
        local_4dc = 10000;
      }
      __dest_00 = (short *)malloc(local_4dc * 6 + 3);
      if (__dest_00 == (short *)0x0) goto LAB_080907be;
      iVar4 = (int)((int)local_4d4 - (int)local_4e4) >> 1;
      memcpy(__dest_00,local_4e4,(iVar4 + 1) * 2);
      __dest = (undefined4 *)(__dest_00 + local_4dc);
      memcpy(__dest,local_4ec,(iVar4 + 1) * 4);
      if (yyssa != local_4e4) {
        free(local_4e4);
      }
      local_4d4 = __dest_00 + iVar4;
      local_4f0 = local_4dc - 1;
      local_4e4 = __dest_00;
      if (local_4d4 < __dest_00 + local_4f0) {
        local_4d8 = __dest + iVar4;
        local_4ec = __dest;
        goto yybackup;
      }
LAB_0808fc91:
      iVar4 = 1;
    }
    else {
LAB_080907be:
      __fprintf_chk(Error,1,"%s, line %ld: %s\n",InFile,LineNumber,"memory exhausted");
      iVar4 = 2;
    }
    goto LAB_0808fc9c;
  }
yybackup:
  iVar4 = (int)yypact[local_4e0];
  if (iVar4 == -0x535) {
yydefault:
    uVar1 = yydefact[local_4e0];
    uVar2 = (uint)uVar1;
    if (uVar1 == 0) {
yyerrlab:
      if (local_4f4 == 0) {
        edifnerrs = edifnerrs + 1;
        __fprintf_chk(Error,1,"%s, line %ld: %s\n",InFile,LineNumber,"syntax error");
LAB_0808f9d5:
        do {
          if (((iVar4 != -0x535) && (uVar2 = iVar4 + 1, uVar2 < 0xa3c)) &&
             (*(short *)(iVar4 + 0x8142661 + uVar2) == 1)) {
            uVar1 = *(ushort *)(iVar4 + 0x8143ae1 + uVar2);
            local_4e0 = (uint)uVar1;
            if (uVar1 != 0) goto code_r0x0808f9fd;
          }
          if (local_4d4 == local_4e4) {
            iVar4 = 1;
            __dest_00 = local_4e4;
            goto LAB_0808fa4b;
          }
          local_4d4 = local_4d4 + -1;
          local_4d8 = local_4d8 + -1;
          iVar4 = (int)yypact[*local_4d4];
        } while( true );
      }
      if (local_4f4 != 3) goto LAB_0808f9d5;
      if (0 < edifchar) {
        edifchar = -2;
        goto LAB_0808f9d5;
      }
      if (edifchar != 0) goto LAB_0808f9d5;
      goto LAB_0808fc91;
    }
    uVar5 = (uint)""[uVar2];
    __dest = local_4d8 + (1 - uVar5);
    if (uVar1 < 0x46a) {
                    // WARNING: Could not recover jumptable at 0x0808f537. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar4 = (*(code *)(&PTR_LAB_0813fcc0)[uVar2])();
      return iVar4;
    }
    local_4d4 = local_4d4 + uVar5 * 0x7fffffff;
    puVar3 = local_4d8 + uVar5 * 0x3fffffff;
    uVar5 = (uint)yyr1[uVar2];
    local_4d8 = puVar3 + 1;
    puVar3[1] = *__dest;
    uVar2 = (int)*local_4d4 + (int)*(short *)(uVar5 + 0x8146858 + (uVar5 - 0x128));
    if ((uVar2 < 0xa3c) && (*local_4d4 == yycheck[uVar2])) {
      local_4e0 = (uint)yytable[uVar2];
    }
    else {
      local_4e0 = SEXT24(*(short *)(uVar5 + 0x8146c18 + (uVar5 - 0x128)));
    }
    goto yynewstate;
  }
  if (edifchar == -2) {
    iVar4 = _IO_getc((_IO_FILE *)Input);
    yytext[0] = (char)iVar4;
                    // WARNING: Could not recover jumptable at 0x0808f5be. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar4 = (*(code *)&DAT_0808f600)();
    return iVar4;
  }
  if (edifchar < 1) {
    edifchar = 0;
    uVar2 = 0;
  }
  else {
    uVar2 = 2;
    if ((uint)edifchar < 0x226) {
      uVar2 = (uint)yytranslate[edifchar];
    }
  }
  uVar5 = uVar2 + iVar4;
  if ((0xa3b < uVar5) || ((int)yycheck[uVar5] != uVar2)) goto yydefault;
  uVar1 = yytable[uVar5];
  local_4e0 = (uint)uVar1;
  if (uVar1 == 0) goto yyerrlab;
  if (uVar1 == 0xb) goto yyreturn;
  local_4f4 = local_4f4 + -1 + (uint)(local_4f4 == 0);
  if (edifchar != 0) {
    edifchar = -2;
  }
  local_4d8 = local_4d8 + 1;
  *local_4d8 = ediflval;
yynewstate:
  local_4d4 = local_4d4 + 1;
  goto yysetstate;
code_r0x0808f9fd:
  if (uVar1 == 0xb) {
yyreturn:
    iVar4 = 0;
LAB_0808fc9c:
    __dest_00 = local_4e4;
    if (local_4e4 != local_4d4) {
      __dest_00 = (short *)((int)local_4d4 +
                           (~((int)local_4d4 + (-2 - (int)local_4e4)) & 0xfffffffeU));
    }
LAB_0808fa4b:
    if (yyssa != __dest_00) {
      free(local_4e4);
    }
    return iVar4;
  }
  local_4d8 = local_4d8 + 1;
  local_4f4 = 3;
  *local_4d8 = ediflval;
  goto yynewstate;
}



void ParseEDIF(char *filename,FILE *err)

{
  char **ppcVar1;
  Token **ppTVar2;
  short sVar3;
  Token *pTVar4;
  int ContextDefined;
  Context *pCVar5;
  ContextCar *pCVar6;
  Context *pCVar7;
  TokenCar *pTVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  Token *pTVar12;
  int *piVar13;
  Token **ppTVar14;
  int iVar15;
  Token *pTVar16;
  short *psVar17;
  int local_28;
  short *local_20;
  
  InFile = filename;
  Input = (FILE *)fopen(filename,"r");
  Error = err;
  LineNumber = 1;
  if (ContextDefined != 0) {
    piVar13 = &TokenDef[0x36].Code;
    do {
      *(Token **)(piVar13 + 1) = TokenHash[*piVar13 % 0x33];
      TokenHash[*piVar13 % 0x33] = (Token *)(piVar13 + -1);
      ppcVar1 = (char **)(piVar13 + -1);
      piVar13 = piVar13 + -3;
      EnterKeyword(*ppcVar1);
    } while (piVar13 != (int *)&DAT_08164478);
    ppTVar14 = (Token **)&ContextDef[0xe8].Code;
    do {
      sVar3 = *(short *)ppTVar14;
      iVar10 = (int)(short)(sVar3 + ((short)((int)sVar3 * 0x100008103 >> 0x16) - (sVar3 >> 0xf)) *
                                    -0x7f);
      *(Context **)(ppTVar14 + 3) = ContextHash[iVar10];
      ContextHash[iVar10] = (Context *)(ppTVar14 + -1);
      ppTVar2 = ppTVar14 + -1;
      ppTVar14 = ppTVar14 + -5;
      EnterKeyword((char *)*ppTVar2);
    } while (ppTVar14 != &TokenDef[0x36].Next);
    iVar10 = 0xc4;
    while( true ) {
      pCVar5 = FindContext((int)BinderDef[iVar10].Origin);
      iVar15 = (int)BinderDef[iVar10].FollowerSize;
      if (iVar15 != 0) {
        iVar9 = 0;
        psVar17 = BinderDef[iVar10].Follower + iVar15 + -1;
        do {
          pCVar6 = (ContextCar *)malloc(0xc);
          pCVar6->Next = pCVar5->Context;
          sVar3 = *psVar17;
          pCVar5->Context = pCVar6;
          uVar11 = (int)sVar3 >> 0x1f;
          pCVar7 = FindContext(((int)sVar3 ^ uVar11) - uVar11);
          pCVar6->Context = pCVar7;
          sVar3 = *psVar17;
          psVar17 = psVar17 + -1;
          pCVar6->u = (uint)(int)sVar3 >> 0x1f;
          iVar9 = iVar9 + 1;
        } while (iVar9 != iVar15);
      }
      if (iVar10 == 0) break;
      iVar10 = iVar10 + -1;
    }
    iVar10 = 8;
    do {
      pCVar5 = FindContext((int)TieDef[iVar10].Origin);
      iVar15 = (int)TieDef[iVar10].EnableSize;
      if (iVar15 != 0) {
        local_28 = 0;
        local_20 = TieDef[iVar10].Enable + iVar15 + -1;
        do {
          pTVar8 = (TokenCar *)malloc(8);
          pTVar8->Next = pCVar5->Token;
          pCVar5->Token = pTVar8;
          iVar9 = (int)*local_20;
          pTVar16 = TokenHash[iVar9 % 0x33];
          if ((pTVar16 != (Token *)0x0) && (pTVar4 = pTVar16, iVar9 != pTVar16->Code)) {
            do {
              pTVar12 = pTVar4;
              pTVar4 = pTVar12->Next;
              if (pTVar4 == (Token *)0x0) {
                pTVar16 = (Token *)0x0;
                goto LAB_08090c54;
              }
            } while (iVar9 != pTVar4->Code);
            pTVar12->Next = pTVar4->Next;
            pTVar4->Next = pTVar16;
            TokenHash[iVar9 % 0x33] = pTVar4;
            pTVar16 = pTVar4;
          }
LAB_08090c54:
          local_28 = local_28 + 1;
          local_20 = local_20 + -1;
          pTVar8->Token = pTVar16;
        } while (iVar15 != local_28);
      }
      if (iVar10 == 0) goto LAB_08090c80;
      iVar10 = iVar10 + -1;
    } while( true );
  }
LAB_08090cb9:
  CurrentBucket = (Bucket *)malloc(0x48);
  CurrentBucket->Index = 0;
  CurrentBucket->Next = (Bucket *)0x0;
  edifparse();
  return;
LAB_08090c80:
  pCVar6 = (ContextCar *)malloc(0xc);
  CSP = pCVar6;
  pCVar6->Next = (ContextCar *)0x0;
  pCVar5 = FindContext(0);
  pCVar6->Context = pCVar5;
  CSP->u = 0;
  ContextDefined = 0;
  goto LAB_08090cb9;
}



void Message(char *Format,...)

{
  (*gui->logv)(Format,&stack0x00000008);
  return;
}



void MyFatal(char *Format,...)

{
  __pid_t _Var1;
  
  EmergencySave();
  _Var1 = getpid();
  __fprintf_chk(stderr,1,"%s (%i): fatal, ",Progname,_Var1);
  __vfprintf_chk(stderr,1,Format,&stack0x00000008);
  fflush(stderr);
                    // WARNING: Subroutine does not return
  exit(1);
}



void CatchSignal(int Signal)

{
  char *pcVar1;
  
  pcVar1 = "unknown";
  if (Signal - 1U < 0xf) {
    pcVar1 = *(char **)(CSWTCH_44 + (Signal - 1U) * 4);
  }
  MyFatal("aborted by %s signal\n",pcVar1);
  return;
}



void ChdirErrorMessage(char *DirName)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(DirName);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t change working directory to\n   \'%s\'\nchdir() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



void OpendirErrorMessage(char *DirName)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(DirName);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t scan directory\n   \'%s\'\nopendir() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



void PopenErrorMessage(char *Filename)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(Filename);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t execute command\n   \'%s\'\npopen() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



void OpenErrorMessage(char *Filename)

{
  void *__ptr;
  int *piVar1;
  char *pcVar2;
  
  __ptr = (void *)__strdup(Filename);
  piVar1 = __errno_location();
  pcVar2 = strerror(*piVar1);
  Message("Can\'t open file\n   \'%s\'\nfopen() returned: \'%s\'\n",__ptr,pcVar2);
  free(__ptr);
  return;
}



void PreLoadElementPCB(void)

{
  DataTypePtr *pDVar1;
  
  if (yyPCB != (PCBTypePtr)0x0) {
    yyFont = (FontTypePtr)&yyPCB->Font;
    pDVar1 = yyPCB->Data;
    yyData = pDVar1;
    *(PCBTypePtr *)&pDVar1->field_0x48 = yyPCB;
    pDVar1->LayerN = 0;
  }
  return;
}



void DisableEmergencySave(void)

{
  dont_save_any_more = '\x01';
  return;
}



void EnableAutosave(void)

{
  undefined4 local_10 [3];
  
  if ((backup_timer != 0) && (gui->stop_timer != (anon_subr_void_hidval_for_stop_timer *)0x0)) {
    (*gui->stop_timer)(backup_timer);
  }
  backup_timer = 0;
  if ((0 < Settings.BackupInterval) &&
     (gui->add_timer != (anon_subr_hidval_anon_subr_void_hidval_ptr_ulong_hidval_for_add_timer *)0x0
     )) {
    (*gui->add_timer)((anon_subr_void_hidval *)local_10,(ulong)backup_cb,
                      Settings.BackupInterval * 1000);
    backup_timer = local_10[0];
  }
  return;
}



void __regparm3 sort_library(LibraryTypePtr lib)

{
  uint uVar1;
  uint uVar2;
  
  qsort(lib->Menu,lib->MenuN,0x1c,netlist_sort);
  if (lib->MenuN != 0) {
    uVar1 = 0;
    do {
      uVar2 = uVar1 + 1;
      qsort(lib->Menu[uVar1].Entry,lib->Menu[uVar1].EntryN,0x18,netnode_sort);
      uVar1 = uVar2;
    } while (uVar2 <= lib->MenuN && lib->MenuN != uVar2);
  }
  return;
}



int ReadNetlist(char *filename)

{
  char cVar1;
  bool bVar2;
  char *command;
  byte bVar3;
  char cVar4;
  char *pcVar5;
  uint uVar6;
  uint uVar7;
  LibraryEntryTypePtr *pLVar8;
  uint *puVar9;
  uint *puVar10;
  int iVar11;
  char *pcVar12;
  int iVar13;
  int in_GS_OFFSET;
  bool bVar14;
  FILE *local_23c;
  int local_238;
  LibraryMenuTypePtr *local_234;
  int local_230;
  char temp [256];
  char inputline [256];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar11 = 1;
  if (filename == (char *)0x0) goto LAB_0809142d;
  Message("Importing PCB netlist %s\n",filename);
  if ((Settings.RatCommand == (char *)0x0) || (*Settings.RatCommand == '\0')) {
    local_23c = fopen(filename,"r");
    bVar2 = false;
    if (local_23c == (FILE *)0x0) {
      Message("Cannot open %s for reading",filename);
      iVar11 = 1;
      goto LAB_0809142d;
    }
LAB_080910ae:
    local_230 = 0;
    local_238 = 0;
    local_234 = (LibraryMenuTypePtr *)0x0;
    while (pcVar5 = fgets(inputline,0xff,local_23c), pcVar5 != (char *)0x0) {
      puVar10 = (uint *)inputline;
      do {
        puVar9 = puVar10;
        uVar6 = *puVar9 + 0xfefefeff & ~*puVar9;
        uVar7 = uVar6 & 0x80808080;
        puVar10 = puVar9 + 1;
      } while (uVar7 == 0);
      bVar14 = (uVar6 & 0x8080) == 0;
      bVar3 = (byte)uVar7;
      if (bVar14) {
        bVar3 = (byte)(uVar7 >> 0x10);
      }
      if (bVar14) {
        puVar10 = (uint *)((int)puVar9 + 6);
      }
      iVar11 = (int)puVar10 + ((-3 - (uint)CARRY1(bVar3,bVar3)) - (int)inputline);
      if (iVar11 == 0) {
        iVar11 = -1;
      }
      else {
        if (temp[iVar11 + 0xff] == '\n') {
          temp[iVar11 + 0xff] = '\0';
          iVar11 = iVar11 + -2;
        }
        else {
          iVar11 = iVar11 + -2;
          Message(
                  "Line length (%i) exceeded in netlist file.\nadditional characters will be ignored.\n"
                  ,0xff);
        }
      }
      cVar1 = inputline[iVar11];
      if (cVar1 == '\\') {
        inputline[iVar11] = '\0';
      }
      iVar11 = 0;
LAB_08091160:
      cVar4 = inputline[iVar11];
      if (cVar4 != '\0') {
        do {
          pcVar5 = inputline + iVar11 + 1;
          do {
            if (((cVar4 != '\t') && (cVar4 != ' ')) && (cVar4 != '\n')) {
              cVar4 = inputline[iVar11];
              break;
            }
            cVar4 = *pcVar5;
            iVar11 = iVar11 + 1;
            pcVar5 = pcVar5 + 1;
          } while (cVar4 != '\0');
          iVar13 = 0;
          if (local_230 == 0) {
            temp[0] = ' ';
            iVar13 = 2;
            temp[1] = ' ';
          }
          if ((cVar4 == '\t') || (cVar4 == ' ')) {
LAB_08091213:
            temp[iVar13] = '\0';
            if (cVar4 != '\0') {
LAB_0809121f:
              pcVar5 = inputline + iVar11 + 1;
              do {
                if (((cVar4 != '\t') && (cVar4 != ' ')) && (cVar4 != '\n')) break;
                cVar4 = *pcVar5;
                iVar11 = iVar11 + 1;
                pcVar5 = pcVar5 + 1;
              } while (cVar4 != '\0');
            }
          }
          else {
            if (cVar4 == '\n') {
LAB_08091358:
              temp[iVar13] = '\0';
              cVar4 = '\n';
              goto LAB_0809121f;
            }
            if (cVar4 != '\0') {
              pcVar12 = temp + iVar13;
              pcVar5 = inputline + iVar11 + 1;
              do {
                iVar11 = iVar11 + 1;
                *pcVar12 = cVar4;
                cVar4 = *pcVar5;
                iVar13 = iVar13 + 1;
                if ((cVar4 == '\t') || (cVar4 == ' ')) goto LAB_08091213;
                if (cVar4 == '\n') goto LAB_08091358;
                pcVar12 = pcVar12 + 1;
                pcVar5 = pcVar5 + 1;
              } while (cVar4 != '\0');
            }
            temp[iVar13] = '\0';
          }
          if (local_230 == 0) {
            local_234 = GetLibraryMenuMemory((LibraryTypePtr)&PCB->NetlistLib);
            pcVar5 = MyStrdup(temp,"ReadNetlist()");
            local_234->flag = '\x01';
            local_230 = 1;
            local_234->Name = pcVar5;
            goto LAB_08091160;
          }
          if ((local_230 == 1) && (pcVar5 = strchr(temp,0x2d), pcVar5 == (char *)0x0))
          goto LAB_080913b6;
          pLVar8 = GetLibraryEntryMemory(local_234);
          pcVar5 = MyStrdup(temp,"ReadNetlist()");
          pLVar8->ListEntry = pcVar5;
          cVar4 = inputline[iVar11];
          if (cVar4 == '\0') break;
        } while( true );
      }
      iVar11 = 0;
      if (cVar1 == '\\') {
        iVar11 = local_230;
      }
      local_238 = local_238 + 1;
      local_230 = iVar11;
    }
    if (local_238 == 0) {
      Message("Empty netlist file!\n");
      pclose(local_23c);
      iVar11 = 1;
    }
    else {
      if (bVar2) {
        pclose(local_23c);
      }
      else {
        fclose(local_23c);
      }
      netlist_sort_offset = 2;
      sort_library((LibraryTypePtr)&PCB->NetlistLib);
      iVar11 = 0;
      netlist_sort_offset = 0;
    }
  }
  else {
    SaveFree(command);
    command = (char *)0x0;
    command = EvaluateFilename(Settings.RatCommand,Settings.RatPath,filename,(char *)0x0);
    if (*command != '\0') {
      local_23c = popen(command,"r");
      bVar2 = true;
      if (local_23c != (FILE *)0x0) goto LAB_080910ae;
    }
    PopenErrorMessage(command);
    iVar11 = 1;
  }
LAB_0809142d:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar11;
LAB_080913b6:
  pcVar5 = MyStrdup(temp,"ReadNetlist()");
  local_230 = 2;
  local_234->Style = pcVar5;
  goto LAB_08091160;
}



int ImportNetlist(char *filename)

{
  FILE *__stream;
  size_t sVar1;
  __int32_t **pp_Var2;
  int iVar3;
  char *pcVar4;
  int in_GS_OFFSET;
  char buf [16];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((filename == (char *)0x0) || (__stream = fopen(filename,"r"), __stream == (FILE *)0x0)) {
    iVar3 = 1;
  }
  else {
    sVar1 = fread(buf,1,0xf,__stream);
    fclose(__stream);
    buf[sVar1] = '\0';
    pcVar4 = buf;
    while (buf[0] != '\0') {
      if ((int)buf[0] + 0x80U < 0x180) {
        pp_Var2 = __ctype_tolower_loc();
        buf[0] = (char)(*pp_Var2)[(int)buf[0]];
      }
      *pcVar4 = buf[0];
      pcVar4 = pcVar4 + 1;
      buf[0] = *pcVar4;
    }
    pcVar4 = strstr(buf,"edif");
    if (pcVar4 == (char *)0x0) {
      iVar3 = ReadNetlist(filename);
    }
    else {
      Message("Importing edif netlist %s\n",filename);
      ParseEDIF(filename,(FILE *)0x0);
      iVar3 = 0;
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int __regparm3 string_cmp(char *a,char *b)

{
  byte bVar1;
  ushort **ppuVar2;
  __int32_t **pp_Var3;
  __int32_t _Var4;
  long lVar5;
  long lVar6;
  char cVar7;
  int iVar8;
  char cVar9;
  char *pcVar10;
  ushort *puVar11;
  __int32_t local_20;
  
  cVar9 = *a;
  if (cVar9 != '\0') {
    cVar7 = *b;
    if (cVar7 != '\0') {
      ppuVar2 = __ctype_b_loc();
      puVar11 = *ppuVar2;
      do {
        _cVar9 = (__int32_t)cVar9;
        iVar8 = (int)cVar7;
        if (((*(byte *)((int)puVar11 + _cVar9 * 2 + 1) & 8) == 0) ||
           ((*(byte *)((int)puVar11 + iVar8 * 2 + 1) & 8) == 0)) {
          local_20 = _cVar9;
          if (_cVar9 + 0x80U < 0x180) {
            pp_Var3 = __ctype_tolower_loc();
            local_20 = (*pp_Var3)[_cVar9];
          }
          _Var4 = iVar8;
          if (iVar8 + 0x80U < 0x180) {
            pp_Var3 = __ctype_tolower_loc();
            _Var4 = (*pp_Var3)[iVar8];
          }
          if (local_20 != _Var4) {
            if (_cVar9 + 0x80U < 0x180) {
              pp_Var3 = __ctype_tolower_loc();
              _cVar9 = (*pp_Var3)[_cVar9];
            }
            if (iVar8 + 0x80U < 0x180) {
              pp_Var3 = __ctype_tolower_loc();
              iVar8 = (*pp_Var3)[iVar8];
            }
            return _cVar9 - iVar8;
          }
LAB_080916cf:
          a = a + 1;
          b = b + 1;
          cVar9 = *a;
        }
        else {
          lVar5 = strtol(a,(char **)0x0,10);
          lVar6 = strtol(b,(char **)0x0,10);
          if (lVar5 != lVar6) {
            return lVar5 - lVar6;
          }
          puVar11 = *ppuVar2;
          bVar1 = *(byte *)((int)puVar11 + (int)*a * 2 + 1);
          while ((bVar1 & 8) != 0) {
            a = a + 1;
            bVar1 = *(byte *)((int)puVar11 + (int)*a * 2 + 1);
          }
          if ((*(byte *)((int)puVar11 + (int)*b * 2 + 1) & 8) == 0) goto LAB_080916cf;
          do {
            pcVar10 = b;
            b = pcVar10 + 1;
          } while ((*(byte *)((int)puVar11 + (int)*b * 2 + 1) & 8) != 0);
          a = a + 1;
          b = pcVar10 + 2;
          cVar9 = *a;
        }
        if (cVar9 == '\0') goto LAB_08091790;
        cVar7 = *b;
      } while (cVar7 != '\0');
    }
    return 1;
  }
LAB_08091790:
  return ~-(uint)(*b == '\0');
}



int netnode_sort(void *va,void *vb)

{
  int iVar1;
  
  iVar1 = string_cmp(*(char **)va,*(char **)vb);
  return iVar1;
}



int netlist_sort(void *va,void *vb)

{
  int iVar1;
  
  iVar1 = string_cmp(*(char **)va + (**(char **)va == '~'),*(char **)vb + (**(char **)vb == '~'));
  return iVar1;
}



void RemoveTMPData(void)

{
  unlink(TMPFilename);
  return;
}



FILE * CheckAndOpenFile(char *Filename,Boolean Confirm,Boolean AllButton,Boolean *WasAllButton,
                       Boolean *WasCancelButton)

{
  int iVar1;
  FILE *pFVar2;
  int iVar3;
  int in_GS_OFFSET;
  stat buffer;
  char message [4176];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((Filename == (char *)0x0) || (*Filename == '\0')) {
    pFVar2 = (FILE *)0x0;
  }
  else {
    iVar3 = __xstat(3,Filename,(stat *)&buffer);
    if ((iVar3 == 0) && (Confirm != '\0')) {
      __sprintf_chk(message,1,0x1050,"File \'%s\' exists, use anyway?",Filename);
      if (WasAllButton != (Boolean *)0x0) {
        *WasAllButton = '\0';
      }
      if (WasCancelButton != (Boolean *)0x0) {
        *WasCancelButton = '\0';
      }
      iVar3 = (*gui->confirm_dialog)(message,0x8152329,&DAT_08147319,"Sequence OK");
      if (iVar3 == 0) {
        if (WasCancelButton != (Boolean *)0x0) {
          *WasCancelButton = '\x01';
        }
      }
      else {
        if ((iVar3 == 2) && (WasAllButton != (Boolean *)0x0)) {
          *WasAllButton = '\x01';
        }
      }
    }
    pFVar2 = (FILE *)fopen(Filename,"w");
    if (pFVar2 == (FILE *)0x0) {
      OpenErrorMessage(Filename);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pFVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



FILE * OpenConnectionDataFile(void)

{
  char *default_file;
  char *Filename;
  FILE *pFVar1;
  Boolean result;
  
  pFVar1 = (FILE *)0x0;
  Filename = (*gui->fileselect)("Save Connection Data As ...",
                                "Choose a file to save all connection data to.",default_file,".net",
                                "connection_data",0);
  if (Filename != (char *)0x0) {
    if (default_file != (char *)0x0) {
      free(default_file);
      default_file = (char *)0x0;
    }
    if (*Filename != '\0') {
      default_file = (char *)__strdup(Filename);
    }
    pFVar1 = CheckAndOpenFile(Filename,'\x01','\0',&result,(Boolean *)0x0);
    free(Filename);
  }
  return pFVar1;
}



void __regparm3 WritePCBInfoHeader(FILE *FP)

{
  int iVar1;
  hostent *hostentry;
  tm *__tp;
  char *local_12c;
  __uid_t __uid;
  passwd *ppVar2;
  int iVar3;
  char *__name;
  int in_GS_OFFSET;
  time_t local_114;
  char hostname [256];
  
  __name = hostname;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_114 = time((time_t *)0x0);
  __fprintf_chk(FP,1,"# release: %s 20091103\n",Progname);
  __tp = localtime(&local_114);
  local_12c = asctime(__tp);
  __fprintf_chk(FP,1,"# date:    %s",local_12c);
  __uid = getuid();
  ppVar2 = getpwuid(__uid);
  local_12c = ppVar2->pw_gecos;
  __fprintf_chk(FP,1,"# user:    %s (%s)\n",ppVar2->pw_name,local_12c);
  iVar3 = gethostname(__name,0xff);
  if (iVar3 != -1) {
    if ((hostentry != (hostent *)0x0) ||
       (hostentry = (hostent *)gethostbyname(__name), hostentry != (hostent *)0x0)) {
      __name = hostentry->h_name;
    }
    __fprintf_chk(FP,1,"# host:    %s\n",__name,local_12c);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void __regparm3 PrintQuotedString(FILE *FP,char *S)

{
  DynamicStringType ds;
  
  CreateQuotedString((DynamicStringTypePtr)0x816c0d0,S);
  fputs(ds.Data,(FILE *)FP);
  return;
}



void __regparm3 WriteViaData(FILE *FP,DataTypePtr *Data)

{
  char *S;
  PinTypePtr *pPVar1;
  uint uVar2;
  LocationType local_4c;
  BDimension local_48;
  BDimension local_44;
  BDimension local_40;
  BDimension local_3c;
  
  if (Data->ViaN != 0) {
    uVar2 = 0;
    do {
      pPVar1 = Data->Via + uVar2;
      local_3c = pPVar1->DrillingHole;
      local_40 = pPVar1->Mask;
      local_44 = pPVar1->Clearance;
      local_48 = pPVar1->Thickness;
      local_4c = pPVar1->Y;
      __fprintf_chk(FP,1,"Via[%i %i %i %i %i %i ",pPVar1->X,local_4c,local_48,local_44,local_40,
                    local_3c);
      S = pPVar1->Name;
      if (S == (char *)0x0) {
        S = "";
      }
      PrintQuotedString(FP,S);
      uVar2 = uVar2 + 1;
      S = flags_to_string(pPVar1->Flags,1);
      __fprintf_chk(FP,1,0x81473e1,S,local_4c,local_48,local_44,local_40,local_3c);
    } while (uVar2 <= Data->ViaN && Data->ViaN != uVar2);
  }
  return;
}



void __regparm3 WriteLayerData(FILE *FP,Cardinal Number,LayerTypePtr layer)

{
  AttributeType *pAVar1;
  char *S;
  int iVar2;
  int iVar3;
  LineTypePtr pLVar4;
  ArcTypePtr *pAVar5;
  TextTypePtr pTVar6;
  uint local_48;
  uint uVar7;
  PointTypePtr pPVar8;
  PolygonTypePtr ppVar9;
  LocationType local_4c;
  BDimension local_44;
  uint local_28;
  
  if ((((layer->LineN != 0) || (layer->ArcN != 0)) || (layer->TextN != 0)) ||
     ((layer->PolygonN != 0 || ((layer->Name != (char *)0x0 && (*layer->Name != '\0')))))) {
    __fprintf_chk(FP,1,"Layer(%i ",Number + 1);
    S = layer->Name;
    if (S == (char *)0x0) {
      S = "";
    }
    PrintQuotedString(FP,S);
    fwrite(")\n(\n",1,4,(FILE *)FP);
    if (0 < (layer->Attributes).Number) {
      iVar2 = 0;
      do {
        iVar3 = iVar2 + 1;
        pAVar1 = (layer->Attributes).List + iVar2;
        __fprintf_chk(FP,1,"%sAttribute(\"%s\" \"%s\")\n",&DAT_0814741a,pAVar1->name,pAVar1->value);
        iVar2 = iVar3;
      } while (iVar3 < (layer->Attributes).Number);
    }
    if (layer->LineN != 0) {
      uVar7 = 0;
      do {
        local_48 = uVar7 + 1;
        pLVar4 = layer->Line + uVar7;
        S = flags_to_string(pLVar4->Flags,4);
        __fprintf_chk(FP,1,"\tLine[%i %i %i %i %i %i %s]\n",(pLVar4->Point1).X,(pLVar4->Point1).Y,
                      (pLVar4->Point2).X,(pLVar4->Point2).Y,pLVar4->Thickness,pLVar4->Clearance,S);
        uVar7 = local_48;
      } while (local_48 <= layer->LineN && layer->LineN != local_48);
    }
    if (layer->ArcN != 0) {
      uVar7 = 0;
      do {
        local_48 = uVar7 + 1;
        pAVar5 = layer->Arc + uVar7;
        S = flags_to_string(pAVar5->Flags,0x4000);
        __fprintf_chk(FP,1,"\tArc[%i %i %i %i %i %i %i %i %s]\n",pAVar5->X,pAVar5->Y,pAVar5->Width,
                      pAVar5->Height,pAVar5->Thickness,pAVar5->Clearance,pAVar5->StartAngle,
                      pAVar5->Delta,S);
        uVar7 = local_48;
      } while (local_48 <= layer->ArcN && layer->ArcN != local_48);
    }
    if (layer->TextN != 0) {
      uVar7 = 0;
      do {
        pTVar6 = layer->Text + uVar7;
        local_44 = pTVar6->Scale;
        local_48 = (uint)pTVar6->Direction;
        local_4c = pTVar6->Y;
        __fprintf_chk(FP,1,"\tText[%i %i %i %i ",pTVar6->X,local_4c,local_48,local_44);
        S = pTVar6->TextString;
        if (S == (char *)0x0) {
          S = "";
        }
        uVar7 = uVar7 + 1;
        PrintQuotedString(FP,S);
        S = flags_to_string(pTVar6->Flags,0x10);
        __fprintf_chk(FP,1,0x81473e1,S,local_4c,local_48,local_44);
      } while (uVar7 <= layer->TextN && layer->TextN != uVar7);
    }
    if (layer->PolygonN != 0) {
      local_28 = 0;
      do {
        ppVar9 = layer->Polygon + local_28;
        S = flags_to_string(ppVar9->Flags,8);
        __fprintf_chk(FP,1,"\tPolygon(%s)\n\t(",S);
        if (ppVar9->PointN != 0) {
          uVar7 = 0;
          do {
            pPVar8 = ppVar9->Points + uVar7;
            if (uVar7 == ((int)uVar7 / 5) * 5) {
              fwrite(&DAT_08147418,1,3,(FILE *)FP);
            }
            uVar7 = uVar7 + 1;
            __fprintf_chk(FP,1,"[%i %i] ",pPVar8->X,pPVar8->Y);
          } while (uVar7 <= ppVar9->PointN && ppVar9->PointN != uVar7);
        }
        fwrite(&DAT_0814740a,1,4,(FILE *)FP);
        local_28 = local_28 + 1;
      } while (local_28 <= layer->PolygonN && layer->PolygonN != local_28);
    }
    fwrite(&DAT_0814740c,1,2,(FILE *)FP);
  }
  return;
}



void __regparm3 WriteElementData(FILE *FP,DataTypePtr *Data)

{
  char *local_38;
  uint local_40;
  int local_44;
  AttributeType *pAVar1;
  int local_50;
  int iVar2;
  LineTypePtr pLVar3;
  ArcTypePtr *pAVar4;
  char *S;
  ElementTypePtr *pEVar5;
  int iVar6;
  PinTypePtr *pPVar7;
  PadTypePtr *pPVar8;
  uint uVar9;
  BDimension local_48;
  BDimension BVar10;
  BDimension BVar11;
  BDimension local_3c;
  uint local_24;
  
  if (Data->ElementN != 0) {
    local_24 = 0;
    do {
      pEVar5 = Data->Element + local_24;
      if ((((pEVar5->LineN != 0) || (pEVar5->PinN != 0)) || (pEVar5->ArcN != 0)) ||
         (pEVar5->PadN != 0)) {
        local_38 = flags_to_string(pEVar5->Flags,2);
        __fprintf_chk(FP,1,"\nElement[%s ",local_38);
        local_38 = pEVar5->Name[0].TextString;
        if (local_38 == (char *)0x0) {
          local_38 = "";
        }
        PrintQuotedString(FP,local_38);
        fputc(0x20,(FILE *)FP);
        local_38 = pEVar5->Name[1].TextString;
        if (local_38 == (char *)0x0) {
          local_38 = "";
        }
        PrintQuotedString(FP,local_38);
        fputc(0x20,(FILE *)FP);
        local_38 = pEVar5->Name[2].TextString;
        if (local_38 == (char *)0x0) {
          local_38 = "";
        }
        PrintQuotedString(FP,local_38);
        local_38 = flags_to_string(pEVar5->Name[0].Flags,0x400);
        local_3c = pEVar5->Name[0].Scale;
        local_40 = (uint)pEVar5->Name[0].Direction;
        local_44 = pEVar5->Name[0].Y - pEVar5->MarkY;
        __fprintf_chk(FP,1," %i %i %i %i %i %i %s]\n(\n",pEVar5->MarkX,pEVar5->MarkY,
                      pEVar5->Name[0].X - pEVar5->MarkX,local_44,local_40,local_3c,local_38);
        if (0 < (pEVar5->Attributes).Number) {
          local_50 = 0;
          do {
            iVar6 = local_50 + 1;
            pAVar1 = (pEVar5->Attributes).List + local_50;
            __fprintf_chk(FP,1,"%sAttribute(\"%s\" \"%s\")\n",&DAT_0814741a,pAVar1->name,
                          pAVar1->value,local_44,local_40,local_3c,local_38);
            local_50 = iVar6;
          } while (iVar6 < (pEVar5->Attributes).Number);
        }
        if (pEVar5->PinN != 0) {
          local_40 = 0;
          do {
            pPVar7 = pEVar5->Pin + local_40;
            local_3c = pPVar7->DrillingHole;
            BVar11 = pPVar7->Mask;
            BVar10 = pPVar7->Clearance;
            local_48 = pPVar7->Thickness;
            local_44 = pPVar7->Y - pEVar5->MarkY;
            local_50 = pPVar7->X - pEVar5->MarkX;
            __fprintf_chk(FP,1,"\tPin[%i %i %i %i %i %i ",local_50,local_44,local_48,BVar10,BVar11,
                          local_3c,local_38);
            S = pPVar7->Name;
            if (S == (char *)0x0) {
              S = "";
            }
            PrintQuotedString(FP,S);
            __fprintf_chk(FP,1,&DAT_08156730,local_50,local_44,local_48,BVar10,BVar11,local_3c);
            S = pPVar7->Number;
            if (S == (char *)0x0) {
              S = "";
            }
            PrintQuotedString(FP,S);
            S = flags_to_string(pPVar7->Flags,0x100);
            __fprintf_chk(FP,1,0x81473e1,S);
            local_40 = local_40 + 1;
          } while (local_40 <= pEVar5->PinN && pEVar5->PinN != local_40);
        }
        if (pEVar5->PadN != 0) {
          local_40 = 0;
          do {
            pPVar8 = pEVar5->Pad + local_40;
            local_3c = pPVar8->Mask;
            BVar11 = pPVar8->Clearance;
            BVar10 = pPVar8->Thickness;
            local_44 = (pPVar8->Point2).Y - pEVar5->MarkY;
            local_50 = (pPVar8->Point2).X - pEVar5->MarkX;
            iVar6 = (pPVar8->Point1).Y - pEVar5->MarkY;
            iVar2 = (pPVar8->Point1).X - pEVar5->MarkX;
            __fprintf_chk(FP,1,"\tPad[%i %i %i %i %i %i %i ",iVar2,iVar6,local_50,local_44,BVar10,
                          BVar11,local_3c);
            local_38 = pPVar8->Name;
            if (local_38 == (char *)0x0) {
              local_38 = "";
            }
            PrintQuotedString(FP,local_38);
            __fprintf_chk(FP,1,&DAT_08156730,iVar2,iVar6,local_50,local_44,BVar10,BVar11,local_3c);
            local_38 = pPVar8->Number;
            if (local_38 == (char *)0x0) {
              local_38 = "";
            }
            PrintQuotedString(FP,local_38);
            local_38 = flags_to_string(pPVar8->Flags,0x200);
            __fprintf_chk(FP,1,0x81473e1,local_38);
            local_40 = local_40 + 1;
          } while (local_40 <= pEVar5->PadN && pEVar5->PadN != local_40);
        }
        if (pEVar5->LineN != 0) {
          local_40 = 0;
          do {
            uVar9 = local_40 + 1;
            pLVar3 = pEVar5->Line + local_40;
            __fprintf_chk(FP,1,"\tElementLine [%i %i %i %i %i]\n",(pLVar3->Point1).X - pEVar5->MarkX
                          ,(pLVar3->Point1).Y - pEVar5->MarkY,(pLVar3->Point2).X - pEVar5->MarkX,
                          (pLVar3->Point2).Y - pEVar5->MarkY,pLVar3->Thickness);
            local_40 = uVar9;
          } while (uVar9 <= pEVar5->LineN && pEVar5->LineN != uVar9);
        }
        if (pEVar5->ArcN != 0) {
          local_40 = 0;
          do {
            uVar9 = local_40 + 1;
            pAVar4 = pEVar5->Arc + local_40;
            __fprintf_chk(FP,1,"\tElementArc [%i %i %i %i %i %i %i]\n",pAVar4->X - pEVar5->MarkX,
                          pAVar4->Y - pEVar5->MarkY,pAVar4->Width,pAVar4->Height,pAVar4->StartAngle,
                          pAVar4->Delta,pAVar4->Thickness);
            local_40 = uVar9;
          } while (uVar9 <= pEVar5->ArcN && pEVar5->ArcN != uVar9);
        }
        fwrite(&DAT_0814740a,1,4,(FILE *)FP);
      }
      local_24 = local_24 + 1;
    } while (local_24 <= Data->ElementN && Data->ElementN != local_24);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

int __regparm3 WritePCB(FILE *FP)

{
  int iVar1;
  int iVar2;
  LibraryEntryTypePtr *pLVar3;
  PCBTypePtr pPVar4;
  int iVar5;
  ushort **ppuVar6;
  AttributeType *pAVar7;
  DataTypePtr *pDVar8;
  char *S;
  LineTypePtr pLVar9;
  int iVar10;
  RatTypePtr *pRVar11;
  Cardinal Number;
  uint uVar12;
  uint uVar13;
  LibraryMenuTypePtr *pLVar14;
  int local_74;
  FILE *local_80;
  int local_4c;
  PCBTypePtr local_48;
  int local_38;
  int local_34;
  int local_30;
  Cardinal local_2c;
  uint local_28;
  
  WritePCBInfoHeader(FP);
  __fprintf_chk(FP,1,
                "\n# To read pcb files, the pcb version (or the cvs source date) must be >= the file version\n"
               );
  __fprintf_chk(FP,1,"FileVersion[%i]\n",0x1324007);
  fwrite(&DAT_08147487,1,5,(FILE *)FP);
  S = PCB->Name;
  if (S == (char *)0x0) {
    S = "";
  }
  PrintQuotedString(FP,S);
  __fprintf_chk(FP,1," %i %i]\n\n",PCB->MaxWidth,PCB->MaxHeight);
  local_74 = (int)Settings.DrawGrid;
  iVar5 = PCB->GridOffsetY;
  iVar10 = PCB->GridOffsetX;
  S = c_dtostr(PCB->Grid);
  __fprintf_chk(FP,1,"Grid[%s %i %i %i]\n",S,iVar10,iVar5,local_74);
  S = c_dtostr(PCB->Zoom);
  if (Settings.ShowSolderSide == '\0') {
    iVar5 = (int)ROUND((double)(Output.Height / 2) / Zoom_Multiplier) + Yorig;
  }
  else {
    iVar5 = (PCB->MaxHeight - (int)ROUND((double)(Output.Height / 2) / Zoom_Multiplier)) - Yorig;
  }
  __fprintf_chk(FP,1,"Cursor[%i %i %s]\n",
                (int)ROUND((double)(Output.Width / 2) / Zoom_Multiplier) + Xorig,iVar5,S,local_74);
  S = c_dtostr(PCB->IsleArea);
  __fprintf_chk(FP,1,"PolyArea[%s]\n",S);
  S = c_dtostr(PCB->ThermScale);
  __fprintf_chk(FP,1,"Thermal[%s]\n",S);
  __fprintf_chk(FP,1,"DRC[%i %i %i %i %i %i]\n",PCB->Bloat,PCB->Shrink,PCB->minWid,PCB->minSlk,
                PCB->minDrill,PCB->minRing);
  S = pcbflags_to_string(PCB->Flags);
  __fprintf_chk(FP,1,"Flags(%s)\n",S);
  S = LayerGroupsToString((LayerGroupTypePtr)&PCB->LayerGroups);
  __fprintf_chk(FP,1,"Groups(\"%s\")\n",S);
  fwrite("Styles[\"",1,8,(FILE *)FP);
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i:",PCB->RouteStyle[0].Name,PCB->RouteStyle[0].Thick,
                PCB->RouteStyle[0].Diameter,PCB->RouteStyle[0].Hole,PCB->RouteStyle[0].Keepaway);
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i:",PCB->RouteStyle[1].Name,PCB->RouteStyle[1].Thick,
                PCB->RouteStyle[1].Diameter,PCB->RouteStyle[1].Hole,PCB->RouteStyle[1].Keepaway);
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i:",PCB->RouteStyle[2].Name,PCB->RouteStyle[2].Thick,
                PCB->RouteStyle[2].Diameter,PCB->RouteStyle[2].Hole,PCB->RouteStyle[2].Keepaway);
  local_38 = PCB->RouteStyle[3].Keepaway;
  local_34 = PCB->RouteStyle[3].Hole;
  local_30 = PCB->RouteStyle[3].Diameter;
  local_80 = (FILE *)PCB->RouteStyle[3].Name;
  __fprintf_chk(FP,1,"%s,%i,%i,%i,%i\"]\n\n",local_80,PCB->RouteStyle[3].Thick,local_30,local_34,
                local_38);
  local_4c = 0;
  local_48 = PCB;
  do {
    if ((local_48->Font).Symbol[0].Valid != '\0') {
      ppuVar6 = __ctype_b_loc();
      if ((*(byte *)((int)*ppuVar6 + local_4c * 2 + 1) & 0x40) == 0) {
        __fprintf_chk(FP,1,"Symbol[%i %i]\n(\n",local_4c,(local_48->Font).Symbol[0].Delta,local_30,
                      local_34,local_38);
      }
      else {
        iVar5 = (local_48->Font).Symbol[0].Delta;
        if (iVar5 == (iVar5 / 100) * 100) {
          __fprintf_chk(FP,1,"Symbol(\'%c\' %i)\n(\n",(int)(char)local_4c,iVar5 / 100,local_30,
                        local_34,local_38);
        }
        else {
          __fprintf_chk(FP,1,"Symbol[\'%c\' %i]\n(\n",(int)(char)local_4c,iVar5,local_30,local_34,
                        local_38);
        }
      }
      local_2c = (local_48->Font).Symbol[0].LineN;
      pLVar9 = (local_48->Font).Symbol[0].Line;
      if (local_2c != 0) {
        do {
          iVar5 = (pLVar9->Point1).X;
          if (iVar5 == (iVar5 / 100) * 100) {
            iVar10 = (pLVar9->Point1).Y;
            if (iVar10 != (iVar10 / 100) * 100) {
              iVar2 = pLVar9->Thickness;
              iVar1 = (pLVar9->Point2).Y;
              local_74 = (pLVar9->Point2).X;
              goto LAB_08092b22;
            }
            local_74 = (pLVar9->Point2).X;
            local_30 = local_74 / 100;
            if (local_74 != local_30 * 100) goto LAB_08092c09;
            iVar1 = (pLVar9->Point2).Y;
            local_34 = iVar1 / 100;
            if (iVar1 != local_34 * 100) {
              iVar2 = pLVar9->Thickness;
              goto LAB_08092b22;
            }
            iVar2 = pLVar9->Thickness;
            local_38 = iVar2 / 100;
            if (iVar2 != local_38 * 100) goto LAB_08092b22;
            __fprintf_chk(FP,1,"\tSymbolLine(%i %i %i %i %i)\n",iVar5 / 100,iVar10 / 100,local_30,
                          local_34,local_38);
          }
          else {
            iVar10 = (pLVar9->Point1).Y;
            local_74 = (pLVar9->Point2).X;
LAB_08092c09:
            local_30 = local_74;
            iVar2 = pLVar9->Thickness;
            iVar1 = (pLVar9->Point2).Y;
            local_74 = local_30;
LAB_08092b22:
            local_30 = local_74;
            local_34 = iVar1;
            local_38 = iVar2;
            __fprintf_chk(FP,1,"\tSymbolLine[%i %i %i %i %i]\n",iVar5,iVar10,local_30,local_34,
                          local_38);
          }
          local_2c = local_2c - 1;
          if (local_2c == 0) break;
          pLVar9 = pLVar9 + 1;
        } while( true );
      }
      local_80 = FP;
      fwrite(&DAT_0814740c,1,2,(FILE *)FP);
    }
    pPVar4 = PCB;
    local_4c = local_4c + 1;
    local_48 = (PCBTypePtr)&local_48->Netlistname;
    if (local_4c == 0x100) {
      if (0 < (PCB->Attributes).Number) {
        iVar5 = 0;
        do {
          iVar10 = iVar5 + 1;
          pAVar7 = (pPVar4->Attributes).List + iVar5;
          local_80 = (FILE *)&DAT_0814741b;
          __fprintf_chk(FP,1,"%sAttribute(\"%s\" \"%s\")\n",&DAT_0814741b,pAVar7->name,pAVar7->value
                        ,local_34,local_38);
          iVar5 = iVar10;
        } while (iVar10 < (pPVar4->Attributes).Number);
      }
      WriteViaData(FP,PCB->Data);
      WriteElementData(FP,PCB->Data);
      pDVar8 = PCB->Data;
      if (pDVar8->RatN != 0) {
        uVar12 = 0;
        do {
          uVar13 = uVar12 + 1;
          pRVar11 = pDVar8->Rat + uVar12;
          __fprintf_chk(FP,1,"Rat[%i %i %i %i %i %i ",(pRVar11->Point1).X,(pRVar11->Point1).Y,
                        pRVar11->group1,(pRVar11->Point2).X,(pRVar11->Point2).Y,pRVar11->group2);
          local_80 = (FILE *)flags_to_string(pRVar11->Flags,0x20);
          __fprintf_chk(FP,1,0x81473e1,local_80);
          pDVar8 = PCB->Data;
          uVar12 = uVar13;
        } while (uVar13 < pDVar8->RatN);
      }
      if (pDVar8->LayerN != -2) {
        Number = 0;
        do {
          uVar12 = Number + 1;
          WriteLayerData(FP,Number,(LayerTypePtr)(&pDVar8->field_0x4c + Number * 0x5c));
          pDVar8 = PCB->Data;
          Number = uVar12;
        } while (uVar12 < pDVar8->LayerN + 2U);
      }
      if ((PCB->NetlistLib).MenuN != 0) {
        __fprintf_chk(FP,1,"NetList()\n(\n",local_80);
        if ((PCB->NetlistLib).MenuN != 0) {
          local_28 = 0;
          do {
            pLVar14 = (PCB->NetlistLib).Menu + local_28;
            __fprintf_chk(FP,1,"\tNet(");
            PrintQuotedString(FP,pLVar14->Name + 2);
            __fprintf_chk(FP,1,&DAT_08156730);
            S = pLVar14->Style;
            if (S == (char *)0x0) {
              S = "(unknown)";
            }
            else {
              if (*S == '\0') {
                S = "(unknown)";
              }
            }
            PrintQuotedString(FP,S);
            __fprintf_chk(FP,1,")\n\t(\n");
            if (pLVar14->EntryN != 0) {
              uVar12 = 0;
              do {
                uVar13 = uVar12 + 1;
                pLVar3 = pLVar14->Entry;
                __fprintf_chk(FP,1,"\t\tConnect(");
                PrintQuotedString(FP,pLVar3[uVar12].ListEntry);
                __fprintf_chk(FP,1,&DAT_0814740c);
                uVar12 = uVar13;
              } while (uVar13 < pLVar14->EntryN);
            }
            __fprintf_chk(FP,1,&DAT_0814740b);
            local_28 = local_28 + 1;
          } while (local_28 < (PCB->NetlistLib).MenuN);
        }
        __fprintf_chk(FP,1,&DAT_0814740c);
      }
      return 0;
    }
  } while( true );
}



int __regparm3 WritePCBFile(char *Filename)

{
  FILE *FP;
  int iVar1;
  
  FP = (FILE *)fopen(Filename,"w");
  if (FP == (FILE *)0x0) {
    iVar1 = -1;
    OpenErrorMessage(Filename);
  }
  else {
    iVar1 = WritePCB(FP);
    fclose((FILE *)FP);
  }
  return iVar1;
}



void SaveTMPData(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  __sprintf_chk(TMPFilename,1,0x50,"PCB.%.8i.save",_Var1);
  WritePCBFile(TMPFilename);
  return;
}



void SaveInTMP(void)

{
  int iVar1;
  __pid_t _Var2;
  int in_GS_OFFSET;
  char filename [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((PCB != (PCBTypePtr)0x0) && (PCB->Changed != '\0')) {
    _Var2 = getpid();
    __sprintf_chk(filename,1,0x50,"PCB.%.8i.save",_Var2);
    Message("Trying to save your layout in \'%s\'\n",filename);
    WritePCBFile(filename);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void EmergencySave(void)

{
  if (dont_save_any_more != '\0') {
    return;
  }
  SaveInTMP();
  dont_save_any_more = '\x01';
  return;
}



void Backup(void)

{
  size_t sVar1;
  __pid_t _Var2;
  char *Filename;
  
  if ((PCB == (PCBTypePtr)0x0) || (PCB->Filename == (char *)0x0)) {
    Filename = (char *)calloc(1,0x17);
    if (Filename == (char *)0x0) goto LAB_080932a5;
    _Var2 = getpid();
    __sprintf_chk(Filename,1,0x17,"PCB.%.8i.backup",_Var2);
  }
  else {
    sVar1 = strlen(PCB->Filename);
    Filename = (char *)calloc(1,sVar1 + 2);
    if (Filename == (char *)0x0) {
LAB_080932a5:
      __fprintf_chk(stderr,1,"Backup():  malloc failed\n");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    __sprintf_chk(Filename,1,0xffffffff,&DAT_08147608,PCB->Filename);
  }
  WritePCBFile(Filename);
  free(Filename);
  return;
}



void backup_cb(hidval data)

{
  undefined4 local_10 [2];
  
  backup_timer = 0;
  Backup();
  if ((0 < Settings.BackupInterval) &&
     (gui->add_timer != (anon_subr_hidval_anon_subr_void_hidval_ptr_ulong_hidval_for_add_timer *)0x0
     )) {
    (*gui->add_timer)((anon_subr_void_hidval *)local_10,(ulong)backup_cb,
                      Settings.BackupInterval * 1000);
    backup_timer = local_10[0];
  }
  return;
}



void PostLoadElementPCB(void)

{
  ElementTypePtr *Element;
  PCBTypePtr pPVar1;
  PCBTypePtr pPVar2;
  
  pPVar1 = PCB;
  if (yyPCB != (PCBTypePtr)0x0) {
    CreateNewPCBPost(yyPCB,0);
    ParseGroupString("1,c:2,s",(LayerGroupTypePtr)&yyPCB->LayerGroups,yyData->LayerN);
    PCB = yyPCB;
    Element = yyPCB->Data->Element;
    MoveElementLowLevel(yyPCB->Data,Element,-(Element->BoundingBox).X1,-(Element->BoundingBox).Y1);
    pPVar2 = yyPCB;
    PCB = pPVar1;
    yyPCB->MaxWidth = (Element->BoundingBox).X2;
    pPVar2->MaxHeight = (Element->BoundingBox).Y2;
  }
  return;
}



int LoadPCB(char *Filename)

{
  int Width;
  int Height;
  PCBTypePtr Ptr;
  int iVar1;
  char *pcVar2;
  
  Ptr = CreateNewPCB('\0');
  iVar1 = ParsePCB(Ptr,Filename);
  if (iVar1 == 0) {
    RemovePCB(PCB);
    PCB = Ptr;
    CreateNewPCBPost(Ptr,0);
    ResetStackAndVisibility();
    Width = PCB->MaxWidth;
    Crosshair.X = Width;
    if (PCB->CursorX == Width || PCB->CursorX < Width) {
      Crosshair.X = PCB->CursorX;
    }
    if (Crosshair.X < 0) {
      Crosshair.X = iVar1;
    }
    Height = PCB->MaxHeight;
    Crosshair.Y = PCB->CursorY;
    if (PCB->CursorY != Height && Height <= PCB->CursorY) {
      Crosshair.Y = Height;
    }
    if (Crosshair.Y < 0) {
      Crosshair.Y = iVar1;
    }
    Xorig = Crosshair.X - (int)ROUND((double)(Output.Width / 2) / Zoom_Multiplier);
    Yorig = Crosshair.Y - (int)ROUND((double)(Output.Height / 2) / Zoom_Multiplier);
    ChangePCBSize(Width,Height);
    if ((PCB->Font).Valid == '\0') {
      Message("File \'%s\' has no font information, using default font\n",Filename);
      CreateDefaultFont();
    }
    SetChangedFlag('\0');
    Ptr = PCB;
    pcVar2 = MyStrdup(Filename,"LoadPCB()");
    Ptr->Filename = pcVar2;
    Settings.grid_units_mm = (double)(int)ROUND(PCB->Grid) != PCB->Grid;
    netlist_sort_offset = 2;
    sort_library((LibraryTypePtr)&PCB->NetlistLib);
    netlist_sort_offset = 0;
    iVar1 = hid_get_flag("style");
    if (iVar1 == 0) {
      SetLineSize(PCB->RouteStyle[0].Thick);
      SetViaSize(PCB->RouteStyle[0].Diameter,'\x01');
      SetViaDrillingHole(PCB->RouteStyle[0].Hole,'\x01');
      SetKeepawayWidth(PCB->RouteStyle[0].Keepaway);
    }
    hid_action("PCBChanged");
    return 0;
  }
  hid_action("PCBChanged");
  RemovePCB(Ptr);
  return 1;
}



int __regparm3 WritePipe(char *Filename,Boolean thePcb)

{
  bool bVar1;
  DynamicStringType command;
  char Char;
  int iVar2;
  int iVar3;
  Cardinal Number;
  uint uVar4;
  FILE *FP;
  char *pcVar5;
  
  if ((Settings.SaveCommand == (char *)0x0) || (*Settings.SaveCommand == '\0')) {
    FP = (FILE *)fopen(Filename,"w");
    if (FP == (FILE *)0x0) {
      Message("Unable to write to file %s\n",Filename);
      return -1;
    }
    bVar1 = false;
  }
  else {
    DSClearString((DynamicStringTypePtr_conflict *)0x816c0dc);
    pcVar5 = Settings.SaveCommand;
    while (Char = *pcVar5, Char != '\0') {
      while ((Char == '%' && (pcVar5[1] == 'f'))) {
        pcVar5 = pcVar5 + 2;
        DSAddString((DynamicStringTypePtr_conflict *)0x816c0dc,Filename);
        Char = *pcVar5;
        if (Char == '\0') goto LAB_080937c0;
      }
      pcVar5 = pcVar5 + 1;
      DSAddCharacter((DynamicStringTypePtr_conflict *)0x816c0dc,Char);
    }
LAB_080937c0:
    DSAddCharacter((DynamicStringTypePtr_conflict *)0x816c0dc,'\0');
    __printf_chk(1,"write to pipe \"%s\"\n",command.Data);
    FP = (FILE *)popen(command.Data,"w");
    if (FP == (FILE *)0x0) {
      PopenErrorMessage(command.Data);
      return -1;
    }
    bVar1 = true;
  }
  if (thePcb == '\0') {
    WriteViaData(FP,Buffers[Settings.BufferNumber].Data);
    WriteElementData(FP,Buffers[Settings.BufferNumber].Data);
    if (PCB->Data->LayerN != -2) {
      Number = 0;
      do {
        uVar4 = Number + 1;
        WriteLayerData(FP,Number,
                       (LayerTypePtr)
                       (&(Buffers[Settings.BufferNumber].Data)->field_0x4c + Number * 0x5c));
        Number = uVar4;
      } while (uVar4 < PCB->Data->LayerN + 2U);
    }
    iVar2 = 0;
  }
  else {
    iVar2 = WritePCB(FP);
  }
  if (bVar1) {
    iVar3 = pclose((FILE *)FP);
  }
  else {
    iVar3 = fclose((FILE *)FP);
  }
  if (iVar3 == 0) {
    return iVar2;
  }
  return -1;
}



int SavePCB(char *Filename)

{
  int iVar1;
  char *pcVar2;
  
  iVar1 = WritePipe(Filename,'\x01');
  if (iVar1 == 0) {
    pcVar2 = MyStrdup(Filename,"SavePCB()");
    SaveFree(PCB->Filename);
    PCB->Filename = pcVar2;
    SetChangedFlag('\0');
  }
  return iVar1;
}



int SaveBufferElements(char *Filename)

{
  int iVar1;
  
  if (Settings.ShowSolderSide != '\0') {
    SwapBuffers();
  }
  iVar1 = WritePipe(Filename,'\0');
  if (Settings.ShowSolderSide == '\0') {
    return iVar1;
  }
  SwapBuffers();
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

int ParseLibraryTree(void)

{
  char cVar1;
  char *__s;
  char *__src;
  DIR *__dirp;
  dirent *pdVar2;
  int iVar3;
  LibraryMenuTypePtr *Menu;
  char *__s_00;
  DIR *__dirp_00;
  size_t sVar4;
  LibraryEntryTypePtr *pLVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  undefined4 *puVar9;
  char *__dest;
  char *pcVar10;
  int in_GS_OFFSET;
  bool bVar11;
  byte bVar12;
  int local_209c;
  stat buffer;
  char working [4097];
  char path [4097];
  int local_20;
  
  bVar12 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  bVar11 = ((uint)path & 1) != 0;
  uVar8 = 0x1001;
  puVar9 = (undefined4 *)path;
  if (bVar11) {
    path[0] = '\0';
    puVar9 = (undefined4 *)(path + 1);
    uVar8 = 0x1000;
  }
  if (((uint)puVar9 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    uVar8 = uVar8 - 2;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  uVar6 = uVar8 >> 2;
  while (uVar6 != 0) {
    uVar6 = uVar6 - 1;
    *puVar9 = 0;
    puVar9 = puVar9 + 1;
  }
  if ((uVar8 & 2) != 0) {
    *(undefined2 *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  if (!bVar11) {
    *(undefined *)puVar9 = 0;
  }
  puVar9 = (undefined4 *)working;
  uVar8 = 0x1001;
  bVar11 = ((uint)puVar9 & 2) != 0;
  if (bVar11) {
    working._0_2_ = 0;
    puVar9 = (undefined4 *)(working + 2);
    uVar8 = 0xfff;
  }
  uVar8 = uVar8 >> 2;
  while (uVar8 != 0) {
    uVar8 = uVar8 - 1;
    *puVar9 = 0;
    puVar9 = puVar9 + 1;
  }
  if (bVar11) {
    *(undefined2 *)puVar9 = 0;
    puVar9 = (undefined4 *)((int)puVar9 + 2);
  }
  *(undefined *)puVar9 = 0;
  GetWorkingDirectory(working);
  __s = MyStrdup(Settings.LibraryTree,"ParseLibraryTree");
  __src = strtok(__s,":");
  if ((__src == (char *)0x0) || (*__src == '\0')) {
    local_209c = 0;
  }
  else {
    local_209c = 0;
    do {
      strncpy(path,__src,0x1000);
      chdir(working);
      __dirp = opendir(path);
      if (__dirp == (DIR *)0x0) {
        OpendirErrorMessage(path);
      }
      else {
        chdir(path);
        GetWorkingDirectory(path);
        while (pdVar2 = readdir(__dirp), pdVar2 != (dirent *)0x0) {
          __src = pdVar2->d_name;
          chdir(path);
          iVar3 = __xstat(3,__src,(stat *)&buffer);
          if ((((iVar3 == 0) && ((buffer.st_mode & 0xf000) == 0x4000)) && (pdVar2->d_name[0] != '.')
              ) && (((pdVar2->d_name[0] != 'C' || (pdVar2->d_name[1] != 'V')) ||
                    ((pdVar2->d_name[2] != 'S' || (pdVar2->d_name[3] != '\0')))))) {
            Menu = GetLibraryMenuMemory((LibraryTypePtr)&Library);
            __s_00 = MyStrdup(__src,"ParseLibraryTree()");
            Menu->Name = __s_00;
            __s_00 = strrchr(path,0x2f);
            puVar9 = (undefined4 *)(__s_00 + 1);
            if (__s_00 == (char *)0x0) {
              puVar9 = (undefined4 *)path;
            }
            __s_00 = (char *)__strdup(puVar9);
            Menu->directory = __s_00;
            __dirp_00 = opendir(__src);
            chdir(__src);
            if (__dirp_00 != (DIR *)0x0) {
              while (pdVar2 = readdir(__dirp_00), pdVar2 != (dirent *)0x0) {
                __s_00 = pdVar2->d_name;
                sVar4 = strlen(__s_00);
                iVar3 = __xstat(3,__s_00,(stat *)&buffer);
                if (((iVar3 == 0) && ((buffer.st_mode & 0xf000) == 0x8000)) &&
                   ((pdVar2->d_name[0] != '.' &&
                    ((((bVar11 = pdVar2->d_name[0] == 'C', !bVar11 ||
                       (bVar11 = pdVar2->d_name[1] == 'V', !bVar11)) ||
                      (bVar11 = pdVar2->d_name[2] == 'S', !bVar11)) ||
                     (bVar11 = pdVar2->d_name[3] == '\0', !bVar11)))))) {
                  iVar3 = 9;
                  __dest = __s_00;
                  pcVar10 = "Makefile";
                  do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar11 = *__dest == *pcVar10;
                    __dest = __dest + (uint)bVar12 * -2 + 1;
                    pcVar10 = pcVar10 + (uint)bVar12 * -2 + 1;
                  } while (bVar11);
                  if (!bVar11) {
                    iVar3 = 0xc;
                    __dest = __s_00;
                    pcVar10 = "Makefile.am";
                    do {
                      if (iVar3 == 0) break;
                      iVar3 = iVar3 + -1;
                      bVar11 = *__dest == *pcVar10;
                      __dest = __dest + (uint)bVar12 * -2 + 1;
                      pcVar10 = pcVar10 + (uint)bVar12 * -2 + 1;
                    } while (bVar11);
                    if (!bVar11) {
                      iVar3 = 0xc;
                      __dest = __s_00;
                      pcVar10 = "Makefile.in";
                      do {
                        if (iVar3 == 0) break;
                        iVar3 = iVar3 + -1;
                        bVar11 = *__dest == *pcVar10;
                        __dest = __dest + (uint)bVar12 * -2 + 1;
                        pcVar10 = pcVar10 + (uint)bVar12 * -2 + 1;
                      } while (bVar11);
                      if ((!bVar11) &&
                         ((sVar4 < 4 ||
                          ((iVar3 = strcmp((char *)((int)&pdVar2->d_off + sVar4 + 3),".png"),
                           iVar3 != 0 &&
                           ((sVar4 == 4 ||
                            (iVar3 = strcmp((char *)((int)&pdVar2->d_off + sVar4 + 2),".html"),
                            iVar3 != 0)))))))) {
                        uVar8 = 0xffffffff;
                        puVar9 = (undefined4 *)path;
                        do {
                          if (uVar8 == 0) break;
                          uVar8 = uVar8 - 1;
                          cVar1 = *(char *)puVar9;
                          puVar9 = (undefined4 *)((int)puVar9 + (uint)bVar12 * -2 + 1);
                        } while (cVar1 != '\0');
                        uVar6 = 0xffffffff;
                        __dest = __s_00;
                        do {
                          if (uVar6 == 0) break;
                          uVar6 = uVar6 - 1;
                          cVar1 = *__dest;
                          __dest = __dest + (uint)bVar12 * -2 + 1;
                        } while (cVar1 != '\0');
                        uVar7 = 0xffffffff;
                        __dest = __src;
                        do {
                          if (uVar7 == 0) break;
                          uVar7 = uVar7 - 1;
                          cVar1 = *__dest;
                          __dest = __dest + (uint)bVar12 * -2 + 1;
                        } while (cVar1 != '\0');
                        local_209c = local_209c + 1;
                        pLVar5 = GetLibraryEntryMemory(Menu);
                        __dest = (char *)MyCalloc(1,~uVar6 + ~uVar8 + ~uVar7 + 1,
                                                  "ParseLibraryTree()");
                        pLVar5->AllocatedMemory = __dest;
                        strcat(__dest,path);
                        strcat(pLVar5->AllocatedMemory,"/");
                        strcat(pLVar5->AllocatedMemory,__src);
                        strcat(pLVar5->AllocatedMemory,"/");
                        uVar8 = 0xffffffff;
                        __dest = pLVar5->AllocatedMemory;
                        do {
                          if (uVar8 == 0) break;
                          uVar8 = uVar8 - 1;
                          cVar1 = *__dest;
                          __dest = __dest + (uint)bVar12 * -2 + 1;
                        } while (cVar1 != '\0');
                        pLVar5->ListEntry = pLVar5->AllocatedMemory + (~uVar8 - 1);
                        strcat(pLVar5->AllocatedMemory,__s_00);
                        pLVar5->Template = (char *)0xffffffff;
                      }
                    }
                  }
                }
              }
            }
            closedir(__dirp_00);
          }
        }
        closedir(__dirp);
      }
      __src = strtok((char *)0x0,":");
    } while ((__src != (char *)0x0) && (*__src != '\0'));
  }
  free(__s);
  chdir(working);
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_209c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int ReadLibraryContents(void)

{
  char *command;
  byte bVar1;
  int iVar2;
  char *S;
  uint uVar3;
  uint uVar4;
  LibraryEntryTypePtr *pLVar5;
  size_t sVar6;
  char *pcVar7;
  uint *puVar8;
  uint *puVar9;
  char *pcVar10;
  int in_GS_OFFSET;
  bool bVar11;
  byte bVar12;
  FILE *local_164;
  char *local_160;
  FILE *local_138;
  int local_134;
  LibraryMenuTypePtr *local_130;
  char acStack292 [4];
  char inputline [256];
  int local_20;
  
  bVar12 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  SaveFree(command);
  command = (char *)0x0;
  local_160 = (char *)0x0;
  command = EvaluateFilename(Settings.LibraryContentsCommand,Settings.LibraryPath,
                             Settings.LibraryFilename,(char *)0x0);
  if ((command == (char *)0x0) || (*command == '\0')) {
    local_138 = (FILE *)0x0;
  }
  else {
    local_138 = popen(command,"r");
    if (local_138 == (FILE *)0x0) {
      PopenErrorMessage(command);
    }
    else {
      local_130 = (LibraryMenuTypePtr *)0x0;
      while (local_164 = local_138, S = fgets(inputline,0xff,local_138), puVar9 = (uint *)inputline,
            S != (char *)0x0) {
        do {
          puVar8 = puVar9;
          uVar3 = *puVar8 + 0xfefefeff & ~*puVar8;
          uVar4 = uVar3 & 0x80808080;
          puVar9 = puVar8 + 1;
        } while (uVar4 == 0);
        bVar11 = (uVar3 & 0x8080) == 0;
        bVar1 = (byte)uVar4;
        if (bVar11) {
          bVar1 = (byte)(uVar4 >> 0x10);
        }
        if (bVar11) {
          puVar9 = (uint *)((int)puVar8 + 6);
        }
        iVar2 = (int)puVar9 + ((-3 - (uint)CARRY1(bVar1,bVar1)) - (int)inputline);
        bVar11 = iVar2 == 0;
        if (!bVar11) {
          bVar11 = inputline[iVar2 + -1] == '\n';
          if (bVar11) {
            inputline[iVar2 + -1] = '\0';
          }
          else {
            Message("linelength (%i) exceeded; following characters will be ignored\n",0xff,
                    local_164,local_160);
          }
        }
        iVar2 = 5;
        puVar9 = (uint *)inputline;
        S = "TYPE=";
        do {
          if (iVar2 == 0) break;
          iVar2 = iVar2 + -1;
          bVar11 = *(char *)puVar9 == *S;
          puVar9 = (uint *)((int)puVar9 + (uint)bVar12 * -2 + 1);
          S = S + (uint)bVar12 * -2 + 1;
        } while (bVar11);
        if (bVar11) {
          local_130 = GetLibraryMenuMemory((LibraryTypePtr)&Library);
          S = "(unknown)";
          if (inputline[5] != '\0') {
            S = inputline + 5;
          }
          S = MyStrdup(S,"ReadLibraryDescription()");
          local_130->Name = S;
          S = (char *)__strdup(Settings.LibraryFilename);
          local_130->directory = S;
        }
        else {
          if (local_130 == (LibraryMenuTypePtr *)0x0) {
            local_130 = GetLibraryMenuMemory((LibraryTypePtr)&Library);
            local_160 = MyStrdup("(unknown)","ReadLibraryDescription()");
            local_130->Name = local_160;
            local_160 = (char *)__strdup(Settings.LibraryFilename);
            local_130->directory = local_160;
          }
          pLVar5 = GetLibraryEntryMemory(local_130);
          local_160 = MyStrdup(inputline,"ReadLibraryDescription()");
          pLVar5->AllocatedMemory = local_160;
          local_160 = strtok(local_160,":");
          pLVar5->Template = local_160;
          if (local_160 == (char *)0x0) {
LAB_08094178:
            local_160 = pLVar5->Description;
LAB_080940ea:
            if (pLVar5->Value == (char *)0x0) {
              local_134 = 4;
            }
            else {
              sVar6 = strlen(pLVar5->Value);
              local_134 = sVar6 + 4;
            }
          }
          else {
            local_160 = strtok((char *)0x0,":");
            pLVar5->Package = local_160;
            if (local_160 == (char *)0x0) goto LAB_08094178;
            local_160 = strtok((char *)0x0,":");
            pLVar5->Value = local_160;
            if (local_160 != (char *)0x0) {
              local_160 = strtok((char *)0x0,":");
              pLVar5->Description = local_160;
              goto LAB_080940ea;
            }
            local_160 = pLVar5->Description;
            local_134 = 4;
          }
          sVar6 = 0;
          if (local_160 != (char *)0x0) {
            sVar6 = strlen(local_160);
          }
          pcVar7 = (char *)MyCalloc(sVar6 + local_134,1,"ReadLibraryDescription()");
          S = pLVar5->Description;
          if (S == (char *)0x0) {
            S = "";
          }
          pLVar5->ListEntry = pcVar7;
          pcVar10 = pLVar5->Value;
          local_160 = "%s, %s";
          if (pcVar10 == (char *)0x0) {
            pcVar10 = "";
          }
          __sprintf_chk(pcVar7,1,0xffffffff,"%s, %s",pcVar10,S);
        }
      }
      pclose(local_138);
    }
  }
  iVar2 = ParseLibraryTree();
  if ((0 < iVar2) || (iVar2 = 1, local_138 != (FILE *)0x0)) {
    sort_library((LibraryTypePtr)&Library);
    iVar2 = 0;
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



Boolean __regparm1 BoxBoxIntersection(BoxTypePtr b1,BoxTypePtr b2)

{
  int *in_stack_00000008;
  
  if (((b2->X1 <= in_stack_00000008[2]) && (*in_stack_00000008 <= b2->X2)) &&
     (b2->Y1 <= in_stack_00000008[3])) {
    return (Boolean)(in_stack_00000008[1] <= b2->Y2);
  }
  return '\0';
}



Boolean __regparm3 PrepareNextLoop(FILE *FP)

{
  int iVar1;
  int iVar2;
  
  iVar1 = PCB->Data->LayerN;
  if (iVar1 != 0) {
    iVar2 = 0;
    do {
      *(undefined4 *)((int)&LineList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&LineList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Location + iVar2) = 0;
      iVar2 = iVar2 + 0x14;
    } while (iVar2 != iVar1 * 0x14);
  }
  PadList[0].Location = 0;
  PadList[0].Number = 0;
  PadList[1].Location = 0;
  PadList[1].Number = 0;
  RatList.Location = 0;
  RatList.Number = 0;
  PVList.Location = 0;
  PVList.Number = 0;
  return '\0';
}



void DumpList(void)

{
  int iVar1;
  int iVar2;
  
  PadList[0].Number = 0;
  PadList[0].Location = 0;
  PadList[0].DrawLocation = 0;
  PadList[1].Number = 0;
  PadList[1].Location = 0;
  PadList[1].DrawLocation = 0;
  PVList.Number = 0;
  PVList.Location = 0;
  iVar1 = PCB->Data->LayerN;
  if (iVar1 != 0) {
    iVar2 = 0;
    do {
      *(undefined4 *)((int)&LineList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&LineList[0].DrawLocation + iVar2) = 0;
      *(undefined4 *)((int)&LineList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].DrawLocation + iVar2) = 0;
      *(undefined4 *)((int)&ArcList[0].Number + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Location + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].DrawLocation + iVar2) = 0;
      *(undefined4 *)((int)&PolygonList[0].Number + iVar2) = 0;
      iVar2 = iVar2 + 0x14;
    } while (iVar2 != iVar1 * 0x14);
  }
  RatList.Location = 0;
  RatList.DrawLocation = 0;
  RatList.Number = 0;
  return;
}



void SaveFindFlag(int NewFlag)

{
  OldFlag = TheFlag;
  TheFlag = NewFlag;
  return;
}



void RestoreFindFlag(void)

{
  TheFlag = OldFlag;
  return;
}



void __regparm3 LocateError(LocationType *x,LocationType *y)

{
  int *piVar1;
  void *pvVar2;
  int iVar3;
  
  pvVar2 = thing_ptr3;
  if (thing_type == 8) {
    piVar1 = *(int **)(*(int *)((int)thing_ptr3 + 0x2c) + 8);
    *x = (piVar1[2] + *piVar1) / 2;
    iVar3 = piVar1[3] + piVar1[1];
  }
  else {
    if (thing_type < 9) {
      if (thing_type == 2) {
        *x = *(LocationType *)((int)thing_ptr3 + 0xd8);
        *y = *(LocationType *)((int)pvVar2 + 0xdc);
        return;
      }
      if (thing_type != 4) {
        if (thing_type != 1) {
          return;
        }
        goto LAB_080944fa;
      }
    }
    else {
      if (thing_type != 0x200) {
        if ((thing_type != 0x4000) && (thing_type != 0x100)) {
          return;
        }
LAB_080944fa:
        *x = *(LocationType *)((int)thing_ptr3 + 0x34);
        *y = *(LocationType *)((int)pvVar2 + 0x38);
        return;
      }
    }
    *x = (*(int *)((int)thing_ptr3 + 0x40) + *(int *)((int)thing_ptr3 + 0x2c)) / 2;
    iVar3 = *(int *)((int)pvVar2 + 0x44) + *(int *)((int)pvVar2 + 0x30);
  }
  *y = iVar3 / 2;
  return;
}



Boolean __regparm3 ADD_PV_TO_LIST(PinTypePtr *Pin)

{
  Boolean BVar1;
  PinTypePtr *Ptr1;
  int Type;
  
  if (User != '\0') {
    Type = 0x100;
    Ptr1 = (PinTypePtr *)Pin->Element;
    if ((PinTypePtr *)Pin->Element == (PinTypePtr *)0x0) {
      Type = 1;
      Ptr1 = Pin;
    }
    AddObjectToFlagUndoList(Type,Ptr1,Pin,Pin);
  }
  (Pin->Flags).f = (Pin->Flags).f | TheFlag;
  *(PinTypePtr **)(PVList.Data + PVList.Number) = Pin;
  if ((drc == '\0') || ((*(byte *)&(Pin->Flags).f & 0x40) != 0)) {
    BVar1 = '\0';
  }
  else {
    thing_ptr1 = Pin->Element;
    BVar1 = '\x01';
    thing_type = 0x100;
    thing_ptr2 = Pin;
    thing_ptr3 = Pin;
    if (thing_ptr1 == (void *)0x0) {
      thing_type = 1;
      thing_ptr1 = Pin;
    }
  }
  PVList.Number = PVList.Number + 1;
  return BVar1;
}



Boolean __regparm3 ADD_RAT_TO_LIST(RatTypePtr *Ptr)

{
  uint uVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(0x20,Ptr,Ptr,Ptr);
  }
  uVar1 = TheFlag | (Ptr->Flags).f;
  *(RatTypePtr **)(RatList.Data + RatList.Number) = Ptr;
  bVar2 = drc != '\0';
  (Ptr->Flags).f = uVar1;
  if ((bVar2) && ((uVar1 & 0x40) == 0)) {
    thing_ptr1 = Ptr;
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 0x20;
    RatList.Number = RatList.Number + 1;
    return '\x01';
  }
  RatList.Number = RatList.Number + 1;
  return '\0';
}



Boolean __regparm3 ADD_LINE_TO_LIST(Cardinal L,LineTypePtr Ptr)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(4,(void *)(&PCB->Data->field_0x4c + L * 0x5c),Ptr,Ptr);
  }
  (Ptr->Flags).f = (Ptr->Flags).f | TheFlag;
  CVar1 = LineList[L].Number;
  *(LineTypePtr *)(LineList[L].Data + CVar1) = Ptr;
  bVar2 = drc != '\0';
  LineList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Ptr->Flags).f & 0x40) == 0)) {
    thing_ptr1 = (void *)(&PCB->Data->field_0x4c + L * 0x5c);
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 4;
    return '\x01';
  }
  return '\0';
}



Boolean __regparm3 ADD_ARC_TO_LIST(Cardinal L,ArcTypePtr *Ptr)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(0x4000,(void *)(&PCB->Data->field_0x4c + L * 0x5c),Ptr,Ptr);
  }
  (Ptr->Flags).f = (Ptr->Flags).f | TheFlag;
  CVar1 = ArcList[L].Number;
  *(ArcTypePtr **)(ArcList[L].Data + CVar1) = Ptr;
  bVar2 = drc != '\0';
  ArcList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Ptr->Flags).f & 0x40) == 0)) {
    thing_ptr1 = (void *)(&PCB->Data->field_0x4c + L * 0x5c);
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 0x4000;
    return '\x01';
  }
  return '\0';
}



Boolean __regparm3 ADD_POLYGON_TO_LIST(Cardinal L,PolygonTypePtr Ptr)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(8,(void *)(&PCB->Data->field_0x4c + L * 0x5c),Ptr,Ptr);
  }
  (Ptr->Flags).f = (Ptr->Flags).f | TheFlag;
  CVar1 = PolygonList[L].Number;
  *(PolygonTypePtr *)(PolygonList[L].Data + CVar1) = Ptr;
  bVar2 = drc != '\0';
  PolygonList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Ptr->Flags).f & 0x40) == 0)) {
    thing_ptr1 = (void *)(&PCB->Data->field_0x4c + L * 0x5c);
    thing_ptr2 = Ptr;
    thing_ptr3 = Ptr;
    thing_type = 8;
    return '\x01';
  }
  return '\0';
}



Boolean __regparm3 ADD_PAD_TO_LIST(Cardinal L,PadTypePtr *Pad)

{
  Cardinal CVar1;
  bool bVar2;
  
  if (User != '\0') {
    AddObjectToFlagUndoList(0x200,Pad->Element,Pad,Pad);
  }
  (Pad->Flags).f = (Pad->Flags).f | TheFlag;
  CVar1 = PadList[L].Number;
  *(PadTypePtr **)(PadList[L].Data + CVar1) = Pad;
  bVar2 = drc != '\0';
  PadList[L].Number = CVar1 + 1;
  if ((bVar2) && ((*(byte *)&(Pad->Flags).f & 0x40) == 0)) {
    thing_ptr1 = Pad->Element;
    thing_ptr2 = Pad;
    thing_ptr3 = Pad;
    thing_type = 0x200;
    return '\x01';
  }
  return '\0';
}



void __regparm3 pcb_drc_violation_free(DrcViolationType *violation)

{
  free(violation->title);
  free(violation->explanation);
  free(violation);
  return;
}



void __regparm3 BuildObjectList(int *object_count,long **object_id_list,int **object_type_list)

{
  long lVar1;
  long *plVar2;
  int *piVar3;
  
  *object_count = 0;
  *object_id_list = (long *)0x0;
  if (thing_type != 8) {
    if (thing_type < 9) {
      if (thing_type < 1) {
        return;
      }
      if ((2 < thing_type) && (thing_type != 4)) {
        return;
      }
    }
    else {
      if (((thing_type != 0x200) && (thing_type != 0x4000)) && (thing_type != 0x100)) {
        return;
      }
    }
  }
  *object_count = 1;
  plVar2 = (long *)calloc(1,4);
  *object_id_list = plVar2;
  piVar3 = (int *)calloc(1,4);
  plVar2 = *object_id_list;
  lVar1 = *(long *)((int)thing_ptr3 + 0x10);
  *object_type_list = piVar3;
  *plVar2 = lVar1;
  *piVar3 = thing_type;
  return;
}



Boolean __regparm3 ListStart(int type,void *ptr1,void *ptr2,void *ptr3)

{
  Boolean BVar1;
  Cardinal L;
  
  DumpList();
  if (type == 0x20) {
    BVar1 = ADD_RAT_TO_LIST((RatTypePtr *)ptr1);
    return BVar1 != '\0';
  }
  if (type < 0x21) {
    if (type == 4) {
      L = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr1);
      BVar1 = ADD_LINE_TO_LIST(L,(LineTypePtr)ptr2);
      return BVar1 != '\0';
    }
    if (type == 8) {
      L = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr1);
      BVar1 = ADD_POLYGON_TO_LIST(L,(PolygonTypePtr)ptr2);
      return BVar1 != '\0';
    }
    if (type == 1) goto LAB_08094bc3;
  }
  else {
    if (type == 0x200) {
      BVar1 = ADD_PAD_TO_LIST((*(uint *)((int)ptr2 + 0x14) >> 7 ^ 1) & 1,(PadTypePtr *)ptr2);
      return BVar1 != '\0';
    }
    if (type == 0x4000) {
      L = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr1);
      BVar1 = ADD_ARC_TO_LIST(L,(ArcTypePtr *)ptr2);
      return BVar1 != '\0';
    }
    if (type == 0x100) {
LAB_08094bc3:
      BVar1 = ADD_PV_TO_LIST((PinTypePtr *)ptr2);
      return BVar1 != '\0';
    }
  }
  return '\0';
}



Boolean LookupPVConnectionsToPVList(void)

{
  int iVar1;
  LocationType LVar2;
  Cardinal CVar3;
  Boolean BVar4;
  int iVar5;
  LocationType *pLVar6;
  PinType *pPVar7;
  int in_GS_OFFSET;
  byte bVar8;
  pv_info info;
  
  CVar3 = PVList.Location;
  bVar8 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (PVList.Location < PVList.Number) {
    do {
      LVar2 = Bloat;
      iVar5 = 0x13;
      pLVar6 = (LocationType *)PVList.Data[PVList.Location];
      pPVar7 = &info.pv;
      while (iVar5 != 0) {
        iVar5 = iVar5 + -1;
        (pPVar7->BoundingBox).X1 = *pLVar6;
        pLVar6 = pLVar6 + (uint)bVar8 * 0x3ffffffe + 1;
        pPVar7 = (PinType *)((int)pPVar7 + (uint)bVar8 * -8 + 4);
      }
      if (0 < LVar2) {
        info.pv.BoundingBox.X1 = info.pv.BoundingBox.X1 - LVar2;
        info.pv.BoundingBox.X2 = info.pv.BoundingBox.X2 + LVar2;
        info.pv.BoundingBox.Y1 = info.pv.BoundingBox.Y1 - LVar2;
        info.pv.BoundingBox.Y2 = info.pv.BoundingBox.Y2 + LVar2;
      }
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) {
LAB_08094dc3:
        BVar4 = '\x01';
        goto LAB_08094dc8;
      }
      r_search(PCB->Data->via_tree,(BoxType *)&info.pv,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               pv_pv_callback,&info);
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) goto LAB_08094dc3;
      r_search(PCB->Data->pin_tree,(BoxType *)&info.pv,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               pv_pv_callback,&info);
      PVList.Location = PVList.Location + 1;
    } while (PVList.Location < PVList.Number);
  }
  BVar4 = '\0';
  PVList.Location = CVar3;
LAB_08094dc8:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean __regparm3 LookupLOConnectionsToPVList(Boolean AndRats)

{
  uint *puVar1;
  int iVar2;
  LocationType LVar3;
  Boolean BVar4;
  int iVar5;
  LocationType *pLVar6;
  PinType *pPVar7;
  int in_GS_OFFSET;
  byte bVar8;
  uint local_100;
  pv_info info;
  
  bVar8 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (PVList.Location < PVList.Number) {
    do {
      LVar3 = Bloat;
      iVar5 = 0x13;
      pLVar6 = (LocationType *)PVList.Data[PVList.Location];
      pPVar7 = &info.pv;
      while (iVar5 != 0) {
        iVar5 = iVar5 + -1;
        (pPVar7->BoundingBox).X1 = *pLVar6;
        pLVar6 = pLVar6 + (uint)bVar8 * 0x3ffffffe + 1;
        pPVar7 = (PinType *)((int)pPVar7 + (uint)bVar8 * -8 + 4);
      }
      if (0 < LVar3) {
        info.pv.BoundingBox.X1 = info.pv.BoundingBox.X1 - LVar3;
        info.pv.BoundingBox.X2 = info.pv.BoundingBox.X2 + LVar3;
        info.pv.BoundingBox.Y1 = info.pv.BoundingBox.Y1 - LVar3;
        info.pv.BoundingBox.Y2 = info.pv.BoundingBox.Y2 + LVar3;
      }
      iVar5 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar5 != 0) {
LAB_08095022:
        BVar4 = '\x01';
        goto LAB_08095027;
      }
      r_search(PCB->Data->pad_tree,(BoxType *)&info.pv,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               LOCtoPVpad_callback,&info);
      if (PCB->Data->LayerN != 0) {
        local_100 = 0;
        do {
          info.layer = local_100;
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 != 0) goto LAB_08095022;
          r_search(*(rtree_t **)(&PCB->Data->field_0x80 + local_100 * 0x5c),(BoxType *)&info.pv,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPVline_callback,&info);
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 != 0) goto LAB_08095022;
          r_search(*(rtree_t **)(&PCB->Data->field_0x8c + local_100 * 0x5c),(BoxType *)&info.pv,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPVarc_callback,&info);
          iVar5 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar5 != 0) goto LAB_08095022;
          r_search(*(rtree_t **)(&PCB->Data->field_0x88 + local_100 * 0x5c),(BoxType *)&info.pv,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPVpoly_callback,&info);
          local_100 = local_100 + 1;
          puVar1 = (uint *)&PCB->Data->LayerN;
        } while (local_100 <= *puVar1 && *puVar1 != local_100);
      }
      if (AndRats != '\0') {
        iVar5 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar5 != 0) goto LAB_08095022;
        r_search(PCB->Data->rat_tree,(BoxType *)&info.pv,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 LOCtoPVrat_callback,&info);
      }
      PVList.Location = PVList.Location + 1;
    } while (PVList.Location < PVList.Number);
  }
  BVar4 = '\0';
LAB_08095027:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean __regparm3 PVTouchesLine(LineTypePtr line)

{
  Boolean BVar1;
  int iVar2;
  lo_info *plVar3;
  int in_GS_OFFSET;
  lo_info info;
  int local_10;
  
  iVar2 = 0x16;
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  plVar3 = &info;
  while (plVar3 = (lo_info *)&plVar3->line, iVar2 != 0) {
    iVar2 = iVar2 + -1;
    ((BoxType *)&plVar3->layer)->X1 = (line->BoundingBox).X1;
    line = (LineTypePtr)&(line->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
    info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
    info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
    info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
  }
  iVar2 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar2 == 0) {
    r_search(PCB->Data->via_tree,(BoxType *)&info.line,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             pv_touch_callback,&info);
    iVar2 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar2 == 0) {
      r_search(PCB->Data->pin_tree,(BoxType *)&info.line,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               pv_touch_callback,&info);
      BVar1 = '\0';
      goto LAB_0809511d;
    }
  }
  BVar1 = '\x01';
LAB_0809511d:
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int LOCtoPad_callback(BoxType *b,void *cl)

{
  int *piVar1;
  Boolean BVar2;
  
  if (((TheFlag & b[1].Y1) == 0) && (*(Cardinal *)cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    piVar1 = *(int **)((int)cl + 4);
    if ((((b[2].Y2 == *piVar1) && (b[3].X1 == piVar1[1])) ||
        ((*piVar1 == b[4].X1 && (b[4].Y1 == piVar1[1])))) &&
       (BVar2 = ADD_PAD_TO_LIST(*(Cardinal *)cl,(PadTypePtr *)b), BVar2 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 0;
}



int PolygonToRat_callback(BoxType *b,void *cl)

{
  int iVar1;
  Boolean BVar2;
  
  if (((b[1].Y1 & TheFlag) == 0) && (b[2].Y2 != 0)) {
    iVar1 = *(int *)(b[2].Y2 + 8);
    if ((**(int **)((int)cl + 4) == *(int *)(iVar1 + 0x2c)) &&
       ((*(int **)((int)cl + 4))[1] == *(int *)(iVar1 + 0x30))) {
      BVar2 = ADD_POLYGON_TO_LIST(*(Cardinal *)cl,(PolygonTypePtr)b);
      if (BVar2 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 8,1);
      }
    }
  }
  return 0;
}



int LOCtoRat_callback(BoxType *b,void *cl)

{
  int *piVar1;
  int iVar2;
  Boolean BVar3;
  
  if ((b[1].Y1 & TheFlag) != 0) {
    return 0;
  }
  piVar1 = *(int **)((int)cl + 4);
  if (b[2].Y2 == *piVar1) {
    if (b[3].X1 == piVar1[1]) goto LAB_08095310;
    iVar2 = b[4].X1;
  }
  else {
    iVar2 = b[4].X1;
  }
  if (*piVar1 != iVar2) {
    return 0;
  }
  if (b[4].Y1 != piVar1[1]) {
    return 0;
  }
LAB_08095310:
  BVar3 = ADD_LINE_TO_LIST(*(Cardinal *)cl,(LineTypePtr)b);
  if (BVar3 == '\0') {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 8,1);
}



int LOCtoLineRat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((((b[1].Y1 & TheFlag) == 0) &&
      (((b[5].Y1 == *(int *)cl &&
        (((b[2].Y2 == *(int *)((int)cl + 0x30) && (b[3].X1 == *(int *)((int)cl + 0x34))) ||
         ((b[2].Y2 == *(int *)((int)cl + 0x44) && (b[3].X1 == *(int *)((int)cl + 0x48))))))) ||
       ((*(int *)cl == b[5].X2 &&
        (((b[4].X1 == *(int *)((int)cl + 0x30) && (b[4].Y1 == *(int *)((int)cl + 0x34))) ||
         ((b[4].X1 == *(int *)((int)cl + 0x44) && (b[4].Y1 == *(int *)((int)cl + 0x48))))))))))) &&
     (BVar1 = ADD_RAT_TO_LIST((RatTypePtr *)b), BVar1 != '\0')) {
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x1a0,1);
  }
  return 0;
}



int LOCtoPolyRat_callback(BoxType *b,void *cl)

{
  int iVar1;
  Boolean BVar2;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    iVar1 = *(int *)(*(int *)((int)cl + 0x134) + 8);
    if (((((b[2].Y2 == *(int *)(iVar1 + 0x2c)) && (b[3].X1 == *(int *)(iVar1 + 0x30))) &&
         (b[5].Y1 == *(int *)cl)) ||
        (((*(int *)(iVar1 + 0x2c) == b[4].X1 && (b[4].Y1 == *(int *)(iVar1 + 0x30))) &&
         (b[5].X2 == *(int *)cl)))) && (BVar2 = ADD_RAT_TO_LIST((RatTypePtr *)b), BVar2 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



int LOCtoPadRat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((((b[1].Y1 & TheFlag) == 0) &&
      (((b[5].Y1 == *(int *)cl &&
        (((b[2].Y2 == *(int *)((int)cl + 0x88) && (b[3].X1 == *(int *)((int)cl + 0x8c))) ||
         ((b[2].Y2 == *(int *)((int)cl + 0x9c) && (b[3].X1 == *(int *)((int)cl + 0xa0))))))) ||
       ((*(int *)cl == b[5].X2 &&
        (((b[4].X1 == *(int *)((int)cl + 0x88) && (b[4].Y1 == *(int *)((int)cl + 0x8c))) ||
         ((b[4].X1 == *(int *)((int)cl + 0x9c) && (b[4].Y1 == *(int *)((int)cl + 0xa0))))))))))) &&
     (BVar1 = ADD_RAT_TO_LIST((RatTypePtr *)b), BVar1 != '\0')) {
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x1a0,1);
  }
  return 0;
}



int pv_pv_callback(BoxType *b,void *cl)

{
  float fVar1;
  float Radius;
  Boolean BVar2;
  uint uVar3;
  float local_2c;
  
  if ((b[1].Y1 & TheFlag) != 0) {
    return 0;
  }
  Radius = (float)*(int *)((int)cl + 0x28) * 0.50000000 + fBloat;
  if (Radius <= 0.00000000) {
    Radius = 0.00000000;
  }
  fVar1 = (float)b[2].Y1 * 0.50000000 + fBloat;
  local_2c = 0.00000000;
  if (fVar1 <= 0.00000000) {
    fVar1 = local_2c;
  }
  local_2c = fVar1;
  BVar2 = IsPointOnPin((float)*(int *)((int)cl + 0x38),(float)*(int *)((int)cl + 0x3c),Radius,
                       (PinTypePtr *)b);
  if ((BVar2 == '\0') &&
     (BVar2 = IsPointOnPin((float)b[3].Y1,(float)b[3].X2,local_2c,(PinTypePtr *)((int)cl + 4)),
     BVar2 == '\0')) {
    if ((*(byte *)((int)cl + 0x19) & 1) == 0) {
      return 0;
    }
    uVar3 = b[1].Y1;
    if ((uVar3 & 0x100) == 0) {
      return 0;
    }
    fVar1 = (float)b[2].Y1 * 0.50000000;
    if ((int)ROUND(fVar1 + (float)b[3].Y1) < (int)ROUND((float)*(int *)((int)cl + 0x38) - Radius)) {
      return 0;
    }
    if ((int)ROUND((float)*(int *)((int)cl + 0x38) + Radius) < (int)ROUND((float)b[3].Y1 - fVar1)) {
      return 0;
    }
    if ((int)ROUND(fVar1 + (float)b[3].X2) < (int)ROUND((float)*(int *)((int)cl + 0x3c) - Radius)) {
      return 0;
    }
    if ((int)ROUND(Radius + (float)*(int *)((int)cl + 0x3c)) < (int)ROUND((float)b[3].X2 - fVar1)) {
      return 0;
    }
  }
  else {
    uVar3 = b[1].Y1;
  }
  if ((uVar3 & 8) != 0) {
    b[1].Y1 = uVar3 | 0x200;
    Settings.RatWarn = '\x01';
    if (b[4].Y1 == 0) {
      Message("WARNING: Hole too close to via.\n");
    }
    else {
      Message("WARNING: Hole too close to pin.\n");
    }
  }
  BVar2 = ADD_PV_TO_LIST((PinTypePtr *)b);
  if (BVar2 == '\0') {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0x50,1);
}



int LOCtoPVrat_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = IsPointOnLineEnd(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c),
                             (RatTypePtr *)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_RAT_TO_LIST((RatTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x50,1);
      }
    }
  }
  return 0;
}



undefined4 pv_rat_callback(PinTypePtr *param_1,int param_2)

{
  Boolean BVar1;
  
  if (((param_1->Flags).f & TheFlag) == 0) {
    BVar1 = IsPointOnLineEnd(param_1->X,param_1->Y,(RatTypePtr *)(param_2 + 0x144));
    if (BVar1 != '\0') {
      ADD_PV_TO_LIST(param_1);
      return 0;
    }
  }
  return 0;
}



int LOCtoPVpoly_callback(BoxType *b,void *cl)

{
  float fVar1;
  char cVar2;
  Boolean BVar3;
  POLYAREA *a;
  int iVar4;
  
  if (((TheFlag & b[1].Y1) == 0) &&
     ((((0xf << (sbyte)((*(uint *)cl & 1) << 2) &
        (uint)*(byte *)((int)cl + (*(uint *)cl >> 1) + 0x1c)) != 0 || ((b[1].Y1 & 0x10U) == 0)) ||
      (*(int *)((int)cl + 0x2c) == 0)))) {
    iVar4 = *(int *)((int)cl + 0x28);
    fVar1 = (float)iVar4 * 0.50000000 + fBloat;
    if (fVar1 <= 0.00000000) {
      fVar1 = 0.00000000;
    }
    if ((*(uint *)((int)cl + 0x18) & 0x100) == 0) {
      if ((*(uint *)((int)cl + 0x18) & 0x800) == 0) {
        cVar2 = IsPointInPolygon(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c)
                                 ,(int)ROUND(fVar1),(PolygonTypePtr)b);
      }
      else {
        a = OctagonPoly(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c),
                        iVar4 / 2);
        cVar2 = isects(a,(PolygonTypePtr)b,'\x01');
      }
    }
    else {
      iVar4 = (iVar4 + Bloat + 1) / 2;
      cVar2 = IsRectangleInPolygon
                        (-iVar4 + *(int *)((int)cl + 0x38),-iVar4 + *(int *)((int)cl + 0x3c),
                         iVar4 + *(int *)((int)cl + 0x38),iVar4 + *(int *)((int)cl + 0x3c),
                         (PolygonTypePtr)b);
    }
    if ((cVar2 != '\0') &&
       (BVar3 = ADD_POLYGON_TO_LIST(*(Cardinal *)cl,(PolygonTypePtr)b), BVar3 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x50,1);
    }
  }
  return 0;
}



int pv_poly_callback(BoxType *b,void *cl)

{
  uint uVar1;
  char cVar2;
  Boolean BVar3;
  POLYAREA *a;
  int iVar4;
  
  uVar1 = b[1].Y1;
  if (((TheFlag & uVar1) == 0) &&
     ((((0xf << (sbyte)((*(uint *)cl & 1) << 2) &
        (uint)*(byte *)((int)&b[1].X2 + (*(uint *)cl >> 1))) != 0 ||
       ((*(byte *)((int)cl + 0x11c) & 0x10) == 0)) || (b[2].X2 == 0)))) {
    if ((uVar1 & 0x100) == 0) {
      if ((uVar1 & 0x800) == 0) {
        cVar2 = IsPointInPolygon(b[3].Y1,b[3].X2,(int)ROUND((float)b[2].Y1 * 0.50000000 + fBloat),
                                 (PolygonTypePtr)((int)cl + 0x108));
      }
      else {
        a = OctagonPoly(b[3].Y1,b[3].X2,b[2].Y1 / 2);
        cVar2 = isects(a,(PolygonTypePtr)((int)cl + 0x108),'\x01');
      }
    }
    else {
      iVar4 = (b[2].Y1 + Bloat + 1) / 2;
      cVar2 = IsRectangleInPolygon
                        (-iVar4 + b[3].Y1,-iVar4 + b[3].X2,iVar4 + b[3].Y1,iVar4 + b[3].X2,
                         (PolygonTypePtr)((int)cl + 0x108));
    }
    if ((cVar2 != '\0') && (BVar3 = ADD_PV_TO_LIST((PinTypePtr *)b), BVar3 != '\0')) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



int LOCtoPVarc_callback(BoxType *b,void *cl)

{
  float fVar1;
  float Radius;
  char cVar2;
  Boolean BVar3;
  uint uVar4;
  uint uVar5;
  
  uVar4 = TheFlag & b[1].Y1;
  if (uVar4 == 0) {
    if ((*(byte *)((int)cl + 0x19) & 1) == 0) {
      fVar1 = (float)*(int *)((int)cl + 0x28) * 0.50000000 + fBloat;
      Radius = 0.00000000;
      if (0.00000000 < fVar1) {
        Radius = fVar1;
      }
      cVar2 = IsPointOnArc((float)*(int *)((int)cl + 0x38),(float)*(int *)((int)cl + 0x3c),Radius,
                           (ArcTypePtr *)b);
    }
    else {
      uVar5 = (*(int *)((int)cl + 0x28) + 1) / 2 + Bloat;
      if ((int)uVar5 < 0) {
        uVar5 = uVar4;
      }
      cVar2 = IsArcInRectangle(*(int *)((int)cl + 0x38) - uVar5,*(int *)((int)cl + 0x3c) - uVar5,
                               uVar5 + *(int *)((int)cl + 0x38),uVar5 + *(int *)((int)cl + 0x3c),
                               (ArcTypePtr *)b);
    }
    if ((cVar2 != '\0') && (BVar3 = ADD_ARC_TO_LIST(*(Cardinal *)cl,(ArcTypePtr *)b), BVar3 != '\0')
       ) {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x50,1);
    }
  }
  return 0;
}



int pv_arc_callback(BoxType *b,void *cl)

{
  float fVar1;
  float Radius;
  char cVar2;
  Boolean BVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = b[1].Y1 & TheFlag;
  if (uVar5 == 0) {
    if ((b[1].Y1 & 0x100U) == 0) {
      fVar1 = (float)b[2].Y1 * 0.50000000 + fBloat;
      Radius = 0.00000000;
      if (0.00000000 < fVar1) {
        Radius = fVar1;
      }
      cVar2 = IsPointOnArc((float)b[3].Y1,(float)b[3].X2,Radius,(ArcTypePtr *)((int)cl + 0xc4));
    }
    else {
      uVar4 = (b[2].Y1 + 1) / 2 + Bloat;
      if ((int)uVar4 < 0) {
        uVar4 = uVar5;
      }
      cVar2 = IsArcInRectangle(b[3].Y1 - uVar4,b[3].X2 - uVar4,uVar4 + b[3].Y1,uVar4 + b[3].X2,
                               (ArcTypePtr *)((int)cl + 0xc4));
    }
    if (cVar2 != '\0') {
      if ((b[1].Y1 & 8U) != 0) {
        b[1].Y1 = b[1].Y1 | 0x200;
        Settings.RatWarn = '\x01';
        Message("WARNING: Hole touches arc.\n");
      }
      BVar3 = ADD_PV_TO_LIST((PinTypePtr *)b);
      if (BVar3 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int LOCtoPVpad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  uint uVar2;
  uint Radius;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_retaddr;
  undefined in_stack_0000000c [76];
  
  uVar2 = TheFlag & b[1].Y1;
  if (uVar2 == 0) {
    Radius = *(int *)((int)cl + 0x28) / 2 + Bloat;
    if ((int)Radius < 0) {
      Radius = uVar2;
    }
    BVar1 = IsPointInPad(*(LocationType *)((int)cl + 0x38),*(LocationType *)((int)cl + 0x3c),Radius,
                         (PadTypePtr)
                         CONCAT8816(CONCAT7612(in_stack_0000000c,
                                               CONCAT48(cl,CONCAT44(b,unaff_retaddr))),
                                    CONCAT412(unaff_EBP,CONCAT48(unaff_ESI,CONCAT44(unaff_EBX,b)))))
    ;
    if (BVar1 != '\0') {
      BVar1 = ADD_PAD_TO_LIST(((uint)b[1].Y1 >> 7 ^ 1) & 1,(PadTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x50,1);
      }
    }
  }
  return 0;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int pv_pad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  uint uVar2;
  uint Radius;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_retaddr;
  undefined in_stack_0000000c [76];
  
  uVar2 = TheFlag & b[1].Y1;
  if (uVar2 == 0) {
    Radius = b[2].Y1 / 2 + Bloat;
    if ((int)Radius < 0) {
      Radius = uVar2;
    }
    BVar1 = IsPointInPad(b[3].Y1,b[3].X2,Radius,
                         (PadTypePtr)
                         CONCAT8816(CONCAT7612(in_stack_0000000c,
                                               CONCAT48(cl,CONCAT44(b,unaff_retaddr))),
                                    CONCAT412(unaff_EBP,
                                              CONCAT48(unaff_ESI,CONCAT44(unaff_EBX,(int)cl + 0x5c))
                                             )));
    if (BVar1 != '\0') {
      if ((b[1].Y1 & 8U) != 0) {
        b[1].Y1 = b[1].Y1 | 0x200;
        Settings.RatWarn = '\x01';
        Message("WARNING: Hole too close to pad.\n");
      }
      BVar1 = ADD_PV_TO_LIST((PinTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x0809611d)
// WARNING: Removing unreachable block (ram,0x08096123)
// WARNING: Removing unreachable block (ram,0x08096128)

int LOCtoArcArc_callback(BoxType *b,void *cl)

{
  ArcTypePtr *Arc;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  float Radius;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  Boolean BVar13;
  int iVar14;
  BoxTypePtr pBVar15;
  int iVar16;
  int iVar17;
  
  iVar14 = b[2].Y1;
  if (iVar14 == 0) {
    return 0;
  }
  if ((b[1].Y1 & TheFlag) != 0) {
    return 0;
  }
  iVar17 = b[3].X2 - *(int *)((int)cl + 0xfc);
  iVar16 = b[3].Y1 - *(int *)((int)cl + 0xf8);
  fVar7 = (float)(iVar16 * iVar16 + iVar17 * iVar17);
  Radius = (float)*(int *)((int)cl + 0xe8) * 0.50000000 + fBloat;
  if (Radius <= 0.00000000) {
    Radius = 0.00000000;
  }
  fVar9 = (float)iVar14 * 0.50000000;
  if (fVar7 == 0.00000000) {
    fVar7 = (float)*(int *)((int)cl + 0xf0) - Radius;
    fVar6 = (float)b[2].Y2;
    if ((fVar7 < fVar6 - fVar9) || (fVar9 + fVar6 < fVar7)) {
      Radius = Radius + (float)*(int *)((int)cl + 0xf0);
      if (Radius < fVar6 - fVar9) {
        return 0;
      }
      if (fVar9 + fVar6 < Radius) {
        return 0;
      }
    }
    iVar14 = iVar14 + Bloat;
    if (iVar14 < 0) {
      iVar14 = 0;
    }
    if ((((iVar14 + b->X1 < *(int *)((int)cl + 0xc4)) || (*(int *)((int)cl + 0xcc) < b->X1)) ||
        (iVar14 + b->Y1 < *(int *)((int)cl + 200))) || (*(int *)((int)cl + 0xd0) < b->Y1)) {
      if (iVar14 + b->X2 < *(int *)((int)cl + 0xc4)) {
        return 0;
      }
      if (*(int *)((int)cl + 0xcc) < b->X2) {
        return 0;
      }
      if (iVar14 + b->Y2 < *(int *)((int)cl + 200)) {
        return 0;
      }
      if (*(int *)((int)cl + 0xd0) < b->Y2) {
        return 0;
      }
    }
  }
  else {
    fVar6 = (float)*(int *)((int)cl + 0xf0) + Radius;
    fVar6 = fVar6 * fVar6;
    fVar8 = (float)b[2].Y2 + fVar9;
    fVar8 = (((fVar6 - fVar8 * fVar8) + fVar7) * 0.50000000) / fVar7;
    fVar7 = (fVar6 / fVar7 - fVar8 * fVar8) + 0.00001000;
    if (fVar7 < 0.00000000) {
      return 0;
    }
    fVar7 = SQRT(fVar7);
    fVar11 = fVar8 * (float)iVar16 + (float)*(int *)((int)cl + 0xf8);
    fVar6 = fVar8 * (float)iVar17 + (float)*(int *)((int)cl + 0xfc);
    fVar12 = (float)iVar16 * fVar7;
    fVar7 = fVar7 * (float)iVar17;
    fVar8 = fVar11 + fVar7;
    if (((((fVar8 < (float)*(int *)((int)cl + 0xc4)) || ((float)*(int *)((int)cl + 0xcc) < fVar8))
         || (fVar10 = fVar6 - fVar12, fVar10 < (float)*(int *)((int)cl + 200))) ||
        ((((float)*(int *)((int)cl + 0xd0) < fVar10 || (fVar8 < (float)b->X1)) ||
         (((float)b->X2 < fVar8 || ((fVar10 < (float)b->Y1 || ((float)b->Y2 < fVar10)))))))) &&
       (((fVar11 = fVar11 - fVar7, fVar11 < (float)*(int *)((int)cl + 0xc4) ||
         ((((float)*(int *)((int)cl + 0xcc) < fVar11 ||
           (fVar6 = fVar6 + fVar12, fVar6 < (float)*(int *)((int)cl + 200))) ||
          ((float)*(int *)((int)cl + 0xd0) < fVar6)))) ||
        (((fVar11 < (float)b->X1 || ((float)b->X2 < fVar11)) ||
         ((fVar6 < (float)b->Y1 || ((float)b->Y2 < fVar6)))))))) {
      Arc = (ArcTypePtr *)((int)cl + 0xc4);
      pBVar15 = GetArcEnds(Arc);
      iVar14 = pBVar15->X2;
      iVar16 = pBVar15->Y2;
      iVar17 = pBVar15->X1;
      iVar1 = pBVar15->Y1;
      pBVar15 = GetArcEnds((ArcTypePtr *)b);
      iVar2 = pBVar15->X2;
      iVar3 = pBVar15->Y2;
      iVar4 = pBVar15->X1;
      iVar5 = pBVar15->Y1;
      BVar13 = IsPointOnArc((float)iVar17,(float)iVar1,Radius,(ArcTypePtr *)b);
      if ((BVar13 == '\0') &&
         (BVar13 = IsPointOnArc((float)iVar14,(float)iVar16,Radius,(ArcTypePtr *)b), BVar13 == '\0')
         ) {
        Radius = fBloat + fVar9;
        if (fBloat + fVar9 <= 0.00000000) {
          Radius = 0.00000000;
        }
        BVar13 = IsPointOnArc((float)iVar4,(float)iVar5,Radius,Arc);
        if (BVar13 == '\0') {
          Radius = fVar9 + fBloat;
          if (fVar9 + fBloat <= 0.00000000) {
            Radius = 0.00000000;
          }
          BVar13 = IsPointOnArc((float)iVar2,(float)iVar3,Radius,Arc);
          if (BVar13 == '\0') {
            return 0;
          }
        }
      }
    }
  }
  BVar13 = ADD_ARC_TO_LIST(*(Cardinal *)cl,(ArcTypePtr *)b);
  if (BVar13 == '\0') {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0x1a0,1);
}



// WARNING: Removing unreachable block (ram,0x080965ba)
// WARNING: Removing unreachable block (ram,0x080965c0)
// WARNING: Removing unreachable block (ram,0x080965c8)

Boolean LineArcIntersect(LineTypePtr Line,ArcTypePtr *Arc)

{
  int iVar1;
  float Radius;
  float Radius_00;
  Boolean BVar2;
  int iVar3;
  BoxTypePtr pBVar4;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined2 in_FPUControlWord;
  float local_6c;
  float local_20;
  undefined in_stack_ffffff98 [12];
  float local_5c;
  float fVar5;
  undefined in_stack_ffffffa8 [12];
  float fVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined in_stack_ffffffbc [12];
  float local_38;
  float local_34;
  float local_30;
  float local_2c;
  int local_28;
  float Radius_01;
  undefined in_stack_ffffffe4 [12];
  
  local_28 = (Line->Point1).X;
  iVar1 = (Line->Point1).Y;
  local_30 = (float)((Line->Point2).X - local_28);
  iVar3 = (Line->Point2).Y - iVar1;
  local_5c = (float)iVar3;
  local_38 = (float)(local_28 - Arc->X);
  local_34 = (float)(iVar1 - Arc->Y);
  local_2c = local_5c * local_5c + local_30 * local_30;
  fVar6 = (float)(Arc->Thickness + Line->Thickness) * 0.50000000 + fBloat;
  if (fVar6 <= 0.00000000) {
    fVar6 = 0.00000000;
  }
  fVar6 = (float)Arc->Width + fVar6;
  local_5c = local_30 * local_34 - local_38 * local_5c;
  local_5c = fVar6 * fVar6 * local_2c - local_5c * local_5c;
  if (0.00000000 <= local_5c) {
    local_20 = (float)Line->Thickness * 0.50000000 + fBloat;
    Radius_01 = local_20;
    if (local_20 <= 0.00000000) {
      local_20 = fVar6;
      Radius_01 = 0.00000000;
    }
    fVar6 = (float)iVar3;
    BVar2 = IsPointOnArc((float)local_28,(float)iVar1,Radius_01,Arc);
    if (BVar2 != '\0') {
      return '\x01';
    }
    Radius_01 = (float)Line->Thickness * 0.50000000 + fBloat;
    Radius = Radius_01;
    if (Radius_01 <= 0.00000000) {
      Radius_01 = local_20;
      Radius = 0.00000000;
    }
    BVar2 = IsPointOnArc((float)(Line->Point2).X,(float)(Line->Point2).Y,Radius,Arc);
    if (BVar2 != '\0') {
      return '\x01';
    }
    if (local_2c != 0.00000000) {
      local_20 = SQRT(local_5c);
      fVar5 = -(local_34 * fVar6 + local_30 * local_38);
      Radius = (local_20 + fVar5) / local_2c;
      Radius_00 = 0.00000000;
      if ((0.00000000 <= Radius) && (Radius <= 1.00000000)) {
        local_5c = (float)Line->Thickness * 0.50000000 + fBloat;
        if (0.00000000 < local_5c) {
          Radius_01 = local_5c;
          Radius_00 = local_5c;
        }
        BVar2 = IsPointOnArc(Radius * local_30 + (float)(Line->Point1).X,
                             Radius * fVar6 + (float)(Line->Point1).Y,Radius_00,Arc);
        local_6c = local_20;
        local_5c = fVar5;
        if (BVar2 != '\0') {
          return '\x01';
        }
      }
      local_20 = (fVar5 - local_20) / local_2c;
      Radius = 0.00000000;
      if ((0.00000000 <= local_20) && (local_20 <= 1.00000000)) {
        Radius_00 = (float)Line->Thickness * 0.50000000 + fBloat;
        if (0.00000000 < Radius_00) {
          Radius_01 = Radius_00;
          Radius = Radius_00;
        }
        BVar2 = IsPointOnArc(local_20 * local_30 + (float)(Line->Point1).X,
                             fVar6 * local_20 + (float)(Line->Point1).Y,Radius,Arc);
        if (BVar2 != '\0') {
          return '\x01';
        }
      }
      pBVar4 = GetArcEnds(Arc);
      uVar7 = 0;
      uVar8 = 0x3fe00000;
      BVar2 = IsPointInPad(pBVar4->X1,pBVar4->Y1,
                           (int)ROUND((float)Arc->Thickness * 0.50000000 + fBloat),
                           (PadTypePtr)
                           CONCAT4100(unaff_ESI,
                                      CONCAT496(unaff_EBX,
                                                CONCAT1284(in_stack_ffffffe4,
                                                           CONCAT480(Radius_01,
                                                                     CONCAT278(in_FPUControlWord,
                                                                               CONCAT276(CONCAT11(
                                                  0xc,(char)in_FPUControlWord),
                                                  CONCAT472(local_28,CONCAT468(local_2c,CONCAT464(
                                                  local_30,CONCAT460(local_34,CONCAT456(local_38,
                                                  CONCAT1244(in_stack_ffffffbc,
                                                             CONCAT440(0x3fe00000,
                                                                       ZEXT3640(CONCAT1224(
                                                  in_stack_ffffffa8,
                                                  CONCAT420(local_5c,CONCAT128(in_stack_ffffff98,
                                                                               CONCAT44(local_6c,
                                                  Line)))))))))))))))))));
      if (BVar2 == '\0') {
        BVar2 = IsPointInPad(pBVar4->X2,pBVar4->Y2,
                             (int)ROUND((float)Arc->Thickness * (float)(double)CONCAT44(uVar8,uVar7)
                                        + fBloat),
                             (PadTypePtr)
                             CONCAT4100(unaff_ESI,
                                        CONCAT496(unaff_EBX,
                                                  CONCAT1284(in_stack_ffffffe4,
                                                             CONCAT480(Radius_01,
                                                                       CONCAT278(in_FPUControlWord,
                                                                                 CONCAT276(CONCAT11(
                                                  0xc,(char)in_FPUControlWord),
                                                  CONCAT472(local_28,CONCAT468(local_2c,CONCAT464(
                                                  local_30,CONCAT460(local_34,CONCAT456(local_38,
                                                  CONCAT1244(in_stack_ffffffbc,
                                                             CONCAT440(uVar8,CONCAT436(uVar7,
                                                  CONCAT1224(in_stack_ffffffa8,
                                                             CONCAT420(local_5c,CONCAT128(
                                                  in_stack_ffffff98,CONCAT44(local_6c,Line))))))))))
                                                  )))))))));
        return BVar2 != '\0';
      }
      return '\x01';
    }
  }
  return '\0';
}



int LOCtoLineArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = LineArcIntersect((LineTypePtr)((int)cl + 4),(ArcTypePtr *)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_ARC_TO_LIST(*(Cardinal *)cl,(ArcTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOCtoArcLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineArcIntersect((LineTypePtr)b,(ArcTypePtr *)((int)cl + 0xc4));
    if (BVar1 != '\0') {
      BVar1 = ADD_LINE_TO_LIST(*(Cardinal *)cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOT_Arccallback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = LineArcIntersect((LineTypePtr)((int)cl + 4),(ArcTypePtr *)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



Boolean ArcPadIntersect(ArcTypePtr *Arc,PadTypePtr *Pad)

{
  Boolean BVar1;
  
  BVar1 = LineArcIntersect((LineTypePtr)Pad,Arc);
  return BVar1;
}



int LOCtoArcPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && (*(uint *)cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineArcIntersect((LineTypePtr)b,(ArcTypePtr *)((int)cl + 0xc4));
    if (BVar1 != '\0') {
      BVar1 = ADD_PAD_TO_LIST(*(Cardinal *)cl,(PadTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOCtoPadArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[2].Y1 != 0) && ((b[1].Y1 & TheFlag) == 0)) {
    BVar1 = LineArcIntersect((LineTypePtr)((int)cl + 0x5c),(ArcTypePtr *)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_ARC_TO_LIST(*(Cardinal *)cl,(ArcTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



void append_drc_dialog_message(char *fmt,...)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  uint *puVar5;
  int iVar6;
  bool bVar7;
  
  puVar5 = (uint *)drc_dialog_message;
  do {
    puVar4 = puVar5;
    uVar2 = *puVar4 + 0xfefefeff & ~*puVar4;
    uVar3 = uVar2 & 0x80808080;
    puVar5 = puVar4 + 1;
  } while (uVar3 == 0);
  bVar7 = (uVar2 & 0x8080) == 0;
  bVar1 = (byte)uVar3;
  if (bVar7) {
    bVar1 = (byte)(uVar3 >> 0x10);
  }
  if (bVar7) {
    puVar5 = (uint *)((int)puVar4 + 6);
  }
  iVar6 = (int)puVar5 + (-3 - (uint)CARRY1(bVar1,bVar1));
  __vsnprintf_chk(iVar6,0x120 - (iVar6 + -0x816c180),1,0xffffffff,fmt,&stack0x00000008);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int throw_drc_dialog(void)

{
  int iVar1;
  
  if (gui->drc_gui != (HID_DRC_GUI *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08096aee. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*gui->drc_gui->throw_drc_dialog)();
    return iVar1;
  }
  append_drc_dialog_message("Press Next to continue DRC checking");
  iVar1 = (*gui->confirm_dialog)(drc_dialog_message,0x8152329,&DAT_08147eea);
  drc_dialog_message[0] = '\0';
  if (gui->drc_gui != (HID_DRC_GUI *)0x0) {
    (*gui->drc_gui->reset_drc_dialog_message)();
  }
  return iVar1;
}



void __regparm3 append_drc_violation(DrcViolationType *violation)

{
  float fVar1;
  float fVar2;
  undefined4 uVar3;
  int Layer;
  undefined4 uVar4;
  LocationType local_14;
  LocationType local_10 [2];
  
  if (gui->drc_gui == (HID_DRC_GUI *)0x0) {
    append_drc_dialog_message("%s\n",violation->title);
    if (Settings.grid_units_mm == '\0') {
      uVar4 = 2;
      uVar3 = 2;
      fVar2 = (float)violation->y / 100.00000000;
      fVar1 = (float)violation->x / 100.00000000;
    }
    else {
      uVar4 = 4;
      uVar3 = 4;
      fVar2 = ((float)violation->y / 100000.00000000) * 25.39999962;
      fVar1 = (100000.00000000 / (float)violation->x) * 25.39999962;
    }
    append_drc_dialog_message("near (%.*f, %.*f)\n",uVar3,(double)fVar1,uVar4,(double)fVar2);
    LocateError(local_10,&local_14);
    if (((thing_type == 8) || (thing_type == 0x4000)) || (thing_type == 4)) {
      Layer = GetLayerNumber(PCB->Data,(LayerTypePtr)thing_ptr1);
      ChangeGroupVisibility(Layer,'\x01','\x01');
    }
    CenterDisplay(local_10[0],local_14,'\0');
  }
  else {
    (*gui->drc_gui->append_drc_violation)(violation);
  }
  if ((gui->drc_gui == (HID_DRC_GUI *)0x0) || (gui->drc_gui->log_drc_violations != 0)) {
    Message("WARNING!  Design Rule error - %s\n",violation->title);
    if (Settings.grid_units_mm == '\0') {
      uVar4 = 2;
      uVar3 = 2;
      fVar1 = (float)violation->y / 100.00000000;
      fVar2 = (float)violation->x / 100.00000000;
    }
    else {
      uVar4 = 4;
      uVar3 = 4;
      fVar1 = ((float)violation->y / 100000.00000000) * 25.39999962;
      fVar2 = (100000.00000000 / (float)violation->x) * 25.39999962;
    }
    Message("near location (%.*f, %.*f)\n",uVar3,(double)fVar2,uVar4,(double)fVar1);
  }
  return;
}



void ResetFoundLinesAndPolygons(Boolean AndDraw)

{
  uint *puVar1;
  uint uVar2;
  bool bVar3;
  PCBTypePtr pPVar4;
  DataTypePtr *pDVar5;
  LayerTypePtr Layer;
  RatTypePtr *Line;
  int iVar6;
  int iVar7;
  undefined *puVar8;
  LineTypePtr Line_00;
  ArcTypePtr *Arc;
  PolygonTypePtr Polygon;
  uint local_24;
  
  bVar3 = false;
  pDVar5 = PCB->Data;
  iVar6 = pDVar5->RatN - 1;
  pPVar4 = PCB;
  if (iVar6 != -1) {
    iVar7 = pDVar5->RatN * 0x5c;
    while( true ) {
      Line = (RatTypePtr *)((int)&pDVar5->Rat[-1].BoundingBox.X1 + iVar7);
      uVar2 = (Line->Flags).f;
      if ((TheFlag & uVar2) != 0) {
        if (AndDraw == '\0') {
          (Line->Flags).f = ~TheFlag & uVar2;
          bVar3 = true;
        }
        else {
          AddObjectToFlagUndoList(0x20,Line,Line,Line);
          (Line->Flags).f = (Line->Flags).f & ~TheFlag;
          DrawRat(Line,0);
          bVar3 = true;
          pPVar4 = PCB;
        }
      }
      if (iVar6 == 0) break;
      iVar6 = iVar6 + -1;
      pDVar5 = pPVar4->Data;
      iVar7 = iVar7 + -0x5c;
    }
    pDVar5 = pPVar4->Data;
  }
  Layer = (LayerTypePtr)&pDVar5->field_0x4c;
  if (pDVar5->LayerN != 0) {
    local_24 = 0;
    do {
      iVar6 = Layer->LineN - 1;
      if (iVar6 != -1) {
        iVar7 = Layer->LineN * 0x58 + -0x58;
        do {
          while( true ) {
            Line_00 = (LineTypePtr)((int)&(Layer->Line->BoundingBox).X1 + iVar7);
            uVar2 = (Line_00->Flags).f;
            if ((TheFlag & uVar2) != 0) break;
LAB_08096e13:
            iVar6 = iVar6 + -1;
            iVar7 = iVar7 + -0x58;
            pPVar4 = PCB;
            if (iVar6 == -1) goto LAB_08096e8d;
          }
          if (AndDraw == '\0') {
            (Line_00->Flags).f = ~TheFlag & uVar2;
            bVar3 = true;
            goto LAB_08096e13;
          }
          iVar6 = iVar6 + -1;
          iVar7 = iVar7 + -0x58;
          AddObjectToFlagUndoList(4,Layer,Line_00,Line_00);
          (Line_00->Flags).f = (Line_00->Flags).f & ~TheFlag;
          DrawLine(Layer,Line_00,0);
          bVar3 = true;
          pPVar4 = PCB;
        } while (iVar6 != -1);
      }
LAB_08096e8d:
      local_24 = local_24 + 1;
      uVar2 = pPVar4->Data->LayerN;
      if (uVar2 <= local_24) goto LAB_08096eb9;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_08096ea7;
LAB_08096eb9:
  Layer = (LayerTypePtr)&pPVar4->Data->field_0x4c;
  if (uVar2 != 0) {
    local_24 = 0;
    do {
      iVar6 = Layer->ArcN - 1;
      if (iVar6 != -1) {
        iVar7 = Layer->ArcN * 0x44 + -0x44;
        do {
          while( true ) {
            Arc = (ArcTypePtr *)((int)&(Layer->Arc->BoundingBox).X1 + iVar7);
            uVar2 = (Arc->Flags).f;
            if ((TheFlag & uVar2) != 0) break;
LAB_08096ef3:
            iVar6 = iVar6 + -1;
            iVar7 = iVar7 + -0x44;
            pPVar4 = PCB;
            if (iVar6 == -1) goto LAB_08096f6d;
          }
          if (AndDraw == '\0') {
            (Arc->Flags).f = ~TheFlag & uVar2;
            bVar3 = true;
            goto LAB_08096ef3;
          }
          iVar6 = iVar6 + -1;
          iVar7 = iVar7 + -0x44;
          AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
          (Arc->Flags).f = (Arc->Flags).f & ~TheFlag;
          DrawArc(Layer,Arc,0);
          bVar3 = true;
          pPVar4 = PCB;
        } while (iVar6 != -1);
      }
LAB_08096f6d:
      local_24 = local_24 + 1;
      uVar2 = pPVar4->Data->LayerN;
      if (uVar2 <= local_24) goto LAB_08096f87;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_08096ea7;
LAB_08096f87:
  Layer = (LayerTypePtr)&pPVar4->Data->field_0x4c;
  if (uVar2 != 0) {
    local_24 = 0;
    do {
      iVar6 = Layer->PolygonN - 1;
      if (iVar6 != -1) {
        puVar8 = &DAT_ffffffc4 + Layer->PolygonN * 0x3c;
        do {
          while( true ) {
            Polygon = (PolygonTypePtr)(puVar8 + (int)&(Layer->Polygon->BoundingBox).X1);
            uVar2 = (Polygon->Flags).f;
            if ((TheFlag & uVar2) != 0) break;
LAB_08096fc3:
            iVar6 = iVar6 + -1;
            puVar8 = &DAT_ffffffc4 + (int)puVar8;
            pPVar4 = PCB;
            if (iVar6 == -1) goto LAB_0809703d;
          }
          if (AndDraw == '\0') {
            (Polygon->Flags).f = ~TheFlag & uVar2;
            bVar3 = true;
            goto LAB_08096fc3;
          }
          iVar6 = iVar6 + -1;
          puVar8 = &DAT_ffffffc4 + (int)puVar8;
          AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
          (Polygon->Flags).f = (Polygon->Flags).f & ~TheFlag;
          DrawPolygon(Layer,Polygon,0);
          bVar3 = true;
          pPVar4 = PCB;
        } while (iVar6 != -1);
      }
LAB_0809703d:
      local_24 = local_24 + 1;
      puVar1 = (uint *)&pPVar4->Data->LayerN;
      if (*puVar1 < local_24 || *puVar1 == local_24) break;
      Layer = Layer + 1;
    } while( true );
  }
LAB_08096ea7:
  if ((bVar3) && (SetChangedFlag('\x01'), AndDraw != '\0')) {
    IncrementUndoSerialNumber();
    Draw();
    return;
  }
  return;
}



void ResetFoundPinsViasAndPads(Boolean AndDraw)

{
  uint uVar1;
  bool bVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  uint uVar5;
  DataTypePtr *pDVar6;
  uint uVar7;
  PadTypePtr *Pad;
  PinTypePtr *Via;
  uint uVar8;
  void *Ptr1;
  int local_2c;
  int local_28;
  
  bVar2 = false;
  pDVar6 = PCB->Data;
  pPVar4 = PCB;
  if (pDVar6->ViaN != 0) {
    uVar7 = 0;
    uVar5 = pDVar6->ViaN;
    do {
      Via = pDVar6->Via + uVar7;
      uVar8 = (Via->Flags).f;
      if ((TheFlag & uVar8) == 0) {
LAB_080970cb:
        pDVar6 = pPVar4->Data;
        uVar8 = pDVar6->ViaN;
      }
      else {
        if (AndDraw == '\0') {
          (Via->Flags).f = ~TheFlag & uVar8;
          bVar2 = true;
          goto LAB_080970cb;
        }
        AddObjectToFlagUndoList(1,Via,Via,Via);
        (Via->Flags).f = (Via->Flags).f & ~TheFlag;
        DrawVia(Via,0);
        bVar2 = true;
        pDVar6 = PCB->Data;
        uVar8 = pDVar6->ViaN;
        pPVar4 = PCB;
      }
    } while ((uVar8 != 0) && (uVar7 = (uVar8 + 1 + uVar7) - uVar5, uVar5 = uVar8, uVar7 < uVar8));
  }
  local_28 = pDVar6->ElementN - 1;
  if (local_28 != -1) {
    iVar3 = pDVar6->ElementN * 300;
    do {
      local_2c = iVar3 + -300;
      Ptr1 = (void *)((int)&pPVar4->Data->Element[-1].BoundingBox.X1 + iVar3);
      if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
        uVar7 = 0;
        uVar5 = *(uint *)((int)Ptr1 + 0xe0);
        do {
          Via = (PinTypePtr *)(uVar7 * 0x4c + *(int *)((int)Ptr1 + 0x100));
          uVar8 = (Via->Flags).f;
          uVar1 = uVar5;
          if ((TheFlag & uVar8) != 0) {
            if (AndDraw == '\0') {
              (Via->Flags).f = ~TheFlag & uVar8;
              bVar2 = true;
            }
            else {
              AddObjectToFlagUndoList(0x100,Ptr1,Via,Via);
              (Via->Flags).f = (Via->Flags).f & ~TheFlag;
              DrawPin(Via,0);
              bVar2 = true;
              uVar1 = *(uint *)((int)Ptr1 + 0xe0);
            }
          }
        } while ((uVar1 != 0) && (uVar7 = (uVar7 + 1 + uVar1) - uVar5, uVar5 = uVar1, uVar7 < uVar1)
                );
      }
      uVar5 = *(uint *)((int)Ptr1 + 0xe8);
      uVar8 = 0;
      uVar7 = uVar5;
      while ((uVar7 != 0 && (uVar8 < uVar7))) {
        Pad = (PadTypePtr *)(uVar8 * 0x68 + *(int *)((int)Ptr1 + 0x104));
        uVar1 = (Pad->Flags).f;
        if ((TheFlag & uVar1) != 0) {
          if (AndDraw == '\0') {
            (Pad->Flags).f = ~TheFlag & uVar1;
            bVar2 = true;
          }
          else {
            AddObjectToFlagUndoList(0x200,Ptr1,Pad,Pad);
            (Pad->Flags).f = (Pad->Flags).f & ~TheFlag;
            DrawPad(Pad,0);
            uVar7 = *(uint *)((int)Ptr1 + 0xe8);
            bVar2 = true;
          }
        }
        uVar8 = uVar8 + (uVar5 == uVar7);
      }
      local_28 = local_28 + -1;
      pPVar4 = PCB;
      iVar3 = local_2c;
    } while (local_28 != -1);
  }
  if ((bVar2) && (SetChangedFlag('\x01'), AndDraw != '\0')) {
    IncrementUndoSerialNumber();
    Draw();
    return;
  }
  return;
}



void __regparm3 ResetConnections(Boolean AndDraw)

{
  if (AndDraw == '\0') {
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    return;
  }
  SaveUndoSerialNumber();
  ResetFoundPinsViasAndPads(AndDraw);
  RestoreUndoSerialNumber();
  ResetFoundLinesAndPolygons(AndDraw);
  return;
}



void __regparm3 PrintElementNameList(ElementTypePtr *Element,FILE *FP)

{
  DynamicStringType vname;
  DynamicStringType pname;
  DynamicStringType cname;
  char *S;
  
  S = Element->Name[0].TextString;
  if (S == (char *)0x0) {
    S = "";
  }
  CreateQuotedString((DynamicStringTypePtr)0x816c2bc,S);
  S = Element->Name[1].TextString;
  if (S == (char *)0x0) {
    S = "";
  }
  CreateQuotedString((DynamicStringTypePtr)0x816c2b4,S);
  S = Element->Name[2].TextString;
  if (S == (char *)0x0) {
    S = "";
  }
  CreateQuotedString((DynamicStringTypePtr)0x816c2ac,S);
  __fprintf_chk(FP,1,"(%s %s %s)\n",cname.Data,pname.Data,vname.Data);
  return;
}



void __regparm3 PrintConnectionElementName(ElementTypePtr *Element,FILE *FP)

{
  fwrite("Element",1,7,(FILE *)FP);
  PrintElementNameList(Element,FP);
  fwrite(&DAT_08147f2f,1,2,(FILE *)FP);
  return;
}



void __regparm3
PrintConnectionListEntry(char *ObjName,ElementTypePtr *Element,Boolean FirstOne,FILE *FP)

{
  DynamicStringType oname;
  
  CreateQuotedString((DynamicStringTypePtr)0x816c2c4,ObjName);
  if (FirstOne == '\0') {
    __fprintf_chk(FP,1,&DAT_08147f32,oname.Data);
    if (Element != (ElementTypePtr *)0x0) {
      PrintElementNameList(Element,FP);
      return;
    }
    fwrite("(__VIA__)\n",1,10,(FILE *)FP);
  }
  else {
    __fprintf_chk(FP,1,&DAT_08147f2a,oname.Data);
  }
  return;
}



void __regparm3 PrintPinConnections(FILE *FP,Boolean IsFirst)

{
  char *ObjName;
  uint uVar1;
  int iVar2;
  
  if (PVList.Number != 0) {
    if (IsFirst != '\0') {
      ObjName = *(char **)((int)*PVList.Data + 0x3c);
      if (ObjName == (char *)0x0) {
        ObjName = "";
      }
      PrintConnectionListEntry(ObjName,(ElementTypePtr *)0x0,'\x01',FP);
    }
    uVar1 = (uint)(IsFirst != '\0');
    if (uVar1 < PVList.Number) {
      iVar2 = uVar1 * 4;
      do {
        ObjName = *(char **)(*(int *)((int)PVList.Data + iVar2) + 0x3c);
        if (ObjName == (char *)0x0) {
          ObjName = "";
        }
        PrintConnectionListEntry
                  (ObjName,*(ElementTypePtr **)(*(int *)((int)PVList.Data + iVar2) + 0x44),'\0',FP);
        uVar1 = uVar1 + 1;
        iVar2 = iVar2 + 4;
      } while (uVar1 < PVList.Number);
    }
  }
  return;
}



void __regparm3 PrintPadConnections(Cardinal Layer,FILE *FP,Boolean IsFirst)

{
  int iVar1;
  Cardinal CVar2;
  char *ObjName;
  uint uVar3;
  int iVar4;
  
  CVar2 = PadList[Layer].Number;
  if (CVar2 != 0) {
    if (IsFirst != '\0') {
      if (*PadList[Layer].Data == (void *)0x0) {
        __printf_chk(1,"Skipping NULL ptr in 1st part of PrintPadConnections\n");
        CVar2 = PadList[Layer].Number;
      }
      else {
        ObjName = *(char **)((int)*PadList[Layer].Data + 0x58);
        if ((ObjName == (char *)0x0) || (*ObjName == '\0')) {
          ObjName = "(unknown)";
        }
        PrintConnectionListEntry(ObjName,(ElementTypePtr *)0x0,'\x01',FP);
        CVar2 = PadList[Layer].Number;
      }
    }
    uVar3 = (uint)(IsFirst != '\0');
    if (uVar3 < CVar2) {
      iVar4 = uVar3 * 4;
      do {
        iVar1 = *(int *)((int)PadList[Layer].Data + iVar4);
        if (iVar1 == 0) {
          __printf_chk(1,"Skipping NULL ptr in 2nd part of PrintPadConnections\n");
        }
        else {
          ObjName = *(char **)(iVar1 + 0x58);
          if (ObjName == (char *)0x0) {
            ObjName = "";
          }
          PrintConnectionListEntry(ObjName,*(ElementTypePtr **)(iVar1 + 0x60),'\0',FP);
        }
        uVar3 = uVar3 + 1;
        iVar4 = iVar4 + 4;
      } while (uVar3 <= PadList[Layer].Number && PadList[Layer].Number != uVar3);
    }
  }
  return;
}



Boolean IsLineInPolygon(LineTypePtr Line,PolygonTypePtr Polygon)

{
  int *piVar1;
  int iVar2;
  PLINE *pPVar3;
  Boolean BVar4;
  POLYAREA *a;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  
  if ((((*(byte *)&(Polygon->Flags).f & 0x10) == 0) || ((*(byte *)&(Line->Flags).f & 0x20) == 0)) &&
     (Polygon->Clipped != (POLYAREA *)0x0)) {
    if ((*(byte *)((int)&(Line->Flags).f + 1) & 1) != 0) {
      iVar6 = (Line->Point1).X;
      iVar2 = (Line->Point2).X;
      if (iVar6 == iVar2) {
        iVar5 = (Line->Point2).Y;
        iVar9 = (Line->Point1).Y;
LAB_08097782:
        iVar10 = (Line->Thickness + Bloat + 1) / 2;
        iVar7 = iVar5;
        if (iVar5 <= iVar9) {
          iVar7 = iVar9;
        }
        iVar8 = iVar6;
        if (iVar6 <= iVar2) {
          iVar8 = iVar2;
        }
        if (iVar9 <= iVar5) {
          iVar5 = iVar9;
        }
        if (iVar2 <= iVar6) {
          iVar6 = iVar2;
        }
        BVar4 = IsRectangleInPolygon
                          (iVar6 - iVar10,iVar5 - iVar10,iVar10 + iVar8,iVar7 + iVar10,Polygon);
        return BVar4;
      }
      iVar5 = (Line->Point1).Y;
      iVar9 = iVar5;
      if (iVar5 == (Line->Point2).Y) goto LAB_08097782;
    }
    pPVar3 = Polygon->Clipped->contours;
    iVar6 = pPVar3->xmax + Bloat;
    if ((((Line->BoundingBox).X1 == iVar6 || (Line->BoundingBox).X1 < iVar6) &&
        (pPVar3->xmin - Bloat <= (Line->BoundingBox).X2)) &&
       ((iVar6 = pPVar3->ymax + Bloat, piVar1 = &(Line->BoundingBox).Y1,
        *piVar1 == iVar6 || *piVar1 < iVar6 &&
        ((pPVar3->ymin - Bloat <= (Line->BoundingBox).Y2 &&
         (a = LinePoly((LineType *)Line,Bloat + Line->Thickness), a != (POLYAREA *)0x0)))))) {
      BVar4 = isects(a,Polygon,'\x01');
      return BVar4;
    }
  }
  return '\0';
}



Boolean __regparm3 LookupLOConnectionsToLine(LineTypePtr Line,Cardinal LayerGroup,Boolean PolysTo)

{
  uint *puVar1;
  uint L;
  Boolean BVar2;
  int iVar3;
  Cardinal *pCVar4;
  PolygonTypePtr Polygon;
  LineTypePtr pLVar5;
  uint uVar6;
  lo_info *plVar7;
  int in_GS_OFFSET;
  uint local_264;
  lo_info info;
  int local_20;
  
  plVar7 = &info;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = 0x16;
  pLVar5 = Line;
  while (plVar7 = (lo_info *)&plVar7->line, iVar3 != 0) {
    iVar3 = iVar3 + -1;
    ((BoxType *)&plVar7->layer)->X1 = (pLVar5->BoundingBox).X1;
    pLVar5 = (LineTypePtr)&(pLVar5->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
    info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
    info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
    info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
  }
  info.layer = LayerGroup;
  iVar3 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar3 == 0) {
    r_search(PCB->Data->rat_tree,(BoxType *)&info.line,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             LOCtoLineRat_callback,&info);
    if ((&(PCB->Flags).f)[LayerGroup + 0x734] != 0) {
      local_264 = 0;
      do {
        L = (&(PCB->Flags).f)[local_264 + 0x744 + LayerGroup * 0x12];
        uVar6 = PCB->Data->LayerN;
        if (L < uVar6) {
          info.layer = L;
          iVar3 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar3 != 0) goto LAB_08097865;
          r_search(*(rtree_t **)(&PCB->Data->field_0x80 + L * 0x5c),(BoxType *)&info.line,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoLineLine_callback,&info);
          iVar3 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar3 != 0) goto LAB_08097865;
          r_search(*(rtree_t **)(&PCB->Data->field_0x8c + L * 0x5c),(BoxType *)&info.line,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoLineArc_callback,&info);
          if ((PolysTo != '\0') &&
             (pCVar4 = &PCB->Data->ViaN + L * 0x17, Polygon = (PolygonTypePtr)pCVar4[0x1e],
             pCVar4[0x16] != 0)) {
            uVar6 = 0;
            while( true ) {
              if (((((Polygon->Flags).f & TheFlag) == 0) &&
                  (BVar2 = IsLineInPolygon(Line,Polygon), BVar2 != '\0')) &&
                 (BVar2 = ADD_POLYGON_TO_LIST(L,Polygon), BVar2 != '\0')) goto LAB_08097865;
              uVar6 = uVar6 + 1;
              puVar1 = (uint *)(&PCB->Data->field_0x58 + L * 0x5c);
              if (*puVar1 < uVar6 || *puVar1 == uVar6) break;
              Polygon = Polygon + 1;
            }
          }
        }
        else {
          info.layer = L - uVar6;
          iVar3 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar3 != 0) goto LAB_08097865;
          r_search(PCB->Data->pad_tree,(BoxType *)&info.line,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoLinePad_callback,&info);
        }
        local_264 = local_264 + 1;
        puVar1 = &(PCB->Flags).f + LayerGroup + 0x734;
      } while (local_264 <= *puVar1 && *puVar1 != local_264);
    }
    BVar2 = '\0';
  }
  else {
LAB_08097865:
    BVar2 = '\x01';
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar2;
}



Boolean __regparm3 LookupLOConnectionsToPad(PadTypePtr *Pad,Cardinal LayerGroup)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  Boolean BVar4;
  int iVar5;
  PadType *pPVar6;
  int in_GS_OFFSET;
  uint local_264;
  lo_info info;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0) {
    BVar4 = LookupLOConnectionsToLine((LineTypePtr)Pad,LayerGroup,'\0');
  }
  else {
    iVar5 = 0x1a;
    pPVar6 = &info.pad;
    while (iVar5 != 0) {
      iVar5 = iVar5 + -1;
      (pPVar6->BoundingBox).X1 = (Pad->BoundingBox).X1;
      Pad = (PadTypePtr *)&(Pad->BoundingBox).Y1;
      pPVar6 = (PadType *)&(pPVar6->BoundingBox).Y1;
    }
    if (0 < Bloat) {
      info.pad.BoundingBox.X1 = info.pad.BoundingBox.X1 - Bloat;
      info.pad.BoundingBox.X2 = info.pad.BoundingBox.X2 + Bloat;
      info.pad.BoundingBox.Y1 = info.pad.BoundingBox.Y1 - Bloat;
      info.pad.BoundingBox.Y2 = info.pad.BoundingBox.Y2 + Bloat;
    }
    info.layer = LayerGroup;
    iVar5 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar5 == 0) {
      r_search(PCB->Data->rat_tree,(BoxType *)&info.pad,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               LOCtoPadRat_callback,&info);
      if ((&(PCB->Flags).f)[LayerGroup + 0x734] != 0) {
        local_264 = 0;
        do {
          uVar2 = (&(PCB->Flags).f)[local_264 + 0x744 + LayerGroup * 0x12];
          uVar3 = PCB->Data->LayerN;
          if (uVar2 < uVar3) {
            info.layer = uVar2;
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(*(rtree_t **)(&PCB->Data->field_0x80 + uVar2 * 0x5c),(BoxType *)&info.pad,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadLine_callback,&info);
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(*(rtree_t **)(&PCB->Data->field_0x8c + uVar2 * 0x5c),(BoxType *)&info.pad,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadArc_callback,&info);
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(*(rtree_t **)(&PCB->Data->field_0x88 + uVar2 * 0x5c),(BoxType *)&info.pad,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadPoly_callback,&info);
          }
          else {
            info.layer = uVar2 - uVar3;
            iVar5 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar5 != 0) goto LAB_08097b76;
            r_search(PCB->Data->pad_tree,(BoxType *)&info.pad,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPadPad_callback,&info);
          }
          local_264 = local_264 + 1;
          puVar1 = &(PCB->Flags).f + LayerGroup + 0x734;
        } while (local_264 <= *puVar1 && *puVar1 != local_264);
      }
      BVar4 = '\0';
    }
    else {
LAB_08097b76:
      BVar4 = '\x01';
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int LOCtoPolyLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = IsLineInPolygon((LineTypePtr)b,(PolygonTypePtr)((int)cl + 0x108));
    if (BVar1 != '\0') {
      BVar1 = ADD_LINE_TO_LIST(*(Cardinal *)cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



Boolean __regparm3 LOTouchesLine(LineTypePtr Line,Cardinal LayerGroup)

{
  uint *puVar1;
  uint uVar2;
  Boolean BVar3;
  int iVar4;
  Cardinal *pCVar5;
  PolygonTypePtr Polygon;
  LineTypePtr pLVar6;
  uint uVar7;
  lo_info *plVar8;
  int in_GS_OFFSET;
  uint local_260;
  lo_info info;
  int local_20;
  
  iVar4 = 0x16;
  plVar8 = &info;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pLVar6 = Line;
  while (plVar8 = (lo_info *)&plVar8->line, iVar4 != 0) {
    iVar4 = iVar4 + -1;
    ((BoxType *)&plVar8->layer)->X1 = (pLVar6->BoundingBox).X1;
    pLVar6 = (LineTypePtr)&(pLVar6->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
    info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
    info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
    info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
  }
  if ((&(PCB->Flags).f)[LayerGroup + 0x734] != 0) {
    local_260 = 0;
    do {
      uVar2 = (&(PCB->Flags).f)[local_260 + 0x744 + LayerGroup * 0x12];
      uVar7 = PCB->Data->LayerN;
      if (uVar2 < uVar7) {
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 == 0) {
          r_search(*(rtree_t **)(&PCB->Data->field_0x80 + uVar2 * 0x5c),(BoxType *)&info.line,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOT_Linecallback,&info);
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 == 0) {
            r_search(*(rtree_t **)(&PCB->Data->field_0x8c + uVar2 * 0x5c),(BoxType *)&info.line,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOT_Arccallback,&info);
            pCVar5 = &PCB->Data->ViaN + uVar2 * 0x17;
            Polygon = (PolygonTypePtr)pCVar5[0x1e];
            if (pCVar5[0x16] != 0) {
              uVar7 = 0;
              while( true ) {
                if (((Polygon->Flags).f & TheFlag) == 0) {
                  BVar3 = IsLineInPolygon(Line,Polygon);
                  if (BVar3 != '\0') goto LAB_0809805c;
                }
                uVar7 = uVar7 + 1;
                puVar1 = (uint *)(&PCB->Data->field_0x58 + uVar2 * 0x5c);
                if (*puVar1 < uVar7 || *puVar1 == uVar7) break;
                Polygon = Polygon + 1;
              }
            }
            goto LAB_080980df;
          }
        }
LAB_0809805c:
        BVar3 = '\x01';
        goto LAB_08098061;
      }
      info.layer = uVar2 - uVar7;
      iVar4 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar4 != 0) goto LAB_0809805c;
      r_search(PCB->Data->pad_tree,(BoxType *)&info.line,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               LOT_Padcallback,&info);
LAB_080980df:
      local_260 = local_260 + 1;
      puVar1 = &(PCB->Flags).f + LayerGroup + 0x734;
    } while (local_260 <= *puVar1 && *puVar1 != local_260);
  }
  BVar3 = '\0';
LAB_08098061:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean lineClear(LineTypePtr line,Cardinal group)

{
  Boolean BVar1;
  bool bVar2;
  
  BVar1 = LOTouchesLine(line,group);
  bVar2 = false;
  if (BVar1 == '\0') {
    BVar1 = PVTouchesLine(line);
    bVar2 = BVar1 == '\0';
  }
  return (Boolean)bVar2;
}



Boolean IsPolygonInPolygon(PolygonTypePtr P1,PolygonTypePtr P2)

{
  int iVar1;
  POLYAREA *a;
  PLINE *pPVar2;
  PLINE *pPVar3;
  VNODE *pVVar4;
  Boolean BVar5;
  int in_GS_OFFSET;
  FlagType local_8c;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  a = P1->Clipped;
  if ((a != (POLYAREA *)0x0) && (P2->Clipped != (POLYAREA *)0x0)) {
    pPVar2 = a->contours;
    pPVar3 = P2->Clipped->contours;
    if ((pPVar2->xmin - Bloat <= pPVar3->xmax) &&
       (((pPVar3->xmin <= pPVar2->xmax + Bloat && (pPVar2->ymin - Bloat <= pPVar3->ymax)) &&
        (pPVar3->ymin <= Bloat + pPVar2->ymax)))) {
      BVar5 = isects(a,P2,'\0');
      if (BVar5 != '\0') {
LAB_080982f4:
        BVar5 = '\x01';
        goto LAB_0809823a;
      }
      if (0 < Bloat) {
        pPVar2 = P1->Clipped->contours;
        while (pPVar2 != (PLINE *)0x0) {
          pPVar3 = P2->Clipped->contours;
          if (((pPVar2->xmin - Bloat <= pPVar3->xmax) && (pPVar3->xmin <= pPVar2->xmax + Bloat)) &&
             ((pPVar2->ymin - Bloat <= pPVar3->ymax && (pPVar3->ymin <= pPVar2->ymax + Bloat)))) {
            line.Point1.X = (pPVar2->head).point[0];
            line.Thickness = Bloat * 2;
            line.Point1.Y = (pPVar2->head).point[1];
            line.Clearance = 0;
            MakeFlags(&local_8c,0);
            pVVar4 = (pPVar2->head).next;
            while (&pPVar2->head != pVVar4) {
              line.Point2.X = pVVar4->point[0];
              line.Point2.Y = pVVar4->point[1];
              SetLineBoundingBox((LineTypePtr)&line);
              BVar5 = IsLineInPolygon((LineTypePtr)&line,P2);
              if (BVar5 != '\0') goto LAB_080982f4;
              pVVar4 = pVVar4->next;
              line.Point1.X = line.Point2.X;
              line.Point1.Y = line.Point2.Y;
            }
          }
          pPVar2 = pPVar2->next;
        }
      }
    }
  }
  BVar5 = '\0';
LAB_0809823a:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar5;
}



Boolean __regparm3 LookupLOConnectionsToPolygon(PolygonTypePtr Polygon,Cardinal LayerGroup)

{
  uint *puVar1;
  int iVar2;
  uint L;
  Boolean BVar3;
  int iVar4;
  PolygonTypePtr P1;
  uint uVar5;
  int in_GS_OFFSET;
  uint local_268;
  lo_info info;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    info.polygon.BoundingBox.X1 = (Polygon->BoundingBox).X1;
    info.polygon.BoundingBox.Y1 = (Polygon->BoundingBox).Y1;
    info.polygon.BoundingBox.X2 = (Polygon->BoundingBox).X2;
    info.polygon.BoundingBox.Y2 = (Polygon->BoundingBox).Y2;
    info.polygon.ID = Polygon->ID;
    info.polygon.Flags.f = (Polygon->Flags).f;
    info.polygon.Flags.t._0_4_ = *(undefined4 *)(Polygon->Flags).t;
    info.polygon.Flags.t._4_4_ = *(undefined4 *)((Polygon->Flags).t + 4);
    info.polygon.net = Polygon->net;
    info.polygon.PointN = Polygon->PointN;
    info.polygon.PointMax = Polygon->PointMax;
    info.polygon.Clipped = Polygon->Clipped;
    info.polygon.NoHoles = Polygon->NoHoles;
    info.polygon.NoHolesValid = Polygon->NoHolesValid;
    info.polygon.Points = Polygon->Points;
    if (0 < Bloat) {
      info.polygon.BoundingBox.X1 = info.polygon.BoundingBox.X1 - Bloat;
      info.polygon.BoundingBox.X2 = info.polygon.BoundingBox.X2 + Bloat;
      info.polygon.BoundingBox.Y1 = info.polygon.BoundingBox.Y1 - Bloat;
      info.polygon.BoundingBox.Y2 = info.polygon.BoundingBox.Y2 + Bloat;
    }
    info.layer = LayerGroup;
    iVar4 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar4 != 0) {
LAB_08098409:
      BVar3 = '\x01';
      goto LAB_0809840e;
    }
    r_search(PCB->Data->rat_tree,(BoxType *)&info.polygon,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             LOCtoPolyRat_callback,&info);
    if ((&(PCB->Flags).f)[LayerGroup + 0x734] != 0) {
      local_268 = 0;
      do {
        L = (&(PCB->Flags).f)[local_268 + 0x744 + LayerGroup * 0x12];
        uVar5 = PCB->Data->LayerN;
        if (L < uVar5) {
          iVar4 = L * 0x5c;
          P1 = *(PolygonTypePtr *)(&PCB->Data->field_0x78 + iVar4);
          if (*(int *)(&PCB->Data->field_0x58 + iVar4) != 0) {
            uVar5 = 0;
            while( true ) {
              if (((((P1->Flags).f & TheFlag) == 0) &&
                  (BVar3 = IsPolygonInPolygon(P1,Polygon), BVar3 != '\0')) &&
                 (BVar3 = ADD_POLYGON_TO_LIST(L,P1), BVar3 != '\0')) goto LAB_08098409;
              uVar5 = uVar5 + 1;
              puVar1 = (uint *)(&PCB->Data->field_0x58 + iVar4);
              if (*puVar1 < uVar5 || *puVar1 == uVar5) break;
              P1 = P1 + 1;
            }
          }
          info.layer = L;
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08098409;
          r_search(*(rtree_t **)(&PCB->Data->field_0x80 + L * 0x5c),(BoxType *)&info.polygon,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPolyLine_callback,&info);
          iVar4 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar4 != 0) goto LAB_08098409;
          r_search(*(rtree_t **)(&PCB->Data->field_0x8c + L * 0x5c),(BoxType *)&info.polygon,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPolyArc_callback,&info);
        }
        else {
          if ((*(byte *)&(Polygon->Flags).f & 0x10) == 0) {
            info.layer = L - uVar5;
            iVar4 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar4 != 0) goto LAB_08098409;
            r_search(PCB->Data->pad_tree,(BoxType *)&info.polygon,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoPolyPad_callback,&info);
          }
        }
        local_268 = local_268 + 1;
        puVar1 = &(PCB->Flags).f + LayerGroup + 0x734;
      } while (local_268 <= *puVar1 && *puVar1 != local_268);
    }
  }
  BVar3 = '\0';
LAB_0809840e:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar3;
}



Boolean IsPadInPolygon(PadTypePtr *pad,PolygonTypePtr polygon)

{
  Boolean BVar1;
  
  BVar1 = IsLineInPolygon((LineTypePtr)pad,polygon);
  return BVar1;
}



int LOCtoPolyPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && (*(uint *)cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = IsLineInPolygon((LineTypePtr)b,(PolygonTypePtr)((int)cl + 0x108));
    if (BVar1 != '\0') {
      BVar1 = ADD_PAD_TO_LIST(*(Cardinal *)cl,(PadTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOCtoPadPoly_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && ((b[1].Y1 & 0x10U) == 0)) {
    BVar1 = IsLineInPolygon((LineTypePtr)((int)cl + 0x5c),(PolygonTypePtr)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_POLYGON_TO_LIST(*(Cardinal *)cl,(PolygonTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



Boolean IsArcInPolygon(ArcTypePtr *Arc,PolygonTypePtr Polygon)

{
  int *piVar1;
  PLINE *pPVar2;
  Boolean BVar3;
  POLYAREA *a;
  int iVar4;
  
  if ((((((*(byte *)&(Polygon->Flags).f & 0x10) == 0) || ((*(byte *)&(Arc->Flags).f & 0x20) == 0))
       && (Polygon->Clipped != (POLYAREA *)0x0)) &&
      ((pPVar2 = Polygon->Clipped->contours, iVar4 = pPVar2->xmax + Bloat,
       (Arc->BoundingBox).X1 == iVar4 || (Arc->BoundingBox).X1 < iVar4 &&
       (pPVar2->xmin - Bloat <= (Arc->BoundingBox).X2)))) &&
     ((iVar4 = pPVar2->ymax + Bloat, piVar1 = &(Arc->BoundingBox).Y1,
      *piVar1 == iVar4 || *piVar1 < iVar4 &&
      ((pPVar2->ymin - Bloat <= (Arc->BoundingBox).Y2 &&
       (a = ArcPoly((ArcType *)Arc,Bloat + Arc->Thickness), a != (POLYAREA *)0x0)))))) {
    BVar3 = isects(a,Polygon,'\x01');
    return BVar3;
  }
  return '\0';
}



Boolean __regparm3 LookupLOConnectionsToArc(ArcTypePtr *Arc,Cardinal LayerGroup)

{
  uint *puVar1;
  uint L;
  Boolean BVar2;
  int iVar3;
  Cardinal *pCVar4;
  PolygonTypePtr Polygon;
  ArcTypePtr *pAVar5;
  uint uVar6;
  ArcType *pAVar7;
  int in_GS_OFFSET;
  uint local_264;
  lo_info info;
  int local_20;
  
  iVar3 = 0x11;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pAVar5 = Arc;
  pAVar7 = &info.arc;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    (pAVar7->BoundingBox).X1 = (pAVar5->BoundingBox).X1;
    pAVar5 = (ArcTypePtr *)&(pAVar5->BoundingBox).Y1;
    pAVar7 = (ArcType *)&(pAVar7->BoundingBox).Y1;
  }
  if (0 < Bloat) {
    info.arc.BoundingBox.X1 = info.arc.BoundingBox.X1 - Bloat;
    info.arc.BoundingBox.X2 = info.arc.BoundingBox.X2 + Bloat;
    info.arc.BoundingBox.Y1 = info.arc.BoundingBox.Y1 - Bloat;
    info.arc.BoundingBox.Y2 = info.arc.BoundingBox.Y2 + Bloat;
  }
  if ((&(PCB->Flags).f)[LayerGroup + 0x734] != 0) {
    local_264 = 0;
    do {
      L = (&(PCB->Flags).f)[local_264 + 0x744 + LayerGroup * 0x12];
      uVar6 = PCB->Data->LayerN;
      if (L < uVar6) {
        info.layer = L;
        iVar3 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar3 == 0) {
          r_search(*(rtree_t **)(&PCB->Data->field_0x80 + L * 0x5c),(BoxType *)&info.arc,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoArcLine_callback,&info);
          iVar3 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar3 == 0) {
            r_search(*(rtree_t **)(&PCB->Data->field_0x8c + L * 0x5c),(BoxType *)&info.arc,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoArcArc_callback,&info);
            pCVar4 = &PCB->Data->ViaN + L * 0x17;
            Polygon = (PolygonTypePtr)pCVar4[0x1e];
            if (pCVar4[0x16] != 0) {
              uVar6 = 0;
              while( true ) {
                if (((Polygon->Flags).f & TheFlag) == 0) {
                  BVar2 = IsArcInPolygon(Arc,Polygon);
                  if (BVar2 != '\0') {
                    BVar2 = ADD_POLYGON_TO_LIST(L,Polygon);
                    if (BVar2 != '\0') goto LAB_08098a35;
                  }
                }
                uVar6 = uVar6 + 1;
                puVar1 = (uint *)(&PCB->Data->field_0x58 + L * 0x5c);
                if (*puVar1 < uVar6 || *puVar1 == uVar6) break;
                Polygon = Polygon + 1;
              }
            }
            goto LAB_08098ab7;
          }
        }
LAB_08098a35:
        BVar2 = '\x01';
        goto LAB_08098a3a;
      }
      info.layer = L - uVar6;
      iVar3 = _setjmp((__jmp_buf_tag *)info.env);
      if (iVar3 != 0) goto LAB_08098a35;
      r_search(PCB->Data->pad_tree,(BoxType *)&info.arc,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               LOCtoArcPad_callback,&info);
LAB_08098ab7:
      local_264 = local_264 + 1;
      puVar1 = &(PCB->Flags).f + LayerGroup + 0x734;
    } while (local_264 <= *puVar1 && *puVar1 != local_264);
  }
  BVar2 = '\0';
LAB_08098a3a:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



undefined4 LOCtoPolyArc_callback(ArcTypePtr *param_1,Cardinal *param_2)

{
  Boolean BVar1;
  
  if ((param_1->Thickness != 0) && (((param_1->Flags).f & TheFlag) == 0)) {
    BVar1 = IsArcInPolygon(param_1,(PolygonTypePtr)(param_2 + 0x42));
    if (BVar1 != '\0') {
      BVar1 = ADD_ARC_TO_LIST(*param_2,param_1);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk(param_2 + 0x68,1);
      }
    }
  }
  return 0;
}



void __regparm3 form_slanted_rectangle(PointType *p,LineTypePtr l)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  float10 fVar5;
  float10 fVar6;
  float10 fVar7;
  
  iVar3 = (l->Point2).Y - (l->Point1).Y;
  iVar1 = (l->Point1).X;
  iVar2 = l->Thickness;
  if (iVar3 == 0) {
    fVar6 = (float10)(iVar2 / 2);
    fVar5 = (float10)0;
  }
  else {
    iVar4 = (l->Point2).X - iVar1;
    if (iVar4 == 0) {
      fVar5 = (float10)(iVar2 / 2);
      fVar6 = (float10)0;
    }
    else {
      fVar6 = (float10)iVar4;
      fVar7 = (float10)iVar3;
      fVar5 = SQRT(fVar7 * fVar7 + fVar6 * fVar6);
      fVar5 = (float10)iVar2 / (fVar5 + fVar5);
      fVar6 = fVar6 * fVar5;
      fVar5 = fVar5 * fVar7;
    }
  }
  p->X = (int)ROUND(((float10)iVar1 - fVar6) + fVar5);
  p->Y = (int)ROUND(((float10)(l->Point1).Y - fVar5) - fVar6);
  p[1].X = (int)ROUND(((float10)(l->Point1).X - fVar6) - fVar5);
  p[1].Y = (int)ROUND(((float10)(l->Point1).Y - fVar5) + fVar6);
  p[2].X = (int)ROUND(((float10)(l->Point2).X + fVar6) - fVar5);
  p[2].Y = (int)ROUND((float10)(l->Point2).Y + fVar5 + fVar6);
  p[3].X = (int)ROUND((float10)(l->Point2).X + fVar6 + fVar5);
  p[3].Y = (int)ROUND(((float10)(l->Point2).Y + fVar5) - fVar6);
  return;
}



// WARNING: Removing unreachable block (ram,0x08098d68)
// WARNING: Removing unreachable block (ram,0x08098d70)
// WARNING: Removing unreachable block (ram,0x08098dda)
// WARNING: Variable defined which should be unmapped: p
// WARNING: Could not reconcile some variable overlaps

Boolean LineLineIntersect(LineTypePtr Line1,LineTypePtr Line2)

{
  float fVar1;
  uint uVar2;
  int X;
  int Y;
  int Y_00;
  int X_00;
  int Y_01;
  int X_01;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  undefined uVar7;
  Boolean BVar8;
  int X_02;
  int iVar9;
  int Radius;
  uint Radius_00;
  BDimension Radius_01;
  undefined2 in_FPUControlWord;
  undefined auStack172 [12];
  undefined auStack156 [12];
  int local_74;
  undefined2 local_70;
  undefined2 local_6e;
  PointType p [4];
  
  if ((*(byte *)((int)&(Line1->Flags).f + 1) & 1) != 0) {
    form_slanted_rectangle(p,Line1);
    BVar8 = IsLineInQuadrangle(p,Line2);
    return BVar8;
  }
  uVar2 = (Line2->Flags).f;
  if ((uVar2 & 0x100) != 0) {
    form_slanted_rectangle(p,Line2);
    BVar8 = IsLineInQuadrangle(p,Line1);
    return BVar8;
  }
  X = (Line1->Point2).X;
  X_02 = (Line1->Point1).X;
  Y = (Line1->Point2).Y;
  fVar6 = (float)(X - X_02);
  Y_00 = (Line1->Point1).Y;
  X_00 = (Line2->Point1).X;
  fVar5 = (float)(Y - Y_00);
  local_74 = X_02 - X_00;
  Radius = (Line2->Point1).Y;
  Y_01 = (Line2->Point2).Y;
  X_01 = (Line2->Point2).X;
  iVar9 = X_01 - X_00;
  fVar4 = (float)(Y_00 - Radius) * fVar6 - (float)local_74 * fVar5;
  fVar1 = (float)(Y_01 - Radius);
  fVar3 = (float)(Y_01 - Radius) * fVar6 - (float)iVar9 * fVar5;
  if (fVar3 == 0.00000000) {
    if ((fVar6 == 0.00000000) && (fVar5 == 0.00000000)) {
      Radius_00 = Line1->Thickness / 2 + Bloat;
      if ((int)Radius_00 < 0) {
        Radius_00 = uVar2 & 0x100;
      }
      BVar8 = IsPointInPad(X_02,Y_00,Radius_00,
                           (PadTypePtr)
                           (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,CONCAT460(
                                                  local_74,CONCAT456(fVar1,CONCAT452(Y,CONCAT448(X,
                                                  CONCAT444(X_01,CONCAT440(Y_01,CONCAT436(iVar9,
                                                  CONCAT432(uVar2,CONCAT1220(auStack156,
                                                                             CONCAT416(X_00,
                                                  CONCAT124(auStack172,Line2)))))))))))))) &
                           (undefined  [104])0xffffffffffffffff));
    }
    else {
      X_02 = Line1->Thickness + Line2->Thickness;
      fVar3 = (float)X_02 * 0.50000000 + fBloat;
      if (fVar3 <= 0.00000000) {
        fVar3 = 0.00000000;
      }
      BVar8 = '\0';
      if ((fVar5 * fVar5 + fVar6 * fVar6) / (fVar4 * fVar4) <= fVar3 * fVar3) {
        Radius_01 = Line2->Thickness / 2 + Bloat;
        if (Radius_01 < 0) {
          Radius_01 = 0;
        }
        BVar8 = IsPointInPad(X_00,Radius,Radius_01,
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,CONCAT460(
                                                  X_02,CONCAT456(fVar1,CONCAT452(Y,CONCAT448(X,
                                                  CONCAT444(X_01,CONCAT440(Y_01,CONCAT436(iVar9,
                                                  CONCAT432(uVar2,CONCAT1220(auStack156,
                                                                             CONCAT416(X_00,
                                                  CONCAT124(auStack172,Line1)))))))))))))) &
                             (undefined  [104])0xffffffffffffffff));
        if (BVar8 == '\0') {
          Radius_01 = Line2->Thickness / 2 + Bloat;
          if (Radius_01 < 0) {
            Radius_01 = 0;
          }
          BVar8 = IsPointInPad((Line2->Point2).X,(Line2->Point2).Y,Radius_01,
                               (PadTypePtr)
                               (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,CONCAT460(
                                                  X_02,CONCAT456(fVar1,CONCAT452(Y,CONCAT448(X,
                                                  CONCAT444(X_01,CONCAT440(Y_01,CONCAT436(iVar9,
                                                  CONCAT432(uVar2,CONCAT1220(auStack156,
                                                                             CONCAT416(X_00,
                                                  CONCAT124(auStack172,Line1)))))))))))))) &
                               (undefined  [104])0xffffffffffffffff));
          if (BVar8 == '\0') {
            Radius_01 = Line1->Thickness / 2 + Bloat;
            if (Radius_01 < 0) {
              Radius_01 = 0;
            }
            BVar8 = IsPointInPad((Line1->Point1).X,(Line1->Point1).Y,Radius_01,
                                 (PadTypePtr)
                                 (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,
                                                  CONCAT460(X_02,CONCAT456(fVar1,CONCAT452(Y,
                                                  CONCAT448(X,CONCAT444(X_01,CONCAT440(Y_01,
                                                  CONCAT436(iVar9,CONCAT432(uVar2,CONCAT1220(
                                                  auStack156,
                                                  CONCAT416(X_00,CONCAT124(auStack172,Line2)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
            if (BVar8 != '\0') {
              return '\x01';
            }
            Radius_01 = Line1->Thickness / 2 + Bloat;
            if (Radius_01 < 0) {
              Radius_01 = 0;
            }
            BVar8 = IsPointInPad((Line1->Point2).X,(Line1->Point2).Y,Radius_01,
                                 (PadTypePtr)
                                 (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,
                                                  CONCAT460(X_02,CONCAT456(fVar1,CONCAT452(Y,
                                                  CONCAT448(X,CONCAT444(X_01,CONCAT440(Y_01,
                                                  CONCAT436(iVar9,CONCAT432(uVar2,CONCAT1220(
                                                  auStack156,
                                                  CONCAT416(X_00,CONCAT124(auStack172,Line2)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
            return BVar8 != '\0';
          }
        }
        return '\x01';
      }
    }
  }
  else {
    fVar4 = fVar4 / fVar3;
    fVar3 = fVar3 / ((float)iVar9 * (float)(Y_00 - Radius) - (float)local_74 * fVar1);
    uVar7 = (undefined)in_FPUControlWord;
    if ((fVar3 < 0.00000000) || (1.00000000 < fVar3)) {
      if ((fVar4 < 0.00000000) || (1.00000000 < fVar4)) {
        BVar8 = IsPointInPad(X_02,Y_00,(int)ROUND((float)Line1->Thickness * 0.50000000 + fBloat),
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(in_FPUControlWord,
                                                            CONCAT264(CONCAT11(0xc,uVar7),
                                                                      CONCAT460(local_74,CONCAT456(
                                                  fVar1,CONCAT452(Y,CONCAT448(X,CONCAT444(X_01,
                                                  CONCAT440(Y_01,CONCAT436(iVar9,CONCAT432(uVar2,
                                                  CONCAT1220(auStack156,
                                                             CONCAT416(X_00,CONCAT124(auStack172,
                                                                                      Line2)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
        if (BVar8 != '\0') {
          return '\x01';
        }
        BVar8 = IsPointInPad((Line1->Point2).X,(Line1->Point2).Y,
                             (int)ROUND((float)Line1->Thickness * 0.50000000 + fBloat),
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(in_FPUControlWord,
                                                            CONCAT264(CONCAT11(0xc,(char)
                                                  in_FPUControlWord),
                                                  CONCAT460(local_74,CONCAT456(fVar1,CONCAT452(Y,
                                                  CONCAT448(X,CONCAT444(X_01,CONCAT440(Y_01,
                                                  CONCAT436(iVar9,CONCAT432(uVar2,CONCAT1220(
                                                  auStack156,
                                                  CONCAT416(X_00,CONCAT124(auStack172,Line2)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
        if (BVar8 != '\0') {
          return '\x01';
        }
        BVar8 = IsPointInPad((Line2->Point1).X,(Line2->Point1).Y,
                             (int)ROUND((float)Line2->Thickness * 0.50000000 + fBloat),
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(in_FPUControlWord,
                                                            CONCAT264(CONCAT11(0xc,(char)
                                                  in_FPUControlWord),
                                                  CONCAT460(local_74,CONCAT456(fVar1,CONCAT452(Y,
                                                  CONCAT448(X,CONCAT444(X_01,CONCAT440(Y_01,
                                                  CONCAT436(iVar9,CONCAT432(uVar2,CONCAT1220(
                                                  auStack156,
                                                  CONCAT416(X_00,CONCAT124(auStack172,Line1)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
        if (BVar8 != '\0') {
          return '\x01';
        }
        BVar8 = IsPointInPad((Line2->Point2).X,(Line2->Point2).Y,
                             (int)ROUND((float)Line2->Thickness * 0.50000000 + fBloat),
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(in_FPUControlWord,
                                                            CONCAT264(CONCAT11(0xc,(char)
                                                  in_FPUControlWord),
                                                  CONCAT460(local_74,CONCAT456(fVar1,CONCAT452(Y,
                                                  CONCAT448(X,CONCAT444(X_01,CONCAT440(Y_01,
                                                  CONCAT436(iVar9,CONCAT432(uVar2,CONCAT1220(
                                                  auStack156,
                                                  CONCAT416(X_00,CONCAT124(auStack172,Line1)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
      }
      else {
        if (0.00000000 <= fVar3) {
          X_02 = 0;
          fVar4 = (float)Line1->Thickness * 0.50000000 + fBloat;
          if (0.00000000 < fVar4) {
            local_70 = CONCAT11(0xc,uVar7);
            X_02 = (int)ROUND(fVar4);
            local_74 = X_02;
            local_6e = in_FPUControlWord;
          }
          BVar8 = IsPointInPad(X,Y,X_02,(PadTypePtr)
                                        (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,
                                                  CONCAT460(local_74,CONCAT456(fVar1,CONCAT452(Y,
                                                  CONCAT448(X,CONCAT444(X_01,CONCAT440(Y_01,
                                                  CONCAT436(iVar9,CONCAT432(uVar2,CONCAT1220(
                                                  auStack156,
                                                  CONCAT416(X_00,CONCAT124(auStack172,Line2)))))))))
                                                  ))))) & (undefined  [104])0xffffffffffffffff));
        }
        else {
          Radius = 0;
          fVar4 = (float)Line1->Thickness * 0.50000000 + fBloat;
          if (0.00000000 < fVar4) {
            local_70 = CONCAT11(0xc,uVar7);
            Radius = (int)ROUND(fVar4);
            local_74 = Radius;
            local_6e = in_FPUControlWord;
          }
          BVar8 = IsPointInPad(X_02,Y_00,Radius,
                               (PadTypePtr)
                               (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,CONCAT460(
                                                  local_74,CONCAT456(fVar1,CONCAT452(Y,CONCAT448(X,
                                                  CONCAT444(X_01,CONCAT440(Y_01,CONCAT436(iVar9,
                                                  CONCAT432(uVar2,CONCAT1220(auStack156,
                                                                             CONCAT416(X_00,
                                                  CONCAT124(auStack172,Line2)))))))))))))) &
                               (undefined  [104])0xffffffffffffffff));
        }
      }
    }
    else {
      if ((0.00000000 <= fVar4) && (fVar4 <= 1.00000000)) {
        return '\x01';
      }
      if (0.00000000 <= fVar4) {
        X_02 = 0;
        fVar4 = (float)Line2->Thickness * 0.50000000 + fBloat;
        if (0.00000000 < fVar4) {
          local_70 = CONCAT11(0xc,uVar7);
          X_02 = (int)ROUND(fVar4);
          local_74 = X_02;
          local_6e = in_FPUControlWord;
        }
        BVar8 = IsPointInPad(X_01,Y_01,X_02,
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,CONCAT460(
                                                  local_74,CONCAT456(fVar1,CONCAT452(Y,CONCAT448(X,
                                                  CONCAT444(X_01,CONCAT440(Y_01,CONCAT436(iVar9,
                                                  CONCAT432(uVar2,CONCAT1220(auStack156,
                                                                             CONCAT416(X_00,
                                                  CONCAT124(auStack172,Line1)))))))))))))) &
                             (undefined  [104])0xffffffffffffffff));
      }
      else {
        X_02 = 0;
        fVar4 = (float)Line2->Thickness * 0.50000000 + fBloat;
        if (0.00000000 < fVar4) {
          local_70 = CONCAT11(0xc,uVar7);
          X_02 = (int)ROUND(fVar4);
          local_74 = X_02;
          local_6e = in_FPUControlWord;
        }
        BVar8 = IsPointInPad(X_00,Radius,X_02,
                             (PadTypePtr)
                             (CONCAT3668(p._0_36_,CONCAT266(local_6e,CONCAT264(local_70,CONCAT460(
                                                  local_74,CONCAT456(fVar1,CONCAT452(Y,CONCAT448(X,
                                                  CONCAT444(X_01,CONCAT440(Y_01,CONCAT436(iVar9,
                                                  CONCAT432(uVar2,CONCAT1220(auStack156,
                                                                             CONCAT416(X_00,
                                                  CONCAT124(auStack172,Line1)))))))))))))) &
                             (undefined  [104])0xffffffffffffffff));
      }
    }
  }
  return BVar8;
}



int LOCtoLineLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_LINE_TO_LIST(*(Cardinal *)cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOT_Linecallback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



Boolean LinePadIntersect(LineTypePtr Line,PadTypePtr *Pad)

{
  Boolean BVar1;
  
  BVar1 = LineLineIntersect(Line,(LineTypePtr)Pad);
  return BVar1;
}



int LOCtoLinePad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && (*(uint *)cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_PAD_TO_LIST(*(Cardinal *)cl,(PadTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOCtoPadPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && (*(uint *)cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineLineIntersect((LineTypePtr)b,(LineTypePtr)((int)cl + 0x5c));
    if (BVar1 != '\0') {
      BVar1 = ADD_PAD_TO_LIST(*(Cardinal *)cl,(PadTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOCtoPadLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)b,(LineTypePtr)((int)cl + 0x5c));
    if (BVar1 != '\0') {
      BVar1 = ADD_LINE_TO_LIST(*(Cardinal *)cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int LOT_Padcallback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if (((TheFlag & b[1].Y1) == 0) && (*(uint *)cl == (((uint)b[1].Y1 >> 7 ^ 1) & 1))) {
    BVar1 = LineLineIntersect((LineTypePtr)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



void InitLayoutLookup(void)

{
  size_t Number;
  PCBTypePtr pPVar1;
  void *pvVar2;
  Cardinal Number_00;
  Cardinal *pCVar3;
  int iVar4;
  uint uVar5;
  DataTypePtr *pDVar6;
  
  pDVar6 = PCB->Data;
  if (pDVar6->LayerN != 0) {
    iVar4 = 0;
    uVar5 = 0;
    do {
      Number = (&pDVar6->ViaN + uVar5 * 0x17)[0x14];
      if (Number == 0) {
        pCVar3 = &pDVar6->ViaN + uVar5 * 0x17;
        Number_00 = pCVar3[0x17];
        if (Number_00 != 0) goto LAB_080995ea;
LAB_08099518:
        pCVar3 = &pDVar6->ViaN + uVar5 * 0x17;
        Number = pCVar3[0x16];
      }
      else {
        pvVar2 = MyCalloc(Number,4,"InitLayoutLookup()");
        *(void **)((int)&LineList[0].Data + iVar4) = pvVar2;
        pCVar3 = &pDVar6->ViaN + uVar5 * 0x17;
        *(Cardinal *)((int)&LineList[0].Size + iVar4) = (&pDVar6->ViaN + uVar5 * 0x17)[0x14];
        Number_00 = pCVar3[0x17];
        if (Number_00 == 0) goto LAB_08099518;
LAB_080995ea:
        pvVar2 = MyCalloc(Number_00,4,"InitLayoutLookup()");
        *(void **)((int)&ArcList[0].Data + iVar4) = pvVar2;
        *(Cardinal *)((int)&ArcList[0].Size + iVar4) = pCVar3[0x17];
        pCVar3 = &pDVar6->ViaN + uVar5 * 0x17;
        Number = pCVar3[0x16];
      }
      if (Number != 0) {
        pvVar2 = MyCalloc(Number,4,"InitLayoutLookup()");
        *(void **)((int)&PolygonList[0].Data + iVar4) = pvVar2;
        *(Cardinal *)((int)&PolygonList[0].Size + iVar4) = pCVar3[0x16];
      }
      pPVar1 = PCB;
      uVar5 = uVar5 + 1;
      *(undefined4 *)((int)&LineList[0].Location + iVar4) = 0;
      *(undefined4 *)((int)&LineList[0].DrawLocation + iVar4) = 0;
      *(undefined4 *)((int)&LineList[0].Number + iVar4) = 0;
      pDVar6 = pPVar1->Data;
      *(undefined4 *)((int)&ArcList[0].Location + iVar4) = 0;
      *(undefined4 *)((int)&ArcList[0].DrawLocation + iVar4) = 0;
      *(undefined4 *)((int)&ArcList[0].Number + iVar4) = 0;
      *(undefined4 *)((int)&PolygonList[0].Location + iVar4) = 0;
      *(undefined4 *)((int)&PolygonList[0].DrawLocation + iVar4) = 0;
      *(undefined4 *)((int)&PolygonList[0].Number + iVar4) = 0;
      iVar4 = iVar4 + 0x14;
    } while (uVar5 <= (uint)pDVar6->LayerN && pDVar6->LayerN != uVar5);
  }
  if (pDVar6->pin_tree == (rtree_t *)0x0) {
    TotalP = 0;
  }
  else {
    TotalP = pDVar6->pin_tree->size;
  }
  if (pDVar6->via_tree == (rtree_t *)0x0) {
    TotalV = 0;
  }
  else {
    TotalV = pDVar6->via_tree->size;
  }
  PVList.Data = (void **)MyCalloc(TotalV + TotalP,4,"InitLayoutLookup()");
  PVList.Location = 0;
  PVList.DrawLocation = 0;
  PVList.Number = 0;
  PVList.Size = TotalV + TotalP;
  RatList.Data = (void **)MyCalloc(PCB->Data->RatN,4,"InitLayoutLookup()");
  RatList.Location = 0;
  RatList.DrawLocation = 0;
  RatList.Number = 0;
  RatList.Size = PCB->Data->RatN;
  return;
}



void InitComponentLookup(void)

{
  Cardinal CVar1;
  uint uVar2;
  Cardinal CVar3;
  uint uVar4;
  uint *puVar5;
  int local_20;
  
  NumberOfPads[0] = 0;
  NumberOfPads[1] = 0;
  CVar1 = PCB->Data->ElementN;
  local_20 = CVar1 - 1;
  CVar3 = 0;
  if (local_20 != -1) {
    NumberOfPads[1] = 0;
    puVar5 = &PCB->Data->Element[CVar1 - 1].PadN;
    do {
      if (*puVar5 != 0) {
        uVar2 = puVar5[7];
        uVar4 = 0;
        do {
          if (*(char *)(uVar2 + 0x14) < '\0') {
            CVar3 = CVar3 + 1;
          }
          else {
            NumberOfPads[1] = NumberOfPads[1] + 1;
          }
          uVar4 = uVar4 + 1;
          uVar2 = uVar2 + 0x68;
        } while (uVar4 < *puVar5);
      }
      local_20 = local_20 + -1;
      puVar5 = puVar5 + -0x4b;
      NumberOfPads[0] = CVar3;
    } while (local_20 != -1);
  }
  PadList[0].Data = (void **)MyCalloc(NumberOfPads[0],4,"InitComponentLookup()");
  PadList[0].Location = 0;
  PadList[0].DrawLocation = 0;
  PadList[0].Number = 0;
  PadList[0].Size = NumberOfPads[0];
  PadList[1].Data = (void **)MyCalloc(NumberOfPads[1],4,"InitComponentLookup()");
  PadList[1].Location = 0;
  PadList[1].DrawLocation = 0;
  PadList[1].Number = 0;
  PadList[1].Size = NumberOfPads[1];
  return;
}



void InitConnectionLookup(void)

{
  InitComponentLookup();
  InitLayoutLookup();
  return;
}



void FreeComponentLookupMemory(void)

{
  SaveFree(PadList[0].Data);
  PadList[0].Data = (void **)0x0;
  SaveFree(PadList[1].Data);
  PadList[1].Data = (void **)0x0;
  return;
}



void FreeLayoutLookupMemory(void)

{
  uint *puVar1;
  void *Ptr;
  PCBTypePtr pPVar2;
  int iVar3;
  uint uVar4;
  
  if (PCB->Data->LayerN != 0) {
    iVar3 = 0;
    uVar4 = 0;
    do {
      uVar4 = uVar4 + 1;
      SaveFree(*(void **)((int)&LineList[0].Data + iVar3));
      Ptr = *(void **)((int)&ArcList[0].Data + iVar3);
      *(undefined4 *)((int)&LineList[0].Data + iVar3) = 0;
      SaveFree(Ptr);
      Ptr = *(void **)((int)&PolygonList[0].Data + iVar3);
      *(undefined4 *)((int)&ArcList[0].Data + iVar3) = 0;
      SaveFree(Ptr);
      pPVar2 = PCB;
      *(undefined4 *)((int)&PolygonList[0].Data + iVar3) = 0;
      iVar3 = iVar3 + 0x14;
      puVar1 = (uint *)&pPVar2->Data->LayerN;
    } while (uVar4 <= *puVar1 && *puVar1 != uVar4);
  }
  SaveFree(PVList.Data);
  PVList.Data = (void **)0x0;
  SaveFree(RatList.Data);
  RatList.Data = (void **)0x0;
  return;
}



void FreeConnectionLookupMemory(void)

{
  FreeComponentLookupMemory();
  FreeLayoutLookupMemory();
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

Boolean PinLineIntersect(PinTypePtr *PV,LineTypePtr Line)

{
  float fVar1;
  Boolean BVar2;
  int Radius;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined2 in_FPUControlWord;
  undefined4 unaff_retaddr;
  undefined in_stack_0000000c [44];
  undefined4 local_2c;
  undefined in_stack_ffffffd8 [20];
  int local_14;
  undefined2 local_10;
  undefined2 local_e;
  
  if ((*(byte *)((int)&(PV->Flags).f + 1) & 1) != 0) {
    Radius = (PV->Thickness + 1) / 2;
    BVar2 = IsLineInRectangle(-Radius + PV->X,-Radius + PV->Y,Radius + PV->X,Radius + PV->Y,Line);
    return BVar2;
  }
  Radius = 0;
  fVar1 = (float)PV->Thickness * 0.50000000 + fBloat;
  if (0.00000000 < fVar1) {
    local_10 = CONCAT11(0xc,(char)in_FPUControlWord);
    Radius = (int)ROUND(fVar1);
    local_14 = Radius;
    local_e = in_FPUControlWord;
  }
  BVar2 = IsPointInPad(PV->X,PV->Y,Radius,
                       (PadTypePtr)
                       CONCAT5648(CONCAT4412(in_stack_0000000c,
                                             CONCAT48(Line,CONCAT44(PV,unaff_retaddr))),
                                  CONCAT444(unaff_EBP,
                                            CONCAT440(unaff_ESI,
                                                      CONCAT436(unaff_EBX,
                                                                CONCAT234(local_e,CONCAT232(local_10
                                                  ,CONCAT428(local_14,CONCAT208(in_stack_ffffffd8,
                                                                                CONCAT44(local_2c,
                                                  Line))))))))));
  return BVar2;
}



int LOCtoPVline_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr *)((int)cl + 4),(LineTypePtr)b);
    if (BVar1 != '\0') {
      BVar1 = ADD_LINE_TO_LIST(*(Cardinal *)cl,(LineTypePtr)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x50,1);
      }
    }
  }
  return 0;
}



int pv_line_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr *)b,(LineTypePtr)((int)cl + 4));
    if (BVar1 != '\0') {
      if ((b[1].Y1 & 8U) != 0) {
        b[1].Y1 = b[1].Y1 | 0x200;
        Settings.RatWarn = '\x01';
        Message("WARNING: Hole too close to line.\n");
      }
      BVar1 = ADD_PV_TO_LIST((PinTypePtr *)b);
      if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1a0,1);
      }
    }
  }
  return 0;
}



int pv_touch_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((b[1].Y1 & TheFlag) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr *)b,(LineTypePtr)((int)cl + 4));
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x1a0,1);
    }
  }
  return 0;
}



DrcViolationType * __regparm3
pcb_drc_violation_new
          (char *title,char *explanation,int x,int y,int have_measured,double measured_value,
          double required_value,int value_digits,char *value_units,int object_count,
          long *object_id_list,int *object_type_list)

{
  DrcViolationType *pDVar1;
  char *pcVar2;
  
  pDVar1 = (DrcViolationType *)calloc(1,0x3c);
  pcVar2 = (char *)__strdup(title);
  pDVar1->title = pcVar2;
  pcVar2 = (char *)__strdup(explanation);
  pDVar1->angle = 0;
  pDVar1->x = x;
  pDVar1->explanation = pcVar2;
  pDVar1->measured_value = measured_value;
  pDVar1->y = y;
  pDVar1->required_value = required_value;
  pDVar1->have_measured = have_measured;
  pDVar1->value_digits = value_digits;
  pDVar1->value_units = value_units;
  pDVar1->object_count = object_count;
  pDVar1->object_id_list = object_id_list;
  pDVar1->object_type_list = object_type_list;
  return pDVar1;
}



int drc_callback(DataTypePtr *data,LayerTypePtr layer,PolygonTypePtr polygon,int type,void *ptr1,
                void *ptr2)

{
  float fVar1;
  Boolean BVar2;
  char *value_units;
  DrcViolationType *violation;
  int value_digits;
  char *local_40;
  int *local_30;
  long *local_2c;
  int local_28;
  LocationType local_24;
  LocationType local_20 [4];
  
  thing_type = type;
  thing_ptr1 = ptr1;
  thing_ptr2 = ptr2;
  thing_ptr3 = ptr2;
  if (type == 0x100) {
    if (SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
        *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) {
      AddObjectToFlagUndoList(0x100,ptr1,ptr2,ptr2);
      *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
      local_40 = "Pin with insufficient clearance inside polygon\n";
      goto doIsBad;
    }
  }
  else {
    if (type < 0x101) {
      if (type == 1) {
        value_digits = *(int *)((int)ptr2 + 0x28);
        if ((value_digits != 0) &&
           (SBORROW4(value_digits,PCB->Bloat * 2) != value_digits + PCB->Bloat * -2 < 0)) {
          AddObjectToFlagUndoList(1,ptr1,ptr2,ptr2);
          *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
          local_40 = "Via with insufficient clearance inside polygon\n";
          goto doIsBad;
        }
      }
      else {
        if (type != 4) goto LAB_08099cc2;
        if (SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
            *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) {
          AddObjectToFlagUndoList(4,ptr1,ptr2,ptr2);
          *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
          local_40 = "Line with insufficient clearance inside polygon\n";
          goto doIsBad;
        }
      }
    }
    else {
      if (type == 0x200) {
        if ((SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
             *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) &&
           (BVar2 = IsLineInPolygon((LineTypePtr)ptr2,polygon), BVar2 != '\0')) {
          AddObjectToFlagUndoList(0x200,ptr1,ptr2,ptr2);
          *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
          local_40 = "Pad with insufficient clearance inside polygon\n";
doIsBad:
          AddObjectToFlagUndoList(8,layer,polygon,polygon);
          (polygon->Flags).f = (polygon->Flags).f | 4;
          DrawPolygon(layer,polygon,0);
          DrawObject(type,ptr1,ptr2,0);
          drcerr_count = drcerr_count + 1;
          LocateError(local_20,&local_24);
          BuildObjectList(&local_28,&local_2c,&local_30);
          if (Settings.grid_units_mm == '\0') {
            value_digits = 2;
            value_units = "mils";
            fVar1 = (float)PCB->Bloat / 100.00000000;
          }
          else {
            value_digits = 4;
            value_units = "mm";
            fVar1 = ((float)PCB->Bloat / 100000.00000000) * 25.39999962;
          }
          violation = pcb_drc_violation_new
                                (local_40,
                                 "Circuits that are too close may bridge during imaging, etching,\nplating, or soldering processes resulting in a direct short."
                                 ,local_20[0],local_24,0,0.00000000,(double)fVar1,value_digits,
                                 value_units,local_28,local_2c,local_30);
          append_drc_violation(violation);
          pcb_drc_violation_free(violation);
          free(local_2c);
          free(local_30);
          value_digits = throw_drc_dialog();
          if (value_digits != 0) {
            IncrementUndoSerialNumber();
            Undo('\x01');
            return 0;
          }
          IsBad = '\x01';
          return 1;
        }
      }
      else {
        if (type != 0x4000) {
LAB_08099cc2:
          Message("hace: Bad Plow object in callback\n");
          return 0;
        }
        if (SBORROW4(*(int *)((int)ptr2 + 0x28),PCB->Bloat * 2) !=
            *(int *)((int)ptr2 + 0x28) + PCB->Bloat * -2 < 0) {
          AddObjectToFlagUndoList(0x4000,ptr1,ptr2,ptr2);
          *(uint *)((int)ptr2 + 0x14) = *(uint *)((int)ptr2 + 0x14) | TheFlag;
          local_40 = "Arc with insufficient clearance inside polygon\n";
          goto doIsBad;
        }
      }
    }
  }
  return 0;
}



Boolean __regparm3 LookupLOConnectionsToRatEnd(PointTypePtr Point,Cardinal LayerGroup)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint local_d0;
  rat_info info;
  BoxType box;
  
  if ((&(PCB->Flags).f)[LayerGroup + 0x734] != 0) {
    local_d0 = 0;
    info.Point = Point;
    do {
      uVar2 = (&(PCB->Flags).f)[local_d0 + 0x744 + LayerGroup * 0x12];
      uVar3 = PCB->Data->LayerN;
      if (uVar2 < uVar3) {
        info.layer = uVar2;
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 != 0) {
          return '\x01';
        }
        box.X1 = Point->X + -1;
        box.X2 = Point->X + 1;
        box.Y1 = Point->Y + -1;
        box.Y2 = Point->Y + 1;
        r_search(*(rtree_t **)(&PCB->Data->field_0x80 + uVar2 * 0x5c),&box,
                 (anon_subr_int_BoxType_ptr_void_ptr *)0x0,LOCtoRat_callback,&info);
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 == 0) {
          box.X1 = Point->X + -1;
          box.X2 = Point->X + 1;
          box.Y1 = Point->Y + -1;
          box.Y2 = Point->Y + 1;
          r_search(*(rtree_t **)(&PCB->Data->field_0x88 + uVar2 * 0x5c),&box,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,PolygonToRat_callback,&info);
        }
      }
      else {
        info.layer = uVar2 - uVar3;
        iVar4 = _setjmp((__jmp_buf_tag *)info.env);
        if (iVar4 != 0) {
          return '\x01';
        }
        box.X1 = Point->X + -1;
        box.X2 = Point->X + 1;
        box.Y1 = Point->Y + -1;
        box.Y2 = Point->Y + 1;
        r_search(PCB->Data->pad_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 LOCtoPad_callback,&info);
      }
      local_d0 = local_d0 + 1;
      puVar1 = &(PCB->Flags).f + LayerGroup + 0x734;
    } while (local_d0 <= *puVar1 && *puVar1 != local_d0);
  }
  return '\0';
}



Boolean __regparm3 LookupPVConnectionsToLOList(Boolean AndRats)

{
  uint *puVar1;
  int iVar2;
  int *piVar3;
  Boolean BVar4;
  uint uVar5;
  int iVar6;
  Cardinal CVar7;
  Cardinal CVar8;
  LocationType *pLVar9;
  LineType *pLVar10;
  PadType *pPVar11;
  ArcType *pAVar12;
  RatType *pRVar13;
  int in_GS_OFFSET;
  byte bVar14;
  int local_278;
  uint local_274;
  int local_270;
  BoxType box;
  lo_info info;
  
  bVar14 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  CVar7 = TotalV;
  CVar8 = TotalP;
  if (PCB->Data->LayerN != 0) {
    local_270 = 0;
    local_274 = 0;
    do {
      if (CVar8 + CVar7 == 0) {
        *(undefined4 *)((int)&LineList[0].Location + local_270) =
             *(undefined4 *)((int)&LineList[0].Number + local_270);
        *(undefined4 *)((int)&ArcList[0].Location + local_270) =
             *(undefined4 *)((int)&ArcList[0].Number + local_270);
        *(undefined4 *)((int)&PolygonList[0].Location + local_270) =
             *(undefined4 *)((int)&PolygonList[0].Number + local_270);
      }
      else {
        uVar5 = *(uint *)((int)&LineList[0].Location + local_270);
        if (uVar5 < *(uint *)((int)&LineList[0].Number + local_270)) {
          do {
            iVar6 = 0x16;
            pLVar9 = *(LocationType **)(*(int *)((int)&LineList[0].Data + local_270) + uVar5 * 4);
            pLVar10 = &info.line;
            while (iVar6 != 0) {
              iVar6 = iVar6 + -1;
              (pLVar10->BoundingBox).X1 = *pLVar9;
              pLVar9 = pLVar9 + (uint)bVar14 * 0x3ffffffe + 1;
              pLVar10 = (LineType *)((int)pLVar10 + (uint)bVar14 * -8 + 4);
            }
            if (0 < Bloat) {
              info.line.BoundingBox.X1 = info.line.BoundingBox.X1 - Bloat;
              info.line.BoundingBox.X2 = info.line.BoundingBox.X2 + Bloat;
              info.line.BoundingBox.Y1 = info.line.BoundingBox.Y1 - Bloat;
              info.line.BoundingBox.Y2 = info.line.BoundingBox.Y2 + Bloat;
            }
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->via_tree,(BoxType *)&info.line,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_line_callback,&info);
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->pin_tree,(BoxType *)&info.line,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_line_callback,&info);
            uVar5 = *(int *)((int)&LineList[0].Location + local_270) + 1;
            puVar1 = (uint *)((int)&LineList[0].Number + local_270);
            *(uint *)((int)&LineList[0].Location + local_270) = uVar5;
          } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        }
        uVar5 = *(uint *)((int)&ArcList[0].Location + local_270);
        if (uVar5 < *(uint *)((int)&ArcList[0].Number + local_270)) {
          do {
            iVar6 = 0x11;
            pLVar9 = *(LocationType **)(*(int *)((int)&ArcList[0].Data + local_270) + uVar5 * 4);
            pAVar12 = &info.arc;
            while (iVar6 != 0) {
              iVar6 = iVar6 + -1;
              (pAVar12->BoundingBox).X1 = *pLVar9;
              pLVar9 = pLVar9 + (uint)bVar14 * 0x3ffffffe + 1;
              pAVar12 = (ArcType *)((int)pAVar12 + (uint)bVar14 * -8 + 4);
            }
            if (0 < Bloat) {
              info.arc.BoundingBox.X1 = info.arc.BoundingBox.X1 - Bloat;
              info.arc.BoundingBox.X2 = info.arc.BoundingBox.X2 + Bloat;
              info.arc.BoundingBox.Y1 = info.arc.BoundingBox.Y1 - Bloat;
              info.arc.BoundingBox.Y2 = info.arc.BoundingBox.Y2 + Bloat;
            }
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->via_tree,(BoxType *)&info.arc,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_arc_callback,&info);
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->pin_tree,(BoxType *)&info.arc,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_arc_callback,&info);
            uVar5 = *(int *)((int)&ArcList[0].Location + local_270) + 1;
            puVar1 = (uint *)((int)&ArcList[0].Number + local_270);
            *(uint *)((int)&ArcList[0].Location + local_270) = uVar5;
          } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        }
        uVar5 = *(uint *)((int)&PolygonList[0].Location + local_270);
        info.layer = local_274;
        CVar7 = TotalV;
        CVar8 = TotalP;
        if (uVar5 < *(uint *)((int)&PolygonList[0].Number + local_270)) {
          do {
            piVar3 = *(int **)(*(int *)((int)&PolygonList[0].Data + local_270) + uVar5 * 4);
            info.polygon.BoundingBox.X1 = *piVar3;
            info.polygon.BoundingBox.Y1 = piVar3[1];
            info.polygon.BoundingBox.X2 = piVar3[2];
            info.polygon.BoundingBox.Y2 = piVar3[3];
            info.polygon.ID = piVar3[4];
            info.polygon.Flags.f = piVar3[5];
            info.polygon.Flags.t._0_4_ = piVar3[6];
            info.polygon.Flags.t._4_4_ = piVar3[7];
            info.polygon.net = (LibraryEntryType *)piVar3[8];
            info.polygon.PointN = piVar3[9];
            info.polygon.PointMax = piVar3[10];
            info.polygon.Clipped = (POLYAREA *)piVar3[0xb];
            info.polygon.NoHoles = (PLINE *)piVar3[0xc];
            info.polygon.NoHolesValid = piVar3[0xd];
            info.polygon.Points = (PointTypePtr)piVar3[0xe];
            if (0 < Bloat) {
              info.polygon.BoundingBox.X1 = info.polygon.BoundingBox.X1 - Bloat;
              info.polygon.BoundingBox.X2 = info.polygon.BoundingBox.X2 + Bloat;
              info.polygon.BoundingBox.Y1 = info.polygon.BoundingBox.Y1 - Bloat;
              info.polygon.BoundingBox.Y2 = info.polygon.BoundingBox.Y2 + Bloat;
            }
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->via_tree,(BoxType *)&info.polygon,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_poly_callback,&info);
            iVar6 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar6 != 0) goto LAB_0809a3c8;
            r_search(PCB->Data->pin_tree,(BoxType *)&info.polygon,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_poly_callback,&info);
            uVar5 = *(int *)((int)&PolygonList[0].Location + local_270) + 1;
            puVar1 = (uint *)((int)&PolygonList[0].Number + local_270);
            *(uint *)((int)&PolygonList[0].Location + local_270) = uVar5;
            CVar7 = TotalV;
            CVar8 = TotalP;
          } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        }
      }
      local_274 = local_274 + 1;
      local_270 = local_270 + 0x14;
      puVar1 = (uint *)&PCB->Data->LayerN;
    } while (local_274 <= *puVar1 && *puVar1 != local_274);
  }
  local_278 = 0;
  do {
    iVar6 = CVar8 + CVar7;
    if (iVar6 == 0) {
      *(undefined4 *)((int)&PadList[0].Location + local_278) =
           *(undefined4 *)((int)&PadList[0].Number + local_278);
    }
    else {
      uVar5 = *(uint *)((int)&PadList[0].Location + local_278);
      if (uVar5 < *(uint *)((int)&PadList[0].Number + local_278)) {
        do {
          iVar6 = 0x1a;
          pLVar9 = *(LocationType **)(*(int *)((int)&PadList[0].Data + local_278) + uVar5 * 4);
          pPVar11 = &info.pad;
          while (iVar6 != 0) {
            iVar6 = iVar6 + -1;
            (pPVar11->BoundingBox).X1 = *pLVar9;
            pLVar9 = pLVar9 + (uint)bVar14 * 0x3ffffffe + 1;
            pPVar11 = (PadType *)((int)pPVar11 + (uint)bVar14 * -8 + 4);
          }
          if (0 < Bloat) {
            info.pad.BoundingBox.X1 = info.pad.BoundingBox.X1 - Bloat;
            info.pad.BoundingBox.X2 = info.pad.BoundingBox.X2 + Bloat;
            info.pad.BoundingBox.Y1 = info.pad.BoundingBox.Y1 - Bloat;
            info.pad.BoundingBox.Y2 = info.pad.BoundingBox.Y2 + Bloat;
          }
          iVar6 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar6 != 0) goto LAB_0809a3c8;
          r_search(PCB->Data->via_tree,(BoxType *)&info.pad,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_pad_callback,&info);
          iVar6 = _setjmp((__jmp_buf_tag *)info.env);
          if (iVar6 != 0) goto LAB_0809a3c8;
          r_search(PCB->Data->pin_tree,(BoxType *)&info.pad,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_pad_callback,&info);
          uVar5 = *(int *)((int)&PadList[0].Location + local_278) + 1;
          puVar1 = (uint *)((int)&PadList[0].Number + local_278);
          *(uint *)((int)&PadList[0].Location + local_278) = uVar5;
        } while (uVar5 <= *puVar1 && *puVar1 != uVar5);
        iVar6 = TotalV + TotalP;
        CVar7 = TotalV;
        CVar8 = TotalP;
      }
    }
    local_278 = local_278 + 0x14;
  } while (local_278 != 0x28);
  if (iVar6 == 0) {
    RatList.Location = RatList.Number;
  }
  if ((AndRats != '\0') && (RatList.Location < RatList.Number)) {
    do {
      iVar6 = 0x17;
      pLVar9 = (LocationType *)RatList.Data[RatList.Location];
      pRVar13 = &info.rat;
      while (iVar6 != 0) {
        iVar6 = iVar6 + -1;
        (pRVar13->BoundingBox).X1 = *pLVar9;
        pLVar9 = pLVar9 + (uint)bVar14 * 0x3ffffffe + 1;
        pRVar13 = (RatType *)((int)pRVar13 + (uint)bVar14 * -8 + 4);
      }
      box.X1 = info.rat.Point1.X + -1;
      box.X2 = info.rat.Point1.X + 1;
      box.Y1 = info.rat.Point1.Y + -1;
      box.Y2 = info.rat.Point1.Y + 1;
      r_search(PCB->Data->via_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,
               &info);
      box.X1 = info.rat.Point2.X + -1;
      box.X2 = info.rat.Point2.X + 1;
      box.Y1 = info.rat.Point2.Y + -1;
      box.Y2 = info.rat.Point2.Y + 1;
      r_search(PCB->Data->via_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,
               &info);
      box.X1 = info.rat.Point1.X + -1;
      box.X2 = info.rat.Point1.X + 1;
      box.Y1 = info.rat.Point1.Y + -1;
      box.Y2 = info.rat.Point1.Y + 1;
      r_search(PCB->Data->pin_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,
               &info);
      box.X1 = info.rat.Point2.X + -1;
      box.X2 = info.rat.Point2.X + 1;
      box.Y1 = info.rat.Point2.Y + -1;
      box.Y2 = info.rat.Point2.Y + 1;
      r_search(PCB->Data->pin_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pv_rat_callback,
               &info);
      RatList.Location = RatList.Location + 1;
    } while (RatList.Location < RatList.Number);
  }
  BVar4 = '\0';
LAB_0809a3cd:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar4;
LAB_0809a3c8:
  BVar4 = '\x01';
  goto LAB_0809a3cd;
}



Boolean __regparm3 DoIt(Boolean AndRats,Boolean AndDraw)

{
  Cardinal *pCVar1;
  LineTypePtr *ppLVar2;
  ArcTypePtr **ppAVar3;
  PolygonTypePtr *pppVar4;
  PadTypePtr **ppPVar5;
  RatTypePtr **ppRVar6;
  PinTypePtr *Pin;
  char cVar7;
  Boolean BVar8;
  int iVar9;
  PCBTypePtr pPVar10;
  int iVar11;
  DataTypePtr *pDVar12;
  uint uVar13;
  uint uVar14;
  Cardinal LayerGroup;
  uint *puVar15;
  int iVar16;
  Cardinal CVar17;
  bool bVar18;
  int *local_fc;
  int local_f8;
  uint local_f4;
  uint local_f0;
  Cardinal arcposition [16];
  Cardinal polyposition [16];
  Cardinal lineposition [16];
  Cardinal padposition [2];
  
LAB_0809aaf8:
  cVar7 = LookupPVConnectionsToPVList();
  if ((cVar7 == '\0') && (cVar7 = LookupLOConnectionsToPVList(AndRats), cVar7 == '\0')) {
    iVar16 = PCB->Data->LayerN;
    if (iVar16 != 0) {
      iVar11 = 0;
      iVar9 = 0;
      do {
        lineposition[iVar9] = *(Cardinal *)((int)&LineList[0].Location + iVar11);
        polyposition[iVar9] = *(Cardinal *)((int)&PolygonList[0].Location + iVar11);
        pCVar1 = (Cardinal *)((int)&ArcList[0].Location + iVar11);
        iVar11 = iVar11 + 0x14;
        arcposition[iVar9] = *pCVar1;
        iVar9 = iVar9 + 1;
      } while (iVar9 != iVar16);
    }
    padposition[0] = PadList[0].Location;
    padposition[1] = PadList[1].Location;
    pPVar10 = PCB;
    CVar17 = RatList.Location;
    do {
      if ((AndRats != '\0') && (CVar17 < RatList.Number)) {
        iVar16 = CVar17 * 4;
        do {
          BVar8 = LookupLOConnectionsToRatEnd
                            ((PointTypePtr)(*(int *)((int)RatList.Data + iVar16) + 0x2c),
                             *(Cardinal *)(*(int *)((int)RatList.Data + iVar16) + 0x54));
          if ((BVar8 != '\0') ||
             (BVar8 = LookupLOConnectionsToRatEnd
                                ((PointTypePtr)(*(int *)((int)RatList.Data + iVar16) + 0x40),
                                 *(Cardinal *)(*(int *)((int)RatList.Data + iVar16) + 0x58)),
             BVar8 != '\0')) goto LAB_0809b090;
          CVar17 = CVar17 + 1;
          iVar16 = iVar16 + 4;
          pPVar10 = PCB;
        } while (CVar17 < RatList.Number);
      }
      uVar14 = pPVar10->Data->LayerN;
      if (uVar14 == 0) {
        local_f4 = 0;
      }
      else {
        LayerGroup = 0;
        do {
          if ((&(pPVar10->Flags).f)[LayerGroup + 0x734] != 0) {
            local_f0 = 0;
            while( true ) {
              uVar13 = (&(pPVar10->Flags).f)[local_f0 + 0x744 + LayerGroup * 0x12];
              if (uVar13 < uVar14) {
                puVar15 = lineposition + uVar13;
                uVar14 = *puVar15;
                if (uVar14 < LineList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToLine
                                      ((LineTypePtr)LineList[uVar13].Data[uVar14],LayerGroup,'\x01')
                    ;
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar15 + 1;
                    *puVar15 = uVar14;
                  } while (uVar14 < LineList[uVar13].Number);
                }
                puVar15 = arcposition + uVar13;
                uVar14 = *puVar15;
                if (uVar14 < ArcList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToArc
                                      ((ArcTypePtr *)ArcList[uVar13].Data[uVar14],LayerGroup);
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar15 + 1;
                    *puVar15 = uVar14;
                  } while (uVar14 < ArcList[uVar13].Number);
                }
                puVar15 = polyposition + uVar13;
                uVar14 = *puVar15;
                pPVar10 = PCB;
                if (uVar14 < PolygonList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToPolygon
                                      ((PolygonTypePtr)PolygonList[uVar13].Data[uVar14],LayerGroup);
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar15 + 1;
                    *puVar15 = uVar14;
                    pPVar10 = PCB;
                  } while (uVar14 < PolygonList[uVar13].Number);
                }
              }
              else {
                uVar13 = uVar13 - uVar14;
                if (1 < uVar13) {
                  Message("bad layer number %d max_layer=%d in find.c\n",uVar13,uVar14);
                  goto LAB_0809b37f;
                }
                puVar15 = padposition + uVar13;
                uVar14 = *puVar15;
                if (uVar14 < PadList[uVar13].Number) {
                  do {
                    BVar8 = LookupLOConnectionsToPad
                                      ((PadTypePtr *)PadList[uVar13].Data[uVar14],LayerGroup);
                    if (BVar8 != '\0') goto LAB_0809b090;
                    uVar14 = *puVar15 + 1;
                    *puVar15 = uVar14;
                    pPVar10 = PCB;
                  } while (uVar14 < PadList[uVar13].Number);
                }
              }
              local_f0 = local_f0 + 1;
              if ((&(pPVar10->Flags).f)[LayerGroup + 0x734] <= local_f0) break;
              uVar14 = pPVar10->Data->LayerN;
            }
            uVar14 = pPVar10->Data->LayerN;
          }
          LayerGroup = LayerGroup + 1;
          local_f4 = uVar14;
        } while (LayerGroup < uVar14);
      }
      bVar18 = AndRats == '\0' || RatList.Number <= CVar17;
      if (uVar14 != 0xfffffffe) {
        iVar16 = 0;
        puVar15 = padposition + local_f4 * 0x3fffffff;
        uVar13 = 0;
        do {
          if (uVar13 < local_f4) {
            if (bVar18) {
              if ((lineposition[uVar13] < *(uint *)((int)&LineList[0].Number + iVar16)) ||
                 (arcposition[uVar13] < *(uint *)((int)&ArcList[0].Number + iVar16))) {
                bVar18 = false;
              }
              else {
                bVar18 = *(uint *)((int)&PolygonList[0].Number + iVar16) <= polyposition[uVar13];
              }
            }
          }
          else {
            if (bVar18) {
              bVar18 = *(uint *)(local_f4 * -0x14 + 0x816c6cc + iVar16) <= *puVar15;
            }
          }
          uVar13 = uVar13 + 1;
          puVar15 = puVar15 + 1;
          iVar16 = iVar16 + 0x14;
        } while (uVar13 < uVar14 + 2);
      }
    } while (!bVar18);
LAB_0809b37f:
    cVar7 = LookupPVConnectionsToLOList(AndRats);
  }
  goto LAB_0809ab0b;
LAB_0809b090:
  cVar7 = '\x01';
LAB_0809ab0b:
  CVar17 = RatList.DrawLocation;
  if (AndDraw != '\0') {
    pDVar12 = PCB->Data;
    local_f8 = pDVar12->LayerN + -1;
    pPVar10 = PCB;
    if (local_f8 != -1) {
      local_fc = LayerStack + local_f8;
      while( true ) {
        iVar16 = *local_fc;
        if (*(char *)(&pDVar12->field_0x90 + iVar16 * 0x5c) != '\0') {
          uVar14 = LineList[iVar16].Number;
          uVar13 = LineList[iVar16].DrawLocation;
          if (uVar13 < uVar14) {
            iVar9 = uVar13 * 4;
            while( true ) {
              uVar13 = uVar13 + 1;
              ppLVar2 = (LineTypePtr *)((int)LineList[iVar16].Data + iVar9);
              iVar9 = iVar9 + 4;
              DrawLine((LayerTypePtr)(&pDVar12->field_0x4c + iVar16 * 0x5c),*ppLVar2,0);
              uVar14 = LineList[iVar16].Number;
              pPVar10 = PCB;
              if (uVar14 <= uVar13) break;
              pDVar12 = PCB->Data;
            }
          }
          LineList[iVar16].DrawLocation = uVar14;
          uVar14 = ArcList[iVar16].DrawLocation;
          uVar13 = ArcList[iVar16].Number;
          if (uVar14 < uVar13) {
            iVar9 = uVar14 * 4;
            do {
              uVar14 = uVar14 + 1;
              ppAVar3 = (ArcTypePtr **)((int)ArcList[iVar16].Data + iVar9);
              iVar9 = iVar9 + 4;
              DrawArc((LayerTypePtr)(&pPVar10->Data->field_0x4c + iVar16 * 0x5c),*ppAVar3,0);
              uVar13 = ArcList[iVar16].Number;
              pPVar10 = PCB;
            } while (uVar14 < uVar13);
          }
          uVar14 = PolygonList[iVar16].DrawLocation;
          ArcList[iVar16].DrawLocation = uVar13;
          uVar13 = PolygonList[iVar16].Number;
          if (uVar14 < uVar13) {
            iVar9 = uVar14 * 4;
            do {
              uVar14 = uVar14 + 1;
              pppVar4 = (PolygonTypePtr *)((int)PolygonList[iVar16].Data + iVar9);
              iVar9 = iVar9 + 4;
              DrawPolygon((LayerTypePtr)(&pPVar10->Data->field_0x4c + iVar16 * 0x5c),*pppVar4,0);
              uVar13 = PolygonList[iVar16].Number;
              pPVar10 = PCB;
            } while (uVar14 < uVar13);
          }
          PolygonList[iVar16].DrawLocation = uVar13;
        }
        local_f8 = local_f8 + -1;
        local_fc = local_fc + -1;
        if (local_f8 == -1) break;
        pDVar12 = pPVar10->Data;
      }
    }
    iVar16 = 0;
    if (pPVar10->PinOn == '\0') {
      if (PVList.DrawLocation < PVList.Number) {
LAB_0809ae93:
        do {
          Pin = (PinTypePtr *)PVList.Data[PVList.DrawLocation];
          if ((*(byte *)&(Pin->Flags).f & 1) == 0) {
            if (pPVar10->ViaOn != '\0') {
              DrawVia(Pin,0);
              pPVar10 = PCB;
            }
          }
          else {
            if (pPVar10->PinOn != '\0') {
              DrawPin(Pin,0);
              pPVar10 = PCB;
            }
          }
          PVList.DrawLocation = PVList.DrawLocation + 1;
        } while (PVList.DrawLocation < PVList.Number);
      }
    }
    else {
      do {
        uVar14 = *(uint *)((int)&PadList[0].DrawLocation + iVar16);
        uVar13 = *(uint *)((int)&PadList[0].Number + iVar16);
        if (uVar14 < uVar13) {
          iVar9 = uVar14 * 4;
          do {
            uVar14 = uVar14 + 1;
            ppPVar5 = (PadTypePtr **)(*(int *)((int)&PadList[0].Data + iVar16) + iVar9);
            iVar9 = iVar9 + 4;
            DrawPad(*ppPVar5,0);
            uVar13 = *(uint *)((int)&PadList[0].Number + iVar16);
          } while (uVar14 < uVar13);
        }
        *(uint *)((int)&PadList[0].DrawLocation + iVar16) = uVar13;
        iVar16 = iVar16 + 0x14;
      } while (iVar16 != 0x28);
      pPVar10 = PCB;
      if (PVList.DrawLocation < PVList.Number) goto LAB_0809ae93;
    }
    CVar17 = RatList.DrawLocation;
    if ((pPVar10->RatOn != '\0') && (CVar17 = RatList.Number, RatList.DrawLocation < RatList.Number)
       ) {
      iVar16 = RatList.DrawLocation * 4;
      LayerGroup = RatList.DrawLocation;
      do {
        LayerGroup = LayerGroup + 1;
        ppRVar6 = (RatTypePtr **)((int)RatList.Data + iVar16);
        iVar16 = iVar16 + 4;
        DrawRat(*ppRVar6,0);
        CVar17 = RatList.Number;
      } while (LayerGroup < RatList.Number);
    }
  }
  RatList.DrawLocation = CVar17;
  if (cVar7 != '\0') goto LAB_0809ab99;
  bVar18 = PVList.Number <= PVList.Location;
  if (AndRats == '\0') {
    iVar16 = PCB->Data->LayerN;
    if (!bVar18 || iVar16 < 1) {
LAB_0809abf9:
      if (bVar18) {
LAB_0809ab99:
        if (AndDraw != '\0') {
          Draw();
        }
        return (Boolean)cVar7;
      }
      goto LAB_0809aaf8;
    }
  }
  else {
    if ((!bVar18) || (RatList.Location < RatList.Number)) goto LAB_0809aaf8;
    bVar18 = true;
    iVar16 = PCB->Data->LayerN;
    if (iVar16 < 1) goto LAB_0809abf9;
  }
  iVar9 = 0;
  iVar11 = 0;
  while (((*(uint *)((int)&LineList[0].Number + iVar9) <=
           *(uint *)((int)&LineList[0].Location + iVar9) &&
          (*(uint *)((int)&ArcList[0].Number + iVar9) <=
           *(uint *)((int)&ArcList[0].Location + iVar9))) &&
         (*(uint *)((int)&PolygonList[0].Number + iVar9) <=
          *(uint *)((int)&PolygonList[0].Location + iVar9)))) {
    iVar11 = iVar11 + 1;
    iVar9 = iVar9 + 0x14;
    if (iVar16 <= iVar11) goto LAB_0809ab99;
  }
  goto LAB_0809aaf8;
}



Boolean __regparm3 DRCFind(int What,void *ptr1,void *ptr2,void *ptr3)

{
  float fVar1;
  Boolean BVar2;
  int value_digits;
  DrcViolationType *violation;
  char *value_units;
  int *local_30;
  long *local_2c;
  int local_28;
  LocationType local_24;
  LocationType local_20 [4];
  
  if (PCB->Shrink != 0) {
    Bloat = -PCB->Shrink;
    fBloat = (float)Bloat;
    TheFlag = 0x1040;
    ListStart(What,ptr1,ptr2,ptr3);
    DoIt('\x01','\0');
    DumpList();
    TheFlag = 4;
    ListStart(What,ptr1,ptr2,ptr3);
    Bloat = 0;
    fBloat = 0.00000000;
    drc = '\x01';
    BVar2 = DoIt('\x01','\0');
    if (BVar2 != '\0') {
      DumpList();
      TheFlag = 0x44;
      ResetConnections('\0');
      User = '\x01';
      drc = '\0';
      Bloat = -PCB->Shrink;
      fBloat = (float)Bloat;
      TheFlag = 0x40;
      RestoreUndoSerialNumber();
      ListStart(What,ptr1,ptr2,ptr3);
      DoIt('\x01','\x01');
      DumpList();
      ListStart(What,ptr1,ptr2,ptr3);
      TheFlag = 4;
      Bloat = 0;
      fBloat = 0.00000000;
      drc = '\x01';
      DoIt('\x01','\x01');
      DumpList();
      drcerr_count = drcerr_count + 1;
      User = '\0';
      drc = '\0';
      LocateError(local_20,&local_24);
      BuildObjectList(&local_28,&local_2c,&local_30);
      if (Settings.grid_units_mm == '\0') {
        value_units = "mils";
        value_digits = 2;
        fVar1 = (float)PCB->Shrink / 100.00000000;
      }
      else {
        value_units = "mm";
        value_digits = 4;
        fVar1 = ((float)PCB->Shrink / 100000.00000000) * 25.39999962;
      }
      violation = pcb_drc_violation_new
                            ("Potential for broken trace",
                                                          
                             "Insufficient overlap between objects can lead to broken tracks\ndue to registration errors with old wheel style photo-plotters."
                             ,local_20[0],local_24,0,0.00000000,(double)fVar1,value_digits,
                             value_units,local_28,local_2c,local_30);
      append_drc_violation(violation);
      pcb_drc_violation_free(violation);
      free(local_2c);
      free(local_30);
      value_digits = throw_drc_dialog();
      if (value_digits == 0) {
        return '\x01';
      }
      IncrementUndoSerialNumber();
      Undo('\x01');
    }
    DumpList();
  }
  drc = '\0';
  ResetConnections('\0');
  TheFlag = 4;
  ListStart(What,ptr1,ptr2,ptr3);
  Bloat = PCB->Bloat;
  fBloat = (float)Bloat;
  drc = '\x01';
  while( true ) {
    BVar2 = DoIt('\x01','\0');
    if (BVar2 == '\0') {
      drc = '\0';
      DumpList();
      TheFlag = 0x44;
      ResetConnections('\0');
      return '\0';
    }
    DumpList();
    TheFlag = 0x44;
    ResetConnections('\0');
    User = '\x01';
    drc = '\0';
    Bloat = 0;
    fBloat = 0.00000000;
    RestoreUndoSerialNumber();
    TheFlag = 0x40;
    ListStart(What,ptr1,ptr2,ptr3);
    DoIt('\x01','\x01');
    DumpList();
    TheFlag = 4;
    ListStart(What,ptr1,ptr2,ptr3);
    Bloat = PCB->Bloat;
    fBloat = (float)Bloat;
    drc = '\x01';
    DoIt('\x01','\x01');
    DumpList();
    drcerr_count = drcerr_count + 1;
    LocateError(local_20,&local_24);
    BuildObjectList(&local_28,&local_2c,&local_30);
    if (Settings.grid_units_mm == '\0') {
      value_digits = 2;
      value_units = "mils";
      fVar1 = (float)PCB->Bloat / 100.00000000;
    }
    else {
      value_digits = 4;
      value_units = "mm";
      fVar1 = ((float)PCB->Bloat / 100000.00000000) * 25.39999962;
    }
    violation = pcb_drc_violation_new
                          ("Copper areas too close",
                                                      
                           "Circuits that are too close may bridge during imaging, etching,\nplating, or soldering processes resulting in a direct short."
                           ,local_20[0],local_24,0,0.00000000,(double)fVar1,value_digits,value_units
                           ,local_28,local_2c,local_30);
    append_drc_violation(violation);
    pcb_drc_violation_free(violation);
    free(local_2c);
    free(local_30);
    User = '\0';
    drc = '\0';
    value_digits = throw_drc_dialog();
    if (value_digits == 0) break;
    IncrementUndoSerialNumber();
    Undo('\x01');
    TheFlag = TheFlag | 0x40;
    Bloat = 0;
    fBloat = 0.00000000;
    ListStart(thing_type,thing_ptr1,thing_ptr2,thing_ptr3);
    DoIt('\x01','\x01');
    DumpList();
    drc = '\x01';
    Bloat = PCB->Bloat;
    fBloat = (float)Bloat;
    ListStart(What,ptr1,ptr2,ptr3);
  }
  return '\x01';
}



int DRCAll(void)

{
  float fVar1;
  float fVar2;
  Boolean BVar3;
  char *value_units;
  DrcViolationType *violation;
  DataType *Data;
  size_t __size;
  char *title;
  DataTypePtr *pDVar4;
  void *ptr2;
  int value_digits;
  int value_digits_00;
  int value_digits_01;
  PCBTypePtr pPVar5;
  int *piVar6;
  uint uVar7;
  uint uVar8;
  LineTypePtr Line;
  PinTypePtr *Pin;
  ArcTypePtr *Arc;
  PadTypePtr *Pad;
  void *ptr1;
  uint uVar9;
  ElementTypePtr *Element;
  LayerType_conflict *ptr1_00;
  int local_58;
  uint local_54;
  int local_50;
  int local_4c;
  char *local_48;
  LayerTypePtr local_44;
  int *local_30;
  long *local_2c;
  int local_28;
  LocationType local_24;
  LocationType local_20 [4];
  
  drc_dialog_message[0] = '\0';
  if (gui->drc_gui != (HID_DRC_GUI *)0x0) {
    (*gui->drc_gui->reset_drc_dialog_message)();
  }
  IsBad = '\0';
  drcerr_count = 0;
  SaveStackAndVisibility();
  ResetStackAndVisibility();
  hid_action("LayersChanged");
  InitConnectionLookup();
  TheFlag = 0x1044;
  ResetConnections('\x01');
  User = '\0';
  pDVar4 = PCB->Data;
  local_48 = (char *)(pDVar4->ElementN - 1);
  if (local_48 == (char *)0xffffffff) {
    local_4c = 0;
    if (IsBad != '\0') goto LAB_0809babf;
  }
  else {
    local_4c = 0;
    value_digits_00 = pDVar4->ElementN * 300;
    while( true ) {
      local_50 = value_digits_00 + -300;
      ptr1 = (void *)((int)&pDVar4->Element[-1].BoundingBox.X1 + value_digits_00);
      if (*(uint *)((int)ptr1 + 0xe0) != 0) {
        uVar7 = 0;
        uVar9 = *(uint *)((int)ptr1 + 0xe0);
        do {
          ptr2 = (void *)(uVar7 * 0x4c + *(int *)((int)ptr1 + 0x100));
          uVar8 = uVar9;
          if ((*(byte *)((int)ptr2 + 0x15) & 0x10) == 0) {
            BVar3 = DRCFind(0x100,ptr1,ptr2,ptr2);
            if (BVar3 != '\0') goto LAB_0809bab8;
            uVar8 = *(uint *)((int)ptr1 + 0xe0);
          }
        } while ((uVar8 != 0) && (uVar7 = (uVar7 + 1 + uVar8) - uVar9, uVar9 = uVar8, uVar7 < uVar8)
                );
      }
      if (IsBad != '\0') goto LAB_0809babf;
      uVar9 = *(uint *)((int)ptr1 + 0xe8);
      uVar8 = 0;
      uVar7 = uVar9;
      while ((uVar7 != 0 && (uVar8 < uVar7))) {
        ptr2 = (void *)(uVar8 * 0x68 + *(int *)((int)ptr1 + 0x104));
        local_4c = (local_4c + 1) - (uint)((*(uint *)((int)ptr2 + 0x14) & 8) == 0);
        if ((*(uint *)((int)ptr2 + 0x14) & 0x1000) == 0) {
          BVar3 = DRCFind(0x200,ptr1,ptr2,ptr2);
          if (BVar3 != '\0') goto LAB_0809bab8;
          uVar7 = *(uint *)((int)ptr1 + 0xe8);
        }
        uVar8 = uVar8 + (uVar9 == uVar7);
      }
      if (IsBad != '\0') goto LAB_0809babf;
      local_48 = (char *)((int)local_48 + -1);
      if (local_48 == (char *)0xffffffff) break;
      pDVar4 = PCB->Data;
      value_digits_00 = local_50;
    }
    pDVar4 = PCB->Data;
  }
  if (pDVar4->ViaN != 0) {
    uVar7 = 0;
    pPVar5 = PCB;
    uVar9 = pDVar4->ViaN;
    do {
      Pin = pDVar4->Via + uVar7;
      if ((*(byte *)((int)&(Pin->Flags).f + 1) & 0x10) == 0) {
        BVar3 = DRCFind(1,Pin,Pin,Pin);
        if (BVar3 != '\0') goto LAB_0809bab8;
        pDVar4 = PCB->Data;
        uVar8 = pDVar4->ViaN;
        pPVar5 = PCB;
      }
      else {
        pDVar4 = pPVar5->Data;
        uVar8 = pDVar4->ViaN;
      }
    } while ((uVar8 != 0) && (uVar7 = (uVar8 + 1 + uVar7) - uVar9, uVar9 = uVar8, uVar7 < uVar8));
    if (IsBad != '\0') goto LAB_0809babf;
  }
  TheFlag = 0x1044;
LAB_0809bac4:
  ResetConnections('\0');
  TheFlag = 0x40;
  if (IsBad == '\0') {
    Data = (DataType *)PCB->Data;
    ptr1_00 = Data->Layer;
    if (Data->LayerN != 0) {
      local_54 = 0;
      do {
        local_44 = (LayerTypePtr)(((LayerTypePtr)ptr1_00)->LineN - 1);
        if (local_44 == (LayerTypePtr)0xffffffff) {
LAB_0809bcd5:
          uVar9 = Data->LayerN;
          if (uVar9 <= local_54 + 1) goto LAB_0809c7e6;
        }
        else {
          value_digits_00 = ((LayerTypePtr)ptr1_00)->LineN * 0x58;
          while( true ) {
            Line = (LineTypePtr)
                   ((int)&((LayerTypePtr)ptr1_00)->Line[-1].BoundingBox.X1 + value_digits_00);
            PlowsPolygon(Data,4,ptr1_00,Line,drc_callback);
            if (IsBad != '\0') break;
            if (Line->Thickness < PCB->minWid) {
              AddObjectToFlagUndoList(4,ptr1_00,Line,Line);
              (Line->Flags).f = (Line->Flags).f | TheFlag;
              DrawLine((LayerTypePtr)ptr1_00,Line,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 4;
              thing_ptr1 = ptr1_00;
              thing_ptr2 = Line;
              thing_ptr3 = Line;
              LocateError(local_20,&local_24);
              BuildObjectList(&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                value_digits = 2;
                value_units = "mils";
                fVar2 = (float)PCB->minWid / 100.00000000;
                fVar1 = (float)Line->Thickness / 100.00000000;
              }
              else {
                value_digits = 4;
                value_units = "mm";
                fVar2 = ((float)PCB->minWid / 100000.00000000) * 25.39999962;
                fVar1 = (100000.00000000 / (float)Line->Thickness) * 25.39999962;
              }
              violation = pcb_drc_violation_new
                                    ("Line width is too thin",
                                                                          
                                     "Process specifications dictate a minimum feature-width\nthat can reliably be reproduced"
                                     ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,
                                     value_digits,value_units,local_28,local_2c,local_30);
              append_drc_violation(violation);
              pcb_drc_violation_free(violation);
              free(local_2c);
              free(local_30);
              value_digits = throw_drc_dialog();
              if (value_digits == 0) {
                IsBad = '\x01';
                break;
              }
              IncrementUndoSerialNumber();
              Undo('\0');
            }
            if (local_44 == (LayerTypePtr)0x0) {
              Data = (DataType *)PCB->Data;
              goto LAB_0809bcd5;
            }
            local_44 = (LayerTypePtr)((int)local_44 + -1);
            Data = (DataType *)PCB->Data;
            value_digits_00 = value_digits_00 + -0x58;
          }
          Data = (DataType *)PCB->Data;
          uVar9 = Data->LayerN;
          if (uVar9 <= local_54 + 1) goto LAB_0809c7e6;
        }
        local_54 = local_54 + 1;
        ptr1_00 = (LayerType_conflict *)((LayerTypePtr)ptr1_00 + 1);
      } while( true );
    }
LAB_0809bcfa:
    local_54 = Data->ElementN - 1;
    if (local_54 != -1) {
      value_digits_00 = Data->ElementN * 300;
      do {
        local_58 = value_digits_00 + -300;
        ptr1 = (void *)((int)&((ElementTypePtr *)Data->Element)[-1].BoundingBox.X1 + value_digits_00
                       );
        if (*(uint *)((int)ptr1 + 0xe0) != 0) {
          uVar9 = 0;
          local_44 = (LayerTypePtr)*(uint *)((int)ptr1 + 0xe0);
          while( true ) {
            Pin = (PinTypePtr *)(uVar9 * 0x4c + *(int *)((int)ptr1 + 0x100));
            PlowsPolygon(Data,0x100,ptr1,Pin,drc_callback);
            if (IsBad != '\0') break;
            if ((*(byte *)&(Pin->Flags).f & 8) == 0) {
              value_digits_00 = Pin->DrillingHole;
              value_digits = Pin->Thickness - value_digits_00;
              if (SBORROW4(value_digits,PCB->minRing * 2) == value_digits + PCB->minRing * -2 < 0) {
                if (PCB->minDrill == value_digits_00 || PCB->minDrill < value_digits_00)
                goto LAB_0809bd6a;
                goto LAB_0809bde6;
              }
              AddObjectToFlagUndoList(0x100,ptr1,Pin,Pin);
              (Pin->Flags).f = (Pin->Flags).f | TheFlag;
              DrawPin(Pin,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 0x100;
              thing_ptr1 = ptr1;
              thing_ptr2 = Pin;
              thing_ptr3 = Pin;
              LocateError(local_20,&local_24);
              BuildObjectList(&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                fVar2 = (float)PCB->minRing / 100.00000000;
                value_units = "mils";
                value_digits_00 = 2;
                fVar1 = (float)((Pin->Thickness - Pin->DrillingHole) / 2) / 100.00000000;
              }
              else {
                value_units = "mm";
                value_digits_00 = 4;
                fVar2 = ((float)PCB->minRing / 100000.00000000) * 25.39999962;
                fVar1 = (100000.00000000 / (float)((Pin->Thickness - Pin->DrillingHole) / 2)) *
                        25.39999962;
              }
              violation = pcb_drc_violation_new
                                    ("Pin annular ring too small",
                                                                          
                                     "Annular rings that are too small may erode during etching,\nresulting in a broken connection"
                                     ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,
                                     value_digits_00,value_units,local_28,local_2c,local_30);
              append_drc_violation(violation);
              pcb_drc_violation_free(violation);
              free(local_2c);
              free(local_30);
              value_digits_00 = throw_drc_dialog();
              if (value_digits_00 != 0) {
                IncrementUndoSerialNumber();
                Undo('\0');
                value_digits_00 = Pin->DrillingHole;
                goto LAB_0809bdde;
              }
LAB_0809cbaa:
              IsBad = '\x01';
              break;
            }
            value_digits_00 = Pin->DrillingHole;
LAB_0809bdde:
            if (PCB->minDrill == value_digits_00 || PCB->minDrill < value_digits_00) {
LAB_0809bd6a:
              uVar7 = *(uint *)((int)ptr1 + 0xe0);
            }
            else {
LAB_0809bde6:
              AddObjectToFlagUndoList(0x100,ptr1,Pin,Pin);
              (Pin->Flags).f = (Pin->Flags).f | TheFlag;
              DrawPin(Pin,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 0x100;
              thing_ptr1 = ptr1;
              thing_ptr2 = Pin;
              thing_ptr3 = Pin;
              LocateError(local_20,&local_24);
              BuildObjectList(&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                value_digits_00 = 2;
                value_units = "mils";
                fVar2 = (float)PCB->minDrill / 100.00000000;
                fVar1 = (float)Pin->DrillingHole / 100.00000000;
              }
              else {
                value_digits_00 = 4;
                value_units = "mm";
                fVar2 = ((float)PCB->minDrill / 100000.00000000) * 25.39999962;
                fVar1 = (100000.00000000 / (float)Pin->DrillingHole) * 25.39999962;
              }
              violation = pcb_drc_violation_new
                                    ("Pin drill size is too small",
                                                                          
                                     "Process rules dictate the minimum drill size which can be used"
                                     ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,
                                     value_digits_00,value_units,local_28,local_2c,local_30);
              append_drc_violation(violation);
              pcb_drc_violation_free(violation);
              free(local_2c);
              free(local_30);
              value_digits_00 = throw_drc_dialog();
              if (value_digits_00 == 0) goto LAB_0809cbaa;
              IncrementUndoSerialNumber();
              Undo('\0');
              uVar7 = *(uint *)((int)ptr1 + 0xe0);
            }
            if ((uVar7 == 0) || (uVar9 = (uVar7 + 1 + uVar9) - (int)local_44, uVar7 <= uVar9))
            break;
            Data = (DataType *)PCB->Data;
            local_44 = (LayerTypePtr)uVar7;
          }
        }
        local_54 = local_54 + -1;
        if (local_54 == -1) goto LAB_0809cc35;
        Data = (DataType *)PCB->Data;
        value_digits_00 = local_58;
      } while( true );
    }
LAB_0809bf6d:
    if (Data->ViaN != 0) {
      uVar7 = 0;
      uVar9 = Data->ViaN;
      while( true ) {
        Pin = Data->Via + uVar7;
        PlowsPolygon(Data,1,Pin,Pin,drc_callback);
        if (IsBad != '\0') break;
        if ((*(byte *)&(Pin->Flags).f & 8) == 0) {
          value_digits_00 = Pin->DrillingHole;
          value_digits = Pin->Thickness - value_digits_00;
          if (SBORROW4(value_digits,PCB->minRing * 2) == value_digits + PCB->minRing * -2 < 0) {
            if (PCB->minDrill == value_digits_00 || PCB->minDrill < value_digits_00)
            goto LAB_0809bfa9;
            goto LAB_0809c016;
          }
          AddObjectToFlagUndoList(1,Pin,Pin,Pin);
          (Pin->Flags).f = (Pin->Flags).f | TheFlag;
          DrawVia(Pin,0);
          drcerr_count = drcerr_count + 1;
          thing_type = 1;
          thing_ptr1 = Pin;
          thing_ptr2 = Pin;
          thing_ptr3 = Pin;
          LocateError(local_20,&local_24);
          BuildObjectList(&local_28,&local_2c,&local_30);
          if (Settings.grid_units_mm == '\0') {
            local_48 = "mils";
            fVar2 = (float)PCB->minRing / 100.00000000;
            value_digits_00 = 2;
            fVar1 = (float)((Pin->Thickness - Pin->DrillingHole) / 2) / 100.00000000;
          }
          else {
            local_48 = "mm";
            value_digits_00 = 4;
            fVar2 = ((float)PCB->minRing / 100000.00000000) * 25.39999962;
            fVar1 = (100000.00000000 / (float)((Pin->Thickness - Pin->DrillingHole) / 2)) *
                    25.39999962;
          }
          violation = pcb_drc_violation_new
                                ("Via annular ring too small",
                                                                  
                                 "Annular rings that are too small may erode during etching,\nresulting in a broken connection"
                                 ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,value_digits_00
                                 ,local_48,local_28,local_2c,local_30);
          append_drc_violation(violation);
          pcb_drc_violation_free(violation);
          free(local_2c);
          free(local_30);
          value_digits_00 = throw_drc_dialog();
          if (value_digits_00 != 0) {
            IncrementUndoSerialNumber();
            Undo('\0');
            value_digits_00 = Pin->DrillingHole;
            goto LAB_0809c00e;
          }
LAB_0809cf40:
          IsBad = '\x01';
          break;
        }
        value_digits_00 = Pin->DrillingHole;
LAB_0809c00e:
        if (PCB->minDrill == value_digits_00 || PCB->minDrill < value_digits_00) {
LAB_0809bfa9:
          Data = (DataType *)PCB->Data;
          uVar8 = Data->ViaN;
        }
        else {
LAB_0809c016:
          AddObjectToFlagUndoList(1,Pin,Pin,Pin);
          (Pin->Flags).f = (Pin->Flags).f | TheFlag;
          DrawVia(Pin,0);
          drcerr_count = drcerr_count + 1;
          thing_type = 1;
          thing_ptr1 = Pin;
          thing_ptr2 = Pin;
          thing_ptr3 = Pin;
          LocateError(local_20,&local_24);
          BuildObjectList(&local_28,&local_2c,&local_30);
          if (Settings.grid_units_mm == '\0') {
            value_units = "mils";
            fVar2 = (float)PCB->minDrill / 100.00000000;
            value_digits_00 = 2;
            fVar1 = (float)Pin->DrillingHole / 100.00000000;
          }
          else {
            value_units = "mm";
            fVar2 = ((float)PCB->minDrill / 100000.00000000) * 25.39999962;
            value_digits_00 = 4;
            fVar1 = (100000.00000000 / (float)Pin->DrillingHole) * 25.39999962;
          }
          violation = pcb_drc_violation_new
                                ("Via drill size is too small",
                                 "Process rules dictate the minimum drill size which can be used",
                                 local_20[0],local_24,1,(double)fVar1,(double)fVar2,value_digits_00,
                                 value_units,local_28,local_2c,local_30);
          append_drc_violation(violation);
          pcb_drc_violation_free(violation);
          free(local_2c);
          free(local_30);
          value_digits_00 = throw_drc_dialog();
          if (value_digits_00 == 0) goto LAB_0809cf40;
          IncrementUndoSerialNumber();
          Undo('\0');
          Data = (DataType *)PCB->Data;
          uVar8 = Data->ViaN;
        }
        if ((uVar8 == 0) || (uVar7 = (uVar8 + 1 + uVar7) - uVar9, uVar9 = uVar8, uVar8 <= uVar7))
        break;
      }
    }
  }
LAB_0809c15f:
  FreeConnectionLookupMemory();
  Bloat = 0;
  fBloat = 0.00000000;
  TheFlag = 0x40;
  if (IsBad == '\0') {
    local_54 = 0;
    local_44 = (LayerTypePtr)(&PCB->Data->field_0x4c + PCB->Data->LayerN * 0x5c);
    do {
      value_digits_00 = local_44->LineN - 1;
      if (value_digits_00 != -1) {
        value_digits = local_44->LineN * 0x58;
        do {
          Line = (LineTypePtr)((int)&local_44->Line[-1].BoundingBox.X1 + value_digits);
          if (Line->Thickness < PCB->minSlk) {
            (Line->Flags).f = (Line->Flags).f | TheFlag;
            DrawLine(local_44,Line,0);
            drcerr_count = drcerr_count + 1;
            thing_ptr1 = local_44;
            thing_type = 4;
            thing_ptr2 = Line;
            thing_ptr3 = Line;
            LocateError(local_20,&local_24);
            BuildObjectList(&local_28,&local_2c,&local_30);
            if (Settings.grid_units_mm == '\0') {
              value_digits_01 = 2;
              value_units = "mils";
              fVar2 = (float)PCB->minSlk / 100.00000000;
              fVar1 = (float)Line->Thickness / 100.00000000;
            }
            else {
              value_digits_01 = 4;
              value_units = "mm";
              fVar2 = ((float)PCB->minSlk / 100000.00000000) * 25.39999962;
              fVar1 = (100000.00000000 / (float)Line->Thickness) * 25.39999962;
            }
            violation = pcb_drc_violation_new
                                  ("Silk line is too thin",
                                                                      
                                   "Process specifications dictate a minimum silkscreen feature-width\nthat can reliably be reproduced"
                                   ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,
                                   value_digits_01,value_units,local_28,local_2c,local_30);
            append_drc_violation(violation);
            pcb_drc_violation_free(violation);
            free(local_2c);
            free(local_30);
            value_digits_01 = throw_drc_dialog();
            if (value_digits_01 == 0) {
              IsBad = '\x01';
              break;
            }
          }
          value_digits_00 = value_digits_00 + -1;
          value_digits = value_digits + -0x58;
        } while (value_digits_00 != -1);
      }
      local_54 = local_54 + 1;
      if (local_54 == 2) break;
      local_44 = local_44 + 1;
    } while( true );
  }
  TheFlag = 0x40;
  if (IsBad == '\0') {
    pDVar4 = PCB->Data;
    local_44 = (LayerTypePtr)(pDVar4->ElementN - 1);
    if (local_44 == (LayerTypePtr)0xffffffff) goto LAB_0809c35f;
    value_digits_00 = pDVar4->ElementN * 300;
    while( true ) {
      local_48 = (char *)(value_digits_00 + -300);
      Element = (ElementTypePtr *)((int)&pDVar4->Element[-1].BoundingBox.X1 + value_digits_00);
      value_digits_00 = Element->LineN - 1;
      if (value_digits_00 != -1) {
        value_digits = 0;
        piVar6 = &Element->Line[Element->LineN - 1].Thickness;
        do {
          value_digits_00 = value_digits_00 + -1;
          value_digits = value_digits + (uint)(*piVar6 < PCB->minSlk);
          piVar6 = piVar6 + -0x16;
        } while (value_digits_00 != -1);
        if (value_digits != 0) {
          (Element->Flags).f = (Element->Flags).f | TheFlag;
          DrawElement(Element,0);
          drcerr_count = drcerr_count + 1;
          thing_type = 2;
          thing_ptr1 = Element;
          thing_ptr2 = Element;
          thing_ptr3 = Element;
          LocateError(local_20,&local_24);
          BuildObjectList(&local_28,&local_2c,&local_30);
          value_units = Element->Name[1].TextString;
          if ((value_units == (char *)0x0) || (*value_units == '\0')) {
            __size = 0x40;
            value_units = "(unknown)";
          }
          else {
            __size = strlen(value_units);
            __size = __size + 0x37;
          }
          title = (char *)calloc(1,__size);
          __snprintf_chk(title,__size,1,0xffffffff,"Element %s has %i silk lines which are too thin"
                         ,value_units,value_digits);
          if (Settings.grid_units_mm == '\0') {
            value_digits_00 = 2;
            value_units = "mils";
            fVar1 = (float)PCB->minSlk / 100.00000000;
          }
          else {
            value_digits_00 = 4;
            value_units = "mm";
            fVar1 = ((float)PCB->minSlk / 100000.00000000) * 25.39999962;
          }
          violation = pcb_drc_violation_new
                                (title,
                                 "Process specifications dictate a minimum silkscreen\nfeature-width that can reliably be reproduced"
                                 ,local_20[0],local_24,0,1.00000000,(double)fVar1,value_digits_00,
                                 value_units,local_28,local_2c,local_30);
          free(title);
          append_drc_violation(violation);
          pcb_drc_violation_free(violation);
          free(local_2c);
          free(local_30);
          value_digits_00 = throw_drc_dialog();
          if (value_digits_00 == 0) {
            IsBad = '\x01';
            goto LAB_0809c35a;
          }
        }
      }
      local_44 = (LayerTypePtr)((int)local_44 + -1);
      if (local_44 == (LayerTypePtr)0xffffffff) break;
      pDVar4 = PCB->Data;
      value_digits_00 = (int)local_48;
    }
    if (IsBad == '\0') goto LAB_0809c35f;
  }
LAB_0809c35a:
  IncrementUndoSerialNumber();
LAB_0809c35f:
  RestoreStackAndVisibility();
  hid_action("LayersChanged");
  (*gui->invalidate_all)();
  if (local_4c != 0) {
    value_units = " has";
    if (local_4c != 1) {
      value_units = "s have";
    }
    Message("Warning:  %d pad%s the nopaste flag set.\n",local_4c,value_units);
  }
  if (IsBad == '\0') {
    return drcerr_count;
  }
  return -drcerr_count;
LAB_0809bab8:
  IsBad = '\x01';
LAB_0809babf:
  TheFlag = 0x1000;
  goto LAB_0809bac4;
LAB_0809c7e6:
  if (IsBad == '\0') {
    ptr1_00 = Data->Layer;
    if (uVar9 != 0) {
      local_54 = 0;
      do {
        local_44 = (LayerTypePtr)(((LayerTypePtr)ptr1_00)->ArcN - 1);
        if (local_44 != (LayerTypePtr)0xffffffff) {
          value_digits_00 = ((LayerTypePtr)ptr1_00)->ArcN * 0x44;
          while( true ) {
            Arc = (ArcTypePtr *)
                  ((int)&((LayerTypePtr)ptr1_00)->Arc[-1].BoundingBox.X1 + value_digits_00);
            PlowsPolygon(Data,0x4000,ptr1_00,Arc,drc_callback);
            if (IsBad != '\0') break;
            if (Arc->Thickness < PCB->minWid) {
              AddObjectToFlagUndoList(0x4000,ptr1_00,Arc,Arc);
              (Arc->Flags).f = (Arc->Flags).f | TheFlag;
              DrawArc((LayerTypePtr)ptr1_00,Arc,0);
              drcerr_count = drcerr_count + 1;
              thing_type = 0x4000;
              thing_ptr1 = ptr1_00;
              thing_ptr2 = Arc;
              thing_ptr3 = Arc;
              LocateError(local_20,&local_24);
              BuildObjectList(&local_28,&local_2c,&local_30);
              if (Settings.grid_units_mm == '\0') {
                value_digits = 2;
                value_units = "mils";
                fVar2 = (float)PCB->minWid / 100.00000000;
                fVar1 = (float)Arc->Thickness / 100.00000000;
              }
              else {
                value_digits = 4;
                value_units = "mm";
                fVar2 = ((float)PCB->minWid / 100000.00000000) * 25.39999962;
                fVar1 = (100000.00000000 / (float)Arc->Thickness) * 25.39999962;
              }
              violation = pcb_drc_violation_new
                                    ("Arc width is too thin",
                                                                          
                                     "Process specifications dictate a minimum feature-width\nthat can reliably be reproduced"
                                     ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,
                                     value_digits,value_units,local_28,local_2c,local_30);
              append_drc_violation(violation);
              pcb_drc_violation_free(violation);
              free(local_2c);
              free(local_30);
              value_digits = throw_drc_dialog();
              if (value_digits == 0) {
                IsBad = '\x01';
                break;
              }
              IncrementUndoSerialNumber();
              Undo('\0');
            }
            if (local_44 == (LayerTypePtr)0x0) {
              Data = (DataType *)PCB->Data;
              goto LAB_0809c9d5;
            }
            local_44 = (LayerTypePtr)((int)local_44 + -1);
            Data = (DataType *)PCB->Data;
            value_digits_00 = value_digits_00 + -0x44;
          }
          Data = (DataType *)PCB->Data;
        }
LAB_0809c9d5:
        local_54 = local_54 + 1;
        if ((uint)Data->LayerN < local_54 || Data->LayerN == local_54) goto LAB_0809bced;
        ptr1_00 = (LayerType_conflict *)((LayerTypePtr)ptr1_00 + 1);
      } while( true );
    }
    goto LAB_0809bcfa;
  }
  goto LAB_0809c15f;
LAB_0809bced:
  if (IsBad != '\0') goto LAB_0809c15f;
  goto LAB_0809bcfa;
LAB_0809cc35:
  if (IsBad == '\0') {
    Data = (DataType *)PCB->Data;
    local_54 = Data->ElementN - 1;
    if (local_54 != -1) {
      local_58 = local_54 * 300;
      do {
        value_digits_00 = 0;
        ptr1 = (void *)((int)&(((ElementTypePtr *)Data->Element)->BoundingBox).X1 + local_58);
        local_44 = (LayerTypePtr)0x0;
        uVar9 = *(uint *)((int)ptr1 + 0xe8);
        uVar7 = uVar9;
LAB_0809cc97:
        if ((uVar7 == 0) || (uVar7 <= local_44)) goto LAB_0809ce70;
        Pad = (PadTypePtr *)(*(int *)((int)ptr1 + 0x104) + value_digits_00);
        PlowsPolygon((DataType *)PCB->Data,0x200,ptr1,Pad,drc_callback);
        if (IsBad != '\0') goto LAB_0809ce70;
        if (PCB->minWid <= Pad->Thickness) {
          uVar7 = *(uint *)((int)ptr1 + 0xe8);
joined_r0x0809ce2b:
          if (uVar7 == uVar9) {
            local_44 = (LayerTypePtr)((int)local_44 + 1);
            value_digits_00 = value_digits_00 + 0x68;
            uVar7 = uVar9;
          }
          goto LAB_0809cc97;
        }
        AddObjectToFlagUndoList(0x200,ptr1,Pad,Pad);
        (Pad->Flags).f = (Pad->Flags).f | TheFlag;
        DrawPad(Pad,0);
        drcerr_count = drcerr_count + 1;
        thing_type = 0x200;
        thing_ptr1 = ptr1;
        thing_ptr2 = Pad;
        thing_ptr3 = Pad;
        LocateError(local_20,&local_24);
        BuildObjectList(&local_28,&local_2c,&local_30);
        if (Settings.grid_units_mm == '\0') {
          value_units = "mils";
          fVar2 = (float)PCB->minWid / 100.00000000;
          value_digits = 2;
          fVar1 = (float)Pad->Thickness / 100.00000000;
        }
        else {
          value_units = "mm";
          fVar2 = ((float)PCB->minWid / 100000.00000000) * 25.39999962;
          value_digits = 4;
          fVar1 = (100000.00000000 / (float)Pad->Thickness) * 25.39999962;
        }
        violation = pcb_drc_violation_new
                              ("Pad is too thin",
                                                              
                               "Pads which are too thin may erode during etching,\nresulting in a broken or unreliable connection"
                               ,local_20[0],local_24,1,(double)fVar1,(double)fVar2,value_digits,
                               value_units,local_28,local_2c,local_30);
        append_drc_violation(violation);
        pcb_drc_violation_free(violation);
        free(local_2c);
        free(local_30);
        value_digits = throw_drc_dialog();
        if (value_digits != 0) {
          IncrementUndoSerialNumber();
          Undo('\0');
          uVar7 = *(uint *)((int)ptr1 + 0xe8);
          goto joined_r0x0809ce2b;
        }
        IsBad = '\x01';
LAB_0809ce70:
        local_54 = local_54 + -1;
        local_58 = local_58 + -300;
        if (local_54 == -1) goto LAB_0809bf55;
        Data = (DataType *)PCB->Data;
      } while( true );
    }
    goto LAB_0809bf6d;
  }
  goto LAB_0809c15f;
LAB_0809bf55:
  if (IsBad != '\0') goto LAB_0809c15f;
  Data = (DataType *)PCB->Data;
  goto LAB_0809bf6d;
}



void LookupUnusedPins(FILE *FP)

{
  uint uVar1;
  uint uVar2;
  bool bVar3;
  Boolean BVar4;
  char cVar5;
  DataTypePtr *pDVar6;
  uint uVar7;
  char *S;
  Cardinal CVar8;
  Cardinal CVar9;
  ElementTypePtr *Element;
  int iVar10;
  uint uVar11;
  PadTypePtr *Pad;
  PinTypePtr *Pin;
  int local_3c;
  int local_38;
  uint local_20;
  
  User = '\x01';
  SaveUndoSerialNumber();
  ResetConnections('\x01');
  RestoreUndoSerialNumber();
  InitConnectionLookup();
  pDVar6 = PCB->Data;
  local_3c = pDVar6->ElementN - 1;
  if (local_3c != -1) {
    iVar10 = pDVar6->ElementN * 300;
    while( true ) {
      local_38 = iVar10 + -300;
      Element = (ElementTypePtr *)((int)&pDVar6->Element[-1].BoundingBox.X1 + iVar10);
      if (Element->PinN == 0) {
        bVar3 = true;
      }
      else {
        bVar3 = true;
        uVar11 = 0;
        uVar7 = Element->PinN;
        do {
          Pin = Element->Pin + uVar11;
          uVar1 = (Pin->Flags).f;
          uVar2 = uVar7;
          if ((((uVar1 & 8) == 0) && (FP != (FILE *)0x0)) && ((TheFlag & uVar1) == 0)) {
            BVar4 = ADD_PV_TO_LIST(Pin);
            if (BVar4 != '\0') goto LAB_0809d20b;
            DoIt('\x01','\x01');
            iVar10 = PadList[0].Number + PVList.Number + PadList[1].Number;
            if (PVList.Number != 0) {
              CVar8 = 0;
              do {
                iVar10 = iVar10 - (uint)(*(int *)((int)PVList.Data[CVar8] + 0x44) == 0);
                CVar8 = CVar8 + 1;
              } while (CVar8 != PVList.Number);
            }
            if (iVar10 == 1) {
              if (bVar3) {
                PrintConnectionElementName(Element,FP);
              }
              S = Pin->Name;
              if (S == (char *)0x0) {
                S = "";
              }
              CreateQuotedString((DynamicStringTypePtr)&oname,S);
              __fprintf_chk(FP,1,&DAT_08148576,oname.Data);
              (Pin->Flags).f = (Pin->Flags).f | 0x40;
              DrawPin(Pin,0);
              bVar3 = false;
            }
            BVar4 = PrepareNextLoop(FP);
            if (BVar4 != '\0') goto LAB_0809d20b;
            uVar2 = Element->PinN;
          }
        } while ((uVar2 != 0) &&
                (uVar11 = (uVar11 + 1 + uVar2) - uVar7, uVar7 = uVar2, uVar11 < uVar2));
      }
      local_20 = 0;
      CVar8 = Element->PadN;
      CVar9 = CVar8;
      while ((CVar9 != 0 && (local_20 < CVar9))) {
        Pad = Element->Pad + local_20;
        uVar7 = (Pad->Flags).f;
        if ((FP != (FILE *)0x0) && ((TheFlag & uVar7) == 0)) {
          BVar4 = ADD_PAD_TO_LIST((uVar7 >> 7 ^ 1) & 1,Pad);
          if (BVar4 != '\0') goto LAB_0809d20b;
          DoIt('\x01','\x01');
          iVar10 = PadList[0].Number + PVList.Number + PadList[1].Number;
          if (PVList.Number != 0) {
            CVar9 = 0;
            do {
              iVar10 = iVar10 - (uint)(*(int *)((int)PVList.Data[CVar9] + 0x44) == 0);
              CVar9 = CVar9 + 1;
            } while (CVar9 != PVList.Number);
          }
          if (iVar10 == 1) {
            if (bVar3) {
              PrintConnectionElementName(Element,FP);
            }
            S = Pad->Name;
            if (S == (char *)0x0) {
              S = "";
            }
            CreateQuotedString((DynamicStringTypePtr)&oname,S);
            __fprintf_chk(FP,1,&DAT_08148576,oname.Data);
            (Pad->Flags).f = (Pad->Flags).f | 0x40;
            DrawPad(Pad,0);
            bVar3 = false;
            cVar5 = PrepareNextLoop(FP);
          }
          else {
            cVar5 = PrepareNextLoop(FP);
          }
          if (cVar5 != '\0') goto LAB_0809d20b;
          CVar9 = Element->PadN;
        }
        local_20 = local_20 + (CVar9 == CVar8);
      }
      if (!bVar3) {
        fwrite(&DAT_08148070,1,3,(FILE *)FP);
        fputc(0x23,(FILE *)FP);
        iVar10 = Settings.CharPerLine;
        while (iVar10 != 0) {
          fputc(0x3d,(FILE *)FP);
          iVar10 = iVar10 + -1;
        }
        fputc(10,(FILE *)FP);
      }
      local_3c = local_3c + -1;
      if (local_3c == -1) break;
      pDVar6 = PCB->Data;
      iVar10 = local_38;
    }
  }
LAB_0809d20b:
  if (Settings.RingBellWhenFinished != '\0') {
    (*gui->beep)();
  }
  FreeConnectionLookupMemory();
  IncrementUndoSerialNumber();
  User = '\0';
  Draw();
  return;
}



void RatFindHook(int type,void *ptr1,void *ptr2,void *ptr3,Boolean undo,Boolean AndRats)

{
  User = undo;
  DumpList();
  ListStart(type,ptr1,ptr2,ptr3);
  DoIt(AndRats,'\0');
  User = '\0';
  return;
}



Boolean __regparm3 PrintElementConnections(ElementTypePtr *Element,FILE *FP,Boolean AndDraw)

{
  uint uVar1;
  Cardinal CVar2;
  Boolean BVar3;
  PinTypePtr *Pin;
  char *ObjName;
  Cardinal CVar4;
  PadTypePtr *Pad;
  uint L;
  int local_24;
  uint local_20;
  
  PrintConnectionElementName(Element,FP);
  if (Element->PinN != 0) {
    L = 0;
    local_20 = Element->PinN;
    do {
      Pin = Element->Pin + L;
      if (((Pin->Flags).f & TheFlag) == 0) {
        BVar3 = ADD_PV_TO_LIST(Pin);
        if (BVar3 != '\0') {
          return '\x01';
        }
        DoIt('\x01',AndDraw);
        PrintPinConnections(FP,'\x01');
        PrintPadConnections(1,FP,'\0');
        PrintPadConnections(0,FP,'\0');
        fwrite("\t}\n",1,3,(FILE *)FP);
        BVar3 = PrepareNextLoop(FP);
        if (BVar3 != '\0') {
          return '\x01';
        }
      }
      else {
        ObjName = Pin->Name;
        if (ObjName == (char *)0x0) {
          ObjName = "";
        }
        PrintConnectionListEntry(ObjName,(ElementTypePtr *)0x0,'\x01',FP);
        fwrite("\t\t__CHECKED_BEFORE__\n\t}\n",1,0x18,(FILE *)FP);
      }
      uVar1 = Element->PinN;
    } while ((uVar1 != 0) && (L = (uVar1 + 1 + L) - local_20, local_20 = uVar1, L < uVar1));
  }
  CVar2 = Element->PadN;
  local_24 = 0;
  local_20 = 0;
  CVar4 = CVar2;
  do {
    if ((CVar4 == 0) || (CVar4 <= local_20)) {
      fwrite(&DAT_08148070,1,3,(FILE *)FP);
      return '\0';
    }
    Pad = (PadTypePtr *)((int)&(Element->Pad->BoundingBox).X1 + local_24);
    L = (Pad->Flags).f;
    if ((TheFlag & L) == 0) {
      L = (L >> 7 ^ 1) & 1;
      BVar3 = ADD_PAD_TO_LIST(L,Pad);
      if (BVar3 != '\0') {
        return '\x01';
      }
      DoIt('\x01',AndDraw);
      PrintPadConnections(L,FP,'\x01');
      PrintPadConnections(L ^ 1,FP,'\0');
      PrintPinConnections(FP,'\0');
      fwrite("\t}\n",1,3,(FILE *)FP);
      BVar3 = PrepareNextLoop(FP);
      if (BVar3 != '\0') {
        return '\x01';
      }
      CVar4 = Element->PadN;
    }
    else {
      ObjName = Pad->Name;
      if (ObjName == (char *)0x0) {
        ObjName = "";
      }
      PrintConnectionListEntry(ObjName,(ElementTypePtr *)0x0,'\x01',FP);
      fwrite("\t\t__CHECKED_BEFORE__\n\t}\n",1,0x18,(FILE *)FP);
      CVar4 = Element->PadN;
    }
    if (CVar4 == CVar2) {
      local_20 = local_20 + 1;
      local_24 = local_24 + 0x68;
      CVar4 = CVar2;
    }
  } while( true );
}



void LookupConnectionsToAllElements(FILE *FP)

{
  int iVar1;
  int iVar2;
  Boolean BVar3;
  DataTypePtr *pDVar4;
  int iVar5;
  
  User = '\0';
  TheFlag = 4;
  ResetConnections('\0');
  InitConnectionLookup();
  pDVar4 = PCB->Data;
  iVar5 = pDVar4->ElementN - 1;
  if (iVar5 != -1) {
    iVar2 = pDVar4->ElementN * 300;
    while( true ) {
      BVar3 = PrintElementConnections
                        ((ElementTypePtr *)((int)&pDVar4->Element[-1].BoundingBox.X1 + iVar2),FP,
                         '\0');
      if (BVar3 != '\0') break;
      fputc(0x23,(FILE *)FP);
      iVar1 = Settings.CharPerLine;
      while (iVar1 != 0) {
        fputc(0x3d,(FILE *)FP);
        iVar1 = iVar1 + -1;
      }
      fputc(10,(FILE *)FP);
      if ((iVar5 != 1) && (Settings.ResetAfterElement != '\0')) {
        ResetConnections('\0');
      }
      if (iVar5 == 0) break;
      iVar5 = iVar5 + -1;
      pDVar4 = PCB->Data;
      iVar2 = iVar2 + -300;
    }
  }
  if (Settings.RingBellWhenFinished != '\0') {
    (*gui->beep)();
  }
  ResetConnections('\0');
  FreeConnectionLookupMemory();
  ClearAndRedrawOutput();
  return;
}



void LookupElementConnections(ElementTypePtr *Element,FILE *FP)

{
  User = '\x01';
  TheFlag = 4;
  ResetConnections('\x01');
  InitConnectionLookup();
  PrintElementConnections(Element,FP,'\x01');
  SetChangedFlag('\x01');
  if (Settings.RingBellWhenFinished != '\0') {
    (*gui->beep)();
  }
  FreeConnectionLookupMemory();
  IncrementUndoSerialNumber();
  User = '\0';
  Draw();
  return;
}



void LookupConnection(LocationType X,LocationType Y,Boolean AndDraw,BDimension Range,int which_flag)

{
  uint type;
  int iVar1;
  char *pcVar2;
  void *local_28;
  void *local_24;
  LayerTypePtr local_20 [4];
  
  type = SearchObjectByLocation(0x300,local_20,&local_24,&local_28,X,Y,Range);
  if (type == 0) {
    type = SearchObjectByLocation(0x402d,local_20,&local_24,&local_28,X,Y,Range);
    if (type == 0) {
      return;
    }
    if (((type & 0x400c) != 0) &&
       (iVar1 = GetLayerNumber(PCB->Data,local_20[0]), PCB->Data->LayerN <= iVar1)) {
      return;
    }
  }
  else {
    pcVar2 = ConnectionName(type,local_20[0],local_24);
    hid_actionl("NetlistShow",pcVar2,0);
  }
  TheFlag = which_flag;
  User = AndDraw;
  InitConnectionLookup();
  ListStart(type,local_20[0],local_24,local_28);
  DoIt('\x01',AndDraw);
  if (User != '\0') {
    IncrementUndoSerialNumber();
  }
  User = '\0';
  if ((AndDraw != '\0') && (Draw(), Settings.RingBellWhenFinished != '\0')) {
    (*gui->beep)();
  }
  FreeConnectionLookupMemory();
  return;
}



int FlagCurrentStyle(int dummy)

{
  PCBTypePtr pPVar1;
  int iVar2;
  
  iVar2 = 0;
  pPVar1 = PCB;
  while ((((pPVar1->RouteStyle[0].Thick != Settings.LineThickness ||
           (pPVar1->RouteStyle[0].Diameter != Settings.ViaThickness)) ||
          (pPVar1->RouteStyle[0].Hole != Settings.ViaDrillingHole)) ||
         (pPVar1->RouteStyle[0].Keepaway != Settings.Keepaway))) {
    iVar2 = iVar2 + 1;
    pPVar1 = (PCBTypePtr)&pPVar1->PrintFilename;
    if (iVar2 == 4) {
      return 0;
    }
  }
  return iVar2 + 1;
}



int FlagGrid(int dummy)

{
  return (uint)(1.00000000 < PCB->Grid);
}



int FlagGridSize(int dummy)

{
  return (int)ROUND((float)PCB->Grid + 0.50000000);
}



int FlagBuffer(int dummy)

{
  return Settings.BufferNumber + 1;
}



int FlagElementName(int dummy)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = (PCB->Flags).f;
  iVar2 = 2;
  if ((uVar1 & 0x40) == 0) {
    iVar2 = (-(uint)((uVar1 & 0x20) == 0) & 2) + 1;
  }
  return iVar2;
}



int FlagTESTFLAG(int bit)

{
  return (uint)(((PCB->Flags).f & bit) != 0);
}



int FlagSETTINGS(int ofs)

{
  return (int)(&Settings.grid_units_mm)[ofs];
}



int FlagMode(int x)

{
  if (x != -1) {
    return (uint)(Settings.Mode == x);
  }
  return Settings.Mode;
}



int FlagHaveRegex(int x)

{
  return 1;
}



int FlagLayerShown(int n)

{
  switch(n) {
  case -6:
    return (int)PCB->ElementOn;
  case -5:
    return (int)PCB->PinOn;
  case -4:
    return (int)PCB->RatOn;
  case -3:
    return (int)PCB->ViaOn;
  case -2:
    return (int)PCB->InvisibleObjectsOn;
  case -1:
    return (PCB->Flags).f >> 0xd & 1;
  }
  if ((-1 < n) && (n < PCB->Data->LayerN)) {
    return (int)*(char *)(&PCB->Data->field_0x90 + n * 0x5c);
  }
  return 0;
}



int FlagLayerActive(int n)

{
  int iVar1;
  
  iVar1 = -4;
  if ((PCB->RatDraw == '\0') && (iVar1 = -6, PCB->SilkActive == '\0')) {
    return 0;
  }
  return (uint)(iVar1 == n);
}



void register_flags_flag_list(void)

{
  hid_register_flags(flags_flag_list,0x46);
  return;
}



int FontSave(int argc,char **argv,int Ux,int Uy)

{
  DataTypePtr *pDVar1;
  int iVar2;
  PCBTypePtr pPVar3;
  PCBTypePtr pPVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  int X1;
  int iVar9;
  int X2;
  int iVar10;
  uint local_24;
  PCBTypePtr local_20;
  
  pPVar3 = PCB;
  pDVar1 = PCB->Data;
  iVar5 = 0;
  do {
    *(undefined4 *)((int)&(pPVar3->Font).Symbol[0].LineN + iVar5) = 0;
    (&(pPVar3->Font).Symbol[0].Valid)[iVar5] = '\0';
    *(undefined4 *)((int)&(pPVar3->Font).Symbol[0].Width + iVar5) = 0;
    iVar5 = iVar5 + 0x1c;
  } while (iVar5 != 0x1c00);
  if (*(int *)&pDVar1->field_0x50 != 0) {
    local_20 = pPVar3;
    local_24 = 0;
    while( true ) {
      iVar6 = local_24 * 0x58 + *(int *)&pDVar1->field_0x70;
      iVar2 = *(int *)(iVar6 + 0x30);
      iVar10 = *(int *)(iVar6 + 0x44);
      iVar5 = ((iVar2 + 1000) / 10000) * 0x10 + -0x11 + (*(int *)(iVar6 + 0x2c) + 1000) / 10000;
      uVar7 = (uint)(iVar5 >> 0x1f) >> 0x1c;
      X1 = ((iVar5 + uVar7 & 0xf) - uVar7) + 1;
      iVar9 = iVar5 + 0xf;
      if (-1 < iVar5) {
        iVar9 = iVar5;
      }
      iVar8 = (iVar9 >> 4) + 1;
      X2 = *(int *)(iVar6 + 0x40) + X1 * -10000;
      X1 = *(int *)(iVar6 + 0x2c) + X1 * -10000;
      iVar9 = (&local_20->ID + iVar5 * 7)[0x38];
      if (iVar9 < X1) {
        (&local_20->ID + iVar5 * 7)[0x38] = X1;
        iVar9 = X1;
      }
      if (iVar9 < X2) {
        (local_20->Font).Symbol[iVar5].Width = X2;
      }
      (local_20->Font).Symbol[iVar5].Valid = '\x01';
      CreateNewLineInSymbol
                ((SymbolTypePtr)((local_20->Font).Symbol + iVar5),X1,iVar2 + iVar8 * -10000,X2,
                 iVar10 + iVar8 * -10000,*(BDimension *)(iVar6 + 0x24));
      local_24 = local_24 + 1;
      if (*(uint *)&pDVar1->field_0x50 < local_24 || *(uint *)&pDVar1->field_0x50 == local_24)
      break;
      local_20 = PCB;
    }
  }
  pPVar4 = PCB;
  iVar5 = *(int *)&pDVar1->field_0x108;
  if (iVar5 != 0) {
    iVar2 = *(int *)&pDVar1->field_0x128;
    iVar10 = 0;
    do {
      iVar9 = iVar10 * 0x58 + iVar2;
      iVar10 = iVar10 + 1;
      iVar6 = *(int *)(iVar9 + 0x2c);
      iVar9 = ((*(int *)(iVar9 + 0x30) + 1000) / 10000) * 0x10 + -0x11 + (iVar6 + 1000) / 10000;
      uVar7 = (uint)(iVar9 >> 0x1f) >> 0x1c;
      (&pPVar4->ID + iVar9 * 7)[0x3a] =
           (iVar6 + (((iVar9 + uVar7 & 0xf) - uVar7) + 1) * -10000) -
           (&pPVar4->ID + iVar9 * 7)[0x38];
    } while (iVar10 != iVar5);
  }
  SetFontInfo((FontTypePtr)&pPVar3->Font);
  return 0;
}



int FontEdit(int argc,char **argv,int Ux,int Uy)

{
  uint *puVar1;
  DataTypePtr *pDVar2;
  FontType *pFVar3;
  PCBTypePtr pPVar4;
  int X1;
  int iVar5;
  char *pcVar6;
  LineTypePtr pLVar7;
  int iVar8;
  PCBTypePtr pPVar9;
  int iVar10;
  int in_GS_OFFSET;
  uint local_74;
  int local_68;
  uint local_60;
  ulong local_5c;
  undefined4 local_58;
  undefined4 local_54;
  ulong local_50;
  undefined4 local_4c;
  undefined4 local_48;
  ulong local_44;
  undefined4 local_40;
  undefined4 local_3c;
  ulong local_38;
  undefined4 local_34;
  undefined4 local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  X1 = hid_actionl("New",0x81483c4,0);
  iVar5 = 1;
  if (X1 == 0) {
    while (4 < PCB->Data->LayerN) {
      MoveLayer(4,-1);
    }
    MoveLayerToGroup(0,0);
    MoveLayerToGroup(1,1);
    MoveLayerToGroup(2,2);
    MoveLayerToGroup(3,3);
    pPVar4 = PCB;
    PCB->MaxWidth = 180000;
    pDVar2 = pPVar4->Data;
    pPVar4->MaxHeight = 180000;
    pPVar4->Grid = 500.00000000;
    pcVar6 = MyStrdup("Font","FontEdit");
    *(char **)&pDVar2->field_0x4c = pcVar6;
    pDVar2 = PCB->Data;
    pcVar6 = MyStrdup("OrigFont","FontEdit");
    *(char **)&pDVar2->field_0xa8 = pcVar6;
    pDVar2 = PCB->Data;
    pcVar6 = MyStrdup("Width","FontEdit");
    *(char **)&pDVar2->field_0x104 = pcVar6;
    pDVar2 = PCB->Data;
    pcVar6 = MyStrdup("Grid","FontEdit");
    *(char **)&pDVar2->field_0x160 = pcVar6;
    hid_action("PCBChanged");
    hid_action("LayersChanged");
    pPVar4 = PCB;
    local_74 = 0;
    pDVar2 = PCB->Data;
    pPVar9 = PCB;
    do {
      X1 = (pPVar4->Font).MaxHeight;
      iVar10 = ((local_74 & 0xf) + 1) * 10000;
      iVar5 = (((int)local_74 >> 4) + 1) * 10000;
      local_68 = 0;
      if ((pPVar9->Font).Symbol[0].LineN != 0) {
        local_60 = 0;
        do {
          MakeFlags((FlagType *)&local_2c,0);
          pLVar7 = (pPVar9->Font).Symbol[0].Line + local_60;
          CreateDrawnLineOnLayer
                    ((LayerTypePtr)&pDVar2->field_0x4c,iVar10 + (pLVar7->Point1).X,
                     (pLVar7->Point1).Y + iVar5,(pLVar7->Point2).X + iVar10,
                     (pLVar7->Point2).Y + iVar5,pLVar7->Thickness,pLVar7->Thickness,
                     (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
          MakeFlags((FlagType *)&local_38,0);
          pLVar7 = (pPVar9->Font).Symbol[0].Line + local_60;
          CreateDrawnLineOnLayer
                    ((LayerTypePtr)&pDVar2->field_0xa8,iVar10 + (pLVar7->Point1).X,
                     (pLVar7->Point1).Y + iVar5,(pLVar7->Point2).X + iVar10,
                     (pLVar7->Point2).Y + iVar5,pLVar7->Thickness,pLVar7->Thickness,
                     (FlagType)CONCAT48(local_30,CONCAT44(local_34,local_38)));
          pLVar7 = (pPVar9->Font).Symbol[0].Line + local_60;
          iVar8 = (pLVar7->Point1).X;
          if (iVar8 <= (pLVar7->Point2).X) {
            iVar8 = (pLVar7->Point2).X;
          }
          if (iVar8 <= local_68) {
            iVar8 = local_68;
          }
          local_60 = local_60 + 1;
          puVar1 = &(pPVar9->Font).Symbol[0].LineN;
          local_68 = iVar8;
        } while (local_60 <= *puVar1 && *puVar1 != local_60);
      }
      pFVar3 = &pPVar9->Font;
      pPVar9 = (PCBTypePtr)&pPVar9->Netlistname;
      local_68 = iVar10 + pFVar3->Symbol[0].Delta + local_68;
      MakeFlags((FlagType *)&local_44,0);
      CreateDrawnLineOnLayer
                ((LayerTypePtr)&pDVar2->field_0x104,local_68,iVar5 + 500,local_68,iVar5 + X1,100,100
                 ,(FlagType)CONCAT48(local_3c,CONCAT44(local_40,local_44)));
      local_74 = local_74 + 1;
    } while (local_74 != 0x100);
    X1 = 10000;
    do {
      MakeFlags((FlagType *)&local_50,0);
      iVar5 = X1 + 10000;
      CreateDrawnLineOnLayer
                ((LayerTypePtr)&pDVar2->field_0x160,X1,0,X1,PCB->MaxHeight,100,100,
                 (FlagType)CONCAT48(local_48,CONCAT44(local_4c,local_50)));
      X1 = iVar5;
    } while (iVar5 != 170000);
    X1 = 10000;
    do {
      MakeFlags((FlagType *)&local_5c,0);
      iVar5 = X1 + 10000;
      CreateDrawnLineOnLayer
                ((LayerTypePtr)&pDVar2->field_0x160,0,X1,PCB->MaxWidth,X1,100,100,
                 (FlagType)CONCAT48(local_54,CONCAT44(local_58,local_5c)));
      X1 = iVar5;
    } while (iVar5 != 180000);
    iVar5 = 0;
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
}



void register_fontmode_action_list(void)

{
  hid_register_actions(fontmode_action_list,2);
  return;
}



void heap_free(heap_t *heap,anon_subr_void_void_ptr *freefunc)

{
  void *pvVar1;
  int iVar2;
  
  iVar2 = heap->size;
  while (iVar2 != 0) {
    pvVar1 = heap->element[iVar2].data;
    if (pvVar1 != (void *)0x0) {
      (*freefunc)(pvVar1);
      iVar2 = heap->size;
    }
    iVar2 = iVar2 + -1;
    heap->size = iVar2;
  }
  return;
}



void __regparm3 __downheap(heap_t *heap,int k)

{
  int iVar1;
  double dVar2;
  heap_element *phVar3;
  int iVar4;
  void *pvVar5;
  double dVar6;
  int iVar7;
  int iVar8;
  heap_element *phVar9;
  double *pdVar10;
  int local_2c;
  
  phVar3 = heap->element;
  phVar9 = phVar3 + k;
  iVar4 = heap->size;
  pvVar5 = phVar9->data;
  dVar2 = (double)phVar9->cost;
  iVar7 = iVar4 / 2;
  if (k <= iVar7) {
    while (iVar8 = k * 2, iVar4 <= iVar8) {
      phVar9 = heap->element + k * 2;
      dVar6 = (double)phVar9->cost;
LAB_0809e3c2:
      local_2c = k * 0x18;
      if (dVar2 < dVar6) goto LAB_0809e430;
LAB_0809e3c6:
      *(undefined4 *)&phVar3[k].cost = *(undefined4 *)&phVar9->cost;
      *(undefined4 *)((int)&phVar3[k].cost + 4) = *(undefined4 *)((int)&phVar9->cost + 4);
      phVar3[k].data = phVar9->data;
      k = iVar8;
      if (iVar7 < iVar8) {
        pdVar10 = (double *)((int)&heap->element->cost + local_2c);
        *(void **)(pdVar10 + 1) = pvVar5;
        *pdVar10 = dVar2;
        return;
      }
    }
    phVar9 = phVar3 + k * 2;
    iVar1 = iVar8 + 1;
    dVar6 = (double)phVar9->cost;
    local_2c = iVar1 * 0xc;
    if (dVar6 <= (double)phVar3[iVar1].cost) goto LAB_0809e3c2;
    phVar9 = phVar3 + iVar1;
    iVar8 = iVar1;
    if ((double)phVar9->cost <= dVar2) goto LAB_0809e3c6;
LAB_0809e430:
    phVar9 = phVar3 + k;
  }
  *(double *)&phVar9->cost = dVar2;
  phVar9->data = pvVar5;
  return;
}



void * heap_remove_smallest(heap_t *heap)

{
  heap_element *phVar1;
  void *pvVar2;
  int iVar3;
  undefined4 uVar4;
  
  phVar1 = heap->element;
  pvVar2 = phVar1[1].data;
  iVar3 = heap->size;
  uVar4 = *(undefined4 *)&phVar1[iVar3].cost;
  heap->size = iVar3 + -1;
  *(undefined4 *)&phVar1[1].cost = uVar4;
  *(undefined4 *)((int)&phVar1[1].cost + 4) = *(undefined4 *)((int)&phVar1[iVar3].cost + 4);
  phVar1[1].data = phVar1[iVar3].data;
  if (0 < iVar3 + -1) {
    __downheap(heap,1);
  }
  return pvVar2;
}



void * heap_replace(heap_t *heap,cost_t cost,void *data)

{
  heap_element *phVar1;
  
  if (heap->size != 0) {
    phVar1 = heap->element;
    phVar1->data = data;
    phVar1->cost = cost;
    __downheap(heap,0);
    data = heap->element->data;
  }
  return data;
}



int heap_is_empty(heap_t *heap)

{
  return (uint)(heap->size == 0);
}



int heap_size(heap_t *heap)

{
  return heap->size;
}



void heap_insert(heap_t *heap,cost_t cost,void *data)

{
  double dVar1;
  int iVar2;
  heap_element *phVar3;
  size_t __size;
  heap_element *phVar4;
  heap_element *phVar5;
  int iVar6;
  int iVar7;
  
  iVar2 = heap->max;
  iVar7 = heap->size + 1;
  if (iVar2 <= iVar7) {
    heap->max = iVar2 * 2;
    if (iVar2 * 2 == 0) {
      heap->max = 0x100;
      __size = 0xc00;
    }
    else {
      __size = iVar2 * 0x18;
    }
    phVar4 = (heap_element *)realloc(heap->element,__size);
    iVar7 = heap->size + 1;
    heap->element = phVar4;
  }
  phVar3 = heap->element;
  heap->size = iVar7;
  phVar3[iVar7].data = data;
  phVar3[iVar7].cost = cost;
  phVar3->cost = MIN_COST;
  phVar4 = phVar3 + iVar7;
  dVar1 = (double)phVar4->cost;
  phVar5 = phVar3 + iVar7 / 2;
  iVar2 = iVar7 / 2;
  if (dVar1 < (double)phVar5->cost) {
    do {
      iVar6 = iVar2;
      *(undefined4 *)&phVar3[iVar7].cost = *(undefined4 *)&phVar5->cost;
      *(undefined4 *)((int)&phVar3[iVar7].cost + 4) = *(undefined4 *)((int)&phVar5->cost + 4);
      phVar3[iVar7].data = phVar5->data;
      phVar5 = phVar3 + iVar6 / 2;
      iVar2 = iVar6 / 2;
      iVar7 = iVar6;
    } while (dVar1 < (double)phVar5->cost);
    phVar4 = phVar3 + iVar6;
  }
  *(double *)&phVar4->cost = dVar1;
  phVar4->data = data;
  return;
}



void heap_destroy(heap_t **heap)

{
  heap_t *__ptr;
  
  __ptr = *heap;
  if (__ptr->element != (heap_element *)0x0) {
    free(__ptr->element);
    __ptr = *heap;
  }
  free(__ptr);
  *heap = (heap_t *)0x0;
  return;
}



heap_t * heap_create(void)

{
  heap_t *phVar1;
  
  if ((double)MIN_COST == 0.00000000) {
    MIN_COST = -99999999999999991611392.00000000;
  }
  phVar1 = (heap_t *)calloc(1,0xc);
  return phVar1;
}



PointTypePtr AdjustInsertPoint(void)

{
  void *pvVar1;
  PointType InsertedPoint;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  AttachedLineType myline;
  
  pvVar1 = Crosshair.AttachedObject.Ptr2;
  if (Crosshair.AttachedObject.State == 0) {
    return (PointTypePtr)0x0;
  }
  Crosshair.AttachedObject.Ptr3 = (void *)0x816c718;
  iVar2 = (*gui->shift_is_pressed)();
  if (iVar2 == 0) {
    if ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0) {
      return (PointTypePtr)0x816c718;
    }
    return (PointTypePtr)0x816c718;
  }
  iVar3 = Crosshair.X - *(int *)((int)pvVar1 + 0x40);
  iVar5 = Crosshair.Y - *(int *)((int)pvVar1 + 0x44);
  iVar2 = Crosshair.X - *(int *)((int)pvVar1 + 0x2c);
  iVar4 = Crosshair.Y - *(int *)((int)pvVar1 + 0x30);
  if ((float10)(iVar5 * iVar5 + iVar3 * iVar3) <= (float10)(iVar4 * iVar4 + iVar2 * iVar2)) {
    myline.Point1.X = *(LocationType *)((int)pvVar1 + 0x40);
    myline.Point1.Y = *(LocationType *)((int)pvVar1 + 0x44);
    myline.Point1.X2 = *(LocationType *)((int)pvVar1 + 0x48);
    myline.Point1.Y2 = *(LocationType *)((int)pvVar1 + 0x4c);
    myline.Point1.ID = *(long *)((int)pvVar1 + 0x50);
  }
  else {
    myline.Point1.X = *(LocationType *)((int)pvVar1 + 0x2c);
    myline.Point1.Y = *(LocationType *)((int)pvVar1 + 0x30);
    myline.Point1.X2 = *(LocationType *)((int)pvVar1 + 0x34);
    myline.Point1.Y2 = *(LocationType *)((int)pvVar1 + 0x38);
    myline.Point1.ID = *(long *)((int)pvVar1 + 0x3c);
  }
  myline.Point2.X = myline.Point1.X;
  myline.Point2.Y = myline.Point1.Y;
  myline.Point2.X2 = myline.Point1.X2;
  myline.Point2.Y2 = myline.Point1.Y2;
  myline.Point2.ID = myline.Point1.ID;
  FortyFiveLine((AttachedLineTypePtr)&myline);
  return (PointTypePtr)0x816c718;
}



void * InsertPointIntoObject
                 (int Type,void *Ptr1,void *Ptr2,Cardinal *Ptr3,LocationType DX,LocationType DY,
                 Boolean Force)

{
  void *pvVar1;
  
  InsertX = DX;
  InsertY = DY;
  InsertAt = *Ptr3;
  Forcible = Force;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&InsertFunctions,Type,Ptr1,Ptr2,Ptr3);
  if (pvVar1 != (void *)0x0) {
    IncrementUndoSerialNumber();
  }
  return pvVar1;
}



void * InsertPointIntoRat(RatTypePtr *Rat)

{
  LineTypePtr Line;
  LineTypePtr Line_00;
  void *Ptr1;
  LayerTypePtr Layer;
  
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  Line = CreateDrawnLineOnLayer
                   (Layer,(Rat->Point1).X,(Rat->Point1).Y,InsertX,InsertY,Settings.LineThickness,
                    Settings.Keepaway * 2,Rat->Flags);
  Line_00 = (LineTypePtr)0x0;
  if (Line != (LineTypePtr)0x0) {
    if (PCB->SilkActive == '\0') {
      Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Ptr1 = (void *)(&PCB->Data->field_0x4c +
                     ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    AddObjectToCreateUndoList(4,Ptr1,Line,Line);
    EraseRat(Rat);
    if (PCB->SilkActive == '\0') {
      Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Layer = (LayerTypePtr)
              (&PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    DrawLine(Layer,Line,0);
    if (PCB->SilkActive == '\0') {
      Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Layer = (LayerTypePtr)
              (&PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    Line_00 = CreateDrawnLineOnLayer
                        (Layer,(Rat->Point2).X,(Rat->Point2).Y,InsertX,InsertY,
                         Settings.LineThickness,Settings.Keepaway * 2,Rat->Flags);
    if (Line_00 != (LineTypePtr)0x0) {
      if (PCB->SilkActive == '\0') {
        Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Ptr1 = (void *)(&PCB->Data->field_0x4c +
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      AddObjectToCreateUndoList(4,Ptr1,Line_00,Line_00);
      if (PCB->SilkActive == '\0') {
        Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Layer = (LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      DrawLine(Layer,Line_00,0);
    }
    MoveObjectToRemoveUndoList(0x20,Rat,Rat,Rat);
    Draw();
  }
  return Line_00;
}



void * InsertPointIntoPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  int iVar1;
  long lVar2;
  LocationType LVar3;
  LocationType LVar4;
  LocationType LVar5;
  LocationType LVar6;
  Cardinal CVar7;
  Boolean BVar8;
  PointTypePtr pPVar9;
  uint uVar10;
  int iVar11;
  int in_GS_OFFSET;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Forcible == '\0') {
    line.Thickness = 0;
    if (InsertAt == 0) {
      CVar7 = Polygon->PointN;
      pPVar9 = Polygon->Points;
    }
    else {
      pPVar9 = Polygon->Points;
      CVar7 = InsertAt;
    }
    iVar11 = CVar7 * 5 + -5;
    line.Point1.X = (&pPVar9->X)[iVar11];
    line.Point1.Y = (&pPVar9->Y)[iVar11];
    line.Point1.X2 = (&pPVar9->X2)[iVar11];
    line.Point1.Y2 = (&pPVar9->Y2)[iVar11];
    line.Point1.ID = (&pPVar9->ID)[iVar11];
    line.Point2.X = pPVar9[InsertAt].X;
    line.Point2.Y = pPVar9[InsertAt].Y;
    line.Point2.X2 = pPVar9[InsertAt].X2;
    line.Point2.Y2 = pPVar9[InsertAt].Y2;
    line.Point2.ID = pPVar9[InsertAt].ID;
    BVar8 = IsPointOnLine((float)InsertX,(float)InsertY,0.00000000,(LineTypePtr)&line);
    pPVar9 = (PointTypePtr)0x0;
    if (BVar8 != '\0') goto LAB_0809eed3;
  }
  ErasePolygon(Polygon);
  r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
  pPVar9 = CreateNewPointInPolygon(Polygon,InsertX,InsertY);
  CVar7 = InsertAt;
  lVar2 = pPVar9->ID;
  LVar3 = pPVar9->Y2;
  LVar4 = pPVar9->X2;
  LVar5 = pPVar9->Y;
  LVar6 = pPVar9->X;
  uVar10 = Polygon->PointN - 1;
  if (InsertAt < uVar10) {
    pPVar9 = Polygon->Points;
    iVar11 = Polygon->PointN * 0x14;
    do {
      uVar10 = uVar10 - 1;
      *(undefined4 *)((int)&pPVar9[-1].X + iVar11) = *(undefined4 *)((int)&pPVar9[-2].X + iVar11);
      *(undefined4 *)((int)&pPVar9[-1].Y + iVar11) =
           *(undefined4 *)(&DAT_ffffffdc + (int)&pPVar9->X + iVar11);
      *(undefined4 *)((int)&pPVar9[-1].X2 + iVar11) = *(undefined4 *)((int)&pPVar9[-2].X2 + iVar11);
      *(undefined4 *)((int)&pPVar9[-1].Y2 + iVar11) = *(undefined4 *)((int)&pPVar9[-2].Y2 + iVar11);
      *(undefined4 *)((int)&pPVar9[-1].ID + iVar11) =
           *(undefined4 *)(&DAT_ffffffe8 + (int)&pPVar9->X + iVar11);
      iVar11 = iVar11 + -0x14;
    } while (CVar7 < uVar10);
  }
  pPVar9 = Polygon->Points + CVar7;
  pPVar9->ID = lVar2;
  pPVar9->Y2 = LVar3;
  pPVar9->X2 = LVar4;
  pPVar9->Y = LVar5;
  pPVar9->X = LVar6;
  SetChangedFlag('\x01');
  AddObjectToInsertPointUndoList(0x800,Layer,Polygon,Polygon->Points + InsertAt);
  SetPolygonBoundingBox(Polygon);
  r_insert_entry(Layer->polygon_tree,(BoxType *)Polygon,0);
  InitClip(PCB->Data,Layer,(PolygonType *)Polygon);
  if ((Forcible != '\0') || (BVar8 = RemoveExcessPolygonPoints(Layer,Polygon), BVar8 == '\0')) {
    DrawPolygon(Layer,Polygon,0);
    Draw();
  }
  pPVar9 = Polygon->Points + InsertAt;
LAB_0809eed3:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pPVar9;
}



void * InsertPointIntoLine(LayerTypePtr Layer,LineTypePtr Line)

{
  int X2;
  LineTypePtr Line_00;
  int Y2;
  
  if (((Line->Point1).X == InsertX) && ((Line->Point1).Y == InsertY)) {
    Line_00 = (LineTypePtr)0x0;
  }
  else {
    X2 = (Line->Point2).X;
    if (InsertX == X2) {
      Y2 = (Line->Point2).Y;
      if (Y2 == InsertY) {
        return (void *)0x0;
      }
    }
    else {
      Y2 = (Line->Point2).Y;
    }
    AddObjectToMoveUndoList(0x1000,Layer,Line,&Line->Point2,InsertX - X2,InsertY - Y2);
    EraseLine(Line);
    r_delete_entry(Layer->line_tree,(BoxType *)Line);
    (Line->Point2).X = InsertX;
    (Line->Point2).Y = InsertY;
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,(BoxType *)Line,0);
    DrawLine(Layer,Line,0);
    Line_00 = CreateDrawnLineOnLayer
                        (Layer,InsertX,InsertY,X2,Y2,Line->Thickness,Line->Clearance,Line->Flags);
    if (Line_00 != (LineTypePtr)0x0) {
      AddObjectToCreateUndoList(4,Layer,Line_00,Line_00);
      DrawLine(Layer,Line_00,0);
    }
    Draw();
  }
  return Line_00;
}



void insertSegment(SegmentTree *st,int n,LocationType Y1,LocationType Y2)

{
  SegmentTreeNode *pSVar1;
  SegmentTreeNode *pSVar2;
  int iVar3;
  
  pSVar1 = st->nodes;
  pSVar2 = pSVar1 + n;
  if ((pSVar2->left < Y1) || (pSVar2->right != Y2 && Y2 <= pSVar2->right)) {
    iVar3 = pSVar1[n * 2 + 1].left;
    if (Y1 < iVar3) {
      insertSegment(st,n * 2,Y1,Y2);
    }
    if (iVar3 < Y2) {
      insertSegment(st,n * 2 + 1,Y1,Y2);
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
    else {
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
  }
  else {
    iVar3 = pSVar2->covered + 1;
    pSVar2->covered = iVar3;
  }
  if (iVar3 < 1) {
    iVar3 = 0;
    if (n < st->size / 2) {
      iVar3 = pSVar1[n * 2 + 1].area + pSVar1[n * 2].area;
    }
  }
  else {
    iVar3 = pSVar2->right - pSVar2->left;
  }
  pSVar2->area = iVar3;
  return;
}



void deleteSegment(SegmentTree *st,int n,LocationType Y1,LocationType Y2)

{
  SegmentTreeNode *pSVar1;
  SegmentTreeNode *pSVar2;
  int iVar3;
  
  pSVar1 = st->nodes;
  pSVar2 = pSVar1 + n;
  if ((pSVar2->left < Y1) || (pSVar2->right != Y2 && Y2 <= pSVar2->right)) {
    iVar3 = pSVar1[n * 2 + 1].left;
    if (Y1 < iVar3) {
      deleteSegment(st,n * 2,Y1,Y2);
    }
    if (iVar3 < Y2) {
      deleteSegment(st,n * 2 + 1,Y1,Y2);
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
    else {
      pSVar1 = st->nodes;
      pSVar2 = pSVar1 + n;
      iVar3 = pSVar2->covered;
    }
  }
  else {
    iVar3 = pSVar2->covered + -1;
    pSVar2->covered = iVar3;
  }
  if (iVar3 < 1) {
    iVar3 = 0;
    if (n < st->size / 2) {
      iVar3 = pSVar1[n * 2 + 1].area + pSVar1[n * 2].area;
    }
  }
  else {
    iVar3 = pSVar2->right - pSVar2->left;
  }
  pSVar2->area = iVar3;
  return;
}



int compareleft(void *ptr1,void *ptr2)

{
  return **(int **)ptr1 - **(int **)ptr2;
}



int compareright(void *ptr1,void *ptr2)

{
  return *(int *)(*(int *)ptr1 + 8) - *(int *)(*(int *)ptr2 + 8);
}



int comparepos(void *ptr1,void *ptr2)

{
  return *(int *)ptr1 - *(int *)ptr2;
}



// WARNING: Could not reconcile some variable overlaps

double ComputeUnionArea(BoxListTypePtr_conflict *boxlist)

{
  LocationType *pLVar1;
  BoxTypePtr pBVar2;
  size_t Number;
  int *__base;
  uint uVar3;
  int iVar4;
  int iVar5;
  int *piVar6;
  int **__base_00;
  void *__base_01;
  uint __nmemb;
  int iVar7;
  SegmentTreeNode *pSVar8;
  LocationType *pLVar9;
  int iVar10;
  uint uVar11;
  bool bVar12;
  size_t local_40;
  double local_3c;
  int local_34;
  SegmentTree segtree;
  
  if (boxlist->BoxN == 0) {
    return 0.00000000;
  }
  Number = boxlist->BoxN * 2;
  __base = (int *)MyCalloc(Number,4,"createSortedYList");
  if (boxlist->BoxN != 0) {
    pBVar2 = boxlist->Box;
    __nmemb = 0;
    do {
      uVar3 = __nmemb + 1;
      __base[__nmemb * 2] = pBVar2[__nmemb].Y1;
      __base[__nmemb * 2 + 1] = pBVar2[__nmemb].Y2;
      __nmemb = uVar3;
    } while (uVar3 <= boxlist->BoxN && boxlist->BoxN != uVar3);
  }
  qsort(__base,Number,4,comparepos);
  if (0 < (int)Number) {
    iVar10 = 0;
    iVar7 = 0;
    iVar4 = 0;
    do {
      if (iVar4 == 0) {
        iVar5 = *__base;
LAB_0809f45a:
        __base[iVar10] = iVar5;
        iVar10 = iVar10 + 1;
        iVar7 = iVar5;
      }
      else {
        iVar5 = __base[iVar4];
        bVar12 = iVar5 != iVar7;
        iVar7 = iVar5;
        if (bVar12) goto LAB_0809f45a;
      }
      if (Number == iVar4 + 1U) goto LAB_0809f480;
      iVar4 = iVar4 + 1;
    } while( true );
  }
  local_3c._0_4_ = (SegmentTreeNode *)MyCalloc(2,0x10,"createSegmentTree");
  local_40 = 2;
  local_3c._0_4_[1].left = 10;
  local_3c._0_4_[1].right = 0xb;
LAB_0809f56f:
  segtree.size = local_40;
  segtree.nodes = local_3c._0_4_;
  free(__base);
  __base_00 = (int **)MyCalloc(boxlist->BoxN,4,"ComputeUnionArea(1)");
  __base_01 = MyCalloc(boxlist->BoxN,4,"ComputeUnionArea(2)");
  __nmemb = boxlist->BoxN;
  if (__nmemb != 0) {
    uVar3 = 0;
    do {
      pBVar2 = boxlist->Box;
      *(BoxTypePtr *)((int)__base_01 + uVar3 * 4) = pBVar2 + uVar3;
      *(BoxTypePtr *)(__base_00 + uVar3) = pBVar2 + uVar3;
      uVar3 = uVar3 + 1;
    } while (uVar3 < __nmemb);
  }
  qsort(__base_00,__nmemb,4,compareleft);
  qsort(__base_01,boxlist->BoxN,4,compareright);
  local_3c = 0.00000000;
  uVar3 = 0;
  __nmemb = boxlist->BoxN;
  if (__nmemb != 0) {
    uVar11 = 0;
    iVar10 = **__base_00;
    do {
      if (uVar3 == __nmemb) {
        iVar7 = *(int *)((int)__base_01 + uVar11 * 4);
        iVar4 = *(int *)(iVar7 + 8);
LAB_0809f678:
        iVar5 = iVar4;
        if (iVar10 != iVar5) {
          local_3c = (double)segtree.nodes[1].area * (double)(iVar5 - iVar10) + local_3c;
        }
        uVar11 = uVar11 + 1;
        deleteSegment(&segtree,1,*(LocationType *)(iVar7 + 4),*(LocationType *)(iVar7 + 0xc));
      }
      else {
        iVar7 = *(int *)((int)__base_01 + uVar11 * 4);
        __base = __base_00[uVar3];
        iVar5 = *__base;
        iVar4 = *(int *)(iVar7 + 8);
        if (*(int *)(iVar7 + 8) < iVar5) goto LAB_0809f678;
        if (iVar10 != iVar5) {
          local_3c = (double)segtree.nodes[1].area * (double)(iVar5 - iVar10) + local_3c;
        }
        uVar3 = uVar3 + 1;
        insertSegment(&segtree,1,__base[1],__base[3]);
      }
      __nmemb = boxlist->BoxN;
      iVar10 = iVar5;
    } while (uVar11 < __nmemb);
  }
  free(__base_00);
  free(__base_01);
  free(segtree.nodes);
  return local_3c * 0.00010000;
LAB_0809f480:
  if (iVar10 == 0) {
    iVar7 = 0;
    iVar4 = 0x10;
    local_40 = 2;
    local_34 = 1;
  }
  else {
    iVar7 = iVar10;
    local_34 = 1;
    do {
      iVar4 = local_34;
      local_34 = iVar4 * 2;
      iVar7 = iVar7 / 2;
    } while (iVar7 != 0);
    local_40 = iVar4 * 4;
    iVar4 = (local_40 - 1) * 0x10;
    iVar7 = local_40 - 2;
  }
  local_3c._0_4_ = (SegmentTreeNode *)MyCalloc(local_40,0x10,"createSegmentTree");
  piVar6 = (int *)((int)&(local_3c._0_4_)->left + iVar4);
  iVar4 = 0xb;
  iVar5 = 10;
  if (iVar10 != 0) {
    iVar10 = iVar10 + -1;
    iVar5 = __base[iVar10];
    iVar4 = iVar5 + 1;
  }
  *piVar6 = iVar5;
  piVar6[1] = iVar4;
  if (local_34 <= iVar7) {
    pSVar8 = local_3c._0_4_ + iVar7 + 1;
    piVar6 = &local_3c._0_4_[iVar7].right;
    do {
      iVar4 = pSVar8->left;
      *piVar6 = iVar4;
      if (iVar10 == 0) {
        iVar4 = iVar4 + -1;
      }
      else {
        iVar10 = iVar10 + -1;
        iVar4 = __base[iVar10];
      }
      piVar6[-1] = iVar4;
      iVar7 = iVar7 + -1;
      pSVar8 = pSVar8 + -1;
      piVar6 = piVar6 + -4;
    } while (local_34 <= iVar7);
    iVar7 = local_34 + -1;
  }
  if (0 < iVar7) {
    pLVar9 = &local_3c._0_4_[iVar7].right;
    iVar4 = 0;
    iVar10 = iVar7 * 2;
    do {
      *pLVar9 = *(LocationType *)((int)&(local_3c._0_4_ + iVar10)[1].right + iVar4);
      pLVar1 = (LocationType *)((int)&local_3c._0_4_[iVar10].left + iVar4);
      iVar4 = iVar4 + -0x20;
      pLVar9[-1] = *pLVar1;
      pLVar9 = pLVar9 + -4;
      iVar7 = iVar7 + -1;
    } while (iVar7 != 0);
  }
  goto LAB_0809f56f;
}



double ComputeIntersectionArea(BoxListTypePtr_conflict *boxlist)

{
  int *piVar1;
  int *piVar2;
  int *piVar3;
  double dVar4;
  int *piVar5;
  BoxTypePtr pBVar6;
  uint uVar7;
  double dVar8;
  
  if (boxlist->BoxN == 0) {
    dVar4 = 0.00000000;
  }
  else {
    pBVar6 = boxlist->Box;
    dVar4 = 0.00000000;
    uVar7 = 0;
    do {
      piVar1 = &pBVar6->X2;
      uVar7 = uVar7 + 1;
      piVar5 = &pBVar6->X1;
      piVar2 = &pBVar6->Y2;
      piVar3 = &pBVar6->Y1;
      pBVar6 = pBVar6 + 1;
      dVar4 = (double)(*piVar2 - *piVar3) * (double)(*piVar1 - *piVar5) + dVar4;
    } while (uVar7 < boxlist->BoxN);
  }
  dVar8 = ComputeUnionArea(boxlist);
  return dVar4 * 0.00010000 - dVar8;
}



void FortyFiveLine(AttachedLineTypePtr Line)

{
  int iVar1;
  int iVar2;
  double dVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  
  iVar1 = (Line->Point1).X;
  iVar2 = (Line->Point1).Y;
  uVar4 = Crosshair.Y - iVar2;
  uVar6 = Crosshair.X - iVar1;
  if (uVar6 == 0) {
    if (uVar4 == 0) {
      return;
    }
    uVar8 = (uint)((int)uVar4 < 1) << 2;
  }
  else {
    dVar3 = (double)uVar4 / (double)uVar6;
    if (dVar3 <= 0.57735027) {
      uVar8 = 2;
      if (dVar3 < -0.57735027) {
        uVar8 = (uint)(-1.73205081 <= dVar3) * 3;
      }
    }
    else {
      uVar8 = (uint)(dVar3 <= 1.73205081);
    }
    if ((int)uVar6 < 0) {
      uVar8 = uVar8 + 4;
    }
  }
  iVar5 = (uVar4 ^ (int)uVar4 >> 0x1f) - ((int)uVar4 >> 0x1f);
  iVar7 = (uVar6 ^ (int)uVar6 >> 0x1f) - ((int)uVar6 >> 0x1f);
  if (iVar7 < iVar5) {
    iVar5 = iVar7;
  }
  switch(uVar8) {
  default:
    (Line->Point2).X = iVar1;
    (Line->Point2).Y = Crosshair.Y;
    break;
  case 1:
    iVar2 = (Line->Point1).Y;
    (Line->Point2).X = iVar5 + iVar1;
    (Line->Point2).Y = iVar5 + iVar2;
    break;
  case 2:
  case 6:
    (Line->Point2).X = Crosshair.X;
    (Line->Point2).Y = iVar2;
    break;
  case 3:
    (Line->Point2).X = iVar5 + iVar1;
    (Line->Point2).Y = iVar2 - iVar5;
    break;
  case 5:
    (Line->Point2).X = iVar1 - iVar5;
    (Line->Point2).Y = iVar2 - iVar5;
    break;
  case 7:
    iVar2 = (Line->Point1).Y;
    (Line->Point2).X = iVar1 - iVar5;
    (Line->Point2).Y = iVar5 + iVar2;
  }
  return;
}



void AdjustAttachedLine(void)

{
  int iVar1;
  
  if (Crosshair.AttachedLine.State != 0) {
    if (Settings.Mode == 2) {
      iVar1 = (*gui->control_is_pressed)();
      if (iVar1 != 0) {
        Crosshair.AttachedLine.draw = '\0';
        return;
      }
    }
    Crosshair.AttachedLine.draw = '\x01';
    if ((PCB->RatDraw == '\0') && ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0)) {
      FortyFiveLine((AttachedLineTypePtr)&Crosshair.AttachedLine);
      return;
    }
    Crosshair.AttachedLine.Point2.X = Crosshair.X;
    Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
  }
  return;
}



void AdjustTwoLine(int way)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint local_20;
  
  if (Crosshair.AttachedLine.State != 0) {
    iVar1 = (*gui->control_is_pressed)();
    if (iVar1 == 0) {
      Crosshair.AttachedLine.draw = '\x01';
      if ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0) {
        iVar1 = (*gui->shift_is_pressed)();
        if (iVar1 != 0) {
          way = ZEXT14(way == 0);
        }
        uVar2 = Crosshair.X - Crosshair.AttachedLine.Point1.X;
        uVar3 = Crosshair.Y - Crosshair.AttachedLine.Point1.Y;
        uVar4 = (int)uVar2 >> 0x1f;
        uVar5 = (int)uVar3 >> 0x1f;
        if (way == 0) {
          uVar4 = (uVar4 ^ uVar2) - uVar4;
          uVar5 = (uVar5 ^ uVar3) - uVar5;
          if ((int)uVar5 < (int)uVar4) {
            if (((int)uVar2 < 1) && (uVar5 = -uVar5, uVar2 == 0)) {
              uVar5 = way;
            }
            Crosshair.AttachedLine.Point2.X = Crosshair.X - uVar5;
            Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedLine.Point1.Y;
          }
          else {
            Crosshair.AttachedLine.Point2.X = Crosshair.AttachedLine.Point1.X;
            local_20 = uVar4;
            if (((int)uVar3 < 1) && (local_20 = way, uVar3 != 0)) {
              local_20 = -uVar4;
            }
            Crosshair.AttachedLine.Point2.Y = Crosshair.Y - local_20;
          }
        }
        else {
          iVar1 = (uVar4 ^ uVar2) - uVar4;
          iVar6 = (uVar5 ^ uVar3) - uVar5;
          if (iVar6 < iVar1) {
            uVar4 = 1;
            if ((int)uVar2 < 1) {
              uVar4 = ~-(uint)(uVar2 == 0);
            }
            Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
            Crosshair.AttachedLine.Point2.X = uVar4 * iVar6 + Crosshair.AttachedLine.Point1.X;
          }
          else {
            Crosshair.AttachedLine.Point2.X = Crosshair.X;
            uVar4 = 1;
            if ((int)uVar3 < 1) {
              uVar4 = ~-(uint)(uVar3 == 0);
            }
            Crosshair.AttachedLine.Point2.Y = uVar4 * iVar1 + Crosshair.AttachedLine.Point1.Y;
          }
        }
      }
      else {
        Crosshair.AttachedLine.Point2.X = Crosshair.X;
        Crosshair.AttachedLine.Point2.Y = Crosshair.Y;
      }
    }
    else {
      Crosshair.AttachedLine.draw = '\0';
    }
  }
  return;
}



float __regparm3 drc_lines(PointTypePtr end,Boolean way)

{
  uint *puVar1;
  int iVar2;
  Cardinal Layer;
  bool bVar3;
  float fVar4;
  uint uVar5;
  bool bVar6;
  uint uVar7;
  bool bVar8;
  uint uVar9;
  int Layer_00;
  int iVar10;
  uint uVar11;
  DataTypePtr *pDVar12;
  Cardinal *pCVar13;
  int in_GS_OFFSET;
  uint local_1dc;
  LocationType local_1d8;
  LocationType local_1d4;
  float local_1cc;
  float local_1c8;
  int local_1c4;
  uint local_1c0;
  float local_1bc;
  uint local_1b0;
  float local_1a8;
  float local_1a4;
  uint local_1a0;
  uint local_19c;
  uint local_198;
  ulong local_18c;
  undefined4 local_188;
  undefined4 local_184;
  drc_info info;
  LineType line2;
  LineType line1;
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags((FlagType *)&local_18c,0);
  line2.Flags.t._0_4_ = local_188;
  line1.Flags.t._0_4_ = local_188;
  line2.Flags.f = local_18c;
  line1.Flags.f = local_18c;
  line2.Flags.t._4_4_ = local_184;
  line1.Flags.t._4_4_ = local_184;
  line2.Clearance = 0;
  line1.Clearance = 0;
  line1.Point1.Y = Crosshair.AttachedLine.Point1.Y;
  line2.Thickness = PCB->Bloat * 2 + 2 + Settings.LineThickness;
  line1.Point1.X = Crosshair.AttachedLine.Point1.X;
  local_1a0 = end->Y - Crosshair.AttachedLine.Point1.Y;
  local_19c = end->X - Crosshair.AttachedLine.Point1.X;
  uVar9 = (local_19c ^ (int)local_19c >> 0x1f) - ((int)local_19c >> 0x1f);
  local_1dc = (local_1a0 ^ (int)local_1a0 >> 0x1f) - ((int)local_1a0 >> 0x1f);
  bVar3 = (int)local_1dc < (int)uVar9;
  if (bVar3) {
    local_1dc = uVar9;
  }
  Layer_00 = LayerStack[0];
  if (PCB->SilkActive != '\0') {
    Layer_00 = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
  }
  line1.Thickness = line2.Thickness;
  Layer_00 = GetGroupOfLayer(Layer_00);
  Layer = PCB->Data->LayerN;
  iVar10 = GetLayerGroupNumberByNumber(Layer);
  if (iVar10 == Layer_00) {
    local_1c4 = Layer + 10;
    info.solder = '\x01';
  }
  else {
    info.solder = '\0';
    local_1c4 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  }
  local_1d4 = line1.Point1.X;
  local_1d8 = line1.Point1.Y;
  if (local_1dc == 0xffffffff) {
    local_1bc = 0.00000000;
LAB_080a061a:
    Layer_00 = *(int *)(in_GS_OFFSET + 0x14);
    end->X = local_1d4;
    end->Y = local_1d8;
    if (iVar2 == Layer_00) {
      return local_1bc;
    }
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  local_1bc = 0.00000000;
  local_1cc = 0.50000000;
  local_1c0 = local_1dc;
  local_1c8 = 1.00000000;
  if (!bVar3) goto LAB_080a009d;
LAB_0809fd5a:
  uVar9 = local_1c0;
  if ((int)local_19c < 1) {
    uVar9 = 0;
    if (local_19c != 0) {
      uVar9 = -local_1c0;
    }
  }
  local_1a0 = end->Y - line1.Point1.Y;
  local_1b0 = (local_1a0 ^ (int)local_1a0 >> 0x1f) - ((int)local_1a0 >> 0x1f);
  local_19c = uVar9;
LAB_0809fd95:
  local_1a8 = 0.50000000;
  local_198 = local_1b0;
  local_1a4 = 1.00000000;
  bVar8 = true;
  do {
    uVar9 = (int)local_198 >> 0x1f;
    if (bVar3) {
      if ((int)local_1a0 < 1) {
        if (local_1a0 == 0) {
          uVar11 = 0;
          local_1a0 = 0;
        }
        else {
          local_1a0 = -local_198;
          uVar11 = ((int)local_1a0 >> 0x1f ^ local_1a0) - ((int)local_1a0 >> 0x1f);
        }
      }
      else {
        uVar11 = (local_198 ^ uVar9) - uVar9;
        local_1a0 = local_198;
      }
      uVar9 = (local_19c ^ (int)local_19c >> 0x1f) - ((int)local_19c >> 0x1f);
      if ((int)uVar9 <= (int)uVar11) goto LAB_080a0356;
      if (way == '\0') {
        uVar9 = uVar11;
        if ((int)local_19c < 1) {
          uVar9 = 0;
          if (local_19c != 0) {
            uVar9 = -uVar11;
          }
        }
        line1.Point2.X = (line1.Point1.X + local_19c) - uVar9;
        uVar11 = 0;
      }
      else {
        uVar9 = uVar11;
        if ((int)local_19c < 1) {
          uVar9 = 0;
          if (local_19c != 0) {
            uVar9 = -uVar11;
          }
        }
        line1.Point2.X = uVar9 + line1.Point1.X;
        uVar11 = local_1a0;
      }
LAB_0809fe3c:
      line1.Point2.Y = line1.Point1.Y + uVar11;
      bVar6 = true;
      line2.Point2.X = local_19c + line1.Point1.X;
      line2.Point2.Y = local_1a0 + line1.Point1.Y;
    }
    else {
      if ((int)local_19c < 1) {
        if (local_19c == 0) {
          uVar9 = 0;
          local_19c = 0;
        }
        else {
          local_19c = -local_198;
          uVar9 = ((int)local_19c >> 0x1f ^ local_19c) - ((int)local_19c >> 0x1f);
        }
      }
      else {
        uVar9 = (local_198 ^ uVar9) - uVar9;
        local_19c = local_198;
      }
      uVar11 = (local_1a0 ^ (int)local_1a0 >> 0x1f) - ((int)local_1a0 >> 0x1f);
      if (((int)uVar9 <= (int)uVar11) && (!bVar3)) {
        if (way == '\0') {
          line1.Point2.X = line1.Point1.X;
          uVar11 = uVar9;
          if ((int)local_1a0 < 1) {
            uVar11 = 0;
            if (local_1a0 != 0) {
              uVar11 = -uVar9;
            }
          }
          uVar11 = local_1a0 - uVar11;
        }
        else {
          line1.Point2.X = line1.Point1.X + local_19c;
          uVar11 = uVar9;
          if ((int)local_1a0 < 1) {
            uVar11 = 0;
            if (local_1a0 != 0) {
              uVar11 = -uVar9;
            }
          }
        }
        goto LAB_0809fe3c;
      }
LAB_080a0356:
      if (bVar3) {
        uVar5 = local_19c;
        if (way == '\0') {
          uVar7 = 0;
        }
        else {
          uVar7 = uVar9;
          if ((int)local_1a0 < 1) {
            uVar7 = 0;
            if (local_1a0 != 0) {
              uVar7 = -uVar9;
            }
          }
        }
      }
      else {
        uVar7 = local_1a0;
        if (way == '\0') {
          uVar5 = 0;
        }
        else {
          uVar5 = uVar11;
          if ((int)local_19c < 1) {
            uVar5 = 0;
            if (local_19c != 0) {
              uVar5 = -uVar11;
            }
          }
        }
      }
      line2.Point2.Y = uVar7 + line1.Point1.Y;
      line2.Point2.X = uVar5 + line1.Point1.X;
      bVar6 = false;
      line1.Point2.X = line2.Point2.X;
      line1.Point2.Y = line2.Point2.Y;
    }
    line2.Point1.X = line1.Point2.X;
    line2.Point1.Y = line1.Point2.Y;
    SetLineBoundingBox((LineTypePtr)&line1);
    SetLineBoundingBox((LineTypePtr)&line2);
    iVar10 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar10 == 0) {
      info.line = (LineTypePtr)&line1;
      r_search(PCB->Data->via_tree,(BoxType *)info.line,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               drcVia_callback,&info);
      r_search(PCB->Data->pin_tree,(BoxType *)&line1,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               drcVia_callback,&info);
      if ((local_1c4 == Layer_00) || (info.solder != '\0')) {
        r_search(PCB->Data->pad_tree,(BoxType *)&line1,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 drcPad_callback,&info);
      }
      if (bVar6) {
        info.line = (LineTypePtr)&line2;
        r_search(PCB->Data->via_tree,(BoxType *)&line2,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 drcVia_callback,&info);
        r_search(PCB->Data->pin_tree,(BoxType *)&line2,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 drcVia_callback,&info);
        if ((local_1c4 == Layer_00) || (info.solder != '\0')) {
          r_search(PCB->Data->pad_tree,(BoxType *)&line2,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   drcPad_callback,&info);
        }
      }
      pDVar12 = PCB->Data;
      iVar10 = *(int *)&pDVar12->field_0x48;
      if (*(int *)(iVar10 + 4 + (Layer_00 + 0x734) * 4) != 0) {
        uVar9 = 0;
        do {
          uVar11 = *(uint *)(iVar10 + 4 + (uVar9 + 0x744 + Layer_00 * 0x12) * 4);
          if (uVar11 < (uint)pDVar12->LayerN) {
            info.line = (LineTypePtr)&line1;
            pCVar13 = &pDVar12->ViaN + uVar11 * 0x17;
            r_search((rtree_t *)pCVar13[0x20],(BoxType *)&line1,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,drcLine_callback,&info);
            r_search((rtree_t *)pCVar13[0x23],(BoxType *)&line1,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,drcArc_callback,&info);
            if (bVar6) {
              info.line = (LineTypePtr)&line2;
              r_search((rtree_t *)pCVar13[0x20],(BoxType *)info.line,
                       (anon_subr_int_BoxType_ptr_void_ptr *)0x0,drcLine_callback,&info);
              r_search((rtree_t *)pCVar13[0x23],(BoxType *)&line2,
                       (anon_subr_int_BoxType_ptr_void_ptr *)0x0,drcArc_callback,&info);
            }
          }
          uVar9 = uVar9 + 1;
          pDVar12 = PCB->Data;
          iVar10 = *(int *)&pDVar12->field_0x48;
          puVar1 = (uint *)(iVar10 + 4 + (Layer_00 + 0x734) * 4);
        } while (uVar9 <= *puVar1 && *puVar1 != uVar9);
      }
      local_1a4 = local_1a4 + local_1a8;
      bVar8 = false;
      fVar4 = (float)(line2.Point2.Y - line1.Point1.Y) * (float)(line2.Point2.Y - line1.Point1.Y) +
              (float)(line2.Point2.X - line1.Point1.X) * (float)(line2.Point2.X - line1.Point1.X);
      if (local_1bc < fVar4) {
        local_1d8 = line2.Point2.Y;
        local_1d4 = line2.Point2.X;
        local_1bc = fVar4;
      }
    }
    else {
      local_1a4 = local_1a4 - local_1a8;
    }
    fVar4 = (float)local_1b0;
    if (local_1a4 * fVar4 < fVar4) {
      fVar4 = local_1a4 * fVar4;
    }
    if ((int)ROUND(fVar4) == local_198) break;
    local_1a8 = local_1a8 * 0.50000000;
    local_198 = (int)ROUND(fVar4);
  } while( true );
  if (!bVar8) {
    if (bVar3) {
      if (line2.Point2.X - line1.Point1.X == local_19c) goto LAB_080a0690;
    }
    else {
      if (line2.Point2.Y - line1.Point1.Y == local_1a0) {
LAB_080a0690:
        local_1c8 = local_1c8 + local_1cc;
        goto LAB_080a003a;
      }
    }
  }
  local_1c8 = local_1c8 - local_1cc;
LAB_080a003a:
  fVar4 = (float)local_1dc;
  if (local_1c8 * fVar4 < fVar4) {
    fVar4 = local_1c8 * fVar4;
  }
  uVar9 = (uint)ROUND(fVar4);
  if (uVar9 == local_1c0) goto LAB_080a061a;
  local_1cc = local_1cc * 0.50000000;
  local_1c0 = uVar9;
  if (bVar3) goto LAB_0809fd5a;
LAB_080a009d:
  uVar9 = local_1c0;
  if ((int)local_1a0 < 1) {
    uVar9 = 0;
    if (local_1a0 != 0) {
      uVar9 = -local_1c0;
    }
  }
  local_19c = end->X - line1.Point1.X;
  local_1b0 = (local_19c ^ (int)local_19c >> 0x1f) - ((int)local_19c >> 0x1f);
  local_1a0 = uVar9;
  goto LAB_0809fd95;
}



void EnforceLineDRC(void)

{
  char cVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  PointType rs;
  PointType r45;
  
  iVar2 = (*gui->mod1_is_pressed)();
  if (iVar2 == 0) {
    iVar2 = (*gui->control_is_pressed)();
    if ((iVar2 == 0) && (PCB->RatDraw == '\0')) {
      if (PCB->SilkActive == '\0') {
        iVar2 = PCB->Data->LayerN;
        iVar3 = LayerStack[0];
      }
      else {
        iVar2 = PCB->Data->LayerN;
        iVar3 = (uint)(Settings.ShowSolderSide == '\0') + iVar2;
      }
      if (iVar3 < iVar2) {
        r45.X = Crosshair.X;
        rs.X = Crosshair.X;
        r45.Y = Crosshair.Y;
        rs.Y = Crosshair.Y;
        fVar4 = drc_lines((PointTypePtr)&rs,'\0');
        fVar5 = drc_lines((PointTypePtr)&r45,'\x01');
        iVar2 = (*gui->shift_is_pressed)();
        cVar1 = (char)iVar2;
        if (cVar1 == '\0') {
          if (fVar5 >= fVar4) goto LAB_080a0824;
        }
        else {
          if (fVar5 < fVar4) {
LAB_080a0824:
            if (PCB->Clipping != 0) {
              PCB->Clipping = ~-(uint)(cVar1 == '\0') + 2;
            }
            Crosshair.X = r45.X;
            Crosshair.Y = r45.Y;
            return;
          }
        }
        if (PCB->Clipping != 0) {
          PCB->Clipping = 2 - (uint)(cVar1 == '\0');
        }
        Crosshair.X = rs.X;
        Crosshair.Y = rs.Y;
        return;
      }
    }
  }
  return;
}



int drcArc_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((*(byte *)&b[1].Y1 & 4) == 0) {
    BVar1 = LineArcIntersect(*(LineTypePtr *)cl,(ArcTypePtr *)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



int drcLine_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((*(byte *)&b[1].Y1 & 4) == 0) {
    BVar1 = LineLineIntersect((LineTypePtr)b,*(LineTypePtr *)cl);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



int drcPad_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((((uint)b[1].Y1 >> 7 & 1) == (int)*(char *)((int)cl + 4)) && ((b[1].Y1 & 4U) == 0)) {
    BVar1 = LinePadIntersect(*(LineTypePtr *)cl,(PadTypePtr *)b);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



int drcVia_callback(BoxType *b,void *cl)

{
  Boolean BVar1;
  
  if ((*(byte *)&b[1].Y1 & 4) == 0) {
    BVar1 = PinLineIntersect((PinTypePtr *)b,*(LineTypePtr *)cl);
    if (BVar1 != '\0') {
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 1;
}



char * lrealpath(char *filename)

{
  int iVar1;
  char *pcVar2;
  int in_GS_OFFSET;
  char buf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar2 = (char *)__realpath_chk(filename,buf,0x1000);
  if (pcVar2 == (char *)0x0) {
    pcVar2 = filename;
  }
  pcVar2 = (char *)__strdup(pcVar2);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pcVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 print_defaults_1(HID_Attribute *a,void *value)

{
  double dVar1;
  int iVar2;
  char *pcVar3;
  
  switch(a->type) {
  default:
    goto switchD_080a0a1f_caseD_0;
  case HID_Integer:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
    }
    else {
      iVar2 = *(int *)value;
    }
    __fprintf_chk(stderr,1,"%s %d\n",a->name,iVar2);
    return;
  case HID_Real:
    if (value == (void *)0x0) {
      dVar1 = (a->default_val).real_value;
    }
    else {
      dVar1 = *(double *)value;
    }
    __fprintf_chk(stderr,1,"%s %g\n",a->name,dVar1);
    return;
  case HID_String:
  case HID_Path:
    if (value == (void *)0x0) {
      pcVar3 = (a->default_val).str_value;
    }
    else {
      pcVar3 = *(char **)value;
    }
    __fprintf_chk(stderr,1,"%s \"%s\"\n",a->name,pcVar3);
    return;
  case HID_Boolean:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
    }
    else {
      iVar2 = (int)*(char *)value;
    }
    pcVar3 = "no";
    if (iVar2 != 0) {
      pcVar3 = "yes";
    }
    break;
  case HID_Enum:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
    }
    else {
      iVar2 = *(int *)value;
    }
    pcVar3 = a->enumerations[iVar2];
    break;
  case HID_Mixed:
    if (value == (void *)0x0) {
      iVar2 = (a->default_val).int_value;
      dVar1 = (a->default_val).real_value;
    }
    else {
      iVar2 = *(int *)value;
      dVar1 = *(double *)value;
    }
    __fprintf_chk(stderr,1,"%s %g%s\n",a->name,dVar1,a->enumerations[iVar2]);
    return;
  }
  __fprintf_chk(stderr,1,"%s %s\n",a->name,pcVar3);
switchD_080a0a1f_caseD_0:
  return;
}



void u(char *fmt,...)

{
  __vfprintf_chk(stderr,1,fmt,&stack0x00000008);
  fputc(10,stderr);
  return;
}



void __regparm3 usage_attr(HID_Attribute *a)

{
  undefined4 *puVar1;
  char buf [200];
  byte bVar2;
  uint uVar3;
  uint uVar4;
  size_t sVar5;
  undefined *puVar6;
  uint *puVar7;
  uint *puVar8;
  char *local_2c;
  int iVar9;
  int iVar10;
  bool bVar11;
  char *local_30;
  
  local_2c = a->help_text;
  if (local_2c == &DAT_00000001) {
    return;
  }
  if (a->type < 8) {
    switch(a->type) {
    case HID_Label:
      goto switchD_080a0cb3_caseD_0;
    default:
      local_2c = a->name;
      local_30 = "--%s <num>";
      break;
    case HID_String:
      local_2c = a->name;
      local_30 = "--%s <string>";
      break;
    case HID_Boolean:
      local_2c = a->name;
      local_30 = "--%s";
      break;
    case HID_Enum:
    case HID_Mixed:
      __sprintf_chk(0x816c780,1,200,"--%s ",a->name);
      if (a->type == HID_Mixed) {
        __strcat_chk(0x816c780," <val>",200);
      }
      if (*a->enumerations != (char *)0x0) {
        iVar10 = 0;
        iVar9 = 0;
        puVar6 = &DAT_08148545;
        do {
          iVar9 = iVar9 + 1;
          __strcat_chk(0x816c780,puVar6,200);
          puVar1 = (undefined4 *)((int)a->enumerations + iVar10);
          iVar10 = iVar9 * 4;
          __strcat_chk(0x816c780,*puVar1,200);
          puVar6 = &DAT_08148547;
        } while (a->enumerations[iVar9] != (char *)0x0);
      }
      __strcat_chk(0x816c780,0x815c524,200);
      local_2c = a->help_text;
      goto LAB_080a0c21;
    case HID_Path:
      local_2c = a->name;
      local_30 = "--%s <path>";
    }
    __sprintf_chk(0x816c780,1,200,local_30,local_2c);
    local_2c = a->help_text;
  }
LAB_080a0c21:
  puVar8 = (uint *)(char *)&ram0x0816c780;
  do {
    puVar7 = puVar8;
    uVar3 = *puVar7 + 0xfefefeff & ~*puVar7;
    uVar4 = uVar3 & 0x80808080;
    puVar8 = puVar7 + 1;
  } while (uVar4 == 0);
  bVar11 = (uVar3 & 0x8080) == 0;
  bVar2 = (byte)uVar4;
  if (bVar11) {
    bVar2 = (byte)(uVar4 >> 0x10);
  }
  if (bVar11) {
    puVar8 = (uint *)((int)puVar7 + 6);
  }
  uVar3 = (int)puVar8 + (-0x816c783 - (uint)CARRY1(bVar2,bVar2));
  if (uVar3 < 0x1f) {
    if (local_2c != (char *)0x0) {
      __fprintf_chk(stderr,1," %-30s\t%s\n",0x816c780,local_2c);
      return;
    }
    __fprintf_chk(stderr,1," %-30s\n",0x816c780);
  }
  else {
    if (local_2c == (char *)0x0) {
      __fprintf_chk(stderr,1,0x814738c,0x816c780);
    }
    else {
      sVar5 = strlen(local_2c);
      if (sVar5 + uVar3 < 0x48) {
        __fprintf_chk(stderr,1," %s\t%s\n",0x816c780,local_2c);
      }
      else {
        __fprintf_chk(stderr,1,&DAT_08148570,0x816c780,local_2c);
      }
    }
  }
switchD_080a0cb3_caseD_0:
  return;
}



void __regparm3 usage_hid(HID *h)

{
  HID *pHVar1;
  HID **ppHVar2;
  HID_Attribute *pHVar3;
  HID_Attribute *a;
  HID **ppHVar4;
  int iVar5;
  HID_AttrNode *pHVar6;
  int iVar7;
  int local_20 [4];
  
  if ((*(byte *)&h->field_0xc & 1) == 0) {
    __fprintf_chk(stderr,1,"\n%s options:\n",h->name);
    exporter = h;
    a = (*h->get_export_options)(local_20);
    if (a != (HID_Attribute *)0x0) {
      if (0 < local_20[0]) {
        iVar5 = 0;
        do {
          iVar5 = iVar5 + 1;
          usage_attr(a);
          a = a + 1;
        } while (iVar5 < local_20[0]);
      }
      exporter = (HID *)0x0;
      return;
    }
  }
  else {
    ppHVar2 = hid_enumerate();
    __fprintf_chk(stderr,1,"\ngui options:\n");
    pHVar6 = hid_attr_nodes;
    while (pHVar6 != (HID_AttrNode *)0x0) {
      while( true ) {
        pHVar1 = *ppHVar2;
        ppHVar4 = ppHVar2;
        while (pHVar1 != (HID *)0x0) {
          a = pHVar6->attributes;
          pHVar3 = (*pHVar1->get_export_options)((int *)0x0);
          if (a == pHVar3) goto skip_this_one;
          pHVar1 = ppHVar4[1];
          ppHVar4 = ppHVar4 + 1;
        }
        if (pHVar6->n < 1) break;
        iVar7 = 0;
        iVar5 = 0;
        do {
          iVar5 = iVar5 + 1;
          a = (HID_Attribute *)((int)&pHVar6->attributes->name + iVar7);
          iVar7 = iVar7 + 0x30;
          usage_attr(a);
        } while (pHVar6->n != iVar5 && iVar5 <= pHVar6->n);
        pHVar6 = pHVar6->next;
        if (pHVar6 == (HID_AttrNode *)0x0) {
          return;
        }
      }
skip_this_one:
      pHVar6 = pHVar6->next;
    }
  }
  return;
}



void usage(void)

{
  byte bVar1;
  HID **ppHVar2;
  undefined1 *puVar3;
  HID *h;
  HID **ppHVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  ppHVar2 = hid_enumerate();
  h = *ppHVar2;
  if (h == (HID *)0x0) {
    iVar6 = 0;
    iVar5 = 0;
    u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
    u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright",Progname);
    u("%s [gui options] <pcb file>\t\tto edit",Progname);
  }
  else {
    iVar5 = 0;
    iVar7 = 0;
    iVar6 = 0;
    ppHVar4 = ppHVar2;
    do {
      bVar1 = *(byte *)&h->field_0xc;
      iVar7 = (iVar7 + 1) - (uint)((bVar1 & 1) == 0);
      iVar6 = (iVar6 + 1) - (uint)((bVar1 & 2) == 0);
      h = ppHVar4[1];
      iVar5 = (iVar5 + 1) - (uint)((bVar1 & 4) == 0);
      ppHVar4 = ppHVar4 + 1;
    } while (h != (HID *)0x0);
    u("PCB Printed Circuit Board editing program, http://pcb.sourceforge.net");
    u("%s [-h|-V|--copyright]\t\t\tHelp, version, copyright",Progname);
    u("%s [gui options] <pcb file>\t\tto edit",Progname);
    puVar3 = &DAT_0814741b;
    if (iVar7 == 1) goto LAB_080a1099;
  }
  puVar3 = (undefined1 *)0x814736c;
LAB_080a1099:
  u("Available GUI hid%s:",puVar3);
  h = *ppHVar2;
  ppHVar4 = ppHVar2;
  while (h != (HID *)0x0) {
    while ((*(byte *)&h->field_0xc & 1) == 0) {
      h = ppHVar4[1];
      ppHVar4 = ppHVar4 + 1;
      if (h == (HID *)0x0) goto LAB_080a10fd;
    }
    __fprintf_chk(stderr,1,"\t%s\t%s\n",h->name,h->description);
    h = ppHVar4[1];
    ppHVar4 = ppHVar4 + 1;
  }
LAB_080a10fd:
  u("%s -p [printing options] <pcb file>\tto print",Progname);
  puVar3 = (undefined1 *)0x814736c;
  if (iVar6 == 1) {
    puVar3 = &DAT_0814741b;
  }
  u("Available printing hid%s:",puVar3);
  h = *ppHVar2;
  ppHVar4 = ppHVar2;
  while (h != (HID *)0x0) {
    while ((*(byte *)&h->field_0xc & 2) == 0) {
      h = ppHVar4[1];
      ppHVar4 = ppHVar4 + 1;
      if (h == (HID *)0x0) goto LAB_080a1185;
    }
    __fprintf_chk(stderr,1,"\t%s\t%s\n",h->name,h->description);
    h = ppHVar4[1];
    ppHVar4 = ppHVar4 + 1;
  }
LAB_080a1185:
  u("%s -x hid [export options] <pcb file>\tto export",Progname);
  puVar3 = (undefined1 *)0x814736c;
  if (iVar5 == 1) {
    puVar3 = &DAT_0814741b;
  }
  u("Available export hid%s:",puVar3);
  h = *ppHVar2;
  ppHVar4 = ppHVar2;
  if (h != (HID *)0x0) {
    do {
      while ((*(byte *)&h->field_0xc & 4) != 0) {
        __fprintf_chk(stderr,1,"\t%s\t%s\n",h->name,h->description);
        h = ppHVar4[1];
        ppHVar4 = ppHVar4 + 1;
        if (h == (HID *)0x0) goto LAB_080a1215;
      }
      h = ppHVar4[1];
      ppHVar4 = ppHVar4 + 1;
    } while (h != (HID *)0x0);
LAB_080a1215:
    h = *ppHVar2;
    ppHVar4 = ppHVar2;
    if (h != (HID *)0x0) {
      do {
        while ((*(byte *)&h->field_0xc & 1) != 0) {
          usage_hid(h);
          h = ppHVar4[1];
          ppHVar4 = ppHVar4 + 1;
          if (h == (HID *)0x0) goto LAB_080a1247;
        }
        h = ppHVar4[1];
        ppHVar4 = ppHVar4 + 1;
      } while (h != (HID *)0x0);
LAB_080a1247:
      h = *ppHVar2;
      ppHVar4 = ppHVar2;
      if (h != (HID *)0x0) {
        do {
          while ((*(byte *)&h->field_0xc & 2) != 0) {
            usage_hid(h);
            h = ppHVar4[1];
            ppHVar4 = ppHVar4 + 1;
            if (h == (HID *)0x0) goto LAB_080a1277;
          }
          h = ppHVar4[1];
          ppHVar4 = ppHVar4 + 1;
        } while (h != (HID *)0x0);
LAB_080a1277:
        h = *ppHVar2;
        while (h != (HID *)0x0) {
          while ((*(byte *)&h->field_0xc & 4) == 0) {
            h = ppHVar2[1];
            ppHVar2 = ppHVar2 + 1;
            if (h == (HID *)0x0) goto LAB_080a12a7;
          }
          usage_hid(h);
          h = ppHVar2[1];
          ppHVar2 = ppHVar2 + 1;
        }
      }
    }
  }
LAB_080a12a7:
                    // WARNING: Subroutine does not return
  exit(1);
}



void print_version(void)

{
  __printf_chk(1,"PCB version %s\n","20091103");
                    // WARNING: Subroutine does not return
  exit(0);
}



void copyright(void)

{
  __printf_chk(1,
               "\n                COPYRIGHT for %s version %s\n\n    PCB, interactive printed circuit board design\n    Copyright (C) 1994,1995,1996,1997 Thomas Nau\n    Copyright (C) 1998, 1999, 2000 Harry Eaton\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n"
               ,Progname,"20091103");
                    // WARNING: Subroutine does not return
  exit(0);
}



void register_main_attribute_list(void)

{
  hid_register_attributes((HID_Attribute *)main_attribute_list,0x85);
  return;
}



int main(int argc,char **argv)

{
  HID *pHVar1;
  HID_AttrNode *pHVar2;
  PCBTypePtr pPVar3;
  size_t sVar4;
  char *local_b8;
  char *__s;
  LayerGroupTypePtr LayerGroup;
  char *__s_00;
  char *__filename;
  HID **ppHVar5;
  HID_Attribute *a;
  int iVar6;
  char cVar7;
  size_t sVar8;
  int iVar9;
  undefined4 *__s_01;
  byte *pbVar10;
  byte *pbVar11;
  byte *pbVar12;
  int in_GS_OFFSET;
  bool bVar13;
  bool bVar14;
  bool bVar15;
  byte bVar16;
  char *path;
  stat sb;
  char buf [20];
  char **local_a4 [4];
  stat local_94;
  int local_3c;
  char local_38 [20];
  int local_24;
  
  bVar16 = 0;
  local_a4[0] = argv;
  local_24 = *(int *)(in_GS_OFFSET + 0x14);
  register_action_action_list();
  register_rotate_action_list();
  register_command_action_list();
  register_djopt_flag_list();
  register_djopt_action_list();
  register_flags_flag_list();
  register_fontmode_action_list();
  register_main_attribute_list();
  register_move_action_list();
  register_netlist_action_list();
  register_puller_action_list();
  register_report_action_list();
  register_vendor_action_list();
  register_vendor_flag_list();
  register_toporouter_action_list();
  setbuf(stdout,(char *)0x0);
  local_b8 = *local_a4[0];
  sVar4 = strlen(local_b8);
  bVar13 = false;
  sVar8 = 0;
  while (sVar8 != sVar4) {
    if (local_b8[sVar8] == '/') {
      bVar13 = true;
    }
    sVar8 = sVar8 + 1;
  }
  if (bVar13) {
    local_b8 = lrealpath(local_b8);
    bindir = (char *)__strdup(local_b8);
LAB_080a1465:
    __s_01 = (undefined4 *)bindir;
    local_b8 = strchr(bindir,0x2f);
    if ((local_b8 != (char *)0x0) && (*local_b8 != '\0')) {
      do {
        __s = local_b8;
        local_b8 = strchr(__s + 1,0x2f);
        if (local_b8 == (char *)0x0) break;
      } while (*local_b8 != '\0');
      *__s = '\0';
      __s_01 = (undefined4 *)bindir;
    }
  }
  else {
    __s = getenv("PATH");
    if (__s != (char *)0x0) {
      __s_00 = (char *)__strdup(__s);
      __s = strtok(__s_00,":");
      while ((__s != (char *)0x0 && (*__s != '\0'))) {
        sVar4 = strlen(local_b8);
        sVar8 = strlen(__s);
        __filename = (char *)calloc(1,sVar4 + 2 + sVar8);
        if (__filename == (char *)0x0) goto LAB_080a20dd;
        __sprintf_chk(__filename,1,0xffffffff,0x814d6ff,__s,0x815d1de,local_b8);
        iVar9 = __xstat(3,__filename,&local_94);
        if (iVar9 == 0) {
          bindir = lrealpath(__filename);
          free(__filename);
          free(__s_00);
          goto LAB_080a1465;
        }
        free(__filename);
        __s = strtok((char *)0x0,":");
      }
      free(__s_00);
    }
    __s_01 = (undefined4 *)calloc(1,9);
    bindir = (char *)__s_01;
    if (__s_01 != (undefined4 *)0x0) {
      *__s_01 = 0x7273752f;
      __s_01[1] = 0x6e69622f;
      *(undefined *)(__s_01 + 2) = 0;
    }
  }
  sVar4 = strlen((char *)__s_01);
  exec_prefix = (char *)calloc(1,sVar4 + 4);
  if (exec_prefix == (char *)0x0) {
LAB_080a20dd:
    __fprintf_chk(stderr,1,"InitPaths():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  __sprintf_chk(exec_prefix,1,0xffffffff,0x814d6ff,bindir,0x815d1de,0x8147345);
  sVar4 = strlen(bindir);
  pcblibdir = (char *)calloc(1,sVar4 + 0xe);
  if (pcblibdir == (char *)0x0) goto LAB_080a20dd;
  __sprintf_chk(pcblibdir,1,0xffffffff,0x814d6ff,bindir,0x815d1de,"../share/pcb");
  sVar4 = strlen(bindir);
  pcbtreedir = (char *)calloc(1,sVar4 + 0x15);
  if (pcbtreedir == (char *)0x0) goto LAB_080a20dd;
  local_b8 = "../share/pcb/newlib";
  __sprintf_chk(pcbtreedir,1,0xffffffff,0x814d6ff,bindir,0x815d1de,"../share/pcb/newlib");
  sVar4 = strlen(pcblibdir);
  pcblibpath = (char *)calloc(1,sVar4 + 3);
  if (pcblibpath == (char *)0x0) goto LAB_080a20dd;
  __sprintf_chk(pcblibpath,1,0xffffffff,&DAT_08148643,&DAT_0814d79c,pcblibdir,local_b8);
  sVar4 = strlen(pcblibdir);
  sVar8 = strlen(pcbtreedir);
  pcbtreepath = (char *)calloc(1,sVar4 + 0x10 + sVar8);
  if (pcbtreepath == (char *)0x0) goto LAB_080a20dd;
  __sprintf_chk(pcbtreepath,1,0xffffffff,"%s%s%s%spcblib-newlib",pcbtreedir,&DAT_0814d79c,pcblibdir,
                0x815d1de);
  iVar9 = 0;
  do {
    while( true ) {
      pbVar11 = *(byte **)((int)&main_attribute_list[0].name + iVar9);
      bVar13 = false;
      bVar15 = pbVar11 == (byte *)0x0;
      if (!bVar15) break;
LAB_080a1719:
      iVar9 = iVar9 + 0x30;
      if (iVar9 == 0x18f0) goto LAB_080a178a;
    }
    iVar6 = 0x10;
    pbVar10 = pbVar11;
    pbVar12 = (byte *)"lib-command-dir";
    do {
      if (iVar6 == 0) break;
      iVar6 = iVar6 + -1;
      bVar13 = *pbVar10 < *pbVar12;
      bVar15 = *pbVar10 == *pbVar12;
      pbVar10 = pbVar10 + (uint)bVar16 * -2 + 1;
      pbVar12 = pbVar12 + (uint)bVar16 * -2 + 1;
    } while (bVar15);
    if (bVar15) {
      *(char **)((int)&main_attribute_list[0].default_val.str_value + iVar9) = pcblibdir;
    }
    iVar6 = 10;
    pbVar10 = pbVar11;
    pbVar12 = (byte *)"font-path";
    do {
      if (iVar6 == 0) break;
      iVar6 = iVar6 + -1;
      bVar13 = *pbVar10 < *pbVar12;
      bVar15 = *pbVar10 == *pbVar12;
      pbVar10 = pbVar10 + (uint)bVar16 * -2 + 1;
      pbVar12 = pbVar12 + (uint)bVar16 * -2 + 1;
    } while (bVar15);
    bVar14 = (!bVar13 && !bVar15) < bVar13;
    bVar13 = (!bVar13 && !bVar15) == bVar13;
    if (!bVar13) {
      iVar6 = 0xd;
      pbVar10 = pbVar11;
      pbVar12 = (byte *)"element-path";
      do {
        if (iVar6 == 0) break;
        iVar6 = iVar6 + -1;
        bVar14 = *pbVar10 < *pbVar12;
        bVar13 = *pbVar10 == *pbVar12;
        pbVar10 = pbVar10 + (uint)bVar16 * -2 + 1;
        pbVar12 = pbVar12 + (uint)bVar16 * -2 + 1;
      } while (bVar13);
      bVar13 = (!bVar14 && !bVar13) == bVar14;
      if (bVar13) goto LAB_080a176a;
      iVar6 = 9;
      pbVar10 = (byte *)"lib-path";
      do {
        if (iVar6 == 0) break;
        iVar6 = iVar6 + -1;
        bVar13 = *pbVar11 == *pbVar10;
        pbVar11 = pbVar11 + (uint)bVar16 * -2 + 1;
        pbVar10 = pbVar10 + (uint)bVar16 * -2 + 1;
      } while (bVar13);
      if (bVar13) goto LAB_080a176a;
      local_b8 = *(char **)((int)&main_attribute_list[0].name + iVar9);
LAB_080a1700:
      iVar6 = 0xb;
      __s = "lib-newlib";
      do {
        if (iVar6 == 0) break;
        iVar6 = iVar6 + -1;
        bVar13 = *local_b8 == *__s;
        local_b8 = local_b8 + (uint)bVar16 * -2 + 1;
        __s = __s + (uint)bVar16 * -2 + 1;
      } while (bVar13);
      if (bVar13) {
        *(char **)((int)&main_attribute_list[0].default_val.str_value + iVar9) = pcbtreepath;
      }
      goto LAB_080a1719;
    }
LAB_080a176a:
    local_b8 = *(char **)((int)&main_attribute_list[0].name + iVar9);
    bVar13 = local_b8 == (char *)0x0;
    *(char **)((int)&main_attribute_list[0].default_val.str_value + iVar9) = pcblibpath;
    if (!bVar13) goto LAB_080a1700;
    iVar9 = iVar9 + 0x30;
  } while (iVar9 != 0x18f0);
LAB_080a178a:
  local_b8 = getenv("HOME");
  if ((local_b8 == (char *)0x0) && (local_b8 = getenv("USERPROFILE"), local_b8 == (char *)0x0)) {
    homedir = (char *)0x0;
  }
  else {
    homedir = (char *)__strdup(local_b8);
  }
  bindtextdomain(&DAT_0815492c,"/usr/share/locale");
  bind_textdomain_codeset(&DAT_0815492c,"UTF-8");
  hid_init();
  hid_load_settings();
  local_b8 = *local_a4[0];
  program_name = local_b8;
  program_basename = strrchr(local_b8,0x2f);
  if (program_basename == (char *)0x0) {
    program_directory = ".";
  }
  else {
    program_directory = (char *)__strdup(local_b8);
    local_b8 = strrchr(program_directory,0x2f);
    *local_b8 = '\0';
    local_b8 = program_basename + 1;
  }
  program_basename = local_b8;
  Progname = local_b8;
  if (1 < argc) {
    local_b8 = local_a4[0][1];
    cVar7 = *local_b8;
    if (((cVar7 == '-') && (local_b8[1] == 'h')) && (local_b8[2] == '\0')) {
      usage();
      if (argc < 2) goto LAB_080a18b2;
      local_b8 = local_a4[0][1];
      cVar7 = *local_b8;
    }
    if (((cVar7 == '-') && (local_b8[1] == 'V')) && (local_b8[2] == '\0')) {
      print_version();
      if (argc < 2) goto LAB_080a18b2;
      local_b8 = local_a4[0][1];
      cVar7 = *local_b8;
    }
    if (((cVar7 == '-') && (local_b8[1] == 'p')) && (local_b8[2] == '\0')) {
      gui = hid_find_printer();
      argc = argc + -1;
      local_a4[0] = local_a4[0] + 1;
      exporter = gui;
      goto LAB_080a18bc;
    }
    if ((((2 < argc) && (cVar7 == '-')) && (local_b8[1] == 'x')) && (local_b8[2] == '\0')) {
      gui = hid_find_exporter(local_a4[0][2]);
      argc = argc + -2;
      local_a4[0] = local_a4[0] + 2;
      exporter = gui;
      goto LAB_080a18bc;
    }
  }
LAB_080a18b2:
  gui = hid_find_gui();
LAB_080a18bc:
  if (gui != (HID *)0x0) {
    iVar9 = 0;
    do {
      iVar6 = iVar9 + 1;
      local_b8 = "signal%d";
      __sprintf_chk(local_38,1,0x14,"signal%d",iVar6);
      __s = MyStrdup(local_38,"DefaultLayerNames");
      (&Settings.GridColor)[iVar6] = "#c49350";
      Settings.LayerColor[iVar9 + 0x10] = "#00ffff";
      *(char **)(&Settings.BackupInterval + iVar6) = __s;
      iVar9 = iVar6;
    } while (iVar6 != 0x10);
    (*gui->parse_arguments)(&argc,local_a4);
    if ((show_help != 0) || ((1 < argc && (*local_a4[0][1] == '-')))) {
      usage();
    }
    if (show_version != 0) {
      print_version();
    }
    if (show_defaults == 0) {
      if (show_copyright != 0) {
        copyright();
      }
      Output.bgGC = (*gui->make_gc)();
      Output.fgGC = (*gui->make_gc)();
      Output.pmGC = (*gui->make_gc)();
      Output.GridGC = (*gui->make_gc)();
      if (1 < (byte)(*Settings.LibraryCommand - 0x2eU)) {
        Settings.LibraryCommand =
             Concat(Settings.LibraryCommandDir,0x815d1de,Settings.LibraryCommand,0);
      }
      if (1 < (byte)(*Settings.LibraryContentsCommand - 0x2eU)) {
        Settings.LibraryContentsCommand =
             Concat(Settings.LibraryCommandDir,0x815d1de,Settings.LibraryContentsCommand,0);
      }
      if (9999999 < Settings.LineThickness - 1U) {
        Settings.LineThickness = 1000;
      }
      if (0x988eb0 < Settings.ViaThickness - 2000U) {
        Settings.ViaThickness = 4000;
      }
      if (Settings.ViaDrillingHole < 1) {
        Settings.ViaDrillingHole = (Settings.ViaThickness * 0x28) / 100;
      }
      iVar9 = 1000;
      if (999 < Settings.MaxWidth) {
        iVar9 = Settings.MaxWidth;
      }
      if (10000000 < iVar9) {
        iVar9 = 10000000;
      }
      iVar6 = 1000;
      if (999 < Settings.MaxHeight) {
        iVar6 = Settings.MaxHeight;
      }
      Settings.MaxHeight = 10000000;
      if (iVar6 < 0x989681) {
        Settings.MaxHeight = iVar6;
      }
      Settings.MaxWidth = iVar9;
      ParseRouteString(Settings.Routes,(RouteStyleTypePtr)Settings.RouteStyle,1);
      if (show_actions != 0) {
        print_actions();
                    // WARNING: Subroutine does not return
        exit(0);
      }
      if (do_dump_actions != 0) {
        dump_actions();
                    // WARNING: Subroutine does not return
        exit(0);
      }
      PCB = CreateNewPCB('\x01');
      LayerGroup = (LayerGroupTypePtr)&PCB->LayerGroups;
      PCB->Data->LayerN = 8;
      ParseGroupString(Settings.Groups,LayerGroup,8);
      CreateNewPCBPost(PCB,1);
      if (1 < argc) {
        command_line_pcb = local_a4[0][1];
      }
      ResetStackAndVisibility();
      CreateDefaultFont();
      if ((*(byte *)&gui->field_0xc & 1) != 0) {
        InitCrosshair();
      }
      signal(0xd,(__sighandler_t)&DAT_00000001);
      InitBuffers();
      SetMode(0x6e);
      if ((command_line_pcb != (char *)0x0) &&
         (iVar9 = LoadPCB(command_line_pcb), pPVar3 = PCB, iVar9 != 0)) {
        local_b8 = MyStrdup(command_line_pcb,"main()");
        pPVar3->Filename = local_b8;
      }
      if ((Settings.InitialLayerStack != (char *)0x0) && (*Settings.InitialLayerStack != '\0')) {
        LayerStringToLayerStack(Settings.InitialLayerStack);
      }
      if ((*(byte *)&gui->field_0xc & 6) != 0) {
        (*gui->do_export)((HID_Attr_Val *)0x0);
                    // WARNING: Subroutine does not return
        exit(0);
      }
      atexit(EmergencySave);
      iVar9 = ReadLibraryContents();
      if ((iVar9 == 0) && (Library.MenuN != 0)) {
        hid_action("LibraryChanged");
      }
      Settings.init_done = 0;
      if (Settings.ScriptFilename != (char *)0x0) {
        Message("Executing startup script file %s\n",Settings.ScriptFilename);
        hid_actionl("ExecuteFile",Settings.ScriptFilename,0);
      }
      if (Settings.ActionString != (char *)0x0) {
        Message("Executing startup action %s\n",Settings.ActionString);
        hid_parse_actions(Settings.ActionString,(anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0);
      }
      if (Settings.init_done == 0) {
        Settings.init_done = 1;
        pcb_dbus_setup();
        EnableAutosave();
        (*gui->do_export)((HID_Attr_Val *)0x0);
        pcb_dbus_finish();
      }
      if (local_24 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return 0;
    }
    ppHVar5 = hid_enumerate();
    pHVar1 = *ppHVar5;
    while (pHVar1 != (HID *)0x0) {
      if ((*(byte *)&pHVar1->field_0xc & 1) == 0) {
        local_b8 = pHVar1->name;
        __fprintf_chk(stderr,1,"\n%s defaults:\n",local_b8);
        a = (*pHVar1->get_export_options)(&local_3c);
        if ((a != (HID_Attribute *)0x0) && (0 < local_3c)) {
          iVar9 = 0;
          do {
            print_defaults_1(a,(void *)0x0);
            iVar9 = iVar9 + 1;
            a = a + 1;
          } while (iVar9 < local_3c);
        }
      }
      else {
        __fprintf_chk(stderr,1,"\ngui defaults:\n",local_b8);
        pHVar2 = hid_attr_nodes;
        while (pHVar2 != (HID_AttrNode *)0x0) {
          iVar9 = 0;
          if (0 < pHVar2->n) {
            iVar6 = 0;
            do {
              iVar9 = iVar9 + 1;
              a = (HID_Attribute *)((int)&pHVar2->attributes->name + iVar6);
              iVar6 = iVar6 + 0x30;
              print_defaults_1(a,a->value);
            } while (iVar9 < pHVar2->n);
          }
          pHVar2 = pHVar2->next;
        }
      }
      pHVar1 = ppHVar5[1];
      ppHVar5 = ppHVar5 + 1;
    }
  }
                    // WARNING: Subroutine does not return
  exit(1);
}



void MirrorElementCoordinates(DataTypePtr *Data,ElementTypePtr *Element,LocationType yoff)

{
  PCBTypePtr pPVar1;
  PointType *pPVar2;
  uint uVar3;
  LocationType *pLVar4;
  undefined *puVar5;
  int iVar6;
  PinTypePtr *ptr2;
  void *ptr2_00;
  int iVar7;
  uint uVar8;
  int local_24;
  uint local_20;
  
  r_delete_element((DataType *)Data,(ElementType *)Element);
  iVar6 = Element->LineN - 1;
  if (iVar6 != -1) {
    iVar7 = PCB->MaxHeight;
    pPVar2 = &Element->Line[Element->LineN - 1].Point1;
    do {
      iVar6 = iVar6 + -1;
      pPVar2->Y = (iVar7 - pPVar2->Y) + yoff;
      pPVar2[1].Y = (iVar7 - pPVar2[1].Y) + yoff;
      pPVar2 = (PointType *)&pPVar2[-5].Y2;
    } while (iVar6 != -1);
  }
  if (Element->PinN != 0) {
    uVar8 = 0;
    local_20 = Element->PinN;
    do {
      ptr2 = Element->Pin + uVar8;
      RestoreToPolygon((DataType *)Data,0x100,Element,ptr2);
      ptr2->Y = (PCB->MaxHeight + yoff) - ptr2->Y;
      uVar3 = Element->PinN;
      if (uVar3 == 0) break;
      uVar8 = (uVar3 + 1 + uVar8) - local_20;
      local_20 = uVar3;
    } while (uVar8 < uVar3);
  }
  uVar8 = Element->PadN;
  local_24 = 0;
  local_20 = 0;
  uVar3 = uVar8;
  while ((pPVar1 = PCB, uVar3 != 0 && (local_20 < uVar3))) {
    ptr2_00 = (void *)((int)&(Element->Pad->BoundingBox).X1 + local_24);
    RestoreToPolygon((DataType *)Data,0x200,Element,ptr2_00);
    pPVar1 = PCB;
    *(uint *)((int)ptr2_00 + 0x14) = *(uint *)((int)ptr2_00 + 0x14) ^ 0x80;
    iVar6 = pPVar1->MaxHeight;
    *(int *)((int)ptr2_00 + 0x30) = (iVar6 - *(int *)((int)ptr2_00 + 0x30)) + yoff;
    *(int *)((int)ptr2_00 + 0x44) = (iVar6 - *(int *)((int)ptr2_00 + 0x44)) + yoff;
    uVar3 = Element->PadN;
    if (Element->PadN == uVar8) {
      local_20 = local_20 + 1;
      local_24 = local_24 + 0x68;
      uVar3 = uVar8;
    }
  }
  iVar6 = Element->ArcN - 1;
  if (iVar6 == -1) {
    iVar7 = PCB->MaxHeight;
  }
  else {
    iVar7 = PCB->MaxHeight;
    pLVar4 = &Element->Arc[Element->ArcN - 1].X;
    do {
      iVar6 = iVar6 + -1;
      pLVar4[2] = -pLVar4[2];
      pLVar4[3] = -pLVar4[3];
      pLVar4[1] = (iVar7 - pLVar4[1]) + yoff;
      pLVar4 = pLVar4 + -0x11;
    } while (iVar6 != -1);
  }
  puVar5 = (undefined *)0x0;
  do {
    iVar6 = *(int *)(puVar5 + 0xa4 + (int)(&Element->Name[2].Y + -0x29));
    *(uint *)(puVar5 + 0x8c + (int)(&Element->Name[2].Flags)[-0xc].t) =
         *(uint *)(puVar5 + 0x8c + (int)(&Element->Name[2].Flags)[-0xc].t) ^ 0x80;
    *(LocationType *)(puVar5 + 0xa4 + (int)(&Element->Name[2].Y + -0x29)) = (yoff - iVar6) + iVar7;
    puVar5 = &DAT_ffffffc4 + (int)puVar5;
  } while (puVar5 != (undefined *)0xffffff4c);
  iVar6 = Element->MarkY;
  (Element->Flags).f = (Element->Flags).f ^ 0x80;
  Element->MarkY = (yoff - iVar6) + iVar7;
  SetElementBoundingBox(Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&pPVar1->Font);
  ClearFromPolygon((DataType *)Data,2,Element,Element);
  return;
}



void SetPointBoundingBox(PointTypePtr Pnt)

{
  Pnt->X2 = Pnt->X + 1;
  Pnt->Y2 = Pnt->Y + 1;
  return;
}



void SetPinBoundingBox(PinTypePtr_conflict Pin)

{
  int iVar1;
  int iVar2;
  
  iVar1 = (Pin->Clearance + Pin->Thickness + 1) / 2;
  iVar2 = (Pin->Mask + 1) / 2;
  if (iVar2 <= iVar1) {
    iVar2 = iVar1;
  }
  (Pin->BoundingBox).X1 = Pin->X - iVar2;
  iVar1 = Pin->Y;
  (Pin->BoundingBox).Y1 = iVar1 - iVar2;
  (Pin->BoundingBox).X2 = Pin->X + iVar2 + 1;
  (Pin->BoundingBox).Y2 = iVar2 + 1 + iVar1;
  return;
}



void SetLineBoundingBox(LineTypePtr Line)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  iVar2 = (Line->Point2).X;
  iVar4 = (Line->Thickness + Line->Clearance + 1) / 2;
  iVar3 = iVar2;
  if ((Line->Point1).X == iVar2 || (Line->Point1).X < iVar2) {
    iVar3 = (Line->Point1).X;
  }
  (Line->BoundingBox).X1 = iVar3 - iVar4;
  iVar3 = (Line->Point2).Y;
  iVar6 = iVar2;
  if (iVar2 <= (Line->Point1).X) {
    iVar6 = (Line->Point1).X;
  }
  piVar1 = &(Line->Point1).Y;
  iVar5 = iVar3;
  if (*piVar1 == iVar3 || *piVar1 < iVar3) {
    iVar5 = (Line->Point1).Y;
  }
  (Line->BoundingBox).X2 = iVar4 + 1 + iVar6;
  (Line->BoundingBox).Y1 = iVar5 - iVar4;
  iVar6 = iVar3;
  if (iVar3 <= (Line->Point1).Y) {
    iVar6 = (Line->Point1).Y;
  }
  (Line->Point2).X2 = iVar2 + 1;
  (Line->BoundingBox).Y2 = iVar6 + 1 + iVar4;
  iVar2 = (Line->Point1).X;
  (Line->Point2).Y2 = iVar3 + 1;
  (Line->Point1).X2 = iVar2 + 1;
  (Line->Point1).Y2 = (Line->Point1).Y + 1;
  return;
}



void SetPolygonBoundingBox(PolygonTypePtr Polygon)

{
  Cardinal CVar1;
  int iVar2;
  int iVar3;
  PointTypePtr pPVar4;
  int iVar5;
  int iVar6;
  int local_14;
  
  CVar1 = Polygon->PointN;
  (Polygon->BoundingBox).Y1 = 10000000;
  (Polygon->BoundingBox).X1 = 10000000;
  (Polygon->BoundingBox).Y2 = 0;
  local_14 = CVar1 - 1;
  (Polygon->BoundingBox).X2 = 0;
  if (local_14 != -1) {
    iVar5 = 0;
    iVar6 = 0;
    pPVar4 = Polygon->Points + (CVar1 - 1);
    iVar3 = 10000000;
    while( true ) {
      iVar2 = pPVar4->X;
      if (iVar2 < iVar3) {
        (Polygon->BoundingBox).X1 = iVar2;
      }
      iVar3 = pPVar4->Y;
      if (iVar3 < (Polygon->BoundingBox).Y1) {
        (Polygon->BoundingBox).Y1 = iVar3;
      }
      if (iVar6 <= iVar2) {
        iVar6 = iVar2;
      }
      if (iVar5 <= iVar3) {
        iVar5 = iVar3;
      }
      iVar6 = iVar6 + 1;
      local_14 = local_14 + -1;
      iVar5 = iVar5 + 1;
      pPVar4 = pPVar4 + -1;
      if (local_14 == -1) break;
      iVar3 = (Polygon->BoundingBox).X1;
    }
    (Polygon->BoundingBox).X2 = iVar6;
    (Polygon->BoundingBox).Y2 = iVar5;
  }
  return;
}



Boolean IsDataEmpty(DataTypePtr *Data)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  bool bVar4;
  
  bVar4 = Data->ElementN == 0 && Data->ViaN == 0;
  iVar1 = PCB->Data->LayerN;
  uVar3 = iVar1 + 2;
  if (iVar1 != -2) {
    uVar2 = 0;
    do {
      while (bVar4 != false) {
        if (((*(int *)&Data->field_0x50 == 0) && (*(int *)&Data->field_0x5c == 0)) &&
           (*(int *)&Data->field_0x54 == 0)) {
          bVar4 = *(int *)&Data->field_0x58 == 0;
          break;
        }
        uVar2 = uVar2 + 1;
        bVar4 = false;
        Data = (DataTypePtr *)&Data->field_0x5c;
        if (uVar3 <= uVar2) {
          return '\0';
        }
      }
      uVar2 = uVar2 + 1;
      Data = (DataTypePtr *)&Data->field_0x5c;
    } while (uVar2 < uVar3);
  }
  return (Boolean)bVar4;
}



int FlagIsDataEmpty(int parm)

{
  Boolean BVar1;
  uint uVar2;
  
  BVar1 = IsDataEmpty(PCB->Data);
  uVar2 = SEXT14(BVar1);
  if (parm != 0) {
    uVar2 = (uint)(uVar2 == 0);
  }
  return uVar2;
}



BoxTypePtr GetDataBoundingBox(DataTypePtr *Data)

{
  BoxType box;
  Boolean BVar1;
  PinTypePtr *pPVar2;
  ElementTypePtr *pEVar3;
  uint uVar4;
  BoxTypePtr pBVar5;
  int iVar6;
  int iVar7;
  int *piVar8;
  int iVar9;
  uint local_38;
  int local_34;
  int local_2c;
  int local_24;
  uint local_1c;
  uint local_18;
  int local_14;
  
  box.Y1 = 10000000;
  box.X1 = 10000000;
  box.Y2 = -10000000;
  box.X2 = -10000000;
  if (Data->ViaN != 0) {
    box.Y1 = 10000000;
    box.X2 = -10000000;
    local_14 = -10000000;
    local_18 = 0;
    pPVar2 = Data->Via;
    box.X1 = 10000000;
    do {
      iVar7 = -(pPVar2->Thickness / 2);
      iVar6 = iVar7 + pPVar2->X;
      if (iVar6 < box.X1) {
        box.X1 = iVar6;
      }
      iVar7 = iVar7 + pPVar2->Y;
      if (iVar7 < box.Y1) {
        box.Y1 = iVar7;
      }
      iVar7 = pPVar2->Thickness / 2;
      iVar6 = iVar7 + pPVar2->X;
      if (box.X2 < iVar6) {
        box.X2 = iVar6;
      }
      box.Y2 = iVar7 + pPVar2->Y;
      if (box.Y2 <= local_14) {
        box.Y2 = local_14;
      }
      pPVar2 = pPVar2 + 1;
      local_18 = local_18 + 1;
      local_14 = box.Y2;
    } while (local_18 < Data->ViaN);
  }
  local_14 = Data->ElementN - 1;
  if (local_14 != -1) {
    pEVar3 = Data->Element + (Data->ElementN - 1);
    do {
      iVar6 = (pEVar3->BoundingBox).X1;
      if (iVar6 < box.X1) {
        box.X1 = iVar6;
      }
      iVar6 = pEVar3->Name[1].BoundingBox.X1;
      piVar8 = &(pEVar3->BoundingBox).Y1;
      if (*piVar8 == box.Y1 || *piVar8 < box.Y1) {
        box.Y1 = (pEVar3->BoundingBox).Y1;
      }
      if (box.X2 <= (pEVar3->BoundingBox).X2) {
        box.X2 = (pEVar3->BoundingBox).X2;
      }
      if (iVar6 < box.X1) {
        box.X1 = iVar6;
      }
      iVar6 = pEVar3->Name[1].BoundingBox.Y1;
      if (iVar6 < box.Y1) {
        box.Y1 = iVar6;
      }
      iVar6 = pEVar3->Name[1].BoundingBox.X2;
      if (box.X2 < iVar6) {
        box.X2 = iVar6;
      }
      iVar6 = (pEVar3->BoundingBox).Y2;
      if (iVar6 <= pEVar3->Name[1].BoundingBox.Y2) {
        iVar6 = pEVar3->Name[1].BoundingBox.Y2;
      }
      if (box.Y2 < iVar6) {
        box.Y2 = iVar6;
      }
      pEVar3 = pEVar3 + -1;
      local_14 = local_14 + -1;
    } while (local_14 != -1);
  }
  local_2c = &Data->field_0x4c;
  iVar6 = PCB->Data->LayerN;
  uVar4 = iVar6 + 2;
  if (iVar6 != -2) {
    local_18 = box.Y1;
    local_38 = 0;
    local_34 = local_2c;
    while( true ) {
      local_14 = *(int *)(local_34 + 4) + -1;
      if (local_14 != -1) {
        piVar8 = (int *)(*(int *)(local_34 + 4) * 0x58 + *(int *)(local_34 + 0x24) + -0x2c);
        do {
          iVar6 = -(piVar8[-2] / 2);
          if (iVar6 + *piVar8 < box.X1) {
            box.X1 = iVar6 + *piVar8;
          }
          if (iVar6 + piVar8[5] < box.X1) {
            box.X1 = iVar6 + piVar8[5];
          }
          iVar7 = iVar6 + piVar8[6];
          if (iVar6 + piVar8[1] < iVar6 + piVar8[6]) {
            iVar7 = iVar6 + piVar8[1];
          }
          if ((int)local_18 <= iVar7) {
            iVar7 = local_18;
          }
          iVar9 = piVar8[-2] / 2;
          iVar6 = iVar9 + *piVar8;
          if (iVar9 + *piVar8 < box.X2) {
            iVar6 = box.X2;
          }
          box.X2 = iVar9 + piVar8[5];
          if (iVar9 + piVar8[5] <= iVar6) {
            box.X2 = iVar6;
          }
          iVar6 = iVar9 + piVar8[6];
          if (iVar9 + piVar8[6] < iVar9 + piVar8[1]) {
            iVar6 = iVar9 + piVar8[1];
          }
          if (box.Y2 < iVar6) {
            box.Y2 = iVar6;
          }
          piVar8 = piVar8 + -0x16;
          local_14 = local_14 + -1;
          local_18 = iVar7;
        } while (local_14 != -1);
      }
      local_38 = local_38 + 1;
      if (uVar4 <= local_38) break;
      local_34 = local_34 + 0x5c;
    }
    local_1c = 0;
    box.Y1 = local_18;
    local_24 = box.Y2;
    local_18 = local_2c;
    while( true ) {
      local_14 = *(int *)(local_18 + 0x10) + -1;
      if (local_14 != -1) {
        piVar8 = (int *)(*(int *)(local_18 + 0x10) * 0x44 + -0x44 + *(int *)(local_18 + 0x30));
        do {
          if (*piVar8 < box.X1) {
            box.X1 = *piVar8;
          }
          if (piVar8[1] < box.Y1) {
            box.Y1 = piVar8[1];
          }
          if (box.X2 < piVar8[2]) {
            box.X2 = piVar8[2];
          }
          if (local_24 < piVar8[3]) {
            local_24 = piVar8[3];
          }
          piVar8 = piVar8 + -0x11;
          local_14 = local_14 + -1;
        } while (local_14 != -1);
      }
      local_1c = local_1c + 1;
      if (uVar4 <= local_1c) break;
      local_18 = local_18 + 0x5c;
    }
    local_1c = 0;
    local_14 = local_24;
    local_18 = local_2c;
    while( true ) {
      iVar6 = *(int *)(local_18 + 8) + -1;
      if (iVar6 != -1) {
        piVar8 = (int *)(&DAT_ffffffc4 + *(int *)(local_18 + 0x28) + *(int *)(local_18 + 8) * 0x3c);
        iVar7 = local_14;
        do {
          local_14 = iVar6;
          if (*piVar8 < box.X1) {
            box.X1 = *piVar8;
          }
          if (piVar8[1] < box.Y1) {
            box.Y1 = piVar8[1];
          }
          if (box.X2 < piVar8[2]) {
            box.X2 = piVar8[2];
          }
          if (iVar7 < piVar8[3]) {
            iVar7 = piVar8[3];
          }
          piVar8 = piVar8 + -0xf;
          iVar6 = local_14 + -1;
          local_14 = iVar7;
        } while (iVar6 != -1);
      }
      local_1c = local_1c + 1;
      if (uVar4 <= local_1c) break;
      local_18 = local_18 + 0x5c;
    }
    local_18 = 0;
    while( true ) {
      iVar6 = *(int *)(local_2c + 0xc) + -1;
      if (iVar6 != -1) {
        piVar8 = (int *)(&DAT_ffffffc4 + *(int *)(local_2c + 0x2c) + *(int *)(local_2c + 0xc) * 0x3c
                        );
        iVar7 = local_14;
        do {
          local_14 = iVar6;
          if (*piVar8 < box.X1) {
            box.X1 = *piVar8;
          }
          if (piVar8[1] < box.Y1) {
            box.Y1 = piVar8[1];
          }
          if (box.X2 < piVar8[2]) {
            box.X2 = piVar8[2];
          }
          if (iVar7 < piVar8[3]) {
            iVar7 = piVar8[3];
          }
          piVar8 = piVar8 + -0xf;
          iVar6 = local_14 + -1;
          local_14 = iVar7;
        } while (iVar6 != -1);
      }
      local_18 = local_18 + 1;
      if (uVar4 <= local_18) break;
      local_2c = local_2c + 0x5c;
    }
    box.Y2 = local_14;
  }
  BVar1 = IsDataEmpty(Data);
  pBVar5 = (BoxTypePtr)0x0;
  if (BVar1 == '\0') {
    pBVar5 = (BoxTypePtr)0x816ca88;
  }
  return pBVar5;
}



void SetFontInfo(FontTypePtr Ptr)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  LocationType LVar4;
  LineTypePtr pLVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  LineTypePtr Line;
  int iVar9;
  int iVar10;
  int local_34;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  
  local_28 = 0;
  local_34 = 10000000;
  Ptr->MaxWidth = 0x32;
  Ptr->MaxHeight = 0x32;
  do {
    iVar9 = local_34;
    if (((&Ptr->Symbol[0].Valid)[local_28] != '\0') &&
       (iVar10 = *(int *)((int)&Ptr->Symbol[0].LineN + local_28), iVar10 != 0)) {
      Line = *(LineTypePtr *)((int)&Ptr->Symbol[0].Line + local_28);
      local_18 = 0;
      local_1c = 0;
      local_14 = 10000000;
      local_20 = 10000000;
      pLVar5 = Line;
      local_24 = iVar10;
      do {
        iVar8 = (pLVar5->Point1).X;
        iVar2 = (pLVar5->Point2).X;
        iVar7 = (pLVar5->Point1).Y;
        iVar6 = iVar8;
        if (iVar2 <= iVar8) {
          iVar6 = iVar2;
        }
        if (local_20 <= iVar6) {
          iVar6 = local_20;
        }
        iVar3 = (pLVar5->Point2).Y;
        iVar9 = iVar7;
        if (iVar3 <= iVar7) {
          iVar9 = iVar3;
        }
        if (local_14 <= iVar9) {
          iVar9 = local_14;
        }
        if (iVar8 <= iVar2) {
          iVar8 = iVar2;
        }
        if (iVar8 <= local_1c) {
          iVar8 = local_1c;
        }
        if (iVar7 <= iVar3) {
          iVar7 = iVar3;
        }
        if (iVar7 <= local_18) {
          iVar7 = local_18;
        }
        pLVar5 = pLVar5 + 1;
        local_24 = local_24 + -1;
        local_20 = iVar6;
        local_1c = iVar8;
        local_18 = iVar7;
        local_14 = iVar9;
      } while (local_24 != 0);
      do {
        (Line->Point1).X = (Line->Point1).X - iVar6;
        (Line->Point2).X = (Line->Point2).X - iVar6;
        SetLineBoundingBox(Line);
        iVar10 = iVar10 + -1;
        Line = Line + 1;
      } while (iVar10 != 0);
      iVar6 = (iVar8 + 1) - iVar6;
      *(int *)((int)&Ptr->Symbol[0].Width + local_28) = iVar6;
      *(int *)((int)&Ptr->Symbol[0].Height + local_28) = iVar7 + 1;
      if (iVar6 < Ptr->MaxWidth) {
        iVar6 = Ptr->MaxWidth;
      }
      Ptr->MaxWidth = iVar6;
      iVar10 = *(int *)((int)&Ptr->Symbol[0].Height + local_28);
      if (iVar10 <= Ptr->MaxHeight) {
        iVar10 = Ptr->MaxHeight;
      }
      Ptr->MaxHeight = iVar10;
      if (local_34 <= iVar9) {
        iVar9 = local_34;
      }
    }
    local_34 = iVar9;
    local_28 = local_28 + 0x1c;
  } while (local_28 != 0x1c00);
  local_14 = 0;
  do {
    if ((&Ptr->Symbol[0].Valid)[local_14] != '\0') {
      iVar9 = *(int *)((int)&Ptr->Symbol[0].LineN + local_14);
      piVar1 = (int *)((int)&Ptr->Symbol[0].Height + local_14);
      *piVar1 = *piVar1 - local_34;
      Line = *(LineTypePtr *)((int)&Ptr->Symbol[0].Line + local_14);
      while (iVar9 != 0) {
        piVar1 = &(Line->Point1).Y;
        *piVar1 = *piVar1 - local_34;
        piVar1 = &(Line->Point2).Y;
        *piVar1 = *piVar1 - local_34;
        SetLineBoundingBox(Line);
        iVar9 = iVar9 + -1;
        Line = Line + 1;
      }
    }
    local_14 = local_14 + 0x1c;
  } while (local_14 != 0x1c00);
  LVar4 = Ptr->MaxWidth;
  (Ptr->DefaultSymbol).Y1 = 0;
  (Ptr->DefaultSymbol).X1 = 0;
  (Ptr->DefaultSymbol).X2 = LVar4;
  (Ptr->DefaultSymbol).Y2 = Ptr->MaxHeight;
  return;
}



int GetLayerNumber(DataTypePtr *Data,LayerTypePtr Layer)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    if ((LayerTypePtr)(&Data->field_0x4c + iVar1 * 0x5c) == Layer) {
      return iVar1;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x12);
  return 0x12;
}



int GetGroupOfLayer(int Layer)

{
  int iVar1;
  uint uVar2;
  Cardinal CVar3;
  uint uVar4;
  Cardinal *pCVar5;
  int iVar6;
  PCBTypePtr local_1c;
  
  iVar1 = PCB->Data->LayerN;
  if (iVar1 != Layer) {
    iVar6 = 0;
    local_1c = PCB;
    if (0 < iVar1) {
      do {
        uVar2 = (PCB->LayerGroups).Number[iVar6];
        if (uVar2 != 0) {
          if ((local_1c->LayerGroups).Entries[0] == Layer) {
            return iVar6;
          }
          pCVar5 = (PCB->LayerGroups).Entries + iVar6 * 0x12 + 1;
          uVar4 = 0;
          while (uVar4 = uVar4 + 1, uVar4 < uVar2) {
            CVar3 = *pCVar5;
            pCVar5 = pCVar5 + 1;
            if (Layer == CVar3) {
              return iVar6;
            }
          }
        }
        iVar6 = iVar6 + 1;
        local_1c = (PCBTypePtr)&local_1c->InvisibleObjectsColor;
      } while (iVar6 < iVar1);
    }
  }
  return iVar1;
}



int GetLayerGroupNumberByPointer(LayerTypePtr Layer)

{
  int iVar1;
  uint uVar2;
  Cardinal CVar3;
  int iVar4;
  Cardinal *pCVar5;
  uint uVar6;
  Cardinal CVar7;
  PCBTypePtr local_18;
  
  CVar7 = 0;
  do {
    if (Layer == (LayerTypePtr)(&PCB->Data->field_0x4c + CVar7 * 0x5c)) break;
    CVar7 = CVar7 + 1;
  } while (CVar7 != 0x12);
  iVar1 = PCB->Data->LayerN;
  iVar4 = 0;
  local_18 = PCB;
  if (0 < iVar1) {
    do {
      uVar2 = (PCB->LayerGroups).Number[iVar4];
      if (uVar2 != 0) {
        if (CVar7 == (local_18->LayerGroups).Entries[0]) {
          return iVar4;
        }
        pCVar5 = (PCB->LayerGroups).Entries + iVar4 * 0x12 + 1;
        uVar6 = 0;
        while (uVar6 = uVar6 + 1, uVar6 < uVar2) {
          CVar3 = *pCVar5;
          pCVar5 = pCVar5 + 1;
          if (CVar7 == CVar3) {
            return iVar4;
          }
        }
      }
      iVar4 = iVar4 + 1;
      local_18 = (PCBTypePtr)&local_18->InvisibleObjectsColor;
    } while (iVar4 < iVar1);
  }
  return iVar4;
}



int GetLayerGroupNumberByNumber(Cardinal Layer)

{
  int iVar1;
  uint uVar2;
  Cardinal CVar3;
  int iVar4;
  Cardinal *pCVar5;
  uint uVar6;
  PCBTypePtr local_18;
  
  local_18 = PCB;
  iVar1 = PCB->Data->LayerN;
  iVar4 = 0;
  if (0 < iVar1) {
    do {
      uVar2 = (PCB->LayerGroups).Number[iVar4];
      if (uVar2 != 0) {
        if ((local_18->LayerGroups).Entries[0] == Layer) {
          return iVar4;
        }
        pCVar5 = (PCB->LayerGroups).Entries + iVar4 * 0x12 + 1;
        uVar6 = 0;
        while (uVar6 = uVar6 + 1, uVar6 < uVar2) {
          CVar3 = *pCVar5;
          pCVar5 = pCVar5 + 1;
          if (CVar3 == Layer) {
            return iVar4;
          }
        }
      }
      iVar4 = iVar4 + 1;
      local_18 = (PCBTypePtr)&local_18->InvisibleObjectsColor;
    } while (iVar4 < iVar1);
  }
  return iVar4;
}



int mem_any_set(uchar *ptr,int bytes)

{
  while( true ) {
    if (bytes == 0) {
      return 0;
    }
    bytes = bytes + -1;
    if (*ptr != '\0') break;
    ptr = ptr + 1;
  }
  return 1;
}



FlagType * AddFlags(FlagType *__return_storage_ptr__,FlagType flag,uint flags)

{
  __return_storage_ptr__->t[7] = flag.t[7];
  __return_storage_ptr__->f = flags | flag.f;
  __return_storage_ptr__->t[6] = flag.t[6];
  __return_storage_ptr__->t[5] = flag.t[5];
  __return_storage_ptr__->t[4] = flag.t[4];
  __return_storage_ptr__->t[3] = flag.t[3];
  __return_storage_ptr__->t[2] = flag.t[2];
  __return_storage_ptr__->t[1] = flag.t[1];
  __return_storage_ptr__->t[0] = flag.t[0];
  return __return_storage_ptr__;
}



FlagType * MaskFlags(FlagType *__return_storage_ptr__,FlagType flag,uint flags)

{
  __return_storage_ptr__->t[7] = flag.t[7];
  __return_storage_ptr__->t[6] = flag.t[6];
  __return_storage_ptr__->f = ~flags & flag.f;
  __return_storage_ptr__->t[5] = flag.t[5];
  __return_storage_ptr__->t[4] = flag.t[4];
  __return_storage_ptr__->t[3] = flag.t[3];
  __return_storage_ptr__->t[2] = flag.t[2];
  __return_storage_ptr__->t[1] = flag.t[1];
  __return_storage_ptr__->t[0] = flag.t[0];
  return __return_storage_ptr__;
}



int MoveLayerToGroup(int layer,int group)

{
  int iVar1;
  Cardinal CVar2;
  uint uVar3;
  ulong uVar4;
  Cardinal CVar5;
  PCBTypePtr pPVar6;
  Cardinal CVar7;
  int iVar8;
  uint uVar9;
  Cardinal *pCVar10;
  int iVar11;
  PCBTypePtr local_24;
  PCBTypePtr local_1c;
  
  pPVar6 = PCB;
  if (-1 < layer) {
    CVar2 = PCB->Data->LayerN;
    CVar7 = CVar2 + 1;
    if (layer <= (int)CVar7) {
      iVar8 = 0;
      local_1c = PCB;
      if (0 < (int)CVar2) {
        do {
          uVar3 = (PCB->LayerGroups).Number[iVar8];
          if (uVar3 != 0) {
            if (layer == (local_1c->LayerGroups).Entries[0]) break;
            pCVar10 = (PCB->LayerGroups).Entries + iVar8 * 0x12 + 1;
            uVar9 = 0;
            while (uVar9 = uVar9 + 1, uVar9 < uVar3) {
              CVar5 = *pCVar10;
              pCVar10 = pCVar10 + 1;
              if (layer == CVar5) goto LAB_080a2f40;
            }
          }
          iVar8 = iVar8 + 1;
          local_1c = (PCBTypePtr)&local_1c->InvisibleObjectsColor;
        } while (iVar8 < (int)CVar2);
      }
LAB_080a2f40:
      if (layer == CVar2) {
        local_1c = (PCBTypePtr)0x0;
        local_24 = PCB;
        if (0 < layer) {
          do {
            uVar3 = (PCB->LayerGroups).Number[(int)local_1c];
            if (uVar3 != 0) {
              if (CVar7 == (local_24->LayerGroups).Entries[0]) break;
              pCVar10 = (PCB->LayerGroups).Entries + (int)local_1c * 0x12 + 1;
              uVar9 = 0;
              while (uVar9 = uVar9 + 1, uVar9 < uVar3) {
                CVar5 = *pCVar10;
                pCVar10 = pCVar10 + 1;
                if (CVar7 == CVar5) goto LAB_080a307b;
              }
            }
            local_1c = (PCBTypePtr)((int)local_1c + 1);
            local_24 = (PCBTypePtr)&local_24->InvisibleObjectsColor;
          } while ((int)local_1c < layer);
        }
LAB_080a307b:
        if ((PCBTypePtr)group == local_1c) {
          return iVar8;
        }
      }
      if (layer == CVar7) {
        iVar11 = 0;
        local_1c = PCB;
        if (0 < (int)CVar2) {
          do {
            uVar3 = (PCB->LayerGroups).Number[iVar11];
            if (uVar3 != 0) {
              if (CVar2 == (local_1c->LayerGroups).Entries[0]) break;
              pCVar10 = (PCB->LayerGroups).Entries + iVar11 * 0x12 + 1;
              uVar9 = 0;
              while (uVar9 = uVar9 + 1, uVar9 < uVar3) {
                CVar7 = *pCVar10;
                pCVar10 = pCVar10 + 1;
                if (CVar2 == CVar7) goto LAB_080a30fe;
              }
            }
            iVar11 = iVar11 + 1;
            local_1c = (PCBTypePtr)&local_1c->InvisibleObjectsColor;
          } while (iVar11 < (int)CVar2);
        }
LAB_080a30fe:
        if (group == iVar11) {
          return iVar8;
        }
      }
      if (group < 0) {
        return iVar8;
      }
      if ((int)CVar2 <= group) {
        return iVar8;
      }
      if (group == iVar8) {
        return iVar8;
      }
      uVar3 = (&(PCB->Flags).f)[iVar8 + 0x734];
      if (uVar3 != 0) {
        uVar9 = 0;
        pCVar10 = (PCB->LayerGroups).Entries + iVar8 * 0x12;
        iVar11 = 0;
        do {
          if (layer != *pCVar10) {
            iVar1 = iVar11 + 0x744;
            iVar11 = iVar11 + 1;
            (&(pPVar6->Flags).f)[iVar1 + iVar8 * 0x12] = *pCVar10;
          }
          uVar9 = uVar9 + 1;
          pCVar10 = pCVar10 + 1;
        } while (uVar9 < uVar3);
      }
      (&(pPVar6->Flags).f)[iVar8 + 0x734] = uVar3 - 1;
      uVar4 = (&(pPVar6->Flags).f)[group + 0x734];
      (&(pPVar6->Flags).f)[group + 0x734] = uVar4 + 1;
      (&(pPVar6->Flags).f)[uVar4 + 0x744 + group * 0x12] = layer;
      return group;
    }
  }
  return -1;
}



char * GetInfoString(void)

{
  HID **ppHVar1;
  int first_time;
  DynamicStringType info;
  HID **ppHVar2;
  HID *pHVar3;
  HID **ppHVar4;
  HID **ppHVar5;
  
  if (first_time != 0) {
    first_time = 0;
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"This is PCB, an interactive\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"printed circuit board editor\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"version ");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"20091103");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"\n\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"Compiled on Mar 28 2011 at 02:42:45");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"\n\nby harry eaton\n\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,
                "Copyright (C) Thomas Nau 1994, 1995, 1996, 1997\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"Copyright (C) harry eaton 1998-2007\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"Copyright (C) C. Scott Ananian 2001\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,
                "Copyright (C) DJ Delorie 2003, 2004, 2005, 2006, 2007, 2008\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,
                "Copyright (C) Dan McMahill 2003, 2004, 2005, 2006, 2007, 2008\n\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,
                "It is licensed under the terms of the GNU\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"General Public License version 2\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,
                "See the LICENSE file for more information\n\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"For more information see:\n\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"PCB homepage: http://pcb.gpleda.org\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"gEDA homepage: http://www.gpleda.org\n")
    ;
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,
                "gEDA Wiki: http://geda.seul.org/wiki/ \n\n");
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"----- Compile Time Options -----\n");
    ppHVar2 = hid_enumerate();
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"GUI:\n");
    pHVar3 = *ppHVar2;
    if (pHVar3 != (HID *)0x0) {
      ppHVar1 = ppHVar2 + 1;
      ppHVar5 = ppHVar2;
      do {
        while (ppHVar4 = ppHVar1, (*(byte *)&pHVar3->field_0xc & 1) != 0) {
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"    ");
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,(*ppHVar5)->name);
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860," : ");
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,(*ppHVar5)->description);
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"\n");
          pHVar3 = *ppHVar4;
          ppHVar1 = ppHVar4 + 1;
          ppHVar5 = ppHVar4;
          if (pHVar3 == (HID *)0x0) goto LAB_080a337a;
        }
        pHVar3 = *ppHVar4;
        ppHVar1 = ppHVar4 + 1;
        ppHVar5 = ppHVar4;
      } while (pHVar3 != (HID *)0x0);
    }
LAB_080a337a:
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"Exporters:\n");
    pHVar3 = *ppHVar2;
    if (pHVar3 != (HID *)0x0) {
      ppHVar1 = ppHVar2 + 1;
      ppHVar5 = ppHVar2;
      do {
        while (ppHVar4 = ppHVar1, (*(byte *)&pHVar3->field_0xc & 4) != 0) {
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"    ");
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,(*ppHVar5)->name);
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860," : ");
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,(*ppHVar5)->description);
          DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"\n");
          pHVar3 = *ppHVar4;
          ppHVar1 = ppHVar4 + 1;
          ppHVar5 = ppHVar4;
          if (pHVar3 == (HID *)0x0) goto LAB_080a3422;
        }
        pHVar3 = *ppHVar4;
        ppHVar1 = ppHVar4 + 1;
        ppHVar5 = ppHVar4;
      } while (pHVar3 != (HID *)0x0);
    }
LAB_080a3422:
    DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"Printers:\n");
    pHVar3 = *ppHVar2;
    while (pHVar3 != (HID *)0x0) {
      if ((*(byte *)&pHVar3->field_0xc & 2) != 0) {
        DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"    ");
        DSAddString((DynamicStringTypePtr_conflict *)0x816c860,(*ppHVar2)->name);
        DSAddString((DynamicStringTypePtr_conflict *)0x816c860," : ");
        DSAddString((DynamicStringTypePtr_conflict *)0x816c860,(*ppHVar2)->description);
        DSAddString((DynamicStringTypePtr_conflict *)0x816c860,"\n");
      }
      pHVar3 = ppHVar2[1];
      ppHVar2 = ppHVar2 + 1;
    }
  }
  return info.Data;
}



void r_delete_element(DataType *data,ElementType *element)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint local_20;
  
  r_delete_entry(data->element_tree,(BoxType *)element);
  if (element->PinN != 0) {
    uVar2 = 0;
    local_20 = element->PinN;
    do {
      r_delete_entry(data->pin_tree,(BoxType *)(element->Pin + uVar2));
      uVar1 = element->PinN;
      if (uVar1 == 0) break;
      uVar2 = (uVar1 + 1 + uVar2) - local_20;
      local_20 = uVar1;
    } while (uVar2 < uVar1);
  }
  uVar2 = element->PadN;
  uVar3 = 0;
  local_20 = 0;
  uVar1 = uVar2;
  while ((uVar1 != 0 && (uVar3 < uVar1))) {
    r_delete_entry(data->pad_tree,(BoxType *)((int)&(element->Pad->BoundingBox).X1 + local_20));
    uVar1 = element->PadN;
    if (element->PadN == uVar2) {
      uVar3 = uVar3 + 1;
      local_20 = local_20 + 0x68;
      uVar1 = uVar2;
    }
  }
  r_delete_entry(data->name_tree[2],(BoxType *)(element->Name + 2));
  r_delete_entry(data->name_tree[1],(BoxType *)(element->Name + 1));
  r_delete_entry(data->name_tree[0],(BoxType *)element->Name);
  return;
}



double c_strtod(char *s)

{
  double dVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  double dVar5;
  int iVar6;
  char cVar7;
  int local_10 [3];
  
  cVar7 = *s;
joined_r0x080a35ce:
  if (cVar7 != '\0') {
    if ((cVar7 == '\t') || (cVar7 == ' ')) goto LAB_080a35d8;
    if (cVar7 == '-') {
      s = s + 1;
      cVar7 = *s;
      fVar4 = -1.00000000;
    }
    else {
      if (cVar7 == '+') {
        s = s + 1;
        cVar7 = *s;
      }
      fVar4 = 1.00000000;
    }
    if ((byte)(cVar7 - 0x30U) < 10) {
      fVar2 = 0.00000000;
      do {
        iVar6 = (int)cVar7;
        s = s + 1;
        cVar7 = *s;
        fVar2 = (float)(int)(&DAT_ffffffd0 + iVar6) + fVar2 * 10.00000000;
      } while ((byte)(cVar7 - 0x30U) < 10);
    }
    else {
      fVar2 = 0.00000000;
    }
    if (cVar7 != '.') goto LAB_080a36bc;
    s = s + 1;
    cVar7 = *s;
    if (9 < (byte)(cVar7 - 0x30U)) goto LAB_080a36bc;
    fVar3 = 0.09999999;
    do {
      iVar6 = (int)cVar7;
      s = s + 1;
      cVar7 = *s;
      fVar2 = (float)(int)(&DAT_ffffffd0 + iVar6) * fVar3 + fVar2;
      fVar3 = fVar3 * 0.09999999;
    } while ((byte)(cVar7 - 0x30U) < 10);
    if (cVar7 == 'e') goto LAB_080a3688;
    goto LAB_080a36c1;
  }
  fVar4 = 1.00000000;
  fVar2 = 0.00000000;
LAB_080a36bc:
  if (cVar7 != 'e') {
LAB_080a36c1:
    if (cVar7 != 'E') {
      return (double)(fVar2 * fVar4);
    }
  }
LAB_080a3688:
  dVar1 = (double)fVar2;
  iVar6 = sscanf(s + 1,"%d",local_10);
  if (iVar6 != 1) {
    return (double)fVar4 * dVar1;
  }
  if (local_10[0] < 1) {
    if (local_10[0] == 0) {
      dVar1 = dVar1 * 1.00000000;
    }
    else {
      dVar5 = 1.00000000;
      do {
        local_10[0] = local_10[0] + 1;
        dVar5 = dVar5 * 0.10000000;
      } while (local_10[0] != 0);
      dVar1 = dVar5 * dVar1;
    }
  }
  else {
    dVar5 = 1.00000000;
    do {
      local_10[0] = local_10[0] + -1;
      dVar5 = dVar5 * 10.00000000;
    } while (local_10[0] != 0);
    dVar1 = dVar5 * dVar1;
  }
  return (double)fVar4 * dVar1;
LAB_080a35d8:
  s = s + 1;
  cVar7 = *s;
  goto joined_r0x080a35ce;
}



char * c_dtostr(double d)

{
  char buf [100];
  size_t sVar1;
  char *__s;
  double dVar2;
  
  __s = (char *)0x816c880;
  if (d < 0.00000000) {
    buf[0] = '-';
    d = -d;
    __s = (char *)0x816c881;
  }
  dVar2 = floor(d + 0.00000050);
  __sprintf_chk(__s,1,100,&DAT_081538d1,(int)ROUND(dVar2));
  sVar1 = strlen(__s);
  __s[sVar1] = '.';
  dVar2 = floor(((d + 0.00000050) - (double)(int)ROUND(dVar2)) * 1000000.00000000);
  __sprintf_chk(__s + sVar1 + 1,1,0xffffffff,&DAT_08149df7,(int)ROUND(dVar2));
  return (char *)0x816c880;
}



char * LayerGroupsToString(LayerGroupTypePtr lg)

{
  int *piVar1;
  ulong uVar2;
  bool bVar3;
  char buf [91];
  PCBTypePtr pPVar4;
  PCBTypePtr pPVar5;
  PCBTypePtr pPVar6;
  ulong uVar7;
  char *pcVar8;
  int iVar9;
  int local_2c;
  uint local_20;
  
  pcVar8 = &ram0x0816c900;
  if (0 < PCB->Data->LayerN) {
    bVar3 = false;
    local_2c = 0;
    pPVar4 = PCB;
    pPVar6 = PCB;
    do {
      iVar9 = local_2c + 0x734;
      pPVar5 = pPVar4;
      if ((&(pPVar6->Flags).f)[iVar9] != 0) {
        if (bVar3) {
          *pcVar8 = ':';
          pcVar8 = pcVar8 + 1;
        }
        bVar3 = true;
        local_20 = 0;
        pPVar5 = pPVar6;
        if ((&(pPVar6->Flags).f)[iVar9] != 0) {
          do {
            uVar7 = (&(pPVar6->Flags).f)[local_20 + 0x744 + local_2c * 0x12];
            uVar2 = pPVar6->Data->LayerN;
            if (uVar2 + 1 == uVar7) {
              *pcVar8 = 'c';
              pcVar8 = pcVar8 + 1;
            }
            else {
              if (uVar7 == uVar2) {
                *pcVar8 = 's';
                pcVar8 = pcVar8 + 1;
              }
              else {
                __sprintf_chk(pcVar8,1,0x5b,&DAT_081538d1,uVar7 + 1);
                do {
                  pcVar8 = pcVar8 + 1;
                  pPVar4 = PCB;
                } while (*pcVar8 != '\0');
              }
            }
            uVar7 = (&(pPVar4->Flags).f)[iVar9];
            if (local_20 != uVar7 - 1) {
              *pcVar8 = ',';
              pcVar8 = pcVar8 + 1;
              uVar7 = (&(pPVar4->Flags).f)[iVar9];
            }
            local_20 = local_20 + 1;
            pPVar6 = pPVar4;
          } while (local_20 < uVar7);
          bVar3 = true;
          pPVar5 = pPVar4;
        }
      }
      local_2c = local_2c + 1;
      piVar1 = &pPVar5->Data->LayerN;
      pPVar6 = pPVar5;
    } while (*piVar1 != local_2c && local_2c <= *piVar1);
  }
  *pcVar8 = '\0';
  return (char *)0x816c900;
}



char * pcb_author(void)

{
  char *__s;
  char *fab_author;
  passwd *pwentry;
  __uid_t __uid;
  char *__n;
  
  if ((fab_author != (char *)0x0) ||
     ((Settings.FabAuthor != (char *)0x0 &&
      (fab_author = Settings.FabAuthor, *Settings.FabAuthor != '\0')))) {
    return fab_author;
  }
  __uid = getuid();
  pwentry = (passwd *)getpwuid(__uid);
  __s = ((passwd *)pwentry)->pw_gecos;
  __n = strchr(__s,0x2c);
  if (__n == (char *)0x0) {
    __n = (char *)strlen(__s);
  }
  else {
    __n = __n + -(int)__s;
  }
  fab_author = (char *)calloc(1,(size_t)(__n + 1));
  if (fab_author == (char *)0x0) {
    perror("pcb: out of memory.\n");
                    // WARNING: Subroutine does not return
    exit(-1);
  }
  memcpy(fab_author,__s,(size_t)__n);
  fab_author[(int)__n] = '\0';
  return fab_author;
}



char * Concat(char *first,...)

{
  size_t sVar1;
  size_t sVar2;
  char **ppcVar3;
  char *__dest;
  char *in_stack_00000008;
  
  sVar1 = strlen(first);
  __dest = (char *)calloc(1,sVar1 + 1);
  strcpy(__dest,first);
  ppcVar3 = (char **)&stack0x0000000c;
  if (in_stack_00000008 != (char *)0x0) {
    do {
      sVar2 = strlen(in_stack_00000008);
      sVar1 = sVar1 + sVar2;
      __dest = (char *)realloc(__dest,sVar1 + 1);
      strcat(__dest,in_stack_00000008);
      in_stack_00000008 = *ppcVar3;
      ppcVar3 = ppcVar3 + 1;
    } while (in_stack_00000008 != (char *)0x0);
  }
  return __dest;
}



int FileExists(char *name)

{
  FILE *__stream;
  
  __stream = fopen(name,"r");
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
  }
  return (uint)(__stream != (FILE *)0x0);
}



char * UniqueElementName(DataTypePtr *Data,char *Name)

{
  int iVar1;
  ushort **ppuVar2;
  long lVar3;
  char cVar4;
  char **ppcVar5;
  int iVar6;
  char *pcVar7;
  char *__nptr;
  
  if ((Name != (char *)0x0) && (*Name != '\0')) {
    while( true ) {
      iVar6 = Data->ElementN - 1;
      if (iVar6 == -1) break;
      ppcVar5 = &Data->Element[Data->ElementN - 1].Name[1].TextString;
      while ((*ppcVar5 == (char *)0x0 || (iVar1 = strcmp(*ppcVar5,Name), iVar1 != 0))) {
        iVar6 = iVar6 + -1;
        ppcVar5 = ppcVar5 + -0x4b;
        if (iVar6 == -1) {
          return Name;
        }
      }
      cVar4 = *Name;
      pcVar7 = Name;
      while (cVar4 != '\0') {
        pcVar7 = pcVar7 + 1;
        cVar4 = *pcVar7;
      }
      ppuVar2 = __ctype_b_loc();
      do {
        __nptr = pcVar7;
        pcVar7 = __nptr + -1;
      } while ((*(byte *)((int)*ppuVar2 + (int)__nptr[-1] * 2 + 1) & 8) != 0);
      cVar4 = '\0';
      iVar6 = 1;
      if (*__nptr != '\0') {
        lVar3 = strtol(__nptr,(char **)0x0,10);
        cVar4 = *__nptr;
        iVar6 = lVar3 + 1;
      }
      *__nptr = '\0';
      __sprintf_chk(temp,1,0x100,&DAT_08139f46,Name,iVar6);
      if (Name == temp) {
        cVar4 = *__nptr;
      }
      *__nptr = cVar4;
      Name = temp;
    }
  }
  return Name;
}



int ParseGroupString(char *s,LayerGroupTypePtr LayerGroup,int LayerN)

{
  ushort uVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  Cardinal CVar7;
  ushort **ppuVar8;
  long lVar9;
  Cardinal CVar10;
  char cVar11;
  int iVar12;
  ushort *puVar13;
  LayerGroupTypePtr pLVar14;
  Cardinal CVar15;
  byte bVar16;
  int local_74;
  Cardinal *local_70;
  int groupnum [18];
  
  bVar16 = 0;
  iVar12 = 0x130;
  iVar6 = 0;
  pLVar14 = LayerGroup;
  while (iVar12 != 0) {
    iVar12 = iVar12 + -1;
    pLVar14->Number[0] = 0;
    pLVar14 = (LayerGroupTypePtr)(pLVar14->Number + 1);
  }
  do {
    groupnum[iVar6] = -1;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 0x12);
  if (((s != (char *)0x0) && (cVar11 = *s, 0 < LayerN)) && (cVar11 != '\0')) {
    bVar4 = false;
    bVar5 = false;
    local_74 = 0;
    CVar7 = LayerN + 1;
    do {
      if (cVar11 != '\0') {
        ppuVar8 = __ctype_b_loc();
        puVar13 = *ppuVar8;
        do {
          if ((*(byte *)((int)puVar13 + (int)cVar11 * 2 + 1) & 0x20) == 0) {
            if (cVar11 != '\0') {
              local_70 = LayerGroup->Entries + local_74 * 0x12;
              CVar15 = 0;
              goto LAB_080a3d2e;
            }
            break;
          }
          s = s + 1;
          cVar11 = *s;
        } while (cVar11 != '\0');
      }
      CVar15 = 0;
LAB_080a3dd0:
      LayerGroup->Number[local_74] = CVar15;
      local_74 = local_74 + 1;
      s = s + (*s == ':');
      if (s == (char *)0x0) goto LAB_080a3e04;
      cVar11 = *s;
      if ((cVar11 == '\0') || (LayerN <= local_74)) goto LAB_080a3e04;
    } while( true );
  }
  bVar2 = 0 < LayerN;
  bVar5 = false;
  local_74 = 0;
LAB_080a3ecd:
  CVar7 = LayerGroup->Number[0];
  LayerGroup->Entries[CVar7] = LayerN;
  LayerGroup->Number[0] = CVar7 + 1;
  bVar3 = 0 < LayerN;
LAB_080a3ee3:
  if (!bVar5) {
    CVar7 = LayerGroup->Number[1];
    LayerGroup->Entries[CVar7 + 0x12] = LayerN + 1;
    LayerGroup->Number[1] = CVar7 + 1;
  }
  if ((bVar2) && (bVar3)) {
    CVar7 = 0;
    do {
      iVar6 = local_74;
      if (groupnum[CVar7] == -1) {
        LayerGroup->Number[local_74] = 1;
        iVar6 = local_74 + 1;
        LayerGroup->Entries[local_74 * 0x12] = CVar7;
      }
      CVar7 = CVar7 + 1;
    } while ((iVar6 < LayerN) && (local_74 = iVar6, (int)CVar7 < LayerN));
  }
  return 0;
LAB_080a3d2e:
  uVar1 = puVar13[cVar11];
  if ((uVar1 & 0x2000) != 0) {
    s = s + 1;
    cVar11 = *s;
    if (cVar11 == '\0') {
      uVar1 = *puVar13;
      goto joined_r0x080a3e66;
    }
    goto LAB_080a3d2e;
  }
  if (cVar11 == 'S') {
LAB_080a3ea6:
    bVar4 = true;
    bVar2 = (int)CVar7 < LayerN;
    CVar10 = LayerN;
LAB_080a3d89:
    if (bVar2) goto LAB_080a3e6c;
  }
  else {
    if (cVar11 < 'T') {
      if (cVar11 != 'C') {
joined_r0x080a3e66:
        if ((uVar1 & 0x800) == 0) goto LAB_080a3e6c;
        lVar9 = strtol(s,(char **)0x0,10);
        bVar2 = (int)CVar7 < (int)(lVar9 - 1U);
        CVar10 = lVar9 - 1U;
        goto LAB_080a3d89;
      }
    }
    else {
      if (cVar11 != 'c') {
        if (cVar11 == 's') goto LAB_080a3ea6;
        goto joined_r0x080a3e66;
      }
    }
    bVar5 = true;
    CVar10 = CVar7;
  }
  if (LayerN < (int)CVar15) {
LAB_080a3e6c:
    iVar6 = 0x130;
    while (iVar6 != 0) {
      iVar6 = iVar6 + -1;
      LayerGroup->Number[0] = 0;
      LayerGroup = (LayerGroupTypePtr)((int)LayerGroup + (uint)bVar16 * -8 + 4);
    }
    return 1;
  }
  s = s + 1;
  CVar15 = CVar15 + 1;
  groupnum[CVar10] = local_74;
  *local_70 = CVar10;
  cVar11 = *s;
  while( true ) {
    if (cVar11 == '\0') goto LAB_080a3dd0;
    puVar13 = *ppuVar8;
    uVar1 = puVar13[cVar11];
    if ((uVar1 & 0x800) == 0) break;
    s = s + 1;
    cVar11 = *s;
  }
  while ((uVar1 & 0x2000) != 0) {
    s = s + 1;
    cVar11 = *s;
    if (cVar11 == '\0') goto LAB_080a3dd0;
    uVar1 = puVar13[cVar11];
  }
  if (cVar11 == ':') goto LAB_080a3dd0;
  if (cVar11 != ',') goto LAB_080a3e6c;
  s = s + 1;
  cVar11 = *s;
  local_70 = local_70 + 1;
  if (cVar11 == '\0') goto LAB_080a3dd0;
  goto LAB_080a3d2e;
LAB_080a3e04:
  bVar2 = local_74 < LayerN;
  bVar3 = true;
  if (bVar4) goto LAB_080a3ee3;
  bVar2 = local_74 < LayerN;
  goto LAB_080a3ecd;
}



void __regparm3 GetNum(char **s,BDimension *num)

{
  char cVar1;
  ushort *puVar2;
  long lVar3;
  ushort **ppuVar4;
  char *pcVar5;
  
  lVar3 = strtol(*s,(char **)0x0,10);
  *num = lVar3;
  ppuVar4 = __ctype_b_loc();
  puVar2 = *ppuVar4;
  pcVar5 = *s;
  while (cVar1 = *pcVar5, pcVar5 = pcVar5 + 1,
        (*(byte *)((int)puVar2 + (int)cVar1 * 2 + 1) & 8) != 0) {
    *s = pcVar5;
  }
  return;
}



void __regparm3 RightAngles(int Angle,float *cosa,float *sina)

{
  double local_1c;
  double local_14;
  
  sincos((double)Angle * 0.01745329,&local_14,&local_1c);
  *cosa = (float)local_1c;
  *sina = (float)local_14;
  return;
}



BoxTypePtr GetArcEnds(ArcTypePtr *Arc)

{
  BoxType box;
  float local_24;
  float local_20 [4];
  
  RightAngles(Arc->StartAngle,local_20,&local_24);
  box.X1 = (LocationType)ROUND((float)Arc->X - (float)Arc->Width * local_20[0]);
  box.Y1 = (LocationType)ROUND((float)Arc->Height * local_24 + (float)Arc->Y);
  RightAngles(Arc->Delta + Arc->StartAngle,local_20,&local_24);
  return (BoxTypePtr)0x816ca60;
}



void SetArcBoundingBox(ArcTypePtr *Arc)

{
  int iVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  bool bVar11;
  double local_2c;
  double local_24 [2];
  
  iVar9 = Arc->Delta;
  if (iVar9 < 0x169) {
    iVar8 = Arc->StartAngle;
    iVar7 = iVar8 + iVar9;
    iVar10 = iVar7;
    if (-1 < iVar9) goto LAB_080a40da;
    if (-1 < iVar7) goto LAB_080a40e2;
LAB_080a42dc:
    iVar10 = iVar7 + 0x168;
    iVar8 = iVar8 + 0x168;
    iVar9 = iVar7 + 0x10e;
    bVar11 = iVar9 == 0;
    if (!bVar11) goto LAB_080a40eb;
LAB_080a42f1:
    dVar4 = 1.00000000;
    iVar9 = iVar8 + -0x5a;
    bVar11 = iVar9 == 0;
    dVar5 = 0.00000000;
    if (!bVar11) goto LAB_080a413f;
LAB_080a42fe:
    local_24[0] = 1.00000000;
    iVar9 = Arc->X;
    local_2c = 0.00000000;
    iVar7 = Arc->Width;
    if (iVar8 < 0xb5) {
      local_24[0] = 1.00000000;
      local_2c = 0.00000000;
    }
    else {
LAB_080a419e:
      if (iVar10 < 0xb4) {
        dVar6 = -1.00000000;
        goto LAB_080a41ae;
      }
    }
  }
  else {
    Arc->Delta = 0x168;
    iVar10 = Arc->StartAngle + 0x168;
    iVar8 = Arc->StartAngle;
LAB_080a40da:
    iVar7 = iVar8;
    iVar8 = iVar10;
    if (iVar7 < 0) goto LAB_080a42dc;
LAB_080a40e2:
    iVar9 = iVar7 + -0x5a;
    bVar11 = iVar7 == 0x5a;
    iVar10 = iVar7;
    if (bVar11) goto LAB_080a42f1;
LAB_080a40eb:
    if (bVar11 || SBORROW4(iVar10,0x5a) != iVar9 < 0) {
      if (iVar10 == 0) {
        dVar4 = 0.00000000;
        dVar5 = 1.00000000;
      }
      else {
LAB_080a410e:
        sincos((double)iVar10 * 0.01745329,local_24,&local_2c);
        dVar4 = local_24[0];
        dVar5 = local_2c;
      }
    }
    else {
      if (iVar10 == 0xb4) {
        dVar4 = 0.00000000;
        dVar5 = -1.00000000;
      }
      else {
        if (iVar10 != 0x10e) goto LAB_080a410e;
        dVar4 = -1.00000000;
        dVar5 = 0.00000000;
      }
    }
    iVar9 = iVar8 + -0x5a;
    bVar11 = iVar8 == 0x5a;
    if (bVar11) goto LAB_080a42fe;
LAB_080a413f:
    if (bVar11 || SBORROW4(iVar8,0x5a) != iVar9 < 0) {
      if (iVar8 == 0) {
        local_2c = 1.00000000;
        local_24[0] = 0.00000000;
      }
      else {
LAB_080a414d:
        sincos((double)iVar8 * 0.01745329,local_24,&local_2c);
      }
    }
    else {
      if (iVar8 == 0xb4) {
        local_2c = -1.00000000;
        local_24[0] = 0.00000000;
      }
      else {
        if (iVar8 != 0x10e) goto LAB_080a414d;
        local_24[0] = -1.00000000;
        local_2c = 0.00000000;
      }
    }
    iVar9 = Arc->X;
    iVar7 = Arc->Width;
    if (0xb4 < iVar8) goto LAB_080a419e;
  }
  dVar6 = local_2c;
  if (dVar5 <= local_2c || local_2c != dVar5) {
    dVar6 = dVar5;
  }
LAB_080a41ae:
  iVar1 = (int)ROUND((double)iVar9 - (double)iVar7 * dVar6);
  (Arc->BoundingBox).X2 = iVar1;
  if ((iVar8 < 0x169) || (0x167 < iVar10)) {
    if (dVar5 <= local_2c) {
      dVar5 = local_2c;
    }
  }
  else {
    dVar5 = 1.00000000;
  }
  iVar2 = Arc->Y;
  iVar3 = Arc->Height;
  iVar9 = (int)ROUND((double)iVar9 - (double)iVar7 * dVar5);
  (Arc->BoundingBox).X1 = iVar9;
  if ((iVar8 < 0x5b) || (0x59 < iVar10)) {
    dVar5 = local_24[0];
    if (local_24[0] <= dVar4 || dVar4 != local_24[0]) {
      dVar5 = dVar4;
    }
  }
  else {
    dVar5 = 1.00000000;
  }
  iVar7 = (int)ROUND((double)iVar2 + (double)iVar3 * dVar5);
  (Arc->BoundingBox).Y2 = iVar7;
  if ((iVar8 < 0x10f) || (0x10d < iVar10)) {
    if (dVar4 <= local_24[0] || local_24[0] != dVar4) {
      local_24[0] = dVar4;
    }
  }
  else {
    local_24[0] = -1.00000000;
  }
  iVar8 = (Arc->Clearance + Arc->Thickness) / 2;
  (Arc->BoundingBox).X1 = iVar9 - iVar8;
  (Arc->BoundingBox).Y1 = (int)ROUND((double)iVar2 + (double)iVar3 * local_24[0]) - iVar8;
  (Arc->BoundingBox).X2 = iVar1 + iVar8 + 1;
  (Arc->BoundingBox).Y2 = iVar8 + 1 + iVar7;
  return;
}



void ChangeArcAngles(LayerTypePtr Layer,ArcTypePtr *a,long new_sa,long new_da)

{
  if (0x167 < new_da) {
    new_da = 0x168;
    new_sa = 0;
  }
  RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,a);
  r_delete_entry(Layer->arc_tree,(BoxType *)a);
  AddObjectToChangeAnglesUndoList(0x4000,a,a,a);
  a->Delta = new_da;
  a->StartAngle = new_sa;
  SetArcBoundingBox(a);
  r_insert_entry(Layer->arc_tree,(BoxType *)a,0);
  ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,a);
  return;
}



void CreateQuotedString(DynamicStringTypePtr DS,char *S)

{
  char Char;
  
  DSClearString((DynamicStringTypePtr_conflict *)DS);
  Char = '\"';
  while( true ) {
    DSAddCharacter((DynamicStringTypePtr_conflict *)DS,Char);
    Char = *S;
    if (Char == '\0') break;
    if ((Char == '\\') || (Char == '\"')) {
      DSAddCharacter((DynamicStringTypePtr_conflict *)DS,'\\');
    }
    Char = *S;
    S = S + 1;
  }
  DSAddCharacter((DynamicStringTypePtr_conflict *)DS,'\"');
  return;
}



char * GetWorkingDirectory(char *path)

{
  char *pcVar1;
  
  pcVar1 = getcwd(path,0x1000);
  return pcVar1;
}



void RestoreStackAndVisibility(void)

{
  Boolean *pBVar1;
  PCBTypePtr pPVar2;
  uint uVar3;
  DataTypePtr *pDVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  
  if (SavedStack.cnt != 0) {
    iVar7 = 1;
    if (SavedStack.cnt != 1) {
      __fprintf_chk(stderr,1,
                    "RestoreStackAndVisibility()  layerstack save count is wrong.  cnt = %d\n",
                    SavedStack.cnt);
      iVar7 = SavedStack.cnt;
    }
    pPVar2 = PCB;
    pDVar4 = PCB->Data;
    uVar5 = pDVar4->LayerN;
    if (uVar5 != 0xfffffffe) {
      uVar3 = 0;
      do {
        if (uVar3 < uVar5) {
          LayerStack[uVar3] = SavedStack.LayerStack[uVar3];
        }
        iVar6 = uVar3 * 0x5c;
        pBVar1 = SavedStack.LayerOn + uVar3;
        uVar3 = uVar3 + 1;
        *(Boolean *)(&pDVar4->field_0x90 + iVar6) = *pBVar1;
        pDVar4 = pPVar2->Data;
        uVar5 = pDVar4->LayerN;
      } while (uVar3 < uVar5 + 2);
    }
    pPVar2->ElementOn = SavedStack.ElementOn;
    pPVar2->InvisibleObjectsOn = SavedStack.InvisibleObjectsOn;
    pPVar2->PinOn = SavedStack.PinOn;
    pPVar2->ViaOn = SavedStack.ViaOn;
    pPVar2->RatOn = SavedStack.RatOn;
    SavedStack.cnt = iVar7 + -1;
    return;
  }
  __fprintf_chk(stderr,1,"RestoreStackAndVisibility()  layerstack has not been saved.  cnt = %d\n",0
               );
  return;
}



void SaveStackAndVisibility(void)

{
  Boolean *pBVar1;
  uint uVar2;
  PCBTypePtr pPVar3;
  Boolean run;
  uint uVar4;
  DataTypePtr *pDVar5;
  int local_20;
  
  if (run == '\0') {
    local_20 = 0;
  }
  else {
    local_20 = SavedStack.cnt;
    if (SavedStack.cnt != 0) {
      __fprintf_chk(stderr,1,
                    "SaveStackAndVisibility()  layerstack was already saved and notyet restored.  cnt = %d\n"
                    ,SavedStack.cnt);
      local_20 = SavedStack.cnt;
    }
  }
  pPVar3 = PCB;
  pDVar5 = PCB->Data;
  uVar2 = pDVar5->LayerN;
  if (uVar2 != 0xfffffffe) {
    uVar4 = 0;
    do {
      if (uVar4 < uVar2) {
        SavedStack.LayerStack[uVar4] = LayerStack[uVar4];
      }
      pBVar1 = (Boolean *)&pDVar5->field_0x90;
      pDVar5 = (DataTypePtr *)&pDVar5->field_0x5c;
      SavedStack.LayerOn[uVar4] = *pBVar1;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar2 + 2);
  }
  SavedStack.ElementOn = pPVar3->ElementOn;
  SavedStack.InvisibleObjectsOn = pPVar3->InvisibleObjectsOn;
  SavedStack.PinOn = pPVar3->PinOn;
  SavedStack.ViaOn = pPVar3->ViaOn;
  SavedStack.RatOn = pPVar3->RatOn;
  SavedStack.cnt = local_20 + 1;
  return;
}



BoxTypePtr GetObjectBoundingBox(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Type != 0x10) {
    if (Type < 0x11) {
      if (Type == 4) {
        return (BoxTypePtr)Ptr2;
      }
      if (Type < 5) {
        if (Type - 1U < 2) {
          return (BoxTypePtr)Ptr1;
        }
      }
      else {
        if (Type == 8) {
          return (BoxTypePtr)Ptr2;
        }
      }
    }
    else {
      if (Type == 0x800) {
        return (BoxTypePtr)Ptr3;
      }
      if (Type < 0x801) {
        if (Type == 0x100) {
          return (BoxTypePtr)Ptr2;
        }
        if (Type == 0x200) {
          return (BoxTypePtr)Ptr2;
        }
      }
      else {
        if (Type == 0x1000) {
          return (BoxTypePtr)Ptr3;
        }
        if (Type == 0x4000) {
          return (BoxTypePtr)Ptr2;
        }
      }
    }
    Message("Request for bounding box of unsupported type %d\n",Type);
  }
  return (BoxTypePtr)Ptr2;
}



void AttachForCopy(LocationType PlaceX,LocationType PlaceY)

{
  double dVar1;
  BoxTypePtr pBVar2;
  int iVar3;
  int iVar4;
  
  iVar4 = 0;
  iVar3 = 0;
  Crosshair.AttachedObject.RubberbandN = 0;
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x10) != 0) goto LAB_080a494d;
  if (Crosshair.AttachedObject.Type == 0x10) {
LAB_080a48a8:
    iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x28);
    iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c);
  }
  else {
    if (Crosshair.AttachedObject.Type < 0x11) {
      if (Crosshair.AttachedObject.Type == 2) {
        iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0xd8);
        iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0xdc);
      }
      else {
        if (Crosshair.AttachedObject.Type < 3) {
          if (Crosshair.AttachedObject.Type != 1) goto LAB_080a48a2;
          iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x34);
          iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
        }
        else {
          if (Crosshair.AttachedObject.Type == 4) {
            iVar3 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x2c);
            iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr2 + 0x30);
          }
          else {
            if (Crosshair.AttachedObject.Type != 8) goto LAB_080a48a2;
            iVar3 = **(int **)((int)Crosshair.AttachedObject.Ptr2 + 0x38);
            iVar4 = (*(int **)((int)Crosshair.AttachedObject.Ptr2 + 0x38))[1];
          }
        }
      }
    }
    else {
      if (Crosshair.AttachedObject.Type == 0x800) {
LAB_080a4b18:
        iVar3 = *(int *)Crosshair.AttachedObject.Ptr3;
        iVar4 = *(int *)((int)Crosshair.AttachedObject.Ptr3 + 4);
      }
      else {
        if (Crosshair.AttachedObject.Type < 0x801) {
          if (Crosshair.AttachedObject.Type == 0x400) goto LAB_080a48a8;
        }
        else {
          if (Crosshair.AttachedObject.Type == 0x1000) goto LAB_080a4b18;
          if (Crosshair.AttachedObject.Type == 0x4000) {
            pBVar2 = GetArcEnds((ArcTypePtr *)Crosshair.AttachedObject.Ptr2);
            iVar3 = pBVar2->X1;
            iVar4 = pBVar2->Y1;
            goto LAB_080a48b0;
          }
        }
LAB_080a48a2:
        iVar4 = 0;
        iVar3 = 0;
      }
    }
  }
LAB_080a48b0:
  dVar1 = PCB->Grid;
  iVar3 = (int)ROUND((double)PCB->GridOffsetX +
                     (double)(int)ROUND(((double)(iVar3 - PCB->GridOffsetX) + dVar1 * 0.50000000) /
                                        dVar1) * dVar1 + 0.50000000) - iVar3;
  iVar4 = (int)ROUND((double)PCB->GridOffsetY +
                     (double)(int)ROUND(((double)(iVar4 - PCB->GridOffsetY) + dVar1 * 0.50000000) /
                                        dVar1) * dVar1 + 0.50000000) - iVar4;
LAB_080a494d:
  Crosshair.AttachedObject.X = PlaceX - iVar3;
  Crosshair.AttachedObject.Y = PlaceY - iVar4;
  if ((Marked.status == '\0') || ((*(byte *)&(PCB->Flags).f & 2) != 0)) {
    SetLocalRef(Crosshair.AttachedObject.X,Crosshair.AttachedObject.Y,'\x01');
  }
  Crosshair.AttachedObject.State = 1;
  pBVar2 = GetObjectBoundingBox
                     (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                      Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3);
  SetCrosshairRange(Crosshair.AttachedObject.X - pBVar2->X1,Crosshair.AttachedObject.Y - pBVar2->Y1,
                    (PCB->MaxWidth + Crosshair.AttachedObject.X) - pBVar2->X2,
                    (PCB->MaxHeight + Crosshair.AttachedObject.Y) - pBVar2->Y2);
  if (((Settings.Mode != 0x69) &&
      (((*(byte *)&(PCB->Flags).f & 0x10) == 0 ||
       (LookupRubberbandLines
                  (Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3),
       Settings.Mode != 0x69)))) &&
     ((Crosshair.AttachedObject.Type - 1U < 2 ||
      ((Crosshair.AttachedObject.Type == 4 || (Crosshair.AttachedObject.Type == 0x1000)))))) {
    LookupRatLines(Crosshair.AttachedObject.Type,Crosshair.AttachedObject.Ptr1,
                   Crosshair.AttachedObject.Ptr2,Crosshair.AttachedObject.Ptr3);
    return;
  }
  return;
}



int ChangeGroupVisibility(int Layer,Boolean On,Boolean ChangeStackOrder)

{
  int iVar1;
  Cardinal CVar2;
  ulong uVar3;
  bool bVar4;
  PCBTypePtr pPVar5;
  ulong uVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int *piVar10;
  uint uVar11;
  Cardinal *pCVar12;
  ulong *puVar13;
  DataTypePtr *pDVar14;
  PCBTypePtr local_28;
  int local_24;
  int local_20;
  
  if (Settings.verbose != 0) {
    __printf_chk(1,"ChangeGroupVisibility(Layer=%d, On=%d, ChangeStackOrder=%d)\n",Layer,(int)On,
                 (int)ChangeStackOrder);
  }
  pPVar5 = PCB;
  pDVar14 = PCB->Data;
  iVar1 = pDVar14->LayerN;
  if (Layer != iVar1) {
    local_20 = 0;
    local_28 = PCB;
    if (0 < iVar1) {
LAB_080a4bc5:
      uVar11 = (PCB->LayerGroups).Number[local_20];
      if (uVar11 == 0) goto LAB_080a4c0c;
      if ((local_28->LayerGroups).Entries[0] != Layer) {
        pCVar12 = (PCB->LayerGroups).Entries + local_20 * 0x12 + 1;
        uVar7 = 0;
        while (uVar7 = uVar7 + 1, uVar7 < uVar11) {
          CVar2 = *pCVar12;
          pCVar12 = pCVar12 + 1;
          if (CVar2 == Layer) goto LAB_080a4cb8;
        }
        goto LAB_080a4c0c;
      }
LAB_080a4cb8:
      if (local_20 < iVar1) {
        local_24 = 1;
        bVar4 = ChangeStackOrder != '\0' && On != '\0';
        puVar13 = &(PCB->Flags).f + uVar11 + 0x743 + local_20 * 0x12;
        do {
          uVar3 = *puVar13;
          uVar11 = uVar11 - 1;
          if ((uVar3 != Layer) && ((int)uVar3 < pDVar14->LayerN)) {
            *(Boolean *)(&pDVar14->field_0x90 + uVar3 * 0x5c) = On;
            uVar6 = LayerStack[0];
            if (ChangeStackOrder != '\0' && On != '\0') {
              pDVar14 = pPVar5->Data;
              iVar1 = pDVar14->LayerN;
              if ((((int)uVar3 < iVar1) && (uVar6 = uVar3, 0 < iVar1)) &&
                 (iVar9 = 0, uVar3 != LayerStack[0])) {
                do {
                  iVar9 = iVar9 + 1;
                  if (iVar1 <= iVar9) break;
                } while (uVar3 != LayerStack[iVar9]);
                piVar10 = LayerStack + iVar9;
                do {
                  *piVar10 = piVar10[-1];
                  piVar10 = piVar10 + -1;
                } while (piVar10 != LayerStack);
              }
            }
            else {
              pDVar14 = pPVar5->Data;
            }
            LayerStack[0] = uVar6;
            local_24 = local_24 + 1;
          }
          puVar13 = puVar13 + -1;
        } while (uVar11 != 0);
        goto LAB_080a4c39;
      }
    }
  }
LAB_080a4c20:
  local_24 = 1;
  bVar4 = ChangeStackOrder != '\0' && On != '\0';
LAB_080a4c39:
  *(Boolean *)(&pDVar14->field_0x90 + Layer * 0x5c) = On;
  iVar1 = LayerStack[0];
  if (((bVar4) && (iVar9 = pPVar5->Data->LayerN, Layer < iVar9)) &&
     ((iVar1 = Layer, 0 < iVar9 && (iVar8 = 0, iVar1 = Layer, Layer != LayerStack[0])))) {
    do {
      iVar8 = iVar8 + 1;
      if (iVar9 <= iVar8) break;
    } while (Layer != LayerStack[iVar8]);
    piVar10 = LayerStack + iVar8;
    do {
      *piVar10 = piVar10[-1];
      piVar10 = piVar10 + -1;
      iVar1 = Layer;
    } while (piVar10 != LayerStack);
  }
  LayerStack[0] = iVar1;
  hid_action("LayersChanged");
  return local_24;
LAB_080a4c0c:
  local_20 = local_20 + 1;
  local_28 = (PCBTypePtr)&local_28->InvisibleObjectsColor;
  if (iVar1 <= local_20) goto LAB_080a4c20;
  goto LAB_080a4bc5;
}



void ResetStackAndVisibility(void)

{
  uint uVar1;
  int iVar2;
  Cardinal CVar3;
  PCBTypePtr pPVar4;
  uint uVar5;
  DataTypePtr *pDVar6;
  Cardinal *pCVar7;
  Cardinal local_28;
  PCBTypePtr local_24;
  int local_20;
  
  pPVar4 = PCB;
  pDVar6 = PCB->Data;
  uVar1 = pDVar6->LayerN;
  if (uVar1 != 0xfffffffe) {
    uVar5 = 0;
    do {
      if (uVar5 < uVar1) {
        LayerStack[uVar5] = uVar5;
      }
      uVar5 = uVar5 + 1;
      *(undefined *)&pDVar6->field_0x90 = 1;
      pDVar6 = (DataTypePtr *)&pDVar6->field_0x5c;
    } while (uVar5 < uVar1 + 2);
    pDVar6 = pPVar4->Data;
  }
  pPVar4->ElementOn = '\x01';
  pPVar4->InvisibleObjectsOn = '\x01';
  pPVar4->PinOn = '\x01';
  pPVar4->ViaOn = '\x01';
  pPVar4->RatOn = '\x01';
  iVar2 = pDVar6->LayerN;
  local_24 = pPVar4;
  local_20 = 0;
  if (iVar2 < 1) {
    local_28 = (pPVar4->LayerGroups).Entries[0];
  }
  else {
    do {
      uVar1 = (pPVar4->LayerGroups).Number[local_20];
      if (uVar1 != 0) {
        local_28 = (local_24->LayerGroups).Entries[0];
        if (iVar2 + 1U == local_28) goto LAB_080a4e98;
        pCVar7 = (pPVar4->LayerGroups).Entries + local_20 * 0x12 + 1;
        uVar5 = 0;
        while (uVar5 = uVar5 + 1, uVar5 < uVar1) {
          CVar3 = *pCVar7;
          pCVar7 = pCVar7 + 1;
          if (iVar2 + 1U == CVar3) goto LAB_080a4e98;
        }
      }
      local_20 = local_20 + 1;
      local_24 = (PCBTypePtr)&local_24->InvisibleObjectsColor;
    } while (local_20 < iVar2);
    local_28 = (pPVar4->LayerGroups).Entries[local_20 * 0x12];
  }
LAB_080a4e98:
  ChangeGroupVisibility(local_28,'\x01','\x01');
  return;
}



void LayerStringToLayerStack(char *s)

{
  bool bVar1;
  PCBTypePtr pPVar2;
  int listed_layers;
  size_t sVar3;
  void *pvVar4;
  undefined *puVar5;
  int Layer;
  ushort **ppuVar6;
  int iVar7;
  DataTypePtr *pDVar8;
  long Layer_00;
  size_t sVar9;
  int iVar10;
  int iVar11;
  char **ppcVar12;
  char *local_30;
  
  sVar3 = strlen(s);
  iVar11 = -1;
  puVar5 = (undefined *)__strdup(s);
  pvVar4 = calloc(1,sVar3 * 4);
  if (0 < (int)sVar3) {
    iVar11 = 0;
    bVar1 = true;
    sVar9 = 0;
    do {
      switch(*puVar5) {
      case 9:
      case 0x20:
      case 0x2c:
      case 0x3a:
      case 0x3b:
        *puVar5 = 0;
        bVar1 = true;
        break;
      default:
        if (bVar1) {
          bVar1 = false;
          *(undefined **)((int)pvVar4 + iVar11 * 4) = puVar5;
          iVar11 = iVar11 + 1;
        }
      }
      sVar9 = sVar9 + 1;
      puVar5 = puVar5 + 1;
    } while (sVar3 != sVar9);
    iVar11 = iVar11 + -1;
  }
  pPVar2 = PCB;
  pDVar8 = PCB->Data;
  iVar10 = pDVar8->LayerN;
  if (-2 < iVar10) {
    Layer = 0;
    do {
      if (Layer < iVar10) {
        LayerStack[Layer] = Layer;
      }
      iVar10 = Layer * 0x5c;
      Layer = Layer + 1;
      *(undefined *)(&pDVar8->field_0x90 + iVar10) = 0;
      pDVar8 = pPVar2->Data;
      iVar10 = pDVar8->LayerN;
    } while (Layer <= iVar10 + 1);
  }
  pPVar2->ElementOn = '\0';
  pPVar2->InvisibleObjectsOn = '\0';
  pPVar2->PinOn = '\0';
  pPVar2->ViaOn = '\0';
  pPVar2->RatOn = '\0';
  if (iVar11 != -1) {
    ppcVar12 = (char **)((int)pvVar4 + iVar11 * 4);
    do {
      while( true ) {
        local_30 = *ppcVar12;
        iVar10 = strcasecmp(local_30,"rats");
        if (iVar10 != 0) break;
        PCB->RatOn = '\x01';
LAB_080a4fc9:
        iVar11 = iVar11 + -1;
        ppcVar12 = ppcVar12 + -1;
        if (iVar11 == -1) {
          return;
        }
      }
      iVar10 = strcasecmp(local_30,"invisible");
      if (iVar10 != 0) {
        iVar10 = strcasecmp(local_30,"pins");
        if (iVar10 == 0) {
          PCB->PinOn = '\x01';
        }
        else {
          iVar10 = strcasecmp(local_30,"vias");
          if (iVar10 == 0) {
            PCB->ViaOn = '\x01';
          }
          else {
            iVar10 = strcasecmp(local_30,"elements");
            if (iVar10 == 0) {
              PCB->ElementOn = '\x01';
            }
            else {
              ppuVar6 = __ctype_b_loc();
              if ((*(byte *)((int)*ppuVar6 + (int)*local_30 * 2 + 1) & 8) == 0) {
                pDVar8 = PCB->Data;
                iVar10 = pDVar8->LayerN;
                if (0 < iVar10) {
                  Layer = 0;
                  do {
                    iVar7 = strcasecmp(local_30,*(char **)&pDVar8->field_0x4c);
                    if (iVar7 == 0) {
                      ChangeGroupVisibility(Layer,'\x01','\x01');
                      goto LAB_080a4fc9;
                    }
                    Layer = Layer + 1;
                    pDVar8 = (DataTypePtr *)&pDVar8->field_0x5c;
                  } while (Layer < iVar10);
                }
                __fprintf_chk(stderr,1,"Warning: layer \"%s\" not known\n",local_30);
                if (listed_layers == 0) {
                  __fprintf_chk(stderr,1,"Named layers in this board are:\n",local_30);
                  listed_layers = 1;
                  pDVar8 = PCB->Data;
                  if (0 < pDVar8->LayerN) {
                    iVar10 = 0;
                    do {
                      Layer = iVar10 * 0x5c;
                      iVar10 = iVar10 + 1;
                      __fprintf_chk(stderr,1,&DAT_08148576,
                                    *(undefined4 *)(&pDVar8->field_0x4c + Layer));
                      pDVar8 = PCB->Data;
                    } while (pDVar8->LayerN != iVar10 && iVar10 <= pDVar8->LayerN);
                  }
                }
              }
              else {
                Layer_00 = strtol(local_30,(char **)0x0,10);
                ChangeGroupVisibility(Layer_00,'\x01','\x01');
              }
            }
          }
        }
        goto LAB_080a4fc9;
      }
      iVar11 = iVar11 + -1;
      ppcVar12 = ppcVar12 + -1;
      PCB->InvisibleObjectsOn = '\x01';
    } while (iVar11 != -1);
  }
  return;
}



char * ExpandFilename(char *Dirname,char *Filename)

{
  DynamicStringType answer;
  size_t sVar1;
  size_t sVar2;
  FILE *__stream;
  int iVar3;
  char *__command;
  
  DSClearString((DynamicStringTypePtr_conflict *)0x816ca78);
  if (Dirname == (char *)0x0) {
    sVar1 = strlen(Filename);
    __command = (char *)MyCalloc(sVar1 + 6,1,"Expand()");
    __sprintf_chk(__command,1,0xffffffff,"echo %s",Filename);
  }
  else {
    sVar1 = strlen(Filename);
    sVar2 = strlen(Dirname);
    __command = (char *)MyCalloc(sVar1 + 7 + sVar2,1,"ExpandFilename()");
    __sprintf_chk(__command,1,0xffffffff,"echo %s/%s",Dirname,Filename);
  }
  __stream = popen(__command,"r");
  if (__stream == (FILE *)0x0) {
    PopenErrorMessage(__command);
    SaveFree(__command);
    __command = (char *)0x0;
  }
  else {
    while( true ) {
      iVar3 = fgetc(__stream);
      if (((iVar3 == -1) || (iVar3 == 0xd)) || (iVar3 == 10)) break;
      DSAddCharacter((DynamicStringTypePtr_conflict *)0x816ca78,(char)iVar3);
    }
    SaveFree(__command);
    iVar3 = pclose(__stream);
    __command = (char *)0x0;
    if (iVar3 == 0) {
      __command = answer.Data;
    }
  }
  return __command;
}



char * EvaluateFilename(char *Template,char *Path,char *Filename,char *Parameter)

{
  char Char;
  char cVar1;
  DynamicStringType command;
  char *pcVar2;
  
  if (Settings.verbose != 0) {
    __printf_chk(1,"EvaluateFilename:\n");
    __printf_chk(1,&DAT_08149e51,Template);
    __printf_chk(1,&DAT_08149e69,Path);
    __printf_chk(1,&DAT_08149e7d,Filename);
    __printf_chk(1,&DAT_08149e95,Parameter);
  }
  DSClearString((DynamicStringTypePtr_conflict *)0x816ca80);
  while (Template != (char *)0x0) {
    while( true ) {
      Char = *Template;
      if (Char == '\0') goto LAB_080a5408;
      if (Char != '%') goto LAB_080a5463;
      cVar1 = Template[1];
      if (cVar1 != 'p') break;
      Template = Template + 2;
      DSAddString((DynamicStringTypePtr_conflict *)0x816ca80,Path);
      if (Template == (char *)0x0) goto LAB_080a5408;
    }
    if (cVar1 == 'f') {
      Template = Template + 2;
      DSAddString((DynamicStringTypePtr_conflict *)0x816ca80,Filename);
    }
    else {
      if (cVar1 == 'a') {
        Template = Template + 2;
        DSAddString((DynamicStringTypePtr_conflict *)0x816ca80,Parameter);
      }
      else {
LAB_080a5463:
        Template = Template + 1;
        DSAddCharacter((DynamicStringTypePtr_conflict *)0x816ca80,Char);
      }
    }
  }
LAB_080a5408:
  DSAddCharacter((DynamicStringTypePtr_conflict *)0x816ca80,'\0');
  if (Settings.verbose != 0) {
    __printf_chk(1,&DAT_0814a2b8,command.Data);
  }
  pcVar2 = MyStrdup(command.Data,"EvaluateFilename()");
  return pcVar2;
}



int ParseRouteString(char *s,RouteStyleTypePtr routeStyle,int scale)

{
  ushort *puVar1;
  char *pcVar2;
  ushort **ppuVar3;
  char *pcVar4;
  int iVar5;
  char cVar6;
  byte bVar7;
  RouteStyleTypePtr pRVar8;
  int in_GS_OFFSET;
  byte bVar9;
  int local_138;
  char *local_130 [4];
  char Name [256];
  int local_20;
  
  bVar9 = 0;
  iVar5 = 0x18;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_130[0] = s;
  pRVar8 = routeStyle;
  while (iVar5 != 0) {
    iVar5 = iVar5 + -1;
    pRVar8->Thick = 0;
    pRVar8 = (RouteStyleTypePtr)&pRVar8->Diameter;
  }
  ppuVar3 = __ctype_b_loc();
  local_138 = 0;
  cVar6 = *s;
  if (cVar6 == '\0') goto LAB_080a582e;
LAB_080a5594:
  while ((*(byte *)((int)*ppuVar3 + (int)cVar6 * 2 + 1) & 0x20) != 0) {
    s = s + 1;
    cVar6 = *s;
    local_130[0] = s;
    if (cVar6 == '\0') goto LAB_080a582e;
  }
  cVar6 = *local_130[0];
  if (cVar6 == ',') goto LAB_080a582e;
  if (cVar6 == '\0') goto LAB_080a582e;
  iVar5 = 0;
  do {
    local_130[0] = local_130[0] + 1;
    Name[iVar5] = cVar6;
    iVar5 = iVar5 + 1;
    cVar6 = *local_130[0];
    if (cVar6 == ',') break;
  } while (cVar6 != '\0');
  do {
    Name[iVar5] = '\0';
    pcVar4 = MyStrdup(Name,"ParseRouteString()");
    puVar1 = *ppuVar3;
    routeStyle->Name = pcVar4;
    pcVar4 = local_130[0] + 1;
    if ((*(byte *)((int)puVar1 + (int)local_130[0][1] * 2 + 1) & 8) == 0) {
LAB_080a5861:
      local_130[0] = pcVar4;
      iVar5 = 0x18;
      while (iVar5 != 0) {
        iVar5 = iVar5 + -1;
        routeStyle->Thick = 0;
        routeStyle = (RouteStyleTypePtr)((int)routeStyle + (uint)bVar9 * -8 + 4);
      }
      iVar5 = 1;
LAB_080a583a:
      if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return iVar5;
    }
    local_130[0] = local_130[0] + 1;
    GetNum(local_130,(BDimension *)routeStyle);
    routeStyle->Thick = scale * routeStyle->Thick;
    cVar6 = *local_130[0];
    if (cVar6 == '\0') {
LAB_080a5858:
      pcVar4 = local_130[0] + 1;
      goto LAB_080a5861;
    }
    puVar1 = *ppuVar3;
    while ((*(byte *)((int)puVar1 + (int)cVar6 * 2 + 1) & 0x20) != 0) {
      local_130[0] = local_130[0] + 1;
      cVar6 = *local_130[0];
      if (cVar6 == '\0') goto LAB_080a5858;
    }
    pcVar4 = local_130[0] + 1;
    if (cVar6 != ',') goto LAB_080a5861;
    if (local_130[0][1] == '\0') {
LAB_080a56dc:
      local_130[0] = pcVar4;
      bVar7 = (byte)((uint)*puVar1 >> 8);
      pcVar4 = local_130[0];
    }
    else {
      bVar7 = (byte)((uint)puVar1[local_130[0][1]] >> 8);
      if ((puVar1[local_130[0][1]] & 0x2000) != 0) {
        pcVar2 = local_130[0] + 2;
        do {
          pcVar4 = pcVar2;
          if (*pcVar4 == '\0') goto LAB_080a56dc;
          bVar7 = (byte)((uint)puVar1[*pcVar4] >> 8);
          pcVar2 = pcVar4 + 1;
        } while ((puVar1[*pcVar4] & 0x2000) != 0);
      }
    }
    local_130[0] = pcVar4;
    pcVar4 = local_130[0];
    if ((bVar7 & 8) == 0) goto LAB_080a5861;
    GetNum(local_130,&routeStyle->Diameter);
    routeStyle->Diameter = scale * routeStyle->Diameter;
    cVar6 = *local_130[0];
    if (cVar6 == '\0') goto LAB_080a5858;
    puVar1 = *ppuVar3;
    while ((*(byte *)((int)puVar1 + (int)cVar6 * 2 + 1) & 0x20) != 0) {
      local_130[0] = local_130[0] + 1;
      cVar6 = *local_130[0];
      if (cVar6 == '\0') goto LAB_080a5858;
    }
    pcVar4 = local_130[0] + 1;
    if (cVar6 != ',') goto LAB_080a5861;
    if (local_130[0][1] == '\0') {
LAB_080a578c:
      local_130[0] = pcVar4;
      bVar7 = (byte)((uint)*puVar1 >> 8);
      pcVar4 = local_130[0];
    }
    else {
      bVar7 = (byte)((uint)puVar1[local_130[0][1]] >> 8);
      if ((puVar1[local_130[0][1]] & 0x2000) != 0) {
        pcVar2 = local_130[0] + 2;
        do {
          pcVar4 = pcVar2;
          if (*pcVar4 == '\0') goto LAB_080a578c;
          bVar7 = (byte)((uint)puVar1[*pcVar4] >> 8);
          pcVar2 = pcVar4 + 1;
        } while ((puVar1[*pcVar4] & 0x2000) != 0);
      }
    }
    local_130[0] = pcVar4;
    pcVar4 = local_130[0];
    if ((bVar7 & 8) == 0) goto LAB_080a5861;
    GetNum(local_130,&routeStyle->Hole);
    routeStyle->Hole = scale * routeStyle->Hole;
    if (*local_130[0] == ',') {
      pcVar4 = local_130[0] + 1;
      if (local_130[0][1] == '\0') {
        bVar7 = (byte)((uint)**ppuVar3 >> 8);
      }
      else {
        puVar1 = *ppuVar3;
        bVar7 = (byte)((uint)puVar1[local_130[0][1]] >> 8);
        if ((puVar1[local_130[0][1]] & 0x2000) != 0) {
          pcVar2 = local_130[0] + 2;
          do {
            pcVar4 = pcVar2;
            if (*pcVar4 == '\0') {
              bVar7 = (byte)((uint)*puVar1 >> 8);
              break;
            }
            bVar7 = (byte)((uint)puVar1[*pcVar4] >> 8);
            pcVar2 = pcVar4 + 1;
          } while ((puVar1[*pcVar4] & 0x2000) != 0);
        }
      }
      local_130[0] = pcVar4;
      pcVar4 = local_130[0];
      if ((bVar7 & 8) == 0) goto LAB_080a5861;
      GetNum(local_130,&routeStyle->Keepaway);
      routeStyle->Keepaway = scale * routeStyle->Keepaway;
      cVar6 = *local_130[0];
      if (cVar6 != '\0') {
        do {
          if ((*(byte *)((int)*ppuVar3 + (int)cVar6 * 2 + 1) & 0x20) == 0) break;
          local_130[0] = local_130[0] + 1;
          cVar6 = *local_130[0];
        } while (cVar6 != '\0');
      }
    }
    else {
      routeStyle->Keepaway = 1000;
    }
    if (local_138 == 3) {
LAB_080a5838:
      iVar5 = 0;
      goto LAB_080a583a;
    }
    cVar6 = *local_130[0];
    if (cVar6 == '\0') goto LAB_080a5858;
    while ((*(byte *)((int)*ppuVar3 + (int)cVar6 * 2 + 1) & 0x20) != 0) {
      local_130[0] = local_130[0] + 1;
      cVar6 = *local_130[0];
      if (cVar6 == '\0') goto LAB_080a5858;
    }
    s = local_130[0] + 1;
    pcVar4 = s;
    if (cVar6 != ':') goto LAB_080a5861;
    local_138 = local_138 + 1;
    local_130[0] = s;
    if (local_138 == 4) goto LAB_080a5838;
    cVar6 = *s;
    routeStyle = routeStyle + 1;
    if (cVar6 != '\0') goto LAB_080a5594;
LAB_080a582e:
    iVar5 = 0;
  } while( true );
}



void QuitApplication(void)

{
  if ((PCB->Changed == '\0') || (Settings.SaveInTMP == '\0')) {
    DisableEmergencySave();
  }
  else {
    EmergencySave();
  }
  if (Settings.init_done < 1) {
    Settings.init_done = -1;
    return;
  }
                    // WARNING: Subroutine does not return
  exit(0);
}



void CenterDisplay(LocationType X,LocationType Y,Boolean Delta)

{
  double dVar1;
  Boolean BVar2;
  
  dVar1 = PCB->Grid;
  PCB->Grid = 1.00000000;
  if (Delta == '\0') {
    BVar2 = MoveCrosshairAbsolute(X,Y);
    if (BVar2 != '\0') {
      RestoreCrosshair('\0');
    }
  }
  else {
    MoveCrosshairRelative(X,Y);
  }
  (*gui->set_crosshair)(Crosshair.X,Crosshair.Y,1);
  PCB->Grid = dVar1;
  return;
}



void SetTextBoundingBox(FontTypePtr FontPtr,TextTypePtr Text)

{
  int *piVar1;
  char cVar2;
  BYTE Number;
  int X;
  float fVar3;
  PCBTypePtr pPVar4;
  byte bVar5;
  int iVar6;
  int iVar7;
  LocationType *pLVar8;
  int Y;
  int iVar9;
  int local_2c;
  byte *local_28;
  
  local_28 = (byte *)Text->TextString;
  if ((local_28 == (byte *)0x0) || (bVar5 = *local_28, bVar5 == 0)) {
    iVar7 = 0;
    iVar9 = 0;
    local_2c = 0;
  }
  else {
    iVar7 = 0;
    iVar9 = 0;
    local_2c = 0;
    do {
      pLVar8 = &FontPtr->MaxHeight + (uint)bVar5 * 7;
      if (*(char *)(pLVar8 + 7) == '\0') {
        local_2c = local_2c + (((FontPtr->DefaultSymbol).X2 - (FontPtr->DefaultSymbol).X1) * 6) / 5;
        iVar9 = (FontPtr->DefaultSymbol).Y2 - (FontPtr->DefaultSymbol).Y1;
      }
      else {
        iVar6 = pLVar8[6];
        if (pLVar8[8] != 0) {
          Y = 0;
          do {
            if (iVar7 < *(int *)(iVar6 + 0x24)) {
              iVar7 = *(int *)(iVar6 + 0x24);
            }
            Y = Y + 1;
            iVar6 = iVar6 + 0x58;
          } while (Y != pLVar8[8]);
        }
        pLVar8 = &FontPtr->MaxHeight + (uint)bVar5 * 7;
        local_2c = local_2c + pLVar8[0xc] + pLVar8[10];
        if (iVar9 < pLVar8[0xb]) {
          iVar9 = pLVar8[0xb];
        }
      }
      local_28 = local_28 + 1;
    } while ((local_28 != (byte *)0x0) && (bVar5 = *local_28, bVar5 != 0));
  }
  fVar3 = (float)Text->Scale / 100.00000000;
  iVar6 = (int)ROUND((float)local_2c * fVar3);
  iVar9 = (int)ROUND((float)iVar9 * fVar3);
  iVar7 = (int)ROUND(((float)Text->Scale / 200.00000000) * (float)iVar7);
  Y = Text->Y;
  if (iVar7 < 400) {
    iVar7 = 400;
  }
  X = Text->X;
  cVar2 = *(char *)&(Text->Flags).f;
  (Text->BoundingBox).Y1 = Y;
  (Text->BoundingBox).X1 = X;
  if (cVar2 < '\0') {
    (Text->BoundingBox).X1 = X - iVar7;
    (Text->BoundingBox).Y1 = iVar7 + Y;
    (Text->BoundingBox).X2 = (X - iVar7) + iVar6 + iVar7;
    (Text->BoundingBox).Y2 = (iVar7 + Y + iVar7 * -2) - iVar9;
    RotateBoxLowLevel((BoxTypePtr)Text,X,Y,4 - Text->Direction & 3);
  }
  else {
    (Text->BoundingBox).X1 = X - iVar7;
    (Text->BoundingBox).Y1 = Y - iVar7;
    (Text->BoundingBox).X2 = (X - iVar7) + iVar6 + iVar7;
    Number = Text->Direction;
    (Text->BoundingBox).Y2 = (Y - iVar7) + iVar7 * 2 + iVar9;
    RotateBoxLowLevel((BoxTypePtr)Text,X,Y,Number);
  }
  pPVar4 = PCB;
  (Text->BoundingBox).X1 = (Text->BoundingBox).X1 - PCB->Bloat;
  piVar1 = &(Text->BoundingBox).Y1;
  *piVar1 = *piVar1 - pPVar4->Bloat;
  iVar9 = pPVar4->Bloat + (Text->BoundingBox).X2;
  (Text->BoundingBox).X2 = iVar9;
  iVar7 = pPVar4->Bloat;
  (Text->BoundingBox).X2 = iVar9 + 1;
  (Text->BoundingBox).Y2 = iVar7 + (Text->BoundingBox).Y2 + 1;
  return;
}



void SetPadBoundingBox(PadTypePtr_conflict Pad)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  double dVar9;
  double local_2c;
  double local_24 [2];
  
  iVar8 = (Pad->Point1).X;
  iVar5 = (Pad->Thickness + Pad->Clearance + 1) / 2;
  iVar4 = (Pad->Point2).Y;
  iVar2 = (Pad->Mask + 1) / 2;
  if (iVar5 < iVar2) {
    iVar5 = iVar2;
  }
  iVar2 = (Pad->Point2).X;
  if (((iVar2 - iVar8 == 0) || ((*(byte *)((int)&(Pad->Flags).f + 1) & 1) == 0)) ||
     (iVar7 = iVar4 - (Pad->Point1).Y, iVar7 == 0)) {
    if (iVar2 < iVar8) {
      iVar8 = iVar2;
    }
    (Pad->BoundingBox).X1 = iVar8 - iVar5;
    if (iVar2 <= (Pad->Point1).X) {
      iVar2 = (Pad->Point1).X;
    }
    piVar1 = &(Pad->Point1).Y;
    iVar8 = iVar4;
    if (*piVar1 == iVar4 || *piVar1 < iVar4) {
      iVar8 = (Pad->Point1).Y;
    }
    iVar2 = iVar5 + iVar2;
    (Pad->BoundingBox).X2 = iVar2;
    if (iVar4 <= (Pad->Point1).Y) {
      iVar4 = (Pad->Point1).Y;
    }
    (Pad->BoundingBox).Y1 = iVar8 - iVar5;
    (Pad->BoundingBox).Y2 = iVar5 + iVar4;
  }
  else {
    dVar9 = atan2((double)iVar7,(double)(iVar2 - iVar8));
    sincos((double)((float)dVar9 + 0.78539813),local_24,&local_2c);
    iVar8 = (int)ROUND((float)local_2c * (float)iVar5 * 1.41421354);
    iVar2 = (Pad->Point2).X;
    iVar4 = (int)ROUND((float)local_24[0] * (float)iVar5 * 1.41421354);
    iVar5 = (Pad->Point1).X;
    iVar6 = iVar8 + iVar2;
    iVar2 = iVar2 + iVar4;
    iVar7 = iVar2;
    if (iVar6 <= iVar2) {
      iVar7 = iVar6;
    }
    iVar3 = iVar5 - iVar4;
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar5 = iVar5 - iVar8;
    if (iVar5 < iVar7) {
      iVar7 = iVar5;
    }
    if (iVar2 <= iVar6) {
      iVar2 = iVar6;
    }
    if (iVar2 < iVar3) {
      iVar2 = iVar3;
    }
    iVar6 = (Pad->Point2).Y;
    if (iVar2 < iVar5) {
      iVar2 = iVar5;
    }
    iVar5 = (Pad->Point1).Y;
    (Pad->BoundingBox).X1 = iVar7;
    iVar7 = iVar6 + iVar4;
    iVar6 = iVar6 - iVar8;
    (Pad->BoundingBox).X2 = iVar2;
    iVar3 = iVar7;
    if (iVar6 <= iVar7) {
      iVar3 = iVar6;
    }
    iVar5 = iVar5 - iVar4;
    if (iVar5 < iVar3) {
      iVar3 = iVar5;
    }
    iVar8 = iVar8 + (Pad->Point1).Y;
    iVar4 = iVar8;
    if (iVar3 <= iVar8) {
      iVar4 = iVar3;
    }
    if (iVar7 <= iVar6) {
      iVar7 = iVar6;
    }
    if (iVar5 <= iVar7) {
      iVar5 = iVar7;
    }
    if (iVar5 < iVar8) {
      iVar5 = iVar8;
    }
    (Pad->BoundingBox).Y1 = iVar4;
    (Pad->BoundingBox).Y2 = iVar5;
  }
  piVar1 = &(Pad->BoundingBox).Y2;
  *piVar1 = *piVar1 + 1;
  (Pad->BoundingBox).X2 = iVar2 + 1;
  return;
}



void SetElementBoundingBox(DataTypePtr *Data,ElementTypePtr_conflict Element,FontTypePtr Font)

{
  FlagType *pFVar1;
  int *piVar2;
  TextTypePtr Text;
  Cardinal CVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  rtree_t *rtree;
  PinTypePtr_conflict Pin;
  PadTypePtr_conflict Pad;
  int iVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  LineTypePtr Line;
  ArcTypePtr *Arc;
  uint uVar12;
  uint local_40;
  LocationType local_30;
  uint local_2c;
  uint local_24;
  int local_20;
  
  if ((Data != (DataTypePtr *)0x0) && (Data->element_tree != (rtree_t *)0x0)) {
    r_delete_entry(Data->element_tree,(BoxType *)Element);
  }
  iVar11 = 2;
  do {
    Text = (TextTypePtr)(Element->Name + iVar11);
    if (Data == (DataTypePtr *)0x0) {
      SetTextBoundingBox(Font,Text);
    }
    else {
      if (Data->name_tree[iVar11] != (rtree_t *)0x0) {
        r_delete_entry(Data->name_tree[iVar11],(BoxType *)Text);
      }
      SetTextBoundingBox(Font,Text);
      rtree = Data->name_tree[iVar11];
      if (rtree == (rtree_t *)0x0) {
        rtree = r_create_tree((BoxType **)0x0,0,0);
        Data->name_tree[iVar11] = rtree;
      }
      r_insert_entry(rtree,(BoxType *)Text,0);
    }
    iVar11 = iVar11 + -1;
  } while (iVar11 != -1);
  CVar3 = Element->LineN;
  (Element->BoundingBox).Y1 = 10000000;
  (Element->BoundingBox).X1 = 10000000;
  (Element->BoundingBox).Y2 = 0;
  local_20 = CVar3 - 1;
  (Element->BoundingBox).X2 = 0;
  if (local_20 != -1) {
    iVar11 = CVar3 * 0x58;
    do {
      local_24 = iVar11 + -0x58;
      Line = (LineTypePtr)((int)&Element->Line[-1].BoundingBox.X1 + iVar11);
      SetLineBoundingBox(Line);
      iVar8 = (Line->Point1).X;
      iVar7 = Line->Thickness + 1;
      iVar5 = -(iVar7 / 2);
      iVar11 = iVar5 + iVar8;
      if (iVar11 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar11;
      }
      iVar6 = (Line->Point1).Y;
      iVar11 = iVar5 + iVar6;
      if (iVar11 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar11;
      }
      iVar9 = (Line->Point2).X;
      iVar11 = iVar5 + iVar9;
      if (iVar11 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar11;
      }
      iVar11 = (Line->Point2).Y;
      iVar5 = iVar5 + iVar11;
      if (iVar5 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar5;
      }
      iVar7 = iVar7 / 2;
      iVar8 = iVar7 + iVar8;
      if ((Element->BoundingBox).X2 < iVar8) {
        (Element->BoundingBox).X2 = iVar8;
      }
      iVar6 = iVar7 + iVar6;
      if ((Element->BoundingBox).Y2 < iVar6) {
        (Element->BoundingBox).Y2 = iVar6;
      }
      iVar9 = iVar7 + iVar9;
      if ((Element->BoundingBox).X2 < iVar9) {
        (Element->BoundingBox).X2 = iVar9;
      }
      iVar7 = iVar7 + iVar11;
      if ((Element->BoundingBox).Y2 < iVar7) {
        (Element->BoundingBox).Y2 = iVar7;
      }
      local_20 = local_20 + -1;
      iVar11 = local_24;
    } while (local_20 != -1);
  }
  iVar11 = Element->ArcN - 1;
  if (iVar11 != -1) {
    iVar8 = Element->ArcN * 0x44;
    do {
      Arc = (ArcTypePtr *)((int)&Element->Arc[-1].BoundingBox.X1 + iVar8);
      SetArcBoundingBox(Arc);
      iVar5 = (Arc->BoundingBox).X1;
      if (iVar5 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar5;
      }
      iVar5 = (Arc->BoundingBox).Y1;
      if (iVar5 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar5;
      }
      iVar5 = (Arc->BoundingBox).X2;
      if ((Element->BoundingBox).X2 < iVar5) {
        (Element->BoundingBox).X2 = iVar5;
      }
      iVar5 = (Arc->BoundingBox).Y2;
      if ((Element->BoundingBox).Y2 < iVar5) {
        (Element->BoundingBox).Y2 = iVar5;
      }
      iVar11 = iVar11 + -1;
      iVar8 = iVar8 + -0x44;
    } while (iVar11 != -1);
  }
  (Element->VBox).X1 = (Element->BoundingBox).X1;
  (Element->VBox).Y1 = (Element->BoundingBox).Y1;
  (Element->VBox).X2 = (Element->BoundingBox).X2;
  (Element->VBox).Y2 = (Element->BoundingBox).Y2;
  if (Element->PinN != 0) {
    uVar12 = 0;
    local_24 = Element->PinN;
    do {
      Pin = Element->Pin + uVar12;
      if (Data == (DataTypePtr *)0x0) {
        SetPinBoundingBox(Pin);
      }
      else {
        if (Data->pin_tree != (rtree_t *)0x0) {
          r_delete_entry(Data->pin_tree,(BoxType *)Pin);
        }
        SetPinBoundingBox(Pin);
        rtree = Data->pin_tree;
        if (rtree == (rtree_t *)0x0) {
          rtree = r_create_tree((BoxType **)0x0,0,0);
          Data->pin_tree = rtree;
        }
        r_insert_entry(rtree,(BoxType *)Pin,0);
      }
      iVar11 = (Pin->BoundingBox).X1;
      if (iVar11 < (Element->BoundingBox).X1) {
        (Element->BoundingBox).X1 = iVar11;
      }
      iVar11 = (Pin->BoundingBox).Y1;
      if (iVar11 < (Element->BoundingBox).Y1) {
        (Element->BoundingBox).Y1 = iVar11;
      }
      iVar11 = (Pin->BoundingBox).X2;
      if ((Element->BoundingBox).X2 < iVar11) {
        (Element->BoundingBox).X2 = iVar11;
      }
      iVar11 = (Pin->BoundingBox).Y2;
      if ((Element->BoundingBox).Y2 < iVar11) {
        (Element->BoundingBox).Y2 = iVar11;
      }
      iVar11 = Pin->X;
      iVar8 = Pin->Thickness;
      iVar5 = -(iVar8 / 2);
      iVar7 = iVar11 + iVar5;
      if (iVar7 < (Element->VBox).X1) {
        (Element->VBox).X1 = iVar7;
      }
      iVar7 = Pin->Y;
      iVar5 = iVar5 + iVar7;
      if (iVar5 < (Element->VBox).Y1) {
        (Element->VBox).Y1 = iVar5;
      }
      iVar8 = iVar8 / 2;
      iVar11 = iVar8 + iVar11;
      if ((Element->VBox).X2 < iVar11) {
        (Element->VBox).X2 = iVar11;
      }
      iVar8 = iVar8 + iVar7;
      if ((Element->VBox).Y2 < iVar8) {
        (Element->VBox).Y2 = iVar8;
      }
      uVar10 = Element->PinN;
    } while ((uVar10 != 0) &&
            (uVar12 = (uVar10 + 1 + uVar12) - local_24, local_24 = uVar10, uVar12 < uVar10));
  }
  uVar12 = Element->PadN;
  local_30 = 0;
  local_2c = 0;
  uVar10 = uVar12;
  while (uVar10 != 0) {
    if (uVar10 <= local_2c) {
      local_30 = (Element->BoundingBox).Y1;
      local_20 = (Element->BoundingBox).X2;
      local_24 = (Element->BoundingBox).X1;
      iVar11 = (Element->BoundingBox).Y2;
      Pad = Element->Pad;
      local_40 = 0;
      goto LAB_080a63e0;
    }
    Pad = (PadTypePtr_conflict)((int)&(Element->Pad->BoundingBox).X1 + local_30);
    if (Data == (DataTypePtr *)0x0) {
      SetPadBoundingBox(Pad);
    }
    else {
      if (Data->pad_tree != (rtree_t *)0x0) {
        r_delete_entry(Data->pad_tree,(BoxType *)Pad);
      }
      SetPadBoundingBox(Pad);
      rtree = Data->pad_tree;
      if (rtree == (rtree_t *)0x0) {
        rtree = r_create_tree((BoxType **)0x0,0,0);
        Data->pad_tree = rtree;
      }
      r_insert_entry(rtree,(BoxType *)Pad,0);
    }
    iVar11 = (Pad->BoundingBox).X1;
    if (iVar11 < (Element->BoundingBox).X1) {
      (Element->BoundingBox).X1 = iVar11;
    }
    iVar11 = (Pad->BoundingBox).Y1;
    if (iVar11 < (Element->BoundingBox).Y1) {
      (Element->BoundingBox).Y1 = iVar11;
    }
    iVar11 = (Pad->BoundingBox).X2;
    if ((Element->BoundingBox).X2 < iVar11) {
      (Element->BoundingBox).X2 = iVar11;
    }
    iVar11 = (Pad->BoundingBox).Y2;
    if ((Element->BoundingBox).Y2 < iVar11) {
      (Element->BoundingBox).Y2 = iVar11;
    }
    iVar5 = Pad->Thickness;
    iVar7 = (Pad->Point2).X;
    iVar8 = (Pad->Point1).X;
    iVar6 = -(iVar5 / 2);
    iVar11 = iVar7;
    if (iVar8 <= iVar7) {
      iVar11 = iVar8;
    }
    iVar11 = iVar6 + iVar11;
    if (iVar11 < (Element->VBox).X1) {
      (Element->VBox).X1 = iVar11;
    }
    iVar4 = (Pad->Point2).Y;
    iVar9 = (Pad->Point1).Y;
    iVar11 = iVar4;
    if (iVar9 <= iVar4) {
      iVar11 = iVar9;
    }
    iVar11 = iVar11 + iVar6;
    if (iVar11 < (Element->VBox).Y1) {
      (Element->VBox).Y1 = iVar11;
    }
    iVar5 = iVar5 / 2;
    if (iVar8 < iVar7) {
      iVar8 = iVar7;
    }
    iVar8 = iVar5 + iVar8;
    if ((Element->VBox).X2 < iVar8) {
      (Element->VBox).X2 = iVar8;
    }
    if (iVar9 < iVar4) {
      iVar9 = iVar4;
    }
    iVar9 = iVar9 + iVar5;
    if ((Element->VBox).Y2 < iVar9) {
      (Element->VBox).Y2 = iVar9;
    }
    uVar10 = Element->PadN;
    if (Element->PadN == uVar12) {
      local_2c = local_2c + 1;
      local_30 = local_30 + 0x68;
      uVar10 = uVar12;
    }
  }
  local_24 = (Element->BoundingBox).X1;
  local_30 = (Element->BoundingBox).Y1;
  local_20 = (Element->BoundingBox).X2;
  iVar11 = (Element->BoundingBox).Y2;
  goto LAB_080a62f4;
LAB_080a63e0:
  do {
    iVar8 = (Pad->Point1).Y;
    iVar5 = (Pad->Point2).Y;
    if (iVar8 == iVar5) {
      if (local_20 - (Pad->Point2).X < (int)((Pad->Point1).X - local_24)) goto LAB_080a63f4;
LAB_080a6428:
      (Pad->Flags).f = (Pad->Flags).f & 0xffffbfff;
    }
    else {
      if (iVar8 - local_30 <= iVar11 - iVar5) goto LAB_080a6428;
LAB_080a63f4:
      (Pad->Flags).f = (Pad->Flags).f | 0x4000;
    }
    local_40 = local_40 + 1;
    Pad = Pad + 1;
  } while (local_40 < uVar10);
LAB_080a62f4:
  if (iVar11 - local_30 < (int)(local_20 - local_24)) {
    uVar12 = Element->PinN;
    if (uVar12 != 0) {
      Pin = Element->Pin;
      uVar10 = 1;
      pFVar1 = &Pin->Flags;
      pFVar1->f = pFVar1->f | 0x4000;
      while (uVar10 < uVar12) {
        Pin[1].Flags.f = Pin[1].Flags.f | 0x4000;
        uVar10 = uVar10 + 1;
        Pin = Pin + 1;
      }
    }
  }
  else {
    uVar12 = Element->PinN;
    if (uVar12 != 0) {
      Pin = Element->Pin;
      uVar10 = 1;
      pFVar1 = &Pin->Flags;
      pFVar1->f = pFVar1->f & 0xffffbfff;
      while (uVar10 < uVar12) {
        Pin[1].Flags.f = Pin[1].Flags.f & 0xffffbfff;
        uVar10 = uVar10 + 1;
        Pin = Pin + 1;
      }
    }
  }
  piVar2 = &(Element->BoundingBox).Y2;
  *piVar2 = *piVar2 + 1;
  piVar2 = &(Element->VBox).X2;
  *piVar2 = *piVar2 + 1;
  piVar2 = &(Element->VBox).Y2;
  *piVar2 = *piVar2 + 1;
  (Element->BoundingBox).X2 = local_20 + 1;
  if (Data == (DataTypePtr *)0x0) {
    return;
  }
  rtree = Data->element_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Data->element_tree = rtree;
  }
  r_insert_entry(rtree,(BoxType *)Element,0);
  return;
}



float GetValue(char *val,char *units,Boolean *absolute)

{
  float fVar1;
  char cVar2;
  ushort **ppuVar3;
  int iVar4;
  double dVar5;
  
  cVar2 = *val;
  if (cVar2 == '=') {
    *absolute = '\x01';
    dVar5 = strtod(val + 1,(char **)0x0);
  }
  else {
    ppuVar3 = __ctype_b_loc();
    *(bool *)absolute = (*(byte *)((int)*ppuVar3 + (int)cVar2 * 2 + 1) & 8) != 0;
    dVar5 = strtod(val,(char **)0x0);
  }
  fVar1 = (float)dVar5;
  if ((units != (char *)0x0) && (*units != '\0')) {
    iVar4 = strncasecmp(units,"mm",2);
    if (iVar4 == 0) {
      fVar1 = fVar1 * 3937.00781250;
    }
    else {
      iVar4 = strncasecmp(units,"mil",3);
      if (iVar4 == 0) {
        fVar1 = fVar1 * 100.00000000;
      }
    }
  }
  return fVar1;
}



// WARNING: Could not reconcile some variable overlaps

FlagType * OldFlags(FlagType *__return_storage_ptr__,uint flags)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int in_GS_OFFSET;
  FlagType rv;
  
  uVar4 = 0x10000;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  rv.t._0_4_ = 0;
  rv.f = flags & 0xffff;
  uVar3 = 0;
  rv.t._4_4_ = 0;
  while( true ) {
    if ((uVar4 & flags) != 0) {
      rv.t[(int)uVar3 >> 1] = rv.t[(int)uVar3 >> 1] | (byte)(1 << (sbyte)((uVar3 & 1) << 2));
    }
    uVar3 = uVar3 + 1;
    if (uVar3 == 8) break;
    uVar4 = uVar4 * 2;
  }
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  __return_storage_ptr__->f = rv.f;
  *(undefined4 *)__return_storage_ptr__->t = rv.t._0_4_;
  *(undefined4 *)(__return_storage_ptr__->t + 4) = 0;
  if (iVar1 == iVar2) {
    return __return_storage_ptr__;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Variable defined which should be unmapped: rv

FlagType * MakeFlags(FlagType *__return_storage_ptr__,uint flags)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  FlagType rv;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __return_storage_ptr__->f = flags;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  *(undefined4 *)__return_storage_ptr__->t = 0;
  *(undefined4 *)(__return_storage_ptr__->t + 4) = 0;
  if (iVar1 == iVar2) {
    return __return_storage_ptr__;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail(flags,0,0);
}



void MovePolygonLowLevel(PolygonTypePtr Polygon,LocationType DeltaX,LocationType DeltaY)

{
  int *piVar1;
  PointTypePtr pPVar2;
  int iVar3;
  
  iVar3 = Polygon->PointN - 1;
  if (iVar3 != -1) {
    pPVar2 = Polygon->Points + (Polygon->PointN - 1);
    do {
      iVar3 = iVar3 + -1;
      pPVar2->X = pPVar2->X + DeltaX;
      pPVar2->Y = pPVar2->Y + DeltaY;
      pPVar2 = pPVar2 + -1;
    } while (iVar3 != -1);
  }
  (Polygon->BoundingBox).X1 = (Polygon->BoundingBox).X1 + DeltaX;
  piVar1 = &(Polygon->BoundingBox).Y1;
  *piVar1 = *piVar1 + DeltaY;
  piVar1 = &(Polygon->BoundingBox).X2;
  *piVar1 = *piVar1 + DeltaX;
  piVar1 = &(Polygon->BoundingBox).Y2;
  *piVar1 = *piVar1 + DeltaY;
  return;
}



void __regparm3 move_one_thermal(int old_index,int new_index,PinType *pin)

{
  byte *pbVar1;
  char cVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  byte bVar6;
  uint local_20;
  byte local_14;
  
  local_20 = 0;
  iVar5 = 0xf;
  if (old_index != -1) {
    cVar2 = (char)(old_index >> 0x1f);
    local_20 = (int)(uint)(pin->Flags).t[old_index / 2] >>
               ((((char)old_index - cVar2 & 1U) + cVar2) * '\x04' & 0x1f) & 0xf;
    iVar5 = old_index;
  }
  iVar3 = 0xf;
  if (new_index != -1) {
    iVar3 = new_index;
  }
  if (iVar5 < iVar3) {
    do {
      cVar2 = (char)(iVar5 >> 0x1f);
      iVar4 = iVar5 + 1;
      local_14 = (((char)iVar5 - cVar2 & 1U) + cVar2) * '\x04';
      cVar2 = (char)(iVar4 >> 0x1f);
      (pin->Flags).t[iVar5 / 2] =
           ~(byte)(0xf << (local_14 & 0x1f)) & (pin->Flags).t[iVar5 / 2] |
           (byte)(((int)(uint)(pin->Flags).t[iVar4 / 2] >>
                   ((((char)iVar4 - cVar2 & 1U) + cVar2) * '\x04' & 0x1f) & 0xfU) <<
                 (local_14 & 0x1f));
      iVar5 = iVar4;
    } while (iVar4 < iVar3);
  }
  else {
    while (iVar3 < iVar5) {
      cVar2 = (char)(iVar5 >> 0x1f);
      iVar4 = iVar5 + -1;
      local_14 = (((char)iVar5 - cVar2 & 1U) + cVar2) * '\x04';
      cVar2 = (char)(iVar4 >> 0x1f);
      (pin->Flags).t[iVar5 / 2] =
           ~(byte)(0xf << (local_14 & 0x1f)) & (pin->Flags).t[iVar5 / 2] |
           (byte)(((int)(uint)(pin->Flags).t[iVar4 / 2] >>
                   ((((char)iVar4 - cVar2 & 1U) + cVar2) * '\x04' & 0x1f) & 0xfU) <<
                 (local_14 & 0x1f));
      iVar5 = iVar4;
    }
  }
  if (new_index != -1) {
    cVar2 = (char)(new_index >> 0x1f);
    bVar6 = (((char)new_index - cVar2 & 1U) + cVar2) * '\x04';
    (pin->Flags).t[new_index / 2] =
         ~(byte)(0xf << (bVar6 & 0x1f)) & (pin->Flags).t[new_index / 2] |
         (byte)(local_20 << (bVar6 & 0x1f));
    return;
  }
  cVar2 = (char)(iVar3 >> 0x1f);
  pbVar1 = (pin->Flags).t + iVar3 / 2;
  *pbVar1 = *pbVar1 & ~(byte)(0xf << ((((char)iVar3 - cVar2 & 1U) + cVar2) * '\x04' & 0x1f));
  return;
}



void register_move_action_list(void)

{
  hid_register_actions(move_action_list,1);
  return;
}



Boolean MoveSelectedObjectsToLayer(LayerTypePtr Target)

{
  Boolean BVar1;
  
  Dest = Target;
  MoreToCome = '\x01';
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&MoveToLayerFunctions,'\x01',-1);
  return BVar1;
}



void * MoveRatToLayer(RatTypePtr *Rat)

{
  LineTypePtr Line;
  LineTypePtr pLVar1;
  
  Line = CreateNewLineOnLayer
                   (Dest,(Rat->Point1).X,(Rat->Point1).Y,(Rat->Point2).X,(Rat->Point2).Y,
                    Settings.LineThickness,Settings.Keepaway * 2,Rat->Flags);
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 8) != 0) {
    (Line->Flags).f = (Line->Flags).f | 0x20;
  }
  pLVar1 = (LineTypePtr)0x0;
  if (Line != (LineTypePtr)0x0) {
    AddObjectToCreateUndoList(4,Dest,Line,Line);
    if (PCB->RatOn != '\0') {
      EraseRat(Rat);
    }
    MoveObjectToRemoveUndoList(0x20,Rat,Rat,Rat);
    DrawLine(Dest,Line,0);
    Draw();
    pLVar1 = Line;
  }
  return pLVar1;
}



int moveline_callback(BoxType *b,void *cl)

{
  PinTypePtr *Via;
  int in_GS_OFFSET;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  
  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);
  MakeFlags((FlagType *)&local_1c,0);
  Via = CreateNewVia(PCB->Data,*(LocationType *)cl,*(LocationType *)((int)cl + 4),
                     Settings.ViaThickness,Settings.Keepaway * 2,0,Settings.ViaDrillingHole,
                     (char *)0x0,(FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  if (Via != (PinTypePtr *)0x0) {
    AddObjectToCreateUndoList(1,Via,Via,Via);
    DrawVia(Via,0);
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 8,1);
}



void * MoveObjectToLayer(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LayerTypePtr Target,
                        Boolean enmasse)

{
  void *pvVar1;
  
  Dest = Target;
  MoreToCome = enmasse;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&MoveToLayerFunctions,Type,Ptr1,Ptr2,Ptr3);
  IncrementUndoSerialNumber();
  return pvVar1;
}



void * MoveObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  void *pvVar1;
  
  DeltaX = DX;
  DeltaY = DY;
  AddObjectToMoveUndoList(Type,Ptr1,Ptr2,Ptr3,DX,DY);
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&MoveFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



void * MoveArc(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  int *piVar1;
  LocationType LVar2;
  LocationType LVar3;
  
  RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
  r_delete_entry(Layer->arc_tree,(BoxType *)Arc);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  if (Layer->On == '\0') {
    Arc->X = Arc->X + DeltaX;
    Arc->Y = Arc->Y + LVar3;
    (Arc->BoundingBox).X1 = (Arc->BoundingBox).X1 + LVar2;
    piVar1 = &(Arc->BoundingBox).Y1;
    *piVar1 = *piVar1 + LVar3;
    piVar1 = &(Arc->BoundingBox).X2;
    *piVar1 = *piVar1 + LVar2;
    piVar1 = &(Arc->BoundingBox).Y2;
    *piVar1 = *piVar1 + LVar3;
  }
  else {
    EraseArc(Arc);
    LVar3 = DeltaY;
    LVar2 = DeltaX;
    Arc->X = Arc->X + DeltaX;
    Arc->Y = Arc->Y + LVar3;
    (Arc->BoundingBox).X1 = (Arc->BoundingBox).X1 + LVar2;
    piVar1 = &(Arc->BoundingBox).Y1;
    *piVar1 = *piVar1 + LVar3;
    piVar1 = &(Arc->BoundingBox).X2;
    *piVar1 = *piVar1 + LVar2;
    piVar1 = &(Arc->BoundingBox).Y2;
    *piVar1 = *piVar1 + LVar3;
    DrawArc(Layer,Arc,0);
    Draw();
  }
  r_insert_entry(Layer->arc_tree,(BoxType *)Arc,0);
  ClearFromPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
  return Arc;
}



void * MovePolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
  }
  r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
  MovePolygonLowLevel(Polygon,DeltaX,DeltaY);
  r_insert_entry(Layer->polygon_tree,(BoxType *)Polygon,0);
  InitClip(PCB->Data,Layer,(PolygonType *)Polygon);
  if (Layer->On != '\0') {
    DrawPolygon(Layer,Polygon,0);
    Draw();
  }
  return Polygon;
}



void * MoveText(LayerTypePtr Layer,TextTypePtr Text)

{
  int *piVar1;
  LocationType LVar2;
  LocationType LVar3;
  
  RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  r_delete_entry(Layer->text_tree,(BoxType *)Text);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  if (Layer->On == '\0') {
    (Text->BoundingBox).X1 = (Text->BoundingBox).X1 + DeltaX;
    piVar1 = &(Text->BoundingBox).Y1;
    *piVar1 = *piVar1 + LVar3;
    piVar1 = &(Text->BoundingBox).X2;
    *piVar1 = *piVar1 + LVar2;
    piVar1 = &(Text->BoundingBox).Y2;
    *piVar1 = *piVar1 + LVar3;
    Text->X = Text->X + LVar2;
    Text->Y = Text->Y + LVar3;
  }
  else {
    EraseText(Layer,Text);
    LVar3 = DeltaY;
    LVar2 = DeltaX;
    (Text->BoundingBox).X1 = (Text->BoundingBox).X1 + DeltaX;
    piVar1 = &(Text->BoundingBox).Y1;
    *piVar1 = *piVar1 + LVar3;
    piVar1 = &(Text->BoundingBox).X2;
    *piVar1 = *piVar1 + LVar2;
    piVar1 = &(Text->BoundingBox).Y2;
    *piVar1 = *piVar1 + LVar3;
    Text->X = Text->X + LVar2;
    Text->Y = Text->Y + LVar3;
    DrawText(Layer,Text,0);
    Draw();
  }
  r_insert_entry(Layer->text_tree,(BoxType *)Text,0);
  ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  return Text;
}



void * MovePolygonPoint(LayerTypePtr Layer,PolygonTypePtr Polygon,PointTypePtr Point)

{
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
  }
  r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
  Point->X = Point->X + DeltaX;
  Point->Y = Point->Y + DeltaY;
  SetPolygonBoundingBox(Polygon);
  r_insert_entry(Layer->polygon_tree,(BoxType *)Polygon,0);
  RemoveExcessPolygonPoints(Layer,Polygon);
  InitClip(PCB->Data,Layer,(PolygonType *)Polygon);
  if (Layer->On != '\0') {
    DrawPolygon(Layer,Polygon,0);
    Draw();
  }
  return Point;
}



void * MoveElementName(ElementTypePtr *Element)

{
  int *piVar1;
  rtree_t *rtree;
  LocationType LVar2;
  LocationType LVar3;
  rtree_t *rtree_00;
  ElementTypePtr *pEVar4;
  int iVar5;
  
  if ((PCB->ElementOn != '\0') &&
     ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (PCB->InvisibleObjectsOn != '\0')))) {
    iVar5 = 2;
    EraseElementName(Element);
    pEVar4 = Element;
    do {
      rtree_00 = (rtree_t *)0x0;
      rtree = (rtree_t *)(&PCB->Data->ElementN)[iVar5 + 0xc];
      if (rtree != (rtree_t *)0x0) {
        r_delete_entry(rtree,(BoxType *)(Element->Name + iVar5));
        rtree_00 = (rtree_t *)(&PCB->Data->ElementN)[iVar5 + 0xc];
      }
      LVar3 = DeltaY;
      LVar2 = DeltaX;
      pEVar4->Name[2].BoundingBox.X1 = pEVar4->Name[2].BoundingBox.X1 + DeltaX;
      piVar1 = &pEVar4->Name[2].BoundingBox.Y1;
      *piVar1 = *piVar1 + LVar3;
      piVar1 = &pEVar4->Name[2].BoundingBox.X2;
      *piVar1 = *piVar1 + LVar2;
      piVar1 = &pEVar4->Name[2].BoundingBox.Y2;
      *piVar1 = *piVar1 + LVar3;
      piVar1 = &pEVar4->Name[2].X;
      *piVar1 = *piVar1 + LVar2;
      piVar1 = &pEVar4->Name[2].Y;
      *piVar1 = *piVar1 + LVar3;
      if (rtree_00 != (rtree_t *)0x0) {
        r_insert_entry(rtree_00,(BoxType *)(Element->Name + iVar5),0);
      }
      iVar5 = iVar5 + -1;
      pEVar4 = (ElementTypePtr *)&pEVar4[-1].LineN;
    } while (iVar5 != -1);
    DrawElementName(Element,0);
    Draw();
    return Element;
  }
  iVar5 = 2;
  pEVar4 = Element;
  do {
    rtree = (rtree_t *)(&PCB->Data->ElementN)[iVar5 + 0xc];
    rtree_00 = (rtree_t *)0x0;
    if (rtree != (rtree_t *)0x0) {
      r_delete_entry(rtree,(BoxType *)(Element->Name + iVar5));
      rtree_00 = (rtree_t *)(&PCB->Data->ElementN)[iVar5 + 0xc];
    }
    LVar3 = DeltaY;
    LVar2 = DeltaX;
    pEVar4->Name[2].BoundingBox.X1 = pEVar4->Name[2].BoundingBox.X1 + DeltaX;
    piVar1 = &pEVar4->Name[2].BoundingBox.Y1;
    *piVar1 = *piVar1 + LVar3;
    piVar1 = &pEVar4->Name[2].BoundingBox.X2;
    *piVar1 = *piVar1 + LVar2;
    piVar1 = &pEVar4->Name[2].BoundingBox.Y2;
    *piVar1 = *piVar1 + LVar3;
    piVar1 = &pEVar4->Name[2].X;
    *piVar1 = *piVar1 + LVar2;
    piVar1 = &pEVar4->Name[2].Y;
    *piVar1 = *piVar1 + LVar3;
    if (rtree_00 != (rtree_t *)0x0) {
      r_insert_entry(rtree_00,(BoxType *)(Element->Name + iVar5),0);
    }
    iVar5 = iVar5 + -1;
    pEVar4 = (ElementTypePtr *)&pEVar4[-1].LineN;
  } while (iVar5 != -1);
  return Element;
}



void * MoveVia(PinTypePtr_conflict Via)

{
  int *piVar1;
  LocationType LVar2;
  LocationType LVar3;
  PCBTypePtr pPVar4;
  
  r_delete_entry(PCB->Data->via_tree,(BoxType *)Via);
  RestoreToPolygon((DataType *)PCB->Data,1,Via,Via);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  Via->Y = Via->Y + DeltaY;
  piVar1 = &(Via->BoundingBox).Y1;
  *piVar1 = *piVar1 + LVar3;
  piVar1 = &(Via->BoundingBox).Y2;
  *piVar1 = *piVar1 + LVar3;
  pPVar4 = PCB;
  Via->X = Via->X + LVar2;
  (Via->BoundingBox).X1 = (Via->BoundingBox).X1 + LVar2;
  piVar1 = &(Via->BoundingBox).X2;
  *piVar1 = *piVar1 + LVar2;
  if (pPVar4->ViaOn != '\0') {
    EraseVia((PinTypePtr *)Via);
    pPVar4 = PCB;
  }
  r_insert_entry(pPVar4->Data->via_tree,(BoxType *)Via,0);
  ClearFromPolygon((DataType *)PCB->Data,1,Via,Via);
  if (PCB->ViaOn != '\0') {
    DrawVia((PinTypePtr *)Via,0);
    Draw();
  }
  return Via;
}



void * MoveLine(LayerTypePtr Layer,LineTypePtr Line)

{
  int *piVar1;
  LocationType LVar2;
  LocationType LVar3;
  
  if (Layer->On != '\0') {
    EraseLine(Line);
  }
  RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
  r_delete_entry(Layer->line_tree,(BoxType *)Line);
  LVar3 = DeltaY;
  LVar2 = DeltaX;
  (Line->Point1).X = (Line->Point1).X + DeltaX;
  (Line->Point2).X = (Line->Point2).X + LVar2;
  piVar1 = &(Line->Point1).Y;
  *piVar1 = *piVar1 + LVar3;
  piVar1 = &(Line->Point2).Y;
  *piVar1 = *piVar1 + LVar3;
  SetLineBoundingBox(Line);
  r_insert_entry(Layer->line_tree,(BoxType *)Line,0);
  ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
  if (Layer->On != '\0') {
    DrawLine(Layer,Line,0);
    Draw();
  }
  return Line;
}



void * MoveLinePoint(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr Point)

{
  if (Layer == (LayerTypePtr)0x0) {
    if (PCB->RatOn != '\0') {
      EraseRat((RatTypePtr *)Line);
    }
    r_delete_entry(PCB->Data->rat_tree,(BoxType *)Line);
    Point->X = Point->X + DeltaX;
    Point->Y = Point->Y + DeltaY;
    SetLineBoundingBox(Line);
    r_insert_entry(PCB->Data->rat_tree,(BoxType *)Line,0);
    if (PCB->RatOn != '\0') {
      DrawRat((RatTypePtr *)Line,0);
      Draw();
    }
  }
  else {
    if (Layer->On != '\0') {
      EraseLine(Line);
    }
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    r_delete_entry(Layer->line_tree,(BoxType *)Line);
    Point->X = Point->X + DeltaX;
    Point->Y = Point->Y + DeltaY;
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,(BoxType *)Line,0);
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
    if (Layer->On != '\0') {
      DrawLine(Layer,Line,0);
      Draw();
    }
  }
  return Line;
}



void * MoveObjectAndRubberband
                 (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  FlagType *pFVar1;
  void *pvVar2;
  RubberbandTypePtr *pRVar3;
  
  DeltaX = DX;
  DeltaY = DY;
  if ((DY == 0) && (DX == 0)) {
    return (void *)0x0;
  }
  pRVar3 = Crosshair.AttachedObject.Rubberband;
  if (Crosshair.AttachedObject.RubberbandN != 0) {
    do {
      pFVar1 = &pRVar3->Line->Flags;
      pFVar1->f = pFVar1->f & 0xfffffdff;
      AddObjectToMoveUndoList(0x1000,pRVar3->Layer,pRVar3->Line,pRVar3->MovedPoint,DX,DY);
      MoveLinePoint(pRVar3->Layer,pRVar3->Line,pRVar3->MovedPoint);
      Crosshair.AttachedObject.RubberbandN = Crosshair.AttachedObject.RubberbandN - 1;
      pRVar3 = pRVar3 + 1;
    } while (Crosshair.AttachedObject.RubberbandN != 0);
  }
  AddObjectToMoveUndoList(Type,Ptr1,Ptr2,Ptr3,DX,DY);
  pvVar2 = ObjectOperation((ObjectFunctionTypePtr *)&MoveFunctions,Type,Ptr1,Ptr2,Ptr3);
  IncrementUndoSerialNumber();
  return pvVar2;
}



int mptl_pin_callback(BoxType *b,void *cl)

{
  byte *pbVar1;
  Boolean BVar2;
  sbyte sVar3;
  uint uVar4;
  byte local_20;
  
  if (((0xf << (sbyte)((*(uint *)cl & 1) << 2) & (uint)*(byte *)((int)&b[1].X2 + (*(uint *)cl >> 1))
       ) != 0) &&
     (BVar2 = IsPointInPolygon(b[3].Y1,b[3].X2,b[2].Y1 + b[2].X2 + 2,
                               *(PolygonTypePtr *)((int)cl + 0xc)), BVar2 != '\0')) {
    if (*(int *)((int)cl + 8) == 0x100) {
      AddObjectToFlagUndoList(0x100,(void *)b[4].Y1,b,b);
    }
    else {
      AddObjectToFlagUndoList(1,b,b,b);
    }
    uVar4 = *(uint *)((int)cl + 4) >> 1;
    sVar3 = (sbyte)((*(uint *)((int)cl + 4) & 1) << 2);
    local_20 = (byte)(0xf << sVar3);
    *(byte *)((int)&b[1].X2 + uVar4) =
         ~local_20 & *(byte *)((int)&b[1].X2 + uVar4) |
         (byte)(((int)(uint)*(byte *)((int)&b[1].X2 + (*(uint *)cl >> 1)) >>
                 (sbyte)((*(uint *)cl & 1) << 2) & 0xfU) << sVar3);
    pbVar1 = (byte *)((int)&b[1].X2 + (*(uint *)cl >> 1));
    *pbVar1 = *pbVar1 & ~(byte)(0xf << (sbyte)((*(uint *)cl & 1) << 2));
    return 1;
  }
  return 0;
}



void * MovePolygonToLayerLowLevel
                 (LayerTypePtr Source,PolygonTypePtr Polygon,LayerTypePtr Destination)

{
  PolygonTypePtr which;
  rtree_t *rtree;
  uint uVar1;
  Cardinal CVar2;
  uint uVar3;
  PolygonTypePtr ppVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  which = GetPolygonMemory(Destination);
  r_delete_entry(Source->polygon_tree,(BoxType *)Polygon);
  (which->BoundingBox).X1 = (Polygon->BoundingBox).X1;
  (which->BoundingBox).Y1 = (Polygon->BoundingBox).Y1;
  (which->BoundingBox).X2 = (Polygon->BoundingBox).X2;
  (which->BoundingBox).Y2 = (Polygon->BoundingBox).Y2;
  which->ID = Polygon->ID;
  (which->Flags).f = (Polygon->Flags).f;
  *(undefined4 *)(which->Flags).t = *(undefined4 *)(Polygon->Flags).t;
  *(undefined4 *)((which->Flags).t + 4) = *(undefined4 *)((Polygon->Flags).t + 4);
  which->net = Polygon->net;
  which->PointN = Polygon->PointN;
  which->PointMax = Polygon->PointMax;
  which->Clipped = Polygon->Clipped;
  which->NoHoles = Polygon->NoHoles;
  which->NoHolesValid = Polygon->NoHolesValid;
  which->Points = Polygon->Points;
  ppVar4 = Source->Polygon;
  CVar2 = Source->PolygonN - 1;
  Source->PolygonN = CVar2;
  (Polygon->BoundingBox).X1 = ppVar4[CVar2].BoundingBox.X1;
  (Polygon->BoundingBox).Y1 = ppVar4[CVar2].BoundingBox.Y1;
  (Polygon->BoundingBox).X2 = ppVar4[CVar2].BoundingBox.X2;
  (Polygon->BoundingBox).Y2 = ppVar4[CVar2].BoundingBox.Y2;
  Polygon->ID = ppVar4[CVar2].ID;
  (Polygon->Flags).f = ppVar4[CVar2].Flags.f;
  *(undefined4 *)(Polygon->Flags).t = *(undefined4 *)ppVar4[CVar2].Flags.t;
  *(undefined4 *)((Polygon->Flags).t + 4) = *(undefined4 *)(ppVar4[CVar2].Flags.t + 4);
  Polygon->net = ppVar4[CVar2].net;
  Polygon->PointN = ppVar4[CVar2].PointN;
  Polygon->PointMax = ppVar4[CVar2].PointMax;
  Polygon->Clipped = ppVar4[CVar2].Clipped;
  Polygon->NoHoles = ppVar4[CVar2].NoHoles;
  Polygon->NoHolesValid = ppVar4[CVar2].NoHolesValid;
  Polygon->Points = ppVar4[CVar2].Points;
  r_substitute(Source->polygon_tree,(BoxType *)(Source->Polygon + Source->PolygonN),
               (BoxType *)Polygon);
  uVar3 = 0x3c;
  ppVar4 = Source->Polygon + Source->PolygonN;
  bVar5 = ((uint)ppVar4 & 1) != 0;
  if (bVar5) {
    *(undefined *)&(ppVar4->BoundingBox).X1 = 0;
    ppVar4 = (PolygonTypePtr)((int)&(ppVar4->BoundingBox).X1 + 1);
    uVar3 = 0x3b;
  }
  if (((uint)ppVar4 & 2) != 0) {
    *(undefined2 *)&(ppVar4->BoundingBox).X1 = 0;
    uVar3 = uVar3 - 2;
    ppVar4 = (PolygonTypePtr)((int)&(ppVar4->BoundingBox).X1 + 2);
  }
  uVar1 = uVar3 >> 2;
  while (uVar1 != 0) {
    uVar1 = uVar1 - 1;
    (ppVar4->BoundingBox).X1 = 0;
    ppVar4 = (PolygonTypePtr)((int)ppVar4 + (uint)bVar6 * -8 + 4);
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)&(ppVar4->BoundingBox).X1 = 0;
    ppVar4 = (PolygonTypePtr)((int)&(ppVar4->BoundingBox).X1 + 2);
  }
  if (bVar5) {
    *(undefined *)&(ppVar4->BoundingBox).X1 = 0;
  }
  rtree = Destination->polygon_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->polygon_tree = rtree;
  }
  r_insert_entry(rtree,(BoxType *)which,0);
  return which;
}



void * MovePolygonToLayer(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  mptlc d;
  
  if ((*(byte *)((int)&(Polygon->Flags).f + 1) & 0x20) == 0) {
    if ((Dest != (LayerTypePtr)0xffffffff) && (Dest != Layer)) {
      AddObjectToMoveToLayerUndoList(8,Layer,Polygon,Polygon);
      if (Layer->On != '\0') {
        ErasePolygon(Polygon);
      }
      d.snum = GetLayerNumber(PCB->Data,Layer);
      d.dnum = GetLayerNumber(PCB->Data,Dest);
      d.polygon = Polygon;
      d.type = 0x100;
      r_search(PCB->Data->pin_tree,(BoxType *)Polygon,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               mptl_pin_callback,&d);
      d.type = 1;
      r_search(PCB->Data->via_tree,(BoxType *)Polygon,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               mptl_pin_callback,&d);
      Polygon = (PolygonTypePtr)MovePolygonToLayerLowLevel(Layer,Polygon,Dest);
      InitClip(PCB->Data,Dest,(PolygonType *)Polygon);
      if (Dest->On != '\0') {
        DrawPolygon(Dest,Polygon,0);
        Draw();
      }
    }
  }
  else {
    Message("Sorry, the object is locked\n");
    Polygon = (PolygonTypePtr)0x0;
  }
  return Polygon;
}



void * MoveTextToLayerLowLevel(LayerTypePtr Source,TextTypePtr Text,LayerTypePtr Destination)

{
  TextTypePtr Text_00;
  int iVar1;
  int iVar2;
  rtree_t *rtree;
  Cardinal CVar3;
  uint uVar4;
  uint uVar5;
  TextTypePtr pTVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  Text_00 = GetTextMemory(Destination);
  RestoreToPolygon((DataType *)PCB->Data,0x10,Source,Text);
  r_delete_entry(Source->text_tree,(BoxType *)Text);
  (Text_00->BoundingBox).X1 = (Text->BoundingBox).X1;
  (Text_00->BoundingBox).Y1 = (Text->BoundingBox).Y1;
  (Text_00->BoundingBox).X2 = (Text->BoundingBox).X2;
  (Text_00->BoundingBox).Y2 = (Text->BoundingBox).Y2;
  Text_00->ID = Text->ID;
  (Text_00->Flags).f = (Text->Flags).f;
  *(undefined4 *)(Text_00->Flags).t = *(undefined4 *)(Text->Flags).t;
  *(undefined4 *)((Text_00->Flags).t + 4) = *(undefined4 *)((Text->Flags).t + 4);
  Text_00->net = Text->net;
  Text_00->Scale = Text->Scale;
  Text_00->X = Text->X;
  Text_00->Y = Text->Y;
  *(undefined4 *)&Text_00->Direction = *(undefined4 *)&Text->Direction;
  Text_00->TextString = Text->TextString;
  Text_00->Element = Text->Element;
  pTVar6 = Source->Text;
  CVar3 = Source->TextN - 1;
  Source->TextN = CVar3;
  (Text->BoundingBox).X1 = pTVar6[CVar3].BoundingBox.X1;
  (Text->BoundingBox).Y1 = pTVar6[CVar3].BoundingBox.Y1;
  (Text->BoundingBox).X2 = pTVar6[CVar3].BoundingBox.X2;
  (Text->BoundingBox).Y2 = pTVar6[CVar3].BoundingBox.Y2;
  Text->ID = pTVar6[CVar3].ID;
  (Text->Flags).f = pTVar6[CVar3].Flags.f;
  *(undefined4 *)(Text->Flags).t = *(undefined4 *)pTVar6[CVar3].Flags.t;
  *(undefined4 *)((Text->Flags).t + 4) = *(undefined4 *)(pTVar6[CVar3].Flags.t + 4);
  Text->net = pTVar6[CVar3].net;
  Text->Scale = pTVar6[CVar3].Scale;
  Text->X = pTVar6[CVar3].X;
  Text->Y = pTVar6[CVar3].Y;
  *(undefined4 *)&Text->Direction = *(undefined4 *)&pTVar6[CVar3].Direction;
  Text->TextString = pTVar6[CVar3].TextString;
  Text->Element = pTVar6[CVar3].Element;
  r_substitute(Source->text_tree,(BoxType *)(Source->Text + Source->TextN),(BoxType *)Text);
  pTVar6 = Source->Text + Source->TextN;
  uVar5 = 0x3c;
  bVar7 = ((uint)pTVar6 & 1) != 0;
  if (bVar7) {
    *(undefined *)&(pTVar6->BoundingBox).X1 = 0;
    pTVar6 = (TextTypePtr)((int)&(pTVar6->BoundingBox).X1 + 1);
    uVar5 = 0x3b;
  }
  if (((uint)pTVar6 & 2) != 0) {
    *(undefined2 *)&(pTVar6->BoundingBox).X1 = 0;
    uVar5 = uVar5 - 2;
    pTVar6 = (TextTypePtr)((int)&(pTVar6->BoundingBox).X1 + 2);
  }
  uVar4 = uVar5 >> 2;
  while (uVar4 != 0) {
    uVar4 = uVar4 - 1;
    (pTVar6->BoundingBox).X1 = 0;
    pTVar6 = (TextTypePtr)((int)pTVar6 + (uint)bVar8 * -8 + 4);
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)&(pTVar6->BoundingBox).X1 = 0;
    pTVar6 = (TextTypePtr)((int)&(pTVar6->BoundingBox).X1 + 2);
  }
  if (bVar7) {
    *(undefined *)&(pTVar6->BoundingBox).X1 = 0;
  }
  iVar1 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar2 = GetLayerGroupNumberByPointer(Destination);
  if (iVar1 == iVar2) {
    (Text_00->Flags).f = (Text_00->Flags).f | 0x80;
  }
  else {
    (Text_00->Flags).f = (Text_00->Flags).f & 0xffffff7f;
  }
  SetTextBoundingBox((FontTypePtr)&PCB->Font,Text_00);
  rtree = Destination->text_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->text_tree = rtree;
  }
  r_insert_entry(rtree,(BoxType *)Text_00,0);
  ClearFromPolygon((DataType *)PCB->Data,0x10,Destination,Text_00);
  return Text_00;
}



void * MoveTextToLayer(LayerTypePtr Layer,TextTypePtr Text)

{
  char cVar1;
  
  if ((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) == 0) {
    if (Dest != Layer) {
      AddObjectToMoveToLayerUndoList(0x10,Layer,Text,Text);
      if (Layer->On != '\0') {
        EraseText(Layer,Text);
      }
      Text = (TextTypePtr)MoveTextToLayerLowLevel(Layer,Text,Dest);
      if (Dest->On == '\0') {
        cVar1 = Layer->On;
      }
      else {
        DrawText(Dest,Text,0);
        cVar1 = Layer->On;
      }
      if ((cVar1 != '\0') || (Dest->On != '\0')) {
        Draw();
      }
    }
  }
  else {
    Message("Sorry, the object is locked\n");
    Text = (TextTypePtr)0x0;
  }
  return Text;
}



void * MoveArcToLayerLowLevel(LayerTypePtr Source,ArcTypePtr *Arc,LayerTypePtr Destination)

{
  ArcTypePtr *which;
  Cardinal CVar1;
  rtree_t *rtree;
  int iVar2;
  uint uVar3;
  uint uVar4;
  ArcTypePtr *pAVar5;
  ArcTypePtr *pAVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  which = GetArcMemory(Destination);
  r_delete_entry(Source->arc_tree,(BoxType *)Arc);
  iVar2 = 0x11;
  pAVar5 = Arc;
  pAVar6 = which;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    (pAVar6->BoundingBox).X1 = (pAVar5->BoundingBox).X1;
    pAVar5 = (ArcTypePtr *)((int)pAVar5 + (uint)bVar8 * -8 + 4);
    pAVar6 = (ArcTypePtr *)((int)pAVar6 + (uint)bVar8 * -8 + 4);
  }
  CVar1 = Source->ArcN - 1;
  iVar2 = 0x11;
  Source->ArcN = CVar1;
  pAVar5 = Source->Arc + CVar1;
  pAVar6 = Arc;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    (pAVar6->BoundingBox).X1 = (pAVar5->BoundingBox).X1;
    pAVar5 = (ArcTypePtr *)((int)pAVar5 + (uint)bVar8 * -8 + 4);
    pAVar6 = (ArcTypePtr *)((int)pAVar6 + (uint)bVar8 * -8 + 4);
  }
  r_substitute(Source->arc_tree,(BoxType *)(Source->Arc + Source->ArcN),(BoxType *)Arc);
  uVar4 = 0x44;
  pAVar5 = Source->Arc + Source->ArcN;
  bVar7 = ((uint)pAVar5 & 1) != 0;
  if (bVar7) {
    *(undefined *)&(pAVar5->BoundingBox).X1 = 0;
    pAVar5 = (ArcTypePtr *)((int)&(pAVar5->BoundingBox).X1 + 1);
    uVar4 = 0x43;
  }
  if (((uint)pAVar5 & 2) != 0) {
    *(undefined2 *)&(pAVar5->BoundingBox).X1 = 0;
    uVar4 = uVar4 - 2;
    pAVar5 = (ArcTypePtr *)((int)&(pAVar5->BoundingBox).X1 + 2);
  }
  uVar3 = uVar4 >> 2;
  while (uVar3 != 0) {
    uVar3 = uVar3 - 1;
    (pAVar5->BoundingBox).X1 = 0;
    pAVar5 = (ArcTypePtr *)((int)pAVar5 + (uint)bVar8 * -8 + 4);
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)&(pAVar5->BoundingBox).X1 = 0;
    pAVar5 = (ArcTypePtr *)((int)&(pAVar5->BoundingBox).X1 + 2);
  }
  if (bVar7) {
    *(undefined *)&(pAVar5->BoundingBox).X1 = 0;
  }
  rtree = Destination->arc_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->arc_tree = rtree;
  }
  r_insert_entry(rtree,(BoxType *)which,0);
  return which;
}



void * MoveArcToLayer(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  ArcTypePtr *Arc_00;
  
  if ((*(byte *)((int)&(Arc->Flags).f + 1) & 0x20) == 0) {
    if ((Dest == Layer) && (Dest->On != '\0')) {
      DrawArc(Dest,Arc,0);
      Draw();
    }
    if ((Dest == (LayerTypePtr)0xffffffff) || (Layer == Dest)) {
      return Arc;
    }
    AddObjectToMoveToLayerUndoList(0x4000,Layer,Arc,Arc);
    RestoreToPolygon((DataType *)PCB->Data,0x4000,Layer,Arc);
    if (Layer->On != '\0') {
      EraseArc(Arc);
    }
    Arc_00 = (ArcTypePtr *)MoveArcToLayerLowLevel(Layer,Arc,Dest);
    ClearFromPolygon((DataType *)PCB->Data,0x4000,Dest,Arc);
    if (Dest->On != '\0') {
      DrawArc(Dest,Arc_00,0);
    }
    Draw();
  }
  else {
    Message("Sorry, the object is locked\n");
    Arc_00 = (ArcTypePtr *)0x0;
  }
  return Arc_00;
}



void * MoveLineToLayerLowLevel(LayerTypePtr Source,LineTypePtr Line,LayerTypePtr Destination)

{
  LineTypePtr which;
  Cardinal CVar1;
  rtree_t *rtree;
  int iVar2;
  uint uVar3;
  uint uVar4;
  LineTypePtr pLVar5;
  LineTypePtr pLVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  which = GetLineMemory(Destination);
  r_delete_entry(Source->line_tree,(BoxType *)Line);
  iVar2 = 0x16;
  pLVar5 = Line;
  pLVar6 = which;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    (pLVar6->BoundingBox).X1 = (pLVar5->BoundingBox).X1;
    pLVar5 = (LineTypePtr)((int)pLVar5 + (uint)bVar8 * -8 + 4);
    pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar8 * -8 + 4);
  }
  iVar2 = 0x16;
  CVar1 = Source->LineN - 1;
  Source->LineN = CVar1;
  pLVar5 = Source->Line + CVar1;
  pLVar6 = Line;
  while (iVar2 != 0) {
    iVar2 = iVar2 + -1;
    (pLVar6->BoundingBox).X1 = (pLVar5->BoundingBox).X1;
    pLVar5 = (LineTypePtr)((int)pLVar5 + (uint)bVar8 * -8 + 4);
    pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar8 * -8 + 4);
  }
  r_substitute(Source->line_tree,(BoxType *)(Source->Line + Source->LineN),(BoxType *)Line);
  uVar4 = 0x58;
  pLVar5 = Source->Line + Source->LineN;
  bVar7 = ((uint)pLVar5 & 1) != 0;
  if (bVar7) {
    *(undefined *)&(pLVar5->BoundingBox).X1 = 0;
    pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 1);
    uVar4 = 0x57;
  }
  if (((uint)pLVar5 & 2) != 0) {
    *(undefined2 *)&(pLVar5->BoundingBox).X1 = 0;
    uVar4 = uVar4 - 2;
    pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 2);
  }
  uVar3 = uVar4 >> 2;
  while (uVar3 != 0) {
    uVar3 = uVar3 - 1;
    (pLVar5->BoundingBox).X1 = 0;
    pLVar5 = (LineTypePtr)((int)pLVar5 + (uint)bVar8 * -8 + 4);
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)&(pLVar5->BoundingBox).X1 = 0;
    pLVar5 = (LineTypePtr)((int)&(pLVar5->BoundingBox).X1 + 2);
  }
  if (bVar7) {
    *(undefined *)&(pLVar5->BoundingBox).X1 = 0;
  }
  rtree = Destination->line_tree;
  if (rtree == (rtree_t *)0x0) {
    rtree = r_create_tree((BoxType **)0x0,0,0);
    Destination->line_tree = rtree;
  }
  r_insert_entry(rtree,(BoxType *)which,0);
  return which;
}



void * MoveLineToLayer(LayerTypePtr Layer,LineTypePtr Line)

{
  char cVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  LineTypePtr Line_00;
  via_info info;
  BoxType sb;
  void *ptr3;
  void *ptr2;
  void *ptr1;
  
  if ((*(byte *)((int)&(Line->Flags).f + 1) & 0x20) == 0) {
    if ((Dest == Layer) && (Dest->On != '\0')) {
      DrawLine(Dest,Line,0);
      Draw();
    }
    if ((Dest == (LayerTypePtr)0xffffffff) || (Layer == Dest)) {
      return Line;
    }
    AddObjectToMoveToLayerUndoList(4,Layer,Line,Line);
    if (Layer->On != '\0') {
      EraseLine(Line);
    }
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    Line_00 = (LineTypePtr)MoveLineToLayerLowLevel(Layer,Line,Dest);
    ClearFromPolygon((DataType *)PCB->Data,4,Dest,Line_00);
    if (Dest->On == '\0') {
      Draw();
      cVar1 = PCB->ViaOn;
    }
    else {
      DrawLine(Dest,Line_00,0);
      Draw();
      cVar1 = PCB->ViaOn;
    }
    if ((cVar1 != '\0') && (MoreToCome == '\0')) {
      iVar2 = GetLayerGroupNumberByPointer(Layer);
      iVar3 = GetLayerGroupNumberByPointer(Dest);
      if (iVar2 != iVar3) {
        iVar2 = GetLayerNumber(PCB->Data,Layer);
        if ((iVar2 < PCB->Data->LayerN) &&
           (iVar2 = GetLayerNumber(PCB->Data,Dest), iVar2 < PCB->Data->LayerN)) {
          iVar2 = (Line_00->Point1).X;
          iVar4 = Line_00->Thickness / 2;
          sb.X1 = -iVar4 + iVar2;
          sb.X2 = iVar4 + iVar2;
          iVar3 = (Line_00->Point1).Y;
          sb.Y1 = -iVar4 + iVar3;
          sb.Y2 = iVar4 + iVar3;
          iVar2 = SearchObjectByLocation
                            (0x101,&ptr1,&ptr2,&ptr3,iVar2,iVar3,Settings.ViaThickness / 2);
          if (iVar2 == 0) {
            info.X = (Line_00->Point1).X;
            info.Y = (Line_00->Point1).Y;
            iVar2 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar2 == 0) {
              r_search(Layer->line_tree,&sb,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                       moveline_callback,&info);
            }
          }
          iVar2 = (Line_00->Point2).X;
          iVar4 = Line_00->Thickness / 2;
          sb.X1 = -iVar4 + iVar2;
          sb.X2 = iVar4 + iVar2;
          iVar3 = (Line_00->Point2).Y;
          sb.Y1 = -iVar4 + iVar3;
          sb.Y2 = iVar4 + iVar3;
          iVar2 = SearchObjectByLocation
                            (0x101,&ptr1,&ptr2,&ptr3,iVar2,iVar3,Settings.ViaThickness / 2);
          if (iVar2 == 0) {
            info.X = (Line_00->Point2).X;
            info.Y = (Line_00->Point2).Y;
            iVar2 = _setjmp((__jmp_buf_tag *)info.env);
            if (iVar2 == 0) {
              r_search(Layer->line_tree,&sb,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                       moveline_callback,&info);
            }
          }
          Draw();
        }
      }
    }
  }
  else {
    Message("Sorry, the object is locked\n");
    Line_00 = (LineTypePtr)0x0;
  }
  return Line_00;
}



void MoveElementLowLevel(DataTypePtr *Data,ElementTypePtr *Element,LocationType DX,LocationType DY)

{
  int *piVar1;
  LineTypePtr Line;
  uint uVar2;
  ArcTypePtr *pAVar3;
  int iVar4;
  PinTypePtr *ptr2;
  PadTypePtr_conflict Pad;
  ElementTypePtr *pEVar5;
  int iVar6;
  uint uVar7;
  uint local_28;
  uint local_24;
  
  if (Data != (DataTypePtr *)0x0) {
    r_delete_entry(Data->element_tree,(BoxType *)Element);
  }
  iVar6 = Element->LineN - 1;
  if (iVar6 != -1) {
    iVar4 = Element->LineN * 0x58;
    do {
      iVar6 = iVar6 + -1;
      Line = (LineTypePtr)((int)&Element->Line[-1].BoundingBox.X1 + iVar4);
      piVar1 = &(Line->Point1).Y;
      *piVar1 = *piVar1 + DY;
      piVar1 = &(Line->Point2).Y;
      *piVar1 = *piVar1 + DY;
      (Line->Point1).X = (Line->Point1).X + DX;
      (Line->Point2).X = (Line->Point2).X + DX;
      SetLineBoundingBox(Line);
      iVar4 = iVar4 + -0x58;
    } while (iVar6 != -1);
  }
  if (Element->PinN != 0) {
    uVar7 = 0;
    local_24 = Element->PinN;
    do {
      ptr2 = Element->Pin + uVar7;
      if (Data != (DataTypePtr *)0x0) {
        r_delete_entry(Data->pin_tree,(BoxType *)ptr2);
        RestoreToPolygon((DataType *)Data,0x100,Element,ptr2);
      }
      ptr2->X = ptr2->X + DX;
      ptr2->Y = ptr2->Y + DY;
      (ptr2->BoundingBox).X1 = (ptr2->BoundingBox).X1 + DX;
      piVar1 = &(ptr2->BoundingBox).Y1;
      *piVar1 = *piVar1 + DY;
      piVar1 = &(ptr2->BoundingBox).X2;
      *piVar1 = *piVar1 + DX;
      piVar1 = &(ptr2->BoundingBox).Y2;
      *piVar1 = *piVar1 + DY;
      if (Data != (DataTypePtr *)0x0) {
        r_insert_entry(Data->pin_tree,(BoxType *)ptr2,0);
        ClearFromPolygon((DataType *)Data,0x100,Element,ptr2);
      }
      uVar2 = Element->PinN;
    } while ((uVar2 != 0) &&
            (uVar7 = (uVar2 + 1 + uVar7) - local_24, local_24 = uVar2, uVar7 < uVar2));
  }
  uVar7 = Element->PadN;
  local_28 = 0;
  uVar2 = uVar7;
LAB_080a86a3:
  do {
    if ((uVar2 == 0) || (uVar2 <= local_28)) {
      iVar6 = Element->ArcN - 1;
      if (iVar6 != -1) {
        pAVar3 = Element->Arc + (Element->ArcN - 1);
        do {
          iVar6 = iVar6 + -1;
          pAVar3->X = pAVar3->X + DX;
          pAVar3->Y = pAVar3->Y + DY;
          (pAVar3->BoundingBox).X1 = (pAVar3->BoundingBox).X1 + DX;
          piVar1 = &(pAVar3->BoundingBox).Y1;
          *piVar1 = *piVar1 + DY;
          piVar1 = &(pAVar3->BoundingBox).X2;
          *piVar1 = *piVar1 + DX;
          piVar1 = &(pAVar3->BoundingBox).Y2;
          *piVar1 = *piVar1 + DY;
          pAVar3 = pAVar3 + -1;
        } while (iVar6 != -1);
      }
      iVar6 = 2;
      pEVar5 = Element;
      do {
        if ((Data != (DataTypePtr *)0x0) && (Data->name_tree[iVar6] != (rtree_t *)0x0)) {
          r_delete_entry(PCB->Data->name_tree[iVar6],(BoxType *)(Element->Name + iVar6));
        }
        pEVar5->Name[2].BoundingBox.X1 = pEVar5->Name[2].BoundingBox.X1 + DX;
        piVar1 = &pEVar5->Name[2].BoundingBox.Y1;
        *piVar1 = *piVar1 + DY;
        piVar1 = &pEVar5->Name[2].BoundingBox.X2;
        *piVar1 = *piVar1 + DX;
        piVar1 = &pEVar5->Name[2].BoundingBox.Y2;
        *piVar1 = *piVar1 + DY;
        piVar1 = &pEVar5->Name[2].X;
        *piVar1 = *piVar1 + DX;
        piVar1 = &pEVar5->Name[2].Y;
        *piVar1 = *piVar1 + DY;
        if ((Data != (DataTypePtr *)0x0) && (Data->name_tree[iVar6] != (rtree_t *)0x0)) {
          r_insert_entry(PCB->Data->name_tree[iVar6],(BoxType *)(Element->Name + iVar6),0);
        }
        iVar6 = iVar6 + -1;
        pEVar5 = (ElementTypePtr *)&pEVar5[-1].LineN;
      } while (iVar6 != -1);
      piVar1 = &(Element->BoundingBox).Y1;
      *piVar1 = *piVar1 + DY;
      piVar1 = &(Element->BoundingBox).Y2;
      *piVar1 = *piVar1 + DY;
      piVar1 = &(Element->VBox).Y1;
      *piVar1 = *piVar1 + DY;
      piVar1 = &(Element->VBox).Y2;
      *piVar1 = *piVar1 + DY;
      Element->MarkY = Element->MarkY + DY;
      (Element->BoundingBox).X1 = (Element->BoundingBox).X1 + DX;
      piVar1 = &(Element->BoundingBox).X2;
      *piVar1 = *piVar1 + DX;
      (Element->VBox).X1 = (Element->VBox).X1 + DX;
      piVar1 = &(Element->VBox).X2;
      *piVar1 = *piVar1 + DX;
      Element->MarkX = Element->MarkX + DX;
      if (Data != (DataTypePtr *)0x0) {
        r_insert_entry(Data->element_tree,(BoxType *)Element,0);
        return;
      }
      return;
    }
    Pad = (PadTypePtr_conflict)(Element->Pad + local_28);
    if (Data != (DataTypePtr *)0x0) goto LAB_080a8628;
    (Pad->Point1).X = (Pad->Point1).X + DX;
    (Pad->Point2).X = (Pad->Point2).X + DX;
    piVar1 = &(Pad->Point1).Y;
    *piVar1 = *piVar1 + DY;
    piVar1 = &(Pad->Point2).Y;
    *piVar1 = *piVar1 + DY;
    SetPadBoundingBox(Pad);
    uVar2 = Element->PadN;
  } while (Element->PadN != uVar7);
  goto LAB_080a86e2;
LAB_080a8628:
  r_delete_entry(Data->pad_tree,(BoxType *)Pad);
  RestoreToPolygon((DataType *)Data,0x200,Element,Pad);
  (Pad->Point1).X = (Pad->Point1).X + DX;
  piVar1 = &(Pad->Point1).Y;
  *piVar1 = *piVar1 + DY;
  (Pad->Point2).X = (Pad->Point2).X + DX;
  piVar1 = &(Pad->Point2).Y;
  *piVar1 = *piVar1 + DY;
  SetPadBoundingBox(Pad);
  r_insert_entry(Data->pad_tree,(BoxType *)Pad,0);
  ClearFromPolygon((DataType *)Data,0x200,Element,Pad);
  uVar2 = Element->PadN;
  if (Element->PadN == uVar7) {
LAB_080a86e2:
    local_28 = local_28 + 1;
    uVar2 = uVar7;
  }
  goto LAB_080a86a3;
}



void * MoveElement(ElementTypePtr *Element)

{
  char cVar1;
  bool bVar2;
  
  if ((PCB->ElementOn == '\0') ||
     ((((Element->Flags).f >> 7 & 1) != (int)Settings.ShowSolderSide &&
      (PCB->InvisibleObjectsOn == '\0')))) {
    if (PCB->PinOn != '\0') {
      EraseElementPinsAndPads(Element);
    }
    MoveElementLowLevel(PCB->Data,Element,DeltaX,DeltaY);
    bVar2 = false;
    cVar1 = PCB->PinOn;
  }
  else {
    EraseElement(Element);
    MoveElementLowLevel(PCB->Data,Element,DeltaX,DeltaY);
    DrawElementName(Element,0);
    DrawElementPackage(Element,0);
    bVar2 = true;
    cVar1 = PCB->PinOn;
  }
  if (cVar1 == '\0') {
    if (!bVar2) {
      return Element;
    }
  }
  else {
    DrawElementPinsAndPads(Element,0);
  }
  Draw();
  return Element;
}



// WARNING: Could not reconcile some variable overlaps

int MoveLayer(int old_index,int new_index)

{
  Cardinal CVar1;
  Cardinal CVar2;
  uint uVar3;
  ulong uVar4;
  char **ppcVar5;
  int iVar6;
  Cardinal CVar7;
  int iVar8;
  char *pcVar9;
  ulong uVar10;
  PCBTypePtr pPVar11;
  int *__dest;
  uint uVar12;
  Cardinal *pCVar13;
  uint uVar14;
  DataTypePtr *pDVar15;
  char **ppcVar16;
  LayerType_conflict *pLVar17;
  int iVar18;
  undefined4 *puVar19;
  undefined4 *puVar20;
  bool bVar21;
  byte bVar22;
  int local_d8;
  int local_d4;
  LayerType_conflict saved_layer;
  int groups [18];
  
  bVar22 = 0;
  AddLayerChangeToUndoList(old_index,new_index);
  IncrementUndoSerialNumber();
  if (old_index < -1) {
    local_d4 = PCB->Data->LayerN;
  }
  else {
    pDVar15 = PCB->Data;
    local_d4 = pDVar15->LayerN;
    if (old_index < local_d4) {
      if (((new_index < -1) || (0xf < new_index)) || (local_d4 < new_index)) {
        Message("Invalid new layer %d for move: must be -1..%d\n",new_index,local_d4);
        iVar6 = 1;
      }
      else {
        iVar6 = 0;
        if (old_index != new_index) {
          iVar6 = 0;
          do {
            CVar1 = (PCB->LayerGroups).Number[iVar6];
            if (CVar1 != 0) {
              pCVar13 = (PCB->LayerGroups).Entries + iVar6 * 0x12;
              CVar7 = 0;
              do {
                CVar2 = *pCVar13;
                CVar7 = CVar7 + 1;
                pCVar13 = pCVar13 + 1;
                groups[CVar2] = iVar6;
              } while (CVar7 != CVar1);
            }
            iVar6 = iVar6 + 1;
          } while (iVar6 != 0x10);
          if (old_index == -1) {
            if (local_d4 == 0x10) {
              Message("No room for new layers\n");
              return 1;
            }
            memmove((void *)(&pDVar15->field_0x4c + (new_index + 1) * 0x5c),
                    (void *)(&pDVar15->field_0x4c + new_index * 0x5c),
                    ((local_d4 + 2) - new_index) * 0x5c);
            memmove(groups + new_index + 1,groups + new_index,
                    (PCB->Data->LayerN - new_index) * 4 + 8);
            iVar6 = 0x17;
            pCVar13 = &pDVar15->ViaN + new_index * 0x17;
            __dest = &PCB->Data->LayerN;
            *__dest = *__dest + 1;
            puVar19 = (undefined4 *)(&pDVar15->field_0x4c + new_index * 0x5c);
            while (iVar6 != 0) {
              iVar6 = iVar6 + -1;
              *puVar19 = 0;
              puVar19 = puVar19 + (uint)bVar22 * 0x3ffffffe + 1;
            }
            *(undefined *)(pCVar13 + 0x24) = 1;
            pcVar9 = MyStrdup("New Layer","MoveLayer");
            *(char **)(pCVar13 + 0x13) = pcVar9;
            *(char **)(pCVar13 + 0x25) = Settings.LayerColor[new_index];
            *(char **)(pCVar13 + 0x26) = Settings.LayerSelectedColor[new_index];
            pPVar11 = PCB;
            pDVar15 = PCB->Data;
            iVar6 = pDVar15->LayerN;
            if (0 < iVar6) {
              iVar8 = 0;
              do {
                if (new_index <= LayerStack[iVar8]) {
                  LayerStack[iVar8] = LayerStack[iVar8] + 1;
                }
                iVar8 = iVar8 + 1;
              } while (iVar8 != iVar6);
            }
            (&DAT_0819587c)[iVar6] = new_index;
          }
          else {
            if (new_index == -1) {
              memmove((void *)(&pDVar15->field_0x4c + old_index * 0x5c),
                      (void *)(&pDVar15->field_0x4c + (old_index + 1) * 0x5c),
                      ((local_d4 + 1) - old_index) * 0x5c);
              puVar19 = (undefined4 *)(&PCB->Data->field_0x4c + (PCB->Data->LayerN + 1) * 0x5c);
              bVar21 = ((uint)puVar19 & 1) != 0;
              uVar14 = 0x5c;
              puVar20 = puVar19;
              if (bVar21) {
                puVar20 = (undefined4 *)((int)puVar19 + (uint)bVar22 * -2 + 1);
                *(undefined *)puVar19 = 0;
                uVar14 = 0x5b;
              }
              puVar19 = puVar20;
              if (((uint)puVar20 & 2) != 0) {
                puVar19 = (undefined4 *)((int)puVar20 + (uint)bVar22 * -4 + 2);
                *(undefined2 *)puVar20 = 0;
                uVar14 = uVar14 - 2;
              }
              uVar12 = uVar14 >> 2;
              while (uVar12 != 0) {
                uVar12 = uVar12 - 1;
                *puVar19 = 0;
                puVar19 = puVar19 + (uint)bVar22 * 0x3ffffffe + 1;
              }
              puVar20 = puVar19;
              if ((uVar14 & 2) != 0) {
                puVar20 = (undefined4 *)((int)puVar19 + (uint)bVar22 * -4 + 2);
                *(undefined2 *)puVar19 = 0;
              }
              if (bVar21) {
                *(undefined *)puVar20 = 0;
              }
              memmove(groups + old_index,groups + old_index + 1,
                      (PCB->Data->LayerN - old_index) * 4 + 4);
              pDVar15 = PCB->Data;
              iVar6 = pDVar15->LayerN;
              pPVar11 = PCB;
              if (0 < iVar6) {
                iVar8 = 0;
                __dest = LayerStack;
                do {
                  if (*__dest == old_index) {
                    memmove(__dest,__dest + 1,((iVar6 + -1) - iVar8) * 4);
                    pPVar11 = PCB;
                  }
                  pDVar15 = pPVar11->Data;
                  iVar8 = iVar8 + 1;
                  iVar6 = pDVar15->LayerN;
                  __dest = __dest + 1;
                } while (iVar8 < iVar6);
              }
              iVar6 = iVar6 + -1;
              iVar8 = 0;
              pDVar15->LayerN = iVar6;
              if (0 < iVar6) {
                do {
                  if (old_index < LayerStack[iVar8]) {
                    LayerStack[iVar8] = LayerStack[iVar8] + -1;
                  }
                  iVar8 = iVar8 + 1;
                } while (iVar8 != iVar6);
              }
            }
            else {
              iVar6 = 0x17;
              ppcVar16 = (char **)(&pDVar15->field_0x4c + old_index * 0x5c);
              pLVar17 = &saved_layer;
              while (iVar6 != 0) {
                iVar6 = iVar6 + -1;
                pLVar17->Name = *ppcVar16;
                ppcVar16 = ppcVar16 + (uint)bVar22 * 0x3ffffffe + 1;
                pLVar17 = (LayerType_conflict *)((int)pLVar17 + (uint)bVar22 * -8 + 4);
              }
              iVar6 = groups[old_index];
              if (old_index < new_index) {
                iVar8 = &PCB->Data->field_0x4c;
                memmove((void *)(iVar8 + old_index * 0x5c),(void *)(iVar8 + (old_index + 1) * 0x5c),
                        (new_index - old_index) * 0x5c);
                memmove(groups + old_index,groups + old_index + 1,(new_index - old_index) * 4);
              }
              else {
                iVar8 = &PCB->Data->field_0x4c;
                memmove((void *)(iVar8 + (new_index + 1) * 0x5c),(void *)(iVar8 + new_index * 0x5c),
                        (old_index - new_index) * 0x5c);
                memmove(groups + new_index + 1,groups + new_index,(old_index - new_index) * 4);
              }
              pLVar17 = &saved_layer;
              uVar14 = 0x5c;
              ppcVar16 = (char **)(&PCB->Data->field_0x4c + new_index * 0x5c);
              bVar21 = ((uint)ppcVar16 & 1) != 0;
              if (bVar21) {
                pLVar17 = (LayerType_conflict *)((int)&saved_layer.Name + 1);
                uVar14 = 0x5b;
                *(undefined *)ppcVar16 = saved_layer.Name._0_1_;
                ppcVar16 = (char **)((int)ppcVar16 + 1);
              }
              if (((uint)ppcVar16 & 2) != 0) {
                ppcVar5 = &pLVar17->Name;
                uVar14 = uVar14 - 2;
                pLVar17 = (LayerType_conflict *)((int)&pLVar17->Name + 2);
                *(undefined2 *)ppcVar16 = *(undefined2 *)ppcVar5;
                ppcVar16 = (char **)((int)ppcVar16 + 2);
              }
              iVar8 = 0;
              uVar12 = uVar14 >> 2;
              while (uVar12 != 0) {
                uVar12 = uVar12 - 1;
                *ppcVar16 = pLVar17->Name;
                pLVar17 = (LayerType_conflict *)((int)pLVar17 + (uint)bVar22 * -8 + 4);
                ppcVar16 = ppcVar16 + (uint)bVar22 * 0x3ffffffe + 1;
              }
              if ((uVar14 & 2) != 0) {
                *(undefined2 *)ppcVar16 = *(undefined2 *)&pLVar17->Name;
                iVar8 = 2;
              }
              if (bVar21) {
                *(undefined *)((int)ppcVar16 + iVar8) = *(undefined *)((int)&pLVar17->Name + iVar8);
              }
              groups[new_index] = iVar6;
              pPVar11 = PCB;
            }
            pDVar15 = pPVar11->Data;
          }
          if (pDVar15->ViaN != 0) {
            uVar12 = 0;
            uVar14 = pDVar15->ViaN;
            do {
              move_one_thermal(old_index,new_index,(PinType *)(pDVar15->Via + uVar12));
              pDVar15 = PCB->Data;
              uVar3 = pDVar15->ViaN;
              pPVar11 = PCB;
              if (uVar3 == 0) break;
              uVar12 = (uVar3 + 1 + uVar12) - uVar14;
              uVar14 = uVar3;
            } while (uVar12 < uVar3);
          }
          local_d4 = pDVar15->ElementN - 1;
          if (local_d4 != -1) {
            iVar6 = pDVar15->ElementN * 300;
            do {
              local_d8 = iVar6 + -300;
              iVar6 = (int)&pDVar15->Element[-1].BoundingBox.X1 + iVar6;
              if (*(uint *)(iVar6 + 0xe0) != 0) {
                uVar12 = 0;
                uVar14 = *(uint *)(iVar6 + 0xe0);
                do {
                  move_one_thermal(old_index,new_index,
                                   (PinType *)(uVar12 * 0x4c + *(int *)(iVar6 + 0x100)));
                  uVar3 = *(uint *)(iVar6 + 0xe0);
                  pPVar11 = PCB;
                  if (uVar3 == 0) break;
                  uVar12 = (uVar3 + 1 + uVar12) - uVar14;
                  uVar14 = uVar3;
                } while (uVar12 < uVar3);
              }
              local_d4 = local_d4 + -1;
              if (local_d4 == -1) goto LAB_080a8dc3;
              pDVar15 = pPVar11->Data;
              iVar6 = local_d8;
            } while( true );
          }
          goto LAB_080a8dc9;
        }
      }
      return iVar6;
    }
  }
  Message("Invalid old layer %d for move: must be -1..%d\n",old_index,local_d4 + -1);
  return 1;
LAB_080a8dc3:
  pDVar15 = pPVar11->Data;
LAB_080a8dc9:
  iVar6 = 0;
  do {
    (pPVar11->LayerGroups).Number[iVar6] = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 0x10);
  if (-2 < pDVar15->LayerN) {
    uVar10 = 0;
    do {
      iVar6 = groups[uVar10] + 0x734;
      uVar4 = (&(pPVar11->Flags).f)[iVar6];
      (&(pPVar11->Flags).f)[uVar4 + 0x744 + groups[uVar10] * 0x12] = uVar10;
      uVar10 = uVar10 + 1;
      (&(pPVar11->Flags).f)[iVar6] = uVar4 + 1;
    } while ((int)uVar10 <= pDVar15->LayerN + 1);
  }
  iVar18 = 4;
  iVar8 = 0;
  iVar6 = 0;
  while( true ) {
    if ((pPVar11->LayerGroups).Number[iVar8] == 0) {
      memmove((pPVar11->LayerGroups).Number + iVar8,
              (void *)((int)(pPVar11->LayerGroups).Number + iVar18),0x40 - iVar18);
      pCVar13 = (PCB->LayerGroups).Entries;
      memmove((void *)((int)pCVar13 + iVar6),(void *)((int)pCVar13 + iVar6 + 0x48),0x438 - iVar6);
    }
    pPVar11 = PCB;
    PCB = pPVar11;
    if (iVar8 == 0xf) break;
    iVar18 = iVar18 + 4;
    iVar8 = iVar8 + 1;
    iVar6 = iVar6 + 0x48;
  }
  hid_action("LayersChanged");
  (*gui->invalidate_all)();
  return 0;
}



int MoveLayerAction(int argc,char **argv,int x,int y)

{
  char *__nptr;
  int iVar1;
  int old_index;
  DataTypePtr *pDVar2;
  char cVar3;
  int new_index;
  char *pcVar4;
  int iVar5;
  char *pcVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  if (argc != 2) {
    Message("Usage; MoveLayer(old,new)");
    return 1;
  }
  __nptr = *argv;
  cVar3 = *__nptr;
  if ((cVar3 == 'c') && (__nptr[1] == '\0')) {
    old_index = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      old_index = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
  }
  else {
    old_index = strtol(__nptr,(char **)0x0,10);
    cVar3 = 'c';
  }
  __nptr = argv[1];
  if ((cVar3 == *__nptr) && (__nptr[1] == '\0')) {
    new_index = LayerStack[0];
    if (PCB->SilkActive != '\0') {
      new_index = (uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN;
    }
    if (new_index < 0) {
      new_index = 0;
    }
LAB_080a91c3:
    iVar5 = -1;
    iVar1 = MoveLayer(old_index,new_index);
  }
  else {
    bVar7 = *__nptr == 'u';
    if ((bVar7) && ((bVar7 = __nptr[1] == 'p', bVar7 && (bVar7 = __nptr[2] == '\0', bVar7)))) {
      if (PCB->SilkActive == '\0') {
        new_index = LayerStack[0] + -1;
      }
      else {
        new_index = PCB->Data->LayerN + -1 + (uint)(Settings.ShowSolderSide == '\0');
      }
      if (new_index < 0) {
        return 1;
      }
    }
    else {
      new_index = 5;
      pcVar4 = __nptr;
      pcVar6 = "down";
      do {
        if (new_index == 0) break;
        new_index = new_index + -1;
        bVar7 = *pcVar4 == *pcVar6;
        pcVar4 = pcVar4 + (uint)bVar8 * -2 + 1;
        pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
      } while (bVar7);
      if (!bVar7) {
        new_index = strtol(__nptr,(char **)0x0,10);
        goto LAB_080a91c3;
      }
      if (PCB->SilkActive == '\0') {
        pDVar2 = PCB->Data;
        new_index = LayerStack[0] + 1;
      }
      else {
        pDVar2 = PCB->Data;
        new_index = pDVar2->LayerN + 1 + (uint)(Settings.ShowSolderSide == '\0');
      }
      if (pDVar2->LayerN <= new_index) {
        return 1;
      }
    }
    iVar1 = MoveLayer(old_index,new_index);
    iVar5 = new_index;
  }
  if (iVar1 != 0) {
    return 1;
  }
  if ((new_index == -1) &&
     (new_index = old_index, iVar5 = old_index, PCB->Data->LayerN <= old_index)) {
    new_index = old_index + -1;
    iVar5 = new_index;
  }
  if (old_index == -1) {
    iVar5 = new_index;
  }
  if (iVar5 != -1) {
    ChangeGroupVisibility(new_index,'\x01','\x01');
    return 0;
  }
  return 0;
}



rtree_t * which_tree(mtspace_t *mtspace,mtspace_type_t which)

{
  if (which == FIXED) {
    return mtspace->ftree;
  }
  if (which != EVEN) {
    return mtspace->otree;
  }
  return mtspace->etree;
}



int mtsBoxCount(vetting_t *w)

{
  return 100;
}



mtspacebox_t * mtspace_create_box(BoxType *box,BDimension keepaway)

{
  mtspacebox_t *pmVar1;
  
  pmVar1 = (mtspacebox_t *)malloc(0x14);
  (pmVar1->box).X1 = box->X1;
  (pmVar1->box).Y1 = box->Y1;
  (pmVar1->box).X2 = box->X2;
  (pmVar1->box).Y2 = box->Y2;
  pmVar1->keepaway = keepaway;
  return pmVar1;
}



void __regparm3 append(query_closure *qc,BoxType *new)

{
  if (qc->desired != (CheapPointType *)0x0) {
    heap_insert((heap_t *)qc->checking,0.00000000,new);
    return;
  }
  vector_append((vector_t *)qc->checking,new);
  return;
}



void __regparm2 qloop(query_closure *qc,rtree_t *tree,Boolean is_vec)

{
  BoxType *query;
  int iVar1;
  heap_t *in_ECX;
  
  do {
    if (qc->desired == (CheapPointType *)0x0) {
      iVar1 = vector_is_empty((vector_t *)qc->checking);
    }
    else {
      iVar1 = heap_is_empty((heap_t *)qc->checking);
    }
    if (iVar1 != 0) {
      return;
    }
    if (qc->desired == (CheapPointType *)0x0) {
      query = (BoxType *)vector_remove_last((vector_t *)qc->checking);
      iVar1 = _setjmp((__jmp_buf_tag *)qc->env);
    }
    else {
      query = (BoxType *)heap_remove_smallest((heap_t *)qc->checking);
      iVar1 = _setjmp((__jmp_buf_tag *)qc->env);
    }
  } while (iVar1 != 0);
  qc->cbox = query;
  r_search(tree,query,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,query_one,qc);
  if (is_vec != '\0') {
    vector_append((vector_t *)in_ECX,query);
    return;
  }
  if (qc->desired == (CheapPointType *)0x0) {
    vector_append((vector_t *)in_ECX,query);
    return;
  }
  heap_insert(in_ECX,0.00000000,query);
  return;
}



void mtspace_remove(mtspace_t *mtspace,BoxType *box,mtspace_type_t which,BDimension keepaway)

{
  int iVar1;
  mts_info cl;
  BoxType small_search;
  
  cl.keepaway = keepaway;
  cl.box.X1 = box->X1;
  cl.box.Y1 = box->Y1;
  cl.box.X2 = box->X2;
  cl.box.Y2 = box->Y2;
  if (which == FIXED) {
    cl.tree = mtspace->ftree;
  }
  else {
    if (which == EVEN) {
      cl.tree = mtspace->etree;
    }
    else {
      cl.tree = mtspace->otree;
    }
  }
  small_search.X1 = (box->X2 - box->X1) / 2 + box->X1;
  small_search.X2 = small_search.X1 + 1;
  small_search.Y1 = (box->Y2 - box->Y1) / 2 + box->Y1;
  small_search.Y2 = small_search.Y1 + 1;
  iVar1 = _setjmp((__jmp_buf_tag *)cl.env);
  if (iVar1 == 0) {
    r_search(cl.tree,&small_search,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,mts_remove_one,&cl);
  }
  return;
}



int query_one(BoxType *box,void *cl)

{
  LocationType LVar1;
  LocationType *pLVar2;
  heap_t *heap;
  BoxType *new;
  int *__ptr;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int local_40;
  int local_30;
  int local_28;
  
  __ptr = *(int **)cl;
  iVar6 = *(int *)((int)cl + 0x14);
  iVar5 = iVar6;
  if (box[1].X1 == iVar6 || box[1].X1 < iVar6) {
    iVar5 = box[1].X1;
  }
  if ((*__ptr + iVar5 < box->X2) && (box->X1 < __ptr[2] - iVar5)) {
    iVar4 = __ptr[1];
    local_40 = box->Y2;
    if (iVar4 + iVar5 < local_40) {
      local_28 = __ptr[3];
      local_30 = local_28 - iVar5;
      iVar7 = box->Y1;
      if (iVar7 < local_30) {
        if ((iVar4 + iVar5 < iVar7) &&
           (iVar6 = iVar6 + *(int *)((int)cl + 0x10), iVar3 = (iVar7 + iVar5) - iVar4,
           SBORROW4(iVar3,iVar6 * 2) == iVar3 + iVar6 * -2 < 0)) {
          new = (BoxType *)malloc(0x10);
          LVar1 = (*(LocationType **)cl)[2];
          new->X1 = **(LocationType **)cl;
          new->X2 = LVar1;
          new->Y2 = iVar7 + iVar5;
          new->Y1 = iVar4;
          append((query_closure *)cl,new);
          local_40 = box->Y2;
          __ptr = *(int **)cl;
          local_28 = __ptr[3];
          local_30 = local_28 - iVar5;
        }
        if ((local_40 < local_30) &&
           (local_28 = local_28 - (local_40 - iVar5),
           iVar6 = *(int *)((int)cl + 0x14) + *(int *)((int)cl + 0x10),
           SBORROW4(local_28,iVar6 * 2) == local_28 + iVar6 * -2 < 0)) {
          new = (BoxType *)malloc(0x10);
          pLVar2 = *(LocationType **)cl;
          new->X1 = *pLVar2;
          LVar1 = pLVar2[3];
          new->X2 = pLVar2[2];
          new->Y2 = LVar1;
          new->Y1 = local_40 - iVar5;
          append((query_closure *)cl,new);
          __ptr = *(int **)cl;
        }
        if ((iVar5 + *__ptr < box->X1) &&
           (iVar6 = box->X1 + iVar5, iVar4 = iVar6 - *__ptr,
           iVar7 = *(int *)((int)cl + 0x14) + *(int *)((int)cl + 0x10),
           SBORROW4(iVar4,iVar7 * 2) == iVar4 + iVar7 * -2 < 0)) {
          new = (BoxType *)malloc(0x10);
          pLVar2 = *(LocationType **)cl;
          new->Y1 = pLVar2[1];
          LVar1 = *pLVar2;
          new->Y2 = pLVar2[3];
          new->X1 = LVar1;
          new->X2 = iVar6;
          append((query_closure *)cl,new);
          __ptr = *(int **)cl;
        }
        if ((box->X2 < __ptr[2] - iVar5) &&
           (iVar5 = box->X2 - iVar5, iVar4 = *(int *)((int)cl + 0x14) + *(int *)((int)cl + 0x10),
           iVar6 = __ptr[2] - iVar5, SBORROW4(iVar6,iVar4 * 2) == iVar6 + iVar4 * -2 < 0)) {
          new = (BoxType *)malloc(0x10);
          iVar6 = *(int *)cl;
          LVar1 = *(LocationType *)(iVar6 + 4);
          new->X1 = iVar5;
          new->Y1 = LVar1;
          LVar1 = *(LocationType *)(iVar6 + 8);
          new->Y2 = *(LocationType *)(iVar6 + 0xc);
          new->X2 = LVar1;
          append((query_closure *)cl,new);
          __ptr = *(int **)cl;
        }
        heap = *(heap_t **)((int)cl + 8);
        if (heap == (heap_t *)0x0) {
          free(__ptr);
        }
        else {
          if ((*(char *)((int)cl + 0xb4) == '\0') && (*(int *)((int)cl + 0xc) != 0)) {
            heap_insert(heap,0.00000000,__ptr);
          }
          else {
            vector_append((vector_t *)heap,__ptr);
          }
        }
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x18,1);
      }
    }
  }
  return 0;
}



void mtsFreeWork(vetting_t **w)

{
  vetting_t *__ptr;
  int iVar1;
  vector_element_t __ptr_00;
  
  __ptr = *w;
  if (((__ptr->desired).X == -0xc8f75) && ((__ptr->desired).Y == -0xc8f75)) {
    while( true ) {
      iVar1 = vector_is_empty((vector_t *)__ptr->untested);
      if (iVar1 != 0) break;
      __ptr_00 = vector_remove_last((vector_t *)__ptr->untested);
      free(__ptr_00);
    }
    vector_destroy((vector_t **)__ptr);
    while( true ) {
      iVar1 = vector_is_empty((vector_t *)__ptr->no_fix);
      if (iVar1 != 0) break;
      __ptr_00 = vector_remove_last((vector_t *)__ptr->no_fix);
      free(__ptr_00);
    }
    vector_destroy((vector_t **)&__ptr->no_fix);
    while( true ) {
      iVar1 = vector_is_empty((vector_t *)__ptr->no_hi);
      if (iVar1 != 0) break;
      __ptr_00 = vector_remove_last((vector_t *)__ptr->no_hi);
      free(__ptr_00);
    }
    vector_destroy((vector_t **)&__ptr->no_hi);
    while( true ) {
      iVar1 = vector_is_empty((vector_t *)__ptr->hi_candidate);
      if (iVar1 != 0) break;
      __ptr_00 = vector_remove_last((vector_t *)__ptr->hi_candidate);
      free(__ptr_00);
    }
    vector_destroy((vector_t **)&__ptr->hi_candidate);
  }
  else {
    heap_free((heap_t *)__ptr->untested,free);
    heap_destroy((heap_t **)__ptr);
    heap_free((heap_t *)__ptr->no_fix,free);
    heap_destroy((heap_t **)&__ptr->no_fix);
    heap_free((heap_t *)__ptr->no_hi,free);
    heap_destroy((heap_t **)&__ptr->no_hi);
    heap_free((heap_t *)__ptr->hi_candidate,free);
    heap_destroy((heap_t **)&__ptr->hi_candidate);
  }
  free(__ptr);
  *w = (vetting_t *)0x0;
  return;
}



vetting_t *
mtspace_query_rect(mtspace_t *mtspace,BoxType *region,BDimension radius,BDimension keepaway,
                  vetting_t *work,vector_t *free_space_vec,vector_t *lo_conflict_space_vec,
                  vector_t *hi_conflict_space_vec,Boolean is_odd,Boolean with_conflicts,
                  CheapPointType *desired)

{
  int iVar1;
  int iVar2;
  LocationType LVar3;
  vetting_t *pvVar4;
  vetting_t *pvVar5;
  int *data;
  int iVar6;
  heap_t *phVar7;
  int iVar8;
  vector_t *pvVar9;
  rtree_t *tree;
  undefined4 local_f0;
  query_closure *local_e0;
  query_closure qc;
  
  if (region == (BoxType *)0x0) {
    qc.keepaway = work->keepaway;
    qc.radius = work->radius;
    if (((work->desired).X == -0xc8f75) && ((work->desired).Y == -0xc8f75)) {
      qc.desired = (CheapPointType *)0x0;
    }
    else {
      qc.desired = &work->desired;
    }
    do {
      local_e0 = &qc;
      qc.checking = work->untested;
      qc.touching = (vector_t *)0x0;
      qloop(local_e0,mtspace->ftree,'\0');
      qc.checking = work->no_fix;
      local_f0 = 0;
      if (with_conflicts != '\0') {
        local_f0 = work->hi_candidate;
      }
      if (is_odd == '\0') {
        tree = mtspace->etree;
      }
      else {
        tree = mtspace->otree;
      }
      qc.touch_is_vec = '\0';
      qc.touching = (vector_t *)local_f0;
      qloop(local_e0,tree,'\0');
      qc.checking = work->no_hi;
      qc.touching = (vector_t *)0x0;
      if (with_conflicts != '\0') {
        qc.touching = lo_conflict_space_vec;
      }
      if (is_odd == '\0') {
        tree = mtspace->otree;
      }
      else {
        tree = mtspace->etree;
      }
      qc.touch_is_vec = '\x01';
      qloop(local_e0,tree,'\x01');
      iVar8 = vector_is_empty(free_space_vec);
      if (iVar8 == 0) {
        if (qc.desired == (CheapPointType *)0x0) {
          iVar8 = vector_is_empty((vector_t *)work->untested);
        }
        else {
          iVar8 = heap_is_empty((heap_t *)work->untested);
        }
        if (iVar8 == 0) {
          return work;
        }
        break;
      }
      if (with_conflicts != '\0') {
        qc.checking = work->hi_candidate;
        if (is_odd == '\0') {
          tree = mtspace->otree;
        }
        else {
          tree = mtspace->etree;
        }
        qc.touching = (vector_t *)0x0;
        qloop(local_e0,tree,'\x01');
      }
      if (qc.desired == (CheapPointType *)0x0) {
        iVar8 = vector_is_empty((vector_t *)work->untested);
      }
      else {
        iVar8 = heap_is_empty((heap_t *)work->untested);
      }
    } while (iVar8 == 0);
    if (qc.desired == (CheapPointType *)0x0) {
      iVar8 = vector_is_empty((vector_t *)work->no_fix);
      if (iVar8 == 0) {
        return work;
      }
      iVar8 = vector_is_empty((vector_t *)work->no_hi);
      if (iVar8 == 0) {
        return work;
      }
      iVar8 = vector_is_empty((vector_t *)work->hi_candidate);
    }
    else {
      iVar8 = heap_is_empty((heap_t *)work->no_fix);
      if (iVar8 == 0) {
        return work;
      }
      iVar8 = heap_is_empty((heap_t *)work->no_hi);
      if (iVar8 == 0) {
        return work;
      }
      iVar8 = heap_is_empty((heap_t *)work->hi_candidate);
    }
    if (iVar8 == 0) {
      return work;
    }
    mtsFreeWork(&work);
    work = (vetting_t *)0x0;
  }
  else {
    work = (vetting_t *)malloc(0x20);
    work->keepaway = keepaway;
    work->radius = radius;
    data = (int *)malloc(0x10);
    pvVar4 = work;
    iVar8 = region->Y1;
    iVar6 = keepaway + radius;
    iVar1 = region->X2;
    data[3] = region->Y2 + iVar6;
    iVar2 = region->X1;
    data[1] = iVar8 + -iVar6;
    data[2] = iVar1 + iVar6;
    *data = -iVar6 + iVar2;
    if (desired == (CheapPointType *)0x0) {
      pvVar9 = vector_create();
      pvVar5 = work;
      *(vector_t **)&pvVar4->untested = pvVar9;
      pvVar9 = vector_create();
      pvVar4 = work;
      *(vector_t **)&pvVar5->no_fix = pvVar9;
      pvVar9 = vector_create();
      pvVar5 = work;
      *(vector_t **)&pvVar4->hi_candidate = pvVar9;
      pvVar9 = vector_create();
      *(vector_t **)&pvVar5->no_hi = pvVar9;
      vector_append((vector_t *)work->untested,data);
      (work->desired).Y = -0xc8f75;
      (work->desired).X = -0xc8f75;
      return work;
    }
    phVar7 = heap_create();
    pvVar5 = work;
    *(heap_t **)&pvVar4->untested = phVar7;
    phVar7 = heap_create();
    pvVar4 = work;
    *(heap_t **)&pvVar5->no_fix = phVar7;
    phVar7 = heap_create();
    pvVar5 = work;
    *(heap_t **)&pvVar4->hi_candidate = phVar7;
    phVar7 = heap_create();
    *(heap_t **)&pvVar5->no_hi = phVar7;
    heap_insert((heap_t *)work->untested,0.00000000,data);
    LVar3 = desired->Y;
    (work->desired).X = desired->X;
    (work->desired).Y = LVar3;
  }
  return work;
}



int mts_remove_one(BoxType *b,void *cl)

{
  if ((((b->X1 == *(int *)((int)cl + 4)) && (b->X2 == *(int *)((int)cl + 0xc))) &&
      (b->Y1 == *(int *)((int)cl + 8))) &&
     ((b->Y2 == *(int *)((int)cl + 0x10) && (b[1].X1 == *(int *)cl)))) {
    r_delete_entry(*(rtree_t **)((int)cl + 0x14),b);
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x18,1);
  }
  return 0;
}



void mtspace_add(mtspace_t *mtspace,BoxType *box,mtspace_type_t which,BDimension keepaway)

{
  mtspacebox_t *which_00;
  rtree_t *rtree;
  
  which_00 = mtspace_create_box(box,keepaway);
  if (which == FIXED) {
    rtree = mtspace->ftree;
  }
  else {
    if (which == EVEN) {
      rtree = mtspace->etree;
    }
    else {
      rtree = mtspace->otree;
    }
  }
  r_insert_entry(rtree,(BoxType *)which_00,1);
  return;
}



void mtspace_destroy(mtspace_t **mtspacep)

{
  r_destroy_tree((rtree_t **)*mtspacep);
  r_destroy_tree(&(*mtspacep)->etree);
  r_destroy_tree(&(*mtspacep)->otree);
  free(*mtspacep);
  *mtspacep = (mtspace_t *)0x0;
  return;
}



mtspace_t * mtspace_create(void)

{
  mtspace_t *pmVar1;
  rtree_t *prVar2;
  
  pmVar1 = (mtspace_t *)malloc(0xc);
  prVar2 = r_create_tree((BoxType **)0x0,0,0);
  pmVar1->ftree = prVar2;
  prVar2 = r_create_tree((BoxType **)0x0,0,0);
  pmVar1->etree = prVar2;
  prVar2 = r_create_tree((BoxType **)0x0,0,0);
  pmVar1->otree = prVar2;
  return pmVar1;
}



void DSClearString(DynamicStringTypePtr_conflict *Ptr)

{
  if (Ptr->Data != (char *)0x0) {
    *Ptr->Data = '\0';
  }
  return;
}



void SaveFree(void *Ptr)

{
  if (Ptr != (void *)0x0) {
    free(Ptr);
    return;
  }
  return;
}



void __regparm3 FreeAttributeListMemory(AttributeListTypePtr list)

{
  int iVar1;
  int iVar2;
  
  if (0 < list->Number) {
    iVar1 = 0;
    do {
      iVar2 = iVar1 + 1;
      SaveFree(list->List[iVar1].name);
      SaveFree(list->List[iVar1].value);
      iVar1 = iVar2;
    } while (list->Number != iVar2 && iVar2 <= list->Number);
  }
  SaveFree(list->List);
  list->List = (AttributeType *)0x0;
  list->Max = 0;
  return;
}



void FreeLibraryMemory(LibraryTypePtr lib)

{
  void *pvVar1;
  void **ppvVar2;
  int iVar3;
  undefined *puVar4;
  int local_28;
  int local_24;
  
  local_24 = lib->MenuN - 1;
  if (local_24 != -1) {
    iVar3 = lib->MenuN * 0x1c;
    do {
      local_28 = iVar3 + -0x1c;
      ppvVar2 = (void **)((int)&lib->Menu[-1].Name + iVar3);
      iVar3 = (int)ppvVar2[3] + -1;
      if (iVar3 != -1) {
        puVar4 = (undefined *)((int)ppvVar2[3] * 0x18);
        do {
          puVar4 = &DAT_ffffffe8 + (int)puVar4;
          iVar3 = iVar3 + -1;
          pvVar1 = ppvVar2[5];
          SaveFree(*(void **)(puVar4 + (int)pvVar1 + 1));
          SaveFree(*(void **)(puVar4 + (int)pvVar1));
        } while (iVar3 != -1);
      }
      SaveFree(ppvVar2[5]);
      SaveFree(*ppvVar2);
      local_24 = local_24 + -1;
      iVar3 = local_28;
    } while (local_24 != -1);
  }
  SaveFree(lib->Menu);
  lib->MenuN = 0;
  lib->MenuMax = 0;
  lib->Menu = (LibraryMenuTypePtr *)0x0;
  return;
}



void FreeElementMemory(ElementTypePtr *Element)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  PinTypePtr *pPVar5;
  byte bVar6;
  uint local_20;
  
  bVar6 = 0;
  if (Element != (ElementTypePtr *)0x0) {
    SaveFree(Element->Name[2].TextString);
    SaveFree(Element->Name[1].TextString);
    SaveFree(Element->Name[0].TextString);
    if (Element->PinN != 0) {
      uVar3 = 0;
      local_20 = Element->PinN;
      do {
        pPVar5 = Element->Pin + uVar3;
        SaveFree(pPVar5->Name);
        pPVar5->Name = (char *)0x0;
        SaveFree(pPVar5->Number);
        uVar1 = Element->PinN;
        pPVar5->Number = (char *)0x0;
        if (uVar1 == 0) break;
        uVar3 = (uVar1 + 1 + uVar3) - local_20;
        local_20 = uVar1;
      } while (uVar3 < uVar1);
    }
    uVar3 = Element->PadN;
    uVar4 = 0;
    local_20 = 0;
    uVar1 = uVar3;
    while ((uVar1 != 0 && (uVar4 < uVar1))) {
      iVar2 = (int)&(Element->Pad->BoundingBox).X1 + local_20;
      SaveFree(*(void **)(iVar2 + 0x58));
      *(undefined4 *)(iVar2 + 0x58) = 0;
      SaveFree(*(void **)(iVar2 + 0x5c));
      uVar1 = Element->PadN;
      *(undefined4 *)(iVar2 + 0x5c) = 0;
      if (uVar1 == uVar3) {
        uVar4 = uVar4 + 1;
        local_20 = local_20 + 0x68;
        uVar1 = uVar3;
      }
    }
    SaveFree(Element->Pin);
    Element->Pin = (PinTypePtr *)0x0;
    SaveFree(Element->Pad);
    Element->Pad = (PadTypePtr *)0x0;
    SaveFree(Element->Line);
    Element->Line = (LineTypePtr)0x0;
    SaveFree(Element->Arc);
    Element->Arc = (ArcTypePtr *)0x0;
    FreeAttributeListMemory((AttributeListTypePtr)&Element->Attributes);
    iVar2 = 0x4b;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (Element->BoundingBox).X1 = 0;
      Element = (ElementTypePtr *)((int)Element + (uint)bVar6 * -8 + 4);
    }
  }
  return;
}



void FreeNetMemory(NetTypePtr *Net)

{
  if (Net != (NetTypePtr *)0x0) {
    SaveFree(Net->Connection);
    Net->ConnectionN = 0;
    Net->ConnectionMax = 0;
    Net->Connection = (ConnectionTypePtr *)0x0;
    Net->Style = (RouteStyleTypePtr)0x0;
  }
  return;
}



void FreeNetListMemory(NetListTypePtr *Netlist)

{
  NetTypePtr *Net;
  int iVar1;
  int iVar2;
  
  if (Netlist != (NetListTypePtr *)0x0) {
    iVar2 = Netlist->NetN - 1;
    if (iVar2 != -1) {
      iVar1 = (Netlist->NetN + 0xfffffff) * 0x10;
      do {
        iVar2 = iVar2 + -1;
        Net = (NetTypePtr *)((int)&Netlist->Net->ConnectionN + iVar1);
        iVar1 = iVar1 + -0x10;
        FreeNetMemory(Net);
      } while (iVar2 != -1);
    }
    SaveFree(Netlist->Net);
    Netlist->NetN = 0;
    Netlist->NetMax = 0;
    Netlist->Net = (NetTypePtr *)0x0;
  }
  return;
}



void FreeNetListListMemory(NetListListTypePtr *Netlistlist)

{
  int iVar1;
  undefined *puVar2;
  
  if (Netlistlist != (NetListListTypePtr *)0x0) {
    iVar1 = Netlistlist->NetListN - 1;
    if (iVar1 != -1) {
      puVar2 = (undefined *)(Netlistlist->NetListN * 0xc);
      do {
        puVar2 = &DAT_fffffff4 + (int)puVar2;
        iVar1 = iVar1 + -1;
        FreeNetListMemory((NetListTypePtr *)((int)&Netlistlist->NetList->NetN + (int)puVar2));
      } while (iVar1 != -1);
    }
    SaveFree(Netlistlist->NetList);
    Netlistlist->NetListN = 0;
    Netlistlist->NetListMax = 0;
    Netlistlist->NetList = (NetListTypePtr *)0x0;
  }
  return;
}



void FreeBoxListMemory(BoxListTypePtr_conflict *Boxlist)

{
  if (Boxlist != (BoxListTypePtr_conflict *)0x0) {
    SaveFree(Boxlist->Box);
    Boxlist->BoxN = 0;
    Boxlist->BoxMax = 0;
    Boxlist->Box = (BoxTypePtr)0x0;
  }
  return;
}



void FreePointerListMemory(PointerListTypePtr_conflict *list)

{
  SaveFree(list->Ptr);
  list->PtrN = 0;
  list->PtrMax = 0;
  list->Ptr = (void **)0x0;
  return;
}



void FreePolygonMemory(PolygonTypePtr Polygon)

{
  int iVar1;
  byte bVar2;
  
  bVar2 = 0;
  if (Polygon != (PolygonTypePtr)0x0) {
    SaveFree(Polygon->Points);
    Polygon->Points = (PointTypePtr)0x0;
    if (Polygon->Clipped != (POLYAREA *)0x0) {
      poly_Free(&Polygon->Clipped);
    }
    poly_FreeContours(&Polygon->NoHoles);
    iVar1 = 0xf;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      (Polygon->BoundingBox).X1 = 0;
      Polygon = (PolygonTypePtr)((int)Polygon + (uint)bVar2 * -8 + 4);
    }
  }
  return;
}



void FreeDataMemory(DataTypePtr *Data)

{
  PinTypePtr *pPVar1;
  uint uVar2;
  void *Ptr;
  void *Ptr_00;
  uint uVar3;
  int iVar4;
  void **ppvVar5;
  undefined *puVar6;
  int iVar7;
  byte bVar8;
  int local_24;
  uint local_20;
  
  bVar8 = 0;
  if (Data == (DataTypePtr *)0x0) {
    __fprintf_chk(stderr,1,"Warning:  Tried to FreeDataMemory(null)\n");
  }
  else {
    if (Data->ViaN != 0) {
      uVar3 = 0;
      local_20 = Data->ViaN;
      do {
        pPVar1 = Data->Via;
        SaveFree(pPVar1[uVar3].Name);
        uVar2 = Data->ViaN;
        pPVar1[uVar3].Name = (char *)0x0;
        if (uVar2 == 0) break;
        uVar3 = (uVar2 + 1 + uVar3) - local_20;
        local_20 = uVar2;
      } while (uVar3 < uVar2);
    }
    iVar4 = Data->ElementN - 1;
    if (iVar4 != -1) {
      iVar7 = Data->ElementN * 300;
      do {
        iVar4 = iVar4 + -1;
        FreeElementMemory((ElementTypePtr *)((int)&Data->Element[-1].BoundingBox.X1 + iVar7));
        iVar7 = iVar7 + -300;
      } while (iVar4 != -1);
    }
    local_24 = 0;
    ppvVar5 = (void **)&Data->field_0x4c;
    while( true ) {
      FreeAttributeListMemory((AttributeListTypePtr)(ppvVar5 + 0x14));
      iVar4 = (int)ppvVar5[2] + -1;
      if (iVar4 != -1) {
        puVar6 = (undefined *)((int)ppvVar5[2] * 0x3c);
        do {
          puVar6 = &DAT_ffffffc4 + (int)puVar6;
          iVar4 = iVar4 + -1;
          Ptr_00 = ppvVar5[10];
          SaveFree(*(void **)(puVar6 + (int)Ptr_00 + 0x34));
          *(undefined4 *)(puVar6 + (int)Ptr_00 + 0x34) = 0;
        } while (iVar4 != -1);
      }
      if (*ppvVar5 != (void *)0x0) {
        SaveFree(*ppvVar5);
        *ppvVar5 = (void *)0x0;
      }
      iVar4 = (int)ppvVar5[1] + -1;
      if (iVar4 == -1) {
        Ptr_00 = ppvVar5[9];
      }
      else {
        iVar7 = (int)ppvVar5[1] * 0x58;
        Ptr_00 = ppvVar5[9];
        do {
          iVar7 = iVar7 + -0x58;
          Ptr = *(void **)((int)Ptr_00 + iVar7 + 0x54);
          if (Ptr != (void *)0x0) {
            SaveFree(Ptr);
            *(undefined4 *)((int)Ptr_00 + iVar7 + 0x54) = 0;
            Ptr_00 = ppvVar5[9];
          }
          iVar4 = iVar4 + -1;
        } while (iVar4 != -1);
      }
      SaveFree(Ptr_00);
      ppvVar5[9] = (void *)0x0;
      SaveFree(ppvVar5[0xc]);
      ppvVar5[0xc] = (void *)0x0;
      SaveFree(ppvVar5[10]);
      ppvVar5[10] = (void *)0x0;
      iVar4 = (int)ppvVar5[3] + -1;
      if (iVar4 != -1) {
        puVar6 = (undefined *)((int)ppvVar5[3] * 0x3c);
        do {
          puVar6 = &DAT_ffffffc4 + (int)puVar6;
          iVar4 = iVar4 + -1;
          FreePolygonMemory((PolygonTypePtr)((int)ppvVar5[0xb] + (int)puVar6));
        } while (iVar4 != -1);
      }
      SaveFree(ppvVar5[0xb]);
      ppvVar5[0xb] = (void *)0x0;
      if (ppvVar5[0xd] != (void *)0x0) {
        r_destroy_tree((rtree_t **)(ppvVar5 + 0xd));
      }
      if (ppvVar5[0x10] != (void *)0x0) {
        r_destroy_tree((rtree_t **)(ppvVar5 + 0x10));
      }
      if (ppvVar5[0xe] != (void *)0x0) {
        r_destroy_tree((rtree_t **)(ppvVar5 + 0xe));
      }
      if (ppvVar5[0xf] != (void *)0x0) {
        r_destroy_tree((rtree_t **)(ppvVar5 + 0xf));
      }
      local_24 = local_24 + 1;
      if (local_24 == 0x12) break;
      ppvVar5 = ppvVar5 + 0x17;
    }
    if (Data->element_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->element_tree);
    }
    if (Data->name_tree[0] != (rtree_t *)0x0) {
      r_destroy_tree(Data->name_tree);
    }
    if (Data->name_tree[1] != (rtree_t *)0x0) {
      r_destroy_tree(Data->name_tree + 1);
    }
    if (Data->name_tree[2] != (rtree_t *)0x0) {
      r_destroy_tree(Data->name_tree + 2);
    }
    if (Data->via_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->via_tree);
    }
    if (Data->pin_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->pin_tree);
    }
    if (Data->pad_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->pad_tree);
    }
    if (Data->rat_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->rat_tree);
    }
    iVar4 = 0x1b1;
    while (iVar4 != 0) {
      iVar4 = iVar4 + -1;
      Data->ViaN = 0;
      Data = (DataTypePtr *)((int)Data + (uint)bVar8 * -8 + 4);
    }
  }
  return;
}



void FreePCBMemory(PCBTypePtr PCBPtr)

{
  DataTypePtr *Ptr;
  int iVar1;
  
  if (PCBPtr != (PCBTypePtr)0x0) {
    SaveFree(PCBPtr->Name);
    PCBPtr->Name = (char *)0x0;
    SaveFree(PCBPtr->Filename);
    PCBPtr->Filename = (char *)0x0;
    SaveFree(PCBPtr->PrintFilename);
    Ptr = (DataTypePtr *)0x0;
    PCBPtr->PrintFilename = (char *)0x0;
    if (PCBPtr->Data != (DataTypePtr *)0x0) {
      FreeDataMemory(PCBPtr->Data);
      Ptr = PCBPtr->Data;
    }
    iVar1 = 0;
    SaveFree(Ptr);
    PCBPtr->Data = (DataTypePtr *)0x0;
    do {
      SaveFree(*(void **)((int)&(PCBPtr->Font).Symbol[0].Line + iVar1));
      *(undefined4 *)((int)&(PCBPtr->Font).Symbol[0].Line + iVar1) = 0;
      iVar1 = iVar1 + 0x1c;
    } while (iVar1 != 0x1c00);
    FreeLibraryMemory((LibraryTypePtr)&PCBPtr->NetlistLib);
    FreeAttributeListMemory((AttributeListTypePtr)&PCBPtr->Attributes);
    memset(PCBPtr,0,0x2210);
    return;
  }
  __fprintf_chk(stderr,1,"Warning:  Tried to FreePCBMemory(null)\n");
  return;
}



char * MyStrdup(char *S,char *Text)

{
  char *pcVar1;
  
  pcVar1 = (char *)0x0;
  if (S != (char *)0x0) {
    pcVar1 = (char *)__strdup(S);
    if (pcVar1 == (char *)0x0) {
      if (Text == (char *)0x0) {
        Text = "(unknown)";
      }
      MyFatal("out of memory during g_strdup() in \'%s\'\n",Text);
      return (char *)0x0;
    }
  }
  return pcVar1;
}



void * MyRealloc(void *Ptr,size_t Size,char *Text)

{
  void *pvVar1;
  
  if (Size == 0) {
    Size = 1;
  }
  if (Ptr == (void *)0x0) {
    pvVar1 = calloc(1,Size);
  }
  else {
    pvVar1 = realloc(Ptr,Size);
  }
  if (pvVar1 != (void *)0x0) {
    return pvVar1;
  }
  if (Text == (char *)0x0) {
    Text = "(unknown)";
  }
  MyFatal("out of memory during realloc() in \'%s\'()\n",Text);
  return (void *)0x0;
}



char * StripWhiteSpaceAndDup(char *S)

{
  ushort *puVar1;
  ushort **ppuVar2;
  size_t __n;
  char *__dest;
  char cVar3;
  
  if ((S != (char *)0x0) && (cVar3 = *S, cVar3 != '\0')) {
    ppuVar2 = __ctype_b_loc();
    puVar1 = *ppuVar2;
    do {
      if ((*(byte *)((int)puVar1 + (int)cVar3 * 2 + 1) & 0x20) == 0) break;
      S = S + 1;
      cVar3 = *S;
    } while (cVar3 != '\0');
    __n = strlen(S);
    __dest = S + (__n - 1);
    if (__n != 0) {
      while( true ) {
        if ((*(byte *)((int)puVar1 + (int)*__dest * 2 + 1) & 0x20) == 0) {
          __dest = (char *)MyRealloc((void *)0x0,__n + 1,"StripWhiteSpace()");
          strncpy(__dest,S,__n);
          __dest[__n] = '\0';
          return __dest;
        }
        __n = __n - 1;
        if (__n == 0) break;
        __dest = __dest + -1;
      }
    }
  }
  return (char *)0x0;
}



void DSAddString(DynamicStringTypePtr_conflict *Ptr,char *S)

{
  uint uVar1;
  size_t sVar2;
  char *pcVar3;
  size_t sVar4;
  char *local_20;
  
  sVar4 = 0;
  local_20 = Ptr->Data;
  if (local_20 != (char *)0x0) {
    sVar4 = strlen(local_20);
  }
  if ((S != (char *)0x0) && (*S != '\0')) {
    sVar2 = strlen(S);
    uVar1 = sVar4 + 1 + sVar2;
    if (local_20 == (char *)0x0) {
      Ptr->MaxLength = uVar1 + 0x200;
      pcVar3 = (char *)MyRealloc((void *)0x0,uVar1 + 0x200,"ReallocDS()");
      Ptr->Data = pcVar3;
      *pcVar3 = '\0';
      local_20 = Ptr->Data;
    }
    else {
      if (Ptr->MaxLength <= uVar1) {
        Ptr->MaxLength = uVar1 + 0x200;
        local_20 = (char *)MyRealloc(local_20,uVar1 + 0x200,"ReallocDS()");
        Ptr->Data = local_20;
      }
    }
    strcat(local_20 + sVar4,S);
    return;
  }
  return;
}



void DSAddCharacter(DynamicStringTypePtr_conflict *Ptr,char Char)

{
  size_t sVar1;
  uint uVar2;
  char *__s;
  
  __s = Ptr->Data;
  if (__s == (char *)0x0) {
    Ptr->MaxLength = 0x201;
    sVar1 = 0;
    __s = (char *)MyRealloc((void *)0x0,0x201,"ReallocDS()");
    uVar2 = 1;
    Ptr->Data = __s;
    *__s = '\0';
    __s = Ptr->Data;
  }
  else {
    sVar1 = strlen(__s);
    uVar2 = sVar1 + 1;
    if (Ptr->MaxLength <= uVar2) {
      Ptr->MaxLength = sVar1 + 0x201;
      __s = (char *)MyRealloc(__s,sVar1 + 0x201,"ReallocDS()");
      Ptr->Data = __s;
    }
  }
  __s[sVar1] = Char;
  Ptr->Data[uVar2] = '\0';
  return;
}



DrillTypePtr_conflict * GetDrillInfoDrillMemory(DrillInfoTypePtr *DrillInfo)

{
  Cardinal CVar1;
  uint uVar2;
  DrillTypePtr Ptr;
  uint uVar3;
  DrillTypePtr pDVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = DrillInfo->DrillN;
  Ptr = DrillInfo->Drill;
  if (DrillInfo->DrillMax <= uVar3) {
    CVar1 = DrillInfo->DrillMax + 0x1e;
    uVar3 = 0x4b0;
    DrillInfo->DrillMax = CVar1;
    Ptr = (DrillTypePtr)MyRealloc(Ptr,CVar1 * 0x28,"GetDrillInfoDrillMemory()");
    DrillInfo->Drill = Ptr;
    pDVar4 = Ptr + DrillInfo->DrillN;
    bVar5 = ((uint)pDVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&pDVar4->DrillSize = 0;
      uVar3 = 0x4af;
      pDVar4 = (DrillTypePtr)((int)&pDVar4->DrillSize + 1);
    }
    if (((uint)pDVar4 & 2) != 0) {
      *(undefined2 *)&pDVar4->DrillSize = 0;
      uVar3 = uVar3 - 2;
      pDVar4 = (DrillTypePtr)((int)&pDVar4->DrillSize + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pDVar4->DrillSize = 0;
      pDVar4 = (DrillTypePtr)((int)pDVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pDVar4->DrillSize = 0;
      pDVar4 = (DrillTypePtr)((int)&pDVar4->DrillSize + 2);
    }
    if (bVar5) {
      *(undefined *)&pDVar4->DrillSize = 0;
      uVar3 = DrillInfo->DrillN;
    }
    else {
      uVar3 = DrillInfo->DrillN;
    }
  }
  DrillInfo->DrillN = uVar3 + 1;
  return (DrillTypePtr_conflict *)(Ptr + uVar3);
}



PinTypeHandle ** GetDrillPinMemory(DrillTypePtr_conflict *Drill)

{
  Cardinal CVar1;
  uint uVar2;
  PinTypePtr *Ptr;
  uint uVar3;
  LocationType *pLVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Drill->PinN;
  Ptr = (PinTypePtr *)Drill->Pin;
  if (Drill->PinMax <= uVar3) {
    CVar1 = Drill->PinMax + 100;
    uVar3 = 400;
    Drill->PinMax = CVar1;
    Ptr = (PinTypePtr *)MyRealloc(Ptr,CVar1 * 4,"GetDrillPinMemory()");
    *(PinTypePtr **)&Drill->Pin = Ptr;
    pLVar4 = &(Ptr->BoundingBox).X1 + Drill->PinN;
    bVar5 = ((uint)pLVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)pLVar4 = 0;
      uVar3 = 399;
      pLVar4 = (LocationType *)((int)pLVar4 + 1);
    }
    if (((uint)pLVar4 & 2) != 0) {
      *(undefined2 *)pLVar4 = 0;
      uVar3 = uVar3 - 2;
      pLVar4 = (LocationType *)((int)pLVar4 + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      *pLVar4 = 0;
      pLVar4 = pLVar4 + (uint)bVar6 * 0x3ffffffe + 1;
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)pLVar4 = 0;
      pLVar4 = (LocationType *)((int)pLVar4 + 2);
    }
    if (bVar5) {
      *(undefined *)pLVar4 = 0;
      uVar3 = Drill->PinN;
    }
    else {
      uVar3 = Drill->PinN;
    }
  }
  Drill->PinN = uVar3 + 1;
  return (PinTypeHandle **)((int)&Ptr->BoundingBox + uVar3 * 4);
}



ElementTypeHandle ** GetDrillElementMemory(DrillTypePtr_conflict *Drill)

{
  Cardinal CVar1;
  uint uVar2;
  ElementTypePtr *Ptr;
  uint uVar3;
  LocationType *pLVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Drill->ElementN;
  Ptr = (ElementTypePtr *)Drill->Element;
  if (Drill->ElementMax <= uVar3) {
    CVar1 = Drill->ElementMax + 0x32;
    uVar3 = 200;
    Drill->ElementMax = CVar1;
    Ptr = (ElementTypePtr *)MyRealloc(Ptr,CVar1 * 4,"GetDrillElementMemory()");
    *(ElementTypePtr **)&Drill->Element = Ptr;
    pLVar4 = &(Ptr->BoundingBox).X1 + Drill->ElementN;
    bVar5 = ((uint)pLVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)pLVar4 = 0;
      uVar3 = 199;
      pLVar4 = (LocationType *)((int)pLVar4 + 1);
    }
    if (((uint)pLVar4 & 2) != 0) {
      *(undefined2 *)pLVar4 = 0;
      uVar3 = uVar3 - 2;
      pLVar4 = (LocationType *)((int)pLVar4 + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      *pLVar4 = 0;
      pLVar4 = pLVar4 + (uint)bVar6 * 0x3ffffffe + 1;
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)pLVar4 = 0;
      pLVar4 = (LocationType *)((int)pLVar4 + 2);
    }
    if (bVar5) {
      *(undefined *)pLVar4 = 0;
      uVar3 = Drill->ElementN;
    }
    else {
      uVar3 = Drill->ElementN;
    }
  }
  Drill->ElementN = uVar3 + 1;
  return (ElementTypeHandle **)((int)&Ptr->BoundingBox + uVar3 * 4);
}



LibraryEntryTypePtr * GetLibraryEntryMemory(LibraryMenuTypePtr *Menu)

{
  Cardinal CVar1;
  uint uVar2;
  LibraryEntryTypePtr *Ptr;
  uint uVar3;
  LibraryEntryTypePtr *pLVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Menu->EntryN;
  Ptr = Menu->Entry;
  if (Menu->EntryMax <= uVar3) {
    CVar1 = Menu->EntryMax + 0x14;
    uVar3 = 0x1e0;
    Menu->EntryMax = CVar1;
    Ptr = (LibraryEntryTypePtr *)MyRealloc(Ptr,CVar1 * 0x18,"GetLibraryEntryMemory()");
    Menu->Entry = Ptr;
    pLVar4 = Ptr + Menu->EntryN;
    bVar5 = ((uint)pLVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&pLVar4->ListEntry = 0;
      uVar3 = 0x1df;
      pLVar4 = (LibraryEntryTypePtr *)((int)&pLVar4->ListEntry + 1);
    }
    if (((uint)pLVar4 & 2) != 0) {
      *(undefined2 *)&pLVar4->ListEntry = 0;
      uVar3 = uVar3 - 2;
      pLVar4 = (LibraryEntryTypePtr *)((int)&pLVar4->ListEntry + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pLVar4->ListEntry = (char *)0x0;
      pLVar4 = (LibraryEntryTypePtr *)((int)pLVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pLVar4->ListEntry = 0;
      pLVar4 = (LibraryEntryTypePtr *)((int)&pLVar4->ListEntry + 2);
    }
    if (bVar5) {
      *(undefined *)&pLVar4->ListEntry = 0;
      uVar3 = Menu->EntryN;
    }
    else {
      uVar3 = Menu->EntryN;
    }
  }
  Menu->EntryN = uVar3 + 1;
  return Ptr + uVar3;
}



LibraryMenuTypePtr * GetLibraryMenuMemory(LibraryTypePtr lib)

{
  Cardinal CVar1;
  uint uVar2;
  LibraryMenuTypePtr *Ptr;
  uint uVar3;
  LibraryMenuTypePtr *pLVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = lib->MenuN;
  Ptr = lib->Menu;
  if (lib->MenuMax <= uVar3) {
    CVar1 = lib->MenuMax + 10;
    uVar3 = 0x118;
    lib->MenuMax = CVar1;
    Ptr = (LibraryMenuTypePtr *)MyRealloc(Ptr,CVar1 * 0x1c,"GetLibraryMenuMemory()");
    pLVar4 = Ptr + lib->MenuN;
    bVar5 = ((uint)pLVar4 & 1) != 0;
    lib->Menu = Ptr;
    if (bVar5) {
      *(undefined *)&pLVar4->Name = 0;
      uVar3 = 0x117;
      pLVar4 = (LibraryMenuTypePtr *)((int)&pLVar4->Name + 1);
    }
    if (((uint)pLVar4 & 2) != 0) {
      *(undefined2 *)&pLVar4->Name = 0;
      uVar3 = uVar3 - 2;
      pLVar4 = (LibraryMenuTypePtr *)((int)&pLVar4->Name + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pLVar4->Name = (char *)0x0;
      pLVar4 = (LibraryMenuTypePtr *)((int)pLVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pLVar4->Name = 0;
      pLVar4 = (LibraryMenuTypePtr *)((int)&pLVar4->Name + 2);
    }
    if (bVar5) {
      *(undefined *)&pLVar4->Name = 0;
      uVar3 = lib->MenuN;
    }
    else {
      uVar3 = lib->MenuN;
    }
  }
  lib->MenuN = uVar3 + 1;
  return Ptr + uVar3;
}



PointTypePtr GetPointMemoryInPolygon(PolygonTypePtr Polygon)

{
  Cardinal CVar1;
  uint uVar2;
  PointTypePtr Ptr;
  uint uVar3;
  PointTypePtr pPVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Polygon->PointN;
  Ptr = Polygon->Points;
  if (Polygon->PointMax <= uVar3) {
    CVar1 = Polygon->PointMax + 10;
    uVar3 = 200;
    Polygon->PointMax = CVar1;
    Ptr = (PointTypePtr)MyRealloc(Ptr,CVar1 * 0x14,"GetPointMemoryInPolygon()");
    Polygon->Points = Ptr;
    pPVar4 = Ptr + Polygon->PointN;
    bVar5 = ((uint)pPVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&pPVar4->X = 0;
      uVar3 = 199;
      pPVar4 = (PointTypePtr)((int)&pPVar4->X + 1);
    }
    if (((uint)pPVar4 & 2) != 0) {
      *(undefined2 *)&pPVar4->X = 0;
      uVar3 = uVar3 - 2;
      pPVar4 = (PointTypePtr)((int)&pPVar4->X + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pPVar4->X = 0;
      pPVar4 = (PointTypePtr)((int)pPVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pPVar4->X = 0;
      pPVar4 = (PointTypePtr)((int)&pPVar4->X + 2);
    }
    if (bVar5) {
      *(undefined *)&pPVar4->X = 0;
      uVar3 = Polygon->PointN;
    }
    else {
      uVar3 = Polygon->PointN;
    }
  }
  Polygon->PointN = uVar3 + 1;
  return Ptr + uVar3;
}



NetListTypePtr * GetNetListMemory(NetListListTypePtr *Netlistlist)

{
  Cardinal CVar1;
  uint uVar2;
  NetListTypePtr *Ptr;
  uint uVar3;
  NetListTypePtr *pNVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Netlistlist->NetListN;
  Ptr = Netlistlist->NetList;
  if (Netlistlist->NetListMax <= uVar3) {
    CVar1 = Netlistlist->NetListMax + 100;
    uVar3 = 0x4b0;
    Netlistlist->NetListMax = CVar1;
    Ptr = (NetListTypePtr *)MyRealloc(Ptr,CVar1 * 0xc,"GetNetListMemory()");
    Netlistlist->NetList = Ptr;
    pNVar4 = Ptr + Netlistlist->NetListN;
    bVar5 = ((uint)pNVar4 & 1) != 0;
    if (bVar5) {
      *(undefined *)&pNVar4->NetN = 0;
      uVar3 = 0x4af;
      pNVar4 = (NetListTypePtr *)((int)&pNVar4->NetN + 1);
    }
    if (((uint)pNVar4 & 2) != 0) {
      *(undefined2 *)&pNVar4->NetN = 0;
      uVar3 = uVar3 - 2;
      pNVar4 = (NetListTypePtr *)((int)&pNVar4->NetN + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pNVar4->NetN = 0;
      pNVar4 = (NetListTypePtr *)((int)pNVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pNVar4->NetN = 0;
      pNVar4 = (NetListTypePtr *)((int)&pNVar4->NetN + 2);
    }
    if (bVar5) {
      *(undefined *)&pNVar4->NetN = 0;
      uVar3 = Netlistlist->NetListN;
    }
    else {
      uVar3 = Netlistlist->NetListN;
    }
  }
  Netlistlist->NetListN = uVar3 + 1;
  return Ptr + uVar3;
}



NetTypePtr * GetNetMemory(NetListTypePtr *Netlist)

{
  Cardinal CVar1;
  uint uVar2;
  NetTypePtr *Ptr;
  uint uVar3;
  NetTypePtr *pNVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Netlist->NetN;
  Ptr = Netlist->Net;
  if (Netlist->NetMax <= uVar3) {
    CVar1 = Netlist->NetMax + 100;
    uVar3 = 0x640;
    Netlist->NetMax = CVar1;
    Ptr = (NetTypePtr *)MyRealloc(Ptr,CVar1 * 0x10,"GetNetMemory()");
    pNVar4 = Ptr + Netlist->NetN;
    bVar5 = ((uint)pNVar4 & 1) != 0;
    Netlist->Net = Ptr;
    if (bVar5) {
      *(undefined *)&pNVar4->ConnectionN = 0;
      uVar3 = 0x63f;
      pNVar4 = (NetTypePtr *)((int)&pNVar4->ConnectionN + 1);
    }
    if (((uint)pNVar4 & 2) != 0) {
      *(undefined2 *)&pNVar4->ConnectionN = 0;
      uVar3 = uVar3 - 2;
      pNVar4 = (NetTypePtr *)((int)&pNVar4->ConnectionN + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pNVar4->ConnectionN = 0;
      pNVar4 = (NetTypePtr *)((int)pNVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pNVar4->ConnectionN = 0;
      pNVar4 = (NetTypePtr *)((int)&pNVar4->ConnectionN + 2);
    }
    if (bVar5) {
      *(undefined *)&pNVar4->ConnectionN = 0;
      uVar3 = Netlist->NetN;
    }
    else {
      uVar3 = Netlist->NetN;
    }
  }
  Netlist->NetN = uVar3 + 1;
  return Ptr + uVar3;
}



ConnectionTypePtr * GetConnectionMemory(NetTypePtr *Net)

{
  Cardinal CVar1;
  uint uVar2;
  ConnectionTypePtr *Ptr;
  uint uVar3;
  ConnectionTypePtr *pCVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  uVar3 = Net->ConnectionN;
  Ptr = Net->Connection;
  if (Net->ConnectionMax <= uVar3) {
    CVar1 = Net->ConnectionMax + 100;
    uVar3 = 0xaf0;
    Net->ConnectionMax = CVar1;
    Ptr = (ConnectionTypePtr *)MyRealloc(Ptr,CVar1 * 0x1c,"GetConnectionMemory()");
    pCVar4 = Ptr + Net->ConnectionN;
    bVar5 = ((uint)pCVar4 & 1) != 0;
    Net->Connection = Ptr;
    if (bVar5) {
      *(undefined *)&pCVar4->X = 0;
      uVar3 = 0xaef;
      pCVar4 = (ConnectionTypePtr *)((int)&pCVar4->X + 1);
    }
    if (((uint)pCVar4 & 2) != 0) {
      *(undefined2 *)&pCVar4->X = 0;
      uVar3 = uVar3 - 2;
      pCVar4 = (ConnectionTypePtr *)((int)&pCVar4->X + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      pCVar4->X = 0;
      pCVar4 = (ConnectionTypePtr *)((int)pCVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pCVar4->X = 0;
      pCVar4 = (ConnectionTypePtr *)((int)&pCVar4->X + 2);
    }
    if (bVar5) {
      *(undefined *)&pCVar4->X = 0;
      uVar3 = Net->ConnectionN;
    }
    else {
      uVar3 = Net->ConnectionN;
    }
  }
  Net->ConnectionN = uVar3 + 1;
  return Ptr + uVar3;
}



BoxTypePtr GetBoxMemory(BoxListTypePtr_conflict *Boxes)

{
  uint uVar1;
  int iVar2;
  BoxTypePtr Ptr;
  
  uVar1 = Boxes->BoxN;
  Ptr = Boxes->Box;
  if (Boxes->BoxMax <= uVar1) {
    iVar2 = Boxes->BoxMax + 0x32;
    Boxes->BoxMax = iVar2 * 2;
    Ptr = (BoxTypePtr)MyRealloc(Ptr,iVar2 * 0x20,"GetBoxMemory()");
    Boxes->Box = Ptr;
    memset(Ptr + Boxes->BoxN,0,(Boxes->BoxMax - Boxes->BoxN) * 0x10);
    uVar1 = Boxes->BoxN;
  }
  Boxes->BoxN = uVar1 + 1;
  return Ptr + uVar1;
}



void ** GetPointerMemory(PointerListTypePtr_conflict *list)

{
  uint uVar1;
  int iVar2;
  void **Ptr;
  
  uVar1 = list->PtrN;
  Ptr = list->Ptr;
  if (list->PtrMax <= uVar1) {
    iVar2 = list->PtrMax + 0x32;
    list->PtrMax = iVar2 * 2;
    Ptr = (void **)MyRealloc(Ptr,iVar2 * 8,"GetPointerMemory()");
    list->Ptr = Ptr;
    memset(Ptr + list->PtrN,0,(list->PtrMax - list->PtrN) * 4);
    uVar1 = list->PtrN;
  }
  list->PtrN = uVar1 + 1;
  return Ptr + uVar1;
}



RubberbandTypePtr * GetRubberbandMemory(void)

{
  uint uVar1;
  RubberbandTypePtr *pRVar2;
  uint uVar3;
  RubberbandTypePtr *pRVar4;
  bool bVar5;
  byte bVar6;
  
  bVar6 = 0;
  pRVar2 = Crosshair.AttachedObject.Rubberband;
  if (Crosshair.AttachedObject.RubberbandMax <= Crosshair.AttachedObject.RubberbandN) {
    Crosshair.AttachedObject.RubberbandMax = Crosshair.AttachedObject.RubberbandMax + 100;
    uVar3 = 0x4b0;
    pRVar2 = (RubberbandTypePtr *)
             MyRealloc(Crosshair.AttachedObject.Rubberband,
                       Crosshair.AttachedObject.RubberbandMax * 0xc,"GetRubberbandMemory()");
    pRVar4 = pRVar2 + Crosshair.AttachedObject.RubberbandN;
    bVar5 = ((uint)pRVar4 & 1) != 0;
    Crosshair.AttachedObject.Rubberband = pRVar2;
    if (bVar5) {
      *(undefined *)&pRVar4->Layer = 0;
      uVar3 = 0x4af;
      pRVar4 = (RubberbandTypePtr *)((int)&pRVar4->Layer + 1);
    }
    if (((uint)pRVar4 & 2) != 0) {
      *(undefined2 *)&pRVar4->Layer = 0;
      uVar3 = uVar3 - 2;
      pRVar4 = (RubberbandTypePtr *)((int)&pRVar4->Layer + 2);
    }
    uVar1 = uVar3 >> 2;
    while (uVar1 != 0) {
      uVar1 = uVar1 - 1;
      pRVar4->Layer = (LayerTypePtr)0x0;
      pRVar4 = (RubberbandTypePtr *)((int)pRVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pRVar4->Layer = 0;
      pRVar4 = (RubberbandTypePtr *)((int)&pRVar4->Layer + 2);
    }
    if (bVar5) {
      *(undefined *)&pRVar4->Layer = 0;
    }
  }
  pRVar2 = pRVar2 + Crosshair.AttachedObject.RubberbandN;
  Crosshair.AttachedObject.RubberbandN = Crosshair.AttachedObject.RubberbandN + 1;
  return pRVar2;
}



void * MyMalloc(size_t Size,char *Text)

{
  void *pvVar1;
  
  if (Size == 0) {
    Size = 1;
  }
  pvVar1 = calloc(1,Size);
  if (pvVar1 != (void *)0x0) {
    return pvVar1;
  }
  if (Text == (char *)0x0) {
    Text = "(unknown)";
  }
  MyFatal("out of memory during malloc() in \'%s\'()\n",Text);
  return (void *)0x0;
}



void * MyCalloc(size_t Number,size_t Size,char *Text)

{
  void *pvVar1;
  
  if (Number == 0) {
    Number = 1;
  }
  if (Size == 0) {
    Size = 1;
  }
  pvVar1 = calloc(Number,Size);
  if (pvVar1 != (void *)0x0) {
    return pvVar1;
  }
  if (Text == (char *)0x0) {
    Text = "(unknown)";
  }
  MyFatal("out of memory during malloc() in \'%s\'()\n",Text);
  return (void *)0x0;
}



ElementTypePtr * GetElementMemory(DataTypePtr *Data)

{
  rtree_t **pprVar1;
  rtree_t *prVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  Cardinal CVar6;
  int iVar7;
  BoxType *which;
  BoxType *pBVar8;
  ElementTypePtr *local_28;
  int local_24;
  int local_20;
  
  local_28 = Data->Element;
  uVar5 = Data->ElementN;
  if (Data->ElementMax <= uVar5) {
    CVar6 = Data->ElementMax + 0x32;
    Data->ElementMax = CVar6;
    if (Data->element_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->element_tree);
      CVar6 = Data->ElementMax;
    }
    iVar7 = 0;
    local_28 = (ElementTypePtr *)MyRealloc(local_28,CVar6 * 300,"GetElementMemory()");
    Data->Element = local_28;
    memset(local_28 + Data->ElementN,0,15000);
    prVar2 = r_create_tree((BoxType **)0x0,0,0);
    Data->element_tree = prVar2;
    do {
      if (Data->name_tree[iVar7] != (rtree_t *)0x0) {
        r_destroy_tree(Data->name_tree + iVar7);
      }
      prVar2 = r_create_tree((BoxType **)0x0,0,0);
      Data->name_tree[iVar7] = prVar2;
      iVar7 = iVar7 + 1;
    } while (iVar7 != 3);
    uVar5 = Data->ElementN;
    local_20 = uVar5 - 1;
    if (local_20 != -1) {
      iVar7 = uVar5 * 300;
      do {
        local_24 = iVar7 + -300;
        which = (BoxType *)((int)&Data->Element[-1].BoundingBox.X1 + iVar7);
        r_insert_entry(Data->element_tree,which,0);
        uVar5 = which[0xe].X1;
        if (uVar5 != 0) {
          iVar7 = which[0x10].X1;
          uVar3 = 0;
          *(BoxType **)(iVar7 + 0x44) = which;
          while (uVar3 = uVar3 + 1, uVar3 < uVar5) {
            *(BoxType **)(uVar3 * 0x4c + 0x44 + iVar7) = which;
          }
        }
        uVar5 = which[0xe].X2;
        iVar7 = 0;
        uVar3 = 0;
        while ((uVar5 != 0 && (uVar3 < uVar5))) {
          uVar3 = uVar3 + 1;
          *(BoxType **)(which[0x10].Y1 + 0x60 + iVar7) = which;
          iVar7 = iVar7 + 0x68;
        }
        iVar7 = 2;
        pBVar8 = which;
        do {
          iVar4 = iVar7 * 0x3c;
          *(BoxType **)&pBVar8[0xd].Y1 = which;
          pBVar8 = (BoxType *)&pBVar8[-4].Y1;
          pprVar1 = Data->name_tree + iVar7;
          iVar7 = iVar7 + -1;
          r_insert_entry(*pprVar1,(BoxType *)((int)which + iVar4 + 0x24),0);
        } while (iVar7 != -1);
        local_20 = local_20 + -1;
        iVar7 = local_24;
      } while (local_20 != -1);
      uVar5 = Data->ElementN;
    }
  }
  Data->ElementN = uVar5 + 1;
  return local_28 + uVar5;
}



PolygonTypePtr GetPolygonMemory(LayerTypePtr Layer)

{
  Cardinal CVar1;
  rtree_t *rtree;
  uint uVar2;
  uint uVar3;
  undefined *puVar4;
  PolygonTypePtr Ptr;
  PolygonTypePtr ppVar5;
  int iVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  uVar3 = Layer->PolygonN;
  Ptr = Layer->Polygon;
  if (Layer->PolygonMax <= uVar3) {
    CVar1 = Layer->PolygonMax + 10;
    Layer->PolygonMax = CVar1;
    if (Layer->polygon_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->polygon_tree);
      CVar1 = Layer->PolygonMax;
    }
    Ptr = (PolygonTypePtr)MyRealloc(Ptr,CVar1 * 0x3c,"GetPolygonMemory()");
    uVar3 = 600;
    ppVar5 = Ptr + Layer->PolygonN;
    bVar7 = ((uint)ppVar5 & 1) != 0;
    Layer->Polygon = Ptr;
    if (bVar7) {
      *(undefined *)&(ppVar5->BoundingBox).X1 = 0;
      uVar3 = 599;
      ppVar5 = (PolygonTypePtr)((int)&(ppVar5->BoundingBox).X1 + 1);
    }
    if (((uint)ppVar5 & 2) != 0) {
      *(undefined2 *)&(ppVar5->BoundingBox).X1 = 0;
      uVar3 = uVar3 - 2;
      ppVar5 = (PolygonTypePtr)((int)&(ppVar5->BoundingBox).X1 + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      (ppVar5->BoundingBox).X1 = 0;
      ppVar5 = (PolygonTypePtr)((int)ppVar5 + (uint)bVar8 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&(ppVar5->BoundingBox).X1 = 0;
      ppVar5 = (PolygonTypePtr)((int)&(ppVar5->BoundingBox).X1 + 2);
    }
    if (bVar7) {
      *(undefined *)&(ppVar5->BoundingBox).X1 = 0;
    }
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Layer->PolygonN;
    iVar6 = uVar3 - 1;
    Layer->polygon_tree = rtree;
    if (iVar6 != -1) {
      puVar4 = (undefined *)(uVar3 * 0x3c);
      while( true ) {
        puVar4 = &DAT_ffffffc4 + (int)puVar4;
        iVar6 = iVar6 + -1;
        r_insert_entry(rtree,(BoxType *)(puVar4 + (int)&(Layer->Polygon->BoundingBox).X1),0);
        if (iVar6 == -1) break;
        rtree = Layer->polygon_tree;
      }
      uVar3 = Layer->PolygonN;
    }
  }
  Layer->PolygonN = uVar3 + 1;
  return Ptr + uVar3;
}



TextTypePtr GetTextMemory(LayerTypePtr Layer)

{
  Cardinal CVar1;
  rtree_t *rtree;
  uint uVar2;
  uint uVar3;
  undefined *puVar4;
  TextTypePtr Ptr;
  TextTypePtr pTVar5;
  int iVar6;
  bool bVar7;
  byte bVar8;
  
  bVar8 = 0;
  uVar3 = Layer->TextN;
  Ptr = Layer->Text;
  if (Layer->TextMax <= uVar3) {
    CVar1 = Layer->TextMax + 0x32;
    Layer->TextMax = CVar1;
    if (Layer->text_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->text_tree);
      CVar1 = Layer->TextMax;
    }
    Ptr = (TextTypePtr)MyRealloc(Ptr,CVar1 * 0x3c,"GetTextMemory()");
    uVar3 = 3000;
    pTVar5 = Ptr + Layer->TextN;
    bVar7 = ((uint)pTVar5 & 1) != 0;
    Layer->Text = Ptr;
    if (bVar7) {
      *(undefined *)&(pTVar5->BoundingBox).X1 = 0;
      uVar3 = 2999;
      pTVar5 = (TextTypePtr)((int)&(pTVar5->BoundingBox).X1 + 1);
    }
    if (((uint)pTVar5 & 2) != 0) {
      *(undefined2 *)&(pTVar5->BoundingBox).X1 = 0;
      uVar3 = uVar3 - 2;
      pTVar5 = (TextTypePtr)((int)&(pTVar5->BoundingBox).X1 + 2);
    }
    uVar2 = uVar3 >> 2;
    while (uVar2 != 0) {
      uVar2 = uVar2 - 1;
      (pTVar5->BoundingBox).X1 = 0;
      pTVar5 = (TextTypePtr)((int)pTVar5 + (uint)bVar8 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&(pTVar5->BoundingBox).X1 = 0;
      pTVar5 = (TextTypePtr)((int)&(pTVar5->BoundingBox).X1 + 2);
    }
    if (bVar7) {
      *(undefined *)&(pTVar5->BoundingBox).X1 = 0;
    }
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Layer->TextN;
    iVar6 = uVar3 - 1;
    Layer->text_tree = rtree;
    if (iVar6 != -1) {
      puVar4 = (undefined *)(uVar3 * 0x3c);
      while( true ) {
        puVar4 = &DAT_ffffffc4 + (int)puVar4;
        iVar6 = iVar6 + -1;
        r_insert_entry(rtree,(BoxType *)(puVar4 + (int)&(Layer->Text->BoundingBox).X1),0);
        if (iVar6 == -1) break;
        rtree = Layer->text_tree;
      }
      uVar3 = Layer->TextN;
    }
  }
  Layer->TextN = uVar3 + 1;
  return Ptr + uVar3;
}



ArcTypePtr * GetArcMemory(LayerTypePtr Layer)

{
  int iVar1;
  Cardinal CVar2;
  rtree_t *rtree;
  uint uVar3;
  ArcTypePtr *Ptr;
  int iVar4;
  
  uVar3 = Layer->ArcN;
  Ptr = Layer->Arc;
  if (Layer->ArcMax <= uVar3) {
    CVar2 = Layer->ArcMax + 1000;
    Layer->ArcMax = CVar2;
    if (Layer->arc_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->arc_tree);
      CVar2 = Layer->ArcMax;
    }
    Ptr = (ArcTypePtr *)MyRealloc(Ptr,CVar2 * 0x44,"GetArcMemory()");
    Layer->Arc = Ptr;
    memset(Ptr + Layer->ArcN,0,68000);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Layer->ArcN;
    iVar4 = uVar3 - 1;
    Layer->arc_tree = rtree;
    if (iVar4 != -1) {
      iVar1 = uVar3 * 0x44;
      while( true ) {
        iVar4 = iVar4 + -1;
        r_insert_entry(rtree,(BoxType *)((int)&Layer->Arc[-1].BoundingBox.X1 + iVar1),0);
        if (iVar4 == -1) break;
        rtree = Layer->arc_tree;
        iVar1 = iVar1 + -0x44;
      }
      uVar3 = Layer->ArcN;
    }
  }
  Layer->ArcN = uVar3 + 1;
  return Ptr + uVar3;
}



LineTypePtr GetLineMemory(LayerTypePtr Layer)

{
  int iVar1;
  Cardinal CVar2;
  rtree_t *rtree;
  uint uVar3;
  LineTypePtr Ptr;
  int iVar4;
  
  uVar3 = Layer->LineN;
  Ptr = Layer->Line;
  if (Layer->LineMax <= uVar3) {
    CVar2 = Layer->LineMax + 10000;
    Layer->LineMax = CVar2;
    if (Layer->line_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Layer->line_tree);
      CVar2 = Layer->LineMax;
    }
    Ptr = (LineTypePtr)MyRealloc(Ptr,CVar2 * 0x58,"GetLineMemory()");
    Layer->Line = Ptr;
    memset(Ptr + Layer->LineN,0,880000);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Layer->LineN;
    iVar4 = uVar3 - 1;
    Layer->line_tree = rtree;
    if (iVar4 != -1) {
      iVar1 = uVar3 * 0x58;
      while( true ) {
        iVar4 = iVar4 + -1;
        r_insert_entry(rtree,(BoxType *)((int)&Layer->Line[-1].BoundingBox.X1 + iVar1),0);
        if (iVar4 == -1) break;
        rtree = Layer->line_tree;
        iVar1 = iVar1 + -0x58;
      }
      uVar3 = Layer->LineN;
    }
  }
  Layer->LineN = uVar3 + 1;
  return Ptr + uVar3;
}



RatTypePtr * GetRatMemory(DataTypePtr *Data)

{
  int iVar1;
  Cardinal CVar2;
  rtree_t *rtree;
  uint uVar3;
  RatTypePtr *Ptr;
  int iVar4;
  
  uVar3 = Data->RatN;
  Ptr = Data->Rat;
  if (Data->RatMax <= uVar3) {
    CVar2 = Data->RatMax + 2000;
    Data->RatMax = CVar2;
    if (Data->rat_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->rat_tree);
      CVar2 = Data->RatMax;
    }
    Ptr = (RatTypePtr *)MyRealloc(Ptr,CVar2 * 0x5c,"GetRatMemory()");
    Data->Rat = Ptr;
    memset(Ptr + Data->RatN,0,0x2cec0);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar3 = Data->RatN;
    iVar4 = uVar3 - 1;
    Data->rat_tree = rtree;
    if (iVar4 != -1) {
      iVar1 = uVar3 * 0x5c;
      while( true ) {
        iVar4 = iVar4 + -1;
        r_insert_entry(rtree,(BoxType *)((int)&Data->Rat[-1].BoundingBox.X1 + iVar1),0);
        if (iVar4 == -1) break;
        rtree = Data->rat_tree;
        iVar1 = iVar1 + -0x5c;
      }
      uVar3 = Data->RatN;
    }
  }
  Data->RatN = uVar3 + 1;
  return Ptr + uVar3;
}



PinTypePtr * GetViaMemory(DataTypePtr *Data)

{
  Cardinal CVar1;
  rtree_t *rtree;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  PinTypePtr *local_20;
  
  local_20 = Data->Via;
  uVar2 = Data->ViaN;
  CVar1 = uVar2 + 1;
  if (Data->ViaMax <= uVar2) {
    CVar1 = Data->ViaMax + 2000;
    Data->ViaMax = CVar1;
    if (Data->via_tree != (rtree_t *)0x0) {
      r_destroy_tree(&Data->via_tree);
      CVar1 = Data->ViaMax;
    }
    local_20 = (PinTypePtr *)MyRealloc(local_20,CVar1 * 0x4c,"GetViaMemory()");
    Data->Via = local_20;
    memset(local_20 + Data->ViaN,0,0x251c0);
    rtree = r_create_tree((BoxType **)0x0,0,0);
    uVar2 = Data->ViaN;
    CVar1 = 1;
    Data->via_tree = rtree;
    if (uVar2 != 0) {
      uVar3 = 0;
      uVar4 = uVar2;
      while( true ) {
        r_insert_entry(rtree,(BoxType *)(Data->Via + uVar3),0);
        uVar2 = Data->ViaN;
        CVar1 = uVar2 + 1;
        if ((uVar2 == 0) || (uVar3 = uVar3 + (CVar1 - uVar4), uVar2 <= uVar3)) break;
        rtree = Data->via_tree;
        uVar4 = uVar2;
      }
    }
  }
  Data->ViaN = CVar1;
  return local_20 + uVar2;
}



PadTypePtr * GetPadMemory(ElementTypePtr *Element)

{
  Boolean BVar1;
  Cardinal CVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  PadTypePtr *pPVar6;
  bool bVar7;
  bool bVar8;
  byte bVar9;
  PadTypePtr *local_28;
  int local_20;
  
  bVar9 = 0;
  local_28 = Element->Pad;
  uVar4 = Element->PadN;
  if (Element->PadMax <= uVar4) {
    if (PCB->Data->pad_tree == (rtree_t *)0x0) {
      CVar2 = Element->PadMax + 0x14;
      Element->PadMax = CVar2;
      local_28 = (PadTypePtr *)MyRealloc(local_28,CVar2 * 0x68,"GetPadMemory()");
      uVar4 = 0x820;
      pPVar6 = local_28 + Element->PadN;
      bVar8 = ((uint)pPVar6 & 1) != 0;
      Element->Pad = local_28;
      if (bVar8) {
        *(undefined *)&(pPVar6->BoundingBox).X1 = 0;
        uVar4 = 0x81f;
        pPVar6 = (PadTypePtr *)((int)&(pPVar6->BoundingBox).X1 + 1);
      }
      if (((uint)pPVar6 & 2) != 0) {
        *(undefined2 *)&(pPVar6->BoundingBox).X1 = 0;
        uVar4 = uVar4 - 2;
        pPVar6 = (PadTypePtr *)((int)&(pPVar6->BoundingBox).X1 + 2);
      }
      uVar3 = uVar4 >> 2;
      while (uVar3 != 0) {
        uVar3 = uVar3 - 1;
        (pPVar6->BoundingBox).X1 = 0;
        pPVar6 = (PadTypePtr *)((int)pPVar6 + (uint)bVar9 * -8 + 4);
      }
      if ((uVar4 & 2) != 0) {
        *(undefined2 *)&(pPVar6->BoundingBox).X1 = 0;
        pPVar6 = (PadTypePtr *)((int)&(pPVar6->BoundingBox).X1 + 2);
      }
      if (bVar8) {
        *(undefined *)&(pPVar6->BoundingBox).X1 = 0;
      }
    }
    else {
      bVar8 = false;
      uVar5 = 0;
      uVar3 = uVar4;
      while ((uVar3 != 0 && (uVar5 < uVar3))) {
        BVar1 = r_delete_entry(PCB->Data->pad_tree,(BoxType *)(Element->Pad + uVar5));
        if (BVar1 != '\0') {
          bVar8 = true;
        }
        uVar3 = Element->PadN;
        uVar5 = uVar5 + (uVar4 == uVar3);
      }
      CVar2 = Element->PadMax + 0x14;
      Element->PadMax = CVar2;
      local_28 = (PadTypePtr *)MyRealloc(local_28,CVar2 * 0x68,"GetPadMemory()");
      uVar4 = 0x820;
      pPVar6 = local_28 + Element->PadN;
      bVar7 = ((uint)pPVar6 & 1) != 0;
      Element->Pad = local_28;
      if (bVar7) {
        *(undefined *)&(pPVar6->BoundingBox).X1 = 0;
        uVar4 = 0x81f;
        pPVar6 = (PadTypePtr *)((int)&(pPVar6->BoundingBox).X1 + 1);
      }
      if (((uint)pPVar6 & 2) != 0) {
        *(undefined2 *)&(pPVar6->BoundingBox).X1 = 0;
        uVar4 = uVar4 - 2;
        pPVar6 = (PadTypePtr *)((int)&(pPVar6->BoundingBox).X1 + 2);
      }
      uVar3 = uVar4 >> 2;
      while (uVar3 != 0) {
        uVar3 = uVar3 - 1;
        (pPVar6->BoundingBox).X1 = 0;
        pPVar6 = (PadTypePtr *)((int)pPVar6 + (uint)bVar9 * -8 + 4);
      }
      if ((uVar4 & 2) != 0) {
        *(undefined2 *)&(pPVar6->BoundingBox).X1 = 0;
        pPVar6 = (PadTypePtr *)((int)&(pPVar6->BoundingBox).X1 + 2);
      }
      if (bVar7) {
        *(undefined *)&(pPVar6->BoundingBox).X1 = 0;
      }
      if (bVar8) {
        uVar3 = Element->PadN;
        uVar5 = 0;
        local_20 = 0;
        uVar4 = uVar3;
        while ((uVar4 != 0 && (uVar5 < uVar4))) {
          r_insert_entry(PCB->Data->pad_tree,
                         (BoxType *)((int)&(Element->Pad->BoundingBox).X1 + local_20),0);
          uVar4 = Element->PadN;
          if (Element->PadN == uVar3) {
            uVar5 = uVar5 + 1;
            local_20 = local_20 + 0x68;
            uVar4 = uVar3;
          }
        }
        goto LAB_080ac0de;
      }
    }
    uVar4 = Element->PadN;
  }
LAB_080ac0de:
  Element->PadN = uVar4 + 1;
  return local_28 + uVar4;
}



PinTypePtr * GetPinMemory(ElementTypePtr *Element)

{
  uint uVar1;
  bool bVar2;
  Boolean BVar3;
  Cardinal CVar4;
  PinTypePtr *pPVar5;
  uint uVar6;
  rtree_t *rtree;
  uint uVar7;
  bool bVar8;
  byte bVar9;
  PinTypePtr *local_24;
  uint local_20;
  
  bVar9 = 0;
  local_24 = Element->Pin;
  uVar6 = Element->PinN;
  uVar7 = Element->PinMax;
  if (uVar7 <= uVar6) {
    rtree = PCB->Data->pin_tree;
    if (rtree == (rtree_t *)0x0) {
      Element->PinMax = uVar7 + 0x14;
    }
    else {
      if (uVar6 != 0) {
        uVar7 = 0;
        pPVar5 = local_24;
        bVar8 = false;
        while( true ) {
          BVar3 = r_delete_entry(rtree,(BoxType *)(pPVar5 + uVar7));
          bVar2 = true;
          if (BVar3 == '\0') {
            bVar2 = bVar8;
          }
          uVar1 = Element->PinN;
          if ((uVar1 == 0) || (uVar7 = (uVar1 + 1 + uVar7) - uVar6, uVar1 <= uVar7)) break;
          pPVar5 = Element->Pin;
          rtree = PCB->Data->pin_tree;
          uVar6 = uVar1;
          bVar8 = bVar2;
        }
        CVar4 = Element->PinMax + 0x14;
        Element->PinMax = CVar4;
        local_24 = (PinTypePtr *)MyRealloc(local_24,CVar4 * 0x4c,"GetPinMemory()");
        uVar7 = 0x5f0;
        pPVar5 = local_24 + Element->PinN;
        bVar8 = ((uint)pPVar5 & 1) != 0;
        Element->Pin = local_24;
        if (bVar8) {
          *(undefined *)&(pPVar5->BoundingBox).X1 = 0;
          uVar7 = 0x5ef;
          pPVar5 = (PinTypePtr *)((int)&(pPVar5->BoundingBox).X1 + 1);
        }
        if (((uint)pPVar5 & 2) != 0) {
          *(undefined2 *)&(pPVar5->BoundingBox).X1 = 0;
          uVar7 = uVar7 - 2;
          pPVar5 = (PinTypePtr *)((int)&(pPVar5->BoundingBox).X1 + 2);
        }
        uVar6 = uVar7 >> 2;
        while (uVar6 != 0) {
          uVar6 = uVar6 - 1;
          (pPVar5->BoundingBox).X1 = 0;
          pPVar5 = (PinTypePtr *)((int)pPVar5 + (uint)bVar9 * -8 + 4);
        }
        if ((uVar7 & 2) != 0) {
          *(undefined2 *)&(pPVar5->BoundingBox).X1 = 0;
          pPVar5 = (PinTypePtr *)((int)&(pPVar5->BoundingBox).X1 + 2);
        }
        if (bVar8) {
          *(undefined *)&(pPVar5->BoundingBox).X1 = 0;
        }
        if (bVar2) {
          uVar7 = 0;
          uVar6 = 0;
          CVar4 = 1;
          local_20 = Element->PinN;
          if (Element->PinN != 0) {
            do {
              r_insert_entry(PCB->Data->pin_tree,(BoxType *)(Element->Pin + uVar7),0);
              uVar6 = Element->PinN;
              CVar4 = uVar6 + 1;
              if (uVar6 == 0) {
                uVar6 = 0;
                break;
              }
              uVar7 = uVar7 + (CVar4 - local_20);
              local_20 = uVar6;
            } while (uVar7 < uVar6);
          }
        }
        else {
          uVar6 = Element->PinN;
          CVar4 = uVar6 + 1;
        }
        goto LAB_080ac371;
      }
      Element->PinMax = uVar7 + 0x14;
    }
    local_24 = (PinTypePtr *)MyRealloc(local_24,(uVar7 + 0x14) * 0x4c,"GetPinMemory()");
    uVar7 = 0x5f0;
    pPVar5 = local_24 + Element->PinN;
    bVar8 = ((uint)pPVar5 & 1) != 0;
    Element->Pin = local_24;
    if (bVar8) {
      *(undefined *)&(pPVar5->BoundingBox).X1 = 0;
      uVar7 = 0x5ef;
      pPVar5 = (PinTypePtr *)((int)&(pPVar5->BoundingBox).X1 + 1);
    }
    if (((uint)pPVar5 & 2) != 0) {
      *(undefined2 *)&(pPVar5->BoundingBox).X1 = 0;
      uVar7 = uVar7 - 2;
      pPVar5 = (PinTypePtr *)((int)&(pPVar5->BoundingBox).X1 + 2);
    }
    uVar6 = uVar7 >> 2;
    while (uVar6 != 0) {
      uVar6 = uVar6 - 1;
      (pPVar5->BoundingBox).X1 = 0;
      pPVar5 = (PinTypePtr *)((int)pPVar5 + (uint)bVar9 * -8 + 4);
    }
    if ((uVar7 & 2) != 0) {
      *(undefined2 *)&(pPVar5->BoundingBox).X1 = 0;
      pPVar5 = (PinTypePtr *)((int)&(pPVar5->BoundingBox).X1 + 2);
    }
    if (bVar8) {
      *(undefined *)&(pPVar5->BoundingBox).X1 = 0;
    }
    uVar6 = Element->PinN;
  }
  CVar4 = uVar6 + 1;
LAB_080ac371:
  Element->PinN = CVar4;
  return local_24 + uVar6;
}



int Netlist(int argc,char **argv,int x,int y)

{
  int iVar1;
  LibraryEntryTypePtr *pLVar2;
  char *__s1;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int __errcode;
  size_t __n;
  int iVar6;
  Cardinal CVar7;
  char *__s1_00;
  PCBTypePtr pPVar8;
  Cardinal CVar9;
  LibraryMenuTypePtr *pLVar10;
  int in_GS_OFFSET;
  code *local_e0;
  uint local_dc;
  regex_t elt_pattern;
  regmatch_t match;
  char errorstring [128];
  
  pPVar8 = PCB;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __errcode = 1;
  if (PCB == (PCBTypePtr)0x0) goto LAB_080ac696;
  if (argc == 0) {
LAB_080ac71e:
    Message("Net(find|select|rats|norats[,net[,pin]])");
    __errcode = 1;
    goto LAB_080ac696;
  }
  __s1_00 = *argv;
  __errcode = strcasecmp(__s1_00,"find");
  local_e0 = netlist_find;
  if (__errcode != 0) {
    __errcode = strcasecmp(__s1_00,"select");
    local_e0 = netlist_select;
    if (__errcode != 0) {
      __errcode = strcasecmp(__s1_00,"rats");
      local_e0 = netlist_rats;
      if (__errcode != 0) {
        __errcode = strcasecmp(__s1_00,"norats");
        local_e0 = netlist_norats;
        if (__errcode != 0) goto LAB_080ac71e;
      }
    }
  }
  if (argc < 2) {
    CVar7 = (pPVar8->NetlistLib).MenuN;
    bVar4 = false;
LAB_080ac7da:
    bVar3 = false;
    if (CVar7 != 0) goto LAB_080ac4f7;
LAB_080ac7e4:
    if (2 < argc) {
      (*gui->log)("Net %s has no pin %s\n",argv[1],argv[2]);
      __errcode = 1;
      goto LAB_080ac696;
    }
  }
  else {
    CVar7 = (pPVar8->NetlistLib).MenuN;
    if (CVar7 == 0) {
      __s1_00 = argv[1];
LAB_080ac7a2:
      __errcode = regcomp((regex_t *)&elt_pattern,__s1_00,0xb);
      if (__errcode != 0) {
        regerror(__errcode,(regex_t *)&elt_pattern,errorstring,0x80);
        Message("regexp error: %s\n",errorstring);
        regfree((regex_t *)&elt_pattern);
        __errcode = 1;
        goto LAB_080ac696;
      }
      bVar4 = true;
      CVar7 = (PCB->NetlistLib).MenuN;
      pPVar8 = PCB;
      goto LAB_080ac7da;
    }
    CVar9 = 0;
    pLVar10 = (pPVar8->NetlistLib).Menu;
    bVar4 = true;
    __s1_00 = argv[1];
    do {
      __errcode = strcasecmp(__s1_00,pLVar10[CVar9].Name + 2);
      if (__errcode == 0) {
        bVar4 = false;
      }
      CVar9 = CVar9 + 1;
    } while (CVar9 != CVar7);
    if (bVar4) goto LAB_080ac7a2;
LAB_080ac4f7:
    bVar3 = false;
    bVar5 = false;
    local_dc = 0;
    do {
      pLVar10 = (pPVar8->NetlistLib).Menu + local_dc;
      if (argc < 2) {
LAB_080ac778:
        bVar3 = true;
        (*local_e0)(pLVar10,0);
        pPVar8 = PCB;
      }
      else {
        if (bVar4) {
          __errcode = regexec((regex_t *)&elt_pattern,pLVar10->Name + 2,1,(regmatch_t *)&match,0);
          pPVar8 = PCB;
        }
        else {
          __errcode = strcasecmp(pLVar10->Name + 2,argv[1]);
        }
        if (__errcode == 0) {
          if (argc == 2) goto LAB_080ac778;
          __s1_00 = argv[2];
          __n = strlen(__s1_00);
          if (pLVar10->EntryN != 0) {
            __errcode = 0;
            do {
              pLVar2 = pLVar10->Entry;
              __s1 = pLVar2[__errcode].ListEntry;
              iVar6 = strcasecmp(__s1,__s1_00);
              if ((iVar6 == 0) ||
                 ((iVar6 = strncasecmp(__s1,__s1_00,__n), iVar6 == 0 && (__s1[__n] == '-')))) {
                (*local_e0)(pLVar10,pLVar2 + __errcode);
                bVar5 = true;
                if (pLVar10->EntryN < __errcode + 1U || pLVar10->EntryN == __errcode + 1U) break;
              }
              else {
                if (pLVar10->EntryN < __errcode + 1U || pLVar10->EntryN == __errcode + 1U) break;
              }
              __errcode = __errcode + 1;
              __s1_00 = argv[2];
            } while( true );
          }
          bVar3 = true;
          pPVar8 = PCB;
        }
      }
      local_dc = local_dc + 1;
    } while (local_dc <= (pPVar8->NetlistLib).MenuN && (pPVar8->NetlistLib).MenuN != local_dc);
    if (!bVar5) goto LAB_080ac7e4;
  }
  if (!bVar3) {
    (*gui->log)("No net named %s\n",argv[1]);
  }
  __errcode = 0;
  if (bVar4) {
    regfree((regex_t *)&elt_pattern);
    __errcode = 0;
  }
LAB_080ac696:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return __errcode;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void netlist_norats(LibraryMenuType *net,LibraryEntryType *pin)

{
  *net->Name = '*';
  net->flag = '\0';
  hid_action("NetlistChanged");
  return;
}



void netlist_rats(LibraryMenuType *net,LibraryEntryType *pin)

{
  *net->Name = ' ';
  net->flag = '\x01';
  hid_action("NetlistChanged");
  return;
}



void netlist_select(LibraryMenuType *net,LibraryEntryType *pin)

{
  Boolean BVar1;
  LocationType X;
  LocationType Y;
  ConnectionType conn;
  
  BVar1 = SeekPad((LibraryEntryType *)net->Entry,&conn,'\0');
  if (BVar1 == '\0') {
    return;
  }
  if (conn.type == 0x100) {
    X = *(LocationType *)((int)conn.ptr2 + 0x34);
    Y = *(LocationType *)((int)conn.ptr2 + 0x38);
  }
  else {
    if (conn.type != 0x200) {
      return;
    }
    X = *(LocationType *)((int)conn.ptr2 + 0x2c);
    Y = *(LocationType *)((int)conn.ptr2 + 0x30);
  }
  LookupConnection(X,Y,'\x01',1,0x40);
  return;
}



void netlist_find(LibraryMenuType *net,LibraryEntryType *pin)

{
  Boolean BVar1;
  LocationType X;
  LocationType Y;
  ConnectionType conn;
  
  BVar1 = SeekPad((LibraryEntryType *)net->Entry,&conn,'\0');
  if (BVar1 == '\0') {
    return;
  }
  if (conn.type == 0x100) {
    X = *(LocationType *)((int)conn.ptr2 + 0x34);
    Y = *(LocationType *)((int)conn.ptr2 + 0x38);
  }
  else {
    if (conn.type != 0x200) {
      return;
    }
    X = *(LocationType *)((int)conn.ptr2 + 0x2c);
    Y = *(LocationType *)((int)conn.ptr2 + 0x30);
  }
  LookupConnection(X,Y,'\x01',1,4);
  return;
}



void register_netlist_action_list(void)

{
  hid_register_actions(netlist_action_list,2);
  return;
}



LibraryMenuTypePtr * netname_to_netname(char *netname)

{
  uint uVar1;
  LibraryMenuTypePtr *pLVar2;
  int iVar3;
  uint uVar4;
  LibraryMenuTypePtr *pLVar5;
  
  if (((*netname == ' ') || (*netname == '*')) && (netname[1] == ' ')) {
    netname = netname + 2;
  }
  uVar1 = (PCB->NetlistLib).MenuN;
  if (uVar1 != 0) {
    pLVar2 = (PCB->NetlistLib).Menu;
    uVar4 = 0;
    do {
      pLVar5 = pLVar2 + uVar4;
      iVar3 = strcmp(pLVar5->Name + 2,netname);
      if (iVar3 == 0) {
        return pLVar5;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar1);
  }
  return (LibraryMenuTypePtr *)0x0;
}



LibraryMenuTypePtr * netnode_to_netname(char *nodename)

{
  uint uVar1;
  LibraryMenuTypePtr *pLVar2;
  uint uVar3;
  LibraryEntryTypePtr *pLVar4;
  LibraryMenuTypePtr *pLVar5;
  int iVar6;
  uint uVar7;
  uint local_28;
  
  uVar1 = (PCB->NetlistLib).MenuN;
  if (uVar1 != 0) {
    pLVar2 = (PCB->NetlistLib).Menu;
    local_28 = 0;
    do {
      pLVar5 = pLVar2 + local_28;
      uVar3 = pLVar5->EntryN;
      if (uVar3 != 0) {
        pLVar4 = pLVar5->Entry;
        uVar7 = 0;
        do {
          iVar6 = strcmp(pLVar4[uVar7].ListEntry,nodename);
          if (iVar6 == 0) {
            return pLVar5;
          }
          uVar7 = uVar7 + 1;
        } while (uVar7 < uVar3);
      }
      local_28 = local_28 + 1;
    } while (local_28 < uVar1);
  }
  return (LibraryMenuTypePtr *)0x0;
}



void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)

{
  if (yy_current_buffer != new_buffer) {
    if (yy_current_buffer != (YY_BUFFER_STATE)0x0) {
      *yy_c_buf_p = yy_hold_char;
      yy_current_buffer->yy_buf_pos = yy_c_buf_p;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }
    yy_n_chars = new_buffer->yy_n_chars;
    yy_current_buffer = new_buffer;
    yy_c_buf_p = new_buffer->yy_buf_pos;
    yyin = new_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    yy_did_buffer_switch_on_eof = 1;
    yytext = yy_c_buf_p;
  }
  return;
}



void yy_load_buffer_state(void)

{
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  yyin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yytext = yy_c_buf_p;
  return;
}



void yy_flush_buffer(YY_BUFFER_STATE b)

{
  char *pcVar1;
  bool bVar2;
  
  if (b != (YY_BUFFER_STATE)0x0) {
    b->yy_n_chars = 0;
    *b->yy_ch_buf = '\0';
    b->yy_ch_buf[1] = '\0';
    pcVar1 = b->yy_ch_buf;
    bVar2 = b == yy_current_buffer;
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    b->yy_buf_pos = pcVar1;
    if (bVar2) {
      yyin = b->yy_input_file;
      yy_c_buf_p = pcVar1;
      yy_hold_char = *pcVar1;
      yy_n_chars = b->yy_n_chars;
      yytext = pcVar1;
      return;
    }
  }
  return;
}



void yy_delete_buffer(YY_BUFFER_STATE b)

{
  if (b == (YY_BUFFER_STATE)0x0) {
    return;
  }
  if (b == yy_current_buffer) {
    yy_current_buffer = (YY_BUFFER_STATE)0x0;
  }
  if (b->yy_is_our_buffer == 0) {
    free(b);
    return;
  }
  free(b->yy_ch_buf);
  free(b);
  return;
}



void __regparm3 yy_fatal_error(char *msg)

{
  __fprintf_chk(stderr,1,&DAT_08148577,msg);
                    // WARNING: Subroutine does not return
  exit(2);
}



YY_BUFFER_STATE yy_scan_buffer(char *base,yy_size_t size)

{
  YY_BUFFER_STATE new_buffer;
  
  if (((size < 2) || (base[size - 2] != '\0')) || (base[size - 1] != '\0')) {
    new_buffer = (YY_BUFFER_STATE)0x0;
  }
  else {
    new_buffer = (YY_BUFFER_STATE)calloc(1,0x28);
    if (new_buffer == (YY_BUFFER_STATE)0x0) {
      yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
    new_buffer->yy_buf_size = size - 2;
    new_buffer->yy_ch_buf = base;
    new_buffer->yy_buf_pos = base;
    new_buffer->yy_is_our_buffer = 0;
    new_buffer->yy_input_file = (FILE *)0x0;
    new_buffer->yy_n_chars = size - 2;
    new_buffer->yy_is_interactive = 0;
    new_buffer->yy_at_bol = 1;
    new_buffer->yy_fill_buffer = 0;
    new_buffer->yy_buffer_status = 0;
    yy_switch_to_buffer(new_buffer);
  }
  return new_buffer;
}



YY_BUFFER_STATE yy_scan_bytes(char *bytes,yy_size_t len)

{
  char *base;
  uint uVar1;
  YY_BUFFER_STATE pyVar2;
  
  base = (char *)calloc(1,len + 2);
  if (base == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
  if (len != 0) {
    uVar1 = 0;
    do {
      base[uVar1] = bytes[uVar1];
      uVar1 = uVar1 + 1;
    } while (uVar1 < len);
  }
  base[len + 1] = '\0';
  base[len] = '\0';
  pyVar2 = yy_scan_buffer(base,len + 2);
  if (pyVar2 == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
  pyVar2->yy_is_our_buffer = 1;
  return pyVar2;
}



YY_BUFFER_STATE yy_scan_string(char *yy_str)

{
  char cVar1;
  yy_size_t len;
  YY_BUFFER_STATE pyVar2;
  
  len = 0;
  cVar1 = *yy_str;
  while (cVar1 != '\0') {
    len = len + 1;
    cVar1 = yy_str[len];
  }
  pyVar2 = yy_scan_bytes(yy_str,len);
  return pyVar2;
}



void yy_init_buffer(YY_BUFFER_STATE b,FILE *file)

{
  int __fd;
  int iVar1;
  
  yy_flush_buffer(b);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  if (file != (FILE *)0x0) {
    __fd = fileno((FILE *)file);
    __fd = isatty(__fd);
    iVar1 = 1;
    if (0 < __fd) goto LAB_080ace90;
  }
  iVar1 = 0;
LAB_080ace90:
  b->yy_is_interactive = iVar1;
  return;
}



YY_BUFFER_STATE yy_create_buffer(FILE *file,int size)

{
  YY_BUFFER_STATE b;
  char *pcVar1;
  
  b = (YY_BUFFER_STATE)calloc(1,0x28);
  if (b == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_buf_size = size;
  pcVar1 = (char *)calloc(1,size + 2);
  b->yy_ch_buf = pcVar1;
  if (pcVar1 == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_is_our_buffer = 1;
  yy_init_buffer(b,file);
  return b;
}



void yyrestart(FILE *input_file)

{
  if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
    yy_current_buffer = yy_create_buffer(yyin,0x4000);
  }
  yy_init_buffer(yy_current_buffer,input_file);
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  yyin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yytext = yy_c_buf_p;
  return;
}



int __regparm3 Parse(char *Executable,char *Path,char *Filename,char *Parameter)

{
  bool bVar1;
  Boolean firsttime;
  char *command;
  int iVar2;
  int iVar3;
  size_t sVar4;
  char *__filename;
  
  if ((Executable != (char *)0x0) && (*Executable != '\0')) {
    if (command != (char *)0x0) {
      SaveFree(command);
      command = (char *)0x0;
    }
    command = EvaluateFilename(Executable,Path,Filename,Parameter);
    if (*command != '\0') {
      bVar1 = true;
      yyin = (FILE *)popen(command,"r");
      if (yyin != (FILE *)0x0) goto joined_r0x080ad148;
    }
    PopenErrorMessage(command);
    return 1;
  }
  iVar2 = 2;
  if (Path != (char *)0x0) {
    sVar4 = strlen(Path);
    iVar2 = sVar4 + 2;
  }
  sVar4 = strlen(Filename);
  __filename = (char *)calloc(1,sVar4 + iVar2);
  if (__filename == (char *)0x0) {
    __fprintf_chk(stderr,1,"Parse():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  if ((Path == (char *)0x0) || (*Path == '\0')) {
    __sprintf_chk(__filename,1,0xffffffff,0x814736b,Filename);
  }
  else {
    __sprintf_chk(__filename,1,0xffffffff,0x814d6ff,Path,0x815d1de,Filename);
  }
  yyin = (FILE *)fopen(__filename,"r");
  if (yyin == (FILE *)0x0) {
    Message("Can\'t open %s for reading\n",__filename);
    return 1;
  }
  bVar1 = false;
  free(__filename);
joined_r0x080ad148:
  if (firsttime == '\0') {
    yyrestart(yyin);
  }
  firsttime = '\0';
  yylineno = 1;
  yyfilename = Filename;
  if (PCB != (PCBTypePtr)0x0) {
    SaveTMPData();
  }
  iVar2 = yyparse();
  RemoveTMPData();
  yy_delete_buffer(yy_current_buffer);
  if (bVar1) {
    iVar3 = pclose((FILE *)yyin);
  }
  else {
    iVar3 = fclose((FILE *)yyin);
  }
  if (iVar3 == 0) {
    return iVar2;
  }
  return 1;
}



int ParseFont(FontTypePtr Ptr,char *Filename)

{
  char *__s;
  char *Path;
  int local_20;
  
  yyPCB = (PCBTypePtr)0x0;
  yyElement = (ElementTypePtr *)0x0;
  yyFont = Ptr;
  __s = (char *)__strdup(Settings.FontPath);
  Path = strtok(__s,":");
  if ((Path == (char *)0x0) || (*Path == '\0')) {
    local_20 = 0;
  }
  else {
    while( true ) {
      Message("Looking for %s in %s\n",Filename,Path);
      local_20 = Parse(Settings.FontCommand,Path,Filename,(char *)0x0);
      if (local_20 == 0) break;
      Path = strtok((char *)0x0,":");
      if ((Path == (char *)0x0) || (*Path == '\0')) goto LAB_080ad2eb;
    }
    Message("Found %s in %s\n",Filename,Path);
  }
LAB_080ad2eb:
  free(__s);
  return local_20;
}



int ParsePCB(PCBTypePtr Ptr,char *Filename)

{
  int iVar1;
  
  yyData = (DataTypePtr *)0x0;
  yyFont = (FontTypePtr)0x0;
  yyElement = (ElementTypePtr *)0x0;
  yyPCB = Ptr;
  iVar1 = Parse(Settings.FileCommand,Settings.FilePath,Filename,(char *)0x0);
  return iVar1;
}



int ParseLibraryEntry(DataTypePtr *Ptr,char *Template)

{
  int iVar1;
  
  yyPCB = (PCBTypePtr)0x0;
  yyElement = (ElementTypePtr *)0x0;
  yyData = Ptr;
  yyFont = (FontTypePtr)&PCB->Font;
  iVar1 = Parse(Settings.LibraryCommand,Settings.LibraryPath,Settings.LibraryFilename,Template);
  return iVar1;
}



int ParseElementFile(DataTypePtr *Ptr,char *Filename)

{
  int iVar1;
  
  yyPCB = (PCBTypePtr)0x0;
  yyElement = (ElementTypePtr *)0x0;
  yyData = Ptr;
  yyFont = (FontTypePtr)&PCB->Font;
  iVar1 = Parse((char *)0x0,(char *)0x0,Filename,(char *)0x0);
  return iVar1;
}



int parse_number(double scale)

{
  double local_14 [2];
  
  __isoc99_sscanf(yytext,&DAT_0814a85d,local_14);
  scale = scale * local_14[0];
  if (scale < 0.00000000) {
    scale = scale - 0.49000000;
  }
  else {
    scale = scale + 0.49000000;
  }
  yylval = (int)ROUND(scale);
  return 0x102;
}



// WARNING: Could not reconcile some variable overlaps

int yylex(void)

{
  int iVar1;
  size_t Number;
  char *pcVar2;
  char *pcVar3;
  short sVar4;
  size_t __n;
  byte *pbVar5;
  int iVar6;
  char *pcVar7;
  size_t sVar8;
  int iVar9;
  char *pcVar10;
  byte bVar11;
  char cVar12;
  byte *pbVar13;
  bool bVar14;
  double dVar15;
  yy_state_type *local_2c;
  yy_state_type *local_28;
  YY_BUFFER_STATE local_24;
  
  if (yy_init != 0) {
    yy_init = 0;
    iVar1 = 1;
    if (yy_start != 0) {
      iVar1 = yy_start;
    }
    if (yyin == (FILE *)0x0) {
      yyin = stdin;
    }
    if (yyout == (FILE *)0x0) {
      yyout = stdout;
    }
    yy_start = iVar1;
    if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
      yy_current_buffer = yy_create_buffer(yyin,0x4000);
    }
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
  }
LAB_080ad4fc:
  *yy_c_buf_p = yy_hold_char;
  local_24 = (YY_BUFFER_STATE)(yy_state_buf + 1);
  yy_state_buf[0] = yy_start;
  iVar1 = yy_start;
  local_28 = (yy_state_type *)yy_c_buf_p;
LAB_080ad51c:
  sVar4 = yy_base[iVar1];
  do {
    bVar11 = *(byte *)(yy_ec + (byte)*yy_c_buf_p);
    while( true ) {
      iVar6 = (uint)bVar11 + (int)sVar4;
      if ((int)yy_chk[iVar6] == iVar1) break;
      iVar1 = (int)yy_def[iVar1];
      if (0xb3 < iVar1) {
        bVar11 = *(byte *)(yy_meta + (uint)bVar11);
      }
      sVar4 = yy_base[iVar1];
    }
    iVar1 = (int)yy_nxt[iVar6];
    yy_c_buf_p = (char *)((byte *)yy_c_buf_p + 1);
    *(int *)local_24 = iVar1;
    local_2c = (yy_state_type *)local_24 + 1;
    sVar4 = yy_base[iVar1];
    pbVar13 = (byte *)yy_c_buf_p;
    local_24 = (YY_BUFFER_STATE)local_2c;
  } while (sVar4 != 0xe8);
LAB_080ad5a1:
  iVar1 = local_2c[-1];
  yy_state_ptr = local_2c + -1;
  sVar4 = yy_accept[iVar1];
  while ((yy_lp = (int)sVar4, yy_lp == 0 || (yy_accept[iVar1 + 1] <= yy_lp))) {
    yy_state_ptr = yy_state_ptr + -1;
    pbVar13 = pbVar13 + -1;
    iVar1 = *yy_state_ptr;
    sVar4 = yy_accept[iVar1];
  }
  yyleng = (int)(pbVar13 + -(int)local_28);
  iVar1 = (int)yy_acclist[yy_lp];
  yy_hold_char = *pbVar13;
  yy_full_match = (char *)pbVar13;
  yytext = (char *)local_28;
  *pbVar13 = 0;
  yy_c_buf_p = (char *)pbVar13;
  if ((iVar1 != 0x2e) && (0 < yyleng)) {
    iVar6 = 0;
    do {
      while (yytext[iVar6] != '\n') {
        iVar6 = iVar6 + 1;
        if (iVar6 == yyleng) goto LAB_080ad655;
      }
      iVar6 = iVar6 + 1;
      yylineno = yylineno + 1;
    } while (iVar6 != yyleng);
  }
LAB_080ad655:
  switch(iVar1) {
  default:
    yy_fatal_error("fatal flex scanner internal error--no action found");
    goto LAB_080ad4fc;
  case 1:
    return 0x106;
  case 2:
    return 0x107;
  case 3:
    return 0x113;
  case 4:
    return 0x117;
  case 5:
    return 0x121;
  case 6:
    return 0x120;
  case 7:
    return 0x122;
  case 8:
    return 0x114;
  case 9:
    return 0x108;
  case 10:
    return 0x111;
  case 0xb:
    return 0x112;
  case 0xc:
    return 0x109;
  case 0xd:
    return 0x10b;
  case 0xe:
    return 0x10a;
  case 0xf:
    return 0x10d;
  case 0x10:
    return 0x10e;
  case 0x11:
    return 0x10f;
  case 0x12:
    return 0x118;
  case 0x13:
    return 0x110;
  case 0x14:
    return 0x116;
  case 0x15:
    return 0x115;
  case 0x16:
    return 0x119;
  case 0x17:
    return 0x11a;
  case 0x18:
    return 0x11b;
  case 0x19:
    return 0x11c;
  case 0x1a:
    return 0x10c;
  case 0x1b:
    return 0x11d;
  case 0x1c:
    return 0x11e;
  case 0x1d:
    return 0x11f;
  case 0x1e:
    return 0x123;
  case 0x1f:
    yylval = (char *)(int)yytext[1];
    return 0x103;
  case 0x20:
    iVar1 = parse_number(3937.00790000);
    return iVar1;
  case 0x21:
    iVar1 = parse_number(3.93700790);
    return iVar1;
  case 0x22:
    iVar1 = parse_number(100000.00000000);
    return iVar1;
  case 0x23:
    iVar1 = parse_number(100.00000000);
    return iVar1;
  case 0x24:
    iVar1 = parse_number(1.00000000);
    return iVar1;
  case 0x25:
    __isoc99_sscanf(yytext,&DAT_0814a861,&yylval);
    return 0x102;
  case 0x26:
    dVar15 = c_strtod(yytext);
    yylval = (char *)(float)dVar15;
    return 0x104;
  case 0x27:
    if (yyleng == 2) {
      yylval = (char *)0x0;
    }
    else {
      Number = yyleng - 1;
      yyleng = yyleng + -2;
      pcVar2 = (char *)MyCalloc(Number,1,"LEX");
      pcVar10 = yytext;
      yylval = pcVar2;
      while (yyleng != 0) {
        pcVar7 = pcVar10 + 1;
        cVar12 = *pcVar7;
        iVar1 = yyleng + -1;
        if (cVar12 == '\\') {
          pcVar7 = pcVar10 + 2;
          cVar12 = *pcVar7;
          iVar1 = yyleng + -2;
        }
        yyleng = iVar1;
        *pcVar2 = cVar12;
        pcVar2 = pcVar2 + 1;
        pcVar10 = pcVar7;
      }
      yyleng = yyleng + -1;
      *pcVar2 = '\0';
    }
    return 0x105;
  case 0x28:
  case 0x29:
  case 0x2a:
  case 0x2b:
    goto LAB_080ad4fc;
  case 0x2c:
    return (int)*yytext;
  case 0x2d:
    fwrite(yytext,yyleng,1,(FILE *)yyout);
    goto LAB_080ad4fc;
  case 0x2e:
    break;
  case 0x2f:
    return 0;
  }
  iVar6 = -1 - (int)yytext;
  *pbVar13 = yy_hold_char;
  local_24 = yy_current_buffer;
  iVar1 = yy_n_chars;
  if (yy_current_buffer->yy_buffer_status == 0) {
    iVar1 = yy_current_buffer->yy_n_chars;
    yy_n_chars = iVar1;
    yy_current_buffer->yy_input_file = yyin;
    local_24->yy_buffer_status = 1;
  }
  pcVar2 = yytext;
  pcVar10 = local_24->yy_ch_buf;
  if (pcVar10 + iVar1 < yy_c_buf_p) {
    if (pcVar10 + iVar1 + 1 < yy_c_buf_p) {
      yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
      local_24 = yy_current_buffer;
    }
    if (local_24->yy_fill_buffer == 0) {
      local_28 = (yy_state_type *)yytext;
      if (yy_c_buf_p + -(int)yytext != &DAT_00000001) goto LAB_080ad88e;
    }
    else {
      pcVar7 = yy_c_buf_p + (-1 - (int)yytext);
      if (0 < (int)pcVar7) {
        pcVar3 = (char *)0x0;
        do {
          pcVar10[(int)pcVar3] = pcVar2[(int)pcVar3];
          pcVar3 = pcVar3 + 1;
          local_24 = yy_current_buffer;
        } while (pcVar3 != pcVar7);
      }
      if (local_24->yy_buffer_status == 2) {
        yy_n_chars = 0;
        local_24->yy_n_chars = 0;
LAB_080adbbe:
        if (pcVar7 == (char *)0x0) {
          yyrestart(yyin);
          iVar9 = 1;
          local_24 = yy_current_buffer;
          iVar1 = yy_n_chars;
        }
        else {
          iVar9 = 2;
          local_24->yy_buffer_status = 2;
          iVar1 = yy_n_chars;
        }
      }
      else {
        sVar8 = ~(uint)pcVar7 + local_24->yy_buf_size;
        if ((int)sVar8 < 1) {
          do {
            yy_fatal_error(
                          "input buffer overflow, can\'t enlarge buffer because scanner uses REJECT"
                          );
          } while( true );
        }
        __n = 0x2000;
        if ((int)sVar8 < 0x2001) {
          __n = sVar8;
        }
        sVar8 = 0;
        if (local_24->yy_is_interactive == 0) {
          yy_n_chars = fread(local_24->yy_ch_buf + (int)pcVar7,1,__n,(FILE *)yyin);
          sVar8 = yy_n_chars;
          if ((yy_n_chars == 0) && (iVar1 = ferror((FILE *)yyin), sVar8 = yy_n_chars, iVar1 != 0)) {
            yy_fatal_error("input in flex scanner failed");
            sVar8 = yy_n_chars;
          }
        }
        else {
          do {
            iVar1 = _IO_getc((_IO_FILE *)yyin);
            if (iVar1 == -1) {
              iVar1 = ferror((FILE *)yyin);
              if (iVar1 != 0) {
                yy_fatal_error("input in flex scanner failed");
              }
              break;
            }
            if (iVar1 == 10) {
              yy_current_buffer->yy_ch_buf[(int)(pcVar7 + sVar8)] = '\n';
              sVar8 = sVar8 + 1;
              break;
            }
            pcVar10 = pcVar7 + sVar8;
            sVar8 = sVar8 + 1;
            yy_current_buffer->yy_ch_buf[(int)pcVar10] = (char)iVar1;
          } while ((int)sVar8 < (int)__n);
        }
        yy_n_chars = sVar8;
        iVar1 = yy_n_chars;
        local_24 = yy_current_buffer;
        iVar9 = 0;
        bVar14 = yy_n_chars == 0;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        if (bVar14) goto LAB_080adbbe;
      }
      yy_n_chars = (int)(pcVar7 + iVar1);
      local_24->yy_ch_buf[yy_n_chars] = '\0';
      yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = '\0';
      local_24 = yy_current_buffer;
      yytext = yy_current_buffer->yy_ch_buf;
      if (iVar9 != 1) {
        local_28 = (yy_state_type *)yytext;
        if (iVar9 != 2) {
          local_28 = yy_state_buf;
          yy_c_buf_p = (char *)((byte *)yytext + (int)(pbVar13 + iVar6));
          yy_state_buf[0] = yy_start;
          iVar1 = yy_start;
          local_24 = (YY_BUFFER_STATE)yytext;
          while (local_28 = local_28 + 1, yy_state_ptr = local_28, local_24 < yy_c_buf_p) {
            bVar11 = 1;
            if (*(byte *)local_24 != 0) {
              bVar11 = *(byte *)(yy_ec + *(byte *)local_24);
            }
            while( true ) {
              iVar6 = (int)yy_base[iVar1] + (uint)bVar11;
              if (iVar1 == (int)yy_chk[iVar6]) break;
              iVar1 = (int)yy_def[iVar1];
              if (0xb3 < iVar1) {
                bVar11 = *(byte *)(yy_meta + (uint)bVar11);
              }
            }
            iVar1 = (int)yy_nxt[iVar6];
            local_24 = (YY_BUFFER_STATE)((byte *)local_24 + 1);
            *local_28 = iVar1;
          }
          local_28 = (yy_state_type *)yytext;
          goto LAB_080adcba;
        }
LAB_080ad88e:
        local_2c = yy_state_buf;
        pbVar13 = (byte *)(local_24->yy_ch_buf + yy_n_chars);
        local_24 = (YY_BUFFER_STATE)local_28;
        yy_state_buf[0] = yy_start;
        iVar1 = yy_start;
        while (local_2c = local_2c + 1, local_24 < pbVar13) {
          bVar11 = 1;
          if (*(byte *)local_24 != 0) {
            bVar11 = *(byte *)(yy_ec + *(byte *)local_24);
          }
          while( true ) {
            iVar6 = (int)yy_base[iVar1] + (uint)bVar11;
            if (iVar1 == (int)yy_chk[iVar6]) break;
            iVar1 = (int)yy_def[iVar1];
            if (0xb3 < iVar1) {
              bVar11 = *(byte *)(yy_meta + (uint)bVar11);
            }
          }
          iVar1 = (int)yy_nxt[iVar6];
          local_24 = (YY_BUFFER_STATE)((byte *)local_24 + 1);
          *local_2c = iVar1;
        }
        goto LAB_080ad5a1;
      }
    }
    yy_did_buffer_switch_on_eof = 0;
    iVar1 = yywrap();
    if (iVar1 == 0) {
      if (yy_did_buffer_switch_on_eof == 0) {
        yyrestart(yyin);
      }
      goto LAB_080ad4fc;
    }
    yy_c_buf_p = yytext;
    iVar1 = (yy_start + -1) / 2 + 0x2f;
    goto LAB_080ad655;
  }
  local_28 = (yy_state_type *)yytext;
  local_2c = yy_state_buf;
  pbVar13 = (byte *)(yytext + (int)(pbVar13 + iVar6));
  yy_state_buf[0] = yy_start;
  iVar1 = yy_start;
  pbVar5 = (byte *)yytext;
  yy_c_buf_p = (char *)pbVar13;
  while (local_2c = local_2c + 1, pbVar5 < pbVar13) {
    if (*pbVar5 == 0) {
      local_24._0_1_ = 1;
    }
    else {
      local_24._0_1_ = *(byte *)(yy_ec + *pbVar5);
    }
    while( true ) {
      iVar6 = (int)yy_base[iVar1] + (uint)(byte)local_24;
      if (iVar1 == (int)yy_chk[iVar6]) break;
      iVar1 = (int)yy_def[iVar1];
      if (0xb3 < iVar1) {
        local_24._0_1_ = *(byte *)(yy_meta + (uint)(byte)local_24);
      }
    }
    pbVar5 = pbVar5 + 1;
    iVar1 = (int)yy_nxt[iVar6];
    *local_2c = iVar1;
  }
  while( true ) {
    iVar6 = (int)yy_base[iVar1];
    if (iVar1 == (int)*(short *)(iVar6 + 0x814b261 + iVar6 + 1)) break;
    iVar1 = (int)yy_def[iVar1];
  }
  iVar1 = (int)*(short *)(iVar6 + 0x814b4a1 + iVar6 + 1);
  if (iVar1 == 0xb3) goto LAB_080ad5a1;
  *local_2c = iVar1;
  local_2c = local_2c + 1;
  pbVar13 = (byte *)yy_c_buf_p;
  if (iVar1 != 0) goto LAB_080adecd;
  goto LAB_080ad5a1;
LAB_080adecd:
  yy_c_buf_p = yy_c_buf_p + 1;
  yy_state_ptr = local_2c;
LAB_080adcba:
  local_24 = (YY_BUFFER_STATE)yy_state_ptr;
  goto LAB_080ad51c;
}



int yywrap(void)

{
  return 1;
}



int yyerror(char *s)

{
  Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n",yyfilename,
          yylineno,s);
  return 0;
}



// WARNING: Type propagation algorithm not settling

int yyparse(void)

{
  uint *puVar1;
  byte Direction;
  Cardinal CVar2;
  LineTypePtr pLVar3;
  Cardinal CVar4;
  LineTypePtr pLVar5;
  uint uVar6;
  FontTypePtr __src;
  PCBTypePtr pPVar7;
  DataTypePtr *Data;
  ElementTypePtr *pEVar8;
  rtree_t *rtree;
  uint flags;
  PCBTypePtr __dest;
  int iVar9;
  int iVar10;
  void **ppvVar11;
  int iVar12;
  FlagType *pFVar13;
  SymbolType *pSVar14;
  Cardinal *pCVar15;
  BDimension *pBVar16;
  ulong *puVar17;
  LineTypePtr *ppLVar18;
  FlagType *pFVar19;
  Cardinal *pCVar20;
  BDimension *pBVar21;
  int in_GS_OFFSET;
  byte bVar22;
  char *local_d3c;
  FontTypePtr local_d38;
  code *local_d34;
  char *local_d30;
  FontTypePtr local_d2c;
  LineTypePtr local_d28;
  PCBTypePtr local_d24;
  PCBTypePtr local_d20;
  PCBTypePtr local_d1c;
  PCBTypePtr local_d18;
  PCBTypePtr local_d14;
  PCBTypePtr local_d10;
  PCBTypePtr local_d0c;
  FlagType in_stack_fffff2f8;
  undefined4 local_cfc;
  FlagType *local_cec;
  FlagType *local_ce8;
  FlagType *local_ce4;
  PCBTypePtr local_ce0;
  PCBTypePtr local_cd0;
  PCBTypePtr local_ccc;
  PCBTypePtr local_cc8;
  PCBTypePtr local_cc4;
  PCBTypePtr local_cc0;
  PCBTypePtr local_cbc;
  PCBTypePtr local_cb8;
  PCBTypePtr local_cb4;
  int local_cb0;
  uint local_cac;
  int local_ca8;
  FontTypePtr local_ca4;
  uint local_ca0;
  uint local_c9c;
  PCBTypePtr local_c98;
  FontTypePtr local_c94;
  int local_c90;
  FlagType local_c8c [2];
  YYSTYPE_conflict yyvsa [200];
  yytype_int16 yyssa [200];
  FlagType local_184;
  FlagType local_178;
  FlagType local_16c;
  FlagType local_160;
  FlagType local_154;
  FlagType local_148;
  FlagType local_13c;
  FlagType local_130;
  FlagType local_124;
  FlagType local_118;
  FlagType local_10c;
  FlagType local_100;
  FlagType local_f4;
  FlagType local_e8;
  FlagType local_dc;
  FlagType local_d0;
  FlagType local_c4;
  FlagType local_b8;
  FlagType local_ac;
  FlagType local_a0;
  FlagType local_94;
  FlagType local_88;
  FlagType local_7c;
  FlagType local_70;
  FlagType local_64;
  FlagType local_58;
  FlagType local_4c;
  FlagType local_40;
  char *yyval;
  LineTypePtr local_30;
  Cardinal local_2c;
  char p_number [8];
  int local_20;
  
  bVar22 = 0;
  pPVar7 = (PCBTypePtr)yyssa;
  iVar10 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_c94 = (FontTypePtr)yyvsa;
  local_ce0 = pPVar7;
  local_c98 = pPVar7;
  yynerrs = 0;
  yychar = -2;
  local_ca0 = 200;
  local_cb0 = 0;
  local_ca8 = 199;
  local_cec = &local_184;
  local_ce8 = &local_178;
  local_ce4 = &local_16c;
  __src = (FontTypePtr)yyvsa;
  do {
    *(short *)&pPVar7->ID = (short)iVar10;
    local_ca4 = __src;
    if ((PCBTypePtr)((int)&local_c98->ID + local_ca8 * 2) <= pPVar7) {
      local_ccc = pPVar7;
      if (local_ca0 < 10000) {
        local_ca0 = local_ca0 * 2;
        if (10000 < local_ca0) {
          local_ca0 = 10000;
        }
        local_c9c = local_ca0 * 2;
        __dest = (PCBTypePtr)calloc(1,local_ca0 * 0xe + 0xb);
        if (__dest != (PCBTypePtr)0x0) {
          local_c94 = (FontTypePtr)(((int)((int)local_ccc - (int)local_c98) >> 1) + 1);
          local_ccc = (PCBTypePtr)((int)local_c94 * 2);
          memcpy(__dest,local_c98,(size_t)local_ccc);
          local_d34 = (code *)(((int)&local_c94->MaxHeight + (int)&local_ccc->ID) * 4);
          local_ca4 = (FontTypePtr)(&__dest->ID + ((local_c9c + 0xb) / 0xc) * 3);
          memcpy(local_ca4,__src,(size_t)local_d34);
          if (local_ce0 != local_c98) {
            free(local_c98);
          }
          pPVar7 = (PCBTypePtr)((int)&__dest->ID + &local_c94[-1].field_0x1c1b * 2);
          local_ca8 = local_ca0 - 1;
          if (pPVar7 < (PCBTypePtr)((int)&__dest->ID + (local_ca0 - 1) * 2)) {
            local_c98 = __dest;
            local_c94 = (FontTypePtr)(&local_ca4->MaxHeight + &local_c94[-1].field_0x1c1b * 3);
            local_d38 = __src;
            goto yybackup;
          }
          iVar10 = 0;
          iVar12 = 1;
          local_c98 = __dest;
          goto LAB_080aece1;
        }
      }
      iVar12 = 2;
      Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n");
      iVar10 = 0;
      pPVar7 = local_ccc;
      goto LAB_080aece1;
    }
yybackup:
    iVar12 = (int)yypact[iVar10];
    if (iVar12 != -0x1a8) {
      if (yychar == -2) {
        local_ccc = pPVar7;
        yychar = yylex();
        pPVar7 = local_ccc;
      }
      __src = local_c94;
      if (yychar < 1) {
        yychar = 0;
        flags = 0;
      }
      else {
        flags = 2;
        if ((uint)yychar < 0x124) {
          flags = (uint)""[yychar];
        }
      }
      uVar6 = flags + iVar12;
      if ((0x24d < uVar6) || ((int)yycheck[uVar6] != flags)) goto yydefault;
      iVar10 = (int)yytable[uVar6];
      if (iVar10 < 1) {
        if ((iVar10 == -0x5d) || (iVar10 == 0)) goto yyerrlab;
        local_c9c = -iVar10;
        goto yyreduce;
      }
      if (iVar10 != 10) {
        local_cb0 = local_cb0 + -1 + (uint)(local_cb0 == 0);
        iVar12 = -2;
        if (yychar == 0) {
          iVar12 = yychar;
        }
        pCVar15 = (Cardinal *)&local_c94->MaxWidth;
        local_c94 = (FontTypePtr)(pCVar15 + 2);
        *(char **)&((FontTypePtr)(pCVar15 + 2))->MaxHeight = yylval;
        *(Cardinal *)&__src->DefaultSymbol = DAT_08195a30;
        *(Cardinal *)&__src->DefaultSymbol = DAT_08195a34;
        yychar = iVar12;
        goto yynewstate;
      }
yyreturn:
      iVar10 = 0;
      iVar12 = 0;
LAB_080aece1:
      __dest = (PCBTypePtr)((int)&pPVar7->ID + iVar10);
      pPVar7 = local_c98;
      if (local_c98 != __dest) {
        pPVar7 = (PCBTypePtr)
                 ((int)&__dest->ID + (~((int)__dest + (-2 - (int)local_c98)) & 0xfffffffeU));
      }
LAB_080ae3a3:
      if (local_ce0 != pPVar7) {
        free(local_c98);
      }
      if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
        return iVar12;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
yydefault:
    local_c9c = (uint)""[iVar10];
    if (""[iVar10] == 0) {
yyerrlab:
      if (local_cb0 == 0) {
        yynerrs = yynerrs + 1;
        local_d30 = "syntax error";
        local_d38 = (FontTypePtr)yyfilename;
        local_d34 = (code *)yylineno;
        local_ccc = pPVar7;
        Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n");
        __src = local_c94;
        __dest = local_c98;
        pPVar7 = local_ccc;
      }
      else {
        __src = local_c94;
        __dest = local_c98;
        if (local_cb0 == 3) {
          if (yychar < 1) {
            if (yychar == 0) {
              iVar10 = 0;
              iVar12 = 1;
              goto LAB_080aece1;
            }
          }
          else {
            yychar = -2;
          }
        }
      }
      while ((((iVar12 == -0x1a8 || (flags = iVar12 + 1, 0x24d < flags)) ||
              (*(short *)(iVar12 + 0x814c521 + flags) != 1)) ||
             (iVar10 = (int)*(short *)(iVar12 + 0x814c9c1 + flags), iVar10 < 1))) {
        if (pPVar7 == __dest) {
          iVar12 = 1;
          pPVar7 = local_c98;
          goto LAB_080ae3a3;
        }
        pPVar7 = (PCBTypePtr)((int)&pPVar7[-1].Data + 2);
        iVar12 = (int)yypact[*(short *)&pPVar7->ID];
        __src = (FontTypePtr)&__src[-1].Symbol[0xff].Height;
      }
      local_c94 = __src;
      if (iVar10 != 10) {
        local_c94 = (FontTypePtr)(&__src->MaxWidth + 2);
        *(char **)&((FontTypePtr)(&__src->MaxWidth + 2))->MaxHeight = yylval;
        *(Cardinal *)&__src->DefaultSymbol = DAT_08195a30;
        *(Cardinal *)&__src->DefaultSymbol = DAT_08195a34;
        local_cb0 = 3;
        goto yynewstate;
      }
      goto yyreturn;
    }
yyreduce:
    __src = local_c94;
    Data = yyData;
    pEVar8 = yyElement;
    __dest = yyPCB;
    local_cac = (uint)""[local_c9c];
    iVar10 = 1 - local_cac;
    yyval = (char *)(&local_c94->MaxHeight)[iVar10 * 3];
    local_30 = (LineTypePtr)(&local_c94->MaxWidth)[iVar10 * 3];
    local_2c = (&local_c94->MaxWidth)[iVar10 * 3 + 1];
    switch(local_c9c) {
    case 5:
    case 0x3f:
      iVar12 = 1;
      iVar10 = local_cac * -2;
      goto LAB_080aece1;
    case 6:
      if (yyPCB != (PCBTypePtr)0x0) {
        iVar10 = 0;
        do {
          LayerFlag[iVar10] = '\0';
          iVar10 = iVar10 + 1;
        } while (iVar10 != 0x12);
        layer_group_string = (char *)0x0;
        yyFont = (FontTypePtr)&yyPCB->Font;
        Data = yyPCB->Data;
        yyData = Data;
        *(PCBTypePtr *)&Data->field_0x48 = yyPCB;
        Data->LayerN = 0;
        break;
      }
LAB_080b088f:
      local_d3c = "illegal fileformat\n";
      local_ccc = pPVar7;
LAB_080b0885:
      Message(local_d3c);
      goto LAB_080af56c;
    case 7:
      local_cb8 = PCB;
      if (layer_group_string == (char *)0x0) {
        layer_group_string = Settings.Groups;
      }
      local_ccc = pPVar7;
      CreateNewPCBPost(yyPCB,0);
      local_d34 = (code *)yyData->LayerN;
      local_d38 = (FontTypePtr)&yyPCB->LayerGroups;
      iVar10 = ParseGroupString(layer_group_string,(LayerGroupTypePtr)local_d38,(int)local_d34);
      if (iVar10 != 0) {
        local_d3c = "illegal layer-group string\n";
        goto LAB_080b0885;
      }
      local_cb4 = (PCBTypePtr)0x0;
      PCB = yyPCB;
      pPVar7 = local_ccc;
      if (-2 < yyData->LayerN) {
        local_cbc = local_ccc;
        Data = yyData;
        do {
          iVar10 = (int)local_cb4 * 0x5c;
          if (*(int *)(&Data->field_0x58 + iVar10) != 0) {
            flags = 0;
            do {
              iVar12 = flags * 0x3c;
              flags = flags + 1;
              local_d34 = (code *)(iVar12 + *(int *)(&Data->field_0x78 + iVar10));
              local_d38 = (FontTypePtr)(&Data->field_0x4c + iVar10);
              InitClip(Data,(LayerTypePtr)local_d38,(PolygonType *)local_d34);
              puVar1 = (uint *)(&yyData->field_0x58 + iVar10);
              Data = yyData;
            } while (flags <= *puVar1 && *puVar1 != flags);
          }
          local_cb4 = (PCBTypePtr)((int)&local_cb4->ID + 1);
          pPVar7 = local_cbc;
        } while ((int)local_cb4 <= Data->LayerN + 1);
      }
      PCB = local_cb8;
      break;
    case 8:
      local_ccc = pPVar7;
      PreLoadElementPCB();
      layer_group_string = (char *)0x0;
      pPVar7 = local_ccc;
      break;
    case 9:
      LayerFlag[0] = '\x01';
      LayerFlag[1] = '\x01';
      yyData->LayerN = 2;
      local_ccc = pPVar7;
      PostLoadElementPCB();
      pPVar7 = local_ccc;
      break;
    case 10:
      if ((yyData == (DataTypePtr *)0x0) || (yyFont == (FontTypePtr)0x0)) goto LAB_080b088f;
      iVar10 = 0;
      do {
        LayerFlag[iVar10] = '\0';
        iVar10 = iVar10 + 1;
      } while (iVar10 != 0x12);
      yyData->LayerN = 0;
      break;
    case 0xe:
      if (yyFont == (FontTypePtr)0x0) {
        local_ccc = pPVar7;
        Message("illegal fileformat\n");
        goto LAB_080af56c;
      }
      yyFont->Valid = '\0';
      __src = yyFont;
      iVar10 = 0;
      do {
        (&__src->Symbol[0].Valid)[iVar10] = '\0';
        iVar10 = iVar10 + 0x1c;
      } while (iVar10 != 0x1c00);
      break;
    case 0xf:
      yyFont->Valid = '\x01';
      local_ccc = pPVar7;
      SetFontInfo(yyFont);
      pPVar7 = local_ccc;
      break;
    case 0x11:
      if (0x1324007 < local_c94[-1].Symbol[0xff].Height) {
        local_ccc = pPVar7;
        Message(
               "ERROR:  The file you are attempting to load is in a format\nwhich is too new for this version of pcb.  To load this file\nyou need a version of pcb which is >= %d.  If you are\nusing a version built from cvs sources, the source date\nmust be >= %d.  This copy of pcb can only read files\nup to file version %d.\n"
               );
        goto LAB_080af56c;
      }
      break;
    case 0x12:
      local_d3c = (char *)local_c94[-1].Symbol[0xff].Height;
      yyPCB->MaxWidth = 10000000;
      __dest->MaxHeight = 10000000;
      __dest->Name = local_d3c;
      break;
    case 0x13:
      yyPCB->Name = (char *)local_c94[-1].Symbol[0xfe].Delta;
      __dest->MaxWidth = local_c94[-1].Symbol[0xff].LineN * 100;
      __dest->MaxHeight = local_c94[-1].Symbol[0xff].Height * 100;
      break;
    case 0x14:
      yyPCB->Name = (char *)local_c94[-1].Symbol[0xfe].Delta;
      __dest->MaxWidth = local_c94[-1].Symbol[0xff].LineN;
      __dest->MaxHeight = local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x19:
      local_c90 = local_c94[-1].Symbol[0xfe].Delta * 100;
      yyPCB->Grid = (double)local_c90;
      __dest->GridOffsetX = local_c94[-1].Symbol[0xff].LineN * 100;
      __dest->GridOffsetY = local_c94[-1].Symbol[0xff].Height * 100;
      break;
    case 0x1a:
      local_c90 = local_c94[-1].Symbol[0xfe].LineMax * 100;
      yyPCB->Grid = (double)local_c90;
      __dest->GridOffsetX = local_c94[-1].Symbol[0xfe].Delta * 100;
      __dest->GridOffsetY = local_c94[-1].Symbol[0xff].LineN * 100;
      Settings.DrawGrid = local_c94[-1].Symbol[0xff].Height != 0;
      break;
    case 0x1b:
      yyPCB->Grid = (double)((float)local_c94[-1].Symbol[0xfe].LineMax * 100.00000000);
      __dest->GridOffsetX = local_c94[-1].Symbol[0xfe].Delta * 100;
      __dest->GridOffsetY = local_c94[-1].Symbol[0xff].LineN * 100;
      Settings.DrawGrid = local_c94[-1].Symbol[0xff].Height != 0;
      break;
    case 0x1c:
      yyPCB->Grid = (double)(float)local_c94[-1].Symbol[0xfe].LineMax;
      __dest->GridOffsetX = local_c94[-1].Symbol[0xfe].Delta;
      __dest->GridOffsetY = local_c94[-1].Symbol[0xff].LineN;
      Settings.DrawGrid = local_c94[-1].Symbol[0xff].Height != 0;
      break;
    case 0x1d:
      yyPCB->CursorX = local_c94[-1].Symbol[0xfe].Delta * 100;
      __dest->CursorY = local_c94[-1].Symbol[0xff].LineN * 100;
      local_c90 = local_c94[-1].Symbol[0xff].Height * 2;
      __dest->Zoom = (double)local_c90;
      break;
    case 0x1e:
      yyPCB->CursorX = local_c94[-1].Symbol[0xfe].Delta;
      __dest->CursorY = local_c94[-1].Symbol[0xff].LineN;
      __dest->Zoom = (double)local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x1f:
      yyPCB->CursorX = local_c94[-1].Symbol[0xfe].Delta;
      __dest->CursorY = local_c94[-1].Symbol[0xff].LineN;
      __dest->Zoom = (double)(float)local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x22:
      yyPCB->IsleArea = (double)(float)local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x24:
      yyPCB->ThermScale = (double)(float)local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x29:
      yyPCB->Bloat = local_c94[-1].Symbol[0xfe].Delta;
      __dest->Shrink = local_c94[-1].Symbol[0xff].LineN;
      __dest->minWid = local_c94[-1].Symbol[0xff].Height;
      __dest->minRing = local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x2a:
      yyPCB->Bloat = local_c94[-1].Symbol[0xfe].LineMax;
      __dest->Shrink = local_c94[-1].Symbol[0xfe].Delta;
      __dest->minWid = local_c94[-1].Symbol[0xff].LineN;
      __dest->minSlk = local_c94[-1].Symbol[0xff].Height;
      __dest->minRing = local_c94[-1].Symbol[0xff].LineN;
      break;
    case 0x2b:
      yyPCB->Bloat = local_c94[-1].Symbol[0xfd].Width;
      *(LineTypePtr *)&__dest->Shrink = local_c94[-1].Symbol[0xfe].Line;
      __dest->minWid = local_c94[-1].Symbol[0xfe].LineMax;
      __dest->minSlk = local_c94[-1].Symbol[0xfe].Delta;
      __dest->minDrill = local_c94[-1].Symbol[0xff].LineN;
      __dest->minRing = local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x2c:
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xff].Height & 0xfffff);
      local_ccc = pPVar7;
      MakeFlags(local_c8c,(uint)local_d38);
      goto LAB_080af5e9;
    case 0x2d:
      local_d34 = yyerror;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_ccc = pPVar7;
      string_to_pcbflags(local_c8c,(char *)local_d38,yyerror);
LAB_080af5e9:
      iVar10 = 3;
      pFVar13 = local_c8c;
      pFVar19 = &__dest->Flags;
      while (pPVar7 = local_ccc, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        pFVar19->f = pFVar13->f;
        pFVar13 = (FlagType *)(&pFVar13->f + (uint)bVar22 * 0x3ffffffe + 1);
        pFVar19 = (FlagType *)((int)pFVar19 + (uint)bVar22 * -8 + 4);
      }
      break;
    case 0x2f:
      layer_group_string = (char *)local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x31:
      local_d34 = (code *)0x64;
      local_d3c = (char *)local_c94[-1].Symbol[0xff].Height;
      goto LAB_080af544;
    case 0x32:
      local_d34 = (code *)&DAT_00000001;
      local_d3c = (char *)local_c94[-1].Symbol[0xff].Height;
LAB_080af544:
      local_d38 = (FontTypePtr)yyPCB->RouteStyle;
      local_ccc = pPVar7;
      iVar10 = ParseRouteString(local_d3c,(RouteStyleTypePtr)local_d38,(int)local_d34);
      pPVar7 = local_ccc;
      if (iVar10 != 0) {
        Message("illegal route-style string\n");
LAB_080af56c:
        iVar12 = 1;
        iVar10 = local_cac * -2;
        pPVar7 = local_ccc;
        goto LAB_080aece1;
      }
      break;
    case 0x39:
      attr_list = (AttributeListTypePtr)&yyPCB->Attributes;
      break;
    case 0x3d:
      yyElement = (ElementTypePtr *)0x0;
      break;
    case 0x45:
      iVar10 = 3;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      pBVar21 = (BDimension *)&stack0xfffff2e4;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pBVar21 = *pBVar16;
        pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
        pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfe].Line;
      local_d30 = (char *)local_c94[-1].Symbol[0xfd].Width;
      local_d34 = *(code **)&local_c94[-1].Symbol[0xfd].Valid;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xfc].Height;
      local_ccc = pPVar7;
      CreateNewVia(yyData,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   (BDimension)local_d2c,(BDimension)local_d28,(BDimension)local_d24,
                   (char *)local_d20,(FlagType)CONCAT48(local_d14,CONCAT44(local_d18,local_d1c)));
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x46:
      local_ccc = pPVar7;
      OldFlags(&local_40,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      pFVar13 = &local_40;
      puVar17 = (ulong *)&stack0xfffff2e4;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d28 = (LineTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d2c = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d34 = (code *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].Height * 100);
      goto LAB_080b0547;
    case 0x47:
      local_ccc = pPVar7;
      OldFlags(&local_4c,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_cb4 = (PCBTypePtr)__src[-1].Symbol[0xfe].Line;
      CVar2 = __src[-1].Symbol[0xfe].LineMax;
      pFVar13 = &local_4c;
      puVar17 = (ulong *)&stack0xfffff2e4;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d28 = (LineTypePtr)(((int)&local_cb4->ID + CVar2) * 100);
      local_d2c = (FontTypePtr)(CVar2 * 100);
      local_d30 = (char *)((int)local_cb4 * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      goto LAB_080b0547;
    case 0x48:
      local_ccc = pPVar7;
      OldFlags(&local_58,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d30 = (char *)(__src[-1].Symbol[0xfe].LineMax * 100);
      pFVar13 = &local_58;
      puVar17 = (ulong *)&stack0xfffff2e4;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d2c = (FontTypePtr)0xbb8;
      local_d28 = (LineTypePtr)((char **)((FontTypePtr)local_d30)->Symbol + 0x68);
      local_d34 = (code *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
LAB_080b0547:
      CreateNewVia(yyData,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   (BDimension)local_d2c,(BDimension)local_d28,(BDimension)local_d24,
                   (char *)local_d20,(FlagType)CONCAT48(local_d14,CONCAT44(local_d18,local_d1c)));
LAB_080afabe:
      SaveFree((void *)local_c94[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x49:
      iVar10 = local_c94[-1].Symbol[0xfe].Delta;
      __src = local_c94 + -1;
      local_d24 = (PCBTypePtr)(iVar10 * 0x28);
      if ((iVar10 * -0x27 < 400) && (400 < iVar10)) {
        local_d24 = (PCBTypePtr)(iVar10 + -400);
      }
      local_ccc = pPVar7;
      OldFlags(&local_64,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d30 = (char *)(__src->Symbol[0xfe].Delta * 100);
      pFVar13 = &local_64;
      puVar17 = (ulong *)&stack0xfffff2e4;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d2c = (FontTypePtr)0xbb8;
      local_d28 = (LineTypePtr)((char **)((FontTypePtr)local_d30)->Symbol + 0x68);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d38 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      CreateNewVia(yyData,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,3000
                   ,(BDimension)local_d28,(BDimension)local_d24,(char *)local_d20,
                   (FlagType)CONCAT48(local_d14,CONCAT44(local_d18,local_d1c)));
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x4a:
      iVar10 = 3;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      pBVar21 = (BDimension *)&stack0xfffff2e4;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pBVar21 = *pBVar16;
        pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
        pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = local_c94[-1].Symbol[0xfe].Line;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d30 = (char *)local_c94[-1].Symbol[0xfe].LineMax;
      local_d34 = (code *)local_c94[-1].Symbol[0xfd].Width;
      local_d38 = *(FontTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      local_d20 = (PCBTypePtr)Settings.RatThickness;
      local_ccc = pPVar7;
      CreateNewRat(yyData,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30,
                   (LocationType)local_d2c,(Cardinal)local_d28,(Cardinal)local_d24,
                   Settings.RatThickness,(FlagType)CONCAT48(local_d14,CONCAT44(local_d18,local_d1c))
                  );
      pPVar7 = local_ccc;
      break;
    case 0x4b:
      local_ccc = pPVar7;
      OldFlags(&local_70,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      pFVar13 = &local_70;
      puVar17 = (ulong *)&stack0xfffff2e4;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = local_c94[-1].Symbol[0xfe].Line;
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      local_d20 = (PCBTypePtr)Settings.RatThickness;
      CreateNewRat(yyData,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30,
                   (LocationType)local_d2c,(Cardinal)local_d28,(Cardinal)local_d24,
                   Settings.RatThickness,(FlagType)CONCAT48(local_d14,CONCAT44(local_d18,local_d1c))
                  );
      pPVar7 = local_ccc;
      break;
    case 0x4c:
      CVar2 = local_c94[-1].Symbol[0xfe].LineMax;
      pCVar15 = &local_c94[-1].Symbol[0xfe].LineMax;
      flags = CVar2 - 1;
      if ((0x11 < flags) || (*(char *)(CVar2 + 0x817cb87) != '\0')) goto LAB_080b08bd;
      iVar10 = flags * 0x5c;
      Layer = (FontTypePtr)(&yyData->field_0x4c + iVar10);
      *(BDimension *)(&yyData->field_0x4c + iVar10) = local_c94[-1].Symbol[0xfe].Delta;
      *(undefined *)(*pCVar15 + 0x817cb87) = 1;
      CVar2 = *pCVar15;
      if (Data->LayerN + 2 < (int)CVar2) {
        Data->LayerN = CVar2 - 2;
      }
      break;
    case 0x58:
      local_ccc = pPVar7;
      OldFlags(&local_7c,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      CVar2 = local_c94[-1].Symbol[0xfe].LineMax;
      local_cb4 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Line;
      pFVar13 = &local_7c;
      puVar17 = (ulong *)&stack0xfffff2d8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d2c = (FontTypePtr)((CVar2 + local_c94[-1].Symbol[0xff].LineN) * 100);
      local_d30 = (char *)((local_c94[-1].Symbol[0xfe].Delta + (int)&local_cb4->ID) * 100);
      local_d34 = (code *)(CVar2 * 100);
      local_d38 = (FontTypePtr)((int)local_cb4 * 100);
      CreateNewPolygonFromRectangle
                ((LayerTypePtr)Layer,(LocationType)local_d38,(LocationType)local_d34,
                 (LocationType)local_d30,(LocationType)local_d2c,
                 (FlagType)CONCAT48(local_d20,CONCAT44(local_d24,local_d28)));
      pPVar7 = local_ccc;
      break;
    case 0x5c:
      attr_list = (AttributeListTypePtr)Layer->Symbol;
      break;
    case 0x5e:
      iVar10 = 3;
      pCVar15 = &local_c94[-1].Symbol[0xff].LineN;
      pCVar20 = (Cardinal *)&stack0xfffff2c8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pCVar20 = *pCVar15;
        pCVar15 = pCVar15 + (uint)bVar22 * 0x3ffffffe + 1;
        pCVar20 = pCVar20 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_ccc = pPVar7;
      Polygon = (FontTypePtr)
                CreateNewPolygon((LayerTypePtr)Layer,
                                 (FlagType)CONCAT48(local_d30,CONCAT44(local_d34,local_d38)));
      pPVar7 = local_ccc;
      break;
    case 0x5f:
      if (*(LineTypePtr *)Polygon->Symbol < (LineTypePtr)0x3) {
        local_ccc = pPVar7;
        Message(
               "WARNING parsing file \'%s\'\n    line:        %i\n    description: \'ignored polygon (< 3 points)\'\n"
               );
        local_d38 = (FontTypePtr)&DAT_00000008;
        local_d34 = (code *)Layer;
        local_d30 = (char *)Polygon;
        local_d2c = Polygon;
        DestroyObject(yyData,8,Layer,Polygon,Polygon);
        pPVar7 = local_ccc;
      }
      else {
        local_ccc = pPVar7;
        SetPolygonBoundingBox((PolygonTypePtr)Polygon);
        __src = Layer;
        rtree = *(rtree_t **)Layer->Symbol;
        if (rtree == (rtree_t *)0x0) {
          rtree = r_create_tree((BoxType **)0x0,0,0);
          *(rtree_t **)__src->Symbol = rtree;
          rtree = *(rtree_t **)Layer->Symbol;
        }
        local_d34 = (code *)0x0;
        local_d38 = Polygon;
        r_insert_entry(rtree,(BoxType *)Polygon,0);
        pPVar7 = local_ccc;
      }
      break;
    case 0x60:
      iVar10 = 3;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      pBVar21 = (BDimension *)&stack0xfffff2e0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pBVar21 = *pBVar16;
        pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
        pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d30 = (char *)local_c94[-1].Symbol[0xfe].Line;
      local_d34 = (code *)local_c94[-1].Symbol[0xfd].Width;
      local_d38 = *(FontTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      local_ccc = pPVar7;
      CreateNewLineOnLayer
                ((LayerTypePtr)Layer,(LocationType)local_d38,(LocationType)local_d34,
                 (LocationType)local_d30,(LocationType)local_d2c,(BDimension)local_d28,
                 (BDimension)local_d24,(FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)));
      pPVar7 = local_ccc;
      break;
    case 0x61:
      local_ccc = pPVar7;
      OldFlags(&local_88,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      pFVar13 = &local_88;
      puVar17 = (ulong *)&stack0xfffff2e0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      CVar2 = local_c94[-1].Symbol[0xfe].Delta;
      CVar4 = local_c94[-1].Symbol[0xfe].LineMax;
      pLVar3 = local_c94[-1].Symbol[0xfe].Line;
      pLVar5 = (LineTypePtr)local_c94[-1].Symbol[0xfd].Width;
      iVar10 = *(int *)&local_c94[-1].Symbol[0xfd].Valid;
LAB_080b0133:
      local_d28 = (LineTypePtr)(CVar2 * 100);
      local_d2c = (FontTypePtr)(CVar4 * 100);
      local_d30 = (char *)((int)pLVar3 * 100);
      local_d34 = (code *)((int)pLVar5 * 100);
      local_d38 = (FontTypePtr)(iVar10 * 100);
      CreateNewLineOnLayer
                ((LayerTypePtr)Layer,(LocationType)local_d38,(LocationType)local_d34,
                 (LocationType)local_d30,(LocationType)local_d2c,(BDimension)local_d28,
                 (BDimension)local_d24,(FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)));
      pPVar7 = local_ccc;
      break;
    case 0x62:
      flags = local_c94[-1].Symbol[0xff].Height;
      if ((flags & 0x10) == 0) {
        local_ccc = pPVar7;
        OldFlags(&local_94,flags);
        iVar10 = 3;
        pFVar13 = &local_94;
        puVar17 = (ulong *)&stack0xfffff2e0;
        while (iVar10 != 0) {
          iVar10 = iVar10 + -1;
          *puVar17 = pFVar13->f;
          pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
          puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
        }
        local_d24 = (PCBTypePtr)0xbb8;
        CVar2 = __src[-1].Symbol[0xff].LineN;
        CVar4 = __src[-1].Symbol[0xfe].Delta;
        pLVar3 = (LineTypePtr)__src[-1].Symbol[0xfe].LineMax;
        pLVar5 = __src[-1].Symbol[0xfe].Line;
        iVar10 = __src[-1].Symbol[0xfd].Width;
        goto LAB_080b0133;
      }
      break;
    case 99:
      iVar10 = 3;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      pBVar21 = (BDimension *)&stack0xfffff2e8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pBVar21 = *pBVar16;
        pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
        pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Line;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfd].Width;
      local_d30 = *(char **)&local_c94[-1].Symbol[0xfd].Valid;
      local_d34 = (code *)local_c94[-1].Symbol[0xfc].Height;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xfc].LineN;
      local_ccc = pPVar7;
      CreateNewArcOnLayer((LayerTypePtr)Layer,(LocationType)local_d38,(LocationType)local_d34,
                          (BDimension)local_d30,(BDimension)local_d2c,(int)local_d28,(int)local_d24,
                          (BDimension)local_d20,(BDimension)local_d1c,
                          (FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      pPVar7 = local_ccc;
      break;
    case 100:
      local_ccc = pPVar7;
      OldFlags(&local_a0,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      pFVar13 = &local_a0;
      puVar17 = (ulong *)&stack0xfffff2e8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      pLVar3 = local_c94[-1].Symbol[0xfe].Line;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d30 = (char *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      iVar10 = local_c94[-1].Symbol[0xfc].Height;
      CVar2 = local_c94[-1].Symbol[0xfc].LineN;
      goto LAB_080affd4;
    case 0x65:
      local_ccc = pPVar7;
      OldFlags(&local_ac,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d30 = (char *)(local_c94[-1].Symbol[0xfd].Width * 100);
      pFVar13 = &local_ac;
      puVar17 = (ulong *)&stack0xfffff2e8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)0xbb8;
      pLVar3 = (LineTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      iVar10 = *(int *)&local_c94[-1].Symbol[0xfd].Valid;
      CVar2 = local_c94[-1].Symbol[0xfc].Height;
      local_d2c = (FontTypePtr)local_d30;
LAB_080affd4:
      local_d20 = (PCBTypePtr)((int)pLVar3 * 100);
      local_d34 = (code *)(iVar10 * 100);
      local_d38 = (FontTypePtr)(CVar2 * 100);
      CreateNewArcOnLayer((LayerTypePtr)Layer,(LocationType)local_d38,(LocationType)local_d34,
                          (BDimension)local_d30,(BDimension)local_d2c,(int)local_d28,(int)local_d24,
                          (BDimension)local_d20,(BDimension)local_d1c,
                          (FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      pPVar7 = local_ccc;
      break;
    case 0x66:
      local_ccc = pPVar7;
      OldFlags(&local_b8,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      pFVar13 = &local_b8;
      puVar17 = (ulong *)&stack0xfffff2e0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d24 = (PCBTypePtr)__src[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)0x64;
      Direction = *(byte *)&__src[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)(uint)Direction;
      local_d30 = (char *)(__src[-1].Symbol[0xfe].LineMax * 100);
      local_d34 = (code *)((int)__src[-1].Symbol[0xfe].Line * 100);
      local_d38 = yyFont;
      CreateNewText((LayerTypePtr)Layer,yyFont,(LocationType)local_d34,(LocationType)local_d30,
                    Direction,100,(char *)local_d24,
                    (FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)));
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x67:
      flags = local_c94[-1].Symbol[0xff].Height;
      if ((flags & 0x400) == 0) {
        local_ccc = pPVar7;
        OldFlags(&local_d0,flags);
        __src = local_c94;
        iVar10 = 3;
        pFVar13 = &local_d0;
        puVar17 = (ulong *)&stack0xfffff2e0;
        while (iVar10 != 0) {
          iVar10 = iVar10 + -1;
          *puVar17 = pFVar13->f;
          pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
          puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
        }
        ppvVar11 = (void **)&__src[-1].Symbol[0xff].LineN;
        local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
        local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        Direction = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        local_d2c = (FontTypePtr)(uint)Direction;
        local_d30 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
        local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
        local_d38 = yyFont;
        CreateNewText((LayerTypePtr)Layer,yyFont,(LocationType)local_d34,(LocationType)local_d30,
                      Direction,(int)local_d28,(char *)local_d24,
                      (FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)));
      }
      else {
        local_cb4 = (PCBTypePtr)
                    (&yyData->field_0x4c + (((flags >> 7 ^ 1) & 1) + yyData->LayerN) * 0x5c);
        local_ccc = pPVar7;
        OldFlags(&local_c4,flags);
        iVar10 = 3;
        ppvVar11 = (void **)&local_c94[-1].Symbol[0xff].LineN;
        pFVar13 = &local_c4;
        puVar17 = (ulong *)&stack0xfffff2e0;
        while (iVar10 != 0) {
          iVar10 = iVar10 + -1;
          *puVar17 = pFVar13->f;
          pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
          puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
        }
        local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
        local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        Direction = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        local_d2c = (FontTypePtr)(uint)Direction;
        local_d30 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
        local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
        local_d38 = yyFont;
        CreateNewText((LayerTypePtr)local_cb4,yyFont,(LocationType)local_d34,(LocationType)local_d30
                      ,Direction,(int)local_d28,(char *)local_d24,
                      (FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)));
      }
      goto LAB_080afe1c;
    case 0x68:
      local_cb8 = (PCBTypePtr)local_c94[-1].Symbol[0xff].Height;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      local_d38 = yyFont;
      if (((uint)local_cb8 & 0x400) == 0) {
        iVar10 = 3;
        pBVar21 = (BDimension *)&stack0xfffff2e0;
        while (iVar10 != 0) {
          iVar10 = iVar10 + -1;
          *pBVar21 = *pBVar16;
          pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
          pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
        }
        ppvVar11 = (void **)&__src[-1].Symbol[0xff].LineN;
        local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
        local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        Direction = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        local_d2c = (FontTypePtr)(uint)Direction;
        local_d30 = (char *)local_c94[-1].Symbol[0xfe].Line;
        local_d34 = (code *)local_c94[-1].Symbol[0xfd].Width;
        local_ccc = pPVar7;
        CreateNewText((LayerTypePtr)Layer,yyFont,(LocationType)local_d34,(LocationType)local_d30,
                      Direction,(int)local_d28,(char *)local_d24,
                      (FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)));
      }
      else {
        iVar10 = 3;
        pBVar21 = (BDimension *)&stack0xfffff2e0;
        while (iVar10 != 0) {
          iVar10 = iVar10 + -1;
          *pBVar21 = *pBVar16;
          pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
          pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
        }
        ppvVar11 = (void **)&__src[-1].Symbol[0xff].LineN;
        local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
        local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
        Direction = *(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
        local_d2c = (FontTypePtr)(uint)Direction;
        local_d30 = (char *)local_c94[-1].Symbol[0xfe].Line;
        local_d34 = (code *)local_c94[-1].Symbol[0xfd].Width;
        local_ccc = pPVar7;
        CreateNewText((LayerTypePtr)
                      (&yyData->field_0x4c +
                      ((((uint)local_cb8 >> 7 ^ 1) & 1) + yyData->LayerN) * 0x5c),yyFont,
                      (LocationType)local_d34,(LocationType)local_d30,Direction,(int)local_d28,
                      (char *)local_d24,(FlagType)CONCAT48(local_d18,CONCAT44(local_d1c,local_d20)))
        ;
      }
LAB_080afe1c:
      SaveFree(*ppvVar11);
      pPVar7 = local_ccc;
      break;
    case 0x6b:
      local_d34 = (code *)(local_c94[-1].Symbol[0xff].Height * 100);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      goto LAB_080afd4b;
    case 0x6c:
      local_d34 = (code *)local_c94[-1].Symbol[0xff].Height;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
LAB_080afd4b:
      local_ccc = pPVar7;
      CreateNewPointInPolygon
                ((PolygonTypePtr)Polygon,(LocationType)local_d38,(LocationType)local_d34);
      pPVar7 = local_ccc;
      break;
    case 0x73:
      local_ccc = pPVar7;
      MakeFlags(&local_dc,0);
      local_cd0 = (PCBTypePtr)(uint)*(byte *)&local_c94[-1].Symbol[0xff].LineN;
      local_cb8 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_cb4 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_cc0 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Line;
      local_cbc = (PCBTypePtr)local_c94[-1].Symbol[0xfd].Width;
      MakeFlags(&local_e8,0);
      iVar10 = 3;
      local_cfc = 0;
      pFVar13 = &local_dc;
      puVar17 = (ulong *)&stack0xfffff2f8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d0c = (PCBTypePtr)0x64;
      local_d1c = (PCBTypePtr)0x0;
      iVar10 = 3;
      pFVar13 = &local_e8;
      puVar17 = (ulong *)&stack0xfffff2d0;
      local_d24 = local_cbc;
      local_d20 = local_cc0;
      local_d18 = local_cb4;
      local_d14 = local_cb8;
      local_d10 = local_cd0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d38 = (FontTypePtr)yyElement;
      local_d34 = (code *)yyFont;
      yyElement = CreateNewElement(yyData,yyElement,yyFont,
                                   (FlagType)CONCAT48(local_d28,CONCAT44(local_d2c,local_d30)),
                                   (char *)local_d24,(char *)local_d20,(char *)local_d1c,
                                   (LocationType)local_d18,(LocationType)local_d14,(BYTE)local_d10,
                                   (int)local_d0c,in_stack_fffff2f8,(Boolean)local_cfc);
      __src = local_c94;
      SaveFree((void *)local_c94[-1].Symbol[0xfd].Width);
      SaveFree(__src[-1].Symbol[0xfe].Line);
      pin_num = 1;
      pPVar7 = local_ccc;
      break;
    case 0x74:
    case 0x76:
    case 0x78:
    case 0x7a:
    case 0x7c:
      local_d38 = (FontTypePtr)yyElement;
      local_d34 = (code *)yyFont;
      local_ccc = pPVar7;
      SetElementBoundingBox(yyData,(ElementTypePtr_conflict)yyElement,yyFont);
      pPVar7 = local_ccc;
      break;
    case 0x75:
      local_ccc = pPVar7;
      OldFlags(&local_f4,local_c94[-1].Symbol[0xff].LineN);
      local_cbc = (PCBTypePtr)(uint)*(byte *)&__src[-1].Symbol[0xfe].LineMax;
      local_cd0 = (PCBTypePtr)__src[-1].Symbol[0xfe].Delta;
      local_cb8 = (PCBTypePtr)((int)__src[-1].Symbol[0xfe].Line * 100);
      local_cb4 = (PCBTypePtr)(__src[-1].Symbol[0xfd].Width * 100);
      local_cc4 = *(PCBTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      local_cc0 = (PCBTypePtr)local_c94[-1].Symbol[0xfc].Height;
      OldFlags(&local_100,local_c94[-1].Symbol[0xfc].LineN);
      iVar10 = 3;
      local_cfc = 0;
      pFVar13 = &local_f4;
      puVar17 = (ulong *)&stack0xfffff2f8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)0x0;
      iVar10 = 3;
      pFVar13 = &local_100;
      puVar17 = (ulong *)&stack0xfffff2d0;
      local_d24 = local_cc0;
      local_d20 = local_cc4;
      local_d18 = local_cb4;
      local_d14 = local_cb8;
      local_d10 = local_cbc;
      local_d0c = local_cd0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d38 = (FontTypePtr)yyElement;
      local_d34 = (code *)yyFont;
      yyElement = CreateNewElement(yyData,yyElement,yyFont,
                                   (FlagType)CONCAT48(local_d28,CONCAT44(local_d2c,local_d30)),
                                   (char *)local_d24,(char *)local_d20,(char *)local_d1c,
                                   (LocationType)local_d18,(LocationType)local_d14,(BYTE)local_d10,
                                   (int)local_d0c,in_stack_fffff2f8,(Boolean)local_cfc);
      SaveFree((void *)local_c94[-1].Symbol[0xfc].Height);
      __src = local_c94;
      goto LAB_080ae6d7;
    case 0x77:
      local_ccc = pPVar7;
      OldFlags(&local_10c,local_c94[-1].Symbol[0xff].LineN);
      local_cc4 = (PCBTypePtr)(uint)*(byte *)&__src[-1].Symbol[0xfe].LineMax;
      local_cd0 = (PCBTypePtr)__src[-1].Symbol[0xfe].Delta;
      local_cc0 = (PCBTypePtr)((int)__src[-1].Symbol[0xfe].Line * 100);
      local_cbc = (PCBTypePtr)(__src[-1].Symbol[0xfd].Width * 100);
      local_cb8 = *(PCBTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      local_cb4 = (PCBTypePtr)local_c94[-1].Symbol[0xfc].Height;
      local_cc8 = (PCBTypePtr)local_c94[-1].Symbol[0xfc].LineN;
      OldFlags(&local_118,local_c94[-1].Symbol[0xfb].Delta);
      iVar10 = 3;
      local_cfc = 0;
      pFVar13 = &local_10c;
      puVar17 = (ulong *)&stack0xfffff2f8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      iVar10 = 3;
      pFVar13 = &local_118;
      puVar17 = (ulong *)&stack0xfffff2d0;
      local_d24 = local_cc8;
      local_d20 = local_cb4;
      local_d1c = local_cb8;
      local_d18 = local_cbc;
      local_d14 = local_cc0;
      local_d10 = local_cc4;
      local_d0c = local_cd0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d38 = (FontTypePtr)yyElement;
      local_d34 = (code *)yyFont;
      yyElement = CreateNewElement(yyData,yyElement,yyFont,
                                   (FlagType)CONCAT48(local_d28,CONCAT44(local_d2c,local_d30)),
                                   (char *)local_d24,(char *)local_d20,(char *)local_d1c,
                                   (LocationType)local_d18,(LocationType)local_d14,(BYTE)local_d10,
                                   (int)local_d0c,in_stack_fffff2f8,(Boolean)local_cfc);
      __src = local_c94;
      SaveFree((void *)local_c94[-1].Symbol[0xfc].LineN);
      SaveFree((void *)__src[-1].Symbol[0xfc].Height);
LAB_080ae6d7:
      SaveFree(*(void **)&__src[-1].Symbol[0xfd].Valid);
      pin_num = 1;
      pPVar7 = local_ccc;
      break;
    case 0x79:
      local_ccc = pPVar7;
      OldFlags(&local_124,local_c94[-1].Symbol[0xff].LineN);
      local_cbc = (PCBTypePtr)__src[-1].Symbol[0xfe].Delta;
      local_cb8 = (PCBTypePtr)(uint)*(byte *)&__src[-1].Symbol[0xfe].LineMax;
      local_cc8 = (PCBTypePtr)
                  (((int)&((__src[-1].Symbol[0xfe].Line)->BoundingBox).X1 +
                   *(int *)&__src[-1].Symbol[0xfd].Valid) * 100);
      local_cb4 = (PCBTypePtr)__src[-1].Symbol[0xfc].LineN;
      local_cc4 = (PCBTypePtr)__src[-1].Symbol[0xfb].Delta;
      local_cd0 = (PCBTypePtr)((__src[-1].Symbol[0xfd].Width + __src[-1].Symbol[0xfc].Height) * 100)
      ;
      local_cc0 = (PCBTypePtr)local_c94[-1].Symbol[0xfb].LineMax;
      OldFlags(&local_130,(uint)local_c94[-1].Symbol[0xfb].Line);
      iVar10 = 3;
      local_cfc = 0;
      pFVar13 = &local_124;
      puVar17 = (ulong *)&stack0xfffff2f8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      iVar10 = 3;
      pFVar13 = &local_130;
      puVar17 = (ulong *)&stack0xfffff2d0;
      local_d24 = local_cc0;
      local_d20 = local_cc4;
      local_d1c = local_cb4;
      local_d18 = local_cd0;
      local_d14 = local_cc8;
      local_d10 = local_cb8;
      local_d0c = local_cbc;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d38 = (FontTypePtr)yyElement;
      local_d34 = (code *)yyFont;
      pEVar8 = CreateNewElement(yyData,yyElement,yyFont,
                                (FlagType)CONCAT48(local_d28,CONCAT44(local_d2c,local_d30)),
                                (char *)local_d24,(char *)local_d20,(char *)local_d1c,
                                (LocationType)local_d18,(LocationType)local_d14,(BYTE)local_d10,
                                (int)local_d0c,in_stack_fffff2f8,(Boolean)local_cfc);
      __src = local_c94;
      yyElement = pEVar8;
      pEVar8->MarkX = local_c94[-1].Symbol[0xfc].Height * 100;
      pEVar8->MarkY = *(int *)&local_c94[-1].Symbol[0xfd].Valid * 100;
      SaveFree((void *)local_c94[-1].Symbol[0xfb].LineMax);
      SaveFree((void *)__src[-1].Symbol[0xfb].Delta);
      SaveFree((void *)__src[-1].Symbol[0xfc].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x7b:
      iVar10 = 3;
      local_cfc = 0;
      pCVar15 = &local_c94[-1].Symbol[0xff].LineN;
      pCVar20 = (Cardinal *)&stack0xfffff2f8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pCVar20 = *pCVar15;
        pCVar15 = pCVar15 + (uint)bVar22 * 0x3ffffffe + 1;
        pCVar20 = pCVar20 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d0c = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d10 = (PCBTypePtr)(uint)*(byte *)&local_c94[-1].Symbol[0xfe].LineMax;
      local_d14 = (PCBTypePtr)
                  ((int)&((local_c94[-1].Symbol[0xfe].Line)->BoundingBox).X1 +
                  *(int *)&local_c94[-1].Symbol[0xfd].Valid);
      local_d18 = (PCBTypePtr)(local_c94[-1].Symbol[0xfd].Width + local_c94[-1].Symbol[0xfc].Height)
      ;
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xfc].LineN;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xfb].Delta;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xfb].LineMax;
      iVar10 = 3;
      pSVar14 = local_c94[-1].Symbol + 0xfb;
      ppLVar18 = (LineTypePtr *)&stack0xfffff2d0;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *ppLVar18 = pSVar14->Line;
        pSVar14 = (SymbolType *)(&pSVar14->Line + (uint)bVar22 * 0x3ffffffe + 1);
        ppLVar18 = ppLVar18 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d38 = (FontTypePtr)yyElement;
      local_d34 = (code *)yyFont;
      local_ccc = pPVar7;
      pEVar8 = CreateNewElement(yyData,yyElement,yyFont,
                                (FlagType)CONCAT48(local_d28,CONCAT44(local_d2c,local_d30)),
                                (char *)local_d24,(char *)local_d20,(char *)local_d1c,
                                (LocationType)local_d18,(LocationType)local_d14,(BYTE)local_d10,
                                (int)local_d0c,in_stack_fffff2f8,(Boolean)local_cfc);
      __src = local_c94;
      yyElement = pEVar8;
      pEVar8->MarkX = local_c94[-1].Symbol[0xfc].Height;
      pEVar8->MarkY = *(LocationType *)&local_c94[-1].Symbol[0xfd].Valid;
      SaveFree((void *)local_c94[-1].Symbol[0xfb].LineMax);
      SaveFree((void *)__src[-1].Symbol[0xfb].Delta);
      SaveFree((void *)__src[-1].Symbol[0xfc].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x84:
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d30 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_d34 = (code *)local_c94[-1].Symbol[0xfe].LineMax;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Line;
      goto LAB_080afb8f;
    case 0x85:
      local_d28 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d38 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
LAB_080afb8f:
      local_ccc = pPVar7;
      CreateNewLineInElement
                (yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30,
                 (LocationType)local_d2c,(BDimension)local_d28);
      pPVar7 = local_ccc;
      break;
    case 0x86:
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d30 = (char *)local_c94[-1].Symbol[0xfe].Line;
      local_d34 = (code *)local_c94[-1].Symbol[0xfd].Width;
      local_d38 = *(FontTypePtr *)&local_c94[-1].Symbol[0xfd].Valid;
      goto LAB_080af1c7;
    case 0x87:
      local_d20 = (PCBTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d30 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
LAB_080af1c7:
      local_ccc = pPVar7;
      CreateNewArcInElement
                (yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                 (BDimension)local_d2c,(int)local_d28,(int)local_d24,(BDimension)local_d20);
      pPVar7 = local_ccc;
      break;
    case 0x88:
      yyElement->MarkX = local_c94[-1].Symbol[0xff].LineN;
      pEVar8->MarkY = local_c94[-1].Symbol[0xff].Height;
      break;
    case 0x89:
      yyElement->MarkX = local_c94[-1].Symbol[0xff].LineN * 100;
      pEVar8->MarkY = local_c94[-1].Symbol[0xff].Height * 100;
      break;
    case 0x8a:
    case 0x96:
      attr_list = (AttributeListTypePtr)&yyElement->Attributes;
      break;
    case 0x92:
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN + yyElement->MarkY);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfe].Delta + yyElement->MarkX);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfe].LineMax + yyElement->MarkY);
      local_d38 = (FontTypePtr)
                  ((int)&((local_c94[-1].Symbol[0xfe].Line)->BoundingBox).X1 + yyElement->MarkX);
      local_ccc = pPVar7;
      CreateNewLineInElement
                (yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30,
                 (LocationType)local_d2c,(BDimension)local_d28);
      pPVar7 = local_ccc;
      break;
    case 0x93:
      local_d28 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100 + yyElement->MarkY);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100 + yyElement->MarkX);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100 + yyElement->MarkY);
      local_d38 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100 + yyElement->MarkX);
      local_ccc = pPVar7;
      CreateNewLineInElement
                (yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30,
                 (LocationType)local_d2c,(BDimension)local_d28);
      pPVar7 = local_ccc;
      break;
    case 0x94:
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d30 = (char *)local_c94[-1].Symbol[0xfe].Line;
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width + yyElement->MarkY);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid + yyElement->MarkX);
      goto LAB_080af0ca;
    case 0x95:
      local_d20 = (PCBTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d30 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100 + yyElement->MarkY);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100 + yyElement->MarkX);
LAB_080af0ca:
      local_ccc = pPVar7;
      CreateNewArcInElement
                (yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                 (BDimension)local_d2c,(int)local_d28,(int)local_d24,(BDimension)local_d20);
      pPVar7 = local_ccc;
      break;
    case 0x98:
      iVar10 = 3;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      pBVar21 = (BDimension *)&stack0xfffff2e8;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *pBVar21 = *pBVar16;
        pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
        pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d28 = local_c94[-1].Symbol[0xfe].Line;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xfd].Width;
      local_d30 = *(char **)&local_c94[-1].Symbol[0xfd].Valid;
      local_d34 = (code *)(local_c94[-1].Symbol[0xfc].Height + yyElement->MarkY);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].LineN + yyElement->MarkX);
      local_ccc = pPVar7;
      CreateNewPin(yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   (BDimension)local_d2c,(BDimension)local_d28,(BDimension)local_d24,
                   (char *)local_d20,(char *)local_d1c,
                   (FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      SaveFree((void *)__src[-1].Symbol[0xfe].Delta);
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x99:
      local_ccc = pPVar7;
      OldFlags(&local_13c,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      pFVar13 = &local_13c;
      puVar17 = (ulong *)&stack0xfffff2e8;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d28 = (LineTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d30 = (char *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfc].Height * 100 + yyElement->MarkY);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].LineN * 100 + yyElement->MarkX);
      CreateNewPin(yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   (BDimension)local_d2c,(BDimension)local_d28,(BDimension)local_d24,
                   (char *)local_d20,(char *)local_d1c,
                   (FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      goto LAB_080aefd1;
    case 0x9a:
      local_ccc = pPVar7;
      OldFlags(&local_148,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d30 = (char *)((int)__src[-1].Symbol[0xfe].Line * 100);
      pFVar13 = &local_148;
      puVar17 = (ulong *)&stack0xfffff2e8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d2c = (FontTypePtr)0xbb8;
      local_d28 = (LineTypePtr)((char **)((FontTypePtr)local_d30)->Symbol + 0x68);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      CreateNewPin(yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   3000,(BDimension)local_d28,(BDimension)local_d24,(char *)local_d20,
                   (char *)local_d1c,(FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      __src = local_c94;
      goto LAB_080af255;
    case 0x9b:
      pin_num = pin_num + 1;
      local_ccc = pPVar7;
      __sprintf_chk(p_number);
      __src = local_c94;
      OldFlags(&local_154,local_c94[-1].Symbol[0xff].Height);
      local_d1c = (PCBTypePtr)p_number;
      iVar10 = 3;
      local_d30 = (char *)(__src[-1].Symbol[0xfe].LineMax * 100);
      pFVar13 = &local_154;
      puVar17 = (ulong *)&stack0xfffff2e8;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d24 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d2c = (FontTypePtr)0xbb8;
      local_d28 = (LineTypePtr)((char **)((FontTypePtr)local_d30)->Symbol + 0x68);
      local_d34 = (code *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      CreateNewPin(yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   3000,(BDimension)local_d28,(BDimension)local_d24,(char *)local_d20,
                   (char *)local_d1c,(FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      goto LAB_080afabe;
    case 0x9c:
      iVar10 = local_c94[-1].Symbol[0xfe].Delta;
      __src = local_c94 + -1;
      local_d24 = (PCBTypePtr)(iVar10 * 0x28);
      if ((iVar10 * -0x27 < 400) && (400 < iVar10)) {
        local_d24 = (PCBTypePtr)(iVar10 + -400);
      }
      pin_num = pin_num + 1;
      local_ccc = pPVar7;
      __sprintf_chk(p_number);
      OldFlags(&local_160,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d30 = (char *)(__src->Symbol[0xfe].Delta * 100);
      pFVar13 = &local_160;
      puVar17 = (ulong *)&stack0xfffff2e8;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)((int)pFVar13 + (uint)bVar22 * -8 + 4);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d1c = (PCBTypePtr)p_number;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d2c = (FontTypePtr)0xbb8;
      local_d28 = (LineTypePtr)((char **)((FontTypePtr)local_d30)->Symbol + 0x68);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d38 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      CreateNewPin(yyElement,(LocationType)local_d38,(LocationType)local_d34,(BDimension)local_d30,
                   3000,(BDimension)local_d28,(BDimension)local_d24,(char *)local_d20,
                   (char *)local_d1c,(FlagType)CONCAT48(local_d10,CONCAT44(local_d14,local_d18)));
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x9d:
      iVar10 = yyElement->MarkY;
      iVar12 = yyElement->MarkX;
      iVar9 = 3;
      pBVar16 = &local_c94[-1].Symbol[0xff].Height;
      pBVar21 = (BDimension *)&stack0xfffff2ec;
      while (__src = local_c94, iVar9 != 0) {
        iVar9 = iVar9 + -1;
        *pBVar21 = *pBVar16;
        pBVar16 = pBVar16 + (uint)bVar22 * 0x3ffffffe + 1;
        pBVar21 = pBVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d18 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d20 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].LineMax;
      local_d24 = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Line;
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xfd].Width;
      local_d2c = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid + iVar10);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfc].Height + iVar12);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfc].LineN + iVar10);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfb].Delta + iVar12);
      local_ccc = pPVar7;
      CreateNewPad(yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30
                   ,(LocationType)local_d2c,(BDimension)local_d28,(BDimension)local_d24,
                   (BDimension)local_d20,(char *)local_d1c,(char *)local_d18,
                   (FlagType)CONCAT48(local_d0c,CONCAT44(local_d10,local_d14)));
LAB_080aefd1:
      SaveFree((void *)__src[-1].Symbol[0xfe].Delta);
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0x9e:
      local_ccc = pPVar7;
      OldFlags(&local_16c,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_cb8 = (PCBTypePtr)yyElement->MarkY;
      local_cb4 = (PCBTypePtr)yyElement->MarkX;
      pFVar13 = local_ce4;
      puVar17 = (ulong *)&stack0xfffff2ec;
      while (iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)(&pFVar13->f + (uint)bVar22 * 0x3ffffffe + 1);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d18 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d20 = (PCBTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d24 = (PCBTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d28 = (LineTypePtr)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d2c = (FontTypePtr)(&local_cb8->ID + *(int *)&local_c94[-1].Symbol[0xfd].Valid * 0x19);
      local_d30 = (char *)(&local_cb4->ID + local_c94[-1].Symbol[0xfc].Height * 0x19);
      local_d34 = (code *)(&local_cb8->ID + local_c94[-1].Symbol[0xfc].LineN * 0x19);
      local_d38 = (FontTypePtr)(&local_cb4->ID + local_c94[-1].Symbol[0xfb].Delta * 0x19);
      CreateNewPad(yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30
                   ,(LocationType)local_d2c,(BDimension)local_d28,(BDimension)local_d24,
                   (BDimension)local_d20,(char *)local_d1c,(char *)local_d18,
                   (FlagType)CONCAT48(local_d0c,CONCAT44(local_d10,local_d14)));
      __src = local_c94;
      goto LAB_080af255;
    case 0x9f:
      local_ccc = pPVar7;
      OldFlags(&local_178,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d28 = (LineTypePtr)(__src[-1].Symbol[0xfe].LineMax * 100);
      pFVar13 = local_ce8;
      puVar17 = (ulong *)&stack0xfffff2ec;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)(&pFVar13->f + (uint)bVar22 * 0x3ffffffe + 1);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d18 = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_d24 = (PCBTypePtr)0xbb8;
      local_d20 = (PCBTypePtr)&local_d28[6].Point2.X2;
      local_d2c = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d34 = (code *)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      local_d38 = (FontTypePtr)(local_c94[-1].Symbol[0xfc].Height * 100);
      CreateNewPad(yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30
                   ,(LocationType)local_d2c,(BDimension)local_d28,3000,(BDimension)local_d20,
                   (char *)local_d1c,(char *)local_d18,
                   (FlagType)CONCAT48(local_d0c,CONCAT44(local_d10,local_d14)));
      goto LAB_080af255;
    case 0xa0:
      pin_num = pin_num + 1;
      local_ccc = pPVar7;
      __sprintf_chk(p_number);
      __src = local_c94;
      OldFlags(&local_184,local_c94[-1].Symbol[0xff].Height);
      iVar10 = 3;
      local_d28 = (LineTypePtr)(__src[-1].Symbol[0xfe].Delta * 100);
      pFVar13 = local_cec;
      puVar17 = (ulong *)&stack0xfffff2ec;
      while (__src = local_c94, iVar10 != 0) {
        iVar10 = iVar10 + -1;
        *puVar17 = pFVar13->f;
        pFVar13 = (FlagType *)(&pFVar13->f + (uint)bVar22 * 0x3ffffffe + 1);
        puVar17 = puVar17 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      local_d18 = (PCBTypePtr)p_number;
      local_d1c = (PCBTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d24 = (PCBTypePtr)0xbb8;
      local_d20 = (PCBTypePtr)&local_d28[6].Point2.X2;
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d30 = (char *)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfd].Width * 100);
      local_d38 = (FontTypePtr)(*(int *)&local_c94[-1].Symbol[0xfd].Valid * 100);
      CreateNewPad(yyElement,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30
                   ,(LocationType)local_d2c,(BDimension)local_d28,3000,(BDimension)local_d20,
                   (char *)local_d1c,(char *)local_d18,
                   (FlagType)CONCAT48(local_d0c,CONCAT44(local_d10,local_d14)));
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0xa1:
      local_d38 = (FontTypePtr)local_c94->MaxHeight;
      local_ccc = pPVar7;
      OldFlags((FlagType *)&yyval,(uint)local_d38);
      pPVar7 = local_ccc;
      break;
    case 0xa2:
      local_d34 = yyerror;
      local_d38 = (FontTypePtr)local_c94->MaxHeight;
      local_ccc = pPVar7;
      string_to_flags((FlagType *)&yyval,(char *)local_d38,yyerror);
      pPVar7 = local_ccc;
      break;
    case 0xa5:
      iVar10 = local_c94[-1].Symbol[0xfe].Delta;
      if (iVar10 - 1U < 0xff) {
        Symbol = (SymbolTypePtr)(yyFont->Symbol + iVar10);
        iVar10 = (int)&yyFont->DefaultSymbol + iVar10 * 0x1c + 8;
        if (*(char *)(iVar10 + 0xc) == '\0') {
          *(undefined *)(iVar10 + 0xc) = 1;
          Symbol->Delta = local_c94[-1].Symbol[0xff].LineN;
          break;
        }
      }
      goto LAB_080b08bd;
    case 0xa7:
      iVar10 = local_c94[-1].Symbol[0xfe].Delta;
      if (iVar10 - 1U < 0xff) {
        Symbol = (SymbolTypePtr)(yyFont->Symbol + iVar10);
        iVar10 = (int)&yyFont->DefaultSymbol + iVar10 * 0x1c + 8;
        if (*(char *)(iVar10 + 0xc) == '\0') {
          *(undefined *)(iVar10 + 0xc) = 1;
          Symbol->Delta = local_c94[-1].Symbol[0xff].LineN * 100;
          break;
        }
      }
LAB_080b08bd:
      local_ccc = pPVar7;
      Message("ERROR parsing file \'%s\'\n    line:        %i\n    description: \'%s\'\n");
      goto LAB_080af56c;
    case 0xb0:
      local_d28 = (LineTypePtr)(local_c94[-1].Symbol[0xff].Height * 100);
      local_d2c = (FontTypePtr)(local_c94[-1].Symbol[0xff].LineN * 100);
      local_d30 = (char *)(local_c94[-1].Symbol[0xfe].Delta * 100);
      local_d34 = (code *)(local_c94[-1].Symbol[0xfe].LineMax * 100);
      local_d38 = (FontTypePtr)((int)local_c94[-1].Symbol[0xfe].Line * 100);
      goto LAB_080ae9c7;
    case 0xb1:
      local_d28 = (LineTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_d2c = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_d30 = (char *)local_c94[-1].Symbol[0xfe].Delta;
      local_d34 = (code *)local_c94[-1].Symbol[0xfe].LineMax;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Line;
LAB_080ae9c7:
      local_ccc = pPVar7;
      CreateNewLineInSymbol
                (Symbol,(LocationType)local_d38,(LocationType)local_d34,(LocationType)local_d30,
                 (LocationType)local_d2c,(BDimension)local_d28);
      pPVar7 = local_ccc;
      break;
    case 0xb9:
      local_d34 = (code *)local_c94[-1].Symbol[0xff].LineN;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xfe].Delta;
      local_ccc = pPVar7;
      Menu = CreateNewNet((LibraryTypePtr)&yyPCB->NetlistLib,(char *)local_d38,(char *)local_d34);
      __src = local_c94;
LAB_080af255:
      SaveFree((void *)__src[-1].Symbol[0xfe].Delta);
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      pPVar7 = local_ccc;
      break;
    case 0xbf:
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xff].Height;
      local_ccc = pPVar7;
      CreateNewConnection(Menu,(char *)local_d38);
      SaveFree((void *)__src[-1].Symbol[0xff].Height);
      pPVar7 = local_ccc;
      break;
    case 0xc2:
      local_d34 = (code *)local_c94[-1].Symbol[0xff].Height;
      local_d38 = (FontTypePtr)local_c94[-1].Symbol[0xff].LineN;
      local_ccc = pPVar7;
      CreateNewAttribute(attr_list,(char *)local_d38,(char *)local_d34);
      SaveFree((void *)__src[-1].Symbol[0xff].LineN);
      SaveFree((void *)__src[-1].Symbol[0xff].Height);
      pPVar7 = local_ccc;
      break;
    case 0xc3:
      yyval = (char *)local_c94->MaxHeight;
      break;
    case 0xc4:
      yyval = (char *)0x0;
    }
    pPVar7 = (PCBTypePtr)((int)pPVar7 + local_cac * -2);
    __src = (FontTypePtr)((int)local_c94 + local_cac * -0xc);
    local_c94 = (FontTypePtr)(&__src->MaxWidth + 2);
    *(char **)(&__src->MaxWidth + 2) = yyval;
    *(LineTypePtr *)&__src->DefaultSymbol = local_30;
    *(Cardinal *)&__src->DefaultSymbol = local_2c;
    uVar6 = (uint)""[local_c9c];
    flags = (int)*(short *)&pPVar7->ID + (int)*(short *)(uVar6 + 0x814d277 + (uVar6 - 0x29));
    if ((flags < 0x24e) && (*(short *)&pPVar7->ID == yycheck[flags])) {
      iVar10 = (int)yytable[flags];
    }
    else {
      iVar10 = (int)*(short *)(uVar6 + 0x814d357 + (uVar6 - 0x29));
    }
yynewstate:
    pPVar7 = (PCBTypePtr)((int)&pPVar7->ID + 2);
    __src = local_ca4;
  } while( true );
}



void add_noholes_polyarea(PLINE *pline,void *user_data)

{
  pline->next = *(PLINE **)((int)user_data + 0x30);
  *(PLINE **)((int)user_data + 0x30) = pline;
  return;
}



// WARNING: Removing unreachable block (ram,0x080b0a22)

Cardinal GetLowestDistancePolygonPoint(PolygonTypePtr Polygon,LocationType X,LocationType Y)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  PointTypePtr pPVar7;
  Cardinal CVar8;
  int iVar9;
  int local_2c;
  Cardinal local_28;
  
  local_28 = 0;
  pPVar7 = Polygon->Points;
  uVar1 = Polygon->PointN;
  if (uVar1 != 0) {
    fVar6 = 99999991988224.00000000;
    CVar8 = 0;
    iVar9 = (&pPVar7->X)[uVar1 * 5 + -5];
    local_2c = (&pPVar7->X + uVar1 * 5 + -5)[1];
    while( true ) {
      iVar2 = pPVar7->X;
      iVar3 = pPVar7->Y;
      fVar5 = (float)(iVar2 - iVar9);
      fVar4 = (float)(iVar3 - local_2c);
      if ((fVar5 != 0.00000000) || (fVar4 != 0.00000000)) {
        fVar5 = ((float)(Y - local_2c) * fVar4 + (float)(X - iVar9) * fVar5) /
                (fVar4 * fVar4 + fVar5 * fVar5);
        if (fVar5 < 0.00000000) {
          fVar5 = (float)(X - iVar9);
          fVar4 = (float)(Y - local_2c);
          fVar5 = fVar4 * fVar4 + fVar5 * fVar5;
        }
        else {
          if (fVar5 <= 1.00000000) {
            fVar4 = ((float)X - (float)iVar9 * (1.00000000 - fVar5)) - (float)iVar2 * fVar5;
            fVar5 = ((float)Y - (float)local_2c * (1.00000000 - fVar5)) - (float)iVar3 * fVar5;
            fVar5 = fVar5 * fVar5 + fVar4 * fVar4;
          }
          else {
            fVar5 = (float)(Y - iVar3) * (float)(Y - iVar3) +
                    (float)(X - iVar2) * (float)(X - iVar2);
          }
        }
        if (fVar5 < fVar6) {
          fVar6 = fVar5;
          local_28 = CVar8;
        }
      }
      CVar8 = CVar8 + 1;
      if (uVar1 <= CVar8) break;
      pPVar7 = pPVar7 + 1;
      iVar9 = iVar2;
      local_2c = iVar3;
    }
  }
  return local_28;
}



void GoToPreviousPoint(void)

{
  if (Crosshair.AttachedPolygon.PointN != 0) {
    if (Crosshair.AttachedPolygon.PointN == 1) {
      addedLines = 0;
      Crosshair.AttachedLine.State = 0;
      Crosshair.AttachedPolygon.PointN = 0;
      return;
    }
    Crosshair.AttachedLine.Point1.X =
         (&(Crosshair.AttachedPolygon.Points)->X)[Crosshair.AttachedPolygon.PointN * 5 + -10];
    Crosshair.AttachedLine.Point1.Y =
         (&(Crosshair.AttachedPolygon.Points)->X + Crosshair.AttachedPolygon.PointN * 5 + -10)[1];
    Crosshair.AttachedPolygon.PointN = Crosshair.AttachedPolygon.PointN - 1;
  }
  return;
}



int PolygonHoles(PolygonType *polygon,BoxType *range,anon_subr_int_PLINE_ptr_void_ptr *callback,
                void *user_data)

{
  PLINE *pPVar1;
  int iVar2;
  
  if (polygon->Clipped != (POLYAREA *)0x0) {
    pPVar1 = polygon->Clipped->contours->next;
    while (pPVar1 != (PLINE *)0x0) {
      if (((range == (BoxType *)0x0) ||
          ((((pPVar1->xmin <= range->X2 && (range->X1 <= pPVar1->xmax)) &&
            (pPVar1->ymin <= range->Y2)) && (range->Y1 <= pPVar1->ymax)))) &&
         (iVar2 = (*callback)(pPVar1,user_data), iVar2 != 0)) {
        return 1;
      }
      pPVar1 = pPVar1->next;
    }
  }
  return 0;
}



int plow_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if ((*(byte *)&b[1].Y1 & 0x10) == 0) {
    return 0;
  }
  iVar1 = (**(code **)((int)cl + 0x14))
                    (*(undefined4 *)((int)cl + 0x10),*(undefined4 *)((int)cl + 0xc),b,
                     *(undefined4 *)cl,*(undefined4 *)((int)cl + 4),*(undefined4 *)((int)cl + 8));
  return iVar1;
}



void debug_pline(PLINE *pl)

{
  VNODE *pVVar1;
  int local_18;
  int local_14;
  
  local_14 = pl->ymax;
  local_18 = pl->ymin;
  __fprintf_chk(stderr,1,"\txmin %d xmax %d ymin %d ymax %d\n",pl->xmin,pl->xmax,local_18,local_14);
  pVVar1 = &pl->head;
  do {
    __fprintf_chk(stderr,1,"\t\tvnode: %d,%d\n",pVVar1->point[0],pVVar1->point[1],local_18,local_14)
    ;
    pVVar1 = pVVar1->next;
    if (&pl->head == pVVar1) {
      return;
    }
  } while (pVVar1 != (VNODE *)0x0);
  return;
}



void debug_polyarea(POLYAREA *p)

{
  PLINE *pl;
  
  __fprintf_chk(stderr,1,"POLYAREA %p\n",p);
  pl = p->contours;
  while (pl != (PLINE *)0x0) {
    debug_pline(pl);
    pl = pl->next;
  }
  return;
}



void debug_polygon(PolygonType *p)

{
  uint uVar1;
  uint uVar2;
  POLYAREA *p_00;
  
  __fprintf_chk(stderr,1,"POLYGON %p  %d pts\n",p,p->PointN);
  if (p->PointN != 0) {
    uVar1 = 0;
    do {
      uVar2 = uVar1 + 1;
      __fprintf_chk(stderr,1,"\t%d: %d, %d\n",uVar1,p->Points[uVar1].X,p->Points[uVar1].Y);
      uVar1 = uVar2;
    } while (uVar2 <= p->PointN && p->PointN != uVar2);
  }
  p_00 = p->Clipped;
  do {
    if (p_00 == (POLYAREA *)0x0) {
      return;
    }
    debug_polyarea(p_00);
    p_00 = p_00->f;
  } while (p->Clipped != p_00);
  return;
}



Boolean MorphPolygon(LayerTypePtr layer,PolygonTypePtr poly)

{
  int iVar1;
  POLYAREA *pPVar2;
  ulong uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  PLINE *pPVar6;
  POLYAREA *pPVar7;
  PolygonTypePtr Polygon;
  PLINE *pPVar8;
  VNODE *pVVar9;
  POLYAREA *__ptr;
  Boolean BVar10;
  int in_GS_OFFSET;
  FlagType flags;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pPVar2 = poly->Clipped;
  if (((pPVar2 == (POLYAREA *)0x0) || ((*(byte *)((int)&(poly->Flags).f + 1) & 0x20) != 0)) ||
     (pPVar2 == pPVar2->f)) {
LAB_080b0f70:
    BVar10 = '\0';
  }
  else {
    ErasePolygon(poly);
    pPVar2 = poly->Clipped;
    poly->Clipped = (POLYAREA *)0x0;
    if (poly->NoHoles != (PLINE *)0x0) {
      __printf_chk(1,"Just leaked in MorpyPolygon\n");
    }
    uVar3 = (poly->Flags).f;
    BVar10 = '\0';
    poly->NoHoles = (PLINE *)0x0;
    uVar4 = *(undefined4 *)(poly->Flags).t;
    uVar5 = *(undefined4 *)((poly->Flags).t + 4);
    RemovePolygon(layer,poly);
    inhibit = '\x01';
    __ptr = pPVar2;
    do {
      if (__ptr->contours->area <= PCB->IsleArea) {
        pPVar7 = __ptr->f;
        poly_DelContour(&__ptr->contours);
        free(__ptr);
        __ptr = pPVar7;
      }
      else {
        Polygon = CreateNewPolygon(layer,(FlagType)CONCAT48(uVar5,CONCAT44(uVar4,uVar3)));
        if (Polygon == (PolygonTypePtr)0x0) goto LAB_080b0f70;
        pPVar6 = __ptr->contours;
        CreateNewPointInPolygon(Polygon,(pPVar6->head).point[0],(pPVar6->head).point[1]);
        pPVar8 = __ptr->contours;
        pVVar9 = (pPVar6->head).next;
        if (pVVar9 != &pPVar8->head) {
          do {
            CreateNewPointInPolygon(Polygon,pVVar9->point[0],pVVar9->point[1]);
            pPVar8 = __ptr->contours;
            pVVar9 = pVVar9->next;
          } while (&pPVar8->head != pVVar9);
        }
        (Polygon->BoundingBox).X1 = pPVar8->xmin;
        (Polygon->BoundingBox).X2 = pPVar8->xmax + 1;
        (Polygon->BoundingBox).Y1 = pPVar8->ymin;
        (Polygon->BoundingBox).Y2 = pPVar8->ymax + 1;
        AddObjectToCreateUndoList(8,layer,Polygon,Polygon);
        Polygon->Clipped = __ptr;
        pPVar7 = __ptr->f;
        __ptr->b = __ptr;
        __ptr->f = __ptr;
        r_insert_entry(layer->polygon_tree,(BoxType *)Polygon,0);
        BVar10 = '\x01';
        DrawPolygon(layer,Polygon,0);
        __ptr = pPVar7;
      }
    } while (__ptr != pPVar2);
    inhibit = '\0';
    IncrementUndoSerialNumber();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean IsPointInPolygonIgnoreHoles(LocationType X,LocationType Y,PolygonTypePtr p)

{
  int iVar1;
  Vector v;
  
  v[0] = X;
  v[1] = Y;
  iVar1 = poly_InsideContour(p->Clipped->contours,v);
  return (Boolean)iVar1;
}



Boolean isects(POLYAREA *a,PolygonTypePtr p,Boolean fr)

{
  BOOLp BVar1;
  POLYAREA *local_10;
  
  BVar1 = Touching(a,p->Clipped);
  if (fr != '\0') {
    local_10 = a;
    poly_Free(&local_10);
  }
  return (Boolean)BVar1;
}



void frac_circle(PLINE *c,LocationType X,LocationType Y,int *v,int range)

{
  float fVar1;
  float fVar2;
  float fVar3;
  VNODE *node;
  int iVar4;
  int local_2c;
  
  node = poly_CreateNode(v);
  poly_InclVertex((c->head).prev,node);
  fVar3 = (float)(v[1] - Y);
  if (range == 1) {
    local_2c = 0x23;
  }
  else {
    local_2c = (int)(0x24 / (longlong)range);
    if (local_2c < 1) {
      return;
    }
  }
  iVar4 = 0;
  fVar1 = (float)(*v - X);
  do {
    fVar2 = fVar1 * 0.98480773 - fVar3 * 0.17364816;
    fVar3 = fVar1 * 0.17364816 + fVar3 * 0.98480773;
    if (0.00000000 <= fVar2) {
      fVar1 = fVar2 + 0.50000000;
    }
    else {
      fVar1 = fVar2 - 0.50000000;
    }
    *v = (int)ROUND(fVar1) + X;
    if (fVar3 < 0.00000000) {
      fVar1 = fVar3 - 0.50000000;
    }
    else {
      fVar1 = fVar3 + 0.50000000;
    }
    iVar4 = iVar4 + 1;
    v[1] = (int)ROUND(fVar1) + Y;
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    fVar1 = fVar2;
  } while (iVar4 < local_2c);
  return;
}



POLYAREA * __regparm3 original_poly(PolygonType *p)

{
  double dVar1;
  double dVar2;
  int iVar3;
  POLYAREA **ppPVar4;
  int *piVar5;
  VNODE *node;
  POLYAREA *p_00;
  POLYAREA *pPVar6;
  POLYAREA *pPVar7;
  int iVar8;
  PLINE *C;
  Vector v;
  
  C = (PLINE *)0x0;
  iVar8 = p->PointN - 1;
  if (iVar8 != -1) {
    iVar3 = p->PointN * 0x14;
    do {
      piVar5 = (int *)((int)&p->Points[-1].X + iVar3);
      v[0] = *piVar5;
      v[1] = piVar5[1];
      if (C == (PLINE *)0x0) {
        C = poly_NewContour(v);
        if (C == (PLINE *)0x0) {
          return (POLYAREA *)0x0;
        }
      }
      else {
        node = poly_CreateNode(v);
        poly_InclVertex((C->head).prev,node);
      }
      iVar8 = iVar8 + -1;
      iVar3 = iVar3 + -0x14;
    } while (iVar8 != -1);
  }
  poly_PreContour(C,1);
  if ((*(byte *)&C->Flags & 8) == 0) {
    poly_InvContour(C);
  }
  p_00 = poly_Create();
  pPVar6 = (POLYAREA *)0x0;
  if (p_00 != (POLYAREA *)0x0) {
    poly_InclContour(p_00,C);
    pPVar6 = (POLYAREA *)0x0;
    pPVar7 = p_00;
    dVar2 = -1.00000000;
    do {
      while (dVar1 = pPVar7->contours->area, dVar2 < dVar1) {
        ppPVar4 = &pPVar7->f;
        pPVar6 = pPVar7;
        pPVar7 = *ppPVar4;
        dVar2 = dVar1;
        if (p_00 == *ppPVar4) goto LAB_080b127a;
      }
      ppPVar4 = &pPVar7->f;
      pPVar7 = *ppPVar4;
    } while (p_00 != *ppPVar4);
LAB_080b127a:
    if (p_00 != pPVar6) {
      C = pPVar6->contours;
      pPVar6->contours = p_00->contours;
      p_00->contours = C;
      pPVar6 = p_00;
    }
  }
  return pPVar6;
}



int __regparm3 Unsubtract(POLYAREA *np1,PolygonType *p)

{
  double dVar1;
  PLINE *pPVar2;
  double dVar3;
  POLYAREA *pPVar4;
  int iVar5;
  POLYAREA *bi;
  POLYAREA *pPVar6;
  POLYAREA *local_14;
  POLYAREA *local_10;
  
  local_10 = (POLYAREA *)0x0;
  iVar5 = poly_Boolean_free(p->Clipped,np1,&local_10,0);
  if (iVar5 == 0) {
    bi = (POLYAREA *)0x0;
    if (local_10 != (POLYAREA *)0x0) {
      pPVar4 = local_10;
      dVar3 = -1.00000000;
      do {
        while (pPVar6 = pPVar4, dVar1 = pPVar6->contours->area, dVar1 <= dVar3) {
          pPVar4 = pPVar6->f;
          if (local_10 == pPVar6->f) goto LAB_080b133a;
        }
        pPVar4 = pPVar6->f;
        bi = pPVar6;
        dVar3 = dVar1;
      } while (local_10 != pPVar6->f);
LAB_080b133a:
      if (local_10 != bi) {
        pPVar2 = bi->contours;
        bi->contours = local_10->contours;
        local_10->contours = pPVar2;
        bi = local_10;
      }
    }
    p->Clipped = bi;
    bi = original_poly(p);
    iVar5 = poly_Boolean_free(p->Clipped,bi,&local_14,1);
    if (iVar5 == 0) {
      bi = (POLYAREA *)0x0;
      if (local_14 != (POLYAREA *)0x0) {
        pPVar4 = local_14;
        dVar3 = -1.00000000;
        do {
          while (pPVar6 = pPVar4, dVar1 = pPVar6->contours->area, dVar1 <= dVar3) {
            pPVar4 = pPVar6->f;
            if (local_14 == pPVar6->f) goto LAB_080b13b2;
          }
          pPVar4 = pPVar6->f;
          bi = pPVar6;
          dVar3 = dVar1;
        } while (local_14 != pPVar6->f);
LAB_080b13b2:
        if (local_14 != bi) {
          pPVar2 = bi->contours;
          bi->contours = local_14->contours;
          local_14->contours = pPVar2;
          bi = local_14;
        }
      }
      p->Clipped = bi;
      return 1;
    }
    __fprintf_chk(stderr,1,"Error while clipping PBO_ISECT: %d\n",iVar5);
    poly_Free(&local_14);
    p->Clipped = (POLYAREA *)0x0;
    if (p->NoHoles != (PLINE *)0x0) {
      __printf_chk(1,"Just leaked in ClipOriginal\n");
    }
  }
  else {
    __fprintf_chk(stderr,1,"Error while clipping PBO_UNITE: %d\n",iVar5);
    poly_Free(&local_10);
    p->Clipped = (POLYAREA *)0x0;
    if (p->NoHoles != (PLINE *)0x0) {
      __printf_chk(1,"Just leaked in Unsubtract\n");
    }
  }
  p->NoHoles = (PLINE *)0x0;
  return 0;
}



POLYAREA * ContourToPoly(PLINE *contour)

{
  POLYAREA *p;
  
  poly_PreContour(contour,1);
  p = poly_Create();
  if (p != (POLYAREA *)0x0) {
    poly_InclContour(p,contour);
  }
  return p;
}



POLYAREA * RoundRect(LocationType x1,LocationType x2,LocationType y1,LocationType y2,BDimension t)

{
  PLINE *c;
  POLYAREA *pPVar1;
  VNODE *node;
  Vector v;
  
  v[0] = x1 - t;
  v[1] = y1;
  c = poly_NewContour(v);
  pPVar1 = (POLYAREA *)0x0;
  if (c != (PLINE *)0x0) {
    frac_circle(c,x1,y1,v,4);
    v[0] = x2;
    v[1] = y1 - t;
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    frac_circle(c,x2,y1,v,4);
    v[0] = t + x2;
    v[1] = y2;
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    frac_circle(c,x2,y2,v,4);
    v[0] = x1;
    v[1] = t + y2;
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    frac_circle(c,x1,y2,v,4);
    pPVar1 = ContourToPoly(c);
  }
  return pPVar1;
}



POLYAREA * CirclePoly(LocationType x,LocationType y,BDimension radius)

{
  PLINE *c;
  POLYAREA *pPVar1;
  Vector v;
  
  if (0 < radius) {
    v[0] = radius + x;
    v[1] = y;
    c = poly_NewContour(v);
    if (c != (PLINE *)0x0) {
      frac_circle(c,x,y,v,1);
      pPVar1 = ContourToPoly(c);
      return pPVar1;
    }
  }
  return (POLYAREA *)0x0;
}



Boolean IsPointInPolygon(LocationType X,LocationType Y,BDimension r,PolygonTypePtr p)

{
  Boolean BVar1;
  BOOLp BVar2;
  POLYAREA *a;
  Vector v;
  
  v[0] = X;
  v[1] = Y;
  BVar2 = poly_CheckInside(p->Clipped,v);
  BVar1 = '\x01';
  if (BVar2 == 0) {
    if ((0 < r) && (a = CirclePoly(X,Y,r), a != (POLYAREA *)0x0)) {
      BVar1 = isects(a,p,'\x01');
      return BVar1;
    }
    BVar1 = '\0';
  }
  return BVar1;
}



POLYAREA * OctagonPoly(LocationType x,LocationType y,BDimension radius)

{
  bool bVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  bool bVar5;
  float fVar6;
  PLINE *contour;
  POLYAREA *pPVar7;
  VNODE *node;
  int iVar8;
  int local_44;
  Vector v;
  
  fVar2 = (float)radius * 0.50000000;
  bVar1 = fVar2 < 0.00000000;
  if (bVar1) {
    fVar3 = fVar2 - 0.50000000;
  }
  else {
    fVar3 = fVar2 + 0.50000000;
  }
  fVar4 = (float)radius * 0.20710677;
  bVar5 = fVar4 >= 0.00000000;
  if (fVar4 < 0.00000000) {
    fVar6 = fVar4 - 0.50000000;
  }
  else {
    fVar6 = fVar4 + 0.50000000;
  }
  v[0] = (int)ROUND(fVar3) + x;
  v[1] = (int)ROUND(fVar6) + y;
  contour = poly_NewContour(v);
  pPVar7 = (POLYAREA *)0x0;
  if (contour != (PLINE *)0x0) {
    if (bVar5) {
      fVar3 = fVar4 + 0.50000000;
    }
    else {
      fVar3 = fVar4 - 0.50000000;
    }
    v[0] = (int)ROUND(fVar3) + x;
    if (bVar1) {
      iVar8 = (int)ROUND(fVar2 - 0.50000000);
      v[1] = iVar8 + y;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      v[0] = x * 2 - v[0];
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
    }
    else {
      iVar8 = (int)ROUND(fVar2 + 0.50000000);
      v[1] = iVar8 + y;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      v[0] = x * 2 - v[0];
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
    }
    local_44 = x * 2;
    v[0] = x - iVar8;
    if (bVar5) {
      iVar8 = (int)ROUND(fVar4 + 0.50000000);
      v[1] = iVar8 + y;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      v[1] = y * 2 - v[1];
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
    }
    else {
      iVar8 = (int)ROUND(fVar4 - 0.50000000);
      v[1] = iVar8 + y;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      v[1] = y * 2 - v[1];
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
    }
    v[0] = x - iVar8;
    if (bVar1) {
      fVar2 = fVar2 - 0.50000000;
    }
    else {
      fVar2 = fVar2 + 0.50000000;
    }
    v[1] = y - (int)ROUND(fVar2);
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    v[0] = local_44 - v[0];
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    if (bVar5) {
      fVar4 = fVar4 + 0.50000000;
    }
    else {
      fVar4 = fVar4 - 0.50000000;
    }
    v[0] = (int)ROUND(fVar2) + x;
    v[1] = y - (int)ROUND(fVar4);
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    pPVar7 = ContourToPoly(contour);
  }
  return pPVar7;
}



POLYAREA * PinPoly(PinType *pin,BDimension thick,BDimension clear)

{
  uint uVar1;
  POLYAREA *pPVar2;
  int radius;
  
  uVar1 = (pin->Flags).f;
  if ((uVar1 & 0x100) != 0) {
    radius = (thick + 1) / 2;
    pPVar2 = RoundRect(pin->X - radius,radius + pin->X,pin->Y - radius,radius + pin->Y,
                       (clear + 1) / 2);
    return pPVar2;
  }
  radius = (thick + 1 + clear) / 2;
  if ((uVar1 & 0x800) == 0) {
    pPVar2 = CirclePoly(pin->X,pin->Y,radius);
    return pPVar2;
  }
  pPVar2 = OctagonPoly(pin->X,pin->Y,radius * 2);
  return pPVar2;
}



POLYAREA * RectPoly(LocationType x1,LocationType x2,LocationType y1,LocationType y2)

{
  PLINE *contour;
  POLYAREA *pPVar1;
  VNODE *node;
  Vector v;
  
  v[1] = y1;
  v[0] = x1;
  contour = poly_NewContour(v);
  pPVar1 = (POLYAREA *)0x0;
  if (contour != (PLINE *)0x0) {
    v[0] = x2;
    v[1] = y1;
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    v[0] = x2;
    v[1] = y2;
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    v[0] = x1;
    v[1] = y2;
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    pPVar1 = ContourToPoly(contour);
  }
  return pPVar1;
}



void __regparm3
r_NoHolesPolygonDicer(POLYAREA *pa,anon_subr_void_PLINE_ptr_void_ptr *emit,void *user_data)

{
  PLINE *pPVar1;
  PLINE *pPVar2;
  POLYAREA *pPVar3;
  POLYAREA *bi;
  POLYAREA *local_30 [3];
  POLYAREA *local_24;
  POLYAREA *local_20 [4];
  
  pPVar1 = pa->contours;
  pPVar2 = pPVar1->next;
  local_30[0] = pa;
  if (pPVar2 != (PLINE *)0x0) {
    bi = RectPoly(pPVar1->xmin,(pPVar2->xmax + pPVar2->xmin) / 2,pPVar1->ymin,pPVar1->ymax);
    poly_AndSubtract_free(local_30[0],bi,local_20,&local_24);
    bi = local_20[0];
    if (local_20[0] != (POLYAREA *)0x0) {
      do {
        pPVar3 = bi->f;
        bi->b = bi;
        bi->f = bi;
        r_NoHolesPolygonDicer(bi,emit,user_data);
        bi = pPVar3;
      } while (pPVar3 != local_20[0]);
    }
    bi = local_24;
    if (local_24 != (POLYAREA *)0x0) {
      do {
        pPVar3 = bi->f;
        bi->b = bi;
        bi->f = bi;
        r_NoHolesPolygonDicer(bi,emit,user_data);
        bi = pPVar3;
      } while (pPVar3 != local_24);
    }
    return;
  }
  pa->contours = (PLINE *)0x0;
  (*emit)(pPVar1,user_data);
  poly_Free(local_30);
  return;
}



void NoHolesPolygonDicer(PolygonTypePtr p,BoxType *clip,anon_subr_void_PLINE_ptr_void_ptr *emit,
                        void *user_data)

{
  POLYAREA *pPVar1;
  POLYAREA *dst;
  POLYAREA *bi;
  int iVar2;
  POLYAREA *local_20 [4];
  
  dst = poly_Create();
  local_20[0] = dst;
  poly_Copy1(dst,p->Clipped);
  if ((((clip == (BoxType *)0x0) ||
       (bi = RectPoly(clip->X1,clip->X2,clip->Y1,clip->Y2), bi == (POLYAREA *)0x0)) ||
      (iVar2 = poly_Boolean_free(dst,bi,local_20,1), dst = local_20[0], iVar2 == 0)) &&
     (bi = dst, dst != (POLYAREA *)0x0)) {
    do {
      pPVar1 = bi->f;
      bi->b = bi;
      bi->f = bi;
      r_NoHolesPolygonDicer(bi,emit,user_data);
      bi = pPVar1;
    } while (dst != pPVar1);
  }
  return;
}



Boolean IsRectangleInPolygon
                  (LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,PolygonTypePtr p)

{
  Boolean BVar1;
  LocationType x1;
  POLYAREA *a;
  LocationType y1;
  
  y1 = Y1;
  if (Y2 <= Y1) {
    y1 = Y2;
  }
  if (Y1 <= Y2) {
    Y1 = Y2;
  }
  x1 = X1;
  if (X2 <= X1) {
    x1 = X2;
  }
  if (X1 <= X2) {
    X1 = X2;
  }
  a = RectPoly(x1,X1,y1,Y1);
  if (a != (POLYAREA *)0x0) {
    BVar1 = isects(a,p,'\x01');
    return BVar1;
  }
  return '\0';
}



POLYAREA * BoxPolyBloated(BoxType *box,BDimension bloat)

{
  POLYAREA *pPVar1;
  
  pPVar1 = RectPoly(box->X1 - bloat,box->X2 + bloat,box->Y1 - bloat,box->Y2 + bloat);
  return pPVar1;
}



int __regparm3
clearPoly(DataTypePtr *Data,LayerTypePtr Layer,PolygonType *polygon,BoxType *here,BDimension expand)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int *piVar6;
  uint uVar7;
  uint *puVar8;
  uint uVar9;
  uint uVar10;
  Cardinal *pCVar11;
  int local_114;
  int local_110;
  uint local_10c;
  int local_100;
  int local_fc;
  int local_f8;
  uint local_e8;
  cpInfo info;
  BoxType region;
  
  if (((*(byte *)&(polygon->Flags).f & 0x10) == 0) ||
     (iVar2 = GetLayerNumber(Data,Layer), PCB->Data->LayerN <= iVar2)) {
    return 0;
  }
  iVar2 = GetLayerNumber(Data,Layer);
  uVar9 = PCB->Data->LayerN;
  if (uVar9 == 0) {
    local_e8 = 0;
  }
  else {
    local_e8 = 0;
    iVar4 = *(int *)&Data->field_0x48;
    local_f8 = iVar4;
    do {
      uVar10 = *(uint *)(iVar4 + 0x1cd4 + local_e8 * 4);
      if (uVar10 != 0) {
        if (iVar2 == *(int *)(local_f8 + 0x1d14)) goto LAB_080b20a0;
        piVar6 = (int *)(iVar4 + 0x1d18 + local_e8 * 0x48);
        uVar7 = 0;
        while (uVar7 = uVar7 + 1, uVar7 < uVar10) {
          iVar5 = *piVar6;
          piVar6 = piVar6 + 1;
          if (iVar2 == iVar5) goto LAB_080b20a0;
        }
      }
      local_e8 = local_e8 + 1;
      local_f8 = local_f8 + 0x48;
    } while (local_e8 < uVar9);
  }
  uVar10 = 0;
  if (uVar9 != 0) {
LAB_080b20a0:
    uVar10 = 0;
    iVar2 = *(int *)&Data->field_0x48;
    local_fc = iVar2;
    do {
      uVar7 = *(uint *)(iVar2 + 0x1cd4 + uVar10 * 4);
      if (uVar7 != 0) {
        if (*(uint *)(local_fc + 0x1d14) == uVar9) break;
        puVar8 = (uint *)(iVar2 + 0x1d18 + uVar10 * 0x48);
        uVar3 = 0;
        while (uVar3 = uVar3 + 1, uVar3 < uVar7) {
          uVar1 = *puVar8;
          puVar8 = puVar8 + 1;
          if (uVar1 == uVar9) goto LAB_080b1fc8;
        }
      }
      uVar10 = uVar10 + 1;
      local_fc = local_fc + 0x48;
    } while (uVar10 < uVar9);
  }
LAB_080b1fc8:
  if (here == (BoxType *)0x0) {
    local_110 = (polygon->BoundingBox).X2;
    iVar5 = (polygon->BoundingBox).Y2;
    iVar2 = (polygon->BoundingBox).X1;
    iVar4 = (polygon->BoundingBox).Y1;
  }
  else {
    iVar2 = (polygon->BoundingBox).X1;
    iVar4 = (polygon->BoundingBox).Y1;
    local_110 = (polygon->BoundingBox).X2;
    if (iVar2 <= here->X1) {
      iVar2 = here->X1;
    }
    if (here->X2 == local_110 || here->X2 < local_110) {
      local_110 = here->X2;
    }
    if (iVar4 <= here->Y1) {
      iVar4 = here->Y1;
    }
    iVar5 = (polygon->BoundingBox).Y2;
    if (here->Y2 == iVar5 || here->Y2 < iVar5) {
      iVar5 = here->Y2;
    }
  }
  region.X1 = iVar2 + -expand;
  region.Y2 = iVar5 + expand;
  region.Y1 = iVar4 + -expand;
  region.X2 = local_110 + expand;
  info.solder = uVar10 == local_e8;
  info.other = here;
  info.data = (DataType *)Data;
  info.layer = (LayerType *)Layer;
  info.polygon = polygon;
  iVar2 = _setjmp((__jmp_buf_tag *)info.env);
  local_100 = 0;
  if (iVar2 == 0) {
    iVar2 = r_search(Data->via_tree,&region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     pin_sub_callback,&info);
    local_100 = r_search(Data->pin_tree,&region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                         pin_sub_callback,&info);
    local_100 = local_100 + iVar2;
    iVar2 = *(int *)&Data->field_0x48;
    if (*(int *)(iVar2 + 4 + (local_e8 + 0x734) * 4) != 0) {
      uVar9 = 0;
      do {
        uVar10 = *(uint *)(iVar2 + 4 + (uVar9 + 0x744 + local_e8 * 0x12) * 4);
        if (uVar10 < (uint)PCB->Data->LayerN) {
          pCVar11 = &Data->ViaN + uVar10 * 0x17;
          iVar2 = r_search((rtree_t *)pCVar11[0x20],&region,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,line_sub_callback,&info);
          iVar4 = r_search((rtree_t *)pCVar11[0x23],&region,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,arc_sub_callback,&info);
          iVar5 = r_search((rtree_t *)pCVar11[0x21],&region,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,text_sub_callback,&info);
          local_100 = iVar5 + iVar4 + iVar2 + local_100;
        }
        iVar2 = *(int *)&Data->field_0x48;
        uVar9 = uVar9 + 1;
        puVar8 = (uint *)(iVar2 + 4 + (local_e8 + 0x734) * 4);
      } while (uVar9 <= *puVar8 && *puVar8 != uVar9);
    }
    if (info.solder == '\0') {
      local_10c = 0;
      uVar9 = PCB->Data->LayerN;
      local_114 = iVar2;
      if (uVar9 != 0) {
        do {
          uVar10 = *(uint *)(iVar2 + 0x1cd4 + local_10c * 4);
          if (uVar10 != 0) {
            if (uVar9 + 1 == *(int *)(local_114 + 0x1d14)) break;
            piVar6 = (int *)(iVar2 + 0x1d18 + local_10c * 0x48);
            uVar7 = 0;
            while (uVar7 = uVar7 + 1, uVar7 < uVar10) {
              iVar4 = *piVar6;
              piVar6 = piVar6 + 1;
              if (uVar9 + 1 == iVar4) goto LAB_080b2366;
            }
          }
          local_10c = local_10c + 1;
          local_114 = local_114 + 0x48;
        } while (local_10c < uVar9);
      }
LAB_080b2366:
      if (local_10c != local_e8) goto LAB_080b2081;
    }
    iVar2 = r_search(Data->pad_tree,&region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     pad_sub_callback,&info);
    local_100 = local_100 + iVar2;
  }
LAB_080b2081:
  polygon->NoHolesValid = 0;
  return local_100;
}



int add_plow(DataTypePtr *Data,LayerTypePtr Layer,PolygonTypePtr Polygon,int type,void *ptr1,
            void *ptr2)

{
  POLYAREA *np1;
  int iVar1;
  
  if (type != 0x10) {
    if (type < 0x11) {
      if (type == 1) goto LAB_080b2458;
      if (type != 4) {
        return 0;
      }
    }
    else {
      if (type == 0x200) goto LAB_080b2458;
      if (type != 0x4000) {
        if (type != 0x100) {
          return 0;
        }
        goto LAB_080b2458;
      }
    }
  }
  if ((*(byte *)((int)ptr2 + 0x14) & 0x20) == 0) {
    return 1;
  }
LAB_080b2458:
  np1 = BoxPolyBloated((BoxType *)ptr2,10);
  if ((np1 != (POLYAREA *)0x0) && (iVar1 = Unsubtract(np1,(PolygonType *)Polygon), iVar1 != 0)) {
    clearPoly(PCB->Data,Layer,(PolygonType *)Polygon,(BoxType *)ptr2,0x14);
    return 1;
  }
  return 1;
}



int PlowsPolygon(DataType *Data,int type,void *ptr1,void *ptr2,
                anon_subr_int_DataTypePtr_LayerTypePtr_PolygonTypePtr_int_void_ptr_void_ptr
                *call_back)

{
  uint *puVar1;
  uint uVar2;
  LayerType_conflict *pLVar3;
  Cardinal Layer;
  int iVar4;
  int iVar5;
  int iVar6;
  PCBType *pPVar7;
  DataType *pDVar8;
  uint uVar9;
  uint uVar10;
  int local_54;
  uint local_50;
  plow_info info;
  BoxType sb;
  
  sb.X1 = *(LocationType *)ptr2;
  info.ptr2 = ptr2;
  info.ptr1 = ptr1;
  sb.Y1 = *(LocationType *)((int)ptr2 + 4);
  info.data = (DataTypePtr_conflict)Data;
  info.callback =
       (anon_subr_int_DataTypePtr_LayerTypePtr_PolygonTypePtr_int_void_ptr_void_ptr_for_callback *)
       call_back;
  sb.X2 = *(LocationType *)((int)ptr2 + 8);
  sb.Y2 = *(LocationType *)((int)ptr2 + 0xc);
  info.type = type;
  if (type == 0x10) {
LAB_080b2610:
    if (((*(byte *)((int)ptr2 + 0x14) & 0x20) != 0) &&
       (iVar4 = GetLayerNumber((DataTypePtr *)Data,(LayerTypePtr)ptr1), iVar4 < PCB->Data->LayerN))
    {
      uVar10 = 0;
      local_54 = 0;
      while( true ) {
        pPVar7 = Data->pcb;
        Layer = GetLayerNumber((DataTypePtr *)Data,(LayerTypePtr)ptr1);
        iVar4 = GetLayerGroupNumberByNumber(Layer);
        if ((pPVar7->LayerGroups).Number[iVar4] <= uVar10) break;
        pPVar7 = Data->pcb;
        Layer = GetLayerNumber((DataTypePtr *)Data,(LayerTypePtr)ptr1);
        iVar4 = GetLayerGroupNumberByNumber(Layer);
        uVar9 = (&(pPVar7->Flags).f)[uVar10 + 0x744 + iVar4 * 0x12];
        if (uVar9 < (uint)PCB->Data->LayerN) {
          info.layer = (LayerTypePtr)(Data->Layer + uVar9);
          iVar4 = r_search(Data->Layer[uVar9].polygon_tree,&sb,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,plow_callback,&info);
          local_54 = local_54 + iVar4;
        }
        uVar10 = uVar10 + 1;
      }
      return local_54;
    }
  }
  else {
    if (type < 0x11) {
      if (type == 2) {
        if (*(uint *)((int)ptr1 + 0xe0) != 0) {
          uVar9 = 0;
          uVar10 = *(uint *)((int)ptr1 + 0xe0);
          do {
            PlowsPolygon(Data,0x100,ptr1,(void *)(uVar9 * 0x4c + *(int *)((int)ptr1 + 0x100)),
                         call_back);
            uVar2 = *(uint *)((int)ptr1 + 0xe0);
            if (uVar2 == 0) break;
            uVar9 = (uVar2 + 1 + uVar9) - uVar10;
            uVar10 = uVar2;
          } while (uVar9 < uVar2);
        }
        uVar10 = *(uint *)((int)ptr1 + 0xe8);
        local_50 = 0;
        do {
          uVar9 = uVar10;
          do {
            if (uVar9 == 0) {
              return 0;
            }
            if (uVar9 <= local_50) {
              return 0;
            }
            PlowsPolygon(Data,0x200,ptr1,(void *)(*(int *)((int)ptr1 + 0x104) + local_50 * 0x68),
                         call_back);
            uVar9 = *(uint *)((int)ptr1 + 0xe8);
          } while (uVar9 != uVar10);
          local_50 = local_50 + 1;
        } while( true );
      }
      if (type == 4) goto LAB_080b2610;
      if (type != 1) {
        return 0;
      }
    }
    else {
      if (type == 0x200) {
        iVar6 = GetLayerGroupNumberByNumber
                          (((*(uint *)((int)ptr2 + 0x14) >> 7 ^ 1) & 1) + PCB->Data->LayerN);
        pPVar7 = Data->pcb;
        iVar4 = iVar6 + 0x734;
        if ((&(pPVar7->Flags).f)[iVar4] == 0) {
          return 0;
        }
        uVar10 = 0;
        local_54 = 0;
        do {
          while (uVar9 = (&(pPVar7->Flags).f)[uVar10 + 0x744 + iVar6 * 0x12],
                (uint)PCB->Data->LayerN <= uVar9) {
            uVar10 = uVar10 + 1;
            puVar1 = &(pPVar7->Flags).f + iVar4;
            if (*puVar1 < uVar10 || *puVar1 == uVar10) {
              return local_54;
            }
          }
          uVar10 = uVar10 + 1;
          info.layer = (LayerTypePtr)(Data->Layer + uVar9);
          iVar5 = r_search(Data->Layer[uVar9].polygon_tree,&sb,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,plow_callback,&info);
          pPVar7 = Data->pcb;
          local_54 = local_54 + iVar5;
          puVar1 = &(pPVar7->Flags).f + iVar4;
        } while (uVar10 <= *puVar1 && *puVar1 != uVar10);
        return local_54;
      }
      if (type == 0x4000) goto LAB_080b2610;
      if (type != 0x100) {
        return 0;
      }
    }
    if (((ptr1 != ptr2) && (type != 0x100)) && (ptr1 != (void *)0x0)) {
      uVar10 = 0;
      local_54 = 0;
      while( true ) {
        pPVar7 = Data->pcb;
        Layer = GetLayerNumber((DataTypePtr *)Data,(LayerTypePtr)ptr1);
        iVar4 = GetLayerGroupNumberByNumber(Layer);
        if ((pPVar7->LayerGroups).Number[iVar4] <= uVar10) break;
        pPVar7 = Data->pcb;
        Layer = GetLayerNumber((DataTypePtr *)Data,(LayerTypePtr)ptr1);
        iVar4 = GetLayerGroupNumberByNumber(Layer);
        uVar9 = (&(pPVar7->Flags).f)[uVar10 + 0x744 + iVar4 * 0x12];
        if (uVar9 < (uint)PCB->Data->LayerN) {
          info.layer = (LayerTypePtr)(Data->Layer + uVar9);
          iVar4 = r_search(Data->Layer[uVar9].polygon_tree,&sb,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,plow_callback,&info);
          local_54 = local_54 + iVar4;
        }
        uVar10 = uVar10 + 1;
      }
      return local_54;
    }
    if (PCB->Data->LayerN != 0) {
      iVar4 = 0;
      pDVar8 = Data;
      uVar10 = 0;
      do {
        uVar9 = uVar10 + 1;
        info.layer = (LayerTypePtr)(Data->Layer + uVar10);
        pLVar3 = pDVar8->Layer;
        pDVar8 = (DataType *)&pDVar8->Layer[0].ArcN;
        iVar6 = r_search(pLVar3->polygon_tree,&sb,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                         plow_callback,&info);
        iVar4 = iVar4 + iVar6;
        puVar1 = (uint *)&PCB->Data->LayerN;
        uVar10 = uVar9;
      } while (uVar9 <= *puVar1 && *puVar1 != uVar9);
      return iVar4;
    }
  }
  return 0;
}



Boolean RemoveExcessPolygonPoints(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  int iVar1;
  Boolean BVar2;
  int iVar3;
  uint uVar4;
  PointTypePtr Ptr3;
  PointTypePtr pPVar5;
  PointTypePtr pPVar6;
  int iVar7;
  int in_GS_OFFSET;
  Boolean local_81;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  BVar2 = Undoing();
  if (BVar2 == '\0') {
    Ptr3 = Polygon->Points;
    if (Polygon->PointN != 0) {
      iVar3 = Polygon->PointN - 1;
      iVar7 = 0;
      pPVar6 = Ptr3 + iVar3;
      local_81 = '\0';
      pPVar5 = Ptr3;
      do {
        pPVar5 = pPVar5 + 1;
        if (iVar3 == iVar7) {
          pPVar5 = Polygon->Points;
        }
        line.Point1.X = pPVar6->X;
        line.Point1.Y = pPVar6->Y;
        line.Point1.X2 = pPVar6->X2;
        line.Point1.Y2 = pPVar6->Y2;
        line.Point1.ID = pPVar6->ID;
        line.Point2.X = pPVar5->X;
        line.Point2.Y = pPVar5->Y;
        line.Point2.X2 = pPVar5->X2;
        line.Point2.Y2 = pPVar5->Y2;
        line.Point2.ID = pPVar5->ID;
        line.Thickness = 0;
        BVar2 = IsPointOnLine((float)Ptr3->X,(float)Ptr3->Y,0.00000000,(LineTypePtr)&line);
        if (BVar2 == '\0') {
          uVar4 = Polygon->PointN;
          if (uVar4 <= iVar7 + 1U) goto LAB_080b2a50;
        }
        else {
          RemoveObject(0x800,Layer,Polygon,Ptr3);
          local_81 = '\x01';
          uVar4 = Polygon->PointN;
          if (uVar4 <= iVar7 + 1U) goto LAB_080b2a50;
        }
        iVar7 = iVar7 + 1;
        if (iVar7 == 1) {
          pPVar6 = Polygon->Points;
        }
        else {
          pPVar6 = pPVar6 + 1;
        }
        Ptr3 = Ptr3 + 1;
        iVar3 = uVar4 - 1;
      } while( true );
    }
  }
  local_81 = '\0';
LAB_080b2a50:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_81;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int InitClip(DataTypePtr *Data,LayerTypePtr layer,PolygonType *p)

{
  POLYAREA *pPVar1;
  
  if (inhibit == '\0') {
    if (p->Clipped != (POLYAREA *)0x0) {
      poly_Free(&p->Clipped);
    }
    pPVar1 = original_poly(p);
    p->Clipped = pPVar1;
    poly_FreeContours(&p->NoHoles);
    if (p->Clipped != (POLYAREA *)0x0) {
      if ((*(byte *)&(p->Flags).f & 0x10) == 0) {
        p->NoHolesValid = 0;
        return 1;
      }
      clearPoly(Data,layer,p,(BoxType *)0x0,0);
      return 1;
    }
  }
  return 0;
}



void ClearFromPolygon(DataType *Data,int type,void *ptr1,void *ptr2)

{
  if (type != 8) {
    PlowsPolygon(Data,type,ptr1,ptr2,subtract_plow);
    return;
  }
  InitClip(PCB->Data,(LayerTypePtr)ptr1,(PolygonType *)ptr2);
  return;
}



void RestoreToPolygon(DataType *Data,int type,void *ptr1,void *ptr2)

{
  if (type != 8) {
    PlowsPolygon(Data,type,ptr1,ptr2,add_plow);
    return;
  }
  InitClip(PCB->Data,(LayerTypePtr)ptr1,(PolygonType *)ptr2);
  return;
}



void ComputeNoHoles(PolygonType *poly)

{
  poly_FreeContours(&poly->NoHoles);
  if (poly->Clipped != (POLYAREA *)0x0) {
    NoHolesPolygonDicer((PolygonTypePtr)poly,(BoxType *)0x0,add_noholes_polyarea,poly);
    poly->NoHolesValid = 1;
    return;
  }
  __printf_chk(1,"Compute_noholes caught poly->Clipped = NULL\n");
  poly->NoHolesValid = 1;
  return;
}



// WARNING: Removing unreachable block (ram,0x080b2d44)

POLYAREA * SquarePadPoly(PadType *pad,BDimension clear)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  PLINE *c;
  POLYAREA *pPVar10;
  VNODE *node;
  int iVar11;
  int iVar12;
  PadType *pPVar13;
  PadType *pPVar14;
  int in_GS_OFFSET;
  int local_118;
  int local_114;
  int local_110;
  int local_10c;
  Vector v;
  PadType _c;
  PadType _t;
  int local_20;
  
  iVar11 = 0x1a;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pPVar13 = pad;
  pPVar14 = &_t;
  while (iVar11 != 0) {
    iVar11 = iVar11 + -1;
    (pPVar14->BoundingBox).X1 = (pPVar13->BoundingBox).X1;
    pPVar13 = (PadType *)&(pPVar13->BoundingBox).Y1;
    pPVar14 = (PadType *)&(pPVar14->BoundingBox).Y1;
  }
  iVar11 = 0x1a;
  local_10c = _t.Point1.X;
  local_110 = _t.Point2.X;
  pPVar13 = pad;
  pPVar14 = &_c;
  while (iVar11 != 0) {
    iVar11 = iVar11 + -1;
    (pPVar14->BoundingBox).X1 = (pPVar13->BoundingBox).X1;
    pPVar13 = (PadType *)&(pPVar13->BoundingBox).Y1;
    pPVar14 = (PadType *)&(pPVar14->BoundingBox).Y1;
  }
  iVar11 = (pad->Thickness + 1) / 2;
  iVar12 = (clear + 1) / 2;
  dVar5 = (double)((pad->Point1).X - (pad->Point2).X);
  dVar2 = (double)((pad->Point1).Y - (pad->Point2).Y);
  dVar2 = SQRT(dVar2 * dVar2 + dVar5 * dVar5);
  dVar5 = 0.00000000;
  if (dVar2 == 0.00000000) {
    dVar1 = (double)iVar11;
    dVar6 = (double)iVar12;
    dVar3 = (double)_t.Point1.Y + dVar1;
    dVar2 = (double)_t.Point2.Y - dVar1;
    dVar7 = (double)_c.Point1.Y + dVar6;
    dVar8 = (double)_c.Point2.Y - dVar6;
    dVar4 = 0.00000000;
  }
  else {
    dVar4 = (double)iVar11 / dVar2;
    dVar1 = (double)(_t.Point1.Y - _t.Point2.Y) * dVar4;
    dVar4 = (double)(_t.Point2.X - _t.Point1.X) * dVar4;
    dVar5 = dVar2 / (double)iVar12;
    dVar6 = (double)(_c.Point1.Y - _c.Point2.Y) * dVar5;
    dVar5 = (double)(_c.Point2.X - _c.Point1.X) * dVar5;
    local_10c = (int)ROUND((double)_t.Point1.X - dVar4);
    dVar3 = (double)_t.Point1.Y + dVar1;
    local_110 = (int)ROUND((double)_t.Point2.X + dVar4);
    dVar2 = (double)_t.Point2.Y - dVar1;
    _c.Point1.X = (LocationType)ROUND((double)_c.Point1.X - dVar5);
    dVar7 = (double)_c.Point1.Y + dVar6;
    _c.Point2.X = (LocationType)ROUND((double)_c.Point2.X + dVar5);
    dVar8 = (double)_c.Point2.Y - dVar6;
  }
  local_114 = (int)ROUND(dVar2);
  local_118 = (int)ROUND(dVar3);
  v[0] = (int)ROUND((double)_c.Point1.X - dVar1);
  v[1] = (int)ROUND((double)(int)ROUND(dVar7) - dVar4);
  c = poly_NewContour(v);
  pPVar10 = (POLYAREA *)0x0;
  if (c != (PLINE *)0x0) {
    dVar2 = (double)local_118;
    dVar3 = (double)local_10c;
    frac_circle(c,(int)ROUND(dVar3 - dVar1),(int)ROUND(dVar2 - dVar4),v,4);
    dVar7 = (double)local_110;
    v[0] = (int)ROUND(dVar7 - dVar6);
    dVar9 = (double)local_114;
    v[1] = (int)ROUND(dVar9 - dVar5);
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    frac_circle(c,(int)ROUND(dVar7 - dVar1),(int)ROUND(dVar9 - dVar4),v,4);
    v[0] = (int)ROUND(dVar1 + (double)_c.Point2.X);
    v[1] = (int)ROUND(dVar4 + (double)(int)ROUND(dVar8));
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    frac_circle(c,(int)ROUND(dVar7 + dVar1),(int)ROUND(dVar9 + dVar4),v,4);
    v[0] = (int)ROUND(dVar6 + dVar3);
    v[1] = (int)ROUND(dVar2 + dVar5);
    node = poly_CreateNode(v);
    poly_InclVertex((c->head).prev,node);
    frac_circle(c,(int)ROUND(dVar1 + dVar3),(int)ROUND(dVar2 + dVar4),v,4);
    pPVar10 = ContourToPoly(c);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pPVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Removing unreachable block (ram,0x080b345e)

POLYAREA * LinePoly(LineType *L,BDimension thick)

{
  double dVar1;
  double dVar2;
  double dVar3;
  POLYAREA *pPVar4;
  PLINE *c;
  VNODE *node;
  int radius;
  LineType *pLVar5;
  int in_GS_OFFSET;
  int local_b0;
  int local_ac;
  int local_a8;
  Vector v;
  LineType _l;
  int local_20;
  
  radius = 0x16;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pLVar5 = &_l;
  while (radius != 0) {
    radius = radius + -1;
    (pLVar5->BoundingBox).X1 = (L->BoundingBox).X1;
    L = (LineType *)&(L->BoundingBox).Y1;
    pLVar5 = (LineType *)&(pLVar5->BoundingBox).Y1;
  }
  if (0 < thick) {
    radius = thick + 1 >> 1;
    dVar3 = (double)(_l.Point1.Y - _l.Point2.Y);
    dVar3 = SQRT(dVar3 * dVar3 +
                 (double)(_l.Point1.X - _l.Point2.X) * (double)(_l.Point1.X - _l.Point2.X));
    if (((_l.Flags.f & 0x100) == 0) && (dVar3 == 0.00000000)) {
      pPVar4 = CirclePoly(_l.Point1.X,_l.Point1.Y,radius);
      goto LAB_080b3422;
    }
    dVar2 = 0.00000000;
    if (dVar3 == 0.00000000) {
      dVar1 = (double)radius;
    }
    else {
      dVar1 = (double)(_l.Point1.Y - _l.Point2.Y) * ((double)radius / dVar3);
      dVar2 = (double)(_l.Point2.X - _l.Point1.X) * ((double)radius / dVar3);
    }
    if ((_l.Flags.f & 0x100) == 0) {
      local_a8 = _l.Point1.X;
      local_ac = _l.Point2.X;
      local_b0 = _l.Point2.Y;
    }
    else {
      local_a8 = (int)ROUND((double)_l.Point1.X - dVar2);
      _l.Point1.Y = (LocationType)ROUND((double)_l.Point1.Y + dVar1);
      local_ac = (int)ROUND((double)_l.Point2.X + dVar2);
      local_b0 = (int)ROUND((double)_l.Point2.Y - dVar1);
    }
    v[0] = (int)ROUND((double)local_a8 - dVar1);
    v[1] = (int)ROUND((double)_l.Point1.Y - dVar2);
    c = poly_NewContour(v);
    if (c != (PLINE *)0x0) {
      v[0] = (int)ROUND((double)local_ac - dVar1);
      v[1] = (int)ROUND((double)local_b0 - dVar2);
      if ((_l.Flags.f & 0x100) == 0) {
        frac_circle(c,local_ac,local_b0,v,2);
      }
      else {
        node = poly_CreateNode(v);
        poly_InclVertex((c->head).prev,node);
      }
      v[0] = (int)ROUND((double)local_ac + dVar1);
      v[1] = (int)ROUND((double)local_b0 + dVar2);
      node = poly_CreateNode(v);
      poly_InclVertex((c->head).prev,node);
      v[0] = (int)ROUND(dVar1 + (double)local_a8);
      v[1] = (int)ROUND(dVar2 + (double)_l.Point1.Y);
      if ((_l.Flags.f & 0x100) == 0) {
        frac_circle(c,local_a8,_l.Point1.Y,v,2);
      }
      else {
        node = poly_CreateNode(v);
        poly_InclVertex((c->head).prev,node);
      }
      pPVar4 = ContourToPoly(c);
      goto LAB_080b3422;
    }
  }
  pPVar4 = (POLYAREA *)0x0;
LAB_080b3422:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pPVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



POLYAREA * __regparm3 ArcPolyNoIntersect(ArcType *a,BDimension thick)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  BoxTypePtr pBVar6;
  int iVar7;
  int iVar8;
  PLINE *c;
  VNODE *node;
  POLYAREA *pPVar9;
  int iVar10;
  double local_4c;
  double local_3c;
  double local_34 [2];
  Vector v;
  
  if (0 < thick) {
    if (a->Delta < 0) {
      a->StartAngle = a->StartAngle + a->Delta;
      a->Delta = -a->Delta;
    }
    iVar10 = thick + 1 >> 1;
    pBVar6 = GetArcEnds((ArcTypePtr *)a);
    iVar7 = a->Width - iVar10;
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    iVar8 = a->Height - iVar10;
    dVar1 = (double)iVar7;
    if (iVar8 < 0) {
      iVar8 = 0;
    }
    iVar7 = a->Delta;
    dVar2 = (double)iVar8;
    dVar3 = (double)a->StartAngle;
    sincos(dVar3 * 0.01745329,local_34,&local_3c);
    v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
    v[1] = (int)ROUND(local_34[0] * dVar2 + (double)a->Y);
    c = poly_NewContour(v);
    if (c != (PLINE *)0x0) {
      iVar8 = iVar7 / 5;
      dVar4 = (double)iVar7 / (double)iVar8;
      if (0 < iVar8 + -1) {
        iVar7 = 0;
        do {
          dVar3 = dVar3 + dVar4;
          iVar7 = iVar7 + 1;
          sincos(dVar3 * 0.01745329,local_34,&local_3c);
          v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
          v[1] = (int)ROUND(local_34[0] * dVar2 + (double)a->Y);
          node = poly_CreateNode(v);
          poly_InclVertex((c->head).prev,node);
        } while (iVar7 < iVar8 + -1);
      }
      local_4c = (double)(a->Delta + a->StartAngle);
      sincos(local_4c * 0.01745329,local_34,&local_3c);
      dVar3 = local_34[0];
      dVar5 = local_3c;
      v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
      v[1] = (int)ROUND(dVar2 * local_34[0] + (double)a->Y);
      frac_circle(c,pBVar6->X2,pBVar6->Y2,v,2);
      dVar1 = (double)(iVar10 + a->Width);
      if (0 < iVar8) {
        iVar7 = 0;
        while( true ) {
          iVar7 = iVar7 + 1;
          v[0] = (int)ROUND((double)a->X - dVar5 * dVar1);
          v[1] = (int)ROUND(dVar3 * dVar1 + (double)a->Y);
          node = poly_CreateNode(v);
          poly_InclVertex((c->head).prev,node);
          if (iVar8 <= iVar7) break;
          local_4c = local_4c + -dVar4;
          sincos(local_4c * 0.01745329,local_34,&local_3c);
          dVar3 = local_34[0];
          dVar5 = local_3c;
        }
      }
      sincos((double)a->StartAngle * 0.01745329,local_34,&local_3c);
      v[0] = (int)ROUND((double)a->X - dVar1 * local_3c);
      v[1] = (int)ROUND(local_34[0] * dVar1 + (double)a->Y);
      frac_circle(c,pBVar6->X1,pBVar6->Y1,v,2);
      pPVar9 = ContourToPoly(c);
      return pPVar9;
    }
  }
  return (POLYAREA *)0x0;
}



POLYAREA * ArcPoly(ArcType *a,BDimension thick)

{
  uint uVar1;
  POLYAREA *ai;
  POLYAREA *bi;
  int iVar2;
  ArcType *pAVar3;
  ArcType *pAVar4;
  int in_GS_OFFSET;
  POLYAREA *local_ac;
  ArcType seg2;
  ArcType seg1;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  uVar1 = a->Delta;
  if (((double)(((int)uVar1 >> 0x1f ^ uVar1) - ((int)uVar1 >> 0x1f)) / -360.00000000 + 1.00000000) *
      (double)a->Width * 6.28318531 - (double)thick < 10.00000000) {
    iVar2 = 0x11;
    pAVar3 = &seg2;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (pAVar3->BoundingBox).X1 = (a->BoundingBox).X1;
      a = (ArcType *)&(a->BoundingBox).Y1;
      pAVar3 = (ArcType *)&(pAVar3->BoundingBox).Y1;
    }
    seg1.Delta = (int)uVar1 / 2;
    iVar2 = 0x11;
    pAVar3 = &seg2;
    pAVar4 = &seg1;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (pAVar4->BoundingBox).X1 = (pAVar3->BoundingBox).X1;
      pAVar3 = (ArcType *)&(pAVar3->BoundingBox).Y1;
      pAVar4 = (ArcType *)&(pAVar4->BoundingBox).Y1;
    }
    seg2.Delta = seg2.Delta - seg1.Delta;
    seg2.StartAngle = seg2.StartAngle + seg1.Delta;
    ai = ArcPolyNoIntersect(&seg1,thick);
    bi = ArcPolyNoIntersect(&seg2,thick);
    poly_Boolean_free(ai,bi,&local_ac,0);
  }
  else {
    local_ac = ArcPolyNoIntersect(a,thick);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_ac;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void CopyAttachedPolygonToLayer(void)

{
  long lVar1;
  PCBTypePtr pPVar2;
  ulong uVar3;
  PointTypePtr pPVar4;
  PolygonTypePtr Polygon;
  DataTypePtr *Data;
  LayerTypePtr Layer;
  void *Ptr1;
  rtree_t *prVar5;
  int iVar6;
  char cVar7;
  PolygonType *pPVar8;
  int in_GS_OFFSET;
  byte bVar9;
  ulong local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  
  bVar9 = 0;
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags((FlagType *)&local_1c,0);
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  Polygon = CreateNewPolygon(Layer,(FlagType)CONCAT48(local_14,CONCAT44(local_18,local_1c)));
  lVar1 = Polygon->ID;
  (Polygon->BoundingBox).X1 = Crosshair.AttachedPolygon.BoundingBox.X1;
  (Polygon->BoundingBox).Y1 = Crosshair.AttachedPolygon.BoundingBox.Y1;
  (Polygon->BoundingBox).X2 = Crosshair.AttachedPolygon.BoundingBox.X2;
  (Polygon->BoundingBox).Y2 = Crosshair.AttachedPolygon.BoundingBox.Y2;
  Polygon->ID = Crosshair.AttachedPolygon.ID;
  uVar3 = Crosshair.AttachedPolygon.Flags.f;
  (Polygon->Flags).f = Crosshair.AttachedPolygon.Flags.f;
  *(undefined4 *)(Polygon->Flags).t = Crosshair.AttachedPolygon.Flags.t._0_4_;
  *(undefined4 *)((Polygon->Flags).t + 4) = Crosshair.AttachedPolygon.Flags.t._4_4_;
  Polygon->net = Crosshair.AttachedPolygon.net;
  Polygon->PointN = Crosshair.AttachedPolygon.PointN;
  Polygon->PointMax = Crosshair.AttachedPolygon.PointMax;
  Polygon->Clipped = Crosshair.AttachedPolygon.Clipped;
  Polygon->NoHoles = Crosshair.AttachedPolygon.NoHoles;
  Polygon->NoHolesValid = Crosshair.AttachedPolygon.NoHolesValid;
  pPVar4 = Crosshair.AttachedPolygon.Points;
  Polygon->ID = lVar1;
  (Polygon->Flags).f = uVar3 | 0x10;
  pPVar2 = PCB;
  Polygon->Points = pPVar4;
  if ((*(byte *)((int)&(pPVar2->Flags).f + 2) & 0x10) != 0) {
    (Polygon->Flags).f = uVar3 | 0x30;
  }
  iVar6 = 0xf;
  pPVar8 = &Crosshair.AttachedPolygon;
  while (iVar6 != 0) {
    iVar6 = iVar6 + -1;
    (pPVar8->BoundingBox).X1 = 0;
    pPVar8 = (PolygonType *)(&(pPVar8->BoundingBox).X1 + (uint)bVar9 * 0x3ffffffe + 1);
  }
  SetPolygonBoundingBox(Polygon);
  cVar7 = PCB->SilkActive;
  if (cVar7 == '\0') {
    Data = PCB->Data;
    iVar6 = *(int *)(&Data->field_0x88 + LayerStack[0] * 0x5c);
  }
  else {
    Data = PCB->Data;
    iVar6 = *(int *)(&Data->field_0x88 +
                    ((uint)(Settings.ShowSolderSide == '\0') + Data->LayerN) * 0x5c);
  }
  if (iVar6 == 0) {
    if (cVar7 == '\0') {
      iVar6 = &Data->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      iVar6 = &Data->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + Data->LayerN) * 0x5c;
    }
    prVar5 = r_create_tree((BoxType **)0x0,0,0);
    *(rtree_t **)(iVar6 + 0x3c) = prVar5;
    cVar7 = PCB->SilkActive;
    Data = PCB->Data;
  }
  if (cVar7 == '\0') {
    iVar6 = &Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar6 = &Data->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + Data->LayerN) * 0x5c;
  }
  r_insert_entry(*(rtree_t **)(iVar6 + 0x3c),(BoxType *)Polygon,0);
  if (PCB->SilkActive == '\0') {
    Data = PCB->Data;
    Layer = (LayerTypePtr)(&Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Data = PCB->Data;
    Layer = (LayerTypePtr)
            (&Data->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + Data->LayerN) * 0x5c);
  }
  InitClip(Data,Layer,(PolygonType *)Polygon);
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  DrawPolygon(Layer,Polygon,0);
  SetChangedFlag('\x01');
  Crosshair.AttachedLine.State = 0;
  addedLines = 0;
  if (PCB->SilkActive == '\0') {
    Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Ptr1 = (void *)(&PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  AddObjectToCreateUndoList(8,Ptr1,Polygon,Polygon);
  if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  IncrementUndoSerialNumber();
  return;
}



void ClosePolygon(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  if (Crosshair.AttachedPolygon.PointN < 3) {
    Message("A polygon has to have at least 3 points\n");
    return;
  }
  if ((*(byte *)((int)&(PCB->Flags).f + 1) & 1) == 0) {
    uVar1 = (&(Crosshair.AttachedPolygon.Points)->X)[Crosshair.AttachedPolygon.PointN * 5 + -5] -
            (Crosshair.AttachedPolygon.Points)->X;
    uVar4 = (int)uVar1 >> 0x1f;
    uVar1 = uVar4 ^ uVar1;
    uVar2 = (&(Crosshair.AttachedPolygon.Points)->X + Crosshair.AttachedPolygon.PointN * 5 + -5)[1]
            - (Crosshair.AttachedPolygon.Points)->Y;
    uVar3 = (int)uVar2 >> 0x1f;
    uVar2 = uVar2 ^ uVar3;
    if (((uVar2 != uVar3) && (uVar1 != uVar4)) && (uVar1 - uVar4 != uVar2 - uVar3)) {
      Message("Cannot close polygon because 45 degree lines are requested.\n");
      return;
    }
  }
  CopyAttachedPolygonToLayer();
  Draw();
  return;
}



int __regparm3 Subtract(POLYAREA *np1,PolygonType *p)

{
  double dVar1;
  PLINE *pPVar2;
  PLINE *pPVar3;
  double dVar4;
  POLYAREA **ppPVar5;
  POLYAREA *pPVar6;
  int iVar7;
  POLYAREA *pPVar8;
  POLYAREA *pPVar9;
  POLYAREA *local_14;
  POLYAREA *local_10;
  
  local_10 = (POLYAREA *)0x0;
  local_14 = np1;
  if (p->Clipped == (POLYAREA *)0x0) {
    poly_Free(&local_14);
    iVar7 = 1;
  }
  else {
    iVar7 = poly_Boolean_free(p->Clipped,np1,&local_10,2);
    if (iVar7 == 0) {
      if (local_10 == (POLYAREA *)0x0) {
        p->Clipped = (POLYAREA *)0x0;
      }
      else {
        pPVar6 = local_10;
        pPVar8 = (POLYAREA *)0x0;
        dVar4 = -1.00000000;
        do {
          while (pPVar9 = pPVar6, dVar1 = pPVar9->contours->area, dVar1 <= dVar4) {
            ppPVar5 = &pPVar9->f;
            pPVar6 = *ppPVar5;
            pPVar9 = pPVar8;
            if (local_10 == *ppPVar5) goto LAB_080b41d2;
          }
          pPVar6 = pPVar9->f;
          pPVar8 = pPVar9;
          dVar4 = dVar1;
        } while (local_10 != pPVar9->f);
LAB_080b41d2:
        if (local_10 != pPVar9) {
          pPVar2 = pPVar9->contours;
          pPVar3 = local_10->contours;
          p->Clipped = local_10;
          pPVar9->contours = pPVar3;
          local_10->contours = pPVar2;
          return 1;
        }
        p->Clipped = local_10;
        if (local_10 != (POLYAREA *)0x0) {
          return 1;
        }
      }
      Message("Polygon cleared out of existence near (%d, %d)\n",
              ((p->BoundingBox).X2 + (p->BoundingBox).X1) / 2,
              ((p->BoundingBox).Y2 + (p->BoundingBox).Y1) / 2);
      iVar7 = 1;
    }
    else {
      __fprintf_chk(stderr,1,"Error while clipping PBO_SUB: %d\n",iVar7);
      poly_Free(&local_10);
      p->Clipped = (POLYAREA *)0x0;
      if (p->NoHoles != (PLINE *)0x0) {
        __printf_chk(1,"Just leaked in Subtract\n");
      }
      p->NoHoles = (PLINE *)0x0;
      iVar7 = -1;
    }
  }
  return iVar7;
}



int __regparm3 SubtractArc(ArcType *arc,PolygonType *p)

{
  int iVar1;
  POLYAREA *np1;
  
  if ((*(byte *)&(arc->Flags).f & 0x20) == 0) {
    iVar1 = 0;
  }
  else {
    np1 = ArcPoly(arc,arc->Clearance + arc->Thickness);
    iVar1 = -1;
    if (np1 != (POLYAREA *)0x0) {
      iVar1 = Subtract(np1,p);
      return iVar1;
    }
  }
  return iVar1;
}



int arc_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if ((*(BoxType **)cl != b) && ((*(byte *)&b[1].Y1 & 0x20) != 0)) {
    iVar1 = SubtractArc((ArcType *)b,*(PolygonType **)((int)cl + 0xc));
    if (-1 < iVar1) {
      return 1;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



int __regparm3 SubtractPad(PadType *pad,PolygonType *p)

{
  POLYAREA *np1;
  int iVar1;
  
  if ((*(byte *)((int)&(pad->Flags).f + 1) & 1) == 0) {
    np1 = LinePoly((LineType *)pad,pad->Clearance + pad->Thickness);
  }
  else {
    np1 = SquarePadPoly(pad,pad->Clearance + pad->Thickness);
  }
  if (np1 != (POLYAREA *)0x0) {
    iVar1 = Subtract(np1,p);
    return iVar1;
  }
  return -1;
}



int pad_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if (*(BoxType **)cl == b) {
    return 0;
  }
  if (*(char *)&b[1].Y1 < '\0') {
    if (*(char *)((int)cl + 0x10) == '\0') {
      return 0;
    }
  }
  else {
    if (*(char *)((int)cl + 0x10) != '\0') {
      return 0;
    }
  }
  iVar1 = SubtractPad((PadType *)b,*(PolygonType **)((int)cl + 0xc));
  if (iVar1 < 0) {
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 1;
}



int __regparm3 SubtractLine(LineType *line,PolygonType *p)

{
  int iVar1;
  POLYAREA *np1;
  
  if ((*(byte *)&(line->Flags).f & 0x20) == 0) {
    iVar1 = 0;
  }
  else {
    np1 = LinePoly(line,line->Clearance + line->Thickness);
    iVar1 = -1;
    if (np1 != (POLYAREA *)0x0) {
      iVar1 = Subtract(np1,p);
      return iVar1;
    }
  }
  return iVar1;
}



int line_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if ((*(BoxType **)cl != b) && ((*(byte *)&b[1].Y1 & 0x20) != 0)) {
    iVar1 = SubtractLine((LineType *)b,*(PolygonType **)((int)cl + 0xc));
    if (-1 < iVar1) {
      return 1;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



int __regparm3 SubtractPin(DataType *d,PinType *pin,LayerType *l,PolygonType *p)

{
  uint laynum;
  POLYAREA *np1;
  int iVar1;
  
  if (pin->Clearance == 0) {
    return 0;
  }
  laynum = GetLayerNumber((DataTypePtr *)d,(LayerTypePtr)l);
  if ((0xf << (sbyte)((laynum & 1) << 2) & (uint)(pin->Flags).t[laynum >> 1]) == 0) {
    np1 = PinPoly(pin,pin->Thickness,pin->Clearance);
    if (np1 == (POLYAREA *)0x0) {
      return -1;
    }
  }
  else {
    np1 = ThermPoly((PCBTypePtr)d->pcb,(PinTypePtr *)pin,laynum);
    if (np1 == (POLYAREA *)0x0) {
      return 0;
    }
  }
  iVar1 = Subtract(np1,p);
  return iVar1;
}



int pin_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if (*(BoxType **)cl == b) {
    return 0;
  }
  iVar1 = SubtractPin(*(DataType **)((int)cl + 4),(PinType *)b,*(LayerType **)((int)cl + 8),
                      *(PolygonType **)((int)cl + 0xc));
  if (-1 < iVar1) {
    return 1;
  }
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0x14,1);
}



int __regparm3 SubtractText(TextType *text,PolygonType *p)

{
  int t;
  POLYAREA *np1;
  
  if ((*(byte *)&(text->Flags).f & 0x20) == 0) {
    t = 0;
  }
  else {
    t = PCB->Bloat;
    np1 = RoundRect(t + (text->BoundingBox).X1,(text->BoundingBox).X2 - t,(text->BoundingBox).Y1 + t
                    ,(text->BoundingBox).Y2 - t,t);
    t = -1;
    if (np1 != (POLYAREA *)0x0) {
      t = Subtract(np1,p);
      return t;
    }
  }
  return t;
}



int text_sub_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  if ((*(BoxType **)cl != b) && ((*(byte *)&b[1].Y1 & 0x20) != 0)) {
    iVar1 = SubtractText((TextType *)b,*(PolygonType **)((int)cl + 0xc));
    if (-1 < iVar1) {
      return 1;
    }
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



int subtract_plow(DataTypePtr *Data,LayerTypePtr Layer,PolygonTypePtr Polygon,int type,void *ptr1,
                 void *ptr2)

{
  if (Polygon->Clipped != (POLYAREA *)0x0) {
    if (type == 0x10) {
      SubtractText((TextType *)ptr2,(PolygonType *)Polygon);
      Polygon->NoHolesValid = 0;
      return 1;
    }
    if (type < 0x11) {
      if (type == 1) goto LAB_080b4718;
      if (type == 4) {
        SubtractLine((LineType *)ptr2,(PolygonType *)Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
    }
    else {
      if (type == 0x200) {
        SubtractPad((PadType *)ptr2,(PolygonType *)Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
      if (type == 0x4000) {
        SubtractArc((ArcType *)ptr2,(PolygonType *)Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
      if (type == 0x100) {
LAB_080b4718:
        SubtractPin((DataType *)Data,(PinType *)ptr2,(LayerType *)Layer,(PolygonType *)Polygon);
        Polygon->NoHolesValid = 0;
        return 1;
      }
    }
  }
  return 0;
}



int seg_in_region(BoxType *b,void *cl)

{
  double dVar1;
  double dVar2;
  double dVar3;
  uint uVar4;
  
  uVar4 = 1;
  dVar1 = *(double *)cl;
  if (dVar1 != 0.00000000) {
    dVar2 = (double)b->X1 * dVar1 + *(double *)((int)cl + 8);
    dVar1 = (double)b->X2 * dVar1 + *(double *)((int)cl + 8);
    dVar3 = dVar1;
    if (dVar2 <= dVar1 || dVar1 != dVar2) {
      dVar3 = dVar2;
    }
    uVar4 = 0;
    if (dVar3 < (double)b->Y2) {
      if (dVar2 <= dVar1) {
        dVar2 = dVar1;
      }
      uVar4 = (uint)((double)b->Y1 <= dVar2);
    }
  }
  return uVar4;
}



int UniteS_Rule(VNODE *cur,DIRECTION *initdir)

{
  *initdir = FORW;
  return (uint)((byte)((*(byte *)&cur->Flags & 7) - 2) < 2);
}



int IsectS_Rule(VNODE *cur,DIRECTION *initdir)

{
  byte bVar1;
  
  *initdir = FORW;
  bVar1 = *(byte *)&cur->Flags & 7;
  return (uint)(bVar1 == 3 || bVar1 == 1);
}



int SubS_Rule(VNODE *cur,DIRECTION *initdir)

{
  byte bVar1;
  
  *initdir = FORW;
  bVar1 = *(byte *)&cur->Flags & 7;
  return (uint)(bVar1 == 4 || bVar1 == 2);
}



int XorS_Rule(VNODE *cur,DIRECTION *initdir)

{
  byte bVar1;
  
  bVar1 = *(byte *)&cur->Flags & 7;
  if (bVar1 == 1) {
    *initdir = BACKW;
    return 1;
  }
  if (bVar1 != 2) {
    return 0;
  }
  *initdir = FORW;
  return 1;
}



int IsectJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  byte bVar1;
  
  bVar1 = *(byte *)&v->Flags & 7;
  return (uint)(bVar1 == 3 || bVar1 == 1);
}



int UniteJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  return (uint)((byte)((*(byte *)&v->Flags & 7) - 2) < 2);
}



int XorJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  byte bVar1;
  
  bVar1 = *(byte *)&v->Flags & 7;
  if (bVar1 == 1) {
    *cdir = BACKW;
    return 1;
  }
  if (bVar1 != 2) {
    return 0;
  }
  *cdir = FORW;
  return 1;
}



int SubJ_Rule(char p,VNODE *v,DIRECTION *cdir)

{
  int iVar1;
  byte bVar2;
  
  if (p == 'B') {
    bVar2 = *(byte *)&v->Flags & 7;
    if (bVar2 == 1) goto LAB_080b4995;
  }
  else {
    if (p == 'A') {
      bVar2 = *(byte *)&v->Flags & 7;
      if (bVar2 == 2) {
        *cdir = FORW;
        return 1;
      }
    }
    else {
      bVar2 = *(byte *)&v->Flags & 7;
    }
  }
  iVar1 = 0;
  if (bVar2 == 4) {
    if (p != 'A') {
LAB_080b4995:
      *cdir = BACKW;
      return 1;
    }
    *cdir = FORW;
    iVar1 = 1;
  }
  return iVar1;
}



int __regparm3 jump(VNODE **cur,DIRECTION *cdir,J_Rule *rule)

{
  VNODE *pVVar1;
  int iVar2;
  DIRECTION DVar3;
  CVCList *pCVar4;
  CVCList *pCVar5;
  DIRECTION local_20 [4];
  
  pVVar1 = *cur;
  if (pVVar1->cvc_prev == (CVCList *)0x0) {
    if (*cdir != FORW) {
      pVVar1 = pVVar1->prev;
    }
    return (uint)(*(byte *)&pVVar1->Flags >> 3 & 1 ^ 1);
  }
  local_20[0] = *cdir;
  if (local_20[0] == FORW) {
    pCVar4 = pVVar1->cvc_prev->prev;
    pCVar5 = pCVar4;
  }
  else {
    pCVar4 = pVVar1->cvc_next->prev;
    pCVar5 = pCVar4;
  }
  do {
    pVVar1 = pCVar4->parent;
    if (pCVar4->side == 'P') {
      pVVar1 = pVVar1->prev;
    }
    if (((*(byte *)&pVVar1->Flags & 8) == 0) &&
       (iVar2 = (*rule)(pCVar4->poly,pVVar1,local_20), iVar2 != 0)) {
      if (pCVar4->side == 'N') {
        if (local_20[0] == FORW) {
          DVar3 = FORW;
          goto LAB_080b4a8d;
        }
      }
      else {
        if ((pCVar4->side == 'P') && (local_20[0] == BACKW)) {
          DVar3 = BACKW;
LAB_080b4a8d:
          pVVar1 = pCVar4->parent;
          *cdir = DVar3;
          *cur = pVVar1;
          return 1;
        }
      }
    }
    pCVar4 = pCVar4->prev;
    if (pCVar5 == pCVar4) {
      return 0;
    }
    local_20[0] = *cdir;
  } while( true );
}



void poly_IniContour(PLINE *c)

{
  if (c != (PLINE *)0x0) {
    (c->head).prev = &c->head;
    (c->head).next = &c->head;
    c->ymin = 0x7fffffff;
    c->xmin = 0x7fffffff;
    c->ymax = -0x80000000;
    c->xmax = -0x80000000;
  }
  return;
}



int flip_cb(BoxType *b,void *cl)

{
  b[1].X1 = *(LocationType *)(b[1].X1 + 4);
  return 1;
}



void poly_M_Incl(POLYAREA **list,POLYAREA *a)

{
  POLYAREA *pPVar1;
  
  if (*list != (POLYAREA *)0x0) {
    a->f = *list;
    a->b = (*list)->b;
    pPVar1 = (*list)->b;
    (*list)->b = a;
    pPVar1->f = a;
    return;
  }
  a->b = a;
  a->f = a;
  *list = a;
  return;
}



BOOLp poly_InclContour(POLYAREA *p,PLINE *c)

{
  PLINE *pPVar1;
  PLINE *pPVar2;
  
  if ((c != (PLINE *)0x0) && (p != (POLYAREA *)0x0)) {
    if ((*(byte *)&c->Flags & 8) == 0) {
      pPVar1 = p->contours;
      if (pPVar1 != (PLINE *)0x0) {
        pPVar2 = pPVar1->next;
        pPVar1->next = c;
        c->next = pPVar2;
        return 1;
      }
    }
    else {
      if (p->contours == (PLINE *)0x0) {
        p->contours = c;
        return 1;
      }
    }
  }
  return 0;
}



void poly_Init(POLYAREA *p)

{
  p->b = p;
  p->f = p;
  p->contours = (PLINE *)0x0;
  return;
}



BOOLp __regparm3 inside_sector(VNODE *pn,int *p2)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  float10 fVar6;
  uint uVar7;
  float10 fVar8;
  float10 fVar9;
  float10 fVar10;
  float10 fVar11;
  
  iVar1 = pn->point[0];
  iVar2 = pn->point[1];
  fVar8 = (float10)(iVar1 - pn->prev->point[0]);
  fVar9 = (float10)(iVar2 - pn->prev->point[1]);
  fVar6 = (float10)0;
  bVar3 = fVar6 <= fVar8 * (float10)(p2[1] - iVar2) - (float10)(*p2 - iVar1) * fVar9;
  fVar10 = (float10)(pn->next->point[0] - iVar1);
  fVar11 = (float10)(pn->next->point[1] - iVar2);
  bVar4 = fVar6 <= (float10)(p2[1] - iVar2) * fVar10 - (float10)(*p2 - iVar1) * fVar11;
  bVar5 = fVar6 <= fVar11 * fVar8 - fVar9 * fVar10;
  if ((bVar3) && (bVar5)) {
    return (uint)bVar4;
  }
  uVar7 = 0;
  if (!bVar5) {
    uVar7 = (uint)(bVar3 || bVar4);
  }
  return uVar7;
}



void vect_init(int *v,double x,double y)

{
  *v = (int)ROUND(x);
  v[1] = (int)ROUND(y);
  return;
}



int vect_equal(int *v1,int *v2)

{
  if (*v1 != *v2) {
    return 0;
  }
  return (uint)(v1[1] == v2[1]);
}



void __regparm3 vect_sub(int *res,int *v1,int *v2)

{
  int *in_stack_00000004;
  int *in_stack_00000008;
  int *in_stack_0000000c;
  
  *in_stack_00000004 = *in_stack_00000008 - *in_stack_0000000c;
  in_stack_00000004[1] = in_stack_00000008[1] - in_stack_0000000c[1];
  return;
}



void vect_min(int *v1,int *v2,int *v3)

{
  int iVar1;
  
  iVar1 = *v2;
  if (*v3 == iVar1 || *v3 < iVar1) {
    iVar1 = *v3;
  }
  *v1 = iVar1;
  iVar1 = v2[1];
  if (v3[1] == iVar1 || v3[1] < iVar1) {
    iVar1 = v3[1];
  }
  v1[1] = iVar1;
  return;
}



void vect_max(int *v1,int *v2,int *v3)

{
  int iVar1;
  
  iVar1 = *v2;
  if (iVar1 <= *v3) {
    iVar1 = *v3;
  }
  *v1 = iVar1;
  iVar1 = v2[1];
  if (iVar1 <= v3[1]) {
    iVar1 = v3[1];
  }
  v1[1] = iVar1;
  return;
}



double vect_len2(int *v)

{
  return (double)v[1] * (double)v[1] + (double)*v * (double)*v;
}



double vect_dist2(int *v1,int *v2)

{
  return (double)(v1[1] - v2[1]) * (double)(v1[1] - v2[1]) +
         (double)(*v1 - *v2) * (double)(*v1 - *v2);
}



double vect_det2(int *v1,int *v2)

{
  return (double)v2[1] * (double)*v1 - (double)v1[1] * (double)*v2;
}



// WARNING: Removing unreachable block (ram,0x080b50fc)
// WARNING: Removing unreachable block (ram,0x080b5084)

int vect_inters2(int *p1,int *p2,int *q1,int *q2,int *S1,int *S2)

{
  int iVar1;
  int iVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int local_30;
  int local_20;
  
  local_30 = *p2;
  iVar8 = *p1;
  iVar10 = *q2;
  iVar1 = *q1;
  iVar13 = iVar8;
  if (iVar8 <= local_30) {
    iVar13 = local_30;
  }
  iVar11 = iVar1;
  if (iVar10 <= iVar1) {
    iVar11 = iVar10;
  }
  if (iVar11 <= iVar13) {
    iVar13 = iVar1;
    if (iVar1 <= iVar10) {
      iVar13 = iVar10;
    }
    iVar11 = iVar8;
    if (local_30 <= iVar8) {
      iVar11 = local_30;
    }
    if (iVar11 <= iVar13) {
      iVar13 = p2[1];
      iVar11 = p1[1];
      iVar2 = q2[1];
      local_20 = q1[1];
      iVar9 = iVar13;
      if (iVar13 < iVar11) {
        iVar9 = iVar11;
      }
      iVar12 = local_20;
      if (iVar2 <= local_20) {
        iVar12 = iVar2;
      }
      if (iVar12 <= iVar9) {
        iVar9 = local_20;
        if (local_20 <= iVar2) {
          iVar9 = iVar2;
        }
        iVar12 = iVar13;
        if (iVar11 < iVar13) {
          iVar12 = iVar11;
        }
        if (iVar12 <= iVar9) {
          dVar4 = (double)(iVar10 - iVar1);
          dVar5 = (double)(iVar2 - local_20);
          dVar6 = (double)(iVar13 - iVar11) * dVar4 - (double)(local_30 - iVar8) * dVar5;
          if (dVar6 == 0.00000000) {
            if ((double)(local_20 - iVar2) * (double)(iVar1 - iVar8) -
                (double)(local_20 - iVar11) * (double)(iVar1 - iVar10) == 0.00000000) {
              dVar6 = (double)(iVar8 - local_30);
              dVar4 = (double)(iVar11 - iVar13);
              dVar5 = dVar4 * dVar4 + dVar6 * dVar6;
              if ((dVar6 <= 0.00000000) && ((dVar6 < 0.00000000 || (dVar4 <= 0.00000000)))) {
                dVar5 = -dVar5;
              }
              dVar6 = (double)(iVar8 - iVar1);
              dVar3 = (double)(iVar11 - local_20);
              dVar4 = dVar3 * dVar3 + dVar6 * dVar6;
              if ((dVar6 <= 0.00000000) && ((dVar6 < 0.00000000 || (dVar3 <= 0.00000000)))) {
                dVar4 = -dVar4;
              }
              dVar3 = (double)(iVar8 - iVar10);
              dVar7 = (double)(iVar11 - iVar2);
              dVar6 = dVar7 * dVar7 + dVar3 * dVar3;
              if ((dVar3 <= 0.00000000) && ((dVar3 < 0.00000000 || (dVar7 <= 0.00000000)))) {
                dVar6 = -dVar6;
              }
              iVar9 = iVar8;
              iVar12 = iVar11;
              dVar3 = 0.00000000;
              if (dVar5 < 0.00000000) {
                iVar9 = local_30;
                iVar12 = iVar13;
                dVar3 = dVar5;
                dVar5 = 0.00000000;
                local_30 = iVar8;
                iVar13 = iVar11;
              }
              iVar8 = iVar1;
              iVar11 = iVar2;
              dVar7 = dVar6;
              if (dVar6 < dVar4) {
                iVar8 = iVar10;
                iVar10 = iVar1;
                iVar11 = local_20;
                dVar7 = dVar4;
                dVar4 = dVar6;
                local_20 = iVar2;
              }
              if (dVar4 <= dVar3) {
                if (dVar3 <= dVar7) {
                  if (dVar7 <= dVar5) {
                    *S1 = iVar9;
                    S1[1] = iVar12;
                    *S2 = iVar10;
                    S2[1] = iVar11;
                  }
                  else {
                    S1[1] = iVar12;
                    *S1 = iVar9;
                    S2[1] = iVar13;
                    *S2 = local_30;
                  }
                  goto LAB_080b5060;
                }
              }
              else {
                if (dVar4 <= dVar5) {
                  if (dVar7 <= dVar5) {
                    *S1 = iVar8;
                    S1[1] = local_20;
                    *S2 = iVar10;
                    S2[1] = iVar11;
                  }
                  else {
                    *S1 = local_30;
                    S1[1] = iVar13;
                    *S2 = iVar8;
                    S2[1] = local_20;
                  }
LAB_080b5060:
                  if ((*S1 == *S2) && (S1[1] == S2[1])) {
                    return 1;
                  }
                  return 2;
                }
              }
            }
          }
          else {
            if (((iVar8 == iVar1) && (iVar11 == local_20)) ||
               ((local_30 == iVar1 && (iVar13 == local_20)))) {
              *S1 = iVar1;
              S1[1] = q1[1];
              return 1;
            }
            if (((iVar8 == iVar10) && (iVar11 == iVar2)) ||
               ((local_30 == iVar10 && (iVar13 == iVar2)))) {
              *S1 = iVar10;
              S1[1] = q2[1];
              return 1;
            }
            dVar3 = ((double)(local_20 - iVar11) * dVar4 + (double)(iVar8 - iVar1) * dVar5) / dVar6;
            if ((((0.00000000 <= dVar3) && (dVar3 <= 1.00000000)) &&
                (dVar6 = ((double)(local_30 - iVar8) * (double)(local_20 - iVar11) +
                         (double)(iVar13 - iVar11) * (double)(iVar8 - iVar1)) / dVar6,
                0.00000000 <= dVar6)) && (dVar6 <= 1.00000000)) {
              dVar4 = dVar4 * dVar6;
              if (dVar4 <= 0.00000000) {
                dVar4 = dVar4 - 0.50000000;
              }
              else {
                dVar4 = dVar4 + 0.50000000;
              }
              dVar5 = dVar5 * dVar6;
              *S1 = (int)ROUND(dVar4) + iVar1;
              if (dVar5 <= 0.00000000) {
                dVar5 = dVar5 - 0.50000000;
              }
              else {
                dVar5 = dVar5 + 0.50000000;
              }
              S1[1] = (int)ROUND(dVar5) + q1[1];
              return 1;
            }
          }
        }
      }
    }
  }
  return 0;
}



BOOLp poly_ChkContour(PLINE *a)

{
  VNODE *pVVar1;
  double dVar2;
  double dVar3;
  VNODE *pVVar4;
  VNODE *pVVar5;
  VNODE *pVVar6;
  int iVar7;
  BOOLp BVar8;
  VNODE *pn;
  VNODE *pn_00;
  Vector i2;
  Vector i1;
  
  pVVar5 = &a->head;
  pVVar6 = pVVar5;
  do {
    pn = pVVar6->next;
    pn_00 = pn;
    while (pVVar4 = pn_00, pVVar5 != pVVar4) {
      pn_00 = pn;
      if (pVVar6 != pVVar4) {
        if (pn == pVVar4) {
          pn_00 = pn->next;
        }
        else {
          pVVar1 = pVVar4->next;
          pn_00 = pVVar6;
          if ((pVVar6 != pVVar1) && (pn_00 = pn, pn != pVVar1)) {
            iVar7 = vect_inters2(pVVar6->point,pn->point,pVVar4->point,pVVar1->point,i1,i2);
            if ((0 < iVar7) &&
               ((((iVar7 != 1 ||
                  ((dVar2 = (double)(i1[0] - pVVar6->point[0]),
                   dVar3 = (double)(i1[1] - pVVar6->point[1]), pn = pVVar6,
                   0.00000001 <= dVar3 * dVar3 + dVar2 * dVar2 &&
                   (pn = pVVar6->next, dVar2 = (double)(i1[0] - pn->point[0]),
                   dVar3 = (double)(i1[1] - pn->point[1]),
                   0.00000001 <= dVar3 * dVar3 + dVar2 * dVar2)))) ||
                 ((dVar2 = (double)(i1[0] - pVVar4->point[0]),
                  dVar3 = (double)(i1[1] - pVVar4->point[1]), pn_00 = pVVar4,
                  0.00000001 <= dVar3 * dVar3 + dVar2 * dVar2 &&
                  (pn_00 = pVVar4->next, dVar2 = (double)(i1[0] - pn_00->point[0]),
                  dVar3 = (double)(i1[1] - pn_00->point[1]),
                  0.00000001 <= dVar3 * dVar3 + dVar2 * dVar2)))) ||
                ((((BVar8 = inside_sector(pn,pn_00->prev->point), BVar8 != 0 ||
                   (BVar8 = inside_sector(pn,pn_00->next->point), BVar8 != 0)) ||
                  (BVar8 = inside_sector(pn_00,pn->prev->point), BVar8 != 0)) ||
                 (BVar8 = inside_sector(pn_00,pn->next->point), BVar8 != 0)))))) {
              return 1;
            }
            pn = pVVar6->next;
            pn_00 = pVVar4->next;
          }
        }
      }
    }
    pVVar6 = pn;
    if (pVVar5 == pn) {
      return 0;
    }
  } while( true );
}



void poly_InclVertex(VNODE *after,VNODE *node)

{
  VNODE *__ptr;
  VNODE *pVVar1;
  
  __ptr = after->next;
  node->prev = after;
  node->next = __ptr;
  __ptr = after->next;
  after->next = node;
  __ptr->prev = node;
  __ptr = node->prev;
  pVVar1 = __ptr->prev;
  if (pVVar1 != node) {
    if (ABS((double)(__ptr->point[0] - pVVar1->point[0]) *
            (double)(node->point[1] - pVVar1->point[1]) -
            (double)(__ptr->point[1] - pVVar1->point[1]) *
            (double)(node->point[0] - pVVar1->point[0])) < 0.00000001) {
      pVVar1->next = node;
      node->prev = pVVar1;
      free(__ptr);
      return;
    }
  }
  return;
}



void poly_ExclVertex(VNODE *node)

{
  VNODE *pVVar1;
  
  if (node->cvc_next != (CVCList *)0x0) {
    free(node->cvc_next);
    free(node->cvc_prev);
  }
  pVVar1 = node->prev;
  pVVar1->next = node->next;
  node->next->prev = pVVar1;
  return;
}



void poly_ClrContour(PLINE *c)

{
  VNODE *node;
  
  node = (c->head).next;
  while (node != &c->head) {
    poly_ExclVertex(node);
    free(node);
    node = (c->head).next;
  }
  (c->head).prev = node;
  (c->head).next = node;
  c->ymin = 0x7fffffff;
  c->xmin = 0x7fffffff;
  c->ymax = -0x80000000;
  c->xmax = -0x80000000;
  return;
}



POLYAREA * poly_Create(void)

{
  POLYAREA *pPVar1;
  
  pPVar1 = (POLYAREA *)malloc(0xc);
  if (pPVar1 != (POLYAREA *)0x0) {
    pPVar1->b = pPVar1;
    pPVar1->f = pPVar1;
    pPVar1->contours = (PLINE *)0x0;
  }
  return pPVar1;
}



CVCList * __regparm3 insert_descriptor(VNODE *a,char poly,char side,CVCList *start)

{
  double dVar1;
  double dVar2;
  CVCList *pCVar3;
  double dVar4;
  CVCList *pCVar5;
  VNODE *node;
  int iVar6;
  int iVar7;
  CVCList *pCVar8;
  VNODE *pVVar9;
  CVCList *pCVar10;
  CVCList *pCVar11;
  int iVar12;
  CVCList *pCVar13;
  CVCList *pCVar14;
  bool bVar15;
  
  pCVar5 = (CVCList *)malloc(0x1c);
  if (pCVar5 != (CVCList *)0x0) {
    pCVar5->poly = poly;
    pCVar5->head = (CVCList *)0x0;
    pCVar5->parent = a;
    pCVar5->side = side;
    pCVar5->prev = pCVar5;
    pCVar5->next = pCVar5;
    if (side == 'P') {
      node = a->prev;
    }
    else {
      node = a->next;
    }
    iVar12 = a->point[0];
    iVar6 = node->point[1] - a->point[1];
    iVar7 = node->point[0] - iVar12;
    if ((vect_zero[0] == iVar7) && (iVar7 = vect_zero[0], vect_zero[1] == iVar6)) {
      if (side == 'P') {
        node = a->prev;
        if (node->cvc_prev == (CVCList *)0xffffffff) {
          node->cvc_next = (CVCList *)0x0;
          node->cvc_prev = (CVCList *)0x0;
        }
        poly_ExclVertex(node);
        iVar12 = a->point[0];
        iVar6 = a->prev->point[1] - a->point[1];
        iVar7 = a->prev->point[0] - iVar12;
      }
      else {
        node = a->next;
        if (node->cvc_prev == (CVCList *)0xffffffff) {
          node->cvc_next = (CVCList *)0x0;
          node->cvc_prev = (CVCList *)0x0;
        }
        poly_ExclVertex(node);
        iVar12 = a->point[0];
        iVar6 = a->next->point[1] - a->point[1];
        iVar7 = a->next->point[0] - iVar12;
      }
    }
    dVar4 = ABS((double)iVar6) / (ABS((double)iVar7) + ABS((double)iVar6));
    if (iVar7 < 0) {
      if (iVar6 < 0) {
        dVar4 = dVar4 + 2.00000000;
      }
      else {
        dVar4 = 2.00000000 - dVar4;
      }
    }
    else {
      if (iVar6 < 0) {
        dVar4 = 4.00000000 - dVar4;
      }
    }
    pCVar5->angle = dVar4;
    if (start == (CVCList *)0x0) {
      pCVar5->head = pCVar5;
    }
    else {
      node = start->parent;
      pCVar8 = start;
      pVVar9 = node;
      if (iVar12 == node->point[0]) goto LAB_080b5781;
      do {
        do {
          pCVar3 = pCVar8->head;
          pVVar9 = pCVar3->parent;
          if ((pVVar9->point[0] == node->point[0]) && (pVVar9->point[1] == node->point[1])) {
            while (pCVar5 != pCVar3) {
              pCVar8->head = pCVar5;
              pCVar8 = pCVar8->next;
              pCVar3 = pCVar8->head;
            }
            pCVar5->head = start;
            return pCVar5;
          }
          pCVar8 = pCVar3;
        } while (iVar12 != pVVar9->point[0]);
LAB_080b5781:
      } while (pVVar9->point[1] != a->point[1]);
      dVar1 = pCVar8->angle;
      pCVar5->head = pCVar8->head;
      pCVar3 = pCVar8;
      pCVar10 = pCVar8;
      pCVar13 = pCVar8;
      do {
        while( true ) {
          pCVar14 = pCVar3;
          pCVar11 = pCVar14->next;
          dVar2 = pCVar11->angle;
          pCVar3 = pCVar11;
          if (dVar1 <= dVar2) break;
          pCVar10 = pCVar11;
          pCVar13 = pCVar14;
          dVar1 = dVar2;
          if (pCVar8 == pCVar11) goto LAB_080b57d1;
        }
        if ((dVar1 <= dVar4) && (dVar4 <= dVar2)) {
          pCVar5->next = pCVar11;
          pCVar8 = pCVar14->next;
          pCVar5->prev = pCVar14;
          pCVar14->next = pCVar5;
          pCVar8->prev = pCVar5;
          return pCVar5;
        }
        bVar15 = pCVar8 != pCVar11;
        pCVar11 = pCVar10;
        pCVar14 = pCVar13;
        dVar1 = dVar2;
      } while (bVar15);
LAB_080b57d1:
      if (pCVar14->angle <= dVar4) {
        pCVar8 = pCVar14->next;
        pCVar5->prev = pCVar14;
        pCVar5->next = pCVar8;
        pCVar8 = pCVar14->next;
        pCVar14->next = pCVar5;
        pCVar8->prev = pCVar5;
        return pCVar5;
      }
      pCVar5->next = pCVar11;
      pCVar5->prev = pCVar11->prev;
      pCVar8 = pCVar11->prev;
      pCVar11->prev = pCVar5;
      pCVar8->next = pCVar5;
    }
  }
  return pCVar5;
}



CVCList * __regparm3 add_descriptors(PLINE *pl,char poly,CVCList *list)

{
  CVCList *start;
  VNODE *a;
  
  a = &pl->head;
  do {
    if (a->cvc_prev != (CVCList *)0x0) {
      start = insert_descriptor(a,poly,'P',list);
      a->cvc_prev = start;
      if (start == (CVCList *)0x0) {
        return (CVCList *)0x0;
      }
      list = insert_descriptor(a,poly,'N',start);
      a->cvc_next = list;
      if (list == (CVCList *)0x0) {
        return (CVCList *)0x0;
      }
    }
    a = a->next;
    if (&pl->head == a) {
      return list;
    }
  } while( true );
}



int poly_InsideContour(PLINE *c,int *p)

{
  int iVar1;
  pip info;
  BoxType ray;
  
  info.p[0] = *p;
  if ((((c->xmin <= info.p[0]) && (info.p[1] = p[1], c->ymin <= info.p[1])) &&
      (info.p[0] <= c->xmax)) && (info.p[1] <= c->ymax)) {
    ray.Y2 = info.p[1] + 1;
    info.f = 0;
    ray.X2 = 0x7fffffff;
    ray.X1 = info.p[0];
    ray.Y1 = info.p[1];
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    if (iVar1 == 0) {
      r_search(c->tree,&ray,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,crossing,&info);
    }
    return info.f;
  }
  return 0;
}



int poly_ContourInContour(PLINE *poly,PLINE *inner)

{
  int iVar1;
  
  if ((((poly->xmin <= inner->xmin) && (poly->ymin <= inner->ymin)) && (inner->xmax <= poly->xmax))
     && (inner->ymax <= poly->ymax)) {
    iVar1 = poly_InsideContour(poly,(inner->head).point);
    return iVar1;
  }
  return 0;
}



BOOLp poly_Valid(POLYAREA *p)

{
  PLINE *a;
  BOOLp BVar1;
  int iVar2;
  
  if ((((p == (POLYAREA *)0x0) || (a = p->contours, a == (PLINE *)0x0)) ||
      ((*(byte *)&a->Flags & 8) == 0)) || (BVar1 = poly_ChkContour(a), BVar1 != 0)) {
LAB_080b5abc:
    BVar1 = 0;
  }
  else {
    a = p->contours->next;
    while (a != (PLINE *)0x0) {
      if ((((*(byte *)&a->Flags & 8) != 0) || (BVar1 = poly_ChkContour(a), BVar1 != 0)) ||
         (iVar2 = poly_ContourInContour(p->contours,a), iVar2 == 0)) goto LAB_080b5abc;
      a = a->next;
    }
    BVar1 = 1;
  }
  return BVar1;
}



BOOLp poly_CheckInside(POLYAREA *p,int *v0)

{
  int iVar1;
  PLINE *c;
  
  if ((((v0 != (int *)0x0) && (p != (POLYAREA *)0x0)) && (c = p->contours, c != (PLINE *)0x0)) &&
     (iVar1 = poly_InsideContour(c,v0), iVar1 != 0)) {
    do {
      c = c->next;
      if (c == (PLINE *)0x0) {
        return 1;
      }
      iVar1 = poly_InsideContour(c,v0);
    } while (iVar1 == 0);
  }
  return 0;
}



BOOLp poly_M_CheckInside(POLYAREA *p,int *v0)

{
  POLYAREA **ppPVar1;
  BOOLp BVar2;
  POLYAREA *p_00;
  
  if ((v0 != (int *)0x0) && (p_00 = p, p != (POLYAREA *)0x0)) {
    do {
      BVar2 = poly_CheckInside(p_00,v0);
      if (BVar2 != 0) {
        return 1;
      }
      ppPVar1 = &p_00->f;
      p_00 = *ppPVar1;
    } while (*ppPVar1 != p);
  }
  return 0;
}



void poly_InvContour(PLINE *c)

{
  VNODE *pVVar1;
  VNODE *pVVar2;
  
  pVVar2 = &c->head;
  do {
    pVVar1 = pVVar2->next;
    pVVar2->next = pVVar2->prev;
    pVVar2->prev = pVVar1;
    pVVar2 = pVVar1;
  } while (&c->head != pVVar1);
  *(byte *)&c->Flags =
       *(byte *)&c->Flags & 0xf7 | (byte)(((uint)(*(byte *)&c->Flags >> 3) & 1 ^ 1) << 3);
  if (c->tree != (rtree_t *)0x0) {
    r_search(c->tree,(BoxType *)0x0,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,flip_cb,(void *)0x0);
  }
  return;
}



int crossing(BoxType *b,void *cl)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  longlong lVar6;
  longlong lVar7;
  uint uVar8;
  uint uVar9;
  
  piVar1 = (int *)b[1].X1;
  iVar2 = *(int *)((int)cl + 8);
  iVar3 = piVar1[7];
  if (iVar2 < iVar3) {
    iVar4 = *(int *)(*piVar1 + 0x1c);
    if (iVar4 <= iVar2) {
      lVar6 = (longlong)(iVar2 - iVar3) * (longlong)(*(int *)(*piVar1 + 0x18) - piVar1[6]);
      uVar8 = (uint)lVar6;
      lVar7 = (longlong)(*(int *)((int)cl + 4) - piVar1[6]) * (longlong)(iVar4 - iVar3);
      uVar9 = (uint)lVar7;
      uVar5 = ((int)((ulonglong)lVar6 >> 0x20) - (int)((ulonglong)lVar7 >> 0x20)) -
              (uint)(uVar8 < uVar9);
      if ((uVar5 | uVar8 - uVar9) == 0) goto LAB_080b5d2a;
      if ((int)uVar5 < 0) {
        *(int *)cl = *(int *)cl + -1;
      }
    }
  }
  else {
    iVar4 = *(int *)(*piVar1 + 0x1c);
    if (iVar2 < iVar4) {
      lVar6 = (longlong)(iVar2 - iVar3) * (longlong)(*(int *)(*piVar1 + 0x18) - piVar1[6]);
      uVar8 = (uint)lVar6;
      lVar7 = (longlong)(*(int *)((int)cl + 4) - piVar1[6]) * (longlong)(iVar4 - iVar3);
      uVar9 = (uint)lVar7;
      uVar5 = uVar8 - uVar9;
      uVar8 = ((int)((ulonglong)lVar6 >> 0x20) - (int)((ulonglong)lVar7 >> 0x20)) -
              (uint)(uVar8 < uVar9);
      if ((uVar8 | uVar5) == 0) {
LAB_080b5d2a:
        *(undefined4 *)cl = 1;
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0xc,1);
      }
      if ((-1 < (int)uVar8) && ((0 < (int)uVar8 || (uVar5 != 0)))) {
        *(int *)cl = *(int *)cl + 1;
      }
    }
  }
  return 1;
}



int get_seg(BoxType *b,void *cl)

{
  if (*(int *)((int)cl + 0x14) != b[1].X1) {
    return 0;
  }
  *(BoxType **)((int)cl + 0x18) = b;
                    // WARNING: Subroutine does not return
  __longjmp_chk((int)cl + 0xb8,1);
}



PLINE * poly_NewContour(int *v)

{
  int iVar1;
  int iVar2;
  PLINE *pPVar3;
  
  pPVar3 = (PLINE *)calloc(1,0x48);
  if (pPVar3 != (PLINE *)0x0) {
    (pPVar3->head).prev = &pPVar3->head;
    (pPVar3->head).next = &pPVar3->head;
    pPVar3->ymin = 0x7fffffff;
    pPVar3->xmin = 0x7fffffff;
    pPVar3->ymax = -0x80000000;
    pPVar3->xmax = -0x80000000;
    if (v != (int *)0x0) {
      iVar1 = *v;
      (pPVar3->head).point[0] = iVar1;
      iVar2 = v[1];
      pPVar3->xmin = iVar1;
      pPVar3->xmax = iVar1 + 1;
      (pPVar3->head).point[1] = iVar2;
      pPVar3->ymin = iVar2;
      pPVar3->ymax = iVar2 + 1;
    }
  }
  return pPVar3;
}



VNODE * poly_CreateNode(int *v)

{
  VNODE *pVVar1;
  
  pVVar1 = (VNODE *)calloc(1,0x20);
  if (pVVar1 != (VNODE *)0x0) {
    pVVar1->point[0] = *v;
    pVVar1->point[1] = v[1];
  }
  return pVVar1;
}



VNODE * __regparm3 node_add(VNODE *dest,int *po,int *new_point)

{
  int iVar1;
  VNODE *pVVar2;
  VNODE *pVVar3;
  
  if (*po == dest->point[0]) {
    if (po[1] == dest->point[1]) {
      return dest;
    }
    pVVar3 = dest->next;
    iVar1 = pVVar3->point[0];
  }
  else {
    pVVar3 = dest->next;
    iVar1 = pVVar3->point[0];
  }
  if ((*po == iVar1) && (po[1] == pVVar3->point[1])) {
    *new_point = *new_point + 4;
  }
  else {
    pVVar3 = poly_CreateNode(po);
    if (pVVar3 == (VNODE *)0x0) {
      pVVar3 = (VNODE *)0x0;
    }
    else {
      pVVar2 = dest->next;
      *new_point = *new_point + 5;
      *(byte *)&pVVar3->Flags = *(byte *)&pVVar3->Flags & 0xf8;
      pVVar3->next = pVVar2;
      pVVar2 = dest->next;
      pVVar3->prev = dest;
      dest->next = pVVar3;
      pVVar3->cvc_next = (CVCList *)0x0;
      pVVar3->cvc_prev = (CVCList *)0x0;
      pVVar2->prev = pVVar3;
    }
  }
  return pVVar3;
}



void * __regparm3 make_edge_tree(PLINE *pb)

{
  VNODE *pVVar1;
  rtree_t *rtree;
  BoxType *which;
  int iVar2;
  VNODE *pVVar3;
  
  rtree = r_create_tree((BoxType **)0x0,0,0);
  pVVar3 = &pb->head;
  do {
    which = (BoxType *)malloc(0x18);
    pVVar1 = pVVar3->next;
    iVar2 = pVVar3->point[0];
    if (iVar2 < pVVar1->point[0]) {
      which->X1 = iVar2;
      which->X2 = pVVar1->point[0] + 1;
      iVar2 = pVVar3->point[1];
      if (iVar2 < pVVar1->point[1]) goto LAB_080b5f0b;
LAB_080b5f61:
      which->Y2 = iVar2 + 1;
      which->Y1 = pVVar1->point[1];
    }
    else {
      which->X2 = iVar2 + 1;
      which->X1 = pVVar1->point[0];
      iVar2 = pVVar3->point[1];
      if (pVVar1->point[1] <= iVar2) goto LAB_080b5f61;
LAB_080b5f0b:
      which->Y1 = iVar2;
      which->Y2 = pVVar1->point[1] + 1;
    }
    *(VNODE **)&which[1].X1 = pVVar3;
    *(PLINE **)&which[1].Y1 = pb;
    r_insert_entry(rtree,which,1);
    pVVar3 = pVVar3->next;
    if (&pb->head == pVVar3) {
      return rtree;
    }
  } while( true );
}



BOOLp poly_CopyContour(PLINE **dst,PLINE *src)

{
  int iVar1;
  PLINE *pb;
  VNODE *node;
  rtree_t *prVar2;
  VNODE *pVVar3;
  
  *dst = (PLINE *)0x0;
  pb = poly_NewContour((src->head).point);
  *dst = pb;
  if (pb == (PLINE *)0x0) {
    return 0;
  }
  pb->Count = src->Count;
  *(byte *)&pb->Flags = *(byte *)&pb->Flags & 0xf7 | *(byte *)&src->Flags & 8;
  pb = *dst;
  iVar1 = src->xmin;
  pVVar3 = (src->head).next;
  pb->area = src->area;
  pb->xmin = iVar1;
  pb->xmax = src->xmax;
  pb->ymin = src->ymin;
  pb->ymax = src->ymax;
  if (pVVar3 != &src->head) {
    do {
      node = poly_CreateNode(pVVar3->point);
      if (node == (VNODE *)0x0) {
        return 0;
      }
      poly_InclVertex(((*dst)->head).prev,node);
      pVVar3 = pVVar3->next;
    } while (pVVar3 != &src->head);
    pb = *dst;
  }
  prVar2 = (rtree_t *)make_edge_tree(pb);
  pb->tree = prVar2;
  return 1;
}



BOOLp poly_Copy1(POLYAREA *dst,POLYAREA *src)

{
  PLINE *src_00;
  BOOLp BVar1;
  PLINE **dst_00;
  
  dst->contours = (PLINE *)0x0;
  dst_00 = &dst->contours;
  dst->b = dst;
  dst->f = dst;
  src_00 = src->contours;
  while( true ) {
    if (src_00 == (PLINE *)0x0) {
      return 1;
    }
    BVar1 = poly_CopyContour(dst_00,src_00);
    if (BVar1 == 0) break;
    src_00 = src_00->next;
    dst_00 = &(*dst_00)->next;
  }
  return 0;
}



BOOLp poly_M_Copy0(POLYAREA **dst,POLYAREA *srcfst)

{
  POLYAREA *pPVar1;
  POLYAREA **ppPVar2;
  POLYAREA *dst_00;
  BOOLp BVar3;
  POLYAREA *src;
  
  *dst = (POLYAREA *)0x0;
  src = srcfst;
  if (srcfst == (POLYAREA *)0x0) {
    return 0;
  }
  while( true ) {
    dst_00 = poly_Create();
    if (dst_00 == (POLYAREA *)0x0) {
      return 0;
    }
    BVar3 = poly_Copy1(dst_00,src);
    if (BVar3 == 0) break;
    if (*dst == (POLYAREA *)0x0) {
      dst_00->f = dst_00;
      dst_00->b = dst_00;
      *dst = dst_00;
      ppPVar2 = &src->f;
      src = *ppPVar2;
      if (*ppPVar2 == srcfst) {
        return 1;
      }
    }
    else {
      dst_00->f = *dst;
      dst_00->b = (*dst)->b;
      pPVar1 = (*dst)->b;
      (*dst)->b = dst_00;
      pPVar1->f = dst_00;
      ppPVar2 = &src->f;
      src = *ppPVar2;
      if (*ppPVar2 == srcfst) {
        return 1;
      }
    }
  }
  return 0;
}



BOOLp poly_Copy0(POLYAREA **dst,POLYAREA *src)

{
  POLYAREA *dst_00;
  BOOLp BVar1;
  
  *dst = (POLYAREA *)0x0;
  if (src != (POLYAREA *)0x0) {
    dst_00 = (POLYAREA *)calloc(1,0xc);
    *dst = dst_00;
    if (dst_00 != (POLYAREA *)0x0) {
      BVar1 = poly_Copy1(dst_00,src);
      return BVar1;
    }
  }
  return 0;
}



void poly_PreContour(PLINE *C,BOOLp optimize)

{
  VNODE *pVVar1;
  VNODE *pVVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  double dVar6;
  VNODE *pVVar7;
  bool bVar8;
  VNODE *pVVar9;
  rtree_t *prVar10;
  int iVar11;
  VNODE *node;
  int iVar12;
  int iVar13;
  int iVar14;
  int local_40;
  VNODE *local_2c;
  int local_24;
  
  pVVar1 = &C->head;
  if (optimize != 0) {
    pVVar9 = pVVar1;
    pVVar2 = (C->head).next;
    while (node = pVVar2, pVVar7 = pVVar9, pVVar1 != node) {
      while (pVVar2 = node->next, pVVar9 = node,
            (double)(pVVar2->point[1] - node->point[1]) *
            (double)(node->point[0] - pVVar7->point[0]) -
            (double)(node->point[1] - pVVar7->point[1]) *
            (double)(pVVar2->point[0] - node->point[0]) == 0.00000000) {
        poly_ExclVertex(node);
        free(node);
        node = pVVar7->next;
        if (pVVar1 == node) goto LAB_080b623d;
      }
    }
  }
LAB_080b623d:
  iVar12 = (C->head).point[0];
  iVar11 = (C->head).point[1];
  local_2c = (C->head).prev;
  C->Count = 0;
  C->xmax = iVar12;
  C->xmin = iVar12;
  C->ymax = iVar11;
  C->ymin = iVar11;
  if (pVVar1 == local_2c) {
    bVar8 = false;
    dVar6 = 0.00000000;
  }
  else {
    dVar6 = 0.00000000;
    pVVar2 = pVVar1;
    local_40 = iVar12;
    local_24 = iVar11;
    do {
      pVVar9 = pVVar2;
      iVar14 = pVVar9->point[0];
      iVar3 = local_2c->point[0];
      iVar4 = pVVar9->point[1];
      iVar5 = local_2c->point[1];
      iVar13 = iVar14;
      if (local_40 <= iVar14) {
        iVar13 = local_40;
      }
      C->xmin = iVar13;
      dVar6 = (double)(iVar4 + iVar5) * (double)(iVar3 - iVar14) + dVar6;
      iVar14 = pVVar9->point[0] + 1;
      if (iVar12 <= iVar14) {
        iVar12 = iVar14;
      }
      C->xmax = iVar12;
      if (pVVar9->point[1] == iVar11 || pVVar9->point[1] < iVar11) {
        iVar11 = pVVar9->point[1];
      }
      C->ymin = iVar11;
      iVar14 = pVVar9->point[1] + 1;
      if (iVar14 < local_24) {
        iVar14 = local_24;
      }
      C->Count = C->Count + 1;
      C->ymax = iVar14;
      pVVar2 = pVVar9->next;
      local_40 = iVar13;
      local_2c = pVVar9;
      local_24 = iVar14;
    } while (pVVar1 != pVVar9->next);
    bVar8 = dVar6 < 0.00000000;
    if (dVar6 < 0.00000000) {
      dVar6 = -dVar6;
    }
  }
  C->area = dVar6;
  if (2 < C->Count) {
    *(byte *)&C->Flags = *(byte *)&C->Flags & 0xf7 | (bVar8 ^ 1U) * '\b';
  }
  prVar10 = (rtree_t *)make_edge_tree(C);
  C->tree = prVar10;
  return;
}



void poly_DelContour(PLINE **c)

{
  VNODE *pVVar1;
  CVCList *__ptr;
  PLINE *__ptr_00;
  VNODE *__ptr_01;
  rtree_t *local_20 [4];
  
  __ptr_00 = *c;
  if (__ptr_00 != (PLINE *)0x0) {
    __ptr_01 = (__ptr_00->head).prev;
    if (&__ptr_00->head != __ptr_01) {
      do {
        pVVar1 = __ptr_01->prev;
        if (__ptr_01->cvc_next != (CVCList *)0x0) {
          free(__ptr_01->cvc_next);
          free(__ptr_01->cvc_prev);
        }
        free(__ptr_01);
        __ptr_00 = *c;
        __ptr_01 = pVVar1;
      } while (&__ptr_00->head != pVVar1);
    }
    __ptr = (__ptr_00->head).cvc_next;
    if (__ptr != (CVCList *)0x0) {
      free(__ptr);
      free(((*c)->head).cvc_prev);
      __ptr_00 = *c;
    }
    if (__ptr_00->tree != (rtree_t *)0x0) {
      local_20[0] = __ptr_00->tree;
      r_destroy_tree(local_20);
      __ptr_00 = *c;
    }
    free(__ptr_00);
    *c = (PLINE *)0x0;
  }
  return;
}



void poly_FreeContours(PLINE **pline)

{
  PLINE *local_10;
  
  local_10 = *pline;
  if (local_10 != (PLINE *)0x0) {
    do {
      *pline = local_10->next;
      poly_DelContour(&local_10);
      local_10 = *pline;
    } while (local_10 != (PLINE *)0x0);
  }
  return;
}



void poly_Free(POLYAREA **p)

{
  POLYAREA *pPVar1;
  POLYAREA *__ptr;
  POLYAREA *pPVar2;
  
  pPVar1 = *p;
  if (pPVar1 != (POLYAREA *)0x0) {
    __ptr = pPVar1->f;
    pPVar2 = __ptr;
    if (pPVar1 != __ptr) {
      do {
        poly_FreeContours(&__ptr->contours);
        pPVar1 = __ptr->f;
        pPVar1->b = __ptr->b;
        __ptr->b->f = pPVar1;
        free(__ptr);
        pPVar2 = *p;
        __ptr = pPVar2->f;
      } while (pPVar2 != __ptr);
    }
    poly_FreeContours(&pPVar2->contours);
    free(*p);
    *p = (POLYAREA *)0x0;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080b6664)

int __regparm3 intersect(jmp_buf *jb,POLYAREA *b,POLYAREA *a,int add)

{
  PLINE *pPVar1;
  PLINE *pPVar2;
  PLINE *pPVar3;
  int iVar4;
  PLINE *pPVar5;
  VNODE *local_184;
  info info;
  BoxType box;
  
  info.touch = (jmp_buf *)0x0;
  if (add == 0) {
    info.touch = jb;
  }
  _setjmp((__jmp_buf_tag *)info.env);
  pPVar1 = a->contours;
  pPVar3 = b->contours;
  do {
    while( true ) {
      if (pPVar1 == (PLINE *)0x0) {
        return 0;
      }
      if (pPVar3 != (PLINE *)0x0) break;
LAB_080b650f:
      pPVar1 = pPVar1->next;
      pPVar3 = b->contours;
    }
    while ((((pPVar1->xmax < pPVar3->xmin || (pPVar3->xmax < pPVar1->xmin)) ||
            (pPVar1->ymax < pPVar3->ymin)) || (pPVar3->ymax < pPVar1->ymin))) {
      pPVar3 = pPVar3->next;
      if (pPVar3 == (PLINE *)0x0) goto LAB_080b650f;
    }
    pPVar5 = pPVar1;
    pPVar2 = pPVar3;
    if (pPVar1->Count < pPVar3->Count) {
      pPVar5 = pPVar3;
      pPVar2 = pPVar1;
    }
    local_184 = &pPVar2->head;
    do {
      info.v = local_184;
      box.X1 = local_184->point[0];
      info.m = (double)(local_184->next->point[0] - box.X1);
      if (info.m == 0.00000000) {
        box.Y1 = local_184->point[1];
        info.m = 0.00000000;
      }
      else {
        box.Y1 = local_184->point[1];
        info.m = (double)(local_184->next->point[1] - box.Y1) / info.m;
        info.b = (double)box.Y1 - (double)box.X1 * info.m;
      }
      box.X2 = box.X1 + 1;
      box.Y2 = box.Y1 + 1;
      iVar4 = _setjmp((__jmp_buf_tag *)info.sego);
      if (iVar4 == 0) {
        r_search(pPVar2->tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,get_seg,&info);
      }
      info.tree = pPVar5->tree;
      if ((info.tree != (rtree_t *)0x0) &&
         (iVar4 = r_search(info.tree,(BoxType *)info.s,seg_in_region,seg_in_seg,&info), iVar4 != 0))
      {
        return 2;
      }
      local_184 = local_184->next;
    } while (&pPVar2->head != local_184);
    pPVar3 = pPVar3->next;
  } while( true );
}



void __regparm3 M_POLYAREA_intersect(jmp_buf *e,POLYAREA *afst,POLYAREA *bfst,int add)

{
  PLINE *pPVar1;
  int iVar2;
  PLINE *pl;
  CVCList *list;
  POLYAREA *b;
  POLYAREA *local_20;
  
  if ((bfst == (POLYAREA *)0x0) || (afst == (POLYAREA *)0x0)) {
                    // WARNING: Subroutine does not return
    __longjmp_chk(e,3);
  }
  pl = bfst->contours;
  list = (CVCList *)0x0;
  b = afst;
  local_20 = bfst;
  do {
    pPVar1 = b->contours;
    if ((((pl->xmin <= pPVar1->xmax) && (pl->ymin <= pPVar1->ymax)) && (pPVar1->xmin <= pl->xmax))
       && (pPVar1->ymin <= pl->ymax)) {
      iVar2 = intersect(e,b,local_20,add);
      if (iVar2 != 0) {
LAB_080b6790:
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,2);
      }
      pl = local_20->contours;
    }
    if ((add == 0) || (b = b->f, b == afst)) {
      while (pl != (PLINE *)0x0) {
        if (((*(byte *)&pl->Flags & 7) == 3) &&
           (list = add_descriptors(pl,'B',list), list == (CVCList *)0x0)) goto LAB_080b6790;
        pl = pl->next;
      }
      if ((add == 0) || (local_20 = local_20->f, local_20 == bfst)) {
        do {
          pl = b->contours;
          while (pl != (PLINE *)0x0) {
            while ((*(byte *)&pl->Flags & 7) == 3) {
              list = add_descriptors(pl,'A',list);
              if (list == (CVCList *)0x0) goto LAB_080b6790;
              pl = pl->next;
              if (pl == (PLINE *)0x0) goto LAB_080b6838;
            }
            pl = pl->next;
          }
LAB_080b6838:
          if ((add == 0) || (b = b->f, b == afst)) {
            return;
          }
        } while( true );
      }
      pl = local_20->contours;
    }
  } while( true );
}



void __regparm3 PutContour(jmp_buf *e,PLINE *cntr,POLYAREA **contours,PLINE **holes,PLINE *parent)

{
  POLYAREA *pPVar1;
  POLYAREA *pPVar2;
  POLYAREA *pPVar3;
  
  cntr->next = (PLINE *)0x0;
  if ((*(byte *)&cntr->Flags & 8) == 0) {
    if (parent == (PLINE *)0x0) {
      cntr->next = *holes;
      *holes = cntr;
    }
    else {
      cntr->next = parent->next;
      parent->next = cntr;
    }
  }
  else {
    if (*contours == (POLYAREA *)0x0) {
      pPVar3 = (POLYAREA *)malloc(0xc);
      *contours = pPVar3;
      if (pPVar3 == (POLYAREA *)0x0) goto LAB_080b6908;
      pPVar3->b = pPVar3;
      pPVar3->f = pPVar3;
    }
    else {
      pPVar3 = (POLYAREA *)malloc(0xc);
      if (pPVar3 == (POLYAREA *)0x0) {
LAB_080b6908:
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,2);
      }
      pPVar1 = *contours;
      pPVar2 = pPVar1->b;
      pPVar3->f = pPVar1;
      pPVar3->b = pPVar2;
      pPVar2->f = pPVar3;
      pPVar1->b = pPVar3;
    }
    pPVar3->contours = cntr;
    cntr->next = (PLINE *)0x0;
  }
  return;
}



void __regparm3
Collect1(jmp_buf *e,VNODE *cur,DIRECTION dir,POLYAREA **contours,PLINE **holes,J_Rule *j_rule)

{
  anon_struct_for_Flags *paVar1;
  int iVar2;
  VNODE *node;
  DIRECTION local_28;
  VNODE *local_24;
  PLINE *local_20 [4];
  
  if (dir != FORW) {
    cur = cur->next;
  }
  local_20[0] = (PLINE *)0x0;
  local_28 = dir;
  local_24 = cur;
  do {
    iVar2 = jump(&local_24,&local_28,j_rule);
    if (iVar2 == 0) {
      if (local_20[0] != (PLINE *)0x0) {
        poly_PreContour(local_20[0],1);
        if (2 < local_20[0]->Count) {
          PutContour(e,local_20[0],contours,holes,(PLINE *)0x0);
          return;
        }
        poly_DelContour(local_20);
      }
      return;
    }
    if (local_20[0] == (PLINE *)0x0) {
      local_20[0] = poly_NewContour(local_24->point);
      if (local_20[0] == (PLINE *)0x0) goto LAB_080b6a52;
    }
    else {
      node = poly_CreateNode(local_24->point);
      if (node == (VNODE *)0x0) {
        if (local_20[0] != (PLINE *)0x0) {
          poly_DelContour(local_20);
        }
LAB_080b6a52:
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,2);
      }
      poly_InclVertex((local_20[0]->head).prev,node);
    }
    node = local_24;
    if (local_28 != FORW) {
      node = local_24->prev;
    }
    *(byte *)&node->Flags = *(byte *)&node->Flags | 8;
    if (node->shared != (VNODE *)0x0) {
      paVar1 = &node->shared->Flags;
      *(byte *)paVar1 = *(byte *)paVar1 | 8;
    }
    if (local_28 == FORW) {
      local_24 = local_24->next;
    }
    else {
      local_24 = local_24->prev;
    }
  } while( true );
}



void __regparm3
Collect(jmp_buf *e,PLINE *a,POLYAREA **contours,PLINE **holes,S_Rule *s_rule,J_Rule *j_rule)

{
  int iVar1;
  VNODE *cur;
  DIRECTION local_24;
  VNODE *local_20 [4];
  
  cur = &a->head;
  do {
    iVar1 = (*s_rule)(cur,&local_24);
    if ((iVar1 != 0) && ((*(byte *)&cur->Flags & 8) == 0)) {
      Collect1(e,cur,local_24,contours,holes,j_rule);
    }
    local_20[0] = cur;
    if ((cur->cvc_prev == (CVCList *)0x0) || (iVar1 = jump(local_20,&local_24,j_rule), iVar1 == 0))
    {
      cur = cur->next;
    }
    else {
      Collect1(e,local_20[0],local_24,contours,holes,j_rule);
      cur = cur->next;
    }
  } while (&a->head != cur);
  return;
}



void __regparm3
M_POLYAREA_Collect(jmp_buf *e,POLYAREA *afst,POLYAREA **contours,PLINE **holes,int action,
                  BOOLp maybe)

{
  byte bVar1;
  POLYAREA *pPVar2;
  PLINE *parent;
  PLINE *a;
  PLINE *pPVar3;
  code *local_48;
  code *local_44;
  POLYAREA *local_24;
  PLINE **local_20;
  
  pPVar2 = afst;
  do {
    pPVar2 = pPVar2->f;
    local_24 = afst;
  } while (pPVar2 != afst);
  do {
    if ((maybe == 0) || (pPVar3 = local_24->contours, (*(byte *)&pPVar3->Flags & 7) == 3)) {
      pPVar3 = (PLINE *)0x0;
    }
    local_20 = &local_24->contours;
LAB_080b6b71:
    a = *local_20;
    if (a != (PLINE *)0x0) {
      do {
        parent = (PLINE *)0x0;
        if (pPVar3 != a) {
          parent = pPVar3;
        }
        bVar1 = *(byte *)&a->Flags & 7;
        if (bVar1 == 3) {
          if (action == 1) {
            Collect(e,a,contours,holes,IsectS_Rule,IsectJ_Rule);
          }
          else {
            if (action < 2) {
              if (action == 0) {
                local_44 = UniteJ_Rule;
                local_48 = UniteS_Rule;
                goto LAB_080b6d18;
              }
            }
            else {
              if (action == 2) {
                local_44 = SubJ_Rule;
                local_48 = SubS_Rule;
LAB_080b6d18:
                Collect(e,a,contours,holes,local_48,local_44);
              }
              else {
                if (action == 3) {
                  Collect(e,a,contours,holes,XorS_Rule,XorJ_Rule);
                }
              }
            }
          }
        }
        else {
          if (action == 1) {
            if (bVar1 == 1) {
              *local_20 = a->next;
              a->next = (PLINE *)0x0;
LAB_080b6c97:
              PutContour(e,a,contours,holes,(PLINE *)0x0);
              goto LAB_080b6b71;
            }
          }
          else {
            if (action < 2) {
              if (action != 0) goto LAB_080b6bb2;
            }
            else {
              if (action != 2) {
                if (action != 3) goto LAB_080b6bb2;
                if (bVar1 == 1) {
                  *local_20 = a->next;
                  a->next = (PLINE *)0x0;
                  poly_InvContour(a);
                  goto LAB_080b6c97;
                }
              }
            }
            if (bVar1 == 2) goto LAB_080b6bf4;
          }
        }
LAB_080b6bb2:
        local_20 = &a->next;
        a = *local_20;
        if (a == (PLINE *)0x0) break;
      } while( true );
    }
    local_24 = local_24->f;
    if (afst == local_24) {
      return;
    }
  } while( true );
LAB_080b6bf4:
  *local_20 = a->next;
  a->next = (PLINE *)0x0;
  PutContour(e,a,contours,holes,parent);
  goto LAB_080b6b71;
}



int __regparm3 adjust_tree(rtree_t *tree,seg *s)

{
  VNODE *pVVar1;
  PLINE *pPVar2;
  VNODE *pVVar3;
  BoxType *which;
  int iVar4;
  
  which = (BoxType *)malloc(0x18);
  if (which != (BoxType *)0x0) {
    pVVar1 = s->v;
    pPVar2 = s->p;
    *(VNODE **)&which[1].X1 = pVVar1;
    *(PLINE **)&which[1].Y1 = pPVar2;
    pVVar3 = pVVar1->next;
    iVar4 = pVVar3->point[0];
    if (pVVar1->point[0] == iVar4 || pVVar1->point[0] < iVar4) {
      iVar4 = pVVar1->point[0];
    }
    which->X1 = iVar4;
    iVar4 = pVVar3->point[0];
    if (iVar4 <= pVVar1->point[0]) {
      iVar4 = pVVar1->point[0];
    }
    which->X2 = iVar4 + 1;
    iVar4 = pVVar3->point[1];
    if (pVVar1->point[1] == iVar4 || pVVar1->point[1] < iVar4) {
      iVar4 = pVVar1->point[1];
    }
    which->Y1 = iVar4;
    iVar4 = pVVar3->point[1];
    if (iVar4 <= pVVar1->point[1]) {
      iVar4 = pVVar1->point[1];
    }
    which->Y2 = iVar4 + 1;
    r_insert_entry(tree,which,1);
    which = (BoxType *)malloc(0x18);
    if (which != (BoxType *)0x0) {
      pVVar1 = s->v->next;
      *(PLINE **)&which[1].Y1 = s->p;
      *(VNODE **)&which[1].X1 = pVVar1;
      pVVar3 = pVVar1->next;
      iVar4 = pVVar3->point[0];
      if (pVVar1->point[0] == iVar4 || pVVar1->point[0] < iVar4) {
        iVar4 = pVVar1->point[0];
      }
      which->X1 = iVar4;
      iVar4 = pVVar3->point[0];
      if (iVar4 <= pVVar1->point[0]) {
        iVar4 = pVVar1->point[0];
      }
      which->X2 = iVar4 + 1;
      iVar4 = pVVar3->point[1];
      if (pVVar1->point[1] == iVar4 || pVVar1->point[1] < iVar4) {
        iVar4 = pVVar1->point[1];
      }
      which->Y1 = iVar4;
      iVar4 = pVVar3->point[1];
      if (iVar4 <= pVVar1->point[1]) {
        iVar4 = pVVar1->point[1];
      }
      which->Y2 = iVar4 + 1;
      r_insert_entry(tree,which,1);
      r_delete_entry(tree,(BoxType *)s);
      return 0;
    }
  }
  return 1;
}



int seg_in_seg(BoxType *b,void *cl)

{
  seg *s;
  PLINE *pPVar1;
  int *piVar2;
  uint uVar3;
  VNODE *pVVar4;
  VNODE *dest;
  int iVar5;
  int *po;
  int iVar6;
  int local_44;
  Vector s2;
  Vector s1;
  uint local_20 [4];
  
  local_44 = vect_inters2((int *)b[1].X1 + 6,(int *)(*(int *)b[1].X1 + 0x18),
                          *(int **)((int)cl + 0x14) + 6,(int *)(**(int **)((int)cl + 0x14) + 0x18),
                          s1,s2);
  if (local_44 != 0) {
    if (*(int *)((int)cl + 0x154) != 0) {
                    // WARNING: Subroutine does not return
      __longjmp_chk(*(int *)((int)cl + 0x154),99);
    }
    iVar5 = *(int *)(*(int *)((int)cl + 0x18) + 0x14);
    *(byte *)(iVar5 + 0x44) = *(byte *)(iVar5 + 0x44) & 0xf8 | 3;
    *(byte *)(b[1].Y1 + 0x44) = *(byte *)(b[1].Y1 + 0x44) & 0xf8 | 3;
    do {
      po = s1;
      if (1 < local_44) {
        po = s2;
      }
      dest = (VNODE *)b[1].X1;
      local_20[0] = 0;
      pVVar4 = node_add(*(VNODE **)((int)cl + 0x14),po,(int *)local_20);
      local_20[0] = local_20[0] << 1;
      dest = node_add(dest,po,(int *)local_20);
      uVar3 = local_20[0];
      if ((dest == (VNODE *)0x0) || (pVVar4 == (VNODE *)0x0)) {
        return 1;
      }
      dest->cvc_next = (CVCList *)0xffffffff;
      dest->cvc_prev = (CVCList *)0xffffffff;
      pVVar4->cvc_next = (CVCList *)0xffffffff;
      pVVar4->cvc_prev = (CVCList *)0xffffffff;
      if ((int)local_20[0] < 0) {
        return 1;
      }
      if ((local_20[0] & 2) != 0) {
        s = *(seg **)((int)cl + 0x18);
        po = s1;
        if (1 < local_44) {
          po = s2;
        }
        pPVar1 = s->p;
        iVar5 = *po;
        iVar6 = pPVar1->xmin;
        if (iVar5 <= pPVar1->xmin) {
          iVar6 = iVar5;
        }
        pPVar1->xmin = iVar6;
        iVar6 = pPVar1->xmax;
        if (pPVar1->xmax <= iVar5 + 1) {
          iVar6 = iVar5 + 1;
        }
        pPVar1->xmax = iVar6;
        iVar5 = pPVar1->ymin;
        if (po[1] == iVar5 || po[1] < iVar5) {
          iVar5 = po[1];
        }
        pPVar1->ymin = iVar5;
        iVar5 = pPVar1->ymax;
        if (pPVar1->ymax <= po[1] + 1) {
          iVar5 = po[1] + 1;
        }
        pPVar1->ymax = iVar5;
        iVar5 = adjust_tree(pPVar1->tree,s);
        if (iVar5 != 0) {
          return 1;
        }
      }
      if ((uVar3 & 1) != 0) {
        po = s1;
        if (1 < local_44) {
          po = s2;
        }
        piVar2 = (int *)b[1].Y1;
        iVar5 = *po;
        iVar6 = *piVar2;
        if (iVar5 <= *piVar2) {
          iVar6 = iVar5;
        }
        *piVar2 = iVar6;
        iVar6 = iVar5 + 1;
        if (iVar5 + 1 < piVar2[2]) {
          iVar6 = piVar2[2];
        }
        piVar2[2] = iVar6;
        iVar5 = piVar2[1];
        if (po[1] == iVar5 || po[1] < iVar5) {
          iVar5 = po[1];
        }
        piVar2[1] = iVar5;
        iVar5 = piVar2[3];
        if (piVar2[3] <= po[1] + 1) {
          iVar5 = po[1] + 1;
        }
        piVar2[3] = iVar5;
        iVar5 = adjust_tree(*(rtree_t **)((int)cl + 0x10),(seg *)b);
        if (iVar5 != 0) {
          return 1;
        }
      }
      if ((uVar3 & 3) != 0) {
                    // WARNING: Subroutine does not return
        __longjmp_chk((int)cl + 0x1c,1);
      }
      local_44 = local_44 + -1;
    } while (local_44 != 0);
  }
  return 0;
}



BOOLp __regparm3 M_POLYAREA_label(POLYAREA *afst,POLYAREA *b,BOOLp touch)

{
  CVCList **ppCVar1;
  char cVar2;
  PLINE *inner;
  CVCList *pCVar3;
  VNODE *pVVar4;
  PLINE *poly;
  bool bVar5;
  uint uVar6;
  CVCList *pCVar7;
  int iVar8;
  void *pvVar9;
  VNODE *pVVar10;
  VNODE *pVVar11;
  uint uVar12;
  POLYAREA *data;
  byte bVar13;
  CVCList *pCVar14;
  VNODE *pVVar15;
  POLYAREA *local_48;
  heap_t *local_20 [4];
  
  local_48 = afst;
  do {
    inner = local_48->contours;
joined_r0x080b7100:
    if (inner != (PLINE *)0x0) {
      if ((*(byte *)&inner->Flags & 7) == 3) {
        pVVar10 = &inner->head;
        uVar12 = 0;
        bVar5 = false;
        pVVar11 = pVVar10;
LAB_080b7136:
        do {
          bVar13 = *(byte *)&pVVar11->Flags;
          uVar6 = (uint)bVar13 & 7;
          if ((bVar13 & 7) != 0) goto LAB_080b712b;
          if (pVVar11->cvc_next == (CVCList *)0x0) {
            uVar6 = uVar12;
            if (1 < uVar12 - 1) goto LAB_080b712b;
            *(byte *)&pVVar11->Flags = bVar13 & 0xf8 | (byte)uVar12;
          }
          else {
            pCVar3 = pVVar11->cvc_prev;
            bVar13 = 0;
            pCVar14 = pCVar3->prev;
            cVar2 = pCVar3->poly;
            pCVar7 = pCVar3;
            if (pCVar3 != pCVar14) {
              bVar13 = 0;
              do {
                if (cVar2 != pCVar14->poly) {
                  bVar13 = (pCVar14->side != 'P') + 1;
                }
                pCVar14 = pCVar14->prev;
              } while (pCVar3 != pCVar14);
            }
LAB_080b71c9:
            do {
              if (cVar2 == pCVar7->poly) {
                if (pCVar7->side == 'P') {
                  pVVar15 = pCVar7->parent->prev;
                }
                else {
                  pVVar15 = pCVar7->parent;
                }
                if (1 < (byte)((*(byte *)&pVVar15->Flags & 7) - 3)) {
                  *(byte *)&pVVar15->Flags = *(byte *)&pVVar15->Flags & 0xf8 | bVar13;
                  ppCVar1 = &pCVar7->prev;
                  pCVar7 = *ppCVar1;
                  if (pCVar3 == *ppCVar1) break;
                  goto LAB_080b71c9;
                }
              }
              else {
                if (pCVar7->side == 'P') {
                  pVVar15 = pVVar11->prev;
                  pVVar4 = pCVar7->parent->prev;
                  if ((pVVar4->point[0] == pVVar15->point[0]) &&
                     (pVVar4->point[1] == pVVar15->point[1])) {
                    *(byte *)&pVVar15->Flags = *(byte *)&pVVar15->Flags & 0xf8 | 3;
                    pVVar11->prev->shared = pCVar7->parent->prev;
                    bVar13 = 1;
                  }
                  else {
                    if ((pVVar4->point[0] == pVVar11->next->point[0]) &&
                       (pVVar4->point[1] == pVVar11->next->point[1])) {
                      bVar13 = 1;
                      *(byte *)&pVVar11->Flags = *(byte *)&pVVar11->Flags & 0xf8 | 4;
                      pVVar11->shared = pCVar7->parent->prev;
                    }
                    else {
                      bVar13 = 1;
                    }
                  }
                }
                else {
                  pVVar15 = pCVar7->parent->next;
                  if ((pVVar15->point[0] == pVVar11->next->point[0]) &&
                     (pVVar15->point[1] == pVVar11->next->point[1])) {
                    bVar13 = 2;
                    *(byte *)&pVVar11->Flags = *(byte *)&pVVar11->Flags & 0xf8 | 3;
                    pVVar11->shared = pCVar7->parent;
                  }
                  else {
                    pVVar4 = pVVar11->prev;
                    if ((pVVar15->point[0] == pVVar4->point[0]) &&
                       (pVVar15->point[1] == pVVar4->point[1])) {
                      *(byte *)&pVVar4->Flags = *(byte *)&pVVar4->Flags & 0xf8 | 4;
                      pVVar11->prev->shared = pCVar7->parent;
                      bVar13 = 2;
                    }
                    else {
                      bVar13 = 2;
                    }
                  }
                }
              }
              ppCVar1 = &pCVar7->prev;
              pCVar7 = *ppCVar1;
            } while (pCVar3 != *ppCVar1);
            uVar12 = (uint)*(byte *)&pVVar11->Flags & 7;
            if ((((*(byte *)&pVVar11->Flags & 7) == 0) ||
                ((*(byte *)&pVVar11->prev->Flags & 7) == 0)) || (1 < (byte)((char)uVar12 - 1U))) {
              uVar12 = 0;
            }
          }
          pVVar11 = pVVar11->next;
          bVar5 = true;
        } while (pVVar10 != pVVar11);
        goto LAB_080b7232;
      }
      local_20[0] = heap_create();
      data = b;
      do {
        poly = data->contours;
        if (((poly->xmin <= inner->xmin) && (poly->ymin <= inner->ymin)) &&
           ((inner->xmax <= poly->xmax && (inner->ymax <= poly->ymax)))) {
          heap_insert(local_20[0],(cost_t)poly->area,data);
        }
        if (touch != 0) goto LAB_080b73eb;
        data = data->f;
      } while (b != data);
      iVar8 = heap_is_empty(local_20[0]);
      while (iVar8 == 0) {
        pvVar9 = heap_remove_smallest(local_20[0]);
        iVar8 = poly_ContourInContour(*(PLINE **)((int)pvVar9 + 8),inner);
        if (iVar8 != 0) {
          poly = *(PLINE **)(*(int *)((int)pvVar9 + 8) + 0x10);
          goto joined_r0x080b7422;
        }
LAB_080b73eb:
        iVar8 = heap_is_empty(local_20[0]);
      }
      heap_destroy(local_20);
LAB_080b744a:
      if (touch == 0) {
        *(byte *)&inner->Flags = *(byte *)&inner->Flags & 0xf8 | 2;
      }
      goto LAB_080b7461;
    }
    if ((touch != 0) || (local_48 = local_48->f, local_48 == afst)) {
      return 0;
    }
  } while( true );
LAB_080b712b:
  uVar12 = uVar6;
  pVVar11 = pVVar11->next;
  if (pVVar10 == pVVar11) {
LAB_080b7232:
    if (bVar5) {
      bVar5 = false;
      goto LAB_080b7136;
    }
    goto LAB_080b7461;
  }
  goto LAB_080b7136;
joined_r0x080b7422:
  if (poly == (PLINE *)0x0) goto LAB_080b7490;
  iVar8 = poly_ContourInContour(poly,inner);
  if (iVar8 != 0) {
    heap_destroy(local_20);
    goto LAB_080b744a;
  }
  poly = poly->next;
  goto joined_r0x080b7422;
LAB_080b7490:
  heap_destroy(local_20);
  if (touch != 0) {
    return 1;
  }
  *(byte *)&inner->Flags = *(byte *)&inner->Flags & 0xf8 | 1;
LAB_080b7461:
  inner = inner->next;
  goto joined_r0x080b7100;
}



BOOLp Touching(POLYAREA *a,POLYAREA *b)

{
  int iVar1;
  uint uVar2;
  BOOLp BVar3;
  jmp_buf e;
  
  iVar1 = _setjmp((__jmp_buf_tag *)e);
  if (iVar1 == 0) {
    M_POLYAREA_intersect((jmp_buf *)e,a,b,0);
    BVar3 = M_POLYAREA_label(a,b,1);
    uVar2 = 1;
    if (BVar3 == 0) {
      BVar3 = M_POLYAREA_label(b,a,1);
      return (uint)(BVar3 != 0);
    }
  }
  else {
    uVar2 = (uint)(iVar1 == 99);
  }
  return uVar2;
}



void __regparm3 InsertHoles(jmp_buf *e,POLYAREA *dest,PLINE **src)

{
  PLINE *pPVar1;
  int iVar2;
  POLYAREA *pPVar3;
  PLINE *poly;
  rtree_t *local_28;
  heap_t *local_24;
  PLINE *local_20 [4];
  
  if (*src != (PLINE *)0x0) {
    if (dest == (POLYAREA *)0x0) {
LAB_080b76db:
                    // WARNING: Subroutine does not return
      __longjmp_chk(e,3);
    }
    local_28 = r_create_tree((BoxType **)0x0,0,0);
    pPVar3 = dest;
    do {
      r_insert_entry(local_28,(BoxType *)pPVar3->contours,0);
      pPVar3 = pPVar3->f;
    } while (pPVar3 != dest);
    local_20[0] = *src;
    while (local_20[0] != (PLINE *)0x0) {
      *src = local_20[0]->next;
      local_24 = heap_create();
      r_search(local_28,(BoxType *)local_20[0],(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               (anon_subr_int_BoxType_ptr_void_ptr *)&heap_it,local_24);
      iVar2 = heap_is_empty(local_24);
      if (iVar2 != 0) {
        poly_DelContour(local_20);
        goto LAB_080b76db;
      }
      poly = (PLINE *)heap_remove_smallest(local_24);
      iVar2 = heap_is_empty(local_24);
      if (iVar2 == 0) {
        while (iVar2 = poly_ContourInContour(poly,local_20[0]), iVar2 == 0) {
          iVar2 = heap_is_empty(local_24);
          if (iVar2 != 0) {
            heap_destroy(&local_24);
            goto LAB_080b76ab;
          }
          poly = (PLINE *)heap_remove_smallest(local_24);
        }
      }
      heap_destroy(&local_24);
      if (poly == (PLINE *)0x0) {
LAB_080b76ab:
        local_20[0]->next = (PLINE *)0x0;
        poly_DelContour(local_20);
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,3);
      }
      pPVar1 = poly->next;
      poly->next = local_20[0];
      local_20[0]->next = pPVar1;
      local_20[0] = *src;
    }
    r_destroy_tree(&local_28);
  }
  return;
}



int poly_AndSubtract_free(POLYAREA *ai,POLYAREA *bi,POLYAREA **aandb,POLYAREA **aminusb)

{
  PLINE *pPVar1;
  POLYAREA **ppPVar2;
  int iVar3;
  VNODE *pVVar4;
  POLYAREA *pPVar5;
  POLYAREA *pPVar6;
  jmp_buf e;
  PLINE *local_2c;
  PLINE *local_28;
  POLYAREA *local_24;
  POLYAREA *local_20 [4];
  
  local_2c = (PLINE *)0x0;
  local_20[0] = ai;
  local_24 = bi;
  *aandb = (POLYAREA *)0x0;
  *aminusb = (POLYAREA *)0x0;
  iVar3 = _setjmp((__jmp_buf_tag *)e);
  if (iVar3 == 0) {
    M_POLYAREA_intersect((jmp_buf *)e,local_20[0],local_24,1);
    M_POLYAREA_label(local_20[0],local_24,0);
    M_POLYAREA_label(local_24,local_20[0],0);
    M_POLYAREA_Collect((jmp_buf *)e,local_20[0],aandb,&local_2c,1,0);
    InsertHoles((jmp_buf *)e,*aandb,&local_2c);
    local_28 = local_2c;
    pPVar5 = local_20[0];
    if (local_2c != (PLINE *)0x0) {
      do {
        local_28 = local_2c;
        local_2c = local_2c->next;
        poly_DelContour(&local_28);
        local_28 = local_2c;
        pPVar5 = local_20[0];
      } while (local_2c != (PLINE *)0x0);
    }
    do {
      pPVar1 = pPVar5->contours;
      while (pPVar1 != (PLINE *)0x0) {
        pVVar4 = &pPVar1->head;
        do {
          *(byte *)&pVVar4->Flags = *(byte *)&pVVar4->Flags & 0xf7;
          pVVar4 = pVVar4->next;
        } while (&pPVar1->head != pVVar4);
        pPVar1 = pPVar1->next;
      }
      ppPVar2 = &pPVar5->f;
      pPVar6 = local_24;
      pPVar5 = *ppPVar2;
    } while (local_20[0] != *ppPVar2);
    do {
      pPVar1 = pPVar6->contours;
      while (pPVar1 != (PLINE *)0x0) {
        pVVar4 = &pPVar1->head;
        do {
          *(byte *)&pVVar4->Flags = *(byte *)&pVVar4->Flags & 0xf7;
          pVVar4 = pVVar4->next;
        } while (&pPVar1->head != pVVar4);
        pPVar1 = pPVar1->next;
      }
      ppPVar2 = &pPVar6->f;
      pPVar6 = *ppPVar2;
    } while (local_24 != *ppPVar2);
    local_2c = (PLINE *)0x0;
    M_POLYAREA_Collect((jmp_buf *)e,local_20[0],aminusb,&local_2c,2,0);
    InsertHoles((jmp_buf *)e,*aminusb,&local_2c);
    poly_Free(local_20);
    poly_Free(&local_24);
  }
  if (local_2c != (PLINE *)0x0) {
    do {
      local_28 = local_2c;
      local_2c = local_2c->next;
      poly_DelContour(&local_28);
    } while (local_2c != (PLINE *)0x0);
  }
  if (iVar3 != 0) {
    local_28 = local_2c;
    poly_Free(aandb);
    poly_Free(aminusb);
  }
  return iVar3;
}



int poly_Boolean_free(POLYAREA *ai,POLYAREA *bi,POLYAREA **res,int action)

{
  PLINE **ppPVar1;
  POLYAREA *pPVar2;
  byte bVar3;
  int iVar4;
  uint maybe;
  PLINE *c;
  PLINE **ppPVar5;
  POLYAREA *pPVar6;
  jmp_buf e;
  PLINE *local_2c;
  PLINE *local_28;
  POLYAREA *local_24;
  POLYAREA *local_20 [4];
  
  local_2c = (PLINE *)0x0;
  local_20[0] = ai;
  local_24 = bi;
  *res = (POLYAREA *)0x0;
  if (ai == (POLYAREA *)0x0) {
    if (action < 3) {
      if (0 < action) {
        if (bi == (POLYAREA *)0x0) {
          return 0;
        }
        poly_Free(&local_24);
        return 0;
      }
      if (action == 0) {
LAB_080b7b85:
        *res = bi;
        return 0;
      }
    }
    else {
      if (action == 3) goto LAB_080b7b85;
    }
  }
  if (bi == (POLYAREA *)0x0) {
    if (action == 1) {
      if (ai == (POLYAREA *)0x0) {
        return 0;
      }
      poly_Free(local_20);
      return 0;
    }
    if (action < 2) {
      if (action == 0) goto LAB_080b799e;
    }
    else {
      if (action < 4) {
LAB_080b799e:
        *res = ai;
        return 0;
      }
    }
  }
  iVar4 = _setjmp((__jmp_buf_tag *)e);
  if (iVar4 != 0) {
LAB_080b792b:
    if (local_2c != (PLINE *)0x0) {
      do {
        local_28 = local_2c;
        local_2c = local_2c->next;
        poly_DelContour(&local_28);
      } while (local_2c != (PLINE *)0x0);
    }
    if (iVar4 != 0) {
      local_28 = local_2c;
      poly_Free(res);
      return iVar4;
    }
    return 0;
  }
  M_POLYAREA_intersect((jmp_buf *)e,local_20[0],local_24,1);
  M_POLYAREA_label(local_20[0],local_24,0);
  M_POLYAREA_label(local_24,local_20[0],0);
  if ((local_24 == local_24->f) && (local_24->contours->next == (PLINE *)0x0)) {
    maybe = (uint)((*(byte *)&local_24->contours->Flags & 7) != 3);
  }
  else {
    maybe = 0;
  }
  M_POLYAREA_Collect((jmp_buf *)e,local_20[0],res,&local_2c,action,maybe);
  poly_Free(local_20);
  pPVar2 = local_24;
  pPVar6 = local_24;
LAB_080b7a28:
  ppPVar5 = &pPVar6->contours;
LAB_080b7a2b:
  c = *ppPVar5;
  do {
    if (c == (PLINE *)0x0) {
      pPVar6 = pPVar6->f;
      if (pPVar2 != pPVar6) goto LAB_080b7a28;
      poly_Free(&local_24);
      InsertHoles((jmp_buf *)e,*res,&local_2c);
      goto LAB_080b792b;
    }
    ppPVar1 = &c->next;
    bVar3 = *(byte *)&c->Flags & 7;
    if (bVar3 != 3) {
      if (bVar3 == 1) {
        if (action != 1) {
          if ((action < 1) || (3 < action)) goto LAB_080b7a4d;
          poly_InvContour(c);
          c = *ppPVar5;
        }
        *ppPVar5 = c->next;
        *(byte *)&c->Flags = *(byte *)&c->Flags & 0xf8;
        c->next = (PLINE *)0x0;
        PutContour((jmp_buf *)e,c,res,&local_2c,(PLINE *)0x0);
        goto LAB_080b7a2b;
      }
      if ((bVar3 == 2) && ((action == 0 || (action == 3)))) break;
    }
LAB_080b7a4d:
    c = *ppPVar1;
    ppPVar5 = ppPVar1;
  } while( true );
  *ppPVar5 = c->next;
  *(byte *)&c->Flags = *(byte *)&c->Flags & 0xf8;
  c->next = (PLINE *)0x0;
  PutContour((jmp_buf *)e,c,res,&local_2c,(PLINE *)0x0);
  goto LAB_080b7a2b;
}



int poly_Boolean(POLYAREA *a_org,POLYAREA *b_org,POLYAREA **res,int action)

{
  BOOLp BVar1;
  int iVar2;
  POLYAREA *local_14;
  POLYAREA *local_10 [3];
  
  local_10[0] = (POLYAREA *)0x0;
  local_14 = (POLYAREA *)0x0;
  BVar1 = poly_M_Copy0(local_10,a_org);
  if (BVar1 != 0) {
    BVar1 = poly_M_Copy0(&local_14,b_org);
    if (BVar1 != 0) {
      iVar2 = poly_Boolean_free(local_10[0],local_14,res,action);
      return iVar2;
    }
  }
  return 2;
}



// WARNING: Type propagation algorithm not settling

int find_pair_line_callback(BoxType *b,void *cl)

{
  Extra *pEVar1;
  int iVar2;
  
  if (*(BoxType **)cl == b) {
    return 0;
  }
  iVar2 = *(int *)((int)cl + 4);
  if ((b[2].Y2 <= iVar2 + 2) && (iVar2 + -2 <= b[2].Y2)) {
    if ((b[3].X1 <= *(int *)((int)cl + 8) + 2) && (*(int *)((int)cl + 8) + -2 <= b[3].X1))
    goto LAB_080b7cb2;
  }
  if (iVar2 + 2 < b[4].X1) {
    return 0;
  }
  if (b[4].X1 < iVar2 + -2) {
    return 0;
  }
  if (*(int *)((int)cl + 8) + 2 < b[4].Y1) {
    return 0;
  }
  if (b[4].Y1 < *(int *)((int)cl + 8) + -2) {
    return 0;
  }
LAB_080b7cb2:
  pEVar1 = *(Extra **)((int)cl + 0x10);
  if (*(Extra **)&pEVar1->start == (Extra *)0x0) {
    if (PCB->SilkActive == '\0') {
      iVar2 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      iVar2 = &PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
    }
    *(Extra **)&pEVar1->start =
         (Extra *)((int)lines + ((int)((int)b - *(int *)(iVar2 + 0x24)) >> 3) * -0x2e8ba2e4);
  }
  else {
    *(Extra **)&pEVar1->start = &multi_next;
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

int find_pair_arc_callback(BoxType *b,void *cl)

{
  Extra *pEVar1;
  int iVar2;
  Extra *pEVar3;
  int iVar4;
  
  if (PCB->SilkActive == '\0') {
    iVar4 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar4 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  if (*(BoxType **)cl == b) {
    return 0;
  }
  iVar2 = *(int *)((int)cl + 4);
  pEVar1 = (Extra *)((int)arcs + ((int)((int)b - *(int *)(iVar4 + 0x30)) >> 2) * -0xf0f0f0c);
  iVar4 = (pEVar1->start).x;
  if ((iVar4 <= iVar2 + 2) && (iVar2 + -2 <= iVar4)) {
    iVar4 = (pEVar1->start).y;
    if ((iVar4 <= *(int *)((int)cl + 8) + 2) && (*(int *)((int)cl + 8) + -2 <= iVar4))
    goto LAB_080b7dfa;
  }
  iVar4 = (pEVar1->end).x;
  if (iVar2 + 2 < iVar4) {
    return 0;
  }
  if (iVar4 < iVar2 + -2) {
    return 0;
  }
  iVar4 = (pEVar1->end).y;
  if (*(int *)((int)cl + 8) + 2 < iVar4) {
    return 0;
  }
  if (iVar4 < *(int *)((int)cl + 8) + -2) {
    return 0;
  }
LAB_080b7dfa:
  pEVar3 = &multi_next;
  if (*(Extra **)&(*(Extra **)((int)cl + 0x10))->start == (Extra *)0x0) {
    pEVar3 = pEVar1;
  }
  *(Extra **)&(*(Extra **)((int)cl + 0x10))->start = pEVar3;
  return 0;
}



void __regparm3 adjust_pointers_1(Extra *old,Extra *new,int num,Extra *l,int n)

{
  Extra *pEVar1;
  Extra *pEVar2;
  int iVar3;
  
  new = (Extra *)((int)new - (int)old);
  pEVar1 = old + num;
  if (0 < n) {
    iVar3 = 0;
    do {
      pEVar2 = (Extra *)(l->start).waiting_for;
      if (((pEVar2 != (Extra *)0x0) && (old < pEVar2)) && (pEVar2 < pEVar1 + 1)) {
        (l->start).waiting_for = (End *)((int)pEVar2 + (int)new);
      }
      pEVar2 = (Extra *)(l->end).waiting_for;
      if (((pEVar2 != (Extra *)0x0) && (old < pEVar2)) && (pEVar2 < pEVar1 + 1)) {
        (l->end).waiting_for = (End *)((int)pEVar2 + (int)new);
      }
      pEVar2 = (l->start).next;
      if ((old <= pEVar2) && (pEVar2 < pEVar1)) {
        (l->start).next = (Extra *)(&(pEVar2->start).next + ((int)new >> 2));
      }
      pEVar2 = (l->end).next;
      if ((old <= pEVar2) && (pEVar2 < pEVar1)) {
        (l->end).next = (Extra *)(&(pEVar2->start).next + ((int)new >> 2));
      }
      iVar3 = iVar3 + 1;
      l = l + 1;
    } while (iVar3 != n);
  }
  return;
}



void __regparm3 adjust_pointers(Extra *old,Extra *new,int num)

{
  adjust_pointers_1(old,new,num,lines,nlines);
  adjust_pointers_1(old,new,num,arcs,narcs);
  return;
}



void __regparm3 find_pairs_1(void *me,Extra **e,int x,int y)

{
  int iVar1;
  FindPairCallbackStruct fpcs;
  BoxType b;
  
  if (*e == (Extra *)0x0) {
    if (PCB->SilkActive == '\0') {
      iVar1 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      iVar1 = &PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
    }
    b.X1 = x + -10;
    b.X2 = x + 10;
    b.Y1 = y + -10;
    fpcs.y = y;
    b.Y2 = y + 10;
    fpcs.me = me;
    fpcs.x = x;
    fpcs.extra_ptr = e;
    r_search(*(rtree_t **)(iVar1 + 0x34),&b,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             find_pair_line_callback,&fpcs);
    if (PCB->SilkActive == '\0') {
      iVar1 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      iVar1 = &PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
    }
    r_search(*(rtree_t **)(iVar1 + 0x40),&b,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             find_pair_arc_callback,&fpcs);
  }
  return;
}



int __regparm3 find_pair(int Px,int Py)

{
  int iVar1;
  void *cl;
  BoxType spot;
  
  multi = 0;
  arc_exact = 0;
  line_exact = 0;
  the_line = (LineTypePtr_conflict *)0x0;
  the_arc = (ArcTypePtr *)0x0;
  if (PCB->SilkActive == '\0') {
    cl = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    cl = (void *)(&PCB->Data->field_0x4c +
                 ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  spot.X1 = Px + -1;
  spot.Y1 = Py + -1;
  spot.X2 = Px + 1;
  spot.Y2 = Py + 1;
  x = Px;
  y = Py;
  r_search(*(rtree_t **)((int)cl + 0x34),&spot,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
           line_callback,cl);
  if (PCB->SilkActive == '\0') {
    cl = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    cl = (void *)(&PCB->Data->field_0x4c +
                 ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  r_search(*(rtree_t **)((int)cl + 0x40),&spot,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
           arc_callback,cl);
  if (((the_line == (LineTypePtr_conflict *)0x0) || (the_arc == (ArcTypePtr *)0x0)) ||
     (iVar1 = 1, multi != 0)) {
    iVar1 = 0;
    x = Px;
    y = Py;
  }
  return iVar1;
}



void __regparm3 fix_arc_extra(ArcTypePtr *a,Extra *e)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double local_2c;
  double local_24 [2];
  
  iVar5 = a->StartAngle;
  iVar1 = a->X;
  iVar2 = a->Width;
  sincos(((double)iVar5 * 3.14159265) / 180.00000000,local_24,&local_2c);
  iVar6 = a->Delta;
  (e->start).x = (int)ROUND((double)iVar1 - ((double)iVar2 * local_2c + 0.50000000));
  iVar3 = a->Y;
  iVar4 = a->Height;
  (e->start).y = (int)ROUND(local_24[0] * (double)iVar4 + 0.50000000 + (double)iVar3);
  sincos(((double)(iVar5 + iVar6) * 3.14159265) / 180.00000000,local_24,&local_2c);
  (e->end).x = (int)ROUND((double)iVar1 - ((double)iVar2 * local_2c + 0.50000000));
  (e->end).y = (int)ROUND((double)iVar3 + (double)iVar4 * local_24[0] + 0.50000000);
  return;
}



double __regparm3 dist(int x1,int y1,int x2,int y2)

{
  return SQRT((double)(y1 - y2) * (double)(y1 - y2) + (double)(x1 - x2) * (double)(x1 - x2));
}



double __regparm3 dist_lsp(int x1,int y1,int x2,int y2,int px,int py)

{
  double dVar1;
  
  if ((float10)(py - y1) * (float10)(y2 - y1) + (float10)(px - x1) * (float10)(x2 - x1) < (float10)0
     ) {
    dVar1 = dist(x1,y1,px,py);
    return dVar1;
  }
  if ((float10)0 <=
      (float10)(py - y2) * (float10)(y1 - y2) + (float10)(px - x2) * (float10)(x1 - x2)) {
    dVar1 = dist(x1,y1,x2,y2);
    return ABS(((double)x2 - (double)x1) * ((double)y1 - (double)py) -
               ((double)x1 - (double)px) * ((double)y2 - (double)y1)) / dVar1;
  }
  dVar1 = dist(x2,y2,px,py);
  return dVar1;
}



int __regparm3 check_point_in_pin(PinTypePtr *pin,int x,int y,End *e)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  
  iVar3 = (pin->Thickness + 1) / 2;
  if ((*(byte *)((int)&(pin->Flags).f + 1) & 1) == 0) {
    dVar4 = dist(pin->X,pin->Y,x,y);
    if (dVar4 <= (double)iVar3) {
      iVar2 = pin->X;
      goto LAB_080b84da;
    }
  }
  else {
    iVar2 = pin->X;
    if ((((iVar2 - iVar3 <= x) && (x <= iVar3 + iVar2)) && (pin->Y - iVar3 <= y)) &&
       (y <= iVar3 + pin->Y)) {
LAB_080b84da:
      bVar1 = *(byte *)&e->field_0x8;
      *(byte *)&e->field_0x8 = bVar1 | 1;
      if ((x == iVar2) && (pin->Y == y)) {
        *(byte *)&e->field_0x8 = bVar1 | 3;
      }
      *(PinTypePtr **)&e->pin = pin;
      return 1;
    }
  }
  return 0;
}



int find_pair_pinarc_callback(BoxType *b,void *cl)

{
  int iVar1;
  Extra *e;
  
  if (PCB->SilkActive == '\0') {
    iVar1 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar1 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  e = (Extra *)((int)arcs + ((int)((int)b - *(int *)(iVar1 + 0x30)) >> 2) * -0xf0f0f0c);
  check_point_in_pin((PinTypePtr *)cl,(e->start).x,(e->start).y,(End *)e);
  check_point_in_pin((PinTypePtr *)cl,(e->end).x,(e->end).y,&e->end);
  return 0;
}



int find_pair_pinline_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  Extra *pEVar3;
  Extra *e;
  double dVar4;
  
  if (PCB->SilkActive == '\0') {
    iVar1 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar1 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  e = (Extra *)((int)lines + ((int)((int)b - *(int *)(iVar1 + 0x24)) >> 3) * -0x2e8ba2e4);
  iVar1 = check_point_in_pin((PinTypePtr *)cl,b[2].Y2,b[3].X1,(End *)e);
  iVar2 = check_point_in_pin((PinTypePtr *)cl,b[4].X1,b[4].Y1,&e->end);
  if (iVar2 + iVar1 == 0) {
    dVar4 = dist_lsp(b[2].Y2,b[3].X1,b[4].X1,b[4].Y1,*(int *)((int)cl + 0x34),
                     *(int *)((int)cl + 0x38));
    if (dVar4 <= (double)(*(int *)((int)cl + 0x24) / 2)) {
      pEVar3 = (e->start).next;
      if (pEVar3 != (Extra *)0x0) {
        if (e == (pEVar3->start).next) {
          (pEVar3->start).next = &multi_next;
          pEVar3 = (e->start).next;
        }
        if (e == (pEVar3->end).next) {
          (pEVar3->end).next = &multi_next;
        }
      }
      pEVar3 = (e->end).next;
      (e->start).next = (Extra *)0x817ccc0;
      if (pEVar3 != (Extra *)0x0) {
        if (e == (pEVar3->start).next) {
          (pEVar3->start).next = &multi_next;
        }
        if (e == (pEVar3->end).next) {
          (pEVar3->end).next = &multi_next;
        }
      }
      (e->end).next = (Extra *)0x817ccc0;
      return 0;
    }
  }
  return 0;
}



double __regparm3 dist_lp(int x1,int y1,int x2,int y2,int px,int py)

{
  double dVar1;
  
  dVar1 = dist(x1,y1,x2,y2);
  return ABS(((double)y1 - (double)py) * ((double)x2 - (double)x1) -
             ((double)x1 - (double)px) * ((double)y2 - (double)y1)) / dVar1;
}



int line_callback(BoxType *b,void *cl)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  dVar2 = dist(b[2].Y2,b[3].X1,x,y);
  dVar3 = dist(b[4].X1,b[4].Y1,x,y);
  if ((dVar2 < 2.00000000) || (dVar3 < 2.00000000)) {
    if (line_exact == 0) {
      line_exact = 1;
      the_line = (LineTypePtr_conflict *)0x0;
    }
LAB_080b881c:
    dVar1 = 2.00000000;
    if (dVar2 < 2.00000000) goto LAB_080b87e4;
  }
  else {
    if (line_exact != 0) goto LAB_080b881c;
    dVar1 = (double)(b[2].Y1 / 2);
    if (dVar2 < dVar1) goto LAB_080b87e4;
  }
  if (dVar1 <= dVar3) {
    return 1;
  }
LAB_080b87e4:
  if (the_line != (LineTypePtr_conflict *)0x0) {
    multi = 1;
  }
  the_line = (LineTypePtr_conflict *)b;
  return 1;
}



int __regparm3 arc_endpoint_is(ArcTypePtr *a,int angle,int x,int y)

{
  uint uVar1;
  int y1;
  int local_38;
  double local_2c;
  double local_24 [2];
  
  local_38 = a->X;
  y1 = a->Y;
  if (angle == (angle / 0x5a) * 0x5a) {
    uVar1 = angle / 0x5a & 3;
    if (uVar1 == 2) {
      local_38 = local_38 + a->Width;
    }
    else {
      if (uVar1 == 3) {
        y1 = y1 - a->Height;
      }
      else {
        if (uVar1 == 1) {
          y1 = y1 + a->Height;
        }
        else {
          local_38 = local_38 - a->Width;
        }
      }
    }
  }
  else {
    sincos(((double)angle * 3.14159265) / 180.00000000,local_24,&local_2c);
    local_38 = (int)ROUND((double)local_38 - local_2c * (double)a->Width);
    y1 = (int)ROUND((double)a->Width * local_24[0] + (double)y1);
  }
  arc_dist = dist(local_38,y1,x,y);
  if (arc_exact == 0) {
    return (uint)(arc_dist < (double)(a->Thickness / 2));
  }
  return (uint)(arc_dist < 2.00000000);
}



int arc_callback(BoxType *b,void *cl)

{
  int iVar1;
  
  iVar1 = arc_endpoint_is((ArcTypePtr *)b,b[3].Y2,x,y);
  if ((iVar1 == 0) && (iVar1 = arc_endpoint_is((ArcTypePtr *)b,b[4].X1 + b[3].Y2,x,y), iVar1 == 0))
  {
    return 1;
  }
  if (arc_dist < 2.00000000) {
    if (arc_exact == 0) {
      arc_exact = 1;
      the_arc = (ArcTypePtr *)b;
      return 1;
    }
  }
  else {
    if (arc_exact != 0) {
      return 1;
    }
  }
  if (the_arc != (ArcTypePtr *)0x0) {
    multi = 1;
  }
  the_arc = (ArcTypePtr *)b;
  return 1;
}



int __regparm3 within(int x1,int y1,int x2,int y2,int r)

{
  double dVar1;
  
  dVar1 = dist(x1,y1,x2,y2);
  return (uint)(dVar1 <= (double)(r / 2));
}



void __regparm3 unlink_extras(Extra *e)

{
  Extra *pEVar1;
  Extra *local_10;
  
  pEVar1 = (e->start).next;
  if (pEVar1 == (Extra *)0x0) {
LAB_080b8aab:
    local_10 = (e->end).next;
  }
  else {
    if ((pEVar1->start).next != e) {
      local_10 = pEVar1;
      if ((pEVar1->end).next != e) goto LAB_080b8ae2;
      (pEVar1->end).next = (e->end).next;
      goto LAB_080b8aab;
    }
    local_10 = (e->end).next;
    (pEVar1->start).next = local_10;
  }
  if (local_10 != (Extra *)0x0) {
    if ((local_10->start).next == e) {
      (local_10->start).next = (e->start).next;
    }
    else {
      if ((local_10->end).next != e) {
LAB_080b8ae2:
        __fprintf_chk(stderr,1,0x814d698,local_10);
                    // WARNING: Subroutine does not return
        abort();
      }
      (local_10->end).next = (e->start).next;
    }
  }
  (e->end).next = (Extra *)0x0;
  (e->start).next = (Extra *)0x0;
  return;
}



void __regparm3 mark_arc_for_deletion(ArcTypePtr *a)

{
  byte *pbVar1;
  Extra *e;
  int iVar2;
  
  if (PCB->SilkActive == '\0') {
    iVar2 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar2 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  e = (Extra *)((int)arcs + ((int)((int)a - *(int *)(iVar2 + 0x30)) >> 2) * -0xf0f0f0c);
  pbVar1 = (byte *)&e->field_0x30;
  *pbVar1 = *pbVar1 | 2;
  unlink_extras(e);
  return;
}



void __regparm3 mark_line_for_deletion(LineTypePtr_conflict *l)

{
  Extra *e;
  int iVar1;
  
  if (PCB->SilkActive == '\0') {
    iVar1 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar1 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  e = (Extra *)((int)lines + ((int)((int)l - *(int *)(iVar1 + 0x24)) >> 3) * -0x2e8ba2e4);
  if ((*(byte *)&e->field_0x30 & 2) == 0) {
    *(byte *)&e->field_0x30 = *(byte *)&e->field_0x30 | 2;
    unlink_extras(e);
    return;
  }
  __fprintf_chk(stderr,1,"double delete?\n");
                    // WARNING: Subroutine does not return
  abort();
}



int __regparm3 check_point_in_pad(PadTypePtr *pad,int x,int y,End *e)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  int local_4c;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  double dVar8;
  LocationType local_60;
  LocationType local_5c;
  LocationType local_58;
  BDimension local_54;
  int local_50;
  
  local_54 = pad->Thickness;
  local_58 = (pad->Point2).Y;
  local_5c = (pad->Point2).X;
  local_60 = (pad->Point1).Y;
  local_50 = x;
  local_4c = y;
  __printf_chk(1,"pad %d,%d - %d,%d t %d  vs  %d,%d\n",(pad->Point1).X,local_60,local_5c,local_58,
               local_54,x,y);
  iVar7 = (pad->Thickness + 1) / 2;
  if ((*(byte *)((int)&(pad->Flags).f + 1) & 1) != 0) {
    iVar4 = (pad->Point2).X;
    iVar5 = (pad->Point1).X;
    iVar3 = iVar5 - iVar7;
    iVar6 = iVar4 - iVar7;
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    if (x < iVar3) {
LAB_080b8ca4:
      __printf_chk(1," - inside_p = %d\n",0,local_60,local_5c,local_58,local_54,local_50,local_4c);
      return 0;
    }
    iVar5 = iVar7 + iVar5;
    iVar4 = iVar7 + iVar4;
    if (iVar5 < iVar4) {
      iVar5 = iVar4;
    }
    if (iVar5 < x) goto LAB_080b8ca4;
    iVar5 = (pad->Point1).Y;
    iVar4 = (pad->Point2).Y;
    iVar3 = iVar5 - iVar7;
    iVar6 = iVar4 - iVar7;
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    if (y < iVar3) goto LAB_080b8ca4;
    iVar5 = iVar7 + iVar5;
    iVar7 = iVar7 + iVar4;
    if (iVar5 < iVar7) {
      iVar5 = iVar7;
    }
    __printf_chk(1," - inside_p = %d\n",(uint)(y <= iVar5),local_60,local_5c,local_58,local_54,
                 local_50,local_4c);
    if (y > iVar5) {
      return 0;
    }
    goto LAB_080b8d22;
  }
  local_50 = (pad->Point1).X;
  local_4c = (pad->Point2).X;
  if (local_50 == local_4c) {
    if ((x < local_50 - iVar7) || (iVar7 + local_50 < x)) goto LAB_080b8de8;
    iVar5 = (pad->Point2).Y;
    local_4c = (pad->Point1).Y;
    iVar4 = iVar5;
    if (local_4c <= iVar5) {
      iVar4 = local_4c;
    }
    if (iVar4 <= y) {
      if (iVar5 <= local_4c) {
        iVar5 = local_4c;
      }
joined_r0x080b8e98:
      if (y <= iVar5) goto LAB_080b8d22;
    }
  }
  else {
    iVar5 = local_50;
    if (local_4c <= local_50) {
      iVar5 = local_4c;
    }
    if (iVar5 <= x) {
      if (local_4c < local_50) {
        local_4c = local_50;
      }
      if (x <= local_4c) {
        local_4c = (pad->Point1).Y;
        if (local_4c - iVar7 <= y) {
          iVar5 = iVar7 + local_4c;
          goto joined_r0x080b8e98;
        }
        goto LAB_080b8deb;
      }
    }
LAB_080b8de8:
    local_4c = (pad->Point1).Y;
  }
LAB_080b8deb:
  dVar8 = dist(local_50,local_4c,x,y);
  if (((double)iVar7 < dVar8) &&
     (dVar8 = dist((pad->Point2).X,(pad->Point2).Y,x,y), (double)iVar7 < dVar8)) {
    return 0;
  }
LAB_080b8d22:
  bVar1 = *(byte *)&e->field_0x8;
  bVar2 = bVar1 | 1;
  *(byte *)&e->field_0x8 = bVar2;
  if (((pad->Point1).X == x) && ((pad->Point1).Y == y)) {
    bVar2 = bVar1 | 3;
    *(byte *)&e->field_0x8 = bVar2;
  }
  if (((pad->Point2).X == x) && ((pad->Point2).Y == y)) {
    bVar2 = bVar2 | 2;
    *(byte *)&e->field_0x8 = bVar2;
  }
  *(byte *)&e->field_0x8 = bVar2 | 4;
  *(PadTypePtr **)&e->pin = pad;
  return 1;
}



int find_pair_padarc_callback(BoxType *b,void *cl)

{
  Extra *e;
  int iVar1;
  
  if (PCB->SilkActive == '\0') {
    iVar1 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar1 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  if (*(char *)((int)cl + 0x14) < '\0') {
    if (current_is_solder == 0) {
      return 0;
    }
  }
  else {
    if (current_is_component == 0) {
      return 0;
    }
  }
  e = (Extra *)((int)arcs + ((int)((int)b - *(int *)(iVar1 + 0x30)) >> 2) * -0xf0f0f0c);
  check_point_in_pad((PadTypePtr *)cl,(e->start).x,(e->start).y,(End *)e);
  check_point_in_pad((PadTypePtr *)cl,(e->end).x,(e->end).y,&e->end);
  return 0;
}



void __regparm3 print_extra(Extra *e,Extra *prev)

{
  byte bVar1;
  Extra *pEVar2;
  undefined *puVar3;
  int iVar4;
  undefined *local_38;
  undefined *local_40;
  undefined *puVar5;
  DataTypePtr *pDVar6;
  DataTypePtr *pDVar7;
  undefined *local_44;
  undefined *puVar8;
  Extra *local_3c;
  undefined4 local_34;
  
  pEVar2 = (e->start).next;
  if (pEVar2 == last_pextra) {
    local_3c = (e->end).next;
    __printf_chk(1,&DAT_0814d6d6,e,pEVar2,local_3c);
  }
  else {
    local_3c = (e->end).next;
    if (last_pextra == local_3c) {
      __printf_chk(1,&DAT_0814d784,e,pEVar2,last_pextra);
      local_3c = last_pextra;
    }
    else {
      __printf_chk(1,"%10p %10p %10p :",e,pEVar2,local_3c);
    }
  }
  local_44 = &DAT_08156000;
  puVar8 = &DAT_0815490f;
  last_pextra = e;
  __printf_chk(1," %c%c",(-(uint)((*(byte *)&e->field_0x30 & 2) == 0) & 0xffffffc9) + 100,
               (-(uint)((*(byte *)&e->field_0x30 & 1) == 0) & 0xffffffc7) + 0x66,local_3c);
  bVar1 = *(byte *)&(e->start).field_0x8;
  local_38 = &DAT_08156000;
  if ((bVar1 & 8) != 0) {
    local_38 = &DAT_081486bf;
  }
  local_40 = &DAT_08156000;
  if ((bVar1 & 4) != 0) {
    local_40 = &DAT_0815490f;
  }
  puVar5 = &DAT_0814d6f6;
  if ((bVar1 & 2) == 0) {
    puVar5 = &DAT_08156000;
  }
  puVar3 = &DAT_0814d6f8;
  if ((bVar1 & 1) == 0) {
    puVar3 = &DAT_08156000;
  }
  __printf_chk(1," s:%s%s%s%s",puVar3,puVar5,local_40,local_38);
  bVar1 = *(byte *)&(e->end).field_0x8;
  local_40 = &DAT_0814d6f6;
  local_38 = &DAT_081486bf;
  if ((bVar1 & 8) == 0) {
    local_38 = &DAT_08156000;
  }
  if ((bVar1 & 4) == 0) {
    puVar8 = &DAT_08156000;
  }
  if ((bVar1 & 2) == 0) {
    local_40 = &DAT_08156000;
  }
  if ((bVar1 & 1) != 0) {
    local_44 = &DAT_0814d6f8;
  }
  __printf_chk(1," e:%s%s%s%s ",local_44,local_40,puVar8,local_38);
  iVar4 = (int)((int)e - (int)lines) >> 2;
  if ((uint)(iVar4 * -0x3b13b13b) < (uint)nlines) {
    if (PCB->SilkActive == '\0') {
      pDVar6 = PCB->Data;
      pDVar7 = (DataTypePtr *)(LayerStack[0] * 0x5c);
    }
    else {
      pDVar7 = PCB->Data;
      pDVar6 = (DataTypePtr *)(((uint)(Settings.ShowSolderSide == '\0') + pDVar7->LayerN) * 0x5c);
    }
    iVar4 = iVar4 * -0x4ec4ec48 + *(int *)((int)&pDVar6->ViaN + &pDVar7->field_0x70);
    local_34 = *(undefined4 *)(iVar4 + 0x44);
    __printf_chk(1," %4d L %d,%d-%d,%d",
                 (iVar4 - *(int *)((int)pDVar6 + (int)pDVar7 + 0x70) >> 3) * -0x45d1745d,
                 *(undefined4 *)(iVar4 + 0x2c),*(undefined4 *)(iVar4 + 0x30),
                 *(undefined4 *)(iVar4 + 0x40),local_34);
    local_38 = (undefined *)0x81493b2;
    local_44 = (undefined *)0x81493b2;
    if ((*(byte *)&(e->end).field_0x8 & 4) != 0) {
      local_44 = &DAT_08154a83;
    }
    if ((*(byte *)&(e->start).field_0x8 & 4) != 0) {
      local_38 = &DAT_08154a83;
    }
    __printf_chk(1,"  %s %p %s %p\n",local_38,(e->start).pin,local_44,(e->end).pin,local_34);
    return;
  }
  iVar4 = (int)((int)e - (int)arcs) >> 2;
  if ((uint)narcs <= (uint)(iVar4 * -0x3b13b13b)) {
    if (e == &multi_next) {
      __printf_chk(1,"-- Multi-next\n",local_44,local_40,puVar8,local_38);
    }
    else {
      __printf_chk(1,"-- Unknown extra: %p\n",e,local_40,puVar8,local_38);
    }
    return;
  }
  if (PCB->SilkActive == '\0') {
    pDVar6 = PCB->Data;
    pDVar7 = (DataTypePtr *)(LayerStack[0] * 0x5c);
  }
  else {
    pDVar7 = PCB->Data;
    pDVar6 = (DataTypePtr *)(((uint)(Settings.ShowSolderSide == '\0') + pDVar7->LayerN) * 0x5c);
  }
  iVar4 = iVar4 * 0x4ec4ec54 + *(int *)((int)&pDVar6->ViaN + &pDVar7->field_0x7c);
  __printf_chk(1," %4d A %d,%d-%d,%d",
               (iVar4 - *(int *)((int)pDVar6 + (int)pDVar7 + 0x7c) >> 2) * -0xf0f0f0f,(e->start).x,
               (e->start).y,(e->end).x,(e->end).y);
  __printf_chk(1," at %d,%d ang %ld,%ld\n",*(undefined4 *)(iVar4 + 0x34),
               *(undefined4 *)(iVar4 + 0x38),*(undefined4 *)(iVar4 + 0x3c),
               *(undefined4 *)(iVar4 + 0x40));
  return;
}



void __regparm3 validate_pair(Extra *e,End *end)

{
  Extra *pEVar1;
  
  pEVar1 = end->next;
  if (((pEVar1 != (Extra *)0x0) && ((pEVar1->start).next != e)) && ((pEVar1->end).next != e)) {
    __fprintf_chk(stderr,1,"no backlink!\n");
    print_extra(e,(Extra *)0x0);
    print_extra(end->next,(Extra *)0x0);
                    // WARNING: Subroutine does not return
    abort();
  }
  return;
}



void __regparm3 reverse_line(LineTypePtr_conflict *line)

{
  DataTypePtr *pDVar1;
  int iVar2;
  Extra *pEVar3;
  undefined4 uVar4;
  End *pEVar5;
  int iVar6;
  void *Ptr1;
  Extra *pEVar7;
  LocationType LVar8;
  LocationType local_80;
  void *local_54;
  LocationType local_50;
  End etmp;
  
  if (PCB->SilkActive == '\0') {
    LVar8 = (line->Point1).Y;
    iVar2 = *(int *)(&PCB->Data->field_0x70 + LayerStack[0] * 0x5c);
    local_54 = (void *)(line->Point2).X;
    local_80 = (line->Point2).Y;
    local_50 = (line->Point1).X;
    Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    pDVar1 = PCB->Data;
    LVar8 = (line->Point1).Y;
    iVar6 = ((uint)(Settings.ShowSolderSide == '\0') + pDVar1->LayerN) * 0x5c;
    iVar2 = *(int *)(&pDVar1->field_0x70 + iVar6);
    local_80 = (line->Point2).Y;
    local_50 = (line->Point1).X;
    Ptr1 = (void *)(&pDVar1->field_0x4c + iVar6);
    local_54 = (void *)(line->Point2).X;
  }
  pEVar7 = (Extra *)((int)lines + ((int)((int)line - iVar2) >> 3) * -0x2e8ba2e4);
  MoveObject(0x1000,Ptr1,line,&line->Point1,(int)local_54 - local_50,local_80 - LVar8);
  if (PCB->SilkActive == '\0') {
    local_54 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    local_54 = (void *)(&PCB->Data->field_0x4c +
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  MoveObject(0x1000,local_54,line,&line->Point2,local_50 - (line->Point2).X,LVar8 - (line->Point2).Y
            );
  pEVar3 = (pEVar7->start).next;
  Ptr1 = (pEVar7->start).pin;
  uVar4 = *(undefined4 *)&(pEVar7->start).field_0x8;
  iVar2 = (pEVar7->start).x;
  iVar6 = (pEVar7->start).y;
  pEVar5 = (pEVar7->start).waiting_for;
  (pEVar7->start).next = (pEVar7->end).next;
  (pEVar7->start).pin = (pEVar7->end).pin;
  *(undefined4 *)&(pEVar7->start).field_0x8 = *(undefined4 *)&(pEVar7->end).field_0x8;
  (pEVar7->start).x = (pEVar7->end).x;
  (pEVar7->start).y = (pEVar7->end).y;
  (pEVar7->start).waiting_for = (pEVar7->end).waiting_for;
  (pEVar7->end).next = pEVar3;
  (pEVar7->end).pin = Ptr1;
  *(undefined4 *)&(pEVar7->end).field_0x8 = uVar4;
  (pEVar7->end).x = iVar2;
  (pEVar7->end).y = iVar6;
  (pEVar7->end).waiting_for = pEVar5;
  return;
}



void __regparm3 reverse_arc(ArcTypePtr *arc)

{
  Extra *pEVar1;
  Extra *pEVar2;
  void *pvVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  End *pEVar7;
  DataTypePtr *pDVar8;
  DataTypePtr *pDVar9;
  End etmp;
  
  if (PCB->SilkActive == '\0') {
    pDVar9 = PCB->Data;
    pDVar8 = (DataTypePtr *)(LayerStack[0] * 0x5c);
  }
  else {
    pDVar8 = PCB->Data;
    pDVar9 = (DataTypePtr *)(((uint)(Settings.ShowSolderSide == '\0') + pDVar8->LayerN) * 0x5c);
  }
  pEVar1 = (Extra *)((int)arcs +
                    ((int)((int)arc - *(int *)((int)&pDVar9->ViaN + &pDVar8->field_0x7c)) >> 2) *
                    -0xf0f0f0c);
  ChangeArcAngles((LayerTypePtr)((int)&pDVar9->ViaN + &pDVar8->field_0x4c),arc,
                  arc->Delta + arc->StartAngle,-arc->Delta);
  pEVar2 = (pEVar1->start).next;
  pvVar3 = (pEVar1->start).pin;
  uVar4 = *(undefined4 *)&(pEVar1->start).field_0x8;
  iVar5 = (pEVar1->start).x;
  iVar6 = (pEVar1->start).y;
  pEVar7 = (pEVar1->start).waiting_for;
  (pEVar1->start).next = (pEVar1->end).next;
  (pEVar1->start).pin = (pEVar1->end).pin;
  *(undefined4 *)&(pEVar1->start).field_0x8 = *(undefined4 *)&(pEVar1->end).field_0x8;
  (pEVar1->start).x = (pEVar1->end).x;
  (pEVar1->start).y = (pEVar1->end).y;
  (pEVar1->start).waiting_for = (pEVar1->end).waiting_for;
  (pEVar1->end).next = pEVar2;
  (pEVar1->end).pin = pvVar3;
  *(undefined4 *)&(pEVar1->end).field_0x8 = uVar4;
  (pEVar1->end).x = iVar5;
  (pEVar1->end).y = iVar6;
  (pEVar1->end).waiting_for = pEVar7;
  return;
}



// WARNING: Removing unreachable block (ram,0x080b98ee)

int __regparm3 gp_point_force(int x,int y,int t,End *e,int esa,int eda,int force,char *name)

{
  double dVar1;
  double dVar2;
  char "gp_point_force" [15];
  LocationType LVar3;
  float10 fVar4;
  double __x;
  double dVar5;
  double dVar6;
  double dVar7;
  LocationType local_34;
  LocationType local_30;
  
  if (start_arc == (ArcTypePtr *)0x0) {
    LVar3 = 0;
    local_34 = (start_line->Point1).X;
    local_30 = (start_line->Point1).Y;
  }
  else {
    local_34 = start_arc->X;
    LVar3 = start_arc->Width;
    local_30 = start_arc->Y;
  }
  dVar6 = (double)(t + thickness);
  __x = dist(local_34,local_30,x,y);
  if (((double)LVar3 - dVar6 <= __x) && ((LVar3 != 0 || (dVar6 <= __x)))) {
    dVar5 = atan2((double)(y - local_30),(double)(x - local_34));
    __x = ((double)LVar3 * sa_sign - dVar6) / __x;
    if ((__x <= 1.00000000) && (-1.00000000 <= __x)) {
      __x = asin(__x);
      dVar5 = dVar5 + __x * se_sign;
      if (eda != 0) {
        dVar7 = ((double)(0xb4 - esa) * 3.14159265) / 180.00000000;
        __x = ((double)-eda * 3.14159265) / 180.00000000;
        if (__x < 0.00000000) {
          dVar7 = dVar7 + __x;
          __x = -__x;
        }
        dVar1 = se_sign * 3.14159265 * -0.50000000 + dVar5;
        while (dVar2 = dVar7 + __x, dVar2 < dVar1) {
          dVar7 = dVar7 + 6.28318531;
        }
        if (dVar1 < dVar7) {
          do {
            dVar7 = dVar7 - 6.28318531;
          } while (dVar1 < dVar7);
          dVar2 = dVar7 + __x;
        }
        if (dVar2 < dVar1) {
          return 0;
        }
      }
      dVar5 = dVar5 - start_angle;
      while (3.14159265 < dVar5) {
        dVar5 = dVar5 - 6.28318531;
      }
      while (dVar5 < -3.14159265) {
        dVar5 = dVar5 + 6.28318531;
      }
      if ((force != 0) || (-0.00700000 <= dVar5 * se_sign)) {
        if (dVar5 * se_sign == se_sign * best_angle) {
          __x = dist((start_line->Point1).X,(start_line->Point1).Y,fx,fy);
          dVar7 = dist((start_line->Point1).X,(start_line->Point1).Y,x,y);
          if (dVar7 <= __x) {
            return 1;
          }
        }
        else {
          if (se_sign * best_angle <= dVar5 * se_sign) {
            return 1;
          }
        }
        fp = 0;
        fr = (int)ROUND(dVar6);
        if (e != (End *)0x0) {
          fp = (uint)(*(byte *)&e->field_0x8 >> 3) & 1;
        }
        best_angle = dVar5;
        fx = x;
        fy = y;
        fp_end = e;
        fa = dVar5;
        return 1;
      }
      dVar6 = dist_lp((start_line->Point1).X,(start_line->Point1).Y,(start_line->Point2).X,
                      (start_line->Point2).Y,x,y);
      fVar4 = (float10)((int)ROUND(dVar6 - (double)thickness) + -1);
      if (fVar4 < (float10)t) {
        gp_point_force(x,y,(int)ROUND(fVar4),e,esa,eda,1,"gp_point_force");
        return 0;
      }
    }
  }
  return 0;
}



int __regparm3 gp_point_2(int x,int y,int t,End *e,int esa,int eda,char *func)

{
  int x2;
  int x1;
  int y1;
  double dVar1;
  int y2;
  double dVar2;
  
  if ((x == sa_x) && (y == sa_y)) {
    return 0;
  }
  y2 = (end_line->Point2).Y;
  x2 = (end_line->Point2).X;
  x1 = (start_line->Point1).X;
  y1 = (start_line->Point1).Y;
  if (-1 < t) {
    dVar2 = (double)(y - y1);
    dVar1 = (double)(x - x1);
    if (((double)(x2 - x1) * dVar2 - (double)(y2 - y1) * dVar1) * se_sign < 0.00000000) {
      if (((double)((start_line->Point2).X - x1) * dVar2 -
          (double)((start_line->Point2).Y - y1) * dVar1) * se_sign < 0.00000000) {
        return 0;
      }
      x1 = (end_line->Point1).X;
      y1 = (end_line->Point1).Y;
      if (((double)(y - y1) * (double)(x2 - x1) - (double)(x - x1) * (double)(y2 - y1)) * se_sign <
          0.00000000) {
        return 0;
      }
    }
    else {
      if (((dVar2 * (double)(y2 - y1) + dVar1 * (double)(x2 - x1) <= 0.00000000) ||
          ((double)(y - y2) * (double)(y1 - y2) + (double)(x - x2) * (double)(x1 - x2) <= 0.00000000
          )) || (dVar2 = dist_lp(x1,y1,x2,y2,x,y), (double)(t + thickness) < dVar2)) {
        return 0;
      }
    }
  }
  y2 = gp_point_force(x,y,t,e,esa,eda,0,func);
  return y2;
}



int gp_pad_cb(BoxType *b,void *cb)

{
  int iVar1;
  char "gp_pad_cb" [10];
  int iVar2;
  int iVar3;
  int t;
  int iVar4;
  
  if ((b != (BoxType *)start_pinpad) && (b != (BoxType *)end_pinpad)) {
    if (*(char *)&b[1].Y1 < '\0') {
      if (current_is_solder == 0) {
        return 0;
      }
    }
    else {
      if (current_is_component == 0) {
        return 0;
      }
    }
    t = (b[2].Y1 + 1) / 2;
    if ((b[1].Y1 & 0x900U) == 0) {
      gp_point_2(b[2].Y2,b[3].X1,t,(End *)0x0,0,0,"gp_pad_cb");
      gp_point_2(b[4].X1,b[4].Y1,t,(End *)0x0,0,0,"gp_pad_cb");
    }
    else {
      iVar2 = b[2].Y2;
      iVar1 = b[4].X1;
      if (iVar2 == iVar1) {
        iVar1 = b[3].X1;
        iVar3 = b[4].Y1;
        iVar4 = iVar3;
        if (iVar1 <= iVar3) {
          iVar4 = iVar1;
        }
        if (iVar3 <= iVar1) {
          iVar3 = iVar1;
        }
        gp_point_2(iVar2 - t,iVar4 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(b[2].Y2 - t,t + iVar3,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(b[2].Y2 + t,iVar4 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(b[2].Y2 + t,t + iVar3,0,(End *)0x0,0,0,"gp_pad_cb");
      }
      else {
        iVar3 = iVar2;
        if (iVar1 <= iVar2) {
          iVar3 = iVar1;
        }
        if (iVar2 <= iVar1) {
          iVar2 = iVar1;
        }
        gp_point_2(iVar3 - t,b[3].X1 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(t + iVar2,b[3].X1 - t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(iVar3 - t,b[3].X1 + t,0,(End *)0x0,0,0,"gp_pad_cb");
        gp_point_2(t + iVar2,b[3].X1 + t,0,(End *)0x0,0,0,"gp_pad_cb");
      }
    }
  }
  return 0;
}



int gp_pin_cb(BoxType *b,void *cb)

{
  char "gp_pin_cb" [10];
  int t;
  
  if ((b != (BoxType *)start_pinpad) && (b != (BoxType *)end_pinpad)) {
    t = (b[2].Y1 + 1) / 2;
    if ((b[1].Y1 & 0x900U) != 0) {
      gp_point_2(b[3].Y1 - t,b[3].X2 - t,0,(End *)0x0,0,0,"gp_pin_cb");
      gp_point_2(b[3].Y1 - t,b[3].X2 + t,0,(End *)0x0,0,0,"gp_pin_cb");
      gp_point_2(b[3].Y1 + t,b[3].X2 + t,0,(End *)0x0,0,0,"gp_pin_cb");
      gp_point_2(b[3].Y1 + t,b[3].X2 - t,0,(End *)0x0,0,0,"gp_pin_cb");
      return 0;
    }
    gp_point_2(b[3].Y1,b[3].X2,t,(End *)0x0,0,0,"gp_pin_cb");
  }
  return 0;
}



int gp_poly_cb(BoxType *b,void *cb)

{
  char "gp_poly_cb" [11];
  int iVar1;
  int *piVar2;
  uint uVar3;
  
  if (b[2].Y1 != 0) {
    uVar3 = 0;
    do {
      iVar1 = uVar3 * 0x14;
      uVar3 = uVar3 + 1;
      piVar2 = (int *)(iVar1 + b[3].X2);
      gp_point_2(*piVar2,piVar2[1],0,(End *)0x0,0,0,"gp_poly_cb");
    } while (uVar3 <= (uint)b[2].Y1 && b[2].Y1 != uVar3);
  }
  return 0;
}



int gp_text_cb(BoxType *b,void *cb)

{
  char "gp_text_cb" [11];
  
  gp_point_2(b->X1,b->Y1,0,(End *)0x0,0,0,"gp_text_cb");
  gp_point_2(b->X1,b->Y2,0,(End *)0x0,0,0,"gp_text_cb");
  gp_point_2(b->X2,b->Y2,0,(End *)0x0,0,0,"gp_text_cb");
  gp_point_2(b->X2,b->Y1,0,(End *)0x0,0,0,"gp_text_cb");
  return 0;
}



int gp_arc_cb(BoxType *b,void *cb)

{
  Extra *pEVar1;
  char "gp_arc_cb" [10];
  int iVar2;
  
  if (PCB->SilkActive == '\0') {
    iVar2 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar2 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  if ((((((ArcTypePtr *)b != start_arc) && ((ArcTypePtr *)b != end_arc)) &&
       (pEVar1 = (Extra *)((int)arcs + ((int)((int)b - *(int *)(iVar2 + 0x30)) >> 2) * -0xf0f0f0c),
       (*(byte *)&pEVar1->field_0x30 & 2) == 0)) &&
      (((gp_point_2(b[3].Y1,b[3].X2,b[2].Y1 / 2 + b[2].Y2,(End *)0x0,b[3].Y2,b[4].X1,"gp_arc_cb"),
        start_arc == (ArcTypePtr *)0x0 || (b[3].Y1 != start_arc->X)) || (b[3].X2 != start_arc->Y))))
     && ((((end_arc == (ArcTypePtr *)0x0 || (b[3].Y1 == end_arc->X)) || (b[3].X2 == end_arc->Y)) &&
         (((pEVar1->start).next == (Extra *)0x0 && ((pEVar1->end).next == (Extra *)0x0)))))) {
    gp_point_2((pEVar1->start).x,(pEVar1->start).y,b[2].Y1 / 2,(End *)0x0,0,0,"gp_arc_cb");
    gp_point_2((pEVar1->end).x,(pEVar1->end).y,b[2].Y1 / 2,(End *)0x0,0,0,"gp_arc_cb");
  }
  return 0;
}



int gp_line_cb(BoxType *b,void *cb)

{
  Extra *e;
  Extra *pEVar1;
  char "gp_line_cb" [11];
  int iVar2;
  
  if (PCB->SilkActive == '\0') {
    iVar2 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar2 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  if ((((LineTypePtr_conflict *)b != start_line) && ((LineTypePtr_conflict *)b != end_line)) &&
     (e = (Extra *)((int)lines + ((int)((int)b - *(int *)(iVar2 + 0x24)) >> 3) * -0x2e8ba2e4),
     (*(byte *)&e->field_0x30 & 2) == 0)) {
    pEVar1 = (e->start).next;
    if ((pEVar1 == (Extra *)0x0) ||
       ((uint)narcs <= (uint)(((int)((int)pEVar1 - (int)arcs) >> 2) * -0x3b13b13b))) {
      gp_point_2(b[2].Y2,b[3].X1,b[2].Y1 / 2,(End *)e,0,0,"gp_line_cb");
    }
    pEVar1 = (e->end).next;
    if ((pEVar1 == (Extra *)0x0) ||
       ((uint)narcs <= (uint)(((int)((int)pEVar1 - (int)arcs) >> 2) * -0x3b13b13b))) {
      gp_point_2(b[4].X1,b[4].Y1,b[2].Y1 / 2,&e->end,0,0,"gp_line_cb");
    }
  }
  return 0;
}



void __regparm3 maybe_pull_1(LineTypePtr_conflict *line)

{
  byte *pbVar1;
  char cVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  Extra *old;
  LineTypePtr_conflict *pLVar7;
  double dVar8;
  LocationType LVar9;
  DataTypePtr *pDVar10;
  LineTypePtr Ptr2;
  void *Ptr1;
  LayerTypePtr Layer;
  Extra *pEVar11;
  Extra *new;
  Extra *new_00;
  int width;
  int iVar12;
  int Y1;
  int iVar13;
  int new_da;
  int iVar14;
  int X1;
  DataTypePtr *pDVar15;
  byte bVar16;
  double dVar17;
  void *local_50;
  int local_4c;
  ArcTypePtr *local_48;
  double local_3c;
  double local_34;
  BoxType box;
  
  bVar16 = 0;
  if (PCB->SilkActive == '\0') {
    new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    new_da = &PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  start_extra = (Extra *)((int)lines +
                         ((int)((int)line - *(int *)(new_da + 0x24)) >> 3) * -0x2e8ba2e4);
  end_extra = (start_extra->end).next;
  if (PCB->SilkActive == '\0') {
    new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    new_da = &PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  end_line = (LineTypePtr_conflict *)
             (((int)((int)end_extra - (int)lines) >> 2) * -0x4ec4ec48 + *(int *)(new_da + 0x24));
  start_line = line;
  if ((*(byte *)&end_extra->field_0x30 & 2) != 0) {
    pbVar1 = (byte *)&(start_extra->end).field_0x8;
    *pbVar1 = *pbVar1 & 0xf7;
    return;
  }
  if (start_extra == (end_extra->end).next) {
    reverse_line(end_line);
  }
  sarc_extra = (start_extra->start).next;
  if ((sarc_extra == (Extra *)0x0) ||
     ((uint)narcs <= (uint)(((int)((int)sarc_extra - (int)arcs) >> 2) * -0x3b13b13b))) {
    start_arc = (ArcTypePtr *)0x0;
    sarc_extra = (Extra *)0x0;
  }
  else {
    if (PCB->SilkActive == '\0') {
      new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      new_da = &PCB->Data->field_0x4c +
               ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
    }
    start_arc = (ArcTypePtr *)
                (((int)((int)sarc_extra - (int)arcs) >> 2) * 0x4ec4ec54 + *(int *)(new_da + 0x30));
    if ((sarc_extra->start).next == start_extra) {
      reverse_arc(start_arc);
    }
  }
  earc_extra = (end_extra->end).next;
  if ((earc_extra == (Extra *)0x0) ||
     ((uint)narcs <= (uint)(((int)((int)earc_extra - (int)arcs) >> 2) * -0x3b13b13b))) {
    end_arc = (ArcTypePtr *)0x0;
    earc_extra = (Extra *)0x0;
  }
  else {
    if (PCB->SilkActive == '\0') {
      new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      new_da = &PCB->Data->field_0x4c +
               ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
    }
    end_arc = (ArcTypePtr *)
              (((int)((int)earc_extra - (int)arcs) >> 2) * 0x4ec4ec54 + *(int *)(new_da + 0x30));
    if ((earc_extra->start).next == end_extra) {
      reverse_arc(end_arc);
    }
  }
  if ((*(byte *)&(start_extra->end).field_0x8 & 8) == 0) {
    return;
  }
  if (start_line->Thickness != end_line->Thickness) {
    return;
  }
  thickness = (start_line->Thickness + 1) / 2 + PCB->Bloat;
  width = (start_line->Point1).X - thickness;
  iVar12 = (start_line->Point1).X + thickness;
  iVar14 = (start_line->Point1).Y - thickness;
  Y1 = (start_line->Point1).Y + thickness;
  X1 = (start_line->Point2).Y;
  new_da = (start_line->Point2).X;
  iVar13 = new_da - thickness;
  if (iVar13 <= width) {
    width = iVar13;
  }
  new_da = thickness + new_da;
  if (new_da < iVar12) {
    new_da = iVar12;
  }
  iVar12 = X1 - thickness;
  if (iVar14 < iVar12) {
    iVar12 = iVar14;
  }
  X1 = X1 + thickness;
  if (Y1 <= X1) {
    Y1 = X1;
  }
  iVar13 = (end_line->Point2).Y;
  X1 = (end_line->Point2).X;
  iVar14 = X1 - thickness;
  if (width <= iVar14) {
    iVar14 = width;
  }
  X1 = thickness + X1;
  if (X1 <= new_da) {
    X1 = new_da;
  }
  new_da = iVar13 - thickness;
  if (iVar12 <= new_da) {
    new_da = iVar12;
  }
  iVar13 = thickness + iVar13;
  if (Y1 < iVar13) {
    Y1 = iVar13;
  }
  box.X1 = iVar14;
  box.Y1 = new_da;
  box.X2 = X1;
  box.Y2 = Y1;
  if (start_arc != (ArcTypePtr *)0x0) {
    iVar13 = start_arc->Thickness / 2;
    width = (sarc_extra->start).y;
    iVar12 = (sarc_extra->start).x;
    box.X1 = iVar12 - iVar13;
    if (iVar14 <= box.X1) {
      box.X1 = iVar14;
    }
    box.X2 = iVar13 + iVar12;
    if (box.X2 <= X1) {
      box.X2 = X1;
    }
    box.Y1 = width - iVar13;
    if (new_da <= box.Y1) {
      box.Y1 = new_da;
    }
    box.Y2 = iVar13 + width;
    if (box.Y2 <= Y1) {
      box.Y2 = Y1;
    }
  }
  LVar9 = box.Y2;
  if (end_arc != (ArcTypePtr *)0x0) {
    Y1 = end_arc->Thickness / 2;
    new_da = (earc_extra->start).y;
    X1 = (earc_extra->start).x;
    width = X1 - Y1;
    if (width <= box.X1) {
      box.X1 = width;
    }
    X1 = X1 + Y1;
    if (box.X2 <= X1) {
      box.X2 = X1;
    }
    X1 = new_da - Y1;
    if (X1 <= box.Y1) {
      box.Y1 = X1;
    }
    LVar9 = Y1 + new_da;
    if (LVar9 < box.Y2) {
      LVar9 = box.Y2;
    }
  }
  box.Y2 = LVar9;
  new_da = (start_line->Point1).X;
  X1 = (start_line->Point1).Y;
  se_sign = 1.00000000;
  if ((float10)((end_line->Point2).Y - X1) * (float10)((start_line->Point2).X - new_da) -
      (float10)((end_line->Point2).X - new_da) * (float10)((start_line->Point2).Y - X1) < (float10)0
     ) {
    se_sign = -1.00000000;
  }
  best_angle = se_sign * 3.14159265;
  if (start_arc == (ArcTypePtr *)0x0) {
    sa_sign = 0.00000000;
  }
  else {
    sa_sign = 1.00000000;
    if ((float10)-start_arc->Delta < (float10)0) {
      sa_sign = -1.00000000;
    }
    sa_sign = sa_sign * se_sign;
  }
  if (end_arc == (ArcTypePtr *)0x0) {
    ea_sign = 0.00000000;
  }
  else {
    ea_sign = 1.00000000;
    if ((float10)-end_arc->Delta < (float10)0) {
      ea_sign = -1.00000000;
    }
    ea_sign = -se_sign * ea_sign;
  }
  start_angle = atan2((double)((start_line->Point2).Y - (start_line->Point1).Y),
                      (double)((start_line->Point2).X - (start_line->Point1).X));
  if (start_arc == (ArcTypePtr *)0x0) {
    sa_x = (start_line->Point1).X;
    sa_y = (start_line->Point1).Y;
    sa_r = 0;
  }
  else {
    sa_x = start_arc->X;
    sa_y = start_arc->Y;
    if ((double)start_arc->Delta * se_sign < 0.00000000) {
      sa_r = start_arc->Width;
    }
    else {
      sa_r = -start_arc->Width;
    }
  }
  if (end_arc == (ArcTypePtr *)0x0) {
    ea_r = 0;
LAB_080bbe6a:
    gp_point_force((end_line->Point2).X,(end_line->Point2).Y,-thickness,(End *)0x0,0,0,1,"end arc");
    LVar9 = (end_line->Point2).X;
    local_48 = (ArcTypePtr *)(end_line->Point2).Y;
  }
  else {
    if (0.00000000 <= ea_sign) {
      ea_r = -end_arc->Width;
    }
    else {
      ea_r = end_arc->Width;
    }
    if (end_arc == (ArcTypePtr *)0x0) goto LAB_080bbe6a;
    gp_point_force(end_arc->X,end_arc->Y,-thickness - ea_r,(End *)0x0,0,0,1,"end arc");
    LVar9 = end_arc->X;
    local_48 = (ArcTypePtr *)end_arc->Y;
  }
  fy = (int)local_48;
  fx = LVar9;
  if (LVar9 < 0) {
    __fprintf_chk(stderr,1,"end line corrupt? f is %d,%d\n",LVar9,local_48);
    print_extra(end_extra,(Extra *)0x0);
    if (earc_extra != (Extra *)0x0) {
      print_extra(earc_extra,(Extra *)0x0);
    }
                    // WARNING: Subroutine does not return
    abort();
  }
  end_dist = dist((end_line->Point1).X,(end_line->Point1).Y,(end_line->Point2).X,
                  (end_line->Point2).Y);
  fp = 0;
  start_pinpad = (start_extra->start).pin;
  end_pinpad = (start_extra->end).pin;
  if (PCB->SilkActive == '\0') {
    new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    new_da = &PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  r_search(*(rtree_t **)(new_da + 0x34),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_line_cb,
           (void *)0x0);
  if (PCB->SilkActive == '\0') {
    new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    new_da = &PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  r_search(*(rtree_t **)(new_da + 0x40),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_arc_cb,
           (void *)0x0);
  if (PCB->SilkActive == '\0') {
    new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    new_da = &PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  r_search(*(rtree_t **)(new_da + 0x38),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_text_cb,
           (void *)0x0);
  if (PCB->SilkActive == '\0') {
    new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    new_da = &PCB->Data->field_0x4c +
             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  r_search(*(rtree_t **)(new_da + 0x3c),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_poly_cb,
           (void *)0x0);
  r_search(PCB->Data->pin_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_pin_cb,(void *)0x0)
  ;
  r_search(PCB->Data->via_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_pin_cb,(void *)0x0)
  ;
  r_search(PCB->Data->pad_tree,&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,gp_pad_cb,(void *)0x0)
  ;
  dVar8 = fa;
  dVar17 = start_angle;
  if (fp != 0) {
    (start_extra->end).waiting_for = fp_end;
    return;
  }
  pbVar1 = (byte *)&(start_extra->end).field_0x8;
  *pbVar1 = *pbVar1 & 0xf7;
  if ((fx == LVar9) && ((ArcTypePtr *)fy == local_48)) {
    if (start_arc == (ArcTypePtr *)0x0) goto LAB_080bae20;
    if (((end_arc != (ArcTypePtr *)0x0) && (start_arc->X == end_arc->X)) &&
       (start_arc->Y == end_arc->Y)) {
      new_da = end_arc->StartAngle - start_arc->StartAngle;
      if (start_arc->Delta < 1) {
        while (new_da < -0x168) {
          new_da = new_da + 0x168;
        }
        while (0 < new_da) {
          new_da = new_da + -0x168;
        }
      }
      else {
        while (0x168 < new_da) {
          new_da = new_da + -0x168;
        }
        while (new_da < 0) {
          new_da = new_da + 0x168;
        }
      }
      mark_arc_for_deletion(end_arc);
      mark_line_for_deletion(start_line);
      mark_line_for_deletion(end_line);
      if (PCB->SilkActive == '\0') {
        Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Layer = (LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      ChangeArcAngles(Layer,start_arc,start_arc->StartAngle,new_da);
      fix_arc_extra(start_arc,sarc_extra);
      did_something = did_something + 1;
      return;
    }
  }
  else {
    if (start_arc == (ArcTypePtr *)0x0) goto LAB_080bae20;
  }
  new_da = start_arc->Delta;
  dVar17 = 180.00000000 - ((dVar17 + dVar8) * 180.00000000) / 3.14159265;
  if (new_da < 0) {
    X1 = (int)ROUND(dVar17) + 0x5a;
  }
  else {
    X1 = (int)ROUND(dVar17) + -0x5a;
  }
  fVar3 = (float)X1 - (float)start_arc->StartAngle;
  while ((float)(new_da + 0xb4) < fVar3) {
    fVar3 = fVar3 - 360.00000000;
  }
  while (fVar3 < (float)(new_da + -0xb4)) {
    fVar3 = fVar3 + 360.00000000;
  }
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  ChangeArcAngles(Layer,start_arc,start_arc->StartAngle,(int)ROUND(fVar3));
  fix_arc_extra(start_arc,sarc_extra);
  if (PCB->SilkActive == '\0') {
    Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Ptr1 = (void *)(&PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  MoveObject(0x1000,Ptr1,start_line,&start_line->Point1,(sarc_extra->end).x - (start_line->Point1).X
             ,(sarc_extra->end).y - (start_line->Point1).Y);
  if (fVar3 * (float)new_da <= 0.00000000) {
    if (PCB->SilkActive == '\0') {
      Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Ptr1 = (void *)(&PCB->Data->field_0x4c +
                     ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    MoveObject(0x1000,Ptr1,start_line,&start_line->Point1,
               (sarc_extra->start).x - (start_line->Point1).X,
               (sarc_extra->start).y - (start_line->Point1).Y);
    mark_arc_for_deletion(start_arc);
  }
LAB_080bae20:
  X1 = fy;
  new_da = fx;
  sincos(se_sign * -1.57079633 + start_angle + fa,&local_34,&local_3c);
  dVar17 = dist((int)ROUND((double)fr * local_3c + (double)new_da),
                (int)ROUND(local_34 * (double)fr + (double)X1),(end_line->Point2).X,
                (end_line->Point2).Y);
  pLVar7 = start_line;
  if (dVar17 < (double)fr * 0.01745241) {
    fy = (int)local_48;
    fx = LVar9;
  }
  else {
    if ((fx != LVar9) || ((ArcTypePtr *)fy != local_48)) {
      Y1 = (start_line->Point1).X;
      sincos(start_angle + fa,&local_34,&local_3c);
      width = (pLVar7->Point1).Y;
      new_da = (int)ROUND((float)local_3c * 10000.00000000 + (float)Y1);
      local_4c = (end_line->Point2).X;
      fVar4 = (float)width;
      local_50 = (void *)(end_line->Point2).Y;
      iVar12 = (end_line->Point1).Y;
      iVar13 = (end_line->Point1).X;
      X1 = (int)ROUND((float)local_34 * 10000.00000000 + fVar4);
      width = width - X1;
      fVar6 = (float)(Y1 - new_da);
      fVar3 = (float)(iVar12 - (int)local_50) * fVar6 - (float)width * (float)(iVar13 - local_4c);
      if (fVar3 != 0.00000000) {
        fVar5 = (float)iVar13 * (float)(int)local_50 - (float)iVar12 * (float)local_4c;
        fVar4 = (float)X1 * (float)Y1 - (float)new_da * fVar4;
        local_4c = (int)ROUND(((float)(iVar13 - local_4c) * fVar4 - fVar6 * fVar5) / fVar3 +
                              0.50000000);
        local_50 = (void *)(int)ROUND(fVar3 / (fVar4 * (float)(iVar12 - (int)local_50) -
                                              fVar5 * (float)width) + 0.50000000);
      }
      if (PCB->SilkActive == '\0') {
        Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Ptr1 = (void *)(&PCB->Data->field_0x4c +
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      MoveObject(0x1000,Ptr1,end_line,&end_line->Point1,local_4c - iVar13,(int)local_50 - iVar12);
      Y1 = fy;
      X1 = fx;
      pLVar7 = start_line;
      dVar17 = -se_sign;
      new_da = (int)ROUND(se_sign * 90.00000000 +
                          (double)(0xb4 - (int)ROUND(((start_angle + fa) * 180.00000000) /
                                                     3.14159265 + 0.50000000)));
      iVar12 = fr % 100;
      width = fr;
      if (iVar12 == 1) {
        width = fr + -1;
        iVar12 = width % 100;
      }
      width = width + (uint)(iVar12 == 99);
      if (PCB->SilkActive == '\0') {
        Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Layer = (LayerTypePtr)
                (&PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      local_48 = CreateNewArcOnLayer(Layer,fx,fy,width,width,new_da,(int)ROUND(dVar17),
                                     start_line->Thickness,start_line->Clearance,start_line->Flags);
      if (local_48 == (ArcTypePtr *)0x0) {
        if (PCB->SilkActive == '\0') {
          Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Layer = (LayerTypePtr)
                  (&PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        local_48 = CreateNewArcOnLayer(Layer,X1,Y1,width,width,new_da,(int)ROUND(dVar17) * 2,
                                       pLVar7->Thickness,pLVar7->Clearance,pLVar7->Flags);
      }
      if (PCB->SilkActive == '\0') {
        Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Ptr1 = (void *)(&PCB->Data->field_0x4c +
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      AddObjectToCreateUndoList(0x4000,Ptr1,local_48,local_48);
      if (local_48 != (ArcTypePtr *)0x0) {
        cVar2 = PCB->SilkActive;
        if (cVar2 == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        if ((uint)max_arcs <= *(uint *)(new_da + 0x10)) {
          max_arcs = max_arcs + 100;
          new = (Extra *)realloc(arcs,max_arcs * 0x34);
          old = arcs;
          if (new != arcs) {
            arcs = new;
            adjust_pointers(old,new,narcs);
            new = arcs;
          }
          memset(new + narcs,0,(max_arcs - narcs) * 0x34);
          cVar2 = PCB->SilkActive;
        }
        if (cVar2 == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        narcs = *(int *)(new_da + 0x10);
        if (PCB->SilkActive == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        old = (Extra *)((int)arcs +
                       ((int)((int)local_48 - *(int *)(new_da + 0x30)) >> 2) * -0xf0f0f0c);
        new_da = 0xd;
        new = old;
        while (new_da != 0) {
          new_da = new_da + -1;
          (new->start).next = (Extra *)0x0;
          new = (Extra *)((int)new + (uint)bVar16 * -8 + 4);
        }
        fix_arc_extra(local_48,old);
        cVar2 = PCB->SilkActive;
        if (cVar2 == '\0') {
          pDVar10 = PCB->Data;
          new_da = &pDVar10->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          pDVar10 = PCB->Data;
          new_da = &pDVar10->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + pDVar10->LayerN) * 0x5c;
        }
        old = (Extra *)((int)arcs +
                       ((int)((int)local_48 - *(int *)(new_da + 0x30)) >> 2) * -0xf0f0f0c);
        if (start_arc != (ArcTypePtr *)0x0) {
          if (cVar2 == '\0') {
            new_da = &pDVar10->field_0x4c + LayerStack[0] * 0x5c;
          }
          else {
            new_da = &pDVar10->field_0x4c +
                     ((uint)(Settings.ShowSolderSide == '\0') + pDVar10->LayerN) * 0x5c;
          }
          pDVar10 = PCB->Data;
          sarc_extra = (Extra *)((int)arcs +
                                ((int)((int)start_arc - *(int *)(new_da + 0x30)) >> 2) * -0xf0f0f0c)
          ;
          cVar2 = PCB->SilkActive;
        }
        if (end_arc != (ArcTypePtr *)0x0) {
          if (cVar2 == '\0') {
            new_da = &pDVar10->field_0x4c + LayerStack[0] * 0x5c;
          }
          else {
            new_da = &pDVar10->field_0x4c +
                     ((uint)(Settings.ShowSolderSide == '\0') + pDVar10->LayerN) * 0x5c;
          }
          pDVar10 = PCB->Data;
          earc_extra = (Extra *)((int)arcs +
                                ((int)((int)end_arc - *(int *)(new_da + 0x30)) >> 2) * -0xf0f0f0c);
          cVar2 = PCB->SilkActive;
        }
        if (cVar2 == '\0') {
          Ptr1 = (void *)(&pDVar10->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Ptr1 = (void *)(&pDVar10->field_0x4c +
                         ((uint)(Settings.ShowSolderSide == '\0') + pDVar10->LayerN) * 0x5c);
        }
        MoveObject(0x1000,Ptr1,start_line,&start_line->Point2,
                   (old->start).x - (start_line->Point2).X,(old->start).y - (start_line->Point2).Y);
        if (PCB->SilkActive == '\0') {
          Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Layer = (LayerTypePtr)
                  (&PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        Ptr2 = CreateNewLineOnLayer
                         (Layer,(old->end).x,(old->end).y,local_4c,(LocationType)local_50,
                          start_line->Thickness,start_line->Clearance,start_line->Flags);
        if (PCB->SilkActive == '\0') {
          Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
        }
        else {
          Ptr1 = (void *)(&PCB->Data->field_0x4c +
                         ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
        }
        AddObjectToCreateUndoList(4,Ptr1,Ptr2,Ptr2);
        cVar2 = PCB->SilkActive;
        if (cVar2 == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        if ((uint)max_lines <= *(uint *)(new_da + 4)) {
          max_lines = max_lines + 100;
          new_00 = (Extra *)realloc(lines,max_lines * 0x34);
          new = lines;
          if (new_00 != lines) {
            lines = new_00;
            adjust_pointers(new,new_00,nlines);
            new_00 = lines;
          }
          memset(new_00 + nlines,0,(max_lines - nlines) * 0x34);
          cVar2 = PCB->SilkActive;
        }
        if (cVar2 == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        nlines = *(int *)(new_da + 4);
        if (PCB->SilkActive == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        X1 = 0xd;
        new = (Extra *)((int)lines + ((int)((int)Ptr2 - *(int *)(new_da + 0x24)) >> 3) * -0x2e8ba2e4
                       );
        while (X1 != 0) {
          X1 = X1 + -1;
          (new->start).next = (Extra *)0x0;
          new = (Extra *)((int)new + (uint)bVar16 * -8 + 4);
        }
        if (PCB->SilkActive == '\0') {
          new_da = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          new_da = &PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        new = (Extra *)(((int)((int)start_line - *(int *)(new_da + 0x24)) >> 3) * -0x2e8ba2e4 +
                       (int)lines);
        if (PCB->SilkActive == '\0') {
          pDVar15 = PCB->Data;
          pDVar10 = (DataTypePtr *)(LayerStack[0] * 0x5c);
        }
        else {
          pDVar10 = PCB->Data;
          pDVar15 = (DataTypePtr *)
                    (((uint)(Settings.ShowSolderSide == '\0') + pDVar10->LayerN) * 0x5c);
        }
        new_00 = (Extra *)(((int)((int)Ptr2 - *(int *)((int)&pDVar15->ViaN + &pDVar10->field_0x70))
                           >> 3) * -0x2e8ba2e4 + (int)lines);
        pEVar11 = (Extra *)((int)lines +
                           ((int)((int)end_line - *(int *)((int)pDVar15 + (int)pDVar10 + 0x70)) >> 3
                           ) * -0x2e8ba2e4);
        start_extra = new;
        end_extra = pEVar11;
        (new_00->start).pin = (new->start).pin;
        Ptr1 = (new->end).pin;
        pbVar1 = (byte *)&(new_00->start).field_0x8;
        *pbVar1 = *pbVar1 | 8;
        pbVar1 = (byte *)&(new_00->end).field_0x8;
        *pbVar1 = *pbVar1 | 8;
        did_something = did_something + 1;
        (new->end).next = old;
        (old->start).next = new;
        (old->end).next = new_00;
        (new_00->start).next = old;
        (new_00->end).pin = Ptr1;
        (new_00->end).next = pEVar11;
        (pEVar11->start).next = new_00;
        npulled = npulled + 1;
        __fprintf_chk(stderr,1,"%6d loops, %d pulled   \r",nloops,npulled);
        maybe_pull_1((LineTypePtr_conflict *)Ptr2);
        return;
      }
                    // WARNING: Subroutine does not return
      __longjmp_chk(abort_buf,1);
    }
  }
  if (end_arc == (ArcTypePtr *)0x0) {
    if (PCB->SilkActive == '\0') {
      Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Ptr1 = (void *)(&PCB->Data->field_0x4c +
                     ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    MoveObject(0x1000,Ptr1,start_line,&start_line->Point2,
               (end_line->Point2).X - (start_line->Point2).X,
               (end_line->Point2).Y - (start_line->Point2).Y);
  }
  else {
    X1 = end_arc->Delta;
    new_da = X1 + end_arc->StartAngle;
    if (X1 < 0) {
      new_da = new_da + -0x5a;
      dVar17 = -(((start_angle + fa) * 180.00000000) / 3.14159265);
    }
    else {
      new_da = new_da + 0x5a;
      dVar17 = 1.00000000 - ((start_angle + fa) * 180.00000000) / 3.14159265;
    }
    new_da = (int)ROUND(dVar17) - new_da;
    while (0xb4 < new_da) {
      new_da = new_da + -0x168;
    }
    while (new_da < -0xb4) {
      new_da = new_da + 0x168;
    }
    if (PCB->SilkActive == '\0') {
      Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Layer = (LayerTypePtr)
              (&PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    ChangeArcAngles(Layer,end_arc,end_arc->StartAngle,new_da + X1);
    fix_arc_extra(end_arc,earc_extra);
    if (PCB->SilkActive == '\0') {
      local_50 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      local_50 = (void *)(&PCB->Data->field_0x4c +
                         ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    MoveObject(0x1000,local_50,start_line,&start_line->Point2,
               (earc_extra->end).x - (start_line->Point2).X,
               (earc_extra->end).y - (start_line->Point2).Y);
    if (X1 * (new_da + X1) < 1) {
      if (PCB->SilkActive == '\0') {
        Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
      }
      else {
        Ptr1 = (void *)(&PCB->Data->field_0x4c +
                       ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
      }
      MoveObject(0x1000,Ptr1,start_line,&start_line->Point2,
                 (earc_extra->start).x - (start_line->Point2).X,
                 (earc_extra->start).y - (start_line->Point2).Y);
      mark_arc_for_deletion(end_arc);
    }
  }
  mark_line_for_deletion(end_line);
  pbVar1 = (byte *)&(start_extra->end).field_0x8;
  *pbVar1 = *pbVar1 | 8;
  did_something = did_something + 1;
  npulled = npulled + 1;
  __fprintf_chk(stderr,1,"%6d loops, %d pulled   \r",nloops,npulled);
  return;
}



int GlobalPuller(int argc,char **argv,int x,int y)

{
  byte *pbVar1;
  int **ppiVar2;
  ArcTypePtr *a;
  byte bVar3;
  char *__s1;
  PCBTypePtr pPVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  Extra *e;
  Extra *pEVar8;
  LayerTypePtr Layer;
  DataTypePtr *pDVar9;
  int **ppiVar10;
  char cVar11;
  Extra *pEVar12;
  int **ppiVar13;
  int iVar14;
  int **ppiVar15;
  PinTypePtr *cl;
  Extra *pEVar16;
  void *me;
  uint uVar17;
  Extra *pEVar18;
  char *local_e4;
  Extra *local_c4;
  char local_bd;
  int local_a8;
  Extra *local_a4;
  LineTypePtr_conflict *local_a0;
  int local_84;
  uint local_78;
  int local_74;
  uint local_70;
  int local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  Extra *local_40;
  uint local_38;
  int local_34;
  uint local_30;
  BoxType box;
  
  setbuf(stdout,(char *)0x0);
  nloops = 0;
  npulled = 0;
  if (argc < 1) {
    local_e4 = "";
    __printf_chk(1,"puller! %s\n",&DAT_0814741b);
    local_70 = 0;
  }
  else {
    local_e4 = *argv;
    __printf_chk(1,"puller! %s\n",local_e4);
    __s1 = *argv;
    iVar5 = strcasecmp(__s1,"selected");
    iVar6 = strcasecmp(__s1,"found");
    local_70 = 4;
    if (iVar6 != 0) {
      local_70 = -(uint)(iVar5 == 0) & 0x40;
    }
  }
  __printf_chk(1,"optimizing...\n",local_e4);
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  iVar5 = GetLayerGroupNumberByPointer(Layer);
  iVar6 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  current_is_solder = ZEXT14(iVar5 == iVar6);
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  iVar5 = GetLayerGroupNumberByPointer(Layer);
  iVar6 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  current_is_component = ZEXT14(iVar5 == iVar6);
  if (PCB->SilkActive == '\0') {
    iVar5 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar5 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  nlines = *(size_t *)(iVar5 + 4);
  max_lines = nlines;
  lines = (Extra *)calloc(nlines,0x34);
  if (PCB->SilkActive == '\0') {
    iVar5 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar5 = &PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  narcs = *(size_t *)(iVar5 + 0x10);
  max_arcs = narcs;
  arcs = (Extra *)calloc(narcs,0x34);
  __printf_chk(1,"pairing...\n");
  cVar11 = PCB->SilkActive;
  if (cVar11 == '\0') {
    pDVar9 = PCB->Data;
    iVar5 = &pDVar9->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    pDVar9 = PCB->Data;
    iVar5 = &pDVar9->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
  }
  iVar6 = *(int *)(iVar5 + 0x10) + -1;
  if (iVar6 != -1) {
    iVar5 = *(int *)(iVar5 + 0x10) * 0x44;
    while( true ) {
      iVar5 = iVar5 + -0x44;
      iVar14 = LayerStack[0];
      if (cVar11 != '\0') {
        iVar14 = (uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN;
      }
      iVar6 = iVar6 + -1;
      a = (ArcTypePtr *)(iVar5 + *(int *)(&pDVar9->field_0x7c + iVar14 * 0x5c));
      fix_arc_extra(a,(Extra *)((int)arcs +
                               ((int)((int)a - *(int *)(&pDVar9->field_0x7c + iVar14 * 0x5c)) >> 2)
                               * -0xf0f0f0c));
      if (iVar6 == -1) break;
      cVar11 = PCB->SilkActive;
      pDVar9 = PCB->Data;
    }
    cVar11 = PCB->SilkActive;
    pDVar9 = PCB->Data;
  }
  if (cVar11 == '\0') {
    iVar5 = &pDVar9->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar5 = &pDVar9->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
  }
  iVar6 = *(int *)(iVar5 + 4) + -1;
  if (iVar6 != -1) {
    iVar5 = *(int *)(iVar5 + 4) * 0x58;
    while( true ) {
      iVar5 = iVar5 + -0x58;
      iVar14 = LayerStack[0];
      if (cVar11 != '\0') {
        iVar14 = (uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN;
      }
      me = (void *)(iVar5 + *(int *)(&pDVar9->field_0x70 + iVar14 * 0x5c));
      if (-1 < *(int *)((int)me + 0x2c)) {
        e = (Extra *)(((int)((int)me - *(int *)(&pDVar9->field_0x70 + iVar14 * 0x5c)) >> 3) *
                      -0x2e8ba2e4 + (int)lines);
        find_pairs_1(me,(Extra **)e,*(int *)((int)me + 0x2c),*(int *)((int)me + 0x30));
        find_pairs_1(me,(Extra **)&e->end,*(int *)((int)me + 0x40),*(int *)((int)me + 0x44));
      }
      iVar6 = iVar6 + -1;
      if (iVar6 == -1) break;
      cVar11 = PCB->SilkActive;
      pDVar9 = PCB->Data;
    }
    pDVar9 = PCB->Data;
    cVar11 = PCB->SilkActive;
  }
  if (cVar11 == '\0') {
    iVar5 = &pDVar9->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    iVar5 = &pDVar9->field_0x4c + ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
  }
  local_44 = *(int *)(iVar5 + 0x10) + -1;
  if (local_44 != -1) {
    iVar5 = *(int *)(iVar5 + 0x10) * 0x44;
    while( true ) {
      iVar5 = iVar5 + -0x44;
      iVar6 = LayerStack[0];
      if (cVar11 != '\0') {
        iVar6 = (uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN;
      }
      me = (void *)(*(int *)(&pDVar9->field_0x7c + iVar6 * 0x5c) + iVar5);
      e = (Extra *)((int)arcs +
                   ((int)((int)me - *(int *)(&pDVar9->field_0x7c + iVar6 * 0x5c)) >> 2) * -0xf0f0f0c
                   );
      if ((*(byte *)&e->field_0x30 & 2) == 0) {
        find_pairs_1(me,(Extra **)e,(e->start).x,(e->start).y);
        find_pairs_1(me,(Extra **)&e->end,(e->end).x,(e->end).y);
      }
      if (local_44 == 0) break;
      local_44 = local_44 + -1;
      cVar11 = PCB->SilkActive;
      pDVar9 = PCB->Data;
    }
    pDVar9 = PCB->Data;
  }
  local_48 = pDVar9->ElementN - 1;
  if (local_48 != -1) {
    iVar5 = pDVar9->ElementN * 300;
    while( true ) {
      local_58 = iVar5 + -300;
      iVar5 = (int)&pDVar9->Element[-1].BoundingBox.X1 + iVar5;
      if (*(uint *)(iVar5 + 0xe0) != 0) {
        uVar17 = 0;
        local_38 = *(uint *)(iVar5 + 0xe0);
        do {
          me = (void *)(uVar17 * 0x4c + *(int *)(iVar5 + 0x100));
          box.X1 = *(int *)((int)me + 0x34) - *(int *)((int)me + 0x24) / 2;
          box.Y1 = *(int *)((int)me + 0x38) - *(int *)((int)me + 0x24) / 2;
          box.X2 = *(int *)((int)me + 0x24) / 2 + *(int *)((int)me + 0x34);
          box.Y2 = *(int *)((int)me + 0x24) / 2 + *(int *)((int)me + 0x38);
          if (PCB->SilkActive == '\0') {
            iVar6 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
          }
          else {
            iVar6 = &PCB->Data->field_0x4c +
                    ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
          }
          r_search(*(rtree_t **)(iVar6 + 0x34),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   find_pair_pinline_callback,me);
          if (PCB->SilkActive == '\0') {
            iVar6 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
          }
          else {
            iVar6 = &PCB->Data->field_0x4c +
                    ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
          }
          r_search(*(rtree_t **)(iVar6 + 0x40),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                   find_pair_pinarc_callback,me);
          uVar7 = *(uint *)(iVar5 + 0xe0);
        } while ((uVar7 != 0) &&
                (uVar17 = (uVar7 + 1 + uVar17) - local_38, local_38 = uVar7, uVar17 < uVar7));
      }
      local_48 = local_48 + -1;
      if (local_48 == -1) break;
      pDVar9 = PCB->Data;
      iVar5 = local_58;
    }
    pDVar9 = PCB->Data;
  }
  if (pDVar9->ViaN != 0) {
    uVar17 = 0;
    local_78 = pDVar9->ViaN;
    do {
      cl = pDVar9->Via + uVar17;
      box.X1 = cl->X - cl->Thickness / 2;
      box.Y1 = cl->Y - cl->Thickness / 2;
      box.X2 = cl->Thickness / 2 + cl->X;
      box.Y2 = cl->Thickness / 2 + cl->Y;
      if (PCB->SilkActive == '\0') {
        iVar5 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
      }
      else {
        iVar5 = &PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
      }
      r_search(*(rtree_t **)(iVar5 + 0x34),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               find_pair_pinline_callback,cl);
      if (PCB->SilkActive == '\0') {
        iVar5 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
      }
      else {
        iVar5 = &PCB->Data->field_0x4c +
                ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
      }
      r_search(*(rtree_t **)(iVar5 + 0x40),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               find_pair_pinarc_callback,cl);
      pDVar9 = PCB->Data;
      uVar7 = pDVar9->ViaN;
    } while ((uVar7 != 0) &&
            (uVar17 = (uVar7 + 1 + uVar17) - local_78, local_78 = uVar7, uVar17 < uVar7));
  }
  local_4c = pDVar9->ElementN - 1;
  if (local_4c != -1) {
    iVar5 = pDVar9->ElementN * 300;
    do {
      local_5c = iVar5 + -300;
      local_34 = 0;
      local_30 = 0;
      iVar5 = (int)&PCB->Data->Element[-1].BoundingBox.X1 + iVar5;
      uVar17 = *(uint *)(iVar5 + 0xe8);
      uVar7 = uVar17;
      while ((uVar7 != 0 && (local_30 < uVar7))) {
        me = (void *)(local_34 + *(int *)(iVar5 + 0x104));
        iVar6 = *(int *)((int)me + 0x40);
        if (*(int *)((int)me + 0x2c) == iVar6 || *(int *)((int)me + 0x2c) < iVar6) {
          iVar6 = *(int *)((int)me + 0x2c);
        }
        box.X1 = iVar6 - *(int *)((int)me + 0x24) / 2;
        iVar6 = *(int *)((int)me + 0x44);
        if (*(int *)((int)me + 0x30) == iVar6 || *(int *)((int)me + 0x30) < iVar6) {
          iVar6 = *(int *)((int)me + 0x30);
        }
        box.Y1 = iVar6 - *(int *)((int)me + 0x24) / 2;
        iVar6 = *(int *)((int)me + 0x40);
        if (iVar6 <= *(int *)((int)me + 0x2c)) {
          iVar6 = *(int *)((int)me + 0x2c);
        }
        box.X2 = *(int *)((int)me + 0x24) / 2 + iVar6;
        iVar6 = *(int *)((int)me + 0x44);
        if (iVar6 <= *(int *)((int)me + 0x30)) {
          iVar6 = *(int *)((int)me + 0x30);
        }
        box.Y2 = *(int *)((int)me + 0x24) / 2 + iVar6;
        if (PCB->SilkActive == '\0') {
          iVar6 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          iVar6 = &PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        r_search(*(rtree_t **)(iVar6 + 0x34),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 find_pair_padline_callback,me);
        if (PCB->SilkActive == '\0') {
          iVar6 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          iVar6 = &PCB->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
        }
        r_search(*(rtree_t **)(iVar6 + 0x40),&box,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 find_pair_padarc_callback,me);
        uVar7 = *(uint *)(iVar5 + 0xe8);
        if (uVar17 == *(uint *)(iVar5 + 0xe8)) {
          local_30 = local_30 + 1;
          local_34 = local_34 + 0x68;
          uVar7 = uVar17;
        }
      }
      local_4c = local_4c + -1;
      iVar5 = local_5c;
    } while (local_4c != -1);
  }
  iVar5 = nlines;
  if (0 < nlines) {
    iVar6 = 0;
    e = lines;
    pEVar8 = lines;
    do {
      while ((e->start).next != &multi_next) {
        pEVar16 = e;
        if ((e->end).next == &multi_next) goto LAB_080bcb51;
LAB_080bcb29:
        iVar6 = iVar6 + 1;
        e = e + 1;
        pEVar8 = pEVar8 + 1;
        if (iVar5 <= iVar6) goto LAB_080bcb65;
      }
      pEVar12 = (pEVar8->end).next;
      (e->start).next = (Extra *)0x0;
      pEVar16 = pEVar8;
      if (pEVar12 != &multi_next) goto LAB_080bcb29;
LAB_080bcb51:
      iVar6 = iVar6 + 1;
      e = e + 1;
      pEVar8 = pEVar8 + 1;
      (pEVar16->end).next = (Extra *)0x0;
    } while (iVar6 < iVar5);
  }
LAB_080bcb65:
  iVar5 = narcs;
  if (0 < narcs) {
    iVar6 = 0;
    e = arcs;
    pEVar8 = arcs;
    do {
      while ((e->start).next != &multi_next) {
        pEVar16 = e;
        if ((e->end).next == &multi_next) goto LAB_080bcbb1;
LAB_080bcb89:
        iVar6 = iVar6 + 1;
        e = e + 1;
        pEVar8 = pEVar8 + 1;
        if (iVar5 <= iVar6) goto LAB_080bcbc5;
      }
      pEVar12 = (pEVar8->end).next;
      (e->start).next = (Extra *)0x0;
      pEVar16 = pEVar8;
      if (pEVar12 != &multi_next) goto LAB_080bcb89;
LAB_080bcbb1:
      iVar6 = iVar6 + 1;
      e = e + 1;
      pEVar8 = pEVar8 + 1;
      (pEVar16->end).next = (Extra *)0x0;
    } while (iVar6 < iVar5);
  }
LAB_080bcbc5:
  if (0 < nlines) {
    iVar5 = 0;
    iVar6 = 0;
    do {
      iVar6 = iVar6 + 1;
      e = (Extra *)((int)&(lines->start).next + iVar5);
      validate_pair(e,(End *)e);
      e = (Extra *)((int)&(lines->start).next + iVar5);
      iVar5 = iVar5 + 0x34;
      validate_pair(e,&e->end);
    } while (iVar6 < nlines);
  }
  if (0 < narcs) {
    iVar5 = 0;
    iVar6 = 0;
    do {
      iVar6 = iVar6 + 1;
      e = (Extra *)((int)&(arcs->start).next + iVar5);
      validate_pair(e,(End *)e);
      e = (Extra *)((int)&(arcs->start).next + iVar5);
      iVar5 = iVar5 + 0x34;
      validate_pair(e,&e->end);
    } while (iVar6 < narcs);
  }
  pPVar4 = PCB;
  iVar5 = nlines;
  if (0 < nlines) {
    iVar14 = 0;
    iVar6 = 0;
    local_c4 = lines;
    e = lines;
    do {
      if (pPVar4->SilkActive == '\0') {
        uVar17 = *(uint *)(*(int *)(&pPVar4->Data->field_0x70 + LayerStack[0] * 0x5c) + 0x14 +
                          iVar14);
      }
      else {
        uVar17 = *(uint *)(*(int *)(&pPVar4->Data->field_0x70 +
                                   ((uint)(Settings.ShowSolderSide == '\0') + pPVar4->Data->LayerN)
                                   * 0x5c) + 0x14 + iVar14);
      }
      if ((uVar17 & local_70) == local_70) {
        pbVar1 = (byte *)&(local_c4->start).field_0x8;
        *pbVar1 = *pbVar1 | 8;
        pbVar1 = (byte *)&(e->end).field_0x8;
        *pbVar1 = *pbVar1 | 8;
      }
      iVar6 = iVar6 + 1;
      iVar14 = iVar14 + 0x58;
      local_c4 = local_c4 + 1;
      e = e + 1;
    } while (iVar6 < iVar5);
    local_74 = 0;
    iVar5 = 0;
    local_60 = 0;
    do {
      pPVar4 = PCB;
      ppiVar13 = (int **)((int)&(lines->start).next + iVar5);
      if ((*ppiVar13 != (int *)0x0) && (*ppiVar13 == ppiVar13[6])) {
        ppiVar13[6] = (int *)0x0;
        if (pPVar4->SilkActive == '\0') {
          iVar6 = &pPVar4->Data->field_0x4c + LayerStack[0] * 0x5c;
        }
        else {
          iVar6 = &pPVar4->Data->field_0x4c +
                  ((uint)(Settings.ShowSolderSide == '\0') + pPVar4->Data->LayerN) * 0x5c;
        }
        mark_line_for_deletion((LineTypePtr_conflict *)(*(int *)(iVar6 + 0x24) + local_74));
        ppiVar13 = (int **)((int)&(lines->start).next + iVar5);
      }
      if ((((*(byte *)(ppiVar13 + 2) & 2) != 0) && ((*(byte *)(ppiVar13 + 8) & 1) != 0)) &&
         (ppiVar13[7] == ppiVar13[1])) {
        *(byte *)(ppiVar13 + 8) = *(byte *)(ppiVar13 + 8) & 0xfe;
        ppiVar15 = (int **)ppiVar13[6];
        if ((int **)ppiVar13[6] == (int **)0x0) {
LAB_080bd3b3:
          ppiVar13 = (int **)((int)&(lines->start).next + iVar5);
        }
        else {
          do {
            ppiVar10 = ppiVar15;
            if ((int **)*ppiVar10 == ppiVar13) {
              *(byte *)(ppiVar10 + 2) = *(byte *)(ppiVar10 + 2) & 0xfe;
              ppiVar2 = ppiVar10 + 6;
              bVar3 = *(byte *)(ppiVar10 + 8);
              ppiVar13 = ppiVar10;
            }
            else {
              *(byte *)(ppiVar10 + 8) = *(byte *)(ppiVar10 + 8) & 0xfe;
              bVar3 = *(byte *)(ppiVar10 + 2);
              ppiVar13 = ppiVar10 + 6;
              ppiVar2 = ppiVar10;
            }
            if ((bVar3 & 1) == 0) break;
            if (ppiVar2[1] != ppiVar13[1]) goto LAB_080bd3b3;
            *(byte *)(ppiVar2 + 2) = bVar3 & 0xfe;
            ppiVar15 = (int **)*ppiVar2;
            ppiVar13 = ppiVar10;
          } while ((int **)*ppiVar2 != (int **)0x0);
          ppiVar13 = (int **)((int)&(lines->start).next + iVar5);
        }
      }
      if ((((*(byte *)(ppiVar13 + 8) & 2) != 0) && ((*(byte *)(ppiVar13 + 2) & 1) != 0)) &&
         (ppiVar13[1] == ppiVar13[7])) {
        *(byte *)(ppiVar13 + 2) = *(byte *)(ppiVar13 + 2) & 0xfe;
        ppiVar15 = (int **)*ppiVar13;
        while (ppiVar10 = ppiVar15, ppiVar10 != (int **)0x0) {
          if ((int **)*ppiVar10 == ppiVar13) {
            ppiVar13 = ppiVar10;
            ppiVar15 = ppiVar10 + 6;
          }
          else {
            ppiVar13 = ppiVar10 + 6;
            ppiVar15 = ppiVar10;
          }
          *(byte *)(ppiVar13 + 2) = *(byte *)(ppiVar13 + 2) & 0xfe;
          if (((*(byte *)(ppiVar15 + 2) & 1) == 0) || (ppiVar15[1] != ppiVar13[1])) break;
          *(byte *)(ppiVar15 + 2) = *(byte *)(ppiVar15 + 2) & 0xfe;
          ppiVar15 = (int **)*ppiVar15;
          ppiVar13 = ppiVar10;
        }
      }
      iVar6 = nlines;
      local_60 = local_60 + 1;
      iVar5 = iVar5 + 0x34;
      local_74 = local_74 + 0x58;
    } while (local_60 < nlines);
    if (0 < nlines) {
      iVar5 = 0;
      e = lines;
      pEVar8 = lines;
      do {
        pEVar16 = e;
        if ((*(byte *)&(e->start).field_0x8 & 1) != 0) {
          (e->start).next = (Extra *)0x0;
          pEVar16 = pEVar8;
        }
        if ((*(byte *)&(pEVar16->end).field_0x8 & 1) != 0) {
          (pEVar16->end).next = (Extra *)0x0;
        }
        iVar14 = nlines;
        pEVar16 = lines;
        iVar5 = iVar5 + 1;
        e = e + 1;
        pEVar8 = pEVar8 + 1;
      } while (iVar5 < iVar6);
      if (0 < iVar6) {
        local_68 = 0;
        local_50 = 0;
        local_40 = lines;
        do {
          e = (local_40->start).next;
          pEVar8 = local_40;
          if (e != (Extra *)0x0) {
            bVar3 = *(byte *)&(local_40->end).field_0x8;
            me = (local_40->end).pin;
            do {
              pEVar12 = e;
              pEVar18 = (Extra *)&e->end;
              if ((e->start).next != pEVar8) {
                pEVar12 = (Extra *)&e->end;
                pEVar18 = e;
              }
              if (me == (pEVar12->start).pin) break;
              (pEVar12->start).pin = me;
              *(byte *)&(pEVar12->start).field_0x8 =
                   *(byte *)&(pEVar12->start).field_0x8 & 0xfb | bVar3 & 4;
              pEVar12 = (pEVar18->start).next;
              pEVar8 = e;
              e = pEVar12;
            } while (pEVar12 != (Extra *)0x0);
            pEVar8 = (Extra *)((int)&(pEVar16->start).next + local_68);
          }
          e = (pEVar8->end).next;
          if (e != (Extra *)0x0) {
            bVar3 = *(byte *)&(pEVar8->start).field_0x8;
            me = (pEVar8->start).pin;
            do {
              pEVar12 = e;
              pEVar18 = (Extra *)&e->end;
              if ((e->start).next != pEVar8) {
                pEVar12 = (Extra *)&e->end;
                pEVar18 = e;
              }
              if (me == (pEVar12->start).pin) break;
              (pEVar12->start).pin = me;
              *(byte *)&(pEVar12->start).field_0x8 =
                   *(byte *)&(pEVar12->start).field_0x8 & 0xfb | bVar3 & 4;
              pEVar12 = (pEVar18->start).next;
              pEVar8 = e;
              e = pEVar12;
            } while (pEVar12 != (Extra *)0x0);
          }
          local_50 = local_50 + 1;
          local_68 = local_68 + 0x34;
          local_40 = local_40 + 1;
        } while (local_50 < iVar14);
      }
    }
  }
  __printf_chk(1,"pulling...\n");
  iVar5 = _setjmp((__jmp_buf_tag *)abort_buf);
  if (iVar5 != 0) {
LAB_080bceed:
    local_bd = PCB->SilkActive;
    if (local_bd == '\0') {
      pDVar9 = PCB->Data;
      iVar5 = &pDVar9->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      pDVar9 = PCB->Data;
      iVar5 = &pDVar9->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
    }
    local_54 = *(int *)(iVar5 + 4) + -1;
    if (-1 < local_54) {
      iVar5 = *(int *)(iVar5 + 4) * 0x58;
      while( true ) {
        iVar5 = iVar5 + -0x58;
        if (local_bd == '\0') {
          local_84 = &pDVar9->field_0x4c + LayerStack[0] * 0x5c;
          iVar6 = *(int *)(&pDVar9->field_0x70 + LayerStack[0] * 0x5c);
        }
        else {
          iVar6 = ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
          local_84 = &pDVar9->field_0x4c + iVar6;
          iVar6 = *(int *)(&pDVar9->field_0x70 + iVar6);
        }
        if ((*(byte *)((int)lines +
                      ((int)((int)(LineTypePtr)(iVar5 + iVar6) - *(int *)(local_84 + 0x24)) >> 3) *
                      -0x2e8ba2e4 + 0x30) & 2) != 0) {
          if (local_bd == '\0') {
            Layer = (LayerTypePtr)(&pDVar9->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            Layer = (LayerTypePtr)
                    (&pDVar9->field_0x4c +
                    ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c);
          }
          RemoveLine(Layer,(LineTypePtr)(iVar5 + iVar6));
        }
        local_54 = local_54 + -1;
        if (local_54 < 0) break;
        local_bd = PCB->SilkActive;
        pDVar9 = PCB->Data;
      }
      local_bd = PCB->SilkActive;
      pDVar9 = PCB->Data;
    }
    if (local_bd == '\0') {
      iVar5 = &pDVar9->field_0x4c + LayerStack[0] * 0x5c;
    }
    else {
      iVar5 = &pDVar9->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
    }
    local_64 = *(int *)(iVar5 + 0x10) + -1;
    if (-1 < local_64) {
      iVar5 = *(int *)(iVar5 + 0x10) * 0x44;
      while( true ) {
        iVar5 = iVar5 + -0x44;
        iVar6 = LayerStack[0];
        if (local_bd != '\0') {
          iVar6 = (uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN;
        }
        a = (ArcTypePtr *)(iVar5 + *(int *)(&pDVar9->field_0x7c + iVar6 * 0x5c));
        if ((*(byte *)((int)arcs +
                      ((int)((int)a - *(int *)(&pDVar9->field_0x7c + iVar6 * 0x5c)) >> 2) *
                      -0xf0f0f0c + 0x30) & 2) != 0) {
          if (local_bd == '\0') {
            Layer = (LayerTypePtr)(&pDVar9->field_0x4c + LayerStack[0] * 0x5c);
          }
          else {
            Layer = (LayerTypePtr)
                    (&pDVar9->field_0x4c +
                    ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c);
          }
          RemoveArc(Layer,a);
        }
        local_64 = local_64 + -1;
        if (local_64 < 0) break;
        local_bd = PCB->SilkActive;
        pDVar9 = PCB->Data;
      }
    }
    free(lines);
    free(arcs);
    arcs = (Extra *)0x0;
    lines = (Extra *)0x0;
    max_arcs = 0;
    max_lines = 0;
    narcs = 0;
    nlines = 0;
    IncrementUndoSerialNumber();
    return 0;
  }
  did_something = 1;
LAB_080bce73:
  nloops = nloops + 1;
  __fprintf_chk(stderr,1,"%6d loops, %d pulled   \r",nloops,npulled);
  did_something = 0;
  cVar11 = PCB->SilkActive;
  if (cVar11 == '\0') {
    iVar5 = *(int *)(&PCB->Data->field_0x50 + LayerStack[0] * 0x5c);
  }
  else {
    iVar5 = *(int *)(&PCB->Data->field_0x50 +
                    ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  iVar6 = iVar5 + -1;
  if (iVar6 != -1) {
    iVar5 = iVar5 * 0x58;
    do {
      iVar5 = iVar5 + -0x58;
      if (cVar11 == '\0') {
        local_a8 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
        iVar14 = *(int *)(&PCB->Data->field_0x70 + LayerStack[0] * 0x5c);
      }
      else {
        pDVar9 = PCB->Data;
        iVar14 = ((uint)(Settings.ShowSolderSide == '\0') + pDVar9->LayerN) * 0x5c;
        local_a8 = &pDVar9->field_0x4c + iVar14;
        iVar14 = *(int *)(&pDVar9->field_0x70 + iVar14);
      }
      local_a0 = (LineTypePtr_conflict *)(iVar14 + iVar5);
      e = (Extra *)(((int)((int)local_a0 - *(int *)(local_a8 + 0x24)) >> 3) * -0x2e8ba2e4 +
                   (int)lines);
      if ((*(byte *)&e->field_0x30 & 2) == 0) {
        if ((e->start).next == (Extra *)0x0) {
          local_a4 = (e->end).next;
          if (local_a4 != (Extra *)0x0) goto LAB_080bd0c3;
        }
        else {
          local_a4 = (e->end).next;
          if (local_a4 != (Extra *)0x0) {
LAB_080bd0c3:
            if ((uint)(((int)((int)local_a4 - (int)lines) >> 2) * -0x3b13b13b) < (uint)nlines) {
              maybe_pull_1(local_a0);
              goto LAB_080bd113;
            }
          }
          pEVar8 = (e->start).next;
          pbVar1 = (byte *)&(e->end).field_0x8;
          *pbVar1 = *pbVar1 & 0xf7;
          if ((pEVar8 == (Extra *)0x0) ||
             ((uint)nlines <= (uint)(((int)((int)pEVar8 - (int)lines) >> 2) * -0x3b13b13b))) {
            pbVar1 = (byte *)&(e->start).field_0x8;
            *pbVar1 = *pbVar1 & 0xf7;
          }
          else {
            reverse_line(local_a0);
            maybe_pull_1(local_a0);
          }
        }
      }
LAB_080bd113:
      iVar6 = iVar6 + -1;
      if (iVar6 == -1) goto code_r0x080bd122;
      cVar11 = PCB->SilkActive;
    } while( true );
  }
  goto LAB_080bceed;
code_r0x080bd122:
  if (did_something == 0) goto LAB_080bceed;
  goto LAB_080bce73;
}



int Puller(int argc,char **argv,int Ux,int Uy)

{
  LocationType LVar1;
  LineTypePtr_conflict *pLVar2;
  ArcTypePtr *pAVar3;
  int new_da;
  LayerTypePtr Layer;
  void *Ptr1;
  double dVar4;
  double dVar5;
  double local_2c;
  double local_24 [2];
  
  new_da = find_pair(Crosshair.X,Crosshair.Y);
  if ((new_da == 0) && (new_da = find_pair(Ux,Uy), new_da == 0)) {
    return 0;
  }
  new_da = within((the_line->Point1).X,(the_line->Point1).Y,x,y,the_line->Thickness);
  pLVar2 = the_line;
  if (new_da == 0) {
    new_da = within((the_line->Point2).X,(the_line->Point2).Y,x,y,the_line->Thickness);
    if (new_da == 0) {
      return 1;
    }
    ex = (the_line->Point1).X;
    ey = (the_line->Point1).Y;
  }
  else {
    ex = (the_line->Point2).X;
    ey = (the_line->Point2).Y;
    (the_line->Point2).X = (the_line->Point1).X;
    LVar1 = (pLVar2->Point1).Y;
    (pLVar2->Point1).X = ex;
    (pLVar2->Point1).Y = ey;
    (pLVar2->Point2).Y = LVar1;
  }
  cx = the_arc->X;
  cy = the_arc->Y;
  new_da = arc_endpoint_is(the_arc,the_arc->StartAngle,x,y);
  if (new_da == 0) {
    new_da = arc_endpoint_is(the_arc,the_arc->Delta + the_arc->StartAngle,x,y);
    if (new_da == 0) {
      return 1;
    }
  }
  else {
    if (PCB->SilkActive == '\0') {
      Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
    }
    else {
      Layer = (LayerTypePtr)
              (&PCB->Data->field_0x4c +
              ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
    }
    ChangeArcAngles(Layer,the_arc,the_arc->StartAngle + the_arc->Delta,-the_arc->Delta);
  }
  new_da = within(cx,cy,ex,ey,the_arc->Width * 2);
  if (new_da != 0) {
    return 1;
  }
  atan2((double)(ey - y),(double)(x - ex));
  dVar4 = atan2((double)(ey - cy),(double)(cx - ex));
  dVar4 = (dVar4 * 180.00000000) / 3.14159265;
  new_da = the_arc->Width;
  dVar5 = dist(cx,cy,ex,ey);
  dVar5 = acos((double)new_da / dVar5);
  dVar5 = (dVar5 * 180.00000000) / 3.14159265;
  if (the_arc->Delta < 1) {
    dVar4 = dVar4 + dVar5;
  }
  else {
    dVar4 = dVar4 - dVar5;
  }
  new_da = (int)ROUND(dVar4 - (double)the_arc->StartAngle);
  if (new_da < 0xb5) {
    if (new_da < -0xb4) {
      new_da = new_da + 0x168;
    }
  }
  else {
    new_da = new_da + -0x168;
  }
  if (PCB->SilkActive == '\0') {
    Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Layer = (LayerTypePtr)
            (&PCB->Data->field_0x4c +
            ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  ChangeArcAngles(Layer,the_arc,the_arc->StartAngle,new_da);
  pAVar3 = the_arc;
  sincos(((double)(the_arc->Delta + the_arc->StartAngle) * 3.14159265) / 180.00000000,local_24,
         &local_2c);
  x = (int)ROUND(((double)pAVar3->X - (double)pAVar3->Width * local_2c) + 0.50000000);
  y = (int)ROUND((double)pAVar3->Height * local_24[0] + (double)pAVar3->Y + 0.50000000);
  if (PCB->SilkActive == '\0') {
    Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
  }
  else {
    Ptr1 = (void *)(&PCB->Data->field_0x4c +
                   ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
  }
  MoveObject(0x1000,Ptr1,the_line,&the_line->Point2,x - (the_line->Point2).X,
             y - (the_line->Point2).Y);
  (*gui->invalidate_all)();
  IncrementUndoSerialNumber();
  return 1;
}



void register_puller_action_list(void)

{
  hid_register_actions(puller_action_list,2);
  return;
}



int find_pair_padline_callback(BoxType *b,void *cl)

{
  Extra *e;
  int y1;
  int x1;
  int py;
  int px;
  double dVar1;
  double dVar2;
  int x2;
  int y2;
  Extra *pEVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  double dVar8;
  
  if (PCB->SilkActive == '\0') {
    x2 = &PCB->Data->field_0x4c + LayerStack[0] * 0x5c;
  }
  else {
    x2 = &PCB->Data->field_0x4c +
         ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c;
  }
  if (*(char *)((int)cl + 0x14) < '\0') {
    if (current_is_solder == 0) {
      return 0;
    }
  }
  else {
    if (current_is_component == 0) {
      return 0;
    }
  }
  e = (Extra *)((int)lines + ((int)((int)b - *(int *)(x2 + 0x24)) >> 3) * -0x2e8ba2e4);
  x2 = check_point_in_pad((PadTypePtr *)cl,b[2].Y2,b[3].X1,(End *)e);
  y2 = check_point_in_pad((PadTypePtr *)cl,b[4].X1,b[4].Y1,&e->end);
  if (y2 + x2 == 0) {
    x2 = b[4].X1;
    y2 = b[4].Y1;
    y1 = b[3].X1;
    iVar6 = *(int *)((int)cl + 0x44);
    x1 = b[2].Y2;
    py = *(int *)((int)cl + 0x30);
    iVar5 = *(int *)((int)cl + 0x40);
    px = *(int *)((int)cl + 0x2c);
    dVar1 = (double)(y1 - y2) * (double)(px - iVar5) - (double)(py - iVar6) * (double)(x1 - x2);
    if (dVar1 != 0.00000000) {
      iVar4 = iVar5;
      if (px <= iVar5) {
        iVar4 = px;
      }
      dVar2 = (double)x1 * (double)y2 - (double)y1 * (double)x2;
      dVar8 = (double)px * (double)iVar6 - (double)py * (double)iVar5;
      dVar7 = ((double)(x1 - x2) * dVar8 - (double)(px - iVar5) * dVar2) / dVar1;
      if ((double)iVar4 <= dVar7) {
        if (iVar5 <= px) {
          iVar5 = px;
        }
        if (dVar7 <= (double)iVar5) {
          iVar5 = iVar6;
          if (py <= iVar6) {
            iVar5 = py;
          }
          dVar1 = (dVar8 * (double)(y1 - y2) - dVar2 * (double)(py - iVar6)) / dVar1;
          if ((double)iVar5 <= dVar1) {
            if (iVar6 <= py) {
              iVar6 = py;
            }
            if (dVar1 <= (double)iVar6) {
              iVar6 = x2;
              if (x1 <= x2) {
                iVar6 = x1;
              }
              if ((double)iVar6 <= dVar7) {
                iVar6 = x2;
                if (x2 <= x1) {
                  iVar6 = x1;
                }
                if (dVar7 <= (double)iVar6) {
                  iVar6 = y2;
                  if (y1 <= y2) {
                    iVar6 = y1;
                  }
                  if ((double)iVar6 <= dVar1) {
                    iVar6 = y2;
                    if (y2 <= y1) {
                      iVar6 = y1;
                    }
                    if (dVar1 <= (double)iVar6) {
                      dist_lsp(x1,y1,x2,y2,px,py);
                      dist_lsp(b[2].Y2,b[3].X1,b[4].X1,b[4].Y1,*(int *)((int)cl + 0x40),
                               *(int *)((int)cl + 0x44));
                      goto LAB_080bdd1c;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    dVar1 = (double)((*(int *)((int)cl + 0x24) + 1) / 2);
    dVar7 = dist_lsp(x1,y1,x2,y2,px,py);
    dVar8 = dist_lsp(b[2].Y2,b[3].X1,b[4].X1,b[4].Y1,*(int *)((int)cl + 0x40),
                     *(int *)((int)cl + 0x44));
    if ((dVar7 < dVar1) || (dVar8 < dVar1)) {
LAB_080bdd1c:
      pEVar3 = (e->start).next;
      if (pEVar3 != (Extra *)0x0) {
        if (e == (pEVar3->start).next) {
          (pEVar3->start).next = &multi_next;
          pEVar3 = (e->start).next;
        }
        if (e == (pEVar3->end).next) {
          (pEVar3->end).next = &multi_next;
        }
      }
      pEVar3 = (e->end).next;
      (e->start).next = (Extra *)0x817ccc0;
      if (pEVar3 != (Extra *)0x0) {
        if (e == (pEVar3->start).next) {
          (pEVar3->start).next = &multi_next;
        }
        if (e == (pEVar3->end).next) {
          (pEVar3->end).next = &multi_next;
        }
      }
      (e->end).next = (Extra *)0x817ccc0;
      return 0;
    }
  }
  return 0;
}



void __regparm3 fab_line(int x1,int y1,int x2,int y2)

{
  (*gui->draw_line)(Output.fgGC,x1,y1,x2,y2);
  return;
}



void __regparm3 fab_circle(int x,int y,int r)

{
  (*gui->draw_arc)(Output.fgGC,x,y,r,r,0,0xb4);
  (*gui->draw_arc)(Output.fgGC,x,y,r,r,0xb4,0xb4);
  return;
}



void __regparm3 drill_sym(int idx,int x,int y)

{
  int x1;
  int y1;
  int r;
  int y1_00;
  int local_24;
  int local_20;
  
  y1 = idx / 5;
  y1_00 = y1 + 1;
  r = y1_00 * 0x640;
  switch(idx % 5) {
  case 0:
    fab_line(x,y,x,r + y);
    r = y - (r >> 1);
    x1 = y1_00 * 0x5140 >> 0x1f;
    y1_00 = (y1_00 * 0x5140) / 0xf + x1;
    fab_line(x,y,(y1_00 - x1) + x,r);
    fab_line(x,y,(x1 - y1_00) + x,r);
    if (0 < y1) {
      r = 1;
      y1_00 = 0x640;
      do {
        r = r + 1;
        fab_circle(x,y,y1_00);
        y1_00 = y1_00 + 0x640;
      } while (r <= y1);
      return;
    }
    break;
  case 1:
    fab_line(x,y + y1_00 * -0x640,x,r + y);
    fab_line(x + y1_00 * -0x640,y,r + x,y);
    if (0 < y1) {
      local_20 = x + 0x640;
      local_24 = 1;
      y1_00 = y;
      do {
        y1_00 = y1_00 + -0x640;
        x = x + -0x640;
        y = y + 0x640;
        fab_line(x,y1_00,local_20,y1_00);
        fab_line(x,y1_00,x,y);
        fab_line(x,y,local_20,y);
        fab_line(local_20,y1_00,local_20,y);
        local_24 = local_24 + 1;
        local_20 = local_20 + 0x640;
      } while (local_24 <= y1);
      return;
    }
    break;
  case 2:
    y1_00 = y1_00 * 0x12c0;
    if (y1_00 < 0) {
      y1_00 = y1_00 + 3;
    }
    y1_00 = y1_00 >> 2;
    r = -y1_00 + y;
    x1 = -y1_00 + x;
    fab_line(x1,r,x + y1_00,y1_00 + y);
    fab_line(x1,y1_00 + y,x + y1_00,r);
    if (0 < y1) {
      local_20 = x + 0x640;
      local_24 = 1;
      y1_00 = y;
      do {
        y1_00 = y1_00 + -0x640;
        x = x + -0x640;
        y = y + 0x640;
        fab_line(x,y1_00,local_20,y1_00);
        fab_line(x,y1_00,x,y);
        fab_line(x,y,local_20,y);
        fab_line(local_20,y1_00,local_20,y);
        local_24 = local_24 + 1;
        local_20 = local_20 + 0x640;
      } while (local_24 <= y1);
      return;
    }
    break;
  case 3:
    y1_00 = 0;
    if (-1 < y1) {
      r = 800;
      do {
        y1_00 = y1_00 + 1;
        fab_circle(x,y,r);
        r = r + 0x640;
      } while (y1_00 <= y1);
      return;
    }
    break;
  case 4:
    if (0 < y1_00) {
      local_20 = x + 0x640;
      local_24 = 1;
      y1 = y;
      do {
        x = x + -0x640;
        y1 = y1 + -0x640;
        y = y + 0x640;
        fab_line(x,y1,local_20,y1);
        fab_line(x,y1,x,y);
        fab_line(x,y,local_20,y);
        fab_line(local_20,y1,local_20,y);
        local_24 = local_24 + 1;
        local_20 = local_20 + 0x640;
      } while (local_24 <= y1_00);
    }
  }
  return;
}



int PrintFab_overhang(void)

{
  DrillInfoTypePtr *pDVar1;
  Cardinal *pCVar2;
  int iVar3;
  int iVar4;
  
  pDVar1 = GetDrillInfo(PCB->Data);
  iVar4 = pDVar1->DrillN - 1;
  if (-1 < iVar4) {
    pCVar2 = &pDVar1->Drill[pDVar1->DrillN - 1].ViaCount;
    iVar3 = 0;
    do {
      iVar3 = (iVar3 + (uint)(pCVar2[1] < pCVar2[-1] + *pCVar2) + 1) - (uint)(pCVar2[1] == 0);
      pCVar2 = pCVar2 + -10;
      iVar4 = iVar4 + -1;
    } while (-1 < iVar4);
    if (3 < iVar3) {
      return iVar3 * 15000 + 30000;
    }
  }
  return 90000;
}



void text_at(int x,int y,int align,char *fmt,...)

{
  int iVar1;
  PCBTypePtr pPVar2;
  int y1;
  int iVar3;
  char *pcVar4;
  int in_GS_OFFSET;
  ulong local_26c;
  undefined4 local_268;
  undefined4 local_264;
  char tmp [512];
  TextType t;
  
  pPVar2 = PCB;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  t.TextString = tmp;
  __vsprintf_chk(t.TextString,1,0x200,fmt,&stack0x00000014);
  t.Direction = '\0';
  t.Scale = 0x96;
  MakeFlags((FlagType *)&local_26c,0);
  t.Flags.f = local_26c;
  t.Flags.t._0_4_ = local_268;
  t.Flags.t._4_4_ = local_264;
  if (tmp[0] == '\0') {
    y1 = 0;
    iVar3 = 0;
  }
  else {
    pcVar4 = tmp;
    iVar3 = 0;
    do {
      pcVar4 = pcVar4 + 1;
      iVar3 = iVar3 + (pPVar2->Font).Symbol[tmp[0]].Delta + (pPVar2->Font).Symbol[tmp[0]].Width;
      tmp[0] = *pcVar4;
    } while (tmp[0] != '\0');
    iVar3 = (iVar3 * 0x96) / 100;
    y1 = -((int)((align & 3U) * iVar3) / 2);
  }
  t.Y = y;
  t.X = 0;
  if (-1 < y1 + x) {
    t.X = y1 + x;
  }
  DrawTextLowLevel((TextTypePtr)&t,0);
  if ((align & 8U) != 0) {
    y1 = t.Y + 1000 + ((pPVar2->Font).MaxHeight * 0x96) / 100;
    fab_line(t.X,y1,iVar3 + t.X,y1);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void PrintFab(void)

{
  int iVar1;
  bool bVar2;
  DataTypePtr *pDVar3;
  Cardinal CVar4;
  DrillInfoTypePtr *d;
  Cardinal *pCVar5;
  tm *__tp;
  int idx;
  int iVar6;
  char *__s2;
  int y;
  int *piVar7;
  DataTypePtr *pDVar8;
  uint uVar9;
  undefined *puVar10;
  int idx_00;
  int in_GS_OFFSET;
  int local_98;
  int local_94;
  int local_8c;
  int local_88;
  int local_84;
  int local_80;
  FlagType local_7c [2];
  time_t local_64;
  char utcTime [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags(local_7c,0);
  d = GetDrillInfo(PCB->Data);
  RoundDrillInfo(d,100);
  local_84 = -75000;
  local_8c = 0;
  y = d->DrillN - 1;
  if (-1 < y) {
    local_8c = 0;
    pCVar5 = &d->Drill[d->DrillN - 1].ViaCount;
    do {
      local_8c = (local_8c + (uint)(pCVar5[1] < pCVar5[-1] + *pCVar5) + 1) - (uint)(pCVar5[1] == 0);
      pCVar5 = pCVar5 + -10;
      y = y + -1;
    } while (-1 < y);
    y = -30000;
    local_84 = -15000;
    if (3 < local_8c) goto LAB_080be586;
    local_84 = local_8c * 15000 + -75000;
  }
  y = local_84 + -15000;
LAB_080be586:
  (*gui->set_line_width)(Output.fgGC,800);
  local_88 = 0;
  local_98 = d->DrillN - 1;
  if (-1 < local_98) {
    idx_00 = local_84;
    y = d->DrillN * 0x28;
    do {
      local_84 = idx_00;
      local_94 = y + -0x28;
      idx_00 = -1;
      piVar7 = (int *)((int)&d->Drill[-1].DrillSize + y);
      if ((uint)piVar7[5] < (uint)(piVar7[4] + piVar7[3])) {
        idx_00 = local_8c + -1;
        local_8c = idx_00;
      }
      bVar2 = false;
      local_80 = -1;
      if (piVar7[5] != 0) {
        local_8c = local_8c + -1;
        bVar2 = local_8c != -1 && idx_00 != -1;
        local_80 = local_8c;
      }
      (*gui->set_color)(Output.fgGC,PCB->PinColor);
      if (piVar7[6] != 0) {
        uVar9 = 0;
        do {
          y = *(int *)(piVar7[8] + uVar9 * 4);
          idx = local_80;
          if ((*(byte *)(y + 0x14) & 8) == 0) {
            idx = idx_00;
          }
          uVar9 = uVar9 + 1;
          drill_sym(idx,*(int *)(y + 0x34),*(int *)(y + 0x38));
        } while (uVar9 <= (uint)piVar7[6] && piVar7[6] != uVar9);
      }
      if (idx_00 == -1) {
        if (local_80 != -1) goto LAB_080be713;
      }
      else {
        drill_sym(idx_00,15000,local_84 + 0xea6);
        text_at(0x20f58,local_84,200,"YES");
        text_at(98000,local_84,200,"%d",(piVar7[4] + piVar7[3]) - piVar7[5]);
        if (local_80 != -1) {
          local_84 = local_84 + -15000;
LAB_080be713:
          drill_sym(local_80,15000,local_84 + 0xea6);
          text_at(140000,local_84,200,"NO");
          text_at(98000,local_84,200,"%d",piVar7[5]);
        }
      }
      (*gui->set_color)(Output.fgGC,PCB->ElementColor);
      text_at(45000,local_84,200,"%0.3f",(double)((float)*piVar7 / 100000.00000000 + 0.00040000));
      if (bVar2) {
        text_at(45000,local_84 + 15000,200,"%0.3f",(double)*piVar7 / 100000.00000000 + 0.00040000);
      }
      local_88 = local_88 + piVar7[4] + piVar7[3];
      local_98 = local_98 + -1;
      idx_00 = local_84 + -15000;
      y = local_94;
    } while (-1 < local_98);
    y = local_84 + -30000;
    local_84 = local_84 + -15000;
  }
  idx_00 = 0;
  (*gui->set_color)(Output.fgGC,PCB->ElementColor);
  text_at(0,local_84,900,"Symbol");
  text_at(41000,local_84,900,"Diam. (Inch)");
  text_at(95000,local_84,900,"Count");
  text_at(130000,local_84,900,"Plated?");
  text_at(0,y,0,"There are %d different drill sizes used in this layout, %d holes total",d->DrillN,
          local_88);
  local_64 = time((time_t *)0x0);
  __tp = gmtime(&local_64);
  strftime(utcTime,0x40,"%c UTC",__tp);
  pDVar3 = PCB->Data;
  y = pDVar3->LayerN;
  pDVar8 = pDVar3;
  if (0 < y) {
    do {
      __s2 = *(char **)&pDVar8->field_0x4c;
      if (((__s2 != (char *)0x0) &&
          ((*(int *)&pDVar8->field_0x50 != 0 || (*(int *)&pDVar8->field_0x5c != 0)))) &&
         ((idx = strcasecmp("route",__s2), idx == 0 || (idx = strcasecmp("outline",__s2), idx == 0))
         )) goto LAB_080bebdf;
      idx_00 = idx_00 + 1;
      pDVar8 = (DataTypePtr *)&pDVar8->field_0x5c;
    } while (idx_00 < y);
  }
  if (idx_00 == y) {
    (*gui->set_line_width)(Output.fgGC,1000);
    (*gui->draw_line)(Output.fgGC,0,0,PCB->MaxWidth,0);
    (*gui->draw_line)(Output.fgGC,0,0,0,PCB->MaxHeight);
    (*gui->draw_line)(Output.fgGC,PCB->MaxWidth,0,PCB->MaxWidth,PCB->MaxHeight);
    (*gui->draw_line)(Output.fgGC,0,PCB->MaxHeight,PCB->MaxWidth,PCB->MaxHeight);
    (*gui->set_line_width)(Output.fgGC,800);
    text_at(200000,-15000,0,"Maximum Dimensions: %d mils wide, %d mils high",PCB->MaxWidth / 100,
            PCB->MaxHeight / 100);
    local_88 = PCB->MaxHeight / 100;
    text_at(PCB->MaxWidth / 2,PCB->MaxHeight + 2000,1,
            "Board outline is the centerline of this 10 mil rectangle - 0,0 to %d,%d mils",
            PCB->MaxWidth / 100,local_88);
  }
  else {
LAB_080bebdf:
    (*gui->set_line_width)(Output.fgGC,1000);
    CVar4 = (&pDVar3->ViaN + idx_00 * 0x17)[0x14];
    y = CVar4 - 1;
    if (y != -1) {
      idx = CVar4 * 0x58;
      do {
        idx = idx + -0x58;
        y = y + -1;
        iVar6 = (&pDVar3->ViaN + idx_00 * 0x17)[0x1c] + idx;
        (*gui->draw_line)(Output.fgGC,*(int *)(iVar6 + 0x2c),*(int *)(iVar6 + 0x30),
                          *(int *)(iVar6 + 0x40),*(int *)(iVar6 + 0x44));
      } while (y != -1);
    }
    CVar4 = (&pDVar3->ViaN + idx_00 * 0x17)[0x17];
    y = CVar4 - 1;
    if (y != -1) {
      idx = CVar4 * 0x44;
      do {
        idx = idx + -0x44;
        y = y + -1;
        iVar6 = (&pDVar3->ViaN + idx_00 * 0x17)[0x1f] + idx;
        local_88 = *(int *)(iVar6 + 0x3c);
        (*gui->draw_arc)(Output.fgGC,*(int *)(iVar6 + 0x34),*(int *)(iVar6 + 0x38),
                         *(int *)(iVar6 + 0x2c),*(int *)(iVar6 + 0x30),local_88,
                         *(int *)(iVar6 + 0x40));
      } while (y != -1);
    }
    CVar4 = (&pDVar3->ViaN + idx_00 * 0x17)[0x15];
    y = CVar4 - 1;
    if (y != -1) {
      puVar10 = (undefined *)(CVar4 * 0x3c);
      do {
        puVar10 = &DAT_ffffffc4 + (int)puVar10;
        y = y + -1;
        DrawTextLowLevel((TextTypePtr)(puVar10 + (&pDVar3->ViaN + idx_00 * 0x17)[0x1d]),0);
      } while (y != -1);
    }
    (*gui->set_line_width)(Output.fgGC,800);
    text_at(PCB->MaxWidth / 2,PCB->MaxHeight + 2000,1,"Board outline is the centerline of this path"
           );
  }
  text_at(200000,-30000,0,"Date: %s",utcTime,local_88);
  __s2 = pcb_author();
  text_at(200000,-45000,0,"Author: %s",__s2,local_88);
  __s2 = PCB->Name;
  if ((__s2 == (char *)0x0) || (*__s2 == '\0')) {
    __s2 = "(unknown)";
  }
  text_at(200000,-60000,0,"Title: %s - Fabrication Drawing",__s2,local_88);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * ConnectionName(int type,void *ptr1,void *ptr2)

{
  char name [256];
  char *pcVar1;
  char *pcVar2;
  
  if (type == 0x100) {
    pcVar2 = *(char **)((int)ptr2 + 0x40);
  }
  else {
    if (type != 0x200) {
      return (char *)0x0;
    }
    pcVar2 = *(char **)((int)ptr2 + 0x5c);
  }
  pcVar1 = *(char **)((int)ptr1 + 0x94);
  if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
    pcVar1 = "(unknown)";
  }
  __strcpy_chk(0x817cdc0,pcVar1,0x100);
  __strcat_chk(0x817cdc0,&DAT_08156000,0x100);
  if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
    pcVar2 = "(unknown)";
  }
  __strcat_chk(0x817cdc0,pcVar2,0x100);
  return (char *)&ram0x0817cdc0;
}



RatTypePtr * AddNet(void)

{
  Cardinal CVar1;
  PCBTypePtr pPVar2;
  int ratDrawn;
  int type;
  char *nodename;
  LibraryMenuTypePtr *Menu;
  LibraryMenuTypePtr *pLVar3;
  LibraryEntryTypePtr *pLVar4;
  char *pcVar5;
  RatTypePtr *pRVar6;
  int iVar7;
  int in_GS_OFFSET;
  Cardinal local_158;
  Cardinal local_154;
  void *ptr3;
  void *local_148;
  void *local_144;
  char name1 [256];
  char ratname [20];
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((Crosshair.AttachedLine.Point1.X == Crosshair.AttachedLine.Point2.X) &&
     (pRVar6 = (RatTypePtr *)0x0, Crosshair.AttachedLine.Point1.Y == Crosshair.AttachedLine.Point2.Y
     )) goto LAB_080bf175;
  type = SearchObjectByLocation
                   (0x300,&local_144,&local_148,&ptr3,Crosshair.AttachedLine.Point1.X,
                    Crosshair.AttachedLine.Point1.Y,5);
  if (type != 0) {
    if ((*(char **)((int)local_144 + 0x94) == (char *)0x0) ||
       (**(char **)((int)local_144 + 0x94) == '\0')) {
      Message("You must name the starting element first\n");
      pRVar6 = (RatTypePtr *)0x0;
      goto LAB_080bf175;
    }
    if (*(char *)((int)local_148 + 0x14) < '\0') {
      local_154 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    }
    else {
      local_154 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
    }
    nodename = ConnectionName(type,local_144,local_148);
    __strcpy_chk(name1,nodename,0x100);
    type = SearchObjectByLocation
                     (0x300,&local_144,&local_148,&ptr3,Crosshair.AttachedLine.Point2.X,
                      Crosshair.AttachedLine.Point2.Y,5);
    if (type != 0) {
      if ((*(char **)((int)local_144 + 0x94) == (char *)0x0) ||
         (**(char **)((int)local_144 + 0x94) == '\0')) {
        Message("You must name the ending element first\n");
        pRVar6 = (RatTypePtr *)0x0;
      }
      else {
        if (*(char *)((int)local_148 + 0x14) < '\0') {
          local_158 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
        }
        else {
          local_158 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
        }
        nodename = ConnectionName(type,local_144,local_148);
        Menu = netnode_to_netname(name1);
        if (Menu == (LibraryMenuTypePtr *)0x0) {
          Menu = netnode_to_netname(nodename);
          if (Menu == (LibraryMenuTypePtr *)0x0) {
            ratDrawn = ratDrawn + 1;
            __sprintf_chk(ratname,1,0x14,"  ratDrawn%i",ratDrawn);
            while( true ) {
              pPVar2 = PCB;
              CVar1 = (PCB->NetlistLib).MenuN;
              type = CVar1 - 1;
              if (type == -1) break;
              Menu = (PCB->NetlistLib).Menu + (CVar1 - 1);
              while ((Menu->Name == (char *)0x0 || (iVar7 = strcmp(Menu->Name,ratname), iVar7 != 0))
                    ) {
                type = type + -1;
                Menu = Menu + -1;
                if (type == -1) goto LAB_080bf314;
              }
              ratDrawn = ratDrawn + 1;
              __sprintf_chk(ratname,1,0x14,"  ratDrawn%i",ratDrawn);
            }
LAB_080bf314:
            Menu = GetLibraryMenuMemory((LibraryTypePtr)&pPVar2->NetlistLib);
            pcVar5 = MyStrdup(ratname,"AddNet");
            Menu->Name = pcVar5;
            pLVar4 = GetLibraryEntryMemory(Menu);
            pcVar5 = MyStrdup(name1,"AddNet");
            pLVar4->ListEntry = pcVar5;
            pLVar4 = GetLibraryEntryMemory(Menu);
            nodename = MyStrdup(nodename,"AddNet");
            pLVar4->ListEntry = nodename;
            Menu->flag = '\x01';
          }
          else {
            pLVar4 = GetLibraryEntryMemory(Menu);
            nodename = MyStrdup(name1,"AddNet");
            pLVar4->ListEntry = nodename;
            netnode_to_netname(name1);
          }
        }
        else {
          pLVar3 = netnode_to_netname(nodename);
          if (pLVar3 != (LibraryMenuTypePtr *)0x0) {
            Message("Both connections already in netlist - cannot merge nets\n");
            pRVar6 = (RatTypePtr *)0x0;
            goto LAB_080bf175;
          }
          pLVar4 = GetLibraryEntryMemory(Menu);
          pcVar5 = MyStrdup(nodename,"AddNet");
          pLVar4->ListEntry = pcVar5;
          netnode_to_netname(nodename);
        }
        hid_action("NetlistChanged");
        MakeFlags((FlagType *)&local_2c,0);
        pRVar6 = CreateNewRat(PCB->Data,Crosshair.AttachedLine.Point1.X,
                              Crosshair.AttachedLine.Point1.Y,Crosshair.AttachedLine.Point2.X,
                              Crosshair.AttachedLine.Point2.Y,local_154,local_158,
                              Settings.RatThickness,
                              (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
      }
      goto LAB_080bf175;
    }
  }
  Message("No pad/pin under rat line\n");
  pRVar6 = (RatTypePtr *)0x0;
LAB_080bf175:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pRVar6;
}



void __regparm3 TransferNet(NetListTypePtr *Netl,NetTypePtr *SourceNet,NetTypePtr *DestNet)

{
  int iVar1;
  ConnectionTypePtr *pCVar2;
  NetTypePtr *pNVar3;
  Cardinal CVar4;
  int iVar5;
  LocationType *pLVar6;
  
  iVar5 = SourceNet->ConnectionN - 1;
  if (iVar5 != -1) {
    iVar1 = SourceNet->ConnectionN * 0x1c;
    do {
      iVar5 = iVar5 + -1;
      pLVar6 = (LocationType *)((int)&SourceNet->Connection[-1].X + iVar1);
      pCVar2 = GetConnectionMemory(DestNet);
      pCVar2->X = *pLVar6;
      pCVar2->Y = pLVar6[1];
      pCVar2->type = pLVar6[2];
      pCVar2->ptr1 = (void *)pLVar6[3];
      pCVar2->ptr2 = (void *)pLVar6[4];
      pCVar2->group = pLVar6[5];
      pCVar2->menu = (LibraryMenuType *)pLVar6[6];
      iVar1 = iVar1 + -0x1c;
    } while (iVar5 != -1);
  }
  DestNet->Style = SourceNet->Style;
  FreeNetMemory(SourceNet);
  pNVar3 = Netl->Net;
  CVar4 = Netl->NetN - 1;
  Netl->NetN = CVar4;
  SourceNet->ConnectionN = pNVar3[CVar4].ConnectionN;
  SourceNet->ConnectionMax = pNVar3[CVar4].ConnectionMax;
  SourceNet->Connection = pNVar3[CVar4].Connection;
  SourceNet->Style = pNVar3[CVar4].Style;
  pNVar3 = Netl->Net + Netl->NetN;
  pNVar3->ConnectionN = 0;
  pNVar3->ConnectionMax = 0;
  pNVar3->Connection = (ConnectionTypePtr *)0x0;
  pNVar3->Style = (RouteStyleTypePtr)0x0;
  return;
}



Boolean __regparm3 GatherSubnets(NetListTypePtr *Netl,Boolean NoWarn,Boolean AndRats)

{
  uint *puVar1;
  NetTypePtr *pNVar2;
  LocationType LVar3;
  uint uVar4;
  LibraryMenuType *pLVar5;
  NetTypePtr *DestNet;
  ConnectionTypePtr *pCVar6;
  Cardinal CVar7;
  PCBTypePtr pPVar8;
  PointerListTypePtr_conflict *list;
  LibraryMenuType **ppLVar9;
  int iVar10;
  void **ppvVar11;
  char *pcVar12;
  LayerTypePtr Layer;
  DataTypePtr *pDVar13;
  byte bVar14;
  char *local_80;
  uint uVar15;
  void *pvVar16;
  uint uVar17;
  uint uVar18;
  int iVar19;
  PinTypePtr *pPVar20;
  undefined *puVar21;
  int iVar22;
  undefined *puVar23;
  byte local_49;
  int local_38;
  int local_30;
  uint local_28;
  uint local_24;
  uint local_20;
  
  local_49 = 0;
  uVar18 = Netl->NetN;
  uVar17 = 0;
joined_r0x080bf4d2:
  if ((uVar18 == 0) || (uVar18 <= uVar17)) {
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    return (Boolean)local_49;
  }
  uVar15 = uVar17 + 1;
  DestNet = Netl->Net + uVar17;
  ResetFoundPinsViasAndPads('\0');
  ResetFoundLinesAndPolygons('\0');
  pCVar6 = DestNet->Connection;
  local_80 = (char *)pCVar6->ptr2;
  RatFindHook(pCVar6->type,pCVar6->ptr1,local_80,local_80,'\0',AndRats);
  puVar1 = (uint *)((int)DestNet->Connection->ptr2 + 0x14);
  *puVar1 = *puVar1 & 0xffffefff;
  uVar18 = uVar15;
  if (uVar15 < Netl->NetN) {
    do {
      while( true ) {
        pNVar2 = Netl->Net;
        pvVar16 = (pNVar2[uVar18].Connection)->ptr2;
        uVar17 = *(uint *)((int)pvVar16 + 0x14);
        if ((uVar17 & 0x1000) == 0) break;
        *(uint *)((int)pvVar16 + 0x14) = uVar17 & 0xffffefff;
        TransferNet(Netl,pNVar2 + uVar18,DestNet);
        if (Netl->NetN < uVar18 || Netl->NetN == uVar18) goto LAB_080bf596;
      }
      uVar18 = uVar18 + 1;
    } while (uVar18 <= Netl->NetN && Netl->NetN != uVar18);
  }
LAB_080bf596:
  pDVar13 = PCB->Data;
  Layer = (LayerTypePtr)&pDVar13->field_0x4c;
  pPVar8 = PCB;
  if (pDVar13->LayerN != -2) {
    local_24 = 0;
    do {
      iVar19 = Layer->LineN - 1;
      if (iVar19 != -1) {
        iVar22 = Layer->LineN * 0x58 + -0x58;
        do {
          while ((pvVar16 = (void *)((int)&(Layer->Line->BoundingBox).X1 + iVar22),
                 (*(byte *)((int)pvVar16 + 0x15) & 0x10) == 0 ||
                 ((*(int *)((int)pvVar16 + 0x2c) != *(int *)((int)pvVar16 + 0x40) &&
                  (*(int *)((int)pvVar16 + 0x30) != *(int *)((int)pvVar16 + 0x44)))))) {
            iVar19 = iVar19 + -1;
            iVar22 = iVar22 + -0x58;
            pPVar8 = PCB;
            if (iVar19 == -1) goto LAB_080bf695;
          }
          iVar19 = iVar19 + -1;
          iVar22 = iVar22 + -0x58;
          pCVar6 = GetConnectionMemory(DestNet);
          LVar3 = *(LocationType *)((int)pvVar16 + 0x2c);
          *(LayerTypePtr *)&pCVar6->ptr1 = Layer;
          pCVar6->type = 4;
          pCVar6->ptr2 = pvVar16;
          pCVar6->X = LVar3;
          pCVar6->Y = *(LocationType *)((int)pvVar16 + 0x30);
          CVar7 = GetLayerGroupNumberByPointer(Layer);
          pCVar6->menu = (LibraryMenuType *)0x0;
          pCVar6->group = CVar7;
          pCVar6 = GetConnectionMemory(DestNet);
          LVar3 = *(LocationType *)((int)pvVar16 + 0x40);
          *(LayerTypePtr *)&pCVar6->ptr1 = Layer;
          pCVar6->type = 4;
          pCVar6->ptr2 = pvVar16;
          pCVar6->X = LVar3;
          pCVar6->Y = *(LocationType *)((int)pvVar16 + 0x44);
          CVar7 = GetLayerGroupNumberByPointer(Layer);
          pCVar6->menu = (LibraryMenuType *)0x0;
          pCVar6->group = CVar7;
          pPVar8 = PCB;
        } while (iVar19 != -1);
      }
LAB_080bf695:
      pDVar13 = pPVar8->Data;
      local_24 = local_24 + 1;
      if (pDVar13->LayerN + 2U <= local_24) goto LAB_080bf767;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_080bf6b6;
LAB_080bf767:
  Layer = (LayerTypePtr)&pDVar13->field_0x4c;
  if (pDVar13->LayerN != -2) {
    local_28 = 0;
    do {
      iVar19 = Layer->PolygonN - 1;
      if (iVar19 != -1) {
        puVar21 = &DAT_ffffffc4 + Layer->PolygonN * 0x3c;
        do {
          while (puVar23 = puVar21 + (int)&(Layer->Polygon->BoundingBox).X1,
                (puVar23[0x15] & 0x10) == 0) {
            iVar19 = iVar19 + -1;
            puVar21 = &DAT_ffffffc4 + (int)puVar21;
            pPVar8 = PCB;
            if (iVar19 == -1) goto LAB_080bf810;
          }
          iVar19 = iVar19 + -1;
          puVar21 = &DAT_ffffffc4 + (int)puVar21;
          pCVar6 = GetConnectionMemory(DestNet);
          iVar22 = *(int *)(puVar23 + 0x2c);
          *(LayerTypePtr *)&pCVar6->ptr1 = Layer;
          pCVar6->type = 8;
          *(undefined **)&pCVar6->ptr2 = puVar23;
          iVar22 = *(int *)(iVar22 + 8);
          pCVar6->X = *(LocationType *)(iVar22 + 0x2c);
          pCVar6->Y = *(LocationType *)(iVar22 + 0x30);
          CVar7 = GetLayerGroupNumberByPointer(Layer);
          pCVar6->menu = (LibraryMenuType *)0x0;
          pCVar6->group = CVar7;
          pPVar8 = PCB;
        } while (iVar19 != -1);
      }
LAB_080bf810:
      pDVar13 = pPVar8->Data;
      local_28 = local_28 + 1;
      if (pDVar13->LayerN + 2U <= local_28) break;
      Layer = Layer + 1;
    } while( true );
  }
LAB_080bf6b6:
  if (pDVar13->ViaN != 0) {
    uVar17 = 0;
    uVar18 = pDVar13->ViaN;
    do {
      pPVar20 = pDVar13->Via + uVar17;
      if ((*(byte *)((int)&(pPVar20->Flags).f + 1) & 0x10) == 0) {
        pDVar13 = pPVar8->Data;
        uVar4 = pDVar13->ViaN;
      }
      else {
        pCVar6 = GetConnectionMemory(DestNet);
        pCVar6->X = pPVar20->X;
        LVar3 = pPVar20->Y;
        pCVar6->type = 1;
        *(PinTypePtr **)&pCVar6->ptr1 = pPVar20;
        *(PinTypePtr **)&pCVar6->ptr2 = pPVar20;
        pCVar6->Y = LVar3;
        pCVar6->group = SLayer;
        pDVar13 = PCB->Data;
        uVar4 = pDVar13->ViaN;
        pPVar8 = PCB;
      }
    } while ((uVar4 != 0) &&
            (uVar17 = (uVar4 + 1 + uVar17) - uVar18, uVar18 = uVar4, uVar17 < uVar4));
  }
  if (NoWarn != '\0') goto LAB_080bf733;
  pLVar5 = DestNet->Connection->menu;
  list = (PointerListTypePtr_conflict *)MyCalloc(1,0xc,"CheckShorts");
  ppLVar9 = (LibraryMenuType **)GetPointerMemory(list);
  *ppLVar9 = pLVar5;
  pDVar13 = PCB->Data;
  local_30 = pDVar13->ElementN - 1;
  bVar14 = 0;
  if (local_30 != -1) {
    pPVar8 = PCB;
    bVar14 = NoWarn;
    iVar19 = pDVar13->ElementN * 300;
    do {
      local_38 = iVar19 + -300;
      iVar19 = (int)&pDVar13->Element[-1].BoundingBox.X1 + iVar19;
      if (*(uint *)(iVar19 + 0xe0) != 0) {
        uVar18 = 0;
        local_20 = *(uint *)(iVar19 + 0xe0);
        do {
          iVar22 = uVar18 * 0x4c + *(int *)(iVar19 + 0x100);
          pPVar8 = PCB;
          uVar17 = local_20;
          if ((*(byte *)(iVar22 + 0x15) & 0x10) != 0) {
            if (*(void **)(iVar22 + 0x48) == (void *)0x0) {
              local_80 = *(char **)(iVar22 + 0x40);
              if (local_80 == (char *)0x0) {
                local_80 = "(unknown)";
                pcVar12 = *(char **)(iVar19 + 0x94);
                if (pcVar12 != (char *)0x0) goto LAB_080bf9e7;
LAB_080bfa29:
                pcVar12 = "(unknown)";
              }
              else {
                if (*local_80 == '\0') {
                  local_80 = "(unknown)";
                }
                pcVar12 = *(char **)(iVar19 + 0x94);
                if (pcVar12 == (char *)0x0) goto LAB_080bfa29;
LAB_080bf9e7:
                if (*pcVar12 == '\0') {
                  pcVar12 = "(unknown)";
                }
              }
              Message("Warning! Net \"%s\" is shorted to %s pin %s\n",pLVar5->Name + 2,pcVar12,
                      local_80);
            }
            else {
              iVar10 = list->PtrN - 1;
              if (iVar10 != -1) {
                pvVar16 = list->Ptr[iVar10];
                ppvVar11 = list->Ptr + (list->PtrN - 2);
                while (*(void **)(iVar22 + 0x48) != pvVar16) {
                  iVar10 = iVar10 + -1;
                  if (iVar10 == -1) goto LAB_080bf919;
                  pvVar16 = *ppvVar11;
                  ppvVar11 = ppvVar11 + -1;
                }
                bVar14 = 1;
                goto joined_r0x080bf96a;
              }
LAB_080bf919:
              ppvVar11 = GetPointerMemory(list);
              *ppvVar11 = *(void **)(iVar22 + 0x48);
              Message("Warning! net \"%s\" is shorted to net \"%s\"\n",pLVar5->Name + 2,
                      **(int **)(iVar22 + 0x48) + 2);
            }
            bVar14 = 1;
            *(uint *)(iVar22 + 0x14) = *(uint *)(iVar22 + 0x14) | 0x200;
            uVar17 = *(uint *)(iVar19 + 0xe0);
            pPVar8 = PCB;
          }
joined_r0x080bf96a:
          PCB = pPVar8;
        } while ((uVar17 != 0) &&
                (uVar18 = (uVar18 + 1 + uVar17) - local_20, local_20 = uVar17, uVar18 < uVar17));
        pDVar13 = pPVar8->Data;
      }
      local_30 = local_30 + -1;
      if (local_30 == -1) goto LAB_080bfa52;
      pDVar13 = pPVar8->Data;
      iVar19 = local_38;
    } while( true );
  }
LAB_080bfa30:
  FreePointerListMemory(list);
  SaveFree(list);
  local_49 = local_49 | bVar14;
LAB_080bf733:
  uVar18 = Netl->NetN;
  uVar17 = uVar15;
  goto joined_r0x080bf4d2;
LAB_080bfa52:
  local_30 = pDVar13->ElementN - 1;
  if (local_30 != -1) {
    iVar19 = pDVar13->ElementN * 300;
    do {
      local_38 = iVar19 + -300;
      iVar19 = (int)&pDVar13->Element[-1].BoundingBox.X1 + iVar19;
      local_20 = 0;
      uVar18 = *(uint *)(iVar19 + 0xe8);
      uVar17 = uVar18;
      while ((uVar17 != 0 && (local_20 < uVar17))) {
        iVar22 = local_20 * 0x68 + *(int *)(iVar19 + 0x104);
        if ((*(byte *)(iVar22 + 0x15) & 0x10) != 0) {
          if (*(void **)(iVar22 + 100) == (void *)0x0) {
            local_80 = *(char **)(iVar22 + 0x5c);
            if (local_80 == (char *)0x0) {
              local_80 = "(unknown)";
              pcVar12 = *(char **)(iVar19 + 0x94);
              if (pcVar12 != (char *)0x0) goto LAB_080bfba7;
LAB_080bfbfe:
              pcVar12 = "(unknown)";
            }
            else {
              if (*local_80 == '\0') {
                local_80 = "(unknown)";
              }
              pcVar12 = *(char **)(iVar19 + 0x94);
              if (pcVar12 == (char *)0x0) goto LAB_080bfbfe;
LAB_080bfba7:
              if (*pcVar12 == '\0') {
                pcVar12 = "(unknown)";
              }
            }
            Message("Warning! Net \"%s\" is shorted  to %s pad %s\n",pLVar5->Name + 2,pcVar12,
                    local_80);
            bVar14 = 1;
            *(uint *)(iVar22 + 0x14) = *(uint *)(iVar22 + 0x14) | 0x200;
            uVar17 = *(uint *)(iVar19 + 0xe8);
          }
          else {
            iVar10 = list->PtrN - 1;
            if (iVar10 == -1) {
LAB_080bfafd:
              ppvVar11 = GetPointerMemory(list);
              *ppvVar11 = *(void **)(iVar22 + 100);
              Message("Warning! Net \"%s\" is shorted to net \"%s\"\n",pLVar5->Name + 2,
                      **(int **)(iVar22 + 100) + 2,local_80);
              bVar14 = 1;
              *(uint *)(iVar22 + 0x14) = *(uint *)(iVar22 + 0x14) | 0x200;
              uVar17 = *(uint *)(iVar19 + 0xe8);
            }
            else {
              pvVar16 = list->Ptr[iVar10];
              ppvVar11 = list->Ptr + (list->PtrN - 2);
              while (*(void **)(iVar22 + 100) != pvVar16) {
                iVar10 = iVar10 + -1;
                if (iVar10 == -1) goto LAB_080bfafd;
                pvVar16 = *ppvVar11;
                ppvVar11 = ppvVar11 + -1;
              }
              bVar14 = 1;
            }
          }
        }
        local_20 = local_20 + (uVar18 == uVar17);
      }
      local_30 = local_30 + -1;
      if (local_30 == -1) break;
      pDVar13 = PCB->Data;
      iVar19 = local_38;
    } while( true );
  }
  goto LAB_080bfa30;
}



Boolean SeekPad(LibraryEntryType *entry,ConnectionType *conn,Boolean Same)

{
  char *__s2;
  PadTypePtr *pPVar1;
  PinTypePtr *pPVar2;
  uint uVar3;
  Boolean BVar4;
  int iVar5;
  ElementTypePtr *pEVar6;
  int iVar7;
  Cardinal CVar8;
  LocationType LVar9;
  char cVar10;
  int iVar11;
  char *pcVar12;
  void *pvVar13;
  char *pcVar14;
  int in_GS_OFFSET;
  uint local_250;
  uint local_230;
  char PinNum [256];
  char ElementName [256];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  __s2 = entry->ListEntry;
  cVar10 = *__s2;
  if ((cVar10 == '-') || (cVar10 == '\0')) {
    iVar5 = 0;
  }
  else {
    iVar11 = 0;
    do {
      iVar5 = iVar11 + 1;
      ElementName[iVar11] = cVar10;
      cVar10 = __s2[iVar5];
      if (cVar10 == '-') goto LAB_080bfc79;
      iVar11 = iVar5;
    } while (cVar10 != '\0');
  }
  if (cVar10 != '-') {
    ElementName[iVar5] = '\0';
    Message("Bad net-list format encountered near: \"%s\"\n",ElementName);
    BVar4 = '\0';
    goto LAB_080bfe3d;
  }
LAB_080bfc79:
  pcVar12 = ElementName;
  if ((iVar5 != 0) && (pcVar12 = ElementName + iVar5, '`' < PinNum[iVar5 + 0xff])) {
    pcVar14 = ElementName + iVar5;
    iVar11 = iVar5;
    do {
      iVar11 = iVar11 + -1;
      pcVar12 = ElementName;
      if (iVar11 == 0) goto LAB_080bfcb0;
      pcVar12 = pcVar14 + -2;
      pcVar14 = pcVar14 + -1;
    } while ('`' < *pcVar12);
    pcVar12 = ElementName + iVar11;
  }
LAB_080bfcb0:
  *pcVar12 = '\0';
  cVar10 = __s2[iVar5 + 1];
  pcVar12 = PinNum;
  if (cVar10 != '\0') {
    iVar11 = 0;
    do {
      PinNum[iVar11] = cVar10;
      iVar11 = iVar11 + 1;
      cVar10 = __s2[iVar11 + iVar5 + 1];
    } while (cVar10 != '\0');
    pcVar12 = PinNum + iVar11;
  }
  *pcVar12 = '\0';
  if (PinNum[0] == '\0') {
    Message("Error! Netlist file is missing pin!\nwhite space after \"%s-\"\n",ElementName);
    badnet = '\x01';
  }
  else {
    iVar5 = 0;
    do {
      iVar11 = iVar5;
      iVar5 = iVar11 + 1;
    } while (PinNum[iVar11 + 1] != '\0');
    pEVar6 = SearchElementByName(PCB->Data,ElementName);
    if (pEVar6 != (ElementTypePtr *)0x0) {
      local_230 = pEVar6->PadN;
      if (local_230 != 0) {
        iVar5 = 0;
        local_250 = 0;
        pPVar1 = pEVar6->Pad;
        do {
          __s2 = *(char **)((int)&pPVar1->Number + iVar5);
          if (((__s2 != (char *)0x0) && (iVar7 = strcmp(PinNum,__s2), iVar7 == 0)) &&
             ((Same == '\0' || ((*(byte *)((int)&(pPVar1->Flags).f + iVar5 + 1) & 0x10) == 0)))) {
            conn->type = 0x200;
            pvVar13 = (void *)((int)&(pEVar6->Pad->BoundingBox).X1 + iVar5);
            conn->ptr2 = pvVar13;
            pPVar1 = pEVar6->Pad;
            CVar8 = SLayer;
            if (-1 < *(char *)((int)&(pPVar1->Flags).f + iVar5)) {
              CVar8 = CLayer;
            }
            conn->group = CVar8;
            if ((*(byte *)((int)pvVar13 + 0x15) & 0x40) == 0) {
              conn->X = *(LocationType *)((int)pvVar13 + 0x2c);
              LVar9 = *(LocationType *)((int)&(pPVar1->Point1).Y + iVar5);
            }
            else {
              conn->X = *(LocationType *)((int)pvVar13 + 0x40);
              LVar9 = *(LocationType *)((int)&(pPVar1->Point2).Y + iVar5);
            }
            conn->Y = LVar9;
            local_230 = pEVar6->PadN;
            break;
          }
          local_250 = local_250 + 1;
          iVar5 = iVar5 + 0x68;
        } while (local_250 < local_230);
        if (local_230 == local_250) goto LAB_080bff48;
LAB_080bfdee:
        *(ElementTypePtr **)&conn->ptr1 = pEVar6;
        BVar4 = '\x01';
        goto LAB_080bfe3d;
      }
LAB_080bff48:
      local_230 = pEVar6->PinN;
      if (local_230 != 0) {
        iVar5 = 0;
        local_250 = 0;
        pPVar2 = pEVar6->Pin;
        do {
          uVar3 = *(uint *)((int)&(pPVar2->Flags).f + iVar5);
          if (((((uVar3 & 8) == 0) &&
               (__s2 = *(char **)((int)&pPVar2->Number + iVar5), __s2 != (char *)0x0)) &&
              (iVar7 = strcmp(PinNum,__s2), iVar7 == 0)) &&
             ((Same == '\0' || ((uVar3 & 0x1000) == 0)))) {
            conn->type = 0x100;
            conn->ptr2 = (void *)((int)&(pEVar6->Pin->BoundingBox).X1 + iVar5);
            conn->group = SLayer;
            pPVar2 = pEVar6->Pin;
            conn->X = *(LocationType *)((int)&pPVar2->X + iVar5);
            conn->Y = *(LocationType *)((int)&pPVar2->Y + iVar5);
            local_230 = pEVar6->PinN;
            break;
          }
          local_250 = local_250 + 1;
          iVar5 = iVar5 + 0x4c;
        } while (local_250 < local_230);
        if (local_250 != local_230) goto LAB_080bfdee;
      }
    }
    BVar4 = '\0';
    if (Same != '\0') goto LAB_080bfe3d;
    if (9 < (byte)(PinNum[iVar11] - 0x30U)) {
      Message(
              "WARNING! Pin number ending with \'%c\' encountered in netlist file\nProbably a bad netlist file format\n"
              ,(int)PinNum[iVar11]);
    }
  }
  Message("Can\'t find %s pin %s called for in netlist.\n",ElementName,PinNum);
  BVar4 = '\0';
LAB_080bfe3d:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return BVar4;
}



NetListTypePtr * ProcNetlist(LibraryTypePtr net_menu)

{
  uint *puVar1;
  uint uVar2;
  char *__s2;
  char *__s1;
  PCBTypePtr pPVar3;
  NetListTypePtr *Wantlist;
  Boolean BVar4;
  uint uVar5;
  NetTypePtr *Net;
  undefined4 uVar6;
  ConnectionTypePtr *pCVar7;
  int iVar8;
  int iVar9;
  LibraryMenuType *pLVar10;
  PCBTypePtr pPVar11;
  int iVar12;
  int iVar13;
  LibraryEntryType *entry;
  int local_50;
  int local_4c;
  NetListTypePtr *local_48;
  int local_44;
  DataTypePtr *local_40;
  ConnectionType LastPoint;
  
  local_48 = (NetListTypePtr *)0x0;
  if (net_menu->MenuN != 0) {
    FreeNetListMemory(Wantlist);
    SaveFree(Wantlist);
    badnet = '\0';
    SLayer = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    CLayer = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
    local_48 = (NetListTypePtr *)MyCalloc(1,0xc,"ProcNetlist()");
    if (local_48 == (NetListTypePtr *)0x0) {
      local_40 = PCB->Data;
    }
    else {
      local_40 = PCB->Data;
      local_44 = local_40->ElementN - 1;
      Wantlist = local_48;
      if (local_44 != -1) {
        iVar13 = local_40->ElementN * 300;
        do {
          iVar8 = (int)&local_40->Element[-1].BoundingBox.X1 + iVar13;
          uVar2 = *(uint *)(iVar8 + 0xe0);
          if (uVar2 != 0) {
            iVar8 = *(int *)(iVar8 + 0x100);
            uVar5 = 0;
            *(undefined4 *)(iVar8 + 0x48) = 0;
            *(uint *)(iVar8 + 0x14) = *(uint *)(iVar8 + 0x14) & 0xffffefff;
            while (uVar5 = uVar5 + 1, uVar5 < uVar2) {
              iVar12 = iVar8 + uVar5 * 0x4c;
              puVar1 = (uint *)(iVar12 + 0x14);
              *puVar1 = *puVar1 & 0xffffefff;
              *(undefined4 *)(iVar12 + 0x48) = 0;
            }
          }
          local_44 = local_44 + -1;
          iVar13 = iVar13 + -300;
        } while (local_44 != -1);
        local_44 = local_40->ElementN - 1;
        if (local_44 != -1) {
          iVar13 = local_40->ElementN * 300;
          do {
            uVar5 = 0;
            iVar12 = (int)&local_40->Element[-1].BoundingBox.X1 + iVar13;
            iVar8 = 0;
            uVar2 = *(uint *)(iVar12 + 0xe8);
            while ((uVar2 != 0 && (uVar5 < uVar2))) {
              uVar5 = uVar5 + 1;
              iVar9 = *(int *)(iVar12 + 0x104) + iVar8;
              iVar8 = iVar8 + 0x68;
              puVar1 = (uint *)(iVar9 + 0x14);
              *puVar1 = *puVar1 & 0xffffefff;
              *(undefined4 *)(iVar9 + 100) = 0;
            }
            local_44 = local_44 + -1;
            iVar13 = iVar13 + -300;
          } while (local_44 != -1);
        }
      }
      local_4c = net_menu->MenuN - 1;
      if (local_4c != -1) {
        iVar13 = net_menu->MenuN * 0x1c;
        do {
          local_50 = iVar13 + -0x1c;
          pLVar10 = (LibraryMenuType *)((int)&net_menu->Menu[-1].Name + iVar13);
          if ((*pLVar10->Name == '*') || (pLVar10->flag == '\0')) {
            badnet = '\x01';
          }
          else {
            Net = GetNetMemory(local_48);
            pPVar3 = PCB;
            __s2 = pLVar10->Style;
            if (__s2 == (char *)0x0) {
              Net->Style = (RouteStyleTypePtr)0x0;
            }
            else {
              iVar13 = 0;
              pPVar11 = PCB;
              do {
                __s1 = pPVar11->RouteStyle[0].Name;
                if (__s1 != (char *)0x0) {
                  iVar8 = strcmp(__s1,__s2);
                  if (iVar8 == 0) {
                    *(RouteStyleType **)&Net->Style = pPVar3->RouteStyle + iVar13;
                    break;
                  }
                }
                iVar13 = iVar13 + 1;
                pPVar11 = (PCBTypePtr)&pPVar11->PrintFilename;
              } while (iVar13 != 4);
            }
            local_44 = pLVar10->EntryN - 1;
            if (local_44 != -1) {
              local_48 = (NetListTypePtr *)(pLVar10->EntryN * 0x18);
              do {
                local_48 = (NetListTypePtr *)(&DAT_ffffffe8 + (int)local_48);
                entry = (LibraryEntryType *)((int)&pLVar10->Entry->ListEntry + (int)local_48);
                BVar4 = SeekPad(entry,&LastPoint,'\0');
                if (BVar4 == '\0') {
                  badnet = '\x01';
                }
                else {
                  if ((*(byte *)((int)LastPoint.ptr2 + 0x15) & 0x10) == 0) goto LAB_080c0426;
                  if (LastPoint.type == 0x100) {
                    uVar6 = *(undefined4 *)((int)LastPoint.ptr2 + 0x40);
                  }
                  else {
                    uVar6 = *(undefined4 *)((int)LastPoint.ptr2 + 0x5c);
                  }
                  Message("Error! Element %s pin %s appears multiple times in the netlist file.\n",
                          *(undefined4 *)((int)LastPoint.ptr1 + 0x94),uVar6);
                }
                while (BVar4 = SeekPad(entry,&LastPoint,'\x01'), BVar4 != '\0') {
LAB_080c0426:
                  pCVar7 = GetConnectionMemory(Net);
                  pCVar7->X = LastPoint.X;
                  pCVar7->Y = LastPoint.Y;
                  pCVar7->type = LastPoint.type;
                  pCVar7->ptr1 = LastPoint.ptr1;
                  pCVar7->ptr2 = LastPoint.ptr2;
                  pCVar7->menu = pLVar10;
                  pCVar7->group = LastPoint.group;
                  *(uint *)((int)LastPoint.ptr2 + 0x14) =
                       *(uint *)((int)LastPoint.ptr2 + 0x14) | 0x1000;
                  if (LastPoint.type == 0x100) {
                    *(LibraryMenuType **)((int)LastPoint.ptr2 + 0x48) = pLVar10;
                  }
                  else {
                    *(LibraryMenuType **)((int)LastPoint.ptr2 + 100) = pLVar10;
                  }
                }
                local_44 = local_44 + -1;
              } while (local_44 != -1);
            }
          }
          local_4c = local_4c + -1;
          local_48 = Wantlist;
          iVar13 = local_50;
        } while (local_4c != -1);
        local_40 = PCB->Data;
      }
    }
    local_44 = local_40->ElementN - 1;
    if (local_44 != -1) {
      iVar13 = local_40->ElementN * 300;
      do {
        iVar8 = (int)&local_40->Element[-1].BoundingBox.X1 + iVar13;
        uVar2 = *(uint *)(iVar8 + 0xe0);
        if (uVar2 != 0) {
          iVar8 = *(int *)(iVar8 + 0x100);
          uVar5 = 0;
          puVar1 = (uint *)(iVar8 + 0x14);
          *puVar1 = *puVar1 & 0xffffefff;
          while (uVar5 = uVar5 + 1, uVar5 < uVar2) {
            puVar1 = (uint *)(iVar8 + 0x14 + uVar5 * 0x4c);
            *puVar1 = *puVar1 & 0xffffefff;
          }
        }
        local_44 = local_44 + -1;
        iVar13 = iVar13 + -300;
      } while (local_44 != -1);
      local_44 = local_40->ElementN - 1;
      if (local_44 != -1) {
        iVar13 = local_40->ElementN * 300;
        do {
          iVar8 = 0;
          uVar5 = 0;
          iVar12 = (int)&local_40->Element[-1].BoundingBox.X1 + iVar13;
          uVar2 = *(uint *)(iVar12 + 0xe8);
          while ((uVar2 != 0 && (uVar5 < uVar2))) {
            uVar5 = uVar5 + 1;
            iVar9 = *(int *)(iVar12 + 0x104) + iVar8;
            iVar8 = iVar8 + 0x68;
            puVar1 = (uint *)(iVar9 + 0x14);
            *puVar1 = *puVar1 & 0xffffefff;
          }
          local_44 = local_44 + -1;
          iVar13 = iVar13 + -300;
        } while (local_44 != -1);
        return local_48;
      }
    }
  }
  return local_48;
}



NetListListType * CollectSubnets(NetListListType *__return_storage_ptr__,Boolean SelectedOnly)

{
  NetListTypePtr *pNVar1;
  NetListTypePtr *Netlist;
  NetTypePtr *Net;
  ConnectionTypePtr *pCVar2;
  int *piVar3;
  LocationType *pLVar4;
  int iVar5;
  int iVar6;
  int local_3c;
  int local_38;
  NetListListType result;
  
  result.NetListN = 0;
  result.NetListMax = 0;
  result.NetList = (NetListTypePtr *)0x0;
  pNVar1 = ProcNetlist((LibraryTypePtr)&PCB->NetlistLib);
  if (pNVar1 == (NetListTypePtr *)0x0) {
    Message("Can\'t add rat lines because no netlist is loaded.\n");
  }
  else {
    InitConnectionLookup();
    SaveFindFlag(0x1000);
    local_3c = pNVar1->NetN - 1;
    if (local_3c != -1) {
      local_38 = (pNVar1->NetN + 0xfffffff) * 0x10;
      do {
        piVar3 = (int *)((int)&pNVar1->Net->ConnectionN + local_38);
        Netlist = GetNetListMemory((NetListListTypePtr *)&result);
        iVar5 = *piVar3 + -1;
        if (iVar5 != -1) {
          iVar6 = *piVar3 * 0x1c;
          do {
            iVar6 = iVar6 + -0x1c;
            pLVar4 = (LocationType *)(piVar3[2] + iVar6);
            if ((SelectedOnly == '\0') || ((*(byte *)(pLVar4[4] + 0x14) & 0x40) != 0)) {
              Net = GetNetMemory(Netlist);
              pCVar2 = GetConnectionMemory(Net);
              pCVar2->X = *pLVar4;
              pCVar2->Y = pLVar4[1];
              pCVar2->type = pLVar4[2];
              pCVar2->ptr1 = (void *)pLVar4[3];
              pCVar2->ptr2 = (void *)pLVar4[4];
              pCVar2->group = pLVar4[5];
              pCVar2->menu = (LibraryMenuType *)pLVar4[6];
              Net->Style = (RouteStyleTypePtr)piVar3[3];
            }
            iVar5 = iVar5 + -1;
          } while (iVar5 != -1);
        }
        GatherSubnets(Netlist,SelectedOnly,'\0');
        local_3c = local_3c + -1;
        local_38 = local_38 + -0x10;
      } while (local_3c != -1);
    }
    FreeConnectionLookupMemory();
    RestoreFindFlag();
  }
  __return_storage_ptr__->NetListN = result.NetListN;
  __return_storage_ptr__->NetListMax = result.NetListMax;
  __return_storage_ptr__->NetList = result.NetList;
  return __return_storage_ptr__;
}



Boolean AddAllRats(Boolean SelectedOnly,anon_subr_void *funcp)

{
  NetTypePtr *pNVar1;
  Boolean BVar2;
  int iVar3;
  ConnectionTypePtr *pCVar4;
  uint uVar5;
  NetTypePtr *pNVar6;
  RatTypePtr *Line;
  int *piVar7;
  int *piVar8;
  undefined1 *puVar9;
  LocationType *pLVar10;
  int *piVar11;
  int iVar12;
  int *piVar13;
  FlagType *pFVar14;
  ulong *puVar15;
  int in_GS_OFFSET;
  byte bVar16;
  FlagType in_stack_ffffff54;
  FlagType *local_90;
  NetTypePtr *local_8c;
  int *local_7c;
  int *local_78;
  int local_74;
  byte local_6d;
  anon_subr_void *local_6c;
  NetListTypePtr *local_68;
  Cardinal local_64;
  byte local_60;
  Boolean local_5f;
  byte local_5e;
  byte local_5d;
  int local_5c;
  NetListTypePtr *local_58;
  uint local_54;
  NetTypePtr *local_50;
  int local_4c;
  int local_48;
  NetTypePtr *local_44;
  int *local_40;
  bool local_39;
  PolygonTypePtr local_38;
  NetTypePtr *local_34;
  int local_30;
  FlagType local_2c;
  int local_20;
  
  bVar16 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_6c = funcp;
  local_5f = SelectedOnly;
  local_68 = ProcNetlist((LibraryTypePtr)&PCB->NetlistLib);
  if (local_68 == (NetListTypePtr *)0x0) {
    Message("Can\'t add rat lines because no netlist is loaded.\n");
    BVar2 = '\0';
    goto LAB_080c0c70;
  }
  InitConnectionLookup();
  SaveFindFlag(0x1000);
  local_58 = (NetListTypePtr *)MyCalloc(1,0xc,"AddAllRats()");
  local_5e = 0;
  local_60 = 0;
  local_64 = local_68->NetN;
  local_90 = &local_2c;
  local_5c = (local_64 + 0xfffffff) * 0x10;
  local_74 = (int)local_5f;
  while (local_64 = local_64 - 1, local_64 != 0xffffffff) {
    piVar7 = (int *)((int)&local_68->Net->ConnectionN + local_5c);
    iVar12 = *piVar7 + -1;
    if (iVar12 != -1) {
      iVar3 = *piVar7 * 0x1c;
      do {
        iVar3 = iVar3 + -0x1c;
        pLVar10 = (LocationType *)(piVar7[2] + iVar3);
        if ((local_5f == '\0') || ((*(byte *)(pLVar10[4] + 0x14) & 0x40) != 0)) {
          local_78 = piVar7;
          local_34 = GetNetMemory(local_58);
          pCVar4 = GetConnectionMemory(local_34);
          pCVar4->X = *pLVar10;
          pCVar4->Y = pLVar10[1];
          pCVar4->type = pLVar10[2];
          pCVar4->ptr1 = (void *)pLVar10[3];
          pCVar4->ptr2 = (void *)pLVar10[4];
          pCVar4->group = pLVar10[5];
          pCVar4->menu = (LibraryMenuType *)pLVar10[6];
          local_34->Style = (RouteStyleTypePtr)local_78[3];
          piVar7 = local_78;
        }
        iVar12 = iVar12 + -1;
      } while (iVar12 != -1);
    }
    local_6d = GatherSubnets(local_58,(Boolean)local_74,'\x01');
    uVar5 = local_58->NetN;
    if (uVar5 != 0) {
      if (uVar5 < 2) {
        local_58->NetN = 0;
        FreeNetMemory(local_58->Net);
        local_5d = 0;
      }
      else {
        local_44 = (NetTypePtr *)0x0;
        local_34 = (NetTypePtr *)0x0;
        local_5d = 0;
        do {
          pNVar6 = local_58->Net;
          local_50 = pNVar6;
          if (1 < uVar5) {
            local_40 = (int *)0x0;
            piVar7 = (int *)0x0;
            local_54 = 1;
            do {
              local_48 = local_50->ConnectionN - 1;
              pNVar1 = local_34;
              if (local_48 != -1) {
                local_4c = local_50->ConnectionN * 0x1c + -0x1c;
                local_34 = pNVar6 + local_54;
                do {
                  piVar13 = (int *)((int)&local_50->Connection->X + local_4c);
                  piVar8 = (int *)(local_34->ConnectionN - 1);
                  if (piVar8 != (int *)0xffffffff) {
                    iVar12 = local_34->ConnectionN * 0x1c + -0x1c;
LAB_080c0979:
                    do {
                      piVar11 = (int *)((int)&local_34->Connection->X + iVar12);
                      if ((((piVar13[2] != 8) ||
                           (local_38 = (PolygonTypePtr)piVar13[4], local_38 == (PolygonTypePtr)0x0))
                          || ((local_39 = (float)pNVar1 == 0.00000000, local_39 &&
                              ((piVar7 != (int *)0x0 && (piVar7[2] == 1)))))) ||
                         (local_8c = pNVar1, local_7c = piVar7, local_78 = piVar8,
                         BVar2 = IsPointInPolygonIgnoreHoles(*piVar11,piVar11[1],local_38),
                         piVar7 = local_7c, piVar8 = local_78, pNVar1 = local_8c, BVar2 == '\0')) {
                        pNVar6 = pNVar1;
                        if (((piVar11[2] != 8) ||
                            (local_38 = (PolygonTypePtr)piVar11[4], local_38 == (PolygonTypePtr)0x0)
                            ) || (((local_39 = (float)pNVar1 == 0.00000000, local_39 &&
                                   ((piVar7 != (int *)0x0 && (piVar7[2] == 1)))) ||
                                  (local_8c = pNVar1, local_7c = piVar7, local_78 = piVar8,
                                  BVar2 = IsPointInPolygonIgnoreHoles(*piVar13,piVar13[1],local_38),
                                  piVar7 = local_7c, piVar8 = local_78, pNVar6 = local_8c,
                                  BVar2 == '\0')))) {
                          local_30 = piVar13[1] - piVar11[1];
                          pNVar1 = (NetTypePtr *)
                                   ((float)local_30 * (float)local_30 +
                                   (float)(*piVar13 - *piVar11) * (float)(*piVar13 - *piVar11));
                          if (((float)pNVar1 < (float)pNVar6) || (piVar7 == (int *)0x0)) {
                            local_44 = local_34;
                            piVar8 = (int *)((int)piVar8 + -1);
                            iVar12 = iVar12 + -0x1c;
                            piVar7 = piVar13;
                            local_40 = piVar11;
                            if (piVar8 == (int *)0xffffffff) break;
                            goto LAB_080c0979;
                          }
                        }
                        else {
                          local_44 = local_34;
                          piVar7 = piVar13;
                          pNVar6 = (NetTypePtr *)0x0;
                          local_40 = piVar11;
                        }
                      }
                      else {
                        local_44 = local_34;
                        piVar7 = piVar11;
                        pNVar6 = (NetTypePtr *)0x0;
                        local_40 = piVar13;
                      }
                      pNVar1 = pNVar6;
                      piVar8 = (int *)((int)piVar8 + -1);
                      iVar12 = iVar12 + -0x1c;
                    } while (piVar8 != (int *)0xffffffff);
                  }
                  local_48 = local_48 + -1;
                  local_4c = local_4c + -0x1c;
                } while (local_48 != -1);
              }
              local_34 = pNVar1;
              local_54 = local_54 + 1;
              if (local_58->NetN <= local_54) goto LAB_080c0b05;
              pNVar6 = local_58->Net;
            } while( true );
          }
          local_40 = (int *)0x0;
          piVar7 = (int *)0x0;
LAB_080c0b05:
          if (local_6c == (anon_subr_void *)0x0) {
            MakeFlags(&local_2c,0);
            iVar12 = 3;
            pFVar14 = local_90;
            puVar15 = (ulong *)&stack0xffffff54;
            while (iVar12 != 0) {
              iVar12 = iVar12 + -1;
              *puVar15 = pFVar14->f;
              pFVar14 = (FlagType *)(&pFVar14->f + (uint)bVar16 * 0x3ffffffe + 1);
              puVar15 = puVar15 + (uint)bVar16 * 0x3ffffffe + 1;
            }
            Line = CreateNewRat(PCB->Data,*piVar7,piVar7[1],*local_40,local_40[1],piVar7[5],
                                local_40[5],Settings.RatThickness,in_stack_ffffff54);
            if (Line != (RatTypePtr *)0x0) {
              if ((float)local_34 == 0.00000000) {
                (Line->Flags).f = (Line->Flags).f | 2;
              }
              AddObjectToCreateUndoList(0x20,Line,Line,Line);
              DrawRat(Line,0);
              local_5d = 1;
            }
          }
          else {
            (*local_6c)(piVar7,local_40,local_50->Style);
          }
          TransferNet(local_58,local_44,local_50);
          uVar5 = local_58->NetN;
        } while (1 < uVar5);
        local_58->NetN = uVar5 - 1;
        FreeNetMemory(local_58->Net + (uVar5 - 1));
        if (local_5d != 0) {
          FreeConnectionLookupMemory();
          InitConnectionLookup();
          local_5d = 1;
        }
      }
      local_60 = local_60 | local_5d;
    }
    local_5e = local_5e | local_6d;
    local_5c = local_5c + -0x10;
  }
  FreeNetListMemory(local_58);
  SaveFree(local_58);
  FreeConnectionLookupMemory();
  RestoreFindFlag();
  if (local_6c == (anon_subr_void *)0x0) {
    if ((local_5e == 0) && (local_60 == 0)) {
LAB_080c0cc9:
      if (local_5f == '\0') {
        if ((PCB->Data->RatN != 0) || (badnet != '\0')) {
          Message(
                 "Nothing more to add, but there are\neither rat-lines in the layout, disabled nets\nin the net-list, or missing components\n"
                 );
          BVar2 = '\0';
          goto LAB_080c0c70;
        }
        Message("Congratulations!!\nThe layout is complete and has no shorted nets.\n");
      }
    }
    else {
      Draw();
      if (local_5e != 0) {
        Settings.RatWarn = '\x01';
      }
      if (local_60 != 0) {
        IncrementUndoSerialNumber();
        uVar5 = PCB->Data->RatN;
        if (uVar5 != 0) {
          puVar9 = &DAT_0814741b;
          if (1 < uVar5) {
            puVar9 = (undefined1 *)0x814736c;
          }
          Message("%d rat line%s remaining\n",uVar5,puVar9);
          BVar2 = '\x01';
          goto LAB_080c0c70;
        }
        goto LAB_080c0caa;
      }
      if (local_5e == 0) goto LAB_080c0cc9;
    }
    BVar2 = '\0';
  }
  else {
LAB_080c0caa:
    BVar2 = '\x01';
  }
LAB_080c0c70:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return BVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void * DestroyObject(DataTypePtr *Target,int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  DestroyTarget = Target;
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&DestroyFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



void * RemoveObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  void *pvVar1;
  
  pvVar1 = ObjectOperation((ObjectFunctionTypePtr *)&RemoveFunctions,Type,Ptr1,Ptr2,Ptr3);
  return pvVar1;
}



void * DestroyRat(RatTypePtr *Rat)

{
  RatTypePtr **ppRVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  RatTypePtr *pRVar6;
  Cardinal CVar7;
  RatTypePtr *pRVar8;
  BoxType *pBVar9;
  bool bVar10;
  byte bVar11;
  
  bVar11 = 0;
  if (DestroyTarget->rat_tree != (rtree_t *)0x0) {
    r_delete_entry(DestroyTarget->rat_tree,(BoxType *)Rat);
  }
  pDVar2 = DestroyTarget;
  ppRVar1 = &DestroyTarget->Rat;
  CVar7 = DestroyTarget->RatN - 1;
  DestroyTarget->RatN = CVar7;
  if (*ppRVar1 + CVar7 != Rat) {
    iVar3 = 0x17;
    pRVar6 = *ppRVar1 + CVar7;
    pRVar8 = Rat;
    while (iVar3 != 0) {
      iVar3 = iVar3 + -1;
      (pRVar8->BoundingBox).X1 = (pRVar6->BoundingBox).X1;
      pRVar6 = (RatTypePtr *)((int)pRVar6 + (uint)bVar11 * -8 + 4);
      pRVar8 = (RatTypePtr *)((int)pRVar8 + (uint)bVar11 * -8 + 4);
    }
    r_substitute(pDVar2->rat_tree,(BoxType *)(pDVar2->Rat + pDVar2->RatN),(BoxType *)Rat);
    CVar7 = DestroyTarget->RatN;
    pDVar2 = DestroyTarget;
  }
  pBVar9 = (BoxType *)((int)&pDVar2->Rat->BoundingBox + CVar7 * 0x5c);
  uVar5 = 0x5c;
  bVar10 = ((uint)pBVar9 & 1) != 0;
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 1);
    uVar5 = 0x5b;
  }
  if (((uint)pBVar9 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    uVar5 = uVar5 - 2;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  uVar4 = uVar5 >> 2;
  while (uVar4 != 0) {
    uVar4 = uVar4 - 1;
    pBVar9->X1 = 0;
    pBVar9 = (BoxType *)(&pBVar9->X1 + (uint)bVar11 * 0x3ffffffe + 1);
  }
  if ((uVar5 & 2) != 0) {
    *(undefined2 *)&pBVar9->X1 = 0;
    pBVar9 = (BoxType *)((int)&pBVar9->X1 + 2);
  }
  if (bVar10) {
    *(undefined *)&pBVar9->X1 = 0;
  }
  return (void *)0x0;
}



void * DestroyArc(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  Cardinal CVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  ArcTypePtr *pAVar5;
  ArcTypePtr *pAVar6;
  BoxType *pBVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  r_delete_entry(Layer->arc_tree,(BoxType *)Arc);
  CVar1 = Layer->ArcN - 1;
  Layer->ArcN = CVar1;
  if (Layer->Arc + CVar1 != Arc) {
    iVar2 = 0x11;
    pAVar5 = Layer->Arc + CVar1;
    pAVar6 = Arc;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (pAVar6->BoundingBox).X1 = (pAVar5->BoundingBox).X1;
      pAVar5 = (ArcTypePtr *)((int)pAVar5 + (uint)bVar9 * -8 + 4);
      pAVar6 = (ArcTypePtr *)((int)pAVar6 + (uint)bVar9 * -8 + 4);
    }
    r_substitute(Layer->arc_tree,(BoxType *)(Layer->Arc + Layer->ArcN),(BoxType *)Arc);
    CVar1 = Layer->ArcN;
  }
  pBVar7 = (BoxType *)((int)&Layer->Arc->BoundingBox + CVar1 * 0x44);
  uVar4 = 0x44;
  bVar8 = ((uint)pBVar7 & 1) != 0;
  if (bVar8) {
    *(undefined *)&pBVar7->X1 = 0;
    pBVar7 = (BoxType *)((int)&pBVar7->X1 + 1);
    uVar4 = 0x43;
  }
  if (((uint)pBVar7 & 2) != 0) {
    *(undefined2 *)&pBVar7->X1 = 0;
    uVar4 = uVar4 - 2;
    pBVar7 = (BoxType *)((int)&pBVar7->X1 + 2);
  }
  uVar3 = uVar4 >> 2;
  while (uVar3 != 0) {
    uVar3 = uVar3 - 1;
    pBVar7->X1 = 0;
    pBVar7 = (BoxType *)(&pBVar7->X1 + (uint)bVar9 * 0x3ffffffe + 1);
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)&pBVar7->X1 = 0;
    pBVar7 = (BoxType *)((int)&pBVar7->X1 + 2);
  }
  if (bVar8) {
    *(undefined *)&pBVar7->X1 = 0;
  }
  return (void *)0x0;
}



void * DestroyElement(ElementTypePtr *Element)

{
  ElementTypePtr **ppEVar1;
  TextType *after;
  rtree_t **pprVar2;
  PinTypePtr *pPVar3;
  DataTypePtr *pDVar4;
  rtree_t *rtree;
  Cardinal CVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  ElementTypePtr *pEVar9;
  int iVar10;
  ElementTypePtr *pEVar11;
  undefined *puVar12;
  bool bVar13;
  byte bVar14;
  
  bVar14 = 0;
  if (DestroyTarget->element_tree != (rtree_t *)0x0) {
    r_delete_entry(DestroyTarget->element_tree,(BoxType *)Element);
  }
  rtree = DestroyTarget->pin_tree;
  if ((rtree != (rtree_t *)0x0) && (Element->PinN != 0)) {
    uVar7 = 0;
    uVar6 = Element->PinN;
    while( true ) {
      r_delete_entry(rtree,(BoxType *)(Element->Pin + uVar7));
      uVar8 = Element->PinN;
      if ((uVar8 == 0) || (uVar7 = (uVar8 + 1 + uVar7) - uVar6, uVar8 <= uVar7)) break;
      rtree = DestroyTarget->pin_tree;
      uVar6 = uVar8;
    }
  }
  if (DestroyTarget->pad_tree != (rtree_t *)0x0) {
    uVar6 = Element->PadN;
    iVar10 = 0;
    uVar8 = 0;
    uVar7 = uVar6;
    while ((uVar7 != 0 && (uVar8 < uVar7))) {
      r_delete_entry(DestroyTarget->pad_tree,
                     (BoxType *)((int)&(Element->Pad->BoundingBox).X1 + iVar10));
      uVar7 = Element->PadN;
      if (uVar7 == uVar6) {
        uVar8 = uVar8 + 1;
        iVar10 = iVar10 + 0x68;
        uVar7 = uVar6;
      }
    }
  }
  iVar10 = 2;
  rtree = DestroyTarget->name_tree[2];
  while( true ) {
    if (rtree != (rtree_t *)0x0) {
      r_delete_entry(rtree,(BoxType *)(Element->Name + iVar10));
    }
    iVar10 = iVar10 + -1;
    if (iVar10 == -1) break;
    rtree = DestroyTarget->name_tree[iVar10];
  }
  FreeElementMemory(Element);
  pDVar4 = DestroyTarget;
  ppEVar1 = &DestroyTarget->Element;
  CVar5 = DestroyTarget->ElementN - 1;
  DestroyTarget->ElementN = CVar5;
  if (*ppEVar1 + CVar5 != Element) {
    iVar10 = 0x4b;
    pEVar9 = *ppEVar1 + CVar5;
    pEVar11 = Element;
    while (iVar10 != 0) {
      iVar10 = iVar10 + -1;
      (pEVar11->BoundingBox).X1 = (pEVar9->BoundingBox).X1;
      pEVar9 = (ElementTypePtr *)((int)pEVar9 + (uint)bVar14 * -8 + 4);
      pEVar11 = (ElementTypePtr *)((int)pEVar11 + (uint)bVar14 * -8 + 4);
    }
    r_substitute(pDVar4->element_tree,(BoxType *)(pDVar4->Element + pDVar4->ElementN),
                 (BoxType *)Element);
    pDVar4 = DestroyTarget;
  }
  uVar6 = Element->PinN;
  if (uVar6 != 0) {
    pPVar3 = Element->Pin;
    uVar7 = 0;
    *(ElementTypePtr **)&pPVar3->Element = Element;
    while (uVar7 = uVar7 + 1, uVar7 < uVar6) {
      *(ElementTypePtr **)&pPVar3[uVar7].Element = Element;
    }
  }
  uVar6 = Element->PadN;
  iVar10 = 0;
  uVar7 = 0;
  while ((uVar6 != 0 && (uVar7 < uVar6))) {
    uVar7 = uVar7 + 1;
    *(ElementTypePtr **)((int)&Element->Pad->Element + iVar10) = Element;
    iVar10 = iVar10 + 0x68;
  }
  puVar12 = (undefined *)0x78;
  iVar10 = 2;
  do {
    after = Element->Name + iVar10;
    pprVar2 = pDVar4->name_tree + iVar10;
    iVar10 = iVar10 + -1;
    r_substitute(*pprVar2,(BoxType *)
                          (puVar12 + (int)&pDVar4->Element[pDVar4->ElementN].Name[0].BoundingBox),
                 (BoxType *)after);
    *(ElementTypePtr **)(puVar12 + 0x38 + (int)(&Element->Name[0].Element + -0xe)) = Element;
    puVar12 = &DAT_ffffffc4 + (int)puVar12;
    pDVar4 = DestroyTarget;
  } while (iVar10 != -1);
  uVar6 = 300;
  pEVar9 = DestroyTarget->Element + DestroyTarget->ElementN;
  bVar13 = ((uint)pEVar9 & 1) != 0;
  if (bVar13) {
    *(undefined *)&(pEVar9->BoundingBox).X1 = 0;
    pEVar9 = (ElementTypePtr *)((int)&(pEVar9->BoundingBox).X1 + 1);
    uVar6 = 299;
  }
  if (((uint)pEVar9 & 2) != 0) {
    *(undefined2 *)&(pEVar9->BoundingBox).X1 = 0;
    uVar6 = uVar6 - 2;
    pEVar9 = (ElementTypePtr *)((int)&(pEVar9->BoundingBox).X1 + 2);
  }
  uVar7 = uVar6 >> 2;
  while (uVar7 != 0) {
    uVar7 = uVar7 - 1;
    (pEVar9->BoundingBox).X1 = 0;
    pEVar9 = (ElementTypePtr *)((int)pEVar9 + (uint)bVar14 * -8 + 4);
  }
  if ((uVar6 & 2) != 0) {
    *(undefined2 *)&(pEVar9->BoundingBox).X1 = 0;
    pEVar9 = (ElementTypePtr *)((int)&(pEVar9->BoundingBox).X1 + 2);
  }
  if (bVar13) {
    *(undefined *)&(pEVar9->BoundingBox).X1 = 0;
  }
  return (void *)0x0;
}



void * DestroyVia(PinTypePtr *Via)

{
  DataTypePtr *pDVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  PinTypePtr *pPVar5;
  Cardinal CVar6;
  PinTypePtr *pPVar7;
  BoxType *pBVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  r_delete_entry(DestroyTarget->via_tree,(BoxType *)Via);
  SaveFree(Via->Name);
  pDVar1 = DestroyTarget;
  Via->Name = (char *)0x0;
  CVar6 = pDVar1->ViaN - 1;
  pDVar1->ViaN = CVar6;
  if (pDVar1->Via + CVar6 != Via) {
    iVar2 = 0x13;
    pPVar5 = pDVar1->Via + CVar6;
    pPVar7 = Via;
    while (iVar2 != 0) {
      iVar2 = iVar2 + -1;
      (pPVar7->BoundingBox).X1 = (pPVar5->BoundingBox).X1;
      pPVar5 = (PinTypePtr *)((int)pPVar5 + (uint)bVar10 * -8 + 4);
      pPVar7 = (PinTypePtr *)((int)pPVar7 + (uint)bVar10 * -8 + 4);
    }
    r_substitute(pDVar1->via_tree,(BoxType *)(pDVar1->Via + pDVar1->ViaN),(BoxType *)Via);
    CVar6 = DestroyTarget->ViaN;
    pDVar1 = DestroyTarget;
  }
  pBVar8 = (BoxType *)((int)&pDVar1->Via->BoundingBox + CVar6 * 0x4c);
  uVar4 = 0x4c;
  bVar9 = ((uint)pBVar8 & 1) != 0;
  if (bVar9) {
    *(undefined *)&pBVar8->X1 = 0;
    pBVar8 = (BoxType *)((int)&pBVar8->X1 + 1);
    uVar4 = 0x4b;
  }
  if (((uint)pBVar8 & 2) != 0) {
    *(undefined2 *)&pBVar8->X1 = 0;
    uVar4 = uVar4 - 2;
    pBVar8 = (BoxType *)((int)&pBVar8->X1 + 2);
  }
  uVar3 = uVar4 >> 2;
  while (uVar3 != 0) {
    uVar3 = uVar3 - 1;
    pBVar8->X1 = 0;
    pBVar8 = (BoxType *)(&pBVar8->X1 + (uint)bVar10 * 0x3ffffffe + 1);
  }
  if ((uVar4 & 2) != 0) {
    *(undefined2 *)&pBVar8->X1 = 0;
    pBVar8 = (BoxType *)((int)&pBVar8->X1 + 2);
  }
  if (bVar9) {
    *(undefined *)&pBVar8->X1 = 0;
  }
  return (void *)0x0;
}



void * DestroyText(LayerTypePtr Layer,TextTypePtr Text)

{
  TextTypePtr pTVar1;
  uint uVar2;
  uint uVar3;
  Cardinal CVar4;
  BoxType *pBVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  SaveFree(Text->TextString);
  Text->TextString = (char *)0x0;
  r_delete_entry(Layer->text_tree,(BoxType *)Text);
  pTVar1 = Layer->Text;
  CVar4 = Layer->TextN - 1;
  Layer->TextN = CVar4;
  if (pTVar1 + CVar4 != Text) {
    (Text->BoundingBox).X1 = pTVar1[CVar4].BoundingBox.X1;
    (Text->BoundingBox).Y1 = pTVar1[CVar4].BoundingBox.Y1;
    (Text->BoundingBox).X2 = pTVar1[CVar4].BoundingBox.X2;
    (Text->BoundingBox).Y2 = pTVar1[CVar4].BoundingBox.Y2;
    Text->ID = pTVar1[CVar4].ID;
    (Text->Flags).f = pTVar1[CVar4].Flags.f;
    *(undefined4 *)(Text->Flags).t = *(undefined4 *)pTVar1[CVar4].Flags.t;
    *(undefined4 *)((Text->Flags).t + 4) = *(undefined4 *)(pTVar1[CVar4].Flags.t + 4);
    Text->net = pTVar1[CVar4].net;
    Text->Scale = pTVar1[CVar4].Scale;
    Text->X = pTVar1[CVar4].X;
    Text->Y = pTVar1[CVar4].Y;
    *(undefined4 *)&Text->Direction = *(undefined4 *)&pTVar1[CVar4].Direction;
    Text->TextString = pTVar1[CVar4].TextString;
    Text->Element = pTVar1[CVar4].Element;
    r_substitute(Layer->text_tree,(BoxType *)(Layer->Text + Layer->TextN),(BoxType *)Text);
    CVar4 = Layer->TextN;
  }
  pBVar5 = (BoxType *)((int)&Layer->Text->BoundingBox + CVar4 * 0x3c);
  uVar3 = 0x3c;
  bVar6 = ((uint)pBVar5 & 1) != 0;
  if (bVar6) {
    *(undefined *)&pBVar5->X1 = 0;
    pBVar5 = (BoxType *)((int)&pBVar5->X1 + 1);
    uVar3 = 0x3b;
  }
  if (((uint)pBVar5 & 2) != 0) {
    *(undefined2 *)&pBVar5->X1 = 0;
    uVar3 = uVar3 - 2;
    pBVar5 = (BoxType *)((int)&pBVar5->X1 + 2);
  }
  uVar2 = uVar3 >> 2;
  while (uVar2 != 0) {
    uVar2 = uVar2 - 1;
    pBVar5->X1 = 0;
    pBVar5 = (BoxType *)(&pBVar5->X1 + (uint)bVar7 * 0x3ffffffe + 1);
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)&pBVar5->X1 = 0;
    pBVar5 = (BoxType *)((int)&pBVar5->X1 + 2);
  }
  if (bVar6) {
    *(undefined *)&pBVar5->X1 = 0;
  }
  return (void *)0x0;
}



void * DestroyLine(LayerTypePtr Layer,LineTypePtr Line)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  LineTypePtr pLVar4;
  Cardinal CVar5;
  LineTypePtr pLVar6;
  BoxType *pBVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  r_delete_entry(Layer->line_tree,(BoxType *)Line);
  SaveFree(Line->Number);
  pLVar4 = Layer->Line;
  CVar5 = Layer->LineN - 1;
  Layer->LineN = CVar5;
  Line->Number = (char *)0x0;
  if (pLVar4 + CVar5 != Line) {
    iVar1 = 0x16;
    pLVar4 = pLVar4 + CVar5;
    pLVar6 = Line;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      (pLVar6->BoundingBox).X1 = (pLVar4->BoundingBox).X1;
      pLVar4 = (LineTypePtr)((int)pLVar4 + (uint)bVar9 * -8 + 4);
      pLVar6 = (LineTypePtr)((int)pLVar6 + (uint)bVar9 * -8 + 4);
    }
    r_substitute(Layer->line_tree,(BoxType *)(Layer->Line + Layer->LineN),(BoxType *)Line);
    CVar5 = Layer->LineN;
  }
  pBVar7 = (BoxType *)((int)&Layer->Line->BoundingBox + CVar5 * 0x58);
  uVar3 = 0x58;
  bVar8 = ((uint)pBVar7 & 1) != 0;
  if (bVar8) {
    *(undefined *)&pBVar7->X1 = 0;
    pBVar7 = (BoxType *)((int)&pBVar7->X1 + 1);
    uVar3 = 0x57;
  }
  if (((uint)pBVar7 & 2) != 0) {
    *(undefined2 *)&pBVar7->X1 = 0;
    uVar3 = uVar3 - 2;
    pBVar7 = (BoxType *)((int)&pBVar7->X1 + 2);
  }
  uVar2 = uVar3 >> 2;
  while (uVar2 != 0) {
    uVar2 = uVar2 - 1;
    pBVar7->X1 = 0;
    pBVar7 = (BoxType *)(&pBVar7->X1 + (uint)bVar9 * 0x3ffffffe + 1);
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)&pBVar7->X1 = 0;
    pBVar7 = (BoxType *)((int)&pBVar7->X1 + 2);
  }
  if (bVar8) {
    *(undefined *)&pBVar7->X1 = 0;
  }
  return (void *)0x0;
}



void * DestroyPolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  PolygonTypePtr ppVar1;
  uint uVar2;
  uint uVar3;
  Cardinal CVar4;
  BoxType *pBVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
  FreePolygonMemory(Polygon);
  ppVar1 = Layer->Polygon;
  CVar4 = Layer->PolygonN - 1;
  Layer->PolygonN = CVar4;
  if (ppVar1 + CVar4 != Polygon) {
    (Polygon->BoundingBox).X1 = ppVar1[CVar4].BoundingBox.X1;
    (Polygon->BoundingBox).Y1 = ppVar1[CVar4].BoundingBox.Y1;
    (Polygon->BoundingBox).X2 = ppVar1[CVar4].BoundingBox.X2;
    (Polygon->BoundingBox).Y2 = ppVar1[CVar4].BoundingBox.Y2;
    Polygon->ID = ppVar1[CVar4].ID;
    (Polygon->Flags).f = ppVar1[CVar4].Flags.f;
    *(undefined4 *)(Polygon->Flags).t = *(undefined4 *)ppVar1[CVar4].Flags.t;
    *(undefined4 *)((Polygon->Flags).t + 4) = *(undefined4 *)(ppVar1[CVar4].Flags.t + 4);
    Polygon->net = ppVar1[CVar4].net;
    Polygon->PointN = ppVar1[CVar4].PointN;
    Polygon->PointMax = ppVar1[CVar4].PointMax;
    Polygon->Clipped = ppVar1[CVar4].Clipped;
    Polygon->NoHoles = ppVar1[CVar4].NoHoles;
    Polygon->NoHolesValid = ppVar1[CVar4].NoHolesValid;
    Polygon->Points = ppVar1[CVar4].Points;
    r_substitute(Layer->polygon_tree,(BoxType *)(Layer->Polygon + Layer->PolygonN),
                 (BoxType *)Polygon);
    CVar4 = Layer->PolygonN;
  }
  pBVar5 = (BoxType *)((int)&Layer->Polygon->BoundingBox + CVar4 * 0x3c);
  uVar3 = 0x3c;
  bVar6 = ((uint)pBVar5 & 1) != 0;
  if (bVar6) {
    *(undefined *)&pBVar5->X1 = 0;
    pBVar5 = (BoxType *)((int)&pBVar5->X1 + 1);
    uVar3 = 0x3b;
  }
  if (((uint)pBVar5 & 2) != 0) {
    *(undefined2 *)&pBVar5->X1 = 0;
    uVar3 = uVar3 - 2;
    pBVar5 = (BoxType *)((int)&pBVar5->X1 + 2);
  }
  uVar2 = uVar3 >> 2;
  while (uVar2 != 0) {
    uVar2 = uVar2 - 1;
    pBVar5->X1 = 0;
    pBVar5 = (BoxType *)(&pBVar5->X1 + (uint)bVar7 * 0x3ffffffe + 1);
  }
  if ((uVar3 & 2) != 0) {
    *(undefined2 *)&pBVar5->X1 = 0;
    pBVar5 = (BoxType *)((int)&pBVar5->X1 + 2);
  }
  if (bVar6) {
    *(undefined *)&pBVar5->X1 = 0;
  }
  return (void *)0x0;
}



void * RemoveRat(RatTypePtr *Rat)

{
  if (PCB->RatOn != '\0') {
    EraseRat(Rat);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(0x20,Rat,Rat,Rat);
  return (void *)0x0;
}



Boolean DeleteRats(Boolean selected)

{
  RatTypePtr *Rat;
  char cVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  int iVar4;
  
  Bulk = '\x01';
  pDVar2 = PCB->Data;
  iVar3 = pDVar2->RatN - 1;
  if (iVar3 == -1) {
    Bulk = '\0';
    cVar1 = '\0';
  }
  else {
    cVar1 = '\0';
    iVar4 = pDVar2->RatN * 0x5c;
    while( true ) {
      Rat = (RatTypePtr *)((int)&pDVar2->Rat[-1].BoundingBox.X1 + iVar4);
      if ((selected == '\0') || ((*(byte *)&(Rat->Flags).f & 0x40) != 0)) {
        RemoveRat(Rat);
        cVar1 = '\x01';
      }
      iVar3 = iVar3 + -1;
      if (iVar3 == -1) break;
      pDVar2 = PCB->Data;
      iVar4 = iVar4 + -0x5c;
    }
    Bulk = '\0';
    if (cVar1 != '\0') {
      Draw();
      IncrementUndoSerialNumber();
      cVar1 = '\x01';
    }
  }
  return (Boolean)cVar1;
}



void * RemovePolygon(LayerTypePtr Layer,PolygonTypePtr Polygon)

{
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(8,Layer,Polygon,Polygon);
  return (void *)0x0;
}



void * DestroyPolygonPoint(LayerTypePtr Layer,PolygonTypePtr Polygon,PointTypePtr Point)

{
  Cardinal CVar1;
  PointTypePtr pPVar2;
  PointTypePtr pPVar3;
  PointTypePtr pPVar4;
  void *pvVar5;
  
  if (3 < Polygon->PointN) {
    r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
    CVar1 = Polygon->PointN;
    pPVar2 = Polygon->Points;
    pPVar4 = Point + 1;
    while (pPVar3 = pPVar4, pPVar3 != pPVar2 + CVar1) {
      Point->X = pPVar3->X;
      Point->Y = pPVar3->Y;
      Point->X2 = pPVar3->X2;
      Point->Y2 = pPVar3->Y2;
      Point->ID = pPVar3->ID;
      pPVar4 = pPVar3 + 1;
      Point = pPVar3;
    }
    Polygon->PointN = CVar1 - 1;
    SetPolygonBoundingBox(Polygon);
    r_insert_entry(Layer->polygon_tree,(BoxType *)Polygon,0);
    InitClip(PCB->Data,Layer,(PolygonType *)Polygon);
    return Polygon;
  }
  pvVar5 = RemovePolygon(Layer,Polygon);
  return pvVar5;
}



void * RemovePolygonPoint(LayerTypePtr Layer,PolygonTypePtr Polygon,PointTypePtr Point)

{
  PointTypePtr pPVar1;
  PointTypePtr pPVar2;
  PointTypePtr pPVar3;
  void *pvVar4;
  Cardinal index;
  uint uVar5;
  
  uVar5 = Polygon->PointN;
  if (uVar5 < 4) {
    pvVar4 = RemovePolygon(Layer,Polygon);
    return pvVar4;
  }
  if (Layer->On != '\0') {
    ErasePolygon(Polygon);
    uVar5 = Polygon->PointN;
  }
  index = uVar5 - 1;
  if (index == 0xffffffff) {
LAB_080c18d6:
    index = 0;
  }
  else {
    pPVar3 = Polygon->Points + (uVar5 - 2);
    pPVar1 = Polygon->Points + index;
    while (pPVar2 = pPVar3, pPVar1 != Point) {
      index = index - 1;
      if (index == 0xffffffff) goto LAB_080c18d6;
      pPVar3 = pPVar2 + -1;
      pPVar1 = pPVar2;
    }
  }
  AddObjectToRemovePointUndoList(0x800,Layer,Polygon,index);
  r_delete_entry(Layer->polygon_tree,(BoxType *)Polygon);
  index = Polygon->PointN;
  pPVar1 = Polygon->Points;
  pPVar3 = Point + 1;
  while (pPVar2 = pPVar3, pPVar2 != pPVar1 + index) {
    Point->X = pPVar2->X;
    Point->Y = pPVar2->Y;
    Point->X2 = pPVar2->X2;
    Point->Y2 = pPVar2->Y2;
    Point->ID = pPVar2->ID;
    pPVar3 = pPVar2 + 1;
    Point = pPVar2;
  }
  Polygon->PointN = index - 1;
  SetPolygonBoundingBox(Polygon);
  r_insert_entry(Layer->polygon_tree,(BoxType *)Polygon,0);
  RemoveExcessPolygonPoints(Layer,Polygon);
  InitClip(PCB->Data,Layer,(PolygonType *)Polygon);
  if ((Layer->On != '\0') && (DrawPolygon(Layer,Polygon,0), Bulk == '\0')) {
    Draw();
  }
  return (void *)0x0;
}



int remove_point(BoxType *b,void *cl)

{
  int *piVar1;
  
  if (*(BoxType **)((int)cl + 0x9c) != b) {
    piVar1 = *(int **)((int)cl + 0xa0);
    if ((b[2].Y2 == *piVar1) && (b[3].X1 == piVar1[1])) {
      *(BoxType **)((int)cl + 0x9c) = b;
      *(LocationType **)((int)cl + 0xa0) = &b[2].Y2;
                    // WARNING: Subroutine does not return
      __longjmp_chk(cl,1);
    }
    if ((*piVar1 == b[4].X1) && (b[4].Y1 == piVar1[1])) {
      *(BoxType **)((int)cl + 0x9c) = b;
      *(BoxType **)((int)cl + 0xa0) = b + 4;
                    // WARNING: Subroutine does not return
      __longjmp_chk(cl,1);
    }
  }
  return 0;
}



void * RemoveVia(PinTypePtr *Via)

{
  if (PCB->ViaOn != '\0') {
    EraseVia(Via);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(1,Via,Via,Via);
  return (void *)0x0;
}



Boolean RemoveSelected(void)

{
  Boolean BVar1;
  
  Bulk = '\x01';
  BVar1 = SelectedOperation((ObjectFunctionTypePtr *)&RemoveFunctions,'\0',-1);
  if (BVar1 == '\0') {
    Bulk = '\0';
    return '\0';
  }
  IncrementUndoSerialNumber();
  Draw();
  Bulk = '\0';
  return '\x01';
}



void * RemoveElement(ElementTypePtr *Element)

{
  if (((PCB->ElementOn != '\0') || (PCB->PinOn != '\0')) &&
     ((((Element->Flags).f >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (PCB->InvisibleObjectsOn != '\0')))) {
    EraseElement(Element);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(2,Element,Element,Element);
  return (void *)0x0;
}



void * RemoveText(LayerTypePtr Layer,TextTypePtr Text)

{
  if (Layer->On != '\0') {
    EraseText(Layer,Text);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(0x10,Layer,Text,Text);
  return (void *)0x0;
}



void * RemoveArc(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  if (Layer->On != '\0') {
    EraseArc(Arc);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(0x4000,Layer,Arc,Arc);
  return (void *)0x0;
}



void * RemoveLine(LayerTypePtr Layer,LineTypePtr Line)

{
  if (Layer->On != '\0') {
    EraseLine(Line);
    if (Bulk == '\0') {
      Draw();
    }
  }
  MoveObjectToRemoveUndoList(4,Layer,Line,Line);
  return (void *)0x0;
}



void * RemoveLinePoint(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr Point)

{
  int iVar1;
  void *pvVar2;
  LocationType local_c4;
  LocationType local_c0;
  rlp_info info;
  
  if (&Line->Point1 == (PointType *)Point) {
    local_c4 = (Line->Point2).X;
    local_c0 = (Line->Point2).Y;
  }
  else {
    local_c4 = (Line->Point1).X;
    local_c0 = (Line->Point1).Y;
  }
  info.line = Line;
  info.point = Point;
  iVar1 = _setjmp((__jmp_buf_tag *)&info);
  if (iVar1 != 0) {
    MoveObject(0x1000,Layer,info.line,info.point,local_c4 - Point->X,local_c0 - Point->Y);
    pvVar2 = RemoveLine(Layer,Line);
    return pvVar2;
  }
  r_search(Layer->line_tree,(BoxType *)Point,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,remove_point,
           &info);
  pvVar2 = RemoveLine(Layer,Line);
  return pvVar2;
}



void RemovePCB(PCBTypePtr Ptr)

{
  ClearUndoList('\x01');
  FreePCBMemory(Ptr);
  SaveFree(Ptr);
  return;
}



double __regparm3 XYtoNetLength(int x,int y,int *found)

{
  int iVar1;
  int iVar2;
  DataTypePtr *pDVar3;
  uint uVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  PCBTypePtr pPVar8;
  int iVar9;
  byte *pbVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  uint local_28;
  
  *found = 0;
  LookupConnection(x,y,'\x01',(int)ROUND(PCB->Grid),4);
  pPVar8 = PCB;
  iVar13 = &PCB->Data->field_0x4c;
  if (PCB->Data->LayerN == -2) {
    return 0.00000000;
  }
  local_28 = 0;
  dVar5 = 0.00000000;
  do {
    iVar9 = *(int *)(iVar13 + 4) + -1;
    if (iVar9 != -1) {
      iVar11 = *(int *)(iVar13 + 4) * 0x58 + -0x58;
      do {
        while (iVar12 = *(int *)(iVar13 + 0x24) + iVar11, (*(byte *)(iVar12 + 0x14) & 4) != 0) {
          iVar9 = iVar9 + -1;
          iVar11 = iVar11 + -0x58;
          iVar1 = *(int *)(iVar12 + 0x30);
          iVar2 = *(int *)(iVar12 + 0x44);
          dVar6 = (double)(*(int *)(iVar12 + 0x2c) - *(int *)(iVar12 + 0x40));
          *found = 1;
          dVar7 = (double)(iVar1 - iVar2);
          dVar5 = SQRT(dVar7 * dVar7 + dVar6 * dVar6) + dVar5;
          if (iVar9 == -1) goto LAB_080c1eed;
        }
        iVar9 = iVar9 + -1;
        iVar11 = iVar11 + -0x58;
      } while (iVar9 != -1);
    }
LAB_080c1eed:
    local_28 = local_28 + 1;
    pDVar3 = pPVar8->Data;
    if (pDVar3->LayerN + 2U <= local_28) {
      iVar13 = &pDVar3->field_0x4c;
      if (pDVar3->LayerN == -2) {
        return dVar5;
      }
      local_28 = 0;
      while( true ) {
        iVar9 = *(int *)(iVar13 + 0x10) + -1;
        if (iVar9 != -1) {
          pbVar10 = &DAT_ffffffd0 + *(int *)(iVar13 + 0x10) * 0x44 + *(int *)(iVar13 + 0x30);
          do {
            if ((*pbVar10 & 4) != 0) {
              iVar12 = *(int *)(pbVar10 + 0x2c);
              uVar4 = *(uint *)(pbVar10 + 0x2c);
              iVar11 = *(int *)(pbVar10 + 0x18);
              *found = 1;
              dVar5 = ((double)((uVar4 ^ iVar12 >> 0x1f) - (iVar12 >> 0x1f)) *
                      (double)iVar11 * 6.28318531) / 360.00000000 + dVar5;
            }
            iVar9 = iVar9 + -1;
            pbVar10 = pbVar10 + -0x44;
          } while (iVar9 != -1);
        }
        local_28 = local_28 + 1;
        if (pDVar3->LayerN + 2U <= local_28) break;
        iVar13 = iVar13 + 0x5c;
      }
      return dVar5;
    }
    iVar13 = iVar13 + 0x5c;
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x080c3330)
// WARNING: Removing unreachable block (ram,0x080c3327)
// WARNING: Removing unreachable block (ram,0x080c3332)

int ReportDialog(int argc,char **argv,int x,int y)

{
  int iVar1;
  byte bVar2;
  BDimension BVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  LocationType LVar9;
  LocationType LVar10;
  LocationType LVar11;
  LocationType LVar12;
  LocationType LVar13;
  LocationType LVar14;
  long lVar15;
  LocationType LVar16;
  LocationType LVar17;
  float fVar18;
  float fVar19;
  double dVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  int iVar25;
  int iVar26;
  ArcTypePtr *pAVar27;
  char *local_970;
  BoxTypePtr pBVar28;
  char *pcVar29;
  ArcTypePtr *pAVar30;
  int iVar31;
  char *pcVar32;
  char *local_968;
  undefined1 *puVar33;
  TextTypePtr pTVar34;
  undefined1 *puVar35;
  rtree_t *prVar36;
  undefined1 *puVar37;
  int in_GS_OFFSET;
  bool bVar38;
  long local_96c;
  LocationType local_964;
  LocationType local_960;
  undefined8 local_95c;
  int local_954;
  undefined1 *local_880;
  undefined1 *local_87c;
  undefined1 *local_878;
  undefined1 *local_874;
  undefined1 *local_870;
  undefined1 *local_86c;
  undefined1 *local_868;
  undefined1 *local_864;
  undefined1 *local_860;
  undefined1 *local_85c;
  undefined1 *local_858;
  void *ptr3;
  ArcTypePtr *local_848;
  LayerTypePtr local_844;
  char report [2048];
  char laynum [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar25 = SearchScreen(x,y,0x5f3f,&local_844,&local_848,&ptr3);
  if (iVar25 == 0) {
    iVar25 = SearchScreen(x,y,0x15f3f,&local_844,&local_848,&ptr3);
    iVar26 = iVar25 + -0x20;
    bVar38 = iVar26 == 0;
    if (bVar38) goto LAB_080c22f1;
LAB_080c202e:
    if (!bVar38 && SBORROW4(iVar25,0x20) == iVar26 < 0) {
      if (iVar25 == 0x400) {
LAB_080c2558:
        if (iVar25 == 0x10) {
          iVar26 = GetLayerNumber(PCB->Data,local_844);
          __sprintf_chk(laynum,1,0x20,"is on layer %d",iVar26);
        }
        pcVar32 = "";
        local_960 = (local_848->BoundingBox).Y2;
        if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
          pcVar32 = "It is LOCKED\n";
        }
        local_968 = "is an element name.";
        if (iVar25 == 0x10) {
          local_968 = laynum;
        }
        local_964 = (local_848->BoundingBox).X2;
        LVar9 = (local_848->BoundingBox).Y1;
        LVar10 = (local_848->BoundingBox).X1;
        LVar11 = local_848->X;
        bVar2 = *(byte *)&local_848->Height;
        if (Settings.grid_units_mm == '\0') {
          local_858 = &DAT_08147f6c;
          dVar20 = ((double)local_848->Thickness * 0.45000000 * 100.00000000) / 100.00000000;
        }
        else {
          local_858 = &DAT_0815627e;
          dVar20 = (((double)local_848->Thickness * 0.45000000 * 100.00000000) / 100000.00000000) *
                   25.40000000;
        }
        LVar12 = local_848->Width;
        BVar3 = local_848->Clearance;
        local_970 = flags_to_string(local_848->Flags,0x10);
        __sprintf_chk(report,1,0x800,
                                            
                      "TEXT ID# %ld   Flags:%s\nLocated at (X,Y) = (%d,%d)\nCharacters are %0.2f %s tall\nValue is \"%s\"\nDirection is %d\nThe bounding box is (%d,%d) (%d, %d)\nIt %s\n%s"
                      ,local_848->ID,local_970,BVar3,LVar12,dVar20,local_858,LVar11,(uint)bVar2,
                      LVar10,LVar9,local_964,local_960,local_968,pcVar32);
      }
      else {
        if (iVar25 < 0x401) {
          if (iVar25 == 0x100) {
            if (local_844[2].Text != (TextTypePtr)0x0) {
              pAVar27 = (ArcTypePtr *)local_844[2].Color;
              pTVar34 = (TextTypePtr)&DAT_00000001;
              if (local_848 != pAVar27) {
                while ((pTVar34 < local_844[2].Text &&
                       (pAVar27 = (ArcTypePtr *)&pAVar27[1].BoundingBox.X2, pAVar27 != local_848)))
                {
                  pTVar34 = (TextTypePtr)((int)&(pTVar34->BoundingBox).X1 + 1);
                }
              }
            }
            uVar8 = (local_848->Flags).f;
            if ((uVar8 & 8) == 0) {
              prVar36 = local_844[1].text_tree;
              pcVar32 = "It is LOCKED\n";
              puVar35 = (undefined1 *)local_848->StartAngle;
              if ((uVar8 & 0x2000) == 0) {
                pcVar32 = "";
              }
              puVar33 = (undefined1 *)local_848->Delta;
              if (puVar33 == (undefined1 *)0x0) {
                puVar33 = &DAT_0814741b;
              }
              if (prVar36 == (rtree_t *)0x0) {
                prVar36 = (rtree_t *)&DAT_0814741b;
              }
              if (puVar35 == (undefined1 *)0x0) {
                puVar35 = &DAT_0814741b;
              }
              if (Settings.grid_units_mm == '\0') {
                iVar25 = local_848->Thickness;
                local_868 = &DAT_08147f6c;
                local_86c = &DAT_08147f6c;
                local_870 = &DAT_08147f6c;
                local_874 = &DAT_08147f6c;
                fVar24 = (float)((local_848->Width - iVar25) / 2) / 100.00000000;
                local_864 = &DAT_08147f6c;
                local_860 = &DAT_08147f6c;
                fVar23 = (float)local_848->Width / 100.00000000;
                fVar22 = (float)((iVar25 - local_848->Height) / 2) / 100.00000000;
                fVar21 = ((float)local_848->Clearance * 0.50000000) / 100.00000000;
                fVar19 = (float)local_848->Height / 100.00000000;
                fVar18 = 100.00000000 / (float)iVar25;
              }
              else {
                iVar25 = local_848->Thickness;
                local_868 = &DAT_0815627e;
                local_86c = &DAT_0815627e;
                local_870 = &DAT_0815627e;
                local_874 = &DAT_0815627e;
                local_864 = &DAT_0815627e;
                local_860 = &DAT_0815627e;
                fVar24 = ((float)((local_848->Width - iVar25) / 2) / 100000.00000000) * 25.39999962;
                fVar23 = ((float)local_848->Width / 100000.00000000) * 25.39999962;
                fVar22 = ((float)((iVar25 - local_848->Height) / 2) / 100000.00000000) * 25.39999962
                ;
                fVar21 = (((float)local_848->Clearance * 0.50000000) / 100000.00000000) *
                         25.39999962;
                fVar19 = ((float)local_848->Height / 100000.00000000) * 25.39999962;
                fVar18 = (100000.00000000 / (float)iVar25) * 25.39999962;
              }
              local_960 = local_848->Y;
              local_964 = local_848->X;
              local_968 = flags_to_string(local_848->Flags,0x100);
              __sprintf_chk(report,1,0x800,
                                                        
                            "PIN ID# %ld   Flags:%s\n(X,Y) = (%d, %d)\nCopper width = %0.2f %s  Drill width = %0.2f %s\nClearance width to Polygon = %0.2f %s\nAnnulus = %0.2f %s\nSolder mask hole = %0.2f %s (gap = %0.2f %s)\nName = \"%s\"\nIt is owned by element %s\nAs pin number %s\n%s"
                            ,local_848->ID,local_968,local_964,local_960,(double)fVar18,local_860,
                            SUB84((double)fVar19,0),(int)((ulonglong)(double)fVar19 >> 0x20),
                            local_864,SUB84((double)fVar21,0),
                            (int)((ulonglong)(double)fVar21 >> 0x20),local_868,
                            SUB84((double)fVar22,0),(int)((ulonglong)(double)fVar22 >> 0x20),
                            local_86c,SUB84((double)fVar23,0),
                            (int)((ulonglong)(double)fVar23 >> 0x20),local_870,(double)fVar24,
                            local_874,puVar35,prVar36,puVar33,pcVar32);
            }
            else {
              prVar36 = local_844[1].text_tree;
              pcVar32 = "It is LOCKED\n";
              if ((uVar8 & 0x2000) == 0) {
                pcVar32 = "";
              }
              if (prVar36 == (rtree_t *)0x0) {
                prVar36 = (rtree_t *)&DAT_0814741b;
              }
              if (Settings.grid_units_mm == '\0') {
                fVar18 = (float)local_848->Height / 100.00000000;
                local_858 = &DAT_08147f6c;
              }
              else {
                local_858 = &DAT_0815627e;
                fVar18 = ((float)local_848->Height / 100000.00000000) * 25.39999962;
              }
              local_960 = local_848->Y;
              local_964 = local_848->X;
              local_968 = flags_to_string(local_848->Flags,0x100);
              local_96c = local_848->ID;
              local_970 = 
              "PIN ID# %ld  Flags:%s\n(X,Y) = (%d, %d)\nIt is a mounting hole, Drill width = %0.2f %s\nIt is owned by element %s\n%s"
              ;
LAB_080c2b07:
              __sprintf_chk(report,1,0x800,local_970,local_96c,local_968,local_964,local_960,
                            (double)fVar18,local_858,prVar36,pcVar32);
            }
          }
          else {
            if (iVar25 != 0x200) goto LAB_080c206e;
            if (local_844[2].Arc != (ArcTypePtr *)0x0) {
              pAVar27 = (ArcTypePtr *)local_844[2].SelectedColor;
              pAVar30 = (ArcTypePtr *)&DAT_00000001;
              if (local_848 != pAVar27) {
                while ((pAVar30 < local_844[2].Arc &&
                       (pAVar27 = (ArcTypePtr *)&pAVar27[1].Thickness, pAVar27 != local_848))) {
                  pAVar30 = (ArcTypePtr *)((int)&(pAVar30->BoundingBox).X1 + 1);
                }
              }
            }
            iVar26 = local_848->Delta;
            local_954 = local_848->Width;
            iVar4 = local_848[1].BoundingBox.X1;
            iVar25 = local_954 - iVar26;
            iVar5 = local_848->Height;
            iVar31 = iVar5 - iVar4;
            iVar6 = local_848[1].ID;
            iVar7 = local_848->Thickness;
            uVar8 = (local_848->Flags).f;
            iVar25 = (int)ROUND(SQRT((double)(iVar31 * iVar31 + iVar25 * iVar25)));
            iVar31 = (iVar6 - iVar7) / 2;
            pcVar32 = "It is LOCKED\n";
            if ((uVar8 & 0x2000) == 0) {
              pcVar32 = "";
            }
            prVar36 = local_844[1].text_tree;
            local_968 = "solder (bottom)";
            puVar35 = (undefined1 *)local_848[1].Flags.f;
            if (-1 < (char)uVar8) {
              local_968 = "component";
            }
            puVar33 = *(undefined1 **)local_848[1].Flags.t;
            if (puVar33 == (undefined1 *)0x0) {
              puVar33 = &DAT_0814741b;
            }
            if (prVar36 == (rtree_t *)0x0) {
              prVar36 = (rtree_t *)&DAT_0814741b;
            }
            if (puVar35 == (undefined1 *)0x0) {
              puVar35 = &DAT_0814741b;
            }
            if (Settings.grid_units_mm == '\0') {
              fVar18 = (float)iVar31 / 100.00000000;
              local_860 = &DAT_08147f6c;
              local_878 = &DAT_08147f6c;
              local_87c = &DAT_08147f6c;
              local_874 = &DAT_08147f6c;
              local_880 = &DAT_08147f6c;
              fVar19 = (float)(iVar25 + iVar6) / 100.00000000;
              fVar21 = (float)iVar6 / 100.00000000;
              fVar22 = ((float)local_848->Clearance * 0.50000000) / 100.00000000;
              fVar23 = (float)(iVar25 + iVar7) / 100.00000000;
              fVar24 = 100.00000000 / (float)iVar7;
            }
            else {
              local_860 = &DAT_0815627e;
              local_878 = &DAT_0815627e;
              local_87c = &DAT_0815627e;
              local_874 = &DAT_0815627e;
              local_880 = &DAT_0815627e;
              fVar18 = ((float)iVar31 / 100000.00000000) * 25.39999962;
              fVar19 = ((float)(iVar25 + iVar6) / 100000.00000000) * 25.39999962;
              fVar21 = ((float)iVar6 / 100000.00000000) * 25.39999962;
              fVar22 = (((float)local_848->Clearance * 0.50000000) / 100000.00000000) * 25.39999962;
              fVar23 = ((float)(iVar25 + iVar7) / 100000.00000000) * 25.39999962;
              fVar24 = (100000.00000000 / (float)iVar7) * 25.39999962;
            }
            local_960 = local_848[1].BoundingBox.Y2;
            local_96c = local_848->StartAngle;
            local_970 = flags_to_string(local_848->Flags,0x200);
            __sprintf_chk(report,1,0x800,
                                                    
                          "PAD ID# %ld   Flags:%s\nFirstPoint(X,Y)  = (%d, %d)  ID = %ld\nSecondPoint(X,Y) = (%d, %d)  ID = %ld\nWidth = %0.2f %s.  Length = %0.2f %s.\nClearance width in polygons = %0.2f %s.\nSolder mask = %0.2f x %0.2f %s (gap = %0.2f %s).\nName = \"%s\"\nIt is owned by SMD element %s\nAs pin number %s and is on the %s\nside of the board.\n%s"
                          ,local_848->ID,local_970,local_954,iVar5,local_96c,iVar26,iVar4,local_960,
                          SUB84((double)fVar24,0),(int)((ulonglong)(double)fVar24 >> 0x20),local_860
                          ,SUB84((double)fVar23,0),(int)((ulonglong)(double)fVar23 >> 0x20),
                          local_874,SUB84((double)fVar22,0),(int)((ulonglong)(double)fVar22 >> 0x20)
                          ,local_878,SUB84((double)fVar21,0),
                          (int)((ulonglong)(double)fVar21 >> 0x20),(double)fVar19,local_87c,
                          (double)fVar18,local_880,puVar35,prVar36,puVar33,local_968,pcVar32);
          }
        }
        else {
          if (iVar25 != 0x1000) {
            if (iVar25 == 0x4000) {
              pcVar32 = "";
              pBVar28 = GetArcEnds(local_848);
              if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
                pcVar32 = "It is LOCKED\n";
              }
              iVar25 = GetLayerNumber(PCB->Data,local_844);
              local_960 = pBVar28->X2;
              local_964 = (local_848->BoundingBox).Y2;
              LVar9 = pBVar28->Y2;
              LVar10 = (local_848->BoundingBox).Y1;
              LVar11 = pBVar28->Y1;
              LVar12 = pBVar28->X1;
              local_96c = local_848->Delta;
              LVar13 = (local_848->BoundingBox).X2;
              LVar14 = (local_848->BoundingBox).X1;
              lVar15 = local_848->StartAngle;
              if (Settings.grid_units_mm == '\0') {
                local_860 = &DAT_08147f6c;
                local_858 = &DAT_08147f6c;
                local_85c = &DAT_08147f6c;
                fVar18 = ((float)local_848->Clearance * 0.50000000) / 100.00000000;
                fVar19 = (float)local_848->Thickness / 100.00000000;
                fVar21 = 100.00000000 / (float)local_848->Width;
              }
              else {
                local_860 = &DAT_0815627e;
                local_858 = &DAT_0815627e;
                local_85c = &DAT_0815627e;
                fVar18 = (((float)local_848->Clearance * 0.50000000) / 100000.00000000) *
                         25.39999962;
                fVar19 = ((float)local_848->Thickness / 100000.00000000) * 25.39999962;
                fVar21 = (100000.00000000 / (float)local_848->Width) * 25.39999962;
              }
              LVar16 = local_848->Y;
              LVar17 = local_848->X;
              local_968 = flags_to_string(local_848->Flags,0x4000);
              __sprintf_chk(report,1,0x800,
                                                        
                            "ARC ID# %ld   Flags:%s\nCenterPoint(X,Y) = (%d, %d)\nRadius = %0.2f %s, Thickness = %0.2f %s\nClearance width in polygons = %0.2f %s\nStartAngle = %ld degrees, DeltaAngle = %ld degrees\nBounding Box is (%d,%d), (%d,%d)\nThat makes the end points at (%d,%d) and (%d,%d)\nIt is on layer %d\n%s"
                            ,local_848->ID,local_968,LVar17,LVar16,(double)fVar21,local_858,
                            SUB84((double)fVar19,0),(int)((ulonglong)(double)fVar19 >> 0x20),
                            local_85c,SUB84((double)fVar18,0),
                            (int)((ulonglong)(double)fVar18 >> 0x20),local_860,lVar15,local_96c,
                            LVar14,LVar10,LVar13,local_964,LVar12,LVar11,local_960,LVar9,iVar25,
                            pcVar32);
              goto LAB_080c2098;
            }
            if (iVar25 != 0x800) goto LAB_080c206e;
          }
          iVar26 = GetLayerNumber(PCB->Data,local_844);
          pcVar32 = "polygon";
          if (iVar25 == 0x1000) {
            pcVar32 = "line";
          }
          __sprintf_chk(report,1,0x800,
                                                
                        "POINT ID# %ld. Points don\'t have flags.\nLocated at (X,Y) = (%d,%d)\nIt belongs to a %s on layer %d\n"
                        ,local_848->ID,(local_848->BoundingBox).X1,(local_848->BoundingBox).Y1,
                        pcVar32,iVar26);
        }
      }
      goto LAB_080c2098;
    }
    if (iVar25 == 2) {
      local_968 = "";
      pcVar32 = "It is LOCKED\n";
      uVar8 = (local_848->Flags).f;
      if ((uVar8 & 0x2000) == 0) {
        pcVar32 = "";
      }
      local_970 = "component";
      if ((char)uVar8 < '\0') {
        local_970 = "solder (bottom)";
      }
      local_96c = local_848[3].ID;
      if ((uVar8 & 0x10) != 0) {
        local_968 = "But it\'s hidden\n";
      }
      local_960 = local_848[2].BoundingBox.Y1;
      local_964 = local_848[2].BoundingBox.X1;
      LVar9 = local_848[3].BoundingBox.Y2;
      if (Settings.grid_units_mm == '\0') {
        local_868 = &DAT_08147f6c;
        dVar20 = ((double)local_848[1].Delta * 0.45000000 * 100.00000000) / 100.00000000;
      }
      else {
        local_868 = &DAT_0815627e;
        dVar20 = (((double)local_848[1].Delta * 0.45000000 * 100.00000000) / 100000.00000000) *
                 25.40000000;
      }
      puVar35 = (undefined1 *)local_848[3].BoundingBox.Y1;
      puVar33 = (undefined1 *)local_848[2].BoundingBox.Y2;
      puVar37 = (undefined1 *)local_848[1].Flags.f;
      if (puVar35 == (undefined1 *)0x0) {
        puVar35 = &DAT_0814741b;
      }
      if (puVar33 == (undefined1 *)0x0) {
        puVar33 = &DAT_0814741b;
      }
      if (puVar37 == (undefined1 *)0x0) {
        puVar37 = &DAT_0814741b;
      }
      LVar10 = (local_848->BoundingBox).Y2;
      LVar11 = (local_848->BoundingBox).X2;
      LVar12 = (local_848->BoundingBox).Y1;
      LVar13 = (local_848->BoundingBox).X1;
      pcVar29 = flags_to_string(local_848->Flags,2);
      __sprintf_chk(report,1,0x800,
                                        
                    "ELEMENT ID# %ld   Flags:%s\nBoundingBox (%d,%d) (%d,%d)\nDescriptive Name \"%s\"\nName on board \"%s\"\nPart number name \"%s\"\nIt is %0.2f %s tall and is located at (X,Y) = (%d,%d)\n%sMark located at point (X,Y) = (%d,%d)\nIt is on the %s side of the board.\n%s"
                    ,local_848->ID,pcVar29,LVar13,LVar12,LVar11,LVar10,puVar37,puVar33,puVar35,
                    SUB84(dVar20,0),(int)((ulonglong)dVar20 >> 0x20),local_868,local_964,local_960,
                    local_968,LVar9,local_96c,local_970,pcVar32);
      goto LAB_080c2098;
    }
    if (2 < iVar25) {
      if (iVar25 != 8) {
        if (iVar25 == 0x10) goto LAB_080c2558;
        if (iVar25 != 4) goto LAB_080c206e;
        local_968 = "";
        pcVar32 = (char *)local_848[1].ID;
        if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
          local_968 = "It is LOCKED\n";
        }
        if ((pcVar32 == (char *)0x0) || (*pcVar32 == '\0')) {
          pcVar32 = "(unknown)";
        }
        iVar25 = GetLayerNumber(PCB->Data,local_844);
        if (Settings.grid_units_mm == '\0') {
          local_868 = &DAT_08147f6c;
          local_86c = &DAT_08147f6c;
          fVar18 = ((float)local_848->Clearance * 0.50000000) / 100.00000000;
          fVar19 = (float)local_848->Thickness / 100.00000000;
        }
        else {
          local_868 = &DAT_0815627e;
          local_86c = &DAT_0815627e;
          fVar18 = (((float)local_848->Clearance * 0.50000000) / 100000.00000000) * 25.39999962;
          fVar19 = (100000.00000000 / (float)local_848->Thickness) * 25.39999962;
        }
        local_96c = local_848->Delta;
        local_960 = local_848[1].BoundingBox.Y2;
        local_964 = local_848[1].BoundingBox.X1;
        lVar15 = local_848->StartAngle;
        LVar9 = local_848->Height;
        LVar10 = local_848->Width;
        local_970 = flags_to_string(local_848->Flags,4);
        __sprintf_chk(report,1,0x800,
                                            
                      "LINE ID# %ld   Flags:%s\nFirstPoint(X,Y) = (%d, %d)  ID = %ld\nSecondPoint(X,Y) = (%d, %d)  ID = %ld\nWidth = %0.2f %s.\nClearance width in polygons = %0.2f %s.\nIt is on layer %d\nand has name %s\n%s"
                      ,local_848->ID,local_970,LVar10,LVar9,lVar15,local_96c,local_964,local_960,
                      SUB84((double)fVar19,0),(int)((ulonglong)(double)fVar19 >> 0x20),local_868,
                      SUB84((double)fVar18,0),(int)((ulonglong)(double)fVar18 >> 0x20),local_86c,
                      iVar25,pcVar32,local_968);
        goto LAB_080c2098;
      }
      pcVar32 = "";
      if ((*(byte *)((int)&(local_848->Flags).f + 1) & 0x20) != 0) {
        pcVar32 = "It is LOCKED\n";
      }
      iVar26 = GetLayerNumber(PCB->Data,local_844);
      local_954 = local_848->Thickness;
      iVar25 = local_848->Clearance - local_954;
      local_95c = *(undefined8 *)&(local_848->BoundingBox).X2;
      local_960 = (local_848->BoundingBox).Y1;
      local_964 = (local_848->BoundingBox).X1;
      local_968 = flags_to_string(local_848->Flags,8);
      local_96c = local_848->ID;
      local_970 = 
      "POLYGON ID# %ld   Flags:%s\nIts bounding box is (%d,%d) (%d,%d)\nIt has %d points and could store %d more\nwithout using more memory.\nIt resides on layer %d\n%s"
      ;
      goto LAB_080c2c15;
    }
    if (iVar25 != 0) {
      if (iVar25 == 1) {
        uVar8 = (local_848->Flags).f;
        if ((uVar8 & 8) != 0) {
          prVar36 = (rtree_t *)local_848->StartAngle;
          pcVar32 = "It is LOCKED\n";
          if ((uVar8 & 0x2000) == 0) {
            pcVar32 = "";
          }
          if (prVar36 == (rtree_t *)0x0) {
            prVar36 = (rtree_t *)&DAT_0814741b;
          }
          if (Settings.grid_units_mm == '\0') {
            fVar18 = (float)local_848->Height / 100.00000000;
            local_858 = &DAT_08147f6c;
          }
          else {
            local_858 = &DAT_0815627e;
            fVar18 = ((float)local_848->Height / 100000.00000000) * 25.39999962;
          }
          local_960 = local_848->Y;
          local_964 = local_848->X;
          local_968 = flags_to_string(local_848->Flags,1);
          local_96c = local_848->ID;
          local_970 = 
          "VIA ID# %ld  Flags:%s\n(X,Y) = (%d, %d)\nIt is a pure hole of diameter %0.2f %s\nName = \"%s\"%s"
          ;
          goto LAB_080c2b07;
        }
        puVar35 = (undefined1 *)local_848->StartAngle;
        pcVar32 = "It is LOCKED\n";
        if ((uVar8 & 0x2000) == 0) {
          pcVar32 = "";
        }
        if (puVar35 == (undefined1 *)0x0) {
          puVar35 = &DAT_0814741b;
        }
        if (Settings.grid_units_mm == '\0') {
          iVar25 = local_848->Thickness;
          local_85c = &DAT_08147f6c;
          local_860 = &DAT_08147f6c;
          fVar24 = (float)((local_848->Width - iVar25) / 2) / 100.00000000;
          local_864 = &DAT_08147f6c;
          local_868 = &DAT_08147f6c;
          local_86c = &DAT_08147f6c;
          local_870 = &DAT_08147f6c;
          fVar23 = (float)local_848->Width / 100.00000000;
          fVar22 = (float)((iVar25 - local_848->Height) / 2) / 100.00000000;
          fVar21 = ((float)local_848->Clearance * 0.50000000) / 100.00000000;
          fVar19 = (float)local_848->Height / 100.00000000;
          fVar18 = 100.00000000 / (float)iVar25;
        }
        else {
          iVar25 = local_848->Thickness;
          local_85c = &DAT_0815627e;
          local_860 = &DAT_0815627e;
          local_864 = &DAT_0815627e;
          local_868 = &DAT_0815627e;
          local_86c = &DAT_0815627e;
          local_870 = &DAT_0815627e;
          fVar24 = ((float)((local_848->Width - iVar25) / 2) / 100000.00000000) * 25.39999962;
          fVar23 = ((float)local_848->Width / 100000.00000000) * 25.39999962;
          fVar22 = ((float)((iVar25 - local_848->Height) / 2) / 100000.00000000) * 25.39999962;
          fVar21 = (((float)local_848->Clearance * 0.50000000) / 100000.00000000) * 25.39999962;
          fVar19 = ((float)local_848->Height / 100000.00000000) * 25.39999962;
          fVar18 = (100000.00000000 / (float)iVar25) * 25.39999962;
        }
        local_960 = local_848->Y;
        local_964 = local_848->X;
        local_968 = flags_to_string(local_848->Flags,1);
        __sprintf_chk(report,1,0x800,
                                            
                      "VIA ID# %ld   Flags:%s\n(X,Y) = (%d, %d)\nCopper width = %0.2f %s  Drill width = %0.2f %s\nClearance width in polygons = %0.2f %s\nAnnulus = %0.2f %s\nSolder mask hole = %0.2f %s (gap = %0.2f %s)\nName = \"%s\"%s"
                      ,local_848->ID,local_968,local_964,local_960,(double)fVar18,local_85c,
                      SUB84((double)fVar19,0),(int)((ulonglong)(double)fVar19 >> 0x20),local_860,
                      SUB84((double)fVar21,0),(int)((ulonglong)(double)fVar21 >> 0x20),local_864,
                      SUB84((double)fVar22,0),(int)((ulonglong)(double)fVar22 >> 0x20),local_868,
                      SUB84((double)fVar23,0),(int)((ulonglong)(double)fVar23 >> 0x20),local_86c,
                      (double)fVar24,local_870,puVar35,pcVar32);
      }
      else {
LAB_080c206e:
        __sprintf_chk(report,1,0x800,"Unknown\n");
      }
      goto LAB_080c2098;
    }
    report[0] = '\0';
  }
  else {
    iVar26 = iVar25 + -0x20;
    bVar38 = iVar25 == 0x20;
    if (!bVar38) goto LAB_080c202e;
LAB_080c22f1:
    local_96c = local_848[1].ID;
    pcVar32 = (char *)local_848[1].Flags.f;
    iVar25 = local_848[1].BoundingBox.X1;
    local_954 = local_848->Delta;
    lVar15 = local_848->StartAngle;
    iVar26 = local_848[1].BoundingBox.Y2;
    local_960 = local_848->Height;
    local_964 = local_848->Width;
    local_968 = flags_to_string(local_848->Flags,4);
    local_95c = CONCAT44(local_96c,lVar15);
    local_96c = local_848->ID;
    local_970 = 
    "RAT-LINE ID# %ld   Flags:%s\nFirstPoint(X,Y) = (%d, %d) ID = %ld connects to layer group %d\nSecondPoint(X,Y) = (%d, %d) ID = %ld connects to layer group %d\n"
    ;
LAB_080c2c15:
    __sprintf_chk(report,1,0x800,local_970,local_96c,local_968,local_964,local_960,local_95c,
                  local_954,iVar25,iVar26,pcVar32);
LAB_080c2098:
    if (report[0] != '\0') {
      HideCrosshair('\0');
      (*gui->report_dialog)("Report",report);
      RestoreCrosshair('\0');
      iVar25 = 0;
      goto LAB_080c20d5;
    }
  }
  Message("Nothing found to report on\n");
  iVar25 = 1;
LAB_080c20d5:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar25;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int Report(int argc,char **argv,int x,int y)

{
  Cardinal *pCVar1;
  Cardinal *pCVar2;
  Cardinal *pCVar3;
  int iVar4;
  char cVar5;
  char *pcVar6;
  Cardinal CVar7;
  LibraryEntryTypePtr *pLVar8;
  int x_00;
  undefined4 uVar9;
  DrillInfoTypePtr *d;
  int *piVar10;
  LibraryMenuTypePtr *pLVar11;
  char *__s;
  char *__s1;
  DataTypePtr *pDVar12;
  LibraryMenuTypePtr *pLVar13;
  undefined1 *puVar14;
  int iVar15;
  DrillTypePtr pDVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  int y_00;
  int in_GS_OFFSET;
  double dVar22;
  char *Ptr;
  uint local_98;
  uint local_94;
  int local_90;
  int local_8c;
  uint local_88;
  PCBTypePtr local_84;
  PCBTypePtr local_80;
  int local_7c;
  uint *local_78;
  int found;
  int local_68;
  int local_64;
  char temp [64];
  
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  if (argc < 1) {
    Message("Usage:\n%s\n","Report(Object|DrillReport|FoundPins|NetLength|AllNetLengths)");
    local_90 = 1;
  }
  else {
    __s1 = *argv;
    x_00 = strcasecmp(__s1,"Object");
    if (x_00 == 0) {
      (*gui->get_coords)("Click on an object",&x,&y);
      local_90 = ReportDialog(argc + -1,argv + 1,x,y);
    }
    else {
      x_00 = strcasecmp(__s1,"DrillReport");
      if (x_00 == 0) {
        x_00 = 0;
        d = GetDrillInfo(PCB->Data);
        RoundDrillInfo(d,100);
        uVar20 = d->DrillN;
        if (uVar20 != 0) {
          pDVar16 = d->Drill;
          uVar17 = 0;
          do {
            pCVar1 = &pDVar16->ViaCount;
            uVar17 = uVar17 + 1;
            pCVar2 = &pDVar16->PinCount;
            pCVar3 = &pDVar16->UnplatedCount;
            pDVar16 = pDVar16 + 1;
            x_00 = *pCVar1 + *pCVar2 + *pCVar3 + x_00;
          } while (uVar17 < uVar20);
        }
        Ptr = (char *)calloc(1,(uVar20 + 8) * 0x40);
        __sprintf_chk(Ptr,1,0xffffffff,
                                            
                      "There are %d different drill sizes used in this layout, %d holes total\n\nDrill Diam. (mils)\t# of Pins\t# of Vias\t# of Elements\t# Unplated\n"
                      ,d->DrillN,x_00);
        cVar5 = *Ptr;
        __s1 = Ptr;
        while (cVar5 != '\0') {
          __s1 = __s1 + 1;
          cVar5 = *__s1;
        }
        if (d->DrillN != 0) {
          x_00 = 0;
          uVar20 = 0;
          do {
            piVar10 = (int *)((int)&d->Drill->DrillSize + x_00);
            __sprintf_chk(__s1,1,0xffffffff,"\t%d\t\t\t%d\t\t%d\t\t%d\t\t%d\n",
                          (*piVar10 + 0x32) / 100,piVar10[3],piVar10[4],piVar10[1],piVar10[5]);
            cVar5 = *__s1;
            while (cVar5 != '\0') {
              __s1 = __s1 + 1;
              cVar5 = *__s1;
            }
            uVar20 = uVar20 + 1;
            x_00 = x_00 + 0x28;
          } while (uVar20 < d->DrillN);
        }
        FreeDrillInfo(d);
        (*gui->report_dialog)("Drill Report",Ptr);
        SaveFree(Ptr);
        local_90 = 0;
      }
      else {
        x_00 = strcasecmp(__s1,"FoundPins");
        if (x_00 == 0) {
          DSClearString((DynamicStringTypePtr_conflict *)&list);
          DSAddString((DynamicStringTypePtr_conflict *)&list,"The following pins/pads are FOUND:\n")
          ;
          pDVar12 = PCB->Data;
          local_78 = (uint *)(pDVar12->ElementN - 1);
          if (local_78 != (uint *)0xffffffff) {
            y_00 = 0;
            x_00 = pDVar12->ElementN * 300;
            while( true ) {
              local_7c = x_00 + -300;
              x_00 = (int)&pDVar12->Element[-1].BoundingBox.X1 + x_00;
              if (*(uint *)(x_00 + 0xe0) != 0) {
                uVar17 = 0;
                uVar20 = *(uint *)(x_00 + 0xe0);
                do {
                  iVar15 = uVar17 * 0x4c + *(int *)(x_00 + 0x100);
                  uVar21 = uVar20;
                  if ((*(byte *)(iVar15 + 0x14) & 4) != 0) {
                    uVar9 = 0x20;
                    if (y_00 % 9 == 8) {
                      uVar9 = 10;
                    }
                    y_00 = y_00 + 1;
                    __sprintf_chk(temp,1,0x40,&DAT_0814df86,*(undefined4 *)(x_00 + 0x94),
                                  *(undefined4 *)(iVar15 + 0x40),uVar9);
                    DSAddString((DynamicStringTypePtr_conflict *)&list,temp);
                    uVar21 = *(uint *)(x_00 + 0xe0);
                  }
                } while ((uVar21 != 0) &&
                        (uVar17 = (uVar17 + 1 + uVar21) - uVar20, uVar20 = uVar21, uVar17 < uVar21))
                ;
              }
              uVar20 = *(uint *)(x_00 + 0xe8);
              uVar21 = 0;
              uVar17 = uVar20;
              while ((uVar17 != 0 && (uVar21 < uVar17))) {
                iVar15 = uVar21 * 0x68 + *(int *)(x_00 + 0x104);
                if ((*(byte *)(iVar15 + 0x14) & 4) != 0) {
                  uVar9 = 0x20;
                  if (y_00 % 9 == 8) {
                    uVar9 = 10;
                  }
                  y_00 = y_00 + 1;
                  __sprintf_chk(temp,1,0x40,&DAT_0814df86,*(undefined4 *)(x_00 + 0x94),
                                *(undefined4 *)(iVar15 + 0x5c),uVar9);
                  DSAddString((DynamicStringTypePtr_conflict *)&list,temp);
                  uVar17 = *(uint *)(x_00 + 0xe8);
                }
                uVar21 = uVar21 + (uVar20 == uVar17);
              }
              local_78 = (uint *)((int)local_78 + -1);
              if (local_78 == (uint *)0xffffffff) break;
              pDVar12 = PCB->Data;
              x_00 = local_7c;
            }
          }
          HideCrosshair('\0');
          (*gui->report_dialog)("Report",list.Data);
          RestoreCrosshair('\0');
          local_90 = 0;
        }
        else {
          x_00 = strcasecmp(__s1,"NetLength");
          if (x_00 == 0) {
            found = 0;
            local_64 = x;
            local_68 = y;
            SaveUndoSerialNumber();
            ResetFoundPinsViasAndPads('\x01');
            RestoreUndoSerialNumber();
            ResetFoundLinesAndPolygons('\x01');
            RestoreUndoSerialNumber();
            (*gui->get_coords)("Click on a connection",&local_64,&local_68);
            XYtoNetLength(local_64,local_68,&found);
            if (found == 0) {
              (*gui->log)("No net under cursor.\n");
              local_90 = 1;
            }
            else {
              pDVar12 = PCB->Data;
              local_84 = PCB;
              local_8c = pDVar12->ElementN - 1;
              if (local_8c != -1) {
                x_00 = pDVar12->ElementN * 300;
                do {
                  local_94 = x_00 + -300;
                  x_00 = (int)&pDVar12->Element[-1].BoundingBox.X1 + x_00;
                  if (*(uint *)(x_00 + 0xe0) != 0) {
                    uVar17 = 0;
                    uVar20 = *(uint *)(x_00 + 0xe0);
                    do {
                      y_00 = uVar17 * 0x4c + *(int *)(x_00 + 0x100);
                      uVar21 = uVar20;
                      if ((*(byte *)(y_00 + 0x14) & 4) != 0) {
                        y_00 = *(int *)(y_00 + 0x40);
                        if ((y_00 != 0) && (*(char **)(x_00 + 0x94) != (char *)0x0)) {
                          __s1 = Concat(*(char **)(x_00 + 0x94),&DAT_08156000,y_00,0);
                          uVar21 = (PCB->NetlistLib).MenuN;
                          local_84 = PCB;
                          if (uVar21 != 0) {
                            local_88 = 0;
                            pLVar11 = (PCB->NetlistLib).Menu;
                            do {
                              pLVar13 = pLVar11 + local_88;
                              uVar19 = pLVar13->EntryN;
                              if (uVar19 != 0) {
                                pLVar8 = pLVar13->Entry;
                                uVar18 = 0;
                                do {
                                  y_00 = strcmp(pLVar8[uVar18].ListEntry,__s1);
                                  if (y_00 == 0) {
                                    __s1 = pLVar13->Name;
                                    goto got_net_name;
                                  }
                                  uVar18 = uVar18 + 1;
                                } while (uVar18 < uVar19);
                              }
                              local_88 = local_88 + 1;
                            } while (local_88 < uVar21);
                          }
                          uVar21 = *(uint *)(x_00 + 0xe0);
                        }
                      }
                    } while ((uVar21 != 0) &&
                            (uVar17 = (uVar17 + 1 + uVar21) - uVar20, uVar20 = uVar21,
                            uVar17 < uVar21));
                  }
                  local_7c = 0;
                  local_80 = (PCBTypePtr)0x0;
                  uVar20 = *(uint *)(x_00 + 0xe8);
                  uVar17 = uVar20;
                  while ((uVar17 != 0 && (local_80 < uVar17))) {
                    y_00 = local_7c + *(int *)(x_00 + 0x104);
                    if ((*(byte *)(y_00 + 0x14) & 4) != 0) {
                      y_00 = *(int *)(y_00 + 0x5c);
                      if ((y_00 != 0) && (*(char **)(x_00 + 0x94) != (char *)0x0)) {
                        __s1 = Concat(*(char **)(x_00 + 0x94),&DAT_08156000,y_00,0);
                        local_84 = PCB;
                        uVar17 = (PCB->NetlistLib).MenuN;
                        if (uVar17 == 0) {
                          uVar17 = *(uint *)(x_00 + 0xe8);
                        }
                        else {
                          local_98 = 0;
                          pLVar11 = (PCB->NetlistLib).Menu;
                          do {
                            pLVar13 = pLVar11 + local_98;
                            uVar21 = pLVar13->EntryN;
                            if (uVar21 != 0) {
                              pLVar8 = pLVar13->Entry;
                              uVar19 = 0;
LAB_080c44e2:
                              y_00 = strcmp(pLVar8[uVar19].ListEntry,__s1);
                              if (y_00 != 0) goto LAB_080c44d8;
                              __s1 = pLVar13->Name;
got_net_name:
                              HideCrosshair('\0');
                              if (__s1 + 2 == (char *)0x0) goto LAB_080c455d;
                              puVar14 = &DAT_08147f6c;
                              if (Settings.grid_units_mm != '\0') {
                                puVar14 = &DAT_0815627e;
                              }
                              (*gui->log)("Net %s length: %0.2f %s\n",__s1 + 2,0,0,puVar14);
                              goto LAB_080c4336;
                            }
LAB_080c4508:
                            local_98 = local_98 + 1;
                          } while (local_98 < uVar17);
                          uVar17 = *(uint *)(x_00 + 0xe8);
                        }
                      }
                    }
                    if (uVar20 == uVar17) {
                      local_80 = (PCBTypePtr)((int)local_80 + 1);
                      local_7c = local_7c + 0x68;
                      uVar17 = uVar20;
                    }
                  }
                  local_8c = local_8c + -1;
                  if (local_8c == -1) break;
                  pDVar12 = local_84->Data;
                  x_00 = local_94;
                } while( true );
              }
              HideCrosshair('\0');
LAB_080c455d:
              puVar14 = &DAT_08147f6c;
              if (Settings.grid_units_mm != '\0') {
                puVar14 = &DAT_0815627e;
              }
              (*gui->log)("Net length: %0.2f %s\n",0,0,puVar14);
LAB_080c4336:
              RestoreCrosshair('\0');
              local_90 = 0;
            }
          }
          else {
            Ptr = "AllNetLengths";
            x_00 = strcasecmp(__s1,"AllNetLengths");
            if (x_00 == 0) {
              local_94 = ~-(uint)(Settings.grid_units_mm == '\0') + 2;
              if (argc != 1) {
                __printf_chk(1,"Units: %s\n",argv[1]);
                __s1 = argv[1];
                Ptr = "mm";
                x_00 = strcasecmp(__s1,"mm");
                local_94 = 1;
                if (x_00 != 0) {
                  Ptr = "mil";
                  x_00 = strcasecmp(__s1,"mil");
                  local_94 = 2;
                  if (x_00 != 0) {
                    Ptr = "in";
                    x_00 = strcasecmp(__s1,"in");
                    local_94 = -(uint)(x_00 == 0) & 3;
                  }
                }
              }
              local_80 = PCB;
              if ((PCB->NetlistLib).MenuN != 0) {
                local_84 = (PCBTypePtr)0x0;
                do {
                  pLVar11 = (local_80->NetlistLib).Menu + (int)local_84;
                  pcVar6 = pLVar11->Name;
                  __s = (char *)__strdup(pLVar11->Entry->ListEntry,Ptr);
                  Ptr = (char *)0x2d;
                  __s1 = strchr(__s,0x2d);
                  if (__s1 == (char *)0x0) {
                    free(__s);
                    local_80 = PCB;
                  }
                  else {
                    *__s1 = '\0';
                    __s1 = __s1 + 1;
                    local_80 = PCB;
                    CVar7 = PCB->Data->ElementN;
                    local_7c = CVar7 - 1;
                    if (local_7c != -1) {
                      local_78 = &PCB->Data->Element[CVar7 - 1].PadN;
                      do {
                        if (((char *)local_78[-0x15] != (char *)0x0) &&
                           (Ptr = __s, x_00 = strcmp((char *)local_78[-0x15],__s), x_00 == 0)) {
                          uVar20 = local_78[-2];
                          if (uVar20 != 0) {
                            uVar17 = local_78[6];
                            uVar21 = 0;
                            do {
                              Ptr = __s1;
                              x_00 = strcmp(*(char **)(uVar17 + 0x40),__s1);
                              if (x_00 == 0) {
                                x_00 = *(int *)(uVar17 + 0x34);
                                y_00 = *(int *)(uVar17 + 0x38);
                                goto got_one;
                              }
                              uVar21 = uVar21 + 1;
                              uVar17 = uVar17 + 0x4c;
                            } while (uVar21 < uVar20);
                          }
                          uVar20 = *local_78;
                          if (uVar20 != 0) {
                            uVar21 = 0;
                            uVar17 = local_78[7];
LAB_080c3ffb:
                            Ptr = __s1;
                            x_00 = strcmp(*(char **)(uVar17 + 0x5c),__s1);
                            if (x_00 != 0) goto LAB_080c3ff0;
                            x_00 = (*(int *)(uVar17 + 0x40) + *(int *)(uVar17 + 0x2c)) / 2;
                            y_00 = (*(int *)(uVar17 + 0x44) + *(int *)(uVar17 + 0x30)) / 2;
got_one:
                            SaveUndoSerialNumber();
                            ResetFoundPinsViasAndPads('\x01');
                            RestoreUndoSerialNumber();
                            Ptr = pcVar6 + 2;
                            ResetFoundLinesAndPolygons('\x01');
                            RestoreUndoSerialNumber();
                            dVar22 = XYtoNetLength(x_00,y_00,&found);
                            if (local_94 == 2) {
                              (*gui->log)("Net %s length %d mil\n",Ptr,
                                          (int)ROUND(dVar22 / 100.00000000));
                              local_80 = PCB;
                            }
                            else {
                              if (local_94 == 3) {
                                (*gui->log)("Net %s length %.3f in\n",Ptr,
                                            SUB84(dVar22 / 100000.00000000,0),
                                            (int)((ulonglong)(dVar22 / 100000.00000000) >> 0x20));
                                local_80 = PCB;
                              }
                              else {
                                if (local_94 == 1) {
                                  (*gui->log)("Net %s length %.2f mm\n",Ptr,
                                              SUB84(dVar22 * 0.00025400,0),
                                              (int)((ulonglong)(dVar22 * 0.00025400) >> 0x20));
                                  local_80 = PCB;
                                }
                                else {
                                  (*gui->log)("Net %s length %d\n",Ptr,(int)ROUND(dVar22));
                                  local_80 = PCB;
                                }
                              }
                            }
                            break;
                          }
                        }
LAB_080c3fc0:
                        local_7c = local_7c + -1;
                        local_78 = local_78 + -0x4b;
                      } while (local_7c != -1);
                    }
                  }
                  local_84 = (PCBTypePtr)((int)local_84 + 1);
                } while (local_84 < (local_80->NetlistLib).MenuN);
              }
            }
            else {
              Message("Syntax error.  Usage:\n%s\n",
                      "Report(Object|DrillReport|FoundPins|NetLength|AllNetLengths)");
              local_90 = 1;
            }
          }
        }
      }
    }
  }
  if (iVar4 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_90;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080c44d8:
  uVar19 = uVar19 + 1;
  if (uVar21 <= uVar19) goto LAB_080c4508;
  goto LAB_080c44e2;
LAB_080c3ff0:
  uVar21 = uVar21 + 1;
  uVar17 = uVar17 + 0x68;
  if (uVar20 <= uVar21) goto LAB_080c3fc0;
  goto LAB_080c3ffb;
}



void register_report_action_list(void)

{
  hid_register_actions(report_action_list,2);
  return;
}



void __regparm3 dump_res(Resource *n,int l)

{
  Resource **ppRVar1;
  undefined4 *puVar2;
  undefined1 *puVar3;
  undefined1 *puVar4;
  int iVar5;
  int iVar6;
  
  if (0 < n->c) {
    iVar5 = 0;
    iVar6 = 0;
    do {
      while (puVar2 = (undefined4 *)((int)&n->v->name + iVar5), puVar2[2] == 0) {
        puVar4 = (undefined1 *)puVar2[1];
        puVar3 = (undefined1 *)*puVar2;
        if (puVar4 == (undefined1 *)0x0) {
          puVar4 = &DAT_0814741b;
        }
        if (puVar3 == (undefined1 *)0x0) {
          puVar3 = &DAT_0814741b;
        }
        iVar6 = iVar6 + 1;
        iVar5 = iVar5 + 0xc;
        __printf_chk(1,"%*cn[%s] = v[%s]\n",l,0x20,puVar3,puVar4);
        if (n->c == iVar6 || n->c < iVar6) {
          return;
        }
      }
      puVar4 = (undefined1 *)*puVar2;
      if (puVar4 == (undefined1 *)0x0) {
        puVar4 = &DAT_0814741b;
      }
      iVar6 = iVar6 + 1;
      __printf_chk(1,"%*cn[%s] = {\n",l,0x20,puVar4);
      ppRVar1 = (Resource **)((int)&n->v->subres + iVar5);
      iVar5 = iVar5 + 0xc;
      dump_res(*ppRVar1,l + 3);
      __printf_chk(1,"%*c}\n",l,0x20);
    } while (n->c != iVar6 && iVar6 <= n->c);
  }
  return;
}



void resource_dump(Resource *r)

{
  dump_res(r,0);
  return;
}



int reserror(char *str)

{
  char *pcVar1;
  
  pcVar1 = "internal strings";
  if (res_file != (FILE *)0x0) {
    pcVar1 = res_filename;
  }
  __fprintf_chk(stderr,1,"Error: %s around line %d: %s\n",pcVar1,res_lineno,str);
  return 0;
}



Resource * resource_subres(Resource *res,char *name)

{
  int iVar1;
  Resource *pRVar2;
  int iVar3;
  ResourceVal *pRVar4;
  int iVar5;
  
  if (((name != (char *)0x0) && (res != (Resource *)0x0)) && (iVar1 = res->c, 0 < iVar1)) {
    pRVar4 = res->v;
    iVar5 = 0;
    do {
      if (((pRVar4->name != (char *)0x0) && (pRVar2 = pRVar4->subres, pRVar2 != (Resource *)0x0)) &&
         (iVar3 = strcmp(pRVar4->name,name), iVar3 == 0)) {
        return pRVar2;
      }
      iVar5 = iVar5 + 1;
      pRVar4 = pRVar4 + 1;
    } while (iVar5 < iVar1);
  }
  return (Resource *)0x0;
}



char * resource_value(Resource *res,char *name)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  ResourceVal *pRVar4;
  int iVar5;
  
  if (((name != (char *)0x0) && (res != (Resource *)0x0)) && (iVar1 = res->c, 0 < iVar1)) {
    pRVar4 = res->v;
    iVar5 = 0;
    do {
      if (((pRVar4->name != (char *)0x0) && (pcVar2 = pRVar4->value, pcVar2 != (char *)0x0)) &&
         (iVar3 = strcmp(pRVar4->name,name), iVar3 == 0)) {
        return pcVar2;
      }
      iVar5 = iVar5 + 1;
      pRVar4 = pRVar4 + 1;
    } while (iVar5 < iVar1);
  }
  return (char *)0x0;
}



void resource_add_val(Resource *n,char *name,char *value,Resource *subres)

{
  int iVar1;
  ResourceVal *pRVar2;
  
  pRVar2 = (ResourceVal *)realloc(n->v,(n->c * 3 + 3) * 4);
  iVar1 = n->c;
  n->c = n->c + 1;
  pRVar2[iVar1].name = name;
  n->v = pRVar2;
  pRVar2[iVar1].subres = subres;
  pRVar2[iVar1].value = value;
  return;
}



Resource * resource_create(Resource *parent)

{
  Resource *pRVar1;
  ResourceVal *pRVar2;
  
  pRVar1 = (Resource *)malloc(0x14);
  pRVar1->flags = 0;
  pRVar1->c = 0;
  pRVar1->parent = parent;
  pRVar2 = (ResourceVal *)malloc(0xc);
  pRVar1->v = pRVar2;
  return pRVar1;
}



int res_parse_getchars(char *buf,int max_size)

{
  char cVar1;
  char **ppcVar2;
  int iVar3;
  uint uVar4;
  
  ppcVar2 = res_strings;
  if (res_file == (FILE *)0x0) {
    uVar4 = 0;
    if (*res_strings != (char *)0x0) {
      cVar1 = (*res_strings)[res_string_idx];
      res_string_idx = res_string_idx + 1;
      *buf = cVar1;
      uVar4 = 1;
      if (cVar1 == '\0') {
        res_strings = ppcVar2 + 1;
        res_string_idx = 0;
        *buf = '\n';
        return uVar4;
      }
    }
  }
  else {
    iVar3 = fgetc((FILE *)res_file);
    *buf = (char)iVar3;
    uVar4 = (uint)(iVar3 != -1);
  }
  return uVar4;
}



uint __regparm3 yytnamerr(char *yyres,char *yystr)

{
  char cVar1;
  char *pcVar2;
  uint uVar3;
  char *pcVar4;
  
  if (*yystr == '\"') {
    uVar3 = 0;
    pcVar2 = yystr;
    while( true ) {
      pcVar4 = pcVar2 + 1;
      cVar1 = *pcVar4;
      if (cVar1 == '\'') break;
      if (cVar1 < '(') {
        if (cVar1 == '\"') {
          if (yyres == (char *)0x0) {
            return uVar3;
          }
          yyres[uVar3] = '\0';
          return uVar3;
        }
      }
      else {
        if ((cVar1 == ',') || ((cVar1 == '\\' && (pcVar4 = pcVar2 + 2, *pcVar4 != '\\')))) break;
      }
      if (yyres != (char *)0x0) {
        yyres[uVar3] = *pcVar4;
      }
      uVar3 = uVar3 + 1;
      pcVar2 = pcVar4;
    }
  }
  if (yyres == (char *)0x0) {
    pcVar2 = (char *)strlen(yystr);
  }
  else {
    pcVar2 = stpcpy(yyres,yystr);
    pcVar2 = pcVar2 + -(int)yyres;
  }
  return (uint)pcVar2;
}



// WARNING: Could not reconcile some variable overlaps

uint __regparm3 yysyntax_error(char *yyresult,int yystate,int reschar)

{
  char **ppcVar1;
  byte bVar2;
  char *yystr;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint *puVar7;
  int iVar8;
  uint *puVar9;
  int iVar10;
  uint uVar11;
  int in_GS_OFFSET;
  bool bVar12;
  char *local_90;
  char *local_8c;
  uint local_80;
  char *yyarg [5];
  char yyformat [60];
  int local_20;
  char " or %s" [7];
  char ", expecting %s" [15];
  
  uVar11 = SEXT14(yypact[yystate]);
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  uVar4 = 0;
  if (uVar11 < 0x1a) {
    uVar4 = 2;
    if ((uint)reschar < 0x104) {
      uVar4 = (uint)""[reschar];
    }
    yyarg[0] = yytname[uVar4];
    iVar10 = 1;
    uVar4 = yytnamerr((char *)0x0,yyarg[0]);
    iVar6 = 0x1a - uVar11;
    local_90 = yyformat + 0x1b;
    yyformat._0_4_ = 0x746e7973;
    if (8 < iVar6) {
      iVar6 = 8;
    }
    iVar8 = 0;
    yyformat._4_4_ = 0x65207861;
    yyformat._8_4_ = 0x726f7272;
    yyformat._12_4_ = 0x6e75202c;
    yyformat._16_4_ = 0x65707865;
    yyformat._20_4_ = 0x64657463;
    yyformat._24_4_ = 0x732520;
    local_8c = ", expecting %s";
    bVar2 = 0;
    local_80 = uVar4;
    do {
      if (((int)""[iVar8 + uVar11] == iVar8) && (iVar8 != 1)) {
        if (iVar10 == 5) {
          iVar10 = 1;
          yyformat._24_4_ = yyformat._24_4_ & 0xffffff;
          local_80 = uVar4;
          break;
        }
        yystr = yytname[iVar8];
        yyarg[iVar10] = yystr;
        iVar10 = iVar10 + 1;
        uVar5 = yytnamerr((char *)0x0,yystr);
        bVar12 = CARRY4(uVar5,local_80);
        local_80 = uVar5 + local_80;
        bVar2 = bVar2 | bVar12;
        local_90 = stpcpy(local_90,local_8c);
        local_8c = " or %s";
      }
      iVar8 = iVar8 + 1;
    } while (iVar8 < iVar6);
    puVar7 = (uint *)yyformat;
    do {
      puVar9 = puVar7;
      uVar4 = *puVar9 + 0xfefefeff & ~*puVar9;
      uVar11 = uVar4 & 0x80808080;
      puVar7 = puVar9 + 1;
    } while (uVar11 == 0);
    bVar12 = (uVar4 & 0x8080) == 0;
    bVar3 = (byte)uVar11;
    if (bVar12) {
      bVar3 = (byte)(uVar11 >> 0x10);
    }
    if (bVar12) {
      puVar7 = (uint *)((int)puVar9 + 6);
    }
    uVar11 = (int)puVar7 + ((-3 - (uint)CARRY1(bVar3,bVar3)) - (int)yyformat);
    uVar4 = uVar11 + local_80;
    if ((CARRY4(uVar11,local_80)) || (bVar2 != 0)) {
      uVar4 = 0xffffffff;
    }
    else {
      if (yyresult != (char *)0x0) {
        *yyresult = yyformat[0];
        if (yyformat[0] != '\0') {
          iVar6 = 0;
          puVar7 = (uint *)yyformat;
          do {
            if (yyformat[0] == '%') {
              yyformat[0] = *(char *)((int)puVar7 + 1);
              if ((yyformat[0] != 's') || (iVar10 <= iVar6)) goto LAB_080c4be3;
              ppcVar1 = yyarg + iVar6;
              iVar6 = iVar6 + 1;
              uVar11 = yytnamerr(yyresult,*ppcVar1);
              puVar9 = (uint *)((int)puVar7 + 2);
              yyresult = yyresult + uVar11;
              yyformat[0] = *(char *)((int)puVar7 + 2);
            }
            else {
              yyformat[0] = *(char *)((int)puVar7 + 1);
LAB_080c4be3:
              puVar9 = (uint *)((int)puVar7 + 1);
              yyresult = yyresult + 1;
            }
            *yyresult = yyformat[0];
            puVar7 = puVar9;
          } while (yyformat[0] != '\0');
        }
      }
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return uVar4;
}



// WARNING: Could not reconcile some variable overlaps

int resparse(void)

{
  Resource **__dest;
  short sVar1;
  short *__dest_00;
  Resource *pRVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  short *psVar6;
  uint uVar7;
  Resource **ppRVar8;
  int in_GS_OFFSET;
  Resource *local_5a4;
  Resource *local_5a0;
  uint local_57c;
  int local_578;
  char *local_574;
  int local_570;
  short *local_56c;
  uint local_568;
  int local_564;
  Resource **local_560;
  YYSTYPE_conflict1 yyvsa [200];
  yytype_int16 yyssa [200];
  char yymsgbuf [128];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_560 = (Resource **)yyvsa;
  resnerrs = 0;
  reschar = -2;
  local_57c = 0x80;
  local_568 = 200;
  local_578 = 0;
  local_564 = 0;
  local_570 = 199;
  psVar6 = yyssa;
  local_56c = yyssa;
  ppRVar8 = local_560;
  local_574 = yymsgbuf;
  do {
    *psVar6 = (short)local_564;
    if (local_56c + local_570 <= psVar6) {
      if (local_568 < 10000) {
        uVar3 = local_568 * 2;
        local_568 = 10000;
        if (uVar3 < 0x2711) {
          local_568 = uVar3;
        }
        __dest_00 = (short *)malloc(local_568 * 6 + 3);
        if (__dest_00 != (short *)0x0) {
          iVar5 = (int)((int)psVar6 - (int)local_56c) >> 1;
          memcpy(__dest_00,local_56c,(iVar5 + 1) * 2);
          __dest = (Resource **)(__dest_00 + local_568);
          memcpy(__dest,local_560,(iVar5 + 1) * 4);
          if (yyssa != local_56c) {
            free(local_56c);
          }
          psVar6 = __dest_00 + iVar5;
          local_570 = local_568 - 1;
          local_56c = __dest_00;
          if (psVar6 < __dest_00 + local_570) {
            ppRVar8 = __dest + iVar5;
            local_560 = __dest;
            goto yybackup;
          }
LAB_080c5373:
          iVar5 = 1;
          goto LAB_080c51da;
        }
      }
LAB_080c51c9:
      iVar5 = 2;
      reserror("memory exhausted");
      goto LAB_080c51da;
    }
yybackup:
    iVar5 = (int)yypact[local_564];
    if (iVar5 != -1) {
      if (reschar == -2) {
        reschar = reslex();
      }
      if (reschar < 1) {
        reschar = 0;
        uVar3 = 0;
      }
      else {
        uVar3 = 2;
        if ((uint)reschar < 0x104) {
          uVar3 = (uint)""[reschar];
        }
      }
      uVar7 = uVar3 + iVar5;
      if ((0x19 < uVar7) || ((int)""[uVar7] != uVar3)) goto yydefault;
      iVar4 = (int)yytable[uVar7];
      if (iVar4 < 1) {
        if ((iVar4 == -8) || (iVar4 == 0)) goto yyerrlab;
        uVar3 = -iVar4;
        goto yyreduce;
      }
      if (iVar4 != 3) {
        local_578 = local_578 + -1 + (uint)(local_578 == 0);
        iVar5 = -2;
        if (reschar == 0) {
          iVar5 = reschar;
        }
        ppRVar8 = ppRVar8 + 1;
        *ppRVar8 = reslval;
        reschar = iVar5;
        local_564 = iVar4;
        goto yynewstate;
      }
yyreturn:
      iVar5 = 0;
LAB_080c51da:
      if (psVar6 != local_56c) {
        psVar6 = (short *)((int)psVar6 + (~((int)psVar6 + (-2 - (int)local_56c)) & 0xfffffffeU));
      }
LAB_080c4fdd:
      if (yyssa != psVar6) {
        free(local_56c);
      }
      if (yymsgbuf != local_574) {
        free(local_574);
      }
      if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
        return iVar5;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
yydefault:
    uVar3 = (uint)"\x02"[local_564];
    if ("\x02"[local_564] == 0) {
yyerrlab:
      if (local_578 == 0) {
        resnerrs = resnerrs + 1;
        uVar3 = yysyntax_error((char *)0x0,local_564,reschar);
        if ((local_57c < uVar3) && (local_57c != 0xffffffff)) {
          local_57c = uVar3 * 2;
          if (local_57c < uVar3) {
            local_57c = 0xffffffff;
          }
          if (yymsgbuf != local_574) {
            free(local_574);
          }
          local_574 = (char *)malloc(local_57c);
          if (local_574 == (char *)0x0) {
            local_574 = yymsgbuf;
            local_57c = 0x80;
          }
        }
        if ((local_57c < uVar3) || (uVar3 == 0)) {
          reserror("syntax error");
          if (uVar3 != 0) goto LAB_080c51c9;
        }
        else {
          yysyntax_error(local_574,local_564,reschar);
          reserror(local_574);
        }
      }
      else {
        if (local_578 == 3) {
          if (reschar < 1) {
            if (reschar == 0) goto LAB_080c5373;
          }
          else {
            reschar = -2;
          }
        }
      }
      while ((((iVar5 == -1 || (0x19 < iVar5 + 1U)) || (""[iVar5 + 1] != '\x01')) ||
             (local_564 = (int)yytable[iVar5 + 1], local_564 < 1))) {
        if (psVar6 == local_56c) {
          iVar5 = 1;
          goto LAB_080c4fdd;
        }
        psVar6 = psVar6 + -1;
        ppRVar8 = ppRVar8 + -1;
        iVar5 = (int)yypact[*psVar6];
      }
      if (local_564 != 3) {
        ppRVar8 = ppRVar8 + 1;
        local_578 = 3;
        *ppRVar8 = reslval;
        goto yynewstate;
      }
      goto yyreturn;
    }
yyreduce:
    uVar7 = (uint)""[uVar3];
    pRVar2 = ppRVar8[1 - uVar7];
    switch(uVar3) {
    case 2:
      parsed_res = resource_create((Resource *)0x0);
      current_res = parsed_res;
      break;
    case 4:
      current_res = resource_create(current_res);
      break;
    case 5:
      pRVar2 = current_res;
      current_res = current_res->parent;
      break;
    case 8:
      resource_add_val(current_res,(char *)0x0,(char *)*ppRVar8,(Resource *)0x0);
      current_res->flags = current_res->flags | 1;
      break;
    case 9:
      resource_add_val(current_res,(char *)ppRVar8[-2],(char *)*ppRVar8,(Resource *)0x0);
      current_res->flags = current_res->flags | 2;
      break;
    case 10:
      local_5a0 = (Resource *)0x0;
      local_5a4 = *ppRVar8;
      goto LAB_080c4e98;
    case 0xb:
      local_5a0 = *ppRVar8;
      local_5a4 = (Resource *)0x0;
LAB_080c4e98:
      resource_add_val(current_res,(char *)0x0,(char *)local_5a4,local_5a0);
      current_res->flags = current_res->flags | 4;
      break;
    case 0xc:
      resource_add_val(current_res,(char *)ppRVar8[-2],(char *)0x0,*ppRVar8);
      current_res->flags = current_res->flags | 8;
    }
    psVar6 = psVar6 + uVar7 * 0x7fffffff;
    sVar1 = *psVar6;
    (ppRVar8 + uVar7 * 0x3fffffff)[1] = pRVar2;
    ppRVar8 = ppRVar8 + uVar7 * 0x3fffffff + 1;
    uVar7 = (int)sVar1 + (int)(char)""[(uint)""[uVar3] + 6];
    if ((uVar7 < 0x1a) && (sVar1 == (short)""[uVar7])) {
      local_564 = (int)yytable[uVar7];
    }
    else {
      local_564 = (int)(char)""[(uint)""[uVar3] + 0xd];
    }
yynewstate:
    psVar6 = psVar6 + 1;
  } while( true );
}



Resource * resource_parse(char *filename,char **strings)

{
  int iVar1;
  
  res_lineno = 1;
  if (filename == (char *)0x0) {
    if (strings == (char **)0x0) {
      res_lineno = 1;
      return (Resource *)0x0;
    }
    res_filename = (char *)0x0;
    res_string_idx = 0;
    res_strings = strings;
  }
  else {
    res_filename = filename;
    res_file = (FILE *)fopen(filename,"r");
    if (res_file == (FILE *)0x0) {
      perror(filename);
      return (Resource *)0x0;
    }
  }
  iVar1 = resparse();
  if (iVar1 == 0) {
    if (filename == (char *)0x0) {
      res_strings = (char **)0x0;
    }
    else {
      fclose((FILE *)res_file);
    }
    return parsed_res;
  }
  return (Resource *)0x0;
}



void res_switch_to_buffer(YY_BUFFER_STATE new_buffer)

{
  if (yy_current_buffer != new_buffer) {
    if (yy_current_buffer != (YY_BUFFER_STATE)0x0) {
      *yy_c_buf_p = yy_hold_char;
      yy_current_buffer->yy_buf_pos = yy_c_buf_p;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }
    yy_n_chars = new_buffer->yy_n_chars;
    yy_current_buffer = new_buffer;
    yy_c_buf_p = new_buffer->yy_buf_pos;
    resin = new_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    yy_did_buffer_switch_on_eof = 1;
    restext = yy_c_buf_p;
  }
  return;
}



void res_load_buffer_state(void)

{
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  resin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  yy_n_chars = yy_current_buffer->yy_n_chars;
  restext = yy_c_buf_p;
  return;
}



void res_flush_buffer(YY_BUFFER_STATE b)

{
  char *pcVar1;
  bool bVar2;
  
  if (b != (YY_BUFFER_STATE)0x0) {
    b->yy_n_chars = 0;
    *b->yy_ch_buf = '\0';
    b->yy_ch_buf[1] = '\0';
    pcVar1 = b->yy_ch_buf;
    bVar2 = b == yy_current_buffer;
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    b->yy_buf_pos = pcVar1;
    if (bVar2) {
      resin = b->yy_input_file;
      yy_c_buf_p = pcVar1;
      yy_hold_char = *pcVar1;
      yy_n_chars = b->yy_n_chars;
      restext = pcVar1;
      return;
    }
  }
  return;
}



void __regparm3 yy_fatal_error(char *msg)

{
  __fprintf_chk(stderr,1,&DAT_08148577,msg);
                    // WARNING: Subroutine does not return
  exit(2);
}



YY_BUFFER_STATE res_scan_buffer(char *base,yy_size_t size)

{
  YY_BUFFER_STATE new_buffer;
  
  if (((size < 2) || (base[size - 2] != '\0')) || (base[size - 1] != '\0')) {
    new_buffer = (YY_BUFFER_STATE)0x0;
  }
  else {
    new_buffer = (YY_BUFFER_STATE)malloc(0x28);
    if (new_buffer == (YY_BUFFER_STATE)0x0) {
      yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
    new_buffer->yy_buf_size = size - 2;
    new_buffer->yy_ch_buf = base;
    new_buffer->yy_buf_pos = base;
    new_buffer->yy_is_our_buffer = 0;
    new_buffer->yy_input_file = (FILE *)0x0;
    new_buffer->yy_n_chars = size - 2;
    new_buffer->yy_is_interactive = 0;
    new_buffer->yy_at_bol = 1;
    new_buffer->yy_fill_buffer = 0;
    new_buffer->yy_buffer_status = 0;
    res_switch_to_buffer(new_buffer);
  }
  return new_buffer;
}



YY_BUFFER_STATE res_scan_bytes(char *bytes,yy_size_t len)

{
  char *base;
  uint uVar1;
  YY_BUFFER_STATE pyVar2;
  
  base = (char *)malloc(len + 2);
  if (base == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
  if (len != 0) {
    uVar1 = 0;
    do {
      base[uVar1] = bytes[uVar1];
      uVar1 = uVar1 + 1;
    } while (uVar1 < len);
  }
  base[len + 1] = '\0';
  base[len] = '\0';
  pyVar2 = res_scan_buffer(base,len + 2);
  if (pyVar2 == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
  pyVar2->yy_is_our_buffer = 1;
  return pyVar2;
}



YY_BUFFER_STATE res_scan_string(char *yy_str)

{
  char cVar1;
  yy_size_t len;
  YY_BUFFER_STATE pyVar2;
  
  len = 0;
  cVar1 = *yy_str;
  while (cVar1 != '\0') {
    len = len + 1;
    cVar1 = yy_str[len];
  }
  pyVar2 = res_scan_bytes(yy_str,len);
  return pyVar2;
}



void res_init_buffer(YY_BUFFER_STATE b,FILE *file)

{
  int __fd;
  int iVar1;
  
  res_flush_buffer(b);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  if (file != (FILE *)0x0) {
    __fd = fileno((FILE *)file);
    __fd = isatty(__fd);
    iVar1 = 1;
    if (0 < __fd) goto LAB_080c5770;
  }
  iVar1 = 0;
LAB_080c5770:
  b->yy_is_interactive = iVar1;
  return;
}



YY_BUFFER_STATE res_create_buffer(FILE *file,int size)

{
  YY_BUFFER_STATE b;
  char *pcVar1;
  
  b = (YY_BUFFER_STATE)malloc(0x28);
  if (b == (YY_BUFFER_STATE)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_buf_size = size;
  pcVar1 = (char *)malloc(size + 2);
  b->yy_ch_buf = pcVar1;
  if (pcVar1 == (char *)0x0) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_is_our_buffer = 1;
  res_init_buffer(b,file);
  return b;
}



void resrestart(FILE *input_file)

{
  if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
    yy_current_buffer = res_create_buffer(resin,0x4000);
  }
  res_init_buffer(yy_current_buffer,input_file);
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  resin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  yy_n_chars = yy_current_buffer->yy_n_chars;
  restext = yy_c_buf_p;
  return;
}



void res_delete_buffer(YY_BUFFER_STATE b)

{
  if (b == (YY_BUFFER_STATE)0x0) {
    return;
  }
  if (b == yy_current_buffer) {
    yy_current_buffer = (YY_BUFFER_STATE)0x0;
  }
  if (b->yy_is_our_buffer == 0) {
    free(b);
    return;
  }
  free(b->yy_ch_buf);
  free(b);
  return;
}



int reslex(void)

{
  FILE *pFVar1;
  char *pcVar2;
  int iVar3;
  char *__s;
  size_t sVar4;
  char *pcVar5;
  short sVar6;
  int max_size;
  int iVar7;
  byte bVar8;
  byte *pbVar9;
  char *pcVar10;
  YY_BUFFER_STATE local_28;
  byte *local_24;
  yy_state_type *local_20;
  
  if (yy_init != 0) {
    yy_init = 0;
    iVar3 = 1;
    if (yy_start != 0) {
      iVar3 = yy_start;
    }
    if (resin == (FILE *)0x0) {
      resin = stdin;
    }
    if (resout == (FILE *)0x0) {
      resout = stdout;
    }
    yy_start = iVar3;
    if (yy_current_buffer == (YY_BUFFER_STATE)0x0) {
      yy_current_buffer = res_create_buffer(resin,0x4000);
    }
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    resin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
  }
LAB_080c596c:
  *yy_c_buf_p = yy_hold_char;
  local_20 = yy_state_buf + 1;
  yy_state_buf[0] = yy_start;
  iVar3 = yy_start;
  local_24 = (byte *)yy_c_buf_p;
LAB_080c598c:
  sVar6 = yy_base[iVar3];
  do {
    bVar8 = *(byte *)(yy_ec + (byte)*yy_c_buf_p);
    while( true ) {
      iVar7 = (uint)bVar8 + (int)sVar6;
      if ((int)yy_chk[iVar7] == iVar3) break;
      iVar3 = (int)yy_def[iVar3];
      if (0x1b < iVar3) {
        bVar8 = *(byte *)(yy_meta + (uint)bVar8);
      }
      sVar6 = yy_base[iVar3];
    }
    iVar3 = (int)yy_nxt[iVar7];
    yy_c_buf_p = (char *)((byte *)yy_c_buf_p + 1);
    *local_20 = iVar3;
    yy_state_ptr = local_20 + 1;
    sVar6 = yy_base[iVar3];
    pbVar9 = (byte *)yy_c_buf_p;
    local_20 = yy_state_ptr;
  } while (sVar6 != 0x39);
LAB_080c5a0b:
  iVar3 = yy_state_ptr[-1];
  yy_state_ptr = yy_state_ptr + -1;
  sVar6 = yy_accept[iVar3];
  while ((yy_lp = (int)sVar6, yy_lp == 0 || (yy_accept[iVar3 + 1] <= yy_lp))) {
    yy_state_ptr = yy_state_ptr + -1;
    pbVar9 = pbVar9 + -1;
    iVar3 = *yy_state_ptr;
    sVar6 = yy_accept[iVar3];
  }
  iVar3 = (int)yy_acclist[yy_lp];
  restext = (char *)local_24;
  resleng = (int)(pbVar9 + -(int)local_24);
  yy_hold_char = *pbVar9;
  yy_full_match = (char *)pbVar9;
  *pbVar9 = 0;
  yy_c_buf_p = (char *)pbVar9;
  if ((iVar3 != 9) && (0 < resleng)) {
    iVar7 = 0;
    do {
      while (restext[iVar7] == '\n') {
        iVar7 = iVar7 + 1;
        reslineno = reslineno + 1;
        if (iVar7 == resleng) goto LAB_080c5abd;
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 != resleng);
  }
LAB_080c5abd:
  switch(iVar3) {
  default:
    yy_fatal_error("fatal flex scanner internal error--no action found");
    goto LAB_080c596c;
  case 1:
  case 2:
    __s = (char *)__strdup(restext + 1);
    reslval = __s;
    sVar4 = strlen(__s);
    __s[sVar4 - 1] = '\0';
    return 0x102;
  case 3:
    res_lineno = res_lineno + 1;
    goto LAB_080c596c;
  case 4:
    res_lineno = res_lineno + (uint)(*restext == '\n');
    goto LAB_080c596c;
  case 5:
    reslval = (char *)__strdup(restext);
    return 0x103;
  case 6:
    reslval = (char *)__strdup(restext);
    return 0x102;
  case 7:
    return (int)*restext;
  case 8:
    fwrite(restext,resleng,1,(FILE *)resout);
    goto LAB_080c596c;
  case 9:
    break;
  case 10:
    return 0;
  }
  iVar3 = -1 - (int)restext;
  *pbVar9 = yy_hold_char;
  local_28 = yy_current_buffer;
  pFVar1 = resin;
  if (yy_current_buffer->yy_buffer_status == 0) {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yy_current_buffer->yy_buffer_status = 1;
    local_28->yy_input_file = pFVar1;
  }
  pcVar2 = restext;
  __s = local_28->yy_ch_buf;
  if (__s + yy_n_chars < yy_c_buf_p) {
    if (__s + yy_n_chars + 1 < yy_c_buf_p) {
      yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
      local_28 = yy_current_buffer;
    }
    if (local_28->yy_fill_buffer == 0) {
      local_20 = (yy_state_type *)restext;
      if (yy_c_buf_p + -(int)restext != &DAT_00000001) goto LAB_080c5c47;
    }
    else {
      pcVar10 = yy_c_buf_p + (-1 - (int)restext);
      if (0 < (int)pcVar10) {
        pcVar5 = (char *)0x0;
        do {
          __s[(int)pcVar5] = pcVar2[(int)pcVar5];
          pcVar5 = pcVar5 + 1;
          local_28 = yy_current_buffer;
        } while (pcVar5 != pcVar10);
      }
      if (local_28->yy_buffer_status == 2) {
        yy_n_chars = 0;
        local_28->yy_n_chars = 0;
      }
      else {
        iVar7 = ~(uint)pcVar10 + local_28->yy_buf_size;
        if (iVar7 < 1) {
          do {
            yy_fatal_error(
                          "input buffer overflow, can\'t enlarge buffer because scanner uses REJECT"
                          );
          } while( true );
        }
        max_size = 0x2000;
        if (iVar7 < 0x2001) {
          max_size = iVar7;
        }
        yy_n_chars = res_parse_getchars(local_28->yy_ch_buf + (int)pcVar10,max_size);
        local_28 = yy_current_buffer;
        yy_current_buffer->yy_n_chars = yy_n_chars;
      }
      iVar7 = 0;
      if (yy_n_chars == 0) {
        if (pcVar10 == (char *)0x0) {
          resrestart(resin);
          iVar7 = 1;
          local_28 = yy_current_buffer;
        }
        else {
          local_28->yy_buffer_status = 2;
          iVar7 = 2;
        }
      }
      yy_n_chars = (int)(pcVar10 + yy_n_chars);
      local_28->yy_ch_buf[yy_n_chars] = '\0';
      yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = '\0';
      local_28 = yy_current_buffer;
      restext = yy_current_buffer->yy_ch_buf;
      local_20 = (yy_state_type *)restext;
      if (iVar7 != 1) {
        if (iVar7 != 2) {
          yy_c_buf_p = (char *)((byte *)restext + (int)(pbVar9 + iVar3));
          yy_state_ptr = yy_state_buf + 1;
          yy_state_buf[0] = yy_start;
          iVar3 = yy_start;
          local_24 = (byte *)restext;
          if (restext < yy_c_buf_p) {
            local_20 = yy_state_buf + 1;
            do {
              bVar8 = 1;
              if (*local_24 != 0) {
                bVar8 = *(byte *)(yy_ec + *local_24);
              }
              while( true ) {
                iVar7 = (int)yy_base[iVar3] + (uint)bVar8;
                if (iVar3 == (int)yy_chk[iVar7]) break;
                iVar3 = (int)yy_def[iVar3];
                if (0x1b < iVar3) {
                  bVar8 = *(byte *)(yy_meta + (uint)bVar8);
                }
              }
              iVar3 = (int)yy_nxt[iVar7];
              local_24 = local_24 + 1;
              *local_20 = iVar3;
              yy_state_ptr = local_20 + 1;
              local_20 = yy_state_ptr;
            } while (local_24 < yy_c_buf_p);
            local_24 = (byte *)restext;
          }
          goto LAB_080c5eb8;
        }
LAB_080c5c47:
        yy_state_ptr = yy_state_buf + 1;
        pbVar9 = (byte *)(local_28->yy_ch_buf + yy_n_chars);
        yy_state_buf[0] = yy_start;
        local_24 = (byte *)local_20;
        if (local_20 < pbVar9) {
          local_28 = (YY_BUFFER_STATE)(yy_state_buf + 1);
          iVar3 = yy_start;
          do {
            bVar8 = 1;
            if (*local_24 != 0) {
              bVar8 = *(byte *)(yy_ec + *local_24);
            }
            while( true ) {
              iVar7 = (int)yy_base[iVar3] + (uint)bVar8;
              if (iVar3 == (int)yy_chk[iVar7]) break;
              iVar3 = (int)yy_def[iVar3];
              if (0x1b < iVar3) {
                bVar8 = *(byte *)(yy_meta + (uint)bVar8);
              }
            }
            iVar3 = (int)yy_nxt[iVar7];
            local_24 = local_24 + 1;
            *(int *)local_28 = iVar3;
            yy_state_ptr = (yy_state_type *)local_28 + 1;
            local_28 = (YY_BUFFER_STATE)yy_state_ptr;
          } while (local_24 < pbVar9);
          local_24 = (byte *)local_20;
        }
        goto LAB_080c5a0b;
      }
    }
    yy_did_buffer_switch_on_eof = 0;
    yy_c_buf_p = (char *)local_20;
    iVar3 = (yy_start + -1) / 2 + 10;
    restext = (char *)local_20;
    goto LAB_080c5abd;
  }
  pbVar9 = (byte *)(restext + (int)(pbVar9 + iVar3));
  local_24 = (byte *)restext;
  yy_state_ptr = yy_state_buf;
  yy_state_buf[0] = yy_start;
  iVar3 = yy_start;
  yy_c_buf_p = (char *)pbVar9;
  while (yy_state_ptr = yy_state_ptr + 1, local_24 < pbVar9) {
    bVar8 = 1;
    if (*local_24 != 0) {
      bVar8 = *(byte *)(yy_ec + *local_24);
    }
    while( true ) {
      iVar7 = (int)yy_base[iVar3] + (uint)bVar8;
      if (iVar3 == (int)yy_chk[iVar7]) break;
      iVar3 = (int)yy_def[iVar3];
      if (0x1b < iVar3) {
        bVar8 = *(byte *)(yy_meta + (uint)bVar8);
      }
    }
    iVar3 = (int)yy_nxt[iVar7];
    local_24 = local_24 + 1;
    *yy_state_ptr = iVar3;
  }
  while( true ) {
    iVar7 = (int)yy_base[iVar3];
    if (iVar3 == (int)*(short *)(iVar7 + 0x814f2e1 + iVar7 + 1)) break;
    iVar3 = (int)yy_def[iVar3];
  }
  iVar3 = (int)*(short *)(iVar7 + 0x814f381 + iVar7 + 1);
  local_24 = (byte *)restext;
  if (iVar3 == 0x1b) goto LAB_080c5a0b;
  *yy_state_ptr = iVar3;
  yy_state_ptr = yy_state_ptr + 1;
  pbVar9 = (byte *)yy_c_buf_p;
  if (iVar3 == 0) goto LAB_080c5a0b;
  yy_c_buf_p = yy_c_buf_p + 1;
LAB_080c5eb8:
  local_20 = yy_state_ptr;
  goto LAB_080c598c;
}



void RotatePointLowLevel(PointTypePtr Point,LocationType X,LocationType Y,BYTE Number)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  
  bVar1 = Number & 3;
  iVar2 = Point->X - X;
  iVar3 = Point->Y - Y;
  if (bVar1 == 2) {
    Point->X = X - iVar2;
    Point->Y = Y - iVar3;
  }
  else {
    if (bVar1 == 3) {
      Point->X = X - iVar3;
      Point->Y = Y + iVar2;
    }
    else {
      if (bVar1 == 1) {
        Point->X = iVar3 + X;
        Point->Y = Y - iVar2;
      }
    }
  }
  return;
}



void RotateBoxLowLevel(BoxTypePtr Box,LocationType X,LocationType Y,BYTE Number)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  byte bVar5;
  int iVar6;
  int iVar7;
  int local_18;
  int local_14;
  
  iVar4 = Box->X1;
  iVar1 = Box->Y1;
  iVar3 = Box->X2;
  iVar2 = Box->Y2;
  iVar6 = iVar4 - X;
  iVar7 = iVar1 - Y;
  bVar5 = Number & 3;
  if (bVar5 == 2) {
    local_18 = iVar3 - X;
    local_14 = iVar2 - Y;
    iVar4 = X - iVar6;
    iVar1 = Y - iVar7;
LAB_080c6200:
    iVar3 = X - local_18;
    iVar2 = Y - local_14;
  }
  else {
    if (bVar5 == 3) {
      local_18 = iVar3 - X;
      local_14 = iVar2 - Y;
      iVar4 = X - iVar7;
      iVar1 = Y + iVar6;
LAB_080c6228:
      iVar3 = X - local_14;
      iVar2 = local_18 + Y;
      goto LAB_080c61b4;
    }
    if (bVar5 == 1) {
      local_18 = iVar3 - X;
      local_14 = iVar2 - Y;
      iVar4 = iVar7 + X;
      iVar1 = Y - iVar6;
    }
    else {
      local_18 = iVar3 - X;
      local_14 = iVar2 - Y;
      if (bVar5 == 2) goto LAB_080c6200;
      if (bVar5 == 3) goto LAB_080c6228;
      if (bVar5 != 1) goto LAB_080c61b4;
    }
    iVar3 = local_14 + X;
    iVar2 = Y - local_18;
  }
LAB_080c61b4:
  iVar6 = iVar3;
  if (iVar4 <= iVar3) {
    iVar6 = iVar4;
  }
  Box->X1 = iVar6;
  iVar6 = iVar2;
  if (iVar1 <= iVar2) {
    iVar6 = iVar1;
  }
  if (iVar3 <= iVar4) {
    iVar3 = iVar4;
  }
  if (iVar2 <= iVar1) {
    iVar2 = iVar1;
  }
  Box->Y1 = iVar6;
  Box->X2 = iVar3;
  Box->Y2 = iVar2;
  return;
}



void RotateArcLowLevel(ArcTypePtr *Arc,LocationType X,LocationType Y,BYTE Number)

{
  LocationType LVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  
  iVar2 = Arc->X - X;
  Arc->StartAngle = (int)((uint)Number * 0x5a + Arc->StartAngle) % 0x168;
  uVar4 = (uint)Number & 3;
  iVar3 = Arc->Y - Y;
  if (uVar4 == 2) {
    Arc->X = X - iVar2;
    Arc->Y = Y - iVar3;
  }
  else {
    if (uVar4 == 3) {
      Arc->Y = Y + iVar2;
      Arc->X = X - iVar3;
    }
    else {
      if (uVar4 == 1) {
        Arc->X = iVar3 + X;
        Arc->Y = Y - iVar2;
      }
    }
  }
  if ((Number == '\x03') || (Number == '\x01')) {
    LVar1 = Arc->Height;
    Arc->Height = Arc->Width;
    Arc->Width = LVar1;
  }
  RotateBoxLowLevel((BoxTypePtr)Arc,X,Y,Number);
  return;
}



void RotatePolygonLowLevel(PolygonTypePtr Polygon,LocationType X,LocationType Y,BYTE Number)

{
  PointTypePtr pPVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  byte bVar5;
  
  iVar4 = Polygon->PointN - 1;
  if (iVar4 != -1) {
    bVar5 = Number & 3;
    pPVar1 = Polygon->Points + (Polygon->PointN - 1);
    do {
      while( true ) {
        iVar2 = pPVar1->X - X;
        iVar3 = pPVar1->Y - Y;
        if (bVar5 != 2) break;
        iVar4 = iVar4 + -1;
        pPVar1->X = X - iVar2;
        pPVar1->Y = Y - iVar3;
        pPVar1 = pPVar1 + -1;
        if (iVar4 == -1) goto LAB_080c63c7;
      }
      if (bVar5 == 3) {
        pPVar1->X = X - iVar3;
        pPVar1->Y = Y + iVar2;
      }
      else {
        if (bVar5 == 1) {
          pPVar1->X = iVar3 + X;
          pPVar1->Y = Y - iVar2;
        }
      }
      iVar4 = iVar4 + -1;
      pPVar1 = pPVar1 + -1;
    } while (iVar4 != -1);
  }
LAB_080c63c7:
  RotateBoxLowLevel((BoxTypePtr)Polygon,X,Y,Number);
  return;
}



void RotateTextLowLevel(TextTypePtr Text,LocationType X,LocationType Y,BYTE Number)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  byte bVar4;
  
  bVar4 = Number;
  if (*(char *)&(Text->Flags).f < '\0') {
    bVar4 = -Number & 3;
  }
  RotateBoxLowLevel((BoxTypePtr)Text,X,Y,Number);
  iVar3 = Text->Y - Y;
  bVar2 = Number & 3;
  iVar1 = Text->X - X;
  if (bVar2 == 2) {
    Text->X = X - iVar1;
    Text->Y = Y - iVar3;
  }
  else {
    if (bVar2 == 3) {
      Text->X = X - iVar3;
      Text->Y = iVar1 + Y;
    }
    else {
      if (bVar2 == 1) {
        Text->X = iVar3 + X;
        Text->Y = Y - iVar1;
      }
    }
  }
  Text->Direction = bVar4 + Text->Direction & 3;
  return;
}



void RotateLineLowLevel(LineTypePtr Line,LocationType X,LocationType Y,BYTE Number)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  local_30 = (Line->Point1).Y;
  iVar3 = (Line->Point1).X;
  iVar2 = local_30 - Y;
  iVar4 = iVar3 - X;
  bVar1 = Number & 3;
  if (bVar1 == 2) {
    iVar3 = X - iVar4;
    local_30 = Y - iVar2;
    (Line->Point1).X = iVar3;
    local_28 = (Line->Point2).X - X;
    (Line->Point1).Y = local_30;
    local_24 = (Line->Point2).Y - Y;
LAB_080c65ba:
    local_20 = X - local_28;
    local_2c = Y - local_24;
    (Line->Point2).X = local_20;
    (Line->Point2).Y = local_2c;
    if (iVar3 == local_20) goto LAB_080c65d1;
  }
  else {
    if (bVar1 == 3) {
      local_28 = (Line->Point2).X;
      iVar3 = X - iVar2;
      local_30 = Y + iVar4;
      (Line->Point1).Y = local_30;
      local_28 = local_28 - X;
      local_24 = (Line->Point2).Y;
      (Line->Point1).X = iVar3;
      local_24 = local_24 - Y;
LAB_080c6619:
      local_20 = X - local_24;
      local_2c = Y + local_28;
      (Line->Point2).X = local_20;
      (Line->Point2).Y = local_2c;
    }
    else {
      if (bVar1 == 1) {
        local_30 = Y - iVar4;
        (Line->Point1).Y = local_30;
        iVar3 = iVar2 + X;
        (Line->Point1).X = iVar3;
        local_28 = (Line->Point2).X - X;
        local_24 = (Line->Point2).Y - Y;
LAB_080c6564:
        local_20 = X + local_24;
        local_2c = Y - local_28;
        (Line->Point2).X = local_20;
        (Line->Point2).Y = local_2c;
      }
      else {
        local_20 = (Line->Point2).X;
        local_28 = local_20 - X;
        local_2c = (Line->Point2).Y;
        local_24 = local_2c - Y;
        if (bVar1 == 2) goto LAB_080c65ba;
        if (bVar1 == 3) goto LAB_080c6619;
        if (bVar1 == 1) goto LAB_080c6564;
      }
    }
    if (iVar3 == local_20) {
LAB_080c65d1:
      if (local_2c < local_30) {
        (Line->Point1).Y = local_2c;
        (Line->Point2).Y = local_30;
      }
      goto LAB_080c6583;
    }
  }
  if ((local_30 == local_2c) && (local_20 < iVar3)) {
    (Line->Point2).X = iVar3;
    (Line->Point1).X = local_20;
  }
LAB_080c6583:
  SetLineBoundingBox(Line);
  return;
}



void * RotateLinePoint(LayerTypePtr Layer,LineTypePtr Line,PointTypePtr Point)

{
  EraseLine(Line);
  if (Layer != (LayerTypePtr)0x0) {
    RestoreToPolygon((DataType *)PCB->Data,4,Layer,Line);
    r_delete_entry(Layer->line_tree,(BoxType *)Line);
    RotatePointLowLevel(Point,CenterX,CenterY,Number);
    SetLineBoundingBox(Line);
    r_insert_entry(Layer->line_tree,(BoxType *)Line,0);
    ClearFromPolygon((DataType *)PCB->Data,4,Layer,Line);
    DrawLine(Layer,Line,0);
    Draw();
    return Line;
  }
  r_delete_entry(PCB->Data->rat_tree,(BoxType *)Line);
  RotatePointLowLevel(Point,CenterX,CenterY,Number);
  SetLineBoundingBox(Line);
  r_insert_entry(PCB->Data->rat_tree,(BoxType *)Line,0);
  DrawRat((RatTypePtr *)Line,0);
  Draw();
  return Line;
}



void * RotateObject(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType X,LocationType Y,
                   BYTE Steps)

{
  FlagType *pFVar1;
  bool bVar2;
  LocationType CenterX;
  LocationType CenterY;
  void *pvVar3;
  RubberbandTypePtr *pRVar4;
  
  bVar2 = false;
  Number = Steps;
  CenterX = X;
  CenterY = Y;
  pRVar4 = Crosshair.AttachedObject.Rubberband;
  if (Crosshair.AttachedObject.RubberbandN != 0) {
    while( true ) {
      CenterY = CenterY;
      CenterX = CenterX;
      pFVar1 = &pRVar4->Line->Flags;
      pFVar1->f = pFVar1->f & 0xfffffdff;
      AddObjectToRotateUndoList
                (0x1000,pRVar4->Layer,pRVar4->Line,pRVar4->MovedPoint,CenterX,CenterY,Steps);
      EraseLine(pRVar4->Line);
      if (pRVar4->Layer == (LayerTypePtr)0x0) {
        r_delete_entry(PCB->Data->rat_tree,(BoxType *)pRVar4->Line);
      }
      else {
        RestoreToPolygon((DataType *)PCB->Data,4,pRVar4->Layer,pRVar4->Line);
        r_delete_entry(pRVar4->Layer->line_tree,(BoxType *)pRVar4->Line);
      }
      RotatePointLowLevel(pRVar4->MovedPoint,CenterX,CenterY,Steps);
      SetLineBoundingBox(pRVar4->Line);
      if (pRVar4->Layer == (LayerTypePtr)0x0) {
        r_insert_entry(PCB->Data->rat_tree,(BoxType *)pRVar4->Line,0);
        DrawRat((RatTypePtr *)pRVar4->Line,0);
      }
      else {
        r_insert_entry(pRVar4->Layer->line_tree,(BoxType *)pRVar4->Line,0);
        ClearFromPolygon((DataType *)PCB->Data,4,pRVar4->Layer,pRVar4->Line);
        DrawLine(pRVar4->Layer,pRVar4->Line,0);
      }
      Crosshair.AttachedObject.RubberbandN = Crosshair.AttachedObject.RubberbandN - 1;
      if (Crosshair.AttachedObject.RubberbandN == 0) break;
      pRVar4 = pRVar4 + 1;
    }
    bVar2 = true;
  }
  AddObjectToRotateUndoList(Type,Ptr1,Ptr2,Ptr3,CenterX,CenterY,Number);
  pvVar3 = ObjectOperation((ObjectFunctionTypePtr *)&RotateFunctions,Type,Ptr1,Ptr2,Ptr3);
  if ((pvVar3 == (void *)0x0) && (!bVar2)) {
    return (void *)0x0;
  }
  Draw();
  IncrementUndoSerialNumber();
  return pvVar3;
}



void RotateScreenObject(LocationType X,LocationType Y,BYTE Steps)

{
  int Type;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  Type = SearchScreen(X,Y,0x4412,local_20,&local_24,&local_28);
  if (Type != 0) {
    if ((*(byte *)((int)local_24 + 0x15) & 0x20) == 0) {
      Crosshair.AttachedObject.RubberbandN = 0;
      if ((*(byte *)&(PCB->Flags).f & 0x10) != 0) {
        LookupRubberbandLines(Type,local_20[0],local_24,local_28);
      }
      if (Type == 2) {
        LookupRatLines(2,local_20[0],local_24,local_28);
      }
      RotateObject(Type,local_20[0],local_24,local_28,X,Y,Steps);
      SetChangedFlag('\x01');
    }
    else {
      Message("Sorry, the object is locked\n");
    }
  }
  return;
}



void * RotateArc(LayerTypePtr Layer,ArcTypePtr *Arc)

{
  EraseArc(Arc);
  r_delete_entry(Layer->arc_tree,(BoxType *)Arc);
  RotateArcLowLevel(Arc,CenterX,CenterY,Number);
  r_insert_entry(Layer->arc_tree,(BoxType *)Arc,0);
  DrawArc(Layer,Arc,0);
  Draw();
  return Arc;
}



void * RotateElementName(ElementTypePtr *Element)

{
  TextTypePtr Text;
  int iVar1;
  int iVar2;
  
  EraseElementName(Element);
  iVar1 = 2;
  do {
    iVar2 = iVar1 + -1;
    Text = (TextTypePtr)(Element->Name + iVar1);
    r_delete_entry((rtree_t *)(&PCB->Data->ElementN)[iVar1 + 0xc],(BoxType *)Text);
    RotateTextLowLevel(Text,CenterX,CenterY,Number);
    r_insert_entry((rtree_t *)(&PCB->Data->ElementN)[iVar1 + 0xc],(BoxType *)Text,0);
    iVar1 = iVar2;
  } while (iVar2 != -1);
  DrawElementName(Element,0);
  Draw();
  return Element;
}



void * RotateText(LayerTypePtr Layer,TextTypePtr Text)

{
  EraseText(Layer,Text);
  RestoreToPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  r_delete_entry(Layer->text_tree,(BoxType *)Text);
  RotateTextLowLevel(Text,CenterX,CenterY,Number);
  r_insert_entry(Layer->text_tree,(BoxType *)Text,0);
  ClearFromPolygon((DataType *)PCB->Data,0x10,Layer,Text);
  DrawText(Layer,Text,0);
  Draw();
  return Text;
}



void RotateElementLowLevel
               (DataTypePtr *Data,ElementTypePtr *Element,LocationType X,LocationType Y,BYTE Number)

{
  TextTypePtr Text;
  uint uVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;
  int iVar5;
  PinTypePtr *ptr2;
  PadTypePtr *ptr2_00;
  uint local_28;
  
  iVar5 = 2;
  do {
    Text = (TextTypePtr)(Element->Name + iVar5);
    if ((Data != (DataTypePtr *)0x0) && (Data->name_tree[iVar5] != (rtree_t *)0x0)) {
      r_delete_entry(Data->name_tree[iVar5],(BoxType *)Text);
    }
    iVar5 = iVar5 + -1;
    RotateTextLowLevel(Text,X,Y,Number);
  } while (iVar5 != -1);
  iVar5 = Element->LineN - 1;
  if (iVar5 != -1) {
    iVar2 = Element->LineN * 0x58;
    do {
      iVar5 = iVar5 + -1;
      RotateLineLowLevel((LineTypePtr)((int)&Element->Line[-1].BoundingBox.X1 + iVar2),X,Y,Number);
      iVar2 = iVar2 + -0x58;
    } while (iVar5 != -1);
  }
  if (Element->PinN != 0) {
    bVar3 = Number & 3;
    uVar4 = 0;
    local_28 = Element->PinN;
    do {
      ptr2 = Element->Pin + uVar4;
      if (Data != (DataTypePtr *)0x0) {
        r_delete_entry(Data->pin_tree,(BoxType *)ptr2);
      }
      RestoreToPolygon((DataType *)Data,0x100,Element,ptr2);
      iVar5 = ptr2->X - X;
      iVar2 = ptr2->Y - Y;
      if (bVar3 == 2) {
        ptr2->X = X - iVar5;
        ptr2->Y = Y - iVar2;
        uVar1 = Element->PinN;
      }
      else {
        if (bVar3 == 3) {
          ptr2->X = X - iVar2;
          ptr2->Y = iVar5 + Y;
        }
        else {
          if (bVar3 == 1) {
            ptr2->X = iVar2 + X;
            ptr2->Y = Y - iVar5;
          }
        }
        uVar1 = Element->PinN;
      }
    } while ((uVar1 != 0) &&
            (uVar4 = (uVar1 + 1 + uVar4) - local_28, local_28 = uVar1, uVar4 < uVar1));
  }
  bVar3 = Number & 3;
  uVar4 = Element->PadN;
  local_28 = 0;
  uVar1 = uVar4;
  while ((uVar1 != 0 && (local_28 < uVar1))) {
    ptr2_00 = Element->Pad + local_28;
    if (Data != (DataTypePtr *)0x0) {
      r_delete_entry(Data->pad_tree,(BoxType *)ptr2_00);
    }
    RestoreToPolygon((DataType *)Data,0x200,Element,ptr2_00);
    RotateLineLowLevel((LineTypePtr)ptr2_00,X,Y,Number);
    uVar1 = Element->PadN;
    if (Element->PadN == uVar4) {
      local_28 = local_28 + 1;
      uVar1 = uVar4;
    }
  }
  iVar5 = Element->ArcN - 1;
  if (iVar5 != -1) {
    iVar2 = Element->ArcN * 0x44;
    do {
      iVar5 = iVar5 + -1;
      RotateArcLowLevel((ArcTypePtr *)((int)&Element->Arc[-1].BoundingBox.X1 + iVar2),X,Y,Number);
      iVar2 = iVar2 + -0x44;
    } while (iVar5 != -1);
  }
  iVar2 = Element->MarkX - X;
  iVar5 = Element->MarkY - Y;
  if (bVar3 == 2) {
    Element->MarkX = X - iVar2;
    Element->MarkY = Y - iVar5;
  }
  else {
    if (bVar3 == 3) {
      Element->MarkX = X - iVar5;
      Element->MarkY = iVar2 + Y;
    }
    else {
      if (bVar3 == 1) {
        Element->MarkX = iVar5 + X;
        Element->MarkY = Y - iVar2;
      }
    }
  }
  SetElementBoundingBox(Data,(ElementTypePtr_conflict)Element,(FontTypePtr)&PCB->Font);
  ClearFromPolygon((DataType *)Data,2,Element,Element);
  return;
}



void * RotateElement(ElementTypePtr *Element)

{
  EraseElement(Element);
  RotateElementLowLevel(PCB->Data,Element,CenterX,CenterY,Number);
  DrawElement(Element,0);
  Draw();
  return Element;
}



void __regparm3 adjust_bounds(rtree_node *node)

{
  LocationType *pLVar1;
  int *piVar2;
  rtree_node *prVar3;
  
  if ((*(byte *)&node->flags & 1) == 0) {
    pLVar1 = *(LocationType **)node->u;
    (node->box).X1 = *pLVar1;
    (node->box).Y1 = pLVar1[1];
    (node->box).X2 = pLVar1[2];
    (node->box).Y2 = pLVar1[3];
    prVar3 = node;
    while (piVar2 = *(int **)(prVar3->u + 4), piVar2 != (int *)0x0) {
      if (*piVar2 < (node->box).X1) {
        (node->box).X1 = *piVar2;
      }
      if ((node->box).X2 < piVar2[2]) {
        (node->box).X2 = piVar2[2];
      }
      if (piVar2[1] < (node->box).Y1) {
        (node->box).Y1 = piVar2[1];
      }
      if ((node->box).Y2 < piVar2[3]) {
        (node->box).Y2 = piVar2[3];
      }
      prVar3 = (rtree_node *)&(prVar3->box).Y1;
      if (prVar3 == (rtree_node *)node->u) {
        return;
      }
    }
  }
  else {
    (node->box).X1 = *(LocationType *)(node->u + 4);
    (node->box).Y1 = *(LocationType *)(node->u + 8);
    (node->box).X2 = *(LocationType *)(node->u + 0xc);
    (node->box).Y2 = *(LocationType *)(node->u + 0x10);
    prVar3 = node;
    do {
      if (*(int *)(prVar3->u + 0x14) == 0) {
        return;
      }
      if (*(int *)(prVar3->u + 0x18) < (node->box).X1) {
        (node->box).X1 = *(int *)(prVar3->u + 0x18);
      }
      if ((node->box).X2 < *(int *)(prVar3->u + 0x20)) {
        (node->box).X2 = *(int *)(prVar3->u + 0x20);
      }
      if (*(int *)(prVar3->u + 0x1c) < (node->box).Y1) {
        (node->box).Y1 = *(int *)(prVar3->u + 0x1c);
      }
      if ((node->box).Y2 < *(int *)(prVar3->u + 0x24)) {
        (node->box).Y2 = *(int *)(prVar3->u + 0x24);
      }
      prVar3 = (rtree_node *)&prVar3->flags;
    } while (prVar3 != (rtree_node *)(node->u + 0x60));
  }
  return;
}



int __r_search(rtree_node *node,BoxType *query,r_arg *arg)

{
  byte *pbVar1;
  BoxType *pBVar2;
  rtree_node *node_00;
  int iVar3;
  int iVar4;
  rtree_node **pprVar5;
  
  if ((*(byte *)&node->flags & 1) == 0) {
    if (arg->check_it == (anon_subr_int_BoxType_ptr_void_ptr_for_check_it *)0x0) {
      node_00 = *(rtree_node **)node->u;
      pprVar5 = (rtree_node **)node->u;
      if (node_00 != (rtree_node *)0x0) {
        iVar4 = 0;
        do {
          if ((((node_00->box).X1 < query->X2) && (query->X1 < (node_00->box).X2)) &&
             (((node_00->box).Y1 < query->Y2 && (query->Y1 < (node_00->box).Y2)))) {
            iVar3 = __r_search(node_00,query,arg);
            iVar4 = iVar4 + iVar3;
          }
          pprVar5 = pprVar5 + 1;
          node_00 = *pprVar5;
        } while (node_00 != (rtree_node *)0x0);
        return iVar4;
      }
    }
    else {
      node_00 = *(rtree_node **)node->u;
      pprVar5 = (rtree_node **)node->u;
      if (node_00 != (rtree_node *)0x0) {
        iVar4 = 0;
        do {
          if (((((node_00->box).X1 < query->X2) && (query->X1 < (node_00->box).X2)) &&
              ((node_00->box).Y1 < query->Y2)) &&
             ((query->Y1 < (node_00->box).Y2 &&
              (iVar3 = (*arg->check_it)((BoxType *)node_00,arg->closure), iVar3 != 0)))) {
            iVar3 = __r_search(*pprVar5,query,arg);
            iVar4 = iVar4 + iVar3;
          }
          pprVar5 = pprVar5 + 1;
          node_00 = *pprVar5;
        } while (node_00 != (rtree_node *)0x0);
        return iVar4;
      }
    }
  }
  else {
    if (arg->found_it == (anon_subr_int_BoxType_ptr_void_ptr_for_found_it *)0x0) {
      if (*(int *)node->u != 0) {
        iVar4 = 0;
        do {
          if (((*(int *)(node->u + 4) < query->X2) && (query->X1 < *(int *)(node->u + 0xc))) &&
             (*(int *)(node->u + 8) < query->Y2)) {
            iVar4 = iVar4 + (uint)(query->Y1 < *(int *)(node->u + 0x10));
          }
          pbVar1 = node->u;
          node = (rtree_node *)&node->flags;
        } while (*(int *)(pbVar1 + 0x14) != 0);
        return iVar4;
      }
    }
    else {
      pBVar2 = *(BoxType **)node->u;
      if (pBVar2 != (BoxType *)0x0) {
        iVar4 = 0;
        do {
          if (((*(int *)(node->u + 4) < query->X2) && (query->X1 < *(int *)(node->u + 0xc))) &&
             ((*(int *)(node->u + 8) < query->Y2 && (query->Y1 < *(int *)(node->u + 0x10))))) {
            iVar3 = (*arg->found_it)(pBVar2,arg->closure);
            iVar4 = (iVar4 + 1) - (uint)(iVar3 == 0);
          }
          pBVar2 = *(BoxType **)(node->u + 0x14);
          node = (rtree_node *)&node->flags;
        } while (pBVar2 != (BoxType *)0x0);
        return iVar4;
      }
    }
  }
  return 0;
}



int r_search(rtree_t *rtree,BoxType *query,anon_subr_int_BoxType_ptr_void_ptr *check_region,
            anon_subr_int_BoxType_ptr_void_ptr *found_rectangle,void *cl)

{
  rtree_node *node;
  int iVar1;
  r_arg arg;
  
  if ((rtree != (rtree_t *)0x0) && (0 < rtree->size)) {
    if (query == (BoxType *)0x0) {
      arg.check_it = (anon_subr_int_BoxType_ptr_void_ptr_for_check_it *)check_region;
      arg.found_it = (anon_subr_int_BoxType_ptr_void_ptr_for_found_it *)found_rectangle;
      arg.closure = cl;
      iVar1 = __r_search(rtree->root,(BoxType *)rtree->root,&arg);
      return iVar1;
    }
    node = rtree->root;
    if (((((node->box).X1 < query->X2) && (query->X1 < (node->box).X2)) &&
        ((node->box).Y1 < query->Y2)) && (query->Y1 < (node->box).Y2)) {
      arg.closure = cl;
      arg.check_it = (anon_subr_int_BoxType_ptr_void_ptr_for_check_it *)check_region;
      arg.found_it = (anon_subr_int_BoxType_ptr_void_ptr_for_found_it *)found_rectangle;
      iVar1 = __r_search(node,query,&arg);
      return iVar1;
    }
  }
  return 0;
}



int r_region_is_empty(rtree_t *rtree,BoxType *region)

{
  int iVar1;
  jmp_buf env;
  
  iVar1 = _setjmp((__jmp_buf_tag *)env);
  if (iVar1 != 0) {
    return 0;
  }
  r_search(rtree,region,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,__r_region_is_empty_rect_in_reg,
           env);
  return 1;
}



int __r_sub(rtree_node *node,BoxType *b,BoxType *a,jmp_buf *e)

{
  int iVar1;
  rtree_node *prVar2;
  int iVar3;
  
  iVar3 = 0;
  if ((*(byte *)&node->flags & 1) == 0) {
    do {
      if ((*(rtree_node **)(node->u + iVar3 * 4) != (rtree_node *)0x0) &&
         (iVar1 = __r_sub(*(rtree_node **)(node->u + iVar3 * 4),b,a,e), iVar1 != 0)) {
        return 1;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 != 6);
  }
  else {
    iVar3 = 0;
    prVar2 = node;
    do {
      if (*(BoxType **)prVar2->u == b) {
        *(BoxType **)(node->u + iVar3 * 0x14) = a;
                    // WARNING: Subroutine does not return
        __longjmp_chk(e,1);
      }
      iVar3 = iVar3 + 1;
      prVar2 = (rtree_node *)&prVar2->flags;
    } while (iVar3 != 6);
  }
  return 0;
}



void r_substitute(rtree_t *rtree,BoxType *before,BoxType *after)

{
  int iVar1;
  jmp_buf env;
  
  if (before != after) {
    iVar1 = _setjmp((__jmp_buf_tag *)env);
    if (iVar1 == 0) {
      __r_sub(rtree->root,before,after,(jmp_buf *)env);
      return;
    }
  }
  return;
}



int __r_region_is_empty_rect_in_reg(BoxType *box,void *cl)

{
                    // WARNING: Subroutine does not return
  __longjmp_chk(cl,1);
}



Boolean __r_delete(rtree_node *node,BoxType *query)

{
  rtree_node **pprVar1;
  BoxType *pBVar2;
  Boolean BVar3;
  int *piVar4;
  rtree_node *__ptr;
  rtree_node *node_00;
  uint uVar5;
  int iVar6;
  uint uVar7;
  anon_struct_for_flags aVar8;
  int iVar9;
  uint local_20;
  
  if (query->X1 < (node->box).X1) {
    return '\0';
  }
  if (query->Y1 < (node->box).Y1) {
    return '\0';
  }
  if ((node->box).X2 < query->X2) {
    return '\0';
  }
  if ((node->box).Y2 < query->Y2) {
    return '\0';
  }
  while ((*(byte *)&node->flags & 1) == 0) {
    iVar9 = 0;
    while (node_00 = *(rtree_node **)(node->u + iVar9 * 4), (rtree_node *)query != node_00) {
      if (node_00 == (rtree_node *)0x0) {
        return '\0';
      }
      BVar3 = __r_delete(node_00,query);
      if (BVar3 != '\0') {
        return '\x01';
      }
      iVar9 = iVar9 + 1;
      if (iVar9 == 6) {
        return '\0';
      }
    }
    free(query);
    if (iVar9 < 6) {
      iVar6 = *(int *)(node->u + iVar9 * 4 + 4);
      piVar4 = (int *)(node->u + iVar9 * 4 + 8);
      *(int *)(node->u + iVar9 * 4) = iVar6;
      while ((iVar6 != 0 && (iVar9 = iVar9 + 1, iVar9 < 6))) {
        iVar6 = *piVar4;
        piVar4[-1] = iVar6;
        piVar4 = piVar4 + 1;
      }
    }
    if (*(int *)node->u != 0) {
      do {
        adjust_bounds(node);
        node = node->parent;
      } while (node != (rtree_node *)0x0);
      return '\x01';
    }
    node_00 = node->parent;
    if (node_00 == (rtree_node *)0x0) {
      *(byte *)&node->flags = *(byte *)&node->flags | 1;
      *(undefined4 *)(node->u + 0x14) = 0;
      *(undefined4 *)(node->u + 0x28) = 0;
      *(undefined4 *)(node->u + 0x3c) = 0;
      *(undefined4 *)(node->u + 0x50) = 0;
      *(undefined4 *)(node->u + 100) = 0;
      *(undefined4 *)(node->u + 0x78) = 0;
      return '\x01';
    }
    if ((node->box).X1 < (node_00->box).X1) {
      return '\0';
    }
    if ((node->box).Y1 < (node_00->box).Y1) {
      return '\0';
    }
    if ((node_00->box).X2 < (node->box).X2) {
      return '\0';
    }
    pBVar2 = &node->box;
    query = (BoxType *)node;
    node = node_00;
    if ((node_00->box).Y2 < pBVar2->Y2) {
      return '\0';
    }
  }
  uVar7 = 1;
  local_20 = 0;
  iVar9 = 0;
  node_00 = node;
  do {
    __ptr = *(rtree_node **)node_00->u;
    if (__ptr == (rtree_node *)0x0) {
      return '\0';
    }
    if ((rtree_node *)query == __ptr) goto LAB_080c7756;
    iVar9 = iVar9 + 1;
    node_00 = (rtree_node *)&node_00->flags;
    local_20 = local_20 | uVar7;
    uVar7 = uVar7 * 2;
  } while (iVar9 != 6);
  __ptr = *(rtree_node **)(node->u + 0x78);
  if (__ptr == (rtree_node *)0x0) {
    return '\0';
  }
LAB_080c7756:
  aVar8 = node->flags;
  uVar5 = (uint)aVar8 >> 1;
  if ((uVar7 & uVar5) != 0) {
    free(__ptr);
    *(undefined4 *)(node->u + iVar9 * 0x14) = 0;
    aVar8 = node->flags;
    uVar5 = (uint)aVar8 >> 1;
  }
  *(uint *)&node->flags =
       (uint)aVar8 & 1 | ((int)(~local_20 * 2 & uVar5) >> 1 | uVar5 & local_20) * 2;
  if (iVar9 < 6) {
    iVar6 = iVar9 + 1;
    pprVar1 = &node->parent + iVar6 * 5;
    pBVar2 = (BoxType *)((int)&node->box + iVar9 * 0x14);
    *(rtree_node **)&pBVar2[1].X2 = pprVar1[2];
    *(rtree_node **)&pBVar2[1].Y2 = pprVar1[3];
    *(rtree_node **)&pBVar2[2].X1 = pprVar1[4];
    *(rtree_node **)&pBVar2[2].Y1 = pprVar1[5];
    *(rtree_node **)&pBVar2[2].X2 = pprVar1[6];
    piVar4 = (int *)(node->u + iVar6 * 0x14);
    iVar9 = pBVar2[1].X2;
    while ((iVar9 != 0 && (iVar6 < 6))) {
      iVar6 = iVar6 + 1;
      iVar9 = piVar4[5];
      piVar4[1] = piVar4[6];
      *piVar4 = iVar9;
      piVar4[2] = piVar4[7];
      piVar4[3] = piVar4[8];
      piVar4[4] = piVar4[9];
      piVar4 = piVar4 + 5;
    }
  }
  if (*(int *)node->u != 0) {
    do {
      adjust_bounds(node);
      node = node->parent;
    } while (node != (rtree_node *)0x0);
    return '\x01';
  }
  if (node->parent == (rtree_node *)0x0) {
    return '\x01';
  }
  __r_delete(node->parent,(BoxType *)node);
  return '\x01';
}



Boolean r_delete_entry(rtree_t *rtree,BoxType *box)

{
  Boolean BVar1;
  
  BVar1 = __r_delete(rtree->root,box);
  if (BVar1 != '\0') {
    rtree->size = rtree->size + -1;
  }
  return BVar1;
}



void __regparm3 __r_destroy_tree(rtree_node *node)

{
  int iVar1;
  void *__ptr;
  rtree_node *prVar2;
  int iVar3;
  uint uVar4;
  
  iVar3 = 0;
  if ((*(byte *)&node->flags & 1) == 0) {
    while (iVar1 = iVar3 * 4, *(rtree_node **)(node->u + iVar1) != (rtree_node *)0x0) {
      iVar3 = iVar3 + 1;
      __r_destroy_tree(*(rtree_node **)(node->u + iVar1));
      if (iVar3 == 6) {
        free(node);
        return;
      }
    }
  }
  else {
    uVar4 = 1;
    __ptr = *(void **)node->u;
    prVar2 = node;
    while (__ptr != (void *)0x0) {
      if ((uVar4 & (uint)node->flags >> 1) != 0) {
        free(__ptr);
      }
      if ((rtree_node *)&prVar2->flags == (rtree_node *)(node->u + 0x60)) break;
      __ptr = *(void **)(prVar2->u + 0x14);
      uVar4 = uVar4 * 2;
      prVar2 = (rtree_node *)&prVar2->flags;
    }
  }
  free(node);
  return;
}



void r_destroy_tree(rtree_t **rtree)

{
  __r_destroy_tree((*rtree)->root);
  free(*rtree);
  *rtree = (rtree_t *)0x0;
  return;
}



// WARNING: Removing unreachable block (ram,0x080c7a93)
// WARNING: Removing unreachable block (ram,0x080c7a8f)

rtree_node * find_clusters(rtree_node *node)

{
  rtree_node **pprVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  int iVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  int iVar11;
  centroid *pcVar12;
  rtree_node *node_00;
  Boolean *pBVar13;
  byte bVar14;
  rtree_node *prVar15;
  uint uVar16;
  int iVar17;
  undefined4 *puVar18;
  int *piVar19;
  int iVar20;
  anon_struct_for_flags aVar21;
  int iVar22;
  uint uVar23;
  float local_a8;
  uint local_9c;
  float local_98;
  float local_94;
  float local_90;
  float local_8c;
  centroid center [7];
  undefined local_24;
  Boolean belong [7];
  
  pcVar12 = center;
  bVar14 = *(byte *)&node->flags;
  iVar11 = 0;
  do {
    piVar19 = (int *)(node->u + iVar11 * 0x14 + 4);
    if ((bVar14 & 1) == 0) {
      piVar19 = *(int **)(node->u + iVar11 * 4);
    }
    iVar20 = *piVar19;
    iVar11 = iVar11 + 1;
    iVar22 = piVar19[2];
    pcVar12->x = (float)(iVar22 + iVar20) * 0.50000000;
    iVar17 = piVar19[1];
    iVar5 = piVar19[3];
    pcVar12->y = (float)(iVar5 + iVar17) * 0.50000000;
    pcVar12->area = (float)(iVar5 - iVar17) * (float)(iVar22 - iVar20) + 1.00000000;
    pcVar12 = pcVar12 + 1;
  } while (iVar11 != 7);
  local_98 = center[6].x;
  local_a8 = center[6].y;
  fVar6 = center[0].y;
  if ((center[6].x == center[0].x) && (center[6].y == center[0].y)) {
    local_98 = center[6].x + 10000.00000000;
    fVar6 = center[0].y - 10000.00000000;
  }
  local_9c = 0;
  fVar7 = center[0].x;
  do {
    pcVar12 = center;
    iVar20 = 0;
    pBVar13 = belong;
    iVar11 = 0;
    fVar2 = center[0].x;
    fVar3 = center[0].y;
    while( true ) {
      pcVar12 = pcVar12 + 1;
      if ((float)(iVar11 + 3) *
          ((fVar6 - fVar3) * (fVar6 - fVar3) + (fVar7 - fVar2) * (fVar7 - fVar2)) <
          ((local_a8 - fVar3) * (local_a8 - fVar3) + (local_98 - fVar2) * (local_98 - fVar2)) *
          (float)(iVar20 + 3)) {
        *pBVar13 = '\x01';
        iVar11 = iVar11 + 1;
      }
      else {
        *pBVar13 = '\0';
        iVar20 = iVar20 + 1;
      }
      if (pcVar12 == (centroid *)&local_24) break;
      pBVar13 = pBVar13 + 1;
      fVar2 = pcVar12->x;
      fVar3 = pcVar12->y;
    }
    if (iVar11 == 7) {
      belong[3] = '\0';
    }
    else {
      if (iVar20 == 7) {
        belong[3] = '\x01';
      }
    }
    iVar11 = 0;
    fVar9 = 0.00000000;
    fVar10 = 0.00000000;
    local_8c = 0.00000000;
    local_90 = 0.00000000;
    local_94 = 0.00000000;
    fVar8 = 0.00000000;
    pcVar12 = center;
    fVar2 = center[0].x;
    fVar3 = center[0].y;
    while( true ) {
      if (belong[iVar11] == '\0') {
        fVar4 = pcVar12->area;
        local_8c = fVar2 * fVar4 + local_8c;
        fVar9 = fVar3 * fVar4 + fVar9;
        fVar10 = fVar10 + fVar4;
      }
      else {
        fVar4 = pcVar12->area;
        local_94 = fVar2 * fVar4 + local_94;
        local_90 = fVar3 * fVar4 + local_90;
        fVar8 = fVar8 + fVar4;
      }
      if (iVar11 == 6) break;
      iVar11 = iVar11 + 1;
      fVar2 = pcVar12[1].x;
      fVar3 = pcVar12[1].y;
      pcVar12 = pcVar12 + 1;
    }
  } while ((((((int)ROUND(local_94 / fVar8) != (int)ROUND(fVar7)) ||
             ((int)ROUND(local_90 / fVar8) != (int)ROUND(fVar6))) ||
            ((int)ROUND(local_8c / fVar10) != (int)ROUND(local_98))) ||
           ((int)ROUND(fVar10 / fVar9) != (int)ROUND(local_a8))) &&
          (local_9c = local_9c + 1, fVar6 = local_90 / fVar8, fVar7 = local_94 / fVar8,
          local_a8 = fVar10 / fVar9, local_98 = local_8c / fVar10, local_9c != 6));
  node_00 = (rtree_node *)calloc(1,0xa4);
  node_00->parent = node->parent;
  bVar14 = *(byte *)&node->flags & 1;
  *(byte *)&node_00->flags = *(byte *)&node_00->flags & 0xfe | bVar14;
  if (bVar14 == 0) {
    iVar22 = 0;
    iVar11 = 0;
    iVar20 = 0;
    do {
      while (iVar17 = iVar20, belong[iVar17] == '\0') {
        iVar20 = *(int *)(node->u + iVar17 * 4);
        *(int *)(node_00->u + iVar22 * 4) = iVar20;
        iVar22 = iVar22 + 1;
        *(rtree_node **)(iVar20 + 0x10) = node_00;
        iVar20 = iVar17 + 1;
        if (iVar17 + 1 == 7) goto LAB_080c7ff0;
      }
      *(undefined4 *)(node->u + iVar11 * 4) = *(undefined4 *)(node->u + iVar17 * 4);
      iVar11 = iVar11 + 1;
      iVar20 = iVar17 + 1;
    } while (iVar17 + 1 != 7);
LAB_080c7ff0:
    uVar23 = 0;
    uVar16 = iVar17 + 1U & 0xffffff00;
    aVar21 = node->flags;
  }
  else {
    uVar23 = 1;
    local_98 = 0.00000000;
    iVar20 = 0;
    iVar11 = 0;
    local_9c = 1;
    local_90 = 0.00000000;
    local_94 = 0.00000000;
    local_8c = 0.00000000;
    prVar15 = node;
    while( true ) {
      if (belong[iVar20] == '\0') {
        pprVar1 = &node_00->parent + (int)local_8c * 5;
        pprVar1[2] = *(rtree_node **)prVar15->u;
        pprVar1[3] = *(rtree_node **)(prVar15->u + 4);
        pprVar1[4] = *(rtree_node **)(prVar15->u + 8);
        pprVar1[5] = *(rtree_node **)(prVar15->u + 0xc);
        pprVar1[6] = *(rtree_node **)(prVar15->u + 0x10);
        aVar21 = node->flags;
        if (((uint)aVar21 >> 1 & uVar23) != 0) {
          local_90 = (float)((uint)local_90 | (uint)local_98);
        }
        local_8c = (float)((int)local_8c + 1);
        local_98 = (float)((int)local_98 << 1);
      }
      else {
        pprVar1 = &node->parent + iVar11 * 5;
        pprVar1[2] = *(rtree_node **)prVar15->u;
        pprVar1[3] = *(rtree_node **)(prVar15->u + 4);
        pprVar1[4] = *(rtree_node **)(prVar15->u + 8);
        pprVar1[5] = *(rtree_node **)(prVar15->u + 0xc);
        pprVar1[6] = *(rtree_node **)(prVar15->u + 0x10);
        aVar21 = node->flags;
        if (((uint)aVar21 >> 1 & uVar23) != 0) {
          local_94 = (float)((uint)local_94 | local_9c);
        }
        iVar11 = iVar11 + 1;
        local_9c = local_9c << 1;
      }
      if (iVar20 == 6) break;
      prVar15 = (rtree_node *)&prVar15->flags;
      iVar20 = iVar20 + 1;
      uVar23 = uVar23 * 2;
    }
    uVar16 = (uint)local_94 & 0x7fffffff;
    uVar23 = (uint)local_90 & 0x7fffffff;
  }
  *(uint *)&node->flags = (uint)aVar21 & 1 | uVar16 * 2;
  *(uint *)&node_00->flags = (uint)node_00->flags & 1 | uVar23 * 2;
  if ((*(byte *)&node->flags & 1) == 0) {
    puVar18 = (undefined4 *)(node->u + iVar11 * 4);
    if (iVar11 < 7) {
      do {
        iVar11 = iVar11 + 1;
        *puVar18 = 0;
        puVar18 = puVar18 + 1;
      } while (iVar11 != 7);
    }
  }
  else {
    if (iVar11 < 7) {
      puVar18 = (undefined4 *)(node->u + iVar11 * 0x14);
      do {
        iVar11 = iVar11 + 1;
        *puVar18 = 0;
        puVar18 = puVar18 + 5;
      } while (iVar11 != 7);
    }
  }
  adjust_bounds(node);
  adjust_bounds(node_00);
  return node_00;
}



void __regparm3 __r_insert_node(rtree_node *node,BoxType *query,int manage,Boolean force)

{
  BoxType *pBVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  LocationType LVar8;
  LocationType LVar9;
  LocationType LVar10;
  LocationType LVar11;
  rtree_node *node_00;
  int iVar12;
  rtree_node *node_01;
  LocationType *pLVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  rtree_node *prVar18;
  int iVar19;
  int iVar20;
  LocationType *pLVar21;
  byte bVar22;
  float10 fVar23;
  float10 fVar24;
  rtree_node *local_3c;
  int local_24;
  
  bVar22 = 0;
  if ((*(byte *)&node->flags & 1) == 0) {
    if (force != '\0') {
      if (query->X1 < (node->box).X1) {
        (node->box).X1 = query->X1;
      }
      if ((node->box).X2 < query->X2) {
        (node->box).X2 = query->X2;
      }
      if (query->Y1 < (node->box).Y1) {
        (node->box).Y1 = query->Y1;
      }
      if ((node->box).Y2 < query->Y2) {
        (node->box).Y2 = query->Y2;
      }
    }
    iVar12 = 0;
    do {
      node_01 = *(rtree_node **)(node->u + iVar12 * 4);
      if (node_01 == (rtree_node *)0x0) {
        local_3c = *(rtree_node **)node->u;
        if ((iVar12 < 6) && ((*(byte *)&local_3c->flags & 1) != 0)) {
          pLVar21 = (LocationType *)calloc(1,0xa4);
          *(byte *)(pLVar21 + 5) = *(byte *)(pLVar21 + 5) | 1;
          *(LocationType **)(node->u + iVar12 * 4) = pLVar21;
          *(rtree_node **)(pLVar21 + 4) = node;
          *(BoxType **)(pLVar21 + 6) = query;
          LVar8 = query->X1;
          pLVar21[7] = LVar8;
          LVar9 = query->Y1;
          pLVar21[8] = LVar9;
          LVar10 = query->X2;
          pLVar21[9] = LVar10;
          LVar11 = query->Y2;
          pLVar21[1] = LVar9;
          *pLVar21 = LVar8;
          pLVar21[2] = LVar10;
          pLVar21[10] = LVar11;
          pLVar21[3] = LVar11;
          if (manage == 0) {
            return;
          }
          pLVar21[5] = pLVar21[5] & 1U | 2;
          return;
        }
        iVar16 = query->X1;
        goto LAB_080c82b9;
      }
      iVar16 = query->X1;
      if (((((node_01->box).X1 == iVar16 || (node_01->box).X1 < iVar16) &&
           (query->X2 <= (node_01->box).X2)) && ((node_01->box).Y1 <= query->Y1)) &&
         (query->Y2 <= (node_01->box).Y2)) {
        __r_insert_node(node_01,query,manage,'\0');
        return;
      }
      iVar12 = iVar12 + 1;
    } while (iVar12 != 6);
    local_3c = *(rtree_node **)node->u;
LAB_080c82b9:
    iVar12 = query->X2;
    iVar2 = (local_3c->box).X2;
    iVar3 = (local_3c->box).X1;
    iVar14 = iVar12;
    if (iVar12 <= iVar2) {
      iVar14 = iVar2;
    }
    iVar20 = iVar3;
    if (iVar16 <= iVar3) {
      iVar20 = iVar16;
    }
    iVar4 = query->Y2;
    iVar5 = (local_3c->box).Y2;
    iVar6 = (local_3c->box).Y1;
    iVar7 = query->Y1;
    iVar15 = iVar4;
    if (iVar4 <= iVar5) {
      iVar15 = iVar5;
    }
    iVar19 = iVar7;
    if (iVar6 <= iVar7) {
      iVar19 = iVar6;
    }
    local_24 = 1;
    fVar23 = (float10)(iVar15 - iVar19) * (float10)(iVar14 - iVar20) -
             (float10)(iVar5 - iVar6) * (float10)(iVar2 - iVar3);
    do {
      node_01 = *(rtree_node **)(node->u + local_24 * 4);
      if (node_01 == (rtree_node *)0x0) break;
      iVar2 = (node_01->box).X2;
      iVar3 = (node_01->box).X1;
      iVar14 = iVar12;
      if (iVar12 <= iVar2) {
        iVar14 = iVar2;
      }
      iVar20 = iVar16;
      if (iVar3 < iVar16) {
        iVar20 = iVar3;
      }
      iVar5 = (node_01->box).Y1;
      iVar6 = (node_01->box).Y2;
      iVar15 = iVar4;
      if (iVar4 <= iVar6) {
        iVar15 = iVar6;
      }
      iVar19 = iVar7;
      if (iVar5 <= iVar7) {
        iVar19 = iVar5;
      }
      fVar24 = (float10)(iVar15 - iVar19) * (float10)(iVar14 - iVar20) -
               (float10)(iVar6 - iVar5) * (float10)(iVar2 - iVar3);
      if (fVar24 < fVar23) {
        fVar23 = fVar24;
        local_3c = node_01;
      }
      local_24 = local_24 + 1;
    } while (local_24 != 6);
    __r_insert_node(local_3c,query,manage,'\x01');
    return;
  }
  iVar12 = 0;
  node_01 = node;
  if (manage == 0) {
    do {
      if (*(int *)node_01->u == 0) goto LAB_080c80a5;
      iVar12 = iVar12 + 1;
      node_01 = (rtree_node *)&node_01->flags;
    } while (iVar12 != 6);
    *(BoxType **)(node->u + 0x78) = query;
    *(LocationType *)(node->u + 0x7c) = query->X1;
    *(LocationType *)(node->u + 0x80) = query->Y1;
    *(LocationType *)(node->u + 0x84) = query->X2;
    *(LocationType *)(node->u + 0x88) = query->Y2;
  }
  else {
    uVar17 = 1;
    do {
      if (*(int *)node_01->u == 0) break;
      iVar12 = iVar12 + 1;
      uVar17 = uVar17 * 2;
      node_01 = (rtree_node *)&node_01->flags;
    } while (iVar12 != 6);
    *(uint *)&node->flags = (uint)node->flags & 1 | ((uint)node->flags >> 1 | uVar17) * 2;
LAB_080c80a5:
    pBVar1 = (BoxType *)((int)&node->box + iVar12 * 0x14);
    *(BoxType **)&pBVar1[1].X2 = query;
    pBVar1[1].Y2 = query->X1;
    pBVar1[2].X1 = query->Y1;
    pBVar1[2].Y1 = query->X2;
    pBVar1[2].X2 = query->Y2;
    if (iVar12 == 0) {
      (node->box).X1 = query->X1;
      (node->box).Y1 = query->Y1;
      (node->box).X2 = query->X2;
      (node->box).Y2 = query->Y2;
      return;
    }
  }
  if (force != '\0') {
    if (query->X1 < (node->box).X1) {
      (node->box).X1 = query->X1;
    }
    if ((node->box).X2 < query->X2) {
      (node->box).X2 = query->X2;
    }
    if (query->Y1 < (node->box).Y1) {
      (node->box).Y1 = query->Y1;
    }
    if ((node->box).Y2 < query->Y2) {
      (node->box).Y2 = query->Y2;
    }
  }
  if (iVar12 < 6) {
    return;
  }
  node_01 = find_clusters(node);
  prVar18 = node->parent;
  do {
    node_00 = prVar18;
    if (node_00 == (rtree_node *)0x0) {
      pLVar13 = (LocationType *)calloc(1,0xa4);
      iVar12 = 0x29;
      prVar18 = node;
      pLVar21 = pLVar13;
      while (iVar12 != 0) {
        iVar12 = iVar12 + -1;
        *pLVar21 = (prVar18->box).X1;
        prVar18 = (rtree_node *)((int)prVar18 + (uint)bVar22 * -8 + 4);
        pLVar21 = pLVar21 + (uint)bVar22 * 0x3ffffffe + 1;
      }
      if ((*(byte *)(pLVar13 + 5) & 1) == 0) {
        do {
          if (pLVar13[iVar12 + 6] != 0) {
            *(LocationType **)(pLVar13[iVar12 + 6] + 0x10) = pLVar13;
          }
          iVar12 = iVar12 + 1;
        } while (iVar12 != 6);
      }
      *(byte *)&node->flags = *(byte *)&node->flags & 0xfe;
      *(uint *)&node->flags = (uint)node->flags & 1;
      *(LocationType **)(node->u + 4) = pLVar13;
      node_01->parent = node;
      *(rtree_node **)node->u = node_01;
      *(rtree_node **)(pLVar13 + 4) = node;
      *(undefined4 *)(node->u + 8) = 0;
      *(undefined4 *)(node->u + 0xc) = 0;
      *(undefined4 *)(node->u + 0x10) = 0;
      *(undefined4 *)(node->u + 0x14) = 0;
      *(undefined4 *)(node->u + 0x18) = 0;
      adjust_bounds(node);
      return;
    }
    iVar12 = 0;
    do {
      if (*(int *)(node_00->u + iVar12 * 4) == 0) {
        *(rtree_node **)(node_00->u + iVar12 * 4) = node_01;
        return;
      }
      iVar12 = iVar12 + 1;
    } while (iVar12 != 6);
    *(rtree_node **)(node_00->u + 0x18) = node_01;
    node_01 = find_clusters(node_00);
    prVar18 = node_00->parent;
    node = node_00;
  } while( true );
}



void r_insert_entry(rtree_t *rtree,BoxType *which,int man)

{
  rtree_node *node;
  bool force;
  
  node = rtree->root;
  if (((which->X1 < (node->box).X1) || ((node->box).X2 < which->X2)) || (which->Y1 < (node->box).Y1)
     ) {
    force = true;
  }
  else {
    force = (node->box).Y2 < which->Y2;
  }
  __r_insert_node(node,which,man,force);
  rtree->size = rtree->size + 1;
  return;
}



rtree_t * r_create_tree(BoxType **boxlist,int N,int manage)

{
  rtree_t *rtree;
  rtree_node *prVar1;
  int iVar2;
  
  rtree = (rtree_t *)calloc(1,8);
  prVar1 = (rtree_node *)calloc(1,0xa4);
  *(byte *)&prVar1->flags = *(byte *)&prVar1->flags | 1;
  prVar1->parent = (rtree_node *)0x0;
  rtree->root = prVar1;
  if (0 < N) {
    iVar2 = 0;
    do {
      r_insert_entry(rtree,boxlist[iVar2],manage);
      iVar2 = iVar2 + 1;
    } while (iVar2 < N);
  }
  return rtree;
}



void __regparm3 CheckPinForRubberbandConnection(PinTypePtr *Pin)

{
  int iVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  uint uVar4;
  rubber_info info;
  
  iVar3 = Pin->X;
  info.line = (LineTypePtr_conflict *)0x0;
  info.radius = Pin->Thickness / 2;
  info.box.X1 = iVar3 - info.radius;
  info.box.X2 = info.radius + iVar3;
  iVar1 = Pin->Y;
  info.box.Y1 = iVar1 - info.radius;
  info.box.Y2 = info.radius + iVar1;
  if ((*(byte *)((int)&(Pin->Flags).f + 1) & 1) != 0) {
    info.radius = 0;
    iVar3 = info.X;
    iVar1 = info.Y;
  }
  info.Y = iVar1;
  info.X = iVar3;
  pDVar2 = PCB->Data;
  if (pDVar2->LayerN != 0) {
    uVar4 = 0;
    do {
      iVar3 = uVar4 * 0x5c;
      uVar4 = uVar4 + 1;
      info.layer = (LayerTypePtr)(&pDVar2->field_0x4c + iVar3);
      r_search(*(rtree_t **)(&pDVar2->field_0x80 + iVar3),&info.box,
               (anon_subr_int_BoxType_ptr_void_ptr *)0x0,rubber_callback,&info);
      pDVar2 = PCB->Data;
    } while (uVar4 <= (uint)pDVar2->LayerN && pDVar2->LayerN != uVar4);
  }
  return;
}



int rubber_callback(BoxType *b,void *cl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  bool bVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  
  if (((*(byte *)((int)&b[1].Y1 + 1) & 0x20) != 0) || (*(BoxType **)((int)cl + 0xc) == b)) {
    return 0;
  }
  iVar13 = *(int *)cl;
  iVar14 = b[2].Y1 / 2;
  if (iVar13 != 0) {
    if (iVar13 < 0) {
      fVar4 = 0.00000000;
    }
    else {
      fVar4 = (float)(iVar14 + iVar13) * (float)(iVar14 + iVar13);
    }
    fVar5 = (float)(*(int *)((int)cl + 4) - b[2].Y2);
    fVar6 = (float)(*(int *)((int)cl + 8) - b[3].X1);
    fVar5 = (fVar6 * fVar6 + fVar5 * fVar5) - fVar4;
    fVar6 = (float)(*(int *)((int)cl + 4) - b[4].X1);
    fVar7 = (float)(*(int *)((int)cl + 8) - b[4].Y1);
    fVar4 = (fVar7 * fVar7 + fVar6 * fVar6) - fVar4;
    if ((0.00000000 < fVar5) && (0.00000000 < fVar4)) {
      return 0;
    }
    if (fVar5 <= 0.00000000) {
      CreateNewRubberbandEntry
                (*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)&b[2].Y2);
    }
    if (fVar4 <= 0.00000000) {
      CreateNewRubberbandEntry
                (*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)(b + 4));
      return 1;
    }
    return 1;
  }
  iVar13 = b[2].Y2;
  iVar9 = *(int *)((int)cl + 0x10);
  if ((iVar9 <= iVar14 + iVar13) && (iVar11 = *(int *)((int)cl + 0x18), iVar13 - iVar14 <= iVar11))
  {
    iVar12 = b[3].X1;
    iVar1 = *(int *)((int)cl + 0x14);
    if ((iVar1 <= iVar12 + iVar14) && (iVar2 = *(int *)((int)cl + 0x1c), iVar12 - iVar14 <= iVar2))
    {
      if (((iVar13 < iVar9) || (iVar11 < iVar13)) && ((iVar12 < iVar1 || (iVar2 < iVar12)))) {
        uVar10 = iVar9 - iVar13 >> 0x1f;
        iVar3 = (uVar10 ^ iVar9 - iVar13) - uVar10;
        uVar10 = iVar11 - iVar13 >> 0x1f;
        iVar13 = (iVar11 - iVar13 ^ uVar10) - uVar10;
        if (iVar3 <= iVar13) {
          iVar13 = iVar3;
        }
        uVar10 = iVar1 - iVar12 >> 0x1f;
        iVar11 = (iVar1 - iVar12 ^ uVar10) - uVar10;
        uVar10 = iVar2 - iVar12 >> 0x1f;
        iVar12 = (iVar2 - iVar12 ^ uVar10) - uVar10;
        if (iVar12 < iVar11) {
          iVar11 = iVar12;
        }
        if ((float10)0 <
            ((float10)iVar11 * (float10)iVar11 + (float10)iVar13 * (float10)iVar13) -
            (float10)(iVar14 * iVar14)) goto LAB_080c8870;
      }
      CreateNewRubberbandEntry
                (*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)&b[2].Y2);
      iVar9 = *(int *)((int)cl + 0x10);
      iVar13 = 1;
      bVar8 = true;
      goto LAB_080c8879;
    }
  }
LAB_080c8870:
  iVar13 = 0;
  bVar8 = false;
LAB_080c8879:
  iVar11 = b[4].X1;
  if (iVar11 + iVar14 < iVar9) {
    return iVar13;
  }
  iVar12 = *(int *)((int)cl + 0x18);
  if (iVar12 < iVar11 - iVar14) {
    return iVar13;
  }
  iVar1 = b[4].Y1;
  iVar2 = *(int *)((int)cl + 0x14);
  if (iVar1 + iVar14 < iVar2) {
    return iVar13;
  }
  iVar3 = *(int *)((int)cl + 0x1c);
  if (iVar1 - iVar14 <= iVar3) {
    if (((iVar11 < iVar9) || (iVar12 < iVar11)) && ((iVar1 < iVar2 || (iVar3 < iVar1)))) {
      uVar10 = iVar9 - iVar11 >> 0x1f;
      iVar9 = (iVar9 - iVar11 ^ uVar10) - uVar10;
      uVar10 = iVar12 - iVar11 >> 0x1f;
      iVar11 = (iVar12 - iVar11 ^ uVar10) - uVar10;
      if (iVar11 < iVar9) {
        iVar9 = iVar11;
      }
      uVar10 = iVar2 - iVar1 >> 0x1f;
      iVar11 = (iVar2 - iVar1 ^ uVar10) - uVar10;
      uVar10 = iVar3 - iVar1 >> 0x1f;
      iVar12 = (iVar3 - iVar1 ^ uVar10) - uVar10;
      if (iVar12 < iVar11) {
        iVar11 = iVar12;
      }
      if (((float10)0 <
           ((float10)iVar11 * (float10)iVar11 + (float10)iVar9 * (float10)iVar9) -
           (float10)(iVar14 * iVar14)) && (!bVar8)) {
        return iVar13;
      }
    }
    CreateNewRubberbandEntry(*(LayerTypePtr *)((int)cl + 0x20),(LineTypePtr)b,(PointTypePtr)(b + 4))
    ;
    return iVar13 + 1;
  }
  return iVar13;
}



int rat_callback(BoxType *box,void *cl)

{
  int iVar1;
  
  iVar1 = *(int *)cl;
  if (iVar1 == 0x200) {
    iVar1 = *(int *)((int)cl + 0xc);
    if (((box[2].Y2 == *(int *)(iVar1 + 0x2c)) && (box[3].X1 == *(int *)(iVar1 + 0x30))) &&
       (box[5].Y1 == *(int *)((int)cl + 4))) goto LAB_080c8b40;
    if (((*(int *)(iVar1 + 0x2c) != box[4].X1) || (box[4].Y1 != *(int *)(iVar1 + 0x30))) ||
       (box[5].X2 != *(int *)((int)cl + 4))) {
      if (((box[2].Y2 == *(int *)(iVar1 + 0x40)) && (box[3].X1 == *(int *)(iVar1 + 0x44))) &&
         (box[5].Y1 == *(int *)((int)cl + 4))) goto LAB_080c8b40;
      if (box[4].X1 != *(int *)(iVar1 + 0x40)) {
        return 0;
      }
      if (box[4].Y1 != *(int *)(iVar1 + 0x44)) {
        return 0;
      }
      if (box[5].X2 != *(int *)((int)cl + 4)) {
        return 0;
      }
    }
  }
  else {
    if (iVar1 == 0x1000) {
      if (((box[5].Y1 == *(int *)((int)cl + 4)) && (box[2].Y2 == **(int **)((int)cl + 0x10))) &&
         (box[3].X1 == (*(int **)((int)cl + 0x10))[1])) goto LAB_080c8b40;
      if (*(int *)((int)cl + 4) != box[5].X2) {
        return 0;
      }
      if (box[4].X1 != **(int **)((int)cl + 0x10)) {
        return 0;
      }
      if (box[4].Y1 != (*(int **)((int)cl + 0x10))[1]) {
        return 0;
      }
    }
    else {
      if (iVar1 != 0x100) {
        Message("hace: bad rubber-rat lookup callback\n");
        return 0;
      }
      iVar1 = *(int *)((int)cl + 8);
      if ((box[2].Y2 == *(int *)(iVar1 + 0x34)) && (box[3].X1 == *(int *)(iVar1 + 0x38))) {
LAB_080c8b40:
        CreateNewRubberbandEntry((LayerTypePtr)0x0,(LineTypePtr)box,(PointTypePtr)&box[2].Y2);
        return 0;
      }
      if (*(int *)(iVar1 + 0x34) != box[4].X1) {
        return 0;
      }
      if (box[4].Y1 != *(int *)(iVar1 + 0x38)) {
        return 0;
      }
    }
  }
  CreateNewRubberbandEntry((LayerTypePtr)0x0,(LineTypePtr)box,(PointTypePtr)(box + 4));
  return 0;
}



void __regparm3 CheckLinePointForRat(LayerTypePtr Layer,PointTypePtr Point)

{
  rinfo info;
  
  info.group = GetLayerGroupNumberByPointer(Layer);
  info.type = 0x1000;
  info.point = Point;
  r_search(PCB->Data->rat_tree,(BoxType *)Point,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
           rat_callback,&info);
  return;
}



void LookupRatLines(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  uint uVar1;
  PadTypePtr *query;
  uint uVar2;
  uint uVar3;
  int local_40;
  rinfo info;
  
  if (Type == 2) {
    if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
      uVar1 = 0;
      uVar2 = *(uint *)((int)Ptr1 + 0xe0);
      do {
        info.pin = (PinTypePtr *)(uVar1 * 0x4c + *(int *)((int)Ptr1 + 0x100));
        info.type = 0x100;
        r_search(PCB->Data->rat_tree,(BoxType *)info.pin,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 rat_callback,&info);
        uVar3 = *(uint *)((int)Ptr1 + 0xe0);
        if (uVar3 == 0) break;
        uVar1 = (uVar3 + 1 + uVar1) - uVar2;
        uVar2 = uVar3;
      } while (uVar1 < uVar3);
    }
    uVar2 = *(uint *)((int)Ptr1 + 0xe8);
    uVar3 = 0;
    local_40 = 0;
    uVar1 = uVar2;
    while ((uVar1 != 0 && (uVar3 < uVar1))) {
      query = (PadTypePtr *)(local_40 + *(int *)((int)Ptr1 + 0x104));
      info.group = GetLayerGroupNumberByNumber
                             ((((query->Flags).f >> 7 ^ 1) & 1) + PCB->Data->LayerN);
      info.type = 0x200;
      info.pad = query;
      r_search(PCB->Data->rat_tree,(BoxType *)query,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               rat_callback,&info);
      uVar1 = *(uint *)((int)Ptr1 + 0xe8);
      if (*(uint *)((int)Ptr1 + 0xe8) == uVar2) {
        uVar3 = uVar3 + 1;
        local_40 = local_40 + 0x68;
        uVar1 = uVar2;
      }
    }
  }
  else {
    if (Type < 3) {
      if (Type == 1) {
        info.type = 0x100;
        info.pin = (PinTypePtr *)Ptr1;
        r_search(PCB->Data->rat_tree,(BoxType *)Ptr1,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                 rat_callback,&info);
      }
    }
    else {
      if (Type == 4) {
        CheckLinePointForRat((LayerTypePtr)Ptr1,(PointTypePtr)((int)Ptr2 + 0x2c));
        CheckLinePointForRat((LayerTypePtr)Ptr1,(PointTypePtr)((int)Ptr2 + 0x40));
        return;
      }
      if (Type == 0x1000) {
        CheckLinePointForRat((LayerTypePtr)Ptr1,(PointTypePtr)Ptr3);
        return;
      }
    }
  }
  return;
}



void __regparm3
CheckLinePointForRubberbandConnection
          (LayerTypePtr Layer,LineTypePtr_conflict *Line,PointTypePtr LinePoint,Boolean Exact)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  DataTypePtr *pDVar4;
  int iVar5;
  uint uVar6;
  PCBTypePtr pPVar7;
  rubber_info info;
  
  iVar5 = Line->Thickness / 2;
  info.radius = -1;
  if ((Exact == '\0') && (info.radius = 1, 3 < Line->Thickness)) {
    info.radius = iVar5;
  }
  info.X = LinePoint->X;
  info.box.X1 = info.X - iVar5;
  info.box.X2 = iVar5 + info.X;
  info.Y = LinePoint->Y;
  info.box.Y1 = info.Y - iVar5;
  info.box.Y2 = iVar5 + info.Y;
  info.line = Line;
  iVar3 = GetLayerGroupNumberByPointer(Layer);
  pDVar4 = PCB->Data;
  iVar5 = *(int *)&pDVar4->field_0x48;
  if (*(int *)(iVar5 + 4 + (iVar3 + 0x734) * 4) != 0) {
    uVar6 = 0;
    pPVar7 = PCB;
    do {
      uVar2 = *(uint *)(iVar5 + 4 + (uVar6 + 0x744 + iVar3 * 0x12) * 4);
      if (uVar2 < (uint)pDVar4->LayerN) {
        if (*(char *)(&pDVar4->ViaN + uVar2 * 0x17 + 0x24) != '\0') {
          info.layer = (LayerTypePtr)(&pDVar4->field_0x4c + uVar2 * 0x5c);
          r_search((rtree_t *)(&pDVar4->ViaN + uVar2 * 0x17)[0x20],&info.box,
                   (anon_subr_int_BoxType_ptr_void_ptr *)0x0,rubber_callback,&info);
          pPVar7 = PCB;
        }
      }
      pDVar4 = pPVar7->Data;
      uVar6 = uVar6 + 1;
      iVar5 = *(int *)&pDVar4->field_0x48;
      puVar1 = (uint *)(iVar5 + 4 + (iVar3 + 0x734) * 4);
    } while (uVar6 <= *puVar1 && *puVar1 != uVar6);
  }
  return;
}



void LookupRubberbandLines(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  Cardinal *pCVar1;
  LayerTypePtr Layer;
  uint uVar2;
  int iVar3;
  Boolean BVar4;
  int iVar5;
  int iVar6;
  DataTypePtr *pDVar7;
  int iVar8;
  uint uVar9;
  int r;
  uint uVar10;
  int iVar11;
  PCBTypePtr pPVar12;
  int iVar13;
  LineTypePtr Line;
  int local_5c;
  uint local_58;
  rubber_info info;
  
  if (Type == 4) {
    iVar5 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1);
    if (iVar5 < PCB->Data->LayerN) {
      CheckLinePointForRubberbandConnection
                ((LayerTypePtr)Ptr1,(LineTypePtr_conflict *)Ptr2,(PointTypePtr)((int)Ptr2 + 0x2c),
                 '\0');
      CheckLinePointForRubberbandConnection
                ((LayerTypePtr)Ptr1,(LineTypePtr_conflict *)Ptr2,(PointTypePtr)((int)Ptr2 + 0x40),
                 '\0');
    }
  }
  else {
    if (Type < 5) {
      if (Type == 1) {
        CheckPinForRubberbandConnection((PinTypePtr *)Ptr1);
        return;
      }
      if (Type == 2) {
        if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
          uVar10 = 0;
          uVar9 = *(uint *)((int)Ptr1 + 0xe0);
          do {
            CheckPinForRubberbandConnection
                      ((PinTypePtr *)(uVar10 * 0x4c + *(int *)((int)Ptr1 + 0x100)));
            uVar2 = *(uint *)((int)Ptr1 + 0xe0);
            if (uVar2 == 0) break;
            uVar10 = (uVar2 + 1 + uVar10) - uVar9;
            uVar9 = uVar2;
          } while (uVar10 < uVar2);
        }
        local_5c = 0;
        local_58 = 0;
        uVar9 = *(uint *)((int)Ptr1 + 0xe8);
        uVar10 = uVar9;
        while ((uVar10 != 0 && (local_58 < uVar10))) {
          info.line = (LineTypePtr_conflict *)0x0;
          r = local_5c + *(int *)((int)Ptr1 + 0x104);
          iVar5 = *(int *)(r + 0x2c);
          iVar6 = *(int *)(r + 0x40);
          iVar8 = *(int *)(r + 0x24) / 2;
          iVar11 = iVar6;
          if (iVar5 <= iVar6) {
            iVar11 = iVar5;
          }
          info.box.X1 = iVar11 - iVar8;
          iVar11 = *(int *)(r + 0x30);
          iVar3 = *(int *)(r + 0x44);
          info.radius = 0;
          iVar13 = iVar3;
          if (iVar11 <= iVar3) {
            iVar13 = iVar11;
          }
          info.box.Y1 = iVar13 - iVar8;
          if (iVar6 <= iVar5) {
            iVar6 = iVar5;
          }
          info.box.X2 = iVar6 + iVar8;
          if (iVar11 < iVar3) {
            iVar11 = iVar3;
          }
          info.box.Y2 = iVar11 + iVar8;
          iVar6 = GetLayerGroupNumberByNumber
                            (((*(uint *)(r + 0x14) >> 7 ^ 1) & 1) + PCB->Data->LayerN);
          pDVar7 = PCB->Data;
          iVar5 = *(int *)&pDVar7->field_0x48;
          if (*(int *)(iVar5 + 4 + (iVar6 + 0x734) * 4) != 0) {
            uVar10 = 0;
            pPVar12 = PCB;
            do {
              uVar2 = *(uint *)(iVar5 + 4 + (uVar10 + 0x744 + iVar6 * 0x12) * 4);
              if (uVar2 < (uint)pDVar7->LayerN) {
                info.layer = (LayerTypePtr)(&pDVar7->field_0x4c + uVar2 * 0x5c);
                if (*(char *)(&pDVar7->ViaN + uVar2 * 0x17 + 0x24) != '\0') {
                  r_search((rtree_t *)(&pDVar7->ViaN + uVar2 * 0x17)[0x20],&info.box,
                           (anon_subr_int_BoxType_ptr_void_ptr *)0x0,rubber_callback,&info);
                  pPVar12 = PCB;
                }
              }
              pDVar7 = pPVar12->Data;
              uVar10 = uVar10 + 1;
              iVar5 = *(int *)&pDVar7->field_0x48;
            } while (uVar10 < *(uint *)(iVar5 + 4 + (iVar6 + 0x734) * 4));
          }
          uVar10 = *(uint *)((int)Ptr1 + 0xe8);
          if (*(uint *)((int)Ptr1 + 0xe8) == uVar9) {
            local_58 = local_58 + 1;
            local_5c = local_5c + 0x68;
            uVar10 = uVar9;
          }
        }
      }
    }
    else {
      if (Type == 8) {
        iVar5 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1);
        if (iVar5 < PCB->Data->LayerN) {
          iVar6 = GetLayerGroupNumberByPointer((LayerTypePtr)Ptr1);
          pDVar7 = PCB->Data;
          iVar5 = *(int *)&pDVar7->field_0x48;
          if (*(int *)(iVar5 + 4 + (iVar6 + 0x734) * 4) != 0) {
            uVar9 = 0;
            pPVar12 = PCB;
            do {
              uVar10 = *(uint *)(iVar5 + 4 + (uVar9 + 0x744 + iVar6 * 0x12) * 4);
              if (uVar10 < (uint)pDVar7->LayerN) {
                Layer = (LayerTypePtr)(&pDVar7->field_0x4c + uVar10 * 0x5c);
                pCVar1 = &pDVar7->ViaN + uVar10 * 0x17;
                if (*(char *)(pCVar1 + 0x24) != '\0') {
                  iVar5 = pCVar1[0x14] - 1;
                  if (iVar5 != -1) {
                    iVar11 = pCVar1[0x14] * 0x58 + -0x58;
                    do {
                      while (Line = (LineTypePtr)(pCVar1[0x1c] + iVar11),
                            ((Line->Flags).f & 0x2020) != 0) {
LAB_080c91e0:
                        iVar5 = iVar5 + -1;
                        iVar11 = iVar11 + -0x58;
                        pPVar12 = PCB;
                        if (iVar5 == -1) goto LAB_080c9299;
                      }
                      r = (Line->Thickness + 1) / 2;
                      BVar4 = IsPointInPolygon((Line->Point1).X,(Line->Point1).Y,r,
                                               (PolygonTypePtr)Ptr2);
                      if (BVar4 != '\0') {
                        CreateNewRubberbandEntry(Layer,Line,(PointTypePtr)&Line->Point1);
                      }
                      BVar4 = IsPointInPolygon((Line->Point2).X,(Line->Point2).Y,r,
                                               (PolygonTypePtr)Ptr2);
                      if (BVar4 == '\0') goto LAB_080c91e0;
                      iVar5 = iVar5 + -1;
                      iVar11 = iVar11 + -0x58;
                      CreateNewRubberbandEntry(Layer,Line,(PointTypePtr)&Line->Point2);
                      pPVar12 = PCB;
                    } while (iVar5 != -1);
                  }
                }
              }
LAB_080c9299:
              pDVar7 = pPVar12->Data;
              uVar9 = uVar9 + 1;
              iVar5 = *(int *)&pDVar7->field_0x48;
            } while (uVar9 < *(uint *)(iVar5 + 4 + (iVar6 + 0x734) * 4));
          }
        }
      }
      else {
        if ((Type == 0x1000) &&
           (iVar5 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1), iVar5 < PCB->Data->LayerN)) {
          CheckLinePointForRubberbandConnection
                    ((LayerTypePtr)Ptr1,(LineTypePtr_conflict *)Ptr2,(PointTypePtr)Ptr3,'\x01');
        }
      }
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

int linepoint_callback(BoxType *b,void *cl)

{
  float fVar1;
  bool bVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  uint uVar6;
  
  fVar5 = PosY;
  fVar3 = PosX;
  uVar6 = 0;
  if ((b[1].Y1 & *(uint *)((int)cl + 0xa8)) == 0) {
    fVar1 = PosX - (float)b[2].Y2;
    fVar4 = PosY - (float)b[3].X1;
    fVar4 = fVar4 * fVar4 + fVar1 * fVar1;
    fVar1 = *(float *)((int)cl + 8);
    bVar2 = fVar4 < fVar1;
    if (bVar2) {
      *(float *)((int)cl + 8) = fVar4;
      **(BoxType ***)cl = b;
      **(LocationType ***)((int)cl + 4) = &b[2].Y2;
      fVar1 = fVar4;
    }
    uVar6 = (uint)bVar2;
    fVar3 = fVar3 - (float)b[4].X1;
    fVar5 = fVar5 - (float)b[4].Y1;
    fVar3 = fVar5 * fVar5 + fVar3 * fVar3;
    if (fVar3 < fVar1) {
      *(float *)((int)cl + 8) = fVar3;
      **(BoxType ***)cl = b;
      *(BoxType **)&(*(BoxType **)((int)cl + 4))->X1 = b + 4;
      uVar6 = 1;
    }
  }
  return uVar6;
}



// WARNING: Type propagation algorithm not settling

int name_callback(BoxType *box,void *cl)

{
  int iVar1;
  uint uVar2;
  BoxType *pBVar3;
  float fVar4;
  int iVar5;
  
  iVar1 = box[3].X2;
  if (((((box[1].Y1 & *(uint *)((int)cl + 0xb0)) != 0) ||
       (((uVar2 = *(uint *)(iVar1 + 0x14), (uVar2 >> 7 & 1) != (int)Settings.ShowSolderSide &&
         (*(char *)((int)cl + 0xc) == '\0')) || ((uVar2 & 0x10) != 0)))) ||
      (((PosX < (float)box->X1 || ((float)box->X2 < PosX)) || (PosY < (float)box->Y1)))) ||
     ((float)box->Y2 < PosY)) {
    iVar5 = 0;
  }
  else {
    iVar5 = 1;
    fVar4 = (float)(box->Y2 - box->Y1) * (float)(box->X2 - box->X1);
    if (fVar4 < *(float *)((int)cl + 0x10)) {
      *(float *)((int)cl + 0x10) = fVar4;
      **(int **)cl = iVar1;
      pBVar3 = *(BoxType **)((int)cl + 4);
      *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = box;
      *(BoxType **)&pBVar3->X1 = box;
      iVar5 = 1;
    }
  }
  return iVar5;
}



// WARNING: Type propagation algorithm not settling

int element_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  BoxType *pBVar2;
  float fVar3;
  int iVar4;
  
  if (((((*(uint *)((int)cl + 0xb0) & box[1].Y1) != 0) ||
       (((((uint)box[1].Y1 >> 7 & 1) != (int)Settings.ShowSolderSide &&
         (*(char *)((int)cl + 0xc) == '\0')) || (PosX < (float)box[0x11].X1)))) ||
      ((((float)box[0x11].X2 < PosX || (PosY < (float)box[0x11].Y1)) || ((float)box[0x11].Y2 < PosY)
       ))) || (fVar3 = (float)(box[0x11].Y2 - box[0x11].Y1) * (float)(box[0x11].X2 - box[0x11].X1),
              *(float *)((int)cl + 0x10) <= fVar3)) {
    iVar4 = 0;
  }
  else {
    ppBVar1 = *(BoxType ***)cl;
    *(float *)((int)cl + 0x10) = fVar3;
    pBVar2 = *(BoxType **)((int)cl + 4);
    *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = box;
    *(BoxType **)&pBVar2->X1 = box;
    *ppBVar1 = box;
    iVar4 = 1;
  }
  return iVar4;
}



Boolean IsPointOnLineEnd(LocationType X,LocationType Y,RatTypePtr *Line)

{
  int iVar1;
  
  if ((Line->Point1).X == X) {
    if ((Line->Point1).Y == Y) {
      return '\x01';
    }
    iVar1 = (Line->Point2).X;
  }
  else {
    iVar1 = (Line->Point2).X;
  }
  if (iVar1 != X) {
    return '\0';
  }
  return (Boolean)(Y == (Line->Point2).Y);
}



Boolean IsPointOnLine(float X,float Y,float Radius,LineTypePtr Line)

{
  int iVar1;
  int iVar2;
  int iVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  int iVar10;
  
  Radius = ((float)Line->Thickness + 1.00000000) * 0.50000000 + Radius;
  iVar1 = (Line->Point2).Y;
  iVar2 = (Line->Point1).Y;
  iVar10 = iVar1;
  if (iVar2 <= iVar1) {
    iVar10 = iVar2;
  }
  if ((float)iVar10 <= Y + Radius) {
    iVar10 = iVar1;
    if (iVar1 <= iVar2) {
      iVar10 = iVar2;
    }
    if (Y - Radius <= (float)iVar10) {
      iVar10 = (Line->Point2).X;
      iVar3 = (Line->Point1).X;
      fVar5 = (float)(iVar10 - iVar3);
      fVar8 = (float)(iVar1 - iVar2);
      fVar9 = (float)iVar3 - X;
      fVar4 = (float)iVar2 - Y;
      Radius = Radius * Radius;
      fVar7 = fVar8 * fVar8 + fVar5 * fVar5;
      if (fVar7 != 0.00000000) {
        fVar6 = fVar5 * fVar4 - fVar8 * fVar9;
        if (Radius * fVar7 < fVar6 * fVar6) {
          return '\0';
        }
        fVar5 = -(fVar8 * fVar4 + fVar5 * fVar9);
        if ((0.00000000 <= fVar5) && (fVar5 <= fVar7)) {
          return '\x01';
        }
        if (0.00000000 <= fVar5) {
          X = (float)iVar10 - X;
          return ((float)iVar1 - Y) * ((float)iVar1 - Y) + X * X <= Radius;
        }
      }
      return (Boolean)(fVar4 * fVar4 + fVar9 * fVar9 <= Radius);
    }
  }
  return '\0';
}



int __regparm3 IsPointInQuadrangle(PointType *p,PointTypePtr l)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  bool bVar6;
  float10 fVar7;
  float10 fVar8;
  float10 fVar9;
  uint local_18;
  
  iVar1 = p[1].X;
  iVar2 = p[1].Y;
  iVar3 = l->X;
  iVar4 = l->Y;
  local_18 = 0xffffffff;
  fVar7 = (float10)(iVar1 - p->X);
  fVar8 = (float10)(iVar2 - p->Y);
  fVar9 = (float10)(iVar4 - p->Y) * fVar8 + (float10)(iVar3 - p->X) * fVar7;
  fVar7 = fVar8 * (float10)(iVar4 - iVar2) + fVar7 * (float10)(iVar3 - iVar1);
  if ((float10)0 <= fVar9) {
    local_18 = (uint)((float10)0 < fVar9);
  }
  uVar5 = 0xffffffff;
  if ((float10)0 <= fVar7) {
    uVar5 = (uint)((float10)0 < fVar7);
  }
  if (local_18 * uVar5 == 1) {
    return 0;
  }
  fVar7 = (float10)(iVar1 - p[2].X);
  uVar5 = 0xffffffff;
  fVar8 = (float10)(iVar2 - p[2].Y);
  fVar9 = (float10)(iVar4 - iVar2) * fVar8 + (float10)(iVar3 - iVar1) * fVar7;
  fVar7 = (float10)(iVar3 - p[2].X) * fVar7 + (float10)(iVar4 - p[2].Y) * fVar8;
  if ((float10)0 <= fVar9) {
    uVar5 = (uint)((float10)0 < fVar9);
  }
  if ((float10)0 <= fVar7) {
    bVar6 = uVar5 * ((float10)0 < fVar7) != 1;
  }
  else {
    bVar6 = uVar5 != 0xffffffff;
  }
  return (uint)bVar6;
}



Boolean IsPointInBox(LocationType X,LocationType Y,BoxTypePtr box,BDimension Radius)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  float10 fVar5;
  
  iVar2 = X - box->X1;
  iVar3 = Y - box->Y1;
  iVar1 = box->Y2 - box->Y1;
  if (iVar2 < 1) {
    if (iVar3 < 0) {
      if (Radius < 0) {
        return '\0';
      }
    }
    else {
      if (iVar3 <= iVar1) {
        iVar2 = -iVar2;
        goto LAB_080c99d3;
      }
      if (Radius < 0) {
        return '\0';
      }
      iVar3 = iVar3 - iVar1;
    }
    fVar5 = (float10)iVar3;
  }
  else {
    iVar4 = box->X2 - box->X1;
    if (iVar2 < iVar4) {
      if (iVar3 < 0) {
        iVar2 = -iVar3;
      }
      else {
        if (iVar3 <= iVar1) {
          return '\x01';
        }
        iVar2 = iVar3 - iVar1;
      }
LAB_080c99d3:
      return iVar2 < Radius;
    }
    if (iVar3 < 0) {
      if (Radius < 0) {
        return '\0';
      }
      iVar2 = iVar2 - iVar4;
      fVar5 = (float10)iVar3;
    }
    else {
      if (iVar3 <= iVar1) {
        iVar2 = iVar2 - iVar4;
        goto LAB_080c99d3;
      }
      if (Radius < 0) {
        return '\0';
      }
      iVar2 = iVar2 - iVar4;
      fVar5 = (float10)(iVar3 - iVar1);
    }
  }
  return (Boolean)((float10)iVar2 * (float10)iVar2 + fVar5 * fVar5 <
                  (float10)Radius * (float10)Radius);
}



Boolean IsPointOnPin(float X,float Y,float Radius,PinTypePtr *pin)

{
  Boolean BVar1;
  int iVar2;
  BoxType b;
  
  if ((*(byte *)((int)&(pin->Flags).f + 1) & 1) == 0) {
    X = (float)pin->X - X;
    Y = (float)pin->Y - Y;
    Radius = (float)(pin->Thickness / 2) + Radius;
    return (Boolean)(Y * Y + X * X <= Radius * Radius);
  }
  iVar2 = pin->Thickness / 2;
  b.X1 = pin->X - iVar2;
  b.X2 = iVar2 + pin->X;
  b.Y1 = pin->Y - iVar2;
  b.Y2 = iVar2 + pin->Y;
  BVar1 = IsPointInBox((int)ROUND(X),(int)ROUND(Y),(BoxTypePtr)&b,(int)ROUND(Radius));
  return (Boolean)(BVar1 != '\0');
}



ElementTypePtr * SearchElementByName(DataTypePtr *Base,char *Name)

{
  char *__s1;
  int iVar1;
  ElementTypePtr *pEVar2;
  int iVar3;
  
  iVar3 = Base->ElementN - 1;
  if (iVar3 != -1) {
    pEVar2 = Base->Element + (Base->ElementN - 1);
    do {
      __s1 = pEVar2->Name[1].TextString;
      if ((__s1 != (char *)0x0) && (Name != (char *)0x0)) {
        iVar1 = strcmp(__s1,Name);
        if (iVar1 == 0) {
          return pEVar2;
        }
      }
      iVar3 = iVar3 + -1;
      pEVar2 = pEVar2 + -1;
    } while (iVar3 != -1);
  }
  return (ElementTypePtr *)0x0;
}



int SearchObjectByID(DataTypePtr *Base,void **Result1,void **Result2,void **Result3,int ID,int type)

{
  PinTypePtr *pPVar1;
  PadTypePtr *pPVar2;
  ArcTypePtr *pAVar3;
  LineTypePtr pLVar4;
  RatTypePtr *pRVar5;
  void *pvVar6;
  ElementTypePtr *pEVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  TextType *pTVar11;
  ElementTypePtr *pEVar12;
  undefined *puVar13;
  RatTypePtr *pRVar14;
  void *pvVar15;
  undefined *puVar16;
  PadTypePtr *pPVar17;
  PinTypePtr *pPVar18;
  void *pvVar19;
  LineTypePtr pLVar20;
  ArcTypePtr *pAVar21;
  uint local_38;
  void *local_34;
  ElementTypePtr *local_28;
  undefined *local_24;
  uint local_20;
  
  if ((type == 0x1000) || (type == 4)) {
    pvVar19 = (void *)&Base->field_0x4c;
    iVar9 = PCB->Data->LayerN;
    if (iVar9 != -2) {
      local_20 = 0;
      do {
        iVar8 = *(int *)((int)pvVar19 + 4) + -1;
        if (iVar8 != -1) {
          pRVar14 = (RatTypePtr *)(*(int *)((int)pvVar19 + 0x24) + iVar8 * 0x58);
          if (pRVar14->ID == ID) {
LAB_080c9f90:
            *Result1 = pvVar19;
            *(RatTypePtr **)Result3 = pRVar14;
            *(RatTypePtr **)Result2 = pRVar14;
            return 4;
          }
          if ((pRVar14->Point1).ID == ID) {
LAB_080c9fb0:
            *Result1 = pvVar19;
            goto LAB_080c9fb5;
          }
          if ((pRVar14->Point2).ID == ID) {
LAB_080c9fd0:
            *Result1 = pvVar19;
            goto LAB_080c9fd5;
          }
          pRVar5 = (RatTypePtr *)
                   (*(int *)((int)pvVar19 + 0x24) + -0xb0 + *(int *)((int)pvVar19 + 4) * 0x58);
          while (pRVar14 = pRVar5, iVar8 = iVar8 + -1, iVar8 != -1) {
            if (pRVar14->ID == ID) goto LAB_080c9f90;
            if ((pRVar14->Point1).ID == ID) goto LAB_080c9fb0;
            pRVar5 = (RatTypePtr *)&pRVar14[-1].BoundingBox.Y1;
            if ((pRVar14->Point2).ID == ID) goto LAB_080c9fd0;
          }
        }
        local_20 = local_20 + 1;
        if (iVar9 + 2U <= local_20) break;
        pvVar19 = (void *)((int)pvVar19 + 0x5c);
      } while( true );
    }
  }
  if (type == 0x4000) {
    pvVar19 = (void *)&Base->field_0x4c;
    iVar9 = PCB->Data->LayerN;
    if (iVar9 != -2) {
      local_20 = 0;
      do {
        iVar8 = *(int *)((int)pvVar19 + 0x10) + -1;
        if (iVar8 != -1) {
          pvVar15 = (void *)(*(int *)((int)pvVar19 + 0x30) + iVar8 * 0x44);
          if (*(int *)((int)pvVar15 + 0x10) == ID) {
LAB_080c9ff0:
            *Result1 = pvVar19;
            *Result3 = pvVar15;
            *Result2 = pvVar15;
            return 0x4000;
          }
          pvVar6 = (void *)(*(int *)((int)pvVar19 + 0x30) +
                           *(int *)((int)pvVar19 + 0x10) * 0x44 + -0x88);
          while (pvVar15 = pvVar6, iVar8 = iVar8 + -1, iVar8 != -1) {
            pvVar6 = (void *)((int)pvVar15 + -0x44);
            if (*(int *)((int)pvVar15 + 0x10) == ID) goto LAB_080c9ff0;
          }
        }
        local_20 = local_20 + 1;
        if (iVar9 + 2U <= local_20) goto LAB_080c9e52;
        pvVar19 = (void *)((int)pvVar19 + 0x5c);
      } while( true );
    }
  }
  else {
    if (type == 0x10) {
      pvVar19 = (void *)&Base->field_0x4c;
      iVar9 = PCB->Data->LayerN;
      if (iVar9 != -2) {
        local_20 = 0;
        do {
          iVar8 = *(int *)((int)pvVar19 + 8) + -1;
          if (iVar8 != -1) {
            puVar16 = (undefined *)(*(int *)((int)pvVar19 + 0x28) + iVar8 * 0x3c);
            if (*(int *)(puVar16 + 0x10) == ID) {
LAB_080ca090:
              *Result1 = pvVar19;
              *(undefined **)Result3 = puVar16;
              *(undefined **)Result2 = puVar16;
              return 0x10;
            }
            puVar13 = &DAT_ffffff88 +
                      *(int *)((int)pvVar19 + 8) * 0x3c + *(int *)((int)pvVar19 + 0x28);
            while (puVar16 = puVar13, iVar8 = iVar8 + -1, iVar8 != -1) {
              puVar13 = puVar16 + -0x3c;
              if (*(int *)(puVar16 + 0x10) == ID) goto LAB_080ca090;
            }
          }
          local_20 = local_20 + 1;
          if (iVar9 + 2U <= local_20) goto LAB_080c9e52;
          pvVar19 = (void *)((int)pvVar19 + 0x5c);
        } while( true );
      }
    }
  }
  if ((type == 0x800) || (type == 8)) {
    local_34 = (void *)&Base->field_0x4c;
    iVar9 = PCB->Data->LayerN;
    if (iVar9 != -2) {
      local_38 = 0;
      do {
        local_20 = *(int *)((int)local_34 + 0xc) + -1;
        if (local_20 != -1) {
          local_24 = (undefined *)(*(int *)((int)local_34 + 0x2c) + local_20 * 0x3c);
          if (*(int *)(local_24 + 0x10) == ID) {
LAB_080ca2c5:
            *Result1 = local_34;
            *(undefined **)Result3 = local_24;
            *(undefined **)Result2 = local_24;
            return 8;
          }
          puVar16 = &DAT_ffffff88 +
                    *(int *)((int)local_34 + 0xc) * 0x3c + *(int *)((int)local_34 + 0x2c);
          do {
            puVar13 = puVar16;
            if (type == 0x800) {
              iVar8 = *(int *)(local_24 + 0x24) + -1;
              if (iVar8 != -1) {
                pvVar19 = (void *)(*(int *)(local_24 + 0x38) + iVar8 * 0x14);
                if (*(int *)((int)pvVar19 + 0x10) == ID) {
LAB_080c9cdc:
                  *Result1 = local_34;
                  *(undefined **)Result2 = local_24;
                  *Result3 = pvVar19;
                  return 0x800;
                }
                pvVar15 = (void *)(*(int *)(local_24 + 0x38) + -0x28 +
                                  *(int *)(local_24 + 0x24) * 0x14);
                while (pvVar19 = pvVar15, iVar8 = iVar8 + -1, iVar8 != -1) {
                  pvVar15 = (void *)((int)pvVar19 + -0x14);
                  if (*(int *)((int)pvVar19 + 0x10) == ID) goto LAB_080c9cdc;
                }
              }
            }
            local_20 = local_20 + -1;
            if (local_20 == -1) break;
            puVar16 = puVar13 + -0x3c;
            local_24 = puVar13;
            if (*(int *)(puVar13 + 0x10) == ID) goto LAB_080ca2c5;
          } while( true );
        }
        local_38 = local_38 + 1;
        if (iVar9 + 2U <= local_38) break;
        local_34 = (void *)((int)local_34 + 0x5c);
      } while( true );
    }
  }
  if (type == 1) {
    if (Base->ViaN != 0) {
      pPVar18 = Base->Via;
      uVar10 = 1;
      pPVar1 = pPVar18;
      if (pPVar18->ID == ID) {
LAB_080ca23f:
        *(PinTypePtr **)Result3 = pPVar18;
        *(PinTypePtr **)Result2 = pPVar18;
        *(PinTypePtr **)Result1 = pPVar18;
        return 1;
      }
      while (pPVar18 = pPVar1 + 1, uVar10 < Base->ViaN) {
        if (pPVar1[1].ID == ID) goto LAB_080ca23f;
        uVar10 = uVar10 + 1;
        pPVar1 = pPVar18;
      }
    }
LAB_080c9e52:
    if (type != 0x1000) goto LAB_080c9ec2;
  }
  else {
    if (type != 0x20) goto LAB_080c9e52;
  }
  iVar9 = Base->RatN - 1;
  if (iVar9 != -1) {
    pRVar14 = Base->Rat + iVar9;
    if (pRVar14->ID == ID) {
LAB_080ca316:
      *(RatTypePtr **)Result3 = pRVar14;
      *(RatTypePtr **)Result2 = pRVar14;
      *(RatTypePtr **)Result1 = pRVar14;
      return 0x20;
    }
    if ((pRVar14->Point1).ID == ID) {
LAB_080ca32f:
      *Result1 = (void *)0x0;
LAB_080c9fb5:
      *(RatTypePtr **)Result2 = pRVar14;
      *(PointType **)Result3 = &pRVar14->Point1;
      return 0x1000;
    }
    if ((pRVar14->Point2).ID != ID) {
      pRVar5 = Base->Rat + (Base->RatN - 2);
      do {
        pRVar14 = pRVar5;
        iVar9 = iVar9 + -1;
        if (iVar9 == -1) goto LAB_080c9ec2;
        if (pRVar14->ID == ID) goto LAB_080ca316;
        if ((pRVar14->Point1).ID == ID) goto LAB_080ca32f;
        pRVar5 = pRVar14 + -1;
      } while ((pRVar14->Point2).ID != ID);
    }
    *Result1 = (void *)0x0;
LAB_080c9fd5:
    *(RatTypePtr **)Result2 = pRVar14;
    *(PointType **)Result3 = &pRVar14->Point2;
    return 0x1000;
  }
LAB_080c9ec2:
  if (((((type == 0x200) || (type == 2)) || (type == 0x2000)) ||
      ((type == 0x100 || (type == 0x8000)))) || (type == 0x400)) {
    local_20 = Base->ElementN - 1;
    if (local_20 != -1) {
      local_28 = Base->Element + local_20;
      if (local_28->ID != ID) {
        pEVar12 = local_28;
        pEVar7 = Base->Element + (Base->ElementN - 2);
        do {
          local_28 = pEVar7;
          if (type == 0x2000) {
            iVar9 = pEVar12->LineN - 1;
            if (iVar9 != -1) {
              pLVar20 = pEVar12->Line + iVar9;
              if (pLVar20->ID == ID) {
LAB_080ca2e4:
                *(ElementTypePtr **)Result1 = pEVar12;
                *(LineTypePtr *)Result3 = pLVar20;
                *(LineTypePtr *)Result2 = pLVar20;
                return 0x2000;
              }
              pLVar4 = pEVar12->Line + (pEVar12->LineN - 2);
              while (pLVar20 = pLVar4, iVar9 = iVar9 + -1, iVar9 != -1) {
                pLVar4 = pLVar20 + -1;
                if (pLVar20->ID == ID) goto LAB_080ca2e4;
              }
            }
LAB_080ca1a8:
            if ((type == 0x200) && (pEVar12->PadN != 0)) {
              pPVar17 = pEVar12->Pad;
              if (pPVar17->ID == ID) {
LAB_080ca1f0:
                *(ElementTypePtr **)Result1 = pEVar12;
                *(PadTypePtr **)Result3 = pPVar17;
                *(PadTypePtr **)Result2 = pPVar17;
                return 0x200;
              }
              uVar10 = 1;
              pPVar2 = pPVar17;
              while (pPVar17 = pPVar2 + 1, uVar10 < pEVar12->PadN) {
                if (pPVar2[1].ID == ID) goto LAB_080ca1f0;
                uVar10 = uVar10 + 1;
                pPVar2 = pPVar17;
              }
            }
          }
          else {
            if (type == 0x8000) {
              iVar9 = pEVar12->ArcN - 1;
              if (iVar9 != -1) {
                pAVar21 = pEVar12->Arc + iVar9;
                if (pAVar21->ID == ID) {
LAB_080ca2fd:
                  *(ElementTypePtr **)Result1 = pEVar12;
                  *(ArcTypePtr **)Result3 = pAVar21;
                  *(ArcTypePtr **)Result2 = pAVar21;
                  return 0x8000;
                }
                pAVar3 = pEVar12->Arc + (pEVar12->ArcN - 2);
                while (pAVar21 = pAVar3, iVar9 = iVar9 + -1, iVar9 != -1) {
                  pAVar3 = pAVar21 + -1;
                  if (pAVar21->ID == ID) goto LAB_080ca2fd;
                }
              }
              goto LAB_080ca1a8;
            }
            if (type == 0x400) {
              pTVar11 = pEVar12->Name + 2;
              if (((pEVar12->Name[2].ID == ID) ||
                  (pTVar11 = pEVar12->Name + 1, pEVar12->Name[1].ID == ID)) ||
                 (pTVar11 = pEVar12->Name, pEVar12->Name[0].ID == ID)) {
                *(ElementTypePtr **)Result1 = pEVar12;
                *(TextType **)Result3 = pTVar11;
                *(TextType **)Result2 = pTVar11;
                return 0x400;
              }
            }
            else {
              if (type != 0x100) goto LAB_080ca1a8;
              if (pEVar12->PinN != 0) {
                pPVar18 = pEVar12->Pin;
                if (pPVar18->ID == ID) {
LAB_080ca34e:
                  *(ElementTypePtr **)Result1 = pEVar12;
                  *(PinTypePtr **)Result3 = pPVar18;
                  *(PinTypePtr **)Result2 = pPVar18;
                  return 0x100;
                }
                uVar10 = 1;
                pPVar1 = pPVar18;
                while (pPVar18 = pPVar1 + 1, uVar10 < pEVar12->PinN) {
                  if (pPVar1[1].ID == ID) goto LAB_080ca34e;
                  uVar10 = uVar10 + 1;
                  pPVar1 = pPVar18;
                }
              }
            }
          }
          local_20 = local_20 + -1;
          if (local_20 == -1) goto LAB_080ca0e7;
          pEVar12 = local_28;
          pEVar7 = local_28 + -1;
        } while (local_28->ID != ID);
      }
      *(ElementTypePtr **)Result3 = local_28;
      *(ElementTypePtr **)Result2 = local_28;
      *(ElementTypePtr **)Result1 = local_28;
      return 2;
    }
  }
LAB_080ca0e7:
  Message("hace: Internal error, search for ID %d failed\n",ID);
  return 0;
}



Boolean __regparm3
SearchRatLineByLocation(int locked,RatTypePtr **Line,RatTypePtr **Dummy1,RatTypePtr **Dummy2)

{
  int iVar1;
  ans_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  info.ptr3 = Dummy2;
  info.ptr1 = Line;
  info.ptr2 = Dummy1;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    return '\x01';
  }
  r_search(PCB->Data->rat_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,rat_callback,
           &info);
  return '\0';
}



Boolean __regparm3
SearchViaByLocation(int locked,PinTypePtr **Via,PinTypePtr **Dummy1,PinTypePtr **Dummy2)

{
  int iVar1;
  Boolean BVar2;
  ans_info info;
  
  BVar2 = '\0';
  if (PCB->ViaOn != '\0') {
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    info.ptr3 = Dummy2;
    info.ptr1 = Via;
    info.ptr2 = Dummy1;
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    BVar2 = '\x01';
    if (iVar1 == 0) {
      r_search(PCB->Data->via_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               pinorvia_callback,&info);
      return '\0';
    }
  }
  return BVar2;
}



Boolean __regparm3
SearchPinByLocation(int locked,ElementTypePtr **Element,PinTypePtr **Pin,PinTypePtr **Dummy)

{
  int iVar1;
  Boolean BVar2;
  ans_info info;
  
  BVar2 = '\0';
  if (PCB->PinOn != '\0') {
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    info.ptr3 = Dummy;
    info.ptr1 = Element;
    info.ptr2 = Pin;
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    BVar2 = '\x01';
    if (iVar1 == 0) {
      r_search(PCB->Data->pin_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
               pinorvia_callback,&info);
      return '\0';
    }
  }
  return BVar2;
}



undefined4 SearchLineByLocation(undefined4 param_1)

{
  uint in_EAX;
  int iVar1;
  LayerTypePtr *in_EDX;
  undefined local_b8 [4];
  undefined4 local_b4;
  undefined local_ac [156];
  uint local_10;
  
  local_10 = -(uint)((in_EAX & 0x10000) == 0) & 0x2000;
  *in_EDX = SearchLayer;
  local_b4 = param_1;
  iVar1 = _setjmp((__jmp_buf_tag *)local_ac);
  if (iVar1 != 0) {
    return 1;
  }
  r_search(SearchLayer->line_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,line_callback
           ,local_b8);
  return 0;
}



Boolean __regparm3
SearchArcByLocation(int locked,LayerTypePtr *Layer,ArcTypePtr **Arc,ArcTypePtr **Dummy)

{
  int iVar1;
  arc_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.Dummy = Dummy;
  info.Arc = Arc;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 != 0) {
    return '\x01';
  }
  r_search(SearchLayer->arc_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,arc_callback,
           &info);
  return '\0';
}



Boolean __regparm3
SearchTextByLocation(int locked,LayerTypePtr *Layer,TextTypePtr *Text,TextTypePtr *Dummy)

{
  int iVar1;
  ans_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.ptr3 = Dummy;
  info.ptr2 = Text;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(SearchLayer->text_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             text_callback,&info);
  }
  return (Boolean)(iVar1 != 0);
}



Boolean __regparm3
SearchPolygonByLocation
          (int locked,LayerTypePtr *Layer,PolygonTypePtr *Polygon,PolygonTypePtr *Dummy)

{
  int iVar1;
  ans_info info;
  
  info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
  *Layer = SearchLayer;
  info.ptr3 = Dummy;
  info.ptr2 = Polygon;
  iVar1 = _setjmp((__jmp_buf_tag *)info.env);
  if (iVar1 == 0) {
    r_search(SearchLayer->polygon_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
             polygon_callback,&info);
  }
  return (Boolean)(iVar1 != 0);
}



Boolean __regparm3
SearchPadByLocation(int locked,ElementTypePtr **Element,PadTypePtr *Pad,PadTypePtr *Dummy,
                   Boolean BackToo)

{
  int iVar1;
  Boolean BVar2;
  bool local_dd;
  ans_info info;
  
  BVar2 = '\0';
  if (PCB->PinOn != '\0') {
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    local_dd = false;
    if (BackToo != '\0') {
      local_dd = PCB->InvisibleObjectsOn != '\0';
    }
    info.BackToo = local_dd;
    info.ptr3 = (void **)Dummy;
    info.ptr1 = Element;
    info.ptr2 = (void **)Pad;
    iVar1 = _setjmp((__jmp_buf_tag *)info.env);
    BVar2 = '\x01';
    if (iVar1 == 0) {
      BVar2 = '\0';
      r_search(PCB->Data->pad_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,pad_callback
               ,&info);
    }
  }
  return BVar2;
}



Boolean __regparm3
SearchElementNameByLocation
          (int locked,ElementTypePtr **Element,TextTypePtr *Text,TextTypePtr *Dummy,Boolean BackToo)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  bool local_dd;
  ans_info info;
  
  bVar4 = false;
  if (PCB->ElementOn != '\0') {
    local_dd = false;
    if (BackToo != '\0') {
      local_dd = PCB->InvisibleObjectsOn != '\0';
    }
    uVar1 = (PCB->Flags).f;
    uVar3 = 1;
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    if ((uVar1 & 0x40) == 0) {
      uVar3 = -(uint)((uVar1 & 0x20) == 0) & 2;
    }
    info.ptr3 = Dummy;
    info.area = 100000000376832.00000000;
    info.BackToo = local_dd;
    info.ptr1 = Element;
    info.ptr2 = Text;
    iVar2 = r_search(PCB->Data->name_tree[uVar3],&SearchBox,
                     (anon_subr_int_BoxType_ptr_void_ptr *)0x0,name_callback,&info);
    bVar4 = iVar2 != 0;
  }
  return (Boolean)bVar4;
}



Boolean __regparm3
SearchElementByLocation
          (int locked,ElementTypePtr **Element,ElementTypePtr **Dummy1,ElementTypePtr **Dummy2,
          Boolean BackToo)

{
  int iVar1;
  bool bVar2;
  ans_info info;
  
  if ((PCB->ElementOn == '\0') || (PCB->PinOn == '\0')) {
    bVar2 = false;
  }
  else {
    info.BackToo = false;
    if (BackToo != '\0') {
      info.BackToo = PCB->InvisibleObjectsOn != '\0';
    }
    info.locked = -(uint)((locked & 0x10000U) == 0) & 0x2000;
    info.ptr3 = Dummy2;
    info.area = 100000000376832.00000000;
    info.ptr1 = Element;
    info.ptr2 = Dummy1;
    iVar1 = r_search(PCB->Data->element_tree,&SearchBox,(anon_subr_int_BoxType_ptr_void_ptr *)0x0,
                     element_callback,&info);
    bVar2 = iVar1 != 0;
  }
  return (Boolean)bVar2;
}



undefined4
SearchObjectByLocation
          (uint param_1,ElementTypePtr **param_2,PadTypePtr *param_3,PadTypePtr *param_4,int param_5
          ,int param_6,int param_7)

{
  uint uVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  bool bVar5;
  float fVar6;
  BDimension BVar7;
  Boolean BVar8;
  char cVar9;
  int *piVar10;
  undefined4 uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  PCBTypePtr pPVar15;
  DataTypePtr *pDVar16;
  int iVar17;
  uint locked;
  undefined *puVar18;
  float local_110;
  uint local_104;
  undefined *local_f0;
  int local_ec;
  ElementTypePtr *local_e8;
  int local_e4;
  PadTypePtr *local_d4;
  PadTypePtr *local_d0;
  float local_cc;
  uint local_2c;
  ElementTypePtr *local_28;
  ElementTypePtr *local_24;
  ElementTypePtr *local_20 [4];
  
  PosX = (float)param_5;
  locked = param_1 & 0x10000;
  PosY = (float)param_6;
  SearchRadius = param_7;
  if (param_7 == 0) {
    SearchBox.X1 = param_5;
    SearchBox.X2 = param_5 + 1;
    SearchBox.Y1 = param_6;
    SearchBox.Y2 = param_6 + 1;
  }
  else {
    SearchBox.X1 = param_5 - param_7;
    SearchBox.Y1 = param_6 - param_7;
    SearchBox.X2 = param_7 + param_5;
    SearchBox.Y2 = param_7 + param_6;
  }
  uVar1 = (PCB->Flags).f;
  uVar13 = param_1 & 0xfffffbef;
  if ((uVar1 & 0x240000) == 0) {
    uVar13 = param_1;
  }
  uVar12 = uVar13 & 0x410;
  if ((uVar1 & 0x80000) == 0) {
    uVar12 = uVar13;
  }
  uVar13 = uVar12 & 0xfffffff7;
  if ((uVar1 & 0x24000) == 0) {
    uVar13 = uVar12;
  }
  if ((((uVar13 & 0x20) != 0) && (PCB->RatOn != '\0')) &&
     (BVar8 = SearchRatLineByLocation
                        (locked,(RatTypePtr **)param_2,(RatTypePtr **)param_3,(RatTypePtr **)param_4
                        ), BVar8 != '\0')) {
    return 0x20;
  }
  if (((uVar13 & 1) != 0) &&
     (BVar8 = SearchViaByLocation(locked,(PinTypePtr **)param_2,(PinTypePtr **)param_3,
                                  (PinTypePtr **)param_4), BVar8 != '\0')) {
    return 1;
  }
  if ((uVar13 & 0x100) == 0) {
LAB_080cab56:
    if (((uVar13 & 0x200) == 0) ||
       (BVar8 = SearchPadByLocation(locked,local_20,(PadTypePtr *)&local_24,(PadTypePtr *)&local_28,
                                    '\0'), BVar8 == '\0')) {
      if (((uVar13 & 0x400) == 0) ||
         (BVar8 = SearchElementNameByLocation
                            (locked,local_20,(TextTypePtr *)&local_24,(TextTypePtr *)&local_28,'\0')
         , BVar8 == '\0')) {
        if (((uVar13 & 2) == 0) ||
           (BVar8 = SearchElementByLocation(locked,local_20,&local_24,&local_28,'\0'), BVar8 == '\0'
           )) {
          local_104 = 0;
          local_110 = 0.00000000;
        }
        else {
          local_104 = 2;
          local_110 = (float)((local_20[0]->BoundingBox).Y2 - (local_20[0]->BoundingBox).Y1) *
                      (float)((local_20[0]->BoundingBox).X2 - (local_20[0]->BoundingBox).X1);
        }
      }
      else {
        local_104 = 0x400;
        local_110 = (float)((local_24->BoundingBox).Y2 - (local_24->BoundingBox).Y1) *
                    (float)((local_24->BoundingBox).X2 - (local_24->BoundingBox).X1);
      }
      goto LAB_080cab92;
    }
    local_104 = 0x200;
  }
  else {
    BVar8 = SearchPinByLocation(locked,local_20,(PinTypePtr **)&local_24,(PinTypePtr **)&local_28);
    local_104 = 0x100;
    if (BVar8 == '\0') goto LAB_080cab56;
  }
  local_110 = 0.00000000;
LAB_080cab92:
  pDVar16 = PCB->Data;
  iVar17 = pDVar16->LayerN;
  if (-2 < iVar17) {
    local_e4 = -1;
    pPVar15 = PCB;
    do {
      BVar7 = SearchRadius;
      if (local_e4 == -1) {
        local_e8 = (ElementTypePtr *)
                   (&pDVar16->field_0x4c + (iVar17 + (uint)(Settings.ShowSolderSide == '\0')) * 0x5c
                   );
LAB_080cac3f:
        SearchLayer = (LayerTypePtr)local_e8;
        if (*(char *)&local_e8->Name[0].net != '\0') {
          if ((local_104 & 0x300) == 0) {
            if ((uVar13 & 0x800) != 0) {
              iVar17 = (local_e8->BoundingBox).Y2;
              local_ec = iVar17 + -1;
              *param_2 = local_e8;
              fVar6 = PosY;
              fVar2 = PosX;
              if (local_ec != -1) {
                local_f0 = (undefined *)(iVar17 * 0x3c);
                bVar5 = false;
                fVar4 = (float)BVar7 * (float)BVar7;
                do {
                  local_f0 = &DAT_ffffffc4 + (int)local_f0;
                  puVar18 = local_f0 + local_e8->Name[0].BoundingBox.X2;
                  iVar17 = *(int *)(puVar18 + 0x24) + -1;
                  if (iVar17 != -1) {
                    iVar14 = *(int *)(puVar18 + 0x24) * 0x14;
                    do {
                      iVar14 = iVar14 + -0x14;
                      piVar10 = (int *)(*(int *)(puVar18 + 0x38) + iVar14);
                      fVar3 = ((float)piVar10[1] - fVar6) * ((float)piVar10[1] - fVar6) +
                              ((float)*piVar10 - fVar2) * ((float)*piVar10 - fVar2);
                      if (fVar3 < fVar4) {
                        *(int **)&(param_4->BoundingBox).X1 = piVar10;
                        *(undefined **)&(param_3->BoundingBox).X1 = puVar18;
                        bVar5 = true;
                        fVar4 = fVar3;
                      }
                      iVar17 = iVar17 + -1;
                    } while (iVar17 != -1);
                  }
                  local_ec = local_ec + -1;
                } while (local_ec != -1);
                if (bVar5) {
                  return 0x800;
                }
              }
            }
            BVar7 = SearchRadius;
            if ((uVar13 & 0x1000) != 0) {
              *param_2 = local_e8;
              (param_4->BoundingBox).X1 = 0;
              local_d4 = param_3;
              local_2c = -(uint)(locked == 0) & 0x2000;
              local_d0 = param_4;
              local_cc = (float)(BVar7 * BVar7);
              iVar17 = r_search((rtree_t *)local_e8->Name[0].ID,&SearchBox,
                                (anon_subr_int_BoxType_ptr_void_ptr *)0x0,linepoint_callback,
                                &local_d4);
              if (iVar17 != 0) {
                return 0x1000;
              }
            }
            if (((uVar13 & 4) != 0) && (cVar9 = SearchLineByLocation(param_4), cVar9 != '\0')) {
              return 4;
            }
            if (((uVar13 & 0x4000) != 0) &&
               (BVar8 = SearchArcByLocation(locked,(LayerTypePtr *)param_2,(ArcTypePtr **)param_3,
                                            (ArcTypePtr **)param_4), BVar8 != '\0')) {
              return 0x4000;
            }
            if (((uVar13 & 0x10) != 0) &&
               (BVar8 = SearchTextByLocation
                                  (locked,(LayerTypePtr *)param_2,(TextTypePtr *)param_3,
                                   (TextTypePtr *)param_4), BVar8 != '\0')) {
              return 0x10;
            }
          }
          pPVar15 = PCB;
          if (((uVar13 & 8) != 0) &&
             (BVar8 = SearchPolygonByLocation
                                (locked,(LayerTypePtr *)param_2,(PolygonTypePtr *)param_3,
                                 (PolygonTypePtr *)param_4), pPVar15 = PCB, BVar8 != '\0')) {
            if ((local_104 == 0) ||
               (piVar10 = (int *)(param_3->BoundingBox).X1, fVar2 = (float)(piVar10[2] - *piVar10),
               fVar2 * fVar2 <= local_110)) {
              return 8;
            }
            break;
          }
        }
      }
      else {
        if (local_e4 < iVar17) {
          local_e8 = (ElementTypePtr *)(&pDVar16->field_0x4c + LayerStack[local_e4] * 0x5c);
          goto LAB_080cac3f;
        }
        SearchLayer = (LayerTypePtr)
                      (&pDVar16->field_0x4c +
                      (iVar17 + (uint)(Settings.ShowSolderSide != '\0')) * 0x5c);
        local_e8 = (ElementTypePtr *)SearchLayer;
        if (pPVar15->InvisibleObjectsOn != '\0') goto LAB_080cac3f;
      }
      pDVar16 = pPVar15->Data;
      local_e4 = local_e4 + 1;
      iVar17 = pDVar16->LayerN;
    } while (local_e4 <= iVar17);
  }
  if ((local_104 & 0x100) == 0) {
    if ((local_104 & 0x200) == 0) {
      if ((local_104 & 0x400) == 0) {
        if ((local_104 & 2) == 0) {
          if (PCB->InvisibleObjectsOn != '\0') {
            if (((uVar13 & 0x200) != 0) &&
               (BVar8 = SearchPadByLocation(locked,param_2,param_3,param_4,'\x01'), BVar8 != '\0'))
            {
              return 0x200;
            }
            if (((uVar13 & 0x400) != 0) &&
               (BVar8 = SearchElementNameByLocation
                                  (locked,param_2,(TextTypePtr *)param_3,(TextTypePtr *)param_4,
                                   '\x01'), BVar8 != '\0')) {
              return 0x400;
            }
            if (((uVar13 & 2) != 0) &&
               (BVar8 = SearchElementByLocation
                                  (locked,param_2,(ElementTypePtr **)param_3,
                                   (ElementTypePtr **)param_4,'\x01'), BVar8 != '\0')) {
              return 2;
            }
          }
          uVar11 = 0;
        }
        else {
          *param_2 = local_20[0];
          *(ElementTypePtr **)&(param_3->BoundingBox).X1 = local_24;
          *(ElementTypePtr **)&(param_4->BoundingBox).X1 = local_28;
          uVar11 = 2;
        }
      }
      else {
        *param_2 = local_20[0];
        *(ElementTypePtr **)&(param_3->BoundingBox).X1 = local_24;
        *(ElementTypePtr **)&(param_4->BoundingBox).X1 = local_28;
        uVar11 = 0x400;
      }
    }
    else {
      *param_2 = local_20[0];
      *(ElementTypePtr **)&(param_3->BoundingBox).X1 = local_24;
      *(ElementTypePtr **)&(param_4->BoundingBox).X1 = local_28;
      uVar11 = 0x200;
    }
  }
  else {
    *param_2 = local_20[0];
    *(ElementTypePtr **)&(param_3->BoundingBox).X1 = local_24;
    *(ElementTypePtr **)&(param_4->BoundingBox).X1 = local_28;
    uVar11 = 0x100;
  }
  return uVar11;
}



int SearchScreen(LocationType X,LocationType Y,int Type,void **Result1,void **Result2,void **Result3
                )

{
  int iVar1;
  
  iVar1 = SearchObjectByLocation(Type,Result1,Result2,Result3,X,Y,pixel_slop * 5);
  return iVar1;
}



// WARNING: Type propagation algorithm not settling

int rat_callback(BoxType *box,void *cl)

{
  BoxType **ppBVar1;
  BoxType *pBVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  Boolean BVar6;
  bool bVar7;
  
  if ((*(uint *)((int)cl + 0xb0) & box[1].Y1) == 0) {
    if ((box[1].Y1 & 2U) == 0) {
      BVar6 = IsPointOnLine(PosX,PosY,(float)SearchRadius,(LineTypePtr)box);
      bVar7 = BVar6 != '\0';
    }
    else {
      fVar3 = (float)box[2].Y2 - PosX;
      fVar5 = (float)box[3].X1 - PosY;
      fVar4 = (float)(box[2].Y1 * 2 + SearchRadius);
      bVar7 = fVar5 * fVar5 + fVar3 * fVar3 <= fVar4 * fVar4;
    }
    if (bVar7) {
      ppBVar1 = *(BoxType ***)cl;
      pBVar2 = *(BoxType **)((int)cl + 4);
      *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = box;
      *(BoxType **)&pBVar2->X1 = box;
      *ppBVar1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

int pinorvia_callback(BoxType *box,void *cl)

{
  Boolean BVar1;
  BoxType *pBVar2;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xb0)) == 0) {
    BVar1 = IsPointOnPin(PosX,PosY,(float)SearchRadius,(PinTypePtr *)box);
    if (BVar1 != '\0') {
      pBVar2 = (BoxType *)box[4].Y1;
      if ((BoxType *)box[4].Y1 == (BoxType *)0x0) {
        pBVar2 = box;
      }
      **(BoxType ***)cl = pBVar2;
      pBVar2 = *(BoxType **)((int)cl + 4);
      *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = box;
      *(BoxType **)&pBVar2->X1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

int text_callback(BoxType *box,void *cl)

{
  BoxType *pBVar1;
  
  if (((((box[1].Y1 & *(uint *)((int)cl + 0xb0)) == 0) && ((float)box->X1 <= PosX)) &&
      (PosX <= (float)box->X2)) && (((float)box->Y1 <= PosY && (PosY <= (float)box->Y2)))) {
    pBVar1 = *(BoxType **)((int)cl + 4);
    *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = box;
    *(BoxType **)&pBVar1->X1 = box;
                    // WARNING: Subroutine does not return
    __longjmp_chk((int)cl + 0x14,1);
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

int polygon_callback(BoxType *box,void *cl)

{
  BoxType *pBVar1;
  Boolean BVar2;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xb0)) == 0) {
    BVar2 = IsPointInPolygon((int)ROUND(PosX),(int)ROUND(PosY),SearchRadius,(PolygonTypePtr)box);
    if (BVar2 != '\0') {
      pBVar1 = *(BoxType **)((int)cl + 4);
      *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = box;
      *(BoxType **)&pBVar1->X1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x080cb682)
// WARNING: Removing unreachable block (ram,0x080cb686)
// WARNING: Removing unreachable block (ram,0x080cb688)

Boolean IsPointOnArc(float X,float Y,float Radius,ArcTypePtr *Arc)

{
  float fVar1;
  float fVar2;
  float fVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  double dVar9;
  
  X = X - (float)Arc->X;
  Y = Y - (float)Arc->Y;
  fVar2 = Y * Y + X * X;
  if (fVar2 == 0.00000000) {
    return (float)Arc->Width <= (float)Arc->Thickness * 0.50000000 + Radius;
  }
  fVar3 = (float)Arc->Width * (float)Arc->Width;
  Radius = (float)Arc->Thickness * 0.50000000 + Radius;
  fVar1 = (((fVar3 - Radius * Radius) + fVar2) * 0.50000000) / fVar2;
  fVar2 = (fVar2 / fVar3 - fVar1 * fVar1) + 0.00001000;
  if (fVar2 < 0.00000000) {
    return '\0';
  }
  fVar2 = SQRT(fVar2);
  iVar5 = Arc->StartAngle;
  iVar8 = Arc->Delta;
  fVar3 = -fVar2 * X;
  fVar2 = Y * fVar2;
  while (iVar5 < 0) {
    iVar5 = iVar5 + 0x168;
  }
  if (iVar8 < 0) {
    iVar7 = iVar5 + iVar8;
    iVar8 = -iVar8;
    while ((iVar5 = iVar7, iVar7 < 0 && (iVar5 = iVar7 + 0x168, iVar5 < 0))) {
      iVar7 = iVar7 + 0x2d0;
    }
  }
  dVar9 = atan2((double)(fVar1 * Y + fVar3),(double)-(fVar1 * X + fVar2));
  iVar7 = (int)ROUND(dVar9 * 57.29577951);
  if (iVar7 < 0) {
    iVar7 = iVar7 + 0x168;
  }
  dVar9 = atan2((double)(fVar1 * Y - fVar3),(double)-(fVar1 * X - fVar2));
  iVar4 = (int)ROUND(dVar9 * 57.29577951);
  if (iVar4 < 0) {
    iVar4 = iVar4 + 0x168;
  }
  iVar4 = iVar4 - iVar7;
  if (iVar4 < 0xb5) {
    if (iVar4 < -0xb4) {
      iVar4 = iVar4 + 0x168;
    }
  }
  else {
    iVar4 = iVar4 + -0x168;
  }
  if (iVar4 < 0) {
    iVar6 = iVar7 + iVar4;
    iVar4 = -iVar4;
    while ((iVar7 = iVar6, iVar6 < 0 && (iVar7 = iVar6 + 0x168, iVar7 < 0))) {
      iVar6 = iVar6 + 0x2d0;
    }
  }
  if (iVar5 <= iVar7) {
    if (iVar7 <= iVar8 + iVar5) {
      return '\x01';
    }
    if (iVar5 < iVar7) goto LAB_080cb7a3;
  }
  if (iVar5 <= iVar4 + iVar7) {
    return '\x01';
  }
LAB_080cb7a3:
  if ((0x167 < iVar8 + iVar5) && (iVar7 < iVar8 + iVar5 + -0x167)) {
    return '\x01';
  }
  if (iVar4 + iVar7 < 0x168) {
    return '\0';
  }
  return iVar5 < iVar4 + iVar7 + -0x167;
}



// WARNING: Type propagation algorithm not settling

int arc_callback(BoxType *box,void *cl)

{
  Boolean BVar1;
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xa4)) == 0) {
    BVar1 = IsPointOnArc(PosX,PosY,(float)SearchRadius,(ArcTypePtr *)box);
    if (BVar1 != '\0') {
      **(BoxType ***)cl = box;
      *(BoxType **)&(*(BoxType **)((int)cl + 4))->X1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 8,1);
    }
  }
  return 0;
}



Boolean IsPointInPad(LocationType X,LocationType Y,BDimension Radius,PadTypePtr Pad)

{
  uint uVar1;
  int iVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  bool bVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  LocationType *pLVar10;
  int iVar11;
  PadType *pPVar12;
  int in_GS_OFFSET;
  int local_90;
  PadType pad;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = *(int *)(Pad.BoundingBox.X1 + 0x24);
  iVar8 = 0x1a;
  pLVar10 = (LocationType *)Pad.BoundingBox.X1;
  pPVar12 = &pad;
  while (iVar8 != 0) {
    iVar8 = iVar8 + -1;
    (pPVar12->BoundingBox).X1 = *pLVar10;
    pLVar10 = pLVar10 + 1;
    pPVar12 = (PadType *)&(pPVar12->BoundingBox).Y1;
  }
  iVar8 = (iVar2 + 1) / 2;
  dVar4 = (double)(pad.Point2.X - pad.Point1.X);
  dVar3 = (double)(pad.Point2.Y - pad.Point1.Y);
  dVar5 = SQRT(dVar3 * dVar3 + dVar4 * dVar4);
  if (0.10000000 <= dVar5) {
    dVar3 = dVar3 / dVar5;
    dVar4 = dVar4 / dVar5;
  }
  else {
    dVar4 = 1.00000000;
    dVar3 = 0.00000000;
  }
  iVar9 = (int)ROUND((double)(Y - pad.Point1.Y) * dVar3 + (double)(X - pad.Point1.X) * dVar4);
  uVar1 = (uint)ROUND((double)(Y - pad.Point1.Y) * dVar4 - (double)(X - pad.Point1.X) * dVar3);
  uVar7 = (int)uVar1 >> 0x1f;
  if ((*(byte *)(Pad.BoundingBox.X1 + 0x15) & 1) == 0) {
    local_90 = (uVar1 ^ uVar7) - uVar7;
    if (iVar9 < 1) {
      bVar6 = false;
      Radius = iVar8 + Radius;
      if (Radius < 0) goto LAB_080cba48;
LAB_080cbb2b:
      bVar6 = (float10)local_90 * (float10)local_90 + (float10)iVar9 * (float10)iVar9 <
              (float10)Radius * (float10)Radius;
      goto LAB_080cba48;
    }
    if (dVar5 <= (double)iVar9) {
      bVar6 = false;
      if (-1 < iVar8 + Radius) {
        dVar3 = (double)(iVar8 + Radius);
        dVar5 = (double)iVar9 - dVar5;
        bVar6 = (double)local_90 * (double)local_90 + dVar5 * dVar5 < dVar3 * dVar3;
      }
      goto LAB_080cba48;
    }
LAB_080cba2c:
    local_90 = local_90 - iVar8;
  }
  else {
    iVar11 = iVar9 + iVar8;
    local_90 = (uVar1 ^ uVar7) - uVar7;
    if (iVar11 < 1) {
      if (iVar8 < local_90) {
        bVar6 = false;
        if (Radius < 0) goto LAB_080cba48;
        iVar9 = iVar8 - local_90;
        local_90 = iVar11;
        goto LAB_080cbb2b;
      }
      local_90 = -iVar11;
    }
    else {
      dVar5 = (double)iVar2 + dVar5;
      dVar3 = (double)iVar11;
      if (dVar3 < dVar5) goto LAB_080cba2c;
      if (iVar8 < local_90) {
        bVar6 = false;
        if (-1 < Radius) {
          bVar6 = (dVar3 - dVar5) * (dVar3 - dVar5) +
                  (double)(iVar8 - local_90) * (double)(iVar8 - local_90) <
                  (double)Radius * (double)Radius;
        }
        goto LAB_080cba48;
      }
      local_90 = (int)ROUND(dVar3 - dVar5);
    }
  }
  bVar6 = local_90 < Radius;
LAB_080cba48:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (Boolean)bVar6;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Restarted to delay deadcode elimination for space: stack

int line_callback(BoxType *box,void *cl)

{
  Boolean BVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined2 in_FPUControlWord;
  undefined4 unaff_retaddr;
  undefined in_stack_0000000c [60];
  undefined in_stack_ffffffe4 [12];
  
  if ((box[1].Y1 & *(uint *)((int)cl + 0xa8)) == 0) {
    BVar1 = IsPointInPad((int)ROUND(PosX),(int)ROUND(PosY),SearchRadius,
                         (PadTypePtr)
                         CONCAT7232(CONCAT6012(in_stack_0000000c,
                                               CONCAT48(cl,CONCAT44(box,unaff_retaddr))),
                                    CONCAT428(unaff_EBP,
                                              CONCAT424(unaff_ESI,
                                                        CONCAT420(unaff_EBX,
                                                                  CONCAT218(in_FPUControlWord,
                                                                            CONCAT216(CONCAT11(0xc,(
                                                  char)in_FPUControlWord),
                                                  CONCAT124(in_stack_ffffffe4,box))))))));
    if (BVar1 != '\0') {
      **(BoxType ***)cl = box;
      *(BoxType **)&(*(BoxType **)((int)cl + 4))->X1 = box;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0xc,1);
    }
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Restarted to delay deadcode elimination for space: stack

int pad_callback(BoxType *b,void *cl)

{
  BoxType *pBVar1;
  Boolean BVar2;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined2 in_FPUControlWord;
  undefined4 unaff_retaddr;
  undefined in_stack_0000000c [60];
  undefined in_stack_ffffffe4 [12];
  
  if (((*(uint *)((int)cl + 0xb0) & b[1].Y1) == 0) &&
     ((((uint)b[1].Y1 >> 7 & 1) == (int)Settings.ShowSolderSide ||
      (*(char *)((int)cl + 0xc) != '\0')))) {
    BVar2 = IsPointInPad((int)ROUND(PosX),(int)ROUND(PosY),SearchRadius,
                         (PadTypePtr)
                         CONCAT7232(CONCAT6012(in_stack_0000000c,
                                               CONCAT48(cl,CONCAT44(b,unaff_retaddr))),
                                    CONCAT428(unaff_EBP,
                                              CONCAT424(unaff_ESI,
                                                        CONCAT420(unaff_EBX,
                                                                  CONCAT218(in_FPUControlWord,
                                                                            CONCAT216(CONCAT11(0xc,(
                                                  char)in_FPUControlWord),
                                                  CONCAT124(in_stack_ffffffe4,b))))))));
    if (BVar2 != '\0') {
      **(LocationType **)cl = b[6].X1;
      pBVar1 = *(BoxType **)((int)cl + 4);
      *(BoxType **)&(*(BoxType **)((int)cl + 8))->X1 = b;
      *(BoxType **)&pBVar1->X1 = b;
                    // WARNING: Subroutine does not return
      __longjmp_chk((int)cl + 0x14,1);
    }
  }
  return 0;
}



Boolean IsArcInRectangle(LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
                        ArcTypePtr *Arc)

{
  int iVar1;
  Boolean BVar2;
  int in_GS_OFFSET;
  bool bVar3;
  ulong local_8c;
  undefined4 local_88;
  undefined4 local_84;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  line.Thickness = 0;
  MakeFlags((FlagType *)&local_8c,0);
  line.Point2.Y = Y1;
  line.Point1.Y = Y1;
  line.Flags.f = local_8c;
  line.Point2.X = X2;
  line.Flags.t._0_4_ = local_88;
  line.Flags.t._4_4_ = local_84;
  line.Point1.X = X1;
  BVar2 = LineArcIntersect((LineTypePtr)&line,Arc);
  if (BVar2 == '\0') {
    line.Point2.X = X2;
    line.Point1.X = X2;
    line.Point1.Y = Y1;
    line.Point2.Y = Y2;
    BVar2 = LineArcIntersect((LineTypePtr)&line,Arc);
    if (BVar2 == '\0') {
      line.Point2.X = X2;
      line.Point2.Y = Y2;
      line.Point1.Y = Y2;
      line.Point1.X = X1;
      BVar2 = LineArcIntersect((LineTypePtr)&line,Arc);
      if (BVar2 == '\0') {
        line.Point1.Y = Y1;
        line.Point2.X = X1;
        line.Point1.X = X1;
        line.Point2.Y = Y2;
        BVar2 = LineArcIntersect((LineTypePtr)&line,Arc);
        bVar3 = BVar2 != '\0';
        goto LAB_080cbd9c;
      }
    }
  }
  bVar3 = true;
LAB_080cbd9c:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return (Boolean)bVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean IsLineInQuadrangle(PointType *p,LineTypePtr Line)

{
  int iVar1;
  Boolean BVar2;
  int iVar3;
  int in_GS_OFFSET;
  bool bVar4;
  ulong local_8c;
  undefined4 local_88;
  undefined4 local_84;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = IsPointInQuadrangle(p,(PointTypePtr)&Line->Point1);
  if (iVar3 == 0) {
    iVar3 = IsPointInQuadrangle(p,(PointTypePtr)&Line->Point2);
    if (iVar3 == 0) {
      line.Thickness = 0;
      MakeFlags((FlagType *)&local_8c,0);
      line.Flags.f = local_8c;
      line.Flags.t._0_4_ = local_88;
      line.Flags.t._4_4_ = local_84;
      line.Point1.X = p->X;
      line.Point1.Y = p->Y;
      line.Point2.X = p[1].X;
      line.Point2.Y = p[1].Y;
      BVar2 = LineLineIntersect((LineTypePtr)&line,Line);
      if (BVar2 == '\0') {
        line.Point1.X = p[2].X;
        line.Point1.Y = p[2].Y;
        BVar2 = LineLineIntersect((LineTypePtr)&line,Line);
        if (BVar2 == '\0') {
          line.Point2.X = p[3].X;
          line.Point2.Y = p[3].Y;
          BVar2 = LineLineIntersect((LineTypePtr)&line,Line);
          if (BVar2 == '\0') {
            line.Point1.X = p->X;
            line.Point1.Y = p->Y;
            BVar2 = LineLineIntersect((LineTypePtr)&line,Line);
            bVar4 = BVar2 != '\0';
            goto LAB_080cbe76;
          }
        }
      }
    }
  }
  bVar4 = true;
LAB_080cbe76:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return (Boolean)bVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean IsLineInRectangle(LocationType X1,LocationType Y1,LocationType X2,LocationType Y2,
                         LineTypePtr Line)

{
  int iVar1;
  int iVar2;
  Boolean BVar3;
  int in_GS_OFFSET;
  bool bVar4;
  ulong local_8c;
  undefined4 local_88;
  undefined4 local_84;
  LineType line;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar2 = (Line->Point1).X;
  if ((((iVar2 <= X1) || (X2 <= iVar2)) || (iVar2 = (Line->Point1).Y, iVar2 <= Y1)) || (Y2 <= iVar2)
     ) {
    line.Thickness = 0;
    MakeFlags((FlagType *)&local_8c,0);
    line.Point2.Y = Y1;
    line.Point1.Y = Y1;
    line.Flags.f = local_8c;
    line.Point1.X = X1;
    line.Point2.X = X2;
    line.Flags.t._0_4_ = local_88;
    line.Flags.t._4_4_ = local_84;
    BVar3 = LineLineIntersect((LineTypePtr)&line,Line);
    if (BVar3 == '\0') {
      line.Point1.X = X2;
      line.Point1.Y = Y1;
      line.Point2.Y = Y2;
      BVar3 = LineLineIntersect((LineTypePtr)&line,Line);
      if (BVar3 == '\0') {
        line.Point2.X = X2;
        line.Point1.Y = Y2;
        line.Point1.X = X1;
        BVar3 = LineLineIntersect((LineTypePtr)&line,Line);
        if (BVar3 == '\0') {
          line.Point1.Y = Y1;
          line.Point2.X = X1;
          line.Point2.Y = Y2;
          BVar3 = LineLineIntersect((LineTypePtr)&line,Line);
          bVar4 = BVar3 != '\0';
          goto LAB_080cc00b;
        }
      }
    }
  }
  bVar4 = true;
LAB_080cc00b:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (Boolean)bVar4;
}



// WARNING: Exceeded maximum restarts with more pending

void * ObjectOperation(ObjectFunctionTypePtr *F,int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  anon_subr_void_ptr_ElementTypePtr_ptr_for_Element *UNRECOVERED_JUMPTABLE;
  anon_subr_void_ptr_LayerTypePtr_LineTypePtr_PointTypePtr_for_LinePoint *UNRECOVERED_JUMPTABLE_01;
  anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *UNRECOVERED_JUMPTABLE_00;
  void *pvVar1;
  
  if (Type == 0x20) {
    UNRECOVERED_JUMPTABLE = (anon_subr_void_ptr_ElementTypePtr_ptr_for_Element *)F->Rat;
joined_r0x080cc205:
    if (UNRECOVERED_JUMPTABLE != (anon_subr_void_ptr_ElementTypePtr_ptr_for_Element *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080cc1d6. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar1 = (*UNRECOVERED_JUMPTABLE)();
      return pvVar1;
    }
  }
  else {
    if (Type < 0x21) {
      if (Type == 4) {
        UNRECOVERED_JUMPTABLE_00 =
             (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)F->Line;
      }
      else {
        if (Type < 5) {
          if (Type == 1) {
            UNRECOVERED_JUMPTABLE = (anon_subr_void_ptr_ElementTypePtr_ptr_for_Element *)F->Via;
          }
          else {
            if (Type != 2) {
              return (void *)0x0;
            }
            UNRECOVERED_JUMPTABLE = F->Element;
          }
          goto joined_r0x080cc205;
        }
        if (Type == 8) {
          UNRECOVERED_JUMPTABLE_00 =
               (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)F->Polygon;
        }
        else {
          if (Type != 0x10) {
            return (void *)0x0;
          }
          UNRECOVERED_JUMPTABLE_00 =
               (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)F->Text;
        }
      }
    }
    else {
      if (Type == 0x400) {
        UNRECOVERED_JUMPTABLE = (anon_subr_void_ptr_ElementTypePtr_ptr_for_Element *)F->ElementName;
        goto joined_r0x080cc205;
      }
      if (Type < 0x401) {
        if (Type == 0x100) {
          UNRECOVERED_JUMPTABLE_00 =
               (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)F->Pin;
        }
        else {
          if (Type != 0x200) {
            return (void *)0x0;
          }
          UNRECOVERED_JUMPTABLE_00 = F->Pad;
        }
      }
      else {
        if (Type == 0x1000) {
          UNRECOVERED_JUMPTABLE_01 = F->LinePoint;
joined_r0x080cc230:
          if (UNRECOVERED_JUMPTABLE_01 ==
              (anon_subr_void_ptr_LayerTypePtr_LineTypePtr_PointTypePtr_for_LinePoint *)0x0) {
            return (void *)0x0;
          }
                    // WARNING: Could not recover jumptable at 0x080cc145. Too many branches
                    // WARNING: Treating indirect jump as call
          pvVar1 = (*UNRECOVERED_JUMPTABLE_01)();
          return pvVar1;
        }
        if (Type != 0x4000) {
          if (Type != 0x800) {
            return (void *)0x0;
          }
          UNRECOVERED_JUMPTABLE_01 =
               (anon_subr_void_ptr_LayerTypePtr_LineTypePtr_PointTypePtr_for_LinePoint *)F->Point;
          goto joined_r0x080cc230;
        }
        UNRECOVERED_JUMPTABLE_00 =
             (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)F->Arc;
      }
    }
    if (UNRECOVERED_JUMPTABLE_00 !=
        (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080cc188. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar1 = (*UNRECOVERED_JUMPTABLE_00)();
      return pvVar1;
    }
  }
  return (void *)0x0;
}



Boolean SelectedOperation(ObjectFunctionTypePtr *F,Boolean Reset,int type)

{
  RatTypePtr *Ptr1;
  char cVar1;
  TextType *pTVar2;
  uint uVar3;
  DataTypePtr *pDVar4;
  LineTypePtr Ptr2;
  ArcTypePtr_conflict Ptr2_00;
  TextTypePtr Ptr2_01;
  PolygonTypePtr Ptr2_02;
  uint uVar5;
  PadTypePtr *Ptr2_03;
  PCBTypePtr pPVar6;
  int iVar7;
  uint uVar8;
  undefined *puVar9;
  LayerTypePtr Ptr1_00;
  ElementTypePtr *Ptr1_01;
  int iVar10;
  PinTypePtr *Ptr2_04;
  TextType *local_28;
  uint local_24;
  
  if ((((type & 4U) == 0) ||
      (F->Line == (anon_subr_void_ptr_LayerTypePtr_LineTypePtr_for_Line *)0x0)) ||
     (Ptr1_00 = (LayerTypePtr)&PCB->Data->field_0x4c, PCB->Data->LayerN == -2)) {
    cVar1 = '\0';
  }
  else {
    local_24 = 0;
    cVar1 = '\0';
    pPVar6 = PCB;
    while( true ) {
      if (Ptr1_00->On != '\0') {
        iVar7 = Ptr1_00->LineN - 1;
        if (iVar7 != -1) {
          iVar10 = Ptr1_00->LineN * 0x58;
          do {
            Ptr2 = (LineTypePtr)((int)&Ptr1_00->Line[-1].BoundingBox.X1 + iVar10);
            if ((*(byte *)&(Ptr2->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(4,Ptr1_00,Ptr2,Ptr2);
                (Ptr2->Flags).f = (Ptr2->Flags).f & 0xffffffbf;
              }
              (*F->Line)(Ptr1_00,Ptr2);
              cVar1 = '\x01';
            }
            iVar7 = iVar7 + -1;
            pPVar6 = PCB;
            iVar10 = iVar10 + -0x58;
          } while (iVar7 != -1);
        }
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      Ptr1_00 = Ptr1_00 + 1;
    }
  }
  if ((((type & 0x4000U) != 0) &&
      (F->Arc != (anon_subr_void_ptr_LayerTypePtr_ArcTypePtr_for_Arc *)0x0)) &&
     (Ptr1_00 = (LayerTypePtr)&PCB->Data->field_0x4c, PCB->Data->LayerN != -2)) {
    local_24 = 0;
    pPVar6 = PCB;
    while( true ) {
      if (Ptr1_00->On != '\0') {
        iVar7 = Ptr1_00->ArcN - 1;
        if (iVar7 != -1) {
          iVar10 = Ptr1_00->ArcN * 0x44;
          do {
            Ptr2_00 = (ArcTypePtr_conflict)((int)&Ptr1_00->Arc[-1].BoundingBox.X1 + iVar10);
            if ((*(byte *)&(Ptr2_00->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(0x4000,Ptr1_00,Ptr2_00,Ptr2_00);
                (Ptr2_00->Flags).f = (Ptr2_00->Flags).f & 0xffffffbf;
              }
              (*F->Arc)(Ptr1_00,Ptr2_00);
              cVar1 = '\x01';
            }
            iVar7 = iVar7 + -1;
            pPVar6 = PCB;
            iVar10 = iVar10 + -0x44;
          } while (iVar7 != -1);
        }
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      Ptr1_00 = Ptr1_00 + 1;
    }
  }
  if ((((type & 0x10U) != 0) &&
      (F->Text != (anon_subr_void_ptr_LayerTypePtr_TextTypePtr_for_Text *)0x0)) &&
     (Ptr1_00 = (LayerTypePtr)&PCB->Data->field_0x4c, PCB->Data->LayerN != -2)) {
    local_24 = 0;
    pPVar6 = PCB;
    while( true ) {
      iVar7 = Ptr1_00->TextN - 1;
      if (iVar7 != -1) {
        puVar9 = (undefined *)(Ptr1_00->TextN * 0x3c);
        do {
          puVar9 = &DAT_ffffffc4 + (int)puVar9;
          Ptr2_01 = (TextTypePtr)(puVar9 + (int)&Ptr1_00->Text->BoundingBox);
          if (((*(byte *)&(Ptr2_01->Flags).f & 0x40) != 0) && (Ptr1_00->On != '\0')) {
            if (Reset != '\0') {
              AddObjectToFlagUndoList(0x10,Ptr1_00,Ptr2_01,Ptr2_01);
              (Ptr2_01->Flags).f = (Ptr2_01->Flags).f & 0xffffffbf;
            }
            (*F->Text)(Ptr1_00,Ptr2_01);
            cVar1 = '\x01';
          }
          iVar7 = iVar7 + -1;
          pPVar6 = PCB;
        } while (iVar7 != -1);
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      Ptr1_00 = Ptr1_00 + 1;
    }
  }
  if ((((type & 8U) != 0) &&
      (F->Polygon != (anon_subr_void_ptr_LayerTypePtr_PolygonTypePtr_for_Polygon *)0x0)) &&
     (Ptr1_00 = (LayerTypePtr)&PCB->Data->field_0x4c, PCB->Data->LayerN != -2)) {
    local_24 = 0;
    pPVar6 = PCB;
    while( true ) {
      if (Ptr1_00->On != '\0') {
        iVar7 = Ptr1_00->PolygonN - 1;
        if (iVar7 != -1) {
          puVar9 = (undefined *)(Ptr1_00->PolygonN * 0x3c);
          do {
            puVar9 = &DAT_ffffffc4 + (int)puVar9;
            Ptr2_02 = (PolygonTypePtr)(puVar9 + (int)&Ptr1_00->Polygon->BoundingBox);
            if ((*(byte *)&(Ptr2_02->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(8,Ptr1_00,Ptr2_02,Ptr2_02);
                (Ptr2_02->Flags).f = (Ptr2_02->Flags).f & 0xffffffbf;
              }
              (*F->Polygon)(Ptr1_00,Ptr2_02);
              cVar1 = '\x01';
            }
            iVar7 = iVar7 + -1;
            pPVar6 = PCB;
          } while (iVar7 != -1);
        }
      }
      local_24 = local_24 + 1;
      if (pPVar6->Data->LayerN + 2U <= local_24) break;
      Ptr1_00 = Ptr1_00 + 1;
    }
  }
  if ((((type & 2U) != 0) && (PCB->ElementOn != '\0')) &&
     (F->Element != (anon_subr_void_ptr_ElementTypePtr_ptr_for_Element *)0x0)) {
    pDVar4 = PCB->Data;
    iVar7 = pDVar4->ElementN - 1;
    if (iVar7 != -1) {
      iVar10 = pDVar4->ElementN * 300;
      while( true ) {
        Ptr1_01 = (ElementTypePtr *)((int)&pDVar4->Element[-1].BoundingBox.X1 + iVar10);
        if ((*(byte *)&(Ptr1_01->Flags).f & 0x40) != 0) {
          if (Reset != '\0') {
            AddObjectToFlagUndoList(2,Ptr1_01,Ptr1_01,Ptr1_01);
            (Ptr1_01->Flags).f = (Ptr1_01->Flags).f & 0xffffffbf;
          }
          (*F->Element)(Ptr1_01);
          cVar1 = '\x01';
        }
        iVar7 = iVar7 + -1;
        if (iVar7 == -1) break;
        pDVar4 = PCB->Data;
        iVar10 = iVar10 + -300;
      }
    }
  }
  if ((((type & 0x400U) != 0) && (PCB->ElementOn != '\0')) &&
     (F->ElementName != (anon_subr_void_ptr_ElementTypePtr_ptr_for_ElementName *)0x0)) {
    pDVar4 = PCB->Data;
    iVar7 = pDVar4->ElementN - 1;
    if (iVar7 != -1) {
      iVar10 = pDVar4->ElementN * 300;
      while( true ) {
        uVar3 = (PCB->Flags).f;
        Ptr1_01 = (ElementTypePtr *)((int)&pDVar4->Element[-1].BoundingBox.X1 + iVar10);
        pTVar2 = Ptr1_01->Name;
        if ((uVar3 & 0x40) == 0) {
          uVar5 = -(uint)((uVar3 & 0x20) == 0) & 0x78;
        }
        else {
          uVar5 = 0x3c;
        }
        if ((*(byte *)((int)&(pTVar2->Flags).f + uVar5) & 0x40) != 0) {
          if (Reset != '\0') {
            if ((uVar3 & 0x40) == 0) {
              local_28 = pTVar2;
              if ((uVar3 & 0x20) == 0) {
                local_28 = Ptr1_01->Name + 2;
              }
            }
            else {
              local_28 = Ptr1_01->Name + 1;
            }
            AddObjectToFlagUndoList(0x400,Ptr1_01,local_28,local_28);
            uVar3 = (PCB->Flags).f;
            if ((uVar3 & 0x40) == 0) {
              if ((uVar3 & 0x20) == 0) {
                pTVar2 = Ptr1_01->Name + 2;
              }
            }
            else {
              pTVar2 = Ptr1_01->Name + 1;
            }
            (pTVar2->Flags).f = (pTVar2->Flags).f & 0xffffffbf;
          }
          (*F->ElementName)(Ptr1_01);
          cVar1 = '\x01';
        }
        iVar7 = iVar7 + -1;
        if (iVar7 == -1) break;
        pDVar4 = PCB->Data;
        iVar10 = iVar10 + -300;
      }
    }
  }
  if ((((type & 0x100U) != 0) && (PCB->PinOn != '\0')) &&
     (F->Pin != (anon_subr_void_ptr_ElementTypePtr_ptr_PinTypePtr_ptr_for_Pin *)0x0)) {
    pDVar4 = PCB->Data;
    local_24 = pDVar4->ElementN - 1;
    if (local_24 != -1) {
      iVar7 = pDVar4->ElementN * 300;
      while( true ) {
        local_28 = (TextType *)(iVar7 + -300);
        Ptr1_01 = (ElementTypePtr *)((int)&pDVar4->Element[-1].BoundingBox.X1 + iVar7);
        if (Ptr1_01->PinN != 0) {
          uVar5 = 0;
          uVar3 = Ptr1_01->PinN;
          do {
            Ptr2_04 = Ptr1_01->Pin + uVar5;
            uVar8 = uVar3;
            if ((*(byte *)&(Ptr2_04->Flags).f & 0x40) != 0) {
              if (Reset != '\0') {
                AddObjectToFlagUndoList(0x100,Ptr1_01,Ptr2_04,Ptr2_04);
                (Ptr2_04->Flags).f = (Ptr2_04->Flags).f & 0xffffffbf;
              }
              (*F->Pin)(Ptr1_01,Ptr2_04);
              uVar8 = Ptr1_01->PinN;
              cVar1 = '\x01';
            }
          } while ((uVar8 != 0) &&
                  (uVar5 = (uVar5 + 1 + uVar8) - uVar3, uVar3 = uVar8, uVar5 < uVar8));
        }
        local_24 = local_24 + -1;
        if (local_24 == -1) break;
        pDVar4 = PCB->Data;
        iVar7 = (int)local_28;
      }
    }
  }
  if ((((type & 0x200U) != 0) && (PCB->PinOn != '\0')) &&
     (F->Pad != (anon_subr_void_ptr_ElementTypePtr_ptr_PadTypePtr_ptr_for_Pad *)0x0)) {
    pDVar4 = PCB->Data;
    local_24 = pDVar4->ElementN - 1;
    if (local_24 != -1) {
      iVar7 = pDVar4->ElementN * 300;
      while( true ) {
        local_28 = (TextType *)(iVar7 + -300);
        uVar8 = 0;
        Ptr1_01 = (ElementTypePtr *)((int)&pDVar4->Element[-1].BoundingBox.X1 + iVar7);
        uVar3 = Ptr1_01->PadN;
        uVar5 = uVar3;
        while ((uVar5 != 0 && (uVar8 < uVar5))) {
          Ptr2_03 = Ptr1_01->Pad + uVar8;
          if ((*(byte *)&(Ptr2_03->Flags).f & 0x40) != 0) {
            if (Reset != '\0') {
              AddObjectToFlagUndoList(0x200,Ptr1_01,Ptr2_03,Ptr2_03);
              (Ptr2_03->Flags).f = (Ptr2_03->Flags).f & 0xffffffbf;
            }
            (*F->Pad)(Ptr1_01,Ptr2_03);
            uVar5 = Ptr1_01->PadN;
            cVar1 = '\x01';
          }
          uVar8 = uVar8 + (uVar3 == uVar5);
        }
        local_24 = local_24 + -1;
        if (local_24 == -1) break;
        pDVar4 = PCB->Data;
        iVar7 = (int)local_28;
      }
    }
  }
  if ((((type & 1U) != 0) && (PCB->ViaOn != '\0')) &&
     (F->Via != (anon_subr_void_ptr_PinTypePtr_ptr_for_Via *)0x0)) {
    pDVar4 = PCB->Data;
    if (pDVar4->ViaN != 0) {
      uVar5 = 0;
      pPVar6 = PCB;
      uVar3 = pDVar4->ViaN;
      do {
        Ptr2_04 = pDVar4->Via + uVar5;
        if ((*(byte *)&(Ptr2_04->Flags).f & 0x40) != 0) {
          if (Reset != '\0') {
            AddObjectToFlagUndoList(1,Ptr2_04,Ptr2_04,Ptr2_04);
            (Ptr2_04->Flags).f = (Ptr2_04->Flags).f & 0xffffffbf;
          }
          (*F->Via)(Ptr2_04);
          cVar1 = '\x01';
          pPVar6 = PCB;
        }
        pDVar4 = pPVar6->Data;
        uVar8 = pDVar4->ViaN;
      } while ((uVar8 != 0) && (uVar5 = (uVar8 + 1 + uVar5) - uVar3, uVar3 = uVar8, uVar5 < uVar8));
    }
  }
  if (((type & 0x20U) != 0) &&
     ((PCB->RatOn != '\0' && (F->Rat != (anon_subr_void_ptr_RatTypePtr_ptr_for_Rat *)0x0)))) {
    pDVar4 = PCB->Data;
    iVar7 = pDVar4->RatN - 1;
    if (iVar7 != -1) {
      iVar10 = pDVar4->RatN * 0x5c;
      while( true ) {
        Ptr1 = (RatTypePtr *)((int)&pDVar4->Rat[-1].BoundingBox.X1 + iVar10);
        if ((*(byte *)&(Ptr1->Flags).f & 0x40) != 0) {
          if (Reset != '\0') {
            AddObjectToFlagUndoList(0x20,Ptr1,Ptr1,Ptr1);
            (Ptr1->Flags).f = (Ptr1->Flags).f & 0xffffffbf;
          }
          (*F->Rat)(Ptr1);
          cVar1 = '\x01';
        }
        iVar7 = iVar7 + -1;
        if (iVar7 == -1) break;
        pDVar4 = PCB->Data;
        iVar10 = iVar10 + -0x5c;
      }
    }
  }
  if ((cVar1 != '\0') && (Reset != '\0')) {
    IncrementUndoSerialNumber();
    return (Boolean)cVar1;
  }
  return (Boolean)cVar1;
}



int __regparm3 regexec_match_all(regex_t *preg,char *string)

{
  int iVar1;
  size_t sVar2;
  regmatch_t match;
  
  iVar1 = regexec((regex_t *)preg,string,1,(regmatch_t *)&match,0);
  if ((iVar1 == 0) && (match.rm_so == 0)) {
    sVar2 = strlen(string);
    return (uint)(match.rm_eo == sVar2);
  }
  return 0;
}



Boolean SelectObjectByName(int Type,char *Pattern,Boolean Flag)

{
  PadTypePtr *Pad;
  int iVar1;
  char *string;
  Cardinal CVar2;
  uint uVar3;
  int __errcode;
  int iVar4;
  PCBTypePtr pPVar5;
  LayerTypePtr Layer;
  uint uVar6;
  DataTypePtr *pDVar7;
  undefined *puVar8;
  ElementTypePtr *Element;
  uint uVar9;
  PinTypePtr *Pin;
  TextTypePtr Text;
  void *Ptr2;
  uint uVar10;
  ElementTypePtr *pEVar11;
  int in_GS_OFFSET;
  int local_e8;
  int local_e4;
  char local_e0;
  uint local_d4;
  uint local_d0;
  regex_t compiled;
  char errorstring [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __errcode = regcomp((regex_t *)&compiled,Pattern,3);
  if (__errcode != 0) {
    regerror(__errcode,(regex_t *)&compiled,errorstring,0x80);
    Message("regexp error: %s\n",errorstring);
    regfree((regex_t *)&compiled);
    local_e0 = '\0';
    goto LAB_080cd1e9;
  }
  pPVar5 = PCB;
  if ((Type & 0x10U) == 0) {
    local_e0 = '\0';
  }
  else {
    local_e0 = '\0';
    Layer = (LayerTypePtr)&PCB->Data->field_0x4c;
    if (PCB->Data->LayerN != -2) {
      local_d0 = 0;
      while( true ) {
        __errcode = Layer->TextN - 1;
        if (__errcode != -1) {
          puVar8 = (undefined *)(Layer->TextN * 0x3c);
          do {
            puVar8 = &DAT_ffffffc4 + (int)puVar8;
            Text = (TextTypePtr)(puVar8 + (int)&(Layer->Text->BoundingBox).X1);
            if (((((*(byte *)((int)&(Text->Flags).f + 1) & 0x20) == 0) && (Layer->On != '\0')) &&
                (Text->TextString != (char *)0x0)) &&
               ((iVar4 = regexec_match_all(&compiled,Text->TextString), iVar4 != 0 &&
                (((Text->Flags).f >> 6 & 1) != (int)Flag)))) {
              AddObjectToFlagUndoList(0x10,Layer,Text,Text);
              (Text->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Text->Flags).f & 0xffffffbf;
              DrawText(Layer,Text,0);
              local_e0 = '\x01';
            }
            __errcode = __errcode + -1;
            pPVar5 = PCB;
          } while (__errcode != -1);
        }
        local_d0 = local_d0 + 1;
        if (pPVar5->Data->LayerN + 2U <= local_d0) break;
        Layer = Layer + 1;
      }
    }
  }
  if ((pPVar5->ElementOn != '\0') && ((Type & 2U) != 0)) {
    pDVar7 = pPVar5->Data;
    local_d0 = pDVar7->ElementN - 1;
    if (local_d0 != -1) {
      __errcode = pDVar7->ElementN * 300;
      do {
        Element = (ElementTypePtr *)((int)&pDVar7->Element[-1].BoundingBox.X1 + __errcode);
        uVar10 = (Element->Flags).f;
        if (((uVar10 & 0x2000) == 0) &&
           ((((uVar10 >> 7 & 1) == (int)Settings.ShowSolderSide ||
             (pPVar5->InvisibleObjectsOn != '\0')) && ((uVar10 >> 6 & 1) != (int)Flag)))) {
          uVar10 = (pPVar5->Flags).f;
          uVar6 = 1;
          if ((uVar10 & 0x40) == 0) {
            uVar6 = -(uint)((uVar10 & 0x20) == 0) & 2;
          }
          string = Element->Name[uVar6].TextString;
          if ((string != (char *)0x0) &&
             (iVar4 = regexec_match_all(&compiled,string), pPVar5 = PCB, iVar4 != 0)) {
            AddObjectToFlagUndoList(2,Element,Element,Element);
            (Element->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Element->Flags).f & 0xffffffbf;
            if (Element->PinN != 0) {
              uVar10 = 0;
              local_d4 = Element->PinN;
              do {
                Pin = Element->Pin + uVar10;
                AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
                (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
                uVar6 = Element->PinN;
                if (uVar6 == 0) break;
                uVar10 = (uVar6 + 1 + uVar10) - local_d4;
                local_d4 = uVar6;
              } while (uVar10 < uVar6);
            }
            uVar10 = Element->PadN;
            uVar9 = 0;
            local_d4 = 0;
            uVar6 = uVar10;
            while ((uVar6 != 0 && (uVar9 < uVar6))) {
              Ptr2 = (void *)((int)&(Element->Pad->BoundingBox).X1 + local_d4);
              AddObjectToFlagUndoList(0x200,Element,Ptr2,Ptr2);
              *(uint *)((int)Ptr2 + 0x14) =
                   ~-(uint)(Flag == '\0') & 0x40 | *(uint *)((int)Ptr2 + 0x14) & 0xffffffbf;
              uVar6 = Element->PadN;
              if (Element->PadN == uVar10) {
                uVar9 = uVar9 + 1;
                local_d4 = local_d4 + 0x68;
                uVar6 = uVar10;
              }
            }
            iVar4 = 2;
            pEVar11 = Element;
            do {
              AddObjectToFlagUndoList(0x400,Element,Element->Name + iVar4,Element->Name + iVar4);
              iVar4 = iVar4 + -1;
              pEVar11->Name[2].Flags.f =
                   ~-(uint)(Flag == '\0') & 0x40 | pEVar11->Name[2].Flags.f & 0xffffffbf;
              pEVar11 = (ElementTypePtr *)&pEVar11[-1].LineN;
            } while (iVar4 != -1);
            DrawElementName(Element,0);
            DrawElement(Element,0);
            local_e0 = '\x01';
            pPVar5 = PCB;
          }
        }
        local_d0 = local_d0 + -1;
        if (local_d0 == -1) break;
        pDVar7 = pPVar5->Data;
        __errcode = __errcode + -300;
      } while( true );
    }
  }
  if (pPVar5->PinOn != '\0') {
    if ((Type & 0x100U) != 0) {
      pDVar7 = pPVar5->Data;
      local_d0 = pDVar7->ElementN - 1;
      if (local_d0 != -1) {
        __errcode = pDVar7->ElementN * 300;
        while( true ) {
          local_d4 = __errcode + -300;
          Ptr2 = (void *)((int)&pDVar7->Element[-1].BoundingBox.X1 + __errcode);
          if (*(uint *)((int)Ptr2 + 0xe0) != 0) {
            uVar6 = 0;
            uVar10 = *(uint *)((int)Ptr2 + 0xe0);
            do {
              uVar9 = uVar10;
              if ((*(byte *)((int)Ptr2 + 0x15) & 0x20) == 0) {
                Pin = (PinTypePtr *)(*(int *)((int)Ptr2 + 0x100) + uVar6 * 0x4c);
                if (Pin->Name != (char *)0x0) {
                  __errcode = regexec_match_all(&compiled,Pin->Name);
                  if ((__errcode != 0) && (((Pin->Flags).f >> 6 & 1) != (int)Flag)) {
                    AddObjectToFlagUndoList(0x100,Ptr2,Pin,Pin);
                    (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
                    DrawPin(Pin,0);
                    local_e0 = '\x01';
                  }
                  uVar9 = *(uint *)((int)Ptr2 + 0xe0);
                }
              }
              pPVar5 = PCB;
            } while ((uVar9 != 0) &&
                    (uVar6 = (uVar6 + 1 + uVar9) - uVar10, uVar10 = uVar9, uVar6 < uVar9));
          }
          local_d0 = local_d0 + -1;
          if (local_d0 == -1) break;
          pDVar7 = pPVar5->Data;
          __errcode = local_d4;
        }
        if (pPVar5->PinOn == '\0') goto LAB_080cd0ef;
      }
    }
    if ((Type & 0x200U) != 0) {
      CVar2 = pPVar5->Data->ElementN;
      local_e4 = CVar2 - 1;
      if (local_e4 != -1) {
        __errcode = CVar2 * 300;
        do {
          local_e8 = __errcode + -300;
          uVar9 = 0;
          Ptr2 = (void *)((int)&pPVar5->Data->Element[-1].BoundingBox.X1 + __errcode);
          uVar10 = *(uint *)((int)Ptr2 + 0xe8);
          uVar6 = uVar10;
          while ((uVar6 != 0 && (uVar9 < uVar6))) {
            if ((*(byte *)((int)Ptr2 + 0x15) & 0x20) == 0) {
              Pad = (PadTypePtr *)(*(int *)((int)Ptr2 + 0x104) + uVar9 * 0x68);
              uVar3 = (Pad->Flags).f;
              if (((((uVar3 >> 7 & 1) == (int)Settings.ShowSolderSide) ||
                   (PCB->InvisibleObjectsOn != '\0')) && ((uVar3 >> 6 & 1) != (int)Flag)) &&
                 (Pad->Name != (char *)0x0)) {
                __errcode = regexec_match_all(&compiled,Pad->Name);
                if (__errcode == 0) {
                  uVar6 = *(uint *)((int)Ptr2 + 0xe8);
                }
                else {
                  AddObjectToFlagUndoList(0x200,Ptr2,Pad,Pad);
                  (Pad->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pad->Flags).f & 0xffffffbf;
                  DrawPad(Pad,0);
                  uVar6 = *(uint *)((int)Ptr2 + 0xe8);
                  local_e0 = '\x01';
                }
              }
            }
            uVar9 = uVar9 + (uVar10 == uVar6);
          }
          local_e4 = local_e4 + -1;
          pPVar5 = PCB;
          __errcode = local_e8;
        } while (local_e4 != -1);
      }
    }
  }
LAB_080cd0ef:
  if ((pPVar5->ViaOn != '\0') && ((Type & 1U) != 0)) {
    pDVar7 = pPVar5->Data;
    if (pDVar7->ViaN != 0) {
      uVar6 = 0;
      uVar10 = pDVar7->ViaN;
      do {
        Pin = pDVar7->Via + uVar6;
        if ((((*(byte *)((int)&(Pin->Flags).f + 1) & 0x20) == 0) && (Pin->Name != (char *)0x0)) &&
           ((__errcode = regexec_match_all(&compiled,Pin->Name), pPVar5 = PCB, __errcode != 0 &&
            (((Pin->Flags).f >> 6 & 1) != (int)Flag)))) {
          AddObjectToFlagUndoList(1,Pin,Pin,Pin);
          (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
          DrawVia(Pin,0);
          local_e0 = '\x01';
          pPVar5 = PCB;
        }
        pDVar7 = pPVar5->Data;
        uVar9 = pDVar7->ViaN;
      } while ((uVar9 != 0) && (uVar6 = (uVar9 + 1 + uVar6) - uVar10, uVar10 = uVar9, uVar6 < uVar9)
              );
    }
  }
  regfree((regex_t *)&compiled);
  if (local_e0 != '\0') {
    IncrementUndoSerialNumber();
    Draw();
  }
LAB_080cd1e9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (Boolean)local_e0;
}



Boolean SelectConnection(Boolean Flag)

{
  PadTypePtr *Pad;
  LayerTypePtr Layer;
  DataTypePtr *pDVar1;
  uint uVar2;
  PCBTypePtr pPVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  void *Ptr1;
  undefined *puVar8;
  LineTypePtr Line;
  PinTypePtr *Pin;
  ArcTypePtr *Arc;
  PolygonTypePtr Polygon;
  RatTypePtr *Line_00;
  int local_28;
  Boolean local_22;
  uint local_20;
  
  pPVar3 = PCB;
  if (PCB->RatOn == '\0') {
    pDVar1 = PCB->Data;
    local_22 = '\0';
  }
  else {
    pDVar1 = PCB->Data;
    local_22 = '\0';
    iVar4 = pDVar1->RatN - 1;
    if (iVar4 != -1) {
      local_22 = '\0';
      iVar7 = pDVar1->RatN * 0x5c;
      while( true ) {
        Line_00 = (RatTypePtr *)((int)&pDVar1->Rat[-1].BoundingBox.X1 + iVar7);
        if ((*(byte *)&(Line_00->Flags).f & 4) != 0) {
          AddObjectToFlagUndoList(0x20,Line_00,Line_00,Line_00);
          (Line_00->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Line_00->Flags).f & 0xffffffbf;
          DrawRat(Line_00,0);
          local_22 = '\x01';
          pPVar3 = PCB;
        }
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        pDVar1 = pPVar3->Data;
        iVar7 = iVar7 + -0x5c;
      }
      pDVar1 = pPVar3->Data;
    }
  }
  Layer = (LayerTypePtr)&pDVar1->field_0x4c;
  if (pDVar1->LayerN != -2) {
    uVar2 = 0;
    do {
      if (Layer->On != '\0') {
        iVar4 = Layer->LineN - 1;
        if (iVar4 != -1) {
          iVar7 = Layer->LineN * 0x58 + -0x58;
          do {
            while (Line = (LineTypePtr)((int)&(Layer->Line->BoundingBox).X1 + iVar7),
                  ((Line->Flags).f & 0x2004) == 4) {
              AddObjectToFlagUndoList(4,Layer,Line,Line);
              iVar4 = iVar4 + -1;
              iVar7 = iVar7 + -0x58;
              (Line->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Line->Flags).f & 0xffffffbf;
              DrawLine(Layer,Line,0);
              local_22 = '\x01';
              pPVar3 = PCB;
              if (iVar4 == -1) goto LAB_080cd579;
            }
            iVar4 = iVar4 + -1;
            iVar7 = iVar7 + -0x58;
            pPVar3 = PCB;
          } while (iVar4 != -1);
        }
      }
LAB_080cd579:
      pDVar1 = pPVar3->Data;
      uVar2 = uVar2 + 1;
      if (pDVar1->LayerN + 2U <= uVar2) goto LAB_080cd818;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_080cd59b;
LAB_080cd818:
  Layer = (LayerTypePtr)&pDVar1->field_0x4c;
  if (pDVar1->LayerN != -2) {
    local_20 = 0;
    do {
      if (Layer->On != '\0') {
        iVar4 = Layer->ArcN - 1;
        if (iVar4 != -1) {
          iVar7 = Layer->ArcN * 0x44 + -0x44;
          do {
            while (Arc = (ArcTypePtr *)((int)&(Layer->Arc->BoundingBox).X1 + iVar7),
                  ((Arc->Flags).f & 0x2004) == 4) {
              AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
              iVar4 = iVar4 + -1;
              iVar7 = iVar7 + -0x44;
              (Arc->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Arc->Flags).f & 0xffffffbf;
              DrawArc(Layer,Arc,0);
              local_22 = '\x01';
              pPVar3 = PCB;
              if (iVar4 == -1) goto LAB_080cd8d6;
            }
            iVar4 = iVar4 + -1;
            iVar7 = iVar7 + -0x44;
            pPVar3 = PCB;
          } while (iVar4 != -1);
        }
      }
LAB_080cd8d6:
      pDVar1 = pPVar3->Data;
      local_20 = local_20 + 1;
      if (pDVar1->LayerN + 2U <= local_20) goto LAB_080cd8f8;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_080cd59b;
LAB_080cd8f8:
  Layer = (LayerTypePtr)&pDVar1->field_0x4c;
  if (pDVar1->LayerN != -2) {
    local_20 = 0;
    do {
      if (Layer->On != '\0') {
        iVar4 = Layer->PolygonN - 1;
        if (iVar4 != -1) {
          puVar8 = &DAT_ffffffc4 + Layer->PolygonN * 0x3c;
          do {
            while (Polygon = (PolygonTypePtr)(puVar8 + (int)&(Layer->Polygon->BoundingBox).X1),
                  ((Polygon->Flags).f & 0x2004) == 4) {
              AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
              iVar4 = iVar4 + -1;
              puVar8 = &DAT_ffffffc4 + (int)puVar8;
              (Polygon->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Polygon->Flags).f & 0xffffffbf;
              DrawPolygon(Layer,Polygon,0);
              local_22 = '\x01';
              pPVar3 = PCB;
              if (iVar4 == -1) goto LAB_080cd9be;
            }
            iVar4 = iVar4 + -1;
            puVar8 = &DAT_ffffffc4 + (int)puVar8;
            pPVar3 = PCB;
          } while (iVar4 != -1);
        }
      }
LAB_080cd9be:
      pDVar1 = pPVar3->Data;
      local_20 = local_20 + 1;
      if (pDVar1->LayerN + 2U <= local_20) break;
      Layer = Layer + 1;
    } while( true );
  }
LAB_080cd59b:
  if ((pPVar3->PinOn != '\0') && (pPVar3->ElementOn != '\0')) {
    local_20 = pDVar1->ElementN - 1;
    if (local_20 != -1) {
      iVar4 = pDVar1->ElementN * 300;
      do {
        local_28 = iVar4 + -300;
        Ptr1 = (void *)((int)&pDVar1->Element[-1].BoundingBox.X1 + iVar4);
        if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
          uVar5 = 0;
          uVar2 = *(uint *)((int)Ptr1 + 0xe0);
          do {
            uVar6 = uVar2;
            pPVar3 = PCB;
            if (((*(byte *)((int)Ptr1 + 0x15) & 0x20) == 0) &&
               (Pin = (PinTypePtr *)(*(int *)((int)Ptr1 + 0x100) + uVar5 * 0x4c),
               (*(byte *)&(Pin->Flags).f & 4) != 0)) {
              AddObjectToFlagUndoList(0x100,Ptr1,Pin,Pin);
              (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
              DrawPin(Pin,0);
              local_22 = '\x01';
              uVar6 = *(uint *)((int)Ptr1 + 0xe0);
              pPVar3 = PCB;
            }
            PCB = pPVar3;
          } while ((uVar6 != 0) &&
                  (uVar5 = (uVar5 + 1 + uVar6) - uVar2, uVar2 = uVar6, uVar5 < uVar6));
          pDVar1 = pPVar3->Data;
        }
        local_20 = local_20 + -1;
        iVar4 = local_28;
      } while (local_20 != -1);
    }
    local_20 = pDVar1->ElementN - 1;
    if (local_20 != -1) {
      iVar4 = pDVar1->ElementN * 300;
      while( true ) {
        local_28 = iVar4 + -300;
        uVar6 = 0;
        Ptr1 = (void *)((int)&pDVar1->Element[-1].BoundingBox.X1 + iVar4);
        uVar2 = *(uint *)((int)Ptr1 + 0xe8);
        uVar5 = uVar2;
        while ((uVar5 != 0 && (uVar6 < uVar5))) {
          if (((*(byte *)((int)Ptr1 + 0x15) & 0x20) == 0) &&
             (Pad = (PadTypePtr *)(*(int *)((int)Ptr1 + 0x104) + uVar6 * 0x68),
             (*(byte *)&(Pad->Flags).f & 4) != 0)) {
            AddObjectToFlagUndoList(0x200,Ptr1,Pad,Pad);
            (Pad->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pad->Flags).f & 0xffffffbf;
            DrawPad(Pad,0);
            uVar5 = *(uint *)((int)Ptr1 + 0xe8);
            local_22 = '\x01';
          }
          uVar6 = uVar6 + (uVar2 == uVar5);
        }
        local_20 = local_20 + -1;
        pPVar3 = PCB;
        if (local_20 == -1) break;
        pDVar1 = PCB->Data;
        iVar4 = local_28;
      }
    }
  }
  if (pPVar3->ViaOn != '\0') {
    pDVar1 = pPVar3->Data;
    if (pDVar1->ViaN != 0) {
      uVar5 = 0;
      uVar2 = pDVar1->ViaN;
      do {
        Pin = pDVar1->Via + uVar5;
        if (((Pin->Flags).f & 0x2004) == 4) {
          AddObjectToFlagUndoList(1,Pin,Pin,Pin);
          (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
          DrawVia(Pin,0);
          local_22 = '\x01';
          pDVar1 = PCB->Data;
          uVar6 = pDVar1->ViaN;
          pPVar3 = PCB;
        }
        else {
          pDVar1 = pPVar3->Data;
          uVar6 = pDVar1->ViaN;
        }
      } while ((uVar6 != 0) && (uVar5 = (uVar6 + 1 + uVar5) - uVar2, uVar2 = uVar6, uVar5 < uVar6));
    }
  }
  Draw();
  return local_22;
}



Boolean SelectBlock(BoxTypePtr Box,Boolean Flag)

{
  LayerTypePtr Layer;
  int iVar1;
  Cardinal *pCVar2;
  ArcTypePtr *Arc;
  TextTypePtr Text;
  PolygonTypePtr Polygon;
  PCBTypePtr pPVar3;
  Cardinal CVar4;
  Cardinal CVar5;
  bool bVar6;
  uint uVar7;
  uint uVar8;
  DataTypePtr *pDVar9;
  LineTypePtr Line;
  ElementTypePtr *Element;
  RatTypePtr *Line_00;
  int iVar10;
  uint uVar11;
  PadTypePtr *Pad;
  ElementTypePtr *pEVar12;
  int iVar13;
  undefined *puVar14;
  PinTypePtr *Pin;
  uint uVar15;
  bool bVar16;
  bool bVar17;
  char local_41;
  uint local_2c;
  PCBTypePtr local_28;
  DataTypePtr *local_24;
  int local_20;
  
  bVar16 = Flag == '\0';
  pPVar3 = PCB;
  if ((bVar16) || (PCB->RatOn != '\0')) {
    local_24 = PCB->Data;
    local_41 = '\0';
    iVar10 = local_24->RatN - 1;
    if (iVar10 != -1) {
      local_28 = PCB;
      iVar13 = local_24->RatN * 0x5c;
      while( true ) {
        Line_00 = (RatTypePtr *)((int)&local_24->Rat[-1].BoundingBox.X1 + iVar13);
        iVar1 = (Line_00->Point1).X;
        if ((Box->X1 <= iVar1) && (iVar1 <= Box->X2)) {
          iVar1 = (Line_00->Point1).Y;
          if ((((Box->Y1 <= iVar1) &&
               ((((iVar1 <= Box->Y2 && (iVar1 = (Line_00->Point2).X, Box->X1 <= iVar1)) &&
                 (iVar1 <= Box->X2)) &&
                ((iVar1 = (Line_00->Point2).Y, Box->Y1 <= iVar1 && (iVar1 <= Box->Y2)))))) &&
              (uVar7 = (Line_00->Flags).f, (uVar7 & 0x2000) == 0)) &&
             ((uVar7 >> 6 & 1) != (int)Flag)) {
            AddObjectToFlagUndoList(0x20,Line_00,Line_00,Line_00);
            (Line_00->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Line_00->Flags).f & 0xffffffbf;
            local_28 = PCB;
            if (PCB->RatOn == '\0') {
              local_24 = PCB->Data;
              local_41 = '\x01';
            }
            else {
              DrawRat(Line_00,0);
              local_28 = PCB;
              local_41 = '\x01';
              local_24 = PCB->Data;
            }
          }
        }
        iVar10 = iVar10 + -1;
        pPVar3 = local_28;
        if (iVar10 == -1) break;
        local_24 = local_28->Data;
        iVar13 = iVar13 + -0x5c;
      }
    }
  }
  else {
    local_24 = PCB->Data;
    local_41 = '\0';
  }
  if (local_24->LayerN != -2) {
    uVar7 = SEXT14(Flag);
    bVar17 = Flag != '\0';
    local_28 = (PCBTypePtr)0x0;
    do {
      if ((!bVar17) || (*(char *)(&local_24->field_0x90 + (int)local_28 * 0x5c) != '\0')) {
        Layer = (LayerTypePtr)(&local_24->field_0x4c + (int)local_28 * 0x5c);
        pCVar2 = &local_24->ViaN + (int)local_28 * 0x17;
        iVar10 = pCVar2[0x14] - 1;
        if (iVar10 != -1) {
          iVar13 = pCVar2[0x14] * 0x58;
          do {
            iVar13 = iVar13 + -0x58;
            Line = (LineTypePtr)(pCVar2[0x1c] + iVar13);
            iVar1 = (Line->Point1).X;
            if ((Box->X1 <= iVar1) && (iVar1 <= Box->X2)) {
              iVar1 = (Line->Point1).Y;
              if (((Box->Y1 <= iVar1) &&
                  (((iVar1 <= Box->Y2 && (iVar1 = (Line->Point2).X, Box->X1 <= iVar1)) &&
                   (iVar1 <= Box->X2)))) &&
                 ((((iVar1 = (Line->Point2).Y, Box->Y1 <= iVar1 && (iVar1 <= Box->Y2)) &&
                   (uVar11 = (Line->Flags).f, (uVar11 & 0x2000) == 0)) &&
                  ((uVar11 >> 6 & 1) != uVar7)))) {
                AddObjectToFlagUndoList(4,Layer,Line,Line);
                local_41 = '\x01';
                (Line->Flags).f =
                     (int)((uint)bVar17 << 0x1f) >> 0x1f & 0x40U | (Line->Flags).f & 0xffffffbf;
                if (*(char *)(pCVar2 + 0x24) != '\0') {
                  DrawLine(Layer,Line,0);
                  local_41 = '\x01';
                }
              }
            }
            iVar10 = iVar10 + -1;
          } while (iVar10 != -1);
        }
        pCVar2 = &local_24->ViaN + (int)local_28 * 0x17;
        iVar10 = pCVar2[0x17] - 1;
        if (iVar10 != -1) {
          iVar13 = pCVar2[0x17] * 0x44;
          do {
            iVar13 = iVar13 + -0x44;
            Arc = (ArcTypePtr *)(pCVar2[0x1f] + iVar13);
            if (((Box->X1 <= (Arc->BoundingBox).X1) && ((Arc->BoundingBox).X2 <= Box->X2)) &&
               ((Box->Y1 <= (Arc->BoundingBox).Y1 &&
                ((((Arc->BoundingBox).Y2 <= Box->Y2 &&
                  (uVar11 = (Arc->Flags).f, (uVar11 & 0x2000) == 0)) && ((uVar11 >> 6 & 1) != uVar7)
                 ))))) {
              AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
              local_41 = '\x01';
              (Arc->Flags).f =
                   (int)((uint)bVar17 << 0x1f) >> 0x1f & 0x40U | (Arc->Flags).f & 0xffffffbf;
              if (*(char *)(pCVar2 + 0x24) != '\0') {
                DrawArc(Layer,Arc,0);
                local_41 = '\x01';
              }
            }
            iVar10 = iVar10 + -1;
          } while (iVar10 != -1);
        }
        pCVar2 = &local_24->ViaN + (int)local_28 * 0x17;
        iVar10 = pCVar2[0x15] - 1;
        if (iVar10 != -1) {
          puVar14 = (undefined *)(pCVar2[0x15] * 0x3c);
          do {
            puVar14 = &DAT_ffffffc4 + (int)puVar14;
            if (((bVar16) || (*(char *)(pCVar2 + 0x24) != '\0')) &&
               ((((Text = (TextTypePtr)(puVar14 + pCVar2[0x1d]), Box->X1 <= (Text->BoundingBox).X1
                  && (((Text->BoundingBox).X2 <= Box->X2 && (Box->Y1 <= (Text->BoundingBox).Y1))))
                 && ((Text->BoundingBox).Y2 <= Box->Y2)) &&
                ((uVar11 = (Text->Flags).f, (uVar11 & 0x2000) == 0 && ((uVar11 >> 6 & 1) != uVar7)))
                ))) {
              AddObjectToFlagUndoList(0x10,Layer,Text,Text);
              local_41 = '\x01';
              (Text->Flags).f =
                   (int)((uint)bVar17 << 0x1f) >> 0x1f & 0x40U | (Text->Flags).f & 0xffffffbf;
              if (*(char *)(pCVar2 + 0x24) != '\0') {
                DrawText(Layer,Text,0);
                local_41 = '\x01';
              }
            }
            iVar10 = iVar10 + -1;
          } while (iVar10 != -1);
        }
        pCVar2 = &local_24->ViaN + (int)local_28 * 0x17;
        iVar10 = pCVar2[0x16] - 1;
        pPVar3 = PCB;
        if (iVar10 != -1) {
          puVar14 = (undefined *)(pCVar2[0x16] * 0x3c);
          do {
            puVar14 = &DAT_ffffffc4 + (int)puVar14;
            Polygon = (PolygonTypePtr)(puVar14 + pCVar2[0x1e]);
            if (((((Box->X1 <= (Polygon->BoundingBox).X1) && ((Polygon->BoundingBox).X2 <= Box->X2))
                 && (Box->Y1 <= (Polygon->BoundingBox).Y1)) &&
                (((Polygon->BoundingBox).Y2 <= Box->Y2 &&
                 (uVar11 = (Polygon->Flags).f, (uVar11 & 0x2000) == 0)))) &&
               ((uVar11 >> 6 & 1) != uVar7)) {
              AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
              local_41 = '\x01';
              (Polygon->Flags).f =
                   (int)((uint)bVar17 << 0x1f) >> 0x1f & 0x40U | (Polygon->Flags).f & 0xffffffbf;
              if (*(char *)(pCVar2 + 0x24) != '\0') {
                DrawPolygon(Layer,Polygon,0);
                local_41 = '\x01';
              }
            }
            iVar10 = iVar10 + -1;
            pPVar3 = PCB;
          } while (iVar10 != -1);
        }
      }
      local_24 = pPVar3->Data;
      local_28 = (PCBTypePtr)((int)local_28 + 1);
    } while (local_28 < local_24->LayerN + 2U);
  }
  CVar4 = local_24->ElementN;
  local_28 = (PCBTypePtr)(CVar4 - 1);
  if (local_28 == (PCBTypePtr)0xffffffff) {
LAB_080ce4e8:
    if ((bVar16) || (pPVar3->ViaOn != '\0')) {
      pDVar9 = pPVar3->Data;
      if (pDVar9->ViaN != 0) {
        uVar11 = 0;
        uVar7 = pDVar9->ViaN;
        do {
          Pin = pDVar9->Via + uVar11;
          if (((((Box->X1 <= Pin->X) && (Pin->X <= Box->X2)) && (Box->Y1 <= Pin->Y)) &&
              ((Pin->Y <= Box->Y2 && (uVar8 = (Pin->Flags).f, (uVar8 & 0x2000) == 0)))) &&
             ((uVar8 >> 6 & 1) != (int)Flag)) {
            AddObjectToFlagUndoList(1,Pin,Pin,Pin);
            local_41 = '\x01';
            (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
            pPVar3 = PCB;
            if (PCB->ViaOn != '\0') {
              DrawVia(Pin,0);
              local_41 = '\x01';
              pPVar3 = PCB;
            }
          }
          pDVar9 = pPVar3->Data;
          uVar8 = pDVar9->ViaN;
        } while ((uVar8 != 0) &&
                (uVar11 = (uVar8 + 1 + uVar11) - uVar7, uVar7 = uVar8, uVar11 < uVar8));
      }
    }
    if (local_41 != '\0') {
      Draw();
      IncrementUndoSerialNumber();
    }
    return (Boolean)local_41;
  }
  local_20 = CVar4 * 300 + -300;
  uVar7 = SEXT14(Flag);
  Element = local_24->Element + (CVar4 - 1);
  if (bVar16) goto LAB_080ce10a;
LAB_080cdef8:
  if (pPVar3->ElementOn != '\0') goto LAB_080ce10a;
  bVar17 = false;
  bVar6 = pPVar3->PinOn != '\0';
LAB_080cdf0b:
  do {
    if (!bVar6) goto LAB_080ce0df;
    if (bVar17) goto LAB_080ce0df;
    do {
      if ((*(byte *)((int)&(Element->Flags).f + 1) & 0x20) == 0) {
        if (Element->PinN != 0) {
          uVar11 = 0;
          CVar4 = Element->PinN;
          do {
            Pin = Element->Pin + uVar11;
            CVar5 = CVar4;
            if (((Box->X1 <= Pin->X) && (Pin->X <= Box->X2)) &&
               ((Box->Y1 <= Pin->Y && ((Pin->Y <= Box->Y2 && (((Pin->Flags).f >> 6 & 1) != uVar7))))
               )) {
              AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
              (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
              if (PCB->PinOn == '\0') {
                local_41 = '\x01';
                CVar5 = Element->PinN;
              }
              else {
                DrawPin(Pin,0);
                local_41 = '\x01';
                CVar5 = Element->PinN;
              }
            }
          } while ((CVar5 != 0) &&
                  (uVar11 = (uVar11 + 1 + CVar5) - CVar4, CVar4 = CVar5, uVar11 < CVar5));
        }
        uVar11 = Element->PadN;
        uVar15 = 0;
        uVar8 = uVar11;
        pPVar3 = PCB;
        while ((PCB = pPVar3, uVar8 != 0 && (uVar15 < uVar8))) {
          Pad = Element->Pad + uVar15;
          iVar10 = (Pad->Point1).X;
          if ((Box->X1 <= iVar10) && (iVar10 <= Box->X2)) {
            iVar10 = (Pad->Point1).Y;
            if (((((Box->Y1 <= iVar10) && (iVar10 <= Box->Y2)) &&
                 (iVar10 = (Pad->Point2).X, Box->X1 <= iVar10)) &&
                (((iVar10 <= Box->X2 && (iVar10 = (Pad->Point2).Y, Box->Y1 <= iVar10)) &&
                 (iVar10 <= Box->Y2)))) && (((Pad->Flags).f >> 6 & 1) != uVar7)) {
              AddObjectToFlagUndoList(0x200,Element,Pad,Pad);
              (Pad->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pad->Flags).f & 0xffffffbf;
              if (PCB->PinOn == '\0') {
                local_41 = '\x01';
                uVar8 = Element->PadN;
              }
              else {
                DrawPad(Pad,0);
                local_41 = '\x01';
                uVar8 = Element->PadN;
              }
            }
          }
          uVar15 = uVar15 + (uVar11 == uVar8);
          pPVar3 = PCB;
        }
      }
LAB_080ce0df:
      do {
        local_28 = (PCBTypePtr)((int)local_28 + -1);
        iVar10 = local_20 + -300;
        if (local_28 == (PCBTypePtr)0xffffffff) goto LAB_080ce4e8;
        Element = (ElementTypePtr *)((int)&pPVar3->Data->Element[-1].BoundingBox.X1 + local_20);
        local_20 = iVar10;
        if (!bVar16) goto LAB_080cdef8;
LAB_080ce10a:
        uVar11 = (Element->Flags).f;
        if (((uVar11 & 0x2000) != 0) ||
           (((uVar11 >> 7 & 1) != (int)Settings.ShowSolderSide &&
            (pPVar3->InvisibleObjectsOn == '\0')))) {
          bVar17 = false;
          bVar6 = pPVar3->PinOn != '\0' || bVar16;
          goto LAB_080cdf0b;
        }
        uVar11 = (pPVar3->Flags).f;
        uVar8 = uVar11 & 0x40;
        if (uVar8 == 0) {
          uVar15 = -(uint)((uVar11 & 0x20) == 0) & 2;
        }
        else {
          uVar15 = 1;
        }
        if (Box->X1 <= Element->Name[uVar15].BoundingBox.X1) {
          if (uVar8 == 0) {
            if (Element->Name[-(uint)((uVar11 & 0x20) == 0) & 2].BoundingBox.X2 <= Box->X2)
            goto LAB_080ce176;
          }
          else {
            if (Element->Name[1].BoundingBox.X2 <= Box->X2) {
LAB_080ce176:
              uVar15 = 1;
              if (uVar8 == 0) {
                uVar15 = -(uint)((uVar11 & 0x20) == 0) & 2;
              }
              if (Box->Y1 <= Element->Name[uVar15].BoundingBox.Y1) {
                if (uVar8 == 0) {
                  if (Element->Name[-(uint)((uVar11 & 0x20) == 0) & 2].BoundingBox.Y2 <= Box->Y2)
                  goto LAB_080ce1bf;
                }
                else {
                  if (Element->Name[1].BoundingBox.Y2 <= Box->Y2) {
LAB_080ce1bf:
                    local_2c = 0x3c;
                    if (uVar8 == 0) {
                      local_2c = -(uint)((uVar11 & 0x20) == 0) & 0x78;
                    }
                    if ((*(byte *)((int)&Element->Name[0].Flags.f + local_2c + 1) & 0x20) == 0) {
                      uVar15 = 0x3c;
                      if (uVar8 == 0) {
                        uVar15 = -(uint)((uVar11 & 0x20) == 0) & 0x78;
                      }
                      if ((*(uint *)((int)&Element->Name[0].Flags.f + uVar15) >> 6 & 1) != uVar7) {
                        iVar10 = 2;
                        pEVar12 = Element;
                        do {
                          AddObjectToFlagUndoList
                                    (0x400,Element,Element->Name + iVar10,Element->Name + iVar10);
                          iVar10 = iVar10 + -1;
                          pEVar12->Name[2].Flags.f =
                               ~-(uint)(Flag == '\0') & 0x40 | pEVar12->Name[2].Flags.f & 0xffffffbf
                          ;
                          pEVar12 = (ElementTypePtr *)&pEVar12[-1].LineN;
                        } while (iVar10 != -1);
                        local_41 = '\x01';
                        pPVar3 = PCB;
                        if (PCB->ElementOn != '\0') {
                          DrawElementName(Element,0);
                          local_41 = '\x01';
                          pPVar3 = PCB;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } while ((!bVar16) && (pPVar3->PinOn == '\0'));
    } while ((((Element->BoundingBox).X1 < Box->X1) ||
             (((Box->X2 < (Element->BoundingBox).X2 || ((Element->BoundingBox).Y1 < Box->Y1)) ||
              (Box->Y2 < (Element->BoundingBox).Y2)))) || (((Element->Flags).f >> 6 & 1) == uVar7));
    AddObjectToFlagUndoList(2,Element,Element,Element);
    (Element->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Element->Flags).f & 0xffffffbf;
    if (Element->PinN != 0) {
      uVar8 = 0;
      uVar11 = Element->PinN;
      do {
        Pin = Element->Pin + uVar8;
        uVar15 = uVar11;
        if (uVar7 != ((Pin->Flags).f >> 6 & 1)) {
          AddObjectToFlagUndoList(0x100,Element,Pin,Pin);
          (Pin->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pin->Flags).f & 0xffffffbf;
          if (PCB->PinOn != '\0') {
            DrawPin(Pin,0);
          }
          uVar15 = Element->PinN;
        }
      } while ((uVar15 != 0) &&
              (uVar8 = (uVar8 + 1 + uVar15) - uVar11, uVar11 = uVar15, uVar8 < uVar15));
    }
    CVar4 = Element->PadN;
    local_24 = (DataTypePtr *)0x0;
    iVar10 = 0;
    CVar5 = CVar4;
    while ((CVar5 != 0 && (local_24 < CVar5))) {
      Pad = (PadTypePtr *)((int)&(Element->Pad->BoundingBox).X1 + iVar10);
      if (uVar7 != ((Pad->Flags).f >> 6 & 1)) {
        AddObjectToFlagUndoList(0x200,Element,Pad,Pad);
        (Pad->Flags).f = ~-(uint)(Flag == '\0') & 0x40 | (Pad->Flags).f & 0xffffffbf;
        if (PCB->PinOn != '\0') {
          DrawPad(Pad,0);
        }
        CVar5 = Element->PadN;
      }
      if (CVar4 == CVar5) {
        local_24 = (DataTypePtr *)((int)local_24 + 1);
        iVar10 = iVar10 + 0x68;
        CVar5 = CVar4;
      }
    }
    if (PCB->PinOn == '\0') {
      bVar17 = true;
      local_41 = '\x01';
      pPVar3 = PCB;
      bVar6 = bVar16;
    }
    else {
      bVar17 = true;
      DrawElement(Element,0);
      local_41 = '\x01';
      bVar6 = PCB->PinOn != '\0' || bVar16;
      pPVar3 = PCB;
    }
  } while( true );
}



Boolean SelectObject(void)

{
  FlagType *pFVar1;
  int iVar2;
  uint uVar3;
  PCBTypePtr pPVar4;
  int iVar5;
  ElementTypePtr *pEVar6;
  PinTypePtr *Ptr2;
  void *Ptr2_00;
  uint uVar7;
  uint uVar8;
  uint local_30;
  void *ptr3;
  PadTypePtr *local_24;
  ElementTypePtr *local_20 [4];
  
  iVar2 = SearchScreen(Crosshair.X,Crosshair.Y,0x473f,local_20,&local_24,&ptr3);
  if ((iVar2 == 0) || ((*(byte *)((int)&(local_24->Flags).f + 1) & 0x20) != 0)) {
    return '\0';
  }
  if (iVar2 == 0x10) {
    AddObjectToFlagUndoList(0x10,local_20[0],local_24,local_24);
    (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
    DrawText((LayerTypePtr)local_20[0],(TextTypePtr)local_24,0);
  }
  else {
    if (iVar2 < 0x11) {
      if (iVar2 == 2) {
        if (local_20[0]->PinN != 0) {
          uVar7 = 0;
          local_30 = local_20[0]->PinN;
          do {
            Ptr2 = local_20[0]->Pin + uVar7;
            AddObjectToFlagUndoList(0x100,local_20[0],Ptr2,Ptr2);
            uVar3 = local_20[0]->PinN;
            (Ptr2->Flags).f = (Ptr2->Flags).f ^ 0x40;
            if (uVar3 == 0) break;
            uVar7 = (uVar3 + 1 + uVar7) - local_30;
            local_30 = uVar3;
          } while (uVar7 < uVar3);
        }
        uVar7 = local_20[0]->PadN;
        uVar8 = 0;
        local_30 = 0;
        uVar3 = uVar7;
        while ((uVar3 != 0 && (uVar8 < uVar3))) {
          Ptr2_00 = (void *)((int)&(local_20[0]->Pad->BoundingBox).X1 + local_30);
          AddObjectToFlagUndoList(0x200,local_20[0],Ptr2_00,Ptr2_00);
          uVar3 = local_20[0]->PadN;
          *(uint *)((int)Ptr2_00 + 0x14) = *(uint *)((int)Ptr2_00 + 0x14) ^ 0x40;
          if (uVar3 == uVar7) {
            uVar8 = uVar8 + 1;
            local_30 = local_30 + 0x68;
            uVar3 = uVar7;
          }
        }
        iVar2 = 2;
        pEVar6 = local_20[0];
        do {
          iVar5 = iVar2 + -1;
          AddObjectToFlagUndoList
                    (0x400,local_20[0],local_20[0]->Name + iVar2,local_20[0]->Name + iVar2);
          pFVar1 = &pEVar6->Name[2].Flags;
          pFVar1->f = pFVar1->f ^ 0x40;
          pEVar6 = (ElementTypePtr *)&pEVar6[-1].LineN;
          iVar2 = iVar5;
        } while (iVar5 != -1);
        AddObjectToFlagUndoList(2,local_20[0],local_20[0],local_20[0]);
        pPVar4 = PCB;
        uVar7 = (local_20[0]->Flags).f;
        (local_20[0]->Flags).f = uVar7 ^ 0x40;
        if ((pPVar4->ElementOn != '\0') &&
           (((uVar7 >> 7 & 1) == (int)Settings.ShowSolderSide ||
            (pPVar4->InvisibleObjectsOn != '\0')))) {
          DrawElementName(local_20[0],0);
          DrawElementPackage(local_20[0],0);
          pPVar4 = PCB;
        }
        if (pPVar4->PinOn != '\0') {
          DrawElementPinsAndPads(local_20[0],0);
        }
      }
      else {
        if (iVar2 < 3) {
          if (iVar2 == 1) {
            AddObjectToFlagUndoList(1,local_20[0],local_20[0],local_20[0]);
            (local_20[0]->Flags).f = (local_20[0]->Flags).f ^ 0x40;
            DrawVia((PinTypePtr *)local_20[0],0);
          }
        }
        else {
          if (iVar2 == 4) {
            AddObjectToFlagUndoList(4,local_20[0],local_24,local_24);
            (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
            DrawLine((LayerTypePtr)local_20[0],(LineTypePtr)local_24,0);
          }
          else {
            if (iVar2 == 8) {
              AddObjectToFlagUndoList(8,local_20[0],local_24,local_24);
              (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
              DrawPolygon((LayerTypePtr)local_20[0],(PolygonTypePtr)local_24,0);
            }
          }
        }
      }
    }
    else {
      if (iVar2 == 0x200) {
        AddObjectToFlagUndoList(0x200,local_20[0],local_24,local_24);
        (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
        DrawPad(local_24,0);
      }
      else {
        if (iVar2 < 0x201) {
          if (iVar2 == 0x20) {
            AddObjectToFlagUndoList(0x20,local_20[0],local_20[0],local_20[0]);
            (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
            DrawRat((RatTypePtr *)local_24,0);
          }
          else {
            if (iVar2 == 0x100) {
              AddObjectToFlagUndoList(0x100,local_20[0],local_24,local_24);
              (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
              DrawPin((PinTypePtr *)local_24,0);
            }
          }
        }
        else {
          if (iVar2 == 0x400) {
            iVar2 = 2;
            pEVar6 = local_20[0];
            do {
              iVar5 = iVar2 + -1;
              AddObjectToFlagUndoList
                        (0x400,local_20[0],local_20[0]->Name + iVar2,local_20[0]->Name + iVar2);
              pFVar1 = &pEVar6->Name[2].Flags;
              pFVar1->f = pFVar1->f ^ 0x40;
              pEVar6 = (ElementTypePtr *)&pEVar6[-1].LineN;
              iVar2 = iVar5;
            } while (iVar5 != -1);
            DrawElementName(local_20[0],0);
          }
          else {
            if (iVar2 == 0x4000) {
              AddObjectToFlagUndoList(0x4000,local_20[0],local_24,local_24);
              (local_24->Flags).f = (local_24->Flags).f ^ 0x40;
              DrawArc((LayerTypePtr)local_20[0],(ArcTypePtr *)local_24,0);
            }
          }
        }
      }
    }
  }
  Draw();
  IncrementUndoSerialNumber();
  return '\x01';
}



void SelectPin(LibraryEntryTypePtr *entry,Boolean toggle)

{
  Boolean BVar1;
  ConnectionType conn;
  
  BVar1 = SeekPad((LibraryEntryType *)entry,&conn,'\0');
  if (BVar1 != '\0') {
    if (conn.type == 0x100) {
      AddObjectToFlagUndoList(0x100,conn.ptr1,conn.ptr2,conn.ptr2);
      if (toggle == '\0') {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) | 0x40;
      }
      else {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) ^ 0x40;
        CenterDisplay(*(LocationType *)((int)conn.ptr2 + 0x34),
                      *(LocationType *)((int)conn.ptr2 + 0x38),'\0');
      }
      DrawPin((PinTypePtr *)conn.ptr2,0);
      return;
    }
    if (conn.type == 0x200) {
      AddObjectToFlagUndoList(0x200,conn.ptr1,conn.ptr2,conn.ptr2);
      if (toggle == '\0') {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) | 0x40;
      }
      else {
        *(uint *)((int)conn.ptr2 + 0x14) = *(uint *)((int)conn.ptr2 + 0x14) ^ 0x40;
        CenterDisplay(*(LocationType *)((int)conn.ptr2 + 0x2c),
                      *(LocationType *)((int)conn.ptr2 + 0x30),'\0');
      }
      DrawPad((PadTypePtr *)conn.ptr2,0);
      return;
    }
  }
  return;
}



void SetViaSize(BDimension Size,Boolean Force)

{
  if ((Force != '\0') || ((Size - 2000U < 0x988eb1 && (Settings.ViaDrillingHole + 399 < Size)))) {
    Settings.ViaThickness = Size;
  }
  return;
}



void SetViaDrillingHole(BDimension Size,Boolean Force)

{
  if ((Force != '\0') || ((Size - 400U < 0x9894f1 && (Size < Settings.ViaThickness + -399)))) {
    Settings.ViaDrillingHole = Size;
  }
  return;
}



void pcb_use_route_style(RouteStyleType *rst)

{
  Settings.ViaThickness = rst->Diameter;
  Settings.ViaDrillingHole = rst->Hole;
  Settings.LineThickness = rst->Thick;
  Settings.Keepaway = rst->Keepaway;
  return;
}



void SetKeepawayWidth(BDimension Width)

{
  if (Width < 0x989681) {
    Settings.Keepaway = Width;
  }
  return;
}



void SetTextScale(Dimension Scale)

{
  if ((ushort)(Scale - 10U) < 0x2707) {
    Settings.TextScale = (int)Scale;
  }
  return;
}



void SetChangedFlag(Boolean New)

{
  if (PCB->Changed != New) {
    PCB->Changed = New;
  }
  return;
}



void SaveMode(void)

{
  int iVar1;
  
  iVar1 = mode_position;
  mode_stack[mode_position] = Settings.Mode;
  if (iVar1 < 0xf) {
    mode_position = iVar1 + 1;
  }
  return;
}



void SetLocalRef(LocationType X,LocationType Y,Boolean Showing)

{
  int count;
  MarkType old;
  
  if (Showing == '\0') {
    if (count < 1) {
      return;
    }
    HideCrosshair('\0');
    count = 0;
    Marked._0_4_ = old._0_4_;
    Marked.X = old.X;
    Marked.Y = old.Y;
  }
  else {
    HideCrosshair('\x01');
    if (count == 0) {
      old._0_4_ = Marked._0_4_;
      old.X = Marked.X;
      old.Y = Marked.Y;
    }
    count = count + 1;
    Marked._0_4_ = CONCAT31(Marked._1_3_,1);
    Marked.X = X;
    Marked.Y = Y;
  }
  RestoreCrosshair('\0');
  return;
}



void SetRouteStyle(char *name)

{
  int iVar1;
  char *__s2;
  int iVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  int in_GS_OFFSET;
  char num [10];
  
  iVar3 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pPVar4 = PCB;
  do {
    if ((name != (char *)0x0) && (__s2 = pPVar4->RouteStyle[0].Name, __s2 != (char *)0x0)) {
      iVar2 = strcmp(name,__s2);
      if (iVar2 == 0) {
        __sprintf_chk(num,1,10,&DAT_081538d1,iVar3 + 1);
        hid_actionl("RouteStyle",num,0);
        break;
      }
    }
    iVar3 = iVar3 + 1;
    pPVar4 = (PCBTypePtr)&pPVar4->PrintFilename;
  } while (iVar3 != 4);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void SetCrosshairRangeToBuffer(void)

{
  if (Settings.Mode != 5) {
    return;
  }
  SetBufferBoundingBox((BufferTypePtr)(Buffers + Settings.BufferNumber));
  SetCrosshairRange(Buffers[Settings.BufferNumber].X - Buffers[Settings.BufferNumber].BoundingBox.X1
                    ,Buffers[Settings.BufferNumber].Y -
                     Buffers[Settings.BufferNumber].BoundingBox.Y1,
                    (PCB->MaxWidth + Buffers[Settings.BufferNumber].X) -
                    Buffers[Settings.BufferNumber].BoundingBox.X2,
                    (PCB->MaxHeight + Buffers[Settings.BufferNumber].Y) -
                    Buffers[Settings.BufferNumber].BoundingBox.Y2);
  return;
}



void SetMode(int Mode)

{
  int iVar1;
  Boolean recursing;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  
  if (recursing != '\0') {
    return;
  }
  recursing = '\x01';
  HideCrosshair('\x01');
  addedLines = 0;
  Crosshair.AttachedObject.Type = 0;
  Crosshair.AttachedObject.State = 0;
  Crosshair.AttachedPolygon.PointN = 0;
  if (PCB->RatDraw == '\0') {
    if (((Settings.Mode != 2) || (Mode != 0x6d)) || (Crosshair.AttachedLine.State == 0)) {
LAB_080cf1fa:
      bVar4 = Settings.Mode == 2;
      bVar2 = Settings.Mode == 0x6d;
      bVar3 = Mode == 2;
      if ((bVar3) && (bVar2)) {
        bVar3 = true;
        bVar2 = true;
        if (Crosshair.AttachedBox.State != 0) {
          Crosshair.AttachedBox.State = 0;
          Crosshair.AttachedLine.State = 1;
          Settings.Mode = 2;
          Crosshair.AttachedLine.Point2.X = Crosshair.AttachedBox.Point1.X;
          Crosshair.AttachedLine.Point1.X = Crosshair.AttachedBox.Point1.X;
          Crosshair.AttachedLine.Point2.Y = Crosshair.AttachedBox.Point1.Y;
          Crosshair.AttachedLine.Point1.Y = Crosshair.AttachedBox.Point1.Y;
          AdjustAttachedObjects();
          iVar1 = Mode;
          goto LAB_080cf2fd;
        }
      }
      goto LAB_080cf223;
    }
    Crosshair.AttachedLine.State = 0;
    Crosshair.AttachedBox.State = 1;
    Crosshair.AttachedBox.Point2.X = Crosshair.AttachedLine.Point1.X;
    Crosshair.AttachedBox.Point1.X = Crosshair.AttachedLine.Point1.X;
    Crosshair.AttachedBox.Point2.Y = Crosshair.AttachedLine.Point1.Y;
    Crosshair.AttachedBox.Point1.Y = Crosshair.AttachedLine.Point1.Y;
    AdjustAttachedObjects();
    iVar1 = Mode;
  }
  else {
    if (((((Mode != 3) && (Mode != 0x6d)) && (Mode != 4)) && ((Mode != 1 && (Mode != 0x6a)))) &&
       ((Mode != 6 && (Mode != 0x6c)))) goto LAB_080cf1fa;
    Message("That mode is NOT allowed when drawing ratlines!\n");
    bVar4 = Settings.Mode == 2;
    bVar2 = Settings.Mode == 0x6d;
    Mode = 0;
    bVar3 = false;
LAB_080cf223:
    if ((bVar4) || (bVar2)) {
      SetLocalRef(0,0,'\0');
    }
    Crosshair.AttachedBox.State = 0;
    Crosshair.AttachedLine.State = 0;
    if (bVar3) {
      iVar1 = Mode;
      if (*(char *)&(PCB->Flags).f < '\0') {
        SaveUndoSerialNumber();
        ResetFoundPinsViasAndPads('\x01');
        RestoreUndoSerialNumber();
        ResetFoundLinesAndPolygons('\x01');
        IncrementUndoSerialNumber();
        iVar1 = Mode;
      }
    }
    else {
      iVar1 = Mode;
      if (Mode == 5) {
        Settings.Mode = Mode;
        SetCrosshairRangeToBuffer();
        goto LAB_080cf263;
      }
    }
  }
LAB_080cf2fd:
  Settings.Mode = iVar1;
  SetCrosshairRange(0,0,PCB->MaxWidth,PCB->MaxHeight);
LAB_080cf263:
  recursing = '\0';
  MoveCrosshairRelative(0,0);
  RestoreCrosshair('\x01');
  return;
}



void RestoreMode(void)

{
  if (mode_position != 0) {
    mode_position = mode_position + -1;
    SetMode(mode_stack[mode_position]);
    return;
  }
  Message("hace: underflow of restore mode\n");
  return;
}



void SetBufferNumber(int Number)

{
  if (4 < (uint)Number) {
    return;
  }
  Settings.BufferNumber = Number;
  SetCrosshairRangeToBuffer();
  return;
}



void SetLineSize(BDimension Size)

{
  if ((Size - 1U < 10000000) && (Settings.LineThickness = Size, *(char *)&(PCB->Flags).f < '\0')) {
    FitCrosshairIntoGrid(Crosshair.X,Crosshair.Y);
    return;
  }
  return;
}



void SetGrid(float Grid,Boolean align)

{
  PCBTypePtr pPVar1;
  
  pPVar1 = PCB;
  if ((1.00000000 <= Grid) && (Grid <= 100000.00000000)) {
    if (align != '\0') {
      PCB->GridOffsetX =
           (int)ROUND(((float)Crosshair.X - (float)(int)ROUND((float)Crosshair.X / Grid) * Grid) +
                      0.50000000);
      pPVar1->GridOffsetY =
           (int)ROUND(((float)Crosshair.Y - (float)(int)ROUND((float)Crosshair.Y / Grid) * Grid) +
                      0.50000000);
    }
    pPVar1->Grid = (double)Grid;
    if (Settings.DrawGrid != '\0') {
      UpdateAll();
      return;
    }
  }
  return;
}



int error_ignore(char *msg)

{
  return 0;
}



char * __regparm3 alloc_buf(int len)

{
  size_t __size;
  char *pcVar1;
  int iVar2;
  
  __size = len + 1;
  iVar2 = (bufptr + 1) % 10;
  bufptr = iVar2;
  if (buffers[iVar2].len < (int)__size) {
    if (buffers[iVar2].ptr == (char *)0x0) {
      pcVar1 = (char *)malloc(__size);
      buffers[iVar2].ptr = pcVar1;
    }
    else {
      pcVar1 = (char *)realloc(buffers[iVar2].ptr,__size);
      buffers[iVar2].ptr = pcVar1;
    }
    iVar2 = bufptr;
    buffers[bufptr].len = __size;
  }
  return buffers[iVar2].ptr;
}



void __regparm3 grow_layer_list(int num)

{
  size_t __nmemb;
  
  if (layers == (char *)0x0) {
    __nmemb = 1;
    if (0 < num) {
      __nmemb = num;
    }
    layers = (char *)calloc(__nmemb,1);
    max_layers = num;
  }
  else {
    if (max_layers < num) {
      max_layers = num;
      layers = (char *)realloc(layers,num);
    }
  }
  if (num_layers < num) {
    memset(layers + num_layers,0,~num_layers + num);
  }
  num_layers = num;
  return;
}



char * common_flags_to_string(FlagType flags,int object_type,FlagBitsType *flagbits,int n_flagbits)

{
  char cVar1;
  char cVar2;
  int iVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  ulong uVar7;
  int iVar8;
  uchar uVar9;
  uint in_EAX;
  uint *puVar10;
  uint uVar11;
  char *pcVar12;
  undefined4 *puVar13;
  int iVar14;
  char *__src;
  size_t sVar15;
  uchar uVar16;
  sbyte sVar17;
  undefined4 in_ECX;
  uchar uVar18;
  uchar uVar19;
  uchar uVar20;
  undefined4 in_EDX;
  int num;
  uint uVar21;
  char *__dest;
  undefined4 *__dest_00;
  int iVar22;
  int iVar23;
  int in_GS_OFFSET;
  undefined *local_e0;
  char *local_40;
  size_t local_3c;
  FlagHolder fh;
  
  uVar18 = (uchar)in_EDX;
  uVar4 = (uchar)((uint)in_ECX >> 8);
  uVar19 = (uchar)in_ECX;
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  uVar9 = (uchar)((uint)in_ECX >> 0x10);
  uVar20 = (uchar)((uint)in_ECX >> 0x18);
  uVar16 = (uchar)((uint)in_EDX >> 8);
  uVar6 = (uchar)((uint)in_EDX >> 0x10);
  uVar5 = (uchar)((uint)in_EDX >> 0x18);
  if (flags.f == 0x20) {
    fh.Flags.f = in_EAX & 0xffffffef;
  }
  else {
    if (flags.f == 0x100) {
      fh.Flags.f = in_EAX & 0xfffffffe;
    }
    else {
      fh.Flags.f = in_EAX;
      if (flags.f == 1) {
        fh.Flags.f = in_EAX & 0xfffffffd;
      }
    }
  }
  uVar7 = fh.Flags.f;
  iVar23 = 3;
  if (0 < flags.t._4_4_) {
    num = 0;
    local_40 = (char *)fh.Flags.f;
    iVar23 = 3;
    puVar10 = flags.t._0_4_;
    do {
      if (((puVar10[3] & flags.f) != 0) && (((uint)local_40 & *puVar10) != 0)) {
        local_40 = (char *)((uint)local_40 & ~*puVar10);
        iVar23 = iVar23 + 1 + puVar10[2];
      }
      num = num + 1;
      puVar10 = puVar10 + 4;
    } while (num != flags.t._4_4_);
    fh.Flags.f = (ulong)local_40;
  }
  fh.Flags.t[0] = uVar18;
  fh.Flags.t[1] = uVar16;
  fh.Flags.t[2] = uVar6;
  fh.Flags.t[3] = uVar5;
  fh.Flags.t[4] = uVar19;
  fh.Flags.t[5] = uVar4;
  fh.Flags.t[6] = uVar9;
  fh.Flags.t[7] = uVar20;
  num = mem_any_set(fh.Flags.t,8);
  if (num != 0) {
    iVar23 = iVar23 + 10;
    uVar11 = 0;
    do {
      uVar21 = (uint)fh.Flags.t[(int)uVar11 >> 1];
      sVar17 = (sbyte)((uVar11 & 1) << 2);
      if ((0xf << sVar17 & uVar21) != 0) {
        uVar21 = (int)uVar21 >> sVar17 & 0xf;
        if ((int)uVar11 < 10) {
          num = 1;
          if (uVar21 != 0) {
LAB_080cf851:
            num = 2;
          }
        }
        else {
          num = 3;
          if (uVar21 == 0) goto LAB_080cf851;
        }
        iVar23 = num + 1 + iVar23;
      }
      uVar11 = uVar11 + 1;
    } while (uVar11 != 0x10);
  }
  pcVar12 = alloc_buf(iVar23 + 2);
  *pcVar12 = '\"';
  puVar13 = (undefined4 *)(pcVar12 + 1);
  __dest_00 = puVar13;
  fh.Flags.f = uVar7;
  fh.Flags.t[0] = uVar18;
  fh.Flags.t[1] = uVar16;
  fh.Flags.t[2] = uVar6;
  fh.Flags.t[3] = uVar5;
  fh.Flags.t[4] = uVar19;
  fh.Flags.t[5] = uVar4;
  fh.Flags.t[6] = uVar9;
  fh.Flags.t[7] = uVar20;
  if (0 < flags.t._4_4_) {
    iVar23 = 0;
    do {
      if (((flags.t._0_4_[3] & flags.f) != 0) && ((fh.Flags.f & *flags.t._0_4_) != 0)) {
        if (__dest_00 != puVar13) {
          *(undefined *)__dest_00 = 0x2c;
          __dest_00 = (undefined4 *)((int)__dest_00 + 1);
        }
        strcpy((char *)__dest_00,(char *)flags.t._0_4_[1]);
        __dest_00 = (undefined4 *)((int)__dest_00 + flags.t._0_4_[2]);
        fh.Flags.f = fh.Flags.f & ~*flags.t._0_4_;
      }
      iVar23 = iVar23 + 1;
      flags.t._0_4_ = flags.t._0_4_ + 4;
    } while (iVar23 < flags.t._4_4_);
  }
  iVar23 = mem_any_set(fh.Flags.t,8);
  if (iVar23 != 0) {
    if (__dest_00 != puVar13) {
      *(undefined *)__dest_00 = 0x2c;
      __dest_00 = (undefined4 *)((int)__dest_00 + 1);
    }
    *__dest_00 = 0x72656874;
    uVar11 = 0;
    __dest_00[1] = 0x6c616d;
    __dest = (char *)((int)__dest_00 + 7);
    grow_layer_list(0);
    num = 1;
    iVar23 = num_layers;
    do {
      while( true ) {
        uVar21 = (uint)fh.Flags.t[(int)uVar11 >> 1];
        sVar17 = (sbyte)((uVar11 & 1) << 2);
        if ((0xf << sVar17 & uVar21) == 0) break;
        if (iVar23 <= (int)uVar11) {
          grow_layer_list(num);
          iVar23 = num_layers;
        }
        num = num + 1;
        layers[uVar11] = (byte)((int)uVar21 >> sVar17) & 0xf;
        uVar11 = uVar11 + 1;
        if (uVar11 == 0x10) goto LAB_080cfa1d;
      }
      uVar11 = uVar11 + 1;
      num = num + 1;
      iVar23 = num_layers;
    } while (uVar11 != 0x10);
LAB_080cfa1d:
    local_3c = 2;
    if (0 < iVar23) {
      num = 0;
      do {
        if (layers[num] != '\0') {
          iVar14 = 2;
          if (9 < num) {
            iVar14 = 3;
            iVar22 = num;
            iVar8 = 1;
            if (99 < num) {
              do {
                iVar14 = iVar8;
                iVar22 = iVar22 / 10;
                iVar8 = iVar14 + 1;
              } while (9 < iVar22);
              iVar14 = iVar14 + 2;
            }
          }
          local_3c = local_3c + 1 + iVar14;
        }
        num = num + 1;
      } while (num != iVar23);
    }
    if (buflen < (int)local_3c) {
      if (buf == (char *)0x0) {
        buf = (char *)malloc(local_3c);
      }
      else {
        buf = (char *)realloc(buf,local_3c);
      }
      buflen = local_3c;
      iVar23 = num_layers;
    }
    __src = buf;
    local_40 = buf + 1;
    *buf = '(';
    if (0 < iVar23) {
      num = 0;
      do {
        __src = layers + num;
        cVar1 = *__src;
        iVar14 = num + 1;
        if (cVar1 != '\0') {
          iVar22 = num + 1;
          iVar14 = iVar22;
          if (iVar22 < iVar23) {
            cVar2 = layers[num + 1];
            while ((cVar2 == '\x01' && (iVar14 = iVar14 + 1, iVar14 < iVar23))) {
              cVar2 = __src[2];
              __src = __src + 1;
            }
          }
          if (num + 2 < iVar14) {
            __sprintf_chk(local_40,1,0xffffffff,&DAT_0814f555,num,iVar14 + -1);
          }
          else {
            if (cVar1 == '\x02') {
              local_e0 = &DAT_0814f55c;
LAB_080cfbba:
              __sprintf_chk(local_40,1,0xffffffff,local_e0,num);
              iVar14 = iVar22;
            }
            else {
              if (cVar1 < '\x03') {
                if (cVar1 != '\x01') {
LAB_080cfbae:
                  local_e0 = &DAT_0814f56b;
                  goto LAB_080cfbba;
                }
                local_e0 = &DAT_0814f558;
              }
              else {
                if (cVar1 == '\x03') {
                  __sprintf_chk(local_40,1,0xffffffff,&DAT_0814f561,num);
                  iVar14 = iVar22;
                  goto LAB_080cfbd5;
                }
                if (cVar1 != '\x04') goto LAB_080cfbae;
                local_e0 = &DAT_0814f566;
              }
              __sprintf_chk(local_40,1,0xffffffff,local_e0,num);
              iVar14 = iVar22;
            }
          }
LAB_080cfbd5:
          sVar15 = strlen(local_40);
          local_40 = local_40 + sVar15;
        }
        num = iVar14;
        __src = buf;
        iVar23 = num_layers;
      } while (num < num_layers);
    }
    local_40[-1] = ')';
    *local_40 = '\0';
    strcpy(__dest,__src);
    sVar15 = strlen(__dest);
    __dest_00 = (undefined4 *)(__dest + sVar15);
  }
  *(undefined *)__dest_00 = 0x22;
  *(undefined *)((int)__dest_00 + 1) = 0;
  if (iVar3 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pcVar12;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * pcbflags_to_string(FlagType flags)

{
  char *pcVar1;
  int in_stack_fffffff0;
  FlagBitsType *in_stack_fffffff4;
  int in_stack_fffffff8;
  
  pcVar1 = common_flags_to_string
                     ((FlagType)CONCAT48(0x16,0x8168000ffffffff),in_stack_fffffff0,in_stack_fffffff4
                      ,in_stack_fffffff8);
  return pcVar1;
}



char * flags_to_string(FlagType flags,int object_type)

{
  char *pcVar1;
  int in_stack_fffffff0;
  FlagBitsType *in_stack_fffffff4;
  int in_stack_fffffff8;
  
  pcVar1 = common_flags_to_string
                     ((FlagType)CONCAT48(0x17,CONCAT44(0x8168160,object_type)),in_stack_fffffff0,
                      in_stack_fffffff4,in_stack_fffffff8);
  return pcVar1;
}



// WARNING: Could not reconcile some variable overlaps

FlagType * __regparm3
common_string_to_flags
          (FlagType *__return_storage_ptr__,char *flagstring,anon_subr_int_char_ptr *error,
          FlagBitsType *flagbits,int n_flagbits)

{
  char cVar1;
  int iVar2;
  char cVar3;
  code *pcVar4;
  FlagBitsType *pFVar5;
  uint uVar6;
  ushort **ppuVar7;
  undefined *puVar8;
  size_t sVar9;
  char *pcVar10;
  sbyte sVar11;
  char *__s;
  int iVar12;
  char cVar13;
  char *pcVar14;
  undefined *num;
  FlagType *pFVar15;
  char *pcVar16;
  undefined *puVar17;
  FlagType *pFVar18;
  int in_GS_OFFSET;
  bool bVar19;
  byte bVar20;
  anon_subr_int_char_ptr *local_50;
  uint local_48;
  int local_38;
  char *local_34;
  char *local_30;
  FlagHolder rv;
  
  bVar20 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  rv.Flags.f = empty_flags.f;
  rv.Flags.t._0_4_ = empty_flags.t._0_4_;
  rv.Flags.t._4_4_ = empty_flags.t._4_4_;
  pcVar4 = error_ignore;
  if (error != (anon_subr_int_char_ptr *)0x0) {
    pcVar4 = error;
  }
  if (flagstring == (char *)0x0) {
    iVar12 = 3;
    pFVar15 = &empty_flags;
    pFVar18 = __return_storage_ptr__;
    while (iVar12 != 0) {
      iVar12 = iVar12 + -1;
      pFVar18->f = pFVar15->f;
      pFVar15 = (FlagType *)pFVar15->t;
      pFVar18 = (FlagType *)pFVar18->t;
    }
  }
  else {
    cVar13 = *flagstring;
    local_30 = flagstring;
    if (cVar13 == '\"') {
      local_30 = flagstring + 1;
      cVar13 = flagstring[1];
    }
    if ((cVar13 != '\"') && (cVar13 != '\0')) {
      local_48 = 0;
      if (cVar13 == ',') goto LAB_080cfef2;
LAB_080cfe38:
      if (cVar13 == '\0') goto LAB_080cfef2;
      pcVar14 = (char *)0x0;
      local_34 = local_30;
      if (cVar13 == '\"') goto LAB_080cfe91;
      if (cVar13 != '(') {
        do {
          local_34 = local_34 + 1;
          cVar13 = *local_34;
          if ((cVar13 == ',') || (cVar13 == '\0')) {
            pcVar14 = local_34 + -(int)local_30;
            goto LAB_080cfe80;
          }
          if (cVar13 == '\"') {
            pcVar14 = local_34 + -(int)local_30;
            bVar19 = pcVar14 == (char *)0x7;
            if (!bVar19) goto LAB_080cfe91;
            goto LAB_080cff89;
          }
        } while (cVar13 != '(');
        pcVar14 = local_34 + -(int)local_30;
      }
      do {
        __s = local_34 + 1;
        grow_layer_list(0);
        cVar13 = *__s;
        local_34 = __s;
        if (cVar13 != '\0') {
          num = (undefined *)0xffffffff;
          local_38 = 5;
          cVar3 = '\x01';
          puVar17 = (undefined *)0x0;
          local_50 = pcVar4;
          do {
            puVar8 = puVar17;
            if (cVar13 == '+') {
              cVar1 = *local_34;
              cVar3 = '\x02';
joined_r0x080d00a3:
              if (cVar1 == ')') {
                local_34 = local_34 + 1;
                break;
              }
            }
            else {
              if (cVar13 == 'S') {
                cVar1 = *local_34;
                cVar3 = '\x03';
                goto joined_r0x080d00a3;
              }
              if (cVar13 == 'X') {
                cVar1 = *local_34;
                cVar3 = '\x04';
                goto joined_r0x080d00a3;
              }
              if (cVar13 == 't') {
                cVar1 = *local_34;
                cVar3 = '\x05';
                goto joined_r0x080d00a3;
              }
              if (((cVar13 != ',') && (cVar13 != ')')) && (cVar13 != '-')) {
                ppuVar7 = __ctype_b_loc();
                if ((*(byte *)((int)*ppuVar7 + (int)cVar13 * 2 + 1) & 8) == 0) {
                  if (local_50 == (anon_subr_int_char_ptr *)0x0) {
                    cVar1 = *local_34;
                  }
                  else {
                    sVar9 = strlen(__s);
                    pcVar10 = alloc_buf(sVar9 + 0x2c);
                    __sprintf_chk(pcVar10,1,0xffffffff,
                                  "Syntax error parsing layer list \"%.*s\" at %c",local_38,__s,
                                  (int)*local_34);
                    (*local_50)(pcVar10);
                    cVar1 = *local_34;
                    local_50 = (anon_subr_int_char_ptr *)0x0;
                  }
                }
                else {
                  cVar1 = *local_34;
                  puVar8 = &DAT_ffffffd0 + (int)puVar17 * 10 + (int)cVar13;
                }
                goto joined_r0x080d00a3;
              }
              if (num == (undefined *)0xffffffff) goto LAB_080d011f;
              while (puVar8 = num, (int)num <= (int)puVar17) {
LAB_080d011f:
                num = puVar8 + 1;
                if ((int)puVar8 < num_layers) {
                  layers[(int)puVar8] = cVar3;
                }
                else {
                  grow_layer_list((int)num);
                  layers[(int)puVar8] = cVar3;
                }
              }
              cVar1 = *local_34;
              puVar8 = (undefined *)0x0;
              cVar3 = '\x01';
              num = puVar17;
              if (cVar1 != '-') {
                num = (undefined *)0xffffffff;
                puVar8 = (undefined *)0x0;
                goto joined_r0x080d00a3;
              }
            }
            local_34 = local_34 + 1;
            cVar13 = *local_34;
            local_38 = local_38 + 1;
            puVar17 = puVar8;
          } while (cVar13 != '\0');
        }
        do {
          bVar19 = pcVar14 == (char *)0x7;
          if (bVar19) {
LAB_080cff89:
            iVar12 = 7;
            __s = local_30;
            pcVar10 = "thermal";
            do {
              if (iVar12 == 0) break;
              iVar12 = iVar12 + -1;
              bVar19 = *__s == *pcVar10;
              __s = __s + (uint)bVar20 * -2 + 1;
              pcVar10 = pcVar10 + (uint)bVar20 * -2 + 1;
            } while (bVar19);
            if (!bVar19) goto LAB_080cfe91;
            uVar6 = 0;
            do {
              if (num_layers <= (int)uVar6) break;
              if (layers[uVar6] != '\0') {
                sVar11 = (sbyte)((uVar6 & 1) << 2);
                rv.Flags.t[(int)uVar6 >> 1] =
                     layers[uVar6] << sVar11 | ~(byte)(0xf << sVar11) & rv.Flags.t[(int)uVar6 >> 1];
              }
              uVar6 = uVar6 + 1;
            } while (uVar6 != 0x10);
LAB_080cfecc:
            cVar13 = *local_34;
          }
          else {
LAB_080cfe91:
            iVar12 = 0;
            pFVar5 = flagbits;
            if (0 < n_flagbits) {
              do {
                if ((char *)pFVar5->nlen == pcVar14) {
                  bVar19 = true;
                  __s = pcVar14;
                  pcVar10 = pFVar5->name;
                  pcVar16 = local_30;
                  do {
                    if (__s == (char *)0x0) break;
                    __s = __s + -1;
                    bVar19 = *pcVar10 == *pcVar16;
                    pcVar10 = pcVar10 + (uint)bVar20 * -2 + 1;
                    pcVar16 = pcVar16 + (uint)bVar20 * -2 + 1;
                  } while (bVar19);
                  if (bVar19) {
                    local_48 = local_48 | pFVar5->mask;
                    goto LAB_080cfecc;
                  }
                }
                iVar12 = iVar12 + 1;
                pFVar5 = pFVar5 + 1;
              } while (iVar12 < n_flagbits);
            }
            __s = alloc_buf((int)(pcVar14 + 0x1c));
            __sprintf_chk(__s,1,0xffffffff,"Unknown flag: \"%.*s\" ignored",pcVar14,local_30);
            (*pcVar4)(__s);
            cVar13 = *local_34;
          }
          if ((cVar13 == '\"') || (cVar13 == '\0')) goto LAB_080cff40;
          local_30 = local_34 + 1;
          cVar13 = local_34[1];
          if (cVar13 != ',') goto LAB_080cfe38;
LAB_080cfef2:
          pcVar14 = (char *)0x0;
          local_34 = local_30;
LAB_080cfe80:
        } while (cVar13 != '(');
      } while( true );
    }
    local_48 = 0;
LAB_080cff40:
    rv.Flags.f = local_48;
    __return_storage_ptr__->f = local_48;
    *(undefined4 *)__return_storage_ptr__->t = rv.Flags.t._0_4_;
    *(undefined4 *)(__return_storage_ptr__->t + 4) = rv.Flags.t._4_4_;
  }
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return __return_storage_ptr__;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



FlagType *
string_to_pcbflags(FlagType *__return_storage_ptr__,char *flagstring,anon_subr_int_char_ptr *error)

{
  common_string_to_flags(__return_storage_ptr__,flagstring,error,pcb_flagbits,0x16);
  return __return_storage_ptr__;
}



FlagType *
string_to_flags(FlagType *__return_storage_ptr__,char *flagstring,anon_subr_int_char_ptr *error)

{
  common_string_to_flags(__return_storage_ptr__,flagstring,error,object_flagbits,0x17);
  return __return_storage_ptr__;
}



POLYAREA * __regparm3 diag_line(LocationType X,LocationType Y,BDimension l,BDimension w,Boolean rt)

{
  PLINE *contour;
  POLYAREA *pPVar1;
  VNODE *node;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  Vector v;
  
  if (rt == '\0') {
    local_40 = (int)ROUND((double)(w - l) * 0.70710678);
    local_3c = (int)ROUND((double)-(w + l) * 0.70710678);
    local_48 = -local_3c;
    local_44 = -local_40;
  }
  else {
    local_48 = (int)ROUND((double)(l - w) * 0.70710678);
    local_44 = (int)ROUND((double)(w + l) * 0.70710678);
    local_40 = local_44;
    local_3c = local_48;
  }
  v[0] = local_3c + X;
  v[1] = local_44 + Y;
  contour = poly_NewContour(v);
  pPVar1 = (POLYAREA *)0x0;
  if (contour != (PLINE *)0x0) {
    v[0] = X - local_40;
    v[1] = Y - local_48;
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    v[0] = X - local_3c;
    v[1] = Y - local_44;
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    v[0] = local_40 + X;
    v[1] = Y + local_48;
    node = poly_CreateNode(v);
    poly_InclVertex((contour->head).prev,node);
    pPVar1 = ContourToPoly(contour);
  }
  return pPVar1;
}



POLYAREA * __regparm3 square_therm(PinTypePtr *pin,Cardinal style)

{
  int iVar1;
  int thick;
  PLINE *contour;
  POLYAREA *pPVar2;
  VNODE *node;
  POLYAREA *pPVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  POLYAREA *pPVar7;
  int in_GS_OFFSET;
  Vector v;
  LineType l;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (style == 1) {
    iVar5 = pin->Clearance;
    iVar6 = pin->Thickness;
    iVar4 = iVar6 / 2;
    thick = (int)ROUND((double)iVar5 * pcb->ThermScale * 0.70710678);
    v[0] = (thick - iVar4) + pin->X;
    v[1] = pin->Y + iVar4;
    contour = poly_NewContour(v);
    if (contour != (PLINE *)0x0) {
      v[0] = (pin->X + iVar4) - thick;
      iVar5 = (iVar6 + iVar5) / 2;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      v[0] = (iVar5 + pin->X) - thick;
      v[1] = iVar5 + pin->Y;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      v[0] = (thick - iVar5) + pin->X;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      pPVar7 = ContourToPoly(contour);
      v[0] = pin->X + iVar4;
      v[1] = (pin->Y + iVar4) - thick;
      contour = poly_NewContour(v);
      if (contour != (PLINE *)0x0) {
        v[1] = (thick - iVar4) + pin->Y;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        v[0] = iVar5 + pin->X;
        v[1] = (thick - iVar5) + pin->Y;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        v[1] = (iVar5 + pin->Y) - thick;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        pPVar3 = ContourToPoly(contour);
        pPVar7->f = pPVar3;
        pPVar3->b = pPVar7;
        v[0] = pin->X - iVar4;
        v[1] = (thick - iVar4) + pin->Y;
        contour = poly_NewContour(v);
        if (contour != (PLINE *)0x0) {
          v[1] = (pin->Y + iVar4) - thick;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          v[0] = pin->X - iVar5;
          v[1] = (iVar5 + pin->Y) - thick;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          v[1] = (thick - iVar5) + pin->Y;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          pPVar3 = ContourToPoly(contour);
          pPVar7->f->f = pPVar3;
          pPVar3->b = pPVar7->f;
          v[0] = (pin->X + iVar4) - thick;
          v[1] = pin->Y - iVar4;
          contour = poly_NewContour(v);
          if (contour != (PLINE *)0x0) {
            v[0] = pin->X + (thick - iVar4);
            node = poly_CreateNode(v);
            poly_InclVertex((contour->head).prev,node);
            v[0] = (thick - iVar5) + pin->X;
            v[1] = pin->Y - iVar5;
            node = poly_CreateNode(v);
            poly_InclVertex((contour->head).prev,node);
            v[0] = (iVar5 + pin->X) - thick;
            node = poly_CreateNode(v);
            poly_InclVertex((contour->head).prev,node);
LAB_080d103b:
            pPVar3 = ContourToPoly(contour);
            pPVar7->f->f->f = pPVar3;
            pPVar3->f = pPVar7;
            pPVar3->b = pPVar7->f->f;
            pPVar7->b = pPVar3;
            goto LAB_080d0502;
          }
        }
      }
    }
  }
  else {
    if (style == 4) {
      thick = pin->Clearance;
      iVar6 = pin->Thickness / 2;
      iVar5 = thick + 3;
      if (-1 < thick) {
        iVar5 = thick;
      }
      iVar4 = (iVar5 >> 2) + iVar6;
      iVar5 = (int)ROUND((double)iVar6 - (double)thick * pcb->ThermScale);
      thick = thick / 2;
      l.Point1.X = pin->X - iVar5;
      l.Point2.X = iVar5 + pin->X;
      l.Point1.Y = iVar4 + pin->Y;
      l.Point2.Y = l.Point1.Y;
      pPVar7 = LinePoly(&l,thick);
      l.Point1.X = iVar4 + pin->X;
      l.Point1.Y = pin->Y - iVar5;
      l.Point2.Y = iVar5 + pin->Y;
      l.Point2.X = l.Point1.X;
      pPVar3 = LinePoly(&l,thick);
      iVar6 = pin->X;
      pPVar7->f = pPVar3;
      pPVar3->b = pPVar7;
      l.Point1.X = iVar6 - iVar5;
      l.Point1.Y = pin->Y - iVar4;
      l.Point2.X = iVar5 + iVar6;
      l.Point2.Y = l.Point1.Y;
      pPVar3 = LinePoly(&l,thick);
      pPVar7->f->f = pPVar3;
      pPVar3->b = pPVar7->f;
      l.Point1.X = pin->X - iVar4;
      l.Point1.Y = pin->Y - iVar5;
      l.Point2.Y = iVar5 + pin->Y;
      l.Point2.X = l.Point1.X;
      pPVar2 = LinePoly(&l,thick);
      pPVar7->f->f->f = pPVar2;
      pPVar3 = pPVar7->f->f;
      pPVar2->f = pPVar7;
      pPVar2->b = pPVar3;
      pPVar7->b = pPVar2;
      goto LAB_080d0502;
    }
    iVar5 = pin->Clearance;
    thick = (int)ROUND((float)iVar5 * (float)pcb->ThermScale * 0.50000000);
    iVar6 = pin->Thickness;
    iVar4 = thick * 2;
    if (style != 5) {
      iVar4 = thick;
    }
    thick = iVar6 / 2;
    v[0] = thick + pin->X;
    v[1] = thick + pin->Y;
    contour = poly_NewContour(v);
    if (contour != (PLINE *)0x0) {
      v[1] = iVar4 + pin->Y;
      iVar5 = (iVar6 + iVar5) / 2;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      if (style == 2) {
        v[0] = iVar5 + pin->X;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
      }
      else {
        iVar6 = pin->Clearance;
        if (iVar6 < 0) {
          iVar6 = iVar6 + 3;
        }
        frac_circle(contour,(iVar6 >> 2) + v[0],v[1],v,2);
      }
      v[1] = thick + pin->Y;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      frac_circle(contour,thick + pin->X,thick + pin->Y,v,4);
      v[0] = iVar4 + pin->X;
      node = poly_CreateNode(v);
      poly_InclVertex((contour->head).prev,node);
      if (style == 2) {
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        v[1] = thick + pin->Y;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
      }
      else {
        iVar6 = pin->Clearance;
        if (iVar6 < 0) {
          iVar6 = iVar6 + 3;
        }
        frac_circle(contour,v[0],v[1] - (iVar6 >> 2),v,2);
      }
      pPVar7 = ContourToPoly(contour);
      v[0] = thick + pin->X;
      v[1] = pin->Y - iVar4;
      contour = poly_NewContour(v);
      if (contour != (PLINE *)0x0) {
        v[1] = pin->Y - thick;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        v[0] = iVar4 + pin->X;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        if (style == 2) {
          v[1] = pin->Y - iVar5;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
        }
        else {
          iVar6 = pin->Clearance;
          if (iVar6 < 0) {
            iVar6 = iVar6 + 3;
          }
          frac_circle(contour,v[0],v[1] - (iVar6 >> 2),v,2);
        }
        v[0] = thick + pin->X;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        frac_circle(contour,thick + pin->X,pin->Y - thick,v,4);
        v[1] = pin->Y - iVar4;
        node = poly_CreateNode(v);
        poly_InclVertex((contour->head).prev,node);
        if (style == 5) {
          iVar6 = pin->Clearance;
          if (iVar6 < 0) {
            iVar6 = iVar6 + 3;
          }
          frac_circle(contour,v[0] - (iVar6 >> 2),v[1],v,2);
        }
        pPVar3 = ContourToPoly(contour);
        pPVar7->f = pPVar3;
        pPVar3->b = pPVar7;
        v[0] = pin->X - iVar4;
        v[1] = pin->Y - thick;
        contour = poly_NewContour(v);
        if (contour != (PLINE *)0x0) {
          v[0] = pin->X - thick;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          v[1] = pin->Y - iVar4;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          if (style == 2) {
            v[0] = pin->X - iVar5;
            node = poly_CreateNode(v);
            poly_InclVertex((contour->head).prev,node);
          }
          else {
            iVar6 = pin->Clearance;
            if (iVar6 < 0) {
              iVar6 = iVar6 + 3;
            }
            frac_circle(contour,v[0] - (iVar6 >> 2),v[1],v,2);
          }
          v[1] = pin->Y - thick;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          frac_circle(contour,pin->X - thick,pin->Y - thick,v,4);
          v[0] = pin->X - iVar4;
          node = poly_CreateNode(v);
          poly_InclVertex((contour->head).prev,node);
          if (style == 5) {
            frac_circle(contour,v[0],pin->Clearance / 4 + v[1],v,2);
          }
          pPVar3 = ContourToPoly(contour);
          pPVar7->f->f = pPVar3;
          pPVar3->b = pPVar7->f;
          v[1] = iVar5 + pin->Y;
          v[0] = pin->X - iVar4;
          contour = poly_NewContour(v);
          if (contour != (PLINE *)0x0) {
            v[0] = pin->X - thick;
            node = poly_CreateNode(v);
            poly_InclVertex((contour->head).prev,node);
            frac_circle(contour,pin->X - thick,thick + pin->Y,v,4);
            v[1] = iVar4 + pin->Y;
            node = poly_CreateNode(v);
            poly_InclVertex((contour->head).prev,node);
            if (style == 2) {
              v[0] = pin->X - thick;
              node = poly_CreateNode(v);
              poly_InclVertex((contour->head).prev,node);
              v[1] = thick + pin->Y;
              node = poly_CreateNode(v);
              poly_InclVertex((contour->head).prev,node);
              v[0] = pin->X - iVar4;
              node = poly_CreateNode(v);
              poly_InclVertex((contour->head).prev,node);
            }
            else {
              iVar5 = pin->Clearance;
              if (iVar5 < 0) {
                iVar5 = iVar5 + 3;
              }
              frac_circle(contour,(iVar5 >> 2) + v[0],v[1],v,2);
              v[1] = thick + pin->Y;
              node = poly_CreateNode(v);
              poly_InclVertex((contour->head).prev,node);
              v[0] = pin->X - iVar4;
              node = poly_CreateNode(v);
              poly_InclVertex((contour->head).prev,node);
              if (style == 5) {
                frac_circle(contour,v[0],pin->Clearance / 4 + v[1],v,2);
              }
            }
            goto LAB_080d103b;
          }
        }
      }
    }
  }
  pPVar7 = (POLYAREA *)0x0;
LAB_080d0502:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pPVar7;
}



POLYAREA * ThermPoly(PCBTypePtr p,PinTypePtr *pin,Cardinal laynum)

{
  int iVar1;
  POLYAREA *pPVar2;
  POLYAREA *bi;
  POLYAREA *pPVar3;
  uint uVar4;
  uint uVar5;
  uint style;
  int w;
  int radius;
  int in_GS_OFFSET;
  ulong local_8c;
  undefined4 local_88;
  undefined4 local_84;
  POLYAREA *local_74;
  POLYAREA *local_70;
  POLYAREA *local_6c;
  POLYAREA *local_68;
  ArcType a;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  style = (int)(uint)(pin->Flags).t[laynum >> 1] >> (sbyte)((laynum & 1) << 2) & 0xf;
  if (style != 3) {
    uVar5 = (pin->Flags).f;
    pcb = p;
    if ((uVar5 & 0x100) != 0) {
      bi = square_therm(pin,style);
      goto LAB_080d1423;
    }
    uVar5 = uVar5 & 0x800;
    if (uVar5 != 0) {
      radius = pin->Clearance + pin->Thickness;
      w = (int)ROUND((float)pin->Clearance * (float)p->ThermScale * 0.50000000);
      local_6c = OctagonPoly(pin->X,pin->Y,radius);
      local_70 = OctagonPoly(pin->X,pin->Y,pin->Thickness);
      poly_Boolean_free(local_6c,local_70,&local_74,2);
      if (style == 2) {
        local_6c = RectPoly(pin->X - w,w + pin->X,pin->Y - radius,radius + pin->Y);
        poly_Boolean_free(local_74,local_6c,&local_70,2);
        local_6c = RectPoly(pin->X - radius,radius + pin->X,pin->Y - w,w + pin->Y);
      }
      else {
        if (style == 5) {
          w = pin->Thickness;
          local_6c = square_therm(pin,5);
          w = w / 2;
          bi = RectPoly(pin->X - w,w + pin->X,pin->Y - w,w + pin->Y);
          poly_Boolean_free(local_6c,bi,&local_70,0);
          poly_Boolean_free(local_74,local_70,&local_6c,1);
          bi = local_6c;
          goto LAB_080d1423;
        }
        local_6c = diag_line(pin->X,pin->Y,radius,w,'\x01');
        poly_Boolean_free(local_74,local_6c,&local_70,2);
        local_6c = diag_line(pin->X,pin->Y,radius,w,'\0');
      }
      poly_Boolean_free(local_70,local_6c,&local_74,2);
      bi = local_74;
      goto LAB_080d1423;
    }
    if (style - 1 < 2) {
      radius = (pin->Thickness + pin->Clearance) / 2;
      w = (int)ROUND((float)pin->Clearance * (float)p->ThermScale * 0.50000000);
      bi = CirclePoly(pin->X,pin->Y,radius);
      local_68 = CirclePoly(pin->X,pin->Y,pin->Thickness / 2);
      poly_Boolean_free(bi,local_68,&local_6c,2);
      if (style == 2) {
        bi = RectPoly(pin->X - radius,radius + pin->X,pin->Y - w,w + pin->Y);
        poly_Boolean_free(local_6c,bi,&local_68,2);
        bi = RectPoly(pin->X - w,w + pin->X,pin->Y - radius,radius + pin->Y);
      }
      else {
        bi = diag_line(pin->X,pin->Y,radius,w,'\x01');
        poly_Boolean_free(local_6c,bi,&local_68,2);
        bi = diag_line(pin->X,pin->Y,radius,w,'\0');
      }
      poly_Boolean_free(local_68,bi,&local_6c,2);
      bi = local_6c;
      goto LAB_080d1423;
    }
    a.X = pin->X;
    a.Y = pin->Y;
    w = pin->Clearance;
    a.Thickness = 1;
    radius = w + 3;
    if (-1 < w) {
      radius = w;
    }
    a.Width = (radius >> 2) + pin->Thickness / 2;
    a.Clearance = w / 2;
    a.Height = a.Width;
    MakeFlags((FlagType *)&local_8c,0);
    a.Flags.f = local_8c;
    uVar4 = 0x2d;
    if (style == 4) {
      uVar4 = uVar5;
    }
    a.Flags.t._0_4_ = local_88;
    a.Flags.t._4_4_ = local_84;
    a.Delta = (long)ROUND(((pcb->ThermScale + pcb->ThermScale + 1.00000000) * (double)a.Clearance *
                          180.00000000) / ((double)a.Width * -3.14159265) + 90.00000000);
    a.StartAngle = (uVar4 + 0x5a) - a.Delta / 2;
    bi = ArcPoly(&a,a.Clearance);
    if (bi == (POLYAREA *)0x0) goto LAB_080d1423;
    a.StartAngle = a.StartAngle + 0x5a;
    pPVar3 = ArcPoly(&a,a.Clearance);
    if (pPVar3 != (POLYAREA *)0x0) {
      bi->f = pPVar3;
      pPVar3->b = bi;
      a.StartAngle = a.StartAngle + 0x5a;
      local_68 = pPVar3;
      pPVar3 = ArcPoly(&a,a.Clearance);
      if (pPVar3 != (POLYAREA *)0x0) {
        a.StartAngle = a.StartAngle + 0x5a;
        bi->f->f = pPVar3;
        pPVar3->b = bi->f;
        local_68 = pPVar3;
        pPVar3 = ArcPoly(&a,a.Clearance);
        if (pPVar3 != (POLYAREA *)0x0) {
          bi->f->f->f = pPVar3;
          pPVar2 = bi->f->f;
          pPVar3->f = bi;
          pPVar3->b = pPVar2;
          bi->b = pPVar3;
          goto LAB_080d1423;
        }
      }
    }
  }
  bi = (POLYAREA *)0x0;
LAB_080d1423:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return bi;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void RestoreUndoSerialNumber(void)

{
  Serial = SavedSerial;
  return;
}



void SaveUndoSerialNumber(void)

{
  SavedSerial = Serial;
  Bumped = '\0';
  return;
}



void LockUndo(void)

{
  Locked = '\x01';
  return;
}



void UnlockUndo(void)

{
  Locked = '\0';
  return;
}



Boolean Undoing(void)

{
  return Locked;
}



UndoListTypePtr * __regparm3 GetUndoSlot(int CommandType,int ID,int Kind)

{
  size_t limit;
  int Type;
  UndoListTypePtr *pUVar1;
  uint Size;
  void *local_28;
  void *local_24;
  void *local_20 [4];
  
  if (UndoMax <= UndoN) {
    UndoMax = UndoMax + 500;
    Size = UndoMax * 0x20;
    UndoList = (UndoListTypePtr *)MyRealloc(UndoList,Size,"AddCommandToUndoList()");
    memset(UndoList + UndoN,0,16000);
    if (limit <= Size && Size - limit != 0) {
      limit = (Size & 0xfff00000) + 0x100000;
      Message("Size of \'undo-list\' exceeds %li kb\n",Size >> 10);
    }
  }
  pUVar1 = UndoList + UndoN;
  if (RedoN != 0) {
    while( true ) {
      if (pUVar1->Type == 1) {
        SaveFree(*(void **)pUVar1->Data);
      }
      else {
        if ((pUVar1->Type == 4) &&
           (Type = SearchObjectByID(RemoveList,local_20,&local_24,&local_28,pUVar1->ID,pUVar1->Kind)
           , Type != 0)) {
          DestroyObject(RemoveList,Type,local_20[0],local_24,local_28);
        }
      }
      RedoN = RedoN - 1;
      if (RedoN == 0) break;
      pUVar1 = pUVar1 + 1;
    }
    pUVar1 = UndoList + UndoN;
  }
  UndoN = UndoN + 1;
  pUVar1->Type = CommandType;
  pUVar1->Kind = Kind;
  pUVar1->ID = ID;
  pUVar1->Serial = Serial;
  return pUVar1;
}



void AddLayerChangeToUndoList(int old_index,int new_index)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(0x8000,0,0);
  *(int *)pUVar1->Data = old_index;
  *(int *)(pUVar1->Data + 4) = new_index;
  return;
}



void AddObjectToChangeAnglesUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked == '\0') {
    pUVar1 = GetUndoSlot(0x4000,*(int *)((int)Ptr3 + 0x10),Type);
    *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)Ptr3 + 0x3c);
    *(undefined4 *)(pUVar1->Data + 4) = *(undefined4 *)((int)Ptr3 + 0x40);
  }
  return;
}



void AddObjectTo2ndSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr *pUVar1;
  
  if ((Locked == '\0') &&
     ((pUVar1 = GetUndoSlot(0x400,*(int *)((int)ptr2 + 0x10),Type), Type == 1 || (Type == 0x100))))
  {
    *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)ptr2 + 0x30);
    return;
  }
  return;
}



void AddObjectToMaskSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(0x2000,*(int *)((int)ptr2 + 0x10),Type);
  if (Type != 0x100) {
    if (Type == 0x200) {
      *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)ptr2 + 0x54);
      return;
    }
    if (Type != 1) {
      return;
    }
  }
  *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)ptr2 + 0x2c);
  return;
}



void AddObjectToClearSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(0x1000,*(int *)((int)ptr2 + 0x10),Type);
  if (Type != 0x100) {
    if (Type < 0x101) {
      if ((Type != 1) && (Type != 4)) {
        return;
      }
    }
    else {
      if ((Type != 0x200) && (Type != 0x4000)) {
        return;
      }
    }
  }
  *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)ptr2 + 0x28);
  return;
}



void AddObjectToSizeUndoList(int Type,void *ptr1,void *ptr2,void *ptr3)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(0x200,*(int *)((int)ptr2 + 0x10),Type);
  if (Type != 0x200) {
    if (Type < 0x201) {
      if (Type != 4) {
        if (Type < 5) {
          if (Type != 1) {
            return;
          }
        }
        else {
          if ((Type != 0x10) && (Type != 0x100)) {
            return;
          }
        }
      }
    }
    else {
      if (Type != 0x2000) {
        if (Type < 0x2001) {
          if (Type != 0x400) {
            return;
          }
        }
        else {
          if ((Type != 0x4000) && (Type != 0x8000)) {
            return;
          }
        }
      }
    }
  }
  *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)ptr2 + 0x24);
  return;
}



void AddObjectToFlagUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked == '\0') {
    pUVar1 = GetUndoSlot(0x100,*(int *)((int)Ptr2 + 0x10),Type);
    *(undefined4 *)pUVar1->Data = *(undefined4 *)((int)Ptr2 + 0x14);
    *(undefined4 *)(pUVar1->Data + 4) = *(undefined4 *)((int)Ptr2 + 0x18);
    *(undefined4 *)(pUVar1->Data + 8) = *(undefined4 *)((int)Ptr2 + 0x1c);
  }
  return;
}



void AddObjectToChangeNameUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3,char *OldName)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(1,*(int *)((int)Ptr3 + 0x10),Type);
  *(char **)pUVar1->Data = OldName;
  return;
}



void AddObjectToMoveUndoList
               (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType DX,LocationType DY)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(2,*(int *)((int)Ptr3 + 0x10),Type);
  *(LocationType *)pUVar1->Data = DX;
  *(LocationType *)(pUVar1->Data + 4) = DY;
  return;
}



void AddObjectToInsertPointUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Locked != '\0') {
    return;
  }
  GetUndoSlot(0x10,*(int *)((int)Ptr3 + 0x10),Type);
  return;
}



void AddObjectToRemovePointUndoList(int Type,void *Ptr1,void *Ptr2,Cardinal index)

{
  undefined4 uVar1;
  UndoListTypePtr *pUVar2;
  undefined4 *puVar3;
  
  if ((Locked == '\0') && (Type == 0x800)) {
    pUVar2 = GetUndoSlot(8,*(int *)((int)Ptr2 + 0x10),8);
    puVar3 = (undefined4 *)(index * 0x14 + *(int *)((int)Ptr2 + 0x38));
    *(undefined4 *)pUVar2->Data = *puVar3;
    *(undefined4 *)(pUVar2->Data + 4) = puVar3[1];
    uVar1 = puVar3[4];
    *(Cardinal *)(pUVar2->Data + 0xc) = index;
    *(undefined4 *)(pUVar2->Data + 8) = uVar1;
    return;
  }
  return;
}



void AddObjectToRotateUndoList
               (int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType CenterX,LocationType CenterY,
               BYTE Steps)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked == '\0') {
    pUVar1 = GetUndoSlot(0x20,*(int *)((int)Ptr3 + 0x10),Type);
    *(LocationType *)pUVar1->Data = CenterX;
    pUVar1->Data[8] = Steps;
    *(LocationType *)(pUVar1->Data + 4) = CenterY;
  }
  return;
}



void AddObjectToMirrorUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3,LocationType yoff)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked != '\0') {
    return;
  }
  pUVar1 = GetUndoSlot(0x800,*(int *)((int)Ptr3 + 0x10),Type);
  *(LocationType *)(pUVar1->Data + 4) = yoff;
  return;
}



void AddObjectToClearPolyUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3,Boolean clear)

{
  UndoListTypePtr *pUVar1;
  
  if (Locked == '\0') {
    pUVar1 = GetUndoSlot(0x10000,*(int *)((int)Ptr3 + 0x10),Type);
    pUVar1->Data[0] = clear;
    *(void **)(pUVar1->Data + 4) = Ptr1;
  }
  return;
}



void AddNetlistLibToUndoList(LibraryTypePtr lib)

{
  Cardinal CVar1;
  char "AddNetlistLibToUndoList" [24];
  UndoListTypePtr *pUVar2;
  Cardinal *pCVar3;
  void *pvVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  LibraryMenuTypePtr *pLVar8;
  int iVar9;
  int iVar10;
  void *pvVar11;
  Cardinal CVar12;
  uint local_2c;
  uint local_28;
  
  if (Locked == '\0') {
    pUVar2 = GetUndoSlot(0x20000,0,0);
    *(LibraryTypePtr *)(pUVar2->Data + 4) = lib;
    pCVar3 = (Cardinal *)calloc(1,4);
    *(Cardinal **)pUVar2->Data = pCVar3;
    *pCVar3 = lib->MenuN;
    CVar1 = lib->MenuMax;
    pCVar3[1] = CVar1;
    pvVar4 = calloc(1,CVar1 * 0x1c);
    *(void **)(pCVar3 + 2) = pvVar4;
    if (pvVar4 == (void *)0x0) {
LAB_080d2266:
      __fprintf_chk(stderr,1,"malloc() failed in %s\n","AddNetlistLibToUndoList");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    if (lib->MenuN != 0) {
      iVar10 = 0;
      local_2c = 0;
      while( true ) {
        pLVar8 = lib->Menu;
        *(undefined4 *)((int)pvVar4 + iVar10 + 0xc) = *(undefined4 *)((int)&pLVar8->EntryN + iVar10)
        ;
        iVar7 = *(int *)((int)&pLVar8->Name + iVar10);
        *(undefined4 *)((int)pvVar4 + iVar10 + 0x10) =
             *(undefined4 *)((int)&pLVar8->EntryMax + iVar10);
        uVar5 = 0;
        pvVar11 = pvVar4;
        if (iVar7 != 0) {
          uVar5 = __strdup(iVar7);
          pLVar8 = lib->Menu;
          pvVar11 = (void *)pCVar3[2];
        }
        iVar7 = *(int *)((int)&pLVar8->directory + iVar10);
        *(undefined4 *)((int)pvVar4 + iVar10) = uVar5;
        uVar5 = 0;
        pvVar4 = pvVar11;
        if (iVar7 != 0) {
          uVar5 = __strdup(iVar7);
          pLVar8 = lib->Menu;
          pvVar4 = (void *)pCVar3[2];
        }
        iVar7 = *(int *)((int)&pLVar8->Style + iVar10);
        *(undefined4 *)((int)pvVar11 + iVar10 + 4) = uVar5;
        uVar5 = 0;
        if (iVar7 != 0) {
          uVar5 = __strdup(iVar7);
        }
        *(undefined4 *)((int)pvVar4 + iVar10 + 8) = uVar5;
        CVar1 = pCVar3[2];
        pvVar4 = calloc(1,*(int *)(CVar1 + iVar10 + 0x10) * 0x18);
        CVar12 = pCVar3[2];
        *(void **)(CVar1 + iVar10 + 0x14) = pvVar4;
        iVar7 = *(int *)(CVar12 + 0x14 + iVar10);
        if (iVar7 == 0) goto LAB_080d2266;
        iVar9 = 0;
        local_28 = 0;
        iVar6 = (int)&lib->Menu->Name + iVar10;
        if (*(int *)(iVar6 + 0xc) != 0) {
          while( true ) {
            iVar6 = *(int *)(*(int *)(iVar6 + 0x14) + iVar9);
            uVar5 = 0;
            if (iVar6 != 0) {
              uVar5 = __strdup(iVar6);
              CVar12 = pCVar3[2];
            }
            *(undefined4 *)(iVar7 + iVar9) = uVar5;
            iVar7 = *(int *)(CVar12 + 0x14 + iVar10);
            pLVar8 = lib->Menu;
            iVar6 = *(int *)(*(int *)((int)&pLVar8->Entry + iVar10) + 4 + iVar9);
            uVar5 = 0;
            if (iVar6 != 0) {
              uVar5 = __strdup(iVar6);
              pLVar8 = lib->Menu;
              CVar12 = pCVar3[2];
            }
            *(undefined4 *)(iVar7 + 4 + iVar9) = uVar5;
            iVar7 = *(int *)(CVar12 + 0x14 + iVar10);
            iVar6 = *(int *)(*(int *)((int)&pLVar8->Entry + iVar10) + 8 + iVar9);
            uVar5 = 0;
            if (iVar6 != 0) {
              uVar5 = __strdup(iVar6);
              pLVar8 = lib->Menu;
              CVar12 = pCVar3[2];
            }
            *(undefined4 *)(iVar7 + 8 + iVar9) = uVar5;
            iVar7 = *(int *)(CVar12 + 0x14 + iVar10);
            iVar6 = *(int *)(*(int *)((int)&pLVar8->Entry + iVar10) + 0xc + iVar9);
            uVar5 = 0;
            if (iVar6 != 0) {
              uVar5 = __strdup(iVar6);
              pLVar8 = lib->Menu;
              CVar12 = pCVar3[2];
            }
            *(undefined4 *)(iVar7 + 0xc + iVar9) = uVar5;
            iVar7 = *(int *)(CVar12 + 0x14 + iVar10);
            iVar6 = *(int *)(*(int *)((int)&pLVar8->Entry + iVar10) + 0x10 + iVar9);
            uVar5 = 0;
            if (iVar6 != 0) {
              uVar5 = __strdup(iVar6);
              pLVar8 = lib->Menu;
              CVar12 = pCVar3[2];
            }
            iVar6 = *(int *)(CVar12 + 0x14 + iVar10);
            *(undefined4 *)(iVar7 + 0x10 + iVar9) = uVar5;
            iVar7 = *(int *)(*(int *)((int)&pLVar8->Entry + iVar10) + 0x14 + iVar9);
            uVar5 = 0;
            if (iVar7 != 0) {
              uVar5 = __strdup(iVar7);
            }
            *(undefined4 *)(iVar6 + 0x14 + iVar9) = uVar5;
            iVar9 = iVar9 + 0x18;
            local_28 = local_28 + 1;
            iVar6 = (int)&lib->Menu->Name + iVar10;
            if (*(uint *)(iVar6 + 0xc) < local_28 || *(uint *)(iVar6 + 0xc) == local_28) break;
            CVar12 = pCVar3[2];
            iVar7 = *(int *)(CVar12 + 0x14 + iVar10);
          }
        }
        iVar10 = iVar10 + 0x1c;
        local_2c = local_2c + 1;
        if (lib->MenuN < local_2c || lib->MenuN == local_2c) break;
        pvVar4 = (void *)pCVar3[2];
      }
    }
  }
  return;
}



void AddObjectToCreateUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Locked == '\0') {
    GetUndoSlot(0x40,*(int *)((int)Ptr3 + 0x10),Type);
  }
  ClearFromPolygon((DataType *)PCB->Data,Type,Ptr1,Ptr2);
  return;
}



void AddObjectToMoveToLayerUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  UndoListTypePtr *pUVar1;
  int iVar2;
  
  if (Locked == '\0') {
    pUVar1 = GetUndoSlot(0x80,*(int *)((int)Ptr3 + 0x10),Type);
    iVar2 = GetLayerNumber(PCB->Data,(LayerTypePtr)Ptr1);
    *(int *)pUVar1->Data = iVar2;
  }
  return;
}



void MoveObjectToRemoveUndoList(int Type,void *Ptr1,void *Ptr2,void *Ptr3)

{
  if (Locked == '\0') {
    if (RemoveList == (DataTypePtr *)0x0) {
      RemoveList = CreateNewBuffer();
    }
    GetUndoSlot(4,*(int *)((int)Ptr3 + 0x10),Type);
    MoveObjectToBuffer(RemoveList,PCB->Data,Type,Ptr1,Ptr2,Ptr3);
  }
  return;
}



void ClearUndoList(Boolean Force)

{
  int iVar1;
  UndoListTypePtr *pUVar2;
  
  if (UndoN == 0) {
    Serial = 1;
    return;
  }
  pUVar2 = UndoList;
  if (Force == '\0') {
    iVar1 = (*gui->confirm_dialog)("OK to clear \'undo\' buffer?",0);
    if (iVar1 == 0) {
      Serial = 1;
      return;
    }
    pUVar2 = UndoList;
    if (UndoN == 0) goto LAB_080d242e;
  }
  while( true ) {
    if (pUVar2->Type == 1) {
      SaveFree(*(void **)pUVar2->Data);
    }
    UndoN = UndoN - 1;
    if (UndoN == 0) break;
    pUVar2 = pUVar2 + 1;
  }
LAB_080d242e:
  SaveFree(UndoList);
  UndoList = (UndoListTypePtr *)0x0;
  if (RemoveList != (DataTypePtr *)0x0) {
    FreeDataMemory(RemoveList);
    free(RemoveList);
    RemoveList = (DataTypePtr *)0x0;
  }
  Serial = 1;
  UndoN = 0;
  RedoN = 0;
  UndoMax = 0;
  return;
}



void IncrementUndoSerialNumber(void)

{
  if (((Locked == '\0') && (UndoN != 0)) && (UndoList[UndoN - 1].Serial == Serial)) {
    Serial = UndoList[UndoN - 1].Serial + 1;
    Bumped = '\x01';
    SetChangedFlag('\x01');
    return;
  }
  return;
}



int __regparm3 PerformUndo(UndoListTypePtr *ptr)

{
  int iVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  uint *puVar10;
  uint *puVar11;
  LocationType LVar12;
  DataTypePtr *pDVar13;
  undefined4 uVar14;
  PointTypePtr pPVar15;
  PointTypePtr pPVar16;
  PointTypePtr pPVar17;
  void *ptr2_00;
  uint type;
  int iVar18;
  void **ppvVar19;
  int old_index;
  int type_00;
  FlagType *pFVar20;
  undefined4 uVar21;
  FlagType *pFVar22;
  int in_GS_OFFSET;
  bool bVar23;
  byte bVar24;
  void *local_90;
  uint local_7c;
  void *local_78;
  ulong local_6c;
  undefined4 local_68;
  undefined4 local_64;
  void *ptr1;
  void *ptr2;
  void *ptr3;
  PointTypePtr local_44;
  PolygonTypePtr local_40;
  LayerTypePtr local_3c;
  FlagType f2;
  FlagType f1;
  
  bVar24 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  type_00 = ptr->Type;
  if (type_00 == 0x100) {
    type_00 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
    ptr2_00 = ptr2;
    if (type_00 == 0) {
      Message("hace Internal error: Can\'t find ID %d type %08x\n");
      flags_to_string(*(FlagType *)ptr->Data,0);
      Message("for UndoFlag Operation. Previous flags: %s\n");
      old_index = 0;
      goto LAB_080d27c2;
    }
    type = *(uint *)((int)ptr2 + 0x14);
    if ((type & 0x2000) == 0) {
      bVar2 = *(byte *)((int)ptr2 + 0x1f);
      bVar3 = *(byte *)((int)ptr2 + 0x1e);
      bVar4 = *(byte *)((int)ptr2 + 0x1d);
      bVar5 = *(byte *)((int)ptr2 + 0x1c);
      bVar6 = *(byte *)((int)ptr2 + 0x1b);
      bVar7 = *(byte *)((int)ptr2 + 0x1a);
      bVar8 = *(byte *)((int)ptr2 + 0x19);
      bVar9 = *(byte *)((int)ptr2 + 0x18);
      MaskFlags((FlagType *)&local_6c,*(FlagType *)((int)ptr2 + 0x14),0xfffff683);
      f1.f = local_6c;
      f1.t._0_4_ = local_68;
      f1.t._4_4_ = local_64;
      MaskFlags((FlagType *)&local_6c,*(FlagType *)ptr->Data,0xfffff683);
      old_index = 0xc;
      f2.f = local_6c;
      bVar23 = (undefined *)register0x00000010 == (undefined *)0xbc;
      f2.t._0_4_ = local_68;
      f2.t._4_4_ = local_64;
      pFVar20 = &f1;
      pFVar22 = &f2;
      do {
        if (old_index == 0) break;
        old_index = old_index + -1;
        bVar23 = *(char *)&pFVar20->f == *(char *)&pFVar22->f;
        pFVar20 = (FlagType *)((int)pFVar20 + (uint)bVar24 * -2 + 1);
        pFVar22 = (FlagType *)((int)pFVar22 + (uint)bVar24 * -2 + 1);
      } while (bVar23);
      if (bVar23) {
        *(undefined4 *)((int)ptr2_00 + 0x14) = *(undefined4 *)ptr->Data;
        *(undefined4 *)((int)ptr2_00 + 0x18) = *(undefined4 *)(ptr->Data + 4);
        *(undefined4 *)((int)ptr2_00 + 0x1c) = *(undefined4 *)(ptr->Data + 8);
        ptr->Data[0xb] = bVar2;
        ptr->Data[10] = bVar3;
        ptr->Data[9] = bVar4;
        ptr->Data[8] = bVar5;
        ptr->Data[7] = bVar6;
        ptr->Data[6] = bVar7;
        ptr->Data[5] = bVar8;
        old_index = 0x100;
        ptr->Data[4] = bVar9;
        *(uint *)ptr->Data = type;
      }
      else {
        if (andDraw != '\0') {
          EraseObject(type_00,ptr1,ptr2);
        }
        *(undefined4 *)((int)ptr2_00 + 0x14) = *(undefined4 *)ptr->Data;
        *(undefined4 *)((int)ptr2_00 + 0x18) = *(undefined4 *)(ptr->Data + 4);
        *(undefined4 *)((int)ptr2_00 + 0x1c) = *(undefined4 *)(ptr->Data + 8);
        ptr->Data[0xb] = bVar2;
        ptr->Data[10] = bVar3;
        ptr->Data[9] = bVar4;
        ptr->Data[8] = bVar5;
        ptr->Data[7] = bVar6;
        ptr->Data[6] = bVar7;
        ptr->Data[5] = bVar8;
        ptr->Data[4] = bVar9;
        old_index = 0x100;
        *(uint *)ptr->Data = type;
        if (andDraw != '\0') {
          DrawObject(type_00,ptr1,ptr2,0);
          old_index = 0x100;
        }
      }
      goto LAB_080d27c2;
    }
  }
  else {
    if (type_00 < 0x101) {
      if (type_00 == 8) {
        type_00 = SearchObjectByID(PCB->Data,&local_3c,&local_40,&ptr3,ptr->ID,ptr->Kind);
        if ((type_00 == 8) && ((*(byte *)((int)&(local_40->Flags).f + 1) & 0x20) == 0)) {
          if ((andDraw != '\0') && (local_3c->On != '\0')) {
            ErasePolygon(local_40);
          }
          InsertPointIntoObject
                    (8,local_3c,local_40,(Cardinal *)(ptr->Data + 0xc),*(LocationType *)ptr->Data,
                     *(LocationType *)(ptr->Data + 4),'\x01');
          bVar23 = andDraw != '\0';
          local_40->Points[*(int *)(ptr->Data + 0xc)].ID = *(long *)(ptr->Data + 8);
          if ((bVar23) && (local_3c->On != '\0')) {
            DrawPolygon(local_3c,local_40,0);
          }
          type_00 = *(int *)(ptr->Data + 8);
          ptr->Type = 0x10;
          ptr->Kind = 0x800;
          ptr->ID = type_00;
          old_index = 8;
          goto LAB_080d27c2;
        }
      }
      else {
        if (type_00 < 9) {
          if (type_00 == 2) {
            type_00 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
            if ((type_00 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
              MoveObject(type_00,ptr1,ptr2,ptr3,-*(int *)ptr->Data,-*(int *)(ptr->Data + 4));
              old_index = 2;
              *(int *)ptr->Data = -*(int *)ptr->Data;
              *(int *)(ptr->Data + 4) = -*(int *)(ptr->Data + 4);
              goto LAB_080d27c2;
            }
          }
          else {
            if (type_00 == 4) {
              type = SearchObjectByID(RemoveList,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
              ptr2_00 = ptr2;
              if (type != 0) {
                if (andDraw != '\0') {
                  if ((type & 0x401c) == 0) {
                    DrawObject(type,ptr3,ptr2,0);
                  }
                  else {
                    pDVar13 = PCB->Data;
                    type_00 = GetLayerNumber(RemoveList,(LayerTypePtr)ptr3);
                    DrawObject(type,(void *)(&pDVar13->field_0x4c + type_00 * 0x5c),ptr2_00,0);
                  }
                }
                MoveObjectToBuffer(PCB->Data,RemoveList,type,ptr3,ptr2,ptr1);
                old_index = 4;
                ptr->Type = 0x40;
                goto LAB_080d27c2;
              }
            }
            else {
              if (((type_00 == 1) &&
                  (type_00 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind),
                  type_00 != 0)) && ((*(byte *)((int)ptr3 + 0x15) & 0x20) == 0)) {
                ptr2_00 = ChangeObjectName(type_00,ptr1,ptr2,ptr3,*(char **)ptr->Data);
                *(void **)ptr->Data = ptr2_00;
                old_index = 1;
                goto LAB_080d27c2;
              }
            }
          }
        }
        else {
          if (type_00 == 0x20) {
            type_00 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
            if ((type_00 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
              RotateObject(type_00,ptr3,ptr2,ptr1,*(LocationType *)ptr->Data,
                           *(LocationType *)(ptr->Data + 4),4 - ptr->Data[8] & 3);
              ptr->Data[8] = 4 - ptr->Data[8] & 3;
              old_index = 0x20;
              goto LAB_080d27c2;
            }
          }
          else {
            if (type_00 < 0x21) {
              if (((type_00 == 0x10) &&
                  (type_00 = SearchObjectByID(PCB->Data,&local_3c,&local_40,&local_44,ptr->ID,
                                              ptr->Kind), type_00 == 0x800)) &&
                 ((*(byte *)((int)&(local_40->Flags).f + 1) & 0x20) == 0)) {
                if ((andDraw != '\0') && (local_3c->On != '\0')) {
                  ErasePolygon(local_40);
                }
                *(LocationType *)ptr->Data = local_44->X;
                LVar12 = local_44->Y;
                ptr->Kind = 8;
                ptr->Type = 8;
                *(LocationType *)(ptr->Data + 4) = LVar12;
                *(long *)(ptr->Data + 8) = local_44->ID;
                ptr->ID = local_40->ID;
                type_00 = local_40->PointN - 1;
                if (type_00 != -1) {
                  pPVar17 = local_40->Points + (local_40->PointN - 2);
                  pPVar16 = local_40->Points + type_00;
                  while (pPVar15 = pPVar17, pPVar16 != local_44) {
                    type_00 = type_00 + -1;
                    if (type_00 == -1) goto LAB_080d29ee;
                    pPVar17 = pPVar15 + -1;
                    pPVar16 = pPVar15;
                  }
                  *(int *)(ptr->Data + 0xc) = type_00;
                }
LAB_080d29ee:
                DestroyObject(PCB->Data,0x800,local_3c,local_40,local_44);
                if ((andDraw == '\0') || (local_3c->On == '\0')) {
                  old_index = 0x10;
                }
                else {
                  DrawPolygon(local_3c,local_40,0);
                  old_index = 0x10;
                }
                goto LAB_080d27c2;
              }
            }
            else {
              if (type_00 == 0x40) {
                type_00 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
                if ((type_00 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
                  if (RemoveList == (DataTypePtr *)0x0) {
                    RemoveList = CreateNewBuffer();
                  }
                  if (andDraw != '\0') {
                    EraseObject(type_00,ptr3,ptr2);
                  }
                  MoveObjectToBuffer(RemoveList,PCB->Data,type_00,ptr3,ptr2,ptr1);
                  old_index = 0x40;
                  ptr->Type = 4;
                  goto LAB_080d27c2;
                }
              }
              else {
                if (((type_00 == 0x80) &&
                    (type_00 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind),
                    type_00 != 0)) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
                  iVar18 = GetLayerNumber(PCB->Data,(LayerTypePtr)ptr3);
                  MoveObjectToLayer(type_00,ptr3,ptr2,ptr1,
                                    (LayerTypePtr)
                                    (&PCB->Data->field_0x4c + *(int *)ptr->Data * 0x5c),'\x01');
                  old_index = 0x80;
                  *(int *)ptr->Data = iVar18;
                  goto LAB_080d27c2;
                }
              }
            }
          }
        }
      }
    }
    else {
      if (type_00 == 0x2000) {
        type = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
        if (((type & 0x301) != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
          if (type == 0x200) {
            uVar21 = *(undefined4 *)((int)ptr2 + 0x54);
          }
          else {
            uVar21 = *(undefined4 *)((int)ptr2 + 0x2c);
          }
          if (andDraw != '\0') {
            EraseObject(type,ptr1,ptr2);
          }
          if (type == 0x200) {
            *(undefined4 *)((int)ptr2 + 0x54) = *(undefined4 *)ptr->Data;
          }
          else {
            *(undefined4 *)((int)ptr2 + 0x2c) = *(undefined4 *)ptr->Data;
          }
          *(undefined4 *)ptr->Data = uVar21;
          old_index = 0x2000;
          if (andDraw != '\0') {
            DrawObject(type,ptr1,ptr2,0);
            old_index = 0x2000;
          }
          goto LAB_080d27c2;
        }
      }
      else {
        if (type_00 < 0x2001) {
          if (type_00 == 0x400) {
            type_00 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind);
            if ((type_00 != 0) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
              uVar21 = *(undefined4 *)((int)ptr2 + 0x30);
              if (andDraw != '\0') {
                EraseObject(type_00,ptr3,ptr2);
              }
              *(undefined4 *)((int)ptr2 + 0x30) = *(undefined4 *)ptr->Data;
              *(undefined4 *)ptr->Data = uVar21;
              DrawObject(type_00,ptr3,ptr2,0);
              old_index = 0x400;
              goto LAB_080d27c2;
            }
          }
          else {
            if (type_00 < 0x401) {
              if (((type_00 == 0x200) &&
                  (type_00 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind),
                  type_00 != 0)) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
                uVar21 = *(undefined4 *)((int)ptr2 + 0x24);
                RestoreToPolygon((DataType *)PCB->Data,type_00,ptr3,ptr2);
                if (andDraw != '\0') {
                  EraseObject(type_00,ptr3,ptr2);
                }
                *(undefined4 *)((int)ptr2 + 0x24) = *(undefined4 *)ptr->Data;
                *(undefined4 *)ptr->Data = uVar21;
                ClearFromPolygon((DataType *)PCB->Data,type_00,ptr3,ptr2);
                old_index = 0x200;
                if (andDraw != '\0') {
                  DrawObject(type_00,ptr3,ptr2,0);
                  old_index = 0x200;
                }
                goto LAB_080d27c2;
              }
            }
            else {
              if (type_00 == 0x800) {
                type_00 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
                if (type_00 != 2) {
                  Message("hace Internal error: UndoMirror on object type %d\n");
                  old_index = 0;
                  goto LAB_080d27c2;
                }
                if ((*(byte *)((int)ptr3 + 0x15) & 0x20) == 0) {
                  if (andDraw != '\0') {
                    EraseElement((ElementTypePtr *)ptr3);
                  }
                  MirrorElementCoordinates
                            (PCB->Data,(ElementTypePtr *)ptr3,*(LocationType *)(ptr->Data + 4));
                  old_index = 0x800;
                  if (andDraw != '\0') {
                    DrawElement((ElementTypePtr *)ptr3,0);
                    old_index = 0x800;
                  }
                  goto LAB_080d27c2;
                }
              }
              else {
                if (((type_00 == 0x1000) &&
                    (type_00 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind),
                    type_00 != 0)) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)) {
                  uVar21 = *(undefined4 *)((int)ptr2 + 0x28);
                  RestoreToPolygon((DataType *)PCB->Data,type_00,ptr1,ptr2);
                  if (andDraw != '\0') {
                    EraseObject(type_00,ptr1,ptr2);
                  }
                  *(undefined4 *)((int)ptr2 + 0x28) = *(undefined4 *)ptr->Data;
                  ClearFromPolygon((DataType *)PCB->Data,type_00,ptr1,ptr2);
                  old_index = 0x1000;
                  *(undefined4 *)ptr->Data = uVar21;
                  if (andDraw != '\0') {
                    DrawObject(type_00,ptr1,ptr2,0);
                    old_index = 0x1000;
                  }
                  goto LAB_080d27c2;
                }
              }
            }
          }
        }
        else {
          if (type_00 == 0x8000) {
            type_00 = *(int *)ptr->Data;
            old_index = *(int *)(ptr->Data + 4);
            *(int *)(ptr->Data + 4) = type_00;
            *(int *)ptr->Data = old_index;
            type_00 = MoveLayer(old_index,type_00);
            old_index = 0x8000;
            if (type_00 == 0) goto LAB_080d27c2;
          }
          else {
            if (type_00 < 0x8001) {
              if (((type_00 == 0x4000) &&
                  (type_00 = SearchObjectByID(PCB->Data,&ptr3,&ptr2,&ptr1,ptr->ID,ptr->Kind),
                  ptr2_00 = ptr3, type_00 == 0x4000)) && ((*(byte *)((int)ptr2 + 0x15) & 0x20) == 0)
                 ) {
                r_delete_entry(*(rtree_t **)((int)ptr3 + 0x40),(BoxType *)ptr2);
                uVar21 = *(undefined4 *)((int)ptr2 + 0x3c);
                uVar14 = *(undefined4 *)((int)ptr2 + 0x40);
                if (andDraw != '\0') {
                  EraseObject(0x4000,ptr2_00,ptr2);
                }
                *(undefined4 *)((int)ptr2 + 0x3c) = *(undefined4 *)ptr->Data;
                *(undefined4 *)((int)ptr2 + 0x40) = *(undefined4 *)(ptr->Data + 4);
                SetArcBoundingBox((ArcTypePtr *)ptr2);
                r_insert_entry(*(rtree_t **)((int)ptr2_00 + 0x40),(BoxType *)ptr2,0);
                *(undefined4 *)ptr->Data = uVar21;
                *(undefined4 *)(ptr->Data + 4) = uVar14;
                DrawObject(0x4000,ptr3,ptr2,0);
                old_index = 0x4000;
                goto LAB_080d27c2;
              }
            }
            else {
              if (type_00 == 0x10000) {
                type_00 = SearchObjectByID(PCB->Data,&ptr1,&ptr2,&ptr3,ptr->ID,ptr->Kind);
                if (type_00 != 0) {
                  if (ptr->Data[0] == 0) {
                    ClearFromPolygon((DataType *)PCB->Data,type_00,*(void **)(ptr->Data + 4),ptr3);
                  }
                  else {
                    RestoreToPolygon((DataType *)PCB->Data,type_00,*(void **)(ptr->Data + 4),ptr3);
                  }
                  old_index = 0x10000;
                  *(bool *)ptr->Data = ptr->Data[0] == 0;
                  goto LAB_080d27c2;
                }
              }
              else {
                if (type_00 == 0x20000) {
                  puVar10 = *(uint **)(ptr->Data + 4);
                  puVar11 = *(uint **)ptr->Data;
                  if (*puVar10 == 0) {
                    ptr2_00 = (void *)puVar10[2];
                  }
                  else {
                    local_7c = 0;
                    local_90 = (void *)puVar10[2];
                    type_00 = 0;
                    ptr2_00 = local_90;
                    do {
                      ppvVar19 = (void **)((int)local_90 + type_00);
                      if (*ppvVar19 != (void *)0x0) {
                        free(*ppvVar19);
                        local_90 = (void *)puVar10[2];
                        ppvVar19 = (void **)((int)local_90 + type_00);
                        ptr2_00 = local_90;
                      }
                      if (ppvVar19[1] != (void *)0x0) {
                        free(ppvVar19[1]);
                        local_90 = (void *)puVar10[2];
                        ppvVar19 = (void **)((int)local_90 + type_00);
                        ptr2_00 = local_90;
                      }
                      if (ppvVar19[2] != (void *)0x0) {
                        free(ppvVar19[2]);
                        local_90 = (void *)puVar10[2];
                        ppvVar19 = (void **)((int)local_90 + type_00);
                        ptr2_00 = local_90;
                      }
                      if (ppvVar19[3] != (void *)0x0) {
                        old_index = 0;
                        local_78 = (void *)0x0;
                        do {
                          if (*(void **)((int)ppvVar19[5] + old_index) != (void *)0x0) {
                            free(*(void **)((int)ppvVar19[5] + old_index));
                            local_90 = (void *)puVar10[2];
                          }
                          ppvVar19 = (void **)((int)local_90 + type_00);
                          iVar18 = (int)ppvVar19[5] + old_index;
                          if (*(void **)(iVar18 + 4) != (void *)0x0) {
                            free(*(void **)(iVar18 + 4));
                            local_90 = (void *)puVar10[2];
                            ppvVar19 = (void **)((int)local_90 + type_00);
                            iVar18 = (int)ppvVar19[5] + old_index;
                          }
                          if (*(void **)(iVar18 + 8) != (void *)0x0) {
                            free(*(void **)(iVar18 + 8));
                            local_90 = (void *)puVar10[2];
                            ppvVar19 = (void **)((int)local_90 + type_00);
                            iVar18 = (int)ppvVar19[5] + old_index;
                          }
                          if (*(void **)(iVar18 + 0xc) != (void *)0x0) {
                            free(*(void **)(iVar18 + 0xc));
                            local_90 = (void *)puVar10[2];
                            ppvVar19 = (void **)((int)local_90 + type_00);
                            iVar18 = (int)ppvVar19[5] + old_index;
                          }
                          if (*(void **)(iVar18 + 0x10) != (void *)0x0) {
                            free(*(void **)(iVar18 + 0x10));
                            local_90 = (void *)puVar10[2];
                            ppvVar19 = (void **)((int)local_90 + type_00);
                            iVar18 = (int)ppvVar19[5] + old_index;
                          }
                          if (*(void **)(iVar18 + 0x14) != (void *)0x0) {
                            free(*(void **)(iVar18 + 0x14));
                            local_90 = (void *)puVar10[2];
                            ppvVar19 = (void **)((int)local_90 + type_00);
                          }
                          local_78 = (void *)((int)local_78 + 1);
                          old_index = old_index + 0x18;
                          ptr2_00 = local_90;
                        } while (local_78 < ppvVar19[3]);
                      }
                      type_00 = type_00 + 0x1c;
                      local_7c = local_7c + 1;
                    } while (local_7c < *puVar10);
                  }
                  if (ptr2_00 != (void *)0x0) {
                    free(ptr2_00);
                  }
                  *puVar10 = *puVar11;
                  puVar10[1] = puVar11[1];
                  puVar10[2] = puVar11[2];
                  hid_action("NetlistChanged");
                  old_index = 0x20000;
                  goto LAB_080d27c2;
                }
              }
            }
          }
        }
      }
    }
  }
  old_index = 0;
LAB_080d27c2:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return old_index;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int Redo(Boolean draw)

{
  uint uVar1;
  UndoListTypePtr *ptr;
  uint uVar2;
  
  andDraw = draw;
  do {
    if (RedoN == 0) {
      Message("Nothing to redo. Perhaps changes have been made since last undo\n");
      return 0;
    }
    uVar2 = 0;
    Locked = '\x01';
    ptr = UndoList + UndoN;
    Serial = ptr->Serial;
    do {
      uVar1 = PerformUndo(ptr);
      UndoN = UndoN + 1;
      uVar2 = uVar2 | uVar1;
      RedoN = RedoN - 1;
      if (RedoN == 0) break;
      ptr = ptr + 1;
    } while (ptr->Serial == Serial);
    Serial = Serial + 1;
    Locked = '\0';
    if (uVar2 != 0) {
      if (andDraw != '\0') {
        Draw();
        return uVar2;
      }
      Locked = '\0';
      return uVar2;
    }
  } while( true );
}



int Undo(Boolean draw)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  UndoListTypePtr *ptr;
  uint uVar4;
  
  uVar1 = (PCB->Flags).f;
  (PCB->Flags).f = uVar1 & 0xfffffbff;
  andDraw = draw;
  do {
    if (UndoN == 0) {
      if (Serial == 0) {
        Message("Nothing to undo - buffer is empty\n");
        return 0;
      }
      Serial = Serial + -1;
      return 0;
    }
    ptr = UndoList + (UndoN - 1);
    iVar2 = ptr->Serial;
    if (iVar2 != Serial + -1) {
      Message("Undo bad serial number %d expecting %d\n",iVar2,Serial + -1);
      Serial = ptr->Serial + 1;
      return 0;
    }
    Locked = '\x01';
    uVar4 = 0;
    Serial = iVar2;
    do {
      uVar3 = PerformUndo(ptr);
      RedoN = RedoN + 1;
      uVar4 = uVar4 | uVar3;
      UndoN = UndoN - 1;
      if (UndoN == 0) break;
      ptr = ptr + -1;
    } while (ptr->Serial == Serial);
    Locked = '\0';
    if (uVar4 != 0) {
      if (andDraw != '\0') {
        Draw();
      }
      if ((uVar1 & 0x400) != 0) {
        (PCB->Flags).f = (PCB->Flags).f | 0x400;
      }
      return uVar4;
    }
  } while( true );
}



int vector_is_empty(vector_t *vector)

{
  return (uint)(vector->size == 0);
}



int vector_size(vector_t *vector)

{
  return vector->size;
}



vector_element_t vector_element(vector_t *vector,int N)

{
  return vector->element[N];
}



vector_element_t vector_element_first(vector_t *vector)

{
  return *vector->element;
}



vector_element_t vector_element_last(vector_t *vector)

{
  return vector->element[vector->size + -1];
}



vector_element_t vector_replace(vector_t *vector,vector_element_t data,int N)

{
  vector_element_t pvVar1;
  
  pvVar1 = vector->element[N];
  vector->element[N] = data;
  return pvVar1;
}



vector_element_t vector_remove(vector_t *vector,int N)

{
  vector_element_t *__dest;
  vector_element_t pvVar1;
  
  __dest = vector->element + N;
  pvVar1 = *__dest;
  memmove(__dest,vector->element + N + 1,(~N + vector->size) * 4);
  vector->size = vector->size + -1;
  return pvVar1;
}



vector_element_t vector_remove_last(vector_t *vector)

{
  vector_element_t pvVar1;
  
  pvVar1 = vector_remove(vector,vector->size + -1);
  return pvVar1;
}



void vector_insert_many(vector_t *vector,int N,vector_element_t *data,int count)

{
  int iVar1;
  vector_element_t *ppvVar2;
  int iVar3;
  
  if (count != 0) {
    iVar3 = vector->size;
    iVar1 = count + iVar3;
    if (vector->max < iVar1) {
      iVar3 = vector->max * 2;
      if (iVar3 < 0x20) {
        iVar3 = 0x20;
      }
      if (iVar3 < iVar1) {
        iVar3 = iVar1;
      }
      vector->max = iVar3;
      ppvVar2 = (vector_element_t *)realloc(vector->element,iVar3 << 2);
      iVar3 = vector->size;
      vector->element = ppvVar2;
    }
    else {
      ppvVar2 = vector->element;
    }
    memmove(ppvVar2 + count + N,ppvVar2 + N,(iVar3 - N) * 4);
    memmove(vector->element + N,data,count * 4);
    vector->size = vector->size + count;
  }
  return;
}



void vector_insert(vector_t *vector,int N,vector_element_t data)

{
  vector_insert_many(vector,N,&data,1);
  return;
}



void vector_append_many(vector_t *vector,vector_element_t *data,int count)

{
  vector_insert_many(vector,vector->size,data,count);
  return;
}



void vector_append_vector(vector_t *vector,vector_t *other_vector)

{
  vector_append_many(vector,other_vector->element,other_vector->size);
  return;
}



void vector_append(vector_t *vector,vector_element_t data)

{
  vector_insert_many(vector,vector->size,&data,1);
  return;
}



void vector_destroy(vector_t **vector)

{
  vector_t *__ptr;
  
  __ptr = *vector;
  if (__ptr->element != (vector_element_t *)0x0) {
    free(__ptr->element);
    __ptr = *vector;
  }
  free(__ptr);
  *vector = (vector_t *)0x0;
  return;
}



vector_t * vector_create(void)

{
  vector_t *pvVar1;
  
  pvVar1 = (vector_t *)calloc(1,0xc);
  return pvVar1;
}



vector_t * vector_duplicate(vector_t *orig)

{
  int iVar1;
  vector_t *pvVar2;
  vector_element_t *__dest;
  
  pvVar2 = vector_create();
  if (orig != (vector_t *)0x0) {
    __dest = (vector_element_t *)malloc(orig->max << 2);
    pvVar2->max = orig->max;
    iVar1 = orig->size;
    pvVar2->element = __dest;
    pvVar2->size = iVar1;
    memcpy(__dest,orig->element,orig->size << 2);
  }
  return pvVar2;
}



int ActionToggleVendor(int argc,char **argv,int x,int y)

{
  vendorMapEnable = vendorMapEnable == '\0';
  return 0;
}



int ActionEnableVendor(int argc,char **argv,int x,int y)

{
  vendorMapEnable = '\x01';
  return 0;
}



int ActionDisableVendor(int argc,char **argv,int x,int y)

{
  vendorMapEnable = '\0';
  return 0;
}



int vendor_get_enabled(int unused)

{
  return (int)vendorMapEnable;
}



void register_vendor_flag_list(void)

{
  hid_register_flags(vendor_flag_list,1);
  return;
}



void register_vendor_action_list(void)

{
  hid_register_actions(vendor_action_list,6);
  return;
}



int vendorDrillMap(int in)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  if (in == cached_drill) {
    return cached_map;
  }
  cached_drill = in;
  if (((n_vendor_drills != 0) && (vendor_drills != (int *)0x0)) && (vendorMapEnable != '\0')) {
    iVar2 = *vendor_drills;
    if (iVar2 < in) {
      iVar2 = 0;
      iVar4 = n_vendor_drills + -1;
      if (vendor_drills[n_vendor_drills + -1] < in) {
        Message(
                "Vendor drill list does not contain a drill >= %6.2f mil\nUsing %6.2f mil instead.\n"
                ,(double)in * 0.01000000,(double)vendor_drills[n_vendor_drills + -1] * 0.01000000);
        cached_map = vendor_drills[n_vendor_drills + -1];
        return vendor_drills[n_vendor_drills + -1];
      }
      while (iVar3 = iVar2, 1 < iVar4 - iVar3) {
        iVar1 = (iVar3 + iVar4) / 2;
        iVar2 = iVar1;
        if (in <= vendor_drills[iVar1]) {
          iVar2 = iVar3;
          iVar4 = iVar1;
        }
      }
      if (rounding_method == 1) {
        iVar2 = vendor_drills[iVar4 + -1];
        cached_map = vendor_drills[iVar4];
        if (cached_map - in < in - iVar2) {
          return cached_map;
        }
      }
      else {
        iVar2 = vendor_drills[iVar4];
      }
    }
    cached_map = iVar2;
    return iVar2;
  }
  cached_map = in;
  return in;
}



Boolean __regparm3 rematch(char *re,char *s)

{
  int iVar1;
  int __errcode;
  int in_GS_OFFSET;
  bool bVar2;
  regex_t compiled;
  regmatch_t match;
  char errorstring [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __errcode = regcomp((regex_t *)&compiled,re,0xb);
  if (__errcode == 0) {
    __errcode = regexec((regex_t *)&compiled,s,1,(regmatch_t *)&match,0);
    regfree((regex_t *)&compiled);
    bVar2 = __errcode == 0;
  }
  else {
    regerror(__errcode,(regex_t *)&compiled,errorstring,0x80);
    Message("regexp error: %s\n",errorstring);
    regfree((regex_t *)&compiled);
    bVar2 = false;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return (Boolean)bVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Boolean vendorIsElementMappable(ElementTypePtr *element)

{
  bool bVar1;
  Boolean BVar2;
  char *__s1;
  int iVar3;
  char *s;
  int iVar4;
  char *__s2;
  
  if (vendorMapEnable == '\0') {
LAB_080d403b:
    BVar2 = '\0';
  }
  else {
    iVar4 = 0;
    bVar1 = true;
    if (0 < n_refdes) {
      do {
        s = element->Name[1].TextString;
        __s2 = ignore_refdes[iVar4];
        if (__s2 == (char *)0x0) {
LAB_080d3fd2:
          if ((s == (char *)0x0) || (*s == '\0')) {
            s = "(unknown)";
          }
          BVar2 = rematch(__s2,s);
          if (BVar2 != '\0') {
            __s2 = ignore_refdes[iVar4];
            s = element->Name[1].TextString;
            goto LAB_080d3ffc;
          }
        }
        else {
          if ((s == (char *)0x0) || (__s1 = s, *s == '\0')) {
            __s1 = "(unknown)";
          }
          iVar3 = strcmp(__s1,__s2);
          if (iVar3 != 0) goto LAB_080d3fd2;
LAB_080d3ffc:
          if ((s == (char *)0x0) || (*s == '\0')) {
            s = "(unknown)";
          }
          Message("Vendor mapping skipped because refdes = %s matches %s\n",s,__s2);
          bVar1 = false;
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < n_refdes);
      if (!bVar1) goto LAB_080d403b;
    }
    if (0 < n_value) {
      iVar4 = 0;
      do {
        s = element->Name[2].TextString;
        __s2 = ignore_value[iVar4];
        if (__s2 == (char *)0x0) {
LAB_080d409a:
          if ((s == (char *)0x0) || (*s == '\0')) {
            s = "(unknown)";
          }
          BVar2 = rematch(__s2,s);
          if (BVar2 != '\0') {
            __s2 = ignore_value[iVar4];
            s = element->Name[2].TextString;
            goto LAB_080d40c4;
          }
        }
        else {
          if ((s == (char *)0x0) || (__s1 = s, *s == '\0')) {
            __s1 = "(unknown)";
          }
          iVar3 = strcmp(__s1,__s2);
          if (iVar3 != 0) goto LAB_080d409a;
LAB_080d40c4:
          if ((s == (char *)0x0) || (*s == '\0')) {
            s = "(unknown)";
          }
          Message("Vendor mapping skipped because value = %s matches %s\n",s,__s2);
          bVar1 = false;
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < n_value);
      if (!bVar1) goto LAB_080d403b;
    }
    if (0 < n_descr) {
      iVar4 = 0;
      do {
        s = element->Name[0].TextString;
        __s2 = ignore_descr[iVar4];
        if (__s2 == (char *)0x0) {
LAB_080d4157:
          if ((s == (char *)0x0) || (*s == '\0')) {
            s = "(unknown)";
          }
          BVar2 = rematch(__s2,s);
          if (BVar2 != '\0') {
            __s2 = ignore_descr[iVar4];
            s = element->Name[0].TextString;
            goto LAB_080d4180;
          }
        }
        else {
          if ((s == (char *)0x0) || (__s1 = s, *s == '\0')) {
            __s1 = "(unknown)";
          }
          iVar3 = strcmp(__s1,__s2);
          if (iVar3 != 0) goto LAB_080d4157;
LAB_080d4180:
          if ((s == (char *)0x0) || (*s == '\0')) {
            s = "(unknown)";
          }
          Message("Vendor mapping skipped because descr = %s matches %s\n",s,__s2);
          bVar1 = false;
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < n_descr);
      if (!bVar1) goto LAB_080d403b;
    }
    BVar2 = '\x01';
    if ((*(byte *)((int)&(element->Flags).f + 1) & 0x20) != 0) {
      s = element->Name[1].TextString;
      if ((s == (char *)0x0) || (*s == '\0')) {
        s = "(unknown)";
      }
      Message("Vendor mapping skipped because element %s is locked\n",s);
      return '\0';
    }
  }
  return BVar2;
}



int ActionUnloadVendor(int argc,char **argv,int x,int y)

{
  cached_drill = -1;
  n_vendor_drills = 0;
  n_refdes = 0;
  n_value = 0;
  n_descr = 0;
  if (vendor_drills != (int *)0x0) {
    free(vendor_drills);
    vendor_drills = (int *)0x0;
  }
  if (ignore_refdes != (char **)0x0) {
    free(ignore_refdes);
    ignore_refdes = (char **)0x0;
  }
  if (ignore_value != (char **)0x0) {
    free(ignore_value);
    ignore_value = (char **)0x0;
  }
  if (ignore_descr != (char **)0x0) {
    free(ignore_descr);
    ignore_descr = (char **)0x0;
  }
  return 0;
}



void apply_vendor_map(void)

{
  uint uVar1;
  double dVar2;
  double dVar3;
  Boolean BVar4;
  Boolean BVar5;
  int in;
  int iVar6;
  char *pcVar7;
  char *pcVar8;
  DataTypePtr *pDVar9;
  char *pcVar10;
  PinTypePtr *Ptr1;
  int in_00;
  uint uVar11;
  long *plVar12;
  ElementTypePtr *element;
  char *pcVar13;
  int local_3c;
  int local_38;
  int local_34;
  char *local_30;
  uint local_2c;
  int local_28;
  uint local_24;
  
  BVar4 = vendorMapEnable;
  vendorMapEnable = '\x01';
  if (0 < n_vendor_drills) {
    local_28 = 0;
    local_38 = 0;
    pDVar9 = PCB->Data;
    if (pDVar9->ViaN != 0) {
      uVar11 = 0;
      local_24 = pDVar9->ViaN;
      do {
        Ptr1 = pDVar9->Via + uVar11;
        local_28 = local_28 + 1;
        in_00 = Ptr1->DrillingHole;
        in = vendorDrillMap(in_00);
        if (in_00 != in) {
          if ((*(byte *)((int)&(Ptr1->Flags).f + 1) & 0x20) == 0) {
            in_00 = vendorDrillMap(Ptr1->DrillingHole);
            BVar5 = ChangeObject2ndSize(1,Ptr1,(void *)0x0,(void *)0x0,in_00,'\x01','\0');
            if (BVar5 == '\0') {
              dVar2 = (double)Ptr1->Y * 0.01000000;
              dVar3 = (double)Ptr1->X * 0.01000000;
              Message(
                      "Via at %.2f, %.2f not changed.  Possible reasons:\n\t- pad size too small\n\t- new size would be too large or too small\n"
                      ,SUB84(dVar3,0),(int)((ulonglong)dVar3 >> 0x20),SUB84(dVar2,0),
                      (int)((ulonglong)dVar2 >> 0x20));
            }
            else {
              local_38 = local_38 + 1;
            }
          }
          else {
            dVar2 = (double)Ptr1->Y * 0.01000000;
            dVar3 = (double)Ptr1->X * 0.01000000;
            Message("Locked via at %.2f, %.2f not changed.\n",SUB84(dVar3,0),
                    (int)((ulonglong)dVar3 >> 0x20),SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20));
          }
        }
        pDVar9 = PCB->Data;
        uVar1 = pDVar9->ViaN;
      } while ((uVar1 != 0) &&
              (uVar11 = (uVar1 + 1 + uVar11) - local_24, local_24 = uVar1, uVar11 < uVar1));
    }
    local_34 = pDVar9->ElementN - 1;
    if (local_34 != -1) {
      in_00 = pDVar9->ElementN * 300;
      do {
        local_3c = in_00 + -300;
        element = (ElementTypePtr *)((int)&PCB->Data->Element[-1].BoundingBox.X1 + in_00);
        BVar5 = vendorIsElementMappable(element);
        if ((BVar5 != '\0') && (element->PinN != 0)) {
          uVar11 = 0;
          local_2c = element->PinN;
          do {
            local_28 = local_28 + 1;
            Ptr1 = element->Pin + uVar11;
            in_00 = Ptr1->DrillingHole;
            in = vendorDrillMap(in_00);
            if (in_00 == in) {
LAB_080d45ca:
              uVar1 = element->PinN;
            }
            else {
              if ((*(byte *)((int)&(Ptr1->Flags).f + 1) & 0x20) == 0) {
                in_00 = vendorDrillMap(Ptr1->DrillingHole);
                BVar5 = ChangeObject2ndSize(0x100,element,Ptr1,(void *)0x0,in_00,'\x01','\0');
                if (BVar5 == '\0') {
                  pcVar7 = element->Name[0].TextString;
                  if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\0')) {
                    pcVar7 = "(unknown)";
                  }
                  pcVar8 = element->Name[2].TextString;
                  if ((pcVar8 == (char *)0x0) || (*pcVar8 == '\0')) {
                    pcVar8 = "(unknown)";
                  }
                  pcVar13 = element->Name[1].TextString;
                  if ((pcVar13 == (char *)0x0) || (*pcVar13 == '\0')) {
                    pcVar13 = "(unknown)";
                  }
                  local_30 = Ptr1->Name;
                  if ((local_30 == (char *)0x0) || (*local_30 == '\0')) {
                    local_30 = "(unknown)";
                  }
                  pcVar10 = Ptr1->Number;
                  if ((pcVar10 == (char *)0x0) || (*pcVar10 == '\0')) {
                    pcVar10 = "(unknown)";
                  }
                  dVar2 = (double)Ptr1->X * 0.01000000;
                  Message(
                          "Pin %s (%s) at %.2f, %.2f (element %s, %s, %s) not changed.\n\tPossible reasons:\n\t- pad size too small\n\t- new size would be too large or too small\n"
                          ,pcVar10,local_30,SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20),
                          (double)Ptr1->Y * 0.01000000,pcVar13,pcVar8,pcVar7);
                }
                else {
                  local_38 = local_38 + 1;
                }
                goto LAB_080d45ca;
              }
              dVar2 = (double)Ptr1->Y * 0.01000000;
              dVar3 = (double)Ptr1->X * 0.01000000;
              Message("Locked pin at %-6.2f, %-6.2f not changed.\n",SUB84(dVar3,0),
                      (int)((ulonglong)dVar3 >> 0x20),SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20)
                     );
              uVar1 = element->PinN;
            }
          } while ((uVar1 != 0) &&
                  (uVar11 = (uVar1 + 1 + uVar11) - local_2c, local_2c = uVar1, uVar11 < uVar1));
        }
        local_34 = local_34 + -1;
        in_00 = local_3c;
      } while (local_34 != -1);
    }
    Message("Updated %d drill sizes out of %d total\n",local_38,local_28);
    in_00 = Settings.ViaDrillingHole;
    in = vendorDrillMap(Settings.ViaDrillingHole);
    if (in_00 != in) {
      local_38 = local_38 + 1;
      Settings.ViaDrillingHole = vendorDrillMap(Settings.ViaDrillingHole);
      Message("Adjusted active via hole size to be %6.2f mils\n",
              SUB84((double)Settings.ViaDrillingHole * 0.01000000,0),
              (int)((ulonglong)((double)Settings.ViaDrillingHole * 0.01000000) >> 0x20));
    }
    in_00 = 0;
    do {
      in = PCB->RouteStyle[in_00].Hole;
      iVar6 = vendorDrillMap(in);
      if (in != iVar6) {
        local_38 = local_38 + 1;
        plVar12 = &PCB->ID;
        in = vendorDrillMap((plVar12 + in_00 * 6)[0x867]);
        (plVar12 + in_00 * 6)[0x867] = in;
        dVar2 = (double)(&PCB->ID + in_00 * 6)[0x867] * 0.01000000;
        Message("Adjusted %s routing style via hole size to be %6.2f mils\n",
                (&PCB->ID + in_00 * 6)[0x869],SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20));
        plVar12 = &PCB->ID + in_00 * 6;
        if (plVar12[0x866] <= plVar12[0x867] + 399) {
          in = plVar12[0x867] + 400;
          plVar12[0x866] = in;
          dVar2 = (double)in * 0.01000000;
          Message("Increased %s routing style via diameter to %6.2f mils\n",plVar12[0x869],
                  SUB84(dVar2,0),(int)((ulonglong)dVar2 >> 0x20));
        }
      }
      in_00 = in_00 + 1;
    } while (in_00 != 4);
    if (local_38 != 0) {
      SetChangedFlag('\x01');
      ClearAndRedrawOutput();
      IncrementUndoSerialNumber();
    }
  }
  vendorMapEnable = BVar4;
  return;
}



int ActionLoadVendorFrom(int argc,char **argv,int x,int y)

{
  undefined4 *puVar1;
  char cVar2;
  undefined4 uVar3;
  PCBTypePtr pPVar4;
  PCBTypePtr pPVar5;
  char *default_file;
  Resource *res;
  char *__s1;
  Resource *res_00;
  Resource *pRVar6;
  int iVar7;
  char **ppcVar8;
  int iVar9;
  int iVar10;
  int *piVar11;
  int iVar12;
  char *__size;
  byte *pbVar13;
  byte *pbVar14;
  int iVar15;
  char *pcVar16;
  byte *pbVar17;
  bool bVar18;
  bool bVar19;
  bool bVar20;
  byte bVar21;
  double dVar22;
  int *local_48;
  char *local_44;
  int local_38;
  int local_30;
  char ***local_2c;
  int local_28;
  
  bVar21 = 0;
  cached_drill = -1;
  if (((argc == 0) || (local_44 = *argv, local_44 == (char *)0x0)) || (*local_44 == '\0')) {
    local_44 = (*gui->fileselect)("Load Vendor Resource File...",
                                                                    
                                  "Picks a vendor resource file to load.\nThis file can contain drc settings for a\nparticular vendor as well as a list of\npredefined drills which are allowed."
                                  ,default_file,".res","vendor",1);
    if (local_44 == (char *)0x0) {
      Message("Syntax error.  Usage:\n%s\n","LoadVendorFrom(filename)");
      return 1;
    }
    if (default_file != (char *)0x0) {
      free(default_file);
      default_file = (char *)0x0;
    }
    if (*local_44 != '\0') {
      default_file = (char *)__strdup(local_44);
    }
  }
  n_vendor_drills = 0;
  n_refdes = 0;
  n_value = 0;
  n_descr = 0;
  if (vendor_drills != (int *)0x0) {
    free(vendor_drills);
    vendor_drills = (int *)0x0;
  }
  if (ignore_refdes != (char **)0x0) {
    free(ignore_refdes);
    ignore_refdes = (char **)0x0;
  }
  if (ignore_value != (char **)0x0) {
    free(ignore_value);
    ignore_value = (char **)0x0;
  }
  if (ignore_descr != (char **)0x0) {
    free(ignore_descr);
    ignore_descr = (char **)0x0;
  }
  res = resource_parse(local_44,(char **)0x0);
  if (res == (Resource *)0x0) {
    Message("Could not load vendor resource file \"%s\"\n",local_44);
    return 1;
  }
  __s1 = resource_value(res,"vendor");
  if ((__s1 == (char *)0x0) || (__s1 = resource_value(res,"vendor"), *__s1 == '\0')) {
    vendor_name = "(unknown)";
  }
  else {
    vendor_name = resource_value(res,"vendor");
  }
  __s1 = resource_value(res,"units");
  if (__s1 == (char *)0x0) {
LAB_080d49e7:
    sf = 100.00000000;
  }
  else {
    cVar2 = *__s1;
    bVar19 = cVar2 == 'm';
    if (((bVar19) && (bVar19 = __s1[1] == 'i', bVar19)) &&
       ((bVar19 = __s1[2] == 'l', bVar19 && (bVar19 = __s1[3] == '\0', bVar19)))) goto LAB_080d49e7;
    iVar9 = 5;
    __size = __s1;
    pcVar16 = "mils";
    do {
      if (iVar9 == 0) break;
      iVar9 = iVar9 + -1;
      bVar19 = *__size == *pcVar16;
      __size = __size + (uint)bVar21 * -2 + 1;
      pcVar16 = pcVar16 + (uint)bVar21 * -2 + 1;
    } while (bVar19);
    if (bVar19) goto LAB_080d49e7;
    iVar9 = 5;
    __size = __s1;
    pcVar16 = "inch";
    do {
      if (iVar9 == 0) break;
      iVar9 = iVar9 + -1;
      bVar19 = *__size == *pcVar16;
      __size = __size + (uint)bVar21 * -2 + 1;
      pcVar16 = pcVar16 + (uint)bVar21 * -2 + 1;
    } while (bVar19);
    if ((bVar19) || (iVar9 = strcmp(__s1,"inches"), iVar9 == 0)) {
LAB_080d5136:
      sf = 100000.00000000;
    }
    else {
      if ((cVar2 != 'm') || ((__s1[1] != 'm' || (__s1[2] != '\0')))) {
        Message("\"%s\" is not a supported units.  Defaulting to inch\n",__s1);
        goto LAB_080d5136;
      }
      sf = 3937.00787402;
    }
  }
  rounding_method = 0;
  res_00 = resource_subres(res,"drillmap");
  if (res_00 == (Resource *)0x0) {
    Message("No drillmap resource found\n");
    goto LAB_080d4dd8;
  }
  __s1 = resource_value(res_00,"round");
  if (__s1 != (char *)0x0) {
    bVar19 = *__s1 == 'u';
    if (((!bVar19) || (bVar19 = __s1[1] == 'p', !bVar19)) || (bVar19 = __s1[2] == '\0', !bVar19)) {
      iVar9 = 8;
      __size = __s1;
      pcVar16 = "nearest";
      do {
        if (iVar9 == 0) break;
        iVar9 = iVar9 + -1;
        bVar19 = *__size == *pcVar16;
        __size = __size + (uint)bVar21 * -2 + 1;
        pcVar16 = pcVar16 + (uint)bVar21 * -2 + 1;
      } while (bVar19);
      if (bVar19) {
        rounding_method = 1;
        goto LAB_080d4a83;
      }
      Message("\"%s\" is not a valid rounding type.  Defaulting to up\n",__s1);
    }
    rounding_method = 0;
  }
LAB_080d4a83:
  __s1 = "skips";
  pRVar6 = resource_subres(res_00,"skips");
  if ((pRVar6 != (Resource *)0x0) && (0 < pRVar6->c)) {
    local_30 = 0;
    local_38 = 0;
    do {
      piVar11 = (int *)((int)&pRVar6->v->name + local_30);
      iVar9 = piVar11[2];
      __size = (char *)((~-(uint)(*piVar11 == 0) & 100) + (uint)(iVar9 != 0) +
                       (~-(uint)(piVar11[1] == 0) & 10));
      if (__size == (char *)0x1) {
        iVar7 = *(int *)(iVar9 + 0x10);
        pbVar14 = *(byte **)(iVar7 + 4);
        bVar19 = false;
        bVar20 = pbVar14 == (byte *)0x0;
        if (bVar20) {
          Message("Error:  null skip value\n",__s1);
          __size = __s1;
        }
        else {
          iVar10 = 7;
          pbVar13 = pbVar14;
          pbVar17 = (byte *)"refdes";
          do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            bVar19 = *pbVar13 < *pbVar17;
            bVar20 = *pbVar13 == *pbVar17;
            pbVar13 = pbVar13 + (uint)bVar21 * -2 + 1;
            pbVar17 = pbVar17 + (uint)bVar21 * -2 + 1;
          } while (bVar20);
          local_2c = &ignore_refdes;
          local_48 = &n_refdes;
          bVar18 = (!bVar19 && !bVar20) < bVar19;
          bVar19 = (!bVar19 && !bVar20) == bVar19;
          __size = __s1;
          if (!bVar19) {
            iVar10 = 6;
            pbVar13 = pbVar14;
            pbVar17 = (byte *)0x8156226;
            do {
              if (iVar10 == 0) break;
              iVar10 = iVar10 + -1;
              bVar18 = *pbVar13 < *pbVar17;
              bVar19 = *pbVar13 == *pbVar17;
              pbVar13 = pbVar13 + (uint)bVar21 * -2 + 1;
              pbVar17 = pbVar17 + (uint)bVar21 * -2 + 1;
            } while (bVar19);
            local_2c = &ignore_value;
            local_48 = &n_value;
            bVar19 = (!bVar18 && !bVar19) == bVar18;
            if (!bVar19) {
              iVar10 = 6;
              pbVar13 = (byte *)"descr";
              do {
                if (iVar10 == 0) break;
                iVar10 = iVar10 + -1;
                bVar19 = *pbVar14 == *pbVar13;
                pbVar14 = pbVar14 + (uint)bVar21 * -2 + 1;
                pbVar13 = pbVar13 + (uint)bVar21 * -2 + 1;
              } while (bVar19);
              if (!bVar19) goto LAB_080d4ad0;
              local_2c = &ignore_descr;
              local_48 = &n_descr;
            }
          }
          if (1 < *(int *)(iVar9 + 0xc)) {
            iVar9 = 0xc;
            iVar10 = 1;
            while( true ) {
              uVar3 = *(undefined4 *)(iVar7 + 4 + iVar9);
              iVar7 = *local_48;
              *local_48 = iVar7 + 1;
              __size = (char *)((iVar7 + 1) * 4);
              ppcVar8 = (char **)realloc(*local_2c,(size_t)__size);
              *local_2c = ppcVar8;
              if (ppcVar8 == (char **)0x0) {
                __fprintf_chk(stderr,1,"realloc() failed\n");
                    // WARNING: Subroutine does not return
                exit(-1);
              }
              iVar7 = *local_48;
              iVar10 = iVar10 + 1;
              iVar9 = iVar9 + 0xc;
              __s1 = (char *)__strdup(uVar3);
              ppcVar8[iVar7 + -1] = __s1;
              iVar7 = *(int *)((int)&pRVar6->v->subres + local_30);
              if (*(int *)(iVar7 + 0xc) <= iVar10) break;
              iVar7 = *(int *)(iVar7 + 0x10);
            }
          }
        }
      }
      else {
        Message("Ignored resource type = %d in skips= section\n",__size);
      }
LAB_080d4ad0:
      local_38 = local_38 + 1;
      local_30 = local_30 + 0xc;
      __s1 = __size;
    } while (local_38 < pRVar6->c);
  }
  if (0 < res_00->c) {
    local_2c = (char ***)0x0;
    local_28 = 0;
    do {
      piVar11 = (int *)((int)&res_00->v->name + (int)local_2c);
      __s1 = (char *)piVar11[1];
      if ((~-(uint)(*piVar11 == 0) & 100) + (uint)(piVar11[2] != 0) +
          (~-(uint)(__s1 == (char *)0x0) & 10) == 10) {
        n_vendor_drills = n_vendor_drills + 1;
        vendor_drills = (int *)realloc(vendor_drills,n_vendor_drills * 4);
        if (vendor_drills == (int *)0x0) {
          __fprintf_chk(stderr,1,"realloc() failed to allocate %ld bytes\n",n_vendor_drills << 2);
        }
        else {
          dVar22 = strtod(__s1,(char **)0x0);
          dVar22 = floor(dVar22 * sf + 0.50000000);
          piVar11 = vendor_drills;
          iVar9 = n_vendor_drills + -1;
          iVar7 = (int)ROUND(dVar22);
          if (iVar9 < 1) {
            iVar10 = 0;
LAB_080d4d7a:
            if (iVar10 == iVar9) {
              vendor_drills[iVar10] = iVar7;
              goto LAB_080d4c78;
            }
            local_38 = iVar10 * 4;
          }
          else {
            if (*vendor_drills < iVar7) {
              iVar10 = 0;
              do {
                iVar10 = iVar10 + 1;
                if (iVar9 <= iVar10) goto LAB_080d4d7a;
                local_38 = iVar10 * 4;
              } while (vendor_drills[iVar10] < iVar7);
            }
            else {
              local_38 = 0;
              iVar10 = 0;
            }
          }
          if (iVar10 < iVar9) {
            iVar15 = iVar9 * 4;
            iVar12 = n_vendor_drills * 4 + -8;
            do {
              puVar1 = (undefined4 *)((int)piVar11 + iVar12);
              iVar9 = iVar9 + -1;
              iVar12 = iVar12 + -4;
              *(undefined4 *)((int)piVar11 + iVar15) = *puVar1;
              iVar15 = iVar15 + -4;
            } while (iVar9 != iVar10);
          }
          *(int *)((int)piVar11 + local_38) = iVar7;
        }
      }
LAB_080d4c78:
      local_28 = local_28 + 1;
      local_2c = (char ***)((int)local_2c + 0xc);
    } while (res_00->c != local_28 && local_28 <= res_00->c);
  }
LAB_080d4dd8:
  res = resource_subres(res,"drc");
  __s1 = resource_value(res,"copper_space");
  pPVar4 = PCB;
  if (__s1 != (char *)0x0) {
    dVar22 = strtod(__s1,(char **)0x0);
    dVar22 = floor(dVar22 * sf + 0.50000000);
    pPVar5 = PCB;
    pPVar4->Bloat = (int)ROUND(dVar22);
    dVar22 = (double)pPVar5->Bloat * 0.01000000;
    Message("Set DRC minimum copper spacing to %.2f mils\n",SUB84(dVar22,0),
            (int)((ulonglong)dVar22 >> 0x20));
  }
  __s1 = resource_value(res,"copper_overlap");
  pPVar4 = PCB;
  if (__s1 != (char *)0x0) {
    dVar22 = strtod(__s1,(char **)0x0);
    dVar22 = floor(dVar22 * sf + 0.50000000);
    pPVar5 = PCB;
    pPVar4->Shrink = (int)ROUND(dVar22);
    dVar22 = (double)pPVar5->Shrink * 0.01000000;
    Message("Set DRC minimum copper overlap to %.2f mils\n",SUB84(dVar22,0),
            (int)((ulonglong)dVar22 >> 0x20));
  }
  __s1 = resource_value(res,"copper_width");
  pPVar4 = PCB;
  if (__s1 != (char *)0x0) {
    dVar22 = strtod(__s1,(char **)0x0);
    dVar22 = floor(dVar22 * sf + 0.50000000);
    pPVar5 = PCB;
    pPVar4->minWid = (int)ROUND(dVar22);
    dVar22 = (double)pPVar5->minWid * 0.01000000;
    Message("Set DRC minimum copper spacing to %.2f mils\n",SUB84(dVar22,0),
            (int)((ulonglong)dVar22 >> 0x20));
  }
  __s1 = resource_value(res,"silk_width");
  pPVar4 = PCB;
  if (__s1 != (char *)0x0) {
    dVar22 = strtod(__s1,(char **)0x0);
    dVar22 = floor(dVar22 * sf + 0.50000000);
    pPVar5 = PCB;
    pPVar4->minSlk = (int)ROUND(dVar22);
    dVar22 = (double)pPVar5->minSlk * 0.01000000;
    Message("Set DRC minimum silk width to %.2f mils\n",SUB84(dVar22,0),
            (int)((ulonglong)dVar22 >> 0x20));
  }
  __s1 = resource_value(res,"min_drill");
  pPVar4 = PCB;
  if (__s1 != (char *)0x0) {
    dVar22 = strtod(__s1,(char **)0x0);
    dVar22 = floor(dVar22 * sf + 0.50000000);
    pPVar5 = PCB;
    pPVar4->minDrill = (int)ROUND(dVar22);
    dVar22 = (double)pPVar5->minDrill * 0.01000000;
    Message("Set DRC minimum drill diameter to %.2f mils\n",SUB84(dVar22,0),
            (int)((ulonglong)dVar22 >> 0x20));
  }
  __s1 = resource_value(res,"min_ring");
  pPVar4 = PCB;
  if (__s1 != (char *)0x0) {
    dVar22 = strtod(__s1,(char **)0x0);
    dVar22 = floor(dVar22 * sf + 0.50000000);
    pPVar5 = PCB;
    pPVar4->minRing = (int)ROUND(dVar22);
    dVar22 = (double)pPVar5->minRing * 0.01000000;
    Message("Set DRC minimum annular ring to %.2f mils\n",SUB84(dVar22,0),
            (int)((ulonglong)dVar22 >> 0x20));
  }
  Message("Loaded %d vendor drills from %s\n",n_vendor_drills,local_44);
  Message("Loaded %d RefDes skips, %d Value skips, %d Descr skips\n",n_refdes,n_value,n_descr);
  vendorMapEnable = '\x01';
  apply_vendor_map();
  free((void *)0x0);
  return 0;
}



int ActionApplyVendor(int argc,char **argv,int x,int y)

{
  hid_action("Busy");
  apply_vendor_map();
  return 0;
}



int hid_parse_actions(char *rstr,anon_subr_int_char_ptr_int_char_ptr_ptr *function)

{
  char cVar1;
  char cVar2;
  code *pcVar3;
  size_t sVar4;
  char *__ptr;
  ushort **ppuVar5;
  int iVar6;
  char cVar7;
  char *pcVar8;
  char *pcVar9;
  bool bVar10;
  int local_2c;
  char **local_28;
  int local_24;
  int local_20;
  
  pcVar3 = hid_actionv;
  if (function != (anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0) {
    pcVar3 = function;
  }
  sVar4 = strlen(rstr);
  __ptr = (char *)malloc(sVar4 + 1);
  local_2c = 0;
  local_28 = (char **)0x0;
LAB_080d5261:
  cVar7 = *rstr;
  do {
    if (cVar7 == '\0') {
cleanup:
      iVar6 = 0;
      goto LAB_080d547d;
    }
    ppuVar5 = __ctype_b_loc();
    while (pcVar8 = __ptr, (*(byte *)((int)*ppuVar5 + (int)cVar7 * 2 + 1) & 0x20) != 0) {
      rstr = rstr + 1;
      cVar7 = *rstr;
      if (cVar7 == '\0') goto cleanup;
    }
    while ((cVar7 != '(' && (cVar7 != '\0'))) {
      rstr = rstr + 1;
      *pcVar8 = cVar7;
      cVar7 = *rstr;
      pcVar8 = pcVar8 + 1;
    }
    *pcVar8 = '\0';
    if (*rstr == '\0') break;
    rstr = rstr + 1;
    cVar7 = *rstr;
    if (cVar7 == '\0') break;
    pcVar8 = pcVar8 + 1;
    local_20 = 0;
    local_24 = 0;
    bVar10 = true;
    while (cVar7 != ')') {
      do {
        if ((cVar7 == '\0') && (bVar10)) goto cleanup;
        if (local_2c <= local_24) {
          local_2c = local_2c + 10;
          if (local_28 == (char **)0x0) {
            local_28 = (char **)malloc(local_2c * 4);
            cVar7 = *rstr;
          }
          else {
            local_28 = (char **)realloc(local_28,local_2c * 4);
            cVar7 = *rstr;
          }
        }
        if (cVar7 != '\0') {
          do {
            if ((*(byte *)((int)*ppuVar5 + (int)cVar7 * 2 + 1) & 0x20) == 0) break;
            rstr = rstr + 1;
            cVar7 = *rstr;
          } while (cVar7 != '\0');
        }
        local_24 = local_24 + 1;
        *(char **)((int)local_28 + local_20) = pcVar8;
        cVar2 = *rstr;
        pcVar9 = pcVar8;
        cVar1 = '\0';
        while ((cVar7 = cVar2, cVar7 != '\0' &&
               ((cVar1 != '\0' || ((cVar7 != ')' && (cVar7 != ','))))))) {
          if ((cVar7 == '\'') || (cVar7 == '\"')) {
            if (cVar1 != '\0') {
              if (cVar1 != cVar7) goto LAB_080d53c6;
              cVar7 = '\0';
            }
          }
          else {
LAB_080d53c6:
            if ((cVar7 == '\\') && (cVar1 != '\'')) {
              rstr = rstr + 1;
              cVar7 = *rstr;
            }
            *pcVar9 = cVar7;
            pcVar9 = pcVar9 + 1;
            cVar7 = cVar1;
          }
          rstr = rstr + 1;
          cVar2 = *rstr;
          cVar1 = cVar7;
        }
        *pcVar9 = '\0';
        pcVar8 = pcVar9 + 1;
        cVar1 = *rstr;
        if (cVar1 == ',') {
          rstr = rstr + 1;
          cVar7 = *rstr;
        }
        while ((pcVar9 = pcVar9 + -1, (*(byte *)((int)*ppuVar5 + (int)*pcVar9 * 2 + 1) & 0x20) != 0
               && (*(char **)((int)local_28 + local_20) <= pcVar9))) {
          *pcVar9 = '\0';
        }
        local_20 = local_20 + 4;
        bVar10 = cVar1 != ',';
      } while (!bVar10);
    }
    iVar6 = (*pcVar3)(__ptr,local_24,local_28);
    if (iVar6 != 0) goto LAB_080d52ed;
    rstr = rstr + 1;
    cVar7 = *rstr;
  } while( true );
  iVar6 = (*pcVar3)(__ptr,0,(char **)0x0);
  if (iVar6 != 0) {
LAB_080d52ed:
    iVar6 = 1;
LAB_080d547d:
    if (local_28 != (char **)0x0) {
      free(local_28);
    }
    if (__ptr != (char *)0x0) {
      free(__ptr);
    }
    return iVar6;
  }
  goto LAB_080d5261;
}



void __regparm3 dump_string(char prefix,char *str)

{
  bool bVar1;
  
  if (*str != '\0') {
    bVar1 = true;
    do {
      if (bVar1) {
        _IO_putc((int)prefix,stdout);
      }
      _IO_putc((int)*str,stdout);
      bVar1 = *str == '\n';
      str = str + 1;
    } while (*str != '\0');
    if (!bVar1) {
      _IO_putc(10,stdout);
    }
  }
  return;
}



int action_sort(void *va,void *vb)

{
  int iVar1;
  
  iVar1 = strcmp(*(char **)va,*(char **)vb);
  return iVar1;
}



void hid_deregister_action(char *name,void **context)

{
  HID_ActionNode *pHVar1;
  int iVar2;
  HID_ActionNode *__ptr;
  HID_ActionNode *pHVar3;
  
  if (context != (void **)0x0) {
    *context = (void *)0x0;
  }
  if (hid_action_nodes != (HID_ActionNode *)0x0) {
    pHVar1 = hid_action_nodes;
    pHVar3 = (HID_ActionNode *)0x0;
    do {
      __ptr = pHVar1;
      if ((__ptr->dynamic != 0) && (iVar2 = strcmp(__ptr->actions->name,name), iVar2 == 0)) {
        if (context != (void **)0x0) {
          *context = __ptr->context;
        }
        if (pHVar3 == (HID_ActionNode *)0x0) {
          hid_action_nodes = __ptr->next;
        }
        else {
          pHVar3->next = __ptr->next;
        }
        free(__ptr->actions);
        free(__ptr);
        if (all_actions != (HID_ActionContext *)0x0) {
          free(all_actions);
          all_actions = (HID_ActionContext *)0x0;
        }
        n_actions = n_actions + -1;
        return;
      }
      pHVar1 = __ptr->next;
      pHVar3 = __ptr;
    } while (__ptr->next != (HID_ActionNode *)0x0);
  }
  return;
}



HID_Action * hid_find_action(char *name,void **context)

{
  char **ppcVar1;
  HID_Action *pHVar2;
  int iVar3;
  int iVar4;
  HID_ActionContext *pHVar5;
  int iVar6;
  int iVar7;
  HID_ActionContext *__base;
  HID_ActionNode *pHVar8;
  int local_24;
  int local_20;
  
  if (name == (char *)0x0) {
    return (HID_Action *)0x0;
  }
  if (all_actions == (HID_ActionContext *)0x0) {
    __base = (HID_ActionContext *)malloc(n_actions * 0x18);
    all_actions = __base;
    if (hid_action_nodes != (HID_ActionNode *)0x0) {
      local_20 = 0;
      pHVar8 = hid_action_nodes;
      do {
        if (0 < pHVar8->n) {
          iVar7 = 0;
          pHVar2 = pHVar8->actions;
          pHVar5 = __base + local_20;
          iVar6 = 0;
          do {
            iVar7 = iVar7 + 1;
            local_20 = local_20 + 1;
            (pHVar5->action).name = *(char **)((int)&pHVar2->name + iVar6);
            (pHVar5->action).need_coord_msg = *(char **)((int)&pHVar2->need_coord_msg + iVar6);
            (pHVar5->action).trigger_cb =
                 *(anon_subr_int_int_char_ptr_ptr_int_int_for_trigger_cb **)
                  ((int)&pHVar2->trigger_cb + iVar6);
            (pHVar5->action).description = *(char **)((int)&pHVar2->description + iVar6);
            ppcVar1 = (char **)((int)&pHVar2->syntax + iVar6);
            iVar6 = iVar6 + 0x14;
            (pHVar5->action).syntax = *ppcVar1;
            pHVar5->context = pHVar8->context;
            pHVar5 = pHVar5 + 1;
          } while (pHVar8->n != iVar7 && iVar7 <= pHVar8->n);
        }
        pHVar8 = pHVar8->next;
      } while (pHVar8 != (HID_ActionNode *)0x0);
    }
    qsort(__base,n_actions,0x18,action_sort);
  }
  iVar6 = n_actions;
  local_20 = -1;
  iVar7 = n_actions;
  while (iVar4 = iVar7, local_24 = iVar4 + -1, local_20 < local_24) {
    while( true ) {
      iVar7 = (iVar4 + local_20) / 2;
      __base = all_actions + iVar7;
      iVar3 = strcmp((__base->action).name,name);
      if (iVar3 == 0) goto LAB_080d5725;
      if (0 < iVar3) break;
      local_20 = iVar7;
      if (local_24 <= iVar7) goto LAB_080d56f0;
    }
  }
LAB_080d56f0:
  if (0 < iVar6) {
    iVar7 = 0;
    __base = all_actions;
    do {
      iVar4 = strcasecmp((__base->action).name,name);
      if (iVar4 == 0) {
LAB_080d5725:
        if (context == (void **)0x0) {
          return (HID_Action *)__base;
        }
        *context = __base->context;
        return (HID_Action *)__base;
      }
      iVar7 = iVar7 + 1;
      __base = __base + 1;
    } while (iVar7 < iVar6);
  }
  __printf_chk(1,0x8150118,name);
  return (HID_Action *)0x0;
}



int hid_actionv(char *name,int argc,char **argv)

{
  void *pvVar1;
  HID_Action *pHVar2;
  int iVar3;
  char *local_44;
  char *pcVar4;
  void *local_28;
  int local_24;
  int local_20 [4];
  
  local_20[0] = 0;
  local_24 = 0;
  if ((name != (char *)0x0) && (Settings.verbose != 0)) {
    local_44 = name;
    __printf_chk(1,&DAT_0815012d,name);
    if (0 < argc) {
      pcVar4 = *argv;
      iVar3 = 0;
      local_44 = "";
      while( true ) {
        iVar3 = iVar3 + 1;
        __printf_chk(1,&DAT_08148644,local_44,pcVar4);
        if (argc <= iVar3) break;
        pcVar4 = argv[iVar3];
        local_44 = ",";
      }
    }
    __printf_chk(1,&DAT_0815013e,local_44);
  }
  pHVar2 = hid_find_action(name,&local_28);
  iVar3 = 1;
  if (pHVar2 != (HID_Action *)0x0) {
    if (pHVar2->need_coord_msg != (char *)0x0) {
      (*gui->get_coords)(pHVar2->need_coord_msg,local_20,&local_24);
    }
    pvVar1 = hid_action_context;
    hid_action_context = local_28;
    iVar3 = (*pHVar2->trigger_cb)(argc,argv,local_20[0],local_24);
    hid_action_context = pvVar1;
  }
  return iVar3;
}



int hid_actionl(char *name,...)

{
  int argc;
  char *pcVar1;
  char *in_stack_00000008;
  char *argv [20];
  
  argc = 0;
  pcVar1 = in_stack_00000008;
  if (in_stack_00000008 != (char *)0x0) {
    do {
      argv[argc] = pcVar1;
      argc = argc + 1;
      pcVar1 = (char *)(&stack0x00000008)[argc];
    } while (pcVar1 != (char *)0x0);
  }
  argc = hid_actionv(name,argc,argv);
  return argc;
}



int hid_action(char *name)

{
  int iVar1;
  
  iVar1 = hid_actionv(name,0,(char **)0x0);
  return iVar1;
}



void dump_actions(void)

{
  undefined4 *puVar1;
  char *str;
  char *str_00;
  int iVar2;
  int iVar3;
  
  hid_find_action(hid_action_nodes->actions->name,(void **)0x0);
  if (0 < n_actions) {
    iVar3 = 0;
    iVar2 = 0;
    do {
      puVar1 = (undefined4 *)((int)&(all_actions->action).name + iVar2);
      str = (char *)puVar1[3];
      str_00 = (char *)puVar1[4];
      if (str == (char *)0x0) {
        str = "";
      }
      if (str_00 == (char *)0x0) {
        str_00 = "";
      }
      iVar3 = iVar3 + 1;
      iVar2 = iVar2 + 0x18;
      __printf_chk(1,&DAT_08150145,*puVar1);
      dump_string('D',str);
      dump_string('S',str_00);
    } while (iVar3 < n_actions);
  }
  return;
}



void print_actions(void)

{
  char cVar1;
  undefined4 *puVar2;
  char *pcVar3;
  char *__ptr;
  char *__size;
  int local_24;
  int local_20;
  
  hid_find_action(hid_action_nodes->actions->name,(void **)0x0);
  __fprintf_chk(stderr,1,"Registered Actions:\n");
  if (0 < n_actions) {
    local_20 = 0;
    local_24 = 0;
    do {
      puVar2 = (undefined4 *)((int)&(all_actions->action).name + local_20);
      if (puVar2[3] == 0) {
        __fprintf_chk(stderr,1,0x814738b,*puVar2);
      }
      else {
        __fprintf_chk(stderr,1,"  %s - %s\n",*puVar2,puVar2[3]);
      }
      __ptr = *(char **)((int)&(all_actions->action).syntax + local_20);
      if (__ptr != (char *)0x0) {
        cVar1 = *__ptr;
        pcVar3 = __ptr;
        if (cVar1 == '\n') goto LAB_080d5b90;
        do {
          pcVar3 = __ptr;
          if (cVar1 == '\0') goto LAB_080d5b90;
          do {
            pcVar3 = pcVar3 + 1;
            if (*pcVar3 == '\n') break;
          } while (*pcVar3 != '\0');
          __size = pcVar3 + -(int)__ptr;
          while( true ) {
            fwrite(&DAT_0815672d,4,1,stderr);
            fwrite(__ptr,(size_t)__size,1,stderr);
            fputc(10,stderr);
            if (*pcVar3 == '\0') goto LAB_080d5b98;
            __ptr = pcVar3 + 1;
            cVar1 = *__ptr;
            pcVar3 = __ptr;
            if (cVar1 != '\n') break;
LAB_080d5b90:
            __size = (char *)0x0;
            __ptr = pcVar3;
          }
        } while( true );
      }
LAB_080d5b98:
      local_24 = local_24 + 1;
      local_20 = local_20 + 0x18;
    } while (local_24 < n_actions);
  }
  return;
}



void __regparm3 hid_register_actions_context(HID_Action *a,int n,void *context,int dynamic)

{
  char *pcVar1;
  HID_ActionContext *__ptr;
  HID_ActionNode *pHVar2;
  HID_ActionNode *pHVar3;
  HID_Action *pHVar4;
  
  pHVar3 = (HID_ActionNode *)malloc(0x14);
  pHVar2 = pHVar3;
  pHVar3->next = hid_action_nodes;
  hid_action_nodes = pHVar2;
  if (dynamic == 0) {
    pHVar3->actions = a;
  }
  else {
    pHVar4 = (HID_Action *)malloc(0x14);
    pcVar1 = a->name;
    pHVar3->actions = pHVar4;
    pHVar4->name = pcVar1;
    pHVar4->need_coord_msg = a->need_coord_msg;
    pHVar4->trigger_cb = a->trigger_cb;
    pHVar4->description = a->description;
    pHVar4->syntax = a->syntax;
  }
  n_actions = n_actions + n;
  pHVar3->n = n;
  pHVar3->dynamic = dynamic;
  __ptr = all_actions;
  pHVar3->context = context;
  if (__ptr != (HID_ActionContext *)0x0) {
    free(__ptr);
    all_actions = (HID_ActionContext *)0x0;
  }
  return;
}



void hid_register_action(HID_Action *a,void *context)

{
  hid_register_actions_context(a,1,context,1);
  return;
}



void hid_register_actions(HID_Action *a,int n)

{
  hid_register_actions_context(a,n,(void *)0x0,0);
  return;
}



void hid_save_and_show_layer_ons(int *save_array)

{
  DataTypePtr *pDVar1;
  int iVar2;
  DataTypePtr *pDVar3;
  
  pDVar1 = PCB->Data;
  if (-2 < pDVar1->LayerN) {
    iVar2 = 0;
    pDVar3 = pDVar1;
    do {
      save_array[iVar2] = (int)*(char *)(&pDVar1->field_0x90 + iVar2 * 0x5c);
      iVar2 = iVar2 + 1;
      *(undefined *)&pDVar3->field_0x90 = 1;
      pDVar3 = (DataTypePtr *)&pDVar3->field_0x5c;
    } while (iVar2 <= pDVar1->LayerN + 1);
  }
  return;
}



void hid_restore_layer_ons(int *save_array)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  DataTypePtr *pDVar4;
  
  pDVar4 = PCB->Data;
  iVar2 = pDVar4->LayerN;
  if (-2 < iVar2) {
    iVar3 = 0;
    do {
      piVar1 = save_array + iVar3;
      iVar3 = iVar3 + 1;
      *(undefined *)&pDVar4->field_0x90 = (char)*piVar1;
      pDVar4 = (DataTypePtr *)&pDVar4->field_0x5c;
    } while (iVar3 <= iVar2 + 1);
  }
  return;
}



char * layer_type_to_file_name(int idx)

{
  int iVar1;
  int iVar2;
  char *__s1;
  char buf [20];
  
  switch(idx) {
  case -0xfef:
    __s1 = "frontsilk";
    break;
  case -0xfee:
    __s1 = "backsilk";
    break;
  default:
    iVar1 = GetLayerGroupNumberByNumber(idx);
    iVar2 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
    __s1 = "front";
    if (iVar1 != iVar2) {
      iVar2 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
      __s1 = "back";
      if (iVar1 != iVar2) {
        if ((PCB->LayerGroups).Number[iVar1] == 1) {
          __s1 = *(char **)(&PCB->Data->field_0x4c + idx * 0x5c);
          iVar2 = strcasecmp(__s1,"route");
          if ((iVar2 == 0) || (iVar2 = strcasecmp(__s1,"outline"), iVar2 == 0)) {
            return "outline";
          }
        }
        __sprintf_chk(buf,1,0x14,"group%d",iVar1);
        __s1 = buf;
      }
    }
    break;
  case -0xfdf:
    __s1 = "frontmask";
    break;
  case -0xfde:
    __s1 = "backmask";
    break;
  case -0xfd0:
    __s1 = "plated-drill";
    break;
  case -0xfc0:
    __s1 = "unplated-drill";
    break;
  case -0xfaf:
    __s1 = "frontpaste";
    break;
  case -0xfae:
    __s1 = "backpaste";
    break;
  case -4000:
    __s1 = "invisible";
    break;
  case -0xf90:
    __s1 = "fab";
    break;
  case -0xf7f:
    __s1 = "frontassembly";
    break;
  case -0xf7e:
    __s1 = "backassembly";
  }
  return __s1;
}



int flag_sort(void *va,void *vb)

{
  int iVar1;
  
  iVar1 = strcmp(*(char **)va,*(char **)vb);
  return iVar1;
}



HID_Flag * hid_find_flag(char *name)

{
  HID_Flag *pHVar1;
  HID_Flag *pHVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  HID_Flag *__base;
  HID_FlagNode *pHVar7;
  bool bVar8;
  int local_24;
  int local_20;
  
  if (all_flags == (HID_Flag *)0x0) {
    __base = (HID_Flag *)calloc(1,n_flags * 0xc);
    local_20 = 0;
    pHVar7 = hid_flag_nodes;
    all_flags = __base;
    if (hid_flag_nodes != (HID_FlagNode *)0x0) {
      while( true ) {
        local_24 = local_20;
        if (0 < pHVar7->n) {
          iVar4 = 0;
          pHVar2 = pHVar7->flags;
          pHVar1 = __base + local_20;
          iVar5 = 1;
          do {
            *(undefined4 *)((int)&pHVar1->name + iVar4) =
                 *(undefined4 *)((int)&pHVar2->name + iVar4);
            *(undefined4 *)((int)&pHVar1->function + iVar4) =
                 *(undefined4 *)((int)&pHVar2->function + iVar4);
            *(undefined4 *)((int)&pHVar1->parm + iVar4) =
                 *(undefined4 *)((int)&pHVar2->parm + iVar4);
            iVar4 = iVar4 + 0xc;
            local_24 = local_20 + iVar5;
            bVar8 = pHVar7->n != iVar5;
            bVar3 = iVar5 <= pHVar7->n;
            iVar5 = iVar5 + 1;
          } while (bVar8 && bVar3);
        }
        if (pHVar7->next == (HID_FlagNode *)0x0) break;
        local_20 = local_24;
        pHVar7 = pHVar7->next;
      }
    }
    qsort(__base,n_flags,0xc,flag_sort);
  }
  local_20 = -1;
  local_24 = n_flags;
  iVar5 = n_flags + 1;
  while (local_20 < local_24) {
    while( true ) {
      iVar6 = (iVar5 + local_20) / 2;
      __base = all_flags + iVar6;
      iVar4 = strcmp(__base->name,name);
      if (iVar4 == 0) {
        return __base;
      }
      if (0 < iVar4) break;
      local_20 = iVar6;
      if (local_24 <= iVar6) goto LAB_080d5f70;
    }
    local_24 = iVar6 + -1;
    iVar5 = iVar6;
  }
LAB_080d5f70:
  __printf_chk(1,"unknown flag `%s\'\n",name);
  return (HID_Flag *)0x0;
}



// WARNING: Exceeded maximum restarts with more pending

int hid_get_flag(char *name)

{
  int nbuf;
  char *buf;
  char *pcVar1;
  long lVar2;
  HID_Flag *pHVar3;
  int iVar4;
  char *__n;
  
  pcVar1 = strchr(name,0x2c);
  if (pcVar1 == (char *)0x0) {
    pHVar3 = hid_find_flag(name);
    if (pHVar3 != (HID_Flag *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080d6161. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar4 = (*pHVar3->function)();
      return iVar4;
    }
  }
  else {
    __n = pcVar1 + -(int)name;
    if (nbuf <= (int)__n) {
      nbuf = (int)(__n + 10);
      buf = (char *)MyRealloc(buf,nbuf,"hid_get_flag");
    }
    memcpy(buf,name,(size_t)__n);
    buf[(int)__n] = '\0';
    lVar2 = strtol(pcVar1 + 1,(char **)0x0,0);
    pHVar3 = hid_find_flag(buf);
    if (pHVar3 != (HID_Flag *)0x0) {
      iVar4 = (*pHVar3->function)(pHVar3->parm);
      return (uint)(lVar2 == iVar4);
    }
  }
  return 0;
}



void hid_register_flags(HID_Flag *a,int n)

{
  HID_FlagNode *pHVar1;
  
  pHVar1 = (HID_FlagNode *)calloc(1,0xc);
  pHVar1->next = hid_flag_nodes;
  pHVar1->n = n;
  n_flags = n_flags + n;
  hid_flag_nodes = pHVar1;
  pHVar1->flags = a;
  if (all_flags != (HID_Flag *)0x0) {
    free(all_flags);
    all_flags = (HID_Flag *)0x0;
  }
  return;
}



void hid_register_gui(HID *Pgui,anon_subr_void_int_ptr_char_ptr_ptr_ptr *func)

{
  if (gui_start != (anon_subr_void_int_ptr_char_ptr_ptr_ptr *)0x0) {
    return;
  }
  gui_start = func;
  default_gui = Pgui;
  return;
}



HID * hid_find_printer(void)

{
  byte bVar1;
  HID *pHVar2;
  int iVar3;
  
  if (hid_num_hids < 1) {
LAB_080d6232:
    pHVar2 = (HID *)0x0;
  }
  else {
    iVar3 = 0;
    pHVar2 = *hid_list;
    bVar1 = *(byte *)&pHVar2->field_0xc;
    while ((bVar1 & 2) == 0) {
      iVar3 = iVar3 + 1;
      if (hid_num_hids <= iVar3) goto LAB_080d6232;
      pHVar2 = hid_list[iVar3];
      bVar1 = *(byte *)&pHVar2->field_0xc;
    }
  }
  return pHVar2;
}



HID ** hid_enumerate(void)

{
  return hid_list;
}



void hid_register_attributes(HID_Attribute *a,int n)

{
  HID_AttrNode *pHVar1;
  
  pHVar1 = (HID_AttrNode *)calloc(1,0xc);
  pHVar1->next = hid_attr_nodes;
  hid_attr_nodes = pHVar1;
  pHVar1->attributes = a;
  pHVar1->n = n;
  return;
}



void __regparm3 copy_color(int set,hidval *cval,hidval *aval)

{
  if (set == 0) {
    *aval = *cval;
    return;
  }
  *cval = *aval;
  return;
}



int hid_cache_color(int set,char *name,hidval *val,void **vcache)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  uint uVar6;
  byte *pbVar7;
  uint uVar8;
  void *local_20;
  
  local_20 = *vcache;
  if (local_20 == (void *)0x0) {
    local_20 = calloc(0x80,1);
    *vcache = local_20;
  }
  iVar3 = *(int *)((int)local_20 + 0x7c);
  if ((iVar3 != 0) && (iVar2 = strcmp(*(char **)(iVar3 + 4),name), iVar2 == 0)) {
    copy_color(set,(hidval *)(iVar3 + 8),val);
    return 1;
  }
  bVar1 = *name;
  uVar6 = 0;
  uVar8 = 0;
  pbVar7 = (byte *)name;
  if (bVar1 != 0) {
    do {
      uVar6 = uVar6 * 0x21 + (uint)bVar1;
      bVar1 = pbVar7[1];
      pbVar7 = pbVar7 + 1;
    } while (bVar1 != 0);
    uVar8 = uVar6 % 0x1f;
  }
  puVar4 = *(undefined4 **)((int)local_20 + uVar8 * 4);
  while( true ) {
    if (puVar4 == (undefined4 *)0x0) {
      if (set == 0) {
        return 0;
      }
      puVar4 = (undefined4 *)calloc(1,0xc);
      *puVar4 = *(undefined4 *)((int)local_20 + uVar8 * 4);
      *(undefined4 **)((int)local_20 + uVar8 * 4) = puVar4;
      uVar5 = __strdup(name);
      puVar4[1] = uVar5;
      puVar4[2] = *val;
      *(undefined4 **)((int)local_20 + 0x7c) = puVar4;
      return 1;
    }
    iVar3 = strcmp((char *)puVar4[1],name);
    if (iVar3 == 0) break;
    puVar4 = (undefined4 *)*puVar4;
  }
  copy_color(set,puVar4 + 2,val);
  *(undefined4 **)((int)local_20 + 0x7c) = puVar4;
  return 1;
}



void derive_default_filename
               (char *pcbfile,HID_Attribute *filename_attrib,char *suffix,char **memory)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  undefined4 *__ptr;
  char *__ptr_00;
  char *pcVar4;
  bool bVar5;
  byte bVar6;
  char *local_20;
  
  bVar6 = 0;
  if (pcbfile == (char *)0x0) {
    __ptr = (undefined4 *)calloc(1,0xc);
    if (__ptr == (undefined4 *)0x0) {
      return;
    }
    *__ptr = 0x6e6b6e75;
    __ptr[1] = 0x2e6e776f;
    __ptr[2] = 0x626370;
  }
  else {
    __ptr = (undefined4 *)__strdup(pcbfile);
  }
  if (__ptr == (undefined4 *)0x0) {
    return;
  }
  if (memory == (char **)0x0) {
    sVar1 = strlen((char *)__ptr);
    sVar2 = strlen(suffix);
    local_20 = (char *)calloc(1,sVar1 + 1 + sVar2);
  }
  else {
    if ((filename_attrib->default_val).str_value != *memory) {
      return;
    }
    sVar1 = strlen((char *)__ptr);
    sVar2 = strlen(suffix);
    local_20 = (char *)calloc(1,sVar1 + 1 + sVar2);
    *memory = local_20;
  }
  if (local_20 != (char *)0x0) {
    strcpy(local_20,(char *)__ptr);
    sVar1 = strlen(local_20);
    bVar5 = sVar1 == 4;
    if (4 < sVar1) {
      iVar3 = 5;
      __ptr_00 = local_20 + (sVar1 - 4);
      pcVar4 = ".pcb";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar5 = *__ptr_00 == *pcVar4;
        __ptr_00 = __ptr_00 + (uint)bVar6 * -2 + 1;
        pcVar4 = pcVar4 + (uint)bVar6 * -2 + 1;
      } while (bVar5);
      if (bVar5) {
        local_20[sVar1 - 4] = '\0';
      }
    }
    strcat(local_20,suffix);
    __ptr_00 = (filename_attrib->default_val).str_value;
    if (__ptr_00 != (char *)0x0) {
      free(__ptr_00);
    }
    (filename_attrib->default_val).str_value = local_20;
  }
  free(__ptr);
  return;
}



HID * hid_find_exporter(char *which)

{
  HID *pHVar1;
  HID **ppHVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  
  iVar5 = hid_num_hids;
  ppHVar2 = hid_list;
  if (0 < hid_num_hids) {
    iVar4 = 0;
    do {
      pHVar1 = ppHVar2[iVar4];
      if (((*(byte *)&pHVar1->field_0xc & 4) != 0) &&
         (iVar3 = strcmp(which,pHVar1->name), iVar3 == 0)) {
        return pHVar1;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar5);
  }
  __fprintf_chk(stderr,1,"Invalid exporter %s, available ones:",which);
  if (0 < hid_num_hids) {
    iVar5 = 0;
    do {
      while ((*(byte *)&hid_list[iVar5]->field_0xc & 4) == 0) {
        iVar5 = iVar5 + 1;
        if (hid_num_hids <= iVar5) goto LAB_080d6690;
      }
      which = hid_list[iVar5]->name;
      iVar5 = iVar5 + 1;
      __fprintf_chk(stderr,1,0x814736a,which);
    } while (iVar5 < hid_num_hids);
  }
LAB_080d6690:
  __fprintf_chk(stderr,1,0x8151453,which);
  return (HID *)0x0;
}



HID * hid_find_gui(void)

{
  byte bVar1;
  HID *pHVar2;
  int iVar3;
  
  if (0 < hid_num_hids) {
    iVar3 = 0;
    pHVar2 = *hid_list;
    bVar1 = *(byte *)&pHVar2->field_0xc;
    while( true ) {
      if ((bVar1 & 6) == 0) {
        return pHVar2;
      }
      iVar3 = iVar3 + 1;
      if (hid_num_hids <= iVar3) break;
      pHVar2 = hid_list[iVar3];
      bVar1 = *(byte *)&pHVar2->field_0xc;
    }
  }
  __fprintf_chk(stderr,1,"Error: No GUI available.\n");
                    // WARNING: Subroutine does not return
  exit(1);
}



void __regparm3 hid_load_settings_1(char *fname)

{
  char **ppcVar1;
  HID_AttrNode *pHVar2;
  FILE *__stream;
  char *__s1;
  ushort **ppuVar3;
  size_t sVar4;
  char *__s2;
  int iVar5;
  char *__s1_00;
  char cVar6;
  char **ppcVar7;
  char *pcVar8;
  char *__s;
  int iVar9;
  int iVar10;
  int in_GS_OFFSET;
  double dVar11;
  char line [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen(fname,"r");
  if (__stream == (FILE *)0x0) {
    free(fname);
  }
  else {
    free(fname);
LAB_080d6770:
    __s1 = fgets(line,0x400,__stream);
    cVar6 = line[0];
    if (__s1 != (char *)0x0) {
      if (line[0] != '\0') {
        __s1 = line;
        ppuVar3 = __ctype_b_loc();
        do {
          if ((*(byte *)((int)*ppuVar3 + (int)cVar6 * 2 + 1) & 0x20) == 0) {
            if ((cVar6 != '#') && (cVar6 = *__s1, cVar6 != '\0')) {
              ppuVar3 = __ctype_b_loc();
              __s2 = __s1;
              goto LAB_080d680e;
            }
            break;
          }
          __s1 = __s1 + 1;
          cVar6 = *__s1;
        } while (cVar6 != '\0');
      }
      goto LAB_080d6770;
    }
    fclose(__stream);
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
  while( true ) {
    __s2 = __s2 + 1;
    cVar6 = *__s2;
    if (cVar6 == '\0') break;
LAB_080d680e:
    if ((*(byte *)((int)*ppuVar3 + (int)cVar6 * 2 + 1) & 0x20) != 0) {
      *__s2 = '\0';
      __s = __s2 + 1;
      cVar6 = __s2[1];
      if (cVar6 != '\0') {
        goto LAB_080d683e;
      }
      break;
    }
  }
  goto LAB_080d6770;
LAB_080d683e:
  if (((*(byte *)((int)*ppuVar3 + (int)cVar6 * 2 + 1) & 0x20) != 0) || (cVar6 == '=')) {
    __s = __s + 1;
    cVar6 = *__s;
    if (cVar6 == '\0') goto LAB_080d6770;
    goto LAB_080d683e;
  }
  sVar4 = strlen(__s);
  __s2 = __s + (sVar4 - 1);
  while ((pHVar2 = hid_attr_nodes, __s <= __s2 &&
         ((*(byte *)((int)*ppuVar3 + (int)*__s2 * 2 + 1) & 0x20) != 0))) {
    *__s2 = '\0';
    __s2 = __s2 + -1;
  }
  while (pHVar2 != (HID_AttrNode *)0x0) {
    iVar9 = 0;
    iVar10 = 0;
    if (0 < pHVar2->n) {
      do {
        ppcVar7 = (char **)((int)&pHVar2->attributes->name + iVar9);
        __s2 = *ppcVar7;
        iVar5 = strcmp(__s1,__s2);
        if (iVar5 == 0) {
          switch(ppcVar7[2]) {
          case (char *)0x1:
            __s2 = (char *)strtol(__s,(char **)0x0,0);
            ppcVar7[5] = __s2;
            break;
          case (char *)0x2:
            dVar11 = strtod(__s,(char **)0x0);
            *(double *)(ppcVar7 + 7) = dVar11;
            break;
          case (char *)0x3:
            __s2 = (char *)__strdup(__s);
            ppcVar7[6] = __s2;
            break;
          case (char *)0x4:
            ppcVar7[5] = &DAT_00000001;
            break;
          case (char *)0x5:
            ppcVar1 = (char **)ppcVar7[9];
            __s1_00 = *ppcVar1;
            if (__s1_00 == (char *)0x0) {
LAB_080d6a29:
              __fprintf_chk(stderr,1,"ERROR:  \"%s\" is an unknown value for the %s option\n",__s,
                            __s2);
                    // WARNING: Subroutine does not return
              exit(1);
            }
            pcVar8 = (char *)0x0;
            while (iVar5 = strcmp(__s1_00,__s), iVar5 != 0) {
              pcVar8 = pcVar8 + 1;
              __s1_00 = ppcVar1[(int)pcVar8];
              if (__s1_00 == (char *)0x0) goto LAB_080d6a29;
            }
            ppcVar7[5] = pcVar8;
            ppcVar7[6] = __s;
            break;
          case (char *)0x6:
                    // WARNING: Subroutine does not return
            abort();
          case (char *)0x7:
            ppcVar7[6] = __s;
          }
        }
        iVar10 = iVar10 + 1;
        iVar9 = iVar9 + 0x30;
      } while (iVar10 < pHVar2->n);
    }
    pHVar2 = pHVar2->next;
  }
  goto LAB_080d6770;
}



void hid_load_settings(void)

{
  byte *pbVar1;
  uint uVar2;
  char *fname;
  int iVar3;
  HID_Attribute *pHVar4;
  int iVar5;
  HID_AttrNode *pHVar6;
  undefined1 *local_34;
  undefined4 local_30;
  
  pHVar6 = hid_attr_nodes;
  if (hid_attr_nodes != (HID_AttrNode *)0x0) {
    do {
      if (0 < pHVar6->n) {
        pHVar4 = pHVar6->attributes;
        iVar5 = 0;
        do {
          iVar3 = 0;
          uVar2 = 0;
          do {
            pbVar1 = (byte *)((int)&pHVar4->name + iVar3);
            iVar3 = iVar3 + 1;
            uVar2 = (int)uVar2 >> 0x10 ^ uVar2 * 0xd ^ (uint)*pbVar1;
          } while (iVar3 != 0x2c);
          pHVar4->hash = uVar2;
          iVar5 = iVar5 + 1;
          pHVar4 = pHVar4 + 1;
        } while (pHVar6->n != iVar5 && iVar5 <= pHVar6->n);
      }
      pHVar6 = pHVar6->next;
    } while (pHVar6 != (HID_AttrNode *)0x0);
  }
  local_30 = 0;
  local_34 = (undefined1 *)0x815057e;
  fname = Concat(pcblibdir,0x815d1de,0x815057e,0);
  hid_load_settings_1(fname);
  if (homedir != (char *)0x0) {
    local_30 = 0x815d1de;
    local_34 = &DAT_0815492b;
    fname = Concat(homedir,0x815d1de,&DAT_0815492b,0x815d1de,0x815057e,0);
    hid_load_settings_1(fname);
  }
  fname = Concat("pcb.settings",0,local_34,local_30);
  hid_load_settings_1(fname);
  return;
}



void hid_save_settings(int locally)

{
  byte *pbVar1;
  undefined8 uVar2;
  HID_AttrNode *pHVar3;
  char *__filename;
  int iVar4;
  FILE *__stream;
  uint uVar5;
  undefined1 *puVar6;
  undefined4 uVar7;
  int iVar8;
  undefined4 *puVar9;
  char *local_8c;
  int local_80;
  stat st;
  
  if (locally == 0) {
    if (homedir == (char *)0x0) {
      return;
    }
    __filename = Concat(homedir,0x815d1de,&DAT_0815492b,0);
    iVar4 = __xstat(3,__filename,(stat *)&st);
    if ((iVar4 != 0) && (iVar4 = mkdir(__filename,0x1ff), iVar4 != 0)) {
      free(__filename);
      return;
    }
    free(__filename);
    local_8c = Concat(homedir,0x815d1de,&DAT_0815492b,0x815d1de,0x815057e,0);
  }
  else {
    local_8c = Concat("pcb.settings",0);
  }
  __stream = fopen(local_8c,"w");
  pHVar3 = hid_attr_nodes;
  if (__stream == (FILE *)0x0) {
    Message("Can\'t open %s",local_8c);
    free(local_8c);
  }
  else {
    while (pHVar3 != (HID_AttrNode *)0x0) {
      iVar4 = 0;
      local_80 = 0;
      if (0 < pHVar3->n) {
LAB_080d6c50:
        do {
          uVar5 = 0;
          puVar9 = (undefined4 *)((int)&pHVar3->attributes->name + iVar4);
          iVar8 = 0;
          do {
            pbVar1 = (byte *)((int)puVar9 + iVar8);
            iVar8 = iVar8 + 1;
            uVar5 = (int)uVar5 >> 0x10 ^ uVar5 * 0xd ^ (uint)*pbVar1;
          } while (iVar8 != 0x2c);
          if (puVar9[0xb] == uVar5) {
            __fprintf_chk(__stream,1,&DAT_08150595);
          }
          switch(puVar9[2]) {
          case 1:
            if ((undefined4 *)puVar9[10] == (undefined4 *)0x0) {
              uVar7 = puVar9[5];
            }
            else {
              uVar7 = *(undefined4 *)puVar9[10];
            }
            iVar4 = iVar4 + 0x30;
            __fprintf_chk(__stream,1,"%s = %d\n",*puVar9,uVar7);
            local_80 = local_80 + 1;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 2:
            if ((undefined8 *)puVar9[10] == (undefined8 *)0x0) {
              uVar2 = *(undefined8 *)(puVar9 + 7);
            }
            else {
              uVar2 = *(undefined8 *)puVar9[10];
            }
            iVar4 = iVar4 + 0x30;
            __fprintf_chk(__stream,1,"%s = %f\n",*puVar9,uVar2);
            local_80 = local_80 + 1;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 3:
          case 7:
            if ((undefined4 *)puVar9[10] == (undefined4 *)0x0) {
              puVar6 = (undefined1 *)puVar9[6];
            }
            else {
              puVar6 = *(undefined1 **)(undefined4 *)puVar9[10];
            }
            if (puVar6 == (undefined1 *)0x0) {
              puVar6 = &DAT_0814741b;
            }
            __fprintf_chk(__stream,1,"%s = %s\n",*puVar9,puVar6);
          default:
            local_80 = local_80 + 1;
            iVar4 = iVar4 + 0x30;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 4:
            if ((char *)puVar9[10] == (char *)0x0) {
              iVar8 = puVar9[5];
            }
            else {
              iVar8 = (int)*(char *)puVar9[10];
            }
            iVar4 = iVar4 + 0x30;
            __fprintf_chk(__stream,1,"%s = %d\n",*puVar9,iVar8);
            local_80 = local_80 + 1;
            if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
            break;
          case 5:
            goto switchD_080d6c90_caseD_5;
          case 6:
                    // WARNING: Subroutine does not return
            abort();
          }
        } while( true );
      }
LAB_080d6ce9:
      __fprintf_chk(__stream,1,0x8151453);
      pHVar3 = pHVar3->next;
    }
    fclose(__stream);
    free(local_8c);
  }
  return;
switchD_080d6c90_caseD_5:
  if ((int *)puVar9[10] == (int *)0x0) {
    iVar8 = puVar9[5];
  }
  else {
    iVar8 = *(int *)puVar9[10];
  }
  iVar4 = iVar4 + 0x30;
  __fprintf_chk(__stream,1,"%s = %s\n",*puVar9,*(undefined4 *)(puVar9[9] + iVar8 * 4));
  local_80 = local_80 + 1;
  if (pHVar3->n == local_80 || pHVar3->n < local_80) goto LAB_080d6ce9;
  goto LAB_080d6c50;
}



// WARNING: Could not reconcile some variable overlaps

void hid_parse_command_line(int *argc,char ***argv)

{
  char *__s2;
  long *plVar1;
  char **ppcVar2;
  double *pdVar3;
  int iVar4;
  long lVar5;
  char *__s1;
  int iVar6;
  int iVar7;
  HID_AttrNode *pHVar8;
  HID_Attribute *pHVar9;
  int iVar10;
  byte *__s2_00;
  byte *pbVar11;
  bool bVar12;
  bool bVar13;
  byte bVar14;
  double dVar15;
  undefined *local_38;
  byte **local_34;
  byte *local_2c;
  HID_AttrNode *local_28;
  
  pHVar8 = hid_attr_nodes;
  bVar14 = 0;
  *argc = *argc + -1;
  *argv = *argv + 1;
  if (pHVar8 != (HID_AttrNode *)0x0) {
    do {
      iVar7 = 0;
      iVar6 = 0;
      if (0 < pHVar8->n) {
        do {
          iVar10 = (int)&pHVar8->attributes->name + iVar7;
          if (5 < *(uint *)(iVar10 + 8)) {
switchD_080d7069_caseD_6:
                    // WARNING: Subroutine does not return
            abort();
          }
          switch(*(undefined4 *)(iVar10 + 8)) {
          case 0:
            break;
          default:
            if (*(undefined4 **)(iVar10 + 0x28) != (undefined4 *)0x0) {
              **(undefined4 **)(iVar10 + 0x28) = *(undefined4 *)(iVar10 + 0x14);
            }
            break;
          case 2:
            if (*(undefined8 **)(iVar10 + 0x28) != (undefined8 *)0x0) {
              **(undefined8 **)(iVar10 + 0x28) = *(undefined8 *)(iVar10 + 0x1c);
            }
            break;
          case 3:
            if (*(undefined4 **)(iVar10 + 0x28) != (undefined4 *)0x0) {
              **(undefined4 **)(iVar10 + 0x28) = *(undefined4 *)(iVar10 + 0x18);
            }
            break;
          case 4:
            if (*(undefined **)(iVar10 + 0x28) != (undefined *)0x0) {
              **(undefined **)(iVar10 + 0x28) = (char)*(undefined4 *)(iVar10 + 0x14);
            }
          }
          iVar6 = iVar6 + 1;
          iVar7 = iVar7 + 0x30;
        } while (pHVar8->n != iVar6 && iVar6 <= pHVar8->n);
      }
      pHVar8 = pHVar8->next;
    } while (pHVar8 != (HID_AttrNode *)0x0);
  }
  iVar6 = *argc;
  if (iVar6 == 0) {
LAB_080d729e:
    iVar6 = 1;
  }
  else {
    local_34 = (byte **)*argv;
    local_2c = *local_34;
    if ((*local_2c == 0x2d) && (local_2c[1] == 0x2d)) {
      do {
        pHVar8 = hid_attr_nodes;
        local_38 = &DAT_00000001;
        iVar6 = 2;
        while (pHVar8 == (HID_AttrNode *)0x0) {
LAB_080d7150:
          bVar12 = local_38 == (undefined *)0x0;
          bVar13 = local_38 == &DAT_00000001;
          if (!bVar13) goto LAB_080d717f;
          iVar7 = 5;
          iVar6 = 5;
          __s2_00 = local_2c;
          pbVar11 = (byte *)"--no-";
          do {
            if (iVar7 == 0) break;
            iVar7 = iVar7 + -1;
            bVar12 = *__s2_00 < *pbVar11;
            bVar13 = *__s2_00 == *pbVar11;
            __s2_00 = __s2_00 + (uint)bVar14 * -2 + 1;
            pbVar11 = pbVar11 + (uint)bVar14 * -2 + 1;
          } while (bVar13);
          local_38 = (undefined *)0x0;
          if ((!bVar12 && !bVar13) != bVar12) {
LAB_080d717f:
            __fprintf_chk(stderr,1,"unrecognized option: %s\n",local_2c);
                    // WARNING: Subroutine does not return
            exit(1);
          }
        }
        local_28 = pHVar8;
LAB_080d7018:
        iVar7 = local_28->n;
        if (iVar7 < 1) goto LAB_080d7140;
        iVar10 = 0;
        pHVar9 = local_28->attributes;
        while( true ) {
          __s2 = pHVar9->name;
          iVar4 = strcmp((char *)(local_2c + iVar6),__s2);
          if (iVar4 == 0) break;
          iVar10 = iVar10 + 1;
          pHVar9 = pHVar9 + 1;
          if (iVar7 <= iVar10) goto LAB_080d7140;
        }
        switch(pHVar9->type) {
        default:
          break;
        case HID_Integer:
          plVar1 = (long *)pHVar9->value;
          if (plVar1 == (long *)0x0) {
            lVar5 = strtol((char *)local_34[1],(char **)0x0,0);
            (pHVar9->default_val).int_value = lVar5;
          }
          else {
            lVar5 = strtol((char *)local_34[1],(char **)0x0,0);
            *plVar1 = lVar5;
          }
          *argc = *argc + -1;
          *argv = *argv + 1;
          break;
        case HID_Real:
          pdVar3 = (double *)pHVar9->value;
          if (pdVar3 == (double *)0x0) {
            dVar15 = strtod((char *)local_34[1],(char **)0x0);
            (pHVar9->default_val).real_value = dVar15;
          }
          else {
            dVar15 = strtod((char *)local_34[1],(char **)0x0);
            *pdVar3 = dVar15;
          }
          goto LAB_080d7225;
        case HID_String:
          if ((byte **)pHVar9->value == (byte **)0x0) {
            *(byte **)&(pHVar9->default_val).str_value = local_34[1];
          }
          else {
            *(byte **)pHVar9->value = local_34[1];
          }
          goto LAB_080d7225;
        case HID_Boolean:
          if ((undefined *)pHVar9->value == (undefined *)0x0) {
            *(undefined **)&(pHVar9->default_val).int_value = local_38;
          }
          else {
            *(undefined *)pHVar9->value = local_38._0_1_;
          }
          break;
        case HID_Enum:
          ppcVar2 = pHVar9->enumerations;
          __s2_00 = local_34[1];
          __s1 = *ppcVar2;
          if (__s1 == (char *)0x0) goto LAB_080d725a;
          iVar6 = 0;
          while (iVar7 = strcmp(__s1,(char *)__s2_00), iVar7 != 0) {
            iVar6 = iVar6 + 1;
            __s1 = ppcVar2[iVar6];
            if (__s1 == (char *)0x0) {
LAB_080d725a:
              __fprintf_chk(stderr,1,"ERROR:  \"%s\" is an unknown value for the --%s option\n",
                            (*argv)[1],__s2);
                    // WARNING: Subroutine does not return
              exit(1);
            }
          }
          (pHVar9->default_val).int_value = iVar6;
          *(byte **)&(pHVar9->default_val).str_value = __s2_00;
LAB_080d7225:
          *argc = *argc + -1;
          *argv = *argv + 1;
          break;
        case HID_Mixed:
        case HID_Path:
          goto switchD_080d7069_caseD_6;
        }
        ppcVar2 = *argv;
        *argc = *argc + -1;
        local_34 = (byte **)(ppcVar2 + 1);
        *(byte ***)argv = local_34;
        iVar6 = *argc;
        if (iVar6 == 0) goto LAB_080d729e;
        local_2c = (byte *)ppcVar2[1];
        if ((*local_2c != 0x2d) || (local_2c[1] != 0x2d)) break;
      } while( true );
    }
    iVar6 = iVar6 + 1;
  }
  *argv = *argv + -1;
  *argc = iVar6;
  return;
LAB_080d7140:
  local_28 = local_28->next;
  if (local_28 == (HID_AttrNode *)0x0) goto LAB_080d7150;
  goto LAB_080d7018;
}



void hid_register_hid(HID *hid)

{
  size_t __size;
  HID *pHVar1;
  int iVar2;
  HID **ppHVar3;
  
  if (hid->struct_size != 0xd0) {
    __fprintf_chk(stderr,1,"Warning: hid \"%s\" has an incompatible ABI.\n",hid->name);
    return;
  }
  if (hid_num_hids < 1) {
LAB_080d733c:
    __size = hid_num_hids * 4 + 8;
    hid_num_hids = hid_num_hids + 1;
    if (hid_list == (HID **)0x0) {
      ppHVar3 = (HID **)calloc(1,__size);
    }
    else {
      ppHVar3 = (HID **)realloc(hid_list,__size);
    }
    iVar2 = hid_num_hids;
    hid_list = ppHVar3;
    ppHVar3[hid_num_hids + -1] = hid;
    ppHVar3[iVar2] = (HID *)0x0;
  }
  else {
    iVar2 = 0;
    pHVar1 = *hid_list;
    while (pHVar1 != hid) {
      iVar2 = iVar2 + 1;
      if (hid_num_hids <= iVar2) goto LAB_080d733c;
      pHVar1 = hid_list[iVar2];
    }
  }
  return;
}



void __regparm3 hid_load_dir(char *dirname)

{
  DIR *__dirp;
  char *__filename;
  dirent *pdVar1;
  char *__s;
  size_t sVar2;
  int iVar3;
  char *__ptr;
  code *pcVar4;
  undefined4 uVar5;
  stat st;
  
  __dirp = opendir(dirname);
  if (__dirp != (DIR *)0x0) {
    while (pdVar1 = readdir(__dirp), pdVar1 != (dirent *)0x0) {
      __s = (char *)__strdup(pdVar1->d_name);
      sVar2 = strlen(__s);
      if (3 < sVar2) {
        iVar3 = strcasecmp(__s + (sVar2 - 3),".so");
        if (iVar3 == 0) {
          __s[sVar2 - 3] = '\0';
        }
        else {
          if (sVar2 != 4) {
            iVar3 = strcasecmp(__s + (sVar2 - 4),".dll");
            if (iVar3 == 0) {
              __s[sVar2 - 4] = '\0';
            }
          }
        }
      }
      __filename = Concat(dirname,0x815d1de,pdVar1->d_name,0);
      iVar3 = __xstat(3,__filename,(stat *)&st);
      if (((iVar3 == 0) && ((st.st_mode & 0x49) != 0)) && ((st.st_mode & 0xf000) == 0x8000)) {
        iVar3 = dlopen(__filename,0x102);
        if (iVar3 == 0) {
          uVar5 = dlerror();
          __fprintf_chk(stderr,1,"dl_error: %s\n",uVar5);
        }
        else {
          __ptr = Concat("hid_",__s,0x81505f8,0);
          pcVar4 = (code *)dlsym(iVar3,__ptr);
          if ((pcVar4 != (code *)0x0) ||
             (pcVar4 = (code *)dlsym(iVar3,"pcb_plugin_init"), pcVar4 != (code *)0x0)) {
            (*pcVar4)();
          }
          free(__ptr);
        }
      }
      free(__s);
      free(__filename);
    }
  }
  free(dirname);
  return;
}



void hid_init(void)

{
  char *dirname;
  char *local_2c;
  undefined4 local_28;
  char *local_24;
  undefined4 local_20;
  char *local_1c;
  undefined4 local_18;
  
  gui = &hid_nogui;
  hid_gtk_init();
  hid_lpr_init();
  hid_bom_init();
  hid_gerber_init();
  hid_nelma_init();
  hid_png_init();
  hid_ps_init();
  local_18 = 0;
  local_1c = "i686-pc-linux-gnu";
  dirname = Concat(exec_prefix,0x815d1de,0x813a3ba,0x815d1de,&DAT_0815492c,0x815d1de,"plugins",
                   0x815d1de,"i686-pc-linux-gnu",0);
  hid_load_dir(dirname);
  local_20 = 0;
  local_24 = "plugins";
  local_28 = 0x815d1de;
  local_2c = "pcb";
  dirname = Concat(exec_prefix,0x815d1de,0x813a3ba,0x815d1de,&DAT_0815492c,0x815d1de,"plugins",0);
  hid_load_dir(dirname);
  if (homedir != (char *)0x0) {
    local_20 = 0;
    local_24 = "i686-pc-linux-gnu";
    dirname = Concat(homedir,0x815d1de,&DAT_0815492b,0x815d1de,"plugins",0x815d1de,
                     "i686-pc-linux-gnu",0,local_1c,local_18);
    hid_load_dir(dirname);
    local_28 = 0;
    local_2c = "plugins";
    dirname = Concat(homedir,0x815d1de,&DAT_0815492b,0x815d1de,"plugins",0);
    hid_load_dir(dirname);
  }
  dirname = Concat("plugins",0x815d1de,"i686-pc-linux-gnu",0,local_2c,local_28,local_24,local_20);
  hid_load_dir(dirname);
  dirname = Concat("plugins",0);
  hid_load_dir(dirname);
  return;
}



hidGC nogui_make_gc(void)

{
  return (hidGC)0x0;
}



void nogui_destroy_gc(hidGC gc)

{
  return;
}



int nogui_shift_is_pressed(void)

{
  return 0;
}



void nogui_set_crosshair(int x,int y,int action)

{
  return;
}



int nogui_progress(int so_far,int total,char *message)

{
  return 0;
}



// WARNING: Type propagation algorithm not settling

void apply_default_hid(HID *d,HID *s)

{
  anon_subr_void_HID_Attr_Val_ptr_for_do_export *paVar1;
  anon_subr_void_int_ptr_char_ptr_ptr_ptr_for_parse_arguments *paVar2;
  anon_subr_void_int_int_int_int_int_for_invalidate_wh *paVar3;
  anon_subr_void_int_int_int_int_int_for_invalidate_lr *paVar4;
  anon_subr_void_for_invalidate_all *paVar5;
  anon_subr_int_char_ptr_int_int_for_set_layer *paVar6;
  anon_subr_hidGC_for_make_gc *paVar7;
  anon_subr_void_hidGC_for_destroy_gc *paVar8;
  anon_subr_void_int_for_use_mask *paVar9;
  anon_subr_void_hidGC_char_ptr_for_set_color *paVar10;
  anon_subr_void_hidGC_EndCapStyle_for_set_line_cap *paVar11;
  anon_subr_void_hidGC_int_for_set_line_width *paVar12;
  anon_subr_void_hidGC_int_for_set_draw_xor *paVar13;
  anon_subr_void_hidGC_int_int_int_int_for_set_line_cap_angle *paVar14;
  anon_subr_void_hidGC_int_int_int_int_for_draw_line *paVar15;
  anon_subr_void_hidGC_int_int_int_int_int_int_for_draw_arc *paVar16;
  anon_subr_void_hidGC_int_int_int_for_fill_circle *paVar17;
  anon_subr_void_hidGC_int_int_ptr_int_ptr_for_fill_polygon *paVar18;
  anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_fill_pcb_polygon *paVar19;
  anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_thindraw_pcb_polygon *paVar20;
  anon_subr_void_double_double_for_calibrate *paVar21;
  anon_subr_int_for_shift_is_pressed *paVar22;
  anon_subr_int_for_control_is_pressed *paVar23;
  anon_subr_int_for_mod1_is_pressed *paVar24;
  anon_subr_void_char_ptr_int_ptr_int_ptr_for_get_coords *paVar25;
  anon_subr_void_int_int_int_for_set_crosshair *paVar26;
  anon_subr_hidval_anon_subr_void_hidval_ptr_ulong_hidval_for_add_timer *paVar27;
  anon_subr_void_hidval_for_stop_timer *paVar28;
  anon_subr_hidval_int_uint_anon_subr_void_hidval_int_uint_hidval_ptr_hidval_for_watch_file *paVar29
  ;
  anon_subr_void_hidval_for_unwatch_file *paVar30;
  anon_subr_hidval_anon_subr_void_hidval_ptr_hidval_for_add_block_hook *paVar31;
  anon_subr_void_hidval_for_stop_block_hook *paVar32;
  anon_subr_void_char_ptr_for_log *paVar33;
  anon_subr_void_char_ptr_va_list_for_logv *paVar34;
  anon_subr_int_char_ptr_for_confirm_dialog *paVar35;
  anon_subr_int_for_close_confirm_dialog *paVar36;
  anon_subr_void_char_ptr_char_ptr_for_report_dialog *paVar37;
  anon_subr_char_ptr_char_ptr_char_ptr_for_prompt_for *paVar38;
  anon_subr_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_int_for_fileselect *paVar39;
  anon_subr_int_HID_Attribute_ptr_int_HID_Attr_Val_ptr_char_ptr_char_ptr_for_attribute_dialog
  *paVar40;
  anon_subr_void_void_ptr_for_show_item *paVar41;
  anon_subr_void_for_beep *paVar42;
  
  if (s == (HID *)0x0) {
    s = &hid_nogui;
  }
  if (d->get_export_options == (anon_subr_HID_Attribute_ptr_int_ptr_for_get_export_options *)0x0) {
    d->get_export_options = s->get_export_options;
    paVar1 = d->do_export;
  }
  else {
    paVar1 = d->do_export;
  }
  if (paVar1 == (anon_subr_void_HID_Attr_Val_ptr_for_do_export *)0x0) {
    d->do_export = s->do_export;
    paVar2 = d->parse_arguments;
  }
  else {
    paVar2 = d->parse_arguments;
  }
  if (paVar2 == (anon_subr_void_int_ptr_char_ptr_ptr_ptr_for_parse_arguments *)0x0) {
    d->parse_arguments = s->parse_arguments;
    paVar3 = d->invalidate_wh;
  }
  else {
    paVar3 = d->invalidate_wh;
  }
  if (paVar3 == (anon_subr_void_int_int_int_int_int_for_invalidate_wh *)0x0) {
    d->invalidate_wh = s->invalidate_wh;
    paVar4 = d->invalidate_lr;
  }
  else {
    paVar4 = d->invalidate_lr;
  }
  if (paVar4 == (anon_subr_void_int_int_int_int_int_for_invalidate_lr *)0x0) {
    d->invalidate_lr = s->invalidate_lr;
    paVar5 = d->invalidate_all;
  }
  else {
    paVar5 = d->invalidate_all;
  }
  if (paVar5 == (anon_subr_void_for_invalidate_all *)0x0) {
    d->invalidate_all = s->invalidate_all;
    paVar6 = d->set_layer;
  }
  else {
    paVar6 = d->set_layer;
  }
  if (paVar6 == (anon_subr_int_char_ptr_int_int_for_set_layer *)0x0) {
    d->set_layer = s->set_layer;
    paVar7 = d->make_gc;
  }
  else {
    paVar7 = d->make_gc;
  }
  if (paVar7 == (anon_subr_hidGC_for_make_gc *)0x0) {
    d->make_gc = s->make_gc;
    paVar8 = d->destroy_gc;
  }
  else {
    paVar8 = d->destroy_gc;
  }
  if (paVar8 == (anon_subr_void_hidGC_for_destroy_gc *)0x0) {
    d->destroy_gc = s->destroy_gc;
    paVar9 = d->use_mask;
  }
  else {
    paVar9 = d->use_mask;
  }
  if (paVar9 == (anon_subr_void_int_for_use_mask *)0x0) {
    d->use_mask = s->use_mask;
    paVar10 = d->set_color;
  }
  else {
    paVar10 = d->set_color;
  }
  if (paVar10 == (anon_subr_void_hidGC_char_ptr_for_set_color *)0x0) {
    d->set_color = s->set_color;
    paVar11 = d->set_line_cap;
  }
  else {
    paVar11 = d->set_line_cap;
  }
  if (paVar11 == (anon_subr_void_hidGC_EndCapStyle_for_set_line_cap *)0x0) {
    d->set_line_cap = s->set_line_cap;
    paVar12 = d->set_line_width;
  }
  else {
    paVar12 = d->set_line_width;
  }
  if (paVar12 == (anon_subr_void_hidGC_int_for_set_line_width *)0x0) {
    d->set_line_width = s->set_line_width;
    paVar13 = d->set_draw_xor;
  }
  else {
    paVar13 = d->set_draw_xor;
  }
  if (paVar13 == (anon_subr_void_hidGC_int_for_set_draw_xor *)0x0) {
    d->set_draw_xor = s->set_draw_xor;
    paVar14 = d->set_line_cap_angle;
  }
  else {
    paVar14 = d->set_line_cap_angle;
  }
  if (paVar14 == (anon_subr_void_hidGC_int_int_int_int_for_set_line_cap_angle *)0x0) {
    d->set_line_cap_angle = s->set_line_cap_angle;
    paVar15 = d->draw_line;
  }
  else {
    paVar15 = d->draw_line;
  }
  if (paVar15 == (anon_subr_void_hidGC_int_int_int_int_for_draw_line *)0x0) {
    d->draw_line = s->draw_line;
    paVar16 = d->draw_arc;
  }
  else {
    paVar16 = d->draw_arc;
  }
  if (paVar16 == (anon_subr_void_hidGC_int_int_int_int_int_int_for_draw_arc *)0x0) {
    d->draw_arc = s->draw_arc;
    paVar17 = d->fill_circle;
  }
  else {
    paVar17 = d->fill_circle;
  }
  if (paVar17 == (anon_subr_void_hidGC_int_int_int_for_fill_circle *)0x0) {
    d->fill_circle = s->fill_circle;
    paVar18 = d->fill_polygon;
  }
  else {
    paVar18 = d->fill_polygon;
  }
  if (paVar18 == (anon_subr_void_hidGC_int_int_ptr_int_ptr_for_fill_polygon *)0x0) {
    d->fill_polygon = s->fill_polygon;
    paVar19 = d->fill_pcb_polygon;
  }
  else {
    paVar19 = d->fill_pcb_polygon;
  }
  if (paVar19 == (anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_fill_pcb_polygon *)0x0) {
    d->fill_pcb_polygon = s->fill_pcb_polygon;
    paVar20 = d->thindraw_pcb_polygon;
  }
  else {
    paVar20 = d->thindraw_pcb_polygon;
  }
  if (paVar20 == (anon_subr_void_hidGC_PolygonType_ptr_BoxType_ptr_for_thindraw_pcb_polygon *)0x0) {
    d->thindraw_pcb_polygon = s->thindraw_pcb_polygon;
    paVar21 = d->calibrate;
  }
  else {
    paVar21 = d->calibrate;
  }
  if (paVar21 == (anon_subr_void_double_double_for_calibrate *)0x0) {
    d->calibrate = s->calibrate;
    paVar22 = d->shift_is_pressed;
  }
  else {
    paVar22 = d->shift_is_pressed;
  }
  if (paVar22 == (anon_subr_int_for_shift_is_pressed *)0x0) {
    d->shift_is_pressed = s->shift_is_pressed;
    paVar23 = d->control_is_pressed;
  }
  else {
    paVar23 = d->control_is_pressed;
  }
  if (paVar23 == (anon_subr_int_for_control_is_pressed *)0x0) {
    d->control_is_pressed = s->control_is_pressed;
    paVar24 = d->mod1_is_pressed;
  }
  else {
    paVar24 = d->mod1_is_pressed;
  }
  if (paVar24 == (anon_subr_int_for_mod1_is_pressed *)0x0) {
    d->mod1_is_pressed = s->mod1_is_pressed;
    paVar25 = d->get_coords;
  }
  else {
    paVar25 = d->get_coords;
  }
  if (paVar25 == (anon_subr_void_char_ptr_int_ptr_int_ptr_for_get_coords *)0x0) {
    d->get_coords = s->get_coords;
    paVar26 = d->set_crosshair;
  }
  else {
    paVar26 = d->set_crosshair;
  }
  if (paVar26 == (anon_subr_void_int_int_int_for_set_crosshair *)0x0) {
    d->set_crosshair = s->set_crosshair;
    paVar27 = d->add_timer;
  }
  else {
    paVar27 = d->add_timer;
  }
  if (paVar27 == (anon_subr_hidval_anon_subr_void_hidval_ptr_ulong_hidval_for_add_timer *)0x0) {
    d->add_timer = s->add_timer;
    paVar28 = d->stop_timer;
  }
  else {
    paVar28 = d->stop_timer;
  }
  if (paVar28 == (anon_subr_void_hidval_for_stop_timer *)0x0) {
    d->stop_timer = s->stop_timer;
    paVar29 = d->watch_file;
  }
  else {
    paVar29 = d->watch_file;
  }
  if (paVar29 ==
      (anon_subr_hidval_int_uint_anon_subr_void_hidval_int_uint_hidval_ptr_hidval_for_watch_file *)
      0x0) {
    d->watch_file = s->watch_file;
    paVar30 = d->unwatch_file;
  }
  else {
    paVar30 = d->unwatch_file;
  }
  if (paVar30 == (anon_subr_void_hidval_for_unwatch_file *)0x0) {
    d->unwatch_file = s->unwatch_file;
    paVar31 = d->add_block_hook;
  }
  else {
    paVar31 = d->add_block_hook;
  }
  if (paVar31 == (anon_subr_hidval_anon_subr_void_hidval_ptr_hidval_for_add_block_hook *)0x0) {
    d->add_block_hook = s->add_block_hook;
    paVar32 = d->stop_block_hook;
  }
  else {
    paVar32 = d->stop_block_hook;
  }
  if (paVar32 == (anon_subr_void_hidval_for_stop_block_hook *)0x0) {
    d->stop_block_hook = s->stop_block_hook;
    paVar33 = d->log;
  }
  else {
    paVar33 = d->log;
  }
  if (paVar33 == (anon_subr_void_char_ptr_for_log *)0x0) {
    d->log = s->log;
    paVar34 = d->logv;
  }
  else {
    paVar34 = d->logv;
  }
  if (paVar34 == (anon_subr_void_char_ptr_va_list_for_logv *)0x0) {
    d->logv = s->logv;
    paVar35 = d->confirm_dialog;
  }
  else {
    paVar35 = d->confirm_dialog;
  }
  if (paVar35 == (anon_subr_int_char_ptr_for_confirm_dialog *)0x0) {
    d->confirm_dialog = s->confirm_dialog;
    paVar36 = d->close_confirm_dialog;
  }
  else {
    paVar36 = d->close_confirm_dialog;
  }
  if (paVar36 == (anon_subr_int_for_close_confirm_dialog *)0x0) {
    d->close_confirm_dialog = s->close_confirm_dialog;
    paVar37 = d->report_dialog;
  }
  else {
    paVar37 = d->report_dialog;
  }
  if (paVar37 == (anon_subr_void_char_ptr_char_ptr_for_report_dialog *)0x0) {
    d->report_dialog = s->report_dialog;
    paVar38 = d->prompt_for;
  }
  else {
    paVar38 = d->prompt_for;
  }
  if (paVar38 == (anon_subr_char_ptr_char_ptr_char_ptr_for_prompt_for *)0x0) {
    d->prompt_for = s->prompt_for;
    paVar39 = d->fileselect;
  }
  else {
    paVar39 = d->fileselect;
  }
  if (paVar39 ==
      (anon_subr_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_char_ptr_int_for_fileselect *)0x0) {
    d->fileselect = s->fileselect;
    paVar40 = d->attribute_dialog;
  }
  else {
    paVar40 = d->attribute_dialog;
  }
  if (paVar40 ==
      (anon_subr_int_HID_Attribute_ptr_int_HID_Attr_Val_ptr_char_ptr_char_ptr_for_attribute_dialog *
      )0x0) {
    d->attribute_dialog = s->attribute_dialog;
    paVar41 = d->show_item;
  }
  else {
    paVar41 = d->show_item;
  }
  if (paVar41 == (anon_subr_void_void_ptr_for_show_item *)0x0) {
    d->show_item = s->show_item;
    paVar42 = d->beep;
  }
  else {
    paVar42 = d->beep;
  }
  if (paVar42 == (anon_subr_void_for_beep *)0x0) {
    d->beep = s->beep;
  }
  if (d->progress == (anon_subr_int_int_int_char_ptr_for_progress *)0x0) {
    d->progress = s->progress;
  }
  if (d->drc_gui == (HID_DRC_GUI *)0x0) {
    d->drc_gui = s->drc_gui;
    return;
  }
  return;
}



void nogui_beep(void)

{
  _IO_putc(7,stdout);
  fflush((FILE *)stdout);
  return;
}



void nogui_show_item(void *item)

{
  char "nogui_show_item" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_show_item");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_attribute_dialog(void)

{
  char "nogui_attribute_dialog" [23];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_attribute_dialog");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_stop_block_hook(void)

{
  char "nogui_stop_block_hook" [22];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_stop_block_hook");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_add_block_hook(void)

{
  char "nogui_add_block_hook" [21];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_add_block_hook");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_unwatch_file(void)

{
  char "nogui_unwatch_file" [19];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_unwatch_file");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_watch_file(void)

{
  char "nogui_watch_file" [17];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_watch_file");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_stop_timer(void)

{
  char "nogui_stop_timer" [17];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_stop_timer");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_add_timer(void)

{
  char "nogui_add_timer" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_add_timer");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_get_coords(void)

{
  char "nogui_get_coords" [17];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_get_coords");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_mod1_is_pressed(void)

{
  char "nogui_mod1_is_pressed" [22];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_mod1_is_pressed");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_control_is_pressed(void)

{
  char "nogui_control_is_pressed" [25];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_control_is_pressed");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_calibrate(void)

{
  char "nogui_calibrate" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_fill_rect(void)

{
  char "nogui_fill_rect" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_rect");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_fill_pcb_polygon(void)

{
  char "nogui_fill_pcb_polygon" [23];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_pcb_polygon");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_fill_polygon(void)

{
  char "nogui_fill_polygon" [19];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_polygon");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_fill_circle(void)

{
  char "nogui_fill_circle" [18];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_fill_circle");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_draw_rect(void)

{
  char "nogui_draw_rect" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_draw_rect");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_draw_arc(void)

{
  char "nogui_draw_arc" [15];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_draw_arc");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_draw_line(void)

{
  char "nogui_draw_line" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_draw_line");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_line_cap_angle(void)

{
  char "nogui_set_line_cap_angle" [25];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_draw_faded(void)

{
  char "nogui_set_draw_faded" [21];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_draw_faded");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_draw_xor(void)

{
  char "nogui_set_draw_xor" [19];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_draw_xor");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_line_width(void)

{
  char "nogui_set_line_width" [21];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_line_width");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_line_cap(void)

{
  char "nogui_set_line_cap" [19];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_line_cap");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_color(void)

{
  char "nogui_set_color" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_color");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_use_mask(void)

{
  char "nogui_use_mask" [15];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_use_mask");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_set_layer(void)

{
  char "nogui_set_layer" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_set_layer");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_invalidate_all(void)

{
  char "nogui_invalidate_all" [21];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_invalidate_all");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_invalidate_lr(void)

{
  char "nogui_invalidate_lr" [20];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_invalidate_lr");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_invalidate_wh(void)

{
  char "nogui_invalidate_wh" [20];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_invalidate_wh");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_parse_arguments(void)

{
  char "nogui_parse_arguments" [22];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_parse_arguments");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_do_export(void)

{
  char "nogui_do_export" [16];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_do_export");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_get_export_options(void)

{
  char "nogui_get_export_options" [25];
  
  __fprintf_chk(stderr,1,"HID error: pcb called GUI function %s without having a GUI available.\n",
                "nogui_get_export_options");
                    // WARNING: Subroutine does not return
  abort();
}



void nogui_report_dialog(undefined4 param_1,undefined4 param_2)

{
  __printf_chk(1,"--- %s ---\n%s\n",param_1,param_2);
  return;
}



char * nogui_fileselect(char *title,char *descr,char *default_file,char *default_ext,
                       char *history_tag,int flags)

{
  char buf [1024];
  
  if (default_file == (char *)0x0) {
    __printf_chk(1,"%s : ",title);
    fgets((char *)0x818d100,0x400,stdin);
    return (char *)0x818d100;
  }
  __printf_chk(1,"%s [%s] : ",title,default_file);
  fgets((char *)0x818d100,0x400,stdin);
  if (buf[0] != '\0') {
    return (char *)0x818d100;
  }
  __strcpy_chk(0x818d100,default_file,0x400);
  return (char *)0x818d100;
}



char * nogui_prompt_for(char *msg,char *default_string)

{
  char buf [1024];
  
  if (default_string == (char *)0x0) {
    __printf_chk(1,"%s : ",msg);
    fgets((char *)0x818d500,0x400,stdin);
    return (char *)0x818d500;
  }
  __printf_chk(1,"%s [%s] : ",msg,default_string);
  fgets((char *)0x818d500,0x400,stdin);
  if (buf[0] != '\0') {
    return (char *)0x818d500;
  }
  __strcpy_chk(0x818d500,default_string,0x400);
  return (char *)0x818d500;
}



int nogui_confirm_dialog(char *msg,...)

{
  int local_10 [3];
  
  __printf_chk(1,"%s ? 0=cancel 1=ok : ",msg);
  fflush(stdout);
  scanf("%d",local_10);
  return local_10[0];
}



int nogui_close_confirm_dialog(void)

{
  int iVar1;
  
  iVar1 = nogui_confirm_dialog("OK to lose data ?",0);
  return iVar1;
}



void nogui_logv(char *fmt,va_list ap)

{
  __vfprintf_chk(stdout,1,fmt,ap);
  return;
}



void nogui_log(char *fmt,...)

{
  __vfprintf_chk(stdout,1,fmt,&stack0x00000008);
  return;
}



int extents_set_layer(char *name,int group,int empty)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  if ((group < 0) ||
     ((iVar1 = PCB->Data->LayerN, group < iVar1 &&
      (group = (PCB->LayerGroups).Entries[group * 0x12], group < 0)))) {
    uVar3 = group & 0xf0;
    if (((uVar3 == 0x30) || (uVar3 == 0x40)) || (uVar2 = 0, uVar3 == 0x10)) {
      uVar2 = 1;
    }
  }
  else {
    uVar2 = (uint)(group <= iVar1 + 1);
  }
  return uVar2;
}



void extents_use_mask(int use_it)

{
  return;
}



void extents_set_color(hidGC gc,char *name)

{
  return;
}



void extents_set_line_cap(hidGC gc,EndCapStyle style)

{
  return;
}



void extents_set_line_width(hidGC gc,int width)

{
  gc->nothing_interesting_here = width;
  return;
}



void extents_set_draw_xor(hidGC gc,int xor)

{
  return;
}



void extents_set_draw_faded(hidGC gc,int faded)

{
  return;
}



void extents_set_line_cap_angle(hidGC gc,int x1,int y1,int x2,int y2)

{
  return;
}



void extents_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  
  iVar1 = gc->nothing_interesting_here;
  if (x1 - iVar1 < box.X1) {
    box.X1 = x1 - iVar1;
  }
  if (box.X2 < x1 + iVar1) {
    box.X2 = x1 + iVar1;
  }
  if (y1 - iVar1 < box.Y1) {
    box.Y1 = y1 - iVar1;
  }
  if (box.Y2 < y1 + iVar1) {
    box.Y2 = y1 + iVar1;
  }
  if (x2 - iVar1 < box.X1) {
    box.X1 = x2 - iVar1;
  }
  if (box.X2 < x2 + iVar1) {
    box.X2 = x2 + iVar1;
  }
  if (y2 - iVar1 < box.Y1) {
    box.Y1 = y2 - iVar1;
  }
  if (box.Y2 < y2 + iVar1) {
    box.Y2 = y2 + iVar1;
  }
  return;
}



void extents_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int end_angle)

{
  int iVar1;
  
  width = width + gc->nothing_interesting_here;
  iVar1 = cx - width;
  if (iVar1 < box.X1) {
    box.X1 = iVar1;
  }
  width = width + cx;
  if (box.X2 < width) {
    box.X2 = width;
  }
  height = gc->nothing_interesting_here + height;
  iVar1 = cy - height;
  if (iVar1 < box.Y1) {
    box.Y1 = iVar1;
  }
  height = height + cy;
  if (box.Y2 < height) {
    box.Y2 = height;
  }
  return;
}



void extents_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  
  iVar1 = gc->nothing_interesting_here;
  if (x1 - iVar1 < box.X1) {
    box.X1 = x1 - iVar1;
  }
  if (box.X2 < x1 + iVar1) {
    box.X2 = x1 + iVar1;
  }
  if (y1 - iVar1 < box.Y1) {
    box.Y1 = y1 - iVar1;
  }
  if (box.Y2 < y1 + iVar1) {
    box.Y2 = y1 + iVar1;
  }
  if (x2 - iVar1 < box.X1) {
    box.X1 = x2 - iVar1;
  }
  if (box.X2 < x2 + iVar1) {
    box.X2 = x2 + iVar1;
  }
  if (y2 - iVar1 < box.Y1) {
    box.Y1 = y2 - iVar1;
  }
  if (box.Y2 < y2 + iVar1) {
    box.Y2 = y2 + iVar1;
  }
  return;
}



void extents_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  if (cx - radius < box.X1) {
    box.X1 = cx - radius;
  }
  if (box.X2 < radius + cx) {
    box.X2 = radius + cx;
  }
  if (cy - radius < box.Y1) {
    box.Y1 = cy - radius;
  }
  if (box.Y2 < radius + cy) {
    box.Y2 = radius + cy;
  }
  return;
}



void extents_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  if (0 < n_coords) {
    iVar2 = 0;
    do {
      iVar1 = x[iVar2];
      iVar3 = iVar1;
      if (iVar1 < box.X1) {
        iVar3 = x[iVar2];
        box.X1 = iVar1;
      }
      if (box.X2 < iVar3) {
        box.X2 = iVar3;
      }
      iVar1 = y[iVar2];
      iVar3 = iVar1;
      if (iVar1 < box.Y1) {
        iVar3 = y[iVar2];
        box.Y1 = iVar1;
      }
      if (box.Y2 < iVar3) {
        box.Y2 = iVar3;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != n_coords);
  }
  return;
}



void extents_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  if (x1 < box.X1) {
    box.X1 = x1;
  }
  if (box.X2 < x1) {
    box.X2 = x1;
  }
  if (y1 < box.Y1) {
    box.Y1 = y1;
  }
  if (box.Y2 < y1) {
    box.Y2 = y1;
  }
  if (x2 < box.X1) {
    box.X1 = x2;
  }
  if (box.X2 < x2) {
    box.X2 = x2;
  }
  if (y2 < box.Y1) {
    box.Y1 = y2;
  }
  if (box.Y2 < y2) {
    box.Y2 = y2;
  }
  return;
}



BoxType * hid_get_extents(void *item)

{
  BoxType region;
  
  region.X1 = -0x7fffffff;
  region.Y1 = -0x7fffffff;
  region.X2 = 0x7fffffff;
  region.Y2 = 0x7fffffff;
  box.X1 = 0x7fffffff;
  box.Y1 = 0x7fffffff;
  box.X2 = -0x7fffffff;
  box.Y2 = -0x7fffffff;
  hid_expose_callback(&extents_hid,&region,item);
  return &box;
}



void extents_destroy_gc(hidGC gc)

{
  free(gc);
  return;
}



hidGC extents_make_gc(void)

{
  hidGC phVar1;
  
  phVar1 = (hidGC)malloc(4);
  phVar1->nothing_interesting_here = 0;
  return phVar1;
}



void __regparm3 thindraw_contour(hidGC gc,PLINE *pl)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  VNODE *pVVar5;
  
  if ((pl->head).next != (VNODE *)0x0) {
    (*gui->set_line_width)(gc,0);
    (*gui->set_line_cap)(gc,Round_Cap);
    pVVar5 = (pl->head).next;
    iVar3 = (pl->head).point[1];
    iVar4 = (pl->head).point[0];
    do {
      iVar1 = pVVar5->point[0];
      iVar2 = pVVar5->point[1];
      (*gui->draw_line)(gc,iVar4,iVar3,iVar1,iVar2);
      pVVar5 = pVVar5->next;
      iVar3 = iVar2;
      iVar4 = iVar1;
    } while (pVVar5 != (pl->head).next);
  }
  return;
}



int thindraw_hole_cb(PLINE *pl,void *user_data)

{
  thindraw_contour((hidGC)user_data,pl);
  return 0;
}



void common_thindraw_pcb_polygon(hidGC gc,PolygonType *poly,BoxType *clip_box)

{
  thindraw_contour(gc,poly->Clipped->contours);
  PolygonHoles(poly,clip_box,thindraw_hole_cb,gc);
  return;
}



void __regparm3 fill_contour(hidGC gc,PLINE *pl)

{
  uint uVar1;
  int *piVar2;
  int *__ptr;
  int *__ptr_00;
  uint uVar3;
  VNODE *pVVar4;
  
  pVVar4 = &pl->head;
  uVar1 = pl->Count;
  __ptr = (int *)malloc(uVar1 * 4);
  __ptr_00 = (int *)malloc(uVar1 * 4);
  if (0 < (int)uVar1) {
    uVar3 = 0;
    do {
      __ptr[uVar3] = pVVar4->point[0];
      piVar2 = pVVar4->point;
      pVVar4 = pVVar4->next;
      __ptr_00[uVar3] = piVar2[1];
      uVar3 = uVar3 + 1;
    } while (uVar1 != uVar3);
  }
  (*gui->fill_polygon)(gc,uVar1,__ptr,__ptr_00);
  free(__ptr);
  free(__ptr_00);
  return;
}



void common_fill_pcb_polygon(hidGC gc,PolygonType *poly,BoxType *clip_box)

{
  int iVar1;
  PLINE *pl;
  uint uVar2;
  int in_GS_OFFSET;
  PolygonType p;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (poly->NoHolesValid == 0) {
    ComputeNoHoles(poly);
  }
  pl = poly->NoHoles;
  while (pl != (PLINE *)0x0) {
    fill_contour(gc,pl);
    pl = pl->next;
  }
  uVar2 = (poly->Flags).f;
  if ((uVar2 & 0x20) != 0) {
    p.BoundingBox.X1 = (poly->BoundingBox).X1;
    p.BoundingBox.Y1 = (poly->BoundingBox).Y1;
    p.BoundingBox.X2 = (poly->BoundingBox).X2;
    p.BoundingBox.Y2 = (poly->BoundingBox).Y2;
    p.ID = poly->ID;
    p.Flags.t._0_4_ = *(undefined4 *)(poly->Flags).t;
    p.Flags.t._4_4_ = *(undefined4 *)((poly->Flags).t + 4);
    p.net = poly->net;
    p.PointN = poly->PointN;
    p.PointMax = poly->PointMax;
    p.NoHoles = poly->NoHoles;
    p.NoHolesValid = poly->NoHolesValid;
    p.Points = poly->Points;
    p.Clipped = poly->Clipped->f;
    p.Flags.f = uVar2;
    if (p.Clipped != poly->Clipped) {
      do {
        NoHolesPolygonDicer((PolygonTypePtr)&p,clip_box,fill_contour_cb,gc);
        p.Clipped = (p.Clipped)->f;
      } while (poly->Clipped != p.Clipped);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void fill_contour_cb(PLINE *pl,void *user_data)

{
  PLINE *local_10 [3];
  
  local_10[0] = pl;
  fill_contour((hidGC)user_data,pl);
  poly_FreeContours(local_10);
  return;
}



void do_mouse_action(int button,int mod_mask)

{
  uint uVar1;
  char *rstr;
  int iVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  int iVar6;
  uint uVar7;
  
  if (0 < button_count) {
    if (*button_nums == button) {
      iVar4 = 0;
      iVar6 = 0;
    }
    else {
      iVar4 = 0;
      iVar6 = 0;
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        if (button_count <= iVar2) {
          return;
        }
        iVar6 = iVar6 + *(int *)((int)mod_count + iVar4);
        iVar4 = iVar2 * 4;
      } while (button_nums[iVar2] != button);
    }
    iVar4 = *(int *)((int)mod_count + iVar4) + iVar6;
    if (iVar6 < iVar4) {
      iVar2 = iVar6 * 4;
      if (mod_mask != mods[iVar6]) {
        iVar2 = iVar6 * 4;
        puVar5 = mods + iVar6 + 1;
        iVar3 = iVar6;
        do {
          iVar2 = iVar2 + 4;
          iVar3 = iVar3 + 1;
          if (iVar4 <= iVar3) goto LAB_080d9005;
          uVar7 = *puVar5;
          puVar5 = puVar5 + 1;
        } while (mod_mask != uVar7);
      }
      iVar4 = *(int *)((int)actions + iVar2);
LAB_080d90b0:
      if ((iVar4 != 0) && (0 < *(int *)(iVar4 + 0xc))) {
        iVar6 = 0;
        iVar2 = 0;
        while ((rstr = *(char **)(*(int *)(iVar4 + 0x10) + 4 + iVar6), rstr == (char *)0x0 ||
               (iVar3 = hid_parse_actions(rstr,hid_actionv), iVar3 == 0))) {
          iVar2 = iVar2 + 1;
          iVar6 = iVar6 + 0xc;
          if (*(int *)(iVar4 + 0xc) == iVar2 || *(int *)(iVar4 + 0xc) < iVar2) {
            return;
          }
        }
      }
    }
    else {
LAB_080d9005:
      uVar7 = (mod_mask & 0x7fffffffU) - 1;
      if (-1 < (int)uVar7) {
        do {
          if (((mod_mask & 0x7fffffffU & uVar7) == uVar7) && (iVar6 < iVar4)) {
            uVar1 = mods[iVar6];
            puVar5 = mods + iVar6 + 1;
            iVar2 = iVar6;
            iVar3 = iVar6 * 4;
            while( true ) {
              if (uVar1 == (mod_mask & 0x80000000U | uVar7)) {
                iVar4 = *(int *)((int)actions + iVar3);
                goto LAB_080d90b0;
              }
              iVar2 = iVar2 + 1;
              if (iVar4 <= iVar2) break;
              uVar1 = *puVar5;
              puVar5 = puVar5 + 1;
              iVar3 = iVar3 + 4;
            }
          }
          uVar7 = uVar7 - 1;
        } while (-1 < (int)uVar7);
      }
    }
  }
  return;
}



uint __regparm3 parse_mods(char *value)

{
  __int32_t **pp_Var1;
  int *piVar2;
  long lVar3;
  char *pcVar4;
  char cVar5;
  uint uVar6;
  
  cVar5 = *value;
  if (cVar5 != '\0') {
    pp_Var1 = __ctype_tolower_loc();
    pcVar4 = value;
    do {
      *pcVar4 = (char)(*pp_Var1)[cVar5];
      pcVar4 = pcVar4 + 1;
      cVar5 = *pcVar4;
    } while (cVar5 != '\0');
  }
  pcVar4 = strstr(value,"mod");
  if (pcVar4 != (char *)0x0) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    lVar3 = strtol(pcVar4 + 3,(char **)0x0,0);
    if (*piVar2 == 0) {
      uVar6 = 1 << ((char)lVar3 + 1U & 0x1f);
      goto LAB_080d918a;
    }
  }
  uVar6 = 0;
LAB_080d918a:
  pcVar4 = strstr(value,"shift");
  if (pcVar4 != (char *)0x0) {
    uVar6 = uVar6 | 1;
  }
  pcVar4 = strstr(value,"ctrl");
  if (pcVar4 != (char *)0x0) {
    uVar6 = uVar6 | 2;
  }
  pcVar4 = strstr(value,"alt");
  if (pcVar4 != (char *)0x0) {
    uVar6 = uVar6 | 4;
  }
  pcVar4 = strstr(value,"up");
  if (pcVar4 != (char *)0x0) {
    uVar6 = uVar6 | 0x80000000;
  }
  return uVar6;
}



Resource * __regparm3 res_wrap(char *value)

{
  Resource *n;
  
  n = resource_create((Resource *)0x0);
  resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
  return n;
}



void load_mouse_resource(Resource *res)

{
  char *__s1;
  ResourceVal *pRVar1;
  Resource *pRVar2;
  char **ppcVar3;
  int iVar4;
  long lVar5;
  uint uVar6;
  uint *puVar7;
  size_t __size;
  int iVar8;
  Resource **ppRVar9;
  int iVar10;
  int local_30;
  int local_2c;
  int local_24;
  int local_20;
  
  __size = 0;
  button_count = res->c;
  button_nums = (int *)malloc(button_count << 2);
  mod_count = (int *)malloc(res->c << 2);
  if (0 < res->c) {
    pRVar1 = res->v;
    iVar4 = 0;
    do {
      __size = (__size + 1) - (uint)(pRVar1->value == (char *)0x0);
      if (pRVar1->subres != (Resource *)0x0) {
        __size = __size + pRVar1->subres->c;
      }
      iVar4 = iVar4 + 1;
      pRVar1 = pRVar1 + 1;
    } while (iVar4 != res->c);
    __size = __size << 2;
  }
  mods = (uint *)malloc(__size);
  actions = (Resource **)malloc(__size);
  if (0 < res->c) {
    local_30 = 0;
    local_24 = 0;
    local_2c = 0;
    do {
      __s1 = *(char **)((int)&res->v->name + local_30);
      if (__s1 != (char *)0x0) {
        iVar4 = strcasecmp(__s1,"left");
        lVar5 = 1;
        if (iVar4 != 0) {
          iVar4 = strcasecmp(__s1,"middle");
          lVar5 = 2;
          if (iVar4 != 0) {
            iVar4 = strcasecmp(__s1,"right");
            lVar5 = 3;
            if (iVar4 != 0) {
              iVar4 = strcasecmp(__s1,"up");
              lVar5 = 4;
              if (iVar4 != 0) {
                iVar4 = strcasecmp(__s1,"down");
                lVar5 = 5;
                if ((iVar4 != 0) && (lVar5 = strtol(__s1,(char **)0x0,10), lVar5 < 0))
                goto LAB_080d9570;
              }
            }
          }
        }
        button_nums[local_2c] = lVar5;
        mod_count[local_2c] = 0;
        iVar4 = (int)&res->v->name + local_30;
        if (*(int *)(iVar4 + 4) != 0) {
          mods[local_24] = 0;
          ppRVar9 = actions + local_24;
          pRVar2 = res_wrap(*(char **)((int)&res->v->value + local_30));
          local_24 = local_24 + 1;
          *ppRVar9 = pRVar2;
          mod_count[local_2c] = 1;
          iVar4 = (int)&res->v->name + local_30;
        }
        iVar4 = *(int *)(iVar4 + 8);
        if ((iVar4 != 0) &&
           (mod_count[local_2c] = mod_count[local_2c] + *(int *)(iVar4 + 0xc),
           0 < *(int *)(iVar4 + 0xc))) {
          iVar8 = 0;
          local_20 = 0;
          iVar10 = local_24 << 2;
          do {
            ppcVar3 = (char **)(*(int *)(iVar4 + 0x10) + iVar8);
            __s1 = *ppcVar3;
            uVar6 = (~-(uint)(__s1 == (char *)0x0) & 100) + (uint)(ppcVar3[2] != (char *)0x0) +
                    (~-(uint)(ppcVar3[1] == (char *)0x0) & 10);
            if (uVar6 == 10) {
              *(undefined4 *)((int)mods + iVar10) = 0;
LAB_080d94e2:
              ppRVar9 = (Resource **)((int)actions + iVar10);
              pRVar2 = res_wrap(*(char **)(*(int *)(iVar4 + 0x10) + 4 + iVar8));
              *ppRVar9 = pRVar2;
            }
            else {
              if (uVar6 < 0xb) {
                if (uVar6 == 1) {
                  *(undefined4 *)((int)mods + iVar10) = 0;
                  *(undefined4 *)((int)actions + iVar10) =
                       *(undefined4 *)(*(int *)(iVar4 + 0x10) + 8 + iVar8);
                }
              }
              else {
                if (uVar6 == 0x65) {
                  puVar7 = (uint *)((int)mods + iVar10);
                  uVar6 = parse_mods(__s1);
                  *puVar7 = uVar6;
                  *(undefined4 *)((int)actions + iVar10) =
                       *(undefined4 *)(*(int *)(iVar4 + 0x10) + 8 + iVar8);
                }
                else {
                  if (uVar6 == 0x6e) {
                    puVar7 = (uint *)((int)mods + iVar10);
                    uVar6 = parse_mods(__s1);
                    *puVar7 = uVar6;
                    goto LAB_080d94e2;
                  }
                }
              }
            }
            local_20 = local_20 + 1;
            iVar8 = iVar8 + 0xc;
            iVar10 = iVar10 + 4;
            local_24 = local_24 + 1;
          } while (*(int *)(iVar4 + 0xc) != local_20 && local_20 <= *(int *)(iVar4 + 0xc));
        }
      }
LAB_080d9570:
      local_2c = local_2c + 1;
      local_30 = local_30 + 0xc;
    } while (res->c != local_2c && local_2c <= res->c);
  }
  return;
}



void toporouter_edge_init(toporouter_edge_t *edge)

{
  edge->routing = (GList *)0x0;
  edge->flags = 0;
  return;
}



void toporouter_bbox_init(toporouter_bbox_t *box)

{
  box->data = (void *)0x0;
  box->type = OTHER;
  box->constraints = (GList *)0x0;
  box->cluster = (_toporouter_cluster_t *)0x0;
  return;
}



void toporouter_vertex_class_init(toporouter_vertex_class_t *klass)

{
  return;
}



void toporouter_vertex_init(toporouter_vertex_t *vertex)

{
  vertex->gcost = 0.00000000;
  vertex->bbox = (_toporouter_bbox_t *)0x0;
  vertex->parent = (_toporouter_vertex_t *)0x0;
  vertex->child = (_toporouter_vertex_t *)0x0;
  vertex->flags = 0;
  vertex->routingedge = (toporouter_edge_t *)0x0;
  vertex->arc = (_toporouter_arc_t *)0x0;
  vertex->oproute = (_toporouter_oproute_t *)0x0;
  vertex->route = (_toporouter_route_t *)0x0;
  vertex->hcost = 0.00000000;
  vertex->gn = 0;
  return;
}



void toporouter_constraint_class_init(toporouter_constraint_class_t *klass)

{
  return;
}



void toporouter_constraint_init(toporouter_constraint_t *constraint)

{
  constraint->box = (toporouter_bbox_t *)0x0;
  constraint->routing = (GList *)0x0;
  return;
}



void toporouter_arc_init(toporouter_arc_t *arc)

{
  arc->x0 = -1.00000000;
  arc->centre = (toporouter_vertex_t *)0x0;
  arc->y0 = -1.00000000;
  arc->v = (toporouter_vertex_t *)0x0;
  arc->x1 = -1.00000000;
  arc->v1 = (toporouter_vertex_t *)0x0;
  arc->y1 = -1.00000000;
  arc->v2 = (toporouter_vertex_t *)0x0;
  arc->r = -1.00000000;
  arc->dir = 0x7a69;
  arc->clearance = (GList *)0x0;
  arc->oproute = (toporouter_oproute_t *)0x0;
  return;
}



void toporouter_output_close(drawing_context_t *dc)

{
  return;
}



gint toporouter_draw_vertex(gpointer item,gpointer data)

{
  return -1;
}



gint toporouter_draw_edge(gpointer item,gpointer data)

{
  return -1;
}



toporouter_bbox_t * vertex_bbox(toporouter_vertex_t *v)

{
  toporouter_bbox_t *ptVar1;
  
  ptVar1 = (toporouter_bbox_t *)0x0;
  if (v != (toporouter_vertex_t *)0x0) {
    ptVar1 = (toporouter_bbox_t *)v->bbox;
  }
  return ptVar1;
}



char * vertex_netlist(toporouter_vertex_t *v)

{
  _toporouter_cluster_t *p_Var1;
  
  if (((v != (toporouter_vertex_t *)0x0) && (v->bbox != (_toporouter_bbox_t *)0x0)) &&
     (p_Var1 = v->bbox->cluster, p_Var1 != (_toporouter_cluster_t *)0x0)) {
    return p_Var1->netlist->netlist;
  }
  return (char *)0x0;
}



char * constraint_netlist(toporouter_constraint_t *c)

{
  _toporouter_cluster_t *p_Var1;
  
  if ((c->box != (toporouter_bbox_t *)0x0) &&
     (p_Var1 = c->box->cluster, p_Var1 != (_toporouter_cluster_t *)0x0)) {
    return p_Var1->netlist->netlist;
  }
  return (char *)0x0;
}



int point_wind(GtsPoint *a,GtsPoint *b,GtsPoint *c)

{
  double dVar1;
  int iVar2;
  
  iVar2 = 1;
  dVar1 = ((double)c->y - (double)b->y) * ((double)b->x - (double)a->x) -
          ((double)c->x - (double)b->x) * ((double)b->y - (double)a->y);
  if (dVar1 <= 0.00010000) {
    iVar2 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  return iVar2;
}



int sloppy_point_wind(GtsPoint *a,GtsPoint *b,GtsPoint *c)

{
  double dVar1;
  int iVar2;
  
  iVar2 = 1;
  dVar1 = ((double)c->y - (double)b->y) * ((double)b->x - (double)a->x) -
          ((double)c->x - (double)b->x) * ((double)b->y - (double)a->y);
  if (dVar1 <= 10.00000000) {
    iVar2 = (uint)(-10.00000000 <= dVar1) - 1;
  }
  return iVar2;
}



void toporouter_draw_cluster
               (toporouter_t *r,drawing_context_t *dc,toporouter_cluster_t *cluster,gdouble red,
               gdouble green,gdouble blue,guint layer)

{
  return;
}



void toporouter_draw_surface
               (toporouter_t *r,GtsSurface *s,char *filename,int w,int h,int mode,GList *datas,
               int layer,GList *candidatepoints)

{
  return;
}



guint groupcount(void)

{
  int iVar1;
  guint gVar2;
  int iVar3;
  
  iVar3 = 0;
  iVar1 = PCB->Data->LayerN;
  gVar2 = 0;
  if (0 < iVar1) {
    do {
      gVar2 = (gVar2 + 1) - (uint)((PCB->LayerGroups).Number[iVar3] == 0);
      iVar3 = iVar3 + 1;
    } while (iVar3 != iVar1);
  }
  return gVar2;
}



int wind(toporouter_spoint_t *p1,toporouter_spoint_t *p2,toporouter_spoint_t *p3)

{
  double dVar1;
  int iVar2;
  
  iVar2 = 1;
  dVar1 = ((double)p3->y - (double)p2->y) * ((double)p2->x - (double)p1->x) -
          ((double)p3->x - (double)p2->x) * ((double)p2->y - (double)p1->y);
  if (dVar1 <= 0.00010000) {
    iVar2 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  return iVar2;
}



int wind_double(gdouble p1_x,gdouble p1_y,gdouble p2_x,gdouble p2_y,gdouble p3_x,gdouble p3_y)

{
  double dVar1;
  int iVar2;
  
  iVar2 = 1;
  dVar1 = ((double)p3_y - (double)p2_y) * ((double)p2_x - (double)p1_x) -
          ((double)p3_x - (double)p2_x) * ((double)p2_y - (double)p1_y);
  if (dVar1 <= 0.00010000) {
    iVar2 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  return iVar2;
}



float10 vertex_gradient(double *a,double *b)

{
  if ((float10)*a != (float10)*b) {
    return ((float10)b[1] - (float10)a[1]) / ((float10)*b - (float10)*a);
  }
  return (float10)INFINITY;
}



// WARNING: Removing unreachable block (ram,0x080d99b2)

float10 segment_gradient(int s)

{
  float10 fVar1;
  float10 fVar2;
  
  fVar1 = (float10)*(double *)(*(int *)(s + 0x10) + 0xc);
  fVar2 = (float10)*(double *)(*(int *)(s + 0xc) + 0xc);
  if (fVar1 != fVar2) {
    return ((float10)*(double *)(*(int *)(s + 0x10) + 0x14) -
           (float10)*(double *)(*(int *)(s + 0xc) + 0x14)) / (fVar1 - fVar2);
  }
  return (float10)INFINITY;
}



float10 perpendicular_gradient(double m)

{
  if ((float10)m <=
      (float10)
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     ) {
    return (float10)-1.00000000 / (float10)m;
  }
  return (float10)0;
}



gint coord_intersect_prop
               (gdouble ax,gdouble ay,gdouble bx,gdouble by,gdouble cx,gdouble cy,gdouble dx,
               gdouble dy)

{
  double dVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  iVar7 = 1;
  dVar2 = ((double)cy - (double)by) * ((double)bx - (double)ax) -
          ((double)cx - (double)bx) * ((double)by - (double)ay);
  if (dVar2 <= 0.00010000) {
    iVar7 = (uint)(-0.00010000 <= dVar2) - 1;
  }
  iVar6 = 1;
  dVar3 = ((double)dy - (double)by) * ((double)bx - (double)ax) -
          ((double)dx - (double)bx) * ((double)by - (double)ay);
  if (dVar3 <= 0.00010000) {
    iVar6 = (uint)(-0.00010000 <= dVar3) - 1;
  }
  iVar5 = 1;
  dVar1 = ((double)ay - (double)dy) * ((double)dx - (double)cx) -
          ((double)ax - (double)dx) * ((double)dy - (double)cy);
  if (dVar1 <= 0.00010000) {
    iVar5 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  iVar4 = 1;
  dVar1 = ((double)by - (double)dy) * ((double)dx - (double)cx) -
          ((double)dy - (double)cy) * ((double)bx - (double)dx);
  if (dVar1 <= 0.00010000) {
    iVar4 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  if ((((0.00010000 < dVar3 || dVar3 < -0.00010000) && (0.00010000 < dVar2 || dVar2 < -0.00010000))
      && (iVar4 != 0)) && (iVar5 != 0)) {
    return (uint)(iVar5 != iVar4 && iVar7 != iVar6);
  }
  return 0;
}



int point_intersect_prop(GtsPoint *a,GtsPoint *b,GtsPoint *c,GtsPoint *d)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  int iVar10;
  int iVar11;
  
  dVar5 = (double)b->x;
  dVar4 = dVar5 - (double)a->x;
  dVar1 = (double)b->y;
  dVar6 = dVar1 - (double)a->y;
  dVar8 = ((double)c->y - dVar1) * dVar4 - ((double)c->x - dVar5) * dVar6;
  if ((0.00010000 < dVar8) || (dVar8 < -0.00010000)) {
    dVar2 = (double)d->x;
    dVar3 = (double)d->y;
    dVar4 = (dVar3 - dVar1) * dVar4 - (dVar2 - dVar5) * dVar6;
    if ((0.00010000 < dVar4) || (dVar4 < -0.00010000)) {
      dVar9 = dVar2 - (double)c->x;
      dVar7 = dVar3 - (double)c->y;
      dVar6 = ((double)a->y - dVar3) * dVar9 - ((double)a->x - dVar2) * dVar7;
      if ((0.00010000 < dVar6) || (dVar6 < -0.00010000)) {
        dVar5 = (dVar1 - dVar3) * dVar9 - (dVar5 - dVar2) * dVar7;
        if ((0.00010000 < dVar5) || (dVar5 < -0.00010000)) {
          iVar11 = 1;
          if (dVar8 <= 0.00010000) {
            iVar11 = (uint)(-0.00010000 <= dVar8) - 1;
          }
          iVar10 = 1;
          if (dVar4 <= 0.00010000) {
            iVar10 = (uint)(-0.00010000 <= dVar4) - 1;
          }
          if (iVar11 != iVar10) {
            iVar11 = 1;
            if (dVar6 <= 0.00010000) {
              iVar11 = (uint)(-0.00010000 <= dVar6) - 1;
            }
            iVar10 = 1;
            if (dVar5 <= 0.00010000) {
              iVar10 = (uint)(-0.00010000 <= dVar5) - 1;
            }
            return (uint)(iVar11 != iVar10);
          }
        }
      }
    }
  }
  return 0;
}



void coord_intersect(gdouble ax,gdouble ay,gdouble bx,gdouble by,gdouble cx,gdouble cy,gdouble dx,
                    gdouble dy,gdouble *rx,gdouble *ry)

{
  double dVar1;
  
  dVar1 = (((double)dy - (double)cy) * ((double)bx - (double)ax) -
          ((double)dx - (double)cx) * ((double)by - (double)ay)) /
          (((double)ay - (double)cy) * ((double)dx - (double)cx) -
          ((double)ax - (double)cx) * ((double)dy - (double)cy));
  *(double *)rx = ((double)bx - (double)ax) * dVar1 + (double)ax;
  *(double *)ry = (double)ay + dVar1 * ((double)by - (double)ay);
  return;
}



// WARNING: Removing unreachable block (ram,0x080d9ee2)

int point_between(GtsPoint *a,GtsPoint *b,GtsPoint *c)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  
  dVar1 = (double)b->x;
  dVar2 = (double)a->x;
  dVar3 = (double)b->y;
  dVar4 = (double)a->y;
  dVar5 = (double)c->x;
  dVar6 = (double)c->y;
  dVar7 = (dVar6 - dVar3) * (dVar1 - dVar2) - (dVar5 - dVar1) * (dVar3 - dVar4);
  if ((dVar7 <= 0.00010000) && (-0.00010000 <= dVar7)) {
    if (dVar1 == dVar2) {
      if ((dVar4 <= dVar6) && (dVar6 <= dVar3)) {
        return 1;
      }
      if (dVar6 <= dVar4) {
        return (uint)(dVar3 <= dVar6);
      }
    }
    else {
      if ((dVar2 <= dVar5) && (dVar5 <= dVar1)) {
        return 1;
      }
      if (dVar5 <= dVar2) {
        return (uint)(dVar1 <= dVar5);
      }
    }
  }
  return 0;
}



gint visited_cmp(gconstpointer a,gconstpointer b)

{
  uint uVar1;
  
  uVar1 = 0xffffffff;
  if (b <= a) {
    uVar1 = (uint)(b < a);
  }
  return uVar1;
}



// WARNING: Removing unreachable block (ram,0x080d9fa2)
// WARNING: Removing unreachable block (ram,0x080d9f9c)

gint compare_points(gconstpointer a,gconstpointer b)

{
  double dVar1;
  double dVar2;
  
  dVar1 = *(double *)((int)a + 0xc);
  dVar2 = *(double *)((int)b + 0xc);
  if (dVar1 == dVar2) {
    dVar1 = *(double *)((int)a + 0x14);
    dVar2 = *(double *)((int)b + 0x14);
    if (dVar1 == dVar2) {
      return 0;
    }
  }
  if (dVar1 < dVar2) {
    return -1;
  }
  return 1;
}



gint compare_segments(gconstpointer a,gconstpointer b)

{
  if (a == b) {
    return 0;
  }
  return -(uint)(a < b) | 1;
}



float10 route_heap_cmp(int item)

{
  return (float10)*(double *)(item + 0x3c) + (float10)*(double *)(item + 0x44);
}



void toporouter_heap_search(gpointer data,gpointer user_data)

{
  if (*(gpointer *)user_data != data) {
    return;
  }
  *(gpointer *)((int)user_data + 4) = *(gpointer *)user_data;
  return;
}



void toporouter_heap_color(gpointer data,gpointer user_data)

{
  *(uint *)((int)data + 0x38) = *(uint *)((int)data + 0x38) | (uint)user_data;
  return;
}



gint vertex_keepout_test(toporouter_t *r,toporouter_vertex_t *v)

{
  double dVar1;
  GList *pGVar2;
  
  pGVar2 = r->keepoutlayers;
  if (pGVar2 != (GList *)0x0) {
    dVar1 = *(double *)pGVar2->data;
    while( true ) {
      if ((double)(v->v).p.z == dVar1) {
        return 1;
      }
      pGVar2 = pGVar2->next;
      if (pGVar2 == (GList *)0x0) break;
      dVar1 = *(double *)pGVar2->data;
    }
  }
  return 0;
}



void swap_vertices(toporouter_vertex_t **v1,toporouter_vertex_t **v2)

{
  toporouter_vertex_t *ptVar1;
  
  ptVar1 = *v1;
  *v1 = *v2;
  *v2 = ptVar1;
  return;
}



guint candidate_is_available(toporouter_vertex_t *v)

{
  toporouter_vertex_t *in_stack_00000008;
  
  if (v == (toporouter_vertex_t *)0x0) {
    return 1;
  }
  if (v != in_stack_00000008) {
    do {
      v = (toporouter_vertex_t *)v->parent;
      if (v == (toporouter_vertex_t *)0x0) {
        return 1;
      }
    } while (in_stack_00000008 != v);
  }
  return 0;
}



gint vertices_connected(toporouter_vertex_t *a,toporouter_vertex_t *b)

{
  if (a->route->netlist != b->route->netlist) {
    return 0;
  }
  return (uint)(a->route->src->c == b->route->src->c);
}



void path_set_oproute(GList *path,toporouter_oproute_t *oproute)

{
  if (path != (GList *)0x0) {
    do {
      if ((*(byte *)((int)path->data + 0x39) & 1) != 0) {
        *(toporouter_oproute_t **)((int)path->data + 0x54) = oproute;
      }
      path = path->next;
    } while (path != (GList *)0x0);
  }
  return;
}



gint compare_rubberband_arcs(toporouter_rubberband_arc_t *a,toporouter_rubberband_arc_t *b)

{
  return (int)ROUND((double)b->d - (double)a->d);
}



void speccut_edge_patch_links(toporouter_edge_t *e)

{
  GList *pGVar1;
  gpointer pvVar2;
  
  pGVar1 = e->routing;
  while (pGVar1 != (GList *)0x0) {
    pvVar2 = pGVar1->data;
    pGVar1 = pGVar1->next;
    *(gpointer *)(*(int *)((int)pvVar2 + 0x2c) + 0x30) = pvVar2;
    *(gpointer *)(*(int *)((int)pvVar2 + 0x30) + 0x2c) = pvVar2;
  }
  return;
}



gint compare_routedata_ascending(gconstpointer a,gconstpointer b)

{
  return (int)ROUND(*(double *)((int)a + 0x14) - *(double *)((int)b + 0x14));
}



void cluster_merge(toporouter_route_t *routedata)

{
  int iVar1;
  int iVar2;
  GPtrArray *pGVar3;
  int **ppiVar4;
  guint gVar5;
  int *piVar6;
  int **ppiVar7;
  
  iVar1 = routedata->dest->c;
  iVar2 = routedata->src->c;
  pGVar3 = routedata->netlist->clusters;
  ppiVar4 = (int **)pGVar3->pdata;
  gVar5 = pGVar3->len;
  ppiVar7 = ppiVar4 + (gVar5 - 1);
  if ((ppiVar4 <= ppiVar7) && (gVar5 != 0)) {
    do {
      while (piVar6 = *ppiVar7, *piVar6 != iVar1) {
        ppiVar7 = ppiVar7 + -1;
        if (ppiVar7 < ppiVar4) {
          return;
        }
      }
      ppiVar7 = ppiVar7 + -1;
      *piVar6 = iVar2;
    } while (ppiVar4 <= ppiVar7);
  }
  return;
}



void netlists_rollback(GList *netlists)

{
  int *piVar1;
  int *piVar2;
  undefined4 *puVar3;
  int *piVar4;
  
  if (netlists != (GList *)0x0) {
    do {
      piVar1 = **(int ***)netlists->data;
      piVar2 = (*(int ***)netlists->data)[1];
      piVar4 = piVar1 + ((int)piVar2 - 1);
      if ((piVar1 <= piVar4) && (piVar2 != (int *)0x0)) {
        do {
          puVar3 = (undefined4 *)*piVar4;
          piVar4 = piVar4 + -1;
          *puVar3 = puVar3[1];
        } while (piVar1 <= piVar4);
      }
      netlists = netlists->next;
    } while (netlists != (GList *)0x0);
  }
  return;
}



gint route_detour_compare(toporouter_route_t **a,toporouter_route_t **b)

{
  return (int)ROUND(((double)(*b)->score - (double)(*b)->detourscore) -
                    ((double)(*a)->score - (double)(*a)->detourscore));
}



void register_toporouter_action_list(void)

{
  hid_register_actions(toporouter_action_list,2);
  return;
}



void hid_toporouter_init(void)

{
  register_toporouter_action_list();
  return;
}



// WARNING: Removing unreachable block (ram,0x080da3a7)
// WARNING: Removing unreachable block (ram,0x080da350)
// WARNING: Removing unreachable block (ram,0x080da354)
// WARNING: Removing unreachable block (ram,0x080da358)
// WARNING: Removing unreachable block (ram,0x080da3ab)
// WARNING: Removing unreachable block (ram,0x080da3b0)

void arc_ortho_projections(toporouter_arc_t *arc,toporouter_arc_t *narc,gdouble *b1,gdouble *b2)

{
  toporouter_vertex_t *ptVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  
  ptVar1 = arc->centre;
  dVar2 = (double)(narc->centre->v).p.x - (double)(ptVar1->v).p.x;
  dVar6 = (double)(narc->centre->v).p.y - (double)(ptVar1->v).p.y;
  dVar3 = (double)arc->x0 - (double)(ptVar1->v).p.x;
  dVar4 = (double)arc->y0 - (double)(ptVar1->v).p.y;
  dVar5 = (dVar2 * dVar2 + dVar6 * dVar6) / (dVar4 * dVar6 + dVar3 * dVar2);
  dVar2 = dVar2 * dVar5;
  dVar5 = dVar5 * dVar6;
  *(double *)b1 = SQRT(dVar5 * dVar5 + dVar2 * dVar2);
  dVar3 = dVar3 - dVar2;
  dVar4 = dVar4 - dVar5;
  *(double *)b2 = SQRT(dVar4 * dVar4 + dVar3 * dVar3);
  return;
}



// WARNING: Removing unreachable block (ram,0x080da3f6)
// WARNING: Removing unreachable block (ram,0x080da3fa)
// WARNING: Removing unreachable block (ram,0x080da400)

float10 vertices_plane_distance(double *a,double *b)

{
  return SQRT(((float10)a[1] - (float10)b[1]) * ((float10)a[1] - (float10)b[1]) +
              ((float10)*a - (float10)*b) * ((float10)*a - (float10)*b));
}



// WARNING: Removing unreachable block (ram,0x080da4e0)
// WARNING: Removing unreachable block (ram,0x080da4d5)
// WARNING: Removing unreachable block (ram,0x080da4e2)

void points_on_line(GtsPoint *a,gdouble m,gdouble r,GtsPoint *b0,GtsPoint *b1)

{
  double dVar1;
  double dVar2;
  
  if ((
       179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
       < (double)m) ||
     ((double)m <
            
      -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     )) {
    *(double *)&b0->y = (double)a->y + (double)r;
    *(double *)&b1->y = (double)a->y - (double)r;
    b0->x = a->x;
    b1->x = a->x;
  }
  else {
    dVar1 = (double)a->y - (double)a->x * (double)m;
    dVar2 = SQRT(((double)r * (double)r) / ((double)m * (double)m + 1.00000000));
    *(double *)&b0->x = (double)a->x + dVar2;
    dVar2 = (double)a->x - dVar2;
    *(double *)&b1->x = dVar2;
    *(double *)&b0->y = (double)b0->x * (double)m + dVar1;
    *(double *)&b1->y = dVar1 + dVar2 * (double)m;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080da5b0)
// WARNING: Removing unreachable block (ram,0x080da5a6)
// WARNING: Removing unreachable block (ram,0x080da5b2)

void coords_on_line(gdouble ax,gdouble ay,gdouble m,gdouble r,gdouble *b0x,gdouble *b0y,gdouble *b1x
                   ,gdouble *b1y)

{
  double dVar1;
  double dVar2;
  
  if ((
       179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
       < (double)m) ||
     ((double)m <
            
      -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     )) {
    *(double *)b0y = (double)ay + (double)r;
    *(double *)b1y = (double)ay - (double)r;
    *b0x = ax;
    *b1x = ax;
  }
  else {
    dVar2 = (double)ay - (double)m * (double)ax;
    dVar1 = SQRT(((double)r * (double)r) / ((double)m * (double)m + 1.00000000));
    *(double *)b0x = (double)ax + dVar1;
    *(double *)b1x = (double)ax - dVar1;
    *(double *)b0y = (double)*b0x * (double)m + dVar2;
    *(double *)b1y = (double)m * (double)*b1x + dVar2;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080da690)
// WARNING: Removing unreachable block (ram,0x080da687)
// WARNING: Removing unreachable block (ram,0x080da692)

void vertices_on_line(toporouter_spoint_t *a,gdouble m,gdouble r,toporouter_spoint_t *b0,
                     toporouter_spoint_t *b1)

{
  double dVar1;
  double dVar2;
  
  if ((
       179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
       < (double)m) ||
     ((double)m <
            
      -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     )) {
    *(double *)&b0->y = (double)a->y + (double)r;
    *(double *)&b1->y = (double)a->y - (double)r;
    b0->x = a->x;
    b1->x = a->x;
  }
  else {
    dVar1 = (double)a->y - (double)a->x * (double)m;
    dVar2 = SQRT(((double)r * (double)r) / ((double)m * (double)m + 1.00000000));
    *(double *)&b0->x = (double)a->x + dVar2;
    dVar2 = (double)a->x - dVar2;
    *(double *)&b1->x = dVar2;
    *(double *)&b0->y = (double)b0->x * (double)m + dVar1;
    *(double *)&b1->y = dVar1 + dVar2 * (double)m;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080da7d0)
// WARNING: Removing unreachable block (ram,0x080da7ca)
// WARNING: Removing unreachable block (ram,0x080da7d2)

float10 export_pcb_drawline(int layer,int x0,int y0,int x1,int y1,BDimension thickness,
                           BDimension keepaway)

{
  LineTypePtr Ptr2;
  int in_GS_OFFSET;
  float10 fVar1;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  MakeFlags((FlagType *)&local_2c,(-(uint)(((PCB->Flags).f & 0x800) == 0) & 0xffffffe0) + 0xa0);
  Ptr2 = CreateDrawnLineOnLayer
                   ((LayerTypePtr)(&PCB->Data->field_0x4c + layer * 0x5c),x0,y0,x1,y1,thickness,
                    keepaway,(FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
  if (Ptr2 == (LineTypePtr)0x0) {
    fVar1 = (float10)0;
  }
  else {
    AddObjectToCreateUndoList(4,(void *)(&PCB->Data->field_0x4c + layer * 0x5c),Ptr2,Ptr2);
    fVar1 = SQRT((float10)(ulonglong)(uint)(y0 - y1) * (float10)(ulonglong)(uint)(y0 - y1) +
                 (float10)(ulonglong)(uint)(x0 - x1) * (float10)(ulonglong)(uint)(x0 - x1)) /
            (float10)100.00000000;
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return fVar1;
}



// WARNING: Removing unreachable block (ram,0x080da904)
// WARNING: Removing unreachable block (ram,0x080da900)
// WARNING: Removing unreachable block (ram,0x080da908)
// WARNING: Removing unreachable block (ram,0x080da92e)
// WARNING: Removing unreachable block (ram,0x080da92a)
// WARNING: Removing unreachable block (ram,0x080da930)
// WARNING: Could not reconcile some variable overlaps

int escape(int argc,char **argv,int x,int y)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  float10 fVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  int iVar8;
  long lVar9;
  DataTypePtr *pDVar10;
  PinTypePtr *Via;
  LineTypePtr Line;
  void *Ptr1;
  LayerTypePtr Layer;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  uint uVar15;
  int in_GS_OFFSET;
  float10 fVar16;
  int local_70;
  int local_6c;
  uint local_5c;
  uint local_58;
  ulonglong local_44;
  ulong local_38;
  undefined4 local_34;
  undefined4 local_30;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar8 = 0;
  if (argc == 1) {
    lVar9 = strtol(*argv,(char **)0x0,10);
    pDVar10 = PCB->Data;
    local_6c = pDVar10->ElementN - 1;
    if (local_6c != -1) {
      iVar8 = pDVar10->ElementN * 300;
      do {
        local_70 = iVar8 + -300;
        uVar15 = 0;
        iVar8 = (int)&pDVar10->Element[-1].BoundingBox.X1 + iVar8;
        uVar2 = *(uint *)(iVar8 + 0xe8);
        iVar14 = 0;
        uVar11 = uVar2;
        while ((uVar11 != 0 && (uVar15 < uVar11))) {
          iVar3 = *(int *)(iVar8 + 0x104);
          iVar1 = iVar3 + iVar14;
          if ((*(byte *)(iVar1 + 0x14) & 0x40) == 0) goto LAB_080da8ae;
          uVar12 = *(int *)(iVar3 + 0x2c) - *(int *)(iVar3 + 0x94);
          uVar11 = (int)uVar12 >> 0x1f;
          uVar13 = *(int *)(iVar3 + 0x30) - *(int *)(iVar3 + 0x98);
          dVar5 = (double)((uVar12 ^ uVar11) - uVar11);
          uVar11 = (int)uVar13 >> 0x1f;
          dVar6 = (double)((uVar13 ^ uVar11) - uVar11);
          dVar5 = SQRT(dVar6 * dVar6 + dVar5 * dVar5);
          dVar6 = SQRT(dVar5 * dVar5 + dVar5 * dVar5) * 0.50000000;
          dVar7 = dVar6 * 0.70710678;
          dVar6 = dVar6 * 0.70710678;
          switch(lVar9) {
          case 0:
          case 5:
          default:
            __printf_chk(1,"ERROR: escape() with bad direction (%d)\n",lVar9);
            iVar8 = 1;
            goto LAB_080da810;
          case 1:
            dVar7 = (double)*(int *)(iVar1 + 0x2c) - dVar7;
            break;
          case 2:
            local_5c = *(uint *)(iVar1 + 0x2c);
            iVar3 = *(int *)(iVar1 + 0x30);
            dVar5 = dVar5 * 0.50000000;
            goto LAB_080dac35;
          case 3:
            dVar7 = (double)*(int *)(iVar1 + 0x2c) + dVar7;
            break;
          case 4:
            dVar5 = dVar5 * -0.50000000 + (double)*(int *)(iVar1 + 0x2c);
            goto LAB_080dac8f;
          case 6:
            dVar5 = dVar5 * 0.50000000 + (double)*(int *)(iVar1 + 0x2c);
LAB_080dac8f:
            local_44 = (ulonglong)ROUND(dVar5);
            local_5c = (uint)local_44;
            local_58 = *(uint *)(iVar1 + 0x30);
            goto LAB_080da9eb;
          case 7:
            dVar7 = (double)*(int *)(iVar1 + 0x2c) - dVar7;
            goto LAB_080da9b9;
          case 8:
            iVar3 = *(int *)(iVar1 + 0x30);
            dVar5 = dVar5 * -0.50000000;
            local_5c = *(uint *)(iVar1 + 0x2c);
LAB_080dac35:
            local_44._0_4_ = (uint)(longlong)ROUND(dVar5 + (double)iVar3);
            local_58 = (uint)local_44;
            goto LAB_080da9eb;
          case 9:
            dVar7 = (double)*(int *)(iVar1 + 0x2c) + dVar7;
LAB_080da9b9:
            local_44._0_4_ = (uint)(longlong)ROUND(dVar7);
            dVar6 = (double)*(int *)(iVar1 + 0x30) - dVar6;
            local_5c = (uint)local_44;
            goto LAB_080da9dc;
          }
          local_44._0_4_ = (uint)(longlong)ROUND(dVar7);
          local_5c = (uint)local_44;
          dVar6 = (double)*(int *)(iVar1 + 0x30) + dVar6;
LAB_080da9dc:
          local_44._0_4_ = (uint)(longlong)ROUND(dVar6);
          local_58 = (uint)local_44;
LAB_080da9eb:
          MakeFlags((FlagType *)&local_2c,0);
          Via = CreateNewVia(PCB->Data,local_5c,local_58,Settings.ViaThickness,Settings.Keepaway * 2
                             ,0,Settings.ViaDrillingHole,(char *)0x0,
                             (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
          if (Via == (PinTypePtr *)0x0) {
LAB_080dad38:
            uVar11 = *(uint *)(iVar8 + 0xe8);
          }
          else {
            AddObjectToCreateUndoList(1,Via,Via,Via);
            DrawVia(Via,0);
            MakeFlags((FlagType *)&local_38,0);
            if (PCB->SilkActive == '\0') {
              Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
            }
            else {
              Layer = (LayerTypePtr)
                      (&PCB->Data->field_0x4c +
                      ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
            }
            local_44 = (ulonglong)local_58;
            fVar16 = (float10)local_44;
            fVar4 = (float10)1;
            local_44 = (ulonglong)local_5c;
            Line = CreateDrawnLineOnLayer
                             (Layer,(int)ROUND((float10)*(int *)(iVar1 + 0x2c) + fVar4),
                              (int)ROUND((float10)*(int *)(iVar1 + 0x30) + fVar4),
                              (int)ROUND((float10)local_44 + fVar4),(int)ROUND(fVar16 + fVar4),
                              Settings.LineThickness,Settings.Keepaway * 2,
                              (FlagType)CONCAT48(local_30,CONCAT44(local_34,local_38)));
            if (Line == (LineTypePtr)0x0) goto LAB_080dad38;
            if (PCB->SilkActive == '\0') {
              Ptr1 = (void *)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
            }
            else {
              Ptr1 = (void *)(&PCB->Data->field_0x4c +
                             ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
            }
            AddObjectToCreateUndoList(4,Ptr1,Line,Line);
            if (PCB->SilkActive == '\0') {
              Layer = (LayerTypePtr)(&PCB->Data->field_0x4c + LayerStack[0] * 0x5c);
            }
            else {
              Layer = (LayerTypePtr)
                      (&PCB->Data->field_0x4c +
                      ((uint)(Settings.ShowSolderSide == '\0') + PCB->Data->LayerN) * 0x5c);
            }
            DrawLine(Layer,Line,0);
            uVar11 = *(uint *)(iVar8 + 0xe8);
          }
LAB_080da8ae:
          if (uVar2 == uVar11) {
            uVar15 = uVar15 + 1;
            iVar14 = iVar14 + 0x68;
            uVar11 = uVar2;
          }
        }
        local_6c = local_6c + -1;
        if (local_6c == -1) break;
        pDVar10 = PCB->Data;
        iVar8 = local_70;
      } while( true );
    }
    IncrementUndoSerialNumber();
    Draw();
    iVar8 = 0;
  }
LAB_080da810:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void print_netlist(toporouter_netlist_t *netlist)

{
  char **ppcVar1;
  guint gVar2;
  GPtrArray *pGVar3;
  char **ppcVar4;
  char *local_14;
  
  local_14 = netlist->netlist;
  __printf_chk(1,"NETLIST %s: ",local_14);
  ppcVar1 = (char **)netlist->clusters->pdata;
  gVar2 = netlist->clusters->len;
  ppcVar4 = ppcVar1 + (gVar2 - 1);
  if (ppcVar1 <= ppcVar4) {
    while (gVar2 != 0) {
      ppcVar1 = (char **)*ppcVar4;
      ppcVar4 = ppcVar4 + -1;
      local_14 = *ppcVar1;
      __printf_chk(1,0x8151558,local_14);
      pGVar3 = netlist->clusters;
      if (ppcVar4 <= pGVar3->pdata && (char **)pGVar3->pdata != ppcVar4) break;
      gVar2 = pGVar3->len;
    }
  }
  __printf_chk(1,0x8151453,local_14);
  return;
}



void print_netscores(GPtrArray *netscores)

{
  char **ppcVar1;
  char **ppcVar2;
  char *local_34;
  undefined8 local_30;
  
  __printf_chk(1,"NETSCORES: \n\n");
  local_30 = 0x815145508151464;
  local_34 = "Score";
  __printf_chk(1,"     %15s %15s %15s\n----------------------------------------------------\n",
               "Score","Detour Sum","Pairwise Fails");
  ppcVar2 = (char **)netscores->pdata;
  if (ppcVar2 < ppcVar2 + netscores->len) {
    do {
      ppcVar1 = (char **)*ppcVar2;
      ppcVar2 = ppcVar2 + 1;
      local_30 = *(undefined8 *)(ppcVar1 + 4);
      local_34 = *ppcVar1;
      __printf_chk(1,"%4d %15f %15f %15d %15x\n",local_34,local_30,*(undefined8 *)(ppcVar1 + 2),
                   ppcVar1[6],ppcVar1);
    } while (ppcVar2 < netscores->pdata + netscores->len);
  }
  __printf_chk(1,0x8151453,local_34,local_30);
  return;
}



void print_costmatrix(gdouble *m,guint n)

{
  uint uVar1;
  gdouble *pgVar2;
  gdouble local_34;
  uint local_24;
  gdouble *local_20;
  
  __printf_chk(1,"COST MATRIX:\n");
  if (n != 0) {
    local_24 = 0;
    local_20 = m;
    do {
      uVar1 = 0;
      pgVar2 = local_20;
      do {
        local_34 = *pgVar2;
        uVar1 = uVar1 + 1;
        pgVar2 = pgVar2 + 1;
        __printf_chk(1,0x81514c3,local_34);
      } while (uVar1 < n);
      __printf_chk(1,0x8151453,local_34);
      local_24 = local_24 + 1;
      local_20 = local_20 + n;
    } while (local_24 < n);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void calculate_serpintine(gdouble delta,gdouble r,gdouble initiala,gdouble *a,guint *nhalfcycles)

{
  double dVar1;
  ulonglong local_1c;
  
  dVar1 = (double)r * 3.14159265 + ((double)initiala - (double)r) + ((double)initiala - (double)r);
  __printf_chk(1,"lhalfcycle = %f r = %f\n",dVar1,r);
  local_1c = (longlong)
             ROUND(((double)r * -3.14159265 + (double)delta) / (dVar1 + (double)r * -2.00000000) +
                   1.00000000) & 0xffffffff;
  dVar1 = (double)local_1c;
  *(double *)a = ((double)r * -3.14159265 +
                 dVar1 * -3.14159265 * (double)r + dVar1 * 4.00000000 * (double)r + (double)delta +
                 (double)r * 4.00000000) / (dVar1 + dVar1);
  *nhalfcycles = (guint)local_1c;
  return;
}



void print_toporouter_arc(toporouter_arc_t *arc)

{
  gdouble local_24;
  gdouble local_1c;
  
  local_1c = (arc->centre->v).p.y;
  __printf_chk(1,"ARC CENTRE: %f,%f ",(arc->centre->v).p.x,local_1c);
  local_24 = arc->r;
  __printf_chk(1,"RADIUS: %f",local_24);
  if (0 < arc->dir) {
    __printf_chk(1," COUNTERCLOCKWISE ",local_24,local_1c);
    return;
  }
  if (arc->dir == 0) {
    __printf_chk(1," COLINEAR(ERROR) ",local_24,local_1c);
    return;
  }
  __printf_chk(1," CLOCKWISE ",local_24,local_1c);
  return;
}



void print_bbox(toporouter_bbox_t *box)

{
  GtsPoint *pGVar1;
  gint gVar2;
  ulonglong local_24;
  ulonglong uVar3;
  undefined4 uVar4;
  
  uVar3 = local_24 & 0xffffffff00000000 | ZEXT48(box);
  __printf_chk(1,"[BBOX %x ",box);
  switch(box->type) {
  case PAD:
    __printf_chk(1,&DAT_0815150d,uVar3);
    break;
  case PIN:
    __printf_chk(1,&DAT_08151512,uVar3);
    break;
  case VIA:
    __printf_chk(1,&DAT_08151517,uVar3);
    break;
  default:
    __printf_chk(1,"UNKNOWN ",uVar3);
    break;
  case LINE:
    __printf_chk(1,"LINE ",uVar3);
    break;
  case BOARD:
    __printf_chk(1,"BOARD ",uVar3);
    break;
  case POLYGON:
    __printf_chk(1,"POLYGON ",uVar3);
    pGVar1 = box->point;
    goto joined_r0x080db229;
  }
  pGVar1 = box->point;
joined_r0x080db229:
  if (pGVar1 == (GtsPoint *)0x0) {
    uVar4 = (undefined4)(uVar3 >> 0x20);
    __printf_chk(1,"P: NONE ",uVar3);
  }
  else {
    uVar4 = (undefined4)((ulonglong)pGVar1->x >> 0x20);
    __printf_chk(1,"P: %f,%f,%f ",pGVar1->x,pGVar1->y,pGVar1->z);
  }
  __printf_chk(1,"LAYER: %d ",box->layer,uVar4);
  gVar2 = -1;
  if (box->cluster != (_toporouter_cluster_t *)0x0) {
    gVar2 = box->cluster->c;
  }
  __printf_chk(1,"CLUSTER: %d]\n",gVar2,uVar4);
  return;
}



// WARNING: Type propagation algorithm not settling

void print_cluster(toporouter_cluster_t *c)

{
  toporouter_bbox_t *ptVar1;
  gpointer *ppvVar2;
  GPtrArray *pGVar3;
  undefined4 uVar4;
  toporouter_bbox_t *ptVar5;
  
  if (c == (toporouter_cluster_t *)0x0) {
    __printf_chk(1,"[CLUSTER (NULL)]\n");
    return;
  }
  __printf_chk(1,"CLUSTER %d: NETLIST = %s STYLE = %s\n",c->c,c->netlist->netlist,c->netlist->style)
  ;
  ptVar1 = (toporouter_bbox_t *)c->boxes->pdata;
  ppvVar2 = (&c->boxes->pdata)[1];
  ptVar5 = (toporouter_bbox_t *)((int)&ptVar1->b + ((int)ppvVar2 + -1) * 4);
  if (ptVar1 <= ptVar5) {
    while (ppvVar2 != (gpointer *)0x0) {
      uVar4 = &ptVar5->b;
      ptVar5 = (toporouter_bbox_t *)((int)(ptVar5 + 0xffffffff) + 0x60);
      print_bbox(*(toporouter_bbox_t **)uVar4);
      pGVar3 = c->boxes;
      if (ptVar5 <= (toporouter_bbox_t *)pGVar3->pdata &&
          (toporouter_bbox_t *)pGVar3->pdata != ptVar5) {
        return;
      }
      ppvVar2 = (&pGVar3->pdata)[1];
    }
  }
  return;
}



toporouter_route_t * routedata_create(void)

{
  toporouter_route_t *ptVar1;
  
  ptVar1 = (toporouter_route_t *)calloc(1,0x50);
  ptVar1->score = 0.00000000;
  ptVar1->netlist = (_toporouter_netlist_t *)0x0;
  ptVar1->alltemppoints = (GHashTable *)0x0;
  ptVar1->path = (GList *)0x0;
  ptVar1->curpoint = (toporouter_vertex_t *)0x0;
  ptVar1->pscore = 0.00000000;
  ptVar1->flags = 0;
  ptVar1->dest = (_toporouter_cluster_t *)0x0;
  ptVar1->src = (_toporouter_cluster_t *)0x0;
  ptVar1->pdest = (_toporouter_cluster_t *)0x0;
  ptVar1->psrc = (_toporouter_cluster_t *)0x0;
  ptVar1->topopath = (GList *)0x0;
  ptVar1->ppath = (GList *)0x0;
  ptVar1->ppathindices = (gint *)0x0;
  ptVar1->srcvertices = (GList *)0x0;
  ptVar1->destvertices = (GList *)0x0;
  return ptVar1;
}



toporouter_rubberband_arc_t *
new_rubberband_arc(toporouter_vertex_t *pathv,toporouter_vertex_t *arcv,gdouble r,gdouble d,
                  gint wind,GList *list)

{
  toporouter_rubberband_arc_t *ptVar1;
  
  ptVar1 = (toporouter_rubberband_arc_t *)calloc(1,0x20);
  ptVar1->pathv = pathv;
  ptVar1->r = r;
  ptVar1->arcv = arcv;
  ptVar1->d = d;
  ptVar1->wind = wind;
  ptVar1->list = list;
  return ptVar1;
}



toporouter_serpintine_t *
toporouter_serpintine_new
          (gdouble x,gdouble y,gdouble x0,gdouble y0,gdouble x1,gdouble y1,gpointer start,
          gdouble halfa,gdouble radius,guint nhalfcycles)

{
  toporouter_serpintine_t *ptVar1;
  
  ptVar1 = (toporouter_serpintine_t *)calloc(1,0x4c);
  ptVar1->x = x;
  ptVar1->y = y;
  ptVar1->x0 = x0;
  ptVar1->y0 = y0;
  ptVar1->x1 = x1;
  ptVar1->y1 = y1;
  ptVar1->start = start;
  ptVar1->halfa = halfa;
  ptVar1->radius = radius;
  ptVar1->nhalfcycles = nhalfcycles;
  ptVar1->arcs = (GList *)0x0;
  return ptVar1;
}



drawing_context_t * toporouter_output_init(int w,int h,char *filename)

{
  int iVar1;
  double dVar2;
  PCBTypePtr pPVar3;
  drawing_context_t *pdVar4;
  
  pdVar4 = (drawing_context_t *)calloc(1,0x24);
  pdVar4->filename = filename;
  pPVar3 = PCB;
  pdVar4->iw = (double)w;
  iVar1 = pPVar3->MaxWidth;
  pdVar4->ih = (double)h;
  if (iVar1 <= pPVar3->MaxHeight) {
    dVar2 = (double)pPVar3->MaxHeight / ((double)h - 20.00000000);
    pdVar4->s = dVar2;
    pdVar4->iw = (double)pPVar3->MaxWidth * dVar2 + 20.00000000;
    return pdVar4;
  }
  dVar2 = (double)iVar1 / ((double)w - 20.00000000);
  pdVar4->s = dVar2;
  pdVar4->ih = (double)pPVar3->MaxHeight * dVar2 + 20.00000000;
  return pdVar4;
}



toporouter_t * toporouter_new(void)

{
  toporouter_t *ptVar1;
  GPtrArray *pGVar2;
  tm *__tp;
  char *pcVar3;
  time_t local_10 [2];
  
  ptVar1 = (toporouter_t *)calloc(1,100);
  gettimeofday((timeval *)&ptVar1->starttime,(__timezone_ptr_t)0x0);
  ptVar1->netsort = netscore_pairwise_compare;
  ptVar1->destboxes = (GList *)0x0;
  ptVar1->consumeddestboxes = (GList *)0x0;
  ptVar1->paths = (GList *)0x0;
  ptVar1->layers = (toporouter_layer_t *)0x0;
  ptVar1->viacost = 10000.00000000;
  ptVar1->flags = 0;
  ptVar1->stublength = 300.00000000;
  ptVar1->viamax = 3;
  ptVar1->serpintine_half_amplitude = 1500.00000000;
  ptVar1->bboxes = (GSList *)0x0;
  ptVar1->wiring_score = 0.00000000;
  ptVar1->bboxtree = (GNode *)0x0;
  pGVar2 = (GPtrArray *)g_ptr_array_new();
  ptVar1->netlists = pGVar2;
  pGVar2 = (GPtrArray *)g_ptr_array_new();
  ptVar1->keepoutlayers = (GList *)0x0;
  ptVar1->routednets = (GList *)0x0;
  ptVar1->failednets = (GList *)0x0;
  ptVar1->routes = pGVar2;
  local_10[0] = time((time_t *)0x0);
  gts_predicates_init();
  Message("Topological Autorouter\n");
  __tp = localtime(local_10);
  pcVar3 = asctime(__tp);
  Message("Started %s",pcVar3);
  Message("-------------------------------------\n");
  Message("Copyright 2009 Anthony Blake (tonyb33@gmail.com)\n\n");
  return ptVar1;
}



void parse_arguments(toporouter_t *r,int argc,char **argv)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  double *pdVar4;
  GList *pGVar5;
  PCBTypePtr pPVar6;
  DataTypePtr *pDVar7;
  int iVar8;
  uint uVar9;
  uint local_3c;
  int local_20 [4];
  
  if (0 < argc) {
    iVar8 = 0;
LAB_080db701:
    do {
      iVar3 = __isoc99_sscanf(argv[iVar8],"viacost=%d",local_20);
      if (iVar3 == 0) {
        iVar3 = __isoc99_sscanf(argv[iVar8],0x81486c6,local_20);
        if (iVar3 != 0) {
          iVar8 = iVar8 + 1;
          pdVar4 = (double *)calloc(1,8);
          *pdVar4 = (double)local_20[0];
          pGVar5 = (GList *)g_list_prepend(r->keepoutlayers,pdVar4);
          r->keepoutlayers = pGVar5;
          if (argc <= iVar8) break;
          goto LAB_080db701;
        }
      }
      else {
        *(double *)&r->viacost = (double)local_20[0];
      }
      iVar8 = iVar8 + 1;
    } while (iVar8 < argc);
  }
  local_3c = 0;
  pDVar7 = PCB->Data;
  uVar9 = pDVar7->LayerN;
  pPVar6 = PCB;
  if (uVar9 == 0) {
    return;
  }
LAB_080db790:
  iVar8 = local_3c + 0x734;
  if ((&(pPVar6->Flags).f)[iVar8] != 0) {
    iVar3 = 0;
    do {
      uVar2 = (&(pPVar6->Flags).f)[iVar3 + 0x744 + local_3c * 0x12];
      if ((uVar2 < uVar9) && (*(char *)(&pDVar7->field_0x90 + uVar2 * 0x5c) == '\0')) {
        pdVar4 = (double *)calloc(1,8);
        *pdVar4 = (double)(ulonglong)local_3c;
        pGVar5 = (GList *)g_list_prepend(r->keepoutlayers,pdVar4);
        r->keepoutlayers = pGVar5;
        puVar1 = &(PCB->Flags).f + iVar8;
        pPVar6 = PCB;
        if (*puVar1 < iVar3 + 1U || *puVar1 == iVar3 + 1U) goto LAB_080db840;
      }
      else {
        puVar1 = &(pPVar6->Flags).f + iVar8;
        if (*puVar1 < iVar3 + 1U || *puVar1 == iVar3 + 1U) goto LAB_080db840;
      }
      iVar3 = iVar3 + 1;
      pDVar7 = pPVar6->Data;
      uVar9 = pDVar7->LayerN;
    } while( true );
  }
  goto LAB_080db849;
LAB_080db840:
  pDVar7 = pPVar6->Data;
  uVar9 = pDVar7->LayerN;
LAB_080db849:
  local_3c = local_3c + 1;
  if (uVar9 <= local_3c) {
    return;
  }
  goto LAB_080db790;
}



void toporouter_arc_remove(toporouter_oproute_t *oproute,toporouter_arc_t *arc)

{
  GList *pGVar1;
  
  pGVar1 = (GList *)g_list_remove(oproute->arcs,arc);
  oproute->arcs = pGVar1;
  if (arc->v != (toporouter_vertex_t *)0x0) {
    arc->v->arc = (_toporouter_arc_t *)0x0;
  }
  return;
}



void toporouter_layer_free(toporouter_layer_t *l)

{
  g_list_free(l->vertices);
  g_list_free();
  return;
}



void cluster_join_bbox(toporouter_cluster_t *cluster,toporouter_bbox_t *box)

{
  if (box != (toporouter_bbox_t *)0x0) {
    g_ptr_array_add(cluster->boxes,box);
    *(toporouter_cluster_t **)&box->cluster = cluster;
  }
  return;
}



toporouter_cluster_t * cluster_create(toporouter_t *r,toporouter_netlist_t *netlist)

{
  guint gVar1;
  toporouter_cluster_t *ptVar2;
  GPtrArray *pGVar3;
  
  ptVar2 = (toporouter_cluster_t *)calloc(1,0x10);
  pGVar3 = netlist->clusters;
  gVar1 = pGVar3->len;
  ptVar2->pc = gVar1;
  ptVar2->c = gVar1;
  g_ptr_array_add(pGVar3,ptVar2);
  ptVar2->netlist = netlist;
  pGVar3 = (GPtrArray *)g_ptr_array_new();
  ptVar2->boxes = pGVar3;
  return ptVar2;
}



gint netscore_pairwise_compare(toporouter_netscore_t **a,toporouter_netscore_t **b)

{
  toporouter_netscore_t *ptVar1;
  toporouter_netscore_t *ptVar2;
  uint uVar3;
  bool bVar4;
  
  ptVar1 = *a;
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS((double)ptVar1->score)) {
    return (uint)(ABS((double)(*b)->score) <=
                                  
                 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                 );
  }
  ptVar2 = *b;
  if (ABS((double)ptVar2->score) <=
            
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     ) {
    uVar3 = ptVar2->pairwise_fails;
    bVar4 = uVar3 <= ptVar1->pairwise_fails;
    if (bVar4) {
      if (bVar4 && ptVar1->pairwise_fails != uVar3) {
        return 1;
      }
      if ((double)ptVar2->pairwise_detour_sum <= (double)ptVar1->pairwise_detour_sum) {
        return (uint)((double)ptVar2->pairwise_detour_sum < (double)ptVar1->pairwise_detour_sum);
      }
    }
  }
  return -1;
}



gint netscore_pairwise_size_compare(toporouter_netscore_t **a,toporouter_netscore_t **b)

{
  double dVar1;
  double dVar2;
  toporouter_netscore_t *ptVar3;
  toporouter_netscore_t *ptVar4;
  uint uVar5;
  bool bVar6;
  
  ptVar3 = *a;
  dVar1 = (double)ptVar3->score;
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(dVar1)) {
    return (uint)(ABS((double)(*b)->score) <=
                                  
                 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                 );
  }
  ptVar4 = *b;
  dVar2 = (double)ptVar4->score;
  if (ABS(dVar2) <=
            
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     ) {
    uVar5 = ptVar4->pairwise_fails;
    bVar6 = uVar5 <= ptVar3->pairwise_fails;
    if (bVar6) {
      if (bVar6 && ptVar3->pairwise_fails != uVar5) {
        return 1;
      }
      if ((double)ptVar4->pairwise_detour_sum <= (double)ptVar3->pairwise_detour_sum) {
        if ((double)ptVar4->pairwise_detour_sum < (double)ptVar3->pairwise_detour_sum) {
          return 1;
        }
        if (dVar2 <= dVar1) {
          return (uint)(dVar2 < dVar1);
        }
      }
    }
  }
  return -1;
}



void netlist_recalculate(toporouter_netlist_t *netlist,GList *ignore)

{
  GPtrArray *pGVar1;
  guint gVar2;
  int **ppiVar3;
  int *piVar4;
  int iVar5;
  int **ppiVar6;
  int **ppiVar7;
  int **ppiVar8;
  int iVar9;
  
  ppiVar7 = (int **)g_list_last(netlist->routed);
  pGVar1 = netlist->clusters;
  gVar2 = pGVar1->len;
  ppiVar3 = (int **)pGVar1->pdata;
  iVar9 = gVar2 - 1;
  ppiVar8 = ppiVar3 + iVar9;
  if (ppiVar3 <= ppiVar8) {
    while (gVar2 != 0) {
      piVar4 = *ppiVar8;
      ppiVar8 = ppiVar8 + -1;
      *piVar4 = iVar9;
      iVar9 = iVar9 + -1;
      if (ppiVar8 < ppiVar3) break;
      gVar2 = pGVar1->len;
    }
  }
  do {
    if (ppiVar7 == (int **)0x0) {
      return;
    }
    if ((ignore == (GList *)0x0) || (iVar9 = g_list_find(ignore,*ppiVar7), iVar9 == 0)) {
      ppiVar8 = (int **)*ppiVar7;
      iVar9 = *ppiVar8[2];
      iVar5 = *ppiVar8[1];
      ppiVar3 = (int **)**ppiVar8;
      ppiVar6 = (int **)*ppiVar3;
      piVar4 = ppiVar3[1];
      ppiVar8 = ppiVar6 + (int)piVar4 + -1;
      if (ppiVar6 <= ppiVar8) {
        while (piVar4 != (int *)0x0) {
          if (iVar9 == **ppiVar8) {
            **ppiVar8 = iVar5;
          }
          if (ppiVar8 + -1 < ppiVar6) break;
          ppiVar8 = ppiVar8 + -1;
          piVar4 = ppiVar3[1];
        }
      }
    }
    ppiVar7 = (int **)ppiVar7[2];
  } while( true );
}



void netlists_recalculate(GList *netlists,GList *ignore)

{
  if (netlists != (GList *)0x0) {
    do {
      netlist_recalculate((toporouter_netlist_t *)netlists->data,ignore);
      netlists = netlists->next;
    } while (netlists != (GList *)0x0);
  }
  return;
}



GtsTriangle * opposite_triangle(GtsTriangle *t,toporouter_edge_t *e)

{
  GtsTriangle *pGVar1;
  char "opposite_triangle" [18];
  GSList *pGVar2;
  
  pGVar2 = (e->e).triangles;
  if (t == (GtsTriangle *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1798,"opposite_triangle",&DAT_081515aa);
  }
  if (pGVar2 != (GSList *)0x0) {
    pGVar1 = (GtsTriangle *)pGVar2->data;
    if (pGVar1 != t) {
      return pGVar1;
    }
    while (pGVar2 = pGVar2->next, pGVar2 != (GSList *)0x0) {
      if (pGVar1 != (GtsTriangle *)pGVar2->data) {
        return (GtsTriangle *)pGVar2->data;
      }
    }
  }
  return (GtsTriangle *)0x0;
}



GList * cluster_vertices(toporouter_t *r,toporouter_cluster_t *c)

{
  guint gVar1;
  toporouter_cluster_t *ptVar2;
  gpointer *ppvVar3;
  gpointer pvVar4;
  char "cluster_vertices" [17];
  GPtrArray *pGVar5;
  undefined4 uVar6;
  toporouter_netlist_t *ptVar7;
  gpointer *ppvVar8;
  GList *pGVar9;
  toporouter_cluster_t **local_24;
  
  if (c != (toporouter_cluster_t *)0x0) {
    ptVar7 = c->netlist;
    ptVar2 = (toporouter_cluster_t *)ptVar7->clusters->pdata;
    gVar1 = ptVar7->clusters->len;
    local_24 = (toporouter_cluster_t **)(ptVar2 + -1 + gVar1 + 3);
    if ((ptVar2 <= local_24) && (gVar1 != 0)) {
      pGVar9 = (GList *)0x0;
      do {
        ptVar2 = *local_24;
        if (*(char *)&r->flags < '\0') {
          if (ptVar2->c == c->c) goto LAB_080dbcbe;
        }
        else {
          if (ptVar2 == c) {
LAB_080dbcbe:
            ppvVar3 = ptVar2->boxes->pdata;
            gVar1 = ptVar2->boxes->len;
            ppvVar8 = ppvVar3 + (gVar1 - 1);
            if ((ppvVar3 <= ppvVar8) && (gVar1 != 0)) {
              do {
                pvVar4 = *ppvVar8;
                if (*(int *)((int)pvVar4 + 0x40) == 5) {
                  if (**(int **)((int)pvVar4 + 0x54) == 0) {
                    // WARNING: Subroutine does not return
                    g_assertion_message_expr
                              (0,"../../src/toporouter.c",0x962,"cluster_vertices",
                               "box->constraints->data");
                  }
                  uVar6 = g_list_prepend(pGVar9,*(undefined4 *)
                                                 (**(int **)((int)pvVar4 + 0x54) + 0xc));
                  pGVar9 = (GList *)g_list_prepend(uVar6,*(undefined4 *)
                                                          (**(int **)((int)pvVar4 + 0x54) + 0x10));
                  pGVar5 = ptVar2->boxes;
                  if (ppvVar8 + -1 <= pGVar5->pdata && pGVar5->pdata != ppvVar8 + -1) {
LAB_080dbd4f:
                    ptVar7 = c->netlist;
                    pGVar5 = ptVar7->clusters;
                    if (local_24 + -1 <= (toporouter_cluster_t *)pGVar5->pdata &&
                        (toporouter_cluster_t *)pGVar5->pdata !=
                        (toporouter_cluster_t *)(local_24 + -1)) {
                      return pGVar9;
                    }
                    goto LAB_080dbc9a;
                  }
                }
                else {
                  if (*(int *)((int)pvVar4 + 0x58) == 0) {
                    __printf_chk(1,"WARNING: cluster_vertices: unhandled bbox type\n");
                  }
                  else {
                    pGVar9 = (GList *)g_list_prepend(pGVar9,*(int *)((int)pvVar4 + 0x58));
                  }
                  pGVar5 = ptVar2->boxes;
                  if (ppvVar8 + -1 <= pGVar5->pdata && pGVar5->pdata != ppvVar8 + -1)
                  goto LAB_080dbd4f;
                }
                ppvVar8 = ppvVar8 + -1;
              } while (pGVar5->len != 0);
              ptVar7 = c->netlist;
            }
          }
        }
        pGVar5 = ptVar7->clusters;
        if (local_24 + -1 <= (toporouter_cluster_t *)pGVar5->pdata &&
            (toporouter_cluster_t *)pGVar5->pdata != (toporouter_cluster_t *)(local_24 + -1)) {
          return pGVar9;
        }
LAB_080dbc9a:
        local_24 = local_24 + -1;
        if (pGVar5->len == 0) {
          return pGVar9;
        }
      } while( true );
    }
  }
  return (GList *)0x0;
}



gpointer __regparm3 gts_object_is_from_class(gpointer object,gpointer klass)

{
  char "gts_object_is_from_class" [25];
  gpointer pvVar1;
  
  if (klass == (gpointer)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return (gpointer)0x0;
  }
  if (object != (gpointer)0x0) {
    pvVar1 = *(gpointer *)object;
    if (pvVar1 == (gpointer)0x0) {
      g_return_if_fail_warning(0,0x8151189,0x8161082);
      return (gpointer)0x0;
    }
    while (klass != pvVar1) {
      pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
      if (pvVar1 == (gpointer)0x0) {
        return (gpointer)0x0;
      }
    }
  }
  return object;
}



void free_list_elements(gpointer data,gpointer user_data)

{
  free(data);
  return;
}



void toporouter_free(toporouter_t *r)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  timeval endtime;
  
  uVar4 = 0;
  while( true ) {
    iVar3 = PCB->Data->LayerN;
    if (iVar3 < 1) break;
    uVar2 = 0;
    iVar1 = 0;
    do {
      uVar2 = (uVar2 + 1) - (uint)((PCB->LayerGroups).Number[iVar1] == 0);
      iVar1 = iVar1 + 1;
    } while (iVar1 != iVar3);
    if (uVar2 <= uVar4) break;
    toporouter_layer_free(r->layers + uVar4);
    uVar4 = uVar4 + 1;
  }
  gettimeofday((timeval *)&endtime,(__timezone_ptr_t)0x0);
  iVar1 = endtime.tv_sec - (r->starttime).tv_sec;
  iVar3 = (endtime.tv_usec - (r->starttime).tv_usec) / 1000;
  if (iVar3 < 0) {
    iVar1 = iVar1 + -1;
    iVar3 = iVar3 + 1000;
  }
  Message("Elapsed time: %d.%02d seconds\n",iVar1,iVar3);
  free(r->layers);
  free(r);
  return;
}



// WARNING: Removing unreachable block (ram,0x080dbf4a)

float10 path_score(int r,int *path)

{
  int iVar1;
  int iVar2;
  float10 fVar3;
  float10 fVar4;
  
  if (path == (int *)0x0) {
    return (float10)INFINITY;
  }
  iVar2 = *path;
  fVar4 = (float10)0;
  do {
    path = (int *)path[1];
    iVar1 = iVar2;
    if (path == (int *)0x0) {
      return fVar4;
    }
    while (iVar2 = *path, iVar1 != 0) {
      fVar3 = (float10)gts_point_distance(iVar1,iVar2);
      fVar4 = (float10)(double)fVar4 + fVar3;
      if (*(double *)(iVar1 + 0x1c) == *(double *)(iVar2 + 0x1c)) break;
      path = (int *)path[1];
      if (path == (int *)0x0) {
        return fVar4;
      }
      fVar4 = fVar4 + (float10)*(double *)(r + 0x24);
      iVar1 = iVar2;
    }
  } while( true );
}



void edge_capacity(int e)

{
  gts_point_distance(*(undefined4 *)(e + 0xc),*(undefined4 *)(e + 0x10));
  return;
}



float10 simple_h_cost(int r,int curpoint,int destpoint)

{
  float10 fVar1;
  double local_14;
  
  if (*(double *)(curpoint + 0x1c) == *(double *)(destpoint + 0x1c)) {
    local_14 = 0.00000000;
  }
  else {
    local_14 = *(double *)(r + 0x24);
  }
  fVar1 = (float10)gts_point_distance(curpoint,destpoint);
  return fVar1 + (float10)local_14;
}



toporouter_vertex_t *
closest_dest_vertex(toporouter_t *r,toporouter_vertex_t *v,toporouter_route_t *routedata)

{
  toporouter_vertex_t *ptVar1;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *ptVar3;
  GList *pGVar4;
  float10 fVar5;
  float10 fVar6;
  
  pGVar4 = routedata->destvertices;
  ptVar2 = (toporouter_vertex_t *)0x0;
  if (pGVar4 != (GList *)0x0) {
    fVar5 = (float10)0;
    ptVar3 = ptVar2;
    do {
      while (ptVar1 = (toporouter_vertex_t *)pGVar4->data, ptVar2 = ptVar3, fVar6 = fVar5,
            (double)(ptVar1->v).p.z == (double)(v->v).p.z) {
        ptVar2 = ptVar1;
        if (ptVar3 == (toporouter_vertex_t *)0x0) {
          fVar6 = (float10)simple_h_cost(r,v,ptVar1);
          break;
        }
        fVar6 = (float10)simple_h_cost(r,v,ptVar1);
        fVar5 = (float10)(double)fVar5;
        if ((((*(byte *)((int)&r->flags + 1) & 1) != 0) && (fVar5 < fVar6)) || (fVar6 < fVar5))
        break;
        pGVar4 = (GList *)(&pGVar4->data)[1];
        if (pGVar4 == (GList *)0x0) {
          return ptVar3;
        }
      }
      fVar5 = fVar6;
      pGVar4 = (GList *)(&pGVar4->data)[1];
      ptVar3 = ptVar2;
    } while (pGVar4 != (GList *)0x0);
  }
  return ptVar2;
}



// WARNING: Removing unreachable block (ram,0x080dc257)

void closest_cluster_pair
               (toporouter_t *r,GList *src_vertices,GList *dest_vertices,toporouter_vertex_t **a,
               toporouter_vertex_t **b)

{
  double dVar1;
  double dVar2;
  toporouter_vertex_t *ptVar3;
  GList *pGVar4;
  GList *pGVar5;
  toporouter_vertex_t *ptVar6;
  float10 fVar7;
  float10 fVar8;
  GList *local_20;
  
  *a = (toporouter_vertex_t *)0x0;
  *b = (toporouter_vertex_t *)0x0;
  if (src_vertices != (GList *)0x0) {
    local_20 = src_vertices;
    fVar8 = (float10)0;
    do {
      ptVar3 = (toporouter_vertex_t *)local_20->data;
      pGVar4 = r->keepoutlayers;
      if (pGVar4 == (GList *)0x0) {
LAB_080dc157:
        if (dest_vertices != (GList *)0x0) {
          ptVar6 = (toporouter_vertex_t *)dest_vertices->data;
          pGVar5 = dest_vertices;
          if (pGVar4 == (GList *)0x0) goto LAB_080dc204;
LAB_080dc170:
          dVar1 = (double)(ptVar6->v).p.z;
          dVar2 = *(double *)pGVar4->data;
          while( true ) {
            if (dVar2 == dVar1) goto LAB_080dc1f0;
            pGVar4 = pGVar4->next;
            if (pGVar4 == (GList *)0x0) break;
            dVar2 = *(double *)pGVar4->data;
          }
          do {
            if ((double)(ptVar3->v).p.z == dVar1) {
              if (*a == (toporouter_vertex_t *)0x0) {
                *a = ptVar3;
                *b = ptVar6;
                fVar8 = (float10)simple_h_cost(r,*a,ptVar6);
                goto LAB_080dc1f0;
              }
              dVar1 = (double)fVar8;
              fVar8 = (float10)simple_h_cost(r,ptVar3,ptVar6);
              fVar7 = (float10)dVar1;
              if ((((*(byte *)((int)&r->flags + 1) & 1) != 0) && (fVar7 < fVar8)) || (fVar8 < fVar7)
                 ) {
                *a = ptVar3;
                *b = ptVar6;
                goto LAB_080dc1f0;
              }
              pGVar5 = pGVar5->next;
              fVar8 = fVar7;
            }
            else {
LAB_080dc1f0:
              pGVar5 = pGVar5->next;
            }
            if (pGVar5 == (GList *)0x0) break;
            pGVar4 = r->keepoutlayers;
            ptVar6 = (toporouter_vertex_t *)pGVar5->data;
            if (pGVar4 != (GList *)0x0) goto LAB_080dc170;
LAB_080dc204:
            dVar1 = (double)(ptVar6->v).p.z;
          } while( true );
        }
        local_20 = local_20->next;
      }
      else {
        dVar1 = *(double *)pGVar4->data;
        pGVar5 = pGVar4;
        while (dVar1 != (double)(ptVar3->v).p.z) {
          pGVar5 = pGVar5->next;
          if (pGVar5 == (GList *)0x0) goto LAB_080dc157;
          dVar1 = *(double *)pGVar5->data;
        }
        local_20 = local_20->next;
      }
    } while (local_20 != (GList *)0x0);
  }
  return;
}



void snapshot(toporouter_t *r,char *name,GList *datas)

{
  int iVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  int in_GS_OFFSET;
  char buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  uVar5 = 0;
  while( true ) {
    iVar2 = PCB->Data->LayerN;
    if (iVar2 < 1) break;
    uVar4 = 0;
    iVar3 = 0;
    do {
      uVar4 = (uVar4 + 1) - (uint)((PCB->LayerGroups).Number[iVar3] == 0);
      iVar3 = iVar3 + 1;
    } while (iVar3 != iVar2);
    if (uVar4 <= uVar5) break;
    __sprintf_chk(buffer,1,0x100,"route-%s-%d.png",name,uVar5);
    uVar5 = uVar5 + 1;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



gint routing_edge_insert(gconstpointer a,gconstpointer b,gpointer user_data)

{
  undefined4 uVar1;
  uint uVar2;
  float10 fVar3;
  float10 fVar4;
  
  uVar1 = *(undefined4 *)((int)user_data + 0xc);
  fVar3 = (float10)gts_point_distance2(uVar1,a);
  fVar4 = (float10)gts_point_distance2(uVar1,b);
  uVar2 = 0xffffffff;
  if (fVar4 - (float10)0.00010000 <= (float10)(double)fVar3) {
    fVar3 = (float10)gts_point_distance2(uVar1,a);
    fVar4 = (float10)gts_point_distance2(uVar1,b);
    uVar2 = (uint)((float10)(double)(float10)0.00010000 + fVar4 < (float10)(double)fVar3);
  }
  return uVar2;
}



void oproute_free(toporouter_oproute_t *oproute)

{
  GtsObject *object;
  GList *pGVar1;
  GList *pGVar2;
  
  pGVar1 = (GList *)0x0;
  pGVar2 = oproute->arcs;
  if (pGVar2 != (GList *)0x0) {
    do {
      while (object = *(GtsObject **)((int)pGVar2->data + 0x2c), -1 < *(char *)&object[4].flags) {
        pGVar2 = pGVar2->next;
        if (pGVar2 == (GList *)0x0) goto LAB_080dc3f9;
      }
      gts_object_destroy(object);
      pGVar2 = pGVar2->next;
    } while (pGVar2 != (GList *)0x0);
LAB_080dc3f9:
    pGVar1 = oproute->arcs;
  }
  g_list_free(pGVar1);
  free(oproute);
  return;
}



GList * split_path(GList *path)

{
  gpointer pvVar1;
  uint uVar2;
  undefined4 uVar3;
  gpointer pvVar4;
  GList *local_20;
  
  uVar3 = 0;
  local_20 = (GList *)0x0;
  if (path != (GList *)0x0) {
    uVar3 = 0;
    local_20 = (GList *)0x0;
    pvVar1 = path->data;
    while( true ) {
      pvVar4 = pvVar1;
      uVar3 = g_list_append(uVar3,pvVar4);
      path = path->next;
      if (path == (GList *)0x0) break;
      pvVar1 = path->data;
      if (((pvVar4 != (gpointer)0x0) &&
          (*(double *)((int)pvVar1 + 0xc) == *(double *)((int)pvVar4 + 0xc))) &&
         (*(double *)((int)pvVar1 + 0x14) == *(double *)((int)pvVar4 + 0x14))) {
        uVar2 = g_list_length(uVar3);
        if (1 < uVar2) {
          local_20 = (GList *)g_list_prepend(local_20,uVar3);
        }
        *(undefined4 *)((int)pvVar4 + 0x30) = 0;
        uVar3 = 0;
        *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
      }
    }
  }
  uVar2 = g_list_length(uVar3);
  if (1 < uVar2) {
    local_20 = (GList *)g_list_prepend(local_20,uVar3);
  }
  return local_20;
}



// WARNING: Removing unreachable block (ram,0x080dc599)
// WARNING: Removing unreachable block (ram,0x080dc536)
// WARNING: Removing unreachable block (ram,0x080dc53c)
// WARNING: Removing unreachable block (ram,0x080dc540)
// WARNING: Removing unreachable block (ram,0x080dc59f)
// WARNING: Removing unreachable block (ram,0x080dc5a8)

float10 vector_angle(double param_1,double oy,double ax,double ay,double bx,double by)

{
  double dVar1;
  
  ax = ax - param_1;
  ay = ay - oy;
  bx = bx - param_1;
  by = by - oy;
  dVar1 = acos((by * ay + bx * ax) / (SQRT(ay * ay + ax * ax) * SQRT(by * by + bx * bx)));
  return (float10)dVar1;
}



// WARNING: Removing unreachable block (ram,0x080dc696)
// WARNING: Removing unreachable block (ram,0x080dc64a)
// WARNING: Removing unreachable block (ram,0x080dc64e)
// WARNING: Removing unreachable block (ram,0x080dc650)
// WARNING: Removing unreachable block (ram,0x080dc69a)
// WARNING: Removing unreachable block (ram,0x080dc6a0)

float10 arc_angle(int arc)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  
  dVar4 = *(double *)(*(int *)(arc + 0x2c) + 0xc);
  dVar2 = *(double *)(arc + 0xc) - dVar4;
  dVar4 = *(double *)(arc + 0x1c) - dVar4;
  dVar1 = *(double *)(*(int *)(arc + 0x2c) + 0x14);
  dVar3 = *(double *)(arc + 0x14) - dVar1;
  dVar1 = *(double *)(arc + 0x24) - dVar1;
  dVar4 = acos((dVar4 * dVar2 + dVar1 * dVar3) /
               (SQRT(dVar3 * dVar3 + dVar2 * dVar2) * SQRT(dVar1 * dVar1 + dVar4 * dVar4)));
  return (float10)dVar4;
}



// WARNING: Removing unreachable block (ram,0x080dc77c)
// WARNING: Removing unreachable block (ram,0x080dc780)
// WARNING: Removing unreachable block (ram,0x080dc788)
// WARNING: Removing unreachable block (ram,0x080dc854)
// WARNING: Removing unreachable block (ram,0x080dc850)
// WARNING: Removing unreachable block (ram,0x080dc858)
// WARNING: Removing unreachable block (ram,0x080dc880)
// WARNING: Removing unreachable block (ram,0x080dc87c)
// WARNING: Removing unreachable block (ram,0x080dc882)

void oproute_calculate_tof(toporouter_oproute_t *oproute)

{
  gpointer pvVar1;
  GList *pGVar2;
  gpointer pvVar3;
  gpointer pvVar4;
  float10 fVar5;
  float10 fVar6;
  float10 fVar7;
  
  fVar7 = (float10)0;
  pGVar2 = oproute->arcs;
  *(double *)&oproute->tof = (double)fVar7;
  if (pGVar2 == (GList *)0x0) {
    fVar7 = (float10)gts_point_distance(oproute->term1,oproute->term2);
    *(double *)&oproute->tof = (double)fVar7;
    return;
  }
  pvVar1 = pGVar2->data;
  pvVar4 = (gpointer)0x0;
  do {
    pvVar3 = pvVar1;
    if (pvVar3 == (gpointer)0x0) {
      if (pvVar4 == (gpointer)0x0) goto LAB_080dc75d;
      fVar7 = (float10)(double)oproute->tof;
LAB_080dc731:
      pGVar2 = pGVar2->next;
    }
    else {
      if (pvVar4 != (gpointer)0x0) {
        fVar5 = (float10)arc_angle(pvVar4);
        fVar7 = (float10)(double)fVar7 + (float10)*(double *)((int)pvVar4 + 0x34) * fVar5;
        *(double *)&oproute->tof = (double)fVar7;
        fVar5 = (float10)*(double *)((int)pvVar4 + 0x1c) - (float10)*(double *)((int)pvVar3 + 0xc);
        fVar6 = (float10)*(double *)((int)pvVar4 + 0x24) - (float10)*(double *)((int)pvVar3 + 0x14);
        fVar7 = SQRT(fVar6 * fVar6 + fVar5 * fVar5) + fVar7;
        *(double *)&oproute->tof = (double)fVar7;
        goto LAB_080dc731;
      }
LAB_080dc75d:
      fVar5 = (float10)*(double *)((int)pvVar3 + 0xc) - (float10)(double)(oproute->term1->v).p.x;
      fVar6 = (float10)*(double *)((int)pvVar3 + 0x14) - (float10)(double)(oproute->term1->v).p.y;
      pGVar2 = pGVar2->next;
      fVar7 = SQRT(fVar6 * fVar6 + fVar5 * fVar5) + fVar7;
      *(double *)&oproute->tof = (double)fVar7;
    }
    if (pGVar2 == (GList *)0x0) {
      fVar5 = (float10)arc_angle(pvVar3);
      fVar6 = (float10)(double)fVar7 + (float10)*(double *)((int)pvVar3 + 0x34) * fVar5;
      *(double *)&oproute->tof = (double)fVar6;
      fVar7 = (float10)*(double *)((int)pvVar3 + 0x1c) - (float10)(double)(oproute->term2->v).p.x;
      fVar5 = (float10)*(double *)((int)pvVar3 + 0x24) - (float10)(double)(oproute->term2->v).p.y;
      *(double *)&oproute->tof = (double)(SQRT(fVar5 * fVar5 + fVar7 * fVar7) + fVar6);
      return;
    }
    fVar7 = (float10)(double)oproute->tof;
    pvVar1 = pGVar2->data;
    pvVar4 = pvVar3;
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x080dc9c8)
// WARNING: Removing unreachable block (ram,0x080dc8fe)
// WARNING: Removing unreachable block (ram,0x080dc9fc)
// WARNING: Removing unreachable block (ram,0x080dc9cc)
// WARNING: Removing unreachable block (ram,0x080dc9d0)

float10 line_line_distance_at_normal
                  (double line1_x1,double line1_y1,double line1_x2,double line1_y2,double line2_x1,
                  double line2_y1,double line2_x2,double line2_y2,double x,double y)

{
  double __value;
  int iVar1;
  int iVar2;
  float10 fVar3;
  float10 fVar4;
  float10 fVar5;
  double local_24;
  double local_14;
  
  if ((line1_x1 == line1_x2) ||
     (local_14 = (line1_x2 - line1_x1) / (line1_y2 - line1_y1),
          
     179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     < local_14)) {
    local_14 = 0.00000000;
  }
  else {
    local_14 = -1.00000000 / local_14;
  }
  if (line2_x1 == line2_x2) {
    __value = INFINITY;
  }
  else {
    __value = (line2_y2 - line2_y1) / (line2_x2 - line2_x1);
  }
  iVar1 = __isinf(local_14);
  local_24 = x;
  if (iVar1 == 0) {
    local_24 = y - local_14 * x;
  }
  iVar2 = __isinf(__value);
  fVar3 = (float10)line2_x1;
  fVar4 = (float10)__value;
  if (iVar2 == 0) {
    fVar5 = (float10)line2_y1 - fVar3 * fVar4;
    fVar3 = (float10)x;
    if (iVar1 == 0) {
      fVar3 = (fVar5 - (float10)local_24) / ((float10)local_14 - fVar4);
    }
    fVar5 = fVar4 * fVar3 + fVar5;
  }
  else {
    fVar5 = (float10)local_14 * fVar3 + (float10)local_24;
  }
  return SQRT(((float10)y - fVar5) * ((float10)y - fVar5) +
              ((float10)x - fVar3) * ((float10)x - fVar3));
}



guint vertex_line_normal_intersection
                (gdouble x1,gdouble y1,gdouble x2,gdouble y2,gdouble x3,gdouble y3,gdouble *x,
                gdouble *y)

{
  double __value;
  double dVar1;
  int iVar2;
  int iVar3;
  double local_2c;
  double local_1c;
  
  if ((double)x1 == (double)x2) {
    local_1c = 0.00000000;
    __value = INFINITY;
  }
  else {
    __value = ((double)y2 - (double)y1) / ((double)x2 - (double)x1);
    if (
        179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
        < __value) {
      local_1c = 0.00000000;
    }
    else {
      local_1c = -1.00000000 / __value;
    }
  }
  iVar2 = __isinf(local_1c);
  local_2c = (double)x3;
  if (iVar2 == 0) {
    local_2c = (double)y3 - (double)x3 * local_1c;
  }
  iVar3 = __isinf(__value);
  dVar1 = (double)x1;
  if (iVar3 == 0) {
    dVar1 = (double)y1 - (double)x1 * __value;
  }
  if (iVar2 == 0) {
    if (iVar3 == 0) {
      __value = (__value - local_1c) / (local_2c - dVar1);
      *(double *)x = __value;
    }
    else {
      *x = x1;
      __value = (double)x1;
    }
    local_2c = __value * local_1c + local_2c;
  }
  else {
    *x = x3;
    local_2c = (double)y1;
  }
  *(double *)y = local_2c;
  __value = (double)x2;
  if ((double)x1 <= (double)x2 || (double)x2 != (double)x1) {
    __value = (double)x1;
  }
  if (__value <= (double)*x) {
    if ((double)x1 <= (double)x2) {
      x1 = x2;
    }
    if ((double)*x <= (double)x1) {
      __value = (double)y2;
      if ((double)y1 <= (double)y2 || (double)y2 != (double)y1) {
        __value = (double)y1;
      }
      if (__value <= local_2c) {
        if ((double)y1 <= (double)y2) {
          y1 = y2;
        }
        return (uint)(local_2c <= (double)y1);
      }
    }
  }
  return 0;
}



void vertex_move_towards_vertex(GtsVertex *v,GtsVertex *p,gdouble d)

{
  double dVar1;
  char "vertex_move_towards_vertex" [27];
  double __x;
  double dVar2;
  double dVar3;
  double local_1c;
  double local_14;
  
  dVar3 = (double)(v->p).x;
  dVar2 = (double)(p->p).x - dVar3;
  dVar1 = (double)(p->p).y - (double)(v->p).y;
  __x = atan(ABS(dVar1 / dVar2));
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x132e,"vertex_move_towards_vertex","finite(theta)");
  }
  if (dVar2 < 0.00000000) {
    if (dVar1 < 0.00000000) {
      sincos(__x,&local_14,&local_1c);
      *(double *)&(v->p).x = dVar3 - (double)d * local_1c;
      *(double *)&(v->p).y = (double)(v->p).y - local_14 * (double)d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar3 - dVar2 * (double)d;
  }
  else {
    if (dVar1 < 0.00000000) {
      dVar2 = cos(__x);
      *(double *)&(v->p).x = dVar2 * (double)d + dVar3;
      dVar3 = sin(__x);
      *(double *)&(v->p).y = (double)(v->p).y - dVar3 * (double)d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar2 * (double)d + dVar3;
  }
  *(double *)&(v->p).x = dVar3;
  dVar3 = sin(__x);
  *(double *)&(v->p).y = dVar3 * (double)d + (double)(v->p).y;
  return;
}



void vertex_move_towards_point(GtsVertex *v,gdouble px,gdouble py,gdouble d)

{
  char "vertex_move_towards_point" [26];
  double __x;
  double dVar1;
  double dVar2;
  double local_1c;
  double local_14;
  
  dVar2 = (double)(v->p).x;
  dVar1 = (double)py - (double)(v->p).y;
  __x = atan(ABS(dVar1 / ((double)px - dVar2)));
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x130c,"vertex_move_towards_point","finite(theta)");
  }
  if ((double)px - dVar2 < 0.00000000) {
    if (dVar1 < 0.00000000) {
      sincos(__x,&local_14,&local_1c);
      *(double *)&(v->p).x = dVar2 - (double)d * local_1c;
      *(double *)&(v->p).y = (double)(v->p).y - local_14 * (double)d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar2 - dVar1 * (double)d;
  }
  else {
    if (dVar1 < 0.00000000) {
      dVar1 = cos(__x);
      *(double *)&(v->p).x = dVar1 * (double)d + dVar2;
      dVar2 = sin(__x);
      *(double *)&(v->p).y = (double)(v->p).y - dVar2 * (double)d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar1 * (double)d + dVar2;
  }
  *(double *)&(v->p).x = dVar2;
  dVar2 = sin(__x);
  *(double *)&(v->p).y = dVar2 * (double)d + (double)(v->p).y;
  return;
}



float10 point_xangle(int a,int b)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  float10 fVar5;
  double dVar6;
  
  dVar1 = *(double *)(a + 0xc);
  dVar2 = *(double *)(b + 0xc);
  dVar3 = *(double *)(a + 0x14);
  dVar4 = *(double *)(b + 0x14);
  if (0.00010000 <= ABS(dVar1 - dVar2)) {
    dVar6 = atan(ABS(dVar1 - dVar2) / ABS(dVar3 - dVar4));
    fVar5 = (float10)dVar6;
  }
  else {
    fVar5 = (float10)1.57079633;
  }
  if (dVar3 <= dVar4) {
    if (dVar2 < dVar1) {
      fVar5 = (float10)3.14159265 - fVar5;
    }
    return fVar5;
  }
  if (dVar1 <= dVar2) {
    return (float10)6.28318531 - fVar5;
  }
  return fVar5 + (float10)3.14159265;
}



float10 region_span(int region)

{
  char "region_span" [12];
  float10 fVar1;
  float10 fVar2;
  
  if (*(int *)(region + 4) == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xad8,"region_span","region->v1 != NULL");
  }
  if (*(int *)(region + 8) == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xad9,0x8151333,"region->v2 != NULL");
  }
  if (*(int *)(region + 0xc) == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xada,0x8151333,"region->origin != NULL");
  }
  fVar2 = (float10)point_xangle(*(int *)(region + 0xc),*(int *)(region + 4));
  fVar1 = (float10)point_xangle(*(undefined4 *)(region + 0xc),*(undefined4 *)(region + 8));
  fVar2 = (float10)(double)fVar2;
  if (fVar2 <= fVar1) {
    return fVar1 - fVar2;
  }
  return ((float10)6.28318531 - fVar2) + fVar1;
}



float10 coord_xangle(double ax,double ay,double bx,double by)

{
  float10 fVar1;
  double dVar2;
  
  if (0.00010000 <= ABS(ax - bx)) {
    dVar2 = atan(ABS(ay - by) / ABS(ax - bx));
    fVar1 = (float10)dVar2;
  }
  else {
    fVar1 = (float10)1.57079633;
  }
  if (by <= ay) {
    if (bx < ax) {
      fVar1 = (float10)3.14159265 - fVar1;
    }
    return fVar1;
  }
  if (ax <= bx) {
    return (float10)6.28318531 - fVar1;
  }
  return fVar1 + (float10)3.14159265;
}



float10 export_pcb_drawarc(int layer,int a,BDimension thickness,BDimension keepaway)

{
  int iVar1;
  double dVar2;
  ArcTypePtr *Ptr2;
  int iVar3;
  int in_GS_OFFSET;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  ulong local_2c;
  undefined4 local_28;
  undefined4 local_24;
  int local_20;
  
  iVar3 = 1;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  dVar2 = (*(double *)(*(int *)(a + 0x2c) + 0x14) - *(double *)(a + 0x24)) *
          (*(double *)(a + 0x1c) - *(double *)(a + 0xc)) -
          (*(double *)(*(int *)(a + 0x2c) + 0xc) - *(double *)(a + 0x1c)) *
          (*(double *)(a + 0x24) - *(double *)(a + 0x14));
  if (dVar2 <= 0.00010000) {
    iVar3 = (uint)(-0.00010000 <= dVar2) - 1;
  }
  fVar6 = (float10)coord_xangle();
  fVar4 = (float10)arc_angle();
  iVar1 = *(int *)(a + 0x3c);
  if ((0.00010000 < dVar2 || dVar2 < -0.00010000) && (iVar1 != 0)) {
    if (iVar1 != iVar3) {
      fVar4 = (float10)6.28318531 - fVar4;
    }
    fVar5 = ((float10)-iVar1 * fVar4 * (float10)180.00000000) / (float10)3.14159265;
    if (((((float10)1 <= fVar5) || (fVar5 <= -(float10)1)) && (fVar5 <= (float10)359.00000000)) &&
       ((float10)-359.00000000 <= fVar5)) {
      MakeFlags((FlagType *)&local_2c,(-(uint)(((PCB->Flags).f & 0x800) == 0) & 0xffffffe0) + 0xa0);
      Ptr2 = CreateNewArcOnLayer((LayerTypePtr)(&PCB->Data->field_0x4c + layer * 0x5c),
                                 (int)ROUND(*(double *)(*(int *)(a + 0x2c) + 0xc)),
                                 (int)ROUND(*(double *)(*(int *)(a + 0x2c) + 0x14)),
                                 (int)ROUND(*(double *)(a + 0x34)),(int)ROUND(*(double *)(a + 0x34))
                                 ,(int)ROUND(((double)fVar6 * 180.00000000) / 3.14159265),
                                 (int)ROUND((double)fVar5),thickness,keepaway,
                                 (FlagType)CONCAT48(local_24,CONCAT44(local_28,local_2c)));
      if (Ptr2 != (ArcTypePtr *)0x0) {
        AddObjectToCreateUndoList(0x4000,(void *)(&PCB->Data->field_0x4c + layer * 0x5c),Ptr2,Ptr2);
        fVar6 = ((float10)(double)fVar4 * (float10)*(double *)(a + 0x34)) / (float10)100.00000000;
        goto LAB_080dd35a;
      }
    }
  }
  fVar6 = (float10)0;
LAB_080dd35a:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return fVar6;
}



void vertex_move_towards_vertex_values(GtsVertex *v,GtsVertex *p,gdouble d,gdouble *x,gdouble *y)

{
  double dVar1;
  char "vertex_move_towards_vertex_values" [34];
  double __x;
  double dVar2;
  double dVar3;
  double local_2c;
  double local_24 [2];
  
  dVar3 = (double)(v->p).x;
  dVar2 = (double)(p->p).x - dVar3;
  dVar1 = (double)(p->p).y - (double)(v->p).y;
  __x = atan(ABS(dVar1 / dVar2));
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x382,"vertex_move_towards_vertex_values","finite(theta)")
    ;
  }
  if (dVar2 < 0.00000000) {
    if (dVar1 < 0.00000000) {
      sincos(__x,local_24,&local_2c);
      *(double *)x = dVar3 - (double)d * local_2c;
      *(double *)y = (double)(v->p).y - local_24[0] * (double)d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar3 - dVar2 * (double)d;
  }
  else {
    if (dVar1 < 0.00000000) {
      dVar2 = cos(__x);
      *(double *)x = dVar2 * (double)d + dVar3;
      dVar3 = sin(__x);
      *(double *)y = (double)(v->p).y - dVar3 * (double)d;
      return;
    }
    dVar2 = cos(__x);
    dVar3 = dVar2 * (double)d + dVar3;
  }
  *(double *)x = dVar3;
  dVar3 = sin(__x);
  *(double *)y = dVar3 * (double)d + (double)(v->p).y;
  return;
}



void vertex_move_towards_point_values
               (GtsVertex *v,gdouble px,gdouble py,gdouble d,gdouble *x,gdouble *y)

{
  char "vertex_move_towards_point_values" [33];
  double __x;
  double dVar1;
  double dVar2;
  double local_2c;
  double local_24 [2];
  
  dVar2 = (double)(v->p).x;
  dVar1 = (double)py - (double)(v->p).y;
  __x = atan(ABS(dVar1 / ((double)px - dVar2)));
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x360,"vertex_move_towards_point_values","finite(theta)");
  }
  if ((double)px - dVar2 < 0.00000000) {
    if (dVar1 < 0.00000000) {
      sincos(__x,local_24,&local_2c);
      *(double *)x = dVar2 - (double)d * local_2c;
      *(double *)y = (double)(v->p).y - local_24[0] * (double)d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar2 - dVar1 * (double)d;
  }
  else {
    if (dVar1 < 0.00000000) {
      dVar1 = cos(__x);
      *(double *)x = dVar1 * (double)d + dVar2;
      dVar2 = sin(__x);
      *(double *)y = (double)(v->p).y - dVar2 * (double)d;
      return;
    }
    dVar1 = cos(__x);
    dVar2 = dVar1 * (double)d + dVar2;
  }
  *(double *)x = dVar2;
  dVar2 = sin(__x);
  *(double *)y = dVar2 * (double)d + (double)(v->p).y;
  return;
}



void coord_move_towards_coord_values
               (gdouble ax,gdouble ay,gdouble px,gdouble py,gdouble d,gdouble *x,gdouble *y)

{
  char "coord_move_towards_coord_values" [32];
  double __x;
  double dVar1;
  double local_1c;
  double local_14;
  
  dVar1 = (double)py - (double)ay;
  __x = atan(ABS(dVar1 / ((double)px - (double)ax)));
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(__x)) {
    __printf_chk(1,"!finite(theta) a = %f,%f p = %f,%f d = %f\n",ax,ay,px,py,d);
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x33e,"coord_move_towards_coord_values","finite(theta)",
               ay._4_4_);
  }
  if ((double)px - (double)ax < 0.00000000) {
    if (dVar1 < 0.00000000) {
      sincos(__x,&local_14,&local_1c);
      *(double *)x = (double)ax - (double)d * local_1c;
      *(double *)y = (double)ay - local_14 * (double)d;
      return;
    }
    dVar1 = cos(__x);
    dVar1 = (double)ax - dVar1 * (double)d;
  }
  else {
    if (dVar1 < 0.00000000) {
      dVar1 = cos(__x);
      *(double *)x = dVar1 * (double)d + (double)ax;
      dVar1 = sin(__x);
      *(double *)y = (double)ay - dVar1 * (double)d;
      return;
    }
    dVar1 = cos(__x);
    dVar1 = dVar1 * (double)d + (double)ax;
  }
  *(double *)x = dVar1;
  dVar1 = sin(__x);
  *(double *)y = dVar1 * (double)d + (double)ay;
  return;
}



void point_from_point_to_point
               (toporouter_vertex_t *a,toporouter_vertex_t *b,gdouble d,gdouble *x,gdouble *y)

{
  double dVar1;
  double dVar2;
  char "point_from_point_to_point" [26];
  double __x;
  double dVar3;
  double local_2c;
  double local_24 [2];
  
  dVar3 = (double)(a->v).p.x;
  dVar1 = (double)(b->v).p.x - dVar3;
  dVar2 = (double)(b->v).p.y - (double)(a->v).p.y;
  __x = atan(ABS(dVar2 / dVar1));
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(__x)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x2e0,"point_from_point_to_point","finite(theta)");
  }
  *(double *)x = dVar3;
  *y = (a->v).p.y;
  if (dVar1 < 0.00000000) {
    if (dVar2 < 0.00000000) {
      sincos(__x,local_24,&local_2c);
      *(double *)x = (double)*x - (double)d * local_2c;
      *(double *)y = (double)*y - local_24[0] * (double)d;
      return;
    }
    dVar3 = cos(__x);
    dVar3 = (double)*x - dVar3 * (double)d;
  }
  else {
    if (dVar2 < 0.00000000) {
      dVar3 = cos(__x);
      *(double *)x = dVar3 * (double)d + (double)*x;
      dVar3 = sin(__x);
      *(double *)y = (double)*y - dVar3 * (double)d;
      return;
    }
    dVar3 = cos(__x);
    dVar3 = dVar3 * (double)d + (double)*x;
  }
  *(double *)x = dVar3;
  dVar3 = sin(__x);
  *(double *)y = dVar3 * (double)d + (double)*y;
  return;
}



// WARNING: Removing unreachable block (ram,0x080dd9a0)
// WARNING: Could not reconcile some variable overlaps

guint calculate_arc_to_arc(toporouter_t *ar,toporouter_arc_t *parc,toporouter_arc_t *arc)

{
  double dVar1;
  gdouble gVar2;
  toporouter_vertex_t *ptVar3;
  double d;
  double r;
  double dVar4;
  toporouter_arc_t *ptVar5;
  char "calculate_arc_to_arc" [21];
  int iVar6;
  toporouter_arc_t *ptVar7;
  float10 fVar8;
  float10 fVar9;
  double __x;
  undefined4 uVar10;
  int local_f0;
  undefined8 local_8c;
  toporouter_vertex_t *local_78;
  double local_6c;
  double local_64;
  undefined8 local_5c;
  gdouble local_54;
  gdouble local_4c;
  gdouble local_44;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  ptVar7 = arc;
  ptVar5 = parc;
  if ((double)arc->r < (double)parc->r) {
    ptVar7 = parc;
    ptVar5 = arc;
  }
  local_78 = ptVar5->centre;
  ptVar3 = ptVar7->centre;
  d = (double)(local_78->v).p.y;
  uVar10 = (undefined4)((ulonglong)d >> 0x20);
  r = (double)(local_78->v).p.x;
  dVar4 = (double)(ptVar3->v).p.x;
  if ((r == dVar4) ||
     (local_8c = (r - dVar4) / (d - (double)(ptVar3->v).p.y),
          
     179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     < local_8c)) {
    local_8c = 0.00000000;
  }
  else {
    local_8c = -1.00000000 / local_8c;
  }
  if (local_78 == ptVar3) {
    __printf_chk(1,"bigr->centre == smallr->centre @ %f,%f\n");
    ptVar3 = ptVar7->centre;
    local_78 = ptVar5->centre;
    if (ptVar3 == local_78) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x14d1,0x8151223,"bigr->centre != smallr->centre",uVar10
                );
    }
  }
  if (parc->dir == arc->dir) {
    d = (double)ptVar7->r;
    r = (double)ptVar5->r;
    fVar8 = (float10)gts_point_distance(ptVar3,local_78);
    __x = acos((double)((float10)(d - r) / fVar8));
    sincos(__x,&local_64,&local_6c);
    r = local_64 * (double)ptVar7->r;
    d = (double)ptVar7->r * local_6c;
    point_from_point_to_point(ptVar7->centre,ptVar5->centre,(gdouble)d,local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,(gdouble)local_8c,(gdouble)r,&local_34,&local_3c,&local_44,
                   &local_4c);
    local_f0 = 1;
    dVar4 = ((double)(ptVar7->centre->v).p.y - local_3c) *
            (local_34 - (double)(ptVar5->centre->v).p.x) -
            ((double)(ptVar7->centre->v).p.x - local_34) *
            (local_3c - (double)(ptVar5->centre->v).p.y);
    if ((dVar4 <= 0.00010000) && (local_f0 = -1, -0.00010000 <= dVar4)) {
      arc_ortho_projections(parc,arc,(gdouble *)&local_5c,&local_54);
      __printf_chk(1,"STRAIGHT:\n");
      __printf_chk(1,"bigr centre = %f,%f smallr centre = %f,%f\n",(ptVar7->centre->v).p.x,
                   (ptVar7->centre->v).p.y,(ptVar5->centre->v).p.x,(ptVar5->centre->v).p.y);
      dVar4 = (double)ptVar7->r;
      fVar8 = (float10)gts_point_distance(ptVar7->centre,ptVar5->centre);
      fVar9 = (float10)gts_point_distance(ptVar7->centre,ptVar5->centre);
      __printf_chk(1,"theta = %f a = %f b = %f bigrr = %f d = %f po = %f\n",__x,r,d,ptVar7->r,
                   (double)fVar9,dVar4 / (double)fVar8);
      d = (double)ptVar7->r;
      r = (double)ptVar5->r;
      fVar8 = (float10)gts_point_distance(ptVar7->centre,ptVar5->centre);
      __printf_chk(1,"bigr-r = %f smallr-r = %f ratio = %f\n",ptVar7->r,ptVar5->r,
                   (double)((float10)(d - r) / fVar8));
      __printf_chk(1,"preva = %f prevb = %f\n\n",local_54,local_5c);
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x14f0,0x8151223,"winddir",local_5c._4_4_)
      ;
    }
    arc_ortho_projections(parc,arc,(gdouble *)&local_5c,&local_54);
    if (ptVar7 == parc) {
      local_f0 = -local_f0;
    }
    if (ptVar7->dir == local_f0) {
      if (ptVar7 == arc) {
        *(double *)&ptVar7->x0 = local_34;
        *(double *)&ptVar7->y0 = local_3c;
      }
      else {
        *(double *)&ptVar7->x1 = local_34;
        *(double *)&ptVar7->y1 = local_3c;
      }
    }
    else {
      if (ptVar7 == arc) {
        ptVar7->x0 = local_44;
        ptVar7->y0 = local_4c;
      }
      else {
        ptVar7->x1 = local_44;
        ptVar7->y1 = local_4c;
      }
    }
    d = (double)ptVar5->r;
    point_from_point_to_point
              (ptVar5->centre,ptVar7->centre,(gdouble)-(local_6c * d),local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,(gdouble)local_8c,(gdouble)(d * local_64),&local_34,
                   &local_3c,&local_44,&local_4c);
    if (ptVar7->dir == local_f0) {
      if (ptVar7 != arc) {
        *(double *)&ptVar5->x0 = local_34;
        *(double *)&ptVar5->y0 = local_3c;
        return 0;
      }
      *(double *)&ptVar5->x1 = local_34;
      *(double *)&ptVar5->y1 = local_3c;
      return 0;
    }
  }
  else {
    d = (double)ptVar7->r;
    r = (double)ptVar5->r;
    fVar8 = (float10)gts_point_distance(ptVar3,local_78);
    __x = acos((double)((float10)(d + r) / fVar8));
    sincos(__x,&local_64,&local_6c);
    r = local_64 * (double)ptVar7->r;
    d = (double)ptVar7->r * local_6c;
    point_from_point_to_point(ptVar7->centre,ptVar5->centre,(gdouble)d,local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,(gdouble)local_8c,(gdouble)r,&local_34,&local_3c,&local_44,
                   &local_4c);
    local_f0 = 1;
    dVar4 = ((double)(ptVar7->centre->v).p.y - local_3c) *
            (local_34 - (double)(ptVar5->centre->v).p.x) -
            ((double)(ptVar7->centre->v).p.x - local_34) *
            (local_3c - (double)(ptVar5->centre->v).p.y);
    if ((dVar4 <= 0.00010000) && (local_f0 = -1, -0.00010000 <= dVar4)) {
      __printf_chk(1,"TWIST:\n");
      dVar4 = (double)ptVar7->r;
      dVar1 = (double)ptVar5->r;
      fVar8 = (float10)gts_point_distance(ptVar7->centre,ptVar5->centre);
      fVar9 = (float10)gts_point_distance(ptVar7->centre,ptVar5->centre);
      __printf_chk(1,"theta = %f a = %f b = %f r = %f d = %f po = %f\n",__x,r,d,
                   (double)ptVar7->r + (double)ptVar5->r,(double)fVar9,
                   (dVar4 + dVar1) / (double)fVar8);
      gVar2 = (ptVar7->centre->v).p.y;
      uVar10 = (undefined4)((ulonglong)gVar2 >> 0x20);
      __printf_chk(1,"bigr centre = %f,%f smallr centre = %f,%f\n\n",(ptVar7->centre->v).p.x,gVar2,
                   (ptVar5->centre->v).p.x,(ptVar5->centre->v).p.y);
      __printf_chk(1,"big wind = %d small wind = %d\n",ptVar7->dir,ptVar5->dir);
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x154c,"calculate_arc_to_arc","winddir",uVar10);
    }
    if (ptVar7 == parc) {
      local_f0 = -local_f0;
    }
    if (ptVar7->dir == local_f0) {
      if (ptVar7 == arc) {
        *(double *)&ptVar7->x0 = local_34;
        *(double *)&ptVar7->y0 = local_3c;
      }
      else {
        *(double *)&ptVar7->x1 = local_34;
        *(double *)&ptVar7->y1 = local_3c;
      }
    }
    else {
      if (ptVar7 == arc) {
        ptVar7->x0 = local_44;
        ptVar7->y0 = local_4c;
      }
      else {
        ptVar7->x1 = local_44;
        ptVar7->y1 = local_4c;
      }
    }
    d = (double)ptVar5->r;
    point_from_point_to_point
              (ptVar5->centre,ptVar7->centre,(gdouble)(local_6c * d),local_24,&local_2c);
    coords_on_line(local_24[0],local_2c,(gdouble)local_8c,(gdouble)(d * local_64),&local_34,
                   &local_3c,&local_44,&local_4c);
    iVar6 = 1;
    d = ((double)(ptVar7->centre->v).p.y - local_3c) * (local_34 - (double)(ptVar5->centre->v).p.x)
        - ((double)(ptVar7->centre->v).p.x - local_34) *
          (local_3c - (double)(ptVar5->centre->v).p.y);
    if ((d <= 0.00010000) && (iVar6 = -1, -0.00010000 <= d)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x156b,0x8151223,"winddir",local_8c._4_4_)
      ;
    }
    if (ptVar7 == parc) {
      iVar6 = -iVar6;
    }
    if (ptVar5->dir == iVar6) {
      if (ptVar7 == arc) {
        *(double *)&ptVar5->x1 = local_34;
        *(double *)&ptVar5->y1 = local_3c;
        return 0;
      }
      *(double *)&ptVar5->x0 = local_34;
      *(double *)&ptVar5->y0 = local_3c;
      return 0;
    }
  }
  if (ptVar7 == arc) {
    ptVar5->x1 = local_44;
    ptVar5->y1 = local_4c;
  }
  else {
    ptVar5->x0 = local_44;
    ptVar5->y0 = local_4c;
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x080de431)

void calculate_term_to_arc(toporouter_vertex_t *v,toporouter_arc_t *arc,guint dir)

{
  double dVar1;
  double dVar2;
  double m;
  double dVar3;
  char "calculate_term_to_arc" [22];
  int iVar4;
  float10 fVar5;
  double __x;
  undefined4 uVar6;
  double local_5c;
  double local_54;
  gdouble local_4c;
  gdouble local_44;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  __x = (double)arc->r;
  fVar5 = (float10)gts_point_distance(v,arc->centre);
  __x = acos((double)((float10)__x / fVar5));
  sincos(__x,&local_54,&local_5c);
  __x = (double)arc->r;
  point_from_point_to_point(arc->centre,v,(gdouble)(local_5c * __x),local_24,&local_2c);
  m = (double)(arc->centre->v).p.x;
  dVar1 = (double)(v->v).p.x;
  if ((m == dVar1) ||
     (m = (m - dVar1) / ((double)(arc->centre->v).p.y - (double)(v->v).p.y),
          
     179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
     < m)) {
    m = 0.00000000;
  }
  else {
    m = -1.00000000 / m;
  }
  coords_on_line(local_24[0],local_2c,(gdouble)m,(gdouble)(__x * local_54),&local_34,&local_3c,
                 &local_44,&local_4c);
  __x = (double)(arc->centre->v).p.y;
  m = (double)(arc->centre->v).p.x;
  iVar4 = 1;
  dVar1 = (double)(v->v).p.y;
  uVar6 = (undefined4)((ulonglong)dVar1 >> 0x20);
  dVar2 = (double)(v->v).p.x;
  dVar3 = (__x - local_3c) * (local_34 - dVar2) - (m - local_34) * (local_3c - dVar1);
  if ((dVar3 <= 0.00010000) && (iVar4 = -1, -0.00010000 <= dVar3)) {
    __printf_chk(1,"!winddir @ v %f,%f arc->centre %f,%f\n",dVar2,dVar1,m,__x);
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x147f,"calculate_term_to_arc","winddir",uVar6);
  }
  if (dir != 0) {
    iVar4 = -iVar4;
  }
  if (arc->dir != iVar4) {
    if (dir != 0) {
      arc->x1 = local_44;
      arc->y1 = local_4c;
      return;
    }
    arc->x0 = local_44;
    arc->y0 = local_4c;
    return;
  }
  if (dir == 0) {
    *(double *)&arc->x0 = local_34;
    *(double *)&arc->y0 = local_3c;
    return;
  }
  *(double *)&arc->x1 = local_34;
  *(double *)&arc->y1 = local_3c;
  return;
}



void clean_routing_edges(toporouter_t *r,toporouter_route_t *data)

{
  g_hash_table_foreach_remove(data->alltemppoints,temp_point_clean,0);
  g_hash_table_destroy(data->alltemppoints);
  data->alltemppoints = (GHashTable *)0x0;
  return;
}



void routedata_insert_temppoints(toporouter_route_t *data,GList *temppoints)

{
  if (temppoints != (GList *)0x0) {
    do {
      g_hash_table_insert(data->alltemppoints,temppoints->data,temppoints->data);
      temppoints = temppoints->next;
    } while (temppoints != (GList *)0x0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080de869)
// WARNING: Removing unreachable block (ram,0x080de6cb)
// WARNING: Removing unreachable block (ram,0x080de86d)
// WARNING: Removing unreachable block (ram,0x080de870)

float10 triangle_interior_capacity(GtsTriangle *t,GtsVertex *v)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double __value;
  double dVar3;
  double dVar4;
  char "triangle_interior_capacity" [27];
  GtsEdge *pGVar5;
  int iVar6;
  int iVar7;
  float10 fVar8;
  float10 fVar9;
  float10 fVar10;
  float10 fVar11;
  float10 fVar12;
  gdouble local_3c;
  double local_34;
  double local_24;
  
  pGVar5 = gts_triangle_edge_opposite(t,v);
  if (pGVar5 == (GtsEdge *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xc1e,"triangle_interior_capacity",&DAT_0815ff3f);
  }
  pGVar1 = (pGVar5->segment).v2;
  pGVar2 = (pGVar5->segment).v1;
  __value = (double)(pGVar1->p).x;
  local_24 = (double)(pGVar2->p).y;
  dVar3 = (double)(pGVar2->p).x;
  if (__value == dVar3) {
    local_34 = 0.00000000;
    __value = INFINITY;
  }
  else {
    __value = (__value - dVar3) / ((double)(pGVar1->p).y - local_24);
    if (
        179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
        < __value) {
      local_34 = 0.00000000;
    }
    else {
      local_34 = -1.00000000 / __value;
    }
  }
  iVar6 = __isinf(local_34);
  if (iVar6 == 0) {
    local_3c = (gdouble)((double)(v->p).y - local_34 * (double)(v->p).x);
  }
  else {
    local_3c = (v->p).x;
  }
  iVar7 = __isinf(__value);
  dVar4 = dVar3;
  if (iVar7 == 0) {
    dVar4 = local_24 - dVar3 * __value;
  }
  if (iVar6 == 0) {
    if (iVar7 == 0) {
      dVar3 = ((double)local_3c - dVar4) / (__value - local_34);
    }
    local_24 = (double)local_3c + local_34 * dVar3;
  }
  else {
    dVar3 = (double)(v->p).x;
  }
  gts_point_distance2(pGVar2,pGVar1);
  pGVar1 = (pGVar5->segment).v1;
  fVar8 = (float10)(double)(pGVar1->p).x;
  fVar9 = (float10)0.00010000;
  fVar10 = (float10)dVar3;
  if ((fVar8 - fVar9 < fVar10) && (fVar10 < fVar8 + fVar9)) {
    fVar11 = (float10)(double)(pGVar1->p).y;
    if ((fVar11 - fVar9 < (float10)local_24) && ((float10)local_24 < fVar9 + fVar11))
    goto LAB_080de8e0;
  }
  pGVar2 = (pGVar5->segment).v2;
  fVar9 = (float10)(double)(pGVar2->p).x;
  fVar11 = (float10)0.00010000;
  if ((fVar9 - fVar11 < fVar10) && (fVar10 < fVar9 + fVar11)) {
    fVar12 = (float10)(double)(pGVar2->p).y;
    if ((fVar12 - fVar11 < (float10)local_24) && ((float10)local_24 < fVar11 + fVar12))
    goto LAB_080de8e0;
  }
  fVar11 = fVar9;
  if (fVar8 <= fVar9 || fVar9 != fVar8) {
    fVar11 = fVar8;
  }
  if (fVar11 <= fVar10) {
    if (fVar8 <= fVar9) {
      fVar8 = fVar9;
    }
    if (fVar10 <= fVar8) {
      fVar8 = (float10)(double)(pGVar1->p).y;
      fVar11 = (float10)(double)(pGVar2->p).y;
      fVar9 = fVar11;
      if (fVar8 <= fVar11 || fVar11 != fVar8) {
        fVar9 = fVar8;
      }
      fVar12 = (float10)local_24;
      if (fVar9 <= fVar12) {
        if (fVar8 <= fVar11) {
          fVar8 = fVar11;
        }
        if (fVar12 <= fVar8) {
          fVar10 = (float10)(double)(v->p).x - fVar10;
          fVar12 = (float10)(double)(v->p).y - fVar12;
          return SQRT(fVar12 * fVar12 + fVar10 * fVar10);
        }
      }
    }
  }
LAB_080de8e0:
  return (float10)INFINITY;
}



GtsPoint * midpoint(GtsPoint *a,GtsPoint *b)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  GtsPointClass *klass;
  GtsPoint *pGVar5;
  
  dVar1 = (double)a->y;
  dVar2 = (double)b->y;
  dVar3 = (double)a->x;
  dVar4 = (double)b->x;
  klass = gts_point_class();
  pGVar5 = gts_point_new(klass,(gdouble)((dVar3 + dVar4) * 0.50000000),
                         (gdouble)((dVar1 + dVar2) * 0.50000000),0.00000000);
  return pGVar5;
}



toporouter_bbox_t *
toporouter_bbox_locate
          (toporouter_t *r,toporouter_term_t type,void *data,gdouble x,gdouble y,guint layergroup)

{
  GSList *pGVar1;
  toporouter_bbox_t *ptVar2;
  GtsPointClass *klass;
  GtsPoint *p;
  GSList *pGVar3;
  
  klass = gts_point_class();
  p = gts_point_new(klass,x,y,(gdouble)(double)(ulonglong)layergroup);
  pGVar3 = gts_bb_tree_stabbed(r->bboxtree,p);
  gts_object_destroy((GtsObject *)p);
  pGVar1 = pGVar3;
  while( true ) {
    if (pGVar1 == (GSList *)0x0) {
      g_slist_free(pGVar3);
      return (toporouter_bbox_t *)0x0;
    }
    ptVar2 = (toporouter_bbox_t *)pGVar1->data;
    if ((ptVar2->type == type) && (ptVar2->data == data)) break;
    pGVar1 = pGVar1->next;
  }
  g_slist_free(pGVar3);
  return ptVar2;
}



toporouter_cluster_t * cluster_find(toporouter_t *r,gdouble x,gdouble y,gdouble z)

{
  gpointer pvVar1;
  int iVar2;
  double dVar3;
  GtsPointClass *klass;
  GtsPoint *p;
  GSList *pGVar4;
  GtsFace *pGVar5;
  toporouter_cluster_t *local_40;
  
  klass = gts_point_class();
  p = gts_point_new(klass,x,y,z);
  pGVar4 = gts_bb_tree_stabbed(r->bboxtree,p);
  local_40 = (toporouter_cluster_t *)0x0;
  if (pGVar4 != (GSList *)0x0) {
    do {
      pvVar1 = pGVar4->data;
      if ((*(int *)((int)pvVar1 + 0x48) == (int)ROUND((double)z)) &&
         (*(int *)((int)pvVar1 + 0x40) != 7)) {
        if (*(int *)((int)pvVar1 + 0x40) == 5) {
          iVar2 = *(int *)((int)pvVar1 + 0x44);
          dVar3 = ((double)*(int *)(iVar2 + 0x44) - (double)y) *
                  ((double)x - (double)*(int *)(iVar2 + 0x2c)) -
                  ((double)*(int *)(iVar2 + 0x40) - (double)x) *
                  ((double)y - (double)*(int *)(iVar2 + 0x30));
          if ((dVar3 <= 0.00010000) && (-0.00010000 <= dVar3)) {
            local_40 = *(toporouter_cluster_t **)((int)pvVar1 + 0x60);
          }
        }
        else {
          if ((*(GtsSurface **)((int)pvVar1 + 0x4c) != (GtsSurface *)0x0) &&
             (pGVar5 = gts_point_locate(p,*(GtsSurface **)((int)pvVar1 + 0x4c),(GtsFace *)0x0),
             pGVar5 != (GtsFace *)0x0)) {
            local_40 = *(toporouter_cluster_t **)((int)pvVar1 + 0x60);
            break;
          }
        }
      }
      pGVar4 = pGVar4->next;
    } while (pGVar4 != (GSList *)0x0);
  }
  gts_object_destroy((GtsObject *)p);
  return local_40;
}



toporouter_route_t * import_route(toporouter_t *r,RatType *line)

{
  double x;
  char "import_route" [13];
  toporouter_route_t *__ptr;
  toporouter_cluster_t *ptVar1;
  _toporouter_cluster_t *p_Var2;
  GList *pGVar3;
  toporouter_route_t *ptVar4;
  undefined4 uVar5;
  
  __ptr = routedata_create();
  ptVar1 = cluster_find(r,(gdouble)(double)(line->Point1).X,(gdouble)(double)(line->Point1).Y,
                        (gdouble)(double)(ulonglong)line->group1);
  *(toporouter_cluster_t **)&__ptr->src = ptVar1;
  x = (double)(line->Point2).X;
  uVar5 = (undefined4)((ulonglong)x >> 0x20);
  p_Var2 = (_toporouter_cluster_t *)
           cluster_find(r,(gdouble)x,(gdouble)(double)(line->Point2).Y,
                        (gdouble)(double)(ulonglong)line->group2);
  __ptr->dest = p_Var2;
  if (__ptr->src == (_toporouter_cluster_t *)0x0) {
    __printf_chk(1,"couldn\'t locate src\n",uVar5);
    p_Var2 = __ptr->dest;
  }
  if (p_Var2 == (_toporouter_cluster_t *)0x0) {
    __printf_chk(1,"couldn\'t locate dest\n",uVar5);
  }
  p_Var2 = __ptr->src;
  if ((p_Var2 == (_toporouter_cluster_t *)0x0) || (__ptr->dest == (_toporouter_cluster_t *)0x0)) {
    __printf_chk(1,"PROBLEM: couldn\'t locate rat src or dest for rat %d,%d,%d -> %d,%d,%d\n",
                 (line->Point1).X,(line->Point1).Y,line->group1,(line->Point2).X,(line->Point2).Y,
                 line->group2);
    ptVar4 = (toporouter_route_t *)0x0;
    free(__ptr);
  }
  else {
    *(toporouter_netlist_t **)&__ptr->netlist = p_Var2->netlist;
    if (p_Var2->netlist != __ptr->dest->netlist) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x18d2,"import_route",
                 "routedata->src->netlist == routedata->dest->netlist");
    }
    g_ptr_array_add(r->routes,__ptr,uVar5);
    g_ptr_array_add(__ptr->netlist->routes,__ptr,uVar5);
    pGVar3 = (GList *)g_list_prepend(r->failednets,__ptr,uVar5);
    r->failednets = pGVar3;
    ptVar4 = __ptr;
  }
  return ptVar4;
}



void acquire_twonets(toporouter_t *r)

{
  RatType *line;
  DataTypePtr *pDVar1;
  int iVar2;
  int iVar3;
  
  pDVar1 = PCB->Data;
  iVar2 = pDVar1->RatN - 1;
  if (iVar2 != -1) {
    iVar3 = pDVar1->RatN * 0x5c;
    while( true ) {
      line = (RatType *)((int)&pDVar1->Rat[-1].BoundingBox.X1 + iVar3);
      if ((*(byte *)&(line->Flags).f & 0x40) != 0) {
        import_route(r,line);
      }
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      pDVar1 = PCB->Data;
      iVar3 = iVar3 + -0x5c;
    }
  }
  if (r->routes->len == 0) {
    pDVar1 = PCB->Data;
    iVar2 = pDVar1->RatN - 1;
    if (iVar2 != -1) {
      iVar3 = pDVar1->RatN * 0x5c;
      while( true ) {
        iVar2 = iVar2 + -1;
        import_route(r,(RatType *)((int)&pDVar1->Rat[-1].BoundingBox.X1 + iVar3));
        if (iVar2 == -1) break;
        pDVar1 = PCB->Data;
        iVar3 = iVar3 + -0x5c;
      }
    }
  }
  return;
}



void import_clusters(toporouter_t *r)

{
  char **ppcVar1;
  int iVar2;
  toporouter_netlist_t *netlist;
  GPtrArray *pGVar3;
  toporouter_cluster_t *cluster;
  int iVar4;
  toporouter_bbox_t *box;
  int iVar5;
  int *piVar6;
  uint uVar7;
  int *piVar8;
  NetListListType *pNVar9;
  uint layergroup;
  NetListListType *pNVar10;
  byte bVar11;
  toporouter_term_t local_98;
  void *data;
  guint layergroup_00;
  Cardinal local_64;
  undefined *local_60;
  int local_58;
  int local_50;
  int local_48;
  int local_44;
  NetListListType local_3c;
  NetListListType nets;
  
  bVar11 = 0;
  ResetFoundPinsViasAndPads('\0');
  ResetFoundLinesAndPolygons('\0');
  CollectSubnets(&local_3c,'\0');
  iVar5 = 3;
  pNVar9 = &local_3c;
  pNVar10 = &nets;
  while (iVar5 != 0) {
    iVar5 = iVar5 + -1;
    pNVar10->NetListN = pNVar9->NetListN;
    pNVar9 = (NetListListType *)((int)pNVar9 + (uint)bVar11 * -8 + 4);
    pNVar10 = (NetListListType *)((int)pNVar10 + (uint)bVar11 * -8 + 4);
  }
  local_60 = (undefined *)(nets.NetListN * 0xc);
  do {
    do {
      do {
        local_60 = &DAT_fffffff4 + (int)local_60;
        local_64 = nets.NetListN - 1;
        if (local_64 == 0xffffffff) {
          FreeNetListListMemory((NetListListTypePtr *)&nets);
          return;
        }
        piVar6 = (int *)((int)&(nets.NetList)->NetN + (int)local_60);
        nets.NetListN = local_64;
      } while (*piVar6 == 0);
      netlist = (toporouter_netlist_t *)calloc(1,0x14);
      ppcVar1 = *(char ***)(*(int *)(piVar6[2] + 8) + 0x18);
      netlist->netlist = *ppcVar1;
      netlist->style = ppcVar1[2];
      pGVar3 = (GPtrArray *)g_ptr_array_new();
      netlist->clusters = pGVar3;
      pGVar3 = (GPtrArray *)g_ptr_array_new();
      netlist->routed = (GList *)0x0;
      netlist->routes = pGVar3;
      g_ptr_array_add(r->netlists,netlist);
      local_58 = *piVar6 + -1;
    } while (local_58 == -1);
    local_50 = (*piVar6 + 0xfffffff) * 0x10;
    do {
      iVar5 = piVar6[2];
      cluster = cluster_create(r,netlist);
      iVar2 = *(int *)(local_50 + iVar5);
      local_44 = iVar2 + -1;
      if (local_44 != -1) {
        local_48 = iVar2 * 0x1c + -0x1c;
        do {
          while( true ) {
            piVar8 = (int *)(local_48 + ((int *)(local_50 + iVar5))[2]);
            iVar2 = piVar8[2];
            if (iVar2 == 4) break;
            if (iVar2 == 0x200) {
              box = toporouter_bbox_locate
                              (r,PAD,(void *)piVar8[4],(gdouble)(double)*piVar8,
                               (gdouble)(double)piVar8[1],piVar8[5]);
              cluster_join_bbox(cluster,box);
            }
            else {
              layergroup = 0;
              if (iVar2 == 0x100) {
                while (iVar2 = PCB->Data->LayerN, 0 < iVar2) {
                  uVar7 = 0;
                  iVar4 = 0;
                  do {
                    uVar7 = (uVar7 + 1) - (uint)((PCB->LayerGroups).Number[iVar4] == 0);
                    iVar4 = iVar4 + 1;
                  } while (iVar4 != iVar2);
                  if (uVar7 <= layergroup) break;
                  box = toporouter_bbox_locate
                                  (r,PIN,(void *)piVar8[4],(gdouble)(double)*piVar8,
                                   (gdouble)(double)piVar8[1],layergroup);
                  cluster_join_bbox(cluster,box);
                  layergroup = layergroup + 1;
                }
              }
              else {
                layergroup = 0;
                if (iVar2 == 1) {
                  while (iVar2 = PCB->Data->LayerN, 0 < iVar2) {
                    uVar7 = 0;
                    iVar4 = 0;
                    do {
                      uVar7 = (uVar7 + 1) - (uint)((PCB->LayerGroups).Number[iVar4] == 0);
                      iVar4 = iVar4 + 1;
                    } while (iVar4 != iVar2);
                    if (uVar7 <= layergroup) break;
                    box = toporouter_bbox_locate
                                    (r,VIA,(void *)piVar8[4],(gdouble)(double)*piVar8,
                                     (gdouble)(double)piVar8[1],layergroup);
                    cluster_join_bbox(cluster,box);
                    layergroup = layergroup + 1;
                  }
                }
                else {
                  if (iVar2 == 8) {
                    layergroup_00 = piVar8[5];
                    iVar2 = piVar8[1];
                    iVar4 = *piVar8;
                    data = (void *)piVar8[4];
                    local_98 = POLYGON;
                    goto LAB_080df0ef;
                  }
                }
              }
            }
            local_44 = local_44 + -1;
            local_48 = local_48 + -0x1c;
            if (local_44 == -1) goto LAB_080df11b;
          }
          layergroup_00 = piVar8[5];
          iVar2 = piVar8[1];
          iVar4 = *piVar8;
          data = (void *)piVar8[4];
          local_98 = LINE;
LAB_080df0ef:
          box = toporouter_bbox_locate
                          (r,local_98,data,(gdouble)(double)iVar4,(gdouble)(double)iVar2,
                           layergroup_00);
          cluster_join_bbox(cluster,box);
          local_44 = local_44 + -1;
          local_48 = local_48 + -0x1c;
        } while (local_44 != -1);
      }
LAB_080df11b:
      local_58 = local_58 + -1;
      local_50 = local_50 + -0x10;
    } while (local_58 != -1);
  } while( true );
}



float10 triangle_cost(undefined4 t,double **data)

{
  double *pdVar1;
  double *pdVar2;
  float10 fVar3;
  float10 fVar4;
  
  pdVar1 = *data;
  pdVar2 = data[1];
  fVar4 = (float10)gts_triangle_quality(t);
  fVar3 = (float10)gts_triangle_area(t);
  fVar4 = (float10)(double)fVar4;
  if (((float10)*pdVar1 <= fVar4) && (fVar3 <= (float10)*pdVar2)) {
    fVar4 = (float10)0;
  }
  return fVar4;
}



GSList * list_to_slist(GList *i)

{
  GSList *pGVar1;
  
  pGVar1 = (GSList *)0x0;
  if (i != (GList *)0x0) {
    do {
      pGVar1 = (GSList *)g_slist_prepend(pGVar1,i->data);
      i = i->next;
    } while (i != (GList *)0x0);
  }
  return pGVar1;
}



float10 lookup_thickness(char *name)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  
  pPVar1 = PCB;
  iVar2 = Settings.LineThickness;
  if (name != (char *)0x0) {
    iVar3 = 0;
    pPVar4 = PCB;
    do {
      iVar2 = strcmp(pPVar4->RouteStyle[0].Name,name);
      if (iVar2 == 0) {
        iVar2 = pPVar1->RouteStyle[iVar3].Thick;
        break;
      }
      iVar3 = iVar3 + 1;
      pPVar4 = (PCBTypePtr)&pPVar4->PrintFilename;
      iVar2 = Settings.LineThickness;
    } while (iVar3 != 4);
  }
  return (float10)iVar2;
}



float10 vertex_net_thickness(int v)

{
  int iVar1;
  int iVar2;
  unkbyte10 Var3;
  
  if (v == 0) goto LAB_080df392;
  iVar2 = *(int *)(v + 0x28);
  if (iVar2 == 0) {
    if ((*(uint *)(v + 0x38) & 0x180) == 0) goto LAB_080df392;
    do {
      v = *(int *)(v + 0x2c);
      if (v == 0) goto LAB_080df392;
    } while ((*(uint *)(v + 0x38) & 0x180) != 0);
    iVar2 = *(int *)(v + 0x28);
    if (iVar2 == 0) goto LAB_080df392;
  }
  else {
    iVar1 = *(int *)(iVar2 + 0x40);
    if (iVar1 - 1U < 2) {
      iVar2 = *(int *)(iVar2 + 0x44);
      if ((*(uint *)(iVar2 + 0x14) & 0x900) == 0) {
LAB_080df34c:
        return (float10)*(int *)(iVar2 + 0x24);
      }
LAB_080df333:
      return (float10)0;
    }
    if (iVar1 == 0) {
      iVar2 = *(int *)(iVar2 + 0x44);
      if (((*(int *)(iVar2 + 0x2c) == *(int *)(iVar2 + 0x40)) &&
          (*(int *)(iVar2 + 0x30) == *(int *)(iVar2 + 0x44))) &&
         ((*(byte *)(iVar2 + 0x15) & 1) == 0)) goto LAB_080df34c;
      goto LAB_080df333;
    }
    if (iVar1 == 7) goto LAB_080df333;
    if (iVar1 == 5) {
      iVar2 = *(int *)(iVar2 + 0x44);
      goto LAB_080df34c;
    }
    if (iVar1 == 9) goto LAB_080df333;
    __printf_chk(1,"Unrecognized type in thickness lookup..\n");
  }
  if (*(int *)(iVar2 + 0x60) != 0) {
    Var3 = lookup_thickness();
    return (float10)Var3;
  }
LAB_080df392:
  return (float10)Settings.LineThickness;
}



float10 lookup_keepaway(char *name)

{
  PCBTypePtr pPVar1;
  int iVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  
  pPVar1 = PCB;
  iVar2 = Settings.Keepaway;
  if (name != (char *)0x0) {
    iVar3 = 0;
    pPVar4 = PCB;
    do {
      iVar2 = strcmp(pPVar4->RouteStyle[0].Name,name);
      if (iVar2 == 0) {
        iVar2 = pPVar1->RouteStyle[iVar3].Keepaway;
        break;
      }
      iVar3 = iVar3 + 1;
      pPVar4 = (PCBTypePtr)&pPVar4->PrintFilename;
      iVar2 = Settings.Keepaway;
    } while (iVar3 != 4);
  }
  return (float10)iVar2;
}



float10 oproute_min_spacing(int a,int b)

{
  float10 fVar1;
  float10 fVar2;
  float10 fVar3;
  float10 fVar4;
  
  fVar1 = (float10)lookup_thickness(*(undefined4 *)(a + 0xc));
  fVar2 = (float10)lookup_thickness(*(undefined4 *)(b + 0xc));
  fVar4 = (float10)lookup_keepaway(*(undefined4 *)(a + 0xc));
  fVar3 = (float10)lookup_keepaway(*(undefined4 *)(b + 0xc));
  if (fVar3 < (float10)(double)fVar4) {
    fVar4 = (float10)lookup_keepaway(*(undefined4 *)(a + 0xc));
  }
  else {
    fVar4 = (float10)lookup_keepaway(*(undefined4 *)(b + 0xc));
  }
  return (float10)0.50000000 * (float10)(double)fVar2 + (float10)(double)fVar1 * (float10)0.50000000
         + fVar4;
}



void export_oproutes(toporouter_t *ar,toporouter_oproute_t *oproute)

{
  double dVar1;
  Cardinal CVar2;
  toporouter_vertex_t *ptVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  gpointer pvVar9;
  GList *pGVar10;
  gpointer pvVar11;
  gpointer pvVar12;
  float10 fVar13;
  float10 fVar14;
  float10 fVar15;
  undefined4 local_44;
  undefined4 local_2c;
  
  CVar2 = (PCB->LayerGroups).Entries[oproute->layergroup * 0x12];
  fVar13 = (float10)lookup_thickness(oproute->style);
  local_2c = (undefined4)(longlong)ROUND(fVar13);
  uVar6 = local_2c;
  fVar13 = (float10)lookup_keepaway(oproute->style);
  pGVar10 = oproute->arcs;
  local_2c = (undefined4)(longlong)ROUND(fVar13);
  uVar7 = local_2c;
  if (pGVar10 == (GList *)0x0) {
    dVar1 = (double)ar->wiring_score;
    local_2c = (undefined4)(longlong)ROUND((double)(oproute->term2->v).p.y);
    uVar4 = local_2c;
    local_2c = (undefined4)(longlong)ROUND((double)(oproute->term2->v).p.x);
    uVar5 = local_2c;
    local_2c = (undefined4)(longlong)ROUND((double)(oproute->term1->v).p.y);
    uVar8 = local_2c;
    local_2c = (undefined4)(longlong)ROUND((double)(oproute->term1->v).p.x);
    fVar13 = (float10)export_pcb_drawline(CVar2,local_2c,uVar8,uVar5,uVar4,uVar6,uVar7);
    *(double *)&ar->wiring_score = (double)(fVar13 + (float10)dVar1);
    return;
  }
  fVar13 = (float10)(double)ar->wiring_score;
  pvVar9 = pGVar10->data;
  pvVar12 = (gpointer)0x0;
  do {
    pvVar11 = pvVar9;
    if (pvVar11 == (gpointer)0x0) {
      if (pvVar12 != (gpointer)0x0) {
        fVar13 = (float10)(double)ar->wiring_score;
        goto LAB_080df55c;
      }
LAB_080df579:
      local_44 = (undefined4)(longlong)ROUND(*(double *)((int)pvVar11 + 0x14));
      uVar4 = local_44;
      local_44 = (undefined4)(longlong)ROUND(*(double *)((int)pvVar11 + 0xc));
      uVar5 = local_44;
      local_44 = (undefined4)(longlong)ROUND((double)(oproute->term1->v).p.y);
      local_2c = (undefined4)(longlong)ROUND((double)(oproute->term1->v).p.x);
      fVar14 = (float10)export_pcb_drawline(CVar2,local_2c,local_44,uVar5,uVar4,uVar6,uVar7);
      pGVar10 = pGVar10->next;
      fVar13 = (float10)(double)fVar13 + fVar14;
      *(double *)&ar->wiring_score = (double)fVar13;
    }
    else {
      if (pvVar12 == (gpointer)0x0) goto LAB_080df579;
      fVar14 = (float10)export_pcb_drawarc(CVar2,pvVar12,uVar6,uVar7);
      *(double *)&ar->wiring_score = (double)((float10)(double)fVar13 + fVar14);
      local_2c = (undefined4)(longlong)ROUND(*(double *)((int)pvVar11 + 0x14));
      uVar4 = local_2c;
      local_2c = (undefined4)(longlong)ROUND(*(double *)((int)pvVar11 + 0xc));
      uVar5 = local_2c;
      local_2c = (undefined4)(longlong)ROUND(*(double *)((int)pvVar12 + 0x24));
      uVar8 = local_2c;
      local_2c = (undefined4)(longlong)ROUND(*(double *)((int)pvVar12 + 0x1c));
      fVar15 = (float10)export_pcb_drawline(CVar2,local_2c,uVar8,uVar5,uVar4,uVar6,uVar7);
      fVar13 = (float10)(double)((float10)(double)fVar13 + fVar14) + fVar15;
      *(double *)&ar->wiring_score = (double)fVar13;
LAB_080df55c:
      pGVar10 = pGVar10->next;
    }
    if (pGVar10 == (GList *)0x0) {
      fVar14 = (float10)export_pcb_drawarc(CVar2,pvVar11,uVar6,uVar7);
      ptVar3 = oproute->term2;
      *(double *)&ar->wiring_score = (double)((float10)(double)fVar13 + fVar14);
      local_2c = (undefined4)(longlong)ROUND((double)(ptVar3->v).p.y);
      uVar4 = local_2c;
      local_2c = (undefined4)(longlong)ROUND((double)(ptVar3->v).p.x);
      uVar5 = local_2c;
      local_2c = (undefined4)(longlong)ROUND(*(double *)((int)pvVar11 + 0x24));
      uVar8 = local_2c;
      local_2c = (undefined4)(longlong)ROUND(*(double *)((int)pvVar11 + 0x1c));
      fVar15 = (float10)export_pcb_drawline(CVar2,local_2c,uVar8,uVar5,uVar4,uVar6,uVar7);
      *(double *)&ar->wiring_score =
           (double)((float10)(double)((float10)(double)fVar13 + fVar14) + fVar15);
      return;
    }
    pvVar9 = pGVar10->data;
    pvVar12 = pvVar11;
  } while( true );
}



float10 vertex_net_keepaway(int v)

{
  int iVar1;
  unkbyte10 Var2;
  
  if (v == 0) goto LAB_080df848;
  iVar1 = *(int *)(v + 0x28);
  if (iVar1 == 0) {
    if ((*(uint *)(v + 0x38) & 0x180) == 0) goto LAB_080df848;
    do {
      v = *(int *)(v + 0x2c);
      if (v == 0) goto LAB_080df848;
    } while ((*(uint *)(v + 0x38) & 0x180) != 0);
    iVar1 = *(int *)(v + 0x28);
    if (iVar1 == 0) goto LAB_080df848;
  }
  if (*(int *)(iVar1 + 0x60) != 0) {
    Var2 = lookup_keepaway();
    return (float10)Var2;
  }
LAB_080df848:
  return (float10)Settings.Keepaway;
}



toporouter_arc_class_t * toporouter_arc_class(void)

{
  toporouter_arc_class_t *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (toporouter_arc_class_t *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &constraint_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name._0_4_ = 0x6f706f74;
    constraint_info.name._4_4_ = 0x74756f72;
    constraint_info.name._8_4_ = 0x615f7265;
    constraint_info.name._12_4_ = 0x745f6372;
    constraint_info.object_size = 0x50;
    constraint_info.class_size = 0x60;
    constraint_info.object_init_func = toporouter_arc_init;
    parent_class = (GtsObjectClass *)gts_constraint_class();
    klass = (toporouter_arc_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



toporouter_arc_t *
toporouter_arc_new(toporouter_oproute_t *oproute,toporouter_vertex_t *v1,toporouter_vertex_t *v2,
                  toporouter_vertex_t *centre,gdouble r,gint dir)

{
  toporouter_arc_class_t *klass;
  toporouter_arc_t *ptVar1;
  
  klass = toporouter_arc_class();
  ptVar1 = (toporouter_arc_t *)gts_object_new((GtsObjectClass *)klass);
  ptVar1->centre = centre;
  ptVar1->v = v1;
  ptVar1->r = r;
  ptVar1->v1 = v1;
  ptVar1->v2 = v2;
  ptVar1->dir = dir;
  if (v1 != (toporouter_vertex_t *)0x0) {
    *(toporouter_arc_t **)&v1->arc = ptVar1;
  }
  ptVar1->clearance = (GList *)0x0;
  ptVar1->oproute = oproute;
  return ptVar1;
}



toporouter_constraint_class_t * toporouter_constraint_class(void)

{
  toporouter_constraint_class_t *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (toporouter_constraint_class_t *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &constraint_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name._0_4_ = 0x6f706f74;
    constraint_info.name._4_4_ = 0x74756f72;
    constraint_info.name._8_4_ = 0x635f7265;
    constraint_info.name._12_4_ = 0x74736e6f;
    constraint_info.name._16_4_ = 0x6e696172;
    constraint_info.name._20_4_ = 0x745f74;
    constraint_info.object_size = 0x20;
    constraint_info.class_size = 0x5c;
    constraint_info.class_init_func = toporouter_constraint_class_init;
    constraint_info.object_init_func = toporouter_constraint_init;
    parent_class = (GtsObjectClass *)gts_constraint_class();
    klass = (toporouter_constraint_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



toporouter_vertex_class_t * toporouter_vertex_class(void)

{
  toporouter_vertex_class_t *klass;
  GtsVertexClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (toporouter_vertex_class_t *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &constraint_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name._0_4_ = 0x6f706f74;
    constraint_info.name._4_4_ = 0x74756f72;
    constraint_info.name._8_4_ = 0x765f7265;
    constraint_info.name._12_4_ = 0x65747265;
    constraint_info.name._16_4_ = 0x745f78;
    constraint_info.object_size = 100;
    constraint_info.class_size = 100;
    constraint_info.class_init_func = toporouter_vertex_class_init;
    constraint_info.object_init_func = toporouter_vertex_init;
    parent_class = gts_vertex_class();
    klass = (toporouter_vertex_class_t *)
            gts_object_class_new((GtsObjectClass *)parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Removing unreachable block (ram,0x080dfb0f)
// WARNING: Removing unreachable block (ram,0x080dfb17)
// WARNING: Removing unreachable block (ram,0x080dfb20)

void create_board_edge(gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble max,gint layer,
                      GList **vlist)

{
  ulonglong uVar1;
  double dVar2;
  GtsVertexClass *klass;
  GtsVertex *pGVar3;
  GList *pGVar4;
  uint uVar5;
  uint local_3c;
  gdouble local_2c;
  gdouble local_24 [2];
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  dVar2 = SQRT(((double)y0 - (double)y1) * ((double)y0 - (double)y1) +
               ((double)x0 - (double)x1) * ((double)x0 - (double)x1));
  uVar1 = (ulonglong)ROUND(dVar2 / (double)max);
  local_3c = (uint)uVar1;
  if (local_3c != 0) {
    local_24[0] = x0;
    local_2c = y0;
    pGVar3 = gts_vertex_new(klass,x0,y0,(gdouble)(double)layer);
    pGVar4 = (GList *)g_list_prepend(*vlist,pGVar3);
    *vlist = pGVar4;
    if (local_3c != 1) {
      uVar5 = 1;
      do {
        uVar5 = uVar5 + 1;
        coord_move_towards_coord_values
                  (x0,y0,x1,y1,(gdouble)(dVar2 / (double)(uVar1 & 0xffffffff)),local_24,&local_2c);
        pGVar3 = gts_vertex_new(klass,local_24[0],local_2c,(gdouble)(double)layer);
        pGVar4 = (GList *)g_list_prepend(*vlist,pGVar3);
        *vlist = pGVar4;
        x0 = local_24[0];
        y0 = local_2c;
      } while (uVar5 < local_3c);
    }
    return;
  }
  local_24[0] = x0;
  local_2c = y0;
  pGVar3 = gts_vertex_new(klass,x0,y0,(gdouble)(double)layer);
  pGVar4 = (GList *)g_list_prepend(*vlist,pGVar3);
  *vlist = pGVar4;
  return;
}



GList * rect_with_attachments
                  (gdouble rad,gdouble x0,gdouble y0,gdouble x1,gdouble y1,gdouble x2,gdouble y2,
                  gdouble x3,gdouble y3,gdouble z)

{
  GList *pGVar1;
  GList *pGVar2;
  ulonglong uVar3;
  GtsVertexClass *klass;
  GtsVertex *pGVar4;
  undefined4 uVar5;
  GtsVertex *pGVar6;
  GList *pGVar7;
  GList *pGVar8;
  ulonglong local_d8;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar4 = gts_vertex_new(klass,x0,y0,z);
  uVar5 = g_list_prepend(0,pGVar4,x0._4_4_);
  pGVar6 = gts_vertex_new(klass,x1,y1,z);
  uVar5 = g_list_prepend(uVar5,pGVar6,x1._4_4_);
  pGVar6 = gts_vertex_new(klass,x2,y2,z);
  uVar5 = g_list_prepend(uVar5,pGVar6,x2._4_4_);
  pGVar6 = gts_vertex_new(klass,x3,y3,z);
  local_d8 = CONCAT44(x3._4_4_,pGVar6);
  pGVar7 = (GList *)g_list_prepend(uVar5,pGVar6,x3._4_4_);
  pGVar8 = (GList *)0x0;
  pGVar1 = pGVar7;
  pGVar2 = pGVar7;
  while (pGVar1 != (GList *)0x0) {
    pGVar6 = (GtsVertex *)pGVar1->data;
    uVar3 = local_d8 >> 0x20;
    local_d8 = local_d8 & 0xffffffff00000000;
    pGVar8 = (GList *)g_list_prepend(pGVar8,pGVar4,(int)uVar3);
    pGVar1 = (GList *)(&pGVar1->data)[1];
    pGVar4 = pGVar6;
    pGVar2 = pGVar8;
  }
  g_list_free(pGVar7);
  return pGVar2;
}



void insert_centre_point(toporouter_t *r,toporouter_layer_t *l,gdouble x,gdouble y)

{
  GtsVertexClass *klass;
  GtsVertex *pGVar1;
  GList *pGVar2;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = l->vertices;
  while( true ) {
    if (pGVar2 == (GList *)0x0) {
      pGVar1 = gts_vertex_new(klass,x,y,0.00000000);
      pGVar2 = (GList *)g_list_prepend(l->vertices,pGVar1,x._4_4_);
      l->vertices = pGVar2;
      return;
    }
    if ((*(double *)((int)pGVar2->data + 0xc) == (double)x) &&
       (*(double *)((int)pGVar2->data + 0x14) == (double)y)) break;
    pGVar2 = pGVar2->next;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080dff25)
// WARNING: Removing unreachable block (ram,0x080dff38)

GList * insert_constraint_edge
                  (toporouter_t *r,toporouter_layer_t *l,gdouble x1,gdouble y1,guint flags1,
                  gdouble x2,gdouble y2,guint flags2,toporouter_bbox_t *box)

{
  double dVar1;
  GtsVertex *pGVar2;
  GtsVertexClass *klass;
  GtsEdgeClass *klass_00;
  GList *pGVar3;
  GtsEdge *pGVar4;
  GtsVertex *v2;
  GtsVertex *v1;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  klass_00 = (GtsEdgeClass *)toporouter_constraint_class();
  pGVar3 = l->vertices;
  if (pGVar3 == (GList *)0x0) {
    v2 = (GtsVertex *)0x0;
  }
  else {
    v2 = (GtsVertex *)0x0;
    v1 = (GtsVertex *)0x0;
    do {
      pGVar2 = (GtsVertex *)pGVar3->data;
      dVar1 = (double)(pGVar2->p).x;
      if ((dVar1 == (double)x1) && ((double)(pGVar2->p).y == (double)y1)) {
        v1 = pGVar2;
      }
      if ((dVar1 == (double)x2) && ((double)(pGVar2->p).y == (double)y2)) {
        v2 = pGVar2;
      }
      pGVar3 = (GList *)(&pGVar3->data)[1];
    } while (pGVar3 != (GList *)0x0);
    if (v1 != (GtsVertex *)0x0) goto LAB_080dff4e;
  }
  v1 = gts_vertex_new(klass,x1,y1,(gdouble)(double)((int)((int)l - (int)r->layers) >> 4));
  *(toporouter_bbox_t **)&v1[1].p.object.klass = box;
  pGVar3 = (GList *)g_list_prepend(l->vertices);
  l->vertices = pGVar3;
LAB_080dff4e:
  if (v2 == (GtsVertex *)0x0) {
    v2 = gts_vertex_new(klass,x2,y2,(gdouble)(double)((int)((int)l - (int)r->layers) >> 4));
    *(toporouter_bbox_t **)&v2[1].p.object.klass = box;
    pGVar3 = (GList *)g_list_prepend(l->vertices);
    l->vertices = pGVar3;
  }
  *(guint *)((int)&v1[1].p.x + 4) = flags1;
  *(guint *)((int)&v2[1].p.x + 4) = flags2;
  pGVar4 = gts_edge_new(klass_00,v1,v2);
  *(toporouter_bbox_t **)&pGVar4[1].segment.object.klass = box;
  pGVar3 = (GList *)g_list_prepend(l->constraints,pGVar4,v2);
  l->constraints = pGVar3;
  pGVar3 = (GList *)g_list_prepend();
  return pGVar3;
}



void insert_constraints_from_list
               (toporouter_t *r,toporouter_layer_t *l,GList *vlist,toporouter_bbox_t *box)

{
  gpointer pvVar1;
  GList *pGVar2;
  GList *pGVar3;
  gpointer pvVar4;
  
  pvVar4 = (gpointer)0x0;
  if (vlist != (GList *)0x0) {
    pGVar3 = vlist->next;
    pvVar4 = vlist->data;
    while (pGVar3 != (GList *)0x0) {
      pvVar1 = pGVar3->data;
      if (pvVar4 != (gpointer)0x0) {
        pGVar2 = insert_constraint_edge
                           (r,l,*(gdouble *)((int)pvVar1 + 0xc),*(gdouble *)((int)pvVar1 + 0x14),
                            *(guint *)((int)pvVar1 + 0x38),*(gdouble *)((int)pvVar4 + 0xc),
                            *(gdouble *)((int)pvVar4 + 0x14),*(guint *)((int)pvVar4 + 0x38),box);
        pGVar2 = (GList *)g_list_concat(box->constraints,pGVar2);
        box->constraints = pGVar2;
      }
      pGVar3 = pGVar3->next;
      pvVar4 = pvVar1;
    }
  }
  pvVar1 = vlist->data;
  pGVar3 = insert_constraint_edge
                     (r,l,*(gdouble *)((int)pvVar1 + 0xc),*(gdouble *)((int)pvVar1 + 0x14),
                      *(guint *)((int)pvVar1 + 0x38),*(gdouble *)((int)pvVar4 + 0xc),
                      *(gdouble *)((int)pvVar4 + 0x14),*(guint *)((int)pvVar4 + 0x38),box);
  pGVar3 = (GList *)g_list_concat(box->constraints,pGVar3);
  box->constraints = pGVar3;
  return;
}



GtsVertex *
insert_vertex(toporouter_t *r,toporouter_layer_t *l,gdouble x,gdouble y,toporouter_bbox_t *box)

{
  GtsVertexClass *klass;
  GtsVertex *pGVar1;
  GList *pGVar2;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = l->vertices;
  while( true ) {
    if (pGVar2 == (GList *)0x0) {
      pGVar1 = gts_vertex_new(klass,x,y,(gdouble)(double)((int)((int)l - (int)r->layers) >> 4));
      *(toporouter_bbox_t **)&pGVar1[1].p.object.klass = box;
      pGVar2 = (GList *)g_list_prepend(l->vertices,pGVar1,x._4_4_);
      l->vertices = pGVar2;
      return pGVar1;
    }
    pGVar1 = (GtsVertex *)pGVar2->data;
    if (((double)(pGVar1->p).x == (double)x) && ((double)(pGVar1->p).y == (double)y)) break;
    pGVar2 = (GList *)(&pGVar2->data)[1];
  }
  *(toporouter_bbox_t **)&pGVar1[1].p.object.klass = box;
  return pGVar1;
}



GtsVertex * vertex_intersect(GtsVertex *a,GtsVertex *b,GtsVertex *c,GtsVertex *d)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  GtsVertexClass *klass;
  int iVar9;
  GtsVertex *pGVar10;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  iVar9 = point_intersect_prop((GtsPoint *)a,(GtsPoint *)b,(GtsPoint *)c,(GtsPoint *)d);
  pGVar10 = (GtsVertex *)0x0;
  if (iVar9 != 0) {
    dVar5 = (double)(c->p).x;
    dVar4 = (double)(d->p).x - dVar5;
    dVar1 = (double)(a->p).y;
    dVar2 = (double)(c->p).y;
    dVar7 = (double)(d->p).y - dVar2;
    dVar3 = (double)(a->p).x;
    dVar8 = (double)(b->p).x - dVar3;
    dVar6 = (double)(b->p).y - dVar1;
    dVar5 = ((dVar1 - dVar2) * dVar4 - (dVar3 - dVar5) * dVar7) / (dVar7 * dVar8 - dVar4 * dVar6);
    pGVar10 = gts_vertex_new(klass,(gdouble)(dVar5 * dVar8 + dVar3),(gdouble)(dVar6 * dVar5 + dVar1)
                             ,0.00000000);
  }
  return pGVar10;
}



void speccut_edge_routing_from_edge(GList *i,toporouter_edge_t *e)

{
  uint *puVar1;
  GtsVertex *a;
  guint32 gVar2;
  gpointer pvVar3;
  GtsVertex *pGVar4;
  GList *pGVar5;
  undefined4 uVar6;
  
  if (i == (GList *)0x0) {
    return;
  }
  do {
    while ((a = (GtsVertex *)i->data, *(char *)((int)&a[1].p.x + 4) < '\0' ||
           (pGVar4 = vertex_intersect(a,(GtsVertex *)a[1].p.object.reserved,(e->e).segment.v1,
                                      (e->e).segment.v2), pGVar4 == (GtsVertex *)0x0))) {
LAB_080e02b8:
      i = (GList *)(&i->data)[1];
      if (i == (GList *)0x0) {
        return;
      }
    }
    puVar1 = (uint *)((int)&pGVar4[1].p.x + 4);
    *puVar1 = *puVar1 | 0x900;
    pGVar5 = (GList *)g_list_insert_sorted_with_data(e->routing,pGVar4,routing_edge_insert,e);
    *(GtsVertex **)&pGVar4[1].p.object.flags = a;
    *(toporouter_edge_t **)&pGVar4[1].p.x = e;
    e->routing = pGVar5;
    gVar2 = a[2].p.object.flags;
    (pGVar4->p).z = (a->p).z;
    pGVar4[2].p.object.flags = gVar2;
    pGVar4[2].p.object.reserved = a[2].p.object.reserved;
    pGVar4[1].p.object.reserved = a[1].p.object.reserved;
    uVar6 = g_list_index(*(undefined4 *)(pGVar4[2].p.object.flags + 0x2c),a);
    gVar2 = pGVar4[2].p.object.flags;
    uVar6 = g_list_insert(*(undefined4 *)(gVar2 + 0x2c),pGVar4,uVar6);
    *(undefined4 *)(gVar2 + 0x2c) = uVar6;
    pvVar3 = pGVar4[2].p.object.reserved;
    if (pvVar3 == (gpointer)0x0) goto LAB_080e02b8;
    *(undefined4 *)((int)pvVar3 + 0x20) = *(undefined4 *)(pGVar4[2].p.object.flags + 0x2c);
    i = (GList *)(&i->data)[1];
    if (i == (GList *)0x0) {
      return;
    }
  } while( true );
}



toporouter_bbox_class_t * toporouter_bbox_class(void)

{
  toporouter_bbox_class_t *class;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (class == (toporouter_bbox_class_t *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &constraint_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name._0_4_ = 0x6f706f74;
    constraint_info.name._4_4_ = 0x74756f72;
    constraint_info.name._8_4_ = 0x625f7265;
    constraint_info.name._12_4_ = 0x5f786f62;
    constraint_info.name._16_4_ = 0x74;
    constraint_info.object_size = 100;
    constraint_info.class_size = 0x5c;
    constraint_info.object_init_func = toporouter_bbox_init;
    parent_class = (GtsObjectClass *)gts_bbox_class();
    class = (toporouter_bbox_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return class;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



toporouter_bbox_t *
toporouter_bbox_create_from_points(int layer,GList *vertices,toporouter_term_t type,gpointer data)

{
  GSList *points;
  GtsBBoxClass *klass;
  toporouter_bbox_t *ptVar1;
  
  points = list_to_slist(vertices);
  klass = (GtsBBoxClass *)toporouter_bbox_class();
  ptVar1 = (toporouter_bbox_t *)gts_bbox_points(klass,points);
  ptVar1->surface = (GtsSurface *)0x0;
  ptVar1->enclosing = 0;
  ptVar1->point = 0;
  *(toporouter_term_t *)&((GtsObject *)&ptVar1->type)->klass = type;
  ptVar1->realpoint = (GtsPoint *)0x0;
  ptVar1->data = data;
  ptVar1->layer = layer;
  g_slist_free(points);
  return ptVar1;
}



// WARNING: Removing unreachable block (ram,0x080e051a)

int read_lines(toporouter_t *r,toporouter_layer_t *l,LayerType *layer,int ln)

{
  double y;
  double y_00;
  double x;
  double x_00;
  int iVar1;
  GtsVertexClass *klass;
  GtsVertex *pGVar2;
  undefined4 uVar3;
  int layer_00;
  toporouter_bbox_t *box;
  GSList *pGVar4;
  GList *vertices;
  int iVar5;
  gpointer data;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  iVar5 = layer->LineN - 1;
  if (iVar5 != -1) {
    iVar1 = layer->LineN * 0x58;
    do {
      data = (gpointer)((int)&layer->Line[-1].BoundingBox.X1 + iVar1);
      x = (double)*(int *)((int)data + 0x2c);
      x_00 = (double)*(int *)((int)data + 0x40);
      y = (double)*(int *)((int)data + 0x30);
      y_00 = (double)*(int *)((int)data + 0x44);
      if ((x != x_00) || (y != y_00)) {
        pGVar2 = gts_vertex_new(klass,(gdouble)x,(gdouble)y,
                                (gdouble)(double)((int)((int)l - (int)r->layers) >> 4));
        uVar3 = g_list_prepend(0,pGVar2);
        pGVar2 = gts_vertex_new(klass,(gdouble)x_00,(gdouble)y_00,
                                (gdouble)(double)((int)((int)l - (int)r->layers) >> 4));
        vertices = (GList *)g_list_prepend(uVar3,pGVar2);
        layer_00 = GetLayerGroupNumberByNumber(ln);
        box = toporouter_bbox_create_from_points(layer_00,vertices,LINE,data);
        pGVar4 = (GSList *)g_slist_prepend(r->bboxes,box);
        r->bboxes = pGVar4;
        g_list_free(vertices);
        vertices = insert_constraint_edge
                             (r,l,(gdouble)x,(gdouble)y,0,(gdouble)x_00,(gdouble)y_00,0,box);
        vertices = (GList *)g_list_concat(box->constraints,vertices);
        box->constraints = vertices;
      }
      iVar5 = iVar5 + -1;
      iVar1 = iVar1 + -0x58;
    } while (iVar5 != -1);
  }
  return 0;
}



toporouter_edge_class_t * toporouter_edge_class(void)

{
  toporouter_edge_class_t *class;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (class == (toporouter_edge_class_t *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &constraint_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name._0_4_ = 0x6f706f74;
    constraint_info.name._4_4_ = 0x74756f72;
    constraint_info.name._8_4_ = 0x655f7265;
    constraint_info.name._12_4_ = 0x5f656764;
    constraint_info.name._16_4_ = 0x74;
    constraint_info.object_size = 0x20;
    constraint_info.class_size = 0x5c;
    constraint_info.object_init_func = toporouter_edge_init;
    parent_class = (GtsObjectClass *)gts_edge_class();
    class = (toporouter_edge_class_t *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return class;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void build_cdt(toporouter_t *r,toporouter_layer_t *l)

{
  GtsEdge *e3;
  GtsEdge *e2;
  GtsEdge *e1;
  GList *pGVar1;
  char "build_cdt" [10];
  GSList *points;
  GtsTriangleClass *klass;
  GtsTriangle *t;
  GtsVertexClass *vertex_class;
  GtsEdgeClass *edge_class;
  GtsFaceClass *face_class;
  GtsSurfaceClass *klass_00;
  GtsSurface *pGVar2;
  GtsFace *f;
  GtsVertex *pGVar3;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  points = list_to_slist(l->vertices);
  klass = gts_triangle_class();
  t = gts_triangle_enclosing(klass,points,1000.00000000);
  gts_triangle_vertices(t,local_20,&local_24,&local_28);
  g_slist_free(points);
  vertex_class = (GtsVertexClass *)toporouter_vertex_class();
  edge_class = (GtsEdgeClass *)toporouter_edge_class();
  face_class = gts_face_class();
  klass_00 = gts_surface_class();
  pGVar2 = gts_surface_new(klass_00,face_class,edge_class,vertex_class);
  e3 = t->e3;
  e2 = t->e2;
  e1 = t->e1;
  l->surface = pGVar2;
  face_class = gts_face_class();
  f = gts_face_new(face_class,e1,e2,e3);
  gts_surface_add_face(l->surface,f);
  pGVar1 = l->vertices;
  while (pGVar1 != (GList *)0x0) {
    pGVar3 = gts_delaunay_add_vertex(l->surface,(GtsVertex *)pGVar1->data,(GtsFace *)0x0);
    if (pGVar3 != (GtsVertex *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x8d8,"build_cdt",
                 "gts_delaunay_add_vertex (l->surface, i->data, NULL) == NULL");
    }
    pGVar1 = (GList *)(&pGVar1->data)[1];
  }
  pGVar1 = l->constraints;
  while( true ) {
    if (pGVar1 == (GList *)0x0) {
      gts_allow_floating_vertices = 1;
      gts_object_destroy((GtsObject *)local_20[0]);
      gts_object_destroy((GtsObject *)local_24);
      gts_object_destroy((GtsObject *)local_28);
      gts_allow_floating_vertices = 0;
      return;
    }
    points = gts_delaunay_add_constraint(l->surface,(GtsConstraint *)pGVar1->data);
    if (points != (GSList *)0x0) break;
    pGVar1 = (GList *)(&pGVar1->data)[1];
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/toporouter.c",0x907,0x8151350,
             "gts_delaunay_add_constraint (l->surface, i->data) == NULL");
}



// WARNING: Type propagation algorithm not settling

void route_restore(toporouter_route_t *route)

{
  gpointer pvVar1;
  char "route_restore" [14];
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  GList *pGVar5;
  gpointer pvVar6;
  int local_20;
  
  pGVar5 = route->ppath;
  if (pGVar5 == (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1aca,"route_restore","route->ppath");
  }
  if (route->ppathindices == (gint *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1acb,0x815117b,"route->ppathindices");
  }
  route->path = pGVar5;
  local_20 = 0;
  pvVar6 = (gpointer)0x0;
  do {
    pvVar1 = pGVar5->data;
    if (*(int *)((int)pvVar1 + 0x34) != 0) {
      pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
      pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
      }
      else {
        if (pGVar4 != (GtsObjectClass *)0x0) {
          pGVar3 = *(GtsObjectClass **)&pGVar4->info;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
          }
          else {
            do {
              if (pGVar2 == pGVar3) break;
              pGVar3 = pGVar3->parent_class;
            } while (pGVar3 != (GtsObjectClass *)0x0);
          }
        }
      }
      pGVar2 = (GtsObjectClass *)
               g_list_insert(((GtsObjectClass **)pGVar4)[7],pvVar1,
                             *(undefined4 *)((int)route->ppathindices + local_20));
      ((GtsObjectClass **)pGVar4)[7] = pGVar2;
    }
    if (pvVar6 != (gpointer)0x0) {
      *(gpointer *)((int)pvVar6 + 0x30) = pvVar1;
      *(gpointer *)((int)pvVar1 + 0x2c) = pvVar6;
    }
    pGVar5 = pGVar5->next;
    local_20 = local_20 + 4;
    pvVar6 = pvVar1;
    if (pGVar5 == (GList *)0x0) {
      route->score = route->pscore;
      route->src = route->psrc;
      route->dest = route->pdest;
      return;
    }
  } while( true );
}



// WARNING: Type propagation algorithm not settling

gint apply_route(GList *path,toporouter_route_t *routedata)

{
  gpointer pvVar1;
  char "apply_route" [12];
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  GList *pGVar5;
  gpointer pvVar6;
  int local_20;
  
  local_20 = 0;
  if (path != (GList *)0x0) {
    pGVar5 = path;
    pvVar6 = (gpointer)0x0;
    do {
      pvVar1 = pGVar5->data;
      if (*(int *)((int)pvVar1 + 0x34) != 0) {
        pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
        pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
        if (pGVar2 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
        }
        else {
          if (pGVar4 != (GtsObjectClass *)0x0) {
            pGVar3 = *(GtsObjectClass **)&pGVar4->info;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
            }
            else {
              do {
                if (pGVar2 == pGVar3) break;
                pGVar3 = pGVar3->parent_class;
              } while (pGVar3 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar2 = (GtsObjectClass *)
                 g_list_insert_sorted_with_data
                           (((GtsObjectClass **)pGVar4)[7],pvVar1,routing_edge_insert,pGVar4);
        local_20 = local_20 + 1;
        ((GtsObjectClass **)pGVar4)[7] = pGVar2;
      }
      if (pvVar6 != (gpointer)0x0) {
        *(gpointer *)((int)pvVar6 + 0x30) = pvVar1;
        *(gpointer *)((int)pvVar1 + 0x2c) = pvVar6;
      }
      if (((*(byte *)((int)pvVar1 + 0x39) & 1) != 0) &&
         (*(toporouter_route_t **)((int)pvVar1 + 0x58) != routedata)) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/toporouter.c",0x1948,"apply_route","tv->route == routedata");
      }
      pGVar5 = pGVar5->next;
      pvVar6 = pvVar1;
    } while (pGVar5 != (GList *)0x0);
    *(undefined4 *)((int)pvVar1 + 0x30) = 0;
    *(undefined4 *)((int)path->data + 0x2c) = 0;
  }
  return local_20;
}



// WARNING: Type propagation algorithm not settling

void remove_route(GList *path)

{
  gpointer pvVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  
  if (path != (GList *)0x0) {
    do {
      pvVar1 = path->data;
      *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
      *(undefined4 *)((int)pvVar1 + 0x30) = 0;
      if (*(int *)((int)pvVar1 + 0x34) != 0) {
        pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
        pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
        if (pGVar2 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
        }
        else {
          if (pGVar4 != (GtsObjectClass *)0x0) {
            pGVar3 = *(GtsObjectClass **)&pGVar4->info;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              pGVar4 = *(GtsObjectClass **)((int)pvVar1 + 0x34);
            }
            else {
              do {
                if (pGVar2 == pGVar3) break;
                pGVar3 = pGVar3->parent_class;
              } while (pGVar3 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar2 = (GtsObjectClass *)g_list_remove(((GtsObjectClass **)pGVar4)[7],pvVar1);
        ((GtsObjectClass **)pGVar4)[7] = pGVar2;
      }
      path = path->next;
    } while (path != (GList *)0x0);
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void route_checkpoint(toporouter_route_t *route,toporouter_route_t *temproute)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  gint *pgVar4;
  GtsObjectClass *pGVar5;
  int iVar6;
  GtsObjectClass *pGVar7;
  GtsObjectClass *pGVar8;
  int local_24;
  int *local_20;
  
  local_20 = (int *)g_list_last(route->path);
  local_24 = g_list_length(route->path);
  if (route->ppathindices != (gint *)0x0) {
    free(route->ppathindices);
  }
  pgVar4 = (gint *)calloc(1,local_24 * 4);
  route->ppathindices = pgVar4;
  if (local_20 != (int *)0x0) {
    local_24 = local_24 * 4;
    do {
      local_24 = local_24 + -4;
      iVar1 = *local_20;
      if (*(int *)(iVar1 + 0x34) != 0) {
        pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
        pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
        }
        else {
          if (pGVar7 != (GtsObjectClass *)0x0) {
            pGVar8 = *(GtsObjectClass **)&pGVar7->info;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
            }
            else {
              do {
                if (pGVar5 == pGVar8) break;
                pGVar8 = pGVar8->parent_class;
              } while (pGVar8 != (GtsObjectClass *)0x0);
            }
          }
        }
        iVar6 = g_list_find(((GtsObjectClass **)pGVar7)[7],iVar1);
        piVar2 = *(int **)(iVar6 + 8);
        pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
        pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
        }
        else {
          if (pGVar7 != (GtsObjectClass *)0x0) {
            pGVar8 = *(GtsObjectClass **)&pGVar7->info;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
            }
            else {
              do {
                if (pGVar5 == pGVar8) break;
                pGVar8 = pGVar8->parent_class;
              } while (pGVar8 != (GtsObjectClass *)0x0);
            }
          }
        }
        iVar6 = g_list_index(((GtsObjectClass **)pGVar7)[7],iVar1);
        while (piVar2 != (int *)0x0) {
          iVar3 = *piVar2;
          piVar2 = (int *)piVar2[2];
          iVar6 = iVar6 - (uint)(*(toporouter_route_t **)(iVar3 + 0x58) == temproute);
        }
        *(int *)((int)route->ppathindices + local_24) = iVar6;
        pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
        pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
        }
        else {
          if (pGVar7 != (GtsObjectClass *)0x0) {
            pGVar8 = *(GtsObjectClass **)&pGVar7->info;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              pGVar7 = *(GtsObjectClass **)(iVar1 + 0x34);
            }
            else {
              do {
                if (pGVar5 == pGVar8) break;
                pGVar8 = pGVar8->parent_class;
              } while (pGVar8 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar5 = (GtsObjectClass *)g_list_remove(((GtsObjectClass **)pGVar7)[7],iVar1);
        ((GtsObjectClass **)pGVar7)[7] = pGVar5;
      }
      local_20 = (int *)local_20[2];
    } while (local_20 != (int *)0x0);
  }
  route->pscore = route->score;
  route->ppath = route->path;
  remove_route(route->path);
  route->path = (GList *)0x0;
  route->psrc = route->src;
  route->pdest = route->dest;
  return;
}



// WARNING: Type propagation algorithm not settling

void delete_route(toporouter_route_t *routedata,guint destroy)

{
  GtsVertex *v1;
  GtsVertex *pGVar1;
  GtsObject *object;
  gpointer pvVar2;
  GtsVertex *v2;
  char "delete_route" [13];
  GtsObjectClass *pGVar3;
  GtsSegment *pGVar4;
  GtsObjectClass *pGVar5;
  GList *pGVar6;
  GtsObjectClass *pGVar7;
  
  pGVar6 = routedata->path;
  if (pGVar6 != (GList *)0x0) {
    if ((GtsVertex *)pGVar6->data == (GtsVertex *)0x0) {
LAB_080e1010:
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x18e5,"delete_route",&DAT_081516de);
    }
    pGVar1 = (GtsVertex *)(&pGVar6->data)[1];
    v2 = (GtsVertex *)pGVar6->data;
    while (pGVar1 != (GtsVertex *)0x0) {
      v1 = *(GtsVertex **)&pGVar1->p;
      if (v1 == (GtsVertex *)0x0) goto LAB_080e1010;
      if (((((*(byte *)((int)&v1[1].p.x + 5) & 1) == 0) &&
           ((*(byte *)((int)&v2[1].p.x + 5) & 1) == 0)) &&
          (pGVar4 = gts_vertices_are_connected(v1,v2), pGVar4 != (GtsSegment *)0x0)) &&
         (pvVar2 = pGVar4[1].object.reserved, ((uint)pvVar2 & 1) != 0)) {
        pGVar4[1].object.reserved = (gpointer)((uint)pvVar2 ^ 1);
      }
      pGVar1 = *(GtsVertex **)((int)&pGVar1->p + 4);
      v2 = v1;
    }
    pGVar6 = routedata->path;
    if (pGVar6 != (GList *)0x0) {
      do {
        object = (GtsObject *)pGVar6->data;
        pvVar2 = object[4].reserved;
        object[3].flags = 0;
        object[4].klass = (GtsObjectClass *)0x0;
        if (pvVar2 != (gpointer)0x0) {
          pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
          pGVar7 = (GtsObjectClass *)object[4].reserved;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            pGVar7 = (GtsObjectClass *)object[4].reserved;
          }
          else {
            if (pGVar7 != (GtsObjectClass *)0x0) {
              pGVar5 = *(GtsObjectClass **)&pGVar7->info;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                pGVar7 = (GtsObjectClass *)object[4].reserved;
              }
              else {
                do {
                  if (pGVar3 == pGVar5) break;
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
          }
          pGVar3 = (GtsObjectClass *)g_list_remove(((GtsObjectClass **)pGVar7)[7],object);
          ((GtsObjectClass **)pGVar7)[7] = pGVar3;
          if (destroy != 0) {
            gts_object_destroy(object);
          }
        }
        pGVar6 = pGVar6->next;
      } while (pGVar6 != (GList *)0x0);
      if (routedata->path != (GList *)0x0) {
        g_list_free(routedata->path);
      }
    }
  }
  routedata->path = (GList *)0x0;
  routedata->curpoint = (toporouter_vertex_t *)0x0;
  routedata->score = INFINITY;
  routedata->alltemppoints = (GHashTable *)0x0;
  return;
}



// WARNING: Type propagation algorithm not settling

float10 pathvertex_arcing_through_constraint(int pathv,int arcv)

{
  byte bVar1;
  int iVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  int iVar5;
  unkbyte10 Var6;
  
  iVar5 = *(int *)(pathv + 0x30);
  if ((iVar5 != 0) && (iVar2 = *(int *)(iVar5 + 0x34), iVar2 != 0)) {
    if ((*(byte *)(iVar5 + 0x39) & 1) != 0) {
      while ((*(int *)(iVar2 + 0xc) == arcv || (*(int *)(iVar2 + 0x10) == arcv))) {
        pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (*(GtsObjectClass **)(iVar5 + 0x34) != (GtsObjectClass *)0x0) {
            pGVar4 = *(GtsObjectClass **)&(*(GtsObjectClass **)(iVar5 + 0x34))->info;
            if (pGVar4 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            }
            else {
              do {
                if (pGVar3 == pGVar4) goto LAB_080e10fb;
                pGVar4 = pGVar4->parent_class;
              } while (pGVar4 != (GtsObjectClass *)0x0);
            }
          }
        }
        iVar5 = *(int *)(iVar5 + 0x30);
        if ((*(byte *)(iVar5 + 0x39) & 1) == 0) break;
        iVar2 = *(int *)(iVar5 + 0x34);
      }
    }
    iVar5 = *(int *)(pathv + 0x2c);
    bVar1 = *(byte *)(iVar5 + 0x39);
    while (((bVar1 & 1) != 0 &&
           ((*(int *)(*(int *)(iVar5 + 0x34) + 0xc) == arcv ||
            (*(int *)(*(int *)(iVar5 + 0x34) + 0x10) == arcv))))) {
      pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (*(GtsObjectClass **)(iVar5 + 0x34) != (GtsObjectClass *)0x0) {
          pGVar4 = *(GtsObjectClass **)&(*(GtsObjectClass **)(iVar5 + 0x34))->info;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar3 == pGVar4) {
LAB_080e10fb:
                Var6 = gts_point_distance();
                return (float10)Var6;
              }
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
      }
      iVar5 = *(int *)(iVar5 + 0x2c);
      bVar1 = *(byte *)(iVar5 + 0x39);
    }
  }
  return (float10)0;
}



void split_edge_routing(toporouter_vertex_t *v,GList **l1,GList **l2)

{
  char "split_edge_routing" [19];
  GtsObjectClass *pGVar1;
  int iVar2;
  GList *pGVar3;
  toporouter_edge_t *ptVar4;
  GtsObjectClass *pGVar5;
  int *piVar6;
  
  if (v == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x10e5,"split_edge_routing",&DAT_081601a8);
  }
  if (v->routingedge == (toporouter_edge_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x10e6,0x81512a4,0x815185e);
  }
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar4 = v->routingedge;
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    ptVar4 = v->routingedge;
  }
  else {
    if (ptVar4 != (toporouter_edge_t *)0x0) {
      pGVar5 = (ptVar4->e).segment.object.klass;
      if (pGVar5 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        ptVar4 = v->routingedge;
      }
      else {
        do {
          if (pGVar1 == pGVar5) break;
          pGVar5 = pGVar5->parent_class;
        } while (pGVar5 != (GtsObjectClass *)0x0);
      }
    }
  }
  iVar2 = g_list_find(ptVar4->routing,v);
  pGVar3 = (GList *)g_list_prepend(*l1,(v->routingedge->e).segment.v1);
  *l1 = pGVar3;
  pGVar3 = (GList *)g_list_prepend(*l2,(v->routingedge->e).segment.v2);
  *l2 = pGVar3;
  if (iVar2 == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x10ed,0x81512a4,0x815cf1a);
  }
  piVar6 = *(int **)(iVar2 + 4);
  while (piVar6 != (int *)0x0) {
    while (*(char *)(*piVar6 + 0x38) < '\0') {
      piVar6 = (int *)piVar6[1];
      if (piVar6 == (int *)0x0) goto LAB_080e12e9;
    }
    pGVar3 = (GList *)g_list_prepend(*l2,*piVar6);
    *l2 = pGVar3;
    piVar6 = (int *)piVar6[1];
  }
LAB_080e12e9:
  piVar6 = *(int **)(iVar2 + 8);
  do {
    if (piVar6 == (int *)0x0) {
      return;
    }
    while (*(char *)(*piVar6 + 0x38) < '\0') {
      piVar6 = (int *)piVar6[2];
      if (piVar6 == (int *)0x0) {
        return;
      }
    }
    pGVar3 = (GList *)g_list_prepend(*l1,*piVar6);
    *l1 = pGVar3;
    piVar6 = (int *)piVar6[2];
  } while( true );
}



GList * edge_routing_first_not_temp(toporouter_edge_t *e)

{
  GtsObjectClass *pGVar1;
  GList *pGVar2;
  GtsObjectClass *pGVar3;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar3 = (e->e).segment.object.klass;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar1 == pGVar3) break;
          pGVar3 = pGVar3->parent_class;
        } while (pGVar3 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar2 = e->routing;
  while ((pGVar2 != (GList *)0x0 && (*(char *)((int)pGVar2->data + 0x38) < '\0'))) {
    pGVar2 = pGVar2->next;
  }
  return pGVar2;
}



toporouter_vertex_t * edge_routing_prev_not_temp(toporouter_edge_t *e,GList *list)

{
  GtsObjectClass *pGVar1;
  GtsObjectClass *pGVar2;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar2 = (e->e).segment.object.klass;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar1 == pGVar2) goto LAB_080e14d6;
          pGVar2 = pGVar2->parent_class;
        } while (pGVar2 != (GtsObjectClass *)0x0);
      }
    }
  }
  while (list != (GList *)0x0) {
    if (-1 < *(char *)&((toporouter_vertex_t *)list->data)->flags) {
      return (toporouter_vertex_t *)list->data;
    }
    list = (GList *)(&list->data)[2];
  }
LAB_080e14d6:
  return (toporouter_vertex_t *)(e->e).segment.v1;
}



toporouter_vertex_t * edge_routing_next_not_temp(toporouter_edge_t *e,GList *list)

{
  GtsObjectClass *pGVar1;
  GtsObjectClass *pGVar2;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar2 = (e->e).segment.object.klass;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar1 == pGVar2) goto LAB_080e1576;
          pGVar2 = pGVar2->parent_class;
        } while (pGVar2 != (GtsObjectClass *)0x0);
      }
    }
  }
  while (list != (GList *)0x0) {
    if (-1 < *(char *)&((toporouter_vertex_t *)list->data)->flags) {
      return (toporouter_vertex_t *)list->data;
    }
    list = (GList *)(&list->data)[1];
  }
LAB_080e1576:
  return (toporouter_vertex_t *)(e->e).segment.v2;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

float10 flow_from_edge_to_edge
                  (GtsTriangle *t,GtsObjectClass **e1,int e2,GtsVertex *common_v,GtsVertex *curpoint
                  )

{
  gpointer pvVar1;
  guint32 gVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  guint gVar5;
  GtsVertex *pGVar6;
  char "flow_from_edge_to_edge" [23];
  GtsEdge *pGVar7;
  GtsObjectClass *pGVar8;
  int iVar9;
  GtsObjectClass *pGVar10;
  GtsObjectClass *pGVar11;
  float10 fVar12;
  float10 fVar13;
  float10 fVar14;
  float10 fVar15;
  float10 fVar16;
  double local_2c;
  double local_24;
  
  pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar8 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e1 != (GtsObjectClass **)0x0) {
      pGVar10 = *e1;
      if (pGVar10 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar8 == pGVar10) break;
          pGVar10 = pGVar10->parent_class;
        } while (pGVar10 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar8 = e1[7];
  if (pGVar8 == (GtsObjectClass *)0x0) {
    local_2c = 0.00000000;
    local_24._0_4_ = common_v;
  }
  else {
    local_2c = 0.00000000;
    pGVar6 = common_v;
    do {
      local_24._0_4_ = *(GtsVertex **)(pGVar8->info).name;
      if (local_24._0_4_ == curpoint) {
        fVar16 = (float10)vertex_net_thickness(curpoint);
        fVar12 = (float10)vertex_net_thickness(pGVar6);
        fVar13 = (float10)vertex_net_keepaway(curpoint);
        fVar14 = (float10)vertex_net_keepaway(pGVar6);
        pGVar8 = *(GtsObjectClass **)((pGVar8->info).name + 4);
        fVar15 = (float10)(double)fVar13;
        if ((float10)(double)fVar13 <= fVar14) {
          fVar15 = fVar14;
        }
        local_2c = (double)((float10)0.50000000 * (float10)(double)fVar12 +
                            (float10)(double)fVar16 * (float10)0.50000000 + fVar15 +
                           (float10)local_2c);
        local_24._0_4_ = curpoint;
      }
      else {
        if (((*(byte *)((int)&local_24._0_4_[1].p.x + 5) & 1) == 0) ||
           (((pvVar1 = local_24._0_4_[1].p.object.reserved, pvVar1 == (gpointer)0x0 ||
             (*(int *)((int)pvVar1 + 0x34) != e2)) &&
            ((gVar2 = local_24._0_4_[1].p.object.flags, gVar2 == 0 || (*(int *)(gVar2 + 0x34) != e2)
             ))))) {
          pGVar8 = *(GtsObjectClass **)((pGVar8->info).name + 4);
          local_24._0_4_ = pGVar6;
        }
        else {
          fVar16 = (float10)vertex_net_thickness(local_24._0_4_);
          fVar12 = (float10)vertex_net_thickness(pGVar6);
          fVar13 = (float10)vertex_net_keepaway(local_24._0_4_);
          fVar14 = (float10)vertex_net_keepaway(pGVar6);
          pGVar8 = *(GtsObjectClass **)((pGVar8->info).name + 4);
          fVar15 = (float10)(double)fVar13;
          if ((float10)(double)fVar13 <= fVar14) {
            fVar15 = fVar14;
          }
          local_2c = (double)((float10)0.50000000 * (float10)(double)fVar12 +
                              (float10)(double)fVar16 * (float10)0.50000000 + fVar15 +
                             (float10)local_2c);
        }
      }
      pGVar6 = local_24._0_4_;
    } while (pGVar8 != (GtsObjectClass *)0x0);
  }
  pGVar7 = gts_triangle_edge_opposite(t,common_v);
  if (pGVar7 == (GtsEdge *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xc97,0x81512f7,"op_edge");
  }
  if (e1 == (GtsObjectClass **)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xc98,0x81512f7,&DAT_081516e9);
  }
  if (e2 == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xc99,0x81512f7,&DAT_0814f5e2);
  }
  pGVar8 = (GtsObjectClass *)(pGVar7->segment).v1;
  pGVar10 = *(GtsObjectClass **)(e2 + 0xc);
  pGVar11 = pGVar8;
  if (((((pGVar10 != pGVar8) && (pGVar3 = *(GtsObjectClass **)(e2 + 0x10), pGVar8 != pGVar3)) &&
       (pGVar4 = (GtsObjectClass *)(pGVar7->segment).v2, pGVar11 = pGVar10, pGVar10 != pGVar4)) &&
      (pGVar11 = pGVar3, pGVar3 != pGVar4)) || (pGVar11 == (GtsObjectClass *)0x0)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xc9c,"flow_from_edge_to_edge",&DAT_081601a8);
  }
  if ((((*(byte *)((int)&(pGVar11->info).arg_set_func + 1) & 1) != 0) &&
      (gVar5 = (pGVar11->info).class_size, gVar5 != 0)) &&
     ((pGVar10 = *(GtsObjectClass **)(gVar5 + 0x34), pGVar10 != (GtsObjectClass *)0x0 &&
      ((GtsObjectClass *)e1 == pGVar10)))) {
    fVar16 = (float10)vertex_net_thickness(pGVar11);
    fVar12 = (float10)vertex_net_thickness(local_24._0_4_);
    fVar13 = (float10)vertex_net_keepaway(pGVar11);
    fVar14 = (float10)vertex_net_keepaway(local_24._0_4_);
    pGVar8 = (GtsObjectClass *)(pGVar7->segment).v1;
    fVar15 = (float10)(double)fVar13;
    if ((float10)(double)fVar13 <= fVar14) {
      fVar15 = fVar14;
    }
    local_2c = (double)((float10)0.50000000 * (float10)(double)fVar12 +
                        (float10)(double)fVar16 * (float10)0.50000000 + fVar15 + (float10)local_2c);
  }
  pGVar10 = e1[3];
  if ((((pGVar10 != pGVar8) && (pGVar11 = e1[4], pGVar8 != pGVar11)) &&
      ((pGVar3 = (GtsObjectClass *)(pGVar7->segment).v2, pGVar8 = pGVar10, pGVar10 != pGVar3 &&
       (pGVar8 = pGVar11, pGVar11 != pGVar3)))) || (pGVar8 == (GtsObjectClass *)0x0)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xca5,0x81512f7,&DAT_081601a8);
  }
  if (((((*(byte *)((int)&(pGVar8->info).arg_set_func + 1) & 1) != 0) &&
       (gVar5 = (pGVar8->info).class_size, gVar5 != 0)) &&
      (pGVar10 = *(GtsObjectClass **)(gVar5 + 0x34), pGVar10 != (GtsObjectClass *)0x0)) &&
     ((GtsObjectClass *)e1 == pGVar10)) {
    fVar16 = (float10)vertex_net_thickness(pGVar8);
    fVar12 = (float10)vertex_net_thickness(local_24._0_4_);
    fVar13 = (float10)vertex_net_keepaway(pGVar8);
    fVar14 = (float10)vertex_net_keepaway(local_24._0_4_);
    fVar15 = (float10)(double)fVar13;
    if ((float10)(double)fVar13 <= fVar14) {
      fVar15 = fVar14;
    }
    local_2c = (double)((float10)0.50000000 * (float10)(double)fVar12 +
                        (float10)(double)fVar16 * (float10)0.50000000 + fVar15 + (float10)local_2c);
  }
  pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar10 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return (float10)local_2c;
  }
  pGVar11 = (pGVar7->segment).object.klass;
  if (pGVar11 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    return (float10)local_2c;
  }
  do {
    if (pGVar10 == pGVar11) {
      pGVar6 = (pGVar7->segment).v1;
      if (pGVar6 == (GtsVertex *)0x0) {
        fVar15 = (float10)vertex_net_thickness(pGVar8);
        local_24 = (double)(fVar15 * (float10)0.50000000 + (float10)local_2c);
LAB_080e1a79:
        fVar15 = (float10)vertex_net_keepaway(pGVar8);
        return (float10)(double)(fVar15 + (float10)local_24);
      }
      pGVar10 = pGVar6[1].p.object.klass;
      fVar15 = (float10)vertex_net_thickness(pGVar8);
      local_24 = (double)(fVar15 * (float10)0.50000000 + (float10)local_2c);
      if (pGVar10 == (GtsObjectClass *)0x0) goto LAB_080e1a79;
      fVar15 = (float10)vertex_net_keepaway(pGVar8);
      iVar9 = *(int *)(pGVar10[1].info.name + 4);
      if (iVar9 == 0) {
        fVar16 = (float10)lookup_keepaway(0);
      }
      else {
        fVar16 = (float10)lookup_keepaway(*(undefined4 *)(*(int *)(iVar9 + 0xc) + 0xc));
      }
      if (fVar16 < (float10)(double)fVar15) {
        fVar15 = (float10)vertex_net_keepaway(pGVar8);
        iVar9 = *(int *)(pGVar10[1].info.name + 4);
        if (iVar9 != 0) goto LAB_080e1911;
LAB_080e194f:
        fVar16 = (float10)lookup_thickness(0);
      }
      else {
        iVar9 = *(int *)(pGVar10[1].info.name + 4);
        if (iVar9 == 0) {
          fVar15 = (float10)lookup_keepaway(0);
        }
        else {
          fVar15 = (float10)lookup_keepaway(*(undefined4 *)(*(int *)(iVar9 + 0xc) + 0xc));
        }
        iVar9 = *(int *)(pGVar10[1].info.name + 4);
        if (iVar9 == 0) goto LAB_080e194f;
LAB_080e1911:
        fVar16 = (float10)lookup_thickness(*(undefined4 *)(*(int *)(iVar9 + 0xc) + 0xc));
      }
      local_2c = (double)(fVar16 * (float10)0.50000000 + (float10)(double)fVar15 + (float10)local_24
                         );
      break;
    }
    pGVar11 = pGVar11->parent_class;
  } while (pGVar11 != (GtsObjectClass *)0x0);
  return (float10)local_2c;
}



float10 edge_flow(GtsObjectClass **e,GtsObjectClass *v1,GtsObjectClass *v2,GtsObjectClass *dest)

{
  bool bVar1;
  char "edge_flow" [10];
  guint gVar2;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  GtsObjectClass *pGVar5;
  float10 fVar6;
  float10 fVar7;
  float10 fVar8;
  float10 fVar9;
  float10 fVar10;
  double local_4c;
  double local_44;
  double local_34;
  double local_2c;
  double local_24;
  
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (GtsObjectClass **)0x0) {
      pGVar3 = *e;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar4 == pGVar3) {
            pGVar4 = e[7];
            goto LAB_080e1bfd;
          }
          pGVar3 = pGVar3->parent_class;
        } while (pGVar3 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar4 = e[7];
LAB_080e1bfd:
  pGVar3 = e[3];
  if ((pGVar3 == v2) || (pGVar3 == v1)) {
    fVar7 = (float10)vertex_net_thickness(pGVar3);
    gVar2 = 0;
    if (dest != (GtsObjectClass *)0x0) {
      gVar2 = (dest->info).object_size;
    }
    if (*(int *)(gVar2 + 0x60) == 0) {
      fVar8 = (float10)lookup_thickness(0);
    }
    else {
      fVar8 = (float10)lookup_thickness(*(undefined4 *)
                                         (*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc));
    }
    local_34 = (double)fVar8;
    fVar8 = (float10)vertex_net_keepaway(pGVar3);
    gVar2 = 0;
    if (dest != (GtsObjectClass *)0x0) {
      gVar2 = (dest->info).object_size;
    }
    if (*(int *)(gVar2 + 0x60) == 0) {
      fVar10 = (float10)lookup_keepaway(0);
    }
    else {
      fVar10 = (float10)lookup_keepaway(*(undefined4 *)
                                         (*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc));
    }
    fVar9 = (float10)(double)fVar8;
    if ((float10)(double)fVar8 <= fVar10) {
      fVar9 = fVar10;
    }
    bVar1 = false;
    local_24 = (double)((float10)0.50000000 * (float10)local_34 +
                        (float10)(double)fVar7 * (float10)0.50000000 + fVar9 + (float10)0.00000000);
    pGVar3 = dest;
  }
  else {
    bVar1 = true;
    local_24 = 0.00000000;
  }
  if (v1 == v2) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xaf6,"edge_flow",&DAT_081516ec);
  }
  while (pGVar4 != (GtsObjectClass *)0x0) {
    pGVar5 = *(GtsObjectClass **)(pGVar4->info).name;
    if (pGVar3 == dest) {
      fVar7 = (float10)vertex_net_thickness(pGVar5);
      gVar2 = 0;
      if (pGVar3 != (GtsObjectClass *)0x0) {
        gVar2 = (pGVar3->info).object_size;
      }
      if (*(int *)(gVar2 + 0x60) == 0) {
        fVar8 = (float10)lookup_thickness(0);
      }
      else {
        fVar8 = (float10)lookup_thickness(*(undefined4 *)
                                           (*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc));
      }
      local_4c = (double)fVar8;
      fVar8 = (float10)vertex_net_keepaway(pGVar5);
      gVar2 = 0;
      if (pGVar3 != (GtsObjectClass *)0x0) {
        gVar2 = (dest->info).object_size;
      }
      if (*(int *)(gVar2 + 0x60) == 0) {
        fVar10 = (float10)lookup_keepaway(0);
      }
      else {
        fVar10 = (float10)lookup_keepaway(*(undefined4 *)
                                           (*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc));
      }
      fVar9 = (float10)(double)fVar8;
      if ((float10)(double)fVar8 <= fVar10) {
        fVar9 = fVar10;
      }
      fVar7 = (float10)0.50000000 * (float10)local_4c + (float10)(double)fVar7 * (float10)0.50000000
              + fVar9 + (float10)local_24;
    }
    else {
      fVar8 = (float10)vertex_net_thickness(pGVar5);
      fVar10 = (float10)vertex_net_thickness(pGVar3);
      fVar9 = (float10)vertex_net_keepaway(pGVar5);
      fVar6 = (float10)vertex_net_keepaway(pGVar3);
      fVar7 = (float10)(double)fVar9;
      if ((float10)(double)fVar9 <= fVar6) {
        fVar7 = fVar6;
      }
      fVar7 = (float10)0.50000000 * (float10)(double)fVar10 +
              (float10)(double)fVar8 * (float10)0.50000000 + fVar7 + (float10)local_24;
    }
    local_24 = (double)fVar7;
    if (((pGVar5 == v2) || (pGVar5 == v1)) && (bVar1)) {
      fVar7 = (float10)vertex_net_thickness(pGVar5);
      gVar2 = 0;
      if (dest != (GtsObjectClass *)0x0) {
        gVar2 = (dest->info).object_size;
      }
      if (*(int *)(gVar2 + 0x60) == 0) {
        fVar8 = (float10)lookup_thickness(0);
      }
      else {
        fVar8 = (float10)lookup_thickness(*(undefined4 *)
                                           (*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc));
      }
      local_44 = (double)fVar8;
      fVar8 = (float10)vertex_net_keepaway(pGVar5);
      gVar2 = 0;
      if (dest != (GtsObjectClass *)0x0) {
        gVar2 = (dest->info).object_size;
      }
      if (*(int *)(gVar2 + 0x60) == 0) {
        fVar10 = (float10)lookup_keepaway(0);
      }
      else {
        fVar10 = (float10)lookup_keepaway(*(undefined4 *)
                                           (*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc));
      }
      fVar9 = (float10)(double)fVar8;
      if ((float10)(double)fVar8 <= fVar10) {
        fVar9 = fVar10;
      }
      bVar1 = false;
      local_24 = (double)((float10)0.50000000 * (float10)local_44 +
                          (float10)(double)fVar7 * (float10)0.50000000 + fVar9 + (float10)local_24);
      pGVar5 = dest;
    }
    pGVar4 = *(GtsObjectClass **)((pGVar4->info).name + 4);
    pGVar3 = pGVar5;
  }
  if (pGVar3 != dest) {
    pGVar4 = e[4];
    fVar8 = (float10)vertex_net_thickness(pGVar4);
    fVar10 = (float10)vertex_net_thickness(pGVar3);
    fVar9 = (float10)vertex_net_keepaway(pGVar4);
    fVar6 = (float10)vertex_net_keepaway(pGVar3);
    fVar7 = (float10)(double)fVar9;
    if ((float10)(double)fVar9 <= fVar6) {
      fVar7 = fVar6;
    }
    return (float10)0.50000000 * (float10)(double)fVar10 +
           (float10)(double)fVar8 * (float10)0.50000000 + fVar7 + (float10)local_24;
  }
  pGVar4 = e[4];
  fVar7 = (float10)vertex_net_thickness(pGVar4);
  gVar2 = 0;
  if (pGVar3 != (GtsObjectClass *)0x0) {
    gVar2 = (pGVar3->info).object_size;
  }
  if (*(int *)(gVar2 + 0x60) == 0) {
    fVar8 = (float10)lookup_thickness(0);
  }
  else {
    fVar8 = (float10)lookup_thickness(*(undefined4 *)(*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc))
    ;
  }
  local_2c = (double)fVar8;
  fVar8 = (float10)vertex_net_keepaway(pGVar4);
  gVar2 = 0;
  if (pGVar3 != (GtsObjectClass *)0x0) {
    gVar2 = (dest->info).object_size;
  }
  if (*(int *)(gVar2 + 0x60) == 0) {
    fVar10 = (float10)lookup_keepaway(0);
  }
  else {
    fVar10 = (float10)lookup_keepaway(*(undefined4 *)(*(int *)(*(int *)(gVar2 + 0x60) + 0xc) + 0xc))
    ;
  }
  fVar9 = (float10)(double)fVar8;
  if ((float10)(double)fVar8 <= fVar10) {
    fVar9 = fVar10;
  }
  return (float10)0.50000000 * (float10)local_2c + (float10)(double)fVar7 * (float10)0.50000000 +
         fVar9 + (float10)local_24;
}



guint check_arc_for_loops(gpointer t1,toporouter_arc_t *arc,gpointer t2)

{
  toporouter_vertex_class_t *ptVar1;
  gint gVar2;
  toporouter_vertex_class_t *ptVar3;
  gdouble local_2c;
  gdouble local_24;
  
  ptVar1 = toporouter_vertex_class();
  if (ptVar1 == (toporouter_vertex_class_t *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (t1 != (gpointer)0x0) {
      ptVar3 = *(toporouter_vertex_class_t **)t1;
      if (ptVar3 == (toporouter_vertex_class_t *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (ptVar1 == ptVar3) {
            local_2c = *(gdouble *)((int)t1 + 0xc);
            local_24 = *(gdouble *)((int)t1 + 0x14);
            goto LAB_080e2116;
          }
          ptVar3 = (toporouter_vertex_class_t *)
                   (ptVar3->parent_class).parent_class.parent_class.parent_class;
        } while (ptVar3 != (toporouter_vertex_class_t *)0x0);
      }
    }
  }
  local_2c = *(gdouble *)((int)t1 + 0x1c);
  local_24 = *(gdouble *)((int)t1 + 0x24);
LAB_080e2116:
  ptVar1 = toporouter_vertex_class();
  if (ptVar1 == (toporouter_vertex_class_t *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (t2 != (gpointer)0x0) {
      ptVar3 = *(toporouter_vertex_class_t **)t2;
      if (ptVar3 == (toporouter_vertex_class_t *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (ptVar1 == ptVar3) break;
          ptVar3 = (toporouter_vertex_class_t *)
                   (ptVar3->parent_class).parent_class.parent_class.parent_class;
        } while (ptVar3 != (toporouter_vertex_class_t *)0x0);
      }
    }
  }
  gVar2 = coord_intersect_prop
                    (local_2c,local_24,arc->x0,arc->y0,arc->x1,arc->y1,*(gdouble *)((int)t2 + 0xc),
                     *(gdouble *)((int)t2 + 0x14));
  return (uint)(gVar2 != 0);
}



GList * edge_routing_last_not_temp(toporouter_edge_t *e)

{
  GList *pGVar1;
  GtsObjectClass *pGVar2;
  GList *pGVar3;
  GtsObjectClass *pGVar4;
  
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar4 = (e->e).segment.object.klass;
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar2 == pGVar4) break;
          pGVar4 = pGVar4->parent_class;
        } while (pGVar4 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar1 = e->routing;
  pGVar3 = (GList *)0x0;
  while (pGVar1 != (GList *)0x0) {
    if (-1 < *(char *)((int)pGVar1->data + 0x38)) {
      pGVar3 = pGVar1;
    }
    pGVar1 = pGVar1->next;
  }
  return pGVar3;
}



// WARNING: Type propagation algorithm not settling

float10 edge_min_spacing(GtsObjectClass *list,GtsObjectClass **e,undefined4 v)

{
  int *piVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  float10 fVar7;
  float10 fVar8;
  GtsObjectClass *local_78;
  GtsObjectClass *local_60;
  double local_24;
  
  if (list == (GtsObjectClass *)0x0) {
    return (float10)INFINITY;
  }
  local_60 = *(GtsObjectClass **)&list->info;
  fVar7 = (float10)gts_point_distance2(local_60,e[3]);
  local_78 = e[3];
  fVar8 = (float10)gts_point_distance2(v,local_78);
  if (fVar8 <= (float10)(double)fVar7) {
    local_24 = 0.00000000;
    do {
      pGVar2 = *(GtsObjectClass **)((int)&list->info + 8);
      if (pGVar2 == (GtsObjectClass *)0x0) {
        pGVar3 = e[3];
      }
      else {
        pGVar3 = *(GtsObjectClass **)&pGVar2->info;
      }
      piVar1 = (int *)pGVar3->attributes;
      if ((((piVar1 == (int *)0x0) || (*piVar1 != *(int *)local_60->attributes)) ||
          (*(int *)piVar1[1] != **(int **)(local_60->attributes + 1))) &&
         (-1 < *(char *)&(pGVar3->info).arg_set_func)) {
        fVar8 = (float10)vertex_net_thickness(local_60,local_78);
        fVar5 = (float10)vertex_net_thickness(pGVar3);
        fVar4 = (float10)vertex_net_keepaway(local_60);
        fVar6 = (float10)vertex_net_keepaway(pGVar3);
        fVar7 = (float10)(double)fVar4;
        if ((float10)(double)fVar4 <= fVar6) {
          fVar7 = fVar6;
        }
        fVar4 = (float10)0.50000000;
        fVar7 = (float10)(double)fVar5 * fVar4 + (float10)(double)fVar8 * fVar4 + fVar7;
        local_60 = pGVar3;
        if (pGVar3 == e[3]) {
          local_78 = pGVar3;
          fVar8 = (float10)pathvertex_arcing_through_constraint(*(undefined4 *)&list->info);
          fVar7 = (float10)(double)fVar7;
          if ((float10)0.00010000 < fVar8) {
            fVar8 = (float10)(double)fVar4 * fVar8;
            pGVar2 = *(GtsObjectClass **)((int)&list->info + 8);
            if (fVar7 <= fVar8 || fVar8 != fVar7) {
              fVar8 = fVar7;
            }
            local_24 = (double)(fVar8 + (float10)local_24);
            goto LAB_080e2448;
          }
        }
        pGVar2 = *(GtsObjectClass **)((int)&list->info + 8);
        local_24 = (double)(fVar7 + (float10)local_24);
      }
LAB_080e2448:
      list = pGVar2;
    } while (pGVar2 != (GtsObjectClass *)0x0);
  }
  else {
    local_24 = 0.00000000;
    do {
      while( true ) {
        pGVar2 = *(GtsObjectClass **)((int)&list->info + 4);
        if (pGVar2 == (GtsObjectClass *)0x0) {
          pGVar3 = e[4];
        }
        else {
          pGVar3 = *(GtsObjectClass **)&pGVar2->info;
        }
        piVar1 = (int *)pGVar3->attributes;
        if ((((piVar1 == (int *)0x0) || (*piVar1 != *(int *)local_60->attributes)) ||
            (*(int *)piVar1[1] != **(int **)(local_60->attributes + 1))) &&
           (-1 < *(char *)&(pGVar3->info).arg_set_func)) break;
LAB_080e2320:
        list = pGVar2;
        if (pGVar2 == (GtsObjectClass *)0x0) goto LAB_080e23d0;
      }
      fVar8 = (float10)vertex_net_thickness(local_60,local_78);
      fVar5 = (float10)vertex_net_thickness(pGVar3);
      fVar4 = (float10)vertex_net_keepaway(local_60);
      fVar6 = (float10)vertex_net_keepaway(pGVar3);
      fVar7 = (float10)(double)fVar4;
      if ((float10)(double)fVar4 <= fVar6) {
        fVar7 = fVar6;
      }
      fVar4 = (float10)0.50000000;
      fVar7 = (float10)(double)fVar5 * fVar4 + (float10)(double)fVar8 * fVar4 + fVar7;
      local_60 = pGVar3;
      if (pGVar3 == e[4]) {
        local_78 = pGVar3;
        fVar8 = (float10)pathvertex_arcing_through_constraint(*(undefined4 *)&list->info);
        fVar7 = (float10)(double)fVar7;
        if ((float10)0.00010000 < fVar8) {
          fVar8 = (float10)(double)fVar4 * fVar8;
          pGVar2 = *(GtsObjectClass **)((int)&list->info + 4);
          if (fVar7 <= fVar8 || fVar8 != fVar7) {
            fVar8 = fVar7;
          }
          local_24 = (double)(fVar8 + (float10)local_24);
          goto LAB_080e2320;
        }
      }
      list = *(GtsObjectClass **)((int)&list->info + 4);
      local_24 = (double)(fVar7 + (float10)local_24);
    } while (list != (GtsObjectClass *)0x0);
  }
LAB_080e23d0:
  local_78 = (GtsObjectClass *)toporouter_constraint_class();
  if (local_78 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return (float10)local_24;
  }
  pGVar2 = *e;
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    return (float10)local_24;
  }
  do {
    if (local_78 == pGVar2) {
      fVar7 = (float10)gts_point_distance(e[3],e[4]);
      if (fVar7 * (float10)0.50000000 < (float10)local_24) {
        fVar7 = (float10)gts_point_distance(e[3],e[4]);
        return (float10)(double)((float10)(double)(float10)0.50000000 * fVar7);
      }
      break;
    }
    pGVar2 = pGVar2->parent_class;
  } while (pGVar2 != (GtsObjectClass *)0x0);
  return (float10)local_24;
}



void print_vertex(toporouter_vertex_t *v)

{
  gdouble gVar1;
  _toporouter_cluster_t *p_Var2;
  _toporouter_netlist_t *p_Var3;
  ulonglong uVar4;
  GtsObjectClass *pGVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  uint uVar8;
  char *pcVar9;
  toporouter_edge_t *ptVar10;
  GtsObjectClass *pGVar11;
  undefined8 local_34;
  ulonglong uVar12;
  
  uVar12._4_4_ = (undefined4)((ulonglong)local_34 >> 0x20);
  if (v == (toporouter_vertex_t *)0x0) {
    __printf_chk(1,"[V (null) ");
    pcVar9 = (char *)0x0;
  }
  else {
    gVar1 = (v->v).p.x;
    uVar12._4_4_ = (undefined4)((ulonglong)gVar1 >> 0x20);
    __printf_chk(1,"[V %f,%f,%f ",gVar1,(v->v).p.y,(v->v).p.z);
    if ((v->bbox == (_toporouter_bbox_t *)0x0) ||
       (p_Var2 = v->bbox->cluster, p_Var2 == (_toporouter_cluster_t *)0x0)) {
      pcVar9 = (char *)0x0;
    }
    else {
      pcVar9 = p_Var2->netlist->netlist;
    }
  }
  uVar12 = CONCAT44(uVar12._4_4_,pcVar9);
  __printf_chk(1,&DAT_08147f34,pcVar9);
  if ((v->route != (_toporouter_route_t *)0x0) &&
     (p_Var3 = v->route->netlist, p_Var3 != (_toporouter_netlist_t *)0x0)) {
    pcVar9 = p_Var3->netlist;
    uVar4 = uVar12 >> 0x20;
    uVar12 = uVar12 & 0xffffffff00000000 | ZEXT48(pcVar9);
    __printf_chk(1,&DAT_08147f34,pcVar9,(int)uVar4);
  }
  uVar12._4_4_ = (undefined4)(uVar12 >> 0x20);
  if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar10 = v->routingedge;
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL",uVar12._4_4_);
      ptVar10 = v->routingedge;
    }
    else {
      if (ptVar10 != (toporouter_edge_t *)0x0) {
        pGVar11 = (ptVar10->e).segment.object.klass;
        if (pGVar11 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082,uVar12._4_4_);
          ptVar10 = v->routingedge;
        }
        else {
          do {
            if (pGVar5 == pGVar11) break;
            pGVar11 = pGVar11->parent_class;
          } while (pGVar11 != (GtsObjectClass *)0x0);
        }
      }
    }
    uVar6 = g_list_length(ptVar10->routing);
    pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar10 = v->routingedge;
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL",uVar12._4_4_);
      ptVar10 = v->routingedge;
    }
    else {
      if (ptVar10 != (toporouter_edge_t *)0x0) {
        pGVar11 = (ptVar10->e).segment.object.klass;
        if (pGVar11 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082,uVar12._4_4_);
          ptVar10 = v->routingedge;
        }
        else {
          do {
            if (pGVar5 == pGVar11) break;
            pGVar11 = pGVar11->parent_class;
          } while (pGVar11 != (GtsObjectClass *)0x0);
        }
      }
    }
    uVar7 = g_list_index(ptVar10->routing,v);
    pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL",uVar12._4_4_);
    }
    else {
      if (v->routingedge != (toporouter_edge_t *)0x0) {
        pGVar11 = (v->routingedge->e).segment.object.klass;
        if (pGVar11 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082,uVar12._4_4_);
        }
        else {
          do {
            if (pGVar5 == pGVar11) {
              __printf_chk(1,"[CONST ");
              goto LAB_080e27d6;
            }
            pGVar11 = pGVar11->parent_class;
          } while (pGVar11 != (GtsObjectClass *)0x0);
        }
      }
    }
    __printf_chk(1,"[EDGE ");
LAB_080e27d6:
    uVar12 = CONCAT44(uVar6,uVar7);
    __printf_chk(1,"%d/%d] ",uVar7,uVar6);
  }
  uVar8 = v->flags;
  if ((char)uVar8 < '\0') {
    __printf_chk(1,"TEMP ",uVar12);
    uVar8 = v->flags;
  }
  if ((uVar8 & 0x100) != 0) {
    __printf_chk(1,"ROUTE ",uVar12);
    uVar8 = v->flags;
  }
  if ((uVar8 & 0x800) != 0) {
    __printf_chk(1,"SPECCUT ");
    uVar8 = v->flags;
  }
  if ((uVar8 & 0x400) != 0) {
    __printf_chk(1,"FAKE ");
  }
  __printf_chk(1,0x8151579);
  return;
}



void print_oproute(toporouter_oproute_t *oproute)

{
  GList *pGVar1;
  toporouter_arc_t *arc;
  
  __printf_chk(1,"Optimized Route:\n");
  __printf_chk(1,"\tNetlist:\t\t%s\n\tStyle:\t\t%s\n",oproute->netlist,oproute->style);
  __printf_chk(1,&DAT_0814741a);
  print_vertex(oproute->term1);
  __printf_chk(1,0x8151453);
  pGVar1 = oproute->arcs;
  while (pGVar1 != (GList *)0x0) {
    arc = (toporouter_arc_t *)pGVar1->data;
    __printf_chk(1,&DAT_0814741a);
    print_toporouter_arc(arc);
    __printf_chk(1,0x8151453);
    pGVar1 = (GList *)(&pGVar1->data)[1];
  }
  __printf_chk(1,&DAT_0814741a);
  print_vertex(oproute->term2);
  __printf_chk(1,0x8151453);
  return;
}



void print_vertices(GList *vertices)

{
  toporouter_vertex_t *v;
  
  if (vertices != (GList *)0x0) {
    do {
      while( true ) {
        v = (toporouter_vertex_t *)vertices->data;
        print_vertex(v);
        if (v != (toporouter_vertex_t *)0x0) break;
        print_bbox((toporouter_bbox_t *)0x0);
LAB_080e2b2d:
        __printf_chk(1,"no bbox\n");
        vertices = (GList *)(&vertices->data)[1];
        if (vertices == (GList *)0x0) {
          return;
        }
      }
      print_bbox((toporouter_bbox_t *)v->bbox);
      if (v->bbox == (_toporouter_bbox_t *)0x0) goto LAB_080e2b2d;
      __printf_chk(1,"has bbox\n");
      if (v->bbox->cluster == (_toporouter_cluster_t *)0x0) {
        __printf_chk(1,"no cluster\n");
      }
      else {
        __printf_chk(1,"has cluster\n");
      }
      vertices = (GList *)(&vertices->data)[1];
    } while (vertices != (GList *)0x0);
  }
  return;
}



void print_edge(toporouter_edge_t *e)

{
  GList *pGVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar3 = (e->e).segment.object.klass;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar2 == pGVar3) break;
          pGVar3 = pGVar3->parent_class;
        } while (pGVar3 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar1 = e->routing;
  __printf_chk(1,"EDGE:\n");
  print_vertex((toporouter_vertex_t *)(e->e).segment.v1);
  while (pGVar1 != (GList *)0x0) {
    print_vertex((toporouter_vertex_t *)pGVar1->data);
    pGVar1 = (GList *)(&pGVar1->data)[1];
  }
  print_vertex((toporouter_vertex_t *)(e->e).segment.v2);
  return;
}



// WARNING: Type propagation algorithm not settling

gint check_speccut(toporouter_oproute_t *oproute,toporouter_vertex_t *v1,toporouter_vertex_t *v2,
                  toporouter_edge_t *e,toporouter_edge_t *e1,toporouter_edge_t *e2)

{
  double x3;
  double dVar1;
  double y3;
  double dVar2;
  double dVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GList *pGVar6;
  double dVar7;
  GtsObjectClass *pGVar8;
  GtsTriangle *t;
  GtsVertex *v1_00;
  GtsSegment *object;
  GtsSegment *object_00;
  guint gVar9;
  toporouter_constraint_class_t *klass;
  guint32 gVar10;
  gpointer pvVar11;
  GtsEdgeClass *klass_00;
  toporouter_edge_t *e_00;
  GtsObjectClass *pGVar12;
  float10 fVar13;
  float10 fVar14;
  GtsVertex *local_30;
  gdouble line_int_y;
  gdouble line_int_x;
  
  pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar8 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning();
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar12 = (e->e).segment.object.klass;
      if (pGVar12 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning();
      }
      else {
        do {
          if (pGVar8 == pGVar12) {
            return 0;
          }
          pGVar12 = pGVar12->parent_class;
        } while (pGVar12 != (GtsObjectClass *)0x0);
      }
    }
  }
  t = gts_triangle_use_edges((GtsEdge *)e,(GtsEdge *)e1,(GtsEdge *)e2);
  if (t == (GtsTriangle *)0x0) {
    __printf_chk(1,"check_speccut: NULL t\n");
  }
  else {
    t = opposite_triangle(t,e);
    if (t == (GtsTriangle *)0x0) {
      __printf_chk(1,"check_speccut: NULL opt\n");
    }
    else {
      if ((e2 != (toporouter_edge_t *)0x0) && (e1 != (toporouter_edge_t *)0x0)) {
        v1_00 = (e1->e).segment.v1;
        pGVar4 = (e2->e).segment.v1;
        local_30 = v1_00;
        if (((v1_00 == pGVar4) ||
            (((pGVar5 = (e1->e).segment.v2, local_30 = pGVar4, pGVar4 == pGVar5 ||
              (pGVar4 = (e2->e).segment.v2, local_30 = v1_00, v1_00 == pGVar4)) ||
             (local_30 = pGVar5, pGVar5 == pGVar4)))) && (local_30 != (GtsVertex *)0x0)) {
          v1_00 = gts_triangle_vertex_opposite(t,(GtsEdge *)e);
          if (v1_00 == (GtsVertex *)0x0) {
            __printf_chk(1,"check_speccut: NULL opv2\n");
            return 0;
          }
          object = gts_vertices_are_connected(v1_00,(e->e).segment.v1);
          object_00 = gts_vertices_are_connected(v1_00,(e->e).segment.v2);
          pGVar4 = (e->e).segment.v1;
          dVar7 = (double)(pGVar4->p).x;
          x3 = (double)(v1_00->p).x;
          dVar1 = (double)(pGVar4->p).y;
          y3 = (double)(v1_00->p).y;
          dVar2 = (double)(local_30->p).x;
          dVar3 = (double)(local_30->p).y;
          dVar7 = (dVar3 - dVar1) * (dVar7 - x3) - (dVar2 - dVar7) * (dVar1 - y3);
          if ((0.00010000 < dVar7) || (dVar7 < -0.00010000)) {
            pGVar5 = (e->e).segment.v2;
            dVar7 = (double)(pGVar5->p).x;
            dVar1 = (double)(pGVar5->p).y;
            dVar7 = (dVar3 - dVar1) * (dVar7 - x3) - (dVar1 - y3) * (dVar2 - dVar7);
            if (((0.00010000 < dVar7) || (dVar7 < -0.00010000)) &&
               (gVar9 = vertex_line_normal_intersection
                                  ((pGVar4->p).x,(pGVar4->p).y,(pGVar5->p).x,(pGVar5->p).y,
                                   (gdouble)x3,(gdouble)y3,&line_int_x,&line_int_y), gVar9 != 0)) {
              if (object->v1 == v1_00) {
                klass = toporouter_constraint_class();
                gts_object_is_from_class(object,klass);
                gVar10 = g_list_append();
                object[1].object.flags = gVar10;
              }
              else {
                klass = toporouter_constraint_class();
                gts_object_is_from_class(object,klass);
                gVar10 = g_list_prepend();
                object[1].object.flags = gVar10;
              }
              fVar13 = (float10)triangle_interior_capacity();
              gts_vertices_are_connected(v1_00,(e->e).segment.v2);
              gts_vertices_are_connected(v1_00,(e->e).segment.v1);
              fVar14 = (float10)flow_from_edge_to_edge();
              klass = toporouter_constraint_class();
              pvVar11 = gts_object_is_from_class(object,klass);
              if (pvVar11 == (gpointer)0x0) {
                gVar10 = g_list_remove();
                object[1].object.flags = gVar10;
              }
              else {
                gVar10 = g_list_remove();
                object[1].object.flags = gVar10;
              }
              if ((double)fVar13 <= (double)fVar14) {
                klass_00 = (GtsEdgeClass *)toporouter_edge_class();
                e_00 = (toporouter_edge_t *)gts_edge_new(klass_00,local_30,v1_00);
                klass = toporouter_constraint_class();
                gts_object_is_from_class(e1,klass);
                speccut_edge_routing_from_edge(e1->routing,e_00);
                klass = toporouter_constraint_class();
                gts_object_is_from_class(e2,klass);
                speccut_edge_routing_from_edge(e2->routing,e_00);
                klass = toporouter_constraint_class();
                gts_object_is_from_class(object,klass);
                speccut_edge_routing_from_edge((GList *)object[1].object.flags,e_00);
                klass = toporouter_constraint_class();
                gts_object_is_from_class(object_00,klass);
                speccut_edge_routing_from_edge((GList *)object_00[1].object.flags,e_00);
                pGVar6 = e_00->routing;
                while (pGVar6 != (GList *)0x0) {
                  pvVar11 = pGVar6->data;
                  pGVar6 = pGVar6->next;
                  *(gpointer *)(*(int *)((int)pvVar11 + 0x2c) + 0x30) = pvVar11;
                  *(gpointer *)(*(int *)((int)pvVar11 + 0x30) + 0x2c) = pvVar11;
                }
                __printf_chk(1,"SPECCUT WITH v %f,%f for seg %f,%f %f,%f detected\n",(v1_00->p).x,
                             (v1_00->p).y,(v1->v).p.x,(v1->v).p.y,(v2->v).p.x,(v2->v).p.y);
                __printf_chk(1,"\tflow %f cap %f\n",(double)fVar14,(double)fVar13);
                print_edge(e_00);
                return (uint)(e_00->routing != (GList *)0x0);
              }
            }
          }
          return 0;
        }
      }
      __printf_chk(1,"check_speccut: NULL opv\n");
    }
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

gint oproute_path_speccut(toporouter_oproute_t *oproute)

{
  GList *pGVar1;
  toporouter_vertex_t *v2;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *ptVar3;
  toporouter_vertex_t *ptVar4;
  toporouter_vertex_t *ptVar5;
  toporouter_vertex_t *v1;
  gint gVar6;
  toporouter_edge_t *e2;
  toporouter_edge_t *e;
  toporouter_vertex_t *ptVar7;
  toporouter_vertex_t *local_64;
  toporouter_vertex_t *local_68;
  toporouter_edge_t *local_60;
  toporouter_edge_t *local_38;
  toporouter_edge_t *local_34;
  
LAB_080e3139:
  pGVar1 = oproute->path;
  if (pGVar1 != (GList *)0x0) {
    local_64 = (toporouter_vertex_t *)pGVar1->data;
    ptVar7 = (toporouter_vertex_t *)(&pGVar1->data)[1];
    if (ptVar7 != (toporouter_vertex_t *)0x0) {
      do {
        v2 = *(toporouter_vertex_t **)&ptVar7->v;
        if (((local_64 != (toporouter_vertex_t *)0x0) &&
            (((local_34 = v2->routingedge, local_34 != (toporouter_edge_t *)0x0 ||
              (local_64->routingedge != (toporouter_edge_t *)0x0)) &&
             ((*(byte *)((int)&local_64->flags + 1) & 8) == 0)))) &&
           ((*(byte *)((int)&v2->flags + 1) & 8) == 0)) {
          if (local_34 == (toporouter_edge_t *)0x0) {
            e2 = (toporouter_edge_t *)
                 gts_vertices_are_connected((local_64->routingedge->e).segment.v2,(GtsVertex *)v2);
            local_60 = local_64->routingedge;
            e = (toporouter_edge_t *)
                gts_vertices_are_connected((local_60->e).segment.v1,(GtsVertex *)v2);
            gVar6 = check_speccut(oproute,local_64,v2,e,local_60,e2);
            if (gVar6 != 0) goto LAB_080e3139;
            local_38 = (toporouter_edge_t *)
                       gts_vertices_are_connected
                                 ((local_64->routingedge->e).segment.v1,(GtsVertex *)v2);
            local_34 = local_64->routingedge;
            local_60 = (toporouter_edge_t *)
                       gts_vertices_are_connected((local_34->e).segment.v2,(GtsVertex *)v2);
            v1 = local_64;
            local_64 = v2;
          }
          else {
            local_38 = local_64->routingedge;
            if (local_38 == (toporouter_edge_t *)0x0) {
              e2 = (toporouter_edge_t *)
                   gts_vertices_are_connected((local_34->e).segment.v2,(GtsVertex *)local_64);
              local_60 = v2->routingedge;
              e = (toporouter_edge_t *)
                  gts_vertices_are_connected((local_60->e).segment.v1,(GtsVertex *)local_64);
              gVar6 = check_speccut(oproute,v2,local_64,e,local_60,e2);
              if (gVar6 != 0) goto LAB_080e3139;
              local_38 = (toporouter_edge_t *)
                         gts_vertices_are_connected
                                   ((v2->routingedge->e).segment.v1,(GtsVertex *)local_64);
              local_34 = v2->routingedge;
              v1 = (toporouter_vertex_t *)(local_34->e).segment.v2;
              local_68 = local_64;
            }
            else {
              ptVar2 = (toporouter_vertex_t *)(local_34->e).segment.v1;
              ptVar3 = (toporouter_vertex_t *)(local_38->e).segment.v1;
              if (ptVar2 == ptVar3) {
                v1 = (toporouter_vertex_t *)(local_34->e).segment.v2;
                local_68 = (toporouter_vertex_t *)(local_38->e).segment.v2;
              }
              else {
                ptVar4 = (toporouter_vertex_t *)(local_34->e).segment.v2;
                if (ptVar3 == ptVar4) {
                  v1 = ptVar2;
                  local_68 = (toporouter_vertex_t *)(local_38->e).segment.v2;
                }
                else {
                  ptVar5 = (toporouter_vertex_t *)(local_38->e).segment.v2;
                  v1 = ptVar4;
                  local_68 = ptVar3;
                  if (ptVar2 != ptVar5) {
                    v1 = (toporouter_vertex_t *)0x0;
                    if (ptVar4 == ptVar5) {
                      v1 = ptVar2;
                    }
                    local_68 = (toporouter_vertex_t *)0x0;
                    if (ptVar4 == ptVar5) {
                      local_68 = ptVar3;
                    }
                  }
                }
              }
            }
            local_60 = (toporouter_edge_t *)
                       gts_vertices_are_connected((GtsVertex *)v1,(GtsVertex *)local_68);
            v1 = v2;
          }
          gVar6 = check_speccut(oproute,v1,local_64,local_60,local_34,local_38);
          if (gVar6 != 0) goto LAB_080e3139;
        }
        ptVar7 = *(toporouter_vertex_t **)((int)&ptVar7->v + 4);
        local_64 = v2;
        if (ptVar7 == (toporouter_vertex_t *)0x0) {
          return 0;
        }
      } while( true );
    }
  }
  return 0;
}



void print_path(GList *path)

{
  toporouter_vertex_t *v;
  gpointer *ppvVar1;
  int iVar2;
  GList *pGVar3;
  
  __printf_chk(1,"PATH:\n");
  pGVar3 = path;
  if (path != (GList *)0x0) {
    do {
      v = (toporouter_vertex_t *)pGVar3->data;
      print_vertex(v);
      if ((v->child != (_toporouter_vertex_t *)0x0) &&
         (iVar2 = g_list_find(path,v->child), iVar2 == 0)) {
        __printf_chk(1,"\t CHILD NOT IN LIST\n");
      }
      if ((v->parent != (_toporouter_vertex_t *)0x0) &&
         (iVar2 = g_list_find(path,v->parent), iVar2 == 0)) {
        __printf_chk(1,"\t parent NOT IN LIST\n");
      }
      ppvVar1 = &pGVar3->data;
      pGVar3 = (GList *)ppvVar1[1];
    } while ((GList *)ppvVar1[1] != (GList *)0x0);
  }
  return;
}



void delaunay_create_from_vertices(GList *vertices,GtsSurface **surface,GtsTriangle **t)

{
  GList **ppGVar1;
  GtsEdge *e3;
  GtsEdge *e2;
  GtsEdge *e1;
  GList *pGVar2;
  GtsTriangleClass *klass;
  GtsTriangle *t_00;
  GtsVertexClass *vertex_class;
  GtsEdgeClass *edge_class;
  GtsFaceClass *face_class;
  GtsSurfaceClass *klass_00;
  GtsSurface *pGVar3;
  GtsFace *f;
  toporouter_vertex_t *v;
  GList *pGVar4;
  GList *points;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pGVar2 = (GList *)0x0;
  points = vertices;
  pGVar4 = vertices;
  if (vertices != (GList *)0x0) {
    do {
      pGVar2 = (GList *)g_slist_prepend(pGVar2,pGVar4->data);
      ppGVar1 = &pGVar4->next;
      points = pGVar2;
      pGVar4 = *ppGVar1;
    } while (*ppGVar1 != (GList *)0x0);
  }
  klass = gts_triangle_class();
  t_00 = gts_triangle_enclosing(klass,(GSList *)points,100000.00000000);
  *t = t_00;
  gts_triangle_vertices(t_00,local_20,&local_24,&local_28);
  vertex_class = (GtsVertexClass *)toporouter_vertex_class();
  edge_class = (GtsEdgeClass *)toporouter_edge_class();
  face_class = gts_face_class();
  klass_00 = gts_surface_class();
  pGVar3 = gts_surface_new(klass_00,face_class,edge_class,vertex_class);
  *surface = pGVar3;
  t_00 = *t;
  e3 = t_00->e3;
  e2 = t_00->e2;
  e1 = t_00->e1;
  face_class = gts_face_class();
  f = gts_face_new(face_class,e1,e2,e3);
  gts_surface_add_face(*surface,f);
  if (vertices != (GList *)0x0) {
    do {
      v = (toporouter_vertex_t *)
          gts_delaunay_add_vertex(*surface,(GtsVertex *)vertices->data,(GtsFace *)0x0);
      if (v != (toporouter_vertex_t *)0x0) {
        __printf_chk(1,"ERROR: vertex could not be added to CDT ");
        print_vertex(v);
      }
      vertices = (GList *)(&vertices->data)[1];
    } while (vertices != (GList *)0x0);
  }
  gts_allow_floating_vertices = 1;
  gts_object_destroy((GtsObject *)local_20[0]);
  gts_object_destroy((GtsObject *)local_24);
  gts_object_destroy((GtsObject *)local_28);
  gts_allow_floating_vertices = 0;
  g_slist_free(points);
  return;
}



toporouter_bbox_t *
toporouter_bbox_create(int layer,GList *vertices,toporouter_term_t type,gpointer data)

{
  GtsSurface *surface;
  GtsBBoxClass *klass;
  toporouter_bbox_t *ptVar1;
  GtsTriangle *local_14;
  GtsSurface *local_10 [2];
  
  delaunay_create_from_vertices(vertices,local_10,&local_14);
  surface = local_10[0];
  klass = (GtsBBoxClass *)toporouter_bbox_class();
  ptVar1 = (toporouter_bbox_t *)gts_bbox_surface(klass,surface);
  ptVar1->type = type;
  ptVar1->data = data;
  ptVar1->surface = local_10[0];
  ptVar1->enclosing = local_14;
  ptVar1->layer = layer;
  return ptVar1;
}



int read_board_constraints(toporouter_t *r,toporouter_layer_t *l,int layer)

{
  toporouter_bbox_t *box;
  GSList *pGVar1;
  GList *local_20 [4];
  
  local_20[0] = (GList *)0x0;
  create_board_edge(0.00000000,0.00000000,(gdouble)(double)PCB->MaxWidth,0.00000000,10000.00000000,
                    layer,local_20);
  create_board_edge((gdouble)(double)PCB->MaxWidth,0.00000000,(gdouble)(double)PCB->MaxWidth,
                    (gdouble)(double)PCB->MaxHeight,10000.00000000,layer,local_20);
  create_board_edge((gdouble)(double)PCB->MaxWidth,(gdouble)(double)PCB->MaxHeight,0.00000000,
                    (gdouble)(double)PCB->MaxHeight,10000.00000000,layer,local_20);
  create_board_edge(0.00000000,(gdouble)(double)PCB->MaxHeight,0.00000000,0.00000000,10000.00000000,
                    layer,local_20);
  box = toporouter_bbox_create(layer,local_20[0],BOARD,(gpointer)0x0);
  pGVar1 = (GSList *)g_slist_prepend();
  r->bboxes = pGVar1;
  insert_constraints_from_list(r,l,local_20[0],box);
  g_list_free(local_20[0],l);
  return 0;
}



int read_points(toporouter_t *r,toporouter_layer_t *l,int layer)

{
  toporouter_layer_t *ptVar1;
  uint uVar2;
  double dVar3;
  double y;
  double x;
  GList *vertices;
  toporouter_bbox_t *box;
  GtsVertex *pGVar4;
  GSList *pGVar5;
  DataTypePtr *pDVar6;
  PCBTypePtr pPVar7;
  int iVar8;
  gpointer data;
  PinTypePtr *data_00;
  uint uVar9;
  float10 fVar10;
  float10 fVar11;
  undefined8 local_10c;
  undefined4 uVar12;
  int local_34;
  int local_30;
  uint local_24;
  
  pDVar6 = PCB->Data;
  local_30 = pDVar6->ElementN - 1;
  if (local_30 != -1) {
    pPVar7 = PCB;
    iVar8 = pDVar6->ElementN * 300;
    do {
      local_34 = iVar8 + -300;
      iVar8 = (int)&pDVar6->Element[-1].BoundingBox.X1 + iVar8;
      if (*(uint *)(iVar8 + 0xe0) != 0) {
        uVar9 = 0;
        local_24 = *(uint *)(iVar8 + 0xe0);
        do {
          data = (gpointer)(uVar9 * 0x4c + *(int *)(iVar8 + 0x100));
          dVar3 = (double)*(int *)((int)data + 0x24) * 0.50000000;
          x = (double)*(int *)((int)data + 0x34);
          y = (double)*(int *)((int)data + 0x38);
          uVar12 = (undefined4)((ulonglong)local_10c >> 0x20);
          if ((*(uint *)((int)data + 0x14) & 0x100) == 0) {
            if ((*(uint *)((int)data + 0x14) & 0x800) == 0) {
              ptVar1 = r->layers;
              fVar10 = (float10)lookup_thickness(*(undefined4 *)((int)data + 0x3c));
              fVar11 = (float10)lookup_keepaway(*(undefined4 *)((int)data + 0x3c),uVar12);
              vertices = rect_with_attachments
                                   ((gdouble)(double)((float10)0.50000000 * (float10)(double)fVar10
                                                     + fVar11),(gdouble)(x - dVar3),
                                    (gdouble)(y - dVar3),(gdouble)(x - dVar3),(gdouble)(y + dVar3),
                                    (gdouble)(x + dVar3),(gdouble)(y + dVar3),(gdouble)(x + dVar3),
                                    (gdouble)(y - dVar3),
                                    (gdouble)(double)((int)((int)l - (int)ptVar1) >> 4));
              box = toporouter_bbox_create((int)((int)l - (int)r->layers) >> 4,vertices,PIN,data);
              pGVar5 = (GSList *)g_slist_prepend();
              r->bboxes = pGVar5;
              goto LAB_080e3970;
            }
            local_10c = CONCAT44(1,stderr);
            __fprintf_chk(stderr,1,"No support for octagon pins yet\n");
            uVar2 = *(uint *)(iVar8 + 0xe0);
            pPVar7 = PCB;
          }
          else {
            ptVar1 = r->layers;
            fVar10 = (float10)lookup_thickness(*(undefined4 *)((int)data + 0x3c));
            fVar11 = (float10)lookup_keepaway(*(undefined4 *)((int)data + 0x3c),uVar12);
            vertices = rect_with_attachments
                                 ((gdouble)(double)((float10)0.50000000 * (float10)(double)fVar10 +
                                                   fVar11),(gdouble)(x - dVar3),(gdouble)(y - dVar3)
                                  ,(gdouble)(x - dVar3),(gdouble)(y + dVar3),(gdouble)(x + dVar3),
                                  (gdouble)(y + dVar3),(gdouble)(x + dVar3),(gdouble)(y - dVar3),
                                  (gdouble)(double)((int)((int)l - (int)ptVar1) >> 4));
            box = toporouter_bbox_create((int)((int)l - (int)r->layers) >> 4,vertices,PIN,data);
            pGVar5 = (GSList *)g_slist_prepend();
            r->bboxes = pGVar5;
            insert_constraints_from_list(r,l,vertices,box);
LAB_080e3970:
            g_list_free();
            local_10c = CONCAT44(l,r);
            pGVar4 = insert_vertex(r,l,(gdouble)x,(gdouble)y,box);
            *(GtsVertex **)&box->point = pGVar4;
            uVar2 = *(uint *)(iVar8 + 0xe0);
            pPVar7 = PCB;
          }
          PCB = pPVar7;
        } while ((uVar2 != 0) &&
                (uVar9 = (uVar2 + 1 + uVar9) - local_24, local_24 = uVar2, uVar9 < uVar2));
      }
      local_30 = local_30 + -1;
      if (local_30 == -1) goto LAB_080e3ae5;
      pDVar6 = pPVar7->Data;
      iVar8 = local_34;
    } while( true );
  }
LAB_080e3aeb:
  if (pDVar6->ViaN != 0) {
    uVar9 = 0;
    local_24 = pDVar6->ViaN;
    do {
      data_00 = pDVar6->Via + uVar9;
      dVar3 = (double)data_00->Thickness * 0.50000000;
      uVar2 = (data_00->Flags).f;
      x = (double)data_00->X;
      y = (double)data_00->Y;
      uVar12 = (undefined4)((ulonglong)local_10c >> 0x20);
      if ((uVar2 & 0x100) == 0) {
        if ((uVar2 & 0x800) == 0) {
          ptVar1 = r->layers;
          fVar10 = (float10)lookup_thickness(data_00->Name);
          fVar11 = (float10)lookup_keepaway(data_00->Name,uVar12);
          vertices = rect_with_attachments
                               ((gdouble)(double)((float10)0.50000000 * (float10)(double)fVar10 +
                                                 fVar11),(gdouble)(x - dVar3),(gdouble)(y - dVar3),
                                (gdouble)(x - dVar3),(gdouble)(y + dVar3),(gdouble)(x + dVar3),
                                (gdouble)(y + dVar3),(gdouble)(x + dVar3),(gdouble)(y - dVar3),
                                (gdouble)(double)((int)((int)l - (int)ptVar1) >> 4));
          box = toporouter_bbox_create((int)((int)l - (int)r->layers) >> 4,vertices,VIA,data_00);
          pGVar5 = (GSList *)g_slist_prepend();
          r->bboxes = pGVar5;
          g_list_free();
          local_10c = CONCAT44(l,r);
          pGVar4 = insert_vertex(r,l,(gdouble)x,(gdouble)y,box);
          *(GtsVertex **)&box->point = pGVar4;
        }
        else {
          local_10c = CONCAT44(1,stderr);
          __fprintf_chk(stderr,1,"No support for octagon vias yet\n");
        }
      }
      else {
        ptVar1 = r->layers;
        fVar10 = (float10)lookup_thickness(data_00->Name);
        fVar11 = (float10)lookup_keepaway(data_00->Name,uVar12);
        vertices = rect_with_attachments
                             ((gdouble)(double)((float10)0.50000000 * (float10)(double)fVar10 +
                                               fVar11),(gdouble)(x - dVar3),(gdouble)(y - dVar3),
                              (gdouble)(x - dVar3),(gdouble)(y + dVar3),(gdouble)(x + dVar3),
                              (gdouble)(y + dVar3),(gdouble)(x + dVar3),(gdouble)(y - dVar3),
                              (gdouble)(double)((int)((int)l - (int)ptVar1) >> 4));
        box = toporouter_bbox_create((int)((int)l - (int)r->layers) >> 4,vertices,VIA,data_00);
        pGVar5 = (GSList *)g_slist_prepend();
        r->bboxes = pGVar5;
        insert_constraints_from_list(r,l,vertices,box);
        g_list_free();
        local_10c = CONCAT44(l,r);
        pGVar4 = insert_vertex(r,l,(gdouble)x,(gdouble)y,box);
        *(GtsVertex **)&box->point = pGVar4;
      }
      pDVar6 = PCB->Data;
      uVar2 = pDVar6->ViaN;
    } while ((uVar2 != 0) &&
            (uVar9 = (uVar2 + 1 + uVar9) - local_24, local_24 = uVar2, uVar9 < uVar2));
  }
  return 0;
LAB_080e3ae5:
  pDVar6 = pPVar7->Data;
  goto LAB_080e3aeb;
}



// WARNING: Removing unreachable block (ram,0x080e446e)
// WARNING: Removing unreachable block (ram,0x080e4934)
// WARNING: Removing unreachable block (ram,0x080e3f61)
// WARNING: Removing unreachable block (ram,0x080e4974)

int read_pads(toporouter_t *r,toporouter_layer_t *l,guint layer)

{
  int iVar1;
  double r_00;
  uint uVar2;
  toporouter_layer_t *ptVar3;
  bool bVar4;
  float fVar5;
  double x;
  double dVar6;
  double y;
  double dVar7;
  gdouble m;
  double m_00;
  gdouble y0;
  gdouble x1;
  gdouble y1;
  gdouble x2;
  gdouble y2;
  gdouble x3;
  gdouble y3;
  char "read_pads" [10];
  int iVar8;
  int iVar9;
  int iVar10;
  DataTypePtr *pDVar11;
  int iVar12;
  int iVar13;
  GList *vertices;
  toporouter_bbox_t *box;
  GtsVertex *pGVar14;
  toporouter_bbox_t *box_00;
  GSList *pGVar15;
  byte bVar16;
  uint uVar17;
  gpointer data;
  float10 fVar18;
  float10 fVar19;
  int local_134;
  int local_130;
  uint local_c0;
  double local_bc;
  toporouter_spoint_t rv [5];
  toporouter_spoint_t temp [2];
  toporouter_spoint_t p [2];
  
  iVar8 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  iVar9 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar10 = (int)((int)l - (int)r->layers) >> 4;
  if ((iVar10 == iVar8) || (iVar9 == iVar10)) {
    pDVar11 = PCB->Data;
    local_130 = pDVar11->ElementN - 1;
    if (local_130 != -1) {
      iVar10 = pDVar11->ElementN * 300;
LAB_080e3e80:
      local_134 = iVar10 + -300;
      iVar10 = (int)&pDVar11->Element[-1].BoundingBox.X1 + iVar10;
      local_c0 = 0;
      uVar2 = *(uint *)(iVar10 + 0xe8);
      do {
        uVar17 = uVar2;
        do {
          if ((uVar17 == 0) || (uVar17 <= local_c0)) {
            local_130 = local_130 + -1;
            if (local_130 == -1) {
              return 0;
            }
            pDVar11 = PCB->Data;
            iVar10 = local_134;
            goto LAB_080e3e80;
          }
          data = (gpointer)(local_c0 * 0x68 + *(int *)(iVar10 + 0x104));
          iVar12 = (int)((int)l - (int)r->layers) >> 4;
          if (((iVar12 == iVar9) &&
              (bVar16 = (byte)((uint)*(undefined4 *)((int)data + 0x14) >> 8),
              (char)*(undefined4 *)((int)data + 0x14) < '\0')) ||
             ((iVar8 == iVar12 &&
              (bVar16 = (byte)((uint)*(undefined4 *)((int)data + 0x14) >> 8),
              -1 < (char)*(undefined4 *)((int)data + 0x14))))) {
            fVar5 = (float)*(int *)((int)data + 0x24) * 0.50000000;
            iVar13 = *(int *)((int)data + 0x2c);
            x = (double)iVar13;
            dVar6 = (double)*(int *)((int)data + 0x40);
            iVar1 = *(int *)((int)data + 0x30);
            y = (double)iVar1;
            dVar7 = (double)*(int *)((int)data + 0x44);
            if ((bVar16 & 1) == 0) {
              if (x == dVar6) {
                if (y == dVar7) {
                  fVar18 = (float10)lookup_thickness(*(undefined4 *)((int)data + 0x58));
                  fVar19 = (float10)lookup_keepaway(*(undefined4 *)((int)data + 0x58));
                  vertices = rect_with_attachments
                                       ((gdouble)(double)((float10)0.50000000 *
                                                          (float10)(double)fVar18 + fVar19),
                                        (gdouble)(double)((float)iVar13 - fVar5),
                                        (gdouble)(double)((float)iVar1 - fVar5),
                                        (gdouble)(double)((float)iVar13 - fVar5),
                                        (gdouble)(double)((float)iVar1 + fVar5),
                                        (gdouble)(double)((float)iVar13 + fVar5),
                                        (gdouble)(double)((float)iVar1 + fVar5),
                                        (gdouble)(double)((float)iVar13 + fVar5),
                                        (gdouble)(double)((float)iVar1 - fVar5),
                                        (gdouble)(double)iVar12);
                  box_00 = toporouter_bbox_create
                                     ((int)((int)l - (int)r->layers) >> 4,vertices,PAD,data);
                  pGVar15 = (GSList *)g_slist_prepend(r->bboxes,box_00);
                  r->bboxes = pGVar15;
                  g_list_free(vertices);
                  pGVar14 = insert_vertex(r,l,(gdouble)x,(gdouble)y,box_00);
                  *(GtsVertex **)&box_00->point = pGVar14;
                  uVar17 = *(uint *)(iVar10 + 0xe8);
                  goto LAB_080e3ecc;
                }
                local_bc = INFINITY;
                bVar4 = true;
                m = INFINITY;
              }
              else {
                local_bc = (dVar7 - y) / (dVar6 - x);
                bVar4 = 
                        179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                        < local_bc;
                m = (gdouble)local_bc;
                if (x == dVar6) {
                  m = INFINITY;
                }
              }
              r_00 = (double)fVar5;
              p[0].x = (gdouble)x;
              p[0].y = (gdouble)y;
              p[1].x = (gdouble)dVar6;
              p[1].y = (gdouble)dVar7;
              vertices_on_line(p,m,(gdouble)(double)fVar5,temp,temp + 1);
              fVar18 = (float10)vertices_plane_distance(temp,p + 1);
              fVar19 = (float10)vertices_plane_distance(temp + 1,p + 1);
              if ((float10)(double)fVar18 <= fVar19) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
              }
              if (bVar4) {
                m = 0.00000000;
              }
              else {
                m = (gdouble)(-1.00000000 / local_bc);
              }
              vertices_on_line(rv,m,(gdouble)r_00,rv + 1,rv + 2);
              if ((double)p[1].x == (double)p[0].x) {
                m_00 = INFINITY;
              }
              else {
                m_00 = ((double)p[0].y - (double)p[1].y) / ((double)p[0].x - (double)p[1].x);
              }
              vertices_on_line(p + 1,(gdouble)m_00,(gdouble)r_00,temp,temp + 1);
              fVar18 = (float10)vertices_plane_distance(temp,p);
              fVar19 = (float10)vertices_plane_distance(temp + 1,p);
              if ((float10)(double)fVar18 <= fVar19) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
                if (!bVar4) goto LAB_080e49af;
LAB_080e465f:
                m = 0.00000000;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
                if (bVar4) goto LAB_080e465f;
LAB_080e49af:
                m = (gdouble)(-1.00000000 / local_bc);
              }
              vertices_on_line(rv,m,(gdouble)r_00,rv + 3,rv + 4);
              y2 = rv[3].y;
              x2 = rv[3].x;
              y1 = rv[2].y;
              x1 = rv[2].x;
              y0 = rv[1].y;
              m = rv[1].x;
              iVar12 = 1;
              r_00 = ((double)rv[2].x - (double)rv[1].x) * ((double)rv[3].y - (double)rv[2].y) -
                     ((double)rv[2].y - (double)rv[1].y) * ((double)rv[3].x - (double)rv[2].x);
              if (r_00 <= 0.00010000) {
                iVar12 = (uint)(-0.00010000 <= r_00) - 1;
              }
              iVar13 = 1;
              r_00 = ((double)rv[4].y - (double)rv[3].y) * ((double)rv[3].x - (double)rv[2].x) -
                     ((double)rv[4].x - (double)rv[3].x) * ((double)rv[3].y - (double)rv[2].y);
              if (r_00 <= 0.00010000) {
                iVar13 = (uint)(-0.00010000 <= r_00) - 1;
              }
              if (iVar12 != iVar13) {
                rv[0].x = rv[3].x;
                rv[0].y = rv[3].y;
                rv[3].x = rv[4].x;
                rv[3].y = rv[4].y;
                rv[4].x = x2;
                rv[4].y = y2;
              }
              y3 = rv[4].y;
              x3 = rv[4].x;
              y2 = rv[3].y;
              x2 = rv[3].x;
              ptVar3 = r->layers;
              fVar18 = (float10)lookup_thickness(*(undefined4 *)((int)data + 0x58));
              fVar19 = (float10)lookup_keepaway(*(undefined4 *)((int)data + 0x58));
              r_00 = (double)(float10)0.50000000;
              vertices = rect_with_attachments
                                   ((gdouble)(double)((float10)(double)fVar18 * (float10)0.50000000
                                                     + fVar19),m,y0,x1,y1,x2,y2,x3,y3,
                                    (gdouble)(double)((int)((int)l - (int)ptVar3) >> 4));
              box_00 = toporouter_bbox_create((int)((int)l - (int)r->layers) >> 4,vertices,PAD,data)
              ;
              pGVar15 = (GSList *)g_slist_prepend(r->bboxes,box_00);
              r->bboxes = pGVar15;
              insert_constraints_from_list(r,l,vertices,box_00);
              g_list_free(vertices);
              pGVar14 = insert_vertex(r,l,(gdouble)((x + dVar6) * r_00),
                                      (gdouble)((y + dVar7) * r_00),box_00);
              *(GtsVertex **)&box_00->point = pGVar14;
            }
            else {
              if (x == dVar6) {
                if (y == dVar7) {
                  fVar18 = (float10)lookup_thickness(*(undefined4 *)((int)data + 0x58));
                  fVar19 = (float10)lookup_keepaway(*(undefined4 *)((int)data + 0x58));
                  vertices = rect_with_attachments
                                       ((gdouble)(double)((float10)0.50000000 *
                                                          (float10)(double)fVar18 + fVar19),
                                        (gdouble)(double)((float)iVar13 - fVar5),
                                        (gdouble)(double)((float)iVar1 - fVar5),
                                        (gdouble)(double)((float)iVar13 - fVar5),
                                        (gdouble)(double)((float)iVar1 + fVar5),
                                        (gdouble)(double)((float)iVar13 + fVar5),
                                        (gdouble)(double)((float)iVar1 + fVar5),
                                        (gdouble)(double)((float)iVar13 + fVar5),
                                        (gdouble)(double)((float)iVar1 - fVar5),
                                        (gdouble)(double)iVar12);
                  box = toporouter_bbox_create
                                  ((int)((int)l - (int)r->layers) >> 4,vertices,PAD,data);
                  pGVar15 = (GSList *)g_slist_prepend(r->bboxes,box);
                  r->bboxes = pGVar15;
                  insert_constraints_from_list(r,l,vertices,box);
                  g_list_free(vertices);
                  pGVar14 = insert_vertex(r,l,(gdouble)x,(gdouble)y,box);
                  box_00 = (toporouter_bbox_t *)pGVar14[1].p.object.klass;
                  *(GtsVertex **)&box->point = pGVar14;
                  if (box != box_00) {
                    // WARNING: Subroutine does not return
                    g_assertion_message_expr
                              (0,"../../src/toporouter.c",0x782,0x815135a,
                               "TOPOROUTER_VERTEX(bbox->point)->bbox == bbox");
                  }
                  goto LAB_080e48ff;
                }
                local_bc = INFINITY;
                bVar4 = true;
                m = INFINITY;
              }
              else {
                local_bc = (dVar7 - y) / (dVar6 - x);
                bVar4 = 
                        179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                        < local_bc;
                m = (gdouble)local_bc;
                if (x == dVar6) {
                  m = INFINITY;
                }
              }
              r_00 = (double)fVar5;
              p[0].x = (gdouble)x;
              p[0].y = (gdouble)y;
              p[1].x = (gdouble)dVar6;
              p[1].y = (gdouble)dVar7;
              vertices_on_line(p,m,(gdouble)(double)fVar5,temp,temp + 1);
              fVar18 = (float10)vertices_plane_distance(temp,p + 1);
              fVar19 = (float10)vertices_plane_distance(temp + 1,p + 1);
              if ((float10)(double)fVar18 <= fVar19) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
                if (!bVar4) goto LAB_080e4a17;
LAB_080e4075:
                m = 0.00000000;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
                if (bVar4) goto LAB_080e4075;
LAB_080e4a17:
                m = (gdouble)(-1.00000000 / local_bc);
              }
              vertices_on_line(rv,m,(gdouble)r_00,rv + 1,rv + 2);
              if ((double)p[1].x == (double)p[0].x) {
                m_00 = INFINITY;
              }
              else {
                m_00 = ((double)p[0].y - (double)p[1].y) / ((double)p[0].x - (double)p[1].x);
              }
              vertices_on_line(p + 1,(gdouble)m_00,(gdouble)r_00,temp,temp + 1);
              fVar18 = (float10)vertices_plane_distance(temp,p);
              fVar19 = (float10)vertices_plane_distance(temp + 1,p);
              if ((float10)(double)fVar18 <= fVar19) {
                rv[0].x = temp[1].x;
                rv[0].y = temp[1].y;
              }
              else {
                rv[0].x = temp[0].x;
                rv[0].y = temp[0].y;
              }
              if (bVar4) {
                m = 0.00000000;
              }
              else {
                m = (gdouble)(-1.00000000 / local_bc);
              }
              vertices_on_line(rv,m,(gdouble)r_00,rv + 3,rv + 4);
              y2 = rv[3].y;
              x2 = rv[3].x;
              y1 = rv[2].y;
              x1 = rv[2].x;
              y0 = rv[1].y;
              m = rv[1].x;
              iVar12 = 1;
              r_00 = ((double)rv[2].x - (double)rv[1].x) * ((double)rv[3].y - (double)rv[2].y) -
                     ((double)rv[2].y - (double)rv[1].y) * ((double)rv[3].x - (double)rv[2].x);
              if (r_00 <= 0.00010000) {
                iVar12 = (uint)(-0.00010000 <= r_00) - 1;
              }
              iVar13 = 1;
              r_00 = ((double)rv[4].y - (double)rv[3].y) * ((double)rv[3].x - (double)rv[2].x) -
                     ((double)rv[4].x - (double)rv[3].x) * ((double)rv[3].y - (double)rv[2].y);
              if (r_00 <= 0.00010000) {
                iVar13 = (uint)(-0.00010000 <= r_00) - 1;
              }
              if (iVar12 != iVar13) {
                rv[0].x = rv[3].x;
                rv[0].y = rv[3].y;
                rv[3].x = rv[4].x;
                rv[3].y = rv[4].y;
                rv[4].x = x2;
                rv[4].y = y2;
              }
              y3 = rv[4].y;
              x3 = rv[4].x;
              y2 = rv[3].y;
              x2 = rv[3].x;
              ptVar3 = r->layers;
              fVar18 = (float10)lookup_thickness(*(undefined4 *)((int)data + 0x58));
              fVar19 = (float10)lookup_keepaway(*(undefined4 *)((int)data + 0x58));
              r_00 = (double)(float10)0.50000000;
              vertices = rect_with_attachments
                                   ((gdouble)(double)((float10)(double)fVar18 * (float10)0.50000000
                                                     + fVar19),m,y0,x1,y1,x2,y2,x3,y3,
                                    (gdouble)(double)((int)((int)l - (int)ptVar3) >> 4));
              box = toporouter_bbox_create((int)((int)l - (int)r->layers) >> 4,vertices,PAD,data);
              pGVar15 = (GSList *)g_slist_prepend(r->bboxes,box);
              r->bboxes = pGVar15;
              insert_constraints_from_list(r,l,vertices,box);
              g_list_free(vertices);
              pGVar14 = insert_vertex(r,l,(gdouble)((x + dVar6) * r_00),
                                      (gdouble)((y + dVar7) * r_00),box);
              box_00 = (toporouter_bbox_t *)pGVar14[1].p.object.klass;
              *(GtsVertex **)&box->point = pGVar14;
              if (box != box_00) {
                    // WARNING: Subroutine does not return
                g_assertion_message_expr
                          (0,"../../src/toporouter.c",0x7a8,"read_pads",
                           "TOPOROUTER_VERTEX(bbox->point)->bbox == bbox");
              }
            }
LAB_080e48ff:
            uVar17 = *(uint *)(iVar10 + 0xe8);
          }
LAB_080e3ecc:
        } while (uVar17 != uVar2);
        local_c0 = local_c0 + 1;
      } while( true );
    }
  }
  return 0;
}



void import_geometry(toporouter_t *r)

{
  guint *pgVar1;
  uint *puVar2;
  uint ln;
  int iVar3;
  DataTypePtr *pDVar4;
  GNode *pGVar5;
  int iVar6;
  uint uVar7;
  size_t __size;
  int iVar8;
  PCBTypePtr pPVar9;
  toporouter_layer_t *local_28;
  guint local_24;
  
  iVar6 = 0;
  __size = 0;
  iVar8 = PCB->Data->LayerN;
  iVar3 = 0;
  if (0 < iVar8) {
    do {
      iVar6 = (iVar6 + 1) - (uint)((PCB->LayerGroups).Number[iVar3] == 0);
      iVar3 = iVar3 + 1;
    } while (iVar3 != iVar8);
    __size = iVar6 * 0x10;
  }
  local_28 = (toporouter_layer_t *)calloc(1,__size);
  pPVar9 = PCB;
  r->layers = local_28;
  if (0 < pPVar9->Data->LayerN) {
    local_24 = 0;
    do {
      iVar8 = local_24 + 0x734;
      if ((&(pPVar9->Flags).f)[iVar8] != 0) {
        local_28->vertices = (GList *)0x0;
        local_28->constraints = (GList *)0x0;
        read_board_constraints(r,local_28,(pPVar9->LayerGroups).Entries[local_24 * 0x12]);
        read_points(r,local_28,(PCB->LayerGroups).Entries[local_24 * 0x12]);
        read_pads(r,local_28,local_24);
        pDVar4 = PCB->Data;
        iVar3 = *(int *)&pDVar4->field_0x48;
        if (*(int *)(iVar3 + 4 + iVar8 * 4) != 0) {
          uVar7 = 0;
          pPVar9 = PCB;
          do {
            ln = *(uint *)(iVar3 + 4 + (uVar7 + 0x744 + local_24 * 0x12) * 4);
            if (ln < (uint)pDVar4->LayerN) {
              read_lines(r,local_28,(LayerType *)(&pDVar4->field_0x4c + ln * 0x5c),ln);
              pPVar9 = PCB;
            }
            pDVar4 = pPVar9->Data;
            uVar7 = uVar7 + 1;
            iVar3 = *(int *)&pDVar4->field_0x48;
            puVar2 = (uint *)(iVar3 + 4 + iVar8 * 4);
          } while (uVar7 <= *puVar2 && *puVar2 != uVar7);
        }
        build_cdt(r,local_28);
        pPVar9 = PCB;
        local_28 = local_28 + 1;
      }
      local_24 = local_24 + 1;
      pgVar1 = (guint *)&pPVar9->Data->LayerN;
    } while (*pgVar1 != local_24 && (int)local_24 <= (int)*pgVar1);
  }
  pGVar5 = gts_bb_tree_new(r->bboxes);
  r->bboxtree = pGVar5;
  import_clusters(r);
  return;
}



toporouter_vertex_t * edge_closest_vertex(toporouter_edge_t *e,toporouter_vertex_t *v)

{
  toporouter_vertex_t *ptVar1;
  GtsObjectClass *pGVar2;
  toporouter_edge_t *ptVar3;
  GtsObjectClass *pGVar4;
  GList *pGVar5;
  float10 fVar6;
  double local_2c;
  toporouter_vertex_t *local_20;
  
  if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar3 = v->routingedge;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      ptVar3 = v->routingedge;
    }
    else {
      if (ptVar3 != (toporouter_edge_t *)0x0) {
        pGVar4 = (ptVar3->e).segment.object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          ptVar3 = v->routingedge;
        }
        else {
          do {
            if (pGVar2 == pGVar4) break;
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar5 = ptVar3->routing;
    if (pGVar5 != (GList *)0x0) {
      local_20 = (toporouter_vertex_t *)0x0;
      local_2c = 0.00000000;
      do {
        ptVar1 = (toporouter_vertex_t *)pGVar5->data;
        fVar6 = (float10)gts_point_distance2(ptVar1,v);
        if ((local_20 == (toporouter_vertex_t *)0x0) || (fVar6 < (float10)local_2c)) {
          local_2c = (double)fVar6;
          local_20 = ptVar1;
        }
        pGVar5 = (GList *)(&pGVar5->data)[1];
      } while (pGVar5 != (GList *)0x0);
      return local_20;
    }
  }
  return (toporouter_vertex_t *)0x0;
}



void delete_vertex(toporouter_vertex_t *v)

{
  GtsObjectClass *pGVar1;
  GList *pGVar2;
  GtsObjectClass *pGVar3;
  toporouter_edge_t *ptVar4;
  
  if (-1 < *(char *)&v->flags) {
    return;
  }
  if (v->routingedge != (toporouter_edge_t *)0x0) {
    pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
    ptVar4 = v->routingedge;
    if (pGVar1 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      ptVar4 = v->routingedge;
    }
    else {
      if (ptVar4 != (toporouter_edge_t *)0x0) {
        pGVar3 = (ptVar4->e).segment.object.klass;
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          ptVar4 = v->routingedge;
        }
        else {
          do {
            if (pGVar1 == pGVar3) break;
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar2 = (GList *)g_list_remove(ptVar4->routing,v);
    ptVar4->routing = pGVar2;
  }
  gts_object_destroy((GtsObject *)v);
  return;
}



// WARNING: Type propagation algorithm not settling

void oproute_check_all_loops(toporouter_t *r,toporouter_oproute_t *oproute)

{
  toporouter_vertex_t *arc;
  toporouter_vertex_t *v;
  guint gVar1;
  toporouter_arc_class_t *klass;
  gpointer pvVar2;
  GList *pGVar3;
  toporouter_arc_class_t *ptVar4;
  toporouter_vertex_t *v_00;
  
  pGVar3 = oproute->arcs;
LAB_080e518e:
  v = oproute->term1;
  while( true ) {
    if (pGVar3 == (GList *)0x0) {
      return;
    }
    arc = (toporouter_vertex_t *)pGVar3->data;
    if ((toporouter_vertex_t *)(&pGVar3->data)[1] == (toporouter_vertex_t *)0x0) {
      v_00 = oproute->term2;
    }
    else {
      v_00 = *(toporouter_vertex_t **)&((toporouter_vertex_t *)(&pGVar3->data)[1])->v;
    }
    gVar1 = check_arc_for_loops(v,(toporouter_arc_t *)arc,v_00);
    if (gVar1 != 0) break;
    pGVar3 = (GList *)(&pGVar3->data)[1];
    v = arc;
  }
  klass = toporouter_arc_class();
  if (klass == (toporouter_arc_class_t *)0x0) {
LAB_080e5290:
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (v != (toporouter_vertex_t *)0x0) {
      ptVar4 = (toporouter_arc_class_t *)(v->v).p.object.klass;
      if (ptVar4 == (toporouter_arc_class_t *)0x0) {
LAB_080e52f8:
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          if (klass == ptVar4) {
            if (v != (toporouter_vertex_t *)0x0) {
              klass = toporouter_arc_class();
              if (klass == (toporouter_arc_class_t *)0x0) goto LAB_080e5290;
              if (v_00 != (toporouter_vertex_t *)0x0) {
                ptVar4 = (toporouter_arc_class_t *)(v_00->v).p.object.klass;
                if (ptVar4 != (toporouter_arc_class_t *)0x0) goto LAB_080e5252;
                goto LAB_080e52f8;
              }
            }
            break;
          }
          ptVar4 = (toporouter_arc_class_t *)(ptVar4->parent_class).parent_class;
        } while (ptVar4 != (toporouter_arc_class_t *)0x0);
      }
    }
  }
  goto LAB_080e52b0;
  while (ptVar4 = (toporouter_arc_class_t *)(ptVar4->parent_class).parent_class,
        ptVar4 != (toporouter_arc_class_t *)0x0) {
LAB_080e5252:
    if (klass == ptVar4) {
      if (v_00 != (toporouter_vertex_t *)0x0) {
        calculate_arc_to_arc(r,(toporouter_arc_t *)v,(toporouter_arc_t *)v_00);
        goto LAB_080e526d;
      }
      break;
    }
  }
LAB_080e52b0:
  klass = toporouter_arc_class();
  if (klass == (toporouter_arc_class_t *)0x0) {
    g_return_if_fail_warning(0,0x8151189,"klass != NULL");
  }
  else {
    if (v != (toporouter_vertex_t *)0x0) {
      ptVar4 = (toporouter_arc_class_t *)(v->v).p.object.klass;
      if (ptVar4 == (toporouter_arc_class_t *)0x0) {
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          if (klass == ptVar4) {
            if (v != (toporouter_vertex_t *)0x0) {
              calculate_term_to_arc(v_00,(toporouter_arc_t *)v,1);
              goto LAB_080e526d;
            }
            break;
          }
          ptVar4 = (toporouter_arc_class_t *)(ptVar4->parent_class).parent_class;
        } while (ptVar4 != (toporouter_arc_class_t *)0x0);
      }
    }
  }
  klass = toporouter_arc_class();
  pvVar2 = gts_object_is_from_class(v_00,klass);
  if (pvVar2 != (gpointer)0x0) {
    calculate_term_to_arc(v,(toporouter_arc_t *)v_00,0);
  }
LAB_080e526d:
  pGVar3 = (GList *)g_list_remove(oproute->arcs,arc);
  oproute->arcs = pGVar3;
  goto LAB_080e518e;
}



// WARNING: Type propagation algorithm not settling

gboolean temp_point_clean(gpointer key,gpointer value,gpointer user_data)

{
  GtsObjectClass *pGVar1;
  GtsObjectClass *pGVar2;
  GtsObjectClass *pGVar3;
  
  if (-1 < *(char *)((int)value + 0x38)) {
    return 1;
  }
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  pGVar3 = *(GtsObjectClass **)((int)value + 0x34);
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    pGVar3 = *(GtsObjectClass **)((int)value + 0x34);
  }
  else {
    if (pGVar3 != (GtsObjectClass *)0x0) {
      pGVar2 = *(GtsObjectClass **)&pGVar3->info;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        pGVar3 = *(GtsObjectClass **)((int)value + 0x34);
      }
      else {
        do {
          if (pGVar1 == pGVar2) break;
          pGVar2 = pGVar2->parent_class;
        } while (pGVar2 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar1 = (GtsObjectClass *)g_list_remove(((GtsObjectClass **)pGVar3)[7],value);
  ((GtsObjectClass **)pGVar3)[7] = pGVar1;
  gts_object_destroy((GtsObject *)value);
  return 1;
}



// WARNING: Type propagation algorithm not settling

GList * vertices_routing_conflicts(toporouter_vertex_t *v,toporouter_vertex_t *pv)

{
  toporouter_edge_t *ptVar1;
  toporouter_edge_t *ptVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  gpointer pvVar5;
  GList *pGVar6;
  GList *pGVar7;
  char "vertices_routing_conflicts" [27];
  GtsObjectClass *pGVar8;
  GtsSegment *object;
  undefined4 uVar9;
  int iVar10;
  GtsVertex *v2;
  toporouter_constraint_class_t *klass;
  GtsSegment *object_00;
  GtsObjectClass *pGVar11;
  toporouter_vertex_t *v_00;
  int *piVar12;
  toporouter_edge_t *ptVar13;
  toporouter_vertex_t *v_01;
  GList *pGVar14;
  GtsVertex *pGVar15;
  GList *pGVar16;
  GList *local_2c;
  GList *local_28;
  GList *local_24;
  GList *local_20 [4];
  
  if ((double)(v->v).p.z != (double)(pv->v).p.z) {
    return (GList *)0x0;
  }
  local_20[0] = (GList *)0x0;
  local_24 = (GList *)0x0;
  if (v == pv) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1103,0x8151289,"v != pv");
  }
  if ((v->routingedge == (toporouter_edge_t *)0x0) && (pv->routingedge == (toporouter_edge_t *)0x0))
  {
    object = gts_vertices_are_connected((GtsVertex *)v,(GtsVertex *)pv);
    if (object == (GtsSegment *)0x0) {
      return (GList *)0x0;
    }
    klass = toporouter_constraint_class();
    pGVar14 = (GList *)0x0;
    gts_object_is_from_class(object,klass);
    piVar12 = (int *)object[1].object.flags;
    if (piVar12 == (int *)0x0) {
      return (GList *)0x0;
    }
    do {
      pGVar14 = (GList *)g_list_prepend(pGVar14,*(undefined4 *)(*piVar12 + 0x58));
      piVar12 = (int *)piVar12[1];
    } while (piVar12 != (int *)0x0);
    return pGVar14;
  }
  pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar8 == (GtsObjectClass *)0x0) {
LAB_080e57a0:
    g_return_if_fail_warning(0,0x8151189,"klass != NULL");
  }
  else {
    if (v->routingedge != (toporouter_edge_t *)0x0) {
      pGVar11 = (v->routingedge->e).segment.object.klass;
      if (pGVar11 == (GtsObjectClass *)0x0) {
LAB_080e54b6:
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar8 == pGVar11) {
            klass = toporouter_constraint_class();
            if (klass == (toporouter_constraint_class_t *)0x0) goto LAB_080e57a0;
            if (pv->routingedge != (toporouter_edge_t *)0x0) {
              pGVar8 = (pv->routingedge->e).segment.object.klass;
              if (pGVar8 != (GtsObjectClass *)0x0) goto joined_r0x080e55d4;
              goto LAB_080e54b6;
            }
            break;
          }
          pGVar11 = pGVar11->parent_class;
        } while (pGVar11 != (GtsObjectClass *)0x0);
      }
    }
  }
LAB_080e54d8:
  pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
  ptVar13 = pv->routingedge;
  if (pGVar8 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x8151189,"klass != NULL");
  }
  else {
    if (ptVar13 != (toporouter_edge_t *)0x0) {
      pGVar11 = (ptVar13->e).segment.object.klass;
      if (pGVar11 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          v_00 = v;
          v_01 = pv;
          if (pGVar8 == pGVar11) goto LAB_080e5518;
          pGVar11 = pGVar11->parent_class;
        } while (pGVar11 != (GtsObjectClass *)0x0);
      }
    }
  }
  ptVar13 = v->routingedge;
  v_00 = pv;
  v_01 = v;
  if (ptVar13 == (toporouter_edge_t *)0x0) {
    ptVar13 = pv->routingedge;
    v_00 = v;
    v_01 = pv;
  }
LAB_080e5518:
  split_edge_routing(v_01,local_20,&local_24);
  if (local_24 == (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x111a,0x8151289,0x8149175);
  }
  if (local_20[0] == (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x111b,0x8151289,0x814914f);
  }
  if (v_00->routingedge == (toporouter_edge_t *)0x0) {
    object_00 = gts_vertices_are_connected((GtsVertex *)v_00,(ptVar13->e).segment.v1);
    object = gts_vertices_are_connected((GtsVertex *)v_00,(ptVar13->e).segment.v2);
    klass = toporouter_constraint_class();
    gts_object_is_from_class(object_00,klass);
    uVar9 = g_list_copy(object_00[1].object.flags);
    local_20[0] = (GList *)g_list_concat(local_20[0],uVar9);
  }
  else {
    ptVar1 = v_00->routingedge;
    local_28 = (GList *)0x0;
    ptVar2 = v_01->routingedge;
    local_2c = (GList *)0x0;
    if ((ptVar1 == (toporouter_edge_t *)0x0) || (ptVar2 == (toporouter_edge_t *)0x0)) {
LAB_080e556f:
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x1129,"vertices_routing_conflicts","commonv");
    }
    v2 = (ptVar1->e).segment.v1;
    pGVar3 = (ptVar2->e).segment.v1;
    pGVar15 = pGVar3;
    if (((pGVar3 != v2) &&
        (((pGVar4 = (ptVar2->e).segment.v2, pGVar15 = v2, v2 != pGVar4 &&
          (v2 = (ptVar1->e).segment.v2, pGVar15 = pGVar3, pGVar3 != v2)) &&
         (pGVar15 = pGVar4, pGVar4 != v2)))) || (pGVar15 == (GtsVertex *)0x0)) goto LAB_080e556f;
    split_edge_routing(v_00,&local_28,&local_2c);
    if ((ptVar13->e).segment.v1 != pGVar15) {
      if ((v_00->routingedge->e).segment.v1 == pGVar15) {
        local_20[0] = (GList *)g_list_concat(local_20[0],local_2c);
        local_24 = (GList *)g_list_concat(local_24,local_28);
        v2 = (v_00->routingedge->e).segment.v2;
      }
      else {
        local_20[0] = (GList *)g_list_concat(local_20[0],local_28);
        local_24 = (GList *)g_list_concat(local_24,local_2c);
        v2 = (v_00->routingedge->e).segment.v1;
      }
      object = gts_vertices_are_connected((ptVar13->e).segment.v1,v2);
      if (object == (GtsSegment *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr(0,"../../src/toporouter.c",0x1147,0x8151289,&DAT_08151856);
      }
      pGVar8 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar8 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189,"klass != NULL");
      }
      else {
        pGVar11 = (object->object).klass;
        if (pGVar11 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,0x8151189,0x8161082);
        }
        else {
          do {
            if (pGVar8 == pGVar11) break;
            pGVar11 = pGVar11->parent_class;
          } while (pGVar11 != (GtsObjectClass *)0x0);
        }
      }
      uVar9 = g_list_copy(object[1].object.flags);
      local_20[0] = (GList *)g_list_concat(local_20[0],uVar9);
      goto LAB_080e573d;
    }
    if (pGVar15 == (v_00->routingedge->e).segment.v1) {
      local_20[0] = (GList *)g_list_concat(local_20[0],local_28);
      local_24 = (GList *)g_list_concat(local_24,local_2c);
      v2 = (v_00->routingedge->e).segment.v2;
    }
    else {
      local_20[0] = (GList *)g_list_concat(local_20[0],local_2c);
      local_24 = (GList *)g_list_concat(local_24,local_28);
      v2 = (v_00->routingedge->e).segment.v1;
    }
    object = gts_vertices_are_connected((ptVar13->e).segment.v2,v2);
    if (object == (GtsSegment *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/toporouter.c",0x1139,0x8151289,&DAT_08151856);
    }
  }
  klass = toporouter_constraint_class();
  gts_object_is_from_class(object,klass);
  uVar9 = g_list_copy(object[1].object.flags);
  local_24 = (GList *)g_list_concat(local_24,uVar9);
LAB_080e573d:
  pGVar16 = (GList *)0x0;
  pGVar6 = (GList *)0x0;
  pGVar14 = local_20[0];
  while (pGVar7 = local_24, pGVar14 != (GList *)0x0) {
    pvVar5 = pGVar14->data;
    if ((((*(byte *)((int)pvVar5 + 0x39) & 1) != 0) &&
        ((iVar10 = g_list_find(local_24,*(undefined4 *)((int)pvVar5 + 0x2c)), iVar10 != 0 ||
         (iVar10 = g_list_find(local_24,*(undefined4 *)((int)pvVar5 + 0x30)), iVar10 != 0)))) &&
       (iVar10 = g_list_find(pGVar16,*(undefined4 *)((int)pvVar5 + 0x58)), iVar10 == 0)) {
      pGVar16 = (GList *)g_list_prepend(pGVar16,*(undefined4 *)((int)pvVar5 + 0x58));
    }
    pGVar14 = pGVar14->next;
    pGVar6 = local_20[0];
  }
  while (pGVar7 != (GList *)0x0) {
    pvVar5 = pGVar7->data;
    if ((((*(byte *)((int)pvVar5 + 0x39) & 1) != 0) &&
        ((iVar10 = g_list_find(pGVar6,*(undefined4 *)((int)pvVar5 + 0x2c)), iVar10 != 0 ||
         (iVar10 = g_list_find(local_20[0],*(undefined4 *)((int)pvVar5 + 0x30)), iVar10 != 0)))) &&
       (iVar10 = g_list_find(pGVar16,*(undefined4 *)((int)pvVar5 + 0x58)), iVar10 == 0)) {
      pGVar16 = (GList *)g_list_prepend(pGVar16,*(undefined4 *)((int)pvVar5 + 0x58));
    }
    pGVar6 = local_20[0];
    pGVar7 = pGVar7->next;
  }
  g_list_free(pGVar6);
  g_list_free(local_24);
  return pGVar16;
joined_r0x080e55d4:
  do {
    if ((GtsObjectClass *)klass == pGVar8) {
      return (GList *)0x0;
    }
    pGVar8 = pGVar8->parent_class;
  } while (pGVar8 != (GtsObjectClass *)0x0);
  goto LAB_080e54d8;
}



GList * route_conflicts(toporouter_route_t *route)

{
  GList **ppGVar1;
  gpointer pvVar2;
  toporouter_vertex_t *pv;
  toporouter_vertex_t *v;
  GList *pGVar3;
  int iVar4;
  GList *pGVar5;
  GList *pGVar6;
  GList *pGVar7;
  
  pGVar6 = (GList *)0x0;
  pGVar7 = route->path;
  if (pGVar7 != (GList *)0x0) {
    pGVar6 = (GList *)0x0;
    pv = (toporouter_vertex_t *)pGVar7->data;
    while (v = pv, pGVar7 = (GList *)(&pGVar7->data)[1], pGVar7 != (GList *)0x0) {
      pv = (toporouter_vertex_t *)pGVar7->data;
      if (((v != (toporouter_vertex_t *)0x0) && ((double)(v->v).p.z == (double)(pv->v).p.z)) &&
         (pGVar3 = vertices_routing_conflicts(v,pv), pGVar5 = pGVar3, pGVar3 != (GList *)0x0)) {
        do {
          pvVar2 = pGVar5->data;
          iVar4 = g_list_find(pGVar6,pvVar2);
          if (iVar4 == 0) {
            pGVar6 = (GList *)g_list_prepend(pGVar6,pvVar2);
          }
          ppGVar1 = &pGVar5->next;
          pGVar5 = *ppGVar1;
        } while (*ppGVar1 != (GList *)0x0);
        g_list_free(pGVar3);
      }
    }
  }
  return pGVar6;
}



float10 vertices_routing_conflict_cost
                  (undefined4 r,toporouter_vertex_t *v,toporouter_vertex_t *pv,int *n)

{
  double dVar1;
  gpointer *ppvVar2;
  GList *pGVar3;
  int iVar4;
  GList *pGVar5;
  
  pGVar3 = vertices_routing_conflicts(v,pv);
  if (pGVar3 == (GList *)0x0) {
    dVar1 = 0.00000000;
  }
  else {
    iVar4 = *n;
    dVar1 = 0.00000000;
    pGVar5 = pGVar3;
    do {
      ppvVar2 = &pGVar5->data;
      iVar4 = iVar4 + 1;
      pGVar5 = pGVar5->next;
      dVar1 = dVar1 + *(double *)((int)*ppvVar2 + 0x14);
    } while (pGVar5 != (GList *)0x0);
    *n = iVar4;
  }
  g_list_free(pGVar3);
  return (float10)dVar1;
}



// WARNING: Removing unreachable block (ram,0x080e5cc7)
// WARNING: Removing unreachable block (ram,0x080e5ccb)
// WARNING: Removing unreachable block (ram,0x080e5cd0)

float10 gcost(int r,int data,undefined4 srcv,int v,int pv,uint *n)

{
  int iVar1;
  float10 fVar2;
  float10 fVar3;
  
  *n = *(uint *)(pv + 0x4c);
  iVar1 = g_list_find(*(undefined4 *)(data + 0x38),v);
  if (iVar1 == 0) {
    fVar2 = (float10)*(double *)(pv + 0xc) - (float10)*(double *)(v + 0xc);
    fVar3 = (float10)*(double *)(pv + 0x14) - (float10)*(double *)(v + 0x14);
    fVar2 = SQRT(fVar3 * fVar3 + fVar2 * fVar2) + (float10)*(double *)(pv + 0x3c);
    if ((*(byte *)(r + 0x14) & 0x20) != 0) {
      if ((pv == v) || (*(double *)(v + 0x1c) != *(double *)(pv + 0x1c))) {
        fVar3 = (float10)0;
      }
      else {
        fVar3 = (float10)vertices_routing_conflict_cost(r,v,pv,n);
        fVar2 = (float10)(double)fVar2;
      }
      fVar2 = (float10)(ulonglong)*n * (float10)(ulonglong)*n * fVar3 + fVar2;
    }
  }
  else {
    fVar2 = (float10)0;
  }
  return fVar2;
}



// WARNING: Removing unreachable block (ram,0x080e5fb8)
// WARNING: Removing unreachable block (ram,0x080e5dd8)
// WARNING: Removing unreachable block (ram,0x080e5fb1)
// WARNING: Removing unreachable block (ram,0x080e5fba)
// WARNING: Removing unreachable block (ram,0x080e5fde)
// WARNING: Removing unreachable block (ram,0x080e5eb0)
// WARNING: Removing unreachable block (ram,0x080e5dd4)
// WARNING: Type propagation algorithm not settling

float10 check_intersect_vertex
                  (gdouble x0,gdouble y0,gdouble x1,gdouble y1,int pathv,int arcv,undefined4 opv,
                  undefined4 wind,int *arcwind,double *arcr)

{
  double d;
  double dVar1;
  double dVar2;
  GtsObjectClass *pGVar3;
  guint gVar4;
  int iVar5;
  undefined4 uVar6;
  GtsObjectClass *pGVar7;
  GtsObjectClass *pGVar8;
  float10 fVar9;
  float10 fVar10;
  float10 fVar11;
  float10 fVar12;
  float10 fVar13;
  undefined8 local_ec;
  gdouble y;
  gdouble x;
  gdouble local_2c;
  gdouble local_24 [2];
  
  uVar6 = (undefined4)((ulonglong)local_ec >> 0x20);
  pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
  pGVar8 = *(GtsObjectClass **)(pathv + 0x34);
  if (pGVar3 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (pGVar8 != (GtsObjectClass *)0x0) {
      pGVar7 = *(GtsObjectClass **)&pGVar8->info;
      if (pGVar7 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar3 == pGVar7) {
            pGVar3 = *(GtsObjectClass **)((int)&pGVar8->info + 0xc);
            pGVar8 = *(GtsObjectClass **)((int)&pGVar8->info + 0x10);
            d = *(double *)((int)&pGVar3->info + 0xc) - *(double *)((int)&pGVar8->info + 0xc);
            dVar1 = *(double *)((int)&pGVar3->info + 0x14) - *(double *)((int)&pGVar8->info + 0x14);
            fVar12 = (float10)vertex_net_thickness(pathv);
            fVar9 = (float10)vertex_net_thickness(arcv,uVar6);
            fVar10 = (float10)vertex_net_keepaway(pathv,uVar6);
            fVar11 = (float10)vertex_net_keepaway(arcv,uVar6);
            fVar13 = (float10)(double)fVar10;
            if ((float10)(double)fVar10 <= fVar11) {
              fVar13 = fVar11;
            }
            fVar13 = (float10)0.50000000 * (float10)(double)fVar9 +
                     (float10)(double)fVar12 * (float10)0.50000000 + fVar13;
            fVar12 = (float10)(SQRT(dVar1 * dVar1 + d * d) * 0.50000000);
            if (fVar12 <= fVar13 || fVar13 != fVar12) {
              fVar13 = fVar12;
            }
            goto LAB_080e5e5e;
          }
          pGVar7 = pGVar7->parent_class;
        } while (pGVar7 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar3 = (GtsObjectClass *)toporouter_constraint_class();
  pGVar8 = *(GtsObjectClass **)(pathv + 0x34);
  if (pGVar3 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    pGVar8 = *(GtsObjectClass **)(pathv + 0x34);
  }
  else {
    if (pGVar8 != (GtsObjectClass *)0x0) {
      pGVar7 = *(GtsObjectClass **)&pGVar8->info;
      if (pGVar7 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        pGVar8 = *(GtsObjectClass **)(pathv + 0x34);
      }
      else {
        do {
          if (pGVar3 == pGVar7) break;
          pGVar7 = pGVar7->parent_class;
        } while (pGVar7 != (GtsObjectClass *)0x0);
      }
    }
  }
  uVar6 = g_list_find(((GtsObjectClass **)pGVar8)[7],pathv);
  fVar13 = (float10)edge_min_spacing(uVar6,pGVar8,arcv);
LAB_080e5e5e:
  d = (double)fVar13;
  gVar4 = vertex_line_normal_intersection
                    (x0,y0,x1,y1,*(gdouble *)(arcv + 0xc),*(gdouble *)(arcv + 0x14),local_24,
                     &local_2c);
  if ((gVar4 != 0) &&
     (dVar1 = local_24[0] - *(double *)(arcv + 0xc), dVar2 = local_2c - *(double *)(arcv + 0x14),
     dVar1 = SQRT(dVar2 * dVar2 + dVar1 * dVar1), dVar1 <= d - 0.00010000)) {
    coord_move_towards_coord_values
              (*(gdouble *)(arcv + 0xc),*(gdouble *)(arcv + 0x14),(gdouble)local_24[0],
               (gdouble)local_2c,(gdouble)d,&x,&y);
    *arcr = d;
    iVar5 = 1;
    dVar2 = (*(double *)(arcv + 0x14) - *(double *)(pathv + 0x14)) *
            (*(double *)(pathv + 0xc) - *(double *)(*(int *)(pathv + 0x2c) + 0xc)) -
            (*(double *)(arcv + 0xc) - *(double *)(pathv + 0xc)) *
            (*(double *)(pathv + 0x14) - *(double *)(*(int *)(pathv + 0x2c) + 0x14));
    if (dVar2 <= 0.00010000) {
      iVar5 = (uint)(-0.00010000 <= dVar2) - 1;
    }
    *arcwind = iVar5;
    return (float10)d - (float10)dVar1;
  }
  return -(float10)1;
}



// WARNING: Removing unreachable block (ram,0x080e6585)
// WARNING: Removing unreachable block (ram,0x080e6158)
// WARNING: Removing unreachable block (ram,0x080e6591)
// WARNING: Removing unreachable block (ram,0x080e659b)
// WARNING: Removing unreachable block (ram,0x080e6154)
// WARNING: Type propagation algorithm not settling

float10 check_non_intersect_vertex
                  (gdouble x0,double y0,double x1,double y1,int pathv,int arcv,int opv,int wind,
                  int *arcwind,double *arcr)

{
  gdouble ay;
  gdouble ax;
  double dVar1;
  double dVar2;
  double dVar3;
  char "check_non_intersect_vertex" [27];
  GtsObjectClass *pGVar4;
  guint gVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  GtsObjectClass *pGVar10;
  int iVar11;
  GtsObjectClass *pGVar12;
  int iVar13;
  float10 fVar14;
  float10 fVar15;
  float10 fVar16;
  float10 fVar17;
  float10 fVar18;
  undefined8 local_fc;
  double local_7c;
  double local_74;
  double local_6c;
  double local_64;
  gdouble local_5c;
  gdouble local_54;
  gdouble local_4c;
  gdouble local_44;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  uVar8 = (undefined4)((ulonglong)local_fc >> 0x20);
  if (*(int *)(pathv + 0x34) == 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x162b,"check_non_intersect_vertex","pathv->routingedge");
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  pGVar12 = *(GtsObjectClass **)(pathv + 0x34);
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (pGVar12 != (GtsObjectClass *)0x0) {
      pGVar10 = *(GtsObjectClass **)&pGVar12->info;
      if (pGVar10 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar4 == pGVar10) {
            pGVar4 = *(GtsObjectClass **)((int)&pGVar12->info + 0xc);
            pGVar12 = *(GtsObjectClass **)((int)&pGVar12->info + 0x10);
            dVar1 = *(double *)((int)&pGVar4->info + 0xc) - *(double *)((int)&pGVar12->info + 0xc);
            dVar2 = *(double *)((int)&pGVar4->info + 0x14) - *(double *)((int)&pGVar12->info + 0x14)
            ;
            fVar17 = (float10)vertex_net_thickness(pathv);
            fVar14 = (float10)vertex_net_thickness(arcv,uVar8);
            fVar15 = (float10)vertex_net_keepaway(pathv,uVar8);
            fVar16 = (float10)vertex_net_keepaway(arcv,uVar8);
            fVar18 = (float10)(double)fVar15;
            if ((float10)(double)fVar15 <= fVar16) {
              fVar18 = fVar16;
            }
            fVar18 = (float10)0.50000000 * (float10)(double)fVar14 +
                     (float10)(double)fVar17 * (float10)0.50000000 + fVar18;
            fVar17 = (float10)(SQRT(dVar2 * dVar2 + dVar1 * dVar1) * 0.50000000);
            if (fVar17 <= fVar18 || fVar18 != fVar17) {
              fVar18 = fVar17;
            }
            goto LAB_080e61e9;
          }
          pGVar10 = pGVar10->parent_class;
        } while (pGVar10 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  pGVar12 = *(GtsObjectClass **)(pathv + 0x34);
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    pGVar12 = *(GtsObjectClass **)(pathv + 0x34);
  }
  else {
    if (pGVar12 != (GtsObjectClass *)0x0) {
      pGVar10 = *(GtsObjectClass **)&pGVar12->info;
      if (pGVar10 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        pGVar12 = *(GtsObjectClass **)(pathv + 0x34);
      }
      else {
        do {
          if (pGVar4 == pGVar10) break;
          pGVar10 = pGVar10->parent_class;
        } while (pGVar10 != (GtsObjectClass *)0x0);
      }
    }
  }
  uVar8 = g_list_find(((GtsObjectClass **)pGVar12)[7],pathv);
  fVar18 = (float10)edge_min_spacing(uVar8,pGVar12,arcv);
LAB_080e61e9:
  local_74 = (double)fVar18;
  gVar5 = vertex_line_normal_intersection
                    (x0,(gdouble)y0,(gdouble)x1,(gdouble)y1,*(gdouble *)(arcv + 0xc),
                     *(gdouble *)(arcv + 0x14),local_24,&local_2c);
  if (gVar5 == 0) {
    if (((double)x0 - (double)local_24[0]) * ((double)x0 - (double)local_24[0]) +
        (y0 - local_2c) * (y0 - local_2c) <
        (x1 - (double)local_24[0]) * (x1 - (double)local_24[0]) + (y1 - local_2c) * (y1 - local_2c))
    {
      local_24[0] = x0;
      local_2c = y0;
    }
    else {
      local_24[0] = (gdouble)x1;
      local_2c = y1;
    }
    ay = *(gdouble *)(arcv + 0x14);
    ax = *(gdouble *)(arcv + 0xc);
    if (((double)ax == (double)local_24[0]) ||
       (local_6c = (local_2c - (double)ay) / ((double)local_24[0] - (double)ax),
              
       179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
       < local_6c)) {
      local_6c = 0.00000000;
    }
    else {
      local_6c = -1.00000000 / local_6c;
    }
  }
  else {
    if ((double)x0 == x1) {
      ay = *(gdouble *)(arcv + 0x14);
      ax = *(gdouble *)(arcv + 0xc);
      local_6c = INFINITY;
    }
    else {
      local_6c = (y1 - y0) / (x1 - (double)x0);
      ay = *(gdouble *)(arcv + 0x14);
      ax = *(gdouble *)(arcv + 0xc);
    }
  }
  coords_on_line(ax,ay,(gdouble)local_6c,100.00000000,&local_44,&local_4c,&local_54,&local_5c);
  iVar11 = 1;
  dVar1 = (local_2c - local_5c) * (local_54 - local_44) -
          ((double)local_24[0] - local_54) * (local_5c - local_4c);
  if (dVar1 <= 0.00010000) {
    iVar11 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  iVar6 = 1;
  dVar1 = (*(double *)(opv + 0x14) - local_5c) * (local_54 - local_44) -
          (*(double *)(opv + 0xc) - local_54) * (local_5c - local_4c);
  if (0.00010000 >= dVar1) {
    iVar6 = (uint)(-0.00010000 <= dVar1) - 1;
  }
  if ((iVar11 != iVar6) && (0.00010000 < dVar1 || dVar1 < -0.00010000)) {
    if (wind == 0) {
      if (local_6c <=
                    
          179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
         ) {
        ay = (gdouble)(-1.00000000 / local_6c);
      }
      else {
        ay = 0.00000000;
      }
      coords_on_line(local_24[0],(gdouble)local_2c,ay,(gdouble)local_74,&local_44,&local_4c,
                     &local_54,&local_5c);
      local_44 = local_44 - *(double *)(opv + 0xc);
      local_4c = local_4c - *(double *)(opv + 0x14);
      local_54 = local_54 - *(double *)(opv + 0xc);
      local_5c = local_5c - *(double *)(opv + 0x14);
      if (local_54 * local_54 + local_5c * local_5c <= local_44 * local_44 + local_4c * local_4c) {
        local_64 = 0.00000000;
      }
      else {
        local_64 = 0.00000000;
      }
LAB_080e63db:
      *arcr = local_74;
      iVar11 = 1;
      dVar1 = (*(double *)(arcv + 0x14) - *(double *)(pathv + 0x14)) *
              (*(double *)(pathv + 0xc) - *(double *)(*(int *)(pathv + 0x2c) + 0xc)) -
              (*(double *)(arcv + 0xc) - *(double *)(pathv + 0xc)) *
              (*(double *)(pathv + 0x14) - *(double *)(*(int *)(pathv + 0x2c) + 0x14));
      if (dVar1 <= 0.00010000) {
        iVar11 = (uint)(-0.00010000 <= dVar1) - 1;
      }
      *arcwind = iVar11;
      return (float10)local_64 + (float10)local_74;
    }
    iVar11 = *(int *)(pathv + 0x2c);
    dVar1 = *(double *)(arcv + 0xc) - (double)local_24[0];
    iVar6 = *(int *)(pathv + 0x30);
    dVar2 = *(double *)(arcv + 0x14) - local_2c;
    local_64 = SQRT(dVar2 * dVar2 + dVar1 * dVar1);
    coord_move_towards_coord_values
              (local_24[0],(gdouble)local_2c,(gdouble)*(double *)(arcv + 0xc),
               (gdouble)*(double *)(arcv + 0x14),(gdouble)(local_74 + local_64),&local_34,&local_3c)
    ;
    iVar9 = 0;
    dVar1 = *(double *)(iVar11 + 0x14) - local_3c;
    dVar2 = *(double *)(iVar11 + 0xc) - local_34;
    local_6c = *(double *)(iVar6 + 0x14) - local_3c;
    local_7c = *(double *)(iVar6 + 0xc) - local_34;
    while( true ) {
      iVar7 = 1;
      dVar3 = dVar1 * (local_34 - (double)local_24[0]) - dVar2 * (local_3c - local_2c);
      if (dVar3 <= 0.00010000) {
        iVar7 = (uint)(-0.00010000 <= dVar3) - 1;
      }
      iVar13 = 1;
      dVar3 = local_6c * (local_34 - (double)local_24[0]) - local_7c * (local_3c - local_2c);
      if (dVar3 <= 0.00010000) {
        if (-0.00010000 <= dVar3) goto LAB_080e63db;
        iVar13 = -1;
      }
      if ((iVar7 == 0) || (iVar7 != iVar13)) goto LAB_080e63db;
      if (iVar9 == 2) break;
      if ((*(byte *)(iVar11 + 0x39) & 1) != 0) {
        iVar11 = *(int *)(iVar11 + 0x2c);
        dVar1 = *(double *)(iVar11 + 0x14) - local_3c;
        dVar2 = *(double *)(iVar11 + 0xc) - local_34;
      }
      if ((*(byte *)(iVar6 + 0x39) & 1) != 0) {
        iVar6 = *(int *)(iVar6 + 0x30);
        local_6c = *(double *)(iVar6 + 0x14) - local_3c;
        local_7c = *(double *)(iVar6 + 0xc) - local_34;
      }
      iVar9 = iVar9 + 1;
    }
  }
  return -(float10)1;
}



// WARNING: Type propagation algorithm not settling

GList * oproute_rubberband_segment
                  (toporouter_t *r,toporouter_oproute_t *oproute,GList *path,gpointer t1,gpointer t2
                  ,guint debug)

{
  double dVar1;
  double dVar2;
  gdouble ax;
  gdouble ay;
  GtsVertex *pGVar3;
  int iVar4;
  double dVar5;
  toporouter_vertex_t *ptVar6;
  char "oproute_rubberband_segment" [27];
  toporouter_vertex_class_t *ptVar7;
  toporouter_edge_t *ptVar8;
  toporouter_arc_class_t *klass;
  gpointer pvVar9;
  toporouter_vertex_t **pptVar10;
  toporouter_vertex_t *centre;
  toporouter_arc_t *arc;
  guint gVar11;
  GList *list;
  int *piVar12;
  gint gVar13;
  undefined4 uVar14;
  toporouter_vertex_t *ptVar15;
  toporouter_vertex_t *ptVar16;
  toporouter_arc_class_t *ptVar17;
  toporouter_vertex_class_t *ptVar18;
  toporouter_vertex_t *pathv;
  toporouter_vertex_t *v1;
  float10 fVar19;
  code *pcVar20;
  toporouter_arc_t *ptVar21;
  int local_a0;
  double local_5c;
  toporouter_vertex_t *local_50;
  double local_4c;
  toporouter_arc_t *local_40;
  toporouter_arc_t *local_3c;
  toporouter_vertex_t *local_38;
  toporouter_vertex_t *local_34;
  int local_30;
  gdouble local_2c;
  gint local_20;
  
  ptVar7 = toporouter_vertex_class();
  if (ptVar7 == (toporouter_vertex_class_t *)0x0) {
    g_return_if_fail_warning();
  }
  else {
    if (t1 != (gpointer)0x0) {
      ptVar18 = *(toporouter_vertex_class_t **)t1;
      if (ptVar18 == (toporouter_vertex_class_t *)0x0) {
        g_return_if_fail_warning();
      }
      else {
        do {
          if (ptVar7 == ptVar18) {
            local_3c = (toporouter_arc_t *)0x0;
            local_5c = *(double *)((int)t1 + 0xc);
            local_4c = *(double *)((int)t1 + 0x14);
            local_38 = (toporouter_vertex_t *)t1;
            goto LAB_080e68c0;
          }
          ptVar18 = (toporouter_vertex_class_t *)
                    (ptVar18->parent_class).parent_class.parent_class.parent_class;
        } while (ptVar18 != (toporouter_vertex_class_t *)0x0);
      }
    }
  }
  klass = toporouter_arc_class();
  pvVar9 = gts_object_is_from_class(t1,klass);
  if (pvVar9 == (gpointer)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x16ca,0x81511ed,"TOPOROUTER_IS_ARC(t1)");
  }
  local_3c = (toporouter_arc_t *)t1;
  local_38 = *(toporouter_vertex_t **)((int)t1 + 0x48);
  local_5c = *(double *)((int)t1 + 0x1c);
  local_4c = *(double *)((int)t1 + 0x24);
LAB_080e68c0:
  ptVar7 = toporouter_vertex_class();
  if (ptVar7 == (toporouter_vertex_class_t *)0x0) {
    g_return_if_fail_warning();
  }
  else {
    if (t2 != (gpointer)0x0) {
      ptVar18 = *(toporouter_vertex_class_t **)t2;
      if (ptVar18 == (toporouter_vertex_class_t *)0x0) {
        g_return_if_fail_warning();
      }
      else {
        do {
          if (ptVar7 == ptVar18) {
            local_40 = (toporouter_arc_t *)0x0;
            dVar1 = *(double *)((int)t2 + 0xc);
            local_34 = (toporouter_vertex_t *)t2;
            dVar2 = *(double *)((int)t2 + 0x14);
            goto LAB_080e690a;
          }
          ptVar18 = (toporouter_vertex_class_t *)
                    (ptVar18->parent_class).parent_class.parent_class.parent_class;
        } while (ptVar18 != (toporouter_vertex_class_t *)0x0);
      }
    }
  }
  klass = toporouter_arc_class();
  if (klass == (toporouter_arc_class_t *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (t2 != (gpointer)0x0) {
      ptVar17 = *(toporouter_arc_class_t **)t2;
      if (ptVar17 == (toporouter_arc_class_t *)0x0) {
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          if (klass == ptVar17) {
            local_40 = (toporouter_arc_t *)t2;
            local_34 = *(toporouter_vertex_t **)((int)t2 + 0x4c);
            dVar1 = *(double *)((int)t2 + 0xc);
            dVar2 = *(double *)((int)t2 + 0x14);
LAB_080e690a:
            if (local_38 == local_34) {
              return (GList *)0;
            }
            list = path->next;
            if (list == (GList *)0x0) {
              return (GList *)0;
            }
            if ((toporouter_vertex_t *)path->data == local_34) {
              return (GList *)0;
            }
            pathv = (toporouter_vertex_t *)list->data;
            if (((pathv == local_34) || (pathv == local_38)) ||
               (ptVar8 = pathv->routingedge, ptVar8 == (toporouter_edge_t *)0x0)) goto LAB_080e6f85;
            do {
              ptVar16 = (toporouter_vertex_t *)(ptVar8->e).segment.v1;
              local_a0 = 1;
              dVar5 = ((double)(ptVar16->v).p.y - dVar2) * (dVar1 - local_5c) -
                      ((double)(ptVar16->v).p.x - dVar1) * (dVar2 - local_4c);
              if (dVar5 <= 0.00010000) {
                local_a0 = (uint)(-0.00010000 <= dVar5) - 1;
              }
              pGVar3 = (ptVar8->e).segment.v2;
              local_30 = 1;
              dVar5 = ((double)(pGVar3->p).y - dVar2) * (dVar1 - local_5c) -
                      ((double)(pGVar3->p).x - dVar1) * (dVar2 - local_4c);
              if ((0.00010000 < dVar5) || (local_30 = -1, dVar5 < -0.00010000)) {
                if ((local_a0 == 0) || (local_a0 == local_30)) goto LAB_080e6c48;
                if ((local_3c == (toporouter_arc_t *)0x0) ||
                   (local_50 = local_3c->centre, local_50 != ptVar16)) {
                  if ((local_40 == (toporouter_arc_t *)0x0) || (local_40->centre != ptVar16)) {
                    fVar19 = (float10)check_intersect_vertex();
                    if ((float10)0.00010000 < fVar19) {
                      new_rubberband_arc(pathv,(toporouter_vertex_t *)
                                               (pathv->routingedge->e).segment.v1,local_2c,
                                         (gdouble)(double)fVar19,local_20,list);
                      g_list_prepend();
                      ptVar8 = pathv->routingedge;
                    }
                    else {
                      ptVar8 = pathv->routingedge;
                    }
                  }
                  if (local_3c != (toporouter_arc_t *)0x0) {
                    local_50 = local_3c->centre;
                    goto LAB_080e6a98;
                  }
                  ptVar16 = (toporouter_vertex_t *)(ptVar8->e).segment.v2;
                }
                else {
LAB_080e6a98:
                  ptVar16 = (toporouter_vertex_t *)(ptVar8->e).segment.v2;
                  if (local_50 == ptVar16) goto LAB_080e6b68;
                }
                if (((local_40 == (toporouter_arc_t *)0x0) || (ptVar16 != local_40->centre)) &&
                   (fVar19 = (float10)check_intersect_vertex(), (float10)0.00010000 < fVar19)) {
                  new_rubberband_arc(pathv,(toporouter_vertex_t *)(pathv->routingedge->e).segment.v2
                                     ,local_2c,(gdouble)(double)fVar19,local_20,list);
                  g_list_prepend();
                }
              }
              else {
                if (local_a0 != 0) {
LAB_080e6c48:
                  if ((local_3c == (toporouter_arc_t *)0x0) ||
                     (local_50 = local_3c->centre, local_50 != ptVar16)) {
                    if ((local_40 == (toporouter_arc_t *)0x0) || (local_40->centre != ptVar16)) {
                      fVar19 = (float10)check_non_intersect_vertex();
                      if ((float10)0.00010000 < fVar19) {
                        new_rubberband_arc(pathv,(toporouter_vertex_t *)
                                                 (pathv->routingedge->e).segment.v1,local_2c,
                                           (gdouble)(double)fVar19,local_20,list);
                        g_list_prepend();
                        ptVar8 = pathv->routingedge;
                      }
                      else {
                        ptVar8 = pathv->routingedge;
                      }
                    }
                    if (local_3c != (toporouter_arc_t *)0x0) {
                      local_50 = local_3c->centre;
                      goto LAB_080e6d38;
                    }
                    ptVar16 = (toporouter_vertex_t *)(ptVar8->e).segment.v2;
                  }
                  else {
LAB_080e6d38:
                    ptVar16 = (toporouter_vertex_t *)(ptVar8->e).segment.v2;
                    if (ptVar16 == local_50) goto LAB_080e6b68;
                  }
                  if (((local_40 == (toporouter_arc_t *)0x0) || (local_40->centre != ptVar16)) &&
                     (fVar19 = (float10)check_non_intersect_vertex(), (float10)0.00010000 < fVar19))
                  {
                    new_rubberband_arc(pathv,(toporouter_vertex_t *)
                                             (pathv->routingedge->e).segment.v2,local_2c,
                                       (gdouble)(double)fVar19,local_20,list);
                    g_list_prepend();
                  }
                }
              }
LAB_080e6b68:
              list = list->next;
              if ((((list == (GList *)0x0) ||
                   (pathv = (toporouter_vertex_t *)list->data, pathv == local_34)) ||
                  (pathv == local_38)) ||
                 (ptVar8 = pathv->routingedge, ptVar8 == (toporouter_edge_t *)0x0)) {
LAB_080e6f85:
                pptVar10 = (toporouter_vertex_t **)g_list_sort();
                do {
                  if (pptVar10 == (toporouter_vertex_t **)0x0) {
                    return (GList *)0x0;
                  }
                  pathv = *pptVar10;
                  ptVar16 = *(toporouter_vertex_t **)((int)&pathv->v + 0x1c);
                  v1 = *(toporouter_vertex_t **)&pathv->v;
                  ptVar15 = *(toporouter_vertex_t **)((int)&ptVar16->v + 4);
                  local_38 = v1;
                  if (ptVar15 == (toporouter_vertex_t *)0x0) {
                    centre = *(toporouter_vertex_t **)((int)&pathv->v + 4);
                  }
                  else {
                    ptVar8 = (*(toporouter_vertex_t **)&ptVar15->v)->routingedge;
                    if (ptVar8 == (toporouter_edge_t *)0x0) {
                      centre = *(toporouter_vertex_t **)((int)&pathv->v + 4);
                    }
                    else {
                      centre = *(toporouter_vertex_t **)((int)&pathv->v + 4);
                      ptVar6 = *(toporouter_vertex_t **)&ptVar15->v;
                      do {
                        local_50 = ptVar6;
                        if ((centre != (toporouter_vertex_t *)(ptVar8->e).segment.v1) &&
                           (centre != (toporouter_vertex_t *)(ptVar8->e).segment.v2))
                        goto LAB_080e6ff1;
                        ptVar15 = *(toporouter_vertex_t **)((int)&ptVar15->v + 4);
                        if (ptVar15 == (toporouter_vertex_t *)0x0) break;
                        ptVar8 = (*(toporouter_vertex_t **)&ptVar15->v)->routingedge;
                        local_38 = local_50;
                        ptVar6 = *(toporouter_vertex_t **)&ptVar15->v;
                      } while (ptVar8 != (toporouter_edge_t *)0x0);
                      local_38 = local_50;
                    }
                  }
LAB_080e6ff1:
                  ptVar16 = *(toporouter_vertex_t **)((int)&ptVar16->v + 8);
                  if (ptVar16 != (toporouter_vertex_t *)0x0) {
                    ptVar8 = (*(toporouter_vertex_t **)&ptVar16->v)->routingedge;
                    ptVar15 = *(toporouter_vertex_t **)&ptVar16->v;
                    while (((ptVar8 != (toporouter_edge_t *)0x0 &&
                            (((toporouter_vertex_t *)(ptVar8->e).segment.v1 == centre ||
                             ((toporouter_vertex_t *)(ptVar8->e).segment.v2 == centre)))) &&
                           (ptVar16 = *(toporouter_vertex_t **)((int)&ptVar16->v + 8), v1 = ptVar15,
                           ptVar16 != (toporouter_vertex_t *)0x0))) {
                      ptVar8 = (*(toporouter_vertex_t **)&ptVar16->v)->routingedge;
                      ptVar15 = *(toporouter_vertex_t **)&ptVar16->v;
                    }
                  }
                  arc = toporouter_arc_new(oproute,v1,local_38,centre,
                                           *(gdouble *)((int)&pathv->v + 8),
                                           (gint)*(toporouter_vertex_t **)((int)&pathv->v + 0x18));
                  ptVar7 = toporouter_vertex_class();
                  if (ptVar7 == (toporouter_vertex_class_t *)0x0) {
                    g_return_if_fail_warning();
                  }
                  else {
                    if (t1 != (gpointer)0x0) {
                      ptVar18 = *(toporouter_vertex_class_t **)t1;
                      if (ptVar18 == (toporouter_vertex_class_t *)0x0) {
                        g_return_if_fail_warning();
                      }
                      else {
                        do {
                          if (ptVar7 == ptVar18) {
                            calculate_term_to_arc((toporouter_vertex_t *)t1,arc,0);
                            goto LAB_080e7099;
                          }
                          ptVar18 = (toporouter_vertex_class_t *)
                                    (ptVar18->parent_class).parent_class.parent_class.parent_class;
                        } while (ptVar18 != (toporouter_vertex_class_t *)0x0);
                      }
                    }
                  }
                  gVar11 = calculate_arc_to_arc(r,(toporouter_arc_t *)t1,arc);
                  if (gVar11 != 0) {
                    __printf_chk(1,"\tERROR: best:  r = %f d = %f\n",
                                 *(undefined8 *)((int)&pathv->v + 8),
                                 *(undefined8 *)((int)&pathv->v + 0x10));
                    return (GList *)0x0;
                  }
LAB_080e7099:
                  ptVar7 = toporouter_vertex_class();
                  if (ptVar7 == (toporouter_vertex_class_t *)0x0) {
                    g_return_if_fail_warning();
                  }
                  else {
                    if (t2 != (gpointer)0x0) {
                      ptVar18 = *(toporouter_vertex_class_t **)t2;
                      if (ptVar18 == (toporouter_vertex_class_t *)0x0) {
                        g_return_if_fail_warning();
                      }
                      else {
                        do {
                          if (ptVar7 == ptVar18) {
                            calculate_term_to_arc((toporouter_vertex_t *)t2,arc,1);
                            goto LAB_080e70e9;
                          }
                          ptVar18 = (toporouter_vertex_class_t *)
                                    (ptVar18->parent_class).parent_class.parent_class.parent_class;
                        } while (ptVar18 != (toporouter_vertex_class_t *)0x0);
                      }
                    }
                  }
                  gVar11 = calculate_arc_to_arc(r,arc,(toporouter_arc_t *)t2);
                  if (gVar11 != 0) {
                    __printf_chk(1,"\tERROR: best: r = %f d = %f\n",
                                 *(undefined8 *)((int)&pathv->v + 8),
                                 *(undefined8 *)((int)&pathv->v + 0x10));
                    return (GList *)0x0;
                  }
LAB_080e70e9:
                  gVar11 = check_arc_for_loops(t1,arc,t2);
                  if (gVar11 == 0) {
                    local_34 = (toporouter_vertex_t *)
                               oproute_rubberband_segment(r,oproute,path,t1,arc,debug);
                    ptVar21 = arc;
                    list = oproute_rubberband_segment
                                     (r,oproute,
                                      (GList *)*(toporouter_vertex_t **)((int)&ptVar16->v + 4),arc,
                                      t2,debug);
                    if (local_34 != (toporouter_vertex_t *)0x0) {
                      piVar12 = (int *)g_list_last(local_34,oproute);
                      iVar4 = *piVar12;
                      if ((toporouter_arc_t *)piVar12[2] != (toporouter_arc_t *)0x0) {
                        local_3c = *(toporouter_arc_t **)&((toporouter_arc_t *)piVar12[2])->object;
                      }
                      if (local_3c == (toporouter_arc_t *)0x0) {
                        ax = *(gdouble *)((int)t1 + 0xc);
                        ay = *(gdouble *)((int)t1 + 0x14);
                      }
                      else {
                        ax = local_3c->x1;
                        ay = local_3c->y1;
                      }
                      ptVar21 = (toporouter_arc_t *)((ulonglong)ay >> 0x20);
                      gVar13 = coord_intersect_prop
                                         (ax,ay,*(gdouble *)(iVar4 + 0xc),*(gdouble *)(iVar4 + 0x14)
                                          ,*(gdouble *)(iVar4 + 0x1c),*(gdouble *)(iVar4 + 0x24),
                                          arc->x0,arc->y0);
                      if (gVar13 != 0) {
                        local_34 = (toporouter_vertex_t *)g_list_remove();
                        if (local_3c == (toporouter_arc_t *)0x0) {
                          calculate_term_to_arc((toporouter_vertex_t *)t1,arc,0);
                        }
                        else {
                          calculate_arc_to_arc(r,local_3c,arc);
                        }
                      }
                    }
                    if (list != (GList *)0x0) {
                      pvVar9 = list->data;
                      if (list->next != (GList *)0x0) {
                        local_40 = (toporouter_arc_t *)list->next->data;
                      }
                      if (local_40 == (toporouter_arc_t *)0x0) {
                        ax = *(gdouble *)((int)t2 + 0xc);
                        ay = *(gdouble *)((int)t2 + 0x14);
                      }
                      else {
                        ax = local_40->x0;
                        ay = local_40->y0;
                      }
                      ptVar21 = (toporouter_arc_t *)((ulonglong)arc->y1 >> 0x20);
                      gVar13 = coord_intersect_prop
                                         (arc->x1,arc->y1,*(gdouble *)((int)pvVar9 + 0xc),
                                          *(gdouble *)((int)pvVar9 + 0x14),
                                          *(gdouble *)((int)pvVar9 + 0x1c),
                                          *(gdouble *)((int)pvVar9 + 0x24),ax,ay);
                      if (gVar13 != 0) {
                        list = (GList *)g_list_remove();
                        if (local_40 == (toporouter_arc_t *)0x0) {
                          calculate_term_to_arc((toporouter_vertex_t *)t2,arc,1);
                        }
                        else {
                          calculate_arc_to_arc(r,arc,local_40);
                        }
                      }
                    }
                    pcVar20 = free_list_elements;
                    g_list_foreach(pptVar10,free_list_elements,0,ptVar21);
                    g_list_free(pptVar10,pcVar20);
                    uVar14 = g_list_prepend(list,arc);
                    list = (GList *)g_list_concat(local_34,uVar14);
                    return list;
                  }
                  if (local_40 == (toporouter_arc_t *)0x0) {
                    if (local_3c != (toporouter_arc_t *)0x0) {
                      calculate_term_to_arc((toporouter_vertex_t *)t2,local_3c,1);
                    }
                  }
                  else {
                    if (local_3c != (toporouter_arc_t *)0x0) {
                      calculate_arc_to_arc(r,local_3c,local_40);
                    }
                    else {
                      calculate_term_to_arc((toporouter_vertex_t *)t1,local_40,0);
                    }
                  }
                  pptVar10 = (toporouter_vertex_t **)g_list_remove();
                  free(pathv);
                } while( true );
              }
            } while( true );
          }
          ptVar17 = (toporouter_arc_class_t *)(ptVar17->parent_class).parent_class;
        } while (ptVar17 != (toporouter_arc_class_t *)0x0);
      }
    }
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/toporouter.c",0x16d5,"oproute_rubberband_segment","TOPOROUTER_IS_ARC(t2)")
  ;
}



toporouter_oproute_t * oproute_rubberband(toporouter_t *r,GList *path)

{
  double dVar1;
  toporouter_vertex_t *ptVar2;
  _toporouter_cluster_t *p_Var3;
  toporouter_netlist_t *ptVar4;
  char "oproute_rubberband" [19];
  toporouter_oproute_t *oproute;
  toporouter_vertex_t **pptVar5;
  GList *pGVar6;
  _toporouter_bbox_t *p_Var7;
  guint local_2c;
  
  oproute = (toporouter_oproute_t *)calloc(1,0x28);
  if (path != (GList *)0x0) {
    oproute->term1 = (toporouter_vertex_t *)path->data;
    pptVar5 = (toporouter_vertex_t **)g_list_last(path);
    p_Var7 = (_toporouter_bbox_t *)0x0;
    oproute->arcs = (GList *)0x0;
    oproute->term2 = *pptVar5;
    ptVar2 = oproute->term1;
    if (ptVar2 != (toporouter_vertex_t *)0x0) {
      p_Var7 = ptVar2->bbox;
    }
    oproute->style = p_Var7->cluster->netlist->style;
    p_Var7 = (_toporouter_bbox_t *)0x0;
    if (ptVar2 != (toporouter_vertex_t *)0x0) {
      p_Var7 = ptVar2->bbox;
    }
    p_Var3 = p_Var7->cluster;
    dVar1 = (double)(ptVar2->v).p.z;
    oproute->path = path;
    ptVar4 = p_Var3->netlist;
    oproute->serp = (toporouter_serpintine_t *)0x0;
    oproute->netlist = ptVar4->netlist;
    local_2c = (guint)(longlong)ROUND(dVar1);
    ptVar2->parent = (_toporouter_vertex_t *)0x0;
    oproute->layergroup = local_2c;
    oproute->term2->child = (_toporouter_vertex_t *)0x0;
    pGVar6 = path;
    do {
      if ((*(byte *)((int)pGVar6->data + 0x39) & 1) != 0) {
        *(toporouter_oproute_t **)((int)pGVar6->data + 0x54) = oproute;
      }
      pGVar6 = pGVar6->next;
    } while (pGVar6 != (GList *)0x0);
    oproute_path_speccut(oproute);
    pGVar6 = oproute_rubberband_segment(r,oproute,path,oproute->term1,oproute->term2,0);
    oproute->arcs = pGVar6;
    oproute_check_all_loops(r,oproute);
    return oproute;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr(0,"../../src/toporouter.c",0x185b,"oproute_rubberband",0x814868a);
}



// WARNING: Type propagation algorithm not settling

void toporouter_export(toporouter_t *r)

{
  toporouter_oproute_t *oproute;
  GList *pGVar1;
  toporouter_vertex_t *ptVar2;
  
  pGVar1 = r->routednets;
  if (pGVar1 != (GList *)0x0) {
    ptVar2 = (toporouter_vertex_t *)0x0;
    do {
      oproute = oproute_rubberband(r,*(GList **)((int)pGVar1->data + 0x2c));
      ptVar2 = (toporouter_vertex_t *)g_list_prepend(ptVar2,oproute);
      pGVar1 = pGVar1->next;
    } while (pGVar1 != (GList *)0x0);
    while (ptVar2 != (toporouter_vertex_t *)0x0) {
      oproute = *(toporouter_oproute_t **)&ptVar2->v;
      export_oproutes(r,oproute);
      oproute_free(oproute);
      ptVar2 = *(toporouter_vertex_t **)((int)&ptVar2->v + 4);
    }
  }
  Message("Reticulating splines... successful\n\n");
  g_list_free();
  return;
}



void edge_adjacent_vertices
               (toporouter_edge_t *e,toporouter_vertex_t *v,toporouter_vertex_t **v1,
               toporouter_vertex_t **v2)

{
  GtsObjectClass *pGVar1;
  GList *list;
  toporouter_vertex_t *ptVar2;
  toporouter_constraint_class_t *klass;
  GtsObjectClass *pGVar3;
  
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar3 = (e->e).segment.object.klass;
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          if (pGVar1 == pGVar3) break;
          pGVar3 = pGVar3->parent_class;
        } while (pGVar3 != (GtsObjectClass *)0x0);
      }
    }
  }
  list = (GList *)g_list_find(e->routing,v);
  if ((toporouter_vertex_t *)(e->e).segment.v1 == v) {
    *v1 = (toporouter_vertex_t *)0x0;
    klass = toporouter_constraint_class();
    gts_object_is_from_class(e,klass);
    ptVar2 = edge_routing_next_not_temp(e,e->routing);
    *v2 = ptVar2;
  }
  else {
    if ((toporouter_vertex_t *)(e->e).segment.v2 == v) {
      pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar1 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189,"klass != NULL");
      }
      else {
        pGVar3 = (e->e).segment.object.klass;
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,0x8151189,0x8161082);
        }
        else {
          do {
            if (pGVar1 == pGVar3) break;
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
        }
      }
      list = (GList *)g_list_last(e->routing);
      ptVar2 = edge_routing_prev_not_temp(e,list);
      *v1 = ptVar2;
      *v2 = (toporouter_vertex_t *)0x0;
      return;
    }
    ptVar2 = edge_routing_prev_not_temp(e,list);
    *v1 = ptVar2;
    ptVar2 = edge_routing_next_not_temp(e,list);
    *v2 = ptVar2;
  }
  return;
}



toporouter_vertex_t * new_temp_toporoutervertex(gdouble x,gdouble y,toporouter_edge_t *e)

{
  double dVar1;
  GtsVertexClass *klass;
  GtsObjectClass *pGVar2;
  GList *pGVar3;
  toporouter_vertex_t *ptVar4;
  GtsObjectClass *pGVar5;
  char *pcVar6;
  
  klass = (GtsVertexClass *)toporouter_vertex_class();
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    pcVar6 = "klass != NULL";
LAB_080e7cc7:
    g_return_if_fail_warning(0,"gts_object_is_from_class",pcVar6);
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar5 = (e->e).segment.object.klass;
      if (pGVar5 == (GtsObjectClass *)0x0) {
        pcVar6 = "c != NULL";
        goto LAB_080e7cc7;
      }
      do {
        if (pGVar2 == pGVar5) break;
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
  pGVar3 = e->routing;
  if (pGVar3 != (GList *)0x0) {
    do {
      ptVar4 = (toporouter_vertex_t *)pGVar3->data;
      dVar1 = (double)(ptVar4->v).p.x;
      if (((((double)x - 0.00010000 < dVar1) && (dVar1 < (double)x + 0.00010000)) &&
          (dVar1 = (double)(ptVar4->v).p.y, (double)y - 0.00010000 < dVar1)) &&
         ((dVar1 < (double)y + 0.00010000 && (*(char *)&ptVar4->flags < '\0')))) {
        return ptVar4;
      }
      pGVar3 = (GList *)(&pGVar3->data)[1];
    } while (pGVar3 != (GList *)0x0);
  }
  ptVar4 = (toporouter_vertex_t *)gts_vertex_new(klass,x,y,(((e->e).segment.v1)->p).z);
  ptVar4->flags = ptVar4->flags | 0x80;
  ptVar4->routingedge = e;
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    pGVar5 = (e->e).segment.object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    }
    else {
      do {
        if (pGVar2 == pGVar5) {
          pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
          if (pGVar2 == (GtsObjectClass *)0x0) goto LAB_080e7c9c;
          pGVar5 = (e->e).segment.object.klass;
          if (pGVar5 != (GtsObjectClass *)0x0) goto LAB_080e7c02;
          goto LAB_080e7c65;
        }
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
  pGVar2 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
LAB_080e7c9c:
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    pGVar5 = (e->e).segment.object.klass;
    if (pGVar5 == (GtsObjectClass *)0x0) {
LAB_080e7c65:
      g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    }
    else {
      do {
        if (pGVar2 == pGVar5) break;
        pGVar5 = pGVar5->parent_class;
      } while (pGVar5 != (GtsObjectClass *)0x0);
    }
  }
LAB_080e7c06:
  pGVar3 = (GList *)g_list_insert_sorted_with_data(e->routing,ptVar4,routing_edge_insert,e,y._4_4_);
  e->routing = pGVar3;
  return ptVar4;
  while (pGVar5 = pGVar5->parent_class, pGVar5 != (GtsObjectClass *)0x0) {
LAB_080e7c02:
    if (pGVar2 == pGVar5) break;
  }
  goto LAB_080e7c06;
}



// WARNING: Removing unreachable block (ram,0x080e80d0)
// WARNING: Removing unreachable block (ram,0x080e80c4)
// WARNING: Removing unreachable block (ram,0x080e80d4)
// WARNING: Removing unreachable block (ram,0x080e7f10)
// WARNING: Removing unreachable block (ram,0x080e80ee)

GList * candidate_vertices(toporouter_vertex_t *v1,toporouter_vertex_t *v2,toporouter_vertex_t *dest
                          ,toporouter_edge_t *e)

{
  float fVar1;
  float fVar2;
  float fVar3;
  double dVar4;
  char "candidate_vertices" [19];
  GtsObjectClass *pGVar5;
  toporouter_vertex_t *ptVar6;
  undefined4 uVar7;
  GtsObjectClass *pGVar8;
  GList *pGVar9;
  float10 fVar10;
  float10 fVar11;
  float10 fVar12;
  float10 fVar13;
  float10 fVar14;
  float10 fVar15;
  float10 fVar16;
  float10 fVar17;
  float10 fVar18;
  float10 fVar19;
  float10 fVar20;
  float10 fVar21;
  double local_6c;
  gdouble local_4c;
  gdouble local_44;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  if (v1 == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xd0b,0x81512e4,&DAT_08161c26);
  }
  if (v2 == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xd0c,0x81512e4,&DAT_081516f2);
  }
  if (dest == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0xd0d,0x81512e4,0x81518d5);
  }
  if (*(char *)&v1->flags < '\0') {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xd0f,"candidate_vertices",
               "!(v1->flags & VERTEX_FLAG_TEMP)");
  }
  if (*(char *)&v2->flags < '\0') {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xd10,0x81512e4,"!(v2->flags & VERTEX_FLAG_TEMP)");
  }
  fVar10 = (float10)gts_point_distance();
  fVar11 = (float10)vertex_net_thickness();
  fVar12 = (float10)vertex_net_thickness();
  fVar17 = (float10)vertex_net_keepaway();
  fVar13 = (float10)vertex_net_keepaway();
  fVar14 = (float10)(double)fVar17;
  if ((float10)(double)fVar17 <= fVar13) {
    fVar14 = fVar13;
  }
  fVar13 = (float10)vertex_net_thickness();
  fVar15 = (float10)vertex_net_thickness();
  fVar21 = (float10)vertex_net_keepaway();
  fVar16 = (float10)vertex_net_keepaway();
  fVar17 = (float10)(double)fVar21;
  if ((float10)(double)fVar21 <= fVar16) {
    fVar17 = fVar16;
  }
  fVar16 = (float10)vertex_net_thickness();
  fVar18 = (float10)vertex_net_thickness();
  fVar19 = (float10)vertex_net_keepaway();
  fVar20 = (float10)vertex_net_keepaway();
  fVar21 = (float10)(double)fVar19;
  if ((float10)(double)fVar19 <= fVar20) {
    fVar21 = fVar20;
  }
  pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar8 = (e->e).segment.object.klass;
      if (pGVar8 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar5 == pGVar8) {
            local_6c = 0.00000000;
            goto LAB_080e7e5c;
          }
          pGVar8 = pGVar8->parent_class;
        } while (pGVar8 != (GtsObjectClass *)0x0);
      }
    }
  }
  fVar19 = (float10)edge_flow(e,v1,v2,dest);
  local_6c = (double)fVar19;
LAB_080e7e5c:
  pGVar9 = (GList *)0x0;
  fVar19 = (float10)edge_capacity();
  if ((float10)local_6c < fVar19) {
    fVar3 = (float)fVar12 * 0.50000000 + (float)fVar11 * 0.50000000 + (float)fVar14;
    fVar2 = (float)fVar15 * 0.50000000 + (float)fVar13 * 0.50000000 + (float)fVar17;
    fVar1 = (float)fVar18 * 0.50000000 + (float)fVar16 * 0.50000000 + (float)fVar21;
    if ((float)fVar10 <= fVar3 + fVar2 + fVar1) {
      ptVar6 = new_temp_toporoutervertex
                         ((gdouble)(double)(((float)(double)(v1->v).p.x + (float)(double)(v2->v).p.x
                                            ) * 0.50000000),
                          (gdouble)(double)(((float)(double)(v1->v).p.y + (float)(double)(v2->v).p.y
                                            ) * 0.50000000),e);
      pGVar9 = (GList *)g_list_prepend(0,ptVar6);
    }
    else {
      vertex_move_towards_vertex_values
                ((GtsVertex *)v1,(GtsVertex *)v2,(gdouble)(double)fVar3,local_24,&local_2c);
      new_temp_toporoutervertex(local_24[0],local_2c,e);
      uVar7 = g_list_prepend();
      vertex_move_towards_vertex_values
                ((GtsVertex *)v2,(GtsVertex *)v1,(gdouble)(double)fVar2,&local_34,&local_3c);
      ptVar6 = new_temp_toporoutervertex(local_34,local_3c,e);
      pGVar9 = (GList *)g_list_prepend(uVar7,ptVar6);
      dVar4 = SQRT(((double)local_2c - (double)local_3c) * ((double)local_2c - (double)local_3c) +
                   ((double)local_24[0] - (double)local_34) *
                   ((double)local_24[0] - (double)local_34));
      if ((double)fVar1 < dVar4) {
        coord_move_towards_coord_values
                  (local_24[0],local_2c,local_34,local_3c,(gdouble)(dVar4 * 0.50000000),&local_44,
                   &local_4c);
        ptVar6 = new_temp_toporoutervertex(local_44,local_4c,e);
        pGVar9 = (GList *)g_list_prepend(pGVar9,ptVar6);
      }
    }
  }
  return pGVar9;
}



// WARNING: Removing unreachable block (ram,0x080e82ac)

toporouter_vertex_t *
new_temp_toporoutervertex_in_segment
          (toporouter_edge_t *e,toporouter_vertex_t *v,gdouble r,toporouter_vertex_t *ref)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double m;
  double dVar3;
  double dVar4;
  double dVar5;
  toporouter_vertex_t *ptVar6;
  toporouter_spoint_t np2;
  toporouter_spoint_t np1;
  toporouter_spoint_t p;
  
  pGVar1 = (e->e).segment.v2;
  m = (double)(pGVar1->p).x;
  pGVar2 = (e->e).segment.v1;
  dVar3 = (double)(pGVar2->p).x;
  if (m == dVar3) {
    m = INFINITY;
  }
  else {
    m = ((double)(pGVar1->p).y - (double)(pGVar2->p).y) / (m - dVar3);
  }
  p.x = (v->v).p.x;
  p.y = (v->v).p.y;
  vertices_on_line(&p,(gdouble)m,r,&np1,&np2);
  m = (double)np1.x - (double)(ref->v).p.x;
  dVar5 = (double)np1.y - (double)(ref->v).p.y;
  dVar4 = (double)np2.x - (double)(ref->v).p.x;
  dVar3 = (double)np2.y - (double)(ref->v).p.y;
  if (m * m + dVar5 * dVar5 < dVar4 * dVar4 + dVar3 * dVar3) {
    ptVar6 = new_temp_toporoutervertex(np1.x,np1.y,e);
    return ptVar6;
  }
  ptVar6 = new_temp_toporoutervertex(np2.x,np2.y,e);
  return ptVar6;
}



// WARNING: Removing unreachable block (ram,0x080e83e6)
// WARNING: Removing unreachable block (ram,0x080e83e2)

GList * all_candidates_on_edge(toporouter_edge_t *e,toporouter_route_t *routedata)

{
  int *piVar1;
  toporouter_vertex_t *ref;
  double dVar2;
  double dVar3;
  toporouter_vertex_t *v;
  GtsObjectClass *pGVar4;
  GtsObjectClass *pGVar5;
  GList *pGVar6;
  
  pGVar4 = (GtsObjectClass *)toporouter_edge_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning();
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar5 = (e->e).segment.object.klass;
      if (pGVar5 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning();
      }
      else {
        do {
          if (pGVar4 == pGVar5) {
            if ((*(byte *)&e->flags & 1) != 0) {
              return (GList *)0x0;
            }
            break;
          }
          pGVar5 = pGVar5->parent_class;
        } while (pGVar5 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning();
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar5 = (e->e).segment.object.klass;
      if (pGVar5 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning();
      }
      else {
        do {
          if (pGVar4 == pGVar5) {
            if ((((*(int *)(e->flags + 0x40) != 7) &&
                 (piVar1 = *(int **)(e->flags + 0x60), piVar1 != (int *)0x0)) &&
                ((toporouter_netlist_t *)piVar1[3] == routedata->src->netlist)) &&
               ((*piVar1 == routedata->dest->c || (*piVar1 == routedata->src->c)))) {
              v = (toporouter_vertex_t *)(e->e).segment.v1;
              ref = (toporouter_vertex_t *)(e->e).segment.v2;
              dVar2 = (double)(v->v).p.x - (double)(ref->v).p.x;
              dVar3 = (double)(v->v).p.y - (double)(ref->v).p.y;
              new_temp_toporoutervertex_in_segment
                        (e,v,(gdouble)(SQRT(dVar3 * dVar3 + dVar2 * dVar2) * 0.50000000),ref);
              pGVar6 = (GList *)g_list_prepend();
              return pGVar6;
            }
            return (GList *)0x0;
          }
          pGVar5 = pGVar5->parent_class;
        } while (pGVar5 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning();
  }
  else {
    if (e != (toporouter_edge_t *)0x0) {
      pGVar5 = (e->e).segment.object.klass;
      if (pGVar5 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning();
      }
      else {
        do {
          if (pGVar4 == pGVar5) break;
          pGVar5 = pGVar5->parent_class;
        } while (pGVar5 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar6 = e->routing;
  v = (toporouter_vertex_t *)(e->e).segment.v1;
  while (pGVar6 != (GList *)0x0) {
    while (ref = (toporouter_vertex_t *)pGVar6->data, *(char *)&ref->flags < '\0') {
      pGVar6 = (GList *)(&pGVar6->data)[1];
      if (pGVar6 == (GList *)0x0) goto LAB_080e84fa;
    }
    candidate_vertices(v,ref,(toporouter_vertex_t *)routedata->destvertices->data,e);
    g_list_concat();
    pGVar6 = (GList *)(&pGVar6->data)[1];
    v = ref;
  }
LAB_080e84fa:
  candidate_vertices(v,(toporouter_vertex_t *)(e->e).segment.v2,
                     (toporouter_vertex_t *)routedata->destvertices->data,e);
  pGVar6 = (GList *)g_list_concat();
  return pGVar6;
}



GList * triangle_all_candidate_points_from_vertex
                  (GtsTriangle *t,toporouter_vertex_t *v,toporouter_route_t *routedata)

{
  toporouter_edge_t *e;
  GList *pGVar1;
  
  e = (toporouter_edge_t *)gts_triangle_edge_opposite(t,(GtsVertex *)v);
  pGVar1 = all_candidates_on_edge(e,routedata);
  return pGVar1;
}



GList * triangle_candidate_points_from_vertex
                  (GtsTriangle *t,toporouter_vertex_t *v,toporouter_vertex_t *dest,
                  toporouter_route_t *routedata)

{
  toporouter_vertex_t *v2;
  toporouter_vertex_t *ptVar1;
  int iVar2;
  _toporouter_cluster_t *p_Var3;
  toporouter_edge_t *e;
  toporouter_edge_t *e_00;
  toporouter_edge_t *e_01;
  GtsObjectClass *pGVar4;
  GList *pGVar5;
  toporouter_constraint_class_t *klass;
  toporouter_vertex_t *ref;
  GList *pGVar6;
  char *pcVar7;
  toporouter_vertex_t *v2_00;
  GtsObjectClass *pGVar8;
  char *pcVar9;
  float10 fVar10;
  undefined4 local_24;
  toporouter_vertex_t *local_20;
  
  e = (toporouter_edge_t *)gts_triangle_edge_opposite(t,(GtsVertex *)v);
  e_00 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v,(e->e).segment.v1);
  e_01 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v,(e->e).segment.v2);
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class");
  }
  else {
    pGVar8 = (e->e).segment.object.klass;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,0x8151189);
    }
    else {
      do {
        if (pGVar4 == pGVar8) {
          if (*(int *)(e->flags + 0x40) != 7) {
            iVar2 = *(int *)(e->flags + 0x60);
            pcVar9 = (char *)0x0;
            if (iVar2 != 0) {
              pcVar9 = *(char **)(*(int *)(iVar2 + 0xc) + 8);
            }
            if (((dest == (toporouter_vertex_t *)0x0) || (dest->bbox == (_toporouter_bbox_t *)0x0))
               || (p_Var3 = dest->bbox->cluster, p_Var3 == (_toporouter_cluster_t *)0x0)) {
              pcVar7 = (char *)0x0;
            }
            else {
              pcVar7 = p_Var3->netlist->netlist;
            }
            if (pcVar9 == pcVar7) {
              ref = (toporouter_vertex_t *)(e->e).segment.v2;
              fVar10 = (float10)gts_point_distance((e->e).segment.v1,ref);
              local_20 = new_temp_toporoutervertex_in_segment
                                   (e,(toporouter_vertex_t *)(e->e).segment.v1,
                                    (gdouble)(double)(fVar10 * (float10)0.50000000),ref);
              goto LAB_080e8683;
            }
          }
          return (GList *)0x0;
        }
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  local_20 = (toporouter_vertex_t *)0x0;
LAB_080e8683:
  pGVar4 = (GtsObjectClass *)toporouter_edge_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x8151189);
  }
  else {
    pGVar8 = (e->e).segment.object.klass;
    if (pGVar8 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,0x8151189);
    }
    else {
      do {
        if (pGVar4 == pGVar8) {
          if ((*(byte *)&e->flags & 1) != 0) goto triangle_candidate_points_from_vertex_exit;
          break;
        }
        pGVar8 = pGVar8->parent_class;
      } while (pGVar8 != (GtsObjectClass *)0x0);
    }
  }
  if ((toporouter_vertex_t *)(e_00->e).segment.v1 == v) {
    pGVar5 = edge_routing_first_not_temp(e_00);
  }
  else {
    pGVar5 = edge_routing_last_not_temp(e_00);
  }
  if (pGVar5 == (GList *)0x0) {
    ref = (toporouter_vertex_t *)(e->e).segment.v1;
  }
  else {
    v2_00 = (toporouter_vertex_t *)(e->e).segment.v2;
    ref = *(toporouter_vertex_t **)((int)pGVar5->data + 0x2c);
    if (((ref == v2_00) || (v2 = *(toporouter_vertex_t **)((int)pGVar5->data + 0x30), v2_00 == v2))
       || ((ref->routingedge != e && (ref = v2, v2->routingedge != e))))
    goto triangle_candidate_points_from_vertex_exit;
  }
  if ((toporouter_vertex_t *)(e_01->e).segment.v1 == v) {
    pGVar5 = edge_routing_first_not_temp(e_01);
  }
  else {
    pGVar5 = edge_routing_last_not_temp(e_01);
  }
  if (pGVar5 == (GList *)0x0) {
    v2_00 = (toporouter_vertex_t *)(e->e).segment.v2;
  }
  else {
    v2 = (toporouter_vertex_t *)(e->e).segment.v1;
    v2_00 = *(toporouter_vertex_t **)((int)pGVar5->data + 0x2c);
    if (((v2_00 == v2) ||
        (ptVar1 = *(toporouter_vertex_t **)((int)pGVar5->data + 0x30), v2 == ptVar1)) ||
       ((v2_00->routingedge != e && (v2_00 = ptVar1, ptVar1->routingedge != e)))) {
triangle_candidate_points_from_vertex_exit:
      if (local_20 != (toporouter_vertex_t *)0x0) {
        g_hash_table_insert(routedata->alltemppoints,local_20,local_20);
      }
      g_list_free(0);
      return (GList *)0x0;
    }
  }
  if (local_20 != (toporouter_vertex_t *)0x0) {
    pGVar5 = (GList *)g_list_prepend();
    return pGVar5;
  }
  klass = toporouter_constraint_class();
  gts_object_is_from_class(e,klass);
  pGVar5 = e->routing;
  local_24 = 0;
  while (pGVar5 != (GList *)0x0) {
    v2 = (toporouter_vertex_t *)pGVar5->data;
    if ((v2->parent == (_toporouter_vertex_t *)v) || (v2->child == (_toporouter_vertex_t *)v)) {
      pGVar6 = candidate_vertices(ref,v2,dest,e);
      local_24 = g_list_concat(local_24,pGVar6);
      ref = v2;
    }
    pGVar5 = (GList *)(&pGVar5->data)[1];
  }
  candidate_vertices(ref,v2_00,dest,e);
  pGVar5 = (GList *)g_list_concat();
  return pGVar5;
}



// WARNING: Type propagation algorithm not settling

gint space_edge(gpointer item,gpointer data)

{
  double dVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  bool bVar4;
  GtsObjectClass *pGVar5;
  toporouter_constraint_class_t *klass;
  int iVar6;
  double *__ptr;
  GtsVertex *pGVar7;
  GtsObjectClass *pGVar8;
  GtsVertex *pGVar9;
  double *pdVar10;
  float10 fVar11;
  float10 fVar12;
  float10 fVar13;
  float10 fVar14;
  float10 fVar15;
  GtsVertex *v;
  char *local_78;
  double local_4c;
  int local_38;
  
  pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x8151189,"klass != NULL");
  }
  else {
    if (item != (gpointer)0x0) {
      pGVar8 = *(GtsObjectClass **)item;
      if (pGVar8 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          if (pGVar5 == pGVar8) {
            return 0;
          }
          pGVar8 = pGVar8->parent_class;
        } while (pGVar8 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar5 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x8151189,"klass != NULL");
  }
  else {
    if (item != (gpointer)0x0) {
      pGVar8 = *(GtsObjectClass **)item;
      if (pGVar8 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189,0x8161082);
      }
      else {
        do {
          if (pGVar5 == pGVar8) break;
          pGVar8 = pGVar8->parent_class;
        } while (pGVar8 != (GtsObjectClass *)0x0);
      }
    }
  }
  if (*(int *)((int)item + 0x1c) != 0) {
    klass = toporouter_constraint_class();
    gts_object_is_from_class(item,klass);
    iVar6 = g_list_length(*(undefined4 *)((int)item + 0x1c));
    if (iVar6 != 0) {
      klass = toporouter_constraint_class();
      gts_object_is_from_class(item,klass);
      iVar6 = g_list_length(*(undefined4 *)((int)item + 0x1c));
      local_78 = (char *)(iVar6 << 3);
      __ptr = (double *)calloc(1,(size_t)local_78);
      local_38 = 0;
      do {
        pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar5 == (GtsObjectClass *)0x0) {
          local_78 = "gts_object_is_from_class";
          g_return_if_fail_warning(0,0x8151189,"klass != NULL");
        }
        else {
          if (item != (gpointer)0x0) {
            pGVar8 = *(GtsObjectClass **)item;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              local_78 = "gts_object_is_from_class";
              g_return_if_fail_warning(0,0x8151189,0x8161082);
            }
            else {
              do {
                if (pGVar5 == pGVar8) break;
                pGVar8 = pGVar8->parent_class;
              } while (pGVar8 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar9 = *(GtsVertex **)((int)item + 0x1c);
        pdVar10 = __ptr;
        while (pGVar9 != (GtsVertex *)0x0) {
          puVar2 = *(undefined4 **)((int)&pGVar9->p + 8);
          v = *(GtsVertex **)&pGVar9->p;
          if (puVar2 == (undefined4 *)0x0) {
            uVar3 = *(undefined4 *)((int)item + 0xc);
            fVar14 = (float10)vertex_net_thickness(v,local_78);
            fVar11 = (float10)vertex_net_thickness(uVar3);
            fVar12 = (float10)vertex_net_keepaway(v);
            fVar13 = (float10)vertex_net_keepaway(uVar3);
            fVar15 = (float10)(double)fVar12;
            if ((float10)(double)fVar12 <= fVar13) {
              fVar15 = fVar13;
            }
            fVar15 = (float10)0.50000000 * (float10)(double)fVar11 +
                     (float10)(double)fVar14 * (float10)0.50000000 + fVar15;
            fVar14 = (float10)gts_point_distance(*(undefined4 *)((int)item + 0xc),v);
          }
          else {
            uVar3 = *puVar2;
            fVar14 = (float10)vertex_net_thickness(uVar3,local_78);
            fVar11 = (float10)vertex_net_thickness(v);
            fVar12 = (float10)vertex_net_keepaway(uVar3);
            fVar13 = (float10)vertex_net_keepaway(v);
            fVar15 = (float10)(double)fVar12;
            if ((float10)(double)fVar12 <= fVar13) {
              fVar15 = fVar13;
            }
            fVar15 = (float10)0.50000000 * (float10)(double)fVar11 +
                     (float10)(double)fVar14 * (float10)0.50000000 + fVar15;
            fVar14 = (float10)gts_point_distance(**(undefined4 **)((int)&pGVar9->p + 8),v);
          }
          if (fVar14 < (float10)(double)fVar15) {
            pGVar7 = *(GtsVertex **)((int)&pGVar9->p + 4);
            *pdVar10 = (double)((float10)(double)fVar15 - fVar14);
            if (pGVar7 == (GtsVertex *)0x0) goto LAB_080e8b9f;
LAB_080e8a8f:
            uVar3 = *(undefined4 *)&pGVar7->p;
            fVar14 = (float10)vertex_net_thickness(uVar3);
            fVar11 = (float10)vertex_net_thickness(v);
            fVar12 = (float10)vertex_net_keepaway(uVar3);
            fVar13 = (float10)vertex_net_keepaway(v);
            fVar15 = (float10)(double)fVar12;
            if ((float10)(double)fVar12 <= fVar13) {
              fVar15 = fVar13;
            }
            fVar15 = (float10)0.50000000 * (float10)(double)fVar11 +
                     (float10)(double)fVar14 * (float10)0.50000000 + fVar15;
            fVar14 = (float10)gts_point_distance(*(undefined4 *)
                                                  &(*(GtsVertex **)((int)&pGVar9->p + 4))->p);
          }
          else {
            pGVar7 = *(GtsVertex **)((int)&pGVar9->p + 4);
            *pdVar10 = 0.00000000;
            if (pGVar7 != (GtsVertex *)0x0) goto LAB_080e8a8f;
LAB_080e8b9f:
            uVar3 = *(undefined4 *)((int)item + 0x10);
            fVar14 = (float10)vertex_net_thickness(v);
            fVar11 = (float10)vertex_net_thickness(uVar3);
            fVar12 = (float10)vertex_net_keepaway(v);
            fVar13 = (float10)vertex_net_keepaway(uVar3);
            fVar15 = (float10)(double)fVar12;
            if ((float10)(double)fVar12 <= fVar13) {
              fVar15 = fVar13;
            }
            fVar15 = (float10)0.50000000 * (float10)(double)fVar11 +
                     (float10)(double)fVar14 * (float10)0.50000000 + fVar15;
            fVar14 = (float10)gts_point_distance(*(undefined4 *)((int)item + 0x10));
          }
          local_4c = (double)fVar15;
          if (fVar14 < (float10)local_4c) {
            *pdVar10 = (double)((fVar14 - (float10)local_4c) + (float10)*pdVar10);
          }
          pGVar9 = *(GtsVertex **)((int)&pGVar9->p + 4);
          pdVar10 = pdVar10 + 1;
          local_78 = (char *)v;
        }
        pGVar5 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,0x8151189,"klass != NULL");
        }
        else {
          if (item != (gpointer)0x0) {
            pGVar8 = *(GtsObjectClass **)item;
            if (pGVar8 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,0x8151189,0x8161082);
            }
            else {
              do {
                if (pGVar5 == pGVar8) break;
                pGVar8 = pGVar8->parent_class;
              } while (pGVar8 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar9 = *(GtsVertex **)((int)item + 0x1c);
        if (pGVar9 == (GtsVertex *)0x0) {
LAB_080e8d59:
          free(__ptr);
          return 0;
        }
        bVar4 = true;
        pdVar10 = __ptr;
        do {
          dVar1 = *pdVar10;
          v = *(GtsVertex **)&pGVar9->p;
          if ((0.00010000 < dVar1) || (dVar1 < -0.00010000)) {
            bVar4 = false;
          }
          pdVar10 = pdVar10 + 1;
          local_78 = *(char **)((int)item + 0x10);
          vertex_move_towards_vertex_values
                    (v,(GtsVertex *)local_78,(gdouble)(dVar1 * 0.10000000),&(v->p).x,&(v->p).y);
          pGVar9 = *(GtsVertex **)((int)&pGVar9->p + 4);
        } while (pGVar9 != (GtsVertex *)0x0);
        if ((bVar4) || (local_38 = local_38 + 1, local_38 == 100)) goto LAB_080e8d59;
      } while( true );
    }
  }
  return 0;
}



guint check_triangle_interior_capacity
                (GtsTriangle *t,toporouter_vertex_t *v,toporouter_vertex_t *curpoint,
                toporouter_edge_t *op_edge,toporouter_edge_t *adj_edge1,toporouter_edge_t *adj_edge2
                )

{
  GtsObjectClass *pGVar1;
  GtsObjectClass *pGVar2;
  float10 fVar3;
  float10 fVar4;
  
  fVar3 = (float10)triangle_interior_capacity(t,v);
  fVar4 = (float10)flow_from_edge_to_edge(t,adj_edge1,adj_edge2,v,curpoint);
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (adj_edge1 != (toporouter_edge_t *)0x0) {
      pGVar2 = (adj_edge1->e).segment.object.klass;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar1 == pGVar2) {
            return 1;
          }
          pGVar2 = pGVar2->parent_class;
        } while (pGVar2 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar1 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar1 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (adj_edge2 != (toporouter_edge_t *)0x0) {
      pGVar2 = (adj_edge2->e).segment.object.klass;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar1 == pGVar2) {
            return 1;
          }
          pGVar2 = pGVar2->parent_class;
        } while (pGVar2 != (GtsObjectClass *)0x0);
      }
    }
  }
  return (uint)((double)fVar4 <= (double)fVar3);
}



GList * triangle_candidate_points_from_edge
                  (toporouter_t *r,GtsTriangle *t,toporouter_edge_t *e,toporouter_vertex_t *v,
                  toporouter_vertex_t **dest,toporouter_route_t *routedata)

{
  bool bVar1;
  toporouter_vertex_t *ptVar2;
  toporouter_vertex_t *ptVar3;
  int *piVar4;
  GtsVertex *pGVar5;
  _toporouter_vertex_t *p_Var6;
  toporouter_edge_t *ptVar7;
  bool bVar8;
  char "triangle_candidate_points_from_edge" [36];
  _toporouter_vertex_t *v1;
  toporouter_edge_t *e_00;
  toporouter_edge_t *e_01;
  GtsObjectClass *pGVar9;
  guint gVar10;
  undefined4 uVar11;
  toporouter_constraint_class_t *klass;
  int iVar12;
  GList *temppoints;
  toporouter_edge_class_t *klass_00;
  gpointer pvVar13;
  toporouter_vertex_t *ref;
  _toporouter_vertex_t *v1_00;
  GtsObjectClass *pGVar14;
  GList *pGVar15;
  bool bVar16;
  bool bVar17;
  bool bVar18;
  bool bVar19;
  bool bVar20;
  float10 fVar21;
  toporouter_edge_t *v2;
  undefined4 local_5c;
  toporouter_vertex_t *local_48;
  toporouter_vertex_t *local_40;
  toporouter_vertex_t *local_3c;
  GList *local_34;
  toporouter_vertex_t *local_2c;
  toporouter_vertex_t *local_28;
  toporouter_vertex_t *local_24;
  toporouter_vertex_t *local_20 [4];
  
  v1 = (_toporouter_vertex_t *)gts_triangle_vertex_opposite(t,(GtsEdge *)e);
  e_00 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v1,(e->e).segment.v1);
  e_01 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v1,(e->e).segment.v2);
  if (*dest == (toporouter_vertex_t *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0xec6,"triangle_candidate_points_from_edge","*dest");
  }
  v2 = (toporouter_edge_t *)&local_24;
  edge_adjacent_vertices(e,v,local_20,(toporouter_vertex_t **)v2);
  pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar9 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class");
  }
  else {
    if (e_00 != (toporouter_edge_t *)0x0) {
      pGVar14 = (e_00->e).segment.object.klass;
      if (pGVar14 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189);
      }
      else {
        do {
          if (pGVar9 == pGVar14) {
            pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
            if (pGVar9 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,0x8151189);
            }
            else {
              pGVar14 = (e_00->e).segment.object.klass;
              if (pGVar14 != (GtsObjectClass *)0x0) goto LAB_080e9052;
              g_return_if_fail_warning(0,0x8151189);
            }
            goto LAB_080e9056;
          }
          pGVar14 = pGVar14->parent_class;
        } while (pGVar14 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar9 = (GtsObjectClass *)toporouter_edge_class();
  if (pGVar9 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x8151189);
  }
  else {
    if (e_00 != (toporouter_edge_t *)0x0) {
      pGVar14 = (e_00->e).segment.object.klass;
      if (pGVar14 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189);
      }
      else {
        do {
          if (pGVar9 == pGVar14) {
            bVar19 = true;
            if ((*(byte *)&e_00->flags & 1) != 0) goto LAB_080e935b;
            break;
          }
          pGVar14 = pGVar14->parent_class;
        } while (pGVar14 != (GtsObjectClass *)0x0);
      }
    }
  }
  ref = (toporouter_vertex_t *)(e->e).segment.v1;
  if (ref != local_20[0]) {
    v1_00 = local_20[0]->parent;
    if ((v1_00 == v1) || (p_Var6 = local_20[0]->child, p_Var6 == v1)) {
LAB_080e9852:
      bVar20 = false;
      bVar19 = false;
      local_40 = (toporouter_vertex_t *)0x0;
      goto LAB_080e96fb;
    }
    if (v1_00->routingedge == e_00) {
      if ((_toporouter_vertex_t *)(e_00->e).segment.v1 == v1) {
        klass = toporouter_constraint_class();
        gts_object_is_from_class(e_00,klass);
        iVar12 = g_list_find(e_00->routing,v1_00);
        local_3c = edge_routing_prev_not_temp(e_00,*(GList **)(iVar12 + 8));
      }
      else {
        klass = toporouter_constraint_class();
        gts_object_is_from_class(e_00,klass);
        iVar12 = g_list_find(e_00->routing,v1_00);
        local_3c = edge_routing_next_not_temp(e_00,*(GList **)(iVar12 + 4));
      }
LAB_080e9535:
      if (local_3c != (toporouter_vertex_t *)0x0) {
        bVar18 = true;
        p_Var6 = (_toporouter_vertex_t *)(e->e).segment.v2;
        if (local_3c->parent != p_Var6) {
          bVar18 = p_Var6 == local_3c->child;
        }
        v2 = e_00;
        temppoints = candidate_vertices((toporouter_vertex_t *)v1_00,local_3c,*dest,e_00);
        bVar19 = local_3c == (toporouter_vertex_t *)v1;
        ref = local_3c;
        goto LAB_080e9588;
      }
      goto LAB_080e9852;
    }
    bVar19 = false;
    if (p_Var6->routingedge == e_00) {
      v1_00 = p_Var6;
      if ((_toporouter_vertex_t *)(e_00->e).segment.v1 == v1) {
        klass = toporouter_constraint_class();
        gts_object_is_from_class(e_00,klass);
        iVar12 = g_list_find(e_00->routing,p_Var6);
        local_3c = edge_routing_prev_not_temp(e_00,*(GList **)(iVar12 + 8));
      }
      else {
        klass = toporouter_constraint_class();
        gts_object_is_from_class(e_00,klass);
        iVar12 = g_list_find(e_00->routing,p_Var6);
        local_3c = edge_routing_next_not_temp(e_00,*(GList **)(iVar12 + 4));
      }
      goto LAB_080e9535;
    }
LAB_080e935b:
    bVar20 = false;
    temppoints = (GList *)0x0;
    local_5c = 0;
    local_40 = (toporouter_vertex_t *)0x0;
    goto LAB_080e936f;
  }
  edge_adjacent_vertices(e_00,ref,&local_2c,&local_28);
  ref = local_2c;
  if (local_2c == (toporouter_vertex_t *)0x0) {
    ref = local_28;
  }
  v2 = e_00;
  temppoints = candidate_vertices(local_20[0],ref,*dest,e_00);
  if (ref == (toporouter_vertex_t *)v1) {
    bVar19 = true;
    bVar18 = false;
LAB_080e9588:
    if ((ref == (toporouter_vertex_t *)0x0) || (!bVar19)) goto triangle_candidate_points_e2;
    if (v1->bbox == (_toporouter_bbox_t *)0x0) {
      local_3c = (toporouter_vertex_t *)0x0;
    }
    else {
      local_3c = (toporouter_vertex_t *)v1->bbox->point;
    }
    iVar12 = g_list_find(routedata->destvertices,ref);
    if (iVar12 == 0) {
      iVar12 = g_list_find(routedata->destvertices,local_3c);
      if (iVar12 == 0) {
        iVar12 = g_list_find(routedata->srcvertices,ref);
        if (iVar12 == 0) goto triangle_candidate_points_e2;
        local_5c = g_list_prepend(0,ref);
        bVar20 = false;
        bVar19 = false;
        local_40 = (toporouter_vertex_t *)0x0;
      }
      else {
        bVar20 = false;
        bVar19 = false;
        local_5c = 0;
        *dest = local_3c;
        local_40 = (toporouter_vertex_t *)0x0;
      }
    }
    else {
      local_5c = g_list_prepend(0,ref);
      bVar20 = false;
      bVar19 = false;
      local_40 = (toporouter_vertex_t *)0x0;
      *dest = ref;
    }
  }
  else {
    v1_00 = (_toporouter_vertex_t *)(e->e).segment.v2;
    bVar18 = true;
    if (ref->parent != v1_00) {
      bVar18 = v1_00 == ref->child;
    }
triangle_candidate_points_e2:
    bVar20 = false;
    bVar19 = false;
    local_5c = 0;
    local_40 = (toporouter_vertex_t *)0x0;
  }
LAB_080e90ce:
  if (!bVar18) {
    bVar20 = local_40 != (toporouter_vertex_t *)0x0;
    goto LAB_080e936f;
  }
  bVar16 = local_40 != (toporouter_vertex_t *)0x0;
  bVar18 = !bVar19;
LAB_080e90e7:
  bVar16 = (bool)(bVar16 & bVar18);
  bVar1 = false;
  bVar17 = false;
  bVar18 = true;
  local_34 = (GList *)0x0;
  local_48 = (toporouter_vertex_t *)0x0;
  bVar8 = true;
  goto LAB_080e910e;
  while (pGVar14 = pGVar14->parent_class, pGVar14 != (GtsObjectClass *)0x0) {
LAB_080e9052:
    if (pGVar9 == pGVar14) break;
  }
LAB_080e9056:
  temppoints = e_00->routing;
  if ((((*(int *)(e_00->flags + 0x40) == 7) ||
       (piVar4 = *(int **)(e_00->flags + 0x60), piVar4 == (int *)0x0)) ||
      ((toporouter_netlist_t *)piVar4[3] != routedata->src->netlist)) ||
     ((*piVar4 != routedata->dest->c && (*piVar4 != routedata->src->c)))) {
    bVar19 = true;
    local_40 = (toporouter_vertex_t *)0x0;
  }
  else {
    if ((((toporouter_vertex_t *)(e->e).segment.v1 == local_20[0]) ||
        ((ptVar7 = local_20[0]->parent->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
         (e_00 == ptVar7)))) ||
       ((ptVar7 = local_20[0]->child->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
        (e_00 == ptVar7)))) {
      ref = (toporouter_vertex_t *)(e_00->e).segment.v2;
      fVar21 = (float10)gts_point_distance((e_00->e).segment.v1,ref);
      v2 = (toporouter_edge_t *)((ulonglong)(double)(fVar21 * (float10)0.50000000) >> 0x20);
      local_40 = new_temp_toporoutervertex_in_segment
                           (e_00,(toporouter_vertex_t *)(e_00->e).segment.v1,
                            (gdouble)(double)(fVar21 * (float10)0.50000000),ref);
      bVar19 = false;
    }
    else {
      bVar19 = false;
      local_40 = (toporouter_vertex_t *)0x0;
    }
  }
  if (temppoints != (GList *)0x0) {
    pGVar5 = (e->e).segment.v2;
    bVar18 = false;
    do {
      while ((pvVar13 = temppoints->data, *(GtsVertex **)((int)pvVar13 + 0x30) == pGVar5 ||
             (*(GtsVertex **)((int)pvVar13 + 0x2c) == pGVar5))) {
        temppoints = temppoints->next;
        if (-1 < *(char *)((int)pvVar13 + 0x38)) {
          bVar18 = true;
        }
        if (temppoints == (GList *)0x0) goto LAB_080e90be;
      }
      temppoints = temppoints->next;
    } while (temppoints != (GList *)0x0);
LAB_080e90be:
    local_5c = 0;
    bVar20 = local_40 != (toporouter_vertex_t *)0x0;
    goto LAB_080e90ce;
  }
  bVar20 = local_40 != (toporouter_vertex_t *)0x0;
LAB_080e96fb:
  local_5c = 0;
  temppoints = (GList *)0x0;
LAB_080e936f:
  pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar9 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x8151189);
  }
  else {
    if (e_01 != (toporouter_edge_t *)0x0) {
      pGVar14 = (e_01->e).segment.object.klass;
      if (pGVar14 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,0x8151189);
      }
      else {
        do {
          if (pGVar9 == pGVar14) {
            pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
            if (pGVar9 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,0x8151189);
            }
            else {
              pGVar14 = (e_01->e).segment.object.klass;
              if (pGVar14 != (GtsObjectClass *)0x0) goto LAB_080e93cf;
              g_return_if_fail_warning(0,0x8151189);
            }
            goto LAB_080e93d3;
          }
          pGVar14 = pGVar14->parent_class;
        } while (pGVar14 != (GtsObjectClass *)0x0);
      }
    }
  }
  klass_00 = toporouter_edge_class();
  pvVar13 = gts_object_is_from_class(e_01,klass_00);
  if ((pvVar13 != (gpointer)0x0) && ((*(byte *)&e_01->flags & 1) != 0)) {
    bVar16 = !bVar19;
    bVar18 = local_40 != (toporouter_vertex_t *)0x0;
    goto LAB_080e90e7;
  }
  bVar8 = bVar19;
  if ((toporouter_vertex_t *)(e->e).segment.v2 == local_24) {
    local_28 = (toporouter_vertex_t *)0x0;
    local_2c = (toporouter_vertex_t *)0x0;
    edge_adjacent_vertices(e_01,local_24,&local_28,&local_2c);
    ref = local_28;
    if (local_28 == (toporouter_vertex_t *)0x0) {
      ref = local_2c;
    }
    v2 = e_01;
    local_34 = candidate_vertices(local_24,ref,*dest,e_01);
    if (ref == (toporouter_vertex_t *)v1) {
      bVar1 = false;
      bVar17 = false;
      bVar18 = false;
      local_48 = (toporouter_vertex_t *)0x0;
      bVar16 = local_40 != (toporouter_vertex_t *)0x0 && !bVar19;
    }
    else {
      v1 = (_toporouter_vertex_t *)(e->e).segment.v1;
      if ((ref->parent == v1) || (v1 == ref->child)) {
        bVar1 = false;
        bVar17 = false;
        bVar16 = false;
        bVar18 = false;
        bVar19 = true;
        local_48 = (toporouter_vertex_t *)0x0;
        bVar8 = true;
      }
      else {
        bVar1 = false;
        bVar17 = false;
        bVar18 = false;
        bVar16 = local_40 != (toporouter_vertex_t *)0x0 && !bVar19;
        local_48 = (toporouter_vertex_t *)0x0;
      }
    }
  }
  else {
    v1_00 = local_24->parent;
    if ((v1_00 == v1) || (p_Var6 = local_24->child, p_Var6 == v1)) {
      bVar16 = !bVar19 && local_40 != (toporouter_vertex_t *)0x0;
    }
    else {
      if (v1_00->routingedge == e_01) {
        if ((_toporouter_vertex_t *)(e_01->e).segment.v1 == v1) {
          klass = toporouter_constraint_class();
          gts_object_is_from_class(e_01,klass);
          iVar12 = g_list_find(e_01->routing,v1_00);
          ref = edge_routing_prev_not_temp(e_01,*(GList **)(iVar12 + 8));
        }
        else {
          klass = toporouter_constraint_class();
          gts_object_is_from_class(e_01,klass);
          iVar12 = g_list_find(e_01->routing,v1_00);
          ref = edge_routing_next_not_temp(e_01,*(GList **)(iVar12 + 4));
        }
      }
      else {
        if (p_Var6->routingedge != e_01) {
          bVar16 = !bVar19 && local_40 != (toporouter_vertex_t *)0x0;
          goto LAB_080e99c4;
        }
        v1_00 = p_Var6;
        if ((_toporouter_vertex_t *)(e_01->e).segment.v1 == v1) {
          klass = toporouter_constraint_class();
          gts_object_is_from_class(e_01,klass);
          iVar12 = g_list_find(e_01->routing,p_Var6);
          ref = edge_routing_prev_not_temp(e_01,*(GList **)(iVar12 + 8));
        }
        else {
          klass = toporouter_constraint_class();
          gts_object_is_from_class(e_01,klass);
          iVar12 = g_list_find(e_01->routing,p_Var6);
          ref = edge_routing_next_not_temp(e_01,*(GList **)(iVar12 + 4));
        }
      }
      if (ref != (toporouter_vertex_t *)0x0) {
        v1 = (_toporouter_vertex_t *)(e->e).segment.v1;
        if ((ref->parent == v1) || (v1 == ref->child)) {
          bVar19 = true;
        }
        v2 = e_01;
        local_34 = candidate_vertices((toporouter_vertex_t *)v1_00,ref,*dest,e_01);
        bVar1 = false;
        bVar17 = false;
        bVar18 = false;
        bVar16 = !bVar19 && local_40 != (toporouter_vertex_t *)0x0;
        local_48 = (toporouter_vertex_t *)0x0;
        bVar8 = bVar19;
        goto LAB_080e910e;
      }
      bVar16 = !bVar19 && local_40 != (toporouter_vertex_t *)0x0;
    }
LAB_080e99c4:
    bVar1 = false;
    bVar17 = false;
    bVar18 = false;
    local_34 = (GList *)0x0;
    local_48 = (toporouter_vertex_t *)0x0;
  }
  goto LAB_080e910e;
  while (pGVar14 = pGVar14->parent_class, pGVar14 != (GtsObjectClass *)0x0) {
LAB_080e93cf:
    if (pGVar9 == pGVar14) break;
  }
LAB_080e93d3:
  pGVar15 = e_01->routing;
  if (((*(int *)(e_01->flags + 0x40) == 7) ||
      (piVar4 = *(int **)(e_01->flags + 0x60), piVar4 == (int *)0x0)) ||
     ((toporouter_netlist_t *)piVar4[3] != routedata->src->netlist)) {
LAB_080e9404:
    bVar18 = true;
    local_48 = (toporouter_vertex_t *)0x0;
  }
  else {
    if ((*piVar4 != routedata->dest->c) && (*piVar4 != routedata->src->c)) goto LAB_080e9404;
    if ((((toporouter_vertex_t *)(e->e).segment.v2 == local_24) ||
        ((ptVar7 = local_24->parent->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
         (e_01 == ptVar7)))) ||
       ((ptVar7 = local_24->child->routingedge, ptVar7 != (toporouter_edge_t *)0x0 &&
        (e_01 == ptVar7)))) {
      ref = (toporouter_vertex_t *)(e_01->e).segment.v2;
      fVar21 = (float10)gts_point_distance((e_01->e).segment.v1,ref);
      v2 = (toporouter_edge_t *)((ulonglong)(double)(fVar21 * (float10)0.50000000) >> 0x20);
      local_48 = new_temp_toporoutervertex_in_segment
                           (e_01,(toporouter_vertex_t *)(e_01->e).segment.v1,
                            (gdouble)(double)(fVar21 * (float10)0.50000000),ref);
      bVar18 = false;
    }
    else {
      bVar18 = false;
      local_48 = (toporouter_vertex_t *)0x0;
    }
  }
  if (pGVar15 == (GList *)0x0) {
    local_34 = (GList *)0x0;
    bVar16 = local_40 != (toporouter_vertex_t *)0x0 && !bVar19;
    bVar17 = local_48 != (toporouter_vertex_t *)0x0;
    bVar8 = (bool)(bVar18 | bVar19);
    bVar1 = !bVar18 && bVar17;
  }
  else {
    pGVar5 = (e->e).segment.v1;
    do {
      while ((pvVar13 = pGVar15->data, *(GtsVertex **)((int)pvVar13 + 0x30) == pGVar5 ||
             (*(GtsVertex **)((int)pvVar13 + 0x2c) == pGVar5))) {
        pGVar15 = pGVar15->next;
        bVar1 = true;
        if (*(char *)((int)pvVar13 + 0x38) < '\0') {
          bVar1 = bVar19;
        }
        bVar19 = bVar1;
        if (pGVar15 == (GList *)0x0) goto LAB_080e9452;
      }
      pGVar15 = pGVar15->next;
    } while (pGVar15 != (GList *)0x0);
LAB_080e9452:
    local_34 = (GList *)0x0;
    bVar16 = !bVar19 && local_40 != (toporouter_vertex_t *)0x0;
    bVar17 = local_48 != (toporouter_vertex_t *)0x0;
    bVar8 = (bool)(bVar19 | bVar18);
    bVar1 = !bVar18 && bVar17;
  }
LAB_080e910e:
  if (e_00 == (toporouter_edge_t *)0x0) {
LAB_080e913b:
    local_20[0] = (toporouter_vertex_t *)0x0;
  }
  else {
    ref = (toporouter_vertex_t *)(e->e).segment.v1;
    ptVar2 = (toporouter_vertex_t *)(e_00->e).segment.v1;
    local_20[0] = ref;
    if ((((ref != ptVar2) &&
         (ptVar3 = (toporouter_vertex_t *)(e->e).segment.v2, local_20[0] = ptVar2, ptVar2 != ptVar3)
         ) && (ptVar2 = (toporouter_vertex_t *)(e_00->e).segment.v2, local_20[0] = ref,
              ref != ptVar2)) && (local_20[0] = ptVar3, ptVar3 != ptVar2)) goto LAB_080e913b;
  }
  if (e_01 == (toporouter_edge_t *)0x0) {
LAB_080e9180:
    local_24 = (toporouter_vertex_t *)0x0;
  }
  else {
    ref = (toporouter_vertex_t *)(e->e).segment.v1;
    ptVar2 = (toporouter_vertex_t *)(e_01->e).segment.v1;
    local_24 = ref;
    if (ref != ptVar2) {
      ptVar3 = (toporouter_vertex_t *)(e->e).segment.v2;
      local_24 = ptVar2;
      if (((ptVar2 != ptVar3) &&
          (ptVar2 = (toporouter_vertex_t *)(e_01->e).segment.v2, local_24 = ref, ref != ptVar2)) &&
         (local_24 = ptVar3, ptVar3 != ptVar2)) goto LAB_080e9180;
    }
  }
  if (bVar19) {
LAB_080e91b5:
    routedata_insert_temppoints(routedata,temppoints);
    pGVar15 = (GList *)0x0;
    g_list_free(temppoints);
  }
  else {
    v2 = e_01;
    gVar10 = check_triangle_interior_capacity(t,local_20[0],v,e_01,e,e_00);
    pGVar15 = temppoints;
    if (gVar10 == 0) goto LAB_080e91b5;
  }
  if (!bVar18) {
    v2 = e_00;
    gVar10 = check_triangle_interior_capacity(t,local_24,v,e_00,e,e_01);
    if (gVar10 != 0) goto LAB_080e9225;
  }
  routedata_insert_temppoints(routedata,local_34);
  g_list_free(local_34);
  local_34 = (GList *)0x0;
LAB_080e9225:
  if (bVar16) {
    pGVar15 = (GList *)g_list_prepend(pGVar15,local_40);
  }
  else {
    if (bVar20) {
      g_hash_table_insert(routedata->alltemppoints,local_40,local_40,v2);
    }
  }
  if (bVar1) {
    local_34 = (GList *)g_list_prepend(local_34,local_48);
  }
  else {
    if (bVar17) {
      g_hash_table_insert(routedata->alltemppoints,local_48,local_48,v2);
    }
  }
  if (bVar8) {
    temppoints = (GList *)g_list_concat(pGVar15,local_34);
    return temppoints;
  }
  uVar11 = g_list_concat(pGVar15,local_34);
  temppoints = (GList *)g_list_concat(local_5c,uVar11);
  return temppoints;
}



GList * triangle_all_candidate_points_from_edge
                  (toporouter_t *r,GtsTriangle *t,toporouter_edge_t *e,toporouter_route_t *routedata
                  ,toporouter_vertex_t **dest,toporouter_vertex_t *curpoint)

{
  gpointer pvVar1;
  GList *pGVar2;
  toporouter_vertex_t *v1;
  int iVar3;
  toporouter_edge_t *e_00;
  toporouter_edge_t *e_01;
  GList *pGVar4;
  GList *pGVar5;
  guint gVar6;
  guint gVar7;
  toporouter_edge_t *ptVar8;
  GtsObjectClass *pGVar9;
  GtsObjectClass *pGVar10;
  undefined4 uVar11;
  toporouter_vertex_t *ptVar12;
  char *local_54;
  GList *local_20;
  
  v1 = (toporouter_vertex_t *)gts_triangle_vertex_opposite(t,(GtsEdge *)e);
  if ((v1 == (toporouter_vertex_t *)0x0) ||
     (pGVar9 = (((GtsPoint *)&v1->bbox)->object).klass, pGVar9 == (GtsObjectClass *)0x0)) {
    ptVar12 = (toporouter_vertex_t *)0x0;
  }
  else {
    ptVar12 = (toporouter_vertex_t *)pGVar9->attributes;
  }
  iVar3 = g_list_find(routedata->destvertices,v1);
  if (iVar3 != 0) {
    pGVar4 = (GList *)g_list_prepend(0,v1);
    *dest = v1;
    return pGVar4;
  }
  iVar3 = g_list_find(routedata->destvertices,ptVar12);
  if (iVar3 == 0) {
    iVar3 = g_list_find(routedata->srcvertices,v1);
    uVar11 = 0;
    if (iVar3 != 0) {
      uVar11 = g_list_prepend(0,v1);
    }
  }
  else {
    uVar11 = 0;
    *dest = ptVar12;
  }
  e_00 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v1,(e->e).segment.v1);
  e_01 = (toporouter_edge_t *)gts_vertices_are_connected((GtsVertex *)v1,(e->e).segment.v2);
  pGVar4 = all_candidates_on_edge(e_00,routedata);
  uVar11 = g_list_concat(uVar11,pGVar4);
  pGVar4 = all_candidates_on_edge(e_01,routedata);
  pGVar5 = (GList *)g_list_concat(uVar11,pGVar4);
  gVar6 = check_triangle_interior_capacity
                    (t,(toporouter_vertex_t *)(e->e).segment.v1,curpoint,e_01,e,e_00);
  gVar7 = check_triangle_interior_capacity
                    (t,(toporouter_vertex_t *)(e->e).segment.v2,curpoint,e_00,e,e_01);
  local_20 = (GList *)0x0;
  pGVar4 = pGVar5;
  pGVar2 = pGVar5;
  do {
    if (pGVar4 == (GList *)0x0) {
      g_list_free(pGVar5);
      return pGVar2;
    }
    pvVar1 = pGVar4->data;
    ptVar8 = *(toporouter_edge_t **)((int)pvVar1 + 0x34);
    if (ptVar8 == (toporouter_edge_t *)0x0) {
LAB_080ea028:
      local_20 = (GList *)g_list_prepend(local_20,pvVar1);
    }
    else {
      if (e_00 == ptVar8) {
        pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar9 == (GtsObjectClass *)0x0) {
          local_54 = "klass != NULL";
LAB_080ea0d7:
          g_return_if_fail_warning(0,"gts_object_is_from_class",local_54);
        }
        else {
          pGVar10 = (e_00->e).segment.object.klass;
          if (pGVar10 == (GtsObjectClass *)0x0) {
            local_54 = "c != NULL";
            goto LAB_080ea0d7;
          }
          do {
            if (pGVar9 == pGVar10) goto LAB_080ea028;
            pGVar10 = pGVar10->parent_class;
          } while (pGVar10 != (GtsObjectClass *)0x0);
        }
        if (gVar6 != 0) goto LAB_080ea028;
        ptVar8 = *(toporouter_edge_t **)((int)pvVar1 + 0x34);
      }
      if (e_01 == ptVar8) {
        pGVar9 = (GtsObjectClass *)toporouter_constraint_class();
        if (pGVar9 == (GtsObjectClass *)0x0) {
          local_54 = "klass != NULL";
LAB_080ea002:
          g_return_if_fail_warning(0,"gts_object_is_from_class",local_54);
        }
        else {
          if (e_01 != (toporouter_edge_t *)0x0) {
            pGVar10 = (e_01->e).segment.object.klass;
            if (pGVar10 == (GtsObjectClass *)0x0) {
              local_54 = "c != NULL";
              goto LAB_080ea002;
            }
            do {
              if (pGVar9 == pGVar10) goto LAB_080ea028;
              pGVar10 = pGVar10->parent_class;
            } while (pGVar10 != (GtsObjectClass *)0x0);
          }
        }
        if (gVar7 != 0) goto LAB_080ea028;
      }
    }
    pGVar4 = pGVar4->next;
    pGVar2 = local_20;
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x080ea4a4)

GList * compute_candidate_points
                  (toporouter_t *tr,toporouter_layer_t *l,toporouter_vertex_t *curpoint,
                  toporouter_route_t *data,toporouter_vertex_t **closestdest)

{
  gpointer *ppvVar1;
  double dVar2;
  double dVar3;
  toporouter_edge_t *e;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GSList *pGVar6;
  gpointer pvVar7;
  GList *pGVar8;
  GtsSegment *pGVar9;
  GtsObjectClass *pGVar10;
  GList *pGVar11;
  GList *temppoints;
  int iVar12;
  GtsVertex *pGVar13;
  int iVar14;
  GtsObjectClass *pGVar15;
  GList *pGVar16;
  char *local_54;
  GList *local_20;
  
  temppoints = tr->keepoutlayers;
  e = curpoint->routingedge;
  if (temppoints == (GList *)0x0) {
LAB_080ea1ab:
    pGVar9 = gts_vertices_are_connected((GtsVertex *)curpoint,(GtsVertex *)*closestdest);
    if (pGVar9 != (GtsSegment *)0x0) {
      pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
      if (pGVar10 == (GtsObjectClass *)0x0) {
        local_54 = "klass != NULL";
LAB_080ea453:
        g_return_if_fail_warning(0,"gts_object_is_from_class",local_54);
      }
      else {
        pGVar15 = (pGVar9->object).klass;
        if (pGVar15 == (GtsObjectClass *)0x0) {
          local_54 = "c != NULL";
          goto LAB_080ea453;
        }
        do {
          if (pGVar10 == pGVar15) goto compute_candidate_points_finish;
          pGVar15 = pGVar15->parent_class;
        } while (pGVar15 != (GtsObjectClass *)0x0);
      }
      if (pGVar9[1].object.flags == 0) {
        temppoints = (GList *)g_list_prepend(0,*closestdest);
        ppvVar1 = &pGVar9[1].object.reserved;
        *ppvVar1 = (gpointer)((uint)*ppvVar1 | 1);
        goto LAB_080ea20a;
      }
    }
    if (-1 < *(char *)&curpoint->flags) {
      pGVar16 = (GList *)0x0;
      pGVar11 = (GList *)gts_vertex_triangles((GtsVertex *)curpoint,(GSList *)0x0);
      pGVar8 = pGVar11;
      temppoints = pGVar11;
      while (pGVar8 != (GList *)0x0) {
        if ((*(byte *)&tr->flags & 0x20) == 0) {
          temppoints = triangle_candidate_points_from_vertex
                                 ((GtsTriangle *)pGVar8->data,curpoint,*closestdest,data);
        }
        else {
          temppoints = triangle_all_candidate_points_from_vertex
                                 ((GtsTriangle *)pGVar8->data,curpoint,data);
        }
        routedata_insert_temppoints(data,temppoints);
        pGVar16 = (GList *)g_list_concat(pGVar16,temppoints);
        pGVar8 = (GList *)(&pGVar8->data)[1];
        temppoints = pGVar16;
      }
      g_slist_free(pGVar11);
      goto LAB_080ea20a;
    }
    pGVar4 = (e->e).segment.v2;
    pGVar5 = (e->e).segment.v1;
    dVar2 = (double)(pGVar4->p).x;
    dVar3 = (double)(pGVar4->p).y;
    iVar12 = 1;
    dVar2 = ((double)(curpoint->parent->v).p.y - dVar3) * (dVar2 - (double)(pGVar5->p).x) -
            ((double)(curpoint->parent->v).p.x - dVar2) * (dVar3 - (double)(pGVar5->p).y);
    if (dVar2 <= 0.00010000) {
      iVar12 = (uint)(-0.00010000 <= dVar2) - 1;
    }
    pGVar6 = (e->e).triangles;
    while (pGVar6 != (GSList *)0x0) {
      pGVar13 = gts_triangle_vertex_opposite((GtsTriangle *)pGVar6->data,(GtsEdge *)e);
      pGVar4 = (e->e).segment.v2;
      pGVar5 = (e->e).segment.v1;
      dVar2 = (double)(pGVar4->p).x;
      dVar3 = (double)(pGVar4->p).y;
      iVar14 = 1;
      dVar2 = ((double)(pGVar13->p).y - dVar3) * (dVar2 - (double)(pGVar5->p).x) -
              ((double)(pGVar13->p).x - dVar2) * (dVar3 - (double)(pGVar5->p).y);
      if (dVar2 <= 0.00010000) {
        iVar14 = (uint)(-0.00010000 <= dVar2) - 1;
      }
      if (iVar12 != iVar14) {
        if ((*(byte *)&tr->flags & 0x20) == 0) {
          temppoints = triangle_candidate_points_from_edge
                                 (tr,(GtsTriangle *)pGVar6->data,e,curpoint,closestdest,data);
          local_20 = temppoints;
        }
        else {
          temppoints = triangle_all_candidate_points_from_edge
                                 (tr,(GtsTriangle *)pGVar6->data,e,data,closestdest,curpoint);
          local_20 = temppoints;
        }
        while (temppoints != (GList *)0x0) {
          pvVar7 = temppoints->data;
          if (*(char *)((int)pvVar7 + 0x38) < '\0') {
            g_hash_table_insert(data->alltemppoints,pvVar7,pvVar7);
          }
          temppoints = temppoints->next;
        }
        temppoints = (GList *)g_list_concat(0,local_20);
        goto LAB_080ea20a;
      }
      pGVar6 = pGVar6->next;
    }
  }
  else {
    dVar2 = *(double *)temppoints->data;
    while (dVar2 != (double)(curpoint->v).p.z) {
      temppoints = temppoints->next;
      if (temppoints == (GList *)0x0) goto LAB_080ea1ab;
      dVar2 = *(double *)temppoints->data;
    }
  }
compute_candidate_points_finish:
  temppoints = (GList *)0x0;
LAB_080ea20a:
  if ((curpoint->bbox != (_toporouter_bbox_t *)0x0) && (curpoint->bbox->cluster->c == data->src->c))
  {
    g_list_copy(data->srcvertices);
    temppoints = (GList *)g_list_concat();
    return temppoints;
  }
  return temppoints;
}



// WARNING: Type propagation algorithm not settling

GList * route(toporouter_t *r,toporouter_route_t *data,guint debug)

{
  double dVar1;
  _toporouter_vertex_t *p;
  _toporouter_cluster_t *p_Var2;
  gpointer pvVar3;
  uint uVar4;
  _toporouter_vertex_t *p_Var5;
  char "route" [6];
  GtsEHeap *heap;
  GList *src_vertices;
  GHashTable *pGVar6;
  guint gVar7;
  int iVar8;
  GList *pGVar9;
  toporouter_vertex_t *local_84;
  GtsObjectClass *pGVar10;
  gpointer pvVar11;
  GtsObjectClass *item;
  GtsObjectClass *pGVar12;
  _toporouter_vertex_t *local_7c;
  toporouter_vertex_t *ptVar13;
  undefined4 uVar14;
  bool bVar15;
  float10 fVar16;
  _toporouter_vertex_t *local_80;
  toporouter_layer_t *local_50;
  toporouter_vertex_t *local_48;
  toporouter_heap_search_data_t heap_search_data;
  guint local_28;
  toporouter_vertex_t *local_24;
  toporouter_vertex_t *local_20 [4];
  
  heap = gts_eheap_new(route_heap_cmp,(gpointer)0x0);
  local_20[0] = (toporouter_vertex_t *)0x0;
  local_24 = (toporouter_vertex_t *)0x0;
  if (data->src->c == data->dest->c) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x11a7,"route","data->src->c != data->dest->c");
  }
  if (data->destvertices != (GList *)0x0) {
    g_list_free(data->destvertices);
  }
  if (data->srcvertices != (GList *)0x0) {
    g_list_free(data->srcvertices);
  }
  src_vertices = cluster_vertices(r,(toporouter_cluster_t *)data->dest);
  data->destvertices = src_vertices;
  src_vertices = cluster_vertices(r,(toporouter_cluster_t *)data->src);
  data->srcvertices = src_vertices;
  closest_cluster_pair(r,src_vertices,data->destvertices,&local_24,local_20);
  ptVar13 = local_24;
  if ((local_24 == (toporouter_vertex_t *)0x0) || (local_20[0] == (toporouter_vertex_t *)0x0)) {
    local_48 = (toporouter_vertex_t *)0x0;
    uVar14 = 0;
  }
  else {
    uVar14 = 0;
    local_50 = r->layers + (int)ROUND((double)(local_24->v).p.z);
    data->path = (GList *)0x0;
    pGVar6 = (GHashTable *)g_hash_table_new(g_direct_hash,g_direct_equal);
    local_84 = local_24;
    local_24->parent = (_toporouter_vertex_t *)0x0;
    data->alltemppoints = pGVar6;
    local_24->child = (_toporouter_vertex_t *)0x0;
    local_24->gcost = 0.00000000;
    local_24->gn = 0;
    fVar16 = (float10)simple_h_cost(r,local_24,local_20[0]);
    *(double *)&local_84->hcost = (double)fVar16;
    gts_eheap_insert(heap,local_24);
    gVar7 = gts_eheap_size(heap);
    while (gVar7 != 0) {
      data->curpoint = local_24;
      local_24 = (toporouter_vertex_t *)gts_eheap_remove_top(heap,(gdouble *)0x0);
      if (((local_24->parent != (_toporouter_vertex_t *)0x0) && (-1 < *(char *)&local_24->flags)) &&
         (dVar1 = (double)(local_24->v).p.z, dVar1 != (double)(local_20[0]->v).p.z)) {
        local_50 = r->layers + (int)ROUND(dVar1);
        local_84 = closest_dest_vertex(r,local_24,data);
        if (local_84 != (toporouter_vertex_t *)0x0) {
          local_20[0] = local_84;
        }
      }
      iVar8 = g_list_find(data->destvertices,local_24);
      if (iVar8 != 0) {
        src_vertices = (GList *)0x0;
        local_48 = (toporouter_vertex_t *)0x0;
        local_20[0] = local_24;
        data->path = (GList *)0x0;
        local_7c = (_toporouter_vertex_t *)local_24;
        ptVar13 = (toporouter_vertex_t *)0x0;
        if (local_24 == (toporouter_vertex_t *)0x0) goto LAB_080ea9b8;
        goto LAB_080ea973;
      }
      uVar14 = g_list_prepend(uVar14,local_24);
      local_7c = (_toporouter_vertex_t *)local_20;
      local_84 = local_24;
      local_80 = (_toporouter_vertex_t *)data;
      pGVar9 = compute_candidate_points(r,local_50,local_24,data,(toporouter_vertex_t **)local_7c);
      src_vertices = pGVar9;
joined_r0x080ea798:
      if (src_vertices != (GList *)0x0) {
        do {
          p = (_toporouter_vertex_t *)src_vertices->data;
          iVar8 = g_list_find(uVar14,p,local_84,local_80,local_7c);
          p_Var5 = (_toporouter_vertex_t *)local_24;
          if (iVar8 == 0) {
            while (p_Var5 != (_toporouter_vertex_t *)0x0) {
              if (p == p_Var5) goto LAB_080ea7b0;
              p_Var5 = *(_toporouter_vertex_t **)((int)p_Var5 + 0x2c);
            }
            heap_search_data.result = (toporouter_vertex_t *)0x0;
            local_80 = p;
            local_7c = (_toporouter_vertex_t *)local_24;
            heap_search_data.key = (toporouter_vertex_t *)p;
            fVar16 = (float10)gcost(r,data,ptVar13,p,local_24,&local_28);
            local_84 = (toporouter_vertex_t *)&heap_search_data;
            dVar1 = (double)fVar16;
            gts_eheap_foreach(heap,toporouter_heap_search,local_84);
            if (heap_search_data.result == (toporouter_vertex_t *)0x0) {
              *(double *)&p->gcost = dVar1;
              *(toporouter_vertex_t **)&p->parent = local_24;
              local_24->child = p;
              p->gn = local_28;
              local_84 = local_20[0];
              fVar16 = (float10)simple_h_cost(r,p);
              *(double *)&p->hcost = (double)fVar16;
              gts_eheap_insert(heap,p);
            }
            else {
              if (dVar1 < (double)p->gcost) goto code_r0x080ea853;
            }
          }
LAB_080ea7b0:
          src_vertices = (GList *)(&src_vertices->data)[1];
          if (src_vertices == (GList *)0x0) break;
        } while( true );
      }
      g_list_free(pGVar9);
      gVar7 = gts_eheap_size(heap);
    }
    data->score = INFINITY;
    clean_routing_edges(r,data);
    local_48 = (toporouter_vertex_t *)0x0;
    data->path = (GList *)0x0;
  }
  goto LAB_080ea5f1;
LAB_080ea973:
  src_vertices = (GList *)g_list_prepend(src_vertices,local_7c);
  data->path = src_vertices;
  iVar8 = g_list_find(data->srcvertices,local_7c);
  if ((iVar8 != 0) && (local_48 = (toporouter_vertex_t *)local_7c, (*(byte *)&r->flags & 0x40) != 0)
     ) {
    local_48 = (toporouter_vertex_t *)data->path;
    ptVar13 = (toporouter_vertex_t *)local_7c;
    goto LAB_080ea9b8;
  }
  if (((toporouter_vertex_t *)local_7c)->parent == (_toporouter_vertex_t *)0x0)
  goto code_r0x080ea9a9;
  src_vertices = data->path;
  local_7c = ((toporouter_vertex_t *)local_7c)->parent;
  goto LAB_080ea973;
code_r0x080ea853:
  *(double *)&p->gcost = dVar1;
  p->gn = local_28;
  *(toporouter_vertex_t **)&p->parent = local_24;
  local_24->child = p;
  gts_eheap_update(heap);
  src_vertices = (GList *)(&src_vertices->data)[1];
  goto joined_r0x080ea798;
code_r0x080ea9a9:
  ptVar13 = local_48;
  local_48 = (toporouter_vertex_t *)data->path;
LAB_080ea9b8:
  fVar16 = (float10)path_score(r,local_48);
  p_Var2 = ptVar13->bbox->cluster;
  *(double *)&data->score = (double)fVar16;
  if (p_Var2 != data->src) {
    data->src = p_Var2;
  }
  p_Var2 = local_20[0]->bbox->cluster;
  if (p_Var2 != data->dest) {
    data->dest = p_Var2;
  }
  src_vertices = data->path;
  if (src_vertices != (GList *)0x0) {
    pvVar11 = src_vertices->data;
    src_vertices = src_vertices->next;
    while (src_vertices != (GList *)0x0) {
      bVar15 = pvVar11 != (gpointer)0x0;
      pvVar11 = src_vertices->data;
      if ((bVar15) && (iVar8 = g_list_find(data->srcvertices,pvVar11), iVar8 != 0)) {
        src_vertices = (GList *)g_list_copy(src_vertices);
        g_list_free(data->path);
        data->path = src_vertices;
      }
      src_vertices = src_vertices->next;
    }
    src_vertices = data->path;
    if (src_vertices != (GList *)0x0) {
      pvVar11 = (gpointer)0x0;
      pGVar9 = src_vertices;
      do {
        pvVar3 = pGVar9->data;
        uVar4 = *(uint *)((int)pvVar3 + 0x38);
        if ((char)uVar4 < '\0') {
          *(uint *)((int)pvVar3 + 0x38) =
               uVar4 & 0xffff0000 | (uint)(ushort)((ushort)uVar4 ^ 0x80) | 0x100;
        }
        if (pvVar11 != (gpointer)0x0) {
          *(gpointer *)((int)pvVar11 + 0x30) = pvVar3;
        }
        if (*(int *)((int)pvVar3 + 0x34) != 0) {
          *(toporouter_route_t **)((int)pvVar3 + 0x58) = data;
        }
        pGVar9 = pGVar9->next;
        pvVar11 = pvVar3;
      } while (pGVar9 != (GList *)0x0);
      if (src_vertices != (GList *)0x0) {
        pvVar11 = (gpointer)0x0;
        do {
          while (pvVar3 = src_vertices->data, pvVar11 == (gpointer)0x0) {
            src_vertices = src_vertices->next;
            *(undefined4 *)((int)pvVar3 + 0x2c) = 0;
            pvVar11 = pvVar3;
            if (src_vertices == (GList *)0x0) goto LAB_080eaac5;
          }
          src_vertices = src_vertices->next;
          *(gpointer *)((int)pvVar3 + 0x2c) = pvVar11;
          *(gpointer *)((int)pvVar11 + 0x30) = pvVar3;
          pvVar11 = pvVar3;
        } while (src_vertices != (GList *)0x0);
LAB_080eaac5:
        if (pvVar3 != (gpointer)0x0) {
          *(undefined4 *)((int)pvVar3 + 0x30) = 0;
        }
      }
    }
  }
  clean_routing_edges(r,data);
  src_vertices = data->path;
  while (src_vertices != (GList *)0x0) {
    while (pvVar11 = src_vertices->data, *(int *)((int)pvVar11 + 0x34) != 0) {
      pGVar10 = (GtsObjectClass *)toporouter_constraint_class();
      item = *(GtsObjectClass **)((int)pvVar11 + 0x34);
      if (pGVar10 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        item = *(GtsObjectClass **)((int)pvVar11 + 0x34);
LAB_080eab54:
        space_edge(item,(gpointer)0x0);
      }
      else {
        if (item == (GtsObjectClass *)0x0) goto LAB_080eab54;
        pGVar12 = *(GtsObjectClass **)&item->info;
        if (pGVar12 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar10 == pGVar12) goto LAB_080eab26;
            pGVar12 = pGVar12->parent_class;
          } while (pGVar12 != (GtsObjectClass *)0x0);
          goto LAB_080eab54;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        space_edge(*(gpointer *)((int)pvVar11 + 0x34),(gpointer)0x0);
      }
      src_vertices = src_vertices->next;
      if (src_vertices == (GList *)0x0) goto LAB_080ea5f1;
    }
LAB_080eab26:
    src_vertices = src_vertices->next;
  }
LAB_080ea5f1:
  g_list_free(data->destvertices);
  g_list_free(data->srcvertices);
  data->destvertices = (GList *)0x0;
  data->srcvertices = (GList *)0x0;
  gts_eheap_destroy(heap);
  g_list_free(uVar14);
  data->alltemppoints = (GHashTable *)0x0;
  return (GList *)local_48;
}



// WARNING: Type propagation algorithm not settling

void roar_detour_route(toporouter_t *r,toporouter_route_t *data)

{
  GList **ppGVar1;
  _toporouter_netlist_t *p_Var2;
  gint gVar3;
  gint **ppgVar4;
  guint gVar5;
  gint *pgVar6;
  toporouter_route_t *route;
  GList *pGVar7;
  GList *pGVar8;
  int iVar9;
  GList *pGVar10;
  gint **ppgVar11;
  toporouter_route_t *route_00;
  GList *local_40;
  gdouble local_3c;
  gdouble local_34;
  GList *local_20;
  
  local_3c = data->score;
  route_checkpoint(data,(toporouter_route_t *)0x0);
  p_Var2 = data->netlist;
  pGVar7 = (GList *)g_list_remove(p_Var2->routed,data);
  p_Var2->routed = pGVar7;
  pGVar7 = (GList *)g_list_remove(r->routednets,data);
  r->routednets = pGVar7;
  pGVar7 = (GList *)g_list_prepend(r->failednets,data);
  r->failednets = pGVar7;
  local_40 = (GList *)g_list_prepend(0,data->netlist);
  netlists_recalculate(local_40,(GList *)0x0);
  r->flags = r->flags | 0x20;
  pGVar7 = route(r,data,0);
  if (pGVar7 == (GList *)0x0) {
    r->flags = r->flags & 0xffffffdf;
  }
  else {
    local_34 = data->score;
    pGVar8 = route_conflicts(data);
    p_Var2 = data->netlist;
    pGVar7 = (GList *)g_list_prepend(p_Var2->routed,data);
    p_Var2->routed = pGVar7;
    pGVar7 = (GList *)g_list_prepend(r->routednets,data);
    r->routednets = pGVar7;
    pGVar7 = (GList *)g_list_remove(r->failednets,data);
    r->flags = r->flags & 0xffffffdf;
    r->failednets = pGVar7;
    pGVar7 = pGVar8;
    if (pGVar8 == (GList *)0x0) {
      netlists_recalculate(local_40,(GList *)0x0);
    }
    else {
      do {
        route_00 = (toporouter_route_t *)pGVar7->data;
        iVar9 = g_list_find(local_40,route_00->netlist);
        if (iVar9 == 0) {
          local_40 = (GList *)g_list_prepend(local_40,route_00->netlist);
        }
        local_3c = (gdouble)((double)local_3c + (double)route_00->score);
        route_checkpoint(route_00,(toporouter_route_t *)0x0);
        p_Var2 = route_00->netlist;
        pGVar10 = (GList *)g_list_remove(p_Var2->routed,route_00);
        p_Var2->routed = pGVar10;
        pGVar10 = (GList *)g_list_remove(r->routednets,route_00);
        r->routednets = pGVar10;
        pGVar10 = (GList *)g_list_prepend(r->failednets,route_00);
        r->failednets = pGVar10;
        ppGVar1 = &pGVar7->next;
        pGVar7 = *ppGVar1;
      } while (*ppGVar1 != (GList *)0x0);
      netlists_recalculate(local_40,(GList *)0x0);
      local_20 = pGVar8;
      do {
        route_00 = (toporouter_route_t *)local_20->data;
        pGVar7 = route(r,route_00,0);
        if (pGVar7 == (GList *)0x0) {
          pGVar7 = local_20->prev;
          goto roar_detour_route_rollback_int;
        }
        p_Var2 = route_00->netlist;
        iVar9 = route_00->dest->c;
        gVar3 = route_00->src->c;
        ppgVar4 = (gint **)p_Var2->clusters->pdata;
        gVar5 = p_Var2->clusters->len;
        ppgVar11 = ppgVar4 + (gVar5 - 1);
        if ((ppgVar4 <= ppgVar11) && (gVar5 != 0)) {
          do {
            while (pgVar6 = *ppgVar11, iVar9 != *pgVar6) {
              ppgVar11 = ppgVar11 + -1;
              if (ppgVar11 < ppgVar4) goto LAB_080eae27;
            }
            ppgVar11 = ppgVar11 + -1;
            *pgVar6 = gVar3;
          } while (ppgVar4 <= ppgVar11);
        }
LAB_080eae27:
        pGVar7 = (GList *)g_list_prepend(p_Var2->routed,route_00);
        p_Var2->routed = pGVar7;
        pGVar7 = (GList *)g_list_prepend(r->routednets,route_00);
        r->routednets = pGVar7;
        pGVar7 = (GList *)g_list_remove(r->failednets,route_00);
        r->failednets = pGVar7;
        local_34 = (gdouble)((double)local_34 + (double)route_00->score);
        local_20 = local_20->next;
      } while (local_20 != (GList *)0x0);
    }
    if ((double)local_34 <= (double)local_3c) {
      g_list_free(pGVar8);
      goto LAB_080eaffe;
    }
    pGVar7 = (GList *)g_list_last(pGVar8);
roar_detour_route_rollback_int:
    p_Var2 = data->netlist;
    pGVar10 = (GList *)g_list_remove(p_Var2->routed,data);
    p_Var2->routed = pGVar10;
    pGVar10 = (GList *)g_list_remove(r->routednets,data);
    r->routednets = pGVar10;
    pGVar10 = (GList *)g_list_prepend(r->failednets,data);
    r->failednets = pGVar10;
    while (pGVar7 != (GList *)0x0) {
      route_00 = (toporouter_route_t *)pGVar7->data;
      p_Var2 = route_00->netlist;
      pGVar10 = (GList *)g_list_remove(p_Var2->routed,route_00);
      p_Var2->routed = pGVar10;
      pGVar10 = (GList *)g_list_remove(r->routednets,route_00);
      r->routednets = pGVar10;
      pGVar10 = (GList *)g_list_prepend(r->failednets,route_00);
      r->failednets = pGVar10;
      delete_route(route_00,1);
      pGVar7 = pGVar7->prev;
    }
    route_00 = (toporouter_route_t *)g_list_last(pGVar8);
    while (route_00 != (toporouter_route_t *)0x0) {
      route = (toporouter_route_t *)route_00->netlist;
      route_restore(route);
      p_Var2 = route->netlist;
      pGVar7 = (GList *)g_list_prepend(p_Var2->routed,route);
      p_Var2->routed = pGVar7;
      pGVar7 = (GList *)g_list_prepend(r->routednets,route);
      r->routednets = pGVar7;
      pGVar7 = (GList *)g_list_remove(r->failednets,route);
      r->failednets = pGVar7;
      route_00 = (toporouter_route_t *)route_00->dest;
    }
    delete_route(data,1);
  }
  route_restore(data);
  p_Var2 = data->netlist;
  pGVar7 = (GList *)g_list_prepend(p_Var2->routed,data);
  p_Var2->routed = pGVar7;
  pGVar7 = (GList *)g_list_prepend(r->routednets,data);
  r->routednets = pGVar7;
  pGVar7 = (GList *)g_list_remove(r->failednets,data);
  r->failednets = pGVar7;
LAB_080eaffe:
  netlists_recalculate(local_40,(GList *)0x0);
  g_list_free();
  return;
}



// WARNING: Type propagation algorithm not settling

void detour_router(toporouter_t *r)

{
  GList *pGVar1;
  gpointer pvVar2;
  toporouter_route_t *data;
  undefined4 uVar3;
  toporouter_route_t **pptVar4;
  toporouter_route_t *ptVar5;
  toporouter_route_t *ptVar6;
  float10 fVar7;
  
  pGVar1 = r->routednets;
  uVar3 = g_list_length(pGVar1);
  pptVar4 = (toporouter_route_t **)g_ptr_array_sized_new(uVar3);
  while (pGVar1 != (GList *)0x0) {
    pvVar2 = pGVar1->data;
    fVar7 = (float10)path_score(r,*(undefined4 *)((int)pvVar2 + 0x2c));
    *(double *)((int)pvVar2 + 0x14) = (double)fVar7;
    g_ptr_array_add(pptVar4,pGVar1->data);
    pGVar1 = pGVar1->next;
  }
  g_ptr_array_sort(pptVar4,route_detour_compare);
  ptVar6 = *pptVar4;
  ptVar5 = pptVar4[1];
  if (ptVar6 < (toporouter_route_t **)((int)&ptVar6->netlist + (int)ptVar5 * 4)) {
    do {
      data = (toporouter_route_t *)ptVar6->netlist;
      if ((ABS((double)data->score) <=
                      
           179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
          ) && (ABS((double)data->detourscore) <=
                                
                179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
               )) {
        if ((double)data->score - (double)data->detourscore <= 1000.00000000) break;
        roar_detour_route(r,data);
        ptVar5 = pptVar4[1];
      }
      ptVar6 = (toporouter_route_t *)&ptVar6->src;
    } while (ptVar6 < (toporouter_route_t *)((int)&(*pptVar4)->netlist + (int)ptVar5 * 4));
  }
  __printf_chk(1,0x8151453);
  g_ptr_array_free(pptVar4,1);
  return;
}



// WARNING: Type propagation algorithm not settling

gint roar_route(toporouter_t *r,toporouter_route_t *routedata,gint threshold)

{
  _toporouter_netlist_t *p_Var1;
  GPtrArray *pGVar2;
  guint gVar3;
  int **ppiVar4;
  int iVar5;
  toporouter_route_t *routedata_00;
  char "roar_route" [11];
  _toporouter_cluster_t *p_Var6;
  GList *pGVar7;
  int **ppiVar8;
  int iVar9;
  GList *pGVar10;
  GList *pGVar11;
  _toporouter_cluster_t *p_Var12;
  toporouter_route_t *route;
  gint gVar13;
  GList *local_34;
  int local_2c;
  toporouter_route_t *local_28;
  GList *local_20;
  
  if (routedata->path != (GList *)0x0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/toporouter.c",0x1b3e,"roar_route","!routedata->path");
  }
  p_Var12 = routedata->src;
  p_Var6 = routedata->dest;
  iVar9 = p_Var12->c;
  if (iVar9 == p_Var6->c) {
    __printf_chk(1,"ERROR: attempt to route already complete route\n");
    p_Var12 = routedata->src;
    p_Var6 = routedata->dest;
    iVar9 = p_Var12->c;
    if (iVar9 == p_Var6->c) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/toporouter.c",0x1b42,0x8151170,
                 "routedata->src->c != routedata->dest->c");
    }
  }
  p_Var12->pc = iVar9;
  p_Var6->pc = p_Var6->c;
  r->flags = r->flags | 0x20;
  routedata->psrc = p_Var12;
  routedata->pdest = p_Var6;
  pGVar7 = route(r,routedata,0);
  if (pGVar7 == (GList *)0x0) {
    local_28 = (toporouter_route_t *)0x0;
    r->flags = r->flags & 0xffffffdf;
    gVar13 = 0;
    goto LAB_080eb624;
  }
  p_Var1 = routedata->netlist;
  pGVar7 = (GList *)g_list_prepend(p_Var1->routed,routedata);
  p_Var1->routed = pGVar7;
  pGVar7 = (GList *)g_list_prepend(r->routednets,routedata);
  r->routednets = pGVar7;
  pGVar7 = (GList *)g_list_remove(r->failednets,routedata);
  r->failednets = pGVar7;
  pGVar7 = route_conflicts(routedata);
  p_Var1 = routedata->netlist;
  pGVar2 = p_Var1->clusters;
  iVar9 = routedata->dest->c;
  gVar3 = pGVar2->len;
  ppiVar4 = (int **)pGVar2->pdata;
  iVar5 = routedata->src->c;
  ppiVar8 = ppiVar4 + (gVar3 - 1);
  if (ppiVar4 <= ppiVar8) {
    while (gVar3 != 0) {
      if (iVar9 == **ppiVar8) {
        **ppiVar8 = iVar5;
      }
      if (ppiVar8 + -1 < ppiVar4) break;
      ppiVar8 = ppiVar8 + -1;
      gVar3 = pGVar2->len;
    }
  }
  r->flags = r->flags & 0xffffffdf;
  if (pGVar7 != (GList *)0x0) {
    local_20 = (GList *)0x0;
    pGVar11 = pGVar7;
    do {
      route = (toporouter_route_t *)pGVar11->data;
      iVar9 = g_list_find(local_20,route->netlist);
      if (iVar9 == 0) {
        local_20 = (GList *)g_list_prepend(local_20,route->netlist);
      }
      route_checkpoint(route,routedata);
      p_Var1 = route->netlist;
      pGVar10 = (GList *)g_list_remove(p_Var1->routed,route);
      p_Var1->routed = pGVar10;
      pGVar10 = (GList *)g_list_remove(r->routednets,route);
      r->routednets = pGVar10;
      pGVar10 = (GList *)g_list_prepend(r->failednets,route);
      r->failednets = pGVar10;
      pGVar11 = pGVar11->next;
    } while (pGVar11 != (GList *)0x0);
    local_34 = (GList *)g_list_prepend(local_20,routedata->netlist);
    netlists_recalculate(local_34,(GList *)0x0);
    route = (toporouter_route_t *)pGVar7->data;
    if (route->src->c != route->dest->c) {
      local_28 = (toporouter_route_t *)0x0;
      local_2c = 0;
      local_20 = pGVar7;
      do {
        pGVar11 = route(r,route,0);
        if (pGVar11 == (GList *)0x0) {
          local_2c = local_2c + 1;
          route = local_28;
          if (threshold <= local_2c) goto joined_r0x080eb4e0;
        }
        else {
          iVar9 = route->dest->c;
          iVar5 = route->src->c;
          pGVar2 = route->netlist->clusters;
          ppiVar4 = (int **)pGVar2->pdata;
          gVar3 = pGVar2->len;
          ppiVar8 = ppiVar4 + (gVar3 - 1);
          if (ppiVar4 <= ppiVar8) {
            while (gVar3 != 0) {
              if (iVar9 == **ppiVar8) {
                **ppiVar8 = iVar5;
              }
              if (ppiVar8 + -1 < ppiVar4) break;
              ppiVar8 = ppiVar8 + -1;
              gVar3 = pGVar2->len;
            }
          }
          local_28 = (toporouter_route_t *)g_list_prepend(local_28,route);
          p_Var1 = route->netlist;
          pGVar11 = (GList *)g_list_prepend(p_Var1->routed,route);
          p_Var1->routed = pGVar11;
          pGVar11 = (GList *)g_list_prepend(r->routednets,route);
          r->routednets = pGVar11;
          pGVar11 = (GList *)g_list_remove(r->failednets,route);
          r->failednets = pGVar11;
          netlist_recalculate((toporouter_netlist_t *)route->netlist,(GList *)0x0);
        }
        local_20 = local_20->next;
        if (local_20 == (GList *)0x0) {
          gVar13 = local_2c + -1;
          goto LAB_080eb63f;
        }
        route = (toporouter_route_t *)local_20->data;
      } while (route->src->c != route->dest->c);
    }
                    // WARNING: Subroutine does not return
    g_assertion_message_expr
              (0,"../../src/toporouter.c",0x1b67,0x8151170,"conflict->src->c != conflict->dest->c");
  }
  gVar13 = -1;
  local_34 = (GList *)g_list_prepend(0,p_Var1);
  netlists_recalculate(local_34,(GList *)0x0);
  local_28 = (toporouter_route_t *)0x0;
LAB_080eb63f:
  netlists_recalculate(local_34,(GList *)0x0);
roar_route_end:
  g_list_free(pGVar7);
  g_list_free(local_34);
LAB_080eb624:
  g_list_free(local_28);
  return gVar13;
joined_r0x080eb4e0:
  while (route != (toporouter_route_t *)0x0) {
    routedata_00 = (toporouter_route_t *)route->netlist;
    p_Var1 = routedata_00->netlist;
    pGVar11 = (GList *)g_list_remove(p_Var1->routed,routedata_00);
    p_Var1->routed = pGVar11;
    pGVar11 = (GList *)g_list_remove(r->routednets,routedata_00);
    r->routednets = pGVar11;
    pGVar11 = (GList *)g_list_prepend(r->failednets,routedata_00);
    r->failednets = pGVar11;
    delete_route(routedata_00,1);
    route = (toporouter_route_t *)route->src;
  }
  delete_route(routedata,1);
  route = (toporouter_route_t *)g_list_last(pGVar7);
  while (route != (toporouter_route_t *)0x0) {
    routedata_00 = (toporouter_route_t *)route->netlist;
    route_restore(routedata_00);
    p_Var1 = routedata_00->netlist;
    pGVar11 = (GList *)g_list_prepend(p_Var1->routed,routedata_00);
    p_Var1->routed = pGVar11;
    pGVar11 = (GList *)g_list_prepend(r->routednets,routedata_00);
    r->routednets = pGVar11;
    pGVar11 = (GList *)g_list_remove(r->failednets,routedata_00);
    r->failednets = pGVar11;
    route = (toporouter_route_t *)route->dest;
  }
  p_Var1 = routedata->netlist;
  pGVar11 = (GList *)g_list_remove(p_Var1->routed,routedata);
  p_Var1->routed = pGVar11;
  pGVar11 = (GList *)g_list_remove(r->routednets,routedata);
  r->routednets = pGVar11;
  pGVar11 = (GList *)g_list_prepend(r->failednets,routedata);
  r->failednets = pGVar11;
  gVar13 = 0;
  netlists_recalculate(local_34,(GList *)0x0);
  goto roar_route_end;
}



// WARNING: Type propagation algorithm not settling

gint roar_router(toporouter_t *r,gint failcount,gint threshold)

{
  toporouter_route_t *ptVar1;
  toporouter_route_t *ptVar2;
  gint gVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int local_28;
  int local_20;
  
  local_28 = failcount + 1;
  Message("ROAR router: ");
  local_20 = 0;
  while( true ) {
    ptVar2 = (toporouter_route_t *)g_list_copy(r->failednets);
    ptVar1 = ptVar2;
    while (ptVar1 != (toporouter_route_t *)0x0) {
      gVar3 = roar_route(r,(toporouter_route_t *)ptVar1->netlist,threshold);
      ptVar1 = (toporouter_route_t *)ptVar1->src;
      failcount = failcount + gVar3;
    }
    g_list_free(ptVar2);
    uVar4 = g_list_length(r->failednets);
    uVar5 = g_list_length(r->routednets);
    __printf_chk(1,"\tROAR pass %d - %d routed -  %d failed\n",local_20,uVar5,uVar4);
    if ((local_28 <= failcount) || (failcount == 0)) break;
    Message("%d -> ",failcount);
    local_20 = local_20 + 1;
    local_28 = failcount;
    if (local_20 == 6) {
      return failcount;
    }
  }
  Message("%d nets remaining\n",failcount);
  return failcount;
}



void netscore_pairwise_calculation(toporouter_netscore_t *netscore,GPtrArray *netscores)

{
  double dVar1;
  double dVar2;
  toporouter_netscore_t *ptVar3;
  toporouter_route_t *ptVar4;
  toporouter_netscore_t *ptVar5;
  toporouter_route_t *data;
  toporouter_netscore_t *ptVar6;
  int iVar7;
  guint local_20;
  
  ptVar3 = (toporouter_netscore_t *)netscores->pdata;
  data = routedata_create();
  apply_route(netscore->routedata->topopath,netscore->routedata);
  local_20 = netscores->len;
  if (ptVar3 < (toporouter_netscore_t **)((int)&ptVar3->id + local_20 * 4)) {
    iVar7 = 0;
    ptVar6 = ptVar3;
    do {
      if ((netscore->pairwise_nodetour[iVar7 >> 2] == 0) &&
         (*(toporouter_netscore_t **)ptVar6 != netscore)) {
        ptVar4 = (*(toporouter_netscore_t **)ptVar6)->routedata;
        data->src = ptVar4->src;
        data->dest = ptVar4->dest;
        route(netscore->r,data,0);
        ptVar5 = *(toporouter_netscore_t **)ptVar6;
        dVar1 = (double)data->score;
        dVar2 = (double)ptVar5->score;
        if (dVar1 == dVar2) {
          netscore->pairwise_nodetour[iVar7 >> 2] = 1;
          ptVar5->pairwise_nodetour[netscore->id] = 1;
        }
        else {
          if (ABS(dVar1) <=
                            
              179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
             ) {
            *(double *)&netscore->pairwise_detour_sum =
                 (dVar1 - dVar2) + (double)netscore->pairwise_detour_sum;
          }
          else {
            netscore->pairwise_fails = netscore->pairwise_fails + 1;
          }
        }
        delete_route(data,1);
        local_20 = netscores->len;
      }
      ptVar6 = (toporouter_netscore_t *)((toporouter_netscore_t **)ptVar6 + 1);
      iVar7 = iVar7 + 4;
    } while (ptVar6 < (toporouter_netscore_t **)((int)&ptVar3->id + local_20 * 4));
  }
  remove_route(netscore->routedata->topopath);
  free(data);
  return;
}



toporouter_netscore_t *
netscore_create(toporouter_t *r,toporouter_route_t *routedata,guint n,guint id)

{
  double dVar1;
  toporouter_netscore_t *ptVar2;
  GList *pGVar3;
  guint *pgVar4;
  uint uVar5;
  
  ptVar2 = (toporouter_netscore_t *)calloc(1,0x24);
  pGVar3 = route(r,routedata,0);
  ptVar2->routedata = routedata;
  dVar1 = (double)routedata->score;
  *(double *)&ptVar2->score = dVar1;
  *(double *)&routedata->detourscore = dVar1;
  ptVar2->id = id;
  if (
      179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
      < ABS(dVar1)) {
    __printf_chk(1,"WARNING: !finite(detourscore)\n");
    print_cluster((toporouter_cluster_t *)routedata->src);
    print_cluster((toporouter_cluster_t *)routedata->dest);
  }
  pgVar4 = (guint *)calloc(1,n * 4);
  ptVar2->pairwise_nodetour = pgVar4;
  if (n != 0) {
    uVar5 = 0;
    while( true ) {
      pgVar4[uVar5] = 0;
      uVar5 = uVar5 + 1;
      if (n <= uVar5) break;
      pgVar4 = ptVar2->pairwise_nodetour;
    }
  }
  ptVar2->pairwise_detour_sum = 0.00000000;
  ptVar2->pairwise_fails = 0;
  ptVar2->r = r;
  if (pGVar3 != (GList *)0x0) {
    pGVar3 = (GList *)g_list_copy(routedata->path);
    routedata->topopath = pGVar3;
    delete_route(routedata,0);
  }
  return ptVar2;
}



guint order_nets_preroute_greedy(toporouter_t *r,GList *nets,GList **rnets)

{
  double dVar1;
  void *__ptr;
  guint n;
  void **ppvVar2;
  guint id;
  toporouter_netscore_t *ptVar3;
  GList *pGVar4;
  void **ppvVar5;
  guint local_20;
  
  n = g_list_length(nets);
  ppvVar2 = (void **)g_ptr_array_sized_new(n);
  if (nets != (GList *)0x0) {
    id = 0;
    do {
      ptVar3 = netscore_create(r,(toporouter_route_t *)nets->data,n,id);
      g_ptr_array_add(ppvVar2,ptVar3);
      nets = nets->next;
      id = id + 1;
    } while (nets != (GList *)0x0);
  }
  g_ptr_array_foreach(ppvVar2,netscore_pairwise_calculation,ppvVar2);
  g_ptr_array_sort(ppvVar2,r->netsort);
  __ptr = ppvVar2[1];
  *rnets = (GList *)0x0;
  ppvVar5 = (void **)(*ppvVar2 + ((int)__ptr - 1));
  if ((ppvVar5 < *ppvVar2) || (__ptr == (void *)0x0)) {
    local_20 = 0;
  }
  else {
    pGVar4 = (GList *)0x0;
    local_20 = 0;
    while( true ) {
      __ptr = *ppvVar5;
      pGVar4 = (GList *)g_list_prepend(pGVar4,*(undefined4 *)((int)__ptr + 0x1c));
      dVar1 = *(double *)((int)__ptr + 0x10);
      *rnets = pGVar4;
      local_20 = local_20 +
                 (
                 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                 < ABS(dVar1));
      ppvVar5 = ppvVar5 + -1;
      free(*(void **)((int)__ptr + 4));
      free(__ptr);
      if ((ppvVar5 <= *ppvVar2 && (void **)*ppvVar2 != ppvVar5) || (ppvVar2[1] == (void *)0x0))
      break;
      pGVar4 = *rnets;
    }
  }
  g_ptr_array_free(ppvVar2,1);
  return local_20;
}



gint rubix_router(toporouter_t *r,gint failcount)

{
  _toporouter_netlist_t *p_Var1;
  int iVar2;
  gint gVar3;
  GPtrArray *pGVar4;
  gint **ppgVar5;
  guint gVar6;
  gint *pgVar7;
  toporouter_route_t *data;
  toporouter_route_t *ptVar8;
  GList *pGVar9;
  gint **ppgVar10;
  toporouter_route_t *local_20 [4];
  
  order_nets_preroute_greedy(r,r->failednets,(GList **)local_20);
  data = (toporouter_route_t *)0x0;
  ptVar8 = local_20[0];
  do {
    if (ptVar8 == (toporouter_route_t *)0x0) {
      g_list_free(data);
      return failcount;
    }
    data = (toporouter_route_t *)ptVar8->netlist;
    pGVar9 = route(r,data,0);
    if (pGVar9 != (GList *)0x0) {
      p_Var1 = data->netlist;
      pGVar9 = (GList *)g_list_prepend(p_Var1->routed,data);
      p_Var1->routed = pGVar9;
      pGVar9 = (GList *)g_list_prepend(r->routednets,data);
      r->routednets = pGVar9;
      pGVar9 = (GList *)g_list_remove(r->failednets,data);
      r->failednets = pGVar9;
      iVar2 = data->dest->c;
      gVar3 = data->src->c;
      pGVar4 = data->netlist->clusters;
      ppgVar5 = (gint **)pGVar4->pdata;
      gVar6 = pGVar4->len;
      ppgVar10 = ppgVar5 + (gVar6 - 1);
      if ((ppgVar5 <= ppgVar10) && (gVar6 != 0)) {
        do {
          while (pgVar7 = *ppgVar10, iVar2 == *pgVar7) {
            ppgVar10 = ppgVar10 + -1;
            *pgVar7 = gVar3;
            if (ppgVar10 < ppgVar5) goto LAB_080ebca7;
          }
          ppgVar10 = ppgVar10 + -1;
        } while (ppgVar5 <= ppgVar10);
      }
LAB_080ebca7:
      failcount = failcount + -1;
    }
    ptVar8 = (toporouter_route_t *)ptVar8->src;
    data = local_20[0];
  } while( true );
}



guint hybrid_router(toporouter_t *r)

{
  gint failcount;
  guint gVar1;
  
  failcount = g_list_length(r->failednets);
  r->flags = r->flags | 0xc0;
  failcount = rubix_router(r,failcount);
  Message("RUBIX router: %d nets remaining\n",failcount);
  __printf_chk(1,"RUBIX router: %d nets remaining\n",failcount);
  r->flags = r->flags | 0x100;
  failcount = roar_router(r,failcount,2);
  detour_router(r);
  gVar1 = roar_router(r,failcount,2);
  detour_router(r);
  return gVar1;
}



int toporouter(int argc,char **argv,int x,int y)

{
  toporouter_t *r;
  
  r = toporouter_new();
  parse_arguments(r,argc,argv);
  import_geometry(r);
  acquire_twonets(r);
  hybrid_router(r);
  toporouter_export(r);
  toporouter_free(r);
  SaveUndoSerialNumber();
  DeleteRats('\0');
  RestoreUndoSerialNumber();
  AddAllRats('\0',(anon_subr_void *)0x0);
  RestoreUndoSerialNumber();
  IncrementUndoSerialNumber();
  ClearAndRedrawOutput();
  return 0;
}



gint spread_edge(gpointer item,gpointer data)

{
  int iVar1;
  int iVar2;
  double dVar3;
  double d;
  GtsObjectClass *pGVar4;
  int iVar5;
  GtsObjectClass *pGVar6;
  int *piVar7;
  float10 fVar8;
  
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (item != (gpointer)0x0) {
      pGVar6 = *(GtsObjectClass **)item;
      if (pGVar6 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar4 == pGVar6) {
            return 0;
          }
          pGVar6 = pGVar6->parent_class;
        } while (pGVar6 != (GtsObjectClass *)0x0);
      }
    }
  }
  pGVar4 = (GtsObjectClass *)toporouter_constraint_class();
  if (pGVar4 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (item != (gpointer)0x0) {
      pGVar6 = *(GtsObjectClass **)item;
      if (pGVar6 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar4 == pGVar6) break;
          pGVar6 = pGVar6->parent_class;
        } while (pGVar6 != (GtsObjectClass *)0x0);
      }
    }
  }
  piVar7 = *(int **)((int)item + 0x1c);
  iVar5 = g_list_length(piVar7);
  if (iVar5 != 0) {
    iVar5 = g_list_length(piVar7);
    if (iVar5 == 1) {
      iVar5 = *(int *)((int)item + 0xc);
      iVar1 = *(int *)((int)item + 0x10);
      iVar2 = *piVar7;
      *(double *)(iVar2 + 0xc) = (*(double *)(iVar5 + 0xc) + *(double *)(iVar1 + 0xc)) * 0.50000000;
      *(double *)(iVar2 + 0x14) =
           (*(double *)(iVar5 + 0x14) + *(double *)(iVar1 + 0x14)) * 0.50000000;
    }
    else {
      fVar8 = (float10)gts_point_distance(*(undefined4 *)((int)item + 0xc),
                                          *(undefined4 *)((int)item + 0x10));
      iVar5 = g_list_length(piVar7);
      if (piVar7 != (int *)0x0) {
        dVar3 = (double)fVar8 / (double)(ulonglong)(iVar5 + 1);
        d = dVar3;
        do {
          vertex_move_towards_vertex_values
                    (*(GtsVertex **)((int)item + 0xc),*(GtsVertex **)((int)item + 0x10),(gdouble)d,
                     (gdouble *)(*piVar7 + 0xc),(gdouble *)(*piVar7 + 0x14));
          piVar7 = (int *)piVar7[1];
          d = d + dVar3;
        } while (piVar7 != (int *)0x0);
      }
    }
  }
  return 0;
}



void dispatch_status_changed(DBusConnection *conn,DBusDispatchStatus new_status,void *data)

{
  return;
}



void pcb_dbus_connection_finish_with_mainloop(DBusConnection *connection)

{
  int iVar1;
  
  iVar1 = dbus_connection_set_watch_functions(connection,0,0,0,0,0);
  if (iVar1 != 0) {
    iVar1 = dbus_connection_set_timeout_functions(connection,0,0,0,0,0);
    if (iVar1 != 0) {
      dbus_connection_set_dispatch_status_function(connection,0,0,0);
      return;
    }
  }
  __fprintf_chk(stderr,1,0x81519f0);
  return;
}



void pcb_dbus_connection_setup_with_mainloop(DBusConnection *connection)

{
  int iVar1;
  undefined local_10 [8];
  
  iVar1 = dbus_connection_set_watch_functions(connection,watch_add,watch_remove,watch_toggled,0,0);
  if (iVar1 != 0) {
    iVar1 = dbus_connection_set_timeout_functions
                      (connection,timeout_add,timeout_remove,timeout_toggled,0,0);
    if (iVar1 != 0) {
      dbus_connection_set_dispatch_status_function(connection,dispatch_status_changed,0,0);
      (*gui->add_block_hook)((anon_subr_void_hidval *)local_10,block_hook_cb);
      return;
    }
  }
  __fprintf_chk(stderr,1,"Not enough memory to set up DBusConnection for use with PCB\n");
  return;
}



void block_hook_cb(undefined4 data)

{
  int iVar1;
  
  iVar1 = dbus_connection_get_dispatch_status(data);
  if (iVar1 != 0) {
    return;
  }
  dbus_connection_dispatch();
  return;
}



void timeout_remove(DBusTimeout *timeout,void *data)

{
  dbus_timeout_set_data(timeout,0,0);
  return;
}



dbus_bool_t timeout_add(DBusTimeout *timeout,void *data)

{
  anon_subr_hidval_anon_subr_void_hidval_ptr_ulong_hidval_for_add_timer *paVar1;
  int iVar2;
  DBusTimeout **ppDVar3;
  DBusTimeout *pDVar4;
  DBusTimeout *local_10;
  
  iVar2 = dbus_timeout_get_enabled(timeout);
  if (iVar2 != 0) {
    ppDVar3 = (DBusTimeout **)malloc(0xc);
    *ppDVar3 = timeout;
    pDVar4 = (DBusTimeout *)dbus_timeout_get_interval(timeout);
    paVar1 = gui->add_timer;
    ppDVar3[2] = pDVar4;
    (*paVar1)((anon_subr_void_hidval *)&local_10,(ulong)timeout_handler_cb,pDVar4);
    ppDVar3[1] = local_10;
    dbus_timeout_set_data(timeout,ppDVar3,timeout_handler_dbus_freed);
  }
  return 1;
}



void timeout_toggled(DBusTimeout *timeout,void *data)

{
  int iVar1;
  
  iVar1 = dbus_timeout_get_enabled(timeout);
  if (iVar1 == 0) {
    timeout_remove(timeout,data);
    return;
  }
  timeout_add(timeout,data);
  return;
}



void timeout_handler_dbus_freed(void *data)

{
  (*gui->stop_timer)(*(undefined4 *)((int)data + 4));
  free(data);
  return;
}



void io_watch_handler_dbus_freed(void *data)

{
  (*gui->unwatch_file)(*(undefined4 *)((int)data + 4));
  free(data);
  return;
}



void watch_remove(DBusWatch *dbus_watch,void *data)

{
  dbus_watch_set_data(dbus_watch,0,0);
  return;
}



dbus_bool_t watch_add(DBusWatch *dbus_watch,void *data)

{
  anon_subr_hidval_int_uint_anon_subr_void_hidval_int_uint_hidval_ptr_hidval_for_watch_file *paVar1;
  int iVar2;
  uint uVar3;
  DBusWatch **ppDVar4;
  anon_subr_void_hidval_int_uint_hidval *paVar5;
  DBusWatch *local_20 [4];
  
  iVar2 = dbus_watch_get_enabled(dbus_watch);
  if (iVar2 != 0) {
    uVar3 = dbus_watch_get_flags(dbus_watch);
    paVar5 = (anon_subr_void_hidval_int_uint_hidval *)(0xd - (uint)((uVar3 & 1) == 0));
    if ((uVar3 & 2) != 0) {
      paVar5 = (anon_subr_void_hidval_int_uint_hidval *)((uint)paVar5 | 1);
    }
    uVar3 = dbus_watch_get_unix_fd(dbus_watch);
    ppDVar4 = (DBusWatch **)malloc(8);
    paVar1 = gui->watch_file;
    *ppDVar4 = dbus_watch;
    (*paVar1)((int)local_20,uVar3,paVar5,io_watch_handler_cb);
    ppDVar4[1] = local_20[0];
    dbus_watch_set_data(dbus_watch,ppDVar4,io_watch_handler_dbus_freed);
  }
  return 1;
}



void watch_toggled(DBusWatch *dbus_watch,void *data)

{
  int iVar1;
  
  iVar1 = dbus_watch_get_enabled(dbus_watch);
  if (iVar1 == 0) {
    watch_remove(dbus_watch,data);
    return;
  }
  watch_add(dbus_watch,data);
  return;
}



void timeout_handler_cb(int data)

{
  undefined4 local_10 [2];
  
  (*gui->add_timer)((anon_subr_void_hidval *)local_10,(ulong)timeout_handler_cb,
                    *(undefined4 *)(data + 8));
  *(undefined4 *)(data + 4) = local_10[0];
  dbus_timeout_handle();
  return;
}



void io_watch_handler_cb(hidval pcb_watch,int fd,uint condition,hidval data)

{
  dbus_watch_handle();
  return;
}



void unregister_dbus_handler(DBusConnection *connection,void *data)

{
  return;
}



void pcb_dbus_finish(void)

{
  DBusError err;
  
  dbus_error_init(&err);
  dbus_connection_flush(pcb_dbus_conn);
  dbus_connection_unregister_object_path(pcb_dbus_conn,"/org/seul/geda/pcb");
  dbus_bus_release_name(pcb_dbus_conn,"org.seul.geda.pcb",&err);
  dbus_error_free(&err);
  pcb_dbus_connection_finish_with_mainloop(pcb_dbus_conn);
  dbus_connection_close(pcb_dbus_conn);
  dbus_connection_unref(pcb_dbus_conn);
  dbus_shutdown();
  return;
}



void pcb_dbus_setup(void)

{
  int iVar1;
  int iVar2;
  DBusError *local_40;
  DBusObjectPathVTable object_vtable;
  DBusError err;
  
  object_vtable.unregister_function = unregister_dbus_handler;
  object_vtable.message_function = handle_dbus_message;
  object_vtable.dbus_internal_pad1 = (anon_subr_void_void_ptr_for_dbus_internal_pad1 *)0x0;
  object_vtable.dbus_internal_pad2 = (anon_subr_void_void_ptr_for_dbus_internal_pad2 *)0x0;
  object_vtable.dbus_internal_pad3 = (anon_subr_void_void_ptr_for_dbus_internal_pad3 *)0x0;
  object_vtable.dbus_internal_pad4 = (anon_subr_void_void_ptr_for_dbus_internal_pad4 *)0x0;
  dbus_error_init(&err);
  pcb_dbus_conn = (DBusConnection *)dbus_bus_get_private(0,&err);
  iVar1 = dbus_error_is_set(&err);
  if (iVar1 != 0) {
    __fprintf_chk(stderr,1,"pcb_dbus: DBus connection Error (%s)\n",err.message);
    dbus_error_free(&err);
  }
  if (pcb_dbus_conn != (DBusConnection *)0x0) {
    local_40 = &err;
    iVar1 = dbus_bus_request_name(pcb_dbus_conn,"org.seul.geda.pcb",2,&err);
    iVar2 = dbus_error_is_set(&err);
    if (iVar2 != 0) {
      __fprintf_chk(stderr,1,"pcb_dbus: DBus name error (%s)\n",err.message);
      dbus_error_free(&err);
      local_40 = (DBusError *)err.message;
    }
    if (iVar1 - 1U < 2) {
      iVar1 = dbus_connection_register_object_path
                        (pcb_dbus_conn,"/org/seul/geda/pcb",&object_vtable,0);
      if (iVar1 != 0) {
        pcb_dbus_connection_setup_with_mainloop(pcb_dbus_conn);
        return;
      }
      __fprintf_chk(stderr,1,"pcb_dbus: Couldn\'t register DBUS handler for %s\n",
                    "/org/seul/geda/pcb");
      return;
    }
    __fprintf_chk(stderr,1,
                  "pcb_dbus: Couldn\'t gain ownership or queued ownership of the canonical DBus name\n"
                  ,local_40);
  }
  return;
}



DBusHandlerResult handle_dbus_message(DBusConnection *connection,DBusMessage *message,void *data)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  DBusHandlerResult DVar4;
  char *pcVar5;
  char *pcVar6;
  bool bVar7;
  byte bVar8;
  char *local_c4;
  DBusMessageIter iter;
  DBusError err;
  int local_2c;
  char **local_28;
  char *local_24;
  undefined4 local_20 [4];
  
  bVar8 = 0;
  iVar1 = dbus_message_get_type(message);
  if (iVar1 == 2) {
    local_c4 = "pcb_dbus: DBUG: Method return message\n";
    goto LAB_080ec772;
  }
  if (iVar1 < 3) {
    if (iVar1 == 1) {
      local_c4 = (char *)dbus_message_get_member(message);
      if (local_c4 == (char *)0x0) {
        local_c4 = "pcb_dbus: Method had no name specified\n";
        goto LAB_080ec772;
      }
      pcVar2 = (char *)dbus_message_get_interface(message);
      bVar7 = pcVar2 == (char *)0x0;
      if (bVar7) {
        local_c4 = "pcb_dbus: Method had no interface specified\n";
        goto LAB_080ec772;
      }
      iVar1 = 0x12;
      pcVar5 = pcVar2;
      pcVar6 = "org.seul.geda.pcb";
      do {
        if (iVar1 == 0) break;
        iVar1 = iVar1 + -1;
        bVar7 = *pcVar5 == *pcVar6;
        pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
        pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
      } while (bVar7);
      if (bVar7) {
        iVar1 = 0xc;
        pcVar5 = local_c4;
        pcVar6 = "GetFilename";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar7 = *pcVar5 == *pcVar6;
          pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
          pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
        } while (bVar7);
        if (!bVar7) goto LAB_080ec8ca;
        iVar1 = dbus_message_new_method_return(message);
        if (iVar1 == 0) goto LAB_080ecbe2;
        dbus_message_iter_init_append(iVar1,&iter);
        if (PCB->Filename == (char *)0x0) {
          local_24 = (char *)0x0;
LAB_080ecacf:
          local_24 = (char *)calloc(1,1);
          if (local_24 == (char *)0x0) {
            local_c4 = "pcb_dbus: Couldn\'t strdup( \"\" ) for the filename\n";
            goto LAB_080ec981;
          }
        }
        else {
          local_24 = lrealpath(PCB->Filename);
          if (local_24 == (char *)0x0) goto LAB_080ecacf;
        }
        iVar3 = dbus_message_iter_append_basic(&iter,0x73,&local_24);
        if (iVar3 == 0) {
          __fprintf_chk(stderr,1,
                        "pcb_dbus: Couldn\'t append return filename string to message reply, Out Of Memory!\n"
                       );
          free(local_24);
          DVar4 = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
          goto out;
        }
        free(local_24);
LAB_080eca95:
        iVar3 = dbus_connection_send(connection,iVar1,0);
        DVar4 = DBUS_HANDLER_RESULT_HANDLED;
        if (iVar3 != 0) goto out;
        local_c4 = "pcb_dbus: Couldn\'t send message, Out Of Memory!\n";
      }
      else {
        iVar1 = 0x1a;
        pcVar5 = pcVar2;
        pcVar6 = "org.seul.geda.pcb.actions";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar7 = *pcVar5 == *pcVar6;
          pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
          pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
        } while (bVar7);
        if (bVar7) {
          iVar1 = 0xb;
          pcVar5 = local_c4;
          pcVar6 = "ExecAction";
          do {
            if (iVar1 == 0) break;
            iVar1 = iVar1 + -1;
            bVar7 = *pcVar5 == *pcVar6;
            pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
            pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
          } while (bVar7);
          if (!bVar7) goto LAB_080ec8ca;
          dbus_error_init(&err);
          local_28 = (char **)0x0;
          iVar1 = dbus_message_get_args(message,&err,0x73,&local_24,0x61,0x73,&local_28,&local_2c,0)
          ;
          if (iVar1 == 0) {
            __fprintf_chk(stderr,1,"Failed to read method arguments\n");
            if (local_28 == (char **)0x0) {
              return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
            }
            dbus_free_string_array(local_28);
            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
          }
          hid_actionv(local_24,local_2c,local_28);
          local_20[0] = 0;
          dbus_free_string_array(local_28);
          iVar1 = dbus_message_new_method_return(message);
          if (iVar1 == 0) goto LAB_080ecbe2;
          dbus_message_iter_init_append(iVar1,&iter);
          iVar3 = dbus_message_iter_append_basic(&iter,0x75,local_20);
          if (iVar3 == 0) {
            local_c4 = "pcb_dbus: Couldn\'t sent message, Out Of Memory!\n";
            goto LAB_080ec981;
          }
          goto LAB_080eca95;
        }
        iVar1 = 0x24;
        pcVar5 = pcVar2;
        pcVar6 = "org.freedesktop.DBus.Introspectable";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar7 = *pcVar5 == *pcVar6;
          pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
          pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
        } while (bVar7);
        if (!bVar7) {
          __fprintf_chk(stderr,1,"pcb_dbus: Interface \'%s\' was not recognised\n",pcVar2);
          return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
        }
        iVar1 = 0xb;
        pcVar5 = local_c4;
        pcVar6 = "Introspect";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar7 = *pcVar5 == *pcVar6;
          pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
          pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
        } while (bVar7);
        if (!bVar7) {
LAB_080ec8ca:
          __fprintf_chk(stderr,1,"pcb_dbus: Interface \'%s\' has no method \'%s\'\n",pcVar2,local_c4
                       );
          return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
        }
        iVar1 = dbus_message_new_method_return(message);
        if (iVar1 == 0) {
LAB_080ecbe2:
          local_c4 = "pcb_dbus: Couldn\'t create reply message\n";
          goto LAB_080ec772;
        }
        dbus_message_iter_init_append(iVar1,&iter);
        iVar3 = dbus_message_iter_append_basic(&iter,0x73,&pcb_dbus_introspect_xml);
        if (iVar3 == 0) {
          local_c4 = "pcb_dbus: Couldn\'t add introspect XML to message return\n";
        }
        else {
          iVar3 = dbus_connection_send(pcb_dbus_conn,iVar1,0);
          DVar4 = DBUS_HANDLER_RESULT_HANDLED;
          if (iVar3 != 0) goto out;
          local_c4 = "pcb_dbus: Couldn\'t queue reply message for sending\n";
        }
      }
LAB_080ec981:
      __fprintf_chk(stderr,1,local_c4);
      DVar4 = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
out:
      dbus_message_unref(iVar1);
      return DVar4;
    }
  }
  else {
    if (iVar1 == 3) {
      local_c4 = "pcb_dbus: DEBUG: Error message\n";
      goto LAB_080ec772;
    }
    if (iVar1 == 4) {
      local_c4 = "pcb_dbus: DEBUG: Signal message\n";
      goto LAB_080ec772;
    }
  }
  local_c4 = "pcb_dbus: DEBUG: Message type wasn\'t one we know about!\n";
LAB_080ec772:
  __fprintf_chk(stderr,1,local_c4);
  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}



int __regparm3 Vx(int x)

{
  double dVar1;
  
  if (ghid_flip_x == 0) {
    dVar1 = (double)(x - gport->view_x0) / (double)gport->zoom;
  }
  else {
    dVar1 = (double)((PCB->MaxWidth - x) - gport->view_x0) / (double)gport->zoom;
  }
  return (int)ROUND(dVar1 + 0.50000000);
}



int __regparm3 Vy(int y)

{
  double dVar1;
  
  if (ghid_flip_y == 0) {
    dVar1 = (double)(y - gport->view_y0) / (double)gport->zoom;
  }
  else {
    dVar1 = (double)((PCB->MaxHeight - y) - gport->view_y0) / (double)gport->zoom;
  }
  return (int)ROUND(dVar1 + 0.50000000);
}



HID_Attribute * ghid_get_export_options(int *n_ret)

{
  return (HID_Attribute *)0x0;
}



int ghid_set_layer(char *name,int group,int empty)

{
  int iVar1;
  uint uVar2;
  
  if (group < 0) {
LAB_080ecd72:
    uVar2 = group & 0xf0;
    if (uVar2 == 0x30) {
      return 1;
    }
    if (uVar2 < 0x31) {
      if (uVar2 == 0x10) {
        if ((bool)(((byte)((uint)group >> 1) ^ 1) & 1) != (Settings.ShowSolderSide != '\0')) {
          return (int)PCB->ElementOn;
        }
      }
      else {
        if ((uVar2 == 0x20) &&
           ((bool)(((byte)((uint)group >> 1) ^ 1) & 1) != (Settings.ShowSolderSide != '\0'))) {
          return (PCB->Flags).f >> 0xd & 1;
        }
      }
    }
    else {
      if (uVar2 == 0x40) {
        return 1;
      }
      if (uVar2 == 0x60) {
        return (int)PCB->InvisibleObjectsOn;
      }
    }
    return 0;
  }
  iVar1 = PCB->Data->LayerN;
  if (group < iVar1) {
    group = (PCB->LayerGroups).Entries[group * 0x12];
    if (group < 0) goto LAB_080ecd72;
    if (iVar1 + 1 < group) {
      return 0;
    }
  }
  else {
    if (iVar1 + 1 < group) {
      return 0;
    }
  }
  return (int)*(char *)(&PCB->Data->field_0x90 + group * 0x5c);
}



void ghid_extents_use_mask(int use_it)

{
  return;
}



void ghid_notify_gui_is_up(void)

{
  ghid_gui_is_up = 1;
  return;
}



gboolean ghid_block_hook_prepare(GSource *source,gint *timeout)

{
  (*(code *)source[1].callback_data)(source[1].callback_funcs);
  return 0;
}



gboolean ghid_block_hook_check(GSource *source)

{
  return 0;
}



gboolean ghid_block_hook_dispatch(GSource *source,GSourceFunc *callback,gpointer user_data)

{
  return 0;
}



int ghid_progress(int so_far,int total,char *message)

{
  return 0;
}



int GetXY(int argc,char **argv,int x,int y)

{
  return 0;
}



int flag_flipx(int x)

{
  return ghid_flip_x;
}



int flag_flipy(int x)

{
  return ghid_flip_y;
}



void __regparm2 zoom_to(double new_zoom,int x,int y)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  double dVar8;
  GhidGui *pGVar9;
  GHidPort *pGVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  int iVar14;
  int iVar15;
  
  dVar7 = (double)(PCB->MaxWidth / gport->width);
  dVar8 = (double)(PCB->MaxHeight / gport->height);
  if (dVar8 <= dVar7) {
    dVar8 = dVar7;
  }
  dVar7 = 1.00000000;
  if (1.00000000 <= new_zoom) {
    dVar7 = new_zoom;
  }
  if (dVar8 <= dVar7 || dVar7 != dVar8) {
    dVar7 = dVar8;
  }
  if ((double)gport->zoom != dVar7) {
    iVar14 = gport->view_x;
    iVar4 = gport->view_x0;
    iVar5 = gport->view_y;
    iVar15 = gport->view_width;
    iVar6 = gport->view_y0;
    iVar3 = gport->view_height;
    *(double *)&gport->zoom = dVar7;
    pixel_slop = (int)ROUND(dVar7);
    ghid_port_ranges_scale(0);
    pGVar10 = gport;
    iVar15 = (int)ROUND((double)gport->view_x -
                        ((double)(iVar14 - iVar4) / (double)iVar15) * (double)gport->view_width);
    piVar2 = &gport->view_y;
    piVar1 = &gport->view_height;
    if (iVar15 < 0) {
      iVar15 = 0;
    }
    gport->view_x0 = iVar15;
    pGVar9 = ghidgui;
    iVar3 = (int)ROUND((double)*piVar2 - ((double)(iVar5 - iVar6) / (double)iVar3) * (double)*piVar1
                      );
    iVar14 = 0;
    if (-1 < iVar3) {
      iVar14 = iVar3;
    }
    pGVar10->view_y0 = iVar14;
    pGVar9->adjustment_changed_holdoff = 1;
    uVar11 = gtk_range_get_type();
    uVar12 = g_type_check_instance_cast(pGVar9->h_range,uVar11);
    uVar13 = (undefined4)((ulonglong)(double)iVar15 >> 0x20);
    gtk_range_set_value(uVar12,(double)iVar15);
    iVar15 = gport->view_y0;
    uVar13 = g_type_check_instance_cast(ghidgui->v_range,uVar11,uVar13);
    gtk_range_set_value(uVar13,(double)iVar15);
    ghidgui->adjustment_changed_holdoff = 0;
    ghid_port_ranges_changed();
    ghid_set_status_line_label();
    return;
  }
  ghid_set_status_line_label();
  return;
}



int SetUnits(int argc,char **argv,int x,int y)

{
  char *pcVar1;
  char cVar2;
  
  if (argc != 0) {
    pcVar1 = *argv;
    cVar2 = *pcVar1;
    if ((((cVar2 == 'm') && (pcVar1[1] == 'i')) && (pcVar1[2] == 'l')) && (pcVar1[3] == '\0')) {
      Settings.grid_units_mm = '\0';
      pcVar1 = *argv;
      cVar2 = *pcVar1;
    }
    if (((cVar2 == 'm') && (pcVar1[1] == 'm')) && (pcVar1[2] == '\0')) {
      Settings.grid_units_mm = '\x01';
    }
    ghid_config_handle_units_changed();
    ghid_set_status_line_label();
  }
  return 0;
}



int ScrollAction(int argc,char **argv,int x,int y)

{
  char *__s1;
  double y_00;
  gdouble x_00;
  int DeltaY;
  int DeltaX;
  long lVar1;
  
  if (ghidgui == (GhidGui *)0x0) {
    return 0;
  }
  if (1 < argc - 1U) {
LAB_080ed238:
    Message("Syntax error.  Usage:\n%s\n");
    return 1;
  }
  lVar1 = 0x28;
  if (argc == 2) {
    lVar1 = strtol(argv[1],(char **)0x0,10);
  }
  __s1 = *argv;
  DeltaY = strcasecmp(__s1,"up");
  if (DeltaY == 0) {
    y_00 = -(((double)ghid_port.height * (double)gport->zoom) / (double)lVar1);
  }
  else {
    DeltaY = strcasecmp(__s1,"down");
    if (DeltaY != 0) {
      DeltaY = strcasecmp(__s1,"right");
      if (DeltaY == 0) {
        x_00 = (gdouble)(((double)ghid_port.width * (double)gport->zoom) / (double)lVar1);
      }
      else {
        DeltaY = strcasecmp(__s1,"left");
        if (DeltaY != 0) goto LAB_080ed238;
        x_00 = (gdouble)-(((double)ghid_port.width * (double)gport->zoom) / (double)lVar1);
      }
      DeltaY = 0;
      DeltaX = (int)ROUND((double)x_00);
      y_00 = 0.00000000;
      goto LAB_080ed179;
    }
    y_00 = ((double)ghid_port.height * (double)gport->zoom) / (double)lVar1;
  }
  DeltaX = 0;
  DeltaY = (int)ROUND(y_00);
  x_00 = 0.00000000;
LAB_080ed179:
  HideCrosshair('\0');
  ghid_port_ranges_pan(x_00,(gdouble)y_00,1);
  MoveCrosshairRelative(DeltaX,DeltaY);
  AdjustAttachedObjects();
  RestoreCrosshair('\0');
  return 0;
}



int Save(int argc,char **argv,int x,int y)

{
  char "Save" [5];
  gchar *current_dir;
  int iVar1;
  gchar *title;
  FILE *__stream;
  gchar *message;
  gboolean gVar2;
  char *__s1;
  
  if (1 < argc) {
    iVar1 = hid_actionv("SaveTo",argc,argv);
    return iVar1;
  }
  __s1 = "Layout";
  if (argc != 0) {
    __s1 = *argv;
  }
  iVar1 = strcasecmp(__s1,"Layout");
  if ((iVar1 == 0) && (PCB->Filename != (char *)0x0)) {
    iVar1 = hid_actionl("SaveTo");
    return iVar1;
  }
  iVar1 = strcasecmp(__s1,"PasteBuffer");
  if (iVar1 == 0) {
    title = (gchar *)dcgettext(&DAT_0815492c,"Save element as",5);
  }
  else {
    title = (gchar *)dcgettext(&DAT_0815492c,"Save layout as",5);
  }
  title = ghid_dialog_file_select_save
                    (title,(gchar **)&ram0x0818d948,PCB->Filename,Settings.FilePath);
  if (title == (gchar *)0x0) {
    return 1;
  }
  __stream = fopen(title,"r");
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
    message = (gchar *)dcgettext(&DAT_0815492c,"File exists!  Ok to overwrite?",5);
    gVar2 = ghid_dialog_confirm(message,(gchar *)0x0,(gchar *)0x0);
    if (gVar2 == 0) {
      g_free(title);
      return 1;
    }
    if (Settings.verbose == 0) goto LAB_080ed3f0;
    __fprintf_chk(stderr,1,"Overwriting %s\n",title);
  }
  if (Settings.verbose != 0) {
    __fprintf_chk(stderr,1,"%s:  Calling SaveTo(%s, %s)\n","Save",__s1,title);
  }
LAB_080ed3f0:
  iVar1 = strcasecmp(__s1,"PasteBuffer");
  if (iVar1 == 0) {
    hid_actionl("PasteBuffer",0x81483d3,title,0);
  }
  else {
    iVar1 = strcasecmp(__s1,"Layout");
    if (iVar1 == 0) {
      hid_actionl("SaveTo","LayoutAs",title,0);
    }
    else {
      hid_actionl("SaveTo",__s1,title,0);
    }
  }
  g_free(title);
  return 0;
}



int RouteStylesChanged(int argc,char **argv,int x,int y)

{
  gchar *name;
  
  if ((PCB != (PCBTypePtr)0x0) && (name = PCB->RouteStyle[0].Name, name != (gchar *)0x0)) {
    ghid_route_style_set_button_label(name,0);
    ghid_route_style_set_button_label(PCB->RouteStyle[1].Name,1);
    ghid_route_style_set_button_label(PCB->RouteStyle[2].Name,2);
    ghid_route_style_set_button_label(PCB->RouteStyle[3].Name,3);
  }
  return 0;
}



int PrintCalibrate(int argc,char **argv,int x,int y)

{
  HID *pHVar1;
  int iVar2;
  
  pHVar1 = hid_find_printer();
  (*pHVar1->calibrate)(0.00000000,0.00000000);
  iVar2 = (*gui->attribute_dialog)
                    ((HID_Attribute *)printer_calibrate_attrs,3,printer_calibrate_values,
                     "Printer Calibration Values","Enter calibration values for your printer");
  if (iVar2 == 0) {
    (*pHVar1->calibrate)
              (printer_calibrate_values[1].real_value,printer_calibrate_values[2].real_value);
  }
  return (uint)(iVar2 != 0);
}



int Print(int argc,char **argv,int x,int y)

{
  HID **ppHVar1;
  anon_subr_void_char_ptr_for_log *paVar2;
  Boolean BVar3;
  HID **ppHVar4;
  char *pcVar5;
  HID *exporter;
  HID *pHVar6;
  
  ppHVar4 = hid_enumerate();
  if (*ppHVar4 != (HID *)0x0) {
    exporter = (HID *)0x0;
    pHVar6 = *ppHVar4;
    do {
      ppHVar1 = ppHVar4 + 1;
      if ((*(byte *)&pHVar6->field_0xc & 2) == 0) {
        pHVar6 = exporter;
      }
      exporter = pHVar6;
      ppHVar4 = ppHVar4 + 1;
      pHVar6 = *ppHVar1;
    } while (*ppHVar1 != (HID *)0x0);
    if (exporter != (HID *)0x0) {
      BVar3 = IsDataEmpty(PCB->Data);
      if (BVar3 != '\0') {
        paVar2 = gui->log;
        pcVar5 = (char *)dcgettext(&DAT_0815492c,"Can\'t print empty layout",5);
        (*paVar2)(pcVar5);
        return 0;
      }
      ghid_dialog_print(exporter);
      return 0;
    }
  }
  paVar2 = gui->log;
  pcVar5 = (char *)dcgettext(&DAT_0815492c,"Can\'t find a suitable printer HID",5);
  (*paVar2)(pcVar5);
  return -1;
}



int Popup(int argc,char **argv,int x,int y)

{
  size_t sVar1;
  void *__ptr;
  int **ppiVar2;
  int iVar3;
  int iVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  long lVar7;
  
  if (1 < argc - 1U) {
    Message("Syntax error.  Usage:\n%s\n","Popup(MenuName, [Button])");
    return 1;
  }
  lVar7 = 0;
  if (argc != 1) {
    lVar7 = strtol(argv[1],(char **)0x0,10);
  }
  sVar1 = strlen(*argv);
  __ptr = calloc(1,sVar1 + 2);
  if (__ptr == (void *)0x0) {
    __fprintf_chk(stderr,1,"Popup():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  __sprintf_chk(__ptr,1,0xffffffff,0x8149e29,*argv);
  __printf_chk(1,"Loading popup \"%s\". Button = %u\n",__ptr,lVar7);
  ppiVar2 = (int **)gtk_ui_manager_get_widget(ghidgui->ui_manager,__ptr);
  free(__ptr);
  iVar3 = gtk_menu_get_type();
  if (ppiVar2 != (int **)0x0) {
    if ((*ppiVar2 == (int *)0x0) || (**ppiVar2 != iVar3)) {
      iVar4 = g_type_check_instance_is_a(ppiVar2,iVar3);
      if (iVar4 == 0) goto LAB_080ed8d0;
    }
    ghidgui->in_popup = 1;
    gtk_widget_grab_focus(ghid_port.drawing_area);
    uVar5 = gtk_get_current_event_time();
    uVar6 = g_type_check_instance_cast(ppiVar2,iVar3);
    gtk_menu_popup(uVar6,0,0,0,0,0,uVar5);
    return 0;
  }
LAB_080ed8d0:
  Message("The specified popup menu \"%s\" has not been defined.\n",*argv);
  return 1;
}



int LayerGroupsChanged(int argc,char **argv,int x,int y)

{
  __printf_chk(1,"LayerGroupsChanged -- not implemented\n");
  return 0;
}



void ghid_calibrate(double xval,double yval)

{
  __printf_chk();
  return;
}



void ghid_extents_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



void ghid_extents_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  __printf_chk();
  return;
}



void ghid_extents_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  __printf_chk();
  return;
}



void ghid_extents_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



void ghid_extents_draw_arc
               (hidGC gc,int cx,int cy,int xradius,int yradius,int start_angle,int delta_angle)

{
  __printf_chk();
  return;
}



void ghid_extents_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



void ghid_set_line_cap_angle(hidGC gc,int x1,int y1,int x2,int y2)

{
  __printf_chk();
  return;
}



void ghid_set_draw_faded(hidGC gc,int faded)

{
  __printf_chk(1,"ghid_set_draw_faded(%p,%d) -- not implemented\n",gc,faded);
  return;
}



int PointCursor(int argc,char **argv,int x,int y)

{
  if (ghidgui != (GhidGui *)0x0) {
    if (argc < 1) {
      ghid_mode_cursor(Settings.Mode);
      return 0;
    }
    ghid_point_cursor();
  }
  return 0;
}



gboolean ghid_watch(GIOChannel *source,GIOCondition condition,gpointer data)

{
  GIOCondition GVar1;
  
  GVar1 = condition & G_IO_IN;
  if ((condition & G_IO_OUT) != 0) {
    GVar1 = condition & G_IO_IN | G_IO_PRI;
  }
  if ((condition & G_IO_ERR) != 0) {
    GVar1 = GVar1 | G_IO_OUT;
  }
  if ((condition & G_IO_HUP) != 0) {
    GVar1 = GVar1 | G_IO_ERR;
  }
  (**(code **)data)(data,*(undefined4 *)((int)data + 8),GVar1,*(undefined4 *)((int)data + 4));
  ghid_mode_cursor(Settings.Mode);
  return 1;
}



gboolean ghid_timer(GuiTimer *timer)

{
  (*timer->func)(timer->user_data);
  ghid_mode_cursor(Settings.Mode);
  return 0;
}



int PanAction(int argc,char **argv,int x,int y)

{
  int on_y;
  int on_x;
  int iVar1;
  
  if (ghidgui != (GhidGui *)0x0) {
    if (1 < argc - 1U) {
      Message("Syntax error.  Usage:\n%s\n","Pan([thumb], Mode)");
      return 1;
    }
    if (argc == 1) {
      iVar1 = strtol(*argv,(char **)0x0,10);
      gport->panning = iVar1;
    }
    else {
      iVar1 = strtol(argv[1],(char **)0x0,10);
      Message(
             "The gtk gui currently ignores the optional first argumentto the Pan action.\nFeel free to provide patches.\n"
             );
      gport->panning = iVar1;
    }
    if (iVar1 == 1) {
      return 0;
    }
    if ((x == on_x) && (y == on_y)) {
      ghid_show_crosshair(0);
      ghidgui->auto_pan_on = (uint)(ghidgui->auto_pan_on == 0);
      ghid_show_crosshair(1);
      return 0;
    }
  }
  return 0;
}



int Load(int argc,char **argv,int x,int y)

{
  char *shortcuts;
  char "Load" [5];
  gchar *current_netlist_dir;
  gchar *current_layout_dir;
  gchar *current_element_dir;
  int iVar1;
  gchar *title;
  char *__s1;
  char *local_28;
  
  if (1 < argc) {
    iVar1 = hid_actionv("LoadFrom",argc,argv);
    return iVar1;
  }
  __s1 = "Layout";
  if (argc != 0) {
    __s1 = *argv;
  }
  iVar1 = strcasecmp(__s1,"Netlist");
  local_28 = Settings.FilePath;
  if (iVar1 == 0) {
    title = (gchar *)dcgettext(&DAT_0815492c,"Load netlist file",5);
    title = ghid_dialog_file_select_open(title,(gchar **)&ram0x0818d954,local_28);
  }
  else {
    iVar1 = strcasecmp(__s1,"ElementToBuffer");
    local_28 = Settings.LibraryTree;
    if (iVar1 == 0) {
      title = (gchar *)dcgettext(&DAT_0815492c,"Load element to buffer",5);
      title = ghid_dialog_file_select_open(title,(gchar **)&ram0x0818d95c,local_28);
    }
    else {
      iVar1 = strcasecmp(__s1,"LayoutToBuffer");
      if (iVar1 == 0) {
        local_28 = "Load layout file to buffer";
      }
      else {
        iVar1 = strcasecmp(__s1,"Layout");
        if (iVar1 != 0) {
          return 0;
        }
        local_28 = "Load layout file";
      }
      shortcuts = Settings.FilePath;
      title = (gchar *)dcgettext(&DAT_0815492c,local_28,5);
      title = ghid_dialog_file_select_open(title,(gchar **)&ram0x0818d958,shortcuts);
    }
  }
  if (title == (gchar *)0x0) {
    return 0;
  }
  if (Settings.verbose != 0) {
    __fprintf_chk(stderr,1,"%s:  Calling LoadFrom(%s, %s)\n","Load",__s1,title);
  }
  hid_actionl("LoadFrom",__s1,title,0);
  g_free(title);
  return 0;
}



int LibraryChanged(int argc,char **argv,int x,int y)

{
  ghid_library_window_show(&ghid_port,0);
  return 0;
}



int Export(int argc,char **argv,int x,int y)

{
  anon_subr_void_char_ptr_for_log *paVar1;
  Boolean BVar2;
  char *pcVar3;
  
  BVar2 = IsDataEmpty(PCB->Data);
  if (BVar2 != '\0') {
    paVar1 = gui->log;
    pcVar3 = (char *)dcgettext(&DAT_0815492c,"Can\'t export empty layout",5);
    (*paVar1)(pcVar3);
    return 0;
  }
  ghid_dialog_export();
  return 0;
}



int DoWindows(int argc,char **argv,int x,int y)

{
  char cVar1;
  int iVar2;
  char *__s1;
  
  __s1 = "";
  if (argc == 1) {
    __s1 = *argv;
  }
  cVar1 = *__s1;
  if (((cVar1 == '1') && (__s1[1] == '\0')) || (iVar2 = strcasecmp(__s1,"Layout"), iVar2 == 0)) {
    return 0;
  }
  if (((cVar1 == '2') && (__s1[1] == '\0')) || (iVar2 = strcasecmp(__s1,"Library"), iVar2 == 0)) {
    ghid_library_window_show(gport,1);
    return 0;
  }
  if (((cVar1 != '3') || (__s1[1] != '\0')) && (iVar2 = strcasecmp(__s1,"Log"), iVar2 != 0)) {
    if (((cVar1 == '4') && (__s1[1] == '\0')) || (iVar2 = strcasecmp(__s1,"Netlist"), iVar2 == 0)) {
      ghid_netlist_window_show(gport,1);
      return 0;
    }
    if (((cVar1 != '5') || (__s1[1] != '\0')) &&
       (iVar2 = strcasecmp(__s1,"Preferences"), iVar2 != 0)) {
      if (((cVar1 != '6') || (__s1[1] != '\0')) && (iVar2 = strcasecmp(__s1,"DRC"), iVar2 != 0)) {
        Message("Syntax error.  Usage:\n%s\n",
                "DoWindows(1|2|3|4|5|6)\nDoWindows(Layout|Library|Log|Netlist|Preferences|DRC)");
        return 1;
      }
      ghid_drc_window_show(1);
      return 0;
    }
    ghid_config_window_show();
    return 0;
  }
  ghid_log_window_show(1);
  return 0;
}



int CursorAction(int argc,char **argv,int x,int y)

{
  double dVar1;
  char *__s1;
  double dVar2;
  int iVar3;
  int iVar4;
  double local_24;
  double local_1c;
  
  if (argc != 4) {
LAB_080ee268:
    Message("Syntax error.  Usage:\n%s\n","Cursor(Type,DeltaUp,DeltaRight,Units)");
    return 1;
  }
  __s1 = *argv;
  iVar3 = strcasecmp(__s1,"pan");
  if (iVar3 == 0) {
    iVar3 = 2;
  }
  else {
    iVar3 = 1;
    iVar4 = strcasecmp(__s1,"warp");
    if (iVar4 != 0) goto LAB_080ee268;
  }
  local_24 = strtod(argv[1],(char **)0x0);
  if (ghid_flip_x != 0) {
    local_24 = -local_24;
  }
  local_1c = strtod(argv[2],(char **)0x0);
  if (ghid_flip_y == 0) {
    local_1c = -local_1c;
  }
  __s1 = argv[3];
  iVar4 = strncasecmp(__s1,"mm",2);
  if (iVar4 == 0) {
    dVar1 = 3937.00787400;
    dVar2 = 3937.00787400;
  }
  else {
    iVar4 = strncasecmp(__s1,"mil",3);
    if (iVar4 == 0) {
      dVar1 = 100.00000000;
      dVar2 = 100.00000000;
    }
    else {
      iVar4 = strncasecmp(__s1,"grid",4);
      if (iVar4 == 0) {
        dVar1 = PCB->Grid;
        dVar2 = dVar1;
      }
      else {
        iVar4 = strncasecmp(__s1,"view",4);
        if (iVar4 == 0) {
          dVar1 = (double)gport->view_width / 100.00000000;
          dVar2 = (double)gport->view_height / 100.00000000;
        }
        else {
          iVar4 = strncasecmp(__s1,"board",4);
          if (iVar4 == 0) {
            dVar1 = (double)PCB->MaxWidth / 100.00000000;
            dVar2 = (double)PCB->MaxHeight / 100.00000000;
          }
          else {
            dVar1 = 0.00000000;
            dVar2 = 0.00000000;
          }
        }
      }
    }
  }
  EventMoveCrosshair((int)ROUND(dVar1 * local_24) + Crosshair.X,
                     (int)ROUND(dVar2 * local_1c) + Crosshair.Y);
  (*gui->set_crosshair)(Crosshair.X,Crosshair.Y,iVar3);
  return 0;
}



int Command(int argc,char **argv,int x,int y)

{
  ghid_handle_user_command(1);
  return 0;
}



int Busy(int argc,char **argv,int x,int y)

{
  ghid_watch_cursor();
  return 0;
}



int Benchmark(int argc,char **argv,int x,int y)

{
  undefined4 uVar1;
  int iVar2;
  BoxType region;
  time_t local_24;
  time_t local_20 [4];
  
  iVar2 = 0;
  uVar1 = gdk_drawable_get_display(gport->drawable);
  region.X1 = 0;
  region.Y1 = 0;
  region.X2 = PCB->MaxWidth;
  region.Y2 = PCB->MaxHeight;
  gdk_display_sync(uVar1);
  time(local_20);
  do {
    iVar2 = iVar2 + 1;
    hid_expose_callback(&ghid_hid,&region,(void *)0x0);
    gdk_display_sync(uVar1);
    time(&local_24);
  } while (local_24 - local_20[0] < 10);
  __printf_chk(1,"%g redraws per second\n",(double)((float)iVar2 / 10.00000000));
  return 0;
}



int About(int argc,char **argv,int x,int y)

{
  ghid_dialog_about();
  return 0;
}



void ghid_stop_block_hook(hidval mlpoll)

{
  g_source_destroy();
  return;
}



anon_subr_void_hidval * ghid_add_block_hook(anon_subr_void_hidval *func,undefined4 user_data)

{
  int iVar1;
  undefined4 in_stack_0000000c;
  
  iVar1 = g_source_new(&ghid_block_hook_funcs,0x3c);
  *(undefined4 *)(iVar1 + 0x34) = user_data;
  *(undefined4 *)(iVar1 + 0x38) = in_stack_0000000c;
  g_source_attach(iVar1,0);
  *(int *)func = iVar1;
  return func;
}



void register_ghid_main_flag_list(void)

{
  hid_register_flags(ghid_main_flag_list,2);
  return;
}



void register_ghid_main_action_list(void)

{
  hid_register_actions(ghid_main_action_list,0x18);
  return;
}



void hid_gtk_init(void)

{
  hid_register_hid(&ghid_hid);
  apply_default_hid(&ghid_extents,&ghid_hid);
  register_ghid_main_action_list();
  register_ghid_main_flag_list();
  register_ghid_netlist_action_list();
  register_ghid_attribute_list();
  register_gtk_topwindow_action_list();
  register_pcbmenu_attr();
  register_ghid_menu_action_list();
  return;
}



int PCBChanged(int argc,char **argv,int x,int y)

{
  if (ghidgui != (GhidGui *)0x0) {
    ghid_window_set_name_label(PCB->Name);
    if (gport->pixmap != (GdkPixmap *)0x0) {
      RouteStylesChanged(0,(char **)0x0,0,0);
      ghid_port_ranges_scale(1);
      ghid_port_ranges_pan(0.00000000,0.00000000,0);
      ghid_port_ranges_zoom(0.00000000);
      ghid_port_ranges_changed();
      ghid_sync_with_new_layout();
    }
  }
  return 0;
}



void ghid_beep(void)

{
  gdk_beep();
  return;
}



void ghid_show_item(void *item)

{
  ghid_pinout_window_show(&ghid_port,(ElementType *)item);
  return;
}



char * ghid_prompt_for(char *msg,char *default_string)

{
  gchar *pgVar1;
  
  pgVar1 = ghid_dialog_input(msg,default_string);
  return pgVar1;
}



void ghid_report_dialog(char *title,char *msg)

{
  ghid_dialog_report(title,msg);
  return;
}



int ghid_close_confirm_dialog(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = ghid_dialog_close_confirm();
  iVar2 = 1;
  if ((iVar1 != 1) && (iVar2 = 0, iVar1 == 2)) {
    iVar1 = hid_actionl("Save",0);
    return (uint)(iVar1 == 0);
  }
  return iVar2;
}



int ghid_confirm_dialog(char *msg,...)

{
  gboolean gVar1;
  gchar *in_stack_00000008;
  gchar *in_stack_0000000c;
  
  if (in_stack_00000008 == (gchar *)0x0) {
    in_stack_00000008 = (gchar *)dcgettext(&DAT_0815492c,"_Cancel",5);
    in_stack_0000000c = (gchar *)dcgettext(&DAT_0815492c,&DAT_08152330,5);
  }
  if (in_stack_0000000c == (gchar *)0x0) {
    in_stack_0000000c = (gchar *)dcgettext(&DAT_0815492c,&DAT_08152330,5);
  }
  gVar1 = ghid_dialog_confirm(msg,in_stack_00000008,in_stack_0000000c);
  return gVar1;
}



void ghid_unwatch_file(int data)

{
  g_io_channel_shutdown(*(undefined4 *)(data + 0xc),1,0);
  g_io_channel_unref(*(undefined4 *)(data + 0xc));
  g_free();
  return;
}



int ghid_watch_file(int fd,uint condition,anon_subr_void_hidval_int_uint_hidval *func,
                   undefined4 user_data)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  uint uVar3;
  undefined4 in_stack_00000014;
  
  puVar1 = (undefined4 *)g_malloc0(0x14);
  uVar3 = (uint)func & 1;
  if (((uint)func & 2) != 0) {
    uVar3 = (uint)func & 1 | 4;
  }
  if (((uint)func & 4) != 0) {
    uVar3 = uVar3 | 8;
  }
  if (((uint)func & 8) != 0) {
    uVar3 = uVar3 | 0x10;
  }
  puVar1[2] = condition;
  *puVar1 = user_data;
  puVar1[1] = in_stack_00000014;
  uVar2 = g_io_channel_unix_new(condition);
  puVar1[3] = uVar2;
  uVar2 = g_io_add_watch(uVar2,uVar3,ghid_watch,puVar1);
  puVar1[4] = uVar2;
  *(undefined4 **)fd = puVar1;
  return fd;
}



void ghid_stop_timer(int timer)

{
  gtk_timeout_remove(*(undefined4 *)(timer + 4));
  g_free();
  return;
}



anon_subr_void_hidval *
ghid_add_timer(anon_subr_void_hidval *func,ulong milliseconds,undefined4 user_data)

{
  ulong *puVar1;
  ulong uVar2;
  ulong in_stack_00000010;
  
  puVar1 = (ulong *)g_malloc0(0xc);
  *puVar1 = milliseconds;
  puVar1[2] = in_stack_00000010;
  uVar2 = gtk_timeout_add(user_data,ghid_timer,puVar1);
  puVar1[1] = uVar2;
  *(ulong **)func = puVar1;
  return func;
}



gboolean ghid_mod1_is_pressed(void)

{
  uint local_10 [3];
  
  if (ghid_gui_is_up == 0) {
    return 0;
  }
  gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  return local_10[0] >> 3 & 1;
}



gboolean ghid_control_is_pressed(void)

{
  uint local_10 [3];
  
  if (ghid_gui_is_up == 0) {
    return 0;
  }
  gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  return local_10[0] >> 2 & 1;
}



gboolean ghid_shift_is_pressed(void)

{
  uint local_10 [3];
  
  if (ghid_gui_is_up == 0) {
    return 0;
  }
  gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  return local_10[0] & 1;
}



void ghid_set_line_width(hidGC gc,int width)

{
  GdkGC *pGVar1;
  
  pGVar1 = (GdkGC *)gc[1].nothing_interesting_here;
  gc[3].nothing_interesting_here = width;
  if (pGVar1 != (GdkGC *)0x0) {
    if (cur_mask == 2) {
      pGVar1 = gport->mask_gc;
    }
    gdk_gc_set_line_attributes
              (pGVar1,(int)ROUND((double)width / (double)gport->zoom + 0.50000000),0,
               gc[4].nothing_interesting_here,gc[5].nothing_interesting_here);
  }
  return;
}



void ghid_set_line_cap(hidGC gc,EndCapStyle style)

{
  GdkGC *pGVar1;
  
  if (style != Square_Cap) {
    if ((style == Trace_Cap) || (style == Round_Cap)) {
      gc[4].nothing_interesting_here = 2;
      gc[5].nothing_interesting_here = 1;
      goto LAB_080eea33;
    }
    if (style != Beveled_Cap) goto LAB_080eea33;
  }
  gc[4].nothing_interesting_here = 3;
  gc[5].nothing_interesting_here = 0;
LAB_080eea33:
  pGVar1 = (GdkGC *)gc[1].nothing_interesting_here;
  if (pGVar1 != (GdkGC *)0x0) {
    if (cur_mask == 2) {
      pGVar1 = gport->mask_gc;
    }
    gdk_gc_set_line_attributes
              (pGVar1,(int)ROUND((double)gc[3].nothing_interesting_here / (double)gport->zoom +
                                 0.50000000),0,gc[4].nothing_interesting_here,
               gc[5].nothing_interesting_here);
  }
  return;
}



void set_special_grid_color(void)

{
  ushort *puVar1;
  GHidPort *pGVar2;
  
  pGVar2 = gport;
  if (gport->colormap != (GdkColormap *)0x0) {
    puVar1 = &(gport->grid_color).red;
    *puVar1 = *puVar1 ^ (gport->bg_color).red;
    puVar1 = &(pGVar2->grid_color).green;
    *puVar1 = *puVar1 ^ (pGVar2->bg_color).green;
    puVar1 = &(pGVar2->grid_color).blue;
    *puVar1 = *puVar1 ^ (pGVar2->bg_color).blue;
    gdk_color_alloc(pGVar2->colormap,&pGVar2->grid_color);
    if (gport->grid_gc != (GdkGC *)0x0) {
      gdk_gc_set_foreground(gport->grid_gc,&gport->grid_color);
    }
  }
  return;
}



void ghid_set_color(hidGC gc,char *name)

{
  int *piVar1;
  GHidPort *pGVar2;
  char "ghid_set_color" [15];
  void *cache;
  GdkColormap *pGVar3;
  int iVar4;
  uint uVar5;
  char *pcVar6;
  int *piVar7;
  char *pcVar8;
  bool bVar9;
  byte bVar10;
  int *cval;
  
  bVar10 = 0;
  if (name == (char *)0x0) {
    __fprintf_chk(stderr,1,"%s():  name = NULL, setting to magenta\n","ghid_set_color");
    name = "magenta";
  }
  *(char **)&gc[2].nothing_interesting_here = name;
  pGVar2 = gport;
  if (gc[1].nothing_interesting_here != 0) {
    bVar9 = gport->colormap == (GdkColormap *)0x0;
    if (bVar9) {
      pGVar3 = (GdkColormap *)gtk_widget_get_colormap(gport->top_window);
      pGVar2->colormap = pGVar3;
    }
    iVar4 = 6;
    pcVar6 = name;
    pcVar8 = "erase";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar9 = *pcVar6 == *pcVar8;
      pcVar6 = pcVar6 + 1 + (uint)bVar10 * -2;
      pcVar8 = pcVar8 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      gdk_gc_set_foreground(gc[1].nothing_interesting_here,&gport->bg_color);
      *(undefined *)((int)&gc[6].nothing_interesting_here + 1) = 1;
    }
    else {
      iVar4 = 6;
      pcVar6 = name;
      pcVar8 = "drill";
      do {
        if (iVar4 == 0) break;
        iVar4 = iVar4 + -1;
        bVar9 = *pcVar6 == *pcVar8;
        pcVar6 = pcVar6 + 1 + (uint)bVar10 * -2;
        pcVar8 = pcVar8 + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      if (bVar9) {
        gdk_gc_set_foreground(gc[1].nothing_interesting_here,&gport->offlimits_color);
        *(undefined *)((int)&gc[6].nothing_interesting_here + 1) = 0;
      }
      else {
        iVar4 = hid_cache_color(0,name,&cval,(void **)&ram0x0818d970);
        piVar7 = cval;
        if (iVar4 == 0) {
          piVar7 = (int *)calloc(1,0x20);
          uVar5 = 0;
          do {
            *(undefined4 *)((int)piVar7 + uVar5) = 0;
            uVar5 = uVar5 + 4;
          } while (uVar5 < 0x20);
          cval = piVar7;
          hid_cache_color(1,name,&cval,(void **)0x818d970);
        }
        if (*piVar7 == 0) {
          piVar1 = piVar7 + 1;
          iVar4 = gdk_color_parse(name,piVar1);
          if (iVar4 == 0) {
            gdk_color_white(gport->colormap,piVar1);
          }
          else {
            gdk_color_alloc(gport->colormap,piVar1);
          }
          *piVar7 = 1;
        }
        pGVar2 = gport;
        if (*(char *)&gc[6].nothing_interesting_here == '\0') {
          gdk_gc_set_foreground(gc[1].nothing_interesting_here,piVar7 + 1);
        }
        else {
          if (piVar7[4] == 0) {
            *(guint16 *)(piVar7 + 6) = (gport->bg_color).red ^ *(ushort *)(piVar7 + 2);
            *(ushort *)((int)piVar7 + 0x1a) =
                 (pGVar2->bg_color).green ^ *(ushort *)((int)piVar7 + 10);
            *(guint16 *)(piVar7 + 7) = (pGVar2->bg_color).blue ^ *(ushort *)(piVar7 + 3);
            gdk_color_alloc(pGVar2->colormap,piVar7 + 5);
            piVar7[4] = 1;
          }
          gdk_gc_set_foreground(gc[1].nothing_interesting_here,piVar7 + 5);
        }
        *(undefined *)((int)&gc[6].nothing_interesting_here + 1) = 0;
      }
    }
  }
  return;
}



void ghid_set_draw_xor(hidGC gc,int xor)

{
  *(char *)&gc[6].nothing_interesting_here = (char)xor;
  if (gc[1].nothing_interesting_here != 0) {
    gdk_gc_set_function(gc[1].nothing_interesting_here,~-(uint)(xor == 0) & 2);
    ghid_set_color(gc,(char *)gc[2].nothing_interesting_here);
    return;
  }
  return;
}



int __regparm3 use_gc(hidGC gc)

{
  int iVar1;
  GdkGC *pGVar2;
  
  iVar1 = 0;
  if (gport->pixmap != (GdkPixmap *)0x0) {
    if (gc[1].nothing_interesting_here == 0) {
      iVar1 = gdk_gc_new(gport->top_window->window);
      gc[1].nothing_interesting_here = iVar1;
      ghid_set_color(gc,(char *)gc[2].nothing_interesting_here);
      ghid_set_line_width(gc,gc[3].nothing_interesting_here);
      ghid_set_line_cap(gc,gc[4].nothing_interesting_here);
      ghid_set_draw_xor(gc,(int)*(char *)&gc[6].nothing_interesting_here);
    }
    if (gc[7].nothing_interesting_here != mask_seq) {
      if (mask_seq == 0) {
        gdk_gc_set_clip_mask(gc[1].nothing_interesting_here,0);
      }
      else {
        gdk_gc_set_clip_mask(gc[1].nothing_interesting_here,gport->mask);
      }
      gc[7].nothing_interesting_here = mask_seq;
    }
    if (cur_mask == 2) {
      pGVar2 = gport->mask_gc;
    }
    else {
      pGVar2 = (GdkGC *)gc[1].nothing_interesting_here;
    }
    gport->u_gc = pGVar2;
    iVar1 = 1;
  }
  return iVar1;
}



void ghid_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  GHidPort *pGVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  iVar4 = cx;
  if (ghid_flip_x != 0) {
    iVar4 = PCB->MaxWidth - cx;
  }
  if (gport->view_x0 - radius <= iVar4) {
    iVar4 = cx;
    if (ghid_flip_x != 0) {
      iVar4 = PCB->MaxWidth - cx;
    }
    if (iVar4 <= (int)ROUND((double)gport->width * (double)gport->zoom) + gport->view_x0 + radius) {
      iVar4 = cy;
      if (ghid_flip_y != 0) {
        iVar4 = PCB->MaxHeight - cy;
      }
      if (gport->view_y0 - radius <= iVar4) {
        iVar4 = cy;
        if (ghid_flip_y != 0) {
          iVar4 = PCB->MaxHeight - cy;
        }
        if ((iVar4 <= (int)ROUND((double)gport->height * (double)gport->zoom) + gport->view_y0 +
                      radius) && (iVar4 = use_gc(gc), pGVar1 = gport, iVar4 != 0)) {
          iVar4 = (int)ROUND((double)radius / (double)gport->zoom + 0.50000000);
          iVar2 = Vy(cy);
          iVar3 = Vx(cx);
          gdk_draw_arc(pGVar1->drawable,pGVar1->u_gc,1,iVar3 - iVar4,iVar2 - iVar4,iVar4 * 2,
                       iVar4 * 2,0,0x5a00);
        }
      }
    }
  }
  return;
}



void ghid_draw_arc(hidGC gc,int cx,int cy,int xradius,int yradius,int start_angle,int delta_angle)

{
  GHidPort *pGVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  
  iVar2 = xradius;
  if (xradius <= yradius) {
    iVar2 = yradius;
  }
  iVar5 = cx;
  if (ghid_flip_x != 0) {
    iVar5 = PCB->MaxWidth - cx;
  }
  if (gport->view_x0 - iVar2 <= iVar5) {
    iVar5 = cx;
    if (ghid_flip_x != 0) {
      iVar5 = PCB->MaxWidth - cx;
    }
    if (iVar5 <= (int)ROUND((double)gport->width * (double)gport->zoom) + gport->view_x0 + iVar2) {
      iVar5 = cy;
      if (ghid_flip_y != 0) {
        iVar5 = PCB->MaxHeight - cy;
      }
      if (gport->view_y0 - iVar2 <= iVar5) {
        iVar5 = cy;
        if (ghid_flip_y != 0) {
          iVar5 = PCB->MaxHeight - cy;
        }
        if ((iVar5 <= (int)ROUND((double)gport->height * (double)gport->zoom) + gport->view_y0 +
                      iVar2) && (iVar2 = use_gc(gc), pGVar1 = gport, iVar2 != 0)) {
          iVar2 = (int)ROUND((double)xradius / (double)gport->zoom + 0.50000000);
          iVar5 = (int)ROUND((double)gport->zoom / (double)yradius + 0.50000000);
          if (ghid_flip_x != 0) {
            delta_angle = -delta_angle;
            start_angle = 0xb4 - start_angle;
          }
          if (ghid_flip_y != 0) {
            start_angle = -start_angle;
            delta_angle = -delta_angle;
          }
          iVar3 = Vy(cy);
          iVar4 = Vx(cx);
          gdk_draw_arc(pGVar1->drawable,pGVar1->u_gc,0,iVar4 - iVar2,iVar3 - iVar5,iVar2 * 2,
                       iVar5 * 2,((start_angle + 0x21c) % 0x168) * 0x40,delta_angle << 6);
        }
      }
    }
  }
  return;
}



void ghid_set_special_colors(HID_Attribute *ha)

{
  char **ppcVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  
  pcVar4 = ha->name;
  if (pcVar4 == (char *)0x0) {
    return;
  }
  ppcVar1 = (char **)ha->value;
  bVar6 = ppcVar1 == (char **)0x0;
  if (bVar6) {
    return;
  }
  iVar2 = 0x11;
  pcVar3 = pcVar4;
  pcVar5 = "background-color";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar6 = *pcVar3 == *pcVar5;
    pcVar3 = pcVar3 + 1;
    pcVar5 = pcVar5 + 1;
  } while (bVar6);
  if ((!bVar6) || (bVar6 = gport->bg_gc == (GdkGC *)0x0, bVar6)) {
    iVar2 = 0x10;
    pcVar3 = pcVar4;
    pcVar5 = "off-limit-color";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar6 = *pcVar3 == *pcVar5;
      pcVar3 = pcVar3 + 1;
      pcVar5 = pcVar5 + 1;
    } while (bVar6);
    if ((bVar6) && (bVar6 = gport->offlimits_gc == (GdkGC *)0x0, !bVar6)) {
      ghid_map_color_string(*ppcVar1,&gport->offlimits_color);
      gdk_gc_set_foreground(gport->offlimits_gc,&gport->offlimits_color);
      return;
    }
    iVar2 = 0xb;
    pcVar3 = "grid-color";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar6 = *pcVar4 == *pcVar3;
      pcVar4 = pcVar4 + 1;
      pcVar3 = pcVar3 + 1;
    } while (bVar6);
    if (!bVar6) {
      return;
    }
    if (gport->grid_gc == (GdkGC *)0x0) {
      return;
    }
    ghid_map_color_string(*ppcVar1,&gport->grid_color);
  }
  else {
    ghid_map_color_string(*ppcVar1,&gport->bg_color);
    gdk_gc_set_foreground(gport->bg_gc,&gport->bg_color);
  }
  set_special_grid_color();
  return;
}



void ghid_use_mask(int use_it)

{
  GHidPort *pGVar1;
  GdkDrawable *old;
  int mask_seq_id;
  GdkPixmap *pGVar2;
  GdkGC *pGVar3;
  GdkColor color;
  
  pGVar1 = gport;
  if (use_it == 6) {
    gdk_flush();
  }
  else {
    if (use_it == 4) {
      *(GdkWindow **)&gport->drawable = gport->drawing_area->window;
      return;
    }
    if (use_it == 5) {
      gport->drawable = old;
      return;
    }
    pGVar2 = gport->pixmap;
    if ((pGVar2 != (GdkPixmap *)0x0) && (use_it != cur_mask)) {
      if (use_it == 1) {
        __printf_chk(1,"gtk doesn\'t support mask_before!\n");
                    // WARNING: Subroutine does not return
        abort();
      }
      if (use_it < 2) {
        if (use_it == 0) {
          *(GdkPixmap **)&gport->drawable = pGVar2;
          mask_seq = 0;
        }
      }
      else {
        if (use_it == 2) {
          pGVar2 = gport->mask;
          if (pGVar2 == (GdkPixmap *)0x0) {
            pGVar2 = (GdkPixmap *)gdk_pixmap_new(0,gport->width,gport->height,1);
            pGVar1->mask = pGVar2;
            pGVar2 = gport->mask;
          }
          pGVar1 = gport;
          pGVar3 = gport->mask_gc;
          *(GdkPixmap **)&gport->drawable = pGVar2;
          mask_seq = 0;
          if (pGVar3 == (GdkGC *)0x0) {
            pGVar3 = (GdkGC *)gdk_gc_new(pGVar2);
            pGVar1->mask_gc = pGVar3;
            pGVar3 = gport->mask_gc;
          }
          color.pixel = 1;
          gdk_gc_set_foreground(pGVar3,&color);
          gdk_draw_rectangle(gport->drawable,gport->mask_gc,1,0,0,gport->width,gport->height);
          color.pixel = 0;
          gdk_gc_set_foreground(gport->mask_gc,&color);
        }
        else {
          if (use_it == 3) {
            mask_seq = mask_seq_id + 1;
            if (mask_seq == 0) {
              mask_seq = 1;
            }
            *(GdkPixmap **)&gport->drawable = pGVar2;
          }
        }
      }
      cur_mask = use_it;
    }
  }
  return;
}



void ghid_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  int iVar1;
  GdkPoint *pGVar2;
  PCBTypePtr pPVar3;
  GHidPort *pGVar4;
  char "ghid_fill_polygon" [18];
  int npoints;
  GdkPoint *points;
  int iVar5;
  int iVar6;
  int local_20;
  
  iVar5 = use_gc(gc);
  if (iVar5 != 0) {
    if (npoints < n_coords) {
      npoints = n_coords + 1;
      points = (GdkPoint *)MyRealloc(points,npoints * 8,"ghid_fill_polygon");
    }
    pGVar4 = gport;
    pPVar3 = PCB;
    pGVar2 = points;
    iVar1 = ghid_flip_y;
    iVar5 = ghid_flip_x;
    if (0 < n_coords) {
      iVar6 = 0;
      do {
        if (iVar5 == 0) {
          pGVar2[iVar6].x =
               (int)ROUND((float)(x[iVar6] - pGVar4->view_x0) / (float)(double)pGVar4->zoom +
                          0.50000000);
          local_20 = y[iVar6];
          if (iVar1 != 0) goto LAB_080ef71a;
LAB_080ef6aa:
          local_20 = local_20 - pGVar4->view_y0;
        }
        else {
          pGVar2[iVar6].x =
               (int)ROUND((double)((pPVar3->MaxWidth - x[iVar6]) - pGVar4->view_x0) /
                          (double)pGVar4->zoom + 0.50000000);
          local_20 = y[iVar6];
          if (iVar1 == 0) goto LAB_080ef6aa;
LAB_080ef71a:
          local_20 = (pPVar3->MaxHeight - local_20) - pGVar4->view_y0;
        }
        pGVar2[iVar6].y = (int)ROUND((double)local_20 / (double)pGVar4->zoom + 0.50000000);
        iVar6 = iVar6 + 1;
      } while (iVar6 != n_coords);
    }
    gdk_draw_polygon(pGVar4->drawable,pGVar4->u_gc,1,pGVar2,n_coords);
  }
  return;
}



void ghid_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  double dVar2;
  Boolean BVar3;
  int iVar4;
  gint gVar5;
  int local_4c;
  int local_44;
  double local_3c;
  double local_34;
  double local_2c;
  double local_24 [2];
  
  if (ghid_flip_x == 0) {
    local_44 = gport->view_x0;
    dVar2 = (double)gport->zoom;
    dVar1 = (double)((int)ROUND((float10)x1) - local_44) / dVar2;
  }
  else {
    local_44 = gport->view_x0;
    dVar2 = (double)gport->zoom;
    dVar1 = (double)((PCB->MaxWidth - (int)ROUND((float10)x1)) - local_44) / dVar2;
  }
  local_4c = (int)ROUND(dVar1 + 0.50000000);
  iVar4 = (int)ROUND((float10)y1);
  if (ghid_flip_y == 0) {
    gVar5 = gport->view_y0;
  }
  else {
    gVar5 = gport->view_y0;
    iVar4 = PCB->MaxHeight - iVar4;
  }
  if (ghid_flip_x == 0) {
    local_44 = (int)ROUND((float10)x2) - local_44;
  }
  else {
    local_44 = (PCB->MaxWidth - (int)ROUND((float10)x2)) - local_44;
  }
  dVar1 = (double)local_44;
  if (ghid_flip_y == 0) {
    local_44 = (int)ROUND((float10)y2) - gVar5;
  }
  else {
    local_44 = (PCB->MaxHeight - (int)ROUND((float10)y2)) - gVar5;
  }
  local_3c = (double)(int)ROUND((double)local_44 / dVar2 + 0.50000000);
  local_34 = (double)(int)ROUND(dVar1 / dVar2 + 0.50000000);
  local_2c = (double)(int)ROUND((double)(iVar4 - gVar5) / dVar2 + 0.50000000);
  local_24[0] = (double)local_4c;
  BVar3 = ClipLine(0.00000000,0.00000000,(double)gport->width,(double)gport->height,local_24,
                   &local_2c,&local_34,&local_3c,(double)gc[3].nothing_interesting_here / dVar2);
  if (BVar3 != '\0') {
    iVar4 = use_gc(gc);
    if (iVar4 != 0) {
      gdk_draw_line(gport->drawable,gport->u_gc,(int)ROUND(local_24[0]),(int)ROUND(local_2c),
                    (int)ROUND(local_34),(int)ROUND(local_3c));
      return;
    }
  }
  return;
}



void ghid_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int local_2c;
  int local_28;
  int local_20;
  
  iVar2 = gc[3].nothing_interesting_here;
  dVar1 = (double)gport->zoom;
  iVar4 = x1;
  if (ghid_flip_x != 0) {
    iVar4 = PCB->MaxWidth - x1;
  }
  local_20 = gport->view_x0;
  iVar5 = local_20 - iVar2;
  if (iVar4 < iVar5) {
    if (ghid_flip_x == 0) {
      if (x2 < iVar5) {
        return;
      }
    }
    else {
      if (PCB->MaxWidth - x2 < iVar5) {
        return;
      }
    }
  }
  local_28 = x1;
  if (ghid_flip_x != 0) {
    local_28 = PCB->MaxWidth - x1;
  }
  iVar4 = (int)ROUND((double)gport->width * dVar1) + local_20 + iVar2;
  if (iVar4 < local_28) {
    iVar5 = x2;
    if (ghid_flip_x != 0) {
      iVar5 = PCB->MaxWidth - x2;
    }
    if (iVar4 < iVar5) {
      return;
    }
  }
  if (ghid_flip_y == 0) {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= y1) goto LAB_080efb08;
  }
  else {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= PCB->MaxHeight - y1) goto LAB_080efb08;
  }
  if (ghid_flip_y == 0) {
    if (y2 < local_2c) {
      return;
    }
  }
  else {
    if (PCB->MaxHeight - y2 < local_2c) {
      return;
    }
  }
LAB_080efb08:
  iVar5 = y1;
  if (ghid_flip_y != 0) {
    iVar5 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)gport->height * dVar1) + iVar4 + iVar2;
  if (iVar2 < iVar5) {
    iVar5 = y2;
    if (ghid_flip_y != 0) {
      iVar5 = PCB->MaxHeight - y2;
    }
    if (iVar2 < iVar5) {
      return;
    }
  }
  if (ghid_flip_x != 0) {
    x1 = PCB->MaxWidth - x1;
  }
  local_28 = (int)ROUND((double)(x1 - local_20) / dVar1 + 0.50000000);
  if (ghid_flip_y != 0) {
    y1 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)(y1 - iVar4) / dVar1 + 0.50000000);
  if (ghid_flip_x == 0) {
    local_20 = x2 - local_20;
  }
  else {
    local_20 = (PCB->MaxWidth - x2) - local_20;
  }
  iVar5 = (int)ROUND((double)local_20 / dVar1 + 0.50000000);
  if (ghid_flip_y == 0) {
    local_20 = y2 - iVar4;
  }
  else {
    local_20 = (PCB->MaxHeight - y2) - iVar4;
  }
  iVar4 = (int)ROUND((double)local_20 / dVar1 + 0.50000000);
  iVar3 = iVar5;
  if (iVar5 < local_28) {
    iVar3 = local_28;
    local_28 = iVar5;
  }
  iVar5 = iVar2;
  if (iVar4 < iVar2) {
    iVar5 = iVar4;
    iVar4 = iVar2;
  }
  iVar2 = use_gc(gc);
  if (iVar2 == 0) {
    return;
  }
  gdk_draw_rectangle(gport->drawable,gport->u_gc,1,local_28,iVar5,(iVar3 + 1) - local_28,
                     (iVar4 + 1) - iVar5);
  return;
}



void ghid_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int local_2c;
  int local_28;
  int local_20;
  
  iVar2 = gc[3].nothing_interesting_here;
  dVar1 = (double)gport->zoom;
  iVar4 = x1;
  if (ghid_flip_x != 0) {
    iVar4 = PCB->MaxWidth - x1;
  }
  local_20 = gport->view_x0;
  iVar5 = local_20 - iVar2;
  if (iVar4 < iVar5) {
    if (ghid_flip_x == 0) {
      if (x2 < iVar5) {
        return;
      }
    }
    else {
      if (PCB->MaxWidth - x2 < iVar5) {
        return;
      }
    }
  }
  local_28 = x1;
  if (ghid_flip_x != 0) {
    local_28 = PCB->MaxWidth - x1;
  }
  iVar4 = (int)ROUND((double)gport->width * dVar1) + local_20 + iVar2;
  if (iVar4 < local_28) {
    iVar5 = x2;
    if (ghid_flip_x != 0) {
      iVar5 = PCB->MaxWidth - x2;
    }
    if (iVar4 < iVar5) {
      return;
    }
  }
  if (ghid_flip_y == 0) {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= y1) goto LAB_080efea8;
  }
  else {
    iVar4 = gport->view_y0;
    local_2c = iVar4 - iVar2;
    if (local_2c <= PCB->MaxHeight - y1) goto LAB_080efea8;
  }
  if (ghid_flip_y == 0) {
    if (y2 < local_2c) {
      return;
    }
  }
  else {
    if (PCB->MaxHeight - y2 < local_2c) {
      return;
    }
  }
LAB_080efea8:
  iVar5 = y1;
  if (ghid_flip_y != 0) {
    iVar5 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)gport->height * dVar1) + iVar4 + iVar2;
  if (iVar2 < iVar5) {
    iVar5 = y2;
    if (ghid_flip_y != 0) {
      iVar5 = PCB->MaxHeight - y2;
    }
    if (iVar2 < iVar5) {
      return;
    }
  }
  if (ghid_flip_x != 0) {
    x1 = PCB->MaxWidth - x1;
  }
  local_28 = (int)ROUND((double)(x1 - local_20) / dVar1 + 0.50000000);
  if (ghid_flip_y != 0) {
    y1 = PCB->MaxHeight - y1;
  }
  iVar2 = (int)ROUND((double)(y1 - iVar4) / dVar1 + 0.50000000);
  if (ghid_flip_x == 0) {
    local_20 = x2 - local_20;
  }
  else {
    local_20 = (PCB->MaxWidth - x2) - local_20;
  }
  iVar5 = (int)ROUND((double)local_20 / dVar1 + 0.50000000);
  if (ghid_flip_y == 0) {
    local_20 = y2 - iVar4;
  }
  else {
    local_20 = (PCB->MaxHeight - y2) - iVar4;
  }
  iVar4 = (int)ROUND((double)local_20 / dVar1 + 0.50000000);
  iVar3 = iVar5;
  if (iVar5 < local_28) {
    iVar3 = local_28;
    local_28 = iVar5;
  }
  iVar5 = iVar2;
  if (iVar4 < iVar2) {
    iVar5 = iVar4;
    iVar4 = iVar2;
  }
  iVar2 = use_gc(gc);
  if (iVar2 == 0) {
    return;
  }
  gdk_draw_rectangle(gport->drawable,gport->u_gc,0,local_28,iVar5,(iVar3 + 1) - local_28,
                     (iVar4 + 1) - iVar5);
  return;
}



void ghid_invalidate_all(void)

{
  ushort *puVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  GdkPoint *pGVar8;
  GHidPort *pGVar9;
  PCBTypePtr pPVar10;
  undefined4 uVar11;
  int iVar12;
  GdkGC *pGVar13;
  int iVar14;
  int iVar15;
  GdkPixbuf *pGVar16;
  int iVar17;
  gint gVar18;
  int iVar19;
  int iVar20;
  int local_80;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_30;
  BoxType region;
  
  if (gport->pixmap == (GdkPixmap *)0x0) {
    return;
  }
  dVar2 = (double)gport->zoom;
  iVar19 = gport->view_x0;
  dVar3 = (double)iVar19;
  dVar7 = dVar2 * 0.00000000 + dVar3;
  local_80 = (int)ROUND(dVar7);
  if (ghid_flip_x == 0) {
    local_40 = gport->width;
    dVar4 = (double)(local_40 + 1) * dVar2 + dVar3;
    local_58 = (int)ROUND(dVar4);
    if (local_58 <= local_80) goto LAB_080f0ba0;
LAB_080f01e3:
    local_58 = local_80;
    if (ghid_flip_x != 0) {
      local_58 = (int)ROUND((double)PCB->MaxWidth - dVar7);
    }
  }
  else {
    local_40 = gport->width;
    dVar4 = (double)(local_40 + 1) * dVar2 + dVar3;
    local_58 = (int)ROUND(dVar4);
    if ((int)ROUND((double)PCB->MaxWidth - dVar7) < (int)ROUND((double)PCB->MaxWidth - dVar4))
    goto LAB_080f01e3;
LAB_080f0ba0:
    if (ghid_flip_x != 0) {
      local_58 = (int)ROUND((double)PCB->MaxWidth - dVar4);
    }
  }
  iVar15 = gport->view_y0;
  dVar4 = (double)iVar15;
  dVar6 = dVar2 * 0.00000000 + dVar4;
  region.Y2 = (LocationType)ROUND(dVar6);
  if (ghid_flip_y == 0) {
    local_50 = gport->height;
    dVar5 = (double)(local_50 + 1) * dVar2 + dVar4;
    local_4c = (int)ROUND(dVar5);
    local_54 = region.Y2;
    local_48 = local_4c;
  }
  else {
    local_50 = gport->height;
    dVar5 = (double)(local_50 + 1) * dVar2 + dVar4;
    local_48 = (int)ROUND(dVar5);
    local_4c = (int)ROUND((double)PCB->MaxHeight - dVar5);
    local_54 = (int)ROUND((double)PCB->MaxHeight - dVar6);
  }
  if (local_54 < local_4c) {
    local_48 = region.Y2;
    if (ghid_flip_y != 0) {
      local_48 = (int)ROUND((double)PCB->MaxHeight - dVar6);
    }
LAB_080f028f:
    if (ghid_flip_x == 0) goto LAB_080f0d39;
LAB_080f0297:
    dVar3 = (double)(local_40 + 1) * dVar2 + dVar3;
    local_54 = (int)ROUND(dVar3);
    if ((int)ROUND((double)PCB->MaxWidth - dVar7) <= (int)ROUND((double)PCB->MaxWidth - dVar3))
    goto LAB_080f0d74;
LAB_080f02e8:
    if (ghid_flip_x != 0) {
      local_80 = (int)ROUND((double)PCB->MaxWidth - dVar7);
    }
LAB_080f0307:
    if (ghid_flip_y == 0) goto LAB_080f0d9d;
LAB_080f030f:
    dVar4 = (double)(local_50 + 1) * dVar2 + dVar4;
    local_50 = (int)ROUND(dVar4);
    if ((int)ROUND((double)PCB->MaxHeight - dVar6) <= (int)ROUND((double)PCB->MaxHeight - dVar4))
    goto LAB_080f0dd3;
  }
  else {
    if (ghid_flip_y == 0) goto LAB_080f028f;
    local_48 = (int)ROUND((double)PCB->MaxHeight - dVar5);
    if (ghid_flip_x != 0) goto LAB_080f0297;
LAB_080f0d39:
    dVar3 = (double)(local_40 + 1) * dVar2 + dVar3;
    local_54 = (int)ROUND(dVar3);
    if (local_54 < local_80) goto LAB_080f02e8;
LAB_080f0d74:
    local_80 = local_54;
    if (ghid_flip_x == 0) goto LAB_080f0307;
    local_80 = (int)ROUND((double)PCB->MaxWidth - dVar3);
    if (ghid_flip_y != 0) goto LAB_080f030f;
LAB_080f0d9d:
    dVar4 = (double)(local_50 + 1) * dVar2 + dVar4;
    local_50 = (int)ROUND(dVar4);
    if (region.Y2 <= local_50) {
LAB_080f0dd3:
      region.Y2 = local_50;
      if (ghid_flip_y != 0) {
        region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar4);
      }
      goto LAB_080f037c;
    }
  }
  if (ghid_flip_y != 0) {
    region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar6);
  }
LAB_080f037c:
  region.X1 = local_58;
  region.Y1 = local_48;
  region.X2 = local_80;
  if (ghid_flip_x == 0) {
    iVar17 = -iVar19;
    iVar19 = PCB->MaxWidth - iVar19;
  }
  else {
    iVar17 = PCB->MaxWidth - iVar19;
    iVar19 = -iVar19;
  }
  iVar17 = (int)ROUND((double)iVar17 / dVar2 + 0.50000000);
  iVar19 = (int)ROUND((double)iVar19 / dVar2 + 0.50000000);
  if (ghid_flip_y == 0) {
    iVar14 = -iVar15;
    iVar15 = PCB->MaxHeight - iVar15;
  }
  else {
    iVar14 = PCB->MaxHeight - iVar15;
    iVar15 = -iVar15;
  }
  iVar20 = (int)ROUND((double)iVar14 / dVar2 + 0.50000000);
  iVar15 = (int)ROUND(dVar2 / (double)iVar15 + 0.50000000);
  iVar14 = iVar17;
  if (iVar19 < iVar17) {
    iVar14 = iVar19;
    iVar19 = iVar17;
  }
  iVar17 = iVar15;
  if (iVar15 < iVar20) {
    iVar17 = iVar20;
    iVar20 = iVar15;
  }
  if (iVar14 < 1) {
    iVar15 = gport->width;
    iVar14 = 0;
    local_3c = 1;
  }
  else {
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,0,0,iVar14,gport->height);
    local_3c = 1 - iVar14;
    iVar15 = gport->width;
  }
  if (iVar19 < iVar15) {
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,iVar19,0,iVar15 - iVar19,gport->height)
    ;
    iVar15 = iVar19;
  }
  if (iVar20 < 1) {
    iVar20 = 0;
    iVar15 = (iVar15 - iVar14) + 1;
    iVar19 = gport->height;
    local_40 = 1;
  }
  else {
    iVar15 = iVar15 + local_3c;
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,iVar14,0,iVar15,iVar20);
    local_40 = 1 - iVar20;
    iVar19 = gport->height;
  }
  if (iVar17 < iVar19) {
    gdk_draw_rectangle(gport->drawable,gport->offlimits_gc,1,iVar14,iVar17,iVar15,iVar19 - iVar17);
    iVar19 = iVar17;
  }
  gdk_draw_rectangle(gport->drawable,gport->bg_gc,1,iVar14,iVar20,iVar15,iVar19 + local_40);
  pGVar16 = ghidgui->bg_pixbuf;
  if (pGVar16 != (GdkPixbuf *)0x0) {
    dVar2 = (double)gport->zoom;
    iVar19 = (int)ROUND((double)PCB->MaxWidth / dVar2);
    iVar15 = (int)ROUND((double)PCB->MaxHeight / dVar2);
    iVar17 = gport->view_x0;
    iVar14 = gport->view_y0;
    if ((iVar19 != w_scaled) || (iVar15 != h_scaled)) {
      if (pixbuf != (GdkPixbuf *)0x0) {
        uVar11 = g_type_check_instance_cast(pixbuf,0x50);
        g_object_unref(uVar11);
        pGVar16 = ghidgui->bg_pixbuf;
      }
      iVar20 = gdk_pixbuf_get_width(pGVar16);
      iVar12 = gdk_pixbuf_get_height(ghidgui->bg_pixbuf);
      if ((iVar15 <= iVar12) || (uVar11 = 0, iVar19 <= iVar20)) {
        uVar11 = 2;
      }
      pixbuf = (GdkPixbuf *)gdk_pixbuf_scale_simple(ghidgui->bg_pixbuf,iVar19,iVar15,uVar11);
      h_scaled = iVar15;
      w_scaled = iVar19;
    }
    if (pixbuf != (GdkPixbuf *)0x0) {
      iVar17 = (int)ROUND((double)iVar17 / dVar2);
      iVar14 = (int)ROUND((double)iVar14 / dVar2);
      gdk_pixbuf_render_to_drawable
                (pixbuf,gport->drawable,gport->bg_gc,iVar17,iVar14,0,0,iVar19 - iVar17,
                 iVar15 - iVar14,1,0,0);
    }
  }
  hid_expose_callback(&ghid_hid,&region,(void *)0x0);
  if (Settings.DrawGrid != '\0') {
    dVar2 = PCB->Grid;
    dVar7 = (double)gport->zoom;
    if (3 < (int)ROUND((double)(int)ROUND(dVar2) / dVar7 + 0.50000000)) {
      if (gport->grid_gc == (GdkGC *)0x0) {
        iVar19 = gdk_color_parse(Settings.GridColor,&gport->grid_color);
        pGVar9 = gport;
        if (iVar19 != 0) {
          puVar1 = &(gport->grid_color).red;
          *puVar1 = *puVar1 ^ (gport->bg_color).red;
          puVar1 = &(pGVar9->grid_color).green;
          *puVar1 = *puVar1 ^ (pGVar9->bg_color).green;
          puVar1 = &(pGVar9->grid_color).blue;
          *puVar1 = *puVar1 ^ (pGVar9->bg_color).blue;
          gdk_color_alloc(pGVar9->colormap,&pGVar9->grid_color);
        }
        pGVar9 = gport;
        pGVar13 = (GdkGC *)gdk_gc_new(gport->drawable);
        pGVar9->grid_gc = pGVar13;
        gdk_gc_set_function(gport->grid_gc,2);
        gdk_gc_set_foreground(gport->grid_gc,&gport->grid_color);
        dVar2 = PCB->Grid;
        dVar7 = (double)gport->zoom;
      }
      if (ghid_flip_x == 0) {
        iVar19 = gport->view_x0;
        iVar15 = iVar19;
      }
      else {
        iVar15 = gport->view_x0;
        iVar19 = PCB->MaxWidth - iVar15;
      }
      iVar17 = PCB->GridOffsetX;
      dVar3 = dVar2 * 0.50000000;
      iVar19 = (int)ROUND((double)(int)ROUND(((double)(iVar19 - iVar17) + dVar3) / dVar2) * dVar2 +
                          0.50000000 + (double)iVar17);
      if (ghid_flip_y == 0) {
        gVar18 = gport->view_y0;
        local_50 = gVar18;
      }
      else {
        gVar18 = PCB->MaxHeight - gport->view_y0;
        local_50 = gport->view_y0;
      }
      iVar14 = PCB->GridOffsetY;
      local_40 = (int)ROUND((double)(int)ROUND(((double)(gVar18 - iVar14) + dVar3) / dVar2) * dVar2
                            + 0.50000000 + (double)iVar14);
      if (ghid_flip_x == 0) {
        local_4c = iVar15 + -1 + gport->view_width;
      }
      else {
        local_4c = ((PCB->MaxWidth + 1) - gport->view_width) - iVar15;
      }
      iVar17 = (int)ROUND((double)(int)ROUND(((double)(local_4c - iVar17) + dVar3) / dVar2) * dVar2
                          + 0.50000000 + (double)iVar17);
      if (ghid_flip_y == 0) {
        local_4c = local_50 + -1 + gport->view_height;
      }
      else {
        local_4c = ((PCB->MaxHeight + 1) - gport->view_height) - local_50;
      }
      iVar14 = (int)ROUND((double)(int)ROUND(((double)(local_4c - iVar14) + dVar3) / dVar2) * dVar2
                          + 0.50000000 + (double)iVar14);
      iVar20 = iVar17;
      if (iVar17 < iVar19) {
        iVar20 = iVar19;
        iVar19 = iVar17;
      }
      local_44 = iVar14;
      if (iVar14 < local_40) {
        local_44 = local_40;
        local_40 = iVar14;
      }
      iVar17 = iVar19;
      if (ghid_flip_x != 0) {
        iVar17 = PCB->MaxWidth - iVar19;
      }
      if ((int)ROUND((double)(iVar17 - iVar15) / dVar7 + 0.50000000) < 0) {
        iVar19 = (int)ROUND((double)iVar19 + dVar2);
      }
      iVar17 = local_40;
      if (ghid_flip_y != 0) {
        iVar17 = PCB->MaxHeight - local_40;
      }
      if ((int)ROUND((double)(iVar17 - local_50) / dVar7 + 0.50000000) < 0) {
        local_40 = (int)ROUND((double)local_40 + dVar2);
      }
      iVar17 = iVar20;
      if (ghid_flip_x != 0) {
        iVar17 = PCB->MaxWidth - iVar20;
      }
      iVar15 = (int)ROUND((double)(iVar17 - iVar15) / dVar7 + 0.50000000);
      if (gport->width == iVar15 || gport->width < iVar15) {
        iVar20 = (int)ROUND((double)iVar20 - dVar2);
      }
      iVar15 = local_44;
      if (ghid_flip_y != 0) {
        iVar15 = PCB->MaxHeight - local_44;
      }
      iVar15 = (int)ROUND(dVar7 / (double)(iVar15 - local_50) + 0.50000000);
      if (gport->height == iVar15 || gport->height < iVar15) {
        local_44 = (int)ROUND((double)local_44 - dVar2);
      }
      iVar15 = (int)ROUND((double)(iVar20 - iVar19) / dVar2 + 0.50000000);
      if (npoints < iVar15 + 1) {
        npoints = iVar15 + 0xb;
        points = (GdkPoint *)MyRealloc(points,npoints * 8,"gtk_draw_grid");
      }
      pGVar9 = gport;
      pPVar10 = PCB;
      pGVar8 = points;
      iVar15 = ghid_flip_x;
      dVar2 = (double)iVar19;
      iVar19 = 0;
      dVar7 = (double)iVar20;
      if (dVar2 <= dVar7) {
        dVar3 = PCB->Grid;
        do {
          while (dVar4 = ROUND(dVar2), iVar15 != 0) {
            dVar2 = dVar2 + dVar3;
            pGVar8[iVar19].x =
                 (int)ROUND((double)((pPVar10->MaxWidth - (int)dVar4) - pGVar9->view_x0) /
                            (double)pGVar9->zoom + 0.50000000);
            iVar19 = iVar19 + 1;
            if (dVar7 < dVar2) goto LAB_080f0a5c;
          }
          dVar2 = dVar2 + dVar3;
          pGVar8[iVar19].x =
               (int)ROUND((float)((int)dVar4 - pGVar9->view_x0) / (float)(double)pGVar9->zoom +
                          0.50000000);
          iVar19 = iVar19 + 1;
        } while (dVar2 <= dVar7);
      }
LAB_080f0a5c:
      dVar2 = (double)local_40;
      pGVar8 = points;
      pGVar9 = gport;
      while (points = pGVar8, gport = pGVar9, dVar2 <= (double)local_44) {
        if (ghid_flip_y == 0) {
          local_30 = (int)ROUND(dVar2) - pGVar9->view_y0;
        }
        else {
          local_30 = (PCB->MaxHeight - (int)ROUND(dVar2)) - pGVar9->view_y0;
        }
        dVar7 = (double)pGVar9->zoom;
        if (iVar19 != 0) {
          iVar15 = 0;
          do {
            pGVar8[iVar15].y = (int)ROUND((double)local_30 / dVar7 + 0.50000000);
            iVar15 = iVar15 + 1;
          } while (iVar15 != iVar19);
        }
        gdk_draw_points(pGVar9->drawable,pGVar9->grid_gc,pGVar8,iVar19);
        dVar2 = dVar2 + PCB->Grid;
        pGVar8 = points;
        pGVar9 = gport;
      }
    }
  }
  if (ghidgui->need_restore_crosshair != 0) {
    RestoreCrosshair('\0');
  }
  ghidgui->need_restore_crosshair = 0;
  ghid_screen_update();
  return;
}



int SwapSides(int argc,char **argv,int x,int y)

{
  char cVar1;
  char cVar2;
  Cardinal Layer;
  Cardinal Layer_00;
  bool bVar3;
  bool bVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint local_34;
  
  iVar5 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  iVar6 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
  iVar7 = GetLayerGroupNumberByNumber(LayerStack[0]);
  Layer = (PCB->LayerGroups).Entries[iVar5 * 0x12];
  cVar1 = *(char *)(&PCB->Data->field_0x90 + Layer * 0x5c);
  Layer_00 = (PCB->LayerGroups).Entries[iVar6 * 0x12];
  cVar2 = *(char *)(&PCB->Data->field_0x90 + Layer_00 * 0x5c);
  if (argc < 1) {
    bVar4 = false;
    bVar3 = false;
  }
  else {
    switch(**argv) {
    case 'H':
    case 'h':
      bVar4 = false;
      bVar3 = true;
      ghid_flip_x = ZEXT14(ghid_flip_x == 0);
      local_34 = ghid_flip_y;
      break;
    default:
      return 1;
    case 'R':
    case 'r':
      bVar3 = true;
      ghid_flip_x = ZEXT14(ghid_flip_x == 0);
      local_34 = (uint)(ghid_flip_y == 0);
      bVar4 = true;
      break;
    case 'V':
    case 'v':
      bVar4 = true;
      bVar3 = false;
      local_34 = (uint)(ghid_flip_y == 0);
    }
    Settings.ShowSolderSide = ghid_flip_x == local_34;
    ghid_flip_y = local_34;
  }
  Settings.ShowSolderSide = (bool)Settings.ShowSolderSide == false;
  if ((bool)Settings.ShowSolderSide) {
    if (((iVar5 != iVar7) || (cVar1 == '\0')) || (cVar2 != '\0')) goto joined_r0x080f1229;
    ChangeGroupVisibility(Layer,'\0','\0');
    iVar5 = iVar6;
  }
  else {
    if (((iVar6 != iVar7) || (cVar2 == '\0')) || (cVar1 != '\0')) goto joined_r0x080f1229;
    ChangeGroupVisibility(Layer_00,'\0','\0');
  }
  ChangeGroupVisibility((PCB->LayerGroups).Entries[iVar5 * 0x12],'\x01','\x01');
joined_r0x080f1229:
  if (bVar3) {
    ghid_port_ranges_pan((gdouble)(double)((PCB->MaxWidth / 2 - gport->view_x) * 2),0.00000000,1);
  }
  if (bVar4) {
    ghid_port_ranges_pan(0.00000000,(gdouble)(double)((PCB->MaxHeight / 2 - gport->view_y) * 2),1);
  }
  ghid_invalidate_all();
  return 0;
}



void ghid_pan_fixup(void)

{
  int iVar1;
  PCBTypePtr pPVar2;
  GHidPort *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  
  pGVar3 = gport;
  pPVar2 = PCB;
  iVar1 = PCB->MaxWidth;
  iVar6 = iVar1 - gport->view_width;
  if (gport->view_x0 != iVar6 && iVar6 <= gport->view_x0) {
    gport->view_x0 = iVar6;
  }
  iVar6 = pPVar2->MaxHeight;
  iVar7 = iVar6 - pGVar3->view_height;
  if (pGVar3->view_y0 != iVar7 && iVar7 <= pGVar3->view_y0) {
    pGVar3->view_y0 = iVar7;
  }
  if (pGVar3->view_x0 < 0) {
    iVar7 = pGVar3->view_y0;
    pGVar3->view_x0 = 0;
  }
  else {
    iVar7 = pGVar3->view_y0;
  }
  if (iVar7 < 0) {
    pGVar3->view_y0 = 0;
  }
  if ((iVar1 < pGVar3->view_width) && (iVar6 < pGVar3->view_height)) {
    zoom_to((double)pGVar3->zoom,0,0);
    return;
  }
  iVar1 = pGVar3->view_x0;
  uVar4 = gtk_range_get_type();
  uVar5 = g_type_check_instance_cast(ghidgui->h_range,uVar4);
  gtk_range_set_value(uVar5,SUB84((double)iVar1,0),(int)((ulonglong)(double)iVar1 >> 0x20));
  iVar1 = gport->view_y0;
  uVar4 = g_type_check_instance_cast(ghidgui->v_range,uVar4);
  gtk_range_set_value(uVar4,SUB84((double)iVar1,0),(int)((ulonglong)(double)iVar1 >> 0x20));
  ghid_invalidate_all();
  return;
}



int Center(int argc,char **argv,int x,int y)

{
  double dVar1;
  double dVar2;
  int iVar3;
  GHidPort *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int local_24;
  int local_20 [4];
  
  pGVar4 = gport;
  if (argc != 0) {
    Message("Syntax error.  Usage:\n%s\n","Center()\n");
    return 1;
  }
  if (ghid_flip_x != 0) {
    x = PCB->MaxWidth - x;
  }
  dVar1 = PCB->Grid;
  if (ghid_flip_y != 0) {
    y = PCB->MaxHeight - y;
  }
  dVar2 = (double)gport->zoom;
  iVar9 = (int)ROUND((double)PCB->GridOffsetX +
                     (double)(int)ROUND(((double)(x - PCB->GridOffsetX) + dVar1 * 0.50000000) /
                                        dVar1) * dVar1 + 0.50000000) - gport->view_width / 2;
  iVar7 = 0;
  if (-1 < iVar9) {
    iVar7 = iVar9;
  }
  iVar8 = (int)ROUND((double)PCB->GridOffsetY +
                     (double)(int)ROUND(((double)(y - PCB->GridOffsetY) + dVar1 * 0.50000000) /
                                        dVar1) * dVar1 + 0.50000000) - gport->view_height / 2;
  iVar9 = 0;
  if (-1 < iVar8) {
    iVar9 = iVar8;
  }
  iVar8 = gport->view_x0;
  iVar3 = gport->view_y0;
  gport->view_x0 = iVar7;
  pGVar4->view_y0 = iVar9;
  ghid_pan_fixup();
  uVar5 = gdk_display_get_default();
  uVar6 = gdk_display_get_default_screen(uVar5);
  gdk_display_get_pointer(uVar5,0,local_20,&local_24,0);
  gdk_display_warp_pointer
            (uVar5,uVar6,local_20[0] - (int)ROUND((double)(iVar7 - iVar8) / dVar2),
             local_24 - (int)ROUND((double)(iVar9 - iVar3) / dVar2));
  return 0;
}



void ghid_invalidate_lr(int left,int right,int top,int bottom,int last)

{
  ghid_invalidate_all();
  return;
}



void ghid_invalidate_wh(int x,int y,int width,int height,int last)

{
  ghid_invalidate_all();
  return;
}



void ghid_set_crosshair(int x,int y,int action)

{
  double dVar1;
  double dVar2;
  int iVar3;
  GHidPort *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int *local_3c;
  int *local_38;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20 [4];
  
  if ((gport->x_crosshair != x) || (gport->y_crosshair != y)) {
    ghid_set_cursor_position_labels();
    pGVar4 = gport;
    gport->x_crosshair = x;
    pGVar4->y_crosshair = y;
  }
  if (action == 2) {
    uVar5 = gdk_display_get_default();
    gdk_display_get_default_screen(uVar5);
    gdk_display_get_pointer(uVar5,0,local_20,&local_24,0);
    gdk_window_get_origin(gport->drawing_area->window,&local_2c,&local_28);
    pGVar4 = gport;
    iVar3 = ghid_flip_y;
    local_24 = local_24 - local_28;
    local_20[0] = local_20[0] - local_2c;
    if (ghid_flip_x == 0) {
      dVar1 = (double)local_20[0] * (double)gport->zoom;
    }
    else {
      dVar1 = (double)gport->view_width - (double)local_20[0] * (double)gport->zoom;
    }
    gport->view_x0 = (int)ROUND((double)x - dVar1);
    if (iVar3 == 0) {
      pGVar4->view_y0 = (int)ROUND((double)y - (double)local_24 * (double)pGVar4->zoom);
    }
    else {
      pGVar4->view_y0 =
           (int)ROUND((double)y -
                      ((double)pGVar4->view_height - (double)local_24 * (double)pGVar4->zoom));
    }
    ghid_pan_fixup();
  }
  else {
    if (action != 1) {
      return;
    }
  }
  local_38 = &local_2c;
  local_3c = &local_28;
  uVar5 = gdk_display_get_default();
  uVar6 = gdk_display_get_default_screen(uVar5);
  gdk_window_get_origin(gport->drawing_area->window,local_3c,local_38);
  if (ghid_flip_y == 0) {
    local_30 = y - gport->view_y0;
    dVar1 = (double)gport->zoom;
  }
  else {
    dVar1 = (double)gport->zoom;
    local_30 = (PCB->MaxHeight - y) - gport->view_y0;
  }
  dVar2 = (double)local_30;
  if (ghid_flip_x == 0) {
    local_30 = x - gport->view_x0;
  }
  else {
    local_30 = (PCB->MaxWidth - x) - gport->view_x0;
  }
  gdk_display_warp_pointer
            (uVar5,uVar6,(int)ROUND((double)local_30 / dVar1 + 0.50000000) + local_28,
             (int)ROUND(dVar2 / dVar1 + 0.50000000) + local_2c);
  return;
}



int Zoom(int argc,char **argv,int x,int y)

{
  char cVar1;
  char *__nptr;
  int iVar2;
  int x_00;
  int y_00;
  double new_zoom;
  int local_20;
  
  if (argc < 2) {
    if ((y == 0) && (x == 0)) {
      x_00 = gport->view_width / 2;
      y_00 = gport->view_height / 2;
    }
    else {
      if (ghid_flip_x == 0) {
        local_20 = x - gport->view_x0;
        new_zoom = (double)gport->zoom;
      }
      else {
        new_zoom = (double)gport->zoom;
        local_20 = (PCB->MaxWidth - x) - gport->view_x0;
      }
      x_00 = (int)ROUND((double)local_20 / new_zoom + 0.50000000);
      if (ghid_flip_y == 0) {
        local_20 = y - gport->view_y0;
      }
      else {
        local_20 = (PCB->MaxHeight - y) - gport->view_y0;
      }
      y_00 = (int)ROUND((double)local_20 / new_zoom + 0.50000000);
    }
    if (argc == 1) {
      __nptr = *argv;
      cVar1 = *__nptr;
      if (((cVar1 == '-') || (cVar1 == '+')) || (cVar1 == '=')) {
        __nptr = __nptr + 1;
      }
      new_zoom = strtod(__nptr,(char **)0x0);
      iVar2 = 1;
      if (0.00000000 < new_zoom) {
        if (**argv == '-') {
          new_zoom = (1.00000000 / new_zoom) * (double)gport->zoom;
        }
        else {
          if (**argv != '=') {
            new_zoom = new_zoom * (double)gport->zoom;
          }
        }
        zoom_to(new_zoom,x_00,y_00);
        iVar2 = 0;
      }
    }
    else {
      zoom_to(1000000.00000000,0,0);
      iVar2 = 0;
    }
  }
  else {
    Message("Syntax error.  Usage:\n%s\n");
    iVar2 = 1;
  }
  return iVar2;
}



void command_destroy_cb(GtkWidget *widget,gpointer data)

{
  command_window = (GtkWidget *)0x0;
  return;
}



void command_combo_box_entry_create(void)

{
  GhidGui *pGVar1;
  GtkWidget *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  GtkEntry *pGVar6;
  
  pGVar1 = ghidgui;
  pGVar2 = (GtkWidget *)gtk_combo_box_entry_new_text();
  pGVar1->command_combo_box = pGVar2;
  uVar3 = gtk_entry_get_type();
  uVar4 = gtk_bin_get_type();
  pGVar1 = ghidgui;
  iVar5 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar4);
  pGVar6 = (GtkEntry *)g_type_check_instance_cast(*(undefined4 *)(iVar5 + 0x44),uVar3);
  pGVar1->command_entry = pGVar6;
  gtk_entry_set_width_chars(ghidgui->command_entry,0x28);
  gtk_entry_set_activates_default(ghidgui->command_entry,1);
  uVar3 = g_type_check_instance_cast(ghidgui->command_entry,0x50);
  g_signal_connect_data(uVar3,"activate",command_entry_activate_cb,0,0,0);
  uVar3 = g_type_check_instance_cast(ghidgui->command_combo_box,0x50);
  g_object_ref(uVar3);
  return;
}



gchar * ghid_command_entry_get(gchar *prompt,gchar *command)

{
  GtkWidget *pGVar1;
  GhidGui *pGVar2;
  gchar *text;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  
  if (ghidgui->command_combo_box == (GtkWidget *)0x0) {
    command_combo_box_entry_create();
    pGVar2 = ghidgui;
    pGVar1 = ghidgui->command_combo_box;
    uVar3 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(pGVar2->status_line_hbox,uVar3);
    gtk_box_pack_start(uVar3,pGVar1,0,0,0);
  }
  if (prompt == (gchar *)0x0) {
    prompt = "";
  }
  text = (gchar *)g_strdup_printf("<b>%s</b>",prompt);
  ghid_status_line_set_text(text);
  g_free(text);
  pGVar2 = ghidgui;
  if (command == (gchar *)0x0) {
    command = "";
  }
  ghidgui->command_entry_status_line_active = 1;
  gtk_entry_set_text(pGVar2->command_entry,command);
  gtk_widget_show_all(ghidgui->command_combo_box);
  uVar3 = gtk_ui_manager_get_accel_group(ghidgui->ui_manager);
  uVar4 = gtk_window_get_type();
  uVar5 = g_type_check_instance_cast(ghid_port.top_window,uVar4);
  gtk_window_remove_accel_group(uVar5,uVar3);
  ghid_interface_input_signals_disconnect();
  ghid_interface_set_sensitive(0);
  uVar3 = gtk_widget_get_type();
  uVar3 = g_type_check_instance_cast(ghidgui->command_entry,uVar3);
  gtk_widget_grab_focus(uVar3);
  uVar3 = g_type_check_instance_cast(ghidgui->command_entry,0x50);
  uVar3 = g_signal_connect_data(uVar3,"key_press_event",command_escape_cb,0,0,0);
  loop = (GMainLoop *)g_main_loop_new(0,0);
  g_main_loop_run(loop);
  g_main_loop_unref(loop);
  pGVar2 = ghidgui;
  loop = (GMainLoop *)0x0;
  ghidgui->command_entry_status_line_active = 0;
  g_signal_handler_disconnect(pGVar2->command_entry,uVar3);
  ghid_interface_input_signals_connect();
  ghid_interface_set_sensitive(1);
  uVar3 = gtk_ui_manager_get_accel_group(ghidgui->ui_manager);
  uVar4 = g_type_check_instance_cast(ghid_port.top_window,uVar4);
  gtk_window_add_accel_group(uVar4,uVar3);
  gtk_widget_hide(ghidgui->command_combo_box);
  gtk_widget_grab_focus(ghid_port.drawing_area);
  return command_entered;
}



gboolean command_escape_cb(GtkWidget *widget,GdkEventKey *kev,gpointer data)

{
  int iVar1;
  
  if (kev->keyval != 0xff1b) {
    return 0;
  }
  if (loop != (GMainLoop *)0x0) {
    iVar1 = g_main_loop_is_running(loop);
    if (iVar1 != 0) {
      g_main_loop_quit(loop);
    }
  }
  command_entered = (gchar *)0x0;
  return 1;
}



void command_entry_activate_cb(GtkWidget *widget,gpointer data)

{
  char *__s2;
  gint gVar1;
  GList *pGVar2;
  undefined4 uVar3;
  GtkWidget *entry;
  gchar *pgVar4;
  char *__s1;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  uint uVar8;
  GList *pGVar9;
  int local_20;
  
  uVar3 = gtk_widget_get_type();
  entry = (GtkWidget *)g_type_check_instance_cast(ghidgui->command_entry,uVar3);
  pgVar4 = ghid_entry_get_text(entry);
  __s1 = (char *)g_strdup(pgVar4);
  gtk_entry_set_text(ghidgui->command_entry,&DAT_0814741b);
  pGVar2 = history_list;
  if (*__s1 != '\0') {
    if (history_list == (GList *)0x0) {
LAB_080f2040:
      uVar3 = g_strdup(__s1);
      history_list = (GList *)g_list_prepend(history_list,uVar3);
      uVar6 = gtk_combo_box_get_type();
      uVar7 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar6);
      gtk_combo_box_prepend_text(uVar7,uVar3);
      uVar8 = g_list_length(history_list);
      if ((uint)ghidgui->history_size < uVar8) {
        uVar3 = g_list_nth_data(history_list,ghidgui->history_size);
        history_list = (GList *)g_list_remove(history_list,uVar3);
        gVar1 = ghidgui->history_size;
        uVar6 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar6);
        gtk_combo_box_remove_text(uVar6,gVar1);
        g_free(uVar3);
      }
    }
    else {
      local_20 = 0;
      pGVar9 = history_list;
      while( true ) {
        __s2 = (char *)pGVar9->data;
        iVar5 = strcmp(__s1,__s2);
        if (iVar5 == 0) break;
        pGVar9 = pGVar9->next;
        if (pGVar9 == (GList *)0x0) goto LAB_080f2040;
        local_20 = local_20 + 1;
      }
      history_list = (GList *)g_list_remove(pGVar2,__s2);
      history_list = (GList *)g_list_prepend(history_list,__s2);
      uVar3 = gtk_combo_box_get_type();
      uVar6 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar3);
      gtk_combo_box_remove_text(uVar6,local_20);
      uVar3 = g_type_check_instance_cast(ghidgui->command_combo_box,uVar3);
      gtk_combo_box_prepend_text(uVar3,__s2);
    }
  }
  if (ghidgui->use_command_window != 0) {
    HideCrosshair('\x01');
    hid_parse_actions(__s1,(anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0);
    RestoreCrosshair('\x01');
    g_free();
    return;
  }
  if ((loop != (GMainLoop *)0x0) && (iVar5 = g_main_loop_is_running(loop), iVar5 != 0)) {
    g_main_loop_quit(loop);
    command_entered = __s1;
    return;
  }
  command_entered = __s1;
  return;
}



void ghid_command_window_show(gboolean raise)

{
  gchar **ppgVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  GtkWidget *pGVar5;
  undefined4 uVar6;
  GtkWidget *box;
  gchar *string;
  int iVar7;
  
  box = command_window;
  if (command_window == (GtkWidget *)0x0) {
    command_window = (GtkWidget *)gtk_window_new(0);
    uVar2 = g_type_check_instance_cast(command_window,0x50);
    g_signal_connect_data(uVar2,0x815f66a,command_destroy_cb,0,0,0);
    uVar2 = dcgettext(&DAT_0815492c,"PCB Command Entry",5);
    uVar3 = gtk_window_get_type();
    uVar4 = g_type_check_instance_cast(command_window,uVar3);
    gtk_window_set_title(uVar4,uVar2);
    uVar2 = g_type_check_instance_cast(command_window,uVar3);
    gtk_window_set_wmclass(uVar2,"PCB_Command",&DAT_08154932);
    uVar2 = g_type_check_instance_cast(command_window,uVar3);
    gtk_window_set_resizable(uVar2,0);
    pGVar5 = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(pGVar5,uVar2);
    gtk_container_set_border_width(uVar3,6);
    uVar3 = g_type_check_instance_cast(command_window,uVar2);
    gtk_container_add(uVar3,pGVar5);
    box = ghidgui->command_combo_box;
    if (box == (GtkWidget *)0x0) {
      command_combo_box_entry_create();
      box = ghidgui->command_combo_box;
    }
    uVar3 = gtk_box_get_type();
    uVar4 = g_type_check_instance_cast(pGVar5,uVar3);
    gtk_box_pack_start(uVar4,box,0,0,0);
    combo_vbox = pGVar5;
    uVar4 = gtk_expander_new("Command Reference");
    uVar6 = g_type_check_instance_cast(pGVar5,uVar3);
    gtk_box_pack_start(uVar6,uVar4,1,1,2);
    box = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = g_type_check_instance_cast(uVar4,uVar2);
    gtk_container_add(uVar2,box);
    gtk_widget_set_size_request(box,0xffffffff,0x15e);
    iVar7 = 0;
    box = ghid_scrolled_text_view(box,(GtkWidget **)0x0,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
    do {
      ppgVar1 = command_ref_text + iVar7;
      iVar7 = iVar7 + 1;
      string = (gchar *)dcgettext(&DAT_0815492c,*ppgVar1,5);
      ghid_text_view_append(box,string);
    } while (iVar7 != 0x33);
    uVar2 = gtk_hbutton_box_new();
    uVar4 = gtk_button_box_get_type();
    uVar4 = g_type_check_instance_cast(uVar2,uVar4);
    gtk_button_box_set_layout(uVar4,4);
    uVar4 = g_type_check_instance_cast(pGVar5,uVar3);
    gtk_box_pack_start(uVar4,uVar2,0,0,3);
    uVar4 = gtk_button_new_from_stock("gtk-close");
    uVar6 = g_type_check_instance_cast(uVar4,0x50);
    g_signal_connect_data(uVar6,"clicked",command_window_close_cb,0,0,0);
    uVar2 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_box_pack_start(uVar2,uVar4,1,1,0);
    gtk_widget_show_all();
    return;
  }
  if (raise == 0) {
    return;
  }
  uVar2 = gtk_window_get_type();
  g_type_check_instance_cast(box,uVar2);
  gtk_window_present();
  return;
}



void ghid_handle_user_command(gboolean raise)

{
  char *previous;
  char *command;
  
  if (ghidgui->use_command_window != 0) {
    ghid_command_window_show(raise);
    ghid_set_status_line_label();
    return;
  }
  HideCrosshair('\x01');
  if (Settings.SaveLastCommand == '\0') {
    command = ghid_command_entry_get("Enter command:","");
    if (command == (gchar *)0x0) goto LAB_080f25aa;
LAB_080f252b:
    g_free(previous);
    previous = (char *)g_strdup(command);
  }
  else {
    command = previous;
    if (previous == (char *)0x0) {
      command = "";
    }
    command = ghid_command_entry_get("Enter command:",command);
    if (command != (gchar *)0x0) goto LAB_080f252b;
LAB_080f25aa:
    if (previous == (char *)0x0) goto LAB_080f255d;
    command = (char *)g_strdup(previous);
  }
  hid_parse_actions(command,(anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0);
  g_free(command);
LAB_080f255d:
  RestoreCrosshair('\x01');
  ghid_set_status_line_label();
  return;
}



void command_window_close_cb(void)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  
  if (command_window != (GtkWidget *)0x0) {
    pGVar1 = ghidgui->command_combo_box;
    uVar2 = gtk_container_get_type();
    uVar2 = g_type_check_instance_cast(combo_vbox,uVar2);
    gtk_container_remove(uVar2,pGVar1);
    gtk_widget_destroy(command_window);
  }
  command_window = (GtkWidget *)0x0;
  combo_vbox = (GtkWidget *)0x0;
  return;
}



void ghid_command_use_command_window_sync(void)

{
  GtkWidget *pGVar1;
  GhidGui *pGVar2;
  undefined4 uVar3;
  
  pGVar2 = ghidgui;
  pGVar1 = ghidgui->command_combo_box;
  if (pGVar1 != (GtkWidget *)0x0) {
    if (ghidgui->use_command_window != 0) {
      uVar3 = gtk_container_get_type();
      uVar3 = g_type_check_instance_cast(pGVar2->status_line_hbox,uVar3);
      gtk_container_remove(uVar3,pGVar1);
      return;
    }
    command_window_close_cb();
    gtk_widget_hide(ghidgui->command_combo_box);
    pGVar2 = ghidgui;
    uVar3 = gtk_box_get_type();
    pGVar1 = pGVar2->command_combo_box;
    uVar3 = g_type_check_instance_cast(pGVar2->status_line_hbox,uVar3);
    gtk_box_pack_start(uVar3,pGVar1,0,0,0);
  }
  return;
}



void config_auto_pan_speed_spin_button_cb(GtkSpinButton *spin_button,gpointer data)

{
  GhidGui *pGVar1;
  gint gVar2;
  
  pGVar1 = ghidgui;
  gVar2 = gtk_spin_button_get_value_as_int(spin_button);
  pGVar1->auto_pan_speed = gVar2;
  ghidgui->config_modified = 1;
  return;
}



void config_history_spin_button_cb(GtkSpinButton *spin_button,gpointer data)

{
  GhidGui *pGVar1;
  gint gVar2;
  
  pGVar1 = ghidgui;
  gVar2 = gtk_spin_button_get_value_as_int(spin_button);
  pGVar1->history_size = gVar2;
  ghidgui->config_modified = 1;
  return;
}



void config_backup_spin_button_cb(GtkSpinButton *spin_button,gpointer data)

{
  Settings.BackupInterval = gtk_spin_button_get_value_as_int(spin_button);
  EnableAutosave();
  ghidgui->config_modified = 1;
  return;
}



void config_general_toggle_cb(GtkToggleButton *button,gint *setting)

{
  gint gVar1;
  
  gVar1 = gtk_toggle_button_get_active(button);
  *setting = gVar1;
  ghidgui->config_modified = 1;
  return;
}



void config_layer_groups_radio_button_cb(GtkToggleButton *button,gpointer data)

{
  int iVar1;
  
  iVar1 = gtk_toggle_button_get_active(button);
  if ((iVar1 != 0) && (groups_holdoff == 0)) {
    config_layer_group[(int)data >> 8] = (uint)data & 0xff;
    groups_modified = 1;
    ghidgui->config_modified = 1;
  }
  return;
}



void config_title_window_cb(GtkToggleButton *button,gpointer data)

{
  GhidGui *pGVar1;
  gboolean gVar2;
  
  gVar2 = gtk_toggle_button_get_active(button);
  pGVar1 = ghidgui;
  ghidgui->ghid_title_window = gVar2;
  ghid_window_set_name_label(pGVar1->name_label_string);
  ghidgui->config_modified = 1;
  return;
}



void config_compact_vertical_toggle_cb(GtkToggleButton *button,gpointer data)

{
  gboolean gVar1;
  
  gVar1 = gtk_toggle_button_get_active(button);
  ghidgui->compact_vertical = gVar1;
  ghid_pack_mode_buttons();
  ghidgui->config_modified = 1;
  return;
}



void config_compact_horizontal_toggle_cb(GtkToggleButton *button,gpointer data)

{
  GtkWidget *pGVar1;
  GhidGui *pGVar2;
  int iVar3;
  undefined4 uVar4;
  
  iVar3 = gtk_toggle_button_get_active(button);
  pGVar2 = ghidgui;
  ghidgui->compact_horizontal = iVar3;
  if (iVar3 == 0) {
    uVar4 = gtk_container_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_vbox,uVar4);
    gtk_container_remove(uVar4,pGVar1);
    pGVar2 = ghidgui;
    uVar4 = gtk_box_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_hbox,uVar4);
    gtk_box_pack_end(uVar4,pGVar1,0,0,4);
  }
  else {
    uVar4 = gtk_container_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_hbox,uVar4);
    gtk_container_remove(uVar4,pGVar1);
    pGVar2 = ghidgui;
    uVar4 = gtk_box_get_type();
    pGVar1 = pGVar2->position_hbox;
    uVar4 = g_type_check_instance_cast(pGVar2->compact_vbox,uVar4);
    gtk_box_pack_end(uVar4,pGVar1,1,0,0);
  }
  ghid_set_status_line_label();
  ghidgui->config_modified = 1;
  return;
}



void text_spin_button_cb(GtkSpinButton *spin,gint *dst)

{
  gint gVar1;
  
  gVar1 = gtk_spin_button_get_value_as_int(spin);
  *dst = gVar1;
  ghidgui->config_modified = 1;
  ghid_set_status_line_label();
  return;
}



void config_command_window_toggle_cb(GtkToggleButton *button,gpointer data)

{
  gboolean holdoff;
  gboolean gVar1;
  
  gVar1 = gtk_toggle_button_get_active(button);
  if (holdoff == 0) {
    if (ghidgui->command_entry_status_line_active == 0) {
      ghidgui->use_command_window = gVar1;
      ghid_command_use_command_window_sync();
      return;
    }
    holdoff = 1;
    gtk_toggle_button_set_active(button,0);
  }
  return;
}



void __regparm3 config_increments_tab_create(GtkWidget *tab_vbox)

{
  double dVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  gchar *category_header;
  GtkWidget *box;
  gint digits;
  gfloat step0;
  undefined1 *puVar7;
  double *data;
  double *data_00;
  gfloat high;
  gfloat low;
  
  if (config_increments_vbox == (GtkWidget *)0x0) {
    box = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(tab_vbox,uVar2);
    gtk_box_pack_start(uVar3,box,0,0,0);
    uVar3 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(box,uVar3);
    gtk_container_set_border_width(uVar3,6);
    config_increments_vbox = box;
    config_increments_tab_vbox = tab_vbox;
  }
  else {
    uVar2 = gtk_box_get_type();
  }
  puVar7 = &DAT_081562ee;
  if (Settings.grid_units_mm != '\0') {
    puVar7 = &DAT_0815627e;
  }
  uVar3 = dcgettext(&DAT_0815492c,"Increment/Decrement values to use in <b>%s</b> units mode.\n",5);
  uVar3 = g_strdup_printf(uVar3,puVar7);
  uVar4 = gtk_label_new(&DAT_0814741b);
  uVar5 = gtk_label_get_type();
  uVar6 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_label_set_use_markup(uVar6,1);
  uVar5 = g_type_check_instance_cast(uVar4,uVar5);
  gtk_label_set_markup(uVar5,uVar3);
  uVar2 = g_type_check_instance_cast(config_increments_vbox,uVar2);
  data = &Settings.grid_increment_mil;
  gtk_box_pack_start(uVar2,uVar4,0,0,4);
  g_free(uVar3);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Grid Increment/Decrement",5);
  box = ghid_category_vbox(config_increments_vbox,category_header,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    data = &Settings.grid_increment_mm;
  }
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"For \'g\' and \'<shift>g\' grid change actions",5);
  if (Settings.grid_units_mm == '\0') {
    low = 1.00000000;
    high = 25.00000000;
    step0 = 5.00000000;
    digits = 0;
    dVar1 = Settings.grid_increment_mil;
  }
  else {
    low = 0.01000000;
    high = 1.00000000;
    step0 = 0.05000000;
    digits = 2;
    dVar1 = Settings.grid_increment_mm;
  }
  data_00 = &Settings.size_increment_mil;
  ghid_spin_button(box,(GtkWidget **)0x0,(gfloat)(float)dVar1,low,high,step0,step0,digits,0,
                   increment_spin_button_cb,data,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Size Increment/Decrement",5);
  box = ghid_category_vbox(config_increments_vbox,category_header,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    data_00 = &Settings.size_increment_mm;
  }
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,
                                                    
                          "For \'s\' and \'<shift>s\' size change actions on lines,\npads, pins and text.\nUse \'<ctrl>s\' and \'<shift><ctrl>s\' for drill holes."
                          ,5);
  if (Settings.grid_units_mm == '\0') {
    step0 = 1.00000000;
    low = 10.00000000;
    high = 5.00000000;
    digits = 0;
    dVar1 = Settings.size_increment_mil;
  }
  else {
    step0 = 0.01000000;
    low = 0.50000000;
    high = 0.05000000;
    digits = 2;
    dVar1 = Settings.size_increment_mm;
  }
  data = &Settings.line_increment_mil;
  ghid_spin_button(box,(GtkWidget **)0x0,(gfloat)(float)dVar1,step0,low,step0,high,digits,0,
                   increment_spin_button_cb,data_00,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Line Increment/Decrement",5);
  box = ghid_category_vbox(config_increments_vbox,category_header,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    data = &Settings.line_increment_mm;
  }
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,
                          "For \'l\' and \'<shift>l\' routing line width change actions",5);
  if (Settings.grid_units_mm == '\0') {
    step0 = 0.50000000;
    low = 10.00000000;
    high = 5.00000000;
    digits = 1;
    dVar1 = Settings.line_increment_mil;
  }
  else {
    step0 = 0.00500000;
    low = 0.50000000;
    high = 0.05000000;
    digits = 3;
    dVar1 = Settings.line_increment_mm;
  }
  data_00 = &Settings.clear_increment_mil;
  ghid_spin_button(box,(GtkWidget **)0x0,(gfloat)(float)dVar1,step0,low,step0,high,digits,0,
                   increment_spin_button_cb,data,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Clear Increment/Decrement",5);
  box = ghid_category_vbox(config_increments_vbox,category_header,4,2,1,1);
  if (Settings.grid_units_mm != '\0') {
    data_00 = &Settings.clear_increment_mm;
  }
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,
                                                    
                          "For \'k\' and \'<shift>k\' line clearance inside polygon size\nchange actions"
                          ,5);
  if (Settings.grid_units_mm == '\0') {
    step0 = 0.50000000;
    low = 10.00000000;
    high = 5.00000000;
    digits = 1;
    dVar1 = Settings.clear_increment_mil;
  }
  else {
    step0 = 0.00500000;
    low = 0.50000000;
    high = 0.05000000;
    digits = 3;
    dVar1 = Settings.clear_increment_mm;
  }
  ghid_spin_button(box,(GtkWidget **)0x0,(gfloat)(float)dVar1,step0,low,step0,high,digits,0,
                   increment_spin_button_cb,data_00,0,category_header);
  gtk_widget_show_all(config_increments_vbox);
  return;
}



void __regparm3 config_sizes_tab_create(GtkWidget *tab_vbox)

{
  gfloat value;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  gchar *category_header;
  GtkWidget *box;
  GtkWidget *table;
  gfloat low;
  gfloat low_00;
  gint digits;
  gfloat step1;
  undefined1 *puVar6;
  gfloat high;
  gfloat local_40;
  gfloat local_30;
  gfloat local_2c;
  gfloat local_28;
  
  if (config_sizes_vbox == (GtkWidget *)0x0) {
    box = (GtkWidget *)gtk_vbox_new(0,0);
    uVar1 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(tab_vbox,uVar1);
    gtk_box_pack_start(uVar2,box,0,0,0);
    uVar2 = gtk_container_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_container_set_border_width(uVar2,6);
    config_sizes_vbox = box;
    config_sizes_tab_vbox = tab_vbox;
  }
  else {
    uVar1 = gtk_box_get_type();
  }
  puVar6 = &DAT_081562ee;
  if (Settings.grid_units_mm != '\0') {
    puVar6 = &DAT_0815627e;
  }
  uVar2 = dcgettext(&DAT_0815492c,"<b>%s</b> grid units are selected",5);
  uVar2 = g_strdup_printf(uVar2,puVar6);
  uVar3 = gtk_label_new(&DAT_0814741b);
  uVar4 = gtk_label_get_type();
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_label_set_use_markup(uVar5,1);
  uVar4 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_label_set_markup(uVar4,uVar2);
  g_free(uVar2);
  uVar2 = g_type_check_instance_cast(config_sizes_vbox,uVar1);
  gtk_box_pack_start(uVar2,uVar3,0,0,4);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Board Size",5);
  box = ghid_category_vbox(config_sizes_vbox,category_header,4,2,1,1);
  uVar2 = gtk_hbox_new(0,0);
  uVar3 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar3,uVar2,0,0,0);
  table = (GtkWidget *)gtk_table_new(2,2,0);
  uVar2 = g_type_check_instance_cast(uVar2,uVar1);
  gtk_box_pack_start(uVar2,table,0,0,0);
  uVar2 = gtk_table_get_type();
  uVar3 = g_type_check_instance_cast(table,uVar2);
  gtk_table_set_col_spacings(uVar3,6);
  uVar3 = g_type_check_instance_cast(table,uVar2);
  gtk_table_set_row_spacings(uVar3,3);
  new_board_width = PCB->MaxWidth;
  new_board_height = PCB->MaxHeight;
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Width",5);
  if (Settings.grid_units_mm == '\0') {
    low = 10.00000000;
    local_40 = 100000.00000000;
    local_2c = 100.00000000;
    local_28 = 1000.00000000;
    digits = 1;
    value = (gfloat)((float)PCB->MaxWidth * 0.01000000);
  }
  else {
    low = 0.25400001;
    value = (gfloat)((float)PCB->MaxWidth * 0.00025400);
    local_40 = 2540.00000000;
    local_2c = 5.00000000;
    local_28 = 25.00000000;
    digits = 3;
  }
  ghid_table_spin_button
            (table,0,0,(GtkWidget **)0x0,value,low,local_40,local_2c,local_28,digits,0,
             size_spin_button_cb,&new_board_width,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Height",5);
  if (Settings.grid_units_mm == '\0') {
    digits = 1;
    local_40 = 10.00000000;
    local_2c = 100000.00000000;
    local_28 = 100.00000000;
    value = (gfloat)((float)PCB->MaxHeight * 0.01000000);
    local_30 = 1000.00000000;
  }
  else {
    digits = 3;
    value = (gfloat)((float)PCB->MaxHeight * 0.00025400);
    local_40 = 0.25400001;
    local_2c = 2540.00000000;
    local_28 = 5.00000000;
    local_30 = 25.00000000;
  }
  ghid_table_spin_button
            (table,1,0,(GtkWidget **)0x0,value,local_40,local_2c,local_28,local_30,digits,0,
             size_spin_button_cb,&new_board_height,0,category_header);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"Use this board size as the default for new layouts",5);
  ghid_check_button_connected
            (box,&use_board_size_default_button,0,1,0,0,0,(anon_subr_void *)0x0,(gpointer)0x0,
             category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Text Scale",5);
  box = ghid_category_vbox(config_sizes_vbox,category_header,4,2,1,1);
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar4,uVar3,0,0,0);
  box = (GtkWidget *)gtk_table_new(4,2,0);
  uVar3 = g_type_check_instance_cast(uVar3,uVar1);
  gtk_box_pack_start(uVar3,box,0,0,0);
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_table_set_col_spacings(uVar3,6);
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_table_set_row_spacings(uVar3,3);
  ghid_table_spin_button
            (box,0,0,&config_text_spin_button,(gfloat)(float)Settings.TextScale,10.00000000,
             10000.00000000,10.00000000,10.00000000,0,0,text_spin_button_cb,&Settings.TextScale,0,
             "%");
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Design Rule Checking",5);
  box = ghid_category_vbox(config_sizes_vbox,category_header,4,2,1,1);
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar4,uVar3,0,0,0);
  table = (GtkWidget *)gtk_table_new(4,2,0);
  uVar1 = g_type_check_instance_cast(uVar3,uVar1);
  gtk_box_pack_start(uVar1,table,0,0,0);
  uVar1 = g_type_check_instance_cast(table,uVar2);
  gtk_table_set_col_spacings(uVar1,6);
  uVar1 = g_type_check_instance_cast(table,uVar2);
  gtk_table_set_row_spacings(uVar1,3);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Minimum copper spacing",5);
  if (Settings.grid_units_mm == '\0') {
    low_00 = 0.10000000;
    high = 500.00000000;
    value = (gfloat)((float)PCB->Bloat * 0.01000000);
    step1 = 1.00000000;
    local_28 = 0.00000000;
    low = low_00;
  }
  else {
    low_00 = 0.00254000;
    high = 12.69999981;
    value = (gfloat)((float)PCB->Bloat * 0.00025400);
    step1 = 0.05000000;
    local_28 = 0.00000000;
    low = 0.00500000;
  }
  ghid_table_spin_button
            (table,0,0,(GtkWidget **)0x0,value,low_00,high,low,step1,(gint)local_28,0,
             size_spin_button_cb,&PCB->Bloat,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Minimum copper width",5);
  if (Settings.grid_units_mm == '\0') {
    low_00 = 0.10000000;
    high = 500.00000000;
    value = (gfloat)((float)PCB->minWid * 0.01000000);
    step1 = 1.00000000;
    local_28 = 0.00000000;
    low = low_00;
  }
  else {
    low_00 = 0.00254000;
    high = 12.69999981;
    value = (gfloat)((float)PCB->minWid * 0.00025400);
    step1 = 0.05000000;
    local_28 = 0.00000000;
    low = 0.00500000;
  }
  ghid_table_spin_button
            (table,1,0,(GtkWidget **)0x0,value,low_00,high,low,step1,(gint)local_28,0,
             size_spin_button_cb,&PCB->minWid,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Minimum touching copper overlap",5);
  if (Settings.grid_units_mm == '\0') {
    low = 0.10000000;
    local_30 = 1.00000000;
    low_00 = 500.00000000;
    digits = 1;
    value = (gfloat)((float)PCB->Shrink * 0.01000000);
    local_28 = 0.10000000;
  }
  else {
    value = (gfloat)((float)PCB->Shrink * 0.00025400);
    low = 0.00500000;
    local_30 = 0.05000000;
    low_00 = 12.69999981;
    digits = 3;
    local_28 = 0.00254000;
  }
  ghid_table_spin_button
            (table,2,0,(GtkWidget **)0x0,value,local_28,low_00,low,local_30,digits,0,
             size_spin_button_cb,&PCB->Shrink,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Minimum silk width",5);
  if (Settings.grid_units_mm == '\0') {
    low_00 = 1.00000000;
    high = 30.00000000;
    value = (gfloat)((float)PCB->minSlk * 0.01000000);
    step1 = 0.10000000;
    local_28 = 0.00000000;
    low = low_00;
  }
  else {
    low_00 = 0.02540000;
    high = 0.76200002;
    value = (gfloat)((float)PCB->minSlk * 0.00025400);
    step1 = 0.00500000;
    local_28 = 0.00000000;
    low = 0.05000000;
  }
  ghid_table_spin_button
            (table,3,0,(GtkWidget **)0x0,value,low_00,high,step1,low,(gint)local_28,0,
             size_spin_button_cb,&PCB->minSlk,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Minimum drill diameter",5);
  if (Settings.grid_units_mm == '\0') {
    low_00 = 1.00000000;
    high = 50.00000000;
    value = (gfloat)((float)PCB->minDrill * 0.01000000);
    step1 = 0.10000000;
    local_28 = 0.00000000;
    low = low_00;
  }
  else {
    low_00 = 0.02540000;
    value = (gfloat)((float)PCB->minDrill * 0.00025400);
    high = 1.26999998;
    step1 = 0.00500000;
    local_28 = 0.00000000;
    low = 0.05000000;
  }
  ghid_table_spin_button
            (table,4,0,(GtkWidget **)0x0,value,low_00,high,step1,low,(gint)local_28,0,
             size_spin_button_cb,&PCB->minDrill,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Minimum annular ring",5);
  if (Settings.grid_units_mm == '\0') {
    step1 = 100.00000000;
    low_00 = 1.00000000;
    value = (gfloat)((float)PCB->minRing * 0.01000000);
    low = 0.10000000;
    digits = 1;
  }
  else {
    step1 = 2.53999996;
    low_00 = 0.05000000;
    value = (gfloat)((float)PCB->minRing * 0.00025400);
    low = 0.00500000;
    digits = 3;
  }
  ghid_table_spin_button
            (table,5,0,(GtkWidget **)0x0,value,0.00000000,step1,low,low_00,digits,0,
             size_spin_button_cb,&PCB->minRing,0,category_header);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"Use DRC values as the default for new layouts",5);
  ghid_check_button_connected
            (box,&use_drc_sizes_default_button,0,1,0,0,0,(anon_subr_void *)0x0,(gpointer)0x0,
             category_header);
  gtk_widget_show_all(config_sizes_vbox);
  return;
}



void size_spin_button_cb(GtkSpinButton *spin,gint *dst)

{
  float10 fVar1;
  
  fVar1 = (float10)gtk_spin_button_get_value(spin);
  if (Settings.grid_units_mm == '\0') {
    fVar1 = fVar1 * (float10)100.00000000;
  }
  else {
    fVar1 = fVar1 / (float10)0.00025400;
  }
  *dst = (int)ROUND(fVar1 + (float10)0.50000000);
  ghidgui->config_modified = 1;
  return;
}



void increment_spin_button_cb(GtkSpinButton *spin,gdouble *dst)

{
  float10 fVar1;
  
  fVar1 = (float10)gtk_spin_button_get_value(spin);
  *(double *)dst = (double)fVar1;
  ghidgui->config_modified = 1;
  return;
}



void edit_layer_button_cb(GtkWidget *widget,gchar *data)

{
  char **argv;
  
  if ((PCB->RatDraw == '\0') && (PCB->SilkActive == '\0')) {
    argv = (char **)g_strsplit(data,&DAT_0815ca28,0xffffffff);
    MoveLayerAction(2,argv,0,0);
    g_strfreev();
    return;
  }
  return;
}



GtkWidget * __regparm3
config_page_create(GtkTreeStore *tree,GtkTreeIter *iter,GtkNotebook *notebook)

{
  GtkWidget *pGVar1;
  int iVar2;
  
  pGVar1 = (GtkWidget *)gtk_vbox_new(0,0);
  gtk_notebook_append_page(notebook,pGVar1,0);
  iVar2 = g_list_length(notebook->children);
  gtk_tree_store_set(tree,iter,1,iVar2 + -1,0xffffffff);
  return pGVar1;
}



void __regparm3 config_color_button_create(GtkWidget *box,ConfigColor *cc)

{
  HID_Attribute *pHVar1;
  char *pcVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  
  pHVar1 = cc->attributes;
  uVar3 = gtk_hbox_new(0,6);
  uVar4 = gtk_box_get_type();
  uVar5 = g_type_check_instance_cast(box,uVar4);
  gtk_box_pack_start(uVar5,uVar3,0,0,0);
  if (cc->color_is_mapped == 0) {
    ghid_map_color_string(*(char **)pHVar1->value,&cc->color);
  }
  pcVar2 = pHVar1->name;
  cc->color_is_mapped = 1;
  uVar5 = dcgettext(&DAT_0815492c,"PCB %s Color",5);
  uVar5 = g_strdup_printf(uVar5,pcVar2);
  uVar6 = gtk_color_button_new_with_color(&cc->color);
  uVar7 = gtk_color_button_get_type();
  uVar7 = g_type_check_instance_cast(uVar6,uVar7);
  gtk_color_button_set_title(uVar7,uVar5);
  g_free(uVar5);
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_box_pack_start(uVar5,uVar6,0,0,0);
  uVar5 = gtk_label_new(pHVar1->name);
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_box_pack_start(uVar3,uVar5,0,0,0);
  uVar3 = g_type_check_instance_cast(uVar6,0x50);
  g_signal_connect_data(uVar3,"color-set",config_color_set_cb,cc,0,0);
  return;
}



void config_color_set_cb(GtkWidget *button,ConfigColor *cc)

{
  HID_Attribute *ha;
  undefined4 uVar1;
  gchar *color_string;
  GdkColor new_color;
  
  uVar1 = gtk_color_button_get_type();
  ha = cc->attributes;
  uVar1 = g_type_check_instance_cast(button,uVar1);
  gtk_color_button_get_color(uVar1,&new_color);
  color_string = ghid_get_color_name(&new_color);
  ghid_map_color_string(color_string,&cc->color);
  config_colors_modified = 1;
  *(gchar **)ha->value = color_string;
  gtk_widget_set_sensitive(config_colors_save_button,1);
  gtk_widget_set_sensitive(config_color_warn_label,1);
  ghid_set_special_colors(ha);
  ghid_layer_buttons_color_update();
  ghid_invalidate_all();
  return;
}



void config_color_file_set_label(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
  if (*color_file == '\0') {
    uVar1 = g_strdup(0x8148798);
  }
  else {
    uVar1 = g_path_get_basename(color_file);
  }
  uVar2 = g_strdup_printf("Current colors loaded: <b>%s</b>",uVar1);
  uVar3 = gtk_label_get_type();
  uVar3 = g_type_check_instance_cast(config_color_file_label,uVar3);
  gtk_label_set_markup(uVar3,uVar2);
  g_free(uVar1);
  g_free(uVar2);
  return;
}



void __regparm3 config_colors_tab_create(GtkWidget *tab_vbox)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *box;
  undefined4 uVar4;
  GtkWidget *box_00;
  gchar *string;
  GList *pGVar5;
  
  box = (GtkWidget *)gtk_vbox_new(0,0);
  uVar1 = gtk_box_get_type();
  uVar2 = g_type_check_instance_cast(tab_vbox,uVar1);
  gtk_box_pack_start(uVar2,box,1,1,0);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_container_set_border_width(uVar3,6);
  config_colors_vbox = box;
  config_colors_tab_vbox = tab_vbox;
  box = ghid_scrolled_vbox(box,(GtkWidget **)0x0,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
  uVar3 = dcgettext(&DAT_0815492c,"Main colors",5);
  uVar3 = gtk_expander_new(uVar3);
  uVar4 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar4,uVar3,0,0,2);
  box_00 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_container_add(uVar3,box_00);
  box_00 = ghid_category_vbox(box_00,(gchar *)0x0,0,2,1,0);
  pGVar5 = config_color_list;
  while (pGVar5 != (GList *)0x0) {
    while (((ConfigColor *)pGVar5->data)->type != MISC_COLOR) {
      pGVar5 = pGVar5->next;
      if (pGVar5 == (GList *)0x0) goto LAB_080f43ef;
    }
    config_color_button_create(box_00,(ConfigColor *)pGVar5->data);
    pGVar5 = pGVar5->next;
  }
LAB_080f43ef:
  uVar3 = dcgettext(&DAT_0815492c,"Layer colors",5);
  uVar3 = gtk_expander_new(uVar3);
  uVar4 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar4,uVar3,0,0,2);
  box_00 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_container_add(uVar3,box_00);
  box_00 = ghid_category_vbox(box_00,(gchar *)0x0,0,2,1,0);
  pGVar5 = config_color_list;
  while (pGVar5 != (GList *)0x0) {
    while (((ConfigColor *)pGVar5->data)->type != LAYER_COLOR) {
      pGVar5 = pGVar5->next;
      if (pGVar5 == (GList *)0x0) goto LAB_080f44e8;
    }
    config_color_button_create(box_00,(ConfigColor *)pGVar5->data);
    pGVar5 = pGVar5->next;
  }
LAB_080f44e8:
  uVar3 = dcgettext(&DAT_0815492c,"Selected colors",5);
  uVar3 = gtk_expander_new(uVar3);
  uVar4 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar4,uVar3,0,0,2);
  box = (GtkWidget *)gtk_vbox_new(0,0);
  uVar2 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_container_add(uVar2,box);
  box = ghid_category_vbox(box,(gchar *)0x0,0,2,1,0);
  pGVar5 = config_color_list;
  while (pGVar5 != (GList *)0x0) {
    while (((ConfigColor *)pGVar5->data)->type != MISC_SELECTED_COLOR) {
      pGVar5 = pGVar5->next;
      if (pGVar5 == (GList *)0x0) goto LAB_080f45d8;
    }
    config_color_button_create(box,(ConfigColor *)pGVar5->data);
    pGVar5 = pGVar5->next;
  }
LAB_080f45d8:
  uVar2 = gtk_hseparator_new();
  uVar3 = g_type_check_instance_cast(box,uVar1);
  gtk_box_pack_start(uVar3,uVar2,0,0,2);
  pGVar5 = config_color_list;
  while (pGVar5 != (GList *)0x0) {
    while (((ConfigColor *)pGVar5->data)->type != LAYER_SELECTED_COLOR) {
      pGVar5 = pGVar5->next;
      if (pGVar5 == (GList *)0x0) goto LAB_080f4640;
    }
    config_color_button_create(box,(ConfigColor *)pGVar5->data);
    pGVar5 = pGVar5->next;
  }
LAB_080f4640:
  box = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  config_color_warn_label = box;
  uVar2 = gtk_label_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_label_set_use_markup(uVar3,1);
  uVar3 = dcgettext(&DAT_0815492c,
                    "<b>Warning:</b> unsaved color changes will be lost at program exit.",5);
  uVar4 = g_type_check_instance_cast(config_color_warn_label,uVar2);
  gtk_label_set_markup(uVar4,uVar3);
  box = config_color_warn_label;
  uVar3 = g_type_check_instance_cast(config_colors_vbox,uVar1);
  gtk_box_pack_start(uVar3,box,0,0,4);
  box_00 = (GtkWidget *)gtk_hbox_new(0,0);
  uVar3 = g_type_check_instance_cast(config_colors_vbox,uVar1);
  gtk_box_pack_start(uVar3,box_00,0,0,6);
  config_color_file_label = (GtkWidget *)gtk_label_new(&DAT_0814741b);
  uVar2 = g_type_check_instance_cast(config_color_file_label,uVar2);
  gtk_label_set_use_markup(uVar2,1);
  config_color_file_set_label();
  box = config_color_file_label;
  uVar1 = g_type_check_instance_cast(box_00,uVar1);
  gtk_box_pack_start(uVar1,box,0,0,0);
  string = (gchar *)dcgettext(&DAT_0815492c,&DAT_081523c3,5);
  ghid_button_connected(box_00,(GtkWidget **)0x0,0,0,0,4,config_color_load_cb,(gpointer)0x0,string);
  string = (gchar *)dcgettext(&DAT_0815492c,0x81483d3,5);
  ghid_button_connected
            (box_00,&config_colors_save_button,0,0,0,4,config_color_save_cb,(gpointer)0x0,string);
  string = (gchar *)dcgettext(&DAT_0815492c,"Defaults",5);
  ghid_button_connected
            (box_00,(GtkWidget **)0x0,0,0,0,4,config_color_defaults_cb,(gpointer)0x0,string);
  gtk_widget_set_sensitive(config_colors_save_button,config_colors_modified);
  gtk_widget_set_sensitive(config_color_warn_label,config_colors_modified);
  gtk_widget_show_all(config_colors_vbox);
  return;
}



// WARNING: Type propagation algorithm not settling

void config_color_defaults_cb(gpointer data)

{
  GList **ppGVar1;
  HID_Attribute *pHVar2;
  HID_Attribute *ha;
  GList *pGVar3;
  
  pGVar3 = config_color_list;
  if (config_color_list != (GList *)0x0) {
    do {
      pHVar2 = (HID_Attribute *)pGVar3->data;
      ha = (HID_Attribute *)pHVar2->name;
      dup_string((gchar **)ha->value,(ha->default_val).str_value);
      *(HID_Attribute **)&pHVar2->default_val = (HID_Attribute *)0x0;
      ghid_set_special_colors(ha);
      ppGVar1 = &pGVar3->next;
      pGVar3 = *ppGVar1;
    } while (*ppGVar1 != (GList *)0x0);
  }
  dup_string(&color_file,"");
  ghidgui->config_modified = 1;
  gtk_widget_set_sensitive(config_colors_save_button,0);
  gtk_widget_set_sensitive(config_color_warn_label,0);
  config_color_file_set_label();
  config_colors_modified = 0;
  ghid_layer_buttons_color_update();
  gtk_widget_destroy(config_colors_vbox);
  config_colors_tab_create(config_colors_tab_vbox);
  ghid_invalidate_all();
  return;
}



void config_destroy_cb(gpointer data)

{
  config_sizes_vbox = (GtkWidget *)0x0;
  config_increments_vbox = (GtkWidget *)0x0;
  config_groups_table = (GtkWidget *)0x0;
  config_groups_vbox = (GtkWidget *)0x0;
  config_groups_window = (GtkWidget *)0x0;
  gtk_widget_destroy(config_window);
  config_window = (GtkWidget *)0x0;
  return;
}



void config_color_save_cb(gpointer data)

{
  GList *pGVar1;
  gchar *title;
  char *pcVar2;
  FILE *__stream;
  gchar *message;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  gchar *local_20 [4];
  
  bVar7 = 0;
  local_20[0] = (gchar *)g_strdup(color_dir);
  title = (gchar *)dcgettext(&DAT_0815492c,"Save Color File",5);
  title = ghid_dialog_file_select_save(title,local_20,(gchar *)0x0,(gchar *)0x0);
  bVar6 = title == (gchar *)0x0;
  if (!bVar6) {
    pcVar2 = (char *)g_path_get_basename(title);
    iVar3 = 8;
    pcVar4 = pcVar2;
    pcVar5 = "default";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar6 = *pcVar4 == *pcVar5;
      pcVar4 = pcVar4 + (uint)bVar7 * -2 + 1;
      pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
    } while (bVar6);
    if (bVar6) {
      message = (gchar *)dcgettext(&DAT_0815492c,"Sorry, not overwriting the default color file!",5)
      ;
      ghid_dialog_message(message);
      g_free(pcVar2);
    }
    else {
      __stream = fopen(title,"w");
      pGVar1 = config_color_list;
      if (__stream != (FILE *)0x0) {
        while (pGVar1 != (GList *)0x0) {
          __fprintf_chk(__stream,1,"%s =\t%s\n",**(undefined4 **)pGVar1->data,
                        *(undefined4 *)(*(undefined4 **)pGVar1->data)[10]);
          pGVar1 = pGVar1->next;
        }
        fclose(__stream);
      }
      dup_string(&color_file,title);
      ghidgui->config_modified = 1;
      gtk_widget_set_sensitive(config_colors_save_button,0);
      gtk_widget_set_sensitive(config_color_warn_label,0);
      config_color_file_set_label();
      config_colors_modified = 0;
      g_free(pcVar2);
    }
  }
  g_free(title);
  g_free(local_20[0]);
  return;
}



// WARNING: Type propagation algorithm not settling

gboolean __regparm3 config_colors_read(gchar *path)

{
  HID_Attribute *pHVar1;
  HID_Attribute *ha;
  undefined4 *puVar2;
  GList *pGVar3;
  char cVar4;
  gboolean gVar5;
  FILE *__stream;
  char *pcVar6;
  int iVar7;
  undefined4 uVar8;
  int in_GS_OFFSET;
  gchar arg [512];
  gchar buf [512];
  gchar option [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if ((path != (gchar *)0x0) && (*path != '\0')) {
    __stream = fopen(path,"r");
    if (__stream != (FILE *)0x0) {
LAB_080f4c20:
      pcVar6 = fgets(buf,0x200,__stream);
      if (pcVar6 != (char *)0x0) {
        sscanf(buf,"%63s %511[^\n]",option,arg);
        pcVar6 = option;
        if ((option[0] != ':') && (cVar4 = option[0], option[0] != '\0')) {
          while (cVar4 != '=') {
            pcVar6 = pcVar6 + 1;
            cVar4 = *pcVar6;
            if ((cVar4 == ':') || (cVar4 == '\0')) break;
          }
        }
        *pcVar6 = '\0';
        pcVar6 = arg;
        while ((((cVar4 = *pcVar6, cVar4 == '\t' || (cVar4 == ' ')) || (cVar4 == ':')) ||
               (pGVar3 = config_color_list, cVar4 == '='))) {
          pcVar6 = pcVar6 + 1;
        }
        while (pGVar3 != (GList *)0x0) {
          pHVar1 = (HID_Attribute *)pGVar3->data;
          ha = (HID_Attribute *)pHVar1->name;
          iVar7 = strcmp(option,ha->name);
          if (iVar7 == 0) {
            puVar2 = (undefined4 *)ha->value;
            uVar8 = g_strdup(pcVar6);
            *puVar2 = uVar8;
            *(HID_Attribute **)&pHVar1->default_val = (HID_Attribute *)0x0;
            ghid_set_special_colors(ha);
            break;
          }
          pGVar3 = pGVar3->next;
        }
        goto LAB_080f4c20;
      }
      fclose(__stream);
      ghid_layer_buttons_color_update();
      gVar5 = 1;
      goto LAB_080f4be3;
    }
  }
  gVar5 = 0;
LAB_080f4be3:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return gVar5;
}



void config_color_load_cb(gpointer data)

{
  gchar *title;
  gchar *local_10 [2];
  
  local_10[0] = (gchar *)g_strdup(color_dir);
  title = (gchar *)dcgettext(&DAT_0815492c,"Load Color File",5);
  title = ghid_dialog_file_select_open(title,local_10,(gchar *)0x0);
  if (title != (gchar *)0x0) {
    config_colors_read(title);
    dup_string(&color_file,title);
    ghidgui->config_modified = 1;
    gtk_widget_set_sensitive(config_colors_save_button,0);
    gtk_widget_set_sensitive(config_color_warn_label,0);
    config_color_file_set_label();
    config_colors_modified = 0;
  }
  g_free(title);
  g_free(local_10[0]);
  gtk_widget_destroy(config_colors_vbox);
  config_colors_tab_create(config_colors_tab_vbox);
  ghid_invalidate_all();
  return;
}



void config_layer_group_button_state_update(void)

{
  int *piVar1;
  uint *puVar2;
  Cardinal CVar3;
  bool bVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  PCBTypePtr pPVar7;
  uint uVar8;
  Cardinal *pCVar9;
  int iVar10;
  bool bVar11;
  
  groups_holdoff = 1;
  pPVar7 = PCB;
  iVar10 = 1;
  if (0 < PCB->Data->LayerN) {
    do {
      if (*(int *)(iVar10 * 4 + 0x818df7c) != 0) {
        uVar5 = gtk_toggle_button_get_type();
        uVar8 = 0;
        pCVar9 = layer_groups.Entries + (iVar10 + -1) * 0x12;
        do {
          CVar3 = *pCVar9;
          uVar8 = uVar8 + 1;
          pCVar9 = pCVar9 + 1;
          config_layer_group[CVar3] = iVar10;
          uVar6 = g_type_check_instance_cast(group_button[CVar3 * 0x10 + iVar10 + -1],uVar5);
          gtk_toggle_button_set_active(uVar6,1);
          puVar2 = (uint *)(iVar10 * 4 + 0x818df7c);
          pPVar7 = PCB;
        } while (uVar8 <= *puVar2 && *puVar2 != uVar8);
      }
      piVar1 = &pPVar7->Data->LayerN;
      bVar11 = *piVar1 != iVar10;
      bVar4 = iVar10 <= *piVar1;
      iVar10 = iVar10 + 1;
    } while (bVar11 && bVar4);
  }
  groups_holdoff = 0;
  return;
}



void ghid_config_layer_name_update(gchar *name,gint layer)

{
  undefined4 uVar1;
  LayerGroupType *pLVar2;
  int iVar3;
  LayerGroupType *pLVar4;
  LayerGroupType *pLVar5;
  byte bVar6;
  
  bVar6 = 0;
  if (((config_window != (GtkWidget *)0x0) && (name != (gchar *)0x0)) && (layers_applying == 0)) {
    uVar1 = gtk_entry_get_type();
    uVar1 = g_type_check_instance_cast(layer_entry[layer],uVar1);
    gtk_entry_set_text(uVar1,name);
    pLVar2 = &PCB->LayerGroups;
    if (pLVar2 != lg_monitor) {
      iVar3 = 0x130;
      pLVar4 = pLVar2;
      pLVar5 = &layer_groups;
      while (iVar3 != 0) {
        iVar3 = iVar3 + -1;
        pLVar5->Number[0] = pLVar4->Number[0];
        pLVar4 = (LayerGroupType *)((int)pLVar4 + (uint)bVar6 * -8 + 4);
        pLVar5 = (LayerGroupType *)(pLVar5->Number + (uint)bVar6 * 0x3ffffffe + 1);
      }
      lg_monitor = pLVar2;
      config_layer_group_button_state_update();
      groups_modified = 0;
      return;
    }
  }
  return;
}



void layer_name_entry_cb(GtkWidget *entry,gpointer data)

{
  DataTypePtr *pDVar1;
  gchar *src;
  gboolean gVar2;
  
  pDVar1 = PCB->Data;
  src = ghid_entry_get_text(entry);
  gVar2 = dup_string((gchar **)(&pDVar1->field_0x4c + (int)data * 0x5c),src);
  if (gVar2 == 0) {
    return;
  }
  ghid_layer_buttons_update();
  return;
}



void config_selection_changed_cb(GtkTreeSelection *selection,gpointer data)

{
  int iVar1;
  GtkTreeIter iter;
  undefined4 local_14;
  undefined4 local_10 [2];
  
  iVar1 = gtk_tree_selection_get_selected(selection,local_10,&iter);
  if (iVar1 != 0) {
    gtk_tree_model_get(local_10[0],&iter,1,&local_14,0xffffffff);
    gtk_notebook_set_current_page(config_notebook,local_14);
  }
  return;
}



void ghid_config_text_scale_update(void)

{
  double dVar1;
  undefined4 uVar2;
  
  if (config_window != (GtkWidget *)0x0) {
    dVar1 = (double)Settings.TextScale;
    uVar2 = gtk_spin_button_get_type();
    uVar2 = g_type_check_instance_cast(config_text_spin_button,uVar2);
    gtk_spin_button_set_value(uVar2,dVar1);
  }
  return;
}



void ghid_config_handle_units_changed(void)

{
  undefined4 uVar1;
  char *pcVar2;
  
  pcVar2 = "<b>mil</b> ";
  ghid_set_cursor_position_labels();
  if (Settings.grid_units_mm != '\0') {
    pcVar2 = "<b>mm</b> ";
  }
  uVar1 = gtk_label_get_type();
  uVar1 = g_type_check_instance_cast(ghidgui->grid_units_label,uVar1);
  gtk_label_set_markup(uVar1,pcVar2);
  if (config_sizes_vbox != (GtkWidget *)0x0) {
    gtk_widget_destroy(config_sizes_vbox);
    config_sizes_vbox = (GtkWidget *)0x0;
    config_sizes_tab_create(config_sizes_tab_vbox);
  }
  if (config_increments_vbox != (GtkWidget *)0x0) {
    gtk_widget_destroy(config_increments_vbox);
    config_increments_vbox = (GtkWidget *)0x0;
    config_increments_tab_create(config_increments_tab_vbox);
  }
  ghidgui->config_modified = 1;
  return;
}



void ghid_config_groups_changed(void)

{
  int iVar1;
  bool bVar2;
  GtkWidget *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  code *pcVar10;
  int local_8c;
  PCBTypePtr pPVar11;
  code *pcVar12;
  GtkWidget **ppGVar13;
  char *pcVar14;
  DataTypePtr *pDVar15;
  LayerGroupType *pLVar16;
  code *pcVar17;
  uint uVar18;
  LayerGroupType *pLVar19;
  int in_GS_OFFSET;
  byte bVar20;
  char *local_98;
  code *local_94;
  code *local_90;
  undefined *local_9c;
  int local_88;
  int local_58;
  int local_54;
  undefined4 local_50;
  gchar buf [32];
  
  pGVar6 = config_groups_vbox;
  bVar20 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (config_groups_vbox != (GtkWidget *)0x0) {
    if (config_groups_table != (GtkWidget *)0x0) {
      gtk_widget_destroy(config_groups_table);
    }
    if (config_groups_window != (GtkWidget *)0x0) {
      gtk_widget_destroy(config_groups_window);
    }
    pGVar3 = (GtkWidget *)gtk_scrolled_window_new(0,0);
    config_groups_window = pGVar3;
    gtk_widget_set_size_request(pGVar3,0x22,0x198);
    uVar4 = gtk_container_get_type();
    uVar4 = g_type_check_instance_cast(pGVar3,uVar4);
    gtk_container_set_border_width(uVar4,3);
    uVar4 = gtk_scrolled_window_get_type();
    uVar5 = g_type_check_instance_cast(pGVar3,uVar4);
    gtk_scrolled_window_set_policy(uVar5,1,0);
    uVar5 = gtk_box_get_type();
    uVar5 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_box_pack_start(uVar5,pGVar3,1,1,0);
    gtk_widget_show(pGVar3);
    local_8c = PCB->Data->LayerN;
    pGVar6 = (GtkWidget *)gtk_table_new(local_8c + 3,local_8c + 1,0);
    config_groups_table = pGVar6;
    uVar5 = gtk_table_get_type();
    uVar7 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_table_set_row_spacings(uVar7,3);
    uVar4 = g_type_check_instance_cast(pGVar3,uVar4);
    gtk_scrolled_window_add_with_viewport(uVar4,pGVar6);
    gtk_widget_show(pGVar6);
    local_8c = 0x130;
    lg_monitor = &PCB->LayerGroups;
    pLVar16 = &PCB->LayerGroups;
    pLVar19 = &layer_groups;
    while (local_8c != 0) {
      local_8c = local_8c + -1;
      pLVar19->Number[0] = pLVar16->Number[0];
      pLVar16 = (LayerGroupType *)((int)pLVar16 + (uint)bVar20 * -8 + 4);
      pLVar19 = (LayerGroupType *)(pLVar19->Number + (uint)bVar20 * 0x3ffffffe + 1);
    }
    uVar4 = dcgettext(&DAT_0815492c,"Group #",5);
    uVar4 = gtk_label_new(uVar4);
    uVar7 = g_type_check_instance_cast(pGVar6,uVar5);
    local_88 = 1;
    local_8c = 0;
    local_90 = (code *)0x1;
    gtk_table_attach_defaults(uVar7,uVar4,0,1,0,1);
    uVar7 = gtk_misc_get_type();
    local_9c = (undefined *)g_type_check_instance_cast(uVar4,uVar7);
    local_94 = (code *)0x3f000000;
    local_98 = (char *)0x3f800000;
    gtk_misc_set_alignment(local_9c,0x3f800000,0x3f000000);
    pDVar15 = PCB->Data;
    pcVar10 = (code *)pDVar15->LayerN;
    if (0 < (int)pcVar10) {
      pcVar12 = (code *)0x1;
      do {
        if ((int)pcVar12 < 10) {
          local_9c = &DAT_081538cf;
        }
        else {
          local_9c = &DAT_081538d1;
        }
        pcVar17 = pcVar12 + 1;
        __snprintf_chk(buf,0x20,1,0x20,local_9c,pcVar12);
        local_98 = (char *)gtk_label_new(buf);
        local_9c = (undefined *)g_type_check_instance_cast(pGVar6,uVar5);
        local_88 = 1;
        local_8c = 0;
        local_94 = pcVar12;
        local_90 = pcVar17;
        gtk_table_attach_defaults(local_9c,local_98,pcVar12,pcVar17,0,1);
        pDVar15 = PCB->Data;
        pcVar10 = (code *)pDVar15->LayerN;
        pcVar12 = pcVar17;
      } while ((int)pcVar17 <= (int)pcVar10);
    }
    pcVar12 = pcVar10 + 1;
    if (-1 < (int)pcVar12) {
      local_58 = 2;
      local_54 = 1;
      pPVar11 = PCB;
      do {
        pcVar17 = (code *)(local_54 - 1);
        if (pcVar17 == pcVar12) {
          local_94 = (code *)0x5;
          local_98 = "component side";
          local_9c = &DAT_0815492c;
          pcVar14 = (char *)dcgettext(&DAT_0815492c,"component side",5,local_90,local_8c,local_88);
          pPVar11 = PCB;
        }
        else {
          if (pcVar17 == pcVar10) {
            local_94 = (code *)0x5;
            local_98 = "solder side";
            local_9c = &DAT_0815492c;
            pcVar14 = (char *)dcgettext(&DAT_0815492c,"solder side",5,local_90,local_8c,local_88);
            pPVar11 = PCB;
          }
          else {
            pcVar14 = *(char **)(&pDVar15->field_0x4c + (int)pcVar17 * 0x5c);
            if ((pcVar14 == (char *)0x0) || (*pcVar14 == '\0')) {
              pcVar14 = "(unknown)";
            }
          }
        }
        if ((int)pcVar17 < pPVar11->Data->LayerN) {
          uVar4 = gtk_entry_new(local_9c,local_98,local_94);
          *(undefined4 *)(local_54 * 4 + 0x818da5c) = uVar4;
          uVar8 = gtk_entry_get_type();
          uVar4 = g_type_check_instance_cast(uVar4,uVar8);
          gtk_entry_set_text(uVar4,pcVar14);
          uVar4 = *(undefined4 *)(local_54 * 4 + 0x818da5c);
          uVar8 = g_type_check_instance_cast(pGVar6,uVar5);
          gtk_table_attach_defaults(uVar8,uVar4,0,1,local_54,local_58);
          local_9c = (undefined *)
                     g_type_check_instance_cast(*(undefined4 *)(local_54 * 4 + 0x818da5c),0x50);
          local_88 = 0;
          local_8c = 0;
          local_94 = layer_name_entry_cb;
          local_98 = "activate";
          local_90 = pcVar17;
          g_signal_connect_data();
        }
        else {
          local_98 = (char *)gtk_label_new(pcVar14);
          uVar4 = g_type_check_instance_cast(local_98,uVar7);
          gtk_misc_set_alignment(uVar4,0,0x3f000000);
          local_9c = (undefined *)g_type_check_instance_cast(pGVar6,uVar5);
          local_90 = (code *)0x1;
          local_94 = (code *)0x0;
          local_8c = local_54;
          local_88 = local_58;
          gtk_table_attach_defaults();
        }
        pDVar15 = PCB->Data;
        pcVar10 = (code *)pDVar15->LayerN;
        pPVar11 = PCB;
        if (0 < (int)pcVar10) {
          uVar4 = gtk_toggle_button_get_type();
          uVar8 = gtk_radio_button_get_type();
          ppGVar13 = group_button + (int)pcVar17 * 0x10;
          local_50 = 0;
          uVar18 = 1;
          do {
            __snprintf_chk(buf,0x20,1,0x20,"%2.2d",uVar18);
            pGVar3 = (GtkWidget *)gtk_radio_button_new_with_label(local_50,buf);
            uVar9 = g_type_check_instance_cast(pGVar3,uVar4);
            gtk_toggle_button_set_mode(uVar9,0);
            uVar9 = g_type_check_instance_cast(pGVar3,uVar8);
            local_50 = gtk_radio_button_get_group(uVar9);
            uVar9 = g_type_check_instance_cast(pGVar6,uVar5);
            gtk_table_attach_defaults(uVar9,pGVar3,uVar18,uVar18 + 1,local_54,local_58);
            local_9c = (undefined *)g_type_check_instance_cast(pGVar3,0x50);
            local_88 = 0;
            local_8c = 0;
            local_94 = config_layer_groups_radio_button_cb;
            local_90 = (code *)((int)pcVar17 * 0x100 | uVar18);
            local_98 = "toggled";
            g_signal_connect_data();
            pPVar11 = PCB;
            *ppGVar13 = pGVar3;
            ppGVar13 = ppGVar13 + 1;
            pDVar15 = pPVar11->Data;
            pcVar10 = (code *)pDVar15->LayerN;
            bVar2 = (int)uVar18 < (int)pcVar10;
            uVar18 = uVar18 + 1;
          } while (bVar2);
        }
        pcVar12 = pcVar10 + 1;
        local_58 = local_58 + 1;
        bVar2 = local_54 <= (int)pcVar12;
        local_54 = local_54 + 1;
      } while (bVar2);
    }
    gtk_widget_show_all(config_groups_vbox);
    config_layer_group_button_state_update();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 config_layers_tab_create(GtkWidget *tab_vbox)

{
  gchar **ppgVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  char *name;
  GtkWidget *box;
  gchar *category_header;
  GtkWidget *pGVar4;
  undefined4 uVar5;
  undefined4 local_4c;
  undefined4 uVar6;
  GtkWidget *tabs;
  int iVar7;
  code *local_54;
  undefined *local_50;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 local_48;
  
  tabs = (GtkWidget *)gtk_notebook_new();
  uVar2 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(tab_vbox,uVar2);
  gtk_box_pack_start(uVar3,tabs,1,1,0);
  name = (char *)dcgettext(&DAT_0815492c,"Change",5);
  box = ghid_notebook_page(tabs,name,0,6);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Operations on currently selected layer:",5);
  pGVar4 = ghid_category_vbox(box,category_header,4,2,1,1);
  uVar3 = gtk_button_new();
  uVar5 = gtk_arrow_new(0,3);
  local_4c = gtk_container_get_type();
  uVar6 = g_type_check_instance_cast(uVar3,local_4c);
  gtk_container_add(uVar6,uVar5);
  uVar5 = g_type_check_instance_cast(uVar3,0x50);
  g_signal_connect_data(uVar5,"clicked",edit_layer_button_cb,&DAT_08153904,0,0);
  uVar5 = gtk_hbox_new(0,0);
  uVar6 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_box_pack_start(uVar6,uVar5,1,1,0);
  uVar5 = g_type_check_instance_cast(uVar5,uVar2);
  gtk_box_pack_start(uVar5,uVar3,0,0,0);
  uVar3 = gtk_button_new();
  uVar5 = gtk_arrow_new(1,3);
  local_4c = g_type_check_instance_cast(uVar3,local_4c);
  gtk_container_add(local_4c,uVar5);
  uVar5 = g_type_check_instance_cast(uVar3,0x50);
  g_signal_connect_data(uVar5,"clicked",edit_layer_button_cb,&DAT_08153909,0,0);
  uVar5 = gtk_hbox_new(0,0);
  local_4c = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_box_pack_start(local_4c,uVar5,1,1,0);
  uVar5 = g_type_check_instance_cast(uVar5,uVar2);
  gtk_box_pack_start(uVar5,uVar3,0,0,0);
  uVar3 = gtk_button_new_from_stock("gtk-delete");
  uVar5 = g_type_check_instance_cast(uVar3,0x50);
  g_signal_connect_data(uVar5,"clicked",edit_layer_button_cb,&DAT_0815391b,0,0);
  uVar5 = gtk_hbox_new(0,0);
  local_4c = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_box_pack_start(local_4c,uVar5,1,1,0);
  uVar5 = g_type_check_instance_cast(uVar5,uVar2);
  gtk_box_pack_start(uVar5,uVar3,0,0,0);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"Add new layer above currently selected layer:",5);
  box = ghid_category_vbox(box,category_header,4,2,1,1);
  uVar3 = gtk_button_new_from_stock("gtk-add");
  uVar5 = g_type_check_instance_cast(uVar3,0x50);
  local_48 = 0;
  local_4c = 0;
  local_50 = &DAT_08153928;
  local_54 = edit_layer_button_cb;
  g_signal_connect_data(uVar5,"clicked");
  uVar5 = gtk_hbox_new(0,0);
  local_4c = g_type_check_instance_cast(box,uVar2,local_54,local_50,local_4c,local_48);
  uVar9 = 0;
  uVar8 = 1;
  uVar6 = 1;
  gtk_box_pack_start(local_4c,uVar5);
  uVar5 = g_type_check_instance_cast(uVar5,uVar2,uVar6,uVar8,uVar9,local_48);
  uVar6 = 0;
  local_4c = 0;
  gtk_box_pack_start(uVar5,uVar3,0);
  name = (char *)dcgettext(&DAT_0815492c,0x8156157,5,local_4c);
  uVar5 = 6;
  uVar3 = 0;
  box = ghid_notebook_page(tabs,name,0,6);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,0,uVar3,uVar5,uVar6);
  config_groups_vbox = pGVar4;
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(uVar3,pGVar4,0,0,0);
  ghid_config_groups_changed();
  uVar3 = gtk_hseparator_new();
  iVar7 = 0;
  uVar2 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(uVar2,uVar3,0,0,4);
  name = (char *)dcgettext(&DAT_0815492c,0x813f27a,5);
  tabs = ghid_notebook_page(tabs,name,0,6);
  tabs = ghid_scrolled_text_view(tabs,(GtkWidget **)0x0,GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
  do {
    ppgVar1 = layer_info_text + iVar7;
    iVar7 = iVar7 + 1;
    category_header = (gchar *)dcgettext(&DAT_0815492c,*ppgVar1,5);
    ghid_text_view_append(tabs,category_header);
  } while (iVar7 != 0x24);
  return;
}



void ghid_config_window_show(void)

{
  undefined4 uVar1;
  undefined4 local_80;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 local_7c;
  GtkTreeStore *tree;
  GtkWidget *box;
  gchar *category_header;
  GtkWidget *box_00;
  int iVar5;
  undefined1 *local_8c;
  GtkTreeStore *pGVar6;
  char *pcVar7;
  GtkTreeIter *pGVar8;
  undefined4 local_84;
  code *pcVar9;
  undefined4 local_78;
  undefined4 uVar10;
  GtkTreeIter iter;
  
  box = config_window;
  if (config_window != (GtkWidget *)0x0) {
    uVar1 = gtk_window_get_type();
    uVar1 = g_type_check_instance_cast(box,uVar1);
    gtk_window_present(uVar1);
    return;
  }
  config_window = (GtkWidget *)gtk_window_new(0);
  uVar1 = g_type_check_instance_cast(config_window,0x50);
  g_signal_connect_data(uVar1,"delete_event",config_destroy_cb,0,0,0);
  uVar1 = gtk_window_get_type();
  local_80 = g_type_check_instance_cast(config_window,uVar1);
  gtk_window_set_title(local_80,"PCB Preferences");
  uVar1 = g_type_check_instance_cast(config_window,uVar1);
  gtk_window_set_wmclass(uVar1,"Pcb_Conf",&DAT_08154932);
  uVar1 = gtk_container_get_type();
  local_80 = g_type_check_instance_cast(config_window,uVar1);
  gtk_container_set_border_width(local_80,2);
  local_80 = gtk_hbox_new(0,4);
  uVar2 = g_type_check_instance_cast(config_window,uVar1);
  gtk_container_add(uVar2,local_80);
  uVar2 = gtk_scrolled_window_new(0,0);
  uVar3 = gtk_scrolled_window_get_type();
  uVar3 = g_type_check_instance_cast(uVar2,uVar3);
  gtk_scrolled_window_set_policy(uVar3,2,1);
  uVar3 = gtk_box_get_type();
  uVar4 = g_type_check_instance_cast(local_80,uVar3);
  gtk_box_pack_start(uVar4,uVar2,0,0,0);
  uVar4 = gtk_vbox_new(0,4);
  local_80 = g_type_check_instance_cast(local_80,uVar3);
  gtk_box_pack_start(local_80,uVar4,1,1,0);
  local_80 = gtk_notebook_new();
  local_7c = g_type_check_instance_cast(uVar4,uVar3);
  gtk_box_pack_start(local_7c,local_80,1,1,0);
  local_7c = gtk_notebook_get_type();
  config_notebook = (GtkNotebook *)g_type_check_instance_cast(local_80,local_7c);
  gtk_notebook_set_show_tabs(config_notebook,0);
  tree = (GtkTreeStore *)gtk_tree_store_new(2,0x40,0x18);
  gtk_tree_store_append(tree,&iter,0);
  local_80 = dcgettext(&DAT_0815492c,"General",5);
  gtk_tree_store_set(tree,&iter,0,local_80,0xffffffff);
  box = config_page_create(tree,&iter,config_notebook);
  local_80 = g_type_check_instance_cast(box,uVar1);
  gtk_container_set_border_width(local_80,6);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Enables",5);
  box_00 = ghid_category_vbox(box,category_header,4,2,1,1);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Use separate window for command entry",5);
  ghid_check_button_connected
            (box_00,(GtkWidget **)0x0,ghidgui->use_command_window,1,0,0,2,
             config_command_window_toggle_cb,(gpointer)0x0,category_header);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"Alternate window layout to allow smaller horizontal size",5
                         );
  ghid_check_button_connected
            (box_00,(GtkWidget **)0x0,ghidgui->compact_horizontal,1,0,0,2,
             config_compact_horizontal_toggle_cb,(gpointer)0x0,category_header);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"Alternate window layout to allow smaller vertical size",5);
  ghid_check_button_connected
            (box_00,(GtkWidget **)0x0,ghidgui->compact_vertical,1,0,0,2,
             config_compact_vertical_toggle_cb,(gpointer)0x0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Put layout name on the window title bar",5);
  ghid_check_button_connected
            (box_00,(GtkWidget **)0x0,ghidgui->ghid_title_window,1,0,0,2,config_title_window_cb,
             (gpointer)0x0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Backups",5);
  box_00 = ghid_category_vbox(box,category_header,4,2,1,1);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"If layout is modified at exit, save into PCB.%i.save",5);
  ghid_check_button_connected
            (box_00,(GtkWidget **)0x0,(int)Settings.SaveInTMP,1,0,0,2,config_general_toggle_cb,
             &Settings.SaveInTMP,category_header);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,
                          "Seconds between auto backups\n(set to zero to disable auto backups)",5);
  ghid_spin_button(box_00,(GtkWidget **)0x0,(gfloat)(float)Settings.BackupInterval,0.00000000,
                   3600.00000000,60.00000000,600.00000000,0,0,config_backup_spin_button_cb,
                   (gpointer)0x0,0,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,&DAT_0815396b,5);
  box = ghid_category_vbox(box,category_header,4,2,1,1);
  category_header =
       (gchar *)dcgettext(&DAT_0815492c,"Number of commands to remember in the history list",5);
  ghid_spin_button(box,(GtkWidget **)0x0,(gfloat)(float)ghidgui->history_size,5.00000000,25.00000000
                   ,1.00000000,1.00000000,0,0,config_history_spin_button_cb,(gpointer)0x0,0,
                   category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Auto pan speed",5);
  ghid_spin_button(box,(GtkWidget **)0x0,(gfloat)(float)ghidgui->auto_pan_speed,1.00000000,
                   10.00000000,1.00000000,1.00000000,0,0,config_auto_pan_speed_spin_button_cb,
                   (gpointer)0x0,0,category_header);
  gtk_tree_store_append(tree,&iter,0);
  local_80 = dcgettext(&DAT_0815492c,0x815c545,5);
  local_7c = 0xffffffff;
  gtk_tree_store_set(tree,&iter,0);
  box = config_page_create(tree,&iter,config_notebook);
  config_sizes_tab_create(box);
  gtk_tree_store_append(tree,&iter,0);
  local_80 = dcgettext(&DAT_0815492c,"Increments",5,local_80,local_7c);
  local_7c = 0xffffffff;
  gtk_tree_store_set(tree,&iter,0);
  box = config_page_create(tree,&iter,config_notebook);
  config_increments_tab_create(box);
  gtk_tree_store_append(tree,&iter,0);
  local_80 = dcgettext(&DAT_0815492c,0x815501b,5,local_80,local_7c);
  local_78 = 0xffffffff;
  local_84 = 0;
  gtk_tree_store_set(tree,&iter);
  box = config_page_create(tree,&iter,config_notebook);
  local_7c = g_type_check_instance_cast(box,uVar1);
  gtk_container_set_border_width(local_7c,6,local_84);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Element Directories",5,local_80,local_78);
  box = ghid_category_vbox(box,category_header,4,2,1,1);
  local_8c = &DAT_0814741b;
  local_80 = gtk_label_new();
  local_7c = gtk_label_get_type(local_8c);
  local_84 = g_type_check_instance_cast(local_80,local_7c);
  gtk_label_set_use_markup(local_84,1);
  local_78 = 5;
  local_84 = dcgettext(&DAT_0815492c,
                                              
                       "<small>Enter a \":\" separated list of custom top level\nelement directories.  For example:\n\t<b>~/gaf/pcb-elements:packages:/usr/local/pcb-elements</b>\nElements should be organized into subdirectories below each\ntop level directory.  Restart program for changes to take effect.</small>"
                      );
  local_7c = g_type_check_instance_cast(local_80,local_7c,local_78);
  gtk_label_set_markup(local_7c,local_84);
  local_7c = g_type_check_instance_cast(box,uVar3,local_78);
  uVar10 = 0;
  local_78 = 0;
  local_84 = 0;
  gtk_box_pack_start();
  box_00 = (GtkWidget *)gtk_entry_new();
  category_header = lib_newlib_config;
  library_newlib_entry = box_00;
  local_80 = gtk_entry_get_type(local_7c,local_80);
  local_80 = g_type_check_instance_cast(box_00,local_80);
  gtk_entry_set_text(local_80,category_header,local_84,local_78,uVar10);
  local_80 = g_type_check_instance_cast(box,uVar3);
  local_84 = 4;
  local_7c = 0;
  gtk_box_pack_start(local_80,box_00,0);
  gtk_tree_store_append(tree,&iter,0);
  local_80 = dcgettext(&DAT_0815492c,"Layers",5,local_7c,local_84);
  local_7c = 0xffffffff;
  gtk_tree_store_set(tree,&iter,0);
  box = config_page_create(tree,&iter,config_notebook);
  config_layers_tab_create(box);
  gtk_tree_store_append(tree,&iter,0);
  local_80 = dcgettext(&DAT_0815492c,"Colors",5,local_80,local_7c);
  local_78 = 0xffffffff;
  local_84 = 0;
  pGVar6 = tree;
  pGVar8 = &iter;
  gtk_tree_store_set();
  box = config_page_create(tree,&iter,config_notebook);
  config_colors_tab_create(box);
  local_7c = gtk_tree_view_get_type();
  local_80 = gtk_tree_model_get_type(pGVar6,pGVar8,local_84,local_80,local_78);
  local_80 = g_type_check_instance_cast(tree,local_80);
  local_80 = gtk_tree_view_new_with_model(local_80);
  local_80 = g_type_check_instance_cast(local_80,local_7c);
  local_7c = g_type_check_instance_cast(tree,0x50);
  g_object_unref(local_7c);
  local_7c = gtk_cell_renderer_text_new();
  local_7c = gtk_tree_view_column_new_with_attributes(0,local_7c,&DAT_081539ac,0,0);
  gtk_tree_view_append_column(local_80,local_7c);
  local_7c = gtk_widget_get_type();
  local_7c = g_type_check_instance_cast(local_80,local_7c);
  uVar1 = g_type_check_instance_cast(uVar2,uVar1);
  gtk_container_add(uVar1);
  uVar1 = gtk_tree_view_get_selection(local_80,local_7c);
  gtk_tree_selection_set_mode(uVar1,1);
  uVar1 = g_type_check_instance_cast(uVar1,0x50);
  local_78 = 0;
  local_84 = 0;
  local_7c = 0;
  pcVar9 = config_selection_changed_cb;
  uVar2 = 0x8155a12;
  g_signal_connect_data();
  local_80 = gtk_hbutton_box_new();
  uVar1 = gtk_button_box_get_type(uVar1,uVar2);
  uVar1 = g_type_check_instance_cast(local_80,uVar1);
  gtk_button_box_set_layout(uVar1,4,pcVar9,local_7c,local_84,local_78);
  uVar1 = g_type_check_instance_cast(local_80,uVar3);
  gtk_box_set_spacing(uVar1,5);
  uVar2 = g_type_check_instance_cast(uVar4,uVar3);
  local_84 = 0;
  local_7c = 0;
  uVar4 = 0;
  uVar1 = local_80;
  gtk_box_pack_start(uVar2);
  pcVar7 = "gtk-ok";
  uVar2 = gtk_button_new_from_stock();
  uVar1 = gtk_object_get_type(pcVar7,uVar1);
  iVar5 = g_type_check_instance_cast(uVar2,uVar1,uVar4,local_7c,local_84);
  *(uint *)(iVar5 + 0xc) = *(uint *)(iVar5 + 0xc) | 0x2000;
  uVar1 = g_type_check_instance_cast(uVar2,0x50,uVar4,local_7c,local_84);
  local_84 = 0;
  local_7c = 0;
  uVar4 = 0;
  pcVar9 = config_close_cb;
  g_signal_connect_data(uVar1,"clicked");
  local_80 = g_type_check_instance_cast(local_80,uVar3,pcVar9,uVar4,local_7c);
  local_7c = 0;
  uVar4 = 1;
  uVar3 = 1;
  uVar1 = uVar2;
  gtk_box_pack_start(local_80);
  gtk_widget_grab_default(uVar2);
  gtk_widget_show_all(config_window,uVar1,uVar3,uVar4,local_7c,local_84);
  return;
}



FILE * __regparm3 config_file_open(gchar *mode)

{
  int iVar1;
  char *__filename;
  gchar *src;
  FILE *pFVar2;
  
  iVar1 = g_get_home_dir();
  if (iVar1 == 0) {
    pFVar2 = (FILE *)0x0;
    g_log(0,0x20,"config_file_open: Can\'t get home directory!");
  }
  else {
    if (config_dir == (gchar *)0x0) {
      config_dir = (gchar *)g_build_path(0x815d1de,iVar1,&DAT_0815492b,0);
      iVar1 = g_file_test(config_dir,4);
      if ((iVar1 == 0) && (iVar1 = mkdir(config_dir,0x1ed), iVar1 < 0)) {
        g_log(0,0x20,"config_file_open: Can\'t make \"%s\" directory!",config_dir);
        g_free(config_dir);
        config_dir = (gchar *)0x0;
        return (FILE *)0x0;
      }
    }
    if (color_dir == (gchar *)0x0) {
      color_dir = (gchar *)g_build_path(0x815d1de,config_dir,0x8153869,0);
      iVar1 = g_file_test(color_dir,4);
      if (iVar1 == 0) {
        iVar1 = mkdir(color_dir,0x1ed);
        if (iVar1 < 0) {
          g_log(0,0x20,"config_file_open: Can\'t make \"%s\" directory!",color_dir);
          g_free(color_dir);
          color_dir = (gchar *)0x0;
        }
        src = (gchar *)g_build_path(0x815d1de,color_dir,"Default",0);
        dup_string(&color_file,src);
        g_free(src);
      }
    }
    __filename = (char *)g_build_path(0x815d1de,config_dir,"preferences",0);
    pFVar2 = (FILE *)fopen(__filename,mode);
    g_free(__filename);
  }
  return pFVar2;
}



void ghid_config_files_write(void)

{
  int **ppiVar1;
  ConfigType CVar2;
  gchar **ppgVar3;
  FILE *__stream;
  int iVar4;
  ConfigAttribute *pCVar5;
  
  if ((ghidgui->config_modified == 0) || (__stream = config_file_open("w"), __stream == (FILE *)0x0)
     ) {
    return;
  }
  __fprintf_chk(__stream,1,"### PCB configuration file. ###\n");
  pCVar5 = config_attributes;
  do {
    while( true ) {
      CVar2 = pCVar5->type;
      if (CVar2 != CONFIG_Integer) break;
      iVar4 = *(int *)pCVar5->value;
LAB_080f6e36:
      __fprintf_chk(__stream,1,"%s = %d\n",pCVar5->name,iVar4);
LAB_080f6e58:
      pCVar5 = pCVar5 + 1;
      if (pCVar5 == (ConfigAttribute *)&y) goto LAB_080f6eb8;
    }
    if (CVar2 == CONFIG_Boolean) {
      iVar4 = (int)*(char *)pCVar5->value;
      goto LAB_080f6e36;
    }
    if (CVar2 == CONFIG_Real) {
      __fprintf_chk(__stream,1,"%s = %f\n",pCVar5->name,*(undefined8 *)pCVar5->value);
      goto LAB_080f6e58;
    }
    if (CVar2 != CONFIG_String) goto LAB_080f6e58;
    ppiVar1 = (int **)&pCVar5->value;
    if (**ppiVar1 == 0) {
      __fprintf_chk(__stream,1,"# %s = NULL\n",pCVar5->name);
      goto LAB_080f6e58;
    }
    ppgVar3 = &pCVar5->name;
    pCVar5 = pCVar5 + 1;
    __fprintf_chk(__stream,1,"%s = %s\n",*ppgVar3,**ppiVar1);
  } while (pCVar5 != (ConfigAttribute *)&y);
LAB_080f6eb8:
  fclose((FILE *)__stream);
  ghidgui->config_modified = 0;
  return;
}



void config_close_cb(gpointer data)

{
  Cardinal CVar1;
  Cardinal CVar2;
  bool bVar3;
  int iVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  PCBTypePtr pPVar8;
  gchar *src;
  gboolean gVar9;
  Cardinal CVar10;
  int iVar11;
  char *Format;
  Cardinal CVar12;
  DataTypePtr *pDVar13;
  LayerGroupType *pLVar14;
  LayerGroupType *pLVar15;
  byte bVar16;
  int local_24;
  
  bVar16 = 0;
  uVar5 = gtk_toggle_button_get_type();
  uVar6 = g_type_check_instance_cast(use_board_size_default_button,uVar5);
  iVar7 = gtk_toggle_button_get_active(uVar6);
  if (iVar7 != 0) {
    Settings.MaxWidth = new_board_width;
    Settings.MaxHeight = new_board_height;
    ghidgui->config_modified = 1;
  }
  uVar5 = g_type_check_instance_cast(use_drc_sizes_default_button,uVar5);
  iVar7 = gtk_toggle_button_get_active(uVar5);
  pPVar8 = PCB;
  if (iVar7 == 0) {
    if (PCB->MaxWidth == new_board_width) {
LAB_080f7237:
      if (pPVar8->MaxHeight == new_board_height) goto LAB_080f6fdf;
    }
  }
  else {
    Settings.Bloat = PCB->Bloat;
    Settings.IsleArea = PCB->IsleArea;
    Settings.Shrink = PCB->Shrink;
    Settings.minWid = PCB->minWid;
    Settings.minSlk = PCB->minSlk;
    Settings.minDrill = PCB->minDrill;
    Settings.minRing = PCB->minRing;
    ghidgui->config_modified = 1;
    if (pPVar8->MaxWidth == new_board_width) goto LAB_080f7237;
  }
  ChangePCBSize(new_board_width,new_board_height);
  pPVar8 = PCB;
LAB_080f6fdf:
  pDVar13 = pPVar8->Data;
  if (0 < pDVar13->LayerN) {
    bVar3 = false;
    iVar7 = 0;
    do {
      src = ghid_entry_get_text(layer_entry[iVar7]);
      gVar9 = dup_string((gchar **)(&pDVar13->field_0x4c + iVar7 * 0x5c),src);
      if (gVar9 != 0) {
        bVar3 = true;
      }
      iVar7 = iVar7 + 1;
      pDVar13 = PCB->Data;
    } while (iVar7 < pDVar13->LayerN);
    layers_applying = 1;
    if (bVar3) {
      ghid_layer_buttons_update();
    }
  }
  pPVar8 = PCB;
  layers_applying = 0;
  if (groups_modified != 0) {
    CVar1 = PCB->Data->LayerN;
    if (0 < (int)CVar1) {
      CVar10 = 0;
      do {
        layer_groups.Number[CVar10] = 0;
        CVar10 = CVar10 + 1;
      } while (CVar10 != CVar1);
    }
    iVar7 = 0;
    local_24 = 0;
    CVar10 = CVar1 + 1;
    if (-1 < (int)CVar10) {
      iVar7 = 0;
      CVar12 = 0;
      while( true ) {
        iVar11 = config_layer_group[CVar12] + -1;
        CVar2 = layer_groups.Number[iVar11];
        layer_groups.Number[CVar2 + 0x10 + iVar11 * 0x12] = CVar12;
        layer_groups.Number[iVar11] = CVar2 + 1;
        iVar4 = iVar7;
        if ((CVar12 != CVar10) && (iVar4 = iVar11, iVar11 = local_24, CVar1 != CVar12)) {
          iVar4 = iVar7;
        }
        local_24 = iVar11;
        iVar7 = iVar4;
        if ((int)CVar10 < (int)(CVar12 + 1)) break;
        CVar12 = CVar12 + 1;
      }
    }
    if ((layer_groups.Number[iVar7] < 2) || (layer_groups.Number[local_24] < 2)) {
      Format = (char *)dcgettext(&DAT_0815492c,
                                                                  
                                 "Both \'solder side\' or \'component side\' layers must have at least\n\tone other layer in their group.\n"
                                 ,5);
      Message(Format);
    }
    else {
      if (iVar7 == local_24) {
        Format = (char *)dcgettext(&DAT_0815492c,
                                                                      
                                   "The \'solder side\' and \'component side\' layers are not allowed\n\tto be in the same layer group #\n"
                                   ,5);
        Message(Format);
      }
      else {
        iVar7 = 0x130;
        pLVar14 = &layer_groups;
        pLVar15 = &pPVar8->LayerGroups;
        while (iVar7 != 0) {
          iVar7 = iVar7 + -1;
          pLVar15->Number[0] = pLVar14->Number[0];
          pLVar14 = (LayerGroupType *)(pLVar14->Number + (uint)bVar16 * 0x3ffffffe + 1);
          pLVar15 = (LayerGroupType *)((int)pLVar15 + (uint)bVar16 * -8 + 4);
        }
        ghid_invalidate_all();
        groups_modified = 0;
      }
    }
  }
  src = ghid_entry_get_text(library_newlib_entry);
  gVar9 = dup_string(&lib_newlib_config,src);
  if (gVar9 != 0) {
    ghidgui->config_modified = 1;
  }
  ghid_config_files_write();
  config_sizes_vbox = (GtkWidget *)0x0;
  config_increments_vbox = (GtkWidget *)0x0;
  config_groups_table = (GtkWidget *)0x0;
  config_groups_vbox = (GtkWidget *)0x0;
  config_groups_window = (GtkWidget *)0x0;
  gtk_widget_destroy(config_window);
  config_window = (GtkWidget *)0x0;
  return;
}



gchar * __regparm3 expand_dir(gchar *dir)

{
  undefined4 uVar1;
  gchar *pgVar2;
  
  if (*dir != '~') {
    pgVar2 = (gchar *)g_strdup(dir);
    return pgVar2;
  }
  uVar1 = g_get_home_dir();
  pgVar2 = (gchar *)g_build_filename(uVar1,dir + 1,0);
  return pgVar2;
}



gint __regparm3 parse_option_line(gchar *line,gchar **option_result,gchar **arg_result)

{
  char *pcVar1;
  gchar *pgVar2;
  gint gVar3;
  char cVar4;
  gchar *__s;
  int in_GS_OFFSET;
  gchar arg [512];
  gchar option [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (option_result != (gchar **)0x0) {
    *option_result = (gchar *)0x0;
  }
  if (arg_result != (gchar **)0x0) {
    *arg_result = (gchar *)0x0;
  }
  cVar4 = *line;
  if ((cVar4 == ' ') || (cVar4 == '\t')) {
    do {
      do {
        line = line + 1;
        cVar4 = *line;
      } while (cVar4 == '\t');
    } while (cVar4 == ' ');
  }
  if ((((cVar4 == '\n') || (cVar4 == '\0')) || (cVar4 == '#')) || (cVar4 == '[')) {
    gVar3 = 0;
  }
  else {
    pcVar1 = strchr(line,10);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '\0';
    }
    __s = arg;
    arg[0] = '\0';
    sscanf(line,"%63s %511[^\n]",option,__s);
    if ((option[0] == '\0') || (pcVar1 = option, option[0] == ':')) {
      pcVar1 = option;
    }
    else {
      while (option[0] != '=') {
        pcVar1 = pcVar1 + 1;
        option[0] = *pcVar1;
        if ((option[0] == ':') || (option[0] == '\0')) break;
      }
    }
    *pcVar1 = '\0';
    while ((((cVar4 = *__s, cVar4 == '\t' || (cVar4 == ' ')) || (cVar4 == ':')) ||
           ((cVar4 == '=' || (cVar4 == '\"'))))) {
      __s = __s + 1;
    }
    pcVar1 = strchr(__s,0x22);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '\0';
    }
    if (option_result != (gchar **)0x0) {
      pgVar2 = (gchar *)g_strdup(option);
      *option_result = pgVar2;
    }
    if ((arg_result == (gchar **)0x0) || (*__s == '\0')) {
      gVar3 = 1;
    }
    else {
      __s = (gchar *)g_strdup(__s);
      *arg_result = __s;
      gVar3 = 2;
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return gVar3;
}



void config_file_read(void)

{
  int iVar1;
  undefined *puVar2;
  double *pdVar3;
  long *plVar4;
  FILE *__stream;
  char *__nptr;
  gint gVar5;
  int iVar6;
  long lVar7;
  gchar *src;
  ConfigAttribute *pCVar8;
  char *__s1;
  int in_GS_OFFSET;
  double dVar9;
  gchar *local_228;
  gchar *local_224;
  gchar buf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = config_file_open("r");
  if (__stream != (FILE *)0x0) {
    buf[0] = '\0';
    while (__nptr = fgets(buf,0x200,(FILE *)__stream), __nptr != (char *)0x0) {
      gVar5 = parse_option_line(buf,&local_224,&local_228);
      __s1 = local_224;
      __nptr = local_228;
      if (0 < gVar5) {
        pCVar8 = config_attributes;
        do {
          if ((__s1 != (char *)0x0) && (iVar6 = strcmp(__s1,pCVar8->name), iVar6 == 0)) {
            if (pCVar8 != (ConfigAttribute *)0x0) {
              puVar2 = (undefined *)pCVar8->type;
              if (puVar2 == &DAT_00000001) {
                plVar4 = (long *)pCVar8->value;
                lVar7 = strtol(__nptr,(char **)0x0,10);
                *plVar4 = lVar7;
                __s1 = local_224;
              }
              else {
                if (puVar2 == (undefined *)0x0) {
                  puVar2 = (undefined *)pCVar8->value;
                  lVar7 = strtol(__nptr,(char **)0x0,10);
                  *puVar2 = (char)lVar7;
                  __s1 = local_224;
                }
                else {
                  if (puVar2 == (undefined *)0x2) {
                    pdVar3 = (double *)pCVar8->value;
                    dVar9 = strtod(__nptr,(char **)0x0);
                    *pdVar3 = dVar9;
                    __s1 = local_224;
                  }
                  else {
                    if (puVar2 == (undefined *)0x3) {
                      src = "";
                      if (__nptr != (char *)0x0) {
                        src = __nptr;
                      }
                      dup_string((gchar **)pCVar8->value,src);
                      __s1 = local_224;
                    }
                  }
                }
              }
            }
            break;
          }
          pCVar8 = pCVar8 + 1;
        } while (pCVar8 != (ConfigAttribute *)&y);
      }
      g_free(__s1);
      g_free(local_228);
    }
    fclose((FILE *)__stream);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 parse_optionv(gint *argc,gchar ***argv,gboolean from_cmd_line)

{
  HID_Attribute *pHVar1;
  char **ppcVar2;
  char *__s2;
  undefined4 *puVar3;
  double *pdVar4;
  long *plVar5;
  int iVar6;
  undefined4 uVar7;
  char *__s1;
  int iVar8;
  long lVar9;
  gint gVar10;
  char *__s2_00;
  HID_AttrNode *pHVar11;
  HID_Attribute *pHVar12;
  double dVar13;
  int local_28;
  
LAB_080f76cf:
  do {
    local_28 = *argc;
    if (local_28 == 0) {
      gVar10 = 1;
LAB_080f7934:
      *argc = gVar10;
      *argv = *argv + -1;
      return;
    }
    ppcVar2 = *argv;
    __s2_00 = *ppcVar2;
    if (((*__s2_00 != '-') || (__s2_00[1] != '-')) && (from_cmd_line != 0)) {
      gVar10 = local_28 + 1;
      goto LAB_080f7934;
    }
    if (hid_attr_nodes != (HID_AttrNode *)0x0) {
      pHVar11 = hid_attr_nodes;
      do {
        pHVar12 = pHVar11->attributes;
        pHVar1 = pHVar12 + pHVar11->n;
        if (pHVar12 < pHVar1) {
          while ((__s2 = pHVar12->name, __s2 == (char *)0x0 ||
                 (iVar6 = strcmp(__s2_00 + (~-(uint)(from_cmd_line == 0) & 2),__s2), iVar6 != 0))) {
            pHVar12 = pHVar12 + 1;
            if (pHVar1 <= pHVar12) goto LAB_080f77be;
          }
          switch(pHVar12->type) {
          default:
            goto switchD_080f7755_caseD_0;
          case HID_Integer:
            plVar5 = (long *)pHVar12->value;
            if (plVar5 == (long *)0x0) {
              lVar9 = strtol(ppcVar2[1],(char **)0x0,0);
              (pHVar12->default_val).int_value = lVar9;
            }
            else {
              lVar9 = strtol(ppcVar2[1],(char **)0x0,0);
              *plVar5 = lVar9;
            }
            break;
          case HID_Real:
            pdVar4 = (double *)pHVar12->value;
            if (pdVar4 == (double *)0x0) {
              dVar13 = strtod(ppcVar2[1],(char **)0x0);
              (pHVar12->default_val).real_value = dVar13;
            }
            else {
              dVar13 = strtod(ppcVar2[1],(char **)0x0);
              *pdVar4 = dVar13;
            }
            break;
          case HID_String:
            puVar3 = (undefined4 *)pHVar12->value;
            if (puVar3 == (undefined4 *)0x0) {
              __s2_00 = (char *)g_strdup(ppcVar2[1]);
              (pHVar12->default_val).str_value = __s2_00;
            }
            else {
              uVar7 = g_strdup(ppcVar2[1]);
              *puVar3 = uVar7;
            }
            break;
          case HID_Boolean:
            if ((undefined *)pHVar12->value == (undefined *)0x0) {
              *(undefined **)&(pHVar12->default_val).int_value = &DAT_00000001;
              local_28 = *argc;
            }
            else {
              *(undefined *)pHVar12->value = 1;
              local_28 = *argc;
            }
            goto switchD_080f7755_caseD_0;
          case HID_Enum:
            goto switchD_080f7755_caseD_5;
          case HID_Mixed:
          case HID_Path:
                    // WARNING: Subroutine does not return
            abort();
          }
          *argc = *argc + -1;
          local_28 = *argc;
          *argv = *argv + 1;
          goto switchD_080f7755_caseD_0;
        }
LAB_080f77be:
        pHVar11 = pHVar11->next;
      } while (pHVar11 != (HID_AttrNode *)0x0);
    }
    if (from_cmd_line != 0) {
      __fprintf_chk(stderr,1,"unrecognized option: %s\n",__s2_00);
                    // WARNING: Subroutine does not return
      exit(1);
    }
    __fprintf_chk(stderr,1,"unrecognized option: %s\n",__s2_00);
  } while( true );
switchD_080f7755_caseD_5:
  __s2_00 = ppcVar2[1];
  ppcVar2 = pHVar12->enumerations;
  __s1 = *ppcVar2;
  if (__s1 == (char *)0x0) goto LAB_080f78fb;
  iVar6 = 0;
  while (iVar8 = strcmp(__s1,__s2_00), iVar8 != 0) {
    iVar6 = iVar6 + 1;
    __s1 = ppcVar2[iVar6];
    if (__s1 == (char *)0x0) {
LAB_080f78fb:
      __fprintf_chk(stderr,1,"ERROR:  \"%s\" is an unknown value for the --%s option\n",__s2_00,__s2
                   );
                    // WARNING: Subroutine does not return
      exit(1);
    }
  }
  (pHVar12->default_val).int_value = iVar6;
  *argc = *argc + -1;
  local_28 = *argc;
  (pHVar12->default_val).str_value = __s2_00;
  *argv = *argv + 1;
switchD_080f7755_caseD_0:
  *argc = local_28 + -1;
  *argv = *argv + 1;
  goto LAB_080f76cf;
}



void __regparm3 load_rc_file(gchar *path)

{
  int iVar1;
  FILE *__stream;
  char *pcVar2;
  int in_GS_OFFSET;
  gchar *av [2];
  gint local_428;
  gchar **local_424;
  gchar buf [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen(path,"r");
  if (__stream != (FILE *)0x0) {
    if (Settings.verbose != 0) {
      __printf_chk(1,"Loading pcbrc file: %s\n",path);
    }
    while( true ) {
      pcVar2 = fgets(buf,0x400,__stream);
      if (pcVar2 == (char *)0x0) break;
      local_424 = av;
      local_428 = parse_option_line(buf,av,av + 1);
      if (0 < local_428) {
        parse_optionv(&local_428,&local_424,0);
      }
      g_free(av[0]);
      g_free(av[1]);
    }
    fclose(__stream);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ghid_config_init(void)

{
  double dVar1;
  double *pdVar2;
  HID_AttrNode *pHVar3;
  anon_enum_32_for_type aVar4;
  GhidGui *pGVar5;
  int iVar6;
  undefined4 uVar7;
  size_t sVar8;
  char *__s1;
  HID_Attribute **ppHVar9;
  HID_Attribute *pHVar10;
  ConfigAttribute *pCVar11;
  char *pcVar12;
  char *pcVar13;
  bool bVar14;
  byte bVar15;
  ConfigAttribute dummy_attribute;
  
  pGVar5 = ghidgui;
  bVar15 = 0;
  ghidgui->n_mode_button_columns = 3;
  pGVar5->small_label_markup = 1;
  pGVar5->auto_pan_on = 1;
  pGVar5->auto_pan_speed = 3;
  pGVar5->history_size = 5;
  dup_string(&color_file,"");
  pHVar3 = hid_attr_nodes;
  do {
    if (pHVar3 == (HID_AttrNode *)0x0) {
      return;
    }
    pHVar10 = pHVar3->attributes;
    iVar6 = pHVar3->n;
    if (pHVar10 < pHVar10 + iVar6) {
      do {
        pdVar2 = (double *)pHVar10->value;
        if (pdVar2 != (double *)0x0) {
          __s1 = pHVar10->name;
          pCVar11 = config_attributes;
          do {
            if ((__s1 != (char *)0x0) && (iVar6 = strcmp(__s1,pCVar11->name), iVar6 == 0)) {
              if ((pCVar11->value == (void *)0x0) && (pCVar11 != (ConfigAttribute *)0x0))
              goto LAB_080f7bbf;
              break;
            }
            pCVar11 = pCVar11 + 1;
          } while (pCVar11 != (ConfigAttribute *)&y);
          pCVar11 = &dummy_attribute;
LAB_080f7bbf:
          aVar4 = pHVar10->type;
          *(undefined **)&pCVar11->type = &DAT_00000004;
          *(double **)&pCVar11->value = pdVar2;
          if (HID_Path < aVar4) {
                    // WARNING: Subroutine does not return
            abort();
          }
          switch(pHVar10->type) {
          case HID_Integer:
            iVar6 = (pHVar10->default_val).int_value;
            *(undefined **)&pCVar11->type = &DAT_00000001;
            *(int *)pdVar2 = iVar6;
            iVar6 = pHVar3->n;
            break;
          case HID_Real:
            dVar1 = (pHVar10->default_val).real_value;
            pCVar11->type = CONFIG_Real;
            *pdVar2 = dVar1;
            iVar6 = pHVar3->n;
            break;
          case HID_String:
            if (__s1 != (char *)0x0) {
              uVar7 = g_strdup((pHVar10->default_val).str_value);
              pCVar11->type = CONFIG_String;
              *(undefined4 *)pdVar2 = uVar7;
              __s1 = pHVar10->name;
              sVar8 = strlen(__s1);
              if ((int)sVar8 < 7) goto LAB_080f7bdf;
              __s1 = strstr(__s1,"color");
              bVar14 = __s1 == (char *)0x0;
              if (!bVar14) {
                ppHVar9 = (HID_Attribute **)g_malloc0(0x18);
                __s1 = pHVar10->name;
                iVar6 = 0xb;
                *ppHVar9 = pHVar10;
                pcVar12 = __s1;
                pcVar13 = "layer-color";
                do {
                  if (iVar6 == 0) break;
                  iVar6 = iVar6 + -1;
                  bVar14 = *pcVar12 == *pcVar13;
                  pcVar12 = pcVar12 + (uint)bVar15 * -2 + 1;
                  pcVar13 = pcVar13 + (uint)bVar15 * -2 + 1;
                } while (bVar14);
                if (bVar14) {
                  ppHVar9[1] = (HID_Attribute *)0x2;
                }
                else {
                  iVar6 = 0x14;
                  pcVar12 = __s1;
                  pcVar13 = "layer-selected-color";
                  do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar14 = *pcVar12 == *pcVar13;
                    pcVar12 = pcVar12 + (uint)bVar15 * -2 + 1;
                    pcVar13 = pcVar13 + (uint)bVar15 * -2 + 1;
                  } while (bVar14);
                  if (bVar14) {
                    ppHVar9[1] = (HID_Attribute *)0x3;
                  }
                  else {
                    iVar6 = strncmp(__s1 + (sVar8 - 0xe),"selected-color",0xe);
                    ppHVar9[1] = (HID_Attribute *)(uint)(iVar6 == 0);
                  }
                }
                config_color_list = (GList *)g_list_append(config_color_list,ppHVar9);
              }
            }
          default:
            iVar6 = pHVar3->n;
            break;
          case HID_Boolean:
            *(char *)pdVar2 = (char)(pHVar10->default_val).int_value;
            pCVar11->type = CONFIG_Boolean;
            iVar6 = pHVar3->n;
            break;
          case HID_Enum:
            *(int *)pdVar2 = (pHVar10->default_val).int_value;
LAB_080f7bdf:
            iVar6 = pHVar3->n;
          }
        }
        pHVar10 = pHVar10 + 1;
      } while (pHVar10 < pHVar3->attributes + iVar6);
    }
    pHVar3 = pHVar3->next;
  } while( true );
}



void ghid_config_files_read(gint *argc,gchar ***argv)

{
  double dVar1;
  GList *pGVar2;
  undefined4 uVar3;
  int iVar4;
  gchar *path;
  char *__s;
  int local_24;
  int local_20 [4];
  
  ghidgui = &_ghidgui;
  ghid_config_init();
  load_rc_file("/etc/pcbrc");
  load_rc_file("/usr/local/etc/pcbrc");
  path = (gchar *)g_build_filename(pcblibdir,"pcbrc",0);
  load_rc_file(path);
  g_free(path);
  uVar3 = g_get_home_dir();
  path = (gchar *)g_build_filename(uVar3,&DAT_08153a27,0);
  load_rc_file(path);
  g_free(path);
  load_rc_file("pcbrc");
  config_file_read();
  config_colors_read(color_file);
  *argc = *argc + -1;
  *argv = *argv + 1;
  parse_optionv(argc,argv,1);
  if ((board_size_override != (gchar *)0x0) &&
     (iVar4 = sscanf(board_size_override,"%dx%d",local_20,&local_24), iVar4 == 2)) {
    if (Settings.grid_units_mm == '\0') {
      dVar1 = (double)local_20[0] * 100.00000000;
    }
    else {
      dVar1 = (double)local_20[0] / 0.00025400;
    }
    Settings.MaxWidth = (int)ROUND(dVar1 + 0.50000000);
    if (Settings.grid_units_mm == '\0') {
      Settings.MaxHeight = (int)ROUND((float)local_24 * 100.00000000 + 0.50000000);
    }
    else {
      Settings.MaxHeight = (int)ROUND((double)local_24 / 0.00025400 + 0.50000000);
    }
  }
  pGVar2 = lib_newlib_list;
  __s = Settings.LibraryTree;
  if ((lib_newlib_config != (gchar *)0x0) && (*lib_newlib_config != '\0')) {
    __s = (char *)g_strdup(lib_newlib_config);
    path = strtok(__s,":");
    while ((path != (gchar *)0x0 && (*path != '\0'))) {
      path = expand_dir(path);
      lib_newlib_list = (GList *)g_list_prepend(lib_newlib_list,path);
      path = strtok((char *)0x0,":");
    }
    g_free(__s);
    pGVar2 = lib_newlib_list;
    __s = Settings.LibraryTree;
  }
  while (pGVar2 != (GList *)0x0) {
    Settings.LibraryTree = __s;
    path = expand_dir((gchar *)pGVar2->data);
    Settings.LibraryTree = (char *)g_strconcat(__s,&DAT_0814d79c,path,0);
    g_free(path);
    g_free(__s);
    pGVar2 = pGVar2->next;
    __s = Settings.LibraryTree;
  }
  Settings.LibraryTree = __s;
  return;
}



void ghid_dialog_export(void)

{
  anon_subr_void_char_ptr_for_log *paVar1;
  HID **ppHVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  char *pcVar7;
  int iVar8;
  HID **ppHVar9;
  HID *pHVar10;
  HID **ppHVar11;
  char *local_48;
  code *local_44;
  char *local_40;
  undefined4 local_3c;
  undefined4 local_38;
  
  uVar3 = gtk_tooltips_new();
  uVar4 = gtk_window_get_type();
  uVar5 = g_type_check_instance_cast(ghid_port.top_window,uVar4);
  uVar6 = dcgettext(&DAT_0815492c,"PCB Export Layout",5);
  local_38 = 0;
  local_3c = 0xfffffffa;
  local_40 = "gtk-cancel";
  export_dialog = (GtkWidget *)gtk_dialog_new_with_buttons(uVar6,uVar5,3,"gtk-cancel",0xfffffffa,0);
  uVar4 = g_type_check_instance_cast(export_dialog,uVar4);
  local_44 = (code *)&DAT_08154932;
  gtk_window_set_wmclass(uVar4,"PCB_Export",&DAT_08154932);
  pcVar7 = (char *)gtk_vbox_new(0,6);
  uVar4 = gtk_container_get_type();
  uVar5 = g_type_check_instance_cast(pcVar7,uVar4);
  gtk_container_set_border_width(uVar5,6);
  uVar5 = gtk_dialog_get_type();
  iVar8 = g_type_check_instance_cast(export_dialog,uVar5);
  uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar8 + 0x94),uVar4);
  local_48 = pcVar7;
  gtk_container_add(uVar4,pcVar7);
  ppHVar9 = hid_enumerate();
  pHVar10 = *ppHVar9;
  if (pHVar10 != (HID *)0x0) {
    ppHVar2 = ppHVar9 + 1;
    do {
      while (ppHVar11 = ppHVar2, (*(byte *)&pHVar10->field_0xc & 4) != 0) {
        exporter = pHVar10;
        uVar4 = gtk_button_new_with_label
                          ((*ppHVar9)->name,local_48,local_44,local_40,local_3c,local_38);
        gtk_tooltips_set_tip(uVar3,uVar4,(*ppHVar9)->description,0);
        uVar6 = gtk_box_get_type();
        uVar6 = g_type_check_instance_cast(pcVar7,uVar6);
        gtk_box_pack_start(uVar6,uVar4,0,0,0);
        local_40 = (char *)*ppHVar9;
        uVar4 = g_type_check_instance_cast(uVar4,0x50);
        local_38 = 0;
        local_3c = 0;
        local_44 = exporter_clicked_cb;
        local_48 = "clicked";
        g_signal_connect_data(uVar4);
        pHVar10 = *ppHVar11;
        ppHVar2 = ppHVar11 + 1;
        ppHVar9 = ppHVar11;
        if (pHVar10 == (HID *)0x0) goto LAB_080f81de;
      }
      pHVar10 = *ppHVar11;
      ppHVar2 = ppHVar11 + 1;
      ppHVar9 = ppHVar11;
    } while (pHVar10 != (HID *)0x0);
  }
LAB_080f81de:
  if (exporter == (HID *)0x0) {
    paVar1 = gui->log;
    local_40 = (char *)dcgettext(&DAT_0815492c,"Can\'t find a suitable exporter HID",5);
    (*paVar1)(local_40);
  }
  gtk_widget_show_all(export_dialog);
  uVar3 = g_type_check_instance_cast(export_dialog,uVar5);
  gtk_dialog_run(uVar3);
  if (export_dialog != (GtkWidget *)0x0) {
    gtk_widget_destroy(export_dialog);
  }
  exporter = (HID *)0x0;
  export_dialog = (GtkWidget *)0x0;
  return;
}



int ghid_attribute_dialog
              (HID_Attribute *attrs,int n_attrs,HID_Attr_Val *results,char *title,char *descr)

{
  int iVar1;
  char "ghid_attribute_dialog" [22];
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  undefined4 local_a0;
  GtkWidget *box;
  undefined4 uVar7;
  undefined4 uVar8;
  GtkWidget *box_00;
  HID_Attribute *pHVar9;
  int iVar10;
  char *local_a4;
  float value;
  undefined4 local_9c;
  gfloat local_98;
  gfloat local_94;
  gint local_90;
  code *local_88;
  HID_Attr_Val *local_84;
  undefined4 local_5c;
  undefined4 local_38;
  GtkWidget *local_20 [4];
  
  uVar2 = gtk_tooltips_new();
  uVar3 = gtk_window_get_type();
  uVar4 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  uVar5 = dcgettext(&DAT_0815492c,title,5);
  uVar4 = gtk_dialog_new_with_buttons(uVar5,uVar4,3,"gtk-cancel",0xffffffff,"gtk-ok",0xfffffffb,0);
  uVar3 = g_type_check_instance_cast(uVar4,uVar3);
  gtk_window_set_wmclass(uVar3,"PCB_attribute_editor",&DAT_08154932);
  box = (GtkWidget *)gtk_vbox_new(0,6);
  uVar3 = gtk_container_get_type();
  uVar5 = g_type_check_instance_cast(box,uVar3);
  gtk_container_set_border_width(uVar5,6);
  uVar5 = gtk_dialog_get_type();
  iVar6 = g_type_check_instance_cast(uVar4,uVar5);
  local_a0 = g_type_check_instance_cast(*(undefined4 *)(iVar6 + 0x94),uVar3);
  gtk_container_add(local_a0,box);
  if (descr == (char *)0x0) {
    descr = &DAT_0814741b;
  }
  local_98 = 0.00000000;
  local_9c = 1;
  local_a0 = 2;
  local_a4 = &DAT_00000004;
  box = ghid_category_vbox(box,descr,4,2,1,1);
  if (n_attrs < 1) {
LAB_080f8440:
    iVar10 = 1;
    gtk_widget_show_all(uVar4);
    uVar2 = g_type_check_instance_cast(uVar4,uVar5);
    iVar6 = gtk_dialog_run(uVar2);
    if (iVar6 == -5) {
      if (0 < n_attrs) {
        iVar6 = 0;
        do {
          results->int_value = (attrs->default_val).int_value;
          local_a4 = (attrs->default_val).str_value;
          results->str_value = local_a4;
          *(undefined4 *)&results->real_value = *(undefined4 *)&(attrs->default_val).real_value;
          *(undefined4 *)((int)&results->real_value + 4) =
               *(undefined4 *)((int)&(attrs->default_val).real_value + 4);
          if (local_a4 != (char *)0x0) {
            local_a4 = (char *)__strdup(local_a4);
            results->str_value = local_a4;
          }
          iVar6 = iVar6 + 1;
          attrs = attrs + 1;
          results = results + 1;
        } while (iVar6 < n_attrs);
      }
      iVar10 = 0;
    }
    gtk_widget_destroy(uVar4);
    return iVar10;
  }
  iVar6 = 0;
  pHVar9 = attrs;
LAB_080f8403:
  do {
    if (pHVar9->help_text == &DAT_00000001) goto LAB_080f83f8;
    if (HID_Path < pHVar9->type) {
      local_a4 = "ghid_attribute_dialog";
      descr = "%s: unknown type of HID attribute\n";
      __printf_chk(1,"%s: unknown type of HID attribute\n",0x81548ba,local_a0,local_9c,local_98);
      goto LAB_080f83f8;
    }
    switch(pHVar9->type) {
    case HID_Label:
      box_00 = (GtkWidget *)gtk_label_new(pHVar9->name,descr);
      local_20[0] = box_00;
      local_a0 = gtk_box_get_type();
      local_a0 = g_type_check_instance_cast(box,local_a0);
      local_9c = 0;
      gtk_box_pack_start(local_a0,box_00,0,0);
      break;
    case HID_Integer:
      box_00 = (GtkWidget *)gtk_hbox_new(0,4);
      local_5c = gtk_box_get_type();
      local_a0 = g_type_check_instance_cast(box,local_5c);
      gtk_box_pack_start(local_a0,box_00,0,0,0);
      local_84 = &pHVar9->default_val;
      local_88 = intspinner_changed_cb;
      local_90 = 0;
      local_94 = 1.00000000;
      local_98 = 1.00000000;
      iVar10 = pHVar9->max_val;
      iVar1 = pHVar9->min_val;
      value = (float)(pHVar9->default_val).int_value;
      goto LAB_080f88c7;
    case HID_Real:
      box_00 = (GtkWidget *)gtk_hbox_new(0,4);
      local_5c = gtk_box_get_type();
      local_a0 = g_type_check_instance_cast(box,local_5c);
      gtk_box_pack_start(local_a0,box_00,0,0,0);
      local_84 = (HID_Attr_Val *)&(pHVar9->default_val).real_value;
      local_88 = dblspinner_changed_cb;
      local_90 = 3;
      local_94 = 0.01000000;
      local_98 = 0.01000000;
      iVar10 = pHVar9->max_val;
      iVar1 = pHVar9->min_val;
      value = (float)(pHVar9->default_val).real_value;
LAB_080f88c7:
      ghid_spin_button(box_00,local_20,(gfloat)value,(gfloat)(float)iVar1,(gfloat)(float)iVar10,
                       local_98,local_94,local_90,0,local_88,local_84,0,(gchar *)0x0);
      gtk_tooltips_set_tip(uVar2,local_20[0],pHVar9->help_text,0);
      descr = (char *)gtk_label_new(pHVar9->name);
      local_20[0] = (GtkWidget *)descr;
      uVar7 = g_type_check_instance_cast(box_00,local_5c);
      local_9c = 0;
      local_a0 = 0;
      local_a4 = (char *)0x0;
      gtk_box_pack_start(uVar7,descr);
      goto LAB_080f83f8;
    case HID_String:
      local_a0 = gtk_hbox_new(0,4);
      local_9c = gtk_box_get_type();
      uVar7 = g_type_check_instance_cast(box,local_9c);
      gtk_box_pack_start(uVar7,local_a0,0,0,0);
      uVar7 = gtk_entry_new();
      uVar8 = g_type_check_instance_cast(local_a0,local_9c);
      gtk_box_pack_start(uVar8,uVar7,0,0,0);
      local_a4 = (pHVar9->default_val).str_value;
      uVar8 = gtk_entry_get_type();
      uVar8 = g_type_check_instance_cast(uVar7,uVar8);
      gtk_entry_set_text(uVar8,local_a4);
      gtk_tooltips_set_tip(uVar2,uVar7,pHVar9->help_text,0);
      uVar7 = g_type_check_instance_cast(uVar7,0x50);
      local_98 = 0.00000000;
      g_signal_connect_data(uVar7,0x8155a12,entry_changed_cb,&(pHVar9->default_val).str_value,0);
      descr = (char *)gtk_label_new(pHVar9->name);
      goto LAB_080f863b;
    case HID_Boolean:
      local_98 = 0.00000000;
      local_9c = 0;
      ghid_check_button_connected
                (box,local_20,(pHVar9->default_val).int_value,1,0,0,0,set_flag_cb,
                 &pHVar9->default_val,pHVar9->name);
      break;
    case HID_Enum:
      local_a0 = gtk_hbox_new(0,4);
      local_9c = gtk_box_get_type();
      uVar7 = g_type_check_instance_cast(box,local_9c);
      gtk_box_pack_start(uVar7,local_a0,0,0,0);
      local_20[0] = (GtkWidget *)gtk_event_box_new();
      gtk_tooltips_set_tip(uVar2,local_20[0],pHVar9->help_text,0);
      box_00 = local_20[0];
      uVar7 = g_type_check_instance_cast(local_a0,local_9c);
      gtk_box_pack_start(uVar7,box_00,0,0,0);
      uVar7 = gtk_combo_box_new_text();
      uVar8 = g_type_check_instance_cast(local_20[0],uVar3);
      gtk_container_add(uVar8,uVar7);
      uVar8 = g_type_check_instance_cast(uVar7,0x50);
      local_98 = 0.00000000;
      g_signal_connect_data(uVar8,0x8155a12,enum_changed_cb,&pHVar9->default_val,0);
      local_a4 = *pHVar9->enumerations;
      if (local_a4 == (char *)0x0) {
        local_38 = gtk_combo_box_get_type();
      }
      else {
        local_38 = gtk_combo_box_get_type();
        iVar10 = 4;
        do {
          uVar8 = g_type_check_instance_cast(uVar7,local_38);
          gtk_combo_box_append_text(uVar8,local_a4);
          local_a4 = *(char **)((int)pHVar9->enumerations + iVar10);
          iVar10 = iVar10 + 4;
        } while (local_a4 != (char *)0x0);
      }
      iVar10 = (pHVar9->default_val).int_value;
      uVar7 = g_type_check_instance_cast(uVar7,local_38);
      gtk_combo_box_set_active(uVar7,iVar10);
      descr = (char *)gtk_label_new(pHVar9->name);
LAB_080f863b:
      local_20[0] = (GtkWidget *)descr;
      uVar7 = g_type_check_instance_cast(local_a0,local_9c);
      local_9c = 0;
      local_a0 = 0;
      local_a4 = (char *)0x0;
      gtk_box_pack_start(uVar7,descr);
      goto LAB_080f83f8;
    case HID_Mixed:
      goto switchD_080f8412_caseD_6;
    case HID_Path:
      box_00 = ghid_category_vbox(box,pHVar9->name,4,2,1,1);
      descr = (char *)gtk_entry_new();
      local_a0 = gtk_box_get_type();
      local_a0 = g_type_check_instance_cast(box_00,local_a0);
      gtk_box_pack_start(local_a0,descr,0,0,0);
      local_a4 = (pHVar9->default_val).str_value;
      local_a0 = gtk_entry_get_type();
      local_a0 = g_type_check_instance_cast(descr,local_a0);
      gtk_entry_set_text(local_a0,local_a4);
      local_a0 = g_type_check_instance_cast(descr,0x50);
      local_98 = 0.00000000;
      local_9c = 0;
      g_signal_connect_data(local_a0,0x8155a12,entry_changed_cb,&(pHVar9->default_val).str_value);
      local_a0 = 0;
      local_a4 = pHVar9->help_text;
      gtk_tooltips_set_tip(uVar2,descr,local_a4);
      goto LAB_080f83f8;
    }
    local_a0 = 0;
    local_a4 = pHVar9->help_text;
    descr = (char *)local_20[0];
    gtk_tooltips_set_tip(uVar2);
LAB_080f83f8:
    iVar6 = iVar6 + 1;
    pHVar9 = pHVar9 + 1;
  } while (iVar6 < n_attrs);
  goto LAB_080f8440;
switchD_080f8412_caseD_6:
  descr = "HID_Mixed\n";
  iVar6 = iVar6 + 1;
  pHVar9 = pHVar9 + 1;
  __printf_chk(1,"HID_Mixed\n",local_a4,local_a0,local_9c,local_98);
  if (n_attrs <= iVar6) goto LAB_080f8440;
  goto LAB_080f8403;
}



void ghid_dialog_print(HID *exporter)

{
  char *descr;
  GtkWidget *pGVar1;
  char "ghid_dialog_print" [18];
  undefined4 uVar2;
  HID_Attribute *attrs;
  char *title;
  int iVar3;
  HID_Attr_Val *results;
  HID_Attr_Val *pHVar4;
  int local_20 [4];
  
  pGVar1 = export_dialog;
  local_20[0] = 0;
  if (export_dialog != (GtkWidget *)0x0) {
    uVar2 = gtk_dialog_get_type();
    uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
    gtk_dialog_response(uVar2,0xfffffffa);
  }
  results = (HID_Attr_Val *)0x0;
  attrs = (*exporter->get_export_options)(local_20);
  if (0 < local_20[0]) {
    results = (HID_Attr_Val *)calloc(1,local_20[0] << 4);
    if (results == (HID_Attr_Val *)0x0) {
      __fprintf_chk(stderr,1,"%s() -- malloc failed\n","ghid_dialog_print");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    descr = exporter->description;
    title = (char *)dcgettext(&DAT_0815492c,"PCB Print Layout",5);
    iVar3 = ghid_attribute_dialog(attrs,local_20[0],results,title,descr);
    if (iVar3 != 0) {
      return;
    }
  }
  (*exporter->do_export)(results);
  if (0 < local_20[0]) {
    iVar3 = 0;
    pHVar4 = results;
    do {
      if (pHVar4->str_value != (char *)0x0) {
        free(pHVar4->str_value);
      }
      iVar3 = iVar3 + 1;
      pHVar4 = pHVar4 + 1;
    } while (iVar3 < local_20[0]);
  }
  if (results != (HID_Attr_Val *)0x0) {
    free(results);
  }
  return;
}



void exporter_clicked_cb(GtkButton *button,HID *exporter)

{
  ghid_dialog_print(exporter);
  return;
}



void enum_changed_cb(GtkWidget *combo_box,int *val)

{
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = gtk_combo_box_get_type();
  uVar1 = g_type_check_instance_cast(combo_box,uVar1);
  iVar2 = gtk_combo_box_get_active(uVar1);
  *val = iVar2;
  return;
}



void set_flag_cb(GtkToggleButton *button,gboolean *flag)

{
  gboolean gVar1;
  
  gVar1 = gtk_toggle_button_get_active(button);
  *flag = gVar1;
  return;
}



void entry_changed_cb(GtkEntry *entry,char **str)

{
  undefined4 uVar1;
  char *pcVar2;
  
  uVar1 = gtk_entry_get_text(entry);
  if (*str != (char *)0x0) {
    free(*str);
  }
  pcVar2 = (char *)__strdup(uVar1);
  *str = pcVar2;
  return;
}



void dblspinner_changed_cb(GtkWidget *spin_button,gpointer data)

{
  undefined4 uVar1;
  float10 fVar2;
  
  uVar1 = gtk_spin_button_get_type();
  uVar1 = g_type_check_instance_cast(spin_button,uVar1);
  fVar2 = (float10)gtk_spin_button_get_value(uVar1);
  *(double *)data = (double)fVar2;
  return;
}



void intspinner_changed_cb(GtkWidget *spin_button,gpointer data)

{
  undefined4 uVar1;
  float10 fVar2;
  
  uVar1 = gtk_spin_button_get_type();
  uVar1 = g_type_check_instance_cast(spin_button,uVar1);
  fVar2 = (float10)gtk_spin_button_get_value(uVar1);
  *(int *)data = (int)ROUND(fVar2);
  return;
}



gchar * ghid_fileselect(char *title,char *descr,char *default_file,char *default_ext,
                       char *history_tag,int flags)

{
  uint uVar1;
  char "ghid_fileselect" [16];
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  ghid_file_history *__ptr;
  uint local_54;
  undefined *puVar6;
  int iVar7;
  int iVar8;
  char *__s1;
  int iVar9;
  char **ppcVar10;
  char *__s2;
  char *local_5c;
  char *local_58;
  gchar *local_38;
  char *local_34;
  int local_2c;
  int local_20;
  
  __ptr = recent_dirs;
  iVar9 = n_recent_dirs;
  if ((history_tag == (char *)0x0) || (*history_tag == '\0')) {
    puVar6 = &DAT_ffffffdc;
  }
  else {
    if (n_recent_dirs < 1) {
      iVar8 = 0;
    }
    else {
      puVar6 = (undefined *)0x0;
      iVar8 = 0;
      do {
        iVar2 = strcmp(*(char **)((int)&__ptr->id + (int)puVar6),history_tag);
        if (iVar2 == 0) goto LAB_080f8e55;
        iVar8 = iVar8 + 1;
        puVar6 = puVar6 + 0x24;
      } while (iVar8 < iVar9);
    }
    n_recent_dirs = iVar9 + 1;
    __ptr = (ghid_file_history *)realloc(__ptr,n_recent_dirs * 0x24);
    recent_dirs = __ptr;
    if (__ptr == (ghid_file_history *)0x0) {
      __fprintf_chk(stderr,1,"%s():  realloc failed\n","ghid_fileselect");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    puVar6 = (undefined *)(iVar8 * 0x24);
    __s2 = (char *)__strdup(history_tag);
    __ptr[iVar8].id = __s2;
    __ptr = recent_dirs;
    iVar9 = 0;
    do {
      __ptr[iVar8].history[iVar9] = (char *)0x0;
      iVar9 = iVar9 + 1;
    } while (iVar9 != 8);
  }
LAB_080f8e55:
  if ((default_file == (char *)0x0) || (*default_file == '\0')) {
    __s1 = (char *)0x0;
    __s2 = (char *)0x0;
  }
  else {
    __s2 = (char *)g_path_get_dirname(default_file);
    __s1 = (char *)g_path_get_basename(default_file);
  }
  uVar1 = flags & 0xffU ^ 1;
  uVar3 = gtk_window_get_type();
  uVar3 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  local_54 = uVar1 & 1;
  uVar3 = gtk_file_chooser_dialog_new
                    (title,uVar3,local_54,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar4 = gtk_dialog_get_type();
  local_5c = (char *)g_type_check_instance_cast(uVar3,uVar4);
  local_58 = (char *)0xfffffffb;
  gtk_dialog_set_default_response(local_5c,0xfffffffb);
  if ((__s2 != (char *)0x0) && (*__s2 != '\0')) {
    uVar5 = gtk_file_chooser_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    local_58 = __s2;
    gtk_file_chooser_set_current_folder(uVar5,__s2);
    g_free(__s2);
    local_5c = __s2;
  }
  if ((__s1 != (char *)0x0) && (*__s1 != '\0')) {
    if ((uVar1 & 1) != 0) {
      uVar5 = gtk_file_chooser_get_type();
      uVar5 = g_type_check_instance_cast(uVar3,uVar5);
      local_58 = __s1;
      gtk_file_chooser_set_current_name(uVar5,__s1);
    }
    g_free(__s1);
    local_5c = __s1;
  }
  iVar9 = 0;
  do {
    __s2 = *(char **)((int)recent_dirs->history + (int)((int)puVar6 + iVar9 * 4));
    if (__s2 == (char *)0x0) break;
    uVar5 = gtk_file_chooser_get_type(local_5c,local_58,local_54);
    iVar9 = iVar9 + 1;
    local_5c = (char *)g_type_check_instance_cast(uVar3,uVar5);
    local_54 = 0;
    gtk_file_chooser_add_shortcut_folder();
    local_58 = __s2;
  } while (iVar9 != 8);
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  iVar9 = gtk_dialog_run(uVar5);
  local_38 = (gchar *)0x0;
  if (iVar9 == -5) {
    uVar4 = gtk_file_chooser_get_type(uVar5,uVar4,local_54);
    uVar4 = g_type_check_instance_cast(uVar3,uVar4);
    local_38 = (gchar *)gtk_file_chooser_get_filename(uVar4);
    if ((local_38 != (gchar *)0x0) &&
       (__s2 = (char *)g_path_get_dirname(local_38), __s2 != (char *)0x0)) {
      iVar9 = (int)&recent_dirs->id + (int)puVar6;
      iVar8 = 0;
      do {
        local_34 = *(char **)(iVar9 + 4 + iVar8 * 4);
        if ((local_34 == (char *)0x0) || (iVar2 = strcmp(local_34,__s2), iVar2 != 0))
        goto LAB_080f90e4;
        iVar8 = iVar8 + 1;
      } while (iVar8 != 8);
      local_34 = *(char **)(iVar9 + 0x24);
LAB_080f90e4:
      local_2c = 1;
      *(char **)(iVar9 + 4) = __s2;
      do {
        local_20 = local_2c + iVar8;
        if (local_20 < 8) {
          __s1 = *(char **)(iVar9 + 4 + local_20 * 4);
          if (__s1 != (char *)0x0) {
            ppcVar10 = (char **)(iVar9 + 4 + (local_20 + 1) * 4);
            iVar2 = local_20 + 1;
            do {
              iVar7 = iVar2;
              iVar2 = strcmp(__s1,__s2);
              if (iVar2 != 0) break;
              iVar8 = iVar8 + 1;
              if (7 < iVar7) goto LAB_080f9190;
              __s1 = *ppcVar10;
              ppcVar10 = ppcVar10 + 1;
              iVar2 = iVar7 + 1;
              local_20 = iVar7;
            } while (__s1 != (char *)0x0);
            __s1 = *(char **)(iVar9 + 4 + local_20 * 4);
          }
        }
        else {
LAB_080f9190:
          __s1 = (char *)0x0;
        }
        *(char **)(iVar9 + 4 + local_2c * 4) = local_34;
        local_2c = local_2c + 1;
        local_34 = __s1;
      } while (local_2c != 8);
      if (__s1 != (char *)0x0) {
        free(__s1);
      }
    }
  }
  gtk_widget_destroy(uVar3);
  return local_38;
}



gchar * ghid_dialog_file_select_save(gchar *title,gchar **path,gchar *file,gchar *shortcuts)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  char *local_4c;
  char *pcVar5;
  gchar *src;
  gchar *pgVar6;
  undefined *local_48;
  undefined4 local_44;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  local_44 = 1;
  uVar1 = gtk_file_chooser_dialog_new(title,uVar1,1,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar2 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_set_default_response(uVar3,0xfffffffb);
  if (((path != (gchar **)0x0) && (local_4c = *path, local_4c != (char *)0x0)) &&
     (*local_4c != '\0')) {
    uVar3 = gtk_file_chooser_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_set_current_folder(uVar3,local_4c);
  }
  if ((file != (gchar *)0x0) && (*file != '\0')) {
    uVar3 = gtk_file_chooser_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_set_current_name(uVar3,file);
  }
  if ((shortcuts != (gchar *)0x0) && (*shortcuts != '\0')) {
    local_4c = (char *)g_strdup(shortcuts);
    while( true ) {
      local_48 = &DAT_0814d79c;
      pcVar5 = strtok(local_4c,":");
      if (pcVar5 == (char *)0x0) break;
      uVar3 = gtk_file_chooser_get_type(local_4c,local_48,local_44);
      uVar3 = g_type_check_instance_cast(uVar1,uVar3);
      local_44 = 0;
      gtk_file_chooser_add_shortcut_folder(uVar3,pcVar5);
      local_4c = (char *)0x0;
    }
    g_free(0);
  }
  pgVar6 = (gchar *)0x0;
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  iVar4 = gtk_dialog_run(uVar2);
  if (iVar4 == -5) {
    uVar2 = gtk_file_chooser_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar2);
    pgVar6 = (gchar *)gtk_file_chooser_get_filename(uVar3);
    uVar2 = g_type_check_instance_cast(uVar1,uVar2);
    src = (gchar *)gtk_file_chooser_get_current_folder(uVar2);
    if ((src != (gchar *)0x0) && (path != (gchar **)0x0)) {
      dup_string(path,src);
      g_free(src);
    }
  }
  gtk_widget_destroy(uVar1);
  return pgVar6;
}



gchar * ghid_dialog_file_select_open(gchar *title,gchar **path,gchar *shortcuts)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 local_44;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  undefined4 uVar6;
  char *__s2;
  gchar *src;
  gchar *pgVar7;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_file_chooser_dialog_new(title,uVar1,0,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar2 = gtk_dialog_get_type();
  local_44 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_set_default_response(local_44,0xfffffffb);
  local_44 = gtk_file_filter_new();
  gtk_file_filter_set_name(local_44,0x814802e);
  gtk_file_filter_add_pattern(local_44,&DAT_081548e7);
  gtk_file_filter_add_pattern(local_44,&DAT_081548e9);
  uVar3 = gtk_file_chooser_get_type();
  uVar4 = g_type_check_instance_cast(uVar1,uVar3);
  gtk_file_chooser_add_filter(uVar4,local_44);
  __s2 = (char *)dcgettext(&DAT_0815492c,"Load element to buffer",5);
  iVar5 = strcmp(title,__s2);
  if (iVar5 == 0) {
    local_44 = gtk_file_filter_new();
    gtk_file_filter_set_name(local_44,&DAT_08154909);
    gtk_file_filter_add_mime_type(local_44,"application/x-pcb-footprint");
    gtk_file_filter_add_pattern(local_44,&DAT_08154907);
    gtk_file_filter_add_pattern(local_44,&DAT_0815490c);
    uVar4 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_add_filter(uVar4,local_44);
  }
  __s2 = (char *)dcgettext(&DAT_0815492c,"Load layout file",5);
  iVar5 = strcmp(title,__s2);
  if (iVar5 != 0) {
    __s2 = (char *)dcgettext(&DAT_0815492c,"Load layout file to buffer",5);
    iVar5 = strcmp(title,__s2);
    if (iVar5 != 0) goto LAB_080f9584;
  }
  local_44 = gtk_file_filter_new();
  gtk_file_filter_set_name(local_44,&DAT_0815492c);
  gtk_file_filter_add_mime_type(local_44,"application/x-pcb-layout");
  gtk_file_filter_add_pattern(local_44,&DAT_0815492a);
  gtk_file_filter_add_pattern(local_44,&DAT_08154930);
  uVar4 = g_type_check_instance_cast(uVar1,uVar3);
  gtk_file_chooser_add_filter(uVar4,local_44);
LAB_080f9584:
  local_44 = 5;
  __s2 = (char *)dcgettext(&DAT_0815492c,"Load netlist file",5);
  iVar5 = strcmp(title,__s2);
  if (iVar5 == 0) {
    uVar4 = gtk_file_filter_new();
    gtk_file_filter_set_name(uVar4,0x8154948);
    gtk_file_filter_add_mime_type(uVar4,"application/x-pcb-netlist");
    gtk_file_filter_add_pattern(uVar4,&DAT_08154950);
    gtk_file_filter_add_pattern(uVar4,"*.NET");
    uVar6 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_add_filter(uVar6,uVar4);
  }
  if ((path != (gchar **)0x0) && (pgVar7 = *path, pgVar7 != (gchar *)0x0)) {
    uVar4 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_file_chooser_set_current_folder(uVar4,pgVar7);
  }
  if ((shortcuts != (gchar *)0x0) && (*shortcuts != '\0')) {
    __s2 = (char *)g_strdup(shortcuts);
    while( true ) {
      __s2 = strtok(__s2,":");
      if (__s2 == (char *)0x0) break;
      uVar4 = g_type_check_instance_cast(uVar1,uVar3,local_44);
      local_44 = 0;
      gtk_file_chooser_add_shortcut_folder(uVar4,__s2);
      __s2 = (char *)0x0;
    }
    g_free(0);
  }
  pgVar7 = (gchar *)0x0;
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  iVar5 = gtk_dialog_run(uVar2);
  if (iVar5 == -5) {
    uVar2 = g_type_check_instance_cast(uVar1,uVar3);
    pgVar7 = (gchar *)gtk_file_chooser_get_filename(uVar2);
    uVar2 = g_type_check_instance_cast(uVar1,uVar3);
    src = (gchar *)gtk_file_chooser_get_current_folder(uVar2);
    if ((src != (gchar *)0x0) && (path != (gchar **)0x0)) {
      dup_string(path,src);
      g_free(src);
    }
  }
  gtk_widget_destroy(uVar1);
  return pgVar7;
}



void ghid_dialog_message(gchar *message)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_message_dialog_new(uVar1,3,1,1,message);
  uVar2 = gtk_dialog_get_type();
  uVar1 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_run(uVar1);
  gtk_widget_destroy();
  return;
}



int ghid_dialog_close_confirm(void)

{
  char *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  
  pcVar1 = PCB->Filename;
  if (pcVar1 == (char *)0x0) {
    uVar2 = dcgettext(&DAT_0815492c,"Save the changes to layout before closing?",5);
    uVar2 = g_strdup_printf(uVar2);
  }
  else {
    uVar2 = dcgettext(&DAT_0815492c,"Save the changes to layout \"%s\" before closing?",5);
    uVar2 = g_strdup_printf(uVar2,pcVar1);
  }
  uVar3 = g_strconcat(&DAT_08154967,uVar2,"</b></big>",0);
  g_free(uVar2);
  uVar2 = dcgettext(&DAT_0815492c,"If you don\'t save, all your changes will be permanently lost.",5
                   );
  uVar2 = g_strconcat(uVar3,0x8151452,uVar2,0);
  uVar3 = gtk_window_get_type();
  uVar3 = g_type_check_instance_cast(ghid_port.top_window,uVar3);
  uVar3 = gtk_message_dialog_new(uVar3,3,1,0,0);
  uVar4 = gtk_message_dialog_get_type();
  uVar4 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_message_dialog_set_markup(uVar4,uVar2);
  uVar2 = dcgettext(&DAT_0815492c,"Close without saving",5);
  uVar4 = gtk_dialog_get_type();
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_dialog_add_buttons(uVar5,uVar2,0xfffffff7,"gtk-cancel",0xfffffffa,"gtk-save",0xfffffff8,0);
  uVar2 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_dialog_set_alternative_button_order(uVar2,0xfffffff8,0xfffffff7,0xfffffffa,0xffffffff);
  iVar7 = 0;
  uVar2 = g_type_check_instance_cast(uVar3,uVar4);
  iVar6 = gtk_dialog_run(uVar2);
  if (iVar6 + 9U < 2) {
    iVar7 = *(int *)((int)&CSWTCH_117 + (iVar6 + 9U) * 4);
  }
  gtk_widget_destroy(uVar3);
  return iVar7;
}



gboolean ghid_dialog_confirm(gchar *message,gchar *cancelmsg,gchar *okmsg)

{
  gint y;
  gint x;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  
  if (cancelmsg == (gchar *)0x0) {
    cancelmsg = (gchar *)dcgettext(&DAT_0815492c,"_Cancel",5);
  }
  if (okmsg == (gchar *)0x0) {
    okmsg = (gchar *)dcgettext(&DAT_0815492c,&DAT_08152330,5);
  }
  uVar1 = gtk_window_get_type();
  uVar2 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar2 = gtk_message_dialog_new(uVar2,3,2,0,message);
  uVar3 = gtk_dialog_get_type();
  uVar4 = g_type_check_instance_cast(uVar2,uVar3);
  gtk_dialog_add_buttons(uVar4,cancelmsg,0xfffffffa,okmsg,0xfffffffb,0);
  if (x != -1) {
    uVar4 = g_type_check_instance_cast(uVar2,uVar1);
    gtk_window_move(uVar4,x,y);
  }
  uVar3 = g_type_check_instance_cast(uVar2,uVar3);
  iVar5 = gtk_dialog_run(uVar3);
  uVar1 = g_type_check_instance_cast(uVar2,uVar1);
  gtk_window_get_position(uVar1,0x8168ca0,0x8168c9c);
  gtk_widget_destroy(uVar2);
  return (uint)(iVar5 == -5);
}



gint ghid_dialog_confirm_all(gchar *all_message)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  GtkWidget *pGVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  gint gVar7;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_dialog_new_with_buttons
                    ("Confirm",uVar1,3,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,"Sequence OK",1,0
                    );
  uVar2 = gtk_dialog_get_type();
  iVar3 = g_type_check_instance_cast(uVar1,uVar2);
  pGVar4 = ghid_framed_vbox(*(GtkWidget **)(iVar3 + 0x94),(gchar *)0x0,6,0,4,6);
  uVar5 = gtk_label_new(all_message);
  uVar6 = gtk_box_get_type();
  uVar6 = g_type_check_instance_cast(pGVar4,uVar6);
  gtk_box_pack_start(uVar6,uVar5,0,0,3);
  gtk_widget_show_all(uVar1);
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  gVar7 = gtk_dialog_run(uVar2);
  gtk_widget_destroy(uVar1);
  return gVar7;
}



void ghid_dialog_about(void)

{
  char *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
  pcVar1 = GetInfoString();
  uVar2 = gtk_window_get_type();
  uVar2 = g_type_check_instance_cast(ghid_port.top_window,uVar2);
  uVar2 = gtk_message_dialog_new(uVar2,3,0,1,pcVar1);
  uVar3 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar2,uVar3);
  gtk_dialog_run(uVar3);
  gtk_widget_destroy(uVar2);
  return;
}



gchar * ghid_dialog_input(gchar *prompt,gchar *initial)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  char *pcVar9;
  int iVar10;
  gchar *pgVar11;
  
  uVar1 = gtk_window_get_type();
  uVar1 = g_type_check_instance_cast(ghid_port.top_window,uVar1);
  uVar1 = gtk_dialog_new_with_buttons
                    ("PCB User Input",uVar1,1,"gtk-cancel",0xfffffffa,"gtk-ok",0xfffffffb,0);
  uVar2 = gtk_dialog_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_dialog_set_default_response(uVar3,0xfffffffb);
  uVar3 = gtk_vbox_new(0,4);
  uVar4 = gtk_container_get_type();
  uVar5 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_container_set_border_width(uVar5,4);
  uVar5 = gtk_label_new(&DAT_0814741b);
  uVar6 = gtk_box_get_type();
  uVar7 = g_type_check_instance_cast(uVar3,uVar6);
  gtk_box_pack_start(uVar7,uVar5,1,1,0);
  uVar7 = gtk_label_get_type();
  uVar8 = g_type_check_instance_cast(uVar5,uVar7);
  gtk_label_set_use_markup(uVar8,1);
  pcVar9 = "Enter something";
  if (prompt != (gchar *)0x0) {
    pcVar9 = prompt;
  }
  uVar5 = g_type_check_instance_cast(uVar5,uVar7);
  gtk_label_set_markup(uVar5,pcVar9);
  uVar5 = gtk_entry_new();
  if (initial == (gchar *)0x0) {
    uVar7 = gtk_entry_get_type();
  }
  else {
    uVar7 = gtk_entry_get_type();
    uVar8 = g_type_check_instance_cast(uVar5,uVar7);
    gtk_entry_set_text(uVar8,initial);
  }
  uVar7 = g_type_check_instance_cast(uVar5,uVar7);
  gtk_entry_set_activates_default(uVar7,1);
  uVar6 = g_type_check_instance_cast(uVar3,uVar6);
  gtk_box_pack_start_defaults(uVar6,uVar5);
  iVar10 = g_type_check_instance_cast(uVar1,uVar2);
  uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar10 + 0x94),uVar4);
  gtk_container_add(uVar4,uVar3);
  gtk_widget_show_all(uVar1);
  uVar2 = g_type_check_instance_cast(uVar1,uVar2);
  iVar10 = gtk_dialog_run(uVar2);
  if (iVar10 == -5) {
    uVar2 = gtk_editable_get_type();
    uVar2 = g_type_check_instance_cast(uVar5,uVar2);
    pgVar11 = (gchar *)gtk_editable_get_chars(uVar2,0,0xffffffff);
  }
  else {
    if (initial == (gchar *)0x0) {
      initial = "";
    }
    pgVar11 = (gchar *)g_strdup(initial);
  }
  gtk_widget_destroy(uVar1);
  return pgVar11;
}



gint drc_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  ghidgui->drc_window_width = (widget->allocation).width;
  gVar1 = (widget->allocation).height;
  pGVar2->config_modified = 1;
  pGVar2->drc_window_height = gVar1;
  return 0;
}



void drc_destroy_cb(GtkWidget *widget,gpointer data)

{
  drc_window = (GtkWidget *)0x0;
  return;
}



void ghid_drc_window_reset_message(void)

{
  if (drc_list_model != (GtkListStore *)0x0) {
    gtk_list_store_clear(drc_list_model);
  }
  num_violations = 0;
  return;
}



void drc_close_cb(gpointer data)

{
  gtk_widget_destroy(drc_window);
  drc_window = (GtkWidget *)0x0;
  return;
}



void drc_refresh_cb(gpointer data)

{
  hid_actionl("DRC",0);
  return;
}



void row_activated_cb(GtkTreeView *view,GtkTreePath *path,GtkTreeViewColumn *column,
                     gpointer user_data)

{
  undefined4 uVar1;
  GtkTreeIter iter;
  int local_10;
  
  uVar1 = gtk_tree_view_get_model(view);
  gtk_tree_model_get_iter(uVar1,&iter,path);
  gtk_tree_model_get(uVar1,&iter,1,&local_10,0xffffffff);
  if (local_10 != 0) {
    CenterDisplay(*(LocationType *)(local_10 + 0x14),*(LocationType *)(local_10 + 0x18),'\0');
  }
  return;
}



void __regparm3 unset_found_flags(int AndDraw)

{
  uint *puVar1;
  bool bVar2;
  uint uVar3;
  PCBTypePtr pPVar4;
  DataTypePtr *pDVar5;
  LayerTypePtr Layer;
  uint uVar6;
  PadTypePtr *Pad;
  LineTypePtr Line;
  ArcTypePtr *Arc;
  PolygonTypePtr Polygon;
  PinTypePtr *Via;
  uint uVar7;
  int iVar8;
  void *Ptr1;
  RatTypePtr *Line_00;
  int iVar9;
  undefined *puVar10;
  int local_24;
  uint local_20;
  
  bVar2 = false;
  uVar6 = 0;
  pDVar5 = PCB->Data;
  pPVar4 = PCB;
  uVar3 = pDVar5->ViaN;
  if (pDVar5->ViaN != 0) {
    do {
      Via = pDVar5->Via + uVar6;
      if ((*(byte *)&(Via->Flags).f & 4) == 0) {
        pDVar5 = pPVar4->Data;
        uVar7 = pDVar5->ViaN;
      }
      else {
        AddObjectToFlagUndoList(1,Via,Via,Via);
        (Via->Flags).f = (Via->Flags).f & 0xfffffffb;
        DrawVia(Via,0);
        bVar2 = true;
        pDVar5 = PCB->Data;
        uVar7 = pDVar5->ViaN;
        pPVar4 = PCB;
      }
    } while ((uVar7 != 0) && (uVar6 = (uVar7 + 1 + uVar6) - uVar3, uVar3 = uVar7, uVar6 < uVar7));
  }
  local_20 = pDVar5->ElementN - 1;
  if (local_20 != -1) {
    iVar8 = pDVar5->ElementN * 300;
    while( true ) {
      local_24 = iVar8 + -300;
      Ptr1 = (void *)((int)&pDVar5->Element[-1].BoundingBox.X1 + iVar8);
      if (*(uint *)((int)Ptr1 + 0xe0) != 0) {
        uVar6 = 0;
        uVar3 = *(uint *)((int)Ptr1 + 0xe0);
        do {
          Via = (PinTypePtr *)(uVar6 * 0x4c + *(int *)((int)Ptr1 + 0x100));
          uVar7 = uVar3;
          if ((*(byte *)&(Via->Flags).f & 4) != 0) {
            AddObjectToFlagUndoList(0x100,Ptr1,Via,Via);
            (Via->Flags).f = (Via->Flags).f & 0xfffffffb;
            DrawPin(Via,0);
            bVar2 = true;
            uVar7 = *(uint *)((int)Ptr1 + 0xe0);
          }
        } while ((uVar7 != 0) && (uVar6 = (uVar6 + 1 + uVar7) - uVar3, uVar3 = uVar7, uVar6 < uVar7)
                );
      }
      uVar3 = *(uint *)((int)Ptr1 + 0xe8);
      uVar7 = 0;
      uVar6 = uVar3;
      while ((uVar6 != 0 && (uVar7 < uVar6))) {
        Pad = (PadTypePtr *)(uVar7 * 0x68 + *(int *)((int)Ptr1 + 0x104));
        if ((*(byte *)&(Pad->Flags).f & 4) != 0) {
          AddObjectToFlagUndoList(0x200,Ptr1,Pad,Pad);
          (Pad->Flags).f = (Pad->Flags).f & 0xfffffffb;
          DrawPad(Pad,0);
          uVar6 = *(uint *)((int)Ptr1 + 0xe8);
          bVar2 = true;
        }
        uVar7 = uVar7 + (uVar3 == uVar6);
      }
      local_20 = local_20 + -1;
      if (local_20 == -1) break;
      pDVar5 = PCB->Data;
      iVar8 = local_24;
    }
    pDVar5 = PCB->Data;
    pPVar4 = PCB;
  }
  iVar8 = pDVar5->RatN - 1;
  if (iVar8 != -1) {
    iVar9 = pDVar5->RatN * 0x5c;
    while( true ) {
      Line_00 = (RatTypePtr *)((int)&pDVar5->Rat[-1].BoundingBox.X1 + iVar9);
      if ((*(byte *)&(Line_00->Flags).f & 4) != 0) {
        AddObjectToFlagUndoList(0x20,Line_00,Line_00,Line_00);
        (Line_00->Flags).f = (Line_00->Flags).f & 0xfffffffb;
        DrawRat(Line_00,0);
        bVar2 = true;
        pPVar4 = PCB;
      }
      if (iVar8 == 0) break;
      iVar8 = iVar8 + -1;
      pDVar5 = pPVar4->Data;
      iVar9 = iVar9 + -0x5c;
    }
    pDVar5 = pPVar4->Data;
  }
  Layer = (LayerTypePtr)&pDVar5->field_0x4c;
  if (pDVar5->LayerN != 0) {
    local_20 = 0;
    do {
      iVar8 = Layer->LineN - 1;
      if (iVar8 != -1) {
        iVar9 = Layer->LineN * 0x58 + -0x58;
        do {
          while (Line = (LineTypePtr)((int)&(Layer->Line->BoundingBox).X1 + iVar9),
                (*(byte *)&(Line->Flags).f & 4) != 0) {
            iVar8 = iVar8 + -1;
            iVar9 = iVar9 + -0x58;
            AddObjectToFlagUndoList(4,Layer,Line,Line);
            (Line->Flags).f = (Line->Flags).f & 0xfffffffb;
            DrawLine(Layer,Line,0);
            bVar2 = true;
            pPVar4 = PCB;
            if (iVar8 == -1) goto LAB_080fa4ac;
          }
          iVar8 = iVar8 + -1;
          iVar9 = iVar9 + -0x58;
          pPVar4 = PCB;
        } while (iVar8 != -1);
      }
LAB_080fa4ac:
      local_20 = local_20 + 1;
      uVar3 = pPVar4->Data->LayerN;
      if (uVar3 <= local_20) goto LAB_080fa4d6;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_080fa4c6;
LAB_080fa4d6:
  Layer = (LayerTypePtr)&pPVar4->Data->field_0x4c;
  if (uVar3 != 0) {
    local_20 = 0;
    do {
      iVar8 = Layer->ArcN - 1;
      if (iVar8 != -1) {
        iVar9 = Layer->ArcN * 0x44 + -0x44;
        do {
          while (Arc = (ArcTypePtr *)((int)&(Layer->Arc->BoundingBox).X1 + iVar9),
                (*(byte *)&(Arc->Flags).f & 4) != 0) {
            iVar8 = iVar8 + -1;
            iVar9 = iVar9 + -0x44;
            AddObjectToFlagUndoList(0x4000,Layer,Arc,Arc);
            (Arc->Flags).f = (Arc->Flags).f & 0xfffffffb;
            DrawArc(Layer,Arc,0);
            bVar2 = true;
            pPVar4 = PCB;
            if (iVar8 == -1) goto LAB_080fa564;
          }
          iVar8 = iVar8 + -1;
          iVar9 = iVar9 + -0x44;
          pPVar4 = PCB;
        } while (iVar8 != -1);
      }
LAB_080fa564:
      local_20 = local_20 + 1;
      uVar3 = pPVar4->Data->LayerN;
      if (uVar3 <= local_20) goto LAB_080fa57e;
      Layer = Layer + 1;
    } while( true );
  }
  goto LAB_080fa4c6;
LAB_080fa57e:
  Layer = (LayerTypePtr)&pPVar4->Data->field_0x4c;
  if (uVar3 != 0) {
    local_20 = 0;
    do {
      iVar8 = Layer->PolygonN - 1;
      if (iVar8 != -1) {
        puVar10 = &DAT_ffffffc4 + Layer->PolygonN * 0x3c;
        do {
          while (Polygon = (PolygonTypePtr)(puVar10 + (int)&(Layer->Polygon->BoundingBox).X1),
                (*(byte *)&(Polygon->Flags).f & 4) != 0) {
            iVar8 = iVar8 + -1;
            puVar10 = &DAT_ffffffc4 + (int)puVar10;
            AddObjectToFlagUndoList(8,Layer,Polygon,Polygon);
            (Polygon->Flags).f = (Polygon->Flags).f & 0xfffffffb;
            DrawPolygon(Layer,Polygon,0);
            bVar2 = true;
            pPVar4 = PCB;
            if (iVar8 == -1) goto LAB_080fa614;
          }
          iVar8 = iVar8 + -1;
          puVar10 = &DAT_ffffffc4 + (int)puVar10;
          pPVar4 = PCB;
        } while (iVar8 != -1);
      }
LAB_080fa614:
      local_20 = local_20 + 1;
      puVar1 = (uint *)&pPVar4->Data->LayerN;
      if (*puVar1 < local_20 || *puVar1 == local_20) break;
      Layer = Layer + 1;
    } while( true );
  }
LAB_080fa4c6:
  if ((bVar2) && (SetChangedFlag('\x01'), AndDraw != 0)) {
    IncrementUndoSerialNumber();
    Draw();
    return;
  }
  return;
}



void selection_changed_cb(GtkTreeSelection *selection,gpointer user_data)

{
  int type;
  int iVar1;
  char *Format;
  int iVar2;
  int ID;
  GtkTreeIter iter;
  void *local_30;
  void *local_2c;
  LayerTypePtr local_28;
  int local_24;
  undefined4 local_20 [4];
  
  iVar1 = gtk_tree_selection_get_selected(selection,local_20,&iter);
  if (iVar1 == 0) {
    unset_found_flags(1);
    return;
  }
  iVar1 = gtk_tree_model_iter_has_child(local_20[0],&iter);
  if (iVar1 == 0) {
    gtk_tree_model_get(local_20[0],&iter,1,&local_24,0xffffffff);
    unset_found_flags(0);
    if (local_24 != 0) {
      if (0 < *(int *)(local_24 + 0x3c)) {
        iVar1 = 0;
        do {
          while( true ) {
            ID = *(int *)(*(int *)(local_24 + 0x40) + iVar1 * 4);
            type = *(int *)(*(int *)(local_24 + 0x44) + iVar1 * 4);
            iVar2 = SearchObjectByID(PCB->Data,&local_28,&local_2c,&local_30,ID,type);
            if (iVar2 == 0) break;
            AddObjectToFlagUndoList(type,local_28,local_2c,local_30);
            ID = *(int *)(local_24 + 0x44);
            *(uint *)((int)local_2c + 0x14) = *(uint *)((int)local_2c + 0x14) | 4;
            ID = *(int *)(ID + iVar1 * 4);
            if (((ID == 8) || (ID == 0x4000)) || (ID == 4)) {
              ID = GetLayerNumber(PCB->Data,local_28);
              ChangeGroupVisibility(ID,'\x01','\x01');
            }
            iVar1 = iVar1 + 1;
            DrawObject(type,local_28,local_2c,0);
            if (*(int *)(local_24 + 0x3c) == iVar1 || *(int *)(local_24 + 0x3c) < iVar1)
            goto LAB_080fa7d0;
          }
          iVar1 = iVar1 + 1;
          Format = (char *)dcgettext(&DAT_0815492c,
                                                                          
                                     "Object ID %i identified during DRC was not found. Stale DRC window?\n"
                                     ,5);
          Message(Format,ID);
        } while (*(int *)(local_24 + 0x3c) != iVar1 && iVar1 <= *(int *)(local_24 + 0x3c));
      }
LAB_080fa7d0:
      SetChangedFlag('\x01');
      IncrementUndoSerialNumber();
      Draw();
      return;
    }
  }
  return;
}



GType ghid_violation_renderer_get_type(void)

{
  GType ghid_violation_renderer_type;
  undefined4 uVar1;
  GType GVar2;
  GTypeInfo ghid_violation_renderer_info;
  
  if (ghid_violation_renderer_type != 0) {
    return ghid_violation_renderer_type;
  }
  uVar1 = gtk_cell_renderer_text_get_type();
  GVar2 = g_type_register_static(uVar1,"GhidViolationRenderer",&ghid_violation_renderer_info,0);
  return GVar2;
}



GtkCellRenderer * ghid_violation_renderer_new(void)

{
  GType GVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkCellRenderer *pGVar4;
  
  GVar1 = ghid_violation_renderer_get_type();
  uVar2 = g_object_new(GVar1,&DAT_08154a82,6,0);
  uVar3 = gtk_cell_renderer_get_type();
  pGVar4 = (GtkCellRenderer *)g_type_check_instance_cast(uVar2,uVar3);
  return pGVar4;
}



void ghid_drc_window_show(gboolean raise)

{
  gint gVar1;
  gint gVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 local_48;
  undefined4 local_44;
  GtkWidget *pGVar6;
  undefined4 local_40;
  GtkCellRenderer *pGVar7;
  code *pcVar8;
  undefined4 local_38;
  
  pGVar6 = drc_window;
  if (drc_window == (GtkWidget *)0x0) {
    drc_window = (GtkWidget *)gtk_window_new(0);
    uVar3 = g_type_check_instance_cast(drc_window,0x50);
    g_signal_connect_data(uVar3,0x815f66a,drc_destroy_cb,0,0,0);
    uVar3 = g_type_check_instance_cast(drc_window,0x50);
    g_signal_connect_data(uVar3,"configure_event",drc_window_configure_event_cb,0,0,0);
    uVar3 = dcgettext(&DAT_0815492c,&DAT_08154a97,5);
    uVar4 = gtk_window_get_type();
    uVar5 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_window_set_title(uVar5,uVar3);
    uVar3 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_window_set_wmclass(uVar3,"PCB_DRC",&DAT_08154932);
    gVar1 = ghidgui->drc_window_height;
    gVar2 = ghidgui->drc_window_width;
    uVar3 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_window_set_default_size(uVar3,gVar2,gVar1);
    uVar3 = gtk_vbox_new(0,0);
    uVar4 = gtk_container_get_type();
    uVar5 = g_type_check_instance_cast(drc_window,uVar4);
    gtk_container_add(uVar5,uVar3);
    uVar5 = g_type_check_instance_cast(uVar3,uVar4);
    gtk_container_set_border_width(uVar5,6);
    uVar5 = gtk_box_get_type();
    local_48 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_box_set_spacing(local_48,6);
    drc_list_model = (GtkListStore *)gtk_list_store_new(2,0x18,0x50);
    local_48 = gtk_scrolled_window_new(0,0);
    local_44 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_box_pack_start(local_44,local_48,1,1,0);
    local_44 = gtk_scrolled_window_get_type();
    local_44 = g_type_check_instance_cast(local_48,local_44);
    gtk_scrolled_window_set_policy(local_44,1,1);
    local_44 = gtk_tree_model_get_type();
    local_44 = g_type_check_instance_cast(drc_list_model,local_44);
    pGVar6 = (GtkWidget *)gtk_tree_view_new_with_model(local_44);
    drc_list = pGVar6;
    uVar4 = g_type_check_instance_cast(local_48,uVar4);
    gtk_container_add(uVar4,pGVar6);
    uVar4 = gtk_tree_view_get_type();
    local_48 = g_type_check_instance_cast(drc_list,uVar4);
    gtk_tree_view_set_rules_hint(local_48,1);
    local_48 = g_type_check_instance_cast(drc_list,uVar4);
    local_48 = gtk_tree_view_get_selection(local_48);
    g_signal_connect_data(local_48,0x8155a12,selection_changed_cb,0,0,0);
    g_signal_connect_data(drc_list,"row-activated",row_activated_cb,0,0,0);
    local_48 = gtk_cell_renderer_text_new();
    local_44 = dcgettext(&DAT_0815492c,&DAT_08154ab5,5);
    local_40 = g_type_check_instance_cast(drc_list,uVar4);
    gtk_tree_view_insert_column_with_attributes
              (local_40,0xffffffff,local_44,local_48,&DAT_081539ac,0,0);
    pGVar7 = ghid_violation_renderer_new();
    local_48 = dcgettext(&DAT_0815492c,"Violation details",5);
    uVar4 = g_type_check_instance_cast(drc_list,uVar4);
    gtk_tree_view_insert_column_with_attributes(uVar4,0xffffffff,local_48,pGVar7,"violation",1,0);
    uVar4 = gtk_hbutton_box_new();
    local_48 = gtk_button_box_get_type();
    local_48 = g_type_check_instance_cast(uVar4,local_48);
    gtk_button_box_set_layout(local_48,4);
    uVar3 = g_type_check_instance_cast(uVar3,uVar5);
    local_38 = 0;
    local_40 = 0;
    local_44 = 0;
    gtk_box_pack_start(uVar3,uVar4);
    uVar3 = g_type_check_instance_cast(uVar4,uVar5,local_44,local_40,local_38);
    local_48 = 6;
    gtk_box_set_spacing(uVar3);
    uVar3 = gtk_button_new_from_stock("gtk-refresh",local_48);
    local_48 = g_type_check_instance_cast(uVar3,0x50,local_44,local_40,local_38);
    local_38 = 0;
    local_40 = 0;
    local_44 = 0;
    pcVar8 = drc_refresh_cb;
    g_signal_connect_data(local_48,"clicked");
    local_48 = g_type_check_instance_cast(uVar4,uVar5,pcVar8,local_44,local_40);
    gtk_box_pack_start(local_48,uVar3,1,1,0,local_38);
    uVar3 = gtk_button_new_from_stock("gtk-close");
    local_48 = g_type_check_instance_cast(uVar3,0x50);
    g_signal_connect_data(local_48,"clicked",drc_close_cb,0,0,0);
    uVar4 = g_type_check_instance_cast(uVar4,uVar5);
    gtk_box_pack_start(uVar4,uVar3,1,1,0);
    gtk_widget_realize(drc_window);
    if (Settings.AutoPlace != '\0') {
      uVar3 = gtk_widget_get_type();
      uVar3 = g_type_check_instance_cast(drc_window,uVar3);
      gtk_widget_set_uposition(uVar3,10,10);
    }
    gtk_widget_show_all();
    return;
  }
  if (raise == 0) {
    return;
  }
  uVar3 = gtk_window_get_type();
  g_type_check_instance_cast(pGVar6,uVar3);
  gtk_window_present();
  return;
}



int ghid_drc_window_throw_dialog(void)

{
  ghid_drc_window_show(1);
  return 1;
}



GType ghid_drc_violation_get_type(void)

{
  GType ghid_drc_violation_type;
  GType GVar1;
  GTypeInfo ghid_drc_violation_info;
  
  if (ghid_drc_violation_type != 0) {
    return ghid_drc_violation_type;
  }
  GVar1 = g_type_register_static(0x50,"GhidDrcViolation",&ghid_drc_violation_info,0);
  return GVar1;
}



GhidDrcViolation * ghid_drc_violation_new(DrcViolationType *violation,GdkDrawable *pixmap)

{
  double dVar1;
  double dVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  char *pcVar9;
  char *pcVar10;
  GType GVar11;
  GhidDrcViolation *pGVar12;
  object_list obj_list;
  
  obj_list.count = violation->object_count;
  dVar1 = violation->required_value;
  dVar2 = violation->measured_value;
  obj_list.id_list = violation->object_id_list;
  iVar3 = violation->y;
  iVar4 = violation->value_digits;
  iVar5 = violation->have_measured;
  obj_list.type_list = violation->object_type_list;
  iVar6 = violation->x;
  iVar7 = violation->angle;
  pcVar8 = violation->value_units;
  pcVar9 = violation->explanation;
  pcVar10 = violation->title;
  GVar11 = ghid_drc_violation_get_type();
  pGVar12 = (GhidDrcViolation *)
            g_object_new(GVar11,"title",pcVar10,"explanation",pcVar9,"x-coord",iVar6,"y-coord",iVar3
                         ,0x813a500,iVar7,"have-measured",iVar5,"measured-value",dVar2,
                         "required-value",dVar1,"value-digits",iVar4,"value-units",pcVar8,
                         "object-list",&obj_list,"pixmap",pixmap,0);
  return pGVar12;
}



void ghid_drc_window_append_violation(DrcViolationType *violation)

{
  GhidDrcViolation *pGVar1;
  GtkTreeIter iter;
  
  ghid_drc_window_show(0);
  num_violations = num_violations + 1;
  pGVar1 = ghid_drc_violation_new(violation,(GdkDrawable *)0x0);
  gtk_list_store_append(drc_list_model,&iter);
  gtk_list_store_set(drc_list_model,&iter,0,num_violations,1,pGVar1,0xffffffff);
  g_object_unref(pGVar1);
  return;
}



void ghid_violation_renderer_get_size
               (GtkCellRenderer *cell,GtkWidget *widget,GdkRectangle *cell_area,gint *x_offset,
               gint *y_offset,gint *width,gint *height)

{
  undefined4 uVar1;
  int iVar2;
  gint gVar3;
  
  uVar1 = gtk_cell_renderer_get_type();
  iVar2 = g_type_check_class_cast(ghid_violation_renderer_parent_class,uVar1);
  (**(code **)(iVar2 + 0x50))(cell,widget,cell_area,x_offset,y_offset,width,height);
  if (width != (gint *)0x0) {
    *width = *width + 100;
  }
  if (height != (gint *)0x0) {
    gVar3 = 100;
    if (99 < *height) {
      gVar3 = *height;
    }
    *height = gVar3;
  }
  return;
}



void ghid_violation_renderer_finalize(GObject *object)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_violation_renderer_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  if (*(int *)(iVar2 + 0x58) != 0) {
    g_object_unref(*(int *)(iVar2 + 0x58));
  }
  iVar2 = g_type_check_class_cast(ghid_violation_renderer_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x080fb1fa. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



void ghid_violation_renderer_class_init(GhidViolationRendererClass *klass)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  GType GVar4;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  uVar2 = gtk_cell_renderer_get_type();
  iVar3 = g_type_check_class_cast(klass,uVar2);
  *(undefined4 *)(iVar1 + 0x18) = 0x80fb1b0;
  *(undefined4 *)(iVar1 + 0xc) = 0x80fb540;
  *(undefined4 *)(iVar1 + 0x10) = 0x80fb440;
  *(undefined4 *)(iVar3 + 0x50) = 0x80fb140;
  *(undefined4 *)(iVar3 + 0x54) = 0x80fb2b0;
  ghid_violation_renderer_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  GVar4 = ghid_drc_violation_get_type();
  uVar2 = g_param_spec_object("violation",&DAT_0814741b,&DAT_0814741b,GVar4,2);
  g_object_class_install_property(iVar1,1,uVar2);
  return;
}



void ghid_violation_renderer_render
               (GtkCellRenderer *cell,GdkDrawable *window,GtkWidget *widget,
               GdkRectangle *background_area,GdkRectangle *cell_area,GdkRectangle *expose_area,
               GtkCellRendererState flags)

{
  int iVar1;
  GtkStyle *pGVar2;
  GType GVar3;
  int iVar4;
  undefined4 uVar5;
  int depth;
  undefined4 uVar6;
  int iVar7;
  GdkPixmap *pGVar8;
  
  GVar3 = ghid_violation_renderer_get_type();
  iVar4 = g_type_check_instance_cast(cell,GVar3);
  cell_area->width = cell_area->width + -100;
  iVar4 = *(int *)(iVar4 + 0x58);
  uVar5 = gtk_cell_renderer_get_type();
  depth = g_type_check_class_cast(ghid_violation_renderer_parent_class,uVar5);
  (**(code **)(depth + 0x54))(cell,window,widget,background_area,cell_area,expose_area,flags);
  if (iVar4 != 0) {
    depth = *(int *)(iVar4 + 0x48);
    if (depth == 0) {
      depth = gdk_drawable_get_depth(window);
      pGVar8 = ghid_render_pixmap(*(int *)(iVar4 + 0x14),*(int *)(iVar4 + 0x18),111.00000000,0x5a,
                                  0x5a,depth);
      g_object_set(iVar4,"pixmap",pGVar8,0);
      g_object_unref(pGVar8);
      depth = *(int *)(iVar4 + 0x48);
      if (depth == 0) {
        return;
      }
    }
    uVar5 = gdk_drawable_get_type();
    uVar5 = g_type_check_instance_cast(depth,uVar5);
    iVar4 = cell_area->y;
    depth = cell_area->x;
    iVar1 = cell_area->width;
    pGVar2 = widget->style;
    uVar6 = gtk_widget_get_type();
    iVar7 = g_type_check_instance_cast(widget,uVar6);
    gdk_draw_drawable(window,pGVar2->fg_gc[*(byte *)(iVar7 + 0x12)],uVar5,0,0,depth + iVar1 + 5,
                      iVar4 + 5,0xffffffff,0xffffffff);
  }
  return;
}



void ghid_violation_renderer_get_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = g_type_name(((object->g_type_instance).g_class)->g_type);
  uVar2 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
  g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
        "../../src/hid/gtk/gui-drc-window.c:712","property",property_id,pspec->name,uVar2,uVar1);
  return;
}



void ghid_drc_violation_get_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = g_type_name(((object->g_type_instance).g_class)->g_type);
  uVar2 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
  g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
        "../../src/hid/gtk/gui-drc-window.c:416","property",property_id,pspec->name,uVar2,uVar1);
  return;
}



void ghid_violation_renderer_set_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  GType GVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  
  GVar1 = ghid_violation_renderer_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  if (property_id == 1) {
    if (*(int *)(iVar2 + 0x58) != 0) {
      g_object_unref(*(int *)(iVar2 + 0x58));
    }
    iVar5 = g_value_dup_object(value);
    *(int *)(iVar2 + 0x58) = iVar5;
    if (iVar5 != 0) {
      if (*(int *)(iVar5 + 0x20) == 0) {
        uVar3 = g_strdup_printf(
                                "<b>%s</b>\n<span size=\'1024\'> </span>\n<small><i>%s</i>\n<span size=\'5120\'> </span>\nRequired: %.*f %s</small>"
                                ,*(undefined4 *)(iVar5 + 0xc),*(undefined4 *)(iVar5 + 0x10),
                                *(undefined4 *)(iVar5 + 0x34),(int)*(undefined8 *)(iVar5 + 0x2c),
                                (int)((ulonglong)*(undefined8 *)(iVar5 + 0x2c) >> 0x20),
                                *(undefined4 *)(iVar5 + 0x38));
      }
      else {
        uVar3 = g_strdup_printf(
                                "<b>%s (%.*f %s)</b>\n<span size=\'1024\'> </span>\n<small><i>%s</i>\n<span size=\'5120\'> </span>\nRequired: %.*f %s</small>"
                                ,*(undefined4 *)(iVar5 + 0xc),*(undefined4 *)(iVar5 + 0x34),
                                (int)*(undefined8 *)(iVar5 + 0x24),
                                (int)((ulonglong)*(undefined8 *)(iVar5 + 0x24) >> 0x20),
                                *(undefined4 *)(iVar5 + 0x38),*(undefined4 *)(iVar5 + 0x10),
                                *(undefined4 *)(iVar5 + 0x34),*(undefined8 *)(iVar5 + 0x2c),
                                *(undefined4 *)(iVar5 + 0x38));
      }
      g_object_set(object,"markup",uVar3,0);
      g_free();
      return;
    }
  }
  else {
    uVar3 = g_type_name(((object->g_type_instance).g_class)->g_type);
    uVar4 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
    g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
          "../../src/hid/gtk/gui-drc-window.c:648","property",property_id,pspec->name,uVar4,uVar3);
  }
  return;
}



void ghid_drc_violation_finalize(GObject *object)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_drc_violation_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  g_free(*(undefined4 *)(iVar2 + 0xc));
  g_free(*(undefined4 *)(iVar2 + 0x10));
  g_free(*(undefined4 *)(iVar2 + 0x38));
  g_free(*(undefined4 *)(iVar2 + 0x40));
  g_free(*(undefined4 *)(iVar2 + 0x44));
  if (*(int *)(iVar2 + 0x48) != 0) {
    g_object_unref(*(int *)(iVar2 + 0x48));
  }
  iVar2 = g_type_check_class_cast(ghid_drc_violation_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x080fb735. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



void ghid_drc_violation_class_init(GhidViolationRendererClass *klass)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  *(undefined4 *)(iVar1 + 0x18) = 0x80fb6b0;
  *(undefined4 *)(iVar1 + 0xc) = 0x80fbb00;
  *(undefined4 *)(iVar1 + 0x10) = 0x80fb4c0;
  ghid_drc_violation_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  uVar2 = g_param_spec_string("title",&DAT_0814741b,&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,1,uVar2);
  uVar2 = g_param_spec_string("explanation",&DAT_0814741b,&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,2,uVar2);
  uVar2 = g_param_spec_int("x-coord",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,3,uVar2);
  uVar2 = g_param_spec_int("y-coord",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,4,uVar2);
  uVar2 = g_param_spec_int(0x813a500,&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,5,uVar2);
  uVar2 = g_param_spec_int("have-measured",&DAT_0814741b,&DAT_0814741b,0x80000000,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,6,uVar2);
  uVar2 = g_param_spec_double("measured-value",&DAT_0814741b,&DAT_0814741b,0xffefffffffffffff,
                              0x7fefffffffffffff,0,2);
  g_object_class_install_property(iVar1,7,uVar2);
  uVar2 = g_param_spec_double("required-value",&DAT_0814741b,&DAT_0814741b,0x8010000000000000,
                              0x7fefffffffffffff,0,2);
  g_object_class_install_property(iVar1,8,uVar2);
  uVar2 = g_param_spec_int("value-digits",&DAT_0814741b,&DAT_0814741b,0,0x7fffffff,0,2);
  g_object_class_install_property(iVar1,9,uVar2);
  uVar3 = 2;
  uVar2 = g_param_spec_string("value-units",&DAT_0814741b,&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,10,uVar2);
  uVar2 = g_param_spec_pointer("object-list",&DAT_0814741b,&DAT_0814741b,2,uVar3);
  g_object_class_install_property(iVar1,0xb,uVar2);
  uVar2 = gdk_drawable_get_type();
  uVar2 = g_param_spec_object("pixmap",&DAT_0814741b,&DAT_0814741b,uVar2,2);
  g_object_class_install_property(iVar1,0xc,uVar2);
  return;
}



void ghid_drc_violation_set_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  int iVar1;
  void *__src;
  GType GVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int *piVar6;
  float10 fVar7;
  
  GVar2 = ghid_drc_violation_get_type();
  iVar3 = g_type_check_instance_cast(object,GVar2);
  switch(property_id) {
  default:
    uVar4 = g_type_name(((object->g_type_instance).g_class)->g_type);
    uVar5 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
    g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
          "../../src/hid/gtk/gui-drc-window.c:391","property",property_id,pspec->name,uVar5,uVar4);
    break;
  case 1:
    g_free(*(undefined4 *)(iVar3 + 0xc));
    uVar4 = g_value_dup_string(value);
    *(undefined4 *)(iVar3 + 0xc) = uVar4;
    break;
  case 2:
    g_free(*(undefined4 *)(iVar3 + 0x10));
    uVar4 = g_value_dup_string(value);
    *(undefined4 *)(iVar3 + 0x10) = uVar4;
    break;
  case 3:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x14) = uVar4;
    break;
  case 4:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x18) = uVar4;
    break;
  case 5:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x1c) = uVar4;
    break;
  case 6:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x20) = uVar4;
    break;
  case 7:
    fVar7 = (float10)g_value_get_double(value);
    *(double *)(iVar3 + 0x24) = (double)fVar7;
    break;
  case 8:
    fVar7 = (float10)g_value_get_double(value);
    *(double *)(iVar3 + 0x2c) = (double)fVar7;
    break;
  case 9:
    uVar4 = g_value_get_int(value);
    *(undefined4 *)(iVar3 + 0x34) = uVar4;
    break;
  case 10:
    g_free(*(undefined4 *)(iVar3 + 0x38));
    uVar4 = g_value_dup_string(value);
    *(undefined4 *)(iVar3 + 0x38) = uVar4;
    break;
  case 0xb:
    g_free(*(undefined4 *)(iVar3 + 0x40));
    g_free(*(undefined4 *)(iVar3 + 0x44));
    piVar6 = (int *)g_value_get_pointer(value);
    *(int *)(iVar3 + 0x3c) = *piVar6;
    uVar4 = g_malloc_n(*piVar6,4);
    *(undefined4 *)(iVar3 + 0x40) = uVar4;
    uVar4 = g_malloc_n(*piVar6,4);
    iVar1 = *piVar6;
    __src = (void *)piVar6[1];
    *(undefined4 *)(iVar3 + 0x44) = uVar4;
    memcpy(*(void **)(iVar3 + 0x40),__src,iVar1 << 2);
    memcpy(*(void **)(iVar3 + 0x44),(void *)piVar6[2],*piVar6 << 2);
    return;
  case 0xc:
    if (*(int *)(iVar3 + 0x48) != 0) {
      g_object_unref(*(int *)(iVar3 + 0x48));
    }
    uVar4 = g_value_dup_object(value);
    *(undefined4 *)(iVar3 + 0x48) = uVar4;
  }
  return;
}



gint library_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  ghidgui->library_window_width = (widget->allocation).width;
  gVar1 = (widget->allocation).height;
  pGVar2->config_modified = 1;
  pGVar2->library_window_height = gVar1;
  return 0;
}



GType ghid_library_window_get_type(void)

{
  GType library_window_type;
  undefined4 uVar1;
  GType GVar2;
  GTypeInfo library_window_info;
  
  if (library_window_type != 0) {
    return library_window_type;
  }
  uVar1 = gtk_dialog_get_type();
  GVar2 = g_type_register_static(uVar1,"GhidLibraryWindow",&library_window_info,0);
  return GVar2;
}



void library_window_class_init(GhidLibraryWindowClass *klass)

{
  int iVar1;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  *(undefined4 *)(iVar1 + 8) = 0x80fbea0;
  *(undefined4 *)(iVar1 + 0x18) = 0x80fbe30;
  library_window_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  return;
}



void library_window_finalize(GObject *object)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(object,GVar1);
  if (*(int *)(iVar2 + 0xb8) != 0) {
    g_source_remove(*(int *)(iVar2 + 0xb8));
    *(undefined4 *)(iVar2 + 0xb8) = 0;
  }
  iVar2 = g_type_check_class_cast(library_window_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x080fbe92. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



GObject * library_window_constructor
                    (GType type,guint n_construct_properties,GObjectConstructParam *construct_params
                    )

{
  Cardinal CVar1;
  int iVar2;
  GObject *pGVar3;
  GType GVar4;
  undefined4 uVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 local_10c;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  uint uVar17;
  uint *puVar18;
  undefined *puVar19;
  GtkTreeIter *local_108;
  undefined8 local_104;
  longlong lVar20;
  undefined8 uVar21;
  undefined4 local_fc;
  uint *local_f8;
  char *pcVar22;
  undefined4 local_f4;
  uint *local_f0;
  undefined4 local_ec;
  int local_7c;
  int local_78;
  GtkTreeIter c_iter;
  GtkTreeIter e_iter;
  GtkTreeIter p_iter;
  GtkTreeIter iter;
  char *local_20 [4];
  
  uVar5 = (undefined4)((ulonglong)local_104 >> 0x20);
  iVar2 = g_type_check_class_cast(library_window_parent_class,0x50);
  pGVar3 = (GObject *)(**(code **)(iVar2 + 8))(type,n_construct_properties,construct_params);
  GVar4 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(pGVar3,GVar4);
  uVar5 = dcgettext(&DAT_0815492c,"Select Footprint...",5,uVar5);
  local_ec = 400;
  g_object_set(pGVar3,0x815eae1,0,"title",uVar5,"default-height",300,"default-width",400,"modal",0,
               "window-position",0,"has-separator",1,0);
  uVar5 = gtk_dialog_get_type();
  iVar6 = g_type_check_instance_cast(iVar2,uVar5);
  g_object_set(*(undefined4 *)(iVar6 + 0x94),"homogeneous",0,0);
  uVar7 = gtk_widget_get_type();
  uVar8 = gtk_hpaned_get_type();
  uVar8 = g_object_new(uVar8,"border-width",5,0);
  uVar8 = g_type_check_instance_cast(uVar8,uVar7);
  *(undefined4 *)(iVar2 + 0xa0) = uVar8;
  local_10c = gtk_notebook_get_type();
  uVar9 = g_object_new(local_10c,"show-tabs",0,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar7);
  uVar10 = g_type_check_instance_cast(uVar9,local_10c);
  *(undefined4 *)(iVar2 + 0xa8) = uVar10;
  uVar10 = gtk_vbox_get_type();
  local_f0 = (uint *)0x0;
  local_f4 = 5;
  local_f8 = (uint *)0x81537d4;
  local_fc = 0;
  uVar10 = g_object_new(uVar10,"border-width",5,"homogeneous",0,0x81537d4,5,0);
  uVar10 = g_type_check_instance_cast(uVar10,uVar7);
  lVar20 = 0x4400000044;
  local_108 = (GtkTreeIter *)&DAT_00000040;
  uVar11 = gtk_tree_store_new(3,0x40,0x44,0x44);
  CVar1 = Library.MenuN;
  uVar13 = (undefined4)((ulonglong)lVar20 >> 0x20);
  local_78 = Library.MenuN - 1;
  if (local_78 != -1) {
    uVar12 = gtk_tree_model_get_type();
    iVar6 = CVar1 * 0x1c;
    do {
      local_7c = iVar6 + -0x1c;
      puVar18 = (uint *)((int)&Library.Menu[-1].Name + iVar6);
      if (puVar18[1] == 0) {
        uVar17 = g_strdup(&DAT_0815d8d1,local_108,lVar20,local_fc,local_f8,local_f4,local_f0,
                          local_ec);
        puVar18[1] = uVar17;
      }
      uVar13 = g_type_check_instance_cast(uVar11,uVar12);
      iVar6 = gtk_tree_model_get_iter_first(uVar13,&e_iter);
      while (iVar6 != 0) {
        uVar13 = g_type_check_instance_cast(uVar11,uVar12);
        gtk_tree_model_get(uVar13,&e_iter,0,local_20,0xffffffff);
        iVar6 = strcmp(local_20[0],(char *)puVar18[1]);
        if (iVar6 == 0) goto LAB_080fc248;
        uVar13 = g_type_check_instance_cast(uVar11,uVar12);
        iVar6 = gtk_tree_model_iter_next(uVar13,&e_iter);
      }
      gtk_tree_store_append(uVar11,&p_iter);
      gtk_tree_store_set(uVar11,&p_iter,0,puVar18[1],1,0,2,0,0xffffffff);
LAB_080fc248:
      gtk_tree_store_append(uVar11,&iter);
      local_108 = &iter;
      local_ec = 0xffffffff;
      local_f0 = (uint *)0x0;
      local_f4 = 2;
      local_fc = 1;
      lVar20 = (ulonglong)*puVar18 << 0x20;
      local_f8 = puVar18;
      gtk_tree_store_set(uVar11);
      iVar6 = puVar18[3] - 1;
      if (iVar6 != -1) {
        puVar19 = (undefined *)(puVar18[3] * 0x18);
        do {
          puVar19 = &DAT_ffffffe8 + (int)puVar19;
          iVar6 = iVar6 + -1;
          local_f0 = (uint *)(puVar19 + puVar18[5]);
          gtk_tree_store_append(uVar11,&c_iter);
          local_ec = 0xffffffff;
          local_f4 = 2;
          local_fc = 1;
          lVar20 = (ulonglong)*local_f0 << 0x20;
          local_108 = &c_iter;
          local_f8 = puVar18;
          gtk_tree_store_set(uVar11);
        } while (iVar6 != -1);
      }
      uVar13 = (undefined4)((ulonglong)lVar20 >> 0x20);
      local_78 = local_78 + -1;
      iVar6 = local_7c;
    } while (local_78 != -1);
  }
  local_fc = gtk_tree_sortable_get_type();
  local_fc = g_type_check_instance_cast(uVar11,local_fc);
  gtk_tree_sortable_set_sort_column_id(local_fc,0,0,uVar13);
  uVar13 = gtk_tree_model_filter_get_type();
  uVar11 = g_object_new(uVar13,"child-model",uVar11,"virtual-root",0,0);
  uVar13 = gtk_scrolled_window_get_type();
  uVar13 = g_object_new(uVar13,"hscrollbar-policy",1,"vscrollbar-policy",0,"shadow-type",3,0);
  uVar13 = g_type_check_instance_cast(uVar13,uVar7);
  local_fc = gtk_tree_view_get_type();
  local_f4 = g_object_new(local_fc,0x8154ecd,uVar11,"rules-hint",1,"headers-visible",0,0);
  local_f4 = g_type_check_instance_cast(local_f4,uVar7);
  g_signal_connect_data(local_f4,"row-activated",tree_row_activated,0,0,0);
  local_ec = g_type_check_instance_cast(local_f4,local_fc);
  local_ec = gtk_tree_view_get_selection(local_ec);
  gtk_tree_selection_set_mode(local_ec,1);
  g_signal_connect_data(local_ec,0x8155a12,library_window_callback_tree_selection_changed,iVar2,0,0)
  ;
  local_ec = gtk_cell_renderer_get_type();
  uVar12 = gtk_cell_renderer_text_get_type();
  uVar14 = 0;
  uVar12 = g_object_new(uVar12,"editable",0,0);
  local_ec = g_type_check_instance_cast(uVar12,local_ec);
  uVar12 = dcgettext(&DAT_0815492c,"Components",5,uVar14);
  uVar14 = gtk_tree_view_column_get_type();
  uVar15 = 0;
  uVar12 = g_object_new(uVar14,"title",uVar12,0);
  uVar12 = g_type_check_instance_cast(uVar12,uVar14);
  gtk_tree_view_column_pack_start(uVar12,local_ec,1,uVar15);
  gtk_tree_view_column_set_attributes(uVar12,local_ec,&DAT_081539ac,0,0);
  local_ec = g_type_check_instance_cast(local_f4,local_fc);
  gtk_tree_view_append_column(local_ec,uVar12);
  local_ec = gtk_container_get_type();
  uVar12 = g_type_check_instance_cast(uVar13,local_ec);
  gtk_container_add(uVar12,local_f4);
  uVar12 = g_type_check_instance_cast(local_f4,local_fc);
  *(undefined4 *)(iVar2 + 0xa4) = uVar12;
  uVar12 = gtk_box_get_type();
  uVar14 = g_type_check_instance_cast(uVar10,uVar12);
  gtk_box_pack_start(uVar14,uVar13,1,1,0);
  uVar13 = gtk_hbox_get_type();
  uVar14 = 0x81537d4;
  uVar13 = g_object_new(uVar13,"homogeneous",0,0x81537d4,3,0);
  uVar13 = g_type_check_instance_cast(uVar13,uVar7);
  uVar14 = dcgettext(&DAT_0815492c,"Filter:",5,uVar14);
  uVar15 = gtk_label_get_type();
  uVar14 = g_object_new(uVar15,"xalign",0,"label",uVar14,0);
  uVar14 = g_type_check_instance_cast(uVar14,uVar7);
  uVar15 = g_type_check_instance_cast(uVar13,uVar12);
  gtk_box_pack_start(uVar15,uVar14,0,0,0);
  uVar14 = gtk_entry_get_type();
  uVar15 = g_object_new(uVar14,&DAT_081539ac);
  uVar15 = g_type_check_instance_cast(uVar15,uVar7);
  g_signal_connect_data(uVar15,0x8155a12,library_window_callback_filter_entry_changed,iVar2,0,0);
  gtk_tree_model_filter_set_visible_func(uVar11,lib_model_filter_visible_func);
  uVar11 = g_type_check_instance_cast(uVar13,uVar12);
  gtk_box_pack_start(uVar11,uVar15,1,1,0);
  uVar11 = g_type_check_instance_cast(uVar15,uVar14);
  *(undefined4 *)(iVar2 + 0xb8) = 0;
  *(undefined4 *)(iVar2 + 0xb0) = uVar11;
  uVar11 = gtk_button_get_type();
  uVar14 = g_object_new(uVar11,"sensitive",0,"relief",2,0);
  uVar14 = g_type_check_instance_cast(uVar14,uVar7);
  uVar15 = gtk_image_new_from_stock("gtk-clear",2);
  uVar16 = g_type_check_instance_cast(uVar14,local_ec);
  gtk_container_add(uVar16,uVar15);
  g_signal_connect_data(uVar14,"clicked",library_window_callback_filter_button_clicked,iVar2,0,0);
  uVar15 = g_type_check_instance_cast(uVar13,uVar12);
  gtk_box_pack_start(uVar15,uVar14,0,0,0);
  uVar11 = g_type_check_instance_cast(uVar14,uVar11);
  *(undefined4 *)(iVar2 + 0xb4) = uVar11;
  uVar11 = g_type_check_instance_cast(uVar10,uVar12);
  uVar15 = 0;
  uVar14 = 0;
  gtk_box_pack_start(uVar11,uVar13);
  uVar11 = g_type_check_instance_cast(local_f4,local_fc);
  *(undefined4 *)(iVar2 + 0xa4) = uVar11;
  uVar11 = dcgettext(&DAT_0815492c,"Libraries",5,uVar14,uVar15);
  uVar11 = gtk_label_new(uVar11);
  local_10c = g_type_check_instance_cast(uVar9,local_10c);
  uVar21 = CONCAT44(uVar14,uVar11);
  gtk_notebook_append_page();
  local_10c = gtk_paned_get_type(local_10c,uVar10,uVar21);
  uVar10 = g_type_check_instance_cast(uVar8,local_10c);
  uVar11 = 0;
  gtk_paned_pack1(uVar10,uVar9,1,0);
  uVar21 = CONCAT44(uVar11,5);
  uVar10 = 0x815555a;
  puVar19 = &DAT_0815492c;
  uVar9 = dcgettext();
  uVar10 = gtk_frame_get_type(puVar19,uVar10,uVar21);
  uVar9 = g_object_new(uVar10,"label",uVar9,0);
  uVar9 = g_type_check_instance_cast(uVar9,uVar7);
  uVar10 = gtk_alignment_get_type();
  uVar10 = g_object_new(uVar10,"left-padding",5,"right-padding",5,"top-padding",5,"bottom-padding",5
                        ,"xscale",0x3ff0000000000000,"yscale",0x3ff0000000000000,"xalign",
                        0x3fe0000000000000,"yalign",0x3fe0000000000000,0);
  uVar7 = g_type_check_instance_cast(uVar10,uVar7);
  GVar4 = ghid_pinout_preview_get_type();
  local_fc = 0;
  uVar13 = 0x96;
  pcVar22 = "height-request";
  uVar11 = 0x96;
  uVar21 = 0x8154fc600000000;
  uVar10 = g_object_new(GVar4,"element-data");
  uVar11 = g_type_check_instance_cast(uVar7,local_ec,uVar21,uVar11,pcVar22,uVar13,local_fc);
  gtk_container_add(uVar11,uVar10);
  uVar11 = g_type_check_instance_cast(uVar9,local_ec);
  gtk_container_add(uVar11,uVar7);
  *(undefined4 *)(iVar2 + 0xac) = uVar10;
  uVar7 = g_type_check_instance_cast(uVar8,local_10c);
  gtk_paned_pack2(uVar7,uVar9,0,0);
  iVar6 = g_type_check_instance_cast(iVar2,uVar5);
  uVar7 = g_type_check_instance_cast(*(undefined4 *)(iVar6 + 0x94),uVar12);
  gtk_box_pack_start(uVar7,uVar8,1,1,0);
  gtk_widget_show_all(uVar8);
  uVar5 = g_type_check_instance_cast(iVar2,uVar5);
  gtk_dialog_add_buttons(uVar5,"gtk-close",0xfffffff9,0);
  return pGVar3;
}



void library_window_callback_filter_button_clicked(GtkButton *button,gpointer user_data)

{
  GType GVar1;
  
  GVar1 = ghid_library_window_get_type();
  g_type_check_instance_cast(user_data,GVar1);
  gtk_entry_set_text();
  return;
}



gboolean lib_model_filter_visible_func(GtkTreeModel *model,GtkTreeIter *iter,gpointer data)

{
  char "lib_model_filter_visible_func" [30];
  GType GVar1;
  int iVar2;
  undefined4 uVar3;
  gboolean gVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  GtkTreeIter iter2;
  undefined4 local_20 [4];
  
  GVar1 = ghid_library_window_get_type();
  if ((data != (gpointer)0x0) &&
     (((*(GType **)data != (GType *)0x0 && (GVar1 == **(GType **)data)) ||
      (iVar2 = g_type_check_instance_is_a(data,GVar1), iVar2 != 0)))) {
    uVar3 = gtk_entry_get_text(*(undefined4 *)((int)data + 0xb0));
    iVar2 = g_ascii_strcasecmp(uVar3,&DAT_0814741b);
    if (iVar2 != 0) {
      iVar2 = gtk_tree_model_iter_has_child(model,iter);
      if (iVar2 == 0) {
        gtk_tree_model_get(model,iter,0,local_20,0xffffffff);
        uVar5 = g_ascii_strup(local_20[0],0xffffffff);
        uVar3 = g_ascii_strup(uVar3,0xffffffff);
        uVar6 = g_strconcat(&DAT_081548e9,uVar3,&DAT_081548e9,0);
        gVar4 = g_pattern_match_simple(uVar6,uVar5);
        g_free(uVar5);
        g_free(uVar3);
        g_free(uVar6);
        return gVar4;
      }
      gtk_tree_model_iter_children(model,&iter2,iter);
      while (gVar4 = lib_model_filter_visible_func(model,&iter2,data), gVar4 == 0) {
        iVar2 = gtk_tree_model_iter_next(model,&iter2);
        if (iVar2 == 0) {
          return 0;
        }
      }
    }
    return 1;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr
            (0,"../../src/hid/gtk/gui-library-window.c",0xe0,"lib_model_filter_visible_func",
             "GHID_IS_LIBRARY_WINDOW (data)");
}



void library_window_callback_filter_entry_changed(GtkEditable *editable,gpointer user_data)

{
  GType GVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  
  GVar1 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(user_data,GVar1);
  uVar3 = gtk_widget_get_type();
  uVar3 = g_type_check_instance_cast(*(undefined4 *)(iVar2 + 0xb4),uVar3);
  uVar4 = gtk_entry_get_text(*(undefined4 *)(iVar2 + 0xb0));
  iVar5 = g_ascii_strcasecmp(uVar4,&DAT_0814741b);
  uVar4 = gtk_object_get_type();
  iVar6 = g_type_check_instance_cast(uVar3,uVar4);
  if ((*(byte *)(iVar6 + 0xd) & 2) != 0) {
    iVar6 = g_type_check_instance_cast(uVar3,uVar4);
    uVar7 = 1;
    if ((*(byte *)(iVar6 + 0xd) & 4) != 0) goto LAB_080fcf2d;
  }
  uVar7 = 0;
LAB_080fcf2d:
  if (uVar7 != (uint)(iVar5 != 0)) {
    gtk_widget_set_sensitive(uVar3,(uint)(iVar5 != 0));
  }
  if (*(int *)(iVar2 + 0xb8) != 0) {
    g_source_remove(*(int *)(iVar2 + 0xb8));
  }
  uVar3 = g_timeout_add(200,library_window_filter_timeout,iVar2);
  *(undefined4 *)(iVar2 + 0xb8) = uVar3;
  return;
}



gboolean library_window_filter_timeout(gpointer data)

{
  GType GVar1;
  int iVar2;
  
  GVar1 = ghid_library_window_get_type();
  iVar2 = g_type_check_instance_cast(data,GVar1);
  *(undefined4 *)(iVar2 + 0xb8) = 0;
  iVar2 = gtk_tree_view_get_model(*(undefined4 *)(iVar2 + 0xa4));
  if (iVar2 != 0) {
    gtk_tree_model_filter_refilter(iVar2);
  }
  return 0;
}



void library_window_callback_tree_selection_changed(GtkTreeSelection *selection,gpointer user_data)

{
  Boolean BVar1;
  int iVar2;
  undefined1 *puVar3;
  char *Name;
  undefined1 *puVar4;
  undefined1 *puVar5;
  GtkTreeIter iter;
  int local_14;
  undefined4 local_10;
  
  local_14 = 0;
  iVar2 = gtk_tree_selection_get_selected(selection,&local_10,&iter);
  if (iVar2 != 0) {
    gtk_tree_selection_get_tree_view(selection);
    gtk_tree_model_get(local_10,&iter,2,&local_14,0xffffffff);
    if (local_14 != 0) {
      puVar3 = *(undefined1 **)(local_14 + 8);
      if (puVar3 == (undefined1 *)0xffffffff) {
        BVar1 = LoadElementToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),
                                    *(char **)(local_14 + 4),'\x01');
        if (BVar1 != '\0') {
          SetMode(5);
        }
      }
      else {
        puVar4 = *(undefined1 **)(local_14 + 0xc);
        puVar5 = *(undefined1 **)(local_14 + 0x10);
        if (puVar4 == (undefined1 *)0x0) {
          puVar4 = &DAT_0814741b;
        }
        if (puVar5 == (undefined1 *)0x0) {
          puVar5 = &DAT_0814741b;
        }
        if (puVar3 == (undefined1 *)0x0) {
          puVar3 = &DAT_0814741b;
        }
        Name = (char *)g_strdup_printf("\'%s\' \'%s\' \'%s\'",puVar3,puVar5,puVar4);
        BVar1 = LoadElementToBuffer((BufferTypePtr)(Buffers + Settings.BufferNumber),Name,'\0');
        if (BVar1 != '\0') {
          SetMode(5);
        }
        g_free(Name);
      }
      g_object_set(*(undefined4 *)((int)user_data + 0xac),"element-data",
                   (Buffers[Settings.BufferNumber].Data)->Element,0);
      return;
    }
  }
  return;
}



void tree_row_activated(GtkTreeView *tree_view,GtkTreePath *path,GtkTreeViewColumn *column,
                       gpointer user_data)

{
  undefined4 uVar1;
  int iVar2;
  GtkTreeIter iter;
  
  uVar1 = gtk_tree_view_get_model(tree_view);
  gtk_tree_model_get_iter(uVar1,&iter,path);
  iVar2 = gtk_tree_model_iter_has_child(uVar1,&iter);
  if (iVar2 != 0) {
    iVar2 = gtk_tree_view_row_expanded(tree_view,path);
    if (iVar2 == 0) {
      gtk_tree_view_expand_row(tree_view,path,0);
    }
    else {
      gtk_tree_view_collapse_row(tree_view,path);
    }
  }
  return;
}



void ghid_library_window_show(GHidPort *out,gboolean raise)

{
  gint gVar1;
  gint gVar2;
  GtkWidget *pGVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GType GVar6;
  int iVar7;
  undefined4 uVar8;
  
  pGVar3 = library_window;
  if (library_window == (GtkWidget *)0x0) {
    GVar6 = ghid_library_window_get_type();
    library_window = (GtkWidget *)g_object_new(GVar6,0);
    g_signal_connect_data(library_window,"response",library_window_callback_response,0,0,0);
    uVar4 = g_type_check_instance_cast(library_window,0x50);
    g_signal_connect_data(uVar4,"configure_event",library_window_configure_event_cb,0,0,0);
    gVar1 = ghidgui->library_window_width;
    gVar2 = ghidgui->library_window_height;
    uVar4 = gtk_window_get_type();
    uVar5 = g_type_check_instance_cast(library_window,uVar4);
    gtk_window_set_default_size(uVar5,gVar1,gVar2);
    uVar5 = dcgettext(&DAT_0815492c,"PCB Library",5);
    uVar8 = g_type_check_instance_cast(library_window,uVar4);
    gtk_window_set_title(uVar8,uVar5);
    uVar4 = g_type_check_instance_cast(library_window,uVar4);
    gtk_window_set_wmclass(uVar4,"PCB_Library",&DAT_08154932);
    gtk_widget_realize(library_window);
    if (Settings.AutoPlace == '\0') {
      uVar4 = gtk_widget_get_type();
    }
    else {
      uVar4 = gtk_widget_get_type();
      uVar5 = g_type_check_instance_cast(library_window,uVar4);
      gtk_widget_set_uposition(uVar5,10,10);
    }
    gtk_widget_show(library_window);
  }
  else {
    if (raise != 0) {
      uVar4 = gtk_window_get_type();
      uVar4 = g_type_check_instance_cast(pGVar3,uVar4);
      gtk_window_present(uVar4);
    }
    uVar4 = gtk_widget_get_type();
  }
  uVar5 = gtk_editable_get_type();
  GVar6 = ghid_library_window_get_type();
  iVar7 = g_type_check_instance_cast(library_window,GVar6);
  uVar5 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0xb0),uVar5);
  gtk_editable_select_region(uVar5,0,0xffffffff);
  uVar5 = gtk_notebook_get_type();
  GVar6 = ghid_library_window_get_type();
  iVar7 = g_type_check_instance_cast(library_window,GVar6);
  uVar5 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0xa8),uVar5);
  uVar8 = gtk_notebook_get_current_page(uVar5);
  uVar5 = gtk_notebook_get_nth_page(uVar5,uVar8);
  GVar6 = ghid_library_window_get_type();
  iVar7 = g_type_check_instance_cast(library_window,GVar6);
  uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar7 + 0xb0),uVar4);
  iVar7 = gtk_widget_is_ancestor(uVar4,uVar5);
  if (iVar7 == 0) {
    return;
  }
  gtk_widget_grab_focus();
  return;
}



void library_window_callback_response(GtkDialog *dialog,gint arg1,gpointer user_data)

{
  undefined4 uVar1;
  
  if ((arg1 != -7) && (arg1 != -4)) {
    return;
  }
  uVar1 = gtk_widget_get_type();
  uVar1 = g_type_check_instance_cast(library_window,uVar1);
  gtk_widget_destroy(uVar1);
  library_window = (GtkWidget *)0x0;
  return;
}



gint log_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  ghidgui->log_window_width = (widget->allocation).width;
  gVar1 = (widget->allocation).height;
  pGVar2->config_modified = 1;
  pGVar2->log_window_height = gVar1;
  return 0;
}



void log_destroy_cb(GtkWidget *widget,gpointer data)

{
  log_window = (GtkWidget *)0x0;
  return;
}



void ghid_log_window_show(gboolean raise)

{
  gint gVar1;
  gint gVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *box;
  undefined4 uVar6;
  
  box = log_window;
  if (log_window == (GtkWidget *)0x0) {
    log_window = (GtkWidget *)gtk_window_new(0);
    uVar3 = g_type_check_instance_cast(log_window,0x50);
    g_signal_connect_data(uVar3,0x815f66a,log_destroy_cb,0,0,0);
    uVar3 = g_type_check_instance_cast(log_window,0x50);
    g_signal_connect_data(uVar3,"configure_event",log_window_configure_event_cb,0,0,0);
    uVar3 = dcgettext(&DAT_0815492c,&DAT_081550a2,5);
    uVar4 = gtk_window_get_type();
    uVar5 = g_type_check_instance_cast(log_window,uVar4);
    gtk_window_set_title(uVar5,uVar3);
    uVar3 = g_type_check_instance_cast(log_window,uVar4);
    gtk_window_set_wmclass(uVar3,"PCB_Log",&DAT_08154932);
    gVar1 = ghidgui->log_window_height;
    gVar2 = ghidgui->log_window_width;
    uVar3 = g_type_check_instance_cast(log_window,uVar4);
    gtk_window_set_default_size(uVar3,gVar2,gVar1);
    box = (GtkWidget *)gtk_vbox_new(0,0);
    uVar3 = gtk_container_get_type();
    uVar4 = g_type_check_instance_cast(box,uVar3);
    gtk_container_set_border_width(uVar4,6);
    uVar3 = g_type_check_instance_cast(log_window,uVar3);
    gtk_container_add(uVar3,box);
    log_text = ghid_scrolled_text_view
                         (box,(GtkWidget **)0x0,GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
    uVar3 = gtk_hbutton_box_new();
    uVar4 = gtk_button_box_get_type();
    uVar4 = g_type_check_instance_cast(uVar3,uVar4);
    gtk_button_box_set_layout(uVar4,4);
    uVar4 = gtk_box_get_type();
    uVar5 = g_type_check_instance_cast(box,uVar4);
    gtk_box_pack_start(uVar5,uVar3,0,0,0);
    uVar5 = gtk_button_new_from_stock("gtk-close");
    uVar6 = g_type_check_instance_cast(uVar5,0x50);
    g_signal_connect_data(uVar6,"clicked",log_close_cb,0,0,0);
    uVar3 = g_type_check_instance_cast(uVar3,uVar4);
    gtk_box_pack_start(uVar3,uVar5,1,1,0);
    gtk_widget_realize(log_window);
    if (Settings.AutoPlace != '\0') {
      uVar3 = gtk_widget_get_type();
      uVar3 = g_type_check_instance_cast(log_window,uVar3);
      gtk_widget_set_uposition(uVar3,10,10);
    }
    gtk_widget_show_all();
    return;
  }
  if (raise == 0) {
    return;
  }
  uVar3 = gtk_window_get_type();
  g_type_check_instance_cast(box,uVar3);
  gtk_window_present();
  return;
}



void ghid_logv(char *fmt,va_list args)

{
  char *string;
  int iVar1;
  
  if (msg_buffer == (char *)0x0) {
    msg_buffer = (char *)calloc(1,0x3ea);
    if (msg_buffer == (char *)0x0) goto LAB_080fd9a1;
    msg_buffer_size = 1000;
  }
  iVar1 = __vsnprintf_chk(msg_buffer,msg_buffer_size,1,0xffffffff,fmt,args);
  if (msg_buffer_size <= iVar1) {
    msg_buffer_size = iVar1 + 100;
    msg_buffer = (char *)realloc(msg_buffer,iVar1 + 0x66);
    if (msg_buffer == (char *)0x0) {
LAB_080fd9a1:
      __fprintf_chk(stderr,1,"ghid_logv():  malloc failed\n\n");
                    // WARNING: Subroutine does not return
      exit(1);
    }
    __vsnprintf_chk(msg_buffer,msg_buffer_size,1,0xffffffff,fmt,args);
  }
  string = msg_buffer;
  ghid_log_window_show(0);
  ghid_text_view_append(log_text,string);
  return;
}



void ghid_log(char *fmt,...)

{
  ghid_logv(fmt,&stack0x00000008);
  return;
}



void log_close_cb(gpointer data)

{
  gtk_widget_destroy(log_window);
  log_window = (GtkWidget *)0x0;
  return;
}



void ghid_create_abort_dialog(char *msg)

{
  return;
}



gboolean ghid_check_abort(void)

{
  return 0;
}



void ghid_end_abort(void)

{
  return;
}



void ghid_clear_increment_get_value(gchar *saction,gchar **value,gchar **units)

{
  undefined4 uVar1;
  gchar s_buf [64];
  undefined *puVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  
  puVar2 = &DAT_081550d0;
  uVar4 = Settings.clear_increment_mil._4_4_;
  uVar1 = Settings.clear_increment_mil._0_4_;
  if (Settings.grid_units_mm != '\0') {
    uVar4 = Settings.clear_increment_mm._4_4_;
    uVar1 = Settings.clear_increment_mm._0_4_;
  }
  if (*saction == '+') {
    puVar2 = &DAT_081550d4;
  }
  __snprintf_chk(0x818e4c0,0x40,1,0x40,puVar2,uVar1,uVar4);
  *value = (gchar *)&ram0x0818e4c0;
  pgVar3 = "mil";
  if (Settings.grid_units_mm != '\0') {
    pgVar3 = "mm";
  }
  *units = pgVar3;
  return;
}



void ghid_line_increment_get_value(gchar *saction,gchar **value,gchar **units)

{
  undefined4 uVar1;
  gchar s_buf [64];
  undefined *puVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  
  puVar2 = &DAT_081550d0;
  uVar4 = Settings.line_increment_mil._4_4_;
  uVar1 = Settings.line_increment_mil._0_4_;
  if (Settings.grid_units_mm != '\0') {
    uVar4 = Settings.line_increment_mm._4_4_;
    uVar1 = Settings.line_increment_mm._0_4_;
  }
  if (*saction == '+') {
    puVar2 = &DAT_081550d4;
  }
  __snprintf_chk(0x818e500,0x40,1,0x40,puVar2,uVar1,uVar4);
  *value = (gchar *)&ram0x0818e500;
  pgVar3 = "mil";
  if (Settings.grid_units_mm != '\0') {
    pgVar3 = "mm";
  }
  *units = pgVar3;
  return;
}



void ghid_size_increment_get_value(gchar *saction,gchar **value,gchar **units)

{
  undefined4 uVar1;
  gchar s_buf [64];
  undefined *puVar2;
  gchar *pgVar3;
  undefined4 uVar4;
  
  puVar2 = &DAT_081550d0;
  uVar4 = Settings.size_increment_mil._4_4_;
  uVar1 = Settings.size_increment_mil._0_4_;
  if (Settings.grid_units_mm != '\0') {
    uVar4 = Settings.size_increment_mm._4_4_;
    uVar1 = Settings.size_increment_mm._0_4_;
  }
  if (*saction == '+') {
    puVar2 = &DAT_081550d4;
  }
  __snprintf_chk(0x818e540,0x40,1,0x40,puVar2,uVar1,uVar4);
  *value = (gchar *)&ram0x0818e540;
  pgVar3 = "mil";
  if (Settings.grid_units_mm != '\0') {
    pgVar3 = "mm";
  }
  *units = pgVar3;
  return;
}



void ghid_get_pointer(int *x,int *y)

{
  int local_14;
  int local_10;
  
  gdk_window_get_pointer(gport->drawing_area->window,&local_10,&local_14,0);
  if (x != (int *)0x0) {
    *x = local_10;
  }
  if (y != (int *)0x0) {
    *y = local_14;
  }
  return;
}



gboolean loop_key_press_cb(GtkWidget *drawing_area,GdkEventKey *kev,GMainLoop **loop)

{
  guint ksym;
  gboolean gVar1;
  ModifierKeysState MVar2;
  int iVar3;
  undefined4 local_34;
  GdkModifierType local_20 [4];
  
  ksym = kev->keyval;
  gVar1 = ghid_is_modifier_key_sym(ksym);
  if (gVar1 != 0) {
    return 1;
  }
  local_20[0] = kev->state;
  MVar2 = ghid_modifier_keys_state(local_20);
  if (ksym == 0xff52) {
    if (MVar2 != CONTROL_PRESSED) {
      if (MVar2 == SHIFT_PRESSED) {
        hid_actionl("MovePointer",0x8161294,0x8148dfe,0);
        return 1;
      }
      if (MVar2 != NONE_PRESSED) {
        return 1;
      }
      hid_actionl("MovePointer",0x8161294,&DAT_0815391d,0);
      return 1;
    }
    local_34 = 0x81491ba;
    goto LAB_080fde57;
  }
  if ((int)ksym < 0xff53) {
    if (ksym == 0xff0d) goto LAB_080fdcf8;
    if (ksym == 0xff51) {
      if (MVar2 != CONTROL_PRESSED) {
        if (MVar2 == SHIFT_PRESSED) {
          hid_actionl("MovePointer",0x8148dfe,0x8161294,0);
          return 1;
        }
        if (MVar2 != NONE_PRESSED) {
          return 1;
        }
        hid_actionl("MovePointer",&DAT_0815391d,0x8161294,0);
        return 1;
      }
      local_34 = 0x814912a;
      goto LAB_080fde57;
    }
  }
  else {
    if (ksym == 0xff53) {
      if (MVar2 != CONTROL_PRESSED) {
        if (MVar2 == SHIFT_PRESSED) {
          hid_actionl("MovePointer",0x8148c4c,0x8161294,0);
          return 1;
        }
        if (MVar2 != NONE_PRESSED) {
          return 1;
        }
        hid_actionl("MovePointer",&DAT_08156a80,0x8161294,0);
        return 1;
      }
      local_34 = 0x814916e;
LAB_080fde57:
      hid_actionl("Display","Scroll",local_34,0);
      hid_actionl("Display","Scroll",0x8161294,0);
      return 1;
    }
    if (ksym == 0xff54) {
      if (MVar2 != CONTROL_PRESSED) {
        if (MVar2 == SHIFT_PRESSED) {
          hid_actionl("MovePointer",0x8161294,0x8148c4c,0);
          return 1;
        }
        if (MVar2 != NONE_PRESSED) {
          return 1;
        }
        hid_actionl("MovePointer",0x8161294,&DAT_08156a80,0);
        return 1;
      }
      local_34 = 0x815fd80;
      goto LAB_080fde57;
    }
  }
  got_location = 0;
LAB_080fdcf8:
  iVar3 = g_main_loop_is_running(*loop);
  if (iVar3 == 0) {
    return 1;
  }
  g_main_loop_quit(*loop);
  return 1;
}



gboolean loop_button_press_cb(GtkWidget *drawing_area,GdkEventButton *ev,GMainLoop **loop)

{
  int iVar1;
  
  iVar1 = g_main_loop_is_running(*loop);
  if (iVar1 != 0) {
    g_main_loop_quit(*loop);
  }
  ghid_note_event_location(ev);
  return 1;
}



GdkCursorType __regparm3 gport_set_cursor(GdkCursorType shape)

{
  GdkCursorType GVar1;
  GdkCursor *pGVar2;
  GHidPort *pGVar3;
  GdkColor bg;
  GdkColor fg;
  
  pGVar3 = gport;
  GVar1 = gport->X_cursor_shape;
  if ((gport->drawing_area != (GtkWidget *)0x0) && (gport->drawing_area->window != (GdkWindow *)0x0)
     ) {
    if (GVar1 != shape) {
      fg.pixel = 0;
      fg.red = 0xffff;
      fg.green = 0xffff;
      fg.blue = 0xffff;
      bg.pixel = 0;
      bg.red = 0;
      bg.green = 0;
      bg.blue = 0;
      gport->X_cursor_shape = shape;
      if (shape < 0x9a) {
        pGVar2 = (GdkCursor *)gdk_cursor_new(shape);
        pGVar3->X_cursor = pGVar2;
        pGVar3 = gport;
      }
      else {
        if (shape == 0xa3) {
          pGVar2 = (GdkCursor *)
                   gdk_cursor_new_from_pixmap(XC_clock_source,XC_clock_mask,&fg,&bg,8,8);
          pGVar3->X_cursor = pGVar2;
          pGVar3 = gport;
        }
        else {
          if (shape == 0xa4) {
            pGVar2 = (GdkCursor *)
                     gdk_cursor_new_from_pixmap(XC_hand_source,XC_hand_mask,&fg,&bg,8,8);
            pGVar3->X_cursor = pGVar2;
            pGVar3 = gport;
          }
          else {
            if (shape == 0xa5) {
              pGVar2 = (GdkCursor *)
                       gdk_cursor_new_from_pixmap(XC_lock_source,XC_lock_mask,&fg,&bg,8,8);
              pGVar3->X_cursor = pGVar2;
              pGVar3 = gport;
            }
          }
        }
      }
      gdk_window_set_cursor(pGVar3->drawing_area->window,pGVar3->X_cursor);
      gdk_cursor_unref(gport->X_cursor);
      shape = GVar1;
    }
    return shape;
  }
  return GDK_X_CURSOR;
}



void ghid_restore_cursor(void)

{
  gport_set_cursor(oldCursor);
  return;
}



void ghid_corner_cursor(void)

{
  GdkCursorType shape;
  
  if (Crosshair.AttachedBox.Point1.Y < Crosshair.Y) {
    shape = (uint)(Crosshair.AttachedBox.Point1.X <= Crosshair.X) * 2 + GDK_LL_ANGLE;
    if (gport->X_cursor_shape == shape) {
      return;
    }
  }
  else {
    shape = (uint)(Crosshair.AttachedBox.Point1.X <= Crosshair.X) * 4 + GDK_UL_ANGLE;
    if (gport->X_cursor_shape == shape) {
      return;
    }
  }
  gport_set_cursor(shape);
  return;
}



void ghid_watch_cursor(void)

{
  GdkCursorType GVar1;
  
  GVar1 = gport_set_cursor(GDK_WATCH);
  if (GVar1 != GDK_WATCH) {
    oldCursor = GVar1;
  }
  return;
}



void ghid_hand_cursor(void)

{
  oldCursor = gport_set_cursor(GDK_HAND2);
  return;
}



void ghid_point_cursor(void)

{
  oldCursor = gport_set_cursor(GDK_DRAPED_BOX);
  return;
}



void ghid_mode_cursor(int Mode)

{
  gboolean gVar1;
  
  switch(Mode) {
  case 0:
    gport_set_cursor(0xa4);
    return;
  case 1:
    gport_set_cursor(GDK_ARROW);
    return;
  case 2:
    gport_set_cursor(GDK_PENCIL);
    return;
  case 3:
    gport_set_cursor(GDK_UL_ANGLE);
    return;
  case 4:
    gport_set_cursor(GDK_SB_UP_ARROW);
    return;
  case 5:
    gport_set_cursor(GDK_HAND1);
    return;
  case 6:
    gport_set_cursor(GDK_XTERM);
    return;
  default:
    return;
  case 0x66:
    break;
  case 0x67:
    gport_set_cursor(GDK_PIRATE);
    return;
  case 0x68:
  case 0x69:
    gport_set_cursor(GDK_CROSSHAIR);
    return;
  case 0x6a:
    gport_set_cursor(GDK_DOTBOX);
    return;
  case 0x6c:
    gport_set_cursor(GDK_IRON_CROSS);
    return;
  case 0x6d:
    gport_set_cursor(GDK_QUESTION_ARROW);
    return;
  case 0x6e:
    gport_set_cursor(GDK_LEFT_PTR);
    return;
  case 0x6f:
    gport_set_cursor(0xa5);
    return;
  }
  gVar1 = ghid_shift_is_pressed();
  if (gVar1 != 0) {
    gport_set_cursor(0xa3);
    return;
  }
  gport_set_cursor(GDK_EXCHANGE);
  return;
}



void ghid_cursor_position_relative_label_set_text(gchar *text)

{
  ghid_label_set_markup(ghidgui->cursor_position_relative_label,text);
  return;
}



void ghid_cursor_position_label_set_text(gchar *text)

{
  ghid_label_set_markup(ghidgui->cursor_position_absolute_label,text);
  return;
}



void ghid_set_cursor_position_labels(void)

{
  int iVar1;
  int in_GS_OFFSET;
  double dVar2;
  char *local_fc;
  double local_f8;
  double local_f0;
  gchar text [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Marked.status == '\0') {
    ghid_cursor_position_relative_label_set_text("r __.__; phi __._; __.__ __.__");
  }
  else {
    local_f0 = 0.01000000;
    if (Settings.grid_units_mm != '\0') {
      local_f0 = 0.00025400;
    }
    local_f8 = (double)(Crosshair.X - Marked.X) * local_f0;
    local_f0 = (double)(Marked.Y - Crosshair.Y) * local_f0;
    dVar2 = atan2(local_f0,local_f8);
    if (Settings.grid_units_mm == '\0') {
      local_fc = "r %-.2f; phi %-.1f; %-.2f %-.2f";
    }
    else {
      local_fc = "r %-.4f; phi %-.1f; %-.4f %-.4f";
    }
    __snprintf_chk(text,0x80,1,0x80,local_fc,SQRT(local_f0 * local_f0 + local_f8 * local_f8),
                   (dVar2 * 180.00000000) / 3.14159265,local_f8,local_f0);
    ghid_cursor_position_relative_label_set_text(text);
  }
  if (Settings.grid_units_mm == '\0') {
    local_fc = "%-.2f %-.2f";
    local_f0 = (double)((float)Crosshair.Y / 100.00000000);
    local_f8 = (double)((float)Crosshair.X / 100.00000000);
  }
  else {
    local_f0 = (double)Crosshair.Y * 0.00025400;
    local_fc = "%-.4f %-.4f";
    local_f8 = (double)Crosshair.X * 0.00025400;
  }
  __snprintf_chk(text,0x80,1,0x80,local_fc,local_f8,local_f0);
  ghid_cursor_position_label_set_text(text);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ghid_status_line_set_text(gchar *text)

{
  if (ghidgui->command_entry_status_line_active != 0) {
    return;
  }
  ghid_label_set_markup(ghidgui->status_line_label,text);
  return;
}



void ghid_set_status_line_label(void)

{
  double dVar1;
  int iVar2;
  char cVar3;
  uint uVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  undefined4 uVar17;
  undefined *local_290;
  undefined1 *local_274;
  int in_GS_OFFSET;
  undefined4 local_25c;
  undefined *local_234;
  gchar text [512];
  
  iVar16 = Settings.GridFactor;
  iVar15 = Settings.BufferNumber;
  iVar14 = Settings.TextScale;
  iVar13 = Settings.Keepaway;
  iVar12 = Settings.LineThickness;
  iVar11 = Settings.ViaDrillingHole;
  iVar10 = Settings.ViaThickness;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  if (Settings.grid_units_mm == '\0') {
    local_274 = &DAT_0814741b;
    local_234 = (undefined *)0x814802e;
    local_290 = &DAT_0815672f;
    if (ghidgui->compact_horizontal != 0) {
      local_274 = (undefined1 *)0x8151453;
    }
    uVar4 = (PCB->Flags).f;
    if ((uVar4 & 0x10) != 0) {
      local_290 = &DAT_081550fc;
    }
    if ((uVar4 & 0x100) == 0) {
      local_234 = &DAT_08155101;
      if ((PCB->Clipping != 0) && (local_234 = &DAT_08155109, PCB->Clipping != 1)) {
        local_234 = &DAT_08155104;
      }
    }
    dVar1 = PCB->Grid;
    if (Settings.ShowSolderSide == '\0') {
      local_25c = dcgettext(&DAT_0815492c,0x8153a8e,5);
    }
    else {
      local_25c = dcgettext(&DAT_0815492c,0x8153a6c,5);
    }
    cVar3 = PCB->Changed;
    uVar17 = dcgettext(&DAT_0815492c,
                                              
                       "<b>%c  view</b>=%s  <b>grid</b>=%.1f:%i  %s%s  <b>line</b>=%.1f  <b>via</b>=%.1f(%.1f)  %s<b>clearance</b>=%.1f  <b>text</b>=%i%%  <b>buffer</b>=#%i"
                       ,5);
    fVar5 = (float)iVar13 / 100.00000000;
    fVar6 = (float)iVar11 / 100.00000000;
    fVar7 = (float)iVar10 / 100.00000000;
    fVar8 = (float)iVar12 / 100.00000000;
    fVar9 = (float)dVar1 / 100.00000000;
  }
  else {
    local_274 = &DAT_0814741b;
    local_290 = &DAT_0815672f;
    local_234 = (undefined *)0x814802e;
    if (ghidgui->compact_horizontal != 0) {
      local_274 = (undefined1 *)0x8151453;
    }
    uVar4 = (PCB->Flags).f;
    if ((uVar4 & 0x10) != 0) {
      local_290 = &DAT_081550fc;
    }
    if ((uVar4 & 0x100) == 0) {
      local_234 = &DAT_08155101;
      if ((PCB->Clipping != 0) && (local_234 = &DAT_08155109, PCB->Clipping != 1)) {
        local_234 = &DAT_08155104;
      }
    }
    dVar1 = PCB->Grid;
    if (Settings.ShowSolderSide == '\0') {
      local_25c = dcgettext(&DAT_0815492c,0x8153a8e,5);
    }
    else {
      local_25c = dcgettext(&DAT_0815492c,0x8153a6c,5);
    }
    cVar3 = PCB->Changed;
    uVar17 = dcgettext(&DAT_0815492c,
                                              
                       "<b>%c  view</b>=%s  <b>grid</b>=%5.3f:%i  %s%s  <b>line</b>=%5.3f  <b>via</b>=%5.3f(%5.3f)  %s<b>clearance</b>=%5.3f  <b>text</b>=%i%%  <b>buffer</b>=#%i"
                       ,5);
    fVar5 = (float)iVar13 * 0.00025400;
    fVar6 = (float)iVar11 * 0.00025400;
    fVar7 = (float)iVar10 * 0.00025400;
    fVar8 = (float)iVar12 * 0.00025400;
    fVar9 = (float)dVar1 * 0.00025400;
  }
  __snprintf_chk(text,0x200,1,0x200,uVar17,(-(uint)(cVar3 == '\0') & 0xfffffff6) + 0x2a,local_25c,
                 (double)fVar9,iVar16,local_234,local_290,(double)fVar8,(double)fVar7,(double)fVar6,
                 local_274,(double)fVar5,iVar14,iVar15 + 1);
  ghid_status_line_set_text(text);
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void ghid_get_user_xy(char *msg)

{
  long lVar1;
  long lVar2;
  long lVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 local_20 [4];
  
  ghid_status_line_set_text(msg);
  lVar3 = Crosshair.AttachedObject.State;
  lVar2 = Crosshair.AttachedBox.State;
  lVar1 = Crosshair.AttachedLine.State;
  HideCrosshair('\x01');
  Crosshair.AttachedObject.State = 0;
  Crosshair.AttachedLine.State = 0;
  Crosshair.AttachedBox.State = 0;
  ghid_hand_cursor();
  RestoreCrosshair('\x01');
  ghid_interface_input_signals_disconnect();
  ghid_interface_set_sensitive(0);
  got_location = 1;
  uVar4 = g_type_check_instance_cast(gport->drawing_area,0x50);
  uVar4 = g_signal_connect_data(uVar4,"button_press_event",loop_button_press_cb,local_20,0,0);
  uVar5 = g_type_check_instance_cast(gport->top_window,0x50);
  uVar5 = g_signal_connect_data(uVar5,"key_press_event",loop_key_press_cb,local_20,0,0);
  local_20[0] = g_main_loop_new(0,0);
  g_main_loop_run(local_20[0]);
  g_main_loop_unref(local_20[0]);
  g_signal_handler_disconnect(gport->drawing_area,uVar4);
  g_signal_handler_disconnect(gport->top_window,uVar5);
  ghid_interface_input_signals_connect();
  ghid_interface_set_sensitive(1);
  HideCrosshair('\x01');
  Crosshair.AttachedLine.State = lVar1;
  Crosshair.AttachedBox.State = lVar2;
  Crosshair.AttachedObject.State = lVar3;
  RestoreCrosshair('\x01');
  ghid_restore_cursor();
  ghid_set_status_line_label();
  return;
}



gint netlist_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,gpointer data)

{
  gint gVar1;
  GhidGui *pGVar2;
  
  pGVar2 = ghidgui;
  gVar1 = (widget->allocation).height;
  ghidgui->config_modified = 1;
  pGVar2->netlist_window_height = gVar1;
  return 0;
}



void netlist_destroy_cb(GtkWidget *widget,GHidPort *out)

{
  netlist_window = (GtkWidget *)0x0;
  selected_net = (LibraryMenuType *)0x0;
  return;
}



void register_ghid_netlist_action_list(void)

{
  hid_register_actions(ghid_netlist_action_list,2);
  return;
}



GtkTreeModel * net_model_create(void)

{
  Cardinal CVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkTreeModel *pGVar4;
  void *__src;
  int iVar5;
  GtkTreeIter *pGVar6;
  void *__dest;
  undefined4 uVar7;
  undefined4 uVar8;
  int *piVar9;
  undefined4 *puVar10;
  int iVar11;
  int iVar12;
  GtkTreeIter *pGVar13;
  code *local_a0;
  int local_68;
  int local_64;
  int local_48;
  size_t local_40;
  GtkTreeIter parent_iter;
  GtkTreeIter new_iter;
  
  uVar2 = gtk_tree_store_new(3,0x40,0x40,0x44);
  uVar3 = gtk_tree_model_get_type();
  pGVar4 = (GtkTreeModel *)g_type_check_instance_cast(uVar2,uVar3);
  local_a0 = gtk_tree_row_reference_free;
  uVar3 = g_hash_table_new_full(g_str_hash,g_str_equal,g_free,gtk_tree_row_reference_free);
  CVar1 = (PCB->NetlistLib).MenuN;
  local_64 = CVar1 - 1;
  if (local_64 != -1) {
    iVar5 = CVar1 * 0x1c;
    do {
      local_68 = iVar5 + -0x1c;
      piVar9 = (int *)((int)&(PCB->NetlistLib).Menu[-1].Name + iVar5);
      if (*piVar9 != 0) {
        if (loading_new_netlist != 0) {
          *(undefined *)(piVar9 + 6) = 1;
        }
        __src = (void *)g_strsplit(*piVar9,0x815d1de,0,local_a0);
        iVar5 = g_strv_length(__src);
        iVar5 = iVar5 + -1;
        pGVar6 = (GtkTreeIter *)0x0;
        if (0 < iVar5) {
          local_40 = iVar5 * 4;
          local_48 = iVar5;
          do {
            __dest = (void *)g_malloc0_n(local_48 + 1,4);
            memcpy(__dest,__src,local_40);
            uVar7 = g_strjoinv(0x815d1de,__dest);
            g_free(__dest);
            pGVar13 = (GtkTreeIter *)g_hash_table_lookup(uVar3,uVar7);
            g_free(uVar7);
            if (pGVar13 != (GtkTreeIter *)0x0) {
              pGVar6 = &parent_iter;
              uVar7 = gtk_tree_row_reference_get_path(pGVar13);
              gtk_tree_model_get_iter(pGVar4,&parent_iter,uVar7);
              iVar11 = local_48 + 1;
              pGVar13 = pGVar6;
              if (iVar5 <= local_48) goto LAB_080fef68;
              break;
            }
            iVar12 = local_48 + -1;
            local_40 = local_40 - 4;
            iVar11 = local_48;
            local_48 = iVar12;
          } while (0 < iVar12);
          puVar10 = (undefined4 *)((int)__src + local_48 * 4);
          local_40 = iVar11 * 4;
          while( true ) {
            iVar12 = iVar11;
            uVar7 = g_strconcat(*puVar10,0x815d1de,0);
            gtk_tree_store_append(uVar2,&new_iter,pGVar13);
            gtk_tree_store_set(uVar2,&new_iter,0,&DAT_0814741b,1,uVar7,2,0,0xffffffff);
            g_free(uVar7);
            uVar7 = gtk_tree_model_get_path(pGVar4,&new_iter);
            uVar7 = gtk_tree_row_reference_new(pGVar4,uVar7);
            parent_iter.stamp = new_iter.stamp;
            parent_iter.user_data = new_iter.user_data;
            parent_iter.user_data2 = new_iter.user_data2;
            parent_iter.user_data3 = new_iter.user_data3;
            __dest = (void *)g_malloc0_n(local_48 + 2,4);
            memcpy(__dest,__src,local_40);
            uVar8 = g_strjoinv(0x815d1de,__dest);
            pGVar13 = &parent_iter;
            g_free(__dest);
            g_hash_table_insert(uVar3,uVar8,uVar7);
            local_40 = local_40 + 4;
            puVar10 = puVar10 + 1;
            if (iVar5 <= iVar12) break;
            iVar11 = iVar12 + 1;
            local_48 = iVar12;
          }
          pGVar6 = &parent_iter;
        }
LAB_080fef68:
        gtk_tree_store_append(uVar2,&new_iter,pGVar6);
        local_a0 = (code *)&DAT_081548e9;
        if (*(char *)(piVar9 + 6) != '\0') {
          local_a0 = (code *)&DAT_0814741b;
        }
        gtk_tree_store_set(uVar2,&new_iter,0,local_a0,1,*(undefined4 *)((int)__src + iVar5 * 4),2,
                           piVar9,0xffffffff);
        g_strfreev(__src);
      }
      local_64 = local_64 + -1;
      iVar5 = local_68;
    } while (local_64 != -1);
  }
  g_hash_table_destroy(uVar3);
  return pGVar4;
}



void __regparm3 node_model_update(LibraryMenuType *menu)

{
  GtkTreeModel *pGVar1;
  undefined4 uVar2;
  int iVar3;
  undefined *puVar4;
  int *piVar5;
  undefined4 local_54;
  GtkTreeIter iter;
  
  pGVar1 = node_model;
  local_54 = 0x44;
  uVar2 = gtk_list_store_new(2,0x40,0x44);
  if (menu != (LibraryMenuType *)0x0) {
    iVar3 = menu->EntryN - 1;
    if (iVar3 != -1) {
      puVar4 = (undefined *)(menu->EntryN * 0x18);
      do {
        puVar4 = &DAT_ffffffe8 + (int)puVar4;
        piVar5 = (int *)((int)&menu->Entry->ListEntry + (int)puVar4);
        if (*piVar5 != 0) {
          gtk_list_store_append(uVar2,&iter,local_54);
          local_54 = 0;
          gtk_list_store_set(uVar2,&iter,0,*piVar5,1,piVar5,0xffffffff);
        }
        iVar3 = iVar3 + -1;
      } while (iVar3 != -1);
    }
  }
  local_54 = gtk_tree_model_get_type();
  node_model = (GtkTreeModel *)g_type_check_instance_cast(uVar2,local_54);
  gtk_tree_view_set_model(node_treeview,node_model);
  uVar2 = gtk_tree_sortable_get_type();
  uVar2 = g_type_check_instance_cast(node_model,uVar2);
  gtk_tree_sortable_set_sort_column_id(uVar2,0,0);
  if (pGVar1 != (GtkTreeModel *)0x0) {
    uVar2 = g_type_check_instance_cast(pGVar1,0x50);
    g_object_unref(uVar2);
  }
  return;
}



void ghid_netlist_nodes_update(LibraryMenuType *net)

{
  node_model_update(net);
  return;
}



gboolean hunt_named_node(GtkTreeModel *model,GtkTreePath *path,GtkTreeIter *iter,gpointer data)

{
  char cVar1;
  int iVar2;
  int iVar3;
  char **ppcVar4;
  char *local_24;
  int local_20 [4];
  
  iVar2 = gtk_tree_model_iter_has_child(model,iter);
  if (iVar2 == 0) {
    gtk_tree_model_get(model,iter,2,local_20,0xffffffff);
    gtk_tree_model_get(model,iter,0,&local_24,0xffffffff);
    if (*local_24 == '*') {
      cVar1 = local_24[1];
      g_free(local_24);
      if ((cVar1 == '\0') && (*(int *)data != 0)) {
        return 0;
      }
    }
    else {
      g_free(local_24);
    }
    iVar2 = *(int *)(local_20[0] + 0xc);
    ppcVar4 = *(char ***)(local_20[0] + 0x14);
    if (iVar2 != 0) {
      while( true ) {
        if ((*ppcVar4 != (char *)0x0) &&
           (iVar3 = strcmp(*(char **)((int)data + 4),*ppcVar4), iVar3 == 0)) {
          *(int *)((int)data + 8) = local_20[0];
          *(gint *)((int)data + 0xc) = iter->stamp;
          *(gpointer *)((int)data + 0x10) = iter->user_data;
          *(gpointer *)((int)data + 0x14) = iter->user_data2;
          *(gpointer *)((int)data + 0x18) = iter->user_data3;
          return 1;
        }
        iVar2 = iVar2 + -1;
        if (iVar2 == 0) break;
        ppcVar4 = ppcVar4 + 6;
      }
    }
  }
  return 0;
}



void ghid_netlist_window_show(GHidPort *out,gboolean raise)

{
  gint gVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 local_54;
  GtkWidget *box;
  GtkWidget *box_00;
  GtkTreeModel *pGVar4;
  GtkTreeView *treeview;
  undefined4 uVar5;
  gchar *string;
  char *local_58;
  undefined *puVar6;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  
  box = netlist_window;
  if ((PCB->NetlistLib).MenuN == 0) {
    return;
  }
  if (netlist_window != (GtkWidget *)0x0) {
    if (raise != 0) {
      uVar2 = gtk_window_get_type();
      uVar2 = g_type_check_instance_cast(box,uVar2);
      gtk_window_present(uVar2);
    }
    ghid_netlist_window_update(1);
    return;
  }
  netlist_window = (GtkWidget *)gtk_window_new(0);
  uVar2 = g_type_check_instance_cast(netlist_window,0x50);
  g_signal_connect_data(uVar2,0x815f66a,netlist_destroy_cb,out,0,0);
  uVar2 = dcgettext(&DAT_0815492c,"PCB Netlist",5);
  uVar3 = gtk_window_get_type();
  local_54 = g_type_check_instance_cast(netlist_window,uVar3);
  gtk_window_set_title(local_54,uVar2);
  uVar2 = g_type_check_instance_cast(netlist_window,uVar3);
  gtk_window_set_wmclass(uVar2,"PCB_Netlist",&DAT_08154932);
  uVar2 = g_type_check_instance_cast(netlist_window,0x50);
  g_signal_connect_data(uVar2,"configure_event",netlist_window_configure_event_cb,0,0,0);
  gVar1 = ghidgui->netlist_window_height;
  uVar2 = g_type_check_instance_cast(netlist_window,uVar3);
  gtk_window_set_default_size(uVar2,0xffffffff,gVar1);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(netlist_window,uVar2);
  gtk_container_set_border_width(uVar3,2);
  box = (GtkWidget *)gtk_vbox_new(0,4);
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_container_set_border_width(uVar3,6);
  uVar2 = g_type_check_instance_cast(netlist_window,uVar2);
  gtk_container_add(uVar2,box);
  box_00 = (GtkWidget *)gtk_hbox_new(0,8);
  uVar2 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(uVar3,box_00,1,1,4);
  pGVar4 = net_model_create();
  uVar3 = gtk_tree_view_get_type();
  local_54 = gtk_tree_view_new_with_model(pGVar4);
  treeview = (GtkTreeView *)g_type_check_instance_cast(local_54,uVar3);
  net_model = pGVar4;
  net_treeview = treeview;
  local_54 = gtk_tree_sortable_get_type();
  local_54 = g_type_check_instance_cast(pGVar4,local_54);
  gtk_tree_sortable_set_sort_column_id(local_54,1,0);
  gtk_tree_view_set_rules_hint(treeview,0);
  g_object_set(treeview,"enable-tree-lines",1,0);
  local_54 = gtk_cell_renderer_text_new();
  uVar5 = dcgettext(&DAT_0815492c,&DAT_08156730,5);
  gtk_tree_view_insert_column_with_attributes(treeview,0xffffffff,uVar5,local_54,&DAT_081539ac,0,0);
  local_54 = gtk_cell_renderer_text_new();
  uVar5 = dcgettext(&DAT_0815492c,"Net Name",5);
  local_54 = gtk_tree_view_column_new_with_attributes(uVar5,local_54,&DAT_081539ac,1,0);
  gtk_tree_view_insert_column(treeview,local_54,0xffffffff);
  gtk_tree_view_set_expander_column(treeview,local_54);
  gtk_tree_view_expand_all(treeview);
  ghid_scrolled_selection
            (treeview,box_00,GTK_SELECTION_SINGLE,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC,
             net_selection_changed_cb,(gpointer)0x0);
  local_54 = g_type_check_instance_cast(treeview,0x50);
  g_signal_connect_data(local_54,"row-activated",net_selection_double_click_cb,0,0,0);
  local_54 = gtk_tree_view_new();
  treeview = (GtkTreeView *)g_type_check_instance_cast(local_54,uVar3);
  node_treeview = treeview;
  gtk_tree_view_set_rules_hint(treeview,0);
  uVar3 = gtk_cell_renderer_text_new();
  local_54 = dcgettext(&DAT_0815492c,"Nodes",5);
  gtk_tree_view_insert_column_with_attributes(treeview,0xffffffff,local_54,uVar3,&DAT_081539ac,0,0);
  node_selection =
       ghid_scrolled_selection
                 (treeview,box_00,GTK_SELECTION_SINGLE,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC,
                  node_selection_changed_cb,(gpointer)0x0);
  uVar3 = gtk_hbox_new(0,0);
  local_54 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(local_54,uVar3,0,0,0);
  local_54 = dcgettext(&DAT_0815492c,"Operations on selected \'Net Name\':",5);
  local_54 = gtk_label_new(local_54);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar3,local_54,0,0,4);
  uVar3 = gtk_misc_get_type();
  uVar3 = g_type_check_instance_cast(local_54,uVar3);
  local_54 = 0x3f000000;
  gtk_misc_set_alignment(uVar3,0);
  uVar3 = gtk_hbox_new(0,0);
  local_54 = g_type_check_instance_cast(box,uVar2,local_54);
  local_4c = 4;
  local_50 = 0;
  gtk_box_pack_start(local_54,uVar3,0);
  uVar5 = 5;
  local_58 = "Select";
  local_54 = dcgettext(&DAT_0815492c);
  local_54 = gtk_button_new_with_label(local_54,local_58);
  uVar5 = g_type_check_instance_cast(uVar3,uVar2,uVar5,local_50,local_4c);
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  gtk_box_pack_start(uVar5,local_54);
  local_54 = g_type_check_instance_cast(local_54,0x50,local_50,local_4c,local_48);
  local_48 = 0;
  local_4c = 0;
  local_50 = 1;
  g_signal_connect_data(local_54,"clicked",netlist_select_cb);
  uVar5 = 5;
  local_58 = "Unselect";
  local_54 = dcgettext(&DAT_0815492c);
  local_54 = gtk_button_new_with_label(local_54,local_58);
  uVar5 = g_type_check_instance_cast(uVar3,uVar2,uVar5,local_50,local_4c,local_48);
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  gtk_box_pack_start(uVar5,local_54);
  local_54 = g_type_check_instance_cast(local_54,0x50,local_50,local_4c,local_48);
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  g_signal_connect_data(local_54,"clicked",netlist_select_cb);
  uVar5 = 5;
  puVar6 = &DAT_0813a46a;
  local_54 = dcgettext(&DAT_0815492c);
  local_54 = gtk_button_new_with_label(local_54,puVar6);
  uVar5 = g_type_check_instance_cast(uVar3,uVar2,uVar5,local_50,local_4c,local_48);
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  gtk_box_pack_start(uVar5,local_54);
  local_54 = g_type_check_instance_cast(local_54,0x50,local_50,local_4c,local_48);
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  g_signal_connect_data(local_54,"clicked",netlist_find_cb);
  uVar5 = 5;
  puVar6 = &DAT_081554af;
  local_54 = dcgettext(&DAT_0815492c);
  local_54 = gtk_button_new_with_label(local_54,puVar6);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2,uVar5,local_50,local_4c,local_48);
  gtk_box_pack_start(uVar3,local_54,0,0,0);
  uVar3 = g_type_check_instance_cast(local_54,0x50);
  g_signal_connect_data(uVar3,"clicked",netlist_rip_up_cb,0,0,0);
  string = (gchar *)dcgettext(&DAT_0815492c,"Disable all nets for adding rats",5);
  ghid_check_button_connected
            (box,&disable_all_button,0,1,0,0,0,netlist_disable_all_cb,(gpointer)0x0,string);
  uVar3 = gtk_hseparator_new();
  local_54 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(local_54,uVar3,0,0,3);
  uVar3 = gtk_hbutton_box_new();
  local_54 = gtk_button_box_get_type();
  local_54 = g_type_check_instance_cast(uVar3,local_54);
  gtk_button_box_set_layout(local_54,4);
  local_54 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(local_54,uVar3,0,0,4);
  local_54 = gtk_button_new_from_stock("gtk-close");
  uVar5 = g_type_check_instance_cast(local_54,0x50);
  g_signal_connect_data(uVar5,"clicked",netlist_close_cb,0,0,0);
  uVar2 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar2,local_54,1,1,0);
  gtk_widget_realize(netlist_window);
  if (Settings.AutoPlace != '\0') {
    uVar2 = gtk_widget_get_type();
    uVar2 = g_type_check_instance_cast(netlist_window,uVar2);
    gtk_widget_set_uposition(uVar2,10,10);
  }
  gtk_widget_show_all();
  return;
}



void ghid_netlist_window_update(gboolean init_nodes)

{
  GtkTreeModel *pGVar1;
  undefined4 uVar2;
  
  pGVar1 = net_model;
  if (netlist_window == (GtkWidget *)0x0) {
    ghid_netlist_window_show(gport,0);
    return;
  }
  net_model = net_model_create();
  gtk_tree_view_set_model(net_treeview,net_model);
  uVar2 = gtk_tree_sortable_get_type();
  uVar2 = g_type_check_instance_cast(net_model,uVar2);
  gtk_tree_sortable_set_sort_column_id(uVar2,1,0);
  if (pGVar1 != (GtkTreeModel *)0x0) {
    uVar2 = gtk_tree_store_get_type();
    uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
    gtk_tree_store_clear(uVar2);
    g_object_unref(pGVar1);
  }
  selected_net = (LibraryMenuType *)0x0;
  if (init_nodes == 0) {
    selected_net = (LibraryMenuType *)0x0;
    return;
  }
  node_model_update((LibraryMenuType *)(PCB->NetlistLib).Menu);
  return;
}



gint NetlistChanged(int argc,char **argv,int x,int y)

{
  undefined4 uVar1;
  
  loading_new_netlist = 1;
  ghid_netlist_window_update(1);
  uVar1 = gtk_toggle_button_get_type();
  uVar1 = g_type_check_instance_cast(disable_all_button,uVar1);
  gtk_toggle_button_set_active(uVar1,0);
  loading_new_netlist = 0;
  return 0;
}



LibraryMenuType * ghid_get_net_from_node_name(gchar *node_name,gboolean enabled_only)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  ggnfnn_task task;
  
  if (node_name != (gchar *)0x0) {
    if (netlist_window == (GtkWidget *)0x0) {
      ghid_netlist_window_show(gport,0);
    }
    while (iVar1 = gtk_events_pending(), iVar1 != 0) {
      gtk_main_iteration();
    }
    if (netlist_window != (GtkWidget *)0x0) {
      task.enabled_only = enabled_only;
      task.node_name = node_name;
      task.found_net = (LibraryMenuType *)0x0;
      gtk_tree_model_foreach(net_model,hunt_named_node,&task);
      if (enabled_only == 0) {
        return task.found_net;
      }
      if (task.found_net == (LibraryMenuType *)0x0) {
        return (LibraryMenuType *)0x0;
      }
      selection_holdoff = 1;
      uVar2 = gtk_tree_model_get_path(net_model,&task.iter);
      gtk_tree_view_scroll_to_cell(net_treeview,uVar2,0,1,0x3f000000,0x3f000000);
      uVar3 = gtk_tree_view_get_selection(net_treeview);
      gtk_tree_selection_select_path(uVar3,uVar2);
      selection_holdoff = 0;
      return task.found_net;
    }
  }
  return (LibraryMenuType *)0x0;
}



void ghid_netlist_highlight_node(gchar *node_name)

{
  LibraryMenuType *menu;
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  char *pcVar4;
  GtkTreeIter iter;
  char *local_20 [4];
  
  if ((node_name != (gchar *)0x0) &&
     (menu = ghid_get_net_from_node_name(node_name,1), menu != (LibraryMenuType *)0x0)) {
    node_model_update(menu);
    iVar1 = gtk_tree_model_get_iter_first(node_model,&iter);
    while (iVar1 != 0) {
      gtk_tree_model_get(node_model,&iter,0,local_20,0xffffffff);
      pcVar4 = local_20[0];
      iVar1 = strcmp(node_name,local_20[0]);
      if (iVar1 == 0) {
        selection_holdoff = 1;
        selected_net = menu;
        uVar2 = gtk_tree_model_get_path(node_model,&iter);
        gtk_tree_view_scroll_to_cell(node_treeview,uVar2,0,1,0x3f000000,0x3f000000);
        uVar3 = gtk_tree_view_get_selection(node_treeview);
        gtk_tree_selection_select_path(uVar3,uVar2);
        selection_holdoff = 0;
        pcVar4 = local_20[0];
      }
      g_free(pcVar4);
      iVar1 = gtk_tree_model_iter_next(node_model,&iter);
    }
  }
  return;
}



gint NetlistShow(int argc,char **argv,int x,int y)

{
  ghid_netlist_window_show(gport,0);
  if (0 < argc) {
    ghid_netlist_highlight_node(*argv);
  }
  return 0;
}



LibraryEntryType * node_get_node_from_name(gchar *node_name,LibraryMenuType **node_net)

{
  LibraryMenuType *pLVar1;
  int iVar2;
  LibraryEntryType *pLVar3;
  Cardinal CVar4;
  GtkTreeIter iter;
  LibraryMenuType *local_20 [4];
  
  if (node_name != (gchar *)0x0) {
    if (netlist_window == (GtkWidget *)0x0) {
      ghid_netlist_window_show(gport,0);
    }
    while (iVar2 = gtk_events_pending(), iVar2 != 0) {
      gtk_main_iteration();
    }
    iVar2 = gtk_tree_model_get_iter_first(net_model,&iter);
    while (iVar2 != 0) {
      gtk_tree_model_get(net_model,&iter,2,local_20,0xffffffff);
      pLVar1 = local_20[0];
      CVar4 = local_20[0]->EntryN;
      pLVar3 = (LibraryEntryType *)local_20[0]->Entry;
      if (CVar4 != 0) {
        while( true ) {
          if ((pLVar3->ListEntry != (char *)0x0) &&
             (iVar2 = strcmp(node_name,pLVar3->ListEntry), iVar2 == 0)) {
            if (node_net == (LibraryMenuType **)0x0) {
              return pLVar3;
            }
            *node_net = pLVar1;
            return pLVar3;
          }
          CVar4 = CVar4 - 1;
          if (CVar4 == 0) break;
          pLVar3 = pLVar3 + 1;
        }
      }
      iVar2 = gtk_tree_model_iter_next(net_model,&iter);
    }
  }
  return (LibraryEntryType *)0x0;
}



void netlist_close_cb(GtkWidget *widget,gpointer data)

{
  gtk_widget_destroy(netlist_window);
  netlist_window = (GtkWidget *)0x0;
  selected_net = (LibraryMenuType *)0x0;
  return;
}



void netlist_disable_all_cb(GtkToggleButton *button,gpointer data)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined1 *puVar5;
  GtkTreeIter iter;
  int local_20 [4];
  
  iVar1 = gtk_toggle_button_get_active(button);
  iVar2 = gtk_tree_model_get_iter_first(net_model,&iter);
  if (iVar2 != 0) {
    uVar3 = gtk_tree_store_get_type();
    do {
      puVar5 = &DAT_081548e9;
      if (iVar1 == 0) {
        puVar5 = &DAT_0814741b;
      }
      uVar4 = g_type_check_instance_cast(net_model,uVar3);
      gtk_tree_store_set(uVar4,&iter,0,puVar5,0xffffffff);
      gtk_tree_model_get(net_model,&iter,2,local_20,0xffffffff);
      *(bool *)(local_20[0] + 0x18) = iVar1 == 0;
      iVar2 = gtk_tree_model_iter_next(net_model,&iter);
    } while (iVar2 != 0);
  }
  return;
}



void netlist_find_cb(GtkWidget *widget,gpointer data)

{
  char *pcVar1;
  
  if (selected_net != (LibraryMenuType *)0x0) {
    pcVar1 = selected_net->Name;
    hid_actionl("connection","reset",0);
    hid_actionl("netlist",&DAT_0814a723,pcVar1 + 2,0);
  }
  return;
}



void netlist_rip_up_cb(GtkWidget *widget,gpointer data)

{
  uint uVar1;
  PCBTypePtr pPVar2;
  void *Ptr2;
  DataTypePtr *pDVar3;
  DataTypePtr *pDVar4;
  int iVar5;
  PinTypePtr *Ptr1;
  int iVar6;
  uint uVar7;
  void *Ptr1_00;
  uint uVar8;
  
  if (selected_net == (LibraryMenuType *)0x0) {
    return;
  }
  netlist_find_cb(widget,data);
  pDVar3 = PCB->Data;
  Ptr1_00 = (void *)&pDVar3->field_0x4c;
  pPVar2 = PCB;
  if (pDVar3->LayerN != -2) {
    uVar8 = 0;
    do {
      if (*(char *)((int)Ptr1_00 + 0x44) != '\0') {
        iVar6 = *(int *)((int)Ptr1_00 + 4) + -1;
        if (iVar6 != -1) {
          iVar5 = *(int *)((int)Ptr1_00 + 4) * 0x58 + -0x58;
          do {
            while (Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x24) + iVar5),
                  (*(uint *)((int)Ptr2 + 0x14) & 0x2004) == 4) {
              iVar6 = iVar6 + -1;
              RemoveObject(4,Ptr1_00,Ptr2,Ptr2);
              iVar5 = iVar5 + -0x58;
              pPVar2 = PCB;
              if (iVar6 == -1) goto LAB_08100445;
            }
            iVar6 = iVar6 + -1;
            iVar5 = iVar5 + -0x58;
            pPVar2 = PCB;
          } while (iVar6 != -1);
        }
      }
LAB_08100445:
      pDVar3 = pPVar2->Data;
      uVar8 = uVar8 + 1;
      if (pDVar3->LayerN + 2U <= uVar8) goto LAB_08100478;
      Ptr1_00 = (void *)((int)Ptr1_00 + 0x5c);
    } while( true );
  }
  goto LAB_08100460;
LAB_08100478:
  Ptr1_00 = (void *)&pDVar3->field_0x4c;
  if (pDVar3->LayerN != -2) {
    uVar8 = 0;
    do {
      if (*(char *)((int)Ptr1_00 + 0x44) != '\0') {
        iVar6 = *(int *)((int)Ptr1_00 + 0x10) + -1;
        if (iVar6 != -1) {
          iVar5 = *(int *)((int)Ptr1_00 + 0x10) * 0x44 + -0x44;
          do {
            while (Ptr2 = (void *)(*(int *)((int)Ptr1_00 + 0x30) + iVar5),
                  (*(uint *)((int)Ptr2 + 0x14) & 0x2004) == 4) {
              iVar6 = iVar6 + -1;
              iVar5 = iVar5 + -0x44;
              RemoveObject(0x4000,Ptr1_00,Ptr2,Ptr2);
              pPVar2 = PCB;
              if (iVar6 == -1) goto LAB_081004f5;
            }
            iVar6 = iVar6 + -1;
            iVar5 = iVar5 + -0x44;
            pPVar2 = PCB;
          } while (iVar6 != -1);
        }
      }
LAB_081004f5:
      pDVar3 = pPVar2->Data;
      uVar8 = uVar8 + 1;
      if (pDVar3->LayerN + 2U <= uVar8) break;
      Ptr1_00 = (void *)((int)Ptr1_00 + 0x5c);
    } while( true );
  }
LAB_08100460:
  if (pPVar2->ViaOn != '\0') {
    pDVar4 = pPVar2->Data;
    if (pDVar4->ViaN != 0) {
      uVar7 = 0;
      uVar8 = pDVar3->ViaN;
      do {
        Ptr1 = pDVar4->Via + uVar7;
        if (((Ptr1->Flags).f & 0x2004) == 4) {
          RemoveObject(1,Ptr1,Ptr1,Ptr1);
          pPVar2 = PCB;
        }
        pDVar4 = pPVar2->Data;
        uVar1 = pDVar4->ViaN;
      } while ((uVar1 != 0) && (uVar7 = (uVar1 + 1 + uVar7) - uVar8, uVar8 = uVar1, uVar7 < uVar1));
    }
  }
  return;
}



void netlist_select_cb(GtkWidget *widget,gpointer data)

{
  Boolean BVar1;
  Cardinal CVar2;
  LibraryEntryTypePtr *entry;
  ConnectionType conn;
  
  if (selected_net != (LibraryMenuType *)0x0) {
    if (selected_net == node_selected_net) {
      node_selected_net = (LibraryMenuType *)0x0;
    }
    InitConnectionLookup();
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    SaveUndoSerialNumber();
    CVar2 = selected_net->EntryN;
    entry = selected_net->Entry;
    if (CVar2 != 0) {
      while( true ) {
        BVar1 = SeekPad((LibraryEntryType *)entry,&conn,'\0');
        if (BVar1 != '\0') {
          RatFindHook(conn.type,conn.ptr1,conn.ptr2,conn.ptr2,'\x01','\x01');
        }
        if (CVar2 == 1) break;
        CVar2 = CVar2 - 1;
        entry = (LibraryEntryTypePtr *)((LibraryEntryType *)entry + 1);
      }
    }
    RestoreUndoSerialNumber();
    SelectConnection((Boolean)data);
    ResetFoundPinsViasAndPads('\0');
    ResetFoundLinesAndPolygons('\0');
    FreeConnectionLookupMemory();
    IncrementUndoSerialNumber();
    ghid_invalidate_all();
  }
  return;
}



void net_selection_changed_cb(GtkTreeSelection *selection,gpointer data)

{
  int iVar1;
  GtkTreeIter iter;
  LibraryMenuType *local_14;
  undefined4 local_10 [2];
  
  if (selection_holdoff != 0) {
    return;
  }
  iVar1 = gtk_tree_selection_get_selected(selection,local_10,&iter);
  if (iVar1 == 0) {
    selected_net = (LibraryMenuType *)0x0;
    return;
  }
  gtk_tree_model_get(local_10[0],&iter,2,&local_14,0xffffffff);
  node_model_update(local_14);
  selected_net = local_14;
  return;
}



void node_selection_changed_cb(GtkTreeSelection *selection,gpointer data)

{
  int iVar1;
  gchar *node_name;
  int iVar2;
  gint gVar3;
  GtkTreeIter iter;
  LibraryEntryType *local_28;
  LibraryMenuType *local_24;
  undefined4 local_20 [4];
  
  if (selection_holdoff != 0) {
    return;
  }
  local_28 = node_get_node_from_name(node_name,&local_24);
  if (local_28 != (LibraryEntryType *)0x0) {
    if (local_24 == node_selected_net) {
      SelectPin((LibraryEntryTypePtr *)local_28,'\x01');
    }
    g_free();
    node_name = (gchar *)0x0;
  }
  iVar2 = gtk_tree_selection_get_selected(selection,local_20,&iter);
  if (iVar2 == 0) {
    if (local_28 == (LibraryEntryType *)0x0) {
      return;
    }
    ghid_invalidate_all();
    return;
  }
  gtk_tree_model_get(local_20[0],&iter,1,&local_28,0xffffffff);
  dup_string((gchar **)0x818e58c,local_28->ListEntry);
  node_selected_net = selected_net;
  SelectPin((LibraryEntryTypePtr *)local_28,'\x01');
  IncrementUndoSerialNumber();
  iVar2 = gport->view_width;
  iVar1 = iVar2 / 0x14;
  if ((Crosshair.X < iVar1 + gport->view_x0) || ((gport->view_x0 + iVar2) - iVar1 < Crosshair.X)) {
    gVar3 = gport->view_height;
  }
  else {
    if (Crosshair.Y < gport->view_y0 + iVar1) {
      gVar3 = gport->view_height;
    }
    else {
      gVar3 = gport->view_height;
      if (Crosshair.Y <= (gVar3 + gport->view_y0) - iVar1) goto LAB_08100888;
    }
  }
  ghid_port_ranges_pan
            ((gdouble)(double)(Crosshair.X - iVar2 / 2),(gdouble)(double)(Crosshair.Y - gVar3 / 2),0
            );
LAB_08100888:
  ghid_screen_update();
  return;
}



void net_selection_double_click_cb
               (GtkTreeView *treeview,GtkTreePath *path,GtkTreeViewColumn *col,gpointer data)

{
  undefined4 uVar1;
  int iVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined1 *puVar5;
  GtkTreeIter iter;
  int local_24;
  byte *local_20 [4];
  
  uVar1 = gtk_tree_view_get_model(treeview);
  iVar2 = gtk_tree_model_get_iter(uVar1,&iter,path);
  if (iVar2 != 0) {
    iVar2 = gtk_tree_model_iter_has_child(uVar1,&iter);
    if (iVar2 == 0) {
      gtk_tree_model_get(uVar1,&iter,0,local_20,0xffffffff);
      if ((*local_20[0] == 0x2a) && (local_20[0][1] == 0)) {
        puVar5 = &DAT_0814741b;
      }
      else {
        puVar5 = &DAT_081548e9;
      }
      uVar3 = gtk_tree_store_get_type();
      uVar3 = g_type_check_instance_cast(uVar1,uVar3);
      gtk_tree_store_set(uVar3,&iter,0,puVar5,0xffffffff);
      gtk_tree_model_get(uVar1,&iter,2,&local_24,0xffffffff);
      uVar4 = (uint)*local_20[0] - 0x2a;
      if (uVar4 == 0) {
        uVar4 = (uint)local_20[0][1];
      }
      *(bool *)(local_24 + 0x18) = uVar4 == 0;
      g_free(local_20[0]);
    }
    else {
      iVar2 = gtk_tree_view_row_expanded(treeview,path);
      if (iVar2 == 0) {
        gtk_tree_view_expand_row(treeview,path,0);
      }
      else {
        gtk_tree_view_collapse_row(treeview,path);
      }
    }
  }
  return;
}



gboolean have_crosshair_attachments(void)

{
  if (Settings.Mode == 5) {
    return 1;
  }
  if (Settings.Mode < 6) {
    if ((Settings.Mode == 2) || (Settings.Mode == 4)) {
      return (uint)(Crosshair.AttachedLine.State != 0);
    }
    if (Settings.Mode == 1) {
      return 1;
    }
  }
  else {
    if (0x67 < Settings.Mode) {
      if (Settings.Mode < 0x6b) {
        return (uint)(Crosshair.AttachedObject.Type != 0);
      }
      if (Settings.Mode == 0x6d) {
        return (uint)(Crosshair.AttachedBox.State != 0);
      }
    }
  }
  return (uint)(Crosshair.AttachedBox.State - 1U < 2);
}



gint ghid_port_window_mouse_scroll_cb(GtkWidget *widget,GdkEventScroll *ev,GHidPort *out)

{
  ModifierKeysState mod_mask;
  int button;
  GdkModifierType local_10 [2];
  
  local_10[0] = ev->state;
  mod_mask = ghid_modifier_keys_state(local_10);
  button = -1;
  if (ev->direction < 4) {
    button = *(int *)(CSWTCH_147 + ev->direction * 4);
  }
  do_mouse_action(button,mod_mask);
  return 1;
}



gboolean ghid_idle_cb(gpointer data)

{
  int iVar1;
  
  if (Settings.Mode == 0) {
    SetMode(0x6e);
  }
  ghid_mode_cursor(Settings.Mode);
  iVar1 = ghidgui->settings_mode;
  if (ghidgui->settings_mode != Settings.Mode) {
    ghid_mode_buttons_update();
    iVar1 = Settings.Mode;
  }
  ghidgui->settings_mode = iVar1;
  ghid_update_toggle_flags();
  return 0;
}



void __regparm3 draw_crosshair(GdkGC *xor_gc,gint x,gint y)

{
  double dVar1;
  double dVar2;
  crosshair_shape prev;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  
  gdk_draw_line(gport->drawing_area->window,xor_gc,x,0,x,gport->height);
  gdk_draw_line(gport->drawing_area->window,xor_gc,0,y,gport->width,y);
  if (prev == Union_Jack_Crosshair_Shape) {
    iVar5 = gport->height;
    iVar6 = gport->width;
    iVar3 = (x + iVar5) - y;
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    iVar7 = x - y;
    if (iVar6 < x - y) {
      iVar7 = iVar6;
    }
    iVar8 = y - x;
    iVar4 = iVar6 + iVar8;
    if (iVar5 < iVar6 + iVar8) {
      iVar4 = iVar5;
    }
    if (iVar8 <= iVar5) {
      iVar5 = iVar8;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    iVar5 = 0;
    if (-1 < iVar7) {
      iVar5 = iVar7;
    }
    if (iVar4 < 0) {
      iVar4 = 0;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar3,iVar4,iVar5,iVar6);
    iVar6 = gport->width;
    iVar3 = gport->height;
    iVar5 = y + x;
    iVar7 = (x - iVar3) + y;
    if (iVar6 < iVar7) {
      iVar7 = iVar6;
    }
    iVar4 = iVar6;
    if (iVar5 <= iVar6) {
      iVar4 = iVar5;
    }
    iVar6 = (x - iVar6) + y;
    if (iVar3 < iVar6) {
      iVar6 = iVar3;
    }
    iVar8 = 0;
    if (-1 < iVar6) {
      iVar8 = iVar6;
    }
    iVar6 = 0;
    if (-1 < iVar4) {
      iVar6 = iVar4;
    }
    if (iVar5 <= iVar3) {
      iVar3 = iVar5;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar7,iVar3,iVar6,iVar8);
  }
  if (prev == Dozen_Crosshair_Shape) {
    dVar2 = (double)x;
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND((double)(iVar6 - y) / 1.73205081 + dVar2);
    dVar1 = (double)y;
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar2 - dVar1 / 1.73205081);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar3 = (int)ROUND((double)(iVar3 - x) * 1.73205081 + dVar1);
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    iVar4 = (int)ROUND(dVar1 - dVar2 * 1.73205081);
    if (iVar4 <= iVar6) {
      iVar6 = iVar4;
    }
    iVar4 = 0;
    if (-1 < iVar6) {
      iVar4 = iVar6;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar6,iVar3,iVar7,iVar4);
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND((double)(iVar6 - y) * 1.73205081 + dVar2);
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar2 - dVar1 * 1.73205081);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar3 = (int)ROUND((double)(iVar3 - x) / 1.73205081 + dVar1);
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    iVar4 = (int)ROUND(dVar1 - 1.73205081 / dVar2);
    if (iVar4 <= iVar6) {
      iVar6 = iVar4;
    }
    iVar4 = 0;
    if (-1 < iVar6) {
      iVar4 = iVar6;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar6,iVar3,iVar7,iVar4);
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND(dVar2 - (double)(iVar6 - y) / 1.73205081);
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar1 / 1.73205081 + dVar2);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar4 = (int)ROUND(dVar2 * 1.73205081 + dVar1);
    if (iVar6 < iVar4) {
      iVar4 = iVar6;
    }
    iVar3 = (int)ROUND(dVar1 - (double)(iVar3 - x) * 1.73205081);
    if (iVar3 <= iVar6) {
      iVar6 = iVar3;
    }
    iVar3 = 0;
    if (-1 < iVar6) {
      iVar3 = iVar6;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar4 < 0) {
      iVar4 = 0;
    }
    iVar6 = 0;
    if (-1 < iVar5) {
      iVar6 = iVar5;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar6,iVar4,iVar7,iVar3);
    iVar6 = gport->height;
    iVar3 = gport->width;
    iVar5 = (int)ROUND(dVar2 - (double)(iVar6 - y) * 1.73205081);
    if (iVar3 < iVar5) {
      iVar5 = iVar3;
    }
    iVar7 = (int)ROUND(dVar1 * 1.73205081 + dVar2);
    if (iVar3 < iVar7) {
      iVar7 = iVar3;
    }
    iVar4 = (int)ROUND(1.73205081 / dVar2 + dVar1);
    if (iVar6 < iVar4) {
      iVar4 = iVar6;
    }
    iVar3 = (int)ROUND(dVar1 - 1.73205081 / (double)(iVar3 - x));
    if (iVar6 < iVar3) {
      iVar3 = iVar6;
    }
    if (iVar3 < 0) {
      iVar3 = 0;
    }
    if (iVar7 < 0) {
      iVar7 = 0;
    }
    if (iVar4 < 0) {
      iVar4 = 0;
    }
    if (iVar5 < 0) {
      iVar5 = 0;
    }
    gdk_draw_line(gport->drawing_area->window,xor_gc,iVar5,iVar4,iVar7,iVar3);
  }
  return;
}



void ghid_show_crosshair(gboolean show)

{
  double dVar1;
  int y;
  gint y_prev;
  gint x_prev;
  GdkColor cross_color;
  GdkGC *xor_gc;
  gboolean gVar2;
  int x;
  gint gVar3;
  
  x = gport->x_crosshair;
  if (((-1 < x) && (ghidgui->creating == 0)) && (gport->has_entered != 0)) {
    if (xor_gc == (GdkGC *)0x0) {
      xor_gc = (GdkGC *)gdk_gc_new((ghid_port.drawing_area)->window);
      gdk_gc_copy(xor_gc,(ghid_port.drawing_area)->style->white_gc);
      gdk_gc_set_function(xor_gc,2);
      ghid_map_color_string(Settings.CrossColor,(GdkColor *)0x818e5c0);
      x = gport->x_crosshair;
    }
    if (ghid_flip_x != 0) {
      x = PCB->MaxWidth - x;
    }
    dVar1 = (double)gport->zoom;
    x = (int)ROUND((double)(x - gport->view_x0) / dVar1);
    if (ghid_flip_y == 0) {
      gVar3 = gport->y_crosshair;
    }
    else {
      gVar3 = PCB->MaxHeight - gport->y_crosshair;
    }
    y = gport->view_y0;
    gdk_gc_set_foreground(xor_gc,(GdkColor *)&ram0x0818e5c0);
    if (((-1 < x_prev) && (draw_crosshair(xor_gc,x_prev,y_prev), ghidgui->auto_pan_on != 0)) &&
       (gVar2 = have_crosshair_attachments(), gVar2 != 0)) {
      gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,0,y_prev + -8,8,0x10);
      gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,gport->width + -8,y_prev + -8,8,0x10);
      gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,x_prev + -8,0,0x10,8);
      gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,x_prev + -8,gport->height + -8,0x10,8)
      ;
    }
    if ((-1 < x) && (show != 0)) {
      y = (int)ROUND((double)(gVar3 - y) / dVar1);
      draw_crosshair(xor_gc,x,y);
      if ((ghidgui->auto_pan_on != 0) && (gVar2 = have_crosshair_attachments(), gVar2 != 0)) {
        y = y + -8;
        gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,0,y,8,0x10);
        gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,gport->width + -8,y,8,0x10);
        gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,x + -8,0,0x10,8);
        gdk_draw_rectangle(gport->drawing_area->window,xor_gc,1,x + -8,gport->height + -8,0x10,8);
      }
    }
  }
  return;
}



gboolean ghid_port_drawing_area_expose_event_cb(GtkWidget *widget,GdkEventExpose *ev,GHidPort *port)

{
  gint gVar1;
  gint gVar2;
  
  ghid_show_crosshair(0);
  gVar1 = (ev->area).y;
  gVar2 = (ev->area).x;
  gdk_draw_drawable(widget->window,port->bg_gc,port->pixmap,gVar2,gVar1,gVar2,gVar1,(ev->area).width
                    ,(ev->area).height);
  ghid_show_crosshair(1);
  return 0;
}



void ghid_screen_update(void)

{
  ghid_show_crosshair(0);
  gdk_draw_drawable(gport->drawing_area->window,gport->bg_gc,gport->pixmap,0,0,0,0,gport->width,
                    gport->height);
  ghid_show_crosshair(1);
  return;
}



gint ghid_port_window_enter_cb(GtkWidget *widget,GdkEventCrossing *ev,GHidPort *out)

{
  GdkCrossingMode GVar1;
  
  GVar1 = ev->mode;
  if ((GVar1 == GDK_CROSSING_NORMAL) || (ev->detail == GDK_NOTIFY_NONLINEAR)) {
    if (ghidgui->command_entry_status_line_active == 0) {
      out->has_entered = 1;
      gtk_widget_grab_focus(out->drawing_area);
      GVar1 = ev->mode;
      ghidgui->in_popup = 0;
    }
    else {
      ghidgui->in_popup = 0;
    }
    if ((GVar1 == GDK_CROSSING_UNGRAB) && (ev->detail == GDK_NOTIFY_NONLINEAR)) {
      ghid_screen_update();
    }
    if (cursor_in_viewport == 0) {
      RestoreCrosshair('\x01');
      cursor_in_viewport = 1;
      return 0;
    }
  }
  return 0;
}



gboolean ghid_note_event_location(GdkEventButton *ev)

{
  GHidPort *pGVar1;
  Boolean BVar2;
  int Y;
  int X;
  bool bVar3;
  int local_14;
  int local_10 [2];
  
  if (ev == (GdkEventButton *)0x0) {
    gdk_window_get_pointer((ghid_port.drawing_area)->window,local_10,&local_14,0);
  }
  else {
    local_10[0] = (int)ROUND((double)ev->x);
    local_14 = (int)ROUND((double)ev->y);
  }
  pGVar1 = gport;
  bVar3 = ghid_flip_y != 0;
  X = (int)ROUND((double)gport->view_x0 + (double)local_10[0] * (double)gport->zoom);
  event_x = local_10[0];
  event_y = local_14;
  gport->view_x = X;
  Y = (int)ROUND((double)pGVar1->view_y0 + (double)local_14 * (double)pGVar1->zoom);
  pGVar1->view_y = Y;
  if (bVar3) {
    Y = PCB->MaxHeight - Y;
  }
  if (ghid_flip_x != 0) {
    X = PCB->MaxWidth - X;
  }
  BVar2 = MoveCrosshairAbsolute(X,Y);
  if ((int)BVar2 != 0) {
    AdjustAttachedObjects();
    RestoreCrosshair('\0');
  }
  ghid_set_cursor_position_labels();
  return (int)BVar2;
}



gboolean ghid_port_button_release_cb(GtkWidget *drawing_area,GdkEventButton *ev,GtkUIManager *ui)

{
  ModifierKeysState MVar1;
  gboolean gVar2;
  GdkModifierType local_10;
  
  ghid_note_event_location(ev);
  local_10 = ev->state;
  MVar1 = ghid_modifier_keys_state(&local_10);
  gVar2 = have_crosshair_attachments();
  if (gVar2 == 0) {
    do_mouse_action(ev->button,MVar1 + 0x80000000);
  }
  else {
    HideCrosshair('\x01');
    do_mouse_action(ev->button,MVar1 + 0x80000000);
    AdjustAttachedObjects();
    ghid_invalidate_all();
    RestoreCrosshair('\x01');
    ghid_screen_update();
  }
  ghid_set_status_line_label();
  g_idle_add(ghid_idle_cb,0);
  return 1;
}



gboolean ghid_port_button_press_cb(GtkWidget *drawing_area,GdkEventButton *ev,GtkUIManager *ui)

{
  ModifierKeysState mod_mask;
  GdkModifierType local_10;
  
  if (ev->type == GDK_BUTTON_PRESS) {
    ghid_note_event_location(ev);
    local_10 = ev->state;
    mod_mask = ghid_modifier_keys_state(&local_10);
    ghid_show_crosshair(0);
    HideCrosshair('\x01');
    do_mouse_action(ev->button,mod_mask);
    ghid_invalidate_all();
    RestoreCrosshair('\x01');
    ghid_set_status_line_label();
    ghid_show_crosshair(1);
    if (gport->panning == 0) {
      g_idle_add(ghid_idle_cb,0);
    }
  }
  return 1;
}



gboolean ghid_port_key_press_cb(GtkWidget *drawing_area,GdkEventKey *kev,GtkUIManager *ui)

{
  guint ksym;
  gboolean gVar1;
  ModifierKeysState MVar2;
  GdkModifierType local_10;
  
  ksym = kev->keyval;
  gVar1 = ghid_is_modifier_key_sym(ksym);
  if (gVar1 != 0) {
    ghid_note_event_location((GdkEventButton *)0x0);
  }
  local_10 = kev->state;
  MVar2 = ghid_modifier_keys_state(&local_10);
  ghid_show_crosshair(0);
  if (ksym == 0xff53) {
    ghid_hotkey_cb(5);
    return 1;
  }
  if ((int)ksym < 0xff54) {
    if (ksym == 0xff09) {
      switch(MVar2) {
      case NONE_PRESSED:
        ghid_hotkey_cb(1);
        return 1;
      case SHIFT_PRESSED:
switchD_08101bc8_caseD_1:
        ghid_hotkey_cb(0x21);
        return 1;
      case CONTROL_PRESSED:
        ghid_hotkey_cb(0x41);
        return 1;
      case SHIFT_CONTROL_PRESSED:
switchD_08101bc8_caseD_3:
        ghid_hotkey_cb(0x61);
        return 1;
      case MOD1_PRESSED:
        ghid_hotkey_cb(0x81);
        return 1;
      case SHIFT_MOD1_PRESSED:
switchD_08101bc8_caseD_5:
        ghid_hotkey_cb(0xa1);
        return 1;
      }
    }
    else {
      if ((int)ksym < 0xff0a) {
        if ((ksym == 0xfd05) || (ksym == 0xfe20)) {
          switch(MVar2) {
          case NONE_PRESSED:
          case SHIFT_PRESSED:
            goto switchD_08101bc8_caseD_1;
          case CONTROL_PRESSED:
          case SHIFT_CONTROL_PRESSED:
            goto switchD_08101bc8_caseD_3;
          case MOD1_PRESSED:
          case SHIFT_MOD1_PRESSED:
            goto switchD_08101bc8_caseD_5;
          }
        }
      }
      else {
        if (ksym == 0xff51) {
          ghid_hotkey_cb(4);
          return 1;
        }
        if (ksym == 0xff52) {
          ghid_hotkey_cb(2);
          return 1;
        }
      }
    }
  }
  else {
    if ((int)ksym < 0xffe5) {
      if (0xffe0 < (int)ksym) {
        return 1;
      }
      if (ksym == 0xff54) {
        ghid_hotkey_cb(3);
        return 1;
      }
    }
    else {
      if ((ksym == 0xffe6) || ((0xffe5 < (int)ksym && (ksym - 0xffe9 < 2)))) {
        return 1;
      }
    }
  }
  return 0;
}



gboolean ghid_port_key_release_cb(GtkWidget *drawing_area,GdkEventKey *kev,GtkUIManager *ui)

{
  gboolean gVar1;
  
  gVar1 = ghid_is_modifier_key_sym(kev->keyval);
  if (gVar1 != 0) {
    ghid_note_event_location((GdkEventButton *)0x0);
  }
  HideCrosshair('\x01');
  AdjustAttachedObjects();
  ghid_invalidate_all();
  RestoreCrosshair('\x01');
  ghid_screen_update();
  g_idle_add(ghid_idle_cb,0);
  return 0;
}



void ghid_get_coords(char *msg,int *x,int *y)

{
  GHidPort *pGVar1;
  gint gVar2;
  
  if (msg != (char *)0x0) {
    if (ghid_port.has_entered != 0) goto LAB_08101cc6;
    ghid_get_user_xy(msg);
  }
  if (ghid_port.has_entered == 0) {
    return;
  }
LAB_08101cc6:
  pGVar1 = gport;
  if (ghid_flip_x == 0) {
    *x = gport->view_x;
  }
  else {
    *x = PCB->MaxWidth - gport->view_x;
  }
  if (ghid_flip_y == 0) {
    gVar2 = pGVar1->view_y;
  }
  else {
    gVar2 = PCB->MaxHeight - pGVar1->view_y;
  }
  *y = gVar2;
  return;
}



gint ghid_port_window_leave_cb(GtkWidget *widget,GdkEventCrossing *ev,GHidPort *out)

{
  int iVar1;
  int iVar2;
  double dVar3;
  GhidGui *pGVar4;
  gboolean gVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int local_24;
  int local_20 [4];
  
  pGVar4 = ghidgui;
  if (ev->mode == GDK_CROSSING_NORMAL) {
    if ((((out->has_entered != 0) && (ghidgui->in_popup == 0)) &&
        (gVar5 = have_crosshair_attachments(), gVar5 != 0)) && (pGVar4->auto_pan_on != 0)) {
      dVar3 = (double)gport->zoom;
      iVar1 = (int)ROUND((double)ghid_port.width * dVar3);
      iVar2 = (int)ROUND((double)ghid_port.height * dVar3);
      if (ghid_flip_x == 0) {
        iVar7 = (int)ROUND((double)gport->view_x0 + dVar3 * 0.00000000);
      }
      else {
        iVar7 = PCB->MaxWidth - (int)ROUND((double)gport->view_x0 + dVar3 * 0.00000000);
      }
      if (ghid_flip_y == 0) {
        iVar6 = (int)ROUND((double)gport->view_y0 + dVar3 * 0.00000000);
      }
      else {
        iVar6 = PCB->MaxHeight - (int)ROUND((double)gport->view_y0 + dVar3 * 0.00000000);
      }
      ghid_get_coords((char *)0x0,local_20,&local_24);
      local_20[0] = local_20[0] - iVar7;
      local_24 = local_24 - iVar6;
      if (ghid_flip_x != 0) {
        local_20[0] = -local_20[0];
      }
      if (ghid_flip_y != 0) {
        local_24 = -local_24;
      }
      iVar6 = iVar2 - local_24;
      iVar8 = iVar1 - local_20[0];
      iVar7 = ghidgui->auto_pan_speed;
      y_pan_speed = iVar7 * 2;
      x_pan_speed = y_pan_speed;
      if (local_20[0] < iVar8) {
        iVar8 = local_20[0];
        x_pan_speed = iVar7 * -2;
      }
      if (local_24 < iVar6) {
        y_pan_speed = iVar7 * -2;
        iVar6 = local_24;
      }
      if (iVar8 < iVar6) {
        if (iVar6 < iVar2 / 3) {
          y_pan_speed = (y_pan_speed * -3 * iVar6) / iVar2 + y_pan_speed;
        }
        else {
          y_pan_speed = 0;
        }
      }
      else {
        if (iVar8 < iVar1 / 3) {
          x_pan_speed = (x_pan_speed * -3 * iVar8) / iVar1 + x_pan_speed;
        }
        else {
          x_pan_speed = 0;
        }
      }
      g_idle_add(ghid_pan_idle_cb,0);
    }
    if (cursor_in_viewport != 0) {
      HideCrosshair('\x01');
      cursor_in_viewport = 0;
    }
    ghid_show_crosshair(0);
    out->has_entered = 0;
    ghid_screen_update();
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x081021ac)
// WARNING: Removing unreachable block (ram,0x081020d0)
// WARNING: Removing unreachable block (ram,0x0810218e)

gboolean ghid_port_ranges_pan(gdouble x,gdouble y,gboolean relative)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  GhidGui *pGVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  undefined4 uVar12;
  undefined8 local_58;
  
  uVar12 = (undefined4)((ulonglong)local_58 >> 0x20);
  uVar7 = gtk_range_get_type();
  uVar8 = g_type_check_instance_cast(ghidgui->h_range,uVar7);
  iVar9 = gtk_range_get_adjustment(uVar8);
  uVar8 = g_type_check_instance_cast(ghidgui->v_range,uVar7,uVar12);
  iVar10 = gtk_range_get_adjustment(uVar8);
  pGVar6 = ghidgui;
  dVar1 = *(double *)(iVar9 + 0x20);
  dVar2 = *(double *)(iVar10 + 0x20);
  if (relative != 0) {
    x = (gdouble)(dVar1 + (double)x);
    y = (gdouble)(dVar2 + (double)y);
  }
  dVar3 = *(double *)(iVar9 + 0x10);
  if (*(double *)(iVar9 + 0x10) <= (double)x) {
    dVar3 = (double)x;
  }
  dVar4 = *(double *)(iVar9 + 0x18) - *(double *)(iVar9 + 0x38);
  if (dVar4 <= dVar3 || dVar3 != dVar4) {
    dVar3 = dVar4;
  }
  dVar4 = *(double *)(iVar10 + 0x10);
  if (*(double *)(iVar10 + 0x10) <= (double)y) {
    dVar4 = (double)y;
  }
  dVar5 = *(double *)(iVar10 + 0x18) - *(double *)(iVar10 + 0x38);
  if (dVar5 <= dVar4 || dVar4 != dVar5) {
    dVar4 = dVar5;
  }
  if (dVar1 != dVar3) {
    if (dVar2 != dVar4) {
      ghidgui->combine_adjustments = 1;
    }
    uVar8 = g_type_check_instance_cast(pGVar6->h_range,uVar7,uVar12);
    uVar12 = (int)((ulonglong)dVar3 >> 0x20);
    gtk_range_set_value(uVar8,dVar3);
  }
  if (dVar2 != dVar4) {
    uVar12 = g_type_check_instance_cast(ghidgui->v_range,uVar7,uVar12);
    gtk_range_set_value(uVar12,dVar4);
  }
  ghid_note_event_location((GdkEventButton *)0x0);
  uVar11 = 1;
  if (dVar1 == dVar3) {
    uVar11 = (uint)(dVar2 != dVar4);
  }
  return uVar11;
}



gboolean ghid_pan_idle_cb(gpointer data)

{
  gboolean gVar1;
  
  if (gport->has_entered != 0) {
    return 0;
  }
  gVar1 = ghid_port_ranges_pan
                    ((gdouble)((double)x_pan_speed * (double)gport->zoom),
                     (gdouble)((double)y_pan_speed * (double)gport->zoom),1);
  return gVar1;
}



gint ghid_port_window_motion_cb(GtkWidget *widget,GdkEventButton *ev,GHidPort *out)

{
  gint y_prev;
  gint x_prev;
  int iVar1;
  gboolean gVar2;
  
  if (out->panning == 0) {
    y_prev = -1;
    x_prev = -1;
    gVar2 = ghid_note_event_location(ev);
    ghid_show_crosshair(1);
    if ((gVar2 != 0) && (gVar2 = have_crosshair_attachments(), gVar2 != 0)) {
      ghid_draw_area_update(gport,(GdkRectangle *)0x0);
    }
  }
  else {
    iVar1 = gtk_events_pending();
    if (iVar1 == 0) {
      if (0 < x_prev) {
        ghid_port_ranges_pan
                  ((gdouble)(((double)x_prev - (double)ev->x) * (double)gport->zoom),
                   (gdouble)(((double)y_prev - (double)ev->y) * (double)gport->zoom),1);
      }
    }
  }
  return 0;
}



void ghid_port_ranges_changed(void)

{
  GhidGui *pGVar1;
  GHidPort *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  
  if (ghidgui->combine_adjustments == 0) {
    HideCrosshair('\0');
    pGVar1 = ghidgui;
    if (ghidgui->combine_adjustments == 0) {
      ghidgui->need_restore_crosshair = 1;
      uVar3 = gtk_range_get_type();
      uVar4 = g_type_check_instance_cast(pGVar1->h_range,uVar3);
      iVar5 = gtk_range_get_adjustment(uVar4);
      uVar3 = g_type_check_instance_cast(ghidgui->v_range,uVar3);
      iVar6 = gtk_range_get_adjustment(uVar3);
      pGVar2 = gport;
      gport->view_x0 = (int)ROUND(*(double *)(iVar5 + 0x20));
      pGVar2->view_y0 = (int)ROUND(*(double *)(iVar6 + 0x20));
      ghid_invalidate_all();
      return;
    }
  }
  ghidgui->combine_adjustments = 0;
  return;
}



void ghid_port_ranges_scale(gboolean emit_changed)

{
  int *piVar1;
  double *pdVar2;
  int iVar3;
  int iVar4;
  double dVar5;
  PCBTypePtr pPVar6;
  GHidPort *pGVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  int iVar10;
  
  pGVar7 = gport;
  pPVar6 = PCB;
  iVar10 = (int)ROUND((double)gport->width * (double)gport->zoom);
  piVar1 = &gport->height;
  pdVar2 = (double *)&gport->zoom;
  gport->view_width = iVar10;
  iVar3 = (int)ROUND((double)*piVar1 * *pdVar2);
  pGVar7->view_height = iVar3;
  iVar4 = pPVar6->MaxWidth;
  if (iVar4 <= iVar10) {
    pGVar7->view_width = iVar4;
  }
  iVar10 = pPVar6->MaxHeight;
  if (iVar10 <= iVar3) {
    pGVar7->view_height = iVar10;
  }
  uVar8 = gtk_range_get_type();
  uVar9 = g_type_check_instance_cast(ghidgui->h_range,uVar8);
  iVar10 = gtk_range_get_adjustment(uVar9);
  dVar5 = (double)gport->view_width;
  *(double *)(iVar10 + 0x38) = dVar5;
  pPVar6 = PCB;
  *(double *)(iVar10 + 0x30) = dVar5 / 10.00000000;
  *(double *)(iVar10 + 0x28) = dVar5 / 100.00000000;
  *(double *)(iVar10 + 0x18) = (double)pPVar6->MaxWidth;
  if (emit_changed != 0) {
    uVar9 = gtk_object_get_type();
    uVar9 = g_type_check_instance_cast(iVar10,uVar9);
    gtk_signal_emit_by_name(uVar9,0x8155a12);
  }
  uVar8 = g_type_check_instance_cast(ghidgui->v_range,uVar8);
  iVar10 = gtk_range_get_adjustment(uVar8);
  dVar5 = (double)gport->view_height;
  *(double *)(iVar10 + 0x38) = dVar5;
  pPVar6 = PCB;
  *(double *)(iVar10 + 0x30) = dVar5 / 10.00000000;
  *(double *)(iVar10 + 0x28) = dVar5 / 100.00000000;
  *(double *)(iVar10 + 0x18) = (double)pPVar6->MaxHeight;
  if (emit_changed != 0) {
    uVar8 = gtk_object_get_type();
    uVar8 = g_type_check_instance_cast(iVar10,uVar8);
    gtk_signal_emit_by_name(uVar8,0x8155a12);
  }
  return;
}



gboolean ghid_port_drawing_area_configure_event_cb
                   (GtkWidget *widget,GdkEventConfigure *ev,GHidPort *out)

{
  gboolean first_time_done;
  gint gVar1;
  GdkPixmap *pGVar2;
  GdkColormap *pGVar3;
  GdkGC *pGVar4;
  int iVar5;
  gint gVar6;
  GHidPort *pGVar7;
  bool bVar8;
  
  HideCrosshair('\x01');
  pGVar7 = gport;
  gVar1 = ev->width;
  pGVar2 = gport->pixmap;
  gport->width = gVar1;
  gVar6 = ev->height;
  pGVar7->height = gVar6;
  if (pGVar2 != (GdkPixmap *)0x0) {
    g_object_unref(pGVar2);
    gVar6 = gport->height;
    gVar1 = gport->width;
    pGVar7 = gport;
  }
  pGVar2 = (GdkPixmap *)gdk_pixmap_new(widget->window,gVar1,gVar6,0xffffffff);
  bVar8 = first_time_done == 0;
  pGVar7->pixmap = pGVar2;
  pGVar7 = gport;
  *(GdkPixmap **)&gport->drawable = gport->pixmap;
  if (bVar8) {
    pGVar3 = (GdkColormap *)gtk_widget_get_colormap(pGVar7->top_window);
    pGVar7->colormap = pGVar3;
    pGVar7 = gport;
    pGVar4 = (GdkGC *)gdk_gc_new(gport->drawable);
    pGVar7->bg_gc = pGVar4;
    iVar5 = gdk_color_parse(Settings.BackgroundColor,&gport->bg_color);
    if (iVar5 == 0) {
      gdk_color_white(gport->colormap,&gport->bg_color);
    }
    else {
      gdk_color_alloc(gport->colormap,&gport->bg_color);
    }
    gdk_gc_set_foreground(gport->bg_gc,&gport->bg_color);
    pGVar7 = gport;
    pGVar4 = (GdkGC *)gdk_gc_new(gport->drawable);
    pGVar7->offlimits_gc = pGVar4;
    iVar5 = gdk_color_parse(Settings.OffLimitColor,&gport->offlimits_color);
    if (iVar5 == 0) {
      gdk_color_white(gport->colormap,&gport->offlimits_color);
    }
    else {
      gdk_color_alloc(gport->colormap,&gport->offlimits_color);
    }
    gdk_gc_set_foreground(gport->offlimits_gc,&gport->offlimits_color);
    first_time_done = 1;
    PCBChanged(0,(char **)0x0,0,0);
    pGVar7 = gport;
  }
  if (pGVar7->mask != (GdkPixmap *)0x0) {
    g_object_unref(pGVar7->mask);
    pGVar7 = gport;
    pGVar2 = (GdkPixmap *)gdk_pixmap_new(0,gport->width,gport->height,1);
    pGVar7->mask = pGVar2;
  }
  ghid_port_ranges_scale(0);
  ghid_invalidate_all();
  RestoreCrosshair('\x01');
  return 0;
}



// WARNING: Removing unreachable block (ram,0x081027f6)

void ghid_port_ranges_zoom(gdouble zoom)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  double dVar8;
  GhidGui *pGVar9;
  GHidPort *pGVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  int iVar14;
  int iVar15;
  
  dVar8 = (double)PCB->MaxWidth / (double)gport->width;
  dVar7 = (double)PCB->MaxHeight / (double)gport->height;
  if (((double)zoom <= dVar8) || ((double)zoom <= dVar7)) {
    if (((double)zoom == 0.00000000) && (zoom = (gdouble)dVar8, dVar8 <= dVar7)) {
      zoom = (gdouble)dVar7;
    }
  }
  else {
    zoom = (gdouble)dVar8;
    if (dVar8 <= dVar7) {
      zoom = (gdouble)dVar7;
    }
  }
  iVar14 = gport->view_x;
  iVar4 = gport->view_x0;
  iVar5 = gport->view_y;
  iVar15 = gport->view_width;
  iVar6 = gport->view_y0;
  iVar3 = gport->view_height;
  gport->zoom = zoom;
  pixel_slop = (int)ROUND((double)zoom);
  ghid_port_ranges_scale(0);
  pGVar10 = gport;
  iVar15 = (int)ROUND((double)gport->view_x -
                      ((double)(iVar14 - iVar4) / (double)iVar15) * (double)gport->view_width);
  piVar2 = &gport->view_y;
  piVar1 = &gport->view_height;
  if (iVar15 < 0) {
    iVar15 = 0;
  }
  gport->view_x0 = iVar15;
  pGVar9 = ghidgui;
  iVar3 = (int)ROUND((double)*piVar2 - ((double)(iVar5 - iVar6) / (double)iVar3) * (double)*piVar1);
  iVar14 = 0;
  if (-1 < iVar3) {
    iVar14 = iVar3;
  }
  pGVar10->view_y0 = iVar14;
  pGVar9->adjustment_changed_holdoff = 1;
  uVar11 = gtk_range_get_type();
  uVar12 = g_type_check_instance_cast(pGVar9->h_range,uVar11);
  uVar13 = (undefined4)((ulonglong)(double)iVar15 >> 0x20);
  gtk_range_set_value(uVar12,(double)iVar15);
  iVar15 = gport->view_y0;
  uVar13 = g_type_check_instance_cast(ghidgui->v_range,uVar11,uVar13);
  gtk_range_set_value(uVar13,(double)iVar15);
  ghidgui->adjustment_changed_holdoff = 0;
  ghid_port_ranges_changed();
  return;
}



void ghid_pinout_preview_get_natural_size(GhidPinoutPreview *pinout,int *width,int *height)

{
  *width = pinout->w_pixels;
  *height = pinout->h_pixels;
  return;
}



GType ghid_pinout_preview_get_type(void)

{
  GType ghid_pinout_preview_type;
  undefined4 uVar1;
  GType GVar2;
  GTypeInfo ghid_pinout_preview_info;
  
  if (ghid_pinout_preview_type != 0) {
    return ghid_pinout_preview_type;
  }
  uVar1 = gtk_drawing_area_get_type();
  GVar2 = g_type_register_static(uVar1,0x8155550,&ghid_pinout_preview_info,0);
  return GVar2;
}



GtkWidget * ghid_pinout_preview_new(ElementType *element)

{
  GType GVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  
  GVar1 = ghid_pinout_preview_get_type();
  uVar2 = g_object_new(GVar1,"element-data",element,0);
  uVar3 = gtk_widget_get_type();
  pGVar4 = (GtkWidget *)g_type_check_instance_cast(uVar2,uVar3);
  return pGVar4;
}



void ghid_pinout_preview_class_init(GhidPinoutPreviewClass *klass)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  
  iVar1 = g_type_check_class_cast(klass,0x50);
  uVar2 = gtk_widget_get_type();
  iVar3 = g_type_check_class_cast(klass,uVar2);
  *(undefined4 *)(iVar1 + 0x18) = 0x81030c0;
  *(undefined4 *)(iVar1 + 0xc) = 0x8102fa0;
  *(undefined4 *)(iVar1 + 0x10) = 0x8102cb0;
  *(undefined4 *)(iVar3 + 200) = 0x8102ac0;
  ghid_pinout_preview_parent_class = (GObjectClass *)g_type_class_peek_parent(klass);
  uVar2 = g_param_spec_pointer("element-data",&DAT_0814741b,&DAT_0814741b,2);
  g_object_class_install_property(iVar1,1,uVar2);
  return;
}



gboolean ghid_pinout_preview_expose(GtkWidget *widget,GdkEventExpose *event)

{
  int iVar1;
  int iVar2;
  gdouble gVar3;
  gint gVar4;
  gint gVar5;
  gint gVar6;
  gint gVar7;
  gint gVar8;
  gint gVar9;
  GdkDrawable *pGVar10;
  int iVar11;
  int iVar12;
  GdkDrawable *pGVar13;
  double dVar14;
  double dVar15;
  GHidPort *pGVar16;
  GType GVar17;
  int iVar18;
  int local_24;
  int local_20 [4];
  
  GVar17 = ghid_pinout_preview_get_type();
  iVar18 = g_type_check_instance_cast(widget,GVar17);
  gVar4 = gport->width;
  gVar5 = gport->height;
  gVar3 = gport->zoom;
  gVar6 = gport->view_x0;
  gVar7 = gport->view_y0;
  gVar8 = gport->view_width;
  gVar9 = gport->view_height;
  pGVar10 = gport->drawable;
  gdk_window_get_geometry(widget->window,0,0,local_20,&local_24,0);
  pGVar16 = gport;
  iVar11 = *(int *)(iVar18 + 0x174);
  iVar12 = *(int *)(iVar18 + 0x178);
  dVar15 = (double)iVar11 / (double)local_20[0];
  dVar14 = (double)iVar12 / (double)local_24;
  if (dVar14 < dVar15) {
    *(double *)&gport->zoom = dVar15;
  }
  else {
    *(double *)&gport->zoom = dVar14;
  }
  pGVar13 = (GdkDrawable *)widget->window;
  pGVar16->width = local_20[0];
  pGVar16->height = local_24;
  pGVar16->drawable = pGVar13;
  iVar1 = (int)ROUND((double)local_20[0] * (double)pGVar16->zoom);
  pGVar16->view_width = iVar1;
  iVar2 = (int)ROUND((double)local_24 * (double)pGVar16->zoom);
  pGVar16->view_x0 = (iVar11 - iVar1) / 2;
  pGVar16->view_height = iVar2;
  pGVar16->view_y0 = (iVar12 - iVar2) / 2;
  gdk_draw_rectangle(pGVar13,pGVar16->bg_gc,1,0,0,local_20[0],local_24);
  hid_expose_callback(&ghid_hid,(BoxType *)0x0,(void *)(iVar18 + 0x40));
  pGVar16 = gport;
  gport->drawable = pGVar10;
  pGVar16->height = gVar5;
  pGVar16->view_x0 = gVar6;
  pGVar16->width = gVar4;
  pGVar16->zoom = gVar3;
  pGVar16->view_width = gVar8;
  pGVar16->view_height = gVar9;
  pGVar16->view_y0 = gVar7;
  return 0;
}



void ghid_pinout_preview_get_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = g_type_name(((object->g_type_instance).g_class)->g_type);
  uVar2 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
  g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
        "../../src/hid/gtk/gui-pinout-preview.c:293","property",property_id,pspec->name,uVar2,uVar1)
  ;
  return;
}



gboolean __regparm3 pinout_zoom_fit(GhidPinoutPreview *pinout,gint zoom)

{
  int iVar1;
  int iVar2;
  float fVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  
  *(float *)&pinout->zoom = (float)zoom;
  dVar7 = exp((double)((float)zoom * 0.34657356));
  iVar5 = (pinout->element).BoundingBox.X2;
  iVar1 = (pinout->element).BoundingBox.X1;
  pinout->x_max = Settings.PinoutOffsetX + iVar5;
  iVar2 = (pinout->element).BoundingBox.Y2;
  fVar3 = 1.00000000 / ((float)dVar7 * 100.00000000);
  iVar6 = (pinout->element).BoundingBox.Y1;
  pinout->y_max = Settings.PinoutOffsetY + iVar2;
  *(float *)&pinout->scale = fVar3;
  iVar5 = (int)ROUND((float)(iVar5 - iVar1) * fVar3);
  pinout->w_pixels = iVar5;
  iVar1 = (int)ROUND((float)(iVar2 - iVar6) * fVar3);
  pinout->h_pixels = iVar1;
  iVar2 = Output.Width * 3;
  iVar6 = iVar2 + 3;
  if (-1 < iVar2) {
    iVar6 = iVar2;
  }
  uVar4 = 0;
  if (iVar5 <= iVar6 >> 2) {
    iVar5 = Output.Height * 3;
    if (iVar5 < 0) {
      iVar5 = iVar5 + 3;
    }
    uVar4 = (uint)(iVar1 <= iVar5 >> 2);
  }
  return uVar4;
}



void __regparm3 pinout_set_data(GhidPinoutPreview *pinout,ElementType *element)

{
  FlagType *pFVar1;
  uint uVar2;
  Cardinal CVar3;
  PinTypePtr *pPVar4;
  PadTypePtr *pPVar5;
  gboolean gVar6;
  int iVar7;
  uint uVar8;
  BDimension *pBVar9;
  
  if (element != (ElementType *)0x0) {
    CopyElementLowLevel((DataTypePtr *)0x0,(ElementTypePtr *)&pinout->element,
                        (ElementTypePtr *)element,'\0',0,0);
    uVar2 = (pinout->element).PinN;
    if (uVar2 != 0) {
      pPVar4 = (pinout->element).Pin;
      uVar8 = 1;
      pFVar1 = &pPVar4->Flags;
      pFVar1->f = pFVar1->f | 0x20;
      while (uVar8 < uVar2) {
        pPVar4[1].Flags.f = pPVar4[1].Flags.f | 0x20;
        uVar8 = uVar8 + 1;
        pPVar4 = pPVar4 + 1;
      }
    }
    uVar2 = (pinout->element).PadN;
    if (uVar2 != 0) {
      pPVar5 = (pinout->element).Pad;
      uVar8 = 1;
      pFVar1 = &pPVar5->Flags;
      pFVar1->f = pFVar1->f | 0x20;
      while (uVar8 < uVar2) {
        pPVar5[1].Flags.f = pPVar5[1].Flags.f | 0x20;
        uVar8 = uVar8 + 1;
        pPVar5 = pPVar5 + 1;
      }
    }
    MoveElementLowLevel((DataTypePtr *)0x0,(ElementTypePtr *)&pinout->element,
                        Settings.PinoutOffsetX - (pinout->element).BoundingBox.X1,
                        Settings.PinoutOffsetY - (pinout->element).BoundingBox.Y1);
    gVar6 = pinout_zoom_fit(pinout,2);
    if (gVar6 == 0) {
      pinout_zoom_fit(pinout,3);
    }
    CVar3 = (pinout->element).LineN;
    iVar7 = CVar3 - 1;
    if (iVar7 != -1) {
      pBVar9 = &(pinout->element).Line[CVar3 - 1].Thickness;
      do {
        iVar7 = iVar7 + -1;
        *pBVar9 = 0;
        pBVar9 = pBVar9 + -0x16;
      } while (iVar7 != -1);
    }
    CVar3 = (pinout->element).ArcN;
    iVar7 = CVar3 - 1;
    if (iVar7 != -1) {
      pBVar9 = &(pinout->element).Arc[CVar3 - 1].Thickness;
      do {
        iVar7 = iVar7 + -1;
        *pBVar9 = 1;
        pBVar9 = pBVar9 + -0x11;
      } while (iVar7 != -1);
    }
    return;
  }
  FreeElementMemory((ElementTypePtr *)&pinout->element);
  pinout->w_pixels = 0;
  pinout->h_pixels = 0;
  return;
}



void ghid_pinout_preview_set_property
               (GObject *object,guint property_id,GValue *value,GParamSpec *pspec)

{
  GType GVar1;
  GhidPinoutPreview *pinout;
  undefined4 uVar2;
  undefined4 uVar3;
  ElementType *element;
  undefined4 uVar4;
  int iVar5;
  
  GVar1 = ghid_pinout_preview_get_type();
  pinout = (GhidPinoutPreview *)g_type_check_instance_cast(object,GVar1);
  if (property_id == 1) {
    element = (ElementType *)g_value_get_pointer(value);
    pinout_set_data(pinout,element);
    uVar2 = gtk_object_get_type();
    uVar3 = gtk_widget_get_type();
    uVar4 = g_type_check_instance_cast(pinout,uVar3);
    iVar5 = g_type_check_instance_cast(uVar4,uVar2);
    if ((*(byte *)(iVar5 + 0xc) & 0x40) != 0) {
      g_type_check_instance_cast(pinout,uVar3);
      gdk_window_invalidate_rect();
      return;
    }
  }
  else {
    uVar2 = g_type_name(((object->g_type_instance).g_class)->g_type);
    uVar3 = g_type_name(((pspec->g_type_instance).g_class)->g_type);
    g_log(0,0x10,"%s: invalid %s id %u for \"%s\" of type `%s\' in `%s\'",
          "../../src/hid/gtk/gui-pinout-preview.c:268","property",property_id,pspec->name,uVar3,
          uVar2);
  }
  return;
}



void ghid_pinout_preview_finalize(GObject *object)

{
  GType GVar1;
  GhidPinoutPreview *pinout;
  int iVar2;
  
  GVar1 = ghid_pinout_preview_get_type();
  pinout = (GhidPinoutPreview *)g_type_check_instance_cast(object,GVar1);
  pinout_set_data(pinout,(ElementType *)0x0);
  iVar2 = g_type_check_class_cast(ghid_pinout_preview_parent_class,0x50);
                    // WARNING: Could not recover jumptable at 0x08103102. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(iVar2 + 0x18))();
  return;
}



void ghid_pinout_window_show(GHidPort *out,ElementType *element)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  GtkWidget *pGVar8;
  GType GVar9;
  GhidPinoutPreview *pinout;
  char *pcVar10;
  char *pcVar11;
  char *pcVar12;
  int local_24;
  int local_20 [4];
  
  if (element != (ElementType *)0x0) {
    pcVar11 = element->Name[2].TextString;
    if ((pcVar11 == (char *)0x0) || (*pcVar11 == '\0')) {
      pcVar12 = element->Name[1].TextString;
      pcVar11 = "(unknown)";
    }
    else {
      pcVar12 = element->Name[1].TextString;
    }
    if ((pcVar12 == (char *)0x0) || (*pcVar12 == '\0')) {
      pcVar12 = "(unknown)";
    }
    pcVar10 = element->Name[0].TextString;
    if ((pcVar10 == (char *)0x0) || (*pcVar10 == '\0')) {
      pcVar10 = "(unknown)";
    }
    uVar1 = g_strdup_printf(0x81555f0,pcVar10,pcVar12,pcVar11);
    uVar2 = gtk_window_new(0);
    uVar3 = gtk_window_get_type();
    uVar4 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_window_set_title(uVar4,uVar1);
    g_free(uVar1);
    uVar1 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_window_set_wmclass(uVar1,"PCB_Pinout",&DAT_08154932);
    uVar1 = gtk_container_get_type();
    uVar4 = g_type_check_instance_cast(uVar2,uVar1);
    gtk_container_set_border_width(uVar4,4);
    uVar4 = gtk_vbox_new(0,0);
    uVar5 = g_type_check_instance_cast(uVar2,uVar1);
    gtk_container_add(uVar5,uVar4);
    uVar5 = gtk_viewport_new(0,0);
    uVar6 = gtk_viewport_get_type();
    uVar6 = g_type_check_instance_cast(uVar5,uVar6);
    gtk_viewport_set_shadow_type(uVar6,1);
    uVar6 = gtk_box_get_type();
    uVar7 = g_type_check_instance_cast(uVar4,uVar6);
    gtk_box_pack_start(uVar7,uVar5,1,1,0);
    pGVar8 = ghid_pinout_preview_new(element);
    uVar1 = g_type_check_instance_cast(uVar5,uVar1);
    gtk_container_add(uVar1,pGVar8);
    GVar9 = ghid_pinout_preview_get_type();
    pinout = (GhidPinoutPreview *)g_type_check_instance_cast(pGVar8,GVar9);
    ghid_pinout_preview_get_natural_size(pinout,local_20,&local_24);
    uVar1 = g_type_check_instance_cast(uVar2,uVar3);
    gtk_window_set_default_size(uVar1,local_20[0] + 0x32,local_24 + 0x32);
    uVar1 = gtk_hbutton_box_new();
    uVar3 = gtk_button_box_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_button_box_set_layout(uVar3,4);
    uVar3 = g_type_check_instance_cast(uVar4,uVar6);
    gtk_box_pack_start(uVar3,uVar1,0,0,0);
    uVar3 = gtk_button_new_from_stock("gtk-close");
    uVar4 = g_type_check_instance_cast(uVar3,0x50);
    g_signal_connect_data(uVar4,"clicked",pinout_close_cb,uVar2,0,0);
    uVar1 = g_type_check_instance_cast(uVar1,uVar6);
    gtk_box_pack_start(uVar1,uVar3,1,1,0);
    gtk_widget_realize(uVar2);
    if (Settings.AutoPlace != '\0') {
      gtk_widget_set_uposition(uVar2,10,10);
    }
    gtk_widget_show_all(uVar2);
    return;
  }
  return;
}



void pinout_close_cb(GtkWidget *widget,GtkWidget *top_window)

{
  gtk_widget_destroy();
  return;
}



GdkPixmap * ghid_render_pixmap(int cx,int cy,double zoom,int width,int height,int depth)

{
  gdouble gVar1;
  double dVar2;
  GdkDrawable *pGVar3;
  gint gVar4;
  gint gVar5;
  gint gVar6;
  gint gVar7;
  gint gVar8;
  gint gVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  GHidPort *pGVar14;
  GdkDrawable *pGVar15;
  int iVar16;
  int iVar17;
  int iVar18;
  int local_48;
  int local_44;
  int local_3c;
  BoxType region;
  
  pGVar3 = gport->drawable;
  gVar4 = gport->height;
  gVar5 = gport->view_x0;
  gVar1 = gport->zoom;
  gVar6 = gport->width;
  gVar7 = gport->view_width;
  gVar8 = gport->view_y0;
  gVar9 = gport->view_height;
  pGVar15 = (GdkDrawable *)gdk_pixmap_new(0,width,height,depth);
  pGVar14 = gport;
  *(double *)&gport->zoom = zoom;
  pGVar14->drawable = pGVar15;
  iVar16 = ghid_flip_x;
  pGVar14->width = width;
  pGVar14->height = height;
  pGVar14->view_width = (int)ROUND((double)width * zoom);
  pGVar14->view_height = (int)ROUND((double)height * zoom);
  iVar17 = ghid_flip_y;
  if (iVar16 != 0) {
    cx = PCB->MaxWidth - cx;
  }
  pGVar14->view_x0 = cx - (int)ROUND((double)height * zoom) / 2;
  if (iVar17 != 0) {
    cy = PCB->MaxHeight - cy;
  }
  pGVar14->view_y0 = cy - (int)ROUND((double)width * zoom) / 2;
  gdk_draw_rectangle(pGVar15,pGVar14->bg_gc,1,0,0,width,height);
  dVar2 = (double)gport->zoom;
  dVar13 = (double)gport->view_x0;
  dVar12 = dVar2 * 0.00000000 + dVar13;
  region.X2 = (LocationType)ROUND(dVar12);
  if (ghid_flip_x == 0) {
    dVar13 = (double)(gport->width + 1) * dVar2 + dVar13;
    iVar16 = (int)ROUND(dVar13);
    iVar17 = region.X2;
    iVar18 = iVar16;
  }
  else {
    dVar13 = (double)(gport->width + 1) * dVar2 + dVar13;
    iVar16 = (int)ROUND((double)PCB->MaxWidth - dVar13);
    iVar17 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    iVar18 = (int)ROUND(dVar13);
  }
  if (iVar17 < iVar16) {
    local_48 = region.X2;
    if (ghid_flip_x != 0) {
      local_48 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    }
  }
  else {
    local_48 = iVar18;
    if (ghid_flip_x != 0) {
      local_48 = (int)ROUND((double)PCB->MaxWidth - dVar13);
    }
  }
  dVar10 = (double)gport->view_y0;
  dVar11 = dVar2 * 0.00000000 + dVar10;
  region.Y2 = (LocationType)ROUND(dVar11);
  if (ghid_flip_y == 0) {
    dVar10 = (double)(gport->height + 1) * dVar2 + dVar10;
    iVar16 = (int)ROUND(dVar10);
    iVar17 = region.Y2;
    local_3c = iVar16;
  }
  else {
    dVar10 = (double)(gport->height + 1) * dVar2 + dVar10;
    iVar16 = (int)ROUND((double)PCB->MaxHeight - dVar10);
    iVar17 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    local_3c = (int)ROUND(dVar10);
  }
  if (iVar17 < iVar16) {
    region.Y1 = region.Y2;
    if (ghid_flip_y != 0) {
      region.Y1 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    }
  }
  else {
    region.Y1 = local_3c;
    if (ghid_flip_y != 0) {
      region.Y1 = (LocationType)ROUND((double)PCB->MaxHeight - dVar10);
    }
  }
  iVar16 = iVar18;
  local_44 = region.X2;
  if (ghid_flip_x != 0) {
    local_44 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    iVar16 = (int)ROUND((double)PCB->MaxWidth - dVar13);
  }
  if (iVar16 < local_44) {
    if (ghid_flip_x != 0) {
      region.X2 = (int)ROUND((double)PCB->MaxWidth - dVar12);
    }
  }
  else {
    region.X2 = iVar18;
    if (ghid_flip_x != 0) {
      region.X2 = (int)ROUND((double)PCB->MaxWidth - dVar13);
    }
  }
  iVar17 = local_3c;
  iVar16 = region.Y2;
  if (ghid_flip_y != 0) {
    iVar16 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    iVar17 = (int)ROUND((double)PCB->MaxHeight - dVar10);
  }
  if (iVar17 < iVar16) {
    if (ghid_flip_y != 0) {
      region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar11);
    }
  }
  else {
    region.Y2 = local_3c;
    if (ghid_flip_y != 0) {
      region.Y2 = (int)ROUND((double)PCB->MaxHeight - dVar10);
    }
  }
  region.X1 = local_48;
  hid_expose_callback(&ghid_hid,&region,(void *)0x0);
  pGVar14 = gport;
  gport->drawable = pGVar3;
  pGVar14->width = gVar6;
  pGVar14->height = gVar4;
  pGVar14->view_x0 = gVar5;
  pGVar14->zoom = gVar1;
  pGVar14->view_y0 = gVar8;
  pGVar14->view_width = gVar7;
  pGVar14->view_height = gVar9;
  return (GdkPixmap *)pGVar15;
}



gint top_window_configure_event_cb(GtkWidget *widget,GdkEventConfigure *ev,GHidPort *port)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  GhidGui *pGVar5;
  
  pGVar5 = ghidgui;
  iVar1 = (widget->allocation).width;
  iVar2 = ghidgui->top_window_width;
  iVar3 = (widget->allocation).height;
  iVar4 = ghidgui->top_window_height;
  ghidgui->top_window_width = iVar1;
  pGVar5->top_window_height = iVar3;
  if ((iVar4 != iVar3) || (iVar2 != iVar1)) {
    pGVar5->config_modified = 1;
  }
  return 0;
}



void absolute_label_size_req_cb(GtkWidget *widget,GtkRequisition *req,gpointer data)

{
  gint w;
  
  if (req->width <= w) {
    req->width = w;
    return;
  }
  return;
}



void relative_label_size_req_cb(GtkWidget *widget,GtkRequisition *req,gpointer data)

{
  gint w;
  
  if (req->width <= w) {
    req->width = w;
    return;
  }
  return;
}



int EditLayerGroups(int argc,char **argv,int x,int y)

{
  if (argc == 0) {
    hid_actionl("DoWindows",0x815393e,0);
    return 0;
  }
  Message("Syntax error.  Usage:\n%s\n","EditLayerGroups()\n");
  return 1;
}



int AdjustStyle(int argc,char **argv,int x,int y)

{
  if (argc < 2) {
    if (route_style_index < 4) {
      ghid_route_style_dialog(route_style_index,(RouteStyleType *)0x0);
    }
    else {
      ghid_route_style_dialog(route_style_index,&route_style_button[route_style_index].route_style);
    }
    return 0;
  }
  Message("Syntax error.  Usage:\n%s\n","AdjustStyle()\n");
  return 1;
}



void ghid_mode_buttons_update(void)

{
  undefined4 uVar1;
  ModeButton *pMVar2;
  
  pMVar2 = mode_buttons;
  do {
    if (pMVar2->mode == Settings.Mode) {
      uVar1 = gtk_toggle_button_get_type();
      uVar1 = g_type_check_instance_cast(pMVar2->button,uVar1);
      gtk_toggle_button_set_active(uVar1,1);
      return;
    }
    pMVar2 = pMVar2 + 1;
  } while (pMVar2 != (ModeButton *)&DAT_08169958);
  return;
}



void ghid_route_style_button_set_active(gint n)

{
  undefined4 uVar1;
  
  if ((uint)n < 7) {
    uVar1 = gtk_toggle_button_get_type();
    uVar1 = g_type_check_instance_cast(route_style_button[n].button,uVar1);
    gtk_toggle_button_set_active(uVar1,1);
  }
  return;
}



void ghid_layer_button_select(gint layer)

{
  undefined4 uVar1;
  
  if (layer != layer_select_button_index) {
    uVar1 = gtk_toggle_button_get_type();
    uVar1 = g_type_check_instance_cast(layer_buttons[layer].radio_select_button,uVar1);
    gtk_toggle_button_set_active(uVar1,1);
    layer_select_button_index = layer;
  }
  return;
}



int ToggleView(int argc,char **argv,int x,int y)

{
  byte *__nptr;
  gboolean in_toggle_view;
  ushort **ppuVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  long lVar6;
  int iVar7;
  byte *pbVar8;
  byte *pbVar9;
  DataTypePtr *pDVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  byte bVar14;
  
  bVar14 = 0;
  if (in_toggle_view != 0) {
    __fprintf_chk(stderr,1,
                  "ToggleView() called on top of another ToggleView()\nPlease report this and how it happened\n"
                 );
    return 0;
  }
  in_toggle_view = 1;
  if (argc == 0) {
LAB_08103e08:
    in_toggle_view = 0;
    Message("Syntax error.  Usage:\n%s\n",
                        
            "ToggleView(1..MAXLAYER)\nToggleView(layername)\nToggleView(Silk|Rats|Pins|Vias|Mask|BackSide)"
           );
    return 1;
  }
  ppuVar1 = __ctype_b_loc();
  __nptr = (byte *)*argv;
  bVar11 = false;
  bVar13 = (*(byte *)((int)*ppuVar1 + (int)(char)*__nptr * 2 + 1) & 8) == 0;
  if (bVar13) {
    iVar7 = 5;
    pbVar8 = __nptr;
    pbVar9 = &DAT_08155606;
    do {
      if (iVar7 == 0) break;
      iVar7 = iVar7 + -1;
      bVar11 = *pbVar8 < *pbVar9;
      bVar13 = *pbVar8 == *pbVar9;
      pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
      pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
    } while (bVar13);
    iVar7 = 0x10;
    bVar12 = (!bVar11 && !bVar13) < bVar11;
    bVar11 = (!bVar11 && !bVar13) == bVar11;
    if (!bVar11) {
      iVar7 = 5;
      pbVar8 = __nptr;
      pbVar9 = (byte *)0x813a186;
      do {
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        bVar12 = *pbVar8 < *pbVar9;
        bVar11 = *pbVar8 == *pbVar9;
        pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
        pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
      } while (bVar11);
      iVar7 = 0x11;
      bVar13 = (!bVar12 && !bVar11) < bVar12;
      bVar11 = (!bVar12 && !bVar11) == bVar12;
      if (!bVar11) {
        iVar7 = 5;
        pbVar8 = __nptr;
        pbVar9 = (byte *)0x8139ea4;
        do {
          if (iVar7 == 0) break;
          iVar7 = iVar7 + -1;
          bVar13 = *pbVar8 < *pbVar9;
          bVar11 = *pbVar8 == *pbVar9;
          pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
          pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
        } while (bVar11);
        iVar7 = 0x12;
        bVar12 = (!bVar13 && !bVar11) < bVar13;
        bVar11 = (!bVar13 && !bVar11) == bVar13;
        if (!bVar11) {
          iVar7 = 5;
          pbVar8 = __nptr;
          pbVar9 = (byte *)0x813a5e3;
          do {
            if (iVar7 == 0) break;
            iVar7 = iVar7 + -1;
            bVar12 = *pbVar8 < *pbVar9;
            bVar11 = *pbVar8 == *pbVar9;
            pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
            pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
          } while (bVar11);
          iVar7 = 0x13;
          bVar13 = (!bVar12 && !bVar11) < bVar12;
          bVar11 = (!bVar12 && !bVar11) == bVar12;
          if (!bVar11) {
            iVar7 = 5;
            pbVar8 = __nptr;
            pbVar9 = (byte *)0x813a651;
            do {
              if (iVar7 == 0) break;
              iVar7 = iVar7 + -1;
              bVar13 = *pbVar8 < *pbVar9;
              bVar11 = *pbVar8 == *pbVar9;
              pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
              pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
            } while (bVar11);
            iVar7 = 0x15;
            bVar12 = (!bVar13 && !bVar11) < bVar13;
            bVar11 = (!bVar13 && !bVar11) == bVar13;
            if (!bVar11) {
              iVar7 = 9;
              pbVar8 = __nptr;
              pbVar9 = (byte *)"BackSide";
              do {
                if (iVar7 == 0) break;
                iVar7 = iVar7 + -1;
                bVar12 = *pbVar8 < *pbVar9;
                bVar11 = *pbVar8 == *pbVar9;
                pbVar8 = pbVar8 + (uint)bVar14 * -2 + 1;
                pbVar9 = pbVar9 + (uint)bVar14 * -2 + 1;
              } while (bVar11);
              iVar7 = 0x14;
              if ((!bVar12 && !bVar11) != bVar12) {
                pDVar10 = PCB->Data;
                iVar2 = pDVar10->LayerN + 1;
                if (-1 < iVar2) {
                  iVar7 = 0;
                  do {
                    iVar3 = strcmp((char *)__nptr,*(char **)&pDVar10->field_0x4c);
                    if (iVar3 == 0) goto LAB_08103d40;
                    iVar7 = iVar7 + 1;
                    pDVar10 = (DataTypePtr *)&pDVar10->field_0x5c;
                  } while (iVar7 <= iVar2);
                }
                goto LAB_08103e08;
              }
            }
          }
        }
      }
    }
  }
  else {
    lVar6 = strtol((char *)__nptr,(char **)0x0,10);
    iVar7 = lVar6 + -1;
  }
LAB_08103d40:
  __printf_chk(1,"ToggleView():  l = %d\n",iVar7);
  uVar4 = gtk_toggle_button_get_type();
  uVar5 = g_type_check_instance_cast(layer_buttons[iVar7].layer_enable_button,uVar4);
  iVar2 = gtk_toggle_button_get_active(uVar5);
  uVar4 = g_type_check_instance_cast(layer_buttons[iVar7].layer_enable_button,uVar4);
  gtk_toggle_button_set_active(uVar4,(uint)(iVar2 != 1));
  return 0;
}



int SelectLayer(int argc,char **argv,int x,int y)

{
  char *__s1;
  int iVar1;
  undefined4 uVar2;
  long lVar3;
  int iVar4;
  
  if (argc != 0) {
    iVar4 = 0x10;
    __s1 = *argv;
    iVar1 = strcasecmp(__s1,"silk");
    if (iVar1 != 0) {
      iVar4 = 0x11;
      iVar1 = strcasecmp(__s1,"rats");
      if (iVar1 != 0) {
        lVar3 = strtol(__s1,(char **)0x0,10);
        iVar4 = lVar3 + -1;
      }
    }
    uVar2 = gtk_toggle_button_get_type();
    uVar2 = g_type_check_instance_cast(layer_buttons[iVar4].radio_select_button,uVar2);
    gtk_toggle_button_set_active(uVar2,1);
    return 0;
  }
  Message("Syntax error.  Usage:\n%s\n","SelectLayer(1..MAXLAYER|Silk|Rats)");
  return 1;
}



void register_ghid_menu_action_list(void)

{
  hid_register_actions(ghid_menu_action_list,2);
  return;
}



void register_gtk_topwindow_action_list(void)

{
  hid_register_actions(gtk_topwindow_action_list,3);
  return;
}



void register_pcbmenu_attr(void)

{
  hid_register_attributes((HID_Attribute *)pcbmenu_attr,1);
  return;
}



void register_ghid_attribute_list(void)

{
  hid_register_attributes((HID_Attribute *)ghid_attribute_list,2);
  return;
}



void ghid_route_style_set_temp_style(RouteStyleType *rst,gint which)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  bool bVar5;
  
  if ((uint)which < 2) {
    iVar3 = which + 4;
    gtk_widget_show(route_style_button[iVar3].button);
    pcVar1 = route_style_button[iVar3].route_style.Name;
    route_style_button[iVar3].shown = 1;
    bVar5 = route_style_index != iVar3;
    route_style_button[iVar3].route_style.Thick = rst->Thick;
    route_style_button[iVar3].route_style.Diameter = rst->Diameter;
    route_style_button[iVar3].route_style.Hole = rst->Hole;
    route_style_button[iVar3].route_style.Keepaway = rst->Keepaway;
    route_style_button[iVar3].route_style.Name = rst->Name;
    iVar2 = rst->index;
    route_style_button[iVar3].route_style.Name = pcVar1;
    route_style_button[iVar3].route_style.index = iVar2;
    if (bVar5) {
      route_style_index = iVar3;
      uVar4 = gtk_toggle_button_get_type();
      g_type_check_instance_cast(route_style_button[iVar3].button,uVar4);
      gtk_toggle_button_set_active();
      return;
    }
  }
  return;
}



void ghid_show_layer_buttons(void)

{
  GtkWidget **ppGVar1;
  int *piVar2;
  int iVar3;
  GtkWidget **ppGVar4;
  
  ppGVar4 = &layer_buttons[0].layer_enable_button;
  iVar3 = 0;
  do {
    while (piVar2 = &PCB->Data->LayerN, *piVar2 == iVar3 || *piVar2 < iVar3) {
      iVar3 = iVar3 + 1;
      gtk_widget_hide(*ppGVar4);
      ppGVar1 = ppGVar4 + -1;
      ppGVar4 = ppGVar4 + 6;
      gtk_widget_hide(*ppGVar1);
      if (iVar3 == 0x10) {
        return;
      }
    }
    iVar3 = iVar3 + 1;
    gtk_widget_show(*ppGVar4);
    ppGVar1 = ppGVar4 + -1;
    ppGVar4 = ppGVar4 + 6;
    gtk_widget_show(*ppGVar1);
  } while (iVar3 != 0x10);
  return;
}



gboolean ghid_listener_cb(GIOChannel *source,GIOCondition condition,gpointer data)

{
  int iVar1;
  undefined4 local_1c;
  gsize term;
  gsize len;
  char *local_10 [3];
  
  local_1c = 0;
  if ((condition & G_IO_HUP) != 0) {
    (*gui->log)("Read end of pipe died!\n");
    return 0;
  }
  if (condition != G_IO_IN) {
    __fprintf_chk(stderr,1,"Unknown condition in ghid_listener_cb\n");
    return 1;
  }
  iVar1 = g_io_channel_read_line(source,local_10,&len,&term,&local_1c);
  if (iVar1 == 1) {
    hid_parse_actions(local_10[0],(anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0);
    g_free(local_10[0]);
    return 1;
  }
  if (iVar1 == 0) {
    (*gui->log)("ERROR status from g_io_channel_read_line\n");
    return 0;
  }
  if (iVar1 == 2) {
    (*gui->log)(
               "Input pipe returned EOF.  The --listen option is \nprobably not running anymore in this session.\n"
               );
    return 0;
  }
  if (iVar1 != 3) {
    __fprintf_chk(stderr,1,"ERROR:  unhandled case in ghid_listener_cb\n");
    return 0;
  }
  (*gui->log)("AGAIN status from g_io_channel_read_line\n");
  return 0;
}



hidGC ghid_make_gc(void)

{
  char *pcVar1;
  hidGC phVar2;
  
  phVar2 = (hidGC)g_malloc0(0x20);
  pcVar1 = Settings.BackgroundColor;
  phVar2->nothing_interesting_here = 0x81685a0;
  *(char **)&phVar2[2].nothing_interesting_here = pcVar1;
  return phVar2;
}



void ghid_destroy_gc(hidGC gc)

{
  if (gc[1].nothing_interesting_here != 0) {
    g_object_unref(gc[1].nothing_interesting_here);
  }
  g_free();
  return;
}



void ghid_parse_arguments(int *argc,char ***argv)

{
  gint gVar1;
  gint gVar2;
  GHidPort *pGVar3;
  uint uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  undefined4 uVar7;
  int iVar8;
  byte *pbVar9;
  byte *pbVar10;
  bool bVar11;
  bool bVar12;
  byte bVar13;
  
  bVar13 = 0;
  gtk_set_locale();
  setlocale(1,"POSIX");
  gtk_disable_setlocale();
  gtk_init(argc,argv);
  gport = &ghid_port;
  pixel_slop = 300;
  ghid_port.zoom = 300.00000000;
  ghid_config_files_read(argc,argv);
  Settings.AutoPlace = '\0';
  if (0 < *argc) {
    bVar11 = false;
    uVar4 = 0;
    bVar12 = true;
    do {
      iVar8 = 0xc;
      pbVar9 = (byte *)(*argv)[uVar4];
      pbVar10 = (byte *)"-auto-place";
      do {
        if (iVar8 == 0) break;
        iVar8 = iVar8 + -1;
        bVar11 = *pbVar9 < *pbVar10;
        bVar12 = *pbVar9 == *pbVar10;
        pbVar9 = pbVar9 + (uint)bVar13 * -2 + 1;
        pbVar10 = pbVar10 + (uint)bVar13 * -2 + 1;
      } while (bVar12);
      if ((!bVar11 && !bVar12) == bVar11) {
        Settings.AutoPlace = '\x01';
      }
      uVar4 = uVar4 + 1;
      bVar11 = (uint)*argc < uVar4;
      bVar12 = *argc == uVar4;
    } while (!bVar12 && (int)uVar4 <= *argc);
  }
  bindtextdomain(&DAT_0815492c,"/usr/share/locale");
  textdomain(&DAT_0815492c);
  bind_textdomain_codeset(&DAT_0815492c,"UTF-8");
  uVar5 = gdk_pixbuf_new_from_xpm_data(icon_bits);
  gtk_window_set_default_icon(uVar5);
  pGVar3 = gport;
  pGVar6 = (GtkWidget *)gtk_window_new(0);
  pGVar3->top_window = pGVar6;
  uVar5 = gtk_window_get_type();
  uVar7 = g_type_check_instance_cast(pGVar6,uVar5);
  gtk_window_set_title(uVar7,&DAT_08154932);
  gVar1 = ghidgui->top_window_height;
  gVar2 = ghidgui->top_window_width;
  uVar5 = g_type_check_instance_cast(pGVar6,uVar5);
  gtk_window_set_default_size(uVar5,gVar2,gVar1);
  if (Settings.AutoPlace != '\0') {
    uVar5 = gtk_widget_get_type();
    uVar5 = g_type_check_instance_cast(pGVar6,uVar5);
    gtk_widget_set_uposition(uVar5,10,10);
  }
  gtk_widget_realize(gport->top_window);
  gtk_widget_show_all(gport->top_window);
  ghidgui->creating = 1;
  return;
}



void layer_enable_button_set_label(GtkWidget *label,gchar *text)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  if (ghidgui->small_label_markup == 0) {
    uVar1 = g_strdup(text);
  }
  else {
    uVar1 = g_strdup_printf("<small>%s</small>",text);
  }
  uVar2 = gtk_label_get_type();
  uVar2 = g_type_check_instance_cast(label,uVar2);
  gtk_label_set_markup(uVar2,uVar1);
  g_free();
  return;
}



void ghid_interface_input_signals_connect(void)

{
  GtkUIManager *pGVar1;
  undefined4 uVar2;
  
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  button_press_handler =
       g_signal_connect_data(uVar2,"button_press_event",ghid_port_button_press_cb,pGVar1,0,0);
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  button_release_handler =
       g_signal_connect_data(uVar2,"button_release_event",ghid_port_button_release_cb,pGVar1,0,0);
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  key_press_handler =
       g_signal_connect_data(uVar2,"key_press_event",ghid_port_key_press_cb,pGVar1,0,0);
  pGVar1 = ghidgui->ui_manager;
  uVar2 = g_type_check_instance_cast(gport->drawing_area,0x50);
  key_release_handler =
       g_signal_connect_data(uVar2,"key_release_event",ghid_port_key_release_cb,pGVar1,0,0);
  return;
}



char * __regparm3 ghid_check_unique_accel(char *accelerator)

{
  char "ghid_check_unique_accel" [24];
  int amax;
  char **accel_list;
  int n_list;
  int iVar1;
  char *pcVar2;
  char **ppcVar3;
  int iVar4;
  char *pcVar5;
  int iVar6;
  
  pcVar5 = accelerator;
  if ((accelerator != (char *)0x0) && (*accelerator != '\0')) {
    if (n_list <= amax) {
      n_list = n_list + 0x80;
      accel_list = (char **)realloc(accel_list,n_list * 4);
      if (accel_list == (char **)0x0) {
        __fprintf_chk(stderr,1,"%s():  realloc failed\n","ghid_check_unique_accel");
                    // WARNING: Subroutine does not return
        exit(1);
      }
    }
    ppcVar3 = accel_list;
    iVar6 = amax;
    iVar4 = 0;
    if (0 < amax) {
      do {
        iVar1 = strcmp(ppcVar3[iVar4],accelerator);
        if (iVar1 == 0) {
          Message("Duplicate accelerator found: \"%s\"\nThe second occurance will be dropped\n",
                  accelerator);
          ppcVar3 = accel_list;
          pcVar5 = (char *)0x0;
          iVar6 = amax;
          break;
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < iVar6);
    }
    pcVar2 = (char *)__strdup(accelerator);
    ppcVar3[iVar6] = pcVar2;
  }
  return pcVar5;
}



void __regparm3 ghid_ui_info_append(gchar *new)

{
  char cVar1;
  size_t sVar2;
  size_t sVar3;
  gchar *__ptr;
  char *pcVar4;
  size_t __size;
  
  __size = new_ui_info_sz;
  __ptr = new_ui_info;
  if (new_ui_info_sz == 0) {
    new_ui_info_sz = 0x400;
    __ptr = (gchar *)calloc(0x400,1);
    __size = new_ui_info_sz;
  }
  do {
    new_ui_info = __ptr;
    new_ui_info_sz = __size;
    __ptr = new_ui_info;
    __size = new_ui_info_sz;
    sVar2 = strlen(new_ui_info);
    sVar3 = strlen(new);
    if (sVar2 + 1 + sVar3 <= __size) {
      cVar1 = *new;
      pcVar4 = __ptr + sVar2;
      while (cVar1 != '\0') {
        new = new + 1;
        *pcVar4 = cVar1;
        cVar1 = *new;
        pcVar4 = pcVar4 + 1;
      }
      *pcVar4 = '\0';
      return;
    }
    __size = __size + 0x400;
    __ptr = (gchar *)realloc(__ptr,__size);
  } while (__ptr != (gchar *)0x0);
  __fprintf_chk(stderr,1,"ghid_ui_info_append():  realloc of size %ld failed\n",__size);
                    // WARNING: Subroutine does not return
  exit(1);
}



void __regparm3 ghid_ui_info_indent(int indent)

{
  int iVar1;
  
  if (0 < indent) {
    iVar1 = 0;
    do {
      iVar1 = iVar1 + 1;
      ghid_ui_info_append(" ");
    } while (iVar1 < indent);
  }
  return;
}



void __regparm3 ghid_check_special_key(char *accel,char *name)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  if (accel == (char *)0x0) {
    return;
  }
  if (*accel == '\0') {
    return;
  }
  pcVar1 = strstr(accel,"<alt>");
  uVar4 = ~-(uint)(pcVar1 == (char *)0x0) & 0x80;
  pcVar1 = strstr(accel,"<control>");
  if (pcVar1 != (char *)0x0) {
    uVar4 = uVar4 | 0x40;
  }
  pcVar1 = strstr(accel,"<shift>");
  if (pcVar1 != (char *)0x0) {
    uVar4 = uVar4 | 0x20;
  }
  sVar2 = strlen(accel);
  if (sVar2 < 3) {
    if (sVar2 != 2) {
      return;
    }
  }
  else {
    pcVar1 = accel + (sVar2 - 3);
    if ((((*pcVar1 == 'T') && (pcVar1[1] == 'a')) && (pcVar1[2] == 'b')) && (pcVar1[3] == '\0')) {
      uVar4 = uVar4 | 1;
      goto LAB_08104938;
    }
  }
  pcVar1 = accel + (sVar2 - 2);
  if (((*pcVar1 == 'U') && (pcVar1[1] == 'p')) && (pcVar1[2] == '\0')) {
    uVar4 = uVar4 | 2;
  }
  else {
    bVar6 = sVar2 == 3;
    if (sVar2 < 4) {
      return;
    }
    iVar3 = 5;
    pcVar1 = accel + (sVar2 - 4);
    pcVar5 = "Down";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar6 = *pcVar1 == *pcVar5;
      pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
      pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
    } while (bVar6);
    if (bVar6) {
      uVar4 = uVar4 | 3;
    }
    else {
      iVar3 = 5;
      pcVar1 = accel + (sVar2 - 4);
      pcVar5 = "Left";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar6 = *pcVar1 == *pcVar5;
        pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
        pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
      } while (bVar6);
      if (bVar6) {
        uVar4 = uVar4 | 4;
      }
      else {
        bVar6 = sVar2 == 4;
        if (bVar6) {
          return;
        }
        iVar3 = 6;
        pcVar1 = accel + (sVar2 - 5);
        pcVar5 = "Right";
        do {
          if (iVar3 == 0) break;
          iVar3 = iVar3 + -1;
          bVar6 = *pcVar1 == *pcVar5;
          pcVar1 = pcVar1 + (uint)bVar7 * -2 + 1;
          pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
        } while (bVar6);
        if (!bVar6) {
          return;
        }
        uVar4 = uVar4 | 5;
      }
    }
  }
LAB_08104938:
  pcVar1 = (char *)g_strdup(name);
  ghid_hotkey_actions[uVar4] = pcVar1;
  return;
}



void __regparm3 note_toggle_flag(char *actionname,MenuFlagType type,char *name)

{
  int iVar1;
  char "note_toggle_flag" [17];
  char *pcVar2;
  ToggleFlagType *pTVar3;
  
  if (max_tflags <= n_tflags) {
    max_tflags = max_tflags + 0x14;
    tflags = (ToggleFlagType *)MyRealloc(tflags,max_tflags * 0x14,"note_toggle_flag");
  }
  pTVar3 = tflags;
  iVar1 = n_tflags;
  pcVar2 = (char *)__strdup(actionname);
  pTVar3[iVar1].actionname = pcVar2;
  pTVar3 = tflags + n_tflags;
  pTVar3->oldval = -1;
  pTVar3->flagname = name;
  pTVar3->flagtype = type;
  pTVar3->xres = "none";
  n_tflags = n_tflags + 1;
  return;
}



void __regparm3 layer_process(gchar **color_string,char **text,int *set,int i)

{
  DataTypePtr *pDVar1;
  char *pcVar2;
  Cardinal *pCVar3;
  gchar *tmpc;
  char *tmps;
  int tmp;
  
  if (color_string == (gchar **)0x0) {
    color_string = &tmpc;
  }
  if (text == (char **)0x0) {
    text = &tmps;
  }
  if (set == (int *)0x0) {
    set = &tmp;
  }
  switch(i) {
  case 0x10:
    *color_string = PCB->ElementColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,0x8148f92,5);
    *text = pcVar2;
    *set = (int)PCB->ElementOn;
    break;
  case 0x11:
    *color_string = PCB->RatColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"rat lines",5);
    *text = pcVar2;
    *set = (int)PCB->RatOn;
    break;
  case 0x12:
    *color_string = PCB->PinColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"pins/pads",5);
    *text = pcVar2;
    *set = (int)PCB->PinOn;
    break;
  case 0x13:
    *color_string = PCB->ViaColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,0x81488e7,5);
    *text = pcVar2;
    *set = (int)PCB->ViaOn;
    break;
  case 0x14:
    *color_string = PCB->InvisibleObjectsColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,"far side",5);
    *text = pcVar2;
    *set = (int)PCB->InvisibleObjectsOn;
    break;
  case 0x15:
    *color_string = PCB->MaskColor;
    pcVar2 = (char *)dcgettext(&DAT_0815492c,0x8148ecd,5);
    *text = pcVar2;
    *set = (PCB->Flags).f >> 0xd & 1;
    break;
  default:
    pDVar1 = PCB->Data;
    pCVar3 = &pDVar1->ViaN + i * 0x17;
    *color_string = (char *)pCVar3[0x25];
    pcVar2 = (char *)pCVar3[0x13];
    if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
      pcVar2 = "(unknown)";
    }
    *text = pcVar2;
    *set = (int)*(char *)(&pDVar1->field_0x90 + i * 0x5c);
  }
  return;
}



void __regparm3 layer_button_set_color(LayerButtonSet *lb,gchar *color_string)

{
  GdkColor color;
  
  if (lb->layer_enable_ebox != (GtkWidget *)0x0) {
    color.blue = 0;
    color.green = 0;
    color.red = 0;
    ghid_map_color_string(color_string,&color);
    gtk_widget_modify_bg(lb->layer_enable_ebox,1,&color);
    gtk_widget_modify_bg(lb->layer_enable_ebox,2,&color);
    gtk_widget_modify_fg(lb->label,1,&WhitePixel);
  }
  return;
}



void ghid_layer_buttons_color_update(void)

{
  int i;
  int iVar1;
  LayerButtonSet *lb;
  gchar *local_20 [4];
  
  if (gport->drawing_area != (GtkWidget *)0x0) {
    pcb_colors_from_settings(PCB);
    i = 0;
    lb = layer_buttons;
    do {
      iVar1 = i + 1;
      layer_process(local_20,(char **)0x0,(int *)0x0,i);
      layer_button_set_color(lb,local_20[0]);
      i = iVar1;
      lb = lb + 1;
    } while (iVar1 != 0x16);
  }
  return;
}



void mode_button_toggled_cb(GtkWidget *widget,ModeButton *mb)

{
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = gtk_toggle_button_get_type();
  uVar1 = g_type_check_instance_cast(widget,uVar1);
  iVar2 = gtk_toggle_button_get_active(uVar1);
  if (iVar2 != 0) {
    SetMode(mb->mode);
    ghid_mode_cursor(mb->mode);
    ghidgui->settings_mode = mb->mode;
  }
  return;
}



void route_style_select_button_cb(GtkToggleButton *button,gpointer data)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  gchar buf [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (((data != (gpointer)0x6) && (ghidgui->toggle_holdoff == 0)) &&
     ((gpointer)route_style_index != data)) {
    route_style_index = (gint)data;
    if ((int)data < 4) {
      __snprintf_chk(buf,0x10,1,0x10,&DAT_081538d1,(int)data + 1);
      iVar2 = gtk_toggle_button_get_active(button);
      if (iVar2 != 0) {
        hid_actionl("RouteStyle",buf,0);
      }
    }
    else {
      if ((int)data < 6) {
        SetLineSize(route_style_button[(int)data].route_style.Thick);
        SetViaSize(route_style_button[(int)data].route_style.Diameter,'\x01');
        SetViaDrillingHole(route_style_button[(int)data].route_style.Hole,'\x01');
        SetKeepawayWidth(route_style_button[(int)data].route_style.Keepaway);
      }
    }
    gtk_widget_set_sensitive(route_style_edit_button,1);
    ghid_set_status_line_label();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ghid_interface_set_sensitive(gboolean sensitive)

{
  gtk_widget_set_sensitive(ghid_left_sensitive_box,sensitive);
  gtk_widget_set_sensitive(ghidgui->menu_hbox,sensitive);
  return;
}



void ghid_route_style_buttons_update(void)

{
  RouteStyleType *pRVar1;
  int n;
  
  n = 0;
  do {
    pRVar1 = PCB->RouteStyle + n;
    if (n < 4) {
LAB_08104fcb:
      if ((((Settings.LineThickness == pRVar1->Thick) && (Settings.ViaThickness == pRVar1->Diameter)
           ) && (Settings.ViaDrillingHole == pRVar1->Hole)) &&
         (Settings.Keepaway == pRVar1->Keepaway)) break;
    }
    else {
      if (route_style_button[n].shown != 0) {
        pRVar1 = &route_style_button[n].route_style;
        goto LAB_08104fcb;
      }
    }
    n = n + 1;
  } while (n != 6);
  ghidgui->toggle_holdoff = 1;
  ghid_route_style_button_set_active(n);
  route_style_index = n;
  ghidgui->toggle_holdoff = 0;
  gtk_widget_set_sensitive(route_style_edit_button,(uint)(n != 6));
  return;
}



void route_style_edit_cb(GtkWidget *widget,GHidPort *port)

{
  hid_action("AdjustStyle");
  return;
}



gint delete_chart_cb(GtkWidget *widget,GdkEvent *event,GHidPort *port)

{
  ghid_config_files_write();
  hid_action("Quit");
  return 1;
}



void destroy_chart_cb(GtkWidget *widget,GHidPort *port)

{
  gtk_main_quit();
  return;
}



void h_adjustment_changed_cb(GtkAdjustment *adj,GhidGui *g)

{
  undefined4 uVar1;
  
  if (g->adjustment_changed_holdoff != 0) {
    return;
  }
  gtk_adjustment_get_value(adj);
  uVar1 = gtk_adjustment_get_type();
  uVar1 = g_type_check_instance_cast(ghidgui->v_adjustment,uVar1);
  gtk_adjustment_get_value(uVar1);
  ghid_port_ranges_changed();
  return;
}



void v_adjustment_changed_cb(GtkAdjustment *adj,GhidGui *g)

{
  undefined4 uVar1;
  
  if (g->adjustment_changed_holdoff != 0) {
    return;
  }
  gtk_adjustment_get_value(adj);
  uVar1 = gtk_adjustment_get_type();
  uVar1 = g_type_check_instance_cast(ghidgui->h_adjustment,uVar1);
  gtk_adjustment_get_value(uVar1);
  ghid_port_ranges_changed();
  return;
}



void ghid_interface_input_signals_disconnect(void)

{
  if (button_press_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,button_press_handler);
  }
  if (button_release_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,button_release_handler);
  }
  if (key_press_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,key_press_handler);
  }
  if (key_release_handler != 0) {
    g_signal_handler_disconnect(gport->drawing_area,key_release_handler);
  }
  button_press_handler = 0;
  button_release_handler = 0;
  key_press_handler = 0;
  key_release_handler = 0;
  return;
}



gboolean ghid_pack_mode_buttons(void)

{
  gint last_pack_compact;
  undefined4 uVar1;
  GtkWidget *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  GtkWidget *pGVar6;
  
  if (-1 < last_pack_compact) {
    if (last_pack_compact == 0) {
      uVar1 = gtk_container_get_type();
      pGVar6 = ghidgui->mode_buttons0_frame;
      pGVar2 = ghidgui->mode_buttons0_frame_vbox;
    }
    else {
      uVar1 = gtk_container_get_type();
      pGVar6 = ghidgui->mode_buttons1_frame;
      pGVar2 = ghidgui->mode_buttons1_vbox;
    }
    iVar5 = 0;
    uVar3 = g_type_check_instance_cast(pGVar2,uVar1);
    gtk_container_remove(uVar3,pGVar6);
    do {
      if (last_pack_compact == 0) {
        uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
        uVar4 = *(undefined4 *)((int)&mode_buttons[0].box0 + iVar5);
      }
      else {
        uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
        uVar4 = *(undefined4 *)((int)&mode_buttons[0].box1 + iVar5);
      }
      iVar5 = iVar5 + 0x18;
      uVar4 = g_type_check_instance_cast(uVar4,uVar1);
      gtk_container_remove(uVar4,uVar3);
    } while (iVar5 != 0x138);
  }
  uVar1 = gtk_box_get_type();
  iVar5 = 0;
  do {
    if (ghidgui->compact_vertical == 0) {
      uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
      uVar4 = *(undefined4 *)((int)&mode_buttons[0].box0 + iVar5);
    }
    else {
      uVar3 = *(undefined4 *)((int)&mode_buttons[0].button + iVar5);
      uVar4 = *(undefined4 *)((int)&mode_buttons[0].box1 + iVar5);
    }
    iVar5 = iVar5 + 0x18;
    uVar4 = g_type_check_instance_cast(uVar4,uVar1);
    gtk_box_pack_start(uVar4,uVar3,0,0,0);
  } while (iVar5 != 0x138);
  if (ghidgui->compact_vertical == 0) {
    pGVar6 = ghidgui->mode_buttons0_frame;
    uVar1 = g_type_check_instance_cast(ghidgui->mode_buttons0_frame_vbox,uVar1);
    gtk_box_pack_start(uVar1,pGVar6,0,0,0);
    gtk_widget_show_all(ghidgui->mode_buttons0_frame);
  }
  else {
    pGVar6 = ghidgui->mode_buttons1_frame;
    uVar1 = g_type_check_instance_cast(ghidgui->mode_buttons1_vbox,uVar1);
    gtk_box_pack_start(uVar1,pGVar6,0,0,0);
    gtk_widget_show_all(ghidgui->mode_buttons1_frame);
  }
  return ghidgui->compact_vertical;
}



void ghid_route_style_set_button_label(gchar *name,gint index)

{
  undefined4 uVar1;
  
  if (((uint)index < 4) && (route_style_button[index].button != (GtkWidget *)0x0)) {
    dcgettext(&DAT_0815492c,name,5);
    uVar1 = gtk_button_get_type();
    g_type_check_instance_cast(route_style_button[index].button,uVar1);
    gtk_button_set_label();
    return;
  }
  return;
}



void ghid_init_toggle_states(void)

{
  gboolean gVar1;
  GhidGui *pGVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  int iVar5;
  
  pGVar2 = ghidgui;
  gVar1 = ghidgui->toggle_holdoff;
  ghidgui->toggle_holdoff = 1;
  uVar3 = gtk_action_group_get_action(pGVar2->main_actions,"ToggleDrawGrid");
  iVar5 = (int)Settings.DrawGrid;
  uVar4 = gtk_toggle_action_get_type();
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleGridUnitsMm");
  iVar5 = (int)Settings.grid_units_mm;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"TogglePinoutShowsNumber");
  iVar5 = (int)Settings.ShowNumber;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"Toggle45degree");
  iVar5 = (int)Settings.AllDirectionLines;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleRubberBand");
  iVar5 = (int)Settings.RubberBandMode;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleStartDirection");
  iVar5 = (int)Settings.SwapStartDirection;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleUniqueNames");
  iVar5 = (int)Settings.UniqueNames;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleSnapPin");
  iVar5 = (int)Settings.SnapPin;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleClearLine");
  iVar5 = (int)Settings.ClearLine;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleOrthogonalMoves");
  iVar5 = (int)Settings.OrthogonalMoves;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleLiveRoute");
  iVar5 = (int)Settings.liveRouting;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleShowDRC");
  iVar5 = (int)Settings.ShowDRC;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,"ToggleAutoDrC");
  iVar5 = (int)Settings.AutoDRC;
  uVar3 = g_type_check_instance_cast(uVar3,uVar4);
  gtk_toggle_action_set_active(uVar3,iVar5);
  ghidgui->toggle_holdoff = gVar1;
  ghid_set_status_line_label();
  return;
}



void ghid_set_menu_toggle_button(GtkActionGroup *ag,gchar *name,gboolean state)

{
  gboolean gVar1;
  int iVar2;
  undefined4 uVar3;
  
  gVar1 = ghidgui->toggle_holdoff;
  ghidgui->toggle_holdoff = 1;
  iVar2 = gtk_action_group_get_action(ag,name);
  if (iVar2 != 0) {
    uVar3 = gtk_toggle_action_get_type();
    uVar3 = g_type_check_instance_cast(iVar2,uVar3);
    gtk_toggle_action_set_active(uVar3,state);
  }
  ghidgui->toggle_holdoff = gVar1;
  return;
}



void ghid_window_set_name_label(gchar *name)

{
  GhidGui *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  gchar *pgVar4;
  
  if (ghidgui != (GhidGui *)0x0) {
    dup_string(&ghidgui->name_label_string,name);
    pGVar1 = ghidgui;
    if ((ghidgui->name_label_string == (char *)0x0) || (*ghidgui->name_label_string == '\0')) {
      uVar2 = dcgettext(&DAT_0815492c,"Unnamed",5);
      pgVar4 = (gchar *)g_strdup(uVar2);
      pGVar1->name_label_string = pgVar4;
    }
    if (ghidgui->name_label != (GtkWidget *)0x0) {
      if (ghidgui->ghid_title_window == 0) {
        gtk_widget_show(ghidgui->label_hbox);
        uVar2 = g_strdup_printf(" <b><big>%s</big></b> ",ghidgui->name_label_string);
        uVar3 = gtk_label_get_type();
        uVar3 = g_type_check_instance_cast(ghidgui->name_label,uVar3);
        gtk_label_set_markup(uVar3,uVar2);
        uVar2 = gtk_window_get_type();
        uVar2 = g_type_check_instance_cast(gport->top_window,uVar2);
        gtk_window_set_title(uVar2,&DAT_08154932);
        g_free();
        return;
      }
      gtk_widget_hide(ghidgui->label_hbox);
      uVar2 = g_strdup_printf("PCB:  %s",ghidgui->name_label_string);
      uVar3 = gtk_window_get_type();
      uVar3 = g_type_check_instance_cast(gport->top_window,uVar3);
      gtk_window_set_title(uVar3,uVar2);
      g_free();
      return;
    }
  }
  return;
}



void ghid_layer_enable_buttons_update(void)

{
  char cVar1;
  GtkWidget *pGVar2;
  gboolean gVar3;
  gchar *text;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  PCBTypePtr pPVar7;
  int layer;
  GtkWidget **ppGVar8;
  DataTypePtr *pDVar9;
  char *src;
  undefined4 local_20;
  
  pPVar7 = PCB;
  layer_enable_button_cb_hold_off = 1;
  pDVar9 = PCB->Data;
  if (pDVar9->LayerN < 1) {
    local_20 = gtk_toggle_button_get_type();
  }
  else {
    local_20 = gtk_toggle_button_get_type();
    ppGVar8 = &layer_buttons[0].layer_enable_button;
    layer = 0;
    do {
      src = *(char **)(&pDVar9->field_0x4c + layer * 0x5c);
      if ((src == (char *)0x0) || (*src == '\0')) {
        src = "(unknown)";
      }
      gVar3 = dup_string((gchar **)(ppGVar8 + 3),src);
      if (gVar3 == 0) {
        if (Settings.verbose == 0) goto LAB_081059be;
LAB_08105a94:
        uVar4 = g_type_check_instance_cast(*ppGVar8,local_20);
        iVar5 = gtk_toggle_button_get_active(uVar4);
        iVar6 = (int)*(char *)(&PCB->Data->field_0x90 + layer * 0x5c);
        if (iVar5 != iVar6) {
          __printf_chk(1,"ghid_layer_enable_buttons_update: active=%d new=%d\n",iVar5,iVar6);
          iVar5 = (int)*(char *)(&PCB->Data->field_0x90 + layer * 0x5c);
        }
      }
      else {
        text = (gchar *)dcgettext(&DAT_0815492c,src,5);
        layer_enable_button_set_label(ppGVar8[2],text);
        text = (gchar *)dcgettext(&DAT_0815492c,src,5);
        ghid_config_layer_name_update(text,layer);
        if (Settings.verbose != 0) goto LAB_08105a94;
LAB_081059be:
        iVar5 = (int)*(char *)(&PCB->Data->field_0x90 + layer * 0x5c);
      }
      layer = layer + 1;
      pGVar2 = *ppGVar8;
      ppGVar8 = ppGVar8 + 6;
      uVar4 = g_type_check_instance_cast(pGVar2,local_20);
      gtk_toggle_button_set_active(uVar4,iVar5);
      pDVar9 = PCB->Data;
      pPVar7 = PCB;
    } while (pDVar9->LayerN != layer && layer <= pDVar9->LayerN);
  }
  cVar1 = pPVar7->ElementOn;
  uVar4 = g_type_check_instance_cast(layer_buttons[16].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar4,(int)cVar1);
  cVar1 = PCB->RatOn;
  uVar4 = g_type_check_instance_cast(layer_buttons[17].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar4,(int)cVar1);
  cVar1 = PCB->PinOn;
  uVar4 = g_type_check_instance_cast(layer_buttons[18].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar4,(int)cVar1);
  cVar1 = PCB->ViaOn;
  uVar4 = g_type_check_instance_cast(layer_buttons[19].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar4,(int)cVar1);
  cVar1 = PCB->InvisibleObjectsOn;
  uVar4 = g_type_check_instance_cast(layer_buttons[20].layer_enable_button,local_20);
  gtk_toggle_button_set_active(uVar4,(int)cVar1);
  layer_enable_button_cb_hold_off = 0;
  return;
}



void ghid_layer_buttons_update(void)

{
  int *piVar1;
  int iVar2;
  char cVar3;
  gboolean gVar4;
  int iVar5;
  undefined4 uVar6;
  int local_c0;
  int in_GS_OFFSET;
  bool bVar7;
  int local_94;
  GValue *local_90;
  GValue setlabel;
  GValue settrue;
  GValue setfalse;
  char *local_50;
  int local_4c;
  char tmpnm [40];
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  setfalse.g_type = 0;
  setfalse.data[0]._0_4_ = 0;
  setfalse.data[0]._4_4_ = 0;
  setfalse.data[1]._0_4_ = 0;
  setfalse.data[1]._4_4_ = 0;
  settrue.g_type = 0;
  settrue.data[0]._0_4_ = 0;
  settrue.data[0]._4_4_ = 0;
  settrue.data[1]._0_4_ = 0;
  settrue.data[1]._4_4_ = 0;
  setlabel.g_type = 0;
  setlabel.data[0]._0_4_ = 0;
  setlabel.data[0]._4_4_ = 0;
  setlabel.data[1]._0_4_ = 0;
  setlabel.data[1]._4_4_ = 0;
  g_value_init(&setfalse,0x14);
  g_value_init(&settrue,0x14);
  g_value_set_boolean(&setfalse,0);
  g_value_set_boolean(&settrue,1);
  g_value_init(&setlabel,0x40);
  if ((ghidgui != (GhidGui *)0x0) && (ghidgui->creating == 0)) {
    ghid_layer_enable_buttons_update();
    local_94 = 0x11;
    if ((PCB->RatDraw == '\0') && (local_94 = 0x10, PCB->SilkActive == '\0')) {
      local_94 = LayerStack[0];
    }
    if (local_94 < PCB->Data->LayerN) {
      cVar3 = *(char *)(&PCB->Data->field_0x90 + local_94 * 0x5c);
    }
    else {
      if (local_94 == 0x10) {
        cVar3 = PCB->ElementOn;
      }
      else {
        cVar3 = '\0';
        if (local_94 == 0x11) {
          cVar3 = PCB->RatOn;
        }
      }
    }
    if (((Settings.verbose != 0) &&
        (local_c0 = local_94,
        __printf_chk(1,"ghid_layer_buttons_update cur_index=%d update_index=%d\n",
                     layer_select_button_index,local_94), cVar3 != '\0')) &&
       (local_94 != layer_select_button_index)) {
      __printf_chk(1,"\tActivating button %d\n",local_94,local_c0);
    }
    local_c0 = 0;
    gVar4 = ghidgui->toggle_holdoff;
    ghidgui->toggle_holdoff = 1;
    do {
      __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"LayerPick",local_c0);
      iVar5 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
      layer_process((gchar **)0x0,&local_50,&local_4c,local_c0);
      g_value_set_string(&setlabel,local_50);
      if (iVar5 != 0) {
        if ((0xf < local_c0) ||
           (local_90 = &setfalse, piVar1 = &PCB->Data->LayerN,
           *piVar1 != local_c0 && local_c0 <= *piVar1)) {
          local_90 = &settrue;
        }
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,0x8154f0b,local_90);
        bVar7 = local_4c != 0;
        uVar6 = gtk_toggle_action_get_type();
        uVar6 = g_type_check_instance_cast(iVar5,uVar6);
        gtk_toggle_action_set_active(uVar6,(uint)(local_c0 == local_94 && bVar7));
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,"label",&setlabel);
      }
      __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"LayerView",local_c0);
      iVar5 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
      if (iVar5 != 0) {
        if ((0xf < local_c0) ||
           (local_90 = &setfalse, piVar1 = &PCB->Data->LayerN,
           *piVar1 != local_c0 && local_c0 <= *piVar1)) {
          local_90 = &settrue;
        }
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,0x8154f0b,local_90);
        bVar7 = local_4c != 0;
        uVar6 = gtk_toggle_action_get_type();
        uVar6 = g_type_check_instance_cast(iVar5,uVar6);
        gtk_toggle_action_set_active(uVar6,(uint)bVar7);
        g_value_set_string(&setlabel,local_50);
        uVar6 = g_type_check_instance_cast(iVar5,0x50);
        g_object_set_property(uVar6,"label",&setlabel);
      }
      local_c0 = local_c0 + 1;
    } while (local_c0 != 0x16);
    g_value_unset(&setfalse);
    g_value_unset(&settrue);
    g_value_unset(&setlabel);
    ghidgui->toggle_holdoff = gVar4;
    if ((cVar3 != '\0') && (local_94 != layer_select_button_index)) {
      layer_select_button_cb_hold_off = 1;
      uVar6 = gtk_toggle_button_get_type();
      uVar6 = g_type_check_instance_cast(layer_buttons[local_94].radio_select_button,uVar6);
      gtk_toggle_button_set_active(uVar6,1);
      layer_select_button_index = local_94;
      layer_select_button_cb_hold_off = 0;
    }
  }
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



gint LayersChanged(int argc,char **argv,int px,int py)

{
  if ((ghidgui != (GhidGui *)0x0) && (ghidgui->ui_manager != (GtkUIManager *)0x0)) {
    ghid_config_groups_changed();
    ghid_layer_buttons_update();
    ghid_show_layer_buttons();
    pcb_colors_from_settings(PCB);
  }
  return 0;
}



void layer_enable_button_cb(GtkWidget *widget,gpointer data)

{
  DataTypePtr **ppDVar1;
  Cardinal CVar2;
  Boolean BVar3;
  PCBTypePtr pPVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  int Layer;
  Boolean On;
  DataTypePtr *pDVar8;
  gpointer Layer_00;
  int iVar9;
  bool bVar10;
  
  uVar5 = gtk_toggle_button_get_type();
  uVar6 = g_type_check_instance_cast(widget,uVar5);
  iVar7 = gtk_toggle_button_get_active(uVar6);
  pPVar4 = PCB;
  if (layer_enable_button_cb_hold_off != 0) {
    return;
  }
  On = (Boolean)iVar7;
  switch(data) {
  case (gpointer)0x10:
    PCB->ElementOn = On;
    BVar3 = Settings.ShowSolderSide;
    pDVar8 = pPVar4->Data;
    *(Boolean *)
     (&pDVar8->field_0x90 + ((uint)(Settings.ShowSolderSide == '\0') + pDVar8->LayerN) * 0x5c) = On;
    *(Boolean *)(&pDVar8->field_0x90 + ((uint)(BVar3 != '\0') + pDVar8->LayerN) * 0x5c) = On;
    break;
  case (gpointer)0x11:
    PCB->RatOn = On;
    break;
  case (gpointer)0x12:
    PCB->PinOn = On;
    CVar2 = pPVar4->Data->ElementN;
    goto LAB_081062df;
  case (gpointer)0x13:
    PCB->ViaOn = On;
    CVar2 = pPVar4->Data->ViaN;
LAB_081062df:
    layer_select_button_cb_hold_off = 1;
    layer_enable_button_cb_hold_off = 1;
    ghid_layer_buttons_update();
    if (CVar2 == 0) {
      layer_enable_button_cb_hold_off = 0;
      layer_select_button_cb_hold_off = 0;
      return;
    }
    goto LAB_081063fa;
  case (gpointer)0x14:
    bVar10 = false;
    ppDVar1 = &PCB->Data;
    PCB->InvisibleObjectsOn = On;
    if (iVar7 != 0) {
      bVar10 = pPVar4->ElementOn != '\0';
    }
    *(bool *)(&(*ppDVar1)->field_0x90 +
             ((uint)(Settings.ShowSolderSide != '\0') + (*ppDVar1)->LayerN) * 0x5c) = bVar10;
    break;
  case (gpointer)0x15:
    if (iVar7 == 0) {
      (PCB->Flags).f = (PCB->Flags).f & 0xffffdfff;
    }
    else {
      (PCB->Flags).f = (PCB->Flags).f | 0x2000;
    }
    break;
  default:
    iVar7 = GetGroupOfLayer((int)data);
    if (PCB->SilkActive == '\0') {
      Layer = PCB->Data->LayerN;
      iVar9 = LayerStack[0];
    }
    else {
      Layer = PCB->Data->LayerN;
      iVar9 = (uint)(Settings.ShowSolderSide == '\0') + Layer;
    }
    if (iVar9 < Layer) {
      Layer = iVar9;
    }
    Layer = GetGroupOfLayer(Layer);
    if (iVar7 == Layer) {
      pDVar8 = PCB->Data;
      Layer = pDVar8->LayerN;
      Layer_00 = (gpointer)(((int)data + 1) % (Layer + 1));
      do {
        if (data == Layer_00) {
          g_type_check_instance_cast(widget,uVar5);
          gtk_toggle_button_set_active();
          return;
        }
        if (*(char *)(&pDVar8->field_0x90 + (int)Layer_00 * 0x5c) == '\x01') {
          Layer = GetGroupOfLayer((int)Layer_00);
          if (iVar7 != Layer) {
            ChangeGroupVisibility((int)Layer_00,'\x01','\x01');
            break;
          }
          pDVar8 = PCB->Data;
          Layer = pDVar8->LayerN;
        }
        Layer_00 = (gpointer)(((int)Layer_00 + 1) % (Layer + 1));
      } while( true );
    }
    ChangeGroupVisibility((int)data,On,'\0');
  }
  layer_select_button_cb_hold_off = 1;
  layer_enable_button_cb_hold_off = 1;
  ghid_layer_buttons_update();
LAB_081063fa:
  layer_select_button_cb_hold_off = 0;
  layer_enable_button_cb_hold_off = 0;
  ghid_invalidate_all();
  return;
}



void layer_select_button_cb(GtkWidget *widget,LayerButtonSet *lb)

{
  PCBTypePtr pPVar1;
  gboolean in_cb;
  undefined4 uVar2;
  int Layer;
  
  uVar2 = gtk_toggle_button_get_type();
  uVar2 = g_type_check_instance_cast(widget,uVar2);
  Layer = gtk_toggle_button_get_active(uVar2);
  pPVar1 = PCB;
  if (((Layer != 0) && (layer_select_button_cb_hold_off == 0)) && (in_cb == 0)) {
    Layer = lb->index;
    in_cb = 1;
    *(bool *)&PCB->SilkActive = Layer == 0x10;
    *(bool *)&pPVar1->RatDraw = Layer == 0x11;
    if (Layer < pPVar1->Data->LayerN) {
      ChangeGroupVisibility(Layer,'\x01','\x01');
      Layer = lb->index;
    }
    layer_select_button_cb_hold_off = 1;
    layer_enable_button_cb_hold_off = 1;
    layer_select_button_index = Layer;
    ghid_layer_buttons_update();
    layer_select_button_cb_hold_off = 0;
    layer_enable_button_cb_hold_off = 0;
    ghid_invalidate_all();
  }
  return;
}



void ghid_sync_with_new_layout(void)

{
  pcb_use_route_style(PCB->RouteStyle);
  ghid_route_style_button_set_active(0);
  ghid_config_handle_units_changed();
  ghid_set_status_line_label();
  return;
}



void ghid_grid_setting_update_menu_actions(void)

{
  GhidGui *pGVar1;
  GtkActionGroup *pGVar2;
  int iVar3;
  gdouble *pgVar4;
  
  if (ghidgui->grid_actions != (GtkActionGroup *)0x0) {
    gtk_ui_manager_remove_action_group(ghidgui->ui_manager,ghidgui->grid_actions);
    g_object_unref(ghidgui->grid_actions);
  }
  pGVar1 = ghidgui;
  pGVar2 = (GtkActionGroup *)gtk_action_group_new("GridActions");
  pGVar1->grid_actions = pGVar2;
  gtk_action_group_set_translation_domain(ghidgui->grid_actions,0);
  gtk_ui_manager_insert_action_group(ghidgui->ui_manager,ghidgui->grid_actions,0);
  pgVar4 = grid_mil_values;
  if (Settings.grid_units_mm != '\0') {
    pgVar4 = grid_mm_values;
  }
  iVar3 = 0;
  do {
    if ((PCB->Grid < (double)pgVar4[iVar3] + 1.00000000) &&
       ((double)pgVar4[iVar3] - 1.00000000 < PCB->Grid)) goto LAB_081066dc;
    iVar3 = iVar3 + 1;
  } while (iVar3 != 0xb);
  iVar3 = -1;
LAB_081066dc:
  if (Settings.grid_units_mm == '\0') {
    gtk_action_group_add_radio_actions
              (ghidgui->grid_actions,radio_grid_mil_setting_entries,0xc,iVar3,
               radio_grid_mil_setting_cb,0);
  }
  else {
    gtk_action_group_add_radio_actions
              (ghidgui->grid_actions,radio_grid_mm_setting_entries,0xc,iVar3,
               radio_grid_mm_setting_cb,0);
  }
  iVar3 = gtk_action_group_get_action(ghidgui->grid_actions,"grid-user");
  if (iVar3 != 0) {
    g_object_set(iVar3,"sensitive",0,0);
  }
  return;
}



void grid_units_button_cb(GtkWidget *widget,gpointer data)

{
  gdouble gVar1;
  int iVar2;
  undefined4 uVar3;
  gdouble *pgVar4;
  
  pgVar4 = grid_mil_values;
  if (Settings.grid_units_mm != '\0') {
    pgVar4 = grid_mm_values;
  }
  iVar2 = 0;
  do {
    if ((PCB->Grid < (double)pgVar4[iVar2] + 1.00000000) &&
       ((double)pgVar4[iVar2] - 1.00000000 < PCB->Grid)) goto LAB_081067f4;
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0xb);
  iVar2 = 10;
LAB_081067f4:
  Settings.grid_units_mm = Settings.grid_units_mm == '\0';
  if ((bool)Settings.grid_units_mm) {
    gVar1 = grid_mm_values[iVar2];
  }
  else {
    gVar1 = grid_mil_values[iVar2];
  }
  *(gdouble *)&PCB->Grid = gVar1;
  ghid_grid_setting_update_menu_actions();
  uVar3 = g_strdup_printf(0x81514cf,PCB->Grid);
  hid_actionl("SetValue",0x813a646,uVar3,&DAT_0814741b,0);
  g_free(uVar3);
  ghid_config_handle_units_changed();
  ghid_set_status_line_label();
  return;
}



void radio_grid_mil_setting_cb(GtkAction *action,GtkRadioAction *current)

{
  int iVar1;
  undefined4 uVar2;
  
  __printf_chk(1,"radio_grid_mil_setting_cb()\n");
  if (ghidgui->toggle_holdoff != 0) {
    return;
  }
  iVar1 = gtk_radio_action_get_current_value(current);
  uVar2 = g_strdup_printf(0x81514cf,grid_mil_values[iVar1]);
  hid_actionl("SetValue",0x813a646,uVar2,&DAT_0814741b,0);
  g_free(uVar2);
  ghid_set_status_line_label();
  return;
}



void radio_grid_mm_setting_cb(GtkAction *action,GtkRadioAction *current)

{
  int iVar1;
  undefined4 uVar2;
  
  __printf_chk(1,"radio_grid_mm_setting_cb()\n");
  if (ghidgui->toggle_holdoff != 0) {
    return;
  }
  iVar1 = gtk_radio_action_get_current_value(current);
  uVar2 = g_strdup_printf(0x81514cf,grid_mm_values[iVar1]);
  hid_actionl("SetValue",0x813a646,uVar2,&DAT_0814741b,0);
  g_free(uVar2);
  ghid_set_status_line_label();
  return;
}



void ghid_update_toggle_flags(void)

{
  int iVar1;
  gboolean gVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GValue *local_c4;
  int iVar6;
  int iVar7;
  int iVar8;
  int local_b8;
  int in_GS_OFFSET;
  undefined *local_c0;
  char *local_bc;
  undefined4 local_90;
  GValue setlabel;
  GValue settrue;
  GValue setfalse;
  char tmpnm [40];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  setfalse.g_type = 0;
  setfalse.data[0]._0_4_ = 0;
  setfalse.data[0]._4_4_ = 0;
  setfalse.data[1]._0_4_ = 0;
  setfalse.data[1]._4_4_ = 0;
  settrue.g_type = 0;
  settrue.data[0]._0_4_ = 0;
  settrue.data[0]._4_4_ = 0;
  settrue.data[1]._0_4_ = 0;
  settrue.data[1]._4_4_ = 0;
  setlabel.g_type = 0;
  setlabel.data[0]._0_4_ = 0;
  setlabel.data[0]._4_4_ = 0;
  setlabel.data[1]._0_4_ = 0;
  setlabel.data[1]._4_4_ = 0;
  g_value_init(&setfalse,0x14);
  g_value_init(&settrue,0x14);
  g_value_set_boolean(&setfalse,0);
  g_value_set_boolean(&settrue,1);
  g_value_init(&setlabel,0x40);
  gVar2 = ghidgui->toggle_holdoff;
  ghidgui->toggle_holdoff = 1;
  if (n_tflags < 1) {
    local_90 = gtk_toggle_action_get_type();
  }
  else {
    local_90 = gtk_toggle_action_get_type();
    iVar7 = 0;
    local_b8 = 0;
LAB_08106b77:
    do {
      iVar6 = (int)&tflags->actionname + iVar7;
      iVar8 = *(int *)(iVar6 + 8);
      if (iVar8 == 0) {
        iVar8 = hid_get_flag(*(char **)(iVar6 + 4));
        uVar3 = gtk_action_group_get_action
                          (ghidgui->main_actions,*(undefined4 *)((int)&tflags->actionname + iVar7));
        local_c4 = &setfalse;
        if (iVar8 != 0) {
          local_c4 = &settrue;
        }
        uVar3 = g_type_check_instance_cast(uVar3,0x50);
        g_object_set_property(uVar3,"sensitive",local_c4);
        *(int *)((int)&tflags->oldval + iVar7) = iVar8;
      }
      else {
        if (iVar8 != 1) {
          local_b8 = local_b8 + 1;
          iVar7 = iVar7 + 0x14;
          __printf_chk(1,"Skipping flagtype %d\n",iVar8);
          if (n_tflags <= local_b8) break;
          goto LAB_08106b77;
        }
        iVar8 = hid_get_flag(*(char **)(iVar6 + 4));
        uVar3 = gtk_action_group_get_action
                          (ghidgui->main_actions,*(undefined4 *)((int)&tflags->actionname + iVar7));
        uVar3 = g_type_check_instance_cast(uVar3,local_90);
        gtk_toggle_action_set_active(uVar3,(uint)(iVar8 != 0));
        *(int *)((int)&tflags->oldval + iVar7) = iVar8;
      }
      local_b8 = local_b8 + 1;
      iVar7 = iVar7 + 0x14;
    } while (local_b8 < n_tflags);
  }
  local_b8 = 0;
  local_bc = "RouteStyle";
  local_c0 = &DAT_08139f46;
  local_c4 = (GValue *)&DAT_00000028;
  __sprintf_chk(tmpnm,1,0x28,&DAT_08139f46,"RouteStyle",0);
  uVar3 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
  uVar4 = gtk_toggle_button_get_type();
  iVar7 = 0;
  while( true ) {
    iVar8 = iVar7 + 1;
    uVar5 = g_type_check_instance_cast
                      (route_style_button[iVar7].button,uVar4,local_c4,local_c0,local_bc,local_b8);
    uVar5 = gtk_toggle_button_get_active(uVar5);
    uVar3 = g_type_check_instance_cast(uVar3,local_90);
    gtk_toggle_action_set_active(uVar3,uVar5);
    if (iVar8 == 7) break;
    local_bc = "RouteStyle";
    local_c0 = &DAT_08139f46;
    local_c4 = (GValue *)&DAT_00000028;
    local_b8 = iVar8;
    __sprintf_chk(tmpnm,1);
    uVar3 = gtk_action_group_get_action(ghidgui->main_actions,tmpnm);
    iVar7 = iVar8;
    if (3 < iVar8) {
      uVar5 = g_type_check_instance_cast(uVar3,0x50,local_c4,local_c0,local_bc,local_b8);
      local_c4 = &setfalse;
      g_object_set_property(uVar5,0x8154f0b);
    }
  }
  g_value_unset(&setfalse);
  g_value_unset(&settrue);
  g_value_unset(&setlabel);
  ghidgui->toggle_holdoff = gVar2;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ghid_menu_cb(GtkAction *action,gpointer data)

{
  char "ghid_menu_cb" [13];
  int in_cb;
  char *pcVar1;
  long n;
  int iVar2;
  int *piVar3;
  gboolean gVar4;
  char *pcVar5;
  int iVar6;
  char *pcVar7;
  Resource *pRVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  if (in_cb != 0) {
    return;
  }
  in_cb = 1;
  pcVar1 = (char *)data;
  if (action != (GtkAction *)0x0) {
    pcVar1 = (char *)gtk_action_get_name(action);
  }
  bVar9 = pcVar1 == (char *)0x0;
  if (bVar9) {
    __fprintf_chk(stderr,1,"%s(%p, %p):  name == NULL\n","ghid_menu_cb",action,data);
    return;
  }
  iVar2 = 8;
  pcVar5 = pcVar1;
  pcVar7 = "MenuItem";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar9 = *pcVar5 == *pcVar7;
    pcVar5 = pcVar5 + (uint)bVar10 * -2 + 1;
    pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
  } while (bVar9);
  if (bVar9) {
    n = strtol(pcVar1 + 8,(char **)0x0,10);
    pRVar8 = action_resources[n];
LAB_08106efc:
    if (pRVar8 != (Resource *)0x0) {
      iVar6 = 0xc;
      iVar2 = 1;
      if (1 < pRVar8->c) {
        do {
          while( true ) {
            piVar3 = (int *)((int)&pRVar8->v->name + iVar6);
            if ((~-(uint)(*piVar3 == 0) & 100) + (uint)(piVar3[2] != 0) +
                (~-(uint)((char *)piVar3[1] == (char *)0x0) & 10) != 10) break;
            iVar2 = iVar2 + 1;
            iVar6 = iVar6 + 0xc;
            hid_parse_actions((char *)piVar3[1],(anon_subr_int_char_ptr_int_char_ptr_ptr *)0x0);
            if (pRVar8->c == iVar2 || pRVar8->c < iVar2) goto LAB_08106f78;
          }
          iVar2 = iVar2 + 1;
          iVar6 = iVar6 + 0xc;
        } while (pRVar8->c != iVar2 && iVar2 <= pRVar8->c);
      }
    }
LAB_08106f78:
    gVar4 = ghidgui->toggle_holdoff;
  }
  else {
    iVar2 = 9;
    pcVar5 = pcVar1;
    pcVar7 = "TMenuItem";
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      bVar9 = *pcVar5 == *pcVar7;
      pcVar5 = pcVar5 + (uint)bVar10 * -2 + 1;
      pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      n = strtol(pcVar1 + 9,(char **)0x0,10);
      if (ghidgui->toggle_holdoff != 1) {
        pRVar8 = toggle_action_resources[n];
        goto LAB_08106efc;
      }
    }
    else {
      iVar2 = 9;
      pcVar5 = pcVar1;
      pcVar7 = "LayerPick";
      do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        bVar9 = *pcVar5 == *pcVar7;
        pcVar5 = pcVar5 + (uint)bVar10 * -2 + 1;
        pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      if (bVar9) {
        n = strtol(pcVar1 + 9,(char **)0x0,10);
        if (ghidgui->toggle_holdoff != 1) {
          pRVar8 = layerpick_resources[n];
          goto LAB_08106efc;
        }
      }
      else {
        iVar2 = 9;
        pcVar5 = pcVar1;
        pcVar7 = "LayerView";
        do {
          if (iVar2 == 0) break;
          iVar2 = iVar2 + -1;
          bVar9 = *pcVar5 == *pcVar7;
          pcVar5 = pcVar5 + (uint)bVar10 * -2 + 1;
          pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
        } while (bVar9);
        if (bVar9) {
          n = strtol(pcVar1 + 9,(char **)0x0,10);
          if (ghidgui->toggle_holdoff != 1) {
            pRVar8 = layerview_resources[n];
            goto LAB_08106efc;
          }
        }
        else {
          iVar2 = 10;
          pcVar5 = pcVar1;
          pcVar7 = "RouteStyle";
          do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar9 = *pcVar5 == *pcVar7;
            pcVar5 = pcVar5 + (uint)bVar10 * -2 + 1;
            pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
          } while (bVar9);
          if (!bVar9) {
            __fprintf_chk(stderr,1,"ERROR:  ghid_menu_cb():  name = \"%s\" is unknown\n",pcVar1);
            gVar4 = ghidgui->toggle_holdoff;
            goto LAB_08106fc8;
          }
          n = strtol(pcVar1 + 10,(char **)0x0,10);
          if (ghidgui->toggle_holdoff != 1) {
            ghid_route_style_button_set_active(n);
            gVar4 = ghidgui->toggle_holdoff;
            goto LAB_08106fc8;
          }
        }
      }
    }
    gVar4 = 1;
  }
LAB_08106fc8:
  ghidgui->toggle_holdoff = 1;
  ghid_update_toggle_flags();
  ghidgui->toggle_holdoff = gVar4;
  in_cb = 0;
  if (gVar4 != 0) {
    return;
  }
  HideCrosshair('\x01');
  AdjustAttachedObjects();
  ghid_invalidate_all();
  RestoreCrosshair('\x01');
  ghid_screen_update();
  ghid_set_status_line_label();
  return;
}



void ghid_hotkey_cb(int which)

{
  if (ghid_hotkey_actions[which] != (char *)0x0) {
    ghid_menu_cb((GtkAction *)0x0,ghid_hotkey_actions[which]);
  }
  return;
}



void __regparm3 ghid_append_action(char *name,char *label,char *accelerator,char *tooltip)

{
  gint gVar1;
  char *local_34;
  gchar *pgVar2;
  GtkActionEntry *pGVar3;
  GtkActionEntry *pGVar4;
  
  local_34 = ghid_check_unique_accel(accelerator);
  new_entries = (GtkActionEntry *)realloc(new_entries,(menuitem_cnt * 3 + 3) * 8);
  if (new_entries == (GtkActionEntry *)0x0) {
    local_34 = "ghid_append_action():  realloc of new_entries failed\n";
  }
  else {
    action_resources = (Resource **)realloc(action_resources,menuitem_cnt * 4 + 4);
    gVar1 = menuitem_cnt;
    if (action_resources != (Resource **)0x0) {
      action_resources[menuitem_cnt] = (Resource *)0x0;
      pGVar3 = new_entries + gVar1;
      pgVar2 = (gchar *)__strdup(name);
      pGVar3->name = pgVar2;
      pGVar3 = new_entries + menuitem_cnt;
      pGVar3->stock_id = (gchar *)0x0;
      pgVar2 = (gchar *)__strdup(label);
      pGVar3->label = pgVar2;
      pGVar3 = new_entries + menuitem_cnt;
      if ((local_34 == (char *)0x0) || (*local_34 == '\0')) {
        pgVar2 = (gchar *)0x0;
        pGVar4 = pGVar3;
      }
      else {
        pgVar2 = (gchar *)__strdup(local_34);
        pGVar4 = new_entries + menuitem_cnt;
      }
      pGVar3->accelerator = pgVar2;
      pgVar2 = (gchar *)0x0;
      pGVar3 = pGVar4;
      if (tooltip != (char *)0x0) {
        pgVar2 = (gchar *)__strdup(tooltip);
        pGVar3 = new_entries + menuitem_cnt;
      }
      pGVar4->tooltip = pgVar2;
      pGVar3->callback = ghid_menu_cb;
      ghid_check_special_key(local_34,name);
      menuitem_cnt = menuitem_cnt + 1;
      return;
    }
    local_34 = "ghid_append_action():  realloc of action_resources failed\n";
  }
  __fprintf_chk(stderr,1,local_34);
                    // WARNING: Subroutine does not return
  exit(1);
}



void __regparm3 add_resource_to_menu(Resource *node,int indent)

{
  int iVar1;
  gint gVar2;
  char "add_resource_to_menu" [21];
  char cVar3;
  char *local_104;
  Resource *res;
  size_t sVar4;
  char *local_108;
  char *tooltip;
  gchar *pgVar5;
  char cVar6;
  int *piVar7;
  gint gVar8;
  GtkToggleActionEntry *pGVar9;
  GtkToggleActionEntry *pGVar10;
  int iVar11;
  int iVar12;
  char **ppcVar13;
  char *pcVar14;
  int in_GS_OFFSET;
  bool bVar15;
  bool bVar16;
  byte bVar17;
  int local_e0;
  char *local_d8;
  char local_d1;
  char *local_cc;
  ResourceVal *local_c4;
  int local_bc;
  int local_b4;
  int local_b0;
  char ch [2];
  char accel [64];
  char tmpid [40];
  char tmps [32];
  
  bVar17 = 0;
  ch[1] = '\0';
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (0 < node->c) {
    local_b4 = 0;
    local_d1 = '\0';
    local_cc = (char *)0x0;
    local_d8 = (char *)0x0;
    local_bc = 0;
    do {
      piVar7 = (int *)((int)&node->v->name + local_b4);
      local_104 = (char *)piVar7[1];
      iVar11 = (~-(uint)(*piVar7 == 0) & 100) + (uint)((Resource *)piVar7[2] != (Resource *)0x0) +
               (~-(uint)(local_104 == (char *)0x0) & 10);
      if (iVar11 == 10) {
        bVar15 = *local_104 == '@';
        if (bVar15) {
          iVar11 = 0xb;
          local_108 = local_104;
          tooltip = "@layerview";
          do {
            if (iVar11 == 0) break;
            iVar11 = iVar11 + -1;
            bVar15 = *local_108 == *tooltip;
            local_108 = local_108 + (uint)bVar17 * -2 + 1;
            tooltip = tooltip + (uint)bVar17 * -2 + 1;
          } while (bVar15);
          if (bVar15) {
            iVar11 = 0;
            do {
              iVar12 = iVar11 + 1;
              __sprintf_chk(tmpid,1,0x28,"<menuitem action=\'%s%d\' />\n","LayerView",iVar11);
              ghid_ui_info_indent(indent);
              ghid_ui_info_append(tmpid);
              iVar11 = iVar12;
            } while (iVar12 != 0x16);
          }
          else {
            iVar11 = 0xb;
            local_108 = local_104;
            tooltip = "@layerpick";
            do {
              if (iVar11 == 0) break;
              iVar11 = iVar11 + -1;
              bVar15 = *local_108 == *tooltip;
              local_108 = local_108 + (uint)bVar17 * -2 + 1;
              tooltip = tooltip + (uint)bVar17 * -2 + 1;
            } while (bVar15);
            if (bVar15) {
              iVar11 = 0;
              do {
                iVar12 = iVar11 + 1;
                __sprintf_chk(tmpid,1,0x28,"<menuitem action=\'%s%d\' />\n","LayerPick",iVar11);
                ghid_ui_info_indent(indent);
                ghid_ui_info_append(tmpid);
                iVar11 = iVar12;
              } while (iVar12 != 0x12);
            }
            else {
              iVar11 = 0xd;
              local_108 = local_104;
              tooltip = "@routestyles";
              do {
                if (iVar11 == 0) break;
                iVar11 = iVar11 + -1;
                bVar15 = *local_108 == *tooltip;
                local_108 = local_108 + (uint)bVar17 * -2 + 1;
                tooltip = tooltip + (uint)bVar17 * -2 + 1;
              } while (bVar15);
              if (bVar15) {
                iVar11 = 0;
                do {
                  iVar12 = iVar11 + 1;
                  __sprintf_chk(tmpid,1,0x28,"<menuitem action=\'%s%d\' />\n","RouteStyle",iVar11);
                  ghid_ui_info_indent(indent);
                  ghid_ui_info_append(tmpid);
                  iVar11 = iVar12;
                } while (iVar12 != 7);
              }
              else {
                Message("GTK GUI currently ignores \"%s\" in the menu\n",local_104);
                Message("resource file.\n");
              }
            }
          }
        }
        else {
          if ((*local_104 == '-') && (local_104[1] == '\0')) {
            ghid_ui_info_indent(indent);
            ghid_ui_info_append("<separator/>\n");
          }
          else {
            if (local_bc != 0) {
              __sprintf_chk(tmps,1,0x20,&DAT_08139f46,0x8155839,menuitem_cnt);
              local_d8 = (char *)__strdup(tmps);
              ghid_append_action(tmps,*(char **)((int)&node->v->value + local_b4),accel,(char *)0x0)
              ;
              ghid_ui_info_indent(indent);
              ghid_ui_info_append("<menuitem action=\'");
              ghid_ui_info_append(tmps);
              ghid_ui_info_append("\'/>\n");
              action_resources[menuitem_cnt + -1] = (Resource *)0x0;
            }
          }
        }
      }
      else {
        if (iVar11 == 0x65) {
          add_resource_to_menu((Resource *)piVar7[2],indent + 5);
        }
        else {
          if (iVar11 == 1) {
            accel[0] = '\0';
            local_104 = resource_value(*(Resource **)((int)&node->v->subres + local_b4),"m");
            if (local_104 != (char *)0x0) {
              local_d1 = *local_104;
            }
            res = resource_subres(*(Resource **)((int)&node->v->subres + local_b4),"a");
            if (res != (Resource *)0x0) {
              bVar15 = true;
              local_104 = res->v[1].value;
LAB_08107480:
              cVar3 = *local_104;
              if (cVar3 != '\0') {
                while (bVar15) {
                  bVar16 = cVar3 == ' ';
                  if (bVar16) {
                    local_104 = local_104 + 1;
                    goto LAB_08107480;
                  }
                  iVar11 = 5;
                  local_108 = local_104;
                  tooltip = "<Key>";
                  do {
                    if (iVar11 == 0) break;
                    iVar11 = iVar11 + -1;
                    bVar16 = *local_108 == *tooltip;
                    local_108 = local_108 + (uint)bVar17 * -2 + 1;
                    tooltip = tooltip + (uint)bVar17 * -2 + 1;
                  } while (bVar16);
                  if (bVar16) goto LAB_0810772e;
                  iVar11 = 4;
                  local_108 = local_104;
                  tooltip = "Ctrl";
                  do {
                    if (iVar11 == 0) break;
                    iVar11 = iVar11 + -1;
                    bVar16 = *local_108 == *tooltip;
                    local_108 = local_108 + (uint)bVar17 * -2 + 1;
                    tooltip = tooltip + (uint)bVar17 * -2 + 1;
                  } while (bVar16);
                  if (bVar16) {
                    local_104 = local_104 + 4;
                    __strncat_chk(accel,"<control>",0x40,0x40);
                    goto LAB_08107480;
                  }
                  iVar11 = 5;
                  local_108 = local_104;
                  tooltip = "Shift";
                  do {
                    if (iVar11 == 0) break;
                    iVar11 = iVar11 + -1;
                    bVar16 = *local_108 == *tooltip;
                    local_108 = local_108 + (uint)bVar17 * -2 + 1;
                    tooltip = tooltip + (uint)bVar17 * -2 + 1;
                  } while (bVar16);
                  if (bVar16) {
                    local_104 = local_104 + 5;
                    __strncat_chk(accel,"<shift>",0x40,0x40);
                    goto LAB_08107480;
                  }
                  iVar11 = 3;
                  local_108 = local_104;
                  tooltip = "Alt";
                  do {
                    if (iVar11 == 0) break;
                    iVar11 = iVar11 + -1;
                    bVar16 = *local_108 == *tooltip;
                    local_108 = local_108 + (uint)bVar17 * -2 + 1;
                    tooltip = tooltip + (uint)bVar17 * -2 + 1;
                  } while (bVar16);
                  if (!bVar16) {
                    local_108 = local_104;
                    Message(
                            "Don\'t know how to parse \"%s\" as an accelerator in the menu resource file.\n"
                            ,local_104);
                    if (gave_msg == 0) {
                      gave_msg = 1;
                      Message(
                              "Format is:\nmodifiers<Key>k\nwhere \"modifiers\" is a space separated list of key modifiers\nand \"k\" is the name of the key.\nAllowed modifiers are:\n   Ctrl\n   Shift\n   Alt\nPlease note that case is important.\n"
                              ,local_108);
                    }
                    accel[0] = '\0';
                    sVar4 = strlen(local_104);
                    local_104 = local_104 + sVar4;
                    goto LAB_08107480;
                  }
                  local_104 = local_104 + 3;
                  __strncat_chk(accel,"<alt>",0x40,0x40);
                  cVar3 = *local_104;
                  if (cVar3 == '\0') goto LAB_08107530;
                }
                iVar11 = 5;
                local_108 = local_104;
                tooltip = "Enter";
                do {
                  if (iVar11 == 0) break;
                  iVar11 = iVar11 + -1;
                  bVar15 = *local_108 == *tooltip;
                  local_108 = local_108 + (uint)bVar17 * -2 + 1;
                  tooltip = tooltip + (uint)bVar17 * -2 + 1;
                } while (bVar15);
                if (bVar15) {
                  __strncat_chk(accel,"Return",0x40,0x40);
LAB_0810772e:
                  local_104 = local_104 + 5;
                  bVar15 = false;
                }
                else {
                  iVar11 = 0;
                  do {
                    ch[0] = cVar3;
                    if (key_table[iVar11].in == *local_104) {
                      __strncat_chk(accel,key_table[iVar11].out,0x40,0x40);
                      goto LAB_081076fe;
                    }
                    iVar11 = iVar11 + 1;
                  } while (iVar11 != 7);
                  __strncat_chk(accel,ch,0x40,0x40);
LAB_081076fe:
                  local_104 = local_104 + 1;
                  bVar15 = false;
                }
                goto LAB_08107480;
              }
            }
LAB_08107530:
            iVar11 = *(int *)((int)&node->v->subres + local_b4);
            iVar12 = *(int *)(iVar11 + 0xc);
            if (0 < iVar12) {
              piVar7 = *(int **)(iVar11 + 0x10);
              iVar11 = 0;
              do {
                local_104 = (char *)piVar7[1];
                if ((~-(uint)(*piVar7 == 0) & 100) + (uint)(piVar7[2] != 0) +
                    (~-(uint)(local_104 == (char *)0x0) & 10) == 10) goto joined_r0x081075b5;
                iVar11 = iVar11 + 1;
                piVar7 = piVar7 + 3;
              } while (iVar11 < iVar12);
            }
            local_104 = "button";
joined_r0x081075b5:
            if (local_d1 == '\0') {
              local_cc = (char *)__strdup(local_104);
            }
            else {
              sVar4 = strlen(local_104);
              local_cc = (char *)calloc(1,sVar4 + 2);
              if (local_cc == (char *)0x0) {
                local_104 = "add_resource_to_menu():  malloc failed\n";
                goto LAB_081080c9;
              }
              cVar3 = *local_104;
              local_108 = local_cc;
              while (cVar3 != '\0') {
                while (local_d1 == cVar3) {
                  *local_108 = '_';
                  cVar3 = *local_104;
                  local_104 = local_104 + 1;
                  local_d1 = '\0';
                  local_108[1] = cVar3;
                  cVar3 = *local_104;
                  local_108 = local_108 + 2;
                  if (cVar3 == '\0') goto LAB_0810794b;
                }
                local_104 = local_104 + 1;
                *local_108 = cVar3;
                cVar3 = *local_104;
                local_108 = local_108 + 1;
              }
LAB_0810794b:
              *local_108 = '\0';
            }
            res = *(Resource **)((int)&node->v->subres + local_b4);
            if ((*(byte *)&res->flags & 4) == 0) {
              local_108 = resource_value(res,"checked");
              local_104 = resource_value(*(Resource **)((int)&node->v->subres + local_b4),
                                         "sensitive");
              tooltip = resource_value(*(Resource **)((int)&node->v->subres + local_b4),"tip");
              if (local_108 == (char *)0x0) {
                bVar15 = local_104 == (char *)0x0;
                if (!bVar15) {
                  iVar11 = 6;
                  local_108 = "false";
                  do {
                    if (iVar11 == 0) break;
                    iVar11 = iVar11 + -1;
                    bVar15 = *local_104 == *local_108;
                    local_104 = local_104 + (uint)bVar17 * -2 + 1;
                    local_108 = local_108 + (uint)bVar17 * -2 + 1;
                  } while (bVar15);
                  if (bVar15) {
                    local_c4 = node->v;
                    goto LAB_08107b7c;
                  }
                }
                __sprintf_chk(tmps,1,0x20,&DAT_08139f46,0x8155839,menuitem_cnt);
                local_d8 = (char *)__strdup(tmps);
                ghid_append_action(tmps,local_cc,accel,tooltip);
                ghid_ui_info_indent(indent);
                ghid_ui_info_append("<menuitem action=\'");
                ghid_ui_info_append(tmps);
                ghid_ui_info_append("\'/>\n");
                local_c4 = node->v;
                action_resources[menuitem_cnt + -1] =
                     *(Resource **)((int)&local_c4->subres + local_b4);
              }
              else {
                __sprintf_chk(tmps,1,0x20,&DAT_08139f46,"TMenuItem",tmenuitem_cnt);
                local_d8 = (char *)__strdup(tmps);
                local_104 = ghid_check_unique_accel(accel);
                new_toggle_entries =
                     (GtkToggleActionEntry *)realloc(new_toggle_entries,(tmenuitem_cnt + 1) * 0x1c);
                if (new_toggle_entries == (GtkToggleActionEntry *)0x0) {
                  local_104 = "ghid_append_toggle_action():  realloc of new_toggle_entries failed\n"
                  ;
LAB_081080c9:
                  __fprintf_chk(stderr,1,local_104);
                    // WARNING: Subroutine does not return
                  exit(1);
                }
                toggle_action_resources =
                     (Resource **)realloc(toggle_action_resources,tmenuitem_cnt * 4 + 4);
                gVar8 = tmenuitem_cnt;
                if (toggle_action_resources == (Resource **)0x0) {
                  local_104 = 
                  "ghid_append_toggle_action():  realloc of toggle_action_resources failed\n";
                  goto LAB_081080c9;
                }
                toggle_action_resources[tmenuitem_cnt] = (Resource *)0x0;
                pGVar9 = new_toggle_entries + gVar8;
                pgVar5 = (gchar *)__strdup(tmps);
                pGVar9->name = pgVar5;
                pGVar9 = new_toggle_entries;
                gVar8 = tmenuitem_cnt;
                new_toggle_entries[tmenuitem_cnt].stock_id = (gchar *)0x0;
                pgVar5 = (gchar *)__strdup(local_cc);
                pGVar10 = new_toggle_entries;
                gVar2 = tmenuitem_cnt;
                pGVar9[gVar8].label = pgVar5;
                pgVar5 = (gchar *)0x0;
                gVar8 = gVar2;
                pGVar9 = pGVar10;
                if (local_104 != (char *)0x0) {
                  pgVar5 = (gchar *)__strdup(local_104);
                  gVar8 = tmenuitem_cnt;
                  pGVar9 = new_toggle_entries;
                }
                pGVar10[gVar2].accelerator = pgVar5;
                pgVar5 = (gchar *)0x0;
                iVar11 = gVar8;
                pGVar10 = pGVar9;
                if (tooltip != (char *)0x0) {
                  pgVar5 = (gchar *)__strdup(tooltip);
                  iVar11 = tmenuitem_cnt;
                  pGVar10 = new_toggle_entries;
                }
                pGVar10[iVar11].callback = ghid_menu_cb;
                pGVar10[iVar11].is_active = 1;
                pGVar9[gVar8].tooltip = pgVar5;
                ghid_check_special_key(local_104,tmps);
                tmenuitem_cnt = tmenuitem_cnt + 1;
                ghid_ui_info_indent(indent);
                ghid_ui_info_append("<menuitem action=\'");
                ghid_ui_info_append(tmps);
                ghid_ui_info_append("\'/>\n");
                local_c4 = node->v;
                toggle_action_resources[tmenuitem_cnt + -1] =
                     *(Resource **)((int)&local_c4->subres + local_b4);
              }
LAB_08107b7c:
              iVar11 = *(int *)((int)&local_c4->subres + local_b4);
              if (0 < *(int *)(iVar11 + 0xc)) {
                local_b0 = 0;
                local_e0 = 0;
                do {
                  ppcVar13 = (char **)(local_e0 + *(int *)(iVar11 + 0x10));
                  local_104 = *ppcVar13;
                  local_108 = ppcVar13[1];
                  if ((~-(uint)(local_104 == (char *)0x0) & 100) +
                      (uint)(ppcVar13[2] != (char *)0x0) + (~-(uint)(local_108 == (char *)0x0) & 10)
                      == 0x6e) {
                    cVar3 = *local_104;
                    if (((cVar3 == 'f') && (local_104[1] == 'g')) && (local_104[2] == '\0')) {
                      cVar3 = 'f';
                      local_104 = "foreground";
                    }
                    cVar6 = cVar3;
                    if (((cVar3 == 'b') && (cVar6 = 'b', local_104[1] == 'g')) &&
                       (cVar6 = cVar3, local_104[2] == '\0')) {
                      local_104 = "background";
                      cVar6 = 'b';
                    }
                    if (((cVar6 != 'm') || (local_104[1] != '\0')) &&
                       ((bVar15 = cVar6 == 'a', !bVar15 || (bVar15 = local_104[1] == '\0', !bVar15))
                       )) {
                      iVar11 = 10;
                      tooltip = local_104;
                      pcVar14 = "sensitive";
                      do {
                        if (iVar11 == 0) break;
                        iVar11 = iVar11 + -1;
                        bVar15 = *tooltip == *pcVar14;
                        tooltip = tooltip + (uint)bVar17 * -2 + 1;
                        pcVar14 = pcVar14 + (uint)bVar17 * -2 + 1;
                      } while (bVar15);
                      if ((!bVar15) &&
                         ((((bVar15 = cVar6 == 't', !bVar15 ||
                            (bVar15 = local_104[1] == 'i', !bVar15)) ||
                           (bVar15 = local_104[2] == 'p', !bVar15)) ||
                          (bVar15 = local_104[3] == '\0', !bVar15)))) {
                        iVar11 = 8;
                        tooltip = local_104;
                        pcVar14 = "checked";
                        do {
                          if (iVar11 == 0) break;
                          iVar11 = iVar11 + -1;
                          bVar15 = *tooltip == *pcVar14;
                          tooltip = tooltip + (uint)bVar17 * -2 + 1;
                          pcVar14 = pcVar14 + (uint)bVar17 * -2 + 1;
                        } while (bVar15);
                        if (bVar15) {
                          note_toggle_flag(new_toggle_entries[tmenuitem_cnt + -1].name,
                                           GHID_FLAG_CHECKED,local_108);
                          local_c4 = node->v;
                        }
                        else {
                          iVar11 = 7;
                          tooltip = "active";
                          do {
                            if (iVar11 == 0) break;
                            iVar11 = iVar11 + -1;
                            bVar15 = *local_104 == *tooltip;
                            local_104 = local_104 + (uint)bVar17 * -2 + 1;
                            tooltip = tooltip + (uint)bVar17 * -2 + 1;
                          } while (bVar15);
                          if (bVar15) {
                            if (local_d8 == (char *)0x0) {
                              __printf_chk(1,"WARNING: %s cname == NULL\n","add_resource_to_menu");
                              local_c4 = node->v;
                            }
                            else {
                              note_toggle_flag(local_d8,GHID_FLAG_ACTIVE,local_108);
                              local_c4 = node->v;
                            }
                          }
                          else {
                            Message("The gtk gui currently ignores \"%s\"",local_108);
                            Message(
                                   "as part of a menuitem resource.\nFeel free to provide patches\n"
                                   );
                            local_c4 = node->v;
                          }
                        }
                      }
                    }
                  }
                  local_b0 = local_b0 + 1;
                  local_e0 = local_e0 + 0xc;
                  iVar11 = *(int *)((int)&local_c4->subres + local_b4);
                } while (local_b0 < *(int *)(iVar11 + 0xc));
              }
            }
            else {
              __sprintf_chk(tmps,1,0x20,&DAT_08139f46,0x8155839,menuitem_cnt);
              local_d8 = (char *)__strdup(tmps);
              ghid_append_action(tmps,local_cc,accel,(char *)0x0);
              ghid_ui_info_indent(indent);
              ghid_ui_info_append("<menu action=\'");
              ghid_ui_info_append(tmps);
              ghid_ui_info_append("\'>\n");
              add_resource_to_menu(*(Resource **)((int)&node->v->subres + local_b4),indent + 5);
              ghid_ui_info_indent(indent);
              ghid_ui_info_append("</menu>\n");
            }
          }
        }
      }
      local_bc = local_bc + 1;
      local_b4 = local_b4 + 0xc;
    } while (local_bc < node->c);
    if (local_d8 != (char *)0x0) {
      free(local_d8);
    }
    if (local_cc != (char *)0x0) {
      free(local_cc);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 make_top_menubar(GtkWidget *hbox)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkUIManager *pGVar4;
  GtkActionGroup *pGVar5;
  Resource *n;
  char *value;
  gchar *pgVar6;
  undefined4 uVar7;
  int iVar8;
  GtkToggleActionEntry *pGVar9;
  int iVar10;
  int in_GS_OFFSET;
  int local_a4;
  int local_74;
  char *local_68;
  int local_64;
  char av [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_64 = 0;
  uVar2 = gtk_frame_new(0);
  uVar3 = gtk_box_get_type();
  iVar8 = 0;
  uVar3 = g_type_check_instance_cast(hbox,uVar3);
  gtk_box_pack_start(uVar3,uVar2,0,1,0);
  uVar3 = gtk_frame_get_type();
  uVar3 = g_type_check_instance_cast(uVar2,uVar3);
  gtk_frame_set_shadow_type(uVar3,4);
  pGVar4 = (GtkUIManager *)gtk_ui_manager_new();
  ghidgui->ui_manager = pGVar4;
  pGVar5 = (GtkActionGroup *)gtk_action_group_new(0x81557bc);
  gtk_action_group_set_translation_domain(pGVar5,0);
  ghidgui->main_actions = pGVar5;
  gtk_action_group_add_actions(pGVar5,new_entries,menuitem_cnt,&ghid_port);
  gtk_action_group_add_toggle_actions(pGVar5,new_toggle_entries,tmenuitem_cnt,&ghid_port);
  local_74 = 0;
  do {
    layer_process((gchar **)0x0,&local_68,(int *)0x0,local_74);
    uVar3 = g_strdup_printf(&DAT_08139f46,"LayerView",local_74);
    *(undefined4 *)((int)&layerview_toggle_entries[0].stock_id + iVar8) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].name + iVar8) = uVar3;
    uVar3 = g_strdup(local_68);
    *(undefined4 *)((int)&layerview_toggle_entries[0].accelerator + iVar8) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].tooltip + iVar8) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].callback + iVar8) = 0x8106db0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].is_active + iVar8) = 0;
    *(undefined4 *)((int)&layerview_toggle_entries[0].label + iVar8) = uVar3;
    n = resource_create((Resource *)0x0);
    iVar10 = local_74 + 1;
    __sprintf_chk(av,1,0x40,"ToggleView(%d)",iVar10);
    value = (char *)__strdup(av);
    resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
    value = (char *)__strdup(av);
    resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
    n->flags = n->flags | 1;
    *(Resource **)(&DAT_0818e8dc + iVar10 * 4) = n;
    local_a4 = local_74;
    uVar3 = g_strdup_printf(&DAT_08139f46,"LayerPick",local_74);
    *(undefined4 *)((int)&layerpick_toggle_entries[0].stock_id + iVar8) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].name + iVar8) = uVar3;
    uVar3 = g_strdup(local_68);
    *(undefined4 *)((int)&layerpick_toggle_entries[0].accelerator + iVar8) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].tooltip + iVar8) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].callback + iVar8) = 0x8106db0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].is_active + iVar8) = 0;
    *(undefined4 *)((int)&layerpick_toggle_entries[0].label + iVar8) = uVar3;
    n = resource_create((Resource *)0x0);
    if (local_74 == 0x10) {
      __sprintf_chk(av,1,0x40,"SelectLayer(Silk) LayersChanged()");
    }
    else {
      if (local_74 == 0x11) {
        __sprintf_chk(av,1,0x40,"SelectLayer(Rats) LayersChanged()");
      }
      else {
        if (local_74 < 9) {
          uVar3 = g_strdup_printf("<Key>%d",iVar10,local_a4);
          *(undefined4 *)((int)&layerpick_toggle_entries[0].accelerator + iVar8) = uVar3;
        }
        __sprintf_chk(av,1,0x40,"SelectLayer(%d) LayersChanged()",iVar10);
      }
    }
    iVar8 = iVar8 + 0x1c;
    value = (char *)__strdup(av);
    resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
    value = (char *)__strdup(av);
    resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
    n->flags = n->flags | 1;
    *(Resource **)(&DAT_0818ebbc + iVar10 * 4) = n;
    local_74 = iVar10;
  } while (iVar10 != 0x16);
  pGVar9 = routestyle_toggle_entries;
  iVar8 = 0;
  do {
    pgVar6 = (gchar *)g_strdup_printf(&DAT_08139f46,"RouteStyle",iVar8);
    pGVar9->stock_id = (gchar *)0x0;
    pGVar9->name = pgVar6;
    if ((iVar8 < 4) && (PCB != (PCBTypePtr)0x0)) {
      pgVar6 = (gchar *)g_strdup(PCB->RouteStyle[iVar8].Name);
      pGVar9->label = pgVar6;
    }
    else {
      pgVar6 = (gchar *)g_strdup(pGVar9->name);
      pGVar9->label = pgVar6;
    }
    pGVar9->accelerator = (gchar *)0x0;
    iVar8 = iVar8 + 1;
    pGVar9->tooltip = (gchar *)0x0;
    pGVar9->callback = ghid_menu_cb;
    pGVar9->is_active = 0;
    pGVar9 = pGVar9 + 1;
    n = resource_create((Resource *)0x0);
    __sprintf_chk(av,1,0x40,"RouteStyle(%d)",iVar8);
    value = (char *)__strdup(av);
    resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
    value = (char *)__strdup(av);
    resource_add_val(n,(char *)0x0,value,(Resource *)0x0);
    n->flags = n->flags | 1;
    *(Resource **)(&routestyle_toggle_entries[6].is_active + iVar8) = n;
  } while (iVar8 != 7);
  gtk_action_group_add_toggle_actions(pGVar5,layerpick_toggle_entries,0x16,&ghid_port);
  gtk_action_group_add_toggle_actions(pGVar5,layerview_toggle_entries,0x16,&ghid_port);
  gtk_action_group_add_toggle_actions(pGVar5,routestyle_toggle_entries,7,&ghid_port);
  gtk_ui_manager_insert_action_group(pGVar4,pGVar5,0);
  uVar3 = gtk_ui_manager_get_accel_group(pGVar4);
  uVar7 = gtk_window_get_type();
  uVar7 = g_type_check_instance_cast(gport->top_window,uVar7);
  gtk_window_add_accel_group(uVar7,uVar3);
  iVar8 = gtk_ui_manager_add_ui_from_string(pGVar4,new_ui_info,0xffffffff,&local_64);
  if (iVar8 == 0) {
    g_log(0,0x20,"building menus failed: %s",*(undefined4 *)(local_64 + 8));
    g_error_free(local_64);
  }
  gtk_ui_manager_set_add_tearoffs(pGVar4,1);
  uVar3 = gtk_ui_manager_get_widget(pGVar4,"/MenuBar");
  uVar7 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(uVar2,uVar7);
  gtk_container_add(uVar2,uVar3);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x081087ae)
// WARNING: Removing unreachable block (ram,0x081087c9)

void ghid_create_pcb_widgets(void)

{
  int iVar1;
  GhidGui *pGVar2;
  GdkPixbuf *pGVar3;
  undefined4 uVar4;
  GtkWidget *box;
  undefined4 uVar5;
  GtkWidget *hbox;
  int i;
  char *__name;
  Resource *res;
  Resource *node;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  GtkWidget *label;
  GtkWidget *pGVar9;
  gchar *pgVar10;
  undefined4 uVar11;
  GtkObject *pGVar12;
  int *piVar13;
  char *filename;
  RouteStyleButton *pRVar14;
  LayerButtonSet *lb;
  ModeButton *pMVar15;
  int iVar16;
  Resource *res_00;
  int iVar17;
  int in_GS_OFFSET;
  undefined8 local_f4;
  GHidPort *pGVar19;
  longlong lVar18;
  undefined4 uVar20;
  undefined8 local_ec;
  uint uVar21;
  undefined4 local_90;
  undefined4 local_7c;
  int local_78;
  int local_74;
  int local_70;
  GtkWidget *local_64;
  int local_60;
  int local_54;
  gchar *local_50;
  char *local_4c;
  GtkWidget *scrolled;
  gchar buf [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  gdk_color_parse();
  gdk_color_parse();
  pGVar2 = ghidgui;
  if (bg_image_file != (gchar *)0x0) {
    pGVar3 = (GdkPixbuf *)gdk_pixbuf_new_from_file();
    pGVar2->bg_pixbuf = pGVar3;
  }
  gtk_vbox_new();
  uVar4 = gtk_container_get_type();
  g_type_check_instance_cast();
  gtk_container_add();
  box = (GtkWidget *)gtk_hbox_new();
  uVar5 = gtk_box_get_type();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  pGVar2 = ghidgui;
  ghidgui->top_hbox = box;
  box = (GtkWidget *)gtk_hbox_new();
  pGVar2->menu_hbox = box;
  g_type_check_instance_cast();
  gtk_box_pack_start();
  box = (GtkWidget *)gtk_vbox_new();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  hbox = (GtkWidget *)gtk_hbox_new();
  g_type_check_instance_cast();
  uVar6 = 0;
  gtk_box_pack_start();
  i = 0;
  do {
    ghid_hotkey_actions[i] = (char *)0x0;
    i = i + 1;
  } while (i != 0x100);
  if (homedir == (char *)0x0) {
    __name = (char *)0x0;
    Message("Warning:  could not determine home directory\n");
  }
  else {
    Message("Note:  home directory is \"%s\"\n");
    uVar6 = 0x815d1de;
    __name = Concat(homedir);
  }
  i = access("gpcb-menu.res",4);
  filename = "gpcb-menu.res";
  if ((i != 0) && ((__name == (char *)0x0 || (i = access(__name,4), filename = __name, i != 0)))) {
    i = access(pcbmenu_path,4);
    filename = (char *)0x0;
    if (i == 0) {
      filename = pcbmenu_path;
    }
  }
  res = resource_parse((char *)0x0,gpcb_menu_default);
  if (res == (Resource *)0x0) {
    __fprintf_chk(stderr,1,"Error: internal menu resource didn\'t parse\n",uVar6);
                    // WARNING: Subroutine does not return
    exit(1);
  }
  res_00 = (Resource *)0x0;
  if (filename != (char *)0x0) {
    res_00 = resource_parse(filename,(char **)0x0);
  }
  if (__name != (char *)0x0) {
    free(__name);
  }
  if (res_00 == (Resource *)0x0) {
    res_00 = res;
  }
  node = resource_subres(res_00,"MainMenu");
  if ((node != (Resource *)0x0) || (node = resource_subres(res,"MainMenu"), node != (Resource *)0x0)
     ) {
    ghid_ui_info_append("<ui>\n");
    ghid_ui_info_indent(5);
    ghid_ui_info_append("<menubar name=\'MenuBar\'>\n");
    add_resource_to_menu(node,10);
    ghid_ui_info_indent(5);
    ghid_ui_info_append("</menubar>\n");
  }
  node = resource_subres(res_00,"PopupMenus");
  if ((node != (Resource *)0x0) ||
     (node = resource_subres(res,"PopupMenus"), node != (Resource *)0x0)) {
    local_78 = node->c;
    local_70 = 0;
    local_74 = 0;
    while (local_74 < local_78) {
      piVar13 = (int *)((int)&node->v->name + local_70);
      if ((~-(uint)(*piVar13 == 0) & 100) + (uint)(piVar13[2] != 0) +
          (~-(uint)(piVar13[1] == 0) & 10) == 0x65) {
        ghid_ui_info_indent(5);
        ghid_ui_info_append("<popup name=\'");
        ghid_ui_info_append(*(gchar **)((int)&node->v->name + local_70));
        ghid_ui_info_append("\'>\n");
        add_resource_to_menu(*(Resource **)((int)&node->v->subres + local_70),10);
        ghid_ui_info_indent(5);
        ghid_ui_info_append("</popup>\n");
        local_78 = node->c;
      }
      local_74 = local_74 + 1;
      local_70 = local_70 + 0xc;
    }
  }
  ghid_ui_info_append("</ui>\n");
  res_00 = resource_subres(res_00,"Mouse");
  if ((res_00 != (Resource *)0x0) ||
     (res_00 = resource_subres(res,"Mouse"), res_00 != (Resource *)0x0)) {
    load_mouse_resource(res_00);
  }
  make_top_menubar(hbox);
  hbox = (GtkWidget *)gtk_frame_new();
  gtk_widget_show();
  g_type_check_instance_cast();
  g_object_ref();
  pGVar2 = ghidgui;
  ghidgui->mode_buttons1_vbox = box;
  pGVar2->mode_buttons1_frame = hbox;
  box = (GtkWidget *)gtk_hbox_new();
  pGVar2->mode_buttons1_hbox = box;
  g_type_check_instance_cast();
  gtk_container_add();
  gtk_vbox_new();
  g_type_check_instance_cast();
  gtk_box_pack_end();
  pGVar2 = ghidgui;
  box = (GtkWidget *)gtk_vbox_new();
  pGVar2->compact_vbox = box;
  g_type_check_instance_cast();
  gtk_box_pack_end();
  pGVar2 = ghidgui;
  box = (GtkWidget *)gtk_hbox_new();
  pGVar2->compact_hbox = box;
  g_type_check_instance_cast();
  gtk_box_pack_start();
  box = (GtkWidget *)gtk_hbox_new();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  ghidgui->label_hbox = box;
  box = (GtkWidget *)gtk_label_new();
  gtk_label_get_type();
  g_type_check_instance_cast();
  gtk_label_set_use_markup();
  if (ghidgui->name_label_string == (gchar *)0x0) {
    g_strdup();
  }
  else {
    g_strdup_printf();
  }
  g_type_check_instance_cast();
  gtk_label_set_markup();
  g_free();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  pGVar2 = ghidgui;
  ghidgui->name_label = box;
  box = (GtkWidget *)gtk_hbox_new();
  pGVar2->position_hbox = box;
  g_type_check_instance_cast();
  g_object_ref();
  if (ghidgui->compact_horizontal == 0) {
    g_type_check_instance_cast();
    gtk_box_pack_end();
  }
  else {
    g_type_check_instance_cast();
    gtk_box_pack_end();
  }
  gtk_button_new();
  box = (GtkWidget *)gtk_label_new();
  g_type_check_instance_cast();
  gtk_label_set_markup();
  ghidgui->grid_units_label = box;
  g_type_check_instance_cast();
  gtk_label_set_use_markup();
  g_type_check_instance_cast();
  gtk_container_add();
  g_type_check_instance_cast();
  gtk_box_pack_end();
  g_type_check_instance_cast();
  g_signal_connect_data();
  gtk_frame_new();
  g_type_check_instance_cast();
  gtk_box_pack_end();
  g_type_check_instance_cast();
  gtk_container_set_border_width();
  gtk_frame_get_type();
  g_type_check_instance_cast();
  gtk_frame_set_shadow_type();
  box = (GtkWidget *)gtk_label_new();
  g_type_check_instance_cast();
  gtk_container_add();
  ghidgui->cursor_position_absolute_label = box;
  g_type_check_instance_cast();
  g_signal_connect_data();
  gtk_frame_new();
  g_type_check_instance_cast();
  gtk_box_pack_end();
  g_type_check_instance_cast();
  gtk_container_set_border_width();
  g_type_check_instance_cast();
  gtk_frame_set_shadow_type();
  box = (GtkWidget *)gtk_label_new();
  g_type_check_instance_cast();
  gtk_container_add();
  ghidgui->cursor_position_relative_label = box;
  g_type_check_instance_cast();
  uVar20 = 0;
  g_signal_connect_data();
  uVar6 = gtk_hbox_new();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  box = (GtkWidget *)gtk_event_box_new();
  gtk_widget_set_events();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  ghid_left_sensitive_box = box;
  box = (GtkWidget *)gtk_vbox_new();
  g_type_check_instance_cast();
  gtk_container_add();
  ghid_scrolled_vbox(box,&scrolled,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
  local_54 = 1;
  uVar7 = gtk_hbox_new();
  uVar8 = g_type_check_instance_cast();
  uVar11 = 0;
  gtk_box_pack_start(uVar8,uVar7,0,0,4,uVar20);
  __name = (char *)gtk_table_new(0x16,2,0,uVar11);
  uVar7 = g_type_check_instance_cast();
  local_ec = CONCAT44(uVar20,3);
  local_f4 = 0;
  gtk_box_pack_start(uVar7,__name,0,0,3,uVar20);
  gtk_table_get_type();
  gtk_toggle_button_get_type();
  gtk_radio_button_get_type();
  local_90 = 0;
  lb = layer_buttons;
  i = 0;
  do {
    lb->index = i;
    if (i < 0x12) {
      hbox = (GtkWidget *)gtk_radio_button_new(local_90,__name,local_f4,local_ec);
      g_type_check_instance_cast();
      local_90 = gtk_radio_button_get_group();
      g_type_check_instance_cast();
      gtk_table_attach_defaults();
      lb->radio_select_button = hbox;
      g_type_check_instance_cast();
      g_signal_connect_data();
    }
    layer_process(&local_50,&local_4c,&local_54,i);
    hbox = (GtkWidget *)gtk_check_button_new();
    label = (GtkWidget *)gtk_label_new();
    g_type_check_instance_cast();
    gtk_label_set_use_markup();
    layer_enable_button_set_label(label,local_4c);
    pGVar9 = (GtkWidget *)gtk_event_box_new();
    g_type_check_instance_cast();
    gtk_container_add();
    g_type_check_instance_cast();
    gtk_container_add();
    g_type_check_instance_cast();
    gtk_table_attach_defaults();
    g_type_check_instance_cast();
    gtk_toggle_button_set_mode();
    lb->layer_enable_button = hbox;
    lb->layer_enable_ebox = pGVar9;
    pgVar10 = (gchar *)g_strdup();
    lb->label = label;
    lb->text = pgVar10;
    layer_button_set_color(lb,local_50);
    g_type_check_instance_cast();
    gtk_toggle_button_set_active();
    g_type_check_instance_cast();
    iVar17 = i + 1;
    local_ec = 0;
    local_f4 = CONCAT44(i,0x81061a0);
    __name = "toggled";
    g_signal_connect_data();
    uVar21 = (uint)((ulonglong)local_ec >> 0x20);
    lb = lb + 1;
    i = iVar17;
  } while (iVar17 != 0x16);
  hbox = (GtkWidget *)gtk_vbox_new();
  uVar7 = g_type_check_instance_cast();
  lVar18 = (ulonglong)uVar21 << 0x20;
  local_f4 = 0;
  gtk_box_pack_start(uVar7,hbox,0,0,0,uVar21);
  ghidgui->mode_buttons0_frame_vbox = hbox;
  hbox = (GtkWidget *)gtk_frame_new();
  ghidgui->mode_buttons0_frame = hbox;
  gtk_widget_show();
  g_type_check_instance_cast();
  g_object_ref();
  pGVar2 = ghidgui;
  hbox = (GtkWidget *)gtk_vbox_new();
  pGVar2->mode_buttons0_vbox = hbox;
  __name = (char *)ghidgui->mode_buttons0_vbox;
  g_type_check_instance_cast();
  gtk_container_add();
  local_64 = (GtkWidget *)0x0;
  local_7c = 0;
  local_60 = 0;
  pMVar15 = mode_buttons;
  do {
    hbox = (GtkWidget *)gtk_radio_button_new(local_7c,__name,local_f4,lVar18);
    pMVar15->button = hbox;
    g_type_check_instance_cast();
    g_object_ref();
    g_type_check_instance_cast();
    local_7c = gtk_radio_button_get_group();
    g_type_check_instance_cast();
    gtk_toggle_button_set_mode();
    if (local_60 % ghidgui->n_mode_button_columns == 0) {
      local_64 = (GtkWidget *)gtk_hbox_new();
      g_type_check_instance_cast();
      gtk_box_pack_start();
    }
    pGVar2 = ghidgui;
    pMVar15->box0 = local_64;
    pMVar15->box1 = pGVar2->mode_buttons1_hbox;
    gdk_pixbuf_new_from_xpm_data();
    gtk_image_new_from_pixbuf();
    g_type_check_instance_cast();
    g_object_unref();
    g_type_check_instance_cast();
    gtk_container_add();
    i = strcmp(pMVar15->name,"select");
    if (i == 0) {
      g_type_check_instance_cast();
      gtk_toggle_button_set_active();
    }
    lVar18 = 0;
    local_f4 = CONCAT44(pMVar15,0x8104d90);
    __name = "toggled";
    g_signal_connect_data();
    uVar7 = (undefined4)((ulonglong)lVar18 >> 0x20);
    local_60 = local_60 + 1;
    pMVar15 = pMVar15 + 1;
  } while (local_60 != 0xd);
  ghid_pack_mode_buttons();
  uVar8 = gtk_frame_new(0,__name);
  uVar11 = g_type_check_instance_cast(box,uVar5);
  gtk_box_pack_end(uVar11,uVar8,0,0,0,uVar7);
  uVar11 = gtk_vbox_new(0,0);
  uVar8 = g_type_check_instance_cast(uVar8,uVar4);
  gtk_container_add(uVar8,uVar11);
  uVar8 = gtk_hbox_new(0,0);
  uVar11 = g_type_check_instance_cast(uVar11,uVar5);
  gtk_box_pack_start(uVar11,uVar8,0,0,1,uVar7);
  uVar11 = gtk_vbox_new(0,0);
  uVar8 = g_type_check_instance_cast(uVar8,uVar5);
  uVar20 = 0;
  gtk_box_pack_start(uVar8,uVar11,0,0,4,uVar7);
  __name = "Route Style";
  uVar8 = dcgettext(&DAT_0815492c,"Route Style",5,uVar20);
  box = (GtkWidget *)gtk_button_new_with_label(uVar8,__name);
  uVar8 = g_type_check_instance_cast(uVar11,uVar5);
  gtk_box_pack_start(uVar8,box,0,0,2,uVar7);
  local_ec = 0;
  local_f4 = 0x8195a8008105040;
  g_signal_connect_data(box,"clicked",route_style_edit_cb,&ghid_port,0,0);
  pRVar14 = route_style_button;
  i = 0;
  route_style_edit_button = box;
  do {
    uVar7 = (undefined4)((ulonglong)local_f4 >> 0x20);
    if (i < 4) {
      dcgettext(&DAT_0815492c,PCB->RouteStyle[i].Name,5,uVar7,local_ec);
      box = (GtkWidget *)gtk_radio_button_new_with_label();
      g_type_check_instance_cast();
      gtk_radio_button_get_group();
      g_type_check_instance_cast();
      gtk_box_pack_start();
      pRVar14->button = box;
    }
    else {
      dcgettext(&DAT_0815492c,"Temp%d",5,uVar7,local_ec);
      iVar17 = i + -3;
      __snprintf_chk();
      box = (GtkWidget *)gtk_radio_button_new_with_label();
      if ((pRVar14->route_style).Name == (char *)0x0) {
        __name = (char *)g_strdup();
        (pRVar14->route_style).Name = __name;
      }
      g_type_check_instance_cast();
      gtk_radio_button_get_group();
      g_type_check_instance_cast();
      gtk_box_pack_start();
      pRVar14->button = box;
      if (i == 6) break;
    }
    pRVar14 = pRVar14 + 1;
    g_type_check_instance_cast();
    iVar16 = i + 1;
    local_ec = 0;
    local_f4 = CONCAT44(i,0x8104df0);
    g_signal_connect_data();
    iVar17 = (int)((ulonglong)local_ec >> 0x20);
    i = iVar16;
  } while (iVar16 != 7);
  uVar7 = gtk_vbox_new(0,0);
  uVar6 = g_type_check_instance_cast(uVar6,uVar5);
  gtk_box_pack_start(uVar6,uVar7,1,1,0,iVar17);
  uVar6 = gtk_hbox_new(0,0);
  uVar7 = g_type_check_instance_cast(uVar7,uVar5);
  gtk_box_pack_start(uVar7,uVar6,1,1,0,iVar17);
  uVar7 = gtk_viewport_new(0,0);
  uVar8 = gtk_viewport_get_type();
  uVar8 = g_type_check_instance_cast(uVar7,uVar8);
  gtk_viewport_set_shadow_type(uVar8,1);
  uVar8 = g_type_check_instance_cast(uVar6,uVar5);
  gtk_box_pack_start(uVar8,uVar7,1,1,0,iVar17);
  pGVar19 = gport;
  box = (GtkWidget *)gtk_drawing_area_new();
  pGVar19->drawing_area = box;
  gtk_widget_add_events(gport->drawing_area,0x7f06);
  uVar8 = gtk_object_get_type();
  i = g_type_check_instance_cast(gport->drawing_area,uVar8);
  *(uint *)(i + 0xc) = *(uint *)(i + 0xc) | 0x800;
  box = gport->drawing_area;
  uVar4 = g_type_check_instance_cast(uVar7,uVar4);
  gtk_container_add(uVar4,box);
  pGVar2 = ghidgui;
  uVar8 = 0x40590000;
  pGVar12 = (GtkObject *)
            gtk_adjustment_new(0,0,0x4059000000000000,0x4024000000000000,0x4024000000000000,
                               0x4024000000000000);
  pGVar2->v_adjustment = pGVar12;
  uVar4 = gtk_adjustment_get_type();
  pGVar2 = ghidgui;
  uVar7 = g_type_check_instance_cast(ghidgui->v_adjustment,uVar4);
  box = (GtkWidget *)gtk_vscrollbar_new(uVar7,uVar4);
  pGVar2->v_range = box;
  uVar4 = gtk_range_get_type();
  uVar4 = g_type_check_instance_cast(ghidgui->v_range,uVar4);
  gtk_range_set_update_policy(uVar4,0);
  box = ghidgui->v_range;
  uVar4 = g_type_check_instance_cast(uVar6,uVar5);
  gtk_box_pack_start(uVar4,box,0,0,0,uVar8);
  pGVar2 = ghidgui;
  uVar4 = g_type_check_instance_cast(ghidgui->v_adjustment,0x50);
  g_signal_connect_data(uVar4,"value_changed",v_adjustment_changed_cb,pGVar2,0,0);
  pGVar2 = ghidgui;
  pGVar12 = (GtkObject *)
            gtk_adjustment_new(0,0,0x4059000000000000,0x4024000000000000,0x4024000000000000,
                               0x4024000000000000);
  pGVar2->h_adjustment = pGVar12;
  pGVar2 = ghidgui;
  g_type_check_instance_cast();
  box = (GtkWidget *)gtk_hscrollbar_new();
  pGVar2->h_range = box;
  g_type_check_instance_cast();
  gtk_range_set_update_policy();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  g_type_check_instance_cast();
  g_signal_connect_data();
  pGVar2 = ghidgui;
  box = (GtkWidget *)gtk_hbox_new();
  pGVar2->status_line_hbox = box;
  g_type_check_instance_cast();
  gtk_box_pack_start();
  box = (GtkWidget *)gtk_label_new();
  g_type_check_instance_cast();
  gtk_label_set_use_markup();
  g_type_check_instance_cast();
  gtk_box_pack_start();
  ghidgui->status_line_label = box;
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  g_signal_connect_data();
  ghid_interface_input_signals_connect();
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  g_signal_connect_data();
  g_type_check_instance_cast();
  pGVar19 = &ghid_port;
  g_signal_connect_data();
  ghidgui->creating = 0;
  gtk_widget_show_all();
  gtk_widget_realize();
  gtk_widget_realize();
  gtk_widget_realize();
  gtk_widget_realize();
  lVar18 = ZEXT48(pGVar19) << 0x20;
  uVar4 = 0;
  gdk_window_set_back_pixmap();
  gtk_widget_hide(route_style_button[4].button,uVar4,lVar18);
  gtk_widget_hide();
  gtk_widget_hide();
  ghid_show_layer_buttons();
  ghid_update_toggle_flags();
  XC_clock_source =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,rotateIcon_bits,0x10,0x10)
  ;
  XC_clock_mask =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,rotateMask_bits,0x10,0x10)
  ;
  XC_hand_source =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,handIcon_bits,0x10,0x10);
  XC_hand_mask = (GdkPixmap *)
                 gdk_bitmap_create_from_data(gport->top_window->window,handMask_bits,0x10,0x10);
  XC_lock_source =
       (GdkPixmap *)gdk_bitmap_create_from_data(gport->top_window->window,lockIcon_bits,0x10,0x10);
  XC_lock_mask = (GdkPixmap *)
                 gdk_bitmap_create_from_data(gport->top_window->window,lockMask_bits,0x10,0x10);
  SetMode(0x6e);
  ghid_mode_buttons_update();
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void ghid_do_export(HID_Attr_Val *options)

{
  int iVar1;
  undefined4 uVar2;
  
  ghid_create_pcb_widgets();
  ghid_layer_buttons_update();
  ghid_show_layer_buttons();
  if (stdin_listen != 0) {
    iVar1 = fileno(stdin);
    uVar2 = g_io_channel_unix_new(iVar1);
    g_io_add_watch(uVar2,1,ghid_listener_cb,0);
  }
  ghid_notify_gui_is_up();
  gtk_main();
  ghid_config_files_write();
  return;
}



gboolean ghid_is_modifier_key_sym(gint ksym)

{
  if ((1 < ksym - 0xffe1U) && (ksym != 0xffe4)) {
    return (uint)(ksym == 0xffe3);
  }
  return 1;
}



gboolean dup_string(gchar **dst,gchar *src)

{
  char *__s1;
  char *pcVar1;
  gchar *pgVar2;
  gboolean gVar3;
  
  if (dst == (gchar **)0x0) {
LAB_0810a6c4:
    gVar3 = 0;
  }
  else {
    __s1 = *dst;
    pcVar1 = __s1;
    if (src == (gchar *)0x0) {
joined_r0x0810a6c2:
      if (pcVar1 == (char *)0x0) goto LAB_0810a6c4;
      g_free(__s1);
    }
    else {
      if (__s1 != (char *)0x0) {
        pcVar1 = (char *)strcmp(__s1,src);
        goto joined_r0x0810a6c2;
      }
    }
    pgVar2 = (gchar *)g_strdup(src);
    *dst = pgVar2;
    gVar3 = 1;
  }
  return gVar3;
}



gboolean utf8_dup_string(gchar **dst_utf8,gchar *src)

{
  char *__s1;
  char *pcVar1;
  int iVar2;
  gchar *pgVar3;
  gboolean gVar4;
  
  if (dst_utf8 == (gchar **)0x0) {
LAB_0810a7a0:
    gVar4 = 0;
  }
  else {
    __s1 = *dst_utf8;
    pcVar1 = __s1;
    if (src == (gchar *)0x0) {
joined_r0x0810a79a:
      if (pcVar1 == (char *)0x0) goto LAB_0810a7a0;
      g_free(__s1);
    }
    else {
      if (__s1 != (char *)0x0) {
        pcVar1 = (char *)strcmp(__s1,src);
        goto joined_r0x0810a79a;
      }
    }
    if (src == (gchar *)0x0) {
      *dst_utf8 = (gchar *)0x0;
      gVar4 = 1;
    }
    else {
      iVar2 = g_utf8_validate(src,0xffffffff,0);
      if (iVar2 == 0) {
        pgVar3 = (gchar *)g_locale_to_utf8(src,0xffffffff,0,0,0);
        *dst_utf8 = pgVar3;
        if (pgVar3 != (gchar *)0x0) {
          return 1;
        }
      }
      pgVar3 = (gchar *)g_strdup(src);
      *dst_utf8 = pgVar3;
      gVar4 = 1;
    }
  }
  return gVar4;
}



GtkWidget *
ghid_scrolled_text_view
          (GtkWidget *box,GtkWidget **scr,GtkPolicyType h_policy,GtkPolicyType v_policy)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  GtkWidget *pGVar3;
  undefined4 uVar4;
  
  pGVar1 = (GtkWidget *)gtk_scrolled_window_new(0,0);
  uVar2 = gtk_scrolled_window_get_type();
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_scrolled_window_set_policy(uVar2,h_policy,v_policy);
  uVar2 = gtk_box_get_type();
  uVar2 = g_type_check_instance_cast(box,uVar2);
  gtk_box_pack_start(uVar2,pGVar1,1,1,0);
  pGVar3 = (GtkWidget *)gtk_text_view_new();
  uVar2 = gtk_text_view_get_type();
  uVar4 = g_type_check_instance_cast(pGVar3,uVar2);
  gtk_text_view_set_editable(uVar4,0);
  uVar2 = g_type_check_instance_cast(pGVar3,uVar2);
  uVar2 = gtk_text_view_get_buffer(uVar2);
  gtk_text_buffer_create_tag(uVar2,"heading","weight",700,0x815c581,0x3800,0);
  gtk_text_buffer_create_tag(uVar2,"italic","style",2,0);
  gtk_text_buffer_create_tag(uVar2,&DAT_0815c4db,"weight",700,0);
  gtk_text_buffer_create_tag(uVar2,0x8152399,"justification",2,0);
  gtk_text_buffer_create_tag(uVar2,"underline","underline",1,0);
  uVar2 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_container_add(uVar2,pGVar3);
  if (scr != (GtkWidget **)0x0) {
    *scr = pGVar1;
  }
  return pGVar3;
}



void __regparm3 text_view_append(GtkWidget *view,gchar *s)

{
  int iVar1;
  gchar *pgVar2;
  char *pcVar3;
  bool bVar4;
  byte bVar5;
  GtkTextIter iter;
  
  bVar5 = 0;
  bVar4 = (undefined *)register0x00000010 == (undefined *)0x9c;
  gtk_text_view_get_type();
  g_type_check_instance_cast();
  gtk_text_view_get_buffer();
  gtk_text_buffer_get_end_iter();
  iVar1 = 3;
  pgVar2 = s;
  pcVar3 = "<b>";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pgVar2 == *pcVar3;
    pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
    pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
  } while (bVar4);
  if (bVar4) {
    gtk_text_buffer_insert_with_tags_by_name();
  }
  else {
    iVar1 = 3;
    pgVar2 = s;
    pcVar3 = "<i>";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *pgVar2 == *pcVar3;
      pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
      pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
    } while (bVar4);
    if (!bVar4) {
      iVar1 = 3;
      pgVar2 = s;
      pcVar3 = "<h>";
      do {
        if (iVar1 == 0) break;
        iVar1 = iVar1 + -1;
        bVar4 = *pgVar2 == *pcVar3;
        pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
        pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
      } while (bVar4);
      if (!bVar4) {
        iVar1 = 3;
        pgVar2 = s;
        pcVar3 = "<c>";
        do {
          if (iVar1 == 0) break;
          iVar1 = iVar1 + -1;
          bVar4 = *pgVar2 == *pcVar3;
          pgVar2 = pgVar2 + (uint)bVar5 * -2 + 1;
          pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
        } while (bVar4);
        if (!bVar4) {
          iVar1 = 4;
          pcVar3 = "<ul>";
          do {
            if (iVar1 == 0) break;
            iVar1 = iVar1 + -1;
            bVar4 = *s == *pcVar3;
            s = s + (uint)bVar5 * -2 + 1;
            pcVar3 = pcVar3 + (uint)bVar5 * -2 + 1;
          } while (bVar4);
          if (!bVar4) {
            gtk_text_buffer_insert();
            goto LAB_0810aa60;
          }
        }
      }
    }
    gtk_text_buffer_insert_with_tags_by_name();
  }
LAB_0810aa60:
  gtk_text_buffer_create_mark();
  g_type_check_instance_cast();
  gtk_text_view_scroll_to_mark();
  gtk_text_buffer_delete_mark();
  return;
}



void ghid_text_view_append_strings(GtkWidget *view,gchar **string,gint n_strings)

{
  char *pcVar1;
  gchar *s;
  char cVar2;
  int iVar3;
  int iVar4;
  
  if (0 < n_strings) {
    iVar3 = 0;
    iVar4 = 0;
    do {
      while (pcVar1 = string[iVar3], *pcVar1 != '<') {
LAB_0810abdd:
        s = (gchar *)dcgettext(0,pcVar1,5);
        if (iVar4 == 0) {
          text_view_append(view,s);
        }
        else {
          s = (gchar *)g_strconcat(iVar4,s,0);
          text_view_append(view,s);
          g_free(s);
          g_free(iVar4);
          iVar4 = 0;
        }
        iVar3 = iVar3 + 1;
        if (n_strings <= iVar3) {
          return;
        }
      }
      if (pcVar1[2] == '>') {
        cVar2 = pcVar1[3];
        if (cVar2 != '\0') goto LAB_0810abd4;
      }
      else {
        cVar2 = pcVar1[3];
LAB_0810abd4:
        if ((cVar2 != '>') || (pcVar1[4] != '\0')) goto LAB_0810abdd;
      }
      iVar3 = iVar3 + 1;
      iVar4 = g_strdup(pcVar1);
    } while (iVar3 < n_strings);
  }
  return;
}



void ghid_text_view_append(GtkWidget *view,gchar *string)

{
  gchar *tag;
  char cVar1;
  gchar *s;
  undefined4 local_14;
  
  if (*string == '<') {
    if (string[2] == '>') {
      cVar1 = string[3];
      if (cVar1 != '\0') goto LAB_0810ad02;
    }
    else {
      cVar1 = string[3];
LAB_0810ad02:
      if ((cVar1 != '>') || (string[4] != '\0')) goto LAB_0810aca3;
    }
    g_strdup(string);
  }
  else {
LAB_0810aca3:
    if (tag == (gchar *)0x0) {
      text_view_append(view,string);
      return;
    }
    local_14 = 0;
    s = (gchar *)g_strconcat();
    text_view_append(view,s);
    g_free(s,string,local_14);
    g_free(tag);
  }
  return;
}



void ghid_label_set_markup(GtkWidget *label,gchar *text)

{
  undefined4 uVar1;
  
  if (label != (GtkWidget *)0x0) {
    uVar1 = gtk_label_get_type();
    g_type_check_instance_cast(label,uVar1);
    gtk_label_set_markup();
    return;
  }
  return;
}



GtkWidget * ghid_notebook_page(GtkWidget *tabs,char *name,gint pad,gint border)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
  pGVar1 = (GtkWidget *)gtk_vbox_new(0,pad);
  uVar2 = gtk_container_get_type();
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_container_set_border_width(uVar2,border);
  uVar2 = gtk_label_new(name);
  uVar3 = gtk_notebook_get_type();
  uVar3 = g_type_check_instance_cast(tabs,uVar3);
  gtk_notebook_append_page(uVar3,pGVar1,uVar2);
  return pGVar1;
}



GtkTreeSelection *
ghid_scrolled_selection
          (GtkTreeView *treeview,GtkWidget *box,GtkSelectionMode s_mode,GtkPolicyType h_policy,
          GtkPolicyType v_policy,anon_subr_void *func_cb,gpointer data)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkTreeSelection *pGVar4;
  
  if ((box == (GtkWidget *)0x0) || (treeview == (GtkTreeView *)0x0)) {
    pGVar4 = (GtkTreeSelection *)0x0;
  }
  else {
    uVar1 = gtk_scrolled_window_new(0,0);
    uVar2 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar2,uVar1,1,1,0);
    uVar2 = gtk_widget_get_type();
    uVar2 = g_type_check_instance_cast(treeview,uVar2);
    uVar3 = gtk_container_get_type();
    uVar3 = g_type_check_instance_cast(uVar1,uVar3);
    gtk_container_add(uVar3,uVar2);
    uVar2 = gtk_scrolled_window_get_type();
    uVar1 = g_type_check_instance_cast(uVar1,uVar2);
    gtk_scrolled_window_set_policy(uVar1,h_policy,v_policy);
    pGVar4 = (GtkTreeSelection *)gtk_tree_view_get_selection(treeview);
    gtk_tree_selection_set_mode(pGVar4,s_mode);
    if (func_cb != (anon_subr_void *)0x0) {
      uVar1 = g_type_check_instance_cast(pGVar4,0x50);
      g_signal_connect_data(uVar1,0x8155a12,func_cb,data,0,0);
    }
  }
  return pGVar4;
}



GtkWidget *
ghid_category_vbox(GtkWidget *box,gchar *category_header,gint header_pad,gint box_pad,
                  gboolean pack_start,gboolean bottom_pad)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  GtkWidget *pGVar6;
  
  uVar1 = gtk_vbox_new(0,0);
  if (pack_start == 0) {
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_end(uVar3,uVar1,0,0,0);
  }
  else {
    uVar2 = gtk_box_get_type();
    uVar3 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar3,uVar1,0,0,0);
  }
  if (category_header != (gchar *)0x0) {
    uVar3 = gtk_label_new(0);
    uVar4 = g_strconcat("<span weight=\"bold\">",category_header,"</span>",0);
    uVar5 = gtk_label_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_label_set_markup(uVar5,uVar4);
    uVar5 = gtk_misc_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar5);
    gtk_misc_set_alignment(uVar5,0,0x3f000000);
    uVar5 = g_type_check_instance_cast(uVar1,uVar2);
    gtk_box_pack_start(uVar5,uVar3,0,0,header_pad);
    g_free(uVar4);
  }
  uVar3 = gtk_hbox_new(0,0);
  uVar4 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_box_pack_start(uVar4,uVar3,0,0,0);
  uVar4 = gtk_label_new(&DAT_0815672c);
  uVar5 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar5,uVar4,0,0,0);
  pGVar6 = (GtkWidget *)gtk_vbox_new(0,box_pad);
  uVar3 = g_type_check_instance_cast(uVar3,uVar2);
  gtk_box_pack_start(uVar3,pGVar6,1,1,0);
  if (bottom_pad != 0) {
    uVar3 = gtk_label_new(&DAT_0814741b);
    uVar1 = g_type_check_instance_cast(uVar1,uVar2);
    gtk_box_pack_start(uVar1,uVar3,0,0,0);
  }
  return pGVar6;
}



GtkWidget *
ghid_framed_vbox_end
          (GtkWidget *box,gchar *label,gint frame_border_width,gboolean frame_expand,gint vbox_pad,
          gint vbox_border_width)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  
  uVar1 = gtk_frame_new(label);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_set_border_width(uVar3,frame_border_width);
  uVar3 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar3);
  gtk_box_pack_end(uVar3,uVar1,frame_expand,frame_expand,0);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,vbox_pad);
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_container_set_border_width(uVar3,vbox_border_width);
  uVar1 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_add(uVar1,pGVar4);
  return pGVar4;
}



GtkWidget *
ghid_framed_vbox(GtkWidget *box,gchar *label,gint frame_border_width,gboolean frame_expand,
                gint vbox_pad,gint vbox_border_width)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  
  uVar1 = gtk_frame_new(label);
  uVar2 = gtk_container_get_type();
  uVar3 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_set_border_width(uVar3,frame_border_width);
  uVar3 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar3);
  gtk_box_pack_start(uVar3,uVar1,frame_expand,frame_expand,0);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,vbox_pad);
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_container_set_border_width(uVar3,vbox_border_width);
  uVar1 = g_type_check_instance_cast(uVar1,uVar2);
  gtk_container_add(uVar1,pGVar4);
  return pGVar4;
}



GtkWidget *
ghid_framed_notebook_page
          (GtkWidget *tabs,char *name,gint border,gint frame_border,gint vbox_pad,gint vbox_border)

{
  GtkWidget *box;
  
  box = ghid_notebook_page(tabs,name,0,border);
  box = ghid_framed_vbox(box,(gchar *)0x0,frame_border,1,vbox_pad,vbox_border);
  return box;
}



GtkWidget *
ghid_scrolled_vbox(GtkWidget *box,GtkWidget **scr,GtkPolicyType h_policy,GtkPolicyType v_policy)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  
  pGVar1 = (GtkWidget *)gtk_scrolled_window_new(0,0);
  uVar2 = gtk_scrolled_window_get_type();
  uVar3 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_scrolled_window_set_policy(uVar3,h_policy,v_policy);
  uVar3 = gtk_box_get_type();
  uVar3 = g_type_check_instance_cast(box,uVar3);
  gtk_box_pack_start(uVar3,pGVar1,1,1,0);
  pGVar4 = (GtkWidget *)gtk_vbox_new(0,0);
  uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
  gtk_scrolled_window_add_with_viewport(uVar2,pGVar4);
  if (scr != (GtkWidget **)0x0) {
    *scr = pGVar1;
  }
  return pGVar4;
}



void ghid_dialog_report(gchar *title,gchar *message)

{
  char cVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  GtkWidget *local_5c;
  GtkWidget *local_20 [4];
  
  if (message != (gchar *)0x0) {
    uVar2 = gtk_window_get_type();
    uVar3 = g_type_check_instance_cast(ghid_port.top_window,uVar2);
    if (title == (gchar *)0x0) {
      title = "PCB";
    }
    uVar3 = gtk_dialog_new_with_buttons(title,uVar3,2,"gtk-ok",0xffffffff,0);
    uVar4 = gtk_object_get_type();
    uVar5 = g_type_check_instance_cast(uVar3,uVar4);
    uVar4 = g_type_check_instance_cast(uVar3,uVar4);
    g_signal_connect_data(uVar4,"response",gtk_widget_destroy,uVar5,0,2);
    uVar2 = g_type_check_instance_cast(uVar3,uVar2);
    gtk_window_set_wmclass(uVar2,"PCB_Dialog",&DAT_08154932);
    local_5c = (GtkWidget *)gtk_vbox_new(0,0);
    uVar2 = gtk_container_get_type();
    uVar2 = g_type_check_instance_cast(local_5c,uVar2);
    gtk_container_set_border_width(uVar2,8);
    uVar2 = gtk_box_get_type();
    uVar4 = gtk_dialog_get_type();
    iVar6 = g_type_check_instance_cast(uVar3,uVar4);
    uVar4 = g_type_check_instance_cast(*(undefined4 *)(iVar6 + 0x94),uVar2);
    gtk_box_pack_start(uVar4,local_5c,0,0,0);
    uVar4 = gtk_label_new(message);
    uVar5 = gtk_label_get_type();
    uVar5 = g_type_check_instance_cast(uVar4,uVar5);
    gtk_label_set_justify(uVar5,0);
    cVar1 = *message;
    if (cVar1 != '\0') {
      iVar6 = 0;
      do {
        message = message + 1;
        iVar6 = iVar6 + (uint)(cVar1 == '\n');
        cVar1 = *message;
      } while (cVar1 != '\0');
      if (0x14 < iVar6) {
        local_5c = ghid_scrolled_vbox(local_5c,local_20,GTK_POLICY_NEVER,GTK_POLICY_AUTOMATIC);
        gtk_widget_set_size_request(local_20[0],0xffffffff,300);
      }
    }
    uVar2 = g_type_check_instance_cast(local_5c,uVar2);
    gtk_box_pack_start(uVar2,uVar4,0,0,0);
    gtk_widget_show_all(uVar3);
  }
  return;
}



void ghid_range_control(GtkWidget *box,GtkWidget **scale_res,gboolean horizontal,GtkPositionType pos
                       ,gboolean set_draw_value,gint digits,gboolean pack_start,gboolean expand,
                       gboolean fill,guint pad,gfloat value,gfloat low,gfloat high,gfloat step0,
                       gfloat step1,anon_subr_void *cb_func,gpointer data)

{
  gpointer pvVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  GtkWidget *pGVar4;
  
  pvVar1 = (gpointer)
           gtk_adjustment_new(SUB84((double)(float)value,0),
                              (int)((ulonglong)(double)(float)value >> 0x20),
                              SUB84((double)(float)low,0),
                              (int)((ulonglong)(double)(float)low >> 0x20),
                              SUB84((double)(float)high,0),
                              (int)((ulonglong)(double)(float)high >> 0x20),(double)(float)step0,
                              (double)(float)step1,0);
  if (horizontal == 0) {
    uVar2 = gtk_adjustment_get_type();
    uVar2 = g_type_check_instance_cast(pvVar1,uVar2);
    pGVar4 = (GtkWidget *)gtk_vscale_new(uVar2);
  }
  else {
    uVar2 = gtk_adjustment_get_type();
    uVar2 = g_type_check_instance_cast(pvVar1,uVar2);
    pGVar4 = (GtkWidget *)gtk_hscale_new(uVar2);
  }
  uVar2 = gtk_scale_get_type();
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_scale_set_value_pos(uVar3,pos);
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_scale_set_draw_value(uVar3,set_draw_value);
  uVar2 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_scale_set_digits(uVar2,digits);
  uVar2 = gtk_range_get_type();
  uVar3 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_range_set_update_policy(uVar3,0);
  uVar2 = g_type_check_instance_cast(pGVar4,uVar2);
  gtk_range_set_increments(uVar2,0,0xbff00000,0,0x3ff00000);
  if (pack_start == 0) {
    uVar2 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_end(uVar2,pGVar4,expand,fill,pad);
  }
  else {
    uVar2 = gtk_box_get_type();
    uVar2 = g_type_check_instance_cast(box,uVar2);
    gtk_box_pack_start(uVar2,pGVar4,expand,fill,pad);
  }
  if (data == (gpointer)0x0) {
    data = pvVar1;
  }
  if (cb_func != (anon_subr_void *)0x0) {
    uVar2 = g_type_check_instance_cast(pvVar1,0x50);
    g_signal_connect_data(uVar2,"value_changed",cb_func,data,0,0);
  }
  if (scale_res != (GtkWidget **)0x0) {
    *scale_res = pGVar4;
  }
  return;
}



void ghid_spin_button(GtkWidget *box,GtkWidget **spin_button,gfloat value,gfloat low,gfloat high,
                     gfloat step0,gfloat step1,gint digits,gint width,anon_subr_void *cb_func,
                     gpointer data,gboolean right_align,gchar *string)

{
  undefined4 uVar1;
  GtkWidget *pGVar2;
  gpointer pvVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  GtkWidget *pGVar7;
  bool bVar8;
  
  bVar8 = string != (gchar *)0x0;
  pGVar7 = box;
  if ((bVar8) && (box != (GtkWidget *)0x0)) {
    pGVar7 = (GtkWidget *)gtk_hbox_new(0,0);
    uVar5 = gtk_box_get_type();
    uVar5 = g_type_check_instance_cast(box,uVar5);
    gtk_box_pack_start(uVar5,pGVar7,0,0,2);
  }
  uVar5 = (undefined4)((ulonglong)(double)(float)high >> 0x20);
  uVar1 = gtk_adjustment_new(SUB84((double)(float)value,0),
                             (int)((ulonglong)(double)(float)value >> 0x20),
                             SUB84((double)(float)low,0),
                             (int)((ulonglong)(double)(float)low >> 0x20),(double)(float)high,
                             (double)(float)step0,(double)(float)step1,0);
  pGVar2 = (GtkWidget *)gtk_spin_button_new(uVar1,0,0x3fe00000,digits);
  if (spin_button != (GtkWidget **)0x0) {
    *spin_button = pGVar2;
  }
  if (0 < width) {
    gtk_widget_set_size_request(pGVar2,width,0xffffffff);
  }
  uVar1 = gtk_spin_button_get_type();
  pvVar3 = (gpointer)g_type_check_instance_cast(pGVar2,uVar1);
  gtk_spin_button_set_numeric(pvVar3,1);
  if (data == (gpointer)0x0) {
    data = pvVar3;
  }
  if (cb_func != (anon_subr_void *)0x0) {
    uVar1 = g_type_check_instance_cast(pGVar2,0x50);
    uVar5 = 0;
    g_signal_connect_data(uVar1,"value_changed",cb_func,data,0,0);
  }
  if (pGVar7 != (GtkWidget *)0x0) {
    if ((bVar8) && (right_align != 0)) {
      uVar4 = gtk_label_new(string);
      uVar1 = gtk_misc_get_type();
      uVar1 = g_type_check_instance_cast(uVar4,uVar1);
      gtk_misc_set_alignment(uVar1,0x3f800000,0x3f000000);
      uVar1 = gtk_box_get_type();
      uVar6 = g_type_check_instance_cast(pGVar7,uVar1);
      gtk_box_pack_start(uVar6,uVar4,1,1,2,uVar5);
    }
    else {
      uVar1 = gtk_box_get_type();
    }
    uVar4 = g_type_check_instance_cast(pGVar7,uVar1);
    gtk_box_pack_start(uVar4,pGVar2,0,0,2,uVar5);
    if ((bVar8) && (right_align == 0)) {
      uVar5 = gtk_label_new(string);
      uVar4 = gtk_misc_get_type();
      uVar5 = g_type_check_instance_cast(uVar5,uVar4);
      gtk_misc_set_alignment(uVar5,0,0x3f000000);
      g_type_check_instance_cast(pGVar7,uVar1);
      gtk_box_pack_start();
      return;
    }
  }
  return;
}



void ghid_table_spin_button
               (GtkWidget *table,gint row,gint column,GtkWidget **spin_button,gfloat value,
               gfloat low,gfloat high,gfloat step0,gfloat step1,gint digits,gint width,
               anon_subr_void *cb_func,gpointer data,gboolean right_align,gchar *string)

{
  undefined4 uVar1;
  GtkWidget *pGVar2;
  gpointer pvVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  
  if (table != (GtkWidget *)0x0) {
    uVar1 = gtk_adjustment_new(SUB84((double)(float)value,0),
                               (int)((ulonglong)(double)(float)value >> 0x20),
                               SUB84((double)(float)low,0),
                               (int)((ulonglong)(double)(float)low >> 0x20),(double)(float)high,
                               (double)(float)step0,(double)(float)step1,0);
    pGVar2 = (GtkWidget *)gtk_spin_button_new(uVar1,0,0x3fe00000,digits);
    if (spin_button != (GtkWidget **)0x0) {
      *spin_button = pGVar2;
    }
    if (0 < width) {
      gtk_widget_set_size_request(pGVar2,width,0xffffffff);
    }
    uVar1 = gtk_spin_button_get_type();
    pvVar3 = (gpointer)g_type_check_instance_cast(pGVar2,uVar1);
    gtk_spin_button_set_numeric(pvVar3,1);
    if (data == (gpointer)0x0) {
      data = pvVar3;
    }
    if (cb_func != (anon_subr_void *)0x0) {
      uVar1 = g_type_check_instance_cast(pGVar2,0x50);
      g_signal_connect_data(uVar1,"value_changed",cb_func,data,0,0);
    }
    if (right_align == 0) {
      uVar1 = gtk_table_get_type();
      uVar4 = g_type_check_instance_cast(table,uVar1);
      gtk_table_attach_defaults(uVar4,pGVar2,column,column + 1,row,row + 1);
      if (string != (gchar *)0x0) {
        uVar4 = gtk_label_new(string);
        uVar5 = gtk_misc_get_type();
        uVar4 = g_type_check_instance_cast(uVar4,uVar5);
        gtk_misc_set_alignment(uVar4,0,0x3f000000);
        g_type_check_instance_cast(table,uVar1);
LAB_0810be18:
        gtk_table_attach_defaults();
        return;
      }
    }
    else {
      uVar1 = gtk_table_get_type();
      uVar4 = g_type_check_instance_cast(table,uVar1);
      gtk_table_attach_defaults(uVar4,pGVar2,column + 1,column + 2,row,row + 1);
      if (string != (gchar *)0x0) {
        uVar4 = gtk_label_new(string);
        uVar5 = gtk_misc_get_type();
        uVar4 = g_type_check_instance_cast(uVar4,uVar5);
        gtk_misc_set_alignment(uVar4,0x3f800000,0x3f000000);
        g_type_check_instance_cast(table,uVar1);
        goto LAB_0810be18;
      }
    }
  }
  return;
}



void ghid_button_connected
               (GtkWidget *box,GtkWidget **button,gboolean pack_start,gboolean expand,gboolean fill,
               gint pad,anon_subr_void *cb_func,gpointer data,gchar *string)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  
  if (string != (gchar *)0x0) {
    pGVar1 = (GtkWidget *)gtk_button_new_with_label(string);
    if (pack_start == 0) {
      if (box != (GtkWidget *)0x0) {
        uVar2 = gtk_box_get_type();
        uVar2 = g_type_check_instance_cast(box,uVar2);
        gtk_box_pack_end(uVar2,pGVar1,expand,fill,pad);
      }
    }
    else {
      if (box != (GtkWidget *)0x0) {
        uVar2 = gtk_box_get_type();
        uVar2 = g_type_check_instance_cast(box,uVar2);
        gtk_box_pack_start(uVar2,pGVar1,expand,fill,pad);
      }
    }
    if (cb_func != (anon_subr_void *)0x0) {
      uVar2 = gtk_object_get_type();
      uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
      gtk_signal_connect_full(uVar2,"clicked",cb_func,0,data,0,0,0);
    }
    if (button != (GtkWidget **)0x0) {
      *button = pGVar1;
    }
  }
  return;
}



gboolean ghid_button_active(GtkWidget *widget)

{
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = gtk_toggle_button_get_type();
  iVar2 = g_type_check_instance_cast(widget,uVar1);
  return (uint)*(byte *)(iVar2 + 0x58) & 1;
}



void ghid_check_button_connected
               (GtkWidget *box,GtkWidget **button,gboolean active,gboolean pack_start,
               gboolean expand,gboolean fill,gint pad,anon_subr_void *cb_func,gpointer data,
               gchar *string)

{
  GtkWidget *pGVar1;
  undefined4 uVar2;
  
  if (string != (gchar *)0x0) {
    pGVar1 = (GtkWidget *)gtk_check_button_new_with_label(string);
    uVar2 = gtk_toggle_button_get_type();
    uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
    gtk_toggle_button_set_active(uVar2,active);
    if (pack_start == 0) {
      if (box != (GtkWidget *)0x0) {
        uVar2 = gtk_box_get_type();
        uVar2 = g_type_check_instance_cast(box,uVar2);
        gtk_box_pack_end(uVar2,pGVar1,expand,fill,pad);
      }
    }
    else {
      if (box != (GtkWidget *)0x0) {
        uVar2 = gtk_box_get_type();
        uVar2 = g_type_check_instance_cast(box,uVar2);
        gtk_box_pack_start(uVar2,pGVar1,expand,fill,pad);
      }
    }
    if (cb_func != (anon_subr_void *)0x0) {
      uVar2 = gtk_object_get_type();
      uVar2 = g_type_check_instance_cast(pGVar1,uVar2);
      gtk_signal_connect_full(uVar2,"clicked",cb_func,0,data,0,0,0);
    }
    if (button != (GtkWidget **)0x0) {
      *button = pGVar1;
    }
  }
  return;
}



gchar * ghid_entry_get_text(GtkWidget *entry)

{
  gchar *pgVar1;
  undefined4 uVar2;
  
  pgVar1 = "";
  if (entry != (GtkWidget *)0x0) {
    uVar2 = gtk_entry_get_type();
    uVar2 = g_type_check_instance_cast(entry,uVar2);
    pgVar1 = (gchar *)gtk_entry_get_text(uVar2);
  }
  while ((*pgVar1 == '\t' || (*pgVar1 == ' '))) {
    pgVar1 = pgVar1 + 1;
  }
  return pgVar1;
}



void ghid_button_set_text(GtkWidget *button,gchar *text)

{
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = gtk_bin_get_type();
  uVar1 = g_type_check_instance_cast(button,uVar1);
  uVar1 = gtk_bin_get_child(uVar1);
  uVar2 = gtk_label_get_type();
  g_type_check_instance_cast(uVar1,uVar2);
  gtk_label_set_text();
  return;
}



void ghid_map_color_string(char *color_string,GdkColor *color)

{
  GdkColormap *colormap;
  
  if ((color != (GdkColor *)0x0) && (ghid_port.top_window != (GtkWidget *)0x0)) {
    if (colormap == (GdkColormap *)0x0) {
      colormap = (GdkColormap *)gtk_widget_get_colormap(ghid_port.top_window);
    }
    if ((*(int *)&color->red != 0) || (color->blue != 0)) {
      gdk_colormap_free_colors(colormap,color,1);
    }
    gdk_color_parse(color_string,color);
    gdk_color_alloc();
    return;
  }
  return;
}



gchar * ghid_get_color_name(GdkColor *color)

{
  gchar *pgVar1;
  
  if (color != (GdkColor *)0x0) {
    pgVar1 = (gchar *)g_strdup_printf("#%2.2x%2.2x%2.2x",(uint)*(byte *)((int)&color->red + 1),
                                      (uint)*(byte *)((int)&color->green + 1),
                                      (uint)*(byte *)((int)&color->blue + 1));
    return pgVar1;
  }
  pgVar1 = (gchar *)g_strdup();
  return pgVar1;
}



void ghid_draw_string_markup
               (GdkDrawable *drawable,PangoFontDescription *font_desc,GdkGC *gc,gint x,gint y,
               gchar *string)

{
  undefined4 uVar1;
  size_t sVar2;
  
  uVar1 = gtk_widget_create_pango_layout(ghid_port.top_window,0);
  pango_layout_set_font_description(uVar1,font_desc);
  sVar2 = strlen(string);
  pango_layout_set_markup(uVar1,string,sVar2);
  gdk_draw_layout(drawable,gc,x,y,uVar1);
  g_object_unref();
  return;
}



void ghid_string_markup_extents
               (PangoFontDescription *font_desc,gchar *string,gint *width,gint *height)

{
  undefined4 uVar1;
  size_t sVar2;
  gint local_24;
  gint local_20 [4];
  
  uVar1 = gtk_widget_create_pango_layout(ghid_port.top_window,0);
  pango_layout_set_font_description(uVar1,font_desc);
  sVar2 = strlen(string);
  pango_layout_set_markup(uVar1,string,sVar2);
  pango_layout_get_pixel_size(uVar1,local_20,&local_24);
  g_object_unref(uVar1);
  if (*width != 0) {
    *width = local_20[0];
  }
  if (*height != 0) {
    *height = local_24;
  }
  return;
}



void ghid_draw_area_update(GHidPort *port,GdkRectangle *rect)

{
  GdkRectangle update_rect;
  
  if (rect == (GdkRectangle *)0x0) {
    update_rect.x = 0;
    update_rect.y = 0;
    update_rect.width = port->width;
    update_rect.height = port->height;
  }
  else {
    update_rect.x = rect->x;
    update_rect.y = rect->y;
    update_rect.width = rect->width;
    update_rect.height = rect->height;
  }
  gdk_window_invalidate_rect(port->drawing_area->window,&update_rect,0);
  return;
}



ButtonState ghid_button_state(GdkModifierType *state)

{
  ButtonState BVar1;
  GdkModifierType local_10 [3];
  
  if (state == (GdkModifierType *)0x0) {
    gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_10);
  }
  else {
    local_10[0] = *state;
  }
  BVar1 = BUTTON1_PRESSED;
  if (((local_10[0] & 0x100) == 0) && (BVar1 = BUTTON2_PRESSED, (local_10[0] & 0x200) == 0)) {
    BVar1 = ~-(uint)((local_10[0] & 0x400) == 0) & 3;
  }
  return BVar1;
}



ModifierKeysState ghid_modifier_keys_state(GdkModifierType *state)

{
  byte bVar1;
  ModifierKeysState MVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  bool bVar8;
  GdkModifierType local_20 [4];
  
  if (state == (GdkModifierType *)0x0) {
    gdk_window_get_pointer((ghid_port.drawing_area)->window,0,0,local_20);
  }
  else {
    local_20[0] = *state;
  }
  uVar4 = local_20[0] & 1;
  uVar5 = local_20[0] & 8;
  uVar6 = local_20[0] & 4;
  bVar1 = uVar6 == 0 & (byte)uVar4;
  if ((bVar1 == 0) || (MVar2 = SHIFT_PRESSED, uVar5 != 0)) {
    bVar7 = uVar6 != 0;
    if (((((uVar4 != 0 || !bVar7) || (MVar2 = CONTROL_PRESSED, uVar5 != 0)) &&
         ((((bVar8 = uVar5 == 0, uVar6 != 0 || (uVar4 != 0)) || (MVar2 = MOD1_PRESSED, bVar8)) &&
          ((bVar3 = (byte)uVar4 & bVar7, bVar3 == 0 || (MVar2 = SHIFT_CONTROL_PRESSED, uVar5 != 0)))
          ))) && ((bVar1 == 0 || (MVar2 = SHIFT_MOD1_PRESSED, bVar8)))) &&
       (((uVar4 != 0 || !bVar7 || (MVar2 = CONTROL_MOD1_PRESSED, bVar8)) &&
        ((bVar3 == 0 || (MVar2 = SHIFT_CONTROL_MOD1_PRESSED, bVar8)))))) {
      MVar2 = NONE_PRESSED;
    }
  }
  return MVar2;
}



void free_glist_and_data(GList **list_head)

{
  GList *pGVar1;
  
  pGVar1 = *list_head;
  if (pGVar1 != (GList *)0x0) {
    do {
      if (pGVar1->data != (gpointer)0x0) {
        g_free(pGVar1->data);
      }
      pGVar1 = pGVar1->next;
    } while (pGVar1 != (GList *)0x0);
    g_list_free(*list_head);
    *list_head = (GList *)0x0;
  }
  return;
}



void ghid_route_style_dialog(gint index,RouteStyleType *temp_rst)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  gfloat value;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  GtkWidget *box;
  GtkWidget *table;
  GtkWidget *box_00;
  int iVar14;
  gchar *category_header;
  char *pcVar15;
  gint digits;
  gfloat high;
  int in_GS_OFFSET;
  bool bVar16;
  float10 fVar17;
  gfloat local_c0;
  int local_a0;
  gfloat local_94;
  gfloat local_8c;
  RouteStyleType rst_buf;
  GtkWidget *local_64;
  gchar buf [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_64 = (GtkWidget *)0x0;
  bVar16 = index < 4;
  if (bVar16) {
    temp_rst = PCB->RouteStyle + index;
  }
  if (temp_rst == (RouteStyleType *)0x0) goto LAB_0810cf08;
  pcVar15 = temp_rst->Name;
  uVar6 = dcgettext(&DAT_0815492c,"%s Sizes",5);
  __snprintf_chk(buf,0x40,1,0x40,uVar6,pcVar15);
  uVar6 = gtk_window_get_type();
  uVar7 = g_type_check_instance_cast(ghid_port.top_window,uVar6);
  uVar7 = gtk_dialog_new_with_buttons(buf,uVar7,3,"gtk-cancel",0xffffffff,"gtk-ok",0xfffffffb,0);
  uVar6 = g_type_check_instance_cast(uVar7,uVar6);
  gtk_window_set_wmclass(uVar6,"Sizes_dialog",&DAT_08154932);
  box_00 = (GtkWidget *)gtk_vbox_new(0,2);
  uVar6 = gtk_container_get_type();
  uVar8 = g_type_check_instance_cast(box_00,uVar6);
  gtk_container_set_border_width(uVar8,6);
  uVar8 = gtk_dialog_get_type();
  iVar9 = g_type_check_instance_cast(uVar7,uVar8);
  uVar6 = g_type_check_instance_cast(*(undefined4 *)(iVar9 + 0x94),uVar6);
  gtk_container_add(uVar6,box_00);
  if (Settings.grid_units_mm == '\0') {
    uVar6 = dcgettext(&DAT_0815492c,&DAT_081562ee,5);
  }
  else {
    uVar6 = dcgettext(&DAT_0815492c,&DAT_0815627e,5);
  }
  uVar10 = dcgettext(&DAT_0815492c,"<b>%s</b> grid units are selected",5);
  uVar6 = g_strdup_printf(uVar10,uVar6);
  uVar10 = gtk_label_new(&DAT_0814741b);
  uVar11 = gtk_label_get_type();
  uVar12 = g_type_check_instance_cast(uVar10,uVar11);
  gtk_label_set_use_markup(uVar12,1);
  uVar12 = g_type_check_instance_cast(uVar10,uVar11);
  gtk_label_set_markup(uVar12,uVar6);
  g_free(uVar6);
  uVar6 = gtk_box_get_type();
  uVar12 = g_type_check_instance_cast(box_00,uVar6);
  gtk_box_pack_start(uVar12,uVar10,0,0,4);
  uVar10 = gtk_hbox_new(0,4);
  uVar12 = g_type_check_instance_cast(box_00,uVar6);
  gtk_box_pack_start(uVar12,uVar10,0,0,4);
  uVar12 = dcgettext(&DAT_0815492c,"Route style name",5);
  uVar12 = gtk_label_new(uVar12);
  uVar13 = g_type_check_instance_cast(uVar10,uVar6);
  gtk_box_pack_start(uVar13,uVar12,0,0,0);
  box = (GtkWidget *)gtk_entry_new();
  route_sizes.name_entry = box;
  uVar10 = g_type_check_instance_cast(uVar10,uVar6);
  gtk_box_pack_start(uVar10,box,0,0,0);
  route_sizes.units_mm = (gboolean)Settings.grid_units_mm;
  category_header = (gchar *)dcgettext(&DAT_0815492c,0x815c545,5);
  box = ghid_category_vbox(box_00,category_header,4,2,1,1);
  table = (GtkWidget *)gtk_table_new(4,2,0);
  uVar10 = gtk_table_get_type();
  uVar12 = g_type_check_instance_cast(table,uVar10);
  gtk_table_set_col_spacings(uVar12,6);
  uVar10 = g_type_check_instance_cast(table,uVar10);
  gtk_table_set_row_spacings(uVar10,3);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Line width",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.00000000;
    local_c0 = 0.01000000;
    high = 100000.00000000;
    local_94 = 5.00000000;
    digits = 1;
    value = (gfloat)((float)temp_rst->Thick * 0.01000000);
  }
  else {
    value = (gfloat)((float)temp_rst->Thick * 0.00025400);
    local_8c = 0.05000000;
    local_c0 = 0.00025400;
    high = 2540.00000000;
    local_94 = 0.25000000;
    digits = 3;
  }
  ghid_table_spin_button
            (table,0,0,&route_sizes.line_width_spin_button,value,local_c0,high,local_8c,local_94,
             digits,0,(anon_subr_void *)0x0,&route_sizes,1,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Via hole",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.00000000;
    local_c0 = 4.00000000;
    high = 99996.00000000;
    local_94 = 5.00000000;
    digits = 1;
    value = (gfloat)((float)temp_rst->Hole * 0.01000000);
  }
  else {
    value = (gfloat)((float)temp_rst->Hole * 0.00025400);
    local_8c = 0.05000000;
    local_c0 = 0.10160000;
    high = 2539.89843750;
    local_94 = 0.25000000;
    digits = 3;
  }
  ghid_table_spin_button
            (table,1,0,&route_sizes.via_hole_spin_button,value,local_c0,high,local_8c,local_94,
             digits,0,via_hole_cb,&route_sizes,1,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Via size",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.00000000;
    local_c0 = 8.00000000;
    high = 100000.00000000;
    local_94 = 5.00000000;
    digits = 1;
    value = (gfloat)((float)temp_rst->Diameter * 0.01000000);
  }
  else {
    value = (gfloat)((float)temp_rst->Diameter * 0.00025400);
    local_8c = 0.05000000;
    local_c0 = 0.20320000;
    high = 2540.00000000;
    local_94 = 0.25000000;
    digits = 3;
  }
  ghid_table_spin_button
            (table,2,0,&route_sizes.via_size_spin_button,value,local_c0,high,local_8c,local_94,
             digits,0,via_size_cb,&route_sizes,1,category_header);
  category_header = (gchar *)dcgettext(&DAT_0815492c,"Clearance",5);
  if (Settings.grid_units_mm == '\0') {
    local_8c = 1.00000000;
    local_c0 = 0.01000000;
    high = 100000.00000000;
    local_94 = 5.00000000;
    digits = 1;
    value = (gfloat)((float)temp_rst->Keepaway * 0.01000000);
  }
  else {
    value = (gfloat)((float)temp_rst->Keepaway * 0.00025400);
    local_8c = 0.05000000;
    local_c0 = 0.00025400;
    high = 2540.00000000;
    local_94 = 0.25000000;
    digits = 3;
  }
  ghid_table_spin_button
            (table,3,0,&route_sizes.clearance_spin_button,value,local_c0,high,local_8c,local_94,
             digits,0,(anon_subr_void *)0x0,&route_sizes,1,category_header);
  uVar10 = g_type_check_instance_cast(box,uVar6);
  gtk_box_pack_start(uVar10,table,0,0,0);
  if (bVar16) {
    category_header = (gchar *)dcgettext(&DAT_0815492c,"Temporary Styles",5);
    box = ghid_category_vbox(box_00,category_header,4,2,1,1);
    uVar10 = gtk_label_new(&DAT_0814741b);
    uVar12 = g_type_check_instance_cast(uVar10,uVar11);
    gtk_label_set_use_markup(uVar12,1);
    pcVar15 = temp_rst->Name;
    uVar12 = dcgettext(&DAT_0815492c,
                       "<small>Use values in a temporary route style instead of <b>%s</b>.</small>",
                       5);
    uVar12 = g_strdup_printf(uVar12,pcVar15);
    uVar13 = g_type_check_instance_cast(uVar10,uVar11);
    gtk_label_set_markup(uVar13,uVar12);
    g_free(uVar12);
    uVar12 = g_type_check_instance_cast(box,uVar6);
    gtk_box_pack_start(uVar12,uVar10,0,0,0);
    category_header = (gchar *)dcgettext(&DAT_0815492c,"Temp1",5);
    ghid_check_button_connected
              (box,&route_sizes.set_temp1_button,0,1,0,0,0,use_temp_cb,&DAT_00000001,category_header
              );
    category_header = (gchar *)dcgettext(&DAT_0815492c,"Temp2",5);
    ghid_check_button_connected
              (box,&route_sizes.set_temp2_button,0,1,0,0,0,use_temp_cb,(gpointer)0x2,category_header
              );
    category_header = (gchar *)dcgettext(&DAT_0815492c,"Default Style",5);
    box_00 = ghid_category_vbox(box_00,category_header,4,2,1,1);
    uVar10 = gtk_label_new(&DAT_0814741b);
    uVar12 = g_type_check_instance_cast(uVar10,uVar11);
    gtk_label_set_use_markup(uVar12,1);
    uVar12 = dcgettext(&DAT_0815492c,
                       "<small>Use values as the default route style for new layouts.</small>",5);
    uVar12 = g_strdup_printf(uVar12);
    uVar11 = g_type_check_instance_cast(uVar10,uVar11);
    gtk_label_set_markup(uVar11,uVar12);
    g_free(uVar12);
    uVar6 = g_type_check_instance_cast(box_00,uVar6);
    gtk_box_pack_start(uVar6,uVar10,0,0,0);
    category_header = (gchar *)dcgettext(&DAT_0815492c,"Set as default",5);
    ghid_check_button_connected
              (box_00,&local_64,0,1,0,0,0,(anon_subr_void *)0x0,(gpointer)0x0,category_header);
    pcVar15 = temp_rst->Name;
    uVar6 = gtk_entry_get_type();
    uVar6 = g_type_check_instance_cast(route_sizes.name_entry,uVar6);
    gtk_entry_set_text(uVar6,pcVar15);
  }
  else {
    uVar6 = gtk_entry_get_type();
    pcVar15 = temp_rst->Name;
    uVar6 = g_type_check_instance_cast(route_sizes.name_entry,uVar6);
    gtk_entry_set_text(uVar6,pcVar15);
    uVar6 = gtk_editable_get_type();
    uVar6 = g_type_check_instance_cast(route_sizes.name_entry,uVar6);
    gtk_editable_set_editable(uVar6,0);
  }
  gtk_widget_show_all(uVar7);
  uVar6 = g_type_check_instance_cast(uVar7,uVar8);
  iVar9 = gtk_dialog_run(uVar6);
  if (iVar9 == -5) {
    iVar9 = 0;
    if (bVar16) {
      uVar6 = gtk_toggle_button_get_type();
      uVar8 = g_type_check_instance_cast(route_sizes.set_temp1_button,uVar6);
      iVar14 = gtk_toggle_button_get_active(uVar8);
      uVar8 = g_type_check_instance_cast(route_sizes.set_temp2_button,uVar6);
      local_a0 = gtk_toggle_button_get_active(uVar8);
      uVar6 = g_type_check_instance_cast(local_64,uVar6);
      iVar9 = gtk_toggle_button_get_active(uVar6);
      if ((local_a0 == 0) && (iVar14 == 0)) goto LAB_0810d410;
      bVar16 = iVar14 == 0;
      temp_rst = &rst_buf;
    }
    else {
LAB_0810d410:
      bVar16 = true;
      local_a0 = 0;
    }
    uVar6 = gtk_spin_button_get_type();
    uVar8 = g_type_check_instance_cast(route_sizes.line_width_spin_button,uVar6);
    fVar17 = (float10)gtk_spin_button_get_value(uVar8);
    if (Settings.grid_units_mm == '\0') {
      fVar17 = fVar17 * (float10)100.00000000;
    }
    else {
      fVar17 = fVar17 / (float10)0.00025400;
    }
    temp_rst->Thick = (int)ROUND(fVar17 + (float10)0.50000000);
    uVar8 = g_type_check_instance_cast(route_sizes.via_hole_spin_button,uVar6);
    fVar17 = (float10)gtk_spin_button_get_value(uVar8);
    if (Settings.grid_units_mm == '\0') {
      fVar17 = fVar17 * (float10)100.00000000;
    }
    else {
      fVar17 = fVar17 / (float10)0.00025400;
    }
    temp_rst->Hole = (int)ROUND(fVar17 + (float10)0.50000000);
    uVar8 = g_type_check_instance_cast(route_sizes.via_size_spin_button,uVar6);
    fVar17 = (float10)gtk_spin_button_get_value(uVar8);
    if (Settings.grid_units_mm == '\0') {
      fVar17 = fVar17 * (float10)100.00000000;
    }
    else {
      fVar17 = fVar17 / (float10)0.00025400;
    }
    temp_rst->Diameter = (int)ROUND(fVar17 + (float10)0.50000000);
    uVar6 = g_type_check_instance_cast(route_sizes.clearance_spin_button,uVar6);
    fVar17 = (float10)gtk_spin_button_get_value(uVar6);
    if (Settings.grid_units_mm == '\0') {
      fVar17 = fVar17 * (float10)100.00000000;
    }
    else {
      fVar17 = fVar17 / (float10)0.00025400;
    }
    temp_rst->Keepaway = (int)ROUND(fVar17 + (float10)0.50000000);
    if ((bVar16) && (index < 4)) {
      if (local_a0 != 0) {
        pcb_use_route_style(temp_rst);
        digits = 1;
        goto LAB_0810d5a9;
      }
      category_header = ghid_entry_get_text(route_sizes.name_entry);
      SaveFree(temp_rst->Name);
      pcVar15 = StripWhiteSpaceAndDup(category_header);
      temp_rst->Name = pcVar15;
      pcb_use_route_style(temp_rst);
      SetChangedFlag('\x01');
      ghid_route_style_set_button_label(temp_rst->Name,index);
    }
    else {
      pcb_use_route_style(temp_rst);
      if (bVar16) {
        digits = 1;
        if (local_a0 == 0) {
          digits = index + -4;
        }
      }
      else {
        digits = 0;
      }
LAB_0810d5a9:
      ghid_route_style_set_temp_style(temp_rst,digits);
    }
    if (iVar9 != 0) {
      Settings.RouteStyle[index].Thick = temp_rst->Thick;
      Settings.RouteStyle[index].Diameter = temp_rst->Diameter;
      Settings.RouteStyle[index].Hole = temp_rst->Hole;
      Settings.RouteStyle[index].Keepaway = temp_rst->Keepaway;
      Settings.RouteStyle[index].Name = temp_rst->Name;
      Settings.RouteStyle[index].index = temp_rst->index;
      ghidgui->config_modified = 1;
      uVar8 = g_strdup(&DAT_0814741b);
      uVar6 = g_strdup_printf("%s,%d,%d,%d,%d",Settings.RouteStyle[0].Name,
                              Settings.RouteStyle[0].Thick,Settings.RouteStyle[0].Diameter,
                              Settings.RouteStyle[0].Hole,Settings.RouteStyle[0].Keepaway);
      uVar6 = g_strconcat(uVar8,uVar6,&DAT_0814d79c,0);
      iVar9 = 0;
      g_free(uVar8);
      while( true ) {
        puVar1 = (undefined4 *)((int)&Settings.RouteStyle[1].Keepaway + iVar9);
        puVar2 = (undefined4 *)((int)&Settings.RouteStyle[1].Hole + iVar9);
        puVar3 = (undefined4 *)((int)&Settings.RouteStyle[1].Diameter + iVar9);
        puVar4 = (undefined4 *)((int)&Settings.RouteStyle[1].Thick + iVar9);
        puVar5 = (undefined4 *)((int)&Settings.RouteStyle[1].Name + iVar9);
        iVar9 = iVar9 + 0x18;
        uVar8 = g_strdup_printf("%s,%d,%d,%d,%d",*puVar5,*puVar4,*puVar3,*puVar2,*puVar1);
        if (iVar9 == 0x48) break;
        uVar8 = g_strconcat(uVar6,uVar8,&DAT_0814d79c,0);
        g_free(uVar6);
        uVar6 = uVar8;
      }
      pcVar15 = (char *)g_strconcat(uVar6,uVar8,0,0);
      g_free(uVar6);
      g_free(Settings.Routes);
      Settings.Routes = pcVar15;
    }
  }
  gtk_widget_destroy(uVar7);
  ghid_set_status_line_label();
LAB_0810cf08:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void use_temp_cb(GtkWidget *button,gpointer data)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  GtkWidget *pGVar4;
  
  uVar1 = gtk_toggle_button_get_type();
  uVar2 = g_type_check_instance_cast(button,uVar1);
  iVar3 = gtk_toggle_button_get_active(uVar2);
  if ((iVar3 != 0) &&
     ((pGVar4 = route_sizes.set_temp2_button, (undefined *)data == &DAT_00000001 ||
      (pGVar4 = route_sizes.set_temp1_button, data == (gpointer)0x2)))) {
    g_type_check_instance_cast(pGVar4,uVar1);
    gtk_toggle_button_set_active();
    return;
  }
  return;
}



void via_size_cb(GtkWidget *widget,SizesDialog *sd)

{
  undefined4 uVar1;
  undefined4 uVar2;
  float10 fVar3;
  float10 fVar4;
  float10 fVar5;
  undefined8 local_28;
  undefined4 uVar6;
  double local_1c;
  
  uVar6 = (undefined4)((ulonglong)local_28 >> 0x20);
  uVar1 = gtk_spin_button_get_type();
  uVar2 = g_type_check_instance_cast(widget,uVar1);
  fVar3 = (float10)gtk_spin_button_get_value(uVar2);
  uVar2 = g_type_check_instance_cast(sd->via_hole_spin_button,uVar1,uVar6);
  fVar4 = (float10)gtk_spin_button_get_value(uVar2);
  if (Settings.grid_units_mm == '\0') {
    fVar5 = (float10)4.00000000;
  }
  else {
    fVar5 = (float10)0.10160000;
  }
  if ((float10)(double)fVar3 - fVar5 < fVar4) {
    if (Settings.grid_units_mm == '\0') {
      local_1c = 4.00000000;
    }
    else {
      local_1c = 0.10160000;
    }
    uVar1 = g_type_check_instance_cast(sd->via_hole_spin_button,uVar1,uVar6);
    gtk_spin_button_set_value(uVar1,(double)fVar3 - local_1c);
  }
  return;
}



void via_hole_cb(GtkWidget *widget,SizesDialog *sd)

{
  float fVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  undefined8 local_38;
  undefined4 uVar7;
  
  uVar7 = (undefined4)((ulonglong)local_38 >> 0x20);
  uVar2 = gtk_spin_button_get_type();
  uVar3 = g_type_check_instance_cast(widget,uVar2);
  fVar4 = (float10)gtk_spin_button_get_value(uVar3);
  uVar3 = g_type_check_instance_cast(sd->via_size_spin_button,uVar2,uVar7);
  fVar5 = (float10)gtk_spin_button_get_value(uVar3);
  if (Settings.grid_units_mm == '\0') {
    fVar6 = (float10)4.00000000;
  }
  else {
    fVar6 = (float10)0.10160000;
  }
  if (fVar5 < fVar6 + (float10)(double)fVar4) {
    if (Settings.grid_units_mm == '\0') {
      fVar1 = 4.00000000;
    }
    else {
      fVar1 = 0.10160000;
    }
    uVar2 = g_type_check_instance_cast(sd->via_size_spin_button,uVar2,uVar7);
    gtk_spin_button_set_value(uVar2,(double)fVar1 + (double)fVar4);
  }
  return;
}



void lpr_calibrate(double xval,double yval)

{
  ps_calibrate_1(xval,yval,1);
  return;
}



HID_Attribute * lpr_get_export_options(int *n)

{
  HID_Attribute *__src;
  
  if ((base_lpr_options[0].default_val.str_value == (char *)0x0) &&
     (base_lpr_options[0].default_val.str_value = (char *)calloc(1,4),
     (undefined4 *)base_lpr_options[0].default_val.str_value != (undefined4 *)0x0)) {
    *(undefined4 *)base_lpr_options[0].default_val.str_value = 0x72706c;
  }
  if (lpr_options == (HID_Attribute *)0x0) {
    __src = (*ps_hid.get_export_options)(&num_lpr_options);
    lpr_options = (HID_Attribute *)calloc(num_lpr_options,0x30);
    memcpy(lpr_options,__src,num_lpr_options * 0x30);
    __src = lpr_options;
    lpr_options->name = base_lpr_options[0].name;
    __src->help_text = base_lpr_options[0].help_text;
    __src->type = base_lpr_options[0].type;
    __src->min_val = base_lpr_options[0].min_val;
    __src->max_val = base_lpr_options[0].max_val;
    (__src->default_val).int_value = base_lpr_options[0].default_val.int_value;
    (__src->default_val).str_value = base_lpr_options[0].default_val.str_value;
    *(undefined4 *)&(__src->default_val).real_value =
         base_lpr_options[0].default_val.real_value._0_4_;
    *(undefined4 *)((int)&(__src->default_val).real_value + 4) =
         base_lpr_options[0].default_val.real_value._4_4_;
    __src->enumerations = base_lpr_options[0].enumerations;
    __src->value = base_lpr_options[0].value;
    __src->hash = base_lpr_options[0].hash;
    lpr_values = (HID_Attr_Val *)calloc(num_lpr_options,0x10);
  }
  __src = lpr_options;
  if (n != (int *)0x0) {
    *n = num_lpr_options;
  }
  return __src;
}



void lpr_parse_arguments(int *argc,char ***argv)

{
  lpr_get_export_options((int *)0x0);
  hid_register_attributes(lpr_options,num_lpr_options);
  hid_parse_command_line(argc,argv);
  return;
}



void lpr_do_export(HID_Attr_Val *options)

{
  char *__command;
  HID_Attr_Val *pHVar1;
  int iVar2;
  FILE *f;
  HID_Attr_Val *pHVar3;
  int iVar4;
  HID_Attribute *pHVar5;
  
  if ((options == (HID_Attr_Val *)0x0) &&
     (lpr_get_export_options((int *)0x0), options = lpr_values, iVar2 = num_lpr_options,
     0 < num_lpr_options)) {
    iVar4 = 0;
    pHVar3 = lpr_values;
    pHVar5 = lpr_options;
    do {
      iVar4 = iVar4 + 1;
      pHVar3->int_value = (pHVar5->default_val).int_value;
      pHVar3->str_value = (pHVar5->default_val).str_value;
      *(undefined4 *)&pHVar3->real_value = *(undefined4 *)&(pHVar5->default_val).real_value;
      pHVar1 = &pHVar5->default_val;
      pHVar5 = pHVar5 + 1;
      *(undefined4 *)((int)&pHVar3->real_value + 4) = *(undefined4 *)((int)&pHVar1->real_value + 4);
      pHVar3 = pHVar3 + 1;
    } while (iVar4 != iVar2);
  }
  __command = options->str_value;
  __printf_chk(1,0x815c678,__command);
  f = (FILE *)popen(__command,"w");
  if (f == (FILE *)0x0) {
    perror(__command);
    return;
  }
  ps_start_file(f);
  ps_hid_export_to_file(f,options);
  fclose((FILE *)f);
  return;
}



void hid_lpr_init(void)

{
  apply_default_hid(&lpr_hid,&ps_hid);
  apply_default_hid(&lpr_hid,(HID *)0x0);
  hid_register_hid(&lpr_hid);
  return;
}



void bom_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes((HID_Attribute *)bom_options,3);
  hid_parse_command_line(argc,argv);
  return;
}



double xyToAngle(double x,double y)

{
  float fVar1;
  float fVar2;
  
  fVar2 = (float)x;
  fVar1 = (float)y;
  if ((0.00000000 < fVar2) && (0.00000000 <= fVar1)) {
    return 180.00000000;
  }
  if ((fVar2 <= 0.00000000) && (0.00000000 < fVar1)) {
    return 90.00000000;
  }
  if ((0.00000000 <= fVar2) || (0.00000000 < fVar1)) {
    if ((0.00000000 <= fVar2) && (fVar1 < 0.00000000)) {
      return 270.00000000;
    }
    Message(
            "xyToAngle(): unable to figure out angle of element\n     because the pin is at the centroid of the part.\n     This is a BUG!!!\n     Setting to %g degrees\n"
            ,0);
  }
  return 0.00000000;
}



StringList * __regparm3 string_insert(char *str,StringList *list)

{
  _StringList *p_Var1;
  char *pcVar2;
  StringList *pSVar3;
  StringList *pSVar4;
  
  pSVar4 = (StringList *)calloc(1,8);
  if (pSVar4 == (StringList *)0x0) {
    __fprintf_chk(stderr,1,"malloc() failed in string_insert()\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  pSVar4->next = (_StringList *)0x0;
  pcVar2 = (char *)__strdup(str);
  pSVar4->str = pcVar2;
  p_Var1 = (_StringList *)list;
  if (list != (StringList *)0x0) {
    do {
      pSVar3 = (StringList *)p_Var1;
      p_Var1 = pSVar3->next;
    } while (p_Var1 != (_StringList *)0x0);
    *(StringList **)&pSVar3->next = pSVar4;
    pSVar4 = list;
  }
  return pSVar4;
}



char * __regparm3 CleanBOMString(char *in)

{
  char cVar1;
  size_t sVar2;
  char *pcVar3;
  uint uVar4;
  uint uVar5;
  
  sVar2 = strlen(in);
  pcVar3 = (char *)calloc(1,sVar2 + 1);
  if (pcVar3 != (char *)0x0) {
    uVar5 = 0;
    do {
      cVar1 = in[uVar5];
      if (cVar1 == '\"') {
        cVar1 = '\'';
      }
      uVar4 = uVar5 + 1;
      pcVar3[uVar5] = cVar1;
      sVar2 = strlen(in);
      uVar5 = uVar4;
    } while (uVar4 <= sVar2);
    return pcVar3;
  }
  __fprintf_chk(stderr,1,"Error:  CleanBOMString() malloc() failed\n");
                    // WARNING: Subroutine does not return
  exit(1);
}



void __regparm3 print_and_free(FILE *fp,BomList *bom)

{
  _BomList *p_Var1;
  char *__ptr;
  char *__ptr_00;
  StringList *__ptr_01;
  
  if (bom != (BomList *)0x0) {
    do {
      if (fp != (FILE *)0x0) {
        __ptr = CleanBOMString(bom->descr);
        __ptr_00 = CleanBOMString(bom->value);
        __fprintf_chk(fp,1,&DAT_0815ca1c,bom->num,__ptr,__ptr_00);
        free(__ptr);
        free(__ptr_00);
      }
      while (__ptr_01 = bom->refdes, __ptr_01 != (StringList *)0x0) {
        if (fp != (FILE *)0x0) {
          __fprintf_chk(fp,1,&DAT_08147f34,__ptr_01->str);
          __ptr_01 = bom->refdes;
        }
        free(__ptr_01->str);
        __ptr_01 = bom->refdes;
        *(_StringList **)&bom->refdes = __ptr_01->next;
        free(__ptr_01);
      }
      if (fp != (FILE *)0x0) {
        __fprintf_chk(fp,1,0x8151453);
      }
      p_Var1 = bom->next;
      free(bom);
      bom = (BomList *)p_Var1;
    } while (p_Var1 != (_BomList *)0x0);
  }
  return;
}



HID_Attribute * bom_get_export_options(int *n)

{
  char *last_xy_filename;
  char *last_bom_filename;
  
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)bom_options,".bom",(char **)&ram0x0818f4a4);
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)(bom_options + 1),".xy",(char **)&ram0x0818f4a0);
  }
  if (n != (int *)0x0) {
    *n = 3;
  }
  return (HID_Attribute *)bom_options;
}



// WARNING: Removing unreachable block (ram,0x0810eb21)

void bom_do_export(HID_Attr_Val *options)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  FILE *__stream;
  tm *__tp;
  char *__s1;
  DataTypePtr *pDVar14;
  char *str;
  int iVar15;
  _BomList *p_Var16;
  int iVar17;
  int iVar18;
  char *__ptr;
  StringList *pSVar19;
  FILE *fp;
  int iVar20;
  uint uVar21;
  BomList *pBVar22;
  uint uVar23;
  char *__s1_00;
  HID_Attr_Val *pHVar24;
  HID_Attr_Val *pHVar25;
  int in_GS_OFFSET;
  byte bVar26;
  double local_174;
  undefined4 uVar27;
  BomList *local_cc;
  int local_c8;
  double local_c4;
  double local_bc;
  int local_b0;
  double local_ac;
  double local_9c;
  int local_8c;
  time_t local_64;
  char utcTime [64];
  
  bVar26 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (options == (HID_Attr_Val *)0x0) {
    bom_get_export_options((int *)0x0);
    iVar20 = 4;
    pHVar24 = &bom_options[0].default_val;
    pHVar25 = bom_values;
    while (iVar20 != 0) {
      iVar20 = iVar20 + -1;
      pHVar25->int_value = pHVar24->int_value;
      pHVar24 = (HID_Attr_Val *)(&pHVar24->int_value + (uint)bVar26 * 0x3ffffffe + 1);
      pHVar25 = (HID_Attr_Val *)(&pHVar25->int_value + (uint)bVar26 * 0x3ffffffe + 1);
    }
    iVar20 = 4;
    pHVar24 = &bom_options[1].default_val;
    while (iVar20 != 0) {
      iVar20 = iVar20 + -1;
      pHVar25->int_value = pHVar24->int_value;
      pHVar24 = (HID_Attr_Val *)(&pHVar24->int_value + (uint)bVar26 * 0x3ffffffe + 1);
      pHVar25 = (HID_Attr_Val *)(&pHVar25->int_value + (uint)bVar26 * 0x3ffffffe + 1);
    }
    options = bom_values;
    iVar20 = 4;
    pHVar24 = &bom_options[2].default_val;
    while (iVar20 != 0) {
      iVar20 = iVar20 + -1;
      pHVar25->int_value = pHVar24->int_value;
      pHVar24 = (HID_Attr_Val *)(&pHVar24->int_value + (uint)bVar26 * 0x3ffffffe + 1);
      pHVar25 = (HID_Attr_Val *)(&pHVar25->int_value + (uint)bVar26 * 0x3ffffffe + 1);
    }
  }
  bom_filename = "pcb-out.bom";
  if (options->str_value != (char *)0x0) {
    bom_filename = options->str_value;
  }
  xy_dim_type = options[2].int_value;
  xy_filename = "pcb-out.xy";
  if (options[1].str_value != (char *)0x0) {
    xy_filename = options[1].str_value;
  }
  __stream = fopen(xy_filename,"w");
  if (__stream == (FILE *)0x0) {
    (*gui->log)("Cannot open file %s for writing\n");
  }
  else {
    local_64 = time((time_t *)0x0);
    __tp = gmtime(&local_64);
    strftime(utcTime,0x40,"%c UTC",__tp);
    __fprintf_chk(__stream,1,"# $Id",__tp);
    __fprintf_chk(__stream,1,&DAT_0815ca47,__tp);
    __fprintf_chk(__stream,1,"# PcbXY Version 1.0\n",__tp);
    __fprintf_chk(__stream,1,"# Date: %s\n",utcTime);
    __s1 = pcb_author();
    __fprintf_chk(__stream,1,"# Author: %s\n",__s1);
    __s1 = PCB->Name;
    if (__s1 == (char *)0x0) {
      __s1 = "(unknown)";
    }
    else {
      if (*__s1 == '\0') {
        __s1 = "(unknown)";
      }
    }
    __fprintf_chk(__stream,1,"# Title: %s - PCB X-Y\n",__s1);
    __fprintf_chk(__stream,1,"# RefDes, Description, Value, X, Y, rotation, top/bottom\n",__s1);
    if (xy_dim_type == 0) {
      __fprintf_chk(__stream,1,"# X,Y in mils.  rotation in degrees.\n",__s1);
    }
    else {
      __fprintf_chk(__stream,1,"# X,Y in mm.  rotation in degrees.\n",__s1);
    }
    local_174 = (double)CONCAT44(__s1,0x815c850);
    __fprintf_chk(__stream,1,"# --------------------------------------------\n",__s1);
    uVar27 = (undefined4)((ulonglong)local_174 >> 0x20);
    pDVar14 = PCB->Data;
    local_b0 = pDVar14->ElementN - 1;
    if (local_b0 != -1) {
      local_c4 = 0.00000000;
      local_bc = 0.00000000;
      local_cc = (BomList *)0x0;
      local_9c = 0.00000000;
      local_ac = 0.00000000;
      iVar20 = pDVar14->ElementN * 300;
      do {
        local_c8 = iVar20 + -300;
        iVar20 = (int)&pDVar14->Element[-1].BoundingBox.X1 + iVar20;
        __s1 = *(char **)(iVar20 + 0xd0);
        if (__s1 == (char *)0x0) {
          __s1 = "(unknown)";
        }
        else {
          if (*__s1 == '\0') {
            __s1 = "(unknown)";
          }
        }
        __s1_00 = *(char **)(iVar20 + 0x58);
        if (__s1_00 == (char *)0x0) {
          __s1_00 = "(unknown)";
        }
        else {
          if (*__s1_00 == '\0') {
            __s1_00 = "(unknown)";
          }
        }
        __ptr = *(char **)(iVar20 + 0x94);
        p_Var16 = (_BomList *)local_cc;
        if (__ptr == (char *)0x0) {
          str = "(unknown)";
          if (local_cc == (BomList *)0x0) goto LAB_0810eb60;
LAB_0810e3ea:
          do {
            pBVar22 = (BomList *)p_Var16;
            if ((((pBVar22->descr != (char *)0x0) &&
                 (iVar15 = strcmp(__s1_00,pBVar22->descr), iVar15 == 0)) &&
                (pBVar22->value != (char *)0x0)) &&
               (iVar15 = strcmp(__s1,pBVar22->value), iVar15 == 0)) {
              pBVar22->num = pBVar22->num + 1;
              pSVar19 = string_insert(str,pBVar22->refdes);
              iVar15 = *(int *)(iVar20 + 0xe0);
              pBVar22->refdes = pSVar19;
              goto joined_r0x0810eaf0;
            }
            p_Var16 = pBVar22->next;
          } while (pBVar22->next != (_BomList *)0x0);
          p_Var16 = (_BomList *)calloc(1,0x14);
          uVar27 = (undefined4)((ulonglong)local_174 >> 0x20);
          if (p_Var16 == (_BomList *)0x0) {
LAB_0810ee24:
            __fprintf_chk(stderr,1,"malloc() failed in bom_insert()\n",uVar27);
                    // WARNING: Subroutine does not return
            exit(1);
          }
          pBVar22->next = p_Var16;
          p_Var16->next = (_BomList *)0x0;
          __s1 = (char *)__strdup();
          p_Var16->descr = __s1;
          __s1 = (char *)__strdup();
          p_Var16->num = 1;
          p_Var16->value = __s1;
          pSVar19 = string_insert(str,(StringList *)0x0);
          p_Var16->refdes = pSVar19;
        }
        else {
          str = "(unknown)";
          if (*__ptr != '\0') {
            str = __ptr;
          }
          if (local_cc != (BomList *)0x0) goto LAB_0810e3ea;
LAB_0810eb60:
          local_cc = (BomList *)calloc(1,0x14);
          uVar27 = (undefined4)((ulonglong)local_174 >> 0x20);
          if (local_cc == (BomList *)0x0) goto LAB_0810ee24;
          local_cc->next = (_BomList *)0x0;
          __s1 = (char *)__strdup();
          local_cc->descr = __s1;
          __s1 = (char *)__strdup();
          *(undefined **)&local_cc->num = &DAT_00000001;
          local_cc->value = __s1;
          pSVar19 = string_insert(str,(StringList *)0x0);
          local_cc->refdes = pSVar19;
        }
        iVar15 = *(int *)(iVar20 + 0xe0);
joined_r0x0810eaf0:
        if (iVar15 == 0) {
          dVar7 = 0.00000000;
          dVar8 = 0.00000000;
          bVar12 = false;
          bVar11 = false;
          local_8c = 0;
        }
        else {
          dVar7 = 0.00000000;
          iVar17 = *(int *)(iVar20 + 0x100);
          bVar11 = false;
          local_8c = 0;
          dVar5 = local_bc;
          dVar8 = dVar7;
          dVar9 = local_c4;
          bVar13 = false;
          do {
            dVar6 = (double)*(int *)(iVar17 + 0x34);
            __s1 = *(char **)(iVar17 + 0x40);
            dVar7 = dVar7 + dVar6;
            dVar10 = (double)*(int *)(iVar17 + 0x38);
            dVar8 = dVar8 + dVar10;
            local_bc = dVar5;
            local_c4 = dVar9;
            bVar12 = bVar13;
            if (__s1 != (char *)0x0) {
              if ((*__s1 == '1') && (__s1[1] == '\0')) {
                bVar11 = true;
                local_ac = dVar6;
                local_9c = dVar10;
              }
              else {
                if ((*__s1 == '2') &&
                   (local_bc = dVar6, local_c4 = dVar10, bVar12 = true, __s1[1] != '\0')) {
                  local_bc = dVar5;
                  local_c4 = dVar9;
                  bVar12 = bVar13;
                }
              }
            }
            local_8c = local_8c + 1;
            iVar17 = iVar17 + 0x4c;
            dVar5 = local_bc;
            dVar9 = local_c4;
            bVar13 = bVar12;
          } while (local_8c != iVar15);
        }
        uVar23 = 0;
        uVar2 = *(uint *)(iVar20 + 0xe8);
        uVar21 = uVar2;
        while ((uVar21 != 0 && (uVar23 < uVar21))) {
          iVar18 = uVar23 * 0x68 + *(int *)(iVar20 + 0x104);
          iVar15 = *(int *)(iVar18 + 0x2c);
          iVar17 = *(int *)(iVar18 + 0x40);
          iVar3 = *(int *)(iVar18 + 0x30);
          iVar4 = *(int *)(iVar18 + 0x44);
          dVar9 = (double)(iVar17 + iVar15) * 0.50000000;
          __s1 = *(char **)(iVar18 + 0x5c);
          dVar5 = (double)(iVar3 + iVar4) * 0.50000000;
          if (__s1 != (char *)0x0) {
            if ((*__s1 == '1') && (__s1[1] == '\0')) {
              local_174 = (double)(iVar17 - iVar15);
              atan2((double)(iVar3 - iVar4),local_174);
              bVar11 = true;
              uVar21 = *(uint *)(iVar20 + 0xe8);
              local_ac = dVar9;
              local_9c = dVar5;
            }
            else {
              if ((*__s1 == '2') && (__s1[1] == '\0')) {
                local_174 = (double)(iVar17 - iVar15);
                atan2((double)(iVar3 - iVar4),local_174);
                bVar12 = true;
                uVar21 = *(uint *)(iVar20 + 0xe8);
                local_c4 = dVar5;
                local_bc = dVar9;
              }
            }
          }
          dVar7 = dVar7 + dVar9;
          local_8c = local_8c + 1;
          uVar23 = uVar23 + (uVar2 == uVar21);
          dVar8 = dVar8 + dVar5;
        }
        if (local_8c != 0) {
          if (bVar11) {
            local_ac = local_ac - dVar7 / (double)local_8c;
            local_9c = -(local_9c - (double)local_8c / dVar8);
            if (local_8c != 1) {
              if ((local_ac == 0.00000000) && (local_9c == 0.00000000)) {
                if (bVar12) {
                  xyToAngle(local_bc,local_c4);
                }
                else {
                  Message(
                         "PrintBOM(): unable to figure out angle of element\n     %s because pin #1 is at the centroid of the part.\n     and I could not find pin #2\'s location\n     Setting to %g degrees\n"
                         );
                }
              }
              else {
                xyToAngle(local_ac,local_9c);
              }
            }
            __s1 = *(char **)(iVar20 + 0x94);
            if (__s1 == (char *)0x0) goto LAB_0810eac1;
LAB_0810e904:
            if (*__s1 == '\0') {
              __s1 = "(unknown)";
            }
          }
          else {
            Message(
                   "PrintBOM(): unable to figure out angle because I could\n     not find pin #1 of element %s\n     Setting to %g degrees\n"
                   );
            __s1 = *(char **)(iVar20 + 0x94);
            if (__s1 != (char *)0x0) goto LAB_0810e904;
LAB_0810eac1:
            __s1 = "(unknown)";
          }
          __s1_00 = CleanBOMString(__s1);
          __s1 = *(char **)(iVar20 + 0x58);
          if (__s1 == (char *)0x0) {
            __s1 = "(unknown)";
          }
          else {
            if (*__s1 == '\0') {
              __s1 = "(unknown)";
            }
          }
          __ptr = CleanBOMString(__s1);
          __s1 = *(char **)(iVar20 + 0xd0);
          if (__s1 == (char *)0x0) {
            __s1 = "(unknown)";
          }
          else {
            if (*__s1 == '\0') {
              __s1 = "(unknown)";
            }
          }
          __s1 = CleanBOMString(__s1);
          local_174 = (double)CONCAT44(__s1_00,0x815ca90);
          __fprintf_chk();
          free(__s1_00);
          free(__ptr);
          free(__s1);
        }
        uVar27 = (undefined4)((ulonglong)local_174 >> 0x20);
        local_b0 = local_b0 + -1;
        if (local_b0 == -1) goto LAB_0810ec06;
        pDVar14 = PCB->Data;
        iVar20 = local_c8;
      } while( true );
    }
    local_cc = (BomList *)0x0;
LAB_0810ec06:
    fclose(__stream);
    fp = (FILE *)fopen(bom_filename,"w");
    if (fp == (FILE *)0x0) {
      (*gui->log)("Cannot open file %s for writing\n");
      print_and_free((FILE *)0x0,local_cc);
    }
    else {
      __fprintf_chk(fp,1,"# $Id",uVar27);
      __fprintf_chk(fp,1,&DAT_0815ca47,uVar27);
      __fprintf_chk(fp,1,"# PcbBOM Version 1.0\n",uVar27);
      __fprintf_chk(fp,1,"# Date: %s\n",utcTime);
      __s1 = pcb_author();
      __fprintf_chk(fp,1,"# Author: %s\n",__s1);
      __s1 = PCB->Name;
      if (__s1 == (char *)0x0) {
        __s1 = "(unknown)";
      }
      else {
        if (*__s1 == '\0') {
          __s1 = "(unknown)";
        }
      }
      __fprintf_chk(fp,1,"# Title: %s - PCB BOM\n",__s1);
      __fprintf_chk(fp,1,"# Quantity, Description, Value, RefDes\n",__s1);
      __fprintf_chk(fp,1,"# --------------------------------------------\n",__s1);
      print_and_free(fp,local_cc);
      fclose((FILE *)fp);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void hid_bom_init(void)

{
  apply_default_hid(&bom_hid,(HID *)0x0);
  hid_register_hid(&bom_hid);
  return;
}



int drill_sort(void *va,void *vb)

{
  int iVar1;
  
  iVar1 = 0;
  if (*(int *)va != *(int *)vb) {
    iVar1 = *(int *)va - *(int *)vb;
  }
  return iVar1;
}



void gerber_use_mask(int use_it)

{
  current_mask = use_it;
  return;
}



void gerber_set_line_cap(hidGC gc,EndCapStyle style)

{
  gc->nothing_interesting_here = style;
  return;
}



void gerber_set_line_width(hidGC gc,int width)

{
  gc[1].nothing_interesting_here = width;
  return;
}



void gerber_set_draw_xor(hidGC gc,int xor)

{
  return;
}



void gerber_set_draw_faded(hidGC gc,int faded)

{
  return;
}



void gerber_set_crosshair(int x,int y,int action)

{
  return;
}



void hid_gerber_init(void)

{
  apply_default_hid(&gerber_hid,(HID *)0x0);
  hid_register_hid(&gerber_hid);
  return;
}



void gerber_calibrate(double xval,double yval)

{
  char "gerber_calibrate" [17];
  
  __fprintf_chk(stderr,1,0x815cb34,"gerber_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



void gerber_set_line_cap_angle(void)

{
  char "gerber_set_line_cap_angle" [26];
  
  __fprintf_chk(stderr,1,0x815cb34,"gerber_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



int __regparm3 findApertureCode(int width,ApertureShape shape)

{
  ApertureShape *pAVar1;
  int iVar2;
  Apertures *pAVar3;
  int iVar4;
  
  pAVar3 = curapp;
  iVar2 = global_aperture_count;
  if (width == 0) {
    return 0;
  }
  if (0 < global_aperture_count) {
    iVar4 = 0;
    do {
      if ((global_aperture_sizes[iVar4] == width) && (global_aperture_shapes[iVar4] == shape)) {
        curapp->aperture_used[iVar4] = 1;
        pAVar3->some_apertures = 1;
        return iVar4 + 0xb;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < global_aperture_count);
    if (0x9ff < global_aperture_count) {
      Message("Error, too many apertures needed for Gerber file.\n");
      return 10;
    }
  }
  global_aperture_sizes[global_aperture_count] = width;
  pAVar3 = curapp;
  pAVar1 = global_aperture_shapes + global_aperture_count;
  global_aperture_count = global_aperture_count + 1;
  *pAVar1 = shape;
  pAVar3->aperture_used[iVar2] = 1;
  pAVar3->some_apertures = 1;
  return iVar2 + 0xb;
}



void __regparm3 use_gc(hidGC gc,int radius)

{
  int width;
  uint uVar1;
  char *pcVar2;
  ApertureShape shape;
  
  if (radius == 0) {
    width = gc[1].nothing_interesting_here;
    if (width == linewidth) {
      uVar1 = gc->nothing_interesting_here;
      if (lastcap == uVar1) {
        return;
      }
    }
    else {
      uVar1 = gc->nothing_interesting_here;
    }
    shape = SQUARE;
    if (uVar1 < 3) {
      shape = *(ApertureShape *)(CSWTCH_161 + uVar1 * 4);
    }
    linewidth = width;
    lastcap = uVar1;
    width = findApertureCode(width,shape);
    if (width < 1) {
      pcVar2 = "SQUARE";
      if (shape == ROUND) {
        pcVar2 = "ROUND";
      }
      __fprintf_chk(stderr,1,"error: aperture for width %d type %s is %d\n",linewidth,pcVar2,width);
    }
    if (f != (FILE *)0x0) {
      __fprintf_chk(f,1,"G54D%d*",width);
    }
  }
  else {
    radius = radius * 2;
    if ((radius - linewidth != 0) || (lastcap != 2)) {
      width = findApertureCode(radius,ROUND);
      if (width < 1) {
        __fprintf_chk(stderr,1,"error: aperture for radius %d type ROUND is %d\n",radius,width);
      }
      if ((f != (FILE *)0x0) && (is_drill == 0)) {
        __fprintf_chk(f,1,"G54D%d*",width);
      }
      linewidth = radius;
      lastcap = 2;
      return;
    }
  }
  return;
}



void gerber_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int local_2c;
  int local_28;
  
  if (((is_mask != 0) && (current_mask == 1)) || (use_gc(gc,1000), f == (FILE *)0x0)) {
    return;
  }
  __fprintf_chk(f,1,"G36*\r\n");
  local_28 = 0;
  local_2c = 0;
  if (0 < n_coords) {
    iVar2 = 0;
    bVar5 = true;
    do {
      while( true ) {
        iVar1 = x[iVar2];
        bVar3 = iVar1 != lastX;
        if (bVar3) {
          lastX = iVar1;
          __fprintf_chk(f,1,&DAT_0815cd61,iVar1);
        }
        iVar1 = y[iVar2];
        bVar4 = iVar1 != lastY;
        if (bVar4) {
          lastY = iVar1;
          __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - iVar1);
        }
        if (!bVar5) break;
        local_2c = x[iVar2];
        local_28 = y[iVar2];
        if (bVar4 || bVar3) {
          __fprintf_chk(f,1,&DAT_0815cd6b);
        }
LAB_0810f27f:
        iVar2 = iVar2 + 1;
        bVar5 = false;
        if (n_coords <= iVar2) goto LAB_0810f348;
      }
      if (!bVar4 && !bVar3) goto LAB_0810f27f;
      iVar2 = iVar2 + 1;
      bVar5 = false;
      __fprintf_chk(f,1,"D01*\r\n");
    } while (iVar2 < n_coords);
  }
LAB_0810f348:
  bVar5 = local_2c == lastX;
  if (!bVar5) {
    lastX = local_2c;
    __fprintf_chk(f,1,&DAT_0815cd61,local_2c);
  }
  if (local_28 == lastY) {
    if (bVar5) goto LAB_0810f3e1;
  }
  else {
    lastY = local_28;
    __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - local_28);
  }
  __fprintf_chk(f,1,"D01*\r\n");
LAB_0810f3e1:
  __fprintf_chk();
  return;
}



void gerber_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  int y [5];
  int x [5];
  
  y[4] = y1;
  y[0] = y1;
  y[3] = y1;
  y[1] = y2;
  y[2] = y2;
  x[4] = x1;
  x[0] = x1;
  x[1] = x1;
  x[2] = x2;
  x[3] = x2;
  gerber_fill_polygon(gc,5,x,y);
  return;
}



void gerber_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  int y [5];
  int x [5];
  
  y[4] = y1;
  y[0] = y1;
  y[3] = y1;
  y[1] = y2;
  y[2] = y2;
  x[4] = x1;
  x[0] = x1;
  x[1] = x1;
  x[2] = x2;
  x[3] = x2;
  gerber_fill_polygon(gc,5,x,y);
  return;
}



void gerber_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  PendingDrills *pPVar1;
  
  if (0 < radius) {
    if (is_drill != 0) {
      radius = ((radius + 0x19) / 0x32) * 0x32;
    }
    use_gc(gc,radius);
    if (f != (FILE *)0x0) {
      if (is_drill == 0) {
        if ((gc[4].nothing_interesting_here == 0) || (flash_drills != 0)) {
          if (cx != lastX) {
            lastX = cx;
            __fprintf_chk(f,1,&DAT_0815cd61,cx);
          }
          if (cy != lastY) {
            lastY = cy;
            __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - cy);
          }
          __fprintf_chk();
          return;
        }
      }
      else {
        if (max_pending_drills <= n_pending_drills) {
          max_pending_drills = max_pending_drills + 100;
          pending_drills = (PendingDrills *)realloc(pending_drills,max_pending_drills * 0xc);
        }
        pPVar1 = pending_drills + n_pending_drills;
        n_pending_drills = n_pending_drills + 1;
        pPVar1->x = cx;
        pPVar1->diam = radius * 2;
        pPVar1->y = cy;
      }
    }
  }
  return;
}



void gerber_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  float fVar1;
  float fVar2;
  bool bVar3;
  bool bVar4;
  double dVar5;
  double local_5c;
  double local_54 [2];
  int y [5];
  int x [5];
  
  if (((y1 == y2) || (x1 == x2)) || (gc->nothing_interesting_here != 1)) {
    use_gc(gc,0);
    if (f != (FILE *)0x0) {
      bVar3 = x1 != lastX;
      if (bVar3) {
        lastX = x1;
        __fprintf_chk(f,1,&DAT_0815cd61,x1);
      }
      bVar4 = y1 != lastY;
      if (bVar4) {
        lastY = y1;
        __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - y1);
      }
      if ((y1 == y2) && (x1 == x2)) {
        __fprintf_chk(f,1,"D03*\r\n");
        return;
      }
      if (bVar4 || bVar3) {
        __fprintf_chk(f,1,&DAT_0815cd6b);
      }
      if (x2 != lastX) {
        lastX = x2;
        __fprintf_chk(f,1,&DAT_0815cd61,x2);
      }
      if (y2 != lastY) {
        lastY = y2;
        __fprintf_chk(f,1,&DAT_0815cd66,PCB->MaxHeight - y2);
      }
      __fprintf_chk(f,1,"D01*\r\n");
    }
  }
  else {
    dVar5 = atan2((double)(y2 - y1),(double)(x2 - x1));
    fVar1 = (float)gc[1].nothing_interesting_here * 0.50000000;
    sincos((double)((float)dVar5 + 0.78539813),local_54,&local_5c);
    fVar2 = (float)local_5c * fVar1 * 1.41421354;
    fVar1 = (float)local_54[0] * fVar1 * 1.41421354;
    x[0] = (int)ROUND((float)x1 - fVar2);
    y[0] = (int)ROUND((float)y1 - fVar1);
    x[1] = (int)ROUND((float)x2 + fVar1);
    y[1] = (int)ROUND((float)y2 - fVar2);
    x[2] = (int)ROUND((float)x2 + fVar2);
    y[2] = (int)ROUND((float)y2 + fVar1);
    x[3] = (int)ROUND((float)x1 - fVar1);
    y[3] = (int)ROUND((float)y1 + fVar2);
    y[4] = y[0];
    x[4] = x[0];
    gerber_fill_polygon(gc,5,x,y);
  }
  return;
}



void gerber_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int delta_angle)

{
  int x2;
  int y2;
  double dVar1;
  double dVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  FILE *pFVar7;
  int x1;
  uint uVar8;
  int y1;
  int iVar9;
  double dVar10;
  double *local_b0;
  double local_2c;
  double local_24 [2];
  
  if (gc[1].nothing_interesting_here == 0) {
    return;
  }
  use_gc(gc,0);
  pFVar7 = f;
  if (f == (FILE *)0x0) {
    return;
  }
  dVar2 = (double)start_angle;
  sincos(dVar2 * 0.01745329,local_24,&local_2c);
  fVar3 = (float)cx - (float)width * (float)local_2c;
  dVar1 = (double)height;
  fVar4 = (float)height * (float)local_24[0] + (float)cy;
  uVar8 = delta_angle >> 0x1f;
  if (width != height) {
    if (height < width) {
      height = width;
    }
    iVar9 = height - gc[1].nothing_interesting_here / 10;
    if (height <= iVar9) {
      iVar9 = height + -1;
    }
    dVar10 = acos((double)iVar9 / (double)height);
    dVar10 = (dVar10 * 180.00000000) / 3.14159265;
    if (5.00000000 <= dVar10 || dVar10 != 5.00000000) {
      dVar10 = 5.00000000;
    }
    iVar9 = (int)ROUND((double)((delta_angle ^ uVar8) - uVar8) / dVar10 + 1.00000000);
    dVar10 = (double)iVar9;
    if (iVar9 < 1) {
      return;
    }
    x1 = (int)ROUND(fVar3);
    y1 = (int)ROUND(fVar4);
    do {
      dVar2 = dVar2 + (double)delta_angle / dVar10;
      iVar9 = iVar9 + -1;
      sincos(dVar2 * 0.01745329,local_24,&local_2c);
      x2 = (int)ROUND((double)cx - (double)width * local_2c);
      y2 = (int)ROUND(dVar1 * local_24[0] + (double)cy);
      gerber_draw_line(gc,x1,y1,x2,y2);
      x1 = x2;
      y1 = y2;
    } while (0 < iVar9);
    return;
  }
  local_b0 = &local_2c;
  sincos((double)(delta_angle + start_angle) * 0.01745329,local_24,local_b0);
  fVar5 = (float)height * (float)local_24[0] + (float)cy;
  fVar6 = (float)lastX;
  if (fVar6 != fVar3) {
    lastX = (int)ROUND(fVar3);
    local_b0 = (double *)lastX;
    __fprintf_chk(pFVar7,1,&DAT_0815cd61,lastX);
    pFVar7 = f;
  }
  if ((float)lastY == fVar4) {
    if (fVar6 == fVar3) goto LAB_0810fc5b;
  }
  else {
    lastY = (int)ROUND(fVar4);
    local_b0 = (double *)(PCB->MaxHeight - lastY);
    __fprintf_chk(pFVar7,1,&DAT_0815cd66,local_b0);
    pFVar7 = f;
  }
  __fprintf_chk(pFVar7,1,&DAT_0815cd6b,local_b0);
  pFVar7 = f;
LAB_0810fc5b:
  iVar9 = (int)ROUND((float)cx - (float)local_2c * (float)width);
  __fprintf_chk(pFVar7,1,"G75*G0%1dX%ldY%ldI%ldJ%ldD01*G01*\r\n",uVar8 + 3,iVar9,
                (int)ROUND((float)PCB->MaxHeight - fVar5),(int)ROUND((float)cx - fVar3),
                (int)ROUND(-((float)cy - fVar4)));
  lastY = (int)ROUND(fVar5);
  lastX = iVar9;
  return;
}



void gerber_set_color(hidGC gc,char *name)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  bool bVar4;
  
  iVar1 = 6;
  bVar4 = (undefined *)register0x00000010 == &DAT_00000010;
  pcVar2 = name;
  pcVar3 = "erase";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pcVar2 == *pcVar3;
    pcVar2 = pcVar2 + 1;
    pcVar3 = pcVar3 + 1;
  } while (bVar4);
  if (bVar4) {
    gc[2].nothing_interesting_here = 1;
    gc[3].nothing_interesting_here = 1;
    gc[4].nothing_interesting_here = 0;
  }
  else {
    iVar1 = 6;
    pcVar2 = "drill";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *name == *pcVar2;
      name = name + 1;
      pcVar2 = pcVar2 + 1;
    } while (bVar4);
    if (bVar4) {
      gc[2].nothing_interesting_here = 1;
      gc[3].nothing_interesting_here = 0;
      gc[4].nothing_interesting_here = 1;
    }
    else {
      gc[2].nothing_interesting_here = 0;
      gc[3].nothing_interesting_here = 0;
      gc[4].nothing_interesting_here = 0;
    }
  }
  return;
}



void gerber_destroy_gc(hidGC gc)

{
  free(gc);
  return;
}



hidGC gerber_make_gc(void)

{
  hidGC phVar1;
  
  phVar1 = (hidGC)calloc(1,0x14);
  phVar1->nothing_interesting_here = 0;
  return phVar1;
}



void maybe_close_f(void)

{
  if (f != (FILE *)0x0) {
    if (was_drill == 0) {
      __fprintf_chk(f,1,"M02*\r\n");
    }
    else {
      __fprintf_chk(f,1,"M30\r\n");
    }
    fclose((FILE *)f);
  }
  f = (FILE *)0x0;
  return;
}



int gerber_set_layer(char *name,int group,int empty)

{
  Apertures *pAVar1;
  int iVar2;
  ApertureShape AVar3;
  int iVar4;
  char *__src;
  undefined1 *puVar5;
  int width;
  tm *__tp;
  __uid_t __uid;
  passwd *ppVar6;
  ushort **ppuVar7;
  __int32_t **pp_Var8;
  int iVar9;
  char cVar10;
  int iVar11;
  uint uVar12;
  Apertures *pAVar13;
  int *piVar14;
  char *pcVar15;
  Apertures *pAVar16;
  char *__src_00;
  int in_GS_OFFSET;
  bool bVar17;
  byte bVar18;
  undefined *local_a4;
  uint idx;
  char *local_7c;
  time_t local_64;
  char utcTime [64];
  
  bVar18 = 0;
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  local_7c = name;
  idx = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    idx = (PCB->LayerGroups).Entries[group * 0x12];
  }
  if (name == (char *)0x0) {
    local_7c = *(char **)(&PCB->Data->field_0x4c + idx * 0x5c);
  }
  bVar17 = idx == 0;
  if ((((int)idx < 0) ||
      (uVar12 = PCB->Data->LayerN, bVar17 = idx == uVar12, (int)uVar12 <= (int)idx)) ||
     (bVar17 = print_layer[idx] == 0, !bVar17)) {
    iVar9 = 10;
    __src_00 = local_7c;
    __src = "invisible";
    do {
      if (iVar9 == 0) break;
      iVar9 = iVar9 + -1;
      bVar17 = *__src_00 == *__src;
      __src_00 = __src_00 + 1;
      __src = __src + 1;
    } while (bVar17);
    if ((!bVar17) &&
       ((bVar17 = idx == 0, -1 < (int)idx || (bVar17 = (idx & 0xf0) == 0x80, !bVar17)))) {
      iVar9 = 8;
      flash_drills = 0;
      __src_00 = local_7c;
      __src = "outline";
      do {
        if (iVar9 == 0) break;
        iVar9 = iVar9 + -1;
        bVar17 = *__src_00 == *__src;
        __src_00 = __src_00 + 1;
        __src = __src + 1;
      } while (bVar17);
      if (bVar17) {
LAB_0810ffea:
        flash_drills = 1;
      }
      else {
        iVar9 = 6;
        __src_00 = local_7c;
        __src = "route";
        do {
          if (iVar9 == 0) break;
          iVar9 = iVar9 + -1;
          bVar17 = *__src_00 == *__src;
          __src_00 = __src_00 + 1;
          __src = __src + 1;
        } while (bVar17);
        if (bVar17) goto LAB_0810ffea;
      }
      if ((is_drill != 0) && (n_pending_drills != 0)) {
        qsort(pending_drills,n_pending_drills,0xc,drill_sort);
        if (0 < n_pending_drills) {
          iVar9 = 0;
          iVar11 = 0;
          do {
            if (iVar11 == 0) {
              width = *(int *)((int)&pending_drills->diam + iVar9);
LAB_08110328:
              width = findApertureCode(width,ROUND);
              __fprintf_chk(f,1,"T%02d\r\n",width);
              piVar14 = (int *)((int)&pending_drills->diam + iVar9);
            }
            else {
              piVar14 = (int *)((int)&pending_drills->diam + iVar9);
              width = *piVar14;
              if (width != *(int *)((int)&pending_drills[-1].diam + iVar9)) goto LAB_08110328;
            }
            iVar11 = iVar11 + 1;
            iVar9 = iVar9 + 0xc;
            __fprintf_chk(f,1,"X%06ldY%06ld\r\n",piVar14[1] / 10,(PCB->MaxHeight - piVar14[2]) / 10)
            ;
          } while (iVar11 < n_pending_drills);
        }
        free(pending_drills);
        max_pending_drills = 0;
        n_pending_drills = 0;
        pending_drills = (PendingDrills *)0x0;
      }
      iVar11 = n_layerapps;
      iVar9 = c_layerapps;
      if ((int)idx < 0) {
        uVar12 = idx & 0xf0;
        if ((uVar12 == 0x40) || (uVar12 == 0x30)) {
          is_drill = 1;
        }
        else {
          is_drill = 0;
        }
        is_mask = 1;
        if (uVar12 != 0x20) goto LAB_08110020;
      }
      else {
        is_drill = 0;
LAB_08110020:
        is_mask = 0;
      }
      current_mask = 0;
      if ((group < 0) || (group != lastgroup)) {
        lastX = -1;
        lastY = -1;
        lastgroup = group;
        lastcolor = 0;
        linewidth = -1;
        lastcap = -1;
        pAVar16 = layerapps;
        if (n_layerapps <= c_layerapps) {
          n_layerapps = c_layerapps + 1;
          pAVar16 = (Apertures *)MyRealloc(layerapps,n_layerapps * 0x2804,"SetAppLayer");
          pAVar13 = pAVar16 + iVar11;
          pAVar1 = pAVar16 + n_layerapps;
          layerapps = pAVar16;
          while (pAVar13 < pAVar1) {
            pAVar13->some_apertures = 0;
            iVar11 = 0;
            do {
              pAVar13->aperture_used[iVar11] = 0;
              iVar11 = iVar11 + 1;
            } while (iVar11 != 0xa00);
            pAVar13 = pAVar13 + 1;
          }
        }
        c_layerapps = c_layerapps + 1;
        curapp = pAVar16 + iVar9;
        if (finding_apertures == 0) {
          if ((curapp->some_apertures != 0) || (all_layers != 0)) {
            maybe_close_f();
            __src_00 = ".gbr";
            pagecount = pagecount + 1;
            if (idx + 0xfd0 < 0x11) {
              __src_00 = *(char **)(CSWTCH_164 + (idx + 0xfd0) * 4);
            }
            __src = layer_type_to_file_name(idx);
            strcpy(filesuff,__src);
            strcat(filesuff,__src_00);
            f = (FILE *)fopen(filename,"w");
            if (f == (FILE *)0x0) {
              Message("Error:  Could not open %s for writing.\n",filename);
              iVar9 = 1;
              goto LAB_0811024c;
            }
            was_drill = is_drill;
            if (verbose != 0) {
              iVar11 = 0;
              iVar9 = 0;
              do {
                iVar11 = (iVar11 + 1) - (uint)(curapp->aperture_used[iVar9] == 0);
                iVar9 = iVar9 + 1;
              } while (iVar9 != 0xa00);
              puVar5 = (undefined1 *)0x814736c;
              if (iVar11 == 1) {
                puVar5 = &DAT_0814741b;
              }
              __printf_chk(1,"Gerber: %d aperture%s in %s\n",iVar11,puVar5,filename);
            }
            if (is_drill == 0) {
              __fprintf_chk(f,1,"G04 start of page %d for group %d idx %d *\r\n",pagecount,group,idx
                           );
              local_64 = time((time_t *)0x0);
              __tp = gmtime(&local_64);
              strftime(utcTime,0x40,"%c UTC",__tp);
              if ((local_7c == (char *)0x0) || (*local_7c == '\0')) {
                local_7c = "(unknown)";
              }
              __src = PCB->Name;
              if ((__src == (char *)0x0) || (*__src == '\0')) {
                __src = "(unknown)";
              }
              __fprintf_chk(f,1,"G04 Title: %s, %s *\r\n",__src,local_7c,idx);
              __fprintf_chk(f,1,"G04 Creator: %s 20091103 *\r\n",Progname);
              __fprintf_chk(f,1,"G04 CreationDate: %s *\r\n",utcTime);
              __uid = getuid();
              ppVar6 = getpwuid(__uid);
              __fprintf_chk(f,1,"G04 For: %s *\r\n",ppVar6->pw_name);
              __fprintf_chk(f,1,"G04 Format: Gerber/RS-274X *\r\n");
              __fprintf_chk(f,1,"G04 PCB-Dimensions: %d %d *\r\n",PCB->MaxWidth,PCB->MaxHeight,idx);
              __fprintf_chk(f,1,"G04 PCB-Coordinate-Origin: lower left *\r\n");
              __fprintf_chk(f,1,"%%MOIN*%%\r\n");
              __fprintf_chk(f,1,"%%FSLAX25Y25*%%\r\n");
              if (layername != (char *)0x0) {
                free(layername);
              }
              pcVar15 = (char *)__strdup(filesuff);
              iVar9 = -1;
              __src = pcVar15;
              do {
                if (iVar9 == 0) break;
                iVar9 = iVar9 + -1;
                cVar10 = *__src;
                __src = __src + (uint)bVar18 * -2 + 1;
              } while (cVar10 != '\0');
              iVar11 = -1;
              do {
                if (iVar11 == 0) break;
                iVar11 = iVar11 + -1;
                cVar10 = *__src_00;
                __src_00 = __src_00 + (uint)bVar18 * -2 + 1;
              } while (cVar10 != '\0');
              layername = pcVar15;
              pcVar15[iVar11 - iVar9] = '\0';
              cVar10 = *pcVar15;
              __src_00 = pcVar15;
              if (cVar10 != '\0') {
                ppuVar7 = __ctype_b_loc();
                do {
                  iVar9 = (int)cVar10;
                  if ((*(byte *)(*ppuVar7 + iVar9) & 8) == 0) {
                    *pcVar15 = '_';
                  }
                  else {
                    if (iVar9 + 0x80U < 0x180) {
                      pp_Var8 = __ctype_toupper_loc();
                      cVar10 = (char)(*pp_Var8)[iVar9];
                    }
                    *pcVar15 = cVar10;
                  }
                  pcVar15 = pcVar15 + 1;
                  cVar10 = *pcVar15;
                  __src_00 = layername;
                } while (cVar10 != '\0');
              }
              iVar11 = 0;
              iVar9 = 0;
              __fprintf_chk(f,1,"%%LN%s*%%\r\n",__src_00);
              lncount = 1;
              do {
                if (curapp->aperture_used[iVar9] != 0) {
                  AVar3 = global_aperture_shapes[iVar9];
                  iVar11 = iVar11 + 1;
                  width = iVar9 + 0xb;
                  iVar4 = global_aperture_sizes[iVar9];
                  if (AVar3 == OCTAGON) {
                    __fprintf_chk(f,1,"%%AMOCT%d*5,0,8,0,0,%.4f,22.5*%%\r\n%%ADD%dOCT%d*%%\r\n",
                                  width,(double)iVar4 / 92387.95330000,width,width);
                  }
                  else {
                    if (AVar3 == ROUND) {
                      __fprintf_chk(f,1,"%%ADD%dC,%.4f*%%\r\n",width,
                                    (double)((float)iVar4 / 100000.00000000));
                    }
                    else {
                      if (AVar3 == SQUARE) {
                        __fprintf_chk(f,1,"%%ADD%dR,%.4fX%.4f*%%\r\n",width,
                                      (double)((float)iVar4 / 100000.00000000));
                      }
                    }
                  }
                }
                iVar9 = iVar9 + 1;
              } while (iVar9 != 0xa00);
              if (iVar11 != 0) goto LAB_081102bc;
              local_a4 = &DAT_0815cebf;
            }
            else {
              iVar9 = 0;
              __fprintf_chk(f,1,"M48\r\nINCH\r\n");
              do {
                if (curapp->aperture_used[iVar9] != 0) {
                  __fprintf_chk(f,1,"T%02dC%.3f\r\n",iVar9 + 0xb,
                                (double)((float)global_aperture_sizes[iVar9] / 100000.00000000));
                }
                iVar9 = iVar9 + 1;
              } while (iVar9 != 0xa00);
              local_a4 = &DAT_0815cecf;
            }
            __fprintf_chk(f,1,local_a4);
            iVar9 = 1;
            goto LAB_0811024c;
          }
          goto LAB_0811024a;
        }
      }
LAB_081102bc:
      iVar9 = 1;
      goto LAB_0811024c;
    }
  }
LAB_0811024a:
  iVar9 = 0;
LAB_0811024c:
  if (iVar2 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar9;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void gerber_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes((HID_Attribute *)gerber_options,3);
  hid_parse_command_line(argc,argv);
  return;
}



int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int iVar1;
  int iVar2;
  int iVar3;
  
  Layer = *(Cardinal *)va;
  Layer_00 = *(Cardinal *)vb;
  iVar1 = PCB->Data->LayerN;
  iVar3 = iVar1 + 1;
  if (((int)Layer_00 < 0) || (iVar3 < (int)Layer_00)) {
    iVar2 = iVar1 + 3 + Layer_00;
  }
  else {
    iVar2 = GetLayerGroupNumberByNumber(Layer_00);
    iVar1 = PCB->Data->LayerN;
    iVar3 = iVar1 + 1;
  }
  if ((iVar3 < (int)Layer) || ((int)Layer < 0)) {
    iVar3 = iVar1 + 3 + Layer;
  }
  else {
    iVar3 = GetLayerGroupNumberByNumber(Layer);
  }
  iVar1 = iVar2 - iVar3;
  if (iVar2 - iVar3 == 0) {
    iVar1 = Layer_00 - Layer;
  }
  return iVar1;
}



HID_Attribute * gerber_get_export_options(int *n)

{
  char *last_made_filename;
  
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)gerber_options,"",(char **)&ram0x0818f580);
  }
  if (n != (int *)0x0) {
    *n = 3;
  }
  return (HID_Attribute *)gerber_options;
}



void gerber_do_export(HID_Attr_Val *options)

{
  Cardinal *pCVar1;
  uchar uVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  uchar uVar7;
  uchar uVar8;
  uchar uVar9;
  uint uVar10;
  int saved_layer_stack [16];
  size_t sVar11;
  int iVar12;
  PCBTypePtr pPVar13;
  DataTypePtr *pDVar14;
  char *__s;
  Cardinal Layer;
  Cardinal Layer_00;
  int *piVar15;
  byte bVar16;
  int save_ons [18];
  BoxType region;
  
  bVar16 = 0;
  uVar2 = (PCB->Flags).t[7];
  uVar10 = (PCB->Flags).f;
  uVar3 = (PCB->Flags).t[6];
  uVar4 = (PCB->Flags).t[5];
  uVar5 = (PCB->Flags).t[4];
  uVar6 = (PCB->Flags).t[3];
  uVar7 = (PCB->Flags).t[2];
  uVar8 = (PCB->Flags).t[1];
  uVar9 = (PCB->Flags).t[0];
  (PCB->Flags).f = uVar10 & 0xfffdbfff;
  if (options == (HID_Attr_Val *)0x0) {
    gerber_get_export_options((int *)0x0);
    gerber_values[0].int_value = gerber_options[0].default_val.int_value;
    options = gerber_values;
    gerber_values[0].str_value = gerber_options[0].default_val.str_value;
    gerber_values[0].real_value._0_4_ = gerber_options[0].default_val.real_value._0_4_;
    gerber_values[0].real_value._4_4_ = gerber_options[0].default_val.real_value._4_4_;
    gerber_values[1].int_value = gerber_options[1].default_val.int_value;
    gerber_values[1].str_value = gerber_options[1].default_val.str_value;
    gerber_values[1].real_value._0_4_ = gerber_options[1].default_val.real_value._0_4_;
    gerber_values[1].real_value._4_4_ = gerber_options[1].default_val.real_value._4_4_;
    gerber_values[2].int_value = gerber_options[2].default_val.int_value;
    gerber_values[2].str_value = gerber_options[2].default_val.str_value;
    gerber_values[2].real_value._0_4_ = gerber_options[2].default_val.real_value._0_4_;
    gerber_values[2].real_value._4_4_ = gerber_options[2].default_val.real_value._4_4_;
  }
  __s = options->str_value;
  if (__s == (char *)0x0) {
    __s = "pcb-out";
  }
  verbose = options[2].int_value;
  all_layers = options[1].int_value;
  sVar11 = strlen(__s);
  filename = (char *)MyRealloc(filename,sVar11 + 0x28,"gerber");
  strcpy(filename,__s);
  __s = filename;
  sVar11 = strlen(filename);
  *(undefined2 *)(__s + sVar11) = 0x2e;
  __s = filename;
  sVar11 = strlen(filename);
  filesuff = __s + sVar11;
  if (all_layers == 0) {
    iVar12 = 0x10;
    piVar15 = print_group;
    while (iVar12 != 0) {
      iVar12 = iVar12 + -1;
      *piVar15 = 0;
      piVar15 = piVar15 + (uint)bVar16 * 0x3ffffffe + 1;
    }
    iVar12 = 0x10;
    piVar15 = print_layer;
    while (iVar12 != 0) {
      iVar12 = iVar12 + -1;
      *piVar15 = 0;
      piVar15 = piVar15 + (uint)bVar16 * 0x3ffffffe + 1;
    }
  }
  else {
    print_group[0] = 0x1010101;
    print_group[1] = 0x1010101;
    print_group[2] = 0x1010101;
    print_group[3] = 0x1010101;
    print_group[4] = 0x1010101;
    print_group[5] = 0x1010101;
    print_group[6] = 0x1010101;
    print_group[7] = 0x1010101;
    print_group[8] = 0x1010101;
    print_group[9] = 0x1010101;
    print_group[10] = 0x1010101;
    print_group[11] = 0x1010101;
    print_group[12] = 0x1010101;
    print_group[13] = 0x1010101;
    print_group[14] = 0x1010101;
    print_group[15] = 0x1010101;
    print_layer[0] = 0x1010101;
    print_layer[1] = 0x1010101;
    print_layer[2] = 0x1010101;
    print_layer[3] = 0x1010101;
    print_layer[4] = 0x1010101;
    print_layer[5] = 0x1010101;
    print_layer[6] = 0x1010101;
    print_layer[7] = 0x1010101;
    print_layer[8] = 0x1010101;
    print_layer[9] = 0x1010101;
    print_layer[10] = 0x1010101;
    print_layer[11] = 0x1010101;
    print_layer[12] = 0x1010101;
    print_layer[13] = 0x1010101;
    print_layer[14] = 0x1010101;
    print_layer[15] = 0x1010101;
  }
  hid_save_and_show_layer_ons(save_ons);
  pDVar14 = PCB->Data;
  Layer_00 = pDVar14->LayerN;
  if (0 < (int)Layer_00) {
    Layer = 0;
    pPVar13 = PCB;
    do {
      pCVar1 = &pDVar14->ViaN + Layer * 0x17;
      if ((((pCVar1[0x14] != 0) || (pCVar1[0x15] != 0)) || (pCVar1[0x17] != 0)) ||
         (pCVar1[0x16] != 0)) {
        iVar12 = GetLayerGroupNumberByNumber(Layer);
        print_group[iVar12] = 1;
        pPVar13 = PCB;
      }
      pDVar14 = pPVar13->Data;
      Layer = Layer + 1;
      Layer_00 = pDVar14->LayerN;
    } while ((int)Layer < (int)Layer_00);
  }
  iVar12 = GetLayerGroupNumberByNumber(Layer_00);
  print_group[iVar12] = 1;
  iVar12 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  print_group[iVar12] = 1;
  if (0 < PCB->Data->LayerN) {
    Layer_00 = 0;
    do {
      iVar12 = GetLayerGroupNumberByNumber(Layer_00);
      if (print_group[iVar12] != 0) {
        print_layer[Layer_00] = 1;
      }
      Layer_00 = Layer_00 + 1;
      pCVar1 = (Cardinal *)&PCB->Data->LayerN;
    } while (*pCVar1 != Layer_00 && (int)Layer_00 <= (int)*pCVar1);
  }
  saved_layer_stack[0] = LayerStack[0];
  saved_layer_stack[1] = LayerStack[1];
  saved_layer_stack[2] = LayerStack[2];
  saved_layer_stack[3] = LayerStack[3];
  saved_layer_stack[4] = LayerStack[4];
  saved_layer_stack[5] = LayerStack[5];
  saved_layer_stack[6] = LayerStack[6];
  saved_layer_stack[7] = LayerStack[7];
  saved_layer_stack[8] = LayerStack[8];
  saved_layer_stack[9] = LayerStack[9];
  saved_layer_stack[10] = LayerStack[10];
  saved_layer_stack[11] = LayerStack[11];
  saved_layer_stack[12] = LayerStack[12];
  saved_layer_stack[13] = LayerStack[13];
  saved_layer_stack[14] = LayerStack[14];
  saved_layer_stack[15] = LayerStack[15];
  qsort(LayerStack,PCB->Data->LayerN,4,layer_sort);
  region.X1 = 0;
  region.Y1 = 0;
  linewidth = -1;
  region.X2 = PCB->MaxWidth;
  lastcap = -1;
  lastcolor = -1;
  layerapps = (Apertures *)0x0;
  region.Y2 = PCB->MaxHeight;
  f = (FILE *)0x0;
  pagecount = 1;
  n_layerapps = 0;
  lastgroup = -1;
  c_layerapps = 0;
  finding_apertures = 1;
  hid_expose_callback(&gerber_hid,&region,(void *)0x0);
  c_layerapps = 0;
  finding_apertures = 0;
  hid_expose_callback(&gerber_hid,&region,(void *)0x0);
  LayerStack[0] = saved_layer_stack[0];
  LayerStack[1] = saved_layer_stack[1];
  LayerStack[2] = saved_layer_stack[2];
  LayerStack[3] = saved_layer_stack[3];
  LayerStack[4] = saved_layer_stack[4];
  LayerStack[5] = saved_layer_stack[5];
  LayerStack[6] = saved_layer_stack[6];
  LayerStack[7] = saved_layer_stack[7];
  LayerStack[8] = saved_layer_stack[8];
  LayerStack[9] = saved_layer_stack[9];
  LayerStack[10] = saved_layer_stack[10];
  LayerStack[11] = saved_layer_stack[11];
  LayerStack[12] = saved_layer_stack[12];
  LayerStack[13] = saved_layer_stack[13];
  LayerStack[14] = saved_layer_stack[14];
  LayerStack[15] = saved_layer_stack[15];
  maybe_close_f();
  hid_restore_layer_ons(save_ons);
  pPVar13 = PCB;
  (PCB->Flags).t[7] = uVar2;
  (pPVar13->Flags).f = uVar10;
  (pPVar13->Flags).t[6] = uVar3;
  (pPVar13->Flags).t[5] = uVar4;
  (pPVar13->Flags).t[4] = uVar5;
  (pPVar13->Flags).t[3] = uVar6;
  (pPVar13->Flags).t[2] = uVar7;
  (pPVar13->Flags).t[1] = uVar8;
  (pPVar13->Flags).t[0] = uVar9;
  return;
}



void nelma_use_mask(int use_it)

{
  return;
}



void nelma_set_line_cap(hidGC gc,EndCapStyle style)

{
  gc[1].nothing_interesting_here = style;
  return;
}



void nelma_set_line_width(hidGC gc,int width)

{
  gc[2].nothing_interesting_here = width;
  return;
}



void nelma_set_draw_xor(hidGC gc,int xor)

{
  return;
}



void nelma_set_draw_faded(hidGC gc,int faded)

{
  gc[5].nothing_interesting_here = faded;
  return;
}



void nelma_set_crosshair(int x,int y,int a)

{
  return;
}



void nelma_calibrate(double xval,double yval)

{
  char "nelma_calibrate" [16];
  
  __fprintf_chk(stderr,1,0x815cfd0,"nelma_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



void nelma_set_line_cap_angle(void)

{
  char "nelma_set_line_cap_angle" [25];
  
  __fprintf_chk(stderr,1,0x815cfd0,"nelma_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



void __regparm3 nelma_write_layer(FILE *out,int z,int h,char *name,int full,char *mat)

{
  uint uVar1;
  LibraryMenuTypePtr *pLVar2;
  LibraryEntryTypePtr *pLVar3;
  uint uVar4;
  uint uVar5;
  LibraryMenuTypePtr *pLVar6;
  uint local_24;
  
  __fprintf_chk(out,1,"layer %s {\n",name);
  __fprintf_chk(out,1,"\theight = %d\n",h);
  __fprintf_chk(out,1,"\tz-order = %d\n",z);
  __fprintf_chk(out,1,"\tmaterial = \"%s\"\n",mat);
  if (full != 0) {
    __fprintf_chk(out,1,"\tobjects = {\n",mat);
    uVar1 = (PCB->NetlistLib).MenuN;
    pLVar2 = (PCB->NetlistLib).Menu;
    if (uVar1 != 0) {
      local_24 = 0;
      do {
        pLVar6 = pLVar2 + local_24;
        if (pLVar6->EntryN != 0) {
          uVar5 = 0;
          do {
            pLVar3 = pLVar6->Entry;
            if ((uVar5 != 0) || (local_24 != 0)) {
              __fprintf_chk(out,1,&DAT_0815d367,mat);
            }
            uVar4 = uVar5 + 1;
            mat = pLVar3[uVar5].ListEntry;
            __fprintf_chk(out,1,"\t\t\"%s-%s\"",mat,name);
            uVar5 = uVar4;
          } while (uVar4 < pLVar6->EntryN);
        }
        local_24 = local_24 + 1;
      } while (local_24 < uVar1);
    }
    __fprintf_chk(out,1,0x8148088,mat);
  }
  __fprintf_chk();
  return;
}



void __regparm3 nelma_write_material(FILE *out,char *name,char *type,double e)

{
  undefined8 local_30;
  undefined4 uVar1;
  
  uVar1 = (undefined4)((ulonglong)local_30 >> 0x20);
  __fprintf_chk(out,1,"material %s {\n",name);
  __fprintf_chk(out,1,"\ttype = \"%s\"\n",type,uVar1);
  __fprintf_chk(out,1,"\tpermittivity = %e\n",e);
  __fprintf_chk(out,1,"\tconductivity = 0.0\n");
  __fprintf_chk(out,1,"\tpermeability = 0.0\n");
  __fprintf_chk(out,1,0x814808a);
  return;
}



void __regparm3 use_gc(hidGC gc)

{
  int iVar1;
  uint uVar2;
  undefined4 uVar3;
  int iVar4;
  undefined4 uVar5;
  int in_GS_OFFSET;
  int local_15c;
  char local_12d;
  int bval;
  char name [256];
  void *bcache;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((HID *)gc->nothing_interesting_here != &nelma_hid) {
    __fprintf_chk(stderr,1,"Fatal: GC from another HID passed to nelma HID\n");
                    // WARNING: Subroutine does not return
    abort();
  }
  if (gc[2].nothing_interesting_here == linewidth) {
    if ((gdImagePtr)gc[7].nothing_interesting_here == lastbrush) goto LAB_081114e4;
  }
  else {
    gdImageSetThickness(nelma_im,(gc[2].nothing_interesting_here * nelma_dpi) / 100000);
    linewidth = gc[2].nothing_interesting_here;
  }
  if ((gc[1].nothing_interesting_here == 0) || (gc[1].nothing_interesting_here == 2)) {
    local_12d = 'C';
    iVar4 = gc[2].nothing_interesting_here / 2;
    uVar5 = 0x43;
  }
  else {
    iVar4 = gc[2].nothing_interesting_here;
    local_12d = 'S';
    uVar5 = 0x53;
  }
  local_15c = (iVar4 * nelma_dpi) / 100000;
  iVar4 = gc[6].nothing_interesting_here;
  __sprintf_chk(name,1,0x100,"#%.2x%.2x%.2x_%c_%d",*(undefined4 *)(iVar4 + 4),
                *(undefined4 *)(iVar4 + 8),*(undefined4 *)(iVar4 + 0xc),uVar5,local_15c);
  iVar4 = hid_cache_color(0,name,&bval,&bcache);
  if (iVar4 == 0) {
    if (local_12d == 'C') {
      iVar4 = local_15c * 2 + 1;
      iVar4 = gdImageCreate(iVar4,iVar4);
      gc[7].nothing_interesting_here = iVar4;
    }
    else {
      iVar4 = gdImageCreate(local_15c + 1,local_15c + 1);
      gc[7].nothing_interesting_here = iVar4;
    }
    uVar5 = gdImageColorAllocate(iVar4,0xff,0xff,0xff);
    iVar4 = gc[6].nothing_interesting_here;
    uVar3 = gdImageColorAllocate
                      (gc[7].nothing_interesting_here,*(undefined4 *)(iVar4 + 4),
                       *(undefined4 *)(iVar4 + 8),*(undefined4 *)(iVar4 + 0xc));
    gdImageColorTransparent(gc[7].nothing_interesting_here,uVar5);
    if (local_15c == 0) {
      local_15c = 0;
LAB_0811164c:
      gdImageFilledRectangle(gc[7].nothing_interesting_here,0,0,local_15c,local_15c,uVar3);
    }
    else {
      if (local_12d != 'C') goto LAB_0811164c;
      gdImageFilledEllipse
                (gc[7].nothing_interesting_here,local_15c,local_15c,local_15c * 2,local_15c * 2,
                 uVar3);
    }
    bval = gc[7].nothing_interesting_here;
    hid_cache_color(1,name,&bval,&bcache);
    iVar4 = gc[7].nothing_interesting_here;
  }
  else {
    gc[7].nothing_interesting_here = bval;
    iVar4 = bval;
  }
  gdImageSetBrush(nelma_im,iVar4);
  lastbrush = (gdImagePtr)gc[7].nothing_interesting_here;
LAB_081114e4:
  uVar2 = (uint)*(byte *)&gc[3].nothing_interesting_here << 0x18 |
          (uint)*(byte *)((int)&gc[3].nothing_interesting_here + 1) << 0x10 |
          gc[5].nothing_interesting_here |
          (uint)*(byte *)((int)&gc[3].nothing_interesting_here + 2) << 8;
  if ((uVar2 != lastcolor) && ((is_drill != 0 || (lastcolor = uVar2, is_mask != 0)))) {
    lastcolor = 0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void nelma_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  gdImageFilledRectangle
            (nelma_im,(nelma_dpi * x1) / 100000,(y1 * nelma_dpi) / 100000,(x2 * nelma_dpi) / 100000,
             (y2 * nelma_dpi) / 100000,*(undefined4 *)gc[6].nothing_interesting_here);
  return;
}



void nelma_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  int iVar1;
  
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  iVar1 = (nelma_dpi * 2 * radius) / 100000;
  gdImageFilledEllipse
            (nelma_im,(nelma_dpi * cx) / 100000,(cy * nelma_dpi) / 100000,iVar1,iVar1,
             *(undefined4 *)gc[6].nothing_interesting_here);
  return;
}



hidGC nelma_make_gc(void)

{
  hidGC phVar1;
  undefined4 *puVar2;
  
  phVar1 = (hidGC)calloc(1,0x20);
  phVar1->nothing_interesting_here = 0x816a820;
  phVar1[1].nothing_interesting_here = 0;
  phVar1[2].nothing_interesting_here = 1;
  puVar2 = (undefined4 *)calloc(1,0x10);
  puVar2[3] = 0;
  puVar2[2] = 0;
  puVar2[1] = 0;
  *puVar2 = 0;
  *(undefined4 **)&phVar1[6].nothing_interesting_here = puVar2;
  return phVar1;
}



void nelma_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  int iVar1;
  void *__ptr;
  int iVar2;
  
  __ptr = calloc(1,n_coords << 3);
  if (__ptr != (void *)0x0) {
    use_gc(gc);
    iVar1 = nelma_dpi;
    if (0 < n_coords) {
      iVar2 = 0;
      do {
        *(int *)((int)__ptr + iVar2 * 8) = (x[iVar2] * iVar1) / 100000;
        *(int *)((int)__ptr + iVar2 * 8 + 4) = (iVar1 * y[iVar2]) / 100000;
        iVar2 = iVar2 + 1;
      } while (iVar2 != n_coords);
    }
    gdImageSetThickness(nelma_im,0);
    linewidth = 0;
    gdImageFilledPolygon(nelma_im,__ptr,n_coords,*(undefined4 *)gc[6].nothing_interesting_here);
    free(__ptr);
    return;
  }
  __fprintf_chk(stderr,1,"ERROR:  nelma_fill_polygon():  malloc failed\n");
                    // WARNING: Subroutine does not return
  exit(1);
}



void nelma_destroy_gc(hidGC gc)

{
  free(gc);
  return;
}



void nelma_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageRectangle(nelma_im,(nelma_dpi * x1) / 100000,(y1 * nelma_dpi) / 100000,
                   (x2 * nelma_dpi) / 100000,(y2 * nelma_dpi) / 100000,
                   *(undefined4 *)gc[6].nothing_interesting_here);
  return;
}



void nelma_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int delta_angle)

{
  int iVar1;
  int iVar2;
  
  start_angle = 0xb4 - start_angle;
  iVar1 = -delta_angle;
  if (iVar1 == 0 || 0 < delta_angle) {
    iVar1 = iVar1 + start_angle;
    iVar2 = start_angle;
  }
  else {
    iVar2 = iVar1 + start_angle;
    iVar1 = start_angle;
  }
  while (iVar1 < 0) {
    iVar2 = iVar2 + 0x168;
    iVar1 = iVar1 + 0x168;
  }
  while (0x167 < iVar1) {
    iVar1 = iVar1 + -0x168;
    iVar2 = iVar2 + -0x168;
  }
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  gdImageArc(nelma_im,(nelma_dpi * cx) / 100000,(cy * nelma_dpi) / 100000,
             (nelma_dpi * 2 * width) / 100000,(height * nelma_dpi * 2) / 100000,iVar1,iVar2,
             0xfffffffd);
  return;
}



void nelma_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  int iVar1;
  
  if ((y1 == y2) && (x1 == x2)) {
    iVar1 = gc[2].nothing_interesting_here / 2;
    nelma_fill_rect(gc,x1 - iVar1,y1 - iVar1,x1 + iVar1,y1 + iVar1);
    return;
  }
  use_gc(gc);
  gdImageSetThickness(nelma_im,0);
  linewidth = 0;
  gdImageLine(nelma_im,(x1 * nelma_dpi) / 100000,(y1 * nelma_dpi) / 100000,(x2 * nelma_dpi) / 100000
              ,(y2 * nelma_dpi) / 100000,0xfffffffd);
  return;
}



void nelma_set_color(hidGC gc,char *name)

{
  color_struct *pcVar1;
  color_struct *pcVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  
  pcVar2 = white;
  pcVar1 = black;
  if (nelma_im != (gdImagePtr)0x0) {
    bVar6 = name == (char *)0x0;
    if (!bVar6) {
      iVar3 = 6;
      pcVar4 = name;
      pcVar5 = "drill";
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar6 = *pcVar4 == *pcVar5;
        pcVar4 = pcVar4 + 1;
        pcVar5 = pcVar5 + 1;
      } while (bVar6);
      if (!bVar6) {
        iVar3 = 6;
        pcVar4 = "erase";
        do {
          if (iVar3 == 0) break;
          iVar3 = iVar3 + -1;
          bVar6 = *name == *pcVar4;
          name = name + 1;
          pcVar4 = pcVar4 + 1;
        } while (bVar6);
        if (bVar6) {
          gc[4].nothing_interesting_here = 1;
          *(color_struct **)&gc[6].nothing_interesting_here = pcVar2;
          return;
        }
      }
    }
    gc[4].nothing_interesting_here = 0;
    *(color_struct **)&gc[6].nothing_interesting_here = pcVar1;
  }
  return;
}



int nelma_set_layer(char *name,int group,int empty)

{
  bool bVar1;
  Cardinal *pCVar2;
  int iVar3;
  uint uVar4;
  byte *pbVar5;
  bool bVar6;
  bool bVar7;
  
  uVar4 = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    uVar4 = (PCB->LayerGroups).Entries[group * 0x12];
  }
  bVar7 = name == (char *)0x0;
  bVar6 = false;
  if (bVar7) {
    bVar6 = CARRY4(uVar4 * 0x5c,(uint)PCB->Data);
    pCVar2 = &PCB->Data->ViaN + uVar4 * 0x17;
    bVar7 = pCVar2 == (Cardinal *)0x0;
    name = (char *)pCVar2[0x13];
  }
  iVar3 = 10;
  pbVar5 = (byte *)"invisible";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = (byte)*name < *pbVar5;
    bVar7 = *name == *pbVar5;
    name = (char *)((byte *)name + 1);
    pbVar5 = pbVar5 + 1;
  } while (bVar7);
  bVar1 = false;
  if ((!bVar6 && !bVar7) == bVar6) {
    return 0;
  }
  if ((int)uVar4 < 0) {
    uVar4 = uVar4 & 0xf0;
    if ((uVar4 == 0x40) || (uVar4 == 0x30)) {
      is_drill = 1;
      bVar1 = true;
    }
    else {
      is_drill = 0;
    }
    if (uVar4 == 0x20) {
      is_mask = 1;
      return 0;
    }
    if (bVar1) {
      is_mask = 0;
      return 1;
    }
  }
  else {
    is_drill = 0;
  }
  is_mask = 0;
  return (uint)(group == nelma_cur_group);
}



void register_nelma_attribute_list(void)

{
  hid_register_attributes((HID_Attribute *)nelma_attribute_list,5);
  return;
}



void nelma_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes((HID_Attribute *)nelma_attribute_list,5);
  hid_parse_command_line(argc,argv);
  return;
}



char * __regparm3 nelma_get_png_name(char *basename,char *suffix)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  
  sVar1 = strlen(basename);
  sVar2 = strlen(suffix);
  pcVar3 = (char *)calloc(1,sVar1 + 6 + sVar2);
  __sprintf_chk(pcVar3,1,0xffffffff,"%s.%s.png",basename,suffix);
  return pcVar3;
}



HID_Attribute * nelma_get_export_options(int *n)

{
  char *last_made_filename;
  
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)nelma_attribute_list,".nelma",(char **)&ram0x081946d8)
    ;
  }
  if (n != (int *)0x0) {
    *n = 5;
  }
  return (HID_Attribute *)nelma_attribute_list;
}



void hid_nelma_init(void)

{
  apply_default_hid(&nelma_hid,(HID *)0x0);
  hid_register_hid(&nelma_hid);
  register_nelma_attribute_list();
  return;
}



void nelma_start_png_export(void)

{
  BoxType region;
  
  region.X1 = 0;
  region.Y1 = 0;
  lastbrush = (gdImagePtr)0xffffffff;
  region.X2 = PCB->MaxWidth;
  region.Y2 = PCB->MaxHeight;
  linewidth = -1;
  lastcap = -1;
  lastcolor = -1;
  lastgroup = -1;
  hid_expose_callback(&nelma_hid,&region,(void *)0x0);
  return;
}



void nelma_choose_groups(void)

{
  Cardinal *pCVar1;
  DataTypePtr *pDVar2;
  int iVar3;
  PCBTypePtr pPVar4;
  Cardinal Layer;
  int *piVar5;
  
  iVar3 = 0x10;
  piVar5 = nelma_export_group;
  while (iVar3 != 0) {
    iVar3 = iVar3 + -1;
    *piVar5 = 0;
    piVar5 = piVar5 + 1;
  }
  pDVar2 = PCB->Data;
  if (0 < pDVar2->LayerN) {
    Layer = 0;
    pPVar4 = PCB;
    do {
      pCVar1 = &pDVar2->ViaN + Layer * 0x17;
      if ((((pCVar1[0x14] != 0) || (pCVar1[0x15] != 0)) || (pCVar1[0x17] != 0)) ||
         (pCVar1[0x16] != 0)) {
        iVar3 = GetLayerGroupNumberByNumber(Layer);
        pPVar4 = PCB;
        nelma_export_group[iVar3] = 1;
      }
      pDVar2 = pPVar4->Data;
      Layer = Layer + 1;
    } while (pDVar2->LayerN != Layer && (int)Layer <= pDVar2->LayerN);
  }
  return;
}



void nelma_do_export(HID_Attr_Val *options)

{
  Cardinal *pCVar1;
  char cVar2;
  int iVar3;
  LibraryMenuTypePtr *pLVar4;
  LibraryEntryTypePtr *pLVar5;
  double dVar6;
  ulonglong uVar7;
  char *suffix;
  color_struct *pcVar8;
  int h;
  FILE *out;
  char *__filename;
  LibraryMenuTypePtr *pLVar9;
  Cardinal idx;
  int h_00;
  HID_Attr_Val *pHVar10;
  uint uVar11;
  Cardinal CVar12;
  int iVar13;
  HID_Attr_Val *pHVar14;
  int z;
  int *piVar15;
  int in_GS_OFFSET;
  byte bVar16;
  longlong local_150;
  ulonglong uVar17;
  double dVar18;
  undefined4 uVar19;
  uint local_100;
  uint local_f8;
  uint local_f0;
  int save_ons [18];
  ConnectionType conn;
  time_t local_88;
  char buf [100];
  
  bVar16 = 0;
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  if (options == (HID_Attr_Val *)0x0) {
    h = 0;
    nelma_get_export_options((int *)0x0);
    pHVar10 = &nelma_attribute_list[0].default_val;
    do {
      piVar15 = (int *)((int)&nelma_values[0].int_value + h);
      h = h + 0x10;
      h_00 = 4;
      pHVar14 = pHVar10;
      while (h_00 != 0) {
        h_00 = h_00 + -1;
        *piVar15 = pHVar14->int_value;
        pHVar14 = (HID_Attr_Val *)(&pHVar14->int_value + (uint)bVar16 * 0x3ffffffe + 1);
        piVar15 = piVar15 + (uint)bVar16 * 0x3ffffffe + 1;
      }
      pHVar10 = pHVar10 + 3;
    } while (h != 0x50);
    options = nelma_values;
  }
  nelma_basename = "pcb-out";
  if (options->str_value != (char *)0x0) {
    nelma_basename = options->str_value;
  }
  nelma_dpi = options[1].int_value;
  if (nelma_dpi < 0) {
    __fprintf_chk(stderr,1,"ERROR:  dpi may not be < 0\n");
  }
  else {
    nelma_copperh = options[2].int_value;
    CVar12 = 0;
    nelma_substratee = options[4].real_value;
    nelma_substrateh = options[3].int_value;
    nelma_choose_groups();
    do {
      uVar11 = (uint)((ulonglong)local_150 >> 0x20);
      if (nelma_export_group[CVar12] != 0) {
        pCVar1 = (Cardinal *)&PCB->Data->LayerN;
        idx = CVar12;
        if (*pCVar1 != CVar12 && (int)CVar12 <= (int)*pCVar1) {
          idx = (PCB->LayerGroups).Entries[CVar12 * 0x12];
        }
        nelma_cur_group = CVar12;
        suffix = layer_type_to_file_name(idx);
        suffix = nelma_get_png_name(nelma_basename,suffix);
        nelma_im = (gdImagePtr)gdImageCreate();
        nelma_f = (FILE *)fopen(suffix,"wb");
        pcVar8 = (color_struct *)calloc(1,0x10);
        pcVar8->b = 0xff;
        pcVar8->g = 0xff;
        pcVar8->r = 0xff;
        white = pcVar8;
        h = gdImageColorAllocate(nelma_im,0xff,0xff,0xff);
        pcVar8->c = h;
        pcVar8 = (color_struct *)calloc(1,0x10);
        pcVar8->b = 0;
        pcVar8->g = 0;
        pcVar8->r = 0;
        local_150 = (ulonglong)uVar11 << 0x20;
        black = pcVar8;
        h = gdImageColorAllocate(nelma_im,0,0,0,uVar11);
        pcVar8->c = h;
        free(suffix);
        hid_save_and_show_layer_ons(save_ons);
        nelma_start_png_export();
        hid_restore_layer_ons(save_ons);
        gdImagePng();
        gdImageDestroy();
        fclose((FILE *)nelma_f);
        free(white);
        free(black);
        nelma_im = (gdImagePtr)0x0;
        nelma_f = (FILE *)0x0;
      }
      CVar12 = CVar12 + 1;
    } while (CVar12 != 0x10);
    uVar11 = 0xffffffff;
    suffix = nelma_basename;
    do {
      if (uVar11 == 0) break;
      uVar11 = uVar11 - 1;
      cVar2 = *suffix;
      suffix = suffix + (uint)bVar16 * -2 + 1;
    } while (cVar2 != '\0');
    __filename = (char *)calloc(1,~uVar11 + 3);
    suffix = nelma_basename;
    __sprintf_chk(__filename,1,0xffffffff,"%s.em",nelma_basename);
    out = (FILE *)fopen(__filename,"w");
    free(__filename);
    __fprintf_chk(out,1,"/* Made with PCB Nelma export HID */");
    local_88 = time((time_t *)0x0);
    __filename = ctime(&local_88);
    uVar17 = CONCAT44(suffix,__filename);
    __fprintf_chk(out,1,"/* %s */",__filename,suffix);
    uVar11 = (PCB->NetlistLib).MenuN;
    pLVar4 = (PCB->NetlistLib).Menu;
    __fprintf_chk(out,1,"\n/* **** Nets **** */\n\n");
    if (uVar11 != 0) {
      local_100 = 0;
      do {
        pLVar9 = pLVar4 + local_100;
        uVar7 = uVar17 >> 0x20;
        uVar17 = uVar17 & 0xffffffff00000000;
        __fprintf_chk(out,1,"net %s {\n",pLVar9->Name + 2,(int)uVar7);
        __fprintf_chk(out,1,"\tobjects = {\n");
        if (pLVar9->EntryN != 0) {
          local_f0 = 0;
          do {
            CVar12 = 0;
            pLVar5 = pLVar9->Entry;
            do {
              if (nelma_export_group[CVar12] != 0) {
                pCVar1 = (Cardinal *)&PCB->Data->LayerN;
                idx = CVar12;
                if (*pCVar1 != CVar12 && (int)CVar12 <= (int)*pCVar1) {
                  idx = (PCB->LayerGroups).Entries[CVar12 * 0x12];
                }
                suffix = layer_type_to_file_name(idx);
                if ((CVar12 != 0) || (local_f0 != 0)) {
                  __fprintf_chk(out,1,&DAT_0815d367);
                }
                __filename = pLVar5[local_f0].ListEntry;
                uVar17 = CONCAT44(suffix,__filename);
                __fprintf_chk(out,1,"\t\t\"%s-%s\"",__filename,suffix);
              }
              CVar12 = CVar12 + 1;
            } while (CVar12 != 0x10);
            local_f0 = local_f0 + 1;
          } while (local_f0 <= pLVar9->EntryN && pLVar9->EntryN != local_f0);
        }
        __fprintf_chk(out,1,0x8151453);
        __fprintf_chk(out,1,0x8148089);
        __fprintf_chk(out,1,0x814808a);
        local_100 = local_100 + 1;
      } while (local_100 < uVar11);
    }
    uVar11 = (PCB->NetlistLib).MenuN;
    pLVar4 = (PCB->NetlistLib).Menu;
    __fprintf_chk(out,1,"\n/* **** Objects **** */\n\n");
    if (uVar11 != 0) {
      local_100 = 0;
      do {
        pLVar9 = pLVar4 + local_100;
        if (pLVar9->EntryN != 0) {
          local_f8 = 0;
          do {
            pLVar5 = pLVar9->Entry;
            SeekPad((LibraryEntryType *)(pLVar5 + local_f8),&conn,'\0');
            CVar12 = 0;
            do {
              if (nelma_export_group[CVar12] != 0) {
                idx = CVar12;
                if ((int)CVar12 < PCB->Data->LayerN) {
                  idx = (PCB->LayerGroups).Entries[CVar12 * 0x12];
                }
                suffix = layer_type_to_file_name(idx);
                __fprintf_chk(out,1,"object %s-%s {\n",
                              ((LibraryEntryType *)(pLVar5 + local_f8))->ListEntry,suffix);
                __fprintf_chk(out,1,"\tposition = { 0, 0 }\n");
                __fprintf_chk(out,1,"\tmaterial = \"copper\"\n");
                __fprintf_chk(out,1,"\ttype = \"image\"\n");
                __fprintf_chk(out,1,"\trole = \"net\"\n");
                suffix = nelma_get_png_name(nelma_basename,suffix);
                __fprintf_chk(out,1,"\tfile = \"%s\"\n");
                free(suffix);
                __fprintf_chk(out,1,"\tfile-pos = { %d, %d }\n");
                __fprintf_chk(out,1,0x814808a);
              }
              CVar12 = CVar12 + 1;
            } while (CVar12 != 0x10);
            local_f8 = local_f8 + 1;
          } while (local_f8 <= pLVar9->EntryN && pLVar9->EntryN != local_f8);
        }
        local_100 = local_100 + 1;
      } while (local_100 < uVar11);
    }
    h_00 = nelma_substrateh / nelma_copperh;
    __fprintf_chk(out,1,"\n/* **** Layers **** */\n\n");
    h = h_00 * 2;
    nelma_write_layer(out,1,h,"air-top",0,"air");
    CVar12 = 0;
    nelma_write_layer(out,1000,h,"air-bottom",0,"air");
    h = 10;
    do {
      iVar13 = h;
      if (nelma_export_group[CVar12] != 0) {
        idx = CVar12;
        if ((int)CVar12 < PCB->Data->LayerN) {
          idx = (PCB->LayerGroups).Entries[CVar12 * 0x12];
        }
        iVar13 = 0xb;
        suffix = layer_type_to_file_name(idx);
        z = h;
        if (h != 10) {
          __sprintf_chk(buf,1,100,"substrate-%d",h);
          z = h + 1;
          iVar13 = h + 2;
          nelma_write_layer(out,h,h_00,buf,0,"composite");
        }
        nelma_write_layer(out,z,1,suffix,1,"air");
      }
      CVar12 = CVar12 + 1;
      h = iVar13;
    } while (CVar12 != 0x10);
    CVar12 = 0;
    __fprintf_chk(out,1,"\n/* **** Materials **** */\n\n");
    nelma_write_material(out,"copper","metal",0.00000000);
    nelma_write_material(out,"air","dielectric",0.00000000);
    nelma_write_material(out,"composite","dielectric",nelma_substratee * 0.00000000);
    dVar18 = 0.02540000 / (double)nelma_dpi;
    dVar6 = (double)nelma_copperh;
    __fprintf_chk(out,1,"\n/* **** Space **** */\n\n");
    __fprintf_chk(out,1,"space pcb {\n");
    __fprintf_chk(out,1,"\tstep = { %e, %e, %e }\n",dVar18,dVar18,dVar6 * 0.00000100);
    __fprintf_chk(out,1,"\tlayers = {\n");
    __fprintf_chk(out,1,&DAT_0815d35c);
    __fprintf_chk(out,1,"\t\t\"air-bottom\"");
    h = 10;
    do {
      uVar19 = (undefined4)((ulonglong)dVar18 >> 0x20);
      h_00 = h;
      if (nelma_export_group[CVar12] != 0) {
        idx = CVar12;
        if ((int)CVar12 < PCB->Data->LayerN) {
          idx = (PCB->LayerGroups).Entries[CVar12 * 0x12];
        }
        suffix = layer_type_to_file_name(idx);
        if (h == 10) {
          h_00 = 0xb;
        }
        else {
          __fprintf_chk(out,1,&DAT_0815d367);
          h_00 = h + 2;
          __fprintf_chk(out,1,"\t\t\"substrate-%d\"",h,uVar19);
        }
        __fprintf_chk(out,1,&DAT_0815d367);
        dVar18 = (double)CONCAT44(uVar19,suffix);
        __fprintf_chk(out,1,"\t\t\"%s\"",suffix,uVar19);
      }
      CVar12 = CVar12 + 1;
      h = h_00;
    } while (CVar12 != 0x10);
    __fprintf_chk(out,1,0x8148088);
    __fprintf_chk(out,1,0x814808a);
    fclose((FILE *)out);
  }
  if (iVar3 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void png_use_mask(int use_it)

{
  return;
}



void png_set_line_cap(hidGC gc,EndCapStyle style)

{
  gc[1].nothing_interesting_here = style;
  return;
}



void png_set_line_width(hidGC gc,int width)

{
  gc[2].nothing_interesting_here = width;
  return;
}



void png_set_draw_xor(hidGC gc,int xor)

{
  return;
}



void png_set_draw_faded(hidGC gc,int faded)

{
  gc[5].nothing_interesting_here = faded;
  return;
}



void png_set_crosshair(int x,int y,int a)

{
  return;
}



void png_calibrate(double xval,double yval)

{
  char "png_calibrate" [14];
  
  __fprintf_chk(stderr,1,0x815cfd0,"png_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



void png_set_line_cap_angle(void)

{
  char "png_set_line_cap_angle" [23];
  
  __fprintf_chk(stderr,1,0x815cfd0,"png_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



void __regparm3 use_gc(hidGC gc)

{
  int iVar1;
  char "use_gc" [7];
  uint uVar2;
  int iVar3;
  int iVar4;
  int local_15c;
  int in_GS_OFFSET;
  char local_138;
  int bval;
  char name [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((HID *)gc->nothing_interesting_here != &png_hid) {
    __fprintf_chk(stderr,1,0x815d478);
                    // WARNING: Subroutine does not return
    abort();
  }
  iVar4 = gc[2].nothing_interesting_here;
  if (iVar4 == linewidth) {
    if ((gdImagePtr)gc[7].nothing_interesting_here != lastbrush) goto LAB_08112e9f;
  }
  else {
    if (((int)ROUND((double)iVar4 / scale + 0.50000000) == 0) && (0 < iVar4)) {
      gdImageSetThickness(im,1);
    }
    else {
      gdImageSetThickness(im,(int)ROUND((bloat + bloat + (double)iVar4) / scale + 0.50000000));
    }
    linewidth = gc[2].nothing_interesting_here;
LAB_08112e9f:
    iVar4 = 0x53;
    local_138 = 'S';
    if ((uint)gc[1].nothing_interesting_here < 3) {
      local_138 = *(char *)((int)&CSWTCH_196 + gc[1].nothing_interesting_here);
      iVar4 = (int)local_138;
    }
    local_15c = 1;
    if ((gc[2].nothing_interesting_here != 0) &&
       (local_15c = (int)ROUND((bloat + bloat + (double)gc[2].nothing_interesting_here) / scale +
                               0.50000000), local_15c == 0)) {
      local_15c = 1;
    }
    iVar3 = gc[6].nothing_interesting_here;
    __sprintf_chk(name,1,0x100,"#%.2x%.2x%.2x_%c_%d",*(undefined4 *)(iVar3 + 4),
                  *(undefined4 *)(iVar3 + 8),*(undefined4 *)(iVar3 + 0xc),iVar4,local_15c);
    iVar4 = hid_cache_color(0,name,&bval,&brush_cache);
    if (iVar4 == 0) {
      iVar4 = gdImageCreate(local_15c,local_15c);
      gc[7].nothing_interesting_here = iVar4;
      if (iVar4 == 0) {
        Message("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n",0x815daae,
                local_15c,local_15c);
        goto LAB_08112ff8;
      }
      iVar4 = gdImageColorAllocate(iVar4,0xff,0xff,0xff);
      if (iVar4 != -1) {
        iVar3 = gc[6].nothing_interesting_here;
        iVar3 = gdImageColorAllocateAlpha
                          (gc[7].nothing_interesting_here,*(undefined4 *)(iVar3 + 4),
                           *(undefined4 *)(iVar3 + 8),*(undefined4 *)(iVar3 + 0xc),0);
        if (iVar3 != -1) {
          gdImageColorTransparent(gc[7].nothing_interesting_here,iVar4);
          if (local_15c < 2) {
            local_15c = 0;
LAB_0811313a:
            gdImageFilledRectangle(gc[7].nothing_interesting_here,0,0,local_15c,local_15c,iVar3);
          }
          else {
            if (local_138 != 'C') {
              local_15c = local_15c + -1;
              goto LAB_0811313a;
            }
            iVar4 = local_15c >> 1;
            gdImageFilledEllipse
                      (gc[7].nothing_interesting_here,iVar4,iVar4,local_15c,local_15c,iVar3);
            gdImageSetPixel(gc[7].nothing_interesting_here,0,iVar4,iVar3);
            gdImageSetPixel(gc[7].nothing_interesting_here,local_15c + -1,iVar4,iVar3);
            gdImageSetPixel(gc[7].nothing_interesting_here,iVar4,0,iVar3);
            gdImageSetPixel(gc[7].nothing_interesting_here,iVar4,local_15c + -1,iVar3);
          }
          bval = gc[7].nothing_interesting_here;
          hid_cache_color(1,name,&bval,&brush_cache);
          iVar4 = gc[7].nothing_interesting_here;
          goto LAB_08112fa2;
        }
      }
      Message("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n","use_gc");
      goto LAB_08112ff8;
    }
    gc[7].nothing_interesting_here = bval;
    iVar4 = bval;
LAB_08112fa2:
    gdImageSetBrush(im,iVar4);
    lastbrush = (gdImagePtr)gc[7].nothing_interesting_here;
  }
  uVar2 = (uint)*(byte *)&gc[3].nothing_interesting_here << 0x18 |
          (uint)*(byte *)((int)&gc[3].nothing_interesting_here + 1) << 0x10 |
          gc[5].nothing_interesting_here |
          (uint)*(byte *)((int)&gc[3].nothing_interesting_here + 2) << 8;
  if ((uVar2 != lastcolor) && ((is_drill != 0 || (lastcolor = uVar2, is_mask != 0)))) {
    lastcolor = 0;
  }
LAB_08112ff8:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void png_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageSetThickness(im,0);
  if (y2 < y1) {
    y2 = y1;
  }
  linewidth = 0;
  if (x2 < x1) {
    x2 = x1;
  }
  gdImageFilledRectangle
            (im,(int)ROUND((((double)x1 - bloat) - (double)x_shift) / scale),
             (int)ROUND((((double)y1 - bloat) - (double)y_shift) / scale),
             (int)ROUND((((double)x2 + bloat) - (double)x_shift) / scale) + -1,
             (int)ROUND((((double)y2 + bloat) - (double)y_shift) / scale) + -1,
             *(undefined4 *)gc[6].nothing_interesting_here);
  return;
}



void png_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  int iVar1;
  
  use_gc(gc);
  gdImageSetThickness(im,0);
  linewidth = 0;
  iVar1 = (int)ROUND((bloat + bloat + (double)(radius * 2)) / scale + 0.50000000);
  gdImageFilledEllipse
            (im,(int)ROUND((double)(cx - x_shift) / scale),
             (int)ROUND((double)(cy - y_shift) / scale),iVar1,iVar1,
             *(undefined4 *)gc[6].nothing_interesting_here);
  return;
}



hidGC png_make_gc(void)

{
  hidGC phVar1;
  undefined4 *puVar2;
  
  phVar1 = (hidGC)calloc(1,0x20);
  phVar1->nothing_interesting_here = 0x816ac60;
  phVar1[1].nothing_interesting_here = 0;
  phVar1[2].nothing_interesting_here = 1;
  puVar2 = (undefined4 *)calloc(1,0x14);
  puVar2[4] = 0;
  puVar2[3] = 0;
  puVar2[2] = 0;
  puVar2[1] = 0;
  *puVar2 = 0;
  *(undefined4 **)&phVar1[6].nothing_interesting_here = puVar2;
  return phVar1;
}



void png_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  double dVar1;
  int iVar2;
  int iVar3;
  void *__ptr;
  int iVar4;
  
  __ptr = calloc(1,n_coords * 8);
  if (__ptr == (void *)0x0) {
    __fprintf_chk(stderr,1,"ERROR:  png_fill_polygon():  malloc failed\n");
                    // WARNING: Subroutine does not return
    exit(1);
  }
  use_gc(gc);
  iVar3 = x_shift;
  iVar2 = y_shift;
  dVar1 = scale;
  if (0 < n_coords) {
    iVar4 = 0;
    do {
      *(int *)((int)__ptr + iVar4 * 8) = (int)ROUND((double)(x[iVar4] - iVar3) / dVar1);
      *(int *)((int)__ptr + iVar4 * 8 + 4) = (int)ROUND((double)(y[iVar4] - iVar2) / dVar1);
      iVar4 = iVar4 + 1;
    } while (iVar4 != n_coords);
  }
  gdImageSetThickness(im,0);
  linewidth = 0;
  gdImageFilledPolygon(im,__ptr,n_coords,*(undefined4 *)gc[6].nothing_interesting_here);
  free(__ptr);
  return;
}



void png_destroy_gc(hidGC gc)

{
  free(gc);
  return;
}



void png_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  gdImageRectangle(im,(int)ROUND((double)(x1 - x_shift) / scale),
                   (int)ROUND((double)(y1 - y_shift) / scale),
                   (int)ROUND((double)(x2 - x_shift) / scale),
                   (int)ROUND((double)(y2 - y_shift) / scale),
                   *(undefined4 *)gc[6].nothing_interesting_here);
  return;
}



void png_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int delta_angle)

{
  int iVar1;
  int iVar2;
  
  start_angle = 0xb4 - start_angle;
  iVar2 = -delta_angle;
  if (iVar2 == 0 || 0 < delta_angle) {
    iVar1 = iVar2 + start_angle;
  }
  else {
    iVar1 = start_angle;
    start_angle = iVar2 + start_angle;
  }
  while (iVar1 < 0) {
    iVar1 = iVar1 + 0x168;
    start_angle = start_angle + 0x168;
  }
  while (0x167 < iVar1) {
    iVar1 = iVar1 + -0x168;
    start_angle = start_angle + -0x168;
  }
  use_gc(gc);
  gdImageSetThickness(im,0);
  linewidth = 0;
  gdImageArc(im,(int)ROUND((double)(cx - x_shift) / scale),
             (int)ROUND((double)(cy - y_shift) / scale),
             (int)ROUND((double)(width * 2) / scale + 0.50000000),
             (int)ROUND((double)(height * 2) / scale + 0.50000000),iVar1,start_angle,0xfffffffd);
  return;
}



// WARNING: Removing unreachable block (ram,0x08113b58)
// WARNING: Removing unreachable block (ram,0x08113b4f)
// WARNING: Removing unreachable block (ram,0x08113b5a)

void png_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  double dVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  gdPoint p [4];
  
  if ((y1 == y2) && (x1 == x2)) {
    iVar4 = gc[2].nothing_interesting_here / 2;
    png_fill_rect(gc,x1 - iVar4,y1 - iVar4,x1 + iVar4,y1 + iVar4);
    return;
  }
  use_gc(gc);
  gdImageSetThickness(im,0);
  linewidth = 0;
  if (((x1 != x2) && (gc[1].nothing_interesting_here == 1)) && (y1 != y2)) {
    iVar4 = gc[6].nothing_interesting_here;
    uVar2 = gdImageColorResolve(im,*(undefined4 *)(iVar4 + 4),*(undefined4 *)(iVar4 + 8),
                                *(undefined4 *)(iVar4 + 0xc));
    iVar5 = x2 - x1;
    iVar3 = y2 - y1;
    dVar1 = SQRT((double)(iVar5 * iVar5 + iVar3 * iVar3));
    dVar1 = (dVar1 + dVar1) * scale;
    iVar4 = (int)ROUND(bloat + bloat + (double)gc[2].nothing_interesting_here);
    p[3].y = (int)ROUND((double)iVar3 * ((double)-iVar4 / dVar1));
    iVar4 = (int)ROUND((double)iVar5 * ((double)iVar4 / dVar1));
    iVar3 = (int)ROUND((double)(x1 - x_shift) / scale);
    p[0].x = (p[3].y + iVar3) - iVar4;
    p[1].x = (iVar3 - p[3].y) - iVar4;
    iVar3 = (int)ROUND((double)(y1 - y_shift) / scale);
    p[0].y = iVar4 + p[3].y + iVar3;
    p[1].y = (p[3].y + iVar3) - iVar4;
    iVar3 = (int)ROUND((double)(x2 - x_shift) / scale);
    p[3].x = iVar4 + p[3].y + iVar3;
    p[2].x = (iVar4 + iVar3) - p[3].y;
    iVar3 = (int)ROUND((double)(y2 - y_shift) / scale);
    p[2].y = (iVar3 - iVar4) - p[3].y;
    p[3].y = (iVar4 + iVar3) - p[3].y;
    gdImageFilledPolygon(im,p,4,uVar2);
    return;
  }
  gdImageLine(im,(int)ROUND((double)(x1 - x_shift) / scale),
              (int)ROUND((double)(y1 - y_shift) / scale),(int)ROUND((double)(x2 - x_shift) / scale),
              (int)ROUND((double)(y2 - y_shift) / scale),0xfffffffd);
  return;
}



void png_set_color(hidGC gc,char *name)

{
  undefined4 *puVar1;
  color_struct *pcVar2;
  char "png_set_color" [14];
  void *pvVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  char *pcVar7;
  char *pcVar8;
  bool bVar9;
  int *cval;
  
  iVar6 = in_mono;
  pcVar2 = white;
  if (im == (gdImagePtr)0x0) {
    return;
  }
  bVar9 = name == (char *)0x0;
  if (bVar9) {
    name = "#ff0000";
LAB_08113be5:
    gc[4].nothing_interesting_here = 0;
    bVar9 = iVar6 == 0;
    if (bVar9) {
      iVar6 = 8;
      pcVar7 = name;
      pcVar8 = "#000000";
      do {
        if (iVar6 == 0) break;
        iVar6 = iVar6 + -1;
        bVar9 = *pcVar7 == *pcVar8;
        pcVar7 = pcVar7 + 1;
        pcVar8 = pcVar8 + 1;
      } while (bVar9);
      if (!bVar9) {
        iVar6 = hid_cache_color(0,name,&cval,&color_cache);
        if (iVar6 != 0) {
          *(int **)&gc[6].nothing_interesting_here = cval;
          return;
        }
        if (*name != '#') {
          __printf_chk(1,"WE SHOULD NOT BE HERE!!!\n");
          *(color_struct **)&gc[6].nothing_interesting_here = black;
          return;
        }
        pvVar3 = calloc(1,0x14);
        *(void **)&gc[6].nothing_interesting_here = pvVar3;
        sscanf(name + 1,"%2x%2x%2x",(int)pvVar3 + 4,(int)pvVar3 + 8,(int)pvVar3 + 0xc);
        puVar1 = (undefined4 *)gc[6].nothing_interesting_here;
        uVar4 = gdImageColorAllocate(im,puVar1[1],puVar1[2],puVar1[3]);
        *puVar1 = uVar4;
        cval = (int *)gc[6].nothing_interesting_here;
        if (*cval != -1) {
          hid_cache_color(1,name,&cval,&color_cache);
          return;
        }
        Message("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n","png_set_color");
        return;
      }
    }
    *(color_struct **)&gc[6].nothing_interesting_here = black;
  }
  else {
    iVar5 = 6;
    pcVar7 = name;
    pcVar8 = "erase";
    do {
      if (iVar5 == 0) break;
      iVar5 = iVar5 + -1;
      bVar9 = *pcVar7 == *pcVar8;
      pcVar7 = pcVar7 + 1;
      pcVar8 = pcVar8 + 1;
    } while (bVar9);
    if (!bVar9) {
      iVar5 = 6;
      pcVar7 = name;
      pcVar8 = "drill";
      do {
        if (iVar5 == 0) break;
        iVar5 = iVar5 + -1;
        bVar9 = *pcVar7 == *pcVar8;
        pcVar7 = pcVar7 + 1;
        pcVar8 = pcVar8 + 1;
      } while (bVar9);
      if (!bVar9) goto LAB_08113be5;
    }
    gc[4].nothing_interesting_here = 1;
    *(color_struct **)&gc[6].nothing_interesting_here = pcVar2;
  }
  return;
}



int png_set_layer(char *name,int group,int empty)

{
  uint uVar1;
  gdImagePtr *ppgVar2;
  char "png_set_layer" [14];
  gdImagePtr pgVar3;
  color_struct *pcVar4;
  int iVar5;
  uint uVar6;
  char *pcVar7;
  char *pcVar8;
  bool bVar9;
  color_struct *white;
  color_struct *black;
  
  uVar1 = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    uVar1 = (PCB->LayerGroups).Entries[group * 0x12];
  }
  if (name == (char *)0x0) {
    name = *(char **)(&PCB->Data->field_0x4c + uVar1 * 0x5c);
  }
  if ((int)uVar1 < 0) {
    if ((uVar1 & 0xf0) == 0x70) {
      return 0;
    }
    bVar9 = (uVar1 & 0xf0) == 0x80;
    if (bVar9) {
      return 0;
    }
  }
  else {
    uVar6 = PCB->Data->LayerN;
    bVar9 = uVar1 == uVar6;
    if (((int)uVar1 < (int)uVar6) && (bVar9 = print_layer[uVar1] == 0, bVar9)) {
      return 0;
    }
  }
  iVar5 = 10;
  pcVar7 = name;
  pcVar8 = "invisible";
  do {
    if (iVar5 == 0) break;
    iVar5 = iVar5 + -1;
    bVar9 = *pcVar7 == *pcVar8;
    pcVar7 = pcVar7 + 1;
    pcVar8 = pcVar8 + 1;
  } while (bVar9);
  if (bVar9) {
    return 0;
  }
  if ((int)uVar1 < 0) {
    uVar6 = uVar1 & 0xf0;
    if ((uVar6 == 0x40) || (uVar6 == 0x30)) {
      is_drill = 1;
    }
    else {
      is_drill = 0;
    }
    if (uVar6 == 0x20) {
      is_mask = 1;
      bVar9 = true;
    }
    else {
      is_mask = 0;
      if (uVar6 == 0x50) {
        is_mask = 0;
        return 0;
      }
      bVar9 = false;
    }
  }
  else {
    is_drill = 0;
    bVar9 = false;
    is_mask = 0;
  }
  if (photo_mode == 0) {
    if (as_shown == 0) {
      if (bVar9) {
        return 0;
      }
      if (1 < uVar1 + 0xfef) {
        return 1;
      }
      return *(int *)((int)&CSWTCH_199 + (uVar1 + 0xfef) * 4);
    }
    if ((int)uVar1 < -0xfef) {
      return 1;
    }
    if (-0xfee < (int)uVar1) {
      if (1 < uVar1 + 0xfdf) {
        return 1;
      }
      if ((*(byte *)((int)&(PCB->Flags).f + 1) & 0x20) == 0) {
        return 0;
      }
      return (uVar1 >> 1 ^ 1) & 1 ^ (uint)(Settings.ShowSolderSide != '\0');
    }
    if ((bool)(((byte)(uVar1 >> 1) ^ 1) & 1) == (Settings.ShowSolderSide != '\0')) {
      return 0;
    }
    return (int)PCB->ElementOn;
  }
  switch(uVar1) {
  case 0xfffff011:
    break;
  case 0xfffff012:
    break;
  default:
    if ((int)uVar1 < 0) {
      return 0;
    }
    iVar5 = strcasecmp(name,"outline");
    if (iVar5 == 0) {
      photo_im = &photo_outline;
    }
    else {
      photo_im = photo_copper + group;
    }
    goto LAB_08113e18;
  case 0xfffff021:
    goto joined_r0x08114028;
  case 0xfffff022:
joined_r0x08114028:
    if (photo_flip == 0) {
      return 0;
    }
    photo_im = &photo_mask;
    goto LAB_08113e18;
  case 0xfffff030:
  case 0xfffff040:
    photo_im = &photo_drill;
    goto LAB_08113e18;
  }
  if (photo_flip == 0) {
    return 0;
  }
  photo_im = &photo_silk;
LAB_08113e18:
  ppgVar2 = photo_im;
  pgVar3 = *photo_im;
  if (pgVar3 == (gdImagePtr)0x0) {
    pgVar3 = (gdImagePtr)gdImageCreate(im->sx,im->sy);
    bVar9 = photo_im == (gdImagePtr *)0x0;
    *ppgVar2 = pgVar3;
    if (bVar9) {
      Message("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n",0x815dada,im->sx,
              im->sy);
      return 0;
    }
    pcVar4 = (color_struct *)calloc(1,0x14);
    pcVar4->b = 0xff;
    pcVar4->g = 0xff;
    pcVar4->r = 0xff;
    pcVar4[1].c = 0;
    white = pcVar4;
    iVar5 = gdImageColorAllocate(*photo_im,0xff,0xff,0xff);
    pcVar4->c = iVar5;
    if (white->c == -1) {
      Message("%s():  gdImageColorAllocate() returned NULL.  Aborting export.\n","png_set_layer");
      return 0;
    }
    pcVar4 = (color_struct *)calloc(1,0x14);
    pcVar4[1].c = 0;
    pcVar4->b = 0;
    pcVar4->g = 0;
    pcVar4->r = 0;
    black = pcVar4;
    iVar5 = gdImageColorAllocate(*photo_im,0,0,0);
    pcVar4->c = iVar5;
    if (black->c == -1) {
      Message("%s(): gdImageColorAllocate() returned NULL.  Aborting export.\n",0x815dada);
      return 0;
    }
    if ((uVar1 == 0xfffff040) || (uVar1 == 0xfffff030)) {
      gdImageFilledRectangle(*photo_im,0,0,im->sx,im->sy,black->c);
    }
    pgVar3 = *photo_im;
  }
  im = pgVar3;
  return 1;
}



void register_png_attribute_list(void)

{
  hid_register_attributes((HID_Attribute *)png_attribute_list,0x11);
  return;
}



void png_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes((HID_Attribute *)png_attribute_list,0x11);
  hid_parse_command_line(argc,argv);
  return;
}



void __regparm3 ts_bs(gdImagePtr im)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined4 local_40;
  int local_30;
  int local_24;
  
  local_30 = 0;
  if (0 < im->sx) {
    do {
      iVar4 = 0;
      if (0 < im->sy) {
        do {
          iVar5 = -0x28;
          local_24 = 0;
          iVar3 = local_30 + -2;
          do {
            iVar2 = -2;
            do {
              iVar1 = gdImageGetPixel(im,iVar3,iVar2 + iVar4);
              if (iVar1 == 0) {
                local_24 = local_24 + *(int *)(iVar5 + 0x815db30 + iVar2 * 4);
              }
              iVar2 = iVar2 + 1;
            } while (iVar2 != 3);
            iVar3 = iVar3 + 1;
            iVar5 = iVar5 + 0x14;
          } while (iVar5 != 0x3c);
          iVar3 = gdImageGetPixel(im,local_30,iVar4);
          if (iVar3 != 0) {
            if (local_24 < 2) {
              if (-2 < local_24) goto LAB_08114342;
              local_40 = 3;
            }
            else {
              local_40 = 2;
            }
            gdImageSetPixel(im,local_30,iVar4,local_40);
          }
LAB_08114342:
          iVar4 = iVar4 + 1;
        } while (im->sy != iVar4 && iVar4 <= im->sy);
      }
      local_30 = local_30 + 1;
    } while (im->sx != local_30 && local_30 <= im->sx);
  }
  return;
}



HID_Attribute * png_get_export_options(int *n)

{
  byte bVar1;
  byte *pbVar2;
  char *last_made_filename;
  int iVar3;
  byte *pbVar4;
  byte *pbVar5;
  bool bVar6;
  bool bVar7;
  char *local_20;
  
  pbVar2 = (byte *)filetypes[png_attribute_list[9].default_val.int_value];
  bVar1 = *pbVar2;
  bVar6 = bVar1 < 0x47;
  bVar7 = bVar1 == 0x47;
  if (bVar7) {
    bVar6 = pbVar2[1] < 0x49;
    bVar7 = pbVar2[1] == 0x49;
    if (bVar7) {
      bVar6 = pbVar2[2] < 0x46;
      bVar7 = pbVar2[2] == 0x46;
      if (bVar7) {
        bVar6 = false;
        bVar7 = pbVar2[3] == 0;
        if (bVar7) {
          local_20 = ".gif";
          goto LAB_081143f4;
        }
      }
    }
  }
  iVar3 = 5;
  pbVar4 = pbVar2;
  pbVar5 = &DAT_0815d8c2;
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *pbVar4 < *pbVar5;
    bVar7 = *pbVar4 == *pbVar5;
    pbVar4 = pbVar4 + 1;
    pbVar5 = pbVar5 + 1;
  } while (bVar7);
  local_20 = ".jpg";
  if ((!bVar6 && !bVar7) != bVar6) {
    if ((((bVar1 == 0x50) && (pbVar2[1] == 0x4e)) && (pbVar2[2] == 0x47)) && (pbVar2[3] == 0)) {
      local_20 = ".png";
    }
    else {
      __fprintf_chk(stderr,1,"Error:  Invalid graphic file format\n");
      local_20 = ".???";
    }
  }
LAB_081143f4:
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)png_attribute_list,local_20,(char **)&ram0x081947f4);
  }
  if (n != (int *)0x0) {
    *n = 0x11;
  }
  return (HID_Attribute *)png_attribute_list;
}



void hid_png_init(void)

{
  apply_default_hid(&png_hid,(HID *)0x0);
  hid_register_hid(&png_hid);
  register_png_attribute_list();
  return;
}



int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  Layer = *(Cardinal *)va;
  Layer_00 = *(Cardinal *)vb;
  iVar4 = PCB->Data->LayerN;
  iVar1 = iVar4 + 1;
  if (((int)Layer < 0) || (iVar1 < (int)Layer)) {
    iVar2 = iVar4 + 3 + Layer;
  }
  else {
    iVar2 = GetLayerGroupNumberByNumber(Layer);
    iVar4 = PCB->Data->LayerN;
    iVar1 = iVar4 + 1;
  }
  if ((iVar1 < (int)Layer_00) || ((int)Layer_00 < 0)) {
    iVar1 = iVar4 + 3 + Layer_00;
  }
  else {
    iVar1 = GetLayerGroupNumberByNumber(Layer_00);
  }
  if ((-1 < (int)Layer) && ((int)Layer <= PCB->Data->LayerN + 1)) {
    iVar4 = 0;
    if (solder_layer != iVar2) {
      iVar4 = (uint)(comp_layer == iVar2) + 1;
    }
    iVar3 = 0;
    if (solder_layer != iVar1) {
      iVar3 = (uint)(comp_layer == iVar1) + 1;
    }
    if (iVar4 != iVar3) {
      return iVar3 - iVar4;
    }
  }
  iVar4 = iVar1 - iVar2;
  if (iVar1 - iVar2 == 0) {
    iVar4 = Layer_00 - Layer;
  }
  return iVar4;
}



void png_hid_export_to_file(FILE *the_file,HID_Attr_Val *options)

{
  Cardinal *pCVar1;
  int saved_layer_stack [16];
  DataTypePtr *pDVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  PCBTypePtr pPVar6;
  int *piVar7;
  Cardinal Layer;
  Cardinal Layer_00;
  int iVar8;
  bool bVar9;
  byte bVar10;
  uchar local_38;
  uchar local_37;
  uchar local_36;
  uchar local_35;
  uchar local_34;
  uchar local_33;
  uchar local_32;
  uchar local_31;
  uint local_30;
  BoxType region;
  
  bVar10 = 0;
  region.X1 = 0;
  region.Y1 = 0;
  f = the_file;
  region.X2 = PCB->MaxWidth;
  region.Y2 = PCB->MaxHeight;
  if (options[7].int_value == 0) {
    bounds = &region;
  }
  else {
    bounds = (BoxType *)GetDataBoundingBox(PCB->Data);
  }
  pPVar6 = PCB;
  iVar5 = 0x10;
  piVar7 = print_group;
  while (iVar5 != 0) {
    iVar5 = iVar5 + -1;
    *piVar7 = 0;
    piVar7 = piVar7 + (uint)bVar10 * 0x3ffffffe + 1;
  }
  iVar5 = 0x10;
  piVar7 = print_layer;
  while (iVar5 != 0) {
    iVar5 = iVar5 + -1;
    *piVar7 = 0;
    piVar7 = piVar7 + (uint)bVar10 * 0x3ffffffe + 1;
  }
  pDVar2 = pPVar6->Data;
  Layer_00 = pDVar2->LayerN;
  if (0 < (int)Layer_00) {
    Layer = 0;
    do {
      pCVar1 = &pDVar2->ViaN + Layer * 0x17;
      if ((((pCVar1[0x14] != 0) || (pCVar1[0x15] != 0)) || (pCVar1[0x17] != 0)) ||
         (pCVar1[0x16] != 0)) {
        iVar5 = GetLayerGroupNumberByNumber(Layer);
        pPVar6 = PCB;
        print_group[iVar5] = 1;
      }
      pDVar2 = pPVar6->Data;
      Layer = Layer + 1;
      Layer_00 = pDVar2->LayerN;
    } while ((int)Layer < (int)Layer_00);
  }
  iVar5 = GetLayerGroupNumberByNumber(Layer_00);
  print_group[iVar5] = 1;
  iVar5 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  pPVar6 = PCB;
  print_group[iVar5] = 1;
  if (0 < pPVar6->Data->LayerN) {
    Layer_00 = 0;
    do {
      iVar5 = GetLayerGroupNumberByNumber(Layer_00);
      if (print_group[iVar5] != 0) {
        print_layer[Layer_00] = 1;
      }
      Layer_00 = Layer_00 + 1;
      pCVar1 = (Cardinal *)&PCB->Data->LayerN;
      pPVar6 = PCB;
    } while (*pCVar1 != Layer_00 && (int)Layer_00 <= (int)*pCVar1);
  }
  saved_layer_stack[0] = LayerStack[0];
  saved_layer_stack[1] = LayerStack[1];
  saved_layer_stack[2] = LayerStack[2];
  saved_layer_stack[3] = LayerStack[3];
  saved_layer_stack[4] = LayerStack[4];
  saved_layer_stack[5] = LayerStack[5];
  saved_layer_stack[6] = LayerStack[6];
  saved_layer_stack[7] = LayerStack[7];
  saved_layer_stack[8] = LayerStack[8];
  saved_layer_stack[9] = LayerStack[9];
  saved_layer_stack[10] = LayerStack[10];
  saved_layer_stack[11] = LayerStack[11];
  saved_layer_stack[12] = LayerStack[12];
  saved_layer_stack[13] = LayerStack[13];
  saved_layer_stack[14] = LayerStack[14];
  saved_layer_stack[15] = LayerStack[15];
  as_shown = options[5].int_value;
  if (as_shown == 0) {
    comp_layer = GetLayerGroupNumberByNumber(pPVar6->Data->LayerN + 1);
    solder_layer = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    qsort(LayerStack,PCB->Data->LayerN,4,layer_sort);
    local_31 = (PCB->Flags).t[7];
    local_32 = (PCB->Flags).t[6];
    local_33 = (PCB->Flags).t[5];
    local_34 = (PCB->Flags).t[4];
    local_35 = (PCB->Flags).t[3];
    local_36 = (PCB->Flags).t[2];
    local_37 = (PCB->Flags).t[1];
    local_38 = (PCB->Flags).t[0];
    local_30 = (PCB->Flags).f;
    bVar9 = photo_mode != 0;
    (PCB->Flags).f = local_30 & 0xfffdbfff;
    iVar4 = solder_layer;
    iVar5 = comp_layer;
    if (bVar9) {
      iVar8 = 0;
      iVar3 = comp_layer;
      if (comp_layer < solder_layer) {
        do {
          photo_groups[iVar3 - iVar5] = iVar3;
          iVar3 = iVar3 + 1;
        } while (iVar3 <= iVar4);
        photo_ngroups = iVar4 + 2 + ~iVar5;
      }
      else {
        do {
          photo_groups[iVar8] = iVar3;
          iVar3 = iVar3 + -1;
          iVar8 = iVar8 + 1;
        } while (iVar4 <= iVar3);
        photo_ngroups = (iVar5 - iVar4) + 1;
      }
      if ((photo_flip != 0) && (iVar5 = photo_ngroups + -1, 0 < iVar5)) {
        piVar7 = photo_groups + iVar5;
        iVar4 = 0;
        do {
          iVar3 = photo_groups[iVar4];
          photo_groups[iVar4] = *piVar7;
          iVar4 = iVar4 + 1;
          *piVar7 = iVar3;
          piVar7 = piVar7 + -1;
        } while (iVar4 < iVar5 - iVar4);
      }
    }
  }
  in_mono = options[6].int_value;
  linewidth = -1;
  lastbrush = (gdImagePtr)0xffffffff;
  lastcap = -1;
  lastcolor = -1;
  lastgroup = -1;
  hid_expose_callback(&png_hid,bounds,(void *)0x0);
  pPVar6 = PCB;
  LayerStack[0] = saved_layer_stack[0];
  LayerStack[1] = saved_layer_stack[1];
  LayerStack[2] = saved_layer_stack[2];
  LayerStack[3] = saved_layer_stack[3];
  LayerStack[4] = saved_layer_stack[4];
  LayerStack[5] = saved_layer_stack[5];
  LayerStack[6] = saved_layer_stack[6];
  LayerStack[7] = saved_layer_stack[7];
  LayerStack[8] = saved_layer_stack[8];
  LayerStack[9] = saved_layer_stack[9];
  LayerStack[10] = saved_layer_stack[10];
  LayerStack[11] = saved_layer_stack[11];
  LayerStack[12] = saved_layer_stack[12];
  LayerStack[13] = saved_layer_stack[13];
  LayerStack[14] = saved_layer_stack[14];
  LayerStack[15] = saved_layer_stack[15];
  if (options[5].int_value == 0) {
    (PCB->Flags).t[7] = local_31;
    (pPVar6->Flags).t[6] = local_32;
    (pPVar6->Flags).t[5] = local_33;
    (pPVar6->Flags).t[4] = local_34;
    (pPVar6->Flags).t[3] = local_35;
    (pPVar6->Flags).t[2] = local_36;
    (pPVar6->Flags).t[1] = local_37;
    (pPVar6->Flags).t[0] = local_38;
    (pPVar6->Flags).f = local_30;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void png_do_export(HID_Attr_Val *options)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  float fVar4;
  double *pdVar5;
  char "png_do_export" [14];
  int iVar6;
  int iVar7;
  BoxTypePtr pBVar8;
  int iVar9;
  color_struct *pcVar10;
  uint uVar11;
  int iVar12;
  undefined4 uVar13;
  long lVar14;
  uint uVar15;
  gdImagePtr pgVar16;
  HID_Attr_Val *pHVar17;
  int iVar18;
  char *pcVar19;
  uint uVar20;
  gdImagePtr *ppgVar21;
  char *pcVar22;
  int *piVar23;
  uint uVar24;
  int in_GS_OFFSET;
  bool bVar25;
  byte bVar26;
  undefined4 local_e0;
  HID_Attr_Val *local_b8;
  int local_b0;
  ulonglong local_ac;
  int local_a4;
  int local_a0;
  uint local_9c;
  uint local_90;
  ulonglong local_84;
  int save_ons [18];
  double local_34;
  char suf [10];
  
  bVar26 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_b8 = options;
  if (color_cache != (void *)0x0) {
    free(color_cache);
    color_cache = (void *)0x0;
  }
  if (brush_cache != (void *)0x0) {
    free(brush_cache);
    brush_cache = (void *)0x0;
  }
  if (options == (HID_Attr_Val *)0x0) {
    png_get_export_options((int *)0x0);
    pHVar17 = &png_attribute_list[0].default_val;
    iVar9 = 0;
    do {
      *(int *)((int)&png_values[0].int_value + iVar9) = pHVar17->int_value;
      *(char **)((int)&png_values[0].str_value + iVar9) = pHVar17->str_value;
      *(undefined4 *)((int)&png_values[0].real_value + iVar9) = *(undefined4 *)&pHVar17->real_value;
      pdVar5 = &pHVar17->real_value;
      pHVar17 = pHVar17 + 3;
      *(undefined4 *)((int)&png_values[0].real_value + iVar9 + 4) = *(undefined4 *)((int)pdVar5 + 4)
      ;
      iVar9 = iVar9 + 0x10;
    } while (iVar9 != 0x110);
    local_b8 = png_values;
  }
  if (local_b8[0xb].int_value == 0) {
    photo_mode = 0;
  }
  else {
    photo_mode = 1;
    local_b8[6].int_value = 1;
    local_b8[5].int_value = 0;
    iVar9 = 0x12;
    ppgVar21 = photo_copper;
    while (iVar9 != 0) {
      iVar9 = iVar9 + -1;
      *ppgVar21 = (gdImagePtr)0x0;
      ppgVar21 = ppgVar21 + (uint)bVar26 * 0x3ffffffe + 1;
    }
    photo_drill = (gdImagePtr)0x0;
    photo_mask = (gdImagePtr)0x0;
    photo_silk = (gdImagePtr)0x0;
    photo_outline = (gdImagePtr)0x0;
    if (local_b8[0xc].int_value == 0) {
      photo_flip = ~-(uint)(local_b8[0xd].int_value == 0) & 2;
    }
    else {
      photo_flip = 1;
    }
  }
  filename = "pcb-out.png";
  if (local_b8->str_value != (char *)0x0) {
    filename = local_b8->str_value;
  }
  if (local_b8[7].int_value == 0) {
    x_shift = 0;
    y_shift = 0;
    iVar9 = PCB->MaxHeight;
    iVar12 = PCB->MaxWidth;
  }
  else {
    pBVar8 = GetDataBoundingBox(PCB->Data);
    y_shift = pBVar8->Y1;
    x_shift = pBVar8->X1;
    iVar9 = pBVar8->Y2 - y_shift;
    iVar12 = pBVar8->X2 - x_shift;
  }
  iVar6 = local_b8[1].int_value;
  if ((iVar6 != 0) && (iVar6 < 0)) {
    __fprintf_chk(stderr,1,"ERROR:  dpi may not be < 0\n");
    goto LAB_081150a5;
  }
  iVar18 = local_b8[2].int_value;
  if (iVar18 < 1) {
    iVar18 = 0;
  }
  else {
    iVar6 = 0;
  }
  iVar7 = local_b8[3].int_value;
  if (iVar7 < 1) {
    iVar7 = 0;
  }
  else {
    iVar6 = 0;
  }
  iVar2 = local_b8[4].int_value;
  if (iVar2 < 1) {
    if (iVar6 == 0) goto LAB_08114c04;
    fVar4 = 100000.00000000 / (float)iVar6;
    scale = (double)fVar4;
    iVar18 = (int)ROUND((float)iVar12 / fVar4);
    iVar7 = (int)ROUND((float)iVar9 / fVar4);
  }
  else {
    if ((iVar18 == 0) || (iVar2 < iVar18)) {
      iVar18 = iVar2;
    }
    if ((iVar7 == 0) || (iVar2 < iVar7)) {
      iVar7 = iVar2;
    }
LAB_08114c04:
    if (iVar7 == 0) {
      if (iVar18 == 0) {
        __fprintf_chk(stderr,1,"ERROR:  You may not set both xmax, ymax,and xy-max to zero\n");
        goto LAB_081150a5;
      }
    }
    else {
      if ((iVar18 == 0) || (iVar12 / iVar18 <= iVar9 / iVar7)) {
        iVar18 = (iVar7 * iVar12) / iVar9;
        scale = (double)(iVar9 / iVar7);
        goto LAB_08114d98;
      }
    }
    iVar7 = (iVar9 * iVar18) / iVar12;
    scale = (double)(iVar12 / iVar18);
  }
LAB_08114d98:
  im = (gdImagePtr)gdImageCreate(iVar18,iVar7);
  if (im == (gdImagePtr)0x0) {
    Message("%s():  gdImageCreate(%d, %d) returned NULL.  Aborting export.\n",0x815dae8,iVar18,iVar7
           );
  }
  else {
    bloat = 0.00000000;
    master_im = im;
    if (local_b8[10].str_value != (char *)0x0) {
      suf[0] = '\0';
      sscanf(local_b8[10].str_value,"%lf %s",&local_34,suf);
      iVar9 = strcasecmp(suf,"in");
      if (iVar9 == 0) {
        bloat = local_34 * 100000.00000000;
      }
      else {
        iVar9 = strcasecmp(suf,"mil");
        if (iVar9 == 0) {
          bloat = local_34 * 100.00000000;
        }
        else {
          iVar9 = strcasecmp(suf,"mm");
          if (iVar9 == 0) {
            bloat = local_34 * 3937.00787400;
          }
          else {
            iVar9 = strcasecmp(suf,"um");
            if (iVar9 == 0) {
              bloat = local_34 * 3937.00787400 * 1000.00000000;
            }
            else {
              iVar9 = strcasecmp(suf,"pix");
              if ((iVar9 == 0) || (iVar9 = strcasecmp(suf,"px"), iVar9 == 0)) {
                bloat = local_34 * scale;
              }
              else {
                bloat = local_34;
              }
            }
          }
        }
      }
    }
    pcVar10 = (color_struct *)calloc(1,0x14);
    pcVar10->b = 0xff;
    pcVar10->g = 0xff;
    pcVar10->r = 0xff;
    uVar11 = ~-(uint)(local_b8[8].int_value == 0) & 0x7f;
    white = pcVar10;
    pcVar10[1].c = uVar11;
    iVar9 = gdImageColorAllocateAlpha(im,0xff,0xff,0xff,uVar11);
    pcVar10->c = iVar9;
    if (white->c == -1) {
      Message("%s():  gdImageColorAllocateAlpha() returned NULL.  Aborting export.\n",
              "png_do_export",iVar18,iVar7);
    }
    else {
      pcVar10 = (color_struct *)calloc(1,0x14);
      pcVar10[1].c = 0;
      pcVar10->b = 0;
      pcVar10->g = 0;
      pcVar10->r = 0;
      local_e0 = 0;
      black = pcVar10;
      iVar9 = gdImageColorAllocate(im,0,0,0);
      pcVar10->c = iVar9;
      if (black->c == -1) {
        Message("%s():  gdImageColorAllocateAlpha() returned NULL.  Aborting export.\n",0x815dae8);
      }
      else {
        f = (FILE *)fopen(filename,"wb");
        if (f == (FILE *)0x0) {
          perror(filename);
        }
        else {
          if (local_b8[5].int_value == 0) {
            hid_save_and_show_layer_ons(save_ons);
          }
          png_hid_export_to_file(f,local_b8);
          if (local_b8[5].int_value == 0) {
            hid_restore_layer_ons(save_ons);
          }
          if (photo_mode != 0) {
            im = master_im;
            ts_bs(photo_copper[photo_groups[0]]);
            ts_bs(photo_silk);
            pgVar16 = photo_mask;
            local_b0 = 0;
            if (0 < photo_mask->sx) {
              do {
                iVar9 = 0;
                if (0 < pgVar16->sy) {
                  do {
                    local_90 = -1;
                    local_a4 = 0;
                    do {
                      iVar18 = 0;
                      iVar12 = local_90 + 1;
                      piVar23 = smshadows + iVar12 * 3;
                      iVar6 = iVar9 + -1;
                      do {
                        iVar7 = gdImageGetPixel(pgVar16,local_90 + local_b0,iVar6);
                        if (iVar7 == 0) {
                          local_a4 = local_a4 + *piVar23;
                        }
                        iVar18 = iVar18 + 1;
                        iVar6 = iVar6 + 1;
                        piVar23 = piVar23 + 1;
                      } while (iVar18 != 3);
                      local_90 = iVar12;
                    } while (iVar12 != 2);
                    iVar12 = gdImageGetPixel(pgVar16,local_b0,iVar9);
                    if (iVar12 != 0) {
                      if (local_a4 < 2) {
                        if (local_a4 < -1) {
                          local_e0 = 3;
                          gdImageSetPixel(pgVar16,local_b0,iVar9,3);
                        }
                      }
                      else {
                        local_e0 = 2;
                        gdImageSetPixel(pgVar16,local_b0,iVar9,2);
                      }
                    }
                    iVar9 = iVar9 + 1;
                  } while (iVar9 < pgVar16->sy);
                }
                local_b0 = local_b0 + 1;
              } while (local_b0 < pgVar16->sx);
            }
            if (photo_outline != (gdImagePtr)0x0) {
              local_e0 = 0;
              uVar13 = gdImageColorResolve(photo_outline,0,0,0);
              if (0 < im->sx) {
                iVar9 = 0;
                do {
                  gdImageFillToBorder(photo_outline,iVar9,0,uVar13,uVar13);
                  iVar12 = iVar9 + 1;
                  local_e0 = uVar13;
                  gdImageFillToBorder(photo_outline,iVar9,im->sy + -1,uVar13,uVar13);
                  iVar9 = iVar12;
                } while (im->sx != iVar12 && iVar12 <= im->sx);
              }
              if (2 < im->sy) {
                iVar9 = 1;
                do {
                  gdImageFillToBorder(photo_outline,0,iVar9,uVar13,uVar13);
                  iVar12 = iVar9 + 1;
                  local_e0 = uVar13;
                  gdImageFillToBorder(photo_outline,im->sx + -1,iVar9,uVar13,uVar13);
                  iVar9 = iVar12;
                } while (iVar12 < im->sy + -1);
              }
            }
            local_90 = 0;
            pgVar16 = im;
            if (0 < im->sx) {
              do {
                uVar11 = 0;
                if (0 < pgVar16->sy) {
LAB_0811555c:
                  do {
                    local_a0 = 0;
                    if (photo_outline != (gdImagePtr)0x0) {
                      local_a0 = gdImageGetPixel(photo_outline,local_90,uVar11,local_e0);
                    }
                    local_a4 = 0;
                    if (photo_mask != (gdImagePtr)0x0) {
                      local_a4 = gdImageGetPixel(photo_mask,local_90,uVar11,local_e0);
                    }
                    iVar9 = 0;
                    if (photo_silk != (gdImagePtr)0x0) {
                      iVar9 = gdImageGetPixel(photo_silk,local_90,uVar11,local_e0);
                    }
                    iVar12 = gdImageGetPixel(photo_copper[photo_groups[1]],local_90,uVar11);
                    uVar24 = (-(uint)(iVar12 == 0) & 0x3c) + 0x28;
                    local_84._0_4_ = (-(uint)(iVar12 == 0) & 0x46) + 0x28;
                    if (photo_ngroups == 2) {
                      local_84 = (ulonglong)uVar24;
                      fVar4 = (float)local_84;
                      local_84 = (ulonglong)(uint)local_84;
                      local_ac._0_4_ = (uint)(longlong)ROUND(fVar4 * 0.30000001 + 49.00000000);
                      local_84._0_4_ =
                           (uint)(longlong)ROUND((float)local_84 * 0.30000001 + 49.00000000);
                      uVar24 = (uint)local_ac;
                    }
                    iVar12 = gdImageGetPixel(photo_copper[photo_groups[0]],local_90,uVar11);
                    uVar15 = uVar24;
                    local_ac._0_4_ = (uint)local_84;
                    if (iVar12 != 0) {
                      if (local_a4 == 0) {
                        lVar14 = random();
                        iVar6 = (lVar14 % 5) * 2;
                        uVar24 = iVar6 + 0x88;
                        uVar15 = iVar6 + 0x92;
                        uVar20 = iVar6 + 0x9c;
                      }
                      else {
                        uVar24 = 0xdc;
                        uVar15 = 0x91;
                        uVar20 = 0xe6;
                      }
                      if (iVar12 == 2) {
                        local_ac = (ulonglong)(0xff - uVar24);
                        local_ac._0_4_ =
                             (uint)(longlong)ROUND((double)local_ac * -0.70000000 + 255.00000000);
                        uVar24 = (uint)local_ac;
                        local_84 = (ulonglong)(0xff - uVar15);
                        local_ac = (ulonglong)(0xff - uVar20);
                        local_84._0_4_ =
                             (uint)(longlong)ROUND((double)local_84 * -0.70000000 + 255.00000000);
                        local_ac._0_4_ =
                             (uint)(longlong)ROUND((double)local_ac * -0.70000000 + 255.00000000);
                        uVar15 = (uint)local_84;
                      }
                      else {
                        local_ac._0_4_ = uVar20;
                        if (iVar12 == 3) {
                          local_ac = (ulonglong)uVar24;
                          local_84 = (ulonglong)uVar15;
                          uVar24 = (uint)(longlong)ROUND((double)local_ac * 0.70000000);
                          local_ac = (ulonglong)uVar20;
                          local_84._0_4_ = (uint)(longlong)ROUND((double)local_84 * 0.70000000);
                          local_ac._0_4_ = (uint)(longlong)ROUND((double)local_ac * 0.70000000);
                          uVar15 = (uint)local_84;
                        }
                      }
                    }
                    if ((photo_drill == (gdImagePtr)0x0) ||
                       (uVar20 = gdImageGetPixel(photo_drill,local_90,uVar11), uVar20 != 0)) {
                      if (iVar9 == 0) {
                        local_84._0_4_ = (uint)local_ac;
                        local_9c = uVar24;
                        if (local_a4 != 0) {
                          if (local_a4 == 2) {
                            fVar4 = 76.50000000;
                          }
                          else {
                            local_84._0_4_ = (uint)local_ac >> 1;
                            local_9c = uVar24 >> 1;
                            if (local_a4 != 3) goto LAB_0811577d;
                            fVar4 = 0.00000000;
                          }
                          local_84 = (ulonglong)uVar15;
                          local_9c = (uint)(longlong)
                                           ROUND((float)(ulonglong)(uVar24 >> 1) * 0.69999999 +
                                                 fVar4);
                          uVar15 = (uint)(longlong)ROUND((float)local_84 * 0.69999999 + fVar4);
                          local_84 = (ulonglong)((uint)local_ac >> 1);
                          local_84._0_4_ =
                               (uint)(longlong)ROUND((float)local_84 * 0.69999999 + fVar4);
                        }
                      }
                      else {
                        if (iVar9 == 2) {
                          uVar15 = 0xff;
                          local_84._0_4_ = 0xff;
                          local_9c = 0xff;
                        }
                        else {
                          uVar15 = 0xe0;
                          local_84._0_4_ = uVar15;
                          local_9c = uVar15;
                          if (iVar9 == 3) {
                            uVar15 = 0xc0;
                            local_84._0_4_ = uVar15;
                            local_9c = uVar15;
                          }
                        }
                      }
                    }
                    else {
                      local_a0 = 1;
                      uVar15 = uVar20;
                      local_84._0_4_ = 0;
                      local_9c = 0;
                    }
LAB_0811577d:
                    if (local_b8[8].int_value == 0) {
                      if (local_a0 == 0) {
                        local_e0 = gdImageColorResolve(im,local_9c,uVar15,(uint)local_84);
                        goto LAB_08115513;
                      }
                      local_e0 = gdImageColorResolve(im,0,0,0);
                      if (photo_flip != 1) goto LAB_08115522;
LAB_081157cf:
                      uVar24 = uVar11 + 1;
                      gdImageSetPixel(im,~local_90 + im->sx,uVar11);
                      pgVar16 = im;
                      uVar11 = uVar24;
                      if (im->sy == uVar24 || im->sy < (int)uVar24) break;
                      goto LAB_0811555c;
                    }
                    if (local_a0 == 0) {
                      local_e0 = gdImageColorResolveAlpha(im,local_9c,uVar15,(uint)local_84,0);
                    }
                    else {
                      local_e0 = gdImageColorResolveAlpha(im,0,0,0,0x7f);
                    }
LAB_08115513:
                    if (photo_flip == 1) goto LAB_081157cf;
LAB_08115522:
                    if (photo_flip == 2) {
                      gdImageSetPixel(im,local_90,~uVar11 + im->sy);
                    }
                    else {
                      gdImageSetPixel(im,local_90,uVar11);
                    }
                    uVar11 = uVar11 + 1;
                    pgVar16 = im;
                  } while (im->sy != uVar11 && (int)uVar11 <= im->sy);
                }
                local_90 = local_90 + 1;
              } while (pgVar16->sx != local_90 && (int)local_90 <= pgVar16->sx);
            }
          }
          pcVar3 = filetypes[local_b8[9].int_value];
          bVar25 = *pcVar3 == 'G';
          if ((((bVar25) && (bVar25 = pcVar3[1] == 'I', bVar25)) &&
              (bVar25 = pcVar3[2] == 'F', bVar25)) && (bVar25 = pcVar3[3] == '\0', bVar25)) {
            gdImageGif(im,f);
          }
          else {
            iVar9 = 5;
            pcVar19 = pcVar3;
            pcVar22 = "JPEG";
            do {
              if (iVar9 == 0) break;
              iVar9 = iVar9 + -1;
              bVar25 = *pcVar19 == *pcVar22;
              pcVar19 = pcVar19 + (uint)bVar26 * -2 + 1;
              pcVar22 = pcVar22 + (uint)bVar26 * -2 + 1;
            } while (bVar25);
            if (bVar25) {
              gdImageJpeg(im,f,0xffffffff);
            }
            else {
              if (((*pcVar3 == 'P') && (pcVar3[1] == 'N')) &&
                 ((pcVar3[2] == 'G' && (pcVar3[3] == '\0')))) {
                gdImagePng(im,f);
              }
              else {
                __fprintf_chk(stderr,1,
                              "Error:  Invalid graphic file format.  This is a bug.  Please report it.\n"
                             );
              }
            }
          }
          fclose((FILE *)f);
          gdImageDestroy(im);
        }
      }
    }
  }
LAB_081150a5:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ps_use_mask(int use_it)

{
  return;
}



void ps_set_line_cap(hidGC gc,EndCapStyle style)

{
  gc[1].nothing_interesting_here = style;
  return;
}



void ps_set_line_width(hidGC gc,int width)

{
  gc[2].nothing_interesting_here = width;
  return;
}



void ps_set_draw_xor(hidGC gc,int xor)

{
  return;
}



void ps_set_draw_faded(hidGC gc,int faded)

{
  gc[5].nothing_interesting_here = faded;
  return;
}



void ps_set_crosshair(int x,int y,int action)

{
  return;
}



void __regparm3 use_gc(hidGC gc)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  undefined4 uVar9;
  
  if ((HID *)gc->nothing_interesting_here != &ps_hid) {
    __fprintf_chk(stderr,1,0x815dbd8);
                    // WARNING: Subroutine does not return
    abort();
  }
  if (gc[2].nothing_interesting_here != linewidth) {
    __fprintf_chk(f,1,"%d setlinewidth\n",
                  ((-(uint)(gc[4].nothing_interesting_here == 0) & 4) - 2) * bloat +
                  gc[2].nothing_interesting_here);
    linewidth = gc[2].nothing_interesting_here;
  }
  uVar3 = gc[1].nothing_interesting_here;
  if (lastcap != uVar3) {
    uVar9 = 2;
    if (uVar3 < 3) {
      uVar9 = *(undefined4 *)(CSWTCH_163 + uVar3 * 4);
    }
    __fprintf_chk(f,1,"%d setlinecap %d setlinejoin\n",uVar9,uVar9);
    lastcap = gc[1].nothing_interesting_here;
  }
  bVar1 = *(byte *)((int)&gc[3].nothing_interesting_here + 1);
  bVar2 = *(byte *)((int)&gc[3].nothing_interesting_here + 2);
  if (((uint)*(byte *)&gc[3].nothing_interesting_here << 0x18 | (uint)bVar1 << 0x10 |
       gc[5].nothing_interesting_here | (uint)bVar2 << 8) == lastcolor) {
    return;
  }
  if ((is_drill != 0) || (is_mask != 0)) {
    __fprintf_chk(f,1,"%d gray\n",(uint)(gc[4].nothing_interesting_here == 0));
    lastcolor = 0;
    return;
  }
  fVar4 = (float)(ushort)*(byte *)&gc[3].nothing_interesting_here;
  fVar6 = (float)(ushort)bVar1;
  fVar7 = (float)(ushort)bVar2;
  if (gc[5].nothing_interesting_here == 0) {
    if (*(short *)&gc[3].nothing_interesting_here !=
        *(short *)((int)&gc[3].nothing_interesting_here + 1)) {
LAB_08115e64:
      __fprintf_chk(f,1,"%g %g %g rgb\n",(double)(fVar4 / 255.00000000),
                    (double)(fVar6 / 255.00000000),(double)(fVar7 / 255.00000000));
      goto LAB_08115e9d;
    }
  }
  else {
    fVar5 = (float)antifade_ratio * 255.00000000;
    fVar8 = (float)fade_ratio;
    fVar4 = fVar4 * fVar8 + fVar5;
    fVar6 = fVar6 * fVar8 + fVar5;
    fVar7 = fVar5 + fVar7 * fVar8;
    if (*(short *)&gc[3].nothing_interesting_here !=
        *(short *)((int)&gc[3].nothing_interesting_here + 1)) goto LAB_08115e64;
  }
  __fprintf_chk(f,1,"%g gray\n",(double)(fVar4 / 255.00000000));
LAB_08115e9d:
  lastcolor = (uint)*(byte *)&gc[3].nothing_interesting_here << 0x18 |
              (uint)*(byte *)((int)&gc[3].nothing_interesting_here + 1) << 0x10 |
              gc[5].nothing_interesting_here |
              (uint)*(byte *)((int)&gc[3].nothing_interesting_here + 2) << 8;
  return;
}



void ps_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  if (y2 < y1) {
    y2 = y1;
  }
  if (x2 < x1) {
    x2 = x1;
  }
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1 - bloat,y1 - bloat,x2 + bloat,y2 + bloat);
  return;
}



void ps_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  int *piVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  
  use_gc(gc);
  if (0 < n_coords) {
    pcVar3 = "moveto";
    iVar4 = 0;
    do {
      piVar1 = y + iVar4;
      piVar2 = x + iVar4;
      iVar4 = iVar4 + 1;
      __fprintf_chk(f,1,0x815f4f4,*piVar2,*piVar1,pcVar3);
      pcVar3 = "lineto";
    } while (iVar4 < n_coords);
  }
  __fprintf_chk();
  return;
}



void ps_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  int iVar1;
  
  use_gc(gc);
  iVar1 = 1;
  if (gc[4].nothing_interesting_here != 0) {
    if (is_copper != 0) {
      if (drillcopper == 0) {
        return;
      }
      if (drill_helper != 0) {
        iVar1 = PCB->minDrill;
        if (iVar1 < 0) {
          iVar1 = iVar1 + 3;
        }
        if (iVar1 >> 2 < radius) {
          radius = iVar1 >> 2;
        }
        iVar1 = -1;
        goto LAB_081160f0;
      }
    }
    iVar1 = -1;
  }
LAB_081160f0:
  __fprintf_chk(f,1,"%d %d %d c\n",cx,cy,iVar1 * bloat + radius);
  return;
}



void ps_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1,y1,x2,y2);
  return;
}



void ps_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int delta_angle)

{
  int iVar1;
  
  if (delta_angle < 1) {
    iVar1 = delta_angle + start_angle;
  }
  else {
    iVar1 = start_angle;
    start_angle = delta_angle + start_angle;
  }
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d %d %d %g a\n",iVar1,start_angle,-width,height,cx,cy,
                (double)(bloat * 2 + linewidth) / (double)width);
  return;
}



void ps_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  int radius;
  
  if ((y1 == y2) && (x1 == x2)) {
    radius = gc[2].nothing_interesting_here / 2;
    if (gc[1].nothing_interesting_here != 1) {
      ps_fill_circle(gc,x1,y1,radius);
      return;
    }
    ps_fill_rect(gc,x1 - radius,y1 - radius,x1 + radius,y1 + radius);
    return;
  }
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d t\n",x1,y1,x2,y2);
  return;
}



void ps_set_line_cap_angle(hidGC gc,int x1,int y1,int x2,int y2)

{
  char "ps_set_line_cap_angle" [22];
  
  __fprintf_chk(stderr,1,"HID error: pcb called unimplemented PS function %s.\n",
                "ps_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



void __regparm3 corner(int x,int y,int dx,int dy)

{
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  __fprintf_chk(f,1,"gsave %d setlinewidth %d %d translate %d %d scale\n",0,x,y,dx,dy);
  local_18 = 200000;
  local_1c = 0;
  local_20 = 20000;
  local_24 = 0;
  local_28 = 0;
  local_2c = 0;
  local_30 = 200000;
  __fprintf_chk(f,1,"%d %d moveto %d %d %d 0 90 arc %d %d lineto\n",200000,0,0,0,20000,0,200000);
  if ((dy < 0) && (dx < 0)) {
    local_28 = 0xffffb1e0;
    local_2c = 0;
    local_30 = 40000;
    __fprintf_chk(f,1,"%d %d moveto 0 %d rlineto\n",40000,0,0xffffb1e0,local_24,local_20,local_1c,
                  local_18);
  }
  __fprintf_chk(f,1,"stroke grestore\n",local_30,local_2c,local_28,local_24,local_20,local_1c,
                local_18);
  return;
}



void ps_start_file(FILE *f)

{
  __fprintf_chk(f,1,"%%!PS-Adobe-3.0\n\n");
  return;
}



void ps_set_color(hidGC gc,char *name)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  bool bVar4;
  undefined local_28;
  undefined local_24;
  undefined local_20;
  
  iVar1 = 6;
  bVar4 = (undefined *)register0x00000010 == &DAT_0000004c;
  pcVar2 = name;
  pcVar3 = "erase";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pcVar2 == *pcVar3;
    pcVar2 = pcVar2 + 1;
    pcVar3 = pcVar3 + 1;
  } while (bVar4);
  if (!bVar4) {
    iVar1 = 6;
    pcVar2 = name;
    pcVar3 = "drill";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *pcVar2 == *pcVar3;
      pcVar2 = pcVar2 + 1;
      pcVar3 = pcVar3 + 1;
    } while (bVar4);
    if (!bVar4) {
      if (incolor == 0) {
        *(undefined *)((int)&gc[3].nothing_interesting_here + 2) = 0;
        *(undefined *)((int)&gc[3].nothing_interesting_here + 1) = 0;
        *(undefined *)&gc[3].nothing_interesting_here = 0;
        gc[4].nothing_interesting_here = 0;
        return;
      }
      sscanf(name + 1,"%02x%02x%02x");
      *(undefined *)&gc[3].nothing_interesting_here = local_20;
      *(undefined *)((int)&gc[3].nothing_interesting_here + 1) = local_24;
      gc[4].nothing_interesting_here = 0;
      *(undefined *)((int)&gc[3].nothing_interesting_here + 2) = local_28;
      return;
    }
  }
  *(undefined *)((int)&gc[3].nothing_interesting_here + 2) = 0xff;
  *(undefined *)((int)&gc[3].nothing_interesting_here + 1) = 0xff;
  *(undefined *)&gc[3].nothing_interesting_here = 0xff;
  gc[4].nothing_interesting_here = 1;
  return;
}



void ps_destroy_gc(hidGC gc)

{
  free(gc);
  return;
}



hidGC ps_make_gc(void)

{
  hidGC phVar1;
  
  phVar1 = (hidGC)calloc(1,0x18);
  phVar1->nothing_interesting_here = 0x816b100;
  phVar1[1].nothing_interesting_here = 0;
  return phVar1;
}



int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int iVar1;
  int iVar2;
  int iVar3;
  
  Layer = *(Cardinal *)va;
  Layer_00 = *(Cardinal *)vb;
  iVar1 = PCB->Data->LayerN;
  iVar3 = iVar1 + 1;
  if (((int)Layer_00 < 0) || (iVar3 < (int)Layer_00)) {
    iVar2 = iVar1 + 3 + Layer_00;
  }
  else {
    iVar2 = GetLayerGroupNumberByNumber(Layer_00);
    iVar1 = PCB->Data->LayerN;
    iVar3 = iVar1 + 1;
  }
  if ((iVar3 < (int)Layer) || ((int)Layer < 0)) {
    iVar3 = iVar1 + 3 + Layer;
  }
  else {
    iVar3 = GetLayerGroupNumberByNumber(Layer);
  }
  iVar1 = iVar2 - iVar3;
  if (iVar2 - iVar3 == 0) {
    iVar1 = Layer_00 - Layer;
  }
  return iVar1;
}



FILE * __regparm3 psopen(char *base,char *which)

{
  size_t sVar1;
  size_t sVar2;
  char *__dest;
  char *pcVar3;
  char *pcVar4;
  FILE *pFVar5;
  
  if (multi_file == 0) {
    pFVar5 = (FILE *)fopen(base,"w");
  }
  else {
    sVar1 = strlen(base);
    sVar2 = strlen(which);
    __dest = (char *)calloc(1,sVar1 + 5 + sVar2);
    pcVar3 = strrchr(base,0x2e);
    if (pcVar3 == (char *)0x0) {
      __sprintf_chk(__dest,1,0xffffffff,"%s.%s.ps",base,which);
    }
    else {
      strcpy(__dest,base);
      pcVar4 = strrchr(__dest,0x2e);
      __sprintf_chk(pcVar4,1,0xffffffff,".%s.%s",which,pcVar3 + 1);
    }
    __printf_chk(1,"PS: open %s\n",__dest);
    pFVar5 = (FILE *)fopen(__dest,"w");
    free(__dest);
  }
  return pFVar5;
}



// WARNING: Type propagation algorithm not settling

int ps_set_layer(char *name,int group,int empty)

{
  uint idx;
  ulonglong uVar1;
  char *which;
  int iVar2;
  int iVar3;
  uint uVar4;
  char *pcVar5;
  bool bVar6;
  byte bVar7;
  undefined8 local_60;
  double local_58;
  double dVar8;
  double dVar9;
  ulonglong uVar10;
  undefined4 uVar11;
  double dVar12;
  double local_34;
  
  uVar11 = (undefined4)((ulonglong)local_60 >> 0x20);
  bVar7 = 0;
  idx = group;
  if ((-1 < group) && (group < PCB->Data->LayerN)) {
    idx = (PCB->LayerGroups).Entries[group * 0x12];
  }
  if (name == (char *)0x0) {
    name = *(char **)(&PCB->Data->field_0x4c + idx * 0x5c);
  }
  if ((empty != 0) ||
     (((bVar6 = idx == 0, -1 < (int)idx &&
       (uVar4 = PCB->Data->LayerN, bVar6 = idx == uVar4, (int)idx < (int)uVar4)) &&
      (bVar6 = print_layer[idx] == 0, bVar6)))) {
    return 0;
  }
  iVar3 = 10;
  which = name;
  pcVar5 = "invisible";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *which == *pcVar5;
    which = which + 1;
    pcVar5 = pcVar5 + 1;
  } while (bVar6);
  if (bVar6) {
    return 0;
  }
  if ((int)idx < 0) {
    uVar4 = idx & 0xf0;
    if ((uVar4 == 0x40) || (uVar4 == 0x30)) {
      is_drill = 1;
    }
    else {
      is_drill = 0;
    }
    if (uVar4 == 0x20) {
      is_mask = 1;
      is_assy = 0;
      is_copper = 0;
      goto LAB_0811680e;
    }
    is_mask = 0;
    if (uVar4 == 0x80) {
      is_assy = 1;
      is_copper = 0;
      goto LAB_0811680e;
    }
    is_copper = ZEXT14(uVar4 == 0);
    is_paste = 1;
    is_assy = 0;
    if (uVar4 != 0x50) goto LAB_0811680e;
  }
  else {
    is_drill = 0;
    is_mask = 0;
    is_assy = 0;
    is_copper = 1;
LAB_0811680e:
    is_paste = 0;
  }
  if (doing_toc != 0) {
    if ((group < 0) || (group != lastgroup)) {
      lastgroup = group;
      pagecount = pagecount + 1;
      __fprintf_chk(f,1,"(%d.) tocp\n",pagecount);
    }
    __fprintf_chk(f,1,"(%s) toc\n",name);
    return 0;
  }
  if ((-1 < group) && (group == lastgroup)) goto LAB_08116c63;
  lastgroup = group;
  iVar3 = pagecount;
  if ((f != (FILE *)0x0) && (iVar3 = 0, pagecount != 0)) {
    __fprintf_chk(f,1,"showpage\n");
    iVar3 = pagecount;
  }
  pagecount = iVar3 + 1;
  if (multi_file != 0) {
    if (f != (FILE *)0x0) {
      fclose((FILE *)f);
    }
    which = layer_type_to_file_name(idx);
    f = psopen(filename,which);
    if (f == (FILE *)0x0) {
      perror(filename);
      return 0;
    }
    ps_start_file(f);
  }
  local_58 = (double)CONCAT44(uVar11,pagecount);
  __fprintf_chk(f,1,"%%%%Page: %d\n",pagecount);
  uVar4 = (uint)(mirror != 0);
  if (automirror != 0) {
    if ((int)idx < 0) {
      if ((idx & 0xf) == 2) goto LAB_08116904;
    }
    else {
      iVar3 = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
      if (iVar3 == group) {
LAB_08116904:
        uVar4 = 1 - uVar4;
      }
    }
  }
  __fprintf_chk(f,1,"/Helvetica findfont 10 scalefont setfont\n",local_58);
  if (legend != 0) {
    uVar11 = (undefined4)((ulonglong)local_58 >> 0x20);
    __fprintf_chk(f,1,"30 30 moveto (%s) show\n",PCB->Filename,uVar11);
    if (PCB->Name == (char *)0x0) {
      which = layer_type_to_file_name(idx);
      local_58 = (double)CONCAT44(uVar11,which);
      __fprintf_chk(f,1,"30 41 moveto (%s) show\n",which,uVar11);
    }
    else {
      which = layer_type_to_file_name(idx);
      local_58 = (double)CONCAT44(which,PCB->Name);
      __fprintf_chk(f,1,"30 41 moveto (%s, %s) show\n",PCB->Name,which);
    }
    if (uVar4 != 0) {
      __fprintf_chk(f,1,"( \\(mirrored\\)) show\n",local_58);
    }
    if (fillpage == 0) {
      local_58 = scale_value;
      __fprintf_chk(f,1,"(, scale = 1:%.3f) show\n",scale_value);
    }
    else {
      __fprintf_chk(f,1,"(, not to scale) show\n",local_58);
    }
  }
  __fprintf_chk(f,1,"newpath\n",local_58);
  local_58 = (double)((float)media_height * 0.50000000);
  dVar8 = (double)((float)media_width * 0.50000000);
  __fprintf_chk(f,1,"72 72 scale %g %g translate\n",dVar8,local_58);
  dVar12 = calibration_y;
  dVar9 = calibration_x;
  local_34 = media_height;
  if (PCB->MaxHeight < PCB->MaxWidth) {
    __fprintf_chk(f,1,0x815e986,dVar8,local_58);
    dVar12 = calibration_x;
    dVar9 = calibration_y;
    local_34 = media_width;
  }
  local_34 = local_34 * 0.50000000;
  __fprintf_chk(f,1,"%g %g scale %% calibration\n",dVar9,dVar12);
  if (uVar4 != 0) {
    __fprintf_chk(f,1,"1 -1 scale\n",dVar9,dVar12);
  }
  if (((int)idx < 0) && ((idx & 0xf0) == 0x70)) {
    __fprintf_chk(f,1,"0.00001 dup neg scale\n",dVar9,dVar12);
    __fprintf_chk(f,1,"%d %d translate\n",-(PCB->MaxWidth / 2),-(PCB->MaxHeight / 2));
LAB_08116f2d:
    iVar2 = (int)ROUND((local_34 - 0.50000000) * 100000.00000000) - PCB->MaxHeight / 2;
    iVar3 = PrintFab_overhang();
    uVar10 = CONCAT44(iVar3,iVar2);
    __fprintf_chk(f,1,"%% PrintFab overhang natural %d, needed %d\n",iVar2,iVar3);
    if (iVar2 < iVar3) {
      uVar1 = uVar10 >> 0x20;
      uVar10 = uVar10 & 0xffffffff00000000 | (ulonglong)(uint)(iVar3 - iVar2);
      __fprintf_chk(f,1,"0 %d translate\n",iVar3 - iVar2,(int)uVar1);
    }
  }
  else {
    __fprintf_chk(f,1,"%g dup neg scale\n",fill_zoom * scale_value,dVar12);
    iVar3 = -(PCB->MaxHeight / 2);
    iVar2 = -(PCB->MaxWidth / 2);
    uVar10 = CONCAT44(iVar3,iVar2);
    __fprintf_chk(f,1,"%d %d translate\n",iVar2,iVar3);
    if (((int)idx < 0) && ((idx & 0xf0) == 0x70)) goto LAB_08116f2d;
  }
  if (invert == 0) {
    __fprintf_chk(f,1,"/gray { setgray } bind def\n",uVar10);
    __fprintf_chk(f,1,"/rgb { setrgbcolor } bind def\n");
  }
  else {
    __fprintf_chk(f,1,"/gray { 1 exch sub setgray } bind def\n",uVar10);
    __fprintf_chk(f,1,"/rgb { 1 1 3 { pop 1 exch sub 3 1 roll } for setrgbcolor } bind def\n");
  }
  if ((outline == 0) || (outline_layer != (LayerTypePtr)0x0)) {
    if (invert != 0) goto LAB_08116b17;
  }
  else {
    if (invert == 0) {
      which = "stroke";
    }
    else {
LAB_08116b17:
      which = "fill";
    }
    iVar3 = PCB->MaxWidth;
    iVar2 = PCB->MaxHeight;
    dVar12 = (double)CONCAT44(iVar3,iVar2);
    uVar10 = CONCAT44(iVar3,iVar2);
    __fprintf_chk(f,1,
                  "0 setgray 0 setlinewidth 0 0 moveto 0 %d lineto %d %d lineto %d 0 lineto closepath %s\n"
                  ,iVar2,iVar3,iVar2,iVar3,which);
  }
  if (align_marks != 0) {
    corner(0,0,-1,-1);
    corner(PCB->MaxWidth,0,1,-1);
    corner(PCB->MaxWidth,PCB->MaxHeight,1,1);
    corner(0,PCB->MaxHeight,-1,1);
  }
  linewidth = -1;
  lastcap = -1;
  lastcolor = -1;
  __fprintf_chk(f,1,"/ts 10000 def\n",uVar10,dVar12);
  __fprintf_chk(f,1,"/ty ts neg def /tx 0 def /Helvetica findfont ts scalefont setfont\n");
  __fprintf_chk(f,1,"/t { moveto lineto stroke } bind def\n");
  __fprintf_chk(f,1,"/r { /y2 exch def /x2 exch def /y1 exch def /x1 exch def\n");
  __fprintf_chk(f,1,
                "     x1 y1 moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto closepath fill } bind def\n"
               );
  __fprintf_chk(f,1,"/c { 0 360 arc fill } bind def\n");
  __fprintf_chk(f,1,
                "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n"
               );
  if (drill_helper != 0) {
    __fprintf_chk(f,1,"/dh { gsave %d setlinewidth 0 gray %d 0 360 arc stroke grestore} bind def\n",
                  400,600);
  }
LAB_08116c63:
  if ((((outline == 0) || (outline_layer == (LayerTypePtr)0x0)) ||
      (outline_layer == (LayerTypePtr)(&PCB->Data->field_0x4c + idx * 0x5c))) ||
     ((bVar6 = idx == 0, (int)idx < 0 && (bVar6 = (idx & 0xf0) == 0, !bVar6)))) {
    return 1;
  }
  iVar3 = 8;
  which = name;
  pcVar5 = "outline";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *which == *pcVar5;
    which = which + (uint)bVar7 * -2 + 1;
    pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
  } while (bVar6);
  if (bVar6) {
    return 1;
  }
  iVar3 = 6;
  which = name;
  pcVar5 = "route";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar6 = *which == *pcVar5;
    which = which + (uint)bVar7 * -2 + 1;
    pcVar5 = pcVar5 + (uint)bVar7 * -2 + 1;
  } while (bVar6);
  if (bVar6) {
    return 1;
  }
  __printf_chk(1,"attempting to draw outlines on %s\n",name);
  DrawLayer(outline_layer,&region);
  return 1;
}



void register_ps_attribute_list(void)

{
  hid_register_attributes((HID_Attribute *)ps_attribute_list,0x12);
  return;
}



void ps_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes((HID_Attribute *)ps_attribute_list,0x12);
  hid_parse_command_line(argc,argv);
  return;
}



HID_Attribute * ps_get_export_options(int *n)

{
  char *last_made_filename;
  
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)ps_attribute_list,".ps",(char **)&ram0x08194b0c);
  }
  if (n != (int *)0x0) {
    *n = 0x12;
  }
  return (HID_Attribute *)ps_attribute_list;
}



void hid_ps_init(void)

{
  apply_default_hid(&ps_hid,(HID *)0x0);
  hid_register_hid(&ps_hid);
  hid_eps_init();
  register_ps_attribute_list();
  register_eps_attribute_list();
  return;
}



void ps_calibrate_1(double xval,double yval,int use_command)

{
  bool bVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  FILE *__stream;
  char *__s;
  HID_Attr_Val vals [3];
  
  if ((xval <= 0.00000000) || (yval <= 0.00000000)) {
    if ((ps_calib_attribute_list[0].default_val.str_value == (char *)0x0) &&
       (ps_calib_attribute_list[0].default_val.str_value = (char *)calloc(1,4),
       (undefined4 *)ps_calib_attribute_list[0].default_val.str_value != (undefined4 *)0x0)) {
      *(undefined4 *)ps_calib_attribute_list[0].default_val.str_value = 0x72706c;
    }
    iVar4 = (*gui->attribute_dialog)
                      ((HID_Attribute *)ps_calib_attribute_list,1,vals,"Print Calibration Page",
                       "Generates a printer calibration page");
    dVar2 = ps_attribute_list[15].default_val.real_value;
    dVar3 = calibration_y;
    if (iVar4 == 0) {
      if ((use_command == 0) && (__s = strchr(vals[0].str_value,0x7c), __s == (char *)0x0)) {
        bVar1 = false;
        __stream = fopen(vals[0].str_value,"w");
      }
      else {
        while ((*vals[0].str_value == '|' || (*vals[0].str_value == ' '))) {
          vals[0].str_value = vals[0].str_value + 1;
        }
        bVar1 = true;
        __stream = popen(vals[0].str_value,"w");
      }
      __s = "%!PS-Adobe\n";
      iVar4 = 0;
      do {
        iVar4 = iVar4 + 1;
        fputs(__s,__stream);
        __s = calib_lines[iVar4];
      } while (__s != (char *)0x0);
      __fprintf_chk(__stream,1,"4 in 0.5 (Y in) cbar\n");
      __fprintf_chk(__stream,1,"20 cm 1.5 (Y cm) cbar\n");
      __fprintf_chk(__stream,1,"10 in 2.5 (Y in) cbar\n");
      __fprintf_chk(__stream,1,"-90 rotate\n");
      __fprintf_chk(__stream,1,"4 in -0.5 (X in) cbar\n");
      __fprintf_chk(__stream,1,"15 cm -1.5 (X cm) cbar\n");
      __fprintf_chk(__stream,1,"7.5 in -2.5 (X in) cbar\n");
      __fprintf_chk(__stream,1,"showpage\n");
      if (bVar1) {
        pclose(__stream);
        return;
      }
      fclose(__stream);
      dVar2 = ps_attribute_list[15].default_val.real_value;
      dVar3 = calibration_y;
    }
  }
  else {
    if ((xval < 3.60000000) || (4.40000000 < xval)) {
      if ((xval < 13.50000000) || (16.50000000 < xval)) {
        if ((xval < 6.75000000) || (8.25000000 < xval)) {
          if (2.00000000 <= xval) {
            Message("X value of %g is too far off.\nExpecting it near: 1.0, 4.0, 15.0, 7.5\n",xval);
          }
          else {
            calibration_x = xval;
            ps_attribute_list[14].default_val.real_value = xval;
          }
        }
        else {
          calibration_x = 7.50000000 / xval;
        }
      }
      else {
        calibration_x = 15.00000000 / xval;
      }
    }
    else {
      calibration_x = 4.00000000 / xval;
    }
    dVar2 = ps_attribute_list[15].default_val.real_value;
    if ((yval < 3.60000000) || (4.40000000 < yval)) {
      if ((yval < 18.00000000) || (22.00000000 < yval)) {
        if ((yval < 9.00000000) || (11.00000000 < yval)) {
          dVar2 = yval;
          dVar3 = yval;
          if (2.00000000 <= yval) {
            Message("Y value of %g is too far off.\nExpecting it near: 1.0, 4.0, 20.0, 10.0\n",yval)
            ;
            dVar2 = ps_attribute_list[15].default_val.real_value;
            dVar3 = calibration_y;
          }
        }
        else {
          dVar3 = 10.00000000 / yval;
        }
      }
      else {
        dVar3 = 20.00000000 / yval;
      }
    }
    else {
      dVar3 = 4.00000000 / yval;
    }
  }
  calibration_y = dVar3;
  ps_attribute_list[15].default_val.real_value = dVar2;
  return;
}



void ps_calibrate(double xval,double yval)

{
  ps_calibrate_1(xval,yval,0);
  return;
}



void ps_hid_export_to_file(FILE *the_file,HID_Attr_Val *options)

{
  int iVar1;
  uchar uVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  uchar uVar7;
  uchar uVar8;
  uchar uVar9;
  uint uVar10;
  int iVar11;
  float fVar12;
  float fVar13;
  double dVar14;
  int saved_layer_stack [16];
  Cardinal *pCVar15;
  int iVar16;
  DataTypePtr *pDVar17;
  PCBTypePtr pPVar18;
  Cardinal Layer;
  Cardinal Layer_00;
  char *pcVar19;
  char *pcVar20;
  int *piVar21;
  char *pcVar22;
  bool bVar23;
  byte bVar24;
  
  pPVar18 = PCB;
  bVar24 = 0;
  uVar2 = (PCB->Flags).t[7];
  uVar3 = (PCB->Flags).t[6];
  uVar4 = (PCB->Flags).t[5];
  uVar5 = (PCB->Flags).t[4];
  uVar6 = (PCB->Flags).t[3];
  uVar7 = (PCB->Flags).t[2];
  uVar8 = (PCB->Flags).t[1];
  uVar9 = (PCB->Flags).t[0];
  uVar10 = (PCB->Flags).f;
  (PCB->Flags).f = uVar10 & 0xfffdbfff;
  f = the_file;
  drill_helper = options[1].int_value;
  align_marks = options[2].int_value;
  outline = options[3].int_value;
  mirror = options[4].int_value;
  fillpage = options[5].int_value;
  fade_ratio = options[0xb].real_value;
  automirror = options[6].int_value;
  incolor = options[7].int_value;
  bloat = options[8].int_value;
  invert = options[9].int_value;
  media = options[10].int_value;
  fVar12 = (float)media_data[media].Width / 100000.00000000;
  media_width = (double)fVar12;
  fVar13 = 100000.00000000 / (float)media_data[media].Height;
  media_height = (double)fVar13;
  fVar12 = ((float)media_data[media].MarginX + (float)media_data[media].MarginX) / -100000.00000000
           + fVar12;
  ps_width = (double)fVar12;
  drillcopper = options[0x10].int_value;
  fVar13 = -100000.00000000 / ((float)media_data[media].MarginY + (float)media_data[media].MarginY)
           + fVar13;
  ps_height = (double)fVar13;
  scale_value = options[0xc].real_value;
  calibration_x = options[0xe].real_value;
  calibration_y = options[0xf].real_value;
  legend = options[0x11].int_value;
  if (fade_ratio < 0.00000000) {
    dVar14 = 0.00000000;
  }
  else {
    dVar14 = 1.00000000;
    if (fade_ratio <= 1.00000000) goto LAB_08117910;
  }
  fade_ratio = dVar14;
LAB_08117910:
  antifade_ratio = 1.00000000 - fade_ratio;
  if (fillpage == 0) {
    fill_zoom = 0.00001000;
  }
  else {
    iVar16 = pPVar18->MaxWidth;
    iVar11 = pPVar18->MaxHeight;
    iVar1 = iVar11;
    if (iVar16 <= iVar11) {
      iVar1 = iVar16;
      iVar16 = iVar11;
    }
    fVar13 = fVar13 / (float)iVar16;
    fVar12 = (float)iVar1 / fVar12;
    if (fVar13 <= fVar12 || fVar12 != fVar13) {
      fVar12 = fVar13;
    }
    fill_zoom = (double)fVar12;
  }
  iVar16 = 0x10;
  piVar21 = print_group;
  while (iVar16 != 0) {
    iVar16 = iVar16 + -1;
    *piVar21 = 0;
    piVar21 = piVar21 + 1;
  }
  outline_layer = (LayerTypePtr)0x0;
  iVar16 = 0x10;
  piVar21 = print_layer;
  while (iVar16 != 0) {
    iVar16 = iVar16 + -1;
    *piVar21 = 0;
    piVar21 = piVar21 + 1;
  }
  pDVar17 = pPVar18->Data;
  Layer_00 = pDVar17->LayerN;
  if (0 < (int)Layer_00) {
    Layer = 0;
    do {
      pCVar15 = &pDVar17->ViaN + Layer * 0x17;
      bVar23 = pCVar15[0x14] == 0;
      if ((((!bVar23) || (bVar23 = pCVar15[0x15] == 0, !bVar23)) ||
          (bVar23 = pCVar15[0x17] == 0, !bVar23)) || (bVar23 = pCVar15[0x16] == 0, !bVar23)) {
        iVar16 = GetLayerGroupNumberByNumber(Layer);
        print_group[iVar16] = 1;
      }
      iVar16 = 8;
      pcVar20 = *(char **)(&pDVar17->field_0x4c + Layer * 0x5c);
      pcVar19 = pcVar20;
      pcVar22 = "outline";
      do {
        if (iVar16 == 0) break;
        iVar16 = iVar16 + -1;
        bVar23 = *pcVar19 == *pcVar22;
        pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
        pcVar22 = pcVar22 + (uint)bVar24 * -2 + 1;
      } while (bVar23);
      if (bVar23) {
LAB_08117a1c:
        __printf_chk(1,"see outline layer\n");
        outline_layer = (LayerTypePtr)(&pDVar17->field_0x4c + Layer * 0x5c);
      }
      else {
        iVar16 = 6;
        pcVar19 = "route";
        do {
          if (iVar16 == 0) break;
          iVar16 = iVar16 + -1;
          bVar23 = *pcVar20 == *pcVar19;
          pcVar20 = pcVar20 + (uint)bVar24 * -2 + 1;
          pcVar19 = pcVar19 + (uint)bVar24 * -2 + 1;
        } while (bVar23);
        if (bVar23) goto LAB_08117a1c;
      }
      Layer = Layer + 1;
      pDVar17 = PCB->Data;
      Layer_00 = pDVar17->LayerN;
    } while ((int)Layer < (int)Layer_00);
  }
  iVar16 = GetLayerGroupNumberByNumber(Layer_00);
  print_group[iVar16] = 1;
  iVar16 = GetLayerGroupNumberByNumber(PCB->Data->LayerN + 1);
  pPVar18 = PCB;
  print_group[iVar16] = 1;
  if (0 < pPVar18->Data->LayerN) {
    Layer_00 = 0;
    do {
      iVar16 = GetLayerGroupNumberByNumber(Layer_00);
      if (print_group[iVar16] != 0) {
        print_layer[Layer_00] = 1;
      }
      Layer_00 = Layer_00 + 1;
      pCVar15 = (Cardinal *)&PCB->Data->LayerN;
      pPVar18 = PCB;
    } while (*pCVar15 != Layer_00 && (int)Layer_00 <= (int)*pCVar15);
  }
  saved_layer_stack[0] = LayerStack[0];
  saved_layer_stack[1] = LayerStack[1];
  saved_layer_stack[2] = LayerStack[2];
  saved_layer_stack[3] = LayerStack[3];
  saved_layer_stack[4] = LayerStack[4];
  saved_layer_stack[5] = LayerStack[5];
  saved_layer_stack[6] = LayerStack[6];
  saved_layer_stack[7] = LayerStack[7];
  saved_layer_stack[8] = LayerStack[8];
  saved_layer_stack[9] = LayerStack[9];
  saved_layer_stack[10] = LayerStack[10];
  saved_layer_stack[11] = LayerStack[11];
  saved_layer_stack[12] = LayerStack[12];
  saved_layer_stack[13] = LayerStack[13];
  saved_layer_stack[14] = LayerStack[14];
  saved_layer_stack[15] = LayerStack[15];
  qsort(LayerStack,pPVar18->Data->LayerN,4,layer_sort);
  region.X1 = 0;
  region.Y1 = 0;
  lastgroup = -1;
  region.X2 = PCB->MaxWidth;
  linewidth = -1;
  lastcap = -1;
  region.Y2 = PCB->MaxHeight;
  lastcolor = -1;
  if (multi_file == 0) {
    pagecount = 1;
    __fprintf_chk(f,1,"%%%%Page: 1\n");
    __fprintf_chk(f,1,"/Times-Roman findfont 24 scalefont setfont\n");
    __fprintf_chk(f,1,"/rightshow { /s exch def s stringwidth pop -1 mul 0 rmoveto s show } def\n");
    __fprintf_chk(f,1,"/y 72 9 mul def /toc { 100 y moveto show /y y 24 sub def } bind def\n");
    __fprintf_chk(f,1,"/tocp { /y y 12 sub def 90 y moveto rightshow } bind def\n");
    doing_toc = 1;
    hid_expose_callback(&ps_hid,&region,(void *)0x0);
  }
  pagecount = 1;
  doing_toc = 0;
  lastgroup = -1;
  hid_expose_callback(&ps_hid,&region,(void *)0x0);
  if (f != (FILE *)0x0) {
    __fprintf_chk(f,1,"showpage\n");
  }
  pPVar18 = PCB;
  LayerStack[0] = saved_layer_stack[0];
  LayerStack[1] = saved_layer_stack[1];
  LayerStack[2] = saved_layer_stack[2];
  LayerStack[3] = saved_layer_stack[3];
  LayerStack[4] = saved_layer_stack[4];
  LayerStack[5] = saved_layer_stack[5];
  LayerStack[6] = saved_layer_stack[6];
  LayerStack[7] = saved_layer_stack[7];
  LayerStack[8] = saved_layer_stack[8];
  LayerStack[9] = saved_layer_stack[9];
  LayerStack[10] = saved_layer_stack[10];
  LayerStack[11] = saved_layer_stack[11];
  LayerStack[12] = saved_layer_stack[12];
  LayerStack[13] = saved_layer_stack[13];
  LayerStack[14] = saved_layer_stack[14];
  LayerStack[15] = saved_layer_stack[15];
  (PCB->Flags).t[7] = uVar2;
  (pPVar18->Flags).t[6] = uVar3;
  (pPVar18->Flags).t[5] = uVar4;
  (pPVar18->Flags).t[4] = uVar5;
  (pPVar18->Flags).t[3] = uVar6;
  (pPVar18->Flags).t[2] = uVar7;
  (pPVar18->Flags).t[1] = uVar8;
  (pPVar18->Flags).t[0] = uVar9;
  (pPVar18->Flags).f = uVar10;
  return;
}



void ps_do_export(HID_Attr_Val *options)

{
  double *pdVar1;
  int iVar2;
  HID_Attr_Val *pHVar3;
  int save_ons [18];
  
  if (options == (HID_Attr_Val *)0x0) {
    ps_get_export_options((int *)0x0);
    pHVar3 = &ps_attribute_list[0].default_val;
    iVar2 = 0;
    do {
      *(int *)((int)&ps_values[0].int_value + iVar2) = pHVar3->int_value;
      *(char **)((int)&ps_values[0].str_value + iVar2) = pHVar3->str_value;
      *(undefined4 *)((int)&ps_values[0].real_value + iVar2) = *(undefined4 *)&pHVar3->real_value;
      pdVar1 = &pHVar3->real_value;
      pHVar3 = pHVar3 + 3;
      *(undefined4 *)((int)&ps_values[0].real_value + iVar2 + 4) = *(undefined4 *)((int)pdVar1 + 4);
      iVar2 = iVar2 + 0x10;
    } while (iVar2 != 0x120);
    options = ps_values;
  }
  filename = "pcb-out.ps";
  if (options->str_value != (char *)0x0) {
    filename = options->str_value;
  }
  multi_file = options[0xd].int_value;
  if (multi_file == 0) {
    f = psopen(filename,"toc");
    if (f == (FILE *)0x0) {
      perror(filename);
      return;
    }
    ps_start_file(f);
  }
  else {
    f = (FILE *)0x0;
  }
  hid_save_and_show_layer_ons(save_ons);
  ps_hid_export_to_file(f,options);
  hid_restore_layer_ons(save_ons);
  multi_file = 0;
  if (f != (FILE *)0x0) {
    fclose((FILE *)f);
  }
  return;
}



void eps_set_line_cap(hidGC gc,EndCapStyle style)

{
  gc->nothing_interesting_here = style;
  return;
}



void eps_set_line_width(hidGC gc,int width)

{
  gc[1].nothing_interesting_here = width;
  return;
}



void eps_set_draw_xor(hidGC gc,int xor)

{
  return;
}



void eps_set_draw_faded(hidGC gc,int faded)

{
  return;
}



void eps_set_crosshair(int x,int y,int action)

{
  return;
}



void hid_eps_init(void)

{
  apply_default_hid(&eps_hid,(HID *)0x0);
  hid_register_hid(&eps_hid);
  return;
}



void eps_calibrate(double xval,double yval)

{
  char "eps_calibrate" [14];
  
  __fprintf_chk(stderr,1,0x815f270,"eps_calibrate");
                    // WARNING: Subroutine does not return
  abort();
}



void __regparm3 use_gc(hidGC gc)

{
  uint uVar1;
  undefined4 uVar2;
  
  if (gc[1].nothing_interesting_here != linewidth) {
    __fprintf_chk(f,1,"%d setlinewidth\n",gc[1].nothing_interesting_here);
    linewidth = gc[1].nothing_interesting_here;
  }
  uVar1 = gc->nothing_interesting_here;
  if (lastcap != uVar1) {
    uVar2 = 2;
    if (uVar1 < 3) {
      uVar2 = *(undefined4 *)(CSWTCH_106 + uVar1 * 4);
    }
    __fprintf_chk(f,1,"%d setlinecap\n",uVar2);
    lastcap = gc->nothing_interesting_here;
  }
  uVar1 = gc[2].nothing_interesting_here;
  if (uVar1 != lastcolor) {
    __fprintf_chk(f,1,"%g %g %g setrgbcolor\n",
                  (double)((float)((int)uVar1 >> 0x10 & 0xff) / 255.00000000),
                  (double)((float)(uVar1 >> 8 & 0xff) / 255.00000000),
                  (double)((float)(uVar1 & 0xff) / 255.00000000));
    lastcolor = gc[2].nothing_interesting_here;
  }
  return;
}



void eps_fill_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1,y1,x2,y2);
  return;
}



void eps_fill_polygon(hidGC gc,int n_coords,int *x,int *y)

{
  int *piVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  
  use_gc(gc);
  if (0 < n_coords) {
    pcVar3 = "moveto";
    iVar4 = 0;
    do {
      piVar1 = y + iVar4;
      piVar2 = x + iVar4;
      iVar4 = iVar4 + 1;
      __fprintf_chk(f,1,0x815f4f4,*piVar2,*piVar1,pcVar3);
      pcVar3 = "lineto";
    } while (iVar4 < n_coords);
  }
  __fprintf_chk();
  return;
}



void eps_fill_circle(hidGC gc,int cx,int cy,int radius)

{
  undefined *puVar1;
  
  use_gc(gc);
  puVar1 = &DAT_0814df8d;
  if (gc[3].nothing_interesting_here != 0) {
    puVar1 = &DAT_081489c6;
  }
  __fprintf_chk(f,1,0x815f4f1,cx,cy,radius,puVar1);
  return;
}



void eps_draw_rect(hidGC gc,int x1,int y1,int x2,int y2)

{
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d r\n",x1,y1,x2,y2);
  return;
}



void eps_draw_arc(hidGC gc,int cx,int cy,int width,int height,int start_angle,int delta_angle)

{
  int iVar1;
  
  if (delta_angle < 1) {
    iVar1 = delta_angle + start_angle;
  }
  else {
    iVar1 = start_angle;
    start_angle = delta_angle + start_angle;
  }
  use_gc(gc);
  __fprintf_chk(f,1,"%d %d %d %d %d %d %g a\n",iVar1,start_angle,-width,height,cx,cy,
                (double)linewidth / (double)width);
  return;
}



void eps_set_line_cap_angle(hidGC gc,int x1,int y1,int x2,int y2)

{
  char "eps_set_line_cap_angle" [23];
  
  __fprintf_chk(stderr,1,0x815f270,"eps_set_line_cap_angle");
                    // WARNING: Subroutine does not return
  abort();
}



void eps_use_mask(int param_1)

{
  int mask_pending;
  
  if (param_1 == 0) {
    if (mask_pending != 0) {
      mask_pending = 0;
      __fprintf_chk(f,1,0x815e749);
      lastcolor = -1;
      return;
    }
  }
  else {
    if ((param_1 == 2) && (mask_pending == 0)) {
      mask_pending = 1;
      __fprintf_chk(f,1,"gsave\n");
      return;
    }
  }
  return;
}



void eps_draw_line(hidGC gc,int x1,int y1,int x2,int y2)

{
  float fVar1;
  float fVar2;
  undefined *puVar3;
  int radius;
  double __x;
  double local_2c;
  double local_24 [2];
  
  radius = gc[1].nothing_interesting_here / 2;
  if ((y1 == y2) && (x1 == x2)) {
    if (gc->nothing_interesting_here != 1) {
      eps_fill_circle(gc,x1,y1,radius);
      return;
    }
    eps_fill_rect(gc,x1 - radius,y1 - radius,radius + x1,radius + y1);
    return;
  }
  use_gc(gc);
  puVar3 = &DAT_081515af;
  if ((gc[3].nothing_interesting_here != 0) &&
     (puVar3 = &DAT_0815f4eb, gc->nothing_interesting_here != 1)) {
    __x = atan2((double)(y2 - y1),(double)(x2 - x1));
    sincos(__x,local_24,&local_2c);
    __x = (__x * 180.00000000) / 3.14159265;
    __fprintf_chk(f,1,"%d %d moveto ",(int)ROUND((double)radius * local_24[0] + (double)x1),
                  (int)ROUND((double)-radius * local_2c + (double)y1));
    fVar2 = (float)__x;
    fVar1 = fVar2 + 90.00000000;
    __fprintf_chk(f,1,"%d %d %d %g %g arc\n",x2,y2,radius,(double)(fVar2 - 90.00000000),
                  (double)fVar1);
    __fprintf_chk(f,1,"%d %d %d %g %g arc\n",x1,y1,radius,(double)fVar1,__x + 270.00000000);
    __fprintf_chk();
    return;
  }
  __fprintf_chk(f,1,"%d %d %d %d %s\n",x1,y1,x2,y2,puVar3);
  return;
}



int eps_set_layer(char *name,int group,int empty)

{
  Cardinal CVar1;
  int iVar2;
  uint uVar3;
  Cardinal CVar4;
  char *pcVar5;
  undefined4 uVar6;
  char *pcVar7;
  bool bVar8;
  
  if ((group < 0) || (PCB->Data->LayerN <= group)) {
    CVar4 = group;
    if (name != (char *)0x0) goto LAB_08118678;
LAB_08118795:
    name = *(char **)(&PCB->Data->field_0x4c + CVar4 * 0x5c);
    if ((int)CVar4 < 0) goto LAB_081187b8;
LAB_08118680:
    CVar1 = PCB->Data->LayerN;
    bVar8 = CVar4 == CVar1;
    if ((int)CVar1 <= (int)CVar4) goto LAB_081186a0;
    bVar8 = print_layer[CVar4] == 0;
  }
  else {
    CVar4 = (PCB->LayerGroups).Entries[group * 0x12];
    if (name == (char *)0x0) goto LAB_08118795;
LAB_08118678:
    if (-1 < (int)CVar4) goto LAB_08118680;
LAB_081187b8:
    if ((CVar4 & 0xf0) == 0x70) {
      return 0;
    }
    bVar8 = (CVar4 & 0xf0) == 0x80;
  }
  if (bVar8) {
    return 0;
  }
LAB_081186a0:
  iVar2 = 10;
  pcVar5 = name;
  pcVar7 = "invisible";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar8 = *pcVar5 == *pcVar7;
    pcVar5 = pcVar5 + 1;
    pcVar7 = pcVar7 + 1;
  } while (bVar8);
  if (!bVar8) {
    if ((int)CVar4 < 0) {
      uVar3 = CVar4 & 0xf0;
      if ((uVar3 == 0x40) || (uVar3 == 0x30)) {
        is_drill = 1;
        uVar6 = 1;
      }
      else {
        is_drill = 0;
        uVar6 = 0;
      }
      if (uVar3 == 0x20) {
        is_mask = 1;
        bVar8 = true;
      }
      else {
        is_mask = 0;
        if (uVar3 == 0x50) {
          is_mask = 0;
          is_paste = 1;
          return 0;
        }
        bVar8 = false;
      }
    }
    else {
      is_drill = 0;
      bVar8 = false;
      uVar6 = 0;
      is_mask = 0;
    }
    is_paste = 0;
    if (!bVar8) {
      __fprintf_chk(f,1,"%% Layer %s group %d drill %d mask %d\n",name,group,uVar6,0);
      if (as_shown == 0) {
        if (CVar4 + 0xfef < 2) {
          return *(int *)((int)&CSWTCH_109 + (CVar4 + 0xfef) * 4);
        }
      }
      else {
        if (CVar4 + 0xfef < 2) {
          if ((bool)(((byte)(CVar4 >> 1) ^ 1) & 1) == (Settings.ShowSolderSide != '\0')) {
            return 0;
          }
          return (int)PCB->ElementOn;
        }
      }
      return 1;
    }
  }
  return 0;
}



void eps_set_color(hidGC gc,char *name)

{
  void *cache;
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  bool bVar4;
  int local_2c;
  int local_28;
  int local_24;
  int cval;
  
  iVar1 = 6;
  bVar4 = (undefined *)register0x00000010 == (undefined *)0x5c;
  pcVar2 = name;
  pcVar3 = "erase";
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *pcVar2 == *pcVar3;
    pcVar2 = pcVar2 + 1;
    pcVar3 = pcVar3 + 1;
  } while (bVar4);
  if (bVar4) {
    bVar4 = fast_erase == 0;
    gc[2].nothing_interesting_here = 0xffffff;
    gc[3].nothing_interesting_here = (uint)bVar4;
  }
  else {
    iVar1 = 6;
    pcVar2 = name;
    pcVar3 = "drill";
    do {
      if (iVar1 == 0) break;
      iVar1 = iVar1 + -1;
      bVar4 = *pcVar2 == *pcVar3;
      pcVar2 = pcVar2 + 1;
      pcVar3 = pcVar3 + 1;
    } while (bVar4);
    if (bVar4) {
      gc[2].nothing_interesting_here = 0xffffff;
      gc[3].nothing_interesting_here = 0;
    }
    else {
      gc[3].nothing_interesting_here = 0;
      iVar1 = hid_cache_color(0,name,&cval,(void **)&ram0x08194da4);
      if (iVar1 == 0) {
        if ((in_mono == 0) && (*name == '#')) {
          sscanf(name + 1,"%2x%2x%2x");
          gc[2].nothing_interesting_here = local_24 * 0x10000 + local_28 * 0x100 + local_2c;
        }
        else {
          gc[2].nothing_interesting_here = 0;
        }
      }
      else {
        gc[2].nothing_interesting_here = cval;
      }
    }
  }
  return;
}



void eps_destroy_gc(hidGC gc)

{
  free(gc);
  return;
}



hidGC eps_make_gc(void)

{
  hidGC phVar1;
  
  phVar1 = (hidGC)calloc(1,0x10);
  phVar1->nothing_interesting_here = 0;
  phVar1[1].nothing_interesting_here = 0;
  phVar1[2].nothing_interesting_here = 0;
  return phVar1;
}



void register_eps_attribute_list(void)

{
  hid_register_attributes((HID_Attribute *)eps_attribute_list,5);
  return;
}



void eps_parse_arguments(int *argc,char ***argv)

{
  hid_register_attributes((HID_Attribute *)eps_attribute_list,5);
  hid_parse_command_line(argc,argv);
  return;
}



HID_Attribute * eps_get_export_options(int *n)

{
  char *last_made_filename;
  
  if (PCB != (PCBTypePtr)0x0) {
    derive_default_filename
              (PCB->Filename,(HID_Attribute *)eps_attribute_list,".eps",(char **)&ram0x08194dac);
  }
  if (n != (int *)0x0) {
    *n = 5;
  }
  return (HID_Attribute *)eps_attribute_list;
}



int layer_sort(void *va,void *vb)

{
  Cardinal Layer;
  Cardinal Layer_00;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  Layer = *(Cardinal *)va;
  Layer_00 = *(Cardinal *)vb;
  iVar4 = PCB->Data->LayerN;
  iVar1 = iVar4 + 1;
  if (((int)Layer < 0) || (iVar1 < (int)Layer)) {
    iVar2 = iVar4 + 3 + Layer;
  }
  else {
    iVar2 = GetLayerGroupNumberByNumber(Layer);
    iVar4 = PCB->Data->LayerN;
    iVar1 = iVar4 + 1;
  }
  if ((iVar1 < (int)Layer_00) || ((int)Layer_00 < 0)) {
    iVar1 = iVar4 + 3 + Layer_00;
  }
  else {
    iVar1 = GetLayerGroupNumberByNumber(Layer_00);
  }
  if ((-1 < (int)Layer) && ((int)Layer <= PCB->Data->LayerN + 1)) {
    iVar4 = 0;
    if (solder_layer != iVar2) {
      iVar4 = (uint)(comp_layer == iVar2) + 1;
    }
    iVar3 = 0;
    if (solder_layer != iVar1) {
      iVar3 = (uint)(comp_layer == iVar1) + 1;
    }
    if (iVar4 != iVar3) {
      return iVar3 - iVar4;
    }
  }
  iVar4 = iVar1 - iVar2;
  if (iVar1 - iVar2 == 0) {
    iVar4 = Layer_00 - Layer;
  }
  return iVar4;
}



void eps_hid_export_to_file(FILE *the_file,HID_Attr_Val *options)

{
  Cardinal *pCVar1;
  uchar uVar2;
  uchar uVar3;
  uchar uVar4;
  uchar uVar5;
  uchar uVar6;
  uchar uVar7;
  uchar uVar8;
  uchar uVar9;
  uint uVar10;
  int saved_layer_stack [16];
  DataTypePtr *pDVar11;
  int iVar12;
  int iVar13;
  PCBTypePtr pPVar14;
  int iVar15;
  int iVar16;
  Cardinal Layer;
  int *piVar17;
  byte bVar18;
  BoxType region;
  
  pPVar14 = PCB;
  bVar18 = 0;
  uVar2 = (PCB->Flags).t[7];
  uVar3 = (PCB->Flags).t[6];
  uVar4 = (PCB->Flags).t[5];
  uVar5 = (PCB->Flags).t[4];
  uVar6 = (PCB->Flags).t[3];
  uVar7 = (PCB->Flags).t[2];
  uVar8 = (PCB->Flags).t[1];
  uVar9 = (PCB->Flags).t[0];
  region.X1 = 0;
  region.Y1 = 0;
  uVar10 = (PCB->Flags).f;
  (PCB->Flags).f = uVar10 & 0xfffdbfff;
  f = the_file;
  region.X2 = pPVar14->MaxWidth;
  region.Y2 = pPVar14->MaxHeight;
  if (options[4].int_value == 0) {
    bounds = &region;
  }
  else {
    bounds = (BoxType *)GetDataBoundingBox(pPVar14->Data);
    pPVar14 = PCB;
  }
  iVar13 = 0x10;
  piVar17 = print_group;
  while (iVar13 != 0) {
    iVar13 = iVar13 + -1;
    *piVar17 = 0;
    piVar17 = piVar17 + (uint)bVar18 * 0x3ffffffe + 1;
  }
  iVar13 = 0x10;
  piVar17 = print_layer;
  while (iVar13 != 0) {
    iVar13 = iVar13 + -1;
    *piVar17 = 0;
    piVar17 = piVar17 + (uint)bVar18 * 0x3ffffffe + 1;
  }
  pDVar11 = pPVar14->Data;
  iVar13 = pDVar11->LayerN;
  if (iVar13 < 1) {
    fast_erase = 0;
  }
  else {
    Layer = 0;
    do {
      pCVar1 = &pDVar11->ViaN + Layer * 0x17;
      if ((*(char *)(pCVar1 + 0x24) != '\0') &&
         ((((pCVar1[0x14] != 0 || (pCVar1[0x15] != 0)) || (pCVar1[0x17] != 0)) ||
          (pCVar1[0x16] != 0)))) {
        iVar13 = GetLayerGroupNumberByNumber(Layer);
        pPVar14 = PCB;
        print_group[iVar13] = 1;
      }
      pDVar11 = pPVar14->Data;
      Layer = Layer + 1;
      iVar13 = pDVar11->LayerN;
    } while ((int)Layer < iVar13);
    fast_erase = 0;
    if (0 < iVar13) {
      fast_erase = 0;
      iVar12 = 0;
      while( true ) {
        if (print_group[iVar12] != 0) {
          fast_erase = fast_erase + 1;
        }
        if (iVar12 + 1 == iVar13) break;
        iVar12 = iVar12 + 1;
      }
      if (fast_erase != 0) {
        fast_erase = ZEXT14(fast_erase == 1);
        goto LAB_08118ce7;
      }
    }
  }
  iVar13 = GetLayerGroupNumberByNumber(iVar13 + 1);
  pPVar14 = PCB;
  print_group[iVar13] = 1;
  iVar13 = pPVar14->Data->LayerN;
  fast_erase = 1;
LAB_08118ce7:
  if (0 < iVar13) {
    Layer = 0;
    do {
      iVar13 = GetLayerGroupNumberByNumber(Layer);
      if (print_group[iVar13] != 0) {
        print_layer[Layer] = 1;
      }
      Layer = Layer + 1;
      pCVar1 = (Cardinal *)&PCB->Data->LayerN;
      pPVar14 = PCB;
    } while (*pCVar1 != Layer && (int)Layer <= (int)*pCVar1);
  }
  if (fast_erase == 0) {
    eps_hid._12_1_ = eps_hid._12_1_ & 0xf7 | 0x10;
  }
  else {
    eps_hid._12_1_ = eps_hid._12_1_ & 0xef | 8;
  }
  saved_layer_stack[0] = LayerStack[0];
  saved_layer_stack[1] = LayerStack[1];
  saved_layer_stack[2] = LayerStack[2];
  saved_layer_stack[3] = LayerStack[3];
  saved_layer_stack[4] = LayerStack[4];
  saved_layer_stack[5] = LayerStack[5];
  saved_layer_stack[6] = LayerStack[6];
  saved_layer_stack[7] = LayerStack[7];
  saved_layer_stack[8] = LayerStack[8];
  saved_layer_stack[9] = LayerStack[9];
  saved_layer_stack[10] = LayerStack[10];
  saved_layer_stack[11] = LayerStack[11];
  saved_layer_stack[12] = LayerStack[12];
  saved_layer_stack[13] = LayerStack[13];
  saved_layer_stack[14] = LayerStack[14];
  saved_layer_stack[15] = LayerStack[15];
  as_shown = options[2].int_value;
  if (options[2].int_value == 0) {
    comp_layer = GetLayerGroupNumberByNumber(pPVar14->Data->LayerN + 1);
    solder_layer = GetLayerGroupNumberByNumber(PCB->Data->LayerN);
    qsort(LayerStack,PCB->Data->LayerN,4,layer_sort);
  }
  __fprintf_chk(f,1,"%%!PS-Adobe-3.0 EPSF-3.0\n");
  in_mono = options[3].int_value;
  linewidth = -1;
  lastcap = -1;
  lastgroup = -1;
  lastcolor = -1;
  iVar13 = (int)ROUND(((double)(bounds->Y2 - bounds->Y1) / 100000.00000000) * 72.00000000 *
                      options[1].real_value + 1.00000000);
  __fprintf_chk(f,1,"%%%%BoundingBox: 0 0 %d %d\n",
                (int)ROUND((100000.00000000 / (double)(bounds->X2 - bounds->X1)) * 72.00000000 *
                           options[1].real_value + 1.00000000),iVar13);
  __fprintf_chk(f,1,"%%%%Pages: 1\n");
  __fprintf_chk(f,1,"save countdictstack mark newpath /showpage {} def /setpagedevice {pop} def\n");
  __fprintf_chk(f,1,"%%%%EndProlog\n");
  __fprintf_chk(f,1,"%%%%Page: 1 1\n");
  __fprintf_chk(f,1,"%%%%BeginDocument: %s\n\n",filename,iVar13);
  __fprintf_chk(f,1,"72 72 scale\n");
  __fprintf_chk(f,1,"0.00001 dup neg scale\n");
  __fprintf_chk(f,1,"%g dup scale\n",options[1].real_value);
  iVar13 = -bounds->Y2;
  __fprintf_chk(f,1,"%d %d translate\n",-bounds->X1,iVar13);
  if ((options[2].int_value != 0) && (Settings.ShowSolderSide != '\0')) {
    __fprintf_chk(f,1,"-1 1 scale %d 0 translate\n",bounds->X1 - bounds->X2,iVar13);
  }
  linewidth = -1;
  lastcap = -1;
  lastcolor = -1;
  iVar16 = bounds->X2 + 1000;
  iVar12 = bounds->Y2 + 1000;
  iVar15 = bounds->Y1 + -1000;
  iVar13 = bounds->X1 + -1000;
  __fprintf_chk(f,1,
                "/nclip { %d %d moveto %d %d lineto %d %d lineto %d %d lineto %d %d lineto eoclip newpath } def\n"
                ,iVar13,iVar15,iVar13,iVar12,iVar16,iVar12,iVar16,iVar15,iVar13,iVar15);
  __fprintf_chk(f,1,"/t { moveto lineto stroke } bind def\n");
  __fprintf_chk(f,1,"/tc { moveto lineto strokepath nclip } bind def\n");
  __fprintf_chk(f,1,"/r { /y2 exch def /x2 exch def /y1 exch def /x1 exch def\n");
  __fprintf_chk(f,1,
                "     x1 y1 moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto closepath fill } bind def\n"
               );
  __fprintf_chk(f,1,"/c { 0 360 arc fill } bind def\n");
  __fprintf_chk(f,1,"/cc { 0 360 arc nclip } bind def\n");
  __fprintf_chk(f,1,
                "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n"
               );
  lastgroup = -1;
  hid_expose_callback(&eps_hid,bounds,(void *)0x0);
  __fprintf_chk(f,1,"showpage\n");
  __fprintf_chk(f,1,"%%%%EndDocument\n");
  __fprintf_chk(f,1,"%%%%Trailer\n");
  __fprintf_chk(f,1,"cleartomark countdictstack exch sub { end } repeat restore\n");
  __fprintf_chk(f,1,"%%%%EOF\n");
  pPVar14 = PCB;
  LayerStack[0] = saved_layer_stack[0];
  LayerStack[1] = saved_layer_stack[1];
  LayerStack[2] = saved_layer_stack[2];
  LayerStack[3] = saved_layer_stack[3];
  LayerStack[4] = saved_layer_stack[4];
  LayerStack[5] = saved_layer_stack[5];
  LayerStack[6] = saved_layer_stack[6];
  LayerStack[7] = saved_layer_stack[7];
  LayerStack[8] = saved_layer_stack[8];
  LayerStack[9] = saved_layer_stack[9];
  LayerStack[10] = saved_layer_stack[10];
  LayerStack[11] = saved_layer_stack[11];
  LayerStack[12] = saved_layer_stack[12];
  LayerStack[13] = saved_layer_stack[13];
  LayerStack[14] = saved_layer_stack[14];
  LayerStack[15] = saved_layer_stack[15];
  (PCB->Flags).t[7] = uVar2;
  (pPVar14->Flags).t[6] = uVar3;
  (pPVar14->Flags).t[5] = uVar4;
  (pPVar14->Flags).t[4] = uVar5;
  (pPVar14->Flags).t[3] = uVar6;
  (pPVar14->Flags).t[2] = uVar7;
  (pPVar14->Flags).t[1] = uVar8;
  (pPVar14->Flags).t[0] = uVar9;
  (pPVar14->Flags).f = uVar10;
  return;
}



void eps_do_export(HID_Attr_Val *options)

{
  double *pdVar1;
  int iVar2;
  HID_Attr_Val *pHVar3;
  int save_ons [18];
  
  if (options == (HID_Attr_Val *)0x0) {
    eps_get_export_options((int *)0x0);
    pHVar3 = &eps_attribute_list[0].default_val;
    iVar2 = 0;
    do {
      *(int *)((int)&eps_values[0].int_value + iVar2) = pHVar3->int_value;
      *(char **)((int)&eps_values[0].str_value + iVar2) = pHVar3->str_value;
      *(undefined4 *)((int)&eps_values[0].real_value + iVar2) = *(undefined4 *)&pHVar3->real_value;
      pdVar1 = &pHVar3->real_value;
      pHVar3 = pHVar3 + 3;
      *(undefined4 *)((int)&eps_values[0].real_value + iVar2 + 4) = *(undefined4 *)((int)pdVar1 + 4)
      ;
      iVar2 = iVar2 + 0x10;
    } while (iVar2 != 0x50);
    options = eps_values;
  }
  filename = options->str_value;
  if (filename == (char *)0x0) {
    filename = "pcb-out.eps";
  }
  f = (FILE *)fopen(filename,"w");
  if (f == (FILE *)0x0) {
    perror(filename);
  }
  else {
    if (options[2].int_value == 0) {
      hid_save_and_show_layer_ons(save_ons);
    }
    eps_hid_export_to_file(f,options);
    if (options[2].int_value == 0) {
      hid_restore_layer_ons(save_ons);
    }
    fclose((FILE *)f);
  }
  return;
}



void __regparm3 gts_object_class_init(GtsObjectClass *klass,GtsObjectClass *parent_class)

{
  GtsObjectClassInitFunc *pGVar1;
  
  if (parent_class != (GtsObjectClass *)0x0) {
    gts_object_class_init(klass,(GtsObjectClass *)parent_class->parent_class);
    pGVar1 = (parent_class->info).class_init_func;
    if (pGVar1 != (GtsObjectClassInitFunc *)0x0) {
      (*pGVar1)(klass);
    }
  }
  return;
}



void object_class_init(GtsObjectClass *klass)

{
  klass->clone = object_clone;
  klass->destroy = object_destroy;
  klass->read = (anon_subr_void_GtsObject_ptr_ptr_GtsFile_ptr_for_read *)0x0;
  klass->write = (anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *)0x0;
  klass->color = (anon_subr_GtsColor_GtsObject_ptr_for_color *)0x0;
  klass->attributes = (anon_subr_void_GtsObject_ptr_GtsObject_ptr_for_attributes *)0x0;
  return;
}



void object_init(GtsObject *object)

{
  object->reserved = (gpointer)0x0;
  object->flags = 0;
  return;
}



void gts_finalize(void)

{
  if (class_table != (GHashTable *)0x0) {
    g_hash_table_foreach(class_table,free_class,0);
    g_hash_table_destroy(class_table);
    class_table = (GHashTable *)0x0;
  }
  return;
}



void free_class(gchar *name,GtsObjectClass *klass)

{
  g_free();
  return;
}



void object_destroy(GtsObject *object)

{
  object->klass = (GtsObjectClass *)0x0;
  g_free();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void gts_object_attributes(GtsObject *object,GtsObject *from)

{
  anon_subr_void_GtsObject_ptr_GtsObject_ptr_for_attributes *UNRECOVERED_JUMPTABLE;
  char "gts_object_attributes" [22];
  
  if (object == (GtsObject *)0x0) {
    g_return_if_fail_warning(0,0x815f7d8,0x815f64c);
  }
  else {
    UNRECOVERED_JUMPTABLE = object->klass->attributes;
    if (UNRECOVERED_JUMPTABLE != (anon_subr_void_GtsObject_ptr_GtsObject_ptr_for_attributes *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08119687. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)();
      return;
    }
  }
  return;
}



void gts_object_reset_reserved(GtsObject *object)

{
  char "gts_object_reset_reserved" [26];
  
  if (object != (GtsObject *)0x0) {
    object->reserved = (gpointer)0x0;
    return;
  }
  g_return_if_fail_warning(0,"gts_object_reset_reserved",0x815f64c);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void gts_object_init(GtsObject *object,GtsObjectClass *klass)

{
  GtsObjectInitFunc UNRECOVERED_JUMPTABLE;
  char "gts_object_init" [16];
  
  if (object == (GtsObject *)0x0) {
    g_return_if_fail_warning(0,0x815f83b,0x815f64c);
    return;
  }
  if (klass == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,0x815f83b,"klass != NULL");
  }
  else {
    if ((GtsObjectClass *)klass->parent_class != (GtsObjectClass *)0x0) {
      gts_object_init(object,(GtsObjectClass *)klass->parent_class);
    }
    UNRECOVERED_JUMPTABLE = (klass->info).object_init_func;
    if (UNRECOVERED_JUMPTABLE != (GtsObjectInitFunc)0x0) {
                    // WARNING: Could not recover jumptable at 0x08119730. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)();
      return;
    }
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void gts_object_destroy(GtsObject *object)

{
  char "gts_object_destroy" [19];
  
  if (object->klass->destroy != (anon_subr_void_GtsObject_ptr_for_destroy *)0x0) {
    object->flags = object->flags | 1;
                    // WARNING: Could not recover jumptable at 0x081197aa. Too many branches
                    // WARNING: Treating indirect jump as call
    (*object->klass->destroy)();
    return;
  }
                    // WARNING: Subroutine does not return
  g_assertion_message_expr(0,"../../src/gts/object.c",0x126,0x815f808,"object->klass->destroy");
}



GtsObject * gts_object_clone(GtsObject *object)

{
  GtsObjectClass *pGVar1;
  char "gts_object_clone" [17];
  GtsObject *pGVar2;
  
  if (object == (GtsObject *)0x0) {
    g_return_if_fail_warning(0,"gts_object_clone",0x815f64c);
    return (GtsObject *)0x0;
  }
  if (object->klass->clone != (anon_subr_void_GtsObject_ptr_GtsObject_ptr_for_clone *)0x0) {
    pGVar2 = (GtsObject *)g_malloc0((object->klass->info).object_size);
    pGVar1 = object->klass;
    pGVar2->reserved = (gpointer)0x0;
    pGVar2->flags = 0;
    pGVar2->klass = pGVar1;
    (*object->klass->clone)(pGVar2,object);
    return pGVar2;
  }
  g_return_if_fail_warning(0,0x815f81b,"object->klass->clone");
  return (GtsObject *)0x0;
}



GtsObject * gts_object_new(GtsObjectClass *klass)

{
  char "gts_object_new" [15];
  GtsObject *object;
  
  if (klass != (GtsObjectClass *)0x0) {
    object = (GtsObject *)g_malloc0((klass->info).object_size);
    *(GtsObjectClass **)&object->klass = klass;
    gts_object_init(object,klass);
    return object;
  }
  g_return_if_fail_warning(0,"gts_object_new","klass != NULL");
  return (GtsObject *)0x0;
}



gpointer gts_object_class_check_cast(gpointer klass,gpointer from)

{
  gpointer pvVar1;
  
  if (klass == (gpointer)0x0) {
    g_log(0,0x10,"invalid cast from (NULL) pointer to `%s\'",from);
  }
  else {
    if (from == (gpointer)0x0) {
      g_return_if_fail_warning(0,"gts_object_class_is_from_class","from != NULL");
LAB_08119943:
      g_log(0,0x10,"invalid cast from `%s\' to `%s\'",klass,from);
    }
    else {
      pvVar1 = klass;
      if (from != klass) {
        do {
          pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
          if (pvVar1 == (gpointer)0x0) goto LAB_08119943;
        } while (from != pvVar1);
      }
    }
  }
  return klass;
}



gpointer gts_object_check_cast(gpointer object,gpointer klass)

{
  gpointer pvVar1;
  gpointer pvVar2;
  char *local_34;
  
  if (object == (gpointer)0x0) {
    local_34 = "invalid cast from (NULL) pointer to `%s\'";
  }
  else {
    pvVar2 = *(gpointer *)object;
    if (pvVar2 != (gpointer)0x0) {
      pvVar1 = pvVar2;
      if (klass == (gpointer)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        pvVar2 = *(gpointer *)object;
      }
      else {
        do {
          if (klass == pvVar1) {
            return object;
          }
          pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
        } while (pvVar1 != (gpointer)0x0);
      }
      g_log(0,0x10,"invalid cast from `%s\' to `%s\'",pvVar2,klass);
      return object;
    }
    local_34 = "invalid unclassed pointer in cast to `%s\'";
  }
  g_log(0,0x10,local_34,klass);
  return object;
}



void object_clone(GtsObject *clone,GtsObject *object)

{
  memcpy(clone,object,(object->klass->info).object_size);
  clone->reserved = (gpointer)0x0;
  return;
}



GtsObjectClass * gts_object_class_from_name(gchar *name)

{
  char "gts_object_class_from_name" [27];
  GtsObjectClass *pGVar1;
  
  if (name != (gchar *)0x0) {
    pGVar1 = (GtsObjectClass *)0x0;
    if (class_table != (GHashTable *)0x0) {
      pGVar1 = (GtsObjectClass *)g_hash_table_lookup(class_table,name);
    }
    return pGVar1;
  }
  g_return_if_fail_warning(0,"gts_object_class_from_name","name != NULL");
  return (GtsObjectClass *)0x0;
}



gpointer gts_object_class_new(GtsObjectClass *parent_class,GtsObjectClassInfo *info)

{
  GtsArgGetFunc paVar1;
  char "gts_object_class_new" [21];
  uint uVar2;
  GtsObjectClass *klass;
  
  if (info == (GtsObjectClassInfo *)0x0) {
    g_return_if_fail_warning(0,0x815f89f,"info != NULL");
    return (gpointer)0x0;
  }
  if (parent_class == (GtsObjectClass *)0x0) {
    uVar2 = info->class_size;
  }
  else {
    if (info->object_size < (parent_class->info).object_size) {
      g_return_if_fail_warning
                (0,"gts_object_class_new",
                 "parent_class == NULL || info->object_size >= parent_class->info.object_size");
      return (gpointer)0x0;
    }
    uVar2 = info->class_size;
    if (uVar2 < (parent_class->info).class_size) {
      g_return_if_fail_warning
                (0,0x815f89f,
                 "parent_class == NULL || info->class_size >= parent_class->info.class_size");
      return (gpointer)0x0;
    }
  }
  klass = (GtsObjectClass *)g_malloc0(uVar2);
  *(undefined4 *)(klass->info).name = *(undefined4 *)info->name;
  *(undefined4 *)((klass->info).name + 4) = *(undefined4 *)(info->name + 4);
  *(undefined4 *)((klass->info).name + 8) = *(undefined4 *)(info->name + 8);
  *(undefined4 *)((klass->info).name + 0xc) = *(undefined4 *)(info->name + 0xc);
  *(undefined4 *)((klass->info).name + 0x10) = *(undefined4 *)(info->name + 0x10);
  *(undefined4 *)((klass->info).name + 0x14) = *(undefined4 *)(info->name + 0x14);
  *(undefined4 *)((klass->info).name + 0x18) = *(undefined4 *)(info->name + 0x18);
  *(undefined4 *)((klass->info).name + 0x1c) = *(undefined4 *)(info->name + 0x1c);
  *(undefined4 *)((klass->info).name + 0x20) = *(undefined4 *)(info->name + 0x20);
  *(undefined4 *)((klass->info).name + 0x24) = *(undefined4 *)(info->name + 0x24);
  (klass->info).object_size = info->object_size;
  (klass->info).class_size = info->class_size;
  (klass->info).class_init_func = info->class_init_func;
  (klass->info).object_init_func = info->object_init_func;
  (klass->info).arg_set_func = info->arg_set_func;
  paVar1 = info->arg_get_func;
  *(GtsObjectClass **)&klass->parent_class = parent_class;
  (klass->info).arg_get_func = paVar1;
  gts_object_class_init(klass,klass);
  if (class_table == (GHashTable *)0x0) {
    class_table = (GHashTable *)g_hash_table_new(g_str_hash,g_str_equal);
  }
  g_hash_table_insert(class_table,klass,klass);
  return klass;
}



GtsObjectClass * gts_object_class(void)

{
  GtsObjectClass *klass;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo object_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsObjectClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &object_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    object_info.name._0_4_ = 0x4f737447;
    object_info.name._4_4_ = 0x63656a62;
    object_info.name._8_4_ = 0x74;
    do {
      *(undefined4 *)(&stack0x00000018 + (int)&klass[-1].info) = 0;
      klass = (GtsObjectClass *)((klass->info).name + 4);
    } while (klass < (GtsObjectClass *)&DAT_0000001c);
    object_info.object_size = 0xc;
    object_info.class_size = 0x5c;
    object_info.class_init_func = object_class_init;
    object_info.object_init_func = object_init;
    klass = (GtsObjectClass *)gts_object_class_new((GtsObjectClass *)0x0,&object_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void point_class_init(GtsObjectClass *klass)

{
  klass->read = point_read;
  klass->write = point_write;
  return;
}



gint __regparm3 sortp(gpointer *p,guint n)

{
  gpointer pvVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  gint gVar5;
  uint local_14;
  
  gVar5 = 1;
  uVar2 = n - 1;
  if (uVar2 != 0) {
    local_14 = 0;
    do {
      uVar3 = 0;
      while (uVar4 = uVar3, uVar3 < uVar2 - local_14) {
        while( true ) {
          uVar3 = uVar4 + 1;
          pvVar1 = p[uVar4];
          if (pvVar1 <= p[uVar3]) break;
          gVar5 = -gVar5;
          p[uVar4] = p[uVar3];
          p[uVar3] = pvVar1;
          uVar4 = uVar3;
          if (uVar2 - local_14 <= uVar3) goto LAB_08119d77;
        }
      }
LAB_08119d77:
      local_14 = local_14 + 1;
    } while (local_14 < uVar2);
  }
  return gVar5;
}



void gts_point_transform(GtsPoint *p,GtsMatrix *m)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  char "gts_point_transform" [20];
  
  if ((m != (GtsMatrix *)0x0) && (p != (GtsPoint *)0x0)) {
    dVar1 = (double)p->x;
    dVar2 = (double)p->y;
    dVar3 = (double)p->z;
    dVar4 = (double)(m + 1)[0];
    dVar5 = (double)(m + 1)[1];
    dVar6 = (double)(m + 1)[2];
    dVar7 = (double)(m + 1)[3];
    dVar8 = (double)(m + 2)[0];
    dVar9 = (double)(m + 2)[1];
    dVar10 = (double)(m + 2)[2];
    dVar11 = (double)(m + 2)[3];
    *(double *)&p->x =
         dVar3 * (double)(*m)[2] + dVar2 * (double)(*m)[1] + dVar1 * (double)(*m)[0] +
         (double)(*m)[3];
    *(double *)&p->y = dVar6 * dVar3 + dVar5 * dVar2 + dVar4 * dVar1 + dVar7;
    *(double *)&p->z = dVar10 * dVar3 + dVar9 * dVar2 + dVar8 * dVar1 + dVar11;
    return;
  }
  g_return_if_fail_warning(0,"gts_point_transform","p != NULL && m != NULL");
  return;
}



float10 gts_point_distance2(int p1,int p2)

{
  char "gts_point_distance2" [20];
  float10 fVar1;
  float10 fVar2;
  float10 fVar3;
  
  if ((p2 != 0) && (p1 != 0)) {
    fVar1 = (float10)*(double *)(p1 + 0xc) - (float10)*(double *)(p2 + 0xc);
    fVar2 = (float10)*(double *)(p1 + 0x14) - (float10)*(double *)(p2 + 0x14);
    fVar3 = (float10)*(double *)(p1 + 0x1c) - (float10)*(double *)(p2 + 0x1c);
    return fVar3 * fVar3 + fVar2 * fVar2 + fVar1 * fVar1;
  }
  g_return_if_fail_warning(0,"gts_point_distance2","p1 != NULL && p2 != NULL");
  return (float10)0;
}



float10 gts_point_segment_distance2(int p,int s)

{
  int iVar1;
  int iVar2;
  char "gts_point_segment_distance2" [28];
  float10 fVar3;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  unkbyte10 Var7;
  float10 fVar8;
  
  if (p == 0) {
    g_return_if_fail_warning(0,"gts_point_segment_distance2",0x816106f);
    return (float10)0;
  }
  if (s == 0) {
    g_return_if_fail_warning(0,0x815fc2b,0x815fd1b);
    return (float10)0;
  }
  iVar1 = *(int *)(s + 0xc);
  iVar2 = *(int *)(s + 0x10);
  fVar8 = (float10)gts_point_distance2(iVar1,iVar2);
  if (fVar8 != (float10)0) {
    fVar3 = (float10)*(double *)(iVar1 + 0xc);
    fVar4 = (float10)*(double *)(iVar1 + 0x14);
    fVar5 = (float10)*(double *)(iVar1 + 0x1c);
    fVar8 = fVar8 / (((float10)*(double *)(p + 0x1c) - fVar5) *
                     ((float10)*(double *)(iVar2 + 0x1c) - fVar5) +
                    ((float10)*(double *)(p + 0x14) - fVar4) *
                    ((float10)*(double *)(iVar2 + 0x14) - fVar4) +
                    ((float10)*(double *)(p + 0xc) - fVar3) *
                    ((float10)*(double *)(iVar2 + 0xc) - fVar3));
    if ((float10)1 < fVar8) {
      Var7 = gts_point_distance2();
      return (float10)Var7;
    }
    if ((float10)0 <= fVar8) {
      fVar6 = (float10)1 - fVar8;
      fVar3 = ((float10)*(double *)(iVar2 + 0xc) * fVar8 + fVar3 * fVar6) -
              (float10)*(double *)(p + 0xc);
      fVar4 = ((float10)*(double *)(iVar2 + 0x14) * fVar8 + fVar4 * fVar6) -
              (float10)*(double *)(p + 0x14);
      fVar8 = (fVar8 * (float10)*(double *)(iVar2 + 0x1c) + fVar6 * fVar5) -
              (float10)*(double *)(p + 0x1c);
      return fVar8 * fVar8 + fVar4 * fVar4 + fVar3 * fVar3;
    }
  }
  Var7 = gts_point_distance2();
  return (float10)Var7;
}



void gts_point_set(GtsPoint *p,gdouble x,gdouble y,gdouble z)

{
  if (p != (GtsPoint *)0x0) {
    p->x = x;
    p->y = y;
    p->z = z;
    return;
  }
  g_return_if_fail_warning();
  return;
}



void gts_point_segment_closest(GtsPoint *p,GtsSegment *s,GtsPoint *closest)

{
  double x;
  double x_00;
  double y;
  double y_00;
  double z;
  double z_00;
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  float10 fVar3;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  float10 fVar7;
  
  if (((p == (GtsPoint *)0x0) || (s == (GtsSegment *)0x0)) || (closest == (GtsPoint *)0x0)) {
    g_return_if_fail_warning();
    return;
  }
  pGVar1 = s->v1;
  pGVar2 = s->v2;
  fVar7 = (float10)gts_point_distance2(pGVar1,pGVar2);
  if (fVar7 == (float10)0) {
    gts_point_set(closest,(pGVar1->p).x,(pGVar1->p).y,(pGVar1->p).z);
    return;
  }
  x = (double)(pGVar2->p).x;
  x_00 = (double)(pGVar1->p).x;
  fVar3 = (float10)x_00;
  y = (double)(pGVar2->p).y;
  y_00 = (double)(pGVar1->p).y;
  fVar4 = (float10)y_00;
  z = (double)(pGVar2->p).z;
  z_00 = (double)(pGVar1->p).z;
  fVar5 = (float10)z_00;
  fVar7 = fVar7 / (((float10)(double)p->z - fVar5) * ((float10)z - fVar5) +
                  ((float10)(double)p->y - fVar4) * ((float10)y - fVar4) +
                  ((float10)(double)p->x - fVar3) * ((float10)x - fVar3));
  if ((float10)1 < fVar7) {
    gts_point_set(closest,(gdouble)x,(gdouble)y,(gdouble)z);
    return;
  }
  if ((float10)0 <= fVar7) {
    fVar6 = (float10)1 - fVar7;
    gts_point_set(closest,(gdouble)(double)(fVar7 * (float10)x + fVar3 * fVar6),
                  (gdouble)(double)((float10)y * fVar7 + fVar4 * fVar6),
                  (gdouble)(double)((float10)z * fVar7 + fVar5 * fVar6));
    return;
  }
  gts_point_set(closest,(gdouble)x_00,(gdouble)y_00,(gdouble)z_00);
  return;
}



gint gts_point_orientation_sos(GtsPoint *p1,GtsPoint *p2,GtsPoint *p3)

{
  char "gts_point_orientation_sos" [26];
  int iVar1;
  gint gVar2;
  double dVar3;
  GtsPoint *p [3];
  
  if (((p2 == (GtsPoint *)0x0) || (p1 == (GtsPoint *)0x0)) || (p3 == (GtsPoint *)0x0)) {
    g_return_if_fail_warning(0,"gts_point_orientation_sos","p1 != NULL && p2 != NULL && p3 != NULL")
    ;
    iVar1 = 0;
  }
  else {
    dVar3 = orient2d((double *)&p1->x,(double *)&p2->x,(double *)&p3->x);
    if (dVar3 == 0.00000000) {
      p[1] = p2;
      iVar1 = -1;
      p[0] = p1;
      p[2] = p3;
      gVar2 = sortp(p,3);
      dVar3 = (double)p[2]->x;
      if ((dVar3 < (double)p[1]->x) || (iVar1 = 1, (double)p[1]->x < dVar3)) {
        iVar1 = gVar2 * iVar1;
      }
      else {
        iVar1 = 1;
        if (((double)p[1]->y <= (double)p[2]->y) && (iVar1 = -1, (double)p[2]->y <= (double)p[1]->y)
           ) {
          iVar1 = 1;
          if (((double)p[0]->x <= dVar3) && (iVar1 = -1, dVar3 <= (double)p[0]->x)) {
            return gVar2;
          }
        }
        iVar1 = gVar2 * iVar1;
      }
    }
    else {
      iVar1 = (uint)(0.00000000 < dVar3) * 2 + -1;
    }
  }
  return iVar1;
}



float10 gts_point_orientation(int param_1,int param_2,int param_3)

{
  char "gts_point_orientation" [22];
  double dVar1;
  
  if (((param_2 != 0) && (param_1 != 0)) && (param_3 != 0)) {
    dVar1 = orient2d((double *)(param_1 + 0xc),(double *)(param_2 + 0xc),(double *)(param_3 + 0xc));
    return (float10)dVar1;
  }
  g_return_if_fail_warning(0,"gts_point_orientation","p1 != NULL && p2 != NULL && p3 != NULL");
  return (float10)0;
}



gint gts_point_orientation_3d_sos(GtsPoint *p1,GtsPoint *p2,GtsPoint *p3,GtsPoint *p4)

{
  bool bVar1;
  char "gts_point_orientation_3d_sos" [29];
  gint gVar2;
  int iVar3;
  double dVar4;
  gdouble c [2];
  gdouble b [2];
  gdouble a [2];
  GtsPoint *p [4];
  
  if ((((p2 == (GtsPoint *)0x0) || (p1 == (GtsPoint *)0x0)) || (p4 == (GtsPoint *)0x0)) ||
     (p3 == (GtsPoint *)0x0)) {
    g_return_if_fail_warning
              (0,"gts_point_orientation_3d_sos",
               "p1 != NULL && p2 != NULL && p3 != NULL && p4 != NULL");
    return 0;
  }
  dVar4 = orient3d((double *)&p1->x,(double *)&p2->x,(double *)&p3->x,(double *)&p4->x);
  if (dVar4 != 0.00000000) {
    return (uint)(0.00000000 < dVar4) * 2 + -1;
  }
  p[2] = p3;
  p[0] = p1;
  p[1] = p2;
  p[3] = p4;
  gVar2 = sortp(p,4);
  a[0] = p[1]->x;
  a[1] = p[1]->y;
  b[0] = p[2]->x;
  b[1] = p[2]->y;
  c[0] = p[3]->x;
  c[1] = p[3]->y;
  dVar4 = orient2d((double *)a,(double *)b,(double *)c);
  if (dVar4 == 0.00000000) {
    a[0] = p[1]->x;
    a[1] = p[1]->z;
    b[0] = p[2]->x;
    b[1] = p[2]->z;
    c[0] = p[3]->x;
    c[1] = p[3]->z;
    dVar4 = orient2d((double *)a,(double *)b,(double *)c);
    if (dVar4 != 0.00000000) {
LAB_0811a553:
      bVar1 = dVar4 <= 0.00000000;
      goto LAB_0811a414;
    }
    a[0] = p[1]->y;
    a[1] = p[1]->z;
    b[0] = p[2]->y;
    b[1] = p[2]->z;
    c[0] = p[3]->y;
    c[1] = p[3]->z;
    dVar4 = orient2d((double *)a,(double *)b,(double *)c);
    if (dVar4 == 0.00000000) {
      a[0] = p[0]->x;
      a[1] = p[0]->y;
      b[0] = p[2]->x;
      b[1] = p[2]->y;
      c[0] = p[3]->x;
      c[1] = p[3]->y;
      dVar4 = orient2d((double *)a,(double *)b,(double *)c);
      if (dVar4 != 0.00000000) goto LAB_0811a553;
      b[0] = p[2]->x;
      c[0] = p[3]->x;
      iVar3 = 1;
      if (((double)c[0] < (double)b[0]) || (iVar3 = -1, (double)b[0] < (double)c[0])) {
LAB_0811a802:
        return gVar2 * iVar3;
      }
      iVar3 = -1;
      if (((double)p[3]->y < (double)p[2]->y) || (iVar3 = 1, (double)p[2]->y < (double)p[3]->y))
      goto LAB_0811a802;
      a[0] = p[0]->x;
      a[1] = p[0]->z;
      b[1] = p[2]->z;
      c[1] = p[3]->z;
      dVar4 = orient2d((double *)a,(double *)b,(double *)c);
      if (dVar4 == 0.00000000) {
        b[1] = p[2]->z;
        c[1] = p[3]->z;
        iVar3 = 1;
        if (((double)c[1] < (double)b[1]) || (iVar3 = -1, (double)b[1] < (double)c[1]))
        goto LAB_0811a802;
        a[0] = p[0]->y;
        a[1] = p[0]->z;
        b[0] = p[2]->y;
        c[0] = p[3]->y;
        dVar4 = orient2d((double *)a,(double *)b,(double *)c);
        if (dVar4 != 0.00000000) goto LAB_0811a553;
        a[0] = p[0]->x;
        a[1] = p[0]->y;
        b[0] = p[1]->x;
        b[1] = p[1]->y;
        c[0] = p[3]->x;
        c[1] = p[3]->y;
        dVar4 = orient2d((double *)a,(double *)b,(double *)c);
        if (dVar4 == 0.00000000) {
          iVar3 = -1;
          dVar4 = (double)p[3]->x;
          if ((dVar4 < (double)p[1]->x) || (iVar3 = 1, (double)p[1]->x < dVar4)) {
            return gVar2 * iVar3;
          }
          iVar3 = 1;
          if (((double)p[1]->y <= (double)p[3]->y) &&
             (iVar3 = -1, (double)p[3]->y <= (double)p[1]->y)) {
            iVar3 = 1;
            if (((double)p[0]->x <= dVar4) && (iVar3 = -1, dVar4 <= (double)p[0]->x)) {
              return gVar2;
            }
          }
          return gVar2 * iVar3;
        }
      }
    }
  }
  bVar1 = 0.00000000 < dVar4;
LAB_0811a414:
  return gVar2 * ((uint)bVar1 * 2 + -1);
}



float10 gts_point_orientation_3d(int param_1,int param_2,int param_3,int param_4)

{
  char "gts_point_orientation_3d" [25];
  double dVar1;
  
  if ((((param_2 != 0) && (param_1 != 0)) && (param_4 != 0)) && (param_3 != 0)) {
    dVar1 = orient3d((double *)(param_1 + 0xc),(double *)(param_2 + 0xc),(double *)(param_3 + 0xc),
                     (double *)(param_4 + 0xc));
    return (float10)dVar1;
  }
  g_return_if_fail_warning
            (0,"gts_point_orientation_3d","p1 != NULL && p2 != NULL && p3 != NULL && p4 != NULL");
  return (float10)0;
}



GtsIntersect gts_point_is_in_triangle(GtsPoint *p,GtsTriangle *t)

{
  double dVar1;
  char "gts_point_is_in_triangle" [25];
  float10 fVar2;
  float10 fVar3;
  float10 fVar4;
  float10 fVar5;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if ((t == (GtsTriangle *)0x0) || (p == (GtsPoint *)0x0)) {
    g_return_if_fail_warning(0,"gts_point_is_in_triangle","p != NULL && t != NULL");
    return GTS_ON;
  }
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  fVar2 = (float10)gts_point_orientation(local_10[0],local_14,p);
  if ((float10)0 <= fVar2) {
    dVar1 = (double)(float10)0;
    fVar3 = (float10)gts_point_orientation(local_14,local_18,p);
    if ((float10)dVar1 <= fVar3) {
      fVar4 = (float10)gts_point_orientation(local_18,local_10[0],p);
      fVar5 = (float10)dVar1;
      if (fVar5 <= fVar4) {
        if (((float10)(double)fVar2 != fVar5) && ((float10)(double)fVar3 != fVar5)) {
          return (uint)(fVar5 != fVar4);
        }
        return GTS_ON;
      }
    }
  }
  return GTS_OUT;
}



// WARNING: Removing unreachable block (ram,0x0811ad49)
// WARNING: Removing unreachable block (ram,0x0811ab86)
// WARNING: Removing unreachable block (ram,0x0811ab51)
// WARNING: Removing unreachable block (ram,0x0811aba2)

GtsPoint *
gts_segment_triangle_intersection
          (GtsSegment *s,GtsTriangle *t,gboolean boundary,GtsPointClass *klass)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  GtsVertex *pGVar7;
  char "gts_segment_triangle_intersection" [34];
  GtsPoint *p;
  GtsVertex *pGVar8;
  GtsVertex *pGVar9;
  GtsVertex *pGVar10;
  float10 fVar11;
  float10 fVar12;
  float10 fVar13;
  float10 fVar14;
  undefined8 local_80;
  undefined4 uVar15;
  double local_2c;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_triangle_intersection",0x815fd1b);
    return (GtsPoint *)0x0;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x815fb80,0x815f901);
    return (GtsPoint *)0x0;
  }
  if (klass == (GtsPointClass *)0x0) {
    g_return_if_fail_warning(0,0x815fb80,"klass != NULL");
    return (GtsPoint *)0x0;
  }
  pGVar5 = (t->e1->segment).v1;
  pGVar10 = (t->e2->segment).v1;
  pGVar6 = (t->e1->segment).v2;
  if ((pGVar5 == pGVar10) || (pGVar6 == pGVar10)) {
    pGVar10 = (t->e2->segment).v2;
  }
  pGVar7 = s->v2;
  pGVar9 = s->v1;
  uVar15 = (undefined4)((ulonglong)local_80 >> 0x20);
  fVar11 = (float10)gts_point_orientation_3d(pGVar5,pGVar6,pGVar10,pGVar7);
  local_2c = (double)fVar11;
  fVar11 = (float10)gts_point_orientation_3d(pGVar5,pGVar6,pGVar10,pGVar9,uVar15);
  if (((float10)local_2c < (float10)0) || (pGVar8 = pGVar7, fVar13 = fVar11, (float10)0 < fVar11)) {
    if (fVar11 < (float10)0) {
      return (GtsPoint *)0x0;
    }
    fVar13 = (float10)local_2c;
    if ((float10)0 < fVar13) {
      return (GtsPoint *)0x0;
    }
    local_2c = (double)fVar11;
    pGVar8 = pGVar9;
    pGVar9 = pGVar7;
  }
  fVar11 = (float10)gts_point_orientation_3d(pGVar5,pGVar9,pGVar10,pGVar8,uVar15);
  dVar1 = (double)fVar11;
  if (boundary == 0) {
    if (dVar1 <= 0.00000000) {
      return (GtsPoint *)0x0;
    }
    fVar11 = (float10)gts_point_orientation_3d(pGVar5,pGVar6,pGVar9,pGVar8,uVar15);
    if (fVar11 <= (float10)0.00000000) {
      return (GtsPoint *)0x0;
    }
    fVar12 = (float10)gts_point_orientation_3d(pGVar6,pGVar10,pGVar9,pGVar8,uVar15);
    if (fVar12 <= (float10)0.00000000) {
      return (GtsPoint *)0x0;
    }
  }
  else {
    if (fVar11 < (float10)0) {
      return (GtsPoint *)0x0;
    }
    fVar11 = (float10)gts_point_orientation_3d(pGVar5,pGVar6,pGVar9,pGVar8,uVar15);
    if (fVar11 < (float10)0) {
      return (GtsPoint *)0x0;
    }
    fVar12 = (float10)gts_point_orientation_3d(pGVar6,pGVar10,pGVar9,pGVar8,uVar15);
    if (fVar12 < (float10)0) {
      return (GtsPoint *)0x0;
    }
  }
  fVar14 = (float10)(double)fVar13;
  fVar13 = (float10)0;
  if ((float10)local_2c == fVar13) {
    if (fVar14 == fVar13) {
      return (GtsPoint *)0x0;
    }
    return (GtsPoint *)pGVar8;
  }
  if (fVar14 == fVar13) {
    return (GtsPoint *)pGVar9;
  }
  if (boundary != 0) {
    if ((float10)(double)fVar11 == fVar13) {
      if ((float10)dVar1 == fVar13) {
        return (GtsPoint *)pGVar5;
      }
    }
    else {
      if (fVar12 != fVar13) goto LAB_0811aba8;
      fVar12 = (float10)dVar1;
      pGVar6 = pGVar10;
    }
    if (fVar12 == fVar13) {
      return (GtsPoint *)pGVar6;
    }
  }
LAB_0811aba8:
  dVar1 = (double)((float10)local_2c / ((float10)local_2c - fVar14));
  p = (GtsPoint *)gts_object_new((GtsObjectClass *)klass);
  dVar2 = (double)(pGVar8->p).z;
  dVar3 = (double)(pGVar8->p).y;
  dVar4 = (double)(pGVar8->p).x;
  gts_point_set(p,(gdouble)(dVar4 + ((double)(pGVar9->p).x - dVar4) * dVar1),
                (gdouble)(((double)(pGVar9->p).y - dVar3) * dVar1 + dVar3),
                (gdouble)(((double)(pGVar9->p).z - dVar2) * dVar1 + dVar2));
  return p;
}



GtsPoint * gts_point_new(GtsPointClass *klass,gdouble x,gdouble y,gdouble z)

{
  GtsPoint *pGVar1;
  
  pGVar1 = (GtsPoint *)gts_object_new((GtsObjectClass *)klass);
  pGVar1->x = x;
  pGVar1->y = y;
  pGVar1->z = z;
  return pGVar1;
}



// WARNING: Removing unreachable block (ram,0x0811af33)

float10 gts_point_triangle_distance2(int p,GtsTriangle *t)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  char "gts_point_triangle_distance2" [29];
  float10 fVar9;
  float10 fVar10;
  unkbyte10 Var11;
  float10 fVar12;
  float10 fVar13;
  float10 fVar14;
  float10 fVar15;
  float10 fVar16;
  float10 fVar17;
  GtsEdge *local_24;
  GtsEdge *local_20;
  GtsEdge *local_1c;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if (p == 0) {
    g_return_if_fail_warning(0,"gts_point_triangle_distance2",0x816106f);
    return (float10)0;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x815fbd9,0x815f901);
    return (float10)0;
  }
  gts_triangle_vertices_edges
            (t,(GtsEdge *)0x0,local_10,&local_14,&local_18,&local_1c,&local_20,&local_24);
  fVar9 = (float10)(double)(local_10[0]->p).x;
  fVar10 = (float10)(double)(local_14->p).x - fVar9;
  dVar5 = (double)(local_10[0]->p).y;
  dVar3 = (double)(local_14->p).y - dVar5;
  dVar8 = (double)(local_10[0]->p).z;
  dVar6 = (double)(local_14->p).z - dVar8;
  dVar1 = (double)((float10)(double)(local_18->p).x - fVar9);
  dVar4 = (double)(local_18->p).y - dVar5;
  dVar7 = (double)(local_18->p).z - dVar8;
  fVar12 = (float10)dVar6 * (float10)dVar7 +
           (float10)dVar3 * (float10)dVar4 + (float10)dVar1 * fVar10;
  fVar13 = (float10)dVar6 * (float10)dVar6 + (float10)dVar3 * (float10)dVar3 + fVar10 * fVar10;
  fVar14 = (float10)dVar7 * (float10)dVar7 +
           (float10)dVar4 * (float10)dVar4 + (float10)dVar1 * (float10)dVar1;
  fVar15 = fVar12 * fVar12 - fVar13 * fVar14;
  if (fVar15 == (float10)0) {
    fVar10 = (float10)gts_point_segment_distance2(p,local_1c);
    fVar9 = (float10)gts_point_segment_distance2(p,local_24);
    fVar10 = (float10)(double)fVar10;
    if (fVar10 <= fVar9 || fVar9 != fVar10) {
      fVar9 = fVar10;
    }
    return fVar9;
  }
  dVar2 = (double)(fVar9 - (float10)*(double *)(p + 0xc));
  dVar5 = dVar5 - *(double *)(p + 0x14);
  dVar8 = dVar8 - *(double *)(p + 0x1c);
  fVar16 = (float10)dVar7 * (float10)dVar8 +
           (float10)dVar4 * (float10)dVar5 + (float10)dVar1 * (float10)dVar2;
  fVar17 = (float10)dVar6 * (float10)dVar8 +
           (float10)dVar3 * (float10)dVar5 + (float10)dVar2 * fVar10;
  fVar9 = (fVar14 * fVar17 - fVar16 * fVar12) / fVar15;
  if (fVar9 < (float10)0) {
    Var11 = gts_point_segment_distance2(p,local_24);
    return (float10)Var11;
  }
  fVar15 = fVar15 / (fVar13 * fVar16 - fVar12 * fVar17);
  if (fVar15 < (float10)0) {
    Var11 = gts_point_segment_distance2(p,local_1c);
    return (float10)Var11;
  }
  if ((float10)1 < fVar9 + fVar15) {
    fVar9 = (float10)gts_point_segment_distance2(p,local_20);
  }
  else {
    fVar10 = (float10)dVar1 * fVar15 + fVar10 * fVar9 + (float10)dVar2;
    fVar12 = (float10)dVar4 * fVar15 + (float10)dVar3 * fVar9 + (float10)dVar5;
    fVar9 = fVar15 * (float10)dVar7 + fVar9 * (float10)dVar6 + (float10)dVar8;
    fVar9 = fVar9 * fVar9 + fVar12 * fVar12 + fVar10 * fVar10;
  }
  return fVar9;
}



// WARNING: Removing unreachable block (ram,0x0811b148)
// WARNING: Removing unreachable block (ram,0x0811b13e)
// WARNING: Removing unreachable block (ram,0x0811b14a)

float10 gts_point_triangle_distance(int p,int t)

{
  char "gts_point_triangle_distance" [28];
  float10 fVar1;
  
  if (p == 0) {
    g_return_if_fail_warning(0,"gts_point_triangle_distance",0x816106f);
    return (float10)0;
  }
  if (t != 0) {
    fVar1 = (float10)gts_point_triangle_distance2(p,t);
    return SQRT(fVar1);
  }
  g_return_if_fail_warning(0,0x815fbbd,0x815f901);
  return (float10)0;
}



// WARNING: Removing unreachable block (ram,0x0811b1d8)
// WARNING: Removing unreachable block (ram,0x0811b1ce)
// WARNING: Removing unreachable block (ram,0x0811b1da)

float10 gts_point_segment_distance(int p,int s)

{
  char "gts_point_segment_distance" [27];
  float10 fVar1;
  
  if (p == 0) {
    g_return_if_fail_warning(0,"gts_point_segment_distance",0x816106f);
    return (float10)0;
  }
  if (s != 0) {
    fVar1 = (float10)gts_point_segment_distance2(p,s);
    return SQRT(fVar1);
  }
  g_return_if_fail_warning(0,0x815fc10,0x815fd1b);
  return (float10)0;
}



float10 gts_point_distance(int p1,int p2)

{
  char "gts_point_distance" [19];
  float10 fVar1;
  float10 fVar2;
  float10 fVar3;
  
  if ((p2 != 0) && (p1 != 0)) {
    fVar1 = (float10)*(double *)(p1 + 0xc) - (float10)*(double *)(p2 + 0xc);
    fVar2 = (float10)*(double *)(p1 + 0x14) - (float10)*(double *)(p2 + 0x14);
    fVar3 = (float10)*(double *)(p1 + 0x1c) - (float10)*(double *)(p2 + 0x1c);
    return SQRT(fVar3 * fVar3 + fVar2 * fVar2 + fVar1 * fVar1);
  }
  g_return_if_fail_warning(0,"gts_point_distance","p1 != NULL && p2 != NULL");
  return (float10)0;
}



float10 gts_point_in_sphere(int param_1,int param_2,int param_3,int param_4,int param_5)

{
  char "gts_point_in_sphere" [20];
  double dVar1;
  
  if ((((param_2 != 0) && (param_1 != 0)) && (param_4 != 0)) && ((param_3 != 0 && (param_5 != 0))))
  {
    dVar1 = insphere((double *)(param_2 + 0xc),(double *)(param_3 + 0xc),(double *)(param_4 + 0xc),
                     (double *)(param_5 + 0xc),(double *)(param_1 + 0xc));
    return (float10)dVar1;
  }
  g_return_if_fail_warning
            (0,"gts_point_in_sphere",
             "p != NULL && p1 != NULL && p2 != NULL && p3 != NULL && p4 != NULL");
  return (float10)0;
}



float10 gts_point_in_circle(int param_1,int param_2,int param_3,int param_4)

{
  char "gts_point_in_circle" [20];
  double dVar1;
  
  if ((((param_2 != 0) && (param_1 != 0)) && (param_4 != 0)) && (param_3 != 0)) {
    dVar1 = incircle((double *)(param_2 + 0xc),(double *)(param_3 + 0xc),(double *)(param_4 + 0xc),
                     (double *)(param_1 + 0xc));
    return (float10)dVar1;
  }
  g_return_if_fail_warning
            (0,"gts_point_in_circle","p != NULL && p1 != NULL && p2 != NULL && p3 != NULL");
  return (float10)0;
}



float10 gts_point_in_triangle_circle(int p,GtsTriangle *t)

{
  char "gts_point_in_triangle_circle" [29];
  double dVar1;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if ((t != (GtsTriangle *)0x0) && (p != 0)) {
    gts_triangle_vertices(t,local_10,&local_14,&local_18);
    dVar1 = incircle((double *)&(local_10[0]->p).x,(double *)&(local_14->p).x,
                     (double *)&(local_18->p).x,(double *)(p + 0xc));
    return (float10)dVar1;
  }
  g_return_if_fail_warning(0,"gts_point_in_triangle_circle","p != NULL && t != NULL");
  return (float10)0;
}



GtsPointClass * gts_point_class(void)

{
  GtsPointClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo point_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsPointClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &point_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    point_info.name._0_4_ = 0x50737447;
    point_info.name._4_4_ = 0x746e696f;
    do {
      *(undefined4 *)(&stack0x0000001c + (int)&klass[-1].parent_class) = 0;
      klass = (GtsPointClass *)((klass->parent_class).info.name + 4);
    } while (klass < (GtsPointClass *)&DAT_0000001c);
    point_info.object_size = 0x24;
    point_info.class_size = 0x60;
    point_info.class_init_func = point_class_init;
    parent_class = gts_object_class();
    klass = (GtsPointClass *)gts_object_class_new(parent_class,&point_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



gboolean gts_point_is_inside_surface(GtsPoint *p,GNode *tree,gboolean is_open)

{
  gdouble gVar1;
  gdouble gVar2;
  double dVar3;
  GSList *pGVar4;
  char "gts_point_is_inside_surface" [28];
  GtsPointClass *klass;
  GtsPoint *p4;
  GSList *pGVar5;
  uint uVar6;
  gint gVar7;
  gint gVar8;
  GtsPoint *p2;
  GtsPoint *p4_00;
  uint local_34;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_is_inside_surface",0x816106f);
    return 0;
  }
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,0x815fb37,"tree != NULL");
    return 0;
  }
  gVar1 = p->z;
  gVar2 = p->y;
  dVar3 = *(double *)((int)tree->data + 0x28);
  klass = gts_point_class();
  p4 = (GtsPoint *)gts_object_new((GtsObjectClass *)klass);
  *(double *)&p4->x = ABS(dVar3) / 10.00000000 + dVar3;
  p4->y = gVar2;
  p4->z = gVar1;
  pGVar5 = gts_bb_tree_stabbed(tree,p);
  local_34 = 0;
  pGVar4 = pGVar5;
  while (pGVar4 != (GSList *)0x0) {
    gts_triangle_vertices(*(GtsTriangle **)((int)pGVar4->data + 0xc),local_20,&local_24,&local_28);
    gVar7 = gts_point_orientation_3d_sos
                      ((GtsPoint *)local_20[0],(GtsPoint *)local_24,(GtsPoint *)local_28,p4);
    gVar8 = gts_point_orientation_3d_sos
                      ((GtsPoint *)local_20[0],(GtsPoint *)local_24,(GtsPoint *)local_28,p);
    if ((((gVar8 < 1) && (p2 = p, p4_00 = p4, -1 < gVar7)) ||
        ((gVar7 < 1 && (p2 = p4, p4_00 = p, -1 < gVar8)))) &&
       ((gVar7 = gts_point_orientation_3d_sos((GtsPoint *)local_20[0],p2,(GtsPoint *)local_28,p4_00)
        , -1 < gVar7 &&
        (gVar7 = gts_point_orientation_3d_sos((GtsPoint *)local_20[0],(GtsPoint *)local_24,p2,p4_00)
        , -1 < gVar7)))) {
      uVar6 = gts_point_orientation_3d_sos((GtsPoint *)local_24,(GtsPoint *)local_28,p2,p4_00);
      local_34 = local_34 + (uVar6 < 0x80000000);
    }
    pGVar4 = pGVar4->next;
  }
  g_slist_free(pGVar5);
  gts_object_destroy((GtsObject *)p4);
  if (is_open != 0) {
    return (local_34 ^ 1) & 1;
  }
  return local_34 & 1;
}



void gts_point_triangle_closest(GtsPoint *p,GtsTriangle *t,GtsPoint *closest)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  char "gts_point_triangle_closest" [27];
  GtsPointClass *klass;
  GtsPoint *closest_00;
  float10 fVar18;
  float10 fVar19;
  GtsPoint *pGVar20;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,"gts_point_triangle_closest",0x816106f);
    return;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x815fba2,0x815f901);
    return;
  }
  if (closest == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,0x815fba2,"closest != NULL");
    return;
  }
  gts_triangle_vertices_edges
            (t,(GtsEdge *)0x0,local_20,&local_24,&local_28,&local_2c,&local_30,&local_34);
  dVar1 = (double)(local_20[0]->p).x;
  dVar4 = (double)(local_24->p).x - dVar1;
  dVar2 = (double)(local_20[0]->p).y;
  dVar6 = (double)(local_24->p).y - dVar2;
  dVar3 = (double)(local_20[0]->p).z;
  dVar12 = (double)(local_24->p).z - dVar3;
  dVar15 = (double)(local_28->p).x - dVar1;
  dVar5 = (double)(local_28->p).y - dVar2;
  dVar11 = (double)(local_28->p).z - dVar3;
  dVar9 = dVar12 * dVar11 + dVar5 * dVar6 + dVar4 * dVar15;
  dVar13 = dVar12 * dVar12 + dVar6 * dVar6 + dVar4 * dVar4;
  dVar8 = dVar11 * dVar11 + dVar5 * dVar5 + dVar15 * dVar15;
  dVar7 = dVar9 * dVar9 - dVar13 * dVar8;
  if (dVar7 != 0.00000000) {
    dVar14 = dVar1 - (double)p->x;
    dVar16 = dVar2 - (double)p->y;
    dVar17 = dVar3 - (double)p->z;
    dVar10 = dVar17 * dVar11 + dVar16 * dVar5 + dVar15 * dVar14;
    dVar14 = dVar17 * dVar12 + dVar16 * dVar6 + dVar4 * dVar14;
    dVar8 = (dVar14 * dVar8 - dVar10 * dVar9) / dVar7;
    if (dVar8 < 0.00000000) {
      gts_point_segment_closest(p,(GtsSegment *)local_34,closest);
      return;
    }
    dVar7 = (dVar13 * dVar10 - dVar9 * dVar14) / dVar7;
    if (dVar7 < 0.00000000) {
      gts_point_segment_closest(p,(GtsSegment *)local_2c,closest);
      return;
    }
    if (1.00000000 < dVar8 + dVar7) {
      gts_point_segment_closest(p,(GtsSegment *)local_30,closest);
      return;
    }
    gts_point_set(closest,(gdouble)(dVar7 * dVar15 + dVar8 * dVar4 + dVar1),
                  (gdouble)(dVar5 * dVar7 + dVar6 * dVar8 + dVar2),
                  (gdouble)(dVar11 * dVar7 + dVar12 * dVar8 + dVar3));
    return;
  }
  klass = gts_point_class();
  closest_00 = (GtsPoint *)gts_object_new((GtsObjectClass *)klass);
  gts_point_segment_closest(p,(GtsSegment *)local_2c,closest_00);
  pGVar20 = closest;
  gts_point_segment_closest(p,(GtsSegment *)local_34,closest);
  fVar18 = (float10)gts_point_distance2(closest_00,p,pGVar20);
  fVar19 = (float10)gts_point_distance2(closest,p,pGVar20);
  if ((float10)(double)fVar18 < fVar19) {
    gts_point_set(closest,closest_00->x,closest_00->y,closest_00->z);
    gts_object_destroy((GtsObject *)closest_00);
  }
  else {
    gts_object_destroy((GtsObject *)closest_00);
  }
  return;
}



void point_write(GtsObject *o,FILE *fptr)

{
  if (*(int *)o->klass[1].info.name == 0) {
    __fprintf_chk(fptr,1,"%.10g %.10g %.10g",*(undefined8 *)(o + 1),*(undefined8 *)&o[1].flags,
                  *(undefined8 *)&o[2].reserved);
    return;
  }
  fwrite(o + 1,8,1,(FILE *)fptr);
  fwrite(&o[1].flags,8,1,(FILE *)fptr);
  fwrite(&o[2].reserved,8,1,(FILE *)fptr);
  return;
}



void point_read(GtsObject **o,GtsFile *f)

{
  GtsObject *pGVar1;
  GtsFile *f_00;
  guint gVar2;
  double dVar3;
  
  f_00 = f;
  pGVar1 = *o;
  if (*(int *)pGVar1->klass[1].info.name == 0) {
    if ((f->type == GTS_FLOAT) || (f->type == GTS_INT)) {
      dVar3 = strtod(f->token->str,(char **)0x0);
      *(double *)(pGVar1 + 1) = dVar3;
      gts_file_next_token(f);
      if ((f->type != GTS_FLOAT) && (f->type != GTS_INT)) {
        gts_file_error(f,"expecting a number (y coordinate)");
        return;
      }
      dVar3 = strtod(f->token->str,(char **)0x0);
      *(double *)&pGVar1[1].flags = dVar3;
      gts_file_next_token(f);
      if ((f->type != GTS_FLOAT) && (f->type != GTS_INT)) {
        gts_file_error(f,"expecting a number (z coordinate)");
        return;
      }
      dVar3 = strtod(f->token->str,(char **)0x0);
      *(double *)&pGVar1[2].reserved = dVar3;
      gts_file_next_token(f);
      return;
    }
    f = (GtsFile *)0x815fa88;
  }
  else {
    gVar2 = gts_file_read(f,pGVar1 + 1,8,1);
    if (gVar2 != 1) {
      gts_file_error(f,"expecting a binary number (x coordinate)");
      return;
    }
    gVar2 = gts_file_read(f,&pGVar1[1].flags,8,1);
    if (gVar2 == 1) {
      gVar2 = gts_file_read(f,&pGVar1[2].reserved,8,1);
      if (gVar2 == 1) {
        return;
      }
      f = (GtsFile *)0x815fa5c;
    }
    else {
      f = (GtsFile *)0x815fa30;
    }
  }
  gts_file_error(f_00,(gchar *)f);
  return;
}



void vertex_class_init(GtsVertexClass *klass)

{
  klass->intersection_attributes =
       (anon_subr_void_GtsVertex_ptr_GtsObject_ptr_GtsObject_ptr_for_intersection_attributes *)0x0;
  (klass->parent_class).parent_class.clone = vertex_clone;
  (klass->parent_class).parent_class.destroy = vertex_destroy;
  return;
}



void vertex_init(GtsVertex *vertex)

{
  vertex->segments = (GSList *)0x0;
  return;
}



void gts_vertex_normal_class_init(GtsVertexClass *klass)

{
  klass->intersection_attributes = vertex_normal_attributes;
  return;
}



GtsSegment * gts_vertices_are_connected(GtsVertex *v1,GtsVertex *v2)

{
  GSList *pGVar1;
  GtsSegment *pGVar2;
  char "gts_vertices_are_connected" [27];
  
  if (v1 == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertices_are_connected",0x8151613);
    return (GtsSegment *)0x0;
  }
  if (v2 != (GtsVertex *)0x0) {
    pGVar1 = v1->segments;
    while( true ) {
      if (pGVar1 == (GSList *)0x0) {
        return (GtsSegment *)0x0;
      }
      pGVar2 = (GtsSegment *)pGVar1->data;
      if ((pGVar2->v1 == v2) || (pGVar2->v2 == v2)) break;
      pGVar1 = (GSList *)(&pGVar1->data)[1];
    }
    return pGVar2;
  }
  g_return_if_fail_warning(0,0x815fee3,0x8151626);
  return (GtsSegment *)0x0;
}



gboolean gts_vertex_is_unattached(GtsVertex *v)

{
  char "gts_vertex_is_unattached" [25];
  
  if (v != (GtsVertex *)0x0) {
    return (uint)(v->segments == (GSList *)0x0);
  }
  g_return_if_fail_warning(0,"gts_vertex_is_unattached","v != NULL");
  return 0;
}



void gts_vertex_replace(GtsVertex *v,GtsVertex *with)

{
  gpointer pvVar1;
  char "gts_vertex_replace" [19];
  GSList *pGVar2;
  GtsVertex *pGVar3;
  GSList *pGVar4;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_replace","v != NULL");
    return;
  }
  if (with == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,0x815ff17,"with != NULL");
    return;
  }
  if (v == with) {
    g_return_if_fail_warning(0,0x815ff17,"v != with");
    return;
  }
  pGVar4 = v->segments;
  pGVar2 = (GSList *)0x0;
  if (pGVar4 != (GSList *)0x0) {
    do {
      while( true ) {
        pvVar1 = pGVar4->data;
        pGVar3 = *(GtsVertex **)((int)pvVar1 + 0xc);
        if (pGVar3 == with) break;
        if (*(GtsVertex **)((int)pvVar1 + 0x10) != with) {
          pGVar2 = (GSList *)g_slist_prepend(with->segments,pvVar1);
          with->segments = pGVar2;
          pGVar3 = *(GtsVertex **)((int)pvVar1 + 0xc);
        }
        if (v != pGVar3) break;
        *(GtsVertex **)((int)pvVar1 + 0xc) = with;
        if (*(GtsVertex **)((int)pvVar1 + 0x10) != v) goto LAB_0811be5d;
LAB_0811bea0:
        pGVar4 = pGVar4->next;
        *(GtsVertex **)((int)pvVar1 + 0x10) = with;
        if (pGVar4 == (GSList *)0x0) goto LAB_0811beb0;
      }
      if (*(GtsVertex **)((int)pvVar1 + 0x10) == v) goto LAB_0811bea0;
LAB_0811be5d:
      pGVar4 = pGVar4->next;
    } while (pGVar4 != (GSList *)0x0);
LAB_0811beb0:
    pGVar2 = v->segments;
  }
  g_slist_free(pGVar2);
  v->segments = (GSList *)0x0;
  return;
}



GtsEdge * __regparm3 replace_vertex(GtsTriangle *t,GtsEdge *e1,GtsVertex *v,GtsVertex *with)

{
  GtsVertex *pGVar1;
  GSList *pGVar2;
  GtsEdge *pGVar3;
  
  pGVar3 = t->e1;
  if ((((pGVar3 == e1) || (((pGVar3->segment).v1 != v && ((pGVar3->segment).v2 != v)))) &&
      ((pGVar3 = t->e2, pGVar3 == e1 || (((pGVar3->segment).v1 != v && ((pGVar3->segment).v2 != v)))
       ))) && ((pGVar3 = t->e3, pGVar3 == e1 ||
               (((pGVar3->segment).v1 != v && ((pGVar3->segment).v2 != v)))))) {
    pGVar3 = (GtsEdge *)0x0;
  }
  else {
    if (with != v) {
      if ((pGVar3->segment).v1 == v) {
        pGVar1 = (pGVar3->segment).v2;
        (pGVar3->segment).v1 = with;
      }
      else {
        pGVar1 = (pGVar3->segment).v2;
      }
      if (pGVar1 == v) {
        (pGVar3->segment).v2 = with;
      }
      pGVar2 = (GSList *)g_slist_prepend(with->segments,pGVar3);
      with->segments = pGVar2;
      pGVar2 = (GSList *)g_slist_remove(v->segments,pGVar3);
      v->segments = pGVar2;
    }
  }
  return pGVar3;
}



void __regparm3 triangle_next(GtsEdge *e,GtsVertex *v,GtsVertex *with)

{
  GSList *pGVar1;
  GtsTriangle *t;
  GtsEdge *e_00;
  
  if (e != (GtsEdge *)0x0) {
    pGVar1 = e->triangles;
    while (pGVar1 != (GSList *)0x0) {
      t = (GtsTriangle *)pGVar1->data;
      if ((t->object).reserved != (gpointer)0x0) {
        (t->object).reserved = (gpointer)0x0;
        e_00 = replace_vertex(t,e,v,with);
        triangle_next(e_00,v,with);
      }
      pGVar1 = (GSList *)(&pGVar1->data)[1];
    }
  }
  return;
}



GList * gts_vertices_merge(GList *vertices,gdouble epsilon,
                          anon_subr_gboolean_GtsVertex_ptr_GtsVertex_ptr *check)

{
  double dVar1;
  double dVar2;
  double dVar3;
  GtsVertex *with;
  GList *pGVar4;
  GtsVertex *v;
  char "gts_vertices_merge" [19];
  GPtrArray *points;
  GNode *tree_3d;
  GtsBBoxClass *klass;
  GtsBBox *bbox;
  GSList *pGVar5;
  gboolean gVar6;
  GList *pGVar7;
  GSList *pGVar8;
  
  if (vertices == (GList *)0x0) {
    g_return_if_fail_warning(0,"gts_vertices_merge","vertices != NULL");
    return (GList *)0x0;
  }
  points = (GPtrArray *)g_ptr_array_new();
  pGVar7 = vertices;
  do {
    g_ptr_array_add(points,pGVar7->data);
    pGVar7 = pGVar7->next;
  } while (pGVar7 != (GList *)0x0);
  tree_3d = gts_kdtree_new(points,(anon_subr_int_void_ptr_void_ptr *)0x0);
  g_ptr_array_free(points,1);
  pGVar7 = vertices;
  do {
    with = (GtsVertex *)pGVar7->data;
    if ((with->p).object.reserved == (gpointer)0x0) {
      dVar1 = (double)(with->p).z;
      dVar2 = (double)(with->p).y;
      dVar3 = (double)(with->p).x;
      klass = gts_bbox_class();
      bbox = gts_bbox_new(klass,with,(gdouble)(dVar3 - (double)epsilon),
                          (gdouble)(dVar2 - (double)epsilon),(gdouble)(dVar1 - (double)epsilon),
                          (gdouble)((double)epsilon + dVar3),(gdouble)((double)epsilon + dVar2),
                          (gdouble)((double)epsilon + dVar1));
      pGVar5 = gts_kdtree_range(tree_3d,bbox,(anon_subr_int_void_ptr_void_ptr *)0x0);
      pGVar8 = pGVar5;
      while (pGVar8 != (GSList *)0x0) {
        while (((v = (GtsVertex *)pGVar8->data, v == with ||
                ((v->p).object.reserved != (gpointer)0x0)) ||
               ((check != (anon_subr_gboolean_GtsVertex_ptr_GtsVertex_ptr *)0x0 &&
                (gVar6 = (*check)(v,with), gVar6 == 0))))) {
          pGVar8 = (GSList *)(&pGVar8->data)[1];
          if (pGVar8 == (GSList *)0x0) goto LAB_0811c21e;
        }
        gts_vertex_replace(v,with);
        pGVar8 = (GSList *)(&pGVar8->data)[1];
        *(GtsVertex **)&(v->p).object.reserved = v;
      }
LAB_0811c21e:
      g_slist_free(pGVar5);
      gts_object_destroy((GtsObject *)bbox);
    }
    pGVar7 = (GList *)(&pGVar7->data)[1];
    if (pGVar7 == (GList *)0x0) {
      g_node_destroy(tree_3d);
      gts_allow_floating_vertices = 1;
      pGVar7 = vertices;
      do {
        pGVar4 = pGVar7->next;
        if (((GtsObject *)pGVar7->data)->reserved != (gpointer)0x0) {
          gts_object_destroy((GtsObject *)pGVar7->data);
          vertices = (GList *)g_list_remove_link(vertices,pGVar7);
          g_list_free_1(pGVar7);
        }
        pGVar7 = pGVar4;
      } while (pGVar4 != (GList *)0x0);
      gts_allow_floating_vertices = 0;
      return vertices;
    }
  } while( true );
}



GSList * gts_vertices_from_segments(GSList *segments)

{
  gpointer pvVar1;
  undefined4 uVar2;
  int iVar3;
  GSList *local_20;
  
  uVar2 = g_hash_table_new(0,0);
  local_20 = (GSList *)0x0;
  if (segments != (GSList *)0x0) {
    do {
      pvVar1 = segments->data;
      iVar3 = g_hash_table_lookup(uVar2,*(undefined4 *)((int)pvVar1 + 0xc));
      if (iVar3 == 0) {
        local_20 = (GSList *)g_slist_prepend(local_20,*(undefined4 *)((int)pvVar1 + 0xc));
        g_hash_table_insert(uVar2,*(undefined4 *)((int)pvVar1 + 0xc),pvVar1);
      }
      iVar3 = g_hash_table_lookup(uVar2,*(undefined4 *)((int)pvVar1 + 0x10));
      if (iVar3 == 0) {
        local_20 = (GSList *)g_slist_prepend(local_20,*(undefined4 *)((int)pvVar1 + 0x10));
        g_hash_table_insert(uVar2,*(undefined4 *)((int)pvVar1 + 0x10),pvVar1);
      }
      segments = segments->next;
    } while (segments != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar2);
  return local_20;
}



GtsVertex * gts_vertex_new(GtsVertexClass *klass,gdouble x,gdouble y,gdouble z)

{
  GtsVertex *p;
  
  p = (GtsVertex *)gts_object_new((GtsObjectClass *)klass);
  gts_point_set((GtsPoint *)p,x,y,z);
  return p;
}



GtsVertexClass * gts_vertex_class(void)

{
  GtsVertexClass *klass;
  GtsPointClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo vertex_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsVertexClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &vertex_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    vertex_info.name._0_4_ = 0x56737447;
    vertex_info.name._4_4_ = 0x65747265;
    vertex_info.name._8_4_ = 0x78;
    do {
      *(undefined4 *)(&stack0x00000020 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsVertexClass *)((klass->parent_class).parent_class.info.name + 4);
    } while (klass < (GtsVertexClass *)&DAT_0000001c);
    vertex_info.object_size = 0x28;
    vertex_info.class_size = 100;
    vertex_info.class_init_func = vertex_class_init;
    vertex_info.object_init_func = vertex_init;
    parent_class = gts_point_class();
    klass = (GtsVertexClass *)gts_object_class_new((GtsObjectClass *)parent_class,&vertex_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



GtsVertexClass * gts_color_vertex_class(void)

{
  GtsVertexClass *klass;
  GtsVertexClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo gts_color_vertex_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsVertexClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &gts_color_vertex_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    gts_color_vertex_info.name._0_4_ = 0x43737447;
    gts_color_vertex_info.name._4_4_ = 0x726f6c6f;
    gts_color_vertex_info.name._8_4_ = 0x74726556;
    gts_color_vertex_info.name._12_4_ = 0x7865;
    do {
      *(undefined4 *)(&stack0x00000024 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsVertexClass *)((klass->parent_class).parent_class.info.name + 4);
    } while (klass < (GtsVertexClass *)&DAT_00000018);
    gts_color_vertex_info.object_size = 0x34;
    gts_color_vertex_info.class_size = 100;
    parent_class = gts_vertex_class();
    klass = (GtsVertexClass *)
            gts_object_class_new((GtsObjectClass *)parent_class,&gts_color_vertex_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



GtsVertexClass * gts_vertex_normal_class(void)

{
  GtsVertexClass *klass;
  GtsVertexClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo gts_vertex_normal_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsVertexClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &gts_vertex_normal_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    gts_vertex_normal_info.name._0_4_ = 0x56737447;
    gts_vertex_normal_info.name._4_4_ = 0x65747265;
    gts_vertex_normal_info.name._8_4_ = 0x726f4e78;
    gts_vertex_normal_info.name._12_4_ = 0x6c616d;
    do {
      *(undefined4 *)(&stack0x00000024 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsVertexClass *)((klass->parent_class).parent_class.info.name + 4);
    } while (klass < (GtsVertexClass *)&DAT_00000018);
    gts_vertex_normal_info.object_size = 0x40;
    gts_vertex_normal_info.class_size = 100;
    gts_vertex_normal_info.class_init_func = gts_vertex_normal_class_init;
    parent_class = gts_vertex_class();
    klass = (GtsVertexClass *)
            gts_object_class_new((GtsObjectClass *)parent_class,&gts_vertex_normal_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void vertex_clone(GtsObject *clone,GtsObject *object)

{
  GtsVertexClass *pGVar1;
  
  pGVar1 = gts_vertex_class();
  (*((pGVar1->parent_class).parent_class.parent_class)->clone)(clone,object);
  clone[3].klass = (GtsObjectClass *)0x0;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void vertex_destroy(GtsObject *object)

{
  uint *puVar1;
  GtsObjectClass *pGVar2;
  char "vertex_destroy" [15];
  GtsObjectClass *pGVar3;
  GtsVertexClass *pGVar4;
  GtsObjectClass *pGVar5;
  
  pGVar3 = object[3].klass;
  pGVar5 = pGVar3;
  if (pGVar3 != (GtsObjectClass *)0x0) {
    do {
      pGVar2 = *(GtsObjectClass **)&pGVar5->info;
      puVar1 = (uint *)(*(int *)(pGVar5->info).name + 8);
      *puVar1 = *puVar1 | 1;
      pGVar5 = pGVar2;
    } while (pGVar2 != (GtsObjectClass *)0x0);
    if (pGVar3 != (GtsObjectClass *)0x0) {
      do {
        pGVar5 = *(GtsObjectClass **)&pGVar3->info;
        gts_object_destroy(*(GtsObject **)(pGVar3->info).name);
        pGVar3 = pGVar5;
      } while (pGVar5 != (GtsObjectClass *)0x0);
      if (object[3].klass != (GtsObjectClass *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/vertex.c",0x29,0x815ff2a,"vertex->segments == NULL");
      }
    }
  }
  pGVar4 = gts_vertex_class();
                    // WARNING: Could not recover jumptable at 0x0811c65c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar4->parent_class).parent_class.parent_class)->destroy)();
  return;
}



GSList * __regparm3
edge_fan_list(GtsVertex *v,GtsSurface *surface,GtsFace *f,GtsEdge *e,GtsFace *first)

{
  GtsFace *f_00;
  GtsEdge *pGVar1;
  char "edge_fan_list" [14];
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsEdge *e_00;
  GtsObjectClass *pGVar4;
  GSList *pGVar5;
  bool bVar6;
  GtsFace *local_20;
  
  local_20 = (GtsFace *)0x0;
  pGVar5 = e->triangles;
  bVar6 = true;
  if (pGVar5 != (GSList *)0x0) {
    do {
      while( true ) {
        f_00 = (GtsFace *)pGVar5->data;
        pGVar2 = (GtsObjectClass *)gts_face_class();
        if (pGVar2 == (GtsObjectClass *)0x0) break;
        if (f_00 != (GtsFace *)0x0) {
          pGVar4 = (f_00->triangle).object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar2 == pGVar4) {
                if ((f_00 != f) && (gVar3 = gts_face_has_parent_surface(f_00,surface), gVar3 != 0))
                {
                  if (local_20 != (GtsFace *)0x0) {
                    g_return_if_fail_warning(0,"edge_fan_list","neighbor == NULL");
                    return (GSList *)0x0;
                  }
                  pGVar5 = (GSList *)(&pGVar5->data)[1];
                  local_20 = f_00;
                  goto joined_r0x0811c7dc;
                }
                break;
              }
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
        pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x0811c7dc:
        if (pGVar5 == (GSList *)0x0) goto LAB_0811c733;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      pGVar5 = (GSList *)(&pGVar5->data)[1];
    } while (pGVar5 != (GSList *)0x0);
LAB_0811c733:
    bVar6 = local_20 == (GtsFace *)0x0;
  }
  if ((local_20 == first) || (bVar6)) {
    return (GSList *)0x0;
  }
  e_00 = (local_20->triangle).e1;
  if (e_00 == e) {
    e_00 = (local_20->triangle).e3;
  }
  else {
    pGVar1 = (local_20->triangle).e2;
    if ((pGVar1 != e) && (e_00 = pGVar1, (local_20->triangle).e3 != e)) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/vertex.c",0x1dc,0x815fe70,0);
    }
  }
  if (((e_00->segment).v1 != v) && ((e_00->segment).v2 != v)) {
    g_return_if_fail_warning
              (0,0x815fe70,"GTS_SEGMENT (enext)->v1 == v || GTS_SEGMENT (enext)->v2 == v");
    return (GSList *)0x0;
  }
  edge_fan_list(v,surface,local_20,e_00,first);
  pGVar5 = (GSList *)g_slist_prepend();
  return pGVar5;
}



// WARNING: Type propagation algorithm not settling

GSList * gts_vertex_fan_oriented(GtsVertex *v,GtsSurface *surface)

{
  GtsFace *f;
  GtsEdge *pGVar1;
  uint uVar2;
  GtsFace *pGVar3;
  char "gts_vertex_fan_oriented" [24];
  gboolean gVar4;
  GSList *pGVar5;
  GtsObjectClass *pGVar6;
  GtsObjectClass *pGVar7;
  GtsObjectClass *pGVar8;
  uint uVar9;
  GtsFace *t;
  uint local_4c;
  GtsFace *local_48;
  GSList *local_40;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *v1;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,0x815fe58,"v != NULL");
    return (GSList *)0x0;
  }
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x815fe58,"surface != NULL");
    return (GSList *)0x0;
  }
  local_40 = v->segments;
  if (local_40 != (GSList *)0x0) {
    local_4c = 2;
    local_48 = (GtsFace *)0x0;
    do {
      pGVar1 = (GtsEdge *)local_40->data;
      pGVar8 = (GtsObjectClass *)gts_edge_class();
      uVar2 = local_4c;
      pGVar3 = local_48;
      if (pGVar8 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (pGVar1 != (GtsEdge *)0x0) {
          pGVar6 = (pGVar1->segment).object.klass;
          if (pGVar6 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar8 == pGVar6) {
                uVar9 = 0;
                t = (GtsFace *)0x0;
                pGVar8 = (&pGVar1->segment)[1].object.klass;
                if (pGVar8 != (GtsObjectClass *)0x0) {
                  do {
                    pGVar6 = (GtsObjectClass *)gts_face_class();
                    f = *(GtsFace **)(pGVar8->info).name;
                    if (pGVar6 == (GtsObjectClass *)0x0) {
                      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                    }
                    else {
                      if (f != (GtsFace *)0x0) {
                        pGVar7 = (f->triangle).object.klass;
                        if (pGVar7 == (GtsObjectClass *)0x0) {
                          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                        }
                        else {
                          do {
                            if (pGVar6 == pGVar7) {
                              gVar4 = gts_face_has_parent_surface(f,surface);
                              if (gVar4 != 0) {
                                t = *(GtsFace **)(pGVar8->info).name;
                                uVar9 = uVar9 + 1;
                              }
                              break;
                            }
                            pGVar7 = pGVar7->parent_class;
                          } while (pGVar7 != (GtsObjectClass *)0x0);
                        }
                      }
                    }
                    pGVar8 = *(GtsObjectClass **)((pGVar8->info).name + 4);
                  } while (pGVar8 != (GtsObjectClass *)0x0);
                  if (t != (GtsFace *)0x0) {
                    if (2 < uVar9) {
                      g_return_if_fail_warning(0,"gts_vertex_fan_oriented","degree <= 2");
                      return (GSList *)0x0;
                    }
                    pGVar3 = t;
                    if (uVar9 == 1) {
                      gts_triangle_vertices_edges
                                ((GtsTriangle *)t,(GtsEdge *)0x0,&v1,&local_24,&local_28,&local_2c,
                                 &local_30,&local_34);
                      if (v == local_24) {
                        local_30 = local_34;
                        local_34 = local_2c;
                      }
                      else {
                        if (v == local_28) {
                          local_34 = local_30;
                          local_30 = local_2c;
                        }
                      }
                      uVar2 = 1;
                      if (pGVar1 == local_34) {
                        uVar2 = local_4c;
                        pGVar3 = local_48;
                      }
                    }
                    else {
                      if (local_4c < uVar9) {
                        pGVar3 = local_48;
                      }
                    }
                  }
                }
                break;
              }
              pGVar6 = pGVar6->parent_class;
            } while (pGVar6 != (GtsObjectClass *)0x0);
          }
        }
      }
      local_48 = pGVar3;
      local_4c = uVar2;
      local_40 = (GSList *)(&local_40->data)[1];
    } while (local_40 != (GSList *)0x0);
    if (local_48 != (GtsFace *)0x0) {
      gts_triangle_vertices_edges
                ((GtsTriangle *)local_48,(GtsEdge *)0x0,&v1,&local_24,&local_28,&local_2c,&local_30,
                 &local_34);
      if (v == local_24) {
        local_30 = local_34;
        local_34 = local_2c;
      }
      else {
        if (v == local_28) {
          local_34 = local_30;
          local_30 = local_2c;
        }
      }
      pGVar1 = local_30;
      pGVar5 = edge_fan_list(v,surface,local_48,local_34,local_48);
      pGVar5 = (GSList *)g_slist_prepend(pGVar5,pGVar1);
      return pGVar5;
    }
  }
  return (GSList *)0x0;
}



gboolean gts_vertex_is_boundary(GtsVertex *v,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsEdge *e;
  char "gts_vertex_is_boundary" [23];
  GtsObjectClass *pGVar2;
  GtsFace *pGVar3;
  GtsObjectClass *pGVar4;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_is_boundary","v != NULL");
    return 0;
  }
  pGVar1 = v->segments;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return 0;
    }
    pGVar2 = (GtsObjectClass *)gts_edge_class();
    e = (GtsEdge *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else {
      if (e != (GtsEdge *)0x0) {
        pGVar4 = (e->segment).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        }
        else {
          do {
            if (pGVar2 == pGVar4) {
              pGVar3 = gts_edge_is_boundary(e,surface);
              if (pGVar3 != (GtsFace *)0x0) {
                return 1;
              }
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



GSList * gts_vertex_neighbors(GtsVertex *v,GSList *list,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsEdge *e;
  char "gts_vertex_neighbors" [21];
  GtsObjectClass *pGVar2;
  GtsFace *pGVar3;
  int iVar4;
  GtsObjectClass *pGVar5;
  GtsVertex *pGVar6;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_neighbors","v != NULL");
    return (GSList *)0x0;
  }
  pGVar1 = v->segments;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return list;
    }
    e = (GtsEdge *)pGVar1->data;
    pGVar6 = (e->segment).v1;
    if ((pGVar6 != v) || (pGVar6 = (e->segment).v2, v != pGVar6)) {
      if (surface == (GtsSurface *)0x0) {
LAB_0811ccd9:
        iVar4 = g_slist_find(list,pGVar6);
        if (iVar4 == 0) {
          list = (GSList *)g_slist_prepend(list,pGVar6);
        }
      }
      else {
        pGVar2 = (GtsObjectClass *)gts_edge_class();
        if (pGVar2 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          pGVar5 = (e->segment).object.klass;
          if (pGVar5 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar2 == pGVar5) {
                pGVar3 = gts_edge_has_parent_surface(e,surface);
                if (pGVar3 != (GtsFace *)0x0) goto LAB_0811ccd9;
                break;
              }
              pGVar5 = pGVar5->parent_class;
            } while (pGVar5 != (GtsObjectClass *)0x0);
          }
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Type propagation algorithm not settling

GSList * gts_vertex_faces(GtsVertex *v,GtsSurface *surface,GSList *list)

{
  GtsObjectClass *pGVar1;
  GtsFace *f;
  char "gts_vertex_faces" [17];
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  int iVar4;
  GtsObjectClass *pGVar5;
  GSList *local_20;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_faces","v != NULL");
    list = (GSList *)0x0;
  }
  else {
    local_20 = v->segments;
    while (local_20 != (GSList *)0x0) {
LAB_0811cdb8:
      pGVar1 = (GtsObjectClass *)local_20->data;
      pGVar2 = (GtsObjectClass *)gts_edge_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        local_20 = (GSList *)(&local_20->data)[1];
joined_r0x0811ce5f:
        if (local_20 == (GSList *)0x0) {
          return list;
        }
        goto LAB_0811cdb8;
      }
      if (pGVar1 == (GtsObjectClass *)0x0) {
LAB_0811ce54:
        local_20 = (GSList *)(&local_20->data)[1];
        goto joined_r0x0811ce5f;
      }
      pGVar5 = *(GtsObjectClass **)&pGVar1->info;
      if (pGVar5 != (GtsObjectClass *)0x0) {
LAB_0811cde7:
        if (pGVar2 != pGVar5) goto LAB_0811cde0;
        pGVar1 = *(GtsObjectClass **)((int)&pGVar1->info + 0x14);
        while (pGVar1 != (GtsObjectClass *)0x0) {
          f = *(GtsFace **)&pGVar1->info;
          pGVar2 = (GtsObjectClass *)gts_face_class();
          if (pGVar2 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else {
            if (f != (GtsFace *)0x0) {
              pGVar5 = (f->triangle).object.klass;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar2 == pGVar5) {
                    if (((surface == (GtsSurface *)0x0) ||
                        (gVar3 = gts_face_has_parent_surface(f,surface), gVar3 != 0)) &&
                       (iVar4 = g_slist_find(list,f), iVar4 == 0)) {
                      list = (GSList *)g_slist_prepend(list,f);
                    }
                    break;
                  }
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
          }
          pGVar1 = *(GtsObjectClass **)((int)&pGVar1->info + 4);
        }
        goto LAB_0811ce54;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      local_20 = (GSList *)(&local_20->data)[1];
    }
  }
  return list;
LAB_0811cde0:
  pGVar5 = pGVar5->parent_class;
  if (pGVar5 == (GtsObjectClass *)0x0) goto LAB_0811ce54;
  goto LAB_0811cde7;
}



// WARNING: Type propagation algorithm not settling

GSList * gts_vertex_triangles(GtsVertex *v,GSList *list)

{
  GSList *pGVar1;
  GtsObjectClass *pGVar2;
  char "gts_vertex_triangles" [21];
  GtsObjectClass *pGVar3;
  int iVar4;
  GtsObjectClass *pGVar5;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_triangles","v != NULL");
    return (GSList *)0x0;
  }
  pGVar1 = v->segments;
  do {
    while( true ) {
      while( true ) {
        if (pGVar1 == (GSList *)0x0) {
          return list;
        }
        pGVar2 = (GtsObjectClass *)pGVar1->data;
        pGVar3 = (GtsObjectClass *)gts_edge_class();
        if (pGVar3 != (GtsObjectClass *)0x0) break;
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        pGVar1 = (GSList *)(&pGVar1->data)[1];
      }
      if (pGVar2 != (GtsObjectClass *)0x0) break;
LAB_0811cfc1:
      pGVar1 = (GSList *)(&pGVar1->data)[1];
    }
    pGVar5 = *(GtsObjectClass **)&pGVar2->info;
    if (pGVar5 != (GtsObjectClass *)0x0) {
LAB_0811cf97:
      if (pGVar3 != pGVar5) break;
      pGVar2 = *(GtsObjectClass **)((int)&pGVar2->info + 0x14);
      while (pGVar2 != (GtsObjectClass *)0x0) {
        iVar4 = g_slist_find(list,*(undefined4 *)&pGVar2->info);
        if (iVar4 == 0) {
          list = (GSList *)g_slist_prepend(list,*(undefined4 *)&pGVar2->info);
        }
        pGVar2 = *(GtsObjectClass **)((int)&pGVar2->info + 4);
      }
      goto LAB_0811cfc1;
    }
    g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
  pGVar5 = pGVar5->parent_class;
  if (pGVar5 == (GtsObjectClass *)0x0) goto LAB_0811cfc1;
  goto LAB_0811cf97;
}



guint gts_vertex_is_contact(GtsVertex *v,gboolean sever)

{
  GtsTriangle *t;
  gpointer *ppvVar1;
  char "gts_vertex_is_contact" [22];
  GSList *pGVar2;
  GSList *pGVar3;
  GtsEdge *e;
  GtsVertex *with;
  guint local_20;
  
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_vertex_is_contact","v != NULL");
    return 0;
  }
  pGVar2 = gts_vertex_triangles(v,(GSList *)0x0);
  local_20 = 0;
  pGVar3 = pGVar2;
  if (pGVar2 != (GSList *)0x0) {
    do {
      *(GSList **)((int)pGVar3->data + 4) = pGVar3;
      ppvVar1 = &pGVar3->data;
      pGVar3 = (GSList *)ppvVar1[1];
    } while ((GSList *)ppvVar1[1] != (GSList *)0x0);
    local_20 = 0;
    pGVar3 = pGVar2;
    with = v;
    do {
      t = (GtsTriangle *)pGVar3->data;
      if ((t->object).reserved != (gpointer)0x0) {
        if ((local_20 != 0) && (sever != 0)) {
          with = (GtsVertex *)gts_object_clone((GtsObject *)v);
        }
        (t->object).reserved = (gpointer)0x0;
        e = replace_vertex(t,(GtsEdge *)0x0,v,with);
        triangle_next(e,v,with);
        e = replace_vertex(t,e,v,with);
        triangle_next(e,v,with);
        local_20 = local_20 + 1;
      }
      pGVar3 = (GSList *)(&pGVar3->data)[1];
    } while (pGVar3 != (GSList *)0x0);
  }
  g_slist_free(pGVar2);
  return local_20;
}



// WARNING: Removing unreachable block (ram,0x0811d4f0)
// WARNING: Removing unreachable block (ram,0x0811d31c)
// WARNING: Type propagation algorithm not settling

void vertex_normal_attributes(GtsVertex *v,GtsObject *e,GtsObject *t)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  char "vertex_normal_attributes" [25];
  GtsObjectClass *pGVar13;
  GtsVertexClass *pGVar14;
  GtsVertexClass *pGVar15;
  uint uVar16;
  int iVar17;
  GtsObjectClass *pGVar18;
  GtsVertexClass *pGVar19;
  GtsVector det;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pGVar13 = (GtsObjectClass *)gts_edge_class();
  if (pGVar13 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e != (GtsObject *)0x0) {
      pGVar18 = e->klass;
      if (pGVar18 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar13 == pGVar18) {
            pGVar13 = (GtsObjectClass *)gts_triangle_class();
            if (pGVar13 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
              goto LAB_0811d630;
            }
            if (t == (GtsObject *)0x0) goto LAB_0811d630;
            pGVar18 = t->klass;
            if (pGVar18 != (GtsObjectClass *)0x0) goto LAB_0811d20b;
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            goto LAB_0811d630;
          }
          pGVar18 = pGVar18->parent_class;
        } while (pGVar18 != (GtsObjectClass *)0x0);
      }
    }
  }
  g_return_if_fail_warning(0,"vertex_normal_attributes","GTS_IS_EDGE (e)");
  return;
LAB_0811d20b:
  if (pGVar13 == pGVar18) {
    pGVar14 = gts_vertex_normal_class();
    if (pGVar14 == (GtsVertexClass *)0x0) goto LAB_0811d338;
    if (e[1].klass == (GtsObjectClass *)0x0) goto LAB_0811d358;
    pGVar15 = *(GtsVertexClass **)((e[1].klass)->info).name;
    if (pGVar15 == (GtsVertexClass *)0x0) goto LAB_0811d588;
    goto LAB_0811d246;
  }
  pGVar18 = pGVar18->parent_class;
  if (pGVar18 == (GtsObjectClass *)0x0) {
LAB_0811d630:
    g_return_if_fail_warning(0,0x815fe10,"GTS_IS_TRIANGLE (t)");
    return;
  }
  goto LAB_0811d20b;
  while (pGVar15 = (GtsVertexClass *)(pGVar15->parent_class).parent_class.parent_class,
        pGVar15 != (GtsVertexClass *)0x0) {
LAB_0811d246:
    if (pGVar14 == pGVar15) {
      pGVar15 = gts_vertex_normal_class();
      pGVar14 = (GtsVertexClass *)e[1].reserved;
      if (pGVar15 == (GtsVertexClass *)0x0) {
LAB_0811d338:
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (pGVar14 != (GtsVertexClass *)0x0) {
          pGVar19 = *(GtsVertexClass **)&pGVar14->parent_class;
          if (pGVar19 == (GtsVertexClass *)0x0) {
LAB_0811d588:
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar15 == pGVar19) {
                pGVar13 = e[1].klass;
                dVar1 = *(double *)((pGVar13->info).name + 0xc);
                dVar3 = *(double *)((int)&pGVar14->parent_class + 0xc) - dVar1;
                dVar2 = *(double *)((pGVar13->info).name + 0x14);
                dVar6 = *(double *)((int)&pGVar14->parent_class + 0x14) - dVar2;
                dVar4 = ABS(dVar6);
                dVar5 = ABS(dVar3);
                if (dVar4 <= dVar5) {
                  dVar1 = (double)(v->p).x - dVar1;
                }
                else {
                  dVar1 = (double)(v->p).y - dVar2;
                  dVar5 = dVar4;
                  dVar3 = dVar6;
                }
                dVar2 = *(double *)((pGVar13->info).name + 0x1c);
                dVar4 = *(double *)((int)&pGVar14->parent_class + 0x1c) - dVar2;
                if (dVar5 < ABS(dVar4)) {
                  dVar1 = (double)(v->p).z - dVar2;
                  dVar3 = dVar4;
                }
                if (dVar3 == 0.00000000) {
                  dVar1 = 0.00000000;
                }
                else {
                  dVar1 = dVar1 / dVar3;
                }
                iVar17 = 0;
                do {
                  *(double *)(&v[1].p.object.klass + iVar17 * 2) =
                       *(double *)((int)&pGVar14->parent_class + (iVar17 + 4) * 8 + 8) * dVar1 +
                       *(double *)((pGVar13->info).name + (iVar17 + 4) * 8 + 8) *
                       (1.00000000 - dVar1);
                  iVar17 = iVar17 + 1;
                } while (iVar17 != 3);
                return;
              }
              pGVar19 = (GtsVertexClass *)(pGVar19->parent_class).parent_class.parent_class;
            } while (pGVar19 != (GtsVertexClass *)0x0);
          }
        }
      }
      break;
    }
  }
LAB_0811d358:
  gts_triangle_vertices((GtsTriangle *)t,local_20,&local_24,&local_28);
  pGVar14 = gts_vertex_normal_class();
  if (pGVar14 != (GtsVertexClass *)0x0) {
    if (local_20[0] == (GtsVertex *)0x0) {
      return;
    }
    pGVar15 = (GtsVertexClass *)(local_20[0]->p).object.klass;
    if (pGVar15 != (GtsVertexClass *)0x0) {
      while (pGVar14 != pGVar15) {
        pGVar15 = (GtsVertexClass *)(pGVar15->parent_class).parent_class.parent_class;
        if (pGVar15 == (GtsVertexClass *)0x0) {
          return;
        }
      }
      pGVar14 = gts_vertex_normal_class();
      if (pGVar14 == (GtsVertexClass *)0x0) goto LAB_0811d696;
      if (local_24 == (GtsVertex *)0x0) {
        return;
      }
      pGVar15 = (GtsVertexClass *)(local_24->p).object.klass;
      if (pGVar15 != (GtsVertexClass *)0x0) {
        while (pGVar14 != pGVar15) {
          pGVar15 = (GtsVertexClass *)(pGVar15->parent_class).parent_class.parent_class;
          if (pGVar15 == (GtsVertexClass *)0x0) {
            return;
          }
        }
        pGVar14 = gts_vertex_normal_class();
        if (pGVar14 == (GtsVertexClass *)0x0) goto LAB_0811d696;
        if (local_28 == (GtsVertex *)0x0) {
          return;
        }
        pGVar15 = (GtsVertexClass *)(local_28->p).object.klass;
        if (pGVar15 != (GtsVertexClass *)0x0) {
          while (pGVar14 != pGVar15) {
            pGVar15 = (GtsVertexClass *)(pGVar15->parent_class).parent_class.parent_class;
            if (pGVar15 == (GtsVertexClass *)0x0) {
              return;
            }
          }
          dVar1 = (double)(local_20[0]->p).x;
          dVar2 = (double)(local_20[0]->p).y;
          dVar3 = (double)(local_20[0]->p).z;
          dVar5 = (double)(local_24->p).x - dVar1;
          dVar11 = (double)(local_24->p).y - dVar2;
          dVar12 = (double)(local_24->p).z - dVar3;
          dVar4 = (double)(local_28->p).x - dVar1;
          dVar10 = (double)(local_28->p).y - dVar2;
          dVar9 = (double)(local_28->p).z - dVar3;
          det[0] = (gdouble)(dVar11 * dVar9 - dVar12 * dVar10);
          det[1] = (gdouble)(dVar12 * dVar4 - dVar5 * dVar9);
          det[2] = (gdouble)(dVar5 * dVar10 - dVar11 * dVar4);
          uVar16 = (uint)(ABS((double)det[0]) < ABS((double)det[1]));
          dVar8 = ABS((double)det[2]);
          dVar7 = ABS((double)det[uVar16]);
          dVar6 = (double)det[uVar16];
          if (dVar7 <= dVar8 || dVar8 != dVar7) {
            dVar6 = (double)det[2];
          }
          if (dVar7 < dVar8) {
            uVar16 = 2;
          }
          if (dVar6 != 0.00000000) {
            dVar1 = (double)(v->p).x - dVar1;
            dVar2 = (double)(v->p).y - dVar2;
            dVar3 = (double)(v->p).z - dVar3;
            if (uVar16 == 1) {
              dVar4 = (dVar4 * dVar3 - dVar9 * dVar1) / (double)det[1];
              dVar1 = (dVar12 * dVar1 - dVar3 * dVar5) / (double)det[1];
            }
            else {
              if (uVar16 == 2) {
                dVar4 = (dVar10 * dVar1 - dVar4 * dVar2) / (double)det[2];
                dVar1 = (double)det[2] / (dVar5 * dVar2 - dVar1 * dVar11);
              }
              else {
                dVar4 = (dVar9 * dVar2 - dVar10 * dVar3) / (double)det[0];
                dVar1 = (double)det[0] / (dVar11 * dVar3 - dVar2 * dVar12);
              }
            }
            iVar17 = 0;
            do {
              *(double *)(&v[1].p.object.klass + iVar17 * 2) =
                   *(double *)(&local_28[1].p.object.klass + iVar17 * 2) * dVar1 +
                   *(double *)(&local_24[1].p.object.klass + iVar17 * 2) * dVar4 +
                   *(double *)(&local_20[0][1].p.object.klass + iVar17 * 2) *
                   ((1.00000000 - dVar4) - dVar1);
              iVar17 = iVar17 + 1;
            } while (iVar17 != 3);
            return;
          }
          g_log(0,0x10,"vertex_normal_attributes: det[%d] == 0.",uVar16);
          return;
        }
      }
    }
    g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    return;
  }
LAB_0811d696:
  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  return;
}



void edge_class_init(GtsObjectClass *klass)

{
  klass->clone = edge_clone;
  klass->destroy = edge_destroy;
  return;
}



void edge_init(GtsEdge *edge)

{
  edge->triangles = (GSList *)0x0;
  return;
}



void __regparm3
triangle_vertices_edges(GtsTriangle *t,GtsEdge *e,GtsVertex **v,GtsEdge **ee1,GtsEdge **ee2)

{
  GtsEdge *pGVar1;
  GtsVertex *pGVar2;
  GtsEdge *pGVar3;
  char "triangle_vertices_edges" [24];
  GtsVertex *pGVar4;
  GtsEdge *pGVar5;
  GtsEdge *pGVar6;
  GtsEdge *pGVar7;
  
  pGVar6 = t->e1;
  pGVar1 = t->e2;
  pGVar2 = (e->segment).v1;
  pGVar3 = t->e3;
  pGVar5 = pGVar1;
  pGVar7 = pGVar3;
  if (((pGVar6 != e) && (pGVar5 = pGVar3, pGVar7 = pGVar6, pGVar1 != e)) &&
     (pGVar5 = pGVar1, pGVar3 != e)) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/gts/edge.c",0x165,"triangle_vertices_edges",&DAT_0815ff39)
    ;
  }
  pGVar4 = (pGVar5->segment).v1;
  pGVar6 = pGVar7;
  if ((pGVar4 == pGVar2) ||
     (((pGVar5->segment).v2 != pGVar2 &&
      (pGVar4 = (pGVar7->segment).v1, pGVar6 = pGVar5, pGVar5 = pGVar7, pGVar4 == pGVar2)))) {
    *v = (pGVar5->segment).v2;
  }
  else {
    *v = pGVar4;
  }
  *ee1 = pGVar5;
  *ee2 = pGVar6;
  return;
}



GtsEdge * __regparm3 next_edge(GtsTriangle *t,GtsEdge *e1,GtsEdge *e)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  char "next_edge" [10];
  GtsEdge *pGVar5;
  
  pGVar1 = (e->segment).v2;
  pGVar2 = (e->segment).v1;
  pGVar5 = t->e1;
  if (((((pGVar5 == e1) || (e == pGVar5)) ||
       ((pGVar3 = (pGVar5->segment).v1, pGVar3 != pGVar2 &&
        (((pGVar4 = (pGVar5->segment).v2, pGVar4 != pGVar2 && (pGVar1 != pGVar3)) &&
         (pGVar1 != pGVar4)))))) &&
      (((pGVar5 = t->e2, pGVar5 == e1 || (e == pGVar5)) ||
       ((pGVar3 = (pGVar5->segment).v1, pGVar3 != pGVar2 &&
        (((pGVar4 = (pGVar5->segment).v2, pGVar4 != pGVar2 && (pGVar1 != pGVar3)) &&
         (pGVar1 != pGVar4)))))))) &&
     (((pGVar5 = t->e3, pGVar5 == e1 || (e == pGVar5)) ||
      ((pGVar3 = (pGVar5->segment).v1, pGVar3 != pGVar2 &&
       (((pGVar4 = (pGVar5->segment).v2, pGVar4 != pGVar2 && (pGVar1 != pGVar3)) &&
        (pGVar1 != pGVar4)))))))) {
                    // WARNING: Subroutine does not return
    g_assertion_message(0,"../../src/gts/edge.c",0x1ae,"next_edge",0);
  }
  return pGVar5;
}



void __regparm3 triangle_next(GtsEdge *e1,GtsEdge *e)

{
  GSList *pGVar1;
  GtsTriangle *t;
  GtsEdge *e1_00;
  
  pGVar1 = e1->triangles;
  while (pGVar1 != (GSList *)0x0) {
    t = (GtsTriangle *)pGVar1->data;
    if ((t->object).reserved != (gpointer)0x0) {
      (t->object).reserved = (gpointer)0x0;
      e1_00 = next_edge(t,e1,e);
      triangle_next(e1_00,e);
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  }
  return;
}



guint gts_edge_is_contact(GtsEdge *e)

{
  GtsTriangle *t;
  char "gts_edge_is_contact" [20];
  GSList *list;
  GSList *pGVar1;
  GtsEdge *e1;
  guint local_24;
  
  if (e != (GtsEdge *)0x0) {
    list = gts_vertex_triangles((e->segment).v1,(GSList *)0x0);
    pGVar1 = gts_vertex_triangles((e->segment).v2,list);
    list = pGVar1;
    while (list != (GSList *)0x0) {
      *(GSList **)((int)list->data + 4) = list;
      list = list->next;
    }
    list = e->triangles;
    local_24 = 0;
    while (list != (GSList *)0x0) {
      t = (GtsTriangle *)list->data;
      if ((t->object).reserved != (gpointer)0x0) {
        (t->object).reserved = (gpointer)0x0;
        e1 = next_edge(t,(GtsEdge *)0x0,e);
        triangle_next(e1,e);
        e1 = next_edge(t,e1,e);
        triangle_next(e1,e);
        local_24 = local_24 + 1;
      }
      list = (GSList *)(&list->data)[1];
    }
    g_slist_foreach(pGVar1,gts_object_reset_reserved,0);
    g_slist_free(pGVar1);
    return local_24;
  }
  g_return_if_fail_warning(0,"gts_edge_is_contact",0x815fd6c);
  return 0;
}



void gts_edge_replace(GtsEdge *e,GtsEdge *with)

{
  gpointer pvVar1;
  GtsEdge *pGVar2;
  char "gts_edge_replace" [17];
  GSList *pGVar3;
  int iVar4;
  GSList *pGVar5;
  
  if (((with == (GtsEdge *)0x0) || (e == (GtsEdge *)0x0)) || (e == with)) {
    g_return_if_fail_warning(0,"gts_edge_replace","e != NULL && with != NULL && e != with");
    return;
  }
  pGVar5 = e->triangles;
  pGVar3 = (GSList *)0x0;
  if (pGVar5 != (GSList *)0x0) {
    do {
      pvVar1 = pGVar5->data;
      if (*(GtsEdge **)((int)pvVar1 + 0xc) == e) {
        *(GtsEdge **)((int)pvVar1 + 0xc) = with;
        if (*(GtsEdge **)((int)pvVar1 + 0x10) == e) goto LAB_0811db28;
LAB_0811daed:
        pGVar2 = *(GtsEdge **)((int)pvVar1 + 0x14);
      }
      else {
        if (*(GtsEdge **)((int)pvVar1 + 0x10) != e) goto LAB_0811daed;
LAB_0811db28:
        pGVar2 = *(GtsEdge **)((int)pvVar1 + 0x14);
        *(GtsEdge **)((int)pvVar1 + 0x10) = with;
      }
      if (pGVar2 == e) {
        *(GtsEdge **)((int)pvVar1 + 0x14) = with;
      }
      iVar4 = g_slist_find(with->triangles,pvVar1);
      if (iVar4 == 0) {
        pGVar3 = (GSList *)g_slist_prepend(with->triangles,pvVar1);
        with->triangles = pGVar3;
      }
      pGVar5 = pGVar5->next;
    } while (pGVar5 != (GSList *)0x0);
    pGVar3 = e->triangles;
  }
  g_slist_free(pGVar3);
  e->triangles = (GSList *)0x0;
  return;
}



GtsEdge * gts_edge_new(GtsEdgeClass *klass,GtsVertex *v1,GtsVertex *v2)

{
  GtsEdge *pGVar1;
  
  pGVar1 = (GtsEdge *)gts_segment_new((GtsSegmentClass *)klass,v1,v2);
  return pGVar1;
}



GtsEdgeClass * gts_edge_class(void)

{
  GtsEdgeClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo edge_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsEdgeClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &edge_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    edge_info.name._0_4_ = 0x45737447;
    edge_info.name._4_4_ = 0x656764;
    do {
      *(undefined4 *)(&stack0x00000014 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsEdgeClass *)((klass->parent_class).parent_class.info.name + 4);
    } while (klass < (GtsEdgeClass *)&DAT_00000020);
    edge_info.object_size = 0x18;
    edge_info.class_size = 0x5c;
    edge_info.class_init_func = edge_class_init;
    edge_info.object_init_func = edge_init;
    parent_class = (GtsObjectClass *)gts_segment_class();
    klass = (GtsEdgeClass *)gts_object_class_new(parent_class,&edge_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Type propagation algorithm not settling
// WARNING: Exceeded maximum restarts with more pending

void edge_destroy(GtsObject *object)

{
  GtsObject *pGVar1;
  char "edge_destroy" [13];
  GtsObject *pGVar2;
  GtsEdgeClass *pGVar3;
  
  pGVar2 = (GtsObject *)object[1].flags;
  if (pGVar2 != (GtsObject *)0x0) {
    do {
      pGVar1 = (GtsObject *)pGVar2->reserved;
      gts_object_destroy((GtsObject *)pGVar2->klass);
      pGVar2 = pGVar1;
    } while (pGVar1 != (GtsObject *)0x0);
    if (object[1].flags != 0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/edge.c",0x23,0x816014d,"edge->triangles == NULL");
    }
  }
  pGVar3 = gts_edge_class();
                    // WARNING: Could not recover jumptable at 0x0811dc94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar3->parent_class).parent_class.parent_class)->destroy)();
  return;
}



void gts_edge_remove(GtsEdge *edge)

{
  GtsVertex *pGVar1;
  GSList *pGVar2;
  
  pGVar1 = (edge->segment).v1;
  pGVar2 = (GSList *)g_slist_remove(pGVar1->segments,edge);
  pGVar1->segments = pGVar2;
  pGVar1 = (edge->segment).v2;
  pGVar2 = (GSList *)g_slist_remove(pGVar1->segments,edge);
  pGVar1->segments = pGVar2;
  edge_destroy((GtsObject *)edge);
  return;
}



void edge_clone(GtsObject *clone,GtsObject *object)

{
  GtsEdgeClass *pGVar1;
  
  pGVar1 = gts_edge_class();
  (*((pGVar1->parent_class).parent_class.parent_class)->clone)(clone,object);
  clone[1].reserved = (gpointer)0x0;
  clone[1].klass = (GtsObjectClass *)0x0;
  clone[1].flags = 0;
  return;
}



GtsFace * gts_edge_has_any_parent_surface(GtsEdge *e)

{
  GSList *pGVar1;
  GtsFace *pGVar2;
  char "gts_edge_has_any_parent_surface" [32];
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_has_any_parent_surface",0x815fd6c);
    return (GtsFace *)0x0;
  }
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsFace *)0x0;
    }
    pGVar2 = (GtsFace *)pGVar1->data;
    pGVar3 = (GtsObjectClass *)gts_face_class();
    if (pGVar3 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else {
      if (pGVar2 != (GtsFace *)0x0) {
        pGVar4 = (pGVar2->triangle).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        }
        else {
          do {
            if (pGVar3 == pGVar4) {
              if ((&pGVar2->triangle)[1].object.klass != (GtsObjectClass *)0x0) {
                return pGVar2;
              }
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Type propagation algorithm not settling

gboolean gts_edge_belongs_to_tetrahedron(GtsEdge *e)

{
  GtsTriangle *pGVar1;
  char "gts_edge_belongs_to_tetrahedron" [32];
  GtsEdge *e3;
  GtsObjectClass *pGVar2;
  GtsTriangle *pGVar3;
  GtsObjectClass *pGVar4;
  GSList *local_40;
  GtsVertex *local_34;
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsEdge *local_24;
  GtsEdge *local_20 [4];
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_belongs_to_tetrahedron",0x815fd6c);
  }
  else {
    local_40 = e->triangles;
    if (local_40 != (GSList *)0x0) {
      do {
        pGVar1 = (GtsTriangle *)(&local_40->data)[1];
        triangle_vertices_edges((GtsTriangle *)local_40->data,e,&local_28,local_20,&local_24);
        while (pGVar1 != (GtsTriangle *)0x0) {
          triangle_vertices_edges(*(GtsTriangle **)&pGVar1->object,e,&local_34,&local_2c,&local_30);
          e3 = (GtsEdge *)gts_vertices_are_connected(local_28,local_34);
          pGVar2 = (GtsObjectClass *)gts_edge_class();
          if (pGVar2 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else {
            if (e3 != (GtsEdge *)0x0) {
              pGVar4 = (e3->segment).object.klass;
              if (pGVar4 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar2 == pGVar4) {
                    pGVar3 = gts_triangle_use_edges(local_20[0],local_2c,e3);
                    if ((pGVar3 != (GtsTriangle *)0x0) &&
                       (pGVar3 = gts_triangle_use_edges(local_24,local_30,e3),
                       pGVar3 != (GtsTriangle *)0x0)) {
                      return 1;
                    }
                    break;
                  }
                  pGVar4 = pGVar4->parent_class;
                } while (pGVar4 != (GtsObjectClass *)0x0);
              }
            }
          }
          pGVar1 = *(GtsTriangle **)((int)&pGVar1->object + 4);
        }
        local_40 = (GSList *)(&local_40->data)[1];
      } while (local_40 != (GSList *)0x0);
    }
  }
  return 0;
}



gboolean gts_edge_manifold_faces(GtsEdge *e,GtsSurface *s,GtsFace **f1,GtsFace **f2)

{
  GtsFace *f;
  char "gts_edge_manifold_faces" [24];
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *pGVar3;
  GSList *pGVar4;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x8160000,0x815fd6c);
  }
  else {
    if (s == (GtsSurface *)0x0) {
      g_return_if_fail_warning(0,0x8160000,0x815fd1b);
    }
    else {
      if (f1 == (GtsFace **)0x0) {
        g_return_if_fail_warning(0,0x8160000,"f1 != NULL");
      }
      else {
        if (f2 != (GtsFace **)0x0) {
          pGVar4 = e->triangles;
          *f2 = (GtsFace *)0x0;
          *f1 = (GtsFace *)0x0;
          if (pGVar4 != (GSList *)0x0) {
            do {
              pGVar1 = (GtsObjectClass *)gts_face_class();
              f = (GtsFace *)pGVar4->data;
              if (pGVar1 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
              }
              else {
                if (f != (GtsFace *)0x0) {
                  pGVar3 = (f->triangle).object.klass;
                  if (pGVar3 == (GtsObjectClass *)0x0) {
                    g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                  }
                  else {
                    do {
                      if (pGVar1 == pGVar3) {
                        gVar2 = gts_face_has_parent_surface(f,s);
                        if (gVar2 != 0) {
                          if (*f1 == (GtsFace *)0x0) {
                            *f1 = (GtsFace *)pGVar4->data;
                          }
                          else {
                            if (*f2 != (GtsFace *)0x0) {
                              return 0;
                            }
                            *f2 = (GtsFace *)pGVar4->data;
                          }
                        }
                        break;
                      }
                      pGVar3 = pGVar3->parent_class;
                    } while (pGVar3 != (GtsObjectClass *)0x0);
                  }
                }
              }
              pGVar4 = (GSList *)(&pGVar4->data)[1];
            } while (pGVar4 != (GSList *)0x0);
            if (*f1 != (GtsFace *)0x0) {
              return (uint)(*f2 != (GtsFace *)0x0);
            }
          }
          return 0;
        }
        g_return_if_fail_warning(0,"gts_edge_manifold_faces","f2 != NULL");
      }
    }
  }
  return 0;
}



guint gts_edge_face_number(GtsEdge *e,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *f;
  char "gts_edge_face_number" [21];
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *pGVar4;
  guint gVar5;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_face_number",0x815fd6c);
    return 0;
  }
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x81600ae,0x815fd1b);
    return 0;
  }
  pGVar1 = e->triangles;
  gVar5 = 0;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return gVar5;
    }
    pGVar2 = (GtsObjectClass *)gts_face_class();
    f = (GtsFace *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else {
      if (f != (GtsFace *)0x0) {
        pGVar4 = (f->triangle).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        }
        else {
          do {
            if (pGVar2 == pGVar4) {
              gVar3 = gts_face_has_parent_surface(f,s);
              gVar5 = (gVar5 + 1) - (uint)(gVar3 == 0);
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



GtsFace * gts_edge_is_boundary(GtsEdge *e,GtsSurface *surface)

{
  GtsFace *f;
  char "gts_edge_is_boundary" [21];
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *pGVar3;
  GSList *pGVar4;
  GtsFace *pGVar5;
  
  if (e == (GtsEdge *)0x0) {
    pGVar5 = (GtsFace *)0x0;
    g_return_if_fail_warning(0,"gts_edge_is_boundary",0x815fd6c);
  }
  else {
    pGVar4 = e->triangles;
    if (pGVar4 == (GSList *)0x0) {
LAB_0811e30a:
      pGVar5 = (GtsFace *)0x0;
    }
    else {
      pGVar5 = (GtsFace *)0x0;
      do {
        pGVar1 = (GtsObjectClass *)gts_face_class();
        f = (GtsFace *)pGVar4->data;
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (f != (GtsFace *)0x0) {
            pGVar3 = (f->triangle).object.klass;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            }
            else {
              do {
                if (pGVar1 == pGVar3) {
                  if (surface != (GtsSurface *)0x0) {
                    gVar2 = gts_face_has_parent_surface(f,surface);
                    if (gVar2 == 0) break;
                  }
                  if (pGVar5 != (GtsFace *)0x0) goto LAB_0811e30a;
                  pGVar5 = (GtsFace *)pGVar4->data;
                  break;
                }
                pGVar3 = pGVar3->parent_class;
              } while (pGVar3 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar4 = (GSList *)(&pGVar4->data)[1];
      } while (pGVar4 != (GSList *)0x0);
    }
  }
  return pGVar5;
}



GtsFace * gts_edge_has_parent_surface(GtsEdge *e,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsFace *f;
  char "gts_edge_has_parent_surface" [28];
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *pGVar4;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_has_parent_surface",0x815fd6c);
    return (GtsFace *)0x0;
  }
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsFace *)0x0;
    }
    pGVar2 = (GtsObjectClass *)gts_face_class();
    f = (GtsFace *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    }
    else {
      if (f != (GtsFace *)0x0) {
        pGVar4 = (f->triangle).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        }
        else {
          do {
            if (pGVar2 == pGVar4) {
              gVar3 = gts_face_has_parent_surface(f,surface);
              if (gVar3 != 0) {
                return (GtsFace *)pGVar1->data;
              }
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



// WARNING: Type propagation algorithm not settling

GSList * gts_edges_from_vertices(GSList *vertices,GtsSurface *parent)

{
  GtsEdge *pGVar1;
  GtsEdge *e;
  char "gts_edges_from_vertices" [24];
  undefined4 uVar2;
  GtsObjectClass *pGVar3;
  GtsFace *pGVar4;
  int iVar5;
  GtsObjectClass *pGVar6;
  GSList *local_24;
  GSList *local_20;
  
  if (parent == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_edges_from_vertices","parent != NULL");
    local_24 = (GSList *)0x0;
  }
  else {
    uVar2 = g_hash_table_new(0,0);
    local_24 = (GSList *)0x0;
    if (vertices != (GSList *)0x0) {
      local_20 = vertices;
      do {
        pGVar1 = *(GtsEdge **)((int)local_20->data + 0x24);
        while (pGVar1 != (GtsEdge *)0x0) {
          e = *(GtsEdge **)&pGVar1->segment;
          pGVar3 = (GtsObjectClass *)gts_edge_class();
          if (pGVar3 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else {
            if (e != (GtsEdge *)0x0) {
              pGVar6 = (e->segment).object.klass;
              if (pGVar6 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar3 == pGVar6) {
                    pGVar4 = gts_edge_has_parent_surface(e,parent);
                    if ((pGVar4 != (GtsFace *)0x0) &&
                       (iVar5 = g_hash_table_lookup(uVar2,e), iVar5 == 0)) {
                      local_24 = (GSList *)g_slist_prepend(local_24,e);
                      g_hash_table_insert(uVar2,e,local_20);
                    }
                    break;
                  }
                  pGVar6 = pGVar6->parent_class;
                } while (pGVar6 != (GtsObjectClass *)0x0);
              }
            }
          }
          pGVar1 = *(GtsEdge **)((int)&pGVar1->segment + 4);
        }
        local_20 = local_20->next;
      } while (local_20 != (GSList *)0x0);
    }
    g_hash_table_destroy(uVar2);
  }
  return local_24;
}



// WARNING: Type propagation algorithm not settling

GtsEdge * gts_edge_is_duplicate(GtsEdge *e)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsObjectClass *pGVar3;
  GtsEdge *pGVar4;
  char "gts_edge_is_duplicate" [22];
  GtsObjectClass *pGVar5;
  GtsObjectClass *pGVar6;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_is_duplicate",0x815fd6c);
    return (GtsEdge *)0x0;
  }
  pGVar1 = (e->segment).v2;
  pGVar2 = (e->segment).v1;
  pGVar3 = (&pGVar2->p)[1].object.klass;
  if (pGVar1 == pGVar2) {
    while (pGVar3 != (GtsObjectClass *)0x0) {
      pGVar4 = *(GtsEdge **)(pGVar3->info).name;
      if (e != pGVar4) {
        pGVar5 = (GtsObjectClass *)gts_edge_class();
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (pGVar4 != (GtsEdge *)0x0) {
            pGVar6 = (pGVar4->segment).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            }
            else {
              do {
                if (pGVar5 == pGVar6) {
                  if (((pGVar4->segment).v1 == pGVar1) && (pGVar1 == (pGVar4->segment).v2)) {
                    return pGVar4;
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
        }
      }
      pGVar3 = *(GtsObjectClass **)((pGVar3->info).name + 4);
    }
  }
  else {
    while (pGVar3 != (GtsObjectClass *)0x0) {
      pGVar4 = *(GtsEdge **)(pGVar3->info).name;
      if (e != pGVar4) {
        pGVar5 = (GtsObjectClass *)gts_edge_class();
        if (pGVar5 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (pGVar4 != (GtsEdge *)0x0) {
            pGVar6 = (pGVar4->segment).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            }
            else {
              do {
                if (pGVar5 == pGVar6) {
                  if (((pGVar4->segment).v1 == pGVar1) || ((pGVar4->segment).v2 == pGVar1)) {
                    return pGVar4;
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
        }
      }
      pGVar3 = *(GtsObjectClass **)((pGVar3->info).name + 4);
    }
  }
  return (GtsEdge *)0x0;
}



GList * gts_edges_merge(GList *edges)

{
  GList *pGVar1;
  GtsEdge *e;
  gpointer *ppvVar2;
  GtsEdge *with;
  GList *pGVar3;
  
  gts_allow_floating_edges = 1;
  pGVar3 = edges;
  if (edges != (GList *)0x0) {
    do {
      while( true ) {
        e = (GtsEdge *)pGVar3->data;
        with = gts_edge_is_duplicate(e);
        if (with != (GtsEdge *)0x0) break;
        ppvVar2 = &pGVar3->data;
        pGVar3 = (GList *)ppvVar2[1];
        if ((GList *)ppvVar2[1] == (GList *)0x0) {
          gts_allow_floating_edges = 0;
          return edges;
        }
      }
      pGVar1 = (GList *)(&pGVar3->data)[1];
      edges = (GList *)g_list_remove_link(edges,pGVar3);
      g_list_free_1(pGVar3);
      gts_edge_replace(e,with);
      gts_object_destroy((GtsObject *)e);
      pGVar3 = pGVar1;
    } while (pGVar1 != (GList *)0x0);
  }
  gts_allow_floating_edges = 0;
  return edges;
}



void gts_edge_swap(GtsEdge *e,GtsSurface *s)

{
  char "gts_edge_swap" [14];
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  guint gVar3;
  GtsFace *f;
  GtsFace *pGVar4;
  GtsObjectClass *pGVar5;
  GSList *pGVar6;
  GtsEdge *e2;
  GtsFace *f_00;
  GtsFace *local_54;
  GtsFace *local_50;
  GtsEdge *local_44;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  GtsEdge *local_38;
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x8160031,0x815fd6c);
  }
  else {
    if (s != (GtsSurface *)0x0) {
      pGVar6 = e->triangles;
      if (pGVar6 != (GSList *)0x0) {
        f_00 = (GtsFace *)0x0;
        local_50 = (GtsFace *)0x0;
        do {
          while( true ) {
            pGVar1 = (GtsObjectClass *)gts_face_class();
            f = (GtsFace *)pGVar6->data;
            if (pGVar1 == (GtsObjectClass *)0x0) break;
            if (f != (GtsFace *)0x0) {
              pGVar5 = (f->triangle).object.klass;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar1 == pGVar5) {
                    gVar2 = gts_face_has_parent_surface(f,s);
                    if (gVar2 != 0) {
                      if (f_00 == (GtsFace *)0x0) {
                        f_00 = (GtsFace *)pGVar6->data;
                        pGVar6 = (GSList *)(&pGVar6->data)[1];
                        goto joined_r0x0811e987;
                      }
                      if (local_50 == (GtsFace *)0x0) {
                        local_50 = (GtsFace *)pGVar6->data;
                        pGVar6 = (GSList *)(&pGVar6->data)[1];
                        goto joined_r0x0811e972;
                      }
                      gVar3 = gts_edge_face_number(e,s);
                      if (gVar3 != 2) {
                        g_return_if_fail_warning
                                  (0,"gts_edge_swap","gts_edge_face_number (e, s) == 2");
                        return;
                      }
                    }
                    break;
                  }
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
            pGVar6 = (GSList *)(&pGVar6->data)[1];
joined_r0x0811e987:
            if (pGVar6 == (GSList *)0x0) goto LAB_0811e84b;
          }
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar6 = (GSList *)(&pGVar6->data)[1];
joined_r0x0811e972:
        } while (pGVar6 != (GSList *)0x0);
LAB_0811e84b:
        if ((local_50 != (GtsFace *)0x0) && (f_00 != (GtsFace *)0x0)) {
          gts_triangle_vertices_edges
                    ((GtsTriangle *)f_00,e,local_20,&local_24,&local_28,&e,&local_38,&local_3c);
          gts_triangle_vertices_edges
                    ((GtsTriangle *)local_50,e,&local_2c,&local_30,&local_34,&e,&local_40,&local_44)
          ;
          if ((local_24 != local_2c) || (local_20[0] != local_30)) {
                    // WARNING: Subroutine does not return
            g_assertion_message_expr
                      (0,"../../src/gts/edge.c",0x20e,0x8160031,"v2 == v4 && v1 == v5");
          }
          e2 = (GtsEdge *)gts_vertices_are_connected(local_28,local_34);
          pGVar1 = (GtsObjectClass *)gts_edge_class();
          if (pGVar1 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          }
          else {
            if (e2 != (GtsEdge *)0x0) {
              pGVar5 = (e2->segment).object.klass;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar1 == pGVar5) goto LAB_0811e9ea;
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
          }
          e2 = (GtsEdge *)gts_segment_new((GtsSegmentClass *)s->edge_class,local_28,local_34);
LAB_0811e9ea:
          local_54 = gts_face_new(s->face_class,local_38,e2,local_44);
          f = (GtsFace *)gts_triangle_is_duplicate((GtsTriangle *)local_54);
          if (f != (GtsFace *)0x0) {
            pGVar1 = (GtsObjectClass *)gts_face_class();
            if (pGVar1 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            }
            else {
              pGVar5 = (f->triangle).object.klass;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar1 == pGVar5) {
                    gts_object_destroy((GtsObject *)local_54);
                    local_54 = f;
                    break;
                  }
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
          }
          gts_surface_add_face(s,local_54);
          f = gts_face_new(s->face_class,e2,local_3c,local_40);
          pGVar4 = (GtsFace *)gts_triangle_is_duplicate((GtsTriangle *)f);
          if (pGVar4 != (GtsFace *)0x0) {
            pGVar1 = (GtsObjectClass *)gts_face_class();
            if (pGVar1 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            }
            else {
              pGVar5 = (pGVar4->triangle).object.klass;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar1 == pGVar5) {
                    gts_object_destroy((GtsObject *)f);
                    f = pGVar4;
                    break;
                  }
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
          }
          gts_surface_add_face(s,f);
          gts_surface_remove_face(s,f_00);
          gts_surface_remove_face(s,local_50);
          return;
        }
      }
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/edge.c",0x20a,0x8160031,"t1 && t2");
    }
    g_return_if_fail_warning(0,0x8160031,0x815fd1b);
  }
  return;
}



void triangle_class_init(GtsObjectClass *klass)

{
  klass->destroy = triangle_destroy;
  return;
}



void triangle_init(GtsTriangle *triangle)

{
  triangle->e3 = (GtsEdge *)0x0;
  triangle->e2 = (GtsEdge *)0x0;
  triangle->e1 = (GtsEdge *)0x0;
  return;
}



// WARNING: Removing unreachable block (ram,0x0811eccf)

void gts_triangle_interpolate_height(GtsTriangle *t,GtsPoint *p)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  char "gts_triangle_interpolate_height" [32];
  GtsVertex *pGVar10;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_interpolate_height",0x815f901);
    return;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,0x8160600,0x816106f);
    return;
  }
  pGVar1 = (t->e1->segment).v1;
  pGVar10 = (t->e2->segment).v1;
  pGVar2 = (t->e1->segment).v2;
  if ((pGVar1 == pGVar10) || (pGVar2 == pGVar10)) {
    pGVar10 = (t->e2->segment).v2;
  }
  dVar5 = (double)(pGVar1->p).x;
  dVar3 = (double)(pGVar2->p).x - dVar5;
  dVar9 = (double)(pGVar1->p).y;
  dVar7 = (double)(pGVar2->p).y - dVar9;
  dVar4 = (double)(pGVar10->p).x - dVar5;
  dVar8 = (double)(pGVar10->p).y - dVar9;
  dVar6 = dVar3 * dVar8 - dVar4 * dVar7;
  if (dVar6 != 0.00000000) {
    dVar5 = (double)p->x - dVar5;
    dVar9 = (double)p->y - dVar9;
    dVar4 = (dVar8 * dVar5 - dVar4 * dVar9) / dVar6;
    dVar6 = dVar6 / (dVar9 * dVar3 - dVar5 * dVar7);
    *(double *)&p->z =
         dVar6 * (double)(pGVar10->p).z +
         dVar4 * (double)(pGVar2->p).z + ((1.00000000 - dVar4) - dVar6) * (double)(pGVar1->p).z;
    return;
  }
  *(double *)&p->z =
       ((double)(pGVar1->p).z + (double)(pGVar2->p).z + (double)(pGVar10->p).z) / 3.00000000;
  return;
}



void gts_triangle_vertices(GtsTriangle *t,GtsVertex **v1,GtsVertex **v2,GtsVertex **v3)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  
  if ((((t != (GtsTriangle *)0x0) && (v2 != (GtsVertex **)0x0)) && (v1 != (GtsVertex **)0x0)) &&
     (v3 != (GtsVertex **)0x0)) {
    pGVar1 = t->e1;
    pGVar2 = t->e2;
    pGVar3 = (pGVar1->segment).v2;
    pGVar4 = (pGVar2->segment).v1;
    if (pGVar3 == pGVar4) {
      *v1 = (pGVar1->segment).v1;
      *v2 = (pGVar1->segment).v2;
      *v3 = (pGVar2->segment).v2;
    }
    else {
      if (pGVar3 == (pGVar2->segment).v2) {
        *v1 = (pGVar1->segment).v1;
        *v2 = (pGVar1->segment).v2;
        *v3 = (pGVar2->segment).v1;
      }
      else {
        if (pGVar4 == (pGVar1->segment).v1) {
          *v1 = pGVar3;
          *v2 = (pGVar1->segment).v1;
          *v3 = (pGVar2->segment).v2;
        }
        else {
          *v1 = pGVar3;
          *v2 = (pGVar1->segment).v1;
          *v3 = (pGVar2->segment).v1;
        }
      }
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



GtsTriangle * gts_triangle_use_edges(GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GSList *pGVar1;
  GtsTriangle *pGVar2;
  GtsEdge *pGVar3;
  char "gts_triangle_use_edges" [23];
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  
  if (e1 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_use_edges",0x816015d);
    return (GtsTriangle *)0x0;
  }
  if (e2 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x81606ca,0x816016b);
    return (GtsTriangle *)0x0;
  }
  if (e3 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x81606ca,0x8160179);
    return (GtsTriangle *)0x0;
  }
  pGVar1 = e1->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsTriangle *)0x0;
    }
    pGVar2 = (GtsTriangle *)pGVar1->data;
    pGVar3 = pGVar2->e1;
    if (pGVar3 == e2) {
      pGVar4 = pGVar2->e2;
      if (pGVar4 == e3) {
        return pGVar2;
      }
      if (pGVar2->e3 == e3) {
        return pGVar2;
      }
    }
    else {
      pGVar4 = pGVar2->e2;
    }
    if (pGVar4 == e2) {
      if (e3 == pGVar3) {
        return pGVar2;
      }
      pGVar5 = pGVar2->e3;
      if (pGVar5 == e3) {
        return pGVar2;
      }
    }
    else {
      pGVar5 = pGVar2->e3;
    }
    if (e2 == pGVar5) {
      if (e3 == pGVar3) {
        return pGVar2;
      }
      if (pGVar4 == e3) {
        return pGVar2;
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



GtsTriangle * gts_triangle_is_duplicate(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GSList *pGVar3;
  GtsTriangle *pGVar4;
  char "gts_triangle_is_duplicate" [26];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_duplicate",0x815f901);
    return (GtsTriangle *)0x0;
  }
  pGVar1 = t->e2;
  pGVar2 = t->e3;
  pGVar3 = t->e1->triangles;
  do {
    if (pGVar3 == (GSList *)0x0) {
      return (GtsTriangle *)0x0;
    }
    pGVar4 = (GtsTriangle *)pGVar3->data;
    if ((pGVar4 != t) &&
       (((pGVar4->e1 == pGVar1 || (pGVar4->e2 == pGVar1)) || (pGVar4->e3 == pGVar1)))) {
      if (pGVar2 == pGVar4->e1) {
        return pGVar4;
      }
      if (pGVar4->e2 == pGVar2) {
        return pGVar4;
      }
      if (pGVar4->e3 == pGVar2) {
        return pGVar4;
      }
    }
    pGVar3 = (GSList *)(&pGVar3->data)[1];
  } while( true );
}



gboolean gts_triangle_is_ok(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsEdge *pGVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  GtsVertex *pGVar7;
  GtsVertex *pGVar8;
  char "gts_triangle_is_ok" [19];
  gboolean gVar9;
  GtsTriangle *pGVar10;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x81606b7,0x815f901);
    return 0;
  }
  pGVar1 = t->e1;
  if (pGVar1 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x81606b7,"t->e1 != NULL");
    return 0;
  }
  pGVar2 = t->e2;
  if (pGVar2 == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x81606b7,"t->e2 != NULL");
    return 0;
  }
  pGVar3 = t->e3;
  if (pGVar3 != (GtsEdge *)0x0) {
    if (((pGVar1 == pGVar2) || (pGVar1 == pGVar3)) || (pGVar2 == pGVar3)) {
      g_return_if_fail_warning(0,0x81606b7,"t->e1 != t->e2 && t->e1 != t->e3 && t->e2 != t->e3");
      return 0;
    }
    pGVar4 = (pGVar1->segment).v1;
    pGVar5 = (pGVar2->segment).v1;
    if (((pGVar4 != pGVar5) && (pGVar6 = (pGVar2->segment).v2, pGVar4 != pGVar6)) &&
       ((pGVar7 = (pGVar1->segment).v2, pGVar5 != pGVar7 && (pGVar6 != pGVar7)))) {
      g_return_if_fail_warning
                (0,"gts_triangle_is_ok",
                 "gts_segments_touch (GTS_SEGMENT (t->e1), GTS_SEGMENT (t->e2))");
      return 0;
    }
    pGVar6 = (pGVar3->segment).v1;
    if (((pGVar4 != pGVar6) && (pGVar7 = (pGVar3->segment).v2, pGVar4 != pGVar7)) &&
       ((pGVar8 = (pGVar1->segment).v2, pGVar6 != pGVar8 && (pGVar7 != pGVar8)))) {
      g_return_if_fail_warning
                (0,0x81606b7,"gts_segments_touch (GTS_SEGMENT (t->e1), GTS_SEGMENT (t->e3))");
      return 0;
    }
    if ((((pGVar5 != pGVar6) && (pGVar7 = (pGVar3->segment).v2, pGVar5 != pGVar7)) &&
        (pGVar8 = (pGVar2->segment).v2, pGVar6 != pGVar8)) && (pGVar7 != pGVar8)) {
      g_return_if_fail_warning
                (0,0x81606b7,"gts_segments_touch (GTS_SEGMENT (t->e2), GTS_SEGMENT (t->e3))");
      return 0;
    }
    if (pGVar4 == (pGVar1->segment).v2) {
      g_return_if_fail_warning(0,0x81606b7,"GTS_SEGMENT (t->e1)->v1 != GTS_SEGMENT (t->e1)->v2");
      gVar9 = 0;
    }
    else {
      if (pGVar5 == (pGVar2->segment).v2) {
        g_return_if_fail_warning(0,0x81606b7,"GTS_SEGMENT (t->e2)->v1 != GTS_SEGMENT (t->e2)->v2");
        gVar9 = 0;
      }
      else {
        if (pGVar6 == (pGVar3->segment).v2) {
          g_return_if_fail_warning(0,0x81606b7,"GTS_SEGMENT (t->e3)->v1 != GTS_SEGMENT (t->e3)->v2")
          ;
          gVar9 = 0;
        }
        else {
          if ((t->object).reserved == (gpointer)0x0) {
            pGVar10 = gts_triangle_is_duplicate(t);
            if (pGVar10 == (GtsTriangle *)0x0) {
              gVar9 = 1;
            }
            else {
              g_return_if_fail_warning(0,0x81606b7,"!gts_triangle_is_duplicate (t)");
              gVar9 = 0;
            }
          }
          else {
            g_return_if_fail_warning(0,0x81606b7,"GTS_OBJECT (t)->reserved == NULL");
            gVar9 = 0;
          }
        }
      }
    }
    return gVar9;
  }
  g_return_if_fail_warning(0,0x81606b7,"t->e3 != NULL");
  return 0;
}



GtsEdge * gts_triangles_common_edge(GtsTriangle *t1,GtsTriangle *t2)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsEdge *pGVar3;
  char "gts_triangles_common_edge" [26];
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  
  if (t1 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_common_edge","t1 != NULL");
    return (GtsEdge *)0x0;
  }
  if (t2 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x81606fb,0x8160209);
    return (GtsEdge *)0x0;
  }
  pGVar4 = t1->e1;
  pGVar1 = t2->e1;
  if (((pGVar4 != pGVar1) && (pGVar2 = t2->e2, pGVar4 != pGVar2)) &&
     (pGVar5 = t2->e3, pGVar4 != pGVar5)) {
    pGVar3 = t1->e2;
    if (pGVar1 == pGVar3) {
      return pGVar1;
    }
    pGVar4 = pGVar2;
    if ((pGVar2 != pGVar3) && (pGVar4 = pGVar5, pGVar5 != pGVar3)) {
      pGVar3 = t1->e3;
      if (pGVar1 == pGVar3) {
        return pGVar1;
      }
      pGVar4 = pGVar2;
      if (pGVar2 != pGVar3) {
        if (pGVar5 != pGVar3) {
          pGVar5 = (GtsEdge *)0x0;
        }
        return pGVar5;
      }
    }
  }
  return pGVar4;
}



guint gts_triangle_neighbor_number(GtsTriangle *t)

{
  GSList *pGVar1;
  GtsTriangle **ppGVar2;
  char "gts_triangle_neighbor_number" [29];
  GtsEdge **ppGVar3;
  guint gVar4;
  GtsEdge *ee [4];
  
  if (t == (GtsTriangle *)0x0) {
    gVar4 = 0;
    g_return_if_fail_warning(0,"gts_triangle_neighbor_number",0x815f901);
  }
  else {
    ppGVar3 = ee;
    gVar4 = 0;
    ee[0] = t->e1;
    ee[1] = t->e2;
    ee[3] = (GtsEdge *)0x0;
    ee[2] = t->e3;
    while (*ppGVar3 != (GtsEdge *)0x0) {
      pGVar1 = (*ppGVar3)->triangles;
      while (pGVar1 != (GSList *)0x0) {
        ppGVar2 = (GtsTriangle **)&pGVar1->data;
        pGVar1 = pGVar1->next;
        gVar4 = gVar4 + (*ppGVar2 != t);
      }
      ppGVar3 = ppGVar3 + 1;
    }
  }
  return gVar4;
}



void gts_triangle_revert(GtsTriangle *t)

{
  GtsEdge *pGVar1;
  char "gts_triangle_revert" [20];
  
  if (t != (GtsTriangle *)0x0) {
    pGVar1 = t->e2;
    t->e2 = t->e1;
    t->e1 = pGVar1;
    return;
  }
  g_return_if_fail_warning(0,"gts_triangle_revert",0x815f901);
  return;
}



GtsEdge * gts_triangle_edge_opposite(GtsTriangle *t,GtsVertex *v)

{
  GtsEdge *pGVar1;
  char "gts_triangle_edge_opposite" [27];
  GtsEdge *pGVar2;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_edge_opposite",0x815f901);
    return (GtsEdge *)0x0;
  }
  if (v != (GtsVertex *)0x0) {
    pGVar2 = t->e1;
    pGVar1 = t->e2;
    if (((pGVar2->segment).v1 == v) || ((pGVar2->segment).v2 == v)) {
      if ((((pGVar1->segment).v1 == v) || (pGVar2 = pGVar1, (pGVar1->segment).v2 == v)) &&
         ((pGVar2 = t->e3, (pGVar2->segment).v1 == v || ((pGVar2->segment).v2 == v)))) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr(0,"../../src/gts/triangle.c",0xd7,0x8160815,&DAT_0816018f);
      }
    }
    else {
      if (((pGVar1->segment).v1 != v) && ((pGVar1->segment).v2 != v)) {
        return (GtsEdge *)0x0;
      }
    }
    return pGVar2;
  }
  g_return_if_fail_warning(0,0x8160815,"v != NULL");
  return (GtsEdge *)0x0;
}



GtsVertex * __regparm3 triangle_use_vertices(GtsTriangle *t,GtsVertex *A,GtsVertex *B)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  char "triangle_use_vertices" [22];
  GtsVertex *pGVar3;
  
  pGVar1 = (t->e1->segment).v1;
  pGVar3 = (t->e2->segment).v1;
  pGVar2 = (t->e1->segment).v2;
  if ((pGVar1 == pGVar3) || (pGVar2 == pGVar3)) {
    pGVar3 = (t->e2->segment).v2;
  }
  if (pGVar1 == A) {
    if ((pGVar2 != B) && (pGVar3 = pGVar2, pGVar3 != B)) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/triangle.c",0x39e,0x8160651,"v3 == B");
    }
  }
  else {
    if (pGVar2 == A) {
      if ((pGVar1 != B) && (pGVar3 = pGVar1, pGVar3 != B)) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr(0,"../../src/gts/triangle.c",0x3a4,0x8160651,"v3 == B");
      }
    }
    else {
      if (pGVar3 != A) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x3ad,0x8160651,0);
      }
      pGVar3 = pGVar2;
      if ((pGVar1 != B) && (pGVar3 = pGVar1, pGVar2 != B)) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr
                  (0,"../../src/gts/triangle.c",0x3aa,"triangle_use_vertices","v2 == B");
      }
    }
  }
  return pGVar3;
}



// WARNING: Type propagation algorithm not settling

gboolean gts_triangles_are_folded(GSList *triangles,GtsVertex *A,GtsVertex *B,gdouble max)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  char "gts_triangles_are_folded" [25];
  GtsVertex *pGVar11;
  GtsVertex *pGVar12;
  GSList *local_44;
  GtsTriangle *local_40;
  
  if (A == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_folded","A != NULL");
    return 1;
  }
  if (B == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,0x8160638,"B != NULL");
    return 1;
  }
  if (triangles != (GSList *)0x0) {
    local_44 = triangles;
    do {
      pGVar11 = triangle_use_vertices((GtsTriangle *)local_44->data,A,B);
      local_40 = (GtsTriangle *)(&local_44->data)[1];
      if (local_40 == (GtsTriangle *)0x0) {
        return 0;
      }
      do {
        pGVar12 = triangle_use_vertices(*(GtsTriangle **)&local_40->object,A,B);
        dVar3 = (double)(A->p).x;
        dVar1 = (double)(B->p).x - dVar3;
        dVar4 = (double)(A->p).y;
        dVar9 = (double)(B->p).y - dVar4;
        dVar6 = (double)(A->p).z;
        dVar10 = (double)(B->p).z - dVar6;
        dVar2 = (double)(pGVar11->p).x - dVar3;
        dVar8 = (double)(pGVar11->p).y - dVar4;
        dVar5 = (double)(pGVar11->p).z - dVar6;
        dVar3 = (double)(pGVar12->p).x - dVar3;
        dVar4 = (double)(pGVar12->p).y - dVar4;
        dVar6 = (double)(pGVar12->p).z - dVar6;
        dVar7 = dVar9 * dVar5 - dVar10 * dVar8;
        dVar5 = dVar2 * dVar10 - dVar5 * dVar1;
        dVar8 = dVar8 * dVar1 - dVar2 * dVar9;
        dVar2 = dVar4 * dVar10 - dVar9 * dVar6;
        dVar6 = dVar6 * dVar1 - dVar10 * dVar3;
        dVar3 = dVar9 * dVar3 - dVar1 * dVar4;
        dVar4 = dVar8 * dVar8 + dVar5 * dVar5 + dVar7 * dVar7;
        dVar1 = dVar3 * dVar3 + dVar6 * dVar6 + dVar2 * dVar2;
        if (dVar1 * 100000000.00000000 <= dVar4) {
          return 1;
        }
        if (dVar4 * 100000000.00000000 <= dVar1) {
          return 1;
        }
        dVar3 = dVar3 * dVar8 + dVar2 * dVar7 + dVar6 * dVar5;
        if ((dVar3 <= 0.00000000) && ((double)max < (dVar3 * dVar3) / (dVar1 * dVar4))) {
          return 1;
        }
        local_40 = *(GtsTriangle **)((int)&local_40->object + 4);
      } while (local_40 != (GtsTriangle *)0x0);
      local_44 = (GSList *)(&local_44->data)[1];
    } while (local_44 != (GSList *)0x0);
  }
  return 0;
}



void gts_triangle_vertices_edges
               (GtsTriangle *t,GtsEdge *e,GtsVertex **v1,GtsVertex **v2,GtsVertex **v3,GtsEdge **e1,
               GtsEdge **e2,GtsEdge **e3)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  char "gts_triangle_vertices_edges" [28];
  GtsVertex *pGVar3;
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  GtsVertex *pGVar6;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  pGVar4 = t->e1;
  if ((e == (GtsEdge *)0x0) || (pGVar4 == e)) {
    *e1 = pGVar4;
    pGVar5 = t->e2;
    *e2 = pGVar5;
    *e3 = t->e3;
LAB_0811f98b:
    pGVar3 = (pGVar4->segment).v2;
    pGVar6 = (pGVar5->segment).v1;
    if (pGVar3 != pGVar6) goto LAB_0811f995;
LAB_0811fa08:
    *v1 = (pGVar4->segment).v1;
    pGVar3 = (pGVar4->segment).v2;
LAB_0811fa13:
    *v2 = pGVar3;
    *v3 = (pGVar5->segment).v2;
  }
  else {
    pGVar4 = t->e2;
    if (pGVar4 == e) {
      *e1 = pGVar4;
      pGVar5 = t->e3;
      *e2 = pGVar5;
      *e3 = t->e1;
      goto LAB_0811f98b;
    }
    pGVar4 = t->e3;
    if (pGVar4 != e) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",0x224,0x8160749,0);
    }
    *e1 = pGVar4;
    pGVar5 = t->e1;
    *e2 = pGVar5;
    *e3 = t->e2;
    pGVar3 = (pGVar4->segment).v2;
    pGVar6 = (pGVar5->segment).v1;
    if (pGVar3 == pGVar6) goto LAB_0811fa08;
LAB_0811f995:
    pGVar1 = (pGVar5->segment).v2;
    if (pGVar3 == pGVar1) {
      *v1 = (pGVar4->segment).v1;
      pGVar3 = (pGVar4->segment).v2;
    }
    else {
      pGVar2 = (pGVar4->segment).v1;
      if (pGVar6 == pGVar2) {
        *v1 = pGVar3;
        pGVar3 = (pGVar4->segment).v1;
        goto LAB_0811fa13;
      }
      if (pGVar1 != pGVar2) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x23c,"gts_triangle_vertices_edges",0);
      }
      *v1 = pGVar3;
      pGVar3 = (pGVar4->segment).v1;
    }
    *v2 = pGVar3;
    *v3 = (pGVar5->segment).v1;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0811fb97)
// WARNING: Removing unreachable block (ram,0x0811fc82)
// WARNING: Removing unreachable block (ram,0x0811fd67)

GtsObject * gts_triangle_is_stabbed(GtsTriangle *t,GtsPoint *p,gdouble *orientation)

{
  double dVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  char "gts_triangle_is_stabbed" [24];
  GtsVertex *pGVar4;
  float10 fVar5;
  float10 fVar6;
  float10 fVar7;
  float10 fVar8;
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_is_stabbed",0x815f901);
  }
  else {
    if (p == (GtsPoint *)0x0) {
      g_return_if_fail_warning(0,0x8160620,0x816106f);
    }
    else {
      gts_triangle_vertices_edges
                (t,(GtsEdge *)0x0,local_20,&local_24,&local_28,(GtsEdge **)&local_2c,
                 (GtsEdge **)&local_30,(GtsEdge **)&local_34);
      fVar5 = (float10)gts_point_orientation(local_20[0],local_24,local_28);
      if (fVar5 != (float10)0) {
        if (fVar5 < (float10)0) {
          pGVar2 = local_30;
          pGVar3 = local_24;
          local_30 = local_34;
          pGVar4 = local_20[0];
          local_34 = pGVar2;
          local_24 = local_20[0];
          local_20[0] = pGVar3;
        }
        else {
          pGVar4 = (GtsVertex *)0x0;
        }
        fVar5 = (float10)gts_point_orientation_3d(local_20[0],local_24,local_28,p);
        if ((float10)0 <= fVar5) {
          dVar1 = (double)(float10)0;
          fVar6 = (float10)gts_point_orientation(local_20[0],local_24,p);
          if ((float10)dVar1 <= fVar6) {
            fVar7 = (float10)gts_point_orientation(local_24,local_28,p);
            if ((float10)dVar1 <= fVar7) {
              fVar8 = (float10)gts_point_orientation(local_28,local_20[0],p);
              if ((float10)dVar1 <= fVar8) {
                if (orientation != (gdouble *)0x0) {
                  dVar1 = -(double)fVar5;
                  if (pGVar4 == (GtsVertex *)0x0) {
                    dVar1 = (double)fVar5;
                  }
                  *(double *)orientation = dVar1;
                }
                fVar5 = (float10)0;
                if ((float10)(double)fVar6 != fVar5) {
                  if ((float10)(double)fVar7 != fVar5) {
                    if (fVar5 == fVar8) {
                      return (GtsObject *)local_34;
                    }
                    return (GtsObject *)t;
                  }
                  if (fVar8 == fVar5) {
                    return (GtsObject *)local_28;
                  }
                  return (GtsObject *)local_30;
                }
                if ((float10)(double)fVar7 == fVar5) {
                  return (GtsObject *)local_24;
                }
                if (fVar8 == fVar5) {
                  return (GtsObject *)local_20[0];
                }
                return (GtsObject *)local_2c;
              }
            }
          }
        }
      }
    }
  }
  return (GtsObject *)0x0;
}



float10 gts_triangle_orientation(int t)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  char "gts_triangle_orientation" [25];
  int iVar5;
  int iVar6;
  unkbyte10 Var7;
  
  if (t == 0) {
    g_return_if_fail_warning(0,"gts_triangle_orientation",0x815f901);
    return (float10)0;
  }
  iVar5 = *(int *)(t + 0xc);
  iVar6 = *(int *)(t + 0x10);
  iVar1 = *(int *)(iVar5 + 0xc);
  iVar2 = *(int *)(iVar6 + 0xc);
  if (iVar1 == iVar2) {
    iVar5 = *(int *)(iVar5 + 0x10);
    iVar6 = *(int *)(iVar6 + 0x10);
  }
  else {
    iVar3 = *(int *)(iVar5 + 0x10);
    iVar4 = *(int *)(iVar6 + 0x10);
    iVar5 = iVar2;
    iVar6 = iVar3;
    if (((iVar3 != iVar4) && (iVar5 = iVar3, iVar6 = iVar2, iVar1 != iVar4)) &&
       (iVar5 = iVar4, iVar2 != iVar3)) {
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",0x1c5,0x8160779,0);
    }
  }
  Var7 = gts_point_orientation(iVar1,iVar6,iVar5);
  return (float10)Var7;
}



gboolean gts_triangles_are_compatible(GtsTriangle *t1,GtsTriangle *t2,GtsEdge *e)

{
  GtsVertex *pGVar1;
  char "gts_triangles_are_compatible" [29];
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsEdge *pGVar4;
  GtsEdge *pGVar5;
  
  if (t1 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangles_are_compatible","t1 != NULL");
    return 0;
  }
  if (t2 == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x81607e4,0x8160209);
    return 0;
  }
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x81607e4,0x815fd6c);
    return 0;
  }
  pGVar5 = t1->e1;
  if (pGVar5 == e) {
    pGVar5 = t1->e2;
  }
  else {
    if (t1->e2 == e) {
      pGVar5 = t1->e3;
    }
    else {
      if (t1->e3 != e) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x111,0x81607e4,0);
      }
    }
  }
  pGVar4 = t2->e1;
  if (pGVar4 == e) {
    pGVar4 = t2->e2;
    pGVar2 = (pGVar5->segment).v1;
    pGVar3 = (pGVar4->segment).v1;
    if (pGVar2 == pGVar3) {
      return 0;
    }
  }
  else {
    if (t2->e2 == e) {
      pGVar4 = t2->e3;
    }
    else {
      if (t2->e3 != e) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x116,0x81607e4,0);
      }
    }
    pGVar2 = (pGVar5->segment).v1;
    pGVar3 = (pGVar4->segment).v1;
    if (pGVar2 == pGVar3) {
      return 0;
    }
  }
  pGVar1 = (pGVar4->segment).v2;
  if ((pGVar2 != pGVar1) && (pGVar2 = (pGVar5->segment).v2, pGVar3 != pGVar2)) {
    return (uint)(pGVar1 != pGVar2);
  }
  return 0;
}



GtsVertex * gts_triangle_vertex_opposite(GtsTriangle *t,GtsEdge *e)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  char "gts_triangle_vertex_opposite" [29];
  GtsVertex *pGVar3;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_vertex_opposite",0x815f901);
    return (GtsVertex *)0x0;
  }
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x8160830,0x815fd6c);
    return (GtsVertex *)0x0;
  }
  pGVar1 = t->e1;
  if (pGVar1 == e) {
    pGVar3 = (t->e2->segment).v1;
    if (((pGVar1->segment).v1 == pGVar3) || ((pGVar1->segment).v2 == pGVar3)) {
      pGVar3 = (t->e2->segment).v2;
    }
  }
  else {
    pGVar2 = t->e2;
    if (pGVar2 == e) {
      pGVar3 = (pGVar1->segment).v1;
      if (((pGVar2->segment).v1 == pGVar3) || ((pGVar2->segment).v2 == pGVar3)) {
        pGVar3 = (pGVar1->segment).v2;
      }
    }
    else {
      pGVar1 = t->e3;
      if (pGVar1 != e) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0xba,0x8160830,0);
      }
      pGVar3 = (pGVar2->segment).v1;
      if (((pGVar1->segment).v1 == pGVar3) || ((pGVar1->segment).v2 == pGVar3)) {
        return (pGVar2->segment).v2;
      }
    }
  }
  return pGVar3;
}



GtsPoint * gts_triangle_circumcircle_center(GtsTriangle *t,GtsPointClass *point_class)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  char "gts_triangle_circumcircle_center" [33];
  GtsPoint *pGVar10;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_circumcircle_center",0x815f901);
    return (GtsPoint *)0x0;
  }
  if (point_class == (GtsPointClass *)0x0) {
    g_return_if_fail_warning(0,0x8160680,"point_class != NULL");
    return (GtsPoint *)0x0;
  }
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  dVar1 = (double)(local_10[0]->p).x;
  dVar2 = (double)(local_10[0]->p).y;
  dVar9 = ((double)(local_14->p).x + dVar1) * 0.50000000;
  dVar8 = ((double)(local_14->p).y + dVar2) * 0.50000000;
  dVar7 = ((double)(local_18->p).x + dVar1) * 0.50000000;
  dVar6 = ((double)(local_18->p).y + dVar2) * 0.50000000;
  dVar3 = (dVar9 - dVar1) * (dVar6 - dVar2);
  dVar5 = (dVar7 - dVar1) * (dVar8 - dVar2);
  dVar4 = dVar3 - dVar5;
  if (dVar4 != 0.00000000) {
    pGVar10 = gts_point_new(point_class,
                            (gdouble)((((dVar6 - dVar2) * (dVar8 - dVar2) * (dVar8 - dVar6) +
                                       dVar9 * dVar3) - dVar7 * dVar5) / dVar4),
                            (gdouble)(-((dVar5 * dVar8 +
                                        (dVar9 - dVar7) * (dVar7 - dVar1) * (dVar9 - dVar1)) -
                                       dVar6 * dVar3) / dVar4),0.00000000);
    return pGVar10;
  }
  return (GtsPoint *)0x0;
}



GSList * gts_triangle_neighbors(GtsTriangle *t)

{
  GSList *pGVar1;
  char "gts_triangle_neighbors" [23];
  GSList *pGVar2;
  GtsEdge **ppGVar3;
  GtsEdge *ee [4];
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_triangle_neighbors",0x815f901);
    pGVar2 = (GSList *)0x0;
  }
  else {
    ppGVar3 = ee;
    ee[0] = t->e1;
    ee[1] = t->e2;
    ee[3] = (GtsEdge *)0x0;
    ee[2] = t->e3;
    pGVar2 = (GSList *)0x0;
    while (*ppGVar3 != (GtsEdge *)0x0) {
      pGVar1 = (*ppGVar3)->triangles;
      while (pGVar1 != (GSList *)0x0) {
        if ((GtsTriangle *)pGVar1->data != t) {
          pGVar2 = (GSList *)g_slist_prepend(pGVar2,(GtsTriangle *)pGVar1->data);
        }
        pGVar1 = pGVar1->next;
      }
      ppGVar3 = ppGVar3 + 1;
    }
  }
  return pGVar2;
}



void gts_triangle_set(GtsTriangle *triangle,GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  char "gts_triangle_set" [17];
  GSList *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *local_20;
  
  if (((((e1 == (GtsEdge *)0x0) || (e2 == (GtsEdge *)0x0)) || (e3 == (GtsEdge *)0x0)) ||
      ((e1 == e3 || (e1 == e2)))) || (e2 == e3)) goto LAB_081203a7;
  pGVar1 = (e1->segment).v1;
  pGVar2 = (e2->segment).v1;
  triangle->e1 = e1;
  triangle->e2 = e2;
  triangle->e3 = e3;
  if (pGVar1 == pGVar2) {
    pGVar1 = (e1->segment).v2;
    pGVar2 = (e3->segment).v1;
    if (pGVar2 == pGVar1) {
      local_20 = (e2->segment).v2;
      if ((e3->segment).v2 == local_20) goto LAB_08120484;
    }
    else {
      local_20 = (e2->segment).v2;
    }
    if ((pGVar2 != local_20) || (pGVar1 != (e3->segment).v2)) goto LAB_081203a7;
    goto LAB_08120484;
  }
  pGVar5 = (e1->segment).v2;
  if (pGVar2 == pGVar5) {
    pGVar2 = (e3->segment).v1;
    if (pGVar1 == pGVar2) {
      pGVar5 = (e2->segment).v2;
      if ((e3->segment).v2 == pGVar5) goto LAB_08120484;
    }
    else {
      pGVar5 = (e2->segment).v2;
    }
    if (pGVar2 != pGVar5) goto LAB_081203a7;
    pGVar2 = (e3->segment).v2;
joined_r0x08120530:
    if (pGVar1 == pGVar2) goto LAB_08120484;
  }
  else {
    pGVar3 = (e2->segment).v2;
    if (pGVar5 == pGVar3) {
      pGVar5 = (e3->segment).v1;
      if (pGVar1 != pGVar5) {
        if (pGVar2 != pGVar5) goto LAB_081203a7;
        pGVar2 = (e3->segment).v2;
        goto joined_r0x08120530;
      }
      pGVar1 = (e3->segment).v2;
    }
    else {
      if (pGVar1 != pGVar3) {
                    // WARNING: Subroutine does not return
        g_assertion_message(0,"../../src/gts/triangle.c",0x7d,"gts_triangle_set",0);
      }
      pGVar1 = (e3->segment).v1;
      if (pGVar5 != pGVar1) {
        if ((pGVar2 == pGVar1) && (pGVar5 == (e3->segment).v2)) goto LAB_08120484;
        goto LAB_081203a7;
      }
      pGVar1 = (e3->segment).v2;
    }
    if (pGVar2 == pGVar1) {
LAB_08120484:
      pGVar4 = (GSList *)g_slist_prepend(e1->triangles,triangle);
      e1->triangles = pGVar4;
      pGVar4 = (GSList *)g_slist_prepend(e2->triangles,triangle);
      e2->triangles = pGVar4;
      pGVar4 = (GSList *)g_slist_prepend(e3->triangles,triangle);
      e3->triangles = pGVar4;
      return;
    }
  }
LAB_081203a7:
  g_return_if_fail_warning();
  return;
}



GSList * gts_triangles_from_edges(GSList *edges)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  GSList *local_24;
  GSList *local_20;
  
  uVar3 = g_hash_table_new(0,0);
  local_24 = (GSList *)0x0;
  local_20 = edges;
  if (edges != (GSList *)0x0) {
    do {
      puVar1 = *(undefined4 **)((int)local_20->data + 0x14);
      while (puVar1 != (undefined4 *)0x0) {
        uVar2 = *puVar1;
        iVar4 = g_hash_table_lookup(uVar3,uVar2);
        if (iVar4 == 0) {
          local_24 = (GSList *)g_slist_prepend(local_24,uVar2);
          g_hash_table_insert(uVar3,uVar2,local_20);
        }
        puVar1 = (undefined4 *)puVar1[1];
      }
      local_20 = local_20->next;
    } while (local_20 != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar3);
  return local_24;
}



void gts_triangle_normal(GtsTriangle *t,gdouble *x,gdouble *y,gdouble *z)

{
  GtsEdge *pGVar1;
  GtsEdge *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  char "gts_triangle_normal" [20];
  GtsVertex *pGVar13;
  GtsVertex *pGVar14;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  pGVar1 = t->e1;
  pGVar2 = t->e2;
  pGVar3 = (pGVar1->segment).v1;
  pGVar4 = (pGVar2->segment).v1;
  if (pGVar3 == pGVar4) {
    pGVar13 = (pGVar1->segment).v2;
    pGVar14 = (pGVar2->segment).v2;
  }
  else {
    pGVar5 = (pGVar1->segment).v2;
    pGVar6 = (pGVar2->segment).v2;
    pGVar13 = pGVar4;
    pGVar14 = pGVar5;
    if (((pGVar5 != pGVar6) && (pGVar13 = pGVar5, pGVar14 = pGVar4, pGVar3 != pGVar6)) &&
       (pGVar13 = pGVar6, pGVar4 != pGVar5)) {
      __fprintf_chk(stderr,1,
                    "t: %p t->e1: %p t->e2: %p t->e3: %p t->e1->v1: %p t->e1->v2: %p t->e2->v1: %p t->e2->v2: %p t->e3->v1: %p t->e3->v2: %p\n"
                    ,t,pGVar1,pGVar2,t->e3,pGVar3,pGVar5,pGVar4,pGVar6,(t->e3->segment).v1,
                    (t->e3->segment).v2);
                    // WARNING: Subroutine does not return
      g_assertion_message(0,"../../src/gts/triangle.c",399,"gts_triangle_normal",0);
    }
  }
  dVar8 = (double)(pGVar3->p).x;
  dVar7 = (double)(pGVar14->p).x - dVar8;
  dVar9 = (double)(pGVar3->p).y;
  dVar10 = (double)(pGVar14->p).y - dVar9;
  dVar12 = (double)(pGVar3->p).z;
  dVar11 = (double)(pGVar14->p).z - dVar12;
  dVar8 = (double)(pGVar13->p).x - dVar8;
  dVar9 = (double)(pGVar13->p).y - dVar9;
  dVar12 = (double)(pGVar13->p).z - dVar12;
  *(double *)x = dVar10 * dVar12 - dVar11 * dVar9;
  *(double *)y = dVar11 * dVar8 - dVar12 * dVar7;
  *(double *)z = dVar9 * dVar7 - dVar8 * dVar10;
  return;
}



float10 gts_triangle_area(GtsTriangle *t)

{
  char "gts_triangle_area" [18];
  gdouble local_24;
  gdouble local_1c;
  gdouble local_14 [2];
  
  if (t != (GtsTriangle *)0x0) {
    gts_triangle_normal(t,local_14,&local_1c,&local_24);
    return SQRT((float10)local_24 * (float10)local_24 +
                (float10)local_1c * (float10)local_1c + (float10)local_14[0] * (float10)local_14[0])
           * (float10)0.50000000;
  }
  g_return_if_fail_warning(0,"gts_triangle_area",0x815f901);
  return (float10)0;
}



float10 gts_triangle_perimeter(int t)

{
  int iVar1;
  char "gts_triangle_perimeter" [23];
  int iVar2;
  int iVar3;
  float10 fVar4;
  float10 fVar5;
  float10 fVar6;
  
  if (t == 0) {
    g_return_if_fail_warning(0,"gts_triangle_perimeter",0x815f901);
    return (float10)0;
  }
  iVar1 = *(int *)(t + 0xc);
  iVar3 = *(int *)(*(int *)(t + 0x10) + 0xc);
  if (*(int *)(iVar1 + 0xc) == iVar3) {
    iVar2 = *(int *)(iVar1 + 0x10);
  }
  else {
    iVar2 = *(int *)(iVar1 + 0x10);
    if (iVar3 != iVar2) goto LAB_08120876;
  }
  iVar3 = *(int *)(*(int *)(t + 0x10) + 0x10);
LAB_08120876:
  fVar4 = (float10)gts_point_distance(*(int *)(iVar1 + 0xc),iVar2);
  fVar5 = (float10)gts_point_distance(*(undefined4 *)(*(int *)(t + 0xc) + 0xc),iVar3);
  fVar6 = (float10)gts_point_distance(*(undefined4 *)(*(int *)(t + 0xc) + 0x10),iVar3);
  return (float10)(double)fVar4 + (float10)(double)fVar5 + fVar6;
}



// WARNING: Removing unreachable block (ram,0x08120958)
// WARNING: Removing unreachable block (ram,0x0812094e)
// WARNING: Removing unreachable block (ram,0x0812095c)

float10 gts_triangle_quality(int t)

{
  char "gts_triangle_quality" [21];
  float10 fVar1;
  float10 fVar2;
  
  if (t == 0) {
    g_return_if_fail_warning(0,"gts_triangle_quality",0x815f901);
    return (float10)0;
  }
  fVar1 = (float10)gts_triangle_perimeter(t);
  if ((float10)0 < fVar1) {
    fVar2 = (float10)gts_triangle_area(t);
    return (SQRT(fVar2) * (float10)4.55901411) / (float10)(double)fVar1;
  }
  return (float10)0;
}



float10 gts_triangles_angle(GtsTriangle *t1,GtsTriangle *t2)

{
  double dVar1;
  double dVar2;
  char "gts_triangles_angle" [20];
  float10 fVar3;
  double dVar4;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24;
  gdouble local_1c;
  gdouble local_14;
  
  if ((t2 == (GtsTriangle *)0x0) || (t1 == (GtsTriangle *)0x0)) {
    g_return_if_fail_warning(0,"gts_triangles_angle","t1 != NULL && t2 != NULL");
    fVar3 = (float10)0;
  }
  else {
    gts_triangle_normal(t1,&local_14,&local_1c,&local_24);
    gts_triangle_normal(t2,&local_2c,&local_34,&local_3c);
    dVar1 = local_3c * local_1c - local_24 * local_34;
    dVar2 = local_24 * local_2c - local_3c * local_14;
    dVar4 = local_34 * local_14 - local_1c * local_2c;
    dVar4 = atan2(SQRT(dVar4 * dVar4 + dVar2 * dVar2 + dVar1 * dVar1),
                  local_3c * local_24 + local_14 * local_2c + local_34 * local_1c);
    fVar3 = (float10)dVar4 - (float10)3.14159265;
    if (fVar3 < (float10)-3.14159265) {
      return fVar3 + (float10)6.28318531;
    }
  }
  return fVar3;
}



GtsTriangle * gts_triangle_new(GtsTriangleClass *klass,GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GtsTriangle *triangle;
  
  triangle = (GtsTriangle *)gts_object_new((GtsObjectClass *)klass);
  gts_triangle_set(triangle,e1,e2,e3);
  return triangle;
}



GtsTriangleClass * gts_triangle_class(void)

{
  GtsTriangleClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo triangle_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsTriangleClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &triangle_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    triangle_info.name._0_4_ = 0x54737447;
    triangle_info.name._4_4_ = 0x6e616972;
    triangle_info.name._8_4_ = 0x656c67;
    do {
      *(undefined4 *)(&stack0x00000018 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsTriangleClass *)((klass->parent_class).info.name + 4);
    } while (klass < (GtsTriangleClass *)&DAT_0000001c);
    triangle_info.object_size = 0x18;
    triangle_info.class_size = 0x5c;
    triangle_info.class_init_func = triangle_class_init;
    triangle_info.object_init_func = triangle_init;
    parent_class = gts_object_class();
    klass = (GtsTriangleClass *)gts_object_class_new(parent_class,&triangle_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



GtsTriangle * gts_triangle_enclosing(GtsTriangleClass *klass,GSList *points,gdouble scale)

{
  double dVar1;
  double dVar2;
  double x;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  GSList *pGVar7;
  GtsVertexClass *klass_00;
  GtsVertex *v1;
  GtsVertex *v2;
  GtsVertex *v2_00;
  GtsEdgeClass *klass_01;
  GtsEdge *e1;
  GtsEdge *e2;
  GtsEdge *e3;
  GtsTriangleClass *klass_02;
  GtsTriangle *pGVar8;
  
  if (points == (GSList *)0x0) {
    return (GtsTriangle *)points;
  }
  pGVar7 = points->next;
  dVar1 = *(double *)((int)points->data + 0xc);
  dVar2 = *(double *)((int)points->data + 0x14);
  dVar4 = dVar1;
  dVar5 = dVar2;
  while (x = dVar4, pGVar7 != (GSList *)0x0) {
    while( true ) {
      dVar3 = *(double *)((int)pGVar7->data + 0xc);
      dVar6 = dVar1;
      dVar4 = dVar3;
      if ((dVar3 <= x) && (dVar6 = dVar3, dVar4 = x, dVar1 <= dVar3)) {
        dVar6 = dVar1;
      }
      dVar1 = dVar6;
      x = *(double *)((int)pGVar7->data + 0x14);
      dVar3 = x;
      dVar6 = dVar5;
      if ((dVar2 < x) || (dVar3 = dVar2, dVar6 = x, x < dVar5)) break;
      pGVar7 = pGVar7->next;
      x = dVar4;
      if (pGVar7 == (GSList *)0x0) goto LAB_08120c42;
    }
    pGVar7 = pGVar7->next;
    dVar2 = dVar3;
    dVar5 = dVar6;
  }
LAB_08120c42:
  x = (dVar1 + dVar4) * 0.50000000;
  dVar5 = (dVar5 + dVar2) * 0.50000000;
  dVar1 = SQRT((dVar2 - dVar5) * (dVar2 - dVar5) + (dVar4 - x) * (dVar4 - x)) * (double)scale;
  if (dVar1 == 0.00000000) {
    dVar1 = (double)scale;
  }
  klass_00 = gts_vertex_class();
  v1 = gts_vertex_new(klass_00,(gdouble)(x + dVar1 * 1.73205081),(gdouble)(dVar5 - dVar1),0.00000000
                     );
  klass_00 = gts_vertex_class();
  v2 = gts_vertex_new(klass_00,(gdouble)x,(gdouble)(dVar5 + dVar1 + dVar1),0.00000000);
  klass_00 = gts_vertex_class();
  v2_00 = gts_vertex_new(klass_00,(gdouble)(x + dVar1 * -1.73205081),(gdouble)(dVar5 - dVar1),
                         0.00000000);
  klass_01 = gts_edge_class();
  e1 = gts_edge_new(klass_01,v1,v2);
  klass_01 = gts_edge_class();
  e2 = gts_edge_new(klass_01,v2,v2_00);
  klass_01 = gts_edge_class();
  e3 = gts_edge_new(klass_01,v2_00,v1);
  klass_02 = gts_triangle_class();
  pGVar8 = gts_triangle_new(klass_02,e1,e2,e3);
  return pGVar8;
}



// WARNING: Exceeded maximum restarts with more pending

void triangle_destroy(GtsObject *object)

{
  byte bVar1;
  GtsObjectClass *object_00;
  GtsObject *object_01;
  GtsObject *object_02;
  int iVar2;
  guint32 gVar3;
  GtsTriangleClass *pGVar4;
  
  object_00 = object[1].klass;
  object_01 = (GtsObject *)object[1].reserved;
  object_02 = (GtsObject *)object[1].flags;
  iVar2 = g_slist_remove(*(undefined4 *)((object_00->info).name + 0x14),object);
  bVar1 = *(byte *)&object_00->info;
  *(int *)((object_00->info).name + 0x14) = iVar2;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_edges == 0)) && (iVar2 == 0)) {
    gts_object_destroy((GtsObject *)object_00);
  }
  gVar3 = g_slist_remove(object_01[1].flags,object);
  object_01[1].flags = gVar3;
  if ((((*(byte *)&object_01->flags & 1) == 0) && (gts_allow_floating_edges == 0)) && (gVar3 == 0))
  {
    gts_object_destroy(object_01);
  }
  gVar3 = g_slist_remove(object_02[1].flags,object);
  object_02[1].flags = gVar3;
  if ((((*(byte *)&object_02->flags & 1) == 0) && (gts_allow_floating_edges == 0)) && (gVar3 == 0))
  {
    gts_object_destroy(object_02);
  }
  pGVar4 = gts_triangle_class();
                    // WARNING: Could not recover jumptable at 0x08120e35. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar4->parent_class).parent_class)->destroy)();
  return;
}



void face_class_init(GtsFaceClass *klass)

{
  (klass->parent_class).parent_class.clone = face_clone;
  (klass->parent_class).parent_class.destroy = face_destroy;
  return;
}



void face_init(GtsFace *face)

{
  face->surfaces = (GSList *)0x0;
  return;
}



gboolean gts_face_has_parent_surface(GtsFace *f,GtsSurface *s)

{
  GSList *pGVar1;
  char "gts_face_has_parent_surface" [28];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_has_parent_surface","f != NULL");
    return 0;
  }
  pGVar1 = f->surfaces;
  while( true ) {
    if (pGVar1 == (GSList *)0x0) {
      return 0;
    }
    if ((GtsSurface *)pGVar1->data == s) break;
    pGVar1 = pGVar1->next;
  }
  return 1;
}



GtsFace * gts_face_new(GtsFaceClass *klass,GtsEdge *e1,GtsEdge *e2,GtsEdge *e3)

{
  GtsFace *triangle;
  
  triangle = (GtsFace *)gts_object_new((GtsObjectClass *)klass);
  gts_triangle_set((GtsTriangle *)triangle,e1,e2,e3);
  return triangle;
}



GtsFaceClass * gts_face_class(void)

{
  GtsFaceClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo face_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsFaceClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &face_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    face_info.name._0_4_ = 0x46737447;
    face_info.name._4_4_ = 0x656361;
    do {
      *(undefined4 *)(&stack0x00000014 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsFaceClass *)((klass->parent_class).parent_class.info.name + 4);
    } while (klass < (GtsFaceClass *)&DAT_00000020);
    face_info.object_size = 0x1c;
    face_info.class_size = 0x5c;
    face_info.class_init_func = face_class_init;
    face_info.object_init_func = face_init;
    parent_class = (GtsObjectClass *)gts_triangle_class();
    klass = (GtsFaceClass *)gts_object_class_new(parent_class,&face_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



guint gts_face_neighbor_number(GtsFace *f,GtsSurface *s)

{
  GtsFace *f_00;
  char "gts_face_neighbor_number" [25];
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *pGVar3;
  GtsEdge **ppGVar4;
  GSList *pGVar5;
  guint local_30;
  GtsEdge *e [4];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_neighbor_number","f != NULL");
    local_30 = 0;
  }
  else {
    ppGVar4 = e;
    local_30 = 0;
    e[0] = (f->triangle).e1;
    e[1] = (f->triangle).e2;
    e[3] = (GtsEdge *)0x0;
    e[2] = (f->triangle).e3;
    while (*ppGVar4 != (GtsEdge *)0x0) {
      pGVar5 = (*ppGVar4)->triangles;
      while (pGVar5 != (GSList *)0x0) {
LAB_08121034:
        f_00 = (GtsFace *)pGVar5->data;
        if (f_00 == f) {
LAB_08121084:
          pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x081210e9:
          if (pGVar5 == (GSList *)0x0) break;
          goto LAB_08121034;
        }
        pGVar1 = (GtsObjectClass *)gts_face_class();
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar5 = (GSList *)(&pGVar5->data)[1];
          goto joined_r0x081210e9;
        }
        if (f_00 == (GtsFace *)0x0) goto LAB_08121084;
        pGVar3 = (f_00->triangle).object.klass;
        if (pGVar3 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar1 == pGVar3) {
              if ((s == (GtsSurface *)0x0) ||
                 (gVar2 = gts_face_has_parent_surface(f_00,s), gVar2 != 0)) {
                local_30 = local_30 + 1;
              }
              break;
            }
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
          goto LAB_08121084;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        pGVar5 = (GSList *)(&pGVar5->data)[1];
      }
      ppGVar4 = ppGVar4 + 1;
    }
  }
  return local_30;
}



void face_clone(GtsObject *clone,GtsObject *object)

{
  GtsFaceClass *pGVar1;
  
  pGVar1 = gts_face_class();
  (*((pGVar1->parent_class).parent_class.parent_class)->clone)(clone,object);
  clone[2].klass = (GtsObjectClass *)0x0;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void face_destroy(GtsObject *object)

{
  GtsObjectClass *pGVar1;
  char "face_destroy" [13];
  GtsObjectClass *pGVar2;
  GtsFaceClass *pGVar3;
  
  pGVar2 = object[2].klass;
  if (pGVar2 != (GtsObjectClass *)0x0) {
    do {
      pGVar1 = *(GtsObjectClass **)((pGVar2->info).name + 4);
      gts_surface_remove_face(*(GtsSurface **)(pGVar2->info).name,(GtsFace *)object);
      pGVar2 = pGVar1;
    } while (pGVar1 != (GtsObjectClass *)0x0);
    if (object[2].klass != (GtsObjectClass *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/face.c",0x23,0x8160950,"face->surfaces == NULL");
    }
  }
  pGVar3 = gts_face_class();
                    // WARNING: Could not recover jumptable at 0x081211cc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar3->parent_class).parent_class.parent_class)->destroy)();
  return;
}



gboolean __regparm3 triangle_is_incompatible(GtsTriangle *t,GtsEdge *e,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *f;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *pGVar4;
  
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return 0;
    }
    if ((GtsTriangle *)pGVar1->data != t) {
      pGVar2 = (GtsObjectClass *)gts_face_class();
      f = (GtsFace *)pGVar1->data;
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (f != (GtsFace *)0x0) {
          pGVar4 = (f->triangle).object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar2 == pGVar4) {
                gVar3 = gts_face_has_parent_surface(f,s);
                if ((gVar3 != 0) &&
                   (gVar3 = gts_triangles_are_compatible(t,(GtsTriangle *)pGVar1->data,e),
                   gVar3 == 0)) {
                  return 1;
                }
                break;
              }
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



gboolean gts_face_is_compatible(GtsFace *f,GtsSurface *s)

{
  char "gts_face_is_compatible" [23];
  gboolean gVar1;
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_is_compatible","f != NULL");
    return 0;
  }
  if (s != (GtsSurface *)0x0) {
    gVar1 = triangle_is_incompatible((GtsTriangle *)f,(f->triangle).e1,s);
    if ((gVar1 == 0) &&
       (gVar1 = triangle_is_incompatible((GtsTriangle *)f,(f->triangle).e2,s), gVar1 == 0)) {
      gVar1 = triangle_is_incompatible((GtsTriangle *)f,(f->triangle).e3,s);
      return (uint)(gVar1 == 0);
    }
    return 0;
  }
  g_return_if_fail_warning(0,0x81608be,0x815fd1b);
  return 0;
}



// WARNING: Type propagation algorithm not settling

GSList * gts_faces_from_edges(GSList *edges,GtsSurface *s)

{
  GtsFace *pGVar1;
  GtsFace *f;
  undefined4 uVar2;
  GtsObjectClass *pGVar3;
  gboolean gVar4;
  int iVar5;
  GtsObjectClass *pGVar6;
  GSList *local_28;
  GSList *local_24;
  
  uVar2 = g_hash_table_new(0,0);
  local_28 = (GSList *)0x0;
  local_24 = edges;
  if (edges != (GSList *)0x0) {
    do {
      pGVar1 = *(GtsFace **)((int)local_24->data + 0x14);
      while (pGVar1 != (GtsFace *)0x0) {
        f = *(GtsFace **)&pGVar1->triangle;
        pGVar3 = (GtsObjectClass *)gts_face_class();
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (f != (GtsFace *)0x0) {
            pGVar6 = (f->triangle).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            }
            else {
              do {
                if (pGVar3 == pGVar6) {
                  if (((s == (GtsSurface *)0x0) ||
                      (gVar4 = gts_face_has_parent_surface(f,s), gVar4 != 0)) &&
                     (iVar5 = g_hash_table_lookup(uVar2,f), iVar5 == 0)) {
                    local_28 = (GSList *)g_slist_prepend(local_28,f);
                    g_hash_table_insert(uVar2,f,local_24);
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
        }
        pGVar1 = *(GtsFace **)((int)&pGVar1->triangle + 4);
      }
      local_24 = local_24->next;
    } while (local_24 != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar2);
  return local_28;
}



void gts_face_foreach_neighbor(GtsFace *f,GtsSurface *s,GtsFunc *func,gpointer data)

{
  GtsFace *f_00;
  char "gts_face_foreach_neighbor" [26];
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *pGVar3;
  GtsEdge **ppGVar4;
  GSList *pGVar5;
  GtsEdge *e [4];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_foreach_neighbor","f != NULL");
  }
  else {
    if (func == (GtsFunc *)0x0) {
      g_return_if_fail_warning(0,0x81608ee,0x816107f);
      return;
    }
    ppGVar4 = e;
    e[0] = (f->triangle).e1;
    e[1] = (f->triangle).e2;
    e[3] = (GtsEdge *)0x0;
    e[2] = (f->triangle).e3;
    while (*ppGVar4 != (GtsEdge *)0x0) {
      pGVar5 = (*ppGVar4)->triangles;
      while (pGVar5 != (GSList *)0x0) {
LAB_081214e4:
        f_00 = (GtsFace *)pGVar5->data;
        if (f_00 == f) {
LAB_0812153d:
          pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x08121591:
          if (pGVar5 == (GSList *)0x0) break;
          goto LAB_081214e4;
        }
        pGVar1 = (GtsObjectClass *)gts_face_class();
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar5 = (GSList *)(&pGVar5->data)[1];
          goto joined_r0x08121591;
        }
        if (f_00 == (GtsFace *)0x0) goto LAB_0812153d;
        pGVar3 = (f_00->triangle).object.klass;
        if (pGVar3 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar1 == pGVar3) {
              if ((s == (GtsSurface *)0x0) ||
                 (gVar2 = gts_face_has_parent_surface(f_00,s), gVar2 != 0)) {
                (*func)(f_00,data);
              }
              break;
            }
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
          goto LAB_0812153d;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        pGVar5 = (GSList *)(&pGVar5->data)[1];
      }
      ppGVar4 = ppGVar4 + 1;
    }
  }
  return;
}



GSList * gts_face_neighbors(GtsFace *f,GtsSurface *s)

{
  GtsFace *f_00;
  char "gts_face_neighbors" [19];
  GtsObjectClass *pGVar1;
  gboolean gVar2;
  GtsObjectClass *pGVar3;
  GtsEdge **ppGVar4;
  GSList *pGVar5;
  GSList *local_30;
  GtsEdge *e [4];
  
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,"gts_face_neighbors","f != NULL");
    local_30 = (GSList *)0x0;
  }
  else {
    ppGVar4 = e;
    local_30 = (GSList *)0x0;
    e[0] = (f->triangle).e1;
    e[1] = (f->triangle).e2;
    e[3] = (GtsEdge *)0x0;
    e[2] = (f->triangle).e3;
    while (*ppGVar4 != (GtsEdge *)0x0) {
      pGVar5 = (*ppGVar4)->triangles;
      while (pGVar5 != (GSList *)0x0) {
LAB_08121644:
        f_00 = (GtsFace *)pGVar5->data;
        if (f_00 == f) {
LAB_081216a2:
          pGVar5 = (GSList *)(&pGVar5->data)[1];
joined_r0x08121709:
          if (pGVar5 == (GSList *)0x0) break;
          goto LAB_08121644;
        }
        pGVar1 = (GtsObjectClass *)gts_face_class();
        if (pGVar1 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
          pGVar5 = (GSList *)(&pGVar5->data)[1];
          goto joined_r0x08121709;
        }
        if (f_00 == (GtsFace *)0x0) goto LAB_081216a2;
        pGVar3 = (f_00->triangle).object.klass;
        if (pGVar3 != (GtsObjectClass *)0x0) {
          do {
            if (pGVar1 == pGVar3) {
              if ((s == (GtsSurface *)0x0) ||
                 (gVar2 = gts_face_has_parent_surface(f_00,s), gVar2 != 0)) {
                local_30 = (GSList *)g_slist_prepend(local_30,f_00);
              }
              break;
            }
            pGVar3 = pGVar3->parent_class;
          } while (pGVar3 != (GtsObjectClass *)0x0);
          goto LAB_081216a2;
        }
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        pGVar5 = (GSList *)(&pGVar5->data)[1];
      }
      ppGVar4 = ppGVar4 + 1;
    }
  }
  return local_30;
}



int compare_x(void *p1,void *p2)

{
  return (uint)(*(double *)(*(int *)p2 + 0xc) < *(double *)(*(int *)p1 + 0xc)) * 2 + -1;
}



int compare_y(void *p1,void *p2)

{
  return (uint)(*(double *)(*(int *)p2 + 0x14) < *(double *)(*(int *)p1 + 0x14)) * 2 + -1;
}



int compare_z(void *p1,void *p2)

{
  return (uint)(*(double *)(*(int *)p2 + 0x1c) < *(double *)(*(int *)p1 + 0x1c)) * 2 + -1;
}



GSList * gts_kdtree_range(GNode *tree_3d,GtsBBox *bbox,anon_subr_int_void_ptr_void_ptr *compare)

{
  double dVar1;
  gpointer pvVar2;
  GNode *tree_3d_00;
  double dVar3;
  double dVar4;
  char "gts_kdtree_range" [17];
  GSList *pGVar5;
  GSList *pGVar6;
  code *compare_00;
  
  if (tree_3d == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_kdtree_range","tree_3d != NULL");
    pGVar6 = (GSList *)0x0;
  }
  else {
    if (bbox == (GtsBBox *)0x0) {
      g_return_if_fail_warning(0,0x8160999,"bbox != NULL");
      pGVar6 = (GSList *)0x0;
    }
    else {
      pvVar2 = tree_3d->data;
      pGVar6 = (GSList *)0x0;
      if (pvVar2 != (gpointer)0x0) {
        if ((((*(double *)((int)pvVar2 + 0xc) < (double)bbox->x1) ||
             (*(double *)((int)pvVar2 + 0x14) < (double)bbox->y1)) ||
            (*(double *)((int)pvVar2 + 0x1c) < (double)bbox->z1)) ||
           ((((double)bbox->x2 < *(double *)((int)pvVar2 + 0xc) ||
             ((double)bbox->y2 < *(double *)((int)pvVar2 + 0x14))) ||
            ((double)bbox->z2 < *(double *)((int)pvVar2 + 0x1c))))) {
          pGVar6 = (GSList *)0x0;
        }
        else {
          pGVar6 = (GSList *)g_slist_prepend(0,pvVar2);
        }
        if (compare == compare_x) {
          dVar3 = (double)bbox->y1;
          dVar4 = (double)bbox->y2;
          dVar1 = *(double *)((int)pvVar2 + 0x14);
          compare_00 = compare_y;
        }
        else {
          if (compare == compare_y) {
            dVar3 = (double)bbox->z1;
            dVar4 = (double)bbox->z2;
            dVar1 = *(double *)((int)pvVar2 + 0x1c);
            compare_00 = compare_z;
          }
          else {
            dVar3 = (double)bbox->x1;
            dVar4 = (double)bbox->x2;
            dVar1 = *(double *)((int)pvVar2 + 0xc);
            compare_00 = compare_x;
          }
        }
        tree_3d_00 = tree_3d->children;
        if (tree_3d_00 != (GNode *)0x0) {
          if (dVar1 <= dVar4) {
            pGVar5 = gts_kdtree_range(tree_3d_00,bbox,compare_00);
            pGVar6 = (GSList *)g_slist_concat(pGVar6,pGVar5);
          }
          if (dVar3 <= dVar1) {
            gts_kdtree_range(tree_3d_00->next,bbox,compare_00);
            pGVar6 = (GSList *)g_slist_concat();
            return pGVar6;
          }
        }
      }
    }
  }
  return pGVar6;
}



GNode * gts_kdtree_new(GPtrArray *points,anon_subr_int_void_ptr_void_ptr *compare)

{
  char "gts_kdtree_new" [15];
  GNode *pGVar1;
  undefined4 uVar2;
  uint uVar3;
  code *__compar;
  GNode *local_30;
  GPtrArray array;
  
  if (points == (GPtrArray *)0x0) {
    g_return_if_fail_warning(0,0x81609aa,"points != NULL");
    return (GNode *)0x0;
  }
  if (points->len == 0) {
    g_return_if_fail_warning(0,"gts_kdtree_new","points->len > 0");
    local_30 = (GNode *)0x0;
  }
  else {
    __compar = compare_y;
    if ((compare != compare_x) && (__compar = compare_x, compare == compare_y)) {
      __compar = compare_z;
    }
    qsort(points->pdata,points->len,4,__compar);
    uVar3 = points->len - 1 >> 1;
    local_30 = (GNode *)g_node_new(points->pdata[uVar3]);
    if (1 < points->len) {
      array.len = uVar3;
      if (uVar3 == 0) {
        uVar2 = g_node_new(0);
        g_node_prepend(local_30,uVar2);
        array.len = points->len - 1;
      }
      else {
        array.pdata = points->pdata;
        pGVar1 = gts_kdtree_new(&array,__compar);
        g_node_prepend(local_30,pGVar1);
        array.len = ~uVar3 + points->len;
      }
      if (array.len == 0) {
        uVar2 = g_node_new(0);
        g_node_prepend(local_30,uVar2);
        return local_30;
      }
      array.pdata = points->pdata + uVar3 + 1;
      pGVar1 = gts_kdtree_new(&array,__compar);
      g_node_prepend(local_30,pGVar1);
      return local_30;
    }
  }
  return local_30;
}



void bbox_init(GtsBBox *bbox)

{
  bbox->bounded = (gpointer)0x0;
  return;
}



void bbox_foreach_vertex(GtsPoint *p,GtsBBox *bb)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  dVar1 = (double)p->x;
  if (dVar1 < (double)bb->x1) {
    *(double *)&bb->x1 = dVar1;
  }
  dVar2 = (double)p->y;
  if (dVar2 < (double)bb->y1) {
    *(double *)&bb->y1 = dVar2;
  }
  dVar3 = (double)p->z;
  if (dVar3 < (double)bb->z1) {
    *(double *)&bb->z1 = dVar3;
  }
  if ((double)bb->x2 < dVar1) {
    *(double *)&bb->x2 = dVar1;
  }
  if ((double)bb->y2 < dVar2) {
    *(double *)&bb->y2 = dVar2;
  }
  if ((double)bb->z2 < dVar3) {
    *(double *)&bb->z2 = dVar3;
  }
  return;
}



gboolean gts_bboxes_are_overlapping(GtsBBox *bb1,GtsBBox *bb2)

{
  uint uVar1;
  
  uVar1 = 1;
  if (bb1 != bb2) {
    if (((((double)bb2->x2 < (double)bb1->x1) || ((double)bb1->x2 < (double)bb2->x1)) ||
        ((double)bb2->y2 < (double)bb1->y1)) ||
       (((double)bb1->y2 < (double)bb2->y1 || ((double)bb2->z2 < (double)bb1->z1)))) {
      return 0;
    }
    uVar1 = (uint)((double)bb2->z1 <= (double)bb1->z2);
  }
  return uVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void gts_bb_tree_traverse_overlapping
               (GNode *tree1,GNode *tree2,GtsBBTreeTraverseFunc *func,gpointer data)

{
  GtsBBox *bb1;
  GtsBBox *bb2;
  gboolean gVar1;
  GNode *tree1_00;
  GNode *tree2_00;
  
  if ((tree2 == (GNode *)0x0) || (tree1 == (GNode *)0x0)) {
    g_return_if_fail_warning();
    return;
  }
  bb1 = (GtsBBox *)tree1->data;
  bb2 = (GtsBBox *)tree2->data;
  gVar1 = gts_bboxes_are_overlapping(bb1,bb2);
  if (gVar1 == 0) {
    return;
  }
  tree1_00 = tree1->children;
  if (tree1_00 == (GNode *)0x0) {
    tree2_00 = tree2->children;
    if (tree2_00 == (GNode *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08121ddb. Too many branches
                    // WARNING: Treating indirect jump as call
      (*func)();
      return;
    }
  }
  else {
    tree2_00 = tree2->children;
    if ((tree2_00 == (GNode *)0x0) ||
       (((double)bb2->z2 - (double)bb2->z1) *
        ((double)bb2->y2 - (double)bb2->y1) * ((double)bb2->x2 - (double)bb2->x1) <
        ((double)bb1->z2 - (double)bb1->z1) *
        ((double)bb1->y2 - (double)bb1->y1) * ((double)bb1->x2 - (double)bb1->x1))) {
      do {
        gts_bb_tree_traverse_overlapping(tree1_00,tree2,func,data);
        tree1_00 = tree1_00->next;
      } while (tree1_00 != (GNode *)0x0);
      return;
    }
  }
  do {
    gts_bb_tree_traverse_overlapping(tree1,tree2_00,func,data);
    tree2_00 = tree2_00->next;
  } while (tree2_00 != (GNode *)0x0);
  return;
}



gboolean gts_bb_tree_is_overlapping(GNode *tree,GtsBBox *bbox)

{
  char "gts_bb_tree_is_overlapping" [27];
  gboolean gVar1;
  GNode *tree_00;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_is_overlapping","tree != NULL");
  }
  else {
    if (bbox == (GtsBBox *)0x0) {
      g_return_if_fail_warning(0,0x8160c21,"bbox != NULL");
      return 0;
    }
    gVar1 = gts_bboxes_are_overlapping(bbox,(GtsBBox *)tree->data);
    if (gVar1 != 0) {
      tree_00 = tree->children;
      if (tree_00 == (GNode *)0x0) {
        return 1;
      }
      do {
        gVar1 = gts_bb_tree_is_overlapping(tree_00,bbox);
        if (gVar1 != 0) {
          return 1;
        }
        tree_00 = tree_00->next;
      } while (tree_00 != (GNode *)0x0);
    }
  }
  return 0;
}



gboolean gts_bbox_is_stabbed(GtsBBox *bb,GtsPoint *p)

{
  char "gts_bbox_is_stabbed" [20];
  
  if (bb == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_is_stabbed","bb != NULL");
    return 0;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,0x8160cbd,0x816106f);
    return 0;
  }
  if (((((double)p->x <= (double)bb->x2) && ((double)bb->y1 <= (double)p->y)) &&
      ((double)p->y <= (double)bb->y2)) && ((double)bb->z1 <= (double)p->z)) {
    return (uint)((double)p->z <= (double)bb->z2);
  }
  return 0;
}



void gts_bbox_point_distance2(GtsBBox *bb,GtsPoint *p,gdouble *min,gdouble *max)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double local_2c;
  double local_24;
  double local_14;
  
  if ((((bb != (GtsBBox *)0x0) && (p != (GtsPoint *)0x0)) && (min != (gdouble *)0x0)) &&
     (max != (gdouble *)0x0)) {
    dVar9 = (double)p->x;
    dVar7 = (double)p->y;
    dVar3 = (double)p->z;
    dVar1 = (double)bb->x1 - dVar9;
    dVar1 = dVar1 * dVar1;
    dVar2 = dVar9 - (double)bb->x2;
    dVar2 = dVar2 * dVar2;
    dVar6 = (double)bb->y1 - dVar7;
    dVar6 = dVar6 * dVar6;
    dVar8 = dVar7 - (double)bb->y2;
    dVar8 = dVar8 * dVar8;
    dVar4 = (double)bb->z1 - dVar3;
    dVar4 = dVar4 * dVar4;
    dVar5 = dVar3 - (double)bb->z2;
    dVar5 = dVar5 * dVar5;
    local_2c = dVar1;
    if (((double)bb->x1 <= dVar9) && (local_2c = dVar2, dVar9 <= (double)bb->x2)) {
      local_2c = 0.00000000;
    }
    local_14 = dVar6;
    if (((double)bb->y1 <= dVar7) && (local_14 = dVar8, dVar7 <= (double)bb->y2)) {
      local_14 = 0.00000000;
    }
    local_24 = dVar4;
    if (((double)bb->z1 <= dVar3) && (local_24 = dVar5, dVar3 <= (double)bb->z2)) {
      local_24 = 0.00000000;
    }
    dVar9 = dVar1;
    if (dVar1 <= dVar2 || dVar2 != dVar1) {
      dVar9 = dVar2;
    }
    if (dVar1 > dVar2 || dVar2 == dVar1) {
      dVar1 = dVar2;
    }
    dVar7 = dVar6;
    if (dVar6 <= dVar8 || dVar8 != dVar6) {
      dVar7 = dVar8;
    }
    if (dVar6 > dVar8 || dVar8 == dVar6) {
      dVar6 = dVar8;
    }
    dVar3 = dVar4;
    if (dVar4 <= dVar5 || dVar5 != dVar4) {
      dVar3 = dVar5;
    }
    if (dVar4 > dVar5 || dVar5 == dVar4) {
      dVar4 = dVar5;
    }
    dVar1 = dVar1 + dVar7 + dVar3;
    dVar3 = dVar6 + dVar9 + dVar3;
    if (dVar1 <= dVar3 || dVar3 != dVar1) {
      dVar3 = dVar1;
    }
    dVar4 = dVar9 + dVar7 + dVar4;
    if (dVar3 <= dVar4 || dVar4 != dVar3) {
      dVar4 = dVar3;
    }
    *(double *)min = local_2c + local_14 + local_24;
    *(double *)max = dVar4;
    return;
  }
  g_return_if_fail_warning();
  return;
}



float10 gts_bbox_diagonal2(int bb)

{
  char "gts_bbox_diagonal2" [19];
  float10 fVar1;
  float10 fVar2;
  float10 fVar3;
  
  if (bb != 0) {
    fVar1 = (float10)*(double *)(bb + 0x28) - (float10)*(double *)(bb + 0x10);
    fVar2 = (float10)*(double *)(bb + 0x30) - (float10)*(double *)(bb + 0x18);
    fVar3 = (float10)*(double *)(bb + 0x38) - (float10)*(double *)(bb + 0x20);
    return fVar3 * fVar3 + fVar2 * fVar2 + fVar1 * fVar1;
  }
  g_return_if_fail_warning(0,"gts_bbox_diagonal2","bb != NULL");
  return (float10)0;
}



void gts_bbox_set(GtsBBox *bbox,gpointer bounded,gdouble x1,gdouble y1,gdouble z1,gdouble x2,
                 gdouble y2,gdouble z2)

{
  if (bbox == (GtsBBox *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  if ((((double)x1 <= (double)x2) && ((double)y1 <= (double)y2)) && ((double)z1 <= (double)z2)) {
    bbox->x1 = x1;
    bbox->y1 = y1;
    bbox->z1 = z1;
    bbox->x2 = x2;
    bbox->y2 = y2;
    bbox->z2 = z2;
    bbox->bounded = bounded;
    return;
  }
  g_return_if_fail_warning();
  return;
}



// WARNING: Removing unreachable block (ram,0x08122422)
// WARNING: Removing unreachable block (ram,0x081222d0)
// WARNING: Removing unreachable block (ram,0x081222d4)
// WARNING: Removing unreachable block (ram,0x081222d8)
// WARNING: Removing unreachable block (ram,0x0812242a)
// WARNING: Removing unreachable block (ram,0x08122430)

void gts_bb_tree_surface_boundary_distance
               (GNode *tree,GtsSurface *s,anon_subr_gdouble_GtsPoint_ptr_gpointer *distance,
               gdouble delta,GtsRange *range)

{
  double dVar1;
  double dVar2;
  char "gts_bb_tree_surface_boundary_distance" [38];
  float10 fVar3;
  gdouble local_44;
  gpointer data [5];
  double local_24 [2];
  
  local_24[0] = 0.00000000;
  local_44 = (double)delta;
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,0x8160ae0,"tree != NULL");
    return;
  }
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x8160ae0,0x815fd1b);
    return;
  }
  if (((double)delta <= 0.00000000) || (1.00000000 <= (double)delta)) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_boundary_distance","delta > 0. && delta < 1.");
    return;
  }
  if (range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,0x8160ae0,0x816121d);
    return;
  }
  gts_range_init(range);
  fVar3 = (float10)gts_bbox_diagonal2(tree->data);
  data[0] = tree;
  data[1] = &local_44;
  data[3] = local_24;
  data[2] = range;
  local_44 = (double)(SQRT(fVar3) * (float10)local_44);
  data[4] = distance;
  gts_surface_foreach_edge(s,surface_distance_foreach_boundary,data);
  if (local_24[0] <= 0.00000000) {
    range->stddev = 0.00000000;
    range->mean = 0.00000000;
    range->max = 0.00000000;
    range->min = 0.00000000;
    return;
  }
  dVar1 = (double)range->sum;
  dVar2 = (double)range->sum2 - (dVar1 * dVar1) / local_24[0];
  if (dVar2 < 0.00000000) {
    range->stddev = 0.00000000;
  }
  else {
    *(double *)&range->stddev = SQRT(dVar2 / local_24[0]);
  }
  *(double *)&range->mean = dVar1 / local_24[0];
  return;
}



// WARNING: Removing unreachable block (ram,0x08122622)
// WARNING: Removing unreachable block (ram,0x081224d0)
// WARNING: Removing unreachable block (ram,0x081224d4)
// WARNING: Removing unreachable block (ram,0x081224d8)
// WARNING: Removing unreachable block (ram,0x0812262a)
// WARNING: Removing unreachable block (ram,0x08122630)

void gts_bb_tree_surface_distance
               (GNode *tree,GtsSurface *s,GtsBBoxDistFunc *distance,gdouble delta,GtsRange *range)

{
  double dVar1;
  double dVar2;
  char "gts_bb_tree_surface_distance" [29];
  float10 fVar3;
  gdouble local_44;
  gpointer data [5];
  double local_24 [2];
  
  local_24[0] = 0.00000000;
  local_44 = (double)delta;
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,0x8160b06,"tree != NULL");
    return;
  }
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x8160b06,0x815fd1b);
    return;
  }
  if (((double)delta <= 0.00000000) || (1.00000000 <= (double)delta)) {
    g_return_if_fail_warning(0,"gts_bb_tree_surface_distance","delta > 0. && delta < 1.");
    return;
  }
  if (range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,0x8160b06,0x816121d);
    return;
  }
  gts_range_init(range);
  fVar3 = (float10)gts_bbox_diagonal2(tree->data);
  data[0] = tree;
  data[1] = &local_44;
  data[3] = local_24;
  data[2] = range;
  local_44 = (double)(SQRT(fVar3) * (float10)local_44);
  data[4] = distance;
  gts_surface_foreach_face(s,surface_distance_foreach_triangle,data);
  if (local_24[0] <= 0.00000000) {
    range->stddev = 0.00000000;
    range->mean = 0.00000000;
    range->max = 0.00000000;
    range->min = 0.00000000;
    return;
  }
  dVar1 = (double)range->sum;
  dVar2 = (double)range->sum2 - (dVar1 * dVar1) / local_24[0];
  if (dVar2 < 0.00000000) {
    range->stddev = 0.00000000;
  }
  else {
    *(double *)&range->stddev = SQRT(dVar2 / local_24[0]);
  }
  *(double *)&range->mean = dVar1 / local_24[0];
  return;
}



GtsBBox * gts_bbox_new(GtsBBoxClass *klass,gpointer bounded,gdouble x1,gdouble y1,gdouble z1,
                      gdouble x2,gdouble y2,gdouble z2)

{
  char "gts_bbox_new" [13];
  GtsBBox *bbox;
  
  if (klass != (GtsBBoxClass *)0x0) {
    bbox = (GtsBBox *)gts_object_new((GtsObjectClass *)klass);
    gts_bbox_set(bbox,bounded,x1,y1,z1,x2,y2,z2);
    return bbox;
  }
  g_return_if_fail_warning(0,"gts_bbox_new","klass != NULL");
  return (GtsBBox *)0x0;
}



GtsBBox * gts_bbox_points(GtsBBoxClass *klass,GSList *points)

{
  double dVar1;
  gpointer pvVar2;
  GtsBBox *pGVar3;
  GSList *pGVar4;
  
  if (points == (GSList *)0x0) {
    return (GtsBBox *)0x0;
  }
  pvVar2 = points->data;
  pGVar3 = gts_bbox_new(klass,points,*(gdouble *)((int)pvVar2 + 0xc),
                        *(gdouble *)((int)pvVar2 + 0x14),*(gdouble *)((int)pvVar2 + 0x1c),
                        *(gdouble *)((int)pvVar2 + 0xc),*(gdouble *)((int)pvVar2 + 0x14),
                        *(gdouble *)((int)pvVar2 + 0x1c));
  pGVar4 = points->next;
joined_r0x08122785:
  if (pGVar4 == (GSList *)0x0) {
    return pGVar3;
  }
  do {
    pvVar2 = pGVar4->data;
    dVar1 = *(double *)((int)pvVar2 + 0xc);
    if (dVar1 <= (double)pGVar3->x2) {
      if ((double)pGVar3->x1 <= dVar1) goto LAB_0812279a;
      *(double *)&pGVar3->x1 = dVar1;
      dVar1 = *(double *)((int)pvVar2 + 0x14);
      if ((double)pGVar3->y2 < dVar1) goto LAB_081227a8;
LAB_081227f9:
      if ((double)pGVar3->y1 <= dVar1) goto LAB_081227b2;
      *(double *)&pGVar3->y1 = dVar1;
      dVar1 = *(double *)((int)pvVar2 + 0x1c);
      if (dVar1 <= (double)pGVar3->z2) goto LAB_08122811;
LAB_081227c0:
      *(double *)&pGVar3->z2 = dVar1;
    }
    else {
      *(double *)&pGVar3->x2 = dVar1;
LAB_0812279a:
      dVar1 = *(double *)((int)pvVar2 + 0x14);
      if (dVar1 <= (double)pGVar3->y2) goto LAB_081227f9;
LAB_081227a8:
      *(double *)&pGVar3->y2 = dVar1;
LAB_081227b2:
      dVar1 = *(double *)((int)pvVar2 + 0x1c);
      if ((double)pGVar3->z2 < dVar1) goto LAB_081227c0;
LAB_08122811:
      if (dVar1 < (double)pGVar3->z1) break;
    }
    pGVar4 = pGVar4->next;
    if (pGVar4 == (GSList *)0x0) {
      return pGVar3;
    }
  } while( true );
  pGVar4 = pGVar4->next;
  *(double *)&pGVar3->z1 = dVar1;
  goto joined_r0x08122785;
}



GtsBBox * gts_bbox_bboxes(GtsBBoxClass *klass,GSList *bboxes)

{
  gpointer pvVar1;
  GSList *pGVar2;
  char "gts_bbox_bboxes" [16];
  GtsBBox *pGVar3;
  
  if (bboxes == (GSList *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_bboxes","bboxes != NULL");
    return (GtsBBox *)0x0;
  }
  if (klass != (GtsBBoxClass *)0x0) {
    pvVar1 = bboxes->data;
    pGVar3 = gts_bbox_new(klass,bboxes,*(gdouble *)((int)pvVar1 + 0x10),
                          *(gdouble *)((int)pvVar1 + 0x18),*(gdouble *)((int)pvVar1 + 0x20),
                          *(gdouble *)((int)pvVar1 + 0x28),*(gdouble *)((int)pvVar1 + 0x30),
                          *(gdouble *)((int)pvVar1 + 0x38));
    pGVar2 = bboxes->next;
    while (pGVar2 != (GSList *)0x0) {
      pvVar1 = pGVar2->data;
      if (*(double *)((int)pvVar1 + 0x10) < (double)pGVar3->x1) {
        *(double *)&pGVar3->x1 = *(double *)((int)pvVar1 + 0x10);
      }
      if (*(double *)((int)pvVar1 + 0x18) < (double)pGVar3->y1) {
        *(double *)&pGVar3->y1 = *(double *)((int)pvVar1 + 0x18);
      }
      if (*(double *)((int)pvVar1 + 0x20) < (double)pGVar3->z1) {
        *(double *)&pGVar3->z1 = *(double *)((int)pvVar1 + 0x20);
      }
      if ((double)pGVar3->x2 < *(double *)((int)pvVar1 + 0x28)) {
        *(double *)&pGVar3->x2 = *(double *)((int)pvVar1 + 0x28);
      }
      if ((double)pGVar3->y2 < *(double *)((int)pvVar1 + 0x30)) {
        *(double *)&pGVar3->y2 = *(double *)((int)pvVar1 + 0x30);
      }
      if ((double)pGVar3->z2 < *(double *)((int)pvVar1 + 0x38)) {
        *(double *)&pGVar3->z2 = *(double *)((int)pvVar1 + 0x38);
      }
      pGVar2 = pGVar2->next;
    }
    return pGVar3;
  }
  g_return_if_fail_warning(0,0x8160d0b,"klass != NULL");
  return (GtsBBox *)0x0;
}



GtsBBox * gts_bbox_segment(GtsBBoxClass *klass,GtsSegment *s)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double dVar3;
  char "gts_bbox_segment" [17];
  GtsBBox *pGVar4;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_segment",0x815fd1b);
    return (GtsBBox *)0x0;
  }
  if (klass == (GtsBBoxClass *)0x0) {
    g_return_if_fail_warning(0,0x8160d2c,"klass != NULL");
    return (GtsBBox *)0x0;
  }
  pGVar4 = gts_bbox_new(klass,s,0.00000000,0.00000000,0.00000000,0.00000000,0.00000000,0.00000000);
  pGVar1 = s->v1;
  pGVar2 = s->v2;
  dVar3 = (double)(pGVar1->p).x;
  if ((double)(pGVar2->p).x < dVar3) {
    *(double *)&pGVar4->x2 = dVar3;
    pGVar4->x1 = (pGVar2->p).x;
    dVar3 = (double)(pGVar1->p).y;
    if (dVar3 <= (double)(pGVar2->p).y) goto LAB_08122a3f;
  }
  else {
    *(double *)&pGVar4->x1 = dVar3;
    pGVar4->x2 = (pGVar2->p).x;
    dVar3 = (double)(pGVar1->p).y;
    if (dVar3 <= (double)(pGVar2->p).y) {
LAB_08122a3f:
      *(double *)&pGVar4->y1 = dVar3;
      pGVar4->y2 = (pGVar2->p).y;
      dVar3 = (double)(pGVar1->p).z;
      if ((double)(pGVar2->p).z < dVar3) goto LAB_08122a56;
      goto LAB_08122a15;
    }
  }
  *(double *)&pGVar4->y2 = dVar3;
  pGVar4->y1 = (pGVar2->p).y;
  dVar3 = (double)(pGVar1->p).z;
  if ((double)(pGVar2->p).z < dVar3) {
LAB_08122a56:
    *(double *)&pGVar4->z2 = dVar3;
    pGVar4->z1 = (pGVar2->p).z;
    return pGVar4;
  }
LAB_08122a15:
  *(double *)&pGVar4->z1 = dVar3;
  pGVar4->z2 = (pGVar2->p).z;
  return pGVar4;
}



GtsBBox * gts_bbox_triangle(GtsBBoxClass *klass,GtsTriangle *t)

{
  gdouble z1;
  gdouble y1;
  gdouble x1;
  GtsEdge *pGVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  char "gts_bbox_triangle" [18];
  GtsBBox *pGVar9;
  GtsVertex *pGVar10;
  GtsEdge *pGVar11;
  
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_triangle",0x815f901);
    return (GtsBBox *)0x0;
  }
  if (klass == (GtsBBoxClass *)0x0) {
    g_return_if_fail_warning(0,0x8160d3d,"klass != NULL");
    return (GtsBBox *)0x0;
  }
  pGVar10 = (t->e1->segment).v1;
  z1 = (pGVar10->p).z;
  y1 = (pGVar10->p).y;
  x1 = (pGVar10->p).x;
  pGVar9 = gts_bbox_new(klass,t,x1,y1,z1,x1,y1,z1);
  pGVar1 = t->e1;
  pGVar10 = (pGVar1->segment).v2;
  dVar2 = (double)(pGVar10->p).x;
  dVar5 = (double)pGVar9->x2;
  if (dVar5 < dVar2) {
    *(double *)&pGVar9->x2 = dVar2;
    dVar2 = (double)(pGVar10->p).x;
    dVar5 = (double)pGVar9->x2;
  }
  dVar3 = (double)pGVar9->x1;
  if (dVar2 < dVar3) {
    *(double *)&pGVar9->x1 = dVar2;
    dVar3 = dVar2;
  }
  dVar2 = (double)(pGVar10->p).y;
  dVar7 = (double)pGVar9->y2;
  if (dVar7 < dVar2) {
    *(double *)&pGVar9->y2 = dVar2;
    dVar2 = (double)(pGVar10->p).y;
    dVar7 = (double)pGVar9->y2;
  }
  dVar6 = (double)pGVar9->y1;
  if (dVar2 < dVar6) {
    *(double *)&pGVar9->y1 = dVar2;
    dVar6 = dVar2;
  }
  dVar2 = (double)(pGVar10->p).z;
  dVar8 = (double)pGVar9->z2;
  if (dVar8 < dVar2) {
    *(double *)&pGVar9->z2 = dVar2;
    dVar2 = (double)(pGVar10->p).z;
    dVar8 = (double)pGVar9->z2;
  }
  dVar4 = (double)pGVar9->z1;
  if (dVar2 < dVar4) {
    pGVar11 = t->e2;
    *(double *)&pGVar9->z1 = dVar2;
    pGVar10 = (pGVar11->segment).v1;
    if ((pGVar1->segment).v1 != pGVar10) goto LAB_08122bbf;
  }
  else {
    pGVar11 = t->e2;
    pGVar10 = (pGVar11->segment).v1;
    dVar2 = dVar4;
    if ((pGVar1->segment).v1 != pGVar10) {
LAB_08122bbf:
      if (pGVar10 != (pGVar1->segment).v2) goto LAB_08122bc8;
    }
  }
  pGVar10 = (pGVar11->segment).v2;
LAB_08122bc8:
  dVar4 = (double)(pGVar10->p).x;
  if (dVar5 < dVar4) {
    *(double *)&pGVar9->x2 = dVar4;
    dVar4 = (double)(pGVar10->p).x;
  }
  if (dVar4 < dVar3) {
    *(double *)&pGVar9->x1 = dVar4;
  }
  dVar5 = (double)(pGVar10->p).y;
  if (dVar7 < dVar5) {
    *(double *)&pGVar9->y2 = dVar5;
    dVar5 = (double)(pGVar10->p).y;
  }
  if (dVar5 < dVar6) {
    *(double *)&pGVar9->y1 = dVar5;
  }
  dVar5 = (double)(pGVar10->p).z;
  if (dVar8 < dVar5) {
    *(double *)&pGVar9->z2 = dVar5;
    dVar5 = (double)(pGVar10->p).z;
  }
  if (dVar5 < dVar2) {
    *(double *)&pGVar9->z1 = dVar5;
  }
  return pGVar9;
}



void __regparm3 bb_tree_free(GNode *tree,gboolean free_leaves)

{
  GNode *tree_00;
  char "bb_tree_free" [13];
  
  if (tree != (GNode *)0x0) {
    if ((free_leaves != 0) || (tree->children != (GNode *)0x0)) {
      gts_object_destroy((GtsObject *)tree->data);
      tree_00 = tree->children;
      while (tree_00 != (GNode *)0x0) {
        bb_tree_free(tree_00,free_leaves);
        tree_00 = tree_00->next;
      }
    }
    return;
  }
  g_return_if_fail_warning(0,"bb_tree_free","tree != NULL");
  return;
}



// WARNING: Type propagation algorithm not settling

float10 __regparm3 bb_tree_min_max(undefined4 *tree,GtsPoint *p,undefined4 *list,double min_max)

{
  GtsBBox *pGVar1;
  GtsBBox *pGVar2;
  undefined4 uVar3;
  float10 fVar4;
  float10 fVar5;
  gdouble local_3c;
  gdouble local_34;
  gdouble local_2c;
  gdouble local_24 [2];
  
  pGVar1 = (GtsBBox *)tree[4];
  if (pGVar1 == (GtsBBox *)0x0) {
    uVar3 = g_slist_prepend(*list,*tree);
    fVar5 = (float10)min_max;
    *list = uVar3;
  }
  else {
    gts_bbox_point_distance2(*(GtsBBox **)&pGVar1->object,p,local_24,&local_2c);
    pGVar2 = *(GtsBBox **)((int)&pGVar1->object + 4);
    if (local_2c <= min_max || min_max != local_2c) {
      min_max = local_2c;
    }
    gts_bbox_point_distance2(*(GtsBBox **)&pGVar2->object,p,&local_34,&local_3c);
    fVar4 = (float10)local_3c;
    fVar5 = (float10)min_max;
    if (fVar4 <= fVar5 || fVar5 != fVar4) {
      fVar5 = fVar4;
    }
    if ((float10)local_24[0] < (float10)local_34) {
      if ((float10)local_24[0] <= fVar5) {
        fVar5 = (float10)bb_tree_min_max(pGVar1,p,list,(double)fVar5);
        if ((float10)local_34 <= fVar5) {
          fVar5 = (float10)bb_tree_min_max(pGVar2,p,list,(double)fVar5);
        }
      }
    }
    else {
      if ((float10)local_34 <= fVar5) {
        fVar5 = (float10)bb_tree_min_max(pGVar2,p,list,(double)fVar5);
        if ((float10)local_24[0] <= fVar5) {
          fVar5 = (float10)bb_tree_min_max(pGVar1,p,list,(double)fVar5);
        }
      }
    }
  }
  return fVar5;
}



GSList * gts_bb_tree_point_closest_bboxes(GNode *tree,GtsPoint *p)

{
  GtsBBox *pGVar1;
  char "gts_bb_tree_point_closest_bboxes" [33];
  GtsBBox *pGVar2;
  GtsBBox *pGVar3;
  GtsBBox *pGVar4;
  float10 fVar5;
  gdouble max;
  gdouble local_3c;
  gdouble local_34;
  gdouble min;
  GtsBBox *local_20 [4];
  
  local_20[0] = (GtsBBox *)0x0;
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_closest_bboxes","tree != NULL");
    return (GSList *)0x0;
  }
  if (p != (GtsPoint *)0x0) {
    gts_bbox_point_distance2((GtsBBox *)tree->data,p,&min,&local_34);
    fVar5 = (float10)bb_tree_min_max(tree,p,local_20);
    local_34 = (double)fVar5;
    pGVar2 = (GtsBBox *)0x0;
    if (local_20[0] != (GtsBBox *)0x0) {
      pGVar1 = local_20[0];
      pGVar4 = (GtsBBox *)0x0;
      do {
        while( true ) {
          pGVar3 = pGVar1;
          pGVar1 = (GtsBBox *)(pGVar3->object).reserved;
          gts_bbox_point_distance2((GtsBBox *)(pGVar3->object).klass,p,&local_3c,&max);
          if (local_3c <= local_34) break;
          pGVar2 = pGVar1;
          if (pGVar4 != (GtsBBox *)0x0) {
            *(GtsBBox **)&(pGVar4->object).reserved = pGVar1;
            pGVar2 = local_20[0];
          }
          local_20[0] = pGVar2;
          g_slist_free_1();
          if (pGVar1 == (GtsBBox *)0x0) {
            return (GSList *)local_20[0];
          }
        }
        pGVar2 = local_20[0];
        pGVar4 = pGVar3;
      } while (pGVar1 != (GtsBBox *)0x0);
    }
    return (GSList *)pGVar2;
  }
  g_return_if_fail_warning(0,0x8160ba0,0x816106f);
  return (GSList *)0x0;
}



GtsPoint *
gts_bb_tree_point_closest(GNode *tree,GtsPoint *p,GtsBBoxClosestFunc *closest,gdouble *distance)

{
  char "gts_bb_tree_point_closest" [26];
  GSList *pGVar1;
  GtsPoint *object;
  GSList *pGVar2;
  GtsPoint *object_00;
  float10 fVar3;
  double local_24;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_closest","tree != NULL");
    return (GtsPoint *)0x0;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,0x8160b5e,0x816106f);
    return (GtsPoint *)0x0;
  }
  if (closest == (GtsBBoxClosestFunc *)0x0) {
    g_return_if_fail_warning(0,0x8160b5e,"closest != NULL");
    return (GtsPoint *)0x0;
  }
  pGVar1 = gts_bb_tree_point_closest_bboxes(tree,p);
  if (pGVar1 == (GSList *)0x0) {
    object = (GtsPoint *)0x0;
    local_24 = 
    179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
  }
  else {
    local_24 = 
    179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    pGVar2 = pGVar1;
    object_00 = (GtsPoint *)0x0;
    do {
      while( true ) {
        object = (*closest)(p,*(gpointer *)((int)pGVar2->data + 0xc));
        fVar3 = (float10)gts_point_distance2(object,p);
        if (fVar3 < (float10)local_24) break;
        gts_object_destroy((GtsObject *)object);
        pGVar2 = pGVar2->next;
        object = object_00;
        if (pGVar2 == (GSList *)0x0) goto LAB_08123049;
      }
      if (object_00 != (GtsPoint *)0x0) {
        gts_object_destroy((GtsObject *)object_00);
      }
      local_24 = (double)fVar3;
      pGVar2 = pGVar2->next;
      object_00 = object;
    } while (pGVar2 != (GSList *)0x0);
  }
LAB_08123049:
  g_slist_free(pGVar1);
  if (distance != (gdouble *)0x0) {
    *(double *)distance = local_24;
  }
  return object;
}



float10 gts_bb_tree_point_distance(GNode *tree,GtsPoint *p,code *distance,gpointer *bbox)

{
  char "gts_bb_tree_point_distance" [27];
  GSList *pGVar1;
  GSList *pGVar2;
  float10 fVar3;
  float10 fVar4;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_point_distance","tree != NULL");
    return (float10)
           179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
  }
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,0x8160b78,0x816106f);
    return (float10)
           179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
  }
  if (distance == (code *)0x0) {
    g_return_if_fail_warning(0,0x8160b78,"distance != NULL");
    return (float10)
           179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
  }
  pGVar1 = gts_bb_tree_point_closest_bboxes(tree,p);
  if (pGVar1 == (GSList *)0x0) {
    fVar3 = (float10)
            179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
  }
  else {
    fVar3 = (float10)
            179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    pGVar2 = pGVar1;
    do {
      fVar4 = (float10)(*distance)(p,*(undefined4 *)((int)pGVar2->data + 0xc));
      fVar3 = (float10)(double)fVar3;
      if ((ABS(fVar4) < ABS(fVar3)) && (fVar3 = fVar4, bbox != (gpointer *)0x0)) {
        *bbox = pGVar2->data;
      }
      pGVar2 = pGVar2->next;
    } while (pGVar2 != (GSList *)0x0);
  }
  g_slist_free(pGVar1);
  return (float10)(double)fVar3;
}



// WARNING: Could not reconcile some variable overlaps

void gts_bb_tree_segment_distance
               (GNode *tree,GtsSegment *s,anon_subr_gdouble_GtsPoint_ptr_gpointer *distance,
               gdouble delta,GtsRange *range)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  GtsPointClass *klass;
  GtsObject *object;
  uint uVar6;
  float10 fVar7;
  float local_6c;
  ulonglong local_2c;
  
  if ((((tree != (GNode *)0x0) && (s != (GtsSegment *)0x0)) &&
      (distance != (anon_subr_gdouble_GtsPoint_ptr_gpointer *)0x0)) &&
     ((0.00000000 < (float)(double)delta && (range != (GtsRange *)0x0)))) {
    pGVar1 = s->v1;
    pGVar2 = s->v2;
    dVar3 = (double)(pGVar2->p).x - (double)(pGVar1->p).x;
    dVar4 = (double)(pGVar2->p).y - (double)(pGVar1->p).y;
    dVar5 = (double)(pGVar2->p).z - (double)(pGVar1->p).z;
    gts_range_init(range);
    klass = gts_point_class();
    object = gts_object_new((GtsObjectClass *)klass);
    local_2c = (longlong)
               ROUND(SQRT(dVar5 * dVar5 + dVar4 * dVar4 + dVar3 * dVar3) /
                     (double)(float)(double)delta + 1.00000000) & 0xffffffff;
    uVar6 = 0;
    local_6c = 0.00000000;
    do {
      uVar6 = uVar6 + 1;
      *(double *)(object + 1) = (double)((float)dVar3 * local_6c + (float)(double)(pGVar1->p).x);
      *(double *)&object[1].flags = (double)((float)dVar4 * local_6c + (float)(double)(pGVar1->p).y)
      ;
      *(double *)&object[2].reserved =
           (double)((float)dVar5 * local_6c + (float)(double)(pGVar1->p).z);
      fVar7 = (float10)gts_bb_tree_point_distance(tree,object,distance,0);
      gts_range_add_value(range,(gdouble)(double)fVar7);
      local_6c = local_6c + 1.00000000 / (float)local_2c;
    } while (uVar6 <= (uint)local_2c);
    gts_object_destroy(object);
    gts_range_update(range);
    return;
  }
  g_return_if_fail_warning();
  return;
}



void surface_distance_foreach_boundary(GtsEdge *e,gpointer *data)

{
  gdouble *pgVar1;
  double *pdVar2;
  double *pdVar3;
  GtsFace *pGVar4;
  float10 fVar5;
  GtsRange range_edge;
  
  pgVar1 = (gdouble *)data[1];
  pdVar2 = (double *)data[3];
  pdVar3 = (double *)data[2];
  pGVar4 = gts_edge_is_boundary(e,(GtsSurface *)0x0);
  if (pGVar4 != (GtsFace *)0x0) {
    gts_bb_tree_segment_distance
              ((GNode *)*data,(GtsSegment *)e,(anon_subr_gdouble_GtsPoint_ptr_gpointer *)data[4],
               *pgVar1,&range_edge);
    if ((double)range_edge.min < *pdVar3) {
      *(gdouble *)pdVar3 = range_edge.min;
    }
    if (pdVar3[1] < (double)range_edge.max) {
      *(gdouble *)(pdVar3 + 1) = range_edge.max;
    }
    *(guint *)(pdVar3 + 6) = *(int *)(pdVar3 + 6) + range_edge.n;
    fVar5 = (float10)gts_point_distance((e->segment).v1,(e->segment).v2);
    *pdVar2 = (double)((float10)*pdVar2 + fVar5);
    pdVar3[2] = (double)((float10)(double)range_edge.mean * fVar5 + (float10)pdVar3[2]);
    pdVar3[3] = (double)((float10)(double)range_edge.mean * fVar5 * (float10)(double)range_edge.mean
                        + (float10)pdVar3[3]);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void gts_bb_tree_triangle_distance
               (GNode *tree,GtsTriangle *t,GtsBBoxDistFunc *distance,gdouble delta,GtsRange *range)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  uint uVar13;
  char "gts_bb_tree_triangle_distance" [30];
  GtsPointClass *klass;
  GtsObject *object;
  uint uVar14;
  float10 fVar15;
  uint local_90;
  double local_8c;
  ulonglong local_3c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,0x8160b40,"tree != NULL");
    return;
  }
  if (t == (GtsTriangle *)0x0) {
    g_return_if_fail_warning(0,0x8160b40,0x815f901);
    return;
  }
  if (distance == (GtsBBoxDistFunc *)0x0) {
    g_return_if_fail_warning(0,0x8160b40,"distance != NULL");
    return;
  }
  if ((float)(double)delta <= 0.00000000) {
    g_return_if_fail_warning(0,"gts_bb_tree_triangle_distance","delta > 0.");
    return;
  }
  if (range != (GtsRange *)0x0) {
    gts_triangle_vertices(t,local_20,&local_24,&local_28);
    dVar5 = (double)(local_20[0]->p).x;
    dVar4 = (double)(local_24->p).x - dVar5;
    dVar7 = (double)(local_20[0]->p).y;
    dVar6 = (double)(local_24->p).y - dVar7;
    dVar9 = (double)(local_20[0]->p).z;
    dVar8 = (double)(local_24->p).z - dVar9;
    dVar5 = (double)(local_28->p).x - dVar5;
    dVar7 = (double)(local_28->p).y - dVar7;
    dVar9 = (double)(local_28->p).z - dVar9;
    gts_range_init(range);
    klass = gts_point_class();
    object = gts_object_new((GtsObjectClass *)klass);
    local_90 = 0;
    local_3c = (longlong)
               ROUND(SQRT(dVar8 * dVar8 + dVar6 * dVar6 + dVar4 * dVar4) / (double)delta +
                     1.00000000) & 0xffffffff;
    uVar13 = (uint)local_3c;
    dVar4 = (double)local_3c;
    local_8c = 0.00000000;
    while( true ) {
      dVar10 = 1.00000000 - local_8c;
      dVar6 = dVar5 * dVar10;
      dVar8 = dVar7 * dVar10;
      dVar11 = dVar9 * dVar10;
      local_3c = (longlong)
                 ROUND(SQRT(dVar11 * dVar11 + dVar8 * dVar8 + dVar6 * dVar6) / (double)delta +
                       1.00000000) & 0xffffffff;
      dVar6 = (double)(local_20[0]->p).x;
      dVar8 = (double)(local_24->p).x;
      dVar11 = (double)(local_20[0]->p).y;
      dVar1 = (double)(local_24->p).y;
      dVar2 = (double)(local_20[0]->p).z;
      dVar3 = (double)(local_24->p).z;
      uVar14 = 0;
      dVar12 = 0.00000000;
      do {
        uVar14 = uVar14 + 1;
        *(double *)(object + 1) = dVar5 * dVar12 + local_8c * dVar8 + dVar6 * dVar10;
        *(double *)&object[1].flags = dVar7 * dVar12 + local_8c * dVar1 + dVar11 * dVar10;
        *(double *)&object[2].reserved = dVar9 * dVar12 + local_8c * dVar3 + dVar10 * dVar2;
        fVar15 = (float10)gts_bb_tree_point_distance(tree,object,distance,0);
        gts_range_add_value(range,(gdouble)(double)fVar15);
        dVar12 = dVar12 + dVar10 / (double)local_3c;
      } while (uVar14 <= (uint)local_3c);
      local_90 = local_90 + 1;
      if (uVar13 < local_90) break;
      local_8c = local_8c + 1.00000000 / dVar4;
    }
    gts_object_destroy(object);
    gts_range_update(range);
    return;
  }
  g_return_if_fail_warning(0,0x8160b40,0x816121d);
  return;
}



void surface_distance_foreach_triangle(GtsTriangle *t,gpointer *data)

{
  double *pdVar1;
  double *pdVar2;
  float10 fVar3;
  GtsRange range_triangle;
  
  pdVar1 = (double *)data[2];
  pdVar2 = (double *)data[3];
  gts_bb_tree_triangle_distance
            ((GNode *)*data,t,(GtsBBoxDistFunc *)data[4],*(gdouble *)data[1],&range_triangle);
  if ((double)range_triangle.min < *pdVar1) {
    *(gdouble *)pdVar1 = range_triangle.min;
  }
  if (pdVar1[1] < (double)range_triangle.max) {
    *(gdouble *)(pdVar1 + 1) = range_triangle.max;
  }
  *(guint *)(pdVar1 + 6) = *(int *)(pdVar1 + 6) + range_triangle.n;
  fVar3 = (float10)gts_triangle_area(t);
  *pdVar2 = (double)((float10)*pdVar2 + fVar3);
  pdVar1[2] = (double)((float10)(double)range_triangle.mean * fVar3 + (float10)pdVar1[2]);
  pdVar1[3] = (double)((float10)(double)range_triangle.mean *
                       fVar3 * (float10)(double)range_triangle.mean + (float10)pdVar1[3]);
  return;
}



void gts_bb_tree_destroy(GNode *tree,gboolean free_leaves)

{
  char "gts_bb_tree_destroy" [20];
  
  if (tree != (GNode *)0x0) {
    bb_tree_free(tree,free_leaves);
    g_node_destroy();
    return;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_destroy","tree != NULL");
  return;
}



GSList * gts_bb_tree_overlap(GNode *tree,GtsBBox *bbox)

{
  char "gts_bb_tree_overlap" [20];
  gboolean gVar1;
  GSList *pGVar2;
  GNode *tree_00;
  GSList *pGVar3;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_overlap","tree != NULL");
    return (GSList *)0x0;
  }
  if (bbox != (GtsBBox *)0x0) {
    pGVar3 = (GSList *)0x0;
    gVar1 = gts_bboxes_are_overlapping(bbox,(GtsBBox *)tree->data);
    if (gVar1 != 0) {
      tree_00 = tree->children;
      if (tree_00 == (GNode *)0x0) {
        pGVar3 = (GSList *)g_slist_prepend();
        return pGVar3;
      }
      do {
        pGVar2 = gts_bb_tree_overlap(tree_00,bbox);
        pGVar3 = (GSList *)g_slist_concat(pGVar3,pGVar2);
        tree_00 = tree_00->next;
      } while (tree_00 != (GNode *)0x0);
    }
    return pGVar3;
  }
  g_return_if_fail_warning(0,0x8160c3c,"bbox != NULL");
  return (GSList *)0x0;
}



GSList * gts_bb_tree_stabbed(GNode *tree,GtsPoint *p)

{
  char "gts_bb_tree_stabbed" [20];
  gboolean gVar1;
  GSList *pGVar2;
  GNode *tree_00;
  GSList *pGVar3;
  
  if (tree == (GNode *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_stabbed","tree != NULL");
    return (GSList *)0x0;
  }
  if (p != (GtsPoint *)0x0) {
    pGVar3 = (GSList *)0x0;
    gVar1 = gts_bbox_is_stabbed((GtsBBox *)tree->data,p);
    if (gVar1 != 0) {
      tree_00 = tree->children;
      if (tree_00 == (GNode *)0x0) {
        pGVar3 = (GSList *)g_slist_prepend();
        return pGVar3;
      }
      do {
        pGVar2 = gts_bb_tree_stabbed(tree_00,p);
        pGVar3 = (GSList *)g_slist_concat(pGVar3,pGVar2);
        tree_00 = tree_00->next;
      } while (tree_00 != (GNode *)0x0);
    }
    return pGVar3;
  }
  g_return_if_fail_warning(0,0x8160c50,0x816106f);
  return (GSList *)0x0;
}



gboolean gts_bbox_overlaps_segment(GtsBBox *bb,GtsSegment *s)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  char "gts_bbox_overlaps_segment" [26];
  int iVar3;
  double tv [3] [3];
  double bh [3];
  double bc [3];
  
  if (bb == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_overlaps_segment","bb != NULL");
    return 0;
  }
  if (s != (GtsSegment *)0x0) {
    pGVar1 = s->v1;
    bc[0] = ((double)bb->x2 + (double)bb->x1) * 0.50000000;
    bh[0] = ((double)bb->x2 - (double)bb->x1) * 0.50000000;
    bc[1] = ((double)bb->y2 + (double)bb->y1) * 0.50000000;
    bh[1] = ((double)bb->y2 - (double)bb->y1) * 0.50000000;
    pGVar2 = s->v2;
    bc[2] = ((double)bb->z2 + (double)bb->z1) * 0.50000000;
    bh[2] = ((double)bb->z2 - (double)bb->z1) * 0.50000000;
    tv[0][0] = (double)(pGVar1->p).x;
    tv[0][1] = (double)(pGVar1->p).y;
    tv[0][2] = (double)(pGVar1->p).z;
    tv[1][0] = (double)(pGVar2->p).x;
    tv[1][1] = (double)(pGVar2->p).y;
    tv[1][2] = (double)(pGVar2->p).z;
    tv[2][0] = tv[0][0];
    tv[2][1] = tv[0][1];
    tv[2][2] = tv[0][2];
    iVar3 = triBoxOverlap(bc,bh,(double (*) [3])tv);
    return iVar3;
  }
  g_return_if_fail_warning(0,0x8160c88,0x815fd1b);
  return 0;
}



gboolean gts_bbox_overlaps_triangle(GtsBBox *bb,GtsTriangle *t)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  char "gts_bbox_overlaps_triangle" [27];
  GtsVertex *pGVar3;
  int iVar4;
  double tv [3] [3];
  double bh [3];
  double bc [3];
  
  if (bb == (GtsBBox *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_overlaps_triangle","bb != NULL");
    return 0;
  }
  if (t != (GtsTriangle *)0x0) {
    pGVar1 = (t->e1->segment).v1;
    pGVar2 = (t->e1->segment).v2;
    pGVar3 = (t->e2->segment).v1;
    if ((pGVar1 == pGVar3) || (pGVar2 == pGVar3)) {
      pGVar3 = (t->e2->segment).v2;
    }
    tv[0][0] = (double)(pGVar1->p).x;
    tv[0][1] = (double)(pGVar1->p).y;
    tv[0][2] = (double)(pGVar1->p).z;
    tv[1][0] = (double)(pGVar2->p).x;
    tv[1][1] = (double)(pGVar2->p).y;
    tv[1][2] = (double)(pGVar2->p).z;
    tv[2][0] = (double)(pGVar3->p).x;
    tv[2][1] = (double)(pGVar3->p).y;
    tv[2][2] = (double)(pGVar3->p).z;
    bh[0] = ((double)bb->x2 - (double)bb->x1) * 0.50000000;
    bh[1] = ((double)bb->y2 - (double)bb->y1) * 0.50000000;
    bh[2] = ((double)bb->z2 - (double)bb->z1) * 0.50000000;
    bc[0] = ((double)bb->x1 + (double)bb->x2) * 0.50000000;
    bc[1] = ((double)bb->y1 + (double)bb->y2) * 0.50000000;
    bc[2] = ((double)bb->z2 + (double)bb->z1) * 0.50000000;
    iVar4 = triBoxOverlap(bc,bh,(double (*) [3])tv);
    return iVar4;
  }
  g_return_if_fail_warning(0,0x8160ca2,0x815f901);
  return 0;
}



void gts_bbox_draw(GtsBBox *bb,FILE *fptr)

{
  char "gts_bbox_draw" [14];
  
  if (bb != (GtsBBox *)0x0) {
    __fprintf_chk(fptr,1,"OFF 8 6 12\n");
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y1,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y1,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y2,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y2,bb->z1);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y1,bb->z2);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y1,bb->z2);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x2,bb->y2,bb->z2);
    __fprintf_chk(fptr,1,"%g %g %g\n",bb->x1,bb->y2,bb->z2);
    fwrite("4 3 2 1 0\n4 4 5 6 7\n4 2 3 7 6\n4 0 1 5 4\n4 0 4 7 3\n4 1 2 6 5\n",1,0x3c,(FILE *)fptr)
    ;
    return;
  }
  g_return_if_fail_warning(0,"gts_bbox_draw","bb != NULL");
  return;
}



void gts_bb_tree_draw(GNode *tree,guint depth,FILE *fptr)

{
  GNode *tree_00;
  uint uVar1;
  
  if ((tree == (GNode *)0x0) || (fptr == (FILE *)0x0)) {
    g_return_if_fail_warning();
    return;
  }
  uVar1 = g_node_depth(tree);
  if (uVar1 == 1) {
    __fprintf_chk(fptr,1,"{ LIST");
    if (depth == 1) goto LAB_08124080;
  }
  else {
    if (uVar1 == depth) {
LAB_08124080:
      gts_bbox_draw((GtsBBox *)tree->data,fptr);
      goto LAB_08123fed;
    }
  }
  if (uVar1 < depth) {
    tree_00 = tree->children;
    while (tree_00 != (GNode *)0x0) {
      gts_bb_tree_draw(tree_00,depth,fptr);
      tree_00 = tree_00->next;
    }
  }
LAB_08123fed:
  if (uVar1 != 1) {
    return;
  }
  __fprintf_chk();
  return;
}



GtsBBox * gts_bbox_surface(GtsBBoxClass *klass,GtsSurface *surface)

{
  char "gts_bbox_surface" [17];
  GtsBBox *data;
  
  if (klass == (GtsBBoxClass *)0x0) {
    g_return_if_fail_warning(0,"gts_bbox_surface","klass != NULL");
    return (GtsBBox *)0x0;
  }
  if (surface != (GtsSurface *)0x0) {
    data = gts_bbox_new(klass,surface,0.00000000,0.00000000,0.00000000,0.00000000,0.00000000,
                        0.00000000);
    data->z1 = 
    179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    data->y1 = 
    179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    data->x1 = 
    179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    data->z2 = 
    -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    data->y2 = 
    -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    data->x2 = 
    -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    gts_surface_foreach_vertex(surface,bbox_foreach_vertex,data);
    return data;
  }
  g_return_if_fail_warning(0,0x8160d1b,"surface != NULL");
  return (GtsBBox *)0x0;
}



GtsBBoxClass * gts_bbox_class(void)

{
  GtsBBoxClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo bbox_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsBBoxClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &bbox_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    bbox_info.name._0_4_ = 0x42737447;
    bbox_info.name._4_4_ = 0x786f42;
    do {
      *(undefined4 *)(&stack0x00000014 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsBBoxClass *)((klass->parent_class).info.name + 4);
    } while (klass < (GtsBBoxClass *)&DAT_00000020);
    bbox_info.object_size = 0x40;
    bbox_info.class_size = 0x5c;
    bbox_info.object_init_func = bbox_init;
    parent_class = gts_object_class();
    klass = (GtsBBoxClass *)gts_object_class_new(parent_class,&bbox_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void prepend_triangle_bbox(GtsTriangle *t,GSList **bboxes)

{
  GtsBBoxClass *klass;
  GtsBBox *pGVar1;
  GSList *pGVar2;
  
  klass = gts_bbox_class();
  pGVar1 = gts_bbox_triangle(klass,t);
  pGVar2 = (GSList *)g_slist_prepend(*bboxes,pGVar1);
  *bboxes = pGVar2;
  return;
}



GNode * gts_bb_tree_new(GSList *bboxes)

{
  double dVar1;
  double dVar2;
  gpointer pvVar3;
  char "gts_bb_tree_new" [16];
  GtsBBoxClass *klass;
  GtsBBox *pGVar4;
  GNode *pGVar5;
  GNode *pGVar6;
  GSList *bboxes_00;
  int iVar7;
  GSList *bboxes_01;
  int local_2c;
  int local_28;
  
  if (bboxes == (GSList *)0x0) {
    g_return_if_fail_warning(0,"gts_bb_tree_new","bboxes != NULL");
    return (GNode *)0x0;
  }
  if (bboxes->next == (GSList *)0x0) {
    pGVar6 = (GNode *)g_node_new();
    return pGVar6;
  }
  klass = gts_bbox_class();
  pGVar4 = gts_bbox_bboxes(klass,bboxes);
  pGVar6 = (GNode *)g_node_new(pGVar4);
  dVar1 = (double)pGVar4->x2 - (double)pGVar4->x1;
  dVar2 = (double)pGVar4->y2 - (double)pGVar4->y1;
  if (dVar1 <= dVar2) {
    iVar7 = 8;
    if ((double)pGVar4->z2 - (double)pGVar4->z1 <= dVar2) goto LAB_081242b7;
  }
  else {
    iVar7 = 0;
    if ((double)pGVar4->z2 - (double)pGVar4->z1 <= dVar1) goto LAB_081242b7;
  }
  iVar7 = 0x10;
LAB_081242b7:
  dVar1 = *(double *)((int)&pGVar4->x1 + iVar7);
  bboxes_00 = (GSList *)0x0;
  dVar2 = *(double *)((int)&pGVar4->x2 + iVar7);
  bboxes_01 = (GSList *)0x0;
  local_28 = 0;
  local_2c = 0;
  do {
    while (pvVar3 = bboxes->data,
          (*(double *)((int)pvVar3 + iVar7 + 0x10) + *(double *)((int)pvVar3 + iVar7 + 0x28)) *
          0.50000000 <= (double)((float)(dVar1 + dVar2) * 0.50000000)) {
      bboxes_01 = (GSList *)g_slist_prepend(bboxes_01,pvVar3);
      bboxes = bboxes->next;
      local_28 = local_28 + 1;
      if (bboxes == (GSList *)0x0) goto LAB_0812433b;
    }
    bboxes_00 = (GSList *)g_slist_prepend(bboxes_00,pvVar3);
    bboxes = bboxes->next;
    local_2c = local_2c + 1;
  } while (bboxes != (GSList *)0x0);
LAB_0812433b:
  if (bboxes_00 == (GSList *)0x0) {
    iVar7 = g_slist_nth(bboxes_01,local_28 - 1U >> 1);
    bboxes_00 = *(GSList **)(iVar7 + 4);
    *(undefined4 *)(iVar7 + 4) = 0;
  }
  else {
    if (bboxes_01 == (GSList *)0x0) {
      iVar7 = g_slist_nth(bboxes_00,local_2c - 1U >> 1);
      bboxes_01 = *(GSList **)(iVar7 + 4);
      *(undefined4 *)(iVar7 + 4) = 0;
    }
  }
  pGVar5 = gts_bb_tree_new(bboxes_00);
  g_node_prepend(pGVar6,pGVar5);
  g_slist_free(bboxes_00);
  pGVar5 = gts_bb_tree_new(bboxes_01);
  g_node_prepend(pGVar6,pGVar5);
  g_slist_free(bboxes_01);
  return pGVar6;
}



GNode * gts_bb_tree_surface(GtsSurface *s)

{
  char "gts_bb_tree_surface" [20];
  GNode *pGVar1;
  GSList *local_10 [2];
  
  local_10[0] = (GSList *)0x0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_face(s,prepend_triangle_bbox,local_10);
    pGVar1 = gts_bb_tree_new(local_10[0]);
    g_slist_free(local_10[0]);
    return pGVar1;
  }
  g_return_if_fail_warning(0,"gts_bb_tree_surface",0x815fd1b);
  return (GNode *)0x0;
}



guint gts_file_read(GtsFile *f,gpointer ptr,guint size,guint nmemb)

{
  char "gts_file_read" [14];
  guint gVar1;
  uint uVar2;
  uint uVar3;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_read","f != NULL");
    return 0;
  }
  if (ptr != (gpointer)0x0) {
    if (f->fp == (FILE *)0x0) {
      g_return_if_fail_warning(0,0x8160fb8,"f->fp != NULL");
      return 0;
    }
    gVar1 = 0;
    if (f->type != GTS_ERROR) {
      gVar1 = fread(ptr,size,nmemb,(FILE *)f->fp);
      uVar3 = size * gVar1;
      if (uVar3 != 0) {
        uVar2 = 0;
        do {
          while (f->curpos = f->curpos + 1, *(char *)((int)ptr + uVar2) == '\n') {
            uVar2 = uVar2 + 1;
            f->curline = f->curline + 1;
            f->curpos = 1;
            if (uVar3 < uVar2 || uVar3 - uVar2 == 0) {
              return gVar1;
            }
          }
          uVar2 = uVar2 + 1;
        } while (uVar2 <= uVar3 && uVar3 - uVar2 != 0);
      }
    }
    return gVar1;
  }
  g_return_if_fail_warning(0,0x8160fb8,0x8160ab8);
  return 0;
}



void gts_file_verror(GtsFile *f,gchar *format,va_list args)

{
  char "gts_file_verror" [16];
  gchar *pgVar1;
  
  if ((f != (GtsFile *)0x0) && (format != (gchar *)0x0)) {
    if (f->type == GTS_ERROR) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr
                (0,"../../src/gts/misc.c",0x8c,"gts_file_verror","f->type != GTS_ERROR");
    }
    pgVar1 = (gchar *)g_strdup_vprintf(format,args);
    f->type = GTS_ERROR;
    f->error = pgVar1;
    return;
  }
  g_return_if_fail_warning();
  return;
}



void gts_file_variable_error(GtsFile *f,GtsFileVariable *vars,gchar *name,gchar *format,...)

{
  char "gts_file_variable_error" [24];
  int iVar1;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,0x8160f18,"f != NULL");
    return;
  }
  if (vars == (GtsFileVariable *)0x0) {
    g_return_if_fail_warning(0,0x8160f18,"vars != NULL");
    return;
  }
  if (name == (gchar *)0x0) {
    g_return_if_fail_warning(0,0x8160f18,"name != NULL");
    return;
  }
  if (format == (gchar *)0x0) {
    g_return_if_fail_warning(0,0x8160f18,"format != NULL");
    return;
  }
  while( true ) {
    if (vars->type == GTS_NONE) {
      g_return_if_fail_warning(0,"gts_file_variable_error","var->type != GTS_NONE");
      return;
    }
    iVar1 = strcmp(vars->name,name);
    if (iVar1 == 0) break;
    vars = vars + 1;
  }
  if (vars->set != 0) {
    f->line = vars->line;
    f->pos = vars->pos;
  }
  gts_file_verror(f,format,&stack0x00000014);
  return;
}



void gts_file_error(GtsFile *f,gchar *format,...)

{
  char "gts_file_error" [15];
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_error","f != NULL");
    return;
  }
  if (format != (gchar *)0x0) {
    gts_file_verror(f,format,&stack0x0000000c);
    return;
  }
  g_return_if_fail_warning(0,0x8160fd4,"format != NULL");
  return;
}



gint gts_file_getc(GtsFile *f)

{
  char cVar1;
  char "gts_file_getc" [14];
  int iVar2;
  char *pcVar3;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_getc","f != NULL");
  }
  else {
    if (f->type != GTS_ERROR) {
      if (f->fp == (FILE *)0x0) {
        iVar2 = -1;
        cVar1 = *f->s;
        if (cVar1 != '\0') {
          iVar2 = (int)cVar1;
          f->s = f->s + 1;
        }
      }
      else {
        iVar2 = fgetc((FILE *)f->fp);
      }
      f->curpos = f->curpos + 1;
LAB_08124880:
      do {
        pcVar3 = f->comments;
        while( true ) {
          if (*pcVar3 == '\0') {
            if (iVar2 == 0x7b) {
              f->scope = f->scope + 1;
              return 0x7b;
            }
            if (iVar2 != 0x7d) {
              if (iVar2 != 10) {
                return iVar2;
              }
              f->curline = f->curline + 1;
              f->curpos = 1;
              return 10;
            }
            if (f->scope != 0) {
              f->scope = f->scope - 1;
              return 0x7d;
            }
            f->line = f->curline;
            f->pos = f->curpos - 1;
            gts_file_error(f,"no matching opening brace");
            return -1;
          }
          if ((char)iVar2 == *pcVar3) break;
          pcVar3 = pcVar3 + 1;
        }
        while (iVar2 != 10) {
          while( true ) {
            if (iVar2 == -1) goto LAB_081248b5;
            if (f->fp == (FILE *)0x0) break;
            iVar2 = fgetc((FILE *)f->fp);
            if (iVar2 == 10) goto LAB_081248b5;
          }
          cVar1 = *f->s;
          if (cVar1 == '\0') {
            iVar2 = -1;
            goto LAB_08124880;
          }
          iVar2 = (int)cVar1;
          f->s = f->s + 1;
        }
LAB_081248b5:
        if (iVar2 == 10) {
          f->curline = f->curline + 1;
          f->curpos = 1;
          if (f->fp == (FILE *)0x0) {
            iVar2 = -1;
            cVar1 = *f->s;
            if (cVar1 != '\0') {
              iVar2 = (int)cVar1;
              f->s = f->s + 1;
            }
          }
          else {
            iVar2 = fgetc((FILE *)f->fp);
          }
        }
      } while( true );
    }
  }
  return -1;
}



gint gts_file_getc_scope(GtsFile *f)

{
  char "gts_file_getc_scope" [20];
  gint gVar1;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_getc_scope","f != NULL");
    return -1;
  }
  gVar1 = -1;
  if (f->type != GTS_ERROR) {
    if (f->scope < f->scope_max || f->scope == f->scope_max) {
      gVar1 = gts_file_getc(f);
      return gVar1;
    }
    do {
      gVar1 = gts_file_getc(f);
      if (gVar1 == -1) {
        return -1;
      }
    } while (f->scope_max <= f->scope && f->scope != f->scope_max);
  }
  return gVar1;
}



void gts_file_destroy(GtsFile *f)

{
  char "gts_file_destroy" [17];
  
  if (f != (GtsFile *)0x0) {
    g_free(f->delimiters);
    g_free(f->comments);
    g_free(f->tokens);
    if (f->error != (gchar *)0x0) {
      g_free(f->error);
    }
    if (f->s1 != (gchar *)0x0) {
      g_free(f->s1);
    }
    g_string_free(f->token,1);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_file_destroy","f != NULL");
  return;
}



GtsFile * file_new(void)

{
  GtsFile *pGVar1;
  GString *pGVar2;
  gchar *pgVar3;
  
  pGVar1 = (GtsFile *)g_malloc(0x40);
  pGVar1->fp = (FILE *)0x0;
  pGVar1->s1 = (gchar *)0x0;
  pGVar1->s = (gchar *)0x0;
  pGVar1->curline = 1;
  pGVar1->curpos = 1;
  pGVar2 = (GString *)g_string_new(&DAT_0814741b);
  pGVar1->type = 0;
  pGVar1->error = (gchar *)0x0;
  pGVar1->next_token = 0;
  pGVar1->scope_max = 0;
  pGVar1->scope = 0;
  pGVar1->token = pGVar2;
  pgVar3 = (gchar *)g_strdup(&DAT_08160ded);
  pGVar1->delimiters = pgVar3;
  pgVar3 = (gchar *)g_strdup(&DAT_08160df0);
  pGVar1->comments = pgVar3;
  pgVar3 = (gchar *)g_strdup("\n{}()=");
  pGVar1->tokens = pgVar3;
  return pGVar1;
}



void gts_file_next_token(GtsFile *f)

{
  GString *pGVar1;
  gsize gVar2;
  char "gts_file_next_token" [20];
  GtsTokenType GVar3;
  char cVar4;
  char *pcVar5;
  int iVar6;
  char cVar7;
  char cVar8;
  char *__s1;
  char *pcVar9;
  char *pcVar10;
  bool bVar11;
  byte bVar12;
  
  bVar12 = 0;
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_next_token","f != NULL");
    return;
  }
  if (f->type == GTS_ERROR) {
    return;
  }
  *f->token->str = '\0';
  pGVar1 = f->token;
  pGVar1->len = 0;
  GVar3 = f->next_token;
  if (GVar3 == 0) {
    GVar3 = gts_file_getc_scope(f);
  }
  else {
    __s1 = f->tokens;
    while (*__s1 != '\0') {
      cVar4 = (char)GVar3;
      if (cVar4 == *__s1) {
        f->line = f->curline;
        f->pos = f->curpos - 1;
        gVar2 = pGVar1->len;
        if (gVar2 + 1 < pGVar1->allocated_len) {
          pGVar1->str[gVar2] = cVar4;
          pGVar1->len = gVar2 + 1;
          pGVar1->str[gVar2 + 1] = '\0';
        }
        else {
          g_string_insert_c(pGVar1,0xffffffff,(int)cVar4);
        }
        GVar3 = f->next_token;
        f->next_token = 0;
        f->type = GVar3;
        return;
      }
      __s1 = __s1 + 1;
    }
    f->next_token = 0;
  }
  bVar11 = false;
  f->type = GTS_NONE;
  if (GVar3 != 0xffffffff) {
LAB_08124c50:
    do {
      cVar4 = (char)GVar3;
      if (bVar11) {
        __s1 = f->delimiters;
        while (*__s1 != '\0') {
          if (cVar4 == *__s1) goto LAB_08124c72;
          __s1 = __s1 + 1;
        }
        __s1 = f->tokens;
        while (*__s1 != '\0') {
          if (cVar4 == *__s1) {
            f->next_token = GVar3;
            GVar3 = f->type;
            goto LAB_08124c75;
          }
          __s1 = __s1 + 1;
        }
        pGVar1 = f->token;
        gVar2 = pGVar1->len;
        if (pGVar1->allocated_len <= gVar2 + 1) {
          g_string_insert_c(pGVar1,0xffffffff,(int)cVar4);
          GVar3 = gts_file_getc_scope(f);
          if (GVar3 == 0xffffffff) break;
          goto LAB_08124c50;
        }
        pGVar1->str[gVar2] = cVar4;
        pGVar1->len = gVar2 + 1;
        pGVar1->str[gVar2 + 1] = '\0';
        GVar3 = gts_file_getc_scope(f);
      }
      else {
        __s1 = f->delimiters;
        while (*__s1 != '\0') {
          if (cVar4 == *__s1) {
            GVar3 = gts_file_getc_scope(f);
            goto joined_r0x08124cf3;
          }
          __s1 = __s1 + 1;
        }
        f->line = f->curline;
        f->pos = f->curpos - 1;
        pGVar1 = f->token;
        gVar2 = pGVar1->len;
        if (gVar2 + 1 < pGVar1->allocated_len) {
          pGVar1->str[gVar2] = cVar4;
          pGVar1->len = gVar2 + 1;
          pGVar1->str[gVar2 + 1] = '\0';
        }
        else {
          g_string_insert_c(pGVar1,0xffffffff,(int)cVar4);
        }
        __s1 = f->tokens;
        while (*__s1 != '\0') {
          if (cVar4 == *__s1) {
            f->type = GVar3;
            goto LAB_08124c75;
          }
          __s1 = __s1 + 1;
        }
        bVar11 = true;
        GVar3 = gts_file_getc_scope(f);
      }
joined_r0x08124cf3:
    } while (GVar3 != 0xffffffff);
LAB_08124c72:
    GVar3 = f->type;
LAB_08124c75:
    if (GVar3 != GTS_NONE) {
      return;
    }
  }
  if (f->token->len == 0) {
    return;
  }
  __s1 = f->token->str;
  cVar8 = *__s1;
  pcVar9 = __s1;
  cVar4 = cVar8;
  while (cVar4 != '\0') {
    pcVar5 = "+-";
    while( true ) {
      pcVar10 = __s1;
      cVar7 = cVar8;
      if (*pcVar5 == '\0') goto LAB_08124e45;
      if (cVar4 == *pcVar5) break;
      pcVar5 = pcVar5 + 1;
    }
    pcVar9 = pcVar9 + 1;
    cVar4 = *pcVar9;
  }
  goto LAB_08124cbc;
LAB_08124e79:
  do {
    pcVar9 = "+-eE.";
    while( true ) {
      pcVar10 = __s1;
      cVar7 = cVar8;
      if (*pcVar9 == '\0') goto LAB_08124ea2;
      if (cVar4 == *pcVar9) break;
      pcVar9 = pcVar9 + 1;
    }
    cVar4 = pcVar5[1];
    pcVar5 = pcVar5 + 1;
  } while (cVar4 != '\0');
  goto LAB_08124cbc;
LAB_08124ea2:
  do {
    pcVar9 = "+-0123456789eE.";
    while( true ) {
      bVar11 = *pcVar9 == '\0';
      if (bVar11) {
        iVar6 = 2;
        pcVar9 = __s1;
        pcVar5 = "0x";
        goto code_r0x08124f13;
      }
      if (cVar7 == *pcVar9) break;
      pcVar9 = pcVar9 + 1;
    }
    cVar7 = pcVar10[1];
    pcVar10 = pcVar10 + 1;
  } while (cVar7 != '\0');
  goto LAB_08124ec8;
LAB_08124e45:
  do {
    pcVar9 = "+-0123456789";
    while( true ) {
      pcVar5 = __s1;
      cVar4 = cVar8;
      if (*pcVar9 == '\0') goto LAB_08124e79;
      if (cVar7 == *pcVar9) break;
      pcVar9 = pcVar9 + 1;
    }
    cVar7 = pcVar10[1];
    pcVar10 = pcVar10 + 1;
  } while (cVar7 != '\0');
LAB_08124e68:
  f->type = GTS_INT;
  return;
LAB_08124f72:
  do {
    pcVar9 = "+-0123456789abcdefx.p";
    while( true ) {
      if (*pcVar9 == '\0') goto LAB_08124cbc;
      if (cVar8 == *pcVar9) break;
      pcVar9 = pcVar9 + 1;
    }
    __s1 = __s1 + 1;
    cVar8 = *__s1;
  } while (cVar8 != '\0');
LAB_08124ec8:
  f->type = GTS_FLOAT;
  return;
  while( true ) {
    iVar6 = iVar6 + -1;
    bVar11 = *pcVar9 == *pcVar5;
    pcVar9 = pcVar9 + (uint)bVar12 * -2 + 1;
    pcVar5 = pcVar5 + (uint)bVar12 * -2 + 1;
    if (!bVar11) break;
code_r0x08124f13:
    if (iVar6 == 0) break;
  }
  pcVar9 = __s1;
  cVar4 = cVar8;
  if (((bVar11) || (iVar6 = strncmp(__s1,"-0x",3), iVar6 == 0)) ||
     (iVar6 = strncmp(__s1,"+0x",3), iVar6 == 0)) {
    do {
      pcVar5 = "+-0123456789abcdefx";
      while( true ) {
        if (*pcVar5 == '\0') goto LAB_08124f72;
        if (cVar4 == *pcVar5) break;
        pcVar5 = pcVar5 + 1;
      }
      cVar4 = pcVar9[1];
      pcVar9 = pcVar9 + 1;
    } while (cVar4 != '\0');
    goto LAB_08124e68;
  }
LAB_08124cbc:
  f->type = GTS_STRING;
  return;
}



GtsFileVariable * gts_file_assign_next(GtsFile *f,GtsFileVariable *vars)

{
  GtsTokenType GVar1;
  double *pdVar2;
  float *pfVar3;
  long *plVar4;
  undefined4 *puVar5;
  bool bVar6;
  char "gts_file_assign_next" [21];
  int iVar7;
  long lVar8;
  undefined4 uVar9;
  double dVar10;
  char *local_48;
  GtsTokenType local_24;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_next","f != NULL");
    return (GtsFileVariable *)0x0;
  }
  if (vars == (GtsFileVariable *)0x0) {
    g_return_if_fail_warning(0,0x8160f4a,"vars != NULL");
    return (GtsFileVariable *)0x0;
  }
  while (local_24 = f->type, local_24 == 10) {
    gts_file_next_token(f);
  }
  if (local_24 == 0x7d) {
    f->scope_max = f->scope_max - 1;
    gts_file_next_token(f);
    return (GtsFileVariable *)0x0;
  }
  if (local_24 != GTS_ERROR) {
    bVar6 = false;
LAB_08125048:
    if (local_24 != GTS_ERROR) {
      while( true ) {
        if (bVar6) goto LAB_081250e0;
        if (vars->type == GTS_NONE) goto LAB_08125430;
        iVar7 = strcmp(vars->name,f->token->str);
        if (iVar7 != 0) {
          vars = vars + 1;
          goto LAB_08125048;
        }
        if ((vars->unique != 0) && (vars->set != 0)) {
          gts_file_error(f,"variable `%s\' was already set at line %d:%d",vars->name,vars->line,
                         vars->pos);
          local_24 = f->type;
          bVar6 = true;
          goto LAB_08125048;
        }
        vars->line = f->line;
        vars->pos = f->pos;
        gts_file_next_token(f);
        if (f->type == 0x3d) break;
        gts_file_error(f,"expecting `=\'");
        local_24 = f->type;
        bVar6 = true;
        if (local_24 == GTS_ERROR) goto LAB_081250e0;
      }
      GVar1 = vars->type;
      vars->set = 1;
      if (GVar1 == GTS_FLOAT) {
        gts_file_next_token(f);
        local_24 = f->type;
        if ((local_24 == GTS_FLOAT) || (local_24 == GTS_INT)) {
          pfVar3 = (float *)vars->data;
          if (pfVar3 == (float *)0x0) goto LAB_08125420;
          dVar10 = strtod(f->token->str,(char **)0x0);
          bVar6 = true;
          *pfVar3 = (float)dVar10;
          local_24 = f->type;
          goto LAB_08125048;
        }
LAB_081253af:
        local_48 = "expecting a number";
      }
      else {
        if (GTS_FLOAT < GVar1) {
          if (GVar1 == GTS_STRING) {
            gts_file_next_token(f);
            local_24 = f->type;
            if (((local_24 != GTS_FLOAT) && (local_24 != GTS_INT)) && (local_24 != GTS_STRING)) {
              local_48 = "expecting a string";
              goto LAB_08125255;
            }
            puVar5 = (undefined4 *)vars->data;
            if (puVar5 != (undefined4 *)0x0) {
              uVar9 = g_strdup(f->token->str);
              *puVar5 = uVar9;
              local_24 = f->type;
              bVar6 = true;
              goto LAB_08125048;
            }
          }
          else {
            if (GVar1 == GTS_FILE) goto LAB_081250f8;
            if (GVar1 != GTS_DOUBLE) goto LAB_08125156;
            gts_file_next_token(f);
            local_24 = f->type;
            if ((local_24 != GTS_FLOAT) && (local_24 != GTS_INT)) goto LAB_081253af;
            pdVar2 = (double *)vars->data;
            if (pdVar2 != (double *)0x0) {
              dVar10 = strtod(f->token->str,(char **)0x0);
              local_24 = f->type;
              bVar6 = true;
              *pdVar2 = dVar10;
              goto LAB_08125048;
            }
          }
LAB_08125420:
          bVar6 = true;
          goto LAB_08125048;
        }
        if ((GVar1 != GTS_INT) && (GVar1 != GTS_UINT)) {
LAB_08125156:
                    // WARNING: Subroutine does not return
          g_assertion_message(0,"../../src/gts/misc.c",0x217,0x8160f4a,0);
        }
        gts_file_next_token(f);
        if (f->type == GTS_INT) {
          plVar4 = (long *)vars->data;
          if (plVar4 == (long *)0x0) goto LAB_081250f8;
          lVar8 = strtol(f->token->str,(char **)0x0,10);
          *plVar4 = lVar8;
          local_24 = f->type;
          bVar6 = true;
          goto LAB_08125048;
        }
        local_48 = "expecting an integer";
      }
LAB_08125255:
      gts_file_error(f,local_48);
      local_24 = f->type;
      vars->set = 0;
      bVar6 = true;
      goto LAB_08125048;
    }
LAB_081250e0:
    if (!bVar6) {
LAB_08125430:
      gts_file_error(f,"unknown identifier `%s\'",f->token->str);
      return (GtsFileVariable *)0x0;
    }
    if (local_24 != GTS_ERROR) {
LAB_081250f8:
      if (vars->set != 0) {
        gts_file_next_token(f);
        return vars;
      }
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/misc.c",0x222,0x8160f4a,"var->set");
    }
  }
  return (GtsFileVariable *)0x0;
}



void gts_file_assign_start(GtsFile *f,GtsFileVariable *vars)

{
  char "gts_file_assign_start" [22];
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,0x8160f5f,"f != NULL");
    return;
  }
  if (vars == (GtsFileVariable *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_start","vars != NULL");
    return;
  }
  while (vars->type != GTS_NONE) {
    vars->set = 0;
    vars = vars + 1;
  }
  if (f->type != 0x7b) {
    gts_file_error(f,"expecting an opening brace");
    return;
  }
  f->scope_max = f->scope_max + 1;
  gts_file_next_token(f);
  return;
}



void gts_file_assign_variables(GtsFile *f,GtsFileVariable *vars)

{
  char "gts_file_assign_variables" [26];
  GtsFileVariable *pGVar1;
  
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,"gts_file_assign_variables","f != NULL");
    return;
  }
  if (vars != (GtsFileVariable *)0x0) {
    gts_file_assign_start(f,vars);
    do {
      pGVar1 = gts_file_assign_next(f,vars);
    } while (pGVar1 != (GtsFileVariable *)0x0);
    return;
  }
  g_return_if_fail_warning(0,0x8160f30,"vars != NULL");
  return;
}



void gts_file_first_token_after(GtsFile *f,GtsTokenType type)

{
  char "gts_file_first_token_after" [27];
  GtsTokenType GVar1;
  
  if (f != (GtsFile *)0x0) {
    GVar1 = f->type;
    if ((GVar1 != GTS_ERROR) && (GVar1 != GTS_NONE)) {
      do {
        if (GVar1 == type) goto LAB_08125600;
        gts_file_next_token(f);
        GVar1 = f->type;
      } while ((GVar1 != GTS_NONE) && (GVar1 != GTS_ERROR));
    }
    if (type == GVar1) {
      gts_file_next_token(f);
      GVar1 = f->type;
      while (type == GVar1) {
LAB_08125600:
        gts_file_next_token(f);
        GVar1 = f->type;
      }
    }
    return;
  }
  g_return_if_fail_warning(0,"gts_file_first_token_after","f != NULL");
  return;
}



GtsFile * gts_file_new_from_string(gchar *s)

{
  char "gts_file_new_from_string" [25];
  GtsFile *f;
  gchar *pgVar1;
  
  if (s != (gchar *)0x0) {
    f = file_new();
    pgVar1 = (gchar *)g_strdup(s);
    f->s = pgVar1;
    f->s1 = pgVar1;
    gts_file_next_token(f);
    return f;
  }
  g_return_if_fail_warning(0,"gts_file_new_from_string",0x815fd1b);
  return (GtsFile *)0x0;
}



GtsFile * gts_file_new(FILE *fp)

{
  char "gts_file_new" [13];
  GtsFile *f;
  
  if (fp != (FILE *)0x0) {
    f = file_new();
    f->fp = fp;
    gts_file_next_token(f);
    return f;
  }
  g_return_if_fail_warning(0,"gts_file_new",0x8160d6c);
  return (GtsFile *)0x0;
}



void gts_predicates_init(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  bool bVar4;
  int iVar5;
  
  fVar3 = 1.00000000;
  iVar5 = 0;
  bVar4 = true;
  fVar2 = fVar3;
  fVar1 = fVar3;
  while( true ) {
    fVar1 = fVar1 * 0.50000000;
    if (bVar4) {
      fVar3 = fVar3 + fVar3;
    }
    if (iVar5 == 0x34) break;
    iVar5 = iVar5 + 1;
    if (fVar2 == fVar1 + 1.00000000) break;
    bVar4 = (bool)(bVar4 ^ 1);
    fVar2 = fVar1 + 1.00000000;
  }
  splitter = (double)(fVar3 + 1.00000000);
  resulterrbound = (double)((fVar1 * 8.00000000 + 3.00000000) * fVar1);
  ccwerrboundA = (double)((fVar1 * 16.00000000 + 3.00000000) * fVar1);
  ccwerrboundB = (double)((fVar1 * 12.00000000 + 2.00000000) * fVar1);
  ccwerrboundC = (double)((fVar1 * 64.00000000 + 9.00000000) * fVar1 * fVar1);
  o3derrboundA = (double)((fVar1 * 56.00000000 + 7.00000000) * fVar1);
  o3derrboundB = (double)((fVar1 * 28.00000000 + 3.00000000) * fVar1);
  o3derrboundC = (double)((fVar1 * 288.00000000 + 26.00000000) * fVar1 * fVar1);
  iccerrboundA = (double)((fVar1 * 96.00000000 + 10.00000000) * fVar1);
  iccerrboundB = (double)((fVar1 * 48.00000000 + 4.00000000) * fVar1);
  iccerrboundC = (double)((fVar1 * 576.00000000 + 44.00000000) * fVar1 * fVar1);
  isperrboundA = (double)((fVar1 * 224.00000000 + 16.00000000) * fVar1);
  isperrboundB = (double)((fVar1 * 72.00000000 + 5.00000000) * fVar1);
  isperrboundC = (double)((fVar1 * 1408.00000000 + 71.00000000) * fVar1 * fVar1);
  return;
}



// WARNING: Removing unreachable block (ram,0x08125a61)
// WARNING: Removing unreachable block (ram,0x08125ad0)

int __regparm3 fast_expansion_sum_zeroelim(int elen,double *e,int flen,double *f,double *h)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  bool bVar10;
  
  dVar1 = *e;
  dVar2 = *f;
  bVar10 = dVar2 <= -dVar1 == dVar1 < dVar2;
  if (bVar10) {
    dVar3 = f[1];
    dVar4 = dVar2;
  }
  else {
    dVar4 = dVar1;
    dVar3 = dVar2;
    dVar1 = e[1];
  }
  uVar8 = (uint)!bVar10;
  uVar9 = (uint)bVar10;
  if (((int)uVar9 < flen) && ((int)uVar8 < elen)) {
    if (dVar3 <= dVar1 == -dVar1 < dVar3) {
      uVar9 = uVar9 + 1;
      dVar2 = dVar3 + dVar4;
      dVar5 = dVar2 - dVar3;
      dVar3 = f[uVar9];
    }
    else {
      uVar8 = uVar8 + 1;
      dVar2 = dVar1 + dVar4;
      dVar5 = dVar2 - dVar1;
      dVar1 = e[uVar8];
    }
    dVar4 = dVar4 - dVar5;
    if (dVar4 != 0.00000000) {
      *h = dVar4;
    }
    uVar6 = (uint)(dVar4 != 0.00000000);
    dVar4 = dVar2;
    while (((int)uVar9 < flen && ((int)uVar8 < elen))) {
      if (dVar3 <= dVar1 == -dVar1 < dVar3) {
        uVar9 = uVar9 + 1;
        dVar2 = dVar4 + dVar3;
        dVar5 = (dVar4 - (dVar2 - (dVar2 - dVar4))) + (dVar3 - (dVar2 - dVar4));
        dVar3 = f[uVar9];
      }
      else {
        uVar8 = uVar8 + 1;
        dVar2 = dVar4 + dVar1;
        dVar5 = (dVar4 - (dVar2 - (dVar2 - dVar4))) + (dVar1 - (dVar2 - dVar4));
        dVar1 = e[uVar8];
      }
      dVar4 = dVar2;
      if (dVar5 != 0.00000000) {
        h[uVar6] = dVar5;
        uVar6 = uVar6 + 1;
      }
    }
  }
  else {
    uVar6 = 0;
  }
  if ((int)uVar8 < elen) {
    iVar7 = uVar8 + 1;
    e = e + iVar7;
    dVar2 = dVar4;
    while( true ) {
      dVar4 = dVar2 + dVar1;
      dVar2 = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar1 - (dVar4 - dVar2));
      dVar1 = *e;
      if (dVar2 != 0.00000000) {
        h[uVar6] = dVar2;
        uVar6 = uVar6 + 1;
      }
      e = e + 1;
      if (elen <= iVar7) break;
      iVar7 = iVar7 + 1;
      dVar2 = dVar4;
    }
  }
  if ((int)uVar9 < flen) {
    iVar7 = uVar9 + 1;
    f = f + iVar7;
    dVar2 = dVar4;
    while( true ) {
      dVar4 = dVar2 + dVar3;
      dVar2 = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar3 - (dVar4 - dVar2));
      dVar3 = *f;
      if (dVar2 != 0.00000000) {
        h[uVar6] = dVar2;
        uVar6 = uVar6 + 1;
      }
      f = f + 1;
      if (flen <= iVar7) break;
      iVar7 = iVar7 + 1;
      dVar2 = dVar4;
    }
  }
  if ((uVar6 != 0) && (dVar4 == 0.00000000)) {
    return uVar6;
  }
  h[uVar6] = dVar4;
  return uVar6 + 1;
}



// WARNING: Removing unreachable block (ram,0x08125c61)

int __regparm3 scale_expansion_zeroelim(int elen,double *e,double b,double *h)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  int iVar8;
  uint uVar9;
  
  dVar7 = splitter;
  dVar6 = b * splitter - (b * splitter - b);
  dVar4 = b - dVar6;
  dVar1 = *e;
  dVar3 = b * dVar1;
  dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
  dVar1 = (dVar1 - dVar2) * dVar4 -
          (((dVar3 - dVar2 * dVar6) - (dVar1 - dVar2) * dVar6) - dVar2 * dVar4);
  if (dVar1 != 0.00000000) {
    *h = dVar1;
  }
  uVar9 = (uint)(dVar1 != 0.00000000);
  if (1 < elen) {
    iVar8 = 1;
    do {
      dVar1 = e[iVar8];
      dVar5 = b * dVar1;
      dVar2 = dVar7 * dVar1 - (dVar7 * dVar1 - dVar1);
      dVar2 = (dVar1 - dVar2) * dVar4 -
              (((dVar5 - dVar2 * dVar6) - (dVar1 - dVar2) * dVar6) - dVar2 * dVar4);
      dVar1 = dVar3 + dVar2;
      dVar2 = (dVar3 - (dVar1 - (dVar1 - dVar3))) + (dVar2 - (dVar1 - dVar3));
      if (dVar2 != 0.00000000) {
        h[uVar9] = dVar2;
        uVar9 = uVar9 + 1;
      }
      dVar3 = dVar5 + dVar1;
      dVar1 = dVar1 - (dVar3 - dVar5);
      if (dVar1 != 0.00000000) {
        h[uVar9] = dVar1;
        uVar9 = uVar9 + 1;
      }
      iVar8 = iVar8 + 1;
    } while (iVar8 != elen);
  }
  if ((uVar9 != 0) && (dVar3 == 0.00000000)) {
    return uVar9;
  }
  h[uVar9] = dVar3;
  return uVar9 + 1;
}



// WARNING: Removing unreachable block (ram,0x08125fcc)
// WARNING: Removing unreachable block (ram,0x08125fc4)
// WARNING: Removing unreachable block (ram,0x08125fb2)

double __regparm3 orient2dadapt(double *pa,double *pb,double *pc,double detsum)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  int elen;
  double local_17c;
  double D [16];
  double C2 [12];
  double C1 [8];
  double u [4];
  double B [4];
  
  dVar11 = splitter;
  dVar1 = *pc;
  dVar2 = *pa;
  dVar8 = dVar2 - dVar1;
  dVar3 = *pb;
  dVar9 = dVar3 - dVar1;
  dVar4 = pc[1];
  dVar5 = pa[1];
  dVar21 = dVar5 - dVar4;
  dVar6 = pb[1];
  dVar23 = dVar6 - dVar4;
  dVar7 = dVar8 * dVar23;
  dVar24 = splitter * dVar8 - (splitter * dVar8 - dVar8);
  dVar10 = dVar8 - dVar24;
  dVar16 = splitter * dVar23 - (splitter * dVar23 - dVar23);
  dVar15 = dVar23 - dVar16;
  dVar14 = dVar10 * dVar15 - (((dVar7 - dVar24 * dVar16) - dVar10 * dVar16) - dVar24 * dVar15);
  dVar22 = dVar9 * dVar21;
  dVar19 = splitter * dVar21 - (splitter * dVar21 - dVar21);
  dVar20 = dVar21 - dVar19;
  dVar17 = dVar9 * splitter - (dVar9 * splitter - dVar9);
  dVar18 = dVar9 - dVar17;
  dVar13 = dVar20 * dVar18 - (((dVar22 - dVar19 * dVar17) - dVar20 * dVar17) - dVar19 * dVar18);
  dVar12 = dVar14 - dVar13;
  B[0] = ((dVar14 - dVar12) - dVar13) + (dVar14 - ((dVar14 - dVar12) + dVar12));
  dVar13 = dVar7 + dVar12;
  dVar12 = (dVar7 - (dVar13 - (dVar13 - dVar7))) + (dVar12 - (dVar13 - dVar7));
  dVar7 = dVar12 - dVar22;
  B[1] = ((dVar12 - dVar7) - dVar22) + (dVar12 - (dVar7 + (dVar12 - dVar7)));
  B[3] = dVar13 + dVar7;
  B[2] = (dVar7 - (B[3] - dVar13)) + (dVar13 - (B[3] - (B[3] - dVar13)));
  dVar7 = B[1] + B[0] + B[2] + B[3];
  if ((dVar7 < detsum * ccwerrboundB) && (-dVar7 < detsum * ccwerrboundB)) {
    dVar2 = ((dVar2 - dVar8) - dVar1) + (dVar2 - (dVar8 + (dVar2 - dVar8)));
    local_17c = ((dVar3 - dVar9) - dVar1) + (dVar3 - (dVar9 + (dVar3 - dVar9)));
    dVar1 = ((dVar5 - dVar21) - dVar4) + (dVar5 - (dVar21 + (dVar5 - dVar21)));
    dVar3 = ((dVar6 - dVar23) - dVar4) + (dVar6 - (dVar23 + (dVar6 - dVar23)));
    if ((dVar2 != 0.00000000) ||
       (((dVar1 != 0.00000000 || (local_17c != 0.00000000)) || (dVar3 != 0.00000000)))) {
      dVar4 = dVar7;
      if (dVar7 < 0.00000000) {
        dVar4 = -dVar7;
      }
      dVar4 = dVar4 * resulterrbound + detsum * ccwerrboundC;
      dVar8 = dVar8 * dVar3;
      dVar23 = dVar23 * dVar2;
      dVar21 = dVar21 * local_17c;
      dVar9 = dVar9 * dVar1;
      dVar7 = ((dVar8 + dVar23) - (dVar21 + dVar9)) + dVar7;
      if ((dVar7 < dVar4) && (-dVar7 < dVar4)) {
        dVar22 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        dVar14 = dVar2 - dVar22;
        dVar6 = dVar15 * dVar14 - (((dVar23 - dVar16 * dVar22) - dVar16 * dVar14) - dVar15 * dVar22)
        ;
        dVar13 = splitter * dVar1 - (splitter * dVar1 - dVar1);
        dVar12 = dVar1 - dVar13;
        dVar5 = dVar18 * dVar12 - (((dVar9 - dVar17 * dVar13) - dVar17 * dVar12) - dVar18 * dVar13);
        dVar4 = dVar6 - dVar5;
        u[0] = (dVar6 - (dVar4 + (dVar6 - dVar4))) + ((dVar6 - dVar4) - dVar5);
        dVar6 = dVar23 + dVar4;
        dVar5 = (dVar23 - (dVar6 - (dVar6 - dVar23))) + (dVar4 - (dVar6 - dVar23));
        dVar4 = dVar5 - dVar9;
        u[1] = (dVar5 - (dVar4 + (dVar5 - dVar4))) + ((dVar5 - dVar4) - dVar9);
        u[3] = dVar6 + dVar4;
        u[2] = (dVar6 - (u[3] - (u[3] - dVar6))) + (dVar4 - (u[3] - dVar6));
        elen = fast_expansion_sum_zeroelim(4,B,4,u,C1);
        dVar4 = dVar11 * dVar3;
        dVar4 = dVar4 - (dVar4 - dVar3);
        dVar5 = dVar3 - dVar4;
        dVar6 = dVar10 * dVar5 - (((dVar8 - dVar24 * dVar4) - dVar10 * dVar4) - dVar24 * dVar5);
        dVar11 = dVar11 * local_17c;
        dVar11 = dVar11 - (dVar11 - local_17c);
        dVar10 = local_17c - dVar11;
        dVar9 = dVar20 * dVar10 - (((dVar21 - dVar19 * dVar11) - dVar20 * dVar11) - dVar19 * dVar10)
        ;
        dVar7 = dVar6 - dVar9;
        u[0] = (dVar6 - (dVar7 + (dVar6 - dVar7))) + ((dVar6 - dVar7) - dVar9);
        dVar6 = dVar8 + dVar7;
        dVar7 = (dVar8 - (dVar6 - (dVar6 - dVar8))) + (dVar7 - (dVar6 - dVar8));
        dVar8 = dVar7 - dVar21;
        u[1] = ((dVar7 - dVar8) - dVar21) + (dVar7 - (dVar8 + (dVar7 - dVar8)));
        u[3] = dVar6 + dVar8;
        u[2] = (dVar6 - (u[3] - (u[3] - dVar6))) + (dVar8 - (u[3] - dVar6));
        elen = fast_expansion_sum_zeroelim(elen,C1,4,u,C2);
        dVar2 = dVar2 * dVar3;
        dVar4 = dVar14 * dVar5 - (((dVar2 - dVar22 * dVar4) - dVar4 * dVar14) - dVar22 * dVar5);
        dVar1 = dVar1 * local_17c;
        dVar3 = dVar12 * dVar10 - (((dVar1 - dVar13 * dVar11) - dVar11 * dVar12) - dVar13 * dVar10);
        dVar5 = dVar4 - dVar3;
        u[0] = (dVar4 - (dVar5 + (dVar4 - dVar5))) + ((dVar4 - dVar5) - dVar3);
        dVar4 = dVar2 + dVar5;
        dVar2 = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar5 - (dVar4 - dVar2));
        dVar3 = dVar2 - dVar1;
        u[1] = (dVar2 - (dVar3 + (dVar2 - dVar3))) + ((dVar2 - dVar3) - dVar1);
        u[3] = dVar4 + dVar3;
        u[2] = (dVar4 - (u[3] - (u[3] - dVar4))) + (dVar3 - (u[3] - dVar4));
        elen = fast_expansion_sum_zeroelim(elen,C2,4,u,D);
        dVar7 = (&local_17c)[elen];
      }
    }
  }
  return dVar7;
}



double orient2d(double *pa,double *pb,double *pc)

{
  double dVar1;
  double dVar2;
  double detsum;
  
  dVar2 = (pb[1] - pc[1]) * (*pa - *pc);
  detsum = (*pb - *pc) * (pa[1] - pc[1]);
  dVar1 = dVar2 - detsum;
  if (dVar2 <= 0.00000000) {
    if (0.00000000 <= dVar2) {
      return dVar1;
    }
    if (0.00000000 <= detsum) {
      return dVar1;
    }
    detsum = -dVar2 - detsum;
  }
  else {
    if (detsum <= 0.00000000) {
      return dVar1;
    }
    detsum = dVar2 + detsum;
  }
  if ((dVar1 < ccwerrboundA * detsum) && (-dVar1 < ccwerrboundA * detsum)) {
    detsum = orient2dadapt(pa,pb,pc,detsum);
    return detsum;
  }
  return dVar1;
}



// WARNING: Removing unreachable block (ram,0x08127a8d)
// WARNING: Removing unreachable block (ram,0x08127647)
// WARNING: Removing unreachable block (ram,0x08127ae7)
// WARNING: Removing unreachable block (ram,0x08126c12)
// WARNING: Removing unreachable block (ram,0x08126c6a)
// WARNING: Removing unreachable block (ram,0x08126c56)
// WARNING: Removing unreachable block (ram,0x08126c3c)
// WARNING: Removing unreachable block (ram,0x08126c24)
// WARNING: Removing unreachable block (ram,0x08126c2c)
// WARNING: Removing unreachable block (ram,0x08126c4c)
// WARNING: Removing unreachable block (ram,0x08126c62)
// WARNING: Removing unreachable block (ram,0x08127bcd)
// WARNING: Removing unreachable block (ram,0x08127741)
// WARNING: Removing unreachable block (ram,0x08128885)

double __regparm3 orient3dadapt(double *pa,double *pb,double *pc,double *pd,double permanent)

{
  double dVar1;
  double dVar2;
  double b;
  double b_00;
  double dVar3;
  double dVar4;
  double b_01;
  double b_02;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double b_03;
  double dVar9;
  double b_04;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  double dVar27;
  double dVar28;
  double dVar29;
  double dVar30;
  double dVar31;
  int elen;
  int flen;
  int flen_00;
  int flen_01;
  int flen_02;
  double *e;
  double *e_00;
  double *e_01;
  int local_108c;
  int local_107c;
  int local_1064;
  double *local_103c;
  double fin2 [192];
  double fin1 [192];
  double w [16];
  double abdet [16];
  double v [12];
  double abt [8];
  double cat [8];
  double bct [8];
  double cdet [8];
  double bdet [8];
  double adet [8];
  double u [4];
  double ct_b [4];
  double ct_a [4];
  double bt_a [4];
  double bt_c [4];
  double at_c [4];
  double at_b [4];
  double ab [4];
  double ca [4];
  double bc [4];
  
  dVar1 = *pd;
  dVar3 = *pa - dVar1;
  dVar4 = *pb - dVar1;
  dVar1 = *pc - dVar1;
  dVar2 = pd[1];
  dVar18 = pa[1] - dVar2;
  dVar19 = pb[1] - dVar2;
  dVar2 = pc[1] - dVar2;
  b = pd[2];
  b_01 = pa[2] - b;
  b_02 = pb[2] - b;
  b = pc[2] - b;
  dVar20 = dVar4 * dVar2;
  dVar6 = dVar4 * splitter - (dVar4 * splitter - dVar4);
  dVar5 = dVar2 * splitter - (dVar2 * splitter - dVar2);
  dVar6 = (dVar4 - dVar6) * (dVar2 - dVar5) -
          (((dVar20 - dVar6 * dVar5) - dVar5 * (dVar4 - dVar6)) - (dVar2 - dVar5) * dVar6);
  dVar5 = dVar1 * dVar19;
  dVar7 = dVar1 * splitter - (dVar1 * splitter - dVar1);
  dVar8 = splitter * dVar19 - (splitter * dVar19 - dVar19);
  dVar8 = (dVar1 - dVar7) * (dVar19 - dVar8) -
          (((dVar5 - dVar7 * dVar8) - dVar8 * (dVar1 - dVar7)) - (dVar19 - dVar8) * dVar7);
  dVar7 = dVar6 - dVar8;
  bc[0] = (dVar6 - (dVar7 + (dVar6 - dVar7))) + ((dVar6 - dVar7) - dVar8);
  dVar6 = dVar20 + dVar7;
  dVar7 = (dVar7 - (dVar6 - dVar20)) + (dVar20 - (dVar6 - (dVar6 - dVar20)));
  dVar8 = dVar7 - dVar5;
  bc[1] = ((dVar7 - dVar8) - dVar5) + (dVar7 - (dVar8 + (dVar7 - dVar8)));
  bc[3] = dVar6 + dVar8;
  bc[2] = (dVar6 - (bc[3] - (bc[3] - dVar6))) + (dVar8 - (bc[3] - dVar6));
  elen = scale_expansion_zeroelim(4,bc,b_01,adet);
  dVar6 = dVar1 * dVar18;
  dVar7 = dVar1 * splitter - (dVar1 * splitter - dVar1);
  dVar8 = dVar18 * splitter - (dVar18 * splitter - dVar18);
  b_00 = (dVar1 - dVar7) * (dVar18 - dVar8) -
         (((dVar6 - dVar7 * dVar8) - dVar8 * (dVar1 - dVar7)) - (dVar18 - dVar8) * dVar7);
  dVar21 = dVar3 * dVar2;
  dVar8 = dVar3 * splitter - (dVar3 * splitter - dVar3);
  dVar7 = splitter * dVar2 - (splitter * dVar2 - dVar2);
  dVar7 = (dVar3 - dVar8) * (dVar2 - dVar7) -
          (((dVar21 - dVar8 * dVar7) - dVar7 * (dVar3 - dVar8)) - dVar8 * (dVar2 - dVar7));
  dVar8 = b_00 - dVar7;
  ca[0] = (b_00 - (dVar8 + (b_00 - dVar8))) + ((b_00 - dVar8) - dVar7);
  dVar7 = dVar6 + dVar8;
  dVar8 = (dVar8 - (dVar7 - dVar6)) + (dVar6 - (dVar7 - (dVar7 - dVar6)));
  b_00 = dVar8 - dVar21;
  ca[1] = ((dVar8 - b_00) - dVar21) + (dVar8 - (b_00 + (dVar8 - b_00)));
  ca[3] = dVar7 + b_00;
  ca[2] = (dVar7 - (ca[3] - (ca[3] - dVar7))) + (b_00 - (ca[3] - dVar7));
  flen = scale_expansion_zeroelim(4,ca,b_02,bdet);
  dVar7 = dVar3 * dVar19;
  dVar8 = dVar3 * splitter - (dVar3 * splitter - dVar3);
  b_00 = dVar19 * splitter - (dVar19 * splitter - dVar19);
  dVar9 = (dVar3 - dVar8) * (dVar19 - b_00) -
          (((dVar7 - dVar8 * b_00) - b_00 * (dVar3 - dVar8)) - (dVar19 - b_00) * dVar8);
  dVar8 = dVar4 * dVar18;
  b_03 = dVar4 * splitter - (dVar4 * splitter - dVar4);
  b_00 = splitter * dVar18 - (splitter * dVar18 - dVar18);
  b_00 = (dVar4 - b_03) * (dVar18 - b_00) -
         (((dVar8 - b_03 * b_00) - b_00 * (dVar4 - b_03)) - (dVar18 - b_00) * b_03);
  b_03 = dVar9 - b_00;
  ab[0] = (dVar9 - (b_03 + (dVar9 - b_03))) + ((dVar9 - b_03) - b_00);
  b_00 = dVar7 + b_03;
  b_03 = (b_03 - (b_00 - dVar7)) + (dVar7 - (b_00 - (b_00 - dVar7)));
  dVar9 = b_03 - dVar8;
  ab[1] = ((b_03 - dVar9) - dVar8) + (b_03 - (dVar9 + (b_03 - dVar9)));
  ab[3] = b_00 + dVar9;
  ab[2] = (b_00 - (ab[3] - (ab[3] - b_00))) + (dVar9 - (ab[3] - b_00));
  flen_00 = scale_expansion_zeroelim(4,ab,b,cdet);
  elen = fast_expansion_sum_zeroelim(elen,adet,flen,bdet,abdet);
  elen = fast_expansion_sum_zeroelim(elen,abdet,flen_00,cdet,fin1);
  if (1 < elen) {
    flen = 1;
    do {
      fin1[0] = fin1[0] + fin1[flen];
      flen = flen + 1;
    } while (flen != elen);
  }
  if (permanent * o3derrboundB <= fin1[0]) {
    return fin1[0];
  }
  if (permanent * o3derrboundB <= -fin1[0]) {
    return fin1[0];
  }
  b_03 = *pa - dVar3;
  b_00 = *pd;
  dVar23 = (*pa - (dVar3 + b_03)) + (b_03 - b_00);
  b_03 = *pb - dVar4;
  dVar31 = (b_03 - b_00) + (*pb - (dVar4 + b_03));
  b_03 = *pc - dVar1;
  dVar30 = (*pc - (dVar1 + b_03)) + (b_03 - b_00);
  b_03 = pa[1] - dVar18;
  b_00 = pd[1];
  dVar29 = (b_03 - b_00) + (pa[1] - (dVar18 + b_03));
  b_03 = pb[1] - dVar19;
  dVar28 = (b_03 - b_00) + (pb[1] - (dVar19 + b_03));
  b_03 = pc[1] - dVar2;
  dVar27 = (pc[1] - (dVar2 + b_03)) + (b_03 - b_00);
  b_03 = pa[2] - b_01;
  b_00 = pd[2];
  b_03 = (b_03 - b_00) + (pa[2] - (b_01 + b_03));
  dVar9 = pb[2] - b_02;
  b_04 = (dVar9 - b_00) + (pb[2] - (b_02 + dVar9));
  dVar9 = pc[2] - b;
  b_00 = (pc[2] - (b + dVar9)) + (dVar9 - b_00);
  if ((((((dVar23 == 0.00000000) && (dVar31 == 0.00000000)) && (dVar30 == 0.00000000)) &&
       ((dVar29 == 0.00000000 && (dVar28 == 0.00000000)))) &&
      ((dVar27 == 0.00000000 && ((b_03 == 0.00000000 && (b_04 == 0.00000000)))))) &&
     (b_00 == 0.00000000)) {
    return fin1[0];
  }
  dVar9 = -fin1[0];
  if (0.00000000 <= fin1[0]) {
    dVar9 = fin1[0];
  }
  dVar22 = dVar9 * resulterrbound + permanent * o3derrboundC;
  dVar9 = dVar4 * dVar27;
  dVar26 = dVar31 * dVar2;
  dVar10 = dVar19 * dVar30;
  dVar11 = dVar1 * dVar28;
  dVar12 = dVar1 * dVar29;
  dVar13 = dVar18 * dVar30;
  dVar25 = dVar2 * dVar23;
  dVar14 = dVar3 * dVar27;
  dVar15 = dVar3 * dVar28;
  dVar24 = dVar19 * dVar23;
  dVar16 = dVar18 * dVar31;
  dVar17 = dVar4 * dVar29;
  fin1[0] = (dVar7 - dVar8) * b_00 + ((dVar15 + dVar24) - (dVar16 + dVar17)) * b +
            (dVar6 - dVar21) * b_04 + ((dVar12 + dVar13) - (dVar25 + dVar14)) * b_02 +
            (dVar20 - dVar5) * b_03 + ((dVar9 + dVar26) - (dVar10 + dVar11)) * b_01 + fin1[0];
  if (dVar22 <= fin1[0]) {
    return fin1[0];
  }
  if (dVar22 <= -fin1[0]) {
    return fin1[0];
  }
  if (dVar23 == 0.00000000) {
    if (dVar29 == 0.00000000) {
      at_b[0] = 0.00000000;
      local_107c = 1;
      at_c[0] = 0.00000000;
      local_108c = 1;
    }
    else {
      dVar5 = -dVar29;
      local_107c = 2;
      local_108c = 2;
      dVar6 = splitter * dVar5 - (splitter * dVar5 - dVar5);
      dVar7 = dVar4 * splitter - (dVar4 * splitter - dVar4);
      at_b[0] = (dVar5 - dVar6) * (dVar4 - dVar7) -
                (((dVar4 * dVar5 - dVar6 * dVar7) - dVar7 * (dVar5 - dVar6)) -
                (dVar4 - dVar7) * dVar6);
      dVar7 = dVar29 * splitter - (dVar29 * splitter - dVar29);
      dVar6 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      at_c[0] = (dVar29 - dVar7) * (dVar1 - dVar6) -
                (((dVar12 - dVar7 * dVar6) - dVar6 * (dVar29 - dVar7)) - (dVar1 - dVar6) * dVar7);
      at_c[1] = dVar12;
      at_b[1] = dVar4 * dVar5;
    }
  }
  else {
    if (dVar29 == 0.00000000) {
      local_108c = 2;
      dVar6 = splitter * dVar23 - (splitter * dVar23 - dVar23);
      dVar5 = dVar19 * splitter - (dVar19 * splitter - dVar19);
      local_107c = 2;
      at_b[0] = (dVar23 - dVar6) * (dVar19 - dVar5) -
                (((dVar24 - dVar6 * dVar5) - (dVar23 - dVar6) * dVar5) - (dVar19 - dVar5) * dVar6);
      dVar5 = -dVar23;
      at_c[1] = dVar5 * dVar2;
      dVar6 = splitter * dVar5 - (splitter * dVar5 - dVar5);
      dVar7 = dVar2 * splitter - (dVar2 * splitter - dVar2);
      at_c[0] = (dVar5 - dVar6) * (dVar2 - dVar7) -
                (((at_c[1] - dVar6 * dVar7) - dVar7 * (dVar5 - dVar6)) - (dVar2 - dVar7) * dVar6);
      at_b[1] = dVar24;
    }
    else {
      dVar22 = splitter * dVar23 - (splitter * dVar23 - dVar23);
      dVar5 = dVar23 - dVar22;
      dVar6 = dVar19 * splitter - (dVar19 * splitter - dVar19);
      dVar6 = dVar5 * (dVar19 - dVar6) -
              (((dVar24 - dVar22 * dVar6) - dVar5 * dVar6) - dVar22 * (dVar19 - dVar6));
      dVar20 = dVar29 * splitter - (dVar29 * splitter - dVar29);
      dVar21 = dVar29 - dVar20;
      dVar7 = dVar4 * splitter - (dVar4 * splitter - dVar4);
      dVar8 = dVar21 * (dVar4 - dVar7) -
              (((dVar17 - dVar20 * dVar7) - dVar21 * dVar7) - dVar20 * (dVar4 - dVar7));
      dVar7 = dVar6 - dVar8;
      at_b[0] = (dVar6 - (dVar7 + (dVar6 - dVar7))) + ((dVar6 - dVar7) - dVar8);
      dVar6 = dVar24 + dVar7;
      dVar7 = (dVar7 - (dVar6 - dVar24)) + (dVar24 - (dVar6 - (dVar6 - dVar24)));
      dVar8 = dVar7 - dVar17;
      at_b[1] = ((dVar7 - dVar8) - dVar17) + (dVar7 - (dVar8 + (dVar7 - dVar8)));
      at_b[3] = dVar6 + dVar8;
      at_b[2] = (dVar6 - (at_b[3] - (at_b[3] - dVar6))) + (dVar8 - (at_b[3] - dVar6));
      dVar6 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      local_107c = 4;
      dVar7 = dVar21 * (dVar1 - dVar6) -
              (((dVar12 - dVar20 * dVar6) - dVar6 * dVar21) - dVar20 * (dVar1 - dVar6));
      dVar6 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      local_108c = 4;
      dVar5 = dVar5 * (dVar2 - dVar6) -
              (((dVar25 - dVar22 * dVar6) - dVar6 * dVar5) - dVar22 * (dVar2 - dVar6));
      dVar6 = dVar7 - dVar5;
      at_c[0] = (dVar7 - (dVar6 + (dVar7 - dVar6))) + ((dVar7 - dVar6) - dVar5);
      dVar5 = dVar12 + dVar6;
      dVar6 = (dVar12 - (dVar5 - (dVar5 - dVar12))) + (dVar6 - (dVar5 - dVar12));
      dVar7 = dVar6 - dVar25;
      at_c[1] = ((dVar6 - dVar7) - dVar25) + (dVar6 - (dVar7 + (dVar6 - dVar7)));
      at_c[3] = dVar5 + dVar7;
      at_c[2] = (dVar5 - (at_c[3] - (at_c[3] - dVar5))) + (dVar7 - (at_c[3] - dVar5));
    }
  }
  if (dVar31 == 0.00000000) {
    if (dVar28 == 0.00000000) {
      bt_c[0] = 0.00000000;
      flen = 1;
      local_1064 = 1;
      bt_a[0] = 0.00000000;
    }
    else {
      flen = 2;
      dVar2 = -dVar28;
      local_1064 = 2;
      dVar5 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      dVar6 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      bt_c[0] = (dVar2 - dVar5) * (dVar1 - dVar6) -
                (((dVar1 * dVar2 - dVar5 * dVar6) - dVar6 * (dVar2 - dVar5)) -
                (dVar1 - dVar6) * dVar5);
      dVar6 = dVar28 * splitter - (dVar28 * splitter - dVar28);
      dVar5 = dVar3 * splitter - (dVar3 * splitter - dVar3);
      bt_a[0] = (dVar28 - dVar6) * (dVar3 - dVar5) -
                (((dVar15 - dVar6 * dVar5) - dVar5 * (dVar28 - dVar6)) - (dVar3 - dVar5) * dVar6);
      bt_a[1] = dVar15;
      bt_c[1] = dVar1 * dVar2;
    }
  }
  else {
    if (dVar28 == 0.00000000) {
      flen = 2;
      local_1064 = 2;
      dVar1 = dVar31 * splitter - (dVar31 * splitter - dVar31);
      dVar5 = dVar2 * splitter - (dVar2 * splitter - dVar2);
      bt_c[0] = (dVar31 - dVar1) * (dVar2 - dVar5) -
                (((dVar26 - dVar1 * dVar5) - dVar5 * (dVar31 - dVar1)) - (dVar2 - dVar5) * dVar1);
      dVar2 = -dVar31;
      bt_a[1] = dVar18 * dVar2;
      dVar5 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      dVar1 = dVar18 * splitter - (dVar18 * splitter - dVar18);
      bt_a[0] = (dVar2 - dVar5) * (dVar18 - dVar1) -
                (((bt_a[1] - dVar5 * dVar1) - dVar1 * (dVar2 - dVar5)) - (dVar18 - dVar1) * dVar5);
      bt_c[1] = dVar26;
    }
    else {
      flen = 4;
      dVar8 = dVar31 * splitter - (dVar31 * splitter - dVar31);
      dVar20 = dVar31 - dVar8;
      dVar5 = dVar2 * splitter - (dVar2 * splitter - dVar2);
      dVar2 = dVar20 * (dVar2 - dVar5) -
              (((dVar26 - dVar8 * dVar5) - dVar5 * dVar20) - (dVar2 - dVar5) * dVar8);
      dVar6 = dVar28 * splitter - (dVar28 * splitter - dVar28);
      dVar7 = dVar28 - dVar6;
      dVar5 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      dVar5 = dVar7 * (dVar1 - dVar5) -
              (((dVar11 - dVar6 * dVar5) - dVar5 * dVar7) - (dVar1 - dVar5) * dVar6);
      dVar1 = dVar2 - dVar5;
      bt_c[0] = (dVar2 - (dVar1 + (dVar2 - dVar1))) + ((dVar2 - dVar1) - dVar5);
      dVar2 = dVar26 + dVar1;
      dVar1 = (dVar1 - (dVar2 - dVar26)) + (dVar26 - (dVar2 - (dVar2 - dVar26)));
      dVar5 = dVar1 - dVar11;
      bt_c[1] = ((dVar1 - dVar5) - dVar11) + (dVar1 - (dVar5 + (dVar1 - dVar5)));
      bt_c[3] = dVar2 + dVar5;
      bt_c[2] = (dVar2 - (bt_c[3] - (bt_c[3] - dVar2))) + (dVar5 - (bt_c[3] - dVar2));
      dVar1 = dVar3 * splitter - (dVar3 * splitter - dVar3);
      dVar1 = dVar7 * (dVar3 - dVar1) -
              (((dVar15 - dVar6 * dVar1) - dVar1 * dVar7) - (dVar3 - dVar1) * dVar6);
      dVar2 = dVar18 * splitter - (dVar18 * splitter - dVar18);
      dVar5 = dVar20 * (dVar18 - dVar2) -
              (((dVar16 - dVar8 * dVar2) - dVar2 * dVar20) - dVar8 * (dVar18 - dVar2));
      dVar2 = dVar1 - dVar5;
      bt_a[0] = (dVar1 - (dVar2 + (dVar1 - dVar2))) + ((dVar1 - dVar2) - dVar5);
      dVar1 = dVar15 + dVar2;
      local_1064 = 4;
      dVar2 = (dVar2 - (dVar1 - dVar15)) + (dVar15 - (dVar1 - (dVar1 - dVar15)));
      dVar5 = dVar2 - dVar16;
      bt_a[1] = ((dVar2 - dVar5) - dVar16) + (dVar2 - (dVar5 + (dVar2 - dVar5)));
      bt_a[3] = dVar1 + dVar5;
      bt_a[2] = (dVar1 - (bt_a[3] - (bt_a[3] - dVar1))) + (dVar5 - (bt_a[3] - dVar1));
    }
  }
  if (dVar30 == 0.00000000) {
    if (dVar27 == 0.00000000) {
      ct_a[0] = 0.00000000;
      flen_00 = 1;
      local_103c = (double *)0x1;
      ct_b[0] = 0.00000000;
    }
    else {
      flen_00 = 2;
      dVar1 = -dVar27;
      local_103c = (double *)0x2;
      dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
      dVar5 = dVar3 * splitter - (dVar3 * splitter - dVar3);
      ct_a[0] = (dVar1 - dVar2) * (dVar3 - dVar5) -
                (((dVar3 * dVar1 - dVar2 * dVar5) - dVar5 * (dVar1 - dVar2)) -
                (dVar3 - dVar5) * dVar2);
      dVar5 = dVar27 * splitter - (dVar27 * splitter - dVar27);
      dVar2 = splitter * dVar4 - (splitter * dVar4 - dVar4);
      ct_b[0] = (dVar27 - dVar5) * (dVar4 - dVar2) -
                (((dVar9 - dVar5 * dVar2) - dVar2 * (dVar27 - dVar5)) - (dVar4 - dVar2) * dVar5);
      ct_b[1] = dVar9;
      ct_a[1] = dVar3 * dVar1;
    }
  }
  else {
    if (dVar27 == 0.00000000) {
      flen_00 = 2;
      dVar2 = dVar30 * splitter - (dVar30 * splitter - dVar30);
      dVar1 = dVar18 * splitter - (dVar18 * splitter - dVar18);
      ct_a[0] = (dVar30 - dVar2) * (dVar18 - dVar1) -
                (((dVar13 - dVar2 * dVar1) - dVar1 * (dVar30 - dVar2)) - (dVar18 - dVar1) * dVar2);
      dVar2 = -dVar30;
      ct_b[1] = dVar19 * dVar2;
      dVar3 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      dVar1 = splitter * dVar19 - (splitter * dVar19 - dVar19);
      local_103c = (double *)0x2;
      ct_b[0] = (dVar2 - dVar3) * (dVar19 - dVar1) -
                (((ct_b[1] - dVar3 * dVar1) - dVar1 * (dVar2 - dVar3)) - (dVar19 - dVar1) * dVar3);
      ct_a[1] = dVar13;
    }
    else {
      flen_00 = 4;
      dVar8 = dVar30 * splitter - (dVar30 * splitter - dVar30);
      dVar7 = dVar30 - dVar8;
      dVar1 = dVar18 * splitter - (dVar18 * splitter - dVar18);
      dVar6 = dVar7 * (dVar18 - dVar1) -
              (((dVar13 - dVar8 * dVar1) - dVar1 * dVar7) - (dVar18 - dVar1) * dVar8);
      dVar1 = dVar27 * splitter - (dVar27 * splitter - dVar27);
      dVar2 = dVar27 - dVar1;
      dVar5 = dVar3 * splitter - (dVar3 * splitter - dVar3);
      dVar3 = dVar2 * (dVar3 - dVar5) -
              (((dVar14 - dVar1 * dVar5) - dVar5 * dVar2) - (dVar3 - dVar5) * dVar1);
      dVar5 = dVar6 - dVar3;
      ct_a[0] = (dVar6 - (dVar5 + (dVar6 - dVar5))) + ((dVar6 - dVar5) - dVar3);
      dVar3 = dVar13 + dVar5;
      dVar5 = (dVar5 - (dVar3 - dVar13)) + (dVar13 - (dVar3 - (dVar3 - dVar13)));
      dVar6 = dVar5 - dVar14;
      ct_a[1] = ((dVar5 - dVar6) - dVar14) + (dVar5 - (dVar6 + (dVar5 - dVar6)));
      ct_a[3] = dVar3 + dVar6;
      ct_a[2] = (dVar3 - (ct_a[3] - (ct_a[3] - dVar3))) + (dVar6 - (ct_a[3] - dVar3));
      dVar3 = dVar4 * splitter - (dVar4 * splitter - dVar4);
      dVar3 = dVar2 * (dVar4 - dVar3) -
              (((dVar9 - dVar1 * dVar3) - dVar3 * dVar2) - (dVar4 - dVar3) * dVar1);
      dVar1 = dVar19 * splitter - (dVar19 * splitter - dVar19);
      dVar1 = dVar7 * (dVar19 - dVar1) -
              (((dVar10 - dVar8 * dVar1) - dVar1 * dVar7) - (dVar19 - dVar1) * dVar8);
      dVar2 = dVar3 - dVar1;
      ct_b[0] = (dVar3 - (dVar2 + (dVar3 - dVar2))) + ((dVar3 - dVar2) - dVar1);
      dVar1 = dVar9 + dVar2;
      local_103c = (double *)0x4;
      dVar2 = (dVar2 - (dVar1 - dVar9)) + (dVar9 - (dVar1 - (dVar1 - dVar9)));
      dVar3 = dVar2 - dVar10;
      ct_b[1] = ((dVar2 - dVar3) - dVar10) + (dVar2 - (dVar3 + (dVar2 - dVar3)));
      ct_b[3] = dVar1 + dVar3;
      ct_b[2] = (dVar1 - (ct_b[3] - (ct_b[3] - dVar1))) + (dVar3 - (ct_b[3] - dVar1));
    }
  }
  flen = fast_expansion_sum_zeroelim(flen,bt_c,flen_00,ct_b,bct);
  flen_00 = scale_expansion_zeroelim(flen,bct,b_01,w);
  elen = fast_expansion_sum_zeroelim(elen,fin1,flen_00,w,fin2);
  flen_00 = fast_expansion_sum_zeroelim((int)local_103c,ct_a,local_107c,at_c,cat);
  flen_01 = scale_expansion_zeroelim(flen_00,cat,b_02,w);
  elen = fast_expansion_sum_zeroelim(elen,fin2,flen_01,w,fin1);
  flen_01 = fast_expansion_sum_zeroelim(local_108c,at_b,local_1064,bt_a,abt);
  flen_02 = scale_expansion_zeroelim(flen_01,abt,b,w);
  e_00 = fin2;
  elen = fast_expansion_sum_zeroelim(elen,fin1,flen_02,w,fin2);
  local_103c = fin1;
  if (b_03 != 0.00000000) {
    flen_02 = scale_expansion_zeroelim(4,bc,b_03,v);
    elen = fast_expansion_sum_zeroelim(elen,fin2,flen_02,v,fin1);
    e_00 = fin1;
    local_103c = fin2;
  }
  e_01 = e_00;
  if (b_04 != 0.00000000) {
    flen_02 = scale_expansion_zeroelim(4,ca,b_04,v);
    elen = fast_expansion_sum_zeroelim(elen,e_00,flen_02,v,local_103c);
    e_01 = local_103c;
    local_103c = e_00;
  }
  e_00 = e_01;
  if (b_00 != 0.00000000) {
    flen_02 = scale_expansion_zeroelim(4,ab,b_00,v);
    elen = fast_expansion_sum_zeroelim(elen,e_01,flen_02,v,local_103c);
    e_00 = local_103c;
    local_103c = e_01;
  }
  e_01 = local_103c;
  if (dVar23 != 0.00000000) {
    e = e_00;
    if (dVar28 != 0.00000000) {
      dVar1 = dVar28 * dVar23;
      dVar2 = splitter * dVar23 - (splitter * dVar23 - dVar23);
      dVar3 = dVar28 * splitter - (dVar28 * splitter - dVar28);
      dVar2 = (dVar23 - dVar2) * (dVar28 - dVar3) -
              (((dVar1 - dVar2 * dVar3) - dVar3 * (dVar23 - dVar2)) - (dVar28 - dVar3) * dVar2);
      dVar5 = b * splitter - (b * splitter - b);
      dVar7 = b - dVar5;
      dVar3 = b * dVar2;
      dVar4 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      u[0] = (dVar2 - dVar4) * dVar7 -
             (((dVar3 - dVar4 * dVar5) - (dVar2 - dVar4) * dVar5) - dVar4 * dVar7);
      dVar6 = dVar1 * b;
      dVar4 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      dVar4 = (dVar1 - dVar4) * dVar7 -
              (((dVar6 - dVar4 * dVar5) - dVar5 * (dVar1 - dVar4)) - dVar4 * dVar7);
      u[2] = dVar3 + dVar4;
      u[1] = (dVar3 - (u[2] - (u[2] - dVar3))) + (dVar4 - (u[2] - dVar3));
      u[3] = dVar6 + u[2];
      u[2] = u[2] - (u[3] - dVar6);
      elen = fast_expansion_sum_zeroelim(elen,e_00,4,u,local_103c);
      e = local_103c;
      e_01 = e_00;
      if (b_00 != 0.00000000) {
        dVar5 = splitter * b_00 - (splitter * b_00 - b_00);
        dVar6 = b_00 - dVar5;
        dVar3 = b_00 * dVar2;
        dVar4 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        u[0] = (dVar2 - dVar4) * dVar6 -
               (((dVar3 - dVar4 * dVar5) - (dVar2 - dVar4) * dVar5) - dVar4 * dVar6);
        dVar2 = dVar1 * b_00;
        dVar4 = dVar1 * splitter - (dVar1 * splitter - dVar1);
        dVar1 = (dVar1 - dVar4) * dVar6 -
                (((dVar2 - dVar4 * dVar5) - dVar5 * (dVar1 - dVar4)) - dVar4 * dVar6);
        u[2] = dVar3 + dVar1;
        u[1] = (dVar3 - (u[2] - (u[2] - dVar3))) + (dVar1 - (u[2] - dVar3));
        u[3] = dVar2 + u[2];
        u[2] = u[2] - (u[3] - dVar2);
        elen = fast_expansion_sum_zeroelim(elen,local_103c,4,u,e_00);
        e = e_00;
        e_01 = local_103c;
      }
    }
    local_103c = e_01;
    e_00 = e;
    e_01 = local_103c;
    if (dVar27 != 0.00000000) {
      dVar23 = -dVar23;
      dVar2 = dVar27 * dVar23;
      dVar1 = splitter * dVar23 - (splitter * dVar23 - dVar23);
      dVar3 = dVar27 * splitter - (dVar27 * splitter - dVar27);
      dVar3 = (dVar23 - dVar1) * (dVar27 - dVar3) -
              (((dVar2 - dVar1 * dVar3) - dVar3 * (dVar23 - dVar1)) - (dVar27 - dVar3) * dVar1);
      dVar5 = b_02 * splitter - (b_02 * splitter - b_02);
      dVar7 = b_02 - dVar5;
      dVar4 = b_02 * dVar3;
      dVar1 = splitter * dVar3 - (splitter * dVar3 - dVar3);
      u[0] = (dVar3 - dVar1) * dVar7 -
             (((dVar4 - dVar1 * dVar5) - (dVar3 - dVar1) * dVar5) - dVar1 * dVar7);
      dVar1 = dVar2 * b_02;
      dVar6 = dVar2 * splitter - (dVar2 * splitter - dVar2);
      dVar5 = (dVar2 - dVar6) * dVar7 -
              (((dVar1 - dVar6 * dVar5) - dVar5 * (dVar2 - dVar6)) - dVar6 * dVar7);
      u[2] = dVar4 + dVar5;
      u[1] = (dVar4 - (u[2] - (u[2] - dVar4))) + (dVar5 - (u[2] - dVar4));
      u[3] = dVar1 + u[2];
      u[2] = u[2] - (u[3] - dVar1);
      elen = fast_expansion_sum_zeroelim(elen,e,4,u,local_103c);
      e_00 = local_103c;
      e_01 = e;
      if (b_04 != 0.00000000) {
        dVar5 = splitter * b_04 - (splitter * b_04 - b_04);
        dVar6 = b_04 - dVar5;
        dVar1 = b_04 * dVar3;
        dVar4 = splitter * dVar3 - (splitter * dVar3 - dVar3);
        u[0] = (dVar3 - dVar4) * dVar6 -
               (((dVar1 - dVar4 * dVar5) - (dVar3 - dVar4) * dVar5) - dVar4 * dVar6);
        dVar3 = dVar2 * b_04;
        dVar4 = dVar2 * splitter - (dVar2 * splitter - dVar2);
        dVar2 = (dVar2 - dVar4) * dVar6 -
                (((dVar3 - dVar4 * dVar5) - dVar5 * (dVar2 - dVar4)) - dVar4 * dVar6);
        u[2] = dVar1 + dVar2;
        u[1] = (dVar1 - (u[2] - (u[2] - dVar1))) + (dVar2 - (u[2] - dVar1));
        u[3] = dVar3 + u[2];
        u[2] = u[2] - (u[3] - dVar3);
        elen = fast_expansion_sum_zeroelim(elen,local_103c,4,u,e);
        e_00 = e;
        e_01 = local_103c;
      }
    }
  }
  local_103c = e_01;
  e_01 = local_103c;
  if (dVar31 != 0.00000000) {
    e = e_00;
    if (dVar27 != 0.00000000) {
      dVar1 = dVar31 * dVar27;
      dVar2 = splitter * dVar31 - (splitter * dVar31 - dVar31);
      dVar3 = splitter * dVar27 - (splitter * dVar27 - dVar27);
      dVar2 = (dVar31 - dVar2) * (dVar27 - dVar3) -
              (((dVar1 - dVar2 * dVar3) - dVar3 * (dVar31 - dVar2)) - dVar2 * (dVar27 - dVar3));
      dVar5 = b_01 * splitter - (b_01 * splitter - b_01);
      dVar6 = b_01 - dVar5;
      dVar3 = b_01 * dVar2;
      dVar4 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      u[0] = (dVar2 - dVar4) * dVar6 -
             (((dVar3 - dVar4 * dVar5) - (dVar2 - dVar4) * dVar5) - dVar4 * dVar6);
      dVar7 = b_01 * dVar1;
      dVar4 = splitter * dVar1 - (splitter * dVar1 - dVar1);
      dVar4 = (dVar1 - dVar4) * dVar6 -
              (((dVar7 - dVar4 * dVar5) - dVar5 * (dVar1 - dVar4)) - dVar4 * dVar6);
      u[2] = dVar3 + dVar4;
      u[1] = (dVar3 - (u[2] - (u[2] - dVar3))) + (dVar4 - (u[2] - dVar3));
      u[3] = dVar7 + u[2];
      u[2] = u[2] - (u[3] - dVar7);
      elen = fast_expansion_sum_zeroelim(elen,e_00,4,u,local_103c);
      e = local_103c;
      e_01 = e_00;
      if (b_03 != 0.00000000) {
        dVar5 = splitter * b_03 - (splitter * b_03 - b_03);
        dVar6 = b_03 - dVar5;
        dVar3 = b_03 * dVar2;
        dVar4 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        u[0] = (dVar2 - dVar4) * dVar6 -
               (((dVar3 - dVar4 * dVar5) - (dVar2 - dVar4) * dVar5) - dVar4 * dVar6);
        dVar2 = b_03 * dVar1;
        dVar4 = splitter * dVar1 - (splitter * dVar1 - dVar1);
        dVar1 = (dVar1 - dVar4) * dVar6 -
                (((dVar2 - dVar4 * dVar5) - dVar5 * (dVar1 - dVar4)) - dVar4 * dVar6);
        u[2] = dVar3 + dVar1;
        u[1] = (dVar3 - (u[2] - (u[2] - dVar3))) + (dVar1 - (u[2] - dVar3));
        u[3] = dVar2 + u[2];
        u[2] = u[2] - (u[3] - dVar2);
        elen = fast_expansion_sum_zeroelim(elen,local_103c,4,u,e_00);
        e = e_00;
        e_01 = local_103c;
      }
    }
    local_103c = e_01;
    e_00 = e;
    e_01 = local_103c;
    if (dVar29 != 0.00000000) {
      dVar31 = -dVar31;
      dVar1 = dVar29 * dVar31;
      dVar2 = splitter * dVar31 - (splitter * dVar31 - dVar31);
      dVar3 = dVar29 * splitter - (dVar29 * splitter - dVar29);
      dVar4 = (dVar31 - dVar2) * (dVar29 - dVar3) -
              (((dVar1 - dVar2 * dVar3) - dVar3 * (dVar31 - dVar2)) - (dVar29 - dVar3) * dVar2);
      dVar3 = b * splitter - (b * splitter - b);
      dVar6 = b - dVar3;
      dVar5 = b * dVar4;
      dVar2 = splitter * dVar4 - (splitter * dVar4 - dVar4);
      u[0] = (dVar4 - dVar2) * dVar6 -
             (((dVar5 - dVar2 * dVar3) - (dVar4 - dVar2) * dVar3) - dVar2 * dVar6);
      b = b * dVar1;
      dVar2 = splitter * dVar1 - (splitter * dVar1 - dVar1);
      dVar2 = (dVar1 - dVar2) * dVar6 -
              (((b - dVar2 * dVar3) - dVar3 * (dVar1 - dVar2)) - dVar2 * dVar6);
      u[2] = dVar5 + dVar2;
      u[1] = (dVar2 - (u[2] - dVar5)) + (dVar5 - (u[2] - (u[2] - dVar5)));
      u[3] = b + u[2];
      u[2] = u[2] - (u[3] - b);
      elen = fast_expansion_sum_zeroelim(elen,e,4,u,local_103c);
      e_00 = local_103c;
      e_01 = e;
      if (b_00 != 0.00000000) {
        dVar3 = splitter * b_00 - (splitter * b_00 - b_00);
        dVar5 = b_00 - dVar3;
        dVar2 = b_00 * dVar4;
        b = splitter * dVar4 - (splitter * dVar4 - dVar4);
        u[0] = (dVar4 - b) * dVar5 - (((dVar2 - b * dVar3) - (dVar4 - b) * dVar3) - b * dVar5);
        b = b_00 * dVar1;
        dVar4 = splitter * dVar1 - (splitter * dVar1 - dVar1);
        dVar1 = (dVar1 - dVar4) * dVar5 -
                (((b - dVar4 * dVar3) - dVar3 * (dVar1 - dVar4)) - dVar4 * dVar5);
        u[2] = dVar2 + dVar1;
        u[1] = (dVar2 - (u[2] - (u[2] - dVar2))) + (dVar1 - (u[2] - dVar2));
        u[3] = b + u[2];
        u[2] = u[2] - (u[3] - b);
        elen = fast_expansion_sum_zeroelim(elen,local_103c,4,u,e);
        e_00 = e;
        e_01 = local_103c;
      }
    }
  }
  local_103c = e_01;
  e_01 = local_103c;
  if (dVar30 == 0.00000000) {
LAB_0812724f:
    local_103c = e_01;
    e = e_00;
    if (b_03 == 0.00000000) goto LAB_08127267;
  }
  else {
    e = e_00;
    if (dVar29 != 0.00000000) {
      dVar1 = dVar29 * dVar30;
      dVar2 = splitter * dVar30 - (splitter * dVar30 - dVar30);
      b = dVar29 * splitter - (dVar29 * splitter - dVar29);
      dVar2 = (dVar30 - dVar2) * (dVar29 - b) -
              (((dVar1 - dVar2 * b) - b * (dVar30 - dVar2)) - (dVar29 - b) * dVar2);
      dVar4 = b_02 * splitter - (b_02 * splitter - b_02);
      dVar5 = b_02 - dVar4;
      b = b_02 * dVar2;
      dVar3 = splitter * dVar2 - (splitter * dVar2 - dVar2);
      u[0] = (dVar2 - dVar3) * dVar5 -
             (((b - dVar3 * dVar4) - (dVar2 - dVar3) * dVar4) - dVar3 * dVar5);
      b_02 = dVar1 * b_02;
      dVar3 = dVar1 * splitter - (dVar1 * splitter - dVar1);
      dVar3 = (dVar1 - dVar3) * dVar5 -
              (((b_02 - dVar3 * dVar4) - dVar4 * (dVar1 - dVar3)) - dVar5 * dVar3);
      u[2] = b + dVar3;
      u[1] = (dVar3 - (u[2] - b)) + (b - (u[2] - (u[2] - b)));
      u[3] = b_02 + u[2];
      u[2] = u[2] - (u[3] - b_02);
      elen = fast_expansion_sum_zeroelim(elen,e_00,4,u,local_103c);
      e = local_103c;
      e_01 = e_00;
      if (b_04 != 0.00000000) {
        dVar4 = splitter * b_04 - (splitter * b_04 - b_04);
        b_02 = b_04 - dVar4;
        b = b_04 * dVar2;
        dVar3 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        u[0] = (dVar2 - dVar3) * b_02 -
               (((b - dVar3 * dVar4) - (dVar2 - dVar3) * dVar4) - dVar3 * b_02);
        dVar2 = dVar1 * b_04;
        dVar3 = dVar1 * splitter - (dVar1 * splitter - dVar1);
        dVar1 = (dVar1 - dVar3) * b_02 -
                (((dVar2 - dVar3 * dVar4) - dVar4 * (dVar1 - dVar3)) - b_02 * dVar3);
        u[2] = b + dVar1;
        u[1] = (b - (u[2] - (u[2] - b))) + (dVar1 - (u[2] - b));
        u[3] = dVar2 + u[2];
        u[2] = u[2] - (u[3] - dVar2);
        elen = fast_expansion_sum_zeroelim(elen,local_103c,4,u,e_00);
        e = e_00;
        e_01 = local_103c;
      }
    }
    local_103c = e_01;
    e_00 = e;
    e_01 = local_103c;
    if (dVar28 == 0.00000000) goto LAB_0812724f;
    dVar30 = -dVar30;
    dVar1 = dVar28 * dVar30;
    dVar2 = splitter * dVar30 - (splitter * dVar30 - dVar30);
    b = dVar28 * splitter - (dVar28 * splitter - dVar28);
    dVar2 = (dVar30 - dVar2) * (dVar28 - b) -
            (((dVar1 - dVar2 * b) - b * (dVar30 - dVar2)) - (dVar28 - b) * dVar2);
    dVar4 = b_01 * splitter - (b_01 * splitter - b_01);
    b_02 = b_01 - dVar4;
    b = b_01 * dVar2;
    dVar3 = splitter * dVar2 - (splitter * dVar2 - dVar2);
    u[0] = (dVar2 - dVar3) * b_02 - (((b - dVar3 * dVar4) - (dVar2 - dVar3) * dVar4) - dVar3 * b_02)
    ;
    b_01 = dVar1 * b_01;
    dVar3 = dVar1 * splitter - (dVar1 * splitter - dVar1);
    dVar3 = (dVar1 - dVar3) * b_02 -
            (((b_01 - dVar3 * dVar4) - dVar4 * (dVar1 - dVar3)) - b_02 * dVar3);
    u[2] = b + dVar3;
    u[1] = (dVar3 - (u[2] - b)) + (b - (u[2] - (u[2] - b)));
    u[3] = b_01 + u[2];
    u[2] = u[2] - (u[3] - b_01);
    elen = fast_expansion_sum_zeroelim(elen,e,4,u,local_103c);
    e_00 = local_103c;
    e_01 = e;
    if (b_03 == 0.00000000) goto LAB_0812724f;
    b_01 = b_03 * splitter - (b_03 * splitter - b_03);
    dVar4 = b_03 - b_01;
    dVar3 = b_03 * dVar2;
    b = dVar2 * splitter - (dVar2 * splitter - dVar2);
    u[0] = (dVar2 - b) * dVar4 - (((dVar3 - b * b_01) - (dVar2 - b) * b_01) - b * dVar4);
    b = dVar1 * b_03;
    dVar2 = dVar1 * splitter - (dVar1 * splitter - dVar1);
    dVar1 = (dVar1 - dVar2) * dVar4 -
            (((b - dVar2 * b_01) - b_01 * (dVar1 - dVar2)) - dVar4 * dVar2);
    u[2] = dVar3 + dVar1;
    u[1] = (dVar3 - (u[2] - (u[2] - dVar3))) + (dVar1 - (u[2] - dVar3));
    u[3] = b + u[2];
    u[2] = u[2] - (u[3] - b);
    elen = fast_expansion_sum_zeroelim(elen,local_103c,4,u,e);
  }
  flen = scale_expansion_zeroelim(flen,bct,b_03,w);
  elen = fast_expansion_sum_zeroelim(elen,e,flen,w,local_103c);
  e_00 = local_103c;
  local_103c = e;
LAB_08127267:
  e_01 = e_00;
  if (b_04 != 0.00000000) {
    flen = scale_expansion_zeroelim(flen_00,cat,b_04,w);
    elen = fast_expansion_sum_zeroelim(elen,e_00,flen,w,local_103c);
    e_01 = local_103c;
    local_103c = e_00;
  }
  if (b_00 != 0.00000000) {
    flen = scale_expansion_zeroelim(flen_01,abt,b_00,w);
    elen = fast_expansion_sum_zeroelim(elen,e_01,flen,w,local_103c);
    e_01 = local_103c;
  }
  return e_01[elen + -1];
}



double orient3d(double *pa,double *pb,double *pc,double *pd)

{
  double permanent;
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double local_2c;
  double local_24;
  double local_1c;
  double local_14;
  
  dVar5 = *pd;
  permanent = pd[1];
  local_14 = pd[2];
  local_24 = pa[2] - local_14;
  local_1c = pb[2] - local_14;
  local_14 = pc[2] - local_14;
  local_2c = (*pb - dVar5) * (pc[1] - permanent);
  dVar1 = (*pc - dVar5) * (pb[1] - permanent);
  dVar2 = (*pc - dVar5) * (pa[1] - permanent);
  dVar4 = (pc[1] - permanent) * (*pa - dVar5);
  dVar3 = (pb[1] - permanent) * (*pa - dVar5);
  permanent = (*pb - dVar5) * (pa[1] - permanent);
  dVar5 = (dVar3 - permanent) * local_14 +
          (local_2c - dVar1) * local_24 + (dVar2 - dVar4) * local_1c;
  if (local_2c < 0.00000000) {
    local_2c = -local_2c;
  }
  if (dVar1 < 0.00000000) {
    dVar1 = -dVar1;
  }
  if (local_24 < 0.00000000) {
    local_24 = -local_24;
  }
  if (dVar2 < 0.00000000) {
    dVar2 = -dVar2;
  }
  if (dVar4 < 0.00000000) {
    dVar4 = -dVar4;
  }
  if (local_1c < 0.00000000) {
    local_1c = -local_1c;
  }
  if (dVar3 < 0.00000000) {
    dVar3 = -dVar3;
  }
  if (permanent < 0.00000000) {
    permanent = -permanent;
  }
  if (local_14 < 0.00000000) {
    local_14 = -local_14;
  }
  permanent = (permanent + dVar3) * local_14 +
              (dVar4 + dVar2) * local_1c + (dVar1 + local_2c) * local_24;
  dVar1 = o3derrboundA * permanent;
  if ((dVar5 <= dVar1) && (-dVar5 <= dVar1)) {
    dVar5 = orient3dadapt(pa,pb,pc,pd,permanent);
    return dVar5;
  }
  return dVar5;
}



// WARNING: Removing unreachable block (ram,0x0812a1fe)
// WARNING: Removing unreachable block (ram,0x0812a172)
// WARNING: Removing unreachable block (ram,0x0812a811)
// WARNING: Removing unreachable block (ram,0x0812a81e)
// WARNING: Removing unreachable block (ram,0x0812ae8e)
// WARNING: Removing unreachable block (ram,0x0812ae09)
// WARNING: Removing unreachable block (ram,0x08129f02)
// WARNING: Removing unreachable block (ram,0x08129f14)
// WARNING: Removing unreachable block (ram,0x08129dd2)
// WARNING: Removing unreachable block (ram,0x08129dec)
// WARNING: Removing unreachable block (ram,0x08129c92)
// WARNING: Removing unreachable block (ram,0x08129cac)
// WARNING: Removing unreachable block (ram,0x081299f2)
// WARNING: Removing unreachable block (ram,0x08129a1c)
// WARNING: Removing unreachable block (ram,0x08129a04)
// WARNING: Removing unreachable block (ram,0x08129a0c)
// WARNING: Removing unreachable block (ram,0x08129a2c)
// WARNING: Removing unreachable block (ram,0x08129ca4)
// WARNING: Removing unreachable block (ram,0x08129de4)
// WARNING: Removing unreachable block (ram,0x08129f06)
// WARNING: Removing unreachable block (ram,0x0812ae7e)
// WARNING: Removing unreachable block (ram,0x0812ae71)
// WARNING: Removing unreachable block (ram,0x0812a7a7)
// WARNING: Removing unreachable block (ram,0x0812a82e)
// WARNING: Removing unreachable block (ram,0x0812a1ee)
// WARNING: Removing unreachable block (ram,0x0812a1df)
// WARNING: Removing unreachable block (ram,0x0812a834)
// WARNING: Removing unreachable block (ram,0x0812ae94)
// WARNING: Removing unreachable block (ram,0x0812a204)

double __regparm3 incircleadapt(double *pa,double *pb,double *pc,double *pd,double permanent)

{
  double b;
  double b_00;
  double b_01;
  double dVar1;
  double b_02;
  double b_03;
  double b_04;
  double b_05;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double b_06;
  double b_07;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double b_08;
  double b_09;
  double b_10;
  double dVar21;
  double dVar22;
  int elen;
  int flen;
  int flen_00;
  int flen_01;
  double *e;
  double *e_00;
  double *h;
  int local_649c;
  int local_6494;
  int local_648c;
  int local_6484;
  int local_647c;
  int local_6474;
  int local_646c;
  int local_645c;
  int local_640c;
  int local_63fc;
  double fin2 [1152];
  double fin1 [1152];
  double temp64 [64];
  double abdet [64];
  double temp48 [48];
  double temp32b [32];
  double temp32a [32];
  double cdet [32];
  double bdet [32];
  double adet [32];
  double cytabt [16];
  double cxtabt [16];
  double bytcat [16];
  double bxtcat [16];
  double aytbct [16];
  double axtbct [16];
  double temp16c [16];
  double temp16b [16];
  double temp16a [16];
  double cyyab [16];
  double cxxab [16];
  double byyca [16];
  double bxxca [16];
  double ayybc [16];
  double axxbc [16];
  double cat [8];
  double bct [8];
  double abt [8];
  double cytabtt [8];
  double cxtabtt [8];
  double bytcatt [8];
  double bxtcatt [8];
  double aytbctt [8];
  double axtbctt [8];
  double cytab [8];
  double cxtab [8];
  double bytca [8];
  double bxtca [8];
  double aytbc [8];
  double axtbc [8];
  double cytbb [8];
  double cytaa [8];
  double cxtbb [8];
  double cxtaa [8];
  double bytcc [8];
  double bytaa [8];
  double bxtcc [8];
  double bxtaa [8];
  double aytcc [8];
  double aytbb [8];
  double axtcc [8];
  double axtbb [8];
  double temp8 [8];
  double cyab [8];
  double cxab [8];
  double byca [8];
  double bxca [8];
  double aybc [8];
  double axbc [8];
  double catt [4];
  double bctt [4];
  double abtt [4];
  double v [4];
  double u [4];
  double cc [4];
  double bb [4];
  double aa [4];
  double ab [4];
  double ca [4];
  double bc [4];
  
  b = *pd;
  b_02 = *pa - b;
  b_03 = *pb - b;
  b = *pc - b;
  b_00 = pd[1];
  b_04 = pa[1] - b_00;
  b_05 = pb[1] - b_00;
  b_00 = pc[1] - b_00;
  dVar2 = b_03 * b_00;
  dVar3 = b_03 * splitter - (b_03 * splitter - b_03);
  dVar4 = b_00 * splitter - (b_00 * splitter - b_00);
  dVar15 = (b_03 - dVar3) * (b_00 - dVar4) -
           (((dVar2 - dVar3 * dVar4) - dVar4 * (b_03 - dVar3)) - (b_00 - dVar4) * dVar3);
  dVar3 = b * b_05;
  dVar5 = b * splitter - (b * splitter - b);
  dVar4 = splitter * b_05 - (splitter * b_05 - b_05);
  dVar4 = (b - dVar5) * (b_05 - dVar4) -
          (((dVar3 - dVar5 * dVar4) - dVar4 * (b - dVar5)) - (b_05 - dVar4) * dVar5);
  dVar5 = dVar15 - dVar4;
  bc[0] = (dVar15 - (dVar5 + (dVar15 - dVar5))) + ((dVar15 - dVar5) - dVar4);
  dVar4 = dVar2 + dVar5;
  dVar5 = (dVar5 - (dVar4 - dVar2)) + (dVar2 - (dVar4 - (dVar4 - dVar2)));
  dVar15 = dVar5 - dVar3;
  bc[1] = ((dVar5 - dVar15) - dVar3) + (dVar5 - (dVar15 + (dVar5 - dVar15)));
  bc[3] = dVar4 + dVar15;
  bc[2] = (dVar4 - (bc[3] - (bc[3] - dVar4))) + (dVar15 - (bc[3] - dVar4));
  elen = scale_expansion_zeroelim(4,bc,b_02,axbc);
  elen = scale_expansion_zeroelim(elen,axbc,b_02,axxbc);
  flen = scale_expansion_zeroelim(4,bc,b_04,aybc);
  flen = scale_expansion_zeroelim(flen,aybc,b_04,ayybc);
  elen = fast_expansion_sum_zeroelim(elen,axxbc,flen,ayybc,adet);
  dVar4 = b * b_04;
  dVar5 = b * splitter - (b * splitter - b);
  dVar15 = b_04 * splitter - (b_04 * splitter - b_04);
  b_01 = (b - dVar5) * (b_04 - dVar15) -
         (((dVar4 - dVar5 * dVar15) - dVar15 * (b - dVar5)) - (b_04 - dVar15) * dVar5);
  dVar16 = b_00 * b_02;
  dVar5 = b_02 * splitter - (b_02 * splitter - b_02);
  dVar15 = splitter * b_00 - (splitter * b_00 - b_00);
  dVar5 = (b_02 - dVar5) * (b_00 - dVar15) -
          (((dVar16 - dVar5 * dVar15) - dVar15 * (b_02 - dVar5)) - (b_00 - dVar15) * dVar5);
  dVar15 = b_01 - dVar5;
  ca[0] = (b_01 - (dVar15 + (b_01 - dVar15))) + ((b_01 - dVar15) - dVar5);
  dVar5 = dVar4 + dVar15;
  dVar15 = (dVar15 - (dVar5 - dVar4)) + (dVar4 - (dVar5 - (dVar5 - dVar4)));
  b_01 = dVar15 - dVar16;
  ca[1] = ((dVar15 - b_01) - dVar16) + (dVar15 - (b_01 + (dVar15 - b_01)));
  ca[3] = dVar5 + b_01;
  ca[2] = (dVar5 - (ca[3] - (ca[3] - dVar5))) + (b_01 - (ca[3] - dVar5));
  flen = scale_expansion_zeroelim(4,ca,b_03,bxca);
  flen = scale_expansion_zeroelim(flen,bxca,b_03,bxxca);
  flen_00 = scale_expansion_zeroelim(4,ca,b_05,byca);
  flen_00 = scale_expansion_zeroelim(flen_00,byca,b_05,byyca);
  flen = fast_expansion_sum_zeroelim(flen,bxxca,flen_00,byyca,bdet);
  dVar15 = b_05 * b_02;
  dVar5 = splitter * b_02 - (splitter * b_02 - b_02);
  b_01 = b_05 * splitter - (b_05 * splitter - b_05);
  b_01 = (b_02 - dVar5) * (b_05 - b_01) -
         (((dVar15 - dVar5 * b_01) - b_01 * (b_02 - dVar5)) - (b_05 - b_01) * dVar5);
  dVar5 = b_03 * b_04;
  dVar1 = b_03 * splitter - (b_03 * splitter - b_03);
  b_06 = splitter * b_04 - (splitter * b_04 - b_04);
  b_06 = (b_03 - dVar1) * (b_04 - b_06) -
         (((dVar5 - dVar1 * b_06) - b_06 * (b_03 - dVar1)) - (b_04 - b_06) * dVar1);
  dVar1 = b_01 - b_06;
  ab[0] = (b_01 - (dVar1 + (b_01 - dVar1))) + ((b_01 - dVar1) - b_06);
  b_01 = dVar15 + dVar1;
  dVar1 = (dVar1 - (b_01 - dVar15)) + (dVar15 - (b_01 - (b_01 - dVar15)));
  b_06 = dVar1 - dVar5;
  ab[1] = ((dVar1 - b_06) - dVar5) + (dVar1 - (b_06 + (dVar1 - b_06)));
  ab[3] = b_01 + b_06;
  ab[2] = (b_01 - (ab[3] - (ab[3] - b_01))) + (b_06 - (ab[3] - b_01));
  flen_00 = scale_expansion_zeroelim(4,ab,b,cxab);
  flen_00 = scale_expansion_zeroelim(flen_00,cxab,b,cxxab);
  flen_01 = scale_expansion_zeroelim(4,ab,b_00,cyab);
  flen_01 = scale_expansion_zeroelim(flen_01,cyab,b_00,cyyab);
  h = fin1;
  flen_00 = fast_expansion_sum_zeroelim(flen_00,cxxab,flen_01,cyyab,cdet);
  elen = fast_expansion_sum_zeroelim(elen,adet,flen,bdet,abdet);
  elen = fast_expansion_sum_zeroelim(elen,abdet,flen_00,cdet,h);
  if (1 < elen) {
    flen = 1;
    do {
      fin1[0] = fin1[0] + h[flen];
      flen = flen + 1;
    } while (flen != elen);
  }
  if ((fin1[0] < permanent * iccerrboundB) && (-fin1[0] < permanent * iccerrboundB)) {
    dVar1 = *pa - b_02;
    b_01 = *pd;
    b_08 = (dVar1 - b_01) + (*pa - (b_02 + dVar1));
    b_06 = pa[1] - b_04;
    dVar1 = pd[1];
    b_06 = (b_06 - dVar1) + (pa[1] - (b_04 + b_06));
    b_07 = *pb - b_03;
    b_10 = (b_07 - b_01) + (*pb - (b_03 + b_07));
    b_07 = pb[1] - b_05;
    b_07 = (b_07 - dVar1) + (pb[1] - (b_05 + b_07));
    b_09 = *pc - b;
    b_09 = (*pc - (b + b_09)) + (b_09 - b_01);
    b_01 = pc[1] - b_00;
    b_01 = (pc[1] - (b_00 + b_01)) + (b_01 - dVar1);
    if (((b_08 != 0.00000000) ||
        (((b_10 != 0.00000000 || (b_09 != 0.00000000)) || (b_06 != 0.00000000)))) ||
       ((b_07 != 0.00000000 || (b_01 != 0.00000000)))) {
      dVar1 = -fin1[0];
      if (0.00000000 <= fin1[0]) {
        dVar1 = fin1[0];
      }
      dVar17 = dVar1 * resulterrbound + permanent * iccerrboundC;
      dVar19 = b_02 * b_02;
      dVar1 = b_04 * b_04;
      dVar6 = b_03 * b_01;
      dVar7 = b_00 * b_10;
      dVar8 = b_03 * b_03;
      dVar9 = b_05 * b_05;
      dVar10 = b * b_06;
      dVar11 = b_04 * b_09;
      dVar12 = b * b;
      dVar13 = b_00 * b_00;
      dVar20 = b_07 * b_02;
      dVar14 = b_05 * b_08;
      dVar18 = b_04 * b_06 + b_08 * b_02;
      dVar21 = b_05 * b_07 + b_03 * b_10;
      dVar22 = b_00 * b_01 + b * b_09;
      fin1[0] = (dVar15 - dVar5) * (dVar22 + dVar22) +
                ((dVar20 + dVar14) - (b_03 * b_06 + b_04 * b_10)) * (dVar12 + dVar13) +
                (dVar4 - dVar16) * (dVar21 + dVar21) +
                ((dVar10 + dVar11) - (b_01 * b_02 + b_00 * b_08)) * (dVar8 + dVar9) +
                (dVar2 - dVar3) * (dVar18 + dVar18) +
                ((dVar6 + dVar7) - (b * b_07 + b_05 * b_09)) * (dVar19 + dVar1) + fin1[0];
      if ((fin1[0] < dVar17) && (-fin1[0] < dVar17)) {
        if ((b_10 != 0.00000000) ||
           (((b_07 != 0.00000000 || (b_09 != 0.00000000)) || (b_01 != 0.00000000)))) {
          dVar3 = splitter * b_02 - (splitter * b_02 - b_02);
          dVar2 = b_02 - dVar3;
          dVar2 = dVar2 * dVar2 - ((dVar19 - dVar3 * dVar3) + dVar3 * -2.00000000 * dVar2);
          dVar4 = b_04 * splitter - (b_04 * splitter - b_04);
          dVar3 = b_04 - dVar4;
          dVar4 = dVar3 * dVar3 - ((dVar1 - dVar4 * dVar4) + dVar4 * -2.00000000 * dVar3);
          dVar3 = dVar2 + dVar4;
          aa[0] = (dVar2 - (dVar3 - (dVar3 - dVar2))) + (dVar4 - (dVar3 - dVar2));
          dVar2 = dVar19 + dVar3;
          dVar3 = (dVar3 - (dVar2 - dVar19)) + (dVar19 - (dVar2 - (dVar2 - dVar19)));
          dVar4 = dVar1 + dVar3;
          aa[1] = (dVar1 - (dVar4 - dVar3)) + (dVar3 - (dVar4 - (dVar4 - dVar3)));
          aa[3] = dVar2 + dVar4;
          aa[2] = (dVar2 - (aa[3] - (aa[3] - dVar2))) + (dVar4 - (aa[3] - dVar2));
        }
        if (((b_09 != 0.00000000) || (b_01 != 0.00000000)) ||
           ((b_08 != 0.00000000 || (b_06 != 0.00000000)))) {
          dVar3 = b_03 * splitter - (b_03 * splitter - b_03);
          dVar2 = b_03 - dVar3;
          dVar4 = dVar2 * dVar2 - ((dVar8 - dVar3 * dVar3) + dVar3 * -2.00000000 * dVar2);
          dVar2 = splitter * b_05 - (splitter * b_05 - b_05);
          dVar3 = b_05 - dVar2;
          dVar2 = dVar3 * dVar3 - ((dVar9 - dVar2 * dVar2) + dVar2 * -2.00000000 * dVar3);
          dVar3 = dVar4 + dVar2;
          bb[0] = (dVar4 - (dVar3 - (dVar3 - dVar4))) + (dVar2 - (dVar3 - dVar4));
          dVar2 = dVar8 + dVar3;
          dVar3 = (dVar3 - (dVar2 - dVar8)) + (dVar8 - (dVar2 - (dVar2 - dVar8)));
          dVar4 = dVar9 + dVar3;
          bb[1] = (dVar9 - (dVar4 - dVar3)) + (dVar3 - (dVar4 - (dVar4 - dVar3)));
          bb[3] = dVar2 + dVar4;
          bb[2] = (dVar2 - (bb[3] - (bb[3] - dVar2))) + (dVar4 - (bb[3] - dVar2));
        }
        if (((b_08 != 0.00000000) || (b_06 != 0.00000000)) ||
           ((b_10 != 0.00000000 || (b_07 != 0.00000000)))) {
          dVar3 = b * splitter - (b * splitter - b);
          dVar2 = b - dVar3;
          dVar4 = dVar2 * dVar2 - ((dVar12 - dVar3 * dVar3) + dVar3 * -2.00000000 * dVar2);
          dVar2 = splitter * b_00 - (splitter * b_00 - b_00);
          dVar3 = b_00 - dVar2;
          dVar2 = dVar3 * dVar3 - ((dVar13 - dVar2 * dVar2) + dVar2 * -2.00000000 * dVar3);
          dVar3 = dVar4 + dVar2;
          cc[0] = (dVar4 - (dVar3 - (dVar3 - dVar4))) + (dVar2 - (dVar3 - dVar4));
          dVar2 = dVar12 + dVar3;
          dVar3 = (dVar3 - (dVar2 - dVar12)) + (dVar12 - (dVar2 - (dVar2 - dVar12)));
          dVar4 = dVar13 + dVar3;
          cc[1] = (dVar13 - (dVar4 - dVar3)) + (dVar3 - (dVar4 - (dVar4 - dVar3)));
          cc[3] = dVar2 + dVar4;
          cc[2] = (dVar2 - (cc[3] - (cc[3] - dVar2))) + (dVar4 - (cc[3] - dVar2));
        }
        if (b_08 == 0.00000000) {
          local_6494 = 0;
          e_00 = h;
          h = fin2;
        }
        else {
          local_6494 = scale_expansion_zeroelim(4,bc,b_08,axtbc);
          flen = scale_expansion_zeroelim(local_6494,axtbc,b_02 + b_02,temp16a);
          flen_00 = scale_expansion_zeroelim(4,cc,b_08,axtcc);
          flen_00 = scale_expansion_zeroelim(flen_00,axtcc,b_05,temp16b);
          flen_01 = scale_expansion_zeroelim(4,bb,b_08,axtbb);
          flen_01 = scale_expansion_zeroelim(flen_01,axtbb,-b_00,temp16c);
          flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_00,temp16b,temp32a);
          flen = fast_expansion_sum_zeroelim(flen_01,temp16c,flen,temp32a,temp48);
          e_00 = fin2;
          elen = fast_expansion_sum_zeroelim(elen,h,flen,temp48,fin2);
        }
        local_648c = 0;
        e = e_00;
        if (b_06 != 0.00000000) {
          local_648c = scale_expansion_zeroelim(4,bc,b_06,aytbc);
          flen = scale_expansion_zeroelim(local_648c,aytbc,b_04 + b_04,temp16a);
          flen_00 = scale_expansion_zeroelim(4,bb,b_06,aytbb);
          flen_00 = scale_expansion_zeroelim(flen_00,aytbb,b,temp16b);
          flen_01 = scale_expansion_zeroelim(4,cc,b_06,aytcc);
          flen_01 = scale_expansion_zeroelim(flen_01,aytcc,-b_03,temp16c);
          flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_00,temp16b,temp32a);
          flen = fast_expansion_sum_zeroelim(flen_01,temp16c,flen,temp32a,temp48);
          elen = fast_expansion_sum_zeroelim(elen,e_00,flen,temp48,h);
          e = h;
          h = e_00;
        }
        local_6484 = 0;
        e_00 = e;
        if (b_10 != 0.00000000) {
          local_6484 = scale_expansion_zeroelim(4,ca,b_10,bxtca);
          flen = scale_expansion_zeroelim(local_6484,bxtca,b_03 + b_03,temp16a);
          flen_00 = scale_expansion_zeroelim(4,aa,b_10,bxtaa);
          flen_00 = scale_expansion_zeroelim(flen_00,bxtaa,b_00,temp16b);
          flen_01 = scale_expansion_zeroelim(4,cc,b_10,bxtcc);
          flen_01 = scale_expansion_zeroelim(flen_01,bxtcc,-b_04,temp16c);
          flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_00,temp16b,temp32a);
          flen = fast_expansion_sum_zeroelim(flen_01,temp16c,flen,temp32a,temp48);
          elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
          e_00 = h;
          h = e;
        }
        local_646c = 0;
        e = e_00;
        if (b_07 != 0.00000000) {
          local_646c = scale_expansion_zeroelim(4,ca,b_07,bytca);
          flen = scale_expansion_zeroelim(local_646c,bytca,b_05 + b_05,temp16a);
          flen_00 = scale_expansion_zeroelim(4,cc,b_07,bytcc);
          flen_00 = scale_expansion_zeroelim(flen_00,bytcc,b_02,temp16b);
          flen_01 = scale_expansion_zeroelim(4,aa,b_07,bytaa);
          flen_01 = scale_expansion_zeroelim(flen_01,bytaa,-b,temp16c);
          flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_00,temp16b,temp32a);
          flen = fast_expansion_sum_zeroelim(flen_01,temp16c,flen,temp32a,temp48);
          elen = fast_expansion_sum_zeroelim(elen,e_00,flen,temp48,h);
          e = h;
          h = e_00;
        }
        local_647c = 0;
        e_00 = e;
        if (b_09 != 0.00000000) {
          local_647c = scale_expansion_zeroelim(4,ab,b_09,cxtab);
          flen = scale_expansion_zeroelim(local_647c,cxtab,b + b,temp16a);
          flen_00 = scale_expansion_zeroelim(4,bb,b_09,cxtbb);
          flen_00 = scale_expansion_zeroelim(flen_00,cxtbb,b_04,temp16b);
          flen_01 = scale_expansion_zeroelim(4,aa,b_09,cxtaa);
          flen_01 = scale_expansion_zeroelim(flen_01,cxtaa,-b_05,temp16c);
          flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_00,temp16b,temp32a);
          flen = fast_expansion_sum_zeroelim(flen_01,temp16c,flen,temp32a,temp48);
          elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
          e_00 = h;
          h = e;
        }
        local_6474 = 0;
        e = e_00;
        if (b_01 != 0.00000000) {
          local_6474 = scale_expansion_zeroelim(4,ab,b_01,cytab);
          flen = scale_expansion_zeroelim(local_6474,cytab,b_00 + b_00,temp16a);
          flen_00 = scale_expansion_zeroelim(4,aa,b_01,cytaa);
          flen_00 = scale_expansion_zeroelim(flen_00,cytaa,b_03,temp16b);
          flen_01 = scale_expansion_zeroelim(4,bb,b_01,cytbb);
          flen_01 = scale_expansion_zeroelim(flen_01,cytbb,-b_02,temp16c);
          flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_00,temp16b,temp32a);
          flen = fast_expansion_sum_zeroelim(flen_01,temp16c,flen,temp32a,temp48);
          elen = fast_expansion_sum_zeroelim(elen,e_00,flen,temp48,h);
          e = h;
          h = e_00;
        }
        if ((b_08 != 0.00000000) || (b_06 != 0.00000000)) {
          if ((b_10 == 0.00000000) &&
             (((b_07 == 0.00000000 && (b_09 == 0.00000000)) && (b_01 == 0.00000000)))) {
            bct[0] = 0.00000000;
            local_645c = 1;
            bctt[0] = 0.00000000;
            local_649c = 1;
          }
          else {
            dVar2 = splitter * b_10 - (splitter * b_10 - b_10);
            dVar3 = b_00 * splitter - (b_00 * splitter - b_00);
            dVar2 = (b_10 - dVar2) * (b_00 - dVar3) -
                    (((dVar7 - dVar2 * dVar3) - dVar3 * (b_10 - dVar2)) - (b_00 - dVar3) * dVar2);
            dVar3 = b_03 * splitter - (b_03 * splitter - b_03);
            dVar4 = b_01 * splitter - (b_01 * splitter - b_01);
            dVar4 = (b_03 - dVar3) * (b_01 - dVar4) -
                    (((dVar6 - dVar3 * dVar4) - dVar4 * (b_03 - dVar3)) - (b_01 - dVar4) * dVar3);
            dVar3 = dVar2 + dVar4;
            u[0] = (dVar2 - (dVar3 - (dVar3 - dVar2))) + (dVar4 - (dVar3 - dVar2));
            dVar2 = dVar7 + dVar3;
            dVar3 = (dVar7 - (dVar2 - (dVar2 - dVar7))) + (dVar3 - (dVar2 - dVar7));
            dVar4 = dVar6 + dVar3;
            u[1] = (dVar6 - (dVar4 - dVar3)) + (dVar3 - (dVar4 - (dVar4 - dVar3)));
            u[3] = dVar2 + dVar4;
            u[2] = (dVar2 - (u[3] - (u[3] - dVar2))) + (dVar4 - (u[3] - dVar2));
            dVar2 = -b_05;
            dVar3 = b_09 * dVar2;
            dVar5 = splitter * b_09 - (splitter * b_09 - b_09);
            dVar4 = splitter * dVar2 - (splitter * dVar2 - dVar2);
            dVar2 = (b_09 - dVar5) * (dVar2 - dVar4) -
                    (((dVar3 - dVar5 * dVar4) - dVar4 * (b_09 - dVar5)) - dVar5 * (dVar2 - dVar4));
            dVar5 = -b_07;
            dVar15 = b * dVar5;
            dVar16 = b * splitter - (b * splitter - b);
            dVar4 = splitter * dVar5 - (splitter * dVar5 - dVar5);
            dVar5 = (b - dVar16) * (dVar5 - dVar4) -
                    (((dVar15 - dVar16 * dVar4) - dVar4 * (b - dVar16)) - dVar16 * (dVar5 - dVar4));
            dVar4 = dVar2 + dVar5;
            v[0] = (dVar2 - (dVar4 - (dVar4 - dVar2))) + (dVar5 - (dVar4 - dVar2));
            dVar2 = dVar3 + dVar4;
            dVar3 = (dVar3 - (dVar2 - (dVar2 - dVar3))) + (dVar4 - (dVar2 - dVar3));
            dVar4 = dVar15 + dVar3;
            v[1] = (dVar15 - (dVar4 - dVar3)) + (dVar3 - (dVar4 - (dVar4 - dVar3)));
            v[3] = dVar2 + dVar4;
            v[2] = (dVar2 - (v[3] - (v[3] - dVar2))) + (dVar4 - (v[3] - dVar2));
            local_649c = fast_expansion_sum_zeroelim(4,u,4,v,bct);
            local_645c = 4;
            dVar2 = b_10 * b_01;
            dVar3 = b_10 * splitter - (b_10 * splitter - b_10);
            dVar4 = b_01 * splitter - (b_01 * splitter - b_01);
            dVar15 = (b_10 - dVar3) * (b_01 - dVar4) -
                     (((dVar2 - dVar3 * dVar4) - dVar4 * (b_10 - dVar3)) - (b_01 - dVar4) * dVar3);
            dVar3 = b_09 * b_07;
            dVar5 = b_09 * splitter - (b_09 * splitter - b_09);
            dVar4 = splitter * b_07 - (splitter * b_07 - b_07);
            dVar4 = (b_09 - dVar5) * (b_07 - dVar4) -
                    (((dVar3 - dVar5 * dVar4) - dVar4 * (b_09 - dVar5)) - (b_07 - dVar4) * dVar5);
            dVar5 = dVar15 - dVar4;
            bctt[0] = (dVar15 - (dVar5 + (dVar15 - dVar5))) + ((dVar15 - dVar5) - dVar4);
            dVar4 = dVar2 + dVar5;
            dVar2 = (dVar5 - (dVar4 - dVar2)) + (dVar2 - (dVar4 - (dVar4 - dVar2)));
            dVar5 = dVar2 - dVar3;
            bctt[1] = ((dVar2 - dVar5) - dVar3) + (dVar2 - (dVar5 + (dVar2 - dVar5)));
            bctt[3] = dVar4 + dVar5;
            bctt[2] = (dVar4 - (bctt[3] - (bctt[3] - dVar4))) + (dVar5 - (bctt[3] - dVar4));
          }
          if (b_08 != 0.00000000) {
            flen = scale_expansion_zeroelim(local_6494,axtbc,b_08,temp16a);
            flen_00 = scale_expansion_zeroelim(local_649c,bct,b_08,axtbct);
            flen_01 = scale_expansion_zeroelim(flen_00,axtbct,b_02 + b_02,temp32a);
            flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_01,temp32a,temp48);
            elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
            e_00 = h;
            if (b_07 != 0.00000000) {
              flen = scale_expansion_zeroelim(4,cc,b_08,temp8);
              flen = scale_expansion_zeroelim(flen,temp8,b_07,temp16a);
              elen = fast_expansion_sum_zeroelim(elen,h,flen,temp16a,e);
              e_00 = e;
              e = h;
            }
            h = e_00;
            if (b_01 != 0.00000000) {
              flen = scale_expansion_zeroelim(4,bb,-b_08,temp8);
              flen = scale_expansion_zeroelim(flen,temp8,b_01,temp16a);
              elen = fast_expansion_sum_zeroelim(elen,e_00,flen,temp16a,e);
              h = e;
              e = e_00;
            }
            flen = scale_expansion_zeroelim(flen_00,axtbct,b_08,temp32a);
            flen_00 = scale_expansion_zeroelim(local_645c,bctt,b_08,axtbctt);
            flen_01 = scale_expansion_zeroelim(flen_00,axtbctt,b_02 + b_02,temp16a);
            flen_00 = scale_expansion_zeroelim(flen_00,axtbctt,b_08,temp16b);
            flen_00 = fast_expansion_sum_zeroelim(flen_01,temp16a,flen_00,temp16b,temp32b);
            flen = fast_expansion_sum_zeroelim(flen,temp32a,flen_00,temp32b,temp64);
            elen = fast_expansion_sum_zeroelim(elen,h,flen,temp64,e);
          }
          if (b_06 != 0.00000000) {
            flen = scale_expansion_zeroelim(local_648c,aytbc,b_06,temp16a);
            flen_00 = scale_expansion_zeroelim(local_649c,bct,b_06,aytbct);
            flen_01 = scale_expansion_zeroelim(flen_00,aytbct,b_04 + b_04,temp32a);
            flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_01,temp32a,temp48);
            elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
            flen = scale_expansion_zeroelim(flen_00,aytbct,b_06,temp32a);
            flen_00 = scale_expansion_zeroelim(local_645c,bctt,b_06,aytbctt);
            flen_01 = scale_expansion_zeroelim(flen_00,aytbctt,b_04 + b_04,temp16a);
            flen_00 = scale_expansion_zeroelim(flen_00,aytbctt,b_06,temp16b);
            flen_00 = fast_expansion_sum_zeroelim(flen_01,temp16a,flen_00,temp16b,temp32b);
            flen = fast_expansion_sum_zeroelim(flen,temp32a,flen_00,temp32b,temp64);
            elen = fast_expansion_sum_zeroelim(elen,h,flen,temp64,e);
          }
        }
        if ((b_10 != 0.00000000) || (b_07 != 0.00000000)) {
          if (((b_09 == 0.00000000) && ((b_01 == 0.00000000 && (b_08 == 0.00000000)))) &&
             (b_06 == 0.00000000)) {
            cat[0] = 0.00000000;
            local_645c = 1;
            catt[0] = 0.00000000;
            local_648c = 1;
          }
          else {
            dVar2 = splitter * b_09 - (splitter * b_09 - b_09);
            dVar3 = b_04 * splitter - (b_04 * splitter - b_04);
            dVar2 = (b_09 - dVar2) * (b_04 - dVar3) -
                    (((dVar11 - dVar2 * dVar3) - dVar3 * (b_09 - dVar2)) - (b_04 - dVar3) * dVar2);
            dVar3 = b * splitter - (b * splitter - b);
            dVar4 = b_06 * splitter - (b_06 * splitter - b_06);
            dVar4 = (b - dVar3) * (b_06 - dVar4) -
                    (((dVar10 - dVar3 * dVar4) - dVar4 * (b - dVar3)) - (b_06 - dVar4) * dVar3);
            dVar3 = dVar2 + dVar4;
            u[0] = (dVar2 - (dVar3 - (dVar3 - dVar2))) + (dVar4 - (dVar3 - dVar2));
            dVar2 = dVar11 + dVar3;
            dVar3 = (dVar11 - (dVar2 - (dVar2 - dVar11))) + (dVar3 - (dVar2 - dVar11));
            dVar4 = dVar10 + dVar3;
            u[1] = (dVar10 - (dVar4 - dVar3)) + (dVar3 - (dVar4 - (dVar4 - dVar3)));
            u[3] = dVar2 + dVar4;
            u[2] = (dVar2 - (u[3] - (u[3] - dVar2))) + (dVar4 - (u[3] - dVar2));
            dVar3 = -b_00;
            dVar15 = b_08 * dVar3;
            dVar4 = splitter * b_08 - (splitter * b_08 - b_08);
            dVar2 = splitter * dVar3 - (splitter * dVar3 - dVar3);
            dVar5 = (b_08 - dVar4) * (dVar3 - dVar2) -
                    (((dVar15 - dVar4 * dVar2) - dVar2 * (b_08 - dVar4)) - dVar4 * (dVar3 - dVar2));
            dVar3 = -b_01;
            dVar2 = b_02 * dVar3;
            dVar16 = splitter * b_02 - (splitter * b_02 - b_02);
            dVar4 = splitter * dVar3 - (splitter * dVar3 - dVar3);
            dVar3 = (b_02 - dVar16) * (dVar3 - dVar4) -
                    (((dVar2 - dVar16 * dVar4) - dVar4 * (b_02 - dVar16)) - dVar16 * (dVar3 - dVar4)
                    );
            dVar4 = dVar5 + dVar3;
            v[0] = (dVar5 - (dVar4 - (dVar4 - dVar5))) + (dVar3 - (dVar4 - dVar5));
            dVar3 = dVar15 + dVar4;
            dVar4 = (dVar15 - (dVar3 - (dVar3 - dVar15))) + (dVar4 - (dVar3 - dVar15));
            dVar5 = dVar2 + dVar4;
            v[1] = (dVar2 - (dVar5 - dVar4)) + (dVar4 - (dVar5 - (dVar5 - dVar4)));
            v[3] = dVar3 + dVar5;
            v[2] = (dVar3 - (v[3] - (v[3] - dVar3))) + (dVar5 - (v[3] - dVar3));
            local_648c = fast_expansion_sum_zeroelim(4,u,4,v,cat);
            local_645c = 4;
            dVar2 = b_09 * b_06;
            dVar3 = b_09 * splitter - (b_09 * splitter - b_09);
            dVar4 = b_06 * splitter - (b_06 * splitter - b_06);
            dVar15 = (b_09 - dVar3) * (b_06 - dVar4) -
                     (((dVar2 - dVar3 * dVar4) - dVar4 * (b_09 - dVar3)) - (b_06 - dVar4) * dVar3);
            dVar3 = b_08 * b_01;
            dVar5 = b_08 * splitter - (b_08 * splitter - b_08);
            dVar4 = splitter * b_01 - (splitter * b_01 - b_01);
            dVar4 = (b_08 - dVar5) * (b_01 - dVar4) -
                    (((dVar3 - dVar5 * dVar4) - dVar4 * (b_08 - dVar5)) - (b_01 - dVar4) * dVar5);
            dVar5 = dVar15 - dVar4;
            catt[0] = (dVar15 - (dVar5 + (dVar15 - dVar5))) + ((dVar15 - dVar5) - dVar4);
            dVar4 = dVar2 + dVar5;
            dVar2 = (dVar5 - (dVar4 - dVar2)) + (dVar2 - (dVar4 - (dVar4 - dVar2)));
            dVar5 = dVar2 - dVar3;
            catt[1] = ((dVar2 - dVar5) - dVar3) + (dVar2 - (dVar5 + (dVar2 - dVar5)));
            catt[3] = dVar4 + dVar5;
            catt[2] = (dVar4 - (catt[3] - (catt[3] - dVar4))) + (dVar5 - (catt[3] - dVar4));
          }
          if (b_10 != 0.00000000) {
            flen = scale_expansion_zeroelim(local_6484,bxtca,b_10,temp16a);
            flen_00 = scale_expansion_zeroelim(local_648c,cat,b_10,bxtcat);
            flen_01 = scale_expansion_zeroelim(flen_00,bxtcat,b_03 + b_03,temp32a);
            flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_01,temp32a,temp48);
            elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
            e_00 = h;
            if (b_01 != 0.00000000) {
              flen = scale_expansion_zeroelim(4,aa,b_10,temp8);
              flen = scale_expansion_zeroelim(flen,temp8,b_01,temp16a);
              elen = fast_expansion_sum_zeroelim(elen,h,flen,temp16a,e);
              e_00 = e;
              e = h;
            }
            h = e_00;
            if (b_06 != 0.00000000) {
              flen = scale_expansion_zeroelim(4,cc,-b_10,temp8);
              flen = scale_expansion_zeroelim(flen,temp8,b_06,temp16a);
              elen = fast_expansion_sum_zeroelim(elen,e_00,flen,temp16a,e);
              h = e;
              e = e_00;
            }
            flen = scale_expansion_zeroelim(flen_00,bxtcat,b_10,temp32a);
            flen_00 = scale_expansion_zeroelim(local_645c,catt,b_10,bxtcatt);
            flen_01 = scale_expansion_zeroelim(flen_00,bxtcatt,b_03 + b_03,temp16a);
            flen_00 = scale_expansion_zeroelim(flen_00,bxtcatt,b_10,temp16b);
            flen_00 = fast_expansion_sum_zeroelim(flen_01,temp16a,flen_00,temp16b,temp32b);
            flen = fast_expansion_sum_zeroelim(flen,temp32a,flen_00,temp32b,temp64);
            elen = fast_expansion_sum_zeroelim(elen,h,flen,temp64,e);
          }
          if (b_07 != 0.00000000) {
            flen = scale_expansion_zeroelim(local_646c,bytca,b_07,temp16a);
            flen_00 = scale_expansion_zeroelim(local_648c,cat,b_07,bytcat);
            flen_01 = scale_expansion_zeroelim(flen_00,bytcat,b_05 + b_05,temp32a);
            flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_01,temp32a,temp48);
            elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
            flen = scale_expansion_zeroelim(flen_00,bytcat,b_07,temp32a);
            flen_00 = scale_expansion_zeroelim(local_645c,catt,b_07,bytcatt);
            flen_01 = scale_expansion_zeroelim(flen_00,bytcatt,b_05 + b_05,temp16a);
            flen_00 = scale_expansion_zeroelim(flen_00,bytcatt,b_07,temp16b);
            flen_00 = fast_expansion_sum_zeroelim(flen_01,temp16a,flen_00,temp16b,temp32b);
            flen = fast_expansion_sum_zeroelim(flen,temp32a,flen_00,temp32b,temp64);
            elen = fast_expansion_sum_zeroelim(elen,h,flen,temp64,e);
          }
        }
        if ((b_09 != 0.00000000) || (b_01 != 0.00000000)) {
          if ((b_08 == 0.00000000) &&
             (((b_06 == 0.00000000 && (b_10 == 0.00000000)) && (b_07 == 0.00000000)))) {
            abt[0] = 0.00000000;
            local_63fc = 1;
            abtt[0] = 0.00000000;
            local_640c = 1;
          }
          else {
            dVar2 = b_08 * splitter - (b_08 * splitter - b_08);
            dVar3 = b_05 * splitter - (b_05 * splitter - b_05);
            dVar2 = (b_08 - dVar2) * (b_05 - dVar3) -
                    (((dVar14 - dVar2 * dVar3) - dVar3 * (b_08 - dVar2)) - (b_05 - dVar3) * dVar2);
            dVar3 = b_02 * splitter - (b_02 * splitter - b_02);
            b_05 = b_07 * splitter - (b_07 * splitter - b_07);
            b_02 = (b_02 - dVar3) * (b_07 - b_05) -
                   (((dVar20 - dVar3 * b_05) - (b_02 - dVar3) * b_05) - (b_07 - b_05) * dVar3);
            b_05 = dVar2 + b_02;
            u[0] = (dVar2 - (b_05 - (b_05 - dVar2))) + (b_02 - (b_05 - dVar2));
            b_02 = dVar14 + b_05;
            b_05 = (b_05 - (b_02 - dVar14)) + (dVar14 - (b_02 - (b_02 - dVar14)));
            dVar2 = dVar20 + b_05;
            u[1] = (dVar20 - (dVar2 - b_05)) + (b_05 - (dVar2 - (dVar2 - b_05)));
            u[3] = b_02 + dVar2;
            u[2] = (b_02 - (u[3] - (u[3] - b_02))) + (dVar2 - (u[3] - b_02));
            b_04 = -b_04;
            dVar4 = b_10 * b_04;
            b_05 = b_10 * splitter - (b_10 * splitter - b_10);
            b_02 = b_04 * splitter - (b_04 * splitter - b_04);
            b_02 = (b_10 - b_05) * (b_04 - b_02) -
                   (((dVar4 - b_05 * b_02) - b_02 * (b_10 - b_05)) - b_05 * (b_04 - b_02));
            dVar2 = -b_06;
            b_05 = b_03 * dVar2;
            dVar3 = b_03 * splitter - (b_03 * splitter - b_03);
            b_04 = splitter * dVar2 - (splitter * dVar2 - dVar2);
            b_04 = (b_03 - dVar3) * (dVar2 - b_04) -
                   (((b_05 - dVar3 * b_04) - b_04 * (b_03 - dVar3)) - dVar3 * (dVar2 - b_04));
            b_03 = b_02 + b_04;
            v[0] = (b_02 - (b_03 - (b_03 - b_02))) + (b_04 - (b_03 - b_02));
            b_04 = dVar4 + b_03;
            b_03 = (dVar4 - (b_04 - (b_04 - dVar4))) + (b_03 - (b_04 - dVar4));
            b_02 = b_03 + b_05;
            v[1] = (b_03 - (b_02 - (b_02 - b_03))) + (b_05 - (b_02 - b_03));
            v[3] = b_04 + b_02;
            v[2] = (b_04 - (v[3] - (v[3] - b_04))) + (b_02 - (v[3] - b_04));
            local_640c = fast_expansion_sum_zeroelim(4,u,4,v,abt);
            b_02 = b_08 * b_07;
            b_03 = b_08 * splitter - (b_08 * splitter - b_08);
            b_04 = b_07 * splitter - (b_07 * splitter - b_07);
            b_04 = (b_08 - b_03) * (b_07 - b_04) -
                   (((b_02 - b_03 * b_04) - b_04 * (b_08 - b_03)) - (b_07 - b_04) * b_03);
            b_05 = b_10 * b_06;
            dVar2 = b_10 * splitter - (b_10 * splitter - b_10);
            b_03 = splitter * b_06 - (splitter * b_06 - b_06);
            local_63fc = 4;
            b_03 = (b_06 - b_03) * (b_10 - dVar2) -
                   (((b_05 - dVar2 * b_03) - b_03 * (b_10 - dVar2)) - dVar2 * (b_06 - b_03));
            dVar2 = b_04 - b_03;
            abtt[0] = (b_04 - (dVar2 + (b_04 - dVar2))) + ((b_04 - dVar2) - b_03);
            b_03 = b_02 + dVar2;
            b_02 = (b_02 - (b_03 - (b_03 - b_02))) + (dVar2 - (b_03 - b_02));
            b_04 = b_02 - b_05;
            abtt[1] = (b_02 - (b_04 + (b_02 - b_04))) + ((b_02 - b_04) - b_05);
            abtt[3] = b_03 + b_04;
            abtt[2] = (b_03 - (abtt[3] - (abtt[3] - b_03))) + (b_04 - (abtt[3] - b_03));
          }
          if (b_09 != 0.00000000) {
            flen = scale_expansion_zeroelim(local_647c,cxtab,b_09,temp16a);
            flen_00 = scale_expansion_zeroelim(local_640c,abt,b_09,cxtabt);
            flen_01 = scale_expansion_zeroelim(flen_00,cxtabt,b + b,temp32a);
            flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_01,temp32a,temp48);
            elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
            e_00 = h;
            if (b_06 != 0.00000000) {
              flen = scale_expansion_zeroelim(4,bb,b_09,temp8);
              flen = scale_expansion_zeroelim(flen,temp8,b_06,temp16a);
              elen = fast_expansion_sum_zeroelim(elen,h,flen,temp16a,e);
              e_00 = e;
              e = h;
            }
            h = e_00;
            if (b_07 != 0.00000000) {
              flen = scale_expansion_zeroelim(4,aa,-b_09,temp8);
              flen = scale_expansion_zeroelim(flen,temp8,b_07,temp16a);
              elen = fast_expansion_sum_zeroelim(elen,e_00,flen,temp16a,e);
              h = e;
              e = e_00;
            }
            flen = scale_expansion_zeroelim(flen_00,cxtabt,b_09,temp32a);
            flen_00 = scale_expansion_zeroelim(local_63fc,abtt,b_09,cxtabtt);
            flen_01 = scale_expansion_zeroelim(flen_00,cxtabtt,b + b,temp16a);
            flen_00 = scale_expansion_zeroelim(flen_00,cxtabtt,b_09,temp16b);
            flen_00 = fast_expansion_sum_zeroelim(flen_01,temp16a,flen_00,temp16b,temp32b);
            flen = fast_expansion_sum_zeroelim(flen,temp32a,flen_00,temp32b,temp64);
            elen = fast_expansion_sum_zeroelim(elen,h,flen,temp64,e);
          }
          if (b_01 != 0.00000000) {
            flen = scale_expansion_zeroelim(local_6474,cytab,b_01,temp16a);
            flen_00 = scale_expansion_zeroelim(local_640c,abt,b_01,cytabt);
            flen_01 = scale_expansion_zeroelim(flen_00,cytabt,b_00 + b_00,temp32a);
            flen = fast_expansion_sum_zeroelim(flen,temp16a,flen_01,temp32a,temp48);
            elen = fast_expansion_sum_zeroelim(elen,e,flen,temp48,h);
            flen = scale_expansion_zeroelim(flen_00,cytabt,b_01,temp32a);
            flen_00 = scale_expansion_zeroelim(local_63fc,abtt,b_01,cytabtt);
            flen_01 = scale_expansion_zeroelim(flen_00,cytabtt,b_00 + b_00,temp16a);
            flen_00 = scale_expansion_zeroelim(flen_00,cytabtt,b_01,temp16b);
            flen_00 = fast_expansion_sum_zeroelim(flen_01,temp16a,flen_00,temp16b,temp32b);
            flen = fast_expansion_sum_zeroelim(flen,temp32a,flen_00,temp32b,temp64);
            elen = fast_expansion_sum_zeroelim(elen,h,flen,temp64,e);
          }
        }
        fin1[0] = e[elen + -1];
      }
    }
  }
  return fin1[0];
}



double incircle(double *pa,double *pb,double *pc,double *pd)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double permanent;
  double local_34;
  double local_2c;
  double local_24;
  
  permanent = *pd;
  dVar2 = *pa - permanent;
  dVar3 = *pb - permanent;
  permanent = *pc - permanent;
  dVar1 = pd[1];
  dVar6 = pa[1] - dVar1;
  dVar5 = pb[1] - dVar1;
  dVar1 = pc[1] - dVar1;
  dVar8 = dVar3 * dVar1;
  local_34 = permanent * dVar5;
  dVar7 = dVar6 * dVar6 + dVar2 * dVar2;
  local_2c = permanent * dVar6;
  local_24 = dVar2 * dVar1;
  dVar4 = dVar5 * dVar5 + dVar3 * dVar3;
  dVar5 = dVar5 * dVar2;
  dVar6 = dVar6 * dVar3;
  permanent = dVar1 * dVar1 + permanent * permanent;
  dVar1 = (dVar5 - dVar6) * permanent + (dVar8 - local_34) * dVar7 + (local_2c - local_24) * dVar4;
  if (dVar8 < 0.00000000) {
    dVar8 = -dVar8;
  }
  if (local_34 < 0.00000000) {
    local_34 = -local_34;
  }
  if (local_2c < 0.00000000) {
    local_2c = -local_2c;
  }
  if (local_24 < 0.00000000) {
    local_24 = -local_24;
  }
  if (dVar5 < 0.00000000) {
    dVar5 = -dVar5;
  }
  if (dVar6 < 0.00000000) {
    dVar6 = -dVar6;
  }
  permanent = (dVar5 + dVar6) * permanent +
              (local_2c + local_24) * dVar4 + (dVar8 + local_34) * dVar7;
  dVar2 = iccerrboundA * permanent;
  if ((dVar1 <= dVar2) && (-dVar1 <= dVar2)) {
    permanent = incircleadapt(pa,pb,pc,pd,permanent);
    return permanent;
  }
  return dVar1;
}



// WARNING: Removing unreachable block (ram,0x0812d86a)
// WARNING: Removing unreachable block (ram,0x0812d856)
// WARNING: Removing unreachable block (ram,0x0812d842)
// WARNING: Removing unreachable block (ram,0x0812d82c)
// WARNING: Removing unreachable block (ram,0x0812d80c)
// WARNING: Removing unreachable block (ram,0x0812d804)
// WARNING: Removing unreachable block (ram,0x0812d81c)
// WARNING: Removing unreachable block (ram,0x0812d836)
// WARNING: Removing unreachable block (ram,0x0812d84a)
// WARNING: Removing unreachable block (ram,0x0812d862)
// WARNING: Removing unreachable block (ram,0x0812d7f2)
// WARNING: Could not reconcile some variable overlaps

double __regparm3
insphereadapt(double *pa,double *pb,double *pc,double *pd,double *pe,double permanent)

{
  double b;
  double b_00;
  double b_01;
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double b_02;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double b_03;
  double b_04;
  double b_05;
  double b_06;
  double b_07;
  double b_08;
  double b_09;
  double b_10;
  double b_11;
  double dVar12;
  double dVar13;
  double dVar14;
  double dVar15;
  double dVar16;
  double dVar17;
  double dVar18;
  double dVar19;
  double dVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  double dVar27;
  double dVar28;
  double dVar29;
  double dVar30;
  double dVar31;
  double dVar32;
  double dVar33;
  double dVar34;
  double dVar35;
  int elen;
  int flen;
  uint elen_00;
  int elen_01;
  int flen_00;
  int elen_02;
  int elen_03;
  int flen_01;
  int elen_04;
  int flen_02;
  int flen_03;
  int flen_04;
  int flen_05;
  int elen_05;
  double dStack213276;
  double deter [5760];
  double cdedet [3456];
  double cddet_1 [2304];
  double abdet_1 [2304];
  double edet [1152];
  double ddet_1 [1152];
  double cdet_1 [1152];
  double bdet_1 [1152];
  double adet_1 [1152];
  double fin1 [1152];
  double detxy [768];
  double cddet [576];
  double abdet [576];
  double det384z [384];
  double det384y [384];
  double det384x [384];
  double ddet [288];
  double cdet [288];
  double bdet [288];
  double adet [288];
  double temp192 [192];
  double xydet [192];
  double eabc [96];
  double deab [96];
  double cdea [96];
  double bcde [96];
  double abcd [96];
  double zdet [96];
  double ydet [96];
  double xdet [96];
  double temp48b [48];
  double temp48a [48];
  double temp48 [48];
  double eac [24];
  double deb [24];
  double cda [24];
  double bce [24];
  double abd [24];
  double eab [24];
  double dea [24];
  double cde [24];
  double bcd [24];
  double abc [24];
  double temp24 [24];
  double temp16_1 [16];
  double temp16 [16];
  double temp8b_1 [8];
  double temp8a_1 [8];
  double temp8c [8];
  double temp8b [8];
  double temp8a [8];
  double eb [4];
  double da_1 [4];
  double ce [4];
  double bd_1 [4];
  double ac_1 [4];
  double ea [4];
  double de [4];
  double cd_1 [4];
  double bc_1 [4];
  double ab_1 [4];
  double bd [4];
  double ac [4];
  double da [4];
  double cd [4];
  double bc [4];
  double ab [4];
  
  b = *pe;
  b_03 = *pa - b;
  b_04 = *pb - b;
  b_05 = *pc - b;
  b = *pd - b;
  b_00 = pe[1];
  b_06 = pa[1] - b_00;
  b_07 = pb[1] - b_00;
  b_08 = pc[1] - b_00;
  b_00 = pd[1] - b_00;
  b_01 = pe[2];
  b_09 = pa[2] - b_01;
  b_10 = pb[2] - b_01;
  b_11 = pc[2] - b_01;
  b_01 = pd[2] - b_01;
  dVar12 = b_03 * b_07;
  dVar18 = b_03 * splitter - (b_03 * splitter - b_03);
  dVar19 = b_03 - dVar18;
  b_02 = b_07 * splitter - (b_07 * splitter - b_07);
  dVar4 = b_07 - b_02;
  dVar13 = dVar19 * dVar4 - (((dVar12 - dVar18 * b_02) - dVar19 * b_02) - dVar18 * dVar4);
  dVar2 = b_04 * b_06;
  dVar16 = b_04 * splitter - (b_04 * splitter - b_04);
  dVar17 = b_04 - dVar16;
  dVar14 = b_06 * splitter - (b_06 * splitter - b_06);
  dVar15 = b_06 - dVar14;
  dVar1 = dVar17 * dVar15 - (((dVar2 - dVar16 * dVar14) - dVar17 * dVar14) - dVar16 * dVar15);
  dVar3 = dVar13 - dVar1;
  ab[0] = (dVar13 - (dVar3 + (dVar13 - dVar3))) + ((dVar13 - dVar3) - dVar1);
  dVar1 = dVar12 + dVar3;
  dVar12 = (dVar12 - (dVar1 - (dVar1 - dVar12))) + (dVar3 - (dVar1 - dVar12));
  dVar13 = dVar12 - dVar2;
  ab[1] = (dVar12 - (dVar13 + (dVar12 - dVar13))) + ((dVar12 - dVar13) - dVar2);
  dVar32 = dVar1 + dVar13;
  ab[2] = (dVar1 - (dVar32 - (dVar32 - dVar1))) + (dVar13 - (dVar32 - dVar1));
  dVar2 = b_04 * b_08;
  dStack213276 = b_08 * splitter - (b_08 * splitter - b_08);
  dVar11 = b_08 - dStack213276;
  dVar13 = dVar17 * dVar11 -
           (((dVar2 - dVar16 * dStack213276) - dVar17 * dStack213276) - dVar16 * dVar11);
  dVar3 = b_05 * b_07;
  dVar9 = b_05 * splitter - (b_05 * splitter - b_05);
  dVar10 = b_05 - dVar9;
  dVar12 = dVar10 * dVar4 - (((dVar3 - dVar9 * b_02) - dVar10 * b_02) - dVar9 * dVar4);
  dVar1 = dVar13 - dVar12;
  bc[0] = (dVar13 - (dVar1 + (dVar13 - dVar1))) + ((dVar13 - dVar1) - dVar12);
  dVar12 = dVar2 + dVar1;
  dVar1 = (dVar2 - (dVar12 - (dVar12 - dVar2))) + (dVar1 - (dVar12 - dVar2));
  dVar13 = dVar1 - dVar3;
  bc[1] = (dVar1 - (dVar13 + (dVar1 - dVar13))) + ((dVar1 - dVar13) - dVar3);
  dVar31 = dVar12 + dVar13;
  bc[2] = (dVar12 - (dVar31 - (dVar31 - dVar12))) + (dVar13 - (dVar31 - dVar12));
  dVar3 = b_05 * b_00;
  dVar7 = b_00 * splitter - (b_00 * splitter - b_00);
  dVar8 = b_00 - dVar7;
  dVar12 = dVar10 * dVar8 - (((dVar3 - dVar9 * dVar7) - dVar10 * dVar7) - dVar9 * dVar8);
  dVar2 = b * b_08;
  dVar5 = splitter * b - (splitter * b - b);
  dVar6 = b - dVar5;
  dVar13 = dVar11 * dVar6 -
           (((dVar2 - dStack213276 * dVar5) - dVar6 * dStack213276) - dVar11 * dVar5);
  dVar1 = dVar12 - dVar13;
  cd[0] = ((dVar12 - dVar1) - dVar13) + (dVar12 - ((dVar12 - dVar1) + dVar1));
  dVar13 = dVar3 + dVar1;
  dVar1 = (dVar3 - (dVar13 - (dVar13 - dVar3))) + (dVar1 - (dVar13 - dVar3));
  dVar12 = dVar1 - dVar2;
  cd[1] = (dVar1 - (dVar12 + (dVar1 - dVar12))) + ((dVar1 - dVar12) - dVar2);
  dVar30 = dVar13 + dVar12;
  cd[2] = (dVar12 - (dVar30 - dVar13)) + (dVar13 - (dVar30 - (dVar30 - dVar13)));
  dVar2 = b * b_06;
  dVar3 = dVar6 * dVar15 - (((dVar2 - dVar14 * dVar5) - dVar6 * dVar14) - dVar15 * dVar5);
  dVar13 = b_03 * b_00;
  dVar12 = dVar19 * dVar8 - (((dVar13 - dVar18 * dVar7) - dVar19 * dVar7) - dVar18 * dVar8);
  dVar1 = dVar3 - dVar12;
  da[0] = ((dVar3 - dVar1) - dVar12) + (dVar3 - ((dVar3 - dVar1) + dVar1));
  dVar12 = dVar2 + dVar1;
  dVar2 = (dVar2 - (dVar12 - (dVar12 - dVar2))) + (dVar1 - (dVar12 - dVar2));
  dVar1 = dVar2 - dVar13;
  da[1] = (dVar2 - (dVar1 + (dVar2 - dVar1))) + ((dVar2 - dVar1) - dVar13);
  dVar29 = dVar12 + dVar1;
  da[2] = (dVar1 - (dVar29 - dVar12)) + (dVar12 - (dVar29 - (dVar29 - dVar12)));
  dVar12 = b_03 * b_08;
  dVar13 = dVar19 * dVar11 -
           (((dVar12 - dVar18 * dStack213276) - dVar19 * dStack213276) - dVar18 * dVar11);
  dVar2 = b_05 * b_06;
  dVar1 = dVar10 * dVar15 - (((dVar2 - dVar9 * dVar14) - dVar10 * dVar14) - dVar9 * dVar15);
  dVar3 = dVar13 - dVar1;
  ac[0] = ((dVar13 - dVar3) - dVar1) + (dVar13 - ((dVar13 - dVar3) + dVar3));
  dVar13 = dVar12 + dVar3;
  dVar12 = (dVar12 - (dVar13 - (dVar13 - dVar12))) + (dVar3 - (dVar13 - dVar12));
  dVar1 = dVar12 - dVar2;
  ac[1] = (dVar12 - (dVar1 + (dVar12 - dVar1))) + ((dVar12 - dVar1) - dVar2);
  dVar12 = dVar13 + dVar1;
  ac[2] = (dVar1 - (dVar12 - dVar13)) + (dVar13 - (dVar12 - (dVar12 - dVar13)));
  dVar3 = b_04 * b_00;
  dVar2 = dVar17 * dVar8 - (((dVar3 - dVar16 * dVar7) - dVar7 * dVar17) - dVar16 * dVar8);
  dVar7 = b * b_07;
  dVar1 = dVar6 * dVar4 - (((dVar7 - b_02 * dVar5) - dVar6 * b_02) - dVar5 * dVar4);
  dVar13 = dVar2 - dVar1;
  bd[0] = (dVar2 - (dVar13 + (dVar2 - dVar13))) + ((dVar2 - dVar13) - dVar1);
  dVar1 = dVar3 + dVar13;
  dVar13 = (dVar3 - (dVar1 - (dVar1 - dVar3))) + (dVar13 - (dVar1 - dVar3));
  dVar2 = dVar13 - dVar7;
  bd[1] = (dVar13 - (dVar2 + (dVar13 - dVar2))) + ((dVar13 - dVar2) - dVar7);
  dVar13 = dVar1 + dVar2;
  bd[2] = (dVar1 - (dVar13 - (dVar13 - dVar1))) + (dVar2 - (dVar13 - dVar1));
  bd[3] = dVar13;
  ac[3] = dVar12;
  da[3] = dVar29;
  cd[3] = dVar30;
  bc[3] = dVar31;
  ab[3] = dVar32;
  elen = scale_expansion_zeroelim(4,cd,b_10,temp8a);
  flen = scale_expansion_zeroelim(4,bd,-b_11,temp8b);
  elen_00 = scale_expansion_zeroelim(4,bc,b_01,temp8c);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen = fast_expansion_sum_zeroelim(elen,temp8a,flen,temp8b,temp16);
  elen_00 = fast_expansion_sum_zeroelim(dStack213276._0_4_,temp8c,elen,temp16,temp24);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen = scale_expansion_zeroelim(elen_00,temp24,b_03,temp48);
  elen = scale_expansion_zeroelim(elen,temp48,-b_03,xdet);
  flen = scale_expansion_zeroelim(dStack213276._0_4_,temp24,b_06,temp48);
  flen = scale_expansion_zeroelim(flen,temp48,-b_06,ydet);
  elen_01 = scale_expansion_zeroelim(dStack213276._0_4_,temp24,b_09,temp48);
  elen_00 = scale_expansion_zeroelim(elen_01,temp48,-b_09,zdet);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen = fast_expansion_sum_zeroelim(elen,xdet,flen,ydet,xydet);
  elen = fast_expansion_sum_zeroelim(elen,xydet,dStack213276._0_4_,zdet,adet);
  flen = scale_expansion_zeroelim(4,da,b_11,temp8a);
  elen_01 = scale_expansion_zeroelim(4,ac,b_01,temp8b);
  elen_00 = scale_expansion_zeroelim(4,cd,b_09,temp8c);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  flen = fast_expansion_sum_zeroelim(flen,temp8a,elen_01,temp8b,temp16);
  elen_00 = fast_expansion_sum_zeroelim(dStack213276._0_4_,temp8c,flen,temp16,temp24);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  flen = scale_expansion_zeroelim(elen_00,temp24,b_04,temp48);
  flen = scale_expansion_zeroelim(flen,temp48,b_04,xdet);
  elen_01 = scale_expansion_zeroelim(dStack213276._0_4_,temp24,b_07,temp48);
  elen_01 = scale_expansion_zeroelim(elen_01,temp48,b_07,ydet);
  flen_00 = scale_expansion_zeroelim(dStack213276._0_4_,temp24,b_10,temp48);
  elen_00 = scale_expansion_zeroelim(flen_00,temp48,b_10,zdet);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  flen = fast_expansion_sum_zeroelim(flen,xdet,elen_01,ydet,xydet);
  flen = fast_expansion_sum_zeroelim(flen,xydet,dStack213276._0_4_,zdet,bdet);
  elen_01 = scale_expansion_zeroelim(4,ab,b_01,temp8a);
  flen_00 = scale_expansion_zeroelim(4,bd,b_09,temp8b);
  elen_00 = scale_expansion_zeroelim(4,da,b_10,temp8c);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen_01 = fast_expansion_sum_zeroelim(elen_01,temp8a,flen_00,temp8b,temp16);
  elen_00 = fast_expansion_sum_zeroelim(dStack213276._0_4_,temp8c,elen_01,temp16,temp24);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen_01 = scale_expansion_zeroelim(elen_00,temp24,b_05,temp48);
  elen_01 = scale_expansion_zeroelim(elen_01,temp48,-b_05,xdet);
  flen_00 = scale_expansion_zeroelim(dStack213276._0_4_,temp24,b_08,temp48);
  flen_00 = scale_expansion_zeroelim(flen_00,temp48,-b_08,ydet);
  elen_02 = scale_expansion_zeroelim(dStack213276._0_4_,temp24,b_11,temp48);
  elen_00 = scale_expansion_zeroelim(elen_02,temp48,-b_11,zdet);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen_01 = fast_expansion_sum_zeroelim(elen_01,xdet,flen_00,ydet,xydet);
  elen_01 = fast_expansion_sum_zeroelim(elen_01,xydet,dStack213276._0_4_,zdet,cdet);
  flen_00 = scale_expansion_zeroelim(4,bc,b_09,temp8a);
  elen_02 = scale_expansion_zeroelim(4,ac,-b_10,temp8b);
  elen_00 = scale_expansion_zeroelim(4,ab,b_11,temp8c);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  flen_00 = fast_expansion_sum_zeroelim(flen_00,temp8a,elen_02,temp8b,temp16);
  flen_00 = fast_expansion_sum_zeroelim(dStack213276._0_4_,temp8c,flen_00,temp16,temp24);
  elen_02 = scale_expansion_zeroelim(flen_00,temp24,b,temp48);
  elen_02 = scale_expansion_zeroelim(elen_02,temp48,b,xdet);
  elen_03 = scale_expansion_zeroelim(flen_00,temp24,b_00,temp48);
  elen_00 = scale_expansion_zeroelim(elen_03,temp48,b_00,ydet);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  flen_00 = scale_expansion_zeroelim(flen_00,temp24,b_01,temp48);
  flen_00 = scale_expansion_zeroelim(flen_00,temp48,b_01,zdet);
  elen_02 = fast_expansion_sum_zeroelim(elen_02,xdet,dStack213276._0_4_,ydet,xydet);
  flen_00 = fast_expansion_sum_zeroelim(elen_02,xydet,flen_00,zdet,ddet);
  elen_00 = fast_expansion_sum_zeroelim(elen,adet,flen,bdet,abdet);
  dStack213276 = (double)((ulonglong)dStack213276 & 0xffffffff00000000 | (ulonglong)elen_00);
  elen = fast_expansion_sum_zeroelim(elen_01,cdet,flen_00,ddet,cddet);
  elen = fast_expansion_sum_zeroelim(dStack213276._0_4_,abdet,elen,cddet,fin1);
  if (1 < elen) {
    flen = 1;
    do {
      fin1[0] = fin1[0] + fin1[flen];
      flen = flen + 1;
    } while (flen != elen);
  }
  if ((fin1[0] < permanent * isperrboundB) && (-fin1[0] < permanent * isperrboundB)) {
    dVar1 = *pa;
    dVar2 = *pe;
    dVar14 = ((dVar1 - b_03) - dVar2) + (dVar1 - (b_03 + (dVar1 - b_03)));
    dVar3 = pa[1];
    dVar4 = pe[1];
    dVar15 = ((dVar3 - b_06) - dVar4) + (dVar3 - (b_06 + (dVar3 - b_06)));
    b_02 = pa[2];
    dVar5 = pe[2];
    dVar16 = ((b_02 - b_09) - dVar5) + (b_02 - (b_09 + (b_02 - b_09)));
    dVar6 = *pb;
    dVar20 = ((dVar6 - b_04) - dVar2) + (dVar6 - (b_04 + (dVar6 - b_04)));
    dVar7 = pb[1];
    dVar21 = ((dVar7 - b_07) - dVar4) + (dVar7 - (b_07 + (dVar7 - b_07)));
    dVar8 = pb[2] - b_10;
    dVar19 = (dVar8 - dVar5) + (pb[2] - (b_10 + dVar8));
    dVar8 = *pc;
    dVar22 = ((dVar8 - b_05) - dVar2) + (dVar8 - (b_05 + (dVar8 - b_05)));
    dVar9 = pc[1];
    dVar23 = ((dVar9 - b_08) - dVar4) + (dVar9 - (b_08 + (dVar9 - b_08)));
    dVar10 = pc[2] - b_11;
    dVar18 = (dVar10 - dVar5) + (pc[2] - (b_11 + dVar10));
    dVar10 = *pd;
    dVar24 = ((dVar10 - b) - dVar2) + (dVar10 - (b + (dVar10 - b)));
    dVar11 = pd[1];
    dVar25 = ((dVar11 - b_00) - dVar4) + (dVar11 - (b_00 + (dVar11 - b_00)));
    dVar17 = pd[2] - b_01;
    dVar5 = (pd[2] - (b_01 + dVar17)) + (dVar17 - dVar5);
    if ((((dVar14 != 0.00000000) ||
         ((((dVar15 != 0.00000000 || (dVar16 != 0.00000000)) || (dVar20 != 0.00000000)) ||
          ((dVar21 != 0.00000000 || (dVar19 != 0.00000000)))))) || (dVar22 != 0.00000000)) ||
       (((dVar23 != 0.00000000 || (dVar18 != 0.00000000)) ||
        ((dVar24 != 0.00000000 || ((dVar25 != 0.00000000 || (dVar5 != 0.00000000)))))))) {
      dVar17 = -fin1[0];
      if (0.00000000 <= fin1[0]) {
        dVar17 = fin1[0];
      }
      dVar33 = dVar17 * resulterrbound + permanent * isperrboundC;
      dVar17 = (b_07 * dVar14 + b_03 * dVar21) - (b_04 * dVar15 + b_06 * dVar20);
      dVar26 = (b_08 * dVar20 + b_04 * dVar23) - (b_05 * dVar21 + b_07 * dVar22);
      dVar34 = (b_00 * dVar22 + b_05 * dVar25) - (b * dVar23 + b_08 * dVar24);
      dVar27 = (b_06 * dVar24 + b * dVar15) - (b_03 * dVar25 + b_00 * dVar14);
      dVar35 = (b_08 * dVar14 + b_03 * dVar23) - (b_05 * dVar15 + b_06 * dVar22);
      dVar28 = (b_00 * dVar20 + b_04 * dVar25) - (b * dVar21 + b_07 * dVar24);
      dVar14 = ((b_11 * dVar32 + (b_09 * dVar31 - b_10 * dVar12)) *
                (b_01 * dVar5 + b_00 * dVar25 + b * dVar24) +
               (b_09 * dVar30 + b_01 * dVar12 + b_11 * dVar29) *
               (b_10 * dVar19 + b_07 * dVar21 + b_04 * dVar20)) -
               ((b_01 * dVar31 + (b_10 * dVar30 - b_11 * dVar13)) *
                (b_09 * dVar16 + b_06 * dVar15 + b_03 * dVar14) +
               (b_11 * dVar18 + b_08 * dVar23 + b_05 * dVar22) *
               (b_10 * dVar29 + dVar13 * b_09 + b_01 * dVar32));
      fin1[0] = fin1[0] + dVar14 + dVar14 +
                          (((dVar16 * dVar30 + dVar5 * dVar12 + dVar18 * dVar29 +
                            b_09 * dVar34 + b_01 * dVar35 + b_11 * dVar27) *
                            (b_10 * b_10 + b_07 * b_07 + b_04 * b_04) +
                           (b_01 * b_01 + b_00 * b_00 + b * b) *
                           (dVar18 * dVar32 + (dVar16 * dVar31 - dVar19 * dVar12) +
                           b_11 * dVar17 + (b_09 * dVar26 - dVar35 * b_10))) -
                          ((dVar19 * dVar29 + dVar16 * dVar13 + dVar5 * dVar32 +
                           b_10 * dVar27 + b_09 * dVar28 + b_01 * dVar17) *
                           (b_11 * b_11 + b_08 * b_08 + b_05 * b_05) +
                          (dVar5 * dVar31 + (dVar19 * dVar30 - dVar18 * dVar13) +
                          b_01 * dVar26 + (dVar34 * b_10 - b_11 * dVar28)) *
                          (b_09 * b_09 + b_06 * b_06 + b_03 * b_03)));
      if ((fin1[0] < dVar33) && (-fin1[0] < dVar33)) {
        b = dVar1 * dVar7;
        dVar18 = dVar1 * splitter - (dVar1 * splitter - dVar1);
        dVar19 = dVar1 - dVar18;
        b_06 = dVar7 * splitter - (dVar7 * splitter - dVar7);
        b_05 = dVar7 - b_06;
        b_01 = dVar19 * b_05 - (((b - dVar18 * b_06) - dVar19 * b_06) - dVar18 * b_05);
        b_03 = dVar3 * dVar6;
        dVar16 = dVar6 * splitter - (dVar6 * splitter - dVar6);
        dVar17 = dVar6 - dVar16;
        dVar14 = dVar3 * splitter - (dVar3 * splitter - dVar3);
        dVar15 = dVar3 - dVar14;
        b_00 = dVar17 * dVar15 - (((b_03 - dVar16 * dVar14) - dVar17 * dVar14) - dVar16 * dVar15);
        b_04 = b_01 - b_00;
        ab_1[0] = ((b_01 - b_04) - b_00) + (b_01 - ((b_01 - b_04) + b_04));
        b_00 = b + b_04;
        b = (b_04 - (b_00 - b)) + (b - (b_00 - (b_00 - b)));
        b_01 = b - b_03;
        ab_1[1] = ((b - b_01) - b_03) + (b - ((b - b_01) + b_01));
        ab_1[3] = b_00 + b_01;
        ab_1[2] = (b_00 - (ab_1[3] - (ab_1[3] - b_00))) + (b_01 - (ab_1[3] - b_00));
        b_01 = dVar6 * dVar9;
        dVar31 = dVar9 * splitter - (dVar9 * splitter - dVar9);
        dStack213276 = dVar9 - dVar31;
        b_03 = dVar17 * dStack213276 -
               (((b_01 - dVar16 * dVar31) - dVar17 * dVar31) - dVar16 * dStack213276);
        b_04 = dVar8 * dVar7;
        dVar29 = dVar8 * splitter - (dVar8 * splitter - dVar8);
        dVar30 = dVar8 - dVar29;
        b = dVar30 * b_05 - (((b_04 - dVar29 * b_06) - dVar30 * b_06) - dVar29 * b_05);
        b_00 = b_03 - b;
        bc_1[0] = ((b_03 - b_00) - b) + (b_03 - ((b_03 - b_00) + b_00));
        b = b_01 + b_00;
        b_01 = (b_00 - (b - b_01)) + (b_01 - (b - (b - b_01)));
        b_00 = b_01 - b_04;
        bc_1[1] = ((b_01 - b_00) - b_04) + (b_01 - ((b_01 - b_00) + b_00));
        bc_1[3] = b + b_00;
        bc_1[2] = (b - (bc_1[3] - (bc_1[3] - b))) + (b_00 - (bc_1[3] - b));
        b_01 = dVar8 * dVar11;
        dVar5 = dVar11 * splitter - (dVar11 * splitter - dVar11);
        dVar13 = dVar11 - dVar5;
        b_03 = dVar30 * dVar13 - (((b_01 - dVar29 * dVar5) - dVar30 * dVar5) - dVar29 * dVar13);
        b_04 = dVar10 * dVar9;
        b_11 = dVar10 * splitter - (dVar10 * splitter - dVar10);
        dVar12 = dVar10 - b_11;
        b = dVar12 * dStack213276 -
            (((b_04 - b_11 * dVar31) - dVar12 * dVar31) - b_11 * dStack213276);
        b_00 = b_03 - b;
        cd_1[0] = ((b_03 - b_00) - b) + (b_03 - ((b_03 - b_00) + b_00));
        b = b_01 + b_00;
        b_01 = (b_00 - (b - b_01)) + (b_01 - (b - (b - b_01)));
        b_00 = b_01 - b_04;
        cd_1[1] = ((b_01 - b_00) - b_04) + (b_01 - ((b_01 - b_00) + b_00));
        cd_1[3] = b + b_00;
        cd_1[2] = (b - (cd_1[3] - (cd_1[3] - b))) + (b_00 - (cd_1[3] - b));
        b_04 = dVar10 * dVar4;
        b_09 = dVar4 * splitter - (dVar4 * splitter - dVar4);
        b_10 = dVar4 - b_09;
        b = dVar12 * b_10 - (((b_04 - b_11 * b_09) - dVar12 * b_09) - b_11 * b_10);
        b_03 = dVar2 * dVar11;
        b_07 = splitter * dVar2 - (splitter * dVar2 - dVar2);
        b_08 = dVar2 - b_07;
        b_01 = dVar13 * b_08 - (((b_03 - dVar5 * b_07) - b_08 * dVar5) - dVar13 * b_07);
        b_00 = b - b_01;
        de[0] = ((b - b_00) - b_01) + (b - ((b - b_00) + b_00));
        b_01 = b_04 + b_00;
        b_00 = (b_00 - (b_01 - b_04)) + (b_04 - (b_01 - (b_01 - b_04)));
        b = b_00 - b_03;
        de[1] = ((b_00 - b) - b_03) + (b_00 - ((b_00 - b) + b));
        de[3] = b_01 + b;
        de[2] = (b_01 - (de[3] - (de[3] - b_01))) + (b - (de[3] - b_01));
        b_03 = dVar2 * dVar3;
        b_04 = b_08 * dVar15 - (((b_03 - dVar14 * b_07) - b_08 * dVar14) - dVar15 * b_07);
        b_01 = dVar1 * dVar4;
        b = dVar19 * b_10 - (((b_01 - dVar18 * b_09) - dVar19 * b_09) - dVar18 * b_10);
        b_00 = b_04 - b;
        ea[0] = ((b_04 - b_00) - b) + (b_04 - ((b_04 - b_00) + b_00));
        b = b_03 + b_00;
        b_03 = (b_00 - (b - b_03)) + (b_03 - (b - (b - b_03)));
        b_00 = b_03 - b_01;
        ea[1] = ((b_03 - b_00) - b_01) + (b_03 - ((b_03 - b_00) + b_00));
        ea[3] = b + b_00;
        ea[2] = (b - (ea[3] - (ea[3] - b))) + (b_00 - (ea[3] - b));
        b = dVar1 * dVar9;
        b_01 = dVar19 * dStack213276 -
               (((b - dVar18 * dVar31) - dVar19 * dVar31) - dVar18 * dStack213276);
        b_03 = dVar8 * dVar3;
        b_00 = dVar30 * dVar15 - (((b_03 - dVar29 * dVar14) - dVar30 * dVar14) - dVar29 * dVar15);
        b_04 = b_01 - b_00;
        ac_1[0] = ((b_01 - b_04) - b_00) + (b_01 - ((b_01 - b_04) + b_04));
        b_01 = b + b_04;
        b = (b_04 - (b_01 - b)) + (b - (b_01 - (b_01 - b)));
        b_00 = b - b_03;
        ac_1[1] = ((b - b_00) - b_03) + (b - ((b - b_00) + b_00));
        ac_1[3] = b_01 + b_00;
        ac_1[2] = (b_01 - (ac_1[3] - (ac_1[3] - b_01))) + (b_00 - (ac_1[3] - b_01));
        b = dVar6 * dVar11;
        b_01 = dVar17 * dVar13 - (((b - dVar16 * dVar5) - dVar17 * dVar5) - dVar16 * dVar13);
        b_03 = dVar10 * dVar7;
        b_00 = dVar12 * b_05 - (((b_03 - b_11 * b_06) - dVar12 * b_06) - b_11 * b_05);
        b_04 = b_01 - b_00;
        bd_1[0] = ((b_01 - b_04) - b_00) + (b_01 - ((b_01 - b_04) + b_04));
        b_01 = b + b_04;
        b = (b_04 - (b_01 - b)) + (b - (b_01 - (b_01 - b)));
        b_00 = b - b_03;
        bd_1[1] = ((b - b_00) - b_03) + (b - ((b - b_00) + b_00));
        bd_1[3] = b_01 + b_00;
        bd_1[2] = (b_01 - (bd_1[3] - (bd_1[3] - b_01))) + (b_00 - (bd_1[3] - b_01));
        dVar8 = dVar8 * dVar4;
        b = dVar30 * b_10 - (((dVar8 - dVar29 * b_09) - dVar30 * b_09) - dVar29 * b_10);
        dVar9 = dVar2 * dVar9;
        b_01 = b_08 * dStack213276 -
               (((dVar9 - dVar31 * b_07) - b_08 * dVar31) - dStack213276 * b_07);
        b_00 = b - b_01;
        ce[0] = ((b - b_00) - b_01) + (b - ((b - b_00) + b_00));
        b_01 = dVar8 + b_00;
        b_00 = (b_00 - (b_01 - dVar8)) + (dVar8 - (b_01 - (b_01 - dVar8)));
        b = b_00 - dVar9;
        ce[1] = ((b_00 - b) - dVar9) + (b_00 - ((b_00 - b) + b));
        ce[3] = b_01 + b;
        ce[2] = (b_01 - (ce[3] - (ce[3] - b_01))) + (b - (ce[3] - b_01));
        dVar10 = dVar10 * dVar3;
        b_00 = dVar12 * dVar15 - (((dVar10 - b_11 * dVar14) - dVar12 * dVar14) - b_11 * dVar15);
        dVar1 = dVar1 * dVar11;
        b = dVar19 * dVar13 - (((dVar1 - dVar18 * dVar5) - dVar19 * dVar5) - dVar18 * dVar13);
        b_03 = b_00 - b;
        da_1[0] = ((b_00 - b_03) - b) + (b_00 - ((b_00 - b_03) + b_03));
        b_01 = dVar10 + b_03;
        b = (b_03 - (b_01 - dVar10)) + (dVar10 - (b_01 - (b_01 - dVar10)));
        b_00 = b - dVar1;
        da_1[1] = ((b - b_00) - dVar1) + (b - ((b - b_00) + b_00));
        da_1[3] = b_01 + b_00;
        da_1[2] = (b_01 - (da_1[3] - (da_1[3] - b_01))) + (b_00 - (da_1[3] - b_01));
        dVar2 = dVar2 * dVar7;
        b = b_08 * b_05 - (((dVar2 - b_06 * b_07) - b_08 * b_06) - b_07 * b_05);
        dVar6 = dVar6 * dVar4;
        b_01 = dVar17 * b_10 - (((dVar6 - dVar16 * b_09) - b_09 * dVar17) - dVar16 * b_10);
        b_00 = b - b_01;
        eb[0] = ((b - b_00) - b_01) + (b - ((b - b_00) + b_00));
        b_01 = dVar2 + b_00;
        b_00 = (b_00 - (b_01 - dVar2)) + (dVar2 - (b_01 - (b_01 - dVar2)));
        b = b_00 - dVar6;
        eb[1] = ((b_00 - b) - dVar6) + (b_00 - ((b_00 - b) + b));
        eb[3] = b_01 + b;
        eb[2] = (b - (eb[3] - b_01)) + (b_01 - (eb[3] - (eb[3] - b_01)));
        elen = scale_expansion_zeroelim(4,bc_1,b_02,temp8a_1);
        flen = scale_expansion_zeroelim(4,ac_1,-pb[2],temp8b_1);
        elen = fast_expansion_sum_zeroelim(elen,temp8a_1,flen,temp8b_1,temp16_1);
        flen = scale_expansion_zeroelim(4,ab_1,pc[2],temp8a_1);
        elen = fast_expansion_sum_zeroelim(flen,temp8a_1,elen,temp16_1,abc);
        flen = scale_expansion_zeroelim(4,cd_1,pb[2],temp8a_1);
        elen_01 = scale_expansion_zeroelim(4,bd_1,-pc[2],temp8b_1);
        flen = fast_expansion_sum_zeroelim(flen,temp8a_1,elen_01,temp8b_1,temp16_1);
        elen_01 = scale_expansion_zeroelim(4,bc_1,pd[2],temp8a_1);
        flen = fast_expansion_sum_zeroelim(elen_01,temp8a_1,flen,temp16_1,bcd);
        elen_01 = scale_expansion_zeroelim(4,de,pc[2],temp8a_1);
        flen_00 = scale_expansion_zeroelim(4,ce,-pd[2],temp8b_1);
        elen_01 = fast_expansion_sum_zeroelim(elen_01,temp8a_1,flen_00,temp8b_1,temp16_1);
        flen_00 = scale_expansion_zeroelim(4,cd_1,pe[2],temp8a_1);
        elen_01 = fast_expansion_sum_zeroelim(flen_00,temp8a_1,elen_01,temp16_1,cde);
        flen_00 = scale_expansion_zeroelim(4,ea,pd[2],temp8a_1);
        elen_02 = scale_expansion_zeroelim(4,da_1,-pe[2],temp8b_1);
        flen_00 = fast_expansion_sum_zeroelim(flen_00,temp8a_1,elen_02,temp8b_1,temp16_1);
        elen_02 = scale_expansion_zeroelim(4,de,pa[2],temp8a_1);
        flen_00 = fast_expansion_sum_zeroelim(elen_02,temp8a_1,flen_00,temp16_1,dea);
        elen_02 = scale_expansion_zeroelim(4,ab_1,pe[2],temp8a_1);
        elen_03 = scale_expansion_zeroelim(4,eb,-pa[2],temp8b_1);
        elen_02 = fast_expansion_sum_zeroelim(elen_02,temp8a_1,elen_03,temp8b_1,temp16_1);
        elen_03 = scale_expansion_zeroelim(4,ea,pb[2],temp8a_1);
        elen_02 = fast_expansion_sum_zeroelim(elen_03,temp8a_1,elen_02,temp16_1,eab);
        elen_03 = scale_expansion_zeroelim(4,bd_1,pa[2],temp8a_1);
        flen_01 = scale_expansion_zeroelim(4,da_1,pb[2],temp8b_1);
        elen_03 = fast_expansion_sum_zeroelim(elen_03,temp8a_1,flen_01,temp8b_1,temp16_1);
        flen_01 = scale_expansion_zeroelim(4,ab_1,pd[2],temp8a_1);
        elen_03 = fast_expansion_sum_zeroelim(flen_01,temp8a_1,elen_03,temp16_1,abd);
        flen_01 = scale_expansion_zeroelim(4,ce,pb[2],temp8a_1);
        elen_04 = scale_expansion_zeroelim(4,eb,pc[2],temp8b_1);
        flen_01 = fast_expansion_sum_zeroelim(flen_01,temp8a_1,elen_04,temp8b_1,temp16_1);
        elen_04 = scale_expansion_zeroelim(4,bc_1,pe[2],temp8a_1);
        flen_01 = fast_expansion_sum_zeroelim(elen_04,temp8a_1,flen_01,temp16_1,bce);
        elen_04 = scale_expansion_zeroelim(4,da_1,pc[2],temp8a_1);
        flen_02 = scale_expansion_zeroelim(4,ac_1,pd[2],temp8b_1);
        elen_04 = fast_expansion_sum_zeroelim(elen_04,temp8a_1,flen_02,temp8b_1,temp16_1);
        flen_02 = scale_expansion_zeroelim(4,cd_1,pa[2],temp8a_1);
        elen_04 = fast_expansion_sum_zeroelim(flen_02,temp8a_1,elen_04,temp16_1,cda);
        flen_02 = scale_expansion_zeroelim(4,eb,pd[2],temp8a_1);
        flen_03 = scale_expansion_zeroelim(4,bd_1,pe[2],temp8b_1);
        flen_02 = fast_expansion_sum_zeroelim(flen_02,temp8a_1,flen_03,temp8b_1,temp16_1);
        flen_03 = scale_expansion_zeroelim(4,de,pb[2],temp8a_1);
        flen_02 = fast_expansion_sum_zeroelim(flen_03,temp8a_1,flen_02,temp16_1,deb);
        flen_03 = scale_expansion_zeroelim(4,ac_1,pe[2],temp8a_1);
        flen_04 = scale_expansion_zeroelim(4,ce,pa[2],temp8b_1);
        flen_03 = fast_expansion_sum_zeroelim(flen_03,temp8a_1,flen_04,temp8b_1,temp16_1);
        flen_04 = scale_expansion_zeroelim(4,ea,pc[2],temp8a_1);
        flen_03 = fast_expansion_sum_zeroelim(flen_04,temp8a_1,flen_03,temp16_1,eac);
        flen_04 = fast_expansion_sum_zeroelim(elen_01,cde,flen_01,bce,temp48a);
        flen_05 = fast_expansion_sum_zeroelim(flen_02,deb,flen,bcd,temp48b);
        if (0 < flen_05) {
          elen_05 = 0;
          do {
            temp48b[elen_05] = -temp48b[elen_05];
            elen_05 = elen_05 + 1;
          } while (elen_05 != flen_05);
        }
        flen_04 = fast_expansion_sum_zeroelim(flen_04,temp48a,flen_05,temp48b,bcde);
        flen_05 = scale_expansion_zeroelim(flen_04,bcde,*pa,temp192);
        flen_05 = scale_expansion_zeroelim(flen_05,temp192,*pa,det384x);
        elen_05 = scale_expansion_zeroelim(flen_04,bcde,pa[1],temp192);
        elen_05 = scale_expansion_zeroelim(elen_05,temp192,pa[1],det384y);
        flen_04 = scale_expansion_zeroelim(flen_04,bcde,pa[2],temp192);
        flen_04 = scale_expansion_zeroelim(flen_04,temp192,pa[2],det384z);
        flen_05 = fast_expansion_sum_zeroelim(flen_05,det384x,elen_05,det384y,detxy);
        flen_04 = fast_expansion_sum_zeroelim(flen_05,detxy,flen_04,det384z,adet_1);
        flen_05 = fast_expansion_sum_zeroelim(flen_00,dea,elen_04,cda,temp48a);
        elen_01 = fast_expansion_sum_zeroelim(flen_03,eac,elen_01,cde,temp48b);
        if (0 < elen_01) {
          elen_05 = 0;
          do {
            temp48b[elen_05] = -temp48b[elen_05];
            elen_05 = elen_05 + 1;
          } while (elen_05 != elen_01);
        }
        elen_01 = fast_expansion_sum_zeroelim(flen_05,temp48a,elen_01,temp48b,cdea);
        flen_05 = scale_expansion_zeroelim(elen_01,cdea,*pb,temp192);
        flen_05 = scale_expansion_zeroelim(flen_05,temp192,*pb,det384x);
        elen_05 = scale_expansion_zeroelim(elen_01,cdea,pb[1],temp192);
        elen_05 = scale_expansion_zeroelim(elen_05,temp192,pb[1],det384y);
        elen_01 = scale_expansion_zeroelim(elen_01,cdea,pb[2],temp192);
        elen_01 = scale_expansion_zeroelim(elen_01,temp192,pb[2],det384z);
        flen_05 = fast_expansion_sum_zeroelim(flen_05,det384x,elen_05,det384y,detxy);
        elen_01 = fast_expansion_sum_zeroelim(flen_05,detxy,elen_01,det384z,bdet_1);
        flen_02 = fast_expansion_sum_zeroelim(elen_02,eab,flen_02,deb,temp48a);
        flen_00 = fast_expansion_sum_zeroelim(elen_03,abd,flen_00,dea,temp48b);
        if (0 < flen_00) {
          flen_05 = 0;
          do {
            temp48b[flen_05] = -temp48b[flen_05];
            flen_05 = flen_05 + 1;
          } while (flen_05 != flen_00);
        }
        flen_00 = fast_expansion_sum_zeroelim(flen_02,temp48a,flen_00,temp48b,deab);
        flen_02 = scale_expansion_zeroelim(flen_00,deab,*pc,temp192);
        flen_02 = scale_expansion_zeroelim(flen_02,temp192,*pc,det384x);
        flen_05 = scale_expansion_zeroelim(flen_00,deab,pc[1],temp192);
        flen_05 = scale_expansion_zeroelim(flen_05,temp192,pc[1],det384y);
        flen_00 = scale_expansion_zeroelim(flen_00,deab,pc[2],temp192);
        flen_00 = scale_expansion_zeroelim(flen_00,temp192,pc[2],det384z);
        flen_02 = fast_expansion_sum_zeroelim(flen_02,det384x,flen_05,det384y,detxy);
        flen_00 = fast_expansion_sum_zeroelim(flen_02,detxy,flen_00,det384z,cdet_1);
        flen_02 = fast_expansion_sum_zeroelim(elen,abc,flen_03,eac,temp48a);
        elen_02 = fast_expansion_sum_zeroelim(flen_01,bce,elen_02,eab,temp48b);
        if (0 < elen_02) {
          flen_01 = 0;
          do {
            temp48b[flen_01] = -temp48b[flen_01];
            flen_01 = flen_01 + 1;
          } while (flen_01 != elen_02);
        }
        elen_02 = fast_expansion_sum_zeroelim(flen_02,temp48a,elen_02,temp48b,eabc);
        flen_01 = scale_expansion_zeroelim(elen_02,eabc,*pd,temp192);
        flen_01 = scale_expansion_zeroelim(flen_01,temp192,*pd,det384x);
        flen_02 = scale_expansion_zeroelim(elen_02,eabc,pd[1],temp192);
        flen_02 = scale_expansion_zeroelim(flen_02,temp192,pd[1],det384y);
        elen_02 = scale_expansion_zeroelim(elen_02,eabc,pd[2],temp192);
        elen_02 = scale_expansion_zeroelim(elen_02,temp192,pd[2],det384z);
        flen_01 = fast_expansion_sum_zeroelim(flen_01,det384x,flen_02,det384y,detxy);
        elen_02 = fast_expansion_sum_zeroelim(flen_01,detxy,elen_02,det384z,ddet_1);
        flen = fast_expansion_sum_zeroelim(flen,bcd,elen_03,abd,temp48a);
        elen = fast_expansion_sum_zeroelim(elen_04,cda,elen,abc,temp48b);
        if (0 < elen) {
          elen_03 = 0;
          do {
            temp48b[elen_03] = -temp48b[elen_03];
            elen_03 = elen_03 + 1;
          } while (elen_03 != elen);
        }
        elen = fast_expansion_sum_zeroelim(flen,temp48a,elen,temp48b,abcd);
        flen = scale_expansion_zeroelim(elen,abcd,*pe,temp192);
        flen = scale_expansion_zeroelim(flen,temp192,*pe,det384x);
        elen_03 = scale_expansion_zeroelim(elen,abcd,pe[1],temp192);
        elen_03 = scale_expansion_zeroelim(elen_03,temp192,pe[1],det384y);
        elen = scale_expansion_zeroelim(elen,abcd,pe[2],temp192);
        elen = scale_expansion_zeroelim(elen,temp192,pe[2],det384z);
        flen = fast_expansion_sum_zeroelim(flen,det384x,elen_03,det384y,detxy);
        elen = fast_expansion_sum_zeroelim(flen,detxy,elen,det384z,edet);
        flen = fast_expansion_sum_zeroelim(flen_04,adet_1,elen_01,bdet_1,abdet_1);
        elen_01 = fast_expansion_sum_zeroelim(flen_00,cdet_1,elen_02,ddet_1,cddet_1);
        elen = fast_expansion_sum_zeroelim(elen_01,cddet_1,elen,edet,cdedet);
        elen = fast_expansion_sum_zeroelim(flen,abdet_1,elen,cdedet,deter);
        fin1[0] = (&dStack213276)[elen];
      }
    }
  }
  return fin1[0];
}



double insphere(double *pa,double *pb,double *pc,double *pd,double *pe)

{
  double dVar1;
  double permanent;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double local_d4;
  double local_6c;
  double local_64;
  double local_5c;
  double local_54;
  double local_4c;
  double local_3c;
  double local_34;
  double local_2c;
  double local_24;
  double local_14;
  
  dVar12 = *pe;
  permanent = *pa - dVar12;
  dVar2 = *pb - dVar12;
  dVar3 = *pc - dVar12;
  dVar12 = *pd - dVar12;
  dVar1 = pe[1];
  dVar5 = pa[1] - dVar1;
  dVar6 = pb[1] - dVar1;
  dVar7 = pc[1] - dVar1;
  dVar1 = pd[1] - dVar1;
  local_24 = pa[2] - pe[2];
  dVar10 = pb[2] - pe[2];
  dVar11 = pc[2] - pe[2];
  dVar8 = pd[2] - pe[2];
  local_14 = permanent * dVar6;
  local_6c = dVar2 * dVar5;
  local_34 = dVar7 * dVar2;
  local_64 = dVar3 * dVar6;
  local_d4 = dVar1 * dVar3;
  dVar9 = dVar12 * dVar7;
  local_2c = dVar12 * dVar5;
  local_5c = dVar1 * permanent;
  local_54 = dVar7 * permanent;
  local_4c = dVar3 * dVar5;
  dVar4 = dVar1 * dVar2;
  local_3c = dVar12 * dVar6;
  dVar5 = local_24 * local_24 + dVar5 * dVar5 + permanent * permanent;
  dVar2 = dVar10 * dVar10 + dVar6 * dVar6 + dVar2 * dVar2;
  permanent = dVar11 * dVar11 + dVar7 * dVar7 + dVar3 * dVar3;
  dVar12 = dVar8 * dVar8 + dVar1 * dVar1 + dVar12 * dVar12;
  dVar1 = (((local_d4 - dVar9) * local_24 +
           dVar8 * (local_54 - local_4c) + (local_2c - local_5c) * dVar11) * dVar2 -
          (dVar8 * (local_34 - local_64) +
          ((local_d4 - dVar9) * dVar10 - (dVar4 - local_3c) * dVar11)) * dVar5) +
          (((local_14 - local_6c) * dVar11 +
           ((local_34 - local_64) * local_24 - (local_54 - local_4c) * dVar10)) * dVar12 -
          ((local_2c - local_5c) * dVar10 +
          (dVar4 - local_3c) * local_24 + dVar8 * (local_14 - local_6c)) * permanent);
  if (local_24 < 0.00000000) {
    local_24 = -local_24;
  }
  if (dVar10 < 0.00000000) {
    dVar10 = -dVar10;
  }
  if (dVar11 < 0.00000000) {
    dVar11 = -dVar11;
  }
  if (dVar8 < 0.00000000) {
    dVar8 = -dVar8;
  }
  if (local_14 < 0.00000000) {
    local_14 = -local_14;
  }
  if (local_6c < 0.00000000) {
    local_6c = -local_6c;
  }
  if (local_34 < 0.00000000) {
    local_34 = -local_34;
  }
  if (local_64 < 0.00000000) {
    local_64 = -local_64;
  }
  if (local_d4 < 0.00000000) {
    local_d4 = -local_d4;
  }
  if (dVar9 < 0.00000000) {
    dVar9 = -dVar9;
  }
  if (local_2c < 0.00000000) {
    local_2c = -local_2c;
  }
  if (local_5c < 0.00000000) {
    local_5c = -local_5c;
  }
  if (local_54 < 0.00000000) {
    local_54 = -local_54;
  }
  if (local_4c < 0.00000000) {
    local_4c = -local_4c;
  }
  if (dVar4 < 0.00000000) {
    dVar4 = -dVar4;
  }
  if (local_3c < 0.00000000) {
    local_3c = -local_3c;
  }
  permanent = (dVar11 * (local_14 + local_6c) +
              dVar10 * (local_54 + local_4c) + local_24 * (local_34 + local_64)) * dVar12 +
              ((local_2c + local_5c) * dVar10 +
              local_24 * (dVar4 + local_3c) + dVar8 * (local_14 + local_6c)) * permanent +
              (local_24 * (dVar9 + local_d4) +
              dVar8 * (local_54 + local_4c) + (local_2c + local_5c) * dVar11) * dVar2 +
              ((local_34 + local_64) * dVar8 +
              (dVar4 + local_3c) * dVar11 + (dVar9 + local_d4) * dVar10) * dVar5;
  dVar12 = isperrboundA * permanent;
  if ((dVar1 <= dVar12) && (-dVar1 <= dVar12)) {
    dVar12 = insphereadapt(pa,pb,pc,pd,pe,permanent);
    return dVar12;
  }
  return dVar1;
}



void __regparm3 sift_down(GtsEHeap *heap,guint i)

{
  double dVar1;
  double dVar2;
  gpointer *ppvVar3;
  uint uVar4;
  gpointer pvVar5;
  uint uVar6;
  gpointer pvVar7;
  gpointer pvVar8;
  uint uVar9;
  uint uVar10;
  
  uVar9 = i * 2;
  uVar10 = uVar9 + 1;
  ppvVar3 = heap->elts->pdata;
  uVar4 = heap->elts->len;
  pvVar8 = (gpointer)0x0;
  if (uVar9 <= uVar4) {
    pvVar8 = ppvVar3[i * 2 + -1];
  }
  pvVar7 = (gpointer)0x0;
  if (uVar10 <= uVar4) {
    pvVar7 = ppvVar3[i * 2];
  }
  pvVar5 = ppvVar3[i - 1];
  dVar1 = *(double *)((int)pvVar5 + 4);
  while( true ) {
    if (pvVar8 == (gpointer)0x0) {
      return;
    }
    uVar6 = uVar9;
    if (pvVar7 == (gpointer)0x0) {
      dVar2 = *(double *)((int)pvVar8 + 4);
    }
    else {
      dVar2 = *(double *)((int)pvVar8 + 4);
      if (*(double *)((int)pvVar7 + 4) <= dVar2) {
        pvVar8 = pvVar7;
        uVar6 = uVar10;
        dVar2 = *(double *)((int)pvVar7 + 4);
      }
    }
    if (dVar1 <= dVar2) break;
    uVar9 = uVar6 * 2;
    *(uint *)((int)pvVar8 + 0xc) = i;
    uVar10 = uVar9 + 1;
    ppvVar3[i - 1] = pvVar8;
    pvVar8 = (gpointer)0x0;
    ppvVar3[uVar6 - 1] = pvVar5;
    *(uint *)((int)pvVar5 + 0xc) = uVar6;
    if (uVar9 <= uVar4) {
      pvVar8 = ppvVar3[uVar6 * 2 + -1];
    }
    pvVar7 = (gpointer)0x0;
    i = uVar6;
    if (uVar10 <= uVar4) {
      pvVar7 = ppvVar3[uVar6 * 2];
    }
  }
  return;
}



void gts_eheap_randomized(GtsEHeap *heap,gboolean randomized)

{
  char "gts_eheap_randomized" [21];
  
  if (heap != (GtsEHeap *)0x0) {
    heap->randomized = randomized;
    return;
  }
  g_return_if_fail_warning(0,"gts_eheap_randomized",0x816106c);
  return;
}



float10 gts_eheap_key(int heap)

{
  char "gts_eheap_key" [14];
  unkbyte10 Var1;
  
  if (heap == 0) {
    g_return_if_fail_warning(0,"gts_eheap_key",0x816106c);
    return (float10)0;
  }
  if (*(code **)(heap + 4) != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0812fb51. Too many branches
                    // WARNING: Treating indirect jump as call
    Var1 = (**(code **)(heap + 4))();
    return (float10)Var1;
  }
  g_return_if_fail_warning(0,0x8161101,"heap->func != NULL");
  return (float10)0;
}



guint gts_eheap_size(GtsEHeap *heap)

{
  char "gts_eheap_size" [15];
  
  if (heap != (GtsEHeap *)0x0) {
    return heap->elts->len;
  }
  g_return_if_fail_warning(0,"gts_eheap_size",0x816106c);
  return 0;
}



void gts_eheap_freeze(GtsEHeap *heap)

{
  char "gts_eheap_freeze" [17];
  
  if (heap != (GtsEHeap *)0x0) {
    heap->frozen = 1;
    return;
  }
  g_return_if_fail_warning(0,"gts_eheap_freeze",0x816106c);
  return;
}



void gts_eheap_foreach(GtsEHeap *heap,GFunc *func,gpointer data)

{
  gpointer *ppvVar1;
  GPtrArray *pGVar2;
  uint uVar3;
  
  if ((heap != (GtsEHeap *)0x0) && (func != (GFunc *)0x0)) {
    pGVar2 = heap->elts;
    if (pGVar2->len != 0) {
      uVar3 = 0;
      do {
        ppvVar1 = pGVar2->pdata + uVar3;
        uVar3 = uVar3 + 1;
        (*func)(*(gpointer *)*ppvVar1,data);
      } while (uVar3 <= pGVar2->len && pGVar2->len != uVar3);
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



void gts_eheap_thaw(GtsEHeap *heap)

{
  char "gts_eheap_thaw" [15];
  guint i;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_thaw",0x816106c);
    return;
  }
  if (heap->frozen != 0) {
    i = heap->elts->len >> 1;
    while (i != 0) {
      sift_down(heap,i);
      i = i - 1;
    }
    heap->frozen = 0;
  }
  return;
}



void gts_eheap_update(GtsEHeap *heap)

{
  uint uVar1;
  gpointer *ppvVar2;
  gpointer pvVar3;
  GtsKeyFunc *pGVar4;
  gpointer *ppvVar5;
  char "gts_eheap_update" [17];
  uint uVar6;
  float10 fVar7;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,"gts_eheap_update",0x816106c);
  }
  else {
    if (heap->func != (GtsKeyFunc *)0x0) {
      heap->frozen = 1;
      uVar1 = heap->elts->len;
      ppvVar2 = heap->elts->pdata;
      pvVar3 = heap->data;
      pGVar4 = heap->func;
      if (uVar1 != 0) {
        uVar6 = 0;
        do {
          ppvVar5 = (gpointer *)ppvVar2[uVar6];
          uVar6 = uVar6 + 1;
          fVar7 = (float10)(*pGVar4)(*ppvVar5,pvVar3);
          *(double *)(ppvVar5 + 1) = (double)fVar7;
        } while (uVar6 < uVar1);
      }
      gts_eheap_thaw(heap);
      return;
    }
    g_return_if_fail_warning(0,0x816110f,"heap->func != NULL");
  }
  return;
}



gpointer gts_eheap_top(GtsEHeap *heap,gdouble *key)

{
  gpointer *ppvVar1;
  char "gts_eheap_top" [14];
  gpointer pvVar2;
  
  if (heap != (GtsEHeap *)0x0) {
    pvVar2 = (gpointer)0x0;
    if (heap->elts->len != 0) {
      ppvVar1 = (gpointer *)*heap->elts->pdata;
      if (key != (gdouble *)0x0) {
        *key = *(gdouble *)(ppvVar1 + 1);
      }
      pvVar2 = *ppvVar1;
    }
    return pvVar2;
  }
  g_return_if_fail_warning(0,"gts_eheap_top",0x816106c);
  return (gpointer)0x0;
}



// WARNING: Removing unreachable block (ram,0x0812fea4)

void __regparm3 sift_up(GtsEHeap *heap,guint i)

{
  double dVar1;
  gpointer *ppvVar2;
  gpointer pvVar3;
  gpointer pvVar4;
  int iVar5;
  uint uVar6;
  
  ppvVar2 = heap->elts->pdata;
  pvVar3 = ppvVar2[i - 1];
  dVar1 = *(double *)((int)pvVar3 + 4);
  if (1 < i) {
    do {
      uVar6 = i >> 1;
      pvVar4 = ppvVar2[uVar6 - 1];
      if (*(double *)((int)pvVar4 + 4) <= dVar1) {
        if (heap->randomized == 0) {
          return;
        }
        if (dVar1 != *(double *)((int)pvVar4 + 4)) {
          return;
        }
        iVar5 = rand();
        if (0x3ffffffe < iVar5) {
          return;
        }
      }
      ppvVar2[uVar6 - 1] = pvVar3;
      *(uint *)((int)pvVar3 + 0xc) = uVar6;
      ppvVar2[i - 1] = pvVar4;
      *(uint *)((int)pvVar4 + 0xc) = i;
      i = uVar6;
    } while (1 < uVar6);
  }
  return;
}



void gts_eheap_decrease_key(GtsEHeap *heap,GtsEHeapPair *p,gdouble new_key)

{
  uint *puVar1;
  uint i;
  
  if ((((heap != (GtsEHeap *)0x0) && (p != (GtsEHeapPair *)0x0)) && (i = p->pos, i != 0)) &&
     (((puVar1 = &heap->elts->len, i < *puVar1 || i == *puVar1 &&
       ((GtsEHeapPair *)heap->elts->pdata[i - 1] == p)) && ((double)new_key <= (double)p->key)))) {
    p->key = new_key;
    if (heap->frozen == 0) {
      sift_up(heap,i);
      return;
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



void gts_eheap_destroy(GtsEHeap *heap)

{
  gpointer *ppvVar1;
  char "gts_eheap_destroy" [18];
  GPtrArray *pGVar2;
  uint uVar3;
  
  if (heap != (GtsEHeap *)0x0) {
    pGVar2 = heap->elts;
    if (pGVar2->len != 0) {
      uVar3 = 0;
      do {
        ppvVar1 = pGVar2->pdata + uVar3;
        uVar3 = uVar3 + 1;
        g_free(*ppvVar1);
        pGVar2 = heap->elts;
      } while (uVar3 <= pGVar2->len && pGVar2->len != uVar3);
    }
    g_ptr_array_free(pGVar2,1);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_eheap_destroy",0x816106c);
  return;
}



gpointer gts_eheap_remove_top(GtsEHeap *heap,gdouble *key)

{
  GPtrArray *pGVar1;
  undefined *puVar2;
  char "gts_eheap_remove_top" [21];
  gpointer pvVar3;
  gpointer *ppvVar4;
  gpointer pvVar5;
  
  if (heap == (GtsEHeap *)0x0) {
    pvVar5 = (gpointer)0x0;
    g_return_if_fail_warning(0,"gts_eheap_remove_top",0x816106c);
  }
  else {
    pGVar1 = heap->elts;
    pvVar5 = (gpointer)0x0;
    puVar2 = (undefined *)pGVar1->len;
    if (puVar2 != (undefined *)0x0) {
      if (puVar2 == &DAT_00000001) {
        ppvVar4 = (gpointer *)g_ptr_array_remove_index(pGVar1,0);
        pvVar5 = *ppvVar4;
        if (key != (gdouble *)0x0) {
          *key = *(gdouble *)(ppvVar4 + 1);
        }
        g_free(ppvVar4);
      }
      else {
        ppvVar4 = (gpointer *)*pGVar1->pdata;
        pvVar5 = *ppvVar4;
        if (key != (gdouble *)0x0) {
          *key = *(gdouble *)(ppvVar4 + 1);
        }
        g_free(ppvVar4);
        pvVar3 = (gpointer)g_ptr_array_remove_index(pGVar1,puVar2 + -1);
        ppvVar4 = pGVar1->pdata;
        *(undefined4 *)((int)pvVar3 + 0xc) = 1;
        *ppvVar4 = pvVar3;
        sift_down(heap,1);
      }
    }
  }
  return pvVar5;
}



gpointer gts_eheap_remove(GtsEHeap *heap,GtsEHeapPair *p)

{
  uint *puVar1;
  int iVar2;
  gpointer pvVar3;
  uint uVar4;
  gpointer *ppvVar5;
  GtsEHeapPair *pGVar6;
  GtsEHeapPair *pGVar7;
  char "gts_eheap_remove" [17];
  uint uVar8;
  
  if (heap == (GtsEHeap *)0x0) {
    g_return_if_fail_warning(0,0x8161157,0x816106c);
  }
  else {
    if (p == (GtsEHeapPair *)0x0) {
      g_return_if_fail_warning(0,0x8161157,0x816106f);
    }
    else {
      pvVar3 = p->data;
      uVar4 = p->pos;
      ppvVar5 = heap->elts->pdata;
      if ((uVar4 != 0) && (puVar1 = &heap->elts->len, uVar4 < *puVar1 || uVar4 == *puVar1)) {
        iVar2 = uVar4 - 1;
        pGVar6 = (GtsEHeapPair *)ppvVar5[iVar2];
        if (pGVar6 == p) {
          while (1 < uVar4) {
            uVar8 = uVar4 >> 1;
            pGVar7 = (GtsEHeapPair *)ppvVar5[uVar8 - 1];
            *(GtsEHeapPair **)(ppvVar5 + (uVar8 - 1)) = pGVar6;
            *(GtsEHeapPair **)(ppvVar5 + iVar2) = pGVar7;
            pGVar6->pos = uVar8;
            pGVar7->pos = uVar4;
            uVar4 = uVar8;
            iVar2 = uVar8 - 1;
          }
          gts_eheap_remove_top(heap,(gdouble *)0x0);
          return pvVar3;
        }
        g_return_if_fail_warning(0,0x8161157,"p == pdata[i - 1]");
        return (gpointer)0x0;
      }
      g_return_if_fail_warning(0,"gts_eheap_remove","i > 0 && i <= heap->elts->len");
    }
  }
  return (gpointer)0x0;
}



GtsEHeapPair * gts_eheap_insert_with_key(GtsEHeap *heap,gpointer p,gdouble key)

{
  GPtrArray *pGVar1;
  guint gVar2;
  char "gts_eheap_insert_with_key" [26];
  GtsEHeapPair *pGVar3;
  
  if (heap == (GtsEHeap *)0x0) {
    pGVar3 = (GtsEHeapPair *)0x0;
    g_return_if_fail_warning(0,"gts_eheap_insert_with_key",0x816106c);
  }
  else {
    pGVar1 = heap->elts;
    pGVar3 = (GtsEHeapPair *)g_malloc(0x10);
    g_ptr_array_add(pGVar1,pGVar3);
    pGVar3->data = p;
    gVar2 = pGVar1->len;
    pGVar3->key = key;
    pGVar3->pos = gVar2;
    if (heap->frozen == 0) {
      sift_up(heap,pGVar1->len);
    }
  }
  return pGVar3;
}



GtsEHeapPair * gts_eheap_insert(GtsEHeap *heap,gpointer p)

{
  GPtrArray *pGVar1;
  int iVar2;
  char "gts_eheap_insert" [17];
  GtsEHeapPair *pGVar3;
  float10 fVar4;
  
  if (heap == (GtsEHeap *)0x0) {
    pGVar3 = (GtsEHeapPair *)0x0;
    g_return_if_fail_warning(0,"gts_eheap_insert",0x816106c);
  }
  else {
    if (heap->func == (GtsKeyFunc *)0x0) {
      pGVar3 = (GtsEHeapPair *)0x0;
      g_return_if_fail_warning(0,0x81611d8,"heap->func != NULL");
    }
    else {
      pGVar1 = heap->elts;
      pGVar3 = (GtsEHeapPair *)g_malloc(0x10);
      g_ptr_array_add(pGVar1,pGVar3);
      pGVar3->pos = pGVar1->len;
      pGVar3->data = p;
      fVar4 = (float10)(*heap->func)(p,heap->data);
      iVar2 = heap->frozen;
      *(double *)&pGVar3->key = (double)fVar4;
      if (iVar2 == 0) {
        sift_up(heap,pGVar1->len);
      }
    }
  }
  return pGVar3;
}



GtsEHeap * gts_eheap_new(GtsKeyFunc *key_func,gpointer data)

{
  GtsEHeap *pGVar1;
  GPtrArray *pGVar2;
  
  pGVar1 = (GtsEHeap *)g_malloc(0x14);
  pGVar2 = (GPtrArray *)g_ptr_array_new();
  pGVar1->frozen = 0;
  pGVar1->randomized = 0;
  pGVar1->elts = pGVar2;
  pGVar1->func = key_func;
  pGVar1->data = data;
  return pGVar1;
}



void surface_class_init(GtsSurfaceClass *klass)

{
  (klass->parent_class).destroy = surface_destroy;
  (klass->parent_class).write = surface_write;
  klass->add_face = (anon_subr_void_GtsSurface_ptr_GtsFace_ptr_for_add_face *)0x0;
  klass->remove_face = (anon_subr_void_GtsSurface_ptr_GtsFace_ptr_for_remove_face *)0x0;
  return;
}



void foreach_face(GtsFace *f,gpointer t_data,gpointer *info)

{
                    // WARNING: Could not recover jumptable at 0x08130452. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)*info)();
  return;
}



void number_foreach(gpointer data,guint *n)

{
  *n = *n + 1;
  return;
}



gboolean gts_coarsen_stop_cost(gdouble cost,guint nedge,gdouble *max_cost)

{
  char "gts_coarsen_stop_cost" [22];
  
  if (max_cost != (gdouble *)0x0) {
    return (uint)((double)*max_cost < (double)cost);
  }
  g_return_if_fail_warning(0,"gts_coarsen_stop_cost","max_cost != NULL");
  return 1;
}



gboolean gts_coarsen_stop_number(gdouble cost,guint nedge,guint *min_number)

{
  char "gts_coarsen_stop_number" [24];
  
  if (min_number != (guint *)0x0) {
    return (uint)(nedge <= *min_number && *min_number != nedge);
  }
  g_return_if_fail_warning(0,"gts_coarsen_stop_number","min_number != NULL");
  return 1;
}



void gts_range_add_value(GtsRange *r,gdouble val)

{
  if (r != (GtsRange *)0x0) {
    if ((double)val < (double)r->min) {
      r->min = val;
    }
    if ((double)r->max < (double)val) {
      r->max = val;
    }
    r->n = r->n + 1;
    *(double *)&r->sum = (double)r->sum + (double)val;
    *(double *)&r->sum2 = (double)val * (double)val + (double)r->sum2;
    return;
  }
  g_return_if_fail_warning();
  return;
}



void gts_range_reset(GtsRange *r)

{
  char "gts_range_reset" [16];
  
  if (r != (GtsRange *)0x0) {
    r->max = 0.00000000;
    r->n = 0;
    r->min = 0.00000000;
    r->sum2 = 0.00000000;
    r->sum = 0.00000000;
    return;
  }
  g_return_if_fail_warning(0,"gts_range_reset",0x8161203);
  return;
}



void gts_range_init(GtsRange *r)

{
  char "gts_range_init" [15];
  
  if (r != (GtsRange *)0x0) {
    r->max = 
    -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    r->min = 
    179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
    ;
    r->sum2 = 0.00000000;
    r->n = 0;
    r->sum = 0.00000000;
    return;
  }
  g_return_if_fail_warning(0,"gts_range_init",0x8161203);
  return;
}



GSList * __regparm3 edge_triangles(GtsEdge *e1,GtsEdge *e)

{
  GSList *pGVar1;
  gpointer pvVar2;
  GSList *pGVar3;
  GtsEdge *pGVar4;
  GSList *pGVar5;
  
  pGVar1 = e1->triangles;
  pGVar3 = (GSList *)0x0;
  do {
    while( true ) {
      if (pGVar1 == (GSList *)0x0) {
        return pGVar3;
      }
      pvVar2 = pGVar1->data;
      if (*(GtsEdge **)((int)pvVar2 + 0xc) == e) break;
      pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x10);
      if (pGVar4 == e) {
        pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x14);
joined_r0x081306b6:
        if (pGVar4 == e1) {
          pGVar4 = *(GtsEdge **)((int)pvVar2 + 0xc);
        }
        goto LAB_0813065d;
      }
      if (*(GtsEdge **)((int)pvVar2 + 0x14) == e) goto joined_r0x081306b6;
      pGVar3 = (GSList *)g_slist_prepend(pGVar3,pvVar2);
LAB_0813063c:
      pGVar1 = pGVar1->next;
    }
    pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x10);
    if (pGVar4 == e1) {
      pGVar4 = *(GtsEdge **)((int)pvVar2 + 0x14);
    }
LAB_0813065d:
    pGVar5 = pGVar4->triangles;
    if (pGVar5 == (GSList *)0x0) goto LAB_0813063c;
    do {
      pvVar2 = pGVar5->data;
      if (((*(GtsEdge **)((int)pvVar2 + 0xc) != e) && (*(GtsEdge **)((int)pvVar2 + 0x10) != e)) &&
         (*(GtsEdge **)((int)pvVar2 + 0x14) != e)) {
        pGVar3 = (GSList *)g_slist_prepend(pGVar3,pvVar2);
      }
      pGVar5 = pGVar5->next;
    } while (pGVar5 != (GSList *)0x0);
    pGVar1 = pGVar1->next;
  } while( true );
}



void closed_foreach_edge(GtsEdge *e,gpointer *data)

{
  int *piVar1;
  guint gVar2;
  
  piVar1 = (int *)*data;
  if (*piVar1 != 0) {
    gVar2 = gts_edge_face_number(e,(GtsSurface *)data[1]);
    if (gVar2 != 2) {
      *piVar1 = 0;
      return;
    }
  }
  return;
}



void manifold_foreach_edge(GtsEdge *e,gpointer *data)

{
  int *piVar1;
  guint gVar2;
  
  piVar1 = (int *)*data;
  if (*piVar1 != 0) {
    gVar2 = gts_edge_face_number(e,(GtsSurface *)data[1]);
    if (2 < gVar2) {
      *piVar1 = 0;
      return;
    }
  }
  return;
}



void non_manifold_edges(GtsEdge *e,gpointer *data)

{
  GtsSurface *s;
  undefined4 *puVar1;
  guint gVar2;
  gboolean gVar3;
  int iVar4;
  undefined4 uVar5;
  GSList *pGVar6;
  
  s = (GtsSurface *)*data;
  puVar1 = (undefined4 *)data[1];
  gVar2 = gts_edge_face_number(e,s);
  if (2 < gVar2) {
    pGVar6 = e->triangles;
    while (pGVar6 != (GSList *)0x0) {
      while ((gVar3 = gts_face_has_parent_surface((GtsFace *)pGVar6->data,s), gVar3 == 0 ||
             (iVar4 = g_slist_find(*puVar1,pGVar6->data), iVar4 != 0))) {
        pGVar6 = (GSList *)(&pGVar6->data)[1];
        if (pGVar6 == (GSList *)0x0) {
          return;
        }
      }
      uVar5 = g_slist_prepend(*puVar1,pGVar6->data);
      *puVar1 = uVar5;
      pGVar6 = (GSList *)(&pGVar6->data)[1];
    }
  }
  return;
}



void surface_boundary(GtsEdge *e,gpointer *data)

{
  undefined4 *puVar1;
  GtsFace *pGVar2;
  undefined4 uVar3;
  
  puVar1 = (undefined4 *)*data;
  pGVar2 = gts_edge_is_boundary(e,(GtsSurface *)data[1]);
  if (pGVar2 != (GtsFace *)0x0) {
    uVar3 = g_slist_prepend(*puVar1,e);
    *puVar1 = uVar3;
  }
  return;
}



GtsFace * gts_surface_traverse_next(GtsSurfaceTraverse *t,guint *level)

{
  char "gts_surface_traverse_next" [26];
  GtsFace *f;
  gpointer data [2];
  
  if (t == (GtsSurfaceTraverse *)0x0) {
    f = (GtsFace *)0x0;
    g_return_if_fail_warning(0,"gts_surface_traverse_next",0x815f901);
  }
  else {
    f = (GtsFace *)gts_fifo_pop(t->q);
    if (f != (GtsFace *)0x0) {
      if (level != (guint *)0x0) {
        *(gpointer *)level = (f->triangle).object.reserved;
      }
      data[0] = t->q;
      data[1] = f;
      gts_face_foreach_neighbor(f,t->s,push_neighbor,data);
    }
  }
  return f;
}



void push_neighbor(GtsFace *v,gpointer *data)

{
  if ((v->triangle).object.reserved != (gpointer)0x0) {
    return;
  }
  (v->triangle).object.reserved = (gpointer)(*(int *)((int)data[1] + 4) + 1);
  gts_fifo_push((GtsFifo *)*data,v);
  return;
}



GtsSurfaceTraverse * gts_surface_traverse_new(GtsSurface *s,GtsFace *f)

{
  char "gts_surface_traverse_new" [25];
  gboolean gVar1;
  GtsFifo *pGVar2;
  GtsSurfaceTraverse *pGVar3;
  
  if (s == (GtsSurface *)0x0) {
    pGVar3 = (GtsSurfaceTraverse *)0x0;
    g_return_if_fail_warning(0,0x81617e9,0x815fd1b);
  }
  else {
    if (f == (GtsFace *)0x0) {
      pGVar3 = (GtsSurfaceTraverse *)0x0;
      g_return_if_fail_warning(0,0x81617e9,"f != NULL");
    }
    else {
      gVar1 = gts_face_has_parent_surface(f,s);
      if (gVar1 == 0) {
        pGVar3 = (GtsSurfaceTraverse *)0x0;
        g_return_if_fail_warning(0,"gts_surface_traverse_new","gts_face_has_parent_surface (f, s)");
      }
      else {
        pGVar3 = (GtsSurfaceTraverse *)g_malloc(8);
        pGVar2 = gts_fifo_new();
        pGVar3->s = s;
        *(undefined **)&(f->triangle).object.reserved = &DAT_00000001;
        pGVar3->q = pGVar2;
        gts_fifo_push(pGVar3->q,f);
      }
    }
  }
  return pGVar3;
}



void build_list_boundary(GtsEdge *e,GSList **list)

{
  GtsFace *pGVar1;
  GtsBBoxClass *klass;
  GtsBBox *pGVar2;
  GSList *pGVar3;
  
  pGVar1 = gts_edge_is_boundary(e,(GtsSurface *)0x0);
  if (pGVar1 != (GtsFace *)0x0) {
    klass = gts_bbox_class();
    pGVar2 = gts_bbox_segment(klass,(GtsSegment *)e);
    pGVar3 = (GSList *)g_slist_prepend(*list,pGVar2);
    *list = pGVar3;
  }
  return;
}



void build_list_face(GtsTriangle *t,GSList **list)

{
  GtsBBoxClass *klass;
  GtsBBox *pGVar1;
  GSList *pGVar2;
  
  klass = gts_bbox_class();
  pGVar1 = gts_bbox_triangle(klass,t);
  pGVar2 = (GSList *)g_slist_prepend(*list,pGVar1);
  *list = pGVar2;
  return;
}



guint gts_surface_face_number(GtsSurface *s)

{
  char "gts_surface_face_number" [24];
  guint gVar1;
  
  if (s != (GtsSurface *)0x0) {
    gVar1 = g_hash_table_size();
    return gVar1;
  }
  g_return_if_fail_warning(0,"gts_surface_face_number",0x815fd1b);
  return 0;
}



void center_of_mass_foreach_face(GtsTriangle *t,gpointer *data)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double *pdVar7;
  double *pdVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double dVar13;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10;
  
  pdVar7 = (double *)data[1];
  pdVar8 = (double *)*data;
  gts_triangle_vertices(t,&local_10,&local_14,&local_18);
  dVar1 = (double)(local_14->p).x;
  dVar2 = (double)(local_10->p).x;
  dVar12 = (double)(local_10->p).y;
  dVar13 = (double)(local_14->p).y - dVar12;
  dVar10 = (double)(local_10->p).z;
  dVar11 = (double)(local_14->p).z - dVar10;
  dVar3 = (double)(local_18->p).x;
  dVar12 = (double)(local_18->p).y - dVar12;
  dVar10 = (double)(local_18->p).z - dVar10;
  dVar9 = dVar13 * dVar10 - dVar12 * dVar11;
  *pdVar7 = (dVar2 * dVar3 + dVar1 * dVar2 + dVar3 * dVar3 + dVar1 * dVar1 + dVar2 * dVar2 +
            dVar3 * dVar1) * dVar9 + *pdVar7;
  dVar4 = (double)(local_10->p).y;
  dVar5 = (double)(local_14->p).y;
  dVar6 = (double)(local_18->p).y;
  pdVar7[1] = (dVar11 * (dVar3 - dVar2) - dVar10 * (dVar1 - dVar2)) *
              (dVar6 * dVar5 +
              dVar4 * dVar6 + dVar4 * dVar5 + dVar6 * dVar6 + dVar5 * dVar5 + dVar4 * dVar4) +
              pdVar7[1];
  dVar10 = (double)(local_10->p).z;
  dVar4 = (double)(local_14->p).z;
  dVar5 = (double)(local_18->p).z;
  pdVar7[2] = ((dVar1 - dVar2) * dVar12 - dVar13 * (dVar3 - dVar2)) *
              (dVar5 * dVar4 +
              dVar10 * dVar5 + dVar10 * dVar4 + dVar5 * dVar5 + dVar4 * dVar4 + dVar10 * dVar10) +
              pdVar7[2];
  *pdVar8 = ((double)(local_10->p).x + (double)(local_14->p).x + (double)(local_18->p).x) * dVar9 +
            *pdVar8;
  return;
}



void volume_foreach_face(GtsTriangle *t,gdouble *volume)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [2];
  
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  dVar1 = (double)(local_14->p).y;
  dVar2 = (double)(local_18->p).z;
  dVar3 = (double)(local_14->p).z;
  dVar4 = (double)(local_18->p).y;
  dVar5 = (double)(local_10[0]->p).z;
  dVar6 = (double)(local_10[0]->p).y;
  *(double *)volume =
       (dVar6 * dVar3 - dVar5 * dVar1) * (double)(local_18->p).x +
       (dVar4 * dVar5 - dVar2 * dVar6) * (double)(local_14->p).x +
       (dVar1 * dVar2 - dVar3 * dVar4) * (double)(local_10[0]->p).x + (double)*volume;
  return;
}



void center_of_area_foreach_face(GtsTriangle *t,gpointer *data)

{
  double *pdVar1;
  double *pdVar2;
  float10 fVar3;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pdVar1 = (double *)*data;
  pdVar2 = (double *)data[1];
  gts_triangle_vertices(t,local_20,&local_24,&local_28);
  fVar3 = (float10)gts_triangle_area(t);
  *pdVar2 = (double)(((float10)(double)(local_20[0]->p).x + (float10)(double)(local_24->p).x +
                     (float10)(double)(local_28->p).x) * fVar3 + (float10)*pdVar2);
  pdVar2[1] = (double)(((float10)(double)(local_20[0]->p).y + (float10)(double)(local_24->p).y +
                       (float10)(double)(local_28->p).y) * fVar3 + (float10)pdVar2[1]);
  pdVar2[2] = (double)(((float10)(double)(local_20[0]->p).z + (float10)(double)(local_24->p).z +
                       (float10)(double)(local_28->p).z) * fVar3 + (float10)pdVar2[2]);
  *pdVar1 = (double)(fVar3 + (float10)*pdVar1);
  return;
}



void sum_area(GtsFace *f,gdouble *area)

{
  double dVar1;
  float10 fVar2;
  
  dVar1 = (double)*area;
  fVar2 = (float10)gts_triangle_area(f);
  *(double *)area = (double)(fVar2 + (float10)dVar1);
  return;
}



void foreach_edge_copy(GtsSegment *s,GtsEdgeClass *klass)

{
  GtsEdge *pGVar1;
  
  pGVar1 = gts_edge_new(klass,(GtsVertex *)(s->v1->p).object.reserved,
                        (GtsVertex *)(s->v2->p).object.reserved);
  *(GtsEdge **)&(s->object).reserved = pGVar1;
  return;
}



void foreach_vertex_copy(GtsPoint *p,GtsVertexClass *klass)

{
  GtsVertex *pGVar1;
  
  pGVar1 = gts_vertex_new(klass,p->x,p->y,p->z);
  *(GtsVertex **)&(p->object).reserved = pGVar1;
  return;
}



gboolean foreach_face_remove(GtsFace *f,gpointer t_data,gpointer *info)

{
  byte bVar1;
  int *piVar2;
  int iVar3;
  gboolean gVar4;
  GSList *pGVar5;
  
  iVar3 = (*(code *)*info)(f,info[1]);
  gVar4 = 0;
  if (iVar3 != 0) {
    piVar2 = (int *)info[2];
    pGVar5 = (GSList *)g_slist_remove(f->surfaces,piVar2);
    bVar1 = *(byte *)&(f->triangle).object.flags;
    f->surfaces = pGVar5;
    if ((((bVar1 & 1) == 0) && (gts_allow_floating_faces == 0)) && (pGVar5 == (GSList *)0x0)) {
      gts_object_destroy((GtsObject *)f);
    }
    gVar4 = 1;
    if (*(code **)(*piVar2 + 0x60) != (code *)0x0) {
      (**(code **)(*piVar2 + 0x60))(piVar2,f);
      return 1;
    }
  }
  return gVar4;
}



void destroy_foreach_face(GtsFace *f,GtsSurface *s)

{
  byte bVar1;
  GSList *pGVar2;
  
  pGVar2 = (GSList *)g_slist_remove(f->surfaces,s);
  bVar1 = *(byte *)&(f->triangle).object.flags;
  f->surfaces = pGVar2;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_faces == 0)) && (pGVar2 == (GSList *)0x0)) {
    gts_object_destroy((GtsObject *)f);
    return;
  }
  return;
}



void create_array_tessellate(GtsFace *f,GPtrArray *array)

{
  g_ptr_array_add();
  return;
}



// WARNING: Removing unreachable block (ram,0x08130f07)
// WARNING: Removing unreachable block (ram,0x08130f0b)
// WARNING: Removing unreachable block (ram,0x08130f10)

GtsVertex * unit_sphere_arc_midvertex(GtsSegment *s,GtsVertexClass *vertex_class)

{
  GtsVertex *pGVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  GtsVertex *pGVar6;
  
  pGVar6 = s->v1;
  pGVar1 = s->v2;
  dVar2 = ((double)(pGVar6->p).x + (double)(pGVar1->p).x) * 0.50000000;
  dVar5 = ((double)(pGVar6->p).y + (double)(pGVar1->p).y) * 0.50000000;
  dVar4 = ((double)(pGVar6->p).z + (double)(pGVar1->p).z) * 0.50000000;
  dVar3 = SQRT(dVar4 * dVar4 + dVar5 * dVar5 + dVar2 * dVar2);
  pGVar6 = gts_vertex_new(vertex_class,(gdouble)(dVar2 / dVar3),(gdouble)(dVar5 / dVar3),
                          (gdouble)(dVar4 / dVar3));
  return pGVar6;
}



// WARNING: Removing unreachable block (ram,0x08131006)
// WARNING: Removing unreachable block (ram,0x0813100c)
// WARNING: Removing unreachable block (ram,0x08131010)

void gts_range_update(GtsRange *r)

{
  double dVar1;
  double dVar2;
  double dVar3;
  char "gts_range_update" [17];
  
  if (r == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_range_update",0x8161203);
    return;
  }
  if (r->n != 0) {
    dVar1 = (double)r->sum;
    dVar3 = (double)(ulonglong)r->n;
    dVar2 = (double)r->sum2 - (dVar1 * dVar1) / dVar3;
    if (dVar2 < 0.00000000) {
      r->stddev = 0.00000000;
    }
    else {
      *(double *)&r->stddev = SQRT(dVar2 / dVar3);
    }
    *(double *)&r->mean = dVar1 / (double)(ulonglong)r->n;
    return;
  }
  r->stddev = 0.00000000;
  r->mean = 0.00000000;
  r->max = 0.00000000;
  r->min = 0.00000000;
  return;
}



void create_heap_coarsen(GtsEdge *e,GtsEHeap *heap)

{
  GtsEHeapPair *pGVar1;
  
  pGVar1 = gts_eheap_insert(heap,e);
  *(GtsEHeapPair **)&(e->segment).object.reserved = pGVar1;
  return;
}



void create_heap_refine(GtsEdge *e,GtsEHeap *heap)

{
  gts_eheap_insert(heap,e);
  return;
}



void edge_length2(int e)

{
  gts_point_distance2(*(undefined4 *)(e + 0xc),*(undefined4 *)(e + 0x10));
  return;
}



float10 edge_length2_inverse(int s)

{
  float10 fVar1;
  
  fVar1 = (float10)gts_point_distance2(*(undefined4 *)(s + 0xc),*(undefined4 *)(s + 0x10));
  return -fVar1;
}



guint gts_surface_foreach_face_remove(GtsSurface *s,GtsFunc *func,gpointer data)

{
  char "gts_surface_foreach_face_remove" [32];
  guint gVar1;
  gpointer info [4];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_face_remove",0x815fd1b);
    return 0;
  }
  if (func != (GtsFunc *)0x0) {
    info[0] = func;
    info[2] = s;
    s->keep_faces = 1;
    info[1] = data;
    gVar1 = g_hash_table_foreach_remove(s->faces,foreach_face_remove,info);
    s->keep_faces = 0;
    return gVar1;
  }
  g_return_if_fail_warning(0,0x8161a20,0x816107f);
  return 0;
}



void gts_surface_foreach_face(GtsSurface *s,GtsFunc *func,gpointer data)

{
  char "gts_surface_foreach_face" [25];
  gpointer info [2];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_face",0x815fd1b);
    return;
  }
  if (func != (GtsFunc *)0x0) {
    info[0] = func;
    s->keep_faces = 1;
    info[1] = data;
    g_hash_table_foreach(s->faces,foreach_face,info);
    s->keep_faces = 0;
    return;
  }
  g_return_if_fail_warning(0,0x8161a40,0x816107f);
  return;
}



void gts_surface_traverse_destroy(GtsSurfaceTraverse *t)

{
  char "gts_surface_traverse_destroy" [29];
  
  if (t != (GtsSurfaceTraverse *)0x0) {
    gts_surface_foreach_face(t->s,gts_object_reset_reserved,(gpointer)0x0);
    gts_fifo_destroy(t->q);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_surface_traverse_destroy",0x815f901);
  return;
}



float10 gts_surface_center_of_area(GtsSurface *s,double *cm)

{
  char "gts_surface_center_of_area" [27];
  float10 fVar1;
  float10 fVar2;
  gpointer data [2];
  double local_14;
  
  local_14 = 0.00000000;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_center_of_area",0x815fd1b);
    return (float10)0.00000000;
  }
  cm[2] = 0.00000000;
  data[0] = &local_14;
  cm[1] = 0.00000000;
  *cm = 0.00000000;
  data[1] = cm;
  gts_surface_foreach_face(s,center_of_area_foreach_face,data);
  fVar1 = (float10)local_14;
  if (fVar1 != (float10)0.00000000) {
    *cm = (double)((float10)*cm / (fVar1 * (float10)3.00000000));
    fVar2 = (float10)3.00000000 * (float10)local_14;
    cm[1] = (double)((float10)cm[1] / fVar2);
    cm[2] = (double)((float10)cm[2] / fVar2);
    return fVar1;
  }
  return fVar1;
}



float10 gts_surface_center_of_mass(GtsSurface *s,double *cm)

{
  char "gts_surface_center_of_mass" [27];
  float10 fVar1;
  float10 fVar2;
  gpointer data [2];
  double local_14;
  
  local_14 = 0.00000000;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_center_of_mass",0x815fd1b);
    return (float10)0.00000000;
  }
  cm[2] = 0.00000000;
  data[0] = &local_14;
  cm[1] = 0.00000000;
  *cm = 0.00000000;
  data[1] = cm;
  gts_surface_foreach_face(s,center_of_mass_foreach_face,data);
  fVar1 = (float10)local_14;
  if (fVar1 != (float10)0.00000000) {
    *cm = (double)((float10)*cm / (fVar1 * (float10)4.00000000));
    fVar2 = (float10)4.00000000 * (float10)local_14;
    cm[1] = (double)((float10)cm[1] / fVar2);
    cm[2] = (double)((float10)cm[2] / fVar2);
  }
  return fVar1 / (float10)6.00000000;
}



float10 gts_surface_volume(GtsSurface *s)

{
  char "gts_surface_volume" [19];
  double local_14 [2];
  
  local_14[0] = 0.00000000;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_face(s,volume_foreach_face,local_14);
    return (float10)local_14[0] / (float10)6.00000000;
  }
  g_return_if_fail_warning(0,"gts_surface_volume",0x815fd1b);
  return (float10)0.00000000;
}



void gts_surface_merge(GtsSurface *s,GtsSurface *with)

{
  char "gts_surface_merge" [18];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_merge",0x815fd1b);
    return;
  }
  if (with != (GtsSurface *)0x0) {
    gts_surface_foreach_face(with,merge_foreach_face,s);
    return;
  }
  g_return_if_fail_warning(0,0x8161920,"with != NULL");
  return;
}



float10 gts_surface_area(GtsSurface *s)

{
  double local_14 [2];
  
  local_14[0] = 0.00000000;
  gts_surface_foreach_face(s,sum_area,local_14);
  return (float10)local_14[0];
}



void gts_surface_foreach_edge(GtsSurface *s,GtsFunc *func,gpointer data)

{
  char "gts_surface_foreach_edge" [25];
  gpointer info [3];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_edge",0x815fd1b);
    return;
  }
  if (func != (GtsFunc *)0x0) {
    s->keep_faces = 1;
    info[0] = (gpointer)g_hash_table_new(0,0);
    info[2] = func;
    info[1] = data;
    g_hash_table_foreach(s->faces,edge_foreach_face,info);
    g_hash_table_destroy(info[0]);
    s->keep_faces = 0;
    return;
  }
  g_return_if_fail_warning(0,0x8161a59,0x816107f);
  return;
}



GSList * gts_surface_split(GtsSurface *s)

{
  char "gts_surface_split" [18];
  gpointer data [2];
  GSList *local_10;
  
  local_10 = (GSList *)0x0;
  if (s != (GtsSurface *)0x0) {
    data[1] = &local_10;
    data[0] = s;
    gts_surface_foreach_edge(s,traverse_boundary,data);
    gts_surface_foreach_face(s,traverse_remaining,data);
    return local_10;
  }
  g_return_if_fail_warning(0,"gts_surface_split",0x815fd1b);
  return (GSList *)0x0;
}



GSList * gts_surface_boundary(GtsSurface *surface)

{
  char "gts_surface_boundary" [21];
  gpointer data [2];
  GSList *local_10 [3];
  
  local_10[0] = (GSList *)0x0;
  if (surface != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = surface;
    gts_surface_foreach_edge(surface,surface_boundary,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_boundary","surface != NULL");
  return (GSList *)0x0;
}



void gts_surface_distance
               (GtsSurface *s1,GtsSurface *s2,gdouble delta,GtsRange *face_range,
               GtsRange *boundary_range)

{
  char "gts_surface_distance" [21];
  GNode *tree;
  GSList *local_20 [4];
  
  if (s1 == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x8161817,"s1 != NULL");
    return;
  }
  if (s2 == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x8161817,0x8161e2c);
    return;
  }
  if (((double)delta <= 0.00000000) || (1.00000000 <= (double)delta)) {
    g_return_if_fail_warning(0,"gts_surface_distance","delta > 0. && delta < 1.");
    return;
  }
  if (face_range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,0x8161817,"face_range != NULL");
    return;
  }
  if (boundary_range == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,0x8161817,"boundary_range != NULL");
    return;
  }
  local_20[0] = (GSList *)0x0;
  gts_surface_foreach_face(s2,build_list_face,local_20);
  if (local_20[0] == (GSList *)0x0) {
    gts_range_reset(face_range);
  }
  else {
    tree = gts_bb_tree_new(local_20[0]);
    g_slist_free(local_20[0]);
    gts_bb_tree_surface_distance(tree,s1,gts_point_triangle_distance,delta,face_range);
    gts_bb_tree_destroy(tree,1);
    local_20[0] = (GSList *)0x0;
    gts_surface_foreach_edge(s2,build_list_boundary,local_20);
    if (local_20[0] != (GSList *)0x0) {
      tree = gts_bb_tree_new(local_20[0]);
      g_slist_free(local_20[0]);
      gts_bb_tree_surface_boundary_distance(tree,s1,gts_point_segment_distance,delta,boundary_range)
      ;
      gts_bb_tree_destroy(tree,1);
      return;
    }
  }
  gts_range_reset(boundary_range);
  return;
}



guint gts_surface_edge_number(GtsSurface *s)

{
  char "gts_surface_edge_number" [24];
  guint local_10 [3];
  
  local_10[0] = 0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_edge(s,number_foreach,local_10);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_edge_number",0x815fd1b);
  return 0;
}



gboolean gts_surface_is_orientable(GtsSurface *s)

{
  char "gts_surface_is_orientable" [26];
  gpointer data [2];
  gboolean local_10 [3];
  
  local_10[0] = 1;
  if (s != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = s;
    gts_surface_foreach_edge(s,orientable_foreach_edge,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_is_orientable",0x815fd1b);
  return 0;
}



gboolean gts_surface_is_closed(GtsSurface *s)

{
  char "gts_surface_is_closed" [22];
  gpointer data [2];
  gboolean local_10 [3];
  
  local_10[0] = 1;
  if (s != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = s;
    gts_surface_foreach_edge(s,closed_foreach_edge,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_is_closed",0x815fd1b);
  return 0;
}



gboolean gts_surface_is_manifold(GtsSurface *s)

{
  char "gts_surface_is_manifold" [24];
  gpointer data [2];
  gboolean local_10 [3];
  
  local_10[0] = 1;
  if (s != (GtsSurface *)0x0) {
    data[0] = local_10;
    data[1] = s;
    gts_surface_foreach_edge(s,manifold_foreach_edge,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_is_manifold",0x815fd1b);
  return 0;
}



void gts_surface_quality_stats(GtsSurface *s,GtsSurfaceQualityStats *stats)

{
  char "gts_surface_quality_stats" [26];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_quality_stats",0x815fd1b);
  }
  else {
    if (stats != (GtsSurfaceQualityStats *)0x0) {
      stats->parent = s;
      gts_range_init((GtsRange *)stats);
      gts_range_init(&stats->face_area);
      gts_range_init(&stats->edge_length);
      gts_range_init(&stats->edge_angle);
      gts_surface_foreach_edge(s,quality_foreach_edge,stats);
      gts_surface_foreach_face(s,quality_foreach_face,stats);
      gts_range_update((GtsRange *)stats);
      gts_range_update(&stats->face_area);
      gts_range_update(&stats->edge_length);
      gts_range_update(&stats->edge_angle);
      return;
    }
    g_return_if_fail_warning(0,0x8161b17,"stats != NULL");
  }
  return;
}



void gts_surface_foreach_vertex(GtsSurface *s,GtsFunc *func,gpointer data)

{
  char "gts_surface_foreach_vertex" [27];
  gpointer info [3];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_foreach_vertex",0x815fd1b);
    return;
  }
  if (func != (GtsFunc *)0x0) {
    s->keep_faces = 1;
    info[0] = (gpointer)g_hash_table_new(0,0);
    info[2] = func;
    info[1] = data;
    g_hash_table_foreach(s->faces,vertex_foreach_face,info);
    g_hash_table_destroy(info[0]);
    s->keep_faces = 0;
    return;
  }
  g_return_if_fail_warning(0,0x8161a72,0x816107f);
  return;
}



guint gts_surface_vertex_number(GtsSurface *s)

{
  char "gts_surface_vertex_number" [26];
  guint local_10 [3];
  
  local_10[0] = 0;
  if (s != (GtsSurface *)0x0) {
    gts_surface_foreach_vertex(s,number_foreach,local_10);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_surface_vertex_number",0x815fd1b);
  return 0;
}



GtsSurface * gts_surface_copy(GtsSurface *s1,GtsSurface *s2)

{
  char "gts_surface_copy" [17];
  
  if (s1 == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_copy","s1 != NULL");
    return (GtsSurface *)0x0;
  }
  if (s2 != (GtsSurface *)0x0) {
    gts_surface_foreach_vertex(s2,foreach_vertex_copy,s1->vertex_class);
    gts_surface_foreach_edge(s2,foreach_edge_copy,s1->edge_class);
    gts_surface_foreach_face(s2,foreach_face_copy,s1);
    gts_surface_foreach_vertex(s2,gts_object_reset_reserved,(gpointer)0x0);
    gts_surface_foreach_edge(s2,gts_object_reset_reserved,(gpointer)0x0);
    return s1;
  }
  g_return_if_fail_warning(0,0x8161932,0x8161e2c);
  return (GtsSurface *)0x0;
}



void gts_surface_stats(GtsSurface *s,GtsSurfaceStats *stats)

{
  char "gts_surface_stats" [18];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_stats",0x815fd1b);
  }
  else {
    if (stats != (GtsSurfaceStats *)0x0) {
      stats->parent = s;
      stats->n_faces = 0;
      stats->n_incompatible_faces = 0;
      stats->n_duplicate_faces = 0;
      stats->n_duplicate_edges = 0;
      stats->n_boundary_edges = 0;
      stats->n_non_manifold_edges = 0;
      gts_range_init(&stats->edges_per_vertex);
      gts_range_init(&stats->faces_per_edge);
      gts_surface_foreach_vertex(s,stats_foreach_vertex,stats);
      gts_surface_foreach_edge(s,stats_foreach_edge,stats);
      gts_surface_foreach_face(s,stats_foreach_face,stats);
      gts_range_update(&stats->edges_per_vertex);
      gts_range_update(&stats->faces_per_edge);
      return;
    }
    g_return_if_fail_warning(0,0x8161b31,"stats != NULL");
  }
  return;
}



void edge_foreach_face(GtsTriangle *t,gpointer t_data,gpointer *info)

{
  gpointer pvVar1;
  gpointer pvVar2;
  code *pcVar3;
  int iVar4;
  
  pvVar1 = info[1];
  pvVar2 = *info;
  pcVar3 = (code *)info[2];
  iVar4 = g_hash_table_lookup(pvVar2,t->e1);
  if (iVar4 == 0) {
    (*pcVar3)(t->e1,pvVar1);
    g_hash_table_insert(pvVar2,t->e1,0xffffffff);
  }
  iVar4 = g_hash_table_lookup(pvVar2,t->e2);
  if (iVar4 == 0) {
    (*pcVar3)(t->e2,pvVar1);
    g_hash_table_insert(pvVar2,t->e2,0xffffffff);
  }
  iVar4 = g_hash_table_lookup(pvVar2,t->e3);
  if (iVar4 != 0) {
    return;
  }
  (*pcVar3)(t->e3,pvVar1);
  g_hash_table_insert();
  return;
}



void vertex_foreach_face(GtsTriangle *t,gpointer t_data,gpointer *info)

{
  gpointer pvVar1;
  gpointer pvVar2;
  GtsEdge *pGVar3;
  code *pcVar4;
  int iVar5;
  GtsVertex *pGVar6;
  
  pvVar1 = info[1];
  pvVar2 = *info;
  pGVar3 = t->e1;
  pcVar4 = (code *)info[2];
  iVar5 = g_hash_table_lookup(pvVar2,(pGVar3->segment).v1);
  if (iVar5 == 0) {
    (*pcVar4)((pGVar3->segment).v1,pvVar1);
    g_hash_table_insert(pvVar2,(pGVar3->segment).v1,0xffffffff);
  }
  iVar5 = g_hash_table_lookup(pvVar2,(pGVar3->segment).v2);
  if (iVar5 == 0) {
    (*pcVar4)((pGVar3->segment).v2,pvVar1);
    g_hash_table_insert(pvVar2,(pGVar3->segment).v2,0xffffffff);
  }
  pGVar6 = (t->e2->segment).v1;
  if (((t->e1->segment).v1 == pGVar6) || (pGVar6 == (t->e1->segment).v2)) {
    iVar5 = g_hash_table_lookup(pvVar2,(t->e2->segment).v2);
  }
  else {
    iVar5 = g_hash_table_lookup(pvVar2,pGVar6);
  }
  if (iVar5 == 0) {
    pGVar6 = (t->e2->segment).v1;
    if (((t->e1->segment).v1 == pGVar6) || (pGVar6 == (t->e1->segment).v2)) {
      pGVar6 = (t->e2->segment).v2;
    }
    (*pcVar4)(pGVar6,pvVar1);
    g_hash_table_insert();
    return;
  }
  return;
}



void gts_surface_add_face(GtsSurface *s,GtsFace *f)

{
  code *UNRECOVERED_JUMPTABLE;
  char "gts_surface_add_face" [21];
  int iVar1;
  GSList *pGVar2;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_add_face",0x815fd1b);
  }
  else {
    if (f == (GtsFace *)0x0) {
      g_return_if_fail_warning(0,0x8161bc0,"f != NULL");
      return;
    }
    if (s->keep_faces != 0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,"../../src/gts/surface.c",0x99,0x8161bc0,"s->keep_faces == FALSE");
    }
    iVar1 = g_hash_table_lookup(s->faces,f);
    if (iVar1 == 0) {
      pGVar2 = (GSList *)g_slist_prepend(f->surfaces,s);
      f->surfaces = pGVar2;
      g_hash_table_insert(s->faces,f,f);
    }
    UNRECOVERED_JUMPTABLE = *(code **)(s->object).klass[1].info.name;
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0813212d. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)();
      return;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void __regparm3 traverse_manifold(GtsTriangle *t,GtsSurface *s)

{
  GSList *pGVar1;
  GtsFace *t_00;
  uint uVar2;
  int iVar3;
  
  do {
    uVar2 = g_slist_length(((GtsFace *)t)->surfaces);
    while( true ) {
      if (1 < uVar2) {
        return;
      }
      gts_surface_add_face(s,(GtsFace *)t);
      iVar3 = g_slist_length(((((GtsFace *)t)->triangle).e1)->triangles);
      if (iVar3 == 2) {
        pGVar1 = ((((GtsFace *)t)->triangle).e1)->triangles;
        t_00 = (GtsFace *)pGVar1->data;
        if (t_00 == (GtsFace *)t) {
          traverse_manifold(*(GtsTriangle **)&((GtsTriangle *)(&pGVar1->data)[1])->object,s);
        }
        else {
          traverse_manifold((GtsTriangle *)t_00,s);
        }
      }
      iVar3 = g_slist_length(((((GtsFace *)t)->triangle).e2)->triangles);
      if (iVar3 == 2) {
        pGVar1 = ((((GtsFace *)t)->triangle).e2)->triangles;
        t_00 = (GtsFace *)pGVar1->data;
        if (t_00 == (GtsFace *)t) {
          traverse_manifold(*(GtsTriangle **)&((GtsTriangle *)(&pGVar1->data)[1])->object,s);
        }
        else {
          traverse_manifold((GtsTriangle *)t_00,s);
        }
      }
      iVar3 = g_slist_length(((((GtsFace *)t)->triangle).e3)->triangles);
      if (iVar3 != 2) {
        return;
      }
      pGVar1 = ((((GtsFace *)t)->triangle).e3)->triangles;
      t_00 = (GtsFace *)pGVar1->data;
      if (t_00 == (GtsFace *)t) break;
      uVar2 = g_slist_length(t_00->surfaces);
      t = (GtsTriangle *)t_00;
    }
    t = (GtsTriangle *)pGVar1->next->data;
  } while( true );
}



void merge_foreach_face(GtsFace *f,GtsSurface *s)

{
  gts_surface_add_face(s,f);
  return;
}



void foreach_face_copy(GtsTriangle *t,GtsSurface *s)

{
  GtsFace *f;
  
  f = gts_face_new(s->face_class,(GtsEdge *)(t->e1->segment).object.reserved,
                   (GtsEdge *)(t->e2->segment).object.reserved,
                   (GtsEdge *)(t->e3->segment).object.reserved);
  gts_surface_add_face(s,f);
  return;
}



// WARNING: Type propagation algorithm not settling

void gts_surface_tessellate(GtsSurface *s,GtsRefineFunc refine_func,gpointer refine_data)

{
  GtsVertex *pGVar1;
  GtsVertex *pGVar2;
  GtsEdge *pGVar3;
  GtsEdgeClass *klass;
  GtsVertexClass *pGVar4;
  int iVar5;
  GtsVertex *pGVar6;
  code *pcVar7;
  int *data;
  GSList *pGVar8;
  GtsEdge *e2;
  GtsEdge *e3;
  GtsEdge *e1;
  GtsFace *f;
  undefined4 uVar9;
  gpointer pvVar10;
  GtsVertex *local_50;
  GtsVertex *local_48;
  GtsVertex *local_44;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  uint local_38;
  GtsVertex *local_34;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsEdge *local_24;
  GtsVertex *local_20;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning();
    return;
  }
  pcVar7 = unit_sphere_arc_midvertex;
  if (refine_func != (GtsRefineFunc)0x0) {
    pcVar7 = refine_func;
  }
  data = (int *)g_ptr_array_new();
  gts_surface_foreach_face(s,create_array_tessellate,data);
  if (data[1] != 0) {
    local_38 = 0;
    do {
      klass = s->edge_class;
      pGVar4 = s->vertex_class;
      iVar5 = *(int *)(*data + local_38 * 4);
      e2 = *(GtsEdge **)(iVar5 + 0x14);
      e3 = *(GtsEdge **)(iVar5 + 0xc);
      e1 = *(GtsEdge **)(iVar5 + 0x10);
      pGVar6 = (e3->segment).v2;
      local_20 = (e1->segment).v1;
      if (pGVar6 == local_20) {
        local_50 = (e3->segment).v1;
        local_28 = (e1->segment).v2;
      }
      else {
        pGVar1 = (e1->segment).v2;
        if (pGVar6 == pGVar1) {
          local_50 = (e3->segment).v1;
          local_28 = local_20;
          local_20 = pGVar6;
        }
        else {
          pGVar2 = (e3->segment).v1;
          local_50 = pGVar6;
          local_28 = pGVar1;
          if ((local_20 != pGVar2) && (local_28 = local_20, local_20 = pGVar2, pGVar1 != pGVar2)) {
                    // WARNING: Subroutine does not return
            g_assertion_message(0,"../../src/gts/surface.c",0x763,"tessellate_face",0);
          }
        }
      }
      pGVar8 = (GSList *)g_slist_remove(e3->triangles,iVar5);
      e3->triangles = pGVar8;
      pGVar8 = (GSList *)g_slist_remove(e1->triangles,iVar5);
      e1->triangles = pGVar8;
      pGVar8 = (GSList *)g_slist_remove(e2->triangles,iVar5);
      e2->triangles = pGVar8;
      pGVar3 = *(GtsEdge **)&e3->segment;
      if (pGVar3 == (GtsEdge *)0x0) {
        local_44 = (*pcVar7)(e3,pGVar4,refine_data);
        local_3c = gts_edge_new(klass,local_50,local_44);
        local_2c = gts_edge_new(klass,local_20,local_44);
        uVar9 = g_slist_append(0,local_3c);
        pvVar10 = (gpointer)g_slist_append(uVar9,local_2c);
        *(gpointer *)&e3->segment = pvVar10;
      }
      else {
        local_2c = *(GtsEdge **)&pGVar3->segment;
        pGVar3 = *(GtsEdge **)&(*(GtsEdge **)((int)&pGVar3->segment + 4))->segment;
        local_44 = (local_2c->segment).v2;
        local_3c = pGVar3;
        if ((local_2c->segment).v1 != local_20) {
          local_3c = local_2c;
          local_2c = pGVar3;
        }
      }
      pGVar3 = *(GtsEdge **)&e1->segment;
      if (pGVar3 == (GtsEdge *)0x0) {
        local_48 = (*pcVar7)(e1,pGVar4,refine_data);
        local_40 = gts_edge_new(klass,local_20,local_48);
        local_24 = gts_edge_new(klass,local_28,local_48);
        uVar9 = g_slist_append(0,local_40);
        pvVar10 = (gpointer)g_slist_append(uVar9,local_24);
        *(gpointer *)&e1->segment = pvVar10;
      }
      else {
        local_24 = *(GtsEdge **)&pGVar3->segment;
        pGVar3 = *(GtsEdge **)&(*(GtsEdge **)((int)&pGVar3->segment + 4))->segment;
        local_48 = (local_24->segment).v2;
        local_40 = pGVar3;
        if ((local_24->segment).v1 != local_28) {
          local_40 = local_24;
          local_24 = pGVar3;
        }
      }
      pGVar3 = *(GtsEdge **)&e2->segment;
      if (pGVar3 == (GtsEdge *)0x0) {
        local_34 = (*pcVar7)(e2,pGVar4,refine_data);
        local_28 = (GtsVertex *)gts_edge_new(klass,local_28,local_34);
        local_20 = (GtsVertex *)gts_edge_new(klass,local_50,local_34);
        uVar9 = g_slist_append(0,local_28);
        pvVar10 = (gpointer)g_slist_append(uVar9,local_20);
        *(gpointer *)&e2->segment = pvVar10;
        if (e3->triangles == (GSList *)0x0) goto LAB_08132758;
LAB_081324d3:
        pGVar8 = e1->triangles;
      }
      else {
        local_20 = *(GtsVertex **)&pGVar3->segment;
        pGVar3 = *(GtsEdge **)&(*(GtsEdge **)((int)&pGVar3->segment + 4))->segment;
        local_34 = (((GtsEdge *)local_20)->segment).v2;
        local_28 = (GtsVertex *)pGVar3;
        if (local_50 != (((GtsEdge *)local_20)->segment).v1) {
          local_28 = local_20;
          local_20 = (GtsVertex *)pGVar3;
        }
        if (e3->triangles != (GSList *)0x0) goto LAB_081324d3;
LAB_08132758:
        g_slist_free(*(gpointer *)&e3->segment);
        *(gpointer *)&e3->segment = (gpointer)0x0;
        gts_object_destroy((GtsObject *)e3);
        pGVar8 = e1->triangles;
      }
      if (pGVar8 == (GSList *)0x0) {
        g_slist_free(*(gpointer *)&e1->segment);
        *(gpointer *)&e1->segment = (gpointer)0x0;
        gts_object_destroy((GtsObject *)e1);
      }
      if (e2->triangles == (GSList *)0x0) {
        g_slist_free(*(gpointer *)&e2->segment);
        *(gpointer *)&e2->segment = (gpointer)0x0;
        gts_object_destroy((GtsObject *)e2);
      }
      e2 = gts_edge_new(klass,local_48,local_34);
      e3 = gts_edge_new(klass,local_34,local_44);
      e1 = gts_edge_new(klass,local_44,local_48);
      *(GtsEdge **)(iVar5 + 0xc) = e2;
      pGVar8 = (GSList *)g_slist_prepend(e2->triangles,iVar5);
      *(GtsEdge **)(iVar5 + 0x10) = e3;
      e2->triangles = pGVar8;
      pGVar8 = (GSList *)g_slist_prepend(e3->triangles,iVar5);
      *(GtsEdge **)(iVar5 + 0x14) = e1;
      e3->triangles = pGVar8;
      pGVar8 = (GSList *)g_slist_prepend(e1->triangles,iVar5);
      e1->triangles = pGVar8;
      f = gts_face_new(s->face_class,(GtsEdge *)local_28,e2,local_24);
      gts_surface_add_face(s,f);
      f = gts_face_new(s->face_class,(GtsEdge *)local_20,local_3c,e3);
      gts_surface_add_face(s,f);
      f = gts_face_new(s->face_class,e1,local_2c,local_40);
      gts_surface_add_face(s,f);
      local_38 = local_38 + 1;
    } while (local_38 <= (uint)data[1] && data[1] != local_38);
  }
  g_ptr_array_free();
  return;
}



GtsSurface * gts_surface_generate_sphere(GtsSurface *s,guint geodesation_order)

{
  char "gts_surface_generate_sphere" [28];
  GtsVertex *v1;
  GtsVertex *v2;
  GtsVertex *v1_00;
  GtsVertex *v2_00;
  GtsVertex *v2_01;
  GtsVertex *v1_01;
  GtsVertex *v1_02;
  GtsVertex *v1_03;
  GtsVertex *v2_02;
  GtsVertex *v2_03;
  GtsVertex *v2_04;
  GtsVertex *v1_04;
  GtsEdge *e2;
  GtsEdge *e1;
  GtsEdge *e1_00;
  GtsEdge *e2_00;
  GtsEdge *e2_01;
  GtsEdge *e2_02;
  GtsEdge *e3;
  GtsEdge *e2_03;
  GtsEdge *e1_01;
  GtsEdge *e3_00;
  GtsEdge *e2_04;
  GtsEdge *e3_01;
  GtsEdge *e3_02;
  GtsEdge *e2_05;
  GtsEdge *e3_03;
  GtsEdge *e2_06;
  GtsEdge *e3_04;
  GtsEdge *e2_07;
  GtsEdge *e2_08;
  GtsEdge *e2_09;
  GtsEdge *e3_05;
  GtsEdge *e3_06;
  GtsEdge *e3_07;
  GtsEdge *e1_02;
  GtsEdge *e2_10;
  GtsEdge *e3_08;
  GtsEdge *e2_11;
  GtsEdge *e2_12;
  GtsEdge *e3_09;
  GtsEdge *e3_10;
  GtsFace *f;
  uint uVar1;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x8161943,0x815fd1b);
    return (GtsSurface *)0x0;
  }
  if (geodesation_order == 0) {
    s = (GtsSurface *)0x0;
    g_return_if_fail_warning(0,"gts_surface_generate_sphere","geodesation_order != 0");
  }
  else {
    v1 = gts_vertex_new(s->vertex_class,0.00000000,0.85065081,-0.52573111);
    v2 = gts_vertex_new(s->vertex_class,0.85065081,0.52573111,0.00000000);
    v1_00 = gts_vertex_new(s->vertex_class,0.52573111,0.00000000,-0.85065081);
    v2_00 = gts_vertex_new(s->vertex_class,0.52573111,0.00000000,0.85065081);
    v2_01 = gts_vertex_new(s->vertex_class,0.85065081,-0.52573111,0.00000000);
    v1_01 = gts_vertex_new(s->vertex_class,0.00000000,0.85065081,0.52573111);
    v1_02 = gts_vertex_new(s->vertex_class,-0.52573111,0.00000000,0.85065081);
    v1_03 = gts_vertex_new(s->vertex_class,0.00000000,-0.85065081,-0.52573111);
    v2_02 = gts_vertex_new(s->vertex_class,-0.85065081,0.52573111,0.00000000);
    v2_03 = gts_vertex_new(s->vertex_class,-0.52573111,0.00000000,-0.85065081);
    v2_04 = gts_vertex_new(s->vertex_class,-0.85065081,-0.52573111,0.00000000);
    v1_04 = gts_vertex_new(s->vertex_class,0.00000000,-0.85065081,0.52573111);
    e2 = gts_edge_new(s->edge_class,v1,v2);
    e1 = gts_edge_new(s->edge_class,v1_00,v2);
    e1_00 = gts_edge_new(s->edge_class,v1,v1_00);
    e2_00 = gts_edge_new(s->edge_class,v2_00,v2_01);
    e2_01 = gts_edge_new(s->edge_class,v2,v2_01);
    e2_02 = gts_edge_new(s->edge_class,v2_00,v2);
    e3 = gts_edge_new(s->edge_class,v1_01,v1_02);
    e2_03 = gts_edge_new(s->edge_class,v2_00,v1_02);
    e1_01 = gts_edge_new(s->edge_class,v1_01,v2_00);
    e3_00 = gts_edge_new(s->edge_class,v1_03,v1_00);
    e2_04 = gts_edge_new(s->edge_class,v1_00,v2_01);
    e3_01 = gts_edge_new(s->edge_class,v1_03,v2_01);
    e3_02 = gts_edge_new(s->edge_class,v1_01,v2_02);
    e2_05 = gts_edge_new(s->edge_class,v1_02,v2_02);
    e3_03 = gts_edge_new(s->edge_class,v1_03,v2_03);
    e2_06 = gts_edge_new(s->edge_class,v1_00,v2_03);
    e3_04 = gts_edge_new(s->edge_class,v1_01,v1);
    e2_07 = gts_edge_new(s->edge_class,v1,v2_02);
    e2_08 = gts_edge_new(s->edge_class,v1_03,v2_04);
    e2_09 = gts_edge_new(s->edge_class,v2_03,v2_04);
    e3_05 = gts_edge_new(s->edge_class,v1_01,v2);
    e3_06 = gts_edge_new(s->edge_class,v1_04,v2_04);
    e3_07 = gts_edge_new(s->edge_class,v1_04,v1_03);
    e1_02 = gts_edge_new(s->edge_class,v1_04,v1_02);
    e2_10 = gts_edge_new(s->edge_class,v1_02,v2_04);
    e3_08 = gts_edge_new(s->edge_class,v1_04,v2_00);
    e2_11 = gts_edge_new(s->edge_class,v2_02,v2_04);
    e2_12 = gts_edge_new(s->edge_class,v2_03,v2_02);
    e3_09 = gts_edge_new(s->edge_class,v1_04,v2_01);
    e3_10 = gts_edge_new(s->edge_class,v1,v2_03);
    f = gts_face_new(s->face_class,e2,e1,e1_00);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e2_00,e2_01,e2_02);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3,e2_03,e1_01);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_00,e2_04,e3_01);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_02,e2_05,e3);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_03,e2_06,e3_00);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_04,e2_07,e3_02);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e2_08,e2_09,e3_03);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_05,e2,e3_04);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_06,e2_08,e3_07);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e1_01,e2_02,e3_05);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e1_02,e2_10,e3_06);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_08,e2_03,e1_02);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e2_09,e2_11,e2_12);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_09,e2_00,e3_08);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e2_05,e2_11,e2_10);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_07,e3_01,e3_09);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e1,e2_01,e2_04);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e3_10,e2_12,e2_07);
    gts_surface_add_face(s,f);
    f = gts_face_new(s->face_class,e1_00,e2_06,e3_10);
    gts_surface_add_face(s,f);
    if (1 < geodesation_order) {
      uVar1 = 1;
      do {
        uVar1 = uVar1 + 1;
        gts_surface_tessellate(s,(GtsRefineFunc)0x0,(gpointer)0x0);
      } while (uVar1 < geodesation_order);
      return s;
    }
  }
  return s;
}



void gts_surface_refine(GtsSurface *surface,GtsKeyFunc *cost_func,gpointer cost_data,
                       GtsRefineFunc refine_func,gpointer refine_data,GtsStopFunc *stop_func,
                       gpointer stop_data)

{
  GtsEdgeClass *klass;
  GSList *pGVar1;
  GtsTriangle *t;
  char "gts_surface_refine" [19];
  GtsEHeap *heap;
  guint gVar2;
  guint gVar3;
  gboolean gVar4;
  GtsVertex *v2;
  GtsEdge *e;
  GtsEdge *p;
  GtsEdge *e3;
  GSList *pGVar5;
  GtsFace *f;
  code *pcVar6;
  GtsEdge *e1;
  gdouble local_3c;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *v1;
  GtsEdge *local_20 [4];
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_refine","surface != NULL");
    return;
  }
  if (stop_func == (GtsStopFunc *)0x0) {
    g_return_if_fail_warning(0,0x8161a03,"stop_func != NULL");
    return;
  }
  if (cost_func == (GtsKeyFunc *)0x0) {
    cost_func = edge_length2_inverse;
  }
  pcVar6 = gts_segment_midvertex;
  if (refine_func != (GtsRefineFunc)0x0) {
    pcVar6 = refine_func;
  }
  heap = gts_eheap_new(cost_func,cost_data);
  gts_eheap_freeze(heap);
  gts_surface_foreach_edge(surface,create_heap_refine,heap);
  gts_eheap_thaw(heap);
  while (e = (GtsEdge *)gts_eheap_remove_top(heap,&local_3c), e != (GtsEdge *)0x0) {
    gVar2 = gts_eheap_size(heap);
    gVar3 = gts_edge_face_number(e,surface);
    gVar4 = (*stop_func)(local_3c,gVar3 + 2 + gVar2,stop_data);
    if (gVar4 != 0) break;
    klass = surface->edge_class;
    local_20[0] = e;
    v2 = (*pcVar6)(e,surface->vertex_class,refine_data);
    e = gts_edge_new(klass,(local_20[0]->segment).v1,v2);
    gts_eheap_insert(heap,e);
    p = gts_edge_new(klass,(local_20[0]->segment).v2,v2);
    gts_eheap_insert(heap,p);
    pGVar1 = local_20[0]->triangles;
    while (pGVar1 != (GSList *)0x0) {
      t = (GtsTriangle *)pGVar1->data;
      gts_triangle_vertices_edges
                (t,local_20[0],&v1,&local_28,&local_2c,local_20,&local_30,&local_34);
      e3 = gts_edge_new(klass,v2,local_2c);
      gts_eheap_insert(heap,e3);
      e1 = e;
      if ((e->segment).v1 != local_28) {
        e1 = p;
        p = e;
      }
      pGVar5 = (GSList *)g_slist_prepend();
      p->triangles = pGVar5;
      pGVar5 = (GSList *)g_slist_prepend();
      e = local_30;
      e3->triangles = pGVar5;
      pGVar5 = (GSList *)g_slist_remove();
      t->e2 = e3;
      t->e1 = p;
      e->triangles = pGVar5;
      t->e3 = local_34;
      f = gts_face_new(surface->face_class,e1,local_30,e3);
      gts_surface_add_face(surface,f);
      pGVar1 = (GSList *)(&pGVar1->data)[1];
      e = p;
      p = e1;
    }
    g_slist_free();
    local_20[0]->triangles = (GSList *)0x0;
    gts_object_destroy((GtsObject *)local_20[0]);
  }
  gts_eheap_destroy(heap);
  return;
}



void gts_surface_write_oogl_boundary(GtsSurface *s,FILE *fptr)

{
  char "gts_surface_write_oogl_boundary" [32];
  gpointer data [2];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write_oogl_boundary",0x815fd1b);
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[0] = fptr;
    data[1] = s;
    fwrite("LIST {\n",1,7,(FILE *)fptr);
    gts_surface_foreach_edge(s,write_edge_oogl_boundary,data);
    fwrite("}\n",1,2,(FILE *)fptr);
    return;
  }
  g_return_if_fail_warning(0,0x8161aa0,"fptr != NULL");
  return;
}



void write_edge_oogl_boundary(GtsSegment *s,gpointer *data)

{
  gdouble gVar1;
  gdouble gVar2;
  gdouble gVar3;
  gdouble gVar4;
  gdouble gVar5;
  gdouble gVar6;
  anon_subr_GtsColor_GtsObject_ptr_for_color *paVar7;
  GtsVertex *pGVar8;
  GtsVertex *pGVar9;
  GtsFace *pGVar10;
  GtsColor c;
  
  pGVar10 = gts_edge_is_boundary((GtsEdge *)s,(GtsSurface *)data[1]);
  if (pGVar10 != (GtsFace *)0x0) {
    paVar7 = ((s->object).klass)->color;
    if (paVar7 == (anon_subr_GtsColor_GtsObject_ptr_for_color *)0x0) {
      pGVar8 = s->v2;
      pGVar9 = s->v1;
      gVar1 = (pGVar8->p).z;
      gVar2 = (pGVar8->p).y;
      gVar3 = (pGVar8->p).x;
      gVar4 = (pGVar9->p).z;
      gVar5 = (pGVar9->p).y;
      gVar6 = (pGVar9->p).x;
      __fprintf_chk(*data,1,"VECT 1 2 0 2 0 %g %g %g %g %g %g\n",SUB84(gVar6,0),
                    (int)((ulonglong)gVar6 >> 0x20),SUB84(gVar5,0),(int)((ulonglong)gVar5 >> 0x20),
                    SUB84(gVar4,0),(int)((ulonglong)gVar4 >> 0x20),SUB84(gVar3,0),
                    (int)((ulonglong)gVar3 >> 0x20),SUB84(gVar2,0),(int)((ulonglong)gVar2 >> 0x20),
                    SUB84(gVar1,0),(int)((ulonglong)gVar1 >> 0x20));
      return;
    }
    (*paVar7)(&c,(GtsObject *)s);
    pGVar8 = s->v1;
    pGVar9 = s->v2;
    gVar1 = (pGVar9->p).z;
    gVar2 = (pGVar9->p).y;
    gVar3 = (pGVar9->p).x;
    gVar4 = (pGVar8->p).z;
    gVar5 = (pGVar8->p).y;
    gVar6 = (pGVar8->p).x;
    __fprintf_chk(*data,1,"VECT 1 2 1 2 1 %g %g %g %g %g %g %g %g %g 1.\n",SUB84(gVar6,0),
                  (int)((ulonglong)gVar6 >> 0x20),SUB84(gVar5,0),(int)((ulonglong)gVar5 >> 0x20),
                  SUB84(gVar4,0),(int)((ulonglong)gVar4 >> 0x20),SUB84(gVar3,0),
                  (int)((ulonglong)gVar3 >> 0x20),SUB84(gVar2,0),(int)((ulonglong)gVar2 >> 0x20),
                  SUB84(gVar1,0),(int)((ulonglong)gVar1 >> 0x20),SUB84((double)(float)c.r,0),
                  (int)((ulonglong)(double)(float)c.r >> 0x20),(double)(float)c.g,(double)(float)c.b
                 );
  }
  return;
}



void gts_surface_write_vtk(GtsSurface *s,FILE *fptr)

{
  char "gts_surface_write_vtk" [22];
  GtsSurfaceStats stats;
  gpointer data [2];
  undefined4 local_10;
  
  local_10 = 0;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write_vtk",0x815fd1b);
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[1] = &local_10;
    data[0] = fptr;
    gts_surface_stats(s,&stats);
    __fprintf_chk(fptr,1,
                  "# vtk DataFile Version 2.0\nGenerated by GTS\nASCII\nDATASET POLYDATA\nPOINTS %u float\n"
                  ,stats.edges_per_vertex.n);
    gts_surface_foreach_vertex(s,write_vertex_vtk,data);
    __fprintf_chk(fptr,1,"POLYGONS %u %u\n",stats.n_faces,stats.n_faces * 4);
    gts_surface_foreach_face(s,write_face_vtk,fptr);
    gts_surface_foreach_vertex(s,gts_object_reset_reserved,(gpointer)0x0);
    return;
  }
  g_return_if_fail_warning(0,0x8161ac0,"fptr != NULL");
  return;
}



void write_face_vtk(GtsTriangle *t,FILE *fp)

{
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10 [3];
  
  gts_triangle_vertices(t,local_10,&local_14,&local_18);
  __fprintf_chk(fp,1,"3 %u %u %u\n",(local_10[0]->p).object.reserved,(local_14->p).object.reserved,
                (local_18->p).object.reserved);
  return;
}



void write_vertex_vtk(GtsPoint *p,gpointer *data)

{
  gpointer *ppvVar1;
  gpointer pvVar2;
  
  __fprintf_chk(*data,1,"%g %g %g\n",p->x,p->y,p->z);
  ppvVar1 = (gpointer *)data[1];
  pvVar2 = *ppvVar1;
  (p->object).reserved = pvVar2;
  *ppvVar1 = (gpointer)((int)pvVar2 + 1);
  return;
}



void gts_surface_write_oogl(GtsSurface *s,FILE *fptr)

{
  char "gts_surface_write_oogl" [23];
  GtsSurfaceStats stats;
  gpointer data [2];
  undefined4 local_10;
  
  local_10 = 0;
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write_oogl",0x815fd1b);
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[1] = &local_10;
    data[0] = fptr;
    gts_surface_stats(s,&stats);
    if ((s->vertex_class->parent_class).parent_class.color ==
        (anon_subr_GtsColor_GtsObject_ptr_for_color *)0x0) {
      fwrite(&DAT_081612cd,1,4,(FILE *)fptr);
    }
    else {
      fwrite(&DAT_081612cc,1,5,(FILE *)fptr);
    }
    __fprintf_chk(fptr,1,0x81612c2,stats.edges_per_vertex.n,stats.n_faces,stats.faces_per_edge.n);
    gts_surface_foreach_vertex(s,write_vertex_oogl,data);
    gts_surface_foreach_face(s,write_face_oogl,fptr);
    gts_surface_foreach_vertex(s,gts_object_reset_reserved,(gpointer)0x0);
    return;
  }
  g_return_if_fail_warning(0,0x8161ad6,"fptr != NULL");
  return;
}



void gts_range_print(GtsRange *r,FILE *fptr)

{
  char "gts_range_print" [16];
  
  if (r == (GtsRange *)0x0) {
    g_return_if_fail_warning(0,"gts_range_print",0x8161203);
    return;
  }
  if (fptr != (FILE *)0x0) {
    __fprintf_chk(fptr,1,"min: %g mean: %g | %g max: %g",r->min,r->mean,r->stddev,r->max);
    return;
  }
  g_return_if_fail_warning(0,0x8161b43,"fptr != NULL");
  return;
}



void surface_write(GtsObject *object,FILE *fptr)

{
  GtsObjectClass *pGVar1;
  
  pGVar1 = (GtsObjectClass *)"GtsVertexBinary";
  if (*(int *)object[2].klass[1].info.name == 0) {
    pGVar1 = object[2].klass;
  }
  __fprintf_chk(fptr,1," %s %s %s %s",object->klass,object[1].reserved,object[1].flags,pGVar1);
  return;
}



void write_face_oogl(GtsTriangle *t,FILE *fp)

{
  anon_subr_GtsColor_GtsObject_ptr_for_color *paVar1;
  GtsColor c;
  GtsVertex *local_18;
  GtsVertex *local_14;
  GtsVertex *local_10;
  
  gts_triangle_vertices(t,&local_10,&local_14,&local_18);
  __fprintf_chk(fp,1,"3 %u %u %u",(local_10->p).object.reserved,(local_14->p).object.reserved,
                (local_18->p).object.reserved);
  paVar1 = ((t->object).klass)->color;
  if (paVar1 != (anon_subr_GtsColor_GtsObject_ptr_for_color *)0x0) {
    (*paVar1)(&c,(GtsObject *)t);
    __fprintf_chk(fp,1,&DAT_08161318,(double)(float)c.r,(double)(float)c.g,(double)(float)c.b);
    return;
  }
  fputc(10,(FILE *)fp);
  return;
}



void write_vertex_oogl(GtsPoint *p,gpointer *data)

{
  FILE *__stream;
  anon_subr_GtsColor_GtsObject_ptr_for_color *paVar1;
  gpointer *ppvVar2;
  gpointer pvVar3;
  GtsColor c;
  
  __stream = (FILE *)*data;
  __fprintf_chk(__stream,1,"%g %g %g",SUB84(p->x,0),(int)((ulonglong)p->x >> 0x20),SUB84(p->y,0),
                (int)((ulonglong)p->y >> 0x20),SUB84(p->z,0),(int)((ulonglong)p->z >> 0x20));
  paVar1 = ((p->object).klass)->color;
  if (paVar1 == (anon_subr_GtsColor_GtsObject_ptr_for_color *)0x0) {
    fputc(10,__stream);
  }
  else {
    (*paVar1)(&c,(GtsObject *)p);
    __fprintf_chk(__stream,1," %g %g %g 1.0\n",SUB84((double)(float)c.r,0),
                  (int)((ulonglong)(double)(float)c.r >> 0x20),SUB84((double)(float)c.g,0),
                  (int)((ulonglong)(double)(float)c.g >> 0x20),SUB84((double)(float)c.b,0),
                  (int)((ulonglong)(double)(float)c.b >> 0x20));
  }
  ppvVar2 = (gpointer *)data[1];
  pvVar3 = *ppvVar2;
  (p->object).reserved = pvVar3;
  *ppvVar2 = (gpointer)((int)pvVar3 + 1);
  return;
}



void gts_surface_write(GtsSurface *s,FILE *fptr)

{
  anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *paVar1;
  char "gts_surface_write" [18];
  gpointer pvVar2;
  gpointer pvVar3;
  GtsSurfaceStats stats;
  gpointer data [4];
  undefined4 local_20 [4];
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_write",0x815fd1b);
    return;
  }
  if (fptr != (FILE *)0x0) {
    data[1] = local_20;
    data[0] = fptr;
    pvVar2 = (gpointer)g_hash_table_new(0,0);
    data[2] = pvVar2;
    pvVar3 = (gpointer)g_hash_table_new(0,0);
    data[3] = pvVar3;
    gts_surface_stats(s,&stats);
    __fprintf_chk(fptr,1,0x816130f,stats.edges_per_vertex.n,stats.faces_per_edge.n,stats.n_faces);
    paVar1 = ((s->object).klass)->write;
    if (paVar1 != (anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *)0x0) {
      (*paVar1)((GtsObject *)s,fptr);
    }
    fputc(10,(FILE *)fptr);
    local_20[0] = 0;
    gts_surface_foreach_vertex(s,write_vertex,data);
    local_20[0] = 0;
    if ((s->vertex_class->parent_class).binary != 0) {
      fputc(10,(FILE *)fptr);
    }
    gts_surface_foreach_edge(s,write_edge,data);
    gts_surface_foreach_face(s,write_face,data);
    g_hash_table_destroy(pvVar2);
    g_hash_table_destroy(pvVar3);
    return;
  }
  g_return_if_fail_warning(0,0x8161aed,"fptr != NULL");
  return;
}



void write_face(GtsTriangle *t,gpointer *data)

{
  anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *paVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  
  uVar2 = g_hash_table_lookup(data[3],t->e3);
  uVar3 = g_hash_table_lookup(data[3],t->e2);
  uVar4 = g_hash_table_lookup(data[3],t->e1);
  __fprintf_chk(*data,1,0x816130f,uVar4,uVar3,uVar2);
  paVar1 = ((t->object).klass)->write;
  if (paVar1 != (anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *)0x0) {
    (*paVar1)((GtsObject *)t,(FILE *)*data);
  }
  fputc(10,(FILE *)*data);
  return;
}



void write_edge(GtsSegment *s,gpointer *data)

{
  anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *paVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  
  uVar2 = g_hash_table_lookup(data[2],s->v2);
  uVar3 = g_hash_table_lookup(data[2],s->v1);
  __fprintf_chk(*data,1,0x8161312,uVar3,uVar2);
  paVar1 = ((s->object).klass)->write;
  if (paVar1 != (anon_subr_void_GtsObject_ptr_FILE_ptr_for_write *)0x0) {
    (*paVar1)((GtsObject *)s,(FILE *)*data);
  }
  fputc(10,(FILE *)*data);
  iVar4 = *(int *)data[1] + 1;
  *(int *)data[1] = iVar4;
  g_hash_table_insert(data[3],s,iVar4);
  return;
}



void write_vertex(GtsPoint *p,gpointer *data)

{
  int iVar1;
  
  (*((p->object).klass)->write)((GtsObject *)p,(FILE *)*data);
  if (*(int *)(p->object).klass[1].info.name == 0) {
    fputc(10,(FILE *)*data);
  }
  iVar1 = *(int *)data[1] + 1;
  *(int *)data[1] = iVar1;
  g_hash_table_insert(data[2],p,iVar1);
  return;
}



void gts_surface_print_stats(GtsSurface *s,FILE *fptr)

{
  char "gts_surface_print_stats" [24];
  GtsSurfaceQualityStats qstats;
  GtsSurfaceStats stats;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_print_stats",0x815fd1b);
    return;
  }
  if (fptr != (FILE *)0x0) {
    gts_surface_stats(s,&stats);
    gts_surface_quality_stats(s,&qstats);
    __fprintf_chk(fptr,1,
                  "# vertices: %u edges: %u faces: %u\n# Connectivity statistics\n#   incompatible faces: %u\n#   duplicate faces: %u\n#   boundary edges: %u\n#   duplicate edges: %u\n#   non-manifold edges: %u\n"
                  ,stats.edges_per_vertex.n,stats.faces_per_edge.n,stats.n_faces,
                  stats.n_incompatible_faces,stats.n_duplicate_faces,stats.n_boundary_edges,
                  stats.n_duplicate_edges,stats.n_non_manifold_edges);
    fwrite("#   edges per vertex: ",1,0x16,(FILE *)fptr);
    gts_range_print(&stats.edges_per_vertex,fptr);
    fwrite("\n#   faces per edge: ",1,0x15,(FILE *)fptr);
    gts_range_print(&stats.faces_per_edge,fptr);
    fwrite("\n# Geometric statistics\n#   face quality: ",1,0x2a,(FILE *)fptr);
    gts_range_print((GtsRange *)&qstats,fptr);
    fwrite("\n#   face area  : ",1,0x12,(FILE *)fptr);
    gts_range_print(&qstats.face_area,fptr);
    fwrite("\n#   edge length : ",1,0x13,(FILE *)fptr);
    gts_range_print(&qstats.edge_length,fptr);
    fputc(10,(FILE *)fptr);
    return;
  }
  g_return_if_fail_warning(0,0x8161aff,"fptr != NULL");
  return;
}



void quality_foreach_face(GtsTriangle *t,GtsSurfaceQualityStats *stats)

{
  float10 fVar1;
  
  fVar1 = (float10)gts_triangle_quality(t);
  gts_range_add_value((GtsRange *)stats,(gdouble)(double)fVar1);
  fVar1 = (float10)gts_triangle_area(t);
  gts_range_add_value(&stats->face_area,(gdouble)(double)fVar1);
  return;
}



void quality_foreach_edge(GtsSegment *s,GtsSurfaceQualityStats *stats)

{
  undefined4 *puVar1;
  GtsObjectClass *pGVar2;
  float10 fVar3;
  double local_28;
  
  pGVar2 = s[1].object.klass;
  fVar3 = (float10)gts_point_distance(s->v1,s->v2);
  local_28 = (double)fVar3;
  gts_range_add_value(&stats->edge_length,(gdouble)local_28);
  if (pGVar2 != (GtsObjectClass *)0x0) {
    do {
      puVar1 = *(undefined4 **)((pGVar2->info).name + 4);
      if (puVar1 == (undefined4 *)0x0) {
        return;
      }
      do {
        fVar3 = (float10)gts_triangles_angle(*(undefined4 *)(pGVar2->info).name,*puVar1,
                                             (int)((ulonglong)local_28 >> 0x20));
        local_28 = (double)ABS(fVar3);
        gts_range_add_value(&stats->edge_angle,(gdouble)local_28);
        puVar1 = (undefined4 *)puVar1[1];
      } while (puVar1 != (undefined4 *)0x0);
      pGVar2 = *(GtsObjectClass **)((pGVar2->info).name + 4);
    } while (pGVar2 != (GtsObjectClass *)0x0);
  }
  return;
}



void stats_foreach_face(GtsTriangle *t,GtsSurfaceStats *stats)

{
  gboolean gVar1;
  GtsTriangle *pGVar2;
  
  gVar1 = gts_face_is_compatible((GtsFace *)t,stats->parent);
  if (gVar1 == 0) {
    stats->n_incompatible_faces = stats->n_incompatible_faces + 1;
  }
  pGVar2 = gts_triangle_is_duplicate(t);
  if (pGVar2 != (GtsTriangle *)0x0) {
    stats->n_duplicate_faces = stats->n_duplicate_faces + 1;
  }
  stats->n_faces = stats->n_faces + 1;
  return;
}



void stats_foreach_edge(GtsEdge *e,GtsSurfaceStats *stats)

{
  guint gVar1;
  GtsSegment *pGVar2;
  
  gVar1 = gts_edge_face_number(e,stats->parent);
  pGVar2 = gts_segment_is_duplicate((GtsSegment *)e);
  if (pGVar2 != (GtsSegment *)0x0) {
    stats->n_duplicate_edges = stats->n_duplicate_edges + 1;
  }
  if (gVar1 == 1) {
    stats->n_boundary_edges = stats->n_boundary_edges + 1;
  }
  else {
    if (2 < gVar1) {
      stats->n_non_manifold_edges = stats->n_non_manifold_edges + 1;
    }
  }
  gts_range_add_value(&stats->faces_per_edge,(gdouble)(double)(ulonglong)gVar1);
  return;
}



void stats_foreach_vertex(GtsVertex *v,GtsSurfaceStats *stats)

{
  GSList *pGVar1;
  GtsEdge *e;
  GtsObjectClass *pGVar2;
  GtsFace *pGVar3;
  GtsObjectClass *pGVar4;
  uint uVar5;
  
  uVar5 = 0;
  pGVar1 = v->segments;
  do {
    if (pGVar1 == (GSList *)0x0) {
      gts_range_add_value(&stats->edges_per_vertex,(gdouble)(double)(ulonglong)uVar5);
      return;
    }
    pGVar2 = (GtsObjectClass *)gts_edge_class();
    e = (GtsEdge *)pGVar1->data;
    if (pGVar2 == (GtsObjectClass *)0x0) {
      g_return_if_fail_warning(0);
    }
    else {
      if (e != (GtsEdge *)0x0) {
        pGVar4 = (e->segment).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0);
        }
        else {
          do {
            if (pGVar2 == pGVar4) {
              pGVar3 = gts_edge_has_parent_surface(e,stats->parent);
              uVar5 = (uVar5 + 1) - (uint)(pGVar3 == (GtsFace *)0x0);
              break;
            }
            pGVar4 = pGVar4->parent_class;
          } while (pGVar4 != (GtsObjectClass *)0x0);
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



GtsSurface *
gts_surface_new(GtsSurfaceClass *klass,GtsFaceClass *face_class,GtsEdgeClass *edge_class,
               GtsVertexClass *vertex_class)

{
  GtsSurface *pGVar1;
  
  pGVar1 = (GtsSurface *)gts_object_new((GtsObjectClass *)klass);
  pGVar1->vertex_class = vertex_class;
  pGVar1->edge_class = edge_class;
  pGVar1->face_class = face_class;
  return pGVar1;
}



guint gts_surface_read(GtsSurface *surface,GtsFile *f)

{
  GtsObject *object;
  anon_subr_void_GtsObject_ptr_ptr_GtsFile_ptr_for_read *paVar1;
  char "gts_surface_read" [17];
  uint uVar2;
  int iVar3;
  int iVar4;
  GtsVertexClass *klass;
  GtsTokenType GVar5;
  GtsObject **ppGVar6;
  GtsVertex *pGVar7;
  uint uVar8;
  int iVar9;
  GtsVertex *local_64;
  GtsVertex *pGVar10;
  GtsVertex *local_44;
  GtsVertex *local_40;
  GtsFace *local_28;
  GtsEdge *local_24;
  GtsObject *local_20 [4];
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_read","surface != NULL");
    return 1;
  }
  if (f == (GtsFile *)0x0) {
    g_return_if_fail_warning(0,0x8161b97,"f != NULL");
    return 1;
  }
  if (f->type != GTS_INT) {
    gts_file_error(f,"expecting an integer (number of vertices)");
    return f->line;
  }
  local_40 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
  gts_file_next_token(f);
  if (f->type != GTS_INT) {
    gts_file_error(f,"expecting an integer (number of edges)");
    return f->line;
  }
  local_44 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
  gts_file_next_token(f);
  if (f->type != GTS_INT) {
    gts_file_error(f,"expecting an integer (number of faces)");
    return f->line;
  }
  local_64 = (GtsVertex *)0xa;
  uVar2 = strtol(f->token->str,(char **)0x0,10);
  gts_file_next_token(f);
  if (f->type == GTS_STRING) {
    gts_file_next_token(f);
    if (f->type != GTS_STRING) {
      gts_file_error(f,"expecting a string (GtsFaceClass)");
      return f->line;
    }
    gts_file_next_token(f);
    if (f->type != GTS_STRING) {
      gts_file_error(f,"expecting a string (GtsEdgeClass)");
      return f->line;
    }
    gts_file_next_token(f);
    if (f->type != GTS_STRING) {
      gts_file_error(f,"expecting a string (GtsVertexClass)");
      return f->line;
    }
    iVar3 = strcmp(f->token->str,"GtsVertexBinary");
    if (iVar3 == 0) {
      (surface->vertex_class->parent_class).binary = 1;
    }
    else {
      (surface->vertex_class->parent_class).binary = 0;
      gts_file_first_token_after(f,10);
    }
  }
  else {
    gts_file_first_token_after(f,10);
  }
  if (uVar2 == 0) {
    return 0;
  }
  iVar3 = g_malloc((int)local_40 * 4 + 4);
  iVar4 = g_malloc((int)local_44 * 4 + 4);
  if (local_40 == (GtsVertex *)0x0) {
    pGVar7 = (GtsVertex *)0x0;
    klass = surface->vertex_class;
LAB_0813487a:
    if (f->type == GTS_ERROR) goto LAB_08134a57;
  }
  else {
    if (f->type == GTS_ERROR) {
      pGVar7 = (GtsVertex *)0x0;
      klass = surface->vertex_class;
    }
    else {
      klass = surface->vertex_class;
      pGVar7 = (GtsVertex *)0x0;
      do {
        local_20[0] = gts_object_new((GtsObjectClass *)klass);
        (*(surface->vertex_class->parent_class).parent_class.read)(local_20,f);
        if (f->type == GTS_ERROR) {
          gts_object_destroy(local_20[0]);
          klass = surface->vertex_class;
        }
        else {
          klass = surface->vertex_class;
          if ((klass->parent_class).binary == 0) {
            gts_file_first_token_after(f,10);
            klass = surface->vertex_class;
          }
          *(GtsObject **)(iVar3 + (int)pGVar7 * 4) = local_20[0];
          pGVar7 = (GtsVertex *)((int)&(pGVar7->p).object.klass + 1);
        }
        if (local_40 <= pGVar7) goto LAB_0813487a;
      } while (f->type != GTS_ERROR);
    }
LAB_08134a57:
    local_40 = pGVar7;
  }
  if ((klass->parent_class).binary != 0) {
    gts_file_first_token_after(f,10);
  }
  if (local_44 == (GtsVertex *)0x0) {
    pGVar7 = (GtsVertex *)0x0;
LAB_0813495d:
    GVar5 = f->type;
    if (GVar5 != GTS_ERROR) goto LAB_0813496d;
  }
  else {
    GVar5 = f->type;
    if (GVar5 == GTS_ERROR) {
      pGVar7 = (GtsVertex *)0x0;
    }
    else {
      pGVar7 = (GtsVertex *)0x0;
      do {
        if (GVar5 == GTS_INT) {
          local_64 = (GtsVertex *)0xa;
          pGVar10 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
          if ((local_40 < pGVar10) || (pGVar10 == (GtsVertex *)0x0)) {
            gts_file_error(f,"vertex index `%d\' is out of range `[1,%d]\'",pGVar10,local_40);
            local_64 = pGVar10;
          }
          else {
            gts_file_next_token(f);
            if (f->type == GTS_INT) {
              local_64 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
              if ((local_40 < local_64) || (local_64 == (GtsVertex *)0x0)) {
                gts_file_error(f,"vertex index `%d\' is out of range `[1,%d]\'",local_64,local_40);
              }
              else {
                local_64 = *(GtsVertex **)(iVar3 + -4 + (int)local_64 * 4);
                local_24 = gts_edge_new(surface->edge_class,
                                        *(GtsVertex **)(iVar3 + -4 + (int)pGVar10 * 4),local_64);
                gts_file_next_token(f);
                if ((f->type != 10) &&
                   (paVar1 = (surface->edge_class->parent_class).parent_class.read,
                   paVar1 != (anon_subr_void_GtsObject_ptr_ptr_GtsFile_ptr_for_read *)0x0)) {
                  (*paVar1)((GtsObject **)&local_24,f);
                }
                gts_file_first_token_after(f,10);
                *(GtsEdge **)(iVar4 + (int)pGVar7 * 4) = local_24;
                pGVar7 = (GtsVertex *)((int)&(pGVar7->p).object.klass + 1);
              }
            }
            else {
              gts_file_error(f,"expecting an integer (second vertex index)");
            }
          }
        }
        else {
          gts_file_error(f,"expecting an integer (first vertex index)",local_64);
        }
        if (local_44 <= pGVar7) goto LAB_0813495d;
        GVar5 = f->type;
      } while (GVar5 != GTS_ERROR);
    }
  }
  local_44 = pGVar7;
LAB_0813496d:
  uVar8 = 0;
  do {
    if (GVar5 == GTS_ERROR) {
LAB_08134b56:
      gts_allow_floating_vertices = 1;
      if (local_40 != (GtsVertex *)0x0) {
        iVar9 = (int)&local_40[-1].segments + 3;
        ppGVar6 = (GtsObject **)(iVar3 + iVar9 * 4);
        while( true ) {
          object = *ppGVar6;
          ppGVar6 = ppGVar6 + -1;
          gts_object_destroy(object);
          if (iVar9 == 0) break;
          iVar9 = iVar9 + -1;
        }
      }
      gts_allow_floating_vertices = 0;
LAB_08134a29:
      g_free(iVar3);
      g_free(iVar4);
      if (f->type != GTS_ERROR) {
        return 0;
      }
      return f->line;
    }
    if (GVar5 == GTS_INT) {
      local_64 = (GtsVertex *)0xa;
      pGVar7 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
      if ((local_44 < pGVar7) || (pGVar7 == (GtsVertex *)0x0)) {
        gts_file_error(f,"edge index `%d\' is out of range `[1,%d]\'",pGVar7,local_44);
        local_64 = pGVar7;
      }
      else {
        gts_file_next_token(f);
        if (f->type == GTS_INT) {
          local_64 = (GtsVertex *)0xa;
          pGVar10 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
          if ((local_44 < pGVar10) || (pGVar10 == (GtsVertex *)0x0)) {
            gts_file_error(f,"edge index `%d\' is out of range `[1,%d]\'",pGVar10,local_44);
            local_64 = pGVar10;
          }
          else {
            gts_file_next_token(f);
            if (f->type == GTS_INT) {
              local_64 = (GtsVertex *)strtol(f->token->str,(char **)0x0,10);
              if ((local_44 < local_64) || (local_64 == (GtsVertex *)0x0)) {
                gts_file_error(f,"edge index `%d\' is out of range `[1,%d]\'",local_64,local_44);
              }
              else {
                iVar9 = (int)local_64 * 4;
                local_64 = *(GtsVertex **)(iVar4 + -4 + (int)pGVar10 * 4);
                local_28 = gts_face_new(surface->face_class,
                                        *(GtsEdge **)(iVar4 + -4 + (int)pGVar7 * 4),
                                        (GtsEdge *)local_64,*(GtsEdge **)(iVar4 + -4 + iVar9));
                gts_file_next_token(f);
                if ((f->type != 10) &&
                   (paVar1 = (surface->face_class->parent_class).parent_class.read,
                   paVar1 != (anon_subr_void_GtsObject_ptr_ptr_GtsFile_ptr_for_read *)0x0)) {
                  (*paVar1)((GtsObject **)&local_28,f);
                }
                uVar8 = uVar8 + 1;
                gts_file_first_token_after(f,10);
                gts_surface_add_face(surface,local_28);
              }
            }
            else {
              gts_file_error(f,"expecting an integer (third edge index)");
            }
          }
        }
        else {
          gts_file_error(f,"expecting an integer (second edge index)");
        }
      }
    }
    else {
      gts_file_error(f,"expecting an integer (first edge index)",local_64);
    }
    if (uVar2 <= uVar8) {
      if (f->type != GTS_ERROR) goto LAB_08134a29;
      goto LAB_08134b56;
    }
    GVar5 = f->type;
  } while( true );
}



void gts_surface_remove_face(GtsSurface *s,GtsFace *f)

{
  code *pcVar1;
  char "gts_surface_remove_face" [24];
  GSList *pGVar2;
  
  if (s == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_surface_remove_face",0x815fd1b);
    return;
  }
  if (f == (GtsFace *)0x0) {
    g_return_if_fail_warning(0,0x8161ba8,"f != NULL");
    return;
  }
  if (s->keep_faces != 0) {
                    // WARNING: Subroutine does not return
    g_assertion_message_expr(0,"../../src/gts/surface.c",0xb8,0x8161ba8,"s->keep_faces == FALSE");
  }
  g_hash_table_remove(s->faces,f);
  pGVar2 = (GSList *)g_slist_remove(f->surfaces,s);
  f->surfaces = pGVar2;
  pcVar1 = *(code **)((s->object).klass[1].info.name + 4);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(s,f);
  }
  if ((((*(byte *)&(f->triangle).object.flags & 1) == 0) && (gts_allow_floating_faces == 0)) &&
     (f->surfaces == (GSList *)0x0)) {
    gts_object_destroy((GtsObject *)f);
    return;
  }
  return;
}



void traverse_remaining(GtsFace *f,gpointer *data_1)

{
  GtsObjectClass **ppGVar1;
  undefined4 *puVar2;
  GtsObjectClass *pGVar3;
  GtsVertexClass *pGVar4;
  GtsObjectClass *pGVar5;
  GtsFace *pGVar6;
  GtsFace *pGVar7;
  int iVar8;
  GtsSurface *s;
  undefined4 uVar9;
  gpointer data [2];
  GtsFace *local_20 [4];
  
  ppGVar1 = (GtsObjectClass **)*data_1;
  puVar2 = (undefined4 *)data_1[1];
  iVar8 = g_slist_length(f->surfaces);
  if (iVar8 == 1) {
    pGVar3 = ppGVar1[4];
    pGVar4 = (GtsVertexClass *)ppGVar1[6];
    pGVar5 = ppGVar1[5];
    s = (GtsSurface *)gts_object_new(*ppGVar1);
    local_20[0] = (GtsFace *)0x0;
    *(GtsObjectClass **)&s->edge_class = pGVar5;
    s->vertex_class = pGVar4;
    *(GtsObjectClass **)&s->face_class = pGVar3;
    uVar9 = g_slist_prepend(*puVar2,s);
    *puVar2 = uVar9;
    data[1] = local_20;
    data[0] = s;
    traverse_manifold((GtsTriangle *)f,s);
    gts_surface_foreach_edge(s,non_manifold_edges,data);
    pGVar6 = (GtsFace *)0x0;
    pGVar7 = local_20[0];
    while (pGVar7 != (GtsFace *)0x0) {
      gts_surface_remove_face(s,(GtsFace *)(pGVar7->triangle).object.klass);
      pGVar7 = (GtsFace *)(pGVar7->triangle).object.reserved;
      pGVar6 = local_20[0];
    }
    g_slist_free(pGVar6);
  }
  return;
}



void traverse_boundary(GtsEdge *e,gpointer *data_1)

{
  undefined4 *puVar1;
  GtsFaceClass *pGVar2;
  GtsVertexClass *pGVar3;
  GtsEdgeClass *pGVar4;
  GtsFace *pGVar5;
  GtsFace *t;
  int iVar6;
  GtsSurface *surface;
  undefined4 uVar7;
  gpointer data [2];
  GtsFace *local_20 [4];
  
  surface = (GtsSurface *)*data_1;
  puVar1 = (undefined4 *)data_1[1];
  t = gts_edge_is_boundary(e,surface);
  if ((t != (GtsFace *)0x0) && (iVar6 = g_slist_length(t->surfaces), iVar6 == 1)) {
    pGVar2 = surface->face_class;
    pGVar3 = surface->vertex_class;
    pGVar4 = surface->edge_class;
    surface = (GtsSurface *)gts_object_new((GtsObjectClass *)(surface->object).klass);
    local_20[0] = (GtsFace *)0x0;
    surface->edge_class = pGVar4;
    surface->vertex_class = pGVar3;
    surface->face_class = pGVar2;
    uVar7 = g_slist_prepend(*puVar1,surface);
    *puVar1 = uVar7;
    data[1] = local_20;
    data[0] = surface;
    traverse_manifold((GtsTriangle *)t,surface);
    gts_surface_foreach_edge(surface,non_manifold_edges,data);
    pGVar5 = (GtsFace *)0x0;
    t = local_20[0];
    while (t != (GtsFace *)0x0) {
      gts_surface_remove_face(surface,(GtsFace *)(t->triangle).object.klass);
      t = (GtsFace *)(t->triangle).object.reserved;
      pGVar5 = local_20[0];
    }
    g_slist_free(pGVar5);
  }
  return;
}



GtsSurfaceClass * gts_surface_class(void)

{
  GtsSurfaceClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo surface_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsSurfaceClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &surface_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    surface_info.name._0_4_ = 0x53737447;
    surface_info.name._4_4_ = 0x61667275;
    surface_info.name._8_4_ = 0x6563;
    do {
      *(undefined4 *)(&stack0x00000020 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsSurfaceClass *)((klass->parent_class).info.name + 4);
    } while (klass < (GtsSurfaceClass *)&DAT_0000001c);
    surface_info.object_size = 0x20;
    surface_info.class_size = 100;
    surface_info.class_init_func = surface_class_init;
    surface_info.object_init_func = surface_init;
    parent_class = gts_object_class();
    klass = (GtsSurfaceClass *)gts_object_class_new(parent_class,&surface_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Exceeded maximum restarts with more pending

void surface_destroy(GtsObject *object)

{
  GtsSurfaceClass *pGVar1;
  
  gts_surface_foreach_face((GtsSurface *)object,destroy_foreach_face,object);
  g_hash_table_destroy(object[1].klass);
  pGVar1 = gts_surface_class();
                    // WARNING: Could not recover jumptable at 0x0813518c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar1->parent_class).parent_class)->destroy)();
  return;
}



void surface_init(GtsSurface *surface)

{
  GHashTable *pGVar1;
  GtsVertexClass *pGVar2;
  GtsEdgeClass *pGVar3;
  GtsFaceClass *pGVar4;
  
  pGVar1 = (GHashTable *)g_hash_table_new(0,0);
  surface->faces = pGVar1;
  pGVar2 = gts_vertex_class();
  surface->vertex_class = pGVar2;
  pGVar3 = gts_edge_class();
  surface->edge_class = pGVar3;
  pGVar4 = gts_face_class();
  surface->keep_faces = 0;
  surface->face_class = pGVar4;
  return;
}



void orientable_foreach_edge(GtsEdge *e,gpointer *data)

{
  int *piVar1;
  GtsSurface *s;
  GtsFace *f;
  GtsFace *pGVar2;
  GtsFace *pGVar3;
  GtsObjectClass *pGVar4;
  gboolean gVar5;
  GtsObjectClass *pGVar6;
  GSList *pGVar7;
  GtsFace *local_24;
  GtsFace *local_20;
  
  piVar1 = (int *)*data;
  if (*piVar1 != 0) {
    s = (GtsSurface *)data[1];
    pGVar7 = e->triangles;
    if (pGVar7 != (GSList *)0x0) {
      local_24 = (GtsFace *)0x0;
      local_20 = (GtsFace *)0x0;
      do {
        f = (GtsFace *)pGVar7->data;
        pGVar4 = (GtsObjectClass *)gts_face_class();
        pGVar2 = local_24;
        pGVar3 = local_20;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (f != (GtsFace *)0x0) {
            pGVar6 = (f->triangle).object.klass;
            if (pGVar6 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
            }
            else {
              do {
                if (pGVar4 == pGVar6) {
                  gVar5 = gts_face_has_parent_surface(f,s);
                  if (((gVar5 != 0) && (pGVar3 = f, local_20 != (GtsFace *)0x0)) &&
                     (pGVar2 = f, pGVar3 = local_20, local_24 != (GtsFace *)0x0)) {
                    *piVar1 = 0;
                    pGVar2 = local_24;
                  }
                  break;
                }
                pGVar6 = pGVar6->parent_class;
              } while (pGVar6 != (GtsObjectClass *)0x0);
            }
          }
        }
        local_20 = pGVar3;
        local_24 = pGVar2;
        pGVar7 = (GSList *)(&pGVar7->data)[1];
      } while ((pGVar7 != (GSList *)0x0) && (*piVar1 != 0));
      if ((local_24 != (GtsFace *)0x0) &&
         ((local_20 != (GtsFace *)0x0 &&
          (gVar5 = gts_triangles_are_compatible((GtsTriangle *)local_20,(GtsTriangle *)local_24,e),
          gVar5 == 0)))) {
        *piVar1 = 0;
        return;
      }
    }
  }
  return;
}



gboolean gts_edge_collapse_is_valid(GtsEdge *e)

{
  GSList *pGVar1;
  GtsEdge *e2;
  GtsEdge *e3;
  gpointer pvVar2;
  char "gts_edge_collapse_is_valid" [27];
  GtsObjectClass *pGVar3;
  GtsVertex *pGVar4;
  GtsTriangle *pGVar5;
  GtsFace *pGVar6;
  gboolean gVar7;
  GtsObjectClass *pGVar8;
  GSList *pGVar9;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_collapse_is_valid",0x815fd6c);
  }
  else {
    pGVar1 = ((e->segment).v1)->segments;
    while (pGVar1 != (GSList *)0x0) {
      e2 = (GtsEdge *)pGVar1->data;
      if (e2 != e) {
        pGVar3 = (GtsObjectClass *)gts_edge_class();
        if (pGVar3 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
        else {
          if (e2 != (GtsEdge *)0x0) {
            pGVar8 = (e2->segment).object.klass;
            if (pGVar8 != (GtsObjectClass *)0x0) {
LAB_08135387:
              if (pGVar3 != pGVar8) goto LAB_08135380;
              pGVar4 = (e2->segment).v1;
              if (pGVar4 == (e->segment).v1) {
                pGVar4 = (e2->segment).v2;
              }
              pGVar9 = pGVar4->segments;
              while (pGVar9 != (GSList *)0x0) {
                e3 = (GtsEdge *)pGVar9->data;
                pGVar3 = (GtsObjectClass *)gts_edge_class();
                if (pGVar3 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                }
                else {
                  if (e3 != (GtsEdge *)0x0) {
                    pGVar8 = (e3->segment).object.klass;
                    if (pGVar8 == (GtsObjectClass *)0x0) {
                      g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                    }
                    else {
                      do {
                        if (pGVar3 == pGVar8) {
                          pGVar4 = (e->segment).v2;
                          if (((e3->segment).v1 == pGVar4) || (pGVar4 == (e3->segment).v2)) {
                            pGVar5 = gts_triangle_use_edges(e,e2,e3);
                            if (pGVar5 == (GtsTriangle *)0x0) {
                              return 0;
                            }
                            goto LAB_08135403;
                          }
                          break;
                        }
                        pGVar8 = pGVar8->parent_class;
                      } while (pGVar8 != (GtsObjectClass *)0x0);
                    }
                  }
                }
                pGVar9 = pGVar9->next;
              }
              goto LAB_08135403;
            }
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
        }
      }
LAB_08135403:
      pGVar1 = (GSList *)(&pGVar1->data)[1];
    }
    pGVar6 = gts_edge_is_boundary(e,(GtsSurface *)0x0);
    if (pGVar6 != (GtsFace *)0x0) {
      pvVar2 = e->triangles->data;
      pGVar6 = gts_edge_is_boundary(*(GtsEdge **)((int)pvVar2 + 0xc),(GtsSurface *)0x0);
      if ((pGVar6 != (GtsFace *)0x0) &&
         (pGVar6 = gts_edge_is_boundary(*(GtsEdge **)((int)pvVar2 + 0x10),(GtsSurface *)0x0),
         pGVar6 != (GtsFace *)0x0)) {
        pGVar6 = gts_edge_is_boundary(*(GtsEdge **)((int)pvVar2 + 0x14),(GtsSurface *)0x0);
        return (uint)(pGVar6 == (GtsFace *)0x0);
      }
      return 1;
    }
    gVar7 = gts_vertex_is_boundary((e->segment).v1,(GtsSurface *)0x0);
    if ((gVar7 == 0) ||
       (gVar7 = gts_vertex_is_boundary((e->segment).v2,(GtsSurface *)0x0), gVar7 == 0)) {
      gVar7 = gts_edge_belongs_to_tetrahedron(e);
      return (uint)(gVar7 == 0);
    }
  }
  return 0;
LAB_08135380:
  pGVar8 = pGVar8->parent_class;
  if (pGVar8 == (GtsObjectClass *)0x0) goto LAB_08135403;
  goto LAB_08135387;
}



gboolean gts_edge_collapse_creates_fold(GtsEdge *e,GtsVertex *v,gdouble max)

{
  GtsVertex *v_00;
  GtsVertex *v_01;
  gpointer pvVar1;
  GtsTriangle *t;
  char "gts_edge_collapse_creates_fold" [31];
  GSList *pGVar2;
  GtsObjectClass *pGVar3;
  GSList *triangles;
  GSList *triangles_00;
  GtsEdge *e1;
  GtsObjectClass *pGVar4;
  gboolean gVar5;
  bool bVar6;
  
  if (e == (GtsEdge *)0x0) {
    g_return_if_fail_warning(0,0x81619e4,0x815fd6c);
    return 1;
  }
  if (v == (GtsVertex *)0x0) {
    g_return_if_fail_warning(0,"gts_edge_collapse_creates_fold","v != NULL");
    return 1;
  }
  v_00 = (e->segment).v1;
  v_01 = (e->segment).v2;
  triangles = v_00->segments;
  triangles_00 = triangles;
  while (triangles_00 != (GSList *)0x0) {
    while (pvVar1 = triangles_00->data, v_00 != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      triangles_00 = triangles_00->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v;
      if (triangles_00 == (GSList *)0x0) goto LAB_081355f3;
    }
    triangles_00 = triangles_00->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v;
  }
LAB_081355f3:
  triangles_00 = v_01->segments;
  pGVar2 = triangles_00;
  while (pGVar2 != (GSList *)0x0) {
    while (pvVar1 = pGVar2->data, v_01 != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      pGVar2 = pGVar2->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v;
      if (pGVar2 == (GSList *)0x0) goto LAB_08135628;
    }
    pGVar2 = pGVar2->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v;
  }
LAB_08135628:
  gVar5 = 0;
  bVar6 = true;
  if (triangles != (GSList *)0x0) {
    do {
      e1 = (GtsEdge *)triangles->data;
      pGVar3 = (GtsObjectClass *)gts_edge_class();
      if (pGVar3 == (GtsObjectClass *)0x0) {
        gVar5 = 0;
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        bVar6 = true;
      }
      else {
        if (e1 != (GtsEdge *)0x0) {
          pGVar4 = (e1->segment).object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar3 == pGVar4) {
                if (e1 != e) {
                  triangles_00 = edge_triangles(e1,e);
                  gVar5 = gts_triangles_are_folded
                                    (triangles_00,(e1->segment).v1,(e1->segment).v2,max);
                  g_slist_free(triangles_00);
                  bVar6 = gVar5 == 0;
                  goto LAB_081356b9;
                }
                break;
              }
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
        bVar6 = true;
        gVar5 = 0;
      }
LAB_081356b9:
      triangles = triangles->next;
    } while ((bVar6) && (triangles != (GSList *)0x0));
    triangles_00 = v_01->segments;
  }
  if (bVar6) {
    do {
      if (triangles_00 == (GSList *)0x0) break;
      e1 = (GtsEdge *)triangles_00->data;
      pGVar3 = (GtsObjectClass *)gts_edge_class();
      if (pGVar3 == (GtsObjectClass *)0x0) {
        gVar5 = 0;
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        bVar6 = true;
      }
      else {
        if (e1 != (GtsEdge *)0x0) {
          pGVar4 = (e1->segment).object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar3 == pGVar4) {
                if (e1 != e) {
                  triangles = edge_triangles(e1,e);
                  gVar5 = gts_triangles_are_folded(triangles,(e1->segment).v1,(e1->segment).v2,max);
                  g_slist_free(triangles);
                  bVar6 = gVar5 == 0;
                  goto LAB_08135764;
                }
                break;
              }
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
        bVar6 = true;
        gVar5 = 0;
      }
LAB_08135764:
      triangles_00 = triangles_00->next;
    } while (bVar6);
  }
  if (gVar5 == 0) {
    triangles = gts_vertex_triangles(v_00,(GSList *)0x0);
    triangles_00 = gts_vertex_triangles(v_01,triangles);
    triangles = triangles_00;
    do {
      while( true ) {
        if (triangles == (GSList *)0x0) goto LAB_08135919;
        t = (GtsTriangle *)triangles->data;
        if (((t->e1 != e) && (t->e2 != e)) && (t->e3 != e)) break;
        gVar5 = 0;
        triangles = (GSList *)(&triangles->data)[1];
      }
      e1 = gts_triangle_edge_opposite(t,v);
      if (e1 == (GtsEdge *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr(0,"../../src/gts/surface.c",0x58c,0x81619e4,&DAT_081516e9);
      }
      gVar5 = gts_triangles_are_folded(e1->triangles,(e1->segment).v1,(e1->segment).v2,max);
      triangles = (GSList *)(&triangles->data)[1];
    } while (gVar5 == 0);
LAB_08135919:
    g_slist_free(triangles_00);
  }
  triangles = v_00->segments;
  while (triangles != (GSList *)0x0) {
    while (pvVar1 = triangles->data, v != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      triangles = triangles->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v_00;
      if (triangles == (GSList *)0x0) goto LAB_081357a8;
    }
    triangles = triangles->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v_00;
  }
LAB_081357a8:
  triangles = v_01->segments;
  do {
    if (triangles == (GSList *)0x0) {
      return gVar5;
    }
    while (pvVar1 = triangles->data, v != *(GtsVertex **)((int)pvVar1 + 0xc)) {
      triangles = triangles->next;
      *(GtsVertex **)((int)pvVar1 + 0x10) = v_01;
      if (triangles == (GSList *)0x0) {
        return gVar5;
      }
    }
    triangles = triangles->next;
    *(GtsVertex **)((int)pvVar1 + 0xc) = v_01;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

void gts_surface_coarsen(GtsSurface *surface,GtsKeyFunc *cost_func,gpointer cost_data,
                        GtsCoarsenFunc coarsen_func,gpointer coarsen_data,GtsStopFunc *stop_func,
                        gpointer stop_data,gdouble minangle)

{
  GtsVertex *v;
  GtsVertexClass *pGVar1;
  GtsVertex *v_00;
  GtsObjectClass *pGVar2;
  gpointer p;
  char "gts_surface_coarsen" [20];
  GtsEHeap *heap;
  GtsEdge *e;
  guint gVar3;
  guint gVar4;
  gboolean gVar5;
  GtsObjectClass *v_01;
  GtsEdge *e_00;
  GtsObjectClass *pGVar6;
  int iVar7;
  GtsEHeapPair *pGVar8;
  code *pcVar9;
  GtsObjectClass *pGVar10;
  gpointer *ppvVar11;
  double dVar12;
  GtsObjectClass *local_30;
  gdouble local_24 [2];
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,0x81619b4,"surface != NULL");
  }
  else {
    if (stop_func == (GtsStopFunc *)0x0) {
      g_return_if_fail_warning(0,0x81619b4,"stop_func != NULL");
    }
    else {
      if (cost_func == (GtsKeyFunc *)0x0) {
        cost_func = edge_length2;
      }
      pcVar9 = gts_segment_midvertex;
      if (coarsen_func != (GtsCoarsenFunc)0x0) {
        pcVar9 = coarsen_func;
      }
      heap = gts_eheap_new(cost_func,cost_data);
      dVar12 = cos((double)minangle);
      gts_eheap_freeze(heap);
      gts_surface_foreach_edge(surface,create_heap_coarsen,heap);
      gts_eheap_thaw(heap);
      gts_allow_floating_edges = 1;
LAB_08135a42:
      e = (GtsEdge *)gts_eheap_remove_top(heap,local_24);
      if (e != (GtsEdge *)0x0) {
        if (
            179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
            <= local_24[0]) {
LAB_08135e4b:
          gts_allow_floating_edges = 0;
          (e->segment).object.reserved = (gpointer)0x0;
          goto LAB_08135e5c;
        }
        gVar3 = gts_eheap_size(heap);
        gVar4 = gts_edge_face_number(e,surface);
        gVar5 = (*stop_func)((gdouble)local_24[0],gVar3 - gVar4,stop_data);
        if (gVar5 != 0) goto LAB_08135e4b;
        v = (e->segment).v2;
        pGVar1 = surface->vertex_class;
        v_00 = (e->segment).v1;
        if (v_00 == v) {
          gts_object_destroy((GtsObject *)e);
        }
        else {
          gVar5 = gts_edge_collapse_is_valid(e);
          if (gVar5 == 0) {
            pGVar8 = gts_eheap_insert_with_key
                               (heap,e,
                                179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                               );
            *(GtsEHeapPair **)&(e->segment).object.reserved = pGVar8;
          }
          else {
            v_01 = (GtsObjectClass *)(*pcVar9)(e,pGVar1,coarsen_data);
            gVar5 = gts_edge_collapse_creates_fold(e,(GtsVertex *)v_01,(gdouble)(dVar12 * dVar12));
            if (gVar5 == 0) {
              gts_object_destroy((GtsObject *)e);
              gts_vertex_replace(v_00,(GtsVertex *)v_01);
              gts_object_destroy((GtsObject *)v_00);
              gts_vertex_replace(v,(GtsVertex *)v_01);
              gts_object_destroy((GtsObject *)v);
              local_30 = ((GtsObject *)(v_01->info).name)[3].klass;
              while (local_30 != (GtsObjectClass *)0x0) {
                while( true ) {
                  e = *(GtsEdge **)(local_30->info).name;
                  while (e_00 = gts_edge_is_duplicate(e), e_00 != (GtsEdge *)0x0) {
                    gts_edge_replace(e_00,e);
                    gts_eheap_remove(heap,(GtsEHeapPair *)(e_00->segment).object.reserved);
                    (e_00->segment).object.reserved = (gpointer)0x0;
                    gts_object_destroy((GtsObject *)e_00);
                  }
                  local_30 = *(GtsObjectClass **)((local_30->info).name + 4);
                  if (e->triangles != (GSList *)0x0) break;
                  g_log();
                  gts_eheap_remove(heap,(GtsEHeapPair *)(e->segment).object.reserved);
                  (e->segment).object.reserved = (gpointer)0x0;
                  gts_object_destroy((GtsObject *)e);
                  if (local_30 == (GtsObjectClass *)0x0) goto LAB_08135a42;
                }
              }
              if (v_01 != (GtsObjectClass *)0x0) {
                local_30 = ((GtsObject *)(v_01->info).name)[3].klass;
                if (local_30 != (GtsObjectClass *)0x0) {
                  ppvVar11 = (gpointer *)0x0;
                  do {
                    while( true ) {
                      pGVar2 = *(GtsObjectClass **)(local_30->info).name;
                      pGVar6 = (GtsObjectClass *)gts_edge_class();
                      if (pGVar6 != (GtsObjectClass *)0x0) break;
                      g_return_if_fail_warning();
                      local_30 = *(GtsObjectClass **)((local_30->info).name + 4);
joined_r0x08135c71:
                      if (local_30 == (GtsObjectClass *)0x0) goto joined_r0x08135c7f;
                    }
                    if (pGVar2 == (GtsObjectClass *)0x0) {
LAB_08135c66:
                      local_30 = *(GtsObjectClass **)((local_30->info).name + 4);
                      goto joined_r0x08135c71;
                    }
                    pGVar10 = *(GtsObjectClass **)&pGVar2->info;
                    if (pGVar10 != (GtsObjectClass *)0x0) {
LAB_08135c07:
                      if (pGVar6 != pGVar10) goto LAB_08135c00;
                      pGVar6 = *(GtsObjectClass **)((int)&pGVar2->info + 0xc);
                      if (v_01 == pGVar6) {
                        pGVar6 = *(GtsObjectClass **)((int)&pGVar2->info + 0x10);
                      }
                      pGVar2 = ((GtsObject *)(pGVar6->info).name)[3].klass;
                      while (pGVar2 != (GtsObjectClass *)0x0) {
                        pGVar6 = *(GtsObjectClass **)(pGVar2->info).name;
                        pGVar10 = (GtsObjectClass *)gts_edge_class();
                        if (pGVar10 == (GtsObjectClass *)0x0) {
                          g_return_if_fail_warning();
                        }
                        else {
                          if (pGVar6 != (GtsObjectClass *)0x0) {
                            pGVar6 = *(GtsObjectClass **)&pGVar6->info;
                            if (pGVar6 == (GtsObjectClass *)0x0) {
                              g_return_if_fail_warning();
                            }
                            else {
                              do {
                                if (pGVar10 == pGVar6) {
                                  iVar7 = g_slist_find();
                                  if (iVar7 == 0) {
                                    ppvVar11 = (gpointer *)g_slist_prepend();
                                  }
                                  break;
                                }
                                pGVar6 = pGVar6->parent_class;
                              } while (pGVar6 != (GtsObjectClass *)0x0);
                            }
                          }
                        }
                        pGVar2 = *(GtsObjectClass **)((pGVar2->info).name + 4);
                      }
                      goto LAB_08135c66;
                    }
                    g_return_if_fail_warning();
                    local_30 = *(GtsObjectClass **)((local_30->info).name + 4);
                  } while (local_30 != (GtsObjectClass *)0x0);
joined_r0x08135c7f:
                  while (ppvVar11 != (gpointer *)0x0) {
                    p = *ppvVar11;
                    gts_eheap_remove(heap,*(GtsEHeapPair **)((int)p + 4));
                    *(undefined4 *)((int)p + 4) = 0;
                    pGVar8 = gts_eheap_insert(heap,p);
                    ppvVar11 = (gpointer *)ppvVar11[1];
                    *(GtsEHeapPair **)((int)p + 4) = pGVar8;
                  }
                }
                g_slist_free();
              }
            }
            else {
              pGVar8 = gts_eheap_insert_with_key
                                 (heap,e,
                                  179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
                                 );
              *(GtsEHeapPair **)&(e->segment).object.reserved = pGVar8;
              gts_object_destroy((GtsObject *)v_01);
            }
          }
        }
        goto LAB_08135a42;
      }
      gts_allow_floating_edges = 0;
LAB_08135e5c:
      gts_eheap_foreach(heap,gts_object_reset_reserved,(gpointer)0x0);
      gts_eheap_destroy(heap);
    }
  }
  return;
LAB_08135c00:
  pGVar10 = pGVar10->parent_class;
  if (pGVar10 == (GtsObjectClass *)0x0) goto LAB_08135c66;
  goto LAB_08135c07;
}



void __regparm3 triangle_barycenter(GtsTriangle *t,GtsPoint *b)

{
  GtsEdge *pGVar1;
  GtsVertex *pGVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  
  pGVar1 = t->e1;
  pGVar2 = (pGVar1->segment).v1;
  pGVar3 = (t->e2->segment).v1;
  if (pGVar2 == pGVar3) {
    pGVar4 = (pGVar1->segment).v2;
  }
  else {
    pGVar4 = (pGVar1->segment).v2;
    if (pGVar3 != pGVar4) goto LAB_08135efc;
  }
  pGVar3 = (t->e2->segment).v2;
LAB_08135efc:
  *(double *)&b->x =
       ((double)(pGVar3->p).x + (double)(pGVar2->p).x + (double)(pGVar4->p).x) / 3.00000000;
  *(double *)&b->y =
       ((double)(pGVar3->p).y + (double)(pGVar2->p).y + (double)(pGVar4->p).y) / 3.00000000;
  return;
}



void gts_list_face_class_init(GtsFaceClass *klass)

{
  (klass->parent_class).parent_class.destroy = gts_list_face_destroy;
  return;
}



GtsFaceClass * gts_list_face_class(void)

{
  GtsFaceClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo gts_list_face_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsFaceClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &gts_list_face_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    gts_list_face_info.name._0_4_ = 0x4c737447;
    gts_list_face_info.name._4_4_ = 0x46747369;
    gts_list_face_info.name._8_4_ = 0x656361;
    do {
      *(undefined4 *)(&stack0x00000018 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsFaceClass *)((klass->parent_class).parent_class.info.name + 4);
    } while (klass < (GtsFaceClass *)&DAT_0000001c);
    gts_list_face_info.object_size = 0x20;
    gts_list_face_info.class_size = 0x5c;
    gts_list_face_info.class_init_func = gts_list_face_class_init;
    parent_class = (GtsObjectClass *)gts_face_class();
    klass = (GtsFaceClass *)gts_object_class_new(parent_class,&gts_list_face_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Exceeded maximum restarts with more pending

void gts_list_face_destroy(GtsObject *object)

{
  GtsFaceClass *pGVar1;
  
  g_slist_free(object[2].reserved);
  pGVar1 = gts_list_face_class();
                    // WARNING: Could not recover jumptable at 0x08136008. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar1->parent_class).parent_class.parent_class)->destroy)();
  return;
}



gpointer __regparm3 gts_object_is_from_class(gpointer object,gpointer klass)

{
  char "gts_object_is_from_class" [25];
  gpointer pvVar1;
  
  if (klass == (gpointer)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
    return (gpointer)0x0;
  }
  if (object != (gpointer)0x0) {
    pvVar1 = *(gpointer *)object;
    if (pvVar1 == (gpointer)0x0) {
      g_return_if_fail_warning(0,0x8161cf9,0x8161082);
      return (gpointer)0x0;
    }
    while (klass != pvVar1) {
      pvVar1 = *(gpointer *)((int)pvVar1 + 0x40);
      if (pvVar1 == (gpointer)0x0) {
        return (gpointer)0x0;
      }
    }
  }
  return object;
}



GtsFace * gts_delaunay_check(GtsSurface *surface)

{
  char "gts_delaunay_check" [19];
  gpointer data [2];
  GtsFace *local_10 [3];
  
  local_10[0] = (GtsFace *)0x0;
  if (surface != (GtsSurface *)0x0) {
    data[1] = local_10;
    data[0] = surface;
    gts_surface_foreach_face(surface,delaunay_check,data);
    return local_10[0];
  }
  g_return_if_fail_warning(0,"gts_delaunay_check","surface != NULL");
  return (GtsFace *)0x0;
}



// WARNING: Type propagation algorithm not settling

void delaunay_check(GtsTriangle *t,gpointer *data)

{
  GtsTriangle *pGVar1;
  GtsSurface *surface;
  GtsTriangle *pGVar2;
  GtsVertex *pGVar3;
  GSList *pGVar4;
  GSList *list;
  float10 fVar5;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  pGVar1 = (GtsTriangle *)data[1];
  surface = (GtsSurface *)*data;
  if (*(GtsTriangle **)&pGVar1->object == (GtsTriangle *)0x0) {
    gts_triangle_vertices(t,local_20,&local_24,&local_28);
    list = gts_vertex_neighbors(local_20[0],(GSList *)0x0,surface);
    list = gts_vertex_neighbors(local_24,list,surface);
    list = gts_vertex_neighbors(local_28,list,surface);
    if (list != (GSList *)0x0) {
      pGVar2 = *(GtsTriangle **)&pGVar1->object;
      pGVar4 = list;
      while (pGVar2 == (GtsTriangle *)0x0) {
        pGVar3 = (GtsVertex *)pGVar4->data;
        if ((((pGVar3 != local_20[0]) && (pGVar3 != local_24)) && (pGVar3 != local_28)) &&
           (fVar5 = (float10)gts_point_in_circle(pGVar3,local_20[0],local_24,local_28),
           (float10)0 < fVar5)) {
          *(GtsTriangle **)&pGVar1->object = t;
        }
        pGVar4 = pGVar4->next;
        if (pGVar4 == (GSList *)0x0) break;
        pGVar2 = *(GtsTriangle **)&pGVar1->object;
      }
    }
    g_slist_free(list);
  }
  return;
}



// WARNING: Type propagation algorithm not settling

GtsConstraintClass * gts_constraint_class(void)

{
  GtsConstraintClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo constraint_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsConstraintClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &constraint_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    constraint_info.name._0_4_ = 0x43737447;
    constraint_info.name._4_4_ = 0x74736e6f;
    constraint_info.name._8_4_ = 0x6e696172;
    constraint_info.name._12_4_ = 0x74;
    do {
      *(undefined4 *)(&stack0x0000001c + (int)&klass[-1].parent_class) = 0;
      klass = (GtsConstraintClass *)((klass->parent_class).parent_class.parent_class.info.name + 4);
    } while (klass < (GtsConstraintClass *)&DAT_00000018);
    constraint_info.object_size = 0x18;
    constraint_info.class_size = 0x5c;
    parent_class = (GtsObjectClass *)gts_edge_class();
    klass = (GtsConstraintClass *)gts_object_class_new(parent_class,&constraint_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



gboolean find_closest(gpointer key,gpointer value,gpointer user_data)

{
  double dVar1;
  double dVar2;
  int iVar3;
  float10 fVar4;
  
  fVar4 = (float10)gts_triangle_orientation(value);
  if (((float10)0 < fVar4) &&
     (iVar3 = *(int *)(*(int *)((int)value + 0xc) + 0xc),
     dVar1 = *(double *)(*(int *)((int)user_data + 0xc) + 0xc) - *(double *)(iVar3 + 0xc),
     dVar2 = *(double *)(*(int *)((int)user_data + 0xc) + 0x14) - *(double *)(iVar3 + 0x14),
     dVar1 = dVar2 * dVar2 + dVar1 * dVar1, dVar1 < *(double *)user_data)) {
    *(double *)user_data = dVar1;
    *(gpointer *)((int)user_data + 8) = value;
  }
  iVar3 = *(int *)((int)user_data + 0x10) + -1;
  *(int *)((int)user_data + 0x10) = iVar3;
  return (uint)(iVar3 < 1);
}



GtsFace * __regparm3 neighbor(GtsFace *f,GtsEdge *e,GtsSurface *surface)

{
  GSList *pGVar1;
  GtsFace *f_00;
  GtsObjectClass *pGVar2;
  gboolean gVar3;
  GtsObjectClass *pGVar4;
  
  pGVar1 = e->triangles;
  do {
    if (pGVar1 == (GSList *)0x0) {
      return (GtsFace *)0x0;
    }
    f_00 = (GtsFace *)pGVar1->data;
    if (f_00 != f) {
      pGVar2 = (GtsObjectClass *)gts_face_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (f_00 != (GtsFace *)0x0) {
          pGVar4 = (f_00->triangle).object.klass;
          if (pGVar4 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar2 == pGVar4) {
                gVar3 = gts_face_has_parent_surface(f_00,surface);
                if (gVar3 != 0) {
                  return f_00;
                }
                break;
              }
              pGVar4 = pGVar4->parent_class;
            } while (pGVar4 != (GtsObjectClass *)0x0);
          }
        }
      }
    }
    pGVar1 = (GSList *)(&pGVar1->data)[1];
  } while( true );
}



GtsFace * __regparm3 point_locate(GtsPoint *o,GtsPoint *p,GtsFace *f,GtsSurface *surface)

{
  double dVar1;
  bool bVar2;
  GtsFace *f_00;
  GtsEdge *e;
  float10 fVar3;
  float10 fVar4;
  GtsVertex *local_78;
  GtsEdge *local_4c;
  GtsEdge *local_48;
  GtsEdge *local_44;
  GtsVertex *local_40;
  GtsVertex *local_3c;
  GtsVertex *local_38;
  GtsEdge *local_34;
  GtsEdge *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsEdge *local_20 [4];
  
  gts_triangle_vertices_edges
            ((GtsTriangle *)f,(GtsEdge *)0x0,&local_38,&local_3c,&local_40,&local_44,&local_48,
             &local_4c);
  fVar3 = (float10)gts_point_orientation(o,local_38,p);
  fVar4 = (float10)0;
  if (fVar4 < fVar3) {
    dVar1 = (double)fVar4;
    fVar3 = (float10)gts_point_orientation(o,local_3c,p);
    fVar4 = (float10)dVar1;
    if (fVar4 < fVar3) {
      fVar4 = (float10)gts_point_orientation(local_3c,local_40,p);
      local_44 = local_48;
      if (fVar4 < (float10)dVar1) goto LAB_0813644b;
    }
    else {
      local_40 = local_38;
      local_78 = local_3c;
      if (fVar4 <= fVar3) goto LAB_0813649d;
      fVar4 = (float10)gts_point_orientation(local_38,local_3c,p);
      if (fVar4 < (float10)dVar1) goto LAB_0813644b;
    }
  }
  else {
    if (fVar3 < fVar4) {
      dVar1 = (double)fVar4;
      fVar3 = (float10)gts_point_orientation(o,local_40,p);
      fVar4 = (float10)dVar1;
      if (fVar4 < fVar3) {
        fVar4 = (float10)gts_point_orientation(local_40,local_38,p);
        local_44 = local_4c;
        if (fVar4 < (float10)dVar1) goto LAB_0813644b;
      }
      else {
        local_78 = local_38;
        if (fVar4 <= fVar3) goto LAB_0813649d;
        fVar4 = (float10)gts_point_orientation(local_3c,local_40,p);
        local_44 = local_48;
        if (fVar4 < (float10)dVar1) goto LAB_0813644b;
      }
    }
    else {
      fVar3 = (float10)gts_point_orientation(local_3c,local_40,p);
      fVar4 = (float10)(double)fVar4;
      local_40 = local_38;
      local_44 = local_48;
      local_78 = local_3c;
      if (fVar3 < fVar4) {
LAB_0813644b:
        if (local_44 == (GtsEdge *)0x0) {
          return f;
        }
        local_20[0] = local_44;
        f = neighbor(f,local_44,surface);
        if (f == (GtsFace *)0x0) {
          return (GtsFace *)0x0;
        }
        gts_triangle_vertices_edges
                  ((GtsTriangle *)f,local_20[0],&local_24,&local_28,&local_2c,local_20,&local_30,
                   &local_34);
        do {
          fVar3 = (float10)gts_point_orientation(o,local_2c,p);
          fVar4 = (float10)0;
          if (fVar3 < fVar4) {
            fVar3 = (float10)gts_point_orientation(local_28,local_2c,p);
            if ((float10)(double)fVar4 <= fVar3) {
              return f;
            }
            f = neighbor(f,local_30,surface);
            local_20[0] = local_30;
            local_24 = local_2c;
          }
          else {
            if (fVar3 <= fVar4) {
              fVar3 = (float10)gts_point_orientation(local_28,local_2c,p);
              if ((float10)(double)fVar4 <= fVar3) {
                return f;
              }
              f_00 = neighbor(f,local_30,surface);
              e = local_34;
              if (f_00 != (GtsFace *)0x0) goto LAB_081364d9;
              goto LAB_081367a5;
            }
            fVar3 = (float10)gts_point_orientation(local_2c,local_24,p);
            if ((float10)(double)fVar4 <= fVar3) {
              return f;
            }
            f = neighbor(f,local_34,surface);
            local_20[0] = local_34;
            local_28 = local_2c;
          }
          if (f == (GtsFace *)0x0) {
            return (GtsFace *)0x0;
          }
          local_30 = (f->triangle).e1;
          if (local_30 == local_20[0]) {
            local_30 = (f->triangle).e2;
            local_34 = (f->triangle).e3;
          }
          else {
            local_34 = (f->triangle).e2;
            if (local_20[0] == local_34) {
              local_34 = local_30;
              local_30 = (f->triangle).e3;
            }
          }
          local_2c = (local_30->segment).v1;
          if ((local_2c == local_24) || (local_2c == local_28)) {
            local_2c = (local_30->segment).v2;
          }
        } while( true );
      }
LAB_0813649d:
      fVar3 = (float10)gts_point_orientation(local_40,local_78,p);
      if (fVar3 < (float10)(double)fVar4) {
        bVar2 = true;
        goto LAB_081364b7;
      }
    }
  }
  bVar2 = false;
LAB_081364b7:
  local_20[0] = (GtsEdge *)0x0;
  if (!bVar2) {
    return f;
  }
  f_00 = neighbor(f,(f->triangle).e1,surface);
  if ((f_00 == (GtsFace *)0x0) &&
     (f_00 = neighbor(f,(f->triangle).e2,surface), f_00 == (GtsFace *)0x0)) {
    e = (f->triangle).e3;
LAB_081367a5:
    f_00 = neighbor(f,e,surface);
    if (f_00 == (GtsFace *)0x0) {
      return (GtsFace *)0x0;
    }
  }
LAB_081364d9:
  triangle_barycenter((GtsTriangle *)f_00,o);
  f_00 = point_locate(o,p,f_00,surface);
  return f_00;
}



GtsFace * gts_point_locate(GtsPoint *p,GtsSurface *surface,GtsFace *guess)

{
  char "gts_point_locate" [17];
  gboolean gVar1;
  GtsPointClass *klass;
  GtsPoint *b;
  GtsFace *pGVar2;
  uint uVar3;
  float10 fVar4;
  double dVar5;
  SFindClosest fc;
  
  if (p == (GtsPoint *)0x0) {
    g_return_if_fail_warning(0,0x8161de0,0x816106f);
  }
  else {
    if (surface == (GtsSurface *)0x0) {
      g_return_if_fail_warning(0,0x8161de0,"surface != NULL");
    }
    else {
      if (guess == (GtsFace *)0x0) {
        fc.dmin = 
        179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
        ;
        fc.closest = (GtsFace *)0x0;
        fc.p = p;
        uVar3 = g_hash_table_size(surface->faces);
        dVar5 = log((double)(ulonglong)uVar3);
        dVar5 = exp(dVar5 / 3.00000000);
        fc.stop = (gint)ROUND(dVar5);
        g_hash_table_find(surface->faces,find_closest,&fc);
        guess = fc.closest;
        if (fc.closest != (GtsFace *)0x0) goto LAB_081368a2;
      }
      else {
        gVar1 = gts_face_has_parent_surface(guess,surface);
        if (gVar1 != 0) {
          fVar4 = (float10)gts_triangle_orientation();
          if (fVar4 <= (float10)0) {
            g_return_if_fail_warning
                      (0,0x8161de0,"gts_triangle_orientation (GTS_TRIANGLE (guess)) > 0.");
            return (GtsFace *)0x0;
          }
LAB_081368a2:
          klass = gts_point_class();
          b = (GtsPoint *)gts_object_new((GtsObjectClass *)klass);
          triangle_barycenter((GtsTriangle *)guess,b);
          pGVar2 = point_locate(b,p,guess,surface);
          gts_object_destroy((GtsObject *)b);
          return pGVar2;
        }
        g_return_if_fail_warning
                  (0,"gts_point_locate",
                   "guess == NULL || gts_face_has_parent_surface (guess, surface)");
      }
    }
  }
  return (GtsFace *)0x0;
}



void __regparm3 remove_triangles(GtsEdge *e,GtsSurface *s)

{
  GtsFace *f;
  GSList *pGVar1;
  GSList *pGVar2;
  GtsObjectClass *pGVar3;
  gboolean gVar4;
  GtsObjectClass *pGVar5;
  
  pGVar2 = e->triangles;
  do {
    while( true ) {
      do {
        while( true ) {
          pGVar1 = pGVar2;
          if (pGVar1 == (GSList *)0x0) {
            return;
          }
          pGVar2 = (GSList *)(&pGVar1->data)[1];
          pGVar3 = (GtsObjectClass *)gts_face_class();
          f = (GtsFace *)pGVar1->data;
          if (pGVar3 != (GtsObjectClass *)0x0) break;
          g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
        }
      } while (f == (GtsFace *)0x0);
      pGVar5 = (f->triangle).object.klass;
      if (pGVar5 != (GtsObjectClass *)0x0) break;
      g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
    }
    do {
      if (pGVar3 == pGVar5) {
        gVar4 = gts_face_has_parent_surface(f,s);
        if (gVar4 != 0) {
          gts_surface_remove_face(s,(GtsFace *)pGVar1->data);
        }
        break;
      }
      pGVar5 = pGVar5->parent_class;
    } while (pGVar5 != (GtsObjectClass *)0x0);
  } while( true );
}



void __regparm3 triangulate_polygon(GSList *poly,GtsSurface *surface,GtsFace *ref)

{
  GtsEdge *e1;
  gpointer pvVar1;
  bool bVar2;
  char "triangulate_polygon" [20];
  GtsVertex *pGVar3;
  GtsObjectClass *pGVar4;
  GtsFace *f;
  GSList *pGVar5;
  GtsEdge *e2;
  GtsEdge *e3;
  GtsVertex *v2;
  GtsVertex *pGVar6;
  GtsObjectClass *pGVar7;
  GSList *poly_00;
  GtsVertex *pGVar8;
  float10 fVar9;
  GSList *local_30;
  GtsVertex *local_2c;
  GSList *local_28;
  GtsVertex *local_20;
  
  local_30 = poly;
  if (poly != (GSList *)0x0) {
    local_28 = poly->next;
    while (local_28 != (GSList *)0x0) {
      e1 = (GtsEdge *)local_30->data;
      pGVar6 = *(GtsVertex **)((int)local_28->data + 0xc);
      local_2c = (e1->segment).v1;
      if ((local_2c == pGVar6) || (v2 = *(GtsVertex **)((int)local_28->data + 0x10), local_2c == v2)
         ) {
        pGVar6 = local_2c;
        local_20 = (e1->segment).v2;
      }
      else {
        pGVar8 = (e1->segment).v2;
        local_20 = local_2c;
        local_2c = pGVar6;
        if ((pGVar6 != pGVar8) && (pGVar6 = v2, local_2c = v2, v2 != pGVar8)) {
                    // WARNING: Subroutine does not return
          g_assertion_message_expr
                    (0,0x8161bdc,0x2c6,"triangulate_polygon","s->v2 == s1->v1 || s->v2 == s1->v2");
        }
      }
      do {
        if (local_28 == (GSList *)0x0) {
          g_slist_free(local_30);
          return;
        }
        pvVar1 = local_28->data;
        v2 = *(GtsVertex **)((int)pvVar1 + 0xc);
        if (v2 == pGVar6) {
          v2 = *(GtsVertex **)((int)pvVar1 + 0x10);
        }
        else {
          if (*(GtsVertex **)((int)pvVar1 + 0x10) != pGVar6) {
                    // WARNING: Subroutine does not return
            g_assertion_message_expr(0,0x8161bdc,0x2d2,0x8161d73,"s1->v2 == v3");
          }
        }
        if ((v2 == local_20) ||
           (fVar9 = (float10)gts_point_orientation(local_20,local_2c,v2), fVar9 < (float10)0)) {
LAB_08136e10:
          local_28 = local_28->next;
          bVar2 = false;
        }
        else {
          pGVar6 = (GtsVertex *)0x0;
          poly_00 = local_30;
          pGVar8 = (GtsVertex *)0x0;
          do {
            while( true ) {
              pvVar1 = poly_00->data;
              pGVar3 = *(GtsVertex **)((int)pvVar1 + 0xc);
              if (((((pGVar3 != pGVar8) && (pGVar3 != pGVar6)) && (local_2c != pGVar3)) &&
                  ((local_20 != pGVar3 && (v2 != pGVar3)))) &&
                 (fVar9 = (float10)gts_point_in_circle(pGVar3,local_20,local_2c,v2),
                 (float10)0 < fVar9)) goto LAB_08136e10;
              pGVar3 = *(GtsVertex **)((int)pvVar1 + 0x10);
              if (((pGVar8 != pGVar3) && (pGVar6 != pGVar3)) &&
                 ((local_2c != pGVar3 && (local_20 != pGVar3)))) break;
LAB_08136c08:
              poly_00 = (GSList *)(&poly_00->data)[1];
              pGVar6 = *(GtsVertex **)((int)pvVar1 + 0xc);
              pGVar8 = pGVar3;
              if (poly_00 == (GSList *)0x0) goto LAB_08136ca0;
            }
            if (v2 != pGVar3) {
              fVar9 = (float10)gts_point_in_circle(pGVar3,local_20,local_2c,v2);
              if (fVar9 <= (float10)0) {
                pGVar3 = *(GtsVertex **)((int)pvVar1 + 0x10);
                goto LAB_08136c08;
              }
              goto LAB_08136e10;
            }
            poly_00 = (GSList *)(&poly_00->data)[1];
            pGVar6 = *(GtsVertex **)((int)pvVar1 + 0xc);
            pGVar8 = v2;
          } while (poly_00 != (GSList *)0x0);
LAB_08136ca0:
          bVar2 = true;
        }
        pGVar6 = v2;
      } while (!bVar2);
      e2 = (GtsEdge *)gts_vertices_are_connected(local_2c,v2);
      pGVar4 = (GtsObjectClass *)gts_edge_class();
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (e2 != (GtsEdge *)0x0) {
          pGVar7 = (e2->segment).object.klass;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar4 == pGVar7) goto LAB_08136cfc;
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
      }
      e2 = gts_edge_new(surface->edge_class,local_2c,v2);
LAB_08136cfc:
      e3 = (GtsEdge *)gts_vertices_are_connected(v2,local_20);
      pGVar4 = (GtsObjectClass *)gts_edge_class();
      if (pGVar4 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (e3 != (GtsEdge *)0x0) {
          pGVar7 = (e3->segment).object.klass;
          if (pGVar7 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar4 == pGVar7) goto LAB_08136d42;
              pGVar7 = pGVar7->parent_class;
            } while (pGVar7 != (GtsObjectClass *)0x0);
          }
        }
      }
      e3 = gts_edge_new(surface->edge_class,v2,local_20);
LAB_08136d42:
      f = gts_face_new(surface->face_class,e1,e2,e3);
      gts_object_attributes((GtsObject *)f,(GtsObject *)ref);
      gts_surface_add_face(surface,f);
      poly_00 = (GSList *)(&local_30->data)[1];
      g_slist_free_1(local_30);
      local_30 = local_28->next;
      if ((local_30 != (GSList *)0x0) && ((GtsEdge *)local_30->data != e3)) {
        local_30 = (GSList *)g_slist_prepend(local_30,e3);
      }
      if ((GtsEdge *)local_28->data == e2) {
        local_28->next = (GSList *)0x0;
      }
      else {
        pGVar5 = (GSList *)g_slist_prepend(0,e2);
        local_28->next = pGVar5;
      }
      triangulate_polygon(poly_00,surface,ref);
      if (local_30 == (GSList *)0x0) break;
      local_28 = (GSList *)(&local_30->data)[1];
    }
  }
  g_slist_free(local_30);
  return;
}



// WARNING: Type propagation algorithm not settling

void __regparm3
swap_if_in_circle(GtsFace *f1,GtsVertex *v1,GtsVertex *v2,GtsVertex *v3,GtsEdge *e1,GtsEdge *e2,
                 GtsEdge *e3,GtsSurface *surface)

{
  GtsEdge *pGVar1;
  GtsFace *f;
  GtsFace *f_00;
  GtsFace *f_01;
  GtsObjectClass *pGVar2;
  GtsVertex *v2_00;
  GtsObjectClass *pGVar3;
  GtsObjectClass *pGVar4;
  GtsObjectClass *pGVar5;
  float10 fVar6;
  char *local_64;
  GtsVertex *local_44;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  GtsEdge *local_38;
  GtsFace *local_30;
  
  local_44 = v2;
  local_30 = f1;
LAB_08136f28:
  pGVar2 = (GtsObjectClass *)gts_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
  }
  else {
    if (e1 != (GtsEdge *)0x0) {
      pGVar5 = (e1->segment).object.klass;
      if (pGVar5 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
      }
      else {
        do {
          if (pGVar2 == pGVar5) {
            return;
          }
          pGVar5 = pGVar5->parent_class;
        } while (pGVar5 != (GtsObjectClass *)0x0);
      }
    }
  }
  f = neighbor(local_30,e1,surface);
  if (f != (GtsFace *)0x0) {
    pGVar1 = (f->triangle).e1;
    if (pGVar1 == e1) {
      local_3c = (f->triangle).e2;
      local_40 = (f->triangle).e3;
    }
    else {
      local_40 = (f->triangle).e2;
      local_3c = pGVar1;
      if (local_40 == e1) {
        local_3c = (f->triangle).e3;
        local_40 = pGVar1;
      }
    }
    v2_00 = (local_3c->segment).v1;
    if ((v2_00 == (e1->segment).v1) || (v2_00 == (e1->segment).v2)) {
      v2_00 = (local_3c->segment).v2;
    }
    fVar6 = (float10)gts_point_in_circle(v2_00,v1,local_44,v3);
    if ((float10)0 < fVar6) {
      local_38 = (GtsEdge *)gts_vertices_are_connected(v3,v2_00);
      pGVar2 = (GtsObjectClass *)gts_edge_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (local_38 != (GtsEdge *)0x0) {
          pGVar5 = (local_38->segment).object.klass;
          if (pGVar5 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar2 == pGVar5) goto LAB_0813703d;
              pGVar5 = pGVar5->parent_class;
            } while (pGVar5 != (GtsObjectClass *)0x0);
          }
        }
      }
      local_38 = gts_edge_new(surface->edge_class,v3,v2_00);
LAB_0813703d:
      f_00 = gts_face_new(surface->face_class,local_38,local_40,e2);
      gts_object_attributes((GtsObject *)f_00,(GtsObject *)local_30);
      f_01 = gts_face_new(surface->face_class,local_38,e3,local_3c);
      gts_object_attributes((GtsObject *)f_01,(GtsObject *)f);
      pGVar2 = (GtsObjectClass *)gts_list_face_class();
      if (pGVar2 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        if (f_00 != (GtsFace *)0x0) {
          pGVar5 = (f_00->triangle).object.klass;
          if (pGVar5 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          }
          else {
            do {
              if (pGVar2 == pGVar5) {
                pGVar2 = (GtsObjectClass *)gts_list_face_class();
                if (pGVar2 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                  goto LAB_08137460;
                }
                if (local_30 == (GtsFace *)0x0) goto LAB_08137460;
                pGVar5 = (local_30->triangle).object.klass;
                if (pGVar5 != (GtsObjectClass *)0x0) goto LAB_0813711b;
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                goto LAB_08137460;
              }
              pGVar5 = pGVar5->parent_class;
            } while (pGVar5 != (GtsObjectClass *)0x0);
          }
        }
      }
      goto LAB_081371f8;
    }
  }
  return;
  while (pGVar5 = pGVar5->parent_class, pGVar5 != (GtsObjectClass *)0x0) {
LAB_0813711b:
    if (pGVar2 == pGVar5) {
      pGVar4 = (GtsObjectClass *)0x0;
      pGVar2 = local_30[1].triangle.object.klass;
      pGVar5 = pGVar2;
      if (pGVar2 == (GtsObjectClass *)0x0) goto LAB_08137194;
      pGVar3 = pGVar2;
      pGVar2 = (GtsObjectClass *)0x0;
      goto LAB_08137154;
    }
  }
LAB_08137460:
  pGVar5 = (GtsObjectClass *)0x0;
  pGVar4 = (GtsObjectClass *)gts_list_face_class();
  pGVar2 = (GtsObjectClass *)0x0;
  goto joined_r0x081371ad;
LAB_08137154:
  do {
    fVar6 = (float10)gts_point_orientation(v3,v2_00,*(undefined4 *)(pGVar3->info).name);
    if ((float10)0 <= fVar6) {
      if (pGVar4 == (GtsObjectClass *)0x0) {
        f_00[1].triangle.object.klass = pGVar3;
        pGVar4 = pGVar3;
      }
      else {
        *(GtsObjectClass **)((pGVar4->info).name + 4) = pGVar3;
        pGVar4 = pGVar3;
      }
LAB_0813714d:
      pGVar5 = *(GtsObjectClass **)((pGVar3->info).name + 4);
    }
    else {
      if (pGVar2 == (GtsObjectClass *)0x0) {
        f_01[1].triangle.object.klass = pGVar3;
        pGVar2 = pGVar3;
        goto LAB_0813714d;
      }
      *(GtsObjectClass **)((pGVar2->info).name + 4) = pGVar3;
      pGVar5 = *(GtsObjectClass **)((pGVar3->info).name + 4);
      pGVar2 = pGVar3;
    }
    pGVar3 = pGVar5;
    pGVar5 = pGVar4;
  } while (pGVar3 != (GtsObjectClass *)0x0);
LAB_08137194:
  local_30[1].triangle.object.klass = (GtsObjectClass *)0x0;
  pGVar4 = (GtsObjectClass *)gts_list_face_class();
joined_r0x081371ad:
  if (pGVar4 == (GtsObjectClass *)0x0) {
    local_64 = "klass != NULL";
  }
  else {
    pGVar3 = (f->triangle).object.klass;
    if (pGVar3 != (GtsObjectClass *)0x0) {
joined_r0x081371c5:
      if (pGVar4 != pGVar3) goto LAB_081371d8;
      pGVar4 = f[1].triangle.object.klass;
      while (pGVar3 = pGVar2, pGVar4 != (GtsObjectClass *)0x0) {
        while (pGVar2 = pGVar4,
              fVar6 = (float10)gts_point_orientation(v3,v2_00,*(undefined4 *)(pGVar2->info).name),
              fVar6 < (float10)0) {
          if (pGVar3 == (GtsObjectClass *)0x0) {
            f_01[1].triangle.object.klass = pGVar2;
            pGVar3 = pGVar2;
            goto LAB_081372c9;
          }
          *(GtsObjectClass **)((pGVar3->info).name + 4) = pGVar2;
          pGVar4 = *(GtsObjectClass **)((pGVar2->info).name + 4);
          pGVar3 = pGVar2;
          if (pGVar4 == (GtsObjectClass *)0x0) goto LAB_0813730a;
        }
        if (pGVar5 == (GtsObjectClass *)0x0) {
          f_00[1].triangle.object.klass = pGVar2;
          pGVar5 = pGVar2;
        }
        else {
          *(GtsObjectClass **)((pGVar5->info).name + 4) = pGVar2;
          pGVar5 = pGVar2;
        }
LAB_081372c9:
        pGVar4 = *(GtsObjectClass **)((pGVar2->info).name + 4);
        pGVar2 = pGVar3;
      }
LAB_0813730a:
      f[1].triangle.object.klass = (GtsObjectClass *)0x0;
      goto LAB_081371e2;
    }
    local_64 = "c != NULL";
  }
  g_return_if_fail_warning(0,"gts_object_is_from_class",local_64);
LAB_081371e2:
  if (pGVar5 != (GtsObjectClass *)0x0) {
    *(undefined4 *)((pGVar5->info).name + 4) = 0;
  }
  if (pGVar2 != (GtsObjectClass *)0x0) {
    *(undefined4 *)((pGVar2->info).name + 4) = 0;
  }
LAB_081371f8:
  gts_surface_remove_face(surface,local_30);
  gts_surface_remove_face(surface,f);
  gts_surface_add_face(surface,f_00);
  gts_surface_add_face(surface,f_01);
  swap_if_in_circle(f_00,v2_00,local_44,v3,local_40,e2,local_38,surface);
  e2 = local_38;
  e1 = local_3c;
  local_44 = v2_00;
  local_30 = f_01;
  goto LAB_08136f28;
LAB_081371d8:
  pGVar3 = pGVar3->parent_class;
  if (pGVar3 == (GtsObjectClass *)0x0) goto LAB_081371e2;
  goto joined_r0x081371c5;
}



GtsVertex * gts_delaunay_add_vertex_to_face(GtsSurface *surface,GtsVertex *v,GtsFace *f)

{
  double dVar1;
  GtsObjectClass *pGVar2;
  float10 fVar3;
  char "gts_delaunay_add_vertex_to_face" [32];
  GtsEdgeClass *klass;
  gpointer pvVar4;
  GtsFace *f_00;
  GtsFace *f_01;
  GtsFace *f_02;
  GtsFaceClass *klass_00;
  uint uVar5;
  GtsVertex *pGVar6;
  GtsObjectClass *pGVar7;
  float10 fVar8;
  float10 fVar9;
  GtsEdge *local_5c;
  GtsEdge *local_58;
  GtsEdge *local_54;
  GSList *last [3];
  GtsFace *nf [3];
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsEdge *local_28;
  GtsEdge *local_24;
  GtsEdge *local_20 [4];
  
  pGVar6 = v;
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_vertex_to_face","surface != NULL");
  }
  else {
    if (v == (GtsVertex *)0x0) {
      g_return_if_fail_warning(0,0x8161dc0,"v != NULL");
      pGVar6 = (GtsVertex *)0x0;
    }
    else {
      if (f == (GtsFace *)0x0) {
        g_return_if_fail_warning(0,0x8161dc0,"f != NULL");
      }
      else {
        gts_triangle_vertices_edges
                  ((GtsTriangle *)f,(GtsEdge *)0x0,&local_2c,&local_30,&local_34,local_20,&local_24,
                   &local_28);
        if (((v == local_2c) || (v == local_30)) || (v == local_34)) {
          pGVar6 = (GtsVertex *)0x0;
        }
        else {
          dVar1 = (double)(v->p).x;
          if ((((dVar1 != (double)(local_2c->p).x) ||
               (pGVar6 = local_2c, (double)(v->p).y != (double)(local_2c->p).y)) &&
              ((dVar1 != (double)(local_30->p).x ||
               (pGVar6 = local_30, (double)(v->p).y != (double)(local_30->p).y)))) &&
             ((dVar1 != (double)(local_34->p).x ||
              (pGVar6 = local_34, (double)(v->p).y != (double)(local_34->p).y)))) {
            local_5c = (GtsEdge *)gts_vertices_are_connected(v,local_2c);
            klass = gts_edge_class();
            pvVar4 = gts_object_is_from_class(local_5c,klass);
            if (pvVar4 == (gpointer)0x0) {
              local_5c = gts_edge_new(surface->edge_class,v,local_2c);
            }
            local_58 = (GtsEdge *)gts_vertices_are_connected(v,local_30);
            klass = gts_edge_class();
            pvVar4 = gts_object_is_from_class(local_58,klass);
            if (pvVar4 == (gpointer)0x0) {
              local_58 = gts_edge_new(surface->edge_class,v,local_30);
            }
            local_54 = (GtsEdge *)gts_vertices_are_connected(v,local_34);
            klass = gts_edge_class();
            pvVar4 = gts_object_is_from_class(local_54,klass);
            if (pvVar4 == (gpointer)0x0) {
              local_54 = gts_edge_new(surface->edge_class,v,local_34);
            }
            f_00 = gts_face_new(surface->face_class,local_5c,local_20[0],local_58);
            nf[0] = f_00;
            gts_object_attributes((GtsObject *)f_00,(GtsObject *)f);
            f_01 = gts_face_new(surface->face_class,local_58,local_24,local_54);
            nf[1] = f_01;
            gts_object_attributes((GtsObject *)f_01,(GtsObject *)f);
            f_02 = gts_face_new(surface->face_class,local_54,local_28,local_5c);
            nf[2] = f_02;
            gts_object_attributes((GtsObject *)f_02,(GtsObject *)f);
            klass_00 = gts_list_face_class();
            pvVar4 = gts_object_is_from_class(f,klass_00);
            if (pvVar4 != (gpointer)0x0) {
              klass_00 = gts_list_face_class();
              pvVar4 = gts_object_is_from_class(f_00,klass_00);
              if (pvVar4 != (gpointer)0x0) {
                pGVar7 = f[1].triangle.object.klass;
                last[0] = (GSList *)0x0;
                last[1] = (GSList *)0x0;
                last[2] = (GSList *)0x0;
                if (pGVar7 == (GtsObjectClass *)0x0) {
                  f[1].triangle.object.klass = (GtsObjectClass *)0x0;
                }
                else {
                  do {
                    pGVar6 = *(GtsVertex **)(pGVar7->info).name;
                    pGVar2 = *(GtsObjectClass **)&pGVar7->info;
                    if (v == pGVar6) {
                      g_slist_free_1(pGVar7);
                    }
                    else {
                      fVar9 = (float10)gts_point_orientation(v,local_2c,pGVar6);
                      fVar3 = (float10)0;
                      if (fVar3 <= fVar9) {
                        fVar9 = (float10)gts_point_orientation(v,local_30,pGVar6);
                        fVar8 = (float10)(double)fVar3;
                        if (fVar9 == fVar8) {
                          fVar9 = (float10)gts_point_orientation(v,local_34,pGVar6);
                          uVar5 = (uint)(fVar9 <= (float10)(double)fVar3);
                        }
                        else {
                          uVar5 = (uint)(fVar8 < fVar9);
                        }
                      }
                      else {
                        fVar9 = (float10)gts_point_orientation(v,local_34,pGVar6);
                        uVar5 = (uint)((float10)(double)fVar3 < fVar9) + 1;
                      }
                      if (last[uVar5] == (GSList *)0x0) {
                        nf[uVar5][1].triangle.object.klass = pGVar7;
                      }
                      else {
                        *(GtsObjectClass **)&last[uVar5]->next = pGVar7;
                      }
                      *(GtsObjectClass **)(last + uVar5) = pGVar7;
                    }
                    pGVar7 = pGVar2;
                  } while (pGVar2 != (GtsObjectClass *)0x0);
                  f[1].triangle.object.klass = (GtsObjectClass *)0x0;
                  if (last[0] != (GSList *)0x0) {
                    last[0]->next = (GSList *)0x0;
                  }
                  if (last[1] != (GSList *)0x0) {
                    last[1]->next = (GSList *)0x0;
                  }
                  if (last[2] != (GSList *)0x0) {
                    last[2]->next = (GSList *)0x0;
                  }
                }
              }
            }
            gts_surface_remove_face(surface,f);
            gts_surface_add_face(surface,f_00);
            gts_surface_add_face(surface,f_01);
            gts_surface_add_face(surface,f_02);
            swap_if_in_circle(f_00,local_2c,local_30,v,local_20[0],local_58,local_5c,surface);
            swap_if_in_circle(f_01,local_30,local_34,v,local_24,local_54,local_58,surface);
            swap_if_in_circle(f_02,local_34,local_2c,v,local_28,local_5c,local_54,surface);
            pGVar6 = (GtsVertex *)0x0;
          }
        }
      }
    }
  }
  return pGVar6;
}



GtsVertex * gts_delaunay_add_vertex(GtsSurface *surface,GtsVertex *v,GtsFace *guess)

{
  char "gts_delaunay_add_vertex" [24];
  GtsFace *f;
  GtsVertex *pGVar1;
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_vertex","surface != NULL");
  }
  else {
    if (v == (GtsVertex *)0x0) {
      g_return_if_fail_warning(0,0x8161da2,"v != NULL");
      return (GtsVertex *)0x0;
    }
    f = gts_point_locate((GtsPoint *)v,surface,guess);
    if (f != (GtsFace *)0x0) {
      pGVar1 = gts_delaunay_add_vertex_to_face(surface,v,f);
      return pGVar1;
    }
  }
  return v;
}



void gts_delaunay_remove_vertex(GtsSurface *surface,GtsVertex *v)

{
  gpointer *ppvVar1;
  char "gts_delaunay_remove_vertex" [27];
  GSList *pGVar2;
  GtsObjectClass *pGVar3;
  GSList *poly;
  gboolean gVar4;
  GtsObjectClass *pGVar5;
  GtsFace *f;
  bool bVar6;
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_remove_vertex","surface != NULL");
  }
  else {
    if (v == (GtsVertex *)0x0) {
      g_return_if_fail_warning(0,0x8161d87,"v != NULL");
    }
    else {
      pGVar2 = gts_vertex_triangles(v,(GSList *)0x0);
      poly = pGVar2;
      if (pGVar2 != (GSList *)0x0) {
        do {
          pGVar3 = (GtsObjectClass *)gts_face_class();
          f = (GtsFace *)poly->data;
          if (pGVar3 == (GtsObjectClass *)0x0) {
            f = (GtsFace *)0x0;
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            bVar6 = true;
          }
          else {
            if (f != (GtsFace *)0x0) {
              pGVar5 = (f->triangle).object.klass;
              if (pGVar5 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
              }
              else {
                do {
                  if (pGVar3 == pGVar5) {
                    gVar4 = gts_face_has_parent_surface(f,surface);
                    if (gVar4 != 0) {
                      f = (GtsFace *)poly->data;
                      bVar6 = f == (GtsFace *)0x0;
                      goto LAB_08137b45;
                    }
                    break;
                  }
                  pGVar5 = pGVar5->parent_class;
                } while (pGVar5 != (GtsObjectClass *)0x0);
              }
            }
            bVar6 = true;
            f = (GtsFace *)0x0;
          }
LAB_08137b45:
          ppvVar1 = &poly->data;
        } while ((bVar6) && (poly = (GSList *)ppvVar1[1], (GSList *)ppvVar1[1] != (GSList *)0x0));
        if (f != (GtsFace *)0x0) {
          poly = gts_vertex_fan_oriented(v,surface);
          triangulate_polygon(poly,surface,f);
          do {
            pGVar3 = (GtsObjectClass *)gts_face_class();
            f = (GtsFace *)pGVar2->data;
            if (pGVar3 == (GtsObjectClass *)0x0) {
              g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            }
            else {
              if (f != (GtsFace *)0x0) {
                pGVar5 = (f->triangle).object.klass;
                if (pGVar5 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                }
                else {
                  do {
                    if (pGVar3 == pGVar5) {
                      gVar4 = gts_face_has_parent_surface(f,surface);
                      if (gVar4 != 0) {
                        gts_surface_remove_face(surface,(GtsFace *)pGVar2->data);
                      }
                      break;
                    }
                    pGVar5 = pGVar5->parent_class;
                  } while (pGVar5 != (GtsObjectClass *)0x0);
                }
              }
            }
            pGVar2 = (GSList *)(&pGVar2->data)[1];
            if (pGVar2 == (GSList *)0x0) {
              g_slist_free();
              return;
            }
          } while( true );
        }
      }
      g_slist_free(pGVar2);
      g_return_if_fail_warning(0,0x8161d87,0x813f8bb);
    }
  }
  return;
}



void gts_delaunay_remove_hull(GtsSurface *surface)

{
  GtsEdge *e;
  char "gts_delaunay_remove_hull" [25];
  GSList *pGVar1;
  GtsObjectClass *pGVar2;
  GtsFace *f;
  GtsFace *pGVar3;
  GtsObjectClass *pGVar4;
  GSList *pGVar5;
  GtsEdge *e_00;
  char *local_44;
  GtsEdge *local_20;
  
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_remove_hull","surface != NULL");
  }
  else {
    pGVar1 = gts_surface_boundary(surface);
    gts_allow_floating_edges = 1;
    while (pGVar5 = pGVar1, pGVar1 != (GSList *)0x0) {
      while( true ) {
        e = (GtsEdge *)pGVar5->data;
        pGVar1 = (GSList *)(&pGVar5->data)[1];
        g_slist_free_1(pGVar5);
        pGVar2 = (GtsObjectClass *)gts_constraint_class();
        if (pGVar2 == (GtsObjectClass *)0x0) break;
        if (e == (GtsEdge *)0x0) goto LAB_08137d96;
        pGVar4 = (e->segment).object.klass;
        if (pGVar4 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
          goto LAB_08137d96;
        }
        while (pGVar2 != pGVar4) {
          pGVar4 = pGVar4->parent_class;
          if (pGVar4 == (GtsObjectClass *)0x0) goto LAB_08137d96;
        }
        pGVar5 = pGVar1;
        if (pGVar1 == (GSList *)0x0) goto LAB_08137eec;
      }
      g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
LAB_08137d96:
      f = gts_edge_is_boundary(e,surface);
      if (f != (GtsFace *)0x0) {
        if (e != (f->triangle).e1) {
          pGVar2 = (GtsObjectClass *)gts_constraint_class();
          local_20 = (f->triangle).e1;
          if (pGVar2 == (GtsObjectClass *)0x0) {
            g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
            local_20 = (f->triangle).e1;
          }
          else {
            if (local_20 != (GtsEdge *)0x0) {
              pGVar4 = (local_20->segment).object.klass;
              if (pGVar4 == (GtsObjectClass *)0x0) {
                g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                local_20 = (f->triangle).e1;
              }
              else {
                do {
                  if (pGVar2 == pGVar4) goto LAB_08137e13;
                  pGVar4 = pGVar4->parent_class;
                } while (pGVar4 != (GtsObjectClass *)0x0);
              }
            }
          }
          pGVar3 = gts_edge_is_boundary(local_20,surface);
          if (pGVar3 == (GtsFace *)0x0) {
            pGVar1 = (GSList *)g_slist_prepend(pGVar1,(f->triangle).e1);
          }
        }
LAB_08137e13:
        if (e != (f->triangle).e2) {
          pGVar2 = (GtsObjectClass *)gts_constraint_class();
          e_00 = (f->triangle).e2;
          if (pGVar2 == (GtsObjectClass *)0x0) {
            local_44 = "klass != NULL";
LAB_08137f33:
            g_return_if_fail_warning(0,"gts_object_is_from_class",local_44);
            e_00 = (f->triangle).e2;
          }
          else {
            if (e_00 != (GtsEdge *)0x0) {
              pGVar4 = (e_00->segment).object.klass;
              if (pGVar4 == (GtsObjectClass *)0x0) {
                local_44 = "c != NULL";
                goto LAB_08137f33;
              }
              do {
                if (pGVar2 == pGVar4) goto LAB_08137e5a;
                pGVar4 = pGVar4->parent_class;
              } while (pGVar4 != (GtsObjectClass *)0x0);
            }
          }
          pGVar3 = gts_edge_is_boundary(e_00,surface);
          if (pGVar3 == (GtsFace *)0x0) {
            pGVar1 = (GSList *)g_slist_prepend(pGVar1,(f->triangle).e2);
          }
        }
LAB_08137e5a:
        if (e != (f->triangle).e3) {
          pGVar2 = (GtsObjectClass *)gts_constraint_class();
          e_00 = (f->triangle).e3;
          if (pGVar2 == (GtsObjectClass *)0x0) {
            local_44 = "klass != NULL";
LAB_08137f90:
            g_return_if_fail_warning(0,"gts_object_is_from_class",local_44);
            e_00 = (f->triangle).e3;
          }
          else {
            if (e_00 != (GtsEdge *)0x0) {
              pGVar4 = (e_00->segment).object.klass;
              if (pGVar4 == (GtsObjectClass *)0x0) {
                local_44 = "c != NULL";
                goto LAB_08137f90;
              }
              do {
                if (pGVar2 == pGVar4) goto LAB_08137ea2;
                pGVar4 = pGVar4->parent_class;
              } while (pGVar4 != (GtsObjectClass *)0x0);
            }
          }
          pGVar3 = gts_edge_is_boundary(e_00,surface);
          if (pGVar3 == (GtsFace *)0x0) {
            pGVar1 = (GSList *)g_slist_prepend(pGVar1,(f->triangle).e3);
          }
        }
LAB_08137ea2:
        gts_surface_remove_face(surface,f);
      }
      if (e->triangles == (GSList *)0x0) {
        gts_object_destroy((GtsObject *)e);
      }
    }
LAB_08137eec:
    gts_allow_floating_edges = 0;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08138162)
// WARNING: Removing unreachable block (ram,0x0813815c)

GSList * __regparm3
remove_intersected_edge
          (GtsSegment *s,GtsEdge *e,GtsFace *f,GtsSurface *surface,GSList **left,GSList **right)

{
  float10 fVar1;
  char "remove_intersected_edge" [24];
  GtsObjectClass *pGVar2;
  GtsFace *f_00;
  GSList *pGVar3;
  GtsObjectClass *pGVar4;
  GSList *pGVar5;
  float10 fVar6;
  float10 fVar7;
  GtsEdge *local_40 [4];
  GtsEdge *local_30;
  GtsEdge *local_2c;
  GtsVertex *local_28;
  GtsVertex *local_24;
  GtsVertex *local_20 [4];
  
  local_40[0] = e;
  pGVar2 = (GtsObjectClass *)gts_constraint_class();
  if (pGVar2 == (GtsObjectClass *)0x0) {
    g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
LAB_081383af:
    pGVar5 = (GSList *)0x0;
  }
  else {
    if (local_40[0] == (GtsEdge *)0x0) goto LAB_081383af;
    pGVar4 = (local_40[0]->segment).object.klass;
    if (pGVar4 != (GtsObjectClass *)0x0) {
      do {
        if (pGVar2 == pGVar4) {
          pGVar5 = (GSList *)g_slist_prepend(0,local_40[0]);
          goto LAB_081380cf;
        }
        pGVar4 = pGVar4->parent_class;
      } while (pGVar4 != (GtsObjectClass *)0x0);
      goto LAB_081383af;
    }
    pGVar5 = (GSList *)0x0;
    g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
  }
LAB_081380cf:
  gts_triangle_vertices_edges
            ((GtsTriangle *)f,local_40[0],local_20,&local_24,&local_28,local_40,&local_2c,&local_30)
  ;
  fVar6 = (float10)gts_point_orientation(local_24,local_28,s->v2);
  fVar7 = (float10)gts_point_orientation(local_28,local_20[0],s->v2);
  if (((float10)(double)fVar6 == (float10)0) && (fVar7 == (float10)0)) {
    remove_triangles(local_40[0],surface);
    if ((pGVar5 == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
      gts_object_destroy((GtsObject *)local_40[0]);
    }
    pGVar3 = (GSList *)g_slist_prepend(*left,local_30);
    *left = pGVar3;
    pGVar3 = (GSList *)g_slist_prepend(*right,local_2c);
    *right = pGVar3;
    return pGVar5;
  }
  fVar1 = (float10)0;
  if ((float10)(double)fVar6 <= fVar1) {
    if (fVar7 < fVar1) {
      fVar6 = (float10)gts_point_orientation(s->v1,s->v2,local_28);
      if (fVar6 <= (float10)(double)fVar1) {
        f_00 = neighbor(f,local_30,surface);
        remove_triangles(local_40[0],surface);
        if ((pGVar5 == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
          gts_object_destroy((GtsObject *)local_40[0]);
        }
        if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
          g_assertion_message_expr(0,0x8161bdc,0x37a,0x8161d5b,&DAT_08161c06);
        }
        goto LAB_081381a8;
      }
      f_00 = neighbor(f,local_2c,surface);
      remove_triangles(local_40[0],surface);
      if ((pGVar5 == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
        gts_object_destroy((GtsObject *)local_40[0]);
      }
      if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr(0,0x8161bdc,0x378,"remove_intersected_edge",&DAT_08161c06);
      }
    }
    else {
      f_00 = neighbor(f,local_2c,surface);
      remove_triangles(local_40[0],surface);
      if ((pGVar5 == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
        gts_object_destroy((GtsObject *)local_40[0]);
      }
      if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
        g_assertion_message_expr(0,0x8161bdc,0x373,0x8161d5b,&DAT_08161c06);
      }
    }
    pGVar3 = (GSList *)g_slist_prepend(*left,local_30);
    *left = pGVar3;
    local_30 = local_2c;
  }
  else {
    if (fVar1 < fVar7) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,0x8161bdc,0x36f,0x8161d5b,"o2 <= 0.");
    }
    f_00 = neighbor(f,local_30,surface);
    remove_triangles(local_40[0],surface);
    if ((pGVar5 == (GSList *)0x0) && (local_40[0]->triangles == (GSList *)0x0)) {
      gts_object_destroy((GtsObject *)local_40[0]);
    }
    if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
      g_assertion_message_expr(0,0x8161bdc,0x370,0x8161d5b,&DAT_08161c06);
    }
LAB_081381a8:
    pGVar3 = (GSList *)g_slist_prepend(*right,local_2c);
    *right = pGVar3;
  }
  pGVar3 = remove_intersected_edge(s,local_30,f_00,surface,left,right);
  pGVar5 = (GSList *)g_slist_concat(pGVar5,pGVar3);
  return pGVar5;
}



GSList * gts_delaunay_add_constraint(GtsSurface *surface,GtsConstraint *c)

{
  double dVar1;
  GtsFace *f;
  GtsVertex *pGVar2;
  char "gts_delaunay_add_constraint" [28];
  GtsObjectClass *pGVar3;
  GSList *pGVar4;
  gboolean gVar5;
  GtsFace *f_00;
  undefined4 uVar6;
  GSList *poly;
  GtsObjectClass *pGVar7;
  float10 fVar8;
  GSList *local_50;
  GtsEdge *local_40;
  GtsEdge *local_3c;
  GtsEdge *local_38;
  GtsVertex *local_34;
  GtsVertex *local_30;
  GtsVertex *local_2c;
  GtsVertex *local_28;
  GSList *local_24;
  GSList *local_20 [4];
  
  local_20[0] = (GSList *)0x0;
  local_24 = (GSList *)0x0;
  if (surface == (GtsSurface *)0x0) {
    g_return_if_fail_warning(0,"gts_delaunay_add_constraint","surface != NULL");
  }
  else {
    if (c == (GtsConstraint *)0x0) {
      g_return_if_fail_warning(0,0x8161d25,0x8161082);
    }
    else {
      pGVar3 = (GtsObjectClass *)gts_constraint_class();
      if (pGVar3 == (GtsObjectClass *)0x0) {
        g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
      }
      else {
        pGVar7 = (c->edge).segment.object.klass;
        if (pGVar7 == (GtsObjectClass *)0x0) {
          g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
        }
        else {
          do {
            if (pGVar3 == pGVar7) {
              local_28 = (c->edge).segment.v1;
              gts_allow_floating_edges = 1;
              pGVar4 = gts_vertex_triangles(local_28,(GSList *)0x0);
              poly = pGVar4;
              do {
                if (poly == (GSList *)0x0) {
                    // WARNING: Subroutine does not return
                  g_assertion_message(0,0x8161bdc,0x3be,"remove_intersected_vertex",0);
                }
                f = (GtsFace *)poly->data;
                pGVar3 = (GtsObjectClass *)gts_face_class();
                if (pGVar3 == (GtsObjectClass *)0x0) {
                  g_return_if_fail_warning(0,"gts_object_is_from_class","klass != NULL");
                }
                else {
                  if (f != (GtsFace *)0x0) {
                    pGVar7 = (f->triangle).object.klass;
                    if (pGVar7 == (GtsObjectClass *)0x0) {
                      g_return_if_fail_warning(0,"gts_object_is_from_class",0x8161082);
                    }
                    else {
                      do {
                        if (pGVar3 == pGVar7) {
                          gVar5 = gts_face_has_parent_surface(f,surface);
                          if (gVar5 != 0) {
                            gts_triangle_vertices((GtsTriangle *)f,&local_2c,&local_30,&local_34);
                            pGVar2 = local_30;
                            if (local_28 == local_30) {
                              local_30 = local_34;
                              local_34 = local_2c;
                            }
                            else {
                              if (local_28 == local_34) {
                                local_30 = local_2c;
                                local_34 = pGVar2;
                              }
                              else {
                                if (local_28 != local_2c) {
                    // WARNING: Subroutine does not return
                                  g_assertion_message_expr
                                            (0,0x8161bdc,0x39c,"remove_intersected_vertex",
                                             &DAT_08161c21);
                                }
                              }
                            }
                            fVar8 = (float10)gts_point_orientation
                                                       (local_28,local_30,(c->edge).segment.v2);
                            if ((float10)0 <= fVar8) {
                              dVar1 = (double)(float10)0;
                              fVar8 = (float10)gts_point_orientation
                                                         (local_34,local_28,(c->edge).segment.v2);
                              if ((float10)dVar1 <= fVar8) {
                                fVar8 = (float10)gts_point_orientation
                                                           (local_30,local_34,(c->edge).segment.v2);
                                local_38 = gts_triangle_edge_opposite((GtsTriangle *)f,local_28);
                                f_00 = neighbor(f,local_38,surface);
                                gts_triangle_vertices_edges
                                          ((GtsTriangle *)f,local_38,&local_30,&local_34,&local_28,
                                           &local_38,&local_40,&local_3c);
                                g_slist_free(pGVar4);
                                local_50 = (GSList *)0x0;
                                if ((double)fVar8 < dVar1) {
                                  gts_allow_floating_faces = 1;
                                  gts_surface_remove_face(surface,f);
                                  gts_allow_floating_faces = 0;
                                  local_20[0] = (GSList *)g_slist_prepend(local_20[0],local_40);
                                  local_24 = (GSList *)g_slist_prepend(local_24,local_3c);
                                  if (f_00 == (GtsFace *)0x0) {
                    // WARNING: Subroutine does not return
                                    g_assertion_message_expr
                                              (0,0x8161bdc,0x3b7,"remove_intersected_vertex",
                                               &DAT_08161c06);
                                  }
                                  local_50 = remove_intersected_edge
                                                       ((GtsSegment *)c,local_38,f_00,surface,
                                                        local_20,&local_24);
                                }
                                gts_allow_floating_edges = 0;
                                uVar6 = g_slist_reverse(local_24);
                                poly = (GSList *)g_slist_prepend(uVar6,c);
                                triangulate_polygon(poly,surface,f);
                                poly = (GSList *)g_slist_prepend(local_20[0],c);
                                triangulate_polygon(poly,surface,f);
                                if (f->surfaces != (GSList *)0x0) {
                                  return local_50;
                                }
                                gts_allow_floating_edges = 1;
                                gts_object_destroy((GtsObject *)f);
                                gts_allow_floating_edges = 0;
                                return local_50;
                              }
                            }
                          }
                          break;
                        }
                        pGVar7 = pGVar7->parent_class;
                      } while (pGVar7 != (GtsObjectClass *)0x0);
                    }
                  }
                }
                poly = (GSList *)(&poly->data)[1];
              } while( true );
            }
            pGVar7 = pGVar7->parent_class;
          } while (pGVar7 != (GtsObjectClass *)0x0);
        }
      }
      g_return_if_fail_warning(0,0x8161d25,"GTS_IS_CONSTRAINT (c)");
    }
  }
  return (GSList *)0x0;
}



int planeBoxOverlap(double *normal,double *vert,double *maxbox)

{
  double dVar1;
  double dVar2;
  int iVar3;
  uint uVar4;
  double vmax [3];
  double vmin [3];
  
  iVar3 = 0;
  do {
    dVar1 = vert[iVar3];
    if (normal[iVar3] <= 0.00000000) {
      dVar2 = maxbox[iVar3];
      vmin[iVar3] = dVar2 - dVar1;
      vmax[iVar3] = -dVar2 - dVar1;
    }
    else {
      dVar2 = maxbox[iVar3];
      vmin[iVar3] = -dVar2 - dVar1;
      vmax[iVar3] = dVar2 - dVar1;
    }
    iVar3 = iVar3 + 1;
  } while (iVar3 != 3);
  uVar4 = 0;
  if (vmin[2] * normal[2] + vmin[1] * normal[1] + vmin[0] * *normal <= 0.00000000) {
    uVar4 = (uint)(0.00000000 <= normal[2] * vmax[2] + normal[1] * vmax[1] + vmax[0] * *normal);
  }
  return uVar4;
}



int triBoxOverlap(double *boxcenter,double *boxhalfsize,double (*triverts) [3])

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  double dVar22;
  float fVar23;
  double dVar24;
  double dVar25;
  double dVar26;
  int iVar27;
  double local_ac;
  double normal [3];
  double v0 [3];
  
  fVar20 = (float)(*triverts)[0] - (float)*boxcenter;
  v0[0] = (double)fVar20;
  fVar21 = (float)(*triverts)[1] - (float)boxcenter[1];
  v0[1] = (double)fVar21;
  fVar18 = (float)(*triverts)[2] - (float)boxcenter[2];
  v0[2] = (double)fVar18;
  fVar8 = (float)(triverts + 1)[1] - (float)boxcenter[1];
  fVar6 = (float)(triverts + 1)[2] - (float)boxcenter[2];
  fVar13 = (float)(triverts + 2)[1] - (float)boxcenter[1];
  fVar7 = (float)(triverts + 2)[2] - (float)boxcenter[2];
  fVar1 = fVar8 - fVar21;
  fVar17 = fVar6 - fVar18;
  fVar2 = fVar21 * fVar17 - fVar18 * fVar1;
  fVar5 = fVar13 * fVar17 - fVar7 * fVar1;
  fVar3 = fVar5;
  if (fVar2 <= fVar5 || fVar5 != fVar2) {
    fVar3 = fVar2;
    fVar2 = fVar5;
  }
  fVar15 = (float)boxhalfsize[1];
  fVar16 = (float)boxhalfsize[2];
  fVar5 = fVar16 * ABS(fVar1) + fVar15 * ABS(fVar17);
  if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
    fVar11 = (float)(triverts + 1)[0] - (float)*boxcenter;
    dVar22 = (triverts + 2)[0] - *boxcenter;
    fVar19 = fVar11 - fVar20;
    fVar5 = fVar19 * fVar18 + fVar20 * -fVar17;
    fVar2 = fVar7 * fVar19 + (float)dVar22 * -fVar17;
    fVar3 = fVar2;
    if (fVar5 <= fVar2 || fVar2 != fVar5) {
      fVar3 = fVar5;
      fVar5 = fVar2;
    }
    fVar4 = (float)*boxhalfsize;
    fVar2 = ABS(fVar19) * fVar16 + fVar4 * ABS(fVar17);
    if ((fVar3 <= fVar2) && (-fVar2 <= fVar5)) {
      fVar5 = fVar11 * fVar1 - fVar8 * fVar19;
      fVar2 = (float)dVar22 * fVar1 - fVar13 * fVar19;
      fVar3 = fVar5;
      if (fVar2 <= fVar5 || fVar5 != fVar2) {
        fVar3 = fVar2;
        fVar2 = fVar5;
      }
      fVar5 = ABS(fVar19) * fVar15 + ABS(fVar1) * fVar4;
      if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
        fVar23 = fVar13 - fVar8;
        fVar14 = fVar7 - fVar6;
        fVar2 = fVar14 * fVar21 - fVar23 * fVar18;
        fVar5 = fVar13 * fVar14 - fVar7 * fVar23;
        fVar3 = fVar5;
        if (fVar2 <= fVar5 || fVar5 != fVar2) {
          fVar3 = fVar2;
          fVar2 = fVar5;
        }
        fVar5 = fVar16 * ABS(fVar23) + fVar15 * ABS(fVar14);
        if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
          dVar24 = dVar22 - (double)fVar11;
          fVar2 = (float)dVar24 * fVar18 + fVar20 * -fVar14;
          fVar5 = fVar7 * (float)dVar24 + -fVar14 * (float)dVar22;
          fVar3 = fVar5;
          if (fVar2 <= fVar5 || fVar5 != fVar2) {
            fVar3 = fVar2;
            fVar2 = fVar5;
          }
          fVar5 = fVar16 * ABS((float)dVar24) + fVar4 * ABS(fVar14);
          if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
            fVar2 = fVar23 * fVar20 - (float)dVar24 * fVar21;
            fVar5 = fVar11 * fVar23 - fVar8 * (float)dVar24;
            fVar3 = fVar5;
            if (fVar2 <= fVar5 || fVar5 != fVar2) {
              fVar3 = fVar2;
              fVar2 = fVar5;
            }
            fVar5 = fVar15 * ABS((float)dVar24) + fVar4 * ABS(fVar23);
            if ((fVar3 <= fVar5) && (-fVar5 <= fVar2)) {
              fVar3 = fVar21 - fVar13;
              fVar2 = fVar18 - fVar7;
              fVar5 = fVar2 * fVar21 - fVar3 * fVar18;
              fVar10 = fVar8 * fVar2 - fVar6 * fVar3;
              fVar9 = fVar10;
              if (fVar5 <= fVar10 || fVar10 != fVar5) {
                fVar9 = fVar5;
                fVar5 = fVar10;
              }
              fVar10 = fVar16 * ABS(fVar3) + fVar15 * ABS(fVar2);
              if ((fVar9 <= fVar10) && (-fVar10 <= fVar5)) {
                fVar12 = fVar20 - (float)dVar22;
                fVar5 = fVar12 * fVar18 + fVar20 * -fVar2;
                fVar10 = fVar6 * fVar12 + -fVar2 * fVar11;
                fVar9 = fVar10;
                if (fVar5 <= fVar10 || fVar10 != fVar5) {
                  fVar9 = fVar5;
                  fVar5 = fVar10;
                }
                fVar2 = fVar16 * ABS(fVar12) + fVar4 * ABS(fVar2);
                if ((fVar9 <= fVar2) && (-fVar2 <= fVar5)) {
                  local_ac = (double)fVar11 * (double)fVar3 - (double)fVar8 * (double)fVar12;
                  dVar26 = dVar22 * (double)fVar3 - (double)fVar13 * (double)fVar12;
                  dVar25 = dVar26;
                  if (local_ac <= dVar26) {
                    dVar25 = local_ac;
                    local_ac = dVar26;
                  }
                  dVar26 = (double)fVar15 * (double)ABS(fVar12) + (double)fVar4 * (double)ABS(fVar3)
                  ;
                  if ((dVar25 <= dVar26) && (-dVar26 <= local_ac)) {
                    fVar2 = fVar11;
                    if (fVar20 <= fVar11) {
                      fVar2 = fVar20;
                    }
                    if (fVar11 <= fVar20) {
                      fVar11 = fVar20;
                    }
                    fVar3 = (float)dVar22;
                    if (fVar3 <= fVar2 || fVar2 != fVar3) {
                      fVar2 = fVar3;
                    }
                    if (fVar3 <= fVar11) {
                      fVar3 = fVar11;
                    }
                    if ((fVar2 <= fVar4) && (-fVar4 <= fVar3)) {
                      fVar2 = fVar8;
                      if (fVar21 <= fVar8) {
                        fVar2 = fVar21;
                      }
                      if (fVar8 <= fVar21) {
                        fVar8 = fVar21;
                      }
                      if (fVar13 <= fVar2 || fVar2 != fVar13) {
                        fVar2 = fVar13;
                      }
                      if (fVar13 <= fVar8) {
                        fVar13 = fVar8;
                      }
                      if ((fVar2 <= fVar15) && (-fVar15 <= fVar13)) {
                        fVar8 = fVar6;
                        if (fVar18 <= fVar6) {
                          fVar8 = fVar18;
                        }
                        if (fVar6 <= fVar18) {
                          fVar6 = fVar18;
                        }
                        if (fVar7 <= fVar8 || fVar8 != fVar7) {
                          fVar8 = fVar7;
                        }
                        if (fVar7 <= fVar6) {
                          fVar7 = fVar6;
                        }
                        if ((fVar8 <= fVar16) && (-fVar16 <= fVar7)) {
                          normal[0] = (double)(fVar14 * fVar1 - fVar23 * fVar17);
                          normal[1] = (double)(fVar17 * (float)dVar24 - fVar19 * fVar14);
                          normal[2] = (double)(fVar19 * fVar23 - fVar1 * (float)dVar24);
                          iVar27 = planeBoxOverlap(normal,v0,boxhalfsize);
                          return (uint)(iVar27 != 0);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}



void segment_class_init(GtsObjectClass *klass)

{
  klass->destroy = segment_destroy;
  return;
}



void segment_init(GtsSegment *segment)

{
  segment->v2 = (GtsVertex *)0x0;
  segment->v1 = (GtsVertex *)0x0;
  return;
}



GtsSegment * gts_segment_is_duplicate(GtsSegment *s)

{
  GtsVertex *pGVar1;
  GtsSegment *pGVar2;
  char "gts_segment_is_duplicate" [25];
  GSList *pGVar3;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_is_duplicate",0x815fd1b);
    return (GtsSegment *)0x0;
  }
  pGVar1 = s->v2;
  pGVar3 = s->v1->segments;
  if (pGVar1 == s->v1) {
    if (pGVar3 != (GSList *)0x0) {
      while (((pGVar2 = (GtsSegment *)pGVar3->data, pGVar2 == s || (pGVar2->v1 != pGVar1)) ||
             (pGVar1 != pGVar2->v2))) {
        pGVar3 = pGVar3->next;
        if (pGVar3 == (GSList *)0x0) {
          return (GtsSegment *)0x0;
        }
      }
      return pGVar2;
    }
  }
  else {
    while (pGVar3 != (GSList *)0x0) {
      pGVar2 = (GtsSegment *)pGVar3->data;
      if (pGVar2 != s) {
        if (pGVar2->v1 == pGVar1) {
          return pGVar2;
        }
        if (pGVar2->v2 == pGVar1) {
          return pGVar2;
        }
      }
      pGVar3 = pGVar3->next;
    }
  }
  return (GtsSegment *)0x0;
}



gboolean gts_segment_is_ok(GtsSegment *s)

{
  char "gts_segment_is_ok" [18];
  GtsSegment *pGVar1;
  gboolean gVar2;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,0x8161e5c,0x815fd1b);
    return 0;
  }
  if (s->v1 != s->v2) {
    pGVar1 = gts_segment_is_duplicate(s);
    if (pGVar1 == (GtsSegment *)0x0) {
      if ((s->object).reserved != (gpointer)0x0) {
        g_return_if_fail_warning(0,0x8161e5c,"GTS_OBJECT (s)->reserved == NULL");
        return 0;
      }
      gVar2 = 1;
    }
    else {
      g_return_if_fail_warning(0,"gts_segment_is_ok","!gts_segment_is_duplicate (s)");
      gVar2 = 0;
    }
    return gVar2;
  }
  g_return_if_fail_warning(0,0x8161e5c,"s->v1 != s->v2");
  return 0;
}



GSList * gts_segments_from_vertices(GSList *vertices)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int iVar4;
  GSList *local_24;
  GSList *local_20;
  
  uVar3 = g_hash_table_new(0,0);
  local_24 = (GSList *)0x0;
  local_20 = vertices;
  if (vertices != (GSList *)0x0) {
    do {
      puVar1 = *(undefined4 **)((int)local_20->data + 0x24);
      while (puVar1 != (undefined4 *)0x0) {
        uVar2 = *puVar1;
        iVar4 = g_hash_table_lookup(uVar3,uVar2);
        if (iVar4 == 0) {
          local_24 = (GSList *)g_slist_prepend(local_24,uVar2);
          g_hash_table_insert(uVar3,uVar2,local_20);
        }
        puVar1 = (undefined4 *)puVar1[1];
      }
      local_20 = local_20->next;
    } while (local_20 != (GSList *)0x0);
  }
  g_hash_table_destroy(uVar3);
  return local_24;
}



GtsVertex * gts_segment_midvertex(GtsSegment *s,GtsVertexClass *klass)

{
  GtsVertex *pGVar1;
  char "gts_segment_midvertex" [22];
  GtsVertex *pGVar2;
  
  if (s == (GtsSegment *)0x0) {
    g_return_if_fail_warning(0,"gts_segment_midvertex",0x815fd1b);
    return (GtsVertex *)0x0;
  }
  if (klass != (GtsVertexClass *)0x0) {
    pGVar2 = s->v1;
    pGVar1 = s->v2;
    pGVar2 = gts_vertex_new(klass,(gdouble)(((double)(pGVar2->p).x + (double)(pGVar1->p).x) *
                                           0.50000000),
                            (gdouble)(((double)(pGVar2->p).y + (double)(pGVar1->p).y) * 0.50000000),
                            (gdouble)(((double)(pGVar2->p).z + (double)(pGVar1->p).z) * 0.50000000))
    ;
    return pGVar2;
  }
  g_return_if_fail_warning(0,0x8161e6e,"klass != NULL");
  return (GtsVertex *)0x0;
}



// WARNING: Removing unreachable block (ram,0x081395c6)

GtsIntersect gts_segments_are_intersecting(GtsSegment *s1,GtsSegment *s2)

{
  double dVar1;
  double dVar2;
  GtsVertex *pGVar3;
  GtsVertex *pGVar4;
  GtsVertex *pGVar5;
  GtsVertex *pGVar6;
  float10 fVar7;
  char "gts_segments_are_intersecting" [30];
  GtsIntersect GVar8;
  float10 fVar9;
  float10 fVar10;
  
  if ((s2 == (GtsSegment *)0x0) || (s1 == (GtsSegment *)0x0)) {
    g_return_if_fail_warning(0,"gts_segments_are_intersecting","s1 != NULL && s2 != NULL");
    GVar8 = GTS_ON;
  }
  else {
    pGVar3 = s1->v1;
    pGVar4 = s1->v2;
    pGVar5 = s2->v1;
    pGVar6 = s2->v2;
    fVar10 = (float10)gts_point_orientation(pGVar3,pGVar4,pGVar5);
    dVar1 = (double)fVar10;
    fVar10 = (float10)gts_point_orientation(pGVar3,pGVar4,pGVar6);
    dVar2 = (double)fVar10;
    if (((dVar1 <= 0.00000000) || (dVar2 <= 0.00000000)) &&
       ((0.00000000 <= dVar1 || (0.00000000 <= dVar2)))) {
      fVar10 = (float10)gts_point_orientation(pGVar5,pGVar6,pGVar3);
      fVar9 = (float10)gts_point_orientation(pGVar5,pGVar6,pGVar4);
      fVar10 = (float10)(double)fVar10;
      if (((fVar10 <= (float10)0) || (fVar9 <= (float10)0)) &&
         (((float10)0 <= fVar10 || ((float10)0 <= fVar9)))) {
        fVar7 = (float10)0;
        if ((((float10)dVar1 != fVar7) && ((float10)dVar2 != fVar7)) && (fVar10 != fVar7)) {
          return (uint)(fVar7 != fVar9);
        }
        return GTS_ON;
      }
    }
    GVar8 = GTS_OUT;
  }
  return GVar8;
}



GtsSegment * gts_segment_new(GtsSegmentClass *klass,GtsVertex *v1,GtsVertex *v2)

{
  char "gts_segment_new" [16];
  GSList *pGVar1;
  GtsSegment *pGVar2;
  
  if (v1 == (GtsVertex *)0x0) {
    pGVar2 = (GtsSegment *)0x0;
    g_return_if_fail_warning(0,"gts_segment_new",0x8151613);
  }
  else {
    if (v2 == (GtsVertex *)0x0) {
      pGVar2 = (GtsSegment *)0x0;
      g_return_if_fail_warning(0,0x8161ebb,0x8151626);
    }
    else {
      if (v1 == v2) {
        pGVar2 = (GtsSegment *)0x0;
        g_return_if_fail_warning(0,0x8161ebb,&DAT_081516ec);
      }
      else {
        pGVar2 = (GtsSegment *)gts_object_new((GtsObjectClass *)klass);
        pGVar2->v1 = v1;
        pGVar2->v2 = v2;
        pGVar1 = (GSList *)g_slist_prepend(v1->segments,pGVar2);
        v1->segments = pGVar1;
        pGVar1 = (GSList *)g_slist_prepend(v2->segments,pGVar2);
        v2->segments = pGVar1;
      }
    }
  }
  return pGVar2;
}



GtsSegmentClass * gts_segment_class(void)

{
  GtsSegmentClass *klass;
  GtsObjectClass *parent_class;
  int iVar1;
  GtsObjectClassInfo *pGVar2;
  int in_GS_OFFSET;
  GtsObjectClassInfo segment_info;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  if (klass == (GtsSegmentClass *)0x0) {
    iVar1 = 0x10;
    pGVar2 = &segment_info;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *(undefined4 *)pGVar2->name = 0;
      pGVar2 = (GtsObjectClassInfo *)(pGVar2->name + 4);
    }
    segment_info.name._0_4_ = 0x53737447;
    segment_info.name._4_4_ = 0x656d6765;
    segment_info.name._8_4_ = 0x746e;
    do {
      *(undefined4 *)(&stack0x00000018 + (int)&klass[-1].parent_class) = 0;
      klass = (GtsSegmentClass *)((klass->parent_class).info.name + 4);
    } while (klass < (GtsSegmentClass *)&DAT_0000001c);
    segment_info.object_size = 0x14;
    segment_info.class_size = 0x5c;
    segment_info.class_init_func = segment_class_init;
    segment_info.object_init_func = segment_init;
    parent_class = gts_object_class();
    klass = (GtsSegmentClass *)gts_object_class_new(parent_class,&segment_info);
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return klass;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Exceeded maximum restarts with more pending

void segment_destroy(GtsObject *object)

{
  byte bVar1;
  GtsObject *object_00;
  int iVar2;
  GtsObjectClass *object_01;
  GtsSegmentClass *pGVar3;
  
  object_01 = object[1].klass;
  object_00 = (GtsObject *)object[1].reserved;
  iVar2 = g_slist_remove(*(undefined4 *)((object_01->info).name + 0x24),object);
  bVar1 = *(byte *)&object_01->info;
  *(int *)((object_01->info).name + 0x24) = iVar2;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_vertices == 0)) && (iVar2 == 0)) {
    gts_object_destroy((GtsObject *)object_01);
  }
  object_01 = (GtsObjectClass *)g_slist_remove(object_00[3].klass,object);
  bVar1 = *(byte *)&object_00->flags;
  object_00[3].klass = object_01;
  if ((((bVar1 & 1) == 0) && (gts_allow_floating_vertices == 0)) &&
     (object_01 == (GtsObjectClass *)0x0)) {
    gts_object_destroy(object_00);
  }
  pGVar3 = gts_segment_class();
                    // WARNING: Could not recover jumptable at 0x0813987a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*((pGVar3->parent_class).parent_class)->destroy)();
  return;
}



void gts_fifo_foreach(GtsFifo *fifo,GtsFunc *func,gpointer data)

{
  GList *pGVar1;
  
  if ((fifo != (GtsFifo *)0x0) && (func != (GtsFunc *)0x0)) {
    pGVar1 = fifo->tail;
    while (pGVar1 != (GList *)0x0) {
      (*func)(pGVar1->data,data);
      pGVar1 = pGVar1->prev;
    }
    return;
  }
  g_return_if_fail_warning();
  return;
}



gboolean gts_fifo_is_empty(GtsFifo *fifo)

{
  char "gts_fifo_is_empty" [18];
  
  if (fifo != (GtsFifo *)0x0) {
    return (uint)(fifo->head == (GList *)0x0);
  }
  g_return_if_fail_warning(0,"gts_fifo_is_empty","fifo != NULL");
  return 1;
}



gpointer gts_fifo_top(GtsFifo *fifo)

{
  char "gts_fifo_top" [13];
  gpointer pvVar1;
  
  if (fifo != (GtsFifo *)0x0) {
    pvVar1 = (gpointer)0x0;
    if (fifo->tail != (GList *)0x0) {
      pvVar1 = fifo->tail->data;
    }
    return pvVar1;
  }
  g_return_if_fail_warning(0,"gts_fifo_top","fifo != NULL");
  return (gpointer)0x0;
}



void gts_fifo_reverse(GtsFifo *fifo)

{
  char "gts_fifo_reverse" [17];
  GList *pGVar1;
  
  if (fifo != (GtsFifo *)0x0) {
    fifo->tail = fifo->head;
    pGVar1 = (GList *)g_list_reverse(fifo->head);
    fifo->head = pGVar1;
    return;
  }
  g_return_if_fail_warning(0,"gts_fifo_reverse","fifo != NULL");
  return;
}



void gts_fifo_destroy(GtsFifo *fifo)

{
  char "gts_fifo_destroy" [17];
  
  if (fifo != (GtsFifo *)0x0) {
    g_list_free(fifo->head);
    g_free();
    return;
  }
  g_return_if_fail_warning(0,"gts_fifo_destroy","fifo != NULL");
  return;
}



guint gts_fifo_size(GtsFifo *fifo)

{
  char "gts_fifo_size" [14];
  guint gVar1;
  
  if (fifo != (GtsFifo *)0x0) {
    gVar1 = g_list_length();
    return gVar1;
  }
  g_return_if_fail_warning(0,"gts_fifo_size","fifo != NULL");
  return 0;
}



gpointer gts_fifo_pop(GtsFifo *fifo)

{
  GList *pGVar1;
  char "gts_fifo_pop" [13];
  GList *pGVar2;
  gpointer pvVar3;
  
  if (fifo == (GtsFifo *)0x0) {
    pvVar3 = (gpointer)0x0;
    g_return_if_fail_warning(0,"gts_fifo_pop","fifo != NULL");
  }
  else {
    pGVar2 = fifo->tail;
    pvVar3 = (gpointer)0x0;
    if (pGVar2 != (GList *)0x0) {
      pGVar1 = pGVar2->prev;
      pvVar3 = pGVar2->data;
      pGVar2 = (GList *)g_list_remove_link(fifo->head,pGVar2);
      fifo->head = pGVar2;
      g_list_free_1(fifo->tail);
      fifo->tail = pGVar1;
    }
  }
  return pvVar3;
}



void gts_fifo_push(GtsFifo *fifo,gpointer data)

{
  char "gts_fifo_push" [14];
  GList *pGVar1;
  
  if (fifo == (GtsFifo *)0x0) {
    g_return_if_fail_warning(0,"gts_fifo_push","fifo != NULL");
    return;
  }
  pGVar1 = (GList *)g_list_prepend(fifo->head,data);
  fifo->head = pGVar1;
  if (fifo->tail != (GList *)0x0) {
    return;
  }
  fifo->tail = pGVar1;
  return;
}



void gts_fifo_write(GtsFifo *fifo,FILE *fp)

{
  GList *pGVar1;
  char "gts_fifo_write" [15];
  
  if (fifo == (GtsFifo *)0x0) {
    g_return_if_fail_warning(0,"gts_fifo_write","fifo != NULL");
    return;
  }
  if (fp == (FILE *)0x0) {
    g_return_if_fail_warning(0,0x8161f57,0x8160d6c);
    return;
  }
  __fprintf_chk(fp,1,&DAT_0814748b);
  pGVar1 = fifo->head;
  while (pGVar1 != (GList *)0x0) {
    __fprintf_chk(fp,1,&DAT_08161ed8,pGVar1->data);
    pGVar1 = pGVar1->next;
  }
  __fprintf_chk(fp,1,&DAT_0815389e);
  return;
}



GtsFifo * gts_fifo_new(void)

{
  GtsFifo *pGVar1;
  
  pGVar1 = (GtsFifo *)g_malloc(8);
  pGVar1->tail = (GList *)0x0;
  pGVar1->head = (GList *)0x0;
  return pGVar1;
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x08139cce)
// WARNING: Removing unreachable block (ram,0x08139cd0)

void __libc_csu_init(void)

{
  EVP_PKEY_CTX *local_2c;
  
  _init(local_2c);
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int atexit(__func *__func)

{
  int iVar1;
  
  iVar1 = __cxa_atexit(__func,0,__dso_handle);
  return iVar1;
}



void __do_global_ctors_aux(void)

{
  code *pcVar1;
  code **ppcVar2;
  
  if (__CTOR_LIST__ != (code *)0xffffffff) {
    ppcVar2 = (code **)&__CTOR_LIST__;
    pcVar1 = __CTOR_LIST__;
    do {
      ppcVar2 = ppcVar2 + -1;
      (*pcVar1)();
      pcVar1 = *ppcVar2;
    } while (pcVar1 != (code *)0xffffffff);
  }
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


