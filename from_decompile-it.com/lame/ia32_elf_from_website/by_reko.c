// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_fini.h"

// 0805483C: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_init.h"

// 0804A00C: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	if (g_dw805AFF8 != 0x00)
		__gmon_start__();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_plt.h"

// 0804A04C: void fileno()
void fileno()
{
}

// 0804A05C: void ldexp()
void ldexp()
{
}

// 0804A06C: void lame_get_in_samplerate()
void lame_get_in_samplerate()
{
}

// 0804A07C: void fputs()
void fputs()
{
}

// 0804A08C: void get_lame_version()
void get_lame_version()
{
}

// 0804A09C: void sprintf()
void sprintf()
{
}

// 0804A0AC: void popen()
void popen()
{
}

// 0804A0BC: void lame_set_num_channels()
void lame_set_num_channels()
{
}

// 0804A0CC: void id3tag_v1_only()
void id3tag_v1_only()
{
}

// 0804A0DC: void id3tag_v2_only()
void id3tag_v2_only()
{
}

// 0804A0EC: void id3tag_set_albumart()
void id3tag_set_albumart()
{
}

// 0804A0FC: void memcmp()
void memcmp()
{
}

// 0804A10C: void lame_stereo_mode_hist()
void lame_stereo_mode_hist()
{
}

// 0804A11C: void lame_get_RadioGain()
void lame_get_RadioGain()
{
}

// 0804A12C: void lame_set_scale_right()
void lame_set_scale_right()
{
}

// 0804A13C: void getchar()
void getchar()
{
}

// 0804A14C: void lame_set_decode_only()
void lame_set_decode_only()
{
}

// 0804A15C: void lame_bitrate_hist()
void lame_bitrate_hist()
{
}

// 0804A16C: void lame_get_noclipGainChange()
void lame_get_noclipGainChange()
{
}

// 0804A17C: void id3tag_init()
void id3tag_init()
{
}

// 0804A18C: void __gmon_start__()
void __gmon_start__()
{
}

// 0804A19C: void __isoc99_sscanf()
void __isoc99_sscanf()
{
}

// 0804A1AC: void __xstat64()
void __xstat64()
{
}

// 0804A1BC: void lame_get_id3v2_tag()
void lame_get_id3v2_tag()
{
}

// 0804A1CC: void get_lame_os_bitness()
void get_lame_os_bitness()
{
}

// 0804A1DC: void getenv()
void getenv()
{
}

// 0804A1EC: void strncpy()
void strncpy()
{
}

// 0804A1FC: void lame_set_error_protection()
void lame_set_error_protection()
{
}

// 0804A20C: void lame_get_num_samples()
void lame_get_num_samples()
{
}

// 0804A21C: void lame_set_debugf()
void lame_set_debugf()
{
}

// 0804A22C: void lame_get_noclipScale()
void lame_get_noclipScale()
{
}

// 0804A23C: void lame_get_compression_ratio()
void lame_get_compression_ratio()
{
}

// 0804A24C: void lame_get_VBR_max_bitrate_kbps()
void lame_get_VBR_max_bitrate_kbps()
{
}

// 0804A25C: void memset()
void memset()
{
}

// 0804A26C: void fopen64()
void fopen64()
{
}

// 0804A27C: void lame_encode_buffer_int()
void lame_encode_buffer_int()
{
}

// 0804A28C: void lame_get_VBR_min_bitrate_kbps()
void lame_get_VBR_min_bitrate_kbps()
{
}

// 0804A29C: void get_lame_url()
void get_lame_url()
{
}

// 0804A2AC: void lame_set_write_id3tag_automatic()
void lame_set_write_id3tag_automatic()
{
}

// 0804A2BC: void __libc_start_main()
void __libc_start_main()
{
}

// 0804A2CC: void id3tag_set_comment()
void id3tag_set_comment()
{
}

// 0804A2DC: void lame_set_decode_on_the_fly()
void lame_set_decode_on_the_fly()
{
}

// 0804A2EC: void _IO_getc()
void _IO_getc()
{
}

// 0804A2FC: void lame_set_VBR_hard_min()
void lame_set_VBR_hard_min()
{
}

// 0804A30C: void lame_get_decode_only()
void lame_get_decode_only()
{
}

// 0804A31C: void lame_get_lametag_frame()
void lame_get_lametag_frame()
{
}

// 0804A32C: void lame_set_strict_ISO()
void lame_set_strict_ISO()
{
}

// 0804A33C: void lame_set_useTemporal()
void lame_set_useTemporal()
{
}

// 0804A34C: void lame_set_force_ms()
void lame_set_force_ms()
{
}

// 0804A35C: void lame_set_compression_ratio()
void lame_set_compression_ratio()
{
}

// 0804A36C: void gettimeofday()
void gettimeofday()
{
}

// 0804A37C: void free()
void free()
{
}

// 0804A38C: void lame_set_VBR_quality()
void lame_set_VBR_quality()
{
}

// 0804A39C: void lame_set_disable_reservoir()
void lame_set_disable_reservoir()
{
}

// 0804A3AC: void hip_decode1_headers()
void hip_decode1_headers()
{
}

// 0804A3BC: void lame_close()
void lame_close()
{
}

// 0804A3CC: void lame_set_nogap_total()
void lame_set_nogap_total()
{
}

// 0804A3DC: void tgetent()
void tgetent()
{
}

// 0804A3EC: void fflush()
void fflush()
{
}

// 0804A3FC: void lame_get_encoder_delay()
void lame_get_encoder_delay()
{
}

// 0804A40C: void fseek()
void fseek()
{
}

// 0804A41C: void lame_set_VBR_min_bitrate_kbps()
void lame_set_VBR_min_bitrate_kbps()
{
}

// 0804A42C: void lame_set_free_format()
void lame_set_free_format()
{
}

// 0804A43C: void fclose()
void fclose()
{
}

// 0804A44C: void lame_set_errorf()
void lame_set_errorf()
{
}

// 0804A45C: void lame_init_bitstream()
void lame_init_bitstream()
{
}

// 0804A46C: void lame_set_exp_nspsytune()
void lame_set_exp_nspsytune()
{
}

// 0804A47C: void clock()
void clock()
{
}

// 0804A48C: void memcpy()
void memcpy()
{
}

// 0804A49C: void lame_get_decode_on_the_fly()
void lame_get_decode_on_the_fly()
{
}

// 0804A4AC: void strlen()
void strlen()
{
}

// 0804A4BC: void lame_set_VBR()
void lame_set_VBR()
{
}

// 0804A4CC: void lame_print_config()
void lame_print_config()
{
}

// 0804A4DC: void lame_get_bWriteVbrTag()
void lame_get_bWriteVbrTag()
{
}

// 0804A4EC: void lame_bitrate_stereo_mode_hist()
void lame_bitrate_stereo_mode_hist()
{
}

// 0804A4FC: void lame_set_nogap_currentindex()
void lame_set_nogap_currentindex()
{
}

// 0804A50C: void lame_set_msfix()
void lame_set_msfix()
{
}

// 0804A51C: void lame_get_VBR()
void lame_get_VBR()
{
}

// 0804A52C: void lame_set_athaa_sensitivity()
void lame_set_athaa_sensitivity()
{
}

// 0804A53C: void feof()
void feof()
{
}

// 0804A54C: void strcpy()
void strcpy()
{
}

// 0804A55C: void ftell()
void ftell()
{
}

// 0804A56C: void lame_set_out_samplerate()
void lame_set_out_samplerate()
{
}

// 0804A57C: void lame_set_asm_optimizations()
void lame_set_asm_optimizations()
{
}

// 0804A58C: void lame_get_quality()
void lame_get_quality()
{
}

// 0804A59C: void id3tag_set_title()
void id3tag_set_title()
{
}

// 0804A5AC: void lame_block_type_hist()
void lame_block_type_hist()
{
}

// 0804A5BC: void lame_set_brate()
void lame_set_brate()
{
}

// 0804A5CC: void atoi()
void atoi()
{
}

// 0804A5DC: void lame_bitrate_kbps()
void lame_bitrate_kbps()
{
}

// 0804A5EC: void lame_set_findReplayGain()
void lame_set_findReplayGain()
{
}

// 0804A5FC: void lame_get_framesize()
void lame_get_framesize()
{
}

// 0804A60C: void atof()
void atof()
{
}

// 0804A61C: void id3tag_set_artist()
void id3tag_set_artist()
{
}

// 0804A62C: void lame_encode_flush()
void lame_encode_flush()
{
}

// 0804A63C: void lame_set_highpassfreq()
void lame_set_highpassfreq()
{
}

// 0804A64C: void fwrite()
void fwrite()
{
}

// 0804A65C: void fprintf()
void fprintf()
{
}

// 0804A66C: void lame_set_VBR_mean_bitrate_kbps()
void lame_set_VBR_mean_bitrate_kbps()
{
}

// 0804A67C: void lame_set_quality()
void lame_set_quality()
{
}

// 0804A68C: void setvbuf()
void setvbuf()
{
}

// 0804A69C: void strncat()
void strncat()
{
}

// 0804A6AC: void lame_get_mode()
void lame_get_mode()
{
}

// 0804A6BC: void lame_set_msgf()
void lame_set_msgf()
{
}

// 0804A6CC: void id3tag_set_year()
void id3tag_set_year()
{
}

// 0804A6DC: void id3tag_set_album()
void id3tag_set_album()
{
}

// 0804A6EC: void malloc()
void malloc()
{
}

// 0804A6FC: void lame_get_totalframes()
void lame_get_totalframes()
{
}

// 0804A70C: void __stack_chk_fail()
void __stack_chk_fail()
{
}

// 0804A71C: void id3tag_set_pad()
void id3tag_set_pad()
{
}

// 0804A72C: void lame_encode_flush_nogap()
void lame_encode_flush_nogap()
{
}

// 0804A73C: void fputc()
void fputc()
{
}

// 0804A74C: void lame_set_VBR_max_bitrate_kbps()
void lame_set_VBR_max_bitrate_kbps()
{
}

// 0804A75C: void lame_get_num_channels()
void lame_get_num_channels()
{
}

// 0804A76C: void hip_decode_init()
void hip_decode_init()
{
}

// 0804A77C: void lame_set_original()
void lame_set_original()
{
}

// 0804A78C: void id3tag_pad_v2()
void id3tag_pad_v2()
{
}

// 0804A79C: void tgetnum()
void tgetnum()
{
}

// 0804A7AC: void lame_get_version()
void lame_get_version()
{
}

// 0804A7BC: void id3tag_add_v2()
void id3tag_add_v2()
{
}

// 0804A7CC: void lame_init_params()
void lame_init_params()
{
}

// 0804A7DC: void lame_set_bWriteVbrTag()
void lame_set_bWriteVbrTag()
{
}

// 0804A7EC: void strcat()
void strcat()
{
}

// 0804A7FC: void lame_get_id3v1_tag()
void lame_get_id3v1_tag()
{
}

// 0804A80C: void id3tag_genre_list()
void id3tag_genre_list()
{
}

// 0804A81C: void lame_get_exp_nspsytune()
void lame_get_exp_nspsytune()
{
}

// 0804A82C: void id3tag_set_track()
void id3tag_set_track()
{
}

// 0804A83C: void __fxstat64()
void __fxstat64()
{
}

// 0804A84C: void lame_get_frameNum()
void lame_get_frameNum()
{
}

// 0804A85C: void lame_set_interChRatio()
void lame_set_interChRatio()
{
}

// 0804A86C: void id3tag_set_genre()
void id3tag_set_genre()
{
}

// 0804A87C: void lame_set_num_samples()
void lame_set_num_samples()
{
}

// 0804A88C: void lame_set_preset()
void lame_set_preset()
{
}

// 0804A89C: void lame_get_free_format()
void lame_get_free_format()
{
}

// 0804A8AC: void lame_set_emphasis()
void lame_set_emphasis()
{
}

// 0804A8BC: void lame_set_mode()
void lame_set_mode()
{
}

// 0804A8CC: void hip_decode_exit()
void hip_decode_exit()
{
}

// 0804A8DC: void lame_print_internals()
void lame_print_internals()
{
}

// 0804A8EC: void vfprintf()
void vfprintf()
{
}

// 0804A8FC: void lame_set_experimentalY()
void lame_set_experimentalY()
{
}

// 0804A90C: void _IO_putc()
void _IO_putc()
{
}

// 0804A91C: void lame_get_VBR_quality()
void lame_get_VBR_quality()
{
}

// 0804A92C: void lame_get_findReplayGain()
void lame_get_findReplayGain()
{
}

// 0804A93C: void lame_set_in_samplerate()
void lame_set_in_samplerate()
{
}

// 0804A94C: void fread()
void fread()
{
}

// 0804A95C: void lame_get_out_samplerate()
void lame_get_out_samplerate()
{
}

// 0804A96C: void lame_set_VBR_q()
void lame_set_VBR_q()
{
}

// 0804A97C: void tgetstr()
void tgetstr()
{
}

// 0804A98C: void lame_get_force_ms()
void lame_get_force_ms()
{
}

// 0804A99C: void lame_set_lowpassfreq()
void lame_set_lowpassfreq()
{
}

// 0804A9AC: void lame_set_scale_left()
void lame_set_scale_left()
{
}

// 0804A9BC: void lame_get_brate()
void lame_get_brate()
{
}

// 0804A9CC: void lame_init()
void lame_init()
{
}

// 0804A9DC: void lame_set_highpasswidth()
void lame_set_highpasswidth()
{
}

// 0804A9EC: void strdup()
void strdup()
{
}

// 0804A9FC: void id3tag_set_fieldvalue()
void id3tag_set_fieldvalue()
{
}

// 0804AA0C: void lame_set_scale()
void lame_set_scale()
{
}

// 0804AA1C: void ferror()
void ferror()
{
}

// 0804AA2C: void hip_decode1_headersB()
void hip_decode1_headersB()
{
}

// 0804AA3C: void tolower()
void tolower()
{
}

// 0804AA4C: void lame_set_copyright()
void lame_set_copyright()
{
}

// 0804AA5C: void lame_set_lowpasswidth()
void lame_set_lowpasswidth()
{
}

// 0804AA6C: void strcmp()
void strcmp()
{
}

// 0804AA7C: void exit()
void exit()
{
}

// 0804AA8C: void id3tag_space_v1()
void id3tag_space_v1()
{
}

// 0804AA9C: void lame_get_VBR_q()
void lame_get_VBR_q()
{
}

// 0804AAAC: void pclose()
void pclose()
{
}

// 0804AABC: void lame_get_VBR_mean_bitrate_kbps()
void lame_get_VBR_mean_bitrate_kbps()
{
}

// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 0804AAD0: void _start(Register (ptr32 Eq_14) edx, Stack int32 dwArg00)
void _start(void (* edx)(), int32 dwArg00)
{
	__align((char *) fp + 4);
	__libc_start_main(&g_t804BFA5, dwArg00, (char *) fp + 4, &g_t8054730, &g_t8054720, edx, fp);
	__hlt();
}

// 0804AB00: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b805B3C4 == 0x00)
	{
		uint32 eax_14 = g_dw805B3C8;
		while (eax_14 < 0x00)
		{
			uint32 eax_24 = eax_14 + 0x01;
			g_dw805B3C8 = eax_24;
			(*((char *) g_a805AF04 + eax_24 * 0x04))();
			eax_14 = g_dw805B3C8;
		}
		g_b805B3C4 = 0x01;
	}
}

// 0804AB60: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
	if (g_dw805AF0C != 0x00 && 0x00 != 0x00)
		fn00000000();
}

// 0804AB84: void parse_args_from_string(Stack Eq_74 dwArg04, Stack Eq_75 dwArg08, Stack Eq_75 dwArg0C, Stack Eq_75 dwArg10)
// Called from:
//      main
void parse_args_from_string(Eq_74 dwArg04, Eq_75 dwArg08, Eq_75 dwArg0C, Eq_75 dwArg10)
{
	if (dwArg08 != 0x00 && (byte) ((word32) (*dwArg08)) != 0x00)
	{
		word32 eax_23 = malloc(strlen(dwArg08) + 0x01);
		strcpy(eax_23, dwArg08);
		Eq_75 dwLoc10_117 = eax_23;
		int32 dwLoc18_121 = 0x01;
		while (true)
		{
			(fp - 0x021C)[dwLoc18_121] = dwLoc10_117;
			int32 v12_42 = dwLoc18_121 + 0x01;
			dwLoc18_121 = v12_42;
			while ((byte) (word32) *dwLoc10_117 != 0x20 && (byte) ((word32) (*dwLoc10_117)) != 0x00)
				dwLoc10_117 = (word32) dwLoc10_117 + 1;
			if ((byte) (word32) *dwLoc10_117 == 0x00)
				break;
			*dwLoc10_117 = 0x00;
			dwLoc10_117 = (word32) dwLoc10_117 + 1;
		}
		(fp - 0x021C)[v12_42] = 0x00;
		int8 Top_186;
		parse_args(dwArg04, v12_42, fp - 0x021C, dwArg0C, dwArg10, null, null, out Top_186);
		free(eax_23);
	}
}

// 0804AC92: Register word32 init_files(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_75 dwArg08, Stack Eq_75 dwArg0C, Stack ptr32 dwArg10, Stack ptr32 dwArg14)
// Called from:
//      main
word32 init_files(struct Eq_172 * gs, Eq_74 dwArg04, Eq_75 dwArg08, Eq_75 dwArg0C, ptr32 dwArg10, ptr32 dwArg14)
{
	word32 eax_116;
	if (strcmp(0x08054866, dwArg0C) != 0x00 && strcmp(dwArg08, dwArg0C) == 0x00)
	{
		error_printf("Input file and Output file are the same. Abort.\n");
		eax_116 = 0x00;
	}
	else
	{
		init_infile(gs, dwArg04, dwArg08, dwArg10, dwArg14);
		word32 ecx_49;
		lame_get_decode_only();
		word32 eax_56 = init_outfile(dwArg0C);
		if (eax_56 == 0x00)
		{
			error_printf("Can't init outfile '%s'\n");
			eax_116 = 0x00;
		}
		else
			eax_116 = eax_56;
	}
	return eax_116;
}

// 0804AD3A: void lame_decoder(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack Eq_222 dwArg0C, Stack Eq_75 dwArg10, Stack Eq_75 dwArg14, Stack (ptr32 int32) dwArg18, Stack (ptr32 int32) dwArg1C)
// Called from:
//      main
void lame_decoder(struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08, Eq_222 dwArg0C, Eq_75 dwArg10, Eq_75 dwArg14, int32 * dwArg18, int32 * dwArg1C)
{
	Eq_227 eax_19;
	lame_get_num_channels();
	Eq_230 dwLoc14_1111 = 0x00;
	if (g_dw805C54C <= 0x09)
	{
		lame_get_in_samplerate();
		strlen(dwArg10) <= 0x1A;
		strcmp(dwArg10, 0x08054866) == 0x00;
		console_printf("\rinput:  %s%s(%g kHz, %i channel%s, ");
	}
	Eq_236 eax_95 = g_t805C544;
	if (eax_95 > 0x07)
		goto l0804B07E;
	switch (g_a8054A58[eax_95 * 0x04])
	{
	case 0x00:
l0804B07E:
		if (g_dw805C54C <= 0x09)
			console_printf("unknown");
		word32 eax_389;
		lame_get_num_samples();
		g_dw805C57C = eax_389;
		g_t805C578.u0 = 0x0480;
		dwArg0C.u0 = 0x00;
		break;
	case 0x01:
		if (g_dw805C54C <= 0x09)
			console_printf("raw PCM data");
		word32 eax_359;
		lame_get_num_samples();
		g_dw805C57C = eax_359;
		g_t805C578.u0 = 0x0480;
		dwArg0C.u0 = 0x00;
		break;
	case 0x02:
		if (g_dw805C54C <= 0x09)
			console_printf("Microsoft WAVE");
		word32 eax_335;
		lame_get_num_samples();
		g_dw805C57C = eax_335;
		g_t805C578.u0 = 0x0480;
		dwArg0C.u0 = 0x00;
		break;
	case 0x03:
		if (g_dw805C54C <= 0x09)
			console_printf("SGI/Apple AIFF");
		word32 eax_311;
		lame_get_num_samples();
		g_dw805C57C = eax_311;
		g_t805C578.u0 = 0x0480;
		dwArg0C.u0 = 0x00;
		break;
	case 0x04:
		dwArg0C = (word32) dwArg0C.u0 + 0x00F1;
		if (g_dw805C54C <= 0x09)
		{
			int32 eax_260;
			lame_get_out_samplerate();
			lame_get_version();
			console_printf("MPEG-%u%s Layer %s");
		}
		break;
	case 0x05:
		dwArg0C = (word32) dwArg0C + 0x00F1;
		if (g_dw805C54C <= 0x09)
		{
			int32 eax_219;
			lame_get_out_samplerate();
			lame_get_version();
			console_printf("MPEG-%u%s Layer %s");
		}
		break;
	case 0x06:
		if (dwArg0C == 0x00)
		{
			if (*dwArg18 < 0x00 && *dwArg1C < 0x00)
			{
				word32 eax_128;
				lame_get_encoder_delay();
				dwArg0C = eax_128 + 0x0211;
			}
			else
			{
				if (*dwArg18 >= 0x00)
					dwArg0C = *dwArg18 + 0x0211;
				if (*dwArg1C >= 0x00)
					dwLoc14_1111 = *dwArg1C - 0x0211;
			}
		}
		else
			dwArg0C = (word32) dwArg0C.u0 + 0x0211;
		if (g_dw805C54C <= 0x09)
		{
			int32 eax_178;
			lame_get_out_samplerate();
			lame_get_version();
			console_printf("MPEG-%u%s Layer %s");
		}
		break;
	case 0x07:
		error_printf("Internal error.  Aborting.");
		exit(~0x00);
	}
	if (g_dw805C54C <= 0x09)
	{
		strlen(dwArg14) <= 0x2D;
		strcmp(dwArg14, 0x08054866) == 0x00;
		console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
		if (dwArg0C > 0x00)
			console_printf("skipping initial %i samples (encoder+decoder delay)\n");
		if (dwLoc14_1111 > 0x00)
			console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
	}
	if (g_dw805C558 == 0x00)
	{
		Eq_385 eax_478;
		lame_get_in_samplerate();
		WriteWaveHeader(dwArg08, 0x7FFFFFFF, eax_478, eax_19, 0x10);
	}
	real64 rLoc2C_1203 = (real64) -(dwArg0C + dwLoc14_1111);
	g_t805C580.u1 = (uint32) ((uint64) (uint32) g_dw805C57C /u g_t805C578);
	do
	{
		Eq_222 eax_533 = get_audio16(gs, dwArg04, fp->aFFFFEDD4);
		Eq_222 dwLoc10_1209 = eax_533;
		if (eax_533 >= 0x00)
		{
			g_t805C584 = (word32) g_t805C584 + (int32) (SEQ(eax_533 >> 0x1F, eax_533) / g_t805C578);
			rLoc2C_1203 = (real64) eax_533 + rLoc2C_1203;
			if (g_dw805C54C <= 0x00)
			{
				decoder_progress(&g_t805C560);
				console_flush();
			}
			Eq_222 eax_582 = dwArg0C;
			if (eax_533 <= dwArg0C)
				eax_582 = eax_533;
			Eq_222 dwLoc18_1220 = eax_582;
			dwArg0C -= eax_582;
			if (dwLoc14_1111 > 0x0480 && (word32) g_t805C584 + 2 > g_t805C580)
			{
				dwLoc10_1209 = eax_533 + (0x0480 - dwLoc14_1111);
				dwLoc14_1111.u0 = 0x0480;
			}
			else if (g_t805C584 == g_t805C580 && eax_533 != 0x00)
				dwLoc10_1209 = eax_533 - dwLoc14_1111;
			while (dwLoc18_1220 < dwLoc10_1209)
			{
				if (g_dw805C558 != 0x00)
				{
					WriteBytesSwapped(dwArg08, fp->aFFFFEDD4 + dwLoc18_1220, 0x02);
					if (eax_19 == 0x02)
						WriteBytesSwapped(dwArg08, fp->aFFFFEDD4 + ((word32) dwLoc18_1220 + 1152), 0x02);
				}
				else
				{
					Write16BitsLowHigh(dwArg08, (int32) (word16) (word32) fp->aFFFFEDD4[dwLoc18_1220]);
					if (eax_19 == 0x02)
						Write16BitsLowHigh(dwArg08, (int32) (word16) (word32) fp->aFFFFEDD4[(word32) dwLoc18_1220 + 1152]);
				}
				dwLoc18_1220 = (word32) dwLoc18_1220.u0 + 1;
			}
			if (g_dw805B3F0 == 0x01)
				fflush(dwArg08);
		}
	} while (dwLoc10_1209 > 0x00);
	real64 rLoc2C_1275;
	if (rLoc2C_1203 <= 0.0 != 0x00)
	{
		if (g_dw805C54C <= 0x09)
			error_printf("WAVE file contains 0 PCM samples\n");
		rLoc2C_1275 = 0.0;
	}
	else if (rLoc2C_1203 > (real64) ((uint64) ((uint32) (0xFFFFFFD0 /u (eax_19 * 0x02)))) != 0x00)
	{
		if (g_dw805C54C <= 0x09)
			error_printf("Very huge WAVE file, can't set filesize accordingly\n");
		rLoc2C_1275 = g_r8054F10;
	}
	else
		rLoc2C_1275 = (real64) (eax_19 * 0x02) * rLoc2C_1203;
	if (g_dw805C558 == 0x00 && (strcmp(0x08054866, dwArg14) != 0x00 && fseek(dwArg08, 0x00, 0x00) == 0x00))
	{
		Eq_385 eax_844;
		lame_get_in_samplerate();
		uint16 wLoc122E_1364 = __fstcw();
		__fldcw((word16) (word32) wLoc122E_1364);
		__fldcw(wLoc122E_1364);
		WriteWaveHeader(dwArg08, (int32) rLoc2C_1275, eax_844, eax_19, 0x10);
	}
	fclose(dwArg08);
	if (g_dw805C54C <= 0x00)
		decoder_progress_finish();
}

// 0804B4F0: void print_lame_tag_leading_info(Stack Eq_74 dwArg04)
// Called from:
//      lame_encoder
void print_lame_tag_leading_info(Eq_74 dwArg04)
{
	word32 eax_12;
	lame_get_bWriteVbrTag();
	if (eax_12 != 0x00)
		console_printf("Writing LAME Tag...");
}

// 0804B513: Register int8 print_trailing_info(Stack Eq_74 dwArg04, FpuStack real64 rArg0, FpuStack out Eq_709 rArg0Out)
// Called from:
//      lame_encoder
int8 print_trailing_info(Eq_74 dwArg04, real64 rArg0, union Eq_709 & rArg0Out)
{
	word32 eax_12;
	lame_get_bWriteVbrTag();
	if (eax_12 != 0x00)
		console_printf("done\n");
	word32 eax_29;
	lame_get_findReplayGain();
	if (eax_29 != 0x00)
	{
		int32 eax_37;
		lame_get_RadioGain();
		console_printf("ReplayGain: %s%.1fdB\n");
		if (eax_37 > 0x01FE || eax_37 < ~0x01FD)
			error_printf("WARNING: ReplayGain exceeds the -51dB to +51dB range. Such a result is too\n         high to be stored in the header.\n");
	}
	int8 Top_141 = 0;
	if (g_dw805C554 != 0x00)
	{
		word32 eax_88;
		lame_get_decode_on_the_fly();
		if (eax_88 != 0x00)
		{
			word32 eax_96;
			lame_get_noclipGainChange();
			real32 rLoc14_244 = (real32) ((real64) eax_96 / (real64) g_r8054F20);
			lame_get_noclipScale();
			real32 rLoc18_251 = (real32) rArg0;
			if ((real64) rLoc14_244 > 0.0 != 0x00)
			{
				console_printf("WARNING: clipping occurs at the current gain. Set your decoder to decrease\n         the  gain  by  at least %.1fdB or encode again ");
				Top_141 = 1;
				if ((real64) rLoc18_251 > 0.0 != 0x00)
				{
					console_printf("using  --scale %.2f\n");
					console_printf("         or less (the value under --scale is approximate).\n");
					Top_141 = 1;
				}
				else
					console_printf("using --scale <arg>\n         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n         with  --scale 1  first)\n");
			}
			else
			{
				Top_141 = 1;
				if ((real64) rLoc14_244 > g_t8054F28 != 0x00)
					console_printf("\nThe waveform does not clip and is less than 0.1dB away from full scale.\n");
				else
				{
					console_printf("\nThe waveform does not clip and is at least %.1fdB away from full scale.\n");
					Top_141 = 1;
				}
			}
		}
	}
	rArg0Out.u0 = <invalid>;
	return Top_141;
}

// 0804B68B: void write_xing_frame(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08)
// Called from:
//      lame_encoder
void write_xing_frame(struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08)
{
	word32 eax_14 = gs->dw0014;
	Eq_74 eax_24;
	lame_get_lametag_frame();
	if (eax_24 > 0x00024000)
		error_printf("Error writing LAME-tag frame: buffer too small: buffer size=%d  frame size=%d\n");
	else if (eax_24 != 0x00)
	{
		if (fwrite(fp + ~0x0002400F, 0x01, eax_24, dwArg08) != eax_24)
			error_printf("Error writing LAME-tag \n");
		else if (g_dw805B3F0 == 0x01)
			fflush(dwArg08);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B79A: Register (ptr8 real64) lame_encoder(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack word32 dwArg0C, Stack Eq_75 dwArg10, Stack Eq_75 dwArg14, FpuStack real64 rArg0)
// Called from:
//      main
real64 * lame_encoder(struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08, word32 dwArg0C, Eq_75 dwArg10, Eq_75 dwArg14, real64 rArg0)
{
	word32 eax_18 = gs->dw0014;
	real64 rRet0_37;
	real64 * Top_31 = encoder_progress_begin(dwArg04, dwArg10, dwArg14, rArg0, out rRet0_37);
	*Top_31 = rRet0_37;
	Eq_74 eax_44;
	lame_get_id3v2_tag();
	if (eax_44 > 0x00024000)
	{
		encoder_progress_end(gs, dwArg04);
		error_printf("Error writing ID3v2 tag: buffer too small: buffer size=%d  ID3v2 size=%d\n");
		goto l0804BC72;
	}
	if (fwrite(fp + ~0x0002400F, 0x01, eax_44, dwArg08) != eax_44)
	{
		encoder_progress_end(gs, dwArg04);
		error_printf("Error writing ID3v2 tag \n");
		goto l0804BC72;
	}
	if (g_dw805B3F0 == 0x01)
		fflush(dwArg08);
	do
	{
		int32 eax_81 = get_audio(gs, dwArg04, fp + ~0x0002641F);
		if (eax_81 >= 0x00)
		{
			encoder_progress(gs, dwArg04);
			Eq_74 eax_114;
			lame_encode_buffer_int();
			if (eax_114 < 0x00)
			{
				if (eax_114 == ~0x00)
					error_printf("mp3 buffer is not big enough... \n");
				else
					error_printf("mp3 internal error:  error code=%i\n");
				goto l0804BC72;
			}
			if (fwrite(fp + ~0x0002400F, 0x01, eax_114, dwArg08) != eax_114)
			{
				error_printf("Error writing mp3 output \n");
				goto l0804BC72;
			}
		}
		if (g_dw805B3F0 == 0x01)
			fflush(dwArg08);
	} while (eax_81 > 0x00);
	Eq_74 dwLoc24018_511;
	if (dwArg0C != 0x00)
	{
		Eq_74 eax_168;
		lame_encode_flush_nogap();
		dwLoc24018_511 = eax_168;
	}
	else
	{
		Eq_74 eax_158;
		lame_encode_flush();
		dwLoc24018_511 = eax_158;
	}
	if (dwLoc24018_511 < 0x00)
	{
		if (dwLoc24018_511 == ~0x00)
			error_printf("mp3 buffer is not big enough... \n");
		else
			error_printf("mp3 internal error:  error code=%i\n");
	}
	else
	{
		encoder_progress_end(gs, dwArg04);
		if (fwrite(fp + ~0x0002400F, 0x01, dwLoc24018_511, dwArg08) != dwLoc24018_511)
		{
			error_printf("Error writing mp3 output \n");
			goto l0804BC72;
		}
		if (g_dw805B3F0 == 0x01)
			fflush(dwArg08);
		Eq_74 eax_216;
		lame_get_id3v1_tag();
		if (eax_216 > 0x00024000)
			error_printf("Error writing ID3v1 tag: buffer too small: buffer size=%d  ID3v1 size=%d\n");
		else if (eax_216 > 0x00)
		{
			if (fwrite(fp + ~0x0002400F, 0x01, eax_216, dwArg08) != eax_216)
			{
				error_printf("Error writing ID3v1 tag \n");
				goto l0804BC72;
			}
			if (g_dw805B3F0 == 0x01)
				fflush(dwArg08);
		}
		if (g_dw805C54C <= 0x00)
			print_lame_tag_leading_info(dwArg04);
		if (fseek(dwArg08, eax_44, 0x00) != 0x00)
			error_printf("fatal error: can't update LAME-tag frame!\n");
		else
			write_xing_frame(gs, dwArg04, dwArg08);
		if (g_dw805C54C <= 0x00)
		{
			real64 rRet0_330;
			Top_31 = print_trailing_info(dwArg04, *Top_31, out rRet0_330);
			*Top_31 = rRet0_330;
		}
	}
l0804BC72:
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return Top_31;
	__stack_chk_fail();
}

// 0804BC85: void brhist_init_package(Stack Eq_74 dwArg04)
// Called from:
//      main
void brhist_init_package(Eq_74 dwArg04)
{
	if (g_dw805C55C != 0x00)
	{
		word32 eax_28;
		lame_get_VBR_max_bitrate_kbps();
		word32 eax_34;
		lame_get_VBR_min_bitrate_kbps();
		if (brhist_init(dwArg04, eax_34, eax_28) != 0x00)
			g_dw805C55C = 0x00;
	}
	else
		brhist_init(dwArg04, 0x80, 0x80);
}

// 0804BCF1: void parse_nogap_filenames(Stack word32 dwArg04, Stack Eq_75 dwArg08, Stack Eq_75 dwArg0C, Stack Eq_75 dwArg10)
// Called from:
//      main
void parse_nogap_filenames(word32 dwArg04, Eq_75 dwArg08, Eq_75 dwArg0C, Eq_75 dwArg10)
{
	strcpy(dwArg0C, dwArg10);
	if (dwArg04 == 0x00)
	{
		strncpy(dwArg0C, dwArg08, 0x0FFD);
		Eq_74 eax_207 = strlen(dwArg0C);
		if (SLICE((word32) Mem208[eax_207 - 0x03 + dwArg0C:byte], byte, 0) == 0x77 && (SLICE((word32) Mem208[(eax_207 - 0x02) + dwArg0C:byte], byte, 0) == 0x61 && (SLICE((word32) Mem208[(eax_207 - 0x01) + dwArg0C:byte], byte, 0) == 118 && SLICE((word32) Mem208[(eax_207 - 0x04) + dwArg0C:byte], byte, 0) == 0x2E)))
		{
			Mem263[eax_207 - 0x03 + dwArg0C:byte] = 0x6D;
			Mem267[eax_207 - 0x02 + dwArg0C:byte] = 0x70;
			Mem272[eax_207 - 0x01 + dwArg0C:byte] = 0x33;
		}
		else
		{
			Mem242[dwArg0C + eax_207:byte] = 0x2E;
			Mem246[eax_207 + 0x01 + dwArg0C:byte] = 0x6D;
			Mem250[eax_207 + 0x02 + dwArg0C:byte] = 0x70;
			Mem254[eax_207 + 0x03 + dwArg0C:byte] = 0x33;
			Mem259[eax_207 + 0x04 + dwArg0C:byte] = 0x00;
		}
	}
	else
	{
		Eq_75 dwLoc10_286 = (word32) dwArg08 + 0x0FFD;
		while ((byte) (word32) *dwLoc10_286 != 0x2F && ((byte) ((word32) (*dwLoc10_286)) != 0x5C && (dwLoc10_286 != dwArg08 && (byte) ((word32) (*dwLoc10_286)) != 0x3A)))
			--dwLoc10_286;
		if (dwLoc10_286 != dwArg08 && (SLICE((word32) Mem52[(strlen(dwArg0C) - 0x01) + dwArg0C:byte], byte, 0) == 0x2F || (SLICE((word32) Mem61[(strlen(dwArg0C) - 0x01) + dwArg0C:byte], byte, 0) == 0x5C || SLICE((word32) Mem70[(strlen(dwArg0C) - 0x01) + dwArg0C:byte], byte, 0) == 0x3A)))
			dwLoc10_286 = (word32) dwLoc10_286 + 1;
		else if (dwLoc10_286 == dwArg08 && (SLICE((word32) Mem85[(strlen(dwArg0C) - 0x01) + dwArg0C:byte], byte, 0) != 0x2F && (SLICE((word32) Mem94[(strlen(dwArg0C) - 0x01) + dwArg0C:byte], byte, 0) != 0x5C && SLICE((word32) Mem103[(strlen(dwArg0C) - 0x01) + dwArg0C:byte], byte, 0) != 0x3A)))
			strcat(dwArg0C, "/");
		strncat(dwArg0C, dwLoc10_286, 0x0FFD);
		Eq_74 eax_133 = strlen(dwArg0C);
		if (SLICE((word32) Mem134[eax_133 - 0x03 + dwArg0C:byte], byte, 0) == 0x77 && (SLICE((word32) Mem134[(eax_133 - 0x02) + dwArg0C:byte], byte, 0) == 0x61 && (SLICE((word32) Mem134[(eax_133 - 0x01) + dwArg0C:byte], byte, 0) == 118 && SLICE((word32) Mem134[(eax_133 - 0x04) + dwArg0C:byte], byte, 0) == 0x2E)))
		{
			Mem189[eax_133 - 0x03 + dwArg0C:byte] = 0x6D;
			Mem193[eax_133 - 0x02 + dwArg0C:byte] = 0x70;
			Mem198[eax_133 - 0x01 + dwArg0C:byte] = 0x33;
		}
		else
		{
			Mem168[dwArg0C + eax_133:byte] = 0x2E;
			Mem172[eax_133 + 0x01 + dwArg0C:byte] = 0x6D;
			Mem176[eax_133 + 0x02 + dwArg0C:byte] = 0x70;
			Mem180[eax_133 + 0x03 + dwArg0C:byte] = 0x33;
			Mem185[eax_133 + 0x04 + dwArg0C:byte] = 0x00;
		}
	}
}

// 0804BFA5: void main(Register (ptr32 Eq_172) gs, Stack int32 dwArg04, Stack (arr (ptr32 char)) dwArg08)
void main(struct Eq_172 * gs, int32 dwArg04, char * dwArg08[])
{
	__align(fp - 4);
	word32 eax_15 = gs->dw0014;
	memset(fp - 832552, 0x00, 0x000C80C8);
	word32 dwLoc3030_623 = 0x00;
	int32 dwLoc3038_628;
	for (dwLoc3038_628 = 0x00; dwLoc3038_628 <= 199; ++dwLoc3038_628)
		(fp - 0x3360)[dwLoc3038_628] = fp - 832552 + dwLoc3038_628 * 0x1001;
	memset(fp - 0x301B, 0x00, 0x1001);
	frontend_open_console(gs);
	g_t805C544.u0 = 0x00;
	Eq_74 eax_61;
	lame_init();
	if (eax_61 == 0x00)
	{
		error_printf("fatal error during initialization\n");
		frontend_close_console();
	}
	else
	{
		lame_set_errorf();
		lame_set_debugf();
		lame_set_msgf();
		if (dwArg04 <= 0x01)
		{
			usage(g_t805B3A0, dwArg08[0]);
			lame_close();
			frontend_close_console();
		}
		else
		{
			parse_args_from_string(eax_61, getenv("LAMEOPT"), fp - 0x301B, fp - 0x1019);
			struct Eq_1431 * Top_125;
			if (parse_args(eax_61, dwArg04, dwArg08, fp - 0x301B, fp - 0x1019, fp - 0x3360, fp - 0x3034, out Top_125) < 0x00)
			{
				lame_close();
				frontend_close_console();
			}
			else
			{
				Top_125->tFFFFFFFF.u0 = (real64) g_r805C550;
				Top_125->tFFFFFFFE.u0 = 0.0;
				Top_125->tFFFFFFFF = Top_125->tFFFFFFFF;
				struct Eq_1431 * Top_141 = Top_125;
				if (Top_125->tFFFFFFFE > Top_125->tFFFFFFFF != 0x00)
					g_r805C550 = 2.0F;
				if ((byte) (word32) bLoc1019 != 0x00 && true)
				{
					strncpy(fp - 8218, fp - 0x1019, 0x1001);
					dwLoc3030_623 = 0x01;
				}
				Eq_74 dwLoc303C_675;
				if (true)
				{
					parse_nogap_filenames(dwLoc3030_623, dwLoc3360, fp - 0x1019, fp - 8218);
					dwLoc303C_675 = init_files(gs, eax_61, dwLoc3360, fp - 0x1019, fp - 0x3028, fp - 12332);
				}
				else
					dwLoc303C_675 = init_files(gs, eax_61, fp - 0x301B, fp - 0x1019, fp - 0x3028, fp - 12332);
				if (dwLoc303C_675 == 0x00)
				{
					lame_close();
					frontend_close_console();
				}
				else
				{
					lame_set_write_id3tag_automatic();
					int32 eax_246;
					lame_init_params();
					if (eax_246 < 0x00)
					{
						if (eax_246 == ~0x00)
							display_bitrates(g_t805B3A0);
						error_printf("fatal error during initialization\n");
						lame_close();
						frontend_close_console();
					}
					else
					{
						if (g_dw805C54C > 0x00)
							g_dw805C55C = 0x00;
						word32 eax_265;
						lame_get_decode_only();
						if (eax_265 != 0x00)
						{
							if (g_dw805C548 != 0x00)
								lame_decoder(gs, eax_61, dwLoc303C_675, g_t805C540, fp - 0x301B, fp - 0x1019, fp - 0x3028, fp - 12332);
							else
								lame_decoder(gs, eax_61, dwLoc303C_675, 0x00, fp - 0x301B, fp - 0x1019, fp - 0x3028, fp - 12332);
						}
						else if (true)
						{
							int32 dwLoc3038_725;
							for (dwLoc3038_725 = 0x00; dwLoc3038_725 < 200; ++dwLoc3038_725)
							{
								word32 eax_326 = (word32) (dwLoc3038_725 != 199);
								if (dwLoc3038_725 > 0x00)
								{
									parse_nogap_filenames(dwLoc3030_623, (fp - 0x3360)[dwLoc3038_725], fp - 0x1019, fp - 8218);
									Eq_74 eax_358 = init_files(gs, eax_61, (fp - 0x3360)[dwLoc3038_725], fp - 0x1019, fp - 0x3028, fp - 12332);
									lame_init_bitstream();
									dwLoc303C_675 = eax_358;
								}
								brhist_init_package(eax_61);
								lame_set_nogap_total();
								lame_set_nogap_currentindex();
								Top_141 = lame_encoder(gs, eax_61, dwLoc303C_675, eax_326, (fp - 0x3360)[dwLoc3038_725], fp - 0x1019, Top_141->r0000);
								fclose(dwLoc303C_675);
								close_infile();
							}
						}
						else
						{
							brhist_init_package(eax_61);
							lame_encoder(gs, eax_61, dwLoc303C_675, 0x00, fp - 0x301B, fp - 0x1019, Top_125->r0000);
							fclose(dwLoc303C_675);
							close_infile();
						}
						lame_close();
						frontend_close_console();
					}
				}
			}
		}
	}
	if ((eax_15 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804C6C0: void my_console_printing(Stack Eq_74 dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_1690 dwArg0C)
// Called from:
//      frontend_msgf
//      console_printf
//      error_printf
//      report_printf
void my_console_printing(Eq_74 dwArg04, char * dwArg08, Eq_1690 dwArg0C)
{
	if (dwArg04 != 0x00)
		vfprintf(dwArg04, dwArg08, dwArg0C);
}

// 0804C6EE: void my_error_printing(Stack Eq_74 dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_1690 dwArg0C)
// Called from:
//      frontend_errorf
void my_error_printing(Eq_74 dwArg04, char * dwArg08, Eq_1690 dwArg0C)
{
	if (dwArg04 != 0x00)
		vfprintf(dwArg04, dwArg08, dwArg0C);
}

// 0804C71C: void my_report_printing(Stack Eq_74 dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_1690 dwArg0C)
// Called from:
//      frontend_debugf
void my_report_printing(Eq_74 dwArg04, char * dwArg08, Eq_1690 dwArg0C)
{
	if (dwArg04 != 0x00)
		vfprintf(dwArg04, dwArg08, dwArg0C);
}

// 0804C74A: void apply_termcap_settings(Register (ptr32 Eq_172) gs, Stack (ptr32 Eq_1714) dwArg04)
// Called from:
//      init_console
void apply_termcap_settings(struct Eq_172 * gs, struct Eq_1714 * dwArg04)
{
	word32 eax_12 = gs->dw0014;
	Eq_75 eax_16 = getenv("TERM");
	if (eax_16 != 0x00)
	{
		word32 eax_24;
		word32 edx_25;
		tgetent();
		if (eax_24 == 0x01)
		{
			int32 eax_30;
			word32 edx_31;
			tgetnum();
			if (eax_30 > 0x27 && eax_30 <= 0x0200)
				dwArg04->dw0014 = eax_30;
			int32 eax_46;
			word32 edx_47;
			tgetnum();
			if (eax_46 > 0x0F && eax_46 <= 0x0100)
				dwArg04->dw0018 = eax_46;
			Eq_75 eax_68;
			word32 edx_69;
			tgetstr();
			if (eax_68 != 0x00)
				strcpy(&dwArg04->dw0018 + 1, eax_68);
			Eq_75 eax_94;
			word32 edx_95;
			tgetstr();
			if (eax_94 != 0x00)
				strcpy((char *) &dwArg04->dw0018 + 0x0E, eax_94);
			Eq_75 eax_120;
			word32 edx_121;
			tgetstr();
			if (eax_120 != 0x00)
				strcpy(&dwArg04->dw0018 + 6, eax_120);
			Eq_75 eax_146;
			word32 edx_147;
			tgetstr();
			if (eax_146 != 0x00)
				strcpy((char *) &dwArg04->dw0018 + 0x0022, eax_146);
		}
	}
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804C978: void init_console(Register (ptr32 Eq_172) gs, Stack (ptr32 Eq_1714) dwArg04)
// Called from:
//      frontend_open_console
void init_console(struct Eq_172 * gs, struct Eq_1714 * dwArg04)
{
	dwArg04->dw0014 = 0x50;
	dwArg04->dw0018 = 0x19;
	dwArg04->t0008 = g_t805B3A0;
	dwArg04->t000C = g_t805B3A0;
	dwArg04->dw0010 = 0x00;
	setvbuf(dwArg04->t0008, &dwArg04->dw0018 + 11, 0x00, 0x0800);
	memcpy(&dwArg04->dw0018 + 1, &g_v8054F47, 0x04);
	apply_termcap_settings(gs, dwArg04);
	dwArg04->dw0000 = 0x434F4E53;
	dwArg04->dw0844 = 0x00;
}

// 0804CA23: void deinit_console(Stack (ptr32 Eq_1858) dwArg04)
// Called from:
//      frontend_close_console
void deinit_console(struct Eq_1858 * dwArg04)
{
	if (dwArg04->t0010 != 0x00)
	{
		fclose(dwArg04->t0010);
		dwArg04->t0010 = 0x00;
	}
	fflush(dwArg04->t0008);
	setvbuf(dwArg04->t0008, null, 0x02, 0x00);
	memset(&dwArg04->t0010 + 0x0D, 0x55, 0x0400);
}

// 0804CA9F: void frontend_open_console(Register (ptr32 Eq_172) gs)
// Called from:
//      main
void frontend_open_console(struct Eq_172 * gs)
{
	init_console(gs, &g_t805BCE0);
}

// 0804CAB3: void frontend_close_console()
// Called from:
//      main
void frontend_close_console()
{
	deinit_console(&g_t805BCE0);
}

// 0804CAC7: void frontend_debugf(Stack (ptr32 char) dwArg04, Stack Eq_1690 dwArg08)
void frontend_debugf(char * dwArg04, Eq_1690 dwArg08)
{
	my_report_printing(g_t805BCF0, dwArg04, dwArg08);
}

// 0804CAEA: void frontend_msgf(Stack (ptr32 char) dwArg04, Stack Eq_1690 dwArg08)
void frontend_msgf(char * dwArg04, Eq_1690 dwArg08)
{
	my_console_printing(g_t805BCE8, dwArg04, dwArg08);
}

// 0804CB0D: void frontend_errorf(Stack (ptr32 char) dwArg04, Stack Eq_1690 dwArg08)
void frontend_errorf(char * dwArg04, Eq_1690 dwArg08)
{
	my_error_printing(g_t805BCEC, dwArg04, dwArg08);
}

// 0804CB30: Register (ptr32 char) console_printf(Stack (ptr32 char) dwArg04)
// Called from:
//      lame_decoder
//      print_lame_tag_leading_info
//      print_trailing_info
//      OpenSndFile
//      lame_decode_initfile
//      genre_list_handler
//      parse_args
//      ts_time_decompose
//      timestatus
//      timestatus_finish
//      encoder_progress_begin
//      decoder_progress
//      decoder_progress_finish
//      brhist_disp_line
//      progress_line
//      stats_value
//      stats_head
//      stats_line
char * console_printf(char * dwArg04)
{
	my_console_printing(g_t805BCE8, dwArg04, fp + 0x08);
	return dwArg04;
}

// 0804CB5F: void error_printf(Stack (ptr32 char) dwArg04)
// Called from:
//      init_files
//      lame_decoder
//      print_trailing_info
//      write_xing_frame
//      lame_encoder
//      main
//      set_debug_file
//      fskip
//      read_samples_mp3
//      read_samples_pcm
//      parse_wave_header
//      aiff_check2
//      parse_aiff_header
//      parse_file_header
//      CloseSndFile
//      OpenSndFile
//      lame_decode_initfile
//      presets_set
//      resample_rate
//      set_id3_albumart
//      parse_args
//      brhist_init
void error_printf(char * dwArg04)
{
	my_console_printing(g_t805BCEC, dwArg04, fp + 0x08);
}

// 0804CB8E: void report_printf(Stack (ptr32 char) dwArg04)
void report_printf(char * dwArg04)
{
	my_console_printing(g_t805BCF0, dwArg04, fp + 0x08);
}

// 0804CBBD: void console_flush()
// Called from:
//      lame_decoder
//      console_up
//      encoder_progress
void console_flush()
{
	fflush(g_t805BCE8);
}

// 0804CBD2: void error_flush()
void error_flush()
{
	fflush(g_t805BCEC);
}

// 0804CBE7: void report_flush()
void report_flush()
{
	fflush(g_t805BCF0);
}

// 0804CBFC: void console_up(Stack int32 dwArg04)
// Called from:
//      brhist_jump_back
void console_up(int32 dwArg04)
{
	while (true)
	{
		--dwArg04;
		if (dwArg04 > 0x00 == 0x00)
			break;
		fputs(&g_b805BCFC, g_t805BCE8);
	}
	console_flush();
}

// 0804CC31: void set_debug_file(Stack Eq_75 dwArg04)
void set_debug_file(Eq_75 dwArg04)
{
	if (g_t805BCF0 == 0x00)
	{
		g_t805BCF0 = fopen64(dwArg04, "a");
		if (g_t805BCF0 != 0x00)
			error_printf("writing debug info into: %s\n");
		else
			error_printf("Error: can't open for debug info: %s\n");
	}
}

// 0804CC8C: Register Eq_74 min_size_t(Stack Eq_74 dwArg04, Stack Eq_74 dwArg08)
// Called from:
//      fskip
Eq_74 min_size_t(Eq_74 dwArg04, Eq_74 dwArg08)
{
	Eq_74 eax_11;
	if (dwArg04 < dwArg08)
		eax_11 = dwArg04;
	else
		eax_11 = dwArg08;
	return eax_11;
}

// 0804CCA1: void machine_byte_order()
void machine_byte_order()
{
}

// 0804CCBE: Register word32 fskip(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack int32 dwArg0C, Register out Eq_2006 edxOut)
// Called from:
//      parse_wave_header
//      parse_aiff_header
//      lame_decode_initfile
word32 fskip(struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08, int32 dwArg0C, union Eq_2006 & edxOut)
{
	word32 eax_131;
	word32 eax_12 = gs->dw0014;
	if (fstat64(fileno(dwArg04), fp + ~0x1083) == 0x00 && (dwLoc1074 & 0xF000) == 0x1000)
	{
		if (dwArg0C == 0x01 && dwArg08 >= 0x00)
		{
			for (; dwArg08 > 0x00; dwArg08 -= eax_123)
			{
				Eq_74 eax_123 = fread(fp + ~0x100F, 0x01, min_size_t(0x1000, dwArg08), dwArg04);
				if (eax_123 == 0x00)
				{
					eax_131 = ~0x00;
					goto l0804CE7A;
				}
			}
			eax_131 = 0x00;
		}
		else
			eax_131 = ~0x00;
	}
	else if (fseek(dwArg04, dwArg08, dwArg0C) == 0x00)
		eax_131 = 0x00;
	else if (dwArg0C == 0x01 && dwArg08 >= 0x00)
	{
		for (; dwArg08 > 0x00; dwArg08 -= eax_75)
		{
			Eq_74 eax_75 = fread(fp + ~0x100F, 0x01, min_size_t(0x1000, dwArg08), dwArg04);
			if (eax_75 == 0x00)
			{
				eax_131 = ~0x00;
				goto l0804CE7A;
			}
		}
		eax_131 = 0x00;
	}
	else
	{
		if (g_dw805C54C <= 0x09)
			error_printf("fskip problem: Mostly the return status of functions is not evaluate so it is more secure to polute <stderr>.\n");
		eax_131 = ~0x00;
	}
l0804CE7A:
	Eq_2006 edx_149 = eax_12 ^ gs->dw0014;
	if (edx_149 == 0x00)
	{
		edxOut = edx_149;
		return eax_131;
	}
	else
		__stack_chk_fail();
}

// 0804CE8D: Register Eq_74 init_outfile(Stack Eq_75 dwArg04)
// Called from:
//      init_files
Eq_74 init_outfile(Eq_75 dwArg04)
{
	Eq_74 eax_24;
	Eq_74 dwLoc10_44;
	if (strcmp(dwArg04, 0x08055007) == 0x00)
	{
		dwLoc10_44 = g_t805B3C0;
		lame_set_stream_binary_mode();
	}
	else
	{
		Eq_74 eax_20 = fopen64(dwArg04, "w+b");
		dwLoc10_44 = eax_20;
		if (eax_20 == 0x00)
		{
			eax_24 = 0x00;
			return eax_24;
		}
	}
	eax_24 = dwLoc10_44;
	return eax_24;
}

// 0804CEE8: void init_infile(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_75 dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10)
// Called from:
//      init_files
void init_infile(struct Eq_172 * gs, Eq_74 dwArg04, Eq_75 dwArg08, ptr32 dwArg0C, ptr32 dwArg10)
{
	g_dw805B3CC = 0x00;
	g_dw805B3DC = 0x00;
	g_t805B3D0 = g_t805B2AC;
	g_dw805B3D4 = g_dw805B3E8;
	g_dw805B3D8 = (word32) (g_dw805B2A8 != 0x01);
	OpenSndFile(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
	g_t805B3E0 = dwArg04;
}

// 0804CF50: void close_infile()
// Called from:
//      main
void close_infile()
{
	CloseSndFile(g_t805B3E0);
}

// 0804CF6F: void SwapBytesInWords(Stack (ptr32 Eq_2155) dwArg04, Stack int32 dwArg08)
void SwapBytesInWords(union Eq_2155 * dwArg04, int32 dwArg08)
{
	union Eq_2155 * dwLoc0C_69 = dwArg04;
	for (; dwArg08 > 0x01; dwArg08 -= 0x02)
	{
		uint32 eax_17 = *dwLoc0C_69;
		*dwLoc0C_69 = eax_17 << 0x08 & 0xFF00FF00 | eax_17 >> 0x08 & 0x00FF00FF;
		dwLoc0C_69 = (union Eq_2155 *) ((char *) dwLoc0C_69 + 4);
	}
	union Eq_2155 * dwArg04_75 = dwLoc0C_69;
	for (; dwArg08 > 0x00; --dwArg08)
	{
		Eq_2183 eax_43 = (int32) (word16) (word32) *dwArg04_75;
		*dwArg04_75 = (union Eq_2155 *) (word16) (SEQ(SLICE(eax_43 >> 0x08, word16, 16), (word16) (eax_43 >> 0x08) & 0xFF) | eax_43 << 0x08);
		dwArg04_75 = (union Eq_2155 *) ((char *) dwArg04_75 + 2);
	}
}

// 0804CFF1: Register word32 get_audio(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack (ptr32 Eq_947) dwArg08)
// Called from:
//      lame_encoder
word32 get_audio(struct Eq_172 * gs, Eq_74 dwArg04, struct Eq_947 * dwArg08)
{
	return get_audio_common(gs, dwArg04, dwArg08, null);
}

// 0804D013: Register word32 get_audio16(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack (ptr32 (arr (struct "Eq_475"))) dwArg08)
// Called from:
//      lame_decoder
word32 get_audio16(struct Eq_172 * gs, Eq_74 dwArg04, struct Eq_475 (* dwArg08)[])
{
	return get_audio_common(gs, dwArg04, null, dwArg08);
}

// 0804D035: Register Eq_2222 get_audio_common(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack (ptr32 Eq_947) dwArg08, Stack (ptr32 (arr (struct "Eq_475"))) dwArg0C)
// Called from:
//      get_audio
//      get_audio16
Eq_2222 get_audio_common(struct Eq_172 * gs, Eq_74 dwArg04, struct Eq_947 * dwArg08, struct Eq_475 (* dwArg0C)[])
{
	int32 eax_12;
	lame_get_num_channels();
	Eq_2226 eax_19;
	lame_get_framesize();
	up32 eax_28;
	lame_get_num_samples();
	Eq_2226 dwLoc1C_349 = eax_19;
	if (g_dw805B3CC != 0x00)
	{
		up32 edx_37 = g_dw805B3DC;
		up32 eax_38 = eax_28;
		if (edx_37 <= eax_28)
			eax_38 = edx_37;
		Eq_2226 ecx_47 = eax_28 - eax_38;
		if (eax_19 > ecx_47 && eax_28 != 0x00)
			dwLoc1C_349 = ecx_47;
	}
	Eq_2222 dwLoc14_366;
	Eq_2222 eax_219;
	if (is_mpeg_file_format(g_t805C544) != 0x00)
	{
		if (dwArg08 != null)
			dwLoc14_366 = read_samples_mp3(gs, dwArg04, g_t805B3E0, fp->aFFFFEDD4);
		else
			dwLoc14_366 = read_samples_mp3(gs, dwArg04, g_t805B3E0, dwArg0C);
		if (dwLoc14_366 < 0x00)
		{
			eax_219 = dwLoc14_366;
			return eax_219;
		}
	}
	else
	{
		Eq_2222 eax_80 = read_samples_pcm(g_t805B3E0, (char *) fp - 13868, eax_12 *s dwLoc1C_349);
		if (eax_80 < 0x00)
		{
			eax_219 = eax_80;
			return eax_219;
		}
		Eq_2222 eax_101 = (int32) (SEQ(eax_80 >> 0x1F, eax_80) / eax_12);
		int32 * dwLoc2C_365 = (char *) fp - 13868 + eax_80 * 0x04;
		dwLoc14_366 = eax_101;
		if (dwArg08 != null)
		{
			if (eax_12 == 0x02)
			{
				Eq_2222 dwLoc28_398 = eax_101;
				while (true)
				{
					Eq_2222 v17_199 = dwLoc28_398 - 0x01;
					dwLoc28_398 = v17_199;
					if (v17_199 < 0x00)
						break;
					struct Eq_2380 * v19_206 = dwLoc2C_365 - 0x04;
					dwArg08->a1200[v17_199].u1 = v19_206->dw0000;
					dwArg08[v17_199 * 0x04 / 0x00001200] = (struct Eq_947) v19_206->dwFFFFFFFC;
					dwLoc2C_365 = v19_206 - 0x04;
				}
			}
			else if (eax_12 == 0x01)
			{
				memset(dwArg08->a1200, 0x00, eax_101 * 0x04);
				Eq_2222 dwLoc28_392 = eax_101;
				while (true)
				{
					Eq_2222 v22_183 = dwLoc28_392 - 0x01;
					dwLoc28_392 = v22_183;
					if (v22_183 < 0x00)
						break;
					int32 * v28_188 = dwLoc2C_365 - 0x04;
					dwArg08[v22_183 * 0x04 / 0x00001200] = (struct Eq_947) *v28_188;
					dwLoc2C_365 = v28_188;
				}
			}
		}
		else if (eax_12 == 0x02)
		{
			Eq_2222 dwLoc28_382 = eax_101;
			while (true)
			{
				Eq_2222 v23_141 = dwLoc28_382 - 0x01;
				dwLoc28_382 = v23_141;
				if (v23_141 < 0x00)
					break;
				struct Eq_2429 * v24_148 = dwLoc2C_365 - 0x04;
				(dwArg0C + 0x0900)[v23_141 * 0x02] = SLICE(Mem149[v24_148 + 0x00:word32] >> 0x10, word16, 0);
				dwArg0C[v23_141 * 0x02] = SLICE(Mem157[v24_148 + -4:word32] >> 0x10, word16, 0);
				dwLoc2C_365 = v24_148 - 0x04;
			}
		}
		else if (eax_12 == 0x01)
		{
			memset(dwArg0C + 0x0900, 0x00, eax_101 * 0x02);
			Eq_2222 dwLoc28_376 = eax_101;
			while (true)
			{
				Eq_2222 v27_122 = dwLoc28_376 - 0x01;
				dwLoc28_376 = v27_122;
				if (v27_122 < 0x00)
					break;
				int32 * v29_127 = dwLoc2C_365 - 0x04;
				dwArg0C[v27_122 * 0x02] = SLICE(Mem128[v29_127 + 0x00:word32] >> 0x10, word16, 0);
				dwLoc2C_365 = v29_127;
			}
		}
	}
	if (is_mpeg_file_format(g_t805C544) != 0x00 && dwArg08 != null)
	{
		Eq_2222 dwLoc28_426 = dwLoc14_366;
		while (true)
		{
			Eq_2222 v13_279 = dwLoc28_426 - 0x01;
			dwLoc28_426 = v13_279;
			if (v13_279 < 0x00)
				break;
			dwArg08[v13_279 * 0x04 / 0x00001200] = (struct Eq_947) ((int32) (word16) (word32) fp->aFFFFEDD4[v13_279] << 0x10);
		}
		if (eax_12 == 0x02)
		{
			Eq_2222 dwLoc28_441 = dwLoc14_366;
			while (true)
			{
				Eq_2222 v16_311 = dwLoc28_441 - 0x01;
				dwLoc28_441 = v16_311;
				if (v16_311 < 0x00)
					break;
				dwArg08->a1200[v16_311] = (int32) (word16) (word32) fp->aFFFFEDD4[(word32) v16_311.u0 + 1152] << 0x10;
			}
		}
		else if (eax_12 == 0x01)
			memset(dwArg08->a1200, 0x00, dwLoc14_366 * 0x04);
	}
	if (eax_28 != ~0x00)
		g_dw805B3DC = (word32) dwLoc14_366.u0 + g_dw805B3DC;
	eax_219 = dwLoc14_366;
	return eax_219;
}

// 0804D384: Register int32 read_samples_mp3(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack (ptr32 (arr (struct "Eq_475"))) dwArg0C)
// Called from:
//      get_audio_common
int32 read_samples_mp3(struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08, struct Eq_475 (* dwArg0C)[])
{
	int32 eax_129;
	word32 eax_19 = lame_decode_fromfile(gs, dwArg08, dwArg0C, dwArg0C + 0x0900, 0x0805C560);
	int32 dwLoc10_102 = eax_19;
	if (eax_19 < 0x00)
	{
		memset(dwArg0C, 0x00, 0x1200);
		eax_129 = 0x00;
	}
	else
	{
		word32 eax_30;
		lame_get_num_channels();
		if (eax_30 != g_dw805C564)
		{
			if (g_dw805C54C <= 0x09)
				error_printf("Error: number of channels has changed in %s - not supported\n");
			dwLoc10_102 = ~0x00;
		}
		word32 eax_58;
		lame_get_in_samplerate();
		if (eax_58 != g_dw805C568)
		{
			if (g_dw805C54C <= 0x09)
				error_printf("Error: sample frequency has changed in %s - not supported\n");
			dwLoc10_102 = ~0x00;
		}
		eax_129 = dwLoc10_102;
	}
	return eax_129;
}

// 0804D455: void WriteWaveHeader(Stack Eq_74 dwArg04, Stack Eq_385 dwArg08, Stack Eq_385 dwArg0C, Stack Eq_227 dwArg10, Stack Eq_227 dwArg14)
// Called from:
//      lame_decoder
void WriteWaveHeader(Eq_74 dwArg04, Eq_385 dwArg08, Eq_385 dwArg0C, Eq_227 dwArg10, Eq_227 dwArg14)
{
	int32 eax_10 = (word32) dwArg14.u0 + 7;
	if (dwArg14 < 0x07)
		eax_10 = (word32) dwArg14.u0 + 0x0E;
	fwrite(&g_v805508B, 0x01, 0x04, dwArg04);
	Write32BitsLowHigh(dwArg04, (word32) dwArg08 + 36);
	fwrite(&g_v8055090, 0x02, 0x04, dwArg04);
	Write32BitsLowHigh(dwArg04, 0x10);
	Write16BitsLowHigh(dwArg04, 0x01);
	Write16BitsLowHigh(dwArg04, dwArg10);
	Write32BitsLowHigh(dwArg04, dwArg0C);
	int32 eax_17 = eax_10 >> 0x03;
	Write32BitsLowHigh(dwArg04, dwArg0C *s dwArg10 *s eax_17);
	Write16BitsLowHigh(dwArg04, dwArg10 *s eax_17);
	Write16BitsLowHigh(dwArg04, dwArg14);
	fwrite(&g_v8055099, 0x01, 0x04, dwArg04);
	Write32BitsLowHigh(dwArg04, dwArg08);
	ferror(dwArg04) == 0x00;
}

// 0804D5A8: void unpack_read_samples(Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack word32 dwArg0C, Stack Eq_75 dwArg10, Stack Eq_74 dwArg14)
// Called from:
//      read_samples_pcm
void unpack_read_samples(Eq_74 dwArg04, Eq_74 dwArg08, word32 dwArg0C, Eq_75 dwArg10, Eq_74 dwArg14)
{
	Eq_74 eax_26 = fread(dwArg10, dwArg08, dwArg04, dwArg14);
	ui32 * dwLoc18_509 = (word32) dwArg10 + (eax_26 << 0x02);
	if (dwArg0C == 0x00)
	{
		if (dwArg08 == 0x01)
		{
			int32 dwLoc14_552 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v11_267 = dwLoc14_552 - dwArg08;
				dwLoc14_552 = v11_267;
				if (v11_267 < 0x00)
					break;
				ui32 * v31_271 = dwLoc18_509 - 0x04;
				*v31_271 = (word32) (byte) (word32) *((word32) dwArg10 + v11_267) << 0x18;
				dwLoc18_509 = v31_271;
			}
		}
		if (dwArg08 == 0x02)
		{
			int32 dwLoc14_563 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v14_297 = dwLoc14_563 - dwArg08;
				dwLoc14_563 = v14_297;
				if (v14_297 < 0x00)
					break;
				ui32 * v30_301 = dwLoc18_509 - 0x04;
				*v30_301 = (word32) (byte) (word32) *((word32) dwArg10 + v14_297) << 0x10 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v14_297 + 0x01))))) << 0x18;
				dwLoc18_509 = v30_301;
			}
		}
		if (dwArg08 == 0x03)
		{
			int32 dwLoc14_574 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v21_344 = dwLoc14_574 - dwArg08;
				dwLoc14_574 = v21_344;
				if (v21_344 < 0x00)
					break;
				ui32 * v28_348 = dwLoc18_509 - 0x04;
				*v28_348 = (word32) (byte) (word32) *((word32) dwArg10 + v21_344) << 0x08 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v21_344 + 0x01))))) << 0x10 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v21_344 + 0x02))))) << 0x18;
				dwLoc18_509 = v28_348;
			}
		}
		if (dwArg08 == 0x04)
		{
			int32 dwLoc14_585 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v23_405 = dwLoc14_585 - dwArg08;
				dwLoc14_585 = v23_405;
				if (v23_405 < 0x00)
					break;
				ui32 * v26_409 = dwLoc18_509 - 0x04;
				*v26_409 = (word32) (byte) (word32) *((word32) dwArg10 + v23_405) << 0x00 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v23_405 + 0x01))))) << 0x08 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v23_405 + 0x02))))) << 0x10 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v23_405 + 0x03))))) << 0x18;
				dwLoc18_509 = v26_409;
			}
		}
	}
	else
	{
		if (dwArg08 == 0x01)
		{
			int32 dwLoc14_511 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v13_43 = dwLoc14_511 - dwArg08;
				dwLoc14_511 = v13_43;
				if (v13_43 < 0x00)
					break;
				ui32 * v15_47 = dwLoc18_509 - 0x04;
				*v15_47 = (word32) (byte) ((word32) *((word32) dwArg10 + v13_43) ^ ~0x7F) << 0x18 | 0x007F0000;
				dwLoc18_509 = v15_47;
			}
		}
		if (dwArg08 == 0x02)
		{
			int32 dwLoc14_522 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v20_86 = dwLoc14_522 - dwArg08;
				dwLoc14_522 = v20_86;
				if (v20_86 < 0x00)
					break;
				ui32 * v29_90 = dwLoc18_509 - 0x04;
				*v29_90 = (word32) (byte) (word32) *((word32) dwArg10 + v20_86) << 0x18 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v20_86 + 0x01))))) << 0x10;
				dwLoc18_509 = v29_90;
			}
		}
		if (dwArg08 == 0x03)
		{
			int32 dwLoc14_533 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v22_133 = dwLoc14_533 - dwArg08;
				dwLoc14_533 = v22_133;
				if (v22_133 < 0x00)
					break;
				ui32 * v25_137 = dwLoc18_509 - 0x04;
				*v25_137 = (word32) (byte) (word32) *((word32) dwArg10 + v22_133) << 0x18 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v22_133 + 0x01))))) << 0x10 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v22_133 + 0x02))))) << 0x08;
				dwLoc18_509 = v25_137;
			}
		}
		if (dwArg08 == 0x04)
		{
			int32 dwLoc14_544 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v24_194 = dwLoc14_544 - dwArg08;
				dwLoc14_544 = v24_194;
				if (v24_194 < 0x00)
					break;
				ui32 * v27_198 = dwLoc18_509 - 0x04;
				*v27_198 = (word32) (byte) (word32) *((word32) dwArg10 + v24_194) << 0x18 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v24_194 + 0x01))))) << 0x10 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v24_194 + 0x02))))) << 0x08 | (word32) ((byte) ((word32) (*((word32) dwArg10 + (v24_194 + 0x03))))) << 0x00;
				dwLoc18_509 = v27_198;
			}
		}
	}
}

// 0804D9AB: Register Eq_74 read_samples_pcm(Stack Eq_74 dwArg04, Stack Eq_75 dwArg08, Stack Eq_74 dwArg0C)
// Called from:
//      get_audio_common
Eq_74 read_samples_pcm(Eq_74 dwArg04, Eq_75 dwArg08, Eq_74 dwArg0C)
{
	Eq_222 eax_9 = g_t805B3D0;
	if (eax_9 != 0x10)
	{
		if (eax_9 <= 0x10)
		{
			if (eax_9 != 0x08)
			{
l0804DA8B:
				if (g_dw805C54C <= 0x09)
					error_printf("Only 8, 16, 24 and 32 bit input files supported \n");
				exit(0x01);
			}
			unpack_read_samples(dwArg0C, 0x01, g_dw805B3D8, dwArg08, dwArg04);
l0804DAAD:
			if (ferror(dwArg04) == 0x00)
				return dwArg0C;
			if (g_dw805C54C <= 0x09)
				error_printf("Error reading input file\n");
			exit(0x01);
		}
		if (eax_9 != 0x18 && eax_9 != 0x20)
			goto l0804DA8B;
	}
	if (g_dw805B2A8 == 0x00)
	{
		error_printf("Unsigned input only supported with bitwidth 8\n");
		exit(0x01);
	}
	word32 eax_27 = (word32) (g_dw805B3EC != 0x00);
	word32 dwLoc14_134 = eax_27;
	if (g_dw805B3D4 != 0x00)
		dwLoc14_134 = (word32) (eax_27 == 0x00);
	Eq_222 eax_40 = g_t805B3D0;
	if (eax_40 < 0x00)
		eax_40 = (word32) eax_40.u0 + 7;
	unpack_read_samples(dwArg0C, eax_40 >> 0x03, dwLoc14_134, dwArg08, dwArg04);
	goto l0804DAAD;
}

// 0804DAE3: Register word32 parse_wave_header(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08)
// Called from:
//      parse_file_header
word32 parse_wave_header(struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08)
{
	word32 eax_223;
	Read32BitsHighLow(dwArg08);
	Read32BitsHighLow(dwArg08);
	Eq_222 dwLoc10_328 = 0x00;
	Eq_222 dwLoc14_329 = 0x00;
	Eq_222 dwLoc1C_331 = 0x00;
	Eq_74 dwLoc20_332 = 0x00;
	word32 dwLoc28_334 = 0x00;
	Eq_74 dwLoc2C_335 = 0x00;
	if (dwArg08 != g_t8055144)
		eax_223 = ~0x00;
	else
	{
		int32 dwLoc38_342;
		for (dwLoc38_342 = 0x00; dwLoc38_342 <= 0x13; ++dwLoc38_342)
		{
			Read32BitsHighLow(dwArg08);
			if (dwArg08 == g_t8055148)
			{
				Read32Bits(dwArg08);
				if (dwArg08 <= 0x0F)
				{
					eax_223 = ~0x00;
					return eax_223;
				}
				Eq_222 eax_99 = Read16BitsLowHigh(dwArg08);
				dwLoc14_329 = Read16BitsLowHigh(dwArg08);
				Read32Bits(dwArg08);
				Read32Bits(dwArg08);
				Read16BitsLowHigh(dwArg08);
				dwLoc10_328 = eax_99;
				dwLoc20_332 = dwArg08;
				dwLoc1C_331 = Read16BitsLowHigh(dwArg08);
				Eq_74 dwLoc34_375 = dwArg08 - 0x10;
				if (dwArg08 > 0x19 && (int32) ((word16) ((word32) g_w8055152)) == eax_99)
				{
					Read16BitsLowHigh(dwArg08);
					Read16BitsLowHigh(dwArg08);
					Read32Bits(dwArg08);
					dwLoc10_328 = Read16BitsLowHigh(dwArg08);
					dwLoc34_375 = dwArg08 - 0x1A;
				}
				if (dwLoc34_375 > 0x00)
				{
					word32 edx_495;
					if (fskip(gs, dwArg08, dwLoc34_375, 0x01, out edx_495) != 0x00)
					{
						eax_223 = ~0x00;
						return eax_223;
					}
				}
			}
			else
			{
				if (dwArg08 == g_t805514C)
				{
					Read32Bits(dwArg08);
					dwLoc2C_335 = dwArg08;
					dwLoc28_334 = 0x01;
					break;
				}
				Read32Bits(dwArg08);
				word32 edx_69;
				if (fskip(gs, dwArg08, dwArg08, 0x01, out edx_69) != 0x00)
				{
					eax_223 = ~0x00;
					return eax_223;
				}
			}
		}
		if (dwLoc28_334 != 0x00)
		{
			if ((int32) (word16) (word32) g_w8055150 != dwLoc10_328)
			{
				if (g_dw805C54C <= 0x09)
					error_printf("Unsupported data format: 0x%04X\n");
				eax_223 = 0x00;
			}
			else
			{
				word32 eax_244;
				lame_set_num_channels();
				if (eax_244 == ~0x00)
				{
					if (g_dw805C54C <= 0x09)
						error_printf("Unsupported number of channels: %u\n");
					eax_223 = 0x00;
				}
				else
				{
					lame_set_in_samplerate();
					g_t805B3D0 = dwLoc1C_331;
					g_dw805B3D8 = 0x01;
					int32 eax_260 = (word32) dwLoc1C_331.u0 + 7;
					if (dwLoc1C_331 < 0x07)
						eax_260 = (word32) dwLoc1C_331.u0 + 0x0E;
					int32 edx_271 = (eax_260 >> 0x03) *s dwLoc14_329;
					int64 edx_eax_276 = SEQ(dwLoc2C_335 >> 0x1F, dwLoc2C_335);
					lame_set_num_samples();
					eax_223 = 0x01;
				}
			}
		}
		else
			eax_223 = ~0x00;
	}
	return eax_223;
}

// 0804DDD0: Register word32 aiff_check2(Stack (ptr32 Eq_3142) dwArg04)
// Called from:
//      parse_aiff_header
word32 aiff_check2(struct Eq_3142 * dwArg04)
{
	word32 eax_134;
	if (dwArg04->t0014 != g_t805512C)
	{
		if (g_dw805C54C <= 0x09)
			error_printf("ERROR: input sound data is not PCM\n");
		eax_134 = 0x01;
	}
	else
	{
		Eq_3150 eax_20 = (int32) (word16) (word32) dwArg04->w0008;
		if (eax_20 <= 0x20 && (0x01 << (byte) (eax_20 - 0x08) & 0x01010101) != 0x00)
		{
			if ((word16) (word32) dwArg04->w0000 == 0x01 || (word16) ((word32) dwArg04->w0000) == 0x02)
			{
				if (dwArg04->dw001C != 0x00)
				{
					if (g_dw805C54C <= 0x09)
						error_printf("ERROR: block size of input sound data is not 0 bytes\n");
					eax_134 = 0x01;
				}
				else
					eax_134 = 0x00;
			}
			else
			{
				if (g_dw805C54C <= 0x09)
					error_printf("ERROR: input sound data is not mono or stereo\n");
				eax_134 = 0x01;
			}
		}
		else
		{
			if (g_dw805C54C <= 0x09)
				error_printf("ERROR: input sound data is not 8, 16, 24 or 32 bits\n");
			eax_134 = 0x01;
		}
	}
	return eax_134;
}

// 0804DEB2: Register Eq_74 make_even_number_of_bytes_in_length(Stack size_t dwArg04)
// Called from:
//      parse_aiff_header
Eq_74 make_even_number_of_bytes_in_length(size_t dwArg04)
{
	Eq_74 eax_14;
	if ((byte) (dwArg04 & 0x01) != 0x00)
		eax_14 = (Eq_74) ((word32) dwArg04 + 1);
	else
		eax_14 = dwArg04;
	return eax_14;
}

// 0804DECC: Register word32 parse_aiff_header(Register word32 edx, Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Register out Eq_3235 TopOut)
// Called from:
//      parse_file_header
word32 parse_aiff_header(word32 edx, struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08, union Eq_3235 & TopOut)
{
	Eq_3235 Top_244 = 0;
	word32 eax_168;
	Eq_74 dwLoc1C_453 = g_t8055134;
	memset(fp - 0x50, 0x00, 0x20);
	Read32BitsHighLow(dwArg08);
	Read32BitsHighLow(dwArg08);
	int32 dwLoc20_454 = 0x00;
	int32 dwLoc24_455 = 0x00;
	Eq_74 dwLoc28_456 = ~0x00;
	Eq_74 dwLoc10_462 = dwArg08;
	word32 edx_160 = edx;
	if (dwArg08 != g_t8055120)
	{
		edx_160 = edx;
		if (dwArg08 != g_t8055124)
		{
			eax_168 = ~0x00;
			goto l0804E2E2;
		}
	}
	do
	{
		Eq_3264 edx_24_8_243 = SLICE(edx_160, word24, 8);
		if (dwLoc10_462 <= 0x00)
		{
l0804E172:
			if (dwLoc1C_453 == g_t805513C)
				g_dw805B3D4 = g_dw805B3E8;
			else if (dwLoc1C_453 == g_t8055138)
				g_dw805B3D4 = (word32) (g_dw805B3E8 == 0x00);
			else
			{
				if (dwLoc1C_453 != g_t8055134)
				{
					eax_168 = ~0x00;
					goto l0804E2E2;
				}
				g_dw805B3D4 = (word32) (g_dw805B3E8 == 0x00);
			}
			if (dwLoc20_454 != 0x00 && (dwLoc24_455 > 0x00 || dwLoc4C == 0x00))
			{
				if (aiff_check2(fp - 0x50) != 0x00)
					eax_168 = 0x00;
				else
				{
					word32 eax_352;
					word32 edx_353;
					word32 ecx_354;
					lame_set_num_channels();
					word24 edx_24_8_565 = SLICE(edx_353, word24, 8);
					byte dl_711 = (byte) edx_353;
					if (eax_352 == ~0x00)
					{
						if (g_dw805C54C <= 0x09)
							error_printf("Unsupported number of channels: %u\n");
						eax_168 = 0x00;
					}
					else
					{
						Eq_3423 Top_358 = Top_244 - 1;
						*Top_358 = rLoc44;
						uint16 wLoc5E_577 = __fstcw();
						__fldcw((word16) (word32) wLoc5E_577);
						int32 dwLoc64_579 = (int32) *Top_358;
						__fldcw(wLoc5E_577);
						lame_set_in_samplerate();
						word32 edx_380;
						word32 ecx_381;
						lame_set_num_samples();
						g_t805B3D0.u0 = (int32) (word16) (word32) wLoc48;
						g_dw805B3D8 = 0x00;
						Top_244 = (word32) Top_358 + 1;
						word24 edx_24_8_582 = SLICE(edx_380, word24, 8);
						byte dl_712 = (byte) edx_380;
						if (dwLoc28_456 >= 0x00 && fseek(dwArg08, dwLoc28_456, 0x00) != 0x00)
						{
							if (g_dw805C54C <= 0x09)
								error_printf("Can't rewind stream to audio data position\n");
							eax_168 = 0x00;
						}
						else
							eax_168 = 0x01;
					}
				}
			}
			else
				eax_168 = ~0x00;
			goto l0804E2E2;
		}
		Read32BitsHighLow(dwArg08);
		int32 v8_55 = dwLoc10_462 - 0x04;
		if (dwArg08 == g_t8055128)
		{
			Read32BitsHighLow(dwArg08);
			Eq_74 eax_197 = make_even_number_of_bytes_in_length(dwArg08);
			wLoc50 = (word16) (uint32) (uint16) Read16BitsHighLow(dwArg08);
			Read32BitsHighLow(dwArg08);
			wLoc48 = (word16) (uint32) (uint16) Read16BitsHighLow(dwArg08);
			real64 * Top_248 = ReadIeeeExtendedHighLow(edx_24_8_243, gs, dwArg08, *Top_244, *((word32) Top_244 + 1));
			dwLoc20_454 = dwLoc24_455 + 0x01;
			dwLoc10_462 = v8_55 - eax_197;
			dwLoc4C = dwArg08;
			rLoc44 = *Top_248;
			Top_244 = (char *) Top_248 + 1;
			Eq_74 dwLoc2C_521 = eax_197 - 0x12;
			if (dwArg08 == g_t8055124)
			{
				Read32BitsHighLow(dwArg08);
				dwLoc1C_453 = dwArg08;
				dwLoc2C_521 = eax_197 - 22;
			}
			if (fskip(gs, dwArg08, dwLoc2C_521, 0x01, out edx_160) == 0x00)
				continue;
			eax_168 = ~0x00;
			goto l0804E2E2;
		}
		if (dwArg08 == g_t805512C)
		{
			Read32BitsHighLow(dwArg08);
			Eq_74 eax_108 = make_even_number_of_bytes_in_length(dwArg08);
			Read32BitsHighLow(dwArg08);
			Read32BitsHighLow(dwArg08);
			dwLoc24_455 = 0x01;
			dwLoc10_462 = v8_55 - eax_108;
			if (dwLoc20_454 <= 0x00)
			{
				Eq_74 eax_143 = ftell(dwArg08);
				dwLoc28_456 = eax_143;
				if (eax_143 >= 0x00)
					dwLoc28_456 = dwArg08 + eax_143;
				if (fskip(gs, dwArg08, eax_108 - 0x08, 0x01, out edx_160) == 0x00)
					continue;
				eax_168 = ~0x00;
				goto l0804E2E2;
			}
			word32 edx_718;
			if (fskip(gs, dwArg08, dwArg08, 0x01, out edx_718) != 0x00)
			{
				eax_168 = ~0x00;
				goto l0804E2E2;
			}
			goto l0804E172;
		}
		Read32BitsHighLow(dwArg08);
		Eq_74 eax_72 = make_even_number_of_bytes_in_length(dwArg08);
		dwLoc10_462 = v8_55 - eax_72;
	} while (fskip(gs, dwArg08, eax_72, 0x01, out edx_160) == 0x00);
	eax_168 = ~0x00;
l0804E2E2:
	TopOut = Top_244;
	return eax_168;
}

// 0804E2E4: Register word32 parse_file_header(Register word32 edx, Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Register out Eq_3521 TopOut)
// Called from:
//      OpenSndFile
word32 parse_file_header(word32 edx, struct Eq_172 * gs, Eq_74 dwArg04, Eq_74 dwArg08, union Eq_3521 & TopOut)
{
	Eq_3521 Top_150 = 0;
	word32 eax_128;
	Read32BitsHighLow(dwArg08);
	g_dw805B3CC = 0x00;
	g_dw805B3D8 = (word32) (g_dw805B2A8 != 0x01);
	if (dwArg08 == g_t8055140)
	{
		int32 eax_73 = parse_wave_header(gs, dwArg04, dwArg08);
		if (eax_73 > 0x00)
		{
			g_dw805B3CC = 0x01;
			eax_128 = 0x02;
			goto l0804E3DF;
		}
		if (eax_73 < 0x00 && g_dw805C54C <= 0x09)
			error_printf("Warning: corrupt or unsupported WAVE format\n");
	}
	else if (dwArg08 == g_t805511C)
	{
		int32 eax_45 = parse_aiff_header(edx, gs, dwArg04, dwArg08, out Top_150);
		if (eax_45 > 0x00)
		{
			g_dw805B3CC = 0x01;
			eax_128 = 0x03;
			goto l0804E3DF;
		}
		if (eax_45 < 0x00 && g_dw805C54C <= 0x09)
			error_printf("Warning: corrupt or unsupported AIFF format\n");
	}
	else if (g_dw805C54C <= 0x09)
		error_printf("Warning: unsupported audio format\n");
	eax_128 = 0x00;
l0804E3DF:
	TopOut = Top_150;
	return eax_128;
}

// 0804E3E1: void CloseSndFile(Stack Eq_74 dwArg08)
// Called from:
//      close_infile
void CloseSndFile(Eq_74 dwArg08)
{
	if (fclose(dwArg08) == 0x00)
		return;
	if (g_dw805C54C <= 0x09)
		error_printf("Could not close audio input file\n");
	exit(0x02);
}

// 0804E41A: void OpenSndFile(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_75 dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10)
// Called from:
//      init_infile
void OpenSndFile(struct Eq_172 * gs, Eq_74 dwArg04, Eq_75 dwArg08, ptr32 dwArg0C, ptr32 dwArg10)
{
	int8 Top_179 = 0;
	Eq_74 dwLoc10_355;
	word32 edx_14;
	lame_set_num_samples();
	if (strcmp(dwArg08, 0x08055007) == 0x00)
	{
		dwLoc10_355 = g_t805B3A4;
		lame_set_stream_binary_mode();
	}
	else
	{
		Eq_74 eax_27 = fopen64(dwArg08, "rb");
		edx_14 = 0x08055332;
		dwLoc10_355 = eax_27;
		if (eax_27 == 0x00)
		{
			if (g_dw805C54C <= 0x09)
				error_printf("Could not find \"%s\".\n");
			exit(0x01);
		}
	}
	if (is_mpeg_file_format(g_t805C544) != 0x00)
	{
		if (lame_decode_initfile(gs, dwLoc10_355, &g_t805C560, dwArg0C, dwArg10) == ~0x00)
		{
			if (g_dw805C54C <= 0x09)
				error_printf("Error reading headers in mp3 input file %s.\n");
			exit(0x01);
		}
		word32 eax_144;
		lame_set_num_channels();
		if (eax_144 == ~0x00)
		{
			if (g_dw805C54C <= 0x09)
				error_printf("Unsupported number of channels: %ud\n");
			exit(0x01);
		}
		lame_set_in_samplerate();
		lame_set_num_samples();
	}
	else
	{
		if (g_t805C544 == 0x08)
		{
			if (g_dw805C54C <= 0x09)
				error_printf("sorry, vorbis support in LAME is deprecated.\n");
			exit(0x01);
		}
		if (g_t805C544 == 0x01)
		{
			if (g_dw805C54C <= 0x09)
			{
				console_printf("Assuming raw pcm input file");
				if (g_dw805B3E8 != 0x00)
					console_printf(" : Forcing byte-swapping\n");
				else
					console_printf("\n");
			}
			g_dw805B3D4 = g_dw805B3E8;
		}
		else
			g_t805C544 = parse_file_header(edx_14, gs, dwArg04, dwLoc10_355, out Top_179);
	}
	if (g_t805C544 != 0x00)
	{
		word32 eax_181;
		lame_get_num_samples();
		if (eax_181 == ~0x00 && dwLoc10_355 != g_t805B3A4)
		{
			lame_get_file_size(dwArg08);
			Eq_709 edx_eax_467 = <invalid>;
			struct Eq_3743 * Top_200 = Top_179 - 1;
			Top_200->t0000.u0 = (real64) edx_eax_467;
			Eq_3746 rLoc1C_401 = Top_200->t0000;
			Top_200->t0000 = rLoc1C_401;
			Top_200->tFFFFFFFF.u0 = 0.0;
			Eq_3746 v11_208 = Top_200->tFFFFFFFF;
			Top_200->tFFFFFFFF = Top_200->t0000;
			Top_200->t0000 = v11_208;
			Top_200->t0000 = Top_200->t0000;
			if (Top_200->tFFFFFFFF >= Top_200->t0000 != 0x00)
			{
				if (is_mpeg_file_format(g_t805C544) != 0x00)
				{
					if (g_dw805C56C > 0x00)
					{
						Top_200->t0000 = rLoc1C_401;
						Top_200->tFFFFFFFF = g_t80554C0;
						Top_200->t0000 *= Top_200->tFFFFFFFF;
						int32 eax_270 = g_dw805C56C;
						Top_200->tFFFFFFFF.u0 = (real64) eax_270;
						Top_200->rFFFFFFFE = g_r80554C8;
						Top_200->tFFFFFFFF *= Top_200->rFFFFFFFE;
						Top_200->t0000 /= Top_200->tFFFFFFFF;
						Eq_3746 rLoc24_413 = Top_200->t0000;
						word32 eax_284;
						lame_get_in_samplerate();
						Top_200->t0000.u0 = (real64) eax_284;
						Top_200->t0000 *= rLoc24_413;
						uint16 wLoc32_416 = __fstcw();
						__fldcw((word16) (word32) wLoc32_416);
						int64 qwLoc3C_418 = (int64) Top_200->t0000;
						__fldcw(wLoc32_416);
						word32 dwLoc3C_419 = (word32) qwLoc3C_418;
						lame_set_num_samples();
						g_dw805C57C = dwLoc3C_419;
					}
				}
				else
				{
					ui32 eax_232;
					lame_get_num_channels();
					Top_200->t0000.u0 = (real64) (eax_232 * 0x02);
					Top_200->tFFFFFFFF = rLoc1C_401;
					Top_200->t0000 = Top_200->tFFFFFFFF / Top_200->t0000;
					uint16 wLoc32_405 = __fstcw();
					__fldcw((word16) (word32) wLoc32_405);
					int64 qwLoc3C_407 = (int64) Top_200->t0000;
					__fldcw(wLoc32_405);
					lame_set_num_samples();
				}
			}
		}
	}
	else
		exit(0x01);
}

// 0804E748: Register word32 check_aid(Stack (ptr32 void) dwArg04)
// Called from:
//      lame_decode_initfile
word32 check_aid(void * dwArg04)
{
	return (word32) (memcmp(dwArg04, &g_v805540A, 0x04) == 0x00);
}

// 0804E773: Register word32 is_syncword_mp123(Stack (ptr32 Eq_3943) dwArg04)
// Called from:
//      lame_decode_initfile
word32 is_syncword_mp123(struct Eq_3943 * dwArg04)
{
	word32 eax_151;
	if ((byte) (word32) dwArg04->b0000 == ~0x00)
	{
		if (((word32) (byte) (word32) dwArg04->b0001 & 0xE0) == 0xE0)
		{
			if (((word32) (byte) (word32) dwArg04->b0001 & 0x18) != 0x08)
			{
				ui32 eax_39 = (word32) (byte) (word32) dwArg04->b0001;
				if ((eax_39 & 0x06) != 0x04)
				{
					if ((eax_39 & 0x06) != 0x06)
					{
						if ((eax_39 & 0x06) != 0x02)
						{
							eax_151 = 0x00;
							return eax_151;
						}
						if (g_t805C544 != 0x06 && g_t805C544 != 0x07)
						{
							eax_151 = 0x00;
							return eax_151;
						}
						g_t805C544.u0 = 0x06;
					}
					else
					{
						if (g_t805C544 != 0x04 && g_t805C544 != 0x07)
						{
							eax_151 = 0x00;
							return eax_151;
						}
						g_t805C544.u0 = 0x04;
					}
				}
				else
				{
					if (g_t805C544 != 0x05 && g_t805C544 != 0x07)
					{
						eax_151 = 0x00;
						return eax_151;
					}
					g_t805C544.u0 = 0x05;
				}
				if (((word32) (byte) (word32) dwArg04->b0001 & 0x06) == 0x00)
					eax_151 = 0x00;
				else if (((word32) (byte) (word32) dwArg04->b0002 & 0xF0) == 0xF0)
					eax_151 = 0x00;
				else if (((word32) (byte) (word32) dwArg04->b0002 & 0x0C) == 0x0C)
					eax_151 = 0x00;
				else if (((word32) (byte) (word32) dwArg04->b0001 & 0x18) == 0x18 && (((word32) ((byte) ((word32) dwArg04->b0001)) & 0x06) == 0x04 && (byte) ((int32) ((byte) ((word32) ((word32) ((byte) ((word32) dwArg04->b0002) >> 0x04) + 0x080554A5))) >> (byte) ((word32) ((byte) ((word32) dwArg04->b0003) >> 0x06)) & 0x01) != 0x00))
					eax_151 = 0x00;
				else if (((word32) (byte) (word32) dwArg04->b0003 & 0x03) == 0x02)
					eax_151 = 0x00;
				else
					eax_151 = 0x01;
				return eax_151;
			}
			else
			{
				eax_151 = 0x00;
				return eax_151;
			}
		}
		else
		{
			eax_151 = 0x00;
			return eax_151;
		}
	}
	else
	{
		eax_151 = 0x00;
		return eax_151;
	}
}

// 0804E961: Register word32 lame_decode_initfile(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack (ptr32 (arr (struct "Eq_475"))) dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10)
// Called from:
//      OpenSndFile
//      lame_decode_initfile
word32 lame_decode_initfile(struct Eq_172 * gs, Eq_74 dwArg04, struct Eq_475 (* dwArg08)[], ptr32 dwArg0C, ptr32 dwArg10)
{
	word32 eax_18 = gs->dw0014;
	memset(dwArg08, 0x00, 0x28);
	word32 dwLoc84_443 = 0x00;
	if (g_dw805B3E4 != 0x00)
	{
		word32 eax_31 = g_dw805B3E4;
		hip_decode_exit();
	}
	word32 eax_265;
	word32 eax_40;
	hip_decode_init();
	g_dw805B3E4 = eax_40;
	if (fread(fp - 116, 0x01, 0x04, dwArg04) != 0x04)
	{
		eax_265 = ~0x00;
		goto l0804EE55;
	}
	if ((byte) (word32) bLoc74 == 0x49 && ((byte) ((word32) bLoc73) == 0x44 && (byte) ((word32) bLoc72) == 0x33))
	{
		if (g_dw805C54C <= 0x09)
			console_printf("ID3v2 found. Be aware that the ID3 tag is currently lost when transcoding.\n");
		if (fread(fp - 116, 0x01, 0x06, dwArg04) != 0x06)
		{
			eax_265 = ~0x00;
			goto l0804EE55;
		}
		byte al_91 = (byte) ((word32) bLoc72 & 0x7F);
		byte al_95 = (byte) ((word32) bLoc71 & 0x7F);
		byte al_99 = (byte) ((word32) bLoc70 & 0x7F);
		byte al_103 = (byte) ((word32) bLoc6F & 0x7F);
		word32 edx_748;
		fskip(gs, dwArg04, ((((word32) (byte) (word32) al_91 << 0x07) + (word32) ((byte) ((word32) al_95)) << 0x07) + (word32) ((byte) ((word32) al_99)) << 0x07) + (word32) ((byte) ((word32) al_103)), 0x01, out edx_748);
		bLoc72 = al_91;
		bLoc71 = al_95;
		bLoc70 = al_99;
		bLoc6F = al_103;
		if (fread(fp - 116, 0x01, 0x04, dwArg04) != 0x04)
		{
			eax_265 = ~0x00;
			goto l0804EE55;
		}
	}
	if (check_aid(fp - 116) != 0x00)
	{
		if (fread(fp - 116, 0x01, 0x02, dwArg04) != 0x02)
		{
			eax_265 = ~0x00;
			goto l0804EE55;
		}
		word32 eax_179 = (word32) (byte) (word32) bLoc74 + ((word32) ((byte) ((word32) bLoc73)) << 0x08);
		if (g_dw805C54C <= 0x09)
			console_printf("Album ID found.  length=%i \n");
		word32 edx_749;
		fskip(gs, dwArg04, eax_179 - 0x06, 0x01, out edx_749);
		if (fread(fp - 116, 0x01, 0x04, dwArg04) != 0x04)
		{
			eax_265 = ~0x00;
			goto l0804EE55;
		}
	}
	do
	{
		if (is_syncword_mp123(fp - 116) != 0x00)
		{
			if (((word32) (byte) (word32) bLoc72 & 0xF0) == 0x00)
			{
				if (g_dw805C54C <= 0x09)
					console_printf("Input file is freeformat.\n");
				dwLoc84_443 = 0x01;
			}
			word32 eax_285 = g_dw805B3E4;
			word32 eax_317;
			hip_decode1_headersB();
			if (eax_317 == ~0x00)
				eax_265 = ~0x00;
			else
			{
				do
				{
					if (Mem325[dwArg08 + 0x00:word32] != 0x00)
					{
						if (Mem325[dwArg08 + 0x0C:word32] == 0x00 && dwLoc84_443 == 0x00)
						{
							if (g_dw805C54C <= 0x09)
								error_printf("fail to sync...\n");
							eax_265 = lame_decode_initfile(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
						}
						else
						{
							if (Mem325[dwArg08 + 0x20:word32] <= 0x00)
								Mem383[dwArg08 + 0x1C:word32] = ~0x00;
							eax_265 = 0x00;
						}
						goto l0804EE55;
					}
					Eq_74 eax_338 = fread(fp - (void *) 116, 0x01, 100, dwArg04);
					if (eax_338 != 100)
					{
						eax_265 = ~0x00;
						goto l0804EE55;
					}
					word32 eax_342 = g_dw805B3E4;
					word32 eax_360;
					hip_decode1_headersB();
				} while (eax_360 != ~0x00);
				eax_265 = ~0x00;
			}
			goto l0804EE55;
		}
		Eq_4310 dwLoc88_523 = 0x00;
		while (dwLoc88_523 < 0x03)
		{
			Mem248[fp - 116 + dwLoc88_523:byte] = SLICE((word32) Mem238[fp - 116 + (dwLoc88_523 + 0x01):byte], byte, 0);
			dwLoc88_523 = (word32) dwLoc88_523 + 1;
		}
	} while (fread(fp - (void *) 113, 0x01, 0x01, dwArg04) == 0x01);
	eax_265 = ~0x00;
l0804EE55:
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return eax_265;
	__stack_chk_fail();
}

// 0804EE68: Register int32 lame_decode_fromfile(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack (ptr32 (arr (struct "Eq_475"))) dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      read_samples_mp3
int32 lame_decode_fromfile(struct Eq_172 * gs, Eq_74 dwArg04, struct Eq_475 (* dwArg08)[], word32 dwArg0C, word32 dwArg10)
{
	int32 eax_105;
	word32 eax_18 = gs->dw0014;
	word32 eax_25 = g_dw805B3E4;
	int32 eax_37;
	hip_decode1_headers();
	if (eax_37 != 0x00)
		eax_105 = eax_37;
	else
	{
		do
		{
			int32 dwLoc0414_164;
			Eq_74 eax_52 = fread(fp - 0x0410, 0x01, 0x0400, dwArg04);
			if (eax_52 == 0x00)
			{
				word32 eax_85 = g_dw805B3E4;
				int32 eax_97;
				hip_decode1_headers();
				dwLoc0414_164 = eax_97;
				if (eax_97 > 0x00)
					break;
				word32 eax_106 = g_dw805B3E4;
				hip_decode_exit();
				g_dw805B3E4 = 0x00;
				eax_105 = ~0x00;
				goto l0804F03A;
			}
			word32 eax_56 = g_dw805B3E4;
			int32 eax_70;
			hip_decode1_headers();
			dwLoc0414_164 = eax_70;
			if (eax_70 == ~0x00)
			{
				word32 eax_78 = g_dw805B3E4;
				hip_decode_exit();
				g_dw805B3E4 = 0x00;
				eax_105 = ~0x00;
				goto l0804F03A;
			}
		} while (eax_70 <= 0x00);
		eax_105 = dwLoc0414_164;
	}
l0804F03A:
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return eax_105;
	__stack_chk_fail();
}

// 0804F04D: Register word32 is_mpeg_file_format(Stack Eq_236 dwArg04)
// Called from:
//      get_audio_common
//      OpenSndFile
word32 is_mpeg_file_format(Eq_236 dwArg04)
{
	word32 eax_11;
	if (dwArg04 == 0x05)
	{
		eax_11 = 0x02;
		return eax_11;
	}
	else
	{
		if (dwArg04 <= 0x05)
		{
			if (dwArg04 == 0x04)
			{
				eax_11 = 0x01;
				return eax_11;
			}
		}
		else
		{
			if (dwArg04 == 0x06)
			{
				eax_11 = 0x03;
				return eax_11;
			}
			if (dwArg04 == 0x07)
			{
				eax_11 = ~0x00;
				return eax_11;
			}
		}
		eax_11 = 0x00;
		return eax_11;
	}
}

// 0804F094: FpuStack real64 GetCPUTime()
// Called from:
//      timestatus
real64 GetCPUTime()
{
	word32 eax_10;
	clock();
	return (real64) eax_10 / g_r80554D0;
}

// 0804F0AF: FpuStack real64 GetRealTime()
// Called from:
//      timestatus
//      encoder_progress
real64 GetRealTime()
{
	gettimeofday(fp - 0x14, null);
	return (real64) dwLoc14 + (real64) dwLoc10 * g_r80554D8;
}

// 0804F0E6: void lame_set_stream_binary_mode()
// Called from:
//      init_outfile
//      OpenSndFile
void lame_set_stream_binary_mode()
{
}

// 0804F0F0: void lame_get_file_size(Stack Eq_75 dwArg04)
// Called from:
//      OpenSndFile
void lame_get_file_size(Eq_75 dwArg04)
{
	stat64(dwArg04, fp - 0x6C) != 0x00;
}

// 0804F120: void set_id3tag(Stack Eq_74 dwArg04, Stack uint32 dwArg08, Stack Eq_75 dwArg0C)
// Called from:
//      id3_tag
void set_id3tag(Eq_74 dwArg04, uint32 dwArg08, Eq_75 dwArg0C)
{
	if (dwArg08 > 121)
		goto l0804F1FD;
	switch (g_a80554E0[(dwArg08 - 0x61) * 0x04])
	{
	case 0x00:
		id3tag_set_artist();
		break;
	case 0x01:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x07:
	case 0x08:
	case 0x09:
	case 0x0A:
	case 0x0C:
	case 0x0E:
	case 0x0F:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x14:
	case 22:
	case 0x17:
l0804F1FD:
		break;
	case 0x02:
		id3tag_set_comment();
		break;
	case 0x06:
		id3tag_set_genre();
		break;
	case 11:
		id3tag_set_album();
		break;
	case 0x0D:
		id3tag_set_track();
		break;
	case 0x13:
		id3tag_set_title();
		break;
	case 0x15:
		id3tag_set_fieldvalue();
		break;
	case 0x18:
		id3tag_set_year();
		break;
	}
}

// 0804F204: void id3_tag(Stack Eq_74 dwArg04, Stack uint32 dwArg08, Stack Eq_75 dwArg10)
// Called from:
//      parse_args
void id3_tag(Eq_74 dwArg04, uint32 dwArg08, Eq_75 dwArg10)
{
	Eq_75 eax_13 = strdup(dwArg10);
	set_id3tag(dwArg04, dwArg08, eax_13);
	free(eax_13);
}

// 0804F24B: void lame_version_print(Stack Eq_74 dwArg04)
// Called from:
//      print_license
//      usage
//      short_help
//      long_help
//      presets_set
void lame_version_print(Eq_74 dwArg04)
{
	Eq_75 eax_10;
	get_lame_os_bitness();
	Eq_75 eax_15;
	get_lame_version();
	Eq_75 eax_20;
	get_lame_url();
	Eq_74 eax_27 = strlen(eax_10);
	Eq_74 eax_31 = strlen(eax_15);
	Eq_74 eax_35 = strlen(eax_20);
	if (eax_27 + eax_31 + eax_35 >u ~0x3F && eax_35 <= ~0x4D)
	{
		if (eax_27 != 0x00)
			fprintf(dwArg04, "LAME %s version %s\n%*s(%s)\n\n", eax_10, eax_15, tLoc3C, 0x50 - eax_35 - 0x02);
		else
			fprintf(dwArg04, "LAME version %s\n%*s(%s)\n\n", eax_15, tLoc40, 0x50 - eax_35 - 0x02);
	}
	else if (eax_27 != 0x00)
		fprintf(dwArg04, "LAME %s version %s (%s)\n\n", eax_10, eax_15, eax_20);
	else
		fprintf(dwArg04, "LAME version %s (%s)\n\n", eax_15, eax_20);
}

// 0804F3AB: void print_license(Stack Eq_74 dwArg04)
// Called from:
//      parse_args
void print_license(Eq_74 dwArg04)
{
	lame_version_print(dwArg04);
	fwrite(&g_v80555B0, 0x01, 0xFF, dwArg04);
	fwrite(&g_v80556B0, 0x01, 0xAF, dwArg04);
	fwrite(&g_v8055760, 0x01, 0x9D, dwArg04);
	fwrite(&g_v8055800, 0x01, 0x01E7, dwArg04);
	fwrite(&g_v80559E8, 0x01, 0x6C, dwArg04);
	fwrite(&g_v8055A58, 0x01, 0x0103, dwArg04);
}

// 0804F49B: void usage(Stack Eq_74 dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      main
//      parse_args
void usage(Eq_74 dwArg04, char * dwArg08)
{
	lame_version_print(dwArg04);
	fprintf(dwArg04, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nTry:\n     \"%s --help\"           for general usage information\n or:\n     \"%s --preset help\"    for information on suggested predefined settings\n or:\n     \"%s --longhelp\"\n  or \"%s -?\"              for a complete options list\n\n", dwArg08, dwArg08, dwArg08, dwArg08, dwArg08);
}

// 0804F4EA: void short_help(Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack (ptr32 char) dwArg0C)
// Called from:
//      parse_args
void short_help(Eq_74 dwArg04, Eq_74 dwArg08, char * dwArg0C)
{
	lame_version_print(dwArg08);
	fprintf(dwArg08, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n", dwArg0C);
	int32 eax_28;
	lame_get_VBR_q();
	fprintf(dwArg08, "OPTIONS:\n    -b bitrate      set the bitrate, default 128 kbps\n    -h              higher quality, but a little slower.  Recommended.\n    -f              fast mode (lower quality)\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n", eax_28);
	fwrite(&g_v8055E80, 0x01, 0x0141, dwArg08);
	fwrite(&g_v8055FC4, 0x01, 0x59, dwArg08);
}

// 0804F588: void wait_for(Stack Eq_74 dwArg04, Stack word32 dwArg08)
// Called from:
//      long_help
void wait_for(Eq_74 dwArg04, word32 dwArg08)
{
	if (dwArg08 != 0x00)
		getchar();
	else
		fputc(0x0A, dwArg04);
	fputc(0x0A, dwArg04);
}

// 0804F5CE: void long_help(Stack Eq_74 dwArg04, Stack Eq_74 dwArg08, Stack (ptr32 char) dwArg0C, Stack word32 dwArg10)
// Called from:
//      parse_args
void long_help(Eq_74 dwArg04, Eq_74 dwArg08, char * dwArg0C, word32 dwArg10)
{
	lame_version_print(dwArg08);
	fprintf(dwArg08, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n", dwArg0C);
	fwrite(&g_v8056020, 0x01, 0x02A3, dwArg08);
	fwrite(&g_v80562C4, 0x01, 0x01A9, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8056470, 0x01, 0x032C, dwArg08);
	fwrite(&g_v80567A0, 0x01, 0x0169, dwArg08);
	fwrite(&g_v805690C, 0x01, 226, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v80569F0, 0x01, 0x018A, dwArg08);
	fwrite(&g_v8056B7C, 0x01, 0x0131, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8056CB0, 0x01, 0xFB, dwArg08);
	int32 eax_111;
	lame_get_VBR_q();
	fprintf(dwArg08, "  VBR options:\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n    -v              the same as -V 4\n    --vbr-old       use old variable bitrate (VBR) routine\n    --vbr-new       use new variable bitrate (VBR) routine (default)\n", eax_111);
	fwrite(&g_v8056EE0, 0x01, 0x0170, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8057051, 0x01, 0x0F, dwArg08);
	fwrite(&g_v8057064, 0x01, 0x01CC, dwArg08);
	fwrite(&g_v8057234, 0x01, 55, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v805726C, 0x01, 0x5A, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v80572C8, 0x01, 0x019A, dwArg08);
	fprintf(dwArg08, "  Filter options:\n  --lowpass <freq>        frequency(kHz), lowpass filter cutoff above freq\n  --lowpass-width <freq>  frequency(kHz) - default 15%% of lowpass freq\n  --highpass <freq>       frequency(kHz), highpass filter cutoff below freq\n  --highpass-width <freq> frequency(kHz) - default 15%% of highpass freq\n");
	fwrite(&g_v80575A0, 0x01, 0x50, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v80575F4, 0x01, 886, dwArg08);
	fwrite(&g_v805796C, 0x01, 0x01DC, dwArg08);
	fwrite(&g_v8057B4C, 0x01, 0x013C, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8057C8C, 0x01, 0x61, dwArg08);
	wait_for(dwArg08, dwArg10);
	display_bitrates(dwArg08);
}

// 0804F991: void display_bitrate(Stack Eq_74 dwArg04, Stack (ptr32 char) dwArg08, Stack int32 dwArg0C, Stack ui32 dwArg10)
// Called from:
//      display_bitrates
void display_bitrate(Eq_74 dwArg04, char * dwArg08, int32 dwArg0C, ui32 dwArg10)
{
	int32 dwLoc14_111 = 0x0E;
	if (dwArg0C == 0x04)
		dwLoc14_111 = 0x08;
	fprintf(dwArg04, "\nMPEG-%-3s layer III sample frequencies (kHz):  %2d  %2d  %g\nbitrates (kbps):", dwArg08, (int32) (32 / dwArg0C), (int32) (48 / dwArg0C), g_r8059820 / (real64) dwArg0C);
	int32 dwLoc10_105;
	for (dwLoc10_105 = 0x01; dwLoc10_105 <= dwLoc14_111; ++dwLoc10_105)
		fprintf(dwArg04, " %2i", g_a805B2E0[((dwArg10 << 0x04) + dwLoc10_105) * 0x04]);
	fputc(0x0A, dwArg04);
}

// 0804FA50: void display_bitrates(Stack Eq_74 dwArg04)
// Called from:
//      main
//      long_help
void display_bitrates(Eq_74 dwArg04)
{
	display_bitrate(dwArg04, "1", 0x01, 0x01);
	display_bitrate(dwArg04, "2", 0x02, 0x00);
	display_bitrate(dwArg04, "2.5", 0x04, 0x00);
	fputc(0x0A, dwArg04);
	fflush(dwArg04);
}

// 0804FAE4: void presets_longinfo_dm(Stack Eq_74 dwArg04)
// Called from:
//      presets_set
void presets_longinfo_dm(Eq_74 dwArg04)
{
	fwrite(&g_v8057D4C, 0x01, 0x39, dwArg04);
	fwrite(&g_v8057D88, 0x01, 0x4B, dwArg04);
	fwrite(&g_v8057DD4, 0x01, 323, dwArg04);
	fwrite(&g_v8057F18, 0x01, 0xFF, dwArg04);
	fwrite(&g_v8058018, 0x01, 0x016A, dwArg04);
	fwrite(&g_v8058184, 0x01, 299, dwArg04);
	fwrite(&g_v80582B0, 0x01, 0x0136, dwArg04);
	fwrite(&g_v80583E8, 0x01, 383, dwArg04);
	fwrite(&g_v8058568, 0x01, 0x41, dwArg04);
	fwrite(&g_v80585AC, 0x01, 0x019C, dwArg04);
	fwrite(&g_v805874C, 0x01, 222, dwArg04);
	fwrite(&g_v805882C, 0x01, 0xF7, dwArg04);
}

// 0804FC9C: Register word32 presets_set(Stack Eq_74 dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack Eq_75 dwArg10, Stack (ptr32 char) dwArg14)
// Called from:
//      parse_args
word32 presets_set(Eq_74 dwArg04, int32 dwArg08, int32 dwArg0C, Eq_75 dwArg10, char * dwArg14)
{
	word32 eax_223;
	word32 dwLoc10_413 = 0x00;
	if (strcmp(dwArg10, 0x08058924) == 0x00 && (dwArg08 <= 0x00 && dwArg0C <= 0x00))
	{
		lame_version_print(g_t805B3C0);
		presets_longinfo_dm(g_t805B3C0);
		eax_223 = ~0x00;
	}
	else
	{
		if (strcmp(dwArg10, 0x08058929) == 0x00)
		{
			dwArg10.u0 = 0x0805892F;
			dwLoc10_413 = 0x01;
		}
		if (strcmp(dwArg10, 0x08058932) == 0x00 || (strcmp(dwArg10, 0x08058938) == 0x00 || (strcmp(dwArg10, 0x0805893B) == 0x00 || strcmp(dwArg10, 0x08058941) == 0x00)))
		{
			dwArg10.u0 = 0x08058944;
			dwLoc10_413 = 0x01;
		}
		if (strcmp(dwArg10, 0x08058947) == 0x00)
		{
			dwArg10.u0 = 0x0805894D;
			dwLoc10_413 = 0x01;
		}
		if (strcmp(dwArg10, 0x08058950) == 0x00)
		{
			dwArg10.u0 = 0x08058956;
			dwLoc10_413 = 0x01;
		}
		if (strcmp(dwArg10, 0x08058959) == 0x00)
			dwArg10.u0 = 0x0805895C;
		if (strcmp(dwArg10, 0x08058960) == 0x00 || strcmp(dwArg10, 0x08058966) == 0x00)
			dwArg10.u0 = 0x0805895C;
		if (strcmp(dwArg10, 0x0805896B) == 0x00)
			dwArg10.u0 = 0x08058970;
		if (strcmp(dwArg10, 0x08058974) == 0x00)
			dwArg10.u0 = 0x08058977;
		if (strcmp(dwArg10, 0x0805897B) == 0x00)
			dwArg10.u0 = 0x08058982;
		if (strcmp(dwArg10, 0x08058986) == 0x00)
		{
			lame_set_VBR_q();
			if (dwArg08 > 0x00)
				lame_set_VBR();
			else
				lame_set_VBR();
			eax_223 = 0x00;
		}
		else if (strcmp(dwArg10, 0x0805898D) == 0x00)
		{
			lame_set_VBR_q();
			if (dwArg08 > 0x00)
				lame_set_VBR();
			else
				lame_set_VBR();
			eax_223 = 0x00;
		}
		else if (strcmp(dwArg10, 0x08058996) == 0x00)
		{
			lame_set_VBR_q();
			if (dwArg08 > 0x00)
				lame_set_VBR();
			else
				lame_set_VBR();
			eax_223 = 0x00;
		}
		else if (strcmp(dwArg10, 0x0805899E) == 0x00 && dwArg08 <= 0x00)
		{
			lame_set_preset();
			eax_223 = 0x00;
		}
		else if (atoi(dwArg10) > 0x00 && dwArg08 <= 0x00)
		{
			if (atoi(dwArg10) > 0x07 && atoi(dwArg10) <= 0x0140)
			{
				lame_set_preset();
				if (dwArg0C == 0x01)
					lame_set_VBR();
				if (dwLoc10_413 == 0x01)
					lame_set_mode();
				eax_223 = 0x00;
			}
			else
			{
				lame_version_print(g_t805BCEC);
				error_printf("Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n");
				eax_223 = ~0x00;
			}
		}
		else
		{
			lame_version_print(g_t805BCEC);
			error_printf("Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n");
			error_printf("    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n");
			eax_223 = ~0x00;
		}
	}
	return eax_223;
}

// 080500DE: void genre_list_handler()
void genre_list_handler()
{
	console_printf("%3d %s\n");
}

// 08050100: Register Eq_5204 local_strcasecmp(Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      filename_to_type
//      parse_args
Eq_5204 local_strcasecmp(byte * dwArg04, byte * dwArg08)
{
	do
	{
		int32 eax_15 = (int32) (byte) (word32) *dwArg04;
		word32 eax_19;
		tolower();
		byte al_23 = (byte) eax_19;
		int32 eax_28 = (int32) (byte) (word32) *dwArg08;
		word32 eax_30;
		tolower();
		byte al_34 = (byte) eax_30;
		if (al_23 == 0x00)
			return al_23 - al_34;
		++dwArg04;
		++dwArg08;
	} while ((byte) (word32) al_23 == al_34);
	return al_23 - al_34;
}

// 08050158: Register word32 filename_to_type(Stack Eq_75 dwArg04)
// Called from:
//      parse_args
word32 filename_to_type(Eq_75 dwArg04)
{
	word32 eax_124;
	Eq_74 eax_11 = strlen(dwArg04);
	if (eax_11 <= 0x03)
		eax_124 = 0x00;
	else
	{
		word32 v7_17 = dwArg04 + (eax_11 - 0x04);
		if (local_strcasecmp(v7_17, &g_b8058D58) == 0x00)
			eax_124 = 0x07;
		else if (local_strcasecmp(v7_17, &g_b8058D5D) == 0x00)
			eax_124 = 0x07;
		else if (local_strcasecmp(v7_17, &g_b8058D62) == 0x00)
			eax_124 = 0x07;
		else if (local_strcasecmp(v7_17, &g_b8058D67) == 0x00)
			eax_124 = 0x07;
		else if (local_strcasecmp(v7_17, &g_b8058D6C) == 0x00)
			eax_124 = 0x02;
		else if (local_strcasecmp(v7_17, &g_b8058D71) == 0x00)
			eax_124 = 0x03;
		else if (local_strcasecmp(v7_17, &g_b8058D76) == 0x00)
			eax_124 = 0x01;
		else if (local_strcasecmp(v7_17, &g_b8058D7B) == 0x00)
			eax_124 = 0x08;
		else
			eax_124 = 0x00;
	}
	return eax_124;
}

// 08050285: Register word32 resample_rate(Stack Eq_5305 qwArg04)
// Called from:
//      parse_args
word32 resample_rate(Eq_5305 qwArg04)
{
	Eq_5305 rLoc14_89 = qwArg04;
	if (qwArg04 >= g_t8059828 != 0x00)
		rLoc14_89 = qwArg04 * g_t8059830;
	word32 eax_113;
	uint16 wLoc16_101 = __fstcw();
	__fldcw((word16) (word32) wLoc16_101);
	__fldcw(wLoc16_101);
	Eq_5322 dwLoc1C_103 = (int32) rLoc14_89;
	if (dwLoc1C_103 > 0x30)
		goto l08050327;
	switch (g_a8058DA8[(dwLoc1C_103 - 0x08) * 0x04])
	{
	case 0x00:
		eax_113 = 8000;
		break;
	case 0x01:
	case 0x02:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x09:
	case 0x0A:
	case 11:
	case 0x0C:
	case 0x0D:
	case 0x0F:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 22:
	case 0x17:
	case 0x19:
	case 0x1A:
	case 0x1B:
	case 0x1C:
	case 0x1D:
	case 0x1E:
	case 0x1F:
	case 0x20:
	case 33:
	case 0x22:
	case 0x23:
	case 0x25:
	case 0x26:
	case 0x27:
l08050327:
		error_printf("Illegal resample frequency: %.3f kHz\n");
		eax_113 = 0x00;
		break;
	case 0x03:
		eax_113 = 0x2B11;
		break;
	case 0x04:
		eax_113 = 12000;
		break;
	case 0x08:
		eax_113 = 16000;
		break;
	case 0x0E:
		eax_113 = 22050;
		break;
	case 0x10:
		eax_113 = 24000;
		break;
	case 0x18:
		eax_113 = 0x7D00;
		break;
	case 0x24:
		eax_113 = 44100;
		break;
	case 0x28:
		eax_113 = 48000;
		break;
	}
	return eax_113;
}

// 08050341: Register int32 set_id3_albumart(Stack Eq_74 dwArg04, Stack Eq_75 dwArg08)
// Called from:
//      parse_args
int32 set_id3_albumart(Eq_74 dwArg04, Eq_75 dwArg08)
{
	int32 eax_129;
	if (dwArg08 == 0x00)
		eax_129 = 0x00;
	else
	{
		int32 dwLoc10_163;
		Eq_74 eax_18 = fopen64(dwArg08, "rb");
		if (eax_18 == 0x00)
			dwLoc10_163 = 0x01;
		else
		{
			fseek(eax_18, 0x00, 0x02);
			Eq_74 eax_29 = ftell(eax_18);
			fseek(eax_18, 0x00, 0x00);
			Eq_75 eax_38 = malloc(eax_29);
			if (eax_38 == 0x00)
				dwLoc10_163 = 0x02;
			else
			{
				if (fread(eax_38, 0x01, eax_29, eax_18) != eax_29)
					dwLoc10_163 = 0x03;
				else
				{
					int32 eax_63;
					word32 eax_58;
					word32 edx_162;
					id3tag_set_albumart();
					if (eax_58 != 0x00)
						eax_63 = 0x04;
					else
						eax_63 = 0x00;
					dwLoc10_163 = eax_63;
				}
				free(eax_38);
			}
			fclose(eax_18);
		}
		if (dwLoc10_163 != 0x02)
		{
			if (dwLoc10_163 <= 0x02)
			{
				if (dwLoc10_163 == 0x01)
					error_printf("Could not find: '%s'.\n");
			}
			else if (dwLoc10_163 != 0x03)
			{
				if (dwLoc10_163 == 0x04)
					error_printf("Unsupported image: '%s'.\nSpecify JPEG/PNG/GIF image (128KB maximum)\n");
			}
			else
				error_printf("Read error: '%s'.\n");
		}
		else
			error_printf("Insufficient memory for reading the albumart.\n");
		eax_129 = dwLoc10_163;
	}
	return eax_129;
}

// 080504D7: Register word32 parse_args(Stack Eq_74 dwArg04, Stack int32 dwArg08, Stack (arr (ptr32 char)) dwArg0C, Stack Eq_75 dwArg10, Stack Eq_75 dwArg14, Stack (arr Eq_75) dwArg18, Stack (ptr32 int32) dwArg1C, Register out Eq_153 TopOut)
// Called from:
//      parse_args_from_string
//      main
word32 parse_args(Eq_74 dwArg04, int32 dwArg08, char * dwArg0C[], Eq_75 dwArg10, Eq_75 dwArg14, Eq_75 dwArg18[], int32 * dwArg1C, union Eq_153 & TopOut)
{
	Eq_153 Top_1789 = 0;
	char * eax_15 = dwArg0C[0];
	*dwArg10 = 0x00;
	*dwArg14 = 0x00;
	g_dw805C54C = 0x00;
	g_dw805C588 = 0x00;
	g_dw805C55C = 0x01;
	g_t805C540.u0 = 0x00;
	g_dw805C548 = 0x00;
	g_dw805C554 = 0x00;
	g_dw805C558 = 0x00;
	id3tag_init();
	word32 dwLoc14_3743 = 0x00;
	word32 dwLoc1C_3744 = 0x00;
	word32 dwLoc20_3745 = 0x00;
	word32 dwLoc24_3746 = 0x00;
	int32 dwLoc2C_3749 = 0x00;
	word32 dwLoc30_3750 = 0x00;
	word32 dwLoc34_3751 = 0x00;
	int32 dwLoc18_3756 = 0x00;
	while (true)
	{
		word32 eax_128;
		int32 v6_40 = dwLoc18_3756 + 0x01;
		dwLoc18_3756 = v6_40;
		if (v6_40 >= dwArg08)
			break;
		struct Eq_5479 * eax_48 = dwArg0C[v6_40];
		Eq_75 dwLoc38_3762 = &eax_48->b0001;
		if ((byte) (word32) eax_48->b0000 == 0x2D != 0x00)
		{
			Eq_75 eax_151;
			word32 dwLoc44_3787 = 0x00;
			if (v6_40 + 0x01 < dwArg08)
				eax_151 = dwArg0C[v6_40 + 0x01];
			else
				eax_151.u0 = 0x08055592;
			Eq_75 dwLoc40_3788 = eax_151;
			if ((byte) (word32) eax_48->b0001 == 0x00)
			{
				dwLoc14_3743 = 0x01;
				if ((byte) (word32) *dwArg10 == 0x00)
					strncpy(dwArg10, dwArg0C[v6_40], 0x1001);
				else if ((byte) (word32) *dwArg14 == 0x00)
					strncpy(dwArg14, dwArg0C[v6_40], 0x1001);
			}
			if ((byte) (word32) eax_48->b0001 != 0x2D)
			{
				while (true)
				{
					Eq_75 v17_217 = (word32) dwLoc38_3762 + 1;
					byte al_212 = (byte) (word32) *dwLoc38_3762;
					dwLoc38_3762 = v17_217;
					if (al_212 != 0x00 == 0x00)
						break;
					Eq_75 eax_228;
					if ((byte) (word32) *v17_217 != 0x00)
						eax_228 = v17_217;
					else
						eax_228 = eax_151;
					Eq_5690 eax_233 = (int32) al_212;
					if (eax_233 > 0x78)
						goto l08052562;
					switch (g_a80596E8[(eax_233 - 0x3F) * 0x04])
					{
					case 0x00:
						long_help(dwArg04, g_t805B3C0, eax_15, 0x00);
						eax_128 = ~0x00;
						goto l08052912;
					case 0x01:
					case 0x02:
					case 0x04:
					case 0x05:
					case 0x06:
					case 0x08:
					case 0x09:
					case 0x0A:
					case 11:
					case 0x0C:
					case 0x0D:
					case 0x0E:
					case 0x0F:
					case 0x10:
					case 0x11:
					case 0x12:
					case 0x13:
					case 22:
					case 0x18:
					case 0x1C:
					case 0x1D:
					case 0x1E:
					case 0x1F:
					case 0x20:
					case 33:
					case 0x28:
					case 0x2A:
					case 0x2B:
					case 0x2D:
					case 0x2F:
					case 0x36:
					case 0x38:
l08052562:
						error_printf("%s: unrecognized option -%c\n");
						eax_128 = ~0x00;
						goto l08052912;
					case 0x03:
						lame_set_VBR_max_bitrate_kbps();
						dwLoc44_3787 = 0x01;
						goto l08052588;
					case 0x07:
						lame_set_VBR_hard_min();
						break;
					case 0x14:
						g_dw805C54C = 0x0A;
						break;
					case 0x15:
						lame_set_bWriteVbrTag();
						g_dw805C558 = 0x00;
						dwLoc24_3746 = 0x01;
						break;
					case 0x17:
						word32 eax_578;
						lame_get_VBR();
						dwLoc44_3787 = 0x01;
						if (eax_578 == 0x00)
							lame_set_VBR();
						atof();
						real32 rLocB0_3934 = (real32) *Top_1789;
						Eq_153 Top_604 = (word32) Top_1789 + 1;
						*((word32) Top_604 - 1) = (real64) rLocB0_3934;
						lame_set_VBR_quality();
						Top_1789 = Top_604;
						break;
					case 0x19:
						word32 eax_564;
						__isoc99_sscanf();
						dwLoc44_3787 = 0x01;
						break;
					case 0x1A:
						lame_set_experimentalY();
						break;
					case 0x1B:
						word32 eax_544;
						__isoc99_sscanf();
						dwLoc44_3787 = eax_544;
						break;
					case 0x22:
						lame_set_mode();
						dwLoc1C_3744 = 0x01;
						break;
					case 0x23:
						lame_set_brate();
						word32 eax_518;
						lame_get_brate();
						lame_set_VBR_min_bitrate_kbps();
						dwLoc44_3787 = 0x01;
						break;
					case 0x24:
						lame_set_copyright();
						break;
					case 0x25:
					case 44:
						error_printf("WARNING: -%c is obsolete.\n");
						break;
					case 0x26:
						dwLoc44_3787 = 0x01;
						int32 eax_448 = (int32) (byte) (word32) *eax_228;
						if (eax_448 != 99)
						{
							if (eax_448 != 110)
							{
								if (eax_448 != 0x35)
								{
									error_printf("%s: -e emp must be n/5/c not %s\n");
									eax_128 = ~0x00;
									goto l08052912;
								}
								lame_set_emphasis();
							}
							else
								lame_set_emphasis();
						}
						else
							lame_set_emphasis();
						break;
					case 0x27:
						lame_set_quality();
						break;
					case 0x29:
						lame_set_quality();
						break;
					case 0x2E:
						dwLoc44_3787 = 0x01;
						Eq_5778 eax_366 = (int32) (byte) (word32) *eax_228;
						if (eax_366 > 115)
							goto l08052119;
						switch (g_a80597D0[(eax_366 - 0x61) * 0x04])
						{
						case 0x00:
							lame_set_mode();
							break;
						case 0x01:
						case 0x02:
						case 0x04:
						case 0x06:
						case 0x07:
						case 0x08:
						case 0x0A:
						case 11:
						case 0x0D:
						case 0x0E:
						case 0x0F:
						case 0x10:
						case 0x11:
l08052119:
							error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
							eax_128 = ~0x00;
							goto l08052912;
						case 0x03:
							lame_set_mode();
							break;
						case 0x05:
							lame_set_force_ms();
							goto l080520DA;
						case 0x09:
l080520DA:
							lame_set_mode();
							break;
						case 0x0C:
							lame_set_mode();
							break;
						case 0x12:
							lame_set_mode();
							break;
						}
						break;
					case 0x30:
						lame_set_original();
						break;
					case 0x31:
						lame_set_error_protection();
						break;
					case 0x32:
						Eq_222 eax_324 = atoi(eax_228);
						dwLoc44_3787 = 0x01;
						Eq_222 dwLoc74_3836 = eax_324;
						if (eax_324 < 0x00)
							dwLoc74_3836.u0 = 0x00;
						if (dwLoc74_3836 > 0x09)
							dwLoc74_3836.u0 = 0x09;
						lame_set_quality();
						break;
					case 0x33:
						g_t805C544.u0 = 0x01;
						break;
					case 0x34:
						atof();
						Eq_5305 rLoc8C_3823 = *Top_1789;
						Eq_5807 Top_277 = (word32) Top_1789 + 1;
						*((word32) Top_277 - 1) = rLoc8C_3823;
						*((word32) Top_277 - 2) = g_t8059860;
						*((word32) Top_277 - 1) = *((word32) Top_277 - 1);
						dwLoc44_3787 = 0x01;
						if (*((word32) Top_277 - 2) >= *((word32) Top_277 - 1) != 0x00)
							*((word32) Top_277 - 1) = g_t8059828;
						else
							*((word32) Top_277 - 1) = 1.0;
						*Top_1789 *= rLoc8C_3823;
						Eq_5867 Top_300 = Top_1789 - 1;
						*Top_300 = g_r8059848;
						*((word32) Top_300 + 1) += *Top_300;
						uint16 wLocB2_3825 = __fstcw();
						__fldcw((word16) (word32) wLocB2_3825);
						int32 dwLocB8_3827 = (int32) *((word32) Top_300 + 1);
						__fldcw(wLocB2_3825);
						lame_set_in_samplerate();
						Top_1789 = (word32) Top_300 + 2;
						break;
					case 0x35:
						lame_set_bWriteVbrTag();
						g_dw805C558 = 0x01;
						break;
					case 55:
						word32 eax_245;
						lame_get_VBR();
						if (eax_245 == 0x00)
							lame_set_VBR();
						break;
					case 0x39:
						g_dw805B3E8 = 0x01;
						break;
					}
l08052588:
					if (dwLoc44_3787 != 0x00)
					{
						if (eax_228 == v17_217)
							dwLoc38_3762.u0 = 0x08055592;
						else
							++dwLoc18_3756;
						dwLoc44_3787 = 0x00;
					}
				}
				continue;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058EF1) == 0x00)
			{
				atof();
				lame_set_out_samplerate();
				dwLoc44_3787 = 0x01;
				Top_1789 = (word32) Top_1789 + 1;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058EFA) == 0x00)
			{
				lame_set_VBR();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F02) == 0x00)
			{
				lame_set_VBR();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F0A) == 0x00)
			{
				lame_set_VBR();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F13) == 0x00)
			{
				lame_set_VBR();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F17) == 0x00)
			{
				lame_set_VBR();
				lame_set_VBR_mean_bitrate_kbps();
				int32 eax_3273;
				lame_get_VBR_mean_bitrate_kbps();
				dwLoc44_3787 = 0x01;
				if (eax_3273 > 7999)
				{
					word32 eax_3281;
					lame_get_VBR_mean_bitrate_kbps();
					int32 edx_3289 = SLICE((eax_3281 + 500) *s 274877907, word32, 32);
					int32 ecx_3294 = (edx_3289 >> 0x06) - (eax_3281 + 500 >> 0x1F);
					lame_set_VBR_mean_bitrate_kbps();
				}
				word32 eax_3316;
				int32 eax_3310;
				lame_get_VBR_mean_bitrate_kbps();
				if (eax_3310 <= 0x013F)
					lame_get_VBR_mean_bitrate_kbps();
				else
					eax_3316 = 0x0140;
				word32 eax_3342;
				lame_set_VBR_mean_bitrate_kbps();
				int32 eax_3336;
				lame_get_VBR_mean_bitrate_kbps();
				if (eax_3336 > 0x08)
					lame_get_VBR_mean_bitrate_kbps();
				else
					eax_3342 = 0x08;
				lame_set_VBR_mean_bitrate_kbps();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F1B) == 0x00)
			{
				lame_set_preset();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F21) == 0x00)
			{
				g_t805B2AC = atoi(eax_151);
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F2A) == 0x00)
			{
				g_dw805B2A8 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F31) == 0x00)
			{
				g_dw805B2A8 = 0x00;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F3A) == 0x00)
			{
				g_dw805B3EC = 0x00;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F48) == 0x00)
			{
				g_dw805B3EC = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F53) == 0x00)
			{
				g_t805C544.u0 = 0x04;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F5C) == 0x00)
			{
				g_t805C544.u0 = 0x05;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F65) == 0x00)
			{
				g_t805C544.u0 = 0x06;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F6E) == 0x00)
			{
				error_printf("sorry, vorbis support in LAME is deprecated.\n");
				eax_128 = ~0x00;
				goto l08052912;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058929) == 0x00)
			{
				if (presets_set(dwArg04, 0x00, 0x00, &eax_48->b0001 + 1, eax_15) < 0x00)
				{
					eax_128 = ~0x00;
					goto l08052912;
				}
				error_printf("Warning: --phone is deprecated, use --preset phone instead!");
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058950) == 0x00)
			{
				if (presets_set(dwArg04, 0x00, 0x00, &eax_48->b0001 + 1, eax_15) < 0x00)
				{
					eax_128 = ~0x00;
					goto l08052912;
				}
				error_printf("Warning: --voice is deprecated, use --preset voice instead!");
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059020) == 0x00)
			{
				lame_set_decode_only();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059027) == 0x00)
			{
				g_dw805B3F0 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805902D) == 0x00)
			{
				g_t805C540 = atoi(eax_151);
				g_dw805C548 = 0x01;
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805903D) == 0x00)
			{
				lame_set_disable_reservoir();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059043) == 0x00)
			{
				lame_set_strict_ISO();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059058) == 0x00)
			{
				atof();
				real32 rLocB0_4590 = (real32) *Top_1789;
				Eq_153 Top_3138 = (word32) Top_1789 + 1;
				*((word32) Top_3138 - 1) = (real64) rLocB0_4590;
				lame_set_scale();
				dwLoc44_3787 = 0x01;
				Top_1789 = Top_3138;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805905E) == 0x00)
			{
				atof();
				real32 rLocB0_4585 = (real32) *Top_1789;
				Eq_153 Top_3119 = (word32) Top_1789 + 1;
				*((word32) Top_3119 - 1) = (real64) rLocB0_4585;
				lame_set_scale_left();
				dwLoc44_3787 = 0x01;
				Top_1789 = Top_3119;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059066) == 0x00)
			{
				atof();
				real32 rLocB0_4580 = (real32) *Top_1789;
				Eq_153 Top_3100 = (word32) Top_1789 + 1;
				*((word32) Top_3100 - 1) = (real64) rLocB0_4580;
				lame_set_scale_right();
				dwLoc44_3787 = 0x01;
				Top_1789 = Top_3100;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805906E) == 0x00)
			{
				dwLoc44_3787 = 0x01;
				if (strcmp(eax_151, 0x08059074) == 0x00)
					lame_set_asm_optimizations();
				if (strcmp(eax_151, 0x08059078) == 0x00)
					lame_set_asm_optimizations();
				if (strcmp(eax_151, 0x0805907E) == 0x00)
					lame_set_asm_optimizations();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059082) == 0x00)
			{
				lame_set_free_format();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805908D) == 0x00)
			{
				lame_set_findReplayGain();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805909D) == 0x00)
			{
				lame_set_decode_on_the_fly();
				lame_set_findReplayGain();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590B1) == 0x00)
			{
				lame_set_findReplayGain();
				dwLoc30_3750 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590BE) == 0x00)
			{
				g_dw805C554 = 0x01;
				lame_set_decode_on_the_fly();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590C9) == 0x00)
			{
				g_dw805C55C = 0x00;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D0) == 0x00)
			{
				id3_tag(dwArg04, 116, eax_151);
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D3) == 0x00)
			{
				id3_tag(dwArg04, 0x61, eax_151);
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D6) == 0x00)
			{
				id3_tag(dwArg04, 0x6C, eax_151);
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D9) == 0x00)
			{
				id3_tag(dwArg04, 121, eax_151);
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590DC) == 0x00)
			{
				id3_tag(dwArg04, 99, eax_151);
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590DF) == 0x00)
			{
				id3_tag(dwArg04, 110, eax_151);
				dwLoc44_3787 = 0x01;
				if (dwArg04 != 0x00 && g_dw805C588 == 0x00)
				{
					if (dwLoc34_3751 == 0x01)
					{
						error_printf("The track number has to be between 1 and 255 for ID3v1.\n");
						eax_128 = ~0x00;
						goto l08052912;
					}
					if (dwLoc34_3751 != 0x02 && g_dw805C54C <= 0x09)
						error_printf("The track number has to be between 1 and 255 for ID3v1, ignored for ID3v1.\n");
				}
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805916C) == 0x00)
			{
				id3_tag(dwArg04, 0x67, eax_151);
				dwLoc44_3787 = 0x01;
				if (dwArg04 != 0x00 && g_dw805C588 == 0x00)
				{
					if (dwArg04 == ~0x00)
					{
						error_printf("Unknown ID3v1 genre number: '%s'.\n");
						eax_128 = ~0x00;
						goto l08052912;
					}
					if (dwArg04 != ~0x01)
					{
						error_printf("Internal error.\n");
						eax_128 = ~0x00;
						goto l08052912;
					}
					if (dwLoc34_3751 == 0x01)
					{
						error_printf("Unknown ID3v1 genre: '%s'.\n");
						eax_128 = ~0x00;
						goto l08052912;
					}
					if (dwLoc34_3751 != 0x02 && g_dw805C54C <= 0x09)
						error_printf("Unknown ID3v1 genre: '%s'.  Setting ID3v1 genre to 'Other'\n");
				}
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80591FD) == 0x00)
			{
				id3_tag(dwArg04, 118, eax_151);
				dwLoc44_3787 = 0x01;
				if (dwArg04 != 0x00 && g_dw805C54C <= 0x09)
					error_printf("Invalid field value: '%s'. Ignored\n");
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059224) == 0x00)
			{
				dwLoc44_3787 = 0x01;
				if (set_id3_albumart(dwArg04, eax_151) != 0x00 && g_dw805C588 == 0x00)
				{
					eax_128 = ~0x00;
					goto l08052912;
				}
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059227) == 0x00)
			{
				g_dw805C588 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059239) == 0x00)
			{
				id3tag_add_v2();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059243) == 0x00)
			{
				id3tag_v1_only();
				dwLoc34_3751 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805924E) == 0x00)
			{
				id3tag_v2_only();
				dwLoc34_3751 = 0x02;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059259) == 0x00)
			{
				id3tag_space_v1();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059265) == 0x00)
			{
				id3tag_pad_v2();
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805926F) == 0x00)
			{
				Eq_222 eax_2734 = atoi(eax_151);
				Eq_222 eax_2736 = 0x0001F400;
				if (eax_2734 <= 0x0001F400)
					eax_2736 = eax_2734;
				Eq_222 eax_2743 = 0x00;
				if (eax_2736 >= 0x00)
					eax_2743 = eax_2736;
				id3tag_set_pad();
				dwLoc44_3787 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805927E) == 0x00)
			{
				id3tag_genre_list();
				eax_128 = ~0x01;
				goto l08052912;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059289) == 0x00)
			{
				atof();
				Eq_5305 rLoc8C_4441 = *Top_1789;
				Eq_153 Top_2624 = (word32) Top_1789 + 1;
				*((word32) Top_2624 - 1) = rLoc8C_4441;
				*((word32) Top_2624 - 2) = 0.0;
				*((word32) Top_2624 - 1) = *((word32) Top_2624 - 1);
				dwLoc44_3787 = 0x01;
				Top_1789 = Top_2624;
				if (*((word32) Top_2624 - 2) > *((word32) Top_2624 - 1) != 0x00)
				{
					lame_set_lowpassfreq();
					goto l0805203C;
				}
				*((word32) Top_2624 - 1) = rLoc8C_4441;
				*((word32) Top_2624 - 2) = g_t8059830;
				*((word32) Top_2624 - 1) = *((word32) Top_2624 - 1);
				if (*((word32) Top_2624 - 2) > *((word32) Top_2624 - 1) != 0x00)
				{
l08051431:
					error_printf("Must specify lowpass with --lowpass freq, freq >= 0.001 kHz\n");
					Top_1789 = Top_2624;
					eax_128 = ~0x00;
					goto l08052912;
				}
				*((word32) Top_2624 - 1) = rLoc8C_4441;
				*((word32) Top_2624 - 2) = g_t8059838;
				Eq_5305 v31_2656 = *((word32) Top_2624 - 2);
				*((word32) Top_2624 - 2) = *((word32) Top_2624 - 1);
				*((word32) Top_2624 - 1) = v31_2656;
				*((word32) Top_2624 - 1) = *((word32) Top_2624 - 1);
				if (*((word32) Top_2624 - 2) > *((word32) Top_2624 - 1) != 0x00)
					goto l08051431;
				*((word32) Top_2624 - 1) = rLoc8C_4441;
				*((word32) Top_2624 - 2) = g_t8059840;
				*((word32) Top_2624 - 1) = *((word32) Top_2624 - 1);
				if (*((word32) Top_2624 - 2) > *((word32) Top_2624 - 1) != 0x00)
					*((word32) Top_2624 - 1) = g_t8059828;
				else
					*((word32) Top_2624 - 1) = 1.0;
				*Top_1789 *= rLoc8C_4441;
				Eq_7289 Top_2690 = Top_1789 - 1;
				*Top_2690 = g_r8059848;
				*((word32) Top_2690 + 1) += *Top_2690;
				uint16 wLocB2_4444 = __fstcw();
				__fldcw((word16) (word32) wLocB2_4444);
				int32 dwLocB8_4446 = (int32) *((word32) Top_2690 + 1);
				__fldcw(wLocB2_4444);
				lame_set_lowpassfreq();
				Top_1789 = (word32) Top_2690 + 2;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80592D1) == 0x00)
			{
				atof();
				Eq_5305 rLoc8C_4427 = *Top_1789;
				Eq_153 Top_2536 = (word32) Top_1789 + 1;
				*((word32) Top_2536 - 1) = rLoc8C_4427;
				*((word32) Top_2536 - 2) = g_t8059830;
				*((word32) Top_2536 - 1) = *((word32) Top_2536 - 1);
				dwLoc44_3787 = 0x01;
				if (*((word32) Top_2536 - 2) > *((word32) Top_2536 - 1) != 0x00)
				{
l0805151B:
					error_printf("Must specify lowpass width with --lowpass-width freq, freq >= 0.001 kHz\n");
					Top_1789 = Top_2536;
					eax_128 = ~0x00;
					goto l08052912;
				}
				*((word32) Top_2536 - 1) = rLoc8C_4427;
				*((word32) Top_2536 - 2) = g_t8059838;
				Eq_5305 v28_2555 = *((word32) Top_2536 - 2);
				*((word32) Top_2536 - 2) = *((word32) Top_2536 - 1);
				*((word32) Top_2536 - 1) = v28_2555;
				*((word32) Top_2536 - 1) = *((word32) Top_2536 - 1);
				if (*((word32) Top_2536 - 2) > *((word32) Top_2536 - 1) != 0x00)
					goto l0805151B;
				*((word32) Top_2536 - 1) = rLoc8C_4427;
				*((word32) Top_2536 - 2) = g_t8059850;
				*((word32) Top_2536 - 1) = *((word32) Top_2536 - 1);
				if (*((word32) Top_2536 - 2) > *((word32) Top_2536 - 1) != 0x00)
					*((word32) Top_2536 - 1) = g_t8059828;
				else
					*((word32) Top_2536 - 1) = 1.0;
				*Top_1789 *= rLoc8C_4427;
				Eq_6961 Top_2589 = Top_1789 - 1;
				*Top_2589 = g_r8059848;
				*((word32) Top_2589 + 1) += *Top_2589;
				uint16 wLocB2_4430 = __fstcw();
				__fldcw((word16) (word32) wLocB2_4430);
				int32 dwLocB8_4432 = (int32) *((word32) Top_2589 + 1);
				__fldcw(wLocB2_4430);
				lame_set_lowpasswidth();
				Top_1789 = (word32) Top_2589 + 2;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059329) == 0x00)
			{
				atof();
				Eq_5305 rLoc8C_4411 = *Top_1789;
				Eq_153 Top_2428 = (word32) Top_1789 + 1;
				*((word32) Top_2428 - 1) = rLoc8C_4411;
				*((word32) Top_2428 - 2) = 0.0;
				*((word32) Top_2428 - 1) = *((word32) Top_2428 - 1);
				dwLoc44_3787 = 0x01;
				Top_1789 = Top_2428;
				if (*((word32) Top_2428 - 2) > *((word32) Top_2428 - 1) != 0x00)
				{
					lame_set_highpassfreq();
					goto l0805203C;
				}
				*((word32) Top_2428 - 1) = rLoc8C_4411;
				*((word32) Top_2428 - 2) = g_t8059830;
				*((word32) Top_2428 - 1) = *((word32) Top_2428 - 1);
				if (*((word32) Top_2428 - 2) > *((word32) Top_2428 - 1) != 0x00)
				{
l08051630:
					error_printf("Must specify highpass with --highpass freq, freq >= 0.001 kHz\n");
					Top_1789 = Top_2428;
					eax_128 = ~0x00;
					goto l08052912;
				}
				*((word32) Top_2428 - 1) = rLoc8C_4411;
				*((word32) Top_2428 - 2) = g_t8059838;
				Eq_5305 v29_2460 = *((word32) Top_2428 - 2);
				*((word32) Top_2428 - 2) = *((word32) Top_2428 - 1);
				*((word32) Top_2428 - 1) = v29_2460;
				*((word32) Top_2428 - 1) = *((word32) Top_2428 - 1);
				if (*((word32) Top_2428 - 2) > *((word32) Top_2428 - 1) != 0x00)
					goto l08051630;
				*((word32) Top_2428 - 1) = rLoc8C_4411;
				*((word32) Top_2428 - 2) = g_t8059850;
				*((word32) Top_2428 - 1) = *((word32) Top_2428 - 1);
				if (*((word32) Top_2428 - 2) > *((word32) Top_2428 - 1) != 0x00)
					*((word32) Top_2428 - 1) = g_t8059828;
				else
					*((word32) Top_2428 - 1) = 1.0;
				*Top_1789 *= rLoc8C_4411;
				Eq_7076 Top_2494 = Top_1789 - 1;
				*Top_2494 = g_r8059848;
				*((word32) Top_2494 + 1) += *Top_2494;
				uint16 wLocB2_4414 = __fstcw();
				__fldcw((word16) (word32) wLocB2_4414);
				int32 dwLocB8_4416 = (int32) *((word32) Top_2494 + 1);
				__fldcw(wLocB2_4414);
				lame_set_highpassfreq();
				Top_1789 = (word32) Top_2494 + 2;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059373) != 0x00)
			{
				if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80593CF) == 0x00)
				{
					atof();
					Eq_5305 rLoc8C_4396 = *Top_1789;
					Eq_153 Top_2323 = (word32) Top_1789 + 1;
					*((word32) Top_2323 - 1) = rLoc8C_4396;
					*((word32) Top_2323 - 2) = 1.0;
					*((word32) Top_2323 - 1) = *((word32) Top_2323 - 1);
					dwLoc44_3787 = 0x01;
					Top_1789 = Top_2323;
					if (*((word32) Top_2323 - 2) > *((word32) Top_2323 - 1) != 0x00)
					{
						error_printf("Must specify compression ratio >= 1.0\n");
						eax_128 = ~0x00;
						goto l08052912;
					}
					*((word32) Top_2323 - 1) = rLoc8C_4396;
					real32 rLocB0_4397 = (real32) *((word32) Top_2323 - 1);
					*((word32) Top_2323 - 1) = (real64) rLocB0_4397;
					lame_set_compression_ratio();
					Top_1789 = Top_2323;
				}
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80593FB) == 0x00)
					lame_set_useTemporal();
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059402) == 0x00)
				{
					atof();
					real32 rLocB0_4389 = (real32) *Top_1789;
					Eq_153 Top_2297 = (word32) Top_1789 + 1;
					*((word32) Top_2297 - 1) = (real64) rLocB0_4389;
					lame_set_interChRatio();
					dwLoc44_3787 = 0x01;
					Top_1789 = Top_2297;
				}
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805940A) == 0x00)
				{
					lame_set_useTemporal();
					dwLoc44_3787 = 0x01;
				}
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805941B) != 0x00)
				{
					if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059425) == 0x00)
					{
						word32 eax_2259;
						lame_get_exp_nspsytune();
						lame_set_exp_nspsytune();
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059431) == 0x00)
					{
						atof();
						lame_set_msfix();
						dwLoc44_3787 = 0x01;
						Top_1789 = (word32) Top_1789 + 1;
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059439) == 0x00)
					{
						atof();
						Eq_153 Top_2187 = (word32) Top_1789 + 1;
						*((word32) Top_2187 - 1) = *Top_1789;
						*((word32) Top_2187 - 2) = g_t8059858;
						*((word32) Top_2187 - 1) *= *((word32) Top_2187 - 2);
						uint16 wLocB2_4352 = __fstcw();
						__fldcw((word16) (word32) wLocB2_4352);
						int32 dwLoc54_4354 = (int32) *((word32) Top_2187 - 1);
						__fldcw(wLocB2_4352);
						dwLoc44_3787 = 0x01;
						Top_1789 = Top_2187;
						if (dwLoc54_4354 < ~0x1F)
							dwLoc54_4354 = ~0x1F;
						if (dwLoc54_4354 > 0x1F)
							dwLoc54_4354 = 0x1F;
						if (dwLoc54_4354 < 0x00)
							dwLoc54_4354 += 0x40;
						word32 eax_2226;
						lame_get_exp_nspsytune();
						lame_set_exp_nspsytune();
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059441) == 0x00)
					{
						atof();
						Eq_153 Top_2124 = (word32) Top_1789 + 1;
						*((word32) Top_2124 - 1) = *Top_1789;
						*((word32) Top_2124 - 2) = g_t8059858;
						*((word32) Top_2124 - 1) *= *((word32) Top_2124 - 2);
						uint16 wLocB2_4325 = __fstcw();
						__fldcw((word16) (word32) wLocB2_4325);
						int32 dwLoc58_4327 = (int32) *((word32) Top_2124 - 1);
						__fldcw(wLocB2_4325);
						dwLoc44_3787 = 0x01;
						Top_1789 = Top_2124;
						if (dwLoc58_4327 < ~0x1F)
							dwLoc58_4327 = ~0x1F;
						if (dwLoc58_4327 > 0x1F)
							dwLoc58_4327 = 0x1F;
						if (dwLoc58_4327 < 0x00)
							dwLoc58_4327 += 0x40;
						word32 eax_2163;
						lame_get_exp_nspsytune();
						lame_set_exp_nspsytune();
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059449) == 0x00)
					{
						atof();
						Eq_153 Top_2061 = (word32) Top_1789 + 1;
						*((word32) Top_2061 - 1) = *Top_1789;
						*((word32) Top_2061 - 2) = g_t8059858;
						*((word32) Top_2061 - 1) *= *((word32) Top_2061 - 2);
						uint16 wLocB2_4298 = __fstcw();
						__fldcw((word16) (word32) wLocB2_4298);
						int32 dwLoc5C_4300 = (int32) *((word32) Top_2061 - 1);
						__fldcw(wLocB2_4298);
						dwLoc44_3787 = 0x01;
						Top_1789 = Top_2061;
						if (dwLoc5C_4300 < ~0x1F)
							dwLoc5C_4300 = ~0x1F;
						if (dwLoc5C_4300 > 0x1F)
							dwLoc5C_4300 = 0x1F;
						if (dwLoc5C_4300 < 0x00)
							dwLoc5C_4300 += 0x40;
						word32 eax_2100;
						lame_get_exp_nspsytune();
						lame_set_exp_nspsytune();
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059453) == 0x00)
					{
						atof();
						Eq_153 Top_1998 = (word32) Top_1789 + 1;
						*((word32) Top_1998 - 1) = *Top_1789;
						*((word32) Top_1998 - 2) = g_t8059858;
						*((word32) Top_1998 - 1) *= *((word32) Top_1998 - 2);
						uint16 wLocB2_4271 = __fstcw();
						__fldcw((word16) (word32) wLocB2_4271);
						int32 dwLoc60_4273 = (int32) *((word32) Top_1998 - 1);
						__fldcw(wLocB2_4271);
						dwLoc44_3787 = 0x01;
						Top_1789 = Top_1998;
						if (dwLoc60_4273 < ~0x1F)
							dwLoc60_4273 = ~0x1F;
						if (dwLoc60_4273 > 0x1F)
							dwLoc60_4273 = 0x1F;
						if (dwLoc60_4273 < 0x00)
							dwLoc60_4273 += 0x40;
						word32 eax_2037;
						lame_get_exp_nspsytune();
						lame_set_exp_nspsytune();
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805945C) != 0x00)
					{
						if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059467) != 0x00 && local_strcasecmp(&eax_48->b0001 + 1, &g_b805946D) != 0x00)
						{
							if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059474) == 0x00)
								g_dw805C54C = ~0x04;
							else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805947A) == 0x00)
								g_dw805C54C = ~0x09;
							else
							{
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059482) == 0x00 || local_strcasecmp(&eax_48->b0001 + 1, &g_b805948A) == 0x00)
								{
									print_license(g_t805B3C0);
									eax_128 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058924) == 0x00 || local_strcasecmp(&eax_48->b0001 + 1, &g_b8059492) == 0x00)
								{
									short_help(dwArg04, g_t805B3C0, eax_15);
									eax_128 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059498) == 0x00)
								{
									long_help(dwArg04, g_t805B3C0, eax_15, 0x00);
									eax_128 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594A1) == 0x00)
								{
									Eq_74 eax_1917;
									popen();
									long_help(dwArg04, eax_1917, eax_15, 0x00);
									pclose();
									eax_128 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594AF) != 0x00 && local_strcasecmp(&eax_48->b0001 + 1, &g_b80594B6) != 0x00)
								{
									if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594C6) == 0x00)
									{
										atof();
										Eq_153 Top_1825 = (word32) Top_1789 + 1;
										*((word32) Top_1825 - 1) = (real64) (real32) *Top_1789;
										g_r805C550 = (real32) *((word32) Top_1825 - 1);
										dwLoc44_3787 = 0x01;
										Top_1789 = Top_1825;
									}
									else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594CF) == 0x00)
										dwLoc24_3746 = 0x01;
									else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594D9) == 0x00)
									{
										strcpy(dwArg14, eax_151);
										dwLoc44_3787 = 0x01;
									}
									else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594E2) == 0x00)
										dwLoc20_3745 = 0x01;
									else
									{
										if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594E8) != 0x00)
										{
											error_printf("%s: unrecognized option --%s\n");
											eax_128 = ~0x00;
											goto l08052912;
										}
										atof();
										real32 rLocB0_4183 = (real32) *Top_1789;
										Eq_153 Top_1798 = (word32) Top_1789 + 1;
										*((word32) Top_1798 - 1) = (real64) rLocB0_4183;
										lame_set_athaa_sensitivity();
										dwLoc44_3787 = 0x01;
										Top_1789 = Top_1798;
									}
								}
								else
								{
									dwLoc44_3787 = 0x01;
									int32 dwLoc68_4195 = 0x00;
									int32 dwLoc6C_4196 = 0x00;
									while (strcmp(dwLoc40_3788, 134583489) == 0x00 || strcmp(dwLoc40_3788, 0x08058F13) == 0x00)
									{
										if (strcmp(dwLoc40_3788, 134583489) == 0x00 && dwLoc68_4195 <= 0x00)
											dwLoc68_4195 = 0x01;
										if (strcmp(dwLoc40_3788, 0x08058F13) == 0x00 && dwLoc6C_4196 <= 0x00)
											dwLoc6C_4196 = 0x01;
										Eq_75 eax_1883;
										word32 v36_1876 = dwLoc44_3787 + 0x01;
										dwLoc44_3787 = v36_1876;
										if (v6_40 + v36_1876 < dwArg08)
											eax_1883 = dwArg0C[v6_40 + v36_1876];
										else
											eax_1883.u0 = 0x08055592;
										dwLoc40_3788 = eax_1883;
									}
									if (presets_set(dwArg04, dwLoc68_4195, dwLoc6C_4196, dwLoc40_3788, eax_15) < 0x00)
									{
										eax_128 = ~0x00;
										goto l08052912;
									}
								}
							}
						}
						else
							g_dw805C54C = 0x0A;
					}
				}
				goto l0805203C;
			}
			atof();
			Eq_5305 rLoc8C_4402 = *Top_1789;
			Eq_153 Top_2365 = (word32) Top_1789 + 1;
			*((word32) Top_2365 - 1) = rLoc8C_4402;
			*((word32) Top_2365 - 2) = g_t8059830;
			*((word32) Top_2365 - 1) = *((word32) Top_2365 - 1);
			dwLoc44_3787 = 0x01;
			if (*((word32) Top_2365 - 2) > *((word32) Top_2365 - 1) == 0x00)
			{
				*((word32) Top_2365 - 1) = rLoc8C_4402;
				*((word32) Top_2365 - 2) = g_t8059838;
				Eq_5305 v30_2384 = *((word32) Top_2365 - 2);
				*((word32) Top_2365 - 2) = *((word32) Top_2365 - 1);
				*((word32) Top_2365 - 1) = v30_2384;
				*((word32) Top_2365 - 1) = *((word32) Top_2365 - 1);
				if (*((word32) Top_2365 - 2) > *((word32) Top_2365 - 1) == 0x00)
				{
					*((word32) Top_2365 - 1) = rLoc8C_4402;
					uint16 wLocB2_4404 = __fstcw();
					__fldcw((word16) (word32) wLocB2_4404);
					int32 dwLocB8_4406 = (int32) *((word32) Top_2365 - 1);
					__fldcw(wLocB2_4404);
					lame_set_highpasswidth();
					Top_1789 = Top_2365;
l0805203C:
					dwLoc18_3756 = v6_40 + dwLoc44_3787;
					continue;
				}
			}
			error_printf("Must specify highpass width with --highpass-width freq, freq >= 0.001 kHz\n");
			Top_1789 = Top_2365;
			eax_128 = ~0x00;
			goto l08052912;
		}
		if (dwLoc20_3745 == 0x00)
		{
			if ((byte) (word32) *dwArg10 == 0x00)
			{
				strncpy(dwArg10, dwArg0C[v6_40], 0x1001);
				dwLoc14_3743 = 0x01;
				continue;
			}
			if ((byte) (word32) *dwArg14 != 0x00)
			{
				error_printf("%s: excess arg %s\n");
				eax_128 = ~0x00;
				goto l08052912;
			}
			else
			{
				strncpy(dwArg14, dwArg0C[v6_40], 0x1001);
				continue;
			}
		}
		if (dwArg1C == null || *dwArg1C <= dwLoc2C_3749)
		{
			error_printf("Error: 'nogap option'.  Calling program does not allow nogap option, or\nyou have exceeded maximum number of input files for the nogap option\n");
			*dwArg1C = ~0x00;
			eax_128 = ~0x00;
			goto l08052912;
		}
		strncpy(dwArg18[dwLoc2C_3749], dwArg0C[v6_40], 0x1001);
		++dwLoc2C_3749;
		dwLoc14_3743 = 0x01;
	}
	if (dwLoc14_3743 == 0x00)
	{
		usage(g_t805BCE8, eax_15);
		eax_128 = ~0x00;
		goto l08052912;
	}
	if ((byte) (word32) *dwArg10 == 0x2D)
	{
		int32 eax_3425 = g_dw805C54C;
		if (eax_3425 <= 0x00)
			eax_3425 = 0x01;
		g_dw805C54C = eax_3425;
	}
	if ((byte) (word32) *dwArg14 == 0x00 && dwLoc2C_3749 == 0x00)
	{
		if ((byte) (word32) *dwArg10 == 0x2D)
			memcpy(dwArg14, &g_v8059645, 0x02);
		else
		{
			strncpy(dwArg14, dwArg10, 0x0FFD);
			word32 eax_3460;
			lame_get_decode_only();
			if (eax_3460 != 0x00)
				strcat(dwArg14, ".wav");
			else
				strcat(dwArg14, ".mp3");
		}
	}
	if (dwLoc30_3750 == 0x00)
		lame_set_findReplayGain();
	if (dwLoc20_3745 != 0x00)
	{
		word32 eax_3504;
		lame_get_bWriteVbrTag();
		if (eax_3504 != 0x00 && dwLoc24_3746 == 0x00)
		{
			console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
			lame_set_bWriteVbrTag();
		}
	}
	if ((byte) (word32) *dwArg14 == 0x2D)
		lame_set_bWriteVbrTag();
	if (g_t805C544 == 0x00)
		g_t805C544 = filename_to_type(dwArg10);
	if (g_t805C544 == 0x08)
	{
		error_printf("sorry, vorbis support in LAME is deprecated.\n");
		eax_128 = ~0x00;
		goto l08052912;
	}
	if (dwLoc1C_3744 != 0x00)
		lame_set_num_channels();
	else
	{
		word32 eax_3571;
		lame_get_mode();
		if (eax_3571 == 0x03)
			lame_set_num_channels();
		else
			lame_set_num_channels();
	}
	word32 eax_3604;
	lame_get_free_format();
	if (eax_3604 != 0x00)
	{
		int32 eax_3613;
		lame_get_brate();
		if (eax_3613 <= 0x07)
		{
l080528E0:
			error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
			error_printf("with the -b <bitrate> option\n");
			eax_128 = ~0x00;
			goto l08052912;
		}
		int32 eax_3621;
		lame_get_brate();
		if (eax_3621 > 0x0280)
			goto l080528E0;
	}
	if (dwArg1C != null)
		*dwArg1C = dwLoc2C_3749;
	eax_128 = 0x00;
l08052912:
	TopOut = Top_1789;
	return eax_128;
}

// 08052914: void ReadByte(Stack Eq_74 dwArg04)
void ReadByte(Eq_74 dwArg04)
{
	(_IO_getc(dwArg04) & 0xFF & 0x80) == 0x00;
}

// 08052945: Register ui32 Read16BitsLowHigh(Stack Eq_74 dwArg04)
// Called from:
//      parse_wave_header
//      Read32Bits
ui32 Read16BitsLowHigh(Eq_74 dwArg04)
{
	ui32 eax_21 = ((_IO_getc(dwArg04) & 0xFF) << 0x08) + (_IO_getc(dwArg04) & 0xFF);
	ui32 dwLoc18_43 = eax_21;
	if ((eax_21 & 0x8000) != 0x00)
		dwLoc18_43 = eax_21 - 0x00010000;
	return dwLoc18_43;
}

// 08052995: Register word16 Read16BitsHighLow(Stack Eq_74 dwArg04)
// Called from:
//      parse_aiff_header
//      Read32BitsHighLow
word16 Read16BitsHighLow(Eq_74 dwArg04)
{
	ui32 eax_21 = ((_IO_getc(dwArg04) & 0xFF) << 0x08) + (_IO_getc(dwArg04) & 0xFF);
	ui32 dwLoc18_43 = eax_21;
	if ((eax_21 & 0x8000) != 0x00)
		dwLoc18_43 = eax_21 - 0x00010000;
	return (word16) dwLoc18_43;
}

// 080529E5: void Write8Bits(Stack Eq_74 dwArg04, Stack byte bArg08)
void Write8Bits(Eq_74 dwArg04, byte bArg08)
{
	_IO_putc((word32) (byte) dwArg08, dwArg04);
}

// 08052A02: void Write16BitsLowHigh(Stack Eq_74 dwArg04, Stack Eq_227 dwArg08)
// Called from:
//      lame_decoder
//      WriteWaveHeader
//      Write32Bits
//      Write32BitsLowHigh
void Write16BitsLowHigh(Eq_74 dwArg04, Eq_227 dwArg08)
{
	_IO_putc((word32) (byte) dwArg08, dwArg04);
	_IO_putc((word32) (byte) (dwArg08 >> 0x08), dwArg04);
}

// 08052A37: void Write16BitsHighLow(Stack Eq_74 dwArg04, Stack Eq_8003 dwArg08)
// Called from:
//      Write32BitsHighLow
void Write16BitsHighLow(Eq_74 dwArg04, Eq_8003 dwArg08)
{
	_IO_putc((word32) (byte) (dwArg08 >> 0x08), dwArg04);
	_IO_putc((word32) (byte) dwArg08, dwArg04);
}

// 08052A6C: void Read24BitsHighLow(Stack Eq_74 dwArg04)
void Read24BitsHighLow(Eq_74 dwArg04)
{
	(((_IO_getc(dwArg04) & 0xFF) << 0x10) + ((_IO_getc(dwArg04) & 0xFF) << 0x08) + (_IO_getc(dwArg04) & 0xFF) & 0x00800000) == 0x00;
}

// 08052ADA: void Read32Bits(Stack Eq_74 dwArg04)
// Called from:
//      parse_wave_header
void Read32Bits(Eq_74 dwArg04)
{
	Read16BitsLowHigh(dwArg04);
	Read16BitsLowHigh(dwArg04);
}

// 08052B17: void Read32BitsHighLow(Stack Eq_74 dwArg04)
// Called from:
//      parse_wave_header
//      parse_aiff_header
//      parse_file_header
void Read32BitsHighLow(Eq_74 dwArg04)
{
	Read16BitsHighLow(dwArg04);
	Read16BitsHighLow(dwArg04);
}

// 08052B54: void Write32Bits(Stack Eq_74 dwArg04, Stack uint32 dwArg08)
void Write32Bits(Eq_74 dwArg04, uint32 dwArg08)
{
	Write16BitsLowHigh(dwArg04, dwArg08 & 0xFFFF);
	Write16BitsLowHigh(dwArg04, dwArg08 >> 0x10);
}

// 08052B88: void Write32BitsLowHigh(Stack Eq_74 dwArg04, Stack Eq_385 dwArg08)
// Called from:
//      WriteWaveHeader
void Write32BitsLowHigh(Eq_74 dwArg04, Eq_385 dwArg08)
{
	Write16BitsLowHigh(dwArg04, dwArg08 & 0xFFFF);
	Write16BitsLowHigh(dwArg04, dwArg08 >> 0x10);
}

// 08052BBC: void Write32BitsHighLow(Stack Eq_74 dwArg04, Stack uint32 dwArg08)
void Write32BitsHighLow(Eq_74 dwArg04, uint32 dwArg08)
{
	Write16BitsHighLow(dwArg04, dwArg08 >> 0x10);
	Write16BitsHighLow(dwArg04, dwArg08 & 0xFFFF);
}

// 08052BF0: void ReadBytes(Register Eq_8074 edx, Stack Eq_74 dwArg04, Stack (ptr32 byte) dwArg08, Stack int32 dwArg0C)
// Called from:
//      ReadIeeeExtendedHighLow
void ReadBytes(Eq_8074 edx, Eq_74 dwArg04, byte * dwArg08, int32 dwArg0C)
{
	while (true)
	{
		int32 eax_15 = feof(dwArg04);
		--dwArg0C;
		if ((byte) (SEQ(SLICE(eax_15, word24, 8), dwArg0C > 0x00) & SEQ(edx_24_8, eax_15 == 0x00)) == 0x00)
			break;
		int32 eax_35 = _IO_getc(dwArg04);
		*dwArg08 = (byte) eax_35;
		edx_24_8 = SLICE(eax_35, word24, 8);
		++dwArg08;
	}
}

// 08052C31: void ReadBytesSwapped(Register word32 edx, Stack Eq_74 dwArg04, Stack (ptr32 byte) dwArg08, Stack int32 dwArg0C)
void ReadBytesSwapped(word32 edx, Eq_74 dwArg04, byte * dwArg08, int32 dwArg0C)
{
	byte * ebx_13 = dwArg08;
	while (true)
	{
		int32 eax_19 = feof(dwArg04);
		--dwArg0C;
		if ((byte) (SEQ(SLICE(eax_19, word24, 8), dwArg0C > 0x00) & SEQ(edx_24_8, eax_19 == 0x00)) == 0x00)
			break;
		*ebx_13 = (byte) _IO_getc(dwArg04);
		++ebx_13;
	}
	byte * ebx_45 = ebx_13 - 0x01;
	while (dwArg08 < ebx_45)
	{
		int32 eax_55 = (int32) (byte) (word32) *dwArg08;
		*dwArg08 = (byte) (word32) *ebx_45;
		*ebx_45 = (byte) eax_55;
		++dwArg08;
		--ebx_45;
	}
}

// 08052C9E: void WriteBytes(Stack Eq_74 dwArg04, Stack (ptr32 byte) dwArg08, Stack int32 dwArg0C)
void WriteBytes(Eq_74 dwArg04, byte * dwArg08, int32 dwArg0C)
{
	while (true)
	{
		--dwArg0C;
		if (dwArg0C > 0x00 == 0x00)
			break;
		_IO_putc((int32) (byte) (word32) *dwArg08, dwArg04);
		++dwArg08;
	}
}

// 08052CD3: void WriteBytesSwapped(Stack Eq_74 dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C)
// Called from:
//      lame_decoder
void WriteBytesSwapped(Eq_74 dwArg04, ptr32 dwArg08, int32 dwArg0C)
{
	byte * dwArg08_42 = dwArg08 + (dwArg0C - 0x01);
	while (true)
	{
		--dwArg0C;
		if (dwArg0C > 0x00 == 0x00)
			break;
		_IO_putc((int32) (byte) (word32) *dwArg08_42, dwArg04);
		--dwArg08_42;
	}
}

// 08052D11: Register (ptr8 Eq_3315) ConvertFromIeeeExtended(Stack (ptr32 Eq_8204) dwArg04, FpuStack real64 rArg0, FpuStack Eq_3315 rArg1, FpuStack out Eq_3315 rArg1Out)
// Called from:
//      ReadIeeeExtendedHighLow
union Eq_3315 * ConvertFromIeeeExtended(struct Eq_8204 * dwArg04, real64 rArg0, Eq_3315 rArg1, union Eq_3315 & rArg1Out)
{
	Eq_3315 rLoc24_204;
	int8 Top_145;
	ui32 eax_22 = (int32) (byte) (word32) dwArg04->b0001 & 0xFF | ((int32) ((byte) ((word32) dwArg04->b0000)) & 0x7F) << 0x08;
	ui32 eax_53 = (int32) (byte) (word32) dwArg04->b0005 & 0xFF | (((int32) ((byte) ((word32) dwArg04->b0002)) << 0x18 | ((int32) ((byte) ((word32) dwArg04->b0003)) & 0xFF) << 0x10) | (int32) ((byte) ((word32) dwArg04->b0004)) << 0x08 & 0xFFFF);
	ui32 eax_84 = (int32) (byte) (word32) dwArg04->b0009 & 0xFF | (((int32) ((byte) ((word32) dwArg04->b0006)) << 0x18 | ((int32) ((byte) ((word32) dwArg04->b0007)) & 0xFF) << 0x10) | (int32) ((byte) ((word32) dwArg04->b0008)) << 0x08 & 0xFFFF);
	if (eax_22 == 0x00 && (eax_53 == 0x00 && eax_84 == 0x00))
	{
		rLoc24_204.u0 = 0.0;
		Top_145 = 0;
	}
	else if (eax_22 == 0x7FFF)
	{
		rLoc24_204 = g_t8059868;
		Top_145 = 0;
	}
	else
	{
		ldexp();
		ldexp();
		rArg1 += rArg0;
		rLoc24_204 = rArg1;
		Top_145 = 2;
	}
	union Eq_3315 * Top_163;
	if ((byte) (word32) dwArg04->b0000 < 0x00)
	{
		Top_163 = Top_145 - 1;
		*Top_163 = (union Eq_3315 *) rLoc24_204;
		*Top_163 = (union Eq_3315 *) -*Top_163;
	}
	else
	{
		Top_163 = Top_145 - 1;
		*Top_163 = (union Eq_3315 *) rLoc24_204;
	}
	rArg1Out = rArg1;
	return Top_163;
}

// 08052E8B: Register (ptr8 Eq_8354) ReadIeeeExtendedHighLow(Register Eq_3264 edx, Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, FpuStack real64 rArg0, FpuStack Eq_3315 rArg1)
// Called from:
//      parse_aiff_header
struct Eq_8354 * ReadIeeeExtendedHighLow(Eq_3264 edx, struct Eq_172 * gs, Eq_74 dwArg04, real64 rArg0, Eq_3315 rArg1)
{
	word32 eax_12 = gs->dw0014;
	ReadBytes(edx_24_8, dwArg04, fp - 0x1A, 0x0A);
	word64 rRet1_39;
	struct Eq_8354 * Top_34 = ConvertFromIeeeExtended(fp - 0x1A, rArg0, rArg1, out rRet1_39);
	Top_34->qw0001 = rRet1_39;
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return Top_34;
	Top_34->r0000 = Top_34->r0000;
	__stack_chk_fail();
}

// 08052EDC: void ts_calc_times(Stack (ptr32 Eq_8390) dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14)
// Called from:
//      timestatus
void ts_calc_times(struct Eq_8390 * dwArg04, int32 dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14)
{
	if (dwArg0C > 0x00 && dwArg04->t0008 > 0.0 != 0x00)
	{
		dwArg04->r0010 = dwArg04->t0008 * (real64) dwArg10 / (real64) dwArg0C;
		dwArg04->r0018 = (real64) (dwArg14 *s dwArg0C) / ((real64) dwArg08 * dwArg04->t0008);
	}
	else
	{
		dwArg04->r0010 = 0.0;
		dwArg04->r0018 = 0.0;
	}
}

// 08052F47: void ts_time_decompose(Stack uint32 dwArg04)
// Called from:
//      timestatus
void ts_time_decompose(uint32 dwArg04)
{
	uint32 edx_17 = SLICE(dwArg04 * 2443359173, word32, 32);
	if (edx_17 >> 11 == 0x00)
		console_printf("   %2u:%02u%c");
	else if (edx_17 >> 11 <= 99)
		console_printf("%2lu:%02u:%02u%c");
	else
		console_printf("%6lu h%c");
}

// 0805303F: void timestatus(Stack Eq_74 dwArg04)
// Called from:
//      encoder_progress
//      encoder_progress_end
void timestatus(Eq_74 dwArg04)
{
	int32 eax_12;
	lame_get_out_samplerate();
	int32 eax_18;
	lame_get_frameNum();
	int32 eax_24;
	lame_get_totalframes();
	int32 eax_30;
	lame_get_framesize();
	int32 dwLoc1C_431 = eax_24;
	if (eax_24 < eax_18)
		dwLoc1C_431 = eax_18;
	if (eax_18 == 0x00)
	{
		g_r805B420 = GetRealTime();
		g_r805B440 = GetCPUTime();
		g_r805B428 = 0.0;
		g_r805B448 = 0.0;
	}
	real64 rRet0_77 = GetRealTime();
	Eq_8475 rLoc1_445 = rRet0_77 - g_r805B420;
	Eq_8475 rLoc34_446 = rLoc1_445;
	if (rLoc1_445 < 0.0 != 0x00)
		rLoc34_446.u0 = 0.0;
	g_r805B428 += rLoc34_446;
	g_r805B420 = rRet0_77;
	real64 rRet0_126 = GetCPUTime();
	Eq_8509 rLoc1_461 = rRet0_126 - g_r805B440;
	Eq_8509 rLoc34_462 = rLoc1_461;
	if (rLoc1_461 < 0.0 != 0x00)
		rLoc34_462.u0 = 0.0;
	g_r805B448 += rLoc34_462;
	g_r805B440 = rRet0_126;
	if (eax_18 == 0x00 && g_dw805B460 == 0x00)
	{
		console_printf("\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r");
		g_dw805B460 = 0x01;
	}
	else
	{
		if (eax_18 > 0x00)
			g_dw805B460 = 0x00;
		int32 dwLoc10_506;
		ts_calc_times(&g_r805B420, eax_12, eax_18, dwLoc1C_431, eax_30);
		ts_calc_times(&g_r805B440, eax_12, eax_18, dwLoc1C_431, eax_30);
		if (eax_18 < dwLoc1C_431)
		{
			real64 rLoc1_513 = (real64) eax_18 * g_r8059AE8 / (real64) dwLoc1C_431 + g_r8059AF0;
			uint16 wLoc3E_514 = __fstcw();
			__fldcw((word16) (word32) wLoc3E_514);
			__fldcw(wLoc3E_514);
			dwLoc10_506 = (int32) rLoc1_513;
		}
		else
			dwLoc10_506 = 100;
		char * eax_259;
		console_printf("\r%6i/%-6i");
		if (dwLoc10_506 <= 99)
			eax_259 = (char *) " (%2d%%)|";
		else
			eax_259 = (char *) "(%3.3d%%)|";
		char * eax_370;
		console_printf(eax_259);
		real64 rLoc1_526 = g_r805B448;
		uint16 wLoc3E_527 = __fstcw();
		__fldcw((word16) (word32) wLoc3E_527);
		__fldcw(wLoc3E_527);
		ts_time_decompose((word32) (int64) rLoc1_526);
		real64 rLoc1_534 = g_r805B450;
		uint16 wLoc3E_535 = __fstcw();
		__fldcw((word16) (word32) wLoc3E_535);
		__fldcw(wLoc3E_535);
		ts_time_decompose((word32) (int64) rLoc1_534);
		real64 rLoc1_542 = g_r805B428;
		uint16 wLoc3E_543 = __fstcw();
		__fldcw((word16) (word32) wLoc3E_543);
		__fldcw(wLoc3E_543);
		ts_time_decompose((word32) (int64) rLoc1_542);
		real64 rLoc1_550 = g_r805B430;
		uint16 wLoc3E_551 = __fstcw();
		__fldcw((word16) (word32) wLoc3E_551);
		__fldcw(wLoc3E_551);
		ts_time_decompose((word32) (int64) rLoc1_550);
		if (g_t805B458 <= 1.0 != 0x00)
			eax_370 = (char *) "%9.4fx|";
		else
			eax_370 = (char *) "%#9.5gx|";
		console_printf(eax_370);
		real64 rLoc1_567 = g_r805B430 - g_r805B428;
		uint16 wLoc3E_568 = __fstcw();
		__fldcw((word16) (word32) wLoc3E_568);
		__fldcw(wLoc3E_568);
		ts_time_decompose((word32) (int64) rLoc1_567);
	}
}

// 08053376: void timestatus_finish()
// Called from:
//      encoder_progress_end
void timestatus_finish()
{
	console_printf("\n");
}

// 0805338A: Register int8 encoder_progress_begin(Stack Eq_74 dwArg04, Stack Eq_75 dwArg08, Stack Eq_75 dwArg0C, FpuStack real64 rArg0, FpuStack out Eq_709 rArg0Out)
// Called from:
//      lame_encoder
int8 encoder_progress_begin(Eq_74 dwArg04, Eq_75 dwArg08, Eq_75 dwArg0C, real64 rArg0, union Eq_709 & rArg0Out)
{
	int8 Top_3 = 0;
	if (g_dw805C54C > 0x09)
	{
l080537B6:
		rArg0Out.u0 = <invalid>;
		return Top_3;
	}
	word32 edx_24;
	word32 ecx_25;
	lame_print_config();
	strcmp(dwArg0C, 0x0805996D) == 0x00;
	strlen(dwArg08) + strlen(dwArg0C) >u 0x41;
	strcmp(dwArg08, 0x0805996D) == 0x00;
	console_printf("Encoding %s%s to %s\n");
	lame_get_out_samplerate();
	console_printf("Encoding as %g kHz ");
	up32 eax_108;
	word32 edx_109;
	word32 ecx_110;
	lame_get_VBR();
	if (eax_108 == 0x02)
	{
		lame_get_quality();
		lame_get_VBR_quality();
		int32 eax_131;
		word32 edx_132;
		word32 ecx_133;
		lame_get_out_samplerate();
		word32 eax_148;
		lame_get_version();
		word32 ecx_154 = 0x02 - eax_148;
		lame_get_force_ms();
		word32 ecx_168;
		lame_get_mode();
		word32 edx_183 = console_printf("%s MPEG-%u%s Layer III VBR(q=%g) qval=%i\n");
		goto l080537A1;
	}
	if (eax_108 <= 0x02)
	{
		if (eax_108 != 0x01)
			goto l080536B6;
	}
	else
	{
		if (eax_108 == 0x03)
		{
			lame_get_quality();
			word32 eax_201;
			lame_get_VBR_mean_bitrate_kbps();
			lame_get_compression_ratio();
			real64 rArg0_580 = rArg0 * g_r8059B00 + g_r8059AF0;
			uint16 wLoc1E_581 = __fstcw();
			__fldcw((word16) (word32) wLoc1E_581);
			__fldcw(wLoc1E_581);
			int32 dwLoc24_583 = (int32) rArg0_580;
			int32 eax_239;
			word32 edx_240;
			word32 ecx_241;
			lame_get_out_samplerate();
			word32 eax_256;
			lame_get_version();
			word32 ecx_262 = 0x02 - eax_256;
			lame_get_force_ms();
			word32 ecx_276;
			lame_get_mode();
			word32 edx_293 = console_printf("%s MPEG-%u%s Layer III (%gx) average %d kbps qval=%i\n");
l080537A1:
			Top_3 = 1;
			if (g_dw805C54C < ~0x08)
			{
				word32 edx_500;
				word32 ecx_501;
				lame_print_internals();
			}
			goto l080537B6;
		}
		if (eax_108 != 0x04)
		{
l080536B6:
			lame_get_quality();
			word32 eax_390;
			lame_get_brate();
			lame_get_compression_ratio();
			real64 rArg0_638 = rArg0 * g_r8059B00 + g_r8059AF0;
			uint16 wLoc1E_639 = __fstcw();
			__fldcw((word16) (word32) wLoc1E_639);
			__fldcw(wLoc1E_639);
			int32 dwLoc24_641 = (int32) rArg0_638;
			int32 eax_428;
			word32 edx_429;
			word32 ecx_430;
			lame_get_out_samplerate();
			word32 eax_445;
			lame_get_version();
			word32 ecx_451 = 0x02 - eax_445;
			lame_get_force_ms();
			word32 ecx_465;
			lame_get_mode();
			word32 edx_482 = console_printf("%s MPEG-%u%s Layer III (%gx) %3d kbps qval=%i\n");
			goto l080537A1;
		}
	}
	lame_get_VBR_quality();
	int32 eax_320;
	word32 edx_321;
	word32 ecx_322;
	lame_get_out_samplerate();
	lame_get_version();
	lame_get_force_ms();
	word32 ecx_356;
	lame_get_mode();
	word32 edx_369 = console_printf("%s MPEG-%u%s Layer III VBR(q=%g)\n");
	goto l080537A1;
}

// 080537BE: void encoder_progress(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04)
// Called from:
//      lame_encoder
void encoder_progress(struct Eq_172 * gs, Eq_74 dwArg04)
{
	if (g_dw805C54C > 0x00)
		return;
	int32 eax_17;
	word32 ecx_18;
	word32 edx_19;
	lame_get_frameNum();
	if ((real64) g_r805C550 <= 0.0 != 0x00)
	{
		if (eax_17 - ((SLICE(eax_17 *s 1374389535, word32, 32) >> 0x05) - (eax_17 >> 0x1F)) *s 100 != 0x00)
			return;
	}
	else
	{
		if (eax_17 != 0x00 && eax_17 != 0x09)
		{
			Eq_8933 rLoc1_191 = GetRealTime() - g_r805B408;
			if (rLoc1_191 >= 0.0 != 0x00 && (real64) g_r805C550 > rLoc1_191 != 0x00)
				return;
		}
		g_r805B408 = GetRealTime();
	}
	if (g_dw805C55C != 0x00)
		brhist_jump_back();
	timestatus(dwArg04);
	if (g_dw805C55C != 0x00)
		brhist_disp(gs, dwArg04);
	console_flush();
}

// 080538AF: void encoder_progress_end(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04)
// Called from:
//      lame_encoder
void encoder_progress_end(struct Eq_172 * gs, Eq_74 dwArg04)
{
	if (g_dw805C54C <= 0x00)
	{
		if (g_dw805C55C != 0x00)
			brhist_jump_back();
		timestatus(dwArg04);
		if (g_dw805C55C != 0x00)
			brhist_disp(gs, dwArg04);
		timestatus_finish();
	}
}

// 080538F2: void decoder_progress(Stack (ptr32 Eq_461) dwArg04)
// Called from:
//      lame_decoder
void decoder_progress(struct Eq_461 * dwArg04)
{
	console_printf("\rFrame#%6i/%-6i %3i kbps");
	if (dwArg04->dw0010 == 0x01)
	{
		ui32 eax_37 = dwArg04->dw0014;
		console_printf("  %s  %c");
		g_dw805B400 = eax_37;
	}
	else
	{
		console_printf("         ");
		g_dw805B400 = 0x00;
	}
	console_printf("        \b\b\b\b\b\b\b\b");
}

// 080539F8: void decoder_progress_finish()
// Called from:
//      lame_decoder
void decoder_progress_finish()
{
	console_printf("\n");
}

// 08053A0C: Register int32 calculate_index(Stack (arr word32) dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      brhist_init
int32 calculate_index(word32 dwArg04[], int32 dwArg08, word32 dwArg0C)
{
	int32 dwLoc08_33 = 0x00;
	while (true)
	{
		int32 eax_25;
		if (dwLoc08_33 >= dwArg08)
			break;
		if (dwArg04[dwLoc08_33] == dwArg0C)
		{
			eax_25 = dwLoc08_33;
			return eax_25;
		}
		++dwLoc08_33;
	}
	eax_25 = ~0x00;
	return eax_25;
}

// 08053A43: Register word32 brhist_init(Stack Eq_74 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      brhist_init_package
word32 brhist_init(Eq_74 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word32 eax_112;
	g_dw805B4C0 = 0x00;
	lame_bitrate_kbps();
	g_dw805B480 = calculate_index(g_a805B488, 0x0E, dwArg08);
	g_dw805B484 = calculate_index(g_a805B488, 0x0E, dwArg0C);
	if (g_dw805B480 <= 0x0D && g_dw805B484 <= 0x0D)
	{
		memset(g_a805B4C4, 0x2A, 0x0200);
		memset(g_a805B6C5, 0x25, 0x0200);
		memset(g_a805BAC7, 0x2D, 0x0200);
		memset(g_a805B8C6, 0x2D, 0x0200);
		eax_112 = 0x00;
	}
	else
	{
		error_printf("lame internal error: VBR min %d kbps or VBR max %d kbps not allowed.\n");
		eax_112 = ~0x00;
	}
	return eax_112;
}

// 08053B52: Register word32 digits(Stack Eq_9110 qwArg04)
// Called from:
//      brhist_disp_line
//      progress_line
word32 digits(Eq_9110 qwArg04)
{
	word32 dwLoc08_70 = 0x01;
	if (dwArg04 > 99999999)
	{
		dwLoc08_70 = 0x09;
		dwArg04 = SLICE(dwArg04 * 1441151881, word32, 32) >> 0x19;
	}
	if (dwArg04 > 9999)
	{
		dwLoc08_70 += 0x04;
		dwArg04 = SLICE(dwArg04 * ~0x2E48E8A6, word32, 32) >> 0x0D;
	}
	if (dwArg04 > 99)
	{
		dwLoc08_70 += 0x02;
		dwArg04 = SLICE(dwArg04 * 1374389535, word32, 32) >> 0x05;
	}
	if (dwArg04 > 0x09)
		++dwLoc08_70;
	return dwLoc08_70;
}

// 08053BDA: void brhist_disp_line(Register (ptr32 Eq_172) gs, Stack int32 dwArg10, Stack Eq_9110 dwArg14)
// Called from:
//      brhist_disp
void brhist_disp_line(struct Eq_172 * gs, int32 dwArg10, Eq_9110 dwArg14)
{
	word32 eax_10 = gs->dw0014;
	digits(dwArg14);
	digits(dwArg14);
	sprintf(fp - 0x1E, " [%*i]", 0x00);
	if ((byte) (word32) g_b805BD06 != 0x00)
		console_printf("\n%3d%s %.*s%.*s%s");
	else
		console_printf("\n%3d%s %.*s%.*s%*s");
	++g_dw805B4C0;
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08053D7C: void progress_line(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04, Stack Eq_9110 dwArg08, Stack Eq_9110 dwArg0C)
// Called from:
//      brhist_disp
void progress_line(struct Eq_172 * gs, Eq_74 dwArg04, Eq_9110 dwArg08, Eq_9110 dwArg0C)
{
	word32 eax_12 = gs->dw0014;
	word32 eax_33;
	lame_get_framesize();
	int32 eax_40;
	lame_get_out_samplerate();
	real32 dwLoc38_322 = 0.0F;
	if (dwArg08 < dwArg0C)
		dwArg08 = dwArg0C;
	if (eax_40 > 0x00)
		dwLoc38_322 = (real32) ((real64) (real32) ((real64) eax_33 * (real64) ((real32) ((real64) (dwArg08 - dwArg0C)))) / (real64) eax_40);
	real64 rLoc1_349 = (real64) dwLoc38_322 / (real64) g_r8059C48;
	uint16 wLoc52_350 = __fstcw();
	uint16 ax_94 = (word16) (word32) wLoc52_350;
	__fldcw(ax_94);
	__fldcw(wLoc52_350);
	__fldcw(ax_94);
	__fldcw(wLoc52_350);
	__fldcw(ax_94);
	__fldcw(wLoc52_350);
	Eq_9110 dwLoc5C_353 = (word32) (int64) rLoc1_349;
	if (dwArg08 != 0x00)
	{
		int32 dwLoc34_392;
		if (dwLoc5C_353 != 0x00)
		{
			digits(dwLoc5C_353);
			sprintf(fp - 0x24, "%*d:%02u:%02u", 0x00);
			dwLoc34_392 = digits(dwLoc5C_353) + 0x07;
		}
		else
		{
			sprintf(fp - 0x24, "%02u:%02u", 0x00);
			dwLoc34_392 = 0x06;
		}
		Eq_9275 eax_208 = (g_dw805BCF4 - dwLoc34_392 + 0x01) *s dwArg08;
		Eq_9282 eax_220 = (word32) dwArg08.u0 + (g_dw805BCF4 - dwLoc34_392) *s dwArg0C;
		if ((int32) (SEQ(eax_208 - 0x01 >> 0x1F, eax_208 - 0x01) / dwArg08 - SEQ(eax_220 - 0x01 >> 0x1F, eax_220 - 0x01) / dwArg08) == 0x00)
			sprintf(fp - 0x24, "%.*s", 0x00);
	}
	if ((byte) (word32) g_b805BD06 != 0x00)
		console_printf("\n%.*s%s%.*s%s");
	else
		console_printf("\n%.*s%s%.*s%*s");
	++g_dw805B4C0;
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0805409D: void stats_value(Stack Eq_9337 qwArg04)
// Called from:
//      stats_line
void stats_value(Eq_9337 qwArg04)
{
	if (qwArg04 > 0.0 != 0x00)
		console_printf(" %5.1f");
}

// 080540E2: void stats_head(Stack Eq_9337 qwArg04, Stack (ptr32 char) dwArg0C)
// Called from:
//      stats_line
void stats_head(Eq_9337 qwArg04, char * dwArg0C)
{
	if (qwArg04 > 0.0 != 0x00)
		console_printf(dwArg0C);
}

// 0805411F: void stats_line(Stack (ptr32 Eq_9353) dwArg04)
// Called from:
//      brhist_disp
void stats_line(struct Eq_9353 * dwArg04)
{
	console_printf("\n   kbps     ");
	stats_head(dwArg04->t0008, "  mono");
	stats_head(dwArg04->t0010, "   IS ");
	stats_head(dwArg04->t0018, "   LR ");
	stats_head(dwArg04->t0020, "   MS ");
	console_printf(" %%    ");
	stats_head(dwArg04->t0028, " long ");
	stats_head(dwArg04->t0030, "switch");
	stats_head(dwArg04->t0038, " short");
	stats_head(dwArg04->t0040, " mixed");
	console_printf(" %%");
	if ((byte) (word32) g_b805BD06 != 0x00)
		console_printf("%s");
	else
		console_printf("%*s");
	++g_dw805B4C0;
	console_printf("\n  %5.1f     ");
	stats_value(dwArg04->t0008);
	stats_value(dwArg04->t0010);
	stats_value(dwArg04->t0018);
	stats_value(dwArg04->t0020);
	console_printf("      ");
	stats_value(dwArg04->t0028);
	stats_value(dwArg04->t0030);
	stats_value(dwArg04->t0038);
	stats_value(dwArg04->t0040);
	if ((byte) (word32) g_b805BD06 != 0x00)
		console_printf("%s");
	else
		console_printf("%*s");
	++g_dw805B4C0;
}

// 08054399: void brhist_disp(Register (ptr32 Eq_172) gs, Stack Eq_74 dwArg04)
// Called from:
//      encoder_progress
//      encoder_progress_end
void brhist_disp(struct Eq_172 * gs, Eq_74 dwArg04)
{
	int32 dwLoc14_425 = 0x00;
	word32 * edi_24 = fp - 212;
	word32 ecx_25;
	for (ecx_25 = 0x12; ecx_25 != 0x00; --ecx_25)
	{
		*edi_24 = 0x00;
		++edi_24;
	}
	g_dw805B4C0 = 0x00;
	lame_bitrate_stereo_mode_hist();
	lame_bitrate_hist();
	lame_stereo_mode_hist();
	lame_block_type_hist();
	int32 dwLoc20_428 = 0x00;
	int32 dwLoc1C_442 = 0x00;
	Eq_9110 dwLoc18_443 = 0x00;
	int32 dwLoc10_444;
	for (dwLoc10_444 = 0x00; dwLoc10_444 <= 0x0D; ++dwLoc10_444)
	{
		dwLoc18_443 = (word32) dwLoc18_443.u0 + (fp - 0x8C)[dwLoc10_444];
		if ((fp - 0x8C)[dwLoc10_444] > dwLoc1C_442)
			dwLoc1C_442 = (fp - 0x8C)[dwLoc10_444];
		if ((fp - 0x8C)[dwLoc10_444] != 0x00)
			++dwLoc14_425;
	}
	int32 dwLoc10_462;
	for (dwLoc10_462 = 0x00; dwLoc10_462 <= 0x0D; ++dwLoc10_462)
	{
		word32 eax_127;
		if ((fp - 0x8C)[dwLoc10_462] != 0x00 && dwLoc14_425 > 0x01)
			eax_127 = 0x01;
		else
			eax_127 = 0x00;
		if (eax_127 != 0x00 || g_dw805B480 <= dwLoc10_462 && g_dw805B484 >= dwLoc10_462)
			brhist_disp_line(gs, dwLoc1C_442, dwLoc18_443);
	}
	int32 dwLoc10_485;
	for (dwLoc10_485 = 0x00; dwLoc10_485 <= 0x03; ++dwLoc10_485)
		dwLoc20_428 += (fp - 0x3C)[dwLoc10_485];
	Eq_9110 eax_369;
	lame_get_totalframes();
	progress_line(gs, dwArg04, eax_369, dwLoc18_443);
	stats_line(fp - 212);
}

// 080546F4: void brhist_jump_back()
// Called from:
//      encoder_progress
//      encoder_progress_end
void brhist_jump_back()
{
	console_up(g_dw805B4C0);
	g_dw805B4C0 = 0x00;
}

// 08054720: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 08054730: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	_init();
	int32 edi_29 = 0x0805B0EC - 0x0805B0EC;
	if (edi_29 >> 0x02 != 0x00)
	{
		Eq_9643 esi_34 = 0x00;
		do
		{
			(*((char *) g_a805B0EC + esi_34 * 0x04))();
			esi_34 = (word32) esi_34.u1 + 1;
		} while (esi_34 < edi_29 >> 0x02);
	}
}

// 0805478A: void __i686.get_pc_thunk.bx()
void __i686.get_pc_thunk.bx()
{
}

// 08054790: Register word32 stat64(Stack Eq_75 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      lame_get_file_size
word32 stat64(Eq_75 dwArg04, ptr32 dwArg08)
{
	word32 eax_20;
	__xstat64();
	return eax_20;
}

// 080547D0: Register word32 fstat64(Stack int32 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      fskip
word32 fstat64(int32 dwArg04, ptr32 dwArg08)
{
	word32 eax_20;
	__fxstat64();
	return eax_20;
}

// 08054810: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * eax_12 = g_ptr805AEFC;
	if (eax_12 != (<anonymous> *) ~0x00)
	{
		word32 * ebx_15 = &g_ptr805AEFC;
		do
		{
			eax_12();
			ebx_15 -= 0x04;
			eax_12 = *ebx_15;
		} while (eax_12 != (<anonymous> *) ~0x00);
	}
}

