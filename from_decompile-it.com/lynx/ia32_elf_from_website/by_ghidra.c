typedef unsigned char   undefined;

typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef struct termios termios, *Ptermios;

typedef uint tcflag_t;

typedef uchar cc_t;

typedef uint speed_t;

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[15];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct stat64 stat64, *Pstat64;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef __quad_t __blkcnt64_t;

typedef struct timespec timespec, *Ptimespec;

typedef __u_quad_t __ino64_t;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat64 {
    __dev_t st_dev;
    uint __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    uint __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef struct addrinfo addrinfo, *Paddrinfo;

typedef uint __socklen_t;

typedef __socklen_t socklen_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo * ai_next;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef struct _IO_FILE FILE;

typedef int __ssize_t;

typedef __ssize_t ssize_t;

typedef int __pid_t;

typedef long __suseconds_t;

typedef long __clock_t;

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    int h_addrtype;
    int h_length;
    char * * h_addr_list;
};

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef int nl_item;

typedef struct dirent64 dirent64, *Pdirent64;

struct dirent64 {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct __dirstream __dirstream, *P__dirstream;

struct __dirstream {
};

typedef struct __dirstream DIR;

typedef union sigval sigval, *Psigval;

typedef union sigval sigval_t;

union sigval {
    int sival_int;
    void * sival_ptr;
};

typedef struct siginfo siginfo, *Psiginfo;

typedef union _union_1028 _union_1028, *P_union_1028;

typedef struct _struct_1029 _struct_1029, *P_struct_1029;

typedef struct _struct_1030 _struct_1030, *P_struct_1030;

typedef struct _struct_1031 _struct_1031, *P_struct_1031;

typedef struct _struct_1032 _struct_1032, *P_struct_1032;

typedef struct _struct_1033 _struct_1033, *P_struct_1033;

typedef struct _struct_1034 _struct_1034, *P_struct_1034;

struct _struct_1034 {
    long si_band;
    int si_fd;
};

struct _struct_1033 {
    void * si_addr;
};

struct _struct_1032 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct _struct_1031 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct _struct_1029 {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct _struct_1030 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

union _union_1028 {
    int _pad[125];
    struct _struct_1029 _kill;
    struct _struct_1030 _timer;
    struct _struct_1031 _rt;
    struct _struct_1032 _sigchld;
    struct _struct_1033 _sigfault;
    struct _struct_1034 _sigpoll;
};

struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union _union_1028 _sifields;
};

typedef struct siginfo siginfo_t;

typedef bool _Bool;

typedef struct bstring bstring, *Pbstring;

struct bstring {
    char * str;
    int len;
};

typedef struct _HTChunk _HTChunk, *P_HTChunk;

typedef struct _HTChunk HTChunk;

struct _HTChunk {
    int size;
    int growby;
    int allocated;
    char * data;
    int failok;
    HTChunk * next;
};

typedef struct _CSOfield_info _CSOfield_info, *P_CSOfield_info;

typedef struct _CSOfield_info CSOfield_info;

struct _CSOfield_info {
    struct _CSOfield_info * next;
    char * name;
    char * attributes;
    char * description;
    int id;
    int lookup;
    int indexed;
    int url;
    int max_size;
    int defreturn;
    int explicit_return;
    int reserved;
    int gpublic;
    char name_buf[16];
    char desc_buf[32];
    char attr_buf[80];
};

typedef struct _CSOformgen_context _CSOformgen_context, *P_CSOformgen_context;

struct _CSOformgen_context {
    char * host;
    char * seek;
    CSOfield_info * fld;
    int port;
    int cur_line;
    int cur_off;
    int rep_line;
    int rep_off;
    int public_override;
    int field_select;
};

typedef struct _CSOformgen_context CSOformgen_context;

typedef ushort LYKeymap_t;

typedef struct Kcmd Kcmd, *PKcmd;

typedef enum LYKeymapCode {
    LYK_1=2,
    LYK_2=3,
    LYK_3=4,
    LYK_4=5,
    LYK_5=6,
    LYK_6=7,
    LYK_7=8,
    LYK_8=9,
    LYK_9=10,
    LYK_ABORT=14,
    LYK_ACTIVATE=39,
    LYK_ADD_BOOKMARK=58,
    LYK_CHANGE_LINK=84,
    LYK_CHDIR=99,
    LYK_CHG_CENTER=98,
    LYK_CLEAR_AUTH=81,
    LYK_COMMAND=1,
    LYK_COMMENT=54,
    LYK_COOKIE_JAR=79,
    LYK_CREATE=92,
    LYK_DEL_BOOKMARK=59,
    LYK_DIRED_MENU=91,
    LYK_DOWNLOAD=63,
    LYK_DOWN_HALF=20,
    LYK_DOWN_LINK=33,
    LYK_DOWN_TWO=18,
    LYK_DO_NOTHING=69,
    LYK_DWIMEDIT=85,
    LYK_DWIMHELP=44,
    LYK_ECGOTO=42,
    LYK_EDIT=55,
    LYK_EDIT_TEXTAREA=86,
    LYK_ELGOTO=83,
    LYK_END=23,
    LYK_EXTERN_LINK=89,
    LYK_EXTERN_PAGE=90,
    LYK_FASTBACKW_LINK=30,
    LYK_FASTFORW_LINK=31,
    LYK_FIRST_LINK=24,
    LYK_F_LINK_NUM=80,
    LYK_GOTO=41,
    LYK_GROW_TEXTAREA=87,
    LYK_HEAD=68,
    LYK_HELP=43,
    LYK_HISTORICAL=75,
    LYK_HISTORY=36,
    LYK_HOME=22,
    LYK_IMAGE_TOGGLE=66,
    LYK_INDEX=45,
    LYK_INDEX_SEARCH=50,
    LYK_INFO=56,
    LYK_INLINE_TOGGLE=67,
    LYK_INSERT_FILE=88,
    LYK_INSTALL=97,
    LYK_INTERRUPT=47,
    LYK_JUMP=71,
    LYK_KEYMAP=72,
    LYK_LAST_LINK=25,
    LYK_LEFT_LINK=35,
    LYK_LINEWRAP_TOGGLE=102,
    LYK_LIST=73,
    LYK_LPOS_NEXT_LINK=29,
    LYK_LPOS_PREV_LINK=28,
    LYK_MAIN_MENU=48,
    LYK_MINIMAL=76,
    LYK_MODIFY=94,
    LYK_NESTED_TABLES=105,
    LYK_NEXT=53,
    LYK_NEXT_DOC=38,
    LYK_NEXT_LINK=27,
    LYK_NEXT_PAGE=15,
    LYK_NOCACHE=46,
    LYK_OPTIONS=49,
    LYK_PASTE_URL=103,
    LYK_PREV=52,
    LYK_PREV_DOC=37,
    LYK_PREV_LINK=26,
    LYK_PREV_PAGE=16,
    LYK_PRINT=57,
    LYK_QUIT=13,
    LYK_RAW_TOGGLE=78,
    LYK_REFRESH=21,
    LYK_RELOAD=12,
    LYK_REMOVE=93,
    LYK_RIGHT_LINK=34,
    LYK_SHELL=62,
    LYK_SHIFT_LEFT=100,
    LYK_SHIFT_RIGHT=101,
    LYK_SOFT_DQUOTES=77,
    LYK_SOURCE=11,
    LYK_SUBMIT=40,
    LYK_SWITCH_DTD=82,
    LYK_TAG_LINK=95,
    LYK_TOGGLE_HELP=70,
    LYK_TOOLBAR=74,
    LYK_TO_CLIPBOARD=104,
    LYK_TRACE_LOG=65,
    LYK_TRACE_TOGGLE=64,
    LYK_UNKNOWN=0,
    LYK_UPLOAD=96,
    LYK_UP_HALF=19,
    LYK_UP_LINK=32,
    LYK_UP_TWO=17,
    LYK_VIEW_BOOKMARK=60,
    LYK_VLINKS=61,
    LYK_WHEREIS=51
} LYKeymapCode;

struct Kcmd {
    enum LYKeymapCode code;
    char * name;
    char * doc;
};

typedef struct _HTStreamClass _HTStreamClass, *P_HTStreamClass;

typedef struct _HTStream _HTStream, *P_HTStream;

typedef struct _HTStream HTStream;

typedef void * HTError;

typedef struct _HTStreamClass HTStreamClass;

struct _HTStreamClass {
    char * name;
    void (* _free)(HTStream *);
    void (* _abort)(HTStream *, HTError);
    void (* put_character)(HTStream *, char);
    void (* put_string)(HTStream *, char *);
    void (* put_block)(HTStream *, char *, int);
};

struct _HTStream {
    HTStreamClass * isa;
};

typedef struct _HTStream.conflict6 _HTStream.conflict6, *P_HTStream.conflict6;

typedef char BOOLEAN;

typedef enum MIME_state {
    MIME_CHUNKED=1,
    MIME_IGNORE=79,
    MIME_NET_ASCII=78,
    MIME_TRANSPARENT=0,
    mcCHUNKED_COUNT_CR=3,
    mcCHUNKED_COUNT_DIGIT=2,
    mcCHUNKED_COUNT_LF=4,
    mcCHUNKED_DATA=6,
    mcCHUNKED_DATA_CR=7,
    mcCHUNKED_DATA_LF=8,
    mcCHUNKED_EXTENSION=5,
    miA=10,
    miACCEPT_RANGES=11,
    miAGE=12,
    miAL=13,
    miALLOW=14,
    miALTERNATES=15,
    miBEGINNING_OF_LINE=9,
    miC=16,
    miCACHE_CONTROL=17,
    miCHECK=77,
    miCO=18,
    miCON=20,
    miCONNECTION=21,
    miCONTENT_=22,
    miCONTENT_BASE=23,
    miCONTENT_DISPOSITION=24,
    miCONTENT_ENCODING=25,
    miCONTENT_FEATURES=26,
    miCONTENT_L=27,
    miCONTENT_LANGUAGE=28,
    miCONTENT_LENGTH=29,
    miCONTENT_LOCATION=30,
    miCONTENT_MD5=31,
    miCONTENT_RANGE=32,
    miCONTENT_T=33,
    miCONTENT_TRANSFER_ENCODING=34,
    miCONTENT_TYPE=35,
    miCOOKIE=19,
    miDATE=36,
    miE=37,
    miETAG=38,
    miEXPIRES=39,
    miGET_VALUE=74,
    miJUNK_LINE=75,
    miKEEP_ALIVE=40,
    miL=41,
    miLAST_MODIFIED=42,
    miLINK=43,
    miLOCATION=44,
    miNEWLINE=76,
    miP=45,
    miPR=46,
    miPRAGMA=47,
    miPROXY_AUTHENTICATE=48,
    miPUBLIC=49,
    miR=50,
    miRE=51,
    miREFRESH=52,
    miRETRY_AFTER=53,
    miS=54,
    miSAFE=55,
    miSE=56,
    miSERVER=57,
    miSET_COOKIE=58,
    miSET_COOKIE1=59,
    miSET_COOKIE2=60,
    miSKIP_GET_VALUE=73,
    miT=61,
    miTITLE=62,
    miTRANSFER_ENCODING=63,
    miU=64,
    miUPGRADE=65,
    miURI=66,
    miV=67,
    miVARY=68,
    miVIA=69,
    miW=70,
    miWARNING=71,
    miWWW_AUTHENTICATE=72
} MIME_state;

typedef struct _HTParentAnchor _HTParentAnchor, *P_HTParentAnchor;

typedef struct _HTParentAnchor HTParentAnchor;

typedef struct _HTAtom _HTAtom, *P_HTAtom;

typedef struct _HTAtom HTAtom;

typedef HTAtom * HTFormat;

typedef struct _HTParentAnchor0 _HTParentAnchor0, *P_HTParentAnchor0;

typedef struct _HTParentAnchor0 HTParentAnchor0;

typedef struct _HTList _HTList, *P_HTList;

typedef struct _HTList HTList;

typedef struct _HyperDoc _HyperDoc, *P_HyperDoc;

typedef struct _HyperDoc HyperDoc;

typedef struct _UCAnchorInfo _UCAnchorInfo, *P_UCAnchorInfo;

typedef struct _UCAnchorInfo UCAnchorInfo;

typedef struct _HTBTree_top _HTBTree_top, *P_HTBTree_top;

typedef struct _HTBTree_top HTBTree;

typedef struct _UCStageInfo _UCStageInfo, *P_UCStageInfo;

typedef struct _HTBTree_element _HTBTree_element, *P_HTBTree_element;

typedef struct _LYUCcharset _LYUCcharset, *P_LYUCcharset;

typedef struct _LYUCcharset LYUCcharset;

struct _HTBTree_top {
    int (* compare)(void *, void *);
    struct _HTBTree_element * top;
};

struct _LYUCcharset {
    int UChndl;
    char * MIMEname;
    int enc;
    int codepage;
    int repertoire;
    int codepoints;
    int cpranges;
    int like8859;
};

struct _UCStageInfo {
    int lock;
    int LYhndl;
    LYUCcharset C;
};

struct _HTBTree_element {
    void * object;
    struct _HTBTree_element * up;
    struct _HTBTree_element * left;
    int left_depth;
    struct _HTBTree_element * right;
    int right_depth;
};

struct _UCAnchorInfo {
    struct _UCStageInfo s[4];
};

struct _HTStream.conflict6 {
    HTStreamClass * isa;
    BOOLEAN net_ascii;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    enum MIME_state state;
    enum MIME_state if_ok;
    enum MIME_state field;
    enum MIME_state fold_state;
    BOOLEAN head_only;
    BOOLEAN pickup_redirection;
    BOOLEAN no_streamstack;
    undefined field_0x1b;
    char * check_pointer;
    char * value_pointer;
    char value[5120];
    HTParentAnchor * anchor;
    HTStream * sink;
    char * boundary;
    char * set_cookie;
    char * set_cookie2;
    char * location;
    char * refresh_url;
    HTFormat c_t_encoding;
    char * compression_encoding;
    BOOLEAN chunked_encoding;
    undefined field_0x1449;
    undefined field_0x144a;
    undefined field_0x144b;
    long chunked_size;
    HTFormat format;
    HTStream * target;
    HTStreamClass targetClass;
    HTAtom * targetRep;
};

struct _HyperDoc {
};

struct _HTAtom {
    HTAtom * next;
    char * name;
};

struct _HTList {
    void * object;
    HTList * next;
};

struct _HTParentAnchor0 {
    HTParentAnchor0 * parent;
    char * address;
    HTParentAnchor * info;
    HTBTree * children;
    HTList sources;
    HTList _add_adult;
    short adult_hash;
    BOOLEAN underway;
    undefined field_0x23;
};

struct _HTParentAnchor {
    HTParentAnchor0 * parent;
    HTList children_notag;
    HyperDoc * document;
    char * address;
    struct bstring * post_data;
    char * post_content_type;
    char * bookmark;
    HTFormat format;
    char * charset;
    BOOLEAN isIndex;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    char * isIndexAction;
    char * isIndexPrompt;
    char * title;
    char * owner;
    char * RevTitle;
    char * citehost;
    char * style;
    HTList * methods;
    void * protocol;
    char * physical;
    BOOLEAN isISMAPScript;
    BOOLEAN isHEAD;
    BOOLEAN safe;
    undefined field_0x57;
    char * source_cache_file;
    HTChunk * source_cache_chunk;
    char * FileCache;
    char * SugFname;
    char * cache_control;
    BOOLEAN no_cache;
    BOOLEAN inBASE;
    undefined field_0x6e;
    undefined field_0x6f;
    char * content_type_params;
    char * content_type;
    char * content_language;
    char * content_encoding;
    char * content_base;
    char * content_disposition;
    char * content_location;
    char * content_md5;
    char * message_id;
    char * subject;
    int content_length;
    char * date;
    char * expires;
    char * last_modified;
    char * ETag;
    char * server;
    UCAnchorInfo * UCStages;
    HTList * imaps;
};

typedef struct _HTStream.conflict5 _HTStream.conflict5, *P_HTStream.conflict5;

struct _HTStream.conflict5 {
    HTStreamClass * isa;
    BOOLEAN had_cr;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    HTStream * sink;
};

typedef struct _HTStream.conflict7 _HTStream.conflict7, *P_HTStream.conflict7;

typedef struct _HTStructured _HTStructured, *P_HTStructured;

typedef struct _HTStructured HTStructured;

typedef enum tokenstate {
    before_tag=1,
    before_value=3,
    beginning=0,
    bracketed_value=5,
    colon=2,
    done=8,
    escape_in_quoted=7,
    quoted_value=6,
    value=4
} tokenstate;

typedef struct _HTStructuredClass _HTStructuredClass, *P_HTStructuredClass;

typedef struct _HTStructuredClass HTStructuredClass;

typedef struct _HText _HText, *P_HText;

typedef struct _HText HText;

typedef struct HTChildAnchor HTChildAnchor, *PHTChildAnchor;

typedef struct _tag _tag, *P_tag;

typedef struct _tag HTTag;

typedef struct _HTStyle _HTStyle, *P_HTStyle;

typedef struct _HTStyle HTStyle;

typedef struct _stack_element _stack_element, *P_stack_element;

typedef struct _stack_element stack_element;

typedef struct _UCTransParams _UCTransParams, *P_UCTransParams;

typedef struct _UCTransParams UCTransParams;

typedef struct _line _line, *P_line;

typedef struct _line HTLine;

typedef struct HTLineTemp HTLineTemp, *PHTLineTemp;

typedef struct _TextAnchor _TextAnchor, *P_TextAnchor;

typedef struct _TextAnchor TextAnchor;

typedef struct _STable_info _STable_info, *P_STable_info;

typedef struct _STable_info STable_info;

typedef enum HTkcode {
    EUC=1,
    JIS=3,
    NOKANJI=0,
    SJIS=2
} HTkcode;

typedef enum eDetectedKCode {
    DET_EUC=1,
    DET_MIXED=3,
    DET_NOTYET=2,
    DET_SJIS=0
} eDetectedKCode;

typedef enum eSJIS_status {
    SJIS_state_has_bad_code=2,
    SJIS_state_in_kanji=1,
    SJIS_state_neutral=0
} eSJIS_status;

typedef enum eEUC_status {
    EUC_state_has_bad_code=3,
    EUC_state_in_kana=2,
    EUC_state_in_kanji=1,
    EUC_state_neutral=0
} eEUC_status;

typedef enum eGridState {
    S_dollar=2,
    S_dollar_paren=5,
    S_esc=1,
    S_jisx0201_text=6,
    S_nonascii_text=4,
    S_paren=3,
    S_text=0
} eGridState;

typedef struct _HTPool _HTPool, *P_HTPool;

typedef struct _HTPool HTPool;

typedef struct _HTAnchor _HTAnchor, *P_HTAnchor;

typedef struct _HTAnchor HTAnchor;

typedef HTAtom HTLinkType;

typedef struct attr attr, *Pattr;

typedef struct attr * AttrList;

typedef struct AttrType AttrType, *PAttrType;

typedef enum SGMLContent {
    SGML_CDATA=2,
    SGML_ELEMENT=6,
    SGML_EMPTY=0,
    SGML_LITTERAL=1,
    SGML_MIXED=5,
    SGML_PCDATA=7,
    SGML_RCDATA=4,
    SGML_SCRIPT=3
} SGMLContent;

typedef int TagClass;

typedef int TagFlags;

typedef long HTFont;

typedef int HTCoord;

typedef int HTColor;

typedef struct HTTabStop HTTabStop, *PHTTabStop;

typedef struct HTStyleChange HTStyleChange, *PHTStyleChange;

typedef struct _FormInfo _FormInfo, *P_FormInfo;

typedef struct _FormInfo FormInfo;

typedef struct HiliteList HiliteList, *PHiliteList;

typedef struct _STable_cellinfo _STable_cellinfo, *P_STable_cellinfo;

typedef struct _STable_cellinfo STable_cellinfo;

typedef struct _STable_rowinfo _STable_rowinfo, *P_STable_rowinfo;

typedef struct _STable_rowinfo STable_rowinfo;

typedef struct _STable_states _STable_states, *P_STable_states;

typedef struct _STable_states STable_states;

typedef struct HTStyleChange pool_data;

typedef struct _OptionType _OptionType, *P_OptionType;

typedef struct _OptionType OptionType;

typedef struct HiliteInfo HiliteInfo, *PHiliteInfo;

typedef enum ended_state {
    ROW_ended_by_endtr=1,
    ROW_ended_by_splitline=2,
    ROW_not_ended=0
} ended_state;

typedef enum cellstate_t {
    CS__0cb=4,
    CS__0cf=8,
    CS__0eb=2,
    CS__0ef=6,
    CS__0new=1,
    CS__cb=5,
    CS__cbc=11,
    CS__cf=9,
    CS__eb=3,
    CS__ebc=10,
    CS__ef=7,
    CS__new=0,
    CS_invalid=-1
} cellstate_t;

struct _STable_rowinfo {
    int Line;
    int ncells;
    BOOLEAN fixed_line;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    enum ended_state ended;
    int content;
    int offset;
    int allocated;
    STable_cellinfo * cells;
    int alignment;
};

struct _STable_states {
    enum cellstate_t prev_state;
    enum cellstate_t state;
    int lineno;
    int icell_core;
    int x_td;
    int pending_len;
};

struct _STable_info {
    struct _STable_info * enclosing;
    struct _TextAnchor * enclosing_last_anchor_before_stbl;
    int startline;
    int nrows;
    int ncols;
    int maxlen;
    int maxpos;
    int allocated_rows;
    int allocated_sumcols;
    int ncolinfo;
    STable_cellinfo * sumcols;
    STable_rowinfo * rows;
    STable_rowinfo rowspans2eog;
    short alignment;
    short rowgroup_align;
    short pending_colgroup_align;
    undefined field_0x5a;
    undefined field_0x5b;
    int pending_colgroup_next;
    STable_states s;
};

struct HiliteInfo {
    char * hl_text;
    short hl_x;
    undefined field_0x6;
    undefined field_0x7;
};

struct HiliteList {
    struct HiliteInfo * hl_info;
    struct HiliteInfo hl_base;
    short hl_len;
    undefined field_0xe;
    undefined field_0xf;
};

struct _OptionType {
    char * name;
    char * cp_submit_value;
    int value_cs;
    struct _OptionType * next;
};

struct _stack_element {
    HTStyle * style;
    int tag_number;
};

struct _HTStream.conflict7 {
    HTStreamClass * isa;
    HTStructured * target;
    char * par_value[23];
    enum tokenstate state;
    char param[10001];
    undefined field_0x2779;
    undefined field_0x277a;
    undefined field_0x277b;
    int param_number;
    int param_count;
};

struct _UCTransParams {
    BOOLEAN transp;
    BOOLEAN do_cjk;
    BOOLEAN decode_utf8;
    BOOLEAN output_utf8;
    BOOLEAN use_raw_char_in;
    BOOLEAN strip_raw_char_in;
    BOOLEAN pass_160_173_raw;
    BOOLEAN do_8bitraw;
    BOOLEAN trans_to_uni;
    BOOLEAN trans_C0_to_uni;
    BOOLEAN repl_translated_C0;
    BOOLEAN trans_from_uni;
};

struct _line {
    struct _line * next;
    struct _line * prev;
    ushort offset;
    ushort size;
    struct HTStyleChange * styles;
    ushort numstyles;
    char data[1];
    undefined field_0x13;
};

struct HTLineTemp {
    HTLine base;
    char data[1026];
    undefined field_0x416;
    undefined field_0x417;
};

struct attr {
    char * name;
    char type;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

struct _HTStructured {
    HTStructuredClass * isa;
    HTParentAnchor * node_anchor;
    HText * text;
    HTStream * target;
    HTStreamClass targetClass;
    struct HTChildAnchor * CurrentA;
    int CurrentANum;
    char * base_href;
    char * map_address;
    HTChunk title;
    HTChunk object;
    BOOLEAN object_started;
    BOOLEAN object_declare;
    BOOLEAN object_shapes;
    BOOLEAN object_ismap;
    char * object_usemap;
    char * object_id;
    char * object_title;
    char * object_data;
    char * object_type;
    char * object_classid;
    char * object_codebase;
    char * object_codetype;
    char * object_name;
    int objects_mixed_open;
    int objects_figged_open;
    HTChunk option;
    BOOLEAN first_option;
    undefined field_0xb1;
    undefined field_0xb2;
    undefined field_0xb3;
    char * LastOptionValue;
    BOOLEAN LastOptionChecked;
    BOOLEAN select_disabled;
    undefined field_0xba;
    undefined field_0xbb;
    HTChunk textarea;
    char * textarea_name;
    int textarea_name_cs;
    char * textarea_accept_cs;
    int textarea_cols;
    int textarea_rows;
    int textarea_disabled;
    char * textarea_id;
    HTChunk math;
    HTChunk style_block;
    HTChunk script;
    int List_Nesting_Level;
    int OL_Counter[12];
    char OL_Type[12];
    int Last_OL_Count;
    char Last_OL_Type;
    undefined field_0x17d;
    undefined field_0x17e;
    undefined field_0x17f;
    int Division_Level;
    short DivisionAlignments[800];
    int Underline_Level;
    int Quote_Level;
    BOOLEAN UsePlainSpace;
    BOOLEAN HiddenValue;
    undefined field_0x7ce;
    undefined field_0x7cf;
    int lastraw;
    char * comment_start;
    char * comment_end;
    HTTag * current_tag;
    BOOLEAN style_change;
    undefined field_0x7e1;
    undefined field_0x7e2;
    undefined field_0x7e3;
    HTStyle * new_style;
    HTStyle * old_style;
    int current_default_alignment;
    BOOLEAN in_word;
    undefined field_0x7f1;
    undefined field_0x7f2;
    undefined field_0x7f3;
    stack_element stack[800];
    stack_element * sp;
    BOOLEAN stack_overrun;
    undefined field_0x20f9;
    undefined field_0x20fa;
    undefined field_0x20fb;
    int skip_stack;
    BOOLEAN inA;
    BOOLEAN inAPPLET;
    BOOLEAN inAPPLETwithP;
    BOOLEAN inBadBASE;
    BOOLEAN inBadHREF;
    BOOLEAN inBadHTML;
    BOOLEAN inBASE;
    BOOLEAN inBoldA;
    BOOLEAN inBoldH;
    BOOLEAN inCAPTION;
    BOOLEAN inCREDIT;
    BOOLEAN inFIG;
    BOOLEAN inFIGwithP;
    BOOLEAN inFONT;
    BOOLEAN inFORM;
    BOOLEAN inLABEL;
    BOOLEAN inP;
    BOOLEAN inPRE;
    BOOLEAN inSELECT;
    BOOLEAN inTABLE;
    BOOLEAN inTEXTAREA;
    BOOLEAN inUnderline;
    BOOLEAN needBoldH;
    undefined field_0x2117;
    char * xinclude;
    LYUCcharset * UCI;
    int UCLYhndl;
    LYUCcharset * inUCI;
    int inUCLYhndl;
    LYUCcharset * outUCI;
    int outUCLYhndl;
    UCTransParams T;
    int tag_charset;
};

struct _FormInfo {
    char * name;
    int number;
    int type;
    char * value;
    char * orig_value;
    int size;
    uint maxlength;
    int group;
    int num_value;
    int hrange;
    int lrange;
    OptionType * select_list;
    char * submit_action;
    int submit_method;
    char * submit_enctype;
    char * submit_title;
    BOOLEAN no_cache;
    undefined field_0x41;
    undefined field_0x42;
    undefined field_0x43;
    char * cp_submit_value;
    char * orig_submit_value;
    int size_l;
    int disabled;
    int name_cs;
    int value_cs;
    char * accept_cs;
};

struct _HTStructuredClass {
    char * name;
    void (* _free)(HTStructured *);
    void (* _abort)(HTStructured *, HTError);
    void (* put_character)(HTStructured *, char);
    void (* put_string)(HTStructured *, char *);
    void (* put_block)(HTStructured *, char *, int);
    int (* start_element)(HTStructured *, int, BOOLEAN *, char * *, int, char * *);
    int (* end_element)(HTStructured *, int, char * *);
    int (* put_entity)(HTStructured *, int);
};

struct _HTStyle {
    struct _HTStyle * next;
    char * name;
    int id;
    char * SGMLTag;
    HTFont font;
    HTCoord fontSize;
    HTColor color;
    int superscript;
    HTAnchor * anchor;
    HTCoord indent1st;
    HTCoord leftIndent;
    HTCoord rightIndent;
    short alignment;
    undefined field_0x32;
    undefined field_0x33;
    HTCoord lineHt;
    HTCoord descentLine;
    struct HTTabStop * tabs;
    BOOLEAN wordWrap;
    BOOLEAN freeFormat;
    undefined field_0x42;
    undefined field_0x43;
    HTCoord spaceBefore;
    HTCoord spaceAfter;
    int paraFlags;
};

struct _HText {
    HTParentAnchor * node_anchor;
    HTLine * last_line;
    struct HTLineTemp temp_line[2];
    int Lines;
    TextAnchor * first_anchor;
    TextAnchor * last_anchor;
    TextAnchor * last_anchor_before_stbl;
    TextAnchor * last_anchor_before_split;
    HTList * forms;
    int last_anchor_number;
    BOOLEAN source;
    BOOLEAN toolbar;
    undefined field_0x856;
    undefined field_0x857;
    HTList * tabs;
    HTList * hidden_links;
    int hiddenlinkflag;
    BOOLEAN no_cache;
    char LastChar;
    BOOLEAN IgnoreExcess;
    undefined field_0x867;
    HTStyle * style;
    int display_on_the_fly;
    int top_of_screen;
    HTLine * top_of_screen_line;
    HTLine * next_line;
    uint permissible_split;
    BOOLEAN in_line_1;
    BOOLEAN stale;
    BOOLEAN page_has_target;
    BOOLEAN has_utf8;
    BOOLEAN had_utf8;
    undefined field_0x885;
    undefined field_0x886;
    undefined field_0x887;
    int first_lineno_last_disp_partial;
    int last_lineno_last_disp_partial;
    STable_info * stbl;
    HTList * enclosed_stbl;
    enum HTkcode kcode;
    enum HTkcode specified_kcode;
    enum eDetectedKCode detected_kcode;
    enum eSJIS_status SJIS_status;
    enum eEUC_status EUC_status;
    enum eGridState state;
    int kanji_buf;
    int in_sjis;
    int halted;
    BOOLEAN have_8bit_chars;
    undefined field_0x8bd;
    undefined field_0x8be;
    undefined field_0x8bf;
    LYUCcharset * UCI;
    int UCLYhndl;
    UCTransParams T;
    HTStream * target;
    HTStreamClass targetClass;
    HTPool * pool;
    BOOLEAN clickable_images;
    BOOLEAN pseudo_inline_alts;
    BOOLEAN verbose_img;
    BOOLEAN raw_mode;
    BOOLEAN historical_comments;
    BOOLEAN minimal_comments;
    BOOLEAN soft_dquotes;
    undefined field_0x8fb;
    short old_dtd;
    short keypad_mode;
    short disp_lines;
    short disp_cols;
};

struct _HTAnchor {
    HTParentAnchor0 * parent;
};

struct HTStyleChange {
    uint direction:2;
    uint horizpos:14;
    uint style:16;
};

struct _STable_cellinfo {
    int cLine;
    int pos;
    int len;
    int colspan;
    int alignment;
};

struct AttrType {
    char * name;
    AttrList list;
};

struct HTTabStop {
    short kind;
    undefined field_0x2;
    undefined field_0x3;
    HTCoord position;
};

struct _HTPool {
    pool_data data[2042];
    struct _HTPool * prev;
    int used;
};

struct _tag {
    char * name;
    int name_len;
    BOOLEAN can_justify;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    AttrList attributes;
    int number_of_attributes;
    struct AttrType * attr_types;
    enum SGMLContent contents;
    TagClass tagclass;
    TagClass contains;
    TagClass icontains;
    TagClass contained;
    TagClass icontained;
    TagClass canclose;
    TagFlags flags;
};

struct HTChildAnchor {
    HTParentAnchor0 * parent;
    char * tag;
    HTAnchor * dest;
    HTLinkType * type;
    HTList _add_children_notag;
    HTList _add_sources;
};

struct _TextAnchor {
    struct _TextAnchor * next;
    struct _TextAnchor * prev;
    int sgml_offset;
    int number;
    int line_num;
    short line_pos;
    short extent;
    BOOLEAN show_anchor;
    BOOLEAN inUnderline;
    BOOLEAN expansion_anch;
    char link_type;
    FormInfo * input_field;
    struct HiliteList lites;
    struct HTChildAnchor * anchor;
};

typedef struct _HTStream.conflict7 HTStream.conflict7;

typedef struct _HTStream.conflict6 HTStream.conflict6;

typedef struct _HTStream.conflict5 HTStream.conflict5;

typedef struct _HTStream.conflict _HTStream.conflict, *P_HTStream.conflict;


// WARNING! conflicting data type names: /DWARF/stdio.h/FILE - /stdio.h/FILE

struct _HTStream.conflict {
    HTStreamClass * isa;
    HTParentAnchor * anchor;
    FILE * fp;
    char * filename;
    HTChunk * chunk;
    HTChunk * last_chunk;
    HTStreamClass * actions;
    HTStream * target;
    int status;
};

typedef struct _HTStream.conflict4 _HTStream.conflict4, *P_HTStream.conflict4;

typedef struct _HTStream.conflict4 HTStream.conflict4;

struct _HTStream.conflict4 {
    HTStreamClass * isa;
    HTStream * target;
    HTStreamClass targetClass;
};

typedef struct _HTStream.conflict HTStream.conflict;

typedef struct _HTStream.conflict3 _HTStream.conflict3, *P_HTStream.conflict3;

typedef struct _HTStream.conflict3 HTStream.conflict3;

typedef long UCode_t;

struct _HTStream.conflict3 {
    HTStreamClass * isa;
    HText * text;
    LYUCcharset * inUCI;
    int inUCLYhndl;
    LYUCcharset * outUCI;
    int outUCLYhndl;
    char utf_count;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
    UCode_t utf_char;
    char utf_buf[8];
    char * utf_buf_p;
    UCTransParams T;
};

typedef struct _HTStream.conflict2 _HTStream.conflict2, *P_HTStream.conflict2;

typedef struct _HTStream.conflict2 HTStream.conflict2;

typedef struct SGML_dtd SGML_dtd, *PSGML_dtd;

typedef struct _HTElement _HTElement, *P_HTElement;

typedef struct _HTElement HTElement;

typedef enum sgml_state {
    S_attr=1,
    S_attr_gap=2,
    S_comment=3,
    S_cro=4,
    S_doctype=5,
    S_dollar=6,
    S_dollar_dq=7,
    S_dollar_paren=8,
    S_dollar_paren_dq=9,
    S_dollar_paren_sq=10,
    S_dollar_sq=11,
    S_dquoted=12,
    S_end=13,
    S_entity=14,
    S_equals=15,
    S_ero=16,
    S_esc=17,
    S_esc_dq=18,
    S_esc_sq=19,
    S_exclamation=20,
    S_in_kanji=21,
    S_incro=22,
    S_junk_tag=23,
    S_litteral=24,
    S_marked=25,
    S_nonascii_text=26,
    S_nonascii_text_dq=27,
    S_nonascii_text_sq=28,
    S_paren=29,
    S_paren_dq=30,
    S_paren_sq=31,
    S_pcdata=32,
    S_pi=33,
    S_script=34,
    S_sgmlatt=35,
    S_sgmlele=36,
    S_sgmlent=37,
    S_squoted=38,
    S_tag=39,
    S_tag_gap=40,
    S_tagname_slash=41,
    S_text=0,
    S_value=42
} sgml_state;


// WARNING! conflicting data type names: /DWARF/stddef.h/size_t - /stddef.h/size_t

struct SGML_dtd {
    HTTag * tags;
    int number_of_tags;
    char * * entity_names;
    size_t number_of_entities;
};

struct _HTElement {
    HTElement * next;
    HTTag * tag;
};

struct _HTStream.conflict2 {
    HTStreamClass * isa;
    struct SGML_dtd * dtd;
    HTStructuredClass * actions;
    HTStructured * target;
    HTTag * current_tag;
    HTTag * slashedtag;
    HTTag * unknown_tag;
    BOOLEAN extended_html;
    BOOLEAN strict_xml;
    BOOLEAN inSELECT;
    BOOLEAN no_lynx_specialcodes;
    int current_attribute_number;
    HTChunk * string;
    int leading_spaces;
    int trailing_spaces;
    HTElement * element_stack;
    enum sgml_state state;
    uchar kanji_buf;
    BOOLEAN present[36];
    undefined field_0x5d;
    undefined field_0x5e;
    undefined field_0x5f;
    char * value[36];
    BOOLEAN lead_exclamation;
    BOOLEAN first_dash;
    BOOLEAN end_comment;
    BOOLEAN doctype_bracket;
    BOOLEAN first_bracket;
    BOOLEAN second_bracket;
    BOOLEAN isHex;
    undefined field_0xf7;
    HTParentAnchor * node_anchor;
    LYUCcharset * inUCI;
    int inUCLYhndl;
    LYUCcharset * outUCI;
    int outUCLYhndl;
    char utf_count;
    undefined field_0x10d;
    undefined field_0x10e;
    undefined field_0x10f;
    UCode_t utf_char;
    char utf_buf[8];
    char * utf_buf_p;
    UCTransParams T;
    int current_tag_charset;
    char * recover;
    int recover_index;
    char * include;
    char * active_include;
    int include_index;
    char * url;
    char * csi;
    int csi_index;
    BOOLEAN cur_attr_is_href;
    BOOLEAN cur_attr_is_name;
    undefined field_0x152;
    undefined field_0x153;
};

typedef struct _HTStream.conflict1 _HTStream.conflict1, *P_HTStream.conflict1;

typedef struct _HTStream.conflict1 HTStream.conflict1;

struct _HTStream.conflict1 {
    HTStreamClass * isa;
    FILE * fp;
    char * end_command;
    char * remove_command;
    char * viewer_command;
    HTFormat input_format;
    HTFormat output_format;
    HTParentAnchor * anchor;
    HTStream * sink;
};

typedef int int32_t;

typedef __mode_t mode_t;

typedef __pid_t pid_t;

typedef __ino64_t ino_t;

typedef __uid_t uid_t;

typedef __off64_t off_t;

typedef __gid_t gid_t;

typedef __dev_t dev_t;

typedef struct anon_struct_0 anon_struct_0, *Panon_struct_0;

struct anon_struct_0 {
    int color;
    char * type;
};


// WARNING! conflicting data type names: /DWARF/LYStyle.c/parse_style/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0


// WARNING! conflicting data type names: /DWARF/dirent.h/DIR - /dirent.h/DIR

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
    undefined field_0x113;
};

typedef enum _login_protocol {
    rlogin=1,
    telnet=0,
    tn3270=2
} _login_protocol;


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval_t - /siginfo.h/sigval_t


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval - /siginfo.h/sigval


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo - /siginfo.h/siginfo

typedef union anon_union anon_union, *Panon_union;

typedef struct anon_struct.conflict2 anon_struct.conflict2, *Panon_struct.conflict2;

typedef struct anon_struct.conflict3 anon_struct.conflict3, *Panon_struct.conflict3;

typedef struct anon_struct.conflict4 anon_struct.conflict4, *Panon_struct.conflict4;

typedef struct anon_struct.conflict5 anon_struct.conflict5, *Panon_struct.conflict5;

typedef struct anon_struct.conflict6 anon_struct.conflict6, *Panon_struct.conflict6;

typedef struct anon_struct.conflict7 anon_struct.conflict7, *Panon_struct.conflict7;

struct anon_struct.conflict2 {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct anon_struct.conflict4 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct anon_struct.conflict6 {
    void * si_addr;
};

struct anon_struct.conflict3 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

struct anon_struct.conflict7 {
    long si_band;
    int si_fd;
};

struct anon_struct.conflict5 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

union anon_union {
    int _pad[29];
    struct anon_struct.conflict2 _kill;
    struct anon_struct.conflict3 _timer;
    struct anon_struct.conflict4 _rt;
    struct anon_struct.conflict5 _sigchld;
    struct anon_struct.conflict6 _sigfault;
    struct anon_struct.conflict7 _sigpoll;
};


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo_t - /siginfo.h/siginfo_t

typedef union anon_union_for__sifields anon_union_for__sifields, *Panon_union_for__sifields;

union anon_union_for__sifields {
    int _pad[29];
    struct anon_struct.conflict2 _kill;
    struct anon_struct.conflict3 _timer;
    struct anon_struct.conflict4 _rt;
    struct anon_struct.conflict5 _sigchld;
    struct anon_struct.conflict6 _sigfault;
    struct anon_struct.conflict7 _sigpoll;
};

typedef struct _HTBTree_element HTBTElement;

typedef char * __gnuc_va_list;

typedef struct _rule _rule, *P_rule;

typedef struct _rule rule;

typedef enum HTRuleOp {
    HT_Alert=9,
    HT_AlwaysAlert=10,
    HT_DefProt=4,
    HT_Fail=3,
    HT_InfoMsg=7,
    HT_Invalid=0,
    HT_Map=1,
    HT_Pass=2,
    HT_PermitRedir=13,
    HT_Progress=6,
    HT_Protect=5,
    HT_Redirect=11,
    HT_RedirectPerm=12,
    HT_UseProxy=14,
    HT_UserMsg=8
} HTRuleOp;

struct _rule {
    struct _rule * next;
    enum HTRuleOp op;
    char * pattern;
    char * equiv;
    char * condition_op;
    char * condition;
};

typedef struct struct_parts struct_parts, *Pstruct_parts;

struct struct_parts {
    char * access;
    char * host;
    char * absolute;
    char * relative;
    char * search;
    char * anchor;
};

typedef struct _HTStyleSheet _HTStyleSheet, *P_HTStyleSheet;

typedef struct _HTStyleSheet HTStyleSheet;

struct _HTStyleSheet {
    char * name;
    HTStyle * styles;
};

typedef enum HTStyle_Enum {
    ST_Address=39,
    ST_Banner=4,
    ST_Blockquote=5,
    ST_Bq=6,
    ST_DivCenter=1,
    ST_DivLeft=2,
    ST_DivRight=3,
    ST_Example=36,
    ST_Footnote=7,
    ST_Glossary=22,
    ST_Glossary1=23,
    ST_Glossary2=24,
    ST_Glossary3=25,
    ST_Glossary4=26,
    ST_Glossary5=27,
    ST_Glossary6=28,
    ST_GlossaryCompact=29,
    ST_GlossaryCompact1=30,
    ST_GlossaryCompact2=31,
    ST_GlossaryCompact3=32,
    ST_GlossaryCompact4=33,
    ST_GlossaryCompact5=34,
    ST_GlossaryCompact6=35,
    ST_Heading1=41,
    ST_Heading2=42,
    ST_Heading3=43,
    ST_Heading4=44,
    ST_Heading5=45,
    ST_Heading6=46,
    ST_HeadingCenter=47,
    ST_HeadingLeft=48,
    ST_HeadingRight=49,
    ST_List=8,
    ST_List1=9,
    ST_List2=10,
    ST_List3=11,
    ST_List4=12,
    ST_List5=13,
    ST_List6=14,
    ST_Listing=38,
    ST_Menu=15,
    ST_Menu1=16,
    ST_Menu2=17,
    ST_Menu3=18,
    ST_Menu4=19,
    ST_Menu5=20,
    ST_Menu6=21,
    ST_Normal=0,
    ST_Note=40,
    ST_Preformatted=37
} HTStyle_Enum;

typedef union anon_union.conflict anon_union.conflict, *Panon_union.conflict;

typedef void (* __sighandler_t)(int);

union anon_union.conflict {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

typedef struct sigaction sigaction, *Psigaction;

typedef union anon_union_for___sigaction_handler anon_union_for___sigaction_handler, *Panon_union_for___sigaction_handler;

typedef struct __sigset_t __sigset_t, *P__sigset_t;

struct __sigset_t {
    ulong __val[32];
};

union anon_union_for___sigaction_handler {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

struct sigaction {
    union anon_union_for___sigaction_handler __sigaction_handler;
    struct __sigset_t sa_mask;
    int sa_flags;
    void (* sa_restorer)(void);
};

typedef struct _connection _connection, *P_connection;

typedef struct _connection connection;

struct _connection {
    struct _connection * next;
    ulong addr;
    int socket;
    BOOLEAN binary;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum eServerType {
    APPLESHARE_SERVER=13,
    CMS_SERVER=4,
    DCTS_SERVER=5,
    DLS_SERVER=15,
    GENERIC_SERVER=0,
    MACHTEN_SERVER=1,
    MSDOS_SERVER=12,
    MS_WINDOWS_SERVER=11,
    NCSA_SERVER=8,
    NETPRESENZ_SERVER=14,
    PETER_LEWIS_SERVER=7,
    TCPC_SERVER=6,
    UNIX_SERVER=2,
    VMS_SERVER=3,
    WINDOWS_2K_SERVER=10,
    WINDOWS_NT_SERVER=9
} eServerType;

typedef struct _EntryInfo _EntryInfo, *P_EntryInfo;

typedef struct _EntryInfo EntryInfo;

struct _EntryInfo {
    char * filename;
    char * linkname;
    char * type;
    char * date;
    uint size;
    BOOLEAN display;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
};

typedef struct _hashbucket _hashbucket, *P_hashbucket;

typedef struct _hashbucket bucket;

struct _hashbucket {
    char * name;
    int code;
    int color;
    int mono;
    int cattr;
    struct _hashbucket * next;
};

typedef union anon_union_for___u anon_union_for___u, *Panon_union_for___u;

union anon_union_for___u {
    int __in;
    int __i;
};

typedef struct AlignedHOSTENT AlignedHOSTENT, *PAlignedHOSTENT;


// WARNING! conflicting data type names: /DWARF/netdb.h/hostent - /bio.h/hostent

struct AlignedHOSTENT {
    struct hostent h;
    char rest[128];
};

typedef struct _statuses _statuses, *P_statuses;

struct _statuses {
    size_t rehostentlen;
    int h_length;
    int child_errno;
    int child_h_errno;
    BOOLEAN h_errno_valid;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef struct _PerFormInfo _PerFormInfo, *P_PerFormInfo;

typedef struct _PerFormInfo PerFormInfo;

struct _PerFormInfo {
    int number;
    int disabled;
    struct _PerFormInfo * next;
    int nfields;
    FormInfo * first_field;
    FormInfo * last_field;
    char * accept_cs;
    char * thisacceptcs;
};

typedef struct _InputFieldData _InputFieldData, *P_InputFieldData;

struct _InputFieldData {
    char * accept;
    char * align;
    int checked;
    char * iclass;
    int disabled;
    char * error;
    char * height;
    char * id;
    char * lang;
    char * max;
    char * maxlength;
    char * md;
    char * min;
    char * name;
    int size;
    char * src;
    char * type;
    char * value;
    char * width;
    int name_cs;
    int value_cs;
    char * accept_cs;
};

typedef struct _InputFieldData InputFieldData;

typedef enum html_src_check_state {
    HTSRC_CK_after_tagname=2,
    HTSRC_CK_normal=0,
    HTSRC_CK_seen_dot=3,
    HTSRC_CK_seen_excl=1
} html_src_check_state;

typedef struct _HT_tagspec _HT_tagspec, *P_HT_tagspec;

typedef struct _HT_tagspec HT_tagspec;

typedef enum HTMLElement {
    HTML_A=0,
    HTML_ABBR=1,
    HTML_ACRONYM=2,
    HTML_ADDRESS=3,
    HTML_ALT_OBJECT=118,
    HTML_APPLET=4,
    HTML_AREA=5,
    HTML_AU=6,
    HTML_AUTHOR=7,
    HTML_B=8,
    HTML_BANNER=9,
    HTML_BASE=10,
    HTML_BASEFONT=11,
    HTML_BDO=12,
    HTML_BGSOUND=13,
    HTML_BIG=14,
    HTML_BLINK=15,
    HTML_BLOCKQUOTE=16,
    HTML_BODY=17,
    HTML_BODYTEXT=18,
    HTML_BQ=19,
    HTML_BR=20,
    HTML_BUTTON=21,
    HTML_CAPTION=22,
    HTML_CENTER=23,
    HTML_CITE=24,
    HTML_CODE=25,
    HTML_COL=26,
    HTML_COLGROUP=27,
    HTML_COMMENT=28,
    HTML_CREDIT=29,
    HTML_DD=30,
    HTML_DEL=31,
    HTML_DFN=32,
    HTML_DIR=33,
    HTML_DIV=34,
    HTML_DL=35,
    HTML_DLC=36,
    HTML_DT=37,
    HTML_EM=38,
    HTML_EMBED=39,
    HTML_FIELDSET=40,
    HTML_FIG=41,
    HTML_FN=42,
    HTML_FONT=43,
    HTML_FORM=44,
    HTML_FRAME=45,
    HTML_FRAMESET=46,
    HTML_H1=47,
    HTML_H2=48,
    HTML_H3=49,
    HTML_H4=50,
    HTML_H5=51,
    HTML_H6=52,
    HTML_HEAD=53,
    HTML_HR=54,
    HTML_HTML=55,
    HTML_HY=56,
    HTML_I=57,
    HTML_IFRAME=58,
    HTML_IMG=59,
    HTML_INPUT=60,
    HTML_INS=61,
    HTML_ISINDEX=62,
    HTML_KBD=63,
    HTML_KEYGEN=64,
    HTML_LABEL=65,
    HTML_LEGEND=66,
    HTML_LH=67,
    HTML_LI=68,
    HTML_LINK=69,
    HTML_LISTING=70,
    HTML_MAP=71,
    HTML_MARQUEE=72,
    HTML_MATH=73,
    HTML_MENU=74,
    HTML_META=75,
    HTML_NEXTID=76,
    HTML_NOFRAMES=77,
    HTML_NOTE=78,
    HTML_OBJECT=79,
    HTML_OL=80,
    HTML_OPTION=81,
    HTML_OVERLAY=82,
    HTML_P=83,
    HTML_PARAM=84,
    HTML_PLAINTEXT=85,
    HTML_PRE=86,
    HTML_Q=87,
    HTML_S=88,
    HTML_SAMP=89,
    HTML_SCRIPT=90,
    HTML_SELECT=91,
    HTML_SHY=92,
    HTML_SMALL=93,
    HTML_SPAN=94,
    HTML_SPOT=95,
    HTML_STRIKE=96,
    HTML_STRONG=97,
    HTML_STYLE=98,
    HTML_SUB=99,
    HTML_SUP=100,
    HTML_TAB=101,
    HTML_TABLE=102,
    HTML_TBODY=103,
    HTML_TD=104,
    HTML_TEXTAREA=105,
    HTML_TEXTFLOW=106,
    HTML_TFOOT=107,
    HTML_TH=108,
    HTML_THEAD=109,
    HTML_TITLE=110,
    HTML_TR=111,
    HTML_TT=112,
    HTML_U=113,
    HTML_UL=114,
    HTML_VAR=115,
    HTML_WBR=116,
    HTML_XMP=117
} HTMLElement;

struct _HT_tagspec {
    struct _HT_tagspec * next;
    int style;
    char * class_name;
    enum HTMLElement element;
    BOOLEAN * present;
    char * * value;
    BOOLEAN start;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef enum HTlexeme {
    HTL_abracket=4,
    HTL_attrib=2,
    HTL_attrval=3,
    HTL_badattr=10,
    HTL_badseq=8,
    HTL_badtag=9,
    HTL_comm=0,
    HTL_entire=7,
    HTL_entity=5,
    HTL_href=6,
    HTL_num_lexemes=12,
    HTL_sgmlspecial=11,
    HTL_tag=1
} HTlexeme;

typedef struct anon_struct anon_struct, *Panon_struct;

struct anon_struct {
    char * name;
    int code;
};

typedef struct anon_struct.conflict anon_struct.conflict, *Panon_struct.conflict;

struct anon_struct.conflict {
    int fg;
    int dft_fg;
    int bg;
    int dft_bg;
};

typedef struct anon_struct.conflict1 anon_struct.conflict1, *Panon_struct.conflict1;

struct anon_struct.conflict1 {
    int fg;
    int bg;
};

typedef struct unipair_str unipair_str, *Punipair_str;

struct unipair_str {
    ushort unicode;
    undefined field_0x2;
    undefined field_0x3;
    char * replace_str;
};

typedef struct unimapdesc_str unimapdesc_str, *Punimapdesc_str;

struct unimapdesc_str {
    ushort entry_ct;
    undefined field_0x2;
    undefined field_0x3;
    struct unipair_str * entries;
    int isdefault;
    int trydefault;
};

typedef struct HTAAProt HTAAProt, *PHTAAProt;

typedef struct GroupDef GroupDef, *PGroupDef;

typedef HTList HTAssocList;

typedef HTList ItemList;

struct GroupDef {
    char * group_name;
    ItemList * item_list;
};

struct HTAAProt {
    char * ctemplate;
    char * filename;
    char * uid_name;
    char * gid_name;
    struct GroupDef * mask_group;
    HTList * valid_schemes;
    HTAssocList * values;
};

typedef __gnuc_va_list va_list;


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE


// WARNING! conflicting data type names: /DWARF/socket.h/sockaddr - /socket.h/sockaddr

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

struct sockaddr_storage {
    sa_family_t ss_family;
    undefined field_0x2;
    undefined field_0x3;
    ulong __ss_align;
    char __ss_padding[120];
};

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

typedef ushort uint16_t;

typedef uint16_t in_port_t;

typedef struct in_addr in_addr, *Pin_addr;

typedef uint uint32_t;

typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    uchar sin_zero[8];
};

typedef enum __socket_type {
    SOCK_CLOEXEC=524288,
    SOCK_DCCP=6,
    SOCK_DGRAM=2,
    SOCK_NONBLOCK=2048,
    SOCK_PACKET=10,
    SOCK_RAW=3,
    SOCK_RDM=4,
    SOCK_SEQPACKET=5,
    SOCK_STREAM=1
} __socket_type;

typedef struct HTAAProtCache HTAAProtCache, *PHTAAProtCache;

struct HTAAProtCache {
    char * prot_filename;
    struct HTAAProt * prot;
};

typedef struct USER_DATA USER_DATA, *PUSER_DATA;

struct USER_DATA {
    char * name;
    int user;
};

typedef struct z_stream_s z_stream_s, *Pz_stream_s;

typedef void * voidpf;

typedef uint uInt;

typedef struct z_stream_s z_stream;

typedef uchar Byte;

typedef Byte Bytef;

typedef ulong uLong;

typedef struct internal_state internal_state, *Pinternal_state;

struct internal_state {
    int dummy;
};

struct z_stream_s {
    Bytef * next_in;
    uInt avail_in;
    uLong total_in;
    Bytef * next_out;
    uInt avail_out;
    uLong total_out;
    char * msg;
    struct internal_state * state;
    voidpf (* zalloc)(voidpf, uInt, uInt);
    void (* zfree)(voidpf, voidpf);
    voidpf opaque;
    int data_type;
    uLong adler;
    uLong reserved;
};

typedef void * voidp;

typedef voidp gzFile;

typedef struct _TABLE _TABLE, *P_TABLE;

typedef struct _TABLE TABLE;

typedef __time_t time_t;

struct _TABLE {
    char * name;
    int type;
    time_t value;
};

typedef enum _DSTMODE {
    DSTmaybe=2,
    DSToff=1,
    DSTon=0
} _DSTMODE;

typedef enum _DSTMODE DSTMODE;

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef enum _MERIDIAN {
    MER24=2,
    MERam=0,
    MERpm=1
} _MERIDIAN;

union YYSTYPE {
    time_t Number;
    enum _MERIDIAN Meridian;
};

typedef enum _MERIDIAN MERIDIAN;

typedef struct _JumpDatum _JumpDatum, *P_JumpDatum;

typedef struct _JumpDatum JumpDatum;

struct _JumpDatum {
    char * key;
    char * url;
};

typedef struct JumpTable JumpTable, *PJumpTable;

struct JumpTable {
    int key;
    int nel;
    char * msg;
    char * file;
    char * shortcut;
    HTList * history;
    JumpDatum * table;
    struct JumpTable * next;
    char * mp;
};

typedef enum AcceptMedia {
    mediaALL=31,
    mediaCFG=4,
    mediaEXT=2,
    mediaINT=1,
    mediaOpt1=1,
    mediaOpt2=5,
    mediaOpt3=13,
    mediaOpt4=29,
    mediaSYS=16,
    mediaUSR=8
} AcceptMedia;

typedef struct _HTPresentation _HTPresentation, *P_HTPresentation;

typedef struct _HTPresentation HTPresentation;

struct _HTPresentation {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream * (* converter)(HTPresentation *, HTParentAnchor *, HTStream *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    int accept_opt;
};

typedef struct _LYMapElement _LYMapElement, *P_LYMapElement;

typedef struct _LYMapElement LYMapElement;

struct _LYMapElement {
    char * address;
    char * title;
};

typedef struct _LYImageMap _LYImageMap, *P_LYImageMap;

typedef struct _LYImageMap LYImageMap;

struct _LYImageMap {
    char * address;
    char * title;
    HTList * elements;
};

typedef struct _TIMEINFO _TIMEINFO, *P_TIMEINFO;

struct _TIMEINFO {
    time_t time;
    long usec;
    long tzone;
};

typedef struct _TIMEINFO TIMEINFO;


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};

typedef struct timezone timezone, *Ptimezone;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef struct HTCharStyle HTCharStyle, *PHTCharStyle;

struct HTCharStyle {
    int color;
    int mono;
    int cattr;
};

typedef struct UC_charset UC_charset, *PUC_charset;

struct UC_charset {
    char * MIMEname;
    char * LYNXname;
    uchar * unicount;
    ushort * unitable;
    int num_uni;
    struct unimapdesc_str replacedesc;
    int uc_status;
    int LYhndl;
    int GN;
    int lowest_eight;
    int enc;
    int codepage;
};

typedef struct _EditFieldData _EditFieldData, *P_EditFieldData;

struct _EditFieldData {
    int sx;
    int sy;
    int dspwdth;
    int strlen;
    int maxlen;
    char pad;
    BOOLEAN hidden;
    BOOLEAN dirty;
    BOOLEAN panon;
    int xpan;
    int pos;
    int margin;
    int current_modifiers;
    int mark;
    char buffer[1024];
    int offset2col[2048];
    int col2offset[2048];
};

typedef uchar LYEditCode;

typedef struct _EditFieldData EditFieldData;

typedef enum RecallType {
    NORECALL=0,
    RECALL_CMD=2,
    RECALL_MAIL=3,
    RECALL_URL=1
} RecallType;

typedef void * iconv_t;

typedef struct Keysym_String_List Keysym_String_List, *PKeysym_String_List;

struct Keysym_String_List {
    char * string;
    int value;
};


// WARNING! conflicting data type names: /DWARF/LYStrings.c/read_keymap_file/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0


// WARNING! conflicting data type names: /DWARF/LYStrings.c/LYmouse_menu/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0

typedef struct HTAssoc HTAssoc, *PHTAssoc;

struct HTAssoc {
    char * name;
    char * value;
};

typedef struct group group, *Pgroup;

struct group {
    char * gr_name;
    char * gr_passwd;
    __gid_t gr_gid;
    char * * gr_mem;
};

typedef struct MailcapEntry MailcapEntry, *PMailcapEntry;

struct MailcapEntry {
    char * contenttype;
    char * command;
    char * testcommand;
    int needsterminal;
    int copiousoutput;
    int needtofree;
    char * label;
    char * printcommand;
    char * nametemplate;
    float quality;
    long maxbytes;
};

typedef struct cmdlist_s cmdlist_s, *Pcmdlist_s;

struct cmdlist_s {
    char * cmd;
    int result;
    struct cmdlist_s * next;
};


// WARNING! conflicting data type names: /DWARF/termios.h/termios - /termios.h/termios

typedef ulong chtype;

typedef struct pdat pdat, *Ppdat;

struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};

typedef struct MEVENT MEVENT, *PMEVENT;

typedef ulong mmask_t;

struct MEVENT {
    short id;
    undefined field_0x2;
    undefined field_0x3;
    int x;
    int y;
    int z;
    mmask_t bstate;
};

typedef struct _win_st _win_st, *P_win_st;

typedef chtype attr_t;

typedef struct ldat ldat, *Pldat;

typedef struct _win_st WINDOW;

typedef struct cchar_t cchar_t, *Pcchar_t;

typedef int wchar_t;

struct cchar_t {
    attr_t attr;
    wchar_t chars[5];
};

struct ldat {
};

struct _win_st {
    short _cury;
    short _curx;
    short _maxy;
    short _maxx;
    short _begy;
    short _begx;
    short _flags;
    undefined field_0xe;
    undefined field_0xf;
    attr_t _attrs;
    chtype _bkgd;
    _Bool _notimeout;
    _Bool _clear;
    _Bool _leaveok;
    _Bool _scroll;
    _Bool _idlok;
    _Bool _idcok;
    _Bool _immed;
    _Bool _sync;
    _Bool _use_keypad;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    int _delay;
    struct ldat * _line;
    short _regtop;
    short _regbottom;
    int _parx;
    int _pary;
    WINDOW * _parent;
    struct pdat _pad;
    short _yoffset;
    undefined field_0x4a;
    undefined field_0x4b;
    struct cchar_t _bkgrnd;
};

typedef struct _HTStructured.conflict1 _HTStructured.conflict1, *P_HTStructured.conflict1;

typedef struct _HTStructured.conflict1 HTStructured.conflict1;

struct _HTStructured.conflict1 {
    HTStructuredClass * isa;
    HTStream * target;
    HTStreamClass targetClass;
    char buffer[201];
    undefined field_0xe9;
    undefined field_0xea;
    undefined field_0xeb;
    int buffer_maxchars;
    char * write_pointer;
    char * line_break[21];
    int cleanness;
    BOOLEAN overflowed;
    BOOLEAN delete_line_break_char[21];
    BOOLEAN preformatted;
    BOOLEAN escape_specials;
    BOOLEAN in_attrval;
    undefined field_0x165;
    undefined field_0x166;
    undefined field_0x167;
    HText * text;
};

typedef struct _HTStructured.conflict _HTStructured.conflict, *P_HTStructured.conflict;

struct _HTStructured.conflict {
    HTStructuredClass * isa;
};

typedef struct _HTStructured.conflict HTStructured.conflict;

typedef struct stat stat, *Pstat;

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    undefined field_0xa;
    undefined field_0xb;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    undefined field_0x2a;
    undefined field_0x2b;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef enum CharUtil_st {
    st_HTML=0,
    st_URL=1,
    st_other=2
} CharUtil_st;

typedef enum canclose_t {
    close_NO=0,
    close_error=1,
    close_valid=2
} canclose_t;

typedef struct anon_struct.conflict10 anon_struct.conflict10, *Panon_struct.conflict10;

struct anon_struct.conflict10 {
    HTParentAnchor0 * parent;
    char * tag;
    HTAnchor * dest;
    HTLinkType * type;
    HTList _add_children_notag;
    HTList _add_sources;
};

typedef struct _DocAddress _DocAddress, *P_DocAddress;

struct _DocAddress {
    char * address;
    struct bstring * post_data;
    char * post_content_type;
    char * bookmark;
    BOOLEAN isHEAD;
    BOOLEAN safe;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct _DocAddress DocAddress;

typedef enum _state {
    S_dollar=2,
    S_dollar_paren=5,
    S_esc=1,
    S_nonascii_text=4,
    S_paren=3,
    S_text=0
} _state;


// WARNING! conflicting data type names: /DWARF/LYCharUtils.c/LYUCFullyTranslateString/_state - /DWARF/LYCharUtils.c/LYEntify/_state

typedef enum _parsing_what {
    P_decimal=3,
    P_hex=2,
    P_named=4,
    P_text=0,
    P_utf8=1
} _parsing_what;

typedef enum comment_state {
    end1=2,
    end2=3,
    start1=0,
    start2=1
} comment_state;

typedef struct parse_args_type parse_args_type, *Pparse_args_type;

typedef struct parse_args_type Config_Type;

struct parse_args_type {
    char * name;
    int type;
    long value;
    char * help_string;
};


// WARNING! conflicting data type names: /DWARF/LYMain.c/restrictions_fun/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0

typedef struct winsize winsize, *Pwinsize;

struct winsize {
    ushort ws_row;
    ushort ws_col;
    ushort ws_xpixel;
    ushort ws_ypixel;
};

typedef struct _HTProtocol _HTProtocol, *P_HTProtocol;

typedef struct _HTProtocol HTProtocol;

struct _HTProtocol {
    char * name;
    int (* load)(char *, HTParentAnchor *, HTFormat, HTStream *);
    HTStream * (* saveStream)(HTParentAnchor *);
};


// WARNING! conflicting data type names: /DWARF/LYMainLoop.c/do_check_goto_URL/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0

typedef enum HTAAMethod {
    METHOD_GET=1,
    METHOD_PUT=2,
    METHOD_UNKNOWN=0
} HTAAMethod;

typedef enum HTAAScheme {
    HTAA_BASIC=2,
    HTAA_KERBEROS_V4=4,
    HTAA_KERBEROS_V5=5,
    HTAA_MAX_SCHEMES=6,
    HTAA_NONE=1,
    HTAA_PUBKEY=3,
    HTAA_UNKNOWN=0
} HTAAScheme;


// WARNING! conflicting data type names: /DWARF/pwd.h/passwd - /pwd.h/passwd


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/__dirstream - /dirent.h/__dirstream

typedef struct HTAAServer HTAAServer, *PHTAAServer;

struct HTAAServer {
    char * hostname;
    int portnumber;
    BOOLEAN IsProxy;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    HTList * setups;
    HTList * realms;
};

typedef struct HTAASetup HTAASetup, *PHTAASetup;

struct HTAASetup {
    struct HTAAServer * server;
    char * ctemplate;
    HTList * valid_schemes;
    HTAssocList * * scheme_specifics;
    BOOLEAN retry;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct HTAARealm HTAARealm, *PHTAARealm;

struct HTAARealm {
    char * realmname;
    char * username;
    char * password;
};

typedef struct trust trust, *Ptrust;

struct trust {
    char * src;
    char * path;
    int type;
    struct trust * next;
};

typedef struct ht_run_info ht_run_info, *Pht_run_info;

struct ht_run_info {
    int byte_len;
    int cell_len;
};

typedef struct PostData PostData, *PPostData;

typedef enum QuoteData {
    NO_QUOTE=0,
    QUOTE_BASE64=2,
    QUOTE_MULTI=1,
    QUOTE_SPECIAL=3
} QuoteData;

struct PostData {
    int type;
    BOOLEAN first;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    char * name;
    char * value;
    struct bstring * data;
    enum QuoteData quote;
};

typedef struct HTTabID HTTabID, *PHTTabID;

struct HTTabID {
    char * name;
    int column;
};

typedef struct agroup agroup, *Pagroup;

struct agroup {
    TextAnchor * anc;
    int prev_anchor_line;
    int anchors_this_line;
    int anchors_this_group;
};

typedef struct unipair_case unipair_case, *Punipair_case;

struct unipair_case {
    ushort upper;
    ushort lower;
};

typedef struct dired_menu dired_menu, *Pdired_menu;

struct dired_menu {
    int cond;
    char * sfx;
    char * link;
    char * rest;
    char * href;
    struct dired_menu * next;
};

typedef enum Conf_Types {
    CONF_ADD_ITEM=11,
    CONF_ADD_STRING=12,
    CONF_ADD_TRUSTED=13,
    CONF_BOOL=1,
    CONF_ENUM=4,
    CONF_ENV=8,
    CONF_ENV2=9,
    CONF_FUN=2,
    CONF_INCLUDE=10,
    CONF_INT=5,
    CONF_NIL=0,
    CONF_PRG=7,
    CONF_STR=6,
    CONF_TIME=3
} Conf_Types;

typedef BOOLEAN optidx_set_t[207];

typedef struct Config_Type.conflict Config_Type.conflict, *PConfig_Type.conflict;

typedef struct Config_Enum Config_Enum, *PConfig_Enum;

struct Config_Enum {
    char * name;
    int value;
};

struct Config_Type.conflict {
    char * name;
    enum Conf_Types type;
    long value;
    struct Config_Enum * table;
};

typedef struct UC_entity_info UC_entity_info, *PUC_entity_info;

struct UC_entity_info {
    char * name;
    ushort code;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct utmp utmp, *Putmp;

typedef struct exit_status exit_status, *Pexit_status;

struct exit_status {
    short e_termination;
    short e_exit;
};

struct utmp {
    short ut_type;
    undefined field_0x2;
    undefined field_0x3;
    pid_t ut_pid;
    char ut_line[32];
    char ut_id[4];
    char ut_user[32];
    char ut_host[256];
    struct exit_status ut_exit;
    long ut_session;
    struct timeval ut_tv;
    int32_t ut_addr_v6[4];
    char __unused[20];
};


// WARNING! conflicting data type names: /DWARF/netdb.h/addrinfo - /netdb.h/addrinfo

typedef struct DIRED DIRED, *PDIRED;

struct DIRED {
    struct stat file_info;
    char sort_tags;
    char file_name[1];
    undefined field_0x62;
    undefined field_0x63;
};

typedef struct _HTSuffix _HTSuffix, *P_HTSuffix;

struct _HTSuffix {
    char * suffix;
    HTAtom * rep;
    HTAtom * encoding;
    char * desc;
    float quality;
};

typedef struct _HTSuffix HTSuffix;

typedef struct term term, *Pterm;

typedef struct term TERMINAL;

typedef struct termtype termtype, *Ptermtype;

typedef struct termtype TERMTYPE;

struct termtype {
    char * term_names;
    char * str_table;
    char * Booleans;
    short * Numbers;
    char * * Strings;
    char * ext_str_table;
    char * * ext_Names;
    ushort num_Booleans;
    ushort num_Numbers;
    ushort num_Strings;
    ushort ext_Booleans;
    ushort ext_Numbers;
    ushort ext_Strings;
};

struct term {
    TERMTYPE type;
    short Filedes;
    undefined field_0x2a;
    undefined field_0x2b;
    struct termios Ottyb;
    struct termios Nttyb;
    int _baudrate;
    char * _termname;
};

typedef enum invcheck_behaviour_t {
    INVCHECK_LOOSE=2,
    INVCHECK_QUERY=0,
    INVCHECK_STRICT=1
} invcheck_behaviour_t;

typedef struct _domain_entry _domain_entry, *P_domain_entry;

typedef struct _domain_entry domain_entry;

typedef enum behaviour_t {
    ACCEPT_ALWAYS=0,
    QUERY_USER=2,
    REJECT_ALWAYS=1
} behaviour_t;

struct _domain_entry {
    char * domain;
    enum behaviour_t bv;
    enum invcheck_behaviour_t invcheck_bv;
    HTList * cookie_list;
};


// WARNING! conflicting data type names: /DWARF/cfg_defs.h/lynx_compile_opts/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0

typedef struct anon_struct_1 anon_struct_1, *Panon_struct_1;

struct anon_struct_1 {
    char * name;
    char * value;
};

typedef struct DocInfo DocInfo, *PDocInfo;

struct DocInfo {
    char * title;
    char * address;
    struct bstring * post_data;
    char * post_content_type;
    char * bookmark;
    BOOLEAN isHEAD;
    BOOLEAN safe;
    undefined field_0x16;
    undefined field_0x17;
    int link;
    int line;
    BOOLEAN internal_link;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    char * style;
};

typedef struct _lynx_list_item_type _lynx_list_item_type, *P_lynx_list_item_type;

struct _lynx_list_item_type {
    struct _lynx_list_item_type * next;
    char * name;
    char * command;
    int always_enabled;
    BOOLEAN override_primary_action;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
    int pagelen;
};

typedef union ParseUnion ParseUnion, *PParseUnion;

typedef struct _lynx_list_item_type lynx_list_item_type;

union ParseUnion {
    lynx_list_item_type * * add_value;
    BOOLEAN * set_value;
    int * int_value;
    char * * str_value;
    int (* fun_value)(char *);
    long def_value;
    HTList * * lst_value;
};

typedef struct _VisitedLink _VisitedLink, *P_VisitedLink;

struct _VisitedLink {
    char * title;
    char * address;
    int level;
    struct _VisitedLink * next_tree;
    struct _VisitedLink * prev_latest;
    struct _VisitedLink * next_latest;
    struct _VisitedLink * prev_first;
};

typedef struct HistInfo HistInfo, *PHistInfo;

struct HistInfo {
    struct DocInfo hdoc;
    int intern_seq_start;
};

typedef struct LinkInfo LinkInfo, *PLinkInfo;

struct LinkInfo {
    char * lname;
    char * target;
    char * l_hightext;
    char * l_hightext2;
    int l_hightext2_offset;
    BOOLEAN inUnderline;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
    int lx;
    int ly;
    int type;
    int sgml_offset;
    int anchor_number;
    int anchor_line_num;
    struct HiliteList list;
    struct _FormInfo * l_form;
};

typedef struct _VisitedLink VisitedLink;

typedef struct OptValues OptValues, *POptValues;

struct OptValues {
    int value;
    char * LongName;
    char * HtmlName;
};

typedef struct PostPair PostPair, *PPostPair;

struct PostPair {
    char * tag;
    char * value;
};

typedef enum HTCJKlang {
    CHINESE=2,
    JAPANESE=1,
    KOREAN=3,
    NOCJK=0,
    TAIPEI=4
} HTCJKlang;

typedef struct config_type config_type, *Pconfig_type;

typedef enum Conf_Types.conflict {
    CONF_ARRAY=1,
    CONF_BOOL=2,
    CONF_ENUM=5,
    CONF_FUN=3,
    CONF_INT=4,
    CONF_LIS=6,
    CONF_MBM=7,
    CONF_NIL=0,
    CONF_STR=8
} Conf_Types.conflict;

struct config_type {
    char * name;
    int enabled;
    enum Conf_Types.conflict type;
    long value;
    char * * strings;
    struct Config_Enum * table;
    void (* write_it)(FILE *, struct config_type *);
    char * note;
};

typedef struct config_type Config_Type.conflict1;

typedef enum LexItem {
    LEX_ALPH_STR=8,
    LEX_AT_SIGN=7,
    LEX_CLOSE_PAREN=6,
    LEX_EOF=1,
    LEX_FIELD_SEP=3,
    LEX_ITEM_SEP=4,
    LEX_NONE=0,
    LEX_OPEN_PAREN=5,
    LEX_REC_SEP=2,
    LEX_TMPL_STR=9
} LexItem;

typedef struct sockaddr_storage SockA;

typedef ushort PortNumber;

typedef HTList AddressDefList;

typedef HTList UserDefList;

typedef struct Ref Ref, *PRef;

struct Ref {
    char * name;
    struct GroupDef * translation;
};

typedef struct Item Item, *PItem;

struct Item {
    UserDefList * user_def_list;
    AddressDefList * address_def_list;
};

typedef struct _cookie _cookie, *P_cookie;

typedef struct _cookie cookie;

struct _cookie {
    char * lynxID;
    char * name;
    char * value;
    int version;
    char * comment;
    char * commentURL;
    char * domain;
    int port;
    char * PortList;
    char * path;
    int pathlen;
    int flags;
    time_t expires;
    BOOLEAN quoted;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
};


// WARNING! conflicting data type names: /DWARF/LYCookie.c/LYConfigCookies/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0


// WARNING! conflicting data type names: /DWARF/LYCookie.c/LYLoadCookies/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0

typedef enum anon_enum_32 {
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    ABMON_1=131086,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ABS_OFF=0,
    ABS_ON=2,
    AFS_URL_TYPE=23,
    ALT_DIGITS=131119,
    AM_STR=131110,
    BIBP_URL_TYPE=17,
    CODESET=14,
    CSO_URL_TYPE=19,
    DATA_URL_TYPE=24,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    DIRS_FIRST=0,
    DSTYLE_ALINK=127,
    DSTYLE_CANDY=131,
    DSTYLE_ELEMENTS=133,
    DSTYLE_LINK=8,
    DSTYLE_NORMAL=128,
    DSTYLE_OPTION=129,
    DSTYLE_STATUS=126,
    DSTYLE_VALUE=130,
    DSTYLE_WHEREIS=132,
    D_FMT=131113,
    D_T_FMT=131112,
    ERA=131116,
    ERA_D_FMT=131118,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    FILES_FIRST=1,
    FILE_URL_TYPE=3,
    FINGER_URL_TYPE=18,
    FLAG_ACCEPT_ALWAYS=0,
    FLAG_FROM_FILE=3,
    FLAG_INVCHECK_LOOSE=6,
    FLAG_INVCHECK_QUERY=4,
    FLAG_INVCHECK_STRICT=5,
    FLAG_QUERY_USER=2,
    FLAG_REJECT_ALWAYS=1,
    FORCE_PROMPT_DFT=0,
    FORCE_PROMPT_NO=2,
    FORCE_PROMPT_YES=1,
    FTP_URL_TYPE=4,
    F_CHECKBOX_TYPE=3,
    F_FILE_TYPE=11,
    F_HIDDEN_TYPE=8,
    F_IMAGE_SUBMIT_TYPE=13,
    F_KEYGEN_TYPE=14,
    F_OPTION_LIST_TYPE=7,
    F_PASSWORD_TYPE=2,
    F_RADIO_TYPE=4,
    F_RANGE_TYPE=10,
    F_RESET_TYPE=6,
    F_SUBMIT_TYPE=5,
    F_TEXTAREA_TYPE=9,
    F_TEXT_SUBMIT_TYPE=12,
    F_TEXT_TYPE=1,
    F_UNKNOWN=0,
    GOPHER_URL_TYPE=12,
    HTML_A=0,
    HTML_ABBR=1,
    HTML_ACRONYM=2,
    HTML_ADDRESS=3,
    HTML_ALT_OBJECT=118,
    HTML_APPLET=4,
    HTML_AREA=5,
    HTML_AU=6,
    HTML_AUTHOR=7,
    HTML_B=8,
    HTML_BANNER=9,
    HTML_BASE=10,
    HTML_BASEFONT=11,
    HTML_BDO=12,
    HTML_BGSOUND=13,
    HTML_BIG=14,
    HTML_BLINK=15,
    HTML_BLOCKQUOTE=16,
    HTML_BODY=17,
    HTML_BODYTEXT=18,
    HTML_BQ=19,
    HTML_BR=20,
    HTML_BUTTON=21,
    HTML_CAPTION=22,
    HTML_CENTER=23,
    HTML_CITE=24,
    HTML_CODE=25,
    HTML_COL=26,
    HTML_COLGROUP=27,
    HTML_COMMENT=28,
    HTML_CREDIT=29,
    HTML_DD=30,
    HTML_DEL=31,
    HTML_DFN=32,
    HTML_DIR=33,
    HTML_DIV=34,
    HTML_DL=35,
    HTML_DLC=36,
    HTML_DT=37,
    HTML_EM=38,
    HTML_EMBED=39,
    HTML_FIELDSET=40,
    HTML_FIG=41,
    HTML_FN=42,
    HTML_FONT=43,
    HTML_FORM=44,
    HTML_FRAME=45,
    HTML_FRAMESET=46,
    HTML_GOPHER_URL_TYPE=13,
    HTML_H1=47,
    HTML_H2=48,
    HTML_H3=49,
    HTML_H4=50,
    HTML_H5=51,
    HTML_H6=52,
    HTML_HEAD=53,
    HTML_HR=54,
    HTML_HTML=55,
    HTML_HY=56,
    HTML_I=57,
    HTML_IFRAME=58,
    HTML_IMG=59,
    HTML_INPUT=60,
    HTML_INS=61,
    HTML_ISINDEX=62,
    HTML_KBD=63,
    HTML_KEYGEN=64,
    HTML_LABEL=65,
    HTML_LEGEND=66,
    HTML_LH=67,
    HTML_LI=68,
    HTML_LINK=69,
    HTML_LISTING=70,
    HTML_MAP=71,
    HTML_MARQUEE=72,
    HTML_MATH=73,
    HTML_MENU=74,
    HTML_META=75,
    HTML_NEXTID=76,
    HTML_NOFRAMES=77,
    HTML_NOTE=78,
    HTML_OBJECT=79,
    HTML_OL=80,
    HTML_OPTION=81,
    HTML_OVERLAY=82,
    HTML_P=83,
    HTML_PARAM=84,
    HTML_PLAINTEXT=85,
    HTML_PRE=86,
    HTML_Q=87,
    HTML_S=88,
    HTML_SAMP=89,
    HTML_SCRIPT=90,
    HTML_SELECT=91,
    HTML_SHY=92,
    HTML_SMALL=93,
    HTML_SPAN=94,
    HTML_SPOT=95,
    HTML_STRIKE=96,
    HTML_STRONG=97,
    HTML_STYLE=98,
    HTML_SUB=99,
    HTML_SUP=100,
    HTML_TAB=101,
    HTML_TABLE=102,
    HTML_TBODY=103,
    HTML_TD=104,
    HTML_TEXTAREA=105,
    HTML_TEXTFLOW=106,
    HTML_TFOOT=107,
    HTML_TH=108,
    HTML_THEAD=109,
    HTML_TITLE=110,
    HTML_TR=111,
    HTML_TT=112,
    HTML_U=113,
    HTML_UL=114,
    HTML_VAR=115,
    HTML_WBR=116,
    HTML_XMP=117,
    HTTPS_URL_TYPE=20,
    HTTP_URL_TYPE=2,
    INDEX_GOPHER_URL_TYPE=15,
    IPPROTO_AH=51,
    IPPROTO_COMP=108,
    IPPROTO_DCCP=33,
    IPPROTO_DSTOPTS=60,
    IPPROTO_EGP=8,
    IPPROTO_ENCAP=98,
    IPPROTO_ESP=50,
    IPPROTO_FRAGMENT=44,
    IPPROTO_GRE=47,
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_ICMPV6=58,
    IPPROTO_IDP=22,
    IPPROTO_IGMP=2,
    IPPROTO_IP=0,
    IPPROTO_IPIP=4,
    IPPROTO_IPV6=41,
    IPPROTO_MAX=256,
    IPPROTO_MTP=92,
    IPPROTO_NONE=59,
    IPPROTO_PIM=103,
    IPPROTO_PUP=12,
    IPPROTO_RAW=255,
    IPPROTO_ROUTING=43,
    IPPROTO_RSVP=46,
    IPPROTO_SCTP=132,
    IPPROTO_TCP=6,
    IPPROTO_TP=29,
    IPPROTO_UDP=17,
    IPPROTO_UDPLITE=136,
    LYE_ABORT=5,
    LYE_AIX=24,
    LYE_BACK=17,
    LYE_BACKW=20,
    LYE_BACK_LL=18,
    LYE_BOL=13,
    LYE_C1CHAR=32,
    LYE_CHAR=1,
    LYE_DELBL=25,
    LYE_DELC=8,
    LYE_DELEL=26,
    LYE_DELN=7,
    LYE_DELNW=10,
    LYE_DELP=9,
    LYE_DELPW=11,
    LYE_ENTER=2,
    LYE_EOL=14,
    LYE_ERASE=12,
    LYE_FORM_PASS=6,
    LYE_FORW=15,
    LYE_FORWW=19,
    LYE_FORW_RL=16,
    LYE_KILLREG=35,
    LYE_LKCMD=23,
    LYE_LOWER=21,
    LYE_NOP=0,
    LYE_PASTE=37,
    LYE_SETM1=29,
    LYE_SETM2=30,
    LYE_SETMARK=33,
    LYE_STOP=4,
    LYE_SWMAP=27,
    LYE_TAB=3,
    LYE_TPOS=28,
    LYE_UNMOD=31,
    LYE_UPPER=22,
    LYE_XPMARK=34,
    LYE_YANK=36,
    LYK_1=2,
    LYK_2=3,
    LYK_3=4,
    LYK_4=5,
    LYK_5=6,
    LYK_6=7,
    LYK_7=8,
    LYK_8=9,
    LYK_9=10,
    LYK_ABORT=14,
    LYK_ACTIVATE=39,
    LYK_ADD_BOOKMARK=58,
    LYK_CHANGE_LINK=84,
    LYK_CHDIR=99,
    LYK_CHG_CENTER=98,
    LYK_CLEAR_AUTH=81,
    LYK_COMMAND=1,
    LYK_COMMENT=54,
    LYK_COOKIE_JAR=79,
    LYK_CREATE=92,
    LYK_DEL_BOOKMARK=59,
    LYK_DIRED_MENU=91,
    LYK_DOWNLOAD=63,
    LYK_DOWN_HALF=20,
    LYK_DOWN_LINK=33,
    LYK_DOWN_TWO=18,
    LYK_DO_NOTHING=69,
    LYK_DWIMEDIT=85,
    LYK_DWIMHELP=44,
    LYK_ECGOTO=42,
    LYK_EDIT=55,
    LYK_EDIT_TEXTAREA=86,
    LYK_ELGOTO=83,
    LYK_END=23,
    LYK_EXTERN_LINK=89,
    LYK_EXTERN_PAGE=90,
    LYK_FASTBACKW_LINK=30,
    LYK_FASTFORW_LINK=31,
    LYK_FIRST_LINK=24,
    LYK_F_LINK_NUM=80,
    LYK_GOTO=41,
    LYK_GROW_TEXTAREA=87,
    LYK_HEAD=68,
    LYK_HELP=43,
    LYK_HISTORICAL=75,
    LYK_HISTORY=36,
    LYK_HOME=22,
    LYK_IMAGE_TOGGLE=66,
    LYK_INDEX=45,
    LYK_INDEX_SEARCH=50,
    LYK_INFO=56,
    LYK_INLINE_TOGGLE=67,
    LYK_INSERT_FILE=88,
    LYK_INSTALL=97,
    LYK_INTERRUPT=47,
    LYK_JUMP=71,
    LYK_KEYMAP=72,
    LYK_LAST_LINK=25,
    LYK_LEFT_LINK=35,
    LYK_LINEWRAP_TOGGLE=102,
    LYK_LIST=73,
    LYK_LPOS_NEXT_LINK=29,
    LYK_LPOS_PREV_LINK=28,
    LYK_MAIN_MENU=48,
    LYK_MINIMAL=76,
    LYK_MODIFY=94,
    LYK_NESTED_TABLES=105,
    LYK_NEXT=53,
    LYK_NEXT_DOC=38,
    LYK_NEXT_LINK=27,
    LYK_NEXT_PAGE=15,
    LYK_NOCACHE=46,
    LYK_OPTIONS=49,
    LYK_PASTE_URL=103,
    LYK_PREV=52,
    LYK_PREV_DOC=37,
    LYK_PREV_LINK=26,
    LYK_PREV_PAGE=16,
    LYK_PRINT=57,
    LYK_QUIT=13,
    LYK_RAW_TOGGLE=78,
    LYK_REFRESH=21,
    LYK_RELOAD=12,
    LYK_REMOVE=93,
    LYK_RIGHT_LINK=34,
    LYK_SHELL=62,
    LYK_SHIFT_LEFT=100,
    LYK_SHIFT_RIGHT=101,
    LYK_SOFT_DQUOTES=77,
    LYK_SOURCE=11,
    LYK_SUBMIT=40,
    LYK_SWITCH_DTD=82,
    LYK_TAG_LINK=95,
    LYK_TOGGLE_HELP=70,
    LYK_TOOLBAR=74,
    LYK_TO_CLIPBOARD=104,
    LYK_TRACE_LOG=65,
    LYK_TRACE_TOGGLE=64,
    LYK_UNKNOWN=0,
    LYK_UPLOAD=96,
    LYK_UP_HALF=19,
    LYK_UP_LINK=32,
    LYK_UP_TWO=17,
    LYK_VIEW_BOOKMARK=60,
    LYK_VLINKS=61,
    LYK_WHEREIS=51,
    LYNXCACHE_URL_TYPE=32,
    LYNXCFG_URL_TYPE=33,
    LYNXCGI_URL_TYPE=25,
    LYNXCOMPILE_OPTS_URL_TYPE=34,
    LYNXCOOKIE_URL_TYPE=35,
    LYNXDIRED_URL_TYPE=36,
    LYNXDOWNLOAD_URL_TYPE=37,
    LYNXEXEC_URL_TYPE=26,
    LYNXHIST_URL_TYPE=38,
    LYNXIMGMAP_URL_TYPE=39,
    LYNXKEYMAP_URL_TYPE=40,
    LYNXMESSAGES_URL_TYPE=41,
    LYNXOPTIONS_URL_TYPE=42,
    LYNXPRINT_URL_TYPE=43,
    LYNXPROG_URL_TYPE=27,
    MAILTO_URL_TYPE=16,
    MBM_ADVANCED=2,
    MBM_OFF=0,
    MBM_STANDARD=1,
    MIXED_STYLE=2,
    MON_1=131098,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    NCFTP_URL_TYPE=5,
    NEWSPOST_URL_TYPE=28,
    NEWSREPLY_URL_TYPE=29,
    NEWS_URL_TYPE=7,
    NNTP_URL_TYPE=8,
    NORECALL=0,
    NOT_A_URL_TYPE=0,
    ORDER_BY_DATE=2,
    ORDER_BY_GROUP=6,
    ORDER_BY_MODE=3,
    ORDER_BY_NAME=0,
    ORDER_BY_SIZE=1,
    ORDER_BY_TYPE=4,
    ORDER_BY_USER=5,
    PM_STR=131111,
    POOL_SIZE=2042,
    PROSPERO_URL_TYPE=22,
    PROXY_URL_TYPE=44,
    RADIXCHAR=65536,
    RECALL_CMD=2,
    RECALL_MAIL=3,
    RECALL_URL=1,
    RLOGIN_URL_TYPE=11,
    SHOW_COLOR_ALWAYS=3,
    SHOW_COLOR_NEVER=0,
    SHOW_COLOR_OFF=1,
    SHOW_COLOR_ON=2,
    SHOW_COLOR_UNKNOWN=-1,
    SNEWSPOST_URL_TYPE=30,
    SNEWSREPLY_URL_TYPE=31,
    SNEWS_URL_TYPE=21,
    STACK_OFF=0,
    STACK_ON=1,
    TELNET_GOPHER_URL_TYPE=14,
    TELNET_URL_TYPE=9,
    THOUSEP=65537,
    TN3270_URL_TYPE=10,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    UIP_ADDRLIST_PAGE=11,
    UIP_CONFIG_DEF=12,
    UIP_DIRED_MENU=8,
    UIP_DOWNLOAD_OPTIONS=1,
    UIP_HISTORY=0,
    UIP_INSTALL=14,
    UIP_LIST_PAGE=4,
    UIP_LYNXCFG=6,
    UIP_OPTIONS_MENU=7,
    UIP_PERMIT_OPTIONS=9,
    UIP_PRINT_OPTIONS=2,
    UIP_SHOWINFO=3,
    UIP_TRACELOG=13,
    UIP_UNKNOWN=-1,
    UIP_UPLOAD_OPTIONS=10,
    UIP_VLINKS=5,
    UNKNOWN_URL_TYPE=1,
    WAIS_URL_TYPE=6,
    _DATE_FMT=131180,
    _ISalnum=8,
    _ISalpha=1024,
    _ISblank=1,
    _IScntrl=2,
    _ISdigit=2048,
    _ISgraph=32768,
    _ISlower=512,
    _ISprint=16384,
    _ISpunct=4,
    _ISspace=8192,
    _ISupper=256,
    _ISxdigit=4096,
    _NL_ADDRESS_CODESET=589836,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_COLLATE_CODESET=196626,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_CTYPE_CLASS=0,
    _NL_CTYPE_CLASS32=5,
    _NL_CTYPE_CLASS_NAMES=10,
    _NL_CTYPE_CLASS_OFFSET=17,
    _NL_CTYPE_CODESET_NAME=14,
    _NL_CTYPE_EXTRA_MAP_1=71,
    _NL_CTYPE_EXTRA_MAP_10=80,
    _NL_CTYPE_EXTRA_MAP_11=81,
    _NL_CTYPE_EXTRA_MAP_12=82,
    _NL_CTYPE_EXTRA_MAP_13=83,
    _NL_CTYPE_EXTRA_MAP_14=84,
    _NL_CTYPE_EXTRA_MAP_2=72,
    _NL_CTYPE_EXTRA_MAP_3=73,
    _NL_CTYPE_EXTRA_MAP_4=74,
    _NL_CTYPE_EXTRA_MAP_5=75,
    _NL_CTYPE_EXTRA_MAP_6=76,
    _NL_CTYPE_EXTRA_MAP_7=77,
    _NL_CTYPE_EXTRA_MAP_8=78,
    _NL_CTYPE_EXTRA_MAP_9=79,
    _NL_CTYPE_GAP1=2,
    _NL_CTYPE_GAP2=4,
    _NL_CTYPE_GAP3=6,
    _NL_CTYPE_GAP4=7,
    _NL_CTYPE_GAP5=8,
    _NL_CTYPE_GAP6=9,
    _NL_CTYPE_INDIGITS0_MB=20,
    _NL_CTYPE_INDIGITS0_WC=31,
    _NL_CTYPE_INDIGITS1_MB=21,
    _NL_CTYPE_INDIGITS1_WC=32,
    _NL_CTYPE_INDIGITS2_MB=22,
    _NL_CTYPE_INDIGITS2_WC=33,
    _NL_CTYPE_INDIGITS3_MB=23,
    _NL_CTYPE_INDIGITS3_WC=34,
    _NL_CTYPE_INDIGITS4_MB=24,
    _NL_CTYPE_INDIGITS4_WC=35,
    _NL_CTYPE_INDIGITS5_MB=25,
    _NL_CTYPE_INDIGITS5_WC=36,
    _NL_CTYPE_INDIGITS6_MB=26,
    _NL_CTYPE_INDIGITS6_WC=37,
    _NL_CTYPE_INDIGITS7_MB=27,
    _NL_CTYPE_INDIGITS7_WC=38,
    _NL_CTYPE_INDIGITS8_MB=28,
    _NL_CTYPE_INDIGITS8_WC=39,
    _NL_CTYPE_INDIGITS9_MB=29,
    _NL_CTYPE_INDIGITS9_WC=40,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _NL_CTYPE_MAP_NAMES=11,
    _NL_CTYPE_MAP_OFFSET=18,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_MB_CUR_MAX=13,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _NL_CTYPE_TOLOWER=3,
    _NL_CTYPE_TOLOWER32=16,
    _NL_CTYPE_TOUPPER=1,
    _NL_CTYPE_TOUPPER32=15,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _NL_CTYPE_WIDTH=12,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MESSAGES_CODESET=327684,
    _NL_MONETARY_CODESET=262189,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_CRNCYSTR=262159,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_NAME_CODESET=524294,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MS=524293,
    _NL_NUM=786449,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_NUM_LC_COLLATE=196627,
    _NL_NUM_LC_CTYPE=85,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_NUM_LC_MONETARY=262190,
    _NL_NUM_LC_NAME=524295,
    _NL_NUM_LC_NUMERIC=65542,
    _NL_NUM_LC_PAPER=458755,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_NUM_LC_TIME=131183,
    _NL_PAPER_CODESET=458754,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_TELEPHONE_CODESET=655364,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_CODESET=131182,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_TIMEZONE=131179,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WABMON_1=131138,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WALT_DIGITS=131170,
    _NL_WAM_STR=131162,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WD_FMT=131165,
    _NL_WD_T_FMT=131164,
    _NL_WERA_D_FMT=131169,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_WERA_YEAR=131168,
    _NL_WMON_1=131150,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WPM_STR=131163,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_W_DATE_FMT=131181,
    __CURRENCY_SYMBOL=262145,
    __DECIMAL_POINT=65536,
    __ERA_YEAR=131117,
    __FRAC_DIGITS=262152,
    __GROUPING=65538,
    __INT_CURR_SYMBOL=262144,
    __INT_FRAC_DIGITS=262151,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_N_SIGN_POSN=262165,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_P_SIGN_POSN=262164,
    __LC_ADDRESS=9,
    __LC_ALL=6,
    __LC_COLLATE=3,
    __LC_CTYPE=0,
    __LC_IDENTIFICATION=12,
    __LC_MEASUREMENT=11,
    __LC_MESSAGES=5,
    __LC_MONETARY=4,
    __LC_NAME=8,
    __LC_NUMERIC=1,
    __LC_PAPER=7,
    __LC_TELEPHONE=10,
    __LC_TIME=2,
    __MON_DECIMAL_POINT=262146,
    __MON_GROUPING=262148,
    __MON_THOUSANDS_SEP=262147,
    __NEGATIVE_SIGN=262150,
    __NOEXPR=327681,
    __NOSTR=327683,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __N_SIGN_POSN=262158,
    __POSITIVE_SIGN=262149,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __P_SIGN_POSN=262157,
    __THOUSANDS_SEP=65537,
    __YESEXPR=327680,
    __YESSTR=327682,
    cftBzip2=3,
    cftCompress=1,
    cftDeflate=4,
    cftGzip=2,
    cftNone=0,
    encodingALL=15,
    encodingBZIP2=8,
    encodingCOMPRESS=4,
    encodingDEFLATE=2,
    encodingGZIP=1,
    encodingNONE=0,
    mediaALL=31,
    mediaCFG=4,
    mediaEXT=2,
    mediaINT=1,
    mediaOpt1=1,
    mediaOpt2=5,
    mediaOpt3=13,
    mediaOpt4=29,
    mediaSYS=16,
    mediaUSR=8,
    ppBZIP2=1,
    ppCHMOD=2,
    ppCOMPRESS=3,
    ppCOPY=4,
    ppCSWING=5,
    ppGZIP=6,
    ppINFLATE=7,
    ppINSTALL=8,
    ppMKDIR=9,
    ppMV=10,
    ppRLOGIN=11,
    ppRM=12,
    ppRMDIR=13,
    ppSETFONT=14,
    ppTAR=15,
    ppTELNET=16,
    ppTN3270=17,
    ppTOUCH=18,
    ppUNCOMPRESS=19,
    ppUNZIP=20,
    ppUUDECODE=21,
    ppUnknown=0,
    ppZCAT=22,
    ppZIP=23,
    pp_Last=24,
    rateBYTES=1,
    rateEtaBYTES=3,
    rateEtaKB=4,
    rateKB=2,
    rateOFF=0,
    st_HTML=0,
    st_URL=1,
    st_other=2
} anon_enum_32;

typedef enum UIP_t {
    UIP_ADDRLIST_PAGE=11,
    UIP_CONFIG_DEF=12,
    UIP_DIRED_MENU=8,
    UIP_DOWNLOAD_OPTIONS=1,
    UIP_HISTORY=0,
    UIP_INSTALL=14,
    UIP_LIST_PAGE=4,
    UIP_LYNXCFG=6,
    UIP_OPTIONS_MENU=7,
    UIP_PERMIT_OPTIONS=9,
    UIP_PRINT_OPTIONS=2,
    UIP_SHOWINFO=3,
    UIP_TRACELOG=13,
    UIP_UNKNOWN=-1,
    UIP_UPLOAD_OPTIONS=10,
    UIP_VLINKS=5
} UIP_t;

typedef enum UrlTypes {
    AFS_URL_TYPE=23,
    BIBP_URL_TYPE=17,
    CSO_URL_TYPE=19,
    DATA_URL_TYPE=24,
    FILE_URL_TYPE=3,
    FINGER_URL_TYPE=18,
    FTP_URL_TYPE=4,
    GOPHER_URL_TYPE=12,
    HTML_GOPHER_URL_TYPE=13,
    HTTPS_URL_TYPE=20,
    HTTP_URL_TYPE=2,
    INDEX_GOPHER_URL_TYPE=15,
    LYNXCACHE_URL_TYPE=32,
    LYNXCFG_URL_TYPE=33,
    LYNXCGI_URL_TYPE=25,
    LYNXCOMPILE_OPTS_URL_TYPE=34,
    LYNXCOOKIE_URL_TYPE=35,
    LYNXDIRED_URL_TYPE=36,
    LYNXDOWNLOAD_URL_TYPE=37,
    LYNXEXEC_URL_TYPE=26,
    LYNXHIST_URL_TYPE=38,
    LYNXIMGMAP_URL_TYPE=39,
    LYNXKEYMAP_URL_TYPE=40,
    LYNXMESSAGES_URL_TYPE=41,
    LYNXOPTIONS_URL_TYPE=42,
    LYNXPRINT_URL_TYPE=43,
    LYNXPROG_URL_TYPE=27,
    MAILTO_URL_TYPE=16,
    NCFTP_URL_TYPE=5,
    NEWSPOST_URL_TYPE=28,
    NEWSREPLY_URL_TYPE=29,
    NEWS_URL_TYPE=7,
    NNTP_URL_TYPE=8,
    NOT_A_URL_TYPE=0,
    PROSPERO_URL_TYPE=22,
    PROXY_URL_TYPE=44,
    RLOGIN_URL_TYPE=11,
    SNEWSPOST_URL_TYPE=30,
    SNEWSREPLY_URL_TYPE=31,
    SNEWS_URL_TYPE=21,
    TELNET_GOPHER_URL_TYPE=14,
    TELNET_URL_TYPE=9,
    TN3270_URL_TYPE=10,
    UNKNOWN_URL_TYPE=1,
    WAIS_URL_TYPE=6
} UrlTypes;

typedef struct _names_pairs _names_pairs, *P_names_pairs;

typedef struct _names_pairs names_pairs;

struct _names_pairs {
    char * fullname;
    char * MIMEname;
};

typedef struct uipage_entry uipage_entry, *Puipage_entry;

struct uipage_entry {
    enum UIP_t type;
    uint flags;
    char * url;
    HTList * alturls;
    char * file;
};

typedef struct _LYTemp _LYTemp, *P_LYTemp;

struct _LYTemp {
    struct _LYTemp * next;
    char * name;
    BOOLEAN outs;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    FILE * file;
};

typedef struct anon_struct.conflict8 anon_struct.conflict8, *Panon_struct.conflict8;

struct anon_struct.conflict8 {
    char * name;
    BOOLEAN * flag;
    BOOLEAN can;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct _LYTemp LY_TEMP;

typedef struct uipage_entry uip_entry;

typedef enum ProgramPaths {
    ppBZIP2=1,
    ppCHMOD=2,
    ppCOMPRESS=3,
    ppCOPY=4,
    ppCSWING=5,
    ppGZIP=6,
    ppINFLATE=7,
    ppINSTALL=8,
    ppMKDIR=9,
    ppMV=10,
    ppRLOGIN=11,
    ppRM=12,
    ppRMDIR=13,
    ppSETFONT=14,
    ppTAR=15,
    ppTELNET=16,
    ppTN3270=17,
    ppTOUCH=18,
    ppUNCOMPRESS=19,
    ppUNZIP=20,
    ppUUDECODE=21,
    ppUnknown=0,
    ppZCAT=22,
    ppZIP=23,
    pp_Last=24
} ProgramPaths;

typedef enum CompressFileType {
    cftBzip2=3,
    cftCompress=1,
    cftDeflate=4,
    cftGzip=2,
    cftNone=0
} CompressFileType;

typedef struct ANY_KEYS ANY_KEYS, *PANY_KEYS;

struct ANY_KEYS {
    int code;
    LYKeymap_t map;
    LYKeymap_t save;
};

typedef struct anon_struct.conflict9 anon_struct.conflict9, *Panon_struct.conflict9;

struct anon_struct.conflict9 {
    int key;
    char * name;
};

typedef struct emap emap, *Pemap;

struct emap {
    char * name;
    int code;
    char * descr;
};


// WARNING! conflicting data type names: /DWARF/LYKeymap.c/pretty_html/lexical_block_0/anon_struct_0 - /DWARF/LYStyle.c/initialise_default_stylesheet/anon_struct_0

typedef long __fd_mask;

typedef struct __sigset_t sigset_t;

typedef struct fd_set fd_set, *Pfd_set;

struct fd_set {
    __fd_mask fds_bits[32];
};

typedef struct _NNTPAuth _NNTPAuth, *P_NNTPAuth;

typedef struct _NNTPAuth NNTPAuth;

struct _NNTPAuth {
    char * host;
    char * user;
    char * pass;
};

typedef enum NNTPAuthResult {
    NNTPAUTH_CLOSE=502,
    NNTPAUTH_ERROR=0,
    NNTPAUTH_OK=281
} NNTPAuthResult;


// WARNING! conflicting data type names: /stdarg.h/__gnuc_va_list - /DWARF/stdarg.h/__gnuc_va_list


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval


// WARNING! conflicting data type names: /time.h/timezone - /DWARF/time.h/timezone

typedef struct timezone * __timezone_ptr_t;


// WARNING! conflicting data type names: /time.h/tm - /DWARF/time.h/tm


// WARNING! conflicting data type names: /sigaction.h/sigaction - /DWARF/sigaction.h/sigaction

typedef union _union_1048 _union_1048, *P_union_1048;


// WARNING! conflicting data type names: /signal.h/__sighandler_t - /DWARF/signal.h/__sighandler_t

union _union_1048 {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};


// WARNING! conflicting data type names: /select.h/sigset_t - /DWARF/select.h/sigset_t


// WARNING! conflicting data type names: /select.h/fd_set - /DWARF/select.h/fd_set


// WARNING! conflicting data type names: /sigset.h/__sigset_t - /DWARF/sigset.h/__sigset_t

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_CHECKSUM=1879048184,
    SHT_DYNAMIC=6,
    SHT_DYNSYM=11,
    SHT_FINI_ARRAY=15,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191,
    SHT_GROUP=17,
    SHT_HASH=5,
    SHT_INIT_ARRAY=14,
    SHT_NOBITS=8,
    SHT_NOTE=7,
    SHT_NULL=0,
    SHT_PREINIT_ARRAY=16,
    SHT_PROGBITS=1,
    SHT_REL=9,
    SHT_RELA=4,
    SHT_SHLIB=10,
    SHT_STRTAB=3,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_syminfo=1879048188,
    SHT_SYMTAB=2,
    SHT_SYMTAB_SHNDX=18
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_AUDIT=1879047932,
    DT_AUXILIARY=2147483645,
    DT_BIND_NOW=24,
    DT_CHECKSUM=1879047672,
    DT_CONFIG=1879047930,
    DT_DEBUG=21,
    DT_DEPAUDIT=1879047931,
    DT_ENCODING=32,
    DT_FEATURE_1=1879047676,
    DT_FILTER=2147483647,
    DT_FINI=13,
    DT_FINI_ARRAY=26,
    DT_FINI_ARRAYSZ=28,
    DT_FLAGS=30,
    DT_FLAGS_1=1879048187,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_HASH=1879047925,
    DT_GNU_LIBLIST=1879047929,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_GNU_PRELINKED=1879047669,
    DT_HASH=4,
    DT_INIT=12,
    DT_INIT_ARRAY=25,
    DT_INIT_ARRAYSZ=27,
    DT_JMPREL=23,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_MOVETAB=1879047934,
    DT_NEEDED=1,
    DT_NULL=0,
    DT_PLTGOT=3,
    DT_PLTPAD=1879047933,
    DT_PLTPADSZ=1879047673,
    DT_PLTREL=20,
    DT_PLTRELSZ=2,
    DT_POSFLAG_1=1879047677,
    DT_PREINIT_ARRAYSZ=33,
    DT_REL=17,
    DT_RELA=7,
    DT_RELACOUNT=1879048185,
    DT_RELAENT=9,
    DT_RELASZ=8,
    DT_RELCOUNT=1879048186,
    DT_RELENT=19,
    DT_RELSZ=18,
    DT_RPATH=15,
    DT_RUNPATH=29,
    DT_SONAME=14,
    DT_STRSZ=10,
    DT_STRTAB=5,
    DT_SYMBOLIC=16,
    DT_SYMENT=11,
    DT_SYMINENT=1879047679,
    DT_SYMINFO=1879047935,
    DT_SYMINSZ=1879047678,
    DT_SYMTAB=6,
    DT_TEXTREL=22,
    DT_TLSDESC_GOT=1879047927,
    DT_TLSDESC_PLT=1879047926,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_VERSYM=1879048176
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_DYNAMIC=2,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_RELRO=1685382482,
    PT_GNU_STACK=1685382481,
    PT_INTERP=3,
    PT_LOAD=1,
    PT_NOTE=4,
    PT_NULL=0,
    PT_PHDR=6,
    PT_SHLIB=5,
    PT_TLS=7
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_pad[9];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};


// WARNING! conflicting data type names: /grp.h/group - /DWARF/grp.h/group




int _init(EVP_PKEY_CTX *ctx)

{
  int iStack12;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return iStack12;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void scrollok(void)

{
  scrollok();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



void ungetmouse(void)

{
  ungetmouse();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigemptyset(sigset_t *__set)

{
  int iVar1;
  
  iVar1 = sigemptyset(__set);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sprintf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sprintf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



void inflateReset(void)

{
  inflateReset();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



void mouseinterval(void)

{
  mouseinterval();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getsockname(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getsockname(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void freeaddrinfo(addrinfo *__ai)

{
  freeaddrinfo(__ai);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void syslog(int __pri,char *__fmt,...)

{
  syslog(__pri,__fmt);
  return;
}



void newwin(void)

{
  newwin();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * bsearch(void *__key,void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = bsearch(__key,__base,__nmemb,__size,__compar);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long random(void)

{
  long lVar1;
  
  lVar1 = random();
  return lVar1;
}



void inflateEnd(void)

{
  inflateEnd();
  return;
}



void waddch(void)

{
  waddch();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int open64(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open64(__file,__oflag);
  return iVar1;
}



void wmove(void)

{
  wmove();
  return;
}



void gzopen64(void)

{
  gzopen64();
  return;
}



void keypad(void)

{
  keypad();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



void echo(void)

{
  echo();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

iconv_t iconv_open(char *__tocode,char *__fromcode)

{
  iconv_t pvVar1;
  
  pvVar1 = iconv_open(__tocode,__fromcode);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int unsetenv(char *__name)

{
  int iVar1;
  
  iVar1 = unsetenv(__name);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __xstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



void endwin(void)

{
  endwin();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

group * getgrnam(char *__name)

{
  group *pgVar1;
  
  pgVar1 = getgrnam(__name);
  return pgVar1;
}



void gzclose(void)

{
  gzclose();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  float10 extraout_ST0;
  
  strtod(__nptr,__endptr);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int system(char *__command)

{
  int iVar1;
  
  iVar1 = system(__command);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ttyname(int __fd)

{
  char *pcVar1;
  
  pcVar1 = ttyname(__fd);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



void doupdate(void)

{
  doupdate();
  return;
}



void resizeterm(void)

{
  resizeterm();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int listen(int __fd,int __n)

{
  int iVar1;
  
  iVar1 = listen(__fd,__n);
  return iVar1;
}



void derwin(void)

{
  derwin();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int toupper(int __c)

{
  int iVar1;
  
  iVar1 = toupper(__c);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int rename(char *__old,char *__new)

{
  int iVar1;
  
  iVar1 = rename(__old,__new);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fopen64(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen64(__filename,__modes);
  return pFVar1;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void _exit(int __status)

{
                    // WARNING: Subroutine does not return
  _exit(__status);
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ctermid(char *__s)

{
  char *pcVar1;
  
  pcVar1 = ctermid(__s);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int chmod(char *__file,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = chmod(__file,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void __assert_fail(char *__assertion,char *__file,uint __line,char *__function)

{
                    // WARNING: Subroutine does not return
  __assert_fail(__assertion,__file,__line,__function);
}



void delwin(void)

{
  delwin();
  return;
}



void werase(void)

{
  werase();
  return;
}



void bindtextdomain(void)

{
  bindtextdomain();
  return;
}



void initscr(void)

{
  initscr();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void perror(char *__s)

{
  perror(__s);
  return;
}



void gettext(void)

{
  gettext();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



void pnoutrefresh(void)

{
  pnoutrefresh();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



void wclrtoeol(void)

{
  wclrtoeol();
  return;
}



void inflate(void)

{
  inflate();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fdopen(int __fd,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fdopen(__fd,__modes);
  return pFVar1;
}



void clearok(void)

{
  clearok();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __lxstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __lxstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void openlog(char *__ident,int __option,int __facility)

{
  openlog(__ident,__option,__facility);
  return;
}



void pair_content(void)

{
  pair_content();
  return;
}



void getmouse(void)

{
  getmouse();
  return;
}



void mousemask(void)

{
  mousemask();
  return;
}



void curses_version(void)

{
  curses_version();
  return;
}



void nonl(void)

{
  nonl();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int truncate64(char *__file,__off64_t __length)

{
  int iVar1;
  
  iVar1 = truncate64(__file,__length);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
  int iVar1;
  
  iVar1 = sigaction(__sig,__act,__oact);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len)

{
  int iVar1;
  
  iVar1 = accept(__fd,__addr,__addr_len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int dup2(int __fd,int __fd2)

{
  int iVar1;
  
  iVar1 = dup2(__fd,__fd2);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



void wtouchln(void)

{
  wtouchln();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)

{
  int iVar1;
  
  iVar1 = getaddrinfo(__name,__service,__req,__pai);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__mode_t umask(__mode_t __mask)

{
  __mode_t _Var1;
  
  _Var1 = umask(__mask);
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t mktime(tm *__tp)

{
  time_t tVar1;
  
  tVar1 = mktime(__tp);
  return tVar1;
}



void wrefresh(void)

{
  wrefresh();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

uint16_t ntohs(uint16_t __netshort)

{
  uint16_t uVar1;
  
  uVar1 = ntohs(__netshort);
  return uVar1;
}



void init_pair(void)

{
  init_pair();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

dirent64 * readdir64(DIR *__dirp)

{
  dirent64 *pdVar1;
  
  pdVar1 = readdir64(__dirp);
  return pdVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int execv(char *__path,char **__argv)

{
  int iVar1;
  
  iVar1 = execv(__path,__argv);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * mkdtemp(char *__template)

{
  char *pcVar1;
  
  pcVar1 = mkdtemp(__template);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t iconv(iconv_t __cd,char **__inbuf,size_t *__inbytesleft,char **__outbuf,
            size_t *__outbytesleft)

{
  size_t sVar1;
  
  sVar1 = iconv(__cd,__inbuf,__inbytesleft,__outbuf,__outbytesleft);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * gai_strerror(int __ecode)

{
  char *pcVar1;
  
  pcVar1 = gai_strerror(__ecode);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)

{
  __pid_t _Var1;
  
  _Var1 = waitpid(__pid,__stat_loc,__options);
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void clearerr(FILE *__stream)

{
  clearerr(__stream);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fgetc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fgetc(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



void cbreak(void)

{
  cbreak();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int bind(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = bind(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long atol(char *__nptr)

{
  long lVar1;
  
  lVar1 = atol(__nptr);
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int atoi(char *__nptr)

{
  int iVar1;
  
  iVar1 = atoi(__nptr);
  return iVar1;
}



void start_color(void)

{
  start_color();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int putenv(char *__string)

{
  int iVar1;
  
  iVar1 = putenv(__string);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double atof(char *__nptr)

{
  float10 extraout_ST0;
  
  atof(__nptr);
  return (double)extraout_ST0;
}



void wresize(void)

{
  wresize();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)

{
  int iVar1;
  
  iVar1 = select(__nfds,__readfds,__writefds,__exceptfds,__timeout);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void srandom(uint __seed)

{
  srandom(__seed);
  return;
}



void gzerror(void)

{
  gzerror();
  return;
}



void wgetch(void)

{
  wgetch();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



void wbkgd(void)

{
  wbkgd();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strncat(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncat(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int remove(char *__filename)

{
  int iVar1;
  
  iVar1 = remove(__filename);
  return iVar1;
}



void newpad(void)

{
  newpad();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int execve(char *__path,char **__argv,char **__envp)

{
  int iVar1;
  
  iVar1 = execve(__path,__argv,__envp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * nl_langinfo(nl_item __item)

{
  char *pcVar1;
  
  pcVar1 = nl_langinfo(__item);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)

{
  int iVar1;
  
  iVar1 = sigprocmask(__how,__set,__oset);
  return iVar1;
}



void has_colors(void)

{
  has_colors();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention yet parameter storage is locked

int iconv_close(iconv_t __cd)

{
  int iVar1;
  
  iVar1 = iconv_close(__cd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int gethostname(char *__name,size_t __len)

{
  int iVar1;
  
  iVar1 = gethostname(__name,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int rmdir(char *__path)

{
  int iVar1;
  
  iVar1 = rmdir(__path);
  return iVar1;
}



void waddnstr(void)

{
  waddnstr();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strtok(char *__s,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strtok(__s,__delim);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

group * getgrgid(__gid_t __gid)

{
  group *pgVar1;
  
  pgVar1 = getgrgid(__gid);
  return pgVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

uint sleep(uint __seconds)

{
  uint uVar1;
  
  uVar1 = sleep(__seconds);
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigaddset(sigset_t *__set,int __signo)

{
  int iVar1;
  
  iVar1 = sigaddset(__set,__signo);
  return iVar1;
}



void wborder(void)

{
  wborder();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



void inflateInit_(void)

{
  inflateInit_();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getnameinfo(sockaddr *__sa,socklen_t __salen,char *__host,socklen_t __hostlen,char *__serv,
               socklen_t __servlen,uint __flags)

{
  int iVar1;
  
  iVar1 = getnameinfo(__sa,__salen,__host,__hostlen,__serv,__servlen,__flags);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



void define_key(void)

{
  define_key();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int vasprintf(char **__ptr,char *__f,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vasprintf(__ptr,__f,__arg);
  return iVar1;
}



void assume_default_colors(void)

{
  assume_default_colors();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t fork(void)

{
  __pid_t _Var1;
  
  _Var1 = fork();
  return _Var1;
}



void textdomain(void)

{
  textdomain();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tcsetattr(int __fd,int __optional_actions,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcsetattr(__fd,__optional_actions,__termios_p);
  return iVar1;
}



void wattr_off(void)

{
  wattr_off();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sscanf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getgroups(int __size,__gid_t *__list)

{
  int iVar1;
  
  iVar1 = getgroups(__size,__list);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



void wnoutrefresh(void)

{
  wnoutrefresh();
  return;
}



void gzread(void)

{
  gzread();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strpbrk(char *__s,char *__accept)

{
  char *pcVar1;
  
  pcVar1 = strpbrk(__s,__accept);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pipe(int *__pipedes)

{
  int iVar1;
  
  iVar1 = pipe(__pipedes);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void closelog(void)

{
  closelog();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
  int iVar1;
  
  iVar1 = kill(__pid,__sig);
  return iVar1;
}



void wclear(void)

{
  wclear();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getpeername(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

hostent * gethostbyname(char *__name)

{
  hostent *phVar1;
  
  phVar1 = gethostbyname(__name);
  return phVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



void nl(void)

{
  nl();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwnam(char *__name)

{
  passwd *ppVar1;
  
  ppVar1 = getpwnam(__name);
  return ppVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tolower(int __c)

{
  int iVar1;
  
  iVar1 = tolower(__c);
  return iVar1;
}



void noecho(void)

{
  noecho();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void wbkgdset(void)

{
  wbkgdset();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = pclose(__stream);
  return iVar1;
}



void napms(void)

{
  napms();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * freopen64(char *__filename,char *__modes,FILE *__stream)

{
  FILE *pFVar1;
  
  pFVar1 = freopen64(__filename,__modes,__stream);
  return pFVar1;
}



void wattr_on(void)

{
  wattr_on();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t geteuid(void)

{
  __uid_t _Var1;
  
  _Var1 = geteuid();
  return _Var1;
}



void _start(void)

{
  __libc_start_main(main);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x0804b48a)
// WARNING: Removing unreachable block (ram,0x0804b490)

void __do_global_dtors_aux(void)

{
  if (completed_6635 == '\0') {
    completed_6635 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0804b4d8)

void frame_dummy(void)

{
  return;
}



void cleanup_sig(int sig)

{
  undefined4 uVar1;
  EVP_PKEY_CTX *local_1c;
  
  signal(1,(__sighandler_t)0x1);
  signal(2,(__sighandler_t)0x1);
  local_1c = (EVP_PKEY_CTX *)0xf;
  signal(0xf,(__sighandler_t)0x1);
  if (traversal != '\0') {
    dump_traversal_history();
  }
  if (sig == 1) {
    cleanup_files();
  }
  else {
    if (dump_output_immediately == '\0') {
      cleanup(local_1c);
    }
    if (sig != 0) {
      uVar1 = gettext("Exiting via interrupt:");
      printf("\n\n%s %d\n\n",uVar1,sig);
      fflush(stdout);
    }
  }
  if (sig == 0) {
    reset_signals();
  }
  else {
    exit_immediately(0);
  }
  return;
}



void cleanup_files(void)

{
  LYCleanupTemp();
  if (lynx_temp_space != (char *)0x0) {
    free(lynx_temp_space);
    lynx_temp_space = (char *)0x0;
  }
  return;
}



void cleanup(EVP_PKEY_CTX *ctx)

{
  signal(1,(__sighandler_t)0x1);
  signal(0xf,(__sighandler_t)0x1);
  signal(2,(__sighandler_t)0x1);
  if (LYCursesON != '\0') {
    LYmove(LYlines + -1,0);
    LYclrtoeol();
    lynx_stop_all_colors();
    LYrefresh();
    stop_curses();
  }
  if (persistent_cookies != '\0') {
    LYStoreCookies(LYCookieSaveFile);
  }
  cleanup_files();
  LYCloseTracelog();
  return;
}



BOOLEAN LYVersionIsRelease(void)

{
  return '\0';
}



char * LYVersionStatus(void)

{
  BOOLEAN BVar1;
  char *local_8;
  
  BVar1 = LYVersionIsRelease();
  if (BVar1 == '\0') {
    local_8 = (char *)gettext("development version");
  }
  else {
    local_8 = (char *)gettext("latest release");
  }
  return local_8;
}



char * LYVersionDate(void)

{
  char temp [12];
  
  LYstrncpy((char *)0x81ab4a8,"14 Dec 2008 16:24:56 -0800",0xb);
  return (char *)&ram0x081ab4a8;
}



void dt_String(FILE *fp,char *label,char *value)

{
  bool bVar1;
  size_t len;
  char *the_value;
  char *the_label;
  int need;
  int have;
  
  the_label = (char *)0x0;
  the_value = (char *)0x0;
  HTSACopy(&the_label,label);
  HTSACopy(&the_value,value);
  len = strlen(the_label);
  need = LYstrExtent(the_label,len,label_columns);
  LYEntify(&the_label,'\x01');
  LYEntify(&the_value,'\x01');
  fwrite(&DAT_081498b0,1,4,(FILE *)fp);
  while (bVar1 = need < label_columns, need = need + 1, bVar1) {
    fwrite("&nbsp;",1,6,(FILE *)fp);
  }
  fprintf((FILE *)fp,"<em>%s</em> %s\n",the_label,the_value);
  if (the_label != (char *)0x0) {
    free(the_label);
    the_label = (char *)0x0;
  }
  if (the_value != (char *)0x0) {
    free(the_value);
  }
  return;
}



void dt_Number(FILE *fp0,char *label,long number,char *units)

{
  char *value;
  
  value = (char *)0x0;
  HTSprintf(&value,"%ld %s",number,units);
  dt_String(fp0,label,value);
  if (value != (char *)0x0) {
    free(value);
  }
  return;
}



int LYShowInfo(DocInfo *doc,DocInfo *newdoc,char *owner_address)

{
  long number;
  char tempfile [256];
  BOOLEAN BVar1;
  UrlTypes UVar2;
  char *local_544;
  size_t sVar3;
  char *local_54c;
  undefined4 uVar4;
  int number_00;
  int *piVar5;
  FILE *local_550;
  ssize_t sVar6;
  int in_GS_OFFSET;
  bool bVar7;
  size_t local_554;
  int local_53c;
  char *local_534;
  char *local_530;
  char *local_52c;
  int local_528;
  char *local_524;
  char *local_520;
  char *local_51c;
  char *local_518;
  char *local_514;
  char *local_510;
  char *local_50c;
  stat dir_info;
  char *enctype;
  int method;
  LYUCcharset *p_in;
  int buf_size;
  int next_to_last;
  char *last_slash;
  char *name;
  char *temp;
  char *cp;
  char *Title;
  FILE *fp0;
  int url_type;
  BOOLEAN LYInfoAdvanced;
  char buf [1024];
  char modes [80];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  Title = (char *)0x0;
  temp = (char *)0x0;
  bVar7 = user_mode == 2;
  if (LYReuseTempfiles == '\0') {
    LYRemoveTemp((char *)0x8194360);
    fp0 = LYOpenTemp((char *)0x8194360,".html","w");
  }
  else {
    fp0 = LYOpenTempRewrite((char *)&ram0x08194360,".html","w");
  }
  if (fp0 == (FILE *)0x0) {
    local_544 = (char *)gettext("Can\'t open temporary file!");
    HTAlert(local_544);
    local_53c = -1;
  }
  else {
    LYLocalFileToURL(&newdoc->address,(char *)0x8194360);
    if ((((0 < nlinks) && (links[doc->link].lname != (char *)0x0)) &&
        (UVar2 = is_url(links[doc->link].lname), UVar2 != NOT_A_URL_TYPE)) &&
       ((UVar2 == LYNXEXEC_URL_TYPE || (UVar2 == LYNXPROG_URL_TYPE)))) {
      local_544 = strrchr(links[doc->link].lname,0x2f);
      sVar3 = strlen(links[doc->link].lname);
      if (local_544 + -(int)links[doc->link].lname == (char *)(sVar3 - 1)) {
        ((char *)(sVar3 - 1))[(int)links[doc->link].lname] = '\0';
      }
    }
    label_columns = 9;
    local_544 = (char *)gettext("Information about the current document");
    WriteInternalTitle(fp0,local_544);
    local_544 = LYVersionStatus();
    BVar1 = LYVersionIsRelease();
    if (BVar1 == '\0') {
      local_534 = "http://lynx.isc.org/current/";
    }
    else {
      local_534 = "http://lynx.isc.org/";
    }
    local_54c = LYVersionDate();
    fprintf((FILE *)fp0,"<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",&DAT_0814995d,"2.8.7dev.11",
            local_54c,local_534,local_544);
    local_550 = fp0;
    fwrite("</h1>\n",1,6,(FILE *)fp0);
    if ((lynx_edit_mode == '\0') || (nlinks < 1)) {
      uVar4 = gettext("File that you are currently viewing");
      fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4,local_550,local_54c,local_534,local_544)
      ;
      LYformTitle(&Title,doc->title);
      if ((doc->isHEAD == '\0') ||
         ((local_544 = strstr(Title," (HEAD)"), local_544 != (char *)0x0 ||
          (local_544 = strstr(Title," - HEAD"), local_544 != (char *)0x0)))) {
        local_530 = "";
      }
      else {
        local_530 = " (HEAD)";
      }
      HTSprintf(&temp,"%s%s",Title,local_530);
      local_544 = temp;
      local_54c = (char *)gettext("Linkname:");
      dt_String(fp0,local_54c,local_544);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      dt_String(fp0,"URL:",doc->address);
      local_544 = HTLoadedDocumentCharset();
      if (local_544 == (char *)0x0) {
        p_in = HTAnchor_getUCInfoStage(HTMainAnchor,1);
        if ((((p_in == (LYUCcharset *)0x0) || (p_in->MIMEname == (char *)0x0)) ||
            (*p_in->MIMEname == '\0')) ||
           (number_00 = HTAnchor_getUCLYhndl(HTMainAnchor,1), number_00 < 0)) {
          p_in = HTAnchor_getUCInfoStage(HTMainAnchor,0);
        }
        if (((p_in != (LYUCcharset *)0x0) && (p_in->MIMEname != (char *)0x0)) &&
           ((*p_in->MIMEname != '\0' &&
            (number_00 = HTAnchor_getUCLYhndl(HTMainAnchor,0), -1 < number_00)))) {
          uVar4 = gettext("(assumed)");
          HTSprintf(&temp,"%s %s",p_in->MIMEname,uVar4);
          local_544 = p_in->MIMEname;
          local_54c = (char *)gettext("Charset:");
          dt_String(fp0,local_54c,local_544);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
      }
      else {
        local_544 = HTLoadedDocumentCharset();
        local_54c = (char *)gettext("Charset:");
        dt_String(fp0,local_54c,local_544);
      }
      local_544 = HText_getServer();
      if ((local_544 != (char *)0x0) && (*local_544 != '\0')) {
        local_54c = (char *)gettext("Server:");
        dt_String(fp0,local_54c,local_544);
      }
      local_544 = HText_getDate();
      if ((local_544 != (char *)0x0) && (*local_544 != '\0')) {
        local_54c = (char *)gettext("Date:");
        dt_String(fp0,local_54c,local_544);
      }
      local_544 = HText_getLastModified();
      if ((local_544 != (char *)0x0) && (*local_544 != '\0')) {
        local_54c = (char *)gettext("Last Mod:");
        dt_String(fp0,local_54c,local_544);
      }
      if (bVar7) {
        if ((HTMainAnchor != (HTParentAnchor *)0x0) && (HTMainAnchor->expires != (char *)0x0)) {
          local_544 = HTMainAnchor->expires;
          local_54c = (char *)gettext("Expires:");
          dt_String(fp0,local_54c,local_544);
        }
        if ((HTMainAnchor != (HTParentAnchor *)0x0) && (HTMainAnchor->cache_control != (char *)0x0))
        {
          local_544 = HTMainAnchor->cache_control;
          local_54c = (char *)gettext("Cache-Control:");
          dt_String(fp0,local_54c,local_544);
        }
        if ((HTMainAnchor == (HTParentAnchor *)0x0) || (HTMainAnchor->content_length < 1)) {
          local_544 = (char *)gettext("bytes");
          number_00 = HText_getNumOfBytes();
          local_54c = (char *)gettext("Length:");
          dt_Number(fp0,local_54c,number_00,local_544);
        }
        else {
          local_544 = (char *)gettext("bytes");
          number = HTMainAnchor->content_length;
          local_54c = (char *)gettext("Content-Length:");
          dt_Number(fp0,local_54c,number,local_544);
        }
        if ((HTMainAnchor != (HTParentAnchor *)0x0) &&
           (HTMainAnchor->content_language != (char *)0x0)) {
          local_544 = HTMainAnchor->content_language;
          local_54c = (char *)gettext("Language:");
          dt_String(fp0,local_54c,local_544);
        }
      }
      if (doc->post_data != (bstring *)0x0) {
        if (doc->post_data == (bstring *)0x0) {
          local_52c = (char *)0x0;
        }
        else {
          local_52c = doc->post_data->str;
        }
        if (doc->post_data == (bstring *)0x0) {
          local_528 = 0;
        }
        else {
          local_528 = doc->post_data->len;
        }
        uVar4 = gettext("Post Data:");
        fprintf((FILE *)fp0,"<dt><em>%s</em> <xmp>%.*s</xmp>\n",uVar4,local_528,local_52c);
        local_544 = doc->post_content_type;
        local_54c = (char *)gettext("Post Content Type:");
        dt_String(fp0,local_54c,local_544);
      }
      if (owner_address == (char *)0x0) {
        local_524 = (char *)gettext(&DAT_08149cc4);
      }
      else {
        local_524 = owner_address;
      }
      local_544 = (char *)gettext("Owner(s):");
      dt_String(fp0,local_544,local_524);
      local_544 = (char *)gettext("lines");
      number_00 = HText_getNumOfLines();
      local_54c = (char *)gettext("size:");
      dt_Number(fp0,local_54c,number_00,local_544);
      if (lynx_mode == '\x02') {
        local_520 = (char *)gettext("forms mode");
      }
      else {
        number_00 = HTisDocumentSource();
        if (number_00 == 0) {
          local_51c = (char *)gettext("normal");
        }
        else {
          local_51c = (char *)gettext("source");
        }
        local_520 = local_51c;
      }
      HTSACopy(&temp,local_520);
      if (doc->safe != '\0') {
        local_544 = (char *)gettext(", safe");
        HTSACat(&temp,local_544);
      }
      if (doc->internal_link != '\0') {
        local_544 = (char *)gettext(", via internal link");
        HTSACat(&temp,local_544);
      }
      if (bVar7) {
        BVar1 = HText_hasNoCacheSet(HTMainText);
        if (BVar1 != '\0') {
          local_544 = (char *)gettext(", no-cache");
          HTSACat(&temp,local_544);
        }
        BVar1 = HTAnchor_isISMAPScript((HTAnchor *)HTMainAnchor);
        if (BVar1 != '\0') {
          local_544 = (char *)gettext(", ISMAP script");
          HTSACat(&temp,local_544);
        }
        if (doc->bookmark != (char *)0x0) {
          local_544 = (char *)gettext(", bookmark file");
          HTSACat(&temp,local_544);
        }
      }
      local_544 = temp;
      local_54c = (char *)gettext("mode:");
      dt_String(fp0,local_54c,local_544);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      if (nlinks < 1) {
        uVar4 = gettext("No Links on the current page");
        fprintf((FILE *)fp0,"<h2>%s</h2>",uVar4);
      }
      else {
        uVar4 = gettext("Link that you currently have selected");
        fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4);
        local_544 = LYGetHiliteStr(doc->link,0);
        local_54c = (char *)gettext("Linkname:");
        dt_String(fp0,local_54c,local_544);
        if ((lynx_mode == '\x02') && (links[doc->link].type == 1)) {
          if ((links[doc->link].l_form)->submit_method != 0) {
            number_00 = (links[doc->link].l_form)->submit_method;
            local_510 = (links[doc->link].l_form)->submit_enctype;
            if (number_00 == 2) {
              local_518 = "POST";
            }
            else {
              if (number_00 == 3) {
                local_514 = "(email)";
              }
              else {
                local_514 = "GET";
              }
              local_518 = local_514;
            }
            local_544 = (char *)gettext("Method:");
            dt_String(fp0,local_544,local_518);
            if ((local_510 == (char *)0x0) || (*local_510 == '\0')) {
              local_510 = "application/x-www-form-urlencoded";
            }
            local_544 = (char *)gettext("Enctype:");
            dt_String(fp0,local_544,local_510);
          }
          if ((links[doc->link].l_form)->submit_action != (char *)0x0) {
            local_544 = (links[doc->link].l_form)->submit_action;
            local_54c = (char *)gettext("Action:");
            dt_String(fp0,local_54c,local_544);
          }
          if (((links[doc->link].l_form)->submit_method == 0) ||
             ((links[doc->link].l_form)->submit_action == (char *)0x0)) {
            uVar4 = gettext("(Form field)");
            fprintf((FILE *)fp0,"<dt>&nbsp;%s\n",uVar4);
          }
        }
        else {
          if (links[doc->link].lname == (char *)0x0) {
            local_50c = "";
          }
          else {
            local_50c = links[doc->link].lname;
          }
          dt_String(fp0,"URL:",local_50c);
        }
        fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      }
    }
    else {
      uVar4 = gettext("Directory that you are currently viewing");
      fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4,local_550,local_54c,local_534,local_544)
      ;
      local_544 = HTnameOfFile_WWW(doc->address,'\0','\x01');
      temp = local_544;
      local_54c = (char *)gettext("Name:");
      dt_String(fp0,local_54c,local_544);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      local_544 = doc->address;
      local_54c = (char *)gettext(&DAT_081499d8);
      dt_String(fp0,local_54c,local_544);
      fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      temp = HTnameOfFile_WWW(links[doc->link].lname,'\0','\x01');
      number_00 = lstat64(temp,(stat64 *)&dir_info);
      if (number_00 == -1) {
        if (WWW_TraceFlag != '\0') {
          piVar5 = __errno_location();
          local_544 = temp;
          number_00 = *piVar5;
          local_550 = TraceFP();
          fprintf((FILE *)local_550,"lstat(%s) failed, errno=%d\n",local_544,number_00);
        }
        local_544 = (char *)gettext("Failed to obtain status of current link!");
        HTAlert(local_544);
      }
      else {
        label_columns = 0x10;
        if ((dir_info.st_mode & 0xf000) == 0x4000) {
          uVar4 = gettext("Directory that you have currently selected");
          fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4);
        }
        else {
          if ((dir_info.st_mode & 0xf000) == 0x8000) {
            uVar4 = gettext("File that you have currently selected");
            fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4);
          }
          else {
            if ((dir_info.st_mode & 0xf000) == 0xa000) {
              uVar4 = gettext("Symbolic link that you have currently selected");
              fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4);
            }
            else {
              uVar4 = gettext("Item that you have currently selected");
              fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4);
            }
          }
        }
        local_544 = temp;
        local_54c = (char *)gettext("Full name:");
        dt_String(fp0,local_54c,local_544);
        if ((dir_info.st_mode & 0xf000) == 0xa000) {
          sVar6 = readlink(temp,buf,0x3ff);
          if (sVar6 == -1) {
            uVar4 = gettext("Unable to follow link");
            sprintf(buf,"%.*s",0x3ff,uVar4);
          }
          else {
            buf[sVar6] = '\0';
          }
          local_544 = (char *)gettext("Points to file:");
          dt_String(fp0,local_544,buf);
        }
        local_544 = HTAA_UidToName(dir_info.st_uid);
        if (*local_544 != '\0') {
          local_54c = (char *)gettext("Name of owner:");
          dt_String(fp0,local_54c,local_544);
        }
        local_544 = HTAA_GidToName(dir_info.st_gid);
        if (*local_544 != '\0') {
          local_54c = (char *)gettext("Group name:");
          dt_String(fp0,local_54c,local_544);
        }
        if ((dir_info.st_mode & 0xf000) == 0x8000) {
          local_544 = (char *)gettext("(bytes)");
          local_54c = (char *)gettext("File size:");
          dt_Number(fp0,local_54c,(long)dir_info.st_size,local_544);
        }
        local_544 = ctime((time_t *)&dir_info.st_ctim);
        local_54c = (char *)gettext("Creation date:");
        dt_String(fp0,local_54c,local_544);
        local_544 = ctime((time_t *)&dir_info.st_mtim);
        local_54c = (char *)gettext("Last modified:");
        dt_String(fp0,local_54c,local_544);
        local_544 = ctime((time_t *)&dir_info.st_atim);
        local_54c = (char *)gettext("Last accessed:");
        dt_String(fp0,local_54c,local_544);
        fwrite("\n</dl>\n",1,7,(FILE *)fp0);
        label_columns = 9;
        uVar4 = gettext("Access Permissions");
        fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar4);
        modes[0] = '\0';
        modes[1] = '\0';
        modes[2] = '\0';
        if ((dir_info.st_mode & 0x100) != 0) {
          local_554 = 7;
          local_544 = ", read";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,local_544,local_554);
        }
        if ((dir_info.st_mode & 0x80) != 0) {
          local_554 = 8;
          local_544 = ", write";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,local_544,local_554);
        }
        if ((dir_info.st_mode & 0x40) != 0) {
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            local_554 = 9;
            local_544 = ", search";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,local_544,local_554);
          }
          else {
            local_554 = 10;
            local_544 = ", execute";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,local_544,local_554);
            if ((dir_info.st_mode & 0x800) != 0) {
              local_554 = 9;
              local_544 = ", setuid";
              sVar3 = strlen(modes);
              memcpy(modes + sVar3,local_544,local_554);
            }
          }
        }
        local_544 = (char *)gettext("Owner:");
        dt_String(fp0,local_544,modes + 2);
        modes[0] = '\0';
        modes[1] = '\0';
        modes[2] = '\0';
        if ((dir_info.st_mode & 0x20) != 0) {
          local_554 = 7;
          local_544 = ", read";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,local_544,local_554);
        }
        if ((dir_info.st_mode & 0x10) != 0) {
          local_554 = 8;
          local_544 = ", write";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,local_544,local_554);
        }
        if ((dir_info.st_mode & 8) != 0) {
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            local_554 = 9;
            local_544 = ", search";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,local_544,local_554);
          }
          else {
            local_554 = 10;
            local_544 = ", execute";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,local_544,local_554);
            if ((dir_info.st_mode & 0x400) != 0) {
              local_554 = 9;
              local_544 = ", setgid";
              sVar3 = strlen(modes);
              memcpy(modes + sVar3,local_544,local_554);
            }
          }
        }
        local_544 = (char *)gettext("Group:");
        dt_String(fp0,local_544,modes + 2);
        modes[0] = '\0';
        modes[1] = '\0';
        modes[2] = '\0';
        if ((dir_info.st_mode & 4) != 0) {
          local_554 = 7;
          local_544 = ", read";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,local_544,local_554);
        }
        if ((dir_info.st_mode & 2) != 0) {
          local_554 = 8;
          local_544 = ", write";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,local_544,local_554);
        }
        if ((dir_info.st_mode & 1) != 0) {
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            local_554 = 9;
            local_544 = ", search";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,local_544,local_554);
          }
          else {
            local_554 = 10;
            local_544 = ", execute";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,local_544,local_554);
            if ((dir_info.st_mode & 0x200) != 0) {
              local_554 = 9;
              local_544 = ", sticky";
              sVar3 = strlen(modes);
              memcpy(modes + sVar3,local_544,local_554);
            }
          }
        }
        local_544 = (char *)gettext("World:");
        dt_String(fp0,local_544,modes + 2);
        fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
    }
    EndInternalPage(fp0);
    LYrefresh();
    LYCloseTemp((char *)0x8194360);
    if (Title != (char *)0x0) {
      free(Title);
      Title = (char *)0x0;
    }
    local_53c = 0;
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_53c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



BOOLEAN editor_can_position(void)

{
  char *table [11];
  char *pcVar1;
  int iVar2;
  BOOLEAN local_19;
  char *local_18;
  uint n;
  HTList *p;
  char *value;
  
  p = positionable_editor;
  n = 0;
  while (n < 0xb) {
    pcVar1 = strstr(editor,((char **)&ram0x08194460)[n]);
    if (pcVar1 != (char *)0x0) {
      return '\x01';
    }
    n = n + 1;
  }
  if (positionable_editor == (HTList *)0x0) {
LAB_0804d133:
    local_19 = '\0';
  }
  else {
    do {
      if ((p == (HTList *)0x0) || (p = p->next, p == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)p->object;
      }
      if (local_18 == (char *)0x0) goto LAB_0804d133;
      iVar2 = strcmp(editor,local_18);
    } while (iVar2 != 0);
    local_19 = '\x01';
  }
  return local_19;
}



int edit_current_file(char *newfile,int cur,int lineno)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  char *Msg;
  int iVar3;
  char *Msg_00;
  int in_GS_OFFSET;
  int local_80;
  int local_7c;
  char *number_sign;
  char *colon;
  char *filename;
  int result;
  char position [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = 0;
  filename = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"edit_current_file(newfile=%s, cur=%d, lineno=%d)\n",newfile,cur,lineno
           );
  }
  BVar2 = LYisLocalFile(newfile);
  if (BVar2 == '\0') {
    Msg = (char *)gettext("Lynx cannot currently (e)dit remote WWW files.");
    HTUserMsg(Msg);
    local_80 = 0;
    goto LAB_0804d388;
  }
  Msg = trimPoundSelector(newfile);
  iVar3 = strncmp(newfile,"file://localhost/",0x10);
  if (iVar3 == 0) {
    colon = newfile + 0x10;
  }
  else {
    colon = strchr(newfile,0x3a);
  }
  HTSACopy(&filename,colon + 1);
  HTUnEscape(filename);
  BVar2 = LYCanReadFile(filename);
  if (BVar2 == '\0') {
    if (filename != (char *)0x0) {
      free(filename);
      filename = (char *)0x0;
    }
    filename = HTParse(newfile,"",5);
    HTUnEscape(filename);
    BVar2 = LYCanReadFile(filename);
    if (BVar2 != '\0') goto LAB_0804d2b4;
    Msg_00 = (char *)gettext("Could not access file.");
    HTAlert(Msg_00);
  }
  else {
LAB_0804d2b4:
    if (cur < 0) {
      cur = 0;
    }
    position[0] = '\0';
    if (nlinks == 0) {
      local_7c = 0;
    }
    else {
      local_7c = links[cur].ly;
    }
    if (0 < lineno + local_7c) {
      sprintf(position,"%d",lineno + local_7c);
    }
    edit_temporary_file(filename,position,(char *)0x0);
    result = 1;
  }
  if (Msg != (char *)0x0) {
    *Msg = '#';
  }
  if (filename != (char *)0x0) {
    free(filename);
    filename = (char *)0x0;
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"edit_current_file returns %d\n",result);
  }
  local_80 = result;
LAB_0804d388:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_80;
}



void edit_temporary_file(char *filename,char *position,char *message)

{
  int iVar1;
  BOOLEAN BVar2;
  char *Msg;
  FILE *__stream;
  int *piVar3;
  uint uVar4;
  char *Msg2;
  int __errnum;
  int in_GS_OFFSET;
  char *local_f8;
  stat stat_info;
  anon_union_for___u __u_3;
  anon_union_for___u __u_2;
  anon_union_for___u __u_1;
  anon_union_for___u __u;
  int save_err;
  int rv;
  int params;
  char *editor_arg;
  char *command;
  char *format;
  char exitcode [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  command = (char *)0x0;
  editor_arg = "";
  Msg = strstr(editor,"pico");
  if (Msg != (char *)0x0) {
    editor_arg = " -t";
  }
  BVar2 = editor_can_position();
  if ((BVar2 == '\0') || (*position == '\0')) {
    HTAddXpand(&command,"%s %s",1,editor);
    HTAddParam(&command,"%s %s",2,filename);
    HTEndParam(&command,"%s %s",3);
  }
  else {
    HTAddXpand(&command,"%s +%s%s %s",1,editor);
    HTAddParam(&command,"%s +%s%s %s",2,position);
    HTAddParam(&command,"%s +%s%s %s",3,editor_arg);
    HTAddParam(&command,"%s +%s%s %s",4,filename);
    HTEndParam(&command,"%s +%s%s %s",5);
  }
  if (message != (char *)0x0) {
    mustshow = '\x01';
    statusline(message);
  }
  Msg = command;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYEdit: %s\n",Msg);
  }
  if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
    sleep(MessageSecs);
  }
  stop_curses();
  piVar3 = __errno_location();
  *piVar3 = 0;
  uVar4 = LYSystem(command);
  if (uVar4 == 0) {
    start_curses();
  }
  else {
    start_curses();
    piVar3 = __errno_location();
    __errnum = *piVar3;
    if (WWW_TraceFlag != '\0') {
      if (__errnum == 0) {
        local_f8 = "reason unknown";
      }
      else {
        local_f8 = strerror(__errnum);
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"ExtEditForm: system() returned %d (0x%x), %s\n",uVar4,uVar4,local_f8
             );
    }
    LYFixCursesOn("show error warning:");
    if (uVar4 == 0xffffffff) {
      Msg = strerror(__errnum);
      Msg2 = (char *)gettext("Error starting editor, %s");
      HTUserMsg2(Msg2,Msg);
    }
    else {
      if ((char)(((byte)uVar4 & 0x7f) + 1) >> 1 < '\x01') {
        if (((uVar4 & 0x7f) == 0) && ((int)(uVar4 & 0xff00) >> 8 != 0x7f)) {
          sprintf(exitcode,"%d",(int)(uVar4 & 0xff00) >> 8);
          Msg = (char *)gettext("Editor returned with error status %s");
          HTUserMsg2(Msg,exitcode);
        }
        else {
          Msg = (char *)gettext(
                               "Error spawning editor, check your editor definition in the options menu"
                               );
          HTAlwaysAlert((char *)0x0,Msg);
        }
      }
      else {
        Msg = (char *)gettext("Editor killed by signal");
        HTAlwaysAlert((char *)0x0,Msg);
      }
    }
  }
  HTSprintf0(&command,"%s~",filename);
  __errnum = stat64(command,(stat64 *)&stat_info);
  if (__errnum == 0) {
    remove(command);
  }
  if (command != (char *)0x0) {
    free(command);
    command = (char *)0x0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int peek_mouse_levent(void)

{
  bool bVar1;
  uint local_8;
  
  bVar1 = 0 < have_levent;
  if (bVar1) {
    ungetmouse(&levent);
    have_levent = have_levent + -1;
  }
  local_8 = (uint)bVar1;
  return local_8;
}



int get_mouse_link(void)

{
  int t;
  
  t = mouse_link;
  if (mouse_link < 0) {
    t = -1;
  }
  mouse_link = -1;
  return t;
}



int peek_mouse_link(void)

{
  return mouse_link;
}



int fancy_mouse(WINDOW *win,int row,int *position)

{
  int local_60;
  int local_58;
  int local_50;
  int local_4c;
  int local_40;
  int local_3c;
  int local_34;
  int local_2c;
  int local_28;
  MEVENT event;
  int delta;
  int mypos;
  int cmd;
  
  getmouse(&event);
  if ((event.bstate & 0x1c) == 0) {
    if ((event.bstate & 0x1c000) == 0) {
      return 0x45;
    }
    return 0xd;
  }
  if (win == (WINDOW *)0x0) {
    local_60 = -1;
  }
  else {
    local_60 = (int)win->_begy;
  }
  event.y = event.y - local_60;
  row = event.y - row;
  if (win == (WINDOW *)0x0) {
    local_58 = -1;
  }
  else {
    local_58 = (int)win->_begx;
  }
  if (local_58 <= event.x) {
    if (win == (WINDOW *)0x0) {
      local_50 = -1;
      local_4c = -1;
    }
    else {
      local_50 = (int)win->_begx;
      local_4c = (int)win->_maxx + 1;
    }
    if (event.x < local_50 + local_4c) goto LAB_0804d90f;
  }
  if ((event.bstate & 0x7000000) == 0) {
    return 0xd;
  }
LAB_0804d90f:
  if (win == (WINDOW *)0x0) {
    local_40 = -1;
  }
  else {
    local_40 = (int)win->_maxy + 1;
  }
  if (event.y + 1 == local_40) {
    if ((event.bstate & 0x10) == 0) {
      if ((event.bstate & 8) == 0) {
        cmd = 0x1b;
      }
      else {
        cmd = 0xf;
      }
    }
    else {
      cmd = 0x17;
    }
  }
  else {
    if (win == (WINDOW *)0x0) {
      local_3c = -1;
    }
    else {
      local_3c = (int)win->_maxy + 1;
    }
    if (event.y < local_3c) {
      if (event.y == 0) {
        if ((event.bstate & 0x10) == 0) {
          if ((event.bstate & 8) == 0) {
            cmd = 0x1a;
          }
          else {
            cmd = 0x10;
          }
        }
        else {
          cmd = 0x16;
        }
      }
      else {
        if (event.y < 0) {
          if ((event.bstate & 0x18) == 0) {
            cmd = 0x10;
          }
          else {
            cmd = 0x16;
          }
        }
        else {
          if (win == (WINDOW *)0x0) {
            local_34 = 0;
          }
          else {
            local_34 = (int)win->_begx + 1;
          }
          if (local_34 < event.x) {
            if (win == (WINDOW *)0x0) {
              local_2c = -1;
              local_28 = -1;
            }
            else {
              local_2c = (int)win->_begx;
              local_28 = (int)win->_maxx + 1;
            }
            if (event.x < local_2c + local_28 + -2) {
              if ((event.bstate & 0x7000000) != 0) {
                *position = *position + row;
                return -1;
              }
              *position = *position + row;
              return 0x27;
            }
          }
          *position = *position + row;
          cmd = -1;
        }
      }
    }
    else {
      if ((event.bstate & 0x18) == 0) {
        cmd = 0xf;
      }
      else {
        cmd = 0x17;
      }
    }
  }
  return cmd;
}



HTList * whichRecall(RecallType recall)

{
  HTList *pHVar1;
  HTList *local_18;
  HTList **list;
  
  if (recall == RECALL_CMD) {
    local_18 = LYcommandList();
  }
  else {
    if (recall == RECALL_MAIL) {
      list = &MAIL_edit_history;
    }
    else {
      list = &URL_edit_history;
    }
    if (*list == (HTList *)0x0) {
      pHVar1 = HTList_new();
      *list = pHVar1;
    }
    local_18 = *list;
  }
  return local_18;
}



void LYRemoveFromCloset(HTList *list)

{
  void *__ptr;
  void *data;
  
  __ptr = HTList_removeFirstObject(list);
  if ((__ptr != (void *)0x0) && (__ptr != (void *)0x0)) {
    free(__ptr);
  }
  return;
}



void LYCloseCloset(RecallType recall)

{
  HTList *list_00;
  HTList *list;
  
  list_00 = whichRecall(recall);
  while ((list_00 != (HTList *)0x0 && (list_00->next != (HTList *)0x0))) {
    LYRemoveFromCloset(list_00);
  }
  HTList_delete(list_00);
  return;
}



char * LYFindInCloset(RecallType recall,char *base)

{
  size_t __n;
  int iVar1;
  char *local_1c;
  uint len;
  char *data;
  HTList *list;
  
  list = whichRecall(recall);
  __n = strlen(base);
  do {
    if ((list == (HTList *)0x0) || (list->next == (HTList *)0x0)) {
      return (char *)0x0;
    }
    if ((list == (HTList *)0x0) || (list = list->next, list == (HTList *)0x0)) {
      local_1c = (char *)0x0;
    }
    else {
      local_1c = (char *)list->object;
    }
    iVar1 = strncmp(base,local_1c,__n);
  } while (iVar1 != 0);
  return local_1c;
}



void LYAddToCloset(RecallType recall,char *str)

{
  HTList *me;
  int iVar1;
  char *data;
  HTList *list;
  
  me = whichRecall(recall);
  data = (char *)0x0;
  HTSACopy(&data,str);
  HTList_addObject(me,data);
  while( true ) {
    iVar1 = HTList_count(me);
    if (iVar1 < 0x65) break;
    LYRemoveFromCloset(me);
  }
  return;
}



int XYdist(int x1,int y1,int x2,int y2,int dx2)

{
  int local_1c;
  int local_18;
  int yerr;
  int xerr;
  
  xerr = (x2 - x1) * 3;
  yerr = (y2 - y1) * 9;
  if (xerr < 0) {
    xerr = ((x1 - x2) - dx2) * 3 + 1;
  }
  if (xerr < 0) {
    xerr = 0;
  }
  if (yerr < 0) {
    yerr = (y2 - y1) * -9;
  }
  if (yerr == 0) {
    if (xerr < 1) {
      local_18 = 0;
    }
    else {
      local_18 = xerr * 2 + -1;
    }
    local_1c = local_18;
  }
  else {
    if ((xerr < 9) && (yerr != 0)) {
      yerr = yerr + (9 - xerr);
    }
    local_1c = yerr + xerr * 2;
  }
  return local_1c;
}



int set_clicked_link(int x,int y,int code,int clicks)

{
  bool bVar1;
  BOOLEAN BVar2;
  int iVar3;
  char *__s;
  size_t dx2;
  int x2;
  int iVar4;
  int local_98;
  int local_94;
  int local_90;
  int local_8c;
  int local_88;
  int local_84;
  int local_80;
  int local_78;
  int local_74;
  int local_6c;
  int local_68;
  double frac;
  int curx;
  int cury;
  int cur_err_2;
  char *text;
  int count;
  int is_text;
  int lx;
  int len;
  int cur_err;
  int mouse_err;
  int l;
  int h;
  int toolbar;
  int c;
  int i;
  int right;
  int left;
  
  iVar3 = (LYcols - (uint)(LYShowScrollbar != '\0')) + -5;
  c = -1;
  if ((LYlines + -1 == y) || (y == 0)) {
    if ((y == 0) && (BVar2 = HText_hasToolbar(HTMainText), BVar2 != '\0')) {
      local_94 = 1;
    }
    else {
      local_94 = 0;
    }
    mouse_link = -2;
    if ((x == 0) && (local_94 != 0)) {
      c = 0x84a;
    }
    else {
      if ((y == 0) && ((LYcols - (uint)(LYShowScrollbar != '\0') == x && (s_hot_paste != -1)))) {
        c = 0x867;
      }
      else {
        if (clicks < 2) {
          if (x < local_94 + 6) {
            if ((code == 3) && (y != 0)) {
              local_88 = 0x103;
            }
            else {
              if ((s_forw_backw == -1) || (x - local_94 < 3)) {
                local_84 = 0x825;
              }
              else {
                local_84 = 0x826;
              }
              local_88 = local_84;
            }
            c = local_88;
          }
          else {
            if (iVar3 < x) {
              if ((code == 3) && (y != 0)) {
                local_80 = 0x102;
              }
              else {
                local_80 = 0x824;
              }
              c = local_80;
            }
            else {
              if (y == 0) {
                c = 0x810;
              }
              else {
                c = 0x80f;
              }
            }
          }
        }
        else {
          if (x < local_94 + 6) {
            if ((code == 3) && (y != 0)) {
              local_90 = 0x106;
            }
            else {
              local_90 = 0x830;
            }
            c = local_90;
          }
          else {
            if (iVar3 < x) {
              if ((code == 3) && (y != 0)) {
                local_8c = 0x107;
              }
              else {
                local_8c = 0x83d;
              }
              c = local_8c;
            }
            else {
              if (y == 0) {
                c = 0x816;
              }
              else {
                c = 0x817;
              }
            }
          }
        }
      }
    }
  }
  else {
    if (((LYcols + -1 == x) && (LYShowScrollbar != '\0')) && (-1 < LYsb_begin)) {
      if (LYsb_arrow == '\0') {
        local_78 = 0;
      }
      else {
        local_78 = 2;
      }
      local_78 = display_lines - local_78;
      mouse_link = -2;
      if (LYsb_arrow == '\0') {
        local_74 = 1;
      }
      else {
        local_74 = 2;
      }
      y = y - local_74;
      if (y < 0) {
        mouse_link = -2;
        return 0x811;
      }
      if (local_78 <= y) {
        mouse_link = -2;
        return 0x812;
      }
      if (1 < clicks) {
        iVar3 = HText_getNumOfLines();
        iVar3 = (iVar3 + 1) - display_lines;
        if (0 < iVar3) {
          LYSetNewline((int)ROUND((double)iVar3 * ((double)y / (double)(local_78 + -1)) + 1.00000000
                                  + 0.50000000));
        }
        iVar3 = LYReverseKeymap(0x45);
        return iVar3;
      }
      if (y < LYsb_begin) {
        mouse_link = -2;
        return 0x810;
      }
      if (LYsb_end <= y) {
        mouse_link = -2;
        return 0x80f;
      }
      mouse_link = -1;
    }
    else {
      mouse_err = 0x1d;
      i = 0;
      while (i < nlinks) {
        iVar3 = links[i].lx;
        bVar1 = false;
        count = 0;
        __s = LYGetHiliteStr(i,0);
        if ((links[i].type == 1) &&
           ((((links[i].l_form)->type == 1 || ((links[i].l_form)->type == 0xc)) ||
            (((links[i].l_form)->type == 2 ||
             (((links[i].l_form)->type == 0xb || ((links[i].l_form)->type == 9)))))))) {
          bVar1 = true;
        }
        if (__s != (char *)0x0) {
          if (bVar1) {
            len = (links[i].l_form)->size;
          }
          else {
            len = strlen(__s);
          }
          cur_err = XYdist(x,y,links[i].lx,links[i].ly,len);
          while (0 < cur_err) {
            count = count + 1;
            __s = LYGetHiliteStr(i,count);
            if (__s == (char *)0x0) break;
            dx2 = strlen(__s);
            iVar4 = links[i].ly;
            x2 = LYGetHilitePos(i,count);
            iVar4 = XYdist(x,y,x2,iVar4 + count,dx2);
            local_98 = cur_err;
            if (iVar4 < cur_err) {
              local_98 = iVar4;
            }
            cur_err = local_98;
          }
          if ((0 < cur_err) && (bVar1)) {
            cur_err = cur_err + -1;
          }
          if (cur_err == 0) {
            if (LYwin == (WINDOW *)0x0) {
              local_6c = -1;
              local_68 = -1;
            }
            else {
              local_6c = (int)LYwin->_cury;
              local_68 = (int)LYwin->_curx;
            }
            if (((clicks < 2) || (!bVar1)) || ((links[i].l_form)->type != 0xc)) {
              if (((code == 2) && (local_6c == y)) &&
                 ((iVar3 <= local_68 && (local_68 - iVar3 <= len)))) {
                mouse_link = -1;
              }
              else {
                if (bVar1) {
                  have_levent = 1;
                }
                mouse_link = i;
              }
              mouse_err = 0;
            }
            else {
              if (((code == 2) && (local_6c == y)) &&
                 ((iVar3 <= local_68 && (local_68 - iVar3 <= len)))) {
                mouse_link = -1;
              }
              else {
                mouse_link = i;
              }
              c = 0x828;
              mouse_err = 0;
            }
            break;
          }
          if (cur_err < mouse_err) {
            mouse_err = cur_err;
            mouse_link = i;
          }
        }
        i = i + 1;
      }
      if (mouse_link < 0) {
        if (LYlines < y * 2) {
          if (y * 4 < LYlines * 3) {
            c = 0x812;
          }
          else {
            c = 0x814;
          }
        }
        else {
          if (y * 4 < LYlines) {
            c = 0x813;
          }
          else {
            c = 0x811;
          }
        }
      }
      else {
        if (mouse_err == 0) {
          if (c == -1) {
            c = 0x827;
          }
        }
        else {
          if (-1 < mouse_err) {
            c = 0x854;
          }
        }
      }
    }
  }
  return c;
}



char * LYstrncpy(char *dst,char *src,int n)

{
  size_t sVar1;
  char *pcVar2;
  int len;
  char *val;
  
  if (src == (char *)0x0) {
    src = "";
  }
  sVar1 = strlen(src);
  if (n < 0) {
    n = 0;
  }
  pcVar2 = strncpy(dst,src,n);
  if ((int)sVar1 < n) {
    dst[sVar1] = '\0';
  }
  else {
    dst[n] = '\0';
  }
  return pcVar2;
}



char * LYmbcsstrncpy(char *dst,char *src,int n_bytes,int n_glyphs,BOOLEAN utf_flag)

{
  bool bVar1;
  char *pcVar2;
  int i_glyphs;
  int i_bytes;
  char *val;
  
  pcVar2 = dst;
  i_bytes = 0;
  i_glyphs = 0;
  if (n_bytes < 0) {
    n_bytes = 0;
  }
  if (n_glyphs < 0) {
    n_glyphs = 0;
  }
  while( true ) {
    if ((*src == '\0') || (n_bytes <= i_bytes)) {
      *dst = '\0';
      return pcVar2;
    }
    if (((utf_flag != '\0') && ((*src & 0xc0U) != 0x80)) &&
       (bVar1 = n_glyphs <= i_glyphs, i_glyphs = i_glyphs + 1, bVar1)) break;
    *dst = *src;
    dst = dst + 1;
    src = src + 1;
    i_bytes = i_bytes + 1;
  }
  *dst = '\0';
  return pcVar2;
}



char * LYmbcs_skip_glyphs(char *data,int n_glyphs,BOOLEAN utf_flag)

{
  bool bVar1;
  int i_glyphs;
  
  i_glyphs = 0;
  if (n_glyphs < 0) {
    n_glyphs = 0;
  }
  if ((data != (char *)0x0) && (*data != '\0')) {
    if (utf_flag == '\0') {
      do {
        bVar1 = n_glyphs < 1;
        n_glyphs = n_glyphs + -1;
        if (bVar1) {
          return data;
        }
        data = data + 1;
      } while (*data != '\0');
    }
    else {
      while ((*data != '\0' &&
             (((utf_flag == '\0' || ((*data & 0xc0U) == 0x80)) ||
              (bVar1 = i_glyphs < n_glyphs, i_glyphs = i_glyphs + 1, bVar1))))) {
        data = data + 1;
      }
    }
  }
  return data;
}



char * LYmbcs_skip_cells(char *data,int n_cells,BOOLEAN utf_flag)

{
  char *pcVar1;
  int iVar2;
  int target;
  int actual;
  char *result;
  
  target = n_cells;
  do {
    pcVar1 = LYmbcs_skip_glyphs(data,target,utf_flag);
    iVar2 = LYstrExtent2(data,(int)(pcVar1 + -(int)data));
    if (iVar2 < 1) {
      return pcVar1;
    }
    target = target + -1;
  } while (n_cells < iVar2);
  return pcVar1;
}



int LYmbcsstrlen(char *str,BOOLEAN utf_flag,BOOLEAN count_gcells)

{
  int len;
  int j;
  int i;
  
  len = 0;
  if ((str != (char *)0x0) && (*str != '\0')) {
    if (count_gcells == '\0') {
      i = 0;
      while (str[i] != '\0') {
        if ((str[i] < '\x03') || ('\b' < str[i])) {
          len = len + 1;
          if ((utf_flag == '\0') || ((str[i] & 0xc0U) == 0x80)) {
            if (((((utf_flag == '\0') && (HTCJK != NOCJK)) && (str[i] < '\0')) &&
                (str[i + 1] != '\0')) && ((str[i + 1] < '\x03' || ('\b' < str[i + 1])))) {
              i = i + 1;
            }
          }
          else {
            j = 0;
            while (((str[i + 1] != '\0' && ((str[i + 1] < '\x03' || ('\b' < str[i + 1])))) &&
                   ((j < 5 && ((utf_flag != '\0' && ((str[i + 1] & 0xc0U) == 0x80))))))) {
              i = i + 1;
              j = j + 1;
            }
          }
        }
        i = i + 1;
      }
    }
    else {
      len = LYstrCells(str);
    }
  }
  return len;
}



void ena_csi(BOOLEAN flag)

{
  csi_is_csi = flag;
  return;
}



int lookup_tiname(char *name,char **names)

{
  int iVar1;
  int code;
  
  code = 0;
  while( true ) {
    if (names[code] == (char *)0x0) {
      return -1;
    }
    iVar1 = strcmp(names[code],name);
    if (iVar1 == 0) break;
    code = code + 1;
  }
  return code;
}



char * expand_tiname(char *first,size_t len,char **result,char *final)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  int in_GS_OFFSET;
  int code;
  char name [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  strncpy(name,first,len);
  name[len] = '\0';
  code = lookup_tiname(name,(char **)strnames);
  if (code < 0) {
    code = lookup_tiname(name,(char **)strfnames);
    if (code < 0) goto LAB_0804ea55;
  }
  if (*(int *)(*(int *)(cur_term + 0x10) + code * 4) != 0) {
    LYstrncpy(*result,*(char **)(*(int *)(cur_term + 0x10) + code * 4),(int)(final + -(int)*result))
    ;
    pcVar2 = *result;
    sVar3 = strlen(*result);
    *result = pcVar2 + sVar3;
  }
LAB_0804ea55:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return first + len;
}



// WARNING: Could not reconcile some variable overlaps

char * expand_tichar(char *first,char **result,char *final)

{
  int iVar1;
  char cVar2;
  ushort **ppuVar3;
  long lVar4;
  size_t len;
  int in_GS_OFFSET;
  char *local_78;
  char *last;
  char *name;
  int value;
  int radix;
  int limit;
  int ch;
  char tmp [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  limit = 0;
  radix = 0;
  value._0_1_ = '\0';
  name = (char *)0x0;
  cVar2 = *first;
  local_78 = first + 1;
  switch((int)cVar2) {
  case 0x45:
  case 0x65:
    value._0_1_ = '\x1b';
    break;
  default:
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[(int)cVar2] & 0x800) == 0) {
      value._0_1_ = *local_78;
    }
    else {
      radix = 8;
      limit = 3;
      local_78 = first;
    }
    break;
  case 0x61:
    name = "bel";
    break;
  case 0x62:
    value._0_1_ = '\b';
    break;
  case 100:
    radix = 10;
    limit = 3;
    break;
  case 0x66:
    value._0_1_ = '\f';
    break;
  case 0x6e:
    value._0_1_ = '\n';
    break;
  case 0x72:
    value._0_1_ = '\r';
    break;
  case 0x74:
    value._0_1_ = '\t';
    break;
  case 0x76:
    value._0_1_ = '\v';
    break;
  case 0x78:
    radix = 0x10;
    limit = 2;
  }
  if (radix != 0) {
    last = (char *)0x0;
    LYstrncpy(tmp,local_78,limit);
    lVar4 = strtol(tmp,&last,radix);
    value._0_1_ = (char)lVar4;
    if ((last != (char *)0x0) && (last != tmp)) {
      local_78 = local_78 + (int)(last + -(int)tmp);
    }
  }
  if (name == (char *)0x0) {
    **result = (char)value;
    *result = *result + 1;
  }
  else {
    len = strlen(name);
    expand_tiname(name,len,result,final);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_78;
}



// WARNING: Could not reconcile some variable overlaps

int expand_substring(char *dst,char *first,char *last,char *final)

{
  byte bVar1;
  byte *first_00;
  char *__s;
  char *pcVar2;
  size_t sVar3;
  char *was;
  char *s;
  int ch;
  
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          if (last <= first) {
            *dst = '\0';
            return 1;
          }
          ch._0_1_ = *first;
          first_00 = (byte *)(first + 1);
          if ((char)ch != '\\') break;
          first = expand_tichar((char *)first_00,&dst,final);
        }
        if ((char)ch == '^') break;
        if ((char)ch == '\0') {
          ch._0_1_ = -0x80;
        }
        *dst = (char)ch;
        dst = dst + 1;
        first = (char *)first_00;
      }
      bVar1 = *first_00;
      __s = first + 2;
      if (bVar1 == 0x28) break;
      if (bVar1 == 0x3f) {
        *dst = '\x7f';
        dst = dst + 1;
        first = __s;
      }
      else {
        if ((bVar1 & 0x3f) < 0x20) {
          *dst = bVar1 & 0x1f;
          dst = dst + 1;
          first = __s;
        }
        else {
          *dst = '^';
          dst = dst + 1;
          first = first + 1;
        }
      }
    }
    s = strchr(__s,0x29);
    pcVar2 = dst;
    if (s == (char *)0x0) {
      sVar3 = strlen(__s);
      s = __s + sVar3;
    }
    first = expand_tiname(__s,(size_t)(s + -(int)__s),&dst,final);
    if (dst == pcVar2) break;
    if (*first != '\0') {
      first = first + 1;
    }
  }
  return 0;
}



void unescaped_char(char *parse,int *keysym)

{
  int iVar1;
  size_t sVar2;
  int in_GS_OFFSET;
  size_t len;
  char buf [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar2 = strlen(parse);
  if (2 < sVar2) {
    expand_substring(buf,parse + 1,parse + (sVar2 - 1),buf + 0x1fff);
    sVar2 = strlen(buf);
    if (sVar2 == 1) {
      *keysym = (int)buf[0];
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



BOOLEAN unescape_string(char *src,char *dst,char *final)

{
  size_t sVar1;
  int iVar2;
  int keysym;
  BOOLEAN ok;
  
  ok = '\0';
  if (*src == '\'') {
    keysym = -1;
    unescaped_char(src,&keysym);
    if (-1 < keysym) {
      *dst = (char)keysym;
      dst[1] = '\0';
      ok = '\x01';
    }
  }
  else {
    if (*src == '\"') {
      sVar1 = strlen(src);
      iVar2 = expand_substring(dst,src + 1,src + (sVar1 - 1),final);
      ok = (BOOLEAN)iVar2;
    }
  }
  return ok;
}



int map_string_to_keysym(char *str,int *keysym)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  ushort **ppuVar5;
  size_t sVar6;
  long lVar7;
  int in_GS_OFFSET;
  int local_2034;
  size_t local_2030;
  byte *local_2028;
  Keysym_String_List *k;
  long value;
  char *tmp;
  size_t len;
  int othersym;
  char *other;
  int modifier;
  char buf [8192];
  
  local_2028 = (byte *)str;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  modifier = 0;
  *keysym = -1;
  iVar2 = strncasecomp(str,"LAC:",4);
  if (iVar2 == 0) {
    pcVar3 = strchr(str + 4,0x3a);
    if (pcVar3 != (char *)0x0) {
      iVar2 = lecname_to_lec(pcVar3 + 1);
      if ((-1 < iVar2) && ((int)(pcVar3 + (-4 - (int)str)) < 0x2000)) {
        strncpy(buf,str + 4,(size_t)(pcVar3 + (-4 - (int)str)));
        (pcVar3 + (-0x200c - (int)str))[(int)(&modifier + 0x803)] = '\0';
        iVar4 = lacname_to_lac(buf);
        *keysym = iVar4;
        if (-1 < *keysym) {
          *keysym = iVar2 << 8 | *keysym | 0x8000;
          local_2034 = *keysym;
          goto LAB_0804f472;
        }
      }
    }
    iVar2 = lacname_to_lac(str + 4);
    *keysym = iVar2;
    if (-1 < *keysym) {
      *keysym = *keysym | 0x800;
      local_2034 = *keysym;
      goto LAB_0804f472;
    }
  }
  iVar2 = strncasecomp(str,"Meta-",5);
  if (iVar2 == 0) {
    local_2028 = (byte *)(str + 5);
    modifier = 0x2000;
    if (*local_2028 != 0) {
      local_2030 = strlen((char *)local_2028);
      if (local_2030 == 1) {
        *keysym = (uint)*local_2028 | 0x2000;
        local_2034 = *keysym;
        goto LAB_0804f472;
      }
      if ((local_2030 == 2) && (*local_2028 == 0x5e)) {
        ppuVar5 = __ctype_b_loc();
        if ((((*ppuVar5)[(byte)str[6]] & 0x400) != 0) || (('?' < str[6] && (str[6] < '`')))) {
          *keysym = (uint)(byte)str[6] & 0x1f | 0x2000;
          local_2034 = *keysym;
          goto LAB_0804f472;
        }
      }
      if ((local_2030 == 2) && ((*local_2028 == 0x5e && (str[6] == '?')))) {
        *keysym = 0x207f;
        local_2034 = *keysym;
        goto LAB_0804f472;
      }
      if ((*local_2028 == 0x5e) || (*local_2028 == 0x5c)) {
        if (0x1c < local_2030) {
          local_2030 = 0x1c;
        }
        expand_substring(buf,(char *)local_2028,(char *)(local_2028 + local_2030),buf + 0x1fff);
        sVar6 = strlen(buf);
        if (sVar6 < 2) {
          *keysym = (uint)(byte)buf[0] | 0x2000;
          local_2034 = *keysym;
          goto LAB_0804f472;
        }
      }
    }
  }
  if (*local_2028 == 0x27) {
    unescaped_char((char *)local_2028,keysym);
  }
  else {
    ppuVar5 = __ctype_b_loc();
    if (((*ppuVar5)[*local_2028] & 0x800) == 0) {
      k = Keysym_Strings;
      while (k->string != (char *)0x0) {
        iVar2 = strcmp(k->string,(char *)local_2028);
        if (iVar2 == 0) {
          *keysym = k->value;
          break;
        }
        k = k + 1;
      }
    }
    else {
      lVar7 = strtol((char *)local_2028,&tmp,0);
      ppuVar5 = __ctype_b_loc();
      if ((((*ppuVar5)[(byte)*tmp] & 8) == 0) && (*keysym = lVar7, 0xff < *keysym)) {
        *keysym = *keysym | 0x400;
      }
    }
  }
  if (-1 < *keysym) {
    *keysym = *keysym | modifier;
  }
  local_2034 = *keysym;
LAB_0804f472:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_2034;
}



char * skip_keysym(char *parse)

{
  bool bVar1;
  ushort **ppuVar2;
  char *local_18;
  int escaped;
  int quoted;
  
  quoted = 0;
  bVar1 = false;
  while (*parse != '\0') {
    if (bVar1) {
      bVar1 = false;
    }
    else {
      if (quoted == 0) {
        if (*parse == '\\') {
          bVar1 = true;
        }
        else {
          if ((*parse == '\"') || (*parse == '\'')) {
            quoted = (int)*parse;
          }
          else {
            ppuVar2 = __ctype_b_loc();
            if (((*ppuVar2)[(byte)*parse] & 0x2000) != 0) break;
          }
        }
      }
      else {
        if (*parse == '\\') {
          bVar1 = true;
        }
        else {
          if ((int)*parse == quoted) {
            quoted = 0;
          }
        }
      }
    }
    parse = parse + 1;
  }
  if ((quoted != 0) || (bVar1)) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = parse;
  }
  return local_18;
}



int setkey_cmd(char *parse)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  byte *pbVar3;
  ushort **ppuVar4;
  char *parse_00;
  char *pcVar5;
  int iVar6;
  int in_GS_OFFSET;
  int local_2020;
  int keysym;
  char *t;
  char *s;
  char buf [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"KEYMAP(PA): in=%s",parse);
  }
  pbVar3 = (byte *)skip_keysym(parse);
  if (pbVar3 == (byte *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"KEYMAP(SKIP) no key description\n");
    }
  }
  else {
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[*pbVar3] & 0x2000) == 0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"KEYMAP(SKIP) junk after key description: \'%s\'\n",pbVar3);
      }
    }
    else {
      *pbVar3 = 0;
      parse_00 = LYSkipBlanks((char *)(pbVar3 + 1));
      pcVar5 = skip_keysym(parse_00);
      if (pcVar5 == (char *)0x0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"KEYMAP(SKIP) no key expansion found\n");
        }
        local_2020 = -1;
        goto LAB_0804f886;
      }
      if (pcVar5 != parse_00) {
        *pcVar5 = '\0';
      }
      iVar6 = map_string_to_keysym(parse_00,&keysym);
      if (-1 < iVar6) {
        BVar2 = unescape_string(parse,buf,buf + 0x1fff);
        iVar6 = keysym;
        if (BVar2 == '\0') {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"KEYMAP(SKIP) could unescape key\n");
          }
          local_2020 = 0;
        }
        else {
          if (LYTraceLogFP == (FILE *)0x0) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"KEYMAP(DEF) keysym=%#x\n",iVar6);
            }
          }
          else {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"KEYMAP(DEF) keysym=%#x, seq=\'%s\'\n",iVar6,buf);
            }
          }
          local_2020 = define_key(buf,keysym);
        }
        goto LAB_0804f886;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"KEYMAP(SKIP) could not map to keysym\n");
      }
    }
  }
  local_2020 = -1;
LAB_0804f886:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_2020;
}



int unsetkey_cmd(char *parse)

{
  char *pcVar1;
  int iVar2;
  int keysym;
  char *s;
  
  pcVar1 = skip_keysym(parse);
  if (pcVar1 != parse) {
    *pcVar1 = '\0';
    iVar2 = map_string_to_keysym(parse,&keysym);
    if (-1 < iVar2) {
      define_key(0,keysym);
    }
  }
  return 0;
}



int read_keymap_file(void)

{
  int iVar1;
  code *pcVar2;
  anon_struct_0 table [2];
  FILE *fp_00;
  size_t __n;
  size_t sVar3;
  int iVar4;
  char *__format;
  char *__s;
  int in_GS_OFFSET;
  size_t len;
  char *s;
  size_t n;
  int linenum;
  FILE *fp;
  char *line;
  char file [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  line = (char *)0x0;
  LYAddPathToHome(file,0x100,".lynx-keymaps");
  fp_00 = (FILE *)fopen64(file,"r");
  if (fp_00 != (FILE *)0x0) {
    linenum = 0;
    while (__s = LYSafeGets(&line,fp_00), __s != (char *)0x0) {
      __s = LYSkipBlanks(line);
      linenum = linenum + 1;
      if ((*__s != '\0') && (*__s != '#')) {
        n = 0;
        while (n < 2) {
          __n = strlen(((anon_struct_0 *)&ram0x08194540)[n].name);
          sVar3 = strlen(__s);
          if ((__n < sVar3) && (iVar4 = strncmp(__s,*(char **)(n * 8 + 0x8194540),__n), iVar4 == 0))
          {
            pcVar2 = *(code **)(n * 8 + 0x8194544);
            __format = LYSkipBlanks(__s + __n);
            iVar4 = (*pcVar2)(__format);
            if (iVar4 < 0) {
              __format = (char *)gettext("Error processing line %d of %s\n");
              fprintf(stderr,__format,linenum,file);
            }
          }
          n = n + 1;
        }
      }
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    LYCloseInput(fp_00);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void setup_vtXXX_keymap(void)

{
  Keysym_String_List table [21];
  size_t n;
  
  n = 0;
  while (n < 0x15) {
    define_key(((Keysym_String_List *)&ram0x08194560)[n].string,*(undefined4 *)(n * 8 + 0x8194564));
    n = n + 1;
  }
  return;
}



int lynx_initialize_keymaps(void)

{
  int iVar1;
  
  setup_vtXXX_keymap();
  iVar1 = read_keymap_file();
  return iVar1;
}



int LYmouse_menu(int x,int y,int atlink,int code)

{
  anon_struct_0 possible_entries [26];
  int iVar1;
  int local_100;
  int local_fc;
  int local_f8;
  char *choices [27];
  int actions [26];
  int filter_out;
  int retlac;
  int c1;
  int c;
  
  if (atlink == 0) {
    local_100 = 2;
  }
  else {
    local_100 = 1;
  }
  filter_out = local_100;
  c1 = 0;
  c = 0;
  while (c < 0x1a) {
    if ((filter_out & *(uint *)(c * 0xc + 0x814a468)) == 0) {
      choices[c1] = ((anon_struct_0 *)&ram0x0814a460)[c].txt;
      actions[c1] = *(int *)(c * 0xc + 0x814a464);
      c1 = c1 + 1;
    }
    c = c + 1;
  }
  choices[c1] = (char *)0x0;
  if (x < 6) {
    local_fc = 1;
  }
  else {
    local_fc = x + -5;
  }
  if (atlink == 0) {
    local_f8 = 9;
  }
  else {
    local_f8 = 1;
  }
  iVar1 = popup_choice(local_f8,y,local_fc,choices,c1,0,'\x01');
  if (term_options == '\0') {
    retlac = actions[iVar1];
  }
  else {
    retlac = 0x45;
    term_options = '\0';
  }
  if ((code == 2) && (mouse_link == -1)) {
    switch(retlac) {
    case 0xe:
      retlac = 0xd;
    case 0xc:
    case 0xf:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x24:
    case 0x25:
    case 0x2a:
    case 0x2b:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x38:
    case 0x39:
    case 0x3c:
    case 0x4f:
      mouse_link = -3;
    }
  }
  if ((retlac == 0x45) || (retlac == 0x15)) {
    mouse_link = -1;
  }
  if ((code == 2) && (retlac == 0x45)) {
    repaint_main_statusline(2);
  }
  return retlac;
}



// WARNING: Could not reconcile some variable overlaps

int LYgetch_for(int code)

{
  int *piVar1;
  WINDOW *pWVar2;
  FILE *__stream;
  int iVar3;
  ushort **ppuVar4;
  char *Msg;
  int iVar5;
  FILE *local_7c;
  uint local_54;
  int local_50;
  uint local_4c;
  MEVENT event;
  int atlink;
  int lac;
  int err;
  int current_modifier;
  int d;
  int c;
  int b;
  int a;
  BOOLEAN done_esc;
  
  d = -1;
  current_modifier = 0;
  done_esc = false;
  have_levent = 0;
  do {
    piVar1 = __errno_location();
    if (*piVar1 == 4) {
      piVar1 = __errno_location();
      *piVar1 = 0;
    }
    clearerr(stdin);
    pWVar2 = LYtopwindow();
    c = wgetch(pWVar2);
    lynx_nl2crlf(0);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GETCH: Got %#x.\n",c);
    }
    if ((c == -1) && (piVar1 = __errno_location(), *piVar1 == 4)) {
      if (WWW_TraceFlag != '\0') {
        iVar5 = (int)recent_sizechange;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Got EOF with EINTR, recent_sizechange so far is %d\n",iVar5);
      }
      if ((recent_sizechange == '\0') && (size_change(0), WWW_TraceFlag != '\0')) {
        iVar5 = (int)recent_sizechange;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Now recent_sizechange is %d\n",iVar5);
      }
      piVar1 = __errno_location();
      *piVar1 = 0;
      return 0x10e;
    }
    local_7c = stdin;
    iVar5 = feof(stdin);
    if (((iVar5 != 0) || (local_7c = stdin, iVar5 = ferror(stdin), iVar5 != 0)) || (c == -1)) {
      if (recent_sizechange != '\0') {
        return 7;
      }
      cleanup((EVP_PKEY_CTX *)local_7c);
      exit_immediately(0);
    }
    if ((escape_bound == 0) && ((c == 0x1b || ((csi_is_csi != '\0' && (c == 0x9b)))))) {
      done_esc = '\x01';
      pWVar2 = LYtopwindow();
      iVar5 = wgetch(pWVar2);
      if ((iVar5 == 0x5b) || (a = iVar5, iVar5 == 0x4f)) {
        pWVar2 = LYtopwindow();
        a = wgetch(pWVar2);
      }
      switch(a) {
      case 0x31:
        if ((iVar5 == 0x5b) || (c == 0x9b)) {
          pWVar2 = LYtopwindow();
          d = wgetch(pWVar2);
          if (d == 0x7e) {
            c = 0x10a;
            break;
          }
        }
        done_esc = '\0';
        break;
      case 0x32:
        if ((iVar5 == 0x5b) || (c == 0x9b)) {
          pWVar2 = LYtopwindow();
          d = wgetch(pWVar2);
          if (d == 0x7e) {
            c = 0x10c;
          }
          else {
            if ((d == 0x38) || (d == 0x39)) {
              pWVar2 = LYtopwindow();
              iVar3 = wgetch(pWVar2);
              if (iVar3 == 0x7e) {
                if (d == 0x38) {
                  c = 0x108;
                }
                else {
                  if (d == 0x39) {
                    c = 0x109;
                  }
                }
                d = -1;
              }
            }
          }
        }
        else {
          done_esc = '\0';
        }
        break;
      case 0x33:
        if ((iVar5 == 0x5b) || (c == 0x9b)) {
          pWVar2 = LYtopwindow();
          d = wgetch(pWVar2);
          if (d == 0x7e) {
            c = 0x10d;
            break;
          }
        }
        done_esc = '\0';
        break;
      case 0x34:
        if ((iVar5 == 0x5b) || (c == 0x9b)) {
          pWVar2 = LYtopwindow();
          d = wgetch(pWVar2);
          if (d == 0x7e) {
            c = 0x10b;
            break;
          }
        }
        done_esc = '\0';
        break;
      case 0x35:
        if ((iVar5 == 0x5b) || (c == 0x9b)) {
          pWVar2 = LYtopwindow();
          d = wgetch(pWVar2);
          if (d == 0x7e) {
            c = 0x105;
            break;
          }
        }
        done_esc = '\0';
        break;
      case 0x36:
        if ((iVar5 == 0x5b) || (c == 0x9b)) {
          pWVar2 = LYtopwindow();
          d = wgetch(pWVar2);
          if (d == 0x7e) {
            c = 0x104;
            break;
          }
        }
        done_esc = '\0';
        break;
      default:
switchD_0804ff2c_caseD_37:
        if (((c == 0x1b) && (a == iVar5)) && (iVar5 != 0x5b)) {
          current_modifier = 0x2000;
          c = a;
          done_esc = (uint)a >> 8 == 0;
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Unknown key sequence: %d:%d:%d\n",c,iVar5,a);
          }
          if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
            sleep(MessageSecs);
          }
        }
        break;
      case 0x41:
        c = 0x100;
        break;
      case 0x42:
        c = 0x101;
        break;
      case 0x43:
        c = 0x102;
        break;
      case 0x44:
        c = 0x103;
        break;
      case 0x4d:
        c = 10;
        break;
      case 0x50:
        c = 0x108;
        break;
      case 0x5b:
        if ((iVar5 != 0x5b) && (c != 0x9b)) goto switchD_0804ff2c_caseD_37;
        pWVar2 = LYtopwindow();
        d = wgetch(pWVar2);
        if (d == 0x41) {
          c = 0x108;
        }
        break;
      case 0x6b:
        if (iVar5 == 0x4f) {
          c = 0x2b;
        }
        else {
          done_esc = '\0';
        }
        break;
      case 0x6c:
        c = 0x2b;
        break;
      case 0x6d:
        c = 0x2d;
        break;
      case 0x70:
        c = 0x30;
        break;
      case 0x71:
        c = 0x107;
        break;
      case 0x72:
        c = 0x101;
        break;
      case 0x73:
        c = 0x104;
        break;
      case 0x74:
        c = 0x103;
        break;
      case 0x75:
        c = 0x108;
        break;
      case 0x76:
        c = 0x102;
        break;
      case 0x77:
        c = 0x106;
        break;
      case 0x78:
        c = 0x100;
        break;
      case 0x79:
        c = 0x105;
      }
      ppuVar4 = __ctype_b_loc();
      if ((((*ppuVar4)[a] & 0x800) != 0) &&
         ((((iVar5 == 0x5b || (c == 0x9b)) && (d != -1)) && (d != 0x7e)))) {
        pWVar2 = LYtopwindow();
        d = wgetch(pWVar2);
      }
      if ((!(bool)done_esc) && ((uint)a >> 8 == 0)) {
        if (((a == iVar5) && ((iVar5 != 0x5b && (c != 0x9b)))) && (c == 0x1b)) {
          current_modifier = 0x2000;
          c = a;
          done_esc = true;
        }
        else {
          done_esc = true;
        }
      }
    }
    if ((c < 0) || ((c & 0x8000U) == 0)) {
      if ((-1 < c) && ((c & 0x400U) != 0)) {
        c = c & 0xfffffbff;
        done_esc = true;
      }
    }
    else {
      if ((code != 2) && (code != 3)) {
        if ((c == -1) || ((c & 0x8000U) == 0)) {
          local_54 = c;
        }
        else {
          local_54 = (uint)CONCAT11(8,(char)c);
        }
        c = local_54;
      }
    }
    if ((((-1 < c) && (-1 < c)) && ((c & 0x8000U) == 0)) && ((c & 0x2000U) != 0)) {
      current_modifier = 0x2000;
      c = c & 0x7ff;
    }
    if ((-1 < c) && ((c & 0x8800U) != 0)) {
      done_esc = true;
    }
    if ((bool)done_esc) goto switchD_08050400_caseD_108;
    switch(c) {
    case 0x102:
      c = 0x101;
      goto switchD_08050400_caseD_108;
    case 0x103:
      c = 0x100;
      goto switchD_08050400_caseD_108;
    case 0x104:
      c = 0x103;
      goto switchD_08050400_caseD_108;
    case 0x105:
      c = 0x102;
      goto switchD_08050400_caseD_108;
    case 0x106:
      c = 0x106;
      goto switchD_08050400_caseD_108;
    case 0x107:
      c = 0x7f;
    default:
      goto switchD_08050400_caseD_108;
    case 0x109:
      c = 0x108;
      goto switchD_08050400_caseD_108;
    case 0x118:
      c = 0x109;
      goto switchD_08050400_caseD_108;
    case 0x14a:
      c = 0x10d;
      goto switchD_08050400_caseD_108;
    case 0x14b:
      c = 0x10c;
      goto switchD_08050400_caseD_108;
    case 0x14d:
      c = 0x12;
      goto switchD_08050400_caseD_108;
    case 0x152:
      c = 0x104;
      goto switchD_08050400_caseD_108;
    case 0x153:
      c = 0x105;
      goto switchD_08050400_caseD_108;
    case 0x157:
      c = 10;
      goto switchD_08050400_caseD_108;
    case 0x15b:
      c = 0x107;
      goto switchD_08050400_caseD_108;
    case 0x15c:
      c = 0x106;
      goto switchD_08050400_caseD_108;
    case 0x15d:
      c = 0x105;
      goto switchD_08050400_caseD_108;
    case 0x15e:
      c = 0x10e;
      goto switchD_08050400_caseD_108;
    case 0x15f:
      c = 0x107;
      goto switchD_08050400_caseD_108;
    case 0x160:
      c = 0x104;
      goto switchD_08050400_caseD_108;
    case 0x161:
      c = 0x10f;
      goto switchD_08050400_caseD_108;
    case 0x168:
      c = 0x107;
      goto switchD_08050400_caseD_108;
    case 0x16a:
      c = 0x10a;
      goto switchD_08050400_caseD_108;
    case 0x16b:
      c = 0x108;
      goto switchD_08050400_caseD_108;
    case 0x173:
      c = 0x109;
      goto switchD_08050400_caseD_108;
    case 0x181:
      c = 0x10b;
      goto switchD_08050400_caseD_108;
    case 0x199:
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"KEY_MOUSE\n");
      }
      if (code == 1) {
        c = 0x11d;
        goto switchD_08050400_caseD_108;
      }
      if (code == 4) {
        getmouse(&event);
        c = 0x10e;
        goto switchD_08050400_caseD_108;
      }
      lac = 0;
      c = -1;
      mouse_link = -1;
      iVar5 = getmouse(&event);
      if (iVar5 != 0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Mouse error: no event available!\n");
        }
        if (code == 0) {
          local_50 = 0;
        }
        else {
          local_50 = 0x10e;
        }
        return local_50;
      }
      levent._0_4_ = event._0_4_;
      levent.x = event.x;
      levent.y = event.y;
      levent.z = event.z;
      levent.bstate = event.bstate;
      if ((event.bstate & 4) != 0) {
        c = set_clicked_link(event.x,event.y,code,1);
        goto LAB_0805092b;
      }
      if ((event.bstate & 8) != 0) {
        c = set_clicked_link(event.x,event.y,code,2);
        if ((c == 0x828) && (code == 2)) {
          lac = 0x28;
        }
        goto LAB_0805092b;
      }
      if ((event.bstate & 0x4000) != 0) {
        c = 0x825;
        goto LAB_0805092b;
      }
      if ((code != 3) && ((event.bstate & 0x30c3) == 0)) {
        if ((event.bstate & 0x100) != 0) {
          iVar5 = set_clicked_link(event.x,event.y,code,1);
          if (iVar5 != 0x827) {
            mouse_link = -1;
          }
          lac = LYmouse_menu(event.x,event.y,(uint)(iVar5 == 0x827),code);
          if (lac == 0x28) {
            if (mouse_link == -1) {
              lac = 0x27;
            }
            else {
              if ((((-1 < mouse_link) && (textfields_need_activation != '\0')) &&
                  (links[mouse_link].type == 1)) &&
                 ((((links[mouse_link].l_form)->type == 1 ||
                   ((links[mouse_link].l_form)->type == 0xc)) ||
                  (((links[mouse_link].l_form)->type == 2 ||
                   (((links[mouse_link].l_form)->type == 0xb ||
                    ((links[mouse_link].l_form)->type == 9)))))))) {
                lac = 0x27;
              }
            }
          }
          if ((lac == 0x27) && (mouse_link == -1)) {
            Msg = (char *)gettext("No link chosen");
            HTAlert(Msg);
            lac = 0x15;
          }
          iVar5 = LYReverseKeymap(lac);
          if (iVar5 < 0) {
            local_4c = lac | 0x800;
          }
          else {
            local_4c = LYReverseKeymap(lac);
          }
          c = local_4c;
        }
LAB_0805092b:
        if ((((code == 2) && (mouse_link == -1)) && (lac != 0x15)) && (lac != 0x28)) {
          ungetmouse(&event);
          wgetch(LYwin);
          c = 0x11d;
        }
        if ((0x294 < c + 1) && ((c & 0x800U) != 0)) {
          return c;
        }
switchD_08050400_caseD_108:
        if ((c & 0x8800U) != 0) {
          return c;
        }
        if (0x294 < c + 1) {
          return 0;
        }
        return c | current_modifier;
      }
      break;
    case 0x19a:
      if (WWW_TraceFlag != '\0') {
        iVar5 = (int)recent_sizechange;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Got KEY_RESIZE, recent_sizechange so far is %d\n",iVar5);
      }
      size_change(0);
      if (WWW_TraceFlag != '\0') {
        iVar5 = (int)recent_sizechange;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Now recent_sizechange is %d\n",iVar5);
      }
      if (recent_sizechange != '\0') {
        c = 0x10e;
        goto switchD_08050400_caseD_108;
      }
      recent_sizechange = '\x01';
    }
  } while( true );
}



int LYgetch(void)

{
  int iVar1;
  
  iVar1 = LYReadCmdKey(0);
  return iVar1;
}



int LYgetch_choice(void)

{
  int ch;
  
  ch = LYReadCmdKey(1);
  if (ch == 3) {
    ch = 7;
  }
  return ch;
}



int LYgetch_input(void)

{
  int ch;
  
  ch = LYReadCmdKey(2);
  if (ch == 3) {
    ch = 7;
  }
  return ch;
}



int LYgetch_single(void)

{
  ushort **ppuVar1;
  uint local_18;
  int ch;
  
  ch = LYReadCmdKey(4);
  if (ch == 3) {
    ch = 7;
  }
  else {
    if ((0 < ch) && (ch < 0x100)) {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[ch & 0xff] & 0x200) == 0) {
        local_18 = ch & 0xff;
      }
      else {
        local_18 = toupper(ch & 0xff);
      }
      ch = local_18;
    }
  }
  return ch;
}



void LYLowerCase(char *arg_buffer)

{
  ushort **ppuVar1;
  int iVar2;
  char local_19;
  size_t i;
  
  i = 0;
  while (arg_buffer[i] != '\0') {
    if ((arg_buffer[i] < '\0') && (arg_buffer[i + 1] != '\0')) {
      if (((kanji_code != SJIS) || ((byte)arg_buffer[i] < 0xa1)) || (0xdf < (byte)arg_buffer[i])) {
        i = i + 1;
      }
    }
    else {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)arg_buffer[i]] & 0x100) == 0) {
        local_19 = arg_buffer[i];
      }
      else {
        iVar2 = tolower((uint)(byte)arg_buffer[i]);
        local_19 = (char)iVar2;
      }
      arg_buffer[i] = local_19;
    }
    i = i + 1;
  }
  return;
}



void LYUpperCase(char *arg_buffer)

{
  ushort **ppuVar1;
  int iVar2;
  char local_19;
  size_t i;
  
  i = 0;
  while (arg_buffer[i] != '\0') {
    if ((arg_buffer[i] < '\0') && (arg_buffer[i + 1] != '\0')) {
      if (((kanji_code != SJIS) || ((byte)arg_buffer[i] < 0xa1)) || (0xdf < (byte)arg_buffer[i])) {
        i = i + 1;
      }
    }
    else {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)arg_buffer[i]] & 0x200) == 0) {
        local_19 = arg_buffer[i];
      }
      else {
        iVar2 = toupper((uint)(byte)arg_buffer[i]);
        local_19 = (char)iVar2;
      }
      arg_buffer[i] = local_19;
    }
    i = i + 1;
  }
  return;
}



BOOLEAN LYRemoveNewlines(char *buffer)

{
  char *local_18;
  char *old;
  
  if (buffer != (char *)0x0) {
    local_18 = buffer;
    while (((*local_18 != '\0' && (*local_18 != '\n')) && (*local_18 != '\r'))) {
      local_18 = local_18 + 1;
    }
    if (*local_18 != '\0') {
      old = local_18;
      while (*old != '\0') {
        if ((*old != '\n') && (*old != '\r')) {
          *local_18 = *old;
          local_18 = local_18 + 1;
        }
        old = old + 1;
      }
      *local_18 = '\0';
      return '\x01';
    }
  }
  return '\0';
}



char * LYReduceBlanks(char *buffer)

{
  if ((buffer != (char *)0x0) && (*buffer != '\0')) {
    LYTrimLeading(buffer);
    LYTrimTrailing(buffer);
    convert_to_spaces(buffer,'\x01');
  }
  return buffer;
}



char * LYRemoveBlanks(char *buffer)

{
  ushort **ppuVar1;
  byte *local_1c;
  byte *local_18;
  char *old;
  
  if (buffer == (char *)0x0) {
    local_1c = (byte *)0x0;
  }
  else {
    local_18 = (byte *)buffer;
    while (*local_18 != 0) {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[*local_18] & 0x2000) != 0) break;
      local_18 = local_18 + 1;
    }
    if (*local_18 != 0) {
      old = (char *)local_18;
      while (*old != '\0') {
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)*old] & 0x2000) == 0) {
          *local_18 = *old;
          local_18 = local_18 + 1;
        }
        old = old + 1;
      }
      *local_18 = 0;
    }
    local_1c = local_18;
  }
  return (char *)local_1c;
}



char * LYSkipBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) == 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



char * LYSkipNonBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    if (*buffer == '\0') {
      return buffer;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) != 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



char * LYSkipCBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) == 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



char * LYSkipCNonBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    if (*buffer == '\0') {
      return buffer;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) != 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



void LYTrimLeading(char *buffer)

{
  char cVar1;
  char *skipped;
  
  skipped = LYSkipBlanks(buffer);
  do {
    *buffer = *skipped;
    cVar1 = *buffer;
    buffer = buffer + 1;
    skipped = skipped + 1;
  } while (cVar1 != '\0');
  return;
}



char * LYTrimNewline(char *buffer)

{
  size_t i;
  
  i = strlen(buffer);
  while ((i != 0 && ((buffer[i - 1] == '\n' || (buffer[i - 1] == '\r'))))) {
    i = i - 1;
    buffer[i] = '\0';
  }
  return buffer;
}



void LYTrimTrailing(char *buffer)

{
  ushort **ppuVar1;
  size_t i;
  
  i = strlen(buffer);
  while( true ) {
    if (i == 0) {
      return;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)buffer[i - 1]] & 0x2000) == 0) break;
    i = i - 1;
    buffer[i] = '\0';
  }
  return;
}



char * LYElideString(char *str,int cut_pos)

{
  char cVar1;
  char s_str [1024];
  size_t sVar2;
  int in_GS_OFFSET;
  int len;
  char *d;
  char *s;
  char buff [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  LYstrncpy(buff,str,0x3ff);
  sVar2 = strlen(buff);
  if ((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -9) < (int)sVar2) {
    buff[cut_pos] = '.';
    buff[cut_pos + 1] = '.';
    s = buff + sVar2 + ((uint)(LYShowScrollbar != '\0') - LYcols) + cut_pos + 10;
    d = buff + cut_pos + 2;
    do {
      if (((s < buff) || (d < buff)) || (buff + LYcols <= d)) break;
      *d = *s;
      cVar1 = *d;
      d = d + 1;
      s = s + 1;
    } while (cVar1 != '\0');
    buff[LYcols] = '\0';
  }
  strcpy((char *)0x81ab4c0,buff);
  if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (char *)&ram0x081ab4c0;
}



BOOLEAN LYTrimStartfile(char *buffer)

{
  int iVar1;
  BOOLEAN local_5;
  
  LYTrimHead(buffer);
  if ((*buffer == 'l') || (*buffer == 'L')) {
    iVar1 = strncasecomp(buffer,"lynxexec:",9);
    if (iVar1 != 0) goto LAB_0805116c;
LAB_0805119f:
    HTUnEscapeSome(buffer," \r\n\t");
    convert_to_spaces(buffer,'\x01');
    local_5 = '\x01';
  }
  else {
LAB_0805116c:
    if ((*buffer == 'l') || (*buffer == 'L')) {
      iVar1 = strncasecomp(buffer,"lynxprog:",9);
      if (iVar1 == 0) goto LAB_0805119f;
    }
    local_5 = '\0';
  }
  return local_5;
}



void LYEscapeStartfile(char **buffer)

{
  BOOLEAN BVar1;
  char *src;
  char *escaped;
  
  BVar1 = LYTrimStartfile(*buffer);
  if (BVar1 == '\0') {
    src = HTEscapeUnsafe(*buffer);
    HTSACopy(buffer,src);
    if (src != (char *)0x0) {
      free(src);
    }
  }
  return;
}



void LYTrimAllStartfile(char *buffer)

{
  BOOLEAN BVar1;
  
  BVar1 = LYTrimStartfile(buffer);
  if (BVar1 == '\0') {
    LYRemoveBlanks(buffer);
  }
  return;
}



void LYSetupEdit(EditFieldData *edit,char *old,int maxstr,int maxdsp)

{
  size_t sVar1;
  int local_c;
  int local_8;
  
  if (LYwin == (WINDOW *)0x0) {
    local_c = -1;
  }
  else {
    local_c = (int)LYwin->_cury;
  }
  edit->sy = local_c;
  if (LYwin == (WINDOW *)0x0) {
    local_8 = -1;
  }
  else {
    local_8 = (int)LYwin->_curx;
  }
  edit->sx = local_8;
  edit->pad = ' ';
  edit->dirty = '\x01';
  edit->panon = '\0';
  edit->current_modifiers = 0;
  edit->maxlen = maxstr;
  edit->dspwdth = maxdsp;
  edit->margin = 0;
  sVar1 = strlen(old);
  edit->pos = sVar1;
  edit->mark = -1;
  edit->xpan = 0;
  if (maxdsp < maxstr) {
    if (4 < edit->dspwdth) {
      edit->panon = '\x01';
    }
    edit->margin = (int)(((uint)(edit->dspwdth >> 0x1f) >> 0x1e) + edit->dspwdth) >> 2;
    if (10 < edit->margin) {
      edit->margin = 10;
    }
  }
  LYstrncpy(edit->buffer,old,maxstr);
  sVar1 = strlen(edit->buffer);
  edit->strlen = sVar1;
  return;
}



int mbcs_glyphs(char *s,int len)

{
  int i;
  int glyphs;
  
  glyphs = 0;
  if (LYCharSet_UC[current_char_set].enc == 7) {
    i = 0;
    while ((s[i] != '\0' && (i < len))) {
      if ((s[i] & 0xc0U) != 0x80) {
        glyphs = glyphs + 1;
      }
      i = i + 1;
    }
  }
  else {
    if (HTCJK == NOCJK) {
      glyphs = len;
    }
    else {
      i = 0;
      while ((s[i] != '\0' && (i < len))) {
        if (s[i] < '\0') {
          i = i + 1;
        }
        i = i + 1;
        glyphs = glyphs + 1;
      }
    }
  }
  return glyphs;
}



int mbcs_skip(char *s,int pos)

{
  int i;
  int p;
  
  if (LYCharSet_UC[current_char_set].enc == 7) {
    i = 0;
    p = 0;
    while (s[i] != '\0') {
      if ((s[i] & 0xc0U) != 0x80) {
        p = p + 1;
      }
      if (pos < p) {
        return i;
      }
      i = i + 1;
    }
  }
  else {
    if (HTCJK == NOCJK) {
      i = pos;
    }
    else {
      i = 0;
      p = 0;
      while ((s[i] != '\0' && (p < pos))) {
        if (s[i] < '\0') {
          i = i + 1;
        }
        p = p + 1;
        i = i + 1;
      }
    }
  }
  return i;
}



int cell2char(char *s,int cells)

{
  size_t sVar1;
  int iVar2;
  int have;
  int pos;
  int len;
  int result;
  
  sVar1 = strlen(s);
  pos = 0;
  while (pos <= (int)sVar1) {
    iVar2 = LYstrExtent2(s,pos);
    if (cells <= iVar2) break;
    pos = pos + 1;
  }
  if ((int)sVar1 < pos) {
    pos = sVar1;
  }
  iVar2 = mbcs_glyphs(s,pos);
  return iVar2;
}



int LYEditInsert(EditFieldData *edit,uchar *s,int len,int map,BOOLEAN maxMessage)

{
  bool bVar1;
  char *text;
  int overflow;
  int edited;
  int remains;
  int length;
  
  length = strlen(edit->buffer);
  edited = 0;
  bVar1 = false;
  if (edit->maxlen - (length + len) < 0) {
    bVar1 = true;
    len = 0;
    if (edit->maxlen <= length) goto finish;
    len = edit->maxlen - length;
  }
  edit->buffer[length + len] = '\0';
  while (edit->pos <= length) {
    edit->buffer[length + len] = edit->buffer[length];
    length = length + -1;
  }
  strncpy(edit->buffer + edit->pos,(char *)s,len);
  edited = 1;
finish:
  edit->pos = edit->pos + len;
  edit->strlen = edit->strlen + len;
  if (edited != 0) {
    edit->dirty = '\x01';
  }
  if ((bVar1) && (maxMessage != '\0')) {
    mustshow = '\x01';
    text = (char *)gettext("Maximum length reached!  Delete text or move off field.");
    statusline(text);
  }
  if (edit->pos < edit->mark) {
    edit->mark = edit->mark + len;
  }
  else {
    if (edit->mark < ~edit->pos) {
      edit->mark = edit->mark - len;
    }
  }
  if (-1 < edit->mark) {
    edit->mark = ~edit->mark;
  }
  return edited;
}



int LYEdit1(EditFieldData *edit,int ch,int action,BOOLEAN maxMessage)

{
  char cVar1;
  size_t sVar2;
  ushort **ppuVar3;
  int iVar4;
  char *text;
  int iVar5;
  int local_30;
  int yanklen;
  int reglen;
  int offset;
  int length;
  int i;
  uchar uch;
  
  if (edit->maxlen < 1) {
    return 0;
  }
  sVar2 = strlen(edit->buffer);
  edit->strlen = sVar2;
  i = sVar2;
  switch(action) {
  default:
    return ch;
  case 1:
    uch = (uchar)ch;
    LYEditInsert(edit,&uch,1,0,maxMessage);
    return 0;
  case 7:
    if ((int)sVar2 <= edit->pos) break;
    iVar5 = edit->pos;
    iVar4 = mbcs_skip(edit->buffer + edit->pos,1);
    edit->pos = iVar5 + iVar4;
  case 9:
    if ((sVar2 != 0) && (edit->pos != 0)) {
      iVar5 = edit->pos;
      iVar4 = mbcs_glyphs(edit->buffer,edit->pos);
      iVar4 = mbcs_skip(edit->buffer,iVar4 + -1);
      iVar5 = iVar5 - iVar4;
      edit->pos = edit->pos - iVar5;
      i = edit->pos;
      while (i < (int)((sVar2 - iVar5) + 1)) {
        edit->buffer[i] = *(char *)((int)edit + i + iVar5 + 0x2c);
        i = i + 1;
      }
      if (-1 < edit->mark) {
        edit->mark = ~edit->mark;
      }
      if (edit->mark <= ~edit->pos) {
        edit->mark = edit->mark + iVar5;
      }
    }
    break;
  case 10:
    offset = edit->pos;
    LYEdit1(edit,0,0x13,'\0');
    offset = edit->pos - offset;
    edit->pos = edit->pos - offset;
    goto shrink;
  case 0xb:
    offset = edit->pos;
    LYEdit1(edit,0,0x14,'\0');
    offset = offset - edit->pos;
shrink:
    i = edit->pos;
    while (i < (int)((sVar2 - offset) + 1)) {
      edit->buffer[i] = edit->buffer[i + offset];
      i = i + 1;
    }
    if (-1 < edit->mark) {
      edit->mark = ~edit->mark;
    }
    if (edit->mark <= ~edit->pos - offset) {
      edit->mark = edit->mark + offset;
    }
    if ((~edit->pos - offset < edit->mark) && (edit->mark < ~edit->pos)) {
      edit->mark = ~edit->pos;
    }
    break;
  case 0xc:
    edit->buffer[0] = '\0';
    edit->mark = -1;
  case 0xd:
    edit->pos = 0;
    break;
  case 0xe:
    edit->pos = sVar2;
    break;
  case 0xf:
  case 0x10:
    if (edit->pos < (int)sVar2) {
      iVar5 = edit->pos;
      iVar4 = mbcs_skip(edit->buffer + edit->pos,1);
      edit->pos = iVar5 + iVar4;
    }
    else {
      if (action == 0x10) {
        return -ch;
      }
    }
    break;
  case 0x11:
  case 0x12:
    if (edit->pos < 1) {
      if (action == 0x12) {
        return -ch;
      }
    }
    else {
      iVar5 = mbcs_glyphs(edit->buffer,edit->pos);
      iVar5 = mbcs_skip(edit->buffer,iVar5 + -1);
      edit->pos = iVar5;
    }
    break;
  case 0x13:
    while ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)edit->buffer[edit->pos]] & 8) != 0 ||
           (edit->buffer[edit->pos] < '\0'))) {
      edit->pos = edit->pos + 1;
    }
    while (((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)edit->buffer[edit->pos]] & 8) == 0 &&
            (-1 < edit->buffer[edit->pos])) && (edit->buffer[edit->pos] != '\0'))) {
      edit->pos = edit->pos + 1;
    }
    break;
  case 0x14:
    while (((edit->pos != 0 &&
            (ppuVar3 = __ctype_b_loc(),
            ((*ppuVar3)[*(byte *)((int)&edit->mark + edit->pos + 3)] & 8) == 0)) &&
           (-1 < *(char *)((int)&edit->mark + edit->pos + 3)))) {
      edit->pos = edit->pos + -1;
    }
    while ((edit->pos != 0 &&
           ((ppuVar3 = __ctype_b_loc(),
            ((*ppuVar3)[*(byte *)((int)&edit->mark + edit->pos + 3)] & 8) != 0 ||
            (*(char *)((int)&edit->mark + edit->pos + 3) < '\0'))))) {
      edit->pos = edit->pos + -1;
    }
    break;
  case 0x15:
    LYLowerCase(edit->buffer);
    break;
  case 0x16:
    LYUpperCase(edit->buffer);
    break;
  case 0x19:
    i = edit->pos;
    while (i < (int)(sVar2 + 1)) {
      *(char *)((int)edit + (i - edit->pos) + 0x2c) = edit->buffer[i];
      i = i + 1;
    }
    if (-1 < edit->mark) {
      edit->mark = ~edit->mark;
    }
    if (~edit->pos < edit->mark) {
      edit->mark = -1;
    }
    else {
      edit->mark = edit->mark + edit->pos;
    }
    edit->pos = 0;
    break;
  case 0x1a:
    edit->buffer[edit->pos] = '\0';
    if (-1 < edit->mark) {
      edit->mark = ~edit->mark;
    }
    if (edit->mark <= ~edit->pos) {
      edit->mark = -1;
    }
    break;
  case 0x1c:
    if ((LYCharSet_UC[current_char_set].enc != 7) && (HTCJK == NOCJK)) {
      if (((int)sVar2 < 2) || (edit->pos == 0)) {
        return ch;
      }
      if (edit->pos == sVar2) {
        edit->pos = edit->pos + -1;
      }
      if (edit->mark < 0) {
        edit->mark = ~edit->mark;
      }
      if ((edit->mark == edit->pos) || (edit->mark == edit->pos + 1)) {
        edit->mark = edit->pos + -1;
      }
      if (-1 < edit->mark) {
        edit->mark = ~edit->mark;
      }
      if (*(char *)((int)&edit->mark + edit->pos + 3) == edit->buffer[edit->pos]) {
        edit->pos = edit->pos + 1;
      }
      else {
        cVar1 = *(char *)((int)&edit->mark + edit->pos + 3);
        *(char *)((int)&edit->mark + edit->pos + 3) = edit->buffer[edit->pos];
        iVar5 = edit->pos;
        edit->buffer[iVar5] = cVar1;
        edit->pos = iVar5 + 1;
      }
    }
    break;
  case 0x20:
    ch = ch & 0xff;
    if (LYlowest_eightbit[current_char_set] <= (int)(ch + 0x40U)) {
      ch = ch + 0x40;
    }
    if ((edit->maxlen < edit->pos) || (edit->maxlen <= edit->strlen)) {
      if (maxMessage != '\0') {
        mustshow = '\x01';
        text = (char *)gettext("Maximum length reached!  Delete text or move off field.");
        statusline(text);
      }
      return ch;
    }
    if (edit->pos < edit->mark) {
      edit->mark = edit->mark + 1;
    }
    else {
      if (edit->mark < ~edit->pos) {
        edit->mark = edit->mark + -1;
      }
    }
    if (-1 < edit->mark) {
      edit->mark = ~edit->mark;
    }
    while (edit->pos <= i) {
      edit->buffer[i + 1] = edit->buffer[i];
      i = i + -1;
    }
    edit->buffer[sVar2 + 1] = '\0';
    edit->buffer[edit->pos] = (char)ch;
    edit->pos = edit->pos + 1;
    break;
  case 0x21:
    edit->mark = edit->pos;
    return 0;
  case 0x22:
    if (edit->mark < 0) {
      edit->mark = ~edit->mark;
    }
    if (edit->mark == edit->pos) {
      return 0;
    }
    iVar5 = edit->pos;
    edit->pos = edit->mark;
    edit->mark = iVar5;
    break;
  case 0x23:
    if (edit->mark < 0) {
      edit->mark = ~edit->mark;
    }
    if (edit->mark == edit->pos) {
      killbuffer[0] = '\0';
      return 0;
    }
    if (edit->pos < edit->mark) {
      LYEdit1(edit,0,0x22,'\0');
    }
    iVar5 = edit->pos - edit->mark;
    local_30 = iVar5;
    if (0x3ff < iVar5) {
      local_30 = 0x3ff;
    }
    LYstrncpy(killbuffer,edit->buffer + edit->mark,local_30);
    i = edit->mark;
    while (*(char *)((int)edit + i + iVar5 + 0x2c) != '\0') {
      edit->buffer[i] = *(char *)((int)edit + i + iVar5 + 0x2c);
      i = i + 1;
    }
    edit->buffer[i] = *(char *)((int)edit + i + iVar5 + 0x2c);
    edit->pos = edit->mark;
    if (-1 < edit->mark) {
      edit->mark = ~edit->mark;
    }
    break;
  case 0x24:
    if (killbuffer[0] == '\0') {
      edit->mark = ~edit->pos;
      return 0;
    }
    sVar2 = strlen(killbuffer);
    if ((edit->maxlen < (int)(edit->pos + sVar2)) || (edit->maxlen < (int)(edit->strlen + sVar2))) {
      if (maxMessage != '\0') {
        mustshow = '\x01';
        text = (char *)gettext("Maximum length reached!  Delete text or move off field.");
        statusline(text);
      }
    }
    else {
      edit->mark = ~edit->pos;
      while (edit->pos <= i) {
        edit->buffer[i + sVar2] = edit->buffer[i];
        i = i + -1;
      }
      i = 0;
      while (i < (int)sVar2) {
        iVar5 = edit->pos;
        edit->buffer[iVar5] = killbuffer[i];
        edit->pos = iVar5 + 1;
        i = i + 1;
      }
    }
  }
  edit->dirty = '\x01';
  sVar2 = strlen(edit->buffer);
  edit->strlen = sVar2;
  return 0;
}



int get_popup_number(char *msg,int *c,int *rel)

{
  int iVar1;
  char cVar2;
  int iVar3;
  char *Msg;
  ushort **ppuVar4;
  int in_GS_OFFSET;
  int local_a8;
  int num;
  char *p;
  char temp [120];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = temp;
  temp[0] = (char)*c;
  temp[1] = '\0';
  mustshow = '\x01';
  statusline(msg);
  iVar3 = LYgetstr(temp,0,0x78,NORECALL);
  if ((iVar3 < 0) || (temp[0] == '\0')) {
    Msg = (char *)gettext("Cancelled!!!");
    HTInfoMsg(Msg);
    *c = 0;
    *rel = 0;
    local_a8 = 0;
  }
  else {
    *rel = 0;
    local_a8 = atoi(p);
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x800) != 0) {
      p = p + 1;
    }
    cVar2 = *p;
    if ((cVar2 == '+') || (cVar2 == '-')) {
      *rel = (int)*p;
      p = p + 1;
      *c = (int)*p;
    }
    else {
      if (cVar2 != '\0') {
        *c = (int)*p;
        p = p + 1;
        *rel = (int)*p;
      }
    }
    if ((*p == 'g') || (*p == 'G')) {
      *c = 0x67;
    }
    else {
      if ((*p == 'p') || (*p == 'P')) {
        *c = 0x70;
      }
      else {
        *c = 0;
      }
    }
    if ((*rel != 0x2b) && (*rel != 0x2d)) {
      *rel = 0;
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_a8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void remember_column(EditFieldData *edit,int offset)

{
  int local_18;
  int x0;
  int y0;
  
  if (LYwin == (WINDOW *)0x0) {
    local_18 = -1;
  }
  else {
    local_18 = (int)LYwin->_curx;
  }
  (&edit->strlen)[offset + 0x108] = local_18;
  return;
}



void fill_edited_line(int prompting,int length,int ch)

{
  int local_1c;
  int local_18;
  int i;
  
  if (prompting == 0) {
    local_1c = s_aedit_pad;
  }
  else {
    local_1c = s_prompt_edit_pad;
  }
  curses_style(local_1c,1);
  i = 0;
  while (i < length) {
    waddch(LYwin,ch & 0xff);
    i = i + 1;
  }
  if (prompting == 0) {
    local_18 = s_aedit_pad;
  }
  else {
    local_18 = s_prompt_edit_pad;
  }
  curses_style(local_18,0);
  return;
}



// WARNING: Removing unreachable block (ram,0x080527bc)
// WARNING: Removing unreachable block (ram,0x0805281f)

void LYRefreshEdit(EditFieldData *edit)

{
  char *s;
  bool bVar1;
  size_t len;
  int pos;
  int pos_00;
  int iVar2;
  FILE *__stream;
  char *data;
  char *pcVar3;
  bool bVar4;
  char *local_94;
  int local_90;
  int local_8c;
  int local_88;
  int local_84;
  int local_80;
  int local_7c;
  int col;
  int j;
  char *next;
  char *last;
  int cell;
  int old_cells;
  int prompting;
  int estyle;
  int rgt_shift;
  int lft_shift;
  char *str;
  int padsize;
  int i;
  int pos_chars;
  int lft_chars;
  int dpy_chars;
  int all_chars;
  int pos_cells;
  int lft_cells;
  int dpy_cells;
  int all_cells;
  int lft_bytes;
  int dpy_bytes;
  int pos_bytes;
  int all_bytes;
  BOOLEAN utf_flag;
  
  lft_shift = 0;
  bVar1 = false;
  if ((edit->dirty != '\0') && (edit->dspwdth != 0)) {
    edit->dirty = '\0';
    len = strlen(edit->buffer);
    edit->strlen = len;
    dpy_cells = LYstrCells(edit->buffer);
    pos = LYstrExtent2(edit->buffer,edit->pos);
    mbcs_glyphs(edit->buffer,edit->xpan);
    mbcs_glyphs(edit->buffer,edit->pos);
    mbcs_glyphs(edit->buffer,len);
    lft_bytes = edit->xpan;
    lft_cells = LYstrExtent2(edit->buffer,edit->xpan);
    if ((edit->dspwdth + lft_cells <= dpy_cells) &&
       ((edit->dspwdth + lft_cells) - edit->margin <= pos)) {
      lft_cells = (pos - edit->dspwdth) + edit->margin;
      pos_00 = cell2char(edit->buffer,lft_cells);
      lft_bytes = mbcs_skip(edit->buffer,pos_00);
    }
    if (pos < edit->margin + lft_cells) {
      lft_cells = pos - edit->margin;
      if (lft_cells < 0) {
        lft_cells = 0;
      }
      pos = cell2char(edit->buffer,lft_cells);
      lft_bytes = mbcs_skip(edit->buffer,pos);
    }
    LYmove(edit->sy,edit->sx);
    if ((edit->panon != '\0') && (lft_cells != 0)) {
      curses_style(s_aedit_arr,1);
      LYmove(edit->sy,edit->sx);
      waddch(LYwin,acs_map._176_4_);
      curses_style(s_aedit_arr,0);
      lft_shift = 1;
    }
    s = edit->buffer + lft_bytes;
    edit->xpan = lft_bytes;
    dpy_cells = dpy_cells - lft_cells;
    if (edit->dspwdth - lft_shift < dpy_cells) {
      bVar1 = true;
      dpy_cells = (edit->dspwdth - lft_shift) + -1;
    }
    do {
      pos = dpy_cells;
      pos_00 = cell2char(s,dpy_cells);
      pos_00 = mbcs_skip(s,pos_00);
      if (!bVar1) break;
      iVar2 = LYstrExtent2(s,pos_00);
      if (dpy_cells < iVar2) {
        iVar2 = dpy_cells + -1;
      }
      dpy_cells = iVar2;
    } while (dpy_cells < pos);
    bVar4 = edit->sy == LYlines + -1;
    prompting = ZEXT14(bVar4);
    if (bVar4) {
      estyle = s_prompt_edit;
    }
    else {
      estyle = s_aedit;
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      if (bVar4) {
        local_94 = "prompt";
      }
      else {
        local_94 = "active";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"STYLE.getstr: switching to <edit.%s>.\n",local_94);
    }
    if (estyle == -1) {
      LYwin->_attrs = 0;
    }
    else {
      curses_style(estyle,1);
    }
    if (edit->hidden == '\0') {
      if ((-1 < edit->mark) && (edit->mark < edit->xpan)) {
        if (bVar4) {
          local_90 = s_prompt_sel;
        }
        else {
          local_90 = s_aedit_sel;
        }
        curses_style(local_90,1);
      }
      remember_column(edit,0);
      i = 0;
      while (i < pos_00) {
        if ((-1 < edit->mark) &&
           (((edit->xpan + i == edit->mark && (edit->mark < edit->pos)) ||
            ((edit->xpan + i == edit->pos && (edit->pos < edit->mark)))))) {
          if (bVar4) {
            local_8c = s_prompt_sel;
          }
          else {
            local_8c = s_aedit_sel;
          }
          curses_style(local_8c,1);
        }
        if ((-1 < edit->mark) &&
           (((edit->xpan + i == edit->mark && (edit->pos < edit->mark)) ||
            ((edit->xpan + i == edit->pos && (edit->mark < edit->pos)))))) {
          if (bVar4) {
            local_88 = s_prompt_sel;
          }
          else {
            local_88 = s_aedit_sel;
          }
          curses_style(local_88,0);
        }
        if (((s[i] == '\x01') || (s[i] == '\x02')) ||
           (((s[i] == -0x60 && ((HTPassHighCtrlRaw == '\0' && (HTCJK == NOCJK)))) &&
            ((LYCharSet_UC[current_char_set].enc == 2 ||
             (((&LYCharSet_UC[0].codepage)[(current_char_set * 2 + 1) * 4] & 0x80U) != 0)))))) {
          waddch(LYwin,0x20);
        }
        else {
          if (s[i] == '\t') {
            col = (&edit->strlen)[i + 0x108] - edit->sx;
            while (col = col + 1, (col & 7U) != 0) {
              waddch(LYwin,0x20);
            }
            waddch(LYwin,0x20);
          }
          else {
            waddch(LYwin,(uint)(byte)s[i]);
          }
        }
        remember_column(edit,i + 1);
        i = i + 1;
      }
      if ((-1 < edit->mark) &&
         (((edit->xpan + pos_00 <= edit->mark && (edit->pos < edit->xpan + pos_00)) ||
          ((edit->mark < edit->xpan + pos_00 && (edit->xpan + pos_00 <= edit->pos)))))) {
        if (bVar4) {
          local_84 = s_prompt_sel;
        }
        else {
          local_84 = s_aedit_sel;
        }
        curses_style(local_84,0);
      }
    }
    else {
      pos = LYCharSet_UC[current_char_set].enc;
      cell = 0;
      fill_edited_line(0,dpy_cells,0x2a);
      i = 0;
      do {
        data = s + i;
        pcVar3 = LYmbcs_skip_glyphs(data,1,pos == 7);
        while (i < (int)(pcVar3 + -(int)s)) {
          (&edit->strlen)[i + 0x108] = edit->sx + cell;
          i = i + 1;
        }
        iVar2 = LYstrExtent2(data,(int)(pcVar3 + -(int)data));
        cell = cell + iVar2;
      } while (i < pos_00);
      (&edit->strlen)[i + 0x108] = edit->sx + cell;
    }
    fill_edited_line(prompting,edit->dspwdth + (edit->sx - (&edit->strlen)[pos_00 + 0x108]),
                     (int)edit->pad);
    if (((edit->panon != '\0') && (pos_00 != 0)) && (bVar1)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Draw right-scroller offset (%d + %d)\n",dpy_cells,lft_shift);
      }
      if (bVar4) {
        local_80 = s_prompt_edit_arr;
      }
      else {
        local_80 = s_aedit_arr;
      }
      curses_style(local_80,1);
      LYmove(edit->sy,edit->sx + dpy_cells + lft_shift);
      waddch(LYwin,acs_map._172_4_);
      if (bVar4) {
        local_7c = s_prompt_edit_arr;
      }
      else {
        local_7c = s_aedit_arr;
      }
      curses_style(local_7c,0);
    }
    LYmove(edit->sy,(&edit->strlen)[(edit->pos - edit->xpan) + 0x108]);
    if (estyle != -1) {
      curses_style(estyle,0);
    }
    LYrefresh();
  }
  return;
}



void reinsertEdit(EditFieldData *edit,char *result)

{
  uint uVar1;
  
  if (result != (char *)0x0) {
    LYEdit1(edit,0,0xc,'\0');
    while (*result != '\0') {
      uVar1 = EditBinding((int)*result);
      LYEdit1(edit,(int)*result,uVar1 & 0xffffff7f,'\0');
      result = result + 1;
    }
  }
  return;
}



int caselessCmpList(void *a,void *b)

{
  int iVar1;
  
  iVar1 = strcasecomp(*(char **)a,*(char **)b);
  return iVar1;
}



int normalCmpList(void *a,void *b)

{
  int iVar1;
  
  iVar1 = strcmp(*(char **)a,*(char **)b);
  return iVar1;
}



char ** sortedList(HTList *list,BOOLEAN ignorecase)

{
  uint __nmemb;
  char **__base;
  int iVar1;
  char *local_30;
  code *local_2c;
  char **result;
  uint jk;
  uint k;
  uint j;
  uint count;
  
  __nmemb = HTList_count(list);
  j = 0;
  __base = (char **)calloc(__nmemb + 1,4);
  if (__base == (char **)0x0) {
    outofmem("./LYStrings.c","sortedList");
  }
  while ((list != (HTList *)0x0 && (list->next != (HTList *)0x0))) {
    if ((list == (HTList *)0x0) || (list = list->next, list == (HTList *)0x0)) {
      local_30 = (char *)0x0;
    }
    else {
      local_30 = (char *)list->object;
    }
    __base[j] = local_30;
    j = j + 1;
  }
  if (1 < __nmemb) {
    if (ignorecase == '\0') {
      local_2c = normalCmpList;
    }
    else {
      local_2c = caselessCmpList;
    }
    qsort(__base,__nmemb,4,local_2c);
    j = 0;
    while (__base[j] != (char *)0x0) {
      k = j;
      while (__base[k] != (char *)0x0) {
        iVar1 = strcmp(__base[j],__base[k]);
        if (iVar1 != 0) break;
        k = k + 1;
      }
      if (j != k - 1) {
        jk = j;
        while (__base[jk] = __base[(jk + (k - 1)) - j], __base[jk] != (char *)0x0) {
          jk = jk + 1;
        }
      }
      j = j + 1;
    }
  }
  return __base;
}



int LYarrayLength(char **list)

{
  char *pcVar1;
  int result;
  
  result = 0;
  while (pcVar1 = *list, list = list + 1, pcVar1 != (char *)0x0) {
    result = result + 1;
  }
  return result;
}



int LYarrayWidth(char **list)

{
  char *__s;
  size_t sVar1;
  int check;
  int result;
  
  result = 0;
  while (*list != (char *)0x0) {
    __s = *list;
    list = list + 1;
    sVar1 = strlen(__s);
    if (result < (int)sVar1) {
      result = sVar1;
    }
  }
  return result;
}



void FormatChoiceNum(char *dst,int num_choices,int choice,char *value)

{
  int local_18;
  int digits;
  
  if (num_choices < 0) {
    LYstrncpy(dst,value,0x3ff);
  }
  else {
    if (num_choices < 10) {
      local_18 = 1;
    }
    else {
      local_18 = 2;
    }
    sprintf(dst,"%*d: %.*s",local_18,choice + 1,0x3f7 - local_18,value);
  }
  return;
}



uint options_width(char **list)

{
  size_t sVar1;
  int count;
  uint width;
  
  width = 0;
  count = 0;
  while (list[count] != (char *)0x0) {
    sVar1 = strlen(list[count]);
    if (width < sVar1) {
      width = strlen(list[count]);
    }
    count = count + 1;
  }
  return width;
}



void draw_option(WINDOW *win,int entry,int width,BOOLEAN reversed,int num_choices,int number,
                char *value)

{
  int iVar1;
  int in_GS_OFFSET;
  int local_428;
  int local_424;
  char Cnum [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FormatChoiceNum(Cnum,num_choices,number,"");
  wmove(win,entry,1);
  curses_w_style(win,s_menu_entry,1);
  waddch(win,0x20);
  curses_w_style(win,s_menu_entry,0);
  curses_w_style(win,s_menu_number,1);
  waddnstr(win,Cnum,0xffffffff);
  curses_w_style(win,s_menu_number,0);
  if (reversed == '\0') {
    local_428 = s_menu_entry;
  }
  else {
    local_428 = s_menu_active;
  }
  curses_w_style(win,local_428,1);
  LYpaddstr(win,width,value);
  if (reversed == '\0') {
    local_424 = s_menu_entry;
  }
  else {
    local_424 = s_menu_active;
  }
  curses_w_style(win,local_424,0);
  curses_w_style(win,s_menu_entry,1);
  waddch(win,0x20);
  curses_w_style(win,s_menu_entry,0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08053bc9)

int LYhandlePopupList(int cur_choice,int ly,int lx,char **choices,int width,int i_length,
                     int disabled,BOOLEAN for_mouse)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  BOOLEAN first;
  char prev_target_buffer [1024];
  char prev_target [1024];
  int iVar5;
  int iVar6;
  int iVar7;
  int local_530;
  WINDOW *win;
  int entry;
  FILE *__stream;
  uint uVar8;
  char *src;
  int in_GS_OFFSET;
  bool formfield;
  int iVar9;
  int local_52c;
  int local_50c;
  int local_508;
  int local_504;
  uint local_500;
  uint local_4fc;
  uint local_4f8;
  int local_4f4;
  int local_4f0;
  int local_4ec;
  char *msg;
  int curpage;
  int row;
  int limit;
  int check;
  int can_scroll_was;
  int can_scroll;
  char **Cptr;
  char *popup_status_msg;
  int number;
  int QueryNum;
  int QueryTotal;
  RecallType recall;
  int ch;
  char *cp;
  int npages;
  int Lnum;
  int lines_to_show;
  int window_offset;
  int length;
  int bottom;
  int top;
  int max_choices;
  int num_choices;
  WINDOW *form_window;
  int orig_choice;
  int rel;
  int j;
  int i;
  int cmd;
  int c;
  BOOLEAN ReDraw;
  BOOLEAN FirstRecall;
  BOOLEAN numbered;
  char buffer [1024];
  char Cnum [64];
  
  local_508 = cur_choice;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  formfield = keypad_mode == 0;
  c = 0;
  cmd = 0;
  rel = 0;
  window_offset = 0;
  ch = 0;
  bVar3 = true;
  bVar4 = false;
  can_scroll = 0;
  if (cur_choice < 0) {
    cur_choice = 0;
  }
  if (first != '\0') {
    prev_target_buffer[0] = '\0';
    first = '\0';
  }
  prev_target[0] = '\0';
  if (search_queries == (HTList *)0x0) {
    local_50c = 0;
  }
  else {
    local_50c = HTList_count(search_queries);
  }
  QueryTotal = local_50c;
  recall = (RecallType)(0 < local_50c);
  QueryNum = local_50c;
  iVar5 = LYarrayLength(choices);
  iVar6 = iVar5 + -1;
  if (width < 1) {
    width = options_width(choices);
  }
  if (formfield) {
    Lnum = 0;
    max_choices = -1;
  }
  else {
    sprintf(Cnum,"%d: ",iVar6);
    Lnum = strlen(Cnum);
    max_choices = iVar6;
  }
  top = ~cur_choice + ly;
  if (top < 0) {
    top = 0;
  }
  iVar7 = iVar6;
  if (0 < i_length) {
    iVar7 = i_length + -1;
  }
  i_length = iVar7;
  bottom = top + i_length + 3;
  if (user_mode == 0) {
    lines_to_show = LYlines + -4;
  }
  else {
    lines_to_show = LYlines + -2;
  }
  if (((for_mouse != '\0') && (user_mode == 0)) && (2 < lines_to_show)) {
    lines_to_show = lines_to_show + -1;
  }
  if (lines_to_show < bottom) {
    if (lines_to_show < i_length + 3) {
      top = 0;
      bottom = i_length + 3;
      if (lines_to_show < bottom) {
        bottom = lines_to_show + 1;
      }
    }
    else {
      top = lines_to_show + (-2 - i_length);
      bottom = lines_to_show + 1;
    }
  }
  iVar7 = (bottom - top) + -2;
  if (iVar7 <= iVar6) {
    can_scroll = 4;
  }
  if (bottom < ly + 2) {
    bottom = ly + 2;
    if (lines_to_show + 1 < bottom) {
      bottom = lines_to_show + 1;
    }
    top = (bottom - iVar7) + -2;
  }
  if ((for_mouse != '\0') && (local_530 = width + Lnum + 4, local_530 < LYcols)) {
    if (LYcols < lx + -1 + local_530) {
      lx = (LYcols + 1) - local_530;
    }
    else {
      if (lx < 1) {
        lx = 1;
      }
    }
  }
  width = width + Lnum;
  bottom = bottom - top;
  if (((iVar6 < 1) || (iVar6 < cur_choice)) ||
     (win = LYstartPopup(&top,&lx,&bottom,&width), win == (WINDOW *)0x0)) {
LAB_08055183:
    if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
      return local_508;
    }
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  width = width - Lnum;
  bottom = bottom + top;
  if (disabled == 0) {
    if (for_mouse == '\0') {
      popup_status_msg =
           (char *)gettext(
                          "(Choice list) Hit return and use arrow keys and return to select option."
                          );
    }
    else {
      popup_status_msg =
           (char *)gettext("Left mouse button or return to select, arrow keys to scroll.");
    }
  }
  else {
    popup_status_msg =
         (char *)gettext("UNMODIFIABLE choice list.  Use return or arrow keys to review or leave.");
  }
  mustshow = '\x01';
  statusline(popup_status_msg);
  if (iVar7 <= cur_choice) {
    window_offset = (cur_choice - iVar7) + 1;
  }
  if (iVar7 < iVar5) {
    local_504 = (iVar6 + iVar7) / iVar7;
  }
  else {
    local_504 = 1;
  }
redraw:
  i = 0;
  while (i <= iVar6) {
    if ((window_offset <= i) && (i - window_offset < iVar7)) {
      draw_option(win,(i + 1) - window_offset,width,'\0',max_choices,i,choices[i]);
    }
    i = i + 1;
  }
  LYbox(win,formfield);
  Cptr = (char **)0x0;
switchD_08053f70_caseD_0:
  do {
    if (cmd == 0x27) {
LAB_0805514e:
      LYsubwindow((WINDOW *)0x0);
      if (disabled == 0) {
        local_4ec = cur_choice;
      }
      else {
        local_4ec = local_508;
      }
      local_508 = local_4ec;
      goto LAB_08055183;
    }
    if (can_scroll != 0) {
      if (window_offset == 0) {
        local_500 = 0;
      }
      else {
        local_500 = 2;
      }
      bVar2 = iVar7 <= iVar6 - window_offset;
      can_scroll = bVar2 | local_500;
      if (local_500 != 0) {
        wmove(win,1,width + Lnum + 3);
        curses_w_style(win,s_menu_sb,1);
        waddch(win,acs_map._180_4_);
        curses_w_style(win,s_menu_sb,0);
      }
      if (bVar2) {
        wmove(win,iVar7,width + Lnum + 3);
        curses_w_style(win,s_menu_sb,1);
        waddch(win,acs_map._184_4_);
        curses_w_style(win,s_menu_sb,0);
      }
    }
    if (Cptr != (char **)0x0) {
      draw_option(win,(i + 1) - window_offset,width,'\0',max_choices,i,Cptr[i]);
    }
    iVar5 = cur_choice;
    Cptr = choices;
    i = cur_choice;
    entry = (cur_choice + 1) - window_offset;
    local_530 = 1;
    local_52c = max_choices;
    draw_option(win,entry,width,'\x01',max_choices,cur_choice,choices[cur_choice]);
    LYstowCursor(win,entry,1);
    c = LYgetch_choice();
    if (((term_options == '\0') && (c != 3)) && (c != 7)) {
      if (c == 0xffffffff) {
        if (keymap[0] != 0x2f) goto LAB_08053e90;
        goto LAB_08053e81;
      }
      if ((c & 0x8800U) == 0) {
        if (keymap[(c & 0x7ffU) + 1] == 0x2f) goto LAB_08053e81;
      }
      else {
        if ((c & 0xffU) == 0x2f) goto LAB_08053e81;
      }
LAB_08053e90:
      if (c == 0x11d) {
        cmd = fancy_mouse(win,entry,&cur_choice);
        if (cmd < 0) goto redraw;
        if (cmd == 0x27) goto LAB_0805514e;
      }
      else {
        if (c == 0xffffffff) {
          local_4fc = (uint)keymap[0];
        }
        else {
          if ((c & 0x8800U) == 0) {
            local_4f8 = (uint)keymap[(c & 0x7ffU) + 1];
          }
          else {
            local_4f8 = c & 0xff;
          }
          local_4fc = local_4f8;
        }
        cmd = local_4fc;
      }
    }
    else {
LAB_08053e81:
      cmd = 0xd;
    }
    switch(cmd) {
    case 0xd:
    case 0xe:
    case 0x25:
    case 0x2f:
      cmd = 0x27;
      cur_choice = local_508;
      break;
    case 0xf:
      if ((iVar6 - iVar7) + 1 != window_offset) {
        cur_choice = cur_choice - window_offset;
        window_offset = window_offset + iVar7;
        if (iVar6 - iVar7 < window_offset) {
          window_offset = (iVar6 - iVar7) + 1;
        }
        cur_choice = cur_choice + window_offset;
        goto redraw;
      }
      if (cur_choice < iVar6) {
        cur_choice = iVar6;
      }
      break;
    case 0x10:
      if (window_offset != 0) {
        cur_choice = cur_choice - window_offset;
        window_offset = window_offset - iVar7;
        if (window_offset < 0) {
          window_offset = 0;
        }
        cur_choice = cur_choice + window_offset;
        goto redraw;
      }
      if (0 < cur_choice) {
        cur_choice = 0;
      }
      break;
    case 0x11:
      cur_choice = cur_choice + -2;
      if (cur_choice < 0) {
        cur_choice = 0;
      }
      if (cur_choice - window_offset < 0) {
        window_offset = window_offset + -2;
        if (window_offset < 0) {
          window_offset = 0;
        }
        goto redraw;
      }
      break;
    case 0x12:
      cur_choice = cur_choice + 2;
      if (iVar6 < cur_choice) {
        cur_choice = iVar6;
      }
      if (iVar7 <= cur_choice - window_offset) {
        window_offset = window_offset + 2;
        if ((iVar6 - iVar7) + 1 < window_offset) {
          window_offset = (iVar6 - iVar7) + 1;
        }
        goto redraw;
      }
      break;
    case 0x13:
      cur_choice = cur_choice - iVar7 / 2;
      if (cur_choice < 0) {
        cur_choice = 0;
      }
      if (cur_choice - window_offset < 0) {
        window_offset = window_offset - iVar7 / 2;
        if (window_offset < 0) {
          window_offset = 0;
        }
        goto redraw;
      }
      break;
    case 0x14:
      cur_choice = iVar7 / 2 + cur_choice;
      if (iVar6 < cur_choice) {
        cur_choice = iVar6;
      }
      if (iVar7 <= cur_choice - window_offset) {
        window_offset = window_offset + iVar7 / 2;
        if ((iVar6 - iVar7) + 1 < window_offset) {
          window_offset = (iVar6 - iVar7) + 1;
        }
        goto redraw;
      }
      break;
    case 0x15:
      lynx_force_repaint();
      LYrefresh();
      break;
    case 0x16:
      cur_choice = 0;
      if (0 < window_offset) {
        window_offset = 0;
        goto redraw;
      }
      break;
    case 0x17:
      cur_choice = iVar6;
      if ((iVar6 - iVar7) + 1 != window_offset) {
        window_offset = (iVar6 - iVar7) + 1;
        goto redraw;
      }
      break;
    case 0x1a:
    case 0x1c:
    case 0x1e:
    case 0x20:
      if (0 < cur_choice) {
        cur_choice = cur_choice + -1;
      }
      if (cur_choice - window_offset < 0) {
        window_offset = window_offset + -1;
        goto redraw;
      }
      break;
    case 0x1b:
    case 0x1d:
    case 0x1f:
    case 0x21:
      if (cur_choice < iVar6) {
        cur_choice = cur_choice + 1;
      }
      if (iVar7 <= cur_choice - window_offset) {
        window_offset = window_offset + 1;
        goto redraw;
      }
      break;
    case 0x33:
      goto switchD_08053f70_caseD_33;
    case 0x35:
      if (((recall != NORECALL) && (prev_target_buffer[0] == '\0')) &&
         (src = (char *)HTList_objectAt(search_queries,0), src != (char *)0x0)) {
        LYstrncpy((char *)0x81ab8c0,src,0x3ff);
        QueryNum = 0;
        bVar3 = false;
      }
      strcpy((char *)0x81abcc0,(char *)0x81ab8c0);
switchD_08053f70_caseD_33:
      if (prev_target[0] == '\0') {
        mustshow = '\x01';
        src = (char *)gettext("Enter a whereis query: ");
        statusline(src);
        ch = LYgetstr((char *)0x81abcc0,0,0x400,recall);
        if (-1 < ch) goto check_recall;
        src = (char *)gettext("Cancelled!!!");
        HTInfoMsg(src);
      }
      else {
check_recall:
        do {
          while( true ) {
            if ((prev_target[0] == '\0') &&
               ((recall == NORECALL || ((ch != 0x100 && (ch != 0x101)))))) {
              src = (char *)gettext("Cancelled!!!");
              HTInfoMsg(src);
              goto restore_popup_statusline;
            }
            if ((recall == NORECALL) || (ch != 0x100)) break;
            if (bVar3) {
              bVar3 = false;
              QueryNum = QueryTotal;
              if (prev_target_buffer[0] == '\0') {
                QueryNum = 0;
              }
              else {
                do {
                  QueryNum = QueryNum + -1;
                  if (QueryNum < 1) break;
                  src = (char *)HTList_objectAt(search_queries,QueryNum);
                } while ((src == (char *)0x0) ||
                        (local_530 = strcmp((char *)0x81ab8c0,src), local_530 != 0));
              }
            }
            else {
              QueryNum = QueryNum + 1;
            }
            if (QueryTotal <= QueryNum) {
              QueryNum = 0;
            }
            src = (char *)HTList_objectAt(search_queries,QueryNum);
            if (src == (char *)0x0) {
LAB_08054e06:
              strcpy((char *)0x81ab8c0,(char *)0x81abcc0);
              HTAddSearchQuery((char *)0x81ab8c0);
              j = 1;
              goto LAB_08054ec4;
            }
            LYstrncpy((char *)0x81abcc0,src,0x3ff);
            if ((prev_target_buffer[0] == '\0') ||
               (local_530 = strcmp((char *)0x81ab8c0,(char *)0x81abcc0), local_530 != 0)) {
              if (((prev_target_buffer[0] == '\0') || (QueryTotal != 2)) &&
                 ((prev_target_buffer[0] != '\0' || (QueryTotal != 1)))) {
                mustshow = '\x01';
                src = (char *)gettext("Edit a previous query: ");
                statusline(src);
              }
              else {
                mustshow = '\x01';
                src = (char *)gettext("Edit the previous query: ");
                statusline(src);
              }
            }
            else {
              mustshow = '\x01';
              src = (char *)gettext("Edit the current query: ");
              statusline(src);
            }
            ch = LYgetstr((char *)0x81abcc0,0,0x400,recall);
            if (ch < 0) {
              src = (char *)gettext("Cancelled!!!");
              HTInfoMsg(src);
              goto restore_popup_statusline;
            }
          }
          if ((recall == NORECALL) || (ch != 0x101)) goto LAB_08054e06;
          if (bVar3) {
            bVar3 = false;
            if (prev_target_buffer[0] == '\0') {
              QueryNum = QueryTotal + -1;
            }
            else {
              QueryNum = 0;
              while ((QueryNum < QueryTotal + -1 &&
                     ((src = (char *)HTList_objectAt(search_queries,QueryNum), src == (char *)0x0 ||
                      (local_530 = strcmp((char *)0x81ab8c0,src), local_530 != 0))))) {
                QueryNum = QueryNum + 1;
              }
            }
          }
          else {
            QueryNum = QueryNum + -1;
          }
          if (QueryNum < 0) {
            QueryNum = QueryTotal + -1;
          }
          src = (char *)HTList_objectAt(search_queries,QueryNum);
          if (src == (char *)0x0) goto LAB_08054e06;
          LYstrncpy((char *)0x81abcc0,src,0x3ff);
          if ((prev_target_buffer[0] == '\0') ||
             (local_530 = strcmp((char *)0x81ab8c0,(char *)0x81abcc0), local_530 != 0)) {
            if (((prev_target_buffer[0] == '\0') || (QueryTotal != 2)) &&
               ((prev_target_buffer[0] != '\0' || (QueryTotal != 1)))) {
              mustshow = '\x01';
              src = (char *)gettext("Edit a previous query: ");
              statusline(src);
            }
            else {
              mustshow = '\x01';
              src = (char *)gettext("Edit the previous query: ");
              statusline(src);
            }
          }
          else {
            mustshow = '\x01';
            src = (char *)gettext("Edit the current query: ");
            statusline(src);
          }
          ch = LYgetstr((char *)0x81abcc0,0,0x400,recall);
        } while (-1 < ch);
        src = (char *)gettext("Cancelled!!!");
        HTInfoMsg(src);
      }
      goto restore_popup_statusline;
    case 0x50:
      c = 0;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      src = (char *)gettext("Select option (or page) number: ");
      number = get_popup_number(src,&c,&rel);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"got popup option number %d, ",number);
      }
      iVar9 = c;
      entry = rel;
      iVar5 = cur_choice;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"rel=\'%c\', c=\'%c\', cur_choice=%d\n",entry,iVar9,iVar5);
        local_530 = iVar9;
        local_52c = iVar5;
      }
      if (c == 0x70) {
        if (iVar7 < cur_choice + 1) {
          local_4f4 = (cur_choice + iVar7) / iVar7;
        }
        else {
          local_4f4 = 1;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"  curpage=%d\n",local_4f4,local_530,local_52c);
        }
        if (rel == 0x2b) {
          number = number + local_4f4;
        }
        else {
          if (rel == 0x2d) {
            number = local_4f4 - number;
          }
        }
      }
      else {
        if (rel == 0x2b) {
          number = cur_choice + number + 1;
        }
        else {
          if (rel == 0x2d) {
            number = (cur_choice - number) + 1;
          }
        }
      }
      if ((rel != 0) && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"new number=%d\n",number,local_530,local_52c);
      }
      if (c != 0x70) {
        if (0 < number) {
          iVar5 = number + -1;
          if ((iVar5 <= iVar6) && (c == 0)) {
            cmd = 0x27;
            cur_choice = iVar5;
            break;
          }
          if (c == 0x67) {
            if (cur_choice == iVar5) {
              msg = (char *)0x0;
              src = (char *)gettext("Option number %d already is current.");
              HTSprintf0(&msg,src,number);
              HTUserMsg(msg);
              if (msg != (char *)0x0) {
                free(msg);
                msg = (char *)0x0;
              }
              mustshow = '\x01';
              statusline(popup_status_msg);
              break;
            }
            if (iVar5 <= iVar6) {
              uVar8 = iVar5 - cur_choice;
              if (((int)uVar8 < 1) || (iVar5 - window_offset < iVar7)) {
                if ((iVar5 - window_offset < 0) &&
                   (window_offset =
                         window_offset - (((int)uVar8 >> 0x1f ^ uVar8) - ((int)uVar8 >> 0x1f)),
                   window_offset < 0)) {
                  window_offset = 0;
                }
              }
              else {
                window_offset = window_offset + uVar8;
                if ((iVar6 - iVar7) + 1 < window_offset) {
                  window_offset = (iVar6 - iVar7) + 1;
                }
              }
              mustshow = '\x01';
              cur_choice = iVar5;
              statusline(popup_status_msg);
              goto redraw;
            }
            src = (char *)gettext("You have entered an invalid option number.");
            HTUserMsg(src);
          }
        }
        mustshow = '\x01';
        statusline(popup_status_msg);
        break;
      }
      if (number < 2) {
        if (window_offset != 0) {
          window_offset = 0;
          cur_choice = 0;
          mustshow = '\x01';
          statusline(popup_status_msg);
          goto redraw;
        }
        src = (char *)gettext("You are already at the beginning of this option list.");
        HTUserMsg(src);
        mustshow = '\x01';
        statusline(popup_status_msg);
      }
      else {
        if (number < local_504) {
          if ((number + -1) * iVar7 - window_offset != 0) {
            window_offset = (number + -1) * iVar7;
            mustshow = '\x01';
            cur_choice = window_offset;
            statusline(popup_status_msg);
            goto redraw;
          }
          msg = (char *)0x0;
          src = (char *)gettext("You are already at page %d of this option list.");
          HTSprintf0(&msg,src,number);
          HTUserMsg(msg);
          if (msg != (char *)0x0) {
            free(msg);
            msg = (char *)0x0;
          }
          mustshow = '\x01';
          statusline(popup_status_msg);
        }
        else {
          if (window_offset < (iVar6 - iVar7) + 1) {
            window_offset = (local_504 + -1) * iVar7;
            if (iVar6 - iVar7 < window_offset) {
              window_offset = (iVar6 - iVar7) + 1;
            }
            if (cur_choice < window_offset) {
              cur_choice = window_offset;
            }
            mustshow = '\x01';
            statusline(popup_status_msg);
            goto redraw;
          }
          src = (char *)gettext("You are already at the end of this option list.");
          HTUserMsg(src);
          mustshow = '\x01';
          statusline(popup_status_msg);
        }
      }
    }
  } while( true );
LAB_08054ec4:
  if (choices[iVar5 + j] == (char *)0x0) goto LAB_08054ee5;
  FormatChoiceNum(buffer,max_choices,iVar5 + j,choices[iVar5 + j]);
  if (case_sensitive == '\0') {
    src = LYstrstr(buffer,(char *)0x81ab8c0);
  }
  else {
    src = strstr(buffer,(char *)0x81ab8c0);
  }
  if (src != (char *)0x0) goto LAB_08054ee5;
  j = j + 1;
  goto LAB_08054ec4;
LAB_08054ee5:
  if (choices[iVar5 + j] == (char *)0x0) {
    if (cur_choice == 0) {
      src = (char *)gettext("\'%s\' not found!");
      HTUserMsg2(src,(char *)0x81ab8c0);
    }
    else {
      j = 0;
      while (j < cur_choice) {
        FormatChoiceNum(buffer,max_choices,j + 1,choices[j]);
        if (case_sensitive == '\0') {
          src = LYstrstr(buffer,(char *)0x81ab8c0);
        }
        else {
          src = strstr(buffer,(char *)0x81ab8c0);
        }
        if (src != (char *)0x0) break;
        j = j + 1;
      }
      if (j < cur_choice) {
        j = cur_choice - j;
        cur_choice = cur_choice - j;
        if (cur_choice - window_offset < 0) {
          window_offset = window_offset - j;
          if (window_offset < 0) {
            window_offset = 0;
          }
          bVar4 = true;
        }
      }
      else {
        src = (char *)gettext("\'%s\' not found!");
        HTUserMsg2(src,(char *)0x81ab8c0);
      }
    }
  }
  else {
    cur_choice = cur_choice + j;
    if (iVar7 <= cur_choice - window_offset) {
      window_offset = window_offset + j;
      if ((iVar6 - iVar7) + 1 < window_offset) {
        window_offset = (iVar6 - iVar7) + 1;
      }
      bVar4 = true;
    }
  }
restore_popup_statusline:
  mustshow = '\x01';
  statusline(popup_status_msg);
  prev_target[0] = '\0';
  if (search_queries == (HTList *)0x0) {
    local_4f0 = 0;
  }
  else {
    local_4f0 = HTList_count(search_queries);
  }
  QueryTotal = local_4f0;
  recall = (RecallType)(0 < local_4f0);
  QueryNum = local_4f0;
  if (bVar4) goto code_r0x08055122;
  goto switchD_08053f70_caseD_0;
code_r0x08055122:
  bVar4 = false;
  goto redraw;
}



int LYgetstr(char *inputline,int hidden,size_t bufsize,RecallType recall)

{
  int iVar1;
  bool bVar2;
  FILE *__stream;
  int iVar3;
  HTList *list_00;
  char **list_01;
  char *result;
  size_t sVar4;
  uchar *puVar5;
  uint uVar6;
  int iVar7;
  int in_GS_OFFSET;
  bool bVar8;
  int local_44a0;
  int local_449c;
  int local_4498;
  int local_4490;
  int local_448c;
  uchar *e1;
  int len;
  uchar *e;
  uchar *s;
  int num_options;
  int cur_choice;
  int old_x;
  int old_y;
  char **data;
  HTList *list;
  int last_xlkc;
  int last_xlec;
  int xlec;
  int ch;
  int MaxStringSize;
  int y;
  int x;
  BOOLEAN refresh_mb;
  EditFieldData MyEdit;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  xlec = -2;
  last_xlkc = -1;
  bVar2 = true;
  if (LYwin == (WINDOW *)0x0) {
    local_44a0 = -1;
  }
  else {
    local_44a0 = (int)LYwin->_curx;
  }
  if (bufsize < 0x400) {
    local_449c = bufsize - 1;
  }
  else {
    local_449c = 0x3ff;
  }
  LYSetupEdit(&MyEdit,inputline,local_449c,(LYcols - (uint)(LYShowScrollbar != '\0')) - local_44a0);
  MyEdit.hidden = (BOOLEAN)hidden;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"called LYgetstr\n");
  }
  do {
    do {
      iVar7 = xlec;
      if (bVar2) {
        LYRefreshEdit(&MyEdit);
      }
      ch = LYReadCmdKey(3);
    } while ((!bVar2) && (iVar3 = EditBinding(ch), iVar3 != 1));
    if ((term_letter != '\0') || ((term_options != '\0' || (term_message != '\0')))) {
      ch = 7;
    }
    if ((recall != NORECALL) && ((ch == 0x100 || (ch == 0x101)))) {
      LYstrncpy(inputline,MyEdit.buffer,bufsize);
      LYAddToCloset(recall,MyEdit.buffer);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYgetstr(%s) recall\n",inputline);
      }
      local_4498 = ch;
      goto LAB_08055ac1;
    }
    ch = ch | MyEdit.current_modifiers;
    MyEdit.current_modifiers = 0;
    if (last_xlkc != -1) {
      if (ch == last_xlkc) {
        ch = ch | 0x1000;
      }
      last_xlkc = -1;
    }
    if (ch == -1) {
      bVar8 = keymap[0] == 0x15;
    }
    else {
      if ((ch & 0x8800U) == 0) {
        bVar8 = keymap[(ch & 0x7ffU) + 1] == 0x15;
      }
      else {
        bVar8 = (ch & 0xffU) == 0x15;
      }
    }
    if (!bVar8) {
      xlec = EditBinding(ch);
      if (((xlec & 0x80U) == 0) || ((xlec & 0x1000U) != 0)) {
        last_xlkc = -1;
      }
      else {
        last_xlkc = ch;
        xlec = xlec & 0xffffff7f;
      }
      switch(xlec) {
      default:
        if ((xlec & 0x1000U) == 0) {
          uVar6 = EditBinding(ch);
          iVar7 = LYEdit1(&MyEdit,ch,uVar6 & 0xffffff7f,'\0');
          if (iVar7 == 0) {
            if ((((bVar2) && (HTCJK != NOCJK)) && (0x80 < ch)) && (ch < 0xff)) {
              bVar2 = false;
            }
            else {
              bVar2 = true;
            }
          }
          else {
            if (!bVar2) {
              LYEdit1(&MyEdit,0,9,'\0');
            }
          }
        }
        break;
      case 2:
        LYstrncpy(inputline,MyEdit.buffer,bufsize);
        if (hidden == 0) {
          LYAddToCloset(recall,MyEdit.buffer);
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYgetstr(%s) LYE_ENTER\n",inputline);
        }
        local_4498 = ch;
LAB_08055ac1:
        if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
          __stack_chk_fail();
        }
        return local_4498;
      case 3:
        if ((xlec == iVar7) && (recall != NORECALL)) {
          list_00 = whichRecall(recall);
          if ((list_00 != (HTList *)0x0) && (list_00->next != (HTList *)0x0)) {
            list_01 = sortedList(list_00,recall == RECALL_CMD);
            cur_choice = 0;
            iVar7 = LYarrayLength(list_01);
            while ((cur_choice < iVar7 &&
                   (iVar3 = strcasecomp(list_01[cur_choice],MyEdit.buffer), iVar3 < 0))) {
              cur_choice = cur_choice + 1;
            }
            if (LYwin == (WINDOW *)0x0) {
              local_4490 = -1;
              local_448c = -1;
            }
            else {
              local_4490 = (int)LYwin->_cury;
              local_448c = (int)LYwin->_curx;
            }
            iVar7 = LYhandlePopupList(cur_choice,0,local_448c,list_01,-1,-1,0,'\0');
            if (-1 < iVar7) {
              if (recall == RECALL_CMD) {
                mustshow = '\x01';
                statusline(": ");
              }
              reinsertEdit(&MyEdit,list_01[iVar7]);
            }
            LYmove(local_4490,local_448c);
            if (list_01 != (char **)0x0) {
              free(list_01);
            }
          }
        }
        else {
          result = LYFindInCloset(recall,MyEdit.buffer);
          reinsertEdit(&MyEdit,result);
        }
        break;
      case 4:
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYgetstr LYE_STOP\n");
        }
        textfields_need_activation = '\x01';
        local_4498 = -1;
        goto LAB_08055ac1;
      case 5:
        *inputline = '\0';
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYgetstr LYE_ABORT\n");
        }
        local_4498 = -1;
        goto LAB_08055ac1;
      case 6:
      case 0x17:
        break;
      case 0x1d:
        MyEdit.current_modifiers = MyEdit.current_modifiers | 0x4000;
        break;
      case 0x1e:
        MyEdit.current_modifiers = MyEdit.current_modifiers | 0x2000;
        break;
      case 0x25:
        e1 = (uchar *)get_clip_grab();
        if (e1 != (uchar *)0x0) {
          sVar4 = strlen((char *)e1);
          puVar5 = e1 + sVar4;
          s = e1;
          if (0 < (int)sVar4) {
            while (e1 < puVar5) {
              if (*e1 < 0x20) {
                if (s < e1) {
                  LYEditInsert(&MyEdit,s,(int)(e1 + -(int)s),0,'\x01');
                }
                s = e1;
                if (*e1 != '\t') break;
                LYEditInsert(&MyEdit," ",1,0,'\x01');
                e1 = e1 + 1;
                s = e1;
              }
              else {
                e1 = e1 + 1;
              }
            }
            if (s < e1) {
              LYEditInsert(&MyEdit,s,(int)(e1 + -(int)s),0,'\x01');
            }
          }
          get_clip_release();
        }
      }
    }
  } while( true );
}



char * LYLineeditHelpURL(void)

{
  char *phelp;
  char helpbuf [256];
  int lasthelp_lineedit;
  size_t sVar1;
  char *local_c;
  
  if (lasthelp_lineedit == current_lineedit) {
    local_c = &ram0x08194a40;
  }
  else {
    if (lasthelp_lineedit == -1) {
      LYstrncpy((char *)0x8194a40,helpfilepath,0xff);
      sVar1 = strlen((char *)0x8194a40);
      phelp = phelp + sVar1;
    }
    if (((LYLineeditHelpURLs[current_lineedit] != (char *)0x0) &&
        (*LYLineeditHelpURLs[current_lineedit] != '\0')) &&
       (sVar1 = strlen(LYLineeditHelpURLs[current_lineedit]), sVar1 <= 0x8194b40U - (int)phelp)) {
      LYstrncpy(phelp,LYLineeditHelpURLs[current_lineedit],0x8194b3f - (int)phelp);
      return (char *)0x8194a40;
    }
    local_c = (char *)0x0;
  }
  return local_c;
}



char * LYstrsep(char **stringp,char *delim)

{
  char *pcVar1;
  char *local_18;
  char *out;
  char *tmp;
  
  if ((stringp == (char **)0x0) || (*stringp == (char *)0x0)) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = *stringp;
    pcVar1 = strpbrk(*stringp,delim);
    if (pcVar1 == (char *)0x0) {
      *stringp = (char *)0x0;
    }
    else {
      *pcVar1 = '\0';
      *stringp = pcVar1 + 1;
    }
  }
  return local_18;
}



char * LYstrstr(char *chptr,char *tarptr)

{
  size_t sVar1;
  int iVar2;
  int len;
  
  sVar1 = strlen(tarptr);
  while( true ) {
    if (*chptr == '\0') {
      return (char *)0x0;
    }
    iVar2 = UPPER8((int)*chptr,(int)*tarptr);
    if ((iVar2 == 0) && (iVar2 = strncasecomp8(chptr + 1,tarptr + 1,sVar1 - 1), iVar2 == 0)) break;
    chptr = chptr + 1;
  }
  return chptr;
}



char * LYno_attr_char_case_strstr(char *chptr,char *tarptr)

{
  int iVar1;
  char *local_c;
  char *local_8;
  
  if (chptr != (char *)0x0) {
    while ((('\x02' < *chptr && (*chptr < '\t')) && (*chptr != '\0'))) {
      chptr = chptr + 1;
    }
    while (*chptr != '\0') {
      iVar1 = UPPER8((int)*chptr,(int)*tarptr);
      if (iVar1 == 0) {
        local_c = chptr + 1;
        local_8 = tarptr + 1;
        if (*local_8 == '\0') {
          return chptr;
        }
        do {
          if ((*local_c < '\x03') || ('\b' < *local_c)) {
            iVar1 = UPPER8((int)*local_c,(int)*local_8);
            if (iVar1 != 0) break;
            local_8 = local_8 + 1;
          }
          local_c = local_c + 1;
          if (*local_8 == '\0') {
            return chptr;
          }
        } while (*local_c != '\0');
      }
      chptr = chptr + 1;
    }
  }
  return (char *)0x0;
}



char * LYno_attr_char_strstr(char *chptr,char *tarptr)

{
  char *local_c;
  char *local_8;
  
  if (chptr != (char *)0x0) {
    while ((('\x02' < *chptr && (*chptr < '\t')) && (*chptr != '\0'))) {
      chptr = chptr + 1;
    }
    while (*chptr != '\0') {
      if (*chptr == *tarptr) {
        local_c = chptr + 1;
        local_8 = tarptr + 1;
        if (*local_8 == '\0') {
          return chptr;
        }
        do {
          if ((*local_c < '\x03') || ('\b' < *local_c)) {
            if (*local_c != *local_8) break;
            local_8 = local_8 + 1;
          }
          local_c = local_c + 1;
          if (*local_8 == '\0') {
            return chptr;
          }
        } while (*local_c != '\0');
      }
      chptr = chptr + 1;
    }
  }
  return (char *)0x0;
}



char * LYno_attr_mbcs_case_strstr
                 (char *chptr,char *tarptr,BOOLEAN utf_flag,BOOLEAN count_gcells,int *nstartp,
                 int *nendp)

{
  int iVar1;
  int iVar2;
  int tarlen;
  int offset;
  int len;
  char *tmptarptr;
  char *tmpchptr;
  
  len = 0;
  if ((chptr != (char *)0x0) && (tarptr != (char *)0x0)) {
    while (('\x02' < *chptr && ((*chptr < '\t' && (*chptr != '\0'))))) {
      chptr = chptr + 1;
    }
    while (*chptr != '\0') {
      if (((((utf_flag == '\0') && (HTCJK != NOCJK)) && (*chptr < '\0')) &&
          (((*chptr == *tarptr && (chptr[1] != '\0')) && ((chptr[1] < '\x03' || ('\b' < chptr[1]))))
          )) || (iVar1 = UPPER8((int)*chptr,(int)*tarptr), iVar1 == 0)) {
        tarlen = 0;
        iVar1 = len + 1;
        tmpchptr = chptr + 1;
        tmptarptr = tarptr + 1;
        if (*tmptarptr == '\0') {
          if (nstartp != (int *)0x0) {
            *nstartp = len;
          }
          if (nendp != (int *)0x0) {
            *nendp = iVar1;
          }
          return chptr;
        }
        if ((((utf_flag == '\0') && (HTCJK != NOCJK)) &&
            ((*chptr < '\0' && ((*chptr == *tarptr && (*tmpchptr != '\0')))))) &&
           ((*tmpchptr < '\x03' || ('\b' < *tmpchptr)))) {
          if (*tmpchptr != *tmptarptr) {
            chptr = chptr + 1;
            if (count_gcells != '\0') {
              iVar1 = len + 2;
            }
            goto LAB_08056270;
          }
          tmpchptr = chptr + 2;
          tmptarptr = tarptr + 2;
          tarlen = ZEXT14(count_gcells != '\0');
          if (*tmptarptr == '\0') {
            if (nstartp != (int *)0x0) {
              *nstartp = len;
            }
            if (nendp != (int *)0x0) {
              *nendp = iVar1 + tarlen;
            }
            return chptr;
          }
        }
        do {
          if ((*tmpchptr < '\x03') || ('\b' < *tmpchptr)) {
            if ((utf_flag == '\0') && ((HTCJK != NOCJK && (*tmpchptr < '\0')))) {
              if (((*tmpchptr != *tmptarptr) || (tmpchptr[1] != tmptarptr[1])) ||
                 (('\x02' < tmpchptr[1] && (tmpchptr[1] < '\t')))) break;
              tmpchptr = tmpchptr + 1;
              tmptarptr = tmptarptr + 1;
              if (count_gcells != '\0') {
                tarlen = tarlen + 1;
              }
            }
            else {
              iVar2 = UPPER8((int)*tmpchptr,(int)*tmptarptr);
              if (iVar2 != 0) break;
            }
            if ((utf_flag == '\0') || ((*tmptarptr & 0xc0U) != 0x80)) {
              tarlen = tarlen + 1;
            }
            tmptarptr = tmptarptr + 1;
          }
          tmpchptr = tmpchptr + 1;
          if (*tmptarptr == '\0') {
            if (nstartp != (int *)0x0) {
              *nstartp = len;
            }
            if (nendp != (int *)0x0) {
              *nendp = iVar1 + tarlen;
            }
            return chptr;
          }
        } while (*tmpchptr != '\0');
      }
      else {
        iVar1 = len;
        if (((utf_flag == '\0') || ((*chptr & 0xc0U) != 0x80)) &&
           ((*chptr < '\x03' || ('\b' < *chptr)))) {
          if (((((utf_flag == '\0') && (HTCJK != NOCJK)) && (*chptr < '\0')) && (chptr[1] != '\0'))
             && (((chptr[1] < '\x03' || ('\b' < chptr[1])) &&
                 (chptr = chptr + 1, count_gcells != '\0')))) {
            len = len + 1;
          }
          iVar1 = len + 1;
        }
      }
LAB_08056270:
      len = iVar1;
      chptr = chptr + 1;
    }
  }
  return (char *)0x0;
}



char * LYno_attr_mbcs_strstr
                 (char *chptr,char *tarptr,BOOLEAN utf_flag,BOOLEAN count_gcells,int *nstartp,
                 int *nendp)

{
  int iVar1;
  int tarlen;
  int offset;
  int len;
  char *tmptarptr;
  char *tmpchptr;
  
  len = 0;
  if ((chptr != (char *)0x0) && (tarptr != (char *)0x0)) {
    while (('\x02' < *chptr && ((*chptr < '\t' && (*chptr != '\0'))))) {
      chptr = chptr + 1;
    }
    while (*chptr != '\0') {
      if (*chptr == *tarptr) {
        tarlen = 0;
        iVar1 = len + 1;
        tmpchptr = chptr + 1;
        tmptarptr = tarptr + 1;
        if (*tmptarptr == '\0') {
          if (nstartp != (int *)0x0) {
            *nstartp = len;
          }
          if (nendp != (int *)0x0) {
            *nendp = iVar1;
          }
          return chptr;
        }
        if ((((utf_flag == '\0') && (HTCJK != NOCJK)) && ((*chptr < '\0' && (*tmpchptr != '\0'))))
           && ((*tmpchptr < '\x03' || ('\b' < *tmpchptr)))) {
          if (*tmpchptr != *tmptarptr) {
            chptr = chptr + 1;
            if (count_gcells != '\0') {
              iVar1 = len + 2;
            }
            goto LAB_080565aa;
          }
          tmpchptr = chptr + 2;
          tmptarptr = tarptr + 2;
          tarlen = ZEXT14(count_gcells != '\0');
          if (*tmptarptr == '\0') {
            if (nstartp != (int *)0x0) {
              *nstartp = len;
            }
            if (nendp != (int *)0x0) {
              *nendp = iVar1 + tarlen;
            }
            return chptr;
          }
        }
        do {
          if ((*tmpchptr < '\x03') || ('\b' < *tmpchptr)) {
            if ((utf_flag == '\0') && ((HTCJK != NOCJK && (*tmpchptr < '\0')))) {
              if (((*tmpchptr != *tmptarptr) || (tmpchptr[1] != tmptarptr[1])) ||
                 (('\x02' < tmpchptr[1] && (tmpchptr[1] < '\t')))) break;
              tmpchptr = tmpchptr + 1;
              tmptarptr = tmptarptr + 1;
              if (count_gcells != '\0') {
                tarlen = tarlen + 1;
              }
            }
            else {
              if (*tmpchptr != *tmptarptr) break;
            }
            if ((utf_flag == '\0') || ((*tmptarptr & 0xc0U) != 0x80)) {
              tarlen = tarlen + 1;
            }
            tmptarptr = tmptarptr + 1;
          }
          tmpchptr = tmpchptr + 1;
          if (*tmptarptr == '\0') {
            if (nstartp != (int *)0x0) {
              *nstartp = len;
            }
            if (nendp != (int *)0x0) {
              *nendp = iVar1 + tarlen;
            }
            return chptr;
          }
        } while (*tmpchptr != '\0');
      }
      else {
        iVar1 = len;
        if (((utf_flag == '\0') || ((*chptr & 0xc0U) != 0x80)) &&
           ((*chptr < '\x03' || ('\b' < *chptr)))) {
          if ((((((utf_flag == '\0') && (HTCJK != NOCJK)) && (*chptr < '\0')) && (chptr[1] != '\0'))
              && ((chptr[1] < '\x03' || ('\b' < chptr[1])))) &&
             (chptr = chptr + 1, count_gcells != '\0')) {
            len = len + 1;
          }
          iVar1 = len + 1;
        }
      }
LAB_080565aa:
      len = iVar1;
      chptr = chptr + 1;
    }
  }
  return (char *)0x0;
}



char * SNACopy(char **dest,char *src,int n)

{
  char *pcVar1;
  FILE *__stream;
  
  if (*dest != (char *)0x0) {
    free(*dest);
    *dest = (char *)0x0;
  }
  if (src != (char *)0x0) {
    pcVar1 = (char *)malloc(n + 1);
    *dest = pcVar1;
    if (*dest == (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Tried to malloc %d bytes\n",n);
      }
      outofmem("./LYStrings.c","SNACopy");
    }
    strncpy(*dest,src,n);
    (*dest)[n] = '\0';
  }
  return *dest;
}



char * SNACat(char **dest,char *src,int n)

{
  size_t sVar1;
  char *pcVar2;
  int length;
  
  if ((src != (char *)0x0) && (*src != '\0')) {
    if (*dest == (char *)0x0) {
      pcVar2 = (char *)malloc(n + 1);
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("./LYStrings.c","SNACat");
      }
      memcpy(*dest,src,n);
      (*dest)[n] = '\0';
    }
    else {
      sVar1 = strlen(*dest);
      pcVar2 = (char *)realloc(*dest,sVar1 + n + 1);
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("./LYStrings.c","SNACat");
      }
      strncpy(*dest + sVar1,src,n);
      (*dest)[sVar1 + n] = '\0';
    }
  }
  return *dest;
}



long UniToLowerCase(long upper)

{
  size_t sVar1;
  int iVar2;
  uint local_18;
  long diff;
  size_t low;
  size_t high;
  size_t i;
  
  if (upper < 1) {
    local_18 = upper;
  }
  else {
    low = 0;
    high = 0x2c1;
    do {
      if (high <= low) {
        return upper;
      }
      sVar1 = (high - low >> 1) + low;
      iVar2 = (uint)unicode_to_lower_case[sVar1].upper - upper;
      if (iVar2 < 0) {
        low = sVar1 + 1;
      }
      if (0 < iVar2) {
        high = sVar1;
      }
    } while ((uint)unicode_to_lower_case[sVar1].upper != upper);
    local_18 = (uint)unicode_to_lower_case[sVar1].lower;
  }
  return local_18;
}



int UPPER8(int ch1,int ch2)

{
  char ch_in;
  char ch_in_00;
  ushort **ppuVar1;
  UCode_t upper;
  UCode_t upper_00;
  long lVar2;
  long lVar3;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  long uni_ch1;
  long uni_ch2;
  
  if (ch1 == ch2) {
    local_2c = 0;
  }
  else {
    if (ch2 == 0) {
      local_2c = ch1 & 0xff;
    }
    else {
      if (ch1 == 0) {
        local_2c = -(ch2 & 0xffU);
      }
      else {
        ch_in = (char)ch1;
        ch_in_00 = (char)ch2;
        if ((ch_in < '\0') || (ch_in_00 < '\0')) {
          if ((ch_in < '\0') && (ch_in_00 < '\0')) {
            if (DisplayCharsetMatchLocale == '\0') {
              upper = UCTransToUni(ch_in_00,current_char_set);
              if (upper < 0) {
                local_2c = ch1 & 0xff;
              }
              else {
                upper_00 = UCTransToUni(ch_in,current_char_set);
                lVar2 = UniToLowerCase(upper_00);
                lVar3 = UniToLowerCase(upper);
                local_2c = lVar2 - lVar3;
              }
            }
            else {
              ppuVar1 = __ctype_b_loc();
              if (((*ppuVar1)[ch1 & 0xff] & 0x200) == 0) {
                local_20 = ch1 & 0xff;
              }
              else {
                local_20 = toupper(ch1 & 0xff);
              }
              ppuVar1 = __ctype_b_loc();
              if (((*ppuVar1)[ch2 & 0xff] & 0x200) == 0) {
                local_1c = ch2 & 0xff;
              }
              else {
                local_1c = toupper(ch2 & 0xff);
              }
              local_2c = local_20 - local_1c;
            }
          }
          else {
            local_2c = 0xfffffff6;
          }
        }
        else {
          ppuVar1 = __ctype_b_loc();
          if (((*ppuVar1)[ch1 & 0xff] & 0x200) == 0) {
            local_28 = ch1 & 0xff;
          }
          else {
            local_28 = toupper(ch1 & 0xff);
          }
          ppuVar1 = __ctype_b_loc();
          if (((*ppuVar1)[ch2 & 0xff] & 0x200) == 0) {
            local_24 = ch2 & 0xff;
          }
          else {
            local_24 = toupper(ch2 & 0xff);
          }
          local_2c = local_28 - local_24;
        }
      }
    }
  }
  return local_2c;
}



char * LYSafeGets(char **src,FILE *fp)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  char *result;
  char buffer [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  if (src != (char **)0x0) {
    result = *src;
  }
  if (result != (char *)0x0) {
    *result = '\0';
  }
  do {
    pcVar2 = fgets(buffer,0x2000,(FILE *)fp);
    if (pcVar2 == (char *)0x0) break;
    if (buffer[0] != '\0') {
      result = HTSACat(&result,buffer);
    }
    pcVar2 = strchr(buffer,10);
  } while (pcVar2 == (char *)0x0);
  iVar3 = ferror((FILE *)fp);
  if (iVar3 == 0) {
    iVar3 = feof((FILE *)fp);
    if ((((iVar3 != 0) && (result != (char *)0x0)) && (*result == '\0')) && (result != (char *)0x0))
    {
      free(result);
      result = (char *)0x0;
    }
  }
  else {
    if (result != (char *)0x0) {
      free(result);
      result = (char *)0x0;
    }
  }
  if (src != (char **)0x0) {
    *src = result;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



void LYOpenCmdLogfile(int argc,char **argv)

{
  char *local_1c;
  int n;
  
  if (lynx_cmd_logfile != (char *)0x0) {
    cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
    if (cmd_logfile != (FILE *)0x0) {
      local_1c = LYVersionDate();
      fprintf((FILE *)cmd_logfile,"# Command logfile created by %s %s (%s)\n",&DAT_0814bcf0,
              "2.8.7dev.11",local_1c);
      n = 0;
      while (n < argc) {
        fprintf((FILE *)cmd_logfile,"# Arg%d = %s\n",n,argv[n],local_1c);
        n = n + 1;
      }
    }
  }
  return;
}



BOOLEAN LYHaveCmdScript(void)

{
  return (BOOLEAN)(cmd_script != (FILE *)0x0);
}



void LYOpenCmdScript(void)

{
  char *pcVar1;
  FILE *__stream;
  char *local_c;
  
  if (lynx_cmd_script != (char *)0x0) {
    cmd_script = (FILE *)fopen64(lynx_cmd_script,"r");
    pcVar1 = lynx_cmd_script;
    if (WWW_TraceFlag != '\0') {
      if (cmd_script == (FILE *)0x0) {
        local_c = "FAIL";
      }
      else {
        local_c = "SUCCESS";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOpenCmdScript(%s) %s\n",pcVar1,local_c);
    }
  }
  return;
}



int LYReadCmdKey(int mode)

{
  char *buffer_00;
  ushort **ppuVar1;
  char *buffer_01;
  int iVar2;
  FILE *__stream;
  uint len;
  char *tmp;
  char *src;
  char *buffer;
  int ch;
  
  ch = -1;
  if (cmd_script == (FILE *)0x0) {
    ch = LYgetch_for(mode);
  }
  else {
    buffer = (char *)0x0;
    while (ch < 0) {
      buffer_01 = LYSafeGets(&buffer,cmd_script);
      if (buffer_01 == (char *)0x0) break;
      LYTrimTrailing(buffer);
      buffer_01 = LYSkipBlanks(buffer);
      buffer_00 = LYSkipNonBlanks(buffer_01);
      if (buffer_00 + -(int)buffer_01 == (char *)0x3) {
        iVar2 = strncasecomp(buffer_01,"key",3);
        if (iVar2 == 0) {
          buffer_01 = LYSkipBlanks(buffer_00);
          ch = LYStringToKeycode(buffer_01);
        }
        else {
          iVar2 = strncasecomp(buffer_01,"set",3);
          if (iVar2 == 0) {
            buffer_01 = LYSkipBlanks(buffer_00);
            tmp = buffer_01;
            while (*tmp != '\0') {
              ppuVar1 = __ctype_b_loc();
              if ((((*ppuVar1)[(byte)*tmp] & 0x2000) != 0) || (*tmp == '=')) break;
              tmp = tmp + 1;
            }
            if (*tmp != '\0') {
              *tmp = '\0';
              tmp = LYSkipBlanks(tmp + 1);
            }
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYSetConfigValue(%s, %s)\n",buffer_01,tmp);
            }
            LYSetConfigValue(buffer_01,tmp);
          }
        }
      }
      else {
        if (buffer_00 + -(int)buffer_01 == &DAT_00000004) {
          iVar2 = strncasecomp(buffer_01,"exit",4);
          if (iVar2 == 0) {
            exit_immediately(0);
          }
        }
      }
    }
    iVar2 = feof((FILE *)cmd_script);
    if (iVar2 != 0) {
      fclose((FILE *)cmd_script);
      cmd_script = (FILE *)0x0;
    }
    if (-1 < ch) {
      LYSleepReplay();
      LYrefresh();
    }
    if (buffer != (char *)0x0) {
      free(buffer);
      buffer = (char *)0x0;
    }
  }
  if (WWW_TraceFlag != '\0') {
    buffer_01 = LYKeycodeToString(ch,'\x01');
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYReadCmdKey(%d) ->%s (%#x)\n",mode,buffer_01,ch);
  }
  LYWriteCmdKey(ch);
  return ch;
}



void LYWriteCmdKey(int ch)

{
  char *pcVar1;
  
  if (cmd_logfile != (FILE *)0x0) {
    pcVar1 = LYKeycodeToString(ch,'\0');
    fprintf((FILE *)cmd_logfile,"key %s\n",pcVar1);
  }
  return;
}



void LYCloseCmdLogfile(void)

{
  if (cmd_logfile != (FILE *)0x0) {
    LYCloseOutput(cmd_logfile);
    cmd_logfile = (FILE *)0x0;
  }
  if (cmd_script != (FILE *)0x0) {
    LYCloseInput(cmd_script);
    cmd_script = (FILE *)0x0;
  }
  if (lynx_cmd_logfile != (char *)0x0) {
    free(lynx_cmd_logfile);
    lynx_cmd_logfile = (char *)0x0;
  }
  if (lynx_cmd_script != (char *)0x0) {
    free(lynx_cmd_script);
    lynx_cmd_script = (char *)0x0;
  }
  return;
}



void terminate_letter(int sig)

{
  term_letter = '\x01';
  signal(2,terminate_letter);
  return;
}



void SafeHTUnEscape(char *string)

{
  bool bVar1;
  ushort **ppuVar2;
  char *Msg;
  int flg;
  int i;
  
  bVar1 = false;
  HTUnEscape(string);
  i = 0;
  do {
    if (string[i] == '\0') {
      if (bVar1) {
        Msg = (char *)gettext(0x814bda8);
        HTAlert(Msg);
      }
      return;
    }
    if (string[i] < '\0') {
LAB_080570b0:
      string[i] = '?';
      bVar1 = true;
    }
    else {
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)string[i]] & 0x4000) == 0) goto LAB_080570b0;
    }
    i = i + 1;
  } while( true );
}



void remove_tildes(char *string)

{
  if (*string == '~') {
    *string = ' ';
  }
  return;
}



void comma_append(char **dst,char *src)

{
  ushort **ppuVar1;
  
  if (*src != '\0') {
    while ((*src == ',' || (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*src] & 0x2000) != 0))) {
      src = src + 1;
    }
    if (*src != '\0') {
      if ((*dst == (char *)0x0) || (**dst == '\0')) {
        HTSACopy(dst,src);
      }
      else {
        HTSACat(dst,",");
        HTSACat(dst,src);
      }
    }
  }
  return;
}



void extract_field(char **dst,char *src,char *keyword)

{
  char *__s;
  size_t n;
  int iVar1;
  FILE *__stream;
  char *local_18;
  char *cp1;
  char *cp;
  int len;
  
  n = strlen(keyword);
  cp = src + 1;
  while (*cp != '\0') {
    if ((cp[-1] == '?') || (cp[-1] == '&')) {
      iVar1 = strncasecomp(cp,keyword,n);
      if (iVar1 == 0) {
        __s = cp + n;
        cp = strchr(__s,0x26);
        if (cp != (char *)0x0) {
          *cp = '\0';
        }
        comma_append(dst,__s);
        if (cp == (char *)0x0) break;
        *cp = '&';
      }
    }
    cp = cp + 1;
  }
  if (WWW_TraceFlag != '\0') {
    if (*dst == (char *)0x0) {
      local_18 = "(null)";
    }
    else {
      local_18 = *dst;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"extract_field(%s) = \'%s\'\n",keyword,local_18);
  }
  return;
}



void extract_subject(char *dst,char *src)

{
  size_t n;
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  char *local_18;
  char *cp1;
  char *cp;
  int len;
  char *keyword;
  
  n = strlen("subject=");
  cp = src + 1;
  while (*cp != '\0') {
    if ((cp[-1] == '?') || (cp[-1] == '&')) {
      iVar1 = strncasecomp(cp,"subject=",n);
      if (iVar1 == 0) break;
    }
    cp = cp + 1;
  }
  if (*cp != '\0') {
    cp = cp + n;
    pcVar2 = strchr(cp,0x26);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    if (*cp != '\0') {
      strncpy(dst,cp,0x46);
      dst[0x46] = '\0';
      SafeHTUnEscape(dst);
    }
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '&';
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (dst == (char *)0x0) {
      local_18 = "(null)";
    }
    else {
      local_18 = dst;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"extract_subject(%s) = \'%s\'\n","subject=",local_18);
  }
  return;
}



void extract_body(char **dst,char *src)

{
  int iVar1;
  char *__s;
  FILE *__stream;
  char *local_28;
  char *temp;
  char *cp1;
  char *cp0;
  char *cp;
  int i;
  int len;
  char *keyword;
  
  len = strlen("body=");
  temp = (char *)0x0;
  cp = src + 1;
  while (*cp != '\0') {
    if ((cp[-1] == '?') || (cp[-1] == '&')) {
      iVar1 = strncasecomp(cp,"body=",len);
      if (iVar1 == 0) {
        __s = cp + len;
        cp = strchr(__s,0x26);
        if (cp != (char *)0x0) {
          *cp = '\0';
        }
        if (*__s != '\0') {
          HTSACopy(&temp,__s);
          HTUnEscape(temp);
          cp0 = temp;
          while( true ) {
            __s = strchr(cp0,10);
            if (__s == (char *)0x0) break;
            *__s = '\0';
            if ((cp0 < __s) && (__s[-1] == '\r')) {
              __s[-1] = '\0';
            }
            i = 0;
            len = strlen(cp0);
            while (0x4e < len) {
              HTSprintf(dst,"%.78s\n",cp0 + i);
              i = i + 0x4e;
              len = strlen(cp0 + i);
            }
            HTSprintf(dst,"%s\n",cp0 + i);
            cp0 = __s + 1;
          }
          i = 0;
          len = strlen(cp0);
          while (0x4e < len) {
            HTSprintf(dst,"%.78s\n",cp0 + i);
            i = i + 0x4e;
            len = strlen(cp0 + i);
          }
          if (len != 0) {
            HTSprintf(dst,"%s\n",cp0 + i);
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (cp == (char *)0x0) break;
        *cp = '&';
      }
    }
    cp = cp + 1;
  }
  if (WWW_TraceFlag != '\0') {
    if (*dst == (char *)0x0) {
      local_28 = "(null)";
    }
    else {
      local_28 = *dst;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"extract_body(%s) = \'%s\'\n","body=",local_28);
  }
  return;
}



BOOLEAN trim_comma(char *address)

{
  size_t sVar1;
  
  sVar1 = strlen(address);
  if (address[sVar1 - 1] == ',') {
    sVar1 = strlen(address);
    address[sVar1 - 1] = '\0';
  }
  return (BOOLEAN)(*address == '\0');
}



BOOLEAN convert_explorer(char *address)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *cp1;
  char *cp0;
  char *cp;
  
  cp = address;
  while( true ) {
    cp1 = strchr(cp,0x40);
    if (cp1 == (char *)0x0) break;
    cp1 = cp1 + 1;
    pcVar2 = strchr(cp1,0x3b);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = ',';
      cp1 = pcVar2 + 1;
    }
    cp = cp1;
  }
  BVar1 = trim_comma(address);
  return BVar1;
}



int header_prompt(char *label,char **result,uint limit)

{
  int iVar1;
  char *__s;
  size_t len;
  int iVar2;
  int in_GS_OFFSET;
  int local_424;
  int ok;
  char buffer [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (*result == (char *)0x0) {
    buffer[0] = '\0';
  }
  else {
    __s = (char *)gettext(" Use Control-U to erase the default.\n");
    len = strlen(__s);
    __s = (char *)gettext(" Use Control-U to erase the default.\n");
    LYwaddnstr(LYwin,__s,len);
    LYstrncpy(buffer,*result,0x3ff);
  }
  if (0x400 < limit) {
    limit = 0x400;
  }
  __s = (char *)gettext(label);
  len = strlen(__s);
  __s = (char *)gettext(label);
  LYwaddnstr(LYwin,__s,len);
  LYwaddnstr(LYwin,": ",2);
  iVar2 = LYgetstr(buffer,0,limit,NORECALL);
  if ((iVar2 < 0) || (term_letter != '\0')) {
    local_424 = 0;
  }
  else {
    local_424 = 1;
  }
  LYwaddnstr(LYwin,"\n",1);
  if (local_424 != 0) {
    remove_tildes(buffer);
    HTSACopy(result,buffer);
  }
  term_letter = '\0';
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  term_letter = '\0';
  return local_424;
}



void show_addresses(char *addresses)

{
  char *pcVar1;
  size_t len;
  char *cp1;
  char *cp;
  
  cp = addresses;
  while( true ) {
    pcVar1 = strchr(cp,0x2c);
    if (pcVar1 == (char *)0x0) break;
    *pcVar1 = '\0';
    while (*cp == ' ') {
      cp = cp + 1;
    }
    if (*cp != '\0') {
      len = strlen(cp);
      LYwaddnstr(LYwin,cp,len);
      LYwaddnstr(LYwin,",\n  ",4);
    }
    *pcVar1 = ',';
    cp = pcVar1 + 1;
  }
  if (*cp != '\0') {
    len = strlen(cp);
    LYwaddnstr(LYwin,cp,len);
  }
  return;
}



FILE * LYPipeToMailer(void)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  undefined *local_1c;
  FILE *fp;
  char *buffer;
  
  buffer = (char *)0x0;
  fp = (FILE *)0x0;
  BVar2 = LYSystemMail();
  if (BVar2 != '\0') {
    HTSprintf0(&buffer,"%s %s",system_mail,system_mail_flags);
    fp = (FILE *)popen(buffer,"w");
    pcVar1 = buffer;
    if (WWW_TraceFlag != '\0') {
      if (fp == (FILE *)0x0) {
        local_1c = &DAT_0814be8b;
      }
      else {
        local_1c = &DAT_0814be88;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"popen(%s) %s\n",pcVar1,local_1c);
    }
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  return fp;
}



void mailform(char *mailto_address,char *mailto_subject,char *mailto_content,char *mailto_type)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  char *src;
  int iVar3;
  int in_GS_OFFSET;
  char *local_2f8;
  char *local_2f4;
  char *local_2f0;
  char *local_2ec;
  char *local_2e8;
  char *local_2e0;
  int i;
  int len;
  int ch;
  char *searchpart;
  char *cp;
  char *keywords;
  char *ccaddr;
  char *address;
  FILE *fd;
  char buf [512];
  char subject [80];
  char self [80];
  
  local_2e0 = mailto_content;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  address = (char *)0x0;
  ccaddr = (char *)0x0;
  keywords = (char *)0x0;
  searchpart = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    if (mailto_address == (char *)0x0) {
      local_2f8 = "(null)";
    }
    else {
      local_2f8 = mailto_address;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"mailto_address: \"%s\"\n",local_2f8);
  }
  if (WWW_TraceFlag != '\0') {
    if (mailto_subject == (char *)0x0) {
      local_2f4 = "(null)";
    }
    else {
      local_2f4 = mailto_subject;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"mailto_subject: \"%s\"\n",local_2f4);
  }
  if (WWW_TraceFlag != '\0') {
    if (mailto_content == (char *)0x0) {
      local_2f0 = "(null)";
    }
    else {
      local_2f0 = mailto_content;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"mailto_content: \"%s\"\n",local_2f0);
  }
  if (WWW_TraceFlag != '\0') {
    if (mailto_type == (char *)0x0) {
      local_2ec = "(null)";
    }
    else {
      local_2ec = mailto_type;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"mailto_type:    \"%s\"\n",local_2ec);
  }
  BVar2 = LYSystemMail();
  if (BVar2 == '\0') goto LAB_0805841a;
  if ((mailto_address == (char *)0x0) || (mailto_content == (char *)0x0)) {
    src = (char *)gettext("Malformed mailto form submission!  Cancelled!");
    HTAlert(src);
    goto LAB_0805841a;
  }
  subject[0] = '\0';
  self[0] = '\0';
  src = strchr(mailto_address,10);
  if (src != (char *)0x0) {
    *src = '\0';
  }
  HTSACopy(&address,mailto_address);
  src = strchr(address,0x3f);
  if (src != (char *)0x0) {
    HTSACopy(&searchpart,src);
    *src = '\0';
    if (searchpart[1] != '\0') {
      extract_subject(subject,searchpart);
      extract_field(&address,searchpart,"to=");
      extract_field(&ccaddr,searchpart,"cc=");
      extract_field(&keywords,searchpart,"keywords=");
      if (keywords != (char *)0x0) {
        if (*keywords == '\0') {
          if (keywords != (char *)0x0) {
            free(keywords);
            keywords = (char *)0x0;
          }
        }
        else {
          SafeHTUnEscape(keywords);
        }
      }
      if (searchpart != (char *)0x0) {
        free(searchpart);
        searchpart = (char *)0x0;
      }
    }
  }
  BVar2 = convert_explorer(address);
  if (BVar2 == '\0') {
    if (ccaddr != (char *)0x0) {
      BVar2 = convert_explorer(ccaddr);
      if ((BVar2 != '\0') && (ccaddr != (char *)0x0)) {
        free(ccaddr);
        ccaddr = (char *)0x0;
      }
    }
    SafeHTUnEscape(address);
    if (ccaddr != (char *)0x0) {
      SafeHTUnEscape(ccaddr);
    }
    if (subject[0] == '\0') {
      if ((mailto_subject == (char *)0x0) || (*mailto_subject == '\0')) {
        sprintf(subject,"mailto:%.63s",address);
      }
      else {
        LYstrncpy(subject,mailto_subject,0x46);
      }
    }
    mustshow = '\x01';
    src = (char *)gettext("Subject: ");
    statusline(src);
    iVar3 = LYgetstr(subject,0,0x46,NORECALL);
    if (iVar3 < 0) {
      src = (char *)gettext("Mailto form submission Cancelled!!!");
      HTInfoMsg(src);
    }
    else {
      if (LYNoCc == '\0') {
        if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
          local_2e8 = "";
        }
        else {
          local_2e8 = personal_mail_address;
        }
        sprintf(self,"%.*s",0x46,local_2e8);
        mustshow = '\x01';
        statusline("Cc: ");
        iVar3 = LYgetstr(self,0,0x46,NORECALL);
        if (iVar3 < 0) {
          src = (char *)gettext("Mailto form submission Cancelled!!!");
          HTInfoMsg(src);
          goto cleanup;
        }
        remove_tildes(self);
        if (ccaddr == (char *)0x0) {
          HTSACopy(&ccaddr,self);
        }
        else {
          HTSACat(&ccaddr,",");
          HTSACat(&ccaddr,self);
        }
      }
      __stream = LYPipeToMailer();
      if (__stream == (FILE *)0x0) {
        src = (char *)gettext("Mailto form submission failed!");
        HTAlert(src);
      }
      else {
        if ((mailto_type != (char *)0x0) && (*mailto_type != '\0')) {
          fwrite("Mime-Version: 1.0\n",1,0x12,(FILE *)__stream);
          fprintf((FILE *)__stream,"Content-Type: %s\n",mailto_type);
        }
        fprintf((FILE *)__stream,"To: %s\n",address);
        if ((personal_mail_address != (char *)0x0) && (*personal_mail_address != '\0')) {
          fprintf((FILE *)__stream,"From: %s\n",personal_mail_address);
        }
        if ((ccaddr != (char *)0x0) && (*ccaddr != '\0')) {
          fprintf((FILE *)__stream,"Cc: %s\n",ccaddr);
        }
        fprintf((FILE *)__stream,"Subject: %s\n\n",subject);
        if ((keywords != (char *)0x0) && (*keywords != '\0')) {
          fprintf((FILE *)__stream,"Keywords: %s\n",keywords);
        }
        mustshow = '\x01';
        src = (char *)gettext("Sending form content...");
        statusline(src);
        while( true ) {
          src = strchr(local_2e0,10);
          if (src == (char *)0x0) break;
          *src = '\0';
          i = 0;
          len = strlen(local_2e0);
          while (0x4e < len) {
            strncpy(buf,local_2e0 + i,0x4e);
            buf[78] = '\0';
            fprintf((FILE *)__stream,"%s\n",buf);
            i = i + 0x4e;
            len = strlen(local_2e0 + i);
          }
          fprintf((FILE *)__stream,"%s\n",local_2e0 + i);
          local_2e0 = src + 1;
        }
        i = 0;
        len = strlen(local_2e0);
        while (0x4e < len) {
          strncpy(buf,local_2e0 + i,0x4e);
          buf[78] = '\0';
          fprintf((FILE *)__stream,"%s\n",buf);
          i = i + 0x4e;
          len = strlen(local_2e0 + i);
        }
        if (len != 0) {
          fprintf((FILE *)__stream,"%s\n",local_2e0 + i);
        }
        pclose((FILE *)__stream);
        LYSleepMsg();
      }
    }
  }
  else {
    src = (char *)gettext("Malformed mailto form submission!  Cancelled!");
    HTAlert(src);
  }
cleanup:
  if (address != (char *)0x0) {
    free(address);
    address = (char *)0x0;
  }
  if (ccaddr != (char *)0x0) {
    free(ccaddr);
    ccaddr = (char *)0x0;
  }
  if (keywords != (char *)0x0) {
    free(keywords);
    keywords = (char *)0x0;
  }
LAB_0805841a:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void mailmsg(int cur,char *owner_address,char *filename,char *linkname)

{
  BOOLEAN BVar1;
  char *src;
  int iVar2;
  FILE *__stream;
  char *__format;
  char *__format_00;
  undefined4 uVar3;
  FILE *fp_00;
  FILE *ofp;
  char *cp;
  char *cmd;
  char *searchpart;
  char *address;
  FILE *fp;
  FILE *fd;
  
  address = (char *)0x0;
  searchpart = (char *)0x0;
  cmd = (char *)0x0;
  BVar1 = LYSystemMail();
  if (((BVar1 != '\0') && (owner_address != (char *)0x0)) && (*owner_address != '\0')) {
    src = strchr(owner_address,10);
    if (src != (char *)0x0) {
      *src = '\0';
    }
    iVar2 = strncasecomp(owner_address,"lynx-dev@",9);
    if (iVar2 != 0) {
      HTSACopy(&address,owner_address);
      src = strchr(address,0x3f);
      if (src != (char *)0x0) {
        HTSACopy(&searchpart,src);
        *src = '\0';
        if (searchpart[1] != '\0') {
          extract_field(&address,searchpart,"to=");
        }
      }
      convert_explorer(address);
      SafeHTUnEscape(address);
      BVar1 = trim_comma(address);
      if (BVar1 == '\0') {
        __stream = LYPipeToMailer();
        if (__stream == (FILE *)0x0) {
          if (address != (char *)0x0) {
            free(address);
            address = (char *)0x0;
          }
          src = cmd;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"mailmsg: \'%s\' failed.\n",src);
          }
        }
        else {
          fprintf((FILE *)__stream,"To: %s\n",address);
          fprintf((FILE *)__stream,"Subject: Lynx Error in %s\n",filename);
          if ((personal_mail_address != (char *)0x0) && (*personal_mail_address != '\0')) {
            fprintf((FILE *)__stream,"Cc: %s\n",personal_mail_address);
          }
          fprintf((FILE *)__stream,"X-URL: %s\n",filename);
          fprintf((FILE *)__stream,"X-Mailer: %s, Version %s\n\n",&DAT_0814c083,"2.8.7dev.11");
          src = links[cur].target;
          __format_00 = links[cur].lname;
          __format = (char *)gettext("The link   %s :?: %s \n");
          fprintf((FILE *)__stream,__format,__format_00,src);
          src = LYGetHiliteStr(cur,0);
          __format_00 = (char *)gettext("called \"%s\"\n");
          fprintf((FILE *)__stream,__format_00,src);
          src = (char *)gettext("in the file \"%s\" called \"%s\"\n");
          fprintf((FILE *)__stream,src,filename,linkname);
          uVar3 = gettext("was requested but was not available.");
          fprintf((FILE *)__stream,"%s\n\n",uVar3);
          uVar3 = gettext("Thought you might want to know.");
          fprintf((FILE *)__stream,"%s\n\n",uVar3);
          uVar3 = gettext("This message was automatically generated by");
          fprintf((FILE *)__stream,"%s\n",uVar3);
          fprintf((FILE *)__stream,"%s %s",&DAT_0814c083,"2.8.7dev.11");
          if (LynxSigFile != (char *)0x0) {
            fp_00 = (FILE *)fopen64(LynxSigFile,"r");
            if (fp_00 != (FILE *)0x0) {
              fwrite(&DAT_0814c162,1,4,(FILE *)__stream);
              while( true ) {
                src = LYSafeGets(&cmd,fp_00);
                if (src == (char *)0x0) break;
                fputs(cmd,(FILE *)__stream);
              }
              LYCloseInput(fp_00);
            }
          }
          pclose((FILE *)__stream);
          if (traversal != '\0') {
            ofp = LYAppendToTxtFile("traverse.errors");
            if (ofp == (FILE *)0x0) {
              ofp = LYNewTxtFile("traverse.errors");
              if (ofp == (FILE *)0x0) {
                src = (char *)gettext("Unable to open traversal errors output file");
                perror(src);
                exit_immediately(1);
              }
            }
            fprintf((FILE *)ofp,"%s\t%s \tin %s\n",links[cur].lname,links[cur].target,filename);
            LYCloseOutput(ofp);
          }
          if (address != (char *)0x0) {
            free(address);
          }
        }
      }
      else {
        if (address != (char *)0x0) {
          free(address);
          address = (char *)0x0;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"mailmsg: No address in \'%s\'.\n",owner_address);
        }
      }
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080596b1)
// WARNING: Removing unreachable block (ram,0x080596c5)
// WARNING: Removing unreachable block (ram,0x0805968f)
// WARNING: Removing unreachable block (ram,0x080596a0)

void reply_by_mail(char *mail_address,char *filename,char *title,char *refid)

{
  int iVar1;
  bool bVar2;
  LYKeymap_t LVar3;
  char *personal_name;
  BOOLEAN BVar4;
  FILE *fp_00;
  char *local_15e0;
  int iVar5;
  size_t len;
  FILE *fp_01;
  char *__s;
  uint uVar6;
  int in_GS_OFFSET;
  char *local_15d4;
  char *local_15d0;
  char *local_15cc;
  char *local_15c8;
  char *local_15c0;
  char *local_15bc;
  char *msg;
  int n;
  char *header;
  int c;
  int i;
  char *cp1;
  char *cp;
  char *body;
  char *searchpart;
  char *keywords;
  char *ccaddr;
  char *the_subject;
  char *to_address;
  char *cc_address;
  char *from_address;
  char *label;
  FILE *fp;
  FILE *fd;
  BOOLEAN is_preparsed;
  char buf [4096];
  char user_input [1024];
  char my_tmpfile [256];
  char default_subject [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  from_address = (char *)0x0;
  cc_address = (char *)0x0;
  to_address = (char *)0x0;
  the_subject = (char *)0x0;
  ccaddr = (char *)0x0;
  keywords = (char *)0x0;
  searchpart = (char *)0x0;
  body = (char *)0x0;
  header = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    if (refid == (char *)0x0) {
      local_15d4 = "(null)";
    }
    else {
      local_15d4 = refid;
    }
    if (title == (char *)0x0) {
      local_15d0 = "(null)";
    }
    else {
      local_15d0 = title;
    }
    if (filename == (char *)0x0) {
      local_15cc = "(null)";
    }
    else {
      local_15cc = filename;
    }
    if (mail_address == (char *)0x0) {
      local_15c8 = "(null)";
    }
    else {
      local_15c8 = mail_address;
    }
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",local_15c8,local_15cc,
            local_15d0,local_15d4);
  }
  term_letter = '\0';
  BVar4 = LYSystemMail();
  if (BVar4 == '\0') goto LAB_0805a0df;
  if ((mail_address == (char *)0x0) || (*mail_address == '\0')) {
    local_15e0 = (char *)gettext("No email address is present in mailto URL!");
    HTAlert(local_15e0);
    goto LAB_0805a0df;
  }
  HTSACopy(&to_address,mail_address);
  fp_00 = LYOpenTemp(my_tmpfile,".txt","w");
  if (fp_00 == (FILE *)0x0) {
    local_15e0 = (char *)gettext("Unable to open temporary file for mailto URL!");
    HTAlert(local_15e0);
    goto LAB_0805a0df;
  }
  default_subject[0] = '\0';
  local_15e0 = strchr(to_address,0x3f);
  if (local_15e0 != (char *)0x0) {
    HTSACopy(&searchpart,local_15e0);
    *local_15e0 = '\0';
    if (searchpart[1] != '\0') {
      extract_subject(default_subject,searchpart);
      extract_field(&to_address,searchpart,"to=");
      extract_field(&ccaddr,searchpart,"cc=");
      extract_field(&keywords,searchpart,"keywords=");
      if (keywords != (char *)0x0) {
        if (*keywords == '\0') {
          if (keywords != (char *)0x0) {
            free(keywords);
            keywords = (char *)0x0;
          }
        }
        else {
          SafeHTUnEscape(keywords);
        }
      }
      extract_body(&body,searchpart);
      if (searchpart != (char *)0x0) {
        free(searchpart);
        searchpart = (char *)0x0;
      }
    }
  }
  BVar4 = convert_explorer(to_address);
  if (BVar4 == '\0') {
    if (((ccaddr != (char *)0x0) && (BVar4 = convert_explorer(ccaddr), BVar4 != '\0')) &&
       (ccaddr != (char *)0x0)) {
      free(ccaddr);
      ccaddr = (char *)0x0;
    }
    SafeHTUnEscape(to_address);
    if (ccaddr != (char *)0x0) {
      SafeHTUnEscape(ccaddr);
    }
    if (((default_subject[0] == '\0') && (title != (char *)0x0)) && (*title != '\0')) {
      strncpy(default_subject,title,0x46);
      default_subject[70] = '\0';
    }
    signal(2,terminate_letter);
    HTSprintf(&header,"To: %s\n",to_address);
    iVar5 = strncasecomp(LYCharSet_UC[current_char_set].MIMEname,"us-ascii",8);
    if (iVar5 != 0) {
      HTSACat(&header,"Mime-Version: 1.0\n");
      if ((LYHaveCJKCharacterSet == '\0') &&
         (iVar5 = strncasecomp(LYCharSet_UC[current_char_set].MIMEname,"x-",2), iVar5 != 0)) {
        HTSprintf(&header,"Content-Type: text/plain; charset=%s\n",
                  LYCharSet_UC[current_char_set].MIMEname);
      }
      HTSACat(&header,"Content-Transfer-Encoding: 8bit\n");
    }
    if ((filename == (char *)0x0) || (*filename == '\0')) {
      HTSprintf(&header,"X-URL: mailto:%s\n",to_address);
    }
    else {
      HTSprintf(&header,"X-URL: %s\n",filename);
    }
    local_15e0 = "2.8.7dev.11";
    HTSprintf(&header,"X-Mailer: %s, Version %s\n",&DAT_0814c083,"2.8.7dev.11");
    if ((refid != (char *)0x0) && (*refid != '\0')) {
      HTSprintf(&header,"In-Reply-To: <%s>\n",refid,local_15e0);
    }
    LYclear();
    LYmove(2,0);
    scrollok(LYwin,1);
    if (body == (char *)0x0) {
      local_15e0 = (char *)gettext("You are sending a comment to:\n  ");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext("You are sending a comment to:\n  ");
      LYwaddnstr(LYwin,local_15e0,len);
    }
    else {
      local_15e0 = (char *)gettext("You are sending a message with body to:\n  ");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext("You are sending a message with body to:\n  ");
      LYwaddnstr(LYwin,local_15e0,len);
    }
    show_addresses(to_address);
    if (ccaddr != (char *)0x0) {
      local_15e0 = strchr(ccaddr,0x2c);
      if (local_15e0 == (char *)0x0) {
        local_15e0 = (char *)gettext("\n With copy to:\n  ");
        len = strlen(local_15e0);
        local_15e0 = (char *)gettext("\n With copy to:\n  ");
        LYwaddnstr(LYwin,local_15e0,len);
      }
      else {
        local_15e0 = (char *)gettext("\n With copies to:\n  ");
        len = strlen(local_15e0);
        local_15e0 = (char *)gettext("\n With copies to:\n  ");
        LYwaddnstr(LYwin,local_15e0,len);
      }
      show_addresses(ccaddr);
    }
    local_15e0 = (char *)gettext("\n\nUse Ctrl-G to cancel if you do not want to send a message\n");
    len = strlen(local_15e0);
    local_15e0 = (char *)gettext("\n\nUse Ctrl-G to cancel if you do not want to send a message\n");
    LYwaddnstr(LYwin,local_15e0,len);
    local_15e0 = (char *)gettext(
                                "\n Please enter your name, or leave it blank to remain anonymous\n"
                                );
    len = strlen(local_15e0);
    local_15e0 = (char *)gettext(
                                "\n Please enter your name, or leave it blank to remain anonymous\n"
                                );
    LYwaddnstr(LYwin,local_15e0,len);
    iVar5 = header_prompt("X-Personal_Name: ",(char **)0x81ac0e8,0x400);
    if (iVar5 == 0) goto cancelled;
    if (*personal_name != '\0') {
      HTSprintf(&header,"%s: %s\n","X-Personal_Name: ",personal_name);
    }
    local_15e0 = (char *)gettext("\n Please enter a mail address or some other\n");
    len = strlen(local_15e0);
    local_15e0 = (char *)gettext("\n Please enter a mail address or some other\n");
    LYwaddnstr(LYwin,local_15e0,len);
    local_15e0 = (char *)gettext(" means to contact you, if you desire a response.\n");
    len = strlen(local_15e0);
    local_15e0 = (char *)gettext(" means to contact you, if you desire a response.\n");
    LYwaddnstr(LYwin,local_15e0,len);
    if (personal_mail_address != (char *)0x0) {
      HTSACopy(&from_address,personal_mail_address);
    }
    iVar5 = header_prompt("From",&from_address,0x400);
    if (iVar5 == 0) goto cancelled;
    HTSprintf(&header,"%s: %s\n",&DAT_0814c446,from_address);
    local_15e0 = (char *)gettext("\n Please enter a subject line.\n");
    len = strlen(local_15e0);
    local_15e0 = (char *)gettext("\n Please enter a subject line.\n");
    LYwaddnstr(LYwin,local_15e0,len);
    if (default_subject[0] == '\0') {
      if ((filename == (char *)0x0) || (*filename == '\0')) {
        HTSprintf(&the_subject,"mailto:%s",to_address);
      }
      else {
        HTSprintf(&the_subject,"%s",filename);
      }
    }
    else {
      HTSACopy(&the_subject,default_subject);
    }
    iVar5 = header_prompt("Subject",&the_subject,0x46);
    if (iVar5 == 0) goto cancelled;
    if (LYNoCc == '\0') {
      local_15e0 = (char *)gettext("\n Enter a mail address for a CC of your message.\n");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext("\n Enter a mail address for a CC of your message.\n");
      LYwaddnstr(LYwin,local_15e0,len);
      local_15e0 = (char *)gettext(" (Leave blank if you don\'t want a copy.)\n");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext(" (Leave blank if you don\'t want a copy.)\n");
      LYwaddnstr(LYwin,local_15e0,len);
      if (personal_mail_address != (char *)0x0) {
        HTSACopy(&cc_address,personal_mail_address);
      }
      iVar5 = header_prompt("Cc",&cc_address,0x400);
      if (iVar5 == 0) goto cancelled;
      comma_append(&ccaddr,cc_address);
    }
    local_15e0 = the_subject;
    HTSprintf(&header,"%s: %s\n","Subject",the_subject);
    if ((ccaddr != (char *)0x0) && (*ccaddr != '\0')) {
      HTSprintf(&header,"Cc: %s\n",ccaddr,local_15e0);
    }
    if ((keywords != (char *)0x0) && (*keywords != '\0')) {
      HTSprintf(&header,"Keywords: %s\n",keywords,local_15e0);
    }
    HTSACat(&header,"\n");
    local_15e0 = header;
    if (WWW_TraceFlag != '\0') {
      fp_01 = TraceFP();
      fprintf((FILE *)fp_01,"**header==\n%s",local_15e0);
    }
    if (((no_editor != '\0') || (editor == (char *)0x0)) || (*editor == '\0')) {
      if (body != (char *)0x0) {
        LYclear();
        LYmove(0,0);
        local_15e0 = (char *)gettext("\n Please review the message body:\n\n");
        len = strlen(local_15e0);
        local_15e0 = (char *)gettext("\n Please review the message body:\n\n");
        LYwaddnstr(LYwin,local_15e0,len);
        LYrefresh();
        cp1 = body;
        i = LYlines + -5;
        while (local_15e0 = strchr(cp1,10), local_15e0 != (char *)0x0) {
          if (i < 1) {
            __s = (char *)gettext("\nPress RETURN to continue: ");
            len = strlen(__s);
            __s = (char *)gettext("\nPress RETURN to continue: ");
            LYwaddnstr(LYwin,__s,len);
            LYrefresh();
            uVar6 = LYgetch();
            LYwaddnstr(LYwin,"\n",1);
            if (((term_letter != '\0') || (uVar6 == 3)) || (uVar6 == 7)) goto cancelled;
            LVar3 = keymap[0];
            if (uVar6 == 0xffffffff) {
joined_r0x0805988b:
              if (LVar3 == 0x2f) goto cancelled;
            }
            else {
              if ((uVar6 & 0x8800) == 0) {
                LVar3 = keymap[(uVar6 & 0x7ff) + 1];
                goto joined_r0x0805988b;
              }
              if ((uVar6 & 0xff) == 0x2f) goto cancelled;
            }
            i = LYlines + -2;
          }
          *local_15e0 = '\0';
          fprintf((FILE *)fp_00,"%s\n",cp1);
          len = strlen(cp1);
          LYwaddnstr(LYwin,cp1,len);
          LYwaddnstr(LYwin,"\n",1);
          i = i + -1;
          cp1 = local_15e0 + 1;
        }
        while (-1 < i) {
          LYwaddnstr(LYwin,"\n",1);
          i = i + -1;
        }
        LYrefresh();
        LYCloseTempFP(fp_00);
        scrollok(LYwin,0);
        goto LAB_08059bc1;
      }
      local_15e0 = (char *)gettext("\n Please enter your message below.");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext("\n Please enter your message below.");
      LYwaddnstr(LYwin,local_15e0,len);
      local_15e0 = (char *)gettext("\n When you are done, press enter and put a single period (.)");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext("\n When you are done, press enter and put a single period (.)");
      LYwaddnstr(LYwin,local_15e0,len);
      local_15e0 = (char *)gettext("\n on a line and press enter again.");
      len = strlen(local_15e0);
      local_15e0 = (char *)gettext("\n on a line and press enter again.");
      LYwaddnstr(LYwin,local_15e0,len);
      LYwaddnstr(LYwin,"\n\n",2);
      LYrefresh();
      user_input[0] = '\0';
      iVar5 = LYgetstr(user_input,0,0x400,NORECALL);
      if (((-1 < iVar5) && (term_letter == '\0')) && (iVar5 = strcmp(user_input,"."), iVar5 != 0)) {
        do {
          iVar5 = strcmp(user_input,".");
          if ((iVar5 == 0) || (term_letter != '\0')) {
            fputc(10,(FILE *)fp_00);
            LYCloseTempFP(fp_00);
            scrollok(LYwin,0);
            goto LAB_08059bc1;
          }
          LYwaddnstr(LYwin,"\n",1);
          remove_tildes(user_input);
          fprintf((FILE *)fp_00,"%s\n",user_input);
          user_input[0] = '\0';
          iVar5 = LYgetstr(user_input,0,0x400,NORECALL);
        } while (-1 < iVar5);
      }
      goto cancelled;
    }
    if (body == (char *)0x0) {
      local_15e0 = HTLoadedDocumentURL();
      if (*local_15e0 != '\0') {
        if ((LYPreparsedSource == '\0') || (iVar5 = HTisDocumentSource(), iVar5 == 0)) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
        if (bVar2) {
          local_15c0 = (char *)gettext("Do you wish to include the preparsed source?");
        }
        else {
          local_15c0 = (char *)gettext("Do you wish to include the original message?");
        }
        BVar4 = HTConfirm(local_15c0);
        if (BVar4 == '\x01') {
          print_wwwfile_to_fd(fp_00,'\x01',!bVar2);
        }
      }
    }
    else {
      cp1 = body;
      while (local_15e0 = strchr(cp1,10), local_15e0 != (char *)0x0) {
        *local_15e0 = '\0';
        fprintf((FILE *)fp_00,"%s\n",cp1);
        cp1 = local_15e0 + 1;
      }
    }
    LYCloseTempFP(fp_00);
    scrollok(LYwin,0);
    if ((term_letter == '\0') && (keymap[1] != 0x2f)) {
      local_15e0 = (char *)gettext("Spawning your selected editor to edit mail message");
      edit_temporary_file(my_tmpfile,"",local_15e0);
LAB_08059bc1:
      signal(2,(__sighandler_t)0x1);
      LYStatusLine = LYlines + -1;
      if (body == (char *)0x0) {
        local_15bc = (char *)gettext("Send this comment?");
      }
      else {
        local_15bc = (char *)gettext("Send this message?");
      }
      BVar4 = HTConfirm(local_15bc);
      LYStatusLine = -1;
      if (BVar4 == '\x01') {
        if (((body == (char *)0x0) && (LynxSigFile != (char *)0x0)) &&
           (fp_00 = (FILE *)fopen64(LynxSigFile,"r"), local_15e0 = LynxSigFile, fp_00 != (FILE *)0x0
           )) {
          LYStatusLine = LYlines + -1;
          if (term_letter == '\0') {
            msg = (char *)0x0;
            __s = (char *)gettext("Append \'%s\'?");
            HTSprintf0(&msg,__s,local_15e0);
            BVar4 = HTConfirm(msg);
            c = (int)BVar4;
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
          }
          else {
            mustshow = '\x01';
            __s = (char *)gettext("Append \'%s\'?");
            user_message(__s,local_15e0);
            c = 0;
          }
          LYStatusLine = -1;
          if ((c == 1) && (fp_01 = (FILE *)fopen64(my_tmpfile,"a+"), fp_01 != (FILE *)0x0)) {
            msg = (char *)0x0;
            fwrite(&DAT_0814c162,1,4,(FILE *)fp_01);
            while (local_15e0 = LYSafeGets(&msg,fp_00), local_15e0 != (char *)0x0) {
              fputs(msg,(FILE *)fp_01);
            }
            LYCloseOutput(fp_01);
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
          }
          LYCloseInput(fp_00);
        }
        LYclear();
        mustshow = '\x01';
        local_15e0 = (char *)gettext("Sending your message...");
        statusline(local_15e0);
        signal(2,(__sighandler_t)0x1);
        fp_00 = LYPipeToMailer();
        if (fp_00 == (FILE *)0x0) {
          local_15e0 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(local_15e0);
        }
        else {
          fp_01 = (FILE *)fopen64(my_tmpfile,"r");
          if (fp_01 == (FILE *)0x0) {
            local_15e0 = (char *)gettext("Cancelled!!!");
            HTInfoMsg(local_15e0);
            pclose((FILE *)fp_00);
          }
          else {
            fputs(header,(FILE *)fp_00);
            while (len = fread(buf,1,0x1000,(FILE *)fp_01), len != 0) {
              fwrite(buf,1,len,(FILE *)fp_00);
            }
            pclose((FILE *)fp_00);
            LYCloseInput(fp_01);
          }
        }
      }
      else {
        LYclear();
      }
    }
  }
  else {
    local_15e0 = (char *)gettext("No email address is present in mailto URL!");
    HTAlert(local_15e0);
cancelled:
    local_15e0 = (char *)gettext("Cancelled!!!");
    HTInfoMsg(local_15e0);
    LYCloseTempFP(fp_00);
    scrollok(LYwin,0);
  }
  signal(2,cleanup_sig);
  term_letter = '\0';
  if (header != (char *)0x0) {
    free(header);
    header = (char *)0x0;
  }
  LYRemoveTemp(my_tmpfile);
  if (from_address != (char *)0x0) {
    free(from_address);
    from_address = (char *)0x0;
  }
  if (the_subject != (char *)0x0) {
    free(the_subject);
    the_subject = (char *)0x0;
  }
  if (cc_address != (char *)0x0) {
    free(cc_address);
    cc_address = (char *)0x0;
  }
  if (to_address != (char *)0x0) {
    free(to_address);
    to_address = (char *)0x0;
  }
  if (ccaddr != (char *)0x0) {
    free(ccaddr);
    ccaddr = (char *)0x0;
  }
  if (keywords != (char *)0x0) {
    free(keywords);
    keywords = (char *)0x0;
  }
  if (body != (char *)0x0) {
    free(body);
    body = (char *)0x0;
  }
LAB_0805a0df:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



BOOLEAN LYSystemMail(void)

{
  int iVar1;
  char *Msg;
  
  if ((system_mail != (char *)0x0) && (iVar1 = strcmp(system_mail,"unknown"), iVar1 != 0)) {
    return '\x01';
  }
  Msg = (char *)gettext("No system mailer configured");
  HTAlert(Msg);
  return '\0';
}



void HTAlert(char *Msg)

{
  FILE *__stream;
  char *message;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nAlert!: %s\n\n",Msg);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fflush((FILE *)__stream);
  }
  mustshow = '\x01';
  message = (char *)gettext("Alert!: %s");
  user_message(message,Msg);
  message = (char *)gettext("Alert!: %s");
  LYstore_message2(message,Msg);
  if ((dump_output_immediately != '\0') && (dump_to_stderr != '\0')) {
    fflush(stdout);
    message = (char *)gettext("Alert!: %s");
    fprintf(stderr,message,Msg);
    fputc(10,stderr);
    fflush(stderr);
  }
  LYSleepAlert();
  return;
}



void HTAlwaysAlert(char *extra_prefix,char *Msg)

{
  char *__format;
  FILE *__stream;
  FILE *local_18;
  char *local_14;
  FILE *local_c;
  FILE *local_8;
  
  if ((dump_output_immediately == '\0') && (LYCursesON != '\0')) {
    HTAlert(Msg);
  }
  else {
    if (extra_prefix == (char *)0x0) {
      if (Msg == (char *)0x0) {
        local_14 = "";
      }
      else {
        local_14 = Msg;
      }
      __format = (char *)gettext("Alert!: %s");
      if (WWW_TraceFlag == '\0') {
        local_c = stderr;
      }
      else {
        local_c = stdout;
      }
      fprintf(local_c,__format,local_14);
      fflush(stdout);
      __format = (char *)gettext("Alert!: %s");
      LYstore_message2(__format,Msg);
      LYSleepAlert();
      if (WWW_TraceFlag == '\0') {
        local_8 = stderr;
      }
      else {
        local_8 = stdout;
      }
      fputc(10,local_8);
    }
    else {
      if (WWW_TraceFlag == '\0') {
        local_18 = stderr;
      }
      else {
        local_18 = stdout;
      }
      fprintf(local_18,"%s %s!\n",extra_prefix,Msg);
      fflush(stdout);
      __format = (char *)gettext("Alert!: %s");
      LYstore_message2(__format,Msg);
      LYSleepAlert();
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\nAlert!: %s\n\n",Msg);
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fflush((FILE *)__stream);
    }
  }
  return;
}



void HTInfoMsg(char *Msg)

{
  FILE *__stream;
  
  mustshow = '\x01';
  statusline(Msg);
  if ((Msg != (char *)0x0) && (*Msg != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Info message: %s\n",Msg);
    }
    LYstore_message(Msg);
    LYSleepInfo();
  }
  return;
}



void HTInfoMsg2(char *Msg2,char *Arg)

{
  FILE *__stream;
  
  mustshow = '\x01';
  user_message(Msg2,Arg);
  if ((Msg2 != (char *)0x0) && (*Msg2 != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Info message: ");
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,Msg2,Arg);
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
    LYstore_message2(Msg2,Arg);
    LYSleepInfo();
  }
  return;
}



void HTUserMsg(char *Msg)

{
  FILE *__stream;
  
  mustshow = '\x01';
  statusline(Msg);
  if ((Msg != (char *)0x0) && (*Msg != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"User message: %s\n",Msg);
    }
    LYstore_message(Msg);
    LYSleepMsg();
  }
  return;
}



void HTUserMsg2(char *Msg2,char *Arg)

{
  FILE *__stream;
  
  mustshow = '\x01';
  user_message(Msg2,Arg);
  if ((Msg2 != (char *)0x0) && (*Msg2 != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"User message: ");
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,Msg2,Arg);
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
    LYstore_message2(Msg2,Arg);
    LYSleepMsg();
  }
  return;
}



void HTProgress(char *Msg)

{
  FILE *__stream;
  
  statusline(Msg);
  LYstore_message(Msg);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"%s\n",Msg);
  }
  LYSleepDebug();
  return;
}



char * HTProgressUnits(int rate)

{
  char *kbunits;
  char *bunits;
  char *local_8;
  
  if (bunits == (char *)0x0) {
    bunits = (char *)gettext("bytes");
    kbunits = (char *)gettext(LYTransferName);
  }
  if ((rate == 2) || (rate == 4)) {
    local_8 = kbunits;
  }
  else {
    local_8 = bunits;
  }
  return local_8;
}



// WARNING: Removing unreachable block (ram,0x0805a744)
// WARNING: Removing unreachable block (ram,0x0805a79d)

char * sprint_bytes(char *s,off_t n,char *was_units)

{
  double dVar1;
  off_t kb_units;
  size_t sVar2;
  undefined8 uVar3;
  char *u;
  
  u = HTProgressUnits(LYTransferRate);
  if ((LYTransferRate == 2) || (LYTransferRate == 4)) {
    if (n < (longlong)
            ((ulonglong)(uint)kb_units * 10 & 0xffffffff |
            (ulonglong)(uint)(kb_units._4_4_ * 10 + (int)((ulonglong)(uint)kb_units * 10 >> 0x20))
            << 0x20)) {
      if (n < 1000) {
        sprintf(s,"%lld",(int)n,n._4_4_);
        u = HTProgressUnits(1);
      }
      else {
        dVar1 = (double)n / (double)CONCAT44(kb_units._4_4_,(uint)kb_units);
        n._4_4_ = (undefined4)((ulonglong)dVar1 >> 0x20);
        sprintf(s,"%.2g",dVar1);
      }
    }
    else {
      uVar3 = __divdi3(n,(uint)kb_units,kb_units._4_4_);
      n._4_4_ = (undefined4)((ulonglong)uVar3 >> 0x20);
      sprintf(s,"%lld",(int)uVar3,n._4_4_);
    }
  }
  else {
    sprintf(s,"%lld",(int)n,n._4_4_);
  }
  if ((was_units == (char *)0x0) || (was_units != u)) {
    sVar2 = strlen(s);
    sprintf(s + sVar2," %s",u,n._4_4_);
  }
  return u;
}



char * sprint_tbuf(char *s,long t)

{
  if (t < 0xe11) {
    if (t < 0x3d) {
      sprintf(s,"%ld sec",t);
    }
    else {
      sprintf(s,"%ldm%lds",t / 0x3c,t % 0x3c);
    }
  }
  else {
    sprintf(s,"%ldh%ldm%lds",t / 0xe10,(t / 0x3c) % 0x3c,t % 0x3c);
  }
  return s;
}



// WARNING: Removing unreachable block (ram,0x0805ad7b)
// WARNING: Removing unreachable block (ram,0x0805ab3a)
// WARNING: Removing unreachable block (ram,0x0805acfb)
// WARNING: Removing unreachable block (ram,0x0805af20)

void HTReadProgress(off_t bytes,off_t total)

{
  longlong lVar1;
  int iVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double last_active;
  double last;
  double first;
  char *line;
  off_t transfer_rate;
  off_t total_last;
  off_t bytes_last;
  char *fmt;
  char *fmt_00;
  long t;
  FILE *__stream;
  int in_GS_OFFSET;
  uint local_154;
  uint uStack336;
  int local_144;
  double now;
  timeval tv;
  char *was_units;
  int renew;
  char transferp [80];
  char totalp [80];
  char bytesp [80];
  char tbuf [16];
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
  dVar3 = (double)tv.tv_usec / 1000000.00000000 + (double)tv.tv_sec;
  if (LYShowTransferRate == '\0') {
    LYTransferRate = 0;
  }
  dVar4 = dVar3;
  dVar5 = dVar3;
  dVar6 = dVar3;
  bytes_last = bytes;
  if ((bytes != 0) &&
     (dVar4 = last_active, dVar5 = last, dVar6 = first,
     bytes_last = CONCAT44(bytes_last._4_4_,(undefined4)bytes_last), bytes < 0)) {
    bytes = CONCAT44(bytes_last._4_4_,(undefined4)bytes_last);
    total = CONCAT44(total_last._4_4_,(undefined4)total_last);
    bytes_last = CONCAT44(bytes_last._4_4_,(undefined4)bytes_last);
  }
  first = dVar6;
  last = dVar5;
  last_active = dVar4;
  local_144 = (int)total;
  total_last = CONCAT44(total_last._4_4_,(undefined4)total_last);
  if ((0 < bytes) && (total_last = CONCAT44(total_last._4_4_,(undefined4)total_last), first < dVar3)
     ) {
    if (((int)transfer_rate._4_4_ < 1) &&
       (((int)transfer_rate._4_4_ < 0 || ((uint)transfer_rate == 0)))) {
      lVar1 = (longlong)ROUND((double)bytes / (dVar3 - first));
      local_154 = (uint)lVar1;
      uStack336 = (uint)((ulonglong)lVar1 >> 0x20);
      transfer_rate._0_4_ = local_154;
      transfer_rate._4_4_ = uStack336;
    }
    total_last = total;
    if (last + 0.20000000 <= dVar3) {
      if (last < dVar3) {
        if (bytes != bytes_last) {
          last_active = dVar3;
        }
        lVar1 = (longlong)ROUND((double)bytes / (dVar3 - first));
        local_154 = (uint)lVar1;
        uStack336 = (uint)((ulonglong)lVar1 >> 0x20);
        transfer_rate._0_4_ = local_154;
        transfer_rate._4_4_ = uStack336;
        last = dVar3;
        bytes_last = bytes;
      }
      if (total < 1) {
        was_units = (char *)0x0;
      }
      else {
        was_units = sprint_bytes(totalp,total,(char *)0x0);
      }
      sprint_bytes(bytesp,bytes,was_units);
      if (total < 1) {
        fmt = (char *)gettext("Read %s of data");
        HTSprintf0((char **)0x81ac110,fmt,bytesp);
      }
      else {
        fmt = (char *)gettext("Read %s of %s of data");
        HTSprintf0((char **)0x81ac110,fmt,bytesp,totalp);
      }
      if (((LYTransferRate != 0) && (-1 < (int)transfer_rate._4_4_)) &&
         ((0 < (int)transfer_rate._4_4_ || ((uint)transfer_rate != 0)))) {
        sprint_bytes(transferp,CONCAT44(transfer_rate._4_4_,(uint)transfer_rate),(char *)0x0);
        fmt = (char *)gettext(", %s/sec");
        HTSprintf((char **)0x81ac110,fmt,transferp);
      }
      if ((LYTransferRate == 3) || (LYTransferRate == 4)) {
        if (5.00000000 <= dVar3 - last_active) {
          fmt = sprint_tbuf(tbuf,(int)ROUND(dVar3 - last_active));
          fmt_00 = (char *)gettext(" (stalled for %s)");
          HTSprintf((char **)0x81ac110,fmt_00,fmt);
        }
        if ((0 < total) && (((uint)transfer_rate | transfer_rate._4_4_) != 0)) {
          t = __divdi3(total - bytes,(uint)transfer_rate,transfer_rate._4_4_);
          fmt = sprint_tbuf(tbuf,t);
          fmt_00 = (char *)gettext(", ETA %s");
          HTSprintf((char **)0x81ac110,fmt_00,fmt);
        }
      }
      HTSACat((char **)0x81ac110,".");
      if ((0x7fffffffffffffff < (ulonglong)total) && ((total < -0x100000000 || (local_144 != -1))))
      {
        fmt = (char *)gettext(" (Press \'z\' to abort)");
        HTSACat((char **)0x81ac110,fmt);
      }
      statusline(line);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s\n",line);
      }
    }
  }
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



BOOLEAN HTLastConfirmCancelled(void)

{
  bool bVar1;
  
  bVar1 = conf_cancelled != '\0';
  if (bVar1) {
    conf_cancelled = '\0';
  }
  return (BOOLEAN)bVar1;
}



int HTForcedPrompt(int option,char *msg,int dft)

{
  int iVar1;
  char *msg2;
  char *show;
  int result;
  
  msg2 = (char *)0x0;
  if (option == 0) {
    result = HTConfirmDefault(msg,dft);
  }
  else {
    if (option == 1) {
      show = (char *)gettext(&DAT_0814c7d6);
      result = 1;
    }
    else {
      if (option != 2) {
        iVar1 = HTConfirmDefault(msg,dft);
        return iVar1;
      }
      show = (char *)gettext(&DAT_0814c7da);
      result = 0;
    }
    HTSprintf(&msg2,"%s %s",msg,show);
    HTUserMsg(msg2);
    free(msg2);
  }
  return result;
}



int HTConfirmDefault(char *Msg,int Dft)

{
  char cVar1;
  char cVar2;
  LYKeymap_t LVar3;
  char *pcVar4;
  ushort **ppuVar5;
  FILE *__stream;
  uint uVar6;
  uint local_4c;
  uint local_48;
  int local_44;
  int local_40;
  uint local_3c;
  uint local_38;
  char *local_34;
  undefined *local_30;
  int c;
  char *msg;
  int result;
  char *msg_no;
  char *msg_yes;
  char fallback_n;
  char fallback_y;
  
  msg_yes = (char *)gettext(&DAT_0814c7d6);
  msg_no = (char *)gettext(&DAT_0814c7da);
  result = -1;
  ppuVar5 = __ctype_b_loc();
  if (((*ppuVar5)[(byte)*msg_yes] & 0x200) == 0) {
    local_4c = (uint)(byte)*msg_yes;
  }
  else {
    local_4c = toupper((uint)(byte)*msg_yes);
  }
  ppuVar5 = __ctype_b_loc();
  if (((*ppuVar5)[(byte)*msg_no] & 0x200) == 0) {
    local_48 = (uint)(byte)*msg_no;
  }
  else {
    local_48 = toupper((uint)(byte)*msg_no);
  }
  if (local_4c == local_48) {
    msg_yes = "yes";
    msg_no = "no";
  }
  conf_cancelled = '\0';
  if (dump_output_immediately == '\0') {
    msg = (char *)0x0;
    fallback_y = 'y';
    fallback_n = 'n';
    if ((*msg_yes == 'y') || (*msg_no == 'y')) {
      fallback_y = '\0';
    }
    if ((*msg_yes == 'n') || (*msg_no == 'n')) {
      fallback_n = '\0';
    }
    if (Dft == -2) {
      HTSprintf0(&msg,"%s (%c/%c) ",Msg,(int)*msg_yes,(int)*msg_no);
    }
    else {
      if (Dft == 1) {
        cVar1 = *msg_yes;
      }
      else {
        cVar1 = *msg_no;
      }
      local_40 = (int)cVar1;
      HTSprintf0(&msg,"%s (%c) ",Msg,local_40);
    }
    pcVar4 = msg;
    if ((LYTraceLogFP != (FILE *)0x0) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Confirm: %s",pcVar4);
    }
    mustshow = '\x01';
    statusline(msg);
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
    do {
      while( true ) {
        while( true ) {
          while( true ) {
            while( true ) {
              while( true ) {
                if (-1 < result) goto LAB_0805b590;
                uVar6 = LYgetch_single();
                ppuVar5 = __ctype_b_loc();
                if (((*ppuVar5)[(byte)*msg_yes] & 0x200) == 0) {
                  local_3c = (uint)(byte)*msg_yes;
                }
                else {
                  local_3c = toupper((uint)(byte)*msg_yes);
                }
                if (local_3c != uVar6) break;
                result = 1;
              }
              ppuVar5 = __ctype_b_loc();
              if (((*ppuVar5)[(byte)*msg_no] & 0x200) == 0) {
                local_38 = (uint)(byte)*msg_no;
              }
              else {
                local_38 = toupper((uint)(byte)*msg_no);
              }
              if (local_38 != uVar6) break;
              result = 0;
            }
            if ((fallback_y == '\0') || ((int)fallback_y != uVar6)) break;
            result = 1;
          }
          if ((fallback_n == '\0') || ((int)fallback_n != uVar6)) break;
          result = 0;
        }
        if ((uVar6 != 3) && (uVar6 != 7)) break;
LAB_0805b568:
        conf_cancelled = '\x01';
        result = 0;
      }
      LVar3 = keymap[0];
      if (uVar6 == 0xffffffff) {
joined_r0x0805b530:
        if (LVar3 == 0x2f) goto LAB_0805b568;
      }
      else {
        if ((uVar6 & 0x8800) == 0) {
          LVar3 = keymap[(uVar6 & 0x7ff) + 1];
          goto joined_r0x0805b530;
        }
        if ((uVar6 & 0xff) == 0x2f) goto LAB_0805b568;
      }
    } while (Dft == -2);
    result = Dft;
LAB_0805b590:
    if (WWW_TraceFlag != '\0') {
      if (conf_cancelled == '\0') {
        local_34 = "";
      }
      else {
        local_34 = ", cancelled";
      }
      if (result == 0) {
        local_30 = &DAT_0814c853;
      }
      else {
        local_30 = &DAT_0814c84f;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"- %s%s.\n",local_30,local_34);
    }
  }
  else {
    if (Dft == -2) {
      if (WWW_TraceFlag != '\0') {
        cVar1 = *msg_no;
        cVar2 = *msg_yes;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Confirm: %s (%c/%c) ",Msg,(int)cVar2,(int)cVar1);
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        if (Dft == 1) {
          cVar1 = *msg_yes;
        }
        else {
          cVar1 = *msg_no;
        }
        local_44 = (int)cVar1;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Confirm: %s (%c) ",Msg,local_44);
      }
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"- NO, not interactive.\n");
    }
    result = 0;
  }
  return result;
}



BOOLEAN HTConfirm(char *Msg)

{
  int iVar1;
  
  iVar1 = HTConfirmDefault(Msg,-2);
  return (BOOLEAN)iVar1;
}



BOOLEAN confirm_post_resub(char *address,char *title,int if_imgmap,int if_file)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  size_t sVar4;
  char *__s;
  int in_GS_OFFSET;
  BOOLEAN local_11d;
  size_t maxlen;
  char *temp;
  char *msg;
  size_t len1;
  BOOLEAN res;
  char buf [240];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  msg = (char *)gettext("Resubmit POST content to %s ?");
  maxlen = (LYcols - (uint)(LYShowScrollbar != '\0')) - 5;
  if (address == (char *)0x0) {
    local_11d = '\0';
    goto LAB_0805baed;
  }
  iVar2 = strncasecomp(address,"LYNXIMGMAP:",0xb);
  if (iVar2 == 0) {
    if (if_imgmap < 1) {
      local_11d = '\0';
      goto LAB_0805baed;
    }
    if (if_imgmap == 1) {
      local_11d = '\x01';
      goto LAB_0805baed;
    }
    msg = (char *)gettext("List from document with POST data.  Reload %s ?");
  }
  else {
    if (((*address == 'f') || (*address == 'F')) &&
       (iVar2 = strncasecomp(address,"file:",5), iVar2 == 0)) {
      if (if_file < 1) {
        local_11d = '\0';
        goto LAB_0805baed;
      }
      if (if_file == 1) {
        local_11d = '\x01';
        goto LAB_0805baed;
      }
      msg = (char *)gettext("List from document with POST data.  Reload %s ?");
    }
    else {
      if (dump_output_immediately != '\0') {
        local_11d = '\0';
        goto LAB_0805baed;
      }
    }
  }
  if (0xef < maxlen) {
    maxlen = 0xef;
  }
  sVar3 = strlen(msg);
  sVar4 = strlen(address);
  if (maxlen < sVar4 + sVar3) {
    __s = HTParse(address,"",0x1d);
    sVar4 = strlen(__s);
    if (maxlen < sVar4 + sVar3) {
      if (__s != (char *)0x0) {
        free(__s);
      }
      if ((title == (char *)0x0) || (sVar4 = strlen(title), maxlen < sVar4 + sVar3)) {
        __s = HTParse(address,"",0x19);
        sVar4 = strlen(__s);
        if (maxlen < sVar4 + sVar3) {
          if (__s != (char *)0x0) {
            free(__s);
          }
          __s = HTParse(address,"",8);
          if (((__s == (char *)0x0) || (*__s == '\0')) ||
             (sVar4 = strlen(__s), maxlen < sVar4 + sVar3)) {
            if (__s != (char *)0x0) {
              free(__s);
            }
            __s = (char *)gettext("Document from Form with POST content.  Resubmit?");
            local_11d = HTConfirm(__s);
          }
          else {
            sprintf(buf,msg,__s);
            local_11d = HTConfirm(buf);
            if (__s != (char *)0x0) {
              free(__s);
            }
          }
        }
        else {
          sprintf(buf,msg,__s);
          local_11d = HTConfirm(buf);
          if (__s != (char *)0x0) {
            free(__s);
          }
        }
      }
      else {
        sprintf(buf,msg,title);
        local_11d = HTConfirm(buf);
      }
    }
    else {
      sprintf(buf,msg,__s);
      local_11d = HTConfirm(buf);
      if (__s != (char *)0x0) {
        free(__s);
      }
    }
  }
  else {
    sprintf(buf,msg,address);
    local_11d = HTConfirm(buf);
  }
LAB_0805baed:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_11d;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * HTPrompt(char *Msg,char *deflt)

{
  int iVar1;
  int in_GS_OFFSET;
  char *rep;
  char Tmp [200];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  rep = (char *)0x0;
  Tmp[0] = '\0';
  Tmp[199] = '\0';
  mustshow = '\x01';
  statusline(Msg);
  if (deflt != (char *)0x0) {
    strncpy(Tmp,deflt,199);
  }
  if (dump_output_immediately == '\0') {
    LYgetstr(Tmp,0,200,NORECALL);
  }
  HTSACopy(&rep,Tmp);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return rep;
}



char * HTPromptPassword(char *Msg)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  char *local_8c;
  char *result;
  char pw [120];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  pw[0] = '\0';
  if (dump_output_immediately == '\0') {
    mustshow = '\x01';
    if (Msg == (char *)0x0) {
      local_8c = (char *)gettext("Password: ");
    }
    else {
      local_8c = Msg;
    }
    statusline(local_8c);
    LYgetstr(pw,1,0x78,NORECALL);
    HTSACopy(&result,pw);
  }
  else {
    uVar2 = gettext("lynx: Password required!!!");
    printf("\n%s\n",uVar2);
    HTSACopy(&result,"");
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



void HTPromptUsernameAndPassword(char *Msg,char **username,char **password,BOOLEAN IsProxy)

{
  undefined4 uVar1;
  char *deflt;
  char *Msg_00;
  char *local_24;
  char *local_20;
  char *local_1c;
  char *local_18;
  char *local_14;
  char *local_10;
  
  if ((((IsProxy == '\0') && (authentication_info[0] != (char *)0x0)) &&
      (authentication_info[1] != (char *)0x0)) ||
     (((IsProxy == '\x01' && (proxyauth_info[0] != (char *)0x0)) &&
      (proxyauth_info[1] != (char *)0x0)))) {
    if (IsProxy == '\0') {
      local_24 = authentication_info[0];
    }
    else {
      local_24 = proxyauth_info[0];
    }
    HTSACopy(username,local_24);
    if (IsProxy == '\0') {
      if (authentication_info[0] != (char *)0x0) {
        free(authentication_info[0]);
        authentication_info[0] = (char *)0x0;
      }
    }
    else {
      if (proxyauth_info[0] != (char *)0x0) {
        free(proxyauth_info[0]);
        proxyauth_info[0] = (char *)0x0;
      }
    }
    if (IsProxy == '\0') {
      local_20 = authentication_info[1];
    }
    else {
      local_20 = proxyauth_info[1];
    }
    HTSACopy(password,local_20);
    if (IsProxy == '\0') {
      if (authentication_info[1] != (char *)0x0) {
        free(authentication_info[1]);
        authentication_info[1] = (char *)0x0;
      }
    }
    else {
      if (proxyauth_info[1] != (char *)0x0) {
        free(proxyauth_info[1]);
        proxyauth_info[1] = (char *)0x0;
      }
    }
  }
  else {
    if (dump_output_immediately == '\0') {
      if (((IsProxy == '\0') && (authentication_info[0] != (char *)0x0)) ||
         ((IsProxy == '\x01' && (proxyauth_info[0] != (char *)0x0)))) {
        if (IsProxy == '\0') {
          local_14 = authentication_info[0];
        }
        else {
          local_14 = proxyauth_info[0];
        }
        HTSACopy(username,local_14);
        if (IsProxy == '\0') {
          if (authentication_info[0] != (char *)0x0) {
            free(authentication_info[0]);
            authentication_info[0] = (char *)0x0;
          }
        }
        else {
          if (proxyauth_info[0] != (char *)0x0) {
            free(proxyauth_info[0]);
            proxyauth_info[0] = (char *)0x0;
          }
        }
      }
      if (Msg == (char *)0x0) {
        deflt = *username;
        Msg_00 = (char *)gettext("Username: ");
        deflt = HTPrompt(Msg_00,deflt);
        *username = deflt;
      }
      else {
        deflt = HTPrompt(Msg,*username);
        *username = deflt;
      }
      if (((IsProxy == '\0') && (authentication_info[1] != (char *)0x0)) ||
         ((IsProxy == '\x01' && (proxyauth_info[1] != (char *)0x0)))) {
        if (IsProxy == '\0') {
          local_10 = authentication_info[1];
        }
        else {
          local_10 = proxyauth_info[1];
        }
        HTSACopy(password,local_10);
        if (IsProxy == '\0') {
          if (authentication_info[1] != (char *)0x0) {
            free(authentication_info[1]);
            authentication_info[1] = (char *)0x0;
          }
        }
        else {
          if (proxyauth_info[1] != (char *)0x0) {
            free(proxyauth_info[1]);
            proxyauth_info[1] = (char *)0x0;
          }
        }
      }
      else {
        if ((*username == (char *)0x0) || (**username == '\0')) {
          HTSACopy(password,"");
        }
        else {
          deflt = (char *)gettext("Password: ");
          deflt = HTPromptPassword(deflt);
          *password = deflt;
        }
      }
    }
    else {
      if (((IsProxy == '\0') && (authentication_info[0] != (char *)0x0)) ||
         ((IsProxy == '\x01' && (proxyauth_info[0] != (char *)0x0)))) {
        if (IsProxy == '\0') {
          local_1c = authentication_info[0];
        }
        else {
          local_1c = proxyauth_info[0];
        }
        HTSACopy(username,local_1c);
        if (IsProxy == '\0') {
          if (authentication_info[0] != (char *)0x0) {
            free(authentication_info[0]);
            authentication_info[0] = (char *)0x0;
          }
        }
        else {
          if (proxyauth_info[0] != (char *)0x0) {
            free(proxyauth_info[0]);
            proxyauth_info[0] = (char *)0x0;
          }
        }
      }
      else {
        HTSACopy(username,"WWWuser");
      }
      if (((IsProxy == '\0') && (authentication_info[1] != (char *)0x0)) ||
         ((IsProxy == '\x01' && (proxyauth_info[1] != (char *)0x0)))) {
        if (IsProxy == '\0') {
          local_18 = authentication_info[1];
        }
        else {
          local_18 = proxyauth_info[1];
        }
        HTSACopy(password,local_18);
        if (IsProxy == '\0') {
          if (authentication_info[1] != (char *)0x0) {
            free(authentication_info[1]);
            authentication_info[1] = (char *)0x0;
          }
        }
        else {
          if (proxyauth_info[1] != (char *)0x0) {
            free(proxyauth_info[1]);
            proxyauth_info[1] = (char *)0x0;
          }
        }
      }
      else {
        HTSACopy(password,"");
      }
      uVar1 = gettext("lynx: Username and Password required!!!");
      printf("\n%s\n",uVar1);
    }
  }
  return;
}



BOOLEAN HTConfirmCookie(domain_entry *de,char *server,char *name,char *value)

{
  char cVar1;
  char cVar2;
  char *string;
  int iVar3;
  size_t sVar4;
  char *Msg2;
  ushort **ppuVar5;
  FILE *__stream;
  int iVar6;
  BOOLEAN local_45;
  uint local_40;
  char *s;
  char *p;
  char *message;
  int percentage;
  int space_free;
  int valuelen;
  int namelen;
  char *prompt;
  int ch;
  
  string = (char *)gettext("%s cookie: %.*s=%.*s  Allow? (Y/N/Always/neVer)");
  if (de == (domain_entry *)0x0) {
    local_45 = '\0';
  }
  else {
    if (de->bv == ACCEPT_ALWAYS) {
      local_45 = '\x01';
    }
    else {
      if (de->bv == REJECT_ALWAYS) {
        local_45 = '\0';
      }
      else {
        if (dump_output_immediately == '\0') {
          if (LYAcceptAllCookies == '\0') {
            message = (char *)0x0;
            iVar6 = LYcols - (uint)(LYShowScrollbar != '\0');
            iVar3 = LYstrCells(string);
            sVar4 = strlen(server);
            space_free = (iVar6 + (10 - iVar3)) - sVar4;
            if (space_free < 0) {
              space_free = 0;
            }
            namelen = strlen(name);
            valuelen = strlen(value);
            if (space_free < namelen + valuelen) {
              iVar3 = (space_free * 100) / (namelen + valuelen);
              namelen = (iVar3 * namelen) / 100;
              valuelen = (iVar3 * valuelen) / 100;
            }
            HTSprintf(&message,string,server,namelen,name,valuelen,value);
            mustshow = '\x01';
            statusline(message);
            if (message != (char *)0x0) {
              free(message);
              message = (char *)0x0;
            }
          }
LAB_0805c303:
          do {
            if (LYAcceptAllCookies == '\0') {
              ch = LYgetch_single();
              gettext("Y/N/A/V");
              s = "YNAV\a\x03";
              Msg2 = strchr("YNAV\a\x03",ch);
              if (((Msg2 == (char *)0x0) &&
                  (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[ch] & 0x400) != 0)) &&
                 (p = strrchr(string,0x28), p != (char *)0x0)) {
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"Looking for %c in %s\n",ch,p);
                }
                do {
                  if (((*p == ')') || (*p == '\0')) ||
                     (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*s] & 0x400) == 0)) break;
                  ppuVar5 = __ctype_b_loc();
                  if (((*ppuVar5)[(byte)*p] & 0x400) != 0) {
                    cVar1 = *p;
                    ppuVar5 = __ctype_b_loc();
                    if (((*ppuVar5)[(byte)*p] & 0x200) == 0) {
                      local_40 = (uint)(byte)*p;
                    }
                    else {
                      local_40 = toupper((uint)(byte)*p);
                    }
                    if ((int)cVar1 == local_40) {
                      if (WWW_TraceFlag != '\0') {
                        cVar1 = *s;
                        cVar2 = *p;
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"...testing %c/%c\n",(int)cVar2,(int)cVar1);
                      }
                      if ((int)*p == ch) {
                        ch = (int)*s;
                        break;
                      }
                      s = s + 1;
                    }
                  }
                  p = p + 1;
                } while( true );
              }
            }
            else {
              ch = 0x41;
            }
            if (ch == 0x4e) break;
            if (ch < 0x4f) {
              if (ch == 0x41) {
                de->bv = ACCEPT_ALWAYS;
                string = de->domain;
                Msg2 = (char *)gettext("\'A\'lways allowing from domain \'%s\'.");
                HTUserMsg2(Msg2,string);
                return '\x01';
              }
            }
            else {
              if (ch == 0x56) {
                de->bv = REJECT_ALWAYS;
                string = de->domain;
                Msg2 = (char *)gettext("ne\'V\'er allowing from domain \'%s\'.");
                HTUserMsg2(Msg2,string);
                return '\0';
              }
              if (ch == 0x59) {
                string = (char *)gettext("Allowing this cookie.");
                HTInfoMsg(string);
                return '\x01';
              }
            }
            if ((ch == 3) || (ch == 7)) break;
            if (ch != -1) {
              if ((ch & 0x8800U) == 0) {
                if (keymap[(ch & 0x7ffU) + 1] == 0x2f) break;
              }
              else {
                if ((ch & 0xffU) == 0x2f) break;
              }
              goto LAB_0805c303;
            }
          } while (keymap[0] != 0x2f);
          string = (char *)gettext("Rejecting this cookie.");
          HTUserMsg(string);
          local_45 = '\0';
        }
        else {
          local_45 = LYSetCookies;
        }
      }
    }
  }
  return local_45;
}



int HTConfirmPostRedirect(char *Redirecting_url,int server_status)

{
  size_t len;
  char *src;
  int iVar1;
  int local_30;
  int local_2c;
  undefined4 local_28;
  int c;
  int on_screen;
  char *url;
  char *StatusInfo;
  char *show_POST_url;
  int result;
  
  result = -1;
  show_POST_url = (char *)0x0;
  StatusInfo = (char *)0x0;
  url = (char *)0x0;
  on_screen = 0;
  if ((server_status == 0x12f) || (server_status == 0x12e)) {
    local_30 = 0x12f;
  }
  else {
    if (dump_output_immediately == '\0') {
      if (user_mode == 0) {
        on_screen = 2;
        LYmove(LYlines + -2,0);
        src = (char *)gettext("Server asked for %d redirection of POST content to");
        HTSprintf0(&StatusInfo,src,server_status);
        len = strlen(StatusInfo);
        LYwaddnstr(LYwin,StatusInfo,len);
        LYclrtoeol();
        LYmove(LYlines + -1,0);
        if (LYcols < 0xfa) {
          local_2c = (LYcols - (uint)(LYShowScrollbar != '\0')) + -5;
        }
        else {
          local_2c = 0xfa;
        }
        HTSprintf0(&url,"URL: %.*s",local_2c,Redirecting_url);
        len = strlen(url);
        LYwaddnstr(LYwin,url,len);
        LYclrtoeol();
        if (server_status == 0x12d) {
          mustshow = '\x01';
          src = (char *)gettext("P)roceed, use G)ET or C)ancel ");
          statusline(src);
        }
        else {
          mustshow = '\x01';
          src = (char *)gettext("P)roceed, or C)ancel ");
          statusline(src);
        }
      }
      else {
        if (server_status == 0x12d) {
          local_28 = gettext("Redirection of POST content.  P)roceed, see U)RL, use G)ET or C)ancel"
                            );
        }
        else {
          local_28 = gettext("Redirection of POST content.  P)roceed, see U)RL, or C)ancel");
        }
        HTSprintf0(&StatusInfo,"%d %.*s",server_status,0xfb,local_28);
        src = (char *)gettext("Location: ");
        HTSACopy(&show_POST_url,src);
        HTSACat(&show_POST_url,Redirecting_url);
      }
      while (result < 0) {
        if (on_screen == 0) {
          mustshow = '\x01';
          statusline(StatusInfo);
        }
        else {
          if (on_screen == 1) {
            mustshow = '\x01';
            statusline(show_POST_url);
          }
        }
        iVar1 = LYgetch_single();
        if (iVar1 == 0x47) {
          if (server_status == 0x12d) {
            if (show_POST_url != (char *)0x0) {
              free(show_POST_url);
              show_POST_url = (char *)0x0;
            }
            result = 0x12f;
          }
          else {
LAB_0805c98b:
            if (on_screen == 1) {
              on_screen = 0;
            }
            else {
              on_screen = 2;
            }
          }
        }
        else {
          if (iVar1 < 0x48) {
            if ((iVar1 != 7) && (iVar1 != 0x43)) goto LAB_0805c98b;
            if (show_POST_url != (char *)0x0) {
              free(show_POST_url);
              show_POST_url = (char *)0x0;
            }
            result = 0;
          }
          else {
            if (iVar1 == 0x50) {
              if (show_POST_url != (char *)0x0) {
                free(show_POST_url);
                show_POST_url = (char *)0x0;
              }
              result = 1;
            }
            else {
              if (iVar1 != 0x55) goto LAB_0805c98b;
              if (user_mode != 0) {
                if (on_screen == 1) {
                  on_screen = 0;
                }
                else {
                  on_screen = 1;
                }
              }
            }
          }
        }
      }
      if (StatusInfo != (char *)0x0) {
        free(StatusInfo);
        StatusInfo = (char *)0x0;
      }
      if (url != (char *)0x0) {
        free(url);
      }
      local_30 = result;
    }
    else {
      if (server_status == 0x12d) {
        local_30 = 0x12f;
      }
      else {
        local_30 = 0;
      }
    }
  }
  return local_30;
}



void LYSleepAlert(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(AlertSecs);
  }
  return;
}



void LYSleepDebug(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(DebugSecs);
  }
  return;
}



void LYSleepInfo(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(InfoSecs);
  }
  return;
}



void LYSleepMsg(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(MessageSecs);
  }
  return;
}



void LYSleepReplay(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(ReplaySecs);
  }
  return;
}



pool_data * ALLOC_IN_POOL(HTPool **ppoolptr,uint request)

{
  HTPool *pHVar1;
  HTPool *newpool;
  uint j;
  uint n;
  pool_data *ptr;
  HTPool *pool;
  
  pHVar1 = *ppoolptr;
  if (pHVar1 == (HTPool *)0x0) {
    ptr = (pool_data *)0x0;
  }
  else {
    n = request;
    if (request == 0) {
      n = 1;
    }
    if ((n & 7) != 0) {
      n = (n - (n & 7)) + 8;
    }
    n = n >> 2;
    if (pHVar1->used + n < 0x7fb) {
      ptr = pHVar1->data + pHVar1->used;
      pHVar1->used = pHVar1->used + n;
    }
    else {
      ptr = (pool_data *)LY_check_calloc(1,0x1ff0);
      if ((HTPool *)ptr == (HTPool *)0x0) {
        ptr = (pool_data *)0x0;
      }
      else {
        *(HTPool **)&((HTPool *)ptr)->prev = pHVar1;
        ((HTPool *)ptr)->used = n;
        *(pool_data **)ppoolptr = ptr;
      }
    }
  }
  return ptr;
}



HTPool * POOL_NEW(void)

{
  HTPool *pHVar1;
  HTPool *poolptr;
  
  pHVar1 = (HTPool *)LY_check_calloc(1,0x1ff0);
  if (pHVar1 != (HTPool *)0x0) {
    pHVar1->prev = (_HTPool *)0x0;
    pHVar1->used = 0;
  }
  return pHVar1;
}



void POOL_FREE(HTPool *poolptr)

{
  _HTPool *p_Var1;
  HTPool *prev;
  HTPool *cur;
  
  cur = poolptr;
  while (cur != (HTPool *)0x0) {
    p_Var1 = cur->prev;
    free(cur);
    cur = (HTPool *)p_Var1;
  }
  return;
}



void * HText_pool_calloc(HText *text,uint size)

{
  pool_data *ppVar1;
  
  ppVar1 = ALLOC_IN_POOL(&text->pool,size);
  return ppVar1;
}



void ht_justify_cleanup(void)

{
  int local_8;
  
  if ((ok_justify == '\0') || (psrc_view != '\0')) {
    local_8 = 0x7532;
  }
  else {
    local_8 = -1;
  }
  in_DT = '\0';
  have_raw_nbsps = '\0';
  this_line_was_split = '\0';
  last_anchor_of_previous_line = (TextAnchor *)0x0;
  form_in_htext = '\0';
  can_justify_this_line = '\x01';
  wait_for_this_stacked_elt = local_8;
  can_justify_here = '\x01';
  return;
}



void mark_justify_start_position(void *text)

{
  if ((text != (void *)0x0) && (*(int *)((int)text + 4) != 0)) {
    justify_start_position = ZEXT24(*(ushort *)(*(int *)((int)text + 4) + 10));
  }
  return;
}



void HText_halt(void)

{
  if (0 < HTFormNumber) {
    HText_DisableCurrentForm();
  }
  if ((HTMainText != (HText *)0x0) && (HTMainText->halted < 2)) {
    HTMainText->halted = 2;
  }
  return;
}



BOOLEAN mem_is_avail(size_t factor,size_t bytes)

{
  void *__ptr;
  BOOLEAN local_15;
  void *p;
  
  if ((bytes < 5000) && (factor != 0)) {
    bytes = 5000;
  }
  if (factor == 0) {
    factor = 1;
  }
  __ptr = malloc(factor * bytes);
  if (__ptr == (void *)0x0) {
    local_15 = '\0';
  }
  else {
    if (__ptr != (void *)0x0) {
      free(__ptr);
    }
    local_15 = '\x01';
  }
  return local_15;
}



void * LY_check_calloc(size_t nmemb,size_t size)

{
  int iVar1;
  BOOLEAN BVar2;
  int iVar3;
  HText *self;
  FILE *__stream;
  char *Msg;
  void *pvVar4;
  void *local_24;
  char *local_20;
  char *local_1c;
  HText *t;
  int n;
  int i;
  
  BVar2 = mem_is_avail(4,nmemb * size);
  if (BVar2 == '\0') {
    iVar3 = HTList_count(loaded_texts);
    iVar1 = iVar3;
    do {
      i = iVar1 + -1;
      if (i < 1) {
        LYFakeZap('\x01');
        if ((HTMainText == (HText *)0x0) || (HTMainText->halted < 2)) {
          BVar2 = mem_is_avail(2,nmemb * size);
          if (BVar2 == '\0') {
            HText_halt();
            BVar2 = mem_is_avail(0,700);
            if (BVar2 != '\0') {
              Msg = (char *)gettext("Memory exhausted, display interrupted!");
              HTAlert(Msg);
            }
          }
          else {
            if (((HTMainText == (HText *)0x0) || (HTMainText->halted == 0)) &&
               (BVar2 = mem_is_avail(0,700), BVar2 != '\0')) {
              Msg = (char *)gettext("Memory exhausted, will interrupt transfer!");
              HTAlert(Msg);
              if (HTMainText != (HText *)0x0) {
                HTMainText->halted = 1;
              }
            }
          }
        }
        pvVar4 = calloc(nmemb,size);
        return pvVar4;
      }
      self = (HText *)HTList_objectAt(loaded_texts,i);
      if (WWW_TraceFlag != '\0') {
        if (((self == (HText *)0x0) || (self->node_anchor == (HTParentAnchor *)0x0)) ||
           (self->node_anchor->post_data == (bstring *)0x0)) {
          local_20 = "";
        }
        else {
          local_20 = " with POST data";
        }
        if (((self == (HText *)0x0) || (self->node_anchor == (HTParentAnchor *)0x0)) ||
           (self->node_anchor->address == (char *)0x0)) {
          local_1c = "unknown anchor";
        }
        else {
          local_1c = self->node_anchor->address;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\nBUG *** Emergency freeing document %d/%d for \'%s\'%s!\n",iVar1,
                iVar3,local_1c,local_20);
      }
      HTList_removeObjectAt(loaded_texts,i);
      HText_free(self);
      BVar2 = mem_is_avail(4,nmemb * size);
      iVar1 = i;
    } while (BVar2 == '\0');
    local_24 = calloc(nmemb,size);
  }
  else {
    local_24 = calloc(nmemb,size);
  }
  return local_24;
}



int StyleToCols(HText *text,HTLine *line,int nstyle)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  int utf_extra;
  char *last;
  char *data;
  int nchars;
  int result;
  
  result = ZEXT24(line->offset);
  nchars = ZEXT24(*(ushort *)(line->styles + nstyle) >> 2);
  data = line->data;
  pcVar1 = data + line->size;
  while ((0 < nchars && (data < pcVar1))) {
    if ((*data < '\x03') || (('\b' < *data || (*data == '\b')))) {
      sVar2 = utf8_length((text->T).output_utf8,data);
      if (sVar2 == 0) {
        if ((HTCJK == NOCJK) || (-1 < *data)) {
          data = data + 1;
          result = result + 1;
        }
        else {
          data = data + 2;
          result = result + 2;
        }
      }
      else {
        iVar3 = LYstrExtent(data,sVar2 + 1,2);
        result = result + iVar3;
        data = data + sVar2 + 1;
      }
      nchars = nchars + -1;
    }
    else {
      data = data + 1;
    }
  }
  return result;
}



void LYClearHiText(TextAnchor *a)

{
  if ((a->lites).hl_info != (HiliteInfo *)0x0) {
    free((a->lites).hl_info);
    (a->lites).hl_info = (HiliteInfo *)0x0;
  }
  (a->lites).hl_base.hl_text = (char *)0x0;
  (a->lites).hl_len = 0;
  return;
}



void LYSetHiText(TextAnchor *a,char *text,int len)

{
  pool_data *ppVar1;
  
  if (text != (char *)0x0) {
    ppVar1 = ALLOC_IN_POOL(&HTMainText->pool,len + 2);
    *(pool_data **)&(a->lites).hl_base.hl_text = ppVar1;
    memcpy((a->lites).hl_base.hl_text,text,len);
    (a->lites).hl_base.hl_text[len] = '\0';
    (a->lites).hl_len = 1;
  }
  return;
}



void LYAddHiText(TextAnchor *a,char *text,int x)

{
  HiliteInfo *__ptr;
  int iVar1;
  size_t __size;
  pool_data *ppVar2;
  uint want;
  uint need;
  HiliteInfo *have;
  
  __ptr = (a->lites).hl_info;
  iVar1 = (int)(a->lites).hl_len + -1;
  (a->lites).hl_len = (a->lites).hl_len + 1;
  __size = (int)(a->lites).hl_len << 3;
  if (__ptr == (HiliteInfo *)0x0) {
    have = (HiliteInfo *)malloc(__size);
  }
  else {
    have = (HiliteInfo *)realloc(__ptr,__size);
  }
  (a->lites).hl_info = have;
  __size = strlen(text);
  ppVar2 = ALLOC_IN_POOL(&HTMainText->pool,__size + 2);
  *(pool_data **)&have[iVar1].hl_text = ppVar2;
  strcpy(have[iVar1].hl_text,text);
  have[iVar1].hl_x = (short)x;
  return;
}



int LYAdjHiTextPos(TextAnchor *a,int count)

{
  char *local_18;
  char *result;
  
  if (count < (a->lites).hl_len) {
    if (count < 1) {
      result = (a->lites).hl_base.hl_text;
    }
    else {
      result = (a->lites).hl_info[(1 - count) * 0x1fffffff].hl_text;
    }
  }
  else {
    result = (char *)0x0;
  }
  if (result == (char *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = LYSkipBlanks(result);
    local_18 = local_18 + -(int)result;
  }
  return (int)local_18;
}



char * LYGetHiTextStr(TextAnchor *a,int count)

{
  int iVar1;
  char *result;
  
  if (count < (a->lites).hl_len) {
    if (count < 1) {
      result = (a->lites).hl_base.hl_text;
    }
    else {
      result = (a->lites).hl_info[(1 - count) * 0x1fffffff].hl_text;
    }
  }
  else {
    result = (char *)0x0;
  }
  iVar1 = LYAdjHiTextPos(a,count);
  return result + iVar1;
}



int LYGetHiTextPos(TextAnchor *a,int count)

{
  int iVar1;
  int result;
  
  if (count < (a->lites).hl_len) {
    if (count < 1) {
      result = (int)a->line_pos;
    }
    else {
      result = (int)(a->lites).hl_info[(1 - count) * 0x1fffffff].hl_x;
    }
  }
  else {
    result = -1;
  }
  iVar1 = LYAdjHiTextPos(a,count);
  return result + iVar1;
}



void LYCopyHiText(TextAnchor *a,TextAnchor *b)

{
  char *text;
  size_t len;
  int x;
  char *s;
  int count;
  
  LYClearHiText(a);
  count = 0;
  while( true ) {
    text = LYGetHiTextStr(b,count);
    if (text == (char *)0x0) break;
    if (count == 0) {
      len = strlen(text);
      LYSetHiText(a,text,len);
    }
    else {
      x = LYGetHiTextPos(b,count);
      LYAddHiText(a,text,x);
    }
    count = count + 1;
  }
  return;
}



void HText_getChartransInfo(HText *me)

{
  int iVar1;
  LYUCcharset *pLVar2;
  int chndl;
  
  iVar1 = HTAnchor_getUCLYhndl(me->node_anchor,3);
  me->UCLYhndl = iVar1;
  if (me->UCLYhndl < 0) {
    HTAnchor_setUCInfoStage(me->node_anchor,current_char_set,3,3);
    iVar1 = HTAnchor_getUCLYhndl(me->node_anchor,3);
    me->UCLYhndl = iVar1;
  }
  pLVar2 = HTAnchor_getUCInfoStage(me->node_anchor,3);
  me->UCI = pLVar2;
  return;
}



void PerFormInfo_free(PerFormInfo *form)

{
  if (form != (PerFormInfo *)0x0) {
    if (form->accept_cs != (char *)0x0) {
      free(form->accept_cs);
      form->accept_cs = (char *)0x0;
    }
    if (form->thisacceptcs != (char *)0x0) {
      free(form->thisacceptcs);
      form->thisacceptcs = (char *)0x0;
    }
    if (form != (PerFormInfo *)0x0) {
      free(form);
    }
  }
  return;
}



void free_form_fields(FormInfo *input_field)

{
  _OptionType *p_Var1;
  OptionType *tmp;
  OptionType *optptr;
  
  if ((input_field->type == 7) && (input_field->select_list != (OptionType *)0x0)) {
    p_Var1 = (_OptionType *)input_field->select_list;
    while (optptr = (OptionType *)p_Var1, optptr != (OptionType *)0x0) {
      p_Var1 = optptr->next;
      if (optptr->name != (char *)0x0) {
        free(optptr->name);
        optptr->name = (char *)0x0;
      }
      if (optptr->cp_submit_value != (char *)0x0) {
        free(optptr->cp_submit_value);
        optptr->cp_submit_value = (char *)0x0;
      }
      if (optptr != (OptionType *)0x0) {
        free(optptr);
      }
    }
    input_field->select_list = (OptionType *)0x0;
    input_field->value = (char *)0x0;
    input_field->orig_value = (char *)0x0;
    input_field->cp_submit_value = (char *)0x0;
    input_field->orig_submit_value = (char *)0x0;
  }
  else {
    if (input_field->value != (char *)0x0) {
      free(input_field->value);
      input_field->value = (char *)0x0;
    }
    if (input_field->orig_value != (char *)0x0) {
      free(input_field->orig_value);
      input_field->orig_value = (char *)0x0;
    }
    if (input_field->cp_submit_value != (char *)0x0) {
      free(input_field->cp_submit_value);
      input_field->cp_submit_value = (char *)0x0;
    }
    if (input_field->orig_submit_value != (char *)0x0) {
      free(input_field->orig_submit_value);
      input_field->orig_submit_value = (char *)0x0;
    }
  }
  if (input_field->name != (char *)0x0) {
    free(input_field->name);
    input_field->name = (char *)0x0;
  }
  if (input_field->submit_action != (char *)0x0) {
    free(input_field->submit_action);
    input_field->submit_action = (char *)0x0;
  }
  if (input_field->submit_enctype != (char *)0x0) {
    free(input_field->submit_enctype);
    input_field->submit_enctype = (char *)0x0;
  }
  if (input_field->submit_title != (char *)0x0) {
    free(input_field->submit_title);
    input_field->submit_title = (char *)0x0;
  }
  if (input_field->accept_cs != (char *)0x0) {
    free(input_field->accept_cs);
    input_field->accept_cs = (char *)0x0;
  }
  return;
}



void FormList_delete(HTList *forms)

{
  PerFormInfo *local_18;
  PerFormInfo *form;
  HTList *cur;
  
  cur = forms;
  while( true ) {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_18 = (PerFormInfo *)0x0;
    }
    else {
      local_18 = (PerFormInfo *)cur->object;
    }
    if (local_18 == (PerFormInfo *)0x0) break;
    PerFormInfo_free(local_18);
  }
  HTList_delete(forms);
  return;
}



void ResetPartialLinenos(HText *text)

{
  if (text != (HText *)0x0) {
    text->first_lineno_last_disp_partial = -1;
    text->last_lineno_last_disp_partial = -1;
  }
  return;
}



HText * HText_new(HTParentAnchor *anchor)

{
  HTLine *pHVar1;
  BOOLEAN BVar2;
  HText *me;
  FILE *__stream;
  int iVar3;
  HText *self_00;
  HTPool *pHVar4;
  LYUCcharset *p_in;
  short local_2a;
  BOOLEAN local_28;
  bool local_21;
  BOOLEAN local_20;
  HText *self;
  HTLine *line;
  
  me = (HText *)calloc(1,0x904);
  if (me != (HText *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GridText: start HText_new\n");
    }
    if (HTMainText != (HText *)0x0) {
      BVar2 = HText_hasUTF8OutputSet(HTMainText);
      if (((BVar2 == '\0') || (BVar2 = HTLoadedDocumentEightbit(), BVar2 == '\0')) ||
         (LYCharSet_UC[current_char_set].enc != 7)) {
        me->had_utf8 = HTMainText->has_utf8;
      }
      else {
        me->had_utf8 = HTMainText->has_utf8;
      }
      HTMainText->has_utf8 = '\0';
    }
    if (loaded_texts == (HTList *)0x0) {
      loaded_texts = HTList_new();
    }
    if (anchor->document != (HyperDoc *)0x0) {
      HTList_removeObject(loaded_texts,anchor->document);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: Auto-uncaching\n");
      }
      HTAnchor_delete_links(anchor);
      *(undefined4 *)anchor->document = 0;
      HText_free((HText *)anchor->document);
      anchor->document = (HyperDoc *)0x0;
    }
    HTList_addObject(loaded_texts,me);
    iVar3 = HTList_count(loaded_texts);
    if (HTCacheSize < iVar3) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: Freeing off cached doc.\n");
      }
      self_00 = (HText *)HTList_removeFirstObject(loaded_texts);
      HText_free(self_00);
    }
    pHVar4 = POOL_NEW();
    me->pool = pHVar4;
    if (me->pool == (HTPool *)0x0) {
      outofmem("./GridText.c","HText_New");
    }
    *(HTLineTemp **)&me->last_line = me->temp_line;
    pHVar1 = me->last_line;
    *(HTLine **)&pHVar1->prev = pHVar1;
    pHVar1->next = pHVar1->prev;
    pHVar1->size = 0;
    pHVar1->offset = pHVar1->size;
    pHVar1->data[pHVar1->size] = '\0';
    pHVar1->numstyles = 0;
    pHVar1->styles = stylechanges_buffers;
    me->Lines = 0;
    me->last_anchor = (TextAnchor *)0x0;
    me->first_anchor = me->last_anchor;
    me->last_anchor_before_split = (TextAnchor *)0x0;
    me->style = &default_style;
    me->top_of_screen = 0;
    me->node_anchor = anchor;
    me->last_anchor_number = 0;
    me->stale = '\x01';
    me->toolbar = '\0';
    me->tabs = (HTList *)0x0;
    me->clickable_images = clickable_images;
    me->pseudo_inline_alts = pseudo_inline_alts;
    me->verbose_img = verbose_img;
    me->raw_mode = LYUseDefaultRawMode;
    me->historical_comments = historical_comments;
    me->minimal_comments = minimal_comments;
    me->soft_dquotes = soft_dquotes;
    me->old_dtd = (short)Old_DTD;
    me->keypad_mode = (short)keypad_mode;
    me->disp_lines = (short)LYlines;
    if (LYwideLines == 0) {
      local_2a = (short)LYcols;
    }
    else {
      local_2a = 0x3f6;
    }
    me->disp_cols = local_2a;
    if (((anchor->bookmark == (char *)0x0) &&
        (BVar2 = LYIsUIPage3(anchor->address,UIP_LIST_PAGE,0), BVar2 == '\0')) &&
       (BVar2 = LYIsUIPage3(anchor->address,UIP_ADDRLIST_PAGE,0), BVar2 == '\0')) {
      me->hiddenlinkflag = LYHiddenLinks;
    }
    else {
      me->hiddenlinkflag = 0;
    }
    me->hidden_links = (HTList *)0x0;
    if ((anchor->no_cache == '\0') && (anchor->post_data == (bstring *)0x0)) {
      local_28 = '\0';
    }
    else {
      local_28 = '\x01';
    }
    me->no_cache = local_28;
    me->LastChar = '\0';
    me->IgnoreExcess = '\0';
    if (LYpsrc == '\0') {
      local_21 = HTOutputFormat == (HTFormat)WWW_SOURCE;
    }
    else {
      if ((mark_htext_as_source == '\0') && (psrc_view == '\0')) {
        local_20 = '\0';
      }
      else {
        local_20 = '\x01';
      }
      local_21 = (bool)local_20;
    }
    *(bool *)&me->source = local_21;
    mark_htext_as_source = '\0';
    HTAnchor_setDocument(anchor,(HyperDoc *)me);
    HTFormNumber = 0;
    HTMainAnchor = anchor;
    HTMainText = me;
    me->display_on_the_fly = 0;
    me->kcode = NOKANJI;
    me->specified_kcode = NOKANJI;
    me->detected_kcode = DET_NOTYET;
    me->SJIS_status = SJIS_state_neutral;
    me->EUC_status = EUC_state_neutral;
    me->state = S_text;
    me->kanji_buf = 0;
    me->in_sjis = 0;
    me->have_8bit_chars = '\0';
    HText_getChartransInfo(me);
    UCSetTransParams(&me->T,me->UCLYhndl,me->UCI,current_char_set,LYCharSet_UC + current_char_set);
    p_in = HTAnchor_getUCInfoStage(anchor,3);
    HText_setKcode(me,anchor->charset,p_in);
    if (underscore_string[0] != '.') {
      memset(underscore_string,0x2e,0x3ff);
      underscore_string[1023] = '\0';
      underscore_string[1024] = '\0';
      memset(star_string,0x5f,0x3ff);
      star_string[1023] = '\0';
      star_string[1024] = '\0';
    }
    underline_on = '\0';
    bold_on = '\0';
    if (display_partial_flag != '\0') {
      display_partial = '\x01';
      NumOfLines_partial = 0;
    }
    ResetPartialLinenos(me);
    ht_justify_cleanup();
  }
  return me;
}



HText * HText_new2(HTParentAnchor *anchor,HTStream *stream)

{
  HTStreamClass *pHVar1;
  HText *pHVar2;
  HText *result;
  
  pHVar2 = HText_new(anchor);
  if (stream != (HTStream *)0x0) {
    pHVar2->target = stream;
    pHVar1 = stream->isa;
    (pHVar2->targetClass).name = pHVar1->name;
    (pHVar2->targetClass)._free = pHVar1->_free;
    (pHVar2->targetClass)._abort = pHVar1->_abort;
    (pHVar2->targetClass).put_character = pHVar1->put_character;
    (pHVar2->targetClass).put_string = pHVar1->put_string;
    (pHVar2->targetClass).put_block = pHVar1->put_block;
  }
  return pHVar2;
}



void HText_free(HText *self)

{
  TextAnchor *pTVar1;
  BOOLEAN BVar2;
  void **local_18;
  HTList *cur;
  HTTabID *Tab;
  TextAnchor *l;
  
  if (self != (HText *)0x0) {
    while (self->first_anchor != (TextAnchor *)0x0) {
      pTVar1 = self->first_anchor;
      *(_TextAnchor **)&self->first_anchor = pTVar1->next;
      if ((pTVar1->link_type == '\x02') && (pTVar1->input_field != (FormInfo *)0x0)) {
        free_form_fields(pTVar1->input_field);
      }
      if ((pTVar1->lites).hl_info != (HiliteInfo *)0x0) {
        free((pTVar1->lites).hl_info);
        (pTVar1->lites).hl_info = (HiliteInfo *)0x0;
      }
    }
    FormList_delete(self->forms);
    if (self->tabs != (HTList *)0x0) {
      cur = self->tabs;
      while( true ) {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (void **)0x0;
        }
        else {
          local_18 = (void **)cur->object;
        }
        if (local_18 == (void **)0x0) break;
        if (*local_18 != (void *)0x0) {
          free(*local_18);
          *local_18 = (void *)0x0;
        }
        if (local_18 != (void **)0x0) {
          free(local_18);
        }
      }
      HTList_delete(self->tabs);
      self->tabs = (HTList *)0x0;
    }
    if (self->hidden_links != (HTList *)0x0) {
      LYFreeStringList(self->hidden_links);
      self->hidden_links = (HTList *)0x0;
    }
    if (self->node_anchor != (HTParentAnchor *)0x0) {
      HTAnchor_resetUCInfoStage(self->node_anchor,-1,2,0);
      HTAnchor_resetUCInfoStage(self->node_anchor,-1,3,0);
      HTAnchor_clearSourceCache(self->node_anchor);
      HTAnchor_delete_links(self->node_anchor);
      HTAnchor_setDocument(self->node_anchor,(HyperDoc *)0x0);
      BVar2 = HTAnchor_delete((HTParentAnchor0 *)self->node_anchor->parent);
      if (BVar2 != '\0') {
        HTMainAnchor = (HTParentAnchor *)0x0;
      }
    }
    POOL_FREE(self->pool);
    if (self != (HText *)0x0) {
      free(self);
    }
  }
  return;
}



int display_line(HTLine *line,HText *text,int scrline,char *target)

{
  char *__src;
  ushort **ppuVar1;
  size_t len;
  int local_4c;
  uint local_48;
  int local_40;
  int local_38;
  int local_34;
  int local_30;
  uint local_2c;
  uint local_28;
  char buffer [7];
  int x;
  int y;
  int current_style;
  size_t utf_extra;
  char *data;
  char LastDisplayChar;
  
  utf_extra = 0;
  LastDisplayChar = ' ';
  current_style = 0;
  LYmove(scrline,0);
  buffer[2] = '\0';
  buffer[1] = '\0';
  buffer[0] = '\0';
  LYclrtoeol();
  local_28 = (uint)line->offset;
  if (LYwideLines == 0) {
    local_4c = LYcols;
  }
  else {
    local_4c = 0x3f6;
  }
  if (local_4c <= (int)local_28) {
    if (LYwideLines == 0) {
      local_48 = LYcols - 1;
    }
    else {
      local_48 = 0x3f5;
    }
    local_28 = local_48;
  }
  if (line->size == 0) {
    local_2c = local_28;
  }
  else {
    local_2c = 0;
    while ((int)local_2c < (int)local_28) {
      waddch(LYwin,0x20);
      local_2c = local_2c + 1;
    }
  }
  local_2c = local_2c + 1;
  __src = line->data;
LAB_0805e4d5:
  while( true ) {
    data = __src;
    if (LYwideLines == 0) {
      local_30 = LYcols;
    }
    else {
      local_30 = 0x3f6;
    }
    if ((local_30 < (int)local_2c) || (buffer[0] = *data, buffer[0] == '\0')) {
      waddch(LYwin,10);
      while (current_style < (int)(uint)line->numstyles) {
        curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                     (uint)(*(byte *)(line->styles + current_style) & 3));
        current_style = current_style + 1;
      }
      return 0;
    }
    __src = data + 1;
    while ((current_style < (int)(uint)line->numstyles &&
           ((int)((uint)(*(ushort *)(line->styles + current_style) >> 2) + (uint)line->offset + 1)
            <= (int)local_2c))) {
      curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                   (uint)(*(byte *)(line->styles + current_style) & 3));
      current_style = current_style + 1;
    }
    if (buffer[0] == '\a') goto LAB_0805e2c4;
    if (buffer[0] != '\b') break;
    if (dump_output_immediately == '\0') {
      waddch(LYwin,0x2b);
      local_2c = local_2c + 1;
    }
  }
  goto LAB_0805e306;
LAB_0805e2c4:
  if (((*__src == '\0') &&
      (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)LastDisplayChar] & 0x2000) == 0)) &&
     (LastDisplayChar != '-')) {
    buffer[0] = '-';
LAB_0805e306:
    if (((text->T).output_utf8 != '\0') && (buffer[0] < '\0')) {
      text->has_utf8 = '\x01';
      utf_extra = utf8_length((text->T).output_utf8,data);
      LastDisplayChar = 'M';
    }
    if (utf_extra == 0) {
      if ((HTCJK == NOCJK) || (-1 < buffer[0])) {
        len = strlen(buffer);
        LYwaddnstr(LYwin,buffer,len);
        LastDisplayChar = buffer[0];
      }
      else {
        if (LYwideLines == 0) {
          local_40 = LYcols;
        }
        else {
          local_40 = 0x3f6;
        }
        if ((int)local_2c <= local_40) {
          buffer[1] = *__src;
          buffer[2] = '\0';
          __src = data + 2;
          local_2c = local_2c + 1;
          len = strlen(buffer);
          LYwaddnstr(LYwin,buffer,len);
          buffer[1] = '\0';
          LastDisplayChar = 'M';
          if (LYwin == (WINDOW *)0x0) {
            local_38 = -1;
          }
          else {
            local_38 = (int)LYwin->_curx;
          }
          if (LYwideLines == 0) {
            local_34 = LYcols;
          }
          else {
            local_34 = 0x3f6;
          }
          if ((local_34 <= local_38) || (local_38 == 0)) goto LAB_0805e4d5;
        }
      }
    }
    else {
      strncpy(buffer + 1,__src,utf_extra);
      buffer[utf_extra + 1] = '\0';
      len = strlen(buffer);
      LYwaddnstr(LYwin,buffer,len);
      buffer[1] = '\0';
      __src = __src + utf_extra;
      utf_extra = 0;
    }
    data = __src;
    local_2c = local_2c + 1;
    __src = data;
  }
  goto LAB_0805e4d5;
}



void display_title(HText *text)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int len;
  int iVar4;
  size_t len_00;
  uchar *sjis;
  int in_GS_OFFSET;
  bool bVar5;
  char *local_5c;
  int local_58;
  int local_54;
  undefined4 local_50;
  int c;
  int start_of_last_page;
  int total_pages;
  int limit;
  int toolbar;
  int j;
  int i;
  uchar *tmp;
  char *title;
  char percent [20];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  title = (char *)0x0;
  if (text != (HText *)0x0) {
    lynx_start_title_color();
    if (last_colorattr_ptr < 1) {
      curses_style(s_title,2);
    }
    else {
      curses_style(s_title,1);
    }
    pcVar3 = HTAnchor_title(text->node_anchor);
    if (pcVar3 == (char *)0x0) {
      local_5c = " ";
    }
    else {
      local_5c = HTAnchor_title(text->node_anchor);
    }
    HTSACopy(&title,local_5c);
    LYReduceBlanks(title);
    len = LYscreenWidth();
    if (len < 10) {
      percent[0] = '\0';
    }
    else {
      if ((((display_lines < 1) && (0 < LYlines)) && (text->top_of_screen < 100000)) &&
         (text->Lines < 1000000)) {
        sprintf(percent," (l%d of %d)",text->top_of_screen,text->Lines);
      }
      else {
        if ((text->Lines < display_lines) || (display_lines < 1)) {
          percent[0] = '\0';
        }
        else {
          iVar4 = (text->Lines + display_lines) / display_lines;
          if (display_lines < text->Lines) {
            local_58 = text->Lines - display_lines;
          }
          else {
            local_58 = 0;
          }
          local_54 = iVar4;
          if (text->top_of_screen <= local_58) {
            local_54 = (text->top_of_screen + display_lines) / display_lines;
          }
          sprintf(percent," (p%d of %d)",local_54,iVar4);
        }
      }
    }
    if ((HTCJK != NOCJK) && (*title != '\0')) {
      len_00 = strlen(title);
      sjis = (uchar *)calloc((len_00 + 0x80) * 2,1);
      if (sjis != (uchar *)0x0) {
        if (kanji_code == EUC) {
          TO_EUC((uchar *)title,sjis);
        }
        else {
          if (kanji_code == SJIS) {
            TO_SJIS((uchar *)title,sjis);
          }
          else {
            i = 0;
            j = 0;
            while (title[i] != '\0') {
              if (title[i] != '\x1b') {
                sjis[j] = title[i];
                j = j + 1;
              }
              i = i + 1;
            }
            sjis[j] = '\0';
          }
        }
        HTSACopy(&title,(char *)sjis);
        if (sjis != (uchar *)0x0) {
          free(sjis);
        }
      }
    }
    LYmove(0,0);
    LYclrtoeol();
    BVar2 = HText_hasToolbar(text);
    if (BVar2 != '\0') {
      waddch(LYwin,0x23);
    }
    toolbar = ZEXT14(BVar2 != '\0');
    if ((s_forw_backw != -1) && ((nhist != 0 || (1 < nhist_extra)))) {
      if (nhist == 0) {
        local_50 = 0x20;
      }
      else {
        local_50 = acs_map._176_4_;
      }
      curses_style(s_forw_backw,1);
      if (nhist == 0) {
        LYmove(0,toolbar + 3);
      }
      else {
        waddch(LYwin,local_50);
        waddch(LYwin,local_50);
        waddch(LYwin,local_50);
      }
      if (1 < nhist_extra) {
        waddch(LYwin,acs_map._172_4_);
        waddch(LYwin,acs_map._172_4_);
        waddch(LYwin,acs_map._172_4_);
      }
      curses_style(s_forw_backw,0);
    }
    bVar5 = LYShowScrollbar != '\0';
    len_00 = strlen(percent);
    i = LYstrCells(title);
    i = ((len - (uint)bVar5) - len_00) - i;
    if (i < 1) {
      bVar5 = LYShowScrollbar != '\0';
      len_00 = strlen(percent);
      pcVar3 = title;
      len = ((len - (uint)bVar5) - len_00) + -3;
      if (len < 1) {
        *title = '\0';
      }
      else {
        len = LYstrExtent2(title,len);
        memcpy(pcVar3 + len,&DAT_0814cce2,4);
      }
      i = 0;
    }
    LYmove(0,i);
    len_00 = strlen(title);
    LYwaddnstr(LYwin,title,len_00);
    if (percent[0] != '\0') {
      len_00 = strlen(percent);
      LYwaddnstr(LYwin,percent,len_00);
    }
    waddch(LYwin,10);
    if (title != (char *)0x0) {
      free(title);
      title = (char *)0x0;
    }
    if (s_hot_paste != -1) {
      LYmove(0,LYcols - (uint)(LYShowScrollbar != '\0'));
      curses_style(s_hot_paste,1);
      waddch(LYwin,acs_map._172_4_);
      curses_style(s_hot_paste,0);
      LYmove(1,0);
    }
    curses_style(s_title,0);
    lynx_stop_title_color();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void display_scrollbar(HText *text)

{
  int iVar1;
  bool bVar2;
  int local_48;
  int local_44;
  int local_40;
  int s_1;
  int s;
  int shown;
  int sh;
  int bot_skip;
  int top_skip;
  int off;
  int h;
  int i;
  
  if (LYsb_arrow == '\0') {
    local_48 = 0;
  }
  else {
    local_48 = 2;
  }
  local_48 = display_lines - local_48;
  bVar2 = LYsb_arrow != '\0';
  LYsb_end = -1;
  LYsb_begin = -1;
  if ((((LYShowScrollbar != '\0') && (text != (HText *)0x0)) && (2 < local_48)) &&
     (display_lines < text->Lines)) {
    if (text->top_of_screen < text->Lines - display_lines) {
      shown = display_lines;
    }
    else {
      shown = text->Lines - text->top_of_screen;
      if (shown < 1) {
        shown = 1;
      }
    }
    sh = (shown * local_48 + text->Lines / 2) / text->Lines;
    if (sh < 1) {
      sh = 1;
    }
    if (local_48 + -1 <= sh) {
      sh = local_48 + -2;
    }
    if (text->top_of_screen == 0) {
      top_skip = 0;
    }
    else {
      if (text->Lines + (1 - (text->top_of_screen + display_lines)) < 1) {
        top_skip = local_48 - sh;
      }
      else {
        top_skip = (int)ROUND((float10)1 +
                              ((float10)text->top_of_screen * (float10)((local_48 - sh) + -1)) /
                              (float10)((text->Lines - display_lines) + 1));
      }
    }
    iVar1 = (local_48 - sh) - top_skip;
    LYsb_begin = top_skip;
    LYsb_end = local_48 - iVar1;
    if (LYsb_arrow != '\0') {
      if (top_skip == 0) {
        local_44 = s_sb_naa;
      }
      else {
        local_44 = s_sb_aa;
      }
      if (last_colorattr_ptr < 1) {
        curses_style(local_44,2);
      }
      else {
        curses_style(local_44,1);
      }
      LYmove(1,(LYcols - (uint)(LYShowScrollbar != '\0')) + LYshiftWin);
      waddch(LYwin,acs_map._180_4_);
      curses_style(local_44,0);
    }
    if (last_colorattr_ptr < 1) {
      curses_style(s_sb_bg,2);
    }
    else {
      curses_style(s_sb_bg,1);
    }
    i = 1;
    while (i <= local_48) {
      if ((i + -1 <= top_skip) && (top_skip < i)) {
        curses_style(s_sb_bar,1);
      }
      if ((i + -1 <= local_48 - iVar1) && (local_48 - iVar1 < i)) {
        curses_style(s_sb_bar,0);
      }
      LYmove(i + (uint)bVar2,(LYcols - (uint)(LYShowScrollbar != '\0')) + LYshiftWin);
      if ((top_skip < i) && (i <= local_48 - iVar1)) {
        waddch(LYwin,acs_map._192_4_);
      }
      else {
        waddch(LYwin,acs_map._388_4_);
      }
      i = i + 1;
    }
    curses_style(s_sb_bg,0);
    if (LYsb_arrow != '\0') {
      if (iVar1 == 0) {
        local_40 = s_sb_naa;
      }
      else {
        local_40 = s_sb_aa;
      }
      if (last_colorattr_ptr < 1) {
        curses_style(local_40,2);
      }
      else {
        curses_style(local_40,1);
      }
      LYmove(local_48 + 2,(LYcols - (uint)(LYShowScrollbar != '\0')) + LYshiftWin);
      waddch(LYwin,acs_map._184_4_);
      curses_style(local_40,0);
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0805fbff)
// WARNING: Removing unreachable block (ram,0x0805fff6)

void display_page(HText *text,int line_number,char *target)

{
  _FormInfo *p_Var1;
  char "display_page" [13];
  int charset_last_displayed;
  int last_nlinks;
  size_t sVar2;
  size_t __n;
  size_t len_00;
  char *text_00;
  int cur;
  HTAnchor *me;
  FILE *__stream;
  bool bVar3;
  int local_90;
  char *local_8c;
  int local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char tmp [7];
  char *cp_AnchorAddress;
  char *s;
  int count;
  char *hi_string;
  int y;
  size_t utf_extra;
  int len;
  int x_pos;
  int written;
  int itmp;
  int LenNeeded;
  int offset;
  char *data;
  int last_disp_partial;
  HTAnchor *link_dest_intl;
  HTAnchor *link_dest;
  FormInfo *FormInfo_ptr;
  int stop_before_for_anchors;
  TextAnchor *Anchor_ptr;
  char *cp;
  int title_lines;
  int i;
  HTLine *line;
  BOOLEAN display_flag;
  
  last_disp_partial = -1;
  lynx_mode = '\x01';
  if (text == (HText *)0x0) {
    if (enable_scrollback != '\0') {
      waddch(LYwin,0x2a);
      LYrefresh();
      LYclear();
    }
    LYwaddnstr(LYwin,"\n\nError accessing document!\nNo data available!\n",0x2f);
    LYrefresh();
    nlinks = 0;
    return;
  }
  if (((display_partial != '\0') || (recent_sizechange != '\0')) || (text->stale != '\0')) {
    ResetPartialLinenos(text);
  }
  tmp[2] = '\0';
  tmp[1] = '\0';
  tmp[0] = '\0';
  if ((target != (char *)0x0) && (*target == '\0')) {
    target = (char *)0x0;
  }
  text->page_has_target = '\0';
  if (display_lines < 1) {
    return;
  }
  line_number = HText_getPreferredTopLine(text,line_number);
  i = 0;
  line = (HTLine *)text->last_line->next;
  while ((i < line_number && (text->last_line != line))) {
    if (LYNoCore == '\0') {
      if (line->next == (_line *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("line->next != ((void *)0)","./GridText.c",0x7e0,"display_page");
      }
    }
    else {
      if (line->next == (_line *)0x0) {
        if (enable_scrollback != '\0') {
          waddch(LYwin,0x2a);
          LYrefresh();
          LYclear();
        }
        LYwaddnstr(LYwin,"\n\nError drawing page!\nBad HText structure!\n",0x2b);
        LYrefresh();
        nlinks = 0;
        return;
      }
    }
    i = i + 1;
    line = (HTLine *)line->next;
  }
  if (((LYlowest_eightbit[current_char_set] < 0x100) && (current_char_set != charset_last_displayed)
      ) && (LYCursesON != '\0')) {
    charset_last_displayed = current_char_set;
  }
  if (enable_scrollback != '\0') {
    waddch(LYwin,0x2a);
    LYrefresh();
    LYclear();
  }
  if ((text->stale != '\0') || (text->top_of_screen + display_lines != line_number)) {
    last_colorattr_ptr = 0;
  }
  text->top_of_screen = line_number;
  text->top_of_screen_line = line;
  bVar3 = no_title == '\0';
  if (bVar3) {
    display_title(text);
  }
  else {
    LYmove(0,0);
  }
  title_lines = ZEXT14(bVar3);
  if (((display_partial != '\0') || (text->first_lineno_last_disp_partial != line_number)) ||
     (text->last_lineno_last_disp_partial < line_number)) {
    ResetCachedStyles();
  }
  if ((display_partial == '\0') || (text->stbl == (STable_info *)0x0)) {
    stop_before_for_anchors = display_lines + line_number;
  }
  else {
    stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
    if (display_lines + line_number < stop_before_for_anchors) {
      stop_before_for_anchors = display_lines + line_number;
    }
  }
  if (line != (HTLine *)0x0) {
    if ((display_partial != '\0') || (text->first_lineno_last_disp_partial != line_number)) {
      text->has_utf8 = '\0';
    }
    i = 0;
    while (i < display_lines) {
      if (LYNoCore == '\0') {
        if (line == (HTLine *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("line != ((void *)0)","./GridText.c",0x848,"display_page");
        }
      }
      else {
        if (line == (HTLine *)0x0) {
          if (enable_scrollback != '\0') {
            waddch(LYwin,0x2a);
            LYrefresh();
            LYclear();
          }
          LYwaddnstr(LYwin,"\n\nError drawing page!\nBad HText structure!\n",0x2b);
          LYrefresh();
          nlinks = 0;
          return;
        }
      }
      if (((display_partial == '\0') && (text->first_lineno_last_disp_partial == line_number)) &&
         (i + line_number <= text->last_lineno_last_disp_partial)) {
        LYmove(i + title_lines + 1,0);
      }
      else {
        display_line(line,text,i + 1,target);
      }
      data = line->data;
      offset = ZEXT24(line->offset);
      while ((target != (char *)0x0 && (*target != '\0'))) {
        if (case_sensitive == '\0') {
          local_8c = LYno_attr_mbcs_case_strstr
                               (data,target,(text->T).output_utf8,'\x01',(int *)0x0,&LenNeeded);
        }
        else {
          local_8c = LYno_attr_mbcs_strstr
                               (data,target,(text->T).output_utf8,'\x01',(int *)0x0,&LenNeeded);
        }
        if (local_8c == (char *)0x0) break;
        if (LYwideLines == 0) {
          local_84 = LYcols;
        }
        else {
          local_84 = 0x3f6;
        }
        if (local_84 < (int)((uint)line->offset + LenNeeded)) break;
        itmp = 0;
        written = 0;
        x_pos = (int)(local_8c + (offset - (int)data));
        sVar2 = strlen(target);
        text->page_has_target = '\x01';
        LYstartTargetEmphasis();
        while ((written < (int)sVar2 && (tmp[0] = data[itmp], tmp[0] != '\0'))) {
          if ((tmp[0] < '\x03') || (('\b' < tmp[0] || (tmp[0] == '\b')))) {
            if (local_8c <= data + itmp) {
              if (data + itmp == local_8c) {
                LYmove(i + title_lines,x_pos);
              }
              __n = utf8_length((text->T).output_utf8,data + itmp);
              if (__n == 0) {
                if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
                  len_00 = strlen(tmp);
                  LYwaddnstr(LYwin,tmp,len_00);
                  written = written + 1;
                }
                else {
                  itmp = itmp + 1;
                  tmp[1] = data[itmp];
                  len_00 = strlen(tmp);
                  LYwaddnstr(LYwin,tmp,len_00);
                  tmp[1] = '\0';
                  written = written + 2;
                }
              }
              else {
                strncpy(tmp + 1,(char *)(&line->field_0x13 + itmp),__n);
                tmp[__n + 1] = '\0';
                itmp = itmp + __n;
                len_00 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,len_00);
                tmp[1] = '\0';
                written = written + __n + 1;
              }
            }
          }
          else {
            x_pos = x_pos + -1;
          }
          itmp = itmp + 1;
        }
        LYstopTargetEmphasis();
        if (LYwin == (WINDOW *)0x0) {
          local_90 = -1;
        }
        else {
          local_90 = (int)LYwin->_curx;
        }
        offset = local_90;
        data = data + itmp;
        LYmove(i + title_lines + 1,0);
      }
      if (text->last_line == line) goto LAB_0805f90b;
      if (display_partial != '\0') {
        last_disp_partial = i + line_number;
      }
      line = (HTLine *)line->next;
      i = i + 1;
    }
  }
LAB_0805f94c:
  text->next_line = line;
  text->stale = '\0';
  nlinks = 0;
  Anchor_ptr = text->first_anchor;
  while( true ) {
    if ((Anchor_ptr == (TextAnchor *)0x0) || (stop_before_for_anchors < Anchor_ptr->line_num))
    goto LAB_0805ffa7;
    if ((line_number <= Anchor_ptr->line_num) && (Anchor_ptr->line_num < stop_before_for_anchors)) {
      text_00 = LYGetHiTextStr(Anchor_ptr,0);
      if ((((Anchor_ptr->show_anchor == '\0') || (text_00 == (char *)0x0)) || (*text_00 == '\0')) ||
         ((Anchor_ptr->link_type & 1U) != 1)) {
        if ((Anchor_ptr->link_type == '\x02') && (Anchor_ptr->input_field->type != 8)) {
          lynx_mode = '\x02';
          p_Var1 = (_FormInfo *)Anchor_ptr->input_field;
          links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
          links[nlinks].anchor_number = Anchor_ptr->number;
          links[nlinks].anchor_line_num = Anchor_ptr->line_num;
          links[nlinks].l_form = p_Var1;
          links[nlinks].lx = (int)Anchor_ptr->line_pos;
          links[nlinks].ly = (Anchor_ptr->line_num + 1) - line_number;
          links[nlinks].type = 1;
          links[nlinks].inUnderline = Anchor_ptr->inUnderline;
          links[nlinks].target = (char *)0x81ae80d;
          HTSACopy((char **)(links + nlinks),empty_string);
          if (p_Var1->type == 4) {
            if (p_Var1->num_value == 0) {
              local_80 = unchecked_radio;
            }
            else {
              local_80 = checked_radio;
            }
            LYSetHilite(nlinks,local_80);
          }
          else {
            if (p_Var1->type == 3) {
              if (p_Var1->num_value == 0) {
                local_7c = unchecked_box;
              }
              else {
                local_7c = checked_box;
              }
              LYSetHilite(nlinks,local_7c);
            }
            else {
              if (p_Var1->type == 2) {
                cur = LYstrCells(p_Var1->value);
                if (cur < 0x400) {
                  cur = LYstrCells(p_Var1->value);
                  local_78 = star_string + (0x3ff - cur);
                }
                else {
                  local_78 = star_string;
                }
                LYSetHilite(nlinks,local_78);
              }
              else {
                LYSetHilite(nlinks,p_Var1->value);
              }
            }
          }
          cur = nlinks;
          nlinks = nlinks + 1;
          LYhighlight(0,cur,target);
        }
        else {
          if ((text_00 != (char *)0x0) && ((*text_00 != '\0' && (WWW_TraceFlag != '\0')))) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"\nGridText: Not showing link, hightext=%s\n",text_00);
          }
        }
      }
      else {
        count = 0;
        while( true ) {
          text_00 = LYGetHiTextStr(Anchor_ptr,count);
          if (count == 0) {
            LYSetHilite(nlinks,text_00);
          }
          if (text_00 == (char *)0x0) break;
          if (count != 0) {
            cur = LYGetHiTextPos(Anchor_ptr,count);
            LYAddHilite(nlinks,text_00,cur);
          }
          count = count + 1;
        }
        links[nlinks].inUnderline = Anchor_ptr->inUnderline;
        links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
        links[nlinks].anchor_number = Anchor_ptr->number;
        links[nlinks].anchor_line_num = Anchor_ptr->line_num;
        me = HTAnchor_followLink(Anchor_ptr->anchor);
        if (traversal == '\0') {
          cp_AnchorAddress = HTAnchor_address(me);
        }
        else {
          cp_AnchorAddress = stub_HTAnchor_address(me);
        }
        if (links[nlinks].lname != (char *)0x0) {
          free(links[nlinks].lname);
          links[nlinks].lname = (char *)0x0;
        }
        if (cp_AnchorAddress == (char *)0x0) {
          HTSACopy((char **)(links + nlinks),empty_string);
        }
        else {
          links[nlinks].lname = cp_AnchorAddress;
        }
        links[nlinks].lx = (int)Anchor_ptr->line_pos;
        links[nlinks].ly = (Anchor_ptr->line_num + 1) - line_number;
        links[nlinks].type = 2;
        links[nlinks].target = (char *)0x81ae80d;
        links[nlinks].l_form = (_FormInfo *)0x0;
        nlinks = nlinks + 1;
      }
    }
    if (nlinks == 0x400) break;
    Anchor_ptr = (TextAnchor *)Anchor_ptr->next;
  }
  if (LYCursesON != '\0') {
    text_00 = (char *)gettext(
                             "Maximum links per page exceeded!  Use half-page or two-line scrolling."
                             );
    HTAlert(text_00);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\ndisplay_page: MAXLINKS reached.\n");
  }
LAB_0805ffa7:
  LYFreeHilites(nlinks,last_nlinks);
  more_links = '\0';
  if (((traversal != '\0') && (Anchor_ptr != (TextAnchor *)0x0)) &&
     (Anchor_ptr->next != (_TextAnchor *)0x0)) {
    more_links = '\x01';
  }
  last_nlinks = nlinks;
  display_scrollbar(text);
  if (((display_partial == '\0') || (last_disp_partial < text->top_of_screen)) ||
     ((enable_scrollback != '\0' || (recent_sizechange != '\0')))) {
    ResetPartialLinenos(text);
  }
  else {
    text->first_lineno_last_disp_partial = text->top_of_screen;
    text->last_lineno_last_disp_partial = last_disp_partial;
  }
  LYrefresh();
  return;
LAB_0805f90b:
  while (i = i + 1, i < display_lines) {
    LYmove(i + title_lines,0);
    LYclrtoeol();
  }
  goto LAB_0805f94c;
}



void HText_beginAppend(HText *text)

{
  text->permissible_split = 0;
  text->in_line_1 = '\x01';
  return;
}



int set_style_by_embedded_chars(char *s,char *e,uchar start_c,uchar end_c)

{
  int ret;
  
  while( true ) {
    e = e + -1;
    if (e < s) {
      return 0;
    }
    if ((int)*e == (uint)end_c) break;
    if ((int)*e == (uint)start_c) {
      return 1;
    }
  }
  return 0;
}



void move_anchors_in_region
               (HTLine *line,int line_number,TextAnchor **prev_anchor,int *prev_head_processed,
               int sbyte,int ebyte,int shift)

{
  short sVar1;
  int local_18;
  int last;
  int head_processed;
  TextAnchor *a;
  
  head_processed = *prev_head_processed;
  a = *prev_anchor;
  do {
    if ((a == (TextAnchor *)0x0) || (line_number < a->line_num)) goto LAB_0806024b;
    if (a->extent == 0) {
      local_18 = 0;
    }
    else {
      local_18 = (int)a->extent + -1;
    }
    last = a->line_pos + local_18;
    if (line_number + -1 <= a->line_num) {
      if (a->line_num == line_number + -1) {
        last = last + ~(uint)line->prev->size;
      }
      if (sbyte <= last) {
        if (((head_processed == 0) && (a->line_num == line_number)) && (ebyte <= a->line_pos)) {
LAB_0806024b:
          *prev_anchor = a;
          *prev_head_processed = head_processed;
          return;
        }
        sVar1 = (short)shift;
        if (((head_processed == 0) && (a->line_num == line_number)) && (sbyte <= a->line_pos)) {
          a->line_pos = a->line_pos + sVar1;
          a->extent = a->extent - sVar1;
          head_processed = 1;
        }
        if (ebyte <= last) goto LAB_0806024b;
        a->extent = a->extent + sVar1;
      }
    }
    a = (TextAnchor *)a->next;
    head_processed = 0;
  } while( true );
}



HTLine * insert_blanks_in_line
                   (HTLine *line,int line_number,HText *text,TextAnchor **prev_anchor,int ninserts,
                   int *oldpos,int *newpos)

{
  int iVar1;
  char *pcVar2;
  bool bVar3;
  HTLine *local_54;
  int local_50;
  int local_4c;
  int local_48;
  int delta;
  int curlim;
  char *t;
  char *copied;
  char *pre;
  char *s;
  char *newdata;
  HTLine *mod_line;
  int head_processed;
  int shift;
  int added_chars;
  int istyle;
  int ip;
  int ioldc;
  
  ioldc = 0;
  istyle = 0;
  added_chars = 0;
  shift = 0;
  pre = line->data;
  copied = line->data;
  if (((line == (HTLine *)0x0) || (line->size == 0)) || (ninserts == 0)) {
    local_54 = (HTLine *)0x0;
  }
  else {
    ip = 0;
    while (ip < ninserts) {
      if ((oldpos[ip] < newpos[ip]) && (added_chars < newpos[ip] - oldpos[ip])) {
        added_chars = newpos[ip] - oldpos[ip];
      }
      ip = ip + 1;
    }
    if ((int)((uint)line->size + added_chars) < 0x3ff) {
      if (text->last_line == line) {
        if (text->temp_line == (HTLineTemp *)line) {
          mod_line = (HTLine *)(text->temp_line + 1);
        }
        else {
          mod_line = (HTLine *)text->temp_line;
        }
      }
      else {
        mod_line = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,(uint)line->size + added_chars + 0x14);
      }
      if (mod_line == (HTLine *)0x0) {
        local_54 = (HTLine *)0x0;
      }
      else {
        if (*prev_anchor == (TextAnchor *)0x0) {
          *prev_anchor = text->first_anchor;
        }
        if ((*prev_anchor == (TextAnchor *)0x0) || (line_number <= (*prev_anchor)->line_num)) {
          local_50 = 0;
        }
        else {
          local_50 = 1;
        }
        head_processed = local_50;
        memcpy(mod_line,line,0x14);
        pcVar2 = mod_line->data;
        ip = 0;
        t = pcVar2;
        s = pre;
        while (ip <= ninserts) {
          if (ip < ninserts) {
            local_4c = oldpos[ip];
          }
          else {
            if (line->size < 0x401) {
              local_48 = 0x401;
            }
            else {
              local_48 = (uint)line->size + 1;
            }
            local_4c = local_48;
          }
          pre = s;
          while (*s != '\0') {
            if ((((text == (HText *)0x0) || ((text->T).output_utf8 == '\0')) || (-1 < *s)) ||
               (0xbf < (byte)*s)) {
              if ((*s < '\x03') || ('\b' < *s)) {
                if (local_4c <= ioldc) break;
                ioldc = ioldc + 1;
                pre = s + 1;
              }
            }
            else {
              pre = s + 1;
            }
            s = s + 1;
          }
          if (ip != 0) {
            move_anchors_in_region
                      (line,line_number,prev_anchor,&head_processed,(int)(copied + -(int)line->data)
                       ,(int)(pre + -(int)line->data),shift);
          }
          while ((istyle < (int)(uint)line->numstyles &&
                 ((int)(uint)(*(ushort *)(mod_line->styles + istyle) >> 2) < local_4c))) {
            *(ushort *)(mod_line->styles + istyle) =
                 *(ushort *)(mod_line->styles + istyle) & 3 |
                 ((*(ushort *)(mod_line->styles + istyle) >> 2) + (short)shift) * 4;
            istyle = istyle + 1;
          }
          while (copied < pre) {
            *t = *copied;
            t = t + 1;
            copied = copied + 1;
          }
          if (ip < ninserts) {
            delta = (newpos[ip] - oldpos[ip]) - shift;
            if (delta < 0) {
              while (((iVar1 = delta + 1, bVar3 = delta < 0, delta = iVar1, bVar3 && (pcVar2 < t))
                     && (t[-1] == ' '))) {
                t = t + -1;
                shift = shift + -1;
              }
            }
            else {
              shift = newpos[ip] - oldpos[ip];
            }
            while (0 < delta) {
              *t = ' ';
              t = t + 1;
              delta = delta + -1;
            }
          }
          ip = ip + 1;
        }
        while (pre < s) {
          *t = *pre;
          t = t + 1;
          pre = pre + 1;
        }
        if (((head_processed != 0) && (*prev_anchor != (TextAnchor *)0x0)) &&
           ((*prev_anchor)->line_num == line_number)) {
          (*prev_anchor)->extent = (*prev_anchor)->extent + (short)shift;
        }
        *t = '\0';
        mod_line->size = (short)t - (short)pcVar2;
        local_54 = mod_line;
      }
    }
    else {
      local_54 = (HTLine *)0x0;
    }
  }
  return local_54;
}



HTStyleChange *
skip_matched_and_correct_offsets(HTStyleChange *end,HTStyleChange *start,uint split_pos)

{
  HTStyleChange *tmp;
  int level;
  
  level = 0;
  tmp = end;
  do {
    if (tmp < start) {
      return (HTStyleChange *)0x0;
    }
    if (*(short *)&tmp->field_0x2 == *(short *)&end->field_0x2) {
      if ((*(byte *)tmp & 3) == 0) {
        level = level + -1;
      }
      else {
        if ((*(byte *)tmp & 3) != 1) {
          return (HTStyleChange *)0x0;
        }
        level = level + 1;
        if (level == 0) {
          return tmp;
        }
      }
    }
    if (split_pos < *(ushort *)tmp >> 2) {
      *(ushort *)tmp = *(ushort *)tmp & 3 | (short)split_pos * 4;
    }
    tmp = tmp + -1;
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: ram

void split_line(HText *text,uint split)

{
  char cVar1;
  ushort uVar2;
  short sVar3;
  short sVar4;
  HTStyle *pHVar5;
  int line_number;
  HTLineTemp *__src;
  HTStyleChange *pHVar6;
  int iVar7;
  bool bVar8;
  short sVar9;
  short sVar10;
  FILE *__stream;
  char *pcVar11;
  size_t __n;
  uint split_pos;
  HTLine *line_00;
  pool_data *ppVar12;
  int iVar13;
  int iVar14;
  size_t sVar15;
  int *oldpos_00;
  int *newpos_00;
  int iVar16;
  uint local_144;
  size_t sVar17;
  HTCoord local_110;
  short local_106;
  int local_104;
  int local_100;
  int local_fc;
  int local_f0;
  int local_ec;
  int local_e8;
  char local_e1;
  uint i_2;
  char *p2_1;
  char *p2;
  int delta;
  int i_1;
  int *newpos;
  int *oldpos;
  int utf_extra;
  HTLine *jline;
  int r_;
  int d_;
  int total_cell_len;
  int total_byte_len;
  ht_run_info *r;
  char *jp;
  int end;
  int start;
  int n_1;
  int len;
  int moved;
  HTLine *temp;
  int n;
  HTStyleChange *at_end;
  HTStyleChange *scan;
  HTStyleChange *to;
  HTStyleChange *from;
  int i;
  uint plen;
  char *linedata;
  char *prevdata;
  HTLine *line;
  HTLine *previous;
  int ctrl_chars_on_previous_line;
  char *cp;
  char *p;
  int t_bold;
  int t_underline;
  int s_pre;
  int s_post;
  int s;
  int TailTrim;
  int SpecialAttrChars;
  int HeadTrim;
  int CurLine;
  TextAnchor *a;
  int new_offset;
  int indent;
  int spare;
  HTStyle *style;
  short alignment;
  char c;
  
  pHVar5 = text->style;
  if (text->in_line_1 == '\0') {
    local_110 = text->style->leftIndent;
  }
  else {
    local_110 = text->style->indent1st;
  }
  line_number = text->Lines;
  HeadTrim = 0;
  SpecialAttrChars = 0;
  t_underline = (int)underline_on;
  t_bold = (int)bold_on;
  ctrl_chars_on_previous_line = 0;
  __src = (HTLineTemp *)text->last_line;
  if (text->temp_line == __src) {
    line = (HTLine *)(text->temp_line + 1);
  }
  else {
    line = (HTLine *)text->temp_line;
  }
  if (line == (HTLine *)0x0) {
    return;
  }
  local_144 = 0x14;
  memset(line,0,0x14);
  ctrl_chars_on_this_line = 0;
  utfxtra_on_this_line = 0;
  text->LastChar = ' ';
  pcVar11 = (__src->base).data;
  if ((*pcVar11 != '\x05') && (*pcVar11 != '\x03')) goto LAB_0806093a;
  cVar1 = *(char *)&(__src->base).field_0x13;
  if (cVar1 != '\x05') {
    if (cVar1 == '\b') {
      *(char *)&(__src->base).field_0x13 = *pcVar11;
      *pcVar11 = '\b';
      goto LAB_0806093a;
    }
    if (cVar1 != '\x03') goto LAB_0806093a;
  }
  if (__src->data[0] == '\b') {
    __src->data[0] = *(undefined *)&(__src->base).field_0x13;
    *(char *)&(__src->base).field_0x13 = *pcVar11;
    *pcVar11 = '\b';
  }
LAB_0806093a:
  if ((__src->base).size < split) {
    if (WWW_TraceFlag != '\0') {
      uVar2 = (__src->base).size;
      __stream = TraceFP();
      local_144 = split;
      fprintf((FILE *)__stream,"*** split_line: split==%u greater than last_line->size==%d !\n",
              split,(uint)uVar2);
    }
    if (0x400 < split) {
      split = (uint)(__src->base).size;
      pcVar11 = strrchr((__src->base).data,0x20);
      if ((pcVar11 != (char *)0x0) && (1 < (int)(pcVar11 + -(int)(__src->base).data))) {
        split = (uint)(pcVar11 + -(int)(__src->base).data);
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        local_144 = split;
        fprintf((FILE *)__stream,"                split adjusted to %u.\n",split);
      }
    }
  }
  text->Lines = text->Lines + 1;
  *(HTLine **)&((__src->base).next)->prev = line;
  *(HTLineTemp **)&line->prev = __src;
  line->next = (__src->base).next;
  *(HTLine **)&(__src->base).next = line;
  text->last_line = line;
  line->size = 0;
  line->offset = 0;
  text->permissible_split = 0;
  line->data[0] = '\0';
  sVar3 = pHVar5->alignment;
  if (split != 0) {
    if ((dump_output_immediately == '\0') || (use_underscore == '\0')) {
      t_underline = set_style_by_embedded_chars
                              ((__src->base).data,(__src->base).data + split,'\x03','\x04');
    }
    local_144 = 5;
    t_bold = set_style_by_embedded_chars
                       ((__src->base).data,(__src->base).data + split,'\x05','\x06');
  }
  if (((dump_output_immediately == '\0') || (use_underscore == '\0')) && (t_underline != 0)) {
    uVar2 = line->size;
    line->data[uVar2] = '\x03';
    line->size = uVar2 + 1;
    line->data[line->size] = '\0';
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
    SpecialAttrChars = 1;
  }
  if (t_bold != 0) {
    uVar2 = line->size;
    line->data[uVar2] = '\x05';
    line->size = uVar2 + 1;
    line->data[line->size] = '\0';
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
    SpecialAttrChars = SpecialAttrChars + 1;
  }
  if (split != 0) {
    p = (__src->base).data;
    p[(__src->base).size] = '\0';
    (__src->base).size = (ushort)split;
    p = p + split;
    while ((((*p == ' ' || (*p == '\x01')) &&
            ((((HeadTrim != 0 ||
               ((text->first_anchor != (TextAnchor *)0x0 || (underline_on != '\0')))) ||
              (bold_on != '\0')) ||
             ((((sVar3 != 1 || (pHVar5->wordWrap != '\0')) || (pHVar5->freeFormat != '\0')) ||
              ((pHVar5->spaceBefore != 0 || (pHVar5->spaceAfter != 0)))))))) || (*p == '\a'))) {
      p = p + 1;
      HeadTrim = HeadTrim + 1;
    }
    __n = strlen(p);
    i = __n;
    if (__n != 0) {
      while (sVar17 = i, i = sVar17 - 1, -1 < i) {
        if (((p[i] == '\x03') || (p[i] == '\x04')) ||
           ((p[i] == '\x05' || ((p[i] == '\x06' || (p[i] == '\a')))))) {
          ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
        }
        else {
          if (((text->T).output_utf8 != '\0') && ((p[i] & 0xc0U) == 0x80)) {
            utfxtra_on_this_line = utfxtra_on_this_line + 1;
          }
        }
        if ((p[i] == '\a') && ((int)text->permissible_split < i)) {
          text->permissible_split = sVar17;
        }
      }
      ctrl_chars_on_this_line = ctrl_chars_on_this_line + utfxtra_on_this_line;
      strcat(line->data,p);
      line->size = line->size + (short)__n;
    }
  }
  p = (char *)((int)&(__src->base).numstyles + (uint)(__src->base).size + 1);
  while ((((__src->base).data <= p && (((*p == ' ' || (*p == '\x01')) && (psrc_view == '\0')))) &&
         (((((ctrl_chars_on_this_line != 0 || (HeadTrim != 0)) ||
            (text->first_anchor != (TextAnchor *)0x0)) ||
           ((underline_on != '\0' || (bold_on != '\0')))) ||
          (((sVar3 != 1 ||
            (((pHVar5->wordWrap != '\0' || (pHVar5->freeFormat != '\0')) ||
             (pHVar5->spaceBefore != 0)))) || (pHVar5->spaceAfter != 0))))))) {
    p = p + -1;
  }
  iVar16 = (int)__src + (((uint)(__src->base).size + 0x11) - (int)p);
  (__src->base).size = (__src->base).size - (short)iVar16;
  p[1] = '\0';
  if (split == 0) {
    s = (uint)(__src->base).size + iVar16;
  }
  else {
    s = split;
  }
  _sVar9 = s + HeadTrim;
  sVar9 = (short)_sVar9;
  split_pos = s - iVar16;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: split_line(%u [now:%d]) called\n",split,s);
    local_144 = split;
  }
  if ((__src->base).styles == stylechanges_buffers) {
    line->styles = stylechanges_buffers + 0x40;
  }
  else {
    line->styles = stylechanges_buffers;
  }
  line->numstyles = 0;
  from = (__src->base).styles + (1 - (uint)(__src->base).numstyles) * 0x3fffffff;
  to = line->styles + 0x3f;
  do {
    local_106 = (short)SpecialAttrChars;
    if ((from < (__src->base).styles) || (to < line->styles)) break;
    *to = *from;
    if (_sVar9 < (int)(uint)(*(ushort *)to >> 2)) {
      *(ushort *)to = *(ushort *)to & 3 | ((*(ushort *)to >> 2) + (local_106 - sVar9)) * 4;
    }
    else {
      if (((int)(uint)(*(ushort *)to >> 2) <= (int)split_pos) ||
         (((*(byte *)to & 3) != 1 && ((*(byte *)to & 3) != 2)))) break;
      if ((int)(uint)(*(ushort *)to >> 2) < s) {
        local_106 = 0;
      }
      *(ushort *)to = *(ushort *)to & 3 | local_106 << 2;
    }
    to = to + -1;
    from = from + -1;
  } while( true );
  scan = from;
  at_end = from;
LAB_0806123f:
  sVar10 = (short)split_pos;
  if ((scan < (__src->base).styles) || (at_end < (__src->base).styles)) goto LAB_08061259;
  if ((*(byte *)scan & 3) == 0) {
    local_144 = split_pos;
    scan = skip_matched_and_correct_offsets(scan,(__src->base).styles,split_pos);
    if (scan == (HTStyleChange *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"BUG: styles improperly nested.\n");
      }
      goto LAB_08061259;
    }
  }
  else {
    if ((*(byte *)scan & 3) == 1) {
      if ((((*(byte *)at_end & 3) == 1) &&
          (*(short *)&at_end->field_0x2 == *(short *)&scan->field_0x2)) &&
         ((int)split_pos <= (int)(uint)(*(ushort *)at_end >> 2))) {
        at_end = at_end + -1;
      }
      else {
        if ((__src->base).styles + 0x3f <= at_end) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"BUG: style overflow before split_line.\n",local_144);
          }
LAB_08061259:
          line->numstyles = (ushort)((int)line->styles + (0xfc - (int)to) >> 2);
          if ((line->numstyles == 0) || (0x3f < line->numstyles)) {
            if (line->numstyles == 0) {
              *(ushort *)line->styles = *(ushort *)line->styles | 0xfffc;
            }
          }
          else {
            n = 0;
            while (n < (int)(uint)line->numstyles) {
              line->styles[n] = to[n + 1];
              n = n + 1;
            }
          }
          (__src->base).numstyles = (short)((int)((int)at_end - (int)(__src->base).styles) >> 2) + 1
          ;
          if ((__src->base).numstyles == 0) {
            pHVar6 = (__src->base).styles;
            *(ushort *)&pHVar6->field_0x0 = *(ushort *)&pHVar6->field_0x0 | 0xfffc;
          }
          line_00 = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,(uint)(__src->base).size + 0x14);
          if (line_00 == (HTLine *)0x0) {
            outofmem("./GridText.c","split_line_2");
          }
          memcpy(line_00,__src,(uint)(__src->base).size + 0x14);
          ppVar12 = ALLOC_IN_POOL(&HTMainText->pool,(uint)(__src->base).numstyles * 4);
          *(pool_data **)&line_00->styles = ppVar12;
          if (line_00->styles == (HTStyleChange *)0x0) {
            outofmem("./GridText.c","split_line_2");
          }
          __n = (uint)(__src->base).numstyles * 4;
          memcpy(line_00->styles,(__src->base).styles,__n);
          *(HTLine **)&line_00->prev->next = line_00;
          *(HTLine **)&line_00->next->prev = line_00;
          line_00->data[line_00->size] = '\0';
          spare = 0;
          if ((((this_line_was_split != '\0') || (sVar3 == 3)) || (sVar3 == 2)) ||
             (text->stbl != (STable_info *)0x0)) {
            cp = line_00->data;
            while (*cp != '\0') {
              if (((*cp == '\x03') || (*cp == '\x04')) ||
                 ((*cp == '\x05' || ((*cp == '\x06' || (*cp == '\a')))))) {
                ctrl_chars_on_previous_line = ctrl_chars_on_previous_line + 1;
              }
              cp = cp + 1;
            }
            if ((line_00->size != 0) &&
               (*(char *)((int)&line_00->numstyles + (uint)line_00->size + 1) == '\a')) {
              ctrl_chars_on_previous_line = ctrl_chars_on_previous_line + -1;
            }
            if (text->stbl == (STable_info *)0x0) {
              local_104 = LYcols - (uint)(LYShowScrollbar != '\0');
            }
            else {
              if (LYtableCols < 1) {
                if (LYwideLines == 0) {
                  local_fc = LYcols;
                }
                else {
                  local_fc = 0x3f6;
                }
                local_100 = local_fc;
              }
              else {
                local_100 = LYtableCols * LYcols >> 0x1f;
                local_100 = ((LYtableCols * LYcols) / 6 + local_100 >> 1) - local_100;
              }
              local_104 = local_100 - (uint)(LYShowScrollbar != '\0');
            }
            iVar13 = pHVar5->rightIndent;
            spare = LYstrExtent2(line_00->data,(uint)line_00->size);
            spare = ((local_104 - iVar13) - local_110) - spare;
            if ((spare < 0) && (LYwideLines != 0)) {
              spare = 0;
            }
          }
          local_144 = (uint)line_00->offset;
          if (pHVar5->alignment == 2) {
            new_offset = local_144 + local_110 + spare;
          }
          else {
            if (pHVar5->alignment == 3) {
              new_offset = local_144 + spare / 2 + local_110;
            }
            else {
              new_offset = local_144 + local_110;
            }
          }
          line_00->offset = ~(ushort)(new_offset >> 0x1f) & (ushort)new_offset;
          if (text->stbl != (STable_info *)0x0) {
            __n = text->Lines - 1;
            Stbl_finishCellInTable
                      (text->stbl,0,__n,(uint)line_00->offset,
                       (uint)line_00->size - ctrl_chars_on_previous_line);
          }
          text->in_line_1 = '\0';
          if (0 < s) {
            bVar8 = false;
            a = text->last_anchor_before_split;
            if (a == (TextAnchor *)0x0) {
              a = text->first_anchor;
            }
            while (a != (TextAnchor *)0x0) {
              if (a->line_num == line_number) {
                len._0_2_ = a->extent;
                sVar17 = a->number;
                start._0_2_ = a->line_pos;
                iVar13 = (int)(short)start;
                iVar14 = iVar13 + (int)(short)len;
                text->last_anchor_before_split = a;
                if (iVar13 < (int)split_pos) {
                  if ((int)split_pos < iVar14) {
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"anchor %d: no relocation",sVar17);
                      __n = sVar17;
                    }
                    if (_sVar9 < iVar14) {
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream," of the start.\n",__n);
                      }
                      a->extent = a->extent + (local_106 - ((short)iVar16 + (short)HeadTrim));
                    }
                    else {
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,", cut the end.\n",__n);
                      }
                      a->extent = sVar10 - (short)start;
                    }
                  }
                }
                else {
                  if (((s <= iVar13) || ((int)(short)len != 0)) ||
                     ((sVar17 != 0 && ((a->show_anchor == '\0' || (bVar8)))))) {
                    bVar8 = true;
                    a->line_num = a->line_num + 1;
                    if (WWW_TraceFlag != '\0') {
                      sVar3 = a->extent;
                      sVar4 = a->line_pos;
                      iVar7 = a->line_num;
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,
                              "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",sVar17,
                              iVar16,HeadTrim,SpecialAttrChars,iVar7,(int)sVar4,(int)sVar3);
                      __n = sVar17;
                    }
                    if (iVar14 < _sVar9) {
                      if (WWW_TraceFlag != '\0') {
                        __n = _sVar9 - iVar14;
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"Move end +%d, ",__n);
                      }
                      len._0_2_ = (short)len + (sVar9 - (short)iVar14);
                    }
                    if (iVar13 < _sVar9) {
                      if (WWW_TraceFlag != '\0') {
                        __n = _sVar9 - iVar13;
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"Move start +%d, ",__n);
                      }
                      len._0_2_ = (short)len + ((short)start - sVar9);
                      start._0_2_ = sVar9;
                    }
                    a->line_pos = ((short)start - sVar9) + local_106;
                    a->extent = (short)len;
                    if (WWW_TraceFlag != '\0') {
                      sVar3 = a->extent;
                      sVar4 = a->line_pos;
                      __n = a->line_num;
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"->(%d,%d,%d)\n",__n,(int)sVar4,(int)sVar3);
                    }
                  }
                  else {
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"anchor %d: no relocation, empty-finished",sVar17);
                      __n = sVar17;
                    }
                    a->line_pos = sVar10;
                  }
                }
              }
              else {
                if (line_number < a->line_num) break;
              }
              a = (TextAnchor *)a->next;
            }
          }
          if ((((this_line_was_split != '\0') && (0 < spare)) && (text->stbl == (STable_info *)0x0))
             && ((0 < justify_max_void_percent && (justify_max_void_percent < 0x65)))) {
            if (text->stbl == (STable_info *)0x0) {
              local_f0 = LYcols - (uint)(LYShowScrollbar != '\0');
            }
            else {
              if (LYtableCols < 1) {
                if (LYwideLines == 0) {
                  local_e8 = LYcols;
                }
                else {
                  local_e8 = 0x3f6;
                }
                local_ec = local_e8;
              }
              else {
                local_ec = LYtableCols * LYcols >> 0x1f;
                local_ec = ((LYtableCols * LYcols) / 6 + local_ec >> 1) - local_ec;
              }
              local_f0 = local_ec - (uint)(LYShowScrollbar != '\0');
            }
            if ((spare * 100) /
                (((local_f0 - pHVar5->rightIndent) - local_110) + ctrl_chars_on_previous_line) <=
                justify_max_void_percent) {
              jp = line_00->data + justify_start_position;
              r = ht_runs;
              ht_num_runs = 0;
              ht_runs[0].cell_len = 0;
              ht_runs[0].byte_len = 0;
              while (cVar1 = *jp, cVar1 != '\0') {
                if (cVar1 == ' ') {
                  ht_num_runs = ht_num_runs + 1;
                  r[1].cell_len = 0;
                  r[1].byte_len = r[1].cell_len;
                  r = r + 1;
                }
                else {
                  r->byte_len = r->byte_len + 1;
                  if ((cVar1 < '\x03') || ('\b' < cVar1)) {
                    r->cell_len = r->cell_len + 1;
                    if (cVar1 == '\x01') {
                      *jp = ' ';
                    }
                    else {
                      if (((text->T).output_utf8 != '\0') && (cVar1 < '\0')) {
                        sVar15 = utf8_length((text->T).output_utf8,jp);
                        r->byte_len = r->byte_len + sVar15;
                        jp = jp + sVar15;
                      }
                    }
                  }
                }
                jp = jp + 1;
              }
              iVar16 = ht_num_runs + 1;
              previous = line_00;
              if (iVar16 != 1) {
                __n = ht_num_runs * 8;
                ht_num_runs = iVar16;
                oldpos_00 = (int *)malloc(__n);
                newpos_00 = oldpos_00 + (1 - ht_num_runs) * 0x3fffffff;
                i_1 = 1;
                if (oldpos_00 == (int *)0x0) {
                  outofmem("./GridText.c","split_line_3");
                }
                iVar16 = spare / (ht_num_runs + -1);
                r_ = spare % (ht_num_runs + -1);
                *oldpos_00 = ht_runs[0].cell_len + justify_start_position + 1;
                *newpos_00 = *oldpos_00 + (uint)(0 < r_) + iVar16;
                while (r_ = r_ + -1, i_1 < ht_num_runs + -1) {
                  _sVar9 = ht_runs[i_1].cell_len + 1;
                  oldpos_00[i_1] = oldpos_00[(1 - i_1) * 0x3fffffff] + _sVar9;
                  newpos_00[i_1] =
                       newpos_00[(1 - i_1) * 0x3fffffff] + _sVar9 + (uint)(0 < r_) + iVar16;
                  i_1 = i_1 + 1;
                }
                previous = insert_blanks_in_line
                                     (line_00,line_number,text,&last_anchor_of_previous_line,
                                      ht_num_runs + -1,oldpos_00,newpos_00);
                free(oldpos_00);
                if (previous == (HTLine *)0x0) {
                  outofmem("./GridText.c","split_line_4");
                }
                *(HTLine **)&line_00->next->prev = previous;
                *(HTLine **)&line_00->prev->next = previous;
                iVar16 = ht_num_runs;
              }
              ht_num_runs = iVar16;
              if (justify_start_position == 0) {
                have_raw_nbsps = '\0';
                justify_start_position = 0;
                this_line_was_split = '\0';
                can_justify_this_line = '\x01';
                return;
              }
              p2 = previous->data;
              while (p2 < previous->data + justify_start_position) {
                if (*p2 == '\x01') {
                  local_e1 = ' ';
                }
                else {
                  local_e1 = *p2;
                }
                *p2 = local_e1;
                p2 = p2 + 1;
              }
              have_raw_nbsps = '\0';
              justify_start_position = 0;
              this_line_was_split = '\0';
              can_justify_this_line = '\x01';
              return;
            }
          }
          if ((((wait_for_this_stacked_elt < 0) &&
               (((text->style->alignment == 1 || (text->style->alignment == 0)) && (HTCJK == NOCJK))
               )) && (((in_DT == '\0' && (can_justify_here != '\0')) &&
                      (can_justify_this_line != '\0')))) && (form_in_htext == '\0')) {
            if (((line->size != 0) && (text->stbl == (STable_info *)0x0)) && (WWW_TraceFlag != '\0')
               ) {
              uVar2 = line->size;
              __stream = TraceFP();
              fprintf((FILE *)__stream,
                      "BUG: justification: shouldn\'t happen - new line is not empty!\n\t\'%.*s\'\n"
                      ,(uint)uVar2,line->data);
            }
            p2_1 = line_00->data;
            while (*p2_1 != '\0') {
              if (*p2_1 == '\x01') {
                *p2_1 = ' ';
              }
              p2_1 = p2_1 + 1;
            }
          }
          else {
            if (have_raw_nbsps != '\0') {
              i_2 = 0;
              while (i_2 < line_00->size) {
                if (line_00->data[i_2] == '\x01') {
                  line_00->data[i_2] = ' ';
                }
                i_2 = i_2 + 1;
              }
              i_2 = 0;
              while (i_2 < line->size) {
                if (line->data[i_2] == '\x01') {
                  line->data[i_2] = ' ';
                }
                i_2 = i_2 + 1;
              }
            }
          }
          have_raw_nbsps = '\0';
          justify_start_position = 0;
          this_line_was_split = '\0';
          can_justify_this_line = '\x01';
          return;
        }
        pHVar6 = at_end + 1;
        *(byte *)pHVar6 = *(byte *)pHVar6 & 0xfc;
        *(undefined2 *)&at_end[1].field_0x2 = *(undefined2 *)&scan->field_0x2;
        *(ushort *)pHVar6 = *(ushort *)pHVar6 & 3 | sVar10 * 4;
        at_end = pHVar6;
      }
      if (((to < line->styles + 0x3f) && ((*(byte *)(to + 1) & 3) == 0)) &&
         (((uint)(*(ushort *)(to + 1) >> 2) <= (uint)SpecialAttrChars &&
          (*(short *)&to[1].field_0x2 == *(short *)&scan->field_0x2)))) {
        to = to + 1;
      }
      else {
        if (to < line->styles) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"BUG: style overflow after split_line.\n",local_144);
          }
          goto LAB_08061259;
        }
        *to = *scan;
        *(ushort *)to = *(ushort *)to & 3 | local_106 * 4;
        to = to + -1;
      }
    }
  }
  if ((int)split_pos < (int)(uint)(*(ushort *)scan >> 2)) {
    *(ushort *)scan = *(ushort *)scan & 3 | sVar10 * 4;
  }
  scan = scan + -1;
  goto LAB_0806123f;
}



void blank_lines(HText *text,int newlines)

{
  BOOLEAN BVar1;
  bool bVar2;
  HTLine *line;
  BOOLEAN first;
  
  BVar1 = HText_LastLineEmpty(text,'\0');
  if (BVar1 == '\0') {
    newlines = newlines + 1;
  }
  else {
    line = (HTLine *)text->last_line->prev;
    bVar2 = (_line *)text->last_line == (_line *)line;
    if ((no_title != '\0') && (bVar2)) {
      return;
    }
    if ((bVar2) && (newlines == 1)) {
      return;
    }
    while ((((line != (HTLine *)0x0 && (text->last_line != line)) &&
            (BVar1 = HText_TrueEmptyLine(line,text,'\0'), BVar1 != '\0')) && (newlines != 0))) {
      newlines = newlines + -1;
      line = (HTLine *)line->prev;
    }
  }
  while (newlines != 0) {
    split_line(text,0);
    newlines = newlines + -1;
  }
  text->in_line_1 = '\x01';
  return;
}



void HText_appendParagraph(HText *text)

{
  int iVar1;
  int local_18;
  int before;
  int after;
  
  iVar1 = text->style->spaceAfter;
  local_18 = text->style->spaceBefore;
  if (local_18 < iVar1) {
    local_18 = iVar1;
  }
  blank_lines(text,local_18);
  return;
}



void HText_setStyle(HText *text,HTStyle *style)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int local_1c;
  int before;
  int after;
  
  if (style != (HTStyle *)0x0) {
    iVar1 = text->style->spaceAfter;
    local_1c = style->spaceBefore;
    if (WWW_TraceFlag != '\0') {
      pcVar2 = style->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GridText: Change to style %s\n",pcVar2);
    }
    if (local_1c < iVar1) {
      local_1c = iVar1;
    }
    blank_lines(text,local_1c);
    text->style = style;
  }
  return;
}



void HText_appendCharacter(HText *text,int ch)

{
  ushort uVar1;
  eDetectedKCode eVar2;
  eEUC_status eVar3;
  HTStyle *pHVar4;
  eGridState eVar5;
  int iVar6;
  uint uVar7;
  HTLine *pHVar8;
  uint uVar9;
  byte bVar10;
  char *str;
  FILE *__stream;
  ushort **ppuVar11;
  uchar *in_ECX;
  uchar *extraout_ECX;
  uchar *extraout_ECX_00;
  uchar *extraout_ECX_01;
  uchar *extraout_ECX_02;
  int iVar12;
  HTCoord local_180;
  int local_174;
  int local_16c;
  int local_168;
  int local_164;
  int local_160;
  int local_15c;
  int local_158;
  int local_154;
  int local_150;
  int local_14c;
  int local_148;
  int local_144;
  int local_140;
  int local_13c;
  int local_138;
  int local_134;
  int local_12c;
  int local_128;
  int local_124;
  int local_120;
  int local_11c;
  int local_118;
  int local_114;
  int local_10c;
  int local_108;
  int local_104;
  int local_100;
  int local_fc;
  int local_f8;
  int local_f4;
  int local_f0;
  int local_ec;
  int local_e8;
  int local_e4;
  int local_e0;
  int local_dc;
  int local_d8;
  int local_d0;
  int local_c8;
  int local_c0;
  int local_bc;
  int local_b8;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  int local_a0;
  int local_9c;
  int local_94;
  int local_90;
  int local_8c;
  byte local_79;
  byte local_78;
  byte local_77;
  byte local_6e;
  byte local_6d;
  HTFont font;
  int number;
  int nominal;
  eGridState saved_state;
  int saved_kanji_buf;
  int target_cu_1;
  int target_1;
  int here_cu;
  int here;
  int target_cu;
  int target;
  HTTabStop *Tab;
  int i;
  eDetectedKCode save_d_kcode;
  int actual;
  int limit;
  int indent;
  HTStyle *style;
  HTLine *line;
  uchar tmp [2];
  uchar c_1;
  uchar kb;
  uchar c;
  
  if (text == (HText *)0x0) {
    return;
  }
  if (1 < text->halted) {
    if (text->halted == 2) {
      text->halted = 0;
      text->kanji_buf = 0;
      str = (char *)gettext(" *** MEMORY EXHAUSTED ***");
      HText_appendText(text,str);
    }
    text->halted = 3;
    return;
  }
  bVar10 = (byte)ch;
  if ((((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED)) &&
      (text->specified_kcode != SJIS)) && (text->specified_kcode != EUC)) {
    eVar2 = text->detected_kcode;
    if (text->SJIS_status == SJIS_state_in_kanji) {
      if (((bVar10 < 0x40) || (bVar10 == 0x7f)) || (0xfc < bVar10)) {
        text->SJIS_status = SJIS_state_has_bad_code;
        if (text->EUC_status == EUC_state_has_bad_code) {
          text->detected_kcode = DET_MIXED;
        }
        else {
          text->detected_kcode = DET_EUC;
        }
      }
      else {
        text->SJIS_status = SJIS_state_neutral;
      }
    }
    else {
      if (text->SJIS_status == SJIS_state_neutral) {
        if (((bVar10 < 0x81) || (0x9f < bVar10)) && ((bVar10 < 0xe0 || (0xef < bVar10)))) {
          if (((char)bVar10 < '\0') && ((bVar10 < 0xa1 || (0xdf < bVar10)))) {
            text->SJIS_status = SJIS_state_has_bad_code;
            if (text->EUC_status == EUC_state_has_bad_code) {
              text->detected_kcode = DET_MIXED;
            }
            else {
              text->detected_kcode = DET_EUC;
            }
          }
        }
        else {
          text->SJIS_status = SJIS_state_in_kanji;
        }
      }
    }
    eVar3 = text->EUC_status;
    if (eVar3 == EUC_state_in_kanji) {
      if ((bVar10 < 0xa1) || (bVar10 == 0xff)) {
        text->EUC_status = EUC_state_has_bad_code;
        if (text->SJIS_status == SJIS_state_has_bad_code) {
          text->detected_kcode = DET_MIXED;
        }
        else {
          text->detected_kcode = DET_SJIS;
        }
      }
      else {
        text->EUC_status = EUC_state_neutral;
      }
    }
    else {
      if (eVar3 == EUC_state_neutral) {
        if ((bVar10 < 0xa1) || (bVar10 == 0xff)) {
          if (bVar10 == 0x8e) {
            text->EUC_status = EUC_state_in_kana;
          }
          else {
            if ((char)bVar10 < '\0') {
              text->EUC_status = EUC_state_has_bad_code;
              if (text->SJIS_status == SJIS_state_has_bad_code) {
                text->detected_kcode = DET_MIXED;
              }
              else {
                text->detected_kcode = DET_SJIS;
              }
            }
          }
        }
        else {
          text->EUC_status = EUC_state_in_kanji;
        }
      }
      else {
        if (eVar3 == EUC_state_in_kana) {
          if ((bVar10 < 0xa1) || (0xdf < bVar10)) {
            text->EUC_status = EUC_state_has_bad_code;
            if (text->SJIS_status == SJIS_state_has_bad_code) {
              text->detected_kcode = DET_MIXED;
            }
            else {
              text->detected_kcode = DET_SJIS;
            }
          }
          else {
            text->EUC_status = EUC_state_neutral;
          }
        }
      }
    }
    if (text->detected_kcode != eVar2) {
      eVar2 = text->detected_kcode;
      if (eVar2 == DET_EUC) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"TH_JP_AUTO_DETECT: This document\'s kcode seems EUC.\n");
          in_ECX = extraout_ECX_00;
        }
      }
      else {
        if (eVar2 == DET_SJIS) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"TH_JP_AUTO_DETECT: This document\'s kcode seems SJIS.\n");
            in_ECX = extraout_ECX;
          }
        }
        else {
          if (eVar2 == DET_MIXED) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"TH_JP_AUTO_DETECT: This document\'s kcode seems mixed!\n");
              in_ECX = extraout_ECX_01;
            }
          }
          else {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"TH_JP_AUTO_DETECT: This document\'s kcode is unexpected!\n")
              ;
              in_ECX = extraout_ECX_02;
            }
          }
        }
      }
    }
  }
  if ((ch == 0x1b) && (HTCJK == NOCJK)) {
    return;
  }
  if (((((char)bVar10 < '\0') && (HTCJK == NOCJK)) && ((text->T).transp == '\0')) &&
     (((text->T).output_utf8 == '\0' && ((int)(ch & 0xffU) < LYlowest_eightbit[current_char_set]))))
  {
    return;
  }
  if (((bVar10 == 0x9b) && (HTCJK == NOCJK)) &&
     ((HTPassHighCtrlRaw == '\0' &&
      ((((text->T).transp == '\0' && ((text->T).output_utf8 == '\0')) &&
       (0x9b < LYlowest_eightbit[current_char_set])))))) {
    return;
  }
  line = text->last_line;
  pHVar4 = text->style;
  if (text->in_line_1 == '\0') {
    local_180 = pHVar4->leftIndent;
  }
  else {
    local_180 = pHVar4->indent1st;
  }
  if (HTCJK == NOCJK) {
    if (ch == 0x1b) {
      return;
    }
LAB_08062c21:
    if ((HTCJK != NOCJK) &&
       (((ch == 5 || (ch == 6)) && (text->permissible_split = (uint)line->size, HTCJK == JAPANESE)))
       ) {
      text->kcode = NOKANJI;
    }
    if (((ch < 3) || (8 < ch)) || (ch == 8)) {
      if (ch == 8) {
        uVar1 = line->size;
        line->data[uVar1] = '\b';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        return;
      }
    }
    else {
      if (0x3fe < line->size) {
        return;
      }
      if (with_backspaces == '\0') {
        return;
      }
      if (HTCJK != NOCJK) {
        return;
      }
      if ((text->T).output_utf8 != '\0') {
        return;
      }
      if (ch == 3) {
        uVar1 = line->size;
        line->data[uVar1] = '\x03';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        if ((dump_output_immediately != '\0') && (use_underscore != '\0')) {
          underline_on = '\x01';
          return;
        }
        underline_on = '\x01';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
        return;
      }
      if (ch == 4) {
        uVar1 = line->size;
        line->data[uVar1] = '\x04';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        if ((dump_output_immediately != '\0') && (use_underscore != '\0')) {
          underline_on = '\0';
          return;
        }
        underline_on = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
        return;
      }
      if (ch == 5) {
        uVar1 = line->size;
        line->data[uVar1] = '\x05';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        bold_on = '\x01';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
        return;
      }
      if (ch == 6) {
        uVar1 = line->size;
        line->data[uVar1] = '\x06';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        bold_on = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
        return;
      }
      if (ch == 7) {
        if (line->size == 0) {
          return;
        }
        if ((uint)line->size <= text->permissible_split) {
          return;
        }
        i = text->permissible_split;
        do {
          uVar7 = i;
          i = uVar7 + 1;
          if (*(char *)(&line->field_0x13 + uVar7) == '\0') break;
        } while (((((2 < *(byte *)(&line->field_0x13 + uVar7)) &&
                   (*(byte *)(&line->field_0x13 + uVar7) < 9)) ||
                  (ppuVar11 = __ctype_b_loc(),
                  ((*ppuVar11)[*(byte *)(&line->field_0x13 + uVar7)] & 0x2000) != 0)) ||
                 ((*(char *)(&line->field_0x13 + uVar7) == '-' ||
                  (*(char *)(&line->field_0x13 + uVar7) == '\x01')))) ||
                (*(char *)(&line->field_0x13 + uVar7) == '\x02'));
        if (*(char *)(&line->field_0x13 + uVar7) == '\0') {
          return;
        }
      }
    }
    if ((text->T).output_utf8 != '\0') {
      if (((text->T).output_utf8 != '\0') && ((ch & 0xc0U) == 0x80)) {
        if (line->size < 0x400) {
          if ((line->size == 0) || (*(char *)((int)&line->numstyles + (uint)line->size + 1) != '\a')
             ) {
            local_174 = 0;
          }
          else {
            local_174 = 1;
          }
          if (text->stbl == (STable_info *)0x0) {
            local_16c = LYcols - (uint)(LYShowScrollbar != '\0');
          }
          else {
            if (LYtableCols < 1) {
              if (LYwideLines == 0) {
                local_164 = LYcols;
              }
              else {
                local_164 = 0x3f6;
              }
              local_168 = local_164;
            }
            else {
              local_168 = LYtableCols * LYcols >> 0x1f;
              local_168 = ((LYtableCols * LYcols) / 6 + local_168 >> 1) - local_168;
            }
            local_16c = local_168 - (uint)(LYShowScrollbar != '\0');
          }
          if ((int)((((uint)line->offset + (uint)line->size + local_180) - ctrl_chars_on_this_line)
                   + local_174) < local_16c) goto LAB_0806320c;
        }
        if ((text->permissible_split == 0) || (text->source != '\0')) {
          text->permissible_split = (uint)line->size;
          while (((text->permissible_split != 0 && ((text->T).output_utf8 != '\0')) &&
                 ((*(byte *)((int)&line->numstyles + text->permissible_split + 1) & 0xc0) == 0x80)))
          {
            text->permissible_split = text->permissible_split - 1;
          }
          if ((text->permissible_split != 0) &&
             (*(char *)((int)&line->numstyles + text->permissible_split + 1) < '\0')) {
            text->permissible_split = text->permissible_split - 1;
          }
          if (text->permissible_split == (uint)line->size) {
            text->permissible_split = 0;
          }
        }
        split_line(text,text->permissible_split);
        line = text->last_line;
        if ((text->source != '\0') && ((uint)line->size == ctrl_chars_on_this_line)) {
          HText_appendCharacter(text,8);
        }
LAB_0806320c:
        uVar1 = line->size;
        line->data[uVar1] = (char)ch;
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
        utfxtra_on_this_line = utfxtra_on_this_line + 1;
        return;
      }
      if (((ch & 0x80U) != 0) && (0x3f9 < line->size)) {
        if (((text->permissible_split == 0) || (text->source != '\0')) &&
           (text->permissible_split = (uint)line->size, text->permissible_split == (uint)line->size)
           ) {
          text->permissible_split = 0;
        }
        split_line(text,text->permissible_split);
        line = text->last_line;
        if ((text->source != '\0') && ((uint)line->size == ctrl_chars_on_this_line)) {
          HText_appendCharacter(text,8);
        }
      }
    }
    if (ch == 10) {
      split_line(text,0);
      text->in_line_1 = '\x01';
      if (HTCJK != JAPANESE) {
        return;
      }
      text->kcode = NOKANJI;
      return;
    }
    if (ch == 2) {
      ch = 0x20;
    }
    if (ch == 0xd) {
      split_line(text,0);
      text->in_line_1 = '\0';
      if (HTCJK != JAPANESE) {
        return;
      }
      text->kcode = NOKANJI;
      return;
    }
    if (ch == 9) {
      if ((line->size != 0) && (*(char *)((int)&line->numstyles + (uint)line->size + 1) == '\a')) {
        line->size = line->size - 1;
        line->data[line->size] = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + -1;
      }
      here = ((uint)line->size + (uint)line->offset + local_180) - ctrl_chars_on_this_line;
      if (pHVar4->tabs == (HTTabStop *)0x0) {
        if (text->in_line_1 == '\0') {
          split_line(text,0);
          return;
        }
        if (pHVar4->leftIndent <= here) {
          split_line(text,0);
          return;
        }
        target = pHVar4->leftIndent;
      }
      else {
        Tab = pHVar4->tabs;
        while (Tab->position <= here) {
          if (Tab->position == 0) {
            split_line(text,0);
            return;
          }
          Tab = Tab + 1;
        }
        target = Tab->position;
      }
      if (text->stbl == (STable_info *)0x0) {
        local_160 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < 1) {
          if (LYwideLines == 0) {
            local_158 = LYcols;
          }
          else {
            local_158 = 0x3f6;
          }
          local_15c = local_158;
        }
        else {
          local_15c = LYtableCols * LYcols >> 0x1f;
          local_15c = ((LYtableCols * LYcols) / 6 + local_15c >> 1) - local_15c;
        }
        local_160 = local_15c - (uint)(LYShowScrollbar != '\0');
      }
      if ((local_160 - pHVar4->rightIndent < target) && (HTOutputFormat != (HTFormat)WWW_SOURCE)) {
        split_line(text,0);
        return;
      }
      text->permissible_split = (uint)line->size;
      if (text->stbl == (STable_info *)0x0) {
        local_154 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < 1) {
          if (LYwideLines == 0) {
            local_14c = LYcols;
          }
          else {
            local_14c = 0x3f6;
          }
          local_150 = local_14c;
        }
        else {
          local_150 = LYtableCols * LYcols >> 0x1f;
          local_150 = ((LYtableCols * LYcols) / 6 + local_150 >> 1) - local_150;
        }
        local_154 = local_150 - (uint)(LYShowScrollbar != '\0');
      }
      if (local_154 < target) {
        if (text->stbl == (STable_info *)0x0) {
          local_148 = LYcols - (uint)(LYShowScrollbar != '\0');
        }
        else {
          if (LYtableCols < 1) {
            if (LYwideLines == 0) {
              local_140 = LYcols;
            }
            else {
              local_140 = 0x3f6;
            }
            local_144 = local_140;
          }
          else {
            local_144 = LYtableCols * LYcols >> 0x1f;
            local_144 = ((LYtableCols * LYcols) / 6 + local_144 >> 1) - local_144;
          }
          local_148 = local_144 - (uint)(LYShowScrollbar != '\0');
        }
        target = local_148;
      }
      if (line->size == 0) {
        line->offset = line->offset + ((short)target - (short)here);
        return;
      }
      while (here < target) {
        uVar1 = line->size;
        line->data[uVar1] = ' ';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        here = here + 1;
      }
      return;
    }
  }
  else {
    switch(text->state) {
    case S_text:
      if (ch == 0x1b) {
        text->state = S_esc;
        text->kanji_buf = 0;
        return;
      }
      break;
    case S_esc:
      if (ch == 0x24) {
        text->state = S_dollar;
        return;
      }
      if (ch == 0x28) {
        text->state = S_paren;
        return;
      }
      text->state = S_text;
    case S_dollar:
      if (((ch == 0x40) || (ch == 0x42)) || (ch == 0x41)) {
        text->state = S_nonascii_text;
        if ((ch != 0x40) && (ch != 0x42)) {
          return;
        }
        text->kcode = JIS;
        return;
      }
      if (ch == 0x28) {
        text->state = S_dollar_paren;
        return;
      }
      text->state = S_text;
      break;
    case S_paren:
      if (((ch == 0x42) || (ch == 0x4a)) || (ch == 0x54)) {
        text->permissible_split = (uint)text->last_line->size;
        text->state = S_text;
        return;
      }
      if (ch == 0x49) {
        text->state = S_jisx0201_text;
        text->permissible_split = (uint)text->last_line->size;
        text->kcode = JIS;
        return;
      }
      text->state = S_text;
      break;
    case S_nonascii_text:
      if (ch == 0x1b) {
        text->state = S_esc;
        text->kanji_buf = 0;
        if (HTCJK != JAPANESE) {
          return;
        }
        text->kcode = NOKANJI;
        return;
      }
      if (bVar10 < 0x20) {
        text->state = S_text;
        text->kanji_buf = 0;
        if (HTCJK == JAPANESE) {
          text->kcode = NOKANJI;
        }
      }
      else {
        ch = ch | 0x80;
      }
      break;
    case S_dollar_paren:
      if (ch == 0x43) {
        text->state = S_nonascii_text;
        return;
      }
      text->state = S_text;
      break;
    case S_jisx0201_text:
      if (ch == 0x1b) {
        text->state = S_esc;
        text->kanji_buf = 0;
        text->kcode = NOKANJI;
        return;
      }
      text->kanji_buf = -0x72;
      ch = ch | 0x80;
    }
    if (text->kanji_buf == 0) {
      if ((ch & 0x80U) != 0) {
        if ((text->kcode == JIS) ||
           ((((text->kcode != SJIS &&
              ((text->detected_kcode != DET_SJIS || (text->specified_kcode != NOKANJI)))) &&
             ((text->kcode != NOKANJI || (text->specified_kcode != SJIS)))) ||
            ((c_1 = (uchar)ch, c_1 < 0xa1 || (0xdf < c_1)))))) {
          text->kanji_buf = ch;
          text->permissible_split = (uint)text->last_line->size;
          return;
        }
        kb = (uchar)text->kanji_buf;
        JISx0201TO0208_SJIS(-0xe,(uchar *)(ch & 0xff),in_ECX);
        ch = (int)(char)c_1;
        text->kanji_buf = (uint)kb;
        text->permissible_split = (uint)text->last_line->size;
      }
      goto LAB_08062c21;
    }
  }
  bVar10 = (byte)ch;
  if (((text->source != '\0') || (dont_wrap_pre != '\0')) && (text == HTMainText)) {
    iVar12 = ((uint)line->offset + (uint)line->size) - ctrl_chars_on_this_line;
    if (text->stbl == (STable_info *)0x0) {
      local_13c = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      if (LYtableCols < 1) {
        if (LYwideLines == 0) {
          local_134 = LYcols;
        }
        else {
          local_134 = 0x3f6;
        }
        local_138 = local_134;
      }
      else {
        local_138 = LYtableCols * LYcols >> 0x1f;
        local_138 = ((LYtableCols * LYcols) / 6 + local_138 >> 1) - local_138;
      }
      local_13c = local_138 - (uint)(LYShowScrollbar != '\0');
    }
    if ((HTCJK == NOCJK) || (text->kanji_buf == 0)) {
      local_12c = 0;
    }
    else {
      local_12c = 1;
    }
    if (iVar12 < (local_13c - pHVar4->rightIndent) - local_12c) {
      if ((text->T).output_utf8 != '\0') {
        if (((int)(char)~bVar10 & 0xc0U) == 0) {
          if ((~bVar10 & 0x20) == 0) {
            if ((~bVar10 & 0x10) == 0) {
              if ((~bVar10 & 8) == 0) {
                if ((~bVar10 & 4) == 0) {
                  if ((~bVar10 & 2) == 0) {
                    local_114 = 0;
                  }
                  else {
                    local_114 = 5;
                  }
                  local_118 = local_114;
                }
                else {
                  local_118 = 4;
                }
                local_11c = local_118;
              }
              else {
                local_11c = 3;
              }
              local_120 = local_11c;
            }
            else {
              local_120 = 2;
            }
            local_124 = local_120;
          }
          else {
            local_124 = 1;
          }
          local_128 = local_124;
        }
        else {
          local_128 = 0;
        }
        if (text->stbl == (STable_info *)0x0) {
          local_10c = LYcols - (uint)(LYShowScrollbar != '\0');
        }
        else {
          if (LYtableCols < 1) {
            if (LYwideLines == 0) {
              local_104 = LYcols;
            }
            else {
              local_104 = 0x3f6;
            }
            local_108 = local_104;
          }
          else {
            local_108 = LYtableCols * LYcols >> 0x1f;
            local_108 = ((LYtableCols * LYcols) / 6 + local_108 >> 1) - local_108;
          }
          local_10c = local_108 - (uint)(LYShowScrollbar != '\0');
        }
        if (local_10c <= local_128 + iVar12) goto LAB_08063b53;
      }
    }
    else {
LAB_08063b53:
      split_line(text,0);
      line = text->last_line;
      iVar12 = text->kanji_buf;
      eVar5 = text->state;
      text->kanji_buf = 0;
      text->state = S_text;
      HText_appendCharacter(text,8);
      text->kanji_buf = iVar12;
      text->state = eVar5;
    }
  }
  if ((ch == 0x20) && (text->permissible_split = (uint)text->last_line->size, HTCJK == JAPANESE)) {
    text->kcode = NOKANJI;
  }
  if (text->IgnoreExcess != '\0') {
    iVar12 = ((uint)line->offset + (uint)line->size + local_180) - ctrl_chars_on_this_line;
    if (text->stbl == (STable_info *)0x0) {
      local_100 = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      if (LYtableCols < 1) {
        if (LYwideLines == 0) {
          local_f8 = LYcols;
        }
        else {
          local_f8 = 0x3f6;
        }
        local_fc = local_f8;
      }
      else {
        local_fc = LYtableCols * LYcols >> 0x1f;
        local_fc = ((LYtableCols * LYcols) / 6 + local_fc >> 1) - local_fc;
      }
      local_100 = local_fc - (uint)(LYShowScrollbar != '\0');
    }
    limit = local_100;
    if ((((keypad_mode == 3) || (keypad_mode == 2)) && (number_fields_on_left == '\0')) &&
       ((text->last_anchor != (TextAnchor *)0x0 && (iVar6 = text->last_anchor->number, 0 < iVar6))))
    {
      if (iVar6 < 100000) {
        if (iVar6 < 10000) {
          if (iVar6 < 1000) {
            if (iVar6 < 100) {
              if (iVar6 < 10) {
                local_e4 = 3;
              }
              else {
                local_e4 = 4;
              }
              local_e8 = local_e4;
            }
            else {
              local_e8 = 5;
            }
            local_ec = local_e8;
          }
          else {
            local_ec = 6;
          }
          local_f0 = local_ec;
        }
        else {
          local_f0 = 7;
        }
        local_f4 = local_f0;
      }
      else {
        local_f4 = 8;
      }
      limit = local_100 - local_f4;
    }
    if (limit <= pHVar4->rightIndent + iVar12) {
      return;
    }
    if (text->stbl == (STable_info *)0x0) {
      local_e0 = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      if (LYtableCols < 1) {
        if (LYwideLines == 0) {
          local_d8 = LYcols;
        }
        else {
          local_d8 = 0x3f6;
        }
        local_dc = local_d8;
      }
      else {
        local_dc = LYtableCols * LYcols >> 0x1f;
        local_dc = ((LYtableCols * LYcols) / 6 + local_dc >> 1) - local_dc;
      }
      local_e0 = local_dc - (uint)(LYShowScrollbar != '\0');
    }
    if (local_e0 <= iVar12) {
      return;
    }
  }
  if ((line->size == 0) || (*(char *)((int)&line->numstyles + (uint)line->size + 1) != '\a')) {
    local_d0 = 0;
  }
  else {
    local_d0 = 1;
  }
  local_d0 = (uint)line->offset + local_180 + (uint)line->size + local_d0;
  if ((HTCJK == NOCJK) || (text->kanji_buf == 0)) {
    local_c8 = 0;
  }
  else {
    local_c8 = 1;
  }
  if (text->stbl == (STable_info *)0x0) {
    local_c0 = LYcols - (uint)(LYShowScrollbar != '\0');
  }
  else {
    if (LYtableCols < 1) {
      if (LYwideLines == 0) {
        local_b8 = LYcols;
      }
      else {
        local_b8 = 0x3f6;
      }
      local_bc = local_b8;
    }
    else {
      local_bc = LYtableCols * LYcols >> 0x1f;
      local_bc = ((LYtableCols * LYcols) / 6 + local_bc >> 1) - local_bc;
    }
    local_c0 = local_bc - (uint)(LYShowScrollbar != '\0');
  }
  if (((pHVar4->rightIndent + local_d0) - ctrl_chars_on_this_line) + local_c8 < local_c0) {
    if ((text->T).output_utf8 != '\0') {
      if (((int)(char)~bVar10 & 0xc0U) == 0) {
        if ((~bVar10 & 0x20) == 0) {
          if ((~bVar10 & 0x10) == 0) {
            if ((~bVar10 & 8) == 0) {
              if ((~bVar10 & 4) == 0) {
                if ((~bVar10 & 2) == 0) {
                  local_9c = 0;
                }
                else {
                  local_9c = 5;
                }
                local_a0 = local_9c;
              }
              else {
                local_a0 = 4;
              }
              local_a4 = local_a0;
            }
            else {
              local_a4 = 3;
            }
            local_a8 = local_a4;
          }
          else {
            local_a8 = 2;
          }
          local_ac = local_a8;
        }
        else {
          local_ac = 1;
        }
        local_b0 = local_ac;
      }
      else {
        local_b0 = 0;
      }
      if (text->stbl == (STable_info *)0x0) {
        local_90 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < 1) {
          if (LYwideLines == 0) {
            local_8c = LYcols;
          }
          else {
            local_8c = 0x3f6;
          }
          local_90 = local_8c;
        }
        else {
          local_90 = LYtableCols * LYcols >> 0x1f;
          local_90 = ((LYtableCols * LYcols) / 6 + local_90 >> 1) - local_90;
        }
        local_90 = local_90 - (uint)(LYShowScrollbar != '\0');
      }
      local_94 = local_90 + -1;
      if (local_94 <= (local_d0 - ctrl_chars_on_this_line) + local_b0) goto LAB_08064265;
    }
    if (0x3fe < line->size) {
      split_line(text,0);
    }
  }
  else {
LAB_08064265:
    if ((pHVar4->wordWrap == '\0') || (HTOutputFormat == (HTFormat)WWW_SOURCE)) {
      if (HTOutputFormat == (HTFormat)WWW_SOURCE) {
        if (0x3fe < line->size) {
          split_line(text,0);
        }
      }
      else {
        if (((dump_output_immediately == '\0') && ((crawl == '\0' || (traversal == '\0')))) ||
           (dont_wrap_pre == '\0')) {
          split_line(text,0);
        }
        else {
          if (0x3fe < line->size) {
            split_line(text,0);
          }
        }
      }
    }
    else {
      if (((wait_for_this_stacked_elt < 0) &&
          (((text->style->alignment == 1 || (text->style->alignment == 0)) && (HTCJK == NOCJK)))) &&
         ((((in_DT == '\0' && (can_justify_here != '\0')) && (can_justify_this_line != '\0')) &&
          (form_in_htext == '\0')))) {
        this_line_was_split = '\x01';
      }
      split_line(text,text->permissible_split);
      if (ch == 0x20) {
        return;
      }
    }
  }
  if ((ch == 1) &&
     ((((-1 < wait_for_this_stacked_elt ||
        ((text->style->alignment != 1 && (text->style->alignment != 0)))) || (HTCJK != NOCJK)) ||
      ((((in_DT != '\0' || (can_justify_here == '\0')) || (can_justify_this_line == '\0')) ||
       (form_in_htext != '\0')))))) {
    ch = 0x20;
  }
  else {
    have_raw_nbsps = '\x01';
  }
  if ((ch & 0x80U) != 0) {
    text->have_8bit_chars = '\x01';
  }
  uVar7 = pHVar4->font;
  pHVar8 = text->last_line;
  local_79 = (byte)ch;
  if ((HTCJK == NOCJK) || (text->kanji_buf == 0)) {
    if (HTCJK == NOCJK) {
      uVar1 = pHVar8->size;
      local_6e = local_79;
      if ((uVar7 & 1) != 0) {
        ppuVar11 = __ctype_b_loc();
        local_6d = local_79;
        if (((*ppuVar11)[ch & 0xff] & 0x200) != 0) {
          iVar12 = toupper(ch & 0xff);
          local_6d = (byte)iVar12;
        }
        local_6e = local_6d;
      }
      pHVar8->data[uVar1] = local_6e;
      pHVar8->size = uVar1 + 1;
    }
    else {
      uVar1 = pHVar8->size;
      if (kanji_code == NOKANJI) {
        local_78 = local_79;
        if ((uVar7 & 1) != 0) {
          ppuVar11 = __ctype_b_loc();
          local_77 = local_79;
          if (((*ppuVar11)[ch & 0xff] & 0x200) != 0) {
            iVar12 = toupper(ch & 0xff);
            local_77 = (byte)iVar12;
          }
          local_78 = local_77;
        }
        local_79 = local_78;
      }
      pHVar8->data[uVar1] = local_79;
      pHVar8->size = uVar1 + 1;
    }
  }
  else {
    uVar9 = text->kanji_buf;
    kb = (uchar)uVar9;
    c_1 = local_79;
    if (HTCJK == JAPANESE) {
      if (text->kcode != JIS) {
        if (((local_79 < 0x40) || (local_79 == 0x7f)) ||
           ((0xfc < local_79 || (((kb < 0x81 || (0x9f < kb)) && ((kb < 0xe0 || (0xef < kb)))))))) {
          if (((((kb < 0xa1) || (kb == 0xff)) || (local_79 < 0xa1)) || (local_79 == 0xff)) &&
             (((kb != 0x8e || (local_79 < 0xa1)) || (0xdf < local_79)))) {
            text->kcode = NOKANJI;
          }
          else {
            text->kcode = EUC;
          }
        }
        else {
          if ((((kb < 0xa1) || (kb == 0xff)) || ((local_79 < 0xa1 || (local_79 == 0xff)))) &&
             (((kb != 0x8e || (local_79 < 0xa1)) || (0xdf < local_79)))) {
            text->kcode = SJIS;
          }
          else {
            if (text->specified_kcode == NOKANJI) {
              if (text->detected_kcode == DET_EUC) {
                text->kcode = EUC;
              }
              else {
                if (text->detected_kcode == DET_SJIS) {
                  text->kcode = SJIS;
                }
                else {
                  if (((kb == 0x8e) && (0xa0 < local_79)) &&
                     ((local_79 < 0xe0 && (text->kcode != EUC)))) {
                    text->kcode = SJIS;
                  }
                }
              }
            }
            else {
              text->kcode = text->specified_kcode;
            }
          }
        }
      }
      if (kanji_code == EUC) {
        if (text->kcode == SJIS) {
          SJIS_TO_EUC1(kb,local_79,tmp);
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = tmp[0];
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = tmp[1];
          pHVar8->size = uVar1 + 1;
        }
        else {
          if ((((kb < 0xa1) || (kb == 0xff)) || ((local_79 < 0xa1 || (local_79 == 0xff)))) &&
             (((kb != 0x8e || (local_79 < 0xa1)) || (0xdf < local_79)))) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"This character (%X:%X) doesn\'t seem Japanese\n",
                      uVar9 & 0xff,ch & 0xff);
            }
            uVar1 = pHVar8->size;
            pHVar8->data[uVar1] = '=';
            pHVar8->size = uVar1 + 1;
            uVar1 = pHVar8->size;
            pHVar8->data[uVar1] = '=';
            pHVar8->size = uVar1 + 1;
          }
          else {
            JISx0201TO0208_EUC(kb,local_79,&kb,&c_1);
            uVar1 = pHVar8->size;
            pHVar8->data[uVar1] = kb;
            pHVar8->size = uVar1 + 1;
            uVar1 = pHVar8->size;
            pHVar8->data[uVar1] = c_1;
            pHVar8->size = uVar1 + 1;
          }
        }
      }
      else {
        if (kanji_code == SJIS) {
          if ((text->kcode == EUC) || (text->kcode == JIS)) {
            EUC_TO_SJIS1(kb,local_79);
            uVar1 = pHVar8->size;
            pHVar8->data[uVar1] = tmp[0];
            pHVar8->size = uVar1 + 1;
            uVar1 = pHVar8->size;
            pHVar8->data[uVar1] = tmp[1];
            pHVar8->size = uVar1 + 1;
          }
          else {
            if ((((local_79 < 0x40) || (local_79 == 0x7f)) || (0xfc < local_79)) ||
               (((kb < 0x81 || (0x9f < kb)) && ((kb < 0xe0 || (0xef < kb)))))) {
              uVar1 = pHVar8->size;
              pHVar8->data[uVar1] = '=';
              pHVar8->size = uVar1 + 1;
              uVar1 = pHVar8->size;
              pHVar8->data[uVar1] = '=';
              pHVar8->size = uVar1 + 1;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"This character (%X:%X) doesn\'t seem Japanese\n",
                        uVar9 & 0xff,ch & 0xff);
              }
            }
            else {
              uVar1 = pHVar8->size;
              pHVar8->data[uVar1] = kb;
              pHVar8->size = uVar1 + 1;
              uVar1 = pHVar8->size;
              pHVar8->data[uVar1] = local_79;
              pHVar8->size = uVar1 + 1;
            }
          }
        }
      }
    }
    else {
      uVar1 = pHVar8->size;
      pHVar8->data[uVar1] = kb;
      pHVar8->size = uVar1 + 1;
      uVar1 = pHVar8->size;
      pHVar8->data[uVar1] = local_79;
      pHVar8->size = uVar1 + 1;
    }
    text->kanji_buf = 0;
  }
  pHVar8->data[pHVar8->size] = '\0';
  if ((uVar7 & 0x10) != 0) {
    HText_appendCharacter(text,1);
  }
  if (ch == 7) {
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
    text->permissible_split = (uint)text->last_line->size;
  }
  if (ch == 8) {
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + 1;
  }
  return;
}



void _internal_HTC(HText *text,int style,int dir)

{
  HTLine *pHVar1;
  HTLine *line;
  
  if (text != (HText *)0x0) {
    pHVar1 = text->last_line;
    if ((((pHVar1->numstyles == 0) || (dir != 0)) ||
        ((*(byte *)(pHVar1->styles + (1 - (uint)pHVar1->numstyles) * 0x3fffffff) & 3) == 0)) ||
       (((uint)*(ushort *)&pHVar1->styles[(1 - (uint)pHVar1->numstyles) * 0x3fffffff].field_0x2 !=
         style || ((uint)(*(ushort *)(pHVar1->styles + (1 - (uint)pHVar1->numstyles) * 0x3fffffff)
                         >> 2) != (uint)pHVar1->size - ctrl_chars_on_this_line)))) {
      if (pHVar1->numstyles < 0x40) {
        *(ushort *)(pHVar1->styles + pHVar1->numstyles) =
             *(ushort *)(pHVar1->styles + pHVar1->numstyles) & 3 | pHVar1->size * 4;
        if (ctrl_chars_on_this_line <=
            (int)(uint)(*(ushort *)(pHVar1->styles + pHVar1->numstyles) >> 2)) {
          *(ushort *)(pHVar1->styles + pHVar1->numstyles) =
               *(ushort *)(pHVar1->styles + pHVar1->numstyles) & 3 |
               ((*(ushort *)(pHVar1->styles + pHVar1->numstyles) >> 2) -
               (short)ctrl_chars_on_this_line) * 4;
        }
        *(undefined2 *)&pHVar1->styles[pHVar1->numstyles].field_0x2 = (short)style;
        *(byte *)(pHVar1->styles + pHVar1->numstyles) =
             *(byte *)(pHVar1->styles + pHVar1->numstyles) & 0xfc | (byte)dir & 3;
        pHVar1->numstyles = pHVar1->numstyles + 1;
      }
    }
    else {
      pHVar1->numstyles = pHVar1->numstyles - 1;
    }
  }
  return;
}



void HText_setLastChar(HText *text,char ch)

{
  if (text != (HText *)0x0) {
    text->LastChar = ch;
  }
  return;
}



char HText_getLastChar(HText *text)

{
  char local_5;
  
  if (text == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = text->LastChar;
  }
  return local_5;
}



void HText_setIgnoreExcess(HText *text,BOOLEAN ignore)

{
  if (text != (HText *)0x0) {
    text->IgnoreExcess = ignore;
  }
  return;
}



int HText_insertBlanksInStblLines(HText *me,int ncols)

{
  ushort uVar1;
  int iVar2;
  HTStyle *pHVar3;
  BOOLEAN BVar4;
  int *oldpos_00;
  int *newpos_00;
  HTLine *pHVar5;
  FILE *__stream;
  int ninserts_00;
  int *local_94;
  int iVar6;
  TextAnchor **local_90;
  TextAnchor **ppTVar7;
  int local_8c;
  int local_7c;
  int local_78;
  int local_74;
  int local_70;
  int ip_1;
  int width_1;
  int width;
  int ip;
  int i;
  HTStyle *style;
  int table_offset;
  int spare;
  int indent;
  int max_width;
  int lines_changed;
  int added_chars_before;
  int last_nonempty;
  int first_lineno_pass2;
  int last_lineno;
  int first_lineno;
  int lineno;
  int ninserts;
  int *newpos;
  int *oldpos;
  HTLine *first_line;
  HTLine *mod_line;
  HTLine *line;
  short alignment;
  
  first_line = (HTLine *)0x0;
  last_nonempty = -1;
  lines_changed = 0;
  max_width = 0;
  i = 0;
  lineno = Stbl_getStartLine(me->stbl);
  if ((lineno < 0) || (me->Lines < lineno)) {
    local_7c = -1;
  }
  else {
    oldpos_00 = (int *)calloc(ncols * 2,4);
    if (oldpos_00 == (int *)0x0) {
      local_7c = -1;
    }
    else {
      newpos_00 = oldpos_00 + ncols;
      line = (HTLine *)me->last_line->next;
      while (i < lineno) {
        if (line == (HTLine *)0x0) {
          free(oldpos_00);
          return -1;
        }
        line = (HTLine *)line->next;
        i = i + 1;
      }
      iVar2 = me->Lines;
      first_lineno_pass2 = iVar2;
      while ((line != (HTLine *)0x0 && (lineno <= iVar2))) {
        local_94 = oldpos_00;
        ninserts_00 = Stbl_getFixupPositions(me->stbl,lineno,oldpos_00,newpos_00);
        if (-1 < ninserts_00) {
          if (first_line == (HTLine *)0x0) {
            first_line = line;
            first_lineno_pass2 = lineno;
            if (WWW_TraceFlag != '\0') {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                local_94 = (int *)lineno;
                fprintf((FILE *)__stream,"line %d first to adjust  --  newpos:",lineno);
              }
              ip = 0;
              while (ip < ncols) {
                if (WWW_TraceFlag != '\0') {
                  local_94 = (int *)newpos_00[ip];
                  __stream = TraceFP();
                  fprintf((FILE *)__stream," %d",local_94);
                }
                ip = ip + 1;
              }
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"\n",local_94);
              }
            }
          }
          if (me->last_line == line) {
            if ((line->size == 0) || (BVar4 = HText_TrueEmptyLine(line,me,'\0'), BVar4 != '\0'))
            goto LAB_080652c3;
            if (first_line == line) {
              first_line = (HTLine *)0x0;
            }
            split_line(me,0);
            line = (HTLine *)me->last_line->prev;
            if (first_line == (HTLine *)0x0) {
              first_line = line;
            }
          }
          if (ninserts_00 == 0) {
            ninserts_00 = HText_TrueLineSize(line,me,'\0');
            if (max_width < ninserts_00) {
              max_width = ninserts_00;
            }
            if (((nested_tables != '\0') && (ninserts_00 != 0)) && (last_nonempty < lineno)) {
              last_nonempty = lineno;
            }
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"line %d true/max width:%d/%d oldpos: NONE\n",lineno,
                      ninserts_00,max_width);
            }
          }
          else {
            local_90 = &me->last_anchor_before_stbl;
            local_8c = ninserts_00;
            pHVar5 = insert_blanks_in_line(line,lineno,me,local_90,ninserts_00,oldpos_00,newpos_00);
            if (pHVar5 != (HTLine *)0x0) {
              if (me->last_line == line) {
                me->last_line = pHVar5;
              }
              *(HTLine **)&line->prev->next = pHVar5;
              *(HTLine **)&line->next->prev = pHVar5;
              lines_changed = lines_changed + 1;
              if (line == first_line) {
                first_line = pHVar5;
              }
              line = pHVar5;
              if (-1 < me->first_lineno_last_disp_partial) {
                if (me->first_lineno_last_disp_partial < lineno) {
                  if (lineno <= me->last_lineno_last_disp_partial) {
                    me->last_lineno_last_disp_partial = lineno + -1;
                  }
                }
                else {
                  ResetPartialLinenos(me);
                }
              }
            }
            iVar6 = 0;
            ppTVar7 = (TextAnchor **)HText_TrueLineSize(line,me,'\0');
            if (max_width < (int)ppTVar7) {
              max_width = (int)ppTVar7;
            }
            if (((nested_tables != '\0') && (ppTVar7 != (TextAnchor **)0x0)) &&
               (last_nonempty < lineno)) {
              last_nonempty = lineno;
            }
            if (WWW_TraceFlag != '\0') {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                iVar6 = lineno;
                local_8c = max_width;
                fprintf((FILE *)__stream,"line %d true/max width:%d/%d oldpos:",lineno,ppTVar7,
                        max_width);
                local_90 = ppTVar7;
              }
              ip_1 = 0;
              while (ip_1 < ninserts_00) {
                if (WWW_TraceFlag != '\0') {
                  iVar6 = oldpos_00[ip_1];
                  __stream = TraceFP();
                  fprintf((FILE *)__stream," %d",iVar6,local_90,local_8c);
                }
                ip_1 = ip_1 + 1;
              }
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"\n",iVar6,local_90,local_8c);
              }
            }
          }
        }
LAB_080652c3:
        line = (HTLine *)line->next;
        lineno = lineno + 1;
      }
      pHVar3 = me->style;
      alignment = Stbl_getAlignment(me->stbl);
      if (alignment == -1) {
        alignment = pHVar3->alignment;
      }
      indent = pHVar3->leftIndent;
      if (me->stbl == (STable_info *)0x0) {
        local_78 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < 1) {
          if (LYwideLines == 0) {
            local_70 = LYcols;
          }
          else {
            local_70 = 0x3f6;
          }
          local_74 = local_70;
        }
        else {
          local_74 = LYtableCols * LYcols >> 0x1f;
          local_74 = ((LYtableCols * LYcols) / 6 + local_74 >> 1) - local_74;
        }
        local_78 = local_74 - (uint)(LYShowScrollbar != '\0');
      }
      spare = ((local_78 - pHVar3->rightIndent) - indent) - max_width;
      if ((spare < 0) && (-1 < pHVar3->rightIndent + spare)) {
        spare = 0;
      }
      else {
        if (spare < 0) {
          spare = spare + pHVar3->rightIndent;
        }
      }
      if ((spare < 0) && (-1 < indent + spare)) {
        indent = indent + spare;
        spare = 0;
      }
      else {
        if (spare < 0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,
                    "BUG: insertBlanks: resulting table too wide by %d positions!\n",-spare);
          }
          spare = 0;
          indent = 0;
        }
      }
      if (alignment == 2) {
        table_offset = indent + spare;
      }
      else {
        if (alignment == 3) {
          table_offset = spare / 2 + indent;
        }
        else {
          table_offset = indent;
        }
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"changing offsets");
      }
      line = first_line;
      lineno = first_lineno_pass2;
      while (((line != (HTLine *)0x0 && (lineno <= iVar2)) && (me->last_line != line))) {
        ninserts_00 = Stbl_getFixupPositions(me->stbl,lineno,oldpos_00,newpos_00);
        if ((-1 < ninserts_00) && ((uint)line->offset != table_offset)) {
          if (-1 < me->first_lineno_last_disp_partial) {
            if (me->first_lineno_last_disp_partial < lineno) {
              if (lineno <= me->last_lineno_last_disp_partial) {
                me->last_lineno_last_disp_partial = lineno + -1;
              }
            }
            else {
              ResetPartialLinenos(me);
            }
          }
          if (WWW_TraceFlag != '\0') {
            uVar1 = line->offset;
            __stream = TraceFP();
            fprintf((FILE *)__stream," %d:%d",lineno,table_offset - (uint)uVar1);
          }
          line->offset = ~(ushort)(table_offset >> 0x1f) & (ushort)table_offset;
        }
        line = (HTLine *)line->next;
        lineno = lineno + 1;
      }
      if ((nested_tables != '\0') && (max_width != 0)) {
        Stbl_update_enclosing(me->stbl,max_width,last_nonempty);
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream," %d:done\n",lineno);
      }
      free(oldpos_00);
      local_7c = lines_changed;
    }
  }
  return local_7c;
}



void HText_cancelStbl(HText *me)

{
  FILE *__stream;
  STable_info *pSVar1;
  STable_info *enclosing;
  STable_info *stbl;
  
  if ((me == (HText *)0x0) || (me->stbl == (STable_info *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"cancelStbl: ignored.\n");
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"cancelStbl: ok, will do.\n");
    }
    if (nested_tables == '\0') {
      Stbl_free(me->stbl);
    }
    else {
      stbl = me->stbl;
      while (stbl != (STable_info *)0x0) {
        pSVar1 = Stbl_get_enclosing(stbl);
        Stbl_free(stbl);
        stbl = pSVar1;
      }
    }
    me->stbl = (STable_info *)0x0;
  }
  return;
}



void HText_startStblTABLE(HText *me,short alignment)

{
  STable_info *enclosing;
  STable_info *pSVar1;
  FILE *__stream;
  STable_info *current;
  
  enclosing = me->stbl;
  if (me != (HText *)0x0) {
    if (nested_tables == '\0') {
      if (me->stbl != (STable_info *)0x0) {
        HText_cancelStbl(me);
      }
    }
    else {
      if (enclosing != (STable_info *)0x0) {
        split_line(me,0);
      }
    }
    pSVar1 = Stbl_startTABLE(alignment);
    me->stbl = pSVar1;
    if (me->stbl == (STable_info *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"startStblTABLE: failed.\n");
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"startStblTABLE: started.\n");
      }
      if (nested_tables != '\0') {
        Stbl_set_enclosing(me->stbl,enclosing,(_TextAnchor *)me->last_anchor_before_stbl);
      }
      me->last_anchor_before_stbl = me->last_anchor;
    }
  }
  return;
}



void free_enclosed_stbl(HText *me)

{
  STable_info *pSVar1;
  FILE *__stream;
  STable_info *local_1c;
  STable_info *stbl;
  HTList *list;
  
  if (me->enclosed_stbl != (HTList *)0x0) {
    list = me->enclosed_stbl;
    while( true ) {
      if ((list == (HTList *)0x0) || (list = list->next, list == (HTList *)0x0)) {
        local_1c = (STable_info *)0x0;
      }
      else {
        local_1c = (STable_info *)list->object;
      }
      if (local_1c == (STable_info *)0x0) break;
      if (WWW_TraceFlag != '\0') {
        pSVar1 = me->stbl;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"endStblTABLE: finally free %p\n",pSVar1);
      }
      Stbl_free(local_1c);
    }
    HTList_delete(me->enclosed_stbl);
    me->enclosed_stbl = (HTList *)0x0;
  }
  return;
}



int HText_endStblTABLE(HText *me)

{
  STable_info *pSVar1;
  FILE *__stream;
  int ncols_00;
  _TextAnchor *p_Var2;
  HTList *pHVar3;
  uint local_20;
  undefined *local_1c;
  STable_info *enclosing;
  int lines_changed;
  int ncols;
  
  enclosing = (STable_info *)0x0;
  if ((me == (HText *)0x0) || (me->stbl == (STable_info *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"endStblTABLE: ignored.\n");
    }
    free_enclosed_stbl(me);
    local_20 = 0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"endStblTABLE: ok, will try.\n");
    }
    ncols_00 = Stbl_finishTABLE(me->stbl);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"endStblTABLE: ncols = %d.\n",ncols_00);
    }
    if (0 < ncols_00) {
      ncols_00 = HText_insertBlanksInStblLines(me,ncols_00);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"endStblTABLE: changed %d lines, done.\n",ncols_00);
      }
      NumOfLines_partial = NumOfLines_partial - ncols_00;
    }
    if (nested_tables == '\0') {
      Stbl_free(me->stbl);
      me->stbl = (STable_info *)0x0;
    }
    else {
      enclosing = Stbl_get_enclosing(me->stbl);
      p_Var2 = Stbl_get_last_anchor_before(me->stbl);
      *(_TextAnchor **)&me->last_anchor_before_stbl = p_Var2;
      if (enclosing == (STable_info *)0x0) {
        Stbl_free(me->stbl);
        free_enclosed_stbl(me);
      }
      else {
        if (me->enclosed_stbl == (HTList *)0x0) {
          pHVar3 = HTList_new();
          me->enclosed_stbl = pHVar3;
        }
        HTList_addObject(me->enclosed_stbl,me->stbl);
        if (WWW_TraceFlag != '\0') {
          pSVar1 = me->stbl;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"endStblTABLE: postpone free %p\n",pSVar1);
        }
      }
      me->stbl = enclosing;
    }
    if (WWW_TraceFlag != '\0') {
      if (enclosing == (STable_info *)0x0) {
        local_1c = &DAT_0814d3d8;
      }
      else {
        local_1c = &DAT_0814cbac;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"endStblTABLE: have%s enclosing table (%p)\n",local_1c,enclosing);
    }
    local_20 = (uint)(enclosing != (STable_info *)0x0);
  }
  return local_20;
}



void HText_startStblTR(HText *me,short alignment)

{
  int iVar1;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    iVar1 = Stbl_addRowToTable(me->stbl,(int)alignment,me->Lines);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_endStblTR(HText *me)

{
  return;
}



void HText_startStblTD(HText *me,int colspan,int rowspan,short alignment,BOOLEAN isheader)

{
  FILE *__stream;
  int pos;
  int offset_not_used_yet;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    if (colspan < 0) {
      colspan = 1;
    }
    if (200 < colspan) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** COLSPAN=%d is too large, ignored!\n",colspan);
      }
      colspan = 1;
    }
    if (200 < rowspan) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** ROWSPAN=%d is too large, ignored!\n",rowspan);
      }
      rowspan = 1;
    }
    pos = HText_LastLineSize(me,'\0');
    offset_not_used_yet = HText_LastLineOffset(me);
    pos = Stbl_addCellToTable(me->stbl,colspan,rowspan,(int)alignment,(int)isheader,me->Lines,
                              offset_not_used_yet,pos);
    if (pos < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_endStblTD(HText *me)

{
  int pos;
  int offset;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    pos = HText_LastLineSize(me,'\0');
    offset = HText_LastLineOffset(me);
    pos = Stbl_finishCellInTable(me->stbl,1,me->Lines,offset,pos);
    if (pos < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_startStblCOL(HText *me,int span,short alignment,BOOLEAN isgroup)

{
  FILE *__stream;
  int iVar1;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    if (span < 1) {
      span = 1;
    }
    if (200 < span) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** SPAN=%d is too large, ignored!\n",span);
      }
      span = 1;
    }
    iVar1 = Stbl_addColInfo(me->stbl,span,alignment,isgroup);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_endStblCOLGROUP(HText *me)

{
  int iVar1;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    iVar1 = Stbl_finishColGroup(me->stbl);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_startStblRowGroup(HText *me,short alignment)

{
  int iVar1;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    iVar1 = Stbl_addRowGroup(me->stbl,alignment);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void add_link_number(HText *text,TextAnchor *a,BOOLEAN save_position)

{
  int iVar1;
  char cVar2;
  int iVar3;
  int in_GS_OFFSET;
  int saved_linenum;
  char saved_lastchar;
  char marker [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (((0 < a->number) && ((text->source == '\0' || (psrcview_no_anchor_numbering == '\0')))) &&
     ((keypad_mode == 1 || (keypad_mode == 2)))) {
    cVar2 = text->LastChar;
    iVar3 = text->Lines;
    sprintf(marker,"[%d]",a->number);
    HText_appendText(text,marker);
    if (((iVar3 != 0) && (text->Lines != 0)) && (cVar2 != ' ')) {
      text->LastChar = ']';
    }
    if (save_position != '\0') {
      a->line_num = text->Lines;
      a->line_pos = text->last_line->size;
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int HText_beginAnchor(HText *text,BOOLEAN underline,HTChildAnchor *anc)

{
  TextAnchor *a_00;
  int iVar1;
  HTAnchor *pHVar2;
  TextAnchor *a;
  
  a_00 = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
  if (a_00 == (TextAnchor *)0x0) {
    outofmem("./GridText.c","HText_beginAnchor");
  }
  a_00->inUnderline = underline;
  iVar1 = SGML_offset();
  a_00->sgml_offset = iVar1;
  a_00->line_num = text->Lines;
  a_00->line_pos = text->last_line->size;
  if (text->last_anchor == (TextAnchor *)0x0) {
    text->first_anchor = a_00;
  }
  else {
    *(TextAnchor **)&text->last_anchor->next = a_00;
  }
  a_00->next = (_TextAnchor *)0x0;
  a_00->anchor = anc;
  a_00->extent = 0;
  a_00->link_type = '\x01';
  text->last_anchor = a_00;
  pHVar2 = HTAnchor_followLink(anc);
  if (pHVar2 == (HTAnchor *)0x0) {
    a_00->number = 0;
  }
  else {
    text->last_anchor_number = text->last_anchor_number + 1;
    a_00->number = text->last_anchor_number;
  }
  if (number_links_on_left != '\0') {
    add_link_number(text,a_00,'\x01');
  }
  return a_00->number;
}



BOOLEAN HText_endAnchor0(HText *text,int number,int really)

{
  char cVar1;
  short sVar2;
  HTLine *pHVar3;
  int iVar4;
  short sVar5;
  bool bVar6;
  uint uVar7;
  BOOLEAN BVar8;
  FILE *__stream;
  HTAnchor *me;
  ushort **ppuVar9;
  int iVar10;
  short local_56;
  TextAnchor *anc;
  int NumSize;
  int extent_adjust;
  int BlankExtent;
  int CurBlankExtent;
  HTLine *start;
  HTLine *prev;
  HTLine *last;
  int l;
  int k;
  int j;
  int i;
  TextAnchor *a;
  BOOLEAN remove_numbers_on_empty;
  
  if ((number < 1) || (text->last_anchor->number == number)) {
    a = text->last_anchor;
  }
  else {
    a = text->first_anchor;
    while ((a != (TextAnchor *)0x0 && (a->number != number))) {
      a = (TextAnchor *)a->next;
    }
    if (a == (TextAnchor *)0x0) {
      a = text->last_anchor;
    }
  }
  if (WWW_TraceFlag != '\0') {
    cVar1 = a->link_type;
    iVar10 = a->number;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText:HText_endAnchor0: number:%d link_type:%d\n",iVar10,(int)cVar1
           );
  }
  if (a->link_type == '\x02') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,
              "BUG: HText_endAnchor0: internal error: last anchor was input field!\n");
    }
    return '\0';
  }
  if (a->number == 0) {
    if (really != 0) {
      a->show_anchor = '\0';
      a->extent = 0;
      return '\0';
    }
    return '\0';
  }
  if ((keypad_mode == 1) || (keypad_mode == 2)) {
    if (text->hiddenlinkflag != 0) {
LAB_0806620f:
      bVar6 = true;
      goto LAB_0806621f;
    }
    if ((LYNoISMAPifUSEMAP != '\0') &&
       ((text->node_anchor == (HTParentAnchor *)0x0 || (text->node_anchor->bookmark == (char *)0x0))
       )) {
      me = HTAnchor_followLink(a->anchor);
      BVar8 = HTAnchor_isISMAPScript(me);
      if (BVar8 != '\0') goto LAB_0806620f;
    }
  }
  bVar6 = false;
LAB_0806621f:
  pHVar3 = text->last_line;
  prev = (HTLine *)text->last_line->prev;
  CurBlankExtent = 0;
  BlankExtent = 0;
  extent_adjust = 0;
  l = text->Lines;
  start = pHVar3;
  if (a->line_num < l) {
    i = ZEXT24(pHVar3->size);
    while ((0 < i && (ppuVar9 = __ctype_b_loc(),
                     ((*ppuVar9)[*(byte *)((int)&pHVar3->numstyles + i + 1)] & 0x2000) != 0))) {
      extent_adjust = extent_adjust + -1;
      i = i + -1;
    }
  }
  while (a->line_num < l) {
    extent_adjust = extent_adjust + (uint)start->size;
    l = l + -1;
    start = (HTLine *)start->prev;
  }
  sVar5 = (short)extent_adjust + (start->size - a->line_pos);
  a->extent = a->extent + sVar5;
  if ((int)(uint)pHVar3->size < (int)a->extent) {
    i = ZEXT24(pHVar3->size);
  }
  else {
    i = (int)a->extent;
  }
  k = (uint)pHVar3->size - i;
  j = k;
  while ((j < (int)(uint)pHVar3->size &&
         (((('\x02' < pHVar3->data[j] && (pHVar3->data[j] < '\t')) ||
           (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[(byte)pHVar3->data[j]] & 0x2000) != 0)) ||
          ((pHVar3->data[j] == '\x01' || (pHVar3->data[j] == '\x02'))))))) {
    i = i + -1;
    j = j + 1;
  }
  start = pHVar3;
  if (i == 0) {
    if ((int)(uint)pHVar3->size < (int)a->extent) {
      BlankExtent = ZEXT24(pHVar3->size);
      CurBlankExtent = BlankExtent;
    }
    else {
      BlankExtent = (int)a->extent;
      CurBlankExtent = BlankExtent;
    }
  }
  while( true ) {
    do {
      if ((i != 0) ||
         ((a->extent <= CurBlankExtent &&
          ((((int)a->extent != CurBlankExtent || (k != 0)) ||
           ((text->last_line == prev ||
            ((prev->size != 0 && (*(char *)((int)&prev->numstyles + (uint)prev->size + 1) != ']'))))
           )))))) goto LAB_0806660f;
      start = prev;
      k = ((uint)prev->size - (int)a->extent) + CurBlankExtent;
      if (k < 0) {
        j = 0;
        i = ZEXT24(prev->size);
      }
      else {
        i = a->extent - CurBlankExtent;
        j = k;
      }
      while ((j < (int)(uint)prev->size &&
             (((('\x02' < prev->data[j] && (prev->data[j] < '\t')) ||
               (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[(byte)prev->data[j]] & 0x2000) != 0)) ||
              ((prev->data[j] == '\x01' || (prev->data[j] == '\x02'))))))) {
        i = i + -1;
        j = j + 1;
      }
    } while (i != 0);
    if (((int)a->extent <= (int)((uint)prev->size + CurBlankExtent)) &&
       ((((int)a->extent != (uint)prev->size + CurBlankExtent || (k != 0)) ||
        (((HTLine *)prev->prev == text->last_line ||
         ((prev->prev->size != 0 &&
          (*(char *)((int)&prev->prev->numstyles + (uint)prev->prev->size + 1) != ']')))))))) break;
    BlankExtent = CurBlankExtent + (uint)prev->size;
    prev = (HTLine *)prev->prev;
    CurBlankExtent = BlankExtent;
  }
  BlankExtent = (int)a->extent;
LAB_0806660f:
  if (really == 0) {
    a->extent = a->extent - sVar5;
    return i == 0;
  }
  if (i == 0) {
    a->show_anchor = '\0';
    if (WWW_TraceFlag != '\0') {
      sVar5 = a->extent;
      sVar2 = a->line_pos;
      iVar10 = a->line_num;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
              iVar10,(int)sVar2,(int)sVar5,BlankExtent);
    }
    if (bVar6) {
      if (start == pHVar3) {
        CurBlankExtent = (uint)pHVar3->size - (int)a->extent;
      }
      else {
        prev = (HTLine *)start->prev;
        CurBlankExtent = ((uint)start->size - (int)a->extent) + CurBlankExtent;
      }
      j = CurBlankExtent + -1;
      if (j < 0) {
        j = 0;
      }
      iVar10 = j;
      if (start->data[j] == ']') {
        NumSize = 1;
        iVar4 = j;
        while ((j = iVar4 + -1, -1 < j &&
               (ppuVar9 = __ctype_b_loc(),
               ((*ppuVar9)[*(byte *)((int)&start->numstyles + iVar4 + 1)] & 0x800) != 0))) {
          NumSize = NumSize + 1;
          iVar4 = j;
        }
        while (j < 0) {
          j = j + 1;
          NumSize = NumSize + -1;
        }
        if (start->data[j] == '[') {
          NumSize = NumSize + 1;
          if ((start == pHVar3) && (j < (int)text->permissible_split)) {
            if ((int)(text->permissible_split - NumSize) < j) {
              text->permissible_split = j;
            }
            else {
              text->permissible_split = text->permissible_split - NumSize;
            }
          }
          k = j + NumSize;
          while (k < (int)(uint)start->size) {
            start->data[j] = start->data[k];
            j = j + 1;
            k = k + 1;
          }
          anc = a;
          while (anc != (TextAnchor *)0x0) {
            if ((anc->line_num == a->line_num) && (NumSize <= anc->line_pos)) {
              anc->line_pos = anc->line_pos - (short)NumSize;
            }
            anc = (TextAnchor *)anc->next;
          }
          start->size = (ushort)j;
          start->data[j] = '\0';
          iVar10 = j;
          while (j = iVar10 + 1, j < k) {
            *(undefined *)(&start->field_0x13 + iVar10) = 0;
            iVar10 = j;
          }
        }
        else {
          if ((prev == (HTLine *)0x0) || (prev->size < 2)) {
            a->show_anchor = '\x01';
          }
          else {
            iVar10 = iVar10 + 1;
            uVar7 = (uint)prev->size;
            do {
              i = uVar7;
              j = i - 1;
              if ((j < 0) || (*(char *)((int)&prev->numstyles + i + 1U) < '\x03')) break;
              uVar7 = j;
            } while (*(char *)((int)&prev->numstyles + i + 1U) < '\t');
            while ((-1 < j &&
                   (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[(byte)prev->data[j]] & 0x800) != 0))) {
              j = j + -1;
            }
            while (j < 0) {
              j = j + 1;
            }
            if (prev->data[j] == '[') {
              while (i < (int)(uint)prev->size) {
                prev->data[j] = prev->data[i];
                j = j + 1;
                i = i + 1;
              }
              prev->size = (ushort)j;
              prev->data[j] = '\0';
              while (j < i) {
                prev->data[j] = '\0';
                j = j + 1;
              }
              if ((start == pHVar3) && (text->permissible_split != 0)) {
                if ((int)text->permissible_split < iVar10) {
                  text->permissible_split = 0;
                }
                else {
                  text->permissible_split = text->permissible_split - iVar10;
                }
              }
              j = 0;
              k = iVar10;
              while (k < (int)(uint)start->size) {
                start->data[j] = start->data[k];
                j = j + 1;
                k = k + 1;
              }
              anc = a;
              while (anc != (TextAnchor *)0x0) {
                if ((anc->line_num == a->line_num) && (iVar10 <= anc->line_pos)) {
                  anc->line_pos = anc->line_pos - (short)iVar10;
                }
                anc = (TextAnchor *)anc->next;
              }
              start->size = (ushort)j;
              start->data[j] = '\0';
              iVar10 = j;
              while (j = iVar10 + 1, j < k) {
                *(undefined *)(&start->field_0x13 + iVar10) = 0;
                iVar10 = j;
              }
            }
            else {
              a->show_anchor = '\x01';
            }
          }
        }
      }
      else {
        if ((prev == (HTLine *)0x0) || (prev->size < 3)) {
          a->show_anchor = '\x01';
        }
        else {
          uVar7 = (uint)prev->size;
          do {
            j = uVar7 - 1;
            if ((j < 0) || (*(char *)((int)&prev->numstyles + uVar7 + 1) < '\x03')) break;
            iVar10 = uVar7 + 1;
            uVar7 = j;
          } while (*(char *)((int)&prev->numstyles + iVar10) < '\t');
          if (j < 0) {
            j = 0;
          }
          if (((j < 2) || (prev->data[j] != ']')) ||
             (ppuVar9 = __ctype_b_loc(),
             ((*ppuVar9)[*(byte *)((int)&prev->numstyles + j + 1)] & 0x800) == 0)) {
            a->show_anchor = '\x01';
          }
          else {
            NumSize = 1;
            iVar10 = j;
            while ((j = iVar10 + -1, -1 < j &&
                   (ppuVar9 = __ctype_b_loc(),
                   ((*ppuVar9)[*(byte *)((int)&prev->numstyles + iVar10 + 1)] & 0x800) != 0))) {
              NumSize = NumSize + 1;
              iVar10 = j;
            }
            while (j < 0) {
              j = j + 1;
              NumSize = NumSize + -1;
            }
            if (prev->data[j] == '[') {
              k = j + NumSize + 1;
              while (k < (int)(uint)prev->size) {
                prev->data[j] = prev->data[k];
                j = j + 1;
                k = k + 1;
              }
              prev->size = (ushort)j;
              prev->data[j] = '\0';
              iVar10 = j;
              while (j = iVar10 + 1, j < k) {
                *(undefined *)(&prev->field_0x13 + iVar10) = 0;
                iVar10 = j;
              }
            }
            else {
              a->show_anchor = '\x01';
            }
          }
        }
      }
    }
  }
  else {
    if (number_links_on_left == '\0') {
      add_link_number(text,a,'\0');
    }
    a->show_anchor = '\x01';
    if ((BlankExtent != 0) && (WWW_TraceFlag != '\0')) {
      sVar5 = a->extent;
      sVar2 = a->line_pos;
      iVar10 = a->line_num;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
              iVar10,(int)sVar2,(int)sVar5,BlankExtent);
    }
  }
  if (a->show_anchor == '\0') {
    a->extent = 0;
    if (text->hiddenlinkflag != 0) {
      a->number = 0;
      text->last_anchor_number = text->last_anchor_number + -1;
      HText_AddHiddenLink(text,a);
    }
  }
  else {
    if (BlankExtent < a->extent) {
      local_56 = (short)BlankExtent;
    }
    else {
      local_56 = 0;
    }
    a->extent = a->extent - local_56;
  }
  if ((((BlankExtent != 0) || (a->extent < 1)) || (a->number < 1)) && (WWW_TraceFlag != '\0')) {
    sVar5 = a->extent;
    sVar2 = a->line_pos;
    iVar10 = a->line_num;
    iVar4 = a->number;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"->[%d](%d,%d,%d,%d)\n",iVar4,iVar10,(int)sVar2,(int)sVar5,BlankExtent)
    ;
  }
  return '\0';
}



void HText_endAnchor(HText *text,int number)

{
  HText_endAnchor0(text,number,1);
  return;
}



BOOLEAN HText_isAnchorBlank(HText *text,int number)

{
  BOOLEAN BVar1;
  
  BVar1 = HText_endAnchor0(text,number,0);
  return BVar1;
}



void HText_appendText(HText *text,char *str)

{
  char *p;
  
  if ((str != (char *)0x0) && (text->halted != 3)) {
    p = str;
    while (*p != '\0') {
      HText_appendCharacter(text,(int)*p);
      p = p + 1;
    }
  }
  return;
}



int remove_special_attr_chars(char *buf)

{
  char *local_c;
  int local_8;
  
  local_8 = 0;
  local_c = buf;
  while (*local_c != '\0') {
    local_8 = local_8 + (uint)(*local_c == '\b');
    if ((*local_c < '\x03') || ('\b' < *local_c)) {
      *buf = *local_c;
      buf = buf + 1;
    }
    local_c = local_c + 1;
  }
  *buf = '\0';
  return local_8;
}



void HText_endAppend(HText *text)

{
  _line *p_Var1;
  _line *p_Var2;
  HTLine *pHVar3;
  FILE *__stream;
  HTLine *next_to_the_last_line;
  HTLine *line_ptr;
  
  if (text != (HText *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GridText: Entering HText_endAppend\n");
    }
    split_line(text,0);
    if (text->halted == 0) {
      if (text->stbl != (STable_info *)0x0) {
        HText_endStblTABLE(text);
      }
    }
    else {
      if (text->stbl != (STable_info *)0x0) {
        HText_cancelStbl(text);
      }
      LYFakeZap('\0');
      text->halted = 0;
    }
    p_Var1 = text->last_line->next;
    while ((text->last_line->data[0] == '\0' && (2 < text->Lines))) {
      p_Var2 = text->last_line->prev;
      if (WWW_TraceFlag != '\0') {
        pHVar3 = text->last_line;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: Removing bottom blank line: `%s\'\n",pHVar3->data);
      }
      p_Var2->next = p_Var1;
      p_Var1->prev = p_Var2;
      *(_line **)&text->last_line = p_Var2;
      text->Lines = text->Lines + -1;
      if (WWW_TraceFlag != '\0') {
        pHVar3 = text->last_line;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: New bottom line: `%s\'\n",pHVar3->data);
      }
    }
    HText_trimHightext(text,'\x01',-1);
  }
  return;
}



void HText_trimHightext(HText *text,BOOLEAN final,int stop_before)

{
  short sVar1;
  short sVar2;
  ushort uVar3;
  int iVar4;
  _line *p_Var5;
  FILE *__stream;
  char *__s;
  ushort **ppuVar6;
  size_t sVar7;
  size_t sVar8;
  int x;
  int hi_offset;
  char *hi_string;
  HTLine *old_line_ptr2;
  int size;
  int anchor_col;
  int count_line;
  int actual_len;
  int hilite_len;
  char *hilite_str;
  HTLine *line_ptr2;
  HTLine *line_ptr;
  TextAnchor *prev_a;
  TextAnchor *anchor_ptr;
  int cur_shift;
  int cur_line;
  uchar ch;
  
  prev_a = (TextAnchor *)0x0;
  if (text != (HText *)0x0) {
    if (final == '\0') {
      if ((stop_before < 0) || (text->Lines < stop_before)) {
        stop_before = text->Lines;
      }
      if (WWW_TraceFlag != '\0') {
        x = text->Lines;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n",
                stop_before,x);
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: Entering HText_trimHightext (final)\n");
      }
    }
    line_ptr = (HTLine *)text->last_line->next;
    cur_line = 0;
    anchor_ptr = text->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      while( true ) {
        while (cur_line < anchor_ptr->line_num) {
          line_ptr = (HTLine *)line_ptr->next;
          cur_line = cur_line + 1;
        }
        if (final == '\0') {
          if (stop_before <= cur_line) {
            return;
          }
          if ((text->Lines + -1 <= anchor_ptr->line_num) &&
             ((int)(uint)text->last_line->prev->size <= (int)anchor_ptr->line_pos)) {
            return;
          }
          if ((((anchor_ptr->extent == 0) && (anchor_ptr->number != 0)) &&
              ((anchor_ptr->link_type & 1U) != 0)) &&
             ((anchor_ptr->show_anchor == '\0' && (anchor_ptr->number == text->last_anchor_number)))
             ) goto LAB_080677e5;
        }
        __s = LYGetHiTextStr(anchor_ptr,0);
        if (__s != (char *)0x0) goto LAB_080677e5;
        if ((int)(uint)line_ptr->size < (int)anchor_ptr->line_pos) {
          anchor_ptr->line_pos = line_ptr->size;
        }
        if (anchor_ptr->line_pos < 0) {
          anchor_ptr->line_pos = 0;
          anchor_ptr->line_num = cur_line;
        }
        if (WWW_TraceFlag != '\0') {
          sVar1 = anchor_ptr->extent;
          x = anchor_ptr->number;
          iVar4 = anchor_ptr->sgml_offset;
          sVar2 = anchor_ptr->line_pos;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"GridText: Anchor found on line:%d col:%d [%05d:%d] ext:%d\n",
                  cur_line,(int)sVar2,iVar4,x,(int)sVar1);
        }
        if ((anchor_ptr->link_type & 1U) != 0) {
          ch = line_ptr->data[anchor_ptr->line_pos];
          while ((ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[ch] & 0x2000) != 0 ||
                 ((2 < ch && (ch < 9))))) {
            anchor_ptr->line_pos = anchor_ptr->line_pos + 1;
            anchor_ptr->extent = anchor_ptr->extent + -1;
            ch = line_ptr->data[anchor_ptr->line_pos];
          }
        }
        if (anchor_ptr->extent < 0) {
          anchor_ptr->extent = 0;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"anchor text: \'%s\'\n",line_ptr->data);
        }
        sVar1 = anchor_ptr->line_pos;
        sVar7 = strlen(line_ptr->data);
        if ((uint)(int)sVar1 < sVar7) goto LAB_080674b9;
        if ((text->Lines <= cur_line) ||
           (((anchor_ptr->extent == 0 && ((int)anchor_ptr->line_pos == (uint)line_ptr->size)) &&
            ((prev_a == (TextAnchor *)0x0 || (prev_a->line_num <= anchor_ptr->line_num)))))) break;
        anchor_ptr->line_num = anchor_ptr->line_num + 1;
        anchor_ptr->line_pos = 0;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"found anchor at end of line\n");
        }
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"found anchor at end of line, leaving it there\n");
      }
LAB_080674b9:
      if ((anchor_ptr->extent < 1) || (anchor_ptr->line_pos < 0)) {
        LYClearHiText(anchor_ptr);
        LYSetHiText(anchor_ptr,"",0);
      }
      else {
        size = (uint)line_ptr->size - (int)anchor_ptr->line_pos;
        if (anchor_ptr->extent < size) {
          size = (int)anchor_ptr->extent;
        }
        LYClearHiText(anchor_ptr);
        LYSetHiText(anchor_ptr,line_ptr->data + anchor_ptr->line_pos,size);
      }
      __s = LYGetHiTextStr(anchor_ptr,0);
      sVar7 = strlen(__s);
      actual_len = (int)anchor_ptr->extent;
      line_ptr2 = line_ptr;
      count_line = cur_line;
      while ((int)sVar7 < actual_len) {
        count_line = count_line + 1;
        p_Var5 = line_ptr2->next;
        if ((final == '\0') && (stop_before <= count_line)) {
          LYClearHiText(anchor_ptr);
          break;
        }
        if (text->last_line == line_ptr2) break;
        line_ptr2 = (HTLine *)p_Var5;
        if (p_Var5 != (_line *)0x0) {
          hi_string = (char *)0x0;
          uVar3 = p_Var5->offset;
          SNACopy(&hi_string,p_Var5->data,actual_len - sVar7);
          sVar8 = strlen(hi_string);
          actual_len = actual_len - sVar8;
          x = remove_special_attr_chars(hi_string);
          x = (uint)uVar3 + x;
          if ((anchor_ptr->link_type & 1U) != 0) {
            LYTrimTrailing(hi_string);
          }
          if ((hi_string == (char *)0x0) || (*hi_string == '\0')) {
            if ((int)sVar7 < actual_len) {
              LYAddHiText(anchor_ptr,"",x);
            }
          }
          else {
            LYAddHiText(anchor_ptr,hi_string,x);
          }
          if (hi_string != (char *)0x0) {
            free(hi_string);
            hi_string = (char *)0x0;
          }
        }
      }
      if ((final == '\0') && (stop_before <= count_line)) {
        return;
      }
      __s = LYGetHiTextStr(anchor_ptr,0);
      remove_special_attr_chars(__s);
      if ((anchor_ptr->link_type & 1U) != 0) {
        LYTrimTrailing(__s);
      }
      if (0 < anchor_ptr->line_pos) {
        x = LYstrExtent2(line_ptr->data,(int)anchor_ptr->line_pos);
        anchor_ptr->line_pos = (short)x;
        if (line_ptr->data[0] == '\b') {
          anchor_ptr->line_pos = anchor_ptr->line_pos + 1;
        }
      }
      anchor_ptr->line_pos = anchor_ptr->line_pos + line_ptr->offset;
      anchor_ptr->line_num = cur_line;
      if (WWW_TraceFlag != '\0') {
        x = anchor_ptr->number;
        sVar1 = anchor_ptr->line_pos;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText:     add link on line %d col %d [%d] %s\n",cur_line,
                (int)sVar1,x,"in HText_trimHightext");
      }
LAB_080677e5:
      prev_a = anchor_ptr;
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
  }
  return;
}



HTParentAnchor * HText_nodeAnchor(HText *text)

{
  return text->node_anchor;
}



HTChildAnchor * HText_childNextNumber(int number,void **prev)

{
  HTChildAnchor *local_18;
  TextAnchor *a;
  
  a = (TextAnchor *)*prev;
  if ((HTMainText == (HText *)0x0) || (number < 1)) {
    local_18 = (HTChildAnchor *)0x0;
  }
  else {
    if ((number == 1) || (a == (TextAnchor *)0x0)) {
      a = HTMainText->first_anchor;
    }
    while ((a != (TextAnchor *)0x0 && (a->number != number))) {
      a = (TextAnchor *)a->next;
    }
    if (a == (TextAnchor *)0x0) {
      local_18 = (HTChildAnchor *)0x0;
    }
    else {
      *(TextAnchor **)prev = a;
      local_18 = a->anchor;
    }
  }
  return local_18;
}



void HText_FormDescNumber(int number,char **desc)

{
  char *pcVar1;
  TextAnchor *a;
  
  if (desc != (char **)0x0) {
    if (((HTMainText == (HText *)0x0) || (HTMainText->first_anchor == (TextAnchor *)0x0)) ||
       (number < 1)) {
      pcVar1 = (char *)gettext("unknown field or link");
      *desc = pcVar1;
    }
    else {
      a = HTMainText->first_anchor;
      while (a != (TextAnchor *)0x0) {
        if (a->number == number) {
          if ((a->input_field == (FormInfo *)0x0) || (a->input_field->type == 0)) {
            pcVar1 = (char *)gettext("unknown field or link");
            *desc = pcVar1;
            return;
          }
          break;
        }
        a = (TextAnchor *)a->next;
      }
      switch(a->input_field->type) {
      default:
        pcVar1 = (char *)gettext("unknown form field");
        *desc = pcVar1;
        break;
      case 1:
        pcVar1 = (char *)gettext("text entry field");
        *desc = pcVar1;
        break;
      case 2:
        pcVar1 = (char *)gettext("password entry field");
        *desc = pcVar1;
        break;
      case 3:
        pcVar1 = (char *)gettext("checkbox");
        *desc = pcVar1;
        break;
      case 4:
        pcVar1 = (char *)gettext("radio button");
        *desc = pcVar1;
        break;
      case 5:
        pcVar1 = (char *)gettext("submit button");
        *desc = pcVar1;
        break;
      case 6:
        pcVar1 = (char *)gettext("reset button");
        *desc = pcVar1;
        break;
      case 7:
        pcVar1 = (char *)gettext("popup menu");
        *desc = pcVar1;
        break;
      case 8:
        pcVar1 = (char *)gettext("hidden form field");
        *desc = pcVar1;
        break;
      case 9:
        pcVar1 = (char *)gettext("text entry area");
        *desc = pcVar1;
        break;
      case 10:
        pcVar1 = (char *)gettext("range entry field");
        *desc = pcVar1;
        break;
      case 0xb:
        pcVar1 = (char *)gettext("file entry field");
        *desc = pcVar1;
        break;
      case 0xc:
        pcVar1 = (char *)gettext("text-submit field");
        *desc = pcVar1;
        break;
      case 0xd:
        pcVar1 = (char *)gettext("image-submit button");
        *desc = pcVar1;
        break;
      case 0xe:
        pcVar1 = (char *)gettext("keygen field");
        *desc = pcVar1;
      }
    }
  }
  return;
}



int HTGetRelLinkNum(int num,int rel,int cur)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  bool bVar5;
  HText *pHVar6;
  int iVar7;
  FILE *__stream;
  char *local_38;
  int local_34;
  int local_30;
  int curanchor;
  int on_screen;
  int curpos;
  int curline;
  int scrtop;
  TextAnchor *l;
  TextAnchor *a;
  
  l = (TextAnchor *)0x0;
  iVar7 = HText_getTopOfScreen();
  pHVar6 = HTMainText;
  iVar1 = links[cur].anchor_line_num;
  iVar2 = links[cur].lx;
  if ((iVar1 < iVar7) || (display_lines + iVar7 <= iVar1)) {
    bVar5 = false;
  }
  else {
    bVar5 = true;
  }
  curanchor = links[cur].anchor_number;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",num,rel,cur,pHVar6);
  }
  iVar3 = display_lines;
  if (WWW_TraceFlag != '\0') {
    if (bVar5) {
      local_38 = "on_screen";
    }
    else {
      local_38 = "0";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",iVar7,
            iVar1,curanchor,iVar3,local_38);
  }
  if (HTMainText == (HText *)0x0) {
    local_34 = 0;
  }
  else {
    if (rel == 0) {
      local_34 = num;
    }
    else {
      if ((bVar5) && (curanchor != 0)) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"curanchor=%d at line %d on screen\n",curanchor,iVar1);
        }
        if (rel == 0x2b) {
          local_34 = curanchor + num;
        }
        else {
          if (rel == 0x2d) {
            local_34 = curanchor - num;
          }
          else {
            local_34 = num;
          }
        }
      }
      else {
        a = HTMainText->first_anchor;
        while (a != (TextAnchor *)0x0) {
          if (WWW_TraceFlag != '\0') {
            iVar3 = a->number;
            iVar4 = a->line_num;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"  a->line_num=%d, a->number=%d\n",iVar4,iVar3);
          }
          if (iVar7 <= a->line_num) break;
          if (a->number != 0) {
            l = a;
            curanchor = a->number;
          }
          a = (TextAnchor *)a->next;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor);
        }
        if (bVar5) {
          while (a != (TextAnchor *)0x0) {
            if (a->number != 0) {
              l = a;
              curanchor = a->number;
            }
            if ((a->line_num == iVar1) && ((int)a->line_pos == iVar2)) break;
            a = (TextAnchor *)a->next;
          }
        }
        if (rel == 0x2b) {
          local_34 = curanchor + num;
        }
        else {
          if (rel == 0x2d) {
            if (l == (TextAnchor *)0x0) {
              while ((a != (TextAnchor *)0x0 && (a->number == 0))) {
                a = (TextAnchor *)a->next;
              }
              if (a == (TextAnchor *)0x0) {
                local_30 = 0;
              }
              else {
                local_30 = a->number - num;
              }
              local_34 = local_30;
            }
            else {
              local_34 = (curanchor + 1) - num;
            }
          }
          else {
            local_34 = num;
          }
        }
      }
    }
  }
  return local_34;
}



// WARNING: Removing unreachable block (ram,0x08067f39)

int HTGetLinkInfo(int number,int want_go,int *go_line,int *linknum,char **hightext,char **lname)

{
  char *pcVar1;
  HTAnchor *me;
  char *cp_freeme;
  int max_offset;
  int prev_prev_anchor_line;
  int prev_anchor_line;
  int anchors_this_screen;
  int anchors_this_line;
  HTAnchor *link_dest;
  TextAnchor *a;
  
  anchors_this_line = 0;
  anchors_this_screen = 0;
  prev_anchor_line = -1;
  prev_prev_anchor_line = -1;
  if (HTMainText != (HText *)0x0) {
    a = HTMainText->first_anchor;
    while (a != (TextAnchor *)0x0) {
      if ((a->show_anchor != '\0') && ((a->link_type != '\x02' || (a->input_field->type != 8)))) {
        if (a->line_num == prev_anchor_line) {
          anchors_this_line = anchors_this_line + 1;
        }
        else {
          anchors_this_line = 1;
          prev_prev_anchor_line = prev_anchor_line;
          prev_anchor_line = a->line_num;
        }
        if (HTMainText->top_of_screen <= a->line_num) {
          anchors_this_screen = anchors_this_screen + 1;
        }
      }
      if (a->number == number) {
        if ((want_go == 0) && (a->link_type != '\x02')) {
          pcVar1 = LYGetHiTextStr(a,0);
          *hightext = pcVar1;
          me = HTAnchor_followLink(a->anchor);
          if (traversal == '\0') {
            cp_freeme = HTAnchor_address(me);
          }
          else {
            cp_freeme = stub_HTAnchor_address(me);
          }
          HTSACopy(lname,cp_freeme);
          if (cp_freeme != (char *)0x0) {
            free(cp_freeme);
          }
          return 2;
        }
        if (a->show_anchor != '\0') {
          if ((((anchors_this_screen < 1) || (nlinks < anchors_this_screen)) ||
              (a->line_num < HTMainText->top_of_screen)) ||
             (HTMainText->top_of_screen + display_lines <= a->line_num)) {
            max_offset = 3;
            if (display_lines < 4) {
              max_offset = display_lines + -1;
            }
            *go_line = prev_anchor_line - max_offset;
            if (*go_line <= prev_prev_anchor_line) {
              *go_line = prev_prev_anchor_line + 1;
            }
            if (*go_line < 0) {
              *go_line = 0;
            }
            if (linknum != (int *)0x0) {
              *linknum = anchors_this_line + -1;
            }
          }
          else {
            *go_line = HTMainText->top_of_screen;
            if (linknum != (int *)0x0) {
              *linknum = anchors_this_screen + -1;
            }
          }
          return 8;
        }
        return 0;
      }
      a = (TextAnchor *)a->next;
    }
  }
  return 0;
}



BOOLEAN same_anchor_or_field
                  (int numberA,FormInfo *formA,int numberB,FormInfo *formB,BOOLEAN ta_same)

{
  int iVar1;
  bool local_9;
  
  if ((0 < numberA) || (0 < numberB)) {
    if (numberA == numberB) {
      return '\x01';
    }
    if (ta_same == '\0') {
      return '\0';
    }
  }
  if ((formA == (FormInfo *)0x0) && (formB == (FormInfo *)0x0)) {
    local_9 = false;
  }
  else {
    if (formA == formB) {
      local_9 = true;
    }
    else {
      if (ta_same == '\0') {
        local_9 = false;
      }
      else {
        if ((formA == (FormInfo *)0x0) || (formB == (FormInfo *)0x0)) {
          local_9 = false;
        }
        else {
          if (((formA->type == formB->type) && (formA->type == 9)) && (formB->type == 9)) {
            if (formA->number == formB->number) {
              if ((formA->name == (char *)0x0) || (formB->name == (char *)0x0)) {
                local_9 = true;
              }
              else {
                iVar1 = strcmp(formA->name,formB->name);
                local_9 = iVar1 == 0;
              }
            }
            else {
              local_9 = false;
            }
          }
          else {
            local_9 = false;
          }
        }
      }
    }
  }
  return (BOOLEAN)local_9;
}



BOOLEAN HText_TAHasMoreLines(int curlink,int direction)

{
  BOOLEAN BVar1;
  FormInfo *local_30;
  FormInfo *local_28;
  FormInfo *local_20;
  FormInfo *local_18;
  TextAnchor *prev_a;
  TextAnchor *a;
  
  prev_a = (TextAnchor *)0x0;
  if (HTMainText != (HText *)0x0) {
    if (direction < 0) {
      a = HTMainText->first_anchor;
      while (a != (TextAnchor *)0x0) {
        if ((a->link_type == '\x02') && (links[curlink].l_form == (_FormInfo *)a->input_field)) {
          if ((a != (TextAnchor *)0x0) && (prev_a != (TextAnchor *)0x0)) {
            if (prev_a->link_type == '\x02') {
              local_30 = prev_a->input_field;
            }
            else {
              local_30 = (FormInfo *)0x0;
            }
            if (a->link_type == '\x02') {
              local_28 = a->input_field;
            }
            else {
              local_28 = (FormInfo *)0x0;
            }
            BVar1 = same_anchor_or_field(a->number,local_28,prev_a->number,local_30,'\x01');
            if (BVar1 != '\0') {
              return '\x01';
            }
          }
          return '\0';
        }
        if ((links[curlink].anchor_number != 0) && (links[curlink].anchor_number <= a->number)) {
          return '\0';
        }
        prev_a = a;
        a = (TextAnchor *)a->next;
      }
    }
    else {
      a = HTMainText->first_anchor;
      while (a != (TextAnchor *)0x0) {
        if ((a->link_type == '\x02') && (links[curlink].l_form == (_FormInfo *)a->input_field)) {
          if ((a != (TextAnchor *)0x0) && (a->next != (_TextAnchor *)0x0)) {
            if (a->next->link_type == '\x02') {
              local_20 = a->next->input_field;
            }
            else {
              local_20 = (FormInfo *)0x0;
            }
            if (a->link_type == '\x02') {
              local_18 = a->input_field;
            }
            else {
              local_18 = (FormInfo *)0x0;
            }
            BVar1 = same_anchor_or_field(a->number,local_18,a->next->number,local_20,'\x01');
            if (BVar1 != '\0') {
              return '\x01';
            }
          }
          return '\0';
        }
        if ((links[curlink].anchor_number != 0) && (links[curlink].anchor_number <= a->number)) {
          return '\0';
        }
        a = (TextAnchor *)a->next;
      }
    }
  }
  return '\0';
}



int HTGetLinkOrFieldStart(int curlink,int *go_line,int *linknum,int direction,BOOLEAN ta_skip)

{
  TextAnchor *pTVar1;
  BOOLEAN BVar2;
  int local_80;
  FormInfo *local_78;
  FormInfo *local_70;
  FormInfo *local_68;
  _FormInfo *local_60;
  FormInfo *local_58;
  _FormInfo *local_50;
  agroup current;
  agroup previous;
  int screensahead;
  int screensback;
  int max_offset;
  agroup *group_to_go;
  int prev_prev_anchor_line;
  int prev_anchor_line;
  int anchors_this_line;
  TextAnchor *a;
  
  anchors_this_line = 0;
  prev_anchor_line = -1;
  prev_prev_anchor_line = -1;
  group_to_go = (agroup *)0x0;
  if (HTMainText == (HText *)0x0) {
    local_80 = 0;
  }
  else {
    current.anc = (TextAnchor *)0x0;
    previous.anc = (TextAnchor *)0x0;
    current.prev_anchor_line = -1;
    previous.prev_anchor_line = -1;
    current.anchors_this_line = 0;
    previous.anchors_this_line = 0;
    current.anchors_this_group = 0;
    previous.anchors_this_group = 0;
    a = HTMainText->first_anchor;
    while (a != (TextAnchor *)0x0) {
      if ((a->show_anchor != '\0') && ((a->link_type != '\x02' || (a->input_field->type != 8)))) {
        if (a->line_num == prev_anchor_line) {
          anchors_this_line = anchors_this_line + 1;
        }
        else {
          anchors_this_line = 1;
          prev_prev_anchor_line = prev_anchor_line;
          prev_anchor_line = a->line_num;
        }
        if ((current.anc == (TextAnchor *)0x0) || (a == (TextAnchor *)0x0)) {
LAB_0806854c:
          previous.anc = current.anc;
          previous.prev_anchor_line = current.prev_anchor_line;
          previous.anchors_this_line = current.anchors_this_line;
          previous.anchors_this_group = current.anchors_this_group;
          current.anc = a;
          current.prev_anchor_line = prev_prev_anchor_line;
          current.anchors_this_line = anchors_this_line;
          current.anchors_this_group = 1;
        }
        else {
          if (a->link_type == '\x02') {
            local_78 = a->input_field;
          }
          else {
            local_78 = (FormInfo *)0x0;
          }
          if ((current.anc)->link_type == '\x02') {
            local_70 = (current.anc)->input_field;
          }
          else {
            local_70 = (FormInfo *)0x0;
          }
          BVar2 = same_anchor_or_field((current.anc)->number,local_70,a->number,local_78,ta_skip);
          if (BVar2 == '\0') goto LAB_0806854c;
          current.anchors_this_group = current.anchors_this_group + 1;
        }
        if (curlink < 0) {
          if (HTMainText->top_of_screen <= a->line_num) {
            if (direction < 0) {
              group_to_go = &previous;
            }
            else {
              if (direction == 0) {
                if (previous.anc == (TextAnchor *)0x0) {
                  group_to_go = &current;
                }
                else {
                  group_to_go = &previous;
                }
              }
              else {
                group_to_go = &current;
              }
            }
            break;
          }
        }
        else {
          if ((-1 < curlink) && (a != (TextAnchor *)0x0)) {
            if (a->link_type == '\x02') {
              local_68 = a->input_field;
            }
            else {
              local_68 = (FormInfo *)0x0;
            }
            if (links[curlink].type == 1) {
              local_60 = links[curlink].l_form;
            }
            else {
              local_60 = (_FormInfo *)0x0;
            }
            BVar2 = same_anchor_or_field
                              (links[curlink].anchor_number,(FormInfo *)local_60,a->number,local_68,
                               ta_skip);
            if (BVar2 != '\0') {
              if (direction == -1) {
                group_to_go = &previous;
              }
              else {
                if (direction != 0) goto LAB_08068779;
                group_to_go = &current;
              }
              break;
            }
          }
          if (((0 < direction) && (-1 < curlink)) && (previous.anc != (TextAnchor *)0x0)) {
            if ((previous.anc)->link_type == '\x02') {
              local_58 = (previous.anc)->input_field;
            }
            else {
              local_58 = (FormInfo *)0x0;
            }
            if (links[curlink].type == 1) {
              local_50 = links[curlink].l_form;
            }
            else {
              local_50 = (_FormInfo *)0x0;
            }
            BVar2 = same_anchor_or_field
                              (links[curlink].anchor_number,(FormInfo *)local_50,
                               (previous.anc)->number,local_58,ta_skip);
            if (BVar2 != '\0') {
              group_to_go = &current;
              break;
            }
          }
        }
      }
LAB_08068779:
      a = (TextAnchor *)a->next;
    }
    if (((group_to_go == (agroup *)0x0) && (curlink < 0)) && (direction < 1)) {
      group_to_go = &current;
    }
    if ((group_to_go == (agroup *)0x0) || (pTVar1 = group_to_go->anc, pTVar1 == (TextAnchor *)0x0))
    {
      local_80 = 0;
    }
    else {
      if (((pTVar1->line_num < HTMainText->top_of_screen) &&
          (HTMainText->top_of_screen - display_lines <= pTVar1->line_num)) &&
         ((((curlink < 0 && (group_to_go->anchors_this_group == 1)) ||
           ((((direction < 0 && (group_to_go != &current)) && (current.anc != (TextAnchor *)0x0)) &&
            ((HTMainText->top_of_screen <= (current.anc)->line_num &&
             (group_to_go->anchors_this_group == 1)))))) ||
          ((pTVar1->next != (_TextAnchor *)0x0 &&
           (HTMainText->top_of_screen <= pTVar1->next->line_num)))))) {
        local_80 = 0x10;
      }
      else {
        if (display_lines < pTVar1->line_num) {
          if (pTVar1->line_num < HTMainText->top_of_screen) {
            max_offset = pTVar1->line_num +
                         (display_lines *
                          (((HTMainText->top_of_screen - pTVar1->line_num) + display_lines + -1) /
                          display_lines) - HTMainText->top_of_screen);
          }
          else {
            if (display_lines < HTMainText->Lines - pTVar1->line_num) {
              if (pTVar1->line_num < HTMainText->top_of_screen + display_lines) {
                max_offset = 3;
              }
              else {
                max_offset = pTVar1->line_num +
                             (-(display_lines *
                               ((pTVar1->line_num - HTMainText->top_of_screen) / display_lines)) -
                             HTMainText->top_of_screen);
              }
            }
            else {
              max_offset = pTVar1->line_num + ~HTMainText->Lines + display_lines;
            }
          }
        }
        else {
          max_offset = 0;
        }
        if (max_offset < 0) {
          max_offset = 0;
        }
        else {
          if (display_lines <= max_offset) {
            max_offset = display_lines + -1;
          }
        }
        *go_line = pTVar1->line_num - max_offset;
        if (*go_line <= group_to_go->prev_anchor_line) {
          *go_line = group_to_go->prev_anchor_line + 1;
        }
        if (*go_line < 0) {
          *go_line = 0;
        }
        if (linknum != (int *)0x0) {
          *linknum = group_to_go->anchors_this_line + -1;
        }
        local_80 = 8;
      }
    }
  }
  return local_80;
}



BOOLEAN HText_getFirstTargetInLine
                  (HText *text,int line_num,BOOLEAN utf_flag,int *offset,int *tLen,char **data,
                  char *target)

{
  ushort uVar1;
  char *local_34;
  int local_2c;
  char *cp;
  int i;
  int LenNeeded;
  int HitOffset;
  int LineOffset;
  char *LineData;
  HTLine *line;
  
  if ((((text != (HText *)0x0) && (-1 < line_num)) && (line_num <= text->Lines)) &&
     ((target != (char *)0x0 && (*target != '\0')))) {
    i = 0;
    line = (HTLine *)text->last_line->next;
    while ((i < line_num && (text->last_line != line))) {
      if (line->next == (_line *)0x0) {
        return '\0';
      }
      i = i + 1;
      line = (HTLine *)line->next;
    }
    if ((line != (HTLine *)0x0) || (cRam00000012 == '\0')) {
      uVar1 = line->offset;
      if (case_sensitive == '\0') {
        local_34 = LYno_attr_mbcs_case_strstr
                             (line->data,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
      }
      else {
        local_34 = LYno_attr_mbcs_strstr(line->data,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
      }
      if (local_34 != (char *)0x0) {
        if (LYwideLines == 0) {
          local_2c = LYcols;
        }
        else {
          local_2c = 0x3f6;
        }
        if ((int)((uint)uVar1 + LenNeeded) <= local_2c) {
          *offset = HitOffset + (uint)uVar1;
          *tLen = LenNeeded - HitOffset;
          HTSACopy(data,local_34);
          remove_special_attr_chars(*data);
          return '\x01';
        }
      }
    }
  }
  return '\0';
}



int HText_getNumOfLines(void)

{
  int local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = 0;
  }
  else {
    local_8 = HTMainText->Lines;
  }
  return local_8;
}



int HText_getNumOfBytes(void)

{
  size_t sVar1;
  HTLine *line;
  int result;
  
  result = -1;
  if (HTMainText != (HText *)0x0) {
    line = (HTLine *)HTMainText->last_line->next;
    while (HTMainText->last_line != line) {
      sVar1 = strlen(line->data);
      result = sVar1 + result + 1;
      line = (HTLine *)line->next;
    }
  }
  return result;
}



char * HText_getTitle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_title(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getStyle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_style(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getSugFname(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_SugFname(HTMainText->node_anchor);
  }
  return local_8;
}



void HTCheckFnameForCompression(char **fname,HTParentAnchor *anchor,BOOLEAN strip_ok)

{
  CompressFileType method_00;
  char *a;
  int iVar1;
  CompressFileType CVar2;
  char *src;
  int rootlen;
  CompressFileType second;
  CompressFileType method;
  char *suffix;
  char *cp;
  char *dot;
  char *fn;
  
  if ((((*fname != (char *)0x0) && (anchor != (HTParentAnchor *)0x0)) &&
      (cp = LYPathLeaf(*fname), *cp != '\0')) &&
     ((method_00 = HTContentToCompressType(anchor), method_00 != cftNone || (strip_ok != '\0')))) {
    a = strrchr(cp,0x2e);
    if ((a != (char *)0x0) && (iVar1 = strcasecomp(a,".tgz"), iVar1 == 0)) {
      if (method_00 != cftNone) {
        return;
      }
      memcpy(a,&DAT_0814d991,5);
      return;
    }
    a = strrchr(cp,0x2e);
    if (a != (char *)0x0) {
      rootlen = 0;
      CVar2 = HTCompressFileType(cp,".",&rootlen);
      if (CVar2 != cftNone) {
        if (method_00 != cftNone) {
          return;
        }
        *a = '\0';
        return;
      }
      CVar2 = HTCompressFileType(cp,"-_",&rootlen);
      if (CVar2 != cftNone) {
        cp = cp + rootlen;
        if (method_00 == cftNone) {
          if (a + 1 == cp) {
            cp = cp + -1;
          }
          *cp = '\0';
          return;
        }
        *cp = '.';
        if (CVar2 == cftCompress) {
          LYUpperCase(cp);
          return;
        }
        LYLowerCase(cp);
        return;
      }
    }
    src = HTCompressTypeToSuffix(method_00);
    if (*src != '\0') {
      if (a == (char *)0x0) {
        HTSACat(fname,src);
      }
      else {
        if (a[1] == '\0') {
          HTSACat(fname,src + 1);
        }
        else {
          HTSACat(fname,src);
        }
      }
    }
  }
  return;
}



char * HText_getLastModified(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_last_modified(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getDate(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_date(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getServer(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_server(HTMainText->node_anchor);
  }
  return local_8;
}



void HText_pageDisplay(int line_num,char *target)

{
  FILE *__stream;
  int stop_before;
  
  if (((debug_display_partial != '\0') || (LYTraceLogFP != (FILE *)0x0)) && (WWW_TraceFlag != '\0'))
  {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: HText_pageDisplay at line %d started\n",line_num);
  }
  if (display_partial != '\0') {
    stop_before = -1;
    if ((HTMainText != (HText *)0x0) && (HTMainText->stbl != (STable_info *)0x0)) {
      stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
    }
    HText_trimHightext(HTMainText,'\0',stop_before);
  }
  display_page(HTMainText,line_num + -1,target);
  if ((display_partial != '\0') && (debug_display_partial != '\0')) {
    LYSleepMsg();
  }
  is_www_index = HTAnchor_isIndex(HTMainAnchor);
  if (((debug_display_partial != '\0') || (LYTraceLogFP != (FILE *)0x0)) && (WWW_TraceFlag != '\0'))
  {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: HText_pageDisplay finished\n");
  }
  return;
}



BOOLEAN HText_pageHasPrevTarget(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = HTMainText->page_has_target;
  }
  return local_5;
}



int HText_closestAnchor(HText *text,int offset)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  TextAnchor *closest;
  TextAnchor *Anchor_ptr;
  int newdiff;
  int absdiff;
  int result;
  
  result = -1;
  absdiff = 0;
  closest = (TextAnchor *)0x0;
  Anchor_ptr = text->first_anchor;
  do {
    if (Anchor_ptr == (TextAnchor *)0x0) {
LAB_08069180:
      if ((result < 0) && (closest != (TextAnchor *)0x0)) {
        result = closest->number;
      }
      return result;
    }
    if (Anchor_ptr->sgml_offset == offset) {
      result = Anchor_ptr->number;
      goto LAB_08069180;
    }
    uVar2 = Anchor_ptr->sgml_offset - offset;
    uVar3 = (int)uVar2 >> 0x1f;
    iVar1 = (uVar2 ^ uVar3) - uVar3;
    if ((absdiff == 0) || (iVar1 < absdiff)) {
      closest = Anchor_ptr;
      absdiff = iVar1;
    }
    Anchor_ptr = (TextAnchor *)Anchor_ptr->next;
  } while( true );
}



int HText_locateAnchor(HText *text,int anchor_number)

{
  TextAnchor *Anchor_ptr;
  int result;
  
  Anchor_ptr = text->first_anchor;
  while( true ) {
    if (Anchor_ptr == (TextAnchor *)0x0) {
      return -1;
    }
    if (Anchor_ptr->number == anchor_number) break;
    Anchor_ptr = (TextAnchor *)Anchor_ptr->next;
  }
  return Anchor_ptr->sgml_offset;
}



BOOLEAN anchor_is_numbered(TextAnchor *Anchor_ptr)

{
  BOOLEAN result;
  
  result = '\0';
  if ((Anchor_ptr->show_anchor == '\0') || ((Anchor_ptr->link_type & 1U) != 1)) {
    if ((Anchor_ptr->link_type == '\x02') && (Anchor_ptr->input_field->type != 8)) {
      result = '\x01';
    }
  }
  else {
    result = '\x01';
  }
  return result;
}



int HText_getAbsLineNumber(HText *text,int anchor_number)

{
  BOOLEAN BVar1;
  TextAnchor *Anchor_ptr;
  int result;
  
  if ((-1 < anchor_number) && (text != (HText *)0x0)) {
    Anchor_ptr = text->first_anchor;
    while (Anchor_ptr != (TextAnchor *)0x0) {
      BVar1 = anchor_is_numbered(Anchor_ptr);
      if ((BVar1 != '\0') && (Anchor_ptr->number == anchor_number)) {
        return Anchor_ptr->line_num;
      }
      Anchor_ptr = (TextAnchor *)Anchor_ptr->next;
    }
  }
  return -1;
}



int HText_anchorRelativeTo(HText *text,int top_lineno,int anchor_number)

{
  BOOLEAN BVar1;
  TextAnchor *Anchor_ptr;
  int from_top;
  int result;
  
  from_top = 0;
  Anchor_ptr = text->first_anchor;
  while( true ) {
    if (Anchor_ptr == (TextAnchor *)0x0) {
      return 0;
    }
    if (Anchor_ptr->number == anchor_number) break;
    BVar1 = anchor_is_numbered(Anchor_ptr);
    if ((BVar1 != '\0') && (top_lineno <= Anchor_ptr->line_num)) {
      from_top = from_top + 1;
    }
    Anchor_ptr = (TextAnchor *)Anchor_ptr->next;
  }
  return from_top;
}



int HText_LinksInLines(HText *text,int line_num,int Lines)

{
  int local_18;
  TextAnchor *Anchor_ptr;
  int end;
  int start;
  int total;
  
  total = 0;
  Lines = line_num + -1 + Lines;
  if (text == (HText *)0x0) {
    local_18 = 0;
  }
  else {
    Anchor_ptr = text->first_anchor;
    while ((Anchor_ptr != (TextAnchor *)0x0 && (Anchor_ptr->line_num <= Lines))) {
      if (((line_num + -1 <= Anchor_ptr->line_num) &&
          ((Anchor_ptr->line_num < Lines && (Anchor_ptr->show_anchor != '\0')))) &&
         ((Anchor_ptr->link_type != '\x02' || (Anchor_ptr->input_field->type != 8)))) {
        total = total + 1;
      }
      Anchor_ptr = (TextAnchor *)Anchor_ptr->next;
    }
    local_18 = total;
  }
  return local_18;
}



void HText_setStale(HText *text)

{
  text->stale = '\x01';
  return;
}



void HText_refresh(HText *text)

{
  if (text->stale != '\0') {
    display_page(text,text->top_of_screen,"");
  }
  return;
}



int HText_sourceAnchors(HText *text)

{
  int local_8;
  
  if (text == (HText *)0x0) {
    local_8 = -1;
  }
  else {
    local_8 = text->last_anchor_number;
  }
  return local_8;
}



BOOLEAN HText_canScrollUp(HText *text)

{
  return (BOOLEAN)(text->top_of_screen != 0);
}



BOOLEAN HText_canScrollDown(void)

{
  BOOLEAN local_18;
  HText *text;
  
  if ((HTMainText == (HText *)0x0) ||
     (HTMainText->Lines < HTMainText->top_of_screen + display_lines)) {
    local_18 = '\0';
  }
  else {
    local_18 = '\x01';
  }
  return local_18;
}



void HText_scrollTop(HText *text)

{
  display_page(text,0,"");
  return;
}



void HText_scrollDown(HText *text)

{
  display_page(text,text->top_of_screen + display_lines,"");
  return;
}



void HText_scrollUp(HText *text)

{
  display_page(text,text->top_of_screen - display_lines,"");
  return;
}



void HText_scrollBottom(HText *text)

{
  display_page(text,text->Lines - display_lines,"");
  return;
}



BOOLEAN HText_select(HText *text)

{
  BOOLEAN BVar1;
  
  if (text != HTMainText) {
    if (text != (HText *)0x0) {
      text->page_has_target = '\0';
    }
    ResetPartialLinenos(text);
    ResetPartialLinenos(HTMainText);
    if (HTMainText != (HText *)0x0) {
      BVar1 = HText_hasUTF8OutputSet(HTMainText);
      if (((BVar1 == '\0') || (BVar1 = HTLoadedDocumentEightbit(), BVar1 == '\0')) ||
         (LYCharSet_UC[current_char_set].enc != 7)) {
        text->had_utf8 = '\0';
      }
      else {
        text->had_utf8 = HTMainText->has_utf8;
      }
      HTMainText->has_utf8 = '\0';
      text->has_utf8 = '\0';
    }
    HTMainText = text;
    HTMainAnchor = text->node_anchor;
    if ((loaded_texts != (HTList *)0x0) &&
       (BVar1 = HTList_removeObject(loaded_texts,text), BVar1 != '\0')) {
      HTList_addObject(loaded_texts,text);
    }
    return '\x01';
  }
  return '\x01';
}



BOOLEAN HText_POSTReplyLoaded(DocInfo *doc)

{
  char cVar1;
  bstring *a;
  char *__s1;
  BOOLEAN BVar2;
  int iVar3;
  BOOLEAN local_29;
  int *local_28;
  char *address;
  bstring *post_data;
  HTList *cur;
  HText *text;
  BOOLEAN is_head;
  
  cur = loaded_texts;
  if ((loaded_texts == (HTList *)0x0) || (doc == (DocInfo *)0x0)) {
    local_29 = '\0';
  }
  else {
    a = doc->post_data;
    if ((a == (bstring *)0x0) || (__s1 = doc->address, __s1 == (char *)0x0)) {
      local_29 = '\0';
    }
    else {
      cVar1 = doc->isHEAD;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_28 = (int *)0x0;
        }
        else {
          local_28 = (int *)cur->object;
        }
        if (local_28 == (int *)0x0) {
          return '\0';
        }
      } while ((((*local_28 == 0) || (*(int *)(*local_28 + 0x14) == 0)) ||
               (BVar2 = HTSABEql(a,*(bstring **)(*local_28 + 0x14)), BVar2 == '\0')) ||
              (((*(int *)(*local_28 + 0x10) == 0 ||
                (iVar3 = strcmp(__s1,*(char **)(*local_28 + 0x10)), iVar3 != 0)) ||
               (*(char *)(*local_28 + 0x55) != cVar1))));
      local_29 = '\x01';
    }
  }
  return local_29;
}



BOOLEAN HTFindPoundSelector(char *selector)

{
  int iVar1;
  FILE *__stream;
  int iVar2;
  TextAnchor *a;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"FindPound: searching for \"%s\"\n",selector);
  }
  a = HTMainText->first_anchor;
  while( true ) {
    if (a == (TextAnchor *)0x0) {
      return '\0';
    }
    if (((a->anchor != (HTChildAnchor *)0x0) && (a->anchor->tag != (char *)0x0)) &&
       (iVar2 = strcmp(a->anchor->tag,selector), iVar2 == 0)) break;
    a = (TextAnchor *)a->next;
  }
  iVar2 = a->line_num + 1;
  www_search_result = iVar2;
  if (WWW_TraceFlag != '\0') {
    iVar1 = a->number;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"FindPound: Selecting anchor [%d] at line %d\n",iVar1,iVar2);
  }
  iVar2 = strcmp(selector,LYToolbarName);
  if (iVar2 == 0) {
    www_search_result = www_search_result + -1;
  }
  return '\x01';
}



BOOLEAN HText_selectAnchor(HText *text,HTChildAnchor *anchor)

{
  int iVar1;
  int iVar2;
  FILE *__stream;
  BOOLEAN local_19;
  int l;
  TextAnchor *a;
  
  a = text->first_anchor;
  while ((a != (TextAnchor *)0x0 && (a->anchor != anchor))) {
    a = (TextAnchor *)a->next;
  }
  if (a == (TextAnchor *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HText: No such anchor in this text!\n");
    }
    local_19 = '\0';
  }
  else {
    if (text != HTMainText) {
      HTMainText = text;
      HTMainAnchor = text->node_anchor;
    }
    iVar1 = a->line_num;
    if (WWW_TraceFlag != '\0') {
      iVar2 = a->number;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HText: Selecting anchor [%d] at line %d\n",iVar2,iVar1);
    }
    if (((text->stale == '\0') && (text->top_of_screen <= iVar1)) &&
       (iVar1 < text->top_of_screen + display_lines + 1)) {
      local_19 = '\x01';
    }
    else {
      www_search_result = iVar1 - display_lines / 3;
      local_19 = '\x01';
    }
  }
  return local_19;
}



void HText_applyStyle(HText *me,HTStyle *style)

{
  return;
}



void HText_updateStyle(HText *me,HTStyle *style)

{
  return;
}



HTStyle * HText_selectionStyle(HText *me,HTStyleSheet *sheet)

{
  return (HTStyle *)0x0;
}



void HText_replaceSel(HText *me,char *aString,HTStyle *aStyle)

{
  return;
}



void HTextApplyToSimilar(HText *me,HTStyle *style)

{
  return;
}



void HTextSelectUnstyled(HText *me,HTStyleSheet *sheet)

{
  return;
}



void HText_unlinkSelection(HText *me)

{
  return;
}



HTAnchor * HText_referenceSelected(HText *me)

{
  return (HTAnchor *)0x0;
}



int HText_getTopOfScreen(void)

{
  int local_18;
  HText *text;
  
  if (HTMainText == (HText *)0x0) {
    local_18 = 0;
  }
  else {
    local_18 = HTMainText->top_of_screen;
  }
  return local_18;
}



int HText_getLines(HText *text)

{
  return text->Lines;
}



int HText_getPreferredTopLine(HText *text,int line_number)

{
  int iVar1;
  int last_screen;
  
  if (text->Lines < display_lines) {
    line_number = 0;
    iVar1 = line_number;
  }
  else {
    iVar1 = text->Lines + (2 - display_lines);
    if ((line_number <= text->Lines) && (iVar1 = line_number, line_number < 0)) {
      line_number = 0;
      iVar1 = line_number;
    }
  }
  line_number = iVar1;
  return line_number;
}



HTAnchor * HText_linkSelTo(HText *me,HTAnchor *anchor)

{
  return (HTAnchor *)0x0;
}



void HTSearchQueries_free(void)

{
  LYFreeStringList(search_queries);
  search_queries = (HTList *)0x0;
  return;
}



void HTAddSearchQuery(char *query)

{
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *new_query;
  
  new_query = (char *)0x0;
  if ((query != (char *)0x0) && (*query != '\0')) {
    HTSACopy(&new_query,query);
    if (search_queries == (HTList *)0x0) {
      search_queries = HTList_new();
      HTList_addObject(search_queries,new_query);
    }
    else {
      cur = search_queries;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) goto LAB_08069b4b;
        iVar1 = strcmp(local_18,new_query);
      } while (iVar1 != 0);
      HTList_removeObject(search_queries,local_18);
      if (local_18 != (char *)0x0) {
        free(local_18);
      }
LAB_08069b4b:
      HTList_addObject(search_queries,new_query);
    }
  }
  return;
}



int do_www_search(DocInfo *doc)

{
  bool bVar1;
  char *argument;
  BOOLEAN BVar2;
  char *text;
  int iVar3;
  char *message;
  FILE *__stream;
  int in_GS_OFFSET;
  int local_248;
  RecallType local_244;
  int local_240;
  char *cp_freeme;
  int QueryNum;
  int QueryTotal;
  RecallType recall;
  int ch;
  char *tmpaddress;
  char *cp;
  BOOLEAN PreviousSearch;
  char temp [256];
  char searchstring [256];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  tmpaddress = (char *)0x0;
  bVar1 = false;
  text = strchr(doc->address,0x3f);
  if (text == (char *)0x0) {
    searchstring[0] = '\0';
    temp[0] = '\0';
  }
  else {
    bVar1 = true;
    LYstrncpy(searchstring,text + 1,0xff);
    cp = searchstring;
    while (*cp != '\0') {
      if (*cp == '+') {
        *cp = ' ';
      }
      cp = cp + 1;
    }
    HTUnEscape(searchstring);
    strcpy(temp,searchstring);
    HTAddSearchQuery(searchstring);
  }
  if (searchstring[0] == '\0') {
    if (HTMainAnchor->isIndexPrompt == (char *)0x0) {
      mustshow = '\x01';
      text = (char *)gettext("Enter a database query: ");
      statusline(text);
    }
    else {
      mustshow = '\x01';
      statusline(HTMainAnchor->isIndexPrompt);
    }
  }
  else {
    mustshow = '\x01';
    text = (char *)gettext("Edit the current query: ");
    statusline(text);
  }
  if (search_queries == (HTList *)0x0) {
    local_248 = 0;
  }
  else {
    local_248 = HTList_count(search_queries);
  }
  if (((bVar1) && (1 < local_248)) || ((!bVar1 && (0 < local_248)))) {
    local_244 = RECALL_URL;
  }
  else {
    local_244 = NORECALL;
  }
  QueryNum = local_248;
  while( true ) {
    while( true ) {
      iVar3 = LYgetstr(searchstring,0,0x100,local_244);
      if ((((-1 < iVar3) && (searchstring[0] != '\0')) && (iVar3 != 0x100)) && (iVar3 != 0x101)) {
        LYTrimLeading(searchstring);
        if (searchstring[0] == '\0') {
          text = (char *)gettext("Cancelled!!!");
          HTInfoMsg(text);
          local_240 = 3;
        }
        else {
          LYTrimTrailing(searchstring);
          if ((LYforce_no_cache == '\0') && (iVar3 = strcmp(temp,searchstring), iVar3 == 0)) {
            text = (char *)gettext("Use Control-R to resubmit the current query.");
            HTUserMsg(text);
            local_240 = 3;
          }
          else {
            HTAddSearchQuery(searchstring);
            text = strchr(doc->address,0x3f);
            if (text != (char *)0x0) {
              *text = '\0';
            }
            HTSACopy(&tmpaddress,doc->address);
            HTSACat(&tmpaddress,"?");
            HTSACat(&tmpaddress,searchstring);
            argument = tmpaddress;
            message = (char *)gettext("Getting %s");
            user_message(message,argument);
            LYSyslog(tmpaddress);
            if (tmpaddress != (char *)0x0) {
              free(tmpaddress);
              tmpaddress = (char *)0x0;
            }
            if (text != (char *)0x0) {
              *text = '?';
            }
            BVar2 = HTSearch(searchstring,HTMainAnchor);
            if (BVar2 == '\0') {
              local_240 = 0;
            }
            else {
              if (traversal == '\0') {
                cp_freeme = HTAnchor_address((HTAnchor *)HTMainAnchor);
              }
              else {
                cp_freeme = stub_HTAnchor_address((HTAnchor *)HTMainAnchor);
              }
              HTSACopy(&doc->address,cp_freeme);
              if (cp_freeme != (char *)0x0) {
                free(cp_freeme);
              }
              if (WWW_TraceFlag != '\0') {
                text = doc->address;
                __stream = TraceFP();
                fprintf((FILE *)__stream,"\ndo_www_search: newfile: %s\n",text);
              }
              local_240 = 1;
            }
          }
        }
        goto LAB_0806a2d6;
      }
      if ((local_244 == NORECALL) || (iVar3 != 0x100)) break;
      if (bVar1) {
        QueryNum = 1;
        bVar1 = false;
      }
      else {
        QueryNum = QueryNum + 1;
      }
      if (local_248 <= QueryNum) {
        QueryNum = 0;
      }
      text = (char *)HTList_objectAt(search_queries,QueryNum);
      if (text == (char *)0x0) goto LAB_0806a05a;
      LYstrncpy(searchstring,text,0xff);
      if ((temp[0] == '\0') || (iVar3 = strcmp(temp,searchstring), iVar3 != 0)) {
        if (((temp[0] == '\0') || (local_248 != 2)) && ((temp[0] != '\0' || (local_248 != 1)))) {
          mustshow = '\x01';
          text = (char *)gettext("Edit a previous query: ");
          statusline(text);
        }
        else {
          mustshow = '\x01';
          text = (char *)gettext("Edit the previous query: ");
          statusline(text);
        }
      }
      else {
        mustshow = '\x01';
        text = (char *)gettext("Edit the current query: ");
        statusline(text);
      }
    }
    if ((local_244 == NORECALL) || (iVar3 != 0x101)) break;
    if (bVar1) {
      bVar1 = false;
      QueryNum = local_248;
    }
    QueryNum = QueryNum + -1;
    if (QueryNum < 0) {
      QueryNum = local_248 + -1;
    }
    text = (char *)HTList_objectAt(search_queries,QueryNum);
    if (text == (char *)0x0) break;
    LYstrncpy(searchstring,text,0xff);
    if ((temp[0] == '\0') || (iVar3 = strcmp(temp,searchstring), iVar3 != 0)) {
      if (((temp[0] == '\0') || (local_248 != 2)) && ((temp[0] != '\0' || (local_248 != 1)))) {
        mustshow = '\x01';
        text = (char *)gettext("Edit a previous query: ");
        statusline(text);
      }
      else {
        mustshow = '\x01';
        text = (char *)gettext("Edit the previous query: ");
        statusline(text);
      }
    }
    else {
      mustshow = '\x01';
      text = (char *)gettext("Edit the current query: ");
      statusline(text);
    }
  }
LAB_0806a05a:
  text = (char *)gettext("Cancelled!!!");
  HTInfoMsg(text);
  local_240 = 3;
LAB_0806a2d6:
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_240;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void write_offset(FILE *fp,HTLine *line)

{
  int i;
  
  if (line->data[0] != '\0') {
    i = 0;
    while (i < (int)(uint)line->offset) {
      fputc(0x20,(FILE *)fp);
      i = i + 1;
    }
  }
  return;
}



void write_hyphen(FILE *fp)

{
  bool bVar1;
  
  if (((dump_output_immediately != '\0') && (LYRawMode != '\0')) &&
     (LYlowest_eightbit[current_char_set] < 0xae)) {
    if ((LYCharSet_UC[current_char_set].enc == 2) ||
       (((&LYCharSet_UC[0].codepage)[(current_char_set * 2 + 1) * 4] & 0x80U) != 0)) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
    if (bVar1) {
      fputc(0xad,(FILE *)fp);
      return;
    }
  }
  fputc(0x2d,(FILE *)fp);
  return;
}



int TrimmedLength(char *string)

{
  byte bVar1;
  char cVar2;
  int iVar3;
  ushort **ppuVar4;
  char *src;
  char *dst;
  uint ch;
  int adjust;
  int result;
  
  result = strlen(string);
  iVar3 = HTisDocumentSource();
  adjust = result;
  if (iVar3 == 0) {
    while (0 < adjust) {
      bVar1 = string[adjust + -1];
      ppuVar4 = __ctype_b_loc();
      if ((((*ppuVar4)[bVar1] & 0x2000) == 0) && ((bVar1 < 3 || (8 < bVar1)))) break;
      adjust = adjust + -1;
    }
    if (result != adjust) {
      src = string + adjust;
      dst = src;
      do {
        src = LYSkipBlanks(src);
        *dst = *src;
        cVar2 = *dst;
        dst = dst + 1;
        src = src + 1;
      } while (cVar2 != '\0');
      result = (int)(dst + (-1 - (int)string));
    }
  }
  return result;
}



void print_wwwfile_to_fd(FILE *fp,BOOLEAN is_email,BOOLEAN is_reply)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  uint __c;
  int local_30;
  int ch;
  HText *text;
  HTLine *line;
  int limit;
  int first;
  BOOLEAN bs;
  BOOLEAN in_u;
  BOOLEAN in_b;
  
  bVar3 = true;
  bVar4 = false;
  bVar5 = false;
  if (((((is_email == '\0') && (is_reply == '\0')) && (HTMainText != (HText *)0x0)) &&
      ((with_backspaces != '\0' && (HTCJK == NOCJK)))) && ((HTMainText->T).output_utf8 == '\0')) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  if (HTMainText != (HText *)0x0) {
    line = (HTLine *)HTMainText->last_line->next;
    while( true ) {
      if (bVar3) {
        bVar3 = false;
        if (is_reply == '\0') {
          if ((is_email != '\0') && (iVar6 = strncmp(line->data,"From ",5), iVar6 == 0)) {
            fputc(0x3e,(FILE *)fp);
          }
        }
        else {
          fputc(0x3e,(FILE *)fp);
        }
      }
      else {
        if (line->data[0] != '\b') {
          fputc(10,(FILE *)fp);
          if (is_reply == '\0') {
            if ((is_email != '\0') && (iVar6 = strncmp(line->data,"From ",5), iVar6 == 0)) {
              fputc(0x3e,(FILE *)fp);
            }
          }
          else {
            fputc(0x3e,(FILE *)fp);
          }
        }
      }
      write_offset(fp,line);
      iVar6 = TrimmedLength(line->data);
      local_30 = 0;
      while (local_30 < iVar6) {
        bVar1 = line->data[local_30];
        __c = (uint)bVar1;
        if ((bVar1 < 3) || (8 < bVar1)) {
          if (bVar4) {
            fputc(__c,(FILE *)fp);
            fputc(8,(FILE *)fp);
            fputc(__c,(FILE *)fp);
          }
          else {
            if (bVar5) {
              fputc(0x5f,(FILE *)fp);
              fputc(8,(FILE *)fp);
              fputc(__c,(FILE *)fp);
            }
            else {
              fputc(__c,(FILE *)fp);
            }
          }
        }
        else {
          if ((bVar1 == 7) && (iVar6 <= local_30 + 1)) {
            write_hyphen(fp);
          }
          else {
            if ((dump_output_immediately == '\0') || (use_underscore == '\0')) {
              if (bVar2) {
                if (bVar1 == 4) {
                  bVar5 = false;
                }
                else {
                  if (bVar1 < 5) {
                    if ((bVar1 == 3) && (!bVar4)) {
                      bVar5 = true;
                    }
                  }
                  else {
                    if (bVar1 == 5) {
                      if (bVar5) {
                        bVar5 = false;
                      }
                      bVar4 = true;
                    }
                    else {
                      if (bVar1 == 6) {
                        bVar4 = false;
                      }
                    }
                  }
                }
              }
            }
            else {
              if (__c - 3 < 2) {
                fputc(0x5f,(FILE *)fp);
              }
            }
          }
        }
        local_30 = local_30 + 1;
      }
      if (HTMainText->last_line == line) break;
      line = (HTLine *)line->next;
    }
    fputc(10,(FILE *)fp);
  }
  return;
}



void print_crawl_to_fd(FILE *fp,char *thelink,char *thetitle)

{
  byte bVar1;
  bool bVar2;
  int iVar3;
  int local_18;
  int ch;
  HTLine *line;
  int limit;
  int first;
  
  bVar2 = true;
  if (HTMainText != (HText *)0x0) {
    line = (HTLine *)HTMainText->last_line->next;
    fprintf((FILE *)fp,"THE_URL:%s\n",thelink);
    if (thetitle != (char *)0x0) {
      fprintf((FILE *)fp,"THE_TITLE:%s\n",thetitle);
    }
    while( true ) {
      if ((!bVar2) && (line->data[0] != '\b')) {
        fputc(10,(FILE *)fp);
      }
      bVar2 = false;
      write_offset(fp,line);
      iVar3 = TrimmedLength(line->data);
      local_18 = 0;
      while (local_18 < iVar3) {
        bVar1 = line->data[local_18];
        if ((bVar1 < 3) || (8 < bVar1)) {
          fputc((uint)bVar1,(FILE *)fp);
        }
        else {
          if ((bVar1 == 7) && (iVar3 <= local_18 + 1)) {
            write_hyphen(fp);
          }
        }
        local_18 = local_18 + 1;
      }
      if (HTMainText->last_line == line) break;
      line = (HTLine *)line->next;
    }
    fputc(10,(FILE *)fp);
    if ((no_list == '\0') && ((keypad_mode == 1 || (keypad_mode == 2)))) {
      printlist(fp,'\0');
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0806a9c7)

void adjust_search_result(DocInfo *doc,int tentative_result,int start_line)

{
  bool bVar1;
  int i;
  int max_offset;
  int goal;
  int nl_closest;
  TextAnchor *a;
  int anch_line;
  BOOLEAN on_screen;
  
  if (0 < tentative_result) {
    anch_line = -1;
    nl_closest = -1;
    goal = 4;
    if ((HTMainText->top_of_screen < tentative_result) &&
       (tentative_result <= HTMainText->top_of_screen + display_lines)) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
    if (display_lines < 4) {
      goal = display_lines;
    }
    www_search_result = goal + -1;
    if ((bVar1) && (0 < nlinks)) {
      i = 0;
      while (i < nlinks) {
        if (doc->line + links[i].ly + -1 <= tentative_result) {
          nl_closest = i;
        }
        if (tentative_result <= doc->line + links[i].ly + -1) break;
        i = i + 1;
      }
      if ((-1 < nl_closest) && (doc->line + links[nl_closest].ly + -1 == tentative_result)) {
        www_search_result = doc->line;
        doc->link = nl_closest;
        return;
      }
    }
    a = HTMainText->first_anchor;
    while ((a != (TextAnchor *)0x0 && (a->line_num <= tentative_result + -1))) {
      anch_line = a->line_num + 1;
      a = (TextAnchor *)a->next;
    }
    if (((anch_line < 0) || (anch_line < tentative_result - www_search_result)) ||
       ((anch_line <= start_line && (HTMainText->top_of_screen < tentative_result)))) {
      if ((tentative_result == start_line || tentative_result - start_line < 0) ||
         (www_search_result < ~start_line + tentative_result)) {
        if ((HTMainText->top_of_screen < tentative_result) &&
           ((tentative_result <= start_line &&
            (tentative_result <= HTMainText->top_of_screen + goal)))) {
          www_search_result = HTMainText->top_of_screen + 1;
        }
        else {
          if (goal < tentative_result) {
            www_search_result = tentative_result - www_search_result;
          }
          else {
            www_search_result = 1;
          }
        }
      }
      else {
        www_search_result = start_line + 1;
      }
    }
    else {
      www_search_result = anch_line;
    }
    if ((doc->line == www_search_result) && (-1 < nl_closest)) {
      doc->link = nl_closest;
    }
  }
  return;
}



BOOLEAN anchor_has_target(TextAnchor *a,char *target)

{
  char *chptr;
  int count;
  char *cp;
  char *sp;
  char *stars;
  OptionType *option;
  
  stars = (char *)0x0;
  count = 0;
  while (chptr = LYGetHiTextStr(a,count), chptr != (char *)0x0) {
    if (case_sensitive == '\0') {
      chptr = LYno_attr_char_case_strstr(chptr,target);
    }
    else {
      chptr = LYno_attr_char_strstr(chptr,target);
    }
    if (chptr != (char *)0x0) {
      return '\x01';
    }
    count = count + 1;
  }
  if (((a->input_field != (FormInfo *)0x0) && (a->input_field->value != (char *)0x0)) &&
     (a->input_field->type != 8)) {
    if (a->input_field->type == 2) {
      if (case_sensitive == '\0') {
        chptr = LYno_attr_char_case_strstr(a->input_field->value,target);
      }
      else {
        chptr = LYno_attr_char_strstr(a->input_field->value,target);
      }
      if (chptr != (char *)0x0) {
        return '\x01';
      }
      HTSACopy(&stars,a->input_field->value);
      sp = stars;
      while (*sp != '\0') {
        *sp = '*';
        sp = sp + 1;
      }
      if (case_sensitive == '\0') {
        chptr = LYno_attr_char_case_strstr(stars,target);
      }
      else {
        chptr = LYno_attr_char_strstr(stars,target);
      }
      if (chptr != (char *)0x0) {
        if (stars != (char *)0x0) {
          free(stars);
        }
        return '\x01';
      }
      if (stars != (char *)0x0) {
        free(stars);
      }
    }
    else {
      if (a->input_field->type == 7) {
        option = a->input_field->select_list;
        while (option != (OptionType *)0x0) {
          if (case_sensitive == '\0') {
            chptr = LYno_attr_char_case_strstr(option->name,target);
          }
          else {
            chptr = LYno_attr_char_strstr(option->name,target);
          }
          if (chptr != (char *)0x0) {
            return '\x01';
          }
          option = (OptionType *)option->next;
        }
      }
      else {
        if (a->input_field->type == 4) {
          if (a->input_field->num_value == 0) {
            cp = unchecked_radio;
          }
          else {
            cp = checked_radio;
          }
          if (case_sensitive == '\0') {
            chptr = LYno_attr_char_case_strstr(cp,target);
          }
          else {
            chptr = LYno_attr_char_strstr(cp,target);
          }
          if (chptr != (char *)0x0) {
            return '\x01';
          }
        }
        else {
          if (a->input_field->type == 3) {
            if (a->input_field->num_value == 0) {
              cp = unchecked_box;
            }
            else {
              cp = checked_box;
            }
            if (case_sensitive == '\0') {
              chptr = LYno_attr_char_case_strstr(cp,target);
            }
            else {
              chptr = LYno_attr_char_strstr(cp,target);
            }
            if (chptr != (char *)0x0) {
              return '\x01';
            }
          }
          else {
            if (case_sensitive == '\0') {
              chptr = LYno_attr_char_case_strstr(a->input_field->value,target);
            }
            else {
              chptr = LYno_attr_char_strstr(a->input_field->value,target);
            }
            if (chptr != (char *)0x0) {
              return '\x01';
            }
          }
        }
      }
    }
  }
  return '\0';
}



TextAnchor * line_num_to_anchor(int line_num)

{
  TextAnchor *a;
  
  if (HTMainText == (HText *)0x0) {
    a = (TextAnchor *)0x0;
  }
  else {
    a = HTMainText->first_anchor;
    while ((a != (TextAnchor *)0x0 && (a->line_num < line_num))) {
      a = (TextAnchor *)a->next;
    }
  }
  return a;
}



int line_num_in_text(HText *text,HTLine *line)

{
  HTLine *temp;
  int result;
  
  result = 1;
  temp = (HTLine *)text->last_line->next;
  while (temp != line) {
    temp = (HTLine *)temp->next;
    result = result + 1;
  }
  return result;
}



TextAnchor * get_prev_anchor(TextAnchor *a)

{
  _TextAnchor *p_Var1;
  TextAnchor *q;
  TextAnchor *p;
  
  if ((a->prev == (_TextAnchor *)0x0) && (p = HTMainText->first_anchor, p != (TextAnchor *)0x0)) {
    while (p_Var1 = p->next, p_Var1 != (_TextAnchor *)0x0) {
      *(TextAnchor **)&p_Var1->prev = p;
      p = (TextAnchor *)p_Var1;
    }
  }
  return (TextAnchor *)a->prev;
}



int www_search_forward(int start_line,DocInfo *doc,char *target,HTLine *line,int count)

{
  BOOLEAN BVar1;
  char *Msg2;
  bool local_15;
  int tentative_result;
  TextAnchor *a;
  int wrapped;
  
  wrapped = 0;
  a = line_num_to_anchor(count + -1);
  while( true ) {
    while ((a != (TextAnchor *)0x0 && (a->line_num == count + -1))) {
      if ((a->show_anchor != '\0') &&
         (((a->link_type != '\x02' || (a->input_field->type != 8)) &&
          (BVar1 = anchor_has_target(a,target), BVar1 != '\0')))) {
        adjust_search_result(doc,count,start_line);
        return 1;
      }
      a = (TextAnchor *)a->next;
    }
    if (case_sensitive == '\0') {
      Msg2 = LYno_attr_char_case_strstr(line->data,target);
    }
    else {
      Msg2 = LYno_attr_char_strstr(line->data,target);
    }
    local_15 = Msg2 != (char *)0x0;
    if (local_15) break;
    if (((count == start_line) && (wrapped != 0)) || (1 < wrapped)) {
      Msg2 = (char *)gettext("\'%s\' not found!");
      HTUserMsg2(Msg2,target);
      return -1;
    }
    if (HTMainText->last_line == line) {
      count = 0;
      wrapped = wrapped + 1;
    }
    line = (HTLine *)line->next;
    count = count + 1;
  }
  if (0 < count) {
    adjust_search_result(doc,count,start_line);
  }
  return 0;
}



int www_search_backward(int start_line,DocInfo *doc,char *target,HTLine *line,int count)

{
  BOOLEAN BVar1;
  char *Msg2;
  bool local_15;
  int tentative_result;
  TextAnchor *a;
  int wrapped;
  
  wrapped = 0;
  a = line_num_to_anchor(count + -1);
  while( true ) {
    while ((a != (TextAnchor *)0x0 && (a->line_num == count + -1))) {
      if ((a->show_anchor != '\0') &&
         (((a->link_type != '\x02' || (a->input_field->type != 8)) &&
          (BVar1 = anchor_has_target(a,target), BVar1 != '\0')))) {
        adjust_search_result(doc,count,start_line);
        return 1;
      }
      a = get_prev_anchor(a);
    }
    if (case_sensitive == '\0') {
      Msg2 = LYno_attr_char_case_strstr(line->data,target);
    }
    else {
      Msg2 = LYno_attr_char_strstr(line->data,target);
    }
    local_15 = Msg2 != (char *)0x0;
    if (local_15) break;
    if (((count == start_line) && (wrapped != 0)) || (1 < wrapped)) {
      Msg2 = (char *)gettext("\'%s\' not found!");
      HTUserMsg2(Msg2,target);
      return -1;
    }
    if (HTMainText->last_line->next == (_line *)line) {
      count = line_num_in_text(HTMainText,HTMainText->last_line);
      count = count + 1;
      wrapped = wrapped + 1;
    }
    line = (HTLine *)line->prev;
    count = count + -1;
  }
  if (0 < count) {
    adjust_search_result(doc,count,start_line);
  }
  return 0;
}



void www_user_search(int start_line,DocInfo *doc,char *target,int direction)

{
  int count;
  HTLine *line;
  
  if (HTMainText != (HText *)0x0) {
    line = (HTLine *)HTMainText->last_line->next;
    if (start_line + direction < 1) {
      line = HTMainText->last_line;
      count = line_num_in_text(HTMainText,line);
    }
    else {
      count = 1;
      while (count < start_line + direction) {
        if (HTMainText->last_line == line) {
          line = (HTLine *)HTMainText->last_line->next;
          count = 1;
          break;
        }
        line = (HTLine *)line->next;
        count = count + 1;
      }
    }
    if (direction < 0) {
      www_search_backward(start_line,doc,target,line,count);
    }
    else {
      www_search_forward(start_line,doc,target,line,count);
    }
  }
  return;
}



void user_message(char *message,char *argument)

{
  char *local_18;
  char *temp;
  
  if (message == (char *)0x0) {
    mustshow = '\0';
  }
  else {
    temp = (char *)0x0;
    if (argument == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = argument;
    }
    HTSprintf0(&temp,message,local_18);
    statusline(temp);
    if (temp != (char *)0x0) {
      free(temp);
    }
  }
  return;
}



char * HText_getOwner(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_owner(HTMainText->node_anchor);
  }
  return local_8;
}



void HText_setMainTextOwner(char *owner)

{
  if (HTMainText != (HText *)0x0) {
    HTAnchor_setOwner(HTMainText->node_anchor,owner);
  }
  return;
}



char * HText_getRevTitle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_RevTitle(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getContentBase(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_content_base(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getContentLocation(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_content_location(HTMainText->node_anchor);
  }
  return local_8;
}



char * HText_getMessageID(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_messageID(HTMainText->node_anchor);
  }
  return local_8;
}



void HTuncache_current_document(void)

{
  HTParentAnchor *pHVar1;
  FILE *__stream;
  char *local_1c;
  char *local_18;
  HTParentAnchor *htmain_anchor;
  
  if (HTMainText == (HText *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTuncache.. HTMainText already is NULL!\n");
    }
  }
  else {
    pHVar1 = HTMainText->node_anchor;
    if ((pHVar1 != (HTParentAnchor *)0x0) &&
       (((HTOutputFormat == (HTFormat)0x0 || (HTOutputFormat != (HTFormat)WWW_SOURCE)) &&
        (pHVar1->UCStages != (UCAnchorInfo *)0x0)))) {
      free(pHVar1->UCStages);
      pHVar1->UCStages = (UCAnchorInfo *)0x0;
    }
    if (WWW_TraceFlag != '\0') {
      if ((pHVar1 == (HTParentAnchor *)0x0) || (pHVar1->post_data == (bstring *)0x0)) {
        local_1c = "";
      }
      else {
        local_1c = " with POST data";
      }
      if ((pHVar1 == (HTParentAnchor *)0x0) || (pHVar1->address == (char *)0x0)) {
        local_18 = "unknown anchor";
      }
      else {
        local_18 = pHVar1->address;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\nHTuncache.. freeing document for \'%s\'%s\n",local_18,local_1c);
    }
    HTList_removeObject(loaded_texts,HTMainText);
    HText_free(HTMainText);
    HTMainText = (HText *)0x0;
  }
  return;
}



BOOLEAN useSourceCache(void)

{
  FILE *__stream;
  undefined *local_18;
  BOOLEAN result;
  
  result = '\0';
  if ((LYCacheSource == 1) &&
     (result = HTMainAnchor->source_cache_file != (char *)0x0, WWW_TraceFlag != '\0')) {
    if ((bool)result) {
      local_18 = &DAT_0814cbac;
    }
    else {
      local_18 = &DAT_0814dbf6;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SourceCache: file-cache%s found\n",local_18);
  }
  return result;
}



BOOLEAN useMemoryCache(void)

{
  FILE *__stream;
  undefined *local_18;
  BOOLEAN result;
  
  result = '\0';
  if ((LYCacheSource == 2) &&
     (result = HTMainAnchor->source_cache_chunk != (HTChunk *)0x0, WWW_TraceFlag != '\0')) {
    if ((bool)result) {
      local_18 = &DAT_0814cbac;
    }
    else {
      local_18 = &DAT_0814dbf6;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SourceCache: memory-cache%s found\n",local_18);
  }
  return result;
}



BOOLEAN HTreparse_document(void)

{
  HTChunk *pHVar1;
  BOOLEAN BVar2;
  FILE *fp_00;
  HTFormat format_00;
  int iVar3;
  char *Msg;
  HTAtom *format_01;
  BOOLEAN local_35;
  char local_34;
  char *local_30;
  char *local_2c;
  int ret_1;
  HTFormat format_1;
  int ret;
  HTFormat format;
  FILE *fp;
  BOOLEAN ok;
  
  ok = '\0';
  if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYCacheSource == 0)) {
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"HTreparse_document returns FALSE\n");
    }
    local_35 = '\0';
  }
  else {
    BVar2 = useSourceCache();
    if (BVar2 == '\0') {
      BVar2 = useMemoryCache();
      if (BVar2 != '\0') {
        format_01 = HTAtom_for("text/html");
        if (WWW_TraceFlag != '\0') {
          pHVar1 = HTMainAnchor->source_cache_chunk;
          fp_00 = TraceFP();
          fprintf((FILE *)fp_00,"SourceCache: Reparsing from memory chunk %p\n",pHVar1);
        }
        if (((HTOutputFormat == (HTFormat)0x0) || (HTOutputFormat != (HTFormat)WWW_SOURCE)) &&
           (HTMainAnchor->UCStages != (UCAnchorInfo *)0x0)) {
          free(HTMainAnchor->UCStages);
          HTMainAnchor->UCStages = (UCAnchorInfo *)0x0;
        }
        if (HTMainAnchor->content_type == (char *)0x0) {
          format_1 = HTCharsetFormat((HTFormat)format_01,HTMainAnchor,UCLYhndl_for_unspec);
        }
        else {
          format_1 = (HTFormat)HTAtom_for(HTMainAnchor->content_type);
        }
        BVar2 = HText_HaveUserChangedForms(HTMainText);
        if (BVar2 != '\0') {
          Msg = (char *)gettext("Reloading document.  Any form entries will be lost!");
          HTAlert(Msg);
        }
        HTAnchor_setProtocol(HTMainAnchor,&scm);
        iVar3 = HTParseMem(format_1,HTOutputFormat,HTMainAnchor,HTMainAnchor->source_cache_chunk,
                           (HTStream *)0x0);
        ok = iVar3 == 200;
        if (WWW_TraceFlag != '\0') {
          if ((bool)ok) {
            local_2c = "succeeded";
          }
          else {
            local_2c = "failed";
          }
          fp_00 = TraceFP();
          fprintf((FILE *)fp_00,"Reparse memory %s\n",local_2c);
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        Msg = HTMainAnchor->source_cache_file;
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"SourceCache: Reparsing file %s\n",Msg);
      }
      if (((HTOutputFormat == (HTFormat)0x0) || (HTOutputFormat != (HTFormat)WWW_SOURCE)) &&
         (HTMainAnchor->UCStages != (UCAnchorInfo *)0x0)) {
        free(HTMainAnchor->UCStages);
        HTMainAnchor->UCStages = (UCAnchorInfo *)0x0;
      }
      if (HTMainAnchor->content_type == (char *)0x0) {
        format_00 = HTFileFormat(HTMainAnchor->source_cache_file,(HTAtom **)0x0,(char **)0x0);
        format = HTCharsetFormat(format_00,HTMainAnchor,UCLYhndl_for_unspec);
      }
      else {
        format = (HTFormat)HTAtom_for(HTMainAnchor->content_type);
      }
      if (WWW_TraceFlag != '\0') {
        Msg = format->name;
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"  Content type is \"%s\"\n",Msg);
      }
      fp_00 = (FILE *)fopen64(HTMainAnchor->source_cache_file,"r");
      if (fp_00 == (FILE *)0x0) {
        if (WWW_TraceFlag != '\0') {
          Msg = HTMainAnchor->source_cache_file;
          fp_00 = TraceFP();
          fprintf((FILE *)fp_00,"  Cannot read file %s\n",Msg);
        }
        LYRemoveTemp(HTMainAnchor->source_cache_file);
        if (HTMainAnchor->source_cache_file != (char *)0x0) {
          free(HTMainAnchor->source_cache_file);
          HTMainAnchor->source_cache_file = (char *)0x0;
        }
        return '\0';
      }
      BVar2 = HText_HaveUserChangedForms(HTMainText);
      if (BVar2 != '\0') {
        Msg = (char *)gettext("Reloading document.  Any form entries will be lost!");
        HTAlert(Msg);
      }
      HTAnchor_setProtocol(HTMainAnchor,&HTFile);
      iVar3 = HTParseFile(format,HTOutputFormat,HTMainAnchor,fp_00,(HTStream *)0x0);
      LYCloseInput(fp_00);
      if (iVar3 == 0xce) {
        Msg = (char *)gettext("Loading incomplete.");
        HTInfoMsg(Msg);
        if (WWW_TraceFlag != '\0') {
          Msg = HTLoadedDocumentURL();
          fp_00 = TraceFP();
          fprintf((FILE *)fp_00,"SourceCache: `%s\' has been accessed, partial content.\n",Msg);
        }
      }
      if ((iVar3 == 200) || (iVar3 == 0xce)) {
        local_34 = '\x01';
      }
      else {
        local_34 = '\0';
      }
      ok = local_34;
      if (WWW_TraceFlag != '\0') {
        if (local_34 == '\0') {
          local_30 = "failed";
        }
        else {
          local_30 = "succeeded";
        }
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"Reparse file %s\n",local_30);
      }
    }
    local_35 = ok;
  }
  return local_35;
}



BOOLEAN HTcan_reparse_document(void)

{
  BOOLEAN BVar1;
  FILE *__stream;
  BOOLEAN result;
  
  result = '\0';
  if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYCacheSource == 0)) {
    result = '\0';
  }
  else {
    BVar1 = useSourceCache();
    if (BVar1 == '\0') {
      BVar1 = useMemoryCache();
      if (BVar1 != '\0') {
        result = '\x01';
      }
    }
    else {
      result = LYCanReadFile(HTMainAnchor->source_cache_file);
    }
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTcan_reparse_document -> %d\n",(int)result);
  }
  return result;
}



void trace_setting_change(char *name,int prev_setting,int new_setting)

{
  FILE *__stream;
  
  if ((prev_setting != new_setting) && (WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,
            "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",name,
            prev_setting,new_setting);
  }
  return;
}



BOOLEAN HTdocument_settings_changed(void)

{
  short sVar1;
  short sVar2;
  int iVar3;
  BOOLEAN BVar4;
  FILE *__stream;
  int local_24;
  int local_1c;
  int local_10;
  
  if ((HTMainText == (HText *)0x0) || (BVar4 = HTcan_reparse_document(), BVar4 == '\0')) {
    return '\0';
  }
  if (WWW_TraceFlag != '\0') {
    trace_setting_change("CLICKABLE_IMAGES",(int)HTMainText->clickable_images,(int)clickable_images)
    ;
    trace_setting_change
              ("PSEUDO_INLINE_ALTS",(int)HTMainText->pseudo_inline_alts,(int)pseudo_inline_alts);
    trace_setting_change("VERBOSE_IMG",(int)HTMainText->verbose_img,(int)verbose_img);
    trace_setting_change("RAW_MODE",(int)HTMainText->raw_mode,(int)LYUseDefaultRawMode);
    trace_setting_change
              ("HISTORICAL_COMMENTS",(int)HTMainText->historical_comments,(int)historical_comments);
    trace_setting_change("MINIMAL_COMMENTS",(int)HTMainText->minimal_comments,(int)minimal_comments)
    ;
    trace_setting_change("SOFT_DQUOTES",(int)HTMainText->soft_dquotes,(int)soft_dquotes);
    trace_setting_change("OLD_DTD",(int)HTMainText->old_dtd,Old_DTD);
    trace_setting_change("KEYPAD_MODE",(int)HTMainText->keypad_mode,keypad_mode);
    iVar3 = LYlines;
    if ((int)HTMainText->disp_lines == LYlines) {
      if (LYwideLines == 0) {
        local_24 = LYcols;
      }
      else {
        local_24 = 0x3f6;
      }
      if ((int)HTMainText->disp_cols == local_24) goto LAB_0806bfe7;
    }
    if (WWW_TraceFlag != '\0') {
      if (LYwideLines == 0) {
        local_1c = LYcols;
      }
      else {
        local_1c = 0x3f6;
      }
      sVar1 = HTMainText->disp_lines;
      sVar2 = HTMainText->disp_cols;
      __stream = TraceFP();
      fprintf((FILE *)__stream,
              "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
              (int)sVar2,(int)sVar1,local_1c,iVar3);
    }
  }
LAB_0806bfe7:
  if ((((((HTMainText->clickable_images == clickable_images) &&
         (HTMainText->pseudo_inline_alts == pseudo_inline_alts)) &&
        (HTMainText->verbose_img == verbose_img)) &&
       ((HTMainText->raw_mode == LYUseDefaultRawMode &&
        (HTMainText->historical_comments == historical_comments)))) &&
      ((HTMainText->minimal_comments == minimal_comments || (historical_comments != '\0')))) &&
     (((HTMainText->soft_dquotes == soft_dquotes && ((int)HTMainText->old_dtd == Old_DTD)) &&
      ((int)HTMainText->keypad_mode == keypad_mode)))) {
    if (LYwideLines == 0) {
      local_10 = LYcols;
    }
    else {
      local_10 = 0x3f6;
    }
    if ((int)HTMainText->disp_cols == local_10) {
      return '\0';
    }
  }
  return '\x01';
}



int HTisDocumentSource(void)

{
  int local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = 0;
  }
  else {
    local_8 = (int)HTMainText->source;
  }
  return local_8;
}



char * HTLoadedDocumentURL(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = "";
  }
  else {
    if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
       (HTMainText->node_anchor->address == (char *)0x0)) {
      local_8 = "";
    }
    else {
      local_8 = HTMainText->node_anchor->address;
    }
  }
  return local_8;
}



bstring * HTLoadedDocumentPost_data(void)

{
  bstring *local_8;
  
  if (((HTMainText == (HText *)0x0) || (HTMainText->node_anchor == (HTParentAnchor *)0x0)) ||
     (HTMainText->node_anchor->post_data == (bstring *)0x0)) {
    local_8 = (bstring *)0x0;
  }
  else {
    local_8 = HTMainText->node_anchor->post_data;
  }
  return local_8;
}



char * HTLoadedDocumentTitle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = "";
  }
  else {
    if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
       (HTMainText->node_anchor->title == (char *)0x0)) {
      local_8 = "";
    }
    else {
      local_8 = HTMainText->node_anchor->title;
    }
  }
  return local_8;
}



BOOLEAN HTLoadedDocumentIsHEAD(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
       (HTMainText->node_anchor->isHEAD == '\0')) {
      local_5 = '\0';
    }
    else {
      local_5 = HTMainText->node_anchor->isHEAD;
    }
  }
  return local_5;
}



BOOLEAN HTLoadedDocumentIsSafe(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
       (HTMainText->node_anchor->safe == '\0')) {
      local_5 = '\0';
    }
    else {
      local_5 = HTMainText->node_anchor->safe;
    }
  }
  return local_5;
}



char * HTLoadedDocumentCharset(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
       (HTMainText->node_anchor->charset == (char *)0x0)) {
      local_8 = (char *)0x0;
    }
    else {
      local_8 = HTMainText->node_anchor->charset;
    }
  }
  return local_8;
}



BOOLEAN HTLoadedDocumentEightbit(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = HTMainText->have_8bit_chars;
  }
  return local_5;
}



void HText_setNodeAnchorBookmark(char *bookmark)

{
  if ((HTMainText != (HText *)0x0) && (HTMainText->node_anchor != (HTParentAnchor *)0x0)) {
    HTAnchor_setBookmark(HTMainText->node_anchor,bookmark);
  }
  return;
}



char * HTLoadedDocumentBookmark(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
       (HTMainText->node_anchor->bookmark == (char *)0x0)) {
      local_8 = (char *)0x0;
    }
    else {
      local_8 = HTMainText->node_anchor->bookmark;
    }
  }
  return local_8;
}



int HText_LastLineSize(HText *text,BOOLEAN IgnoreSpaces)

{
  int local_c;
  
  if (((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) || (text->last_line->size == 0)
     ) {
    local_c = 0;
  }
  else {
    local_c = HText_TrueLineSize(text->last_line,text,IgnoreSpaces);
  }
  return local_c;
}



BOOLEAN HText_LastLineEmpty(HText *text,BOOLEAN IgnoreSpaces)

{
  BOOLEAN local_9;
  
  if (((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) || (text->last_line->size == 0)
     ) {
    local_9 = '\x01';
  }
  else {
    local_9 = HText_TrueEmptyLine(text->last_line,text,IgnoreSpaces);
  }
  return local_9;
}



int HText_LastLineOffset(HText *text)

{
  uint local_8;
  
  if ((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) {
    local_8 = 0;
  }
  else {
    local_8 = (uint)text->last_line->offset;
  }
  return local_8;
}



int HText_PreviousLineSize(HText *text,BOOLEAN IgnoreSpaces)

{
  HTLine *line_00;
  int local_1c;
  HTLine *line;
  
  if ((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) {
    local_1c = 0;
  }
  else {
    line_00 = (HTLine *)text->last_line->prev;
    if (line_00 == (HTLine *)0x0) {
      local_1c = 0;
    }
    else {
      local_1c = HText_TrueLineSize(line_00,text,IgnoreSpaces);
    }
  }
  return local_1c;
}



BOOLEAN HText_PreviousLineEmpty(HText *text,BOOLEAN IgnoreSpaces)

{
  HTLine *line_00;
  BOOLEAN local_19;
  HTLine *line;
  
  if ((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) {
    local_19 = '\x01';
  }
  else {
    line_00 = (HTLine *)text->last_line->prev;
    if (line_00 == (HTLine *)0x0) {
      local_19 = '\x01';
    }
    else {
      local_19 = HText_TrueEmptyLine(line_00,text,IgnoreSpaces);
    }
  }
  return local_19;
}



int HText_TrueLineSize(HTLine *line,HText *text,BOOLEAN IgnoreSpaces)

{
  ushort **ppuVar1;
  int local_1c;
  int true_size;
  size_t i;
  
  true_size = 0;
  if ((line == (HTLine *)0x0) || (line->size == 0)) {
    local_1c = 0;
  }
  else {
    if (IgnoreSpaces == '\0') {
      i = 0;
      while (i < line->size) {
        if (((line->data[i] < '\x03') || ('\b' < line->data[i])) &&
           ((text == (HText *)0x0 ||
            ((((text->T).output_utf8 == '\0' || (-1 < line->data[i])) ||
             ((line->data[i] & 0xc0U) == 0xc0)))))) {
          true_size = true_size + 1;
        }
        i = i + 1;
      }
    }
    else {
      i = 0;
      while (i < line->size) {
        if (((((byte)line->data[i] < 3) || (8 < (byte)line->data[i])) &&
            (((text == (HText *)0x0 || (((text->T).output_utf8 == '\0' || (-1 < line->data[i])))) ||
             ((line->data[i] & 0xc0U) == 0xc0)))) &&
           (((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)line->data[i]] & 0x2000) == 0 &&
             (line->data[i] != '\x01')) && (line->data[i] != '\x02')))) {
          true_size = true_size + 1;
        }
        i = i + 1;
      }
    }
    local_1c = true_size;
  }
  return local_1c;
}



BOOLEAN HText_TrueEmptyLine(HTLine *line,HText *text,BOOLEAN IgnoreSpaces)

{
  ushort **ppuVar1;
  size_t i;
  
  if ((line != (HTLine *)0x0) && (line->size != 0)) {
    if (IgnoreSpaces == '\0') {
      i = 0;
      while (i < line->size) {
        if (((line->data[i] < '\x03') || ('\b' < line->data[i])) &&
           ((text == (HText *)0x0 ||
            ((((text->T).output_utf8 == '\0' || (-1 < line->data[i])) ||
             ((line->data[i] & 0xc0U) == 0xc0)))))) {
          return '\0';
        }
        i = i + 1;
      }
    }
    else {
      i = 0;
      while (i < line->size) {
        if (((((byte)line->data[i] < 3) || (8 < (byte)line->data[i])) &&
            (((text == (HText *)0x0 || (((text->T).output_utf8 == '\0' || (-1 < line->data[i])))) ||
             ((line->data[i] & 0xc0U) == 0xc0)))) &&
           (((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)line->data[i]] & 0x2000) == 0 &&
             (line->data[i] != '\x01')) && (line->data[i] != '\x02')))) {
          return '\0';
        }
        i = i + 1;
      }
    }
  }
  return '\x01';
}



void HText_NegateLineOne(HText *text)

{
  if (text != (HText *)0x0) {
    text->in_line_1 = '\0';
  }
  return;
}



BOOLEAN HText_inLineOne(HText *text)

{
  BOOLEAN local_5;
  
  if (text == (HText *)0x0) {
    local_5 = '\x01';
  }
  else {
    local_5 = text->in_line_1;
  }
  return local_5;
}



void HText_RemovePreviousLine(HText *text)

{
  _line *p_Var1;
  HTLine *previous;
  HTLine *line;
  
  if ((text != (HText *)0x0) && (1 < text->Lines)) {
    p_Var1 = text->last_line->prev->prev;
    p_Var1->next = (_line *)text->last_line;
    text->last_line->prev = p_Var1;
    text->Lines = text->Lines + -1;
  }
  return;
}



int HText_getCurrentColumn(HText *text)

{
  int iVar1;
  HTCoord local_18;
  int column;
  BOOLEAN IgnoreSpaces;
  
  column = 0;
  if (text != (HText *)0x0) {
    if (text->in_line_1 == '\0') {
      local_18 = text->style->leftIndent;
    }
    else {
      local_18 = text->style->indent1st;
    }
    iVar1 = HText_LastLineSize(text,'\0');
    column = local_18 + iVar1 + (uint)text->last_line->offset;
  }
  return column;
}



int HText_getMaximumColumn(HText *text)

{
  int local_18;
  int column;
  
  if (LYwideLines == 0) {
    local_18 = LYcols;
  }
  else {
    local_18 = 0x3f6;
  }
  column = local_18;
  if (text != (HText *)0x0) {
    column = local_18 - text->style->rightIndent;
  }
  return column;
}



void HText_setTabID(HText *text,char *name)

{
  HTList *pHVar1;
  int iVar2;
  HTTabID *local_18;
  HTList *last;
  HTList *cur;
  HTTabID *Tab;
  
  Tab = (HTTabID *)0x0;
  cur = text->tabs;
  last = (HTList *)0x0;
  if (((text != (HText *)0x0) && (name != (char *)0x0)) && (*name != '\0')) {
    if (cur == (HTList *)0x0) {
      pHVar1 = HTList_new();
      text->tabs = pHVar1;
      cur = text->tabs;
    }
    else {
      while( true ) {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (HTTabID *)0x0;
        }
        else {
          local_18 = (HTTabID *)cur->object;
        }
        Tab = local_18;
        if (local_18 == (HTTabID *)0x0) break;
        if ((local_18->name != (char *)0x0) && (iVar2 = strcmp(local_18->name,name), iVar2 == 0)) {
          return;
        }
        last = cur;
      }
      if (last != (HTList *)0x0) {
        cur = last;
      }
    }
    if (Tab == (HTTabID *)0x0) {
      Tab = (HTTabID *)calloc(1,8);
      if (Tab == (HTTabID *)0x0) {
        outofmem("./GridText.c","HText_setTabID");
      }
      HTList_addObject(cur,Tab);
      HTSACopy((char **)Tab,name);
    }
    iVar2 = HText_getCurrentColumn(text);
    Tab->column = iVar2;
  }
  return;
}



int HText_getTabIDColumn(HText *text,char *name)

{
  int iVar1;
  char **local_18;
  HTList *cur;
  HTTabID *Tab;
  int column;
  
  column = 0;
  cur = text->tabs;
  if ((((text != (HText *)0x0) && (name != (char *)0x0)) && (*name != '\0')) &&
     (cur != (HTList *)0x0)) {
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char **)0x0;
      }
      else {
        local_18 = (char **)cur->object;
      }
    } while ((local_18 != (char **)0x0) &&
            ((*local_18 == (char *)0x0 || (iVar1 = strcmp(*local_18,name), iVar1 != 0))));
    if (local_18 != (char **)0x0) {
      column = (int)local_18[1];
    }
  }
  return column;
}



void HText_AddHiddenLink(HText *text,TextAnchor *textanchor)

{
  HTList *pHVar1;
  HTAnchor *me;
  char *newObject;
  HTAnchor *dest;
  
  if (((text != (HText *)0x0) && (textanchor != (TextAnchor *)0x0)) &&
     (textanchor->anchor != (HTChildAnchor *)0x0)) {
    if (text->hidden_links == (HTList *)0x0) {
      pHVar1 = HTList_new();
      text->hidden_links = pHVar1;
    }
    me = HTAnchor_followLink(textanchor->anchor);
    if ((me != (HTAnchor *)0x0) &&
       (((text->hiddenlinkflag != 2 || (text->hidden_links == (HTList *)0x0)) ||
        (text->hidden_links->next == (HTList *)0x0)))) {
      newObject = HTAnchor_address(me);
      HTList_appendObject(text->hidden_links,newObject);
    }
  }
  return;
}



int HText_HiddenLinkCount(HText *text)

{
  int count;
  
  count = 0;
  if ((text != (HText *)0x0) && (text->hidden_links != (HTList *)0x0)) {
    count = HTList_count(text->hidden_links);
  }
  return count;
}



char * HText_HiddenLinkAt(HText *text,int number)

{
  char *href;
  
  href = (char *)0x0;
  if (((text != (HText *)0x0) && (text->hidden_links != (HTList *)0x0)) && (-1 < number)) {
    href = (char *)HTList_objectAt(text->hidden_links,number);
  }
  return href;
}



void HText_beginForm(char *action,char *method,char *enctype,char *title,char *accept_cs)

{
  int iVar1;
  char *src;
  PerFormInfo *pPVar2;
  FILE *__stream;
  char *local_34;
  char *local_30;
  char *local_2c;
  char *local_28;
  char *local_24;
  char *local_20;
  PerFormInfo *newform;
  
  HTFormMethod = 1;
  HTFormNumber = HTFormNumber + 1;
  HTFormFields = 0;
  HTFormDisabled = '\0';
  if (action == (char *)0x0) {
    src = HTLoadedDocumentURL();
    HTSACopy(&HTFormAction,src);
  }
  else {
    iVar1 = strncasecomp(action,"mailto:",7);
    if (iVar1 == 0) {
      HTFormMethod = 3;
    }
    HTSACopy(&HTFormAction,action);
  }
  if (((method != (char *)0x0) && (HTFormMethod != 3)) &&
     ((iVar1 = strcasecomp(method,"post"), iVar1 == 0 ||
      (iVar1 = strcasecomp(method,"pget"), iVar1 == 0)))) {
    HTFormMethod = 2;
  }
  if ((enctype == (char *)0x0) || (*enctype == '\0')) {
    if (HTFormEnctype != (char *)0x0) {
      free(HTFormEnctype);
      HTFormEnctype = (char *)0x0;
    }
  }
  else {
    HTSACopy(&HTFormEnctype,enctype);
    if ((HTFormMethod != 3) &&
       (iVar1 = strncasecomp(enctype,"multipart/form-data",0x13), iVar1 == 0)) {
      HTFormMethod = 2;
    }
  }
  if ((title == (char *)0x0) || (*title == '\0')) {
    if (HTFormTitle != (char *)0x0) {
      free(HTFormTitle);
      HTFormTitle = (char *)0x0;
    }
  }
  else {
    HTSACopy(&HTFormTitle,title);
  }
  if (accept_cs != (char *)0x0) {
    HTSACopy(&HTFormAcceptCharset,accept_cs);
    LYRemoveBlanks(HTFormAcceptCharset);
    LYLowerCase(HTFormAcceptCharset);
  }
  pPVar2 = (PerFormInfo *)calloc(1,0x20);
  if (pPVar2 == (PerFormInfo *)0x0) {
    outofmem("./GridText.c","HText_beginForm");
  }
  pPVar2->number = HTFormNumber;
  PerFormInfo_free(HTCurrentForm);
  iVar1 = HTFormMethod;
  src = HTFormAction;
  HTCurrentForm = pPVar2;
  if (WWW_TraceFlag != '\0') {
    if (HTFormAcceptCharset == (char *)0x0) {
      local_34 = "";
      local_30 = "";
    }
    else {
      local_30 = " Accept-charset:";
      local_34 = HTFormAcceptCharset;
    }
    if (HTFormEnctype == (char *)0x0) {
      local_2c = "";
      local_28 = "";
    }
    else {
      local_28 = " Enctype:";
      local_2c = HTFormEnctype;
    }
    if (HTFormTitle == (char *)0x0) {
      local_24 = "";
      local_20 = "";
    }
    else {
      local_20 = " Title:";
      local_24 = HTFormTitle;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",src,iVar1,local_20,
            local_24,local_28,local_2c,local_30,local_34);
  }
  return;
}



void HText_endForm(HText *text)

{
  HTList *pHVar1;
  FILE *__stream;
  TextAnchor *a;
  
  if (((HTFormFields == 1) && (text != (HText *)0x0)) && (text->first_anchor != (TextAnchor *)0x0))
  {
    a = text->first_anchor;
    while (a != (TextAnchor *)0x0) {
      if (((a->link_type == '\x02') && (a->input_field->number == HTFormNumber)) &&
         (a->input_field->type == 1)) {
        a->input_field->submit_action = (char *)0x0;
        HTSACopy(&a->input_field->submit_action,HTFormAction);
        if (HTFormEnctype != (char *)0x0) {
          HTSACopy(&a->input_field->submit_enctype,HTFormEnctype);
        }
        if (HTFormTitle != (char *)0x0) {
          HTSACopy(&a->input_field->submit_title,HTFormTitle);
        }
        a->input_field->submit_method = HTFormMethod;
        a->input_field->type = 0xc;
        if (HTFormDisabled != '\0') {
          a->input_field->disabled = 1;
        }
        break;
      }
      a = (TextAnchor *)a->next;
    }
  }
  if (HTCurrentForm == (PerFormInfo *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"endForm:    HTCurrentForm is missing!\n");
    }
  }
  else {
    if (HTFormDisabled != '\0') {
      HTCurrentForm->disabled = 1;
    }
    HTCurrentForm->accept_cs = HTFormAcceptCharset;
    HTFormAcceptCharset = (char *)0x0;
    if (text->forms == (HTList *)0x0) {
      pHVar1 = HTList_new();
      text->forms = pHVar1;
    }
    HTList_appendObject(text->forms,HTCurrentForm);
    HTCurrentForm = (PerFormInfo *)0x0;
  }
  if (HTCurSelectGroup != (char *)0x0) {
    free(HTCurSelectGroup);
    HTCurSelectGroup = (char *)0x0;
  }
  if (HTCurSelectGroupSize != (char *)0x0) {
    free(HTCurSelectGroupSize);
    HTCurSelectGroupSize = (char *)0x0;
  }
  if (HTCurSelectedOptionValue != (char *)0x0) {
    free(HTCurSelectedOptionValue);
    HTCurSelectedOptionValue = (char *)0x0;
  }
  if (HTFormAction != (char *)0x0) {
    free(HTFormAction);
    HTFormAction = (char *)0x0;
  }
  if (HTFormEnctype != (char *)0x0) {
    free(HTFormEnctype);
    HTFormEnctype = (char *)0x0;
  }
  if (HTFormTitle != (char *)0x0) {
    free(HTFormTitle);
    HTFormTitle = (char *)0x0;
  }
  if (HTFormAcceptCharset != (char *)0x0) {
    free(HTFormAcceptCharset);
    HTFormAcceptCharset = (char *)0x0;
  }
  HTFormFields = 0;
  HTFormDisabled = '\0';
  return;
}



void HText_beginSelect(char *name,int name_cs,BOOLEAN multiple,char *size)

{
  int iVar1;
  FILE *__stream;
  char *local_1c;
  char *local_14;
  char *local_10;
  
  HTSACopy(&HTCurSelectGroup,name);
  HTCurSelectGroupCharset = name_cs;
  if (multiple == '\0') {
    HTCurSelectGroupType = 4;
  }
  else {
    HTCurSelectGroupType = 3;
  }
  HTSACopy(&HTCurSelectGroupSize,size);
  iVar1 = HTCurSelectGroupType;
  if (WWW_TraceFlag != '\0') {
    if (HTCurSelectGroupSize == (char *)0x0) {
      local_1c = "<NULL>";
    }
    else {
      local_1c = HTCurSelectGroupSize;
    }
    if (HTCurSelectGroup == (char *)0x0) {
      local_14 = "<NULL>";
    }
    else {
      local_14 = HTCurSelectGroup;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HText_beginSelect: name=%s type=%d size=%s\n",local_14,iVar1,local_1c)
    ;
  }
  iVar1 = HTCurSelectGroupCharset;
  if (WWW_TraceFlag != '\0') {
    if (HTCurSelectGroupCharset < 0) {
      local_10 = "<UNKNOWN>";
    }
    else {
      local_10 = LYCharSet_UC[HTCurSelectGroupCharset].MIMEname;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HText_beginSelect: name_cs=%d \"%s\"\n",iVar1,local_10);
  }
  return;
}



int HText_getOptionNum(HText *text)

{
  TextAnchor *pTVar1;
  FILE *__stream;
  int local_18;
  int n;
  OptionType *op;
  TextAnchor *a;
  
  n = 1;
  if ((text == (HText *)0x0) || (text->last_anchor == (TextAnchor *)0x0)) {
    local_18 = 0;
  }
  else {
    pTVar1 = text->last_anchor;
    if ((pTVar1->link_type == '\x02') &&
       ((pTVar1->input_field != (FormInfo *)0x0 && (pTVar1->input_field->type == 7)))) {
      op = pTVar1->input_field->select_list;
      while (op != (OptionType *)0x0) {
        n = n + 1;
        op = (OptionType *)op->next;
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HText_getOptionNum: Got number \'%d\'.\n",n);
      }
      local_18 = n;
    }
    else {
      local_18 = 0;
    }
  }
  return local_18;
}



char * HText_skipOptionNumPrefix(char *opname)

{
  char cVar1;
  ushort **ppuVar2;
  int i;
  char *cp;
  
  if ((keypad_mode != 3) && (keypad_mode != 2)) {
    return opname;
  }
  if ((((opname != (char *)0x0) && (*opname != '\0')) && (*opname == '(')) && (opname[1] != 0)) {
    ppuVar2 = __ctype_b_loc();
    cp = opname + 2;
    if (((*ppuVar2)[(byte)opname[1]] & 0x800) != 0) {
      while ((*cp != '\0' && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*cp] & 0x800) != 0))) {
        cp = cp + 1;
      }
      if ((*cp == '\0') || (cVar1 = *cp, cp = cp + 1, cVar1 != ')')) {
        return opname;
      }
      i = (int)(cp + -(int)opname);
      while ((i < 5 && (*cp == '_'))) {
        i = i + 1;
        cp = cp + 1;
      }
      if (4 < i) {
        return cp;
      }
      return opname;
    }
  }
  return opname;
}



char * HText_setLastOptionValue
                 (HText *text,char *value,char *submit_value,int order,BOOLEAN checked,int val_cs,
                 int submit_val_cs)

{
  int iVar1;
  FormInfo *pFVar2;
  bool bVar3;
  FILE *__stream;
  size_t sVar4;
  ushort **ppuVar5;
  char *pcVar6;
  OptionType *pOVar7;
  uchar *sjis;
  char *local_8c;
  char *local_88;
  undefined *local_84;
  char *local_80;
  int local_78;
  char *local_74;
  int local_70;
  size_t local_6c;
  char *local_68;
  size_t local_64;
  char *local_60;
  char *local_5c;
  char *local_58;
  char *local_54;
  char *local_50;
  FormInfo *last_input_1;
  int newlen_1;
  int curlen_1;
  int curlen;
  int newlen;
  FormInfo *last_input;
  OptionType *new_ptr;
  OptionType *op_ptr;
  int j;
  int i;
  int number;
  uchar *tmp;
  char *ret_Value;
  char *cp1;
  char *cp;
  BOOLEAN first_option;
  
  ret_Value = (char *)0x0;
  number = 0;
  if ((((value == (char *)0x0) || (text == (HText *)0x0)) ||
      (text->last_anchor == (TextAnchor *)0x0)) ||
     ((text->last_anchor->input_field == (FormInfo *)0x0 || (text->last_anchor->link_type != '\x02')
      ))) {
    if (WWW_TraceFlag != '\0') {
      if (value == (char *)0x0) {
        local_8c = "<NULL>";
      }
      else {
        local_8c = value;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HText_setLastOptionValue: invalid call!  value:%s!\n",local_8c);
    }
    local_88 = (char *)0x0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      if (checked == '\0') {
        local_84 = &DAT_0814e05f;
      }
      else {
        local_84 = &DAT_0814e05c;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",value
              ,local_84);
    }
    if (*value != '\0') {
      sVar4 = strlen(value);
      cp = value + (sVar4 - 1);
      while ((value <= cp &&
             ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x2000) != 0 ||
              ((2 < (byte)*cp && ((byte)*cp < 9))))))) {
        cp = cp + -1;
      }
      cp[1] = '\0';
    }
    cp = value;
    while ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x2000) != 0 ||
           ((2 < (byte)*cp && ((byte)*cp < 9))))) {
      cp = cp + 1;
    }
    if ((((HTCurSelectGroupType == 4) && (LYSelectPopups != '\0')) &&
        ((keypad_mode == 3 || (keypad_mode == 2)))) &&
       (pcVar6 = HText_skipOptionNumPrefix(cp), cp < pcVar6)) {
      i = 0;
      j = (int)(pcVar6 + -(int)cp);
      while ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)pcVar6[i]] & 0x2000) != 0 ||
             ((2 < (byte)pcVar6[i] && ((byte)pcVar6[i] < 9))))) {
        i = i + 1;
      }
      if (0 < i) {
        while (pcVar6[i] != '\0') {
          cp[j] = pcVar6[i];
          j = j + 1;
          i = i + 1;
        }
        cp[j] = '\0';
      }
    }
    if (HTCurSelectGroupType == 3) {
      HTSACopy(&text->last_anchor->input_field->value,cp);
      text->last_anchor->input_field->value_cs = val_cs;
      HText_appendText(text,cp);
    }
    else {
      if (LYSelectPopups == '\0') {
        if (submit_value == (char *)0x0) {
          local_80 = cp;
        }
        else {
          local_80 = submit_value;
        }
        HTSACopy(&text->last_anchor->input_field->value,local_80);
        if (submit_value == (char *)0x0) {
          local_78 = val_cs;
        }
        else {
          local_78 = submit_val_cs;
        }
        text->last_anchor->input_field->value_cs = local_78;
        HText_appendText(text,cp);
      }
      else {
        op_ptr = text->last_anchor->input_field->select_list;
        bVar3 = false;
        LYReduceBlanks(value);
        if (op_ptr == (OptionType *)0x0) {
          if (text->last_anchor->input_field->type != 7) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,
                      "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",7);
            }
            if (WWW_TraceFlag != '\0') {
              iVar1 = text->last_anchor->input_field->type;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"                          but %d, ignoring!\n",iVar1);
            }
            return (char *)0x0;
          }
          pFVar2 = text->last_anchor->input_field;
          pOVar7 = (OptionType *)calloc(1,0x10);
          pFVar2->select_list = pOVar7;
          new_ptr = pFVar2->select_list;
          if (new_ptr == (OptionType *)0x0) {
            outofmem("./GridText.c","HText_setLastOptionValue");
          }
          bVar3 = true;
        }
        else {
          while (op_ptr->next != (_OptionType *)0x0) {
            number = number + 1;
            op_ptr = (OptionType *)op_ptr->next;
          }
          number = number + 1;
          new_ptr = (OptionType *)calloc(1,0x10);
          *(OptionType **)&op_ptr->next = new_ptr;
          if (new_ptr == (OptionType *)0x0) {
            outofmem("./GridText.c","HText_setLastOptionValue");
          }
        }
        new_ptr->name = (char *)0x0;
        new_ptr->cp_submit_value = (char *)0x0;
        new_ptr->next = (_OptionType *)0x0;
        cp = value;
        while ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x2000) != 0 ||
               ((2 < (byte)*cp && ((byte)*cp < 9))))) {
          cp = cp + 1;
        }
        i = 0;
        j = 0;
        while (cp[i] != '\0') {
          if ((cp[i] == '\x01') || (cp[i] == '\x02')) {
            cp[j] = ' ';
            j = j + 1;
          }
          else {
            if ((cp[i] != '\a') && (((byte)cp[i] < 3 || (8 < (byte)cp[i])))) {
              cp[j] = cp[i];
              j = j + 1;
            }
          }
          i = i + 1;
        }
        cp[j] = '\0';
        if (HTCJK == NOCJK) {
          HTSACopy((char **)new_ptr,cp);
        }
        else {
          if (cp != (char *)0x0) {
            sVar4 = strlen(cp);
            sjis = (uchar *)calloc(sVar4 * 2 + 1,1);
            if (sjis != (uchar *)0x0) {
              if (sjis == (uchar *)0x0) {
                outofmem("./GridText.c","HText_setLastOptionValue");
              }
              if (kanji_code == EUC) {
                TO_EUC((uchar *)cp,sjis);
                val_cs = current_char_set;
              }
              else {
                if (kanji_code == SJIS) {
                  TO_SJIS((uchar *)cp,sjis);
                  val_cs = current_char_set;
                }
                else {
                  i = 0;
                  j = 0;
                  while (cp[i] != '\0') {
                    if (cp[i] != '\x1b') {
                      sjis[j] = cp[i];
                      j = j + 1;
                    }
                    i = i + 1;
                  }
                }
              }
              HTSACopy((char **)new_ptr,(char *)sjis);
              if (sjis != (uchar *)0x0) {
                free(sjis);
              }
            }
          }
        }
        if (submit_value == (char *)0x0) {
          local_74 = HText_skipOptionNumPrefix(new_ptr->name);
        }
        else {
          local_74 = submit_value;
        }
        HTSACopy(&new_ptr->cp_submit_value,local_74);
        if (submit_value == (char *)0x0) {
          local_70 = val_cs;
        }
        else {
          local_70 = submit_val_cs;
        }
        new_ptr->value_cs = local_70;
        if (bVar3) {
          pFVar2 = text->last_anchor->input_field;
          HTSACopy(&HTCurSelectedOptionValue,new_ptr->name);
          pFVar2->num_value = 0;
          if (pFVar2->value != (char *)0x0) {
            free(pFVar2->value);
            pFVar2->value = (char *)0x0;
          }
          if (pFVar2->cp_submit_value != (char *)0x0) {
            free(pFVar2->cp_submit_value);
            pFVar2->cp_submit_value = (char *)0x0;
          }
          pFVar2->value = pFVar2->select_list->name;
          pFVar2->orig_value = pFVar2->select_list->name;
          pFVar2->cp_submit_value = pFVar2->select_list->cp_submit_value;
          pFVar2->orig_submit_value = pFVar2->select_list->cp_submit_value;
          pFVar2->value_cs = new_ptr->value_cs;
        }
        else {
          sVar4 = strlen(new_ptr->name);
          if (HTCurSelectedOptionValue == (char *)0x0) {
            local_6c = 0;
          }
          else {
            local_6c = strlen(HTCurSelectedOptionValue);
          }
          if ((int)local_6c < (int)sVar4) {
            if ((int)(sVar4 - local_6c) < 0x400) {
              local_68 = underscore_string + (local_6c - sVar4) + 0x3ff;
            }
            else {
              local_68 = underscore_string;
            }
            HTSACat(&HTCurSelectedOptionValue,local_68);
          }
        }
        if (checked != '\0') {
          sVar4 = strlen(new_ptr->name);
          if (HTCurSelectedOptionValue == (char *)0x0) {
            local_64 = 0;
          }
          else {
            local_64 = strlen(HTCurSelectedOptionValue);
          }
          pFVar2 = text->last_anchor->input_field;
          pFVar2->num_value = number;
          pFVar2->value = new_ptr->name;
          pFVar2->orig_value = new_ptr->name;
          pFVar2->cp_submit_value = new_ptr->cp_submit_value;
          pFVar2->orig_submit_value = new_ptr->cp_submit_value;
          pFVar2->value_cs = new_ptr->value_cs;
          HTSACopy(&HTCurSelectedOptionValue,new_ptr->name);
          if ((int)sVar4 < (int)local_64) {
            if ((int)(local_64 - sVar4) < 0x400) {
              local_60 = underscore_string + (sVar4 - local_64) + 0x3ff;
            }
            else {
              local_60 = underscore_string;
            }
            HTSACat(&HTCurSelectedOptionValue,local_60);
          }
        }
        if (order == 3) {
          if (HTCurSelectedOptionValue == (char *)0x0) {
            HTSACopy(&HTCurSelectedOptionValue,"");
          }
          pFVar2 = text->last_anchor->input_field;
          sVar4 = strlen(HTCurSelectedOptionValue);
          pFVar2->size = sVar4;
          ret_Value = HTCurSelectedOptionValue;
        }
      }
    }
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        if (order == 3) {
          local_5c = " LAST_ORDER";
        }
        else {
          local_5c = "";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HText_setLastOptionValue:%s value=\"%s\"\n",local_5c,value);
      }
      if (WWW_TraceFlag != '\0') {
        if (val_cs < 0) {
          local_58 = "<UNKNOWN>";
        }
        else {
          local_58 = LYCharSet_UC[val_cs].MIMEname;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"            val_cs=%d \"%s\"",val_cs,local_58);
      }
      if (submit_value == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"\n");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          if (HTCurSelectGroupType == 3) {
            local_54 = "(ignored)";
          }
          else {
            local_54 = "";
          }
          if (submit_val_cs < 0) {
            local_50 = "<UNKNOWN>";
          }
          else {
            local_50 = LYCharSet_UC[submit_val_cs].MIMEname;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream," (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n",
                  submit_val_cs,local_50,local_54,submit_value);
        }
      }
    }
    local_88 = ret_Value;
  }
  return local_88;
}



int HText_beginInput(HText *text,BOOLEAN underline,InputFieldData *I)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  FILE *__stream;
  TextAnchor *a_00;
  FormInfo *dest;
  int iVar4;
  size_t sVar5;
  uchar *sjis;
  uint uVar6;
  HTList *pHVar7;
  int in_GS_OFFSET;
  bool bVar8;
  char *local_ac;
  int local_a8;
  int local_a4;
  char *local_a0;
  byte local_9c;
  char *local_98;
  int local_94;
  int local_90;
  int local_8c;
  byte local_88;
  char *local_80;
  char *local_7c;
  char *local_74;
  char *local_70;
  char *local_68;
  int i2;
  TextAnchor *b;
  int MaximumSize;
  int adjust_marker;
  int j;
  int i;
  uchar *tmp;
  char *IValue;
  char *cp_option;
  FormInfo *f;
  TextAnchor *a;
  BOOLEAN had_bracket;
  char marker [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp_option = (char *)0x0;
  IValue = (char *)0x0;
  adjust_marker = 0;
  if (WWW_TraceFlag != '\0') {
    if (I->type == (char *)0x0) {
      local_ac = "";
    }
    else {
      local_ac = I->type;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: Entering HText_beginInput type=%s\n",local_ac);
  }
  a_00 = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
  dest = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool,0x60);
  if ((a_00 == (TextAnchor *)0x0) || (dest == (FormInfo *)0x0)) {
    outofmem("./GridText.c","HText_beginInput");
  }
  iVar4 = SGML_offset();
  a_00->sgml_offset = iVar4;
  a_00->inUnderline = underline;
  a_00->line_num = text->Lines;
  a_00->line_pos = text->last_line->size;
  if (I->type != (char *)0x0) {
    iVar4 = strcmp(I->type,"OPTION");
    if (((iVar4 == 0) && (HTCurSelectGroupType == 4)) && (LYSelectPopups == '\0')) {
      I->type = "RADIO";
      I->name = HTCurSelectGroup;
      I->name_cs = HTCurSelectGroupCharset;
    }
  }
  if ((I->name != (char *)0x0) && (I->type != (char *)0x0)) {
    iVar4 = strcasecomp(I->type,"radio");
    if (iVar4 == 0) {
      if (text->last_anchor == (TextAnchor *)0x0) {
        I->checked = 1;
      }
      else {
        i2 = 0;
        b = text->first_anchor;
        while (b != (TextAnchor *)0x0) {
          if (((b->link_type == '\x02') && (b->input_field->type == 4)) &&
             (b->input_field->number == HTFormNumber)) {
            iVar4 = strcmp(b->input_field->name,I->name);
            if (iVar4 == 0) {
              if ((I->checked != 0) && (b->input_field->num_value != 0)) {
                b->input_field->num_value = 0;
                HTSACopy(&b->input_field->orig_value,"0");
                break;
              }
              i2 = i2 + 1;
            }
          }
          b = (TextAnchor *)b->next;
        }
        if (i2 == 0) {
          I->checked = 1;
        }
      }
    }
  }
  a_00->next = (_TextAnchor *)0x0;
  a_00->anchor = (HTChildAnchor *)0x0;
  a_00->link_type = '\x02';
  a_00->show_anchor = '\x01';
  LYClearHiText(a_00);
  a_00->extent = 2;
  a_00->input_field = dest;
  dest->select_list = (OptionType *)0x0;
  dest->number = HTFormNumber;
  if ((HTFormDisabled == '\0') && (I->disabled == 0)) {
    local_a8 = 0;
  }
  else {
    local_a8 = 1;
  }
  dest->disabled = local_a8;
  dest->no_cache = '\0';
  HTFormFields = HTFormFields + 1;
  if (HTFormMethod == 2) {
    dest->no_cache = '\x01';
  }
  if (I->value != (char *)0x0) {
    HTSACopy(&IValue,I->value);
  }
  if ((IValue != (char *)0x0) && (HTCJK != NOCJK)) {
    if (I->type != (char *)0x0) {
      iVar4 = strcasecomp(I->type,"hidden");
      if (iVar4 == 0) goto LAB_0806e574;
    }
    sVar5 = strlen(IValue);
    sjis = (uchar *)calloc(sVar5 * 2 + 1,1);
    if (sjis != (uchar *)0x0) {
      if (kanji_code == EUC) {
        TO_EUC((uchar *)IValue,sjis);
        I->value_cs = current_char_set;
      }
      else {
        if (kanji_code == SJIS) {
          TO_SJIS((uchar *)IValue,sjis);
          I->value_cs = current_char_set;
        }
        else {
          i = 0;
          j = 0;
          while (IValue[i] != '\0') {
            if (IValue[i] != '\x1b') {
              sjis[j] = IValue[i];
              j = j + 1;
            }
            i = i + 1;
          }
        }
      }
      HTSACopy(&IValue,(char *)sjis);
      if (sjis != (uchar *)0x0) {
        free(sjis);
      }
    }
  }
LAB_0806e574:
  if (I->type != (char *)0x0) {
    iVar4 = strcmp(I->type,"OPTION");
    if (iVar4 == 0) {
      cp_option = I->type;
      if (HTCurSelectGroupType == 4) {
        I->type = "OPTION_LIST";
      }
      else {
        I->type = "CHECKBOX";
      }
      I->name = HTCurSelectGroup;
      I->name_cs = HTCurSelectGroupCharset;
      if (HTCurSelectGroupSize != (char *)0x0) {
        iVar4 = atoi(HTCurSelectGroupSize);
        dest->size_l = iVar4;
        if (HTCurSelectGroupSize != (char *)0x0) {
          free(HTCurSelectGroupSize);
          HTCurSelectGroupSize = (char *)0x0;
        }
      }
    }
  }
  if (I->size == 0) {
    dest->size = 0x14;
  }
  else {
    dest->size = I->size;
    if ((dest->size == 0) && (cp_option == (char *)0x0)) {
      dest->size = 0x14;
    }
  }
  if (I->maxlength == (char *)0x0) {
    dest->maxlength = 0;
  }
  else {
    uVar6 = atoi(I->maxlength);
    dest->maxlength = uVar6;
  }
  if (I->checked == 1) {
    dest->num_value = 1;
  }
  else {
    dest->num_value = 0;
  }
  if (I->type == (char *)0x0) {
    dest->type = 1;
  }
  else {
    iVar4 = strcasecomp(I->type,"password");
    if (iVar4 == 0) {
      dest->type = 2;
    }
    else {
      iVar4 = strcasecomp(I->type,"checkbox");
      if (iVar4 == 0) {
        dest->type = 3;
      }
      else {
        iVar4 = strcasecomp(I->type,"radio");
        if (iVar4 == 0) {
          dest->type = 4;
        }
        else {
          iVar4 = strcasecomp(I->type,"submit");
          if (iVar4 == 0) {
            dest->type = 5;
          }
          else {
            iVar4 = strcasecomp(I->type,"image");
            if (iVar4 == 0) {
              dest->type = 0xd;
            }
            else {
              iVar4 = strcasecomp(I->type,"reset");
              if (iVar4 == 0) {
                dest->type = 6;
              }
              else {
                iVar4 = strcasecomp(I->type,"OPTION_LIST");
                if (iVar4 == 0) {
                  dest->type = 7;
                }
                else {
                  iVar4 = strcasecomp(I->type,"hidden");
                  if (iVar4 == 0) {
                    dest->type = 8;
                    HTFormFields = HTFormFields + -1;
                    dest->size = 0;
                  }
                  else {
                    iVar4 = strcasecomp(I->type,"textarea");
                    if (iVar4 == 0) {
                      dest->type = 9;
                    }
                    else {
                      iVar4 = strcasecomp(I->type,"range");
                      if (iVar4 == 0) {
                        dest->type = 10;
                      }
                      else {
                        iVar4 = strcasecomp(I->type,"file");
                        if (iVar4 == 0) {
                          dest->type = 0xb;
                          if (WWW_TraceFlag != '\0') {
                            __stream = TraceFP();
                            fprintf((FILE *)__stream,"ok, got a file uploader\n");
                          }
                        }
                        else {
                          iVar4 = strcasecomp(I->type,"keygen");
                          if (iVar4 == 0) {
                            dest->type = 0xe;
                          }
                          else {
                            dest->type = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (I->name == (char *)0x0) {
    if (((dest->type != 6) && (dest->type != 5)) && (dest->type != 0xd)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"GridText: No name present in input field; not displaying\n");
      }
      if (IValue != (char *)0x0) {
        free(IValue);
        IValue = (char *)0x0;
      }
      local_a4 = 0;
      goto LAB_0806f27d;
    }
    HTSACopy((char **)dest,"");
  }
  else {
    HTSACopy((char **)dest,I->name);
    dest->name_cs = I->name_cs;
  }
  if (text->last_anchor == (TextAnchor *)0x0) {
    text->first_anchor = a_00;
  }
  else {
    *(TextAnchor **)&text->last_anchor->next = a_00;
  }
  if (IValue == (char *)0x0) {
    if (dest->type != 7) {
      HTSACopy(&dest->value,"");
      dest->value_cs = current_char_set;
    }
  }
  else {
    if ((dest->type == 7) || (dest->type == 3)) {
      HTSACopy(&dest->value,IValue);
      HTSACopy(&dest->cp_submit_value,IValue);
    }
    else {
      HTSACopy(&dest->value,IValue);
    }
    dest->value_cs = I->value_cs;
  }
  if (dest->type == 6) {
    if ((dest->value == (char *)0x0) || (*dest->value == '\0')) {
      HTSACopy(&dest->value,"Reset");
      dest->size = 5;
    }
    else {
      sVar5 = strlen(dest->value);
      dest->size = sVar5;
    }
  }
  else {
    if ((dest->type == 0xd) || (dest->type == 5)) {
      if ((dest->value == (char *)0x0) || (*dest->value == '\0')) {
        if (dest->type == 0xd) {
          HTSACopy(&dest->value,"[IMAGE]-Submit");
          dest->size = 0xe;
        }
        else {
          HTSACopy(&dest->value,"Submit");
          dest->size = 6;
        }
      }
      else {
        sVar5 = strlen(dest->value);
        dest->size = sVar5;
      }
      dest->submit_action = (char *)0x0;
      HTSACopy(&dest->submit_action,HTFormAction);
      if (HTFormEnctype != (char *)0x0) {
        HTSACopy(&dest->submit_enctype,HTFormEnctype);
      }
      if (HTFormTitle != (char *)0x0) {
        HTSACopy(&dest->submit_title,HTFormTitle);
      }
      dest->submit_method = HTFormMethod;
    }
    else {
      if (((dest->type == 4) || (dest->type == 3)) && (dest->size = 3, IValue == (char *)0x0)) {
        if (dest->type == 3) {
          local_a0 = "on";
        }
        else {
          local_a0 = "";
        }
        HTSACopy(&dest->value,local_a0);
      }
    }
  }
  if (IValue != (char *)0x0) {
    free(IValue);
    IValue = (char *)0x0;
  }
  if ((dest->type == 4) || (dest->type == 3)) {
    if (dest->num_value == 0) {
      HTSACopy(&dest->orig_value,"0");
    }
    else {
      HTSACopy(&dest->orig_value,"1");
    }
  }
  else {
    if (dest->type == 7) {
      dest->orig_value = (char *)0x0;
    }
    else {
      HTSACopy(&dest->orig_value,dest->value);
    }
  }
  if (I->accept_cs != (char *)0x0) {
    HTSACopy(&dest->accept_cs,I->accept_cs);
    LYRemoveBlanks(dest->accept_cs);
    LYLowerCase(dest->accept_cs);
  }
  if (((uint)dest->type < 0xf) &&
     (local_9c = (byte)dest->type, (1 << (local_9c & 0x1f) & 0x4500U) != 0)) {
    a_00->number = 0;
  }
  else {
    if ((keypad_mode == 3) || (keypad_mode == 2)) {
      text->last_anchor_number = text->last_anchor_number + 1;
      a_00->number = text->last_anchor_number;
    }
    else {
      a_00->number = 0;
    }
  }
  if (((keypad_mode == 3) || (keypad_mode == 2)) && (0 < a_00->number)) {
    sprintf(marker,"[%d]",a_00->number);
    adjust_marker = strlen(marker);
    if (number_fields_on_left != '\0') {
      bVar8 = dest->type == 7;
      if (bVar8) {
        local_98 = marker + 1;
      }
      else {
        local_98 = marker;
      }
      HText_appendText(text,local_98);
      if (bVar8) {
        HText_appendCharacter(text,0x5b);
      }
    }
    a_00->line_num = text->Lines;
    a_00->line_pos = text->last_line->size;
  }
  else {
    marker[0] = '\0';
  }
  if (text->stbl == (STable_info *)0x0) {
    local_90 = LYcols - (uint)(LYShowScrollbar != '\0');
  }
  else {
    if (LYtableCols < 1) {
      if (LYwideLines == 0) {
        local_8c = LYcols;
      }
      else {
        local_8c = 0x3f6;
      }
      local_90 = local_8c;
    }
    else {
      local_90 = LYtableCols * LYcols >> 0x1f;
      local_90 = ((LYtableCols * LYcols) / 6 + local_90 >> 1) - local_90;
    }
    local_90 = local_90 - (uint)(LYShowScrollbar != '\0');
  }
  local_94 = local_90 + 1;
  if (((uint)dest->type < 0xe) &&
     (local_88 = (byte)dest->type, (1 << (local_88 & 0x1f) & 0x2262U) != 0)) {
    MaximumSize = (local_94 - adjust_marker) + (~text->style->leftIndent - text->style->rightIndent)
    ;
    if ((keypad_mode == 3) || (keypad_mode == 2)) {
      if ((number_fields_on_left == '\0') &&
         ((dest->type == 1 && ((int)a_00->line_pos + 10 < MaximumSize)))) {
        MaximumSize = MaximumSize - a_00->line_pos;
      }
      else {
        sVar5 = strlen(marker);
        MaximumSize = MaximumSize - sVar5;
      }
    }
    I->value = dest->value;
  }
  else {
    MaximumSize = (local_94 - adjust_marker) + -10;
  }
  if (MaximumSize < 1) {
    MaximumSize = 1;
  }
  if (MaximumSize < dest->size) {
    dest->size = MaximumSize;
  }
  text->last_anchor = a_00;
  if (HTCurrentForm == (PerFormInfo *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"beginInput: HTCurrentForm is missing!\n");
    }
  }
  else {
    if (HTCurrentForm->first_field == (FormInfo *)0x0) {
      HTCurrentForm->first_field = dest;
    }
    HTCurrentForm->last_field = dest;
    HTCurrentForm->nfields = HTCurrentForm->nfields + 1;
    if ((dest->accept_cs != (char *)0x0) && (HTFormAcceptCharset == (char *)0x0)) {
      HTSACopy(&HTFormAcceptCharset,dest->accept_cs);
    }
    if (text->forms == (HTList *)0x0) {
      pHVar7 = HTList_new();
      text->forms = pHVar7;
    }
  }
  if (WWW_TraceFlag != '\0') {
    iVar4 = dest->size;
    if (dest->value == (char *)0x0) {
      local_80 = "";
    }
    else {
      local_80 = dest->value;
    }
    pcVar2 = dest->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Input link: name=%s\nvalue=%s\nsize=%d\n",pcVar2,local_80,iVar4);
  }
  if (WWW_TraceFlag != '\0') {
    if (I->name_cs < 0) {
      local_7c = "<UNKNOWN>";
    }
    else {
      local_7c = LYCharSet_UC[I->name_cs].MIMEname;
    }
    iVar4 = I->name_cs;
    if (dest->name_cs < 0) {
      local_74 = "<UNKNOWN>";
    }
    else {
      local_74 = LYCharSet_UC[dest->name_cs].MIMEname;
    }
    iVar3 = dest->name_cs;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",iVar3,local_74,iVar4
            ,local_7c);
  }
  if (WWW_TraceFlag != '\0') {
    if (I->value_cs < 0) {
      local_70 = "<UNKNOWN>";
    }
    else {
      local_70 = LYCharSet_UC[I->value_cs].MIMEname;
    }
    iVar4 = I->value_cs;
    if (dest->value_cs < 0) {
      local_68 = "<UNKNOWN>";
    }
    else {
      local_68 = LYCharSet_UC[dest->value_cs].MIMEname;
    }
    iVar3 = dest->value_cs;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"            value_cs=%d \"%s\" (from %d \"%s\")\n",iVar3,local_68,
            iVar4,local_70);
  }
  if ((I->size != 0) && (adjust_marker < dest->size)) {
    dest->size = dest->size - adjust_marker;
  }
  local_a4 = dest->size;
LAB_0806f27d:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_a4;
}



void HText_endInput(HText *text)

{
  int iVar1;
  int in_GS_OFFSET;
  char marker [20];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((((keypad_mode == 3) || (keypad_mode == 2)) && (number_fields_on_left == '\0')) &&
     (((text != (HText *)0x0 && (text->last_anchor != (TextAnchor *)0x0)) &&
      (0 < text->last_anchor->number)))) {
    HText_setIgnoreExcess(text,'\0');
    sprintf(marker,"[%d]",text->last_anchor->number);
    HText_appendText(text,marker);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



double get_trans_q(int cs_from,char *givenmime)

{
  int to;
  char *a;
  char *__nptr;
  double local_2c;
  double df;
  char *ptok;
  char *pval;
  char *field;
  char *pair;
  char *p;
  BOOLEAN tq;
  
  df = 1.00000000;
  if ((givenmime == (char *)0x0) || (*givenmime == '\0')) {
    local_2c = 0.00000000;
  }
  else {
    p = strchr(givenmime,0x3b);
    if (p != (char *)0x0) {
      *p = '\0';
      p = p + 1;
    }
    to = strcmp(givenmime,"*");
    if (to == 0) {
      to = UCGetLYhndl_byMIME("utf-8");
      tq = UCCanTranslateFromTo(cs_from,to);
    }
    else {
      to = UCGetLYhndl_byMIME(givenmime);
      tq = UCCanTranslateFromTo(cs_from,to);
    }
    if (tq == '\0') {
      local_2c = 0.00000000;
    }
    else {
      if ((p == (char *)0x0) || (*p == '\0')) {
        local_2c = (double)(short)tq;
      }
      else {
        field = p;
        do {
          do {
            do {
              pair = HTNextTok(&field,";","\"",(char *)0x0);
              if (pair == (char *)0x0) goto LAB_0806f4c0;
              a = HTNextTok(&pair,"= ",(char *)0x0,(char *)0x0);
            } while (a == (char *)0x0);
            __nptr = HTNextField(&pair);
          } while (__nptr == (char *)0x0);
          to = strcasecomp(a,"q");
        } while (to != 0);
        df = strtod(__nptr,(char **)0x0);
LAB_0806f4c0:
        local_2c = (double)(short)tq * df;
      }
    }
  }
  return local_2c;
}



int find_best_target_cs(char **best_csname,int cs_from,char *acceptstring)

{
  char *givenmime;
  int iVar1;
  double dVar2;
  int local_28;
  double q;
  double bestq;
  char *nextfield;
  char *field;
  char *bestmime;
  char *paccept;
  
  paccept = (char *)0x0;
  bestq = -1.00000000;
  bestmime = (char *)0x0;
  HTSACopy(&paccept,acceptstring);
  nextfield = paccept;
  while( true ) {
    givenmime = HTNextTok(&nextfield,",","\"",(char *)0x0);
    if (givenmime == (char *)0x0) break;
    if (*givenmime != '\0') {
      dVar2 = get_trans_q(cs_from,givenmime);
      if (bestq < dVar2) {
        bestq = dVar2;
        bestmime = givenmime;
      }
    }
  }
  if (bestmime == (char *)0x0) {
    if (paccept != (char *)0x0) {
      free(paccept);
    }
    local_28 = -1;
  }
  else {
    iVar1 = strcmp(bestmime,"*");
    if (iVar1 == 0) {
      HTSACopy(best_csname,"utf-8");
    }
    else {
      HTSACopy(best_csname,bestmime);
    }
    if (paccept != (char *)0x0) {
      free(paccept);
      paccept = (char *)0x0;
    }
    if (bestq <= 0.00000000) {
      local_28 = -1;
    }
    else {
      local_28 = UCGetLYhndl_byMIME(*best_csname);
    }
  }
  return local_28;
}



void load_a_file(char *val_used,bstring **result)

{
  int iVar1;
  FILE *fp;
  char *Msg;
  size_t len;
  int in_GS_OFFSET;
  size_t bytes;
  FILE *fd;
  char buffer [257];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (WWW_TraceFlag != '\0') {
    fp = TraceFP();
    fprintf((FILE *)fp,"Ok, about to convert %s to mime/thingy\n",val_used);
  }
  if (*val_used != '\0') {
    fp = (FILE *)fopen64(val_used,"rb");
    if (fp == (FILE *)0x0) {
      Msg = (char *)gettext("Can\'t open file for uploading");
      HTAlert(Msg);
    }
    else {
      while( true ) {
        len = fread(buffer,1,0x100,(FILE *)fp);
        if (len == 0) break;
        HTSABCat(result,buffer,len);
      }
      LYCloseInput(fp);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * guess_content_type(char *filename)

{
  HTFormat pHVar1;
  char *local_18;
  HTFormat format;
  char *desc;
  HTAtom *encoding;
  
  pHVar1 = HTFileFormat(filename,&encoding,&desc);
  if (((pHVar1 == (HTFormat)0x0) || (pHVar1->name == (char *)0x0)) || (*pHVar1->name == '\0')) {
    local_18 = "text/plain";
  }
  else {
    local_18 = pHVar1->name;
  }
  return local_18;
}



void cannot_transcode(BOOLEAN *had_warning,char *target_csname)

{
  char *message;
  char *local_8;
  
  if (*had_warning == '\0') {
    *had_warning = '\x01';
    mustshow = '\x01';
    if (target_csname == (char *)0x0) {
      local_8 = "UNKNOWN";
    }
    else {
      local_8 = target_csname;
    }
    message = (char *)gettext("Warning: Cannot transcode form data to charset %s!");
    user_message(message,local_8);
    LYSleepAlert();
  }
  return;
}



uint check_form_specialchars(char *value)

{
  char *p;
  uint result;
  
  result = 0;
  p = value;
  while (((p != (char *)0x0 && (*p != '\0')) && (result != 3))) {
    if (((*p == '\x01') || (*p == '\x02')) || (*p == '\a')) {
      result = result | 2;
    }
    else {
      if (*p < '\0') {
        result = result | 1;
      }
    }
    p = p + 1;
  }
  return result;
}



void UpdateBoundary(char **Boundary,bstring *data)

{
  int iVar1;
  ushort **ppuVar2;
  int local_30;
  char *local_2c;
  char local_25;
  char *want;
  char *text;
  int last;
  int have;
  int j;
  char temp [2];
  
  have = strlen(*Boundary);
  if (data == (bstring *)0x0) {
    local_30 = 0;
    local_2c = (char *)0x0;
  }
  else {
    local_30 = data->len;
    local_2c = data->str;
  }
  want = *Boundary;
  j = 0;
  while (j <= local_30 - have) {
    if ((*want == local_2c[j]) && (iVar1 = memcmp(want,local_2c + j,have), iVar1 == 0)) {
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)local_2c[have + j]] & 0x800) == 0) {
        local_25 = '0';
      }
      else {
        local_25 = 'a';
      }
      temp[0] = local_25;
      temp[1] = '\0';
      HTSACat(&want,temp);
      have = have + 1;
    }
    j = j + 1;
  }
  *Boundary = want;
  return;
}



char * convert_to_base64(char *src,int len)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  char *pcVar4;
  char "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [65];
  char *pcVar5;
  char *e_1;
  char *c_1;
  char *e;
  char *c;
  int chunk;
  int eollen;
  char *str;
  char *r;
  char *eol;
  int rlen;
  char *dest;
  uchar c3;
  uchar c2;
  uchar c1;
  
  str = src;
  rlen = ((len + 2) / 3) * 4;
  if (rlen != 0) {
    rlen = rlen + (rlen + -1) / 0x4c + 1;
  }
  pcVar5 = (char *)malloc(rlen + 1);
  if (pcVar5 == (char *)0x0) {
    outofmem("./GridText.c","convert_to_base64");
  }
  chunk = 0;
  r = pcVar5;
  while (0 < len) {
    if (chunk == 0x13) {
      c = "\n";
      while (c < "") {
        *r = *c;
        r = r + 1;
        c = c + 1;
      }
      chunk = 0;
    }
    bVar1 = *str;
    bVar2 = str[1];
    pbVar3 = (byte *)(str + 2);
    *r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[bVar1 >> 2];
    r[1] = *(char *)(((uint)(bVar2 >> 4) | ((uint)bVar1 & 3) << 4) + 0x814e420);
    pcVar4 = r + 2;
    if (len < 3) {
      str = (char *)pbVar3;
      if (len == 2) {
        *pcVar4 = *(char *)(((uint)bVar2 & 0xf) * 4 + 0x814e420);
        r[3] = '=';
      }
      else {
        *pcVar4 = '=';
        r[3] = '=';
      }
    }
    else {
      bVar1 = *pbVar3;
      *pcVar4 = *(char *)(((uint)(bVar1 >> 6) | ((uint)bVar2 & 0xf) * 4) + 0x814e420);
      r[3] = *(char *)(((uint)bVar1 & 0x3f) + 0x814e420);
      str = str + 3;
    }
    r = r + 4;
    len = len + -3;
    chunk = chunk + 1;
  }
  if (rlen != 0) {
    c_1 = "\n";
    while (c_1 < "") {
      *r = *c_1;
      r = r + 1;
      c_1 = c_1 + 1;
    }
  }
  *r = '\0';
  return pcVar5;
}



char * escape_or_quote_name(char *name,QuoteData quoting,char *MultipartContentType)

{
  char *escaped1;
  
  escaped1 = (char *)0x0;
  if (quoting < QUOTE_SPECIAL) {
    if (quoting == NO_QUOTE) {
      HTSACopy(&escaped1,name);
    }
    else {
      HTSACopy(&escaped1,"Content-Disposition: form-data");
      HTSprintf(&escaped1,"; name=\"%s\"",name);
      if (MultipartContentType != (char *)0x0) {
        HTSprintf(&escaped1,MultipartContentType,"text/plain");
      }
      if (quoting == QUOTE_BASE64) {
        HTSACat(&escaped1,"\r\nContent-Transfer-Encoding: base64");
      }
      HTSACat(&escaped1,"\r\n\r\n");
    }
  }
  else {
    if (quoting == QUOTE_SPECIAL) {
      escaped1 = HTEscapeSP(name,'\x01');
    }
  }
  return escaped1;
}



char * escape_or_quote_value(char *value,QuoteData quoting)

{
  size_t len;
  char *local_18;
  char *escaped2;
  
  escaped2 = (char *)0x0;
  if (quoting == QUOTE_BASE64) {
    len = strlen(value);
    escaped2 = convert_to_base64(value,len);
  }
  else {
    if (quoting < QUOTE_BASE64) {
      if (value == (char *)0x0) {
        local_18 = "";
      }
      else {
        local_18 = value;
      }
      HTSACopy(&escaped2,local_18);
    }
    else {
      if (quoting == QUOTE_SPECIAL) {
        escaped2 = HTEscapeSP(value,'\x01');
      }
    }
  }
  return escaped2;
}



int check_if_base64_needed(int submit_method,bstring *data)

{
  byte bVar1;
  bool bVar2;
  FILE *__stream;
  char *local_30;
  int local_2c;
  int local_28;
  int ch;
  int length;
  int n;
  int col;
  char *text;
  int width;
  BOOLEAN printable;
  
  width = 0;
  bVar2 = true;
  if (data == (bstring *)0x0) {
    local_30 = (char *)0x0;
  }
  else {
    local_30 = data->str;
  }
  if (local_30 != (char *)0x0) {
    col = 0;
    if (data == (bstring *)0x0) {
      local_2c = 0;
    }
    else {
      local_2c = data->len;
    }
    n = 0;
    while (n < local_2c) {
      bVar1 = local_30[n];
      if (((char)bVar1 < '\0') || ((bVar1 < 0x20 && (bVar1 != 10)))) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"nonprintable %d:%#x\n",n,(uint)bVar1);
        }
        bVar2 = false;
      }
      if ((bVar1 == 10) || (bVar1 == 0xd)) {
        if (width < col) {
          width = col;
        }
        col = 0;
      }
      else {
        col = col + 1;
      }
      n = n + 1;
    }
    if (width < col) {
      width = col;
    }
  }
  if (((bVar2) || (submit_method != 3)) || (width < 0x49)) {
    local_28 = 0;
  }
  else {
    local_28 = 1;
  }
  return local_28;
}



int HText_SubmitForm(FormInfo *submit_item,DocInfo *doc,char *link_name,char *link_value)

{
  char cVar1;
  int iVar2;
  FormInfo *pFVar3;
  bstring *pbVar4;
  bool bVar5;
  bool bVar6;
  BOOLEAN BVar7;
  FILE *__stream;
  int iVar8;
  uint uVar9;
  uint uVar10;
  char *name;
  char *filename;
  int local_194;
  char *local_190;
  QuoteData local_18c;
  QuoteData local_188;
  char *local_184;
  char *local_17c;
  char *local_178;
  char *local_174;
  char *local_170;
  char *local_16c;
  char *local_168;
  char *local_164;
  char *local_160;
  char *local_15c;
  char *local_154;
  char *local_150;
  char *local_14c;
  char *local_148;
  char *local_144;
  char *local_140;
  char *local_138;
  char *local_134;
  char *local_130;
  int local_128;
  char *local_124;
  char *local_11c;
  char *local_114;
  undefined *local_10c;
  undefined *local_108;
  undefined *local_104;
  undefined *local_100;
  undefined *local_fc;
  undefined *local_f8;
  undefined *local_f4;
  undefined1 *local_ec;
  undefined1 *local_e8;
  undefined *local_e4;
  undefined *local_e0;
  undefined *local_dc;
  undefined *local_d8;
  undefined *local_d4;
  undefined *local_d0;
  char *local_cc;
  char *local_c8;
  undefined *local_c4;
  undefined *local_c0;
  int local_bc;
  char *local_b8;
  int local_b4;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *temp;
  char *t;
  char *marker;
  QuoteData quoting;
  int out_cs;
  FormInfo *form_ptr_1;
  uint name_is_special;
  uint field_is_special;
  char *val;
  FormInfo *form_ptr;
  uint form_is_special;
  int textarea_lineno;
  int target_cs;
  int result;
  int form_number;
  int anchor_limit;
  int anchor_count;
  char *val_used;
  char *previous_blanks;
  char *name_used;
  char *last_textarea_name;
  char *escaped2;
  char *escaped1;
  char *copied_val_used;
  char *copied_name_used;
  char *content_type_out;
  char *MultipartContentType;
  char *Boundary;
  bstring *my_query;
  TextAnchor *anchor_ptr;
  PostData *my_data;
  PerFormInfo *thisform;
  char *target_csname;
  char *out_csname;
  BOOLEAN first_one;
  BOOLEAN skip_field;
  BOOLEAN SemiColon;
  BOOLEAN PlainText;
  BOOLEAN success;
  BOOLEAN have_accept_cs;
  BOOLEAN had_chartrans_warning;
  
  had_chartrans_warning = '\0';
  bVar5 = false;
  PlainText = '\0';
  bVar6 = false;
  target_csname = (char *)0x0;
  my_data = (PostData *)0x0;
  my_query = (bstring *)0x0;
  Boundary = (char *)0x0;
  MultipartContentType = (char *)0x0;
  content_type_out = (char *)0x0;
  copied_name_used = (char *)0x0;
  copied_val_used = (char *)0x0;
  escaped1 = (char *)0x0;
  escaped2 = (char *)0x0;
  last_textarea_name = (char *)0x0;
  previous_blanks = (char *)0x0;
  val_used = "";
  anchor_count = 0;
  anchor_limit = 0;
  iVar2 = submit_item->number;
  target_cs = -1;
  textarea_lineno = 0;
  form_is_special = 0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SubmitForm\n  link_name=%s\n  link_value=%s\n",link_name,link_value);
  }
  if (HTMainText == (HText *)0x0) {
    local_194 = 0;
  }
  else {
    thisform = (PerFormInfo *)HTList_objectAt(HTMainText->forms,iVar2 + -1);
    if (thisform == (PerFormInfo *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SubmitForm: form %d not in HTMainText\'s list!\n",iVar2);
      }
    }
    else {
      if (thisform->number != iVar2) {
        if (WWW_TraceFlag != '\0') {
          iVar8 = thisform->number;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SubmitForm: failed sanity check, %d!=%d !\n",iVar8,iVar2);
        }
        thisform = (PerFormInfo *)0x0;
      }
    }
    if ((submit_item->submit_action == (char *)0x0) || (*submit_item->submit_action == '\0')) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SubmitForm: no action given\n");
      }
      local_194 = 0;
    }
    else {
      if ((submit_item->submit_method == 3) &&
         (iVar8 = strncasecomp(submit_item->submit_action,"mailto:",7), iVar8 != 0)) {
        name = (char *)gettext("Malformed mailto form submission!  Cancelled!");
        HTAlert(name);
        local_194 = 0;
      }
      else {
        if ((submit_item->submit_enctype == (char *)0x0) ||
           (iVar8 = strncasecomp(submit_item->submit_enctype,"text/plain",10), iVar8 != 0)) {
          if ((submit_item->submit_enctype == (char *)0x0) ||
             (iVar8 = strncasecomp(submit_item->submit_enctype,"application/sgml-form-urlencoded",
                                   0x20), iVar8 != 0)) {
            if ((submit_item->submit_enctype != (char *)0x0) &&
               (iVar8 = strncasecomp(submit_item->submit_enctype,"multipart/form-data",0x13),
               iVar8 == 0)) {
              Boundary = "xnyLAaB03X";
            }
          }
          else {
            bVar6 = true;
          }
        }
        else {
          PlainText = '\x01';
        }
        if (((thisform != (PerFormInfo *)0x0) && (submit_item->accept_cs != (char *)0x0)) &&
           (iVar8 = strcasecomp(submit_item->accept_cs,"UNKNOWN"), iVar8 != 0)) {
          bVar5 = true;
          target_cs = find_best_target_cs(&thisform->thisacceptcs,current_char_set,
                                          submit_item->accept_cs);
        }
        if (((thisform != (PerFormInfo *)0x0) && (!bVar5)) &&
           ((thisform->accept_cs != (char *)0x0 &&
            (iVar8 = strcasecomp(thisform->accept_cs,"UNKNOWN"), iVar8 != 0)))) {
          bVar5 = true;
          target_cs = find_best_target_cs(&thisform->thisacceptcs,current_char_set,
                                          thisform->accept_cs);
        }
        if (((bVar5) && (-1 < target_cs)) && (thisform->thisacceptcs != (char *)0x0)) {
          target_csname = thisform->thisacceptcs;
        }
        if (((target_cs < 0) && (HTMainText->node_anchor->charset != (char *)0x0)) &&
           (*HTMainText->node_anchor->charset != '\0')) {
          target_cs = UCGetLYhndl_byMIME(HTMainText->node_anchor->charset);
          if (target_cs < 0) {
            target_cs = UCLYhndl_for_unspec;
            target_csname = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
          }
          else {
            target_csname = HTMainText->node_anchor->charset;
          }
        }
        if (target_cs < 0) {
          target_cs = UCLYhndl_for_unspec;
        }
        anchor_ptr = HTMainText->first_anchor;
        while (anchor_ptr != (TextAnchor *)0x0) {
          if (anchor_ptr->link_type == '\x02') {
            if ((anchor_ptr->input_field->number == iVar2) &&
               (anchor_ptr->input_field->disabled == 0)) {
              pFVar3 = anchor_ptr->input_field;
              if (pFVar3->cp_submit_value == (char *)0x0) {
                local_190 = pFVar3->value;
              }
              else {
                local_190 = pFVar3->cp_submit_value;
              }
              uVar9 = check_form_specialchars(local_190);
              uVar10 = check_form_specialchars(pFVar3->name);
              form_is_special = uVar9 | uVar10;
              if (((((uVar9 != 0) && (-1 < target_cs)) &&
                   (((uVar9 & 1) != 0 ||
                    ((LYCharSet_UC[target_cs].enc != 2 &&
                     (((&LYCharSet_UC[0].codepage)[(target_cs * 2 + 1) * 4] & 0x80U) == 0)))))) &&
                  (BVar7 = UCNeedNotTranslate(pFVar3->value_cs,target_cs), BVar7 == '\0')) &&
                 (BVar7 = UCCanTranslateFromTo(pFVar3->value_cs,target_cs), BVar7 == '\0')) {
                BVar7 = UCCanTranslateFromTo(target_cs,pFVar3->value_cs);
                if (BVar7 == '\0') {
                  target_cs = -1;
                }
                else {
                  target_cs = pFVar3->value_cs;
                  target_csname = (char *)0x0;
                }
              }
              if (((uVar10 != 0) && (-1 < target_cs)) &&
                 (((((uVar10 & 1) != 0 ||
                    ((LYCharSet_UC[target_cs].enc != 2 &&
                     (((&LYCharSet_UC[0].codepage)[(target_cs * 2 + 1) * 4] & 0x80U) == 0)))) &&
                   (BVar7 = UCNeedNotTranslate(pFVar3->name_cs,target_cs), BVar7 == '\0')) &&
                  (BVar7 = UCCanTranslateFromTo(pFVar3->name_cs,target_cs), BVar7 == '\0')))) {
                BVar7 = UCCanTranslateFromTo(target_cs,pFVar3->name_cs);
                if (BVar7 == '\0') {
                  target_cs = -1;
                }
                else {
                  target_cs = pFVar3->value_cs;
                  target_csname = (char *)0x0;
                }
              }
              anchor_limit = anchor_limit + 1;
            }
            else {
              if (iVar2 < anchor_ptr->input_field->number) break;
            }
          }
          anchor_ptr = (TextAnchor *)anchor_ptr->next;
        }
        if ((anchor_limit != 0) &&
           (my_data = (PostData *)calloc(anchor_limit,0x18), my_data == (PostData *)0x0)) {
          outofmem("./GridText.c","HText_SubmitForm");
        }
        if ((target_csname == (char *)0x0) && (-1 < target_cs)) {
          if ((form_is_special & 1) == 0) {
            if ((form_is_special & 2) == 0) {
              target_csname = "us-ascii";
            }
            else {
              target_csname = LYCharSet_UC[target_cs].MIMEname;
            }
          }
          else {
            target_csname = LYCharSet_UC[target_cs].MIMEname;
          }
        }
        if ((submit_item->submit_method == 1) && (Boundary == (char *)0x0)) {
          temp = (char *)0x0;
          HTSACopy(&temp,submit_item->submit_action);
          strtok(temp,"#");
          strtok(temp,"?");
          HTSACat(&temp,"?");
          HTSABCat0(&my_query,temp);
        }
        else {
          if (bVar6) {
            HTSACopy(&content_type_out,"application/sgml-form-urlencoded");
          }
          else {
            if (PlainText == '\x01') {
              HTSACopy(&content_type_out,"text/plain");
            }
            else {
              if (Boundary == (char *)0x0) {
                HTSACopy(&content_type_out,"application/x-www-form-urlencoded");
              }
              else {
                HTSACopy(&content_type_out,"multipart/form-data");
              }
            }
          }
          if (((bVar5) || ((form_is_special & 1) != 0)) || ((form_is_special & 2) != 0)) {
            if ((target_cs < 0) || (target_csname == (char *)0x0)) {
              cannot_transcode(&had_chartrans_warning,target_csname);
            }
            else {
              if ((Boundary == (char *)0x0) &&
                 (((HTMainText->node_anchor->charset != (char *)0x0 &&
                   ((iVar8 = strcmp(HTMainText->node_anchor->charset,"iso-8859-1"), iVar8 != 0 ||
                    (iVar8 = strcmp(target_csname,"iso-8859-1"), iVar8 != 0)))) ||
                  ((HTMainText->node_anchor->charset == (char *)0x0 &&
                   (target_cs != UCLYhndl_for_unspec)))))) {
                HTSprintf(&content_type_out,"; charset=%s",target_csname);
              }
            }
          }
        }
        out_csname = target_csname;
        anchor_ptr = HTMainText->first_anchor;
        while (anchor_ptr != (TextAnchor *)0x0) {
          if (anchor_ptr->link_type == '\x02') {
            if ((anchor_ptr->input_field->number == iVar2) &&
               (anchor_ptr->input_field->disabled == 0)) {
              pFVar3 = anchor_ptr->input_field;
              if (PlainText == '\0') {
                if (Boundary == (char *)0x0) {
                  local_188 = QUOTE_SPECIAL;
                }
                else {
                  local_188 = QUOTE_MULTI;
                }
                local_18c = local_188;
              }
              else {
                local_18c = NO_QUOTE;
              }
              if (pFVar3->type != 9) {
                textarea_lineno = 0;
              }
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"SubmitForm[%d/%d]: ",anchor_count + 1,anchor_limit);
              }
              if (pFVar3->name == (char *)0x0) {
                local_184 = "";
              }
              else {
                local_184 = pFVar3->name;
              }
              name_used = local_184;
              switch(pFVar3->type) {
              default:
                if (WWW_TraceFlag != '\0') {
                  iVar8 = pFVar3->type;
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"What type is %d?\n",iVar8);
                }
                break;
              case 1:
              case 2:
              case 3:
              case 4:
              case 7:
              case 8:
              case 9:
switchD_080707d1_caseD_1:
                if (pFVar3->cp_submit_value == (char *)0x0) {
                  val_used = pFVar3->value;
                }
                else {
                  val_used = pFVar3->cp_submit_value;
                }
                uVar9 = check_form_specialchars(val_used);
                if (uVar9 == 0) {
                  if (WWW_TraceFlag != '\0') {
                    if (target_csname == (char *)0x0) {
                      local_150 = "???";
                    }
                    else {
                      local_150 = target_csname;
                    }
                    if (pFVar3->name == (char *)0x0) {
                      local_14c = "";
                    }
                    else {
                      local_14c = pFVar3->name;
                    }
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"field \"%s\" %d %s OK\n",local_14c,target_cs,local_150
                           );
                  }
                  success = '\x01';
                }
                else {
                  HTSACopy(&copied_val_used,val_used);
                  success = LYUCTranslateBackFormData
                                      (&copied_val_used,pFVar3->value_cs,target_cs,PlainText);
                  if (WWW_TraceFlag != '\0') {
                    if (success == '\0') {
                      local_164 = "FAILED";
                    }
                    else {
                      local_164 = "OK";
                    }
                    if (target_csname == (char *)0x0) {
                      local_160 = "???";
                    }
                    else {
                      local_160 = target_csname;
                    }
                    if (pFVar3->value_cs < 0) {
                      local_15c = "???";
                    }
                    else {
                      local_15c = LYCharSet_UC[pFVar3->value_cs].MIMEname;
                    }
                    iVar8 = pFVar3->value_cs;
                    if (pFVar3->name == (char *)0x0) {
                      local_154 = "";
                    }
                    else {
                      local_154 = pFVar3->name;
                    }
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"field \"%s\" %d %s -> %d %s %s\n",local_154,iVar8,
                            local_15c,target_cs,local_160,local_164);
                  }
                  if (success != '\0') {
                    val_used = copied_val_used;
                  }
                }
                if (success == '\0') {
                  cannot_transcode(&had_chartrans_warning,target_csname);
                  out_cs = pFVar3->value_cs;
                }
                else {
                  out_cs = target_cs;
                }
                if (-1 < out_cs) {
                  out_csname = LYCharSet_UC[out_cs].MIMEname;
                }
                if (Boundary != (char *)0x0) {
                  HTSACopy(&MultipartContentType,"\r\nContent-Type: %s");
                  if ((success == '\0') && (pFVar3->value_cs < 0)) {
                    out_csname = "UNKNOWN-8BIT";
                  }
                  else {
                    if (success == '\0') {
                      target_csname = (char *)0x0;
                    }
                    else {
                      if (target_csname == (char *)0x0) {
                        target_csname = LYCharSet_UC[target_cs].MIMEname;
                      }
                    }
                  }
                  iVar8 = strcmp(out_csname,"iso-8859-1");
                  if (iVar8 != 0) {
                    HTSprintf(&MultipartContentType,"; charset=%s",out_csname);
                  }
                }
                if ((((pFVar3->type != 9) ||
                     (textarea_lineno = textarea_lineno + 1, textarea_lineno < 2)) ||
                    (last_textarea_name == (char *)0x0)) ||
                   ((pFVar3->name == (char *)0x0 ||
                    (iVar8 = strcmp(last_textarea_name,pFVar3->name), iVar8 != 0)))) {
                  uVar9 = check_form_specialchars(local_184);
                  if (uVar9 == 0) {
                    if (WWW_TraceFlag != '\0') {
                      if (target_csname == (char *)0x0) {
                        local_134 = "???";
                      }
                      else {
                        local_134 = target_csname;
                      }
                      if (pFVar3->name == (char *)0x0) {
                        local_130 = "";
                      }
                      else {
                        local_130 = pFVar3->name;
                      }
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"name \"%s\" %d %s OK\n",local_130,target_cs,
                              local_134);
                    }
                    success = '\x01';
                    if (Boundary != (char *)0x0) {
                      HTSACopy(&copied_name_used,local_184);
                    }
                  }
                  else {
                    HTSACopy(&copied_name_used,local_184);
                    success = LYUCTranslateBackFormData
                                        (&copied_name_used,pFVar3->name_cs,target_cs,PlainText);
                    if (WWW_TraceFlag != '\0') {
                      if (success == '\0') {
                        local_148 = "FAILED";
                      }
                      else {
                        local_148 = "OK";
                      }
                      if (target_csname == (char *)0x0) {
                        local_144 = "???";
                      }
                      else {
                        local_144 = target_csname;
                      }
                      if (pFVar3->name_cs < 0) {
                        local_140 = "???";
                      }
                      else {
                        local_140 = LYCharSet_UC[pFVar3->name_cs].MIMEname;
                      }
                      iVar8 = pFVar3->name_cs;
                      if (pFVar3->name == (char *)0x0) {
                        local_138 = "";
                      }
                      else {
                        local_138 = pFVar3->name;
                      }
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"name \"%s\" %d %s -> %d %s %s\n",local_138,iVar8,
                              local_140,target_cs,local_144,local_148);
                    }
                    if (success != '\0') {
                      name_used = copied_name_used;
                    }
                    if (Boundary != (char *)0x0) {
                      if (success == '\0') {
                        HTSACopy(&MultipartContentType,"");
                        target_csname = (char *)0x0;
                      }
                      else {
                        if (target_csname == (char *)0x0) {
                          target_csname = LYCharSet_UC[target_cs].MIMEname;
                        }
                      }
                    }
                  }
                  if (success == '\0') {
                    cannot_transcode(&had_chartrans_warning,target_csname);
                  }
                  if (Boundary != (char *)0x0) {
                    HTMake822Word(&copied_name_used,0);
                    name_used = copied_name_used;
                  }
                }
                break;
              case 5:
              case 0xc:
              case 0xd:
                if (((pFVar3->name == (char *)0x0) || (*pFVar3->name == '\0')) ||
                   (iVar8 = strcmp(pFVar3->name,link_name), iVar8 != 0)) {
                  if (WWW_TraceFlag != '\0') {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"skipping submit field with ");
                  }
                  if (WWW_TraceFlag != '\0') {
                    if ((pFVar3->name == (char *)0x0) || (*pFVar3->name == '\0')) {
                      local_178 = "no field name";
                    }
                    else {
                      local_178 = "not current link";
                    }
                    if (link_name == (char *)0x0) {
                      local_174 = "???";
                    }
                    else {
                      local_174 = link_name;
                    }
                    if (pFVar3->name == (char *)0x0) {
                      local_170 = "???";
                    }
                    else {
                      local_170 = pFVar3->name;
                    }
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"name \"%s\" for link_name \"%s\", %s.\n",local_170,
                            local_174,local_178);
                  }
                }
                else {
                  if ((pFVar3->type == 0xc) ||
                     (((pFVar3->value != (char *)0x0 && (*pFVar3->value != '\0')) &&
                      (iVar8 = strcmp(pFVar3->value,link_value), iVar8 == 0))))
                  goto switchD_080707d1_caseD_1;
                  if (WWW_TraceFlag != '\0') {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"skipping submit field with ");
                  }
                  if (WWW_TraceFlag != '\0') {
                    if (link_name == (char *)0x0) {
                      local_16c = "???";
                    }
                    else {
                      local_16c = link_name;
                    }
                    if (pFVar3->name == (char *)0x0) {
                      local_168 = "???";
                    }
                    else {
                      local_168 = pFVar3->name;
                    }
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"name \"%s\" for link_name \"%s\", %s!\n",local_168,
                            local_16c,"values are different");
                  }
                }
                break;
              case 6:
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"reset\n");
                }
                break;
              case 0xb:
                if (pFVar3->value == (char *)0x0) {
                  local_17c = "";
                }
                else {
                  local_17c = pFVar3->value;
                }
                val_used = local_17c;
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"I will submit %s (from %s)\n",local_17c,local_184);
                }
              }
              bVar5 = false;
              my_data[anchor_count].first = '\x01';
              my_data[anchor_count].type = pFVar3->type;
              switch(pFVar3->type) {
              default:
                bVar5 = true;
                break;
              case 1:
              case 2:
              case 7:
              case 8:
                break;
              case 3:
              case 4:
                if (pFVar3->num_value == 0) {
                  bVar5 = true;
                }
                break;
              case 5:
              case 0xc:
              case 0xd:
                if ((((pFVar3->name == (char *)0x0) || (*pFVar3->name == '\0')) ||
                    (iVar8 = strcmp(pFVar3->name,link_name), iVar8 != 0)) ||
                   ((pFVar3->type != 0xc &&
                    (((pFVar3->value == (char *)0x0 || (*pFVar3->value == '\0')) ||
                     (iVar8 = strcmp(pFVar3->value,link_value), iVar8 != 0)))))) {
                  bVar5 = true;
                }
                break;
              case 9:
                if ((last_textarea_name == (char *)0x0) ||
                   (iVar8 = strcmp(last_textarea_name,pFVar3->name), iVar8 != 0)) {
                  textarea_lineno = 1;
                  last_textarea_name = pFVar3->name;
                }
                else {
                  my_data[anchor_count].first = '\0';
                }
                break;
              case 0xb:
                load_a_file(val_used,&my_data[anchor_count].data);
              }
              if (!bVar5) {
                HTSACopy(&my_data[anchor_count].name,name_used);
                HTSACopy(&my_data[anchor_count].value,val_used);
                if (my_data[anchor_count].data == (bstring *)0x0) {
                  HTSABCat0(&my_data[anchor_count].data,val_used);
                }
                my_data[anchor_count].quote = local_18c;
                if ((local_18c == QUOTE_MULTI) &&
                   (iVar8 = check_if_base64_needed
                                      (submit_item->submit_method,my_data[anchor_count].data),
                   iVar8 != 0)) {
                  if (WWW_TraceFlag != '\0') {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"will encode as base64\n");
                  }
                  my_data[anchor_count].quote = QUOTE_BASE64;
                  if (my_data[anchor_count].data == (bstring *)0x0) {
                    local_128 = 0;
                  }
                  else {
                    local_128 = (my_data[anchor_count].data)->len;
                  }
                  if (my_data[anchor_count].data == (bstring *)0x0) {
                    local_124 = (char *)0x0;
                  }
                  else {
                    local_124 = (my_data[anchor_count].data)->str;
                  }
                  escaped2 = convert_to_base64(local_124,local_128);
                  HTSABCopy0(&my_data[anchor_count].data,escaped2);
                  if (escaped2 != (char *)0x0) {
                    free(escaped2);
                    escaped2 = (char *)0x0;
                  }
                }
              }
              anchor_count = anchor_count + 1;
              if (copied_name_used != (char *)0x0) {
                free(copied_name_used);
                copied_name_used = (char *)0x0;
              }
              if (copied_val_used != (char *)0x0) {
                free(copied_val_used);
                copied_val_used = (char *)0x0;
              }
            }
            else {
              if (iVar2 < anchor_ptr->input_field->number) break;
            }
          }
          anchor_ptr = (TextAnchor *)anchor_ptr->next;
        }
        if (copied_name_used != (char *)0x0) {
          free(copied_name_used);
          copied_name_used = (char *)0x0;
        }
        if (my_data != (PostData *)0x0) {
          bVar5 = true;
          if ((content_type_out != (char *)0x0) && (Boundary != (char *)0x0)) {
            Boundary = (char *)0x0;
            HTSACopy(&Boundary,"LYNX");
            anchor_count = 0;
            while (anchor_count < anchor_limit) {
              if (my_data[anchor_count].data != (bstring *)0x0) {
                UpdateBoundary(&Boundary,my_data[anchor_count].data);
              }
              anchor_count = anchor_count + 1;
            }
            HTSprintf(&content_type_out,"; boundary=%s",Boundary);
          }
          anchor_count = 0;
          while (anchor_count < anchor_limit) {
            if ((my_data[anchor_count].name != (char *)0x0) &&
               (my_data[anchor_count].value != (char *)0x0)) {
              if (WWW_TraceFlag != '\0') {
                pbVar4 = my_data[anchor_count].data;
                if (my_data[anchor_count].value == (char *)0x0) {
                  local_11c = "";
                }
                else {
                  local_11c = my_data[anchor_count].value;
                }
                cVar1 = my_data[anchor_count].first;
                if (my_data[anchor_count].name == (char *)0x0) {
                  local_114 = "";
                }
                else {
                  local_114 = my_data[anchor_count].name;
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,"processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n"
                        ,anchor_count + 1,anchor_limit,local_114,(int)cVar1,local_11c,pbVar4);
              }
              if (my_data[anchor_count].first != '\0') {
                if (bVar5) {
                  if (Boundary != (char *)0x0) {
                    HTBprintf(&my_query,"--%s\r\n",Boundary);
                  }
                  bVar5 = false;
                }
                else {
                  if (PlainText == '\0') {
                    if (bVar6) {
                      HTSABCat0(&my_query,";");
                    }
                    else {
                      if (Boundary == (char *)0x0) {
                        HTSABCat0(&my_query,"&");
                      }
                      else {
                        HTBprintf(&my_query,"\r\n--%s\r\n",Boundary);
                      }
                    }
                  }
                  else {
                    HTSABCat0(&my_query,"\n");
                  }
                }
              }
              HTSABCat(&my_data[anchor_count].data,"",1);
              name = my_data[anchor_count].name;
              filename = my_data[anchor_count].value;
              switch(my_data[anchor_count].type) {
              case 1:
              case 2:
              case 7:
              case 8:
                escaped1 = escape_or_quote_name
                                     (my_data[anchor_count].name,my_data[anchor_count].quote,
                                      MultipartContentType);
                escaped2 = escape_or_quote_value(filename,my_data[anchor_count].quote);
                if ((PlainText == '\0') || (*escaped2 == '\0')) {
                  local_10c = &DAT_0814cbac;
                }
                else {
                  local_10c = &DAT_0814d205;
                }
                if (PlainText == '\0') {
                  local_108 = &DAT_0814cbac;
                }
                else {
                  local_108 = &DAT_0814d205;
                }
                if (Boundary == (char *)0x0) {
                  local_104 = &DAT_0814e81f;
                }
                else {
                  local_104 = &DAT_0814cbac;
                }
                HTBprintf(&my_query,"%s%s%s%s%s",escaped1,local_104,local_108,escaped2,local_10c);
                break;
              case 3:
              case 4:
                escaped1 = escape_or_quote_name
                                     (my_data[anchor_count].name,my_data[anchor_count].quote,
                                      MultipartContentType);
                escaped2 = escape_or_quote_value(filename,my_data[anchor_count].quote);
                if ((PlainText == '\0') || (*escaped2 == '\0')) {
                  local_100 = &DAT_0814cbac;
                }
                else {
                  local_100 = &DAT_0814d205;
                }
                if (PlainText == '\0') {
                  local_fc = &DAT_0814cbac;
                }
                else {
                  local_fc = &DAT_0814d205;
                }
                if (Boundary == (char *)0x0) {
                  local_f8 = &DAT_0814e81f;
                }
                else {
                  local_f8 = &DAT_0814cbac;
                }
                HTBprintf(&my_query,"%s%s%s%s%s",escaped1,local_f8,local_fc,escaped2,local_100);
                break;
              case 5:
              case 0xc:
              case 0xd:
                escaped1 = escape_or_quote_name
                                     (my_data[anchor_count].name,my_data[anchor_count].quote,
                                      MultipartContentType);
                escaped2 = escape_or_quote_value(filename,my_data[anchor_count].quote);
                if (my_data[anchor_count].type == 0xd) {
                  if (Boundary == (char *)0x0) {
                    if ((PlainText == '\0') || (*escaped1 == '\0')) {
                      local_f4 = &DAT_0814cbac;
                    }
                    else {
                      local_f4 = &DAT_0814d205;
                    }
                    if (PlainText == '\0') {
                      if (bVar6) {
                        local_e8 = &DAT_0814e38c;
                      }
                      else {
                        local_e8 = &DAT_0814e81d;
                      }
                      local_ec = local_e8;
                    }
                    else {
                      local_ec = &DAT_0814d205;
                    }
                    HTBprintf(&my_query,"%s.x=0%s%s.y=0%s",escaped1,local_ec,escaped1,local_f4);
                  }
                  else {
                    name = strchr(escaped1,0x3d);
                    name[1] = '\0';
                    HTBprintf(&my_query,"%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",
                              escaped1,my_data[anchor_count].name,Boundary,escaped1,
                              my_data[anchor_count].name);
                  }
                }
                else {
                  if ((PlainText == '\0') || (*escaped2 == '\0')) {
                    local_e4 = &DAT_0814cbac;
                  }
                  else {
                    local_e4 = &DAT_0814d205;
                  }
                  if (PlainText == '\0') {
                    local_e0 = &DAT_0814cbac;
                  }
                  else {
                    local_e0 = &DAT_0814d205;
                  }
                  if (Boundary == (char *)0x0) {
                    local_dc = &DAT_0814e81f;
                  }
                  else {
                    local_dc = &DAT_0814cbac;
                  }
                  HTBprintf(&my_query,"%s%s%s%s%s",escaped1,local_dc,local_e0,escaped2,local_e4);
                }
                break;
              case 9:
                escaped2 = escape_or_quote_value(filename,my_data[anchor_count].quote);
                if (my_data[anchor_count].first == '\0') {
                  if (PlainText == '\0') {
                    if (Boundary == (char *)0x0) {
                      local_c8 = "%0d%0a";
                    }
                    else {
                      local_c8 = "\r\n";
                    }
                    local_cc = local_c8;
                  }
                  else {
                    local_cc = "\n";
                  }
                  if (*escaped2 == '\0') {
                    HTSACat(&previous_blanks,local_cc);
                  }
                  else {
                    if ((previous_blanks != (char *)0x0) &&
                       (HTSABCat0(&my_query,previous_blanks), previous_blanks != (char *)0x0)) {
                      free(previous_blanks);
                      previous_blanks = (char *)0x0;
                    }
                    HTSABCat0(&my_query,escaped2);
                    if ((PlainText == '\0') && (Boundary == (char *)0x0)) {
                      HTSACopy(&previous_blanks,local_cc);
                    }
                    else {
                      HTSABCat0(&my_query,local_cc);
                    }
                  }
                }
                else {
                  if (PlainText == '\0') {
                    if (Boundary == (char *)0x0) {
                      HTSACopy(&previous_blanks,"%0d%0a");
                    }
                    else {
                      HTSACopy(&previous_blanks,"\r\n");
                    }
                  }
                  else {
                    if (previous_blanks != (char *)0x0) {
                      free(previous_blanks);
                      previous_blanks = (char *)0x0;
                    }
                  }
                  escaped1 = escape_or_quote_name
                                       (name,my_data[anchor_count].quote,MultipartContentType);
                  if ((PlainText == '\0') || (*escaped2 == '\0')) {
                    local_d8 = &DAT_0814cbac;
                  }
                  else {
                    local_d8 = &DAT_0814d205;
                  }
                  if (PlainText == '\0') {
                    local_d4 = &DAT_0814cbac;
                  }
                  else {
                    local_d4 = &DAT_0814d205;
                  }
                  if (Boundary == (char *)0x0) {
                    local_d0 = &DAT_0814e81f;
                  }
                  else {
                    local_d0 = &DAT_0814cbac;
                  }
                  HTBprintf(&my_query,"%s%s%s%s%s",escaped1,local_d0,local_d4,escaped2,local_d8);
                }
                break;
              case 0xb:
                if (PlainText == '\0') {
                  if (Boundary == (char *)0x0) {
                    escaped1 = HTEscapeSP(my_data[anchor_count].name,'\x01');
                  }
                  else {
                    name = guess_content_type(filename);
                    temp = (char *)0x0;
                    HTSACopy(&escaped1,"Content-Disposition: form-data");
                    HTSprintf(&escaped1,"; name=\"%s\"",my_data[anchor_count].name);
                    HTSACopy(&temp,filename);
                    HTMake822Word(&temp,0);
                    HTSprintf(&escaped1,"; filename=\"%s\"",temp);
                    if (temp != (char *)0x0) {
                      free(temp);
                      temp = (char *)0x0;
                    }
                    HTSprintf(&escaped1,"\r\nContent-Type: %s",name);
                    if (my_data[anchor_count].quote == QUOTE_BASE64) {
                      HTSACat(&escaped1,"\r\nContent-Transfer-Encoding: base64");
                    }
                    HTSACat(&escaped1,"\r\n\r\n");
                  }
                }
                else {
                  HTSACopy(&escaped1,my_data[anchor_count].name);
                }
                if (PlainText == '\0') {
                  local_c4 = &DAT_0814cbac;
                }
                else {
                  local_c4 = &DAT_0814d205;
                }
                if (Boundary == (char *)0x0) {
                  local_c0 = &DAT_0814e81f;
                }
                else {
                  local_c0 = &DAT_0814cbac;
                }
                HTBprintf(&my_query,"%s%s%s",escaped1,local_c0,local_c4);
                if ((my_data[anchor_count].data != (bstring *)0x0) &&
                   (1 < (my_data[anchor_count].data)->len)) {
                  if (my_data[anchor_count].data == (bstring *)0x0) {
                    local_bc = -1;
                  }
                  else {
                    local_bc = (my_data[anchor_count].data)->len + -1;
                  }
                  if (my_data[anchor_count].data == (bstring *)0x0) {
                    local_b8 = (char *)0x0;
                  }
                  else {
                    local_b8 = (my_data[anchor_count].data)->str;
                  }
                  HTSABCat(&my_query,local_b8,local_bc);
                  if (PlainText != '\0') {
                    HTBprintf(&my_query,"\n",local_bc,local_c0,local_c4);
                  }
                }
              }
              if (escaped1 != (char *)0x0) {
                free(escaped1);
                escaped1 = (char *)0x0;
              }
              if (escaped2 != (char *)0x0) {
                free(escaped2);
                escaped2 = (char *)0x0;
              }
            }
            anchor_count = anchor_count + 1;
          }
          if (Boundary != (char *)0x0) {
            HTBprintf(&my_query,"\r\n--%s--\r\n",Boundary);
          }
          if (WWW_TraceFlag != '\0') {
            if (WWW_TraceFlag != '\0') {
              if (my_query == (bstring *)0x0) {
                local_b4 = 0;
              }
              else {
                local_b4 = my_query->len;
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,"Query %d{",local_b4);
            }
            trace_bstring(my_query);
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"}\n");
            }
          }
        }
        if (submit_item->submit_method == 3) {
          name = submit_item->submit_action;
          filename = (char *)gettext("Submitting %s");
          HTUserMsg2(filename,name);
          HTSABCat(&my_query,"",1);
          name = content_type_out;
          if (my_query == (bstring *)0x0) {
            local_ac = (char *)0x0;
          }
          else {
            local_ac = my_query->str;
          }
          if ((submit_item->submit_title == (char *)0x0) || (*submit_item->submit_title == '\0')) {
            filename = HText_getTitle();
            if (filename == (char *)0x0) {
              local_a4 = "";
            }
            else {
              local_a4 = HText_getTitle();
            }
            local_a8 = local_a4;
          }
          else {
            local_a8 = submit_item->submit_title;
          }
          mailform(submit_item->submit_action + 7,local_a8,local_ac,name);
          result = 0;
          HTSABFree(&my_query);
          if (content_type_out != (char *)0x0) {
            free(content_type_out);
            content_type_out = (char *)0x0;
          }
        }
        else {
          mustshow = '\x01';
          name = (char *)gettext("Submitting form...");
          statusline(name);
          if ((submit_item->submit_method == 2) || (Boundary != (char *)0x0)) {
            LYFreePostData(doc);
            name = content_type_out;
            doc->post_data = my_query;
            doc->post_content_type = content_type_out;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"GridText - post_data set:\n%s\n",name);
            }
            HTSACopy(&doc->address,submit_item->submit_action);
          }
          else {
            HTSABCat(&my_query,"",1);
            if (my_query == (bstring *)0x0) {
              local_a0 = (char *)0x0;
            }
            else {
              local_a0 = my_query->str;
            }
            HTSACopy(&doc->address,local_a0);
            LYFreePostData(doc);
            if (content_type_out != (char *)0x0) {
              free(content_type_out);
              content_type_out = (char *)0x0;
            }
          }
          result = 1;
        }
        if (MultipartContentType != (char *)0x0) {
          free(MultipartContentType);
          MultipartContentType = (char *)0x0;
        }
        if (previous_blanks != (char *)0x0) {
          free(previous_blanks);
          previous_blanks = (char *)0x0;
        }
        if (Boundary != (char *)0x0) {
          free(Boundary);
          Boundary = (char *)0x0;
        }
        if (my_data != (PostData *)0x0) {
          anchor_count = 0;
          while (anchor_count < anchor_limit) {
            if (my_data[anchor_count].name != (char *)0x0) {
              free(my_data[anchor_count].name);
              my_data[anchor_count].name = (char *)0x0;
            }
            if (my_data[anchor_count].value != (char *)0x0) {
              free(my_data[anchor_count].value);
              my_data[anchor_count].value = (char *)0x0;
            }
            HTSABFree(&my_data[anchor_count].data);
            anchor_count = anchor_count + 1;
          }
          if (my_data != (PostData *)0x0) {
            free(my_data);
          }
        }
        local_194 = result;
      }
    }
  }
  return local_194;
}



void HText_DisableCurrentForm(void)

{
  TextAnchor *anchor_ptr;
  
  HTFormDisabled = '\x01';
  if (HTMainText != (HText *)0x0) {
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      if ((anchor_ptr->link_type == '\x02') && (anchor_ptr->input_field->number == HTFormNumber)) {
        anchor_ptr->input_field->disabled = 1;
      }
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
  }
  return;
}



void HText_ResetForm(FormInfo *form)

{
  char *text;
  TextAnchor *anchor_ptr;
  
  mustshow = '\x01';
  text = (char *)gettext("Resetting form...");
  statusline(text);
  if (HTMainText != (HText *)0x0) {
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      if (anchor_ptr->link_type == '\x02') {
        if (anchor_ptr->input_field->number == form->number) {
          if ((anchor_ptr->input_field->type == 4) || (anchor_ptr->input_field->type == 3)) {
            if (*anchor_ptr->input_field->orig_value == '0') {
              anchor_ptr->input_field->num_value = 0;
            }
            else {
              anchor_ptr->input_field->num_value = 1;
            }
          }
          else {
            if (anchor_ptr->input_field->type == 7) {
              anchor_ptr->input_field->value = anchor_ptr->input_field->orig_value;
              anchor_ptr->input_field->cp_submit_value = anchor_ptr->input_field->orig_submit_value;
            }
            else {
              HTSACopy(&anchor_ptr->input_field->value,anchor_ptr->input_field->orig_value);
            }
          }
        }
        else {
          if (form->number < anchor_ptr->input_field->number) {
            return;
          }
        }
      }
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
  }
  return;
}



BOOLEAN HText_HaveUserChangedForms(HText *text)

{
  int iVar1;
  TextAnchor *anchor_ptr;
  
  if (text != (HText *)0x0) {
    anchor_ptr = text->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      if (anchor_ptr->link_type == '\x02') {
        if ((anchor_ptr->input_field->type == 4) || (anchor_ptr->input_field->type == 3)) {
          if (((*anchor_ptr->input_field->orig_value == '0') &&
              (anchor_ptr->input_field->num_value == 1)) ||
             ((*anchor_ptr->input_field->orig_value != '0' &&
              (anchor_ptr->input_field->num_value == 0)))) {
            return '\x01';
          }
        }
        else {
          if (anchor_ptr->input_field->type == 7) {
            iVar1 = strcmp(anchor_ptr->input_field->value,anchor_ptr->input_field->orig_value);
            if (iVar1 != 0) {
              return '\x01';
            }
            iVar1 = strcmp(anchor_ptr->input_field->cp_submit_value,
                           anchor_ptr->input_field->orig_submit_value);
            if (iVar1 != 0) {
              return '\x01';
            }
          }
          else {
            iVar1 = strcmp(anchor_ptr->input_field->value,anchor_ptr->input_field->orig_value);
            if (iVar1 != 0) {
              return '\x01';
            }
          }
        }
      }
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
  }
  return '\0';
}



void HText_activateRadioButton(FormInfo *form)

{
  int iVar1;
  int iVar2;
  int form_number;
  TextAnchor *anchor_ptr;
  
  iVar1 = form->number;
  if (HTMainText != (HText *)0x0) {
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      if ((anchor_ptr->link_type == '\x02') && (anchor_ptr->input_field->type == 4)) {
        if (anchor_ptr->input_field->number == iVar1) {
          iVar2 = strcmp(anchor_ptr->input_field->name,form->name);
          if ((iVar2 == 0) && (anchor_ptr->input_field->num_value != 0)) {
            anchor_ptr->input_field->num_value = 0;
            break;
          }
        }
        else {
          if (iVar1 < anchor_ptr->input_field->number) break;
        }
      }
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
    form->num_value = 1;
  }
  return;
}



char * stub_HTAnchor_address(HTAnchor *me)

{
  char *addr;
  
  addr = (char *)0x0;
  if (me != (HTAnchor *)0x0) {
    HTSACopy(&addr,me->parent->address);
  }
  return addr;
}



void HText_setToolbar(HText *text)

{
  if (text != (HText *)0x0) {
    text->toolbar = '\x01';
  }
  return;
}



BOOLEAN HText_hasToolbar(HText *text)

{
  BOOLEAN local_8;
  
  if ((text == (HText *)0x0) || (text->toolbar == '\0')) {
    local_8 = '\0';
  }
  else {
    local_8 = '\x01';
  }
  return local_8;
}



void HText_setNoCache(HText *text)

{
  if (text != (HText *)0x0) {
    text->no_cache = '\x01';
  }
  return;
}



BOOLEAN HText_hasNoCacheSet(HText *text)

{
  BOOLEAN local_8;
  
  if ((text == (HText *)0x0) || (text->no_cache == '\0')) {
    local_8 = '\0';
  }
  else {
    local_8 = '\x01';
  }
  return local_8;
}



BOOLEAN HText_hasUTF8OutputSet(HText *text)

{
  BOOLEAN local_8;
  
  if ((text == (HText *)0x0) || ((text->T).output_utf8 == '\0')) {
    local_8 = '\0';
  }
  else {
    local_8 = '\x01';
  }
  return local_8;
}



void HText_setKcode(HText *text,char *charset,LYUCcharset *p_in)

{
  int iVar1;
  bool bVar2;
  BOOLEAN charset_explicit;
  
  if (text == (HText *)0x0) {
    return;
  }
  if ((charset == (char *)0x0) && (p_in == (LYUCcharset *)0x0)) {
    return;
  }
  bVar2 = charset != (char *)0x0;
  if ((charset == (char *)0x0) || (*charset == '\0')) {
    charset = p_in->MIMEname;
  }
  if (charset == (char *)0x0) {
    return;
  }
  if (*charset == '\0') {
    return;
  }
  if ((bVar2) &&
     (((iVar1 = strcmp(charset,"shift_jis"), iVar1 == 0 ||
       (iVar1 = strcmp(charset,"x-sjis"), iVar1 == 0)) ||
      (iVar1 = strcmp(charset,"x-shift-jis"), iVar1 == 0)))) {
    text->kcode = SJIS;
  }
  else {
    if (((bVar2) && (iVar1 = strcmp(charset,"utf-8"), iVar1 != 0)) &&
       (((p_in != (LYUCcharset *)0x0 && (p_in->enc == 5)) ||
        (((((iVar1 = strcmp(charset,"x-euc"), iVar1 == 0 ||
            (iVar1 = strcmp(charset,"euc-jp"), iVar1 == 0)) ||
           ((iVar1 = strncmp(charset,"x-euc-",6), iVar1 == 0 ||
            ((((iVar1 = strcmp(charset,"euc-kr"), iVar1 == 0 ||
               (iVar1 = strcmp(charset,"iso-2022-kr"), iVar1 == 0)) ||
              (iVar1 = strcmp(charset,"big5"), iVar1 == 0)) ||
             ((iVar1 = strcmp(charset,"cn-big5"), iVar1 == 0 ||
              (iVar1 = strcmp(charset,"euc-cn"), iVar1 == 0)))))))) ||
          (iVar1 = strcmp(charset,"gb2312"), iVar1 == 0)) ||
         ((iVar1 = strncmp(charset,"cn-gb",5), iVar1 == 0 ||
          (iVar1 = strcmp(charset,"iso-2022-cn"), iVar1 == 0)))))))) {
      text->kcode = EUC;
    }
    else {
      text->kcode = NOKANJI;
      if ((HTCJK != NOCJK) &&
         ((p_in == (LYUCcharset *)0x0 || ((p_in->enc != 5 && (p_in->enc != 7)))))) {
        HTCJK = NOCJK;
      }
    }
  }
  if ((bVar2) && (iVar1 = strcmp(charset,"utf-8"), iVar1 != 0)) {
    text->specified_kcode = text->kcode;
    return;
  }
  if (UCAssume_MIMEcharset != (char *)0x0) {
    iVar1 = strcmp(UCAssume_MIMEcharset,"euc-jp");
    if (iVar1 == 0) {
      text->specified_kcode = EUC;
      text->kcode = text->specified_kcode;
    }
    else {
      iVar1 = strcmp(UCAssume_MIMEcharset,"shift_jis");
      if (iVar1 == 0) {
        text->specified_kcode = SJIS;
        text->kcode = text->specified_kcode;
      }
    }
  }
  return;
}



void HText_setBreakPoint(HText *text)

{
  if (text != (HText *)0x0) {
    text->permissible_split = (uint)text->last_line->size;
  }
  return;
}



BOOLEAN HText_AreDifferent(HTParentAnchor *anchor,char *full_address)

{
  HTParentAnchor *pHVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  BOOLEAN local_19;
  char *local_18;
  char *MTpound;
  char *MTaddress;
  HTParentAnchor *MTanc;
  
  if (((HTMainText == (HText *)0x0) || (anchor == (HTParentAnchor *)0x0)) ||
     (full_address == (char *)0x0)) {
    local_19 = '\x01';
  }
  else {
    pHVar1 = HTMainText->node_anchor;
    if ((pHVar1->address == (char *)0x0) || (anchor->address == (char *)0x0)) {
      local_19 = '\x01';
    }
    else {
      pcVar3 = strchr(full_address,0x23);
      if (pcVar3 == (char *)0x0) {
        local_19 = '\x01';
      }
      else {
        iVar4 = strncasecomp(anchor->address,"LYNXIMGMAP:",0xb);
        if (iVar4 == 0) {
          local_19 = '\x01';
        }
        else {
          if (pHVar1->isHEAD == anchor->isHEAD) {
            iVar4 = strncasecomp(pHVar1->address,"LYNXIMGMAP:",0xb);
            if (iVar4 == 0) {
              local_18 = pHVar1->address + 0xb;
            }
            else {
              local_18 = pHVar1->address;
            }
            pcVar3 = trimPoundSelector(local_18);
            iVar4 = strcmp(local_18,anchor->address);
            if (iVar4 == 0) {
              if (pcVar3 != (char *)0x0) {
                *pcVar3 = '#';
              }
              if (pHVar1->address == local_18) {
                if (pHVar1->post_data == (bstring *)0x0) {
                  if (anchor->post_data != (bstring *)0x0) {
                    return '\x01';
                  }
                }
                else {
                  if (anchor->post_data == (bstring *)0x0) {
                    return '\x01';
                  }
                  BVar2 = HTSABEql(pHVar1->post_data,anchor->post_data);
                  if (BVar2 == '\0') {
                    return '\x01';
                  }
                }
              }
              local_19 = '\0';
            }
            else {
              if (pcVar3 != (char *)0x0) {
                *pcVar3 = '#';
              }
              local_19 = '\x01';
            }
          }
          else {
            local_19 = '\x01';
          }
        }
      }
    }
  }
  return local_19;
}



int increment_tagged_htline(HTLine *ht,TextAnchor *a,int *lx_val,int *old_val,int incr,int mode)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  ushort **ppuVar5;
  char *__src;
  size_t __n;
  pool_data *ppVar6;
  size_t sVar7;
  int in_GS_OFFSET;
  HTLine *local_c48;
  HTLine *temp;
  int fixup;
  int post_n;
  int pre_n;
  int new_n;
  int n;
  int val;
  char *t;
  char *lx;
  char *s;
  char *p;
  TextAnchor *nxt_anchor;
  TextAnchor *st_anchor;
  BOOLEAN valid;
  BOOLEAN plx;
  char lxbuf [2048];
  char buf [1024];
  int local_8;
  
  local_c48 = ht;
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  st_anchor = a;
  p = ht->data;
  s = buf;
  bVar3 = false;
  fixup = 0;
  if (*lx_val != 0) {
    nxt_anchor = a;
    while ((nxt_anchor != (TextAnchor *)0x0 && (nxt_anchor->line_num == a->line_num))) {
      nxt_anchor->line_pos = nxt_anchor->line_pos + (short)*lx_val;
      nxt_anchor = (TextAnchor *)nxt_anchor->next;
    }
    fixup = *lx_val;
    *lx_val = 0;
    if (a != (TextAnchor *)0x0) {
      st_anchor = (TextAnchor *)a->next;
    }
  }
  do {
    while( true ) {
      if (*p == '\0') goto LAB_080733d8;
      if (*p == '[') break;
      *s = *p;
      s = s + 1;
      p = p + 1;
    }
    *s = *p;
    s = s + 1;
    p = p + 1;
    n = 0;
    bVar2 = true;
    t = p;
    while (*t != ']') {
      if (*t == '\0') {
        bVar2 = false;
        bVar3 = true;
        break;
      }
      ppuVar5 = __ctype_b_loc();
      bVar1 = *t;
      t = t + 1;
      if (((*ppuVar5)[bVar1] & 0x800) == 0) {
        bVar2 = false;
        break;
      }
      n = n + 1;
    }
    if ((bVar2) && (0 < n)) {
      iVar4 = atoi(p);
      if ((*old_val == iVar4) || (*old_val == 0)) {
        if (*old_val != 0) {
          *old_val = *old_val + 1;
        }
        sprintf(s,"%d",iVar4 + incr);
        __n = strlen(s);
        s = s + __n;
        p = p + n;
        if (__n - n != 0) {
          nxt_anchor = st_anchor;
          while ((nxt_anchor != (TextAnchor *)0x0 && (nxt_anchor->line_num == a->line_num))) {
            nxt_anchor->line_pos = nxt_anchor->line_pos + (short)(__n - n);
            nxt_anchor = (TextAnchor *)nxt_anchor->next;
          }
          if (st_anchor != (TextAnchor *)0x0) {
            st_anchor = (TextAnchor *)st_anchor->next;
          }
        }
      }
    }
    __n = strlen(p);
    sVar7 = strlen(ht->next->data);
  } while ((!bVar3) || (0x7ff < (int)(__n + sVar7 + 2)));
  strcpy(lxbuf,p);
  strcat(lxbuf,ht->next->data);
  n = 0;
  bVar3 = true;
  t = lxbuf;
  do {
    if (*t == ']') {
LAB_0807325c:
      if (((bVar3) && (0 < n)) && ((int)(n + sVar7 + 2) < 0x400)) {
        iVar4 = atoi(lxbuf);
        if ((*old_val == iVar4) || (*old_val == 0)) {
          if (*old_val != 0) {
            *old_val = *old_val + 1;
          }
          sprintf(lxbuf,"%d",iVar4 + incr);
          sVar7 = strlen(lxbuf);
          __src = strchr(ht->next->data,0x5d);
          strcat(lxbuf,__src);
          s = strncpy(s,lxbuf,__n);
          s = s + __n;
          strcpy(ht->next->data,lxbuf + __n);
          *lx_val = sVar7 - n;
        }
      }
LAB_080733d8:
      *s = '\0';
      __n = strlen(ht->data);
      if (mode == 1) {
        buf[__n] = '\0';
      }
      else {
        sVar7 = strlen(buf);
        if (ht->size < sVar7) {
          sVar7 = strlen(buf);
          local_c48 = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,sVar7 + 0x14);
          if (local_c48 == (HTLine *)0x0) {
            outofmem("./GridText.c","increment_tagged_htline");
          }
          memcpy(local_c48,ht,0x14);
          ppVar6 = ALLOC_IN_POOL(&HTMainText->pool,(uint)ht->numstyles * 4);
          *(pool_data **)&local_c48->styles = ppVar6;
          if (local_c48->styles == (HTStyleChange *)0x0) {
            outofmem("./GridText.c","increment_tagged_htline");
          }
          memcpy(local_c48->styles,ht->styles,(uint)ht->numstyles * 4);
          *(HTLine **)&local_c48->prev->next = local_c48;
          *(HTLine **)&local_c48->next->prev = local_c48;
        }
      }
      strcpy(local_c48->data,buf);
      sVar7 = strlen(buf);
      if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return (sVar7 - __n) + fixup;
    }
    ppuVar5 = __ctype_b_loc();
    bVar1 = *t;
    t = t + 1;
    if (((*ppuVar5)[bVar1] & 0x800) == 0) {
      bVar3 = false;
      goto LAB_0807325c;
    }
    n = n + 1;
  } while( true );
}



void insert_new_textarea_anchor(TextAnchor **curr_anchor,HTLine **exit_htline)

{
  TextAnchor *b;
  HTLine *ht;
  TextAnchor *a_00;
  FormInfo *dest;
  int iVar1;
  int i;
  int lx;
  int curr_tag;
  HTLine *l;
  FormInfo *f;
  TextAnchor *a;
  HTLine *htline;
  TextAnchor *anchor;
  
  b = *curr_anchor;
  curr_tag = 0;
  lx = 0;
  htline = (HTLine *)HTMainText->last_line->next;
  i = 0;
  while ((b->line_num != i && (htline = (HTLine *)htline->next, HTMainText->last_line != htline))) {
    i = i + 1;
  }
  ht = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,0x414);
  a_00 = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
  dest = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool,0x60);
  if (((a_00 == (TextAnchor *)0x0) || (ht == (HTLine *)0x0)) || (dest == (FormInfo *)0x0)) {
    outofmem("./GridText.c","insert_new_textarea_anchor");
  }
  a_00->next = b->next;
  a_00->number = b->number;
  a_00->line_pos = b->line_pos;
  a_00->extent = b->extent;
  iVar1 = SGML_offset();
  a_00->sgml_offset = iVar1;
  a_00->line_num = b->line_num + 1;
  LYCopyHiText(a_00,b);
  a_00->link_type = b->link_type;
  a_00->input_field = dest;
  a_00->show_anchor = b->show_anchor;
  a_00->inUnderline = b->inUnderline;
  a_00->expansion_anch = '\x01';
  a_00->anchor = (HTChildAnchor *)0x0;
  HTSACopy((char **)dest,b->input_field->name);
  dest->number = b->input_field->number;
  dest->type = b->input_field->type;
  HTSACopy(&dest->orig_value,"");
  dest->size = b->input_field->size;
  dest->maxlength = b->input_field->maxlength;
  dest->no_cache = b->input_field->no_cache;
  dest->disabled = b->input_field->disabled;
  dest->value_cs = current_char_set;
  ht->next = htline->next;
  *(HTLine **)&ht->prev = htline;
  ht->offset = htline->offset;
  ht->size = htline->size;
  ht->numstyles = htline->numstyles;
  ht->styles = htline->styles;
  strcpy(ht->data,htline->data);
  *(HTLine **)&htline->next->prev = ht;
  *(HTLine **)&htline->next = ht;
  if ((keypad_mode == 3) || (keypad_mode == 2)) {
    a_00->number = a_00->number + 1;
    increment_tagged_htline(ht,a_00,&lx,&curr_tag,1,1);
  }
  if (HTMainText->last_anchor == b) {
    HTMainText->last_anchor = a_00;
  }
  if (HTMainText->last_line == htline) {
    HTMainText->last_line = ht;
  }
  *(TextAnchor **)&b->next = a_00;
  *curr_anchor = a_00;
  *(_line **)exit_htline = ht->next;
  return;
}



void update_subsequent_anchors
               (int newlines,TextAnchor *start_anchor,HTLine *start_htline,int start_tag)

{
  FILE *__stream;
  int iVar1;
  char *Msg;
  int hang_detect;
  int hang;
  int lx;
  int tag_adj;
  int line_adj;
  HTLine *htline;
  TextAnchor *anchor;
  
  htline = start_htline;
  lx = 0;
  hang = 0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: adjusting struct\'s to add %d new line(s)\n",newlines);
  }
  anchor = (TextAnchor *)start_anchor->next;
  while (anchor != (TextAnchor *)0x0) {
    if (((keypad_mode == 3) || (keypad_mode == 2)) && (anchor->number != 0)) {
      anchor->number = anchor->number + newlines;
    }
    anchor->line_num = anchor->line_num + newlines;
    anchor = (TextAnchor *)anchor->next;
  }
  if ((keypad_mode == 3) || (keypad_mode == 2)) {
    anchor = (TextAnchor *)start_anchor->next;
    while (HTMainText->last_line->next != (_line *)htline) {
      while ((anchor != (TextAnchor *)0x0 && (anchor->number - newlines != start_tag))) {
        hang = hang + 1;
        if (((TextAnchor *)anchor->next == anchor) || (99999 < hang)) {
          Msg = (char *)gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
          HTAlert(Msg);
          goto finish;
        }
        anchor = (TextAnchor *)anchor->next;
      }
      if (anchor == (TextAnchor *)0x0) break;
      iVar1 = increment_tagged_htline(htline,anchor,&lx,&start_tag,newlines,0);
      htline->size = htline->size + (short)iVar1;
      htline = (HTLine *)htline->next;
    }
  }
finish:
  nlinks = nlinks + newlines;
  HTMainText->Lines = HTMainText->Lines + newlines;
  HTMainText->last_anchor_number = HTMainText->last_anchor_number + newlines;
  more_text = HText_canScrollDown();
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: TextAnchor and HTLine struct\'s adjusted\n");
  }
  return;
}



BOOLEAN IsFormsTextarea(FormInfo *form,TextAnchor *anchor_ptr)

{
  int iVar1;
  
  if ((((anchor_ptr->link_type == '\x02') && (anchor_ptr->input_field->type == 9)) &&
      (anchor_ptr->input_field->number == form->number)) &&
     (iVar1 = strcmp(anchor_ptr->input_field->name,form->name), iVar1 == 0)) {
    return '\x01';
  }
  return '\0';
}



int finish_ExtEditForm(LinkInfo *form_link,TextAnchor *start_anchor,char *ed_temp,int orig_cnt)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  FILE *fp_00;
  int iVar4;
  char *Msg;
  ushort **ppuVar5;
  char *Msg_00;
  stat stat_info;
  int i;
  int skip_num;
  char *skip_at;
  int wanted_fieldlen_wrap;
  int len_in;
  int len0;
  int len;
  int newlines;
  int match_tag;
  char *cp;
  char *lp;
  char *line;
  char *ebuf;
  HTLine *htline;
  int line_cnt;
  int exit_line;
  int entry_line;
  TextAnchor *end_anchor;
  TextAnchor *anchor_ptr;
  FILE *fp;
  size_t size;
  BOOLEAN wrapalert;
  
  end_anchor = (TextAnchor *)0x0;
  bVar2 = false;
  iVar1 = form_link->anchor_line_num;
  exit_line = 0;
  line_cnt = 1;
  htline = (HTLine *)0x0;
  match_tag = 0;
  newlines = 0;
  wanted_fieldlen_wrap = -1;
  skip_at = (char *)0x0;
  skip_num = 0;
  if (WWW_TraceFlag != '\0') {
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"GridText: entered HText_ExtEditForm()\n");
  }
  iVar4 = stat64(ed_temp,(stat64 *)&stat_info);
  if (((iVar4 < 0) || ((stat_info.st_mode & 0xf000) != 0x8000)) || ((size_t)stat_info.st_size == 0))
  {
    size = 0;
    ebuf = (char *)calloc(1,1);
    if (ebuf == (char *)0x0) {
      outofmem("./GridText.c","HText_ExtEditForm");
    }
  }
  else {
    ebuf = (char *)calloc((size_t)stat_info.st_size + 1,1);
    if (ebuf == (char *)0x0) {
      Msg = (char *)gettext("Not enough memory for file!");
      HTAlwaysAlert((char *)0x0,Msg);
      return 0;
    }
    fp_00 = (FILE *)fopen64(ed_temp,"r");
    size = fread(ebuf,1,(size_t)stat_info.st_size,(FILE *)fp_00);
    LYCloseInput(fp_00);
    ebuf[size] = '\0';
  }
  while (size != 0) {
    if (LYtrimInputFields == '\0') {
      if ((ebuf[size - 1] == '\r') || (ebuf[size - 1] == '\n')) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
      if (!bVar3) goto LAB_08073d78;
    }
    else {
      ppuVar5 = __ctype_b_loc();
      if (((*ppuVar5)[(byte)ebuf[size - 1]] & 0x2000) == 0) {
LAB_08073d78:
        if (ebuf[size - 1] != '\0') break;
      }
    }
    size = size - 1;
    ebuf[size] = '\0';
  }
  Msg = (char *)malloc(0x400);
  if (Msg == (char *)0x0) {
    outofmem("./GridText.c","HText_ExtEditForm");
  }
  anchor_ptr = start_anchor;
  if ((start_anchor->input_field->size < 5) || (0x3ff < start_anchor->input_field->size)) {
    wanted_fieldlen_wrap = 0;
  }
  len = 0;
  lp = ebuf;
  do {
    if (((orig_cnt < line_cnt) && (*lp == '\0')) && ((len == 0 || (*lp != '\0')))) {
      if (WWW_TraceFlag != '\0') {
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"GridText: edited text inserted into lynx struct\'s\n");
      }
      if (0 < newlines) {
        update_subsequent_anchors(newlines,end_anchor,htline,match_tag);
      }
      if (Msg != (char *)0x0) {
        free(Msg);
      }
      if (ebuf != (char *)0x0) {
        free(ebuf);
      }
      return exit_line - iVar1;
    }
    if (skip_at == (char *)0x0) {
      len0 = 0;
    }
    else {
      len0 = (int)(skip_at + -(int)lp);
      strncpy(Msg,lp,len0);
      ((char *)len0)[(int)Msg] = '\0';
      lp = skip_at + skip_num;
      skip_at = (char *)0x0;
      skip_num = 0;
    }
    Msg[len0] = '\0';
    Msg_00 = strchr(lp,10);
    if (Msg_00 == (char *)0x0) {
      len = strlen(lp);
    }
    else {
      len = (int)(Msg_00 + -(int)lp);
    }
    if ((((wanted_fieldlen_wrap < 0) && (!bVar2)) && (start_anchor->input_field->size <= len0 + len)
        ) && ((Msg_00 = strchr(lp,0x20), Msg_00 != (char *)0x0 &&
              ((int)(Msg_00 + -(int)lp) < start_anchor->input_field->size + -1)))) {
      LYFixCursesOn("ask for confirmation:");
      LYerase();
      Msg_00 = (char *)gettext("Wrap lines to fit displayed area?");
      iVar4 = HTConfirmDefault(Msg_00,0);
      if (iVar4 == 0) {
        wanted_fieldlen_wrap = 0;
      }
      else {
        wanted_fieldlen_wrap = start_anchor->input_field->size + -1;
      }
    }
    if ((0 < wanted_fieldlen_wrap) && (wanted_fieldlen_wrap < len0 + len)) {
      i = wanted_fieldlen_wrap - len0;
      while ((int)(((uint)(wanted_fieldlen_wrap >> 0x1f) >> 0x1e) + wanted_fieldlen_wrap) >> 2 <=
             i + len0) {
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[(byte)lp[i]] & 0x2000) != 0) {
          len = i + 1;
          cp = lp + i;
          if (((cp[1] != '\n') &&
              (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)cp[1]] & 0x2000) != 0)) &&
             (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)cp[2]] & 0x2000) == 0)) {
            len = i + 2;
            cp = cp + 1;
          }
          ppuVar5 = __ctype_b_loc();
          if (((*ppuVar5)[(byte)cp[1]] & 0x2000) == 0) {
            while (((*cp != '\0' && (*cp != '\r')) &&
                   ((*cp != '\n' &&
                    ((int)(cp + -(int)lp) <=
                     ((int)(((uint)(wanted_fieldlen_wrap * 3 >> 0x1f) >> 0x1e) +
                           wanted_fieldlen_wrap * 3) >> 2) + len))))) {
              cp = cp + 1;
            }
            if ((*cp == '\r') && (cp[1] == '\n')) {
              cp = cp + 1;
            }
            if ((*cp == '\n') &&
               (((cp[1] == '\r' || (cp[1] == '\n')) ||
                (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)cp[1]] & 0x2000) == 0)))) {
              *cp = ' ';
              while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)cp[-1]] & 0x2000) != 0) {
                skip_num = skip_num + 1;
                cp = cp + -1;
              }
              skip_at = cp;
            }
          }
          break;
        }
        i = i + -1;
      }
    }
    if ((0 < wanted_fieldlen_wrap) && (i = len, wanted_fieldlen_wrap < len0 + len)) {
      do {
        i = i + -1;
        if (len0 + i + 1 <= wanted_fieldlen_wrap) break;
        ppuVar5 = __ctype_b_loc();
      } while (((*ppuVar5)[(byte)lp[i]] & 0x2000) != 0);
      if (wanted_fieldlen_wrap < len0 + i + 1) {
        len = wanted_fieldlen_wrap - len0;
      }
    }
    if (0x3ff < len0 + len) {
      if (!bVar2) {
        LYFixCursesOn("show alert:");
        Msg_00 = (char *)gettext("Very long lines have been wrapped!");
        HTAlert(Msg_00);
        bVar2 = true;
      }
      i = 0x3ff - len0;
      while (0 < i) {
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[(byte)lp[i]] & 0x2000) != 0) {
          len = i;
          break;
        }
        i = i + -1;
      }
      if (0x3ff < len0 + len) {
        len = 0x3ff - len0;
      }
    }
    strncat(Msg,lp,len);
    Msg[len0 + len] = '\0';
    if (orig_cnt < line_cnt) {
      insert_new_textarea_anchor(&end_anchor,&htline);
      anchor_ptr = end_anchor;
      newlines = newlines + 1;
    }
    HTSACopy(&anchor_ptr->input_field->value,Msg);
    if (len0 + len < 1) {
      if (exit_line == 0) {
        exit_line = anchor_ptr->line_num;
      }
    }
    else {
      exit_line = 0;
    }
    lp = lp + len;
    if ((*lp != 0) && (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*lp] & 0x2000) != 0)) {
      lp = (char *)((byte *)lp + 1);
    }
    end_anchor = anchor_ptr;
    anchor_ptr = (TextAnchor *)anchor_ptr->next;
    if (anchor_ptr != (TextAnchor *)0x0) {
      match_tag = ((_TextAnchor *)anchor_ptr)->number;
    }
    line_cnt = line_cnt + 1;
  } while( true );
}



int HText_ExtEditForm(LinkInfo *form_link)

{
  int iVar1;
  int iVar2;
  FormInfo *form_00;
  char *pcVar3;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *fp_00;
  char *result;
  int in_GS_OFFSET;
  int local_50;
  FormInfo *form;
  int offset;
  int orig_cnt;
  int entry_line;
  int start_line;
  TextAnchor *start_anchor;
  TextAnchor *anchor_ptr;
  FILE *fp;
  char *ed_temp;
  BOOLEAN firstanchor;
  char ed_offset [10];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  start_anchor = (TextAnchor *)0x0;
  bVar4 = true;
  start_line = 0;
  iVar2 = form_link->anchor_line_num;
  orig_cnt = 0;
  form_00 = (FormInfo *)form_link->l_form;
  if (WWW_TraceFlag != '\0') {
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"GridText: entered HText_ExtEditForm()\n");
  }
  result = (char *)malloc(0x100);
  fp_00 = LYOpenTemp(result,"","w");
  if (fp_00 == (FILE *)0x0) {
    if (result != (char *)0x0) {
      free(result);
    }
    local_50 = 0;
  }
  else {
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      BVar5 = IsFormsTextarea(form_00,anchor_ptr);
      if (BVar5 == '\0') {
        if (!bVar4) break;
      }
      else {
        if (bVar4) {
          bVar4 = false;
          start_anchor = anchor_ptr;
          start_line = anchor_ptr->line_num;
        }
        orig_cnt = orig_cnt + 1;
        fputs(anchor_ptr->input_field->value,(FILE *)fp_00);
        fputc(10,(FILE *)fp_00);
      }
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
    LYCloseTempFP(fp_00);
    if (WWW_TraceFlag != '\0') {
      pcVar3 = form_00->name;
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"GridText: TEXTAREA name=|%s| dumped to tempfile\n",pcVar3);
    }
    pcVar3 = editor;
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"GridText: invoking editor (%s) on tempfile\n",pcVar3);
    }
    ed_offset[0] = '\0';
    if (iVar2 != start_line && -1 < iVar2 - start_line) {
      BVar5 = editor_can_position();
      if (BVar5 != '\0') {
        sprintf(ed_offset,"%d",(iVar2 - start_line) + 1);
      }
    }
    edit_temporary_file(result,ed_offset,(char *)0x0);
    pcVar3 = editor;
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"GridText: returned from editor (%s)\n",pcVar3);
    }
    if (form_00->disabled == 0) {
      offset = finish_ExtEditForm(form_link,start_anchor,result,orig_cnt);
    }
    else {
      offset = 0;
    }
    LYRemoveTemp(result);
    if (result != (char *)0x0) {
      free(result);
    }
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"GridText: exiting HText_ExtEditForm()\n");
    }
    local_50 = offset;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_50;
}



void HText_ExpandTextarea(LinkInfo *form_link,int newlines)

{
  FormInfo *form_00;
  char *pcVar1;
  bool bVar2;
  BOOLEAN BVar3;
  FILE *__stream;
  int i;
  int match_tag;
  HTLine *htline;
  FormInfo *form;
  TextAnchor *end_anchor;
  TextAnchor *anchor_ptr;
  BOOLEAN firstanchor;
  
  end_anchor = (TextAnchor *)0x0;
  bVar2 = true;
  form_00 = (FormInfo *)form_link->l_form;
  htline = (HTLine *)0x0;
  match_tag = 0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"GridText: entered HText_ExpandTextarea()\n");
  }
  if (0 < newlines) {
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != (TextAnchor *)0x0) {
      BVar3 = IsFormsTextarea(form_00,anchor_ptr);
      if (BVar3 == '\0') {
        if (!bVar2) break;
      }
      else {
        if (bVar2) {
          bVar2 = false;
        }
        end_anchor = anchor_ptr;
      }
      anchor_ptr = (TextAnchor *)anchor_ptr->next;
    }
    i = 1;
    while (i <= newlines) {
      insert_new_textarea_anchor(&end_anchor,&htline);
      HTSACopy(&end_anchor->input_field->value,"");
      if (end_anchor->next != (_TextAnchor *)0x0) {
        match_tag = end_anchor->next->number;
      }
      i = i + 1;
    }
    if (WWW_TraceFlag != '\0') {
      pcVar1 = form_00->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",newlines,
              pcVar1);
    }
    update_subsequent_anchors(newlines,end_anchor,htline,match_tag);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GridText: exiting HText_ExpandTextarea()\n");
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

int HText_InsertFile(LinkInfo *form_link)

{
  _line *p_Var1;
  bool bVar2;
  bool bVar3;
  BOOLEAN BVar4;
  FILE *fp_00;
  char *pathname;
  char *Msg;
  int iVar5;
  size_t sVar6;
  pool_data pVar7;
  TextAnchor *a_00;
  FormInfo *form_00;
  int start_tag;
  char *Msg_00;
  int local_cc;
  int local_c8;
  stat stat_info;
  int i;
  int len;
  int newlines;
  int match_tag;
  int file_cs;
  int entry_line;
  char *cp;
  char *lp;
  char *line;
  char *fbuf;
  HTLine *l;
  FormInfo *f;
  TextAnchor *a;
  HTLine *htline;
  FormInfo *form;
  TextAnchor *end_anchor;
  TextAnchor *prev_anchor;
  TextAnchor *anchor_ptr;
  char *fn;
  FILE *fp;
  size_t size;
  BOOLEAN truncalert;
  BOOLEAN firstanchor;
  
  prev_anchor = (TextAnchor *)0x0;
  end_anchor = (TextAnchor *)0x0;
  bVar3 = true;
  bVar2 = false;
  form_00 = (FormInfo *)form_link->l_form;
  htline = (HTLine *)0x0;
  start_tag = form_link->anchor_line_num;
  if (WWW_TraceFlag != '\0') {
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"GridText: entered HText_InsertFile()\n");
  }
  pathname = GetFileName();
  if (pathname == (char *)0x0) {
    pathname = (char *)gettext("File insert cancelled!!!");
    HTInfoMsg(pathname);
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"GridText: file insert cancelled - no filename provided\n");
    }
    local_cc = 0;
  }
  else {
    if (((no_dotfiles != '\0') || (show_dotfiles == '\0')) &&
       (Msg = LYPathLeaf(pathname), *Msg == '.')) {
      pathname = (char *)gettext("File name may not begin with a dot.");
      HTUserMsg(pathname);
      return 0;
    }
    iVar5 = stat64(pathname,(stat64 *)&stat_info);
    if ((iVar5 < 0) || ((size_t)stat_info.st_size == 0)) {
      Msg = (char *)gettext("Nothing to insert - file is 0-length.");
      HTInfoMsg(Msg);
      if (WWW_TraceFlag != '\0') {
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"GridText: file insert aborted - file=|%s|- was 0-length\n",pathname);
      }
      if (pathname != (char *)0x0) {
        free(pathname);
      }
      local_cc = 0;
    }
    else {
      Msg = (char *)calloc((size_t)stat_info.st_size + 1,1);
      if (Msg == (char *)0x0) {
        free(pathname);
        pathname = (char *)gettext("Not enough memory for file!");
        HTAlert(pathname);
        local_cc = 0;
      }
      else {
        LYGetFileInfo(pathname,(HTParentAnchor **)0x0,(HTFormat *)0x0,(HTAtom **)0x0,(char **)0x0,
                      (char **)0x0,&file_cs);
        fp_00 = (FILE *)fopen64(pathname,"r");
        if (fp_00 == (FILE *)0x0) {
          free(Msg);
          free(pathname);
          pathname = (char *)gettext("Can\'t open file for reading.");
          HTAlert(pathname);
          local_cc = 0;
        }
        else {
          sVar6 = fread(Msg,1,(size_t)stat_info.st_size,(FILE *)fp_00);
          LYCloseInput(fp_00);
          if (pathname != (char *)0x0) {
            free(pathname);
          }
          Msg[sVar6] = '\0';
          anchor_ptr = HTMainText->first_anchor;
          while ((anchor_ptr != (TextAnchor *)0x0 &&
                 ((BVar4 = IsFormsTextarea(form_00,anchor_ptr), BVar4 == '\0' ||
                  (anchor_ptr->line_num != start_tag))))) {
            prev_anchor = anchor_ptr;
            anchor_ptr = (TextAnchor *)anchor_ptr->next;
          }
          htline = (HTLine *)HTMainText->last_line->next;
          i = 0;
          while ((anchor_ptr->line_num != i &&
                 (htline = (HTLine *)htline->next, HTMainText->last_line != htline))) {
            i = i + 1;
          }
          pVar7 = (pool_data)ALLOC_IN_POOL(&HTMainText->pool,0x414);
          a_00 = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
          form_00 = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool,0x60);
          if (((a_00 == (TextAnchor *)0x0) || (pVar7 == (pool_data)0x0)) ||
             (form_00 == (FormInfo *)0x0)) {
            outofmem("./GridText.c","HText_InsertFile");
          }
          *(TextAnchor **)&a_00->next = anchor_ptr;
          a_00->number = anchor_ptr->number;
          a_00->line_pos = anchor_ptr->line_pos;
          a_00->extent = anchor_ptr->extent;
          start_tag = SGML_offset();
          a_00->sgml_offset = start_tag;
          a_00->line_num = anchor_ptr->line_num;
          LYCopyHiText(a_00,anchor_ptr);
          a_00->link_type = anchor_ptr->link_type;
          a_00->input_field = form_00;
          a_00->show_anchor = anchor_ptr->show_anchor;
          a_00->inUnderline = anchor_ptr->inUnderline;
          a_00->expansion_anch = '\x01';
          a_00->anchor = (HTChildAnchor *)0x0;
          HTSACopy((char **)form_00,anchor_ptr->input_field->name);
          form_00->number = anchor_ptr->input_field->number;
          form_00->type = anchor_ptr->input_field->type;
          HTSACopy(&form_00->orig_value,"");
          form_00->size = anchor_ptr->input_field->size;
          form_00->maxlength = anchor_ptr->input_field->maxlength;
          form_00->no_cache = anchor_ptr->input_field->no_cache;
          form_00->disabled = anchor_ptr->input_field->disabled;
          if (file_cs < 0) {
            local_c8 = current_char_set;
          }
          else {
            local_c8 = file_cs;
          }
          form_00->value_cs = local_c8;
          *(ushort *)((int)pVar7 + 8) = htline->offset;
          *(ushort *)((int)pVar7 + 10) = htline->size;
          *(ushort *)((int)pVar7 + 0x10) = htline->numstyles;
          *(HTStyleChange **)((int)pVar7 + 0xc) = htline->styles;
          strcpy((char *)((int)pVar7 + 0x12),htline->data);
          if (HTMainText->first_anchor == anchor_ptr) {
            HTMainText->first_anchor = a_00;
          }
          if (prev_anchor != (TextAnchor *)0x0) {
            *(TextAnchor **)&prev_anchor->next = a_00;
          }
          p_Var1 = htline->prev;
          *(_line **)pVar7 = p_Var1->next;
          *(_line **)((int)pVar7 + 4) = p_Var1;
          *(pool_data *)((int)p_Var1->next + 4) = pVar7;
          *(pool_data *)&p_Var1->next = pVar7;
          htline = *(HTLine **)p_Var1->next;
          newlines = 1;
          pathname = (char *)malloc(0x400);
          if (pathname == (char *)0x0) {
            outofmem("./GridText.c","HText_InsertFile");
          }
          start_tag = a_00->number;
          lp = Msg;
          anchor_ptr = a_00;
          while (*lp != '\0') {
            Msg_00 = strchr(lp,10);
            if (Msg_00 == (char *)0x0) {
              len = strlen(lp);
            }
            else {
              len = (int)(Msg_00 + -(int)lp);
            }
            if (0x3ff < len) {
              if (!bVar2) {
                Msg_00 = (char *)gettext("Very long lines have been truncated!");
                HTAlert(Msg_00);
                bVar2 = true;
              }
              len = 0x3ff;
              if (lp[0x3ff] != '\0') {
                lp[0x400] = '\0';
              }
            }
            strncpy(pathname,lp,len);
            pathname[len] = '\0';
            if (!bVar3) {
              insert_new_textarea_anchor(&end_anchor,&htline);
              anchor_ptr = end_anchor;
              newlines = newlines + 1;
            }
            HTSACopy(&anchor_ptr->input_field->value,pathname);
            if (-1 < file_cs) {
              anchor_ptr->input_field->value_cs = file_cs;
            }
            lp = lp + len;
            if (*lp != '\0') {
              lp = lp + 1;
            }
            bVar3 = false;
            end_anchor = anchor_ptr;
            anchor_ptr = (TextAnchor *)anchor_ptr->next;
          }
          if (WWW_TraceFlag != '\0') {
            fp_00 = TraceFP();
            fprintf((FILE *)fp_00,"GridText: file inserted into lynx struct\'s\n");
          }
          update_subsequent_anchors(newlines,end_anchor,htline,start_tag);
          if (pathname != (char *)0x0) {
            free(pathname);
          }
          if (Msg != (char *)0x0) {
            free(Msg);
          }
          if (WWW_TraceFlag != '\0') {
            fp_00 = TraceFP();
            fprintf((FILE *)fp_00,"GridText: exiting HText_InsertFile()\n");
          }
          local_cc = newlines;
        }
      }
    }
  }
  return local_cc;
}



int GetColumn(void)

{
  int local_18;
  int x;
  int y;
  int result;
  
  if (LYwin == (WINDOW *)0x0) {
    local_18 = -1;
  }
  else {
    local_18 = (int)LYwin->_curx;
  }
  return local_18;
}



BOOLEAN DidWrap(int y0,int x0)

{
  int local_20;
  int local_1c;
  int local_18;
  int x;
  int y;
  BOOLEAN result;
  
  result = '\0';
  if (LYwin == (WINDOW *)0x0) {
    local_20 = -1;
    local_1c = -1;
  }
  else {
    local_20 = (int)LYwin->_cury;
    local_1c = (int)LYwin->_curx;
  }
  if (LYwideLines == 0) {
    local_18 = LYcols;
  }
  else {
    local_18 = 0x3f6;
  }
  if ((local_18 <= local_1c) || ((local_1c == 0 && (local_20 != y0)))) {
    result = '\x01';
  }
  return result;
}



void redraw_part_of_line(HTLine *line,char *str,int len,HText *text)

{
  char *__src;
  BOOLEAN BVar1;
  int iVar2;
  ushort **ppuVar3;
  size_t len_00;
  int local_48;
  int local_44;
  int local_3c;
  int local_38;
  char buffer [7];
  int XP;
  int YP;
  int scols;
  int tcols;
  int current_style;
  size_t utf_extra;
  char *end_of_data;
  char *data;
  char LastDisplayChar;
  
  utf_extra = 0;
  current_style = 0;
  LastDisplayChar = ' ';
  if (LYwin == (WINDOW *)0x0) {
    local_48 = -1;
    local_44 = -1;
  }
  else {
    local_48 = (int)LYwin->_cury;
    local_44 = (int)LYwin->_curx;
  }
  buffer[2] = '\0';
  buffer[1] = '\0';
  buffer[0] = '\0';
  data = str;
  local_38 = local_44 + 1;
  __src = data;
LAB_08075439:
  while( true ) {
    data = __src;
    if (str + len <= data) {
      while (current_style < (int)(uint)line->numstyles) {
        curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                     (uint)(*(byte *)(line->styles + current_style) & 3));
        current_style = current_style + 1;
      }
      return;
    }
    buffer[0] = *data;
    __src = data + 1;
    iVar2 = GetColumn();
    scols = StyleToCols(text,line,current_style);
    while ((current_style < (int)(uint)line->numstyles && (scols <= iVar2))) {
      curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                   (uint)(*(byte *)(line->styles + current_style) & 3));
      current_style = current_style + 1;
      scols = StyleToCols(text,line,current_style);
    }
    if (buffer[0] == '\a') goto LAB_08075299;
    if (buffer[0] != '\b') break;
    if (dump_output_immediately == '\0') {
      waddch(LYwin,0x2b);
      local_38 = local_38 + 1;
    }
  }
  goto LAB_080752db;
LAB_08075299:
  if (((*__src == '\0') &&
      (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)LastDisplayChar] & 0x2000) == 0)) &&
     (LastDisplayChar != '-')) {
    buffer[0] = '-';
LAB_080752db:
    if (((text->T).output_utf8 != '\0') && (buffer[0] < '\0')) {
      utf_extra = utf8_length((text->T).output_utf8,data);
      LastDisplayChar = 'M';
    }
    if (utf_extra == 0) {
      if ((HTCJK == NOCJK) || (-1 < buffer[0])) {
        len_00 = strlen(buffer);
        LYwaddnstr(LYwin,buffer,len_00);
        LastDisplayChar = buffer[0];
      }
      else {
        if (LYwideLines == 0) {
          local_3c = LYcols;
        }
        else {
          local_3c = 0x3f6;
        }
        if (local_38 <= local_3c) {
          buffer[1] = *__src;
          buffer[2] = '\0';
          local_38 = local_38 + 1;
          len_00 = strlen(buffer);
          LYwaddnstr(LYwin,buffer,len_00);
          buffer[1] = '\0';
          LastDisplayChar = 'M';
          __src = data + 2;
        }
      }
    }
    else {
      strncpy(buffer + 1,__src,utf_extra);
      buffer[utf_extra + 1] = '\0';
      len_00 = strlen(buffer);
      LYwaddnstr(LYwin,buffer,len_00);
      buffer[1] = '\0';
      __src = __src + utf_extra;
      utf_extra = 0;
    }
    data = __src;
    BVar1 = DidWrap(local_48,local_44);
    __src = data;
    if (BVar1 == '\0') {
      local_38 = local_38 + 1;
    }
  }
  goto LAB_08075439;
}



void redraw_lines_of_link(int cur)

{
  bool bVar1;
  HText *text_00;
  int x;
  size_t len;
  char *__s;
  char *text;
  int count;
  int col;
  int row;
  int lines_back;
  HTLine *todr1;
  
  if (HTMainText->next_line == HTMainText->last_line) {
    lines_back = HTMainText->Lines + ((1 - links[cur].ly) - HTMainText->top_of_screen);
  }
  else {
    lines_back = (1 - links[cur].ly) + display_lines;
  }
  todr1 = HTMainText->next_line;
  while (bVar1 = 0 < lines_back, lines_back = lines_back + -1, bVar1) {
    todr1 = (HTLine *)todr1->prev;
  }
  row = links[cur].ly;
  if (no_title != '\0') {
    row = row + -1;
  }
  count = 0;
  while( true ) {
    if (display_lines < row) {
      return;
    }
    __s = LYGetHiliteStr(cur,count);
    if (__s == (char *)0x0) break;
    x = LYGetHilitePos(cur,count);
    LYmove(row,x);
    text_00 = HTMainText;
    len = strlen(__s);
    redraw_part_of_line(todr1,__s,len,text_00);
    todr1 = (HTLine *)todr1->next;
    count = count + 1;
    row = row + 1;
  }
  return;
}



void HTMark_asSource(void)

{
  if (HTMainText != (HText *)0x0) {
    HTMainText->source = '\x01';
  }
  return;
}



HTkcode HText_getKcode(HText *text)

{
  return text->kcode;
}



void HText_updateKcode(HText *text,HTkcode kcode)

{
  text->kcode = kcode;
  return;
}



HTkcode HText_getSpecifiedKcode(HText *text)

{
  return text->specified_kcode;
}



void HText_updateSpecifiedKcode(HText *text,HTkcode kcode)

{
  text->specified_kcode = kcode;
  return;
}



int HTMainText_Get_UCLYhndl(void)

{
  int local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = -1;
  }
  else {
    local_8 = HTAnchor_getUCLYhndl(HTMainText->node_anchor,0);
  }
  return local_8;
}



int getfile(DocInfo *doc,int *target)

{
  char cVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  size_t __n;
  char *Msg;
  int iVar3;
  ushort **ppuVar4;
  char *Msg2;
  undefined4 uVar5;
  HTParentAnchor *me;
  UrlTypes UVar6;
  bstring *b;
  int local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_5c;
  DocAddress WWWDoc;
  char *msg;
  HTParentAnchor *tmpanchor_1;
  int status;
  char *proxy_1;
  char *proxy;
  char *title;
  HTParentAnchor *tmpanchor;
  char *last_slash;
  char *ref_url;
  long value;
  char *cp1;
  char *temp;
  char *cp;
  char *pound;
  UrlTypes url_type;
  
  temp = (char *)0x0;
  if (LYCancelDownload != '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"getfile:    resetting LYCancelDownload to FALSE\n");
    }
    LYCancelDownload = '\0';
  }
  LYFakeZap('\0');
  redirection_attempts = 0;
Try_Redirected_URL:
  do {
    WWWDoc.address = doc->address;
    WWWDoc.post_data = doc->post_data;
    WWWDoc.post_content_type = doc->post_content_type;
    WWWDoc.bookmark = doc->bookmark;
    WWWDoc.isHEAD = doc->isHEAD;
    WWWDoc.safe = doc->safe;
    HTPermitRedir = '\0';
    if (WWW_Download_File != (char *)0x0) {
      free(WWW_Download_File);
      WWW_Download_File = (char *)0x0;
    }
    redirect_post_content = '\0';
    HTNoDataOK = 0;
    if (WWW_TraceFlag != '\0') {
      Msg = doc->address;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"getfile: getting %s\n\n",Msg);
    }
    temp = HTParse(doc->address,"",8);
    if ((temp != (char *)0x0) && (__n = strlen(temp), 3 < __n)) {
      cp1 = strchr(temp,0x40);
      if (cp1 == (char *)0x0) {
        cp1 = temp;
      }
      Msg = strrchr(cp1,0x3a);
      if (Msg != (char *)0x0) {
        iVar3 = sscanf(Msg + 1,"%ld",&value);
        if (iVar3 == 1) {
          if ((value == 0x13) || (value == 0x10013)) {
            Msg = (char *)gettext("Port 19 not permitted in URLs.");
            HTAlert(Msg);
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
          if ((value == 0x19) || (value == 0x10019)) {
            Msg = (char *)gettext("Port 25 not permitted in URLs.");
            HTAlert(Msg);
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
          if ((0xffff < value) || (value < 0)) {
            msg = (char *)0x0;
            Msg = (char *)gettext("Port %lu not permitted in URLs.");
            HTSprintf0(&msg,Msg,value);
            HTAlert(msg);
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
        }
        else {
          ppuVar4 = __ctype_b_loc();
          if (((*ppuVar4)[(byte)Msg[1]] & 0x800) != 0) {
            Msg = (char *)gettext("URL has a bad port field.");
            HTAlert(Msg);
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
        }
      }
    }
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
    url_type = is_url(doc->address);
    if (url_type == NOT_A_URL_TYPE) {
      if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
        sleep(MessageSecs);
      }
      Msg = doc->address;
      Msg2 = (char *)gettext("Badly formed address %s");
      HTUserMsg2(Msg2,Msg);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\n");
      }
      return 3;
    }
    if ((((((LYValidate != '\0') && (LYPermitURL == '\0')) && (url_type != HTTP_URL_TYPE)) &&
         ((url_type != HTTPS_URL_TYPE && (url_type != LYNXHIST_URL_TYPE)))) &&
        ((url_type != LYNXKEYMAP_URL_TYPE &&
         ((url_type != LYNXIMGMAP_URL_TYPE && (url_type != LYNXCOOKIE_URL_TYPE)))))) &&
       ((url_type != LYNXMESSAGES_URL_TYPE &&
        ((url_type != LYNXOPTIONS_URL_TYPE || (WWWDoc.post_data == (bstring *)0x0)))))) {
      __n = strlen(helpfilepath);
      iVar3 = strncmp(WWWDoc.address,helpfilepath,__n);
      if (iVar3 != 0) {
        if (lynxlistfile != (char *)0x0) {
          __n = strlen(lynxlistfile);
          iVar3 = strncmp(WWWDoc.address,lynxlistfile,__n);
          if (iVar3 == 0) goto LAB_08075b5a;
        }
        if (lynxlinksfile != (char *)0x0) {
          __n = strlen(lynxlinksfile);
          iVar3 = strncmp(WWWDoc.address,lynxlinksfile,__n);
          if (iVar3 == 0) goto LAB_08075b5a;
        }
        if (lynxjumpfile == (char *)0x0) {
LAB_08075b3a:
          Msg = (char *)gettext("Not an http URL or form ACTION!");
          HTUserMsg(Msg);
          return 3;
        }
        __n = strlen(lynxjumpfile);
        iVar3 = strncmp(WWWDoc.address,lynxjumpfile,__n);
        if (iVar3 != 0) goto LAB_08075b3a;
      }
    }
LAB_08075b5a:
    if (traversal == '\0') {
      if (((check_realm != '\0') && (LYPermitURL == '\0')) && (LYJumpFileURL == '\0')) {
        __n = strlen(startrealm);
        iVar3 = strncmp(startrealm,WWWDoc.address,__n);
        if (((((((iVar3 != 0) && (url_type != LYNXHIST_URL_TYPE)) &&
               ((url_type != LYNXKEYMAP_URL_TYPE &&
                ((url_type != LYNXIMGMAP_URL_TYPE && (url_type != LYNXCOOKIE_URL_TYPE)))))) &&
              (url_type != LYNXPRINT_URL_TYPE)) &&
             ((((url_type != LYNXOPTIONS_URL_TYPE && (url_type != LYNXCFG_URL_TYPE)) &&
               (url_type != LYNXCOMPILE_OPTS_URL_TYPE)) &&
              ((url_type != LYNXMESSAGES_URL_TYPE && (url_type != LYNXDOWNLOAD_URL_TYPE)))))) &&
            (((url_type != MAILTO_URL_TYPE &&
              ((url_type != NEWSPOST_URL_TYPE && (url_type != NEWSREPLY_URL_TYPE)))) &&
             ((url_type != SNEWSPOST_URL_TYPE && (url_type != SNEWSREPLY_URL_TYPE)))))) &&
           (((LYUserSpecifiedURL != '\0' ||
             (((url_type != LYNXEXEC_URL_TYPE && (url_type != LYNXPROG_URL_TYPE)) &&
              (url_type != LYNXCGI_URL_TYPE)))) &&
            ((WWWDoc.bookmark == (char *)0x0 || (*WWWDoc.bookmark == '\0')))))) {
          __n = strlen(helpfilepath);
          iVar3 = strncmp(WWWDoc.address,helpfilepath,__n);
          if (iVar3 != 0) {
            if (lynxlistfile != (char *)0x0) {
              __n = strlen(lynxlistfile);
              iVar3 = strncmp(WWWDoc.address,lynxlistfile,__n);
              if (iVar3 == 0) goto LAB_08075d68;
            }
            if (lynxjumpfile == (char *)0x0) {
LAB_08075d48:
              Msg = (char *)gettext("URL is not in starting realm!");
              HTUserMsg(Msg);
              return 3;
            }
            __n = strlen(lynxjumpfile);
            iVar3 = strncmp(WWWDoc.address,lynxjumpfile,__n);
            if (iVar3 != 0) goto LAB_08075d48;
          }
        }
      }
    }
    else {
      if ((url_type != HTTP_URL_TYPE) && (url_type != LYNXIMGMAP_URL_TYPE)) {
        return 3;
      }
    }
LAB_08075d68:
    if ((((((((WWWDoc.post_data != (bstring *)0x0) && (url_type != HTTP_URL_TYPE)) &&
            (url_type != HTTPS_URL_TYPE)) &&
           ((url_type != LYNXCGI_URL_TYPE && (url_type != LYNXIMGMAP_URL_TYPE)))) &&
          (url_type != GOPHER_URL_TYPE)) &&
         ((url_type != CSO_URL_TYPE && (url_type != PROXY_URL_TYPE)))) &&
        (url_type != LYNXOPTIONS_URL_TYPE)) &&
       ((url_type != FILE_URL_TYPE ||
        ((BVar2 = LYIsUIPage3(WWWDoc.address,UIP_LIST_PAGE,1), BVar2 == '\0' &&
         (BVar2 = LYIsUIPage3(WWWDoc.address,UIP_ADDRLIST_PAGE,1), BVar2 == '\0')))))) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"getfile: dropping post_data!\n");
      }
      Msg = (char *)gettext("POST not supported for this URL - ignoring POST data!");
      HTAlert(Msg);
      LYFreePostData(doc);
      WWWDoc.post_data = (bstring *)0x0;
      WWWDoc.post_content_type = (char *)0x0;
    }
    LYSyslog(doc->address);
    if (((url_type == UNKNOWN_URL_TYPE) || (url_type == AFS_URL_TYPE)) ||
       (url_type == PROSPERO_URL_TYPE)) {
      Msg = (char *)gettext("Unsupported URL scheme!");
      HTAlert(Msg);
      return 3;
    }
    if (url_type == DATA_URL_TYPE) {
      Msg = (char *)gettext("Unsupported data: URL!  Use SHOWINFO, for now.");
      HTAlert(Msg);
      return 3;
    }
    if (url_type == LYNXPRINT_URL_TYPE) {
      iVar3 = printfile(doc);
      return iVar3;
    }
    if (url_type == LYNXOPTIONS_URL_TYPE) {
      iVar3 = postoptions(doc);
      return iVar3;
    }
    if ((url_type == LYNXCFG_URL_TYPE) && (no_lynxcfg_info == '\0')) {
      iVar3 = lynx_cfg_infopage(doc);
      return iVar3;
    }
    if ((url_type == LYNXCOMPILE_OPTS_URL_TYPE) && (no_compileopts_info == '\0')) {
      iVar3 = lynx_compile_opts(doc);
      return iVar3;
    }
    if ((((url_type == NEWSPOST_URL_TYPE) || (url_type == NEWSREPLY_URL_TYPE)) ||
        (url_type == SNEWSPOST_URL_TYPE)) || (url_type == SNEWSREPLY_URL_TYPE)) {
      if (no_newspost != '\0') {
        Msg = (char *)gettext("News posting is disabled!");
        HTUserMsg(Msg);
        return 3;
      }
      if ((news_ok == '\0') && ((url_type == NEWSPOST_URL_TYPE || (url_type == NEWSREPLY_URL_TYPE)))
         ) {
        Msg = (char *)gettext("USENET news access is disabled!");
        HTUserMsg(Msg);
        return 3;
      }
      HTLoadAbsolute(&WWWDoc);
      return 3;
    }
    if (url_type == LYNXDOWNLOAD_URL_TYPE) {
      LYDownload(doc->address);
      return 1;
    }
    if (url_type == LYNXDIRED_URL_TYPE) {
      if (no_dired_support != '\0') {
        Msg = (char *)gettext("File management support is disabled!");
        HTUserMsg(Msg);
        return 3;
      }
      local_dired(doc);
      WWWDoc.address = doc->address;
      WWWDoc.post_data = doc->post_data;
      WWWDoc.post_content_type = doc->post_content_type;
      WWWDoc.bookmark = doc->bookmark;
      WWWDoc.isHEAD = doc->isHEAD;
      WWWDoc.safe = doc->safe;
      BVar2 = HTLoadAbsolute(&WWWDoc);
      if (BVar2 != '\0') {
        return 1;
      }
      return 0;
    }
    if ((LYNoRefererHeader == '\0') && (LYNoRefererForThis == '\0')) {
      ref_url = HTLoadedDocumentURL();
      iVar3 = strncasecomp(ref_url,"LYNXIMGMAP:",0xb);
      if (iVar3 == 0) {
        ref_url = ref_url + 0xb;
      }
      if ((no_filereferer == '\x01') &&
         (((*ref_url == 'f' || (*ref_url == 'F')) &&
          (iVar3 = strncasecomp(ref_url,"file:",5), iVar3 == 0)))) {
        LYNoRefererForThis = '\x01';
      }
      if (((LYNoRefererForThis == '\0') && (Msg = strchr(ref_url,0x3f), Msg != (char *)0x0)) &&
         (Msg = strchr(Msg,0x3d), Msg != (char *)0x0)) {
        if (LYRefererWithQuery == 'S') {
          HTSACopy(&LYRequestReferer,ref_url);
        }
        else {
          if (LYRefererWithQuery == 'P') {
            if (LYRequestReferer != (char *)0x0) {
              free(LYRequestReferer);
              LYRequestReferer = (char *)0x0;
            }
            LYRequestReferer = HTParse(ref_url,"",0x39);
          }
          else {
            LYNoRefererForThis = '\x01';
          }
        }
      }
      else {
        if (LYNoRefererForThis == '\0') {
          HTSACopy(&LYRequestReferer,ref_url);
        }
      }
    }
    else {
      Msg = HTLoadedDocumentURL();
      HTSACopy(&LYRequestReferer,Msg);
    }
    if (url_type == LYNXHIST_URL_TYPE) {
      BVar2 = historytarget(doc);
      if (((BVar2 != '\0') && (doc != (DocInfo *)0x0)) && (doc->address != (char *)0x0)) {
        WWWDoc.address = doc->address;
        WWWDoc.post_data = doc->post_data;
        WWWDoc.post_content_type = doc->post_content_type;
        WWWDoc.bookmark = doc->bookmark;
        WWWDoc.isHEAD = doc->isHEAD;
        WWWDoc.safe = doc->safe;
        lynx_edit_mode = '\0';
        BVar2 = HTLoadAbsolute(&WWWDoc);
        if (BVar2 != '\0') {
          return 1;
        }
        return 0;
      }
      return 0;
    }
    if ((url_type == LYNXEXEC_URL_TYPE) || (url_type == LYNXPROG_URL_TYPE)) {
      if (no_exec != '\0') {
        Msg = doc->address;
        Msg2 = HTLoadedDocumentURL();
        BVar2 = exec_ok(Msg2,Msg + 9,1);
        if (BVar2 == '\0') {
          Msg = (char *)gettext("Execution is disabled.");
          HTUserMsg(Msg);
          return 3;
        }
      }
      if ((no_bookmark_exec != '\0') && (Msg = HTLoadedDocumentBookmark(), Msg != (char *)0x0)) {
        Msg = (char *)gettext("Execution via bookmarks is disabled.");
        HTUserMsg(Msg);
        return 3;
      }
      if (local_exec == '\0') {
        if (local_exec_on_local_files != '\0') {
          Msg = doc->address;
          Msg2 = HTLoadedDocumentURL();
          BVar2 = exec_ok(Msg2,Msg + 9,0);
          if (BVar2 != '\0') goto LAB_08076372;
        }
        msg = (char *)0x0;
        Msg = key_for_func(0x31);
        Msg2 = (char *)gettext(
                              "Execution is not enabled for this file.  See the Options menu (use %s)."
                              );
        HTSprintf0(&msg,Msg2,Msg);
        HTAlert(msg);
        if (msg != (char *)0x0) {
          free(msg);
        }
      }
      else {
LAB_08076372:
        msg = (char *)0x0;
        Msg2 = strrchr(doc->address,0x2f);
        Msg = doc->address;
        __n = strlen(doc->address);
        if (Msg2 + -(int)Msg == (char *)(__n - 1)) {
          Msg = doc->address;
          __n = strlen(doc->address);
          Msg[__n - 1] = '\0';
        }
        HTSACopy(&msg,doc->address);
        LYTildeExpand(&msg,'\x01');
        HTInfoMsg(doc->address);
        stop_curses();
        Msg = strstr(msg,"//");
        if (Msg == msg + 9) {
          LYSystem(msg + 0xb);
        }
        else {
          LYSystem(msg + 9);
        }
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
        if (url_type != LYNXPROG_URL_TYPE) {
          signal(2,(__sighandler_t)0x1);
          uVar5 = gettext("Press <return> to return to Lynx.");
          printf("\n%s",uVar5);
          fflush(stdout);
          LYgetch();
        }
        if (dump_output_immediately == '\0') {
          start_curses();
          LYAddVisitedLink(doc);
        }
      }
      return 3;
    }
    if (url_type == MAILTO_URL_TYPE) {
      if (no_mail == '\0') {
        me = HTAnchor_findAddress(&WWWDoc);
        msg = (char *)0x0;
        title = "";
        Msg = HTAnchor_title(me);
        if (Msg == (char *)0x0) {
          if ((HTMainAnchor != (HTParentAnchor *)0x0) && (LYUserSpecifiedURL == '\0')) {
            title = HTAnchor_subject(HTMainAnchor);
            if ((title == (char *)0x0) || (*title == '\0')) {
              title = "";
            }
            else {
              iVar3 = strncasecomp(title,"Re:",3);
              if (iVar3 != 0) {
                HTSACopy(&msg,"Re: ");
                HTSACat(&msg,title);
                title = msg;
              }
            }
          }
        }
        else {
          title = HTAnchor_title(me);
        }
        Msg = strchr(doc->address,0x3a);
        if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYUserSpecifiedURL != '\0')) {
          local_68 = (char *)0x0;
        }
        else {
          local_68 = HTMainAnchor->message_id;
        }
        if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYUserSpecifiedURL != '\0')) {
          local_64 = doc->address;
        }
        else {
          local_64 = HTMainAnchor->address;
        }
        reply_by_mail(Msg + 1,local_64,title,local_68);
        if (msg != (char *)0x0) {
          free(msg);
        }
      }
      else {
        Msg = (char *)gettext("Mail access is disabled!");
        HTUserMsg(Msg);
      }
      return 3;
    }
    if (((((((local_host_only != '\0') && (url_type != LYNXKEYMAP_URL_TYPE)) &&
           (url_type != LYNXIMGMAP_URL_TYPE)) &&
          ((url_type != LYNXCOOKIE_URL_TYPE && (url_type != LYNXMESSAGES_URL_TYPE)))) &&
         ((url_type != LYNXCGI_URL_TYPE &&
          ((url_type != NEWS_URL_TYPE || (iVar3 = strncmp(doc->address,"news://",7), iVar3 == 0)))))
         ) && (BVar2 = LYisLocalHost(doc->address), BVar2 == '\0')) &&
       (BVar2 = LYisLocalAlias(doc->address), BVar2 == '\0')) {
      Msg = (char *)gettext("Only files and servers on the local host can be accessed.");
      HTUserMsg(Msg);
      return 3;
    }
    if (((url_type == TELNET_URL_TYPE) || (url_type == TN3270_URL_TYPE)) ||
       (url_type == TELNET_GOPHER_URL_TYPE)) {
      if (telnet_ok == '\0') {
        Msg = (char *)gettext("Telnet access is disabled!");
        HTUserMsg(Msg);
        return 3;
      }
      if ((no_telnet_port != '\0') && (Msg = strchr(doc->address + 7,0x3a), Msg != (char *)0x0)) {
        Msg = (char *)gettext("Telnet port specifications are disabled.");
        HTUserMsg(Msg);
        return 3;
      }
      if (url_type == TN3270_URL_TYPE) {
        local_60 = "tn3270_proxy";
      }
      else {
        if (url_type == TELNET_GOPHER_URL_TYPE) {
          local_5c = "gopher_proxy";
        }
        else {
          local_5c = "telnet_proxy";
        }
        local_60 = local_5c;
      }
      Msg = LYGetEnv(local_60);
      if (((Msg == (char *)0x0) || (BVar2 = override_proxy(doc->address), BVar2 != '\0')) ||
         ((iVar3 = strncasecomp(Msg,"telnet:",7), iVar3 == 0 ||
          ((iVar3 = strncasecomp(Msg,"tn3270:",7), iVar3 == 0 ||
           (iVar3 = strncasecomp(Msg,"rlogin:",7), iVar3 == 0)))))) {
        stop_curses();
        HTLoadAbsolute(&WWWDoc);
        if (dump_output_immediately == '\0') {
          start_curses();
          fflush(stdout);
          LYAddVisitedLink(doc);
        }
        return 3;
      }
    }
    else {
      if ((news_ok == '\0') && ((url_type == NEWS_URL_TYPE || (url_type == NNTP_URL_TYPE)))) {
        Msg = (char *)gettext("USENET news access is disabled!");
        HTUserMsg(Msg);
        return 3;
      }
      if (url_type == RLOGIN_URL_TYPE) {
        if (rlogin_ok == '\0') {
          Msg = (char *)gettext("Rlogin access is disabled!");
          HTUserMsg(Msg);
          return 3;
        }
        Msg = LYGetEnv("rlogin_proxy");
        if ((((Msg == (char *)0x0) || (BVar2 = override_proxy(doc->address), BVar2 != '\0')) ||
            (iVar3 = strncasecomp(Msg,"telnet:",7), iVar3 == 0)) ||
           ((iVar3 = strncasecomp(Msg,"tn3270:",7), iVar3 == 0 ||
            (iVar3 = strncasecomp(Msg,"rlogin:",7), iVar3 == 0)))) {
          stop_curses();
          HTLoadAbsolute(&WWWDoc);
          fflush(stdout);
          if (dump_output_immediately == '\0') {
            start_curses();
            LYAddVisitedLink(doc);
          }
          return 3;
        }
      }
      else {
        if ((url_type == INDEX_GOPHER_URL_TYPE) &&
           (Msg = strchr(doc->address,0x3f), Msg == (char *)0x0)) {
          Msg = strstr(doc->address,"%09");
          if (Msg == (char *)0x0) {
            BVar2 = HTLoadAbsolute(&WWWDoc);
            if (BVar2 == '\0') {
              local_6c = 0;
            }
            else {
              status = do_www_search(doc);
              if (status == 3) {
                LYpop(doc);
                WWWDoc.address = doc->address;
                WWWDoc.post_data = doc->post_data;
                WWWDoc.post_content_type = doc->post_content_type;
                WWWDoc.bookmark = doc->bookmark;
                WWWDoc.isHEAD = doc->isHEAD;
                WWWDoc.safe = doc->safe;
                BVar2 = HTLoadAbsolute(&WWWDoc);
                status = (int)BVar2;
              }
              else {
                lynx_edit_mode = '\0';
              }
              local_6c = status;
            }
            return local_6c;
          }
          *Msg = '\0';
          HTSACopy(&temp,doc->address);
          Msg = Msg + 3;
          if ((*Msg != '\0') && (iVar3 = strncmp(Msg,"%09",3), iVar3 != 0)) {
            HTSACat(&temp,"?");
            HTSACat(&temp,Msg);
            Msg = strstr(temp,"%09");
            if (Msg != (char *)0x0) {
              *Msg = '\0';
            }
          }
          HTSACopy(&doc->address,temp);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          goto Try_Redirected_URL;
        }
      }
    }
    if ((ftp_ok == '\0') && ((url_type == FTP_URL_TYPE || (url_type == NCFTP_URL_TYPE)))) {
      Msg = (char *)gettext("Ftp access is disabled!");
      HTUserMsg(Msg);
      return 3;
    }
    if (url_type == HTML_GOPHER_URL_TYPE) {
      msg = (char *)0x0;
      Msg = strchr(doc->address + 9,0x2f);
      if (Msg != (char *)0x0) {
        iVar3 = strncmp(Msg + 1,"hGET%20/",8);
        if (iVar3 == 0) {
          HTSACopy(&msg,"http://");
          if (WWW_TraceFlag != '\0') {
            Msg2 = doc->address;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"getfile: URL \'%s\'\n",Msg2);
          }
          Msg[1] = '\0';
          HTSACat(&msg,doc->address + 9);
          Msg2 = strchr(msg + 6,0x3a);
          if (Msg2 == (char *)0x0) {
            HTSACat(&msg,"70/");
            Msg2 = msg;
            __n = strlen(msg);
            Msg2[__n - 4] = ':';
          }
          __n = strlen(Msg + 8);
          if (1 < __n) {
            HTSACat(&msg,Msg + 9);
          }
          HTSACopy(&doc->address,msg);
          if (WWW_TraceFlag != '\0') {
            Msg = doc->address;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"  changed to \'%s\'\n",Msg);
          }
          if (msg != (char *)0x0) {
            free(msg);
            msg = (char *)0x0;
          }
          url_type = HTTP_URL_TYPE;
        }
      }
    }
    if ((((url_type == HTTP_URL_TYPE) || (url_type == HTTPS_URL_TYPE)) || (url_type == FTP_URL_TYPE)
        ) || ((url_type == NCFTP_URL_TYPE || (url_type == CSO_URL_TYPE)))) {
      fix_httplike_urls(doc,url_type);
    }
    WWWDoc.address = doc->address;
    lynx_edit_mode = '\0';
    if (url_type == BIBP_URL_TYPE) {
      msg = (char *)0x0;
      if (BibP_bibhost_checked == '\0') {
        LYCheckBibHost();
      }
      if (BibP_bibhost_available == '\0') {
        if ((HTMainAnchor == (HTParentAnchor *)0x0) ||
           (Msg = HTAnchor_citehost(HTMainAnchor), Msg == (char *)0x0)) {
          HTSACopy(&msg,BibP_globalserver);
        }
        else {
          Msg = HTAnchor_citehost(HTMainAnchor);
          HTSACopy(&msg,Msg);
        }
      }
      else {
        HTSACopy(&msg,BibP_bibhost);
      }
      if ((HTMainAnchor == (HTParentAnchor *)0x0) ||
         (Msg = HTAnchor_citehost(HTMainAnchor), Msg == (char *)0x0)) {
        HTSACat(&msg,"bibp1.0/resolve?usin=");
      }
      else {
        HTSACat(&msg,"bibp1.0/resolve?citehost=");
        Msg = HTAnchor_citehost(HTMainAnchor);
        HTSACat(&msg,Msg);
        HTSACat(&msg,"&usin=");
      }
      HTSACat(&msg,doc->address + 5);
      HTSACopy(&doc->address,msg);
      WWWDoc.address = doc->address;
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
    }
    if (url_type == FILE_URL_TYPE) {
      LYTildeExpand(&doc->address,'\x01');
      WWWDoc.address = doc->address;
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(MessageSecs);
    }
    Msg = doc->address;
    Msg2 = (char *)gettext("Getting %s");
    user_message(Msg2,Msg);
    if ((WWW_TraceFlag != '\0') && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
    BVar2 = HTLoadAbsolute(&WWWDoc);
    if (BVar2 != '\0') {
      lynx_mode = '\x01';
      Msg = strchr(doc->address,0x23);
      if (WWW_Download_File != (char *)0x0) {
        me = HTAnchor_findAddress(&WWWDoc);
        msg = (char *)0x0;
        Msg = HTAnchor_SugFname(me);
        if (Msg == (char *)0x0) {
          HTSACopy(&msg,doc->address);
        }
        else {
          Msg = HTAnchor_SugFname(me);
          HTSACopy(&msg,Msg);
        }
        HTCheckFnameForCompression(&msg,me,'\0');
        iVar3 = LYdownload_options(&msg,WWW_Download_File);
        if (iVar3 < 0) {
          if (msg != (char *)0x0) {
            free(msg);
          }
          return 0;
        }
        LYAddVisitedLink(doc);
        HTSACopy(&doc->address,msg);
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
        doc->internal_link = '\0';
        WWWDoc.address = doc->address;
        LYFreePostData(doc);
        WWWDoc.post_data = (bstring *)0x0;
        WWWDoc.post_content_type = (char *)0x0;
        doc->bookmark = (char *)0x0;
        WWWDoc.bookmark = doc->bookmark;
        doc->isHEAD = '\0';
        WWWDoc.isHEAD = doc->isHEAD;
        doc->safe = '\0';
        WWWDoc.safe = doc->safe;
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
        BVar2 = HTLoadAbsolute(&WWWDoc);
        if (BVar2 != '\0') {
          return 1;
        }
        return 0;
      }
      if (Msg == (char *)0x0) {
        Msg2 = HTLoadedDocumentURL();
        iVar3 = strcmp(doc->address,Msg2);
        if (iVar3 == 0) {
          b = HTLoadedDocumentPost_data();
          BVar2 = HTSABEql(doc->post_data,b);
          if ((BVar2 != '\0') &&
             (cVar1 = doc->isHEAD, BVar2 = HTLoadedDocumentIsHEAD(), cVar1 == BVar2))
          goto LAB_08077653;
        }
        LYAddVisitedLink(doc);
        return 3;
      }
LAB_08077653:
      if (Msg != (char *)0x0) {
        if (HTMainText == (HText *)0x0) {
          return 3;
        }
        BVar2 = HTFindPoundSelector(Msg + 1);
        if (BVar2 != '\0') {
          *target = www_search_result;
          doc->link = -1;
        }
      }
      return 1;
    }
    if (use_this_url_instead == (char *)0x0) {
      if (HTNoDataOK == 0) {
        return 0;
      }
      return 3;
    }
    UVar6 = is_url(use_this_url_instead);
    if (UVar6 == NOT_A_URL_TYPE) {
      Msg = (char *)gettext("Location URL is not absolute.");
      HTUserMsg(Msg);
      temp = HTParse(use_this_url_instead,WWWDoc.address,0x1f);
      if ((temp != (char *)0x0) && (*temp != '\0')) {
        HTSACopy(&use_this_url_instead,temp);
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
    }
    UVar6 = is_url(use_this_url_instead);
    if ((HTPermitRedir == '\0') &&
       ((((((((UVar6 == LYNXDOWNLOAD_URL_TYPE || (UVar6 == LYNXEXEC_URL_TYPE)) ||
             (UVar6 == LYNXPROG_URL_TYPE)) ||
            ((((UVar6 == LYNXDIRED_URL_TYPE || (UVar6 == LYNXPRINT_URL_TYPE)) ||
              ((UVar6 == LYNXOPTIONS_URL_TYPE ||
               ((UVar6 == LYNXCFG_URL_TYPE || (UVar6 == LYNXCOMPILE_OPTS_URL_TYPE)))))) ||
             (UVar6 == LYNXHIST_URL_TYPE)))) ||
           (((((UVar6 == LYNXCOOKIE_URL_TYPE || (UVar6 == LYNXMESSAGES_URL_TYPE)) ||
              ((LYValidate != '\0' && ((UVar6 != HTTP_URL_TYPE && (UVar6 != HTTPS_URL_TYPE)))))) ||
             (((no_file_url != '\0' || (no_goto_file != '\0')) && (UVar6 == FILE_URL_TYPE)))) ||
            (((((no_goto_lynxcgi != '\0' && (UVar6 == LYNXCGI_URL_TYPE)) ||
               ((no_goto_bibp != '\0' && (UVar6 == BIBP_URL_TYPE)))) ||
              ((no_goto_cso != '\0' && (UVar6 == CSO_URL_TYPE)))) ||
             (((no_goto_finger != '\0' && (UVar6 == FINGER_URL_TYPE)) ||
              (((no_goto_ftp != '\0' && ((UVar6 == FTP_URL_TYPE || (UVar6 == NCFTP_URL_TYPE)))) ||
               ((no_goto_gopher != '\0' && (UVar6 == GOPHER_URL_TYPE)))))))))))) ||
          ((((no_goto_http != '\0' && (UVar6 == HTTP_URL_TYPE)) ||
            ((no_goto_https != '\0' && (UVar6 == HTTPS_URL_TYPE)))) ||
           (((no_goto_mailto != '\0' && (UVar6 == MAILTO_URL_TYPE)) ||
            ((no_goto_news != '\0' && (UVar6 == NEWS_URL_TYPE)))))))) ||
         (((((no_goto_nntp != '\0' && (UVar6 == NNTP_URL_TYPE)) ||
            ((no_goto_rlogin != '\0' && (UVar6 == RLOGIN_URL_TYPE)))) ||
           ((no_goto_snews != '\0' && (UVar6 == SNEWS_URL_TYPE)))) ||
          ((no_goto_telnet != '\0' && (UVar6 == TELNET_URL_TYPE)))))) ||
        (((no_goto_tn3270 != '\0' && (UVar6 == TN3270_URL_TYPE)) ||
         ((no_goto_wais != '\0' && (UVar6 == WAIS_URL_TYPE)))))))) {
      Msg = (char *)gettext("Illegal redirection URL received from server!");
      HTAlert(Msg);
      Msg = use_this_url_instead;
      if (LYCursesON == '\0') {
        Msg2 = (char *)gettext("Illegal URL: %s");
        fprintf(stderr,Msg2,Msg);
      }
      else {
        Msg2 = (char *)gettext("Illegal URL: %s");
        HTUserMsg2(Msg2,Msg);
      }
      if (use_this_url_instead != (char *)0x0) {
        free(use_this_url_instead);
        use_this_url_instead = (char *)0x0;
      }
      return 3;
    }
    Msg = strchr(doc->address,0x23);
    if ((Msg != (char *)0x0) && (Msg2 = strchr(use_this_url_instead,0x23), Msg2 == (char *)0x0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"getfile: Adding fragment \'%s\' to redirection URL.\n",Msg);
      }
      HTSACat(&use_this_url_instead,Msg);
      doc->link = -1;
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(MessageSecs);
    }
    Msg = use_this_url_instead;
    Msg2 = (char *)gettext("Using %s");
    HTUserMsg2(Msg2,Msg);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
    HTSACopy(&doc->address,use_this_url_instead);
    if (use_this_url_instead != (char *)0x0) {
      free(use_this_url_instead);
      use_this_url_instead = (char *)0x0;
    }
    if (redirect_post_content == '\0') {
      LYFreePostData(doc);
    }
  } while( true );
}



void srcmode_for_next_retrieval(int mode)

{
  if (mode < 0) {
    HTOutputFormat = (HTFormat)HTAtom_for("www/present");
    psrc_view = '\0';
  }
  else {
    if (mode == 0) {
      if (HTOutputFormat == (HTFormat)WWW_SOURCE) {
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
      }
      else {
        if (LYpsrc != '\0') {
          psrc_view = '\0';
        }
      }
    }
    else {
      if (LYpsrc == '\0') {
        HTOutputFormat = (HTFormat)WWW_SOURCE;
      }
      else {
        psrc_view = '\x01';
      }
    }
  }
  return;
}



int follow_link_number(int c,int cur,DocInfo *doc,int *num)

{
  int iVar1;
  FILE *__stream;
  char *text_00;
  int iVar2;
  ushort **ppuVar3;
  int iVar4;
  int in_GS_OFFSET;
  int local_d8;
  int local_d4;
  int local_d0;
  int local_cc;
  int local_c8;
  char local_c4;
  char *text;
  int info;
  int curpage;
  int npages;
  int nlines;
  int curline;
  int new_link;
  int new_top;
  int rel;
  char *p;
  BOOLEAN want_go;
  char temp [120];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = temp;
  rel = 0;
  iVar4 = *num;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"follow_link_number(%d,%d,...)\n",c,cur);
  }
  temp[0] = (char)c;
  temp[1] = '\0';
  *num = -1;
  mustshow = '\x01';
  text_00 = (char *)gettext("Follow link (or goto link or page) number: ");
  statusline(text_00);
  iVar2 = LYgetstr(temp,0,0x78,NORECALL);
  if ((iVar2 < 0) || (temp[0] == '\0')) {
    text_00 = (char *)gettext("Cancelled!!!");
    HTInfoMsg(text_00);
    local_d8 = 0x10e;
  }
  else {
    iVar2 = atoi(p);
    *num = iVar2;
    while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x800) != 0) {
      p = p + 1;
    }
    iVar2 = (int)*p;
    if ((iVar2 == 0x2b) || (iVar2 == 0x2d)) {
      c = (int)p[1];
      rel = iVar2;
    }
    else {
      c = iVar2;
      if (iVar2 != 0) {
        rel = (int)p[1];
      }
    }
    if (WWW_TraceFlag != '\0') {
      iVar2 = *num;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"  temp=%s, *num=%d, rel=\'%c\'\n",temp,iVar2,rel);
    }
    iVar2 = LYlines;
    if (((c == 0x70) || (c == 0x50)) && (display_lines == 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream," curline=%d, LYlines=%d, display too small!\n",iVar4,iVar2);
      }
      local_d8 = 5;
    }
    else {
      if ((c == 0x70) || (c == 0x50)) {
        iVar2 = HText_getNumOfLines();
        if (display_lines < iVar2 + 1) {
          local_d4 = (iVar2 + display_lines) / display_lines;
        }
        else {
          local_d4 = 1;
        }
        if (display_lines < iVar4 + 1) {
          local_d0 = (iVar4 + display_lines) / display_lines;
        }
        else {
          local_d0 = 1;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream," nlines=%d, npages=%d, curline=%d, curpage=%d\n",iVar2,local_d4,
                  iVar4,local_d0);
        }
        if (*num < 1) {
          *num = (uint)(rel == 0);
        }
        if (rel == 0x2b) {
          *num = *num + local_d0;
        }
        else {
          if (rel == 0x2d) {
            *num = local_d0 - *num;
          }
        }
        if (local_d4 < 2) {
          local_cc = 1;
        }
        else {
          if (*num <= local_d4) {
            local_d4 = *num;
          }
          local_c8 = display_lines * (local_d4 + -1) + 1;
          local_cc = local_c8;
        }
        doc->line = local_cc;
        local_d8 = 3;
      }
      else {
        if ((c == 0x67) || (c == 0x47)) {
          local_c4 = '\x01';
        }
        else {
          local_c4 = '\0';
        }
        if (rel != 0) {
          iVar4 = HTGetRelLinkNum(*num,rel,cur);
          *num = iVar4;
        }
        if (*num < 1) {
          local_d8 = 5;
        }
        else {
          text = (char *)0x0;
          iVar4 = HTGetLinkInfo(*num,(int)local_c4,&new_top,&new_link,&text,(char **)(links + cur));
          if (text != (char *)0x0) {
            LYSetHilite(cur,text);
          }
          if (iVar4 == 6) {
            links[cur].type = 6;
            local_d8 = 1;
          }
          else {
            if (iVar4 == 8) {
              doc->line = new_top + 1;
              doc->link = new_link;
              local_d8 = 2;
            }
            else {
              if (iVar4 == 0) {
                local_d8 = 5;
              }
              else {
                links[cur].type = 2;
                local_d8 = 1;
              }
            }
          }
        }
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_d8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void add_trusted(char *str,int type)

{
  BOOLEAN first;
  trust *dest;
  int Type;
  char *src;
  char *path;
  trust *tp;
  
  if (str != (char *)0x0) {
    if (first != '\0') {
      first = '\0';
    }
    path = strchr(str,9);
    if (path == (char *)0x0) {
      path = "";
    }
    else {
      *path = '\0';
      path = path + 1;
    }
    dest = (trust *)malloc(0x10);
    if (dest == (trust *)0x0) {
      outofmem("./LYGetFile.c","add_trusted");
    }
    dest->src = (char *)0x0;
    dest->path = (char *)0x0;
    dest->type = type;
    HTSACopy((char **)dest,str);
    HTSACopy(&dest->path,path);
    if (type == 0) {
      if (trusted_exec == &trusted_exec_default) {
        dest->next = (trust *)0x0;
        trusted_exec = dest;
      }
      else {
        dest->next = trusted_exec;
        trusted_exec = dest;
      }
    }
    else {
      if (type == 1) {
        if (always_trusted_exec == &always_trusted_exec_default) {
          dest->next = (trust *)0x0;
          always_trusted_exec = dest;
        }
        else {
          dest->next = always_trusted_exec;
          always_trusted_exec = dest;
        }
      }
      else {
        if (type == 2) {
          if (trusted_cgi == &trusted_cgi_default) {
            dest->next = (trust *)0x0;
            trusted_cgi = dest;
          }
          else {
            dest->next = trusted_cgi;
            trusted_cgi = dest;
          }
        }
      }
    }
  }
  return;
}



BOOLEAN exec_ok(char *source,char *linktext,int type)

{
  char cVar1;
  char *Msg;
  ushort **ppuVar2;
  FILE *__stream;
  size_t __n;
  int iVar3;
  BOOLEAN local_29;
  char *command;
  char *buf;
  int Type;
  char *allowed_extra_chars;
  char *cp;
  trust *tp;
  
  Type = type;
  if (LYJumpFileURL == '\0') {
    if (type == 0) {
      tp = trusted_exec;
    }
    else {
      if (type == 1) {
        tp = always_trusted_exec;
      }
      else {
        if (type != 2) {
          Msg = (char *)gettext("Executable link rejected due to malformed request.");
          HTAlert(Msg);
          return '\0';
        }
        tp = trusted_cgi;
      }
    }
    Msg = strstr(linktext,"../");
    if (Msg == (char *)0x0) {
      if (type == 2) {
        allowed_extra_chars = " _-:./@~$&+=\t";
      }
      else {
        allowed_extra_chars = " _-:./@~$+=\t";
      }
      cp = linktext;
      while (*cp != '\0') {
        ppuVar2 = __ctype_b_loc();
        if ((((*ppuVar2)[(byte)*cp] & 8) == 0) &&
           (Msg = strchr(allowed_extra_chars,(int)*cp), Msg == (char *)0x0)) {
          buf = (char *)0x0;
          cVar1 = *cp;
          Msg = (char *)gettext("Executable link rejected due to `%c\' character.");
          HTSprintf0(&buf,Msg,(int)cVar1);
          HTAlert(buf);
          if (buf != (char *)0x0) {
            free(buf);
          }
          return '\0';
        }
        cp = cp + 1;
      }
      while( true ) {
        while (tp != (trust *)0x0) {
          if (tp->type == Type) {
            command = linktext;
            Msg = strstr(linktext,"//");
            if (Msg == linktext) {
              command = linktext + 2;
            }
            if (WWW_TraceFlag != '\0') {
              Msg = tp->src;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"comparing source\n\t\'%s\'\n\t\'%s\'\n",source,Msg);
            }
            if (WWW_TraceFlag != '\0') {
              Msg = tp->path;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"comparing command\n\t\'%s\'\n\t\'%s\'\n",command,Msg);
            }
            __n = strlen(tp->src);
            iVar3 = strncmp(source,tp->src,__n);
            if (iVar3 == 0) {
              __n = strlen(tp->path);
              iVar3 = strncmp(command,tp->path,__n);
              if (iVar3 == 0) {
                return '\x01';
              }
            }
          }
          tp = tp->next;
        }
        if ((Type != 0) || (always_trusted_exec == &always_trusted_exec_default)) break;
        Type = 1;
        tp = always_trusted_exec;
      }
      if ((no_exec == '\0') || (type != 1)) {
        Msg = (char *)gettext("Executable link rejected due to location or path.");
        HTAlert(Msg);
      }
      local_29 = '\0';
    }
    else {
      Msg = (char *)gettext("Executable link rejected due to relative path string (\'../\').");
      HTAlert(Msg);
      local_29 = '\0';
    }
  }
  else {
    local_29 = '\x01';
  }
  return local_29;
}



int fix_httplike_urls(DocInfo *doc,UrlTypes type)

{
  char *pcVar1;
  BOOLEAN BVar2;
  char *__s;
  size_t sVar3;
  FILE *__stream;
  char *pcVar4;
  char *second;
  char *first;
  char *path_1;
  char *path;
  char *proxy;
  char *slash;
  
  __s = strchr(doc->address,0x23);
  if (__s != (char *)0x0) {
    return 0;
  }
  if ((type == FTP_URL_TYPE) &&
     (__s = doc->address, sVar3 = strlen(doc->address), __s[sVar3 - 1] == '/')) {
    __s = HTParse(doc->address,"",5);
    if (__s != (char *)0x0) {
      if ((*__s == '/') && (__s[1] == '\0')) {
        if (__s != (char *)0x0) {
          free(__s);
        }
        return 0;
      }
      if (__s != (char *)0x0) {
        free(__s);
      }
    }
    __s = LYGetEnv("ftp_proxy");
    if ((__s != (char *)0x0) && (BVar2 = override_proxy(doc->address), BVar2 == '\0')) {
      return 0;
    }
    if (WWW_TraceFlag != '\0') {
      __s = doc->address;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"fix_httplike_urls: URL \'%s\'\n",__s);
    }
    LYTrimHtmlSep(doc->address);
    if (WWW_TraceFlag != '\0') {
      __s = doc->address;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"            changed to \'%s\'\n",__s);
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(MessageSecs);
    }
  }
  else {
    if (type == NCFTP_URL_TYPE) {
      path_1 = (char *)0x0;
      __s = doc->address;
      pcVar4 = strchr(__s,0x3a);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = doc->address;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"fix_httplike_urls: URL \'%s\'\n",pcVar1);
      }
      *pcVar4 = '\0';
      HTSprintf0(&path_1,"%s//%s%s",&DAT_0814f68a,__s,pcVar4 + 1);
      if (doc->address != (char *)0x0) {
        free(doc->address);
        doc->address = (char *)0x0;
      }
      doc->address = path_1;
      if (WWW_TraceFlag != '\0') {
        __s = doc->address;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"            changed to \'%s\'\n",__s);
      }
      if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
        sleep(MessageSecs);
      }
    }
  }
  __s = strrchr(doc->address,0x2f);
  if (__s != (char *)0x0) {
    if ((__s[-1] != '/') || (__s[-2] != ':')) {
      return 0;
    }
    if ((type == HTTP_URL_TYPE) || (type == HTTPS_URL_TYPE)) {
      pcVar4 = strchr(doc->address,0x3a);
      if (__s + -2 != pcVar4) {
        return 0;
      }
      __s = strchr(doc->address,0x3f);
      if (__s != (char *)0x0) {
        return 0;
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    __s = doc->address;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"fix_httplike_urls: URL \'%s\'\n",__s);
  }
  LYAddHtmlSep(&doc->address);
  if (WWW_TraceFlag != '\0') {
    __s = doc->address;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"            changed to \'%s\'\n",__s);
  }
  if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
    sleep(MessageSecs);
  }
  return 1;
}



void LYStdinArgs_free(void)

{
  LYFreeStringList(LYStdinArgs);
  LYStdinArgs = (HTList *)0x0;
  return;
}



void reset_signals(void)

{
  signal(1,(__sighandler_t)0x0);
  signal(0xf,(__sighandler_t)0x0);
  signal(2,(__sighandler_t)0x0);
  if (no_suspend != '\0') {
    signal(0x14,(__sighandler_t)0x0);
  }
  return;
}



void exit_immediately(int code)

{
  reset_signals();
  LYexit(code);
  return;
}



BOOLEAN GetStdin(char **buf,BOOLEAN marker)

{
  char *pcVar1;
  int iVar2;
  FILE *__stream;
  BOOLEAN local_11;
  char *local_10;
  
  pcVar1 = LYSafeGets(buf,stdin);
  if (pcVar1 == (char *)0x0) {
LAB_080786e8:
    if (WWW_TraceFlag != '\0') {
      if (*buf == (char *)0x0) {
        local_10 = "";
      }
      else {
        local_10 = *buf;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...mark: %s\n",local_10);
    }
    local_11 = '\0';
  }
  else {
    if (marker != '\0') {
      iVar2 = strncmp(*buf,"---",3);
      if (iVar2 == 0) goto LAB_080786e8;
    }
    LYTrimTrailing(*buf);
    if (WWW_TraceFlag != '\0') {
      pcVar1 = *buf;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...data: %s\n",pcVar1);
    }
    local_11 = '\x01';
  }
  return local_11;
}



void SetLocale(void)

{
  char *cp;
  
  setlocale(6,"");
  cp = LYGetEnv("LYNX_LOCALEDIR");
  if (cp == (char *)0x0) {
    cp = "/usr/share/locale";
  }
  bindtextdomain(&DAT_0814f6e0,cp);
  textdomain(&DAT_0814f6e0);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: stack

int main(char **argv)

{
  int iVar1;
  bool bVar2;
  BOOLEAN BVar3;
  char *src;
  char *src_00;
  int __fd;
  undefined4 uVar4;
  FILE *fp_00;
  HTAtom *pHVar5;
  __sighandler_t p_Var6;
  int iVar7;
  int in_GS_OFFSET;
  char **in_stack_00000008;
  EVP_PKEY_CTX *local_300;
  HTList *local_2f8;
  HTList *pHVar8;
  HTList *local_2e4;
  int local_2e0;
  BOOLEAN local_2dc;
  BOOLEAN local_2d8;
  BOOLEAN local_2d4;
  BOOLEAN local_2d0;
  BOOLEAN local_2cc;
  BOOLEAN local_2c8;
  BOOLEAN local_2c4;
  BOOLEAN local_2c0;
  undefined local_2b4 [4];
  stat dir_info;
  char *noargv [2];
  char *argument;
  int ch;
  int ignored;
  HTList *cur;
  char *buf;
  char *cp1;
  FILE *fp;
  char *cp;
  char *temp;
  int status;
  int i;
  char local_21c [3];
  BOOLEAN LYGetStdinArgs;
  char result [256];
  char filename [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  temp = (char *)0x0;
  cp = (char *)0x0;
  bVar2 = false;
  ftp_lasthost = (char *)calloc(1,1);
  LYShowColor = 2;
  pgm = *in_stack_00000008;
  src = LYLastPathSep(pgm);
  if (src != (char *)0x0) {
    pgm = src + 1;
  }
  src = LYGetEnv("LYNX_TRACE");
  if (src != (char *)0x0) {
    WWW_TraceFlag = '\x01';
  }
  fp = (FILE *)LYGetEnv("LYNX_TRACE_FILE");
  if (fp == (FILE *)0x0) {
    fp = (FILE *)0x814f700;
  }
  LYTraceLogPath = (char *)malloc(0x100);
  LYAddPathToHome(LYTraceLogPath,0x100,(char *)fp);
  status = 1;
  while (status < (int)argv) {
    parse_arg(in_stack_00000008 + status,1,&status);
    status = status + 1;
  }
  LYOpenTraceLog();
  SetLocale();
  memset(links,0,0x11000);
  LYAllocHistory(8);
  memset(MBM_A_subbookmark,0,0x1a);
  local_2f8 = (HTList *)0x1a;
  memset(MBM_A_subdescript,0,0x1a);
  HTSACopy(&list_format,"    %p %4l %-8.8o %-8.8g %7s %-12.12d %a");
  AlertSecs = 3000;
  DebugSecs = 0;
  InfoSecs = 1000;
  MessageSecs = 2000;
  ReplaySecs = 0;
  HTSACopy(&LYTransferName,"KiB");
  HTSACopy(&helpfile,"http://lynx.isc.org/release/lynx2-8-6/lynx_help/lynx_help_main.html");
  HTSACopy(&startfile,"http://lynx.isc.org/");
  LYEscapeStartfile(&startfile);
  HTSACopy(&indexfile,"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/MetaIndex.html");
  HTSACopy(&global_type_map,"/etc/mailcap");
  HTSACopy(&personal_type_map,"~/.mailcap");
  HTSACopy(&global_extension_map,"/etc/mime.types");
  HTSACopy(&personal_extension_map,"~/.mime.types");
  HTSACopy(&language,"en");
  HTSACopy(&pref_charset,"");
  HTSACopy(&system_mail,"/usr/sbin/sendmail");
  HTSACopy(&system_mail_flags,"-t -oi");
  HTSACopy(&LYUserAgent,"Lynx");
  HTSACat(&LYUserAgent,"/");
  HTSACat(&LYUserAgent,"2.8.7dev.11");
  if (HTLibraryVersion != (char *)0x0) {
    HTSACat(&LYUserAgent," libwww-FM/");
    HTSACat(&LYUserAgent,HTLibraryVersion);
  }
  HTSACopy(&LYUserAgentDefault,LYUserAgent);
  HTSACopy(&lynx_version_putenv_command,"LYNX_VERSION=");
  HTSACat(&lynx_version_putenv_command,"2.8.7dev.11");
  putenv(lynx_version_putenv_command);
  src = LYGetEnv("LYNX_TEMP_SPACE");
  if (src == (char *)0x0) {
    src = LYGetEnv("TMPDIR");
    if (src == (char *)0x0) {
      HTSACopy(&lynx_temp_space,"/tmp/");
    }
    else {
      HTSACopy(&lynx_temp_space,src);
    }
  }
  else {
    HTSACopy(&lynx_temp_space,src);
  }
  LYTildeExpand(&lynx_temp_space,'\x01');
  src = strstr(lynx_temp_space,"$USER");
  if ((src != (char *)0x0) && (src_00 = LYGetEnv("USER"), src_00 != (char *)0x0)) {
    *src = '\0';
    HTSACopy(&cp,lynx_temp_space);
    *src = '$';
    HTSACat(&cp,src_00);
    HTSACat(&cp,src + 5);
    HTSACopy(&lynx_temp_space,cp);
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
  }
  LYAddPathSep(&lynx_temp_space);
  HTSACopy(&lynx_temp_space,lynx_temp_space);
  __fd = HTStat(lynx_temp_space,(stat *)local_2b4);
  if (((__fd < 0) && (__fd = mkdir(lynx_temp_space,0x1c0), __fd < 0)) ||
     ((dir_info.__st_ino & 0xf000) != 0x4000)) {
    uVar4 = gettext("No such directory");
    local_2f8 = (HTList *)lynx_temp_space;
    fprintf(stderr,"%s: %s\n",lynx_temp_space,uVar4);
    exit_immediately(1);
  }
  src = HTHostName();
  HTSACopy(&LYHostName,src);
  HTSACopy(&LYLocalDomain,"ukans.edu");
  HTSACopy(&URLDomainPrefixes,"www.");
  HTSACopy(&URLDomainSuffixes,".com,.edu,.net,.org");
  HTSACopy(&XLoadImageCommand,"xli %s &");
  HTSACopy(&SSL_cert_file,(char *)0x0);
  HTSACopy(&BibP_globalserver,"http://usin.org/");
  HTSACopy(&BibP_bibhost,"http://bibhost/");
  no_newspost = LYNewsPosting == '\0';
  status = 1;
  while (status < (int)argv) {
    local_2f8 = (HTList *)&status;
    parse_arg(in_stack_00000008 + status,2,(int *)local_2f8);
    status = status + 1;
  }
  status = 1;
  while (status < (int)argv) {
    __fd = strcmp(in_stack_00000008[status],"-");
    if (__fd == 0) {
      bVar2 = true;
      break;
    }
    status = status + 1;
  }
  if (bVar2) {
    cur = (HTList *)0x0;
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"processing stdin arguments\n");
    }
    while (BVar3 = GetStdin((char **)&cur,'\x01'), BVar3 != '\0') {
      dir_info.st_ino._4_4_ = cur;
      noargv[0] = (char *)0x0;
      LYTrimTrailing((char *)cur);
      local_2f8 = (HTList *)0x0;
      BVar3 = parse_arg((char **)((int)&dir_info.st_ino + 4),2,(int *)0x0);
      pHVar8 = cur;
      if ((BVar3 == '\0') && (*(char *)&cur->object != '\0')) {
        noargv[1] = (char *)0x0;
        if (LYStdinArgs == (HTList *)0x0) {
          LYStdinArgs = HTList_new();
        }
        HTSACopy(noargv + 1,(char *)cur);
        HTList_appendObject(LYStdinArgs,noargv[1]);
        pHVar8 = (HTList *)noargv[1];
        if (WWW_TraceFlag != '\0') {
          fp_00 = TraceFP();
          fprintf((FILE *)fp_00,"...StdinArg:%s\n",pHVar8);
          local_2f8 = pHVar8;
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          fp_00 = TraceFP();
          fprintf((FILE *)fp_00,"...complete:%s\n",pHVar8);
          local_2f8 = pHVar8;
        }
      }
    }
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"...done with stdin arguments\n",local_2f8);
    }
    if (cur != (HTList *)0x0) {
      free(cur);
      cur = (HTList *)0x0;
    }
  }
  if (LYValidate == '\x01') {
    parse_restrictions("all");
    LYUseTraceLog = '\0';
  }
  if (lynx_cmd_script != (char *)0x0) {
    LYTildeExpand(&lynx_cmd_script,'\x01');
    LYOpenCmdScript();
  }
  if (lynx_cmd_logfile != (char *)0x0) {
    LYTildeExpand(&lynx_cmd_logfile,'\x01');
    LYOpenCmdLogfile((int)argv,in_stack_00000008);
  }
  src = (char *)gettext("Jump to (use \'?\' for list): ");
  HTSACopy(&jumpprompt,src);
  if ((lynx_cfg_file == (char *)0x0) &&
     ((fp = (FILE *)LYGetEnv("LYNX_CFG"), fp != (FILE *)0x0 ||
      (fp = (FILE *)LYGetEnv("lynx_cfg"), fp != (FILE *)0x0)))) {
    HTSACopy(&lynx_cfg_file,(char *)fp);
  }
  if (lynx_cfg_file == (char *)0x0) {
    HTSACopy(&lynx_cfg_file,"/etc/lynx-cur/lynx.cfg");
  }
  LYTildeExpand(&lynx_cfg_file,'\0');
  BVar3 = LYCanReadFile(lynx_cfg_file);
  src = lynx_cfg_file;
  if (BVar3 == '\0') {
    src_00 = (char *)gettext("\nConfiguration file \"%s\" is not available.\n\n");
    fprintf(stderr,src_00,src);
    exit_immediately(1);
  }
  __fd = LYCharSetsDeclared();
  if (__fd == 0) {
    src = (char *)gettext("\nLynx character sets not declared.\n\n");
    fprintf(stderr,src);
    exit_immediately(1);
  }
  current_char_set = safeUCGetLYhndl_byMIME("iso-8859-1");
  UCLYhndl_for_unspec = LATIN1;
  HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[LATIN1].MIMEname);
  __fd = LYEditmapDeclared();
  if (__fd == 0) {
    src = (char *)gettext("\nLynx edit map not declared.\n\n");
    fprintf(stderr,src);
    exit_immediately(1);
  }
  lynx_setup_colors();
  src = Current_Dir(result + 0xfc);
  __fd = strcmp(src,".");
  if (__fd == 0) {
    src = LYGetEnv("PWD");
    if (src != (char *)0x0) {
      HTSACopy(&original_dir,src);
    }
  }
  else {
    HTSACopy(&original_dir,result + 0xfc);
  }
  LYstrncpy(result + 0xfc,".lynxsig",0xff);
  BVar3 = LYPathOffHomeOK(result + 0xfc,0x100);
  if (BVar3 == '\0') {
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"LYNX_SIG_FILE \'%s\' is bad. Ignoring.\n",".lynxsig");
    }
  }
  else {
    HTSACopy(&LynxSigFile,result + 0xfc);
    LYAddPathToHome(result + 0xfc,0x100,LynxSigFile);
    HTSACopy(&LynxSigFile,result + 0xfc);
    src = LynxSigFile;
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"LYNX_SIG_FILE set to \'%s\'\n",src);
    }
  }
  HTSwitchDTD(1);
  read_cfg(lynx_cfg_file,"main program",1,(FILE *)0x0);
  if (lynx_lss_file2 != (char *)0x0) {
    if (lynx_lss_file != (char *)0x0) {
      free(lynx_lss_file);
    }
    lynx_lss_file = lynx_lss_file2;
    lynx_lss_file2 = (char *)0x0;
  }
  if ((lynx_lss_file == (char *)0x0) &&
     ((fp = (FILE *)LYGetEnv("LYNX_LSS"), fp != (FILE *)0x0 ||
      (fp = (FILE *)LYGetEnv("lynx_lss"), fp != (FILE *)0x0)))) {
    HTSACopy(&lynx_lss_file,(char *)fp);
  }
  if (lynx_lss_file == (char *)0x0) {
    HTSACopy(&lynx_lss_file,"/etc/lynx-cur/lynx.lss");
  }
  LYTildeExpand(&lynx_lss_file,'\x01');
  if (((lynx_lss_file == (char *)0x0) || (*lynx_lss_file == '\0')) ||
     (BVar3 = LYCanReadFile(lynx_lss_file), src = lynx_lss_file, BVar3 != '\0')) {
    style_readFromFile(lynx_lss_file);
  }
  else {
    src_00 = (char *)gettext("\nLynx file \"%s\" is not available.\n\n");
    fprintf(stderr,src_00,src);
    exit_immediately(1);
  }
  read_rc((FILE *)0x0);
  LYFindLocaleCharset();
  src = LYGetEnv("WWW_HOME");
  if (src != (char *)0x0) {
    HTSACopy(&startfile,src);
    LYEscapeStartfile(&startfile);
  }
  HTSACopy(&LynxHome,startfile);
  LYEnsureAbsoluteURL(&LynxHome,"LynxHome",0);
  status = 1;
  while (status < (int)argv) {
    parse_arg(in_stack_00000008 + status,4,&status);
    status = status + 1;
  }
  if (LYStdinArgs != (HTList *)0x0) {
    ignored = (int)LYStdinArgs;
    noargv[0] = (char *)0x0;
    while( true ) {
      if ((ignored == 0) || (ignored = *(int *)(ignored + 4), (HTList **)ignored == (HTList **)0x0))
      {
        local_2e4 = (HTList *)0x0;
      }
      else {
        local_2e4 = (HTList *)((HTList *)ignored)->object;
      }
      dir_info.st_ino._4_4_ = local_2e4;
      if (local_2e4 == (HTList *)0x0) break;
      parse_arg((char **)((int)&dir_info.st_ino + 4),4,(int *)0x0);
    }
    LYStdinArgs_free();
  }
  if ((bVar2) || (startfile_stdin != '\0')) goto LAB_080797a2;
  __fd = fileno(stdin);
  __fd = isatty(__fd);
  if (__fd != 0) goto LAB_080797a2;
  __fd = fileno((FILE *)stdout);
  if (__fd == 0) {
    __fd = fileno(stderr);
    __fd = isatty(__fd);
    if (__fd != 0) goto LAB_080796f6;
    local_2e0 = 0;
  }
  else {
LAB_080796f6:
    local_2e0 = 1;
  }
  __fd = isatty(local_2e0);
  if (__fd != 0) {
    ch = 0;
    while (__fd = fgetc(stdin), __fd != -1) {
      ch = ch + 1;
    }
    if (ch != 0) {
      src = (char *)gettext("Ignored %d characters from standard input.\n");
      fprintf(stderr,src,ch);
      src = (char *)gettext("Use \"-stdin\" or \"-\" to tell how to handle piped input.\n");
      fprintf(stderr,src);
    }
  }
LAB_080797a2:
  if (startfile_stdin != '\0') {
    noargv[1] = (char *)0x0;
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"processing stdin startfile\n");
    }
    fp_00 = LYOpenTemp(local_21c,".html","w");
    if (fp_00 != (FILE *)0x0) {
      HTSACopy(&startfile,local_21c);
      while (BVar3 = GetStdin(noargv + 1,'\0'), BVar3 != '\0') {
        fputs(noargv[1],(FILE *)fp_00);
        fputc(10,(FILE *)fp_00);
      }
      if (noargv[1] != (char *)0x0) {
        free(noargv[1]);
        noargv[1] = (char *)0x0;
      }
      LYCloseTempFP(fp_00);
    }
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"...done stdin startfile\n");
    }
  }
  if (Old_DTD != 0) {
    HTSwitchDTD((uint)(Old_DTD == 0));
  }
  HTMLUseCharacterSet(current_char_set);
  if (persistent_cookies != '\0') {
    if (LYCookieFile == (char *)0x0) {
      LYCookieFile = (char *)malloc(0x100);
      LYAddPathToHome(LYCookieFile,0x100,".lynx_cookies");
    }
    else {
      LYTildeExpand(&LYCookieFile,'\0');
    }
    LYLoadCookies(LYCookieFile);
  }
  if (LYCookieSaveFile != (char *)0x0) {
    LYTildeExpand(&LYCookieSaveFile,'\0');
  }
  if (LYCookieSaveFile == (char *)0x0) {
    if (dump_output_immediately == '\0') {
      HTSACopy(&LYCookieSaveFile,LYCookieFile);
    }
    else {
      HTSACopy(&LYCookieSaveFile,"/dev/null");
    }
  }
  src = LYGetEnv("LYNX_HELPFILE");
  if (src != (char *)0x0) {
    HTSACopy(&helpfile,src);
  }
  HTSACopy(&helpfilepath,helpfile);
  src = LYPathLeaf(helpfilepath);
  if (src != helpfilepath) {
    *src = '\0';
  }
  LYAddHtmlSep(&helpfilepath);
  src = LYGetEnv("LYNX_SAVE_SPACE");
  if (src != (char *)0x0) {
    HTSACopy(&lynx_save_space,src);
  }
  if (((lynx_save_space != (char *)0x0) && (*lynx_save_space == '\0')) &&
     (lynx_save_space != (char *)0x0)) {
    free(lynx_save_space);
    lynx_save_space = (char *)0x0;
  }
  if (lynx_save_space != (char *)0x0) {
    LYTildeExpand(&lynx_save_space,'\x01');
    LYAddPathSep(&lynx_save_space);
  }
  HTFormatInit();
  if (FileInitAlreadyDone == '\0') {
    HTFileInit();
  }
  BVar3 = LYCheckUserAgent();
  if (BVar3 == '\0') {
    src = (char *)gettext("User-Agent string does not contain \"Lynx\" or \"L_y_n_x\"");
    src_00 = (char *)gettext("Warning:");
    HTAlwaysAlert(src_00,src);
  }
  if (LYPreparsedSource != '\0') {
    HTPreparsedFormatInit();
  }
  if (emacs_keys != '\0') {
    set_emacs_keys();
  }
  if (vi_keys != '\0') {
    set_vi_keys();
  }
  if (no_numbers != '\0') {
    number_links = '\0';
    number_fields = '\0';
    keypad_mode = 0;
    set_numbers_as_arrows();
  }
  if ((crawl != '\0') && (number_links == '\0')) {
    keypad_mode = 0;
  }
  if ((keypad_mode != 1) && (keypad_mode != 2)) {
    if (number_fields != '\0') {
      keypad_mode = 2;
    }
    if (number_links != '\0') {
      keypad_mode = 1;
    }
    set_numbers_as_arrows();
  }
  if (LYUseDefSelPop == '\0') {
    LYSelectPopups = LYSelectPopups == '\0';
  }
  if (LYUseDefShoCur == '\0') {
    LYShowCursor = LYShowCursor == '\0';
  }
  if ((LYPrependBase != '\0') &&
     (pHVar5 = HTAtom_for("www/download"), pHVar5 == (HTAtom *)HTOutputFormat)) {
    LYPrependBaseToSource = '\x01';
  }
  if (no_multibook != '\0') {
    LYMBMBlocked = '\x01';
  }
  if (((dump_output_immediately != '\0') || (LYMBMBlocked != '\0')) || (no_multibook != '\0')) {
    LYMultiBookmarks = 0;
    LYMBMBlocked = '\x01';
    no_multibook = '\x01';
  }
  if (dump_output_immediately == '\0') {
    signal(1,cleanup_sig);
  }
  else {
    LYCacheSource = 0;
    display_partial_flag = '\0';
  }
  signal(0xf,cleanup_sig);
  LYExtSignal(0x1c,size_change);
  if (((WWW_TraceFlag == '\0') && (dump_output_immediately == '\0')) && (stack_dump == '\0')) {
    signal(2,cleanup_sig);
    signal(0xb,FatalProblem);
    signal(4,FatalProblem);
    p_Var6 = signal(0xd,(__sighandler_t)0x1);
    if (p_Var6 != (__sighandler_t)0x1) {
      restore_sigpipe_for_children = '\x01';
    }
  }
  if (no_suspend != '\0') {
    signal(0x14,(__sighandler_t)0x1);
  }
  if ((HEAD_request != '\0') && (BVar3 = LYCanDoHEAD(startfile), BVar3 != '\x01')) {
    fprintf(stderr,
            "The \'-head\' switch is for http HEAD requests and cannot be used for\n\'%s\'.\n",
            startfile);
    exit_immediately(1);
  }
  if ((keep_mime_headers != '\0') && (BVar3 = LYCanDoHEAD(startfile), BVar3 != '\x01')) {
    fprintf(stderr,"The \'-mime_header\' switch is for http URLs and cannot be used for\n\'%s\'.\n",
            startfile);
    exit_immediately(1);
  }
  if ((traversal != '\0') && (__fd = strncmp(startfile,"http",4), __fd != 0)) {
    fprintf(stderr,"The \'-traversal\' switch is for http URLs and cannot be used for\n\'%s\'.\n",
            startfile);
    exit_immediately(1);
  }
  if (dump_output_immediately == '\0') {
    HTMLSRC_init_caches('\0');
  }
  if (dump_output_immediately == '\0') {
    setup(terminal);
  }
  LYEnsureAbsoluteURL(&startfile,"STARTFILE",0);
  if (homepage != (char *)0x0) {
    LYEnsureAbsoluteURL(&homepage,"HOMEPAGE",0);
  }
  if ((homepage == (char *)0x0) || (*homepage == '\0')) {
    HTSACopy(&homepage,startfile);
  }
  else {
    HTSACopy(&LynxHome,homepage);
  }
  BVar3 = inlocaldomain();
  if (BVar3 == '\0') {
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"LYMain: User in REMOTE domain\n");
    }
    if ((no_outside_telnet == '\0') && (telnet_ok != '\0')) {
      local_2cc = '\x01';
    }
    else {
      local_2cc = '\0';
    }
    telnet_ok = local_2cc;
    if ((no_outside_news == '\0') && (news_ok != '\0')) {
      local_2c8 = '\x01';
    }
    else {
      local_2c8 = '\0';
    }
    news_ok = local_2c8;
    if ((no_outside_ftp == '\0') && (ftp_ok != '\0')) {
      local_2c4 = '\x01';
    }
    else {
      local_2c4 = '\0';
    }
    ftp_ok = local_2c4;
    if ((no_outside_rlogin == '\0') && (rlogin_ok != '\0')) {
      local_2c0 = '\x01';
    }
    else {
      local_2c0 = '\0';
    }
    rlogin_ok = local_2c0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"LYMain: User in Local domain\n");
    }
    if ((no_inside_telnet == '\0') && (telnet_ok != '\0')) {
      local_2dc = '\x01';
    }
    else {
      local_2dc = '\0';
    }
    telnet_ok = local_2dc;
    if ((no_inside_news == '\0') && (news_ok != '\0')) {
      local_2d8 = '\x01';
    }
    else {
      local_2d8 = '\0';
    }
    news_ok = local_2d8;
    if ((no_inside_ftp == '\0') && (ftp_ok != '\0')) {
      local_2d4 = '\x01';
    }
    else {
      local_2d4 = '\0';
    }
    ftp_ok = local_2d4;
    if ((no_inside_rlogin == '\0') && (rlogin_ok != '\0')) {
      local_2d0 = '\x01';
    }
    else {
      local_2d0 = '\0';
    }
    rlogin_ok = local_2d0;
  }
  LYSetConfigValue("broken_ftp_retr","ProFTPD 1.2.5");
  LYSetConfigValue("broken_ftp_retr","spftp/");
  LYSetConfigValue("broken_ftp_epsv","(Version wu-2.6.2-12)");
  if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
    cp = (char *)0x0;
    HTSprintf0(&cp,"lynx_bookmarks%s",".html");
    set_default_bookmark_page(cp);
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
  }
  if ((BookmarkPage == (char *)0x0) || (*BookmarkPage == '\0')) {
    set_default_bookmark_page(bookmark_page);
  }
  LYOpenlog(syslog_txt);
  if ((x_display != (char *)0x0) && (*x_display != '\0')) {
    LYisConfiguredForX = '\x01';
  }
  if (dump_output_immediately == '\0') {
    cache_tag_styles();
    if (with_backspaces != '\0') {
      with_backspaces = '\0';
    }
    ena_csi(0x9b < LYlowest_eightbit[current_char_set]);
    temp = (char *)mainloop();
    LYCloseCloset(RECALL_URL);
    local_300 = (EVP_PKEY_CTX *)0x3;
    LYCloseCloset(RECALL_MAIL);
    cleanup(local_300);
    exit_immediately((int)temp);
  }
  else {
    if (((crawl == '\0') || (number_links != '\0')) || (number_fields != '\0')) {
      if (no_numbers == '\0') {
        if (((no_list == '\0') && (keypad_mode != 1)) && (keypad_mode != 2)) {
          if (number_fields == '\0') {
            keypad_mode = 1;
          }
          else {
            keypad_mode = 2;
          }
        }
      }
      else {
        keypad_mode = 0;
      }
    }
    else {
      keypad_mode = 0;
    }
    if (0 < dump_output_width) {
      LYcols = dump_output_width;
    }
    HTAddGotoURL(startfile);
    status = HTList_count(Goto_URLs);
    while (status = status + -1, -1 < status) {
      src = (char *)HTList_objectAt(Goto_URLs,status);
      HTSACopy(&startfile,src);
      src = startfile;
      if (WWW_TraceFlag != '\0') {
        iVar7 = HTList_count(Goto_URLs);
        __fd = status + 1;
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"dumping %d:%d %s\n",__fd,iVar7,src);
      }
      temp = (char *)mainloop();
      if ((no_list == '\0') && (crawl == '\0')) {
        printlist(stdout,'\0');
      }
      if ((void *)status != (void *)0x0) {
        putchar(10);
      }
    }
    if (persistent_cookies != '\0') {
      LYStoreCookies(LYCookieSaveFile);
    }
    exit_immediately((int)temp);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (int)temp;
}



void LYRegisterLynxProtocols(void)

{
  HTRegisterProtocol(&LYLynxKeymap);
  HTRegisterProtocol(&LYLynxCGI);
  HTRegisterProtocol(&LYLynxIMGmap);
  HTRegisterProtocol(&LYLynxCookies);
  HTRegisterProtocol(&LYLynxStatusMessages);
  return;
}



void reload_read_cfg(void)

{
  BOOLEAN BVar1;
  char *result;
  FILE *fp;
  int iVar2;
  char *Msg;
  char *LYCookieSaveFile_flag;
  char *LYCookieFile_flag;
  FILE *rcfp;
  char *tempfile;
  BOOLEAN persistent_cookies_flag;
  
  if (no_option_save == '\0') {
    result = (char *)calloc(0x100,1);
    if (result == (char *)0x0) {
      result = (char *)gettext("Not enough memory!");
      HTAlwaysAlert((char *)0x0,result);
    }
    else {
      fp = LYOpenTemp(result,".rc","w");
      if (fp == (FILE *)0x0) {
        if (result != (char *)0x0) {
          free(result);
        }
        result = (char *)gettext("Can\'t open temporary file!");
        HTAlwaysAlert((char *)0x0,result);
      }
      else {
        iVar2 = save_rc(fp);
        BVar1 = persistent_cookies;
        if (iVar2 == 0) {
          Msg = (char *)gettext("Unable to save Options!");
          HTAlwaysAlert((char *)0x0,Msg);
          LYRemoveTemp(result);
          if (result != (char *)0x0) {
            free(result);
          }
        }
        else {
          LYCookieFile_flag = (char *)0x0;
          LYCookieSaveFile_flag = (char *)0x0;
          if (persistent_cookies != '\0') {
            HTSACopy(&LYCookieFile_flag,LYCookieFile);
            HTSACopy(&LYCookieSaveFile_flag,LYCookieSaveFile);
          }
          html_src_on_lynxcfg_reload();
          free_lynx_cfg();
          source_cache_file_error = '\0';
          read_cfg(lynx_cfg_file,"main program",1,(FILE *)0x0);
          fp = (FILE *)fopen64(result,"r");
          read_rc(fp);
          LYRemoveTemp(result);
          if (result != (char *)0x0) {
            free(result);
          }
          LYSetDisplayLines();
          if (persistent_cookies != BVar1) {
            persistent_cookies = BVar1;
            result = (char *)gettext(
                                    "persistent cookies state will be changed in next session only."
                                    );
            HTAlert(result);
          }
          if (persistent_cookies != '\0') {
            iVar2 = strcmp(LYCookieFile,LYCookieFile_flag);
            if (iVar2 != 0) {
              HTSACopy(&LYCookieFile,LYCookieFile_flag);
              if (WWW_TraceFlag != '\0') {
                fp = TraceFP();
                fprintf((FILE *)fp,"cookie file can be changed in next session only, restored.\n");
              }
            }
            iVar2 = strcmp(LYCookieSaveFile,LYCookieSaveFile_flag);
            if (iVar2 != 0) {
              HTSACopy(&LYCookieSaveFile,LYCookieSaveFile_flag);
              if (WWW_TraceFlag != '\0') {
                fp = TraceFP();
                fprintf((FILE *)fp,
                        "cookie save file can be changed in next session only, restored.\n");
              }
            }
            if (LYCookieFile_flag != (char *)0x0) {
              free(LYCookieFile_flag);
              LYCookieFile_flag = (char *)0x0;
            }
            if (LYCookieSaveFile_flag != (char *)0x0) {
              free(LYCookieSaveFile_flag);
            }
          }
        }
      }
    }
  }
  return;
}



void disable_pausing(void)

{
  MessageSecs = 0;
  AlertSecs = 0;
  InfoSecs = 0;
  ReplaySecs = 0;
  DebugSecs = 0;
  return;
}



void force_dump_mode(void)

{
  dump_output_immediately = '\x01';
  disable_pausing();
  LYcols = 0x50;
  return;
}



int parse_authentication(char *next_arg,char **result)

{
  size_t __n;
  char *pcVar1;
  char *cp;
  char *auth_info;
  
  auth_info = (char *)0x0;
  if (next_arg != (char *)0x0) {
    HTSACopy(&auth_info,next_arg);
    __n = strlen(next_arg);
    memset(next_arg,0x20,__n);
  }
  if (auth_info != (char *)0x0) {
    pcVar1 = strchr(auth_info,0x3a);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '\0';
      HTUnEscape(pcVar1 + 1);
      HTSACopy(result + 1,pcVar1 + 1);
    }
    if (*auth_info != '\0') {
      HTUnEscape(auth_info);
      HTSACopy(result,auth_info);
    }
    if (auth_info != (char *)0x0) {
      free(auth_info);
    }
  }
  return 0;
}



int anonymous_fun(char *next_arg)

{
  if ((LYValidate == '\0') && (LYRestricted == '\0')) {
    parse_restrictions("default");
  }
  LYRestricted = '\x01';
  return 0;
}



int assume_charset_fun(char *next_arg)

{
  UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
  HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return 0;
}



int assume_local_charset_fun(char *next_arg)

{
  UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
  return 0;
}



int assume_unrec_charset_fun(char *next_arg)

{
  UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(next_arg);
  return 0;
}



int auth_fun(char *next_arg)

{
  parse_authentication(next_arg,authentication_info);
  return 0;
}



int base_fun(char *next_arg)

{
  HTAtom *pHVar1;
  
  LYPrependBase = '\x01';
  pHVar1 = HTAtom_for("www/dump");
  if (pHVar1 == (HTAtom *)HTOutputFormat) {
    HTOutputFormat = (HTFormat)HTAtom_for("www/download");
  }
  return 0;
}



int cache_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTCacheSize = atoi(next_arg);
  }
  if (HTCacheSize < 2) {
    HTCacheSize = 2;
  }
  return 0;
}



int child_fun(char *next_arg)

{
  child_lynx = '\x01';
  no_disk_save = '\x01';
  no_mail = '\x01';
  return 0;
}



int child_relaxed_fun(char *next_arg)

{
  child_lynx = '\x01';
  return 0;
}



int crawl_fun(char *next_arg)

{
  LYcols = 0x50;
  crawl = '\x01';
  return 0;
}



int display_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    LYsetXDisplay(next_arg);
  }
  return 0;
}



int display_charset_fun(char *next_arg)

{
  int iVar1;
  char *__format;
  int i;
  
  iVar1 = UCGetLYhndl_byMIME(next_arg);
  if (iVar1 < 0) {
    __format = (char *)gettext("Lynx: ignoring unrecognized charset=%s\n");
    fprintf(stderr,__format,next_arg);
    iVar1 = current_char_set;
  }
  current_char_set = iVar1;
  return 0;
}



int dump_output_fun(char *next_arg)

{
  force_dump_mode();
  return 0;
}



int editor_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTSACopy(&editor,next_arg);
  }
  system_editor = '\x01';
  return 0;
}



int error_file_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    http_error_file = next_arg;
  }
  return 0;
}



int exec_fun(char *next_arg)

{
  local_exec = '\x01';
  return 0;
}



int get_data_fun(char *next_arg)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  char *buf;
  char **get_data;
  
  buf = (char *)0x0;
  force_dump_mode();
  HTSACopy(&form_get_data,"?");
  while( true ) {
    BVar2 = GetStdin(&buf,'\x01');
    pcVar1 = form_get_data;
    if (BVar2 == '\0') break;
    HTSACat(&form_get_data,buf);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"get_data:%s\n",pcVar1);
  }
  pcVar1 = form_get_data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"get_data:%s\n",pcVar1);
  }
  return 0;
}



int help_fun(char *next_arg)

{
  print_help_and_exit(0);
  return 0;
}



int hiddenlinks_fun(char *next_arg)

{
  Config_Enum table [4];
  BOOLEAN BVar1;
  
  if (next_arg == (char *)0x0) {
    LYHiddenLinks = 0;
  }
  else {
    BVar1 = LYgetEnum((Config_Enum *)&ram0x08194ce0,next_arg,&LYHiddenLinks);
    if (BVar1 == '\0') {
      print_help_and_exit(-1);
    }
  }
  return 0;
}



int homepage_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTSACopy(&homepage,next_arg);
    LYEscapeStartfile(&homepage);
  }
  return 0;
}



int mime_header_fun(char *next_arg)

{
  HTAtom *local_8;
  
  keep_mime_headers = '\x01';
  force_dump_mode();
  if (LYPrependBase == '\0') {
    local_8 = HTAtom_for("www/dump");
  }
  else {
    local_8 = HTAtom_for("www/download");
  }
  LYcols = 0x3f6;
  HTOutputFormat = (HTFormat)local_8;
  return 0;
}



int newschunksize_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTNewsChunkSize = atoi(next_arg);
    if (HTNewsMaxChunk < HTNewsChunkSize) {
      HTNewsMaxChunk = HTNewsChunkSize;
    }
  }
  return 0;
}



int newsmaxchunk_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTNewsMaxChunk = atoi(next_arg);
    if (HTNewsMaxChunk < HTNewsChunkSize) {
      HTNewsChunkSize = HTNewsMaxChunk;
    }
  }
  return 0;
}



int nobold_fun(char *next_arg)

{
  LYnoVideo(1);
  return 0;
}



int nobrowse_fun(char *next_arg)

{
  HTDirAccess = 0;
  return 0;
}



int nocolor_fun(char *next_arg)

{
  LYShowColor = 0;
  return 0;
}



int nopause_fun(char *next_arg)

{
  disable_pausing();
  return 0;
}



int nomore_fun(char *next_arg)

{
  nomore = '\x01';
  return 0;
}



int noreverse_fun(char *next_arg)

{
  LYnoVideo(2);
  return 0;
}



int nounderline_fun(char *next_arg)

{
  LYnoVideo(4);
  return 0;
}



int pauth_fun(char *next_arg)

{
  parse_authentication(next_arg,proxyauth_info);
  return 0;
}



int post_data_fun(char *next_arg)

{
  BOOLEAN BVar1;
  char *buf;
  char **post_data;
  
  buf = (char *)0x0;
  force_dump_mode();
  while( true ) {
    BVar1 = GetStdin(&buf,'\x01');
    if (BVar1 == '\0') break;
    HTSACat(&form_post_data,buf);
  }
  return 0;
}



char * show_restriction(char *name)

{
  int iVar1;
  char *value;
  
  iVar1 = find_restriction(name,-1);
  if (iVar1 == 0) {
    value = "off";
  }
  else {
    if (iVar1 == 1) {
      value = "on";
    }
    else {
      value = "?";
    }
  }
  return value;
}



int restrictions_fun(char *next_arg)

{
  bool bVar1;
  bool bVar2;
  anon_struct_0 table [38];
  char *Usage [4];
  char *__s1;
  int iVar3;
  char *__s;
  size_t sVar4;
  size_t sVar5;
  undefined *local_2c;
  char *value;
  char *name;
  uint column;
  uint k;
  uint j;
  BOOLEAN first;
  BOOLEAN found;
  
  column = 0;
  if ((next_arg == (char *)0x0) || (*next_arg == '\0')) {
    j = 0;
    while (j < 4) {
      puts(((char **)&ram0x08194d00)[j]);
      j = j + 1;
    }
    j = 0;
    while (j < 0x26) {
      iVar3 = strcmp(*(char **)(j * 8 + 0x8150a00),"all");
      if (iVar3 == 0) {
LAB_0807af12:
        value = (char *)0x0;
      }
      else {
        iVar3 = strcmp(*(char **)(j * 8 + 0x8150a00),"default");
        if (iVar3 == 0) goto LAB_0807af12;
        value = show_restriction(*(char **)(j * 8 + 0x8150a00));
      }
      print_help_strings(*(char **)(j * 8 + 0x8150a00),*(char **)(j * 8 + 0x8150a04),value,'\0');
      j = j + 1;
    }
    bVar2 = true;
    j = 0;
    while( true ) {
      bVar1 = false;
      __s1 = index_to_restriction(j);
      if (__s1 == (char *)0x0) break;
      k = 0;
      while (k < 0x26) {
        iVar3 = strcmp(__s1,*(char **)(k * 8 + 0x8150a00));
        if (iVar3 == 0) {
          bVar1 = true;
        }
        k = k + 1;
      }
      if (!bVar1) {
        if (bVar2) {
          puts("Other restrictions (see the user\'s guide):");
        }
        __s = show_restriction(((anon_struct_0 *)&ram0x08150a00)[j].name);
        if (column == 0) {
          local_2c = &DAT_08150b5e;
        }
        else {
          local_2c = &DAT_08150b5b;
        }
        printf("%s%s (%s)",local_2c,__s1,__s);
        sVar4 = strlen(__s1);
        sVar5 = strlen(__s);
        column = sVar4 + sVar5 + column + 5;
        if (0x32 < column) {
          column = 0;
          putchar(10);
        }
        bVar2 = false;
      }
      j = j + 1;
    }
    if (column != 0) {
      putchar(10);
    }
    exit_immediately(0);
  }
  else {
    if (*next_arg == '?') {
      print_restrictions_to_fd(stdout);
      exit_immediately(0);
    }
    else {
      parse_restrictions(next_arg);
    }
  }
  return 0;
}



int selective_fun(char *next_arg)

{
  HTDirAccess = 1;
  return 0;
}



int source_fun(char *next_arg)

{
  HTAtom *local_8;
  
  force_dump_mode();
  if (LYPrependBase == '\0') {
    local_8 = HTAtom_for("www/dump");
  }
  else {
    local_8 = HTAtom_for("www/download");
  }
  LYcols = 0x3f6;
  HTOutputFormat = (HTFormat)local_8;
  return 0;
}



int traversal_fun(char *next_arg)

{
  LYcols = 0x3f6;
  traversal = '\x01';
  return 0;
}



int version_fun(char *next_arg)

{
  char *__format;
  char *fmt;
  undefined4 uVar1;
  char *result;
  
  result = (char *)0x0;
  SetLocale();
  __format = LYVersionDate();
  fmt = (char *)gettext("%s Version %s (%s)");
  HTSprintf0(&result,fmt,&DAT_0814f827,"2.8.7dev.11",__format);
  HTSACat(&result,"\n");
  HTSprintf(&result,"libwww-FM %s",HTLibraryVersion);
  uVar1 = curses_version();
  HTSprintf(&result,", %s",uVar1);
  HTSprintf(&result,"(wide)");
  puts(result);
  free(result);
  __format = (char *)gettext("Built on %s %s %s\n");
  printf(__format,"linux-gnu","May 21 2010","12:03:35");
  puts("");
  __format = (char *)gettext("Copyrights held by the Lynx Developers Group,");
  puts(__format);
  __format = (char *)gettext("the University of Kansas, CERN, and other contributors.");
  puts(__format);
  __format = (char *)gettext("Distributed under the GNU General Public License (Version 2).");
  puts(__format);
  __format = (char *)gettext("See http://lynx.isc.org/ and the online help for more information.");
  puts(__format);
  puts("");
  exit_immediately(0);
  return 0;
}



int width_fun(char *next_arg)

{
  int local_18;
  int w;
  
  if (next_arg != (char *)0x0) {
    local_18 = atoi(next_arg);
    if (0 < local_18) {
      if (0x3f6 < local_18) {
        local_18 = 0x3f6;
      }
      dump_output_width = local_18;
    }
  }
  return 0;
}



void print_help_strings(char *name,char *help,char *value,BOOLEAN option)

{
  size_t sVar1;
  char *pcVar2;
  bool bVar3;
  undefined *local_20;
  int field_width;
  int first;
  int c;
  int pad;
  
  sVar1 = strlen(name);
  first = (-sVar1 - (int)option) + 0x12;
  if (option == '\0') {
    local_20 = &DAT_0814f6b1;
  }
  else {
    local_20 = &DAT_0814f8e3;
  }
  fprintf(stdout,"  %s%s",local_20,name);
  if (*help != '=') {
    pad = (-sVar1 - (int)option) + 0x11;
    while (0 < pad) {
      fputc(0x20,stdout);
      pad = pad + -1;
    }
    fputc(0x20,stdout);
    first = 0;
  }
  pcVar2 = strchr(help,10);
  if (pcVar2 == (char *)0x0) {
    fputs(help,stdout);
  }
  else {
    while (c = (int)*help, c != 0) {
      if (c == 10) {
        first = first + -1;
        if (first < 0) {
          pad = 0x14;
        }
        else {
          c = 0x20;
          pad = first;
        }
        fputc(c,stdout);
        while (bVar3 = pad != 0, pad = pad + -1, bVar3) {
          fputc(0x20,stdout);
        }
      }
      else {
        fputc(c,stdout);
      }
      help = help + 1;
      first = first + -1;
    }
  }
  if (value != (char *)0x0) {
    printf(" (%s)",value);
  }
  fputc(10,stdout);
  return;
}



void print_help_and_exit(int exit_status)

{
  int iVar1;
  char *__format;
  char **ppcVar2;
  uint uVar3;
  int in_GS_OFFSET;
  char *local_420;
  char *local_41c;
  ParseUnion *q;
  char *value;
  Config_Type *p;
  char temp [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (pgm == (char *)0x0) {
    pgm = "lynx";
  }
  __format = (char *)gettext("USAGE: %s [options] [file]\n");
  fprintf(stdout,__format);
  __format = (char *)gettext("Options are:\n");
  fprintf(stdout,__format);
  print_help_strings("","receive options and arguments from stdin",(char *)0x0,'\x01');
  p = Arg_Table;
  do {
    if (p->name == (char *)0x0) {
      exit_immediately(exit_status);
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    value = temp;
    ppcVar2 = (char **)&p->value;
    uVar3 = p->type & 0xff0;
    if (uVar3 == 0x30) {
      if (**ppcVar2 == '\0') {
        local_41c = "on";
      }
      else {
        local_41c = "off";
      }
      strcpy(temp,local_41c);
    }
    else {
      if (uVar3 < 0x31) {
        if ((uVar3 == 0x10) || (uVar3 == 0x20)) {
          if (**ppcVar2 == '\0') {
            local_420 = "off";
          }
          else {
            local_420 = "on";
          }
          strcpy(temp,local_420);
        }
        else {
LAB_0807b701:
          value = (char *)0x0;
        }
      }
      else {
        if (uVar3 == 0x70) {
          value = *(char **)*ppcVar2;
          if ((value != (char *)0x0) && (*value == '\0')) {
            value = (char *)0x0;
          }
        }
        else {
          if (uVar3 == 0x80) {
            sprintf(temp,"%.3f");
          }
          else {
            if (uVar3 != 0x60) goto LAB_0807b701;
            sprintf(temp,"%d");
          }
        }
      }
    }
    print_help_strings(p->name,p->help_string,value,'\x01');
    p = p + 1;
  } while( true );
}



int arg_eqs_parse(char *a,char *b,char **c)

{
  char *pcVar1;
  ushort **ppuVar2;
  int result;
  
  result = -1;
  *c = (char *)0x0;
  do {
    if (-1 < result) {
      return result;
    }
    if (((*a != *b) || (*a == '\0')) || (*b == '\0')) {
      if (*a == '\0') {
        switch(*b) {
        case '\0':
          result = 1;
          break;
        default:
          result = 0;
          break;
        case '\t':
        case ' ':
          pcVar1 = LYSkipBlanks(b);
          *c = pcVar1;
          result = 1;
          break;
        case '+':
switchD_0807b7e7_caseD_2b:
          *c = b;
          result = 1;
          break;
        case '-':
          ppuVar2 = __ctype_b_loc();
          if (((*ppuVar2)[(byte)b[1]] & 0x400) == 0) goto switchD_0807b7e7_caseD_2b;
          result = 0;
          break;
        case ':':
        case '=':
          *c = b + 1;
          result = 1;
        }
      }
      else {
        if ((*a != '_') || (*b != '-')) {
          result = 0;
        }
      }
    }
    a = a + 1;
    b = b + 1;
  } while( true );
}



BOOLEAN parse_arg(char **argv,uint mask,int *countp)

{
  char *__s1;
  int *piVar1;
  char *pcVar2;
  BOOLEAN no_options_further;
  FILE *__stream;
  int iVar3;
  int **ppiVar4;
  long lVar5;
  char *__format;
  uint uVar6;
  int local_48;
  bool local_41;
  char *local_40;
  float ival;
  char *temp_ptr;
  char *next_arg;
  ParseFunc *fun;
  ParseUnion *q;
  char *arg_name;
  Config_Type *p;
  
  __s1 = *argv;
  if (WWW_TraceFlag != '\0') {
    if (countp == (int *)0x0) {
      local_48 = -1;
    }
    else {
      local_48 = *countp;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"parse_arg(arg_name=%s, mask=%u, count=%d)\n",__s1,mask,local_48);
  }
  if ((((uint)(countp == (int *)0x0) == mask) &&
      (no_options_further = '\0', nonoption != (char *)0x0)) && (nonoption != (char *)0x0)) {
    free(nonoption);
    nonoption = (char *)0x0;
  }
  if ((*__s1 == '-') && (no_options_further != '\x01')) {
    iVar3 = strcmp(__s1,"--");
    if (iVar3 == 0) {
      local_41 = true;
    }
    else {
      arg_name = __s1 + 1;
      if (*arg_name == '\0') {
        local_41 = true;
      }
      else {
        if (*arg_name == '-') {
          arg_name = __s1 + 2;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"parse_arg lookup(%s)\n",arg_name);
        }
        p = Arg_Table;
        while (p->name != (char *)0x0) {
          ppiVar4 = (int **)&p->value;
          next_arg = (char *)0x0;
          temp_ptr = (char *)0x0;
          if ((*p->name == *arg_name) &&
             (iVar3 = arg_eqs_parse(p->name,arg_name,&next_arg), iVar3 != 0)) {
            if ((p->type & 0x1000U) != 0) {
              if (((next_arg == (char *)0x0) && (next_arg = argv[1], countp != (int *)0x0)) &&
                 (next_arg != (char *)0x0)) {
                *countp = *countp + 1;
              }
              if (WWW_TraceFlag != '\0') {
                if (next_arg == (char *)0x0) {
                  local_40 = "(null)";
                }
                else {
                  local_40 = next_arg;
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,"...arg:%s\n",local_40);
              }
            }
            if ((p->type & mask) == 0) {
              if (WWW_TraceFlag != '\0') {
                uVar6 = p->type;
                __stream = TraceFP();
                fprintf((FILE *)__stream,"...skip (mask %u/%d)\n",mask,uVar6 & 7);
              }
              return '\0';
            }
            uVar6 = p->type & 0xff0;
            if (uVar6 == 0x40) {
              if (*ppiVar4 != (int *)0x0) {
                (*(code *)*ppiVar4)(next_arg);
              }
            }
            else {
              if (uVar6 < 0x41) {
                if ((((uVar6 == 0x20) || (uVar6 == 0x30)) || (uVar6 == 0x10)) &&
                   (*ppiVar4 != (int *)0x0)) {
                  if (next_arg == (char *)0x0) {
                    uVar6 = p->type & 0xff0;
                    if (uVar6 == 0x20) {
                      *(undefined *)*ppiVar4 = 1;
                    }
                    else {
                      if (uVar6 == 0x30) {
                        *(undefined *)*ppiVar4 = 0;
                      }
                      else {
                        if (uVar6 == 0x10) {
                          *(bool *)*ppiVar4 = *(char *)*ppiVar4 == '\0';
                        }
                      }
                    }
                  }
                  else {
                    if ((((*next_arg == '1') || (*next_arg == '+')) ||
                        (iVar3 = strcasecomp(next_arg,"on"), iVar3 == 0)) ||
                       (iVar3 = strcasecomp(next_arg,"true"), iVar3 == 0)) {
                      *(undefined *)*ppiVar4 = 1;
                    }
                    else {
                      if (((*next_arg == '0') || (*next_arg == '-')) ||
                         ((iVar3 = strcasecomp(next_arg,"off"), iVar3 == 0 ||
                          (iVar3 = strcasecomp(next_arg,"false"), iVar3 == 0)))) {
                        *(undefined *)*ppiVar4 = 0;
                      }
                    }
                  }
                }
              }
              else {
                if (uVar6 == 0x60) {
                  if ((*ppiVar4 != (int *)0x0) && (next_arg != (char *)0x0)) {
                    piVar1 = *ppiVar4;
                    lVar5 = strtol(next_arg,&temp_ptr,0);
                    *piVar1 = lVar5;
                  }
                }
                else {
                  if (uVar6 < 0x61) {
                    if (((uVar6 == 0x50) && (*ppiVar4 != (int *)0x0)) && (next_arg != (char *)0x0))
                    {
                      HTSACopy((char **)*ppiVar4,next_arg);
                    }
                  }
                  else {
                    if (uVar6 == 0x70) {
                      if ((*ppiVar4 != (int *)0x0) && (next_arg != (char *)0x0)) {
                        *(char **)*ppiVar4 = next_arg;
                      }
                    }
                    else {
                      if ((((uVar6 == 0x80) && (*ppiVar4 != (int *)0x0)) &&
                          (next_arg != (char *)0x0)) &&
                         (iVar3 = sscanf(next_arg,"%f",&ival), iVar3 == 1)) {
                        **ppiVar4 = (int)ROUND(ival * 1000.00000000);
                      }
                    }
                  }
                }
              }
            }
            Old_DTD = (int)DTD_recovery;
            return '\x01';
          }
          p = p + 1;
        }
        if (pgm == (char *)0x0) {
          pgm = "LYNX";
        }
        pcVar2 = pgm;
        __s1 = *argv;
        __format = (char *)gettext("%s: Invalid Option: %s\n");
        fprintf(stderr,__format,pcVar2,__s1);
        print_help_and_exit(-1);
        local_41 = false;
      }
    }
  }
  else {
    if (mask == 4) {
      if (nonoption != (char *)0x0) {
        LYEnsureAbsoluteURL(&nonoption,"NONOPTION",0);
        HTAddGotoURL(nonoption);
        if (nonoption != (char *)0x0) {
          free(nonoption);
          nonoption = (char *)0x0;
        }
      }
      HTSACopy(&nonoption,__s1);
    }
    HTSACopy(&startfile,__s1);
    LYEscapeStartfile(&startfile);
    __s1 = startfile;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"parse_arg startfile:%s\n",__s1);
    }
    local_41 = countp != (int *)0x0;
  }
  return (BOOLEAN)local_41;
}



void FatalProblem(int sig)

{
  undefined4 uVar1;
  
  signal(1,(__sighandler_t)0x1);
  signal(0xf,(__sighandler_t)0x1);
  signal(2,(__sighandler_t)0x1);
  signal(0xb,(__sighandler_t)0x1);
  signal(4,(__sighandler_t)0x1);
  fflush(stderr);
  fflush(stdout);
  if ((LYOutOfMemory != '\0') && (LYCursesON != '\0')) {
    LYSleepAlert();
  }
  cleanup_sig(0);
  signal(0xb,(__sighandler_t)0x0);
  signal(4,(__sighandler_t)0x0);
  if (LYOutOfMemory == '\0') {
    fprintf(stderr,"\r\nA Fatal error has occurred in %s Ver. %s\r\n",&DAT_0814f827,"2.8.7dev.11");
    fwrite(
           "\r\nPlease notify your system administrator to confirm a bug, and\r\nif confirmed, to notify the lynx-dev list.  Bug reports should\r\nhave concise descriptions of the command and/or URL which causes\r\nthe problem, the operating system name with version number, the\r\nTCPIP implementation, and any other relevant information.\r\n"
           ,1,0x13f,stderr);
    if ((sig != 0) || (LYNoCore == '\0')) {
      fwrite("\r\nDo NOT mail the core file if one was generated.\r\n",1,0x33,stderr);
    }
    if (sig != 0) {
      fprintf(stderr,"\r\nLynx now exiting with signal:  %d\r\n\r\n",sig);
    }
    if (LYNoCore != '\0') {
      exit_immediately(1);
    }
                    // WARNING: Subroutine does not return
    abort();
  }
  LYOutOfMemory = '\0';
  uVar1 = gettext("Memory exhausted!  Program aborted!");
  printf("\r\n%s\r\n\r\n",uVar1);
  fflush(stdout);
  exit_immediately(1);
  return;
}



int sametext(char *een,char *twee)

{
  int iVar1;
  uint local_8;
  
  if ((een == (char *)0x0) || (twee == (char *)0x0)) {
    local_8 = 1;
  }
  else {
    iVar1 = strcmp(een,twee);
    local_8 = (uint)(iVar1 == 0);
  }
  return local_8;
}



void TracelogOpenFailed(void)

{
  char *Msg;
  undefined4 uVar1;
  
  WWW_TraceFlag = '\0';
  if (LYCursesON == '\0') {
    uVar1 = gettext(0x815315c);
    fprintf(stderr,"%s\n",uVar1);
    exit_immediately(1);
  }
  else {
    Msg = (char *)gettext(0x815315c);
    HTUserMsg(Msg);
  }
  return;
}



BOOLEAN LYReopenTracelog(BOOLEAN *trace_flag_ptr)

{
  FILE *__stream;
  BOOLEAN local_5;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nTurning off TRACE for fetch of log.\n");
  }
  LYCloseTracelog();
  LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath);
  if (LYTraceLogFP == (FILE *)0x0) {
    TracelogOpenFailed();
    local_5 = '\0';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      WWW_TraceFlag = '\0';
      *trace_flag_ptr = '\x01';
    }
    local_5 = '\x01';
  }
  return local_5;
}



void turn_trace_back_on(BOOLEAN *trace_flag_ptr)

{
  FILE *__s;
  
  if (*trace_flag_ptr == '\x01') {
    WWW_TraceFlag = '\x01';
    *trace_flag_ptr = '\0';
    __s = TraceFP();
    fwrite("Turning TRACE back on.\n\n",1,0x18,(FILE *)__s);
  }
  return;
}



FILE * TraceFP(void)

{
  FILE *local_8;
  
  if (LYTraceLogFP == (FILE *)0x0) {
    local_8 = stderr;
  }
  else {
    local_8 = LYTraceLogFP;
  }
  return local_8;
}



BOOLEAN LYOpenTraceLog(void)

{
  undefined4 local_14;
  FILE *__stream;
  char *local_10;
  
  if (((WWW_TraceFlag != '\0') && (LYUseTraceLog != '\0')) && (LYTraceLogFP == (FILE *)0x0)) {
    LYTraceLogFP = LYNewTxtFile(LYTraceLogPath);
    if (LYTraceLogFP == (FILE *)0x0) {
      TracelogOpenFailed();
      return '\0';
    }
    fflush(stdout);
    fflush(stderr);
    local_14 = gettext("Lynx Trace Log");
    __stream = TraceFP();
    local_10 = "2.8.7dev.11";
    fprintf((FILE *)__stream,"\t\t%s (%s)\n\n",local_14,"2.8.7dev.11");
    if (LYValidate == '\0') {
      if (LYRestricted == '\0') {
        if ((had_restrictions_all == '\0') || (had_restrictions_default == '\0')) {
          if (had_restrictions_default == '\0') {
            if ((had_restrictions_all != '\0') && (WWW_TraceFlag != '\0')) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"\"all\" restrictions are set.\n",local_14,local_10);
            }
          }
          else {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"Restriction \"default\" was given.\n",local_14,local_10);
            }
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Restrictions \"all\" and \"default\" were given.\n",local_14,
                    local_10);
          }
        }
      }
      else {
        if (had_restrictions_all == '\0') {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Anonymous restrictions are set.\n",local_14,local_10);
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Anonymous restrictions set, restriction \"all\" was given.\n",
                    local_14,local_10);
          }
        }
      }
    }
    else {
      if ((LYRestricted == '\0') || (had_restrictions_default == '\0')) {
        if (had_restrictions_default == '\0') {
          if (LYRestricted == '\0') {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"Validate restrictions are set.\n",local_14,local_10);
            }
          }
          else {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,
                      "Validate restrictions set, additional anonymous restrictions ignored.\n",
                      local_14,local_10);
            }
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,
                    "Validate restrictions set, restriction \"default\" was given.\n",local_14,
                    local_10);
          }
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Validate and some anonymous restrictions are set.\n",local_14,
                  local_10);
        }
      }
    }
  }
  return '\x01';
}



void LYCloseTracelog(void)

{
  if (LYTraceLogFP != (FILE *)0x0) {
    fflush(stdout);
    fflush(stderr);
    fclose((FILE *)LYTraceLogFP);
    LYTraceLogFP = (FILE *)0x0;
  }
  return;
}



void handle_LYK_TRACE_TOGGLE(void)

{
  BOOLEAN BVar1;
  char *local_8;
  
  WWW_TraceFlag = WWW_TraceFlag == '\0';
  BVar1 = LYOpenTraceLog();
  if (BVar1 != '\0') {
    if (WWW_TraceFlag == '\0') {
      local_8 = (char *)gettext("Trace OFF!");
    }
    else {
      local_8 = (char *)gettext("Trace ON!");
    }
    HTUserMsg(local_8);
  }
  return;
}



void LYSetNewline(int value)

{
  Newline = value;
  return;
}



int LYGetNewline(void)

{
  return Newline;
}



void LYChgNewline(int adjust)

{
  Newline = Newline + adjust;
  return;
}



BOOLEAN reparse_document(void)

{
  BOOLEAN BVar1;
  BOOLEAN result;
  
  from_source_cache = '\x01';
  BVar1 = HTreparse_document();
  from_source_cache = BVar1 != '\0';
  return BVar1;
}



BOOLEAN reparse_or_reload(int *cmd)

{
  BOOLEAN BVar1;
  
  BVar1 = reparse_document();
  if (BVar1 == '\0') {
    *cmd = 0xc;
  }
  return (BOOLEAN)(BVar1 == '\0');
}



void set_address(DocInfo *doc,char *address)

{
  HTSACopy(&doc->address,address);
  return;
}



void copy_address(DocInfo *dst,DocInfo *src)

{
  HTSACopy(&dst->address,src->address);
  return;
}



void free_address(DocInfo *doc)

{
  if (doc->address != (char *)0x0) {
    free(doc->address);
    doc->address = (char *)0x0;
  }
  return;
}



void move_address(DocInfo *dst,DocInfo *src)

{
  copy_address(dst,src);
  free_address(src);
  return;
}



BOOLEAN LYMainLoop_pageDisplay(int line_num)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int prev_newline;
  char *pound;
  
  iVar1 = Newline;
  Newline = line_num;
  if (((((from_source_cache == '\0') && (display_partial != '\0')) && (newdoc.line == 1)) &&
      ((line_num == 1 && (iVar1 == 1)))) &&
     ((pcVar3 = strchr(newdoc.address,0x23), pcVar3 != (char *)0x0 &&
      ((*pcVar3 != '\0' && (pcVar3[1] != '\0')))))) {
    BVar2 = HTFindPoundSelector(pcVar3 + 1);
    if (BVar2 == '\0') {
      Newline = iVar1;
      return '\0';
    }
    Newline = www_search_result;
  }
  HText_pageDisplay(Newline,prev_target);
  return '\x01';
}



BOOLEAN set_curdoc_link(int nextlink)

{
  BOOLEAN result;
  
  result = '\0';
  if (((curdoc.link != nextlink) && (-1 < nextlink)) && (nextlink < nlinks)) {
    if ((-1 < curdoc.link) && (curdoc.link < nlinks)) {
      LYhighlight(0,curdoc.link,prev_target);
      result = '\x01';
    }
    curdoc.link = nextlink;
  }
  return result;
}



void goto_line(int nextline)

{
  int iVar1;
  int iVar2;
  FILE *__stream;
  int old_link;
  int n;
  
  iVar1 = newdoc.link;
  newdoc.link = 0;
  n = 0;
  while( true ) {
    if (nlinks <= n) {
      newdoc.link = 0;
      return;
    }
    if (links[n].anchor_line_num + 1 == nextline) break;
    n = n + 1;
  }
  if (WWW_TraceFlag != '\0') {
    iVar2 = HText_getTopOfScreen();
    __stream = TraceFP();
    fprintf((FILE *)__stream,"top_of_screen %d\n",iVar2 + 1);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"goto_line(%d) -> link %d -> %d\n",nextline,iVar1,n);
  }
  newdoc.link = n;
  return;
}



void set_curdoc_link_by_mouse(int nextlink)

{
  BOOLEAN BVar1;
  
  BVar1 = set_curdoc_link(nextlink);
  if (BVar1 != '\0') {
    LYhighlight(1,nextlink,prev_target);
    LYmsec_delay(0x14);
  }
  return;
}



int do_change_link(void)

{
  int nextlink;
  char *fmt;
  char *msgtmp;
  int mouse_tmp;
  
  nextlink = get_mouse_link();
  if (nextlink != -1) {
    if ((nextlink < 0) || (nlinks <= nextlink)) {
      msgtmp = (char *)0x0;
      fmt = (char *)gettext("Internal error: Invalid mouse link %d!");
      HTSprintf0(&msgtmp,fmt,nextlink);
      HTAlert(msgtmp);
      if (msgtmp != (char *)0x0) {
        free(msgtmp);
      }
      return -1;
    }
    set_curdoc_link_by_mouse(nextlink);
  }
  return 0;
}



void do_check_goto_URL(char *user_input_buffer,char **old_user_input,BOOLEAN *force_load)

{
  bool bVar1;
  anon_struct_0 table [29];
  BOOLEAN BVar2;
  size_t __n;
  char *Msg2;
  int iVar3;
  char *Arg;
  uint n;
  BOOLEAN found;
  
  bVar1 = false;
  if (*user_input_buffer == '#') {
    if ((user_input_buffer[1] != '\0') &&
       (BVar2 = HTFindPoundSelector(user_input_buffer + 1), BVar2 != '\0')) {
      HTAddGotoURL(user_input_buffer);
      trimPoundSelector(curdoc.address);
      HTSACat(&curdoc.address,user_input_buffer);
    }
  }
  else {
    HTSACopy(old_user_input,user_input_buffer);
    LYEnsureAbsoluteURL(old_user_input,"",1);
    sprintf(user_input_buffer,"%.*s",0x3ff,*old_user_input);
    if (*old_user_input != (char *)0x0) {
      free(*old_user_input);
      *old_user_input = (char *)0x0;
    }
    n = 0;
    while (n < 0x1d) {
      if (**(char **)(n * 8 + 0x81955a4) != '\0') {
        __n = strlen(((anon_struct_0 *)&ram0x081955a0)[n].name);
        iVar3 = strncmp(user_input_buffer,*(char **)(n * 8 + 0x81955a0),__n);
        if (iVar3 == 0) {
          bVar1 = true;
          Arg = *(char **)(n * 8 + 0x81955a0);
          Msg2 = (char *)gettext("You are not allowed to goto \"%s\" URLs");
          HTUserMsg2(Msg2,Arg);
          break;
        }
      }
      n = n + 1;
    }
    if (!bVar1) {
      if (((LYValidate != '\0') && (iVar3 = strncasecomp(user_input_buffer,"http:",5), iVar3 != 0))
         && (iVar3 = strncasecomp(user_input_buffer,"https:",6), iVar3 != 0)) {
        Arg = (char *)gettext("Goto a non-http URL is disallowed!");
        HTUserMsg(Arg);
        return;
      }
      set_address(&newdoc,user_input_buffer);
      newdoc.isHEAD = '\0';
      iVar3 = are_different(&curdoc,&newdoc);
      if (iVar3 != 0) {
        Arg = (char *)gettext("A URL specified by the user");
        HTSACopy((char **)&newdoc,Arg);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        *force_load = '\x01';
        if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
          HTuncache_current_document();
        }
      }
      LYUserSpecifiedURL = '\x01';
      HTAddGotoURL(newdoc.address);
    }
  }
  return;
}



BOOLEAN do_check_recall(int ch,char *user_input_buffer,char **old_user_input,int URLTotal,
                       int *URLNum,RecallType recall,BOOLEAN *FirstURLRecall)

{
  char *src;
  int iVar1;
  char *cp;
  BOOLEAN ret;
  
  if (*old_user_input == (char *)0x0) {
    HTSACopy(old_user_input,"");
  }
  do {
    do {
      while( true ) {
        LYTrimAllStartfile(user_input_buffer);
        if ((*user_input_buffer == '\0') &&
           ((recall == NORECALL || ((ch != 0x100 && (ch != 0x101)))))) {
          LYstrncpy(user_input_buffer,*old_user_input,0x3ff);
          if (*old_user_input != (char *)0x0) {
            free(*old_user_input);
            *old_user_input = (char *)0x0;
          }
          src = (char *)gettext("Cancelled!!!");
          HTInfoMsg(src);
          return '\0';
        }
        if ((recall != NORECALL) && (ch == 0x100)) break;
        if ((recall == NORECALL) || (ch != 0x101)) {
          return '\x01';
        }
        if (*FirstURLRecall == '\0') {
          *URLNum = *URLNum + -1;
        }
        else {
          *FirstURLRecall = '\0';
          *URLNum = URLTotal + -1;
        }
        if (*URLNum < 0) {
          *URLNum = URLTotal + -1;
        }
        src = (char *)HTList_objectAt(Goto_URLs,*URLNum);
        if (src != (char *)0x0) {
          LYstrncpy(user_input_buffer,src,0x3ff);
          if (((goto_buffer == '\0') || (**old_user_input == '\0')) ||
             (iVar1 = strcmp(*old_user_input,user_input_buffer), iVar1 != 0)) {
            if (((goto_buffer == '\0') || (URLTotal != 2)) &&
               ((goto_buffer != '\0' || (URLTotal != 1)))) {
              mustshow = '\x01';
              src = (char *)gettext("Edit a previous Goto URL: ");
              statusline(src);
            }
            else {
              mustshow = '\x01';
              src = (char *)gettext("Edit the previous Goto URL: ");
              statusline(src);
            }
          }
          else {
            mustshow = '\x01';
            src = (char *)gettext("Edit the current Goto URL: ");
            statusline(src);
          }
          ch = LYgetstr(user_input_buffer,0,0x400,recall);
          if (ch < 0) {
            LYstrncpy(user_input_buffer,*old_user_input,0x3ff);
            if (*old_user_input != (char *)0x0) {
              free(*old_user_input);
              *old_user_input = (char *)0x0;
            }
            src = (char *)gettext("Cancelled!!!");
            HTInfoMsg(src);
            return '\0';
          }
        }
      }
      if (*FirstURLRecall == '\0') {
        *URLNum = *URLNum + 1;
      }
      else {
        *FirstURLRecall = '\0';
        *URLNum = 0;
      }
      if (URLTotal <= *URLNum) {
        *URLNum = 0;
      }
      src = (char *)HTList_objectAt(Goto_URLs,*URLNum);
    } while (src == (char *)0x0);
    LYstrncpy(user_input_buffer,src,0x3ff);
    if (((goto_buffer == '\0') || (**old_user_input == '\0')) ||
       (iVar1 = strcmp(*old_user_input,user_input_buffer), iVar1 != 0)) {
      if (((goto_buffer == '\0') || (URLTotal != 2)) && ((goto_buffer != '\0' || (URLTotal != 1))))
      {
        mustshow = '\x01';
        src = (char *)gettext("Edit a previous Goto URL: ");
        statusline(src);
      }
      else {
        mustshow = '\x01';
        src = (char *)gettext("Edit the previous Goto URL: ");
        statusline(src);
      }
    }
    else {
      mustshow = '\x01';
      src = (char *)gettext("Edit the current Goto URL: ");
      statusline(src);
    }
    ch = LYgetstr(user_input_buffer,0,0x400,recall);
  } while (-1 < ch);
  LYstrncpy(user_input_buffer,*old_user_input,0x3ff);
  if (*old_user_input != (char *)0x0) {
    free(*old_user_input);
    *old_user_input = (char *)0x0;
  }
  src = (char *)gettext("Cancelled!!!");
  HTInfoMsg(src);
  return '\0';
}



void do_cleanup_after_delete(void)

{
  HTuncache_current_document();
  move_address(&newdoc,&curdoc);
  if (curdoc.link == nlinks + -1) {
    newdoc.link = curdoc.link + -1;
  }
  else {
    newdoc.link = curdoc.link;
  }
  newdoc.line = curdoc.line;
  return;
}



int find_link_near_col(int col,int delta)

{
  int iVar1;
  char *__s;
  size_t sVar2;
  bool local_25;
  char *text;
  int cx;
  int dist;
  int best;
  int cy;
  int i;
  
  i = curdoc.link;
  while( true ) {
    if (delta < 1) {
      local_25 = (bool)(~(byte)((uint)i >> 0x18) >> 7);
    }
    else {
      local_25 = i < nlinks;
    }
    if (local_25 == false) break;
    if (0 < (links[i].ly - links[curdoc.link].ly) * delta) {
      iVar1 = links[i].ly;
      best = -1;
      dist = 1000000;
      while( true ) {
        if (delta < 1) {
          if (i < 0) {
            return best;
          }
        }
        else {
          if (nlinks <= i) {
            return best;
          }
        }
        if (links[i].ly != iVar1) break;
        cx = links[i].lx;
        __s = LYGetHiliteStr(i,0);
        if (__s != (char *)0x0) {
          sVar2 = strlen(__s);
          cx = (sVar2 >> 1) + cx;
        }
        cx = cx - col;
        if (cx < 0) {
          cx = -cx;
        }
        if (cx < dist) {
          dist = cx;
          best = i;
        }
        i = i + delta;
      }
      return best;
    }
    i = i + delta;
  }
  return -1;
}



int DoTraversal(int c,BOOLEAN *crawl_ok)

{
  bool bVar1;
  BOOLEAN BVar2;
  int iVar3;
  size_t __n;
  char *pcVar4;
  FILE *__stream;
  bool bVar5;
  EVP_PKEY_CTX *local_3c;
  int local_18;
  BOOLEAN rlink_allowed;
  BOOLEAN rlink_exists;
  BOOLEAN rlink_rejected;
  
  if (((nlinks < 1) || (links[curdoc.link].type == 1)) || (links[curdoc.link].lname == (char *)0x0))
  {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
    BVar2 = lookup_reject(links[curdoc.link].lname);
    if (((BVar2 == '\0') && (traversal_host != (char *)0x0)) &&
       (links[curdoc.link].lname != (char *)0x0)) {
      iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXIMGMAP:",0xb);
      if (iVar3 == 0) {
        __n = strlen(traversal_host);
        iVar3 = strncmp(traversal_host,links[curdoc.link].lname + 0xb,__n);
        bVar5 = iVar3 == 0;
      }
      else {
        __n = strlen(traversal_host);
        iVar3 = strncmp(traversal_host,links[curdoc.link].lname,__n);
        bVar5 = iVar3 == 0;
      }
    }
    else {
      bVar5 = false;
    }
  }
  else {
    bVar5 = false;
  }
  if ((bVar1) && (bVar5)) {
    BVar2 = lookup_link(links[curdoc.link].lname);
    if (BVar2 == '\0') {
      HTSACopy(&traversal_link_to_add,links[curdoc.link].lname);
      iVar3 = strncasecomp(traversal_link_to_add,"LYNXIMGMAP:",0xb);
      if (iVar3 != 0) {
        *crawl_ok = '\x01';
      }
      c = 0x102;
    }
    else {
      if ((more_links == '\0') && ((curdoc.link < 0 || (nlinks + -1 <= curdoc.link)))) {
        local_3c = (EVP_PKEY_CTX *)curdoc.title;
        iVar3 = strcmp(curdoc.title,"Entry into main screen");
        if ((iVar3 == 0) || (nhist < 1)) {
          if (dump_output_immediately == '\0') {
            cleanup(local_3c);
            exit_immediately(1);
          }
          c = -1;
        }
        else {
          c = 0x103;
        }
      }
      else {
        c = 0x101;
      }
    }
  }
  else {
    if (bVar1) {
      add_to_reject_list(links[curdoc.link].lname);
    }
    if ((more_links == '\0') && ((curdoc.link < 0 || (nlinks + -1 <= curdoc.link)))) {
      local_3c = (EVP_PKEY_CTX *)curdoc.title;
      iVar3 = strcmp(curdoc.title,"Entry into main screen");
      if ((iVar3 == 0) || (nhist < 1)) {
        if (dump_output_immediately == '\0') {
          cleanup(local_3c);
          exit_immediately(1);
        }
        c = -1;
      }
      else {
        c = 0x103;
      }
    }
    else {
      c = 0x101;
    }
  }
  if (WWW_TraceFlag != '\0') {
    pcVar4 = LYKeycodeToString(c,'\0');
    iVar3 = nlinks;
    if (nlinks < 1) {
      local_18 = 0;
    }
    else {
      local_18 = curdoc.link;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"DoTraversal(%d:%d) -> %s\n",local_18,iVar3,pcVar4);
  }
  return c;
}



// WARNING: Could not reconcile some variable overlaps

int handle_LYK_ACTIVATE(int *c,int cmd,BOOLEAN *try_internal,BOOLEAN *refresh_screen,
                       BOOLEAN *force_load,int real_cmd)

{
  BOOLEAN BVar1;
  int iVar2;
  FILE *__stream;
  char *src;
  HTAtom *pHVar3;
  size_t __n;
  LinkInfo *pLVar4;
  char **ppcVar5;
  byte bVar6;
  char *local_8c;
  undefined4 local_88;
  undefined4 local_84;
  undefined4 local_80;
  undefined4 local_7c;
  undefined in_stack_ffffff88 [48];
  undefined4 local_38;
  LinkInfo *local_34;
  undefined *local_30;
  int local_28;
  undefined4 local_24;
  int local_20;
  char *local_1c;
  char *local_18;
  char *local_14;
  
  bVar6 = 0;
  local_30 = &stack0xffffff74;
  iVar2 = do_change_link();
  if (iVar2 == -1) {
    LYforce_no_cache = '\0';
    reloading = '\0';
    return 1;
  }
  if (nlinks < 1) {
    return 0;
  }
  if (links[curdoc.link].type == 1) {
    if (((real_cmd == 0x27) && (textfields_need_activation != '\0')) &&
       (((links[curdoc.link].l_form)->type == 1 ||
        (((((links[curdoc.link].l_form)->type == 0xc || ((links[curdoc.link].l_form)->type == 2)) ||
          ((links[curdoc.link].l_form)->type == 0xb)) || ((links[curdoc.link].l_form)->type == 9))))
       )) {
      textinput_activated = '\x01';
      local_34 = links + curdoc.link;
      local_38 = 0x11;
      iVar2 = 0x11;
      pLVar4 = local_34;
      ppcVar5 = (char **)&stack0xffffff74;
      while (iVar2 != 0) {
        iVar2 = iVar2 + -1;
        *ppcVar5 = pLVar4->lname;
        pLVar4 = (LinkInfo *)(&pLVar4->lname + (uint)bVar6 * 0x3ffffffe + 1);
        ppcVar5 = ppcVar5 + (uint)bVar6 * 0x3ffffffe + 1;
      }
      show_main_statusline
                ((LinkInfo)
                 CONCAT4820(in_stack_ffffff88,
                            CONCAT416(local_7c,CONCAT412(local_80,CONCAT48(local_84,CONCAT44(
                                                  local_88,local_8c))))),2);
      textfields_need_activation = textfields_activation_option;
      return 0;
    }
    if ((((links[curdoc.link].l_form)->type == 5) || ((links[curdoc.link].l_form)->type == 0xd)) ||
       ((links[curdoc.link].l_form)->type == 0xc)) {
      if ((links[curdoc.link].l_form)->disabled == 1) {
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return 0;
      }
      if (((links[curdoc.link].l_form)->submit_action == (char *)0x0) ||
         (*(links[curdoc.link].l_form)->submit_action == '\0')) {
        src = (char *)gettext();
        HTUserMsg(src);
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return 0;
      }
      if (((links[curdoc.link].l_form)->submit_method == 3) && (no_mail != '\0')) {
        src = (char *)gettext();
        HTAlert(src);
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return 0;
      }
      if ((no_file_url != '\0') &&
         (((*(links[curdoc.link].l_form)->submit_action == 'f' ||
           (*(links[curdoc.link].l_form)->submit_action == 'F')) &&
          (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"file:",5), iVar2 == 0)))
         ) {
        src = (char *)gettext();
        HTAlert(src);
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return 0;
      }
      iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXCOOKIE:",0xb);
      if (((((iVar2 == 0) ||
            ((iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXDIRED:",10),
             iVar2 == 0 &&
             (((no_dired_support != '\0' ||
               (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action + 10,
                                     "//PERMIT_LOCATION",0x11), iVar2 != 0)) ||
              (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,1), BVar1 == '\0')))))) ||
           (((iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXDOWNLOAD:",0xd),
             iVar2 == 0 ||
             (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXHIST:",9),
             iVar2 == 0)) ||
            ((iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXKEYMAP:",0xb),
             iVar2 == 0 ||
             ((iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXIMGMAP:",0xb),
              iVar2 == 0 ||
              (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXPRINT:",10),
              iVar2 == 0)))))))) ||
          (((*(links[curdoc.link].l_form)->submit_action == 'l' ||
            (*(links[curdoc.link].l_form)->submit_action == 'L')) &&
           (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"lynxexec:",9),
           iVar2 == 0)))) ||
         (((*(links[curdoc.link].l_form)->submit_action == 'l' ||
           (*(links[curdoc.link].l_form)->submit_action == 'L')) &&
          (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"lynxprog:",9),
          iVar2 == 0)))) {
        src = (char *)gettext();
        HTAlert(src);
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYMainLoop: Rejected \'%s\'\n");
        }
        HTOutputFormat = (HTFormat)HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return 0;
      }
      if (check_realm != '\0') {
        LYPermitURL = '\x01';
      }
      if (((no_filereferer == '\x01') && ((*curdoc.address == 'f' || (*curdoc.address == 'F')))) &&
         (iVar2 = strncasecomp(curdoc.address,"file:",5), iVar2 == 0)) {
        LYNoRefererForThis = '\x01';
      }
      if ((links[curdoc.link].l_form)->submit_method != 3) {
        src = LYGetHiliteStr(curdoc.link,0);
        HTSACopy((char **)&newdoc,src);
      }
    }
    if ((((links[curdoc.link].l_form)->type == 1) || ((links[curdoc.link].l_form)->type == 0xc)) ||
       (((links[curdoc.link].l_form)->type == 2 ||
        (((links[curdoc.link].l_form)->type == 0xb || ((links[curdoc.link].l_form)->type == 9))))))
    {
      if ((real_cmd == 0x2e) ||
         (((real_cmd == 0x3f || (real_cmd == 0x44)) ||
          ((real_cmd == 0x28 && (textinput_activated == '\0')))))) {
        local_28 = 0;
      }
      else {
        local_28 = 2;
      }
      show_formlink_statusline((FormInfo *)links[curdoc.link].l_form,local_28);
      if (((user_mode == 0) && (textinput_activated != '\0')) &&
         ((real_cmd == 0x27 || (real_cmd == 0x28)))) {
        form_noviceline((links[curdoc.link].l_form)->disabled);
      }
    }
    if ((((real_cmd == 0x28) || (real_cmd == 0x2e)) || (real_cmd == 0x3f)) || (real_cmd == 0x44)) {
      local_24 = 1;
    }
    else {
      local_24 = 0;
    }
    iVar2 = change_form_link(curdoc.link,&newdoc,refresh_screen,'\0',(BOOLEAN)local_24);
    *c = iVar2;
    if ((*c == 0x7fe) && (*refresh_screen == '\0')) {
      pHVar3 = HTAtom_for("www/download");
      if ((((pHVar3 == (HTAtom *)HTOutputFormat) && (newdoc.post_data != (bstring *)0x0)) &&
          (newdoc.safe == '\0')) && (BVar1 = HText_POSTReplyLoaded(&newdoc), BVar1 == '\x01')) {
        src = (char *)gettext();
        BVar1 = HTConfirm(src);
        if (BVar1 == '\0') {
          src = (char *)gettext();
          HTInfoMsg(src);
          HTOutputFormat = (HTFormat)HTAtom_for("www/present");
          LYforce_no_cache = '\0';
          copy_address(&newdoc,&curdoc);
          HTSACopy((char **)&newdoc,curdoc.title);
          if (curdoc.post_data == (bstring *)0x0) {
            local_20 = 0;
            local_1c = (char *)0x0;
          }
          else {
            local_20 = (curdoc.post_data)->len;
            local_1c = (curdoc.post_data)->str;
          }
          HTSABCopy(&newdoc.post_data,local_1c,local_20);
          HTSACopy(&newdoc.post_content_type,curdoc.post_content_type);
          HTSACopy(&newdoc.bookmark,curdoc.bookmark);
          newdoc.isHEAD = curdoc.isHEAD;
          newdoc.safe = curdoc.safe;
          newdoc.internal_link = curdoc.internal_link;
          return 0;
        }
      }
      if ((check_realm != '\0') && (LYValidate == '\0')) {
        LYPermitURL = '\x01';
      }
    }
    else {
      if ((((links[curdoc.link].l_form)->type == 5) ||
          (((links[curdoc.link].l_form)->type == 0xd || ((links[curdoc.link].l_form)->type == 0xc)))
          ) && ((links[curdoc.link].l_form)->submit_method != 3)) {
        src = HText_getTitle();
        if (src == (char *)0x0) {
          if (curdoc.title != (char *)0x0) {
            HTSACopy((char **)&newdoc,curdoc.title);
          }
        }
        else {
          src = HText_getTitle();
          HTSACopy((char **)&newdoc,src);
        }
      }
    }
    if (*c == 0x7fe) {
      *c = 0x10e;
    }
    else {
      if (*c == 0x17) {
        *c = 0x10e;
        *refresh_screen = '\x01';
      }
      else {
        if ((((*c & 0x8000U) == 0) && ((*c & 0x800U) != 0)) &&
           (iVar2 = LYReverseKeymap(*c & 0xff), -1 < iVar2)) {
          LYReverseKeymap(*c & 0xff);
        }
        if (((real_cmd == 0x27) || (real_cmd == 0x28)) &&
           (((((links[curdoc.link].l_form)->type == 1 ||
              ((((links[curdoc.link].l_form)->type == 0xc ||
                ((links[curdoc.link].l_form)->type == 2)) ||
               ((links[curdoc.link].l_form)->type == 0xb)))) ||
             ((links[curdoc.link].l_form)->type == 9)) && (textinput_activated != '\0')))) {
          return 3;
        }
      }
    }
    return 2;
  }
  if (((no_file_url != '\0') &&
      ((*links[curdoc.link].lname == 'f' || (*links[curdoc.link].lname == 'F')))) &&
     (iVar2 = strncasecomp(links[curdoc.link].lname,"file:",5), iVar2 == 0)) {
    if (((*curdoc.address != 'f') && (*curdoc.address != 'F')) ||
       (iVar2 = strncasecomp(curdoc.address,"file:",5), iVar2 != 0)) {
      iVar2 = strncasecomp(curdoc.address,"LYNXKEYMAP:",0xb);
      if ((iVar2 != 0) && (iVar2 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb), iVar2 != 0)) {
LAB_0807e34b:
        src = (char *)gettext();
        HTAlert(src);
        reloading = '\0';
        return 0;
      }
      __n = strlen(helpfilepath);
      iVar2 = strncmp(links[curdoc.link].lname,helpfilepath,__n);
      if (iVar2 != 0) goto LAB_0807e34b;
    }
    if (curdoc.bookmark != (char *)0x0) {
      src = (char *)gettext();
      HTAlert(src);
      reloading = '\0';
      return 0;
    }
  }
  iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXCOOKIE:",0xb);
  if (iVar2 == 0) {
    local_18 = (char *)gettext();
    if (curdoc.title == (char *)0x0) {
      local_14 = "";
    }
    else {
      local_14 = curdoc.title;
    }
    iVar2 = strcmp(local_14,local_18);
    if ((iVar2 != 0) || (iVar2 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb), iVar2 != 0))
    goto LAB_0807e610;
  }
  iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10);
  if (((((iVar2 == 0) &&
        (((BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,1), BVar1 == '\0' &&
          (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,1), BVar1 == '\0')) &&
         (BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,1), BVar1 == '\0')))) ||
       ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDOWNLOAD:",0xd), iVar2 == 0 &&
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_DOWNLOAD_OPTIONS,1), BVar1 == '\0')))) ||
      ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar2 == 0 &&
       (((BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,1), BVar1 == '\0' &&
         (BVar1 = LYIsUIPage3(curdoc.address,UIP_LIST_PAGE,1), BVar1 == '\0')) &&
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_ADDRLIST_PAGE,1), BVar1 == '\0')))))) ||
     ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10), iVar2 == 0 &&
      (BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,1), BVar1 == '\0')))) {
LAB_0807e610:
    src = (char *)gettext();
    HTAlert(src);
    HTOutputFormat = (HTFormat)HTAtom_for("www/present");
    LYforce_no_cache = '\0';
    reloading = '\0';
    return 0;
  }
  BVar1 = run_external(links[curdoc.link].lname,'\x01');
  if (BVar1 != '\0') {
    *refresh_screen = '\x01';
    return 0;
  }
  set_address(&newdoc,links[curdoc.link].lname);
  src = LYGetHiliteStr(curdoc.link,0);
  HTSACopy((char **)&newdoc,src);
  iVar2 = are_different(&curdoc,&newdoc);
  if (iVar2 != 0) {
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    iVar2 = strncasecomp(newdoc.address,"LYNXMESSAGES:",0xd);
    if (iVar2 == 0) {
      LYforce_no_cache = '\x01';
    }
  }
  if ((((no_jump == '\0') && (lynxjumpfile != (char *)0x0)) && (curdoc.address != (char *)0x0)) &&
     (iVar2 = strcmp(lynxjumpfile,curdoc.address), iVar2 == 0)) {
    LYJumpFileURL = '\x01';
    LYUserSpecifiedURL = '\x01';
    goto LAB_0807e858;
  }
  if (curdoc.title == (char *)0x0) {
LAB_0807e7d7:
    if ((curdoc.bookmark == (char *)0x0) &&
       ((lynxjumpfile == (char *)0x0 || (iVar2 = strcmp(lynxjumpfile,curdoc.address), iVar2 != 0))))
    {
      if (((no_filereferer == '\x01') && ((*curdoc.address == 'f' || (*curdoc.address == 'F')))) &&
         (iVar2 = strncasecomp(curdoc.address,"file:",5), iVar2 == 0)) {
        LYNoRefererForThis = '\x01';
      }
      goto LAB_0807e858;
    }
  }
  else {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,1);
    if (BVar1 == '\0') {
      src = (char *)gettext();
      iVar2 = strcmp(curdoc.title,src);
      if (iVar2 != 0) goto LAB_0807e7d7;
    }
  }
  LYUserSpecifiedURL = '\x01';
LAB_0807e858:
  newdoc.link = 0;
  *force_load = '\x01';
  psrc_view = '\0';
  if (lynx_edit_mode != '\0') {
    if (1 < LYAutoUncacheDirLists) {
      HTuncache_current_document();
    }
    HTUnEscapeSome(newdoc.address,"/");
    iVar2 = strcasecomp(newdoc.address,"file://localhost/");
    if (iVar2 != 0) {
      strip_trailing_slash(newdoc.address);
    }
  }
  iVar2 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb);
  if (iVar2 != 0) {
    return 0;
  }
  HTuncache_current_document();
  return 0;
}



void handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  BOOLEAN BVar1;
  int iVar2;
  char *Msg;
  char *local_18;
  int c;
  
  if (LYValidate != '\0') {
    if (*old_c == real_c) {
      return;
    }
    *old_c = real_c;
    Msg = (char *)gettext("Bookmark features are currently disabled.");
    HTUserMsg(Msg);
    return;
  }
  BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,1);
  if ((((((BVar1 != '\0') || (BVar1 = LYIsUIPage3(curdoc.address,UIP_SHOWINFO,1), BVar1 != '\0')) ||
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,1), BVar1 != '\0')) ||
       ((BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,1), BVar1 != '\0' ||
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,1), BVar1 != '\0')))) ||
      (((BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,1), BVar1 != '\0' ||
        ((BVar1 = LYIsUIPage3(curdoc.address,UIP_DOWNLOAD_OPTIONS,1), BVar1 != '\0' ||
         (iVar2 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb), iVar2 == 0)))) ||
       (BVar1 = LYIsUIPage3(curdoc.address,UIP_OPTIONS_MENU,1), BVar1 != '\0')))) ||
     ((0 < nlinks &&
      ((((links[curdoc.link].lname == (char *)0x0 ||
         (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar2 == 0)) ||
        (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10), iVar2 == 0)) ||
       (((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10), iVar2 == 0 ||
         (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDOWNLOAD:",0xd), iVar2 == 0)) ||
        ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXCOOKIE:",0xb), iVar2 == 0 ||
         (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10), iVar2 == 0)))))))))) {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("History, showinfo, menu and list files cannot be saved as bookmarks.");
      HTUserMsg(Msg);
    }
    return;
  }
  if (nlinks < 1) {
    if (curdoc.post_data != (bstring *)0x0) {
      Msg = (char *)gettext("Documents from forms with POST content cannot be saved as bookmarks.");
      HTUserMsg(Msg);
      return;
    }
    if (curdoc.bookmark != (char *)0x0) {
      Msg = (char *)gettext("There are no links in this bookmark file!");
      HTUserMsg(Msg);
      return;
    }
    mustshow = '\x01';
    Msg = (char *)gettext("Save D)ocument to bookmark file or C)ancel? (d,c): ");
    statusline(Msg);
    iVar2 = LYgetch_single();
    if (iVar2 != 0x44) {
      return;
    }
    save_bookmark_link(curdoc.address,curdoc.title);
    *refresh_screen = '\x01';
    goto check_add_bookmark_to_self;
  }
  if (((curdoc.post_data == (bstring *)0x0) && (curdoc.bookmark == (char *)0x0)) &&
     ((BVar1 = LYIsUIPage3(curdoc.address,UIP_LIST_PAGE,1), BVar1 == '\0' &&
      ((BVar1 = LYIsUIPage3(curdoc.address,UIP_ADDRLIST_PAGE,1), BVar1 == '\0' &&
       (BVar1 = LYIsUIPage3(curdoc.address,UIP_VLINKS,1), BVar1 == '\0')))))) {
    mustshow = '\x01';
    Msg = (char *)gettext("Save D)ocument or L)ink to bookmark file or C)ancel? (d,l,c): ");
    statusline(Msg);
    c = LYgetch_single();
    if (c == 0x44) {
      save_bookmark_link(curdoc.address,curdoc.title);
      *refresh_screen = '\x01';
      goto check_add_bookmark_to_self;
    }
  }
  else {
    if ((LYMultiBookmarks == 0) && (curdoc.bookmark != (char *)0x0)) {
      if (*bookmark_page == '.') {
        local_18 = bookmark_page + 1;
      }
      else {
        local_18 = bookmark_page;
      }
      Msg = strstr(curdoc.address,local_18);
      if (Msg == (char *)0x0) goto LAB_0807ed36;
      mustshow = '\x01';
      Msg = (char *)gettext("Reproduce L)ink in this bookmark file or C)ancel? (l,c): ");
      statusline(Msg);
    }
    else {
LAB_0807ed36:
      if ((curdoc.post_data != (bstring *)0x0) && (links[curdoc.link].type == 6)) {
        Msg = (char *)gettext("Documents from forms with POST content cannot be saved as bookmarks."
                             );
        HTUserMsg(Msg);
        return;
      }
      mustshow = '\x01';
      Msg = (char *)gettext("Save L)ink to bookmark file or C)ancel? (l,c): ");
      statusline(Msg);
    }
    c = LYgetch_single();
  }
  if (c != 0x4c) {
    return;
  }
  if ((curdoc.post_data != (bstring *)0x0) && (links[curdoc.link].type == 6)) {
    Msg = (char *)gettext("Documents from forms with POST content cannot be saved as bookmarks.");
    HTUserMsg(Msg);
    return;
  }
  if (links[curdoc.link].type == 1) {
    Msg = (char *)gettext("Cannot save form fields/links");
    HTUserMsg(Msg);
    return;
  }
  Msg = LYGetHiliteStr(curdoc.link,0);
  save_bookmark_link(links[curdoc.link].lname,Msg);
  *refresh_screen = '\x01';
check_add_bookmark_to_self:
  if (curdoc.bookmark == (char *)0x0) {
    return;
  }
  if (BookmarkPage == (char *)0x0) {
    return;
  }
  iVar2 = strcmp(curdoc.bookmark,BookmarkPage);
  if (iVar2 != 0) {
    return;
  }
  HTuncache_current_document();
  move_address(&newdoc,&curdoc);
  HTSACopy(&newdoc.bookmark,curdoc.bookmark);
  newdoc.link = curdoc.link;
  newdoc.line = curdoc.line;
  newdoc.internal_link = '\0';
  return;
}



void handle_LYK_CLEAR_AUTH(int *old_c,int real_c)

{
  BOOLEAN BVar1;
  char *Msg;
  
  if (*old_c != real_c) {
    *old_c = real_c;
    Msg = (char *)gettext("Clear all authorization info for this session?");
    BVar1 = HTConfirm(Msg);
    if (BVar1 == '\0') {
      Msg = (char *)gettext("Cancelled!!!");
      HTUserMsg(Msg);
    }
    else {
      if (authentication_info[0] != (char *)0x0) {
        free(authentication_info[0]);
        authentication_info[0] = (char *)0x0;
      }
      if (authentication_info[1] != (char *)0x0) {
        free(authentication_info[1]);
        authentication_info[1] = (char *)0x0;
      }
      if (proxyauth_info[0] != (char *)0x0) {
        free(proxyauth_info[0]);
        proxyauth_info[0] = (char *)0x0;
      }
      if (proxyauth_info[1] != (char *)0x0) {
        free(proxyauth_info[1]);
        proxyauth_info[1] = (char *)0x0;
      }
      HTClearHTTPAuthInfo();
      HTClearNNTPAuthInfo();
      HTClearFTPPassword();
      Msg = (char *)gettext("Authorization info cleared.");
      HTUserMsg(Msg);
    }
  }
  return;
}



int handle_LYK_COMMAND(char *user_input_buffer)

{
  int iVar1;
  char *buffer;
  char *pcVar2;
  Kcmd *pKVar3;
  FILE *__stream;
  LYKeymapCode local_20;
  LYKeymapCode local_1c;
  LYKeymapCode local_18;
  char *tmp;
  char *src;
  Kcmd *mp;
  int ch;
  
  *user_input_buffer = '\0';
  mustshow = '\x01';
  statusline(": ");
  iVar1 = LYgetstr(user_input_buffer,0,0x400,RECALL_CMD);
  if (iVar1 < 0) {
    local_1c = LYK_UNKNOWN;
  }
  else {
    buffer = LYSkipBlanks(user_input_buffer);
    pcVar2 = LYSkipNonBlanks(buffer);
    *pcVar2 = '\0';
    pKVar3 = LYStringToKcmd(buffer);
    if (pKVar3 == (Kcmd *)0x0) {
      local_20 = LYK_UNKNOWN;
    }
    else {
      local_20 = pKVar3->code;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYK_COMMAND(%s.%s) = %d\n",buffer,pcVar2,local_20);
    }
    if (local_20 == LYK_UNKNOWN) {
      if (*buffer == '\0') {
        local_18 = LYK_UNKNOWN;
      }
      else {
        local_18 = ~LYK_UNKNOWN;
      }
      local_1c = local_18;
    }
    else {
      local_1c = local_20;
    }
  }
  return local_1c;
}



void handle_LYK_COMMENT(BOOLEAN *refresh_screen,char **owner_address_p,int *old_c,int real_c)

{
  int iVar1;
  size_t sVar2;
  char *Msg;
  char *fmt;
  UrlTypes UVar3;
  char *pcVar4;
  char *local_30;
  char *local_2c;
  char *temp;
  char *id;
  char *kp;
  char *cp;
  char *address;
  int c;
  
  if ((*owner_address_p == (char *)0x0) &&
     (iVar1 = strncasecomp(curdoc.address,"http",4), iVar1 != 0)) {
    if (*old_c == real_c) {
      return;
    }
    *old_c = real_c;
    Msg = (char *)gettext("No owner is defined for this file so you cannot send a comment");
    HTUserMsg(Msg);
    return;
  }
  if (no_mail == '\0') {
    Msg = (char *)gettext("Do you wish to send a comment?");
    iVar1 = HTConfirmDefault(Msg,0);
    if (iVar1 != 0) {
      if (*owner_address_p == (char *)0x0) {
        address = (char *)0x0;
        temp = HTParse(curdoc.address,"",4);
        if (temp != (char *)0x0) {
          HTUnEscape(temp);
          if ((*temp == '~') && (sVar2 = strlen(temp), 1 < sVar2)) {
            Msg = strchr(temp + 1,0x2f);
            if (Msg != (char *)0x0) {
              *Msg = '\0';
            }
            HTSACopy(&address,"mailto:");
            HTSACat(&address,temp + 1);
            HTSACat(&address,"@");
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (address == (char *)0x0) {
          HTSACopy(&address,"mailto:WebMaster@");
        }
        temp = HTParse(curdoc.address,"",8);
        HTSACat(&address,temp);
        Msg = address;
        fmt = (char *)gettext("No owner is defined. Use %s?");
        HTSprintf0(&temp,fmt,Msg);
        iVar1 = HTConfirmDefault(temp,0);
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
        if (iVar1 != 1) {
          if (address == (char *)0x0) {
            return;
          }
          free(address);
          return;
        }
        HTSACopy(owner_address_p,address);
        if (address != (char *)0x0) {
          free(address);
          address = (char *)0x0;
        }
      }
      UVar3 = is_url(*owner_address_p);
      if (UVar3 == MAILTO_URL_TYPE) {
        kp = HText_getRevTitle();
        Msg = HText_getMessageID();
        temp = (char *)0x0;
        if ((((kp == (char *)0x0) && (HTMainAnchor != (HTParentAnchor *)0x0)) &&
            (kp = HTAnchor_subject(HTMainAnchor), kp != (char *)0x0)) &&
           ((*kp != '\0' && (iVar1 = strncasecomp(kp,"Re: ",4), iVar1 != 0)))) {
          HTSACopy(&temp,"Re: ");
          HTSACat(&temp,kp);
          kp = temp;
        }
        pcVar4 = strchr(*owner_address_p,0x3a);
        fmt = curdoc.address;
        if (pcVar4 == (char *)0x0) {
          if (kp == (char *)0x0) {
            local_2c = "";
          }
          else {
            local_2c = kp;
          }
          reply_by_mail(*owner_address_p,curdoc.address,local_2c,Msg);
        }
        else {
          if (kp == (char *)0x0) {
            local_30 = "";
          }
          else {
            local_30 = kp;
          }
          pcVar4 = strchr(*owner_address_p,0x3a);
          reply_by_mail(pcVar4 + 1,fmt,local_30,Msg);
        }
        if (temp != (char *)0x0) {
          free(temp);
        }
        *refresh_screen = '\x01';
      }
      else {
        set_address(&newdoc,*owner_address_p);
        newdoc.internal_link = '\0';
      }
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("Mail is disallowed so you cannot send a comment");
      HTUserMsg(Msg);
    }
  }
  return;
}



BOOLEAN handle_LYK_COOKIE_JAR(int *cmd)

{
  int iVar1;
  BOOLEAN local_5;
  
  iVar1 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb);
  if (iVar1 == 0) {
    *cmd = 0x25;
    local_5 = '\x01';
  }
  else {
    set_address(&newdoc,"LYNXCOOKIE:/");
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
    LYforce_no_cache = '\x01';
    if ((LYValidate != '\0') || (check_realm != '\0')) {
      LYPermitURL = '\x01';
    }
    local_5 = '\0';
  }
  return local_5;
}



void handle_LYK_CREATE(void)

{
  int iVar1;
  
  if ((lynx_edit_mode != '\0') && (no_dired_support == '\0')) {
    iVar1 = local_create(&curdoc);
    if (0 < iVar1) {
      if (0 < LYAutoUncacheDirLists) {
        HTuncache_current_document();
      }
      move_address(&newdoc,&curdoc);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.line = curdoc.line;
      newdoc.link = ~(curdoc.link >> 0x1f) & curdoc.link;
      LYclear();
    }
  }
  return;
}



void handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  char *Msg;
  int iVar1;
  
  if (curdoc.bookmark == (char *)0x0) {
    *refresh_screen = '\x01';
    if (*old_c != real_c) {
      *old_c = real_c;
      lynx_force_repaint();
    }
  }
  else {
    Msg = (char *)gettext("Do you really want to delete this link from your bookmark file?");
    iVar1 = HTConfirmDefault(Msg,0);
    if (iVar1 == 1) {
      remove_bookmark_link(links[curdoc.link].anchor_number + -1,curdoc.bookmark);
      do_cleanup_after_delete();
    }
  }
  return;
}



void handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  BOOLEAN BVar1;
  char *__s2;
  int iVar2;
  char *local_8;
  
  if ((lynx_edit_mode != '\0') && (no_dired_support == '\0')) {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,1);
    if (BVar1 == '\0') {
      __s2 = (char *)gettext("File Management Options");
      if (curdoc.title == (char *)0x0) {
        local_8 = "";
      }
      else {
        local_8 = curdoc.title;
      }
      iVar2 = strcmp(local_8,__s2);
      if (iVar2 != 0) {
        dired_options(&curdoc,&newdoc.address);
        *refresh_screen = '\x01';
      }
    }
  }
  return;
}



int handle_LYK_DOWNLOAD(int *cmd,int *old_c,int real_c)

{
  DocInfo temp;
  BOOLEAN BVar1;
  int iVar2;
  char *Msg;
  int local_1c;
  char *local_18;
  int number;
  
  if ((LYValidate != '\0') ||
     (((no_download != '\0' && (override_no_download == '\0')) && (no_disk_save != '\0')))) {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("The \'d\'ownload command is currently disabled.");
      HTUserMsg(Msg);
    }
    return 0;
  }
  BVar1 = LYIsUIPage3(curdoc.address,UIP_DOWNLOAD_OPTIONS,1);
  if (BVar1 != '\0') {
    return 0;
  }
  iVar2 = do_change_link();
  if (iVar2 != -1) {
    if (nlinks < 1) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("Nothing to download.");
        HTUserMsg(Msg);
      }
    }
    else {
      if (links[curdoc.link].type == 1) {
        if ((((links[curdoc.link].l_form)->type == 5) || ((links[curdoc.link].l_form)->type == 0xd))
           || ((links[curdoc.link].l_form)->type == 0xc)) {
          if ((links[curdoc.link].l_form)->submit_method == 3) {
            if (*old_c != real_c) {
              *old_c = real_c;
              Msg = (char *)gettext("Form has a mailto action!  Cannot download.");
              HTUserMsg(Msg);
            }
            return 0;
          }
          iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXOPTIONS:",0xc);
          if (iVar2 == 0) {
            if (*old_c != real_c) {
              *old_c = real_c;
              Msg = (char *)gettext("This special URL cannot be downloaded!");
              HTUserMsg(Msg);
            }
            return 0;
          }
          HTOutputFormat = (HTFormat)HTAtom_for("www/download");
          LYforce_no_cache = '\x01';
          *cmd = 0x27;
          return 2;
        }
        if (*old_c != real_c) {
          *old_c = real_c;
          Msg = (char *)gettext("You cannot download an input field.");
          HTUserMsg(Msg);
        }
      }
      else {
        iVar2 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb);
        if (iVar2 == 0) {
          if (*old_c != real_c) {
            *old_c = real_c;
            Msg = (char *)gettext("You cannot download cookies.");
            HTUserMsg(Msg);
          }
        }
        else {
          BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,1);
          if (BVar1 == '\0') {
            BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,1);
            if (BVar1 == '\0') {
              BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,1);
              if (BVar1 == '\0') {
                if (((lynx_edit_mode == '\0') || (no_dired_support != '\0')) ||
                   (Msg = strstr(links[curdoc.link].lname,"/SugFile="), Msg != (char *)0x0)) {
                  BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,1);
                  if ((BVar1 == '\0') ||
                     (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar2 != 0)) {
                    iVar2 = strncmp(links[curdoc.link].lname,"data:",5);
                    if (iVar2 == 0) {
                      if (*old_c != real_c) {
                        *old_c = real_c;
                        Msg = (char *)gettext("Unsupported data: URL!  Use SHOWINFO, for now.");
                        HTAlert(Msg);
                      }
                    }
                    else {
                      iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXCOOKIE:",0xb);
                      if (((((((iVar2 == 0) ||
                              (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10),
                              iVar2 == 0)) ||
                             (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDOWNLOAD:",0xd),
                             iVar2 == 0)) ||
                            ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10),
                             iVar2 == 0 ||
                             (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXOPTIONS:",0xc),
                             iVar2 == 0)))) ||
                           ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9),
                            iVar2 == 0 ||
                            ((iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9),
                             iVar2 == 0 ||
                             (iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXCOMPILEOPTS:",0x10)
                             , iVar2 == 0)))))) ||
                          (((*links[curdoc.link].lname == 'l' || (*links[curdoc.link].lname == 'L'))
                           && (iVar2 = strncasecomp(links[curdoc.link].lname,"lynxexec:",9),
                              iVar2 == 0)))) ||
                         (((*links[curdoc.link].lname == 'l' || (*links[curdoc.link].lname == 'L'))
                          && (iVar2 = strncasecomp(links[curdoc.link].lname,"lynxprog:",9),
                             iVar2 == 0)))) {
                        Msg = (char *)gettext("This special URL cannot be downloaded!");
                        HTUserMsg(Msg);
                      }
                      else {
                        iVar2 = strncasecomp(links[curdoc.link].lname,"mailto:",7);
                        if (iVar2 == 0) {
                          Msg = (char *)gettext("You cannot download a mailto: link.");
                          HTUserMsg(Msg);
                        }
                        else {
                          if (((local_host_only == '\0') ||
                              (BVar1 = LYisLocalHost(links[curdoc.link].lname), BVar1 != '\0')) ||
                             (BVar1 = LYisLocalAlias(links[curdoc.link].lname), BVar1 != '\0')) {
                            set_address(&newdoc,links[curdoc.link].lname);
                            Msg = LYGetHiliteStr(curdoc.link,0);
                            HTSACopy((char **)&newdoc,Msg);
                            iVar2 = are_different(&curdoc,&newdoc);
                            if (iVar2 != 0) {
                              LYFreePostData(&newdoc);
                              if (newdoc.bookmark != (char *)0x0) {
                                free(newdoc.bookmark);
                                newdoc.bookmark = (char *)0x0;
                              }
                              newdoc.isHEAD = '\0';
                              newdoc.safe = '\0';
                            }
                            newdoc.internal_link = '\0';
                            newdoc.link = ZEXT14(user_mode == 0);
                            HTOutputFormat = (HTFormat)HTAtom_for("www/download");
                            LYforce_no_cache = '\x01';
                          }
                          else {
                            Msg = (char *)gettext(
                                                 "Only files and servers on the local host can be accessed."
                                                 );
                            HTUserMsg(Msg);
                          }
                        }
                      }
                    }
                  }
                  else {
                    iVar2 = atoi(links[curdoc.link].lname + 9);
                    if ((nhist <= iVar2) || (iVar2 < 0)) {
                      Msg = (char *)gettext("This special URL cannot be downloaded!");
                      HTUserMsg(Msg);
                      return 0;
                    }
                    if ((history[iVar2].hdoc.post_data != (bstring *)0x0) &&
                       (history[iVar2].hdoc.safe != '\x01')) {
                      Msg = (char *)gettext("Document from Form with POST content.  Resubmit?");
                      BVar1 = HTConfirm(Msg);
                      if (BVar1 == '\0') {
                        Msg = (char *)gettext("Cancelled!!!");
                        HTInfoMsg(Msg);
                        return 0;
                      }
                    }
                    copy_address(&newdoc,(DocInfo *)(history + iVar2));
                    Msg = LYGetHiliteStr(curdoc.link,0);
                    HTSACopy((char **)&newdoc,Msg);
                    HTSACopy(&newdoc.bookmark,history[iVar2].hdoc.bookmark);
                    LYFreePostData(&newdoc);
                    if (history[iVar2].hdoc.post_data != (bstring *)0x0) {
                      if (history[iVar2].hdoc.post_data == (bstring *)0x0) {
                        local_1c = 0;
                      }
                      else {
                        local_1c = (history[iVar2].hdoc.post_data)->len;
                      }
                      if (history[iVar2].hdoc.post_data == (bstring *)0x0) {
                        local_18 = (char *)0x0;
                      }
                      else {
                        local_18 = (history[iVar2].hdoc.post_data)->str;
                      }
                      HTSABCopy(&newdoc.post_data,local_18,local_1c);
                    }
                    if (history[iVar2].hdoc.post_content_type != (char *)0x0) {
                      HTSACopy(&newdoc.post_content_type,history[iVar2].hdoc.post_content_type);
                    }
                    newdoc.isHEAD = history[iVar2].hdoc.isHEAD;
                    newdoc.safe = history[iVar2].hdoc.safe;
                    newdoc.internal_link = '\0';
                    newdoc.link = ZEXT14(user_mode == 0);
                    HTOutputFormat = (HTFormat)HTAtom_for("www/download");
                    LYUserSpecifiedURL = '\x01';
                    LYforce_no_cache = '\x01';
                  }
                }
                else {
                  copy_address((DocInfo *)&ram0x081aea60,&newdoc);
                  set_address(&newdoc,links[curdoc.link].lname);
                  iVar2 = LYdownload_options(&newdoc.address,links[curdoc.link].lname);
                  if (iVar2 < 0) {
                    copy_address(&newdoc,(DocInfo *)0x81aea60);
                  }
                  else {
                    newdoc.internal_link = '\0';
                  }
                  LYFreeDocInfo((DocInfo *)0x81aea60);
                }
              }
              else {
                if (*old_c != real_c) {
                  *old_c = real_c;
                  Msg = (char *)gettext("You cannot download an permit option.");
                  HTUserMsg(Msg);
                }
              }
            }
            else {
              if (*old_c != real_c) {
                *old_c = real_c;
                Msg = (char *)gettext("You cannot download an upload option.");
                HTUserMsg(Msg);
              }
            }
          }
          else {
            if (*old_c != real_c) {
              *old_c = real_c;
              Msg = (char *)gettext("You cannot download a printing option.");
              HTUserMsg(Msg);
            }
          }
        }
      }
    }
    return 0;
  }
  return 1;
}



void handle_LYK_DOWN_xxx(int *old_c,int real_c,int scroll_by)

{
  char *Msg;
  int i;
  
  if (more_text == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at the end of this document.");
      HTInfoMsg(Msg);
    }
  }
  else {
    Newline = Newline + scroll_by;
    if (((0 < nlinks) && (-1 < curdoc.link)) && (scroll_by < links[curdoc.link].ly)) {
      newdoc.link = curdoc.link;
      i = 0;
      while (links[i].ly <= scroll_by) {
        newdoc.link = newdoc.link + -1;
        i = i + 1;
      }
    }
  }
  return;
}



void handle_LYK_DOWN_HALF(int *old_c,int real_c)

{
  handle_LYK_DOWN_xxx(old_c,real_c,display_lines / 2);
  return;
}



void handle_LYK_DOWN_LINK(int *follow_col,int *old_c,int real_c)

{
  char *Msg;
  size_t sVar1;
  int nextlink;
  char *text;
  int newlink;
  
  if (curdoc.link < nlinks + -1) {
    if (*follow_col == -1) {
      Msg = LYGetHiliteStr(curdoc.link,0);
      *follow_col = links[curdoc.link].lx;
      if (Msg != (char *)0x0) {
        nextlink = *follow_col;
        sVar1 = strlen(Msg);
        *follow_col = nextlink + (sVar1 >> 1);
      }
    }
    nextlink = find_link_near_col(*follow_col,1);
    if (nextlink < 0) {
      if (more_text == '\0') {
        if (*old_c != real_c) {
          *old_c = real_c;
          Msg = (char *)gettext("There are no links below this line of the document.");
          HTUserMsg(Msg);
        }
      }
      else {
        Newline = Newline + display_lines;
      }
    }
    else {
      set_curdoc_link(nextlink);
    }
  }
  else {
    if (more_text == '\0') {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are already at the end of this document.");
        HTInfoMsg(Msg);
      }
    }
    else {
      Newline = Newline + display_lines;
    }
  }
  return;
}



void handle_LYK_DOWN_TWO(int *old_c,int real_c)

{
  handle_LYK_DOWN_xxx(old_c,real_c,2);
  return;
}



int handle_LYK_DWIMEDIT(int *cmd,int *old_c,int real_c)

{
  char *Msg;
  int local_8;
  
  if (((nlinks < 1) || (links[curdoc.link].type != 1)) || ((links[curdoc.link].l_form)->type != 9))
  {
    if (((nlinks < 1) || (links[curdoc.link].type != 1)) || ((links[curdoc.link].l_form)->type != 1)
       ) {
      if (no_editor == '\0') {
        local_8 = 0;
      }
      else {
        if (*old_c != real_c) {
          *old_c = real_c;
          Msg = (char *)gettext("External editing is currently disabled.");
          HTUserMsg(Msg);
        }
        local_8 = 1;
      }
    }
    else {
      Msg = (char *)gettext("This field cannot be (e)dited with an external editor.");
      HTUserMsg(Msg);
      local_8 = 1;
    }
  }
  else {
    *cmd = 0x56;
    local_8 = 2;
  }
  return local_8;
}



int handle_LYK_ECGOTO(int *ch,char *user_input_buffer,char **old_user_input,int *old_c,int real_c)

{
  BOOLEAN BVar1;
  char *Msg;
  int iVar2;
  
  if ((no_goto == '\0') || (LYValidate != '\0')) {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,1);
    if ((BVar1 == '\0') &&
       ((BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,1), BVar1 == '\0' &&
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,1), BVar1 == '\0')))) {
      HTSACopy(old_user_input,user_input_buffer);
      LYstrncpy(user_input_buffer,curdoc.address,0x3ff);
      if (curdoc.post_data != (bstring *)0x0) {
        Msg = (char *)gettext("Current document has POST data.");
        HTAlert(Msg);
      }
      mustshow = '\x01';
      Msg = (char *)gettext("Edit this document\'s URL: ");
      statusline(Msg);
      iVar2 = LYgetstr(user_input_buffer,0,0x400,RECALL_URL);
      *ch = iVar2;
      if ((((-1 < *ch) && (*user_input_buffer != '\0')) &&
          (iVar2 = strcmp(user_input_buffer,curdoc.address), iVar2 != 0)) &&
         (LYTrimAllStartfile(user_input_buffer), *user_input_buffer != '\0')) {
        return 2;
      }
      Msg = (char *)gettext("Cancelled!!!");
      HTInfoMsg(Msg);
      LYstrncpy(user_input_buffer,*old_user_input,0x3ff);
      if (*old_user_input != (char *)0x0) {
        free(*old_user_input);
        *old_user_input = (char *)0x0;
      }
      return 0;
    }
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You cannot edit File Management URLs");
      HTUserMsg(Msg);
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("Goto a random URL is disallowed!");
      HTUserMsg(Msg);
    }
  }
  return 0;
}



void handle_LYK_EDIT(int *old_c,int real_c)

{
  UrlTypes UVar1;
  char *Msg;
  int iVar2;
  stat dir_info;
  char *tp;
  char *cp;
  
  tp = (char *)0x0;
  if (no_editor == '\0') {
    if ((((lynx_edit_mode == '\0') || (editor == (char *)0x0)) || (*editor == '\0')) ||
       (no_dired_support != '\0')) {
      if ((editor == (char *)0x0) || (*editor == '\0')) {
        if (*old_c != real_c) {
          *old_c = real_c;
          Msg = (char *)gettext("No editor is defined!");
          HTUserMsg(Msg);
        }
      }
      else {
        iVar2 = edit_current_file(newdoc.address,curdoc.link,Newline);
        if (iVar2 != 0) {
          HTuncache_current_document();
          LYforce_no_cache = '\x01';
          free_address(&curdoc);
          newdoc.line = curdoc.line;
          newdoc.link = curdoc.link;
          LYclear();
        }
      }
    }
    else {
      if (0 < nlinks) {
        Msg = links[curdoc.link].lname;
        UVar1 = is_url(Msg);
        if (UVar1 == FILE_URL_TYPE) {
          Msg = HTnameOfFile_WWW(Msg,'\0','\x01');
          HTSACopy(&tp,Msg);
          if (Msg != (char *)0x0) {
            free(Msg);
          }
          iVar2 = stat64(tp,(stat64 *)&dir_info);
          if (iVar2 == -1) {
            Msg = (char *)gettext("System error - failure to get status.");
            HTAlert(Msg);
          }
          else {
            if ((dir_info.st_mode & 0xf000) == 0x8000) {
              HTSACopy(&tp,links[curdoc.link].lname);
              HTUnEscapeSome(tp,"/");
              iVar2 = edit_current_file(tp,curdoc.link,Newline);
              if (iVar2 != 0) {
                if (0 < LYAutoUncacheDirLists) {
                  HTuncache_current_document();
                }
                move_address(&newdoc,&curdoc);
                newdoc.line = curdoc.line;
                newdoc.link = curdoc.link;
                LYclear();
              }
            }
          }
          if (tp != (char *)0x0) {
            free(tp);
          }
        }
      }
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("The \'e\'dit command is currently disabled.");
      HTUserMsg(Msg);
    }
  }
  return;
}



void handle_LYK_DWIMHELP(char **cshelpfile)

{
  char *pcVar1;
  
  if (((((-1 < curdoc.link) && (curdoc.link < nlinks)) && (links[curdoc.link].type == 1)) &&
      ((links[curdoc.link].l_form)->disabled == 0)) &&
     ((((links[curdoc.link].l_form)->type == 1 || ((links[curdoc.link].l_form)->type == 0xc)) ||
      (((links[curdoc.link].l_form)->type == 2 ||
       (((links[curdoc.link].l_form)->type == 0xb || ((links[curdoc.link].l_form)->type == 9))))))))
  {
    pcVar1 = LYLineeditHelpURL();
    *cshelpfile = pcVar1;
  }
  return;
}



void handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  char *Msg;
  int n;
  
  if (no_editor == '\0') {
    if ((editor == (char *)0x0) || (*editor == '\0')) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("No editor is defined!");
        HTUserMsg(Msg);
      }
    }
    else {
      if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
        stop_curses();
        HText_ExtEditForm(links + curdoc.link);
        start_curses();
        *refresh_screen = '\x01';
      }
      else {
        Msg = (char *)gettext("Not in a TEXTAREA; cannot use external editor.");
        HTInfoMsg(Msg);
      }
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("External editing is currently disabled.");
      HTUserMsg(Msg);
    }
  }
  return;
}



int handle_LYK_ELGOTO(int *ch,char *user_input_buffer,char **old_user_input,int *old_c,int real_c)

{
  BOOLEAN BVar1;
  char *text;
  int iVar2;
  char *local_c;
  char *local_8;
  
  if ((no_goto == '\0') || (LYValidate != '\0')) {
    if (((nlinks < 1) || (curdoc.link < 0)) ||
       ((((links[curdoc.link].type == 1 && ((links[curdoc.link].l_form)->type != 5)) &&
         ((links[curdoc.link].l_form)->type != 0xd)) && ((links[curdoc.link].l_form)->type != 0xc)))
       ) {
      if (*old_c != real_c) {
        *old_c = real_c;
        text = (char *)gettext("You are not on a form submission button or normal link.");
        HTUserMsg(text);
      }
    }
    else {
      if ((links[curdoc.link].type == 1) &&
         (((links[curdoc.link].l_form)->submit_action == (char *)0x0 ||
          (*(links[curdoc.link].l_form)->submit_action == '\0')))) {
        if (*old_c != real_c) {
          *old_c = real_c;
          text = (char *)gettext("** Bad HTML!!  No form action defined. **");
          HTUserMsg(text);
        }
      }
      else {
        iVar2 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10);
        if ((iVar2 != 0) &&
           (((BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,1), BVar1 == '\0' &&
             (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,1), BVar1 == '\0')) &&
            (BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,1), BVar1 == '\0')))) {
          HTSACopy(old_user_input,user_input_buffer);
          if (links[curdoc.link].type == 1) {
            local_c = (links[curdoc.link].l_form)->submit_action;
          }
          else {
            local_c = links[curdoc.link].lname;
          }
          LYstrncpy(user_input_buffer,local_c,0x3ff);
          mustshow = '\x01';
          text = (char *)gettext("Edit the current link\'s URL: ");
          statusline(text);
          iVar2 = LYgetstr(user_input_buffer,0,0x400,RECALL_URL);
          *ch = iVar2;
          if ((-1 < *ch) && (*user_input_buffer != '\0')) {
            if (links[curdoc.link].type == 1) {
              local_8 = (links[curdoc.link].l_form)->submit_action;
            }
            else {
              local_8 = links[curdoc.link].lname;
            }
            iVar2 = strcmp(user_input_buffer,local_8);
            if ((iVar2 != 0) && (LYTrimAllStartfile(user_input_buffer), *user_input_buffer != '\0'))
            {
              return 2;
            }
          }
          text = (char *)gettext("Cancelled!!!");
          HTInfoMsg(text);
          LYstrncpy(user_input_buffer,*old_user_input,0x3ff);
          if (*old_user_input != (char *)0x0) {
            free(*old_user_input);
            *old_user_input = (char *)0x0;
          }
          return 0;
        }
        if (*old_c != real_c) {
          *old_c = real_c;
          text = (char *)gettext("You cannot edit File Management URLs");
          HTUserMsg(text);
        }
      }
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      text = (char *)gettext("Goto a random URL is disallowed!");
      HTUserMsg(text);
    }
  }
  return 0;
}



void handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)

{
  if ((0 < nlinks) && (links[curdoc.link].lname != (char *)0x0)) {
    run_external(links[curdoc.link].lname,'\0');
    *refresh_screen = '\x01';
  }
  return;
}



void handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)

{
  if (curdoc.address != (char *)0x0) {
    run_external(curdoc.address,'\0');
    *refresh_screen = '\x01';
  }
  return;
}



BOOLEAN handle_LYK_FASTBACKW_LINK(int *cmd,int *old_c,int real_c)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  char *twee;
  char *thisname_1;
  int thisgroup_1;
  char *thisname;
  int thisgroup;
  int code;
  int res;
  int nextlink;
  int samepage;
  
  bVar1 = false;
  nextlink = curdoc.link;
  if (1 < nlinks) {
    if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
      iVar3 = (links[curdoc.link].l_form)->number;
      twee = (links[curdoc.link].l_form)->name;
      if ((curdoc.link < 1) ||
         ((((links[0].type == 1 && ((links[0].l_form)->type == 9)) &&
           ((links[0].l_form)->number == iVar3)) &&
          (iVar2 = sametext((links[0].l_form)->name,twee), iVar2 != 0)))) {
        if ((((((more_text == '\0') && (Newline == 1)) && (links[0].type == 1)) &&
             (((links[0].l_form)->type == 9 && ((links[0].l_form)->number == iVar3)))) &&
            (iVar2 = sametext((links[0].l_form)->name,twee), iVar2 != 0)) &&
           ((((links[nlinks + -1].type != 1 || ((links[nlinks + -1].l_form)->type != 9)) ||
             ((links[nlinks + -1].l_form)->number != iVar3)) ||
            (iVar3 = sametext((links[nlinks + -1].l_form)->name,twee), iVar3 == 0)))) {
          nextlink = nlinks + -1;
          bVar1 = true;
        }
        else {
          if (((more_text == '\0') && (Newline == 1)) && (0 < curdoc.link)) {
            nextlink = 0;
            bVar1 = true;
          }
        }
      }
      else {
        while ((nextlink = nextlink + -1, links[nextlink].type == 1 &&
               ((links[nextlink].l_form)->type == 9))) {
          if (((links[nextlink].l_form)->number != iVar3) ||
             (iVar2 = sametext((links[nextlink].l_form)->name,twee), iVar2 == 0)) break;
        }
        bVar1 = true;
      }
    }
    else {
      if (curdoc.link < 1) {
        if ((more_text == '\0') && (Newline == 1)) {
          nextlink = nlinks + -1;
          bVar1 = true;
        }
      }
      else {
        nextlink = curdoc.link + -1;
        bVar1 = true;
      }
    }
  }
  if (bVar1) {
    if (((0 < nextlink) && (links[nextlink].type == 1)) && ((links[nextlink].l_form)->type == 9)) {
      iVar3 = (links[nextlink].l_form)->number;
      twee = (links[nextlink].l_form)->name;
      if (((links[0].type == 1) && ((links[0].l_form)->type == 9)) &&
         (((links[0].l_form)->number == iVar3 &&
          (iVar2 = sametext((links[0].l_form)->name,twee), iVar2 != 0)))) {
        nextlink = 0;
      }
      else {
        while (((1 < nextlink && (links[nextlink + -1].type == 1)) &&
               (((links[nextlink + -1].l_form)->type == 9 &&
                (((links[nextlink + -1].l_form)->number == iVar3 &&
                 (iVar2 = sametext((links[nextlink + -1].l_form)->name,twee), iVar2 != 0))))))) {
          nextlink = nextlink + -1;
        }
      }
    }
    set_curdoc_link(nextlink);
    return '\0';
  }
  if ((1 < Newline) &&
     (iVar3 = HTGetLinkOrFieldStart(curdoc.link,&Newline,&newdoc.link,-1,'\x01'), iVar3 != 0)) {
    if (iVar3 == 0x10) {
      if (0 < nlinks) {
        curdoc.link = 0;
      }
      *cmd = 0x1a;
      return '\x01';
    }
    Newline = Newline + 1;
    return '\0';
  }
  if (*old_c == real_c) {
    return '\0';
  }
  *old_c = real_c;
  twee = (char *)gettext("There are no links above this line of the document.");
  HTInfoMsg(twee);
  return '\0';
}



void handle_LYK_FASTFORW_LINK(int *old_c,int real_c)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  char *twee;
  char *thisname;
  int thisgroup;
  int nextlink;
  int samepage;
  
  bVar1 = false;
  nextlink = curdoc.link;
  if (1 < nlinks) {
    if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
      iVar3 = (links[curdoc.link].l_form)->number;
      twee = (links[curdoc.link].l_form)->name;
      if ((curdoc.link < nlinks + -1) &&
         (((links[nlinks + -1].type != 1 || ((links[nlinks + -1].l_form)->type != 9)) ||
          (((links[nlinks + -1].l_form)->number != iVar3 ||
           (iVar2 = sametext((links[nlinks + -1].l_form)->name,twee), iVar2 == 0)))))) {
        do {
          nextlink = nextlink + 1;
          if (((links[nextlink].type != 1) || ((links[nextlink].l_form)->type != 9)) ||
             ((links[nextlink].l_form)->number != iVar3)) break;
          iVar2 = sametext((links[nextlink].l_form)->name,twee);
        } while (iVar2 != 0);
        bVar1 = true;
      }
      else {
        if (((more_text == '\0') && (Newline == 1)) && (0 < curdoc.link)) {
          nextlink = 0;
          bVar1 = true;
        }
      }
    }
    else {
      if (curdoc.link < nlinks + -1) {
        nextlink = curdoc.link + 1;
        bVar1 = true;
      }
      else {
        if (((more_text == '\0') && (Newline == 1)) && (0 < curdoc.link)) {
          nextlink = 0;
          bVar1 = true;
        }
      }
    }
  }
  if (bVar1) {
    set_curdoc_link(nextlink);
  }
  else {
    if (((more_text == '\0') && (Newline == 1)) && (curdoc.link == nlinks + -1)) {
      set_curdoc_link(0);
    }
    else {
      if ((more_text != '\0') &&
         (iVar3 = HTGetLinkOrFieldStart(curdoc.link,&Newline,&newdoc.link,1,'\x01'), iVar3 != 0)) {
        Newline = Newline + 1;
        return;
      }
      if (*old_c != real_c) {
        *old_c = real_c;
        twee = (char *)gettext("There are no links below this line of the document.");
        HTInfoMsg(twee);
      }
    }
  }
  return;
}



void handle_LYK_FIRST_LINK(void)

{
  int iVar1;
  int i;
  
  i = curdoc.link;
  iVar1 = i;
  do {
    i = iVar1;
    iVar1 = i + -1;
    if (iVar1 < 0) break;
  } while (links[iVar1].ly == links[curdoc.link].ly);
  set_curdoc_link(i);
  return;
}



BOOLEAN handle_LYK_GOTO(int *ch,char *user_input_buffer,char **old_user_input,RecallType *recall,
                       int *URLTotal,int *URLNum,BOOLEAN *FirstURLRecall,int *old_c,int real_c)

{
  char *text;
  int iVar1;
  BOOLEAN local_9;
  int local_8;
  
  if ((no_goto == '\0') || (LYValidate != '\0')) {
    HTSACopy(old_user_input,user_input_buffer);
    if (goto_buffer == '\0') {
      *user_input_buffer = '\0';
    }
    if (Goto_URLs == (HTList *)0x0) {
      local_8 = 0;
    }
    else {
      local_8 = HTList_count(Goto_URLs);
    }
    *URLTotal = local_8;
    if ((goto_buffer == '\0') || (*user_input_buffer == '\0')) {
      *recall = (uint)(0 < *URLTotal);
      *URLNum = *URLTotal;
      *FirstURLRecall = '\x01';
    }
    else {
      *recall = (uint)(1 < *URLTotal);
      *URLNum = 0;
      *FirstURLRecall = '\0';
    }
    mustshow = '\x01';
    text = (char *)gettext("URL to open: ");
    statusline(text);
    iVar1 = LYgetstr(user_input_buffer,0,0x400,*recall);
    *ch = iVar1;
    if (*ch < 0) {
      LYstrncpy(user_input_buffer,*old_user_input,0x3ff);
      if (*old_user_input != (char *)0x0) {
        free(*old_user_input);
        *old_user_input = (char *)0x0;
      }
      text = (char *)gettext("Cancelled!!!");
      HTInfoMsg(text);
      local_9 = '\0';
    }
    else {
      local_9 = '\x01';
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      text = (char *)gettext("Goto a random URL is disallowed!");
      HTUserMsg(text);
    }
    local_9 = '\0';
  }
  return local_9;
}



void handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)

{
  char *Msg;
  
  if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
    HText_ExpandTextarea(links + curdoc.link,5);
    *refresh_screen = '\x01';
  }
  else {
    Msg = (char *)gettext("Not in a TEXTAREA; cannot use command.");
    HTInfoMsg(Msg);
  }
  return;
}



BOOLEAN handle_LYK_HEAD(int *cmd)

{
  BOOLEAN BVar1;
  int iVar2;
  char *Msg;
  char *local_20;
  char *local_18;
  char *scheme_1;
  char *scheme;
  int c;
  
  if ((nlinks < 1) ||
     ((((links[curdoc.link].type == 1 && ((links[curdoc.link].l_form)->type != 5)) &&
       ((links[curdoc.link].l_form)->type != 0xd)) && ((links[curdoc.link].l_form)->type != 0xc))))
  {
    if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
      Msg = (char *)gettext("Document from POST action, HEAD may not be understood.  Proceed?");
      BVar1 = HTConfirm(Msg);
      if (BVar1 == '\0') {
        Msg = (char *)gettext("Cancelled!!!");
        HTInfoMsg(Msg);
        return '\0';
      }
    }
    if (nlinks < 1) {
      c = 0x44;
    }
    else {
      mustshow = '\x01';
      Msg = (char *)gettext("Send HEAD request for D)ocument, or C)ancel? (d,c): ");
      statusline(Msg);
      c = LYgetch_single();
    }
    if (c == 0x44) {
      iVar2 = strncasecomp(curdoc.address,"LYNXIMGMAP:",0xb);
      if (iVar2 == 0) {
        local_18 = curdoc.address + 0xb;
      }
      else {
        local_18 = curdoc.address;
      }
      BVar1 = LYCanDoHEAD(local_18);
      if (BVar1 == '\x01') {
        HEAD_request = '\x01';
        LYforce_no_cache = '\x01';
        HTSACopy((char **)&newdoc,curdoc.title);
        BVar1 = HTLoadedDocumentIsHEAD();
        if (BVar1 == '\0') {
          HTSACat((char **)&newdoc," - HEAD");
        }
        else {
          HText_setNoCache(HTMainText);
          free_address(&curdoc);
        }
      }
      else {
        Msg = (char *)gettext("Sorry, the document is not an http URL.");
        HTUserMsg(Msg);
      }
    }
  }
  else {
    mustshow = '\x01';
    Msg = (char *)gettext("Send HEAD request for D)ocument or L)ink, or C)ancel? (d,l,c): ");
    statusline(Msg);
    iVar2 = LYgetch_single();
    if (iVar2 == 0x44) {
      iVar2 = strncasecomp(curdoc.address,"LYNXIMGMAP:",0xb);
      if (iVar2 == 0) {
        local_20 = curdoc.address + 0xb;
      }
      else {
        local_20 = curdoc.address;
      }
      BVar1 = LYCanDoHEAD(local_20);
      if (BVar1 == '\x01') {
        if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
          Msg = (char *)gettext("Document from POST action, HEAD may not be understood.  Proceed?");
          BVar1 = HTConfirm(Msg);
          if (BVar1 == '\0') {
            Msg = (char *)gettext("Cancelled!!!");
            HTInfoMsg(Msg);
            return '\0';
          }
        }
        HEAD_request = '\x01';
        LYforce_no_cache = '\x01';
        HTSACopy((char **)&newdoc,curdoc.title);
        BVar1 = HTLoadedDocumentIsHEAD();
        if (BVar1 == '\0') {
          HTSACat((char **)&newdoc," - HEAD");
        }
        else {
          HText_setNoCache(HTMainText);
          free_address(&curdoc);
        }
      }
      else {
        Msg = (char *)gettext("Sorry, the document is not an http URL.");
        HTUserMsg(Msg);
      }
    }
    else {
      if (iVar2 == 0x4c) {
        if ((((links[curdoc.link].type == 1) ||
             (iVar2 = strncmp(links[curdoc.link].lname,"http",4), iVar2 == 0)) ||
            ((iVar2 = strncmp(links[curdoc.link].lname,"LYNXIMGMAP:http",0xf), iVar2 == 0 ||
             (BVar1 = LYCanDoHEAD(links[curdoc.link].lname), BVar1 == '\x01')))) ||
           (((links[curdoc.link].type == 6 && (curdoc.address != (char *)0x0)) &&
            (iVar2 = strncmp(curdoc.address,"http",4), iVar2 == 0)))) {
          if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->disabled != 0)) {
            Msg = (char *)gettext("Sorry, the ACTION for this form is disabled.");
            HTUserMsg(Msg);
          }
          else {
            if (((links[curdoc.link].type != 1) ||
                ((links[curdoc.link].l_form)->submit_action == (char *)0x0)) ||
               ((((*(links[curdoc.link].l_form)->submit_action == 'l' ||
                  (*(links[curdoc.link].l_form)->submit_action == 'L')) &&
                 (iVar2 = strncasecomp((links[curdoc.link].l_form)->submit_action,"lynxcgi:",8),
                 iVar2 == 0)) ||
                (iVar2 = strncmp((links[curdoc.link].l_form)->submit_action,"http",4), iVar2 == 0)))
               ) {
              if ((links[curdoc.link].type == 1) &&
                 ((links[curdoc.link].l_form)->submit_method == 2)) {
                Msg = (char *)gettext(
                                     "Form submit action is POST, HEAD may not be understood.  Proceed?"
                                     );
                BVar1 = HTConfirm(Msg);
                if (BVar1 == '\0') {
                  Msg = (char *)gettext("Cancelled!!!");
                  HTInfoMsg(Msg);
                  return '\0';
                }
              }
              HEAD_request = '\x01';
              LYforce_no_cache = '\x01';
              *cmd = 0x27;
              return '\x01';
            }
            Msg = (char *)gettext("Sorry, the ACTION for this form is not an http URL.");
            HTUserMsg(Msg);
          }
        }
        else {
          Msg = (char *)gettext("Sorry, the link is not an http URL.");
          HTUserMsg(Msg);
        }
      }
    }
  }
  return '\0';
}



void handle_LYK_HELP(char **cshelpfile)

{
  int iVar1;
  char *src;
  char *my_value;
  
  my_value = (char *)0x0;
  if (*cshelpfile == (char *)0x0) {
    *cshelpfile = helpfile;
  }
  HTSACopy(&my_value,*cshelpfile);
  LYEnsureAbsoluteURL(&my_value,*cshelpfile,0);
  iVar1 = strcmp(curdoc.address,my_value);
  if (iVar1 != 0) {
    set_address(&newdoc,my_value);
    src = (char *)gettext("Help Screen");
    HTSACopy((char **)&newdoc,src);
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
  }
  if (my_value != (char *)0x0) {
    free(my_value);
  }
  *cshelpfile = (char *)0x0;
  return;
}



void handle_LYK_HISTORICAL(void)

{
  BOOLEAN BVar1;
  char *Msg;
  char *local_c;
  char *local_8;
  
  BVar1 = HTcan_reparse_document();
  if (BVar1 == '\0') {
    if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
      BVar1 = confirm_post_resub(curdoc.address,(char *)0x0,0,0);
      if (BVar1 == '\0') {
        Msg = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(Msg);
        goto LAB_08082457;
      }
    }
    HText_setNoCache(HTMainText);
    move_address(&newdoc,&curdoc);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
  }
LAB_08082457:
  historical_comments = historical_comments == '\0';
  if (minimal_comments == '\0') {
    if ((bool)historical_comments) {
      local_8 = (char *)gettext("Historical comment parsing ON (Valid is overridden)!");
    }
    else {
      local_8 = (char *)gettext("Historical comment parsing OFF (Valid is in effect)!");
    }
    HTAlert(local_8);
  }
  else {
    if ((bool)historical_comments) {
      local_c = (char *)gettext("Historical comment parsing ON (Minimal is overridden)!");
    }
    else {
      local_c = (char *)gettext("Historical comment parsing OFF (Minimal is in effect)!");
    }
    HTAlert(local_c);
  }
  reparse_document();
  return;
}



BOOLEAN handle_LYK_HISTORY(BOOLEAN ForcePush)

{
  BOOLEAN BVar1;
  int iVar2;
  char *src;
  
  if ((curdoc.title == (char *)0x0) ||
     (BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,1), BVar1 != '\0')) {
    return '\0';
  }
  if ((WWW_TraceFlag != '\0') && ((LYUseTraceLog == '\0' && (LYCursesON != '\0')))) {
    LYmove(LYlines + -1,(LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
    LYrefresh();
  }
  LYpush(&curdoc,ForcePush);
  iVar2 = showhistory(&newdoc.address);
  if (iVar2 < 0) {
    LYpop(&curdoc);
    return '\x01';
  }
  LYRegisterUIPage(newdoc.address,UIP_HISTORY);
  src = (char *)gettext("History Page");
  HTSACopy((char **)&newdoc,src);
  LYFreePostData(&newdoc);
  if (newdoc.bookmark != (char *)0x0) {
    free(newdoc.bookmark);
    newdoc.bookmark = (char *)0x0;
  }
  newdoc.isHEAD = '\0';
  newdoc.safe = '\0';
  newdoc.internal_link = '\0';
  newdoc.link = 1;
  free_address(&curdoc);
  if ((LYValidate != '\0') || (check_realm != '\0')) {
    LYPermitURL = '\x01';
  }
  return '\x01';
}



BOOLEAN handle_LYK_IMAGE_TOGGLE(int *cmd)

{
  BOOLEAN BVar1;
  char *local_8;
  
  clickable_images = clickable_images == '\0';
  if ((bool)clickable_images) {
    local_8 = (char *)gettext("Links will be included for all images!  Reloading...");
  }
  else {
    local_8 = (char *)gettext("Standard image handling restored!  Reloading...");
  }
  HTUserMsg(local_8);
  BVar1 = reparse_or_reload(cmd);
  return BVar1;
}



void handle_LYK_INDEX(int *old_c,int real_c)

{
  int iVar1;
  char *src;
  
  iVar1 = strcmp(curdoc.address,indexfile);
  if (iVar1 != 0) {
    if (*indexfile == '\0') {
      if (*old_c != real_c) {
        *old_c = real_c;
        src = (char *)gettext("No index is currently available.");
        HTUserMsg(src);
      }
    }
    else {
      set_address(&newdoc,indexfile);
      src = (char *)gettext("System Index");
      HTSACopy((char **)&newdoc,src);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
    }
  }
  return;
}



void handle_LYK_INDEX_SEARCH(BOOLEAN *force_load,BOOLEAN ForcePush,int *old_c,int real_c)

{
  int iVar1;
  char *Msg2;
  char *Msg;
  int local_1c;
  char *local_18;
  int local_14;
  char *local_10;
  
  if (is_www_index == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext(
                           "Not a searchable indexed document -- press \'/\' to search for a text string"
                           );
      HTUserMsg(Msg);
    }
  }
  else {
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    iVar1 = do_www_search(&newdoc);
    Msg = use_this_url_instead;
    if (iVar1 == 1) {
      if (((WWW_TraceFlag != '\0') && (LYUseTraceLog == '\0')) && (LYCursesON != '\0')) {
        LYmove(LYlines + -1,(LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
        LYrefresh();
      }
      LYpush(&curdoc,ForcePush);
      copy_address(&curdoc,&newdoc);
      if (curdoc.post_data == (bstring *)0x0) {
        local_1c = 0;
        local_18 = (char *)0x0;
      }
      else {
        local_1c = (curdoc.post_data)->len;
        local_18 = (curdoc.post_data)->str;
      }
      HTSABCopy(&newdoc.post_data,local_18,local_1c);
      HTSACopy(&newdoc.post_content_type,curdoc.post_content_type);
      newdoc.internal_link = '\0';
      curdoc.line = -1;
      Newline = 0;
    }
    else {
      if (use_this_url_instead == (char *)0x0) {
        copy_address(&newdoc,&curdoc);
        if (curdoc.post_data == (bstring *)0x0) {
          local_14 = 0;
          local_10 = (char *)0x0;
        }
        else {
          local_14 = (curdoc.post_data)->len;
          local_10 = (curdoc.post_data)->str;
        }
        HTSABCopy(&newdoc.post_data,local_10,local_14);
        HTSACopy(&newdoc.post_content_type,curdoc.post_content_type);
        HTSACopy(&newdoc.bookmark,curdoc.bookmark);
        newdoc.isHEAD = curdoc.isHEAD;
        newdoc.safe = curdoc.safe;
        newdoc.internal_link = curdoc.internal_link;
      }
      else {
        Msg2 = (char *)gettext("Using %s");
        HTUserMsg2(Msg2,Msg);
        HTSACopy((char **)&newdoc,"A URL specified by redirection");
        set_address(&newdoc,use_this_url_instead);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        if (use_this_url_instead != (char *)0x0) {
          free(use_this_url_instead);
          use_this_url_instead = (char *)0x0;
        }
        *force_load = '\x01';
      }
    }
  }
  return;
}



BOOLEAN handle_LYK_INFO(int *cmd)

{
  BOOLEAN BVar1;
  int iVar2;
  char *src;
  BOOLEAN local_5;
  
  BVar1 = LYIsUIPage3(curdoc.address,UIP_SHOWINFO,1);
  if (BVar1 == '\0') {
    iVar2 = do_change_link();
    if (iVar2 != -1) {
      iVar2 = LYShowInfo(&curdoc,&newdoc,owner_address);
      if (-1 < iVar2) {
        LYRegisterUIPage(newdoc.address,UIP_SHOWINFO);
        src = (char *)gettext("Information about the current document");
        HTSACopy((char **)&newdoc,src);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        LYforce_no_cache = '\x01';
        if ((LYValidate != '\0') || (check_realm != '\0')) {
          LYPermitURL = '\x01';
        }
      }
    }
    local_5 = '\0';
  }
  else {
    *cmd = 0x25;
    local_5 = '\x01';
  }
  return local_5;
}



BOOLEAN handle_LYK_INLINE_TOGGLE(int *cmd)

{
  BOOLEAN BVar1;
  char *local_8;
  
  pseudo_inline_alts = pseudo_inline_alts == '\0';
  if ((bool)pseudo_inline_alts) {
    local_8 = (char *)gettext(
                             "Pseudo_ALTs will be inserted for inlines without ALT strings!  Reloading..."
                             );
  }
  else {
    local_8 = (char *)gettext(
                             "Inlines without an ALT string specified will be ignored!  Reloading..."
                             );
  }
  HTUserMsg(local_8);
  BVar1 = reparse_or_reload(cmd);
  return BVar1;
}



void handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  char *Msg;
  int n;
  
  if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
    if ((((no_file_url == '\0') && (no_goto_file == '\0')) && (HTDirAccess != 0)) &&
       (HTDirAccess != 1)) {
      HText_InsertFile(links + curdoc.link);
      *refresh_screen = '\x01';
    }
    else {
      if (*old_c != real_c) {
        *old_c = real_c;
        if (no_goto_file == '\0') {
          Msg = (char *)gettext("Access to local files denied.");
          HTUserMsg(Msg);
        }
        else {
          Msg = (char *)gettext("You are not allowed to goto \"%s\" URLs");
          HTUserMsg2(Msg,"file:");
        }
        Msg = (char *)gettext("File insert cancelled!!!");
        HTInfoMsg(Msg);
      }
    }
  }
  else {
    Msg = (char *)gettext("Not in a TEXTAREA; cannot use command.");
    HTInfoMsg(Msg);
  }
  return;
}



BOOLEAN handle_LYK_JUMP(int c,char *user_input_buffer,char **old_user_input,RecallType *recall,
                       BOOLEAN *FirstURLRecall,int *URLNum,int *URLTotal,int *ch,int *old_c,
                       int real_c)

{
  BOOLEAN BVar1;
  char *aName;
  char *ret;
  
  if ((no_jump == '\0') && (JThead != (JumpTable *)0x0)) {
    LYJumpFileURL = '\x01';
    aName = LYJump(c);
    if (aName == (char *)0x0) {
      LYJumpFileURL = '\0';
    }
    else {
      aName = HTParse(aName,startfile,0x1f);
      BVar1 = LYTrimStartfile(aName);
      if (BVar1 == '\0') {
        LYRemoveBlanks(user_input_buffer);
      }
      set_address(&newdoc,aName);
      HTSACopy(&lynxjumpfile,aName);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if (aName != (char *)0x0) {
        free(aName);
      }
      LYUserSpecifiedURL = '\x01';
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      if (no_jump == '\0') {
        aName = (char *)gettext("No jump file is currently available.");
        HTUserMsg(aName);
      }
      else {
        aName = (char *)gettext("Jumping to a shortcut URL is disallowed!");
        HTUserMsg(aName);
      }
    }
  }
  return '\0';
}



void handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag,BOOLEAN *emacs_keys_flag,int *old_c,int real_c)

{
  char *src;
  
  if (*old_c != real_c) {
    *old_c = real_c;
    set_address(&newdoc,"LYNXKEYMAP:");
    src = (char *)gettext("Current Key Map");
    HTSACopy((char **)&newdoc,src);
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
    if ((*vi_keys_flag != vi_keys) || (*emacs_keys_flag != emacs_keys)) {
      *vi_keys_flag = vi_keys;
      *emacs_keys_flag = emacs_keys;
    }
    if (no_dired_support == '\0') {
      prev_lynx_edit_mode = lynx_edit_mode;
    }
    LYforce_no_cache = '\x01';
  }
  return;
}



void handle_LYK_LAST_LINK(void)

{
  int iVar1;
  int i;
  
  i = curdoc.link;
  iVar1 = i;
  do {
    i = iVar1;
    iVar1 = i + 1;
    if (nlinks <= iVar1) break;
  } while (links[iVar1].ly == links[curdoc.link].ly);
  set_curdoc_link(i);
  return;
}



void handle_LYK_LEFT_LINK(void)

{
  if ((0 < curdoc.link) && (links[curdoc.link].ly == links[curdoc.link + -1].ly)) {
    set_curdoc_link(curdoc.link + -1);
  }
  return;
}



BOOLEAN handle_LYK_LIST(int *cmd)

{
  BOOLEAN BVar1;
  char *__s2;
  int iVar2;
  char *local_c;
  
  __s2 = (char *)gettext("List Page");
  if (curdoc.title == (char *)0x0) {
    local_c = "";
  }
  else {
    local_c = curdoc.title;
  }
  iVar2 = strcmp(local_c,__s2);
  if ((iVar2 == 0) && (BVar1 = LYIsUIPage3(curdoc.address,UIP_LIST_PAGE,1), BVar1 != '\0')) {
    *cmd = 0x25;
    return '\x01';
  }
  iVar2 = showlist(&newdoc,'\x01');
  if (-1 < iVar2) {
    __s2 = (char *)gettext("List Page");
    HTSACopy((char **)&newdoc,__s2);
    if ((LYValidate != '\0') || (check_realm != '\0')) {
      LYPermitURL = '\x01';
      HTSACopy(&lynxlistfile,newdoc.address);
    }
  }
  return '\0';
}



void handle_LYK_MAIN_MENU(int *old_c,int real_c)

{
  int iVar1;
  char *Msg;
  
  iVar1 = strcmp(curdoc.address,homepage);
  if (iVar1 == 0) {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at main screen!");
      HTUserMsg(Msg);
    }
  }
  else {
    Msg = (char *)gettext("Do you really want to go to the Main screen?");
    iVar1 = HTConfirmDefault(Msg,0);
    if (iVar1 == 1) {
      set_address(&newdoc,homepage);
      Msg = (char *)gettext("Entry into main screen");
      HTSACopy((char **)&newdoc,Msg);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      LYhighlight(0,curdoc.link,prev_target);
      if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
        HTuncache_current_document();
      }
    }
  }
  return;
}



void handle_LYK_MINIMAL(void)

{
  BOOLEAN BVar1;
  char *Msg;
  char *local_c;
  char *local_8;
  
  if (historical_comments == '\0') {
    BVar1 = HTcan_reparse_document();
    if (BVar1 == '\0') {
      if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
        BVar1 = confirm_post_resub(curdoc.address,(char *)0x0,0,0);
        if (BVar1 == '\0') {
          Msg = (char *)gettext("Document will not be reloaded!");
          HTInfoMsg(Msg);
          goto LAB_080832a6;
        }
      }
      HText_setNoCache(HTMainText);
      move_address(&newdoc,&curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
    }
  }
LAB_080832a6:
  minimal_comments = minimal_comments == '\0';
  if (historical_comments == '\0') {
    if ((bool)minimal_comments) {
      local_c = (char *)gettext("Minimal comment parsing ON (and in effect)!");
    }
    else {
      local_c = (char *)gettext("Minimal comment parsing OFF (Valid is in effect)!");
    }
    HTAlert(local_c);
  }
  else {
    if ((bool)minimal_comments) {
      local_8 = (char *)gettext("Minimal comment parsing ON (but Historical is in effect)!");
    }
    else {
      local_8 = (char *)gettext("Minimal comment parsing OFF (Historical is in effect)!");
    }
    HTAlert(local_8);
  }
  reparse_document();
  return;
}



void handle_LYK_MODIFY(BOOLEAN *refresh_screen)

{
  int iVar1;
  int ret;
  
  if (((lynx_edit_mode != '\0') && (0 < nlinks)) && (no_dired_support == '\0')) {
    iVar1 = local_modify(&curdoc,&newdoc.address);
    if (iVar1 == -99) {
      *refresh_screen = '\x01';
    }
    else {
      if (iVar1 != 0) {
        if (0 < LYAutoUncacheDirLists) {
          HTuncache_current_document();
        }
        move_address(&newdoc,&curdoc);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        newdoc.line = curdoc.line;
        newdoc.link = curdoc.link;
        LYclear();
      }
    }
  }
  return;
}



BOOLEAN handle_LYK_NESTED_TABLES(int *cmd)

{
  BOOLEAN BVar1;
  char *local_8;
  
  nested_tables = nested_tables == '\0';
  if ((bool)nested_tables) {
    local_8 = (char *)gettext("Parsing nested-tables toggled ON!  Reloading...");
  }
  else {
    local_8 = (char *)gettext("Parsing nested-tables toggled OFF!  Reloading...");
  }
  HTUserMsg(local_8);
  BVar1 = reparse_or_reload(cmd);
  return BVar1;
}



BOOLEAN handle_LYK_OPTIONS(int *cmd,BOOLEAN *refresh_screen)

{
  bool bVar1;
  BOOLEAN BVar2;
  BOOLEAN BVar3;
  int iVar4;
  BOOLEAN BVar5;
  char cVar6;
  char cVar7;
  BOOLEAN BVar8;
  int iVar9;
  int iVar10;
  char *Msg;
  char *local_50;
  char *local_4c;
  char *local_48;
  char *local_44;
  char *local_40;
  char *local_3c;
  char *local_38;
  char *local_34;
  char *local_30;
  char *CurrentNegoCharset;
  char *CurrentNegoLanguage;
  char *CurrentUserAgent;
  int HTfileSortMethod_flag;
  int CurrentCharSet_flag;
  int CurrentAssumeCharSet_flag;
  BOOLEAN canreparse_post;
  BOOLEAN user_mode_flag;
  BOOLEAN show_dotfiles_flag;
  BOOLEAN keypad_mode_flag;
  BOOLEAN verbose_img_flag;
  BOOLEAN LYSelectPopups_flag;
  BOOLEAN LYUseDefaultRawMode_flag;
  
  iVar9 = HTfileSortMethod;
  BVar5 = show_dotfiles;
  iVar4 = UCLYhndl_for_unspec;
  iVar10 = current_char_set;
  BVar3 = LYUseDefaultRawMode;
  BVar2 = LYSelectPopups;
  BVar8 = verbose_img;
  if (LYUseFormsOptions != '\0') {
    BVar8 = LYIsUIPage3(curdoc.address,UIP_OPTIONS_MENU,1);
    if (BVar8 == '\0') {
      set_address(&newdoc,"LYNXOPTIONS:/");
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      if ((LYValidate != '\0') || (check_realm != '\0')) {
        LYPermitURL = '\x01';
      }
      LYforce_no_cache = '\x01';
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      return '\0';
    }
    *cmd = 0x25;
    return '\x01';
  }
  cVar6 = (char)keypad_mode;
  cVar7 = (char)user_mode;
  CurrentUserAgent = (char *)0x0;
  CurrentNegoLanguage = (char *)0x0;
  CurrentNegoCharset = (char *)0x0;
  if (LYUserAgent == (char *)0x0) {
    local_50 = "";
  }
  else {
    local_50 = LYUserAgent;
  }
  HTSACopy(&CurrentUserAgent,local_50);
  if (language == (char *)0x0) {
    local_4c = "";
  }
  else {
    local_4c = language;
  }
  HTSACopy(&CurrentNegoLanguage,local_4c);
  if (pref_charset == (char *)0x0) {
    local_48 = "";
  }
  else {
    local_48 = pref_charset;
  }
  HTSACopy(&CurrentNegoCharset,local_48);
  LYoptions();
  if (((((int)cVar6 == keypad_mode) &&
       (((int)cVar7 == user_mode || ((cVar7 != '\0' && (user_mode != 0)))))) &&
      (((iVar9 == HTfileSortMethod && (BVar5 == show_dotfiles)) ||
       ((((*curdoc.address != 'f' && (*curdoc.address != 'F')) ||
         (iVar9 = strncasecomp(curdoc.address,"file:",5), iVar9 != 0)) &&
        (iVar9 = strncasecomp(curdoc.address,"ftp:",4), iVar9 != 0)))))) &&
     (((iVar10 == current_char_set && (iVar4 == UCLYhndl_for_unspec)) &&
      ((BVar8 == verbose_img && ((BVar3 == LYUseDefaultRawMode && (BVar2 == LYSelectPopups)))))))) {
    if (LYUserAgent == (char *)0x0) {
      local_44 = "";
    }
    else {
      local_44 = LYUserAgent;
    }
    iVar10 = strcmp(CurrentUserAgent,local_44);
    if (iVar10 == 0) {
      if (language == (char *)0x0) {
        local_40 = "";
      }
      else {
        local_40 = language;
      }
      iVar10 = strcmp(CurrentNegoLanguage,local_40);
      if (iVar10 == 0) {
        if (pref_charset == (char *)0x0) {
          local_3c = "";
        }
        else {
          local_3c = pref_charset;
        }
        iVar10 = strcmp(CurrentNegoCharset,local_3c);
        if (iVar10 == 0) goto LAB_08083a3e;
      }
    }
    iVar10 = strncmp(curdoc.address,"http",4);
    if ((iVar10 != 0) &&
       (((*curdoc.address != 'l' && (*curdoc.address != 'L')) ||
        (iVar10 = strncasecomp(curdoc.address,"lynxcgi:",8), iVar10 != 0)))) goto LAB_08083a3e;
  }
  canreparse_post = '\0';
  if (((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) &&
     ((canreparse_post = HTcan_reparse_document(), canreparse_post == '\0' &&
      (BVar8 = confirm_post_resub(curdoc.address,curdoc.title,2,1), BVar8 == '\0')))) {
    Msg = (char *)gettext("Document will not be reloaded!");
    HTInfoMsg(Msg);
    goto LAB_08083a3e;
  }
  copy_address(&newdoc,&curdoc);
  if (LYUserAgent == (char *)0x0) {
    local_38 = "";
  }
  else {
    local_38 = LYUserAgent;
  }
  iVar10 = strcmp(CurrentUserAgent,local_38);
  if (iVar10 == 0) {
    if (language == (char *)0x0) {
      local_34 = "";
    }
    else {
      local_34 = language;
    }
    iVar10 = strcmp(CurrentNegoLanguage,local_34);
    if (iVar10 != 0) goto LAB_0808386e;
    if (pref_charset == (char *)0x0) {
      local_30 = "";
    }
    else {
      local_30 = pref_charset;
    }
    iVar10 = strcmp(CurrentNegoCharset,local_30);
    if (iVar10 != 0) goto LAB_0808386e;
  }
  else {
LAB_0808386e:
    iVar10 = strncmp(curdoc.address,"http",4);
    if (iVar10 != 0) {
      if (((*curdoc.address == 'l') || (*curdoc.address == 'L')) &&
         (iVar10 = strncasecomp(curdoc.address,"lynxcgi:",8), iVar10 == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (bVar1) goto LAB_080838e5;
    }
    reloading = '\x01';
  }
LAB_080838e5:
  iVar10 = HTisDocumentSource();
  if (iVar10 != 0) {
    srcmode_for_next_retrieval(1);
  }
  if ((reloading == '\0') && (BVar8 = reparse_document(), BVar8 != '\0')) {
    if (CurrentUserAgent != (char *)0x0) {
      free(CurrentUserAgent);
      CurrentUserAgent = (char *)0x0;
    }
    if (CurrentNegoLanguage != (char *)0x0) {
      free(CurrentNegoLanguage);
      CurrentNegoLanguage = (char *)0x0;
    }
    if (CurrentNegoCharset != (char *)0x0) {
      free(CurrentNegoCharset);
    }
    return '\0';
  }
  if ((canreparse_post != '\0') &&
     (BVar8 = confirm_post_resub(curdoc.address,curdoc.title,2,1), BVar8 == '\0')) {
    iVar10 = HTisDocumentSource();
    if (iVar10 != 0) {
      srcmode_for_next_retrieval(0);
    }
    if (CurrentUserAgent != (char *)0x0) {
      free(CurrentUserAgent);
      CurrentUserAgent = (char *)0x0;
    }
    if (CurrentNegoLanguage != (char *)0x0) {
      free(CurrentNegoLanguage);
      CurrentNegoLanguage = (char *)0x0;
    }
    if (CurrentNegoCharset != (char *)0x0) {
      free(CurrentNegoCharset);
    }
    return '\0';
  }
  HEAD_request = HTLoadedDocumentIsHEAD();
  HText_setNoCache(HTMainText);
  newdoc.line = curdoc.line;
  newdoc.link = curdoc.link;
  LYforce_no_cache = '\x01';
  free_address(&curdoc);
LAB_08083a3e:
  if (CurrentUserAgent != (char *)0x0) {
    free(CurrentUserAgent);
    CurrentUserAgent = (char *)0x0;
  }
  if (CurrentNegoLanguage != (char *)0x0) {
    free(CurrentNegoLanguage);
    CurrentNegoLanguage = (char *)0x0;
  }
  if (CurrentNegoCharset != (char *)0x0) {
    free(CurrentNegoCharset);
  }
  *refresh_screen = '\x01';
  return '\0';
}



void handle_NEXT_DOC(void)

{
  int iVar1;
  char *Msg;
  
  iVar1 = LYhist_next(&curdoc,&newdoc);
  if (iVar1 == 0) {
    Msg = (char *)gettext("No next document present");
    HTUserMsg(Msg);
  }
  else {
    free_address(&curdoc);
  }
  return;
}



void handle_LYK_NEXT_LINK(int c,int *old_c,int real_c)

{
  int iVar1;
  int iVar2;
  char *Msg;
  char *thisname;
  int thisgroup;
  
  if (curdoc.link < nlinks + -1) {
    LYhighlight(0,curdoc.link,prev_target);
    if (((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) && (c == 9)) {
      iVar1 = (links[curdoc.link].l_form)->number;
      Msg = (links[curdoc.link].l_form)->name;
      while ((curdoc.link = curdoc.link + 1, curdoc.link < nlinks + -1 &&
             (links[curdoc.link].type == 1))) {
        if ((links[curdoc.link].l_form)->type != 9) {
          return;
        }
        if ((links[curdoc.link].l_form)->number != iVar1) {
          return;
        }
        iVar2 = sametext((links[curdoc.link].l_form)->name,Msg);
        if (iVar2 == 0) {
          return;
        }
      }
    }
    else {
      curdoc.link = curdoc.link + 1;
    }
  }
  else {
    if (((more_text == '\0') && (Newline == 1)) && (curdoc.link == nlinks + -1)) {
      set_curdoc_link(0);
    }
    else {
      if (more_text == '\0') {
        if (*old_c != real_c) {
          *old_c = real_c;
          Msg = (char *)gettext("You are already at the end of this document.");
          HTInfoMsg(Msg);
        }
      }
      else {
        Newline = Newline + display_lines;
      }
    }
  }
  return;
}



void handle_LYK_NEXT_PAGE(int *old_c,int real_c)

{
  char *Msg;
  
  if (more_text == '\0') {
    if (curdoc.link < nlinks + -1) {
      set_curdoc_link(nlinks + -1);
    }
    else {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are already at the end of this document.");
        HTInfoMsg(Msg);
      }
    }
  }
  else {
    Newline = Newline + display_lines;
  }
  return;
}



BOOLEAN handle_LYK_NOCACHE(int *old_c,int real_c)

{
  char *Msg;
  
  if (0 < nlinks) {
    if ((((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type != 5)) &&
        ((links[curdoc.link].l_form)->type != 0xd)) && ((links[curdoc.link].l_form)->type != 0xc)) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are not on a form submission button or normal link.");
        HTUserMsg(Msg);
      }
      return '\0';
    }
    LYforce_no_cache = '\x01';
    reloading = '\x01';
  }
  return '\x01';
}



void handle_LYK_PREV_LINK(int *arrowup,int *old_c,int real_c)

{
  char *Msg;
  int local_18;
  int scrollamount;
  
  if (curdoc.link < 1) {
    if (((more_text == '\0') && (curdoc.link == 0)) && (Newline == 1)) {
      set_curdoc_link(nlinks + -1);
    }
    else {
      if (curdoc.line < 2) {
        if (*old_c != real_c) {
          *old_c = real_c;
          Msg = (char *)gettext("You are already at the beginning of this document.");
          HTInfoMsg(Msg);
        }
      }
      else {
        if (display_lines < Newline) {
          local_18 = display_lines;
        }
        else {
          local_18 = Newline + -1;
        }
        Newline = Newline - local_18;
        if (((local_18 < display_lines) && (0 < nlinks)) &&
           ((curdoc.link == 0 && (links[0].ly + -1 + local_18 <= display_lines)))) {
          newdoc.link = HText_LinksInLines(HTMainText,1,local_18);
          newdoc.link = newdoc.link + -1;
        }
        else {
          *arrowup = 1;
        }
      }
    }
  }
  else {
    set_curdoc_link(curdoc.link + -1);
  }
  return;
}



int handle_PREV_DOC(int *cmd,int *old_c,int real_c)

{
  bool bVar1;
  BOOLEAN BVar2;
  HTParentAnchor *me;
  HyperDoc *pHVar3;
  int iVar4;
  char *Msg2;
  char *Msg;
  DocAddress WWWDoc;
  HText *text;
  HTParentAnchor *tmpanchor;
  BOOLEAN first;
  BOOLEAN conf;
  
  if (nhist < 1) {
    if (child_lynx == '\x01') {
      return 1;
    }
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at the first document");
      HTUserMsg(Msg);
    }
  }
  else {
    bVar1 = true;
    HTLastConfirmCancelled();
    while( true ) {
      if ((nhist < 1) || (conf = '\0', history[nhist + -1].hdoc.post_data == (bstring *)0x0))
      goto LAB_08084307;
      WWWDoc.address = history[nhist + -1].hdoc.address;
      WWWDoc.post_data = history[nhist + -1].hdoc.post_data;
      WWWDoc.post_content_type = history[nhist + -1].hdoc.post_content_type;
      WWWDoc.bookmark = history[nhist + -1].hdoc.bookmark;
      WWWDoc.isHEAD = history[nhist + -1].hdoc.isHEAD;
      WWWDoc.safe = history[nhist + -1].hdoc.safe;
      me = HTAnchor_findAddress(&WWWDoc);
      BVar2 = HTAnchor_safe(me);
      if (BVar2 != '\0') goto LAB_08084307;
      pHVar3 = HTAnchor_document(me);
      if (((pHVar3 != (HyperDoc *)0x0) ||
          ((iVar4 = strncasecomp(WWWDoc.address,"LYNXIMGMAP:",0xb), iVar4 != 0 &&
           (conf = confirm_post_resub(WWWDoc.address,history[nhist + -1].hdoc.title,0,0),
           conf != '\0')))) &&
         ((LYresubmit_posts == '\0' ||
          ((conf != '\0' ||
           (((iVar4 = are_different((DocInfo *)(history + nhist + -1),&curdoc), iVar4 == 0 &&
             (iVar4 = are_different((DocInfo *)(history + nhist + -1),&newdoc), iVar4 == 0)) ||
            (BVar2 = confirm_post_resub(WWWDoc.address,history[nhist + -1].hdoc.title,2,2),
            BVar2 != '\0')))))))) break;
      BVar2 = HTLastConfirmCancelled();
      Msg = WWWDoc.address;
      if (BVar2 != '\0') {
        if ((!bVar1) && (curdoc.internal_link != '\0')) {
          free_address(&curdoc);
        }
        *cmd = 0x45;
        return 2;
      }
      if (nhist == 1) {
        Msg = (char *)gettext("Cancelled!!!");
        HTInfoMsg(Msg);
        *old_c = 0;
        *cmd = 0x45;
        return 2;
      }
      Msg2 = (char *)gettext("Skipping %s");
      HTUserMsg2(Msg2,Msg);
      do {
        LYpop(&curdoc);
        if (nhist < 2) break;
        iVar4 = are_different((DocInfo *)(history + nhist + -1),&curdoc);
      } while (iVar4 == 0);
      bVar1 = false;
    }
    if (conf != '\0') {
      LYforce_no_cache = '\x01';
    }
LAB_08084307:
    if (!bVar1) {
      curdoc.internal_link = '\0';
    }
    LYhist_prev_register(&curdoc);
    free_address(&newdoc);
    if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
      HTuncache_current_document();
    }
  }
  return 0;
}



void handle_LYK_PREV_PAGE(int *old_c,int real_c)

{
  char *Msg;
  
  if (Newline < 2) {
    if (curdoc.link < 1) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are already at the beginning of this document.");
        HTInfoMsg(Msg);
      }
    }
    else {
      set_curdoc_link(0);
    }
  }
  else {
    Newline = Newline - display_lines;
  }
  return;
}



void handle_LYK_PRINT(BOOLEAN *ForcePush,int *old_c,int real_c)

{
  BOOLEAN BVar1;
  int lines_in_file;
  char *src;
  
  if (LYValidate == '\0') {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,1);
    if (BVar1 == '\0') {
      lines_in_file = HText_getNumOfLines();
      lines_in_file = print_options(&newdoc.address,curdoc.address,lines_in_file);
      if (-1 < lines_in_file) {
        LYRegisterUIPage(newdoc.address,UIP_PRINT_OPTIONS);
        src = (char *)gettext("Printing Options");
        HTSACopy((char **)&newdoc,src);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        *ForcePush = '\x01';
        if (check_realm != '\0') {
          LYPermitURL = '\x01';
        }
      }
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      src = (char *)gettext("The \'p\'rint command is currently disabled.");
      HTUserMsg(src);
    }
  }
  return;
}



BOOLEAN handle_LYK_QUIT(void)

{
  char *Msg;
  int c;
  
  if (LYQuitDefaultYes == '\x01') {
    Msg = (char *)gettext("Are you sure you want to quit?");
    c = HTConfirmDefault(Msg,1);
  }
  else {
    Msg = (char *)gettext("Are you sure you want to quit?");
    c = HTConfirmDefault(Msg,0);
  }
  if (LYQuitDefaultYes == '\x01') {
    if (c != 0) {
      return '\x01';
    }
    Msg = (char *)gettext("Excellent!!!");
    HTInfoMsg(Msg);
  }
  else {
    if (c == 1) {
      return '\x01';
    }
    Msg = (char *)gettext("Excellent!!!");
    HTInfoMsg(Msg);
  }
  return '\0';
}



BOOLEAN handle_LYK_RAW_TOGGLE(int *cmd)

{
  char *Msg;
  BOOLEAN local_9;
  char *local_8;
  
  Msg = HTLoadedDocumentCharset();
  if (Msg == (char *)0x0) {
    LYUseDefaultRawMode = LYUseDefaultRawMode == '\0';
    if (LYRawMode == '\0') {
      local_8 = (char *)gettext("Raw 8-bit or CJK mode toggled ON!  Reloading...");
    }
    else {
      local_8 = (char *)gettext("Raw 8-bit or CJK mode toggled OFF!  Reloading...");
    }
    HTUserMsg(local_8);
    HTMLSetCharacterHandling(current_char_set);
    local_9 = reparse_or_reload(cmd);
  }
  else {
    Msg = (char *)gettext("charset for this document specified explicitly, sorry...");
    HTUserMsg(Msg);
    local_9 = '\0';
  }
  return local_9;
}



void handle_LYK_RELOAD(int real_cmd)

{
  BOOLEAN BVar1;
  char *Msg;
  int iVar2;
  
  if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
    Msg = (char *)gettext("Document from Form with POST content.  Resubmit?");
    BVar1 = HTConfirm(Msg);
    if (BVar1 == '\0') {
      Msg = (char *)gettext("Cancelled!!!");
      HTInfoMsg(Msg);
      return;
    }
  }
  iVar2 = HTisDocumentSource();
  if (iVar2 != 0) {
    forced_UCLYhdnl = HTMainText_Get_UCLYhndl();
    if (-1 < forced_UCLYhdnl) {
      force_old_UCLYhndl_on_reload = '\x01';
    }
    srcmode_for_next_retrieval(1);
  }
  HEAD_request = HTLoadedDocumentIsHEAD();
  HText_setNoCache(HTMainText);
  newdoc.line = curdoc.line;
  newdoc.link = curdoc.link;
  free_address(&curdoc);
  if (real_cmd == 0xc) {
    reloading = '\x01';
  }
  return;
}



void handle_LYK_REMOVE(BOOLEAN *refresh_screen)

{
  int iVar1;
  int linkno;
  
  iVar1 = curdoc.link;
  if (((lynx_edit_mode != '\0') && (0 < nlinks)) && (no_dired_support == '\0')) {
    local_remove(&curdoc);
    if (LYAutoUncacheDirLists < 1) {
      if (curdoc.link != iVar1) {
        *refresh_screen = '\x01';
      }
    }
    else {
      do_cleanup_after_delete();
    }
  }
  return;
}



void handle_LYK_RIGHT_LINK(void)

{
  if ((curdoc.link < nlinks + -1) && (links[curdoc.link].ly == links[curdoc.link + 1].ly)) {
    set_curdoc_link(curdoc.link + 1);
  }
  return;
}



void handle_LYK_SHELL(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  char *shell;
  undefined4 uVar1;
  char *Msg;
  
  if (no_shell == '\0') {
    stop_curses();
    uVar1 = gettext("Spawning your default shell.  Use \'exit\' to return to Lynx.\n");
    printf("%s\r\n",uVar1);
    if (shell == (char *)0x0) {
      Msg = LYSysShell();
      HTSACopy((char **)0x81aea88,Msg);
    }
    LYSystem(shell);
    start_curses();
    *refresh_screen = '\x01';
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("Spawning is currently disabled.");
      HTUserMsg(Msg);
    }
  }
  return;
}



void handle_LYK_SOFT_DQUOTES(void)

{
  BOOLEAN BVar1;
  char *Msg;
  char *local_8;
  
  BVar1 = HTcan_reparse_document();
  if (BVar1 == '\0') {
    if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
      BVar1 = confirm_post_resub(curdoc.address,(char *)0x0,1,1);
      if (BVar1 == '\0') {
        Msg = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(Msg);
        goto LAB_080848df;
      }
    }
    HText_setNoCache(HTMainText);
    move_address(&newdoc,&curdoc);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
  }
LAB_080848df:
  soft_dquotes = soft_dquotes == '\0';
  if ((bool)soft_dquotes) {
    local_8 = (char *)gettext("Soft double-quote parsing ON!");
  }
  else {
    local_8 = (char *)gettext("Soft double-quote parsing OFF!");
  }
  HTUserMsg(local_8);
  reparse_document();
  return;
}



int wrap_reparse_document(void)

{
  BOOLEAN BVar1;
  int top_lineno_00;
  FILE *__stream;
  int anchor_number_00;
  int iVar2;
  int iVar3;
  int local_34;
  int local_30;
  int top_lineno;
  int new_lineno;
  int new_anchor;
  int old_offset;
  int old_from_top;
  int old_line_num;
  int anchor_number;
  int result;
  
  if ((nlinks < 1) || (curdoc.link < 0)) {
    local_34 = -1;
  }
  else {
    local_34 = links[curdoc.link].anchor_number;
  }
  top_lineno_00 = HText_getAbsLineNumber(HTMainText,local_34);
  anchor_number_00 = curdoc.link;
  old_from_top = (top_lineno_00 - Newline) + 1;
  if ((nlinks < 1) || (curdoc.link < 0)) {
    local_30 = -1;
  }
  else {
    local_30 = links[curdoc.link].sgml_offset;
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"original anchor %d, topline %d, link %d, offset %d\n",local_34,
            top_lineno_00,anchor_number_00,local_30);
  }
  BVar1 = reparse_document();
  if (((int)BVar1 != 0) && (-1 < local_30)) {
    anchor_number_00 = HText_closestAnchor(HTMainText,local_30);
    top_lineno_00 = HText_getAbsLineNumber(HTMainText,anchor_number_00);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"old anchor %d -> new anchor %d\n",local_34,anchor_number_00);
    }
    if (top_lineno_00 - old_from_top < 0) {
      old_from_top = top_lineno_00;
    }
    top_lineno_00 = HText_getPreferredTopLine(HTMainText,top_lineno_00 - old_from_top);
    iVar2 = top_lineno_00 + 1;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"preferred top %d\n",iVar2);
    }
    if (iVar2 == Newline) {
      newdoc.link = curdoc.link;
    }
    else {
      Newline = iVar2;
      newdoc.link = HText_anchorRelativeTo(HTMainText,top_lineno_00,anchor_number_00);
      curdoc.link = newdoc.link;
      if (WWW_TraceFlag != '\0') {
        iVar3 = HText_locateAnchor(HTMainText,anchor_number_00);
        top_lineno_00 = curdoc.link;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"adjusted anchor %d, topline %d, link %d, offset %d\n",
                anchor_number_00,iVar2,top_lineno_00,iVar3);
      }
    }
  }
  return (int)BVar1;
}



void handle_LYK_SOURCE(char **ownerS_address_p)

{
  char cVar1;
  int iVar2;
  char *Msg;
  BOOLEAN canreparse_post;
  
  canreparse_post = '\0';
  if (((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) &&
     (canreparse_post = HTcan_reparse_document(), canreparse_post == '\0')) {
    if (curdoc.isHEAD == '\0') {
      cVar1 = confirm_post_resub(curdoc.address,curdoc.title,1,1);
    }
    else {
      Msg = (char *)gettext("Document from Form with POST content.  Resubmit?");
      cVar1 = HTConfirm(Msg);
    }
    if (cVar1 == '\0') {
      Msg = (char *)gettext("Cancelled!!!");
      HTInfoMsg(Msg);
      return;
    }
  }
  iVar2 = HTisDocumentSource();
  if (iVar2 == 0) {
    Msg = HText_getOwner();
    if (Msg != (char *)0x0) {
      Msg = HText_getOwner();
      HTSACopy(ownerS_address_p,Msg);
    }
    LYUCPushAssumed(HTMainAnchor);
    srcmode_for_next_retrieval(1);
  }
  else {
    srcmode_for_next_retrieval(-1);
  }
  iVar2 = wrap_reparse_document();
  if (iVar2 == 0) {
    if (canreparse_post == '\0') {
      if (curdoc.title != (char *)0x0) {
        HTSACopy((char **)&newdoc,curdoc.title);
      }
      free_address(&curdoc);
      LYforce_no_cache = '\x01';
    }
    else {
      srcmode_for_next_retrieval(0);
      LYUCPopAssumed();
    }
  }
  else {
    HTOutputFormat = (HTFormat)HTAtom_for("www/present");
    if (psrc_view != '\0') {
      HTMark_asSource();
    }
    psrc_view = '\0';
    if (*ownerS_address_p != (char *)0x0) {
      free(*ownerS_address_p);
      *ownerS_address_p = (char *)0x0;
    }
    LYUCPopAssumed();
    HTMLSetCharacterHandling(current_char_set);
  }
  return;
}



void handle_LYK_SWITCH_DTD(void)

{
  BOOLEAN BVar1;
  BOOLEAN BVar2;
  char *Msg;
  int iVar3;
  bool bVar4;
  char *local_18;
  BOOLEAN canreparse;
  
  BVar1 = HTcan_reparse_document();
  if (BVar1 == '\0') {
    if ((curdoc.post_data != (bstring *)0x0) && (curdoc.safe != '\x01')) {
      BVar2 = confirm_post_resub(curdoc.address,(char *)0x0,1,1);
      if (BVar2 == '\0') {
        Msg = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(Msg);
        goto LAB_08084e0c;
      }
    }
    iVar3 = HTisDocumentSource();
    if ((iVar3 != 0) && (LYPreparsedSource != '\0')) {
      srcmode_for_next_retrieval(1);
    }
    HText_setNoCache(HTMainText);
    move_address(&newdoc,&curdoc);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
  }
LAB_08084e0c:
  bVar4 = Old_DTD == 0;
  Old_DTD = ZEXT14(bVar4);
  HTSwitchDTD((uint)!bVar4);
  if (Old_DTD == 0) {
    local_18 = (char *)gettext("Now using SortaSGML parsing of HTML!");
  }
  else {
    local_18 = (char *)gettext("Now using TagSoup parsing of HTML.");
  }
  HTUserMsg(local_18);
  if (BVar1 != '\0') {
    iVar3 = HTisDocumentSource();
    if ((iVar3 != 0) && (LYPreparsedSource != '\0')) {
      srcmode_for_next_retrieval(1);
    }
    BVar1 = reparse_document();
    if (BVar1 == '\0') {
      srcmode_for_next_retrieval(0);
    }
  }
  return;
}



void handle_LYK_TAG_LINK(void)

{
  bool bVar1;
  char *__s1;
  int iVar2;
  char *local_18;
  char *tagname;
  HTList *t1;
  BOOLEAN found;
  
  if (((lynx_edit_mode != '\0') && (0 < nlinks)) && (no_dired_support == '\0')) {
    __s1 = LYGetHiliteStr(curdoc.link,0);
    iVar2 = strcmp(__s1,"..");
    if (iVar2 != 0) {
      if (dir_list_style == 2) {
        __s1 = LYGetHiliteStr(curdoc.link,0);
        iVar2 = strcmp(__s1,"../");
      }
      else {
        __s1 = LYGetHiliteStr(curdoc.link,0);
        iVar2 = strncmp(__s1,"Up to ",6);
      }
      if (iVar2 != 0) {
        bVar1 = false;
        t1 = tagged;
        do {
          if ((t1 == (HTList *)0x0) || (t1 = t1->next, t1 == (HTList *)0x0)) {
            local_18 = (char *)0x0;
          }
          else {
            local_18 = (char *)t1->object;
          }
          tagname = local_18;
          if (local_18 == (char *)0x0) goto LAB_0808502d;
          iVar2 = strcmp(links[curdoc.link].lname,local_18);
        } while (iVar2 != 0);
        bVar1 = true;
        HTList_removeObject(tagged,tagname);
        if (tagname != (char *)0x0) {
          free(tagname);
          tagname = (char *)0x0;
        }
        tagflag(0,curdoc.link);
LAB_0808502d:
        if (!bVar1) {
          if (tagged == (HTList *)0x0) {
            tagged = HTList_new();
          }
          tagname = (char *)0x0;
          HTSACopy(&tagname,links[curdoc.link].lname);
          HTList_addObject(tagged,tagname);
          tagflag(1,curdoc.link);
        }
        if (curdoc.link < nlinks + -1) {
          set_curdoc_link(curdoc.link + 1);
        }
        else {
          if (((more_text == '\0') && (Newline == 1)) && (curdoc.link == nlinks + -1)) {
            set_curdoc_link(0);
          }
          else {
            if (more_text != '\0') {
              Newline = Newline + display_lines;
            }
          }
        }
      }
    }
  }
  return;
}



void handle_LYK_TOGGLE_HELP(void)

{
  if (user_mode == 0) {
    toggle_novice_line();
    noviceline((int)more_text);
  }
  return;
}



void handle_LYK_TOOLBAR(BOOLEAN *try_internal,BOOLEAN *force_load,int *old_c,int real_c)

{
  BOOLEAN BVar1;
  char *Msg;
  char *toolbar;
  char *cp;
  
  toolbar = (char *)0x0;
  BVar1 = HText_hasToolbar(HTMainText);
  if (BVar1 == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("Document has no Toolbar links or Banner.");
      HTUserMsg(Msg);
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = trimPoundSelector(curdoc.address);
      HTSprintf0(&toolbar,"%s#%s",curdoc.address,LYToolbarName);
      if (Msg != (char *)0x0) {
        *Msg = '#';
      }
      set_address(&newdoc,toolbar);
      if (toolbar != (char *)0x0) {
        free(toolbar);
      }
      *try_internal = '\x01';
      *force_load = '\x01';
    }
  }
  return;
}



void handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)

{
  BOOLEAN BVar1;
  char *src;
  
  if (LYTraceLogFP == (FILE *)0x0) {
    src = (char *)gettext("No trace log has been started for this session.");
    HTUserMsg(src);
  }
  else {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_TRACELOG,1);
    if (BVar1 == '\0') {
      BVar1 = LYReopenTracelog(trace_flag_ptr);
      if (BVar1 != '\0') {
        LYLocalFileToURL(&newdoc.address,LYTraceLogPath);
        LYRegisterUIPage(newdoc.address,UIP_TRACELOG);
        src = (char *)gettext("Lynx Trace Log");
        HTSACopy((char **)&newdoc,src);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        if ((LYValidate != '\0') || (check_realm != '\0')) {
          LYPermitURL = '\x01';
        }
        LYforce_no_cache = '\x01';
      }
    }
  }
  return;
}



void handle_LYK_UPLOAD(void)

{
  BOOLEAN BVar1;
  char *src;
  
  BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,1);
  if (((BVar1 == '\0') && (lynx_edit_mode != '\0')) && (no_dired_support == '\0')) {
    LYUpload_options(&newdoc.address,curdoc.address);
    src = (char *)gettext("Upload Options");
    HTSACopy((char **)&newdoc,src);
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
    if (0 < LYAutoUncacheDirLists) {
      HTuncache_current_document();
    }
  }
  return;
}



void handle_LYK_UP_xxx(int *arrowup,int *old_c,int real_c,int scroll_by)

{
  int iVar1;
  char *Msg;
  
  iVar1 = curdoc.link;
  if (Newline < 2) {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at the beginning of this document.");
      HTInfoMsg(Msg);
    }
  }
  else {
    if (Newline == scroll_by || Newline - scroll_by < 0) {
      scroll_by = Newline + -1;
    }
    Newline = Newline - scroll_by;
    if ((0 < nlinks) && (-1 < curdoc.link)) {
      if (display_lines < links[curdoc.link].ly + scroll_by) {
        *arrowup = 1;
      }
      else {
        newdoc.link = HText_LinksInLines(HTMainText,Newline,scroll_by);
        newdoc.link = iVar1 + newdoc.link;
      }
    }
  }
  return;
}



void handle_LYK_UP_HALF(int *arrowup,int *old_c,int real_c)

{
  handle_LYK_UP_xxx(arrowup,old_c,real_c,display_lines / 2);
  return;
}



void handle_LYK_UP_LINK(int *follow_col,int *arrowup,int *old_c,int real_c)

{
  int nextlink;
  char *Msg;
  size_t sVar1;
  int local_1c;
  int scrollamount;
  char *text;
  int newlink;
  
  if (curdoc.link < 1) {
LAB_0808561c:
    if ((curdoc.line < 2) || (Newline < 2)) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are already at the beginning of this document.");
        HTInfoMsg(Msg);
      }
    }
    else {
      if (display_lines < Newline) {
        local_1c = display_lines;
      }
      else {
        local_1c = Newline + -1;
      }
      Newline = Newline - local_1c;
      if ((((local_1c < display_lines) && (0 < nlinks)) && (-1 < curdoc.link)) &&
         (links[0].ly + -1 + local_1c <= display_lines)) {
        newdoc.link = HText_LinksInLines(HTMainText,1,local_1c);
        newdoc.link = newdoc.link + -1;
      }
      else {
        *arrowup = 1;
      }
    }
  }
  else {
    if (links[0].ly == links[curdoc.link].ly) {
      nextlink = HText_LinksInLines(HTMainText,1,Newline + -1);
      if (nextlink != 0) goto LAB_0808561c;
    }
    if (*follow_col == -1) {
      Msg = LYGetHiliteStr(curdoc.link,0);
      *follow_col = links[curdoc.link].lx;
      if (Msg != (char *)0x0) {
        nextlink = *follow_col;
        sVar1 = strlen(Msg);
        *follow_col = nextlink + (sVar1 >> 1);
      }
    }
    nextlink = find_link_near_col(*follow_col,-1);
    if (nextlink < 0) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("There are no links above this line of the document.");
        HTUserMsg(Msg);
      }
    }
    else {
      set_curdoc_link(nextlink);
    }
  }
  return;
}



void handle_LYK_UP_TWO(int *arrowup,int *old_c,int real_c)

{
  handle_LYK_UP_xxx(arrowup,old_c,real_c,2);
  return;
}



void handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen,int *old_c,int real_c)

{
  char *text;
  int iVar1;
  char *cp;
  
  if (LYValidate == '\0') {
    text = get_bookmark_filename(&newdoc.address);
    if (text == (char *)0x0) {
      if (*old_c != real_c) {
        *old_c = real_c;
        text = (char *)gettext("Unable to open bookmark file, use \'a\' to save a link first");
        LYMBM_statusline(text);
        LYSleepAlert();
        if (LYMultiBookmarks != 0) {
          *refresh_screen = '\x01';
        }
      }
    }
    else {
      if (((*text != '\0') && (iVar1 = strcmp(text," "), iVar1 != 0)) &&
         (iVar1 = strcmp(curdoc.address,newdoc.address), iVar1 != 0)) {
        LYforce_no_cache = '\x01';
        text = (char *)gettext("Bookmark file");
        HTSACopy((char **)&newdoc,text);
        HTSACopy(&newdoc.bookmark,BookmarkPage);
        LYFreePostData(&newdoc);
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        return;
      }
      if (LYMultiBookmarks != 0) {
        *refresh_screen = '\x01';
      }
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      text = (char *)gettext("Bookmark features are currently disabled.");
      HTUserMsg(text);
    }
  }
  return;
}



BOOLEAN handle_LYK_VLINKS(int *cmd,BOOLEAN *newdoc_link_is_absolute)

{
  BOOLEAN BVar1;
  int iVar2;
  char *src;
  BOOLEAN local_15;
  int c;
  
  BVar1 = LYIsUIPage3(curdoc.address,UIP_VLINKS,1);
  if (BVar1 == '\0') {
    iVar2 = LYShowVisitedLinks(&newdoc.address);
    if (iVar2 < 0) {
      src = (char *)gettext("No previously visited links available!");
      HTUserMsg(src);
      local_15 = '\0';
    }
    else {
      src = (char *)gettext("Visited Links Page");
      HTSACopy((char **)&newdoc,src);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if (0 < iVar2) {
        *newdoc_link_is_absolute = '\x01';
        newdoc.link = iVar2 + -1;
      }
      if ((LYValidate != '\0') || (check_realm != '\0')) {
        LYPermitURL = '\x01';
        HTSACopy(&lynxlinksfile,newdoc.address);
      }
      local_15 = '\0';
    }
  }
  else {
    *cmd = 0x25;
    local_15 = '\x01';
  }
  return local_15;
}



void handle_LYK_WHEREIS(int cmd,BOOLEAN *refresh_screen)

{
  BOOLEAN BVar1;
  int iVar2;
  char local_24;
  int local_20;
  int local_1c;
  char *remember_old_target;
  int oldcur;
  BOOLEAN found;
  BOOLEAN have_target_onscreen;
  
  if ((prev_target[0] == '\0') || (BVar1 = HText_pageHasPrevTarget(), BVar1 == '\0')) {
    local_24 = '\0';
  }
  else {
    local_24 = '\x01';
  }
  iVar2 = curdoc.link;
  remember_old_target = (char *)0x0;
  if (local_24 == '\0') {
    HTSACopy(&remember_old_target,"");
  }
  else {
    HTSACopy(&remember_old_target,prev_target);
  }
  if (cmd == 0x33) {
    prev_target[0] = '\0';
    local_20 = 0;
  }
  else {
    if (cmd == 0x35) {
      local_1c = 1;
    }
    else {
      local_1c = -1;
    }
    local_20 = local_1c;
  }
  BVar1 = textsearch(&curdoc,prev_target,0x3ff,local_20);
  if ((www_search_result < 0) || (curdoc.line == www_search_result)) {
    if (BVar1 == '\0') {
      *refresh_screen = local_24;
    }
    else {
      if ((local_24 == '\0') && (BVar1 != '\0')) {
        *refresh_screen = '\x01';
      }
      else {
        if ((((curdoc.line == www_search_result) && (curdoc.link == iVar2)) && (-1 < curdoc.link))
           && ((0 < nlinks && (display_lines / 3 <= links[curdoc.link].ly)))) {
          *refresh_screen = '\x01';
        }
        else {
          if (((case_sensitive != '\0') &&
              (iVar2 = strcmp(prev_target,remember_old_target), iVar2 != 0)) ||
             ((case_sensitive == '\0' &&
              (iVar2 = strcasecomp8(prev_target,remember_old_target), iVar2 != 0)))) {
            *refresh_screen = '\x01';
          }
        }
      }
    }
  }
  else {
    *refresh_screen = '\x01';
  }
  if (remember_old_target != (char *)0x0) {
    free(remember_old_target);
  }
  return;
}



void handle_LYK_digit(int c,BOOLEAN *force_load,char *user_input_buffer,int *old_c,int real_c,
                     BOOLEAN *try_internal)

{
  int iVar1;
  char *__format;
  int iVar2;
  int local_20;
  char *temp;
  int number;
  int lindx;
  
  if (nlinks < 1) {
    local_20 = 0;
  }
  else {
    local_20 = curdoc.link;
  }
  temp = (char *)0x0;
  number = curdoc.line;
  iVar1 = follow_link_number(c,local_20,&newdoc,&number);
  iVar2 = newdoc.line;
  if (iVar1 == 2) {
    Newline = newdoc.line;
    newdoc.line = 1;
    if (((curdoc.line == iVar2) && (0 < nlinks)) && (-1 < curdoc.link)) {
      if (curdoc.link == newdoc.link) {
        HTSACopy(&temp,user_input_buffer);
        iVar2 = number;
        __format = (char *)gettext("Link number %d already is current.");
        sprintf(user_input_buffer,__format,iVar2);
        HTUserMsg(user_input_buffer);
        LYstrncpy(user_input_buffer,temp,0x3ff);
        if (temp != (char *)0x0) {
          free(temp);
        }
      }
      else {
        set_curdoc_link(newdoc.link);
        newdoc.link = 0;
      }
    }
  }
  else {
    if (iVar1 < 3) {
      if (iVar1 == 1) {
        set_address(&newdoc,links[local_20].lname);
        __format = LYGetHiliteStr(local_20,0);
        HTSACopy((char **)&newdoc,__format);
        iVar2 = are_different(&curdoc,&newdoc);
        if (iVar2 != 0) {
          LYFreePostData(&newdoc);
          if (newdoc.bookmark != (char *)0x0) {
            free(newdoc.bookmark);
            newdoc.bookmark = (char *)0x0;
          }
          newdoc.isHEAD = '\0';
          newdoc.safe = '\0';
          iVar2 = strncasecomp(newdoc.address,"LYNXMESSAGES:",0xd);
          if (iVar2 == 0) {
            LYforce_no_cache = '\x01';
          }
        }
        newdoc.internal_link = '\0';
        *force_load = '\x01';
      }
    }
    else {
      if (iVar1 == 3) {
        Newline = newdoc.line;
        newdoc.line = 1;
        if (curdoc.line == iVar2) {
          if (iVar2 < 2) {
            __format = (char *)gettext("You are already at the beginning of this document.");
            HTInfoMsg(__format);
          }
          else {
            if (more_text == '\0') {
              __format = (char *)gettext("You are already at the end of this document.");
              HTInfoMsg(__format);
            }
            else {
              HTSACopy(&temp,user_input_buffer);
              iVar2 = number;
              __format = (char *)gettext("You are already at page %d of this document.");
              sprintf(user_input_buffer,__format,iVar2);
              HTUserMsg(user_input_buffer);
              LYstrncpy(user_input_buffer,temp,0x3ff);
              if (temp != (char *)0x0) {
                free(temp);
              }
            }
          }
        }
      }
      else {
        if (iVar1 == 5) {
          *old_c = real_c;
          __format = (char *)gettext("You have entered an invalid link number.");
          HTUserMsg(__format);
        }
      }
    }
  }
  return;
}



void handle_LYK_CHDIR(void)

{
  int iVar1;
  char buf [256];
  BOOLEAN BVar2;
  int iVar3;
  char *text;
  FILE *__stream;
  int *piVar4;
  int in_GS_OFFSET;
  char *addr;
  char *p;
  char buf2 [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = (char *)0x0;
  if (no_chdir != '\0') {
    text = (char *)gettext("Changing working-directory is currently disabled.");
    HTUserMsg(text);
    goto LAB_080861c9;
  }
  mustshow = '\x01';
  text = (char *)gettext("cd to:");
  statusline(text);
  iVar3 = LYgetstr((char *)0x81aeaa0,0,0xff,NORECALL);
  if ((iVar3 < 0) || (buf[0] == '\0')) {
    text = (char *)gettext("Cancelled!!!");
    HTInfoMsg(text);
    goto LAB_080861c9;
  }
  if ((buf[0] == '~') && ((buf[1] == '/' || (buf[1] == '\0')))) {
    text = Home_Dir();
    HTSprintf0(&p,"%s%s",text,0x81aeaa1);
  }
  else {
    HTSACopy(&p,(char *)0x81aeaa0);
  }
  text = p;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"changing directory to \'%s\'\n",text);
  }
  iVar3 = chdir(p);
  if (iVar3 == 0) {
    if (no_dired_support == '\0') {
      if (lynx_edit_mode == '\0') {
        BVar2 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,1);
        if (BVar2 == '\0') goto LAB_08086193;
      }
      addr = (char *)0x0;
      Current_Dir(buf2);
      LYLocalFileToURL(&addr,buf2);
      newdoc.address = addr;
      newdoc.isHEAD = '\0';
      text = (char *)gettext("A URL specified by the user");
      HTSACopy((char **)&newdoc,text);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
        HTuncache_current_document();
      }
    }
    else {
LAB_08086193:
      text = (char *)gettext("Done!");
      HTInfoMsg(text);
    }
  }
  else {
    piVar4 = __errno_location();
    iVar3 = *piVar4;
    if (iVar3 == 0xd) {
      text = (char *)gettext("Could not access directory.");
      HTInfoMsg(text);
    }
    else {
      if (iVar3 == 0x14) {
        text = (char *)gettext("A component of path is not a directory");
        HTInfoMsg(text);
      }
      else {
        if (iVar3 == 2) {
          text = (char *)gettext("No such directory");
          HTInfoMsg(text);
        }
        else {
          text = (char *)gettext("failed to change directory");
          HTInfoMsg(text);
        }
      }
    }
  }
  if (p != (char *)0x0) {
    free(p);
    p = (char *)0x0;
  }
LAB_080861c9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int repeat_to_delta(int n)

{
  int threshold;
  
  threshold = LYcols / 3;
  while( true ) {
    if (threshold < 1) {
      return n;
    }
    if (threshold <= n) break;
    threshold = (threshold * 2) / 3;
  }
  return threshold;
}



void handle_LYK_SHIFT_LEFT(BOOLEAN *flag,int count)

{
  int iVar1;
  char *Msg;
  
  iVar1 = LYshiftWin;
  if (LYwideLines == 0) {
    Msg = (char *)gettext("Shifting is disabled while line-wrap is in effect");
    HTAlert(Msg);
  }
  else {
    if (0 < LYshiftWin) {
      LYshiftWin = repeat_to_delta(count);
      LYshiftWin = iVar1 - LYshiftWin;
      *flag = '\x01';
    }
    if (LYshiftWin < 0) {
      LYshiftWin = 0;
    }
  }
  return;
}



void handle_LYK_SHIFT_RIGHT(BOOLEAN *flag,int count)

{
  char *Msg;
  int iVar1;
  
  if (LYwideLines == 0) {
    Msg = (char *)gettext("Shifting is disabled while line-wrap is in effect");
    HTAlert(Msg);
  }
  else {
    iVar1 = repeat_to_delta(count);
    LYshiftWin = iVar1 + LYshiftWin;
    *flag = '\x01';
  }
  return;
}



BOOLEAN handle_LYK_LINEWRAP_TOGGLE(int *cmd,BOOLEAN *flag)

{
  int wrap [8];
  char *choices [9];
  int iVar1;
  BOOLEAN local_19;
  char *local_18;
  int c;
  
  if (LYwin == stdscr) {
    local_19 = '\0';
  }
  else {
    iVar1 = popup_choice((uint)(LYwideLines == 0),LYlines / 2 + -2,
                         (int)(LYcols - (uint)(LYShowScrollbar != '\0')) / 2 + -6,
                         (char **)&ram0x081956c0,8,0,'\x01');
    if (term_options == '\0') {
      LYtableCols = ((int *)&ram0x081956a0)[iVar1];
      if (iVar1 == 0) {
        LYshiftWin = 0;
      }
      LYwideLines = iVar1;
      *flag = '\x01';
      if (LYwideLines == 0) {
        local_18 = (char *)gettext("Linewrap ON!");
      }
      else {
        local_18 = (char *)gettext("Linewrap OFF!");
      }
      HTUserMsg(local_18);
      local_19 = reparse_or_reload(cmd);
    }
    else {
      local_19 = '\0';
    }
  }
  return local_19;
}


/*
Unable to decompile 'mainloop'
Cause: Exception while decompiling 0808641f: process: timeout

*/


int are_different(DocInfo *doc1,DocInfo *doc2)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  int local_18;
  char *cp2;
  char *cp1;
  
  if ((doc1->address == (char *)0x0) || (doc2->address == (char *)0x0)) {
    local_18 = 1;
  }
  else {
    if (doc1->isHEAD == doc2->isHEAD) {
      pcVar2 = trimPoundSelector(doc1->address);
      pcVar3 = trimPoundSelector(doc2->address);
      iVar4 = strcmp(doc1->address,doc2->address);
      if (iVar4 == 0) {
        if (pcVar2 != (char *)0x0) {
          *pcVar2 = '#';
        }
        if (pcVar3 != (char *)0x0) {
          *pcVar3 = '#';
        }
        if (doc1->post_data == (bstring *)0x0) {
          if (doc2->post_data != (bstring *)0x0) {
            return 1;
          }
        }
        else {
          if (doc2->post_data == (bstring *)0x0) {
            return 1;
          }
          BVar1 = HTSABEql(doc1->post_data,doc2->post_data);
          if (BVar1 == '\0') {
            return 1;
          }
        }
        local_18 = 0;
      }
      else {
        if (pcVar2 != (char *)0x0) {
          *pcVar2 = '#';
        }
        if (pcVar3 != (char *)0x0) {
          *pcVar3 = '#';
        }
        local_18 = 1;
      }
    }
    else {
      local_18 = 1;
    }
  }
  return local_18;
}



void HTAddGotoURL(char *url)

{
  FILE *__stream;
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *copy;
  
  copy = (char *)0x0;
  if ((url != (char *)0x0) && (*url != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAddGotoURL %s\n",url);
    }
    HTSACopy(&copy,url);
    if (Goto_URLs == (HTList *)0x0) {
      Goto_URLs = HTList_new();
      HTList_addObject(Goto_URLs,copy);
    }
    else {
      cur = Goto_URLs;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) goto LAB_0808afa1;
        iVar1 = strcmp(local_18,copy);
      } while (iVar1 != 0);
      HTList_removeObject(Goto_URLs,local_18);
      if (local_18 != (char *)0x0) {
        free(local_18);
      }
LAB_0808afa1:
      HTList_addObject(Goto_URLs,copy);
    }
  }
  return;
}



void show_main_statusline(LinkInfo curlink,int for_what)

{
  int iVar1;
  int iVar2;
  size_t len;
  char *text;
  char *__format;
  int in_GS_OFFSET;
  char *cp;
  char *indx;
  char buf [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((user_mode == 0) && (for_what != 2)) {
    noviceline((int)more_text);
  }
  iVar2 = HTisDocumentSource();
  if (iVar2 == 0) {
    if (((lynx_mode == '\x02') && (0 < nlinks)) &&
       ((user_mode != 2 || ((curlink & (undefined  [68])0x2) == (undefined  [68])0x0)))) {
      if (curlink.type == 1) {
        show_formlink_statusline((FormInfo *)curlink.l_form,for_what);
      }
      else {
        text = (char *)gettext("(NORMAL LINK)   Use right-arrow or <return> to activate.");
        statusline(text);
      }
      if (is_www_index != '\0') {
        text = (char *)gettext("-index-");
        iVar2 = LYcols - (uint)(LYShowScrollbar != '\0');
        len = strlen(text);
        LYmove(LYlines + -1,iVar2 - len);
        lynx_start_reverse();
        len = strlen(text);
        LYwaddnstr(LYwin,text,len);
        lynx_stop_reverse();
      }
    }
    else {
      if ((user_mode == 2) && (0 < nlinks)) {
        cp = (char *)0x0;
        if (curlink.type == 6) {
          iVar2 = strncasecomp(curlink.lname,"LYNXIMGMAP:",0xb);
          if (iVar2 != 0) {
            cp = strchr(curlink.lname,0x23);
          }
        }
        if (cp == (char *)0x0) {
          cp = curlink.lname;
        }
        status_link(cp,more_text,is_www_index);
      }
      else {
        if ((is_www_index == '\0') || (more_text == '\0')) {
          if (is_www_index == '\0') {
            if (more_text == '\0') {
              mustshow = '\x01';
              text = (char *)gettext(
                                    "Commands: Use arrow keys to move, \'?\' for help, \'q\' to quit, \'<-\' to go back."
                                    );
              statusline(text);
            }
            else {
              if (user_mode == 0) {
                mustshow = '\x01';
                text = (char *)gettext("-- press space for next page --");
                statusline(text);
              }
              else {
                mustshow = '\x01';
                text = (char *)gettext(
                                      "-- press space for more, use arrow keys to move, \'?\' for help, \'q\' to quit."
                                      );
                statusline(text);
              }
            }
          }
          else {
            text = key_for_func(0x32);
            __format = (char *)gettext("This is a searchable index.  Use %s to search.");
            sprintf(buf,__format,text);
            mustshow = '\x01';
            statusline(buf);
          }
        }
        else {
          text = key_for_func(0x32);
          __format = (char *)gettext("--More--  This is a searchable index.  Use %s to search.");
          sprintf(buf,__format,text);
          mustshow = '\x01';
          statusline(buf);
        }
      }
    }
  }
  else {
    mustshow = '\x01';
    text = (char *)gettext(
                          "Currently viewing document source.  Press \'\\\' to return to rendered version."
                          );
    statusline(text);
  }
  if (LYShowCursor == '\0') {
    LYmove(LYlines + -1,(LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void repaint_main_statusline(int for_what)

{
  int iVar1;
  LinkInfo *pLVar2;
  char **ppcVar3;
  LinkInfo in_stack_ffffff94;
  undefined4 local_18;
  LinkInfo *local_14;
  undefined *local_10;
  
  local_10 = &stack0xffffff94;
  if ((-1 < curdoc.link) && (curdoc.link < nlinks)) {
    local_14 = links + curdoc.link;
    local_18 = 0x11;
    iVar1 = 0x11;
    pLVar2 = local_14;
    ppcVar3 = (char **)&stack0xffffff94;
    while (iVar1 != 0) {
      iVar1 = iVar1 + -1;
      *ppcVar3 = pLVar2->lname;
      pLVar2 = (LinkInfo *)&pLVar2->target;
      ppcVar3 = ppcVar3 + 1;
    }
    show_main_statusline(in_stack_ffffff94,for_what);
  }
  return;
}



void form_noviceline(int disabled)

{
  char *__s;
  size_t len;
  int lkc_first;
  char *erasekey;
  char *temp;
  
  LYmove(LYlines + -2,0);
  LYclrtoeol();
  if (disabled == 0) {
    __s = (char *)gettext(
                         "            Enter text into the field by typing on the keyboard              "
                         );
    len = strlen(__s);
    __s = (char *)gettext(
                         "            Enter text into the field by typing on the keyboard              "
                         );
    LYwaddnstr(LYwin,__s,len);
  }
  LYmove(LYlines + -1,0);
  LYclrtoeol();
  if (disabled == 0) {
    lkc_first = EditBinding(0x15);
    if (lkc_first == 0xc) {
      __s = (char *)gettext(
                           "    Ctrl-U to delete all text in field, [Backspace] to delete a character    "
                           );
      len = strlen(__s);
      __s = (char *)gettext(
                           "    Ctrl-U to delete all text in field, [Backspace] to delete a character    "
                           );
      LYwaddnstr(LYwin,__s,len);
    }
    else {
      lkc_first = EditBinding(0x15);
      if (lkc_first == 0x19) {
        __s = (char *)gettext(
                             "      Ctrl-U to delete text in field, [Backspace] to delete a character    "
                             );
        len = strlen(__s);
        __s = (char *)gettext(
                             "      Ctrl-U to delete text in field, [Backspace] to delete a character    "
                             );
        LYwaddnstr(LYwin,__s,len);
      }
      else {
        temp = (char *)0x0;
        lkc_first = LYKeyForEditAction(0xc);
        erasekey = fmt_keys(lkc_first,-1);
        if (erasekey == (char *)0x0) {
          lkc_first = LYKeyForEditAction(0x19);
          erasekey = fmt_keys(lkc_first,-1);
          if (erasekey != (char *)0x0) {
            __s = (char *)gettext(
                                 "      %s to delete text in field, [Backspace] to delete a character    "
                                 );
            HTSprintf0(&temp,__s,erasekey);
          }
        }
        else {
          __s = (char *)gettext(
                               "    %s to delete all text in field, [Backspace] to delete a character    "
                               );
          HTSprintf0(&temp,__s,erasekey);
        }
        if (temp != (char *)0x0) {
          len = strlen(temp);
          LYwaddnstr(LYwin,temp,len);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (erasekey != (char *)0x0) {
          free(erasekey);
        }
      }
    }
  }
  return;
}



void exit_immediately_with_error_message(int state,BOOLEAN first_file)

{
  char *__needle;
  undefined4 uVar1;
  undefined4 uVar2;
  char **local_4c;
  char *local_30;
  char *local_28;
  char *local_1c;
  char *buf2;
  char *buf;
  
  buf = (char *)0x0;
  buf2 = (char *)0x0;
  if (first_file != '\0') {
    local_4c = &buf2;
    LYstatusline_messages_on_exit(local_4c);
  }
  if (state != 0) goto LAB_0808b66d;
  if (buf2 == (char *)0x0) {
LAB_0808b60f:
    local_30 = startfile;
  }
  else {
    __needle = (char *)gettext("Can\'t Access");
    __needle = strstr(buf2,__needle);
    if (__needle == (char *)0x0) goto LAB_0808b60f;
    local_30 = "";
  }
  uVar1 = gettext("lynx: Can\'t access startfile");
  if (buf2 == (char *)0x0) {
    local_28 = "";
  }
  else {
    local_28 = buf2;
  }
  local_4c = &buf;
  HTSprintf0(local_4c,"%s\n%s %s\n",local_28,uVar1,local_30);
LAB_0808b66d:
  if (state == 3) {
    uVar1 = gettext("      Exiting...");
    uVar2 = gettext("lynx: Start file could not be found or is not text/html or text/plain");
    if (buf2 == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = buf2;
    }
    local_4c = &buf;
    HTSprintf0(local_4c,"%s\n%s\n%s\n",local_1c,uVar2,uVar1);
  }
  if (buf2 != (char *)0x0) {
    local_4c = (char **)buf2;
    free(buf2);
    buf2 = (char *)0x0;
  }
  if (dump_output_immediately == '\0') {
    cleanup((EVP_PKEY_CTX *)local_4c);
  }
  if (dump_output_immediately == '\0') {
    fputs(buf,stdout);
  }
  else {
    fputs(buf,stderr);
  }
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  if (dump_output_immediately == '\0') {
    exit_immediately(1);
  }
  return;
}



void status_link(char *curlink_name,BOOLEAN show_more,BOOLEAN show_indx)

{
  int iVar1;
  char *pcVar2;
  undefined4 uVar3;
  size_t sVar4;
  size_t sVar5;
  FILE *__stream;
  int in_GS_OFFSET;
  int n;
  int cut_to_pos;
  int cut_from_pos;
  char *buf;
  int length;
  int prefix;
  char format [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  prefix = 0;
  format[0] = '\0';
  if ((show_more != '\0') && (nomore == '\0')) {
    uVar3 = gettext("-more-");
    sprintf(format,"%.*s ",0x3fe,uVar3);
    prefix = strlen(format);
  }
  if (show_indx != '\0') {
    uVar3 = gettext("-index-");
    sprintf(format + prefix,"%.*s ",0x3fe - prefix,uVar3);
  }
  sVar4 = strlen(format);
  sVar5 = strlen(curlink_name);
  if (((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) < (int)sVar4) || (0x3fe < (int)sVar4))
  {
    mustshow = '\x01';
    user_message("%s",format);
  }
  else {
    sprintf(format + sVar4,"%%.%ds",((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) - sVar4);
    if (((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) < (int)(sVar5 + sVar4)) &&
       (long_url_ok != '\0')) {
      buf = (char *)0x0;
      HTSACopy(&buf,curlink_name);
      cut_to_pos = sVar5 - 2;
      while ((0 < cut_to_pos && (buf[cut_to_pos] != '/'))) {
        cut_to_pos = cut_to_pos + -1;
      }
      cut_from_pos = cut_to_pos + -4;
      while ((0 < cut_from_pos &&
             ((buf[cut_from_pos] != '/' ||
              ((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) <=
               (int)(sVar4 + cut_from_pos + 4 + (sVar5 - cut_to_pos))))))) {
        cut_from_pos = cut_from_pos + -1;
      }
      if (0 < cut_from_pos) {
        n = 1;
        while (n < 4) {
          buf[cut_from_pos + n] = '.';
          n = n + 1;
        }
        n = 0;
        while (cut_to_pos + n <= (int)sVar5) {
          buf[cut_from_pos + 4 + n] = buf[cut_to_pos + n];
          n = n + 1;
        }
      }
      mustshow = '\x01';
      user_message(format,buf);
      pcVar2 = buf;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"lastline = %s\n",pcVar2);
      }
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
    }
    else {
      mustshow = '\x01';
      user_message(format,curlink_name);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * LYDownLoadAddress(void)

{
  char *local_8;
  
  if (newdoc.address == (char *)0x0) {
    local_8 = "";
  }
  else {
    local_8 = newdoc.address;
  }
  return local_8;
}



int string_to_attr(char *name)

{
  int iVar1;
  uint i;
  
  i = 0;
  while( true ) {
    if (6 < i) {
      return 0;
    }
    iVar1 = strcasecomp(Mono_Attrs[i].name,name);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return Mono_Attrs[i].code;
}



char * attr_to_string(int code)

{
  bool bVar1;
  char result [136];
  uint uVar2;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  size_t sVar7;
  undefined *local_38;
  size_t local_34;
  int local_28;
  char *bg;
  char *fg;
  int bold;
  int pair;
  uint i;
  short b;
  short f;
  
  uVar2 = code & 0xff00;
  uVar3 = uVar2 >> 8;
  if ((uVar3 == 0) || ((code & 0x200000U) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
    code = code & 0xffdfffff;
  }
  result[0] = '\0';
  i = 0;
  while (i < 7) {
    if ((Mono_Attrs[i].code & code) != 0) {
      if (result[0] != '\0') {
        local_34 = 2;
        local_38 = &DAT_08155669;
        sVar7 = strlen((char *)0x81af040);
        memcpy((void *)(sVar7 + 0x81af040),local_38,local_34);
      }
      strcat((char *)0x81af040,Mono_Attrs[i].name);
    }
    i = i + 1;
  }
  if (uVar3 != 0) {
    iVar4 = pair_content((int)(short)(uVar2 >> 8),&f,&b);
    if (iVar4 != -1) {
      if (bVar1) {
        local_28 = f + COLORS;
      }
      else {
        local_28 = (int)f;
      }
      pcVar5 = lookup_color(local_28);
      pcVar6 = lookup_color((int)b);
      if (result[0] != '\0') {
        strcat((char *)0x81af040,"+");
      }
      sVar7 = strlen((char *)0x81af040);
      sprintf((char *)(sVar7 + 0x81af040),"%s/%s",pcVar5,pcVar6);
    }
  }
  return (char *)0x81af040;
}



void LYbox(WINDOW *win,BOOLEAN formfield)

{
  int boxhori;
  int boxvert;
  
  UCSetBoxChars(current_char_set,&boxvert,&boxhori,0,0);
  curses_w_style(win,s_menu_frame,1);
  if ((boxvert == 0) || (boxhori == 0)) {
    wborder(win,boxvert,boxvert,boxhori,boxhori,0,0,0,0);
  }
  else {
    if ((boxvert == 0x2a) || (boxhori == 0x2a)) {
      wborder(win,boxvert,boxvert,boxhori,boxhori,0x2a,0x2a,0x2a,0x2a);
    }
    else {
      wborder(win,boxvert,boxvert,boxhori,boxhori,0x2f,0x5c,0x5c,0x2f);
    }
  }
  curses_w_style(win,s_menu_frame,0);
  wrefresh(win);
  return;
}



void setStyle(int style,int color,int cattr,int mono)

{
  displayStyles[style].color = color;
  displayStyles[style].cattr = cattr;
  displayStyles[style].mono = mono;
  return;
}



void setHashStyle(int style,int color,int cattr,int mono,char *element)

{
  bucket *dest;
  FILE *__stream;
  bucket *ds;
  
  dest = hashStyles + style;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n",element,style,color,mono);
  }
  hashStyles[style].color = color;
  hashStyles[style].cattr = cattr;
  hashStyles[style].mono = mono;
  hashStyles[style].code = style;
  if (dest->name != (char *)0x0) {
    free(dest->name);
    dest->name = (char *)0x0;
  }
  HTSACopy((char **)dest,element);
  return;
}



void LYAttrset(WINDOW *win,int color,int mono)

{
  char *pcVar1;
  FILE *__stream;
  
  if (((lynx_has_color == 0) || (LYShowColor < 2)) || (color < 0)) {
    if (mono < 0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"CSS:LYAttrset (A_NORMAL)\n");
      }
      win->_attrs = 0;
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pcVar1 = attr_to_string(mono);
        __stream = TraceFP();
        fprintf((FILE *)__stream,"CSS:LYAttrset mono %#x -> (%s)\n",mono,pcVar1);
      }
      win->_attrs = mono;
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pcVar1 = attr_to_string(color);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"CSS:LYAttrset color %#x -> (%s)\n",color,pcVar1);
    }
    win->_attrs = color;
  }
  return;
}



void curses_w_style(WINDOW *win,int style,int dir)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  FILE *__stream;
  long lVar4;
  bucket *local_34;
  undefined *local_24;
  int local_20;
  int local_1c;
  int last_attr;
  bucket *ds;
  int XP;
  int YP;
  
  if (style == -1) {
    local_34 = &nostyle_bucket;
  }
  else {
    local_34 = hashStyles + style;
  }
  if (local_34->name == (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"CSS.CS:Style %d not configured\n",style);
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      iVar1 = local_34->color;
      iVar2 = local_34->code;
      pcVar3 = local_34->name;
      if (dir == 0) {
        local_24 = &DAT_0815571d;
      }
      else {
        local_24 = &DAT_0815571c;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"CSS.CS:<%s%s> style %d code %#x, color %#x\n",local_24,pcVar3,style,
              iVar2,iVar1);
    }
    if (win == (WINDOW *)0x0) {
      local_20 = -1;
      local_1c = -1;
    }
    else {
      local_20 = (int)win->_cury;
      local_1c = (int)win->_curx;
    }
    if ((style == s_normal) && (dir != 0)) {
      LYAttrset(win,local_34->color,local_34->mono);
      if (win == LYwin) {
        SetCachedStyle(local_20,local_1c,s_normal);
      }
    }
    else {
      if (dir == 1) {
        if (0x7f < last_colorattr_ptr) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            iVar1 = last_styles[last_colorattr_ptr];
            __stream = TraceFP();
            fprintf((FILE *)__stream,"........... %s (0x%x) %s\r\n",
                    "attribute cache FULL, dropping last",iVar1,"in LynxChangeStyle(curses_w_style)"
                   );
          }
          last_colorattr_ptr = 0x7f;
        }
        iVar1 = last_colorattr_ptr;
        lVar4 = LYgetattrs(win);
        last_styles[iVar1] = lVar4;
        last_colorattr_ptr = iVar1 + 1;
      }
      else {
        if (dir != 2) {
          if (dir != 0) {
            return;
          }
          if (last_colorattr_ptr != 0) {
            last_colorattr_ptr = last_colorattr_ptr + -1;
            LYAttrset(win,last_styles[last_colorattr_ptr],last_styles[last_colorattr_ptr]);
            return;
          }
          LYAttrset(win,0,-1);
          return;
        }
      }
      if (((((style != s_alink) && (style != s_curedit)) && (style != s_aedit)) &&
          ((style != s_aedit_sel && (style != s_aedit_pad)))) && (style != s_aedit_arr)) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          pcVar3 = local_34->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"CACHED: <%s> @(%d,%d)\n",pcVar3,local_20,local_1c);
        }
        if (win == LYwin) {
          SetCachedStyle(local_20,local_1c,style);
        }
      }
      LYAttrset(win,local_34->color,local_34->mono);
    }
  }
  return;
}



void wcurses_css(WINDOW *win,char *name,int dir)

{
  bool bVar1;
  int style;
  FILE *__stream;
  char *pcVar2;
  char *pclass;
  int tmpHash;
  int try_again;
  
  bVar1 = true;
  while (bVar1) {
    style = hash_code(name);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"CSSTRIM:trying to set [%s] style - ",name);
    }
    if (style == -1) {
      pcVar2 = strrchr(name,0x2e);
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"undefined, trimming at %p\n",pcVar2);
      }
      if (pcVar2 == (char *)0x0) {
        bVar1 = false;
      }
      else {
        *pcVar2 = '\0';
      }
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        style = hash_code(name);
        __stream = TraceFP();
        fprintf((FILE *)__stream,"ok (%d)\n",style);
      }
      style = hash_code(name);
      curses_w_style(win,style,dir);
      bVar1 = false;
    }
  }
  return;
}



void curses_css(char *name,int dir)

{
  wcurses_css(LYwin,name,dir);
  return;
}



void curses_style(int style,int dir)

{
  curses_w_style(LYwin,style,dir);
  return;
}



int get_color_pair(int n)

{
  int local_8;
  
  if (((n < 0x19) && (lynx_color_pairs[n].fg == default_fg)) &&
     (lynx_color_pairs[n].bg == default_bg)) {
    local_8 = 0;
  }
  else {
    local_8 = n << 8;
  }
  return local_8;
}



int lynx_color_cfg_attr(int code)

{
  int fg;
  int result;
  
  result = 0;
  if ((((-1 < code) && (code < 8)) && ((int)(COLORS - 1) < lynx_color_cfg[code].fg)) &&
     ((COLORS & lynx_color_cfg[code].fg) != 0)) {
    result = 0x200000;
  }
  return result;
}



int encode_color_attr(int color_attr)

{
  uint uVar1;
  int offs;
  int code;
  int result;
  
  code = ZEXT14((color_attr & 0x200000U) != 0);
  if ((color_attr & 0x140000U) != 0) {
    code = code | 2;
  }
  if ((color_attr & 0x20000U) != 0) {
    code = code | 4;
  }
  result = lynx_color_cfg_attr(code);
  if (code + 1 < COLOR_PAIRS) {
    uVar1 = get_color_pair(code + 1);
    result = result | uVar1;
  }
  return result;
}



int decode_mono_code(int mono_code)

{
  int result;
  
  result = 0;
  if ((mono_code & 1U) != 0) {
    result = 0x200000;
  }
  if ((mono_code & 2U) != 0) {
    result = result | 0x40000;
  }
  if ((mono_code & 4U) != 0) {
    result = result | 0x20000;
  }
  return result;
}



int LYgetTableAttr(void)

{
  int result;
  
  if ((lynx_has_color == 0) || (LYShowColor < 2)) {
    result = Current_Attr;
  }
  else {
    result = encode_color_attr(Current_Attr);
  }
  return ~Masked_Attr & result;
}



char * LYgetTableString(int code)

{
  int code_00;
  uint color_attr;
  uint uVar1;
  uint uVar2;
  FILE *__stream;
  char *src;
  char *result;
  uint n;
  int bg;
  int fg;
  int mono;
  int pair;
  int second;
  int mask;
  
  color_attr = decode_mono_code(code);
  uVar1 = encode_color_attr(color_attr);
  uVar2 = (uVar1 & 0xff00) >> 8;
  fg = lynx_color_pairs[uVar2].fg;
  code_00 = lynx_color_pairs[uVar2].bg;
  result = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYgetTableString(%d)\n",code);
  }
  if ((fg == 0) && (code_00 == 0)) {
    fg = 7;
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"%#x -> %#x (mono %#x pair %d) fg=%d, bg=%d\n",color_attr,uVar1,
            color_attr & 0xffffff00,uVar2,fg,code_00);
  }
  n = 0;
  while (n < 7) {
    if ((Mono_Attrs[n].code & color_attr & 0xffffff00) != 0) {
      if (result != (char *)0x0) {
        HTSACat(&result,"+");
      }
      HTSACat(&result,Mono_Attrs[n].name);
    }
    n = n + 1;
  }
  if (result == (char *)0x0) {
    HTSACopy(&result,"normal");
  }
  HTSACat(&result,":");
  src = lookup_color(fg);
  HTSACat(&result,src);
  if (-1 < code_00) {
    HTSACat(&result,":");
    src = lookup_color(code_00);
    HTSACat(&result,src);
  }
  src = result;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"->%s\n",src);
  }
  return result;
}



void lynx_init_color_pair(int n)

{
  return;
}



void lynx_map_color(int n)

{
  FILE *__stream;
  int j;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lynx_map_color(%d)\n",n);
  }
  if (n + 1 < 0x19) {
    j = n + 1;
    while (j < 0x19) {
      lynx_color_pairs[j].fg = lynx_color_cfg[n].fg;
      lynx_color_pairs[j].bg = lynx_color_cfg[n].bg;
      j = j + 8;
    }
    lynx_color_pairs[n + 9].bg = lynx_color_cfg[0].bg;
  }
  lynx_init_color_pair(n);
  return;
}



int lynx_chg_color(int color,int fg,int bg)

{
  FILE *__stream;
  int local_8;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lynx_chg_color(color=%d, fg=%d, bg=%d)\n",color,fg,bg);
  }
  if ((fg == -3) || (bg == -3)) {
    local_8 = -1;
  }
  else {
    if ((color < 0) || (7 < color)) {
      local_8 = -1;
    }
    else {
      lynx_color_cfg[color].fg = fg;
      lynx_color_cfg[color].bg = bg;
      lynx_map_color(color);
      local_8 = 0;
    }
  }
  return local_8;
}



void lynx_set_color(int a)

{
  WINDOW *pWVar1;
  uint uVar2;
  uint local_8;
  
  pWVar1 = LYwin;
  if ((lynx_has_color != 0) && (1 < LYShowColor)) {
    uVar2 = lynx_color_cfg_attr(a);
    if (a + 1 < COLOR_PAIRS) {
      local_8 = get_color_pair(a + 1);
    }
    else {
      local_8 = 0;
    }
    pWVar1->_attrs = uVar2 | local_8;
  }
  return;
}



void lynx_standout(int flag)

{
  if (flag == 0) {
    wattr_off(LYwin,0x40000,0);
  }
  else {
    wattr_on(LYwin,0x40000,0);
  }
  return;
}



void lynx_init_colors(void)

{
  int iVar1;
  int iVar2;
  FILE *__stream;
  size_t n;
  
  iVar2 = default_bg;
  iVar1 = default_fg;
  if (lynx_has_color == 0) {
    if (LYShowColor != 0) {
      LYShowColor = 1;
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"lynx_init_colors (default %d/%d)\n",iVar1,iVar2);
    }
    lynx_color_cfg[0].fg = default_fg;
    lynx_color_cfg[0].bg = default_bg;
    n = 0;
    while (n < 8) {
      lynx_init_color_pair(n);
      n = n + 1;
    }
  }
  return;
}



void lynx_setup_colors(void)

{
  FILE *__stream;
  int n;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lynx_setup_colors\n");
  }
  if (LYuse_default_colors == '\0') {
    n = 0;
    while (n < 8) {
      if (lynx_color_cfg[n].dft_fg != 0) {
        lynx_color_cfg[n].fg = 0;
      }
      if (lynx_color_cfg[n].dft_bg != 0) {
        lynx_color_cfg[n].bg = 7;
      }
      n = n + 1;
    }
  }
  n = 0;
  while (n < 8) {
    lynx_map_color(n);
    n = n + 1;
  }
  return;
}



void LYnoVideo(int a)

{
  FILE *__stream;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYnoVideo(%d)\n",a);
  }
  Masked_Attr = decode_mono_code(a);
  return;
}



void start_curses(void)

{
  int iVar1;
  bool bVar2;
  char cVar3;
  BOOLEAN BVar4;
  int __fd;
  FILE *__stream;
  undefined4 uVar5;
  uint n;
  int keypad_on;
  BOOLEAN savesize;
  
  bVar2 = false;
  __fd = fileno(stdout);
  __fd = isatty(__fd);
  if (__fd != 0) {
    __fd = LYReopenInput();
    if (__fd < 0) {
      fwrite("Cannot open tty input\n",1,0x16,stderr);
      exit_immediately(1);
    }
  }
  BVar4 = recent_sizechange;
  if (LYscreen == (WINDOW *)0x0) {
    size_change(0);
    recent_sizechange = BVar4;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Screen size: %s()\n","initscr");
    }
    LYscreen = (WINDOW *)initscr();
    if (LYscreen == (WINDOW *)0x0) {
      uVar5 = gettext("Terminal initialisation failed - unknown terminal type?");
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s\n",uVar5);
      exit_immediately(1);
    }
    lynx_called_initscr = '\x01';
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
    size_change(0);
    iVar1 = LYlines;
    __fd = LYcols;
    recent_sizechange = '\0';
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Screen size is now %d x %d\n",iVar1,__fd);
    }
    if (LYuseCursesPads == '\0') {
      LYwin = stdscr;
    }
    else {
      LYwin = (WINDOW *)newpad(LYlines,0x3f6);
      LYshiftWin = 0;
      LYwideLines = 0;
    }
    keypad(LYwin,1);
    bVar2 = true;
    __fd = lynx_initialize_keymaps();
    if (__fd == -1) {
      endwin();
      exit_immediately(1);
    }
    cVar3 = has_colors();
    if (cVar3 != '\0') {
      lynx_has_color = 1;
      start_color();
      if (0x10 < COLORS) {
        COLORS = 0x10;
      }
      if (COLORS < 8) {
        COLORS = 2;
      }
      if ((8 < COLORS) && (COLORS != 0x10)) {
        COLORS = 8;
      }
      if (LYuse_default_colors != '\0') {
        __fd = assume_default_colors(default_fg,default_bg);
        if (__fd != 0) {
          default_fg = 7;
          default_bg = 0;
        }
        iVar1 = default_bg;
        __fd = default_fg;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"initializing default colors %d/%d\n",__fd,iVar1);
        }
        if ((-1 < default_fg) || (-1 < default_bg)) {
          n = 0;
          while (n < 8) {
            if ((-1 < default_fg) && (lynx_color_cfg[n].fg < 0)) {
              lynx_color_cfg[n].fg = default_fg;
            }
            if ((-1 < default_bg) && (lynx_color_cfg[n].bg < 0)) {
              lynx_color_cfg[n].bg = default_bg;
            }
            if (WWW_TraceFlag != '\0') {
              __fd = lynx_color_cfg[n].bg;
              iVar1 = lynx_color_cfg[n].fg;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"color_cfg[%u] = %d/%d\n",n,iVar1,__fd);
            }
            n = n + 1;
          }
          lynx_setup_colors();
        }
      }
    }
    if ((lynx_lss_file != (char *)0x0) && (*lynx_lss_file != '\0')) {
      BVar4 = LYCanReadFile(lynx_lss_file);
      if (BVar4 != '\0') {
        style_readFromFile(lynx_lss_file);
      }
    }
    parse_userstyles();
    lynx_init_colors();
  }
  cbreak();
  signal(2,cleanup_sig);
  noecho();
  if (!bVar2) {
    keypad(LYwin,1);
  }
  lynx_enable_mouse(1);
  fflush(stdin);
  fflush(stdout);
  fflush(stderr);
  LYCursesON = '\x01';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"start_curses: done.\n");
  }
  return;
}



void lynx_enable_mouse(int state)

{
  int was;
  int iVar1;
  int old;
  
  if (LYUseMouse != '\0') {
    if (state == 0) {
      mousemask(0,0);
    }
    else {
      if (was == 0) {
        iVar1 = mouseinterval(0xffffffff);
        was = was + 1;
        if (iVar1 < 200) {
          mouseinterval(300);
        }
      }
      mousemask(0x501f1df,0);
    }
  }
  return;
}



void lynx_nl2crlf(int normal)

{
  int can_fix;
  int waiting;
  int did_save;
  termios saved_tty;
  int __fd;
  
  __fd = cur_term;
  if (did_save == 0) {
    if (cur_term == 0) {
      can_fix = 0;
    }
    else {
      saved_tty.c_iflag = *(tcflag_t *)(cur_term + 0x68);
      saved_tty.c_oflag = *(tcflag_t *)(cur_term + 0x6c);
      saved_tty.c_cflag = *(tcflag_t *)(cur_term + 0x70);
      saved_tty.c_lflag = *(tcflag_t *)(cur_term + 0x74);
      saved_tty._16_4_ = *(undefined4 *)(cur_term + 0x78);
      saved_tty.c_cc._3_4_ = *(undefined4 *)(cur_term + 0x7c);
      saved_tty.c_cc._7_4_ = *(undefined4 *)(cur_term + 0x80);
      saved_tty.c_cc._11_4_ = *(undefined4 *)(cur_term + 0x84);
      saved_tty.c_cc._15_4_ = *(undefined4 *)(cur_term + 0x88);
      saved_tty.c_cc._19_4_ = *(undefined4 *)(cur_term + 0x8c);
      saved_tty.c_cc._23_4_ = *(undefined4 *)(cur_term + 0x90);
      saved_tty.c_cc._27_4_ = *(undefined4 *)(cur_term + 0x94);
      saved_tty._48_4_ = *(undefined4 *)(cur_term + 0x98);
      saved_tty.c_ispeed = *(speed_t *)(cur_term + 0x9c);
      saved_tty.c_ospeed = *(speed_t *)(cur_term + 0xa0);
      did_save = 1;
    }
  }
  if (can_fix != 0) {
    if (normal == 0) {
      if (waiting != 0) {
        *(tcflag_t *)(cur_term + 0x68) = saved_tty.c_iflag;
        *(tcflag_t *)(__fd + 0x6c) = saved_tty.c_oflag;
        *(tcflag_t *)(__fd + 0x70) = saved_tty.c_cflag;
        *(tcflag_t *)(__fd + 0x74) = saved_tty.c_lflag;
        *(undefined4 *)(__fd + 0x78) = saved_tty._16_4_;
        *(undefined4 *)(__fd + 0x7c) = saved_tty.c_cc._3_4_;
        *(undefined4 *)(__fd + 0x80) = saved_tty.c_cc._7_4_;
        *(undefined4 *)(__fd + 0x84) = saved_tty.c_cc._11_4_;
        *(undefined4 *)(__fd + 0x88) = saved_tty.c_cc._15_4_;
        *(undefined4 *)(__fd + 0x8c) = saved_tty.c_cc._19_4_;
        *(undefined4 *)(__fd + 0x90) = saved_tty.c_cc._23_4_;
        *(undefined4 *)(__fd + 0x94) = saved_tty.c_cc._27_4_;
        *(undefined4 *)(__fd + 0x98) = saved_tty._48_4_;
        *(speed_t *)(__fd + 0x9c) = saved_tty.c_ispeed;
        *(speed_t *)(__fd + 0xa0) = saved_tty.c_ospeed;
        __fd = fileno(stdout);
        tcsetattr(__fd,1,(termios *)0x81af0e0);
        waiting = 0;
        nl();
        LYrefresh();
      }
    }
    else {
      if (waiting == 0) {
        *(uint *)(cur_term + 0x6c) = *(uint *)(cur_term + 0x6c) | 4;
        waiting = 1;
        nonl();
      }
    }
  }
  return;
}



void stop_curses(void)

{
  FILE *__stream;
  
  if (LYCursesON != '\0') {
    FreeCachedStyles();
    echo();
  }
  if (LYCursesON == '\x01') {
    lynx_nl2crlf(1);
    lynx_enable_mouse(0);
    if ((LYscreen != (WINDOW *)0x0) || (lynx_called_initscr != '\0')) {
      endwin();
    }
  }
  fflush(stdout);
  fflush(stderr);
  LYCursesON = '\0';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"stop_curses: done.\n");
  }
  signal(2,(__sighandler_t)0x0);
  return;
}



BOOLEAN setup(char *terminal)

{
  char *src;
  int iVar1;
  undefined4 uVar2;
  char *cp;
  char *buffer;
  char *term_putenv;
  
  term_putenv = (char *)0x0;
  buffer = (char *)0x0;
  src = LYgetXDisplay();
  if (src == (char *)0x0) {
    if (x_display != (char *)0x0) {
      free(x_display);
      x_display = (char *)0x0;
    }
  }
  else {
    HTSACopy(&x_display,src);
  }
  if (terminal != (char *)0x0) {
    HTSprintf0(&term_putenv,"TERM=%.106s",terminal);
    putenv(term_putenv);
  }
  src = LYGetEnv("TERM");
  iVar1 = dumbterm(src);
  if (iVar1 != 0) {
    uVar2 = gettext("Your Terminal type is unknown!");
    printf("\n\n  %s\n\n",uVar2);
    uVar2 = gettext("Enter a terminal type:");
    printf("  %s [vt100] ",uVar2);
    src = LYSafeGets(&buffer,stdin);
    if (src != (char *)0x0) {
      LYTrimLeading(buffer);
      LYTrimTrailing(buffer);
    }
    if ((buffer == (char *)0x0) || (*buffer == '\0')) {
      HTSACopy(&buffer,"vt100");
    }
    HTSprintf0(&term_putenv,"TERM=%.106s",buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
      buffer = (char *)0x0;
    }
    putenv(term_putenv);
    src = LYGetEnv("TERM");
    uVar2 = gettext("TERMINAL TYPE IS SET TO");
    printf("\n%s %s\n",uVar2,src);
    LYSleepMsg();
  }
  start_curses();
  iVar1 = strncmp(ttytype,"sun",3);
  if (iVar1 == 0) {
    LYnoVideo(2);
  }
  LYlines = LYscreenHeight();
  LYcols = LYscreenWidth();
  return '\x01';
}



int dumbterm(char *terminal)

{
  int iVar1;
  int dumb;
  
  if ((((terminal != (char *)0x0) && (iVar1 = strcasecomp(terminal,"network"), iVar1 != 0)) &&
      (iVar1 = strcasecomp(terminal,"unknown"), iVar1 != 0)) &&
     (((iVar1 = strcasecomp(terminal,"dialup"), iVar1 != 0 &&
       (iVar1 = strcasecomp(terminal,"dumb"), iVar1 != 0)) &&
      ((iVar1 = strcasecomp(terminal,"switch"), iVar1 != 0 &&
       (iVar1 = strcasecomp(terminal,"ethernet"), iVar1 != 0)))))) {
    return 0;
  }
  return 1;
}



void LYpaddstr(WINDOW *the_window,int width,char *the_string)

{
  bool bVar1;
  int local_20;
  int local_1c;
  int actual;
  int x;
  int y;
  
  actual = strlen(the_string);
  if (the_window == (WINDOW *)0x0) {
    local_20 = -1;
    local_1c = -1;
  }
  else {
    local_20 = (int)the_window->_cury;
    local_1c = (int)the_window->_curx;
  }
  if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < width + local_1c) {
    width = (LYcols - (uint)(LYShowScrollbar != '\0')) - local_1c;
  }
  if (width < actual) {
    actual = width;
  }
  LYwaddnstr(the_window,the_string,actual);
  width = width - actual;
  while (bVar1 = 0 < width, width = width + -1, bVar1) {
    waddnstr(the_window,&DAT_08155a7f,0xffffffff,local_20);
  }
  return;
}



void LYsubwindow(WINDOW *param)

{
  uint uVar1;
  int local_18;
  long b;
  
  if (param == (WINDOW *)0x0) {
    if (LYwin == (WINDOW *)0x0) {
      local_18 = -1;
    }
    else {
      local_18 = (int)LYwin->_maxy + 1;
    }
    wtouchln(LYwin,0,local_18,1);
    delwin(my_subwindow);
    my_subwindow = (WINDOW *)0x0;
  }
  else {
    my_subwindow = param;
    keypad(param,1);
    curses_w_style(my_subwindow,s_menu_bg,1);
    uVar1 = LYgetattrs(my_subwindow);
    wbkgd(my_subwindow,uVar1 | 0x20);
    curses_w_style(my_subwindow,s_menu_bg,0);
    scrollok(my_subwindow,1);
  }
  return;
}



WINDOW * LYtopwindow(void)

{
  WINDOW *local_8;
  
  if (my_subwindow == (WINDOW *)0x0) {
    local_8 = LYwin;
  }
  else {
    local_8 = my_subwindow;
  }
  return local_8;
}



WINDOW * LYstartPopup(int *top_y,int *left_x,int *height,int *width)

{
  char *Msg;
  WINDOW *form_window;
  
  form_window = (WINDOW *)0x0;
  if ((0 < *left_x) && (*left_x + *width + 4 < (int)(LYcols - (uint)(LYShowScrollbar != '\0')))) {
    form_window = (WINDOW *)newwin(*height,*width + 4,*top_y,*left_x + -1);
  }
  if (form_window == (WINDOW *)0x0) {
    if ((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -4) < *width) {
      *width = (LYcols - (uint)(LYShowScrollbar != '\0')) + -4;
      *left_x = 1;
    }
    else {
      *left_x = ((LYcols - (uint)(LYShowScrollbar != '\0')) + -4) - *width;
      if (*left_x < 1) {
        *left_x = 1;
      }
    }
    form_window = (WINDOW *)newwin(*height,*width + 4,*top_y,*left_x + -1);
  }
  if (form_window == (WINDOW *)0x0) {
    Msg = (char *)gettext("Unable to create popup window!");
    HTAlert(Msg);
  }
  else {
    LYsubwindow(form_window);
  }
  return form_window;
}



void LYstartTargetEmphasis(void)

{
  if (s_whereis == -1) {
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
  }
  else {
    curses_style(s_whereis,1);
  }
  return;
}



void LYstopTargetEmphasis(void)

{
  if (s_whereis == -1) {
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
  }
  else {
    curses_style(s_whereis,0);
  }
  return;
}



void LYtouchline(int row)

{
  wtouchln(LYwin,row,1,1);
  return;
}



void LYwaddnstr(WINDOW *w,char *src,size_t len)

{
  int local_50;
  WINDOW *w_00;
  FILE *__stream;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_34;
  int local_2c;
  WINDOW *sub;
  size_t inx;
  int x;
  int y;
  int x0;
  int y0;
  
  if (LYwin == (WINDOW *)0x0) {
    local_50 = -1;
    local_4c = -1;
  }
  else {
    local_50 = (int)LYwin->_cury;
    local_4c = (int)LYwin->_curx;
  }
  if (((((LYuseCursesPads == '\0') || (LYwin != w)) || (LYshiftWin != 0)) ||
      ((LYwideLines != 0 ||
       ((int)len <= (int)((LYcols - (uint)(LYShowScrollbar != '\0')) - local_4c))))) ||
     ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) <= local_4c)) {
    if (WWW_TraceFlag != '\0') {
      if (LYwin == (WINDOW *)0x0) {
        local_40 = -1;
        local_3c = -1;
      }
      else {
        local_40 = (int)LYwin->_cury;
        local_3c = (int)LYwin->_curx;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"[%2d,%2d] LYwaddnstr(%.*s, %u)\n",local_40,local_3c,len,src,len,
                local_50);
      }
    }
    if (LYwin == (WINDOW *)0x0) {
      local_34 = -1;
    }
    else {
      local_34 = (int)LYwin->_curx;
    }
    inx = 0;
    while (inx < len) {
      if (src[inx] == '\t') {
        if (LYwin == (WINDOW *)0x0) {
          local_2c = -1;
        }
        else {
          local_2c = (int)LYwin->_curx;
        }
        x = local_2c;
        while (x = x + 1, (x - local_34 & 7U) != 0) {
          waddch(w,0x20);
        }
        waddch(w,0x20);
      }
      else {
        waddch(w,(uint)(byte)src[inx]);
      }
      inx = inx + 1;
    }
  }
  else {
    w_00 = (WINDOW *)derwin(LYwin,LYlines,LYcols - (uint)(LYShowScrollbar != '\0'),0,0);
    if (w_00 != (WINDOW *)0x0) {
      wmove(w_00,local_50,local_4c);
      LYwideLines = 1;
      LYwaddnstr(w_00,src,len);
      if (w_00 == (WINDOW *)0x0) {
        local_48 = -1;
        local_44 = -1;
      }
      else {
        local_48 = (int)w_00->_cury;
        local_44 = (int)w_00->_curx;
      }
      delwin(w_00);
      wmove(LYwin,local_48,local_44);
    }
    LYwideLines = 0;
  }
  return;
}



int LYstrExtent(char *string,int len,int maxCells)

{
  short sVar1;
  int fake_max;
  WINDOW *fake_win;
  int local_28;
  int new_y;
  int new_x;
  int n;
  int used;
  int result;
  
  if (len < 0) {
    used = strlen(string);
  }
  else {
    used = len;
  }
  result = used;
  if ((0 < used) && (lynx_called_initscr != '\0')) {
    if ((fake_max < maxCells) && (fake_max = (maxCells + 1) * 2, fake_win != (WINDOW *)0x0)) {
      delwin(fake_win);
      fake_win = (WINDOW *)0x0;
    }
    if (fake_win == (WINDOW *)0x0) {
      fake_win = (WINDOW *)newwin(2,fake_max,0,0);
    }
    if (fake_win != (WINDOW *)0x0) {
      result = 0;
      wmove(fake_win,0,0);
      n = 0;
      while (n < used) {
        if ((string[n] != '\0') && ((string[n] < '\x03' || ('\b' < string[n])))) {
          waddch(fake_win,(uint)(byte)string[n]);
          if (fake_win == (WINDOW *)0x0) {
            sVar1 = -1;
            local_28 = -1;
          }
          else {
            sVar1 = fake_win->_cury;
            local_28 = (int)fake_win->_curx;
          }
          if ((0 < sVar1) || (maxCells < local_28)) break;
          result = local_28;
        }
        n = n + 1;
      }
    }
  }
  if (maxCells < result) {
    result = maxCells;
  }
  return result;
}



int LYstrExtent2(char *string,int len)

{
  int iVar1;
  
  iVar1 = LYstrExtent(string,len,len << 3);
  return iVar1;
}



int LYstrCells(char *string)

{
  size_t len;
  int iVar1;
  
  len = strlen(string);
  iVar1 = LYstrExtent2(string,len);
  return iVar1;
}



int LYscreenHeight(void)

{
  int result;
  
  result = LINES;
  if (LINES < 1) {
    result = 0x18;
  }
  return result;
}



int LYscreenWidth(void)

{
  int result;
  
  result = COLS;
  if (COLS < 1) {
    result = 0x50;
  }
  return result;
}



void LYnormalColor(void)

{
  int color;
  
  if ((LYwin != stdscr) && (-1 < displayStyles[128].color)) {
    wbkgd(LYwin,displayStyles[128].color | 0x20);
    LYrefresh();
  }
  return;
}



void LYclear(void)

{
  wclear(LYwin);
  LYnormalColor();
  return;
}



void LYclrtoeol(void)

{
  wclrtoeol(LYwin);
  return;
}



void LYerase(void)

{
  werase(LYwin);
  LYnormalColor();
  return;
}



void LYmove(int y,int x)

{
  wmove(LYwin,y,x);
  return;
}



void LYrefresh(void)

{
  int iVar1;
  int local_24;
  int local_20;
  int local_1c;
  int x;
  int y;
  
  if (LYwin == stdscr) {
    wrefresh(stdscr);
  }
  else {
    if (LYwin == (WINDOW *)0x0) {
      local_24 = -1;
      local_20 = -1;
    }
    else {
      local_24 = (int)LYwin->_cury;
      local_20 = (int)LYwin->_curx;
    }
    x = local_20;
    if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < local_20) {
      x = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    wmove(stdscr,local_24,x);
    wnoutrefresh(stdscr);
    iVar1 = LYscreenWidth();
    pnoutrefresh(LYwin,0,LYshiftWin,0,0,LYlines,iVar1 + -1);
    if (my_subwindow != (WINDOW *)0x0) {
      if (my_subwindow == (WINDOW *)0x0) {
        local_1c = -1;
      }
      else {
        local_1c = (int)my_subwindow->_maxy + 1;
      }
      wtouchln(my_subwindow,0,local_1c,1);
      wnoutrefresh(my_subwindow);
    }
    doupdate();
  }
  return;
}



void lynx_force_repaint(void)

{
  clearok(curscr,1);
  return;
}



void lynx_start_title_color(void)

{
  return;
}



void lynx_stop_title_color(void)

{
  return;
}



void lynx_start_link_color(int flag,int pending)

{
  if (flag == 0) {
    lynx_start_bold();
    if (pending != 0) {
      lynx_start_underline();
    }
  }
  else {
    lynx_start_reverse();
    if ((lynx_has_color != 0) && (1 < LYShowColor)) {
      lynx_start_underline();
    }
  }
  return;
}



void lynx_stop_link_color(int flag,int pending)

{
  int local_8;
  
  if (flag == 1) {
    local_8 = s_alink;
  }
  else {
    local_8 = s_a;
  }
  curses_style(local_8,0);
  return;
}



void lynx_stop_target_color(void)

{
  lynx_stop_underline();
  lynx_stop_reverse();
  lynx_stop_bold();
  return;
}



void lynx_start_target_color(void)

{
  lynx_start_bold();
  lynx_start_reverse();
  lynx_start_underline();
  return;
}



void lynx_start_status_color(void)

{
  if ((lynx_has_color == 0) || (LYShowColor < 2)) {
    lynx_start_reverse();
  }
  else {
    lynx_set_color(2);
  }
  return;
}



void lynx_stop_status_color(void)

{
  if ((lynx_has_color == 0) || (LYShowColor < 2)) {
    lynx_stop_reverse();
  }
  else {
    lynx_set_color(0);
  }
  return;
}



void lynx_start_h1_color(void)

{
  if ((bold_H1 != '\0') || (bold_headers != '\0')) {
    lynx_start_bold();
  }
  return;
}



void lynx_stop_h1_color(void)

{
  if ((bold_H1 != '\0') || (bold_headers != '\0')) {
    lynx_stop_bold();
  }
  return;
}



void lynx_start_prompt_color(void)

{
  lynx_start_reverse();
  return;
}



void lynx_stop_prompt_color(void)

{
  lynx_stop_reverse();
  return;
}



void lynx_start_radio_color(void)

{
  lynx_start_bold();
  return;
}



void lynx_stop_radio_color(void)

{
  lynx_stop_bold();
  return;
}



void lynx_stop_all_colors(void)

{
  lynx_stop_underline();
  lynx_stop_reverse();
  lynx_stop_bold();
  return;
}



void lynx_start_bold(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x200000;
  }
  else {
    local_8 = 0x20000;
  }
  wattr_on(LYwin,local_8,0);
  return;
}



void lynx_start_reverse(void)

{
  wattr_on(LYwin,0x40000,0);
  return;
}



void lynx_start_underline(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x20000;
  }
  else {
    local_8 = 0x200000;
  }
  wattr_on(LYwin,local_8,0);
  return;
}



void lynx_stop_bold(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x200000;
  }
  else {
    local_8 = 0x20000;
  }
  wattr_off(LYwin,local_8,0);
  return;
}



void lynx_stop_reverse(void)

{
  wattr_off(LYwin,0x40000,0);
  return;
}



void lynx_stop_underline(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x20000;
  }
  else {
    local_8 = 0x200000;
  }
  wattr_off(LYwin,local_8,0);
  return;
}



void LYSetDisplayLines(void)

{
  if (no_title == '\0') {
    if (user_mode == 0) {
      display_lines = LYlines + -4;
    }
    else {
      display_lines = LYlines + -2;
    }
  }
  else {
    if (user_mode == 0) {
      display_lines = LYlines + -3;
    }
    else {
      display_lines = LYlines + -1;
    }
  }
  return;
}



void LYstowCursor(WINDOW *win,int row,int col)

{
  if (LYShowCursor == '\0') {
    LYmove(LYlines + -1,(LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
  }
  else {
    wmove(win,row,col);
  }
  wrefresh(win);
  return;
}



long LYgetattrs(WINDOW *win)

{
  attr_t result;
  short pair;
  
  return win->_attrs;
}



int LYindex2MBM(int n)

{
  char MBMcodes [27];
  int local_8;
  
  if ((n < 0) || (0x19 < n)) {
    local_8 = 0x3f;
  }
  else {
    local_8 = (int)((char *)&ram0x081957e4)[n];
  }
  return local_8;
}



int LYMBM2index(int ch)

{
  ushort **ppuVar1;
  char *pcVar2;
  uint local_1c;
  char *result;
  char *letters;
  
  ppuVar1 = __ctype_b_loc();
  if (((*ppuVar1)[ch & 0xff] & 0x200) == 0) {
    local_1c = ch & 0xff;
  }
  else {
    local_1c = toupper(ch & 0xff);
  }
  if (((0 < (int)local_1c) &&
      (pcVar2 = strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ",local_1c), pcVar2 != (char *)0x0)) &&
     ((int)(pcVar2 + -0x8155ac4) < 0x1a)) {
    return (int)(pcVar2 + -0x8155ac4);
  }
  return -1;
}



void show_bookmark_not_defined(void)

{
  char *pcVar1;
  char *fmt;
  char *string_buffer;
  
  string_buffer = (char *)0x0;
  pcVar1 = key_for_func(0x31);
  fmt = (char *)gettext("Bookmark file is not defined. Use %s to see options.");
  HTSprintf0(&string_buffer,fmt,pcVar1);
  LYMBM_statusline(string_buffer);
  if (string_buffer != (char *)0x0) {
    free(string_buffer);
  }
  return;
}



char * get_bookmark_filename(char **URL)

{
  char filename_buffer [256];
  int iVar1;
  FILE *fp_00;
  char *source;
  char *newname;
  int MBM_tmp;
  FILE *fp;
  char *string_buffer;
  
  string_buffer = (char *)0x0;
  iVar1 = select_multi_bookmarks();
  if (iVar1 == -2) {
    return "";
  }
  if (iVar1 != -1) {
    HTSACopy(&BookmarkPage,MBM_A_subbookmark[iVar1]);
    LYAddPathToHome((char *)&ram0x081af240,0x100,BookmarkPage);
    source = BookmarkPage;
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",source,0x81af240);
    }
    fp_00 = (FILE *)fopen64((char *)0x81af240,"r");
    if (fp_00 != (FILE *)0x0) {
      source = LYSafeGets(&string_buffer,fp_00);
      if (((source == (char *)0x0) || (source = LYTrimNewline(string_buffer), *source == '\0')) ||
         (iVar1 = strncmp(string_buffer,"ncsa-xmosaic-hotlist-format-1",0x1d), iVar1 != 0)) {
        is_mosaic_hotlist = '\0';
        LYLocalFileToURL(URL,(char *)0x81af240);
      }
      else {
        is_mosaic_hotlist = '\x01';
        source = convert_mosaic_bookmark_file((char *)0x81af240);
        LYLocalFileToURL(URL,source);
      }
      if (string_buffer != (char *)0x0) {
        free(string_buffer);
        string_buffer = (char *)0x0;
      }
      LYCloseInput(fp_00);
      return (char *)0x81af240;
    }
    return (char *)0x0;
  }
  show_bookmark_not_defined();
  return " ";
}



char * convert_mosaic_bookmark_file(char *filename_buffer)

{
  char newfile [256];
  FILE *fp_00;
  FILE *fp_01;
  undefined4 uVar1;
  char *text;
  char *local_18;
  int line;
  char *buf;
  FILE *nfp;
  FILE *fp;
  
  buf = (char *)0x0;
  line = -2;
  LYRemoveTemp((char *)0x81af340);
  fp_00 = LYOpenTemp((char *)0x81af340,".html","w");
  if (fp_00 == (FILE *)0x0) {
    text = (char *)gettext("Unable to open tempfile for X Mosaic hotlist conversion.");
    LYMBM_statusline(text);
    LYSleepAlert();
    local_18 = "";
  }
  else {
    fp_01 = (FILE *)fopen64(filename_buffer,"r");
    if (fp_01 == (FILE *)0x0) {
      local_18 = "";
    }
    else {
      uVar1 = gettext("Converted Mosaic Hotlist");
      fprintf((FILE *)fp_00,"<head>\n<title>%s</title>\n</head>\n",uVar1);
      uVar1 = gettext(
                     "     This file is an HTML representation of the X Mosaic hotlist file.\n     Outdated or invalid links may be removed by using the\n     remove bookmark command, it is usually the \'R\' key but may have\n     been remapped by you or your system administrator."
                     );
      fprintf((FILE *)fp_00,"%s\n\n<p>\n<ol>\n",uVar1);
      while( true ) {
        text = LYSafeGets(&buf,fp_01);
        if (text == (char *)0x0) break;
        if (-1 < line) {
          LYTrimNewline(buf);
          if ((line & 1U) == 0) {
            if (*buf != '\0') {
              strtok(buf," ");
              fprintf((FILE *)fp_00,"<LI><a href=\"%s\">",buf);
            }
          }
          else {
            fprintf((FILE *)fp_00,"%s</a>\n",buf);
          }
        }
        line = line + 1;
      }
      LYCloseTempFP(fp_00);
      LYCloseInput(fp_01);
      local_18 = &ram0x081af340;
    }
  }
  return local_18;
}


/*
Unable to decompile 'save_bookmark_link'
Cause: 
Low-level Error: Shared type id: 80000000000001b
  _state : eGridState
*/


void remove_bookmark_link(int cur,char *cur_bookmark_page)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  char "%s %s %s" [9];
  FILE *__stream;
  int iVar6;
  char *Msg;
  int *piVar7;
  int in_GS_OFFSET;
  stat stat_buf;
  char *program;
  char *buffer;
  int keep_ol;
  int seen;
  char *cp2;
  char *cp;
  int del_line;
  mode_t mode;
  int n;
  char *buf;
  FILE *nfp;
  FILE *fp;
  BOOLEAN retain;
  BOOLEAN regular;
  BOOLEAN keep_tempfile;
  char homepath [256];
  char newfile [256];
  char filename_buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  buf = (char *)0x0;
  bVar5 = false;
  bVar4 = false;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"remove_bookmark_link: deleting link number: %d\n",cur);
  }
  if (cur_bookmark_page == (char *)0x0) goto LAB_0808fc90;
  LYAddPathToHome(filename_buffer,0x100,cur_bookmark_page);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",cur_bookmark_page,
            filename_buffer);
  }
  fp = (FILE *)fopen64(filename_buffer,"r");
  if (fp == (FILE *)0x0) {
    Msg = (char *)gettext("Unable to open bookmark file for deletion of link.");
    HTAlert(Msg);
    goto LAB_0808fc90;
  }
  LYAddPathToHome(homepath,0x100,"");
  nfp = LYOpenScratch(newfile,homepath);
  if (nfp == (FILE *)0x0) {
    LYCloseInput(fp);
    Msg = (char *)gettext("Unable to open scratch file for deletion of link.");
    HTAlert(Msg);
    goto LAB_0808fc90;
  }
  iVar6 = stat64(filename_buffer,(stat64 *)&stat_buf);
  if (iVar6 == 0) {
    if (((stat_buf.st_mode & 0xf000) == 0x8000) && (stat_buf.st_nlink == 1)) {
      bVar4 = true;
    }
    else {
      bVar4 = false;
    }
    chmod(newfile,stat_buf.st_mode & 0xff | 0x180);
    nfp = LYReopenTemp(newfile);
    if (nfp == (FILE *)0x0) {
      LYCloseInput(fp);
      Msg = (char *)gettext("Unable to reopen temporary file for deletion of link.");
      HTAlert(Msg);
      goto LAB_0808fc90;
    }
  }
  if (is_mosaic_hotlist == '\0') {
    n = -1;
    do {
      Msg = LYSafeGets(&buf,fp);
      if (Msg == (char *)0x0) goto LAB_0808f8b3;
      bVar2 = false;
      bVar3 = true;
      seen = 0;
      cp = buf;
      if ((cur == 0) && (Msg = LYstrstr(buf,"<ol><LI>"), Msg != (char *)0x0)) {
        bVar2 = true;
      }
      while ((n < cur && (cp = LYstrstr(cp,"<a href="), cp != (char *)0x0))) {
        seen = seen + 1;
        n = n + 1;
        if (n == cur) {
          if (((seen != 1) || (Msg = LYstrstr(buf,"</a>"), Msg == (char *)0x0)) ||
             (Msg = LYstrstr(cp + 1,"<a href="), Msg != (char *)0x0)) {
            Msg = (char *)gettext("Link is not by itself all on one line in bookmark file.");
            HTAlert(Msg);
            goto failure;
          }
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"remove_bookmark_link: skipping link %d\n",n);
          }
          if (bVar2) {
            fwrite("<ol>\n",1,5,(FILE *)nfp);
          }
          bVar3 = false;
        }
        cp = cp + 8;
      }
    } while ((!bVar3) || (iVar6 = fputs(buf,(FILE *)nfp), iVar6 != -1));
  }
  else {
    n = -3;
    do {
      Msg = LYSafeGets(&buf,fp);
      if (Msg == (char *)0x0) goto LAB_0808f8b3;
      n = n + 1;
    } while (((n == cur * 2) || (cur * 2 + 1 == n)) || (iVar6 = fputs(buf,(FILE *)nfp), iVar6 != -1)
            );
  }
  goto failure;
LAB_0808f8b3:
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"remove_bookmark_link: files: %s %s\n",newfile,filename_buffer);
  }
  LYCloseInput(fp);
  fp = (FILE *)0x0;
  iVar6 = fflush((FILE *)nfp);
  if (iVar6 == -1) {
    if (WWW_TraceFlag != '\0') {
      piVar7 = __errno_location();
      Msg = strerror(*piVar7);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"fflush(nfp): %s",Msg);
    }
  }
  else {
    LYCloseTempFP(nfp);
    nfp = (FILE *)0x0;
    if (!bVar4) {
      iVar6 = LYCopyFile(newfile,filename_buffer);
      if (iVar6 == 0) {
        LYRemoveTemp(newfile);
        goto LAB_0808fc90;
      }
      LYSleepAlert();
      Msg = (char *)gettext("Unable to copy temporary file for deletion of link.");
      HTUserMsg(Msg);
      bVar5 = true;
    }
    iVar6 = rename(newfile,filename_buffer);
    if (iVar6 != -1) {
      if (bVar4) {
        chmod(filename_buffer,stat_buf.st_mode & 0xfff);
      }
      goto LAB_0808fc90;
    }
    piVar7 = __errno_location();
    if (*piVar7 == 0x12) {
      buffer = (char *)0x0;
      Msg = HTGetProgramPath(ppMV);
      if (Msg != (char *)0x0) {
        HTAddParam(&buffer,"%s %s %s",1,Msg);
        HTAddParam(&buffer,"%s %s %s",2,newfile);
        HTAddParam(&buffer,"%s %s %s",3,filename_buffer);
        HTEndParam(&buffer,"%s %s %s",3);
        iVar6 = LYSystem(buffer);
        if (iVar6 == 0) {
          if (bVar4) {
            chmod(filename_buffer,stat_buf.st_mode & 0xfff);
          }
          if (buffer != (char *)0x0) {
            free(buffer);
            buffer = (char *)0x0;
          }
          goto LAB_0808fc90;
        }
      }
      if (buffer != (char *)0x0) {
        free(buffer);
        buffer = (char *)0x0;
      }
      bVar5 = true;
    }
    else {
      if (WWW_TraceFlag != '\0') {
        piVar7 = __errno_location();
        Msg = strerror(*piVar7);
        __stream = TraceFP();
        fprintf((FILE *)__stream,"rename(): %s",Msg);
      }
      Msg = (char *)gettext("Error renaming temporary file.");
      HTAlert(Msg);
      if (WWW_TraceFlag != '\0') {
        perror("renaming the file");
      }
    }
  }
failure:
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  Msg = (char *)gettext("Bookmark deletion failed.");
  HTAlert(Msg);
  if (nfp != (FILE *)0x0) {
    LYCloseTempFP(nfp);
  }
  if (fp != (FILE *)0x0) {
    LYCloseInput(fp);
  }
  if (bVar5) {
    Msg = (char *)gettext("File may be recoverable from %s during this session");
    HTUserMsg2(Msg,newfile);
  }
  else {
    LYRemoveTemp(newfile);
  }
LAB_0808fc90:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int select_multi_bookmarks(void)

{
  BOOLEAN BVar1;
  char *text;
  int ch;
  int local_20;
  int local_1c;
  int local_18;
  int c;
  
  if ((LYMultiBookmarks == 0) || (BVar1 = LYHaveSubBookmarks(), BVar1 == '\0')) {
    if (MBM_A_subbookmark[0] == (char *)0x0) {
      local_20 = -1;
    }
    else {
      local_20 = 0;
    }
  }
  else {
    if ((LYMultiBookmarks == 2) && (user_mode == 2)) {
      text = (char *)gettext("Select subbookmark, \'=\' for menu, or ^G to cancel: ");
      LYMBM_statusline(text);
      do {
        while( true ) {
          ch = LYgetch();
          BVar1 = LYisNonAlnumKeyname(ch,0x25);
          if (((BVar1 != '\0') || (ch == 3)) || (ch == 7)) {
            return -2;
          }
          BVar1 = LYisNonAlnumKeyname(ch,0x15);
          if (BVar1 == '\0') break;
          lynx_force_repaint();
          LYrefresh();
        }
        BVar1 = LYisNonAlnumKeyname(ch,0x27);
        if (BVar1 != '\0') {
          if (MBM_A_subbookmark[0] == (char *)0x0) {
            local_1c = -1;
          }
          else {
            local_1c = 0;
          }
          return local_1c;
        }
        if (ch == 0x3d) {
          ch = select_menu_multi_bookmarks();
          return ch;
        }
        local_18 = LYMBM2index(ch);
      } while (local_18 < 0);
      if (MBM_A_subbookmark[local_18] == (char *)0x0) {
        local_18 = -1;
      }
      local_20 = local_18;
    }
    else {
      local_20 = select_menu_multi_bookmarks();
    }
  }
  return local_20;
}



int select_menu_multi_bookmarks(void)

{
  BOOLEAN BVar1;
  int iVar2;
  int iVar3;
  size_t len;
  char *__s;
  int ch;
  int iVar4;
  int local_40;
  int local_3c;
  char *shead_buffer;
  int MBM_current;
  int MBM_to;
  int MBM_from;
  int MBM_screens;
  int MBM_allow;
  int MBM_tmp_count;
  int d;
  int c;
  
  if (LYMultiBookmarks == 0) {
    local_40 = 0;
  }
  else {
    iVar2 = LYlines + -7;
    if (0 < iVar2) {
      iVar3 = 0x19 / iVar2 + 1;
      MBM_current = 1;
LAB_0808fe6d:
      do {
        MBM_from = (MBM_current + -1) * iVar2;
        if (MBM_from < 0) {
          MBM_from = 0;
        }
        if (MBM_current != 1) {
          MBM_from = MBM_from + 1;
        }
        MBM_to = iVar2 * MBM_current;
        if (0x19 < MBM_to) {
          MBM_to = 0x19;
        }
        LYclear();
        LYmove(1,5);
        lynx_start_h1_color();
        if (iVar3 < 2) {
          __s = (char *)gettext("       Select Bookmark");
          len = strlen(__s);
          __s = (char *)gettext("       Select Bookmark");
          LYwaddnstr(LYwin,__s,len);
        }
        else {
          shead_buffer = (char *)0x0;
          __s = (char *)gettext(" Select Bookmark (screen %d of %d)");
          HTSprintf0(&shead_buffer,__s,MBM_current,iVar3);
          len = strlen(shead_buffer);
          LYwaddnstr(LYwin,shead_buffer,len);
          if (shead_buffer != (char *)0x0) {
            free(shead_buffer);
            shead_buffer = (char *)0x0;
          }
        }
        lynx_stop_h1_color();
        MBM_tmp_count = 0;
        c = MBM_from;
        while (c <= MBM_to) {
          LYmove(MBM_tmp_count + 3,5);
          ch = LYindex2MBM(c);
          waddch(LYwin,ch);
          LYwaddnstr(LYwin," : ",3);
          if (MBM_A_subdescript[c] != (char *)0x0) {
            len = strlen(MBM_A_subdescript[c]);
            LYwaddnstr(LYwin,MBM_A_subdescript[c],len);
          }
          LYmove(MBM_tmp_count + 3,0x24);
          waddch(LYwin,0x28);
          if (MBM_A_subbookmark[c] != (char *)0x0) {
            len = strlen(MBM_A_subbookmark[c]);
            LYwaddnstr(LYwin,MBM_A_subbookmark[c],len);
          }
          waddch(LYwin,0x29);
          MBM_tmp_count = MBM_tmp_count + 1;
          c = c + 1;
        }
        if (1 < iVar3) {
          LYmove(LYlines + -2,0);
          LYwaddnstr(LYwin,"\'",1);
          lynx_start_bold();
          LYwaddnstr(LYwin,"[",1);
          lynx_stop_bold();
          LYwaddnstr(LYwin,"\' ",2);
          __s = (char *)gettext("previous");
          len = strlen(__s);
          __s = (char *)gettext("previous");
          LYwaddnstr(LYwin,__s,len);
          LYwaddnstr(LYwin,", \'",3);
          lynx_start_bold();
          LYwaddnstr(LYwin,"]",1);
          lynx_stop_bold();
          LYwaddnstr(LYwin,"\' ",2);
          __s = (char *)gettext("next screen");
          len = strlen(__s);
          __s = (char *)gettext("next screen");
          LYwaddnstr(LYwin,__s,len);
        }
        __s = (char *)gettext("Select destination or ^G to Cancel: ");
        LYMBM_statusline(__s);
        do {
          while( true ) {
            while( true ) {
              ch = LYgetch();
              iVar4 = LYMBM2index(ch);
              if (iVar4 < 0) break;
              if (MBM_A_subbookmark[iVar4] != (char *)0x0) {
                return iVar4;
              }
              show_bookmark_not_defined();
              __s = (char *)gettext("Select destination or ^G to Cancel: ");
              LYMBM_statusline(__s);
            }
            BVar1 = LYisNonAlnumKeyname(ch,0x25);
            if (((BVar1 != '\0') || (ch == 7)) || (ch == 3)) {
              return -2;
            }
            BVar1 = LYisNonAlnumKeyname(ch,0x15);
            if (BVar1 == '\0') break;
            lynx_force_repaint();
            LYrefresh();
          }
          BVar1 = LYisNonAlnumKeyname(ch,0x27);
          if (BVar1 != '\0') {
            if (MBM_A_subbookmark[0] == (char *)0x0) {
              local_3c = -1;
            }
            else {
              local_3c = 0;
            }
            return local_3c;
          }
          if (((ch == 0x5d) || (BVar1 = LYisNonAlnumKeyname(ch,0xf), BVar1 != '\0')) && (1 < iVar3))
          {
            MBM_current = MBM_current + 1;
            if (iVar3 < MBM_current) {
              MBM_current = 1;
            }
            goto LAB_0808fe6d;
          }
        } while (((ch != 0x5b) && (BVar1 = LYisNonAlnumKeyname(ch,0x10), BVar1 == '\0')) ||
                (iVar3 < 2));
        MBM_current = MBM_current + -1;
        if (MBM_current < 1) {
          MBM_current = iVar3;
        }
      } while( true );
    }
    __s = (char *)gettext("Screen too small! (8x35 min)");
    HTAlert(__s);
    local_40 = -2;
  }
  return local_40;
}



BOOLEAN LYHaveSubBookmarks(void)

{
  int i;
  
  i = 1;
  while( true ) {
    if (0x18 < i) {
      return '\0';
    }
    if ((MBM_A_subbookmark[i] != (char *)0x0) && (*MBM_A_subbookmark[i] != '\0')) break;
    i = i + 1;
  }
  return '\x01';
}



void LYMBM_statusline(char *text)

{
  if ((LYMultiBookmarks == 0) || (user_mode != 0)) {
    mustshow = '\x01';
    statusline(text);
  }
  else {
    LYStatusLine = LYlines + -1;
    mustshow = '\x01';
    statusline(text);
    LYStatusLine = -1;
  }
  return;
}



BOOLEAN havevisible(char *Title)

{
  byte bVar1;
  BOOLEAN BVar2;
  UCode_t UVar3;
  long unicode;
  char *p;
  uchar c;
  
  p = Title;
  do {
    if (*p == '\0') {
      return '\0';
    }
    bVar1 = *p;
    if ((0x20 < bVar1) && (bVar1 < 0x7f)) {
      return '\x01';
    }
    if ((0x20 < bVar1) && (bVar1 != 0x7f)) {
      if ((LYHaveCJKCharacterSet != '\0') ||
         (BVar2 = UCCanUniTranslateFrom(current_char_set), BVar2 == '\0')) {
        return '\x01';
      }
      UVar3 = UCTransToUni(*p,current_char_set);
      if ((0x20 < UVar3) && (UVar3 < 0x7f)) {
        return '\x01';
      }
      if ((0x20 < UVar3) &&
         (((UVar3 != 0xa0 && (UVar3 != 0xad)) && ((UVar3 < 0x2000 || (0x200e < UVar3)))))) {
        return '\x01';
      }
    }
    p = p + 1;
  } while( true );
}



BOOLEAN have8bit(char *Title)

{
  char *p;
  
  p = Title;
  while( true ) {
    if (*p == '\0') {
      return '\0';
    }
    if (*p < '\0') break;
    p = p + 1;
  }
  return '\x01';
}



char * title_convert8bit(char *Title)

{
  int iVar1;
  int charset_in_00;
  int charset_out_00;
  int iVar2;
  UCode_t UVar3;
  int in_GS_OFFSET;
  long unicode;
  int charset_out;
  int charset_in;
  char *buf;
  char *ncr;
  char *comment;
  char *q;
  char *p0;
  char *p;
  char temp [2];
  char replace_buf [32];
  
  charset_in_00 = current_char_set;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = Title;
  comment = (char *)0x0;
  ncr = (char *)0x0;
  buf = (char *)0x0;
  charset_out_00 = UCGetLYhndl_byMIME("us-ascii");
  while (*p != '\0') {
    LYstrncpy(temp,p,1);
    if (temp[0] < '\0') {
      iVar2 = UCTransCharStr(replace_buf,0x20,temp[0],charset_in_00,charset_out_00,1);
      if (0 < iVar2) {
        HTSACat(&comment,replace_buf);
      }
      UVar3 = UCTransToUni(temp[0],charset_in_00);
      HTSACat(&ncr,"&#");
      sprintf(replace_buf,"%ld",UVar3);
      HTSACat(&ncr,replace_buf);
      HTSACat(&ncr,";");
    }
    else {
      HTSACat(&comment,temp);
      HTSACat(&ncr,temp);
    }
    p = p + 1;
  }
  p0 = comment;
  q = comment;
  while (*p0 != '\0') {
    if (((0x1f < (byte)*p0) && (*p0 != '>')) && ((q == comment || ((*p0 != '-' || (q[-1] != '-')))))
       ) {
      *q = *p0;
      q = q + 1;
    }
    p0 = p0 + 1;
  }
  *q = '\0';
  HTSACat(&buf,"<!-- ");
  HTSACat(&buf,comment);
  HTSACat(&buf," -->");
  HTSACat(&buf,ncr);
  if (comment != (char *)0x0) {
    free(comment);
    comment = (char *)0x0;
  }
  if (ncr != (char *)0x0) {
    free(ncr);
    ncr = (char *)0x0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return buf;
}



void set_default_bookmark_page(char *value)

{
  int iVar1;
  char *src;
  
  if (value != (char *)0x0) {
    if ((bookmark_page == (char *)0x0) || (iVar1 = strcmp(bookmark_page,value), iVar1 != 0)) {
      HTSACopy(&bookmark_page,value);
    }
    HTSACopy(&BookmarkPage,bookmark_page);
    HTSACopy(MBM_A_subbookmark,bookmark_page);
    src = (char *)gettext("Default Bookmark File");
    HTSACopy(MBM_A_subdescript,src);
    return;
  }
  return;
}



time_t LYmktime(char *string,BOOLEAN absolute)

{
  time_t tVar1;
  FILE *__stream;
  time_t tVar2;
  char *pcVar3;
  time_t result;
  
  if ((string != (char *)0x0) && (*string != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYmktime: Parsing \'%s\'\n",string);
    }
    result = parsedate(string,(TIMEINFO *)0x0);
    if (absolute == '\0') {
      tVar2 = time((time_t *)0x0);
      if (-1 < tVar2 - result) {
        result = 0;
      }
    }
    if ((result != 0) && (WWW_TraceFlag != '\0')) {
      pcVar3 = ctime(&result);
      tVar1 = result;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYmktime: clock=%d, ctime=%s",tVar1,pcVar3);
    }
  }
  return result;
}



LY_TEMP * FindTempfileByName(char *name)

{
  int iVar1;
  LY_TEMP *p;
  
  p = ly_temp;
  while( true ) {
    if (p == (LY_TEMP *)0x0) {
      return (LY_TEMP *)0x0;
    }
    iVar1 = strcmp(p->name,name);
    if (iVar1 == 0) break;
    p = (LY_TEMP *)p->next;
  }
  return p;
}



LY_TEMP * FindTempfileByFP(FILE *fp)

{
  LY_TEMP *p;
  
  p = ly_temp;
  while ((p != (LY_TEMP *)0x0 && (p->file != fp))) {
    p = (LY_TEMP *)p->next;
  }
  return p;
}



char * LYGetEnv(char *name)

{
  char *local_18;
  char *result;
  
  local_18 = getenv(name);
  if ((local_18 == (char *)0x0) || (*local_18 == '\0')) {
    local_18 = (char *)0x0;
  }
  return local_18;
}



size_t utf8_length(BOOLEAN utf_flag,char *data)

{
  size_t sVar1;
  size_t utf_extra;
  
  utf_extra = 0;
  if ((utf_flag != '\0') && (*data < '\0')) {
    if (((int)*data & 0xe0U) == 0xc0) {
      utf_extra = 1;
    }
    else {
      if (((int)*data & 0xf0U) == 0xe0) {
        utf_extra = 2;
      }
      else {
        if (((int)*data & 0xf8U) == 0xf0) {
          utf_extra = 3;
        }
        else {
          if (((int)*data & 0xfcU) == 0xf8) {
            utf_extra = 4;
          }
          else {
            if (((int)*data & 0xfeU) == 0xfc) {
              utf_extra = 5;
            }
            else {
              utf_extra = 0;
            }
          }
        }
      }
    }
    sVar1 = strlen(data + 1);
    if (sVar1 < utf_extra) {
      utf_extra = 0;
    }
  }
  return utf_extra;
}



void LYFreeHilites(int first,int last)

{
  int i;
  
  i = first;
  while (i < last) {
    LYSetHilite(i,(char *)0x0);
    if (links[i].lname != (char *)0x0) {
      free(links[i].lname);
      links[i].lname = (char *)0x0;
    }
    i = i + 1;
  }
  return;
}



void LYSetHilite(int cur,char *text)

{
  links[cur].list.hl_base.hl_text = text;
  links[cur].list.hl_len = (ushort)(text != (char *)0x0);
  if (links[cur].list.hl_info != (HiliteInfo *)0x0) {
    free(links[cur].list.hl_info);
    links[cur].list.hl_info = (HiliteInfo *)0x0;
  }
  return;
}



void LYAddHilite(int cur,char *text,int x)

{
  HiliteInfo *__ptr;
  int iVar1;
  int iVar2;
  uint want;
  uint need;
  HiliteInfo *have;
  HiliteList *list;
  
  __ptr = links[cur].list.hl_info;
  iVar1 = (int)links[cur].list.hl_len + -1;
  links[cur].list.hl_len = links[cur].list.hl_len + 1;
  iVar2 = (int)links[cur].list.hl_len;
  if (__ptr == (HiliteInfo *)0x0) {
    have = (HiliteInfo *)malloc(iVar2 << 3);
  }
  else {
    have = (HiliteInfo *)realloc(__ptr,iVar2 << 3);
  }
  links[cur].list.hl_info = have;
  have[iVar1].hl_text = text;
  have[iVar1].hl_x = (short)x;
  return;
}



char * LYGetHiliteStr(int cur,int count)

{
  char *result;
  
  if (count < links[cur].list.hl_len) {
    if (count < 1) {
      result = links[cur].list.hl_base.hl_text;
    }
    else {
      result = links[cur].list.hl_info[(1 - count) * 0x1fffffff].hl_text;
    }
  }
  else {
    result = (char *)0x0;
  }
  return result;
}



int LYGetHilitePos(int cur,int count)

{
  int result;
  
  if (count < links[cur].list.hl_len) {
    if (count < 1) {
      result = links[cur].lx;
    }
    else {
      result = (int)links[cur].list.hl_info[(1 - count) * 0x1fffffff].hl_x;
    }
  }
  else {
    result = -1;
  }
  return result;
}



BOOLEAN show_whereis_targets
                  (int flag,int cur,int count,char *target,BOOLEAN TargetEmphasisON,BOOLEAN utf_flag
                  )

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  size_t sVar4;
  int y_00;
  int x;
  int iVar5;
  size_t n;
  size_t len_00;
  int iVar6;
  int in_GS_OFFSET;
  char *local_518;
  size_t local_514;
  char *local_510;
  int local_508;
  int local_500;
  int local_4f8;
  int local_4f0;
  size_t local_4ec;
  char *local_4e8;
  char *local_4e0;
  char *local_4d8;
  size_t local_4d0;
  size_t local_4c8;
  int local_4bc;
  int local_4b4;
  int local_4ac;
  int local_4a4;
  size_t local_4a0;
  char *local_49c;
  char *local_494;
  char *local_48c;
  size_t local_484;
  int local_478;
  BOOLEAN local_470;
  char tmp [7];
  size_t utf_extra;
  int hoffset;
  int hLine;
  int hLen;
  int hlen;
  int tlen;
  char *data;
  int offset;
  int y;
  int len;
  int written;
  int itmp;
  int tLen;
  int Offset;
  int LenNeeded;
  int HitOffset;
  char *theData;
  char *cp;
  char *Data;
  char buffer [1024];
  
  local_470 = TargetEmphasisON;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  theData = (char *)0x0;
  tmp[2] = '\0';
  tmp[1] = '\0';
  tmp[0] = '\0';
  if (((((target != (char *)0x0) && (*target != '\0')) && ((links[cur].type & 2U) != 0)) &&
      ((pcVar3 = LYGetHiliteStr(cur,count), pcVar3 != (char *)0x0 &&
       (pcVar3 = LYGetHiliteStr(cur,count), *pcVar3 != '\0')))) &&
     ((links[cur].ly + count < display_lines &&
      (BVar2 = HText_getFirstTargetInLine
                         (HTMainText,links[cur].anchor_line_num + count,utf_flag,&Offset,&tLen,
                          &theData,target), BVar2 != '\0')))) {
    sVar4 = strlen(target);
    y_00 = links[cur].ly + count;
    x = LYGetHilitePos(cur,count);
    iVar6 = LYcols - (uint)(LYShowScrollbar != '\0');
    iVar5 = LYGetHilitePos(cur,count);
    pcVar3 = LYGetHiliteStr(cur,count);
    if (pcVar3 == (char *)0x0) {
      local_518 = "";
    }
    else {
      local_518 = LYGetHiliteStr(cur,count);
    }
    LYmbcsstrncpy(buffer,local_518,0x3ff,iVar6 - iVar5,utf_flag);
    local_514 = strlen(buffer);
    if ((HTCJK != NOCJK) || (utf_flag != '\0')) {
      local_514 = LYmbcsstrlen(buffer,utf_flag,'\x01');
    }
    if (Offset < (int)(x + local_514)) {
      Data = theData;
      while ((Offset < x && (Offset + tLen <= x))) {
        iVar5 = Offset + tLen;
        if (case_sensitive == '\0') {
          local_510 = LYno_attr_mbcs_case_strstr
                                (Data + sVar4,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        else {
          local_510 = LYno_attr_mbcs_strstr
                                (Data + sVar4,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        if ((local_510 == (char *)0x0) || (LYcols <= LenNeeded + iVar5)) goto highlight_search_done;
        Data = local_510;
        Offset = HitOffset + iVar5;
      }
      if ((Offset < x) && (x < Offset + tLen)) {
        itmp = 0;
        iVar5 = Offset - x;
        LYmove(y_00,x);
        tmp[0] = buffer[0];
        n = utf8_length(utf_flag,buffer);
        if (n == 0) {
          if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
            if (flag == 1) {
              LYmove(y_00,x + 1);
            }
            else {
              LYstartTargetEmphasis();
              local_470 = '\x01';
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            written = 1;
          }
          else {
            itmp = 1;
            if (flag == 1) {
              LYmove(y_00,x + 1);
            }
            else {
              LYstartTargetEmphasis();
              local_470 = '\x01';
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            tmp[1] = '\0';
            written = 2;
          }
        }
        else {
          LYstrncpy(tmp + 1,buffer + 1,n);
          if (flag == 1) {
            LYmove(y_00,x + 1);
          }
          else {
            LYstartTargetEmphasis();
            local_470 = '\x01';
            len_00 = strlen(tmp);
            LYwaddnstr(LYwin,tmp,len_00);
          }
          tmp[1] = '\0';
          written = n + 1;
          itmp = n;
        }
        itmp = itmp + 1;
        if ((local_470 == '\0') && (buffer[itmp] != '\0')) {
          LYstartTargetEmphasis();
          local_470 = '\x01';
        }
        while ((written < (int)(iVar5 + sVar4) && (tmp[0] = buffer[itmp], tmp[0] != '\0'))) {
          n = utf8_length(utf_flag,buffer + itmp);
          if (n == 0) {
            if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
              if ((flag == 1) && (buffer[itmp + 1] == '\0')) {
                LYstopTargetEmphasis();
                local_470 = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_4f8 = -1;
                }
                else {
                  local_4f8 = (int)LYwin->_curx;
                }
                LYmove(y_00,local_4f8 + 1);
              }
              else {
                len_00 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,len_00);
              }
              written = written + 1;
            }
            else {
              tmp[1] = buffer[itmp + 1];
              if ((flag == 1) && (buffer[itmp + 2] == '\0')) {
                LYstopTargetEmphasis();
                local_470 = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_500 = -1;
                }
                else {
                  local_500 = (int)LYwin->_curx;
                }
                LYmove(y_00,local_500 + 1);
              }
              else {
                len_00 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,len_00);
              }
              tmp[1] = '\0';
              written = written + 2;
              itmp = itmp + 1;
            }
          }
          else {
            LYstrncpy(tmp + 1,buffer + itmp + 1,n);
            if ((flag == 1) && (buffer[itmp + n + 1] == '\0')) {
              LYstopTargetEmphasis();
              local_470 = '\0';
              if (LYwin == (WINDOW *)0x0) {
                local_508 = -1;
              }
              else {
                local_508 = (int)LYwin->_curx;
              }
              LYmove(y_00,local_508 + 1);
            }
            else {
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            tmp[1] = '\0';
            written = written + n + 1;
            itmp = itmp + n;
          }
          itmp = itmp + 1;
        }
        if (local_470 != '\0') {
          LYstopTargetEmphasis();
          local_470 = '\0';
        }
        if (LYwin == (WINDOW *)0x0) {
          local_4f0 = -1;
        }
        else {
          local_4f0 = (int)LYwin->_curx;
        }
        if (flag == 1) {
          local_4ec = local_514 - 1;
        }
        else {
          local_4ec = local_514;
        }
        if ((int)(local_4ec + x) <= local_4f0) goto highlight_search_done;
        if (case_sensitive == '\0') {
          if (utf_flag == '\0') {
            local_4d8 = Data + (local_4f0 - Offset);
          }
          else {
            local_4d8 = LYmbcs_skip_glyphs(Data,local_4f0 - Offset,utf_flag);
          }
          local_4e8 = LYno_attr_mbcs_case_strstr
                                (local_4d8,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        else {
          if (utf_flag == '\0') {
            local_4e0 = Data + (local_4f0 - Offset);
          }
          else {
            local_4e0 = LYmbcs_skip_glyphs(Data,local_4f0 - Offset,utf_flag);
          }
          local_4e8 = LYno_attr_mbcs_strstr(local_4e0,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        if ((local_4e8 == (char *)0x0) || (LYcols <= LenNeeded + local_4f0))
        goto highlight_search_done;
        if (flag == 1) {
          local_4d0 = local_514 - 1;
        }
        else {
          local_4d0 = local_514;
        }
        if ((int)(local_4d0 + x) <= local_4f0 + HitOffset) goto highlight_search_done;
        Data = local_4e8;
        Offset = HitOffset + local_4f0;
      }
      while( true ) {
        data = buffer;
        if (flag == 1) {
          local_4c8 = local_514 - 1;
        }
        else {
          local_4c8 = local_514;
        }
        if ((int)local_4c8 < Offset - x) goto highlight_search_done;
        if (utf_flag == '\0') {
          data = data + (Offset - x);
        }
        else {
          data = LYmbcs_skip_glyphs(data,Offset - x,utf_flag);
          LYrefresh();
        }
        iVar5 = Offset;
        itmp = 0;
        LYmove(y_00,Offset);
        tmp[0] = *data;
        n = utf8_length(utf_flag,data);
        if (n == 0) {
          if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
            if ((flag == 1) && ((iVar5 <= x || (data[1] == '\0')))) {
              LYmove(y_00,iVar5 + 1);
            }
            else {
              LYstartTargetEmphasis();
              local_470 = '\x01';
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            written = 1;
          }
          else {
            itmp = 1;
            tmp[1] = data[1];
            if ((flag == 1) && ((iVar5 <= x || (data[2] == '\0')))) {
              LYmove(y_00,iVar5 + 2);
            }
            else {
              LYstartTargetEmphasis();
              local_470 = '\x01';
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            tmp[1] = '\0';
            written = 2;
          }
        }
        else {
          LYstrncpy(tmp + 1,data + 1,n);
          if ((flag == 1) && ((iVar5 <= x || (data[n + 1] == '\0')))) {
            LYmove(y_00,iVar5 + 1);
          }
          else {
            LYstartTargetEmphasis();
            local_470 = '\x01';
            len_00 = strlen(tmp);
            LYwaddnstr(LYwin,tmp,len_00);
          }
          tmp[1] = '\0';
          written = n + 1;
          itmp = n;
        }
        itmp = itmp + 1;
        if ((local_470 == '\0') && (data[itmp] != '\0')) {
          LYstartTargetEmphasis();
          local_470 = '\x01';
        }
        while ((written < (int)sVar4 && (tmp[0] = data[itmp], tmp[0] != '\0'))) {
          n = utf8_length(utf_flag,data + itmp);
          if (n == 0) {
            if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
              if ((flag == 1) && (data[itmp + 1] == '\0')) {
                LYstopTargetEmphasis();
                local_470 = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_4ac = -1;
                }
                else {
                  local_4ac = (int)LYwin->_curx;
                }
                LYmove(y_00,local_4ac + 1);
              }
              else {
                len_00 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,len_00);
              }
              written = written + 1;
            }
            else {
              tmp[1] = data[itmp + 1];
              if ((flag == 1) && (data[itmp + 2] == '\0')) {
                LYstopTargetEmphasis();
                local_470 = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_4b4 = -1;
                }
                else {
                  local_4b4 = (int)LYwin->_curx;
                }
                LYmove(y_00,local_4b4 + 1);
              }
              else {
                len_00 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,len_00);
              }
              tmp[1] = '\0';
              written = written + 2;
              itmp = itmp + 1;
            }
          }
          else {
            LYstrncpy(tmp + 1,data + itmp + 1,n);
            if ((flag == 1) && (data[itmp + n + 1] == '\0')) {
              LYstopTargetEmphasis();
              local_470 = '\0';
              if (LYwin == (WINDOW *)0x0) {
                local_4bc = -1;
              }
              else {
                local_4bc = (int)LYwin->_curx;
              }
              LYmove(y_00,local_4bc + 1);
            }
            else {
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            tmp[1] = '\0';
            written = written + n + 1;
            itmp = itmp + n;
          }
          itmp = itmp + 1;
        }
        if (local_470 != '\0') {
          LYstopTargetEmphasis();
          local_470 = '\0';
        }
        if (LYwin == (WINDOW *)0x0) {
          local_4a4 = -1;
        }
        else {
          local_4a4 = (int)LYwin->_curx;
        }
        if (flag == 1) {
          local_4a0 = local_514 - 1;
        }
        else {
          local_4a0 = local_514;
        }
        if ((int)(local_4a0 + x) <= local_4a4) goto highlight_search_done;
        if (case_sensitive == '\0') {
          if (utf_flag == '\0') {
            local_48c = Data + (local_4a4 - Offset);
          }
          else {
            local_48c = LYmbcs_skip_glyphs(Data,local_4a4 - Offset,utf_flag);
          }
          local_49c = LYno_attr_mbcs_case_strstr
                                (local_48c,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        else {
          if (utf_flag == '\0') {
            local_494 = Data + (local_4a4 - Offset);
          }
          else {
            local_494 = LYmbcs_skip_glyphs(Data,local_4a4 - Offset,utf_flag);
          }
          local_49c = LYno_attr_mbcs_strstr(local_494,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        if ((local_49c == (char *)0x0) || (LYcols <= LenNeeded + local_4a4))
        goto highlight_search_done;
        if (flag == 1) {
          local_484 = local_514 - 1;
        }
        else {
          local_484 = local_514;
        }
        if ((int)(local_484 + x) <= local_4a4 + HitOffset) goto highlight_search_done;
        if ((int)(x + local_514) <= tLen + local_4a4 + HitOffset) break;
        Data = local_49c;
        Offset = HitOffset + local_4a4;
      }
      local_4a4 = local_4a4 + HitOffset;
      if (utf_flag == '\0') {
        Data = Data + (local_4a4 - x);
      }
      else {
        Data = LYmbcs_skip_glyphs(Data,local_4a4 - x,utf_flag);
        LYrefresh();
      }
      LYmove(y_00,local_4a4);
      itmp = 0;
      written = 0;
      sVar4 = strlen(Data);
      LYstartTargetEmphasis();
      local_470 = '\x01';
      while ((written < (int)sVar4 && (tmp[0] = Data[itmp], tmp[0] != '\0'))) {
        n = utf8_length(utf_flag,Data + itmp);
        if (n == 0) {
          if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
            if ((flag == 1) && (Data[itmp + 1] == '\0')) {
              LYstopTargetEmphasis();
              local_470 = '\0';
            }
            else {
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            written = written + 1;
          }
          else {
            tmp[1] = Data[itmp + 1];
            if ((flag == 1) && (Data[itmp + 2] == '\0')) {
              LYstopTargetEmphasis();
              local_470 = '\0';
            }
            else {
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            tmp[1] = '\0';
            written = written + 2;
            itmp = itmp + 1;
          }
        }
        else {
          LYstrncpy(tmp + 1,Data + itmp + 1,n);
          if ((flag == 1) && (Data[itmp + n + 1] == '\0')) {
            LYstopTargetEmphasis();
            local_470 = '\0';
            if (LYwin == (WINDOW *)0x0) {
              local_478 = -1;
            }
            else {
              local_478 = (int)LYwin->_curx;
            }
            LYmove(y_00,local_478 + 1);
          }
          else {
            len_00 = strlen(tmp);
            LYwaddnstr(LYwin,tmp,len_00);
          }
          tmp[1] = '\0';
          written = written + n + 1;
          itmp = itmp + n;
        }
        itmp = itmp + 1;
      }
      if (local_470 != '\0') {
        LYstopTargetEmphasis();
      }
    }
  }
highlight_search_done:
  if (theData != (char *)0x0) {
    free(theData);
    theData = (char *)0x0;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_470;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int find_cached_style(int cur,int flag)

{
  int iVar1;
  int iVar2;
  BOOLEAN BVar3;
  FILE *__stream;
  int x;
  int s;
  
  s = s_alink;
  if (((textfields_need_activation != '\0') && (links[cur].type == 1)) &&
     (((links[cur].l_form)->type == 1 ||
      (((((links[cur].l_form)->type == 0xc || ((links[cur].l_form)->type == 2)) ||
        ((links[cur].l_form)->type == 0xb)) || ((links[cur].l_form)->type == 9)))))) {
    s = s_curedit;
  }
  if (flag == 1) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      iVar1 = links[cur].lx;
      iVar2 = links[cur].ly;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"STYLE.highlight.on: @(%d,%d).\n",iVar2,iVar1);
    }
  }
  else {
    BVar3 = ValidCachedStyle(links[cur].ly,links[cur].lx);
    if (BVar3 == '\0') {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"STYLE.highlight.off: can\'t use cache.\n");
      }
      s = s_a;
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        iVar1 = links[cur].lx;
        iVar2 = links[cur].ly;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"STYLE.highlight.off: cached style @(%d,%d): ",iVar2,iVar1);
      }
      s = GetCachedStyle(links[cur].ly,links[cur].lx);
      if (s == 0) {
        x = links[cur].lx;
        do {
          x = x + -1;
          if (x < 0) goto LAB_08092b86;
          s = GetCachedStyle(links[cur].ly,x);
        } while (s == 0);
        SetCachedStyle(links[cur].ly,links[cur].lx,s);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          iVar1 = links[cur].lx;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"found %d, x_offset=%d.\n",s,x - iVar1);
        }
LAB_08092b86:
        if (s == 0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"not found, assume <a>.\n");
          }
          s = s_a;
        }
      }
      else {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"found %d.\n",s);
        }
      }
    }
  }
  return s;
}



void LYhighlight(int flag,int cur,char *target)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  bool bVar4;
  FILE *__stream;
  int style;
  char *pcVar5;
  int x;
  size_t len_00;
  int in_GS_OFFSET;
  bool utf_flag_00;
  int local_478;
  char *local_474;
  undefined *local_46c;
  char *local_460;
  int local_45c;
  int local_458;
  int local_454;
  char tmp [7];
  int row;
  char *text;
  int avail_space;
  int gllen;
  int len;
  char *hi_string;
  int title_adjust;
  int hi_offset;
  int hi_count;
  int i;
  BOOLEAN hl2_drawn;
  BOOLEAN hl1_drawn;
  BOOLEAN utf_flag;
  BOOLEAN target1_drawn;
  BOOLEAN TargetEmphasisON;
  char buffer [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (no_title == '\0') {
    local_478 = 0;
  }
  else {
    local_478 = -1;
  }
  TargetEmphasisON = '\0';
  utf_flag_00 = LYCharSet_UC[current_char_set].enc == 7;
  bVar4 = false;
  tmp[2] = '\0';
  tmp[1] = '\0';
  tmp[0] = '\0';
  if (cur < 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYhighlight cur %d (bug workaround)\n",cur);
    }
    cur = 0;
  }
  if (WWW_TraceFlag != '\0') {
    if (target == (char *)0x0) {
      local_474 = "(null)";
    }
    else {
      local_474 = target;
    }
    style = links[cur].anchor_number;
    if (flag == 0) {
      local_46c = &DAT_081564e3;
    }
    else {
      local_46c = &DAT_081564e0;
    }
    x = links[cur].lx;
    iVar2 = links[cur].ly;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYhighlight at(%2d,%2d) %s %d [%d]:%s\n",iVar2,x,local_46c,cur,style,
            local_474);
  }
  if (0 < nlinks) {
    if ((flag == 1) || (links[cur].type == 1)) {
      LYmove(links[cur].ly + local_478,links[cur].lx);
      style = find_cached_style(cur,flag);
      curses_style(style,1);
    }
    if (links[cur].type == 1) {
      avail_space = ((LYcols - (uint)(LYShowScrollbar != '\0')) - links[cur].lx) +
                    (LYlines - links[cur].ly) * (LYcols - (uint)(LYShowScrollbar != '\0'));
      text = LYGetHiliteStr(cur,0);
      if (text == (char *)0x0) {
        text = "";
      }
      if ((links[cur].l_form)->size < avail_space) {
        avail_space = (links[cur].l_form)->size;
      }
      gllen = LYmbcsstrlen(text,utf_flag_00,'\x01');
      pcVar5 = LYmbcs_skip_cells(text,avail_space,utf_flag_00);
      LYwaddnstr(LYwin,text,(size_t)(pcVar5 + -(int)text));
      while (bVar3 = gllen < avail_space, gllen = gllen + 1, bVar3) {
        waddch(LYwin,0x5f);
      }
    }
    else {
      if (flag == 0) {
        bVar4 = true;
        redraw_lines_of_link(cur);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          style = links[cur].lx;
          x = links[cur].ly;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"STYLE.highlight.off: NOFIX branch @(%d,%d).\n",x,style);
        }
      }
      else {
        x = LYcols - (uint)(LYShowScrollbar != '\0');
        style = links[cur].lx;
        pcVar5 = LYGetHiliteStr(cur,0);
        if (pcVar5 == (char *)0x0) {
          local_460 = "";
        }
        else {
          local_460 = LYGetHiliteStr(cur,0);
        }
        LYmbcsstrncpy(buffer,local_460,0x3ff,x - style,utf_flag_00);
        len_00 = strlen(buffer);
        LYwaddnstr(LYwin,buffer,len_00);
      }
    }
    if (!bVar4) {
      hi_count = 1;
      while ((pcVar5 = LYGetHiliteStr(cur,hi_count), pcVar5 != (char *)0x0 &&
             (links[cur].ly + hi_count <= display_lines))) {
        style = links[cur].ly + hi_count + local_478;
        x = LYGetHilitePos(cur,hi_count);
        lynx_stop_link_color((uint)(flag == 1),(int)links[cur].inUnderline);
        LYmove(style,x);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          if (flag == 1) {
            local_45c = s_alink;
          }
          else {
            local_45c = s_a;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"STYLE.highlight.line2: @(%d,%d), style=%d.\n",style,x,local_45c)
          ;
        }
        if (flag == 1) {
          local_458 = s_alink;
        }
        else {
          local_458 = s_a;
        }
        curses_style(local_458,2);
        i = 0;
        while ((tmp[0] = pcVar5[i], tmp[0] != '\0' && (i + x < LYcols))) {
          if ((pcVar5[i] < '\x03') || ('\b' < pcVar5[i])) {
            if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
            }
            else {
              i = i + 1;
              tmp[1] = pcVar5[i];
              len_00 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,len_00);
              tmp[1] = '\0';
            }
          }
          i = i + 1;
        }
        hi_count = hi_count + 1;
      }
      lynx_stop_link_color((uint)(flag == 1),(int)links[cur].inUnderline);
    }
    hi_count = 0;
    while (pcVar5 = LYGetHiliteStr(cur,hi_count), pcVar5 != (char *)0x0) {
      TargetEmphasisON = show_whereis_targets(flag,cur,hi_count,target,TargetEmphasisON,utf_flag_00)
      ;
      hi_count = hi_count + 1;
    }
    if (LYShowCursor == '\0') {
      LYmove(LYlines + -1,(LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
    }
    else {
      if (links[cur].lx < 1) {
        local_454 = 0;
      }
      else {
        local_454 = links[cur].lx + -1;
      }
      LYmove(links[cur].ly + local_478,local_454);
    }
    if (flag != 0) {
      LYrefresh();
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void free_and_clear(char **pointer)

{
  if (*pointer != (char *)0x0) {
    if (*pointer != (char *)0x0) {
      free(*pointer);
      *pointer = (char *)0x0;
    }
    *pointer = (char *)0x0;
  }
  return;
}



void convert_to_spaces(char *string,BOOLEAN condense)

{
  char cVar1;
  bool bVar2;
  char *ns;
  char *s;
  BOOLEAN last_is_space;
  
  bVar2 = false;
  if (string != (char *)0x0) {
    ns = LYSkipNonBlanks(string);
    s = ns;
    while (*s != '\0') {
      cVar1 = *s;
      if (cVar1 == '\n') {
LAB_080936ba:
        if (!bVar2) {
          *ns = ' ';
          ns = ns + 1;
          bVar2 = true;
        }
      }
      else {
        if (cVar1 < '\v') {
          if (cVar1 == '\t') {
LAB_0809369e:
            if ((condense == '\0') || (!bVar2)) {
              *ns = ' ';
              ns = ns + 1;
            }
            bVar2 = true;
            goto LAB_080936e3;
          }
        }
        else {
          if (cVar1 == '\r') goto LAB_080936ba;
          if (cVar1 == ' ') goto LAB_0809369e;
        }
        *ns = *s;
        ns = ns + 1;
        bVar2 = false;
      }
LAB_080936e3:
      s = s + 1;
    }
    *ns = '\0';
  }
  return;
}



char * strip_trailing_slash(char *dirname)

{
  int i;
  
  i = strlen(dirname);
  while ((i = i - 1, -1 < i && (dirname[i] == '/'))) {
    dirname[i] = '\0';
  }
  return dirname;
}



void remove_most_blanks(char *buffer)

{
  bool bVar1;
  size_t sVar2;
  undefined *local_28;
  size_t local_24;
  int length;
  BOOLEAN trailing;
  
  sVar2 = strlen(buffer);
  if ((sVar2 == 0) || (buffer[sVar2 - 1] != ' ')) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  LYReduceBlanks(buffer);
  if (bVar1) {
    local_24 = 2;
    local_28 = &DAT_0815656c;
    sVar2 = strlen(buffer);
    memcpy(buffer + sVar2,local_28,local_24);
  }
  return;
}



void statusline(char *text)

{
  bool bVar1;
  size_t len_00;
  uchar *euc;
  char *__s2;
  int iVar2;
  int in_GS_OFFSET;
  int local_84c;
  int local_848;
  uint local_844;
  int local_840;
  int a;
  int x;
  int y;
  char *p;
  int at_lineno;
  int j;
  int i;
  int len;
  int max_length;
  uchar *temp;
  BOOLEAN has_CJK;
  uchar k;
  char text_buff [1024];
  char buffer [1024];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  if (((text != (char *)0x0) && (dump_output_immediately == '\0')) &&
     ((mustshow == '\x01' || (no_statusline != '\x01')))) {
    mustshow = '\0';
    LYstrncpy(text_buff,text,0x3ff);
    strchr(text_buff,10);
    local_84c = (LYcols - (uint)(LYShowScrollbar != '\0')) + -1;
    if (0x3ff < local_84c) {
      local_84c = 0x3ff;
    }
    if ((text_buff[0] == '\0') || (LYHaveCJKCharacterSet == '\0')) {
      remove_most_blanks(text_buff);
      len = strlen(text_buff);
      if (0x3fe < len) {
        len = 0x3ff;
      }
      __s2 = strncpy(buffer,text_buff,len);
      __s2[len] = '\0';
      while ((0 < len && (iVar2 = LYstrExtent(buffer,len,len), local_84c < iVar2))) {
        text_buff[len + 0x3ff] = '\0';
        len = len + -1;
      }
    }
    else {
      len_00 = strlen(text_buff);
      euc = (uchar *)calloc(len_00 + 1,1);
      if (euc == (uchar *)0x0) {
        outofmem("./LYUtils.c","statusline");
      }
      if (kanji_code == EUC) {
        TO_EUC((uchar *)text_buff,euc);
      }
      else {
        if (kanji_code == SJIS) {
          strcpy((char *)euc,text_buff);
        }
        else {
          i = 0;
          j = 0;
          while (text_buff[i] != '\0') {
            if (text_buff[i] != '\x1b') {
              euc[j] = text_buff[i];
              j = j + 1;
            }
            i = i + 1;
          }
          euc[j] = '\0';
        }
      }
      remove_most_blanks((char *)euc);
      i = 0;
      j = 0;
      len = 0;
      k = '\0';
      while ((euc[i] != '\0' && (len < local_84c))) {
        if (k == '\0') {
          if ((char)euc[i] < '\0') {
            k = euc[i];
          }
          else {
            buffer[j] = euc[i];
            j = j + 1;
            len = len + 1;
          }
        }
        else {
          buffer[j] = k;
          buffer[j + 1] = euc[i];
          j = j + 2;
          k = '\0';
          len = len + 2;
        }
        i = i + 1;
      }
      buffer[j] = '\0';
      if (euc != (uchar *)0x0) {
        free(euc);
      }
    }
    if (LYStatusLine < 0) {
      if (user_mode == 0) {
        at_lineno = LYlines + -3;
      }
      else {
        at_lineno = LYlines + -1;
      }
    }
    else {
      if (LYStatusLine < LYlines + -1) {
        at_lineno = LYStatusLine;
      }
      else {
        at_lineno = LYlines + -1;
      }
    }
    LYmove(at_lineno,0);
    LYclrtoeol();
    if (buffer[0] != '\0') {
      bVar1 = false;
      if (HTCJK != NOCJK) {
        i = 0;
        while (buffer[i] != '\0') {
          if (buffer[i] < '\0') {
            bVar1 = true;
            break;
          }
          i = i + 1;
        }
      }
      if (bVar1) {
        LYrefresh();
      }
      __s2 = (char *)gettext("Alert!: %s");
      iVar2 = strncmp(buffer,__s2,5);
      if ((iVar2 == 0) && (hashStyles[s_alert].name != (char *)0x0)) {
        local_848 = s_alert;
      }
      else {
        local_848 = s_status;
      }
      curses_style(local_848,1);
      len_00 = strlen(buffer);
      LYwaddnstr(LYwin,buffer,len_00);
      if ((lynx_has_color == 0) || (LYShowColor < 2)) {
        local_844 = 0x20;
      }
      else {
        local_844 = hashStyles[local_848].color | 0x20;
      }
      wbkgdset(LYwin,local_844);
      if (LYwin == (WINDOW *)0x0) {
        local_840 = -1;
      }
      else {
        local_840 = (int)LYwin->_cury;
      }
      if (local_840 == at_lineno) {
        LYclrtoeol();
      }
      if ((lynx_has_color == 0) || (LYShowColor < 2)) {
        wbkgdset(LYwin,0x20);
      }
      else {
        if (s_normal == -1) {
          wbkgdset(LYwin,displayStyles[128].color | 0x20);
        }
        else {
          wbkgdset(LYwin,hashStyles[s_normal].color | 0x20);
        }
      }
      curses_style(local_848,0);
    }
    LYrefresh();
  }
  if (local_8 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * novice_lines(int lineno)

{
  char *local_8;
  
  if (lineno == 1) {
    local_8 = (char *)gettext(
                             "  O)ther cmds  B)ack  E)dit  D)ownload ^R)eload ^W)ipe screen  search doc: / \n"
                             );
  }
  else {
    if (lineno == 2) {
      local_8 = (char *)gettext(
                               "O)ther cmds  C)omment  History: <backspace>  Bookmarks: V)iew, A)dd, R)emove \n"
                               );
    }
    else {
      if (lineno == 0) {
        local_8 = (char *)gettext(
                                 "  O)ther cmds  H)elp  K)eymap  G)oto  P)rint  M)ain screen  o)ptions  Q)uit  \n"
                                 );
      }
      else {
        local_8 = "";
      }
    }
  }
  return local_8;
}



void toggle_novice_line(void)

{
  char *pcVar1;
  
  lineno = lineno + 1;
  pcVar1 = novice_lines(lineno);
  if (*pcVar1 == '\0') {
    lineno = 0;
  }
  return;
}



void noviceline(int more_flag)

{
  size_t len;
  char *__s;
  
  if (dump_output_immediately == '\0') {
    LYmove(LYlines + -2,0);
    LYclrtoeol();
    __s = (char *)gettext(
                         "  Arrow keys: Up and Down to move.  Right to follow a link; Left to go back.  \n"
                         );
    len = strlen(__s);
    __s = (char *)gettext(
                         "  Arrow keys: Up and Down to move.  Right to follow a link; Left to go back.  \n"
                         );
    LYwaddnstr(LYwin,__s,len);
    LYmove(LYlines + -1,0);
    LYclrtoeol();
    if ((lynx_edit_mode == '\0') || (no_dired_support != '\0')) {
      if (LYUseNoviceLineTwo == '\0') {
        __s = novice_lines(lineno);
        len = strlen(__s);
        __s = novice_lines(lineno);
        LYwaddnstr(LYwin,__s,len);
      }
      else {
        __s = (char *)gettext(
                             " H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history list \n"
                             );
        len = strlen(__s);
        __s = (char *)gettext(
                             " H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history list \n"
                             );
        LYwaddnstr(LYwin,__s,len);
      }
    }
    else {
      __s = (char *)gettext(
                           "  C)reate  D)ownload  E)dit  F)ull menu  M)odify  R)emove  T)ag  U)pload     \n"
                           );
      len = strlen(__s);
      __s = (char *)gettext(
                           "  C)reate  D)ownload  E)dit  F)ull menu  M)odify  R)emove  T)ag  U)pload     \n"
                           );
      LYwaddnstr(LYwin,__s,len);
    }
    LYrefresh();
  }
  return;
}



int LYReopenInput(void)

{
  FILE *pFVar1;
  int __fd;
  FILE *__stream;
  FILE *pFVar2;
  FILE *frp;
  int new_fd;
  char *term_name;
  int fd;
  int result;
  
  result = 0;
  __fd = fileno(stdin);
  if (__fd == 0) {
    __fd = isatty(0);
    if (__fd == 0) {
      __fd = LYConsoleInputFD('\0');
      if (__fd == 0) {
        term_name = (char *)0x0;
        new_fd = -1;
        __fd = fileno(stdout);
        __fd = isatty(__fd);
        if (__fd != 0) {
          __fd = fileno(stdout);
          term_name = ttyname(__fd);
          if (term_name != (char *)0x0) {
            new_fd = open64(term_name,0);
          }
        }
        if (new_fd == -1) {
          __fd = fileno(stderr);
          __fd = isatty(__fd);
          if (__fd != 0) {
            __fd = fileno(stderr);
            term_name = ttyname(__fd);
            if (term_name != (char *)0x0) {
              new_fd = open64(term_name,0);
            }
          }
        }
        if (new_fd == -1) {
          term_name = ctermid((char *)0x0);
          if (term_name != (char *)0x0) {
            new_fd = open64(term_name,0);
          }
        }
        if (new_fd == -1) {
          term_name = "/dev/tty";
          new_fd = open64("/dev/tty",0);
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYReopenInput open(%s) returned %d.\n",term_name,new_fd);
        }
        if (new_fd < 0) {
          result = -1;
        }
        else {
          close(new_fd);
          pFVar2 = freopen64(term_name,"r",stdin);
          if (WWW_TraceFlag != '\0') {
            __fd = fileno(stdin);
            pFVar1 = stdin;
            __stream = TraceFP();
            fprintf((FILE *)__stream,
                                        
                    "LYReopenInput freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n"
                    ,term_name,pFVar2,pFVar1,__fd);
          }
          result = 1;
        }
      }
    }
  }
  return result;
}



int LYConsoleInputFD(BOOLEAN need_selectable)

{
  int iVar1;
  int local_1c;
  int fd;
  
  local_1c = fileno(stdin);
  if (((need_selectable != '\0') && (local_1c != -1)) && (iVar1 = isatty(local_1c), iVar1 == 0)) {
    local_1c = -1;
  }
  return local_1c;
}



void LYFakeZap(BOOLEAN set)

{
  int iVar1;
  FILE *__stream;
  
  if ((set == '\0') || (0 < fake_zap)) {
    if ((set == '\0') && (fake_zap != 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\r *** Unset simulated \'Z\'");
      }
      iVar1 = fake_zap;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,", %d pending",iVar1);
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream," ***\n");
      }
      fake_zap = 0;
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\r *** Set simulated \'Z\'");
    }
    iVar1 = fake_zap;
    if ((fake_zap != 0) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,", %d pending",iVar1);
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream," ***\n");
    }
    fake_zap = fake_zap + 1;
  }
  return;
}



int DontCheck(void)

{
  long last;
  BOOLEAN BVar1;
  int local_18;
  timeval tv;
  long next;
  
  if (dump_output_immediately == '\0') {
    BVar1 = LYHaveCmdScript();
    if (BVar1 == '\0') {
      gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
      if (tv.tv_usec / 100000 == last) {
        local_18 = 1;
      }
      else {
        local_18 = 0;
      }
    }
    else {
      local_18 = 1;
    }
  }
  else {
    local_18 = 1;
  }
  return local_18;
}



int HTCheckForInterrupt(void)

{
  LYKeymap_t LVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  int iVar3;
  int *piVar4;
  char *s_00;
  int local_c0;
  uint local_bc;
  uint local_b8;
  fd_set readfds;
  timeval socket_timeout;
  int Newline_partial;
  int res;
  char *s;
  fd_set *__arr;
  uint __i;
  int ret;
  int cmd;
  int c;
  BOOLEAN do_refresh;
  
  if (0 < fake_zap) {
    fake_zap = fake_zap + -1;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\r *** Got simulated \'Z\' ***\n");
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fflush((FILE *)__stream);
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(AlertSecs);
    }
    return 1;
  }
  iVar3 = DontCheck();
  if (iVar3 != 0) {
    return 0;
  }
  socket_timeout.tv_sec = 0;
  socket_timeout.tv_usec = 0;
  __i = 0;
  while (__i < 0x20) {
    readfds.fds_bits[__i] = 0;
    __i = __i + 1;
  }
  readfds.fds_bits[0] = readfds.fds_bits[0] | 1;
  iVar3 = select(1,(fd_set *)&readfds,(fd_set *)0x0,(fd_set *)0x0,(timeval *)&socket_timeout);
  if ((iVar3 == -1) && (piVar4 = __errno_location(), *piVar4 == 4)) {
    return 0;
  }
  if ((readfds.fds_bits[0] & 1U) == 0) {
    return 0;
  }
  local_b8 = LYgetch();
  if ((local_b8 == 3) || (local_b8 == 7)) {
LAB_080946b5:
    local_c0 = 1;
  }
  else {
    LVar1 = keymap[0];
    if (local_b8 == 0xffffffff) {
joined_r0x080946b3:
      if (LVar1 == 0x2f) goto LAB_080946b5;
    }
    else {
      if ((local_b8 & 0x8800) == 0) {
        LVar1 = keymap[(local_b8 & 0x7ff) + 1];
        goto joined_r0x080946b3;
      }
      if ((local_b8 & 0xff) == 0x2f) goto LAB_080946b5;
    }
    if (local_b8 == 0xffffffff) {
      local_bc = (uint)keymap[0];
    }
    else {
      if ((local_b8 & 0x8800) == 0) {
        local_b8 = (uint)keymap[(local_b8 & 0x7ff) + 1];
      }
      else {
        local_b8 = local_b8 & 0xff;
      }
      local_bc = local_b8;
    }
    if (local_bc == 0x40) {
      handle_LYK_TRACE_TOGGLE();
    }
    else {
      if (local_bc == 0x68) {
        s_00 = LYDownLoadAddress();
        if (((s_00 == (char *)0x0) || (*s_00 == '\0')) || (iVar3 = put_clip(s_00), iVar3 != 0)) {
          s_00 = (char *)gettext("Copy to clipboard failed.");
          HTInfoMsg(s_00);
        }
        else {
          s_00 = (char *)gettext("Download document URL put to clipboard.");
          HTInfoMsg(s_00);
        }
      }
      else {
        if ((display_partial != '\0') && (2 < NumOfLines_partial)) {
          Newline_partial = LYGetNewline();
          switch(local_bc) {
          case 0xf:
            BVar2 = HText_canScrollDown();
            if (BVar2 != '\0') {
              Newline_partial = Newline_partial + display_lines;
            }
            break;
          case 0x10:
            if (1 < Newline_partial) {
              Newline_partial = Newline_partial - display_lines;
            }
            break;
          case 0x11:
            if (1 < Newline_partial) {
              Newline_partial = Newline_partial + -2;
            }
            break;
          case 0x12:
            BVar2 = HText_canScrollDown();
            if (BVar2 != '\0') {
              Newline_partial = Newline_partial + 2;
            }
            break;
          case 0x13:
            if (1 < Newline_partial) {
              Newline_partial = Newline_partial - display_lines / 2;
            }
            break;
          case 0x14:
            BVar2 = HText_canScrollDown();
            if (BVar2 != '\0') {
              Newline_partial = display_lines / 2 + Newline_partial;
            }
            break;
          case 0x15:
            break;
          case 0x16:
            if (1 < Newline_partial) {
              Newline_partial = 1;
            }
            break;
          case 0x17:
            BVar2 = HText_canScrollDown();
            if (BVar2 != '\0') {
              iVar3 = HText_getNumOfLines();
              Newline_partial = (iVar3 - display_lines) + 1;
            }
            break;
          default:
            return 0;
          case 0x1e:
            if (display_lines + 1 < Newline_partial) {
              iVar3 = HTGetLinkOrFieldStart(-1,&Newline_partial,(int *)0x0,-1,'\x01');
              if (iVar3 == 8) {
                Newline_partial = Newline_partial + 1;
              }
              else {
                if (iVar3 == 0x10) {
                  Newline_partial = Newline_partial - display_lines;
                }
              }
            }
            else {
              Newline_partial = Newline_partial - display_lines;
            }
            break;
          case 0x1f:
            BVar2 = HText_canScrollDown();
            if (BVar2 != '\0') {
              iVar3 = HText_LinksInLines(HTMainText,Newline_partial,display_lines);
              iVar3 = HTGetLinkOrFieldStart(iVar3 + -1,&Newline_partial,(int *)0x0,1,'\x01');
              if (iVar3 == 8) {
                Newline_partial = Newline_partial + 1;
              }
            }
            break;
          case 0x33:
          case 0x34:
          case 0x35:
            handle_LYK_WHEREIS(local_bc,&do_refresh);
            if (www_search_result != -1) {
              Newline_partial = www_search_result;
              www_search_result = -1;
            }
          }
          if (Newline_partial < 1) {
            Newline_partial = 1;
          }
          BVar2 = LYMainLoop_pageDisplay(Newline_partial);
          if (BVar2 != '\0') {
            NumOfLines_partial = HText_getNumOfLines();
          }
        }
      }
    }
    local_c0 = 0;
  }
  return local_c0;
}



BOOLEAN LYisAbsPath(char *path)

{
  BOOLEAN result;
  
  result = '\0';
  if ((path != (char *)0x0) && (*path != '\0')) {
    result = *path == '/';
  }
  return result;
}



BOOLEAN LYisRootPath(char *path)

{
  size_t sVar1;
  BOOLEAN local_8;
  
  sVar1 = strlen(path);
  if ((sVar1 == 1) && (*path == '/')) {
    local_8 = '\x01';
  }
  else {
    local_8 = '\0';
  }
  return local_8;
}



BOOLEAN LYisLocalFile(char *filename)

{
  char *__s;
  char *__s2;
  int iVar1;
  char *__s2_00;
  char *cp;
  char *acc_method;
  char *host;
  
  if (filename == (char *)0x0) {
    return '\0';
  }
  __s = HTParse(filename,"",8);
  if (__s == (char *)0x0) {
    return '\0';
  }
  if (*__s == '\0') {
    if (__s != (char *)0x0) {
      free(__s);
    }
    return '\0';
  }
  __s2 = strchr(__s,0x3a);
  if (__s2 != (char *)0x0) {
    *__s2 = '\0';
  }
  __s2 = HTParse(filename,"",0x10);
  if ((__s2 != (char *)0x0) && (iVar1 = strcmp("file",__s2), iVar1 == 0)) {
    iVar1 = strcmp(__s,"localhost");
    if (iVar1 != 0) {
      __s2_00 = HTHostName();
      iVar1 = strcmp(__s,__s2_00);
      if (iVar1 != 0) goto LAB_08094bf3;
    }
    if (__s != (char *)0x0) {
      free(__s);
    }
    if (__s2 != (char *)0x0) {
      free(__s2);
    }
    return '\x01';
  }
LAB_08094bf3:
  if (__s != (char *)0x0) {
    free(__s);
  }
  if (__s2 != (char *)0x0) {
    free(__s2);
  }
  return '\0';
}



BOOLEAN LYisLocalHost(char *filename)

{
  char *__s;
  char *__s2;
  int iVar1;
  BOOLEAN local_15;
  char *cp;
  char *host;
  
  if (filename == (char *)0x0) {
    local_15 = '\0';
  }
  else {
    __s = HTParse(filename,"",8);
    if (__s == (char *)0x0) {
      local_15 = '\0';
    }
    else {
      if (*__s == '\0') {
        if (__s != (char *)0x0) {
          free(__s);
        }
        local_15 = '\0';
      }
      else {
        __s2 = strchr(__s,0x3a);
        if (__s2 != (char *)0x0) {
          *__s2 = '\0';
        }
        iVar1 = strcmp(__s,"localhost");
        if ((iVar1 != 0) && (iVar1 = strcmp(__s,LYHostName), iVar1 != 0)) {
          __s2 = HTHostName();
          iVar1 = strcmp(__s,__s2);
          if (iVar1 != 0) {
            if (__s != (char *)0x0) {
              free(__s);
            }
            return '\0';
          }
        }
        if (__s != (char *)0x0) {
          free(__s);
        }
        local_15 = '\x01';
      }
    }
  }
  return local_15;
}



void LYFreeStringList(HTList *list)

{
  void *local_18;
  HTList *cur;
  char *argument;
  
  if (list != (HTList *)0x0) {
    cur = list;
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void *)0x0;
      }
      else {
        local_18 = cur->object;
      }
      if (local_18 == (void *)0x0) break;
      if (local_18 != (void *)0x0) {
        free(local_18);
      }
    }
    HTList_delete(list);
  }
  return;
}



void LYLocalhostAliases_free(void)

{
  LYFreeStringList(localhost_aliases);
  localhost_aliases = (HTList *)0x0;
  return;
}



void LYAddLocalhostAlias(char *alias)

{
  char *LocalAlias;
  
  LocalAlias = (char *)0x0;
  if ((alias != (char *)0x0) && (*alias != '\0')) {
    if (localhost_aliases == (HTList *)0x0) {
      localhost_aliases = HTList_new();
    }
    HTSACopy(&LocalAlias,alias);
    HTList_addObject(localhost_aliases,LocalAlias);
  }
  return;
}



BOOLEAN LYisLocalAlias(char *filename)

{
  char *__s;
  char *pcVar1;
  int iVar2;
  BOOLEAN local_19;
  char *local_18;
  HTList *cur;
  char *cp;
  char *alias;
  char *host;
  
  cur = localhost_aliases;
  if ((localhost_aliases == (HTList *)0x0) || (filename == (char *)0x0)) {
    local_19 = '\0';
  }
  else {
    __s = HTParse(filename,"",8);
    if (__s == (char *)0x0) {
      local_19 = '\0';
    }
    else {
      if (*__s == '\0') {
        if (__s != (char *)0x0) {
          free(__s);
        }
        local_19 = '\0';
      }
      else {
        pcVar1 = strchr(__s,0x3a);
        if (pcVar1 != (char *)0x0) {
          *pcVar1 = '\0';
        }
        do {
          if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
            local_18 = (char *)0x0;
          }
          else {
            local_18 = (char *)cur->object;
          }
          if (local_18 == (char *)0x0) {
            if (__s != (char *)0x0) {
              free(__s);
            }
            return '\0';
          }
          iVar2 = strcmp(__s,local_18);
        } while (iVar2 != 0);
        if (__s != (char *)0x0) {
          free(__s);
        }
        local_19 = '\x01';
      }
    }
  }
  return local_19;
}



UrlTypes LYCheckForProxyURL(char *filename)

{
  char *src;
  char *pcVar1;
  ushort **ppuVar2;
  char *cp2;
  char *cp1;
  char *cp;
  
  cp2 = (char *)0x0;
  if ((filename == (char *)0x0) || (*filename == '\0')) {
    return NOT_A_URL_TYPE;
  }
  src = LYSkipBlanks(filename);
  cp1 = strchr(src + 1,0x3a);
  if (cp1 != (char *)0x0) {
    pcVar1 = strchr(src + 1,0x2f);
    if ((pcVar1 != (char *)0x0) && (pcVar1 < cp1)) {
      return NOT_A_URL_TYPE;
    }
    *cp1 = '\0';
    cp2 = (char *)0x0;
    HTSACopy(&cp2,src);
    *cp1 = ':';
    HTSACat(&cp2,"_proxy");
    pcVar1 = LYGetEnv(cp2);
    if (pcVar1 != (char *)0x0) {
      if (cp2 != (char *)0x0) {
        free(cp2);
      }
      return PROXY_URL_TYPE;
    }
    if (cp2 != (char *)0x0) {
      free(cp2);
      cp2 = (char *)0x0;
    }
    cp1 = cp1 + 1;
    if (*src == '\0') {
      return NOT_A_URL_TYPE;
    }
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[(byte)*cp1] & 0x800) == 0) {
      return UNKNOWN_URL_TYPE;
    }
    while ((*cp1 != '\0' && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*cp1] & 0x800) != 0))) {
      cp1 = cp1 + 1;
    }
    if ((*cp1 != '\0') && (*cp1 != '/')) {
      return UNKNOWN_URL_TYPE;
    }
  }
  return NOT_A_URL_TYPE;
}



BOOLEAN compare_type(char *tst,char *cmp,size_t len)

{
  int iVar1;
  BOOLEAN local_15;
  size_t i;
  
  iVar1 = strncasecomp(tst,cmp,len);
  if (iVar1 == 0) {
    iVar1 = strncmp(tst,cmp,len);
    if (iVar1 != 0) {
      i = 0;
      while (i < len) {
        tst[i] = cmp[i];
        i = i + 1;
      }
    }
    local_15 = '\x01';
  }
  else {
    local_15 = '\0';
  }
  return local_15;
}



UrlTypes is_url(char *filename)

{
  BOOLEAN BVar1;
  char *__s;
  size_t sVar2;
  char *pcVar3;
  ushort **ppuVar4;
  int iVar5;
  int limit;
  int len;
  UrlTypes result;
  char *cp1;
  char *cp;
  
  result = NOT_A_URL_TYPE;
  if ((filename == (char *)0x0) || (*filename == '\0')) {
    return NOT_A_URL_TYPE;
  }
  __s = strchr(filename,0x3a);
  if (__s == (char *)0x0) {
    return NOT_A_URL_TYPE;
  }
  __s = LYSkipBlanks(filename);
  if ((*__s == ':') || (*__s == '/')) {
    return NOT_A_URL_TYPE;
  }
  sVar2 = strlen(__s);
  switch(*__s) {
  case 'B':
  case 'b':
    BVar1 = compare_type(__s,"bibp:",5);
    if (BVar1 != '\0') {
      result = BIBP_URL_TYPE;
    }
    break;
  default:
    if ((2 < (int)sVar2) &&
       (((pcVar3 = strchr(__s + 3,0x3a), pcVar3 == (char *)0x0 || (pcVar3[1] != '/')) ||
        (pcVar3[2] != '/')))) {
      if (((pcVar3 != (char *)0x0) && (1 < (int)(pcVar3 + -(int)__s))) &&
         (BVar1 = LYisAbsPath(pcVar3 + 1), BVar1 != '\0')) {
        result = NCFTP_URL_TYPE;
      }
      break;
    }
    switch(*__s) {
    case 'A':
    case 'a':
      BVar1 = compare_type(__s,"afs:",4);
      if (BVar1 != '\0') {
        result = AFS_URL_TYPE;
      }
      break;
    case 'C':
    case 'c':
      BVar1 = compare_type(__s,"cso:",4);
      if (BVar1 != '\0') {
        result = CSO_URL_TYPE;
      }
      break;
    case 'G':
    case 'g':
      BVar1 = compare_type(__s,"gopher:",7);
      if (BVar1 == '\0') break;
      sVar2 = strlen(__s);
      if ((sVar2 < 0xb) || (__s = strchr(__s + 0xb,0x2f), __s == (char *)0x0)) {
        result = GOPHER_URL_TYPE;
        break;
      }
      ppuVar4 = __ctype_b_loc();
      if (((*ppuVar4)[(byte)__s[1]] & 0x200) == 0) {
        if (__s[1] != 'H') goto LAB_0809592e;
      }
      else {
        iVar5 = toupper((uint)(byte)__s[1]);
        if (iVar5 != 0x48) {
LAB_0809592e:
          if (__s[1] != 'w') {
            if ((__s[1] == 'T') || (__s[1] == '8')) {
              result = TELNET_GOPHER_URL_TYPE;
            }
            else {
              if (__s[1] == '7') {
                result = INDEX_GOPHER_URL_TYPE;
              }
              else {
                result = GOPHER_URL_TYPE;
              }
            }
            break;
          }
        }
      }
      result = HTML_GOPHER_URL_TYPE;
      break;
    case 'H':
    case 'h':
      BVar1 = compare_type(__s,"http:",5);
      if (BVar1 == '\0') {
        BVar1 = compare_type(__s,"https:",6);
        if (BVar1 != '\0') {
          result = HTTPS_URL_TYPE;
        }
      }
      else {
        result = HTTP_URL_TYPE;
      }
      break;
    case 'P':
    case 'p':
      BVar1 = compare_type(__s,"prospero:",9);
      if (BVar1 != '\0') {
        result = PROSPERO_URL_TYPE;
      }
      break;
    case 'R':
    case 'r':
      BVar1 = compare_type(__s,"rlogin:",7);
      if (BVar1 != '\0') {
        result = RLOGIN_URL_TYPE;
      }
      break;
    case 'T':
    case 't':
      BVar1 = compare_type(__s,"telnet:",7);
      if (BVar1 == '\0') {
        BVar1 = compare_type(__s,"tn3270:",7);
        if (BVar1 != '\0') {
          result = TN3270_URL_TYPE;
        }
      }
      else {
        result = TELNET_URL_TYPE;
      }
      break;
    case 'W':
    case 'w':
      BVar1 = compare_type(__s,"wais:",5);
      if (BVar1 != '\0') {
        result = WAIS_URL_TYPE;
      }
    }
    break;
  case 'D':
  case 'd':
    BVar1 = compare_type(__s,"data:",5);
    if (BVar1 != '\0') {
      result = DATA_URL_TYPE;
    }
    break;
  case 'F':
  case 'f':
    BVar1 = compare_type(__s,"file:",5);
    if (BVar1 == '\0') {
      if (((((int)sVar2 < 6) || (__s[4] != '/')) || (__s[5] != '/')) ||
         (BVar1 = compare_type(__s,"ftp:",4), BVar1 == '\0')) {
        if (((8 < (int)sVar2) && (__s[7] == '/')) &&
           ((__s[8] == '/' && (BVar1 = compare_type(__s,"finger:",7), BVar1 != '\0')))) {
          result = FINGER_URL_TYPE;
        }
      }
      else {
        result = FTP_URL_TYPE;
      }
    }
    else {
      BVar1 = LYisLocalFile(__s);
      if (BVar1 == '\0') {
        if ((__s[5] == '/') && (__s[6] == '/')) {
          result = FTP_URL_TYPE;
        }
      }
      else {
        result = FILE_URL_TYPE;
      }
    }
    break;
  case 'L':
  case 'l':
    BVar1 = compare_type(__s,"lynxexec:",9);
    if (BVar1 == '\0') {
      BVar1 = compare_type(__s,"lynxprog:",9);
      if (BVar1 == '\0') {
        BVar1 = compare_type(__s,"lynxcgi:",8);
        if (BVar1 == '\0') {
          BVar1 = compare_type(__s,"LYNXPRINT:",10);
          if (BVar1 == '\0') {
            BVar1 = compare_type(__s,"LYNXOPTIONS:",0xc);
            if (BVar1 == '\0') {
              BVar1 = compare_type(__s,"LYNXCFG:",8);
              if (BVar1 == '\0') {
                BVar1 = compare_type(__s,"LYNXMESSAGES:",0xd);
                if (BVar1 == '\0') {
                  BVar1 = compare_type(__s,"LYNXCOMPILEOPTS:",0x10);
                  if (BVar1 == '\0') {
                    BVar1 = compare_type(__s,"LYNXDOWNLOAD:",0xd);
                    if (BVar1 == '\0') {
                      BVar1 = compare_type(__s,"LYNXDIRED:",10);
                      if (BVar1 == '\0') {
                        BVar1 = compare_type(__s,"LYNXHIST:",9);
                        if (BVar1 == '\0') {
                          BVar1 = compare_type(__s,"LYNXKEYMAP:",0xb);
                          if (BVar1 == '\0') {
                            BVar1 = compare_type(__s,"LYNXIMGMAP:",0xb);
                            if (BVar1 == '\0') {
                              BVar1 = compare_type(__s,"LYNXCOOKIE:",0xb);
                              if (BVar1 != '\0') {
                                result = LYNXCOOKIE_URL_TYPE;
                              }
                            }
                            else {
                              is_url(__s + 0xb);
                              result = LYNXIMGMAP_URL_TYPE;
                            }
                          }
                          else {
                            result = LYNXKEYMAP_URL_TYPE;
                          }
                        }
                        else {
                          result = LYNXHIST_URL_TYPE;
                        }
                      }
                      else {
                        result = LYNXDIRED_URL_TYPE;
                      }
                    }
                    else {
                      result = LYNXDOWNLOAD_URL_TYPE;
                    }
                  }
                  else {
                    result = LYNXCOMPILE_OPTS_URL_TYPE;
                  }
                }
                else {
                  result = LYNXMESSAGES_URL_TYPE;
                }
              }
              else {
                result = LYNXCFG_URL_TYPE;
              }
            }
            else {
              result = LYNXOPTIONS_URL_TYPE;
            }
          }
          else {
            result = LYNXPRINT_URL_TYPE;
          }
        }
        else {
          result = LYNXCGI_URL_TYPE;
        }
      }
      else {
        result = LYNXPROG_URL_TYPE;
      }
    }
    else {
      result = LYNXEXEC_URL_TYPE;
    }
    break;
  case 'M':
  case 'm':
    BVar1 = compare_type(__s,"mailto:",7);
    if (BVar1 != '\0') {
      result = MAILTO_URL_TYPE;
    }
    break;
  case 'N':
  case 'n':
    BVar1 = compare_type(__s,"news:",5);
    if (BVar1 == '\0') {
      BVar1 = compare_type(__s,"nntp:",5);
      if (BVar1 == '\0') {
        BVar1 = compare_type(__s,"newspost:",9);
        if (BVar1 == '\0') {
          BVar1 = compare_type(__s,"newsreply:",10);
          if (BVar1 != '\0') {
            result = NEWSREPLY_URL_TYPE;
          }
        }
        else {
          result = NEWSPOST_URL_TYPE;
        }
      }
      else {
        result = NNTP_URL_TYPE;
      }
    }
    else {
      result = NEWS_URL_TYPE;
    }
    break;
  case 'S':
  case 's':
    BVar1 = compare_type(__s,"snews:",6);
    if (BVar1 == '\0') {
      BVar1 = compare_type(__s,"snewspost:",10);
      if (BVar1 == '\0') {
        BVar1 = compare_type(__s,"snewsreply:",0xb);
        if (BVar1 != '\0') {
          result = NEWSREPLY_URL_TYPE;
        }
      }
      else {
        result = NEWSPOST_URL_TYPE;
      }
    }
    else {
      result = SNEWS_URL_TYPE;
    }
  }
  if (result == NOT_A_URL_TYPE) {
    result = LYCheckForProxyURL(filename);
  }
  return result;
}



void LYFixCursesOn(char *reason)

{
  FILE *__stream;
  
  if ((dump_output_immediately == '\0') && (LYCursesON == '\0')) {
    if ((reason != (char *)0x0) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Forcing curses on to %s\n",reason);
    }
    start_curses();
  }
  return;
}



BOOLEAN LYFixCursesOnForAccess(char *addr,char *physical)

{
  char *Msg;
  int iVar1;
  char *cp1;
  
  if (((((dump_output_immediately == '\0') && (LYCursesON == '\0')) && (physical != (char *)0x0)) &&
      ((Msg = strstr(addr,"://"), Msg != (char *)0x0 &&
       ((((iVar1 = strncasecomp(addr,"telnet:",7), iVar1 == 0 ||
          (iVar1 = strncasecomp(addr,"rlogin:",7), iVar1 == 0)) ||
         (iVar1 = strncasecomp(addr,"tn3270:",7), iVar1 == 0)) ||
        (((iVar1 = strncasecomp(addr,"gopher:",7), iVar1 != 0 &&
          (Msg = strchr(addr + 0xb,0x2f), Msg != (char *)0x0)) &&
         ((Msg[1] == 'T' || (Msg[1] == '8')))))))))) &&
     (((iVar1 = strncasecomp(physical,"telnet:",7), iVar1 != 0 &&
       (iVar1 = strncasecomp(physical,"rlogin:",7), iVar1 != 0)) &&
      (iVar1 = strncasecomp(physical,"tn3270:",7), iVar1 != 0)))) {
    start_curses();
    Msg = (char *)gettext("Unexpected access protocol for this URL scheme.");
    HTAlert(Msg);
    return '\x01';
  }
  return '\0';
}



BOOLEAN LYCanDoHEAD(char *address)

{
  BOOLEAN BVar1;
  int iVar2;
  UrlTypes UVar3;
  char *__s;
  char *__s_00;
  char *pcVar4;
  ushort **ppuVar5;
  BOOLEAN local_29;
  char *local_28;
  char *proxy;
  char *acc_method;
  char *cp;
  char *temp;
  int isurl;
  char *temp0;
  
  temp0 = (char *)0x0;
  if ((address == (char *)0x0) || (*address == '\0')) {
    local_29 = '\0';
  }
  else {
    iVar2 = strncmp(address,"http",4);
    if (iVar2 == 0) {
      local_29 = '\x01';
    }
    else {
      HTSACopy(&temp0,address);
      UVar3 = is_url(temp0);
      if (UVar3 == NOT_A_URL_TYPE) {
        if (temp0 != (char *)0x0) {
          free(temp0);
        }
        local_29 = '\0';
      }
      else {
        if (UVar3 == LYNXCGI_URL_TYPE) {
          if (temp0 != (char *)0x0) {
            free(temp0);
          }
          local_29 = '\x01';
        }
        else {
          if ((UVar3 == NEWS_URL_TYPE) || (UVar3 == NNTP_URL_TYPE)) {
            __s = HTParse(address,"",4);
            __s_00 = strrchr(__s,0x2f);
            local_28 = __s;
            if (__s_00 != (char *)0x0) {
              local_28 = __s_00;
            }
            pcVar4 = strchr(local_28,0x40);
            if (pcVar4 != (char *)0x0) {
              if (temp0 != (char *)0x0) {
                free(temp0);
                temp0 = (char *)0x0;
              }
              if (__s != (char *)0x0) {
                free(__s);
              }
              return '\x01';
            }
            if (((__s_00 != (char *)0x0) &&
                (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)__s_00[1]] & 0x800) != 0)) &&
               (__s_00 = strchr(__s_00,0x2d), __s_00 == (char *)0x0)) {
              if (temp0 != (char *)0x0) {
                free(temp0);
                temp0 = (char *)0x0;
              }
              if (__s != (char *)0x0) {
                free(__s);
              }
              return '\x01';
            }
            if (__s != (char *)0x0) {
              free(__s);
            }
          }
          if (UVar3 != FILE_URL_TYPE) {
            acc_method = HTParse(temp0,"",0x10);
            if ((acc_method != (char *)0x0) && (*acc_method != '\0')) {
              HTSACat(&acc_method,"_proxy");
              __s = LYGetEnv(acc_method);
              if ((__s != (char *)0x0) &&
                 (((iVar2 = strncasecomp(__s,"http:",5), iVar2 == 0 ||
                   (((*__s == 'l' || (*__s == 'L')) &&
                    (iVar2 = strncasecomp(__s,"lynxcgi:",8), iVar2 == 0)))) &&
                  (BVar1 = override_proxy(temp0), BVar1 == '\0')))) {
                if (temp0 != (char *)0x0) {
                  free(temp0);
                  temp0 = (char *)0x0;
                }
                if (acc_method != (char *)0x0) {
                  free(acc_method);
                }
                return '\x01';
              }
            }
            if (acc_method != (char *)0x0) {
              free(acc_method);
              acc_method = (char *)0x0;
            }
          }
          if (temp0 != (char *)0x0) {
            free(temp0);
          }
          local_29 = '\0';
        }
      }
    }
  }
  return local_29;
}



BOOLEAN LYCloseInput(FILE *fp)

{
  int iVar1;
  int err;
  
  if (fp != (FILE *)0x0) {
    iVar1 = ferror((FILE *)fp);
    fclose((FILE *)fp);
    if (iVar1 == 0) {
      return '\x01';
    }
  }
  return '\0';
}



BOOLEAN LYCloseOutput(FILE *fp)

{
  int iVar1;
  char *Msg;
  int err;
  
  if (fp != (FILE *)0x0) {
    iVar1 = ferror((FILE *)fp);
    fclose((FILE *)fp);
    if (iVar1 == 0) {
      return '\x01';
    }
  }
  Msg = (char *)gettext("Cannot write to file.");
  HTAlert(Msg);
  return '\0';
}



BOOLEAN LYCanWriteFile(char *filename)

{
  BOOLEAN BVar1;
  FILE *fp;
  char *text;
  bool local_5;
  
  fp = (FILE *)fopen64(filename,"w");
  BVar1 = LYCloseOutput(fp);
  if (BVar1 == '\0') {
    mustshow = '\x01';
    text = (char *)gettext("Enter a new filename: ");
    statusline(text);
  }
  else {
    remove(filename);
  }
  local_5 = BVar1 != '\0';
  return (BOOLEAN)local_5;
}



BOOLEAN LYCanReadFile(char *filename)

{
  BOOLEAN BVar1;
  FILE *fp_00;
  FILE *fp;
  
  if (((filename != (char *)0x0) && (*filename != '\0')) &&
     (fp_00 = (FILE *)fopen64(filename,"r"), fp_00 != (FILE *)0x0)) {
    BVar1 = LYCloseInput(fp_00);
    return BVar1;
  }
  return '\0';
}



void remove_backslashes(char *buf)

{
  char *cp;
  
  cp = buf;
  while (*cp != '\0') {
    if (*cp == '\\') {
      if ((*cp == '\\') && (cp[1] == '\\')) {
        *buf = *cp;
        buf = buf + 1;
      }
    }
    else {
      *buf = *cp;
      buf = buf + 1;
    }
    cp = cp + 1;
  }
  *buf = '\0';
  return;
}



// WARNING: Could not reconcile some variable overlaps

BOOLEAN inlocaldomain(void)

{
  int iVar1;
  size_t sVar2;
  int iVar3;
  size_t sVar4;
  FILE *fp_00;
  int in_GS_OFFSET;
  char *local_1ac;
  char *mytty;
  char *cp;
  FILE *fp;
  int n;
  int result;
  utmp me;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  mytty = (char *)0x0;
  local_1ac = ttyname(0);
  if (local_1ac != (char *)0x0) {
    mytty = LYLastPathSep(local_1ac);
  }
  result._0_1_ = '\0';
  if ((mytty == (char *)0x0) || (fp_00 = (FILE *)fopen64("/var/run/utmp","r"), fp_00 == (FILE *)0x0)
     ) {
    if (WWW_TraceFlag != '\0') {
      if (local_1ac == (char *)0x0) {
        local_1ac = "(null)";
      }
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"Could not get ttyname (returned %s) or open UTMP file %s\n",local_1ac,
              "/var/run/utmp");
    }
  }
  else {
    do {
      sVar2 = fread(&me,0x180,1,(FILE *)fp_00);
      if ((int)sVar2 < 1) break;
      iVar3 = strcmp(me.ut_line,mytty + 1);
    } while (iVar3 != 0);
    LYCloseInput(fp_00);
    if (0 < (int)sVar2) {
      sVar2 = strlen(me.ut_host);
      sVar4 = strlen(LYLocalDomain);
      if (sVar4 < sVar2) {
        sVar2 = strlen(me.ut_host);
        sVar4 = strlen(LYLocalDomain);
        iVar3 = strcmp(LYLocalDomain,(char *)((int)&me + (sVar2 - sVar4) + 0x4c));
        if (iVar3 == 0) {
          result._0_1_ = '\x01';
          goto LAB_0809638e;
        }
      }
      if (me.ut_host[0] == '\0') {
        result._0_1_ = '\x01';
      }
    }
  }
LAB_0809638e:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return (BOOLEAN)result;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Removing unreachable block (ram,0x080963ef)

void LYExtSignal(int sig,LYSigHandlerFunc_t *handler)

{
  sigaction act;
  
  if ((sig == 0x1c) && (LYNonRestartingSIGWINCH != '\0')) {
    act.__sigaction_handler = handler;
    sigemptyset((sigset_t *)&act.sa_mask);
    act.sa_flags = 0;
    sigaction(0x1c,(sigaction *)&act,(sigaction *)0x0);
  }
  else {
    signal(sig,(__sighandler_t)handler);
  }
  return;
}



BOOLEAN LYToggleSigDfl(int sig,sigaction *where,int to_dfl)

{
  int *piVar1;
  char *pcVar2;
  FILE *__stream;
  BOOLEAN local_99;
  sigaction oact;
  int rv;
  
  if (to_dfl == 1) {
    rv = sigaction(sig,(sigaction *)0x0,(sigaction *)&oact);
    if (rv == 0) {
      if (oact.__sigaction_handler == 0) {
        if (where != (sigaction *)0x0) {
          memcpy(where,&oact,0x8c);
          rv = 0;
        }
      }
      else {
        oact.__sigaction_handler = 0;
        rv = sigaction(sig,(sigaction *)&oact,(sigaction *)where);
      }
    }
  }
  else {
    rv = sigaction(sig,(sigaction *)where,(sigaction *)0x0);
  }
  if (rv == 0) {
    local_99 = '\x01';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      piVar1 = __errno_location();
      pcVar2 = strerror(*piVar1);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Error in LYToggleSigDfl: %s\n",pcVar2);
    }
    local_99 = '\0';
  }
  return local_99;
}



void size_change(int sig)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  FILE *__stream;
  winsize win;
  int old_cols;
  int old_lines;
  
  iVar3 = LYlines;
  iVar1 = LYcols;
  iVar4 = ioctl(0,0x5413,&win);
  if (iVar4 == 0) {
    if (win.ws_row != 0) {
      LYlines = ZEXT24(win.ws_row);
    }
    if (win.ws_col != 0) {
      LYcols = ZEXT24(win.ws_col);
    }
  }
  if (LYlines < 1) {
    LYlines = 0x18;
  }
  iVar4 = LYlines;
  if (LYcols < 1) {
    LYcols = 0x50;
  }
  iVar2 = LYcols;
  if (((LYlines != iVar3) || (LYcols != iVar1)) &&
     (recent_sizechange = '\x01', WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Window size changed from (%d,%d) to (%d,%d)\n",iVar3,iVar1,iVar4,iVar2
           );
  }
  LYExtSignal(0x1c,size_change);
  return;
}



void HTSugFilenames_free(void)

{
  LYFreeStringList(sug_filenames);
  sug_filenames = (HTList *)0x0;
  return;
}



void HTAddSugFilename(char *fname)

{
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *tmp;
  
  tmp = (char *)0x0;
  if ((fname != (char *)0x0) && (*fname != '\0')) {
    HTSACopy(&tmp,fname);
    if (sug_filenames == (HTList *)0x0) {
      sug_filenames = HTList_new();
      HTList_addObject(sug_filenames,tmp);
    }
    else {
      cur = sug_filenames;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) goto LAB_08096750;
        iVar1 = strcmp(local_18,tmp);
      } while (iVar1 != 0);
      HTList_removeObject(sug_filenames,local_18);
      if (local_18 != (char *)0x0) {
        free(local_18);
      }
LAB_08096750:
      HTList_addObject(sug_filenames,tmp);
    }
  }
  return;
}



void change_sug_filename(char *fname)

{
  size_t sVar1;
  char *__s;
  __pid_t _Var2;
  size_t __n;
  int iVar3;
  size_t sVar4;
  byte local_30;
  char *local_2c;
  char *end;
  char *cp1;
  char *cp;
  char *temp;
  char *cp2;
  
  temp = (char *)0x0;
  sVar1 = strlen(fname);
  HTUnEscape(fname);
  __s = wwwName(lynx_temp_space);
  if (*__s == '/') {
    _Var2 = getpid();
    HTSprintf0(&temp,"file://localhost%s%u",__s,_Var2);
  }
  else {
    _Var2 = getpid();
    HTSprintf0(&temp,"file://localhost/%s%u",__s,_Var2);
  }
  __n = strlen(temp);
  iVar3 = strncmp(fname,temp,__n);
  if (iVar3 == 0) {
    cp = strrchr(fname,0x2e);
    __n = strlen(cp);
    sVar4 = strlen(temp);
    if (sVar4 - 4 < __n) {
      cp = (char *)0x0;
    }
    if (cp == (char *)0x0) {
      local_2c = "";
    }
    else {
      local_2c = cp;
    }
    HTSACopy(&temp,local_2c);
    sprintf(fname,"temp%.*s",0xf6,temp);
  }
  if (temp != (char *)0x0) {
    free(temp);
    temp = (char *)0x0;
  }
  __n = strlen(fname);
  if (fname[__n - 1] == '/') {
    __n = strlen(fname);
    fname[__n - 1] = '\0';
  }
  cp = strrchr(fname,0x2f);
  if ((cp != (char *)0x0) && (__n = strlen(cp), 1 < __n)) {
    cp1 = fname;
    while (cp = cp + 1, *cp != '\0') {
      *cp1 = *cp;
      cp1 = cp1 + 1;
    }
    *cp1 = '\0';
  }
  if (((((fname + sVar1)[-1] == ']') && (cp = strrchr(fname,0x5b), cp != (char *)0x0)) &&
      (fname < cp)) && (cp = cp + -1, *cp == ' ')) {
    while (*cp == ' ') {
      *cp = '\0';
      cp = cp + -1;
    }
  }
  __s = strchr(fname,0x5b);
  if (((__s != (char *)0x0) && (cp1 = strrchr(__s,0x5d), cp1 != (char *)0x0)) &&
     (__n = strlen(cp1), 1 < __n)) {
    cp = fname;
    while (cp1 = cp1 + 1, *cp1 != '\0') {
      *cp = *cp1;
      cp = cp + 1;
    }
    *cp = '\0';
  }
  cp = fname;
  while (*cp != '\0') {
    if (((int)*cp - 0x20U < 0x10) &&
       (local_30 = (byte)((int)*cp - 0x20U), (1 << (local_30 & 0x1f) & 0x8085U) != 0)) {
      *cp = '-';
    }
    cp = cp + 1;
  }
  __n = strlen(fname);
  cp = fname + __n;
  while (cp < fname + sVar1) {
    *cp = '\0';
    cp = cp + 1;
  }
  return;
}



int fmt_tempname(char *result,char *prefix,char *suffix)

{
  int iVar1;
  bool bVar2;
  BOOLEAN first;
  uint counter;
  uchar used_tempname [1251];
  int names_used;
  time_t tVar3;
  long lVar4;
  uint uVar5;
  uint uVar6;
  char *Msg;
  __pid_t _Var7;
  size_t sVar8;
  size_t sVar9;
  FILE *__stream;
  int in_GS_OFFSET;
  uint local_134;
  char *local_128;
  char *local_124;
  uint mask;
  uint offset;
  int code;
  char leaf [256];
  
  local_124 = prefix;
  local_128 = suffix;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (prefix == (char *)0x0) {
    local_124 = "";
  }
  if (suffix == (char *)0x0) {
    local_128 = "";
  }
  if (first != '\0') {
    tVar3 = time((time_t *)0x0);
    srandom((uint)(result + tVar3));
    first = '\0';
  }
  counter = 10000;
  if (names_used < 10000) {
    lVar4 = random();
    local_134 = (uint)(longlong)
                      ROUND(((float)lVar4 * 10000.00000000) / 2147483648.00000000 + 1.00000000);
    counter = local_134;
    do {
      counter = counter % 10000;
      uVar5 = counter >> 3;
      uVar6 = 1 << ((byte)counter & 7);
      if ((((uchar *)&ram0x081af460)[uVar5] & uVar6) == 0) {
        names_used = names_used + 1;
        *(byte *)(uVar5 + 0x81af460) = (byte)uVar6 | *(byte *)(uVar5 + 0x81af460);
        break;
      }
    } while ((*(byte *)(uVar5 + 0x81af460) & uVar6) == 0);
  }
  if (9999 < names_used) {
    Msg = (char *)gettext("Too many tempfiles");
    HTAlert(Msg);
  }
  uVar5 = counter;
  _Var7 = getpid();
  sprintf(leaf,"L%u-%uTMP%s",_Var7,uVar5,local_128);
  sVar8 = strlen(local_124);
  sVar9 = strlen(leaf);
  bVar2 = 0xff < sVar8 + sVar9;
  if (bVar2) {
    sprintf(result,"%.*s",0xff,leaf,local_128);
  }
  else {
    sprintf(result,"%s%s",local_124,leaf,local_128);
  }
  code = ZEXT14(!bVar2);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"-> \'%s\'\n",result);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



int number2arrows(int number)

{
  switch(number) {
  case 0x31:
    number = 0x107;
    break;
  case 0x32:
    number = 0x101;
    break;
  case 0x33:
    number = 0x104;
    break;
  case 0x34:
    number = 0x103;
    break;
  case 0x35:
    number = 0x10e;
    break;
  case 0x36:
    number = 0x102;
    break;
  case 0x37:
    number = 0x106;
    break;
  case 0x38:
    number = 0x100;
    break;
  case 0x39:
    number = 0x105;
  }
  return number;
}



BOOLEAN strn_dash_equ(char *p1,char *p2,int len)

{
  char cVar1;
  bool bVar2;
  
  do {
    bVar2 = len == 0;
    len = len + -1;
    if (bVar2) {
      return '\x01';
    }
    if (*p2 == '\0') {
      return '\0';
    }
    cVar1 = *p1;
    if ((cVar1 == '-') || (cVar1 == '_')) {
      if (*p2 != '_') {
        return '\0';
      }
    }
    else {
      if (cVar1 == '\0') {
        return '\0';
      }
      if (*p1 != *p2) {
        return '\0';
      }
    }
    p1 = p1 + 1;
    p2 = p2 + 1;
  } while( true );
}



char * index_to_restriction(int inx)

{
  char *local_8;
  
  if ((inx < 0) || (0x39 < inx)) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = restrictions[inx].name;
  }
  return local_8;
}



int find_restriction(char *name,int len)

{
  BOOLEAN BVar1;
  uint i;
  
  if (len < 0) {
    len = strlen(name);
  }
  i = 0;
  while( true ) {
    if (0x39 < i) {
      return -1;
    }
    BVar1 = strn_dash_equ(name,restrictions[i].name,len);
    if (BVar1 != '\0') break;
    i = i + 1;
  }
  return (int)*restrictions[i].flag;
}



void parse_restrictions(char *s)

{
  bool bVar1;
  BOOLEAN BVar2;
  char *p1;
  undefined4 uVar3;
  uint i;
  char *word;
  char *p;
  BOOLEAN found;
  
  p = s;
  do {
    if ((*p == '\0') || (p1 = LYSkipCBlanks(p), p = p1, *p1 == '\0')) {
      if (no_shell != '\0') {
        no_goto_lynxexec = '\x01';
        no_goto_lynxprog = '\x01';
        no_goto_lynxcgi = '\x01';
        local_exec_on_local_files = '\x01';
      }
      return;
    }
    while ((*p != ',' && (*p != '\0'))) {
      p = p + 1;
    }
    bVar1 = false;
    BVar2 = strn_dash_equ(p1,"all",(int)(p + -(int)p1));
    if (BVar2 == '\0') {
      BVar2 = strn_dash_equ(p1,"default",(int)(p + -(int)p1));
      if (BVar2 == '\0') {
        i = 0;
        while (i < 0x3a) {
          BVar2 = strn_dash_equ(p1,restrictions[i].name,(int)(p + -(int)p1));
          if (BVar2 != '\0') {
            *restrictions[i].flag = '\x01';
            bVar1 = true;
            break;
          }
          i = i + 1;
        }
      }
      else {
        bVar1 = true;
        i = 2;
        while (i < 0x3a) {
          *(bool *)restrictions[i].flag = restrictions[i].can == '\0';
          i = i + 1;
        }
      }
    }
    else {
      bVar1 = true;
      i = 2;
      while (i < 0x3a) {
        *restrictions[i].flag = '\x01';
        i = i + 1;
      }
    }
    if (!bVar1) {
      uVar3 = gettext("unknown restriction");
      printf("%s: %.*s\n",uVar3,p + -(int)p1,p1);
      exit_immediately(1);
    }
    if (*p != '\0') {
      p = p + 1;
    }
  } while( true );
}



void print_restrictions_to_fd(FILE *fp)

{
  char *__format;
  int iVar1;
  uint count;
  uint i;
  
  count = 0;
  i = 0;
  while (i < 0x3a) {
    if (*restrictions[i].flag == '\x01') {
      count = count + 1;
    }
    i = i + 1;
  }
  if (count == 0) {
    __format = (char *)gettext("No restrictions set.\n");
    fprintf((FILE *)fp,__format);
  }
  else {
    __format = (char *)gettext("Restrictions set:\n");
    fprintf((FILE *)fp,__format);
    i = 0;
    while (i < 0x3a) {
      if (*restrictions[i].flag == '\x01') {
        iVar1 = strncmp(restrictions[i].name,"goto_",5);
        if ((iVar1 != 0) || (no_goto == '\0')) {
          fprintf((FILE *)fp,"   %s\n",restrictions[i].name);
        }
      }
      i = i + 1;
    }
  }
  return;
}



char * LYCheckMail(void)

{
  BOOLEAN firsttime;
  long lastsize;
  time_t lasttime;
  time_t lastcheck;
  char *mf;
  char *Msg;
  stat st;
  time_t now;
  
  if (firsttime != '\0') {
    mf = LYGetEnv("MAIL");
    firsttime = '\0';
    time((time_t *)0x81af94c);
  }
  Msg = mf;
  if (mf != (char *)0x0) {
    time(&now);
    Msg = (char *)(now - lastcheck);
    if (((((0x3b < (int)Msg) && (Msg = (char *)stat64(mf,(stat64 *)&st), -1 < (int)Msg)) &&
         (Msg = (char *)(st.st_mode & 0xf000), Msg == (char *)0x8000)) &&
        (Msg = (char *)st.st_mtim.tv_sec, -1 < st.st_size._4_4_)) &&
       ((0 < st.st_size._4_4_ || ((uint)st.st_size != 0)))) {
      if (((st.st_mtim.tv_sec == lasttime) || (st.st_mtim.tv_sec <= st.st_atim.tv_sec)) &&
         (((lastsize == 0 || (st.st_size._4_4_ < lastsize >> 0x1f)) ||
          ((st.st_size._4_4_ <= lastsize >> 0x1f && ((uint)st.st_size <= (uint)lastsize)))))) {
        if (lastsize == 0) {
          Msg = (char *)gettext("*** You have mail. ***");
          HTUserMsg(Msg);
          Msg = (char *)st.st_mtim.tv_sec;
        }
      }
      else {
        Msg = (char *)gettext("*** You have new mail. ***");
        HTUserMsg(Msg);
        Msg = (char *)st.st_mtim.tv_sec;
      }
    }
  }
  return Msg;
}



void LYEnsureAbsoluteURL(char **href,char *name,int fixit)

{
  int iVar1;
  UrlTypes UVar2;
  FILE *__stream;
  char *src;
  undefined1 *local_1c;
  char *local_18;
  char *temp;
  
  if ((*href != (char *)0x0) && (**href != '\0')) {
    LYFillLocalFileURL(href,"file://localhost");
    iVar1 = strcasecomp(*href,"news:");
    if (iVar1 == 0) {
      HTSACat(href,"*");
    }
    else {
      iVar1 = strcasecomp(*href,"snews:");
      if (iVar1 == 0) {
        HTSACat(href,"/*");
      }
    }
    UVar2 = is_url(*href);
    if (UVar2 == NOT_A_URL_TYPE) {
      if (WWW_TraceFlag != '\0') {
        src = *href;
        if (name == (char *)0x0) {
          local_1c = &DAT_08156400;
          local_18 = "";
        }
        else {
          local_1c = &DAT_0815656c;
          local_18 = name;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s%s\'%s\' is not a URL\n",local_18,local_1c,src);
      }
      LYConvertToURL(href,fixit);
    }
    src = HTParse(*href,"",0x1f);
    if ((src != (char *)0x0) && (*src != '\0')) {
      HTSACopy(href,src);
    }
    if (src != (char *)0x0) {
      free(src);
    }
  }
  return;
}



void LYConvertToURL(char **AllocatedString,int fixit)

{
  int iVar1;
  bool bVar2;
  BOOLEAN BVar3;
  char *pathname;
  FILE *__stream;
  int iVar4;
  char *pcVar5;
  int in_GS_OFFSET;
  char *local_194;
  stat st;
  char *cp2;
  char *temp2;
  char *fragment;
  char *cp;
  char *temp;
  char *old_string;
  BOOLEAN is_local;
  char curdir [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  old_string = *AllocatedString;
  temp = (char *)0x0;
  cp = (char *)0x0;
  if ((old_string == (char *)0x0) || (*old_string == '\0')) goto LAB_08098058;
  *AllocatedString = (char *)0x0;
  HTSACopy(AllocatedString,"file://localhost");
  if (*old_string == '/') {
    if (old_string[1] == '\0') {
      HTSACat(AllocatedString,"/");
    }
    else {
      iVar4 = stat64(old_string,(stat64 *)&st);
      if (iVar4 < 0) {
        BVar3 = LYCanReadFile(old_string);
        if (BVar3 == '\0') {
          if (old_string[1] == '~') {
            pathname = Home_Dir();
            pathname = wwwName(pathname);
            HTSACat(AllocatedString,pathname);
            cp = strchr(old_string + 1,0x2f);
            if (cp != (char *)0x0) {
              HTSACopy(&temp,cp);
              LYTrimRelFromAbsPath(temp);
              HTSACat(AllocatedString,temp);
              if (temp != (char *)0x0) {
                free(temp);
                temp = (char *)0x0;
              }
            }
          }
          else {
            HTSACopy(&temp,old_string);
            LYTrimRelFromAbsPath(temp);
            HTSACat(AllocatedString,temp);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
          }
          goto LAB_08097fdd;
        }
      }
      HTSACopy(&temp,old_string);
      LYTrimRelFromAbsPath(temp);
      pcVar5 = old_string;
      pathname = temp;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pcVar5,pathname);
      }
      cp = HTEscape(temp,'\x04');
      HTSACat(AllocatedString,cp);
      if (cp != (char *)0x0) {
        free(cp);
        cp = (char *)0x0;
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      pathname = old_string;
      if (WWW_TraceFlag != '\0') {
        pcVar5 = *AllocatedString;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pathname,pcVar5);
      }
    }
LAB_08097fdd:
    pathname = old_string;
    if (WWW_TraceFlag != '\0') {
      pcVar5 = *AllocatedString;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pathname,pcVar5);
    }
  }
  else {
    if (*old_string == '~') {
      pathname = Home_Dir();
      pathname = wwwName(pathname);
      HTSACat(AllocatedString,pathname);
      cp = strchr(old_string,0x2f);
      if (cp != (char *)0x0) {
        HTSACopy(&temp,cp);
        LYTrimRelFromAbsPath(temp);
        HTSACat(AllocatedString,temp);
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
      }
      pathname = old_string;
      if (WWW_TraceFlag != '\0') {
        pcVar5 = *AllocatedString;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pathname,pcVar5);
      }
    }
    else {
      temp2 = (char *)0x0;
      bVar2 = false;
      Current_Dir(curdir);
      HTSACopy(&temp,curdir);
      HTSACat(&temp,"/");
      HTSACat(&temp,old_string);
      LYTrimRelFromAbsPath(temp);
      pcVar5 = old_string;
      pathname = temp;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pcVar5,pathname);
      }
      iVar4 = stat64(temp,(stat64 *)&st);
      if (iVar4 < 0) {
        BVar3 = LYCanReadFile(temp);
        if (BVar3 != '\0') goto LAB_080977a2;
        cp2 = (char *)0x0;
        HTSACopy(&temp2,curdir);
        LYAddPathSep(&temp2);
        HTSACopy(&cp,old_string);
        pathname = trimPoundSelector(cp);
        HTUnEscape(cp);
        HTSACat(&temp2,cp);
        HTSACopy(&cp2,temp2);
        LYTrimRelFromAbsPath(temp2);
        iVar4 = strcmp(temp2,temp);
        if (iVar4 == 0) {
LAB_08097a63:
          pcVar5 = strchr(curdir,0x23);
          if (pcVar5 == (char *)0x0) {
            pcVar5 = strchr(curdir,0x25);
            if (pcVar5 == (char *)0x0) goto LAB_08097b6c;
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          iVar4 = strcmp(cp2,temp2);
          if (iVar4 == 0) {
            temp = HTEscape(curdir,'\x04');
            LYAddHtmlSep(&temp);
            HTSACat(&temp,old_string);
          }
          else {
            temp = HTEscape(temp2,'\x04');
            if (pathname != (char *)0x0) {
              if (pathname != (char *)0x0) {
                *pathname = '#';
              }
              HTSACat(&temp,pathname);
            }
          }
        }
        else {
          iVar4 = stat64(temp2,(stat64 *)&st);
          if (iVar4 < 0) {
            BVar3 = LYCanReadFile(temp2);
            if (BVar3 == '\0') goto LAB_08097a63;
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          iVar4 = strcmp(cp2,temp2);
          if (iVar4 == 0) {
            temp = HTEscape(curdir,'\x04');
            LYAddHtmlSep(&temp);
            HTSACat(&temp,old_string);
          }
          else {
            temp = HTEscape(temp2,'\x04');
            if (pathname != (char *)0x0) {
              if (pathname != (char *)0x0) {
                *pathname = '#';
              }
              HTSACat(&temp,pathname);
            }
          }
          HTSACat(AllocatedString,temp);
          pathname = old_string;
          if (WWW_TraceFlag != '\0') {
            pcVar5 = *AllocatedString;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pathname,pcVar5);
          }
          bVar2 = true;
        }
LAB_08097b6c:
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        if (cp2 != (char *)0x0) {
          free(cp2);
          cp2 = (char *)0x0;
        }
      }
      else {
LAB_080977a2:
        cp = HTEscape(temp,'\x04');
        HTSACat(AllocatedString,cp);
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        pathname = old_string;
        if (WWW_TraceFlag != '\0') {
          pcVar5 = *AllocatedString;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Converted \'%s\' to \'%s\'\n",pathname,pcVar5);
        }
        bVar2 = true;
      }
      if (!bVar2) {
        if (WWW_TraceFlag != '\0') {
          if (temp2 == (char *)0x0) {
            local_194 = temp;
          }
          else {
            local_194 = temp2;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Can\'t stat() or fopen() \'%s\'\n",local_194);
        }
        BVar3 = LYExpandHostForURL(&old_string,URLDomainPrefixes,URLDomainSuffixes);
        if (BVar3 == '\0') {
          if (fixit == 0) {
            HTSACat(AllocatedString,temp);
          }
          else {
            HTSACopy(AllocatedString,old_string);
          }
        }
        else {
          BVar3 = LYAddSchemeForURL(&old_string,"http://");
          if (BVar3 == '\0') {
            HTSACopy(AllocatedString,"http://");
            HTSACat(AllocatedString,old_string);
          }
          else {
            HTSACopy(AllocatedString,old_string);
          }
        }
        if (WWW_TraceFlag != '\0') {
          pathname = *AllocatedString;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Trying: \'%s\'\n",pathname);
        }
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      if (temp2 != (char *)0x0) {
        free(temp2);
        temp2 = (char *)0x0;
      }
    }
  }
  if (old_string != (char *)0x0) {
    free(old_string);
    old_string = (char *)0x0;
  }
  if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
    sleep(AlertSecs);
  }
LAB_08098058:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



BOOLEAN LYExpandHostForURL(char **AllocatedString,char *prefix_list,char *suffix_list)

{
  int iVar1;
  char *src;
  char *src_00;
  ushort **ppuVar2;
  FILE *__stream;
  size_t sVar3;
  char *src_01;
  char *src_02;
  undefined4 uVar4;
  undefined4 uVar5;
  hostent *phVar6;
  bool bVar7;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_84;
  char *local_80;
  addrinfo hints;
  int error;
  addrinfo *res;
  char *Fragment;
  char *Path;
  char *host;
  char *HostColon;
  char *Host;
  char *MsgStr;
  char *StrColon;
  char *Str;
  char *EndS;
  char *StartS;
  char *DomainSuffix;
  char *EndP;
  char *StartP;
  char *DomainPrefix;
  BOOLEAN Startup;
  BOOLEAN GotHost;
  
  DomainPrefix = (char *)0x0;
  DomainSuffix = (char *)0x0;
  Str = (char *)0x0;
  MsgStr = (char *)0x0;
  Host = (char *)0x0;
  host = (char *)0x0;
  Fragment = (char *)0x0;
  GotHost = '\0';
  bVar7 = helpfilepath == (char *)0x0;
  if ((((*AllocatedString == (char *)0x0) || (**AllocatedString == '\0')) ||
      (**AllocatedString == '/')) || (**AllocatedString == '#')) {
    return '\0';
  }
  iVar1 = strncmp(*AllocatedString,"..",2);
  if ((iVar1 == 0) || (iVar1 = strncmp(*AllocatedString,"./",2), iVar1 == 0)) {
    return '\0';
  }
  HTSACopy(&Str,*AllocatedString);
  src = strchr(Str,0x2f);
  if (src == (char *)0x0) {
    Fragment = trimPoundSelector(Str);
  }
  else {
    *src = '\0';
  }
  src_00 = strrchr(Str,0x3a);
  if ((src_00 != (char *)0x0) &&
     (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)src_00[1]] & 0x800) != 0)) {
    if (src_00 == Str) goto cleanup;
    *src_00 = '\0';
  }
  HTSACopy(&host,Str);
  HTUnEscape(host);
  if (LYCursesON == '\0') {
    if ((bVar7) && (dump_output_immediately == '\0')) {
      uVar4 = gettext(" first");
      src_01 = host;
      uVar5 = gettext("Looking up ");
      fprintf(stdout,"%s \'%s\'%s\r\n",uVar5,src_01,uVar4);
    }
  }
  else {
    src_01 = (char *)gettext("Looking up ");
    HTSACopy(&MsgStr,src_01);
    HTSACat(&MsgStr,host);
    src_01 = (char *)gettext(" first");
    HTSACat(&MsgStr,src_01);
    HTProgress(MsgStr);
  }
  memset(&hints,0,0x20);
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  iVar1 = getaddrinfo(host,"80",(addrinfo *)&hints,(addrinfo **)&res);
  src_02 = Str;
  src_01 = host;
  if ((iVar1 == 0) && (res != (addrinfo *)0x0)) {
    if (((LYCursesON != '\0') && (iVar1 = HTCheckForInterrupt(), src = host, iVar1 != 0)) &&
       (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYExpandHostForURL: Ignoring interrupt because \'%s\' resolved.\n",
              src);
    }
    GotHost = '\x01';
  }
  else {
    if ((LYCursesON == '\0') || (lynx_nsl_status != -0x752e)) {
      if ((prefix_list == (char *)0x0) || (sVar3 = strlen(Str), src_02[sVar3 - 1] == '.')) {
        local_94 = "";
      }
      else {
        local_94 = prefix_list;
      }
      StartP = local_94;
      if (((*local_94 != '\0') && (*local_94 != '.')) &&
         (((iVar1 = strncasecomp(*AllocatedString,"www.",4), iVar1 == 0 ||
           (((((iVar1 = strncasecomp(*AllocatedString,"ftp.",4), iVar1 == 0 ||
               (iVar1 = strncasecomp(*AllocatedString,"gopher.",7), iVar1 == 0)) ||
              (iVar1 = strncasecomp(*AllocatedString,"wais.",5), iVar1 == 0)) ||
             ((iVar1 = strncasecomp(*AllocatedString,"cso.",4), iVar1 == 0 ||
              (iVar1 = strncasecomp(*AllocatedString,"ns.",3), iVar1 == 0)))) ||
            (iVar1 = strncasecomp(*AllocatedString,"ph.",3), iVar1 == 0)))) ||
          (((iVar1 = strncasecomp(*AllocatedString,"finger.",7), iVar1 == 0 ||
            (iVar1 = strncasecomp(*AllocatedString,"news.",5), iVar1 == 0)) ||
           (iVar1 = strncasecomp(*AllocatedString,"nntp.",5), iVar1 == 0)))))) {
        StartP = "";
      }
      while ((*StartP != '\0' && (((byte)*StartP < 0x21 || (*StartP == ','))))) {
        StartP = StartP + 1;
      }
      EndP = StartP;
      while (((*EndP != '\0' && (0x20 < (byte)*EndP)) && (*EndP != ','))) {
        EndP = EndP + 1;
      }
      HTSACopy(&DomainPrefix,StartP);
      DomainPrefix[(int)(EndP + -(int)StartP)] = '\0';
      do {
        if ((suffix_list == (char *)0x0) || (*Str == '.')) {
          local_90 = "";
        }
        else {
          local_90 = suffix_list;
        }
        StartS = local_90;
        while ((*StartS != '\0' && (((byte)*StartS < 0x21 || (*StartS == ','))))) {
          StartS = StartS + 1;
        }
        EndS = StartS;
        while (((*EndS != '\0' && (0x20 < (byte)*EndS)) && (*EndS != ','))) {
          EndS = EndS + 1;
        }
        HTSACopy(&DomainSuffix,StartS);
        DomainSuffix[(int)(EndS + -(int)StartS)] = '\0';
        do {
          HTSACopy(&Host,DomainPrefix);
          if (*Str == '.') {
            local_8c = Str + 1;
          }
          else {
            local_8c = Str;
          }
          HTSACat(&Host,local_8c);
          src_01 = Host;
          sVar3 = strlen(Host);
          src_02 = Host;
          if (src_01[sVar3 - 1] == '.') {
            sVar3 = strlen(Host);
            src_02[sVar3 - 1] = '\0';
          }
          HTSACat(&Host,DomainSuffix);
          src_01 = strrchr(Host,0x3a);
          if ((src_01 != (char *)0x0) &&
             (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)src_01[1]] & 0x800) != 0)) {
            *src_01 = '\0';
          }
          HTSACopy(&host,Host);
          HTUnEscape(host);
          if (LYCursesON == '\0') {
            if ((bVar7) && (dump_output_immediately == '\0')) {
              uVar4 = gettext(", guessing...");
              src_02 = host;
              uVar5 = gettext("Looking up ");
              fprintf(stdout,"%s \'%s\'%s\n",uVar5,src_02,uVar4);
            }
          }
          else {
            src_02 = (char *)gettext("Looking up ");
            HTSACopy(&MsgStr,src_02);
            HTSACat(&MsgStr,host);
            src_02 = (char *)gettext(", guessing...");
            HTSACat(&MsgStr,src_02);
            HTProgress(MsgStr);
          }
          phVar6 = LYGetHostByName(host);
          src_02 = host;
          GotHost = phVar6 != (hostent *)0x0;
          if (src_01 != (char *)0x0) {
            *src_01 = ':';
          }
          if (!(bool)GotHost) {
            if ((LYCursesON != '\0') && (lynx_nsl_status == -0x752e)) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,
                        "LYExpandHostForURL: Interrupted while \'%s\' failed to resolve.\n",src_02);
              }
              goto cleanup;
            }
            if (*EndS == '\0') {
              local_88 = EndS;
            }
            else {
              local_88 = EndS + 1;
            }
            StartS = local_88;
            while ((*StartS != '\0' && (((byte)*StartS < 0x21 || (*StartS == ','))))) {
              StartS = StartS + 1;
            }
            EndS = StartS;
            while (((*EndS != '\0' && (0x20 < (byte)*EndS)) && (*EndS != ','))) {
              EndS = EndS + 1;
            }
            LYstrncpy(DomainSuffix,StartS,(int)(EndS + -(int)StartS));
          }
        } while ((!(bool)GotHost) && (*DomainSuffix != '\0'));
        if (!(bool)GotHost) {
          if (*EndP == '\0') {
            local_84 = EndP;
          }
          else {
            local_84 = EndP + 1;
          }
          StartP = local_84;
          while ((*StartP != '\0' && (((byte)*StartP < 0x21 || (*StartP == ','))))) {
            StartP = StartP + 1;
          }
          EndP = StartP;
          while (((*EndP != '\0' && (0x20 < (byte)*EndP)) && (*EndP != ','))) {
            EndP = EndP + 1;
          }
          LYstrncpy(DomainPrefix,StartP,(int)(EndP + -(int)StartP));
        }
      } while ((!(bool)GotHost) && (*DomainPrefix != '\0'));
      if ((bool)GotHost) {
        if ((src_00 != (char *)0x0) && (src_01 = strchr(Host,0x3a), src_01 == (char *)0x0)) {
          *src_00 = ':';
          HTSACat(&Host,src_00);
        }
        if (src == (char *)0x0) {
          if (Fragment != (char *)0x0) {
            HTSACat(&Host,"/");
            if (Fragment != (char *)0x0) {
              *Fragment = '#';
            }
            HTSACat(&Host,Fragment);
          }
        }
        else {
          *src = '/';
          HTSACat(&Host,src);
        }
        HTSACopy(AllocatedString,Host);
      }
      if (((LYCursesON != '\0') && (iVar1 = HTCheckForInterrupt(), src = host, iVar1 != 0)) &&
         (WWW_TraceFlag != '\0')) {
        if ((bool)GotHost) {
          local_80 = "resolved";
        }
        else {
          local_80 = "timed out";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYExpandHostForURL: Ignoring interrupt because \'%s\' %s.\n",src,
                local_80);
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYExpandHostForURL: Interrupted while \'%s\' failed to resolve.\n"
                ,src_01);
      }
    }
  }
cleanup:
  if (DomainPrefix != (char *)0x0) {
    free(DomainPrefix);
    DomainPrefix = (char *)0x0;
  }
  if (DomainSuffix != (char *)0x0) {
    free(DomainSuffix);
    DomainSuffix = (char *)0x0;
  }
  if (Str != (char *)0x0) {
    free(Str);
    Str = (char *)0x0;
  }
  if (MsgStr != (char *)0x0) {
    free(MsgStr);
    MsgStr = (char *)0x0;
  }
  if (Host != (char *)0x0) {
    free(Host);
    Host = (char *)0x0;
  }
  if (host != (char *)0x0) {
    free(host);
  }
  return GotHost;
}



BOOLEAN LYAddSchemeForURL(char **AllocatedString,char *default_scheme)

{
  int iVar1;
  char *pcVar2;
  BOOLEAN local_15;
  char *Str;
  BOOLEAN GotScheme;
  
  Str = (char *)0x0;
  GotScheme = '\0';
  if ((*AllocatedString != (char *)0x0) && (**AllocatedString != '\0')) {
    iVar1 = strncasecomp(*AllocatedString,"www",3);
    if (iVar1 == 0) {
      if ((default_scheme == (char *)0x0) ||
         (pcVar2 = strstr(default_scheme,"http"), pcVar2 == (char *)0x0)) {
        HTSACopy(&Str,"http://");
      }
      else {
        HTSACopy(&Str,default_scheme);
      }
      GotScheme = '\x01';
    }
    else {
      iVar1 = strncasecomp(*AllocatedString,"ftp",3);
      if (iVar1 == 0) {
        HTSACopy(&Str,"ftp://");
        GotScheme = '\x01';
      }
      else {
        iVar1 = strncasecomp(*AllocatedString,"gopher",6);
        if (iVar1 == 0) {
          HTSACopy(&Str,"gopher://");
          GotScheme = '\x01';
        }
        else {
          iVar1 = strncasecomp(*AllocatedString,"wais",4);
          if (iVar1 == 0) {
            HTSACopy(&Str,"wais://");
            GotScheme = '\x01';
          }
          else {
            iVar1 = strncasecomp(*AllocatedString,"cso",3);
            if (((iVar1 == 0) || (iVar1 = strncasecomp(*AllocatedString,"ns.",3), iVar1 == 0)) ||
               (iVar1 = strncasecomp(*AllocatedString,"ph.",3), iVar1 == 0)) {
              HTSACopy(&Str,"cso://");
              GotScheme = '\x01';
            }
            else {
              iVar1 = strncasecomp(*AllocatedString,"finger",6);
              if (iVar1 == 0) {
                HTSACopy(&Str,"finger://");
                GotScheme = '\x01';
              }
              else {
                iVar1 = strncasecomp(*AllocatedString,"news",4);
                if (iVar1 == 0) {
                  if ((default_scheme == (char *)0x0) ||
                     ((pcVar2 = strstr(default_scheme,"news"), pcVar2 == (char *)0x0 &&
                      (pcVar2 = strstr(default_scheme,"nntp"), pcVar2 == (char *)0x0)))) {
                    HTSACopy(&Str,"news://");
                  }
                  else {
                    HTSACopy(&Str,default_scheme);
                  }
                  GotScheme = '\x01';
                }
                else {
                  iVar1 = strncasecomp(*AllocatedString,"nntp",4);
                  if (iVar1 == 0) {
                    HTSACopy(&Str,"nntp://");
                    GotScheme = '\x01';
                  }
                }
              }
            }
          }
        }
      }
    }
    if (GotScheme == '\x01') {
      HTSACat(&Str,*AllocatedString);
      HTSACopy(AllocatedString,Str);
      if (Str != (char *)0x0) {
        free(Str);
      }
      local_15 = GotScheme;
    }
    else {
      if ((default_scheme == (char *)0x0) || (*default_scheme == '\0')) {
        local_15 = GotScheme;
      }
      else {
        HTSACopy(&Str,default_scheme);
        HTSACat(&Str,*AllocatedString);
        HTSACopy(AllocatedString,Str);
        if (Str != (char *)0x0) {
          free(Str);
        }
        local_15 = '\x01';
      }
    }
    return local_15;
  }
  return '\0';
}



void LYTrimRelFromAbsPath(char *path)

{
  char cVar1;
  size_t sVar2;
  int i;
  char *cp;
  BOOLEAN TerminalSlash;
  
  if ((path != (char *)0x0) && (*path == '/')) {
    sVar2 = strlen(path);
    cVar1 = path[sVar2 - 1];
    HTSimplify(path);
    cp = path;
    while (cp[1] == '.') {
      if (cp[2] == '\0') {
        cp[1] = '\0';
      }
      else {
        if (cp[2] == '/') {
          cp = cp + 2;
        }
        else {
          if ((cp[2] == '.') && (cp[3] == '\0')) {
            cp[1] = '\0';
          }
          else {
            if ((cp[2] != '.') || (cp[3] != '/')) break;
            cp = cp + 3;
          }
        }
      }
    }
    if (path < cp) {
      i = 0;
      while (cp[i] != '\0') {
        path[i] = cp[i];
        i = i + 1;
      }
      path[i] = '\0';
    }
    if (cVar1 != '/') {
      LYTrimPathSep(path);
    }
  }
  return;
}



void LYDoCSI(char *url,char *comment,char **csi)

{
  int iVar1;
  char *cp;
  
  if (comment != (char *)0x0) {
    iVar1 = strncmp(comment,"!--#",4);
    if (iVar1 == 0) {
      iVar1 = strncasecomp(comment + 4,"lynxCSI",7);
      if (iVar1 == 0) {
        HTSACat(csi,"\n<p align=\"center\">URL: ");
        HTSACat(csi,url);
        HTSACat(csi,"</p>\n\n");
      }
    }
  }
  return;
}



char * Current_Dir(char *pathname)

{
  char *pcVar1;
  char *result;
  
  pcVar1 = getcwd(pathname,0x100);
  if (pcVar1 == (char *)0x0) {
    memcpy(pathname,&DAT_081575f5,2);
  }
  return pathname;
}



char * CheckDir(char *path)

{
  BOOLEAN BVar1;
  int iVar2;
  stat stat_info;
  
  BVar1 = LYisAbsPath(path);
  if (((BVar1 != '\0') && (iVar2 = HTStat(path,&stat_info), -1 < iVar2)) &&
     ((stat_info.st_mode & 0xf000) == 0x4000)) {
    return path;
  }
  return (char *)0x0;
}



char * HomeEnv(void)

{
  char *path;
  char *result;
  
  path = LYGetEnv("HOME");
  path = CheckDir(path);
  return path;
}



char * Home_Dir(void)

{
  char *homedir;
  char *src;
  __uid_t __uid;
  passwd *ppVar1;
  passwd *pw;
  char *cp;
  
  if (homedir == (char *)0x0) {
    src = HomeEnv();
    if (src == (char *)0x0) {
      __uid = geteuid();
      ppVar1 = getpwuid(__uid);
      if ((ppVar1 == (passwd *)0x0) || (ppVar1->pw_dir == (char *)0x0)) {
        HTSACopy(&HomeDir,"/tmp");
      }
      else {
        HTSACopy(&HomeDir,ppVar1->pw_dir);
      }
    }
    else {
      HTSACopy(&HomeDir,src);
    }
    homedir = HomeDir;
  }
  if (homedir == (char *)0x0) {
    src = (char *)gettext("Cannot find HOME directory");
    puts(src);
    exit_immediately(1);
  }
  return homedir;
}



char * LYPathLeaf(char *pathname)

{
  char *local_18;
  char *leaf;
  
  leaf = strrchr(pathname,0x2f);
  if (leaf != (char *)0x0) {
    leaf = leaf + 1;
  }
  if (leaf == (char *)0x0) {
    local_18 = pathname;
  }
  else {
    local_18 = leaf;
  }
  return local_18;
}



BOOLEAN LYPathOffHomeOK(char *fbuffer,size_t fbuffer_size)

{
  char *pcVar1;
  char *pcVar2;
  UrlTypes UVar3;
  int iVar4;
  size_t sVar5;
  char *cp1;
  char *cp;
  char *file;
  
  file = (char *)0x0;
  if (((fbuffer == (char *)0x0) || (fbuffer_size < 2)) || (*fbuffer == '\0')) {
    return '\0';
  }
  HTSACopy(&file,fbuffer);
  cp = file;
  if (*file == '~') {
    if (file[1] == '/') {
      if (file[2] == '\0') {
        if (file != (char *)0x0) {
          free(file);
        }
        return '\0';
      }
      pcVar1 = strchr(file + 2,0x2f);
      if (pcVar1 == (char *)0x0) {
        cp = cp + 2;
      }
      else {
        *cp = '.';
      }
    }
    else {
      if ((file[1] == '\0') || (pcVar1 = strchr(file + 1,0x2f), pcVar1 == (char *)0x0)) {
        if (file != (char *)0x0) {
          free(file);
        }
        return '\0';
      }
      cp = pcVar1 + -1;
      if (pcVar1[1] == '\0') {
        if (file != (char *)0x0) {
          free(file);
        }
        return '\0';
      }
      pcVar2 = strchr(pcVar1 + 1,0x2f);
      if (pcVar2 == (char *)0x0) {
        cp = pcVar1 + 1;
      }
      else {
        *cp = '.';
      }
    }
  }
  UVar3 = is_url(cp);
  if ((UVar3 == NOT_A_URL_TYPE) && (*cp != '/')) {
    HTSimplify(cp);
    iVar4 = strncmp(cp,"./",2);
    if ((iVar4 == 0) && (pcVar1 = strchr(cp + 2,0x2f), pcVar1 == (char *)0x0)) {
      cp = cp + 2;
    }
    if ((((*cp != '\0') && (*cp != '/')) && (sVar5 = strlen(cp), cp[sVar5 - 1] != '/')) &&
       ((pcVar1 = strstr(cp,".."), pcVar1 == (char *)0x0 && (iVar4 = strcmp(cp,"."), iVar4 != 0))))
    {
      if ((fbuffer_size < 4) ||
         ((iVar4 = strncmp(cp,"./",2), iVar4 == 0 ||
          (pcVar1 = strchr(cp,0x2f), pcVar1 == (char *)0x0)))) {
        sVar5 = strlen(cp);
        if (fbuffer_size - 1 < sVar5) {
          cp[fbuffer_size - 1] = '\0';
        }
        strcpy(fbuffer,cp);
      }
      else {
        memcpy(fbuffer,&DAT_08157421,3);
        sVar5 = strlen(cp);
        if (fbuffer_size - 3 < sVar5) {
          cp[fbuffer_size - 3] = '\0';
        }
        strcat(fbuffer,cp);
      }
      if (file != (char *)0x0) {
        free(file);
      }
      return '\x01';
    }
    if (file != (char *)0x0) {
      free(file);
    }
    return '\0';
  }
  if (file != (char *)0x0) {
    free(file);
  }
  return '\0';
}



char * FindLeadingTilde(char *pathname,BOOLEAN embedded)

{
  char *result;
  
  result = pathname;
  if (pathname != (char *)0x0) {
    if (embedded != '\0') {
      while (*pathname != '\0') {
        if ((*pathname == '/') && (pathname[1] == '~')) {
          pathname = pathname + 1;
          break;
        }
        pathname = pathname + 1;
      }
    }
    if (*pathname == '~') {
      result = pathname;
    }
  }
  return result;
}



char * LYAbsOrHomePath(char **fname)

{
  int iVar1;
  BOOLEAN BVar2;
  int in_GS_OFFSET;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  BVar2 = LYisAbsPath(*fname);
  if (BVar2 == '\0') {
    if (**fname == '~') {
      LYTildeExpand(fname,'\0');
    }
    else {
      LYAddPathToHome(temp,0x100,*fname);
      HTSACopy(fname,temp);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *fname;
}



char * LYTildeExpand(char **pathname,BOOLEAN embedded)

{
  char *pcVar1;
  char *pathname_00;
  FILE *__stream;
  char *second;
  char *first;
  char *temp;
  
  pathname_00 = FindLeadingTilde(*pathname,embedded);
  if (*pathname_00 == '~') {
    if (WWW_TraceFlag != '\0') {
      pcVar1 = *pathname;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYTildeExpand %s\n",pcVar1);
    }
    if (pathname_00[1] == '/') {
      first = (char *)0x0;
      second = (char *)0x0;
      HTSACopy(&first,*pathname);
      first[(int)(pathname_00 + -(int)*pathname)] = '\0';
      HTSACopy(&second,pathname_00 + 2);
      HTSACopy(pathname,first);
      pathname_00 = Home_Dir();
      pathname_00 = wwwName(pathname_00);
      HTSACat(pathname,pathname_00);
      LYAddPathSep(pathname);
      HTSACat(pathname,second);
      if (first != (char *)0x0) {
        free(first);
        first = (char *)0x0;
      }
      if (second != (char *)0x0) {
        free(second);
        second = (char *)0x0;
      }
    }
    else {
      if (pathname_00[1] == '\0') {
        pathname_00 = Home_Dir();
        pathname_00 = wwwName(pathname_00);
        HTSACopy(pathname,pathname_00);
      }
    }
    if (WWW_TraceFlag != '\0') {
      pathname_00 = *pathname;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"expanded path %s\n",pathname_00);
    }
  }
  return *pathname;
}



void LYAddPathToHome(char *fbuffer,size_t fbuffer_size,char *fname)

{
  char *src;
  size_t sVar1;
  int iVar2;
  char *local_18;
  int len;
  char *file;
  char *home;
  
  home = (char *)0x0;
  file = fname;
  if (fbuffer != (char *)0x0) {
    if (fbuffer_size < 2) {
      *fbuffer = '\0';
    }
    else {
      fbuffer[fbuffer_size - 1] = '\0';
      if (fname == (char *)0x0) {
        file = "";
      }
      src = Home_Dir();
      HTSACopy(&home,src);
      if ((home == (char *)0x0) || (*home == '\0')) {
        HTSACopy(&home,"/error");
      }
      sVar1 = strlen(home);
      if ((int)(~sVar1 + fbuffer_size) < 1) {
        LYstrncpy(fbuffer,home,fbuffer_size - 1);
        if (home != (char *)0x0) {
          free(home);
        }
      }
      else {
        iVar2 = strncmp(file,"./",2);
        if (iVar2 == 0) {
          local_18 = file + 2;
        }
        else {
          local_18 = file;
        }
        sprintf(fbuffer,"%s/%.*s",home,~sVar1 + fbuffer_size,local_18);
        if (home != (char *)0x0) {
          free(home);
        }
      }
    }
  }
  return;
}



char * LYAddPathToSave(char *fname)

{
  int iVar1;
  BOOLEAN BVar2;
  int in_GS_OFFSET;
  char *result;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  BVar2 = LYisAbsPath(fname);
  if (BVar2 == '\0') {
    if (lynx_save_space == (char *)0x0) {
      LYAddPathToHome(temp,0x100,fname);
      HTSACopy(&result,temp);
    }
    else {
      HTSACopy(&result,lynx_save_space);
    }
  }
  else {
    HTSACopy(&result,fname);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



BOOLEAN IsOurSymlink(char *name)

{
  BOOLEAN BVar1;
  ssize_t sVar2;
  char *pcVar3;
  FILE *__stream;
  char *clone;
  char *cutoff;
  char *buffer;
  int used;
  int size;
  BOOLEAN result;
  
  result = '\0';
  size = 0x100;
  buffer = (char *)malloc(0x100);
  if (buffer != (char *)0x0) {
    do {
      sVar2 = readlink(name,buffer,size - 1);
      if (sVar2 != size + -1) break;
      size = size << 1;
      buffer = (char *)realloc(buffer,size);
    } while (buffer != (char *)0x0);
    if (sVar2 < 1) {
      if (buffer != (char *)0x0) {
        free(buffer);
        buffer = (char *)0x0;
      }
    }
    else {
      buffer[sVar2] = '\0';
    }
  }
  if (buffer != (char *)0x0) {
    BVar1 = LYisAbsPath(buffer);
    if (BVar1 == '\0') {
      pcVar3 = LYLastPathSep(name);
      clone = (char *)0x0;
      if (pcVar3 != (char *)0x0) {
        HTSprintf0(&clone,"%.*s%s%s",pcVar3 + -(int)name,name,&DAT_081573e8,buffer);
        if (buffer != (char *)0x0) {
          free(buffer);
        }
        buffer = clone;
      }
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"IsOurSymlink(%s -> %s)\n",name,buffer);
    }
    result = IsOurFile(buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  return result;
}



BOOLEAN IsOurFile(char *name)

{
  bool bVar1;
  __uid_t _Var2;
  BOOLEAN BVar3;
  int iVar4;
  __uid_t _Var5;
  FILE *__stream;
  char *local_7c;
  stat data;
  char *leaf;
  char *path;
  int linked;
  BOOLEAN result;
  
  result = '\0';
  if (*name == '~') goto LAB_08099db6;
  iVar4 = lstat64(name,(stat64 *)&data);
  _Var2 = data.st_uid;
  if (iVar4 != 0) goto LAB_08099db6;
  if ((((data.st_mode & 0xf000) == 0x8000) && ((data.st_mode & 0x12) == 0)) && (data.st_nlink == 1))
  {
    _Var5 = getuid();
    if (_Var2 != _Var5) goto LAB_08099c9e;
  }
  else {
LAB_08099c9e:
    if ((data.st_mode & 0xf000) != 0xa000) goto LAB_08099db6;
    BVar3 = IsOurSymlink(name);
    if (BVar3 == '\0') goto LAB_08099db6;
  }
  bVar1 = false;
  path = (char *)0x0;
  HTSACopy(&path,name);
  do {
    leaf = LYPathLeaf(path);
    if (leaf != path) {
      leaf = leaf + -1;
      *leaf = '\0';
    }
    if (*path == '\0') {
      local_7c = "/";
    }
    else {
      local_7c = path;
    }
    iVar4 = lstat64(local_7c,(stat64 *)&data);
    if (iVar4 != 0) break;
    if ((data.st_mode & 0xf000) == 0xa000) {
      bVar1 = true;
    }
    else {
      if ((data.st_mode & 0xf000) == 0x4000) {
        if ((bVar1) && ((bVar1 = false, data.st_uid != 0 || ((data.st_mode & 2) != 0)))) {
          bVar1 = true;
          break;
        }
      }
      else {
        if (bVar1) break;
      }
    }
  } while (leaf != path);
  if (path != (char *)0x0) {
    free(path);
    path = (char *)0x0;
  }
  result = !bVar1;
LAB_08099db6:
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"IsOurFile(%s) %d\n",name,(int)result);
  }
  return result;
}



FILE * OpenHiddenFile(char *name,char *mode)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int *piVar3;
  int iVar4;
  FILE *pFVar5;
  __mode_t __mask;
  char *local_78;
  stat data;
  mode_t save;
  int fd;
  FILE *fp;
  BOOLEAN binary;
  
  fp = (FILE *)0x0;
  pcVar2 = strchr(mode,0x62);
  if (*mode == 'w') {
    fd = open64(name,0xc1,0x180);
    if (((fd < 0) && (piVar3 = __errno_location(), *piVar3 == 0x11)) &&
       (BVar1 = IsOurFile(name), BVar1 != '\0')) {
      remove(name);
      fd = open64(name,0xc1,0x180);
    }
    if (fd < 0) {
      return (FILE *)0x0;
    }
    pFVar5 = (FILE *)fdopen(fd,mode);
    return pFVar5;
  }
  if (*mode != 'a') {
    if (*mode != 'a') {
      __mask = umask(0x3f);
      iVar4 = chmod(name,0x180);
      if ((iVar4 == 0) || (piVar3 = __errno_location(), *piVar3 == 2)) {
        fp = (FILE *)fopen64(name,mode);
      }
      umask(__mask);
      return fp;
    }
    return (FILE *)0x0;
  }
  BVar1 = IsOurFile(name);
  if ((BVar1 != '\0') && (iVar4 = chmod(name,0x180), iVar4 == 0)) {
    pFVar5 = (FILE *)fopen64(name,mode);
    return pFVar5;
  }
  iVar4 = lstat64(name,(stat64 *)&data);
  if (iVar4 == 0) {
    return (FILE *)0x0;
  }
  if (pcVar2 == (char *)0x0) {
    local_78 = "w";
  }
  else {
    local_78 = "wb";
  }
  pFVar5 = OpenHiddenFile(name,local_78);
  return pFVar5;
}



FILE * LYNewBinFile(char *name)

{
  FILE *pFVar1;
  FILE *fp;
  
  pFVar1 = OpenHiddenFile(name,"wb");
  return pFVar1;
}



FILE * LYNewTxtFile(char *name)

{
  FILE *pFVar1;
  FILE *fp;
  
  pFVar1 = OpenHiddenFile(name,"w");
  return pFVar1;
}



FILE * LYAppendToTxtFile(char *name)

{
  FILE *pFVar1;
  FILE *fp;
  
  pFVar1 = OpenHiddenFile(name,"a+");
  return pFVar1;
}



void LYRelaxFilePermissions(char *name)

{
  int iVar1;
  __mode_t __mask;
  stat stat_buf;
  mode_t save;
  mode_t mode;
  
  iVar1 = stat64(name,(stat64 *)&stat_buf);
  if (((iVar1 == 0) && ((stat_buf.st_mode & 0xf000) == 0x8000)) &&
     ((stat_buf.st_mode & 0x1ff) == 0x180)) {
    __mask = umask(0x3f);
    umask(__mask);
    chmod(name,~__mask & (stat_buf.st_mode & 0x1c0 | 0x36));
  }
  return;
}



BOOLEAN LYCachedTemp(char *result,char **cached)

{
  BOOLEAN BVar1;
  BOOLEAN local_5;
  
  if (*cached == (char *)0x0) {
    local_5 = '\0';
  }
  else {
    LYstrncpy(result,*cached,0x100);
    if (*cached != (char *)0x0) {
      free(*cached);
      *cached = (char *)0x0;
    }
    BVar1 = LYCanReadFile(result);
    if (BVar1 != '\0') {
      remove(result);
    }
    local_5 = '\x01';
  }
  return local_5;
}



FILE * LYOpenTemp(char *result,char *suffix,char *mode)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  __uid_t _Var4;
  FILE *__stream;
  int iVar5;
  __uid_t _Var6;
  __mode_t __mask;
  char *pcVar7;
  int *piVar8;
  LY_TEMP *pLVar9;
  FILE *local_8c;
  stat sb;
  int old_mask;
  LY_TEMP *p;
  FILE *fp;
  BOOLEAN make_it;
  char wrt;
  BOOLEAN txt;
  
  fp = (FILE *)0x0;
  bVar3 = true;
  wrt = 'r';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYOpenTemp(,%s,%s)\n",suffix,mode);
  }
  if (result == (char *)0x0) {
    local_8c = (FILE *)0x0;
  }
  else {
    while (*mode != '\0') {
      cVar1 = *mode;
      mode = mode + 1;
      if (cVar1 == 'b') {
        bVar3 = false;
      }
      else {
        if (cVar1 == 'w') {
          wrt = 'w';
        }
        else {
          if (cVar1 != 'a') {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"%s @%d: BUG\n","./LYUtils.c",0x1742);
            }
            return (FILE *)0x0;
          }
          wrt = 'a';
        }
      }
    }
    if (lynx_temp_subspace == 0) {
      bVar2 = false;
      iVar5 = lstat64(lynx_temp_space,(stat64 *)&sb);
      _Var4 = sb.st_uid;
      pcVar7 = lynx_temp_space;
      if ((iVar5 == 0) && ((sb.st_mode & 0xf000) == 0x4000)) {
        _Var6 = getuid();
        pcVar7 = lynx_temp_space;
        if (((_Var4 != _Var6) || ((sb.st_mode & 0x12) != 0)) &&
           (bVar2 = true, WWW_TraceFlag != '\0')) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"lynx_temp_space is not our directory %s owner %d mode %03o\n",
                  pcVar7,sb.st_uid,sb.st_mode & 0x1ff);
        }
      }
      else {
        bVar2 = true;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"lynx_temp_space is not a directory %s\n",pcVar7);
        }
      }
      if (bVar2) {
        __mask = umask(0x3f);
        HTSACat(&lynx_temp_space,"lynxXXXXXXXXXX");
        pcVar7 = mkdtemp(lynx_temp_space);
        if (pcVar7 == (char *)0x0) {
          piVar8 = __errno_location();
          pcVar7 = strerror(*piVar8);
          printf("%s: %s\n",lynx_temp_space,pcVar7);
          exit_immediately(1);
        }
        umask(__mask);
        lynx_temp_subspace = 1;
        HTSACat(&lynx_temp_space,"/");
        pcVar7 = lynx_temp_space;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"made subdirectory %s\n",pcVar7);
        }
      }
      else {
        lynx_temp_subspace = -1;
      }
    }
    do {
      iVar5 = fmt_tempname(result,lynx_temp_space,suffix);
      if (iVar5 == 0) {
        return (FILE *)0x0;
      }
      if (bVar3) {
        if (wrt == 'a') {
          fp = LYAppendToTxtFile(result);
        }
        else {
          if (wrt == 'w') {
            fp = LYNewTxtFile(result);
          }
        }
      }
      else {
        fp = LYNewBinFile(result);
      }
      if ((fp == (FILE *)0x0) && (piVar8 = __errno_location(), *piVar8 != 0x11)) {
        if (WWW_TraceFlag != '\0') {
          piVar8 = __errno_location();
          pcVar7 = strerror(*piVar8);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"... LYOpenTemp(%s) failed: %s\n",result,pcVar7);
        }
        return (FILE *)0x0;
      }
    } while (fp == (FILE *)0x0);
    pLVar9 = (LY_TEMP *)calloc(1,0x10);
    if (pLVar9 == (LY_TEMP *)0x0) {
      outofmem("./LYUtils.c","LYOpenTemp");
    }
    else {
      *(LY_TEMP **)&pLVar9->next = ly_temp;
      HTSACopy(&pLVar9->name,result);
      pLVar9->file = fp;
      *(bool *)&pLVar9->outs = wrt != 'r';
      ly_temp = pLVar9;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"... LYOpenTemp(%s)\n",result);
    }
    local_8c = fp;
  }
  return local_8c;
}



FILE * LYReopenTemp(char *name)

{
  LY_TEMP *pLVar1;
  FILE *pFVar2;
  FILE *fp;
  LY_TEMP *p;
  
  fp = (FILE *)0x0;
  LYCloseTemp(name);
  pLVar1 = FindTempfileByName(name);
  if (pLVar1 != (LY_TEMP *)0x0) {
    pFVar2 = LYAppendToTxtFile(name);
    pLVar1->file = pFVar2;
    fp = pLVar1->file;
  }
  return fp;
}



FILE * LYOpenTempRewrite(char *fname,char *suffix,char *mode)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  FILE *__stream;
  LY_TEMP *pLVar4;
  int iVar5;
  int *piVar6;
  char *pcVar7;
  bool bVar8;
  FILE *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_7c;
  stat stat_buf;
  LY_TEMP *p;
  FILE *fp;
  BOOLEAN still_open;
  BOOLEAN is_ours;
  BOOLEAN writable_exists;
  BOOLEAN registered;
  char wrt;
  BOOLEAN txt;
  
  fp = (FILE *)0x0;
  bVar3 = true;
  wrt = 'r';
  bVar2 = false;
  writable_exists = '\0';
  is_ours = '\0';
  bVar8 = false;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYOpenTempRewrite(%s,%s,%s)\n",fname,suffix,mode);
  }
  if (*fname == '\0') {
    local_94 = LYOpenTemp(fname,suffix,mode);
  }
  else {
    pLVar4 = FindTempfileByName(fname);
    if (pLVar4 != (LY_TEMP *)0x0) {
      bVar2 = true;
      bVar8 = pLVar4->file != (FILE *)0x0;
      if (WWW_TraceFlag != '\0') {
        if (bVar8) {
          local_90 = ", still open!";
        }
        else {
          local_90 = ".";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"...used before%s\n",local_90);
      }
    }
    if (bVar2) {
      writable_exists = HTEditable(fname);
      if (writable_exists != '\0') {
        is_ours = IsOurFile(fname);
      }
      if (WWW_TraceFlag != '\0') {
        if (is_ours == '\0') {
          local_8c = "is NOT our file.";
        }
        else {
          local_8c = "is our file.";
        }
        if (writable_exists == '\0') {
          local_88 = "";
        }
        else {
          local_88 = "exists and is writable, ";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"...%s%s\n",local_88,local_8c);
      }
    }
    if (bVar8) {
      local_94 = LYOpenTemp(fname,suffix,mode);
    }
    else {
      if (bVar2) {
        if ((writable_exists == '\0') || (is_ours != '\0')) {
          if ((is_ours == '\0') && (iVar5 = lstat64(fname,(stat64 *)&stat_buf), iVar5 == 0)) {
            local_94 = LYOpenTemp(fname,suffix,mode);
          }
          else {
            while (*mode != '\0') {
              cVar1 = *mode;
              mode = mode + 1;
              if (cVar1 == 'b') {
                bVar3 = false;
              }
              else {
                if (cVar1 == 'w') {
                  wrt = 'w';
                }
                else {
                  if (cVar1 != 'a') {
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"%s @%d: BUG\n","./LYUtils.c",0x180d);
                    }
                    return (FILE *)0x0;
                  }
                  wrt = 'a';
                }
              }
            }
            if (is_ours != '\0') {
              if (bVar3) {
                iVar5 = truncate64(fname,0);
                if (iVar5 != 0) {
                  if (WWW_TraceFlag != '\0') {
                    piVar6 = __errno_location();
                    pcVar7 = strerror(*piVar6);
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"... truncate(%s,0) failed: %s\n",fname,pcVar7);
                  }
                  __stream = LYOpenTemp(fname,suffix,mode);
                  return __stream;
                }
                __stream = LYReopenTemp(fname);
                return __stream;
              }
              remove(fname);
            }
            if (bVar3) {
              if (wrt == 'a') {
                fp = LYAppendToTxtFile(fname);
              }
              else {
                if (wrt == 'w') {
                  fp = LYNewTxtFile(fname);
                }
              }
            }
            else {
              fp = LYNewBinFile(fname);
            }
            pLVar4->file = fp;
            if (WWW_TraceFlag != '\0') {
              if (fp == (FILE *)0x0) {
                local_7c = "failed";
              }
              else {
                local_7c = "ok";
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,"... LYOpenTempRewrite(%s), %s\n",fname,local_7c);
            }
            local_94 = fp;
          }
        }
        else {
          local_94 = LYOpenTemp(fname,suffix,mode);
        }
      }
      else {
        local_94 = LYOpenTemp(fname,suffix,mode);
      }
    }
  }
  return local_94;
}



FILE * LYOpenScratch(char *result,char *prefix)

{
  int iVar1;
  LY_TEMP *pLVar2;
  FILE *__stream;
  FILE *local_18;
  LY_TEMP *p;
  FILE *fp;
  
  iVar1 = fmt_tempname(result,prefix,".html");
  if (iVar1 == 0) {
    local_18 = (FILE *)0x0;
  }
  else {
    local_18 = LYNewTxtFile(result);
    if (local_18 != (FILE *)0x0) {
      pLVar2 = (LY_TEMP *)calloc(1,0x10);
      if (pLVar2 == (LY_TEMP *)0x0) {
        outofmem("./LYUtils.c","LYOpenScratch");
      }
      else {
        *(LY_TEMP **)&pLVar2->next = ly_temp;
        HTSACopy(&pLVar2->name,result);
        pLVar2->file = local_18;
        ly_temp = pLVar2;
      }
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOpenScratch(%s)\n",result);
    }
  }
  return local_18;
}



void LY_close_temp(LY_TEMP *p)

{
  if (p->file != (FILE *)0x0) {
    if (p->outs == '\0') {
      LYCloseInput(p->file);
    }
    else {
      LYCloseOutput(p->file);
    }
    p->file = (FILE *)0x0;
  }
  return;
}



void LYCloseTemp(char *name)

{
  FILE *__stream;
  LY_TEMP *p_00;
  char *local_18;
  LY_TEMP *p;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYCloseTemp(%s)\n",name);
  }
  p_00 = FindTempfileByName(name);
  if (p_00 != (LY_TEMP *)0x0) {
    if (WWW_TraceFlag != '\0') {
      if (p_00->file == (FILE *)0x0) {
        local_18 = "";
      }
      else {
        local_18 = ", closed";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...LYCloseTemp(%s)%s\n",name,local_18);
    }
    LY_close_temp(p_00);
  }
  return;
}



void LYCloseTempFP(FILE *fp)

{
  char *pcVar1;
  FILE *__stream;
  LY_TEMP *p_00;
  LY_TEMP *p;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYCloseTempFP\n");
  }
  p_00 = FindTempfileByFP(fp);
  if (p_00 != (LY_TEMP *)0x0) {
    LY_close_temp(p_00);
    if (WWW_TraceFlag != '\0') {
      pcVar1 = p_00->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...LYCloseTempFP(%s)\n",pcVar1);
    }
  }
  return;
}



int LYRemoveTemp(char *name)

{
  FILE *__stream;
  int iVar1;
  char *local_18;
  int code;
  LY_TEMP *q;
  LY_TEMP *p;
  
  if ((name != (char *)0x0) && (*name != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYRemoveTemp(%s)\n",name);
    }
    p = ly_temp;
    q = (LY_TEMP *)0x0;
    while (p != (LY_TEMP *)0x0) {
      iVar1 = strcmp(name,p->name);
      if (iVar1 == 0) {
        if (q == (LY_TEMP *)0x0) {
          ly_temp = (LY_TEMP *)p->next;
        }
        else {
          q->next = p->next;
        }
        LY_close_temp(p);
        iVar1 = remove(name);
        if (WWW_TraceFlag != '\0') {
          if (p->file == (FILE *)0x0) {
            local_18 = "";
          }
          else {
            local_18 = ", closed";
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"...LYRemoveTemp done(%d)%s\n",iVar1,local_18);
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fflush((FILE *)__stream);
        }
        if (p->name != (char *)0x0) {
          free(p->name);
          p->name = (char *)0x0;
        }
        if (p == (LY_TEMP *)0x0) {
          return iVar1;
        }
        free(p);
        return iVar1;
      }
      q = p;
      p = (LY_TEMP *)p->next;
    }
  }
  return -1;
}



void LYCleanupTemp(void)

{
  int iVar1;
  FILE *__stream;
  int in_GS_OFFSET;
  char result [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  while (ly_temp != (LY_TEMP *)0x0) {
    LYRemoveTemp(ly_temp->name);
  }
  if (0 < lynx_temp_subspace) {
    LYstrncpy(result,lynx_temp_space,0xff);
    LYTrimPathSep(result);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYCleanupTemp removing %s\n",result);
    }
    rmdir(result);
    lynx_temp_subspace = -1;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void LYRenamedTemp(char *oldname,char *newname)

{
  FILE *__stream;
  LY_TEMP *pLVar1;
  LY_TEMP *p;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYRenamedTemp(old=%s, new=%s)\n",oldname,newname);
  }
  pLVar1 = FindTempfileByName(oldname);
  if (pLVar1 != (LY_TEMP *)0x0) {
    HTSACopy(&pLVar1->name,newname);
  }
  return;
}



void LYCheckBibHost(void)

{
  BOOLEAN BVar1;
  BOOLEAN BVar2;
  DocAddress bibhostIcon;
  BOOLEAN saveFlag;
  
  bibhostIcon.address = (char *)0x0;
  HTSACopy((char **)&bibhostIcon,BibP_bibhost);
  HTSACat((char **)&bibhostIcon,"bibp1.0/bibpicon.jpg");
  BVar1 = traversal;
  bibhostIcon.post_data = (bstring *)0x0;
  bibhostIcon.post_content_type = (char *)0x0;
  bibhostIcon.bookmark = (char *)0x0;
  bibhostIcon.isHEAD = '\0';
  bibhostIcon.safe = '\0';
  traversal = '\x01';
  BVar2 = HTLoadAbsolute(&bibhostIcon);
  traversal = BVar1;
  BibP_bibhost_available = BVar2 == '\x01';
  BibP_bibhost_checked = '\x01';
  return;
}



BOOLEAN LYIsUIPage3(char *url,UIP_t type,int flagparam)

{
  size_t __n;
  int iVar1;
  bool bVar2;
  char *local_18;
  HTList *l0;
  char *p;
  size_t l;
  uint i;
  
  if (url == (char *)0x0) {
    return '\0';
  }
  i = 0;
  while( true ) {
    if (0xc < i) {
      return '\0';
    }
    if (ly_uip[i].type == type) break;
    i = i + 1;
  }
  if (ly_uip[i].url != (char *)0x0) {
    if ((flagparam & 1U) == 0) {
      iVar1 = strcmp(ly_uip[i].url,url);
      bVar2 = iVar1 == 0;
    }
    else {
      __n = strlen(ly_uip[i].url);
      iVar1 = strncmp(ly_uip[i].url,url,__n);
      if ((iVar1 == 0) && ((url[__n] == '\0' || (url[__n] == '#')))) {
        bVar2 = true;
      }
      else {
        bVar2 = false;
      }
    }
    if (bVar2) {
      return '\x01';
    }
    if ((ly_uip[i].flags & 1) != 0) {
      l0 = ly_uip[i].alturls;
      while( true ) {
        if ((l0 == (HTList *)0x0) || (l0 = l0->next, l0 == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)l0->object;
        }
        if (local_18 == (char *)0x0) break;
        if ((flagparam & 1U) == 0) {
          iVar1 = strcmp(local_18,url);
          bVar2 = iVar1 == 0;
        }
        else {
          __n = strlen(local_18);
          iVar1 = strncmp(local_18,url,__n);
          if ((iVar1 == 0) && ((url[__n] == '\0' || (url[__n] == '#')))) {
            bVar2 = true;
          }
          else {
            bVar2 = false;
          }
        }
        if (bVar2) {
          return '\x01';
        }
      }
    }
    return '\0';
  }
  return '\0';
}



void LYRegisterUIPage(char *url,UIP_t type)

{
  int iVar1;
  HTList *pHVar2;
  char *local_1c;
  HTList *l0;
  int n;
  char *p;
  uint i;
  
  i = 0;
  while( true ) {
    if (0xc < i) {
      return;
    }
    if (ly_uip[i].type == type) break;
    i = i + 1;
  }
  if (((ly_uip[i].url != (char *)0x0) && (url != (char *)0x0)) &&
     (iVar1 = strcmp(ly_uip[i].url,url), iVar1 == 0)) {
    return;
  }
  if (((ly_uip[i].url == (char *)0x0) || (url == (char *)0x0)) || ((ly_uip[i].flags & 1) == 0)) {
    HTSACopy(&ly_uip[i].url,url);
    return;
  }
  n = 0;
  l0 = ly_uip[i].alturls;
  while( true ) {
    if ((l0 == (HTList *)0x0) || (l0 = l0->next, l0 == (HTList *)0x0)) {
      local_1c = (char *)0x0;
    }
    else {
      local_1c = (char *)l0->object;
    }
    if (local_1c == (char *)0x0) {
      if (ly_uip[i].alturls == (HTList *)0x0) {
        pHVar2 = HTList_new();
        ly_uip[i].alturls = pHVar2;
      }
      if ((HTCacheSize <= n) && ((ly_uip[i].flags & 2) != 0)) {
        HTList_removeFirstObject(ly_uip[i].alturls);
      }
      HTList_addObject(ly_uip[i].alturls,ly_uip[i].url);
      ly_uip[i].url = (char *)0x0;
      HTSACopy(&ly_uip[i].url,url);
      return;
    }
    iVar1 = strcmp(local_1c,url);
    if (iVar1 == 0) {
      return;
    }
    iVar1 = strcmp(local_1c,ly_uip[i].url);
    if (iVar1 == 0) break;
    n = n + 1;
  }
  HTSACopy(&ly_uip[i].url,url);
  return;
}



void LYUIPages_free(void)

{
  uint i;
  
  i = 0;
  while (i < 0xd) {
    if (ly_uip[i].url != (char *)0x0) {
      free(ly_uip[i].url);
      ly_uip[i].url = (char *)0x0;
    }
    if (ly_uip[i].file != (char *)0x0) {
      free(ly_uip[i].file);
      ly_uip[i].file = (char *)0x0;
    }
    LYFreeStringList(ly_uip[i].alturls);
    ly_uip[i].alturls = (HTList *)0x0;
    i = i + 1;
  }
  return;
}



char * wwwName(char *pathname)

{
  char *cp;
  
  return pathname;
}



BOOLEAN LYValidateFilename(char *result,char *given)

{
  char buf [256];
  BOOLEAN BVar1;
  int iVar2;
  char *Msg;
  char *pathname;
  size_t sVar3;
  size_t sVar4;
  BOOLEAN local_19;
  char *cp2;
  char *cp;
  
  iVar2 = strcmp(given,"/dev/null");
  if (iVar2 == 0) {
    local_19 = '\0';
  }
  else {
    if (*given == '|') {
      if (no_shell == '\0') {
        LYstrncpy(result,given,0x100);
        local_19 = '\x01';
      }
      else {
        Msg = (char *)gettext("Spawning is currently disabled.");
        HTUserMsg(Msg);
        local_19 = '\0';
      }
    }
    else {
      Msg = FindLeadingTilde(given,'\x01');
      if (Msg != given) {
        pathname = Home_Dir();
        pathname = wwwName(pathname);
        if (pathname != (char *)0x0) {
          sVar3 = strlen(pathname);
          sVar4 = strlen(given);
          if (sVar3 + sVar4 < 0x100) {
            *Msg = '\0';
            strcpy(result,given);
            LYTrimPathSep(result);
            strcat(result,pathname);
            strcat(result,Msg + 1);
            strcpy(given,result);
          }
        }
      }
      BVar1 = LYisAbsPath(given);
      if (BVar1 == '\0') {
        cp = Current_Dir((char *)&ram0x081af960);
      }
      else {
        cp = (char *)0x0;
      }
      *result = '\0';
      if (cp != (char *)0x0) {
        LYTrimPathSep(cp);
        sVar3 = strlen(cp);
        if (0xfd < sVar3) {
          return '\0';
        }
        sprintf(result,"%s/",cp);
      }
      sVar3 = strlen(result);
      sVar4 = strlen(given);
      if (sVar3 + sVar4 < 0xff) {
        strcat(result,given);
        local_19 = '\x01';
      }
      else {
        local_19 = '\0';
      }
    }
  }
  return local_19;
}



int LYValidateOutput(char *filename)

{
  BOOLEAN BVar1;
  BOOLEAN BVar2;
  char *Msg;
  int c;
  
  if (*filename == '|') {
    return 0x59;
  }
  if (((no_dotfiles != '\0') || (show_dotfiles == '\0')) &&
     (Msg = LYPathLeaf(filename), *Msg == '.')) {
    Msg = (char *)gettext("File name may not begin with a dot.");
    HTAlert(Msg);
    return 0x4e;
  }
  BVar1 = LYCanReadFile(filename);
  if (BVar1 != '\0') {
    Msg = (char *)gettext("File exists.  Overwrite?");
    BVar1 = HTConfirm(Msg);
    BVar2 = HTLastConfirmCancelled();
    if (BVar2 != '\0') {
      Msg = (char *)gettext("Save request cancelled!!!");
      HTInfoMsg(Msg);
      return 3;
    }
    if (BVar1 == '\0') {
      return 0x4e;
    }
  }
  return 0x59;
}



void LYLocalFileToURL(char **target,char *source)

{
  int iVar1;
  BOOLEAN BVar2;
  char *src;
  int in_GS_OFFSET;
  char *leaf;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  HTSACopy(target,"file://localhost");
  src = wwwName(source);
  BVar2 = LYisAbsPath(source);
  if (BVar2 == '\0') {
    Current_Dir(temp);
    if (temp[0] != '/') {
      LYAddHtmlSep(target);
    }
    HTSACat(target,temp);
  }
  if (*src != '/') {
    LYAddHtmlSep(target);
  }
  HTSACat(target,src);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



FILE * InternalPageFP(char *filename,int reuse_flag)

{
  char *Msg;
  FILE *fp;
  
  if ((LYReuseTempfiles == '\0') || (reuse_flag == 0)) {
    LYRemoveTemp(filename);
    fp = LYOpenTemp(filename,".html","wb");
  }
  else {
    fp = LYOpenTempRewrite(filename,".html","wb");
  }
  if (fp == (FILE *)0x0) {
    Msg = (char *)gettext("Can\'t open temporary file!");
    HTAlert(Msg);
  }
  return fp;
}



void WriteInternalTitle(FILE *fp0,char *Title)

{
  int iVar1;
  char *__s2;
  char *Address;
  
  fwrite("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n",1,0x40,(FILE *)fp0);
  fwrite("<html>\n<head>\n",1,0xe,(FILE *)fp0);
  LYAddMETAcharsetToFD(fp0,-1);
  __s2 = (char *)gettext("List Page");
  iVar1 = strcmp(Title,__s2);
  if (iVar1 == 0) {
    __s2 = HTLoadedDocumentURL();
    __s2 = strchr(__s2,0x22);
    if (__s2 == (char *)0x0) {
      Address = (char *)0x0;
      __s2 = HTLoadedDocumentURL();
      HTSACopy(&Address,__s2);
      LYEntify(&Address,'\0');
      fprintf((FILE *)fp0,"<base href=\"%s\">\n",Address);
      if (Address != (char *)0x0) {
        free(Address);
        Address = (char *)0x0;
      }
    }
  }
  fprintf((FILE *)fp0,"<title>%s</title>\n</head>\n<body>\n",Title);
  return;
}



void BeginInternalPage(FILE *fp0,char *Title,char *HelpURL)

{
  char *pcVar1;
  BOOLEAN BVar2;
  undefined4 uVar3;
  
  WriteInternalTitle(fp0,Title);
  if (((user_mode == 0) &&
      (BVar2 = LYwouldPush(Title,(char *)0x0), pcVar1 = helpfilepath, BVar2 != '\0')) &&
     (HelpURL != (char *)0x0)) {
    uVar3 = gettext(" Version ");
    fprintf((FILE *)fp0,"<h1>%s (%s%s%s), <a href=\"%s%s\">help</a></h1>\n",Title,&DAT_08157a84,
            uVar3,"2.8.7dev.11",pcVar1,HelpURL);
    return;
  }
  uVar3 = gettext(" Version ");
  fprintf((FILE *)fp0,"<h1>%s (%s%s%s)</h1>\n",Title,&DAT_08157a84,uVar3,"2.8.7dev.11");
  return;
}



void EndInternalPage(FILE *fp0)

{
  fwrite("</body>\n</html>",1,0xf,(FILE *)fp0);
  return;
}



char * trimPoundSelector(char *address)

{
  char *pcVar1;
  char *pound;
  
  pcVar1 = strchr(address,0x23);
  if (pcVar1 != (char *)0x0) {
    *pcVar1 = '\0';
  }
  return pcVar1;
}



void LYTrimPathSep(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if ((sVar1 != 0) && (path[sVar1 - 1] == '/')) {
      path[sVar1 - 1] = '\0';
    }
  }
  return;
}



void LYAddPathSep(char **path)

{
  char *__s;
  size_t sVar1;
  char *temp;
  size_t len;
  
  if ((path != (char **)0x0) && (__s = *path, __s != (char *)0x0)) {
    sVar1 = strlen(__s);
    if ((sVar1 != 0) && (__s[sVar1 - 1] != '/')) {
      HTSACat(path,"/");
    }
  }
  return;
}



void LYAddPathSep0(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if (((sVar1 != 0) && (sVar1 < 0xfe)) && (path[sVar1 - 1] != '/')) {
      strcat(path,"/");
    }
  }
  return;
}



char * LYLastPathSep(char *path)

{
  char *pcVar1;
  char *result;
  
  pcVar1 = strrchr(path,0x2f);
  return pcVar1;
}



void LYTrimHtmlSep(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if ((sVar1 != 0) && (path[sVar1 - 1] == '/')) {
      path[sVar1 - 1] = '\0';
    }
  }
  return;
}



void LYAddHtmlSep(char **path)

{
  char *__s;
  size_t sVar1;
  char *temp;
  size_t len;
  
  if ((path != (char **)0x0) && (__s = *path, __s != (char *)0x0)) {
    sVar1 = strlen(__s);
    if ((sVar1 != 0) && (__s[sVar1 - 1] != '/')) {
      HTSACat(path,"/");
    }
  }
  return;
}



void LYAddHtmlSep0(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if (((sVar1 != 0) && (sVar1 < 0xfe)) && (path[sVar1 - 1] != '/')) {
      strcat(path,"/");
    }
  }
  return;
}



int LYCopyFile(char *src,char *dst)

{
  int iVar1;
  char *parameter;
  FILE *fp;
  FILE *fp_00;
  int iVar2;
  size_t __n;
  int in_GS_OFFSET;
  int len;
  FILE *fout;
  FILE *fin;
  char *the_command;
  char *program;
  int code;
  uchar buff [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  parameter = HTGetProgramPath(ppCOPY);
  if (parameter == (char *)0x0) {
    code = -1;
    fp = (FILE *)fopen64(src,"rb");
    if (fp != (FILE *)0x0) {
      fp_00 = (FILE *)fopen64(dst,"wb");
      if (fp_00 != (FILE *)0x0) {
        code = 0;
        do {
          __n = fread(buff,1,0x2000,(FILE *)fp);
          if ((int)__n < 1) goto LAB_0809bf6a;
          fwrite(buff,1,__n,(FILE *)fp_00);
          iVar2 = ferror((FILE *)fp_00);
        } while (iVar2 == 0);
        code = -1;
LAB_0809bf6a:
        LYCloseOutput(fp_00);
      }
      LYCloseInput(fp);
    }
  }
  else {
    the_command = (char *)0x0;
    HTAddParam(&the_command,"%s %s %s",1,parameter);
    HTAddParam(&the_command,"%s %s %s",2,src);
    HTAddParam(&the_command,"%s %s %s",3,dst);
    HTEndParam(&the_command,"%s %s %s",3);
    parameter = the_command;
    if (WWW_TraceFlag != '\0') {
      fp = TraceFP();
      fprintf((FILE *)fp,"command: %s\n",parameter);
    }
    stop_curses();
    code = LYSystem(the_command);
    start_curses();
    if (the_command != (char *)0x0) {
      free(the_command);
      the_command = (char *)0x0;
    }
  }
  if (code != 0) {
    parameter = (char *)gettext("Cannot write to file.");
    HTAlert(parameter);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



// WARNING: Removing unreachable block (ram,0x0809c115)
// WARNING: Removing unreachable block (ram,0x0809c11b)

int LYSystem(char *command)

{
  int iVar1;
  FILE *__stream;
  int iVar2;
  int *piVar3;
  sigaction saved_sigtstp_act;
  int saved_errno;
  int do_free;
  int code;
  BOOLEAN sigtstp_saved;
  
  sigtstp_saved = '\0';
  fflush(stdout);
  fflush(stderr);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYSystem(%s)\n",command);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fflush((FILE *)__stream);
  }
  if (restore_sigpipe_for_children != '\0') {
    signal(0xd,(__sighandler_t)0x0);
  }
  if (((dump_output_immediately == '\0') && (LYCursesON == '\0')) && (no_suspend == '\0')) {
    sigtstp_saved = LYToggleSigDfl(0x14,&saved_sigtstp_act,1);
  }
  iVar2 = system(command);
  piVar3 = __errno_location();
  iVar1 = *piVar3;
  if (sigtstp_saved != '\0') {
    LYToggleSigDfl(0x14,&saved_sigtstp_act,0);
  }
  if (restore_sigpipe_for_children != '\0') {
    signal(0xd,(__sighandler_t)0x1);
  }
  fflush(stdout);
  fflush(stderr);
  piVar3 = __errno_location();
  *piVar3 = iVar1;
  return iVar2;
}



char * LYSysShell(void)

{
  char *shell;
  
  return "exec $SHELL";
}



char * LYgetXDisplay(void)

{
  char *pcVar1;
  
  pcVar1 = LYGetEnv("DISPLAY");
  return pcVar1;
}



void LYsetXDisplay(char *new_display)

{
  char *display_putenv_command;
  char *src;
  
  if (new_display != (char *)0x0) {
    HTSprintf0((char **)0x81afa60,"DISPLAY=%s",new_display);
    putenv(display_putenv_command);
    src = LYgetXDisplay();
    if (src != (char *)0x0) {
      HTSACopy(&x_display,src);
    }
  }
  return;
}



void get_clip_release(void)

{
  if (paste_handle != (FILE *)0x0) {
    pclose((FILE *)paste_handle);
  }
  if ((paste_buf != (char *)0x0) && (paste_buf != (char *)0x0)) {
    free(paste_buf);
    paste_buf = (char *)0x0;
  }
  return;
}



int clip_grab(void)

{
  char *__command;
  int local_18;
  char *cmd;
  
  __command = LYGetEnv("RL_PASTE_CMD");
  if (paste_handle != (FILE *)0x0) {
    pclose((FILE *)paste_handle);
  }
  if (__command == (char *)0x0) {
    local_18 = 0;
  }
  else {
    paste_handle = (FILE *)popen(__command,"r");
    if (paste_handle == (FILE *)0x0) {
      local_18 = 0;
    }
    else {
      local_18 = 1;
    }
  }
  return local_18;
}



char * get_clip_grab(void)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  char *local_18;
  int off;
  int size;
  int len;
  
  size = 0x3f0;
  off = 0;
  iVar1 = clip_grab();
  if (iVar1 == 0) {
    local_18 = (char *)0x0;
  }
  else {
    if (paste_handle == (FILE *)0x0) {
      local_18 = (char *)0x0;
    }
    else {
      if ((paste_buf != (char *)0x0) && (paste_buf != (char *)0x0)) {
        free(paste_buf);
        paste_buf = (char *)0x0;
      }
      paste_buf = (char *)malloc(0x3f0);
      while( true ) {
        sVar2 = fread(paste_buf + off,1,0x3ef,(FILE *)paste_handle);
        paste_buf[off + sVar2] = '\0';
        if ((int)sVar2 < 0x3ef) break;
        pcVar3 = strchr(paste_buf + off,0xd);
        if (pcVar3 != (char *)0x0) break;
        pcVar3 = strchr(paste_buf + off,10);
        if (pcVar3 != (char *)0x0) break;
        size = size + 0x3ef;
        paste_buf = (char *)realloc(paste_buf,size);
        off = off + sVar2;
      }
      local_18 = paste_buf;
    }
  }
  return local_18;
}



int put_clip(char *s)

{
  char *__command;
  size_t __n;
  FILE *__s;
  size_t sVar1;
  int iVar2;
  int local_18;
  int res;
  int l;
  FILE *fh;
  char *cmd;
  
  __command = LYGetEnv("RL_CLCOPY_CMD");
  __n = strlen(s);
  if (__command == (char *)0x0) {
    local_18 = -1;
  }
  else {
    __s = popen(__command,"w");
    if (__s == (FILE *)0x0) {
      local_18 = -1;
    }
    else {
      sVar1 = fwrite(s,1,__n,__s);
      iVar2 = pclose(__s);
      if ((iVar2 == 0) && (sVar1 == __n)) {
        local_18 = 0;
      }
      else {
        local_18 = -1;
      }
    }
  }
  return local_18;
}



void LYmsec_delay(uint msec)

{
  napms(msec);
  return;
}



void LYOpenlog(char *banner)

{
  FILE *__stream;
  char *local_8;
  
  if (syslog_requested_urls != '\0') {
    if (WWW_TraceFlag != '\0') {
      if (banner == (char *)0x0) {
        local_8 = "(null)";
      }
      else {
        local_8 = banner;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOpenlog(%s)\n",local_8);
    }
    openlog("lynx",1,0xa8);
    if (banner == (char *)0x0) {
      syslog(6,"Session start");
    }
    else {
      syslog(6,"Session start:%s",banner);
    }
  }
  return;
}



BOOLEAN looks_like_password(char *first,char *last)

{
  BOOLEAN result;
  
  result = '\0';
  while( true ) {
    if (last < first) {
      return result;
    }
    if ((*first == '/') || (*first == ':')) break;
    result = '\x01';
    first = first + 1;
  }
  return '\0';
}



void LYSyslog(char *arg)

{
  BOOLEAN BVar1;
  FILE *__stream;
  UrlTypes UVar2;
  char *__s1;
  int iVar3;
  char *pcVar4;
  char *local_1c;
  char *buf;
  char *atsign;
  char *colon2;
  char *colon1;
  
  if (syslog_requested_urls != '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYSyslog %s\n",arg);
    }
    UVar2 = is_url(arg);
    if ((((UVar2 != NOT_A_URL_TYPE) && (__s1 = strchr(arg,0x3a), __s1 != (char *)0x0)) &&
        (iVar3 = strncmp(__s1,"://",3), iVar3 == 0)) &&
       (((pcVar4 = strchr(__s1 + 3,0x3a), pcVar4 != (char *)0x0 &&
         (__s1 = strchr(__s1,0x40), __s1 != (char *)0x0)) &&
        ((pcVar4 < __s1 && (BVar1 = looks_like_password(pcVar4 + 1,__s1 + -1), BVar1 != '\0')))))) {
      buf = (char *)0x0;
      HTSACopy(&buf,arg);
      buf[(int)(pcVar4 + (1 - (int)arg))] = '\0';
      HTSACat(&buf,"******");
      HTSACat(&buf,__s1);
      syslog(0xae,"%s",buf);
      __s1 = buf;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"...alter %s\n",__s1);
      }
      if (buf == (char *)0x0) {
        return;
      }
      free(buf);
      return;
    }
    if (arg == (char *)0x0) {
      local_1c = "(null)";
    }
    else {
      local_1c = arg;
    }
    syslog(0xae,"%s",local_1c);
  }
  return;
}



void LYCloselog(void)

{
  if (syslog_requested_urls != '\0') {
    syslog(6,"Session over");
    closelog();
  }
  return;
}



BOOLEAN LYCheckUserAgent(void)

{
  char *pcVar1;
  
  if ((((LYUserAgent != (char *)0x0) && (*LYUserAgent != '\0')) &&
      (pcVar1 = strstr(LYUserAgent,"Lynx"), pcVar1 == (char *)0x0)) &&
     (((pcVar1 = strstr(LYUserAgent,"lynx"), pcVar1 == (char *)0x0 &&
       (pcVar1 = strstr(LYUserAgent,"L_y_n_x"), pcVar1 == (char *)0x0)) &&
      (pcVar1 = strstr(LYUserAgent,"l_y_n_x"), pcVar1 == (char *)0x0)))) {
    return '\0';
  }
  return '\x01';
}



void validate_x_display(void)

{
  char *src;
  char *cp;
  
  src = LYgetXDisplay();
  if (src == (char *)0x0) {
    if (x_display != (char *)0x0) {
      free(x_display);
      x_display = (char *)0x0;
    }
  }
  else {
    HTSACopy(&x_display,src);
  }
  return;
}



void summarize_x_display(char *display_option)

{
  int iVar1;
  char *text;
  
  if ((x_display == (char *)0x0) && (*display_option == '\0')) {
LAB_0809c891:
    if ((x_display == (char *)0x0) && (LYisConfiguredForX == '\x01')) {
      mustshow = '\x01';
      text = (char *)gettext("Value accepted! -- WARNING: Lynx is configured for XWINDOWS!");
      statusline(text);
    }
    else {
      if ((x_display == (char *)0x0) || (LYisConfiguredForX != '\0')) {
        mustshow = '\x01';
        text = (char *)gettext("Value accepted!");
        statusline(text);
      }
      else {
        mustshow = '\x01';
        text = (char *)gettext("Value accepted! -- WARNING: Lynx is NOT configured for XWINDOWS!");
        statusline(text);
      }
    }
  }
  else {
    if (x_display != (char *)0x0) {
      iVar1 = strcmp(x_display,display_option);
      if (iVar1 == 0) goto LAB_0809c891;
    }
    if (*display_option == '\0') {
      mustshow = '\x01';
      text = (char *)gettext("Failed to clear DISPLAY variable!");
      statusline(text);
    }
    else {
      mustshow = '\x01';
      text = (char *)gettext("Failed to set DISPLAY variable!");
      statusline(text);
    }
  }
  return;
}



void SetupChosenShowColor(void)

{
  int local_10;
  int local_c;
  int local_8;
  
  can_do_colors = '\x01';
  if (LYCursesON != '\0') {
    can_do_colors = has_colors();
  }
  if ((no_option_save == '\0') && (LYChosenShowColor == -1)) {
    if (LYrcShowColor == 0) {
      if (LYShowColor < 2) {
        local_10 = 0;
      }
      else {
        local_10 = 2;
      }
      LYChosenShowColor = local_10;
    }
    else {
      if (LYrcShowColor == 3) {
        if (can_do_colors == '\0') {
          LYChosenShowColor = 3;
        }
        else {
          if (LYShowColor < 2) {
            local_c = 1;
          }
          else {
            local_c = 3;
          }
          LYChosenShowColor = local_c;
        }
      }
      else {
        if (LYShowColor < 2) {
          local_8 = 1;
        }
        else {
          local_8 = 2;
        }
        LYChosenShowColor = local_8;
      }
    }
  }
  return;
}



int add_it(char *text,int len)

{
  size_t len_00;
  
  if (len != 0) {
    text[len] = '\0';
    len_00 = strlen(text);
    LYwaddnstr(LYwin,text,len_00);
  }
  return 0;
}



void addlbl(char *text)

{
  bool bVar1;
  int len;
  int in_GS_OFFSET;
  int d;
  int s;
  BOOLEAN b;
  char actual [80];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  bVar1 = false;
  d = 0;
  s = 0;
  while (text[s] != '\0') {
    actual[d] = text[s];
    len = d + 1;
    if (text[s] == '(') {
      len = add_it(actual,d);
      lynx_start_bold();
      bVar1 = true;
      actual[len] = text[s];
      d = len + 1;
    }
    else {
      d = len;
      if (text[s] == ')') {
        d = add_it(actual,len);
        lynx_stop_bold();
        bVar1 = false;
      }
    }
    s = s + 1;
  }
  add_it(actual,d);
  if (bVar1) {
    lynx_stop_bold();
  }
  if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void LYoptions(void)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  char *userMode_choices [4];
  char *mbm_choices [4];
  char *keypad_choices [4];
  char *fileSort_choices [5];
  char *dirList_choices [4];
  char *caseless_choices [3];
  char *bool_choices [3];
  char cVar4;
  BOOLEAN BVar5;
  size_t len;
  int iVar6;
  char **choices_00;
  int iVar7;
  char *__s;
  char *Msg2;
  ushort **ppuVar8;
  int in_GS_OFFSET;
  char *local_64c;
  char *local_644;
  char *local_640;
  char *local_638;
  char *local_634;
  char *local_62c;
  char *local_628;
  char *local_624;
  char *local_620;
  char *local_61c;
  char *local_614;
  char *local_610;
  int local_60c;
  char *local_608;
  char *local_600;
  char *local_5fc;
  char *local_5f4;
  char *local_5f0;
  char *local_5e8;
  int local_5e4;
  char *local_5e0;
  int local_5dc;
  char *local_5d8;
  int local_5d0;
  char *local_5cc;
  int local_5c8;
  char *local_5c4;
  int local_5c0;
  char *local_5bc;
  int local_5b8;
  char *local_5b4;
  int local_5b0;
  char *local_5ac;
  int local_5a8;
  char *local_5a4;
  char *local_5a0;
  char *local_59c;
  int local_598;
  int local_594;
  char *local_590;
  char *local_58c;
  int local_588;
  char *local_584;
  char *local_580;
  char *local_57c;
  int local_578;
  char *local_574;
  char *local_56c;
  char *local_568;
  char *local_560;
  char *local_55c;
  char *local_554;
  char *local_550;
  char *local_548;
  char *local_544;
  char *local_53c;
  char *local_538;
  char *local_530;
  char *local_52c;
  char *local_524;
  char *local_520;
  char *local_518;
  int local_514;
  int local_510;
  char *local_50c;
  int local_508;
  int local_504;
  int local_500;
  char *local_4fc;
  int local_4f8;
  char *local_4f4;
  char *local_4ec;
  char *local_4e8;
  char *local_4e0;
  int local_4dc;
  int local_4d8;
  int local_4d4;
  int local_4d0;
  int local_4cc;
  int local_4c8;
  int local_4c4;
  int local_4bc;
  int local_4b8;
  int local_4b4;
  int local_4b0;
  int local_4ac;
  int local_4a8;
  int local_4a4;
  int local_4a0;
  int local_49c;
  int local_498;
  int local_494;
  char *local_490;
  char *local_488;
  char *local_484;
  char *local_47c;
  char *choices [10];
  char *terminal_1;
  int chosen;
  char *terminal;
  char **assume_list;
  int curval;
  int i;
  char *cp;
  int CurrentShowColor;
  int CurrentAssumeCharSet;
  int CurrentCharSet;
  int ch;
  int response;
  BOOLEAN again;
  BOOLEAN old_use_assume_charset;
  BOOLEAN use_assume_charset;
  BOOLEAN AddValueAccepted;
  BOOLEAN CurrentRawMode;
  char display_option [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  CurrentCharSet = current_char_set;
  CurrentAssumeCharSet = UCLYhndl_for_unspec;
  CurrentShowColor = LYShowColor;
  CurrentRawMode = LYRawMode;
  bVar2 = false;
  if (LYlines < 0x17) {
    __s = (char *)gettext("Screen height must be at least 23 lines for the Options menu!");
    HTAlert(__s);
LAB_080a09db:
    if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    return;
  }
  term_options = '\0';
  LYStatusLine = LYlines + -1;
  signal(2,terminate_options);
  if (no_option_save == '\0') {
    SetupChosenShowColor();
  }
  else {
    if (LYShowColor == 0) {
      LYShowColor = 1;
    }
    else {
      if (LYShowColor == 3) {
        LYShowColor = 2;
      }
    }
  }
  use_assume_charset = user_mode == 2;
draw_options:
  if (enable_scrollback == '\0') {
    LYerase();
  }
  else {
    LYclear();
  }
  LYmove(0,5);
  lynx_start_h1_color();
  LYwaddnstr(LYwin,"         Options Menu (",0x17);
  LYwaddnstr(LYwin,"Lynx",4);
  LYwaddnstr(LYwin," Version ",9);
  LYwaddnstr(LYwin,"2.8.7dev.11",0xb);
  waddch(LYwin,0x29);
  lynx_stop_h1_color();
  LYmove(2,5);
  addlbl("(E)ditor                     : ");
  if ((editor == (char *)0x0) || (*editor == '\0')) {
    local_64c = "NONE";
  }
  else {
    local_64c = editor;
  }
  len = strlen(local_64c);
  if ((editor == (char *)0x0) || (*editor == '\0')) {
    local_644 = "NONE";
  }
  else {
    local_644 = editor;
  }
  LYwaddnstr(LYwin,local_644,len);
  LYmove(3,5);
  addlbl("(D)ISPLAY variable           : ");
  if ((x_display == (char *)0x0) || (*x_display == '\0')) {
    local_640 = "NONE";
  }
  else {
    local_640 = x_display;
  }
  len = strlen(local_640);
  if ((x_display == (char *)0x0) || (*x_display == '\0')) {
    local_638 = "NONE";
  }
  else {
    local_638 = x_display;
  }
  LYwaddnstr(LYwin,local_638,len);
  LYmove(4,5);
  addlbl("mu(L)ti-bookmarks: ");
  len = strlen(((char **)&ram0x08195954)[LYMultiBookmarks]);
  LYwaddnstr(LYwin,*(char **)(LYMultiBookmarks * 4 + 0x8195954),len);
  LYmove(4,0x22);
  if (LYMultiBookmarks == 0) {
    addlbl("(B)ookmark file: ");
    if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
      local_634 = "NONE";
    }
    else {
      local_634 = bookmark_page;
    }
    len = strlen(local_634);
    if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
      local_62c = "NONE";
    }
    else {
      local_62c = bookmark_page;
    }
    LYwaddnstr(LYwin,local_62c,len);
  }
  else {
    addlbl("review/edit (B)ookmarks files");
  }
  LYmove(5,5);
  addlbl("(F)TP sort criteria          : ");
  if (HTfileSortMethod == 0) {
    local_628 = "By Filename";
  }
  else {
    if (HTfileSortMethod == 2) {
      local_624 = "By Size    ";
    }
    else {
      if (HTfileSortMethod == 1) {
        local_620 = "By Type    ";
      }
      else {
        local_620 = "By Date    ";
      }
      local_624 = local_620;
    }
    local_628 = local_624;
  }
  LYwaddnstr(LYwin,local_628,0xb);
  LYmove(6,5);
  addlbl("(P)ersonal mail address      : ");
  if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
    local_61c = "NONE";
  }
  else {
    local_61c = personal_mail_address;
  }
  len = strlen(local_61c);
  if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
    local_614 = "NONE";
  }
  else {
    local_614 = personal_mail_address;
  }
  LYwaddnstr(LYwin,local_614,len);
  LYmove(7,5);
  addlbl("(S)earching type             : ");
  if (case_sensitive == '\0') {
    local_610 = "CASE INSENSITIVE";
  }
  else {
    local_610 = "CASE SENSITIVE  ";
  }
  LYwaddnstr(LYwin,local_610,0x10);
  if ((bool)use_assume_charset) {
    local_60c = 0xb;
  }
  else {
    local_60c = 10;
  }
  LYmove(local_60c,5);
  addlbl("display (C)haracter set      : ");
  len = strlen(LYchar_set_names[current_char_set]);
  LYwaddnstr(LYwin,LYchar_set_names[current_char_set],len);
  LYmove(8,5);
  addlbl("preferred document lan(G)uage: ");
  if ((language == (char *)0x0) || (*language == '\0')) {
    local_608 = "NONE";
  }
  else {
    local_608 = language;
  }
  len = strlen(local_608);
  if ((language == (char *)0x0) || (*language == '\0')) {
    local_600 = "NONE";
  }
  else {
    local_600 = language;
  }
  LYwaddnstr(LYwin,local_600,len);
  LYmove(9,5);
  addlbl("preferred document c(H)arset : ");
  if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
    local_5fc = "NONE";
  }
  else {
    local_5fc = pref_charset;
  }
  len = strlen(local_5fc);
  if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
    local_5f4 = "NONE";
  }
  else {
    local_5f4 = pref_charset;
  }
  LYwaddnstr(LYwin,local_5f4,len);
  if ((bool)use_assume_charset) {
    LYmove(10,5);
    addlbl("(^A)ssume charset if unknown : ");
    if (UCAssume_MIMEcharset == (char *)0x0) {
      if (UCLYhndl_for_unspec < 0) {
        local_5f0 = "NONE";
      }
      else {
        local_5f0 = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
      }
      len = strlen(local_5f0);
      if (UCLYhndl_for_unspec < 0) {
        local_5e8 = "NONE";
      }
      else {
        local_5e8 = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
      }
      LYwaddnstr(LYwin,local_5e8,len);
    }
    else {
      len = strlen(UCAssume_MIMEcharset);
      LYwaddnstr(LYwin,UCAssume_MIMEcharset,len);
    }
  }
  if ((bool)use_assume_charset) {
    local_5e4 = 0xc;
  }
  else {
    local_5e4 = 0xb;
  }
  LYmove(local_5e4,5);
  addlbl("Raw 8-bit or CJK m(O)de      : ");
  if (LYRawMode == '\0') {
    local_5e0 = "OFF";
  }
  else {
    local_5e0 = "ON ";
  }
  LYwaddnstr(LYwin,local_5e0,3);
  if ((bool)use_assume_charset) {
    local_5dc = 0xc;
  }
  else {
    local_5dc = 0xb;
  }
  LYmove(local_5dc,0x2c);
  addlbl("show color (&)  : ");
  if (no_option_save == '\0') {
    if (LYChosenShowColor == 1) {
      LYwaddnstr(LYwin,"OFF",3);
    }
    else {
      if (LYChosenShowColor < 2) {
        if (LYChosenShowColor == 0) {
          LYwaddnstr(LYwin,"NEVER     ",10);
        }
      }
      else {
        if (LYChosenShowColor == 2) {
          LYwaddnstr(LYwin,"ON ",3);
        }
        else {
          if (LYChosenShowColor == 3) {
            cVar4 = has_colors();
            if (cVar4 == '\x01') {
              LYwaddnstr(LYwin,"ALWAYS    ",10);
            }
            else {
              LYwaddnstr(LYwin,"Always try",10);
            }
          }
        }
      }
    }
  }
  else {
    if (LYShowColor == 1) {
      local_5d8 = "ON ";
    }
    else {
      local_5d8 = "OFF";
    }
    LYwaddnstr(LYwin,local_5d8,3);
  }
  if ((bool)use_assume_charset) {
    local_5d0 = 0xd;
  }
  else {
    local_5d0 = 0xc;
  }
  LYmove(local_5d0,5);
  addlbl("(V)I keys: ");
  if (vi_keys == '\0') {
    local_5cc = "OFF";
  }
  else {
    local_5cc = "ON ";
  }
  LYwaddnstr(LYwin,local_5cc,3);
  if ((bool)use_assume_charset) {
    local_5c8 = 0xd;
  }
  else {
    local_5c8 = 0xc;
  }
  LYmove(local_5c8,0x16);
  addlbl("e(M)acs keys: ");
  if (emacs_keys == '\0') {
    local_5c4 = "OFF";
  }
  else {
    local_5c4 = "ON ";
  }
  LYwaddnstr(LYwin,local_5c4,3);
  if ((bool)use_assume_charset) {
    local_5c0 = 0xd;
  }
  else {
    local_5c0 = 0xc;
  }
  LYmove(local_5c0,0x2c);
  addlbl("sho(W) dot files: ");
  if ((no_dotfiles == '\0') && (show_dotfiles != '\0')) {
    local_5bc = "ON ";
  }
  else {
    local_5bc = "OFF";
  }
  LYwaddnstr(LYwin,local_5bc,3);
  if ((bool)use_assume_charset) {
    local_5b8 = 0xe;
  }
  else {
    local_5b8 = 0xd;
  }
  LYmove(local_5b8,5);
  addlbl("popups for selec(T) fields   : ");
  if (LYSelectPopups == '\0') {
    local_5b4 = "OFF";
  }
  else {
    local_5b4 = "ON ";
  }
  LYwaddnstr(LYwin,local_5b4,3);
  if ((bool)use_assume_charset) {
    local_5b0 = 0xe;
  }
  else {
    local_5b0 = 0xd;
  }
  LYmove(local_5b0,0x2c);
  addlbl("show cursor (@) : ");
  if (LYShowCursor == '\0') {
    local_5ac = "OFF";
  }
  else {
    local_5ac = "ON ";
  }
  LYwaddnstr(LYwin,local_5ac,3);
  if ((bool)use_assume_charset) {
    local_5a8 = 0xf;
  }
  else {
    local_5a8 = 0xe;
  }
  LYmove(local_5a8,5);
  addlbl("(K)eypad mode                : ");
  if (((keypad_mode == 3) || (keypad_mode == 2)) && ((keypad_mode == 1 || (keypad_mode == 2)))) {
    local_5a4 = "Links and form fields are numbered";
  }
  else {
    if ((keypad_mode == 1) || (keypad_mode == 2)) {
      local_5a0 = "Links are numbered                ";
    }
    else {
      if ((keypad_mode == 3) || (keypad_mode == 2)) {
        local_59c = "Form fields are numbered          ";
      }
      else {
        local_59c = "Numbers act as arrows             ";
      }
      local_5a0 = local_59c;
    }
    local_5a4 = local_5a0;
  }
  LYwaddnstr(LYwin,local_5a4,0x22);
  if ((bool)use_assume_charset) {
    local_598 = 0x10;
  }
  else {
    local_598 = 0xf;
  }
  LYmove(local_598,5);
  addlbl("li(N)e edit style            : ");
  len = strlen(LYLineeditNames[current_lineedit]);
  LYwaddnstr(LYwin,LYLineeditNames[current_lineedit],len);
  if ((bool)use_assume_charset) {
    local_594 = 0x12;
  }
  else {
    local_594 = 0x11;
  }
  LYmove(local_594,5);
  addlbl("l(I)st directory style       : ");
  if (dir_list_style == 1) {
    local_590 = "Files first      ";
  }
  else {
    if (dir_list_style == 2) {
      local_58c = "Mixed style      ";
    }
    else {
      local_58c = "Directories first";
    }
    local_590 = local_58c;
  }
  LYwaddnstr(LYwin,local_590,0x11);
  if ((bool)use_assume_charset) {
    local_588 = 0x13;
  }
  else {
    local_588 = 0x12;
  }
  LYmove(local_588,5);
  addlbl("(U)ser mode                  : ");
  if (user_mode == 0) {
    local_584 = "Novice      ";
  }
  else {
    if (user_mode == 1) {
      local_580 = "Intermediate";
    }
    else {
      local_580 = "Advanced    ";
    }
    local_584 = local_580;
  }
  LYwaddnstr(LYwin,local_584,0xc);
  addlbl("  verbose images (!) : ");
  if (verbose_img == '\0') {
    local_57c = "OFF";
  }
  else {
    local_57c = "ON ";
  }
  LYwaddnstr(LYwin,local_57c,3);
  if ((bool)use_assume_charset) {
    local_578 = 0x14;
  }
  else {
    local_578 = 0x13;
  }
  LYmove(local_578,5);
  addlbl("user (A)gent                 : ");
  if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
    local_574 = "NONE";
  }
  else {
    local_574 = LYUserAgent;
  }
  len = strlen(local_574);
  if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
    local_56c = "NONE";
  }
  else {
    local_56c = LYUserAgent;
  }
  LYwaddnstr(LYwin,local_56c,len);
  LYmove(LYlines + -3,2);
  __s = (char *)gettext("Select ");
  len = strlen(__s);
  __s = (char *)gettext("Select ");
  LYwaddnstr(LYwin,__s,len);
  lynx_start_bold();
  __s = (char *)gettext("capital letter");
  len = strlen(__s);
  __s = (char *)gettext("capital letter");
  LYwaddnstr(LYwin,__s,len);
  lynx_stop_bold();
  __s = (char *)gettext(" of option line,");
  len = strlen(__s);
  __s = (char *)gettext(" of option line,");
  LYwaddnstr(LYwin,__s,len);
  if (no_option_save == '\0') {
    LYwaddnstr(LYwin," \'",2);
    lynx_start_bold();
    LYwaddnstr(LYwin,">",1);
    lynx_stop_bold();
    LYwaddnstr(LYwin,"\'",1);
    __s = (char *)gettext(" to save,");
    len = strlen(__s);
    __s = (char *)gettext(" to save,");
    LYwaddnstr(LYwin,__s,len);
  }
  __s = (char *)gettext(&DAT_08158205);
  len = strlen(__s);
  __s = (char *)gettext(&DAT_08158205);
  LYwaddnstr(LYwin,__s,len);
  LYwaddnstr(LYwin,"\'",1);
  lynx_start_bold();
  LYwaddnstr(LYwin,"r",1);
  lynx_stop_bold();
  LYwaddnstr(LYwin,"\'",1);
  __s = (char *)gettext(" to return to Lynx.");
  len = strlen(__s);
  __s = (char *)gettext(" to return to Lynx.");
  LYwaddnstr(LYwin,__s,len);
  response = 0;
switchD_0809e032_caseD_52:
  if ((((response == 0x52) || (BVar5 = LYisNonAlnumKeyname(response,0x25), BVar5 != '\0')) ||
      (response == 0x3e)) || (term_options != '\0')) {
LAB_080a09b6:
    term_options = '\0';
    LYStatusLine = -1;
    signal(2,cleanup_sig);
    goto LAB_080a09db;
  }
  if ((response == 3) || (response == 7)) {
LAB_080a0991:
    ppuVar8 = __ctype_b_loc();
    if (((*ppuVar8)[response] & 0x4000) == 0) goto LAB_080a09b6;
  }
  else {
    if (response == -1) {
      if (keymap[0] != 0x2f) goto LAB_0809debc;
      goto LAB_080a0991;
    }
    if ((response & 0x8800U) == 0) {
      if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_080a0991;
    }
    else {
      if ((response & 0xffU) == 0x2f) goto LAB_080a0991;
    }
  }
LAB_0809debc:
  if (bVar2) {
    mustshow = '\x01';
    __s = (char *)gettext("Value accepted!");
    statusline(__s);
    bVar2 = false;
  }
  LYmove(LYlines + -2,0);
  lynx_start_prompt_color();
  __s = (char *)gettext("Command: ");
  len = strlen(__s);
  __s = (char *)gettext("Command: ");
  LYwaddnstr(LYwin,__s,len);
  lynx_stop_prompt_color();
  LYrefresh();
  response = LYgetch_single();
  if (term_options == '\0') {
    if ((response == 3) || (response == 7)) {
LAB_0809dfc7:
      ppuVar8 = __ctype_b_loc();
      if (((*ppuVar8)[response] & 0x4000) == 0) goto LAB_0809dfe8;
    }
    else {
      if (response == 0xffffffff) {
        if (keymap[0] != 0x2f) goto LAB_0809dff2;
        goto LAB_0809dfc7;
      }
      if ((response & 0x8800U) == 0) {
        if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_0809dfc7;
      }
      else {
        if ((response & 0xffU) == 0x2f) goto LAB_0809dfc7;
      }
    }
  }
  else {
LAB_0809dfe8:
    response = 0x52;
  }
LAB_0809dff2:
  BVar5 = LYisNonAlnumKeyname(response,0x15);
  if (BVar5 != '\0') {
    lynx_force_repaint();
    goto draw_options;
  }
  switch(response) {
  default:
    if (no_option_save == '\0') {
      __s = (char *)gettext(" \'>\' to save, or \'r\' to return to Lynx ");
      HTInfoMsg(__s);
    }
    else {
      __s = (char *)gettext(" \'r\' to return to Lynx ");
      HTInfoMsg(__s);
    }
    goto switchD_0809e032_caseD_52;
  case 1:
    if ((bool)use_assume_charset) {
      choices_00 = (char **)calloc(LYNumCharsets + 1,4);
      if (choices_00 == (char **)0x0) {
        outofmem("./LYOptions.c","options");
      }
      i = 0;
      while (i < LYNumCharsets) {
        choices_00[i] = LYCharSet_UC[i].MIMEname;
        i = i + 1;
      }
      curval = UCLYhndl_for_unspec;
      if ((UCLYhndl_for_unspec == current_char_set) && (UCAssume_MIMEcharset != (char *)0x0)) {
        curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
      }
      if (curval < 0) {
        if (LYRawMode == '\0') {
          local_514 = 0;
        }
        else {
          local_514 = current_char_set;
        }
        curval = local_514;
      }
      if (LYSelectPopups == '\0') {
        UCLYhndl_for_unspec = boolean_choice(curval,10,-1,choices_00);
      }
      else {
        UCLYhndl_for_unspec = popup_choice(curval,10,-1,choices_00,0,0,'\0');
      }
      if ((CurrentAssumeCharSet != UCLYhndl_for_unspec) || (UCLYhndl_for_unspec != curval)) {
        if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
          HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
        }
        if (HTCJK != JAPANESE) {
          LYRawMode = UCLYhndl_for_unspec == current_char_set;
        }
        HTMLSetUseDefaultRawMode(current_char_set,LYRawMode);
        HTMLSetCharacterHandling(current_char_set);
        CurrentAssumeCharSet = UCLYhndl_for_unspec;
        CurrentRawMode = LYRawMode;
        if (LYSelectPopups == '\0') {
          if ((bool)use_assume_charset) {
            local_510 = 0xc;
          }
          else {
            local_510 = 0xb;
          }
          LYmove(local_510,0x24);
          LYclrtoeol();
          if (LYRawMode == '\0') {
            local_50c = "OFF";
          }
          else {
            local_50c = "ON ";
          }
          LYwaddnstr(LYwin,local_50c,3);
        }
      }
      if (choices_00 != (char **)0x0) {
        free(choices_00);
      }
      response = 0x20;
      if (LYSelectPopups != '\0') {
        if (term_options == '\0') {
          bVar2 = true;
        }
        else {
          term_options = '\0';
        }
        goto draw_options;
      }
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("That key requires Advanced User mode.");
      statusline(__s);
      bVar2 = false;
    }
    goto switchD_0809e032_caseD_52;
  case 0x21:
    if (LYSelectPopups == '\0') {
      iVar7 = boolean_choice((int)verbose_img,0x12,0x47,(char **)0x81959a4);
      verbose_img = (BOOLEAN)iVar7;
    }
    else {
      iVar7 = popup_choice((int)verbose_img,0x12,0x47,(char **)0x81959a4,2,0,'\0');
      verbose_img = (BOOLEAN)iVar7;
    }
    response = 0x20;
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x26:
    if (no_option_save == '\0') {
      choices[0] = (char *)0x0;
      HTSACopy(choices,"NEVER     ");
      choices[1] = (char *)0x0;
      HTSACopy(choices + 1,"OFF       ");
      choices[2] = (char *)0x0;
      HTSACopy(choices + 2,"ON        ");
      choices[3] = (char *)0x0;
      cVar4 = has_colors();
      if (cVar4 == '\x01') {
        HTSACopy(choices + 3,"ALWAYS    ");
      }
      else {
        HTSACopy(choices + 3,"Always try");
      }
      choices[4] = (char *)0x0;
      do {
        if (LYSelectPopups == '\0') {
          if ((bool)use_assume_charset) {
            local_4c8 = 0xc;
          }
          else {
            local_4c8 = 0xb;
          }
          chosen = boolean_choice(LYChosenShowColor,local_4c8,0x3e,choices);
        }
        else {
          if ((bool)use_assume_charset) {
            local_4c4 = 0xc;
          }
          else {
            local_4c4 = 0xb;
          }
          chosen = popup_choice(LYChosenShowColor,local_4c4,0x3e,choices,4,0,'\0');
        }
        if ((chosen == 2) && (cVar4 = has_colors(), cVar4 == '\0')) {
          bVar3 = true;
        }
        else {
          bVar3 = false;
        }
        if (bVar3) {
          __s = LYGetEnv("TERM");
          if (__s == (char *)0x0) {
            __s = (char *)gettext("Terminal does not support color");
            HTUserMsg(__s);
          }
          else {
            Msg2 = (char *)gettext("Your \'%s\' terminal does not support color.");
            HTUserMsg2(Msg2,__s);
          }
        }
      } while (bVar3);
      LYChosenShowColor = chosen;
      cVar4 = has_colors();
      if (cVar4 != '\0') {
        LYShowColor = chosen;
      }
      if (choices[0] != (char *)0x0) {
        free(choices[0]);
        choices[0] = (char *)0x0;
      }
      if (choices[1] != (char *)0x0) {
        free(choices[1]);
        choices[1] = (char *)0x0;
      }
      if (choices[2] != (char *)0x0) {
        free(choices[2]);
        choices[2] = (char *)0x0;
      }
      if (choices[3] != (char *)0x0) {
        free(choices[3]);
        choices[3] = (char *)0x0;
      }
    }
    else {
      cVar4 = has_colors();
      if (cVar4 != '\x01') {
        __s = LYGetEnv("TERM");
        if (__s == (char *)0x0) {
          __s = (char *)gettext("Terminal does not support color");
          HTUserMsg(__s);
        }
        else {
          Msg2 = (char *)gettext("Your \'%s\' terminal does not support color.");
          HTUserMsg2(Msg2,__s);
        }
        goto switchD_0809e032_caseD_52;
      }
      if ((bool)use_assume_charset) {
        local_4cc = 0xc;
      }
      else {
        local_4cc = 0xb;
      }
      iVar7 = boolean_choice(LYShowColor + -1,local_4cc,0x3e,(char **)0x81959a4);
      if (iVar7 == 0) {
        LYShowColor = 1;
      }
      else {
        LYShowColor = 2;
      }
    }
    if (CurrentShowColor != LYShowColor) {
      lynx_force_repaint();
    }
    CurrentShowColor = LYShowColor;
    response = 0x20;
    if ((LYSelectPopups != '\0') && (no_option_save == '\0')) {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x3e:
    if (no_option_save == '\0') {
      __s = (char *)gettext("Saving Options...");
      HTInfoMsg(__s);
      LYrcShowColor = LYChosenShowColor;
      iVar7 = save_rc((FILE *)0x0);
      if (iVar7 == 0) {
        __s = (char *)gettext("Unable to save Options!");
        HTAlert(__s);
      }
      else {
        __s = (char *)gettext("Options saved!");
        HTInfoMsg(__s);
      }
    }
    else {
      __s = (char *)gettext(" \'r\' to return to Lynx ");
      HTInfoMsg(__s);
      response = 0x20;
    }
    goto switchD_0809e032_caseD_52;
  case 0x40:
    if ((bool)use_assume_charset) {
      local_4bc = 0xe;
    }
    else {
      local_4bc = 0xd;
    }
    iVar7 = boolean_choice((int)LYShowCursor,local_4bc,0x3e,(char **)0x81959a4);
    LYShowCursor = (BOOLEAN)iVar7;
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x41:
    if (no_useragent == '\0') {
      if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
        LYmove(4,0x24);
        LYwaddnstr(LYwin,"    ",4);
        display_option[0] = '\0';
      }
      else {
        LYstrncpy(display_option,LYUserAgent,0x3ff);
      }
      mustshow = '\x01';
      __s = (char *)gettext("Hit RETURN to accept entered data.  Delete data to invoke the default."
                           );
      statusline(__s);
      if ((bool)use_assume_charset) {
        local_498 = 0x14;
      }
      else {
        local_498 = 0x13;
      }
      LYmove(local_498,0x24);
      lynx_start_bold();
      iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
      lynx_stop_bold();
      if ((bool)use_assume_charset) {
        local_494 = 0x14;
      }
      else {
        local_494 = 0x13;
      }
      LYmove(local_494,0x24);
      if ((term_options == '\0') && (iVar7 != -1)) {
        if (display_option[0] == '\0') {
          HTSACopy(&LYUserAgent,LYUserAgentDefault);
          if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
            local_484 = "NONE";
          }
          else {
            local_484 = LYUserAgent;
          }
          len = strlen(local_484);
          if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
            local_47c = "NONE";
          }
          else {
            local_47c = LYUserAgent;
          }
          LYwaddnstr(LYwin,local_47c,len);
        }
        else {
          HTSACopy(&LYUserAgent,display_option);
          len = strlen(display_option);
          LYwaddnstr(LYwin,display_option,len);
        }
      }
      else {
        if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
          local_490 = "NONE";
        }
        else {
          local_490 = LYUserAgent;
        }
        len = strlen(local_490);
        if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
          local_488 = "NONE";
        }
        else {
          local_488 = LYUserAgent;
        }
        LYwaddnstr(LYwin,local_488,len);
      }
      LYclrtoeol();
      if (iVar7 == -1) {
        __s = (char *)gettext("Cancelled!!!");
        HTInfoMsg(__s);
        HTInfoMsg("");
      }
      else {
        BVar5 = LYCheckUserAgent();
        if (BVar5 == '\0') {
          mustshow = '\x01';
          __s = (char *)gettext(
                               "Use \"L_y_n_x\" or \"Lynx\" in User-Agent, or it looks like intentional deception!"
                               );
          statusline(__s);
        }
        else {
          mustshow = '\x01';
          __s = (char *)gettext("Value accepted!");
          statusline(__s);
        }
      }
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("Changing of the User-Agent string is disabled!");
      statusline(__s);
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x42:
    if (no_bookmark == '\0') {
      if (LYMultiBookmarks != 0) {
        edit_bookmarks();
        signal(2,terminate_options);
        goto draw_options;
      }
      if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
        LYmove(4,0x32);
        LYclrtoeol();
        display_option[0] = '\0';
      }
      else {
        LYstrncpy(display_option,bookmark_page,0x3ff);
      }
      mustshow = '\x01';
      __s = (char *)gettext("Hit RETURN to accept entered data.");
      statusline(__s);
      LYmove(4,0x32);
      lynx_start_bold();
      iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
      lynx_stop_bold();
      LYmove(4,0x32);
      if (((term_options == '\0') && (iVar7 != -1)) && (display_option[0] != '\0')) {
        BVar5 = LYPathOffHomeOK(display_option,0x400);
        if (BVar5 == '\0') {
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_52c = "NONE";
          }
          else {
            local_52c = bookmark_page;
          }
          len = strlen(local_52c);
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_524 = "NONE";
          }
          else {
            local_524 = bookmark_page;
          }
          LYwaddnstr(LYwin,local_524,len);
          LYclrtoeol();
          mustshow = '\x01';
          __s = (char *)gettext("Use a filepath off your home directory!");
          statusline(__s);
          response = 0x20;
          goto switchD_0809e032_caseD_52;
        }
        HTSACopy(&bookmark_page,display_option);
        HTSACopy(MBM_A_subbookmark,bookmark_page);
        len = strlen(bookmark_page);
        LYwaddnstr(LYwin,bookmark_page,len);
      }
      else {
        if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
          local_538 = "NONE";
        }
        else {
          local_538 = bookmark_page;
        }
        len = strlen(local_538);
        if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
          local_530 = "NONE";
        }
        else {
          local_530 = bookmark_page;
        }
        LYwaddnstr(LYwin,local_530,len);
      }
      LYclrtoeol();
      if (iVar7 == -1) {
        __s = (char *)gettext("Cancelled!!!");
        HTInfoMsg(__s);
        HTInfoMsg("");
      }
      else {
        mustshow = '\x01';
        __s = (char *)gettext("Value accepted!");
        statusline(__s);
      }
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("You are not allowed to change the bookmark file!");
      statusline(__s);
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x43:
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_508 = 0xb;
      }
      else {
        local_508 = 10;
      }
      current_char_set = boolean_choice(current_char_set,local_508,-1,LYchar_set_names);
    }
    else {
      if ((bool)use_assume_charset) {
        local_504 = 0xb;
      }
      else {
        local_504 = 10;
      }
      current_char_set = popup_choice(current_char_set,local_504,-1,LYchar_set_names,0,0,'\0');
    }
    if (CurrentCharSet != current_char_set) {
      LYUseDefaultRawMode = '\x01';
      HTMLUseCharacterSet(current_char_set);
      CurrentCharSet = current_char_set;
      CurrentRawMode = LYRawMode;
      if (LYSelectPopups == '\0') {
        if ((bool)use_assume_charset) {
          local_500 = 0xc;
        }
        else {
          local_500 = 0xb;
        }
        LYmove(local_500,0x24);
        LYclrtoeol();
        if (LYRawMode == '\0') {
          local_4fc = "OFF";
        }
        else {
          local_4fc = "ON ";
        }
        LYwaddnstr(LYwin,local_4fc,3);
      }
    }
    response = 0x20;
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x44:
    if ((x_display == (char *)0x0) || (*x_display == '\0')) {
      LYmove(3,0x24);
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,x_display,0x3ff);
    }
    mustshow = '\x01';
    __s = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(__s);
    LYmove(3,0x24);
    lynx_start_bold();
    iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
    lynx_stop_bold();
    LYmove(3,0x24);
    if (((term_options == '\0') && (iVar7 != -1)) &&
       ((x_display == (char *)0x0 || (iVar6 = strcmp(x_display,display_option), iVar6 != 0)))) {
      if ((display_option[0] == '\0') &&
         ((x_display == (char *)0x0 || ((x_display != (char *)0x0 && (*x_display == '\0')))))) {
        LYwaddnstr(LYwin,"NONE",4);
        LYclrtoeol();
        mustshow = '\x01';
        __s = (char *)gettext("Value accepted!");
        statusline(__s);
        response = 0x20;
      }
      else {
        LYsetXDisplay(display_option);
        validate_x_display();
        if (x_display == (char *)0x0) {
          local_550 = "NONE";
        }
        else {
          local_550 = x_display;
        }
        len = strlen(local_550);
        if (x_display == (char *)0x0) {
          local_548 = "NONE";
        }
        else {
          local_548 = x_display;
        }
        LYwaddnstr(LYwin,local_548,len);
        LYclrtoeol();
        summarize_x_display(display_option);
        response = 0x20;
      }
    }
    else {
      if ((x_display == (char *)0x0) || (*x_display == '\0')) {
        local_55c = "NONE";
      }
      else {
        local_55c = x_display;
      }
      len = strlen(local_55c);
      if ((x_display == (char *)0x0) || (*x_display == '\0')) {
        local_554 = "NONE";
      }
      else {
        local_554 = x_display;
      }
      LYwaddnstr(LYwin,local_554,len);
      LYclrtoeol();
      if (iVar7 == -1) {
        __s = (char *)gettext("Cancelled!!!");
        HTInfoMsg(__s);
        HTInfoMsg("");
      }
      else {
        mustshow = '\x01';
        __s = (char *)gettext("Value accepted!");
        statusline(__s);
      }
      response = 0x20;
    }
    goto switchD_0809e032_caseD_52;
  case 0x45:
    if (no_editor == '\0') {
      if (system_editor == '\0') {
        if ((editor == (char *)0x0) || (*editor == '\0')) {
          LYmove(2,0x24);
          LYwaddnstr(LYwin,"    ",4);
          display_option[0] = '\0';
        }
        else {
          LYstrncpy(display_option,editor,0x3ff);
        }
        mustshow = '\x01';
        __s = (char *)gettext("Hit RETURN to accept entered data.");
        statusline(__s);
        LYmove(2,0x24);
        lynx_start_bold();
        iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
        lynx_stop_bold();
        LYmove(2,0x24);
        if ((term_options == '\0') && (iVar7 != -1)) {
          if (display_option[0] == '\0') {
            if (editor != (char *)0x0) {
              free(editor);
              editor = (char *)0x0;
            }
            LYwaddnstr(LYwin,"NONE",4);
          }
          else {
            HTSACopy(&editor,display_option);
            len = strlen(display_option);
            LYwaddnstr(LYwin,display_option,len);
          }
        }
        else {
          if ((editor == (char *)0x0) || (*editor == '\0')) {
            local_568 = "NONE";
          }
          else {
            local_568 = editor;
          }
          len = strlen(local_568);
          if ((editor == (char *)0x0) || (*editor == '\0')) {
            local_560 = "NONE";
          }
          else {
            local_560 = editor;
          }
          LYwaddnstr(LYwin,local_560,len);
        }
        LYclrtoeol();
        if (iVar7 == -1) {
          __s = (char *)gettext("Cancelled!!!");
          HTInfoMsg(__s);
          HTInfoMsg("");
        }
        else {
          mustshow = '\x01';
          __s = (char *)gettext("Value accepted!");
          statusline(__s);
        }
      }
      else {
        mustshow = '\x01';
        __s = (char *)gettext("You are not allowed to change which editor to use!");
        statusline(__s);
      }
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("The \'e\'dit command is currently disabled.");
      statusline(__s);
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x46:
    if (LYSelectPopups == '\0') {
      HTfileSortMethod = boolean_choice(HTfileSortMethod,5,-1,(char **)&ram0x08195974);
    }
    else {
      HTfileSortMethod = popup_choice(HTfileSortMethod,5,-1,(char **)0x8195974,4,0,'\0');
    }
    response = 0x20;
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x47:
    if ((language == (char *)0x0) || (*language == '\0')) {
      LYmove(8,0x24);
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,language,0x3ff);
    }
    mustshow = '\x01';
    __s = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(__s);
    LYmove(8,0x24);
    lynx_start_bold();
    iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
    lynx_stop_bold();
    LYmove(8,0x24);
    if ((term_options == '\0') && (iVar7 != -1)) {
      if (display_option[0] == '\0') {
        if (language != (char *)0x0) {
          free(language);
          language = (char *)0x0;
        }
        LYwaddnstr(LYwin,"NONE",4);
      }
      else {
        HTSACopy(&language,display_option);
        len = strlen(display_option);
        LYwaddnstr(LYwin,display_option,len);
      }
    }
    else {
      if ((language == (char *)0x0) || (*language == '\0')) {
        local_4f4 = "NONE";
      }
      else {
        local_4f4 = language;
      }
      len = strlen(local_4f4);
      if ((language == (char *)0x0) || (*language == '\0')) {
        local_4ec = "NONE";
      }
      else {
        local_4ec = language;
      }
      LYwaddnstr(LYwin,local_4ec,len);
    }
    LYclrtoeol();
    if (iVar7 == -1) {
      __s = (char *)gettext("Cancelled!!!");
      HTInfoMsg(__s);
      HTInfoMsg("");
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("Value accepted!");
      statusline(__s);
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x48:
    if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
      LYmove(9,0x24);
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,pref_charset,0x3ff);
    }
    mustshow = '\x01';
    __s = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(__s);
    LYmove(9,0x24);
    lynx_start_bold();
    iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
    lynx_stop_bold();
    LYmove(9,0x24);
    if ((term_options == '\0') && (iVar7 != -1)) {
      if (display_option[0] == '\0') {
        if (pref_charset != (char *)0x0) {
          free(pref_charset);
          pref_charset = (char *)0x0;
        }
        LYwaddnstr(LYwin,"NONE",4);
      }
      else {
        HTSACopy(&pref_charset,display_option);
        len = strlen(display_option);
        LYwaddnstr(LYwin,display_option,len);
      }
    }
    else {
      if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
        local_4e8 = "NONE";
      }
      else {
        local_4e8 = pref_charset;
      }
      len = strlen(local_4e8);
      if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
        local_4e0 = "NONE";
      }
      else {
        local_4e0 = pref_charset;
      }
      LYwaddnstr(LYwin,local_4e0,len);
    }
    LYclrtoeol();
    if (iVar7 == -1) {
      __s = (char *)gettext("Cancelled!!!");
      HTInfoMsg(__s);
      HTInfoMsg("");
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("Value accepted!");
      statusline(__s);
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x49:
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_4a8 = 0x12;
      }
      else {
        local_4a8 = 0x11;
      }
      dir_list_style = boolean_choice(dir_list_style,local_4a8,-1,(char **)&ram0x08195988);
    }
    else {
      if ((bool)use_assume_charset) {
        local_4a4 = 0x12;
      }
      else {
        local_4a4 = 0x11;
      }
      dir_list_style = popup_choice(dir_list_style,local_4a4,-1,(char **)0x8195988,3,0,'\0');
    }
    response = 0x20;
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x4b:
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_4b8 = 0xf;
      }
      else {
        local_4b8 = 0xe;
      }
      keypad_mode = boolean_choice(keypad_mode,local_4b8,-1,(char **)&ram0x08195964);
    }
    else {
      if ((bool)use_assume_charset) {
        local_4b4 = 0xf;
      }
      else {
        local_4b4 = 0xe;
      }
      keypad_mode = popup_choice(keypad_mode,local_4b4,-1,(char **)0x8195964,3,0,'\0');
    }
    if (keypad_mode == 0) {
      set_numbers_as_arrows();
    }
    else {
      reset_numbers_as_arrows();
    }
    response = 0x20;
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x4c:
    if (LYMBMBlocked == '\0') {
      if (LYSelectPopups == '\0') {
        LYMultiBookmarks = boolean_choice(LYMultiBookmarks,4,0x18,(char **)0x8195954);
      }
      else {
        LYMultiBookmarks = popup_choice(LYMultiBookmarks,4,0x17,(char **)0x8195954,3,0,'\0');
      }
      if (LYSelectPopups == '\0') {
        LYmove(4,0x22);
        LYclrtoeol();
        if (LYMultiBookmarks == 0) {
          __s = (char *)gettext("B)ookmark file: ");
          len = strlen(__s);
          __s = (char *)gettext("B)ookmark file: ");
          LYwaddnstr(LYwin,__s,len);
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_544 = "NONE";
          }
          else {
            local_544 = bookmark_page;
          }
          len = strlen(local_544);
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_53c = "NONE";
          }
          else {
            local_53c = bookmark_page;
          }
          LYwaddnstr(LYwin,local_53c,len);
        }
        else {
          __s = (char *)gettext("review/edit B)ookmarks files");
          len = strlen(__s);
          __s = (char *)gettext("review/edit B)ookmarks files");
          LYwaddnstr(LYwin,__s,len);
        }
      }
      response = 0x20;
      if (LYSelectPopups != '\0') {
        if (term_options == '\0') {
          bVar2 = true;
        }
        else {
          term_options = '\0';
        }
        goto draw_options;
      }
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("Multiple bookmark support is not available.");
      statusline(__s);
      response = 0x20;
    }
    goto switchD_0809e032_caseD_52;
  case 0x4d:
    if ((bool)use_assume_charset) {
      local_4d8 = 0xd;
    }
    else {
      local_4d8 = 0xc;
    }
    iVar7 = boolean_choice((int)emacs_keys,local_4d8,0x24,(char **)0x81959a4);
    emacs_keys = (BOOLEAN)iVar7;
    if (emacs_keys == '\0') {
      reset_emacs_keys();
    }
    else {
      set_emacs_keys();
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x4e:
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_4b0 = 0x10;
      }
      else {
        local_4b0 = 0xf;
      }
      current_lineedit = boolean_choice(current_lineedit,local_4b0,-1,LYLineeditNames);
    }
    else {
      if ((bool)use_assume_charset) {
        local_4ac = 0x10;
      }
      else {
        local_4ac = 0xf;
      }
      current_lineedit = popup_choice(current_lineedit,local_4ac,-1,LYLineeditNames,0,0,'\0');
    }
    response = 0x20;
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case 0x4f:
    if ((bool)use_assume_charset) {
      local_4f8 = 0xc;
    }
    else {
      local_4f8 = 0xb;
    }
    iVar7 = boolean_choice((int)LYRawMode,local_4f8,-1,(char **)&ram0x081959a4);
    LYRawMode = (BOOLEAN)iVar7;
    if (CurrentRawMode != LYRawMode) {
      HTMLSetUseDefaultRawMode(current_char_set,LYRawMode);
      HTMLSetCharacterHandling(current_char_set);
      CurrentRawMode = LYRawMode;
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x50:
    if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
      LYmove(6,0x24);
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,personal_mail_address,0x3ff);
    }
    mustshow = '\x01';
    __s = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(__s);
    LYmove(6,0x24);
    lynx_start_bold();
    iVar7 = LYgetstr(display_option,0,0x400,NORECALL);
    lynx_stop_bold();
    LYmove(6,0x24);
    if ((term_options == '\0') && (iVar7 != -1)) {
      if (display_option[0] == '\0') {
        if (personal_mail_address != (char *)0x0) {
          free(personal_mail_address);
          personal_mail_address = (char *)0x0;
        }
        LYwaddnstr(LYwin,"NONE",4);
      }
      else {
        HTSACopy(&personal_mail_address,display_option);
        len = strlen(display_option);
        LYwaddnstr(LYwin,display_option,len);
      }
    }
    else {
      if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
        local_520 = "NONE";
      }
      else {
        local_520 = personal_mail_address;
      }
      len = strlen(local_520);
      if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
        local_518 = "NONE";
      }
      else {
        local_518 = personal_mail_address;
      }
      LYwaddnstr(LYwin,local_518,len);
    }
    LYclrtoeol();
    if (iVar7 == -1) {
      __s = (char *)gettext("Cancelled!!!");
      HTInfoMsg(__s);
      HTInfoMsg("");
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("Value accepted!");
      statusline(__s);
    }
    response = 0x20;
  case 0x52:
    goto switchD_0809e032_caseD_52;
  case 0x53:
    iVar7 = boolean_choice((int)case_sensitive,7,-1,(char **)&ram0x08195998);
    case_sensitive = (BOOLEAN)iVar7;
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x54:
    if ((bool)use_assume_charset) {
      local_4d0 = 0xe;
    }
    else {
      local_4d0 = 0xd;
    }
    iVar7 = boolean_choice((int)LYSelectPopups,local_4d0,0x24,(char **)0x81959a4);
    LYSelectPopups = (BOOLEAN)iVar7;
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x55:
    break;
  case 0x56:
    if ((bool)use_assume_charset) {
      local_4dc = 0xd;
    }
    else {
      local_4dc = 0xc;
    }
    iVar7 = boolean_choice((int)vi_keys,local_4dc,0xf,(char **)0x81959a4);
    vi_keys = (BOOLEAN)iVar7;
    if (vi_keys == '\0') {
      reset_vi_keys();
    }
    else {
      set_vi_keys();
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  case 0x57:
    if (no_dotfiles == '\0') {
      if ((bool)use_assume_charset) {
        local_4d4 = 0xd;
      }
      else {
        local_4d4 = 0xc;
      }
      iVar7 = boolean_choice((int)show_dotfiles,local_4d4,0x3e,(char **)0x81959a4);
      show_dotfiles = (BOOLEAN)iVar7;
    }
    else {
      mustshow = '\x01';
      __s = (char *)gettext("Access to dot files is disabled!");
      statusline(__s);
    }
    response = 0x20;
    goto switchD_0809e032_caseD_52;
  }
  if (LYSelectPopups == '\0') {
    if ((bool)use_assume_charset) {
      local_4a0 = 0x13;
    }
    else {
      local_4a0 = 0x12;
    }
    user_mode = boolean_choice(user_mode,local_4a0,-1,(char **)&ram0x08195944);
  }
  else {
    if ((bool)use_assume_charset) {
      local_49c = 0x13;
    }
    else {
      local_49c = 0x12;
    }
    user_mode = popup_choice(user_mode,local_49c,-1,(char **)0x8195944,3,0,'\0');
  }
  use_assume_charset = 1 < user_mode;
  LYSetDisplayLines();
  response = 0x20;
  if (LYSelectPopups != '\0') goto code_r0x080a03c9;
  goto switchD_0809e032_caseD_52;
code_r0x080a03c9:
  if (term_options == '\0') {
    bVar2 = true;
  }
  else {
    term_options = '\0';
  }
  goto draw_options;
}



int widest_choice(char **choices)

{
  size_t sVar1;
  int len;
  int width;
  int n;
  
  width = 0;
  n = 0;
  while (choices[n] != (char *)0x0) {
    sVar1 = strlen(choices[n]);
    if (width < (int)sVar1) {
      width = sVar1;
    }
    n = n + 1;
  }
  return width;
}



void show_choice(char *choice,int width)

{
  bool bVar1;
  size_t len_00;
  int len;
  
  len = strlen(choice);
  len_00 = strlen(choice);
  LYwaddnstr(LYwin,choice,len_00);
  while (bVar1 = len < width, len = len + 1, bVar1) {
    waddch(LYwin,0x20);
  }
  return;
}



int boolean_choice(int cur_choice,int line,int column,char **choices)

{
  int iVar1;
  int iVar2;
  int width_00;
  char *text;
  ushort **ppuVar3;
  int local_30;
  uint local_2c;
  uint local_28;
  int width;
  int orig_choice;
  int col;
  int number;
  int cmd;
  int response;
  
  iVar1 = cur_choice;
  response = 0;
  if (column < 0) {
    local_30 = 0x24;
  }
  else {
    local_30 = column;
  }
  width_00 = widest_choice(choices);
  number = 0;
  while (choices[number] != (char *)0x0) {
    number = number + 1;
  }
  number = number + -1;
  mustshow = '\x01';
  text = (char *)gettext("Hit any key to change value; RETURN to accept.");
  statusline(text);
  LYmove(line,local_30);
  lynx_start_reverse();
  show_choice(choices[cur_choice],width_00);
  if (LYShowCursor != '\0') {
    LYmove(line,local_30 + -1);
  }
  LYrefresh();
  term_options = '\0';
  do {
    LYmove(line,local_30);
    if (term_options == '\0') {
      response = LYgetch_single();
    }
    if (term_options == '\0') {
      if ((response == 3) || (response == 7)) {
LAB_080a0c10:
        ppuVar3 = __ctype_b_loc();
        if (((*ppuVar3)[response] & 0x4000) == 0) goto LAB_080a0c2e;
      }
      else {
        if (response == -1) {
          if (keymap[0] != 0x2f) goto LAB_080a0c42;
          goto LAB_080a0c10;
        }
        if ((response & 0x8800U) == 0) {
          if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_080a0c10;
        }
        else {
          if ((response & 0xffU) == 0x2f) goto LAB_080a0c10;
        }
      }
    }
    else {
LAB_080a0c2e:
      response = 10;
      term_options = '\x01';
      cur_choice = iVar1;
    }
LAB_080a0c42:
    if ((response == 10) || (response == 0xd)) {
LAB_080a0d76:
      LYmove(line,local_30);
      lynx_stop_reverse();
      show_choice(choices[cur_choice],width_00);
      if (term_options == '\0') {
        mustshow = '\x01';
        text = (char *)gettext("Value accepted!");
        statusline(text);
      }
      else {
        term_options = '\0';
        text = (char *)gettext("Cancelled!!!");
        HTInfoMsg(text);
        HTInfoMsg("");
      }
      return cur_choice;
    }
    if (response == -1) {
      local_2c = (uint)keymap[0];
    }
    else {
      if ((response & 0x8800U) == 0) {
        local_28 = (uint)keymap[(response & 0x7ffU) + 1];
      }
      else {
        local_28 = response & 0xff;
      }
      local_2c = local_28;
    }
    if (local_2c == 0x27) goto LAB_080a0d76;
    iVar2 = number;
    switch(local_2c) {
    default:
switchD_080a0cc5_caseD_0:
      if (cur_choice == number) {
        cur_choice = 0;
        iVar2 = cur_choice;
      }
      else {
        iVar2 = cur_choice + 1;
      }
      break;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      if (number < (int)(local_2c - 1)) goto switchD_080a0cc5_caseD_0;
      iVar2 = local_2c - 1;
      break;
    case 0xd:
    case 0xe:
    case 0x25:
      term_options = '\x01';
      iVar2 = iVar1;
      break;
    case 0x10:
    case 0x11:
    case 0x13:
    case 0x1a:
    case 0x1c:
    case 0x1e:
    case 0x20:
    case 0x23:
      if (cur_choice != 0) {
        iVar2 = cur_choice + -1;
      }
      break;
    case 0x15:
      lynx_force_repaint();
      LYrefresh();
      iVar2 = cur_choice;
      break;
    case 0x16:
      cur_choice = 0;
      iVar2 = cur_choice;
      break;
    case 0x17:
    }
    cur_choice = iVar2;
    show_choice(choices[cur_choice],width_00);
    if (LYShowCursor != '\0') {
      LYmove(line,local_30 + -1);
    }
    LYrefresh();
  } while( true );
}



void terminate_options(int sig)

{
  term_options = '\x01';
  signal(2,terminate_options);
  return;
}



void edit_bookmarks(void)

{
  int iVar1;
  BOOLEAN BVar2;
  size_t len;
  char *__s;
  int iVar3;
  uint uVar4;
  ushort **ppuVar5;
  int in_GS_OFFSET;
  uint local_134;
  char *local_130;
  char *local_12c;
  char *ehead_buffer;
  int a;
  int MBM_current;
  int ch;
  int def_response;
  int response;
  char MBM_tmp_line [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  response = 0;
  def_response = 0;
  MBM_current = 1;
  term_options = '\0';
  signal(2,terminate_options);
draw_bookmark_list:
  do {
    if (enable_scrollback == '\0') {
      LYerase();
    }
    else {
      LYclear();
    }
    LYmove(0,5);
    lynx_start_h1_color();
    if (LYlines < 0x21) {
      ehead_buffer = (char *)0x0;
      __s = (char *)gettext("Editing Bookmark DESCRIPTION and FILEPATH (%d of 2)");
      HTSprintf0(&ehead_buffer,__s,MBM_current);
      len = strlen(ehead_buffer);
      LYwaddnstr(LYwin,ehead_buffer,len);
      if (ehead_buffer != (char *)0x0) {
        free(ehead_buffer);
        ehead_buffer = (char *)0x0;
      }
    }
    else {
      __s = (char *)gettext("         Editing Bookmark DESCRIPTION and FILEPATH");
      len = strlen(__s);
      __s = (char *)gettext("         Editing Bookmark DESCRIPTION and FILEPATH");
      LYwaddnstr(LYwin,__s,len);
    }
    lynx_stop_h1_color();
    if (LYlines < 0x21) {
      a = MBM_current * 0xd + -0xd;
      while (a <= (MBM_current * 0x19) / 2) {
        LYmove(a + MBM_current * -0xd + 0x10,5);
        uVar4 = LYindex2MBM(a);
        waddch(LYwin,uVar4 & 0xff);
        LYwaddnstr(LYwin," : ",3);
        if (MBM_A_subdescript[a] != (char *)0x0) {
          len = strlen(MBM_A_subdescript[a]);
          LYwaddnstr(LYwin,MBM_A_subdescript[a],len);
        }
        LYmove(a + MBM_current * -0xd + 0x10,0x23);
        LYwaddnstr(LYwin,"| ",2);
        if (MBM_A_subbookmark[a] != (char *)0x0) {
          len = strlen(MBM_A_subbookmark[a]);
          LYwaddnstr(LYwin,MBM_A_subbookmark[a],len);
        }
        a = a + 1;
      }
    }
    else {
      a = 0;
      while (a < 0x1a) {
        LYmove(a + 3,5);
        uVar4 = LYindex2MBM(a);
        waddch(LYwin,uVar4 & 0xff);
        LYwaddnstr(LYwin," : ",3);
        if (MBM_A_subdescript[a] != (char *)0x0) {
          len = strlen(MBM_A_subdescript[a]);
          LYwaddnstr(LYwin,MBM_A_subdescript[a],len);
        }
        LYmove(a + 3,0x23);
        LYwaddnstr(LYwin,"| ",2);
        if (MBM_A_subbookmark[a] != (char *)0x0) {
          len = strlen(MBM_A_subbookmark[a]);
          LYwaddnstr(LYwin,MBM_A_subbookmark[a],len);
        }
        a = a + 1;
      }
    }
    if (LYlines < 0x21) {
      LYmove(LYlines + -4,0);
      LYwaddnstr(LYwin,"\'",1);
      lynx_start_bold();
      LYwaddnstr(LYwin,"[",1);
      lynx_stop_bold();
      LYwaddnstr(LYwin,"\' ",2);
      __s = (char *)gettext("previous");
      len = strlen(__s);
      __s = (char *)gettext("previous");
      LYwaddnstr(LYwin,__s,len);
      LYwaddnstr(LYwin,", \'",3);
      lynx_start_bold();
      LYwaddnstr(LYwin,"]",1);
      lynx_stop_bold();
      LYwaddnstr(LYwin,"\' ",2);
      __s = (char *)gettext("next screen");
      len = strlen(__s);
      __s = (char *)gettext("next screen");
      LYwaddnstr(LYwin,__s,len);
    }
    LYmove(LYlines + -3,0);
    if (no_option_save == '\0') {
      LYwaddnstr(LYwin,"\'",1);
      lynx_start_bold();
      LYwaddnstr(LYwin,">",1);
      lynx_stop_bold();
      LYwaddnstr(LYwin,"\'",1);
      __s = (char *)gettext(" to save,");
      len = strlen(__s);
      __s = (char *)gettext(" to save,");
      LYwaddnstr(LYwin,__s,len);
    }
    __s = (char *)gettext(&DAT_08158205);
    len = strlen(__s);
    __s = (char *)gettext(&DAT_08158205);
    LYwaddnstr(LYwin,__s,len);
    LYwaddnstr(LYwin,"\'",1);
    lynx_start_bold();
    LYwaddnstr(LYwin,"^G",2);
    lynx_stop_bold();
    LYwaddnstr(LYwin,"\'",1);
    __s = (char *)gettext(" to return to Lynx.");
    len = strlen(__s);
    __s = (char *)gettext(" to return to Lynx.");
    LYwaddnstr(LYwin,__s,len);
LAB_080a1d8c:
    do {
      if ((term_options != '\0') || (BVar2 = LYisNonAlnumKeyname(response,0x25), BVar2 != '\0'))
      goto LAB_080a1e4e;
      if ((response == 3) || (response == 7)) {
LAB_080a1e20:
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[response] & 0x4000) == 0) goto LAB_080a1e4e;
      }
      else {
        if (response == -1) {
          if (keymap[0] != 0x2f) goto LAB_080a1e41;
          goto LAB_080a1e20;
        }
        if ((response & 0x8800U) == 0) {
          if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_080a1e20;
        }
        else {
          if ((response & 0xffU) == 0x2f) goto LAB_080a1e20;
        }
      }
LAB_080a1e41:
      if (response == 0x3e) {
LAB_080a1e4e:
        term_options = '\0';
        signal(2,cleanup_sig);
        if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
          return;
        }
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      LYmove(LYlines + -2,0);
      lynx_start_prompt_color();
      __s = (char *)gettext("Letter: ");
      len = strlen(__s);
      __s = (char *)gettext("Letter: ");
      LYwaddnstr(LYwin,__s,len);
      lynx_stop_prompt_color();
      LYrefresh();
      if (def_response == 0) {
        local_134 = LYgetch_single();
      }
      else {
        local_134 = def_response;
      }
      response = local_134;
      def_response = 0;
    } while (term_options != '\0');
    if ((local_134 == 3) || (local_134 == 7)) {
LAB_080a1654:
      ppuVar5 = __ctype_b_loc();
      if (((*ppuVar5)[local_134] & 0x4000) == 0) goto LAB_080a1d8c;
    }
    else {
      if (local_134 == 0xffffffff) {
        if (keymap[0] != 0x2f) goto LAB_080a1679;
        goto LAB_080a1654;
      }
      if ((local_134 & 0x8800) == 0) {
        if (keymap[(local_134 & 0x7ff) + 1] == 0x2f) goto LAB_080a1654;
      }
      else {
        if ((local_134 & 0xff) == 0x2f) goto LAB_080a1654;
      }
    }
LAB_080a1679:
    BVar2 = LYisNonAlnumKeyname(local_134,0x25);
    if (BVar2 != '\0') goto LAB_080a1d8c;
    if (local_134 == 0x3e) {
      if (no_option_save == '\0') {
        __s = (char *)gettext("Saving Options...");
        HTInfoMsg(__s);
        iVar3 = save_rc((FILE *)0x0);
        if (iVar3 == 0) {
          __s = (char *)gettext("Unable to save Options!");
          HTAlert(__s);
        }
        else {
          __s = (char *)gettext("Options saved!");
          HTInfoMsg(__s);
        }
      }
      else {
        __s = (char *)gettext(" \'r\' to return to Lynx ");
        HTInfoMsg(__s);
        response = 0x20;
      }
      goto LAB_080a1d8c;
    }
    BVar2 = LYisNonAlnumKeyname(local_134,0x15);
    if (BVar2 != '\0') {
      lynx_force_repaint();
      goto LAB_080a1d8c;
    }
    if (((local_134 == 0x5d) || (BVar2 = LYisNonAlnumKeyname(local_134,0xf), BVar2 != '\0')) &&
       (LYlines < 0x21)) {
      MBM_current = MBM_current + 1;
      if (2 < MBM_current) {
        MBM_current = 1;
      }
      goto draw_bookmark_list;
    }
    if (((local_134 != 0x5b) && (BVar2 = LYisNonAlnumKeyname(local_134,0x10), BVar2 == '\0')) ||
       (0x20 < LYlines)) {
      a = 0;
      while (a < 0x1a) {
        iVar3 = LYMBM2index(local_134);
        if (iVar3 == a) {
          if (LYlines < 0x21) {
            if ((MBM_current == 1) && (0xc < a)) {
              MBM_current = 2;
              def_response = local_134;
              goto draw_bookmark_list;
            }
            if ((MBM_current == 2) && (a < 0xc)) {
              MBM_current = 1;
              def_response = local_134;
              goto draw_bookmark_list;
            }
          }
          mustshow = '\x01';
          __s = (char *)gettext("Hit RETURN to accept entered data.");
          statusline(__s);
          if (0 < a) {
            lynx_start_bold();
            if (LYlines < 0x21) {
              LYmove(a + MBM_current * -0xd + 0x10,9);
            }
            else {
              LYmove(a + 3,9);
            }
            if (MBM_A_subdescript[a] == (char *)0x0) {
              local_130 = "";
            }
            else {
              local_130 = MBM_A_subdescript[a];
            }
            LYstrncpy(MBM_tmp_line,local_130,0xff);
            LYgetstr(MBM_tmp_line,0,0x100,NORECALL);
            lynx_stop_bold();
            if (MBM_tmp_line[0] == '\0') {
              if (MBM_A_subdescript[a] != (char *)0x0) {
                free(MBM_A_subdescript[a]);
                MBM_A_subdescript[a] = (char *)0x0;
              }
            }
            else {
              HTSACopy(MBM_A_subdescript + a,MBM_tmp_line);
            }
            if (LYlines < 0x21) {
              LYmove(a + MBM_current * -0xd + 0x10,5);
            }
            else {
              LYmove(a + 3,5);
            }
            uVar4 = LYindex2MBM(a);
            waddch(LYwin,uVar4 & 0xff);
            LYwaddnstr(LYwin," : ",3);
            if (MBM_A_subdescript[a] != (char *)0x0) {
              len = strlen(MBM_A_subdescript[a]);
              LYwaddnstr(LYwin,MBM_A_subdescript[a],len);
            }
            LYclrtoeol();
            LYrefresh();
          }
          if (LYlines < 0x21) {
            LYmove(a + MBM_current * -0xd + 0x10,0x23);
          }
          else {
            LYmove(a + 3,0x23);
          }
          LYwaddnstr(LYwin,"| ",2);
          lynx_start_bold();
          if (MBM_A_subbookmark[a] == (char *)0x0) {
            local_12c = "";
          }
          else {
            local_12c = MBM_A_subbookmark[a];
          }
          LYstrncpy(MBM_tmp_line,local_12c,0xff);
          LYgetstr(MBM_tmp_line,0,0x100,NORECALL);
          lynx_stop_bold();
          if (MBM_tmp_line[0] == '\0') {
            if (a == 0) {
              HTSACopy(MBM_A_subbookmark,bookmark_page);
            }
            else {
              if (MBM_A_subbookmark[a] != (char *)0x0) {
                free(MBM_A_subbookmark[a]);
                MBM_A_subbookmark[a] = (char *)0x0;
              }
            }
          }
          else {
            BVar2 = LYPathOffHomeOK(MBM_tmp_line,0x100);
            if (BVar2 == '\0') {
              __s = (char *)gettext("Use a filepath off your home directory!");
              LYMBM_statusline(__s);
              LYSleepAlert();
            }
            else {
              HTSACopy(MBM_A_subbookmark + a,MBM_tmp_line);
              if (a == 0) {
                HTSACopy(&bookmark_page,MBM_A_subbookmark[0]);
              }
            }
          }
          if (LYlines < 0x21) {
            LYmove(a + MBM_current * -0xd + 0x10,0x23);
          }
          else {
            LYmove(a + 3,0x23);
          }
          LYwaddnstr(LYwin,"| ",2);
          if (MBM_A_subbookmark[a] != (char *)0x0) {
            len = strlen(MBM_A_subbookmark[a]);
            LYwaddnstr(LYwin,MBM_A_subbookmark[a],len);
          }
          LYclrtoeol();
          LYmove(LYlines + -1,0);
          LYclrtoeol();
          break;
        }
        a = a + 1;
      }
      goto LAB_080a1d8c;
    }
    MBM_current = MBM_current + -1;
    if (MBM_current < 1) {
      MBM_current = 2;
    }
  } while( true );
}



int popup_choice(int cur_choice,int line,int column,char **choices,int i_length,int disabled,
                BOOLEAN for_mouse)

{
  int iVar1;
  char *Msg;
  byte local_c;
  
  if (column < 0) {
    column = 0x23;
  }
  term_options = '\0';
  iVar1 = LYhandlePopupList(cur_choice,line,column,choices,-1,i_length,disabled,for_mouse);
  if (((iVar1 - 0xdU < 0x19) &&
      (local_c = (byte)(iVar1 - 0xdU), (1 << (local_c & 0x1f) & 0x1000003U) != 0)) &&
     (term_options = '\x01', for_mouse == '\0')) {
    Msg = (char *)gettext("Cancelled!!!");
    HTUserMsg(Msg);
  }
  if ((disabled == 0) && (term_options == '\0')) {
    if (for_mouse == '\0') {
      mustshow = '\x01';
      Msg = (char *)gettext("Value accepted!");
      statusline(Msg);
    }
  }
  else {
    mustshow = '\x01';
    statusline("");
  }
  return iVar1;
}



void PutOptValues(FILE *fp,int value,OptValues *table)

{
  undefined4 uVar1;
  char *local_8;
  
  while (table->LongName != (char *)0x0) {
    if (table->HtmlName != (char *)0x0) {
      uVar1 = gettext(table->LongName);
      if (table->value == value) {
        local_8 = "selected";
      }
      else {
        local_8 = "";
      }
      fprintf((FILE *)fp,"<option value=\"%s\" %s>%s\n",table->HtmlName,local_8,uVar1);
    }
    table = table + 1;
  }
  return;
}



BOOLEAN GetOptValues(OptValues *table,char *value,int *result)

{
  int iVar1;
  
  while( true ) {
    if (table->LongName == (char *)0x0) {
      return '\0';
    }
    if ((table->HtmlName != (char *)0x0) && (iVar1 = strcmp(value,table->HtmlName), iVar1 == 0))
    break;
    table = table + 1;
  }
  *result = table->value;
  return '\x01';
}



PostPair * break_data(bstring *data)

{
  char *pcVar1;
  FILE *__stream;
  char *pcVar2;
  size_t sVar3;
  ushort **ppuVar4;
  PostPair *local_34;
  char *local_30;
  size_t len;
  size_t i;
  int count;
  PostPair *q;
  char *p;
  
  count = 0;
  if (((data == (bstring *)0x0) || (data == (bstring *)0x0)) || (data->len == 0)) {
    local_34 = (PostPair *)0x0;
  }
  else {
    if (data == (bstring *)0x0) {
      local_30 = (char *)0x0;
    }
    else {
      local_30 = data->str;
    }
    p = local_30;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"break_data %s\n",local_30);
    }
    q = (PostPair *)calloc(1,8);
    if (q == (PostPair *)0x0) {
      outofmem("./LYOptions.c","break_data(calloc)");
    }
    do {
      pcVar2 = LYstrsep(&p,"&");
      q[count].value = pcVar2;
      pcVar2 = LYstrsep(&q[count].value,"=");
      q[count].tag = pcVar2;
      HTUnEscape(q[count].tag);
      sVar3 = strlen(q[count].value);
      i = 0;
      while (i < sVar3) {
        if (q[count].value[i] == '+') {
          if (((i == 0) || (q[count].value[i + 1] != '+')) ||
             (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)q[count].value[i + 2]] & 8) == 0)) {
            q[count].value[i] = ' ';
          }
          else {
            q[count].value[i] = ' ';
            i = i + 2;
          }
        }
        i = i + 1;
      }
      HTUnEscape(q[count].value);
      if (WWW_TraceFlag != '\0') {
        pcVar2 = q[count].value;
        pcVar1 = q[count].tag;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"...item[%d] tag=%s, value=%s\n",count,pcVar1,pcVar2);
      }
      local_34 = (PostPair *)realloc(q,(count + 2) * 8);
      if (local_34 == (PostPair *)0x0) {
        outofmem("./LYOptions.c","break_data(realloc)");
      }
      local_34[count + 1].tag = (char *)0x0;
    } while ((p != (char *)0x0) && (count = count + 1, q = local_34, *p != '\0'));
  }
  return local_34;
}



BOOLEAN isLynxOptionsPage(char *address,char *portion)

{
  int iVar1;
  size_t n;
  uint len;
  BOOLEAN result;
  
  result = '\0';
  iVar1 = strncasecomp(address,"LYNXOPTIONS:",0xc);
  if (iVar1 == 0) {
    n = strlen(portion);
    address = address + 0xc;
    iVar1 = strncasecomp(address,portion,n);
    if ((iVar1 == 0) && ((address[n] == '\0' || (address[n] == '/')))) {
      result = '\x01';
    }
  }
  return result;
}



int postoptions(DocInfo *newdoc)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  BOOLEAN BVar6;
  BOOLEAN BVar7;
  PostPair *__ptr;
  int iVar8;
  char *url;
  char *fmt;
  int iVar9;
  int iVar10;
  FILE *__stream;
  int local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  DocAddress WWWDoc;
  int j_1;
  int newval_2;
  int newval_1;
  int j;
  int newval;
  char *buf;
  int status;
  int CurrentShowColor;
  int old_media_value;
  int display_char_set_old;
  int code;
  int i;
  PostPair *data;
  BOOLEAN need_end_reload;
  BOOLEAN need_reload;
  BOOLEAN assume_char_set_changed;
  BOOLEAN raw_mode_old;
  BOOLEAN save_all;
  
  BVar7 = LYRawMode;
  iVar5 = current_char_set;
  iVar8 = LYAcceptMedia;
  code = 0;
  bVar2 = false;
  bVar1 = false;
  bVar3 = false;
  bVar4 = false;
  CurrentShowColor = LYShowColor;
  BVar6 = isLynxOptionsPage(newdoc->address,"//MBM_MENU");
  if (BVar6 != '\0') {
    if (newdoc->post_data != (bstring *)0x0) {
      free(newdoc->post_data);
      newdoc->post_data = (bstring *)0x0;
    }
    if (no_bookmark != '\0') {
      url = (char *)gettext("You are not allowed to change the bookmark file!");
      HTAlert(url);
      return 3;
    }
    if (dump_output_immediately != '\0') {
      return 0;
    }
    edit_bookmarks();
    return 3;
  }
  BVar6 = isLynxOptionsPage(newdoc->address,"/");
  if (BVar6 == '\0') {
    url = (char *)gettext("Random URL is disallowed!  Use a shortcut.");
    HTAlert(url);
    return 3;
  }
  __ptr = break_data(newdoc->post_data);
  if (__ptr == (PostPair *)0x0) {
    iVar8 = gen_options(&newdoc->address);
    if (iVar8 == 1) {
      WWWDoc.address = newdoc->address;
      WWWDoc.post_data = newdoc->post_data;
      WWWDoc.post_content_type = newdoc->post_content_type;
      WWWDoc.bookmark = newdoc->bookmark;
      WWWDoc.isHEAD = newdoc->isHEAD;
      WWWDoc.safe = newdoc->safe;
      BVar7 = HTLoadAbsolute(&WWWDoc);
      if (BVar7 == '\0') {
        return 0;
      }
      LYRegisterUIPage(newdoc->address,UIP_OPTIONS_MENU);
      lynx_edit_mode = '\0';
      return 1;
    }
    HTAlwaysAlert("Unexpected way of accessing",newdoc->address);
    if (newdoc->address == (char *)0x0) {
      return iVar8;
    }
    free(newdoc->address);
    newdoc->address = (char *)0x0;
    return iVar8;
  }
  url = HTLoadedDocumentURL();
  BVar6 = LYIsUIPage3(url,UIP_OPTIONS_MENU,0);
  if (BVar6 == '\0') {
    url = HTLoadedDocumentURL();
    BVar6 = LYIsUIPage3(url,UIP_VLINKS,0);
    if (BVar6 == '\0') {
      buf = (char *)0x0;
      url = key_for_func_ext(0x31,0);
      fmt = (char *)gettext("Use %s to invoke the Options menu!");
      HTSprintf0(&buf,fmt,url);
      HTAlert(buf);
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      if (__ptr != (PostPair *)0x0) {
        free(__ptr);
      }
      return 0;
    }
  }
  i = 0;
  while (__ptr[i].tag != (char *)0x0) {
    iVar9 = strcmp(__ptr[i].tag,secure_string);
    if (iVar9 == 0) {
      if ((secure_value == (char *)0x0) || (iVar9 = strcmp(__ptr[i].value,secure_value), iVar9 != 0)
         ) {
        buf = (char *)0x0;
        url = key_for_func_ext(0x31,0);
        fmt = (char *)gettext("Use %s to invoke the Options menu!");
        HTSprintf0(&buf,fmt,url);
        HTAlert(buf);
        if (__ptr != (PostPair *)0x0) {
          free(__ptr);
        }
        return 3;
      }
      if (secure_value != (char *)0x0) {
        free(secure_value);
        secure_value = (char *)0x0;
      }
    }
    iVar9 = strcmp(__ptr[i].tag,save_options_string);
    if ((iVar9 == 0) && (no_option_save == '\0')) {
      bVar2 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,cookies_string);
    if (iVar9 == 0) {
      iVar9 = strcmp(__ptr[i].value,cookies_ignore_all_string);
      if (iVar9 == 0) {
        LYSetCookies = '\0';
      }
      else {
        iVar9 = strcmp(__ptr[i].value,cookies_up_to_user_string);
        if (iVar9 == 0) {
          LYSetCookies = '\x01';
          LYAcceptAllCookies = '\0';
        }
        else {
          iVar9 = strcmp(__ptr[i].value,cookies_accept_all_string);
          if (iVar9 == 0) {
            LYSetCookies = '\x01';
            LYAcceptAllCookies = '\x01';
          }
        }
      }
    }
    iVar9 = strcmp(__ptr[i].tag,x_display_string);
    if (iVar9 == 0) {
      LYsetXDisplay(__ptr[i].value);
      validate_x_display();
      summarize_x_display(__ptr[i].value);
    }
    iVar9 = strcmp(__ptr[i].tag,editor_string);
    if (iVar9 == 0) {
      if (editor != (char *)0x0) {
        free(editor);
        editor = (char *)0x0;
      }
      HTSACopy(&editor,__ptr[i].value);
    }
    iVar9 = strcmp(__ptr[i].tag,emacs_keys_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      emacs_keys = (BOOLEAN)code;
      if (emacs_keys == '\0') {
        reset_emacs_keys();
      }
      else {
        set_emacs_keys();
      }
    }
    iVar9 = strcmp(__ptr[i].tag,keypad_mode_string);
    if (iVar9 == 0) {
      buf = (char *)0x0;
      BVar6 = GetOptValues(keypad_mode_values,__ptr[i].value,(int *)&buf);
      if ((BVar6 != '\0') && ((char *)keypad_mode != buf)) {
        keypad_mode = (int)buf;
        bVar3 = true;
        if (buf == (char *)0x0) {
          set_numbers_as_arrows();
        }
        else {
          reset_numbers_as_arrows();
        }
      }
    }
    iVar9 = strcmp(__ptr[i].tag,lineedit_mode_string);
    if (iVar9 == 0) {
      iVar9 = atoi(__ptr[i].value);
      j = 0;
      while (LYLineeditNames[j] != (char *)0x0) {
        if (j == iVar9) {
          current_lineedit = iVar9;
        }
        j = j + 1;
      }
    }
    iVar9 = strcmp(__ptr[i].tag,mail_address_string);
    if (iVar9 == 0) {
      if (personal_mail_address != (char *)0x0) {
        free(personal_mail_address);
        personal_mail_address = (char *)0x0;
      }
      HTSACopy(&personal_mail_address,__ptr[i].value);
    }
    iVar9 = strcmp(__ptr[i].tag,anonftp_password_string);
    if (iVar9 == 0) {
      if (anonftp_password != (char *)0x0) {
        free(anonftp_password);
        anonftp_password = (char *)0x0;
      }
      HTSACopy(&anonftp_password,__ptr[i].value);
    }
    iVar9 = strcmp(__ptr[i].tag,search_type_string);
    if ((iVar9 == 0) &&
       (BVar6 = GetOptValues(search_type_values,__ptr[i].value,&code), BVar6 != '\0')) {
      case_sensitive = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,DTD_recovery_string);
    if (((iVar9 == 0) && (BVar6 = GetOptValues(DTD_type_values,__ptr[i].value,&code), BVar6 != '\0')
        ) && (Old_DTD != code)) {
      Old_DTD = code;
      HTSwitchDTD((uint)(code == 0));
      bVar3 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,select_popups_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYSelectPopups = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,show_color_string);
    if ((iVar9 == 0) &&
       (BVar6 = GetOptValues(show_color_values,__ptr[i].value,&LYChosenShowColor), BVar6 != '\0')) {
      if (can_do_colors != '\0') {
        LYShowColor = LYChosenShowColor;
      }
      if (CurrentShowColor != LYShowColor) {
        lynx_force_repaint();
      }
      CurrentShowColor = LYShowColor;
    }
    iVar9 = strcmp(__ptr[i].tag,show_cursor_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYShowCursor = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,underline_links_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYUnderlineLinks = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,show_scrollbar_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYShowScrollbar = (BOOLEAN)code;
      bVar3 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,cookie_prompt_string);
    if (iVar9 == 0) {
      GetOptValues(prompt_values,__ptr[i].value,&cookie_noprompt);
    }
    iVar9 = strcmp(__ptr[i].tag,user_mode_string);
    if ((iVar9 == 0) &&
       (BVar6 = GetOptValues(user_mode_values,__ptr[i].value,&user_mode), BVar6 != '\0')) {
      LYSetDisplayLines();
    }
    iVar9 = strcmp(__ptr[i].tag,visited_links_string);
    if (iVar9 == 0) {
      GetOptValues(visited_links_values,__ptr[i].value,&Visited_Links_As);
    }
    iVar9 = strcmp(__ptr[i].tag,images_string);
    if (iVar9 == 0) {
      iVar9 = strcmp(__ptr[i].value,images_ignore_all_string);
      if ((iVar9 == 0) && ((pseudo_inline_alts != '\0' || (clickable_images != '\0')))) {
        pseudo_inline_alts = '\0';
        clickable_images = '\0';
        bVar3 = true;
      }
      else {
        iVar9 = strcmp(__ptr[i].value,images_use_label_string);
        if ((iVar9 == 0) && ((pseudo_inline_alts != '\x01' || (clickable_images != '\0')))) {
          pseudo_inline_alts = '\x01';
          clickable_images = '\0';
          bVar3 = true;
        }
        else {
          iVar9 = strcmp(__ptr[i].value,images_use_links_string);
          if ((iVar9 == 0) && (clickable_images != '\x01')) {
            clickable_images = '\x01';
            bVar3 = true;
          }
        }
      }
    }
    iVar9 = strcmp(__ptr[i].tag,verbose_images_string);
    if (((iVar9 == 0) &&
        (BVar6 = GetOptValues(verbose_images_type_values,__ptr[i].value,&code), BVar6 != '\0')) &&
       ((int)verbose_img != code)) {
      verbose_img = (BOOLEAN)code;
      bVar3 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,vi_keys_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      vi_keys = (BOOLEAN)code;
      if (vi_keys == '\0') {
        reset_vi_keys();
      }
      else {
        set_vi_keys();
      }
    }
    iVar9 = strcmp(__ptr[i].tag,mbm_string);
    if ((iVar9 == 0) && (LYMBMBlocked == '\0')) {
      GetOptValues(mbm_values,__ptr[i].value,&LYMultiBookmarks);
    }
    iVar9 = strcmp(__ptr[i].tag,single_bookmark_string);
    if (((iVar9 == 0) && (no_bookmark == '\0')) && (*__ptr[i].value != '\0')) {
      if (bookmark_page != (char *)0x0) {
        free(bookmark_page);
        bookmark_page = (char *)0x0;
      }
      HTSACopy(&bookmark_page,__ptr[i].value);
    }
    iVar9 = strcmp(__ptr[i].tag,assume_char_set_string);
    if (((iVar9 == 0) && (iVar9 = UCGetLYhndl_byMIME(__ptr[i].value), -1 < iVar9)) &&
       (((BVar7 != '\0' && (iVar10 = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset), iVar10 != iVar9))
        || ((BVar7 == '\0' && (iVar9 != UCLYhndl_for_unspec)))))) {
      UCLYhndl_for_unspec = iVar9;
      HTSACopy(&UCAssume_MIMEcharset,__ptr[i].value);
      bVar1 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,locale_charset_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYLocaleCharset = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,display_char_set_string);
    if (iVar9 == 0) {
      iVar9 = atoi(__ptr[i].value);
      j_1 = 0;
      while (LYchar_set_names[j_1] != (char *)0x0) {
        if (j_1 == iVar9) {
          current_char_set = iVar9;
        }
        j_1 = j_1 + 1;
      }
    }
    iVar9 = strcmp(__ptr[i].tag,raw_mode_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYRawMode = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,passive_ftp_string);
    if (iVar9 == 0) {
      ftp_passive = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,ftp_sort_string);
    if (iVar9 == 0) {
      GetOptValues(ftp_sort_values,__ptr[i].value,&HTfileSortMethod);
    }
    iVar9 = strcmp(__ptr[i].tag,dired_list_string);
    if (iVar9 == 0) {
      GetOptValues(dired_list_values,__ptr[i].value,&dir_list_style);
    }
    iVar9 = strcmp(__ptr[i].tag,dired_sort_string);
    if (iVar9 == 0) {
      GetOptValues(dired_sort_values,__ptr[i].value,&dir_list_order);
    }
    iVar9 = strcmp(__ptr[i].tag,show_dotfiles_string);
    if (((iVar9 == 0) && (no_dotfiles == '\0')) &&
       (BVar6 = GetOptValues(bool_values,__ptr[i].value,&code), BVar6 != '\0')) {
      show_dotfiles = (BOOLEAN)code;
    }
    iVar9 = strcmp(__ptr[i].tag,show_rate_string);
    if ((iVar9 == 0) && (BVar6 = GetOptValues(rate_values,__ptr[i].value,&code), BVar6 != '\0')) {
      LYTransferRate = code;
    }
    iVar9 = strcmp(__ptr[i].tag,preferred_media_string);
    if (iVar9 == 0) {
      GetOptValues(media_values,__ptr[i].value,&LYAcceptMedia);
    }
    iVar9 = strcmp(__ptr[i].tag,preferred_encoding_string);
    if (iVar9 == 0) {
      GetOptValues(encoding_values,__ptr[i].value,&LYAcceptEncoding);
    }
    iVar9 = strcmp(__ptr[i].tag,preferred_doc_char_string);
    if ((iVar9 == 0) && (iVar9 = strcmp(pref_charset,__ptr[i].value), iVar9 != 0)) {
      if (pref_charset != (char *)0x0) {
        free(pref_charset);
        pref_charset = (char *)0x0;
      }
      HTSACopy(&pref_charset,__ptr[i].value);
      bVar4 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,preferred_doc_lang_string);
    if ((iVar9 == 0) && (iVar9 = strcmp(language,__ptr[i].value), iVar9 != 0)) {
      if (language != (char *)0x0) {
        free(language);
        language = (char *)0x0;
      }
      HTSACopy(&language,__ptr[i].value);
      bVar4 = true;
    }
    iVar9 = strcmp(__ptr[i].tag,user_agent_string);
    if (((iVar9 == 0) && (no_useragent == '\0')) &&
       (iVar9 = strcmp(LYUserAgent,__ptr[i].value), iVar9 != 0)) {
      bVar4 = true;
      if (LYUserAgent != (char *)0x0) {
        free(LYUserAgent);
        LYUserAgent = (char *)0x0;
      }
      if (*__ptr[i].value == '\0') {
        local_68 = LYUserAgentDefault;
      }
      else {
        local_68 = __ptr[i].value;
      }
      HTSACopy(&LYUserAgent,local_68);
      BVar6 = LYCheckUserAgent();
      if (BVar6 == '\0') {
        url = (char *)gettext(
                             "Use \"L_y_n_x\" or \"Lynx\" in User-Agent, or it looks like intentional deception!"
                             );
        HTAlert(url);
      }
    }
    i = i + 1;
  }
  LYFindLocaleCharset();
  if (iVar8 != LYAcceptMedia) {
    HTFilterPresentations();
  }
  if (((iVar5 != current_char_set) || (BVar7 != LYRawMode)) || (bVar1)) {
    if (iVar5 != current_char_set) {
      LYUseDefaultRawMode = '\x01';
      HTMLUseCharacterSet(current_char_set);
    }
    if ((bVar1) && (HTCJK != JAPANESE)) {
      LYRawMode = UCLYhndl_for_unspec == current_char_set;
    }
    if ((BVar7 != LYRawMode) || (bVar1)) {
      HTMLSetUseDefaultRawMode(current_char_set,LYRawMode);
      HTMLSetCharacterHandling(current_char_set);
    }
    bVar3 = true;
  }
  HTSABFree(&newdoc->post_data);
  if (__ptr != (PostPair *)0x0) {
    free(__ptr);
  }
  if (bVar2) {
    url = (char *)gettext("Saving Options...");
    HTInfoMsg(url);
    LYrcShowColor = LYChosenShowColor;
    iVar8 = save_rc((FILE *)0x0);
    if (iVar8 == 0) {
      url = (char *)gettext("Unable to save Options!");
      HTAlert(url);
    }
    else {
      url = (char *)gettext("Options saved!");
      HTInfoMsg(url);
    }
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nLYOptions.c/postoptions(): exiting...\n");
  }
  if (WWW_TraceFlag != '\0') {
    if (bVar3) {
      local_64 = "TRUE";
    }
    else {
      local_64 = "FALSE";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"                            need_reload = %s\n",local_64);
  }
  if (WWW_TraceFlag != '\0') {
    if (bVar4) {
      local_60 = "TRUE";
    }
    else {
      local_60 = "FALSE";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"                            need_end_reload = %s\n",local_60);
  }
  LYpop(newdoc);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  LYforce_no_cache = '\0';
  LYoverride_no_cache = '\x01';
  BVar7 = HTLoadAbsolute(&WWWDoc);
  if (BVar7 == '\0') {
    return 0;
  }
  HTuncache_current_document();
  LYpop(newdoc);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  LYforce_no_cache = '\0';
  LYoverride_no_cache = '\x01';
  BVar7 = HTLoadAbsolute(&WWWDoc);
  if (BVar7 == '\0') {
    return 0;
  }
  reloading = '\0';
  if (bVar4) {
    iVar8 = strncmp(newdoc->address,"http",4);
    if (iVar8 != 0) {
      if (((*newdoc->address == 'l') || (*newdoc->address == 'L')) &&
         (iVar8 = strncasecomp(newdoc->address,"lynxcgi:",8), iVar8 == 0)) {
        bVar1 = true;
      }
      else {
        bVar1 = false;
      }
      if (bVar1) goto LAB_080a398a;
    }
    reloading = '\x01';
    bVar3 = true;
  }
LAB_080a398a:
  if (bVar3) {
    iVar8 = HTisDocumentSource();
    if (iVar8 != 0) {
      srcmode_for_next_retrieval(1);
    }
    if ((reloading == '\0') && (BVar7 = HTcan_reparse_document(), BVar7 != '\0')) {
      BVar7 = HTreparse_document();
      if (BVar7 == '\0') {
        srcmode_for_next_retrieval(0);
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYOptions.c/postoptions(): now really exit.\n\n");
      }
      local_6c = 1;
    }
    else {
      if ((newdoc->post_data == (bstring *)0x0) ||
         ((newdoc->safe != '\0' ||
          (BVar7 = confirm_post_resub(newdoc->address,newdoc->title,2,1), BVar7 != '\0')))) {
        HEAD_request = HTLoadedDocumentIsHEAD();
        HTuncache_current_document();
        LYpush(newdoc,'\0');
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYOptions.c/postoptions(): now really exit.\n\n");
        }
        local_6c = 3;
      }
      else {
        url = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(url);
        iVar8 = HTisDocumentSource();
        if (iVar8 != 0) {
          srcmode_for_next_retrieval(0);
        }
        local_6c = 1;
      }
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOptions.c/postoptions(): now really exit.\n\n");
    }
    local_6c = 1;
  }
  return local_6c;
}



char * NewSecureValue(void)

{
  char oops [2];
  long lVar1;
  char *local_18;
  long key;
  
  if (secure_value != (char *)0x0) {
    free(secure_value);
    secure_value = (char *)0x0;
  }
  secure_value = (char *)malloc(0x50);
  if (secure_value == (char *)0x0) {
    local_18 = &ram0x08195f00;
  }
  else {
    lVar1 = random();
    sprintf(secure_value,"%ld",lVar1);
    local_18 = secure_value;
  }
  return local_18;
}



void PutLabel(FILE *fp,char *name,char *value)

{
  bool bVar1;
  BOOLEAN BVar2;
  size_t len;
  char *local_18;
  int need;
  int want;
  int have;
  
  len = strlen(name);
  need = LYstrExtent(name,len,0x21);
  if (no_margins == '\0') {
    local_18 = "&nbsp;&nbsp;";
  }
  else {
    local_18 = "";
  }
  fprintf((FILE *)fp,"%s%s",local_18,name);
  BVar2 = will_save_rc(value);
  if ((BVar2 == '\0') || (no_option_save != '\0')) {
    if (need < 0x1e) {
      fwrite("&nbsp;",1,6,(FILE *)fp);
      need = need + 1;
    }
    fwrite(&DAT_08159104,1,3,(FILE *)fp);
    while (bVar1 = need < 0x1e, need = need + 1, bVar1) {
      fwrite("&nbsp;",1,6,(FILE *)fp);
    }
  }
  else {
    while (bVar1 = need < 0x21, need = need + 1, bVar1) {
      fwrite("&nbsp;",1,6,(FILE *)fp);
    }
  }
  fwrite(&DAT_08159108,1,2,(FILE *)fp);
  return;
}



char * check_if_write_lynxrc(char **table)

{
  BOOLEAN BVar1;
  char *result;
  int n;
  
  result = (char *)0x0;
  n = 0;
  while( true ) {
    if (table[n] == (char *)0x0) {
      return result;
    }
    result = table[n];
    BVar1 = will_save_rc(result);
    if (BVar1 == '\0') break;
    n = n + 1;
  }
  return result;
}



char * will_save_cookies(void)

{
  char *table [3];
  char *pcVar1;
  
  pcVar1 = check_if_write_lynxrc((char **)&ram0x08195f04);
  return pcVar1;
}



char * will_save_images(void)

{
  char *table [3];
  char *pcVar1;
  
  pcVar1 = check_if_write_lynxrc((char **)&ram0x08195f10);
  return pcVar1;
}



void LYMenuVisitedLinks(FILE *fp0,int disable_all)

{
  char *local_8;
  
  if (disable_all == 0) {
    local_8 = "";
  }
  else {
    local_8 = "disabled";
  }
  fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",visited_links_string,local_8);
  PutOptValues(fp0,Visited_Links_As,visited_links_values);
  fwrite("</select>\n",1,10,(FILE *)fp0);
  return;
}



int gen_options(char **newfile)

{
  int iVar1;
  char tempfile [256];
  FILE *fp0_00;
  char *local_1c0;
  undefined4 local_1bc;
  undefined4 uVar2;
  size_t sVar3;
  int in_GS_OFFSET;
  bool bVar4;
  char *local_1c8;
  int local_1b0;
  int local_1a8;
  int local_1a4;
  char *local_19c;
  char *local_198;
  char *local_194;
  char *local_190;
  char *local_18c;
  char *local_188;
  char *local_180;
  char *local_17c;
  char *local_174;
  char *local_16c;
  char *local_164;
  char *local_160;
  char *local_158;
  char *local_154;
  char *local_150;
  char *local_14c;
  char *local_148;
  char *local_140;
  char *local_138;
  char *local_134;
  char *local_130;
  char *local_12c;
  char *local_124;
  char *local_120;
  char *local_118;
  char *local_114;
  char *local_110;
  char *local_10c;
  char *local_104;
  char *local_100;
  char *local_fc;
  char *local_f8;
  char *local_f4;
  char *local_f0;
  char *local_ec;
  char *local_e8;
  char *local_e4;
  char *local_e0;
  char *local_d8;
  char *local_d0;
  char *local_c8;
  char *local_c4;
  char *local_bc;
  char *local_b8;
  char *local_b4;
  char *local_b0;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *local_9c;
  char *local_98;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char *local_74;
  char *local_70;
  char *local_6c;
  char *local_64;
  char *local_5c;
  char *local_58;
  char *local_54;
  char *local_50;
  char *message;
  int curval;
  size_t len;
  size_t text_len;
  size_t cset_len;
  FILE *fp0;
  int i;
  BOOLEAN disable_all;
  char temp [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cset_len = 0;
  if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < 0x2e) {
    local_1b0 = 7;
  }
  else {
    if (no_margins == '\0') {
      local_1a8 = 0x25;
    }
    else {
      local_1a8 = 0x23;
    }
    local_1b0 = (LYcols - (uint)(LYShowScrollbar != '\0')) - local_1a8;
  }
  fp0_00 = InternalPageFP((char *)&ram0x08195f20,1);
  if (fp0_00 == (FILE *)0x0) {
    local_1a4 = 0;
  }
  else {
    LYLocalFileToURL(newfile,(char *)0x8195f20);
    LYforce_no_cache = '\x01';
    bVar4 = LYUseFormsOptions == '\0';
    local_1c0 = (char *)gettext("Options Menu");
    BeginInternalPage(fp0_00,local_1c0,(char *)0x0);
    fprintf((FILE *)fp0_00,"<form action=\"%s\" method=\"post\">\n","LYNXOPTIONS:");
    local_1c0 = NewSecureValue();
    fprintf((FILE *)fp0_00,"<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",secure_string,
            local_1c0);
    fwrite("<p align=center>\n",1,0x11,(FILE *)fp0_00);
    if (!bVar4) {
      local_1bc = gettext("Accept Changes");
      fprintf((FILE *)fp0_00,"<input type=\"submit\" value=\"%s\"> - \n",local_1bc);
      local_1bc = gettext("Reset Changes");
      fprintf((FILE *)fp0_00,"<input type=\"reset\" value=\"%s\"> - \n",local_1bc);
      local_1bc = gettext("Left Arrow cancels changes");
      fprintf((FILE *)fp0_00,"%s - \n",local_1bc);
    }
    local_1bc = gettext("HELP!");
    local_1c0 = "keystrokes/option_help.html.gz";
    fprintf((FILE *)fp0_00,"<a href=\"%s%s\">%s</a>\n",helpfilepath,"keystrokes/option_help.html.gz"
            ,local_1bc);
    if (no_option_save == '\0') {
      if (!bVar4) {
        uVar2 = gettext("Save options to disk");
        fprintf((FILE *)fp0_00,"<p align=center>%s: ",uVar2,local_1c0,local_1bc);
        fprintf((FILE *)fp0_00,"<input type=\"checkbox\" name=\"%s\">\n",save_options_string);
      }
      uVar2 = gettext("(options marked with (!) will not be saved)");
      fprintf((FILE *)fp0_00,"<br>%s\n",uVar2,local_1c0,local_1bc);
    }
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    uVar2 = gettext("General Preferences");
    if (no_margins == '\0') {
      local_19c = "&nbsp;&nbsp;";
    }
    else {
      local_19c = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_19c,uVar2,local_1bc);
    local_1c0 = user_mode_string;
    local_1c8 = (char *)gettext("User mode");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_198 = "disabled";
    }
    else {
      local_198 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",user_mode_string,local_198);
    PutOptValues(fp0_00,user_mode,user_mode_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = editor_string;
    local_1c8 = (char *)gettext("Editor");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_194 = "disabled";
    }
    else {
      if ((no_editor == '\0') && (system_editor == '\0')) {
        local_190 = "";
      }
      else {
        local_190 = "disabled";
      }
      local_194 = local_190;
    }
    if (editor == (char *)0x0) {
      local_18c = "";
    }
    else {
      local_18c = editor;
    }
    fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",local_1b0,
            editor_string,local_18c,local_194);
    local_1c0 = search_type_string;
    local_1c8 = (char *)gettext("Type of Search");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_188 = "disabled";
    }
    else {
      local_188 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",search_type_string,local_188,local_18c,
            local_194);
    PutOptValues(fp0_00,(int)case_sensitive,search_type_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1bc = gettext("Security and Privacy");
    if (no_margins == '\0') {
      local_180 = "&nbsp;&nbsp;";
    }
    else {
      local_180 = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_180,local_1bc);
    local_1c0 = will_save_cookies();
    local_1c8 = (char *)gettext("Cookies");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_17c = "disabled";
    }
    else {
      local_17c = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",cookies_string,local_17c);
    local_1bc = gettext(cookies_ignore_all_string);
    if (LYSetCookies == '\0') {
      local_174 = "selected";
    }
    else {
      local_174 = "";
    }
    fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",cookies_ignore_all_string,local_174,
            local_1bc);
    local_1bc = gettext(cookies_up_to_user_string);
    if ((LYSetCookies == '\0') || (LYAcceptAllCookies != '\0')) {
      local_16c = "";
    }
    else {
      local_16c = "selected";
    }
    fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",cookies_up_to_user_string,local_16c,
            local_1bc);
    local_1bc = gettext(cookies_accept_all_string);
    if ((LYSetCookies == '\0') || (LYAcceptAllCookies == '\0')) {
      local_164 = "";
    }
    else {
      local_164 = "selected";
    }
    fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",cookies_accept_all_string,local_164,
            local_1bc);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = cookie_prompt_string;
    local_1c8 = (char *)gettext("Invalid-Cookie Prompting");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_160 = "disabled";
    }
    else {
      local_160 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",cookie_prompt_string,local_160,local_1bc);
    PutOptValues(fp0_00,cookie_noprompt,prompt_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    uVar2 = gettext("Keyboard Input");
    if (no_margins == '\0') {
      local_158 = "&nbsp;&nbsp;";
    }
    else {
      local_158 = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_158,uVar2);
    local_1c0 = keypad_mode_string;
    local_1c8 = (char *)gettext("Keypad mode");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_154 = "disabled";
    }
    else {
      local_154 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",keypad_mode_string,local_154);
    PutOptValues(fp0_00,keypad_mode,keypad_mode_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = emacs_keys_string;
    local_1c8 = (char *)gettext("Emacs keys");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_150 = "disabled";
    }
    else {
      local_150 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",emacs_keys_string,local_150);
    PutOptValues(fp0_00,(int)emacs_keys,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = vi_keys_string;
    local_1c8 = (char *)gettext("VI keys");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_14c = "disabled";
    }
    else {
      local_14c = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",vi_keys_string,local_14c);
    PutOptValues(fp0_00,(int)vi_keys,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = lineedit_mode_string;
    if (LYLineeditNames[1] != (char *)0x0) {
      local_1c8 = (char *)gettext("Line edit style");
      PutLabel(fp0_00,local_1c8,local_1c0);
      if (bVar4) {
        local_148 = "disabled";
      }
      else {
        local_148 = "";
      }
      fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",lineedit_mode_string,local_148);
      i = 0;
      while (LYLineeditNames[i] != (char *)0x0) {
        sprintf(temp,"%d",i,local_148,local_1bc);
        local_1bc = gettext(LYLineeditNames[i]);
        if (i == current_lineedit) {
          local_140 = "selected";
        }
        else {
          local_140 = "";
        }
        fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",temp);
        i = i + 1;
        local_148 = local_140;
      }
      fwrite("</select>\n",1,10,(FILE *)fp0_00);
    }
    uVar2 = gettext("Display and Character Set");
    if (no_margins == '\0') {
      local_138 = "&nbsp;&nbsp;";
    }
    else {
      local_138 = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_138,uVar2);
    local_1c0 = locale_charset_string;
    local_1c8 = (char *)gettext("Use locale-based character set");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_134 = "disabled";
    }
    else {
      local_134 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",locale_charset_string,local_134);
    PutOptValues(fp0_00,(int)LYLocaleCharset,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = display_char_set_string;
    local_1c8 = (char *)gettext("Display character set");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_130 = "disabled";
    }
    else {
      if (LYLocaleCharset == '\0') {
        local_12c = "";
      }
      else {
        local_12c = "disabled";
      }
      local_130 = local_12c;
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",display_char_set_string,local_130);
    i = 0;
    while (LYchar_set_names[i] != (char *)0x0) {
      sVar3 = strlen(LYchar_set_names[i]);
      if (cset_len < sVar3) {
        cset_len = sVar3;
      }
      sprintf(temp,"%d",i,local_130,local_1bc);
      local_1bc = gettext(LYchar_set_names[i]);
      if (i == current_char_set) {
        local_124 = "selected";
      }
      else {
        local_124 = "";
      }
      fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",temp);
      i = i + 1;
      local_130 = local_124;
    }
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    curval = UCLYhndl_for_unspec;
    if (UCLYhndl_for_unspec == current_char_set) {
      curval = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
    }
    local_1c0 = assume_char_set_string;
    local_1c8 = (char *)gettext("Assumed document character set");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_120 = "disabled";
    }
    else {
      local_120 = "";
    }
    local_1c8 = "<select name=\"%s\" %s>\n";
    local_1c0 = assume_char_set_string;
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",assume_char_set_string,local_120);
    i = 0;
    while (i < LYNumCharsets) {
      local_1bc = gettext(LYCharSet_UC[i].MIMEname,local_1c8,local_1c0,local_120,local_1bc);
      if (i == curval) {
        local_118 = "selected";
      }
      else {
        local_118 = "";
      }
      local_1c0 = LYCharSet_UC[i].MIMEname;
      local_1c8 = "<option value=\"%s\" %s>%s\n";
      fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n");
      i = i + 1;
      local_120 = local_118;
    }
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = raw_mode_string;
    if (LYHaveCJKCharacterSet == '\0') {
      local_1c8 = (char *)gettext("Raw 8-bit");
      PutLabel(fp0_00,local_1c8,local_1c0);
    }
    else {
      local_1c8 = (char *)gettext("CJK mode");
      PutLabel(fp0_00,local_1c8,local_1c0);
    }
    if (bVar4) {
      local_114 = "disabled";
    }
    else {
      local_114 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",raw_mode_string,local_114);
    PutOptValues(fp0_00,(int)LYRawMode,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = x_display_string;
    local_1c8 = (char *)gettext("X Display");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_110 = "disabled";
    }
    else {
      local_110 = "";
    }
    if (x_display == (char *)0x0) {
      local_10c = "";
    }
    else {
      local_10c = x_display;
    }
    fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",local_1b0,
            x_display_string,local_10c,local_110);
    local_1bc = gettext("Document Appearance");
    if (no_margins == '\0') {
      local_104 = "&nbsp;&nbsp;";
    }
    else {
      local_104 = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_104,local_1bc,local_10c,local_110);
    SetupChosenShowColor();
    local_1c0 = show_color_string;
    local_1c8 = (char *)gettext("Show color");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (no_option_save == '\0') {
      if (bVar4) {
        local_f8 = "disabled";
      }
      else {
        local_f8 = "";
      }
      fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",show_color_string,local_f8);
      if (can_do_colors == '\0') {
        show_color_values[2].HtmlName = (char *)0x0;
        show_color_values[3].LongName = "Always try";
      }
      else {
        show_color_values[2].HtmlName = "ON";
        show_color_values[3].LongName = "ALWAYS";
      }
      PutOptValues(fp0_00,LYChosenShowColor,show_color_values);
    }
    else {
      if (bVar4) {
        local_100 = "disabled";
      }
      else {
        if (can_do_colors == '\0') {
          local_fc = "disabled";
        }
        else {
          local_fc = "";
        }
        local_100 = local_fc;
      }
      fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",show_color_string,local_100);
      if (LYShowColor == 0) {
        LYShowColor = 1;
      }
      else {
        if (LYShowColor == 3) {
          LYShowColor = 2;
        }
      }
      PutOptValues(fp0_00,LYShowColor + -1,bool_values);
    }
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = show_cursor_string;
    local_1c8 = (char *)gettext("Show cursor");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_f4 = "disabled";
    }
    else {
      local_f4 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",show_cursor_string,local_f4);
    PutOptValues(fp0_00,(int)LYShowCursor,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = underline_links_string;
    local_1c8 = (char *)gettext("Underline links");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_f0 = "disabled";
    }
    else {
      local_f0 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",underline_links_string,local_f0);
    PutOptValues(fp0_00,(int)LYUnderlineLinks,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = show_scrollbar_string;
    local_1c8 = (char *)gettext("Show scrollbar");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_ec = "disabled";
    }
    else {
      local_ec = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",show_scrollbar_string,local_ec);
    PutOptValues(fp0_00,(int)LYShowScrollbar,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = select_popups_string;
    local_1c8 = (char *)gettext("Popups for select fields");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_e8 = "disabled";
    }
    else {
      local_e8 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",select_popups_string,local_e8);
    PutOptValues(fp0_00,(int)LYSelectPopups,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = DTD_recovery_string;
    local_1c8 = (char *)gettext("HTML error recovery");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_e4 = "disabled";
    }
    else {
      local_e4 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",DTD_recovery_string,local_e4);
    PutOptValues(fp0_00,Old_DTD,DTD_type_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = will_save_images();
    local_1c8 = (char *)gettext("Show images");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_e0 = "disabled";
    }
    else {
      local_e0 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",images_string,local_e0);
    local_1bc = gettext(images_ignore_all_string);
    if ((pseudo_inline_alts == '\0') && (clickable_images == '\0')) {
      local_d8 = "selected";
    }
    else {
      local_d8 = "";
    }
    fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",images_ignore_all_string,local_d8,
            local_1bc);
    local_1bc = gettext(images_use_label_string);
    if ((pseudo_inline_alts == '\0') || (clickable_images != '\0')) {
      local_d0 = "";
    }
    else {
      local_d0 = "selected";
    }
    fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",images_use_label_string,local_d0,local_1bc
           );
    local_1bc = gettext(images_use_links_string);
    if (clickable_images == '\0') {
      local_c8 = "";
    }
    else {
      local_c8 = "selected";
    }
    fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",images_use_links_string,local_c8,local_1bc
           );
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = verbose_images_string;
    local_1c8 = (char *)gettext("Verbose images");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_c4 = "disabled";
    }
    else {
      local_c4 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",verbose_images_string,local_c4,local_1bc);
    PutOptValues(fp0_00,(int)verbose_img,verbose_images_type_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1bc = gettext("Headers Transferred to Remote Servers");
    if (no_margins == '\0') {
      local_bc = "&nbsp;&nbsp;";
    }
    else {
      local_bc = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_bc,local_1bc);
    local_1c0 = mail_address_string;
    local_1c8 = (char *)gettext("Personal mail address");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_b8 = "disabled";
    }
    else {
      local_b8 = "";
    }
    if (personal_mail_address == (char *)0x0) {
      local_b4 = "";
    }
    else {
      local_b4 = personal_mail_address;
    }
    fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",local_1b0,
            mail_address_string,local_b4,local_b8);
    local_1c0 = mail_address_string;
    local_1c8 = (char *)gettext("Password for anonymous ftp");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_b0 = "disabled";
    }
    else {
      local_b0 = "";
    }
    if (anonftp_password == (char *)0x0) {
      local_ac = "";
    }
    else {
      local_ac = anonftp_password;
    }
    fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",local_1b0,
            anonftp_password_string,local_ac,local_b0);
    local_1c0 = preferred_media_string;
    local_1c8 = (char *)gettext("Preferred media type");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_a8 = "disabled";
    }
    else {
      local_a8 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",preferred_media_string,local_a8,local_ac,
            local_b0);
    PutOptValues(fp0_00,LYAcceptMedia,media_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = preferred_encoding_string;
    local_1c8 = (char *)gettext("Preferred encoding");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_a4 = "disabled";
    }
    else {
      local_a4 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",preferred_encoding_string,local_a4);
    PutOptValues(fp0_00,LYAcceptEncoding,encoding_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = preferred_doc_char_string;
    local_1c8 = (char *)gettext("Preferred document character set");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_a0 = "disabled";
    }
    else {
      local_a0 = "";
    }
    if (pref_charset == (char *)0x0) {
      local_9c = "";
    }
    else {
      local_9c = pref_charset;
    }
    fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",
            cset_len + 2,preferred_doc_char_string,local_9c,local_a0);
    local_1c0 = preferred_doc_lang_string;
    local_1c8 = (char *)gettext("Preferred document language");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_98 = "disabled";
    }
    else {
      local_98 = "";
    }
    if (language == (char *)0x0) {
      local_94 = "";
    }
    else {
      local_94 = language;
    }
    fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",
            cset_len + 2,preferred_doc_lang_string,local_94,local_98);
    local_1c0 = user_agent_string;
    if (no_useragent == '\0') {
      local_1c8 = (char *)gettext("User-Agent header");
      PutLabel(fp0_00,local_1c8,local_1c0);
      if (bVar4) {
        local_90 = "disabled";
      }
      else {
        local_90 = "";
      }
      if (LYUserAgent == (char *)0x0) {
        local_8c = "";
      }
      else {
        local_8c = LYUserAgent;
      }
      fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",local_1b0
              ,user_agent_string,local_8c,local_90);
      local_94 = local_8c;
      local_98 = local_90;
    }
    local_1bc = gettext("Listing and Accessing Files");
    if (no_margins == '\0') {
      local_84 = "&nbsp;&nbsp;";
    }
    else {
      local_84 = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_84,local_1bc,local_94,local_98);
    local_1c0 = passive_ftp_string;
    local_1c8 = (char *)gettext("Use Passive FTP");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_80 = "disabled";
    }
    else {
      local_80 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",passive_ftp_string,local_80);
    PutOptValues(fp0_00,(int)ftp_passive,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = ftp_sort_string;
    local_1c8 = (char *)gettext("FTP sort criteria");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_7c = "disabled";
    }
    else {
      local_7c = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",ftp_sort_string,local_7c);
    PutOptValues(fp0_00,HTfileSortMethod,ftp_sort_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = dired_list_string;
    local_1c8 = (char *)gettext("Local directory sort criteria");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_78 = "disabled";
    }
    else {
      local_78 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",dired_list_string,local_78);
    PutOptValues(fp0_00,dir_list_style,dired_list_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = dired_sort_string;
    local_1c8 = (char *)gettext("Local directory sort order");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_74 = "disabled";
    }
    else {
      local_74 = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",dired_sort_string,local_74);
    PutOptValues(fp0_00,dir_list_order,dired_sort_values);
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1c0 = show_dotfiles_string;
    if (no_dotfiles == '\0') {
      local_1c8 = (char *)gettext("Show dot files");
      PutLabel(fp0_00,local_1c8,local_1c0);
      if (bVar4) {
        local_70 = "disabled";
      }
      else {
        local_70 = "";
      }
      fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",show_dotfiles_string,local_70);
      PutOptValues(fp0_00,(int)show_dotfiles,bool_values);
      fwrite("</select>\n",1,10,(FILE *)fp0_00);
    }
    local_1c0 = show_rate_string;
    local_1c8 = (char *)gettext("Show transfer rate");
    PutLabel(fp0_00,local_1c8,local_1c0);
    if (bVar4) {
      local_6c = "disabled";
    }
    else {
      local_6c = "";
    }
    fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",show_rate_string,local_6c);
    i = 0;
    while (rate_values[i].LongName != (char *)0x0) {
      message = (char *)0x0;
      local_1c0 = HTProgressUnits(rate_values[i].value);
      HTSprintf0(&message,rate_values[i].LongName,local_1c0,local_6c,local_94);
      local_94 = (char *)gettext(message);
      if (rate_values[i].value == LYTransferRate) {
        local_64 = "selected";
      }
      else {
        local_64 = "";
      }
      fprintf((FILE *)fp0_00,"<option value=\"%s\" %s>%s\n",rate_values[i].HtmlName);
      if (message != (char *)0x0) {
        free(message);
        message = (char *)0x0;
      }
      i = i + 1;
      local_6c = local_64;
    }
    fwrite("</select>\n",1,10,(FILE *)fp0_00);
    local_1bc = gettext("Special Files and Screens");
    if (no_margins == '\0') {
      local_5c = "&nbsp;&nbsp;";
    }
    else {
      local_5c = "";
    }
    fprintf((FILE *)fp0_00,"\n%s<em>%s</em>\n",local_5c,local_1bc);
    local_1c0 = mbm_string;
    if (LYMBMBlocked == '\0') {
      local_1c8 = (char *)gettext("Multi-bookmarks");
      PutLabel(fp0_00,local_1c8,local_1c0);
      if (bVar4) {
        local_58 = "disabled";
      }
      else {
        local_58 = "";
      }
      fprintf((FILE *)fp0_00,"<select name=\"%s\" %s>\n",mbm_string,local_58);
      PutOptValues(fp0_00,LYMultiBookmarks,mbm_values);
      fwrite("</select>\n",1,10,(FILE *)fp0_00);
    }
    local_1c8 = single_bookmark_string;
    local_1c0 = mbm_string;
    if (LYMultiBookmarks == 0) {
      local_1c0 = (char *)gettext("Bookmarks file");
      PutLabel(fp0_00,local_1c0,local_1c8);
      if (bVar4) {
        local_54 = "disabled";
      }
      else {
        local_54 = "";
      }
      if (bookmark_page == (char *)0x0) {
        local_50 = "";
      }
      else {
        local_50 = bookmark_page;
      }
      fprintf((FILE *)fp0_00,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",local_1b0
              ,single_bookmark_string,local_50,local_54);
    }
    else {
      local_1c8 = (char *)gettext("Review/edit Bookmarks files");
      PutLabel(fp0_00,local_1c8,local_1c0);
      local_1bc = gettext("Goto multi-bookmark menu");
      fprintf((FILE *)fp0_00,"<a href=\"%s\">%s</a>\n","LYNXOPTIONS://MBM_MENU",local_1bc);
    }
    local_1c0 = visited_links_string;
    local_1c8 = (char *)gettext("Visited Pages");
    PutLabel(fp0_00,local_1c8,local_1c0);
    LYMenuVisitedLinks(fp0_00,(int)bVar4);
    if (no_lynxcfg_info == '\0') {
      local_1bc = gettext("View the file ");
      fprintf((FILE *)fp0_00,"\n  %s<a href=\"%s\">lynx.cfg</a>.\n",local_1bc,"LYNXCFG:");
    }
    fwrite("\n</pre>\n",1,8,(FILE *)fp0_00);
    if (!bVar4) {
      fwrite("<p align=center>\n",1,0x11,(FILE *)fp0_00);
      local_1bc = gettext("Accept Changes");
      fprintf((FILE *)fp0_00,"<input type=\"submit\" value=\"%s\"> - \n",local_1bc);
      local_1bc = gettext("Reset Changes");
      fprintf((FILE *)fp0_00,"<input type=\"reset\" value=\"%s\"> - \n",local_1bc);
      local_1bc = gettext("Left Arrow cancels changes");
      fprintf((FILE *)fp0_00,"%s\n",local_1bc);
    }
    fwrite("</form>\n",1,8,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    local_1a4 = 1;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_1a4;
}



BOOLEAN is_true(char *string)

{
  int iVar1;
  
  iVar1 = strcasecomp(string,"TRUE");
  if ((iVar1 != 0) && (iVar1 = strcasecomp(string,"ON"), iVar1 != 0)) {
    return '\0';
  }
  return '\x01';
}



char * find_colon(char *buffer)

{
  char cVar1;
  char *buf;
  char ch;
  
  buf = buffer;
  if (buffer != (char *)0x0) {
    while (cVar1 = *buf, cVar1 != '\0') {
      if (cVar1 == ':') {
        return buf;
      }
      if ((cVar1 == '\\') && (buf = buf + 1, *buf == '\0')) {
        return (char *)0x0;
      }
      buf = buf + 1;
    }
  }
  return (char *)0x0;
}



void free_item_list(lynx_list_item_type **ptr)

{
  _lynx_list_item_type *p_Var1;
  lynx_list_item_type *next;
  lynx_list_item_type *cur;
  
  p_Var1 = (_lynx_list_item_type *)*ptr;
  while (cur = (lynx_list_item_type *)p_Var1, cur != (lynx_list_item_type *)0x0) {
    p_Var1 = cur->next;
    if (cur->name != (char *)0x0) {
      free(cur->name);
      cur->name = (char *)0x0;
    }
    if (cur->command != (char *)0x0) {
      free(cur->command);
      cur->command = (char *)0x0;
    }
    if (cur != (lynx_list_item_type *)0x0) {
      free(cur);
    }
  }
  *ptr = (lynx_list_item_type *)0x0;
  return;
}



void free_all_item_lists(void)

{
  free_item_list(&printers);
  free_item_list(&downloaders);
  free_item_list(&uploaders);
  free_item_list(&externals);
  return;
}



void add_item_to_list(char *buffer,lynx_list_item_type **list_ptr,int special)

{
  BOOLEAN BVar1;
  char *__s;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  lynx_list_item_type *prev_item;
  lynx_list_item_type *cur_item;
  char *last_colon;
  char *next_colon;
  char *colon;
  
  __s = strrchr(buffer,0x3a);
  if ((__s != (char *)0x0) && (__s[-1] != '\\')) {
    *__s = '\0';
    iVar2 = strcasecomp(__s + 1,"XWINDOWS");
    if (iVar2 == 0) {
      __s = LYgetXDisplay();
      if (__s == (char *)0x0) {
        return;
      }
    }
    else {
      iVar2 = strcasecomp(__s + 1,"NON_XWINDOWS");
      if ((iVar2 == 0) && (__s = LYgetXDisplay(), __s != (char *)0x0)) {
        return;
      }
    }
  }
  if (*list_ptr == (lynx_list_item_type *)0x0) {
    cur_item = (lynx_list_item_type *)calloc(1,0x18);
    if (cur_item == (lynx_list_item_type *)0x0) {
      outofmem("./LYReadCFG.c","read_cfg");
    }
    *list_ptr = cur_item;
  }
  else {
    prev_item = *list_ptr;
    while (prev_item->next != (_lynx_list_item_type *)0x0) {
      prev_item = (lynx_list_item_type *)prev_item->next;
    }
    cur_item = (lynx_list_item_type *)calloc(1,0x18);
    if (cur_item == (lynx_list_item_type *)0x0) {
      outofmem("./LYReadCFG.c","read_cfg");
    }
    else {
      *(lynx_list_item_type **)&prev_item->next = cur_item;
    }
  }
  cur_item->next = (_lynx_list_item_type *)0x0;
  cur_item->name = (char *)0x0;
  cur_item->command = (char *)0x0;
  cur_item->always_enabled = 0;
  cur_item->override_primary_action = '\0';
  cur_item->pagelen = 0x42;
  __s = find_colon(buffer);
  if (__s != (char *)0x0) {
    pcVar3 = (char *)calloc((size_t)(__s + (1 - (int)buffer)),1);
    cur_item->name = pcVar3;
    if (cur_item->name == (char *)0x0) {
      outofmem("./LYReadCFG.c","read_cfg");
    }
    LYstrncpy(cur_item->name,buffer,(int)(__s + -(int)buffer));
    remove_backslashes(cur_item->name);
    next_colon = find_colon(__s + 1);
    if (next_colon == (char *)0x0) {
      sVar4 = strlen(__s);
      next_colon = __s + sVar4;
    }
    if (next_colon != __s + 1 && -1 < (int)(next_colon + -(int)(__s + 1))) {
      pcVar3 = (char *)calloc((size_t)(next_colon + -(int)__s),1);
      cur_item->command = pcVar3;
      if (cur_item->command == (char *)0x0) {
        outofmem("./LYReadCFG.c","read_cfg");
      }
      LYstrncpy(cur_item->command,__s + 1,(int)(next_colon + -(int)(__s + 1)));
      remove_backslashes(cur_item->command);
    }
    __s = next_colon + 1;
    if (*next_colon != '\0') {
      next_colon = strchr(__s,0x3a);
      if (next_colon != (char *)0x0) {
        *next_colon = '\0';
        next_colon = next_colon + 1;
      }
      BVar1 = is_true(__s);
      cur_item->always_enabled = (int)BVar1;
      if (next_colon != (char *)0x0) {
        if (special == 0) {
          BVar1 = is_true(next_colon);
          cur_item->override_primary_action = BVar1;
        }
        else {
          iVar2 = atoi(next_colon);
          cur_item->pagelen = iVar2;
        }
      }
    }
  }
  return;
}



lynx_list_item_type * find_item_by_number(lynx_list_item_type *list_ptr,char *number)

{
  int value;
  
  value = atoi(number);
  while ((-1 < value && (list_ptr != (lynx_list_item_type *)0x0))) {
    list_ptr = (lynx_list_item_type *)list_ptr->next;
    value = value + -1;
  }
  return list_ptr;
}



int match_item_by_name(lynx_list_item_type *ptr,char *name,BOOLEAN only_overriders)

{
  size_t n;
  int iVar1;
  
  if (ptr->command != (char *)0x0) {
    n = strlen(ptr->name);
    iVar1 = strncasecomp(ptr->name,name,n);
    if ((iVar1 == 0) && ((only_overriders == '\0' || (ptr->override_primary_action != '\0')))) {
      return 1;
    }
  }
  return 0;
}



int check_color(char *color,int the_default)

{
  FILE *__stream;
  int iVar1;
  int local_18;
  int c;
  int i;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"check_color(%s,%d)\n",color,the_default);
  }
  iVar1 = strcasecomp(color,"default");
  if (iVar1 == 0) {
    if ((LYuse_default_colors != '\0') && (default_color_reset == '\0')) {
      the_default = -1;
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"=> default %d\n",the_default);
    }
    local_18 = the_default;
  }
  else {
    iVar1 = strcasecomp(color,"nocolor");
    if (iVar1 == 0) {
      local_18 = -2;
    }
    else {
      i = 0;
      while (i < 0x10) {
        iVar1 = strcasecomp(color,Color_Strings[i]);
        if (iVar1 == 0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"=> %d\n",i);
          }
          return i;
        }
        i = i + 1;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"=> ERR_COLOR\n");
      }
      local_18 = -3;
    }
  }
  return local_18;
}



char * lookup_color(int code)

{
  uint n;
  
  n = 0;
  while( true ) {
    if (0xf < n) {
      return "default";
    }
    if (n == code) break;
    n = n + 1;
  }
  return Color_Strings[n];
}



void exit_with_color_syntax(char *error_line)

{
  char *__format;
  undefined4 uVar1;
  uint i;
  
  __format = (char *)gettext(
                            "Syntax Error parsing COLOR in configuration file:\nThe line must be of the form:\nCOLOR:INTEGER:FOREGROUND:BACKGROUND\n\nHere FOREGROUND and BACKGROUND must be one of:\nThe special strings \'nocolor\' or \'default\', or\n"
                            );
  fprintf(stderr,__format);
  i = 0;
  while (i < 0x10) {
    fprintf(stderr,"%16s %16s %16s %16s\n",Color_Strings[i],Color_Strings[i + 1],
            Color_Strings[i + 2],Color_Strings[i + 3]);
    i = i + 4;
  }
  uVar1 = gettext("Offending line:");
  fprintf(stderr,"%s\nCOLOR:%s\n",uVar1,error_line);
  exit_immediately(1);
  return;
}



void parse_color(char *buffer)

{
  int color_00;
  char *pcVar1;
  char *pcVar2;
  int bg_00;
  int fg_00;
  char *temp;
  char *bg;
  char *fg;
  int color;
  
  temp = (char *)0x0;
  HTSACopy(&temp,buffer);
  color_00 = atoi(buffer);
  pcVar1 = find_colon(buffer);
  if (pcVar1 == (char *)0x0) {
    exit_with_color_syntax(temp);
  }
  *pcVar1 = '\0';
  pcVar2 = find_colon(pcVar1 + 1);
  if (pcVar2 == (char *)0x0) {
    exit_with_color_syntax(temp);
  }
  *pcVar2 = '\0';
  bg_00 = check_color(pcVar2 + 1,default_bg);
  fg_00 = check_color(pcVar1 + 1,default_fg);
  color_00 = lynx_chg_color(color_00,fg_00,bg_00);
  if (color_00 < 0) {
    exit_with_color_syntax(temp);
  }
  if (temp != (char *)0x0) {
    free(temp);
  }
  return;
}



int assume_charset_fun(char *value)

{
  UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(value);
  HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return 0;
}



int assume_local_charset_fun(char *value)

{
  UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(value);
  return 0;
}



int assume_unrec_charset_fun(char *value)

{
  UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(value);
  return 0;
}



int character_set_fun(char *value)

{
  int iVar1;
  int i;
  
  iVar1 = UCGetLYhndl_byAnyName(value);
  if (-1 < iVar1) {
    current_char_set = iVar1;
  }
  return 0;
}



int outgoing_mail_charset_fun(char *value)

{
  outgoing_mail_charset = UCGetLYhndl_byMIME(value);
  return 0;
}



int assumed_color_fun(char *buffer)

{
  char *pcVar1;
  FILE *__stream;
  char *temp;
  char *bg;
  char *fg;
  
  temp = (char *)0x0;
  if (LYuse_default_colors == '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...ignored since DEFAULT_COLORS:off\n");
    }
  }
  else {
    HTSACopy(&temp,buffer);
    pcVar1 = find_colon(buffer);
    if (pcVar1 == (char *)0x0) {
      exit_with_color_syntax(temp);
    }
    *pcVar1 = '\0';
    default_fg = check_color(buffer,default_fg);
    default_bg = check_color(pcVar1 + 1,default_bg);
    if ((default_fg == -3) || (default_bg == -3)) {
      exit_with_color_syntax(temp);
    }
    if (temp != (char *)0x0) {
      free(temp);
    }
  }
  return 0;
}



int color_fun(char *value)

{
  parse_color(value);
  return 0;
}



int default_colors_fun(char *value)

{
  LYuse_default_colors = is_true(value);
  if (LYuse_default_colors == '\0') {
    default_color_reset = '\x01';
    if ((default_fg == -1) || (default_bg == -1)) {
      default_fg = 7;
      default_bg = 0;
      lynx_setup_colors();
    }
  }
  else {
    default_fg = -1;
    default_bg = -1;
  }
  return 0;
}



int default_bookmark_file_fun(char *value)

{
  set_default_bookmark_page(value);
  return 0;
}



int default_cache_size_fun(char *value)

{
  HTCacheSize = atoi(value);
  if (HTCacheSize < 2) {
    HTCacheSize = 2;
  }
  return 0;
}



int default_editor_fun(char *value)

{
  if (system_editor == '\0') {
    HTSACopy(&editor,value);
  }
  return 0;
}



int numbers_as_arrows_fun(char *value)

{
  BOOLEAN BVar1;
  
  BVar1 = is_true(value);
  keypad_mode = ZEXT14(BVar1 == '\0');
  return 0;
}



int dired_menu_fun(char *value)

{
  add_menu_item(value);
  return 0;
}



int jumpfile_fun(char *value)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  char *buffer;
  
  buffer = (char *)0x0;
  HTSprintf0(&buffer,"JUMPFILE:%s",value);
  BVar2 = LYJumpInit(buffer);
  pcVar1 = buffer;
  if ((BVar2 == '\0') && (WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Failed to register %s\n",pcVar1);
  }
  if (buffer != (char *)0x0) {
    free(buffer);
  }
  return 0;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int keymap_fun(char *key)

{
  char *a;
  char *func_00;
  int xlkc;
  char *__format;
  int iVar1;
  uint uVar2;
  char *local_2c;
  char **endp;
  char *sselect_edi;
  int select_edi;
  int lec;
  int lkc;
  char *efunc;
  char *func;
  BOOLEAN success;
  
  func = strchr(key,0x3a);
  if (func != (char *)0x0) {
    *func = '\0';
    func = func + 1;
    a = strchr(func,0x3a);
    if (a == func) {
      func = (char *)0x0;
    }
    else {
      if ((a != (char *)0x0) && (xlkc = strncasecomp(a + 1,"DIRED",5), xlkc == 0)) {
        func_00 = strtok(func," \t\n:#");
        xlkc = remap(key,func_00,'\x01');
        if (xlkc == 0) {
          func_00 = (char *)gettext("key remapping of %s to %s for %s failed\n");
          fprintf(stderr,func_00,key,func,a + 1);
          return 0;
        }
        if (func == (char *)0x0) {
          return 0;
        }
        xlkc = strcmp("TOGGLE_HELP",func);
        if (xlkc != 0) {
          return 0;
        }
        LYUseNoviceLineTwo = '\0';
        return 0;
      }
      func_00 = strtok(func," \t\n:#");
      xlkc = remap(key,func_00,'\0');
      if (xlkc == 0) {
        func_00 = (char *)gettext("key remapping of %s to %s failed\n");
        fprintf(stderr,func_00,key,func);
      }
      else {
        if ((func != (char *)0x0) && (xlkc = strcmp("TOGGLE_HELP",func), xlkc == 0)) {
          LYUseNoviceLineTwo = '\0';
        }
      }
    }
    if (a != (char *)0x0) {
      a = a + 1;
      local_2c = a;
      if (func != (char *)0x0) {
        local_2c = (char *)0x0;
      }
      func_00 = strtok(local_2c," \t\n:#");
      if ((func_00 == a) && (*a != '\0')) {
        success = '\0';
        xlkc = lkcstring_to_lkc(key);
        lec = -1;
        select_edi = 0;
        sselect_edi = strtok((char *)0x0," \t\n:#");
        if (sselect_edi != (char *)0x0) {
          if (*sselect_edi != '\0') {
            select_edi = strtol(sselect_edi,&sselect_edi,10);
          }
          func_00 = sselect_edi;
          if (*sselect_edi != '\0') {
            __format = (char *)gettext(
                                      "invalid line-editor selection %s for key %s, selecting all\n"
                                      );
            fprintf(stderr,__format,func_00,key);
            select_edi = 0;
          }
        }
        iVar1 = strcasecomp(a,"PASS!");
        if (iVar1 == 0) {
          if (func != (char *)0x0) {
            uVar2 = lacname_to_lac(func);
            lec = uVar2 | 0x1000;
            success = LYRemapEditBinding(xlkc,lec,select_edi);
          }
          if (success != '\0') {
            return 0;
          }
          func_00 = (char *)gettext(
                                   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"
                                   );
          fprintf(stderr,func_00,key,xlkc,lec,a);
        }
        if (success == '\0') {
          lec = lecname_to_lec(a);
          success = LYRemapEditBinding(xlkc,lec,select_edi);
        }
        if (success == '\0') {
          if (lec == -1) {
            func_00 = (char *)gettext(
                                     "setting of line-editor binding for key %s (0x%x) for %s failed\n"
                                     );
            fprintf(stderr,func_00,key,xlkc,a);
          }
          else {
            func_00 = (char *)gettext(
                                     "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"
                                     );
            fprintf(stderr,func_00,key,xlkc,lec,a);
          }
        }
      }
    }
  }
  return 0;
}



int localhost_alias_fun(char *value)

{
  LYAddLocalhostAlias(value);
  return 0;
}



int lynxcgi_environment_fun(char *value)

{
  add_lynxcgi_environment(value);
  return 0;
}



int lynx_sig_file_fun(char *value)

{
  int iVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  FILE *__stream;
  int in_GS_OFFSET;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  LYstrncpy(temp,value,0xff);
  BVar3 = LYPathOffHomeOK(temp,0x100);
  if (BVar3 == '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYNX_SIG_FILE \'%s\' is bad. Ignoring.\n",".lynxsig");
    }
  }
  else {
    HTSACopy(&LynxSigFile,temp);
    LYAddPathToHome(temp,0x100,LynxSigFile);
    HTSACopy(&LynxSigFile,temp);
    pcVar2 = LynxSigFile;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYNX_SIG_FILE set to \'%s\'\n",pcVar2);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



int news_chunk_size_fun(char *value)

{
  HTNewsChunkSize = atoi(value);
  if (HTNewsMaxChunk < HTNewsChunkSize) {
    HTNewsMaxChunk = HTNewsChunkSize;
  }
  return 0;
}



int news_max_chunk_fun(char *value)

{
  HTNewsMaxChunk = atoi(value);
  if (HTNewsMaxChunk < HTNewsChunkSize) {
    HTNewsChunkSize = HTNewsMaxChunk;
  }
  return 0;
}



int news_posting_fun(char *value)

{
  LYNewsPosting = is_true(value);
  no_newspost = LYNewsPosting == '\0';
  return 0;
}



int cern_rulesfile_fun(char *value)

{
  int iVar1;
  char *__format;
  char *local_18;
  char *rulesfile2;
  char *rulesfile1;
  
  rulesfile1 = (char *)0x0;
  rulesfile2 = (char *)0x0;
  iVar1 = HTLoadRules(value);
  if (iVar1 < 0) {
    HTSACopy(&rulesfile1,value);
    LYTrimLeading(value);
    LYTrimTrailing(value);
    HTSACopy(&rulesfile2,value);
    LYTildeExpand(&rulesfile2,'\0');
    iVar1 = strcmp(rulesfile1,rulesfile2);
    if ((iVar1 == 0) || (iVar1 = HTLoadRules(rulesfile2), iVar1 < 0)) {
      if ((rulesfile2 == (char *)0x0) || (*rulesfile2 == '\0')) {
        local_18 = (char *)gettext("(no name)");
      }
      else {
        local_18 = rulesfile2;
      }
      __format = (char *)gettext("Lynx: cannot start, CERN rules file %s is not available\n");
      fprintf(stderr,__format,local_18);
      exit_immediately(1);
    }
    else {
      if (rulesfile1 != (char *)0x0) {
        free(rulesfile1);
        rulesfile1 = (char *)0x0;
      }
      if (rulesfile2 != (char *)0x0) {
        free(rulesfile2);
      }
    }
  }
  return 0;
}



int referer_with_query_fun(char *value)

{
  int iVar1;
  
  iVar1 = strncasecomp(value,"SEND",4);
  if (iVar1 == 0) {
    LYRefererWithQuery = 'S';
  }
  else {
    iVar1 = strncasecomp(value,"PARTIAL",7);
    if (iVar1 == 0) {
      LYRefererWithQuery = 'P';
    }
    else {
      LYRefererWithQuery = 'D';
    }
  }
  return 0;
}



int suffix_fun(char *value)

{
  size_t sVar1;
  FILE *__stream;
  char *pcVar2;
  char *local_38;
  double df;
  double q;
  char *description;
  char *sq;
  char *encoding;
  char *p;
  char *mime_type;
  
  encoding = (char *)0x0;
  sq = (char *)0x0;
  description = (char *)0x0;
  sVar1 = strlen(value);
  if ((sVar1 < 3) || (mime_type = strchr(value,0x3a), mime_type == (char *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Invalid SUFFIX:%s ignored.\n",value);
    }
  }
  else {
    *mime_type = '\0';
    mime_type = mime_type + 1;
    if ((*mime_type != '\0') && (encoding = strchr(mime_type,0x3a), encoding != (char *)0x0)) {
      *encoding = '\0';
      encoding = encoding + 1;
      sq = strchr(encoding,0x3a);
      if (sq != (char *)0x0) {
        *sq = '\0';
        sq = sq + 1;
        description = strchr(sq,0x3a);
        if (description != (char *)0x0) {
          *description = '\0';
          description = description + 1;
          p = strchr(sq,0x3a);
          if (p != (char *)0x0) {
            *p = '\0';
          }
          LYTrimTail(description);
        }
        LYRemoveBlanks(sq);
        if (*sq == '\0') {
          sq = (char *)0x0;
        }
      }
      LYRemoveBlanks(encoding);
      LYLowerCase(encoding);
      if (*encoding == '\0') {
        encoding = (char *)0x0;
      }
    }
    LYRemoveBlanks(mime_type);
    if (*mime_type == '\0') {
      if (WWW_TraceFlag != '\0') {
        if (encoding == (char *)0x0) {
          local_38 = "what?";
        }
        else {
          local_38 = encoding;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SUFFIX:%s without MIME type for %s\n",value,local_38);
      }
      mime_type = (char *)0x0;
      if (encoding == (char *)0x0) {
        return 0;
      }
    }
    if (encoding == (char *)0x0) {
      pcVar2 = strstr(mime_type,"tex");
      if ((((pcVar2 == (char *)0x0) &&
           (pcVar2 = strstr(mime_type,"postscript"), pcVar2 == (char *)0x0)) &&
          (pcVar2 = strstr(mime_type,"sh"), pcVar2 == (char *)0x0)) &&
         ((pcVar2 = strstr(mime_type,"troff"), pcVar2 == (char *)0x0 &&
          (pcVar2 = strstr(mime_type,"rtf"), pcVar2 == (char *)0x0)))) {
        encoding = "binary";
      }
      else {
        encoding = "8bit";
      }
    }
    if (sq == (char *)0x0) {
      q = 1.00000000;
    }
    else {
      q = strtod(sq,&p);
      if ((p == sq) && (q <= 0.00000000)) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Invalid q=%s for SUFFIX:%s, using -1.0\n",sq,value);
        }
        q = -1.00000000;
      }
    }
    HTSetSuffix5(value,mime_type,encoding,description,q);
  }
  return 0;
}



int suffix_order_fun(char *value)

{
  bool bVar1;
  int iVar2;
  FILE *__stream;
  char *a;
  char *optn;
  char *p;
  BOOLEAN want_file_init_now;
  
  p = value;
  bVar1 = false;
  LYUseBuiltinSuffixes = '\x01';
LAB_080a7adf:
  do {
    a = HTNextTok(&p,", ","",(char *)0x0);
    if (a == (char *)0x0) {
LAB_080a7b0f:
      if ((bVar1) && (FileInitAlreadyDone == '\0')) {
        HTFileInit();
        FileInitAlreadyDone = '\x01';
      }
      return 0;
    }
    iVar2 = strcasecomp(a,"NO_BUILTIN");
    if (iVar2 != 0) {
      iVar2 = strcasecomp(a,"PRECEDENCE_HERE");
      if (iVar2 == 0) {
        bVar1 = true;
      }
      else {
        iVar2 = strcasecomp(a,"PRECEDENCE_OTHER");
        if (iVar2 != 0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Invalid SUFFIX_ORDER:%s\n",a);
          }
          goto LAB_080a7b0f;
        }
        bVar1 = false;
      }
      goto LAB_080a7adf;
    }
    LYUseBuiltinSuffixes = '\0';
  } while( true );
}



int system_editor_fun(char *value)

{
  HTSACopy(&editor,value);
  system_editor = '\x01';
  return 0;
}



int viewer_fun(char *value)

{
  size_t sVar1;
  char *__s;
  char *pcVar2;
  int iVar3;
  char *environment;
  char *viewer;
  char *mime_type;
  
  sVar1 = strlen(value);
  if ((2 < sVar1) && (__s = strchr(value,0x3a), __s != (char *)0x0)) {
    *__s = '\0';
    __s = __s + 1;
    LYRemoveBlanks(value);
    LYLowerCase(value);
    pcVar2 = strrchr(__s,0x3a);
    if ((pcVar2 == (char *)0x0) || ((sVar1 = strlen(__s), sVar1 < 2 || (pcVar2[-1] == '\\')))) {
      remove_backslashes(__s);
      HTSetPresentation(value,__s,(char *)0x0,1.00000000,3.00000000,0.00000000,0,mediaCFG);
    }
    else {
      *pcVar2 = '\0';
      remove_backslashes(__s);
      iVar3 = strcasecomp(pcVar2 + 1,"XWINDOWS");
      if (iVar3 == 0) {
        pcVar2 = LYgetXDisplay();
        if (pcVar2 != (char *)0x0) {
          HTSetPresentation(value,__s,(char *)0x0,1.00000000,3.00000000,0.00000000,0,mediaCFG);
        }
      }
      else {
        iVar3 = strcasecomp(pcVar2 + 1,"NON_XWINDOWS");
        if (iVar3 == 0) {
          pcVar2 = LYgetXDisplay();
          if (pcVar2 == (char *)0x0) {
            HTSetPresentation(value,__s,(char *)0x0,1.00000000,3.00000000,0.00000000,0,mediaCFG);
          }
        }
        else {
          HTSetPresentation(value,__s,(char *)0x0,1.00000000,3.00000000,0.00000000,0,mediaCFG);
        }
      }
    }
  }
  return 0;
}



int nonrest_sigwinch_fun(char *value)

{
  int iVar1;
  char *pcVar2;
  
  iVar1 = strncasecomp(value,"XWINDOWS",8);
  if (iVar1 == 0) {
    pcVar2 = LYgetXDisplay();
    LYNonRestartingSIGWINCH = pcVar2 != (char *)0x0;
  }
  else {
    LYNonRestartingSIGWINCH = is_true(value);
  }
  return 0;
}



void html_src_bad_syntax(char *value,char *option_name)

{
  char *buf;
  
  buf = (char *)0x0;
  HTSprintf0(&buf,"HTMLSRC_%s",option_name);
  LYUpperCase(buf);
  fprintf(stderr,"Bad syntax in TAGSPEC %s:%s\n",buf,value);
  exit_immediately(1);
  return;
}



int parse_html_src_spec(HTlexeme lexeme_code,char *value,char *option_name)

{
  char *ts;
  FILE *__stream;
  int iVar1;
  char *ts2;
  
  if ((value != (char *)0x0) && (*value != '\0')) {
    ts = strchr(value,0x3a);
    if (ts == (char *)0x0) {
      html_src_bad_syntax(value,option_name);
    }
    *ts = '\0';
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYReadCFG - parsing tagspec \'%s:%s\' for option \'%s\'\n",value,ts,
              option_name);
    }
    html_src_clean_item(lexeme_code);
    iVar1 = html_src_parse_tagspec(value,lexeme_code,'\x01','\x01');
    if ((iVar1 == 0) || (iVar1 = html_src_parse_tagspec(ts,lexeme_code,'\x01','\x01'), iVar1 == 0))
    {
      *ts = ':';
      html_src_bad_syntax(value,option_name);
    }
    *ts = ':';
    HTSACopy(HTL_tagspecs + lexeme_code,value);
  }
  return 0;
}



int psrcspec_fun(char *s)

{
  Config_Enum lexemnames [13];
  BOOLEAN BVar1;
  char *pcVar2;
  FILE *__stream;
  int found;
  char *e;
  
  pcVar2 = strchr(s,0x3a);
  if (pcVar2 == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",s);
    }
  }
  else {
    *pcVar2 = '\0';
    BVar1 = LYgetEnum((Config_Enum *)&ram0x081960c0,s,&found);
    if (BVar1 == '\0') {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",s,
                pcVar2 + 1);
      }
    }
    else {
      parse_html_src_spec(found,pcVar2 + 1,s);
    }
  }
  return 0;
}



int read_htmlsrc_attrname_xform(char *str)

{
  int iVar1;
  FILE *__stream;
  int val;
  
  iVar1 = sscanf(str,"%d",&val);
  if (iVar1 == 1) {
    if ((val < 0) || (2 < val)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n",val);
      }
    }
    else {
      attrname_transform = val;
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"bad value for htmlsrc_attrname_xform (ignored): %s\n",str);
    }
  }
  return 0;
}



int read_htmlsrc_tagname_xform(char *str)

{
  int iVar1;
  FILE *__stream;
  int val;
  
  iVar1 = sscanf(str,"%d",&val);
  if (iVar1 == 1) {
    if ((val < 0) || (2 < val)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n",val);
      }
    }
    else {
      tagname_transform = val;
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"bad value for htmlsrc_tagname_xform (ignored): %s\n",str);
    }
  }
  return 0;
}



void free_lynx_cfg(void)

{
  char *__s;
  int **ppiVar1;
  char *pcVar2;
  char *eqls;
  char *name;
  ParseUnion *q;
  Config_Type *tbl;
  
  tbl = Config_Table;
  while (((Config_Type *)tbl)->name != (char *)0x0) {
    ppiVar1 = (int **)&((Config_Type *)tbl)->value;
    if ((((Config_Type *)tbl)->type == 8) && (*ppiVar1 != (int *)0x0)) {
      __s = (char *)**ppiVar1;
      pcVar2 = strchr(__s,0x3d);
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '\0';
        unsetenv(__s);
      }
      if (**ppiVar1 != 0) {
        free((void *)**ppiVar1);
        **ppiVar1 = 0;
      }
      if (*ppiVar1 != (int *)0x0) {
        free(*ppiVar1);
        *ppiVar1 = (int *)0x0;
      }
    }
    tbl = (Config_Type_conflict *)((Config_Type *)tbl + 1);
  }
  free_all_item_lists();
  reset_dired_menu();
  if (lynxcfginfo_url != (char *)0x0) {
    free(lynxcfginfo_url);
    lynxcfginfo_url = (char *)0x0;
  }
  if (configinfo_url != (char *)0x0) {
    free(configinfo_url);
    configinfo_url = (char *)0x0;
  }
  return;
}



Config_Type * lookup_config(char *name)

{
  byte bVar1;
  ushort **ppuVar2;
  int iVar3;
  char local_1d;
  uint local_18;
  Config_Type *tbl;
  char ch1;
  char ch;
  
  tbl = Config_Table;
  ppuVar2 = __ctype_b_loc();
  if (((*ppuVar2)[(byte)*name] & 0x200) == 0) {
    local_1d = *name;
  }
  else {
    iVar3 = toupper((uint)(byte)*name);
    local_1d = (char)iVar3;
  }
  while( true ) {
    if (((Config_Type *)tbl)->name == (char *)0x0) {
      return (Config_Type *)tbl;
    }
    bVar1 = *((Config_Type *)tbl)->name;
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[bVar1] & 0x200) == 0) {
      local_18 = (uint)bVar1;
    }
    else {
      local_18 = toupper((uint)bVar1);
    }
    if (((int)local_1d == local_18) &&
       (iVar3 = strcasecomp(name,((Config_Type *)tbl)->name), iVar3 == 0)) break;
    tbl = (Config_Type_conflict *)((Config_Type *)tbl + 1);
  }
  return (Config_Type *)tbl;
}



char * actual_filename(char *cfg_filename,char *parent_filename,char *dft_filename)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *my_filename;
  
  my_filename = (char *)0x0;
  BVar1 = LYisAbsPath(cfg_filename);
  if ((BVar1 == '\0') &&
     ((parent_filename != (char *)0x0 || (BVar1 = LYCanReadFile(cfg_filename), BVar1 == '\0')))) {
    if ((*cfg_filename == '~') && (cfg_filename[1] == '/')) {
      pcVar2 = Home_Dir();
      HTSprintf0(&my_filename,"%s%s",pcVar2,cfg_filename + 1);
    }
    else {
      if (parent_filename != (char *)0x0) {
        HTSACopy(&my_filename,parent_filename);
        pcVar2 = LYPathLeaf(my_filename);
        *pcVar2 = '\0';
        HTSACat(&my_filename,cfg_filename);
      }
      if ((my_filename != (char *)0x0) && (BVar1 = LYCanReadFile(my_filename), BVar1 != '\0')) {
        return my_filename;
      }
      HTSACopy(&my_filename,dft_filename);
      pcVar2 = LYPathLeaf(my_filename);
      *pcVar2 = '\0';
      HTSACat(&my_filename,cfg_filename);
      BVar1 = LYCanReadFile(my_filename);
      if (BVar1 == '\0') {
        HTSACopy(&my_filename,cfg_filename);
      }
    }
  }
  else {
    HTSACopy(&my_filename,cfg_filename);
  }
  return my_filename;
}



FILE * LYOpenCFG(char *cfg_filename,char *parent_filename,char *dft_filename)

{
  char *__filename;
  FILE *__stream;
  FILE *result;
  char *my_file;
  
  __filename = actual_filename(cfg_filename,parent_filename,dft_filename);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"opening config file %s\n",__filename);
  }
  __stream = (FILE *)fopen64(__filename,"r");
  if (__filename != (char *)0x0) {
    free(__filename);
  }
  return __stream;
}



void LYSetConfigValue(char *name,char *value)

{
  BOOLEAN BVar1;
  Config_Type *pCVar2;
  lynx_list_item_type **pplVar3;
  int iVar4;
  char *pcVar5;
  lynx_list_item_type *plVar6;
  _lynx_list_item_type *p_Var7;
  float ival;
  char *temp;
  ParseUnion *q;
  Config_Type *tbl;
  
  pCVar2 = lookup_config(name);
  pplVar3 = (lynx_list_item_type **)&pCVar2->value;
  temp = (char *)0x0;
  switch(pCVar2->type) {
  case 1:
    if (*pplVar3 != (lynx_list_item_type *)0x0) {
      plVar6 = *pplVar3;
      BVar1 = is_true(value);
      *(BOOLEAN *)&plVar6->next = BVar1;
    }
    break;
  case 2:
    if (*pplVar3 != (lynx_list_item_type *)0x0) {
      (*(code *)*pplVar3)(value);
    }
    break;
  case 3:
    if ((*pplVar3 != (lynx_list_item_type *)0x0) && (iVar4 = sscanf(value,"%f",&ival), iVar4 == 1))
    {
      (*pplVar3)->next = (_lynx_list_item_type *)(int)ROUND(ival * 1000.00000000);
    }
    break;
  case 4:
    if (pCVar2->help_string != (char *)0x0) {
      LYgetEnum((Config_Enum *)pCVar2->help_string,value,(int *)*pplVar3);
    }
    break;
  case 5:
    if ((*pplVar3 != (lynx_list_item_type *)0x0) && (iVar4 = sscanf(value,"%d",&ival), iVar4 == 1))
    {
      *(float *)&(*pplVar3)->next = ival;
    }
    break;
  case 6:
    if (*pplVar3 != (lynx_list_item_type *)0x0) {
      HTSACopy((char **)*pplVar3,value);
    }
    break;
  case 7:
    pcVar5 = HTSACopy(&temp,value);
    if (pcVar5 != (char *)0x0) {
      HTSetProgramPath((ProgramPaths)*pplVar3,temp);
    }
    break;
  case 8:
  case 9:
    if (pCVar2->type == 8) {
      LYLowerCase(name);
    }
    else {
      LYUpperCase(name);
    }
    pcVar5 = LYGetEnv(name);
    if (pcVar5 == (char *)0x0) {
      if (*pplVar3 == (lynx_list_item_type *)0x0) {
        plVar6 = (lynx_list_item_type *)calloc(1,4);
        *pplVar3 = plVar6;
      }
      HTSprintf0((char **)*pplVar3,"%s=%s",name,value);
      putenv((char *)(*pplVar3)->next);
    }
    break;
  case 0xb:
    if (*pplVar3 != (lynx_list_item_type *)0x0) {
      add_item_to_list(value,(lynx_list_item_type **)*pplVar3,
                       (uint)(*pplVar3 == (lynx_list_item_type *)&printers));
    }
    break;
  case 0xc:
    if ((*pplVar3)->next == (_lynx_list_item_type *)0x0) {
      plVar6 = *pplVar3;
      p_Var7 = (_lynx_list_item_type *)HTList_new();
      plVar6->next = p_Var7;
    }
    if (*pplVar3 != (lynx_list_item_type *)0x0) {
      ival = 0.00000000;
      HTSACopy((char **)&ival,value);
      HTList_appendObject((HTList *)(*pplVar3)->next,(void *)ival);
    }
    break;
  case 0xd:
    add_trusted(value,(int)*pplVar3);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void do_read_cfg(char *cfg_filename,char *parent_filename,int nesting_level,FILE *fp0,
                optidx_set_t *allowed)

{
  char cVar1;
  bool bVar2;
  FILE *fp_00;
  byte *buffer_00;
  ushort **ppuVar3;
  FILE *__stream;
  char *source;
  Config_Type *pCVar4;
  size_t sVar5;
  char *__format;
  uint uVar6;
  int in_GS_OFFSET;
  uint local_224;
  BOOLEAN local_21c;
  lynx_list_item_type *cur_download;
  char *buf;
  uint i_1;
  uint i1;
  uint i;
  Config_Type *tbl2;
  char *my_file;
  char *sep;
  char *cp1;
  char *url;
  char *p2;
  char *p1;
  optidx_set_t *resultant_set;
  ParseUnion *q;
  Config_Type *tbl;
  char *cp;
  char *value;
  char *name;
  char *buffer;
  FILE *fp;
  BOOLEAN any_optname_found;
  char savechar;
  optidx_set_t anded_set;
  optidx_set_t cur_set;
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  buffer = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"Loading cfg file \'%s\'.\n",cfg_filename);
  }
  if (10 < nesting_level) {
    __format = (char *)gettext(
                              "More than %d nested lynx.cfg includes -- perhaps there is a loop?!?\n"
                              );
    fprintf(stderr,__format,nesting_level + -1);
    __format = (char *)gettext("Last attempted include was \'%s\',\n");
    fprintf(stderr,__format,cfg_filename);
    __format = (char *)gettext("included from \'%s\'.\n");
    fprintf(stderr,__format,parent_filename);
    exit_immediately(1);
  }
  if ((cfg_filename == (char *)0x0) || (*cfg_filename == '\0')) {
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"No filename following -cfg switch!\n");
    }
  }
  else {
    fp_00 = LYOpenCFG(cfg_filename,parent_filename,"/etc/lynx-cur/lynx.cfg");
    if (fp_00 == (FILE *)0x0) {
      if (WWW_TraceFlag != '\0') {
        fp_00 = TraceFP();
        fprintf((FILE *)fp_00,"lynx.cfg file not found as \'%s\'\n",cfg_filename);
      }
    }
    else {
      have_read_cfg = '\x01';
      while (__format = LYSafeGets(&buffer,fp_00), __format != (char *)0x0) {
        buffer_00 = (byte *)LYSkipBlanks(buffer);
        ppuVar3 = __ctype_b_loc();
        if ((((*ppuVar3)[*buffer_00] & 4) == 0) &&
           (LYTrimTrailing((char *)buffer_00), *buffer_00 != 0)) {
          __format = strchr((char *)buffer_00,0x3a);
          if (__format == (char *)0x0) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYReadCFG: missing \':\' %s\n",buffer_00);
            }
          }
          else {
            *__format = '\0';
            __format = __format + 1;
            cp = strrchr(__format,0x3a);
            if (cp == (char *)0x0) {
              cp = __format;
            }
            source = strchr(cp,0x23);
            if (source != (char *)0x0) {
              ppuVar3 = __ctype_b_loc();
              if (((*ppuVar3)[(byte)source[-1]] & 0x2000) != 0) {
                source[-1] = 0;
              }
            }
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYReadCFG %s:%s\n",buffer_00,__format);
            }
            pCVar4 = lookup_config((char *)buffer_00);
            if (pCVar4->name == (char *)0x0) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"LYReadCFG: ignored %s:%s\n",buffer_00,__format);
              }
            }
            else {
              if ((allowed == (optidx_set_t *)0x0) ||
                 ((*allowed)[(int)(pCVar4 + -0x819614) >> 4] == '\0')) {
                if ((fp0 == (FILE *)0x0) || (pCVar4->type == 10)) {
                  local_224 = pCVar4->type;
                }
                else {
                  local_224 = 0;
                }
                if (local_224 < 0xe) {
                  uVar6 = 1 << ((byte)local_224 & 0x1f);
                  if ((uVar6 & 0x3bfe) == 0) {
                    if ((uVar6 & 0x400) == 0) goto LAB_080a926e;
                    bVar2 = false;
                    url = (char *)0x0;
                    cp1 = (char *)0x0;
                    sep = " for ";
                    p1 = strstr(__format," for ");
                    if (p1 == (char *)0x0) {
                      sep = ":";
                      p1 = strstr(__format,":");
                      if (p1 != (char *)0x0) goto LAB_080a8d55;
                    }
                    else {
LAB_080a8d55:
                      *p1 = '\0';
                      sVar5 = strlen(sep);
                      p1 = p1 + sVar5;
                    }
                    if ((fp0 != (FILE *)0x0) && (no_lynxcfg_xinfo == '\0')) {
                      source = actual_filename(__format,cfg_filename,"/etc/lynx-cur/lynx.cfg");
                      LYLocalFileToURL(&url,source);
                      if (source != (char *)0x0) {
                        free(source);
                      }
                      HTSACopy(&cp1,__format);
                      source = strchr(__format,0x26);
                      if ((source != (char *)0x0) ||
                         (source = strchr(__format,0x3c), source != (char *)0x0)) {
                        LYEntify(&cp1,'\x01');
                      }
                      fprintf((FILE *)fp0,"%s:<a href=\"%s\">%s</a>\n\n",buffer_00,url,cp1);
                      fprintf((FILE *)fp0,"    #&lt;begin  %s&gt;\n",cp1);
                    }
                    if (p1 != (char *)0x0) {
                      while (source = LYSkipBlanks(p1), *source != '\0') {
                        p1 = LYSkipNonBlanks(source);
                        cVar1 = *p1;
                        *p1 = '\0';
                        pCVar4 = lookup_config(source);
                        if (pCVar4->name == (char *)0x0) {
                          if (fp0 == (FILE *)0x0) {
                            fprintf(stderr,"unknown option name %s in %s\n",source,cfg_filename);
                          }
                        }
                        else {
                          if (!bVar2) {
                            bVar2 = true;
                            i = 0;
                            while (i < 0xcf) {
                              cur_set[i] = '\x01';
                              i = i + 1;
                            }
                          }
                          cur_set[(int)(pCVar4 + -0x819614) >> 4] = '\0';
                        }
                        if ((cVar1 == '\0') || (p1[1] == '\0')) break;
                        p1 = p1 + 1;
                      }
                    }
                    if (allowed == (optidx_set_t *)0x0) {
                      if (bVar2) {
                        resultant_set = (optidx_set_t *)cur_set;
                      }
                      else {
                        resultant_set = (optidx_set_t *)0x0;
                      }
                    }
                    else {
                      if (bVar2) {
                        i1 = 0;
                        while (i1 < 0xcf) {
                          if (((*allowed)[i1] == '\0') && (cur_set[i1] == '\0')) {
                            local_21c = '\0';
                          }
                          else {
                            local_21c = '\x01';
                          }
                          anded_set[i1] = local_21c;
                          i1 = i1 + 1;
                        }
                        resultant_set = (optidx_set_t *)anded_set;
                      }
                      else {
                        resultant_set = allowed;
                      }
                    }
                    if (((fp0 != (FILE *)0x0) && (no_lynxcfg_xinfo == '\0')) &&
                       (resultant_set != (optidx_set_t *)0x0)) {
                      buf = (char *)0x0;
                      fwrite("     Options allowed in this file:\n",1,0x23,(FILE *)fp0);
                      i_1 = 0;
                      while (i_1 < 0xcf) {
                        if ((*resultant_set)[i_1] == '\0') {
                          HTSACopy(&buf,Config_Table[i_1].name);
                          LYUpperCase(buf);
                          fprintf((FILE *)fp0,"         * %s\n",buf);
                        }
                        i_1 = i_1 + 1;
                      }
                      if (buf != (char *)0x0) {
                        free(buf);
                        buf = (char *)0x0;
                      }
                    }
                    do_read_cfg(__format,cfg_filename,nesting_level + 1,fp0,resultant_set);
                    if ((fp0 != (FILE *)0x0) && (no_lynxcfg_xinfo == '\0')) {
                      fprintf((FILE *)fp0,"    #&lt;end of %s&gt;\n\n",cp1);
                      if (url != (char *)0x0) {
                        free(url);
                        url = (char *)0x0;
                      }
                      if (cp1 != (char *)0x0) {
                        free(cp1);
                        cp1 = (char *)0x0;
                      }
                    }
                  }
                  else {
                    LYSetConfigValue((char *)buffer_00,__format);
                  }
                }
                else {
LAB_080a926e:
                  if (fp0 != (FILE *)0x0) {
                    source = strchr(__format,0x26);
                    if ((source == (char *)0x0) &&
                       (source = strchr(__format,0x3c), source == (char *)0x0)) {
                      fprintf((FILE *)fp0,"%s:%s\n",buffer_00,__format);
                    }
                    else {
                      buf = (char *)0x0;
                      HTSACopy(&buf,__format);
                      LYEntify(&buf,'\x01');
                      fprintf((FILE *)fp0,"%s:%s\n",buffer_00,buf);
                      if (buf != (char *)0x0) {
                        free(buf);
                        buf = (char *)0x0;
                      }
                    }
                  }
                }
              }
              else {
                if (fp0 == (FILE *)0x0) {
                  fprintf(stderr,"%s is not allowed in the %s\n",buffer_00,cfg_filename);
                }
              }
            }
          }
        }
      }
      LYCloseInput(fp_00);
      if (downloaders != (lynx_list_item_type *)0x0) {
        cur_download = downloaders;
        while (cur_download != (lynx_list_item_type *)0x0) {
          if (cur_download->always_enabled != 0) {
            override_no_download = '\x01';
            break;
          }
          cur_download = (lynx_list_item_type *)cur_download->next;
        }
      }
      LYConfigCookies();
    }
  }
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void read_cfg(char *cfg_filename,char *parent_filename,int nesting_level,FILE *fp0)

{
  HTInitProgramPaths();
  do_read_cfg(cfg_filename,parent_filename,nesting_level,fp0,(optidx_set_t *)0x0);
  return;
}



void extra_cfg_link(FILE *fp,char *href,char *name)

{
  fprintf((FILE *)fp,"<a href=\"%s\">%s</a>",href,name);
  return;
}



int lynx_cfg_infopage(DocInfo *newdoc)

{
  char tempfile [256];
  BOOLEAN BVar1;
  char *__s2;
  char *__s1;
  int iVar2;
  FILE *fp0_00;
  undefined4 uVar3;
  undefined4 uVar4;
  uint local_30;
  DocAddress WWWDoc;
  FILE *fp0;
  char *cp1;
  char *temp;
  
  temp = (char *)0x0;
  cp1 = (char *)0x0;
  if ((no_lynxcfg_xinfo != '\0') ||
     (__s2 = strstr(newdoc->address,"LYNXCFG://reload"), __s2 == (char *)0x0)) goto LAB_080a960e;
  reload_read_cfg();
  if ((HTMainText != (HText *)0x0) && (0 < nhist)) {
    __s2 = (char *)gettext("Lynx.cfg Information");
    __s1 = HTLoadedDocumentTitle();
    iVar2 = strcmp(__s1,__s2);
    if (iVar2 == 0) {
      __s2 = history[nhist + -1].hdoc.address;
      __s1 = HTLoadedDocumentURL();
      iVar2 = strcmp(__s1,__s2);
      if ((iVar2 == 0) &&
         (BVar1 = LYIsUIPage3(history[nhist + -1].hdoc.address,UIP_LYNXCFG,1),
         __s2 = lynxcfginfo_url, BVar1 != '\0')) {
        if (lynxcfginfo_url != (char *)0x0) {
          __s1 = HTLoadedDocumentURL();
          iVar2 = strcmp(__s1,__s2);
          if (iVar2 == 0) goto LAB_080a95ee;
        }
        LYpop(newdoc);
        WWWDoc.address = newdoc->address;
        WWWDoc.post_data = newdoc->post_data;
        WWWDoc.post_content_type = newdoc->post_content_type;
        WWWDoc.bookmark = newdoc->bookmark;
        WWWDoc.isHEAD = newdoc->isHEAD;
        WWWDoc.safe = newdoc->safe;
        LYforce_no_cache = '\0';
        LYoverride_no_cache = '\x01';
        BVar1 = HTLoadAbsolute(&WWWDoc);
        if (BVar1 == '\0') {
          return 0;
        }
        HTuncache_current_document();
        LYRegisterUIPage((char *)0x0,UIP_LYNXCFG);
      }
    }
  }
LAB_080a95ee:
  if (lynxcfginfo_url != (char *)0x0) {
    free(lynxcfginfo_url);
    lynxcfginfo_url = (char *)0x0;
  }
LAB_080a960e:
  if ((LYforce_no_cache == '\0') || (reloading == '\0')) {
    if ((lynxcfginfo_url != (char *)0x0) &&
       ((BVar1 = LYCanReadFile((char *)&ram0x08196e40), BVar1 == '\0' &&
        (lynxcfginfo_url != (char *)0x0)))) {
      free(lynxcfginfo_url);
      lynxcfginfo_url = (char *)0x0;
    }
  }
  else {
    if (lynxcfginfo_url != (char *)0x0) {
      free(lynxcfginfo_url);
      lynxcfginfo_url = (char *)0x0;
    }
  }
  if (lynxcfginfo_url == (char *)0x0) {
    fp0_00 = InternalPageFP((char *)0x8196e40,1);
    if (fp0_00 == (FILE *)0x0) {
      return 0;
    }
    LYLocalFileToURL(&lynxcfginfo_url,(char *)0x8196e40);
    LYforce_no_cache = '\x01';
    __s2 = (char *)gettext("Lynx.cfg Information");
    BeginInternalPage(fp0_00,__s2,(char *)0x0);
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    if (no_lynxcfg_xinfo == '\0') {
      iVar2 = strcmp(lynx_cfg_file,"/etc/lynx-cur/lynx.cfg");
      if (iVar2 == 0) {
        uVar3 = gettext("Please read the distribution");
        uVar4 = gettext("The following is read from your lynx.cfg file.");
        fprintf((FILE *)fp0_00,"<em>%s\n%s",uVar4,uVar3);
        fwrite(" </em>lynx.cfg<em> ",1,0x13,(FILE *)fp0_00);
        uVar3 = gettext("for more comments.");
        fprintf((FILE *)fp0_00,"%s</em>\n",uVar3);
      }
      else {
        uVar3 = gettext("Please read the distribution");
        uVar4 = gettext("The following is read from your lynx.cfg file.");
        fprintf((FILE *)fp0_00,"<em>%s\n%s",uVar4,uVar3);
        LYLocalFileToURL(&temp,"/etc/lynx-cur/lynx.cfg");
        fprintf((FILE *)fp0_00," <a href=\"%s\">lynx.cfg</a> ",temp);
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
        uVar3 = gettext("for more comments.");
        fprintf((FILE *)fp0_00,"%s</em>\n\n",uVar3);
      }
      if ((no_compileopts_info == '\0') && (no_lynxcfg_xinfo == '\0')) {
        uVar3 = gettext("See also");
        fprintf((FILE *)fp0_00,"%s</pre><ul><li>",uVar3);
        __s2 = (char *)gettext("compile time options");
        extra_cfg_link(fp0_00,"LYNXCOMPILEOPTS:",__s2);
        fwrite(&DAT_0815af9f,1,4,(FILE *)fp0_00);
        LYLocalFileToURL(&temp,lynx_lss_file);
        __s2 = (char *)gettext("color-style configuration");
        extra_cfg_link(fp0_00,temp,__s2);
        fwrite("</ul><pre>\n",1,0xb,(FILE *)fp0_00);
      }
      else {
        uVar3 = gettext("See also");
        fprintf((FILE *)fp0_00,"%s ",uVar3);
        if (no_compileopts_info == '\0') {
          __s2 = (char *)gettext("compile time options");
          extra_cfg_link(fp0_00,"LYNXCOMPILEOPTS:",__s2);
        }
        if (no_lynxcfg_xinfo == '\0') {
          LYLocalFileToURL(&temp,lynx_lss_file);
          __s2 = (char *)gettext("color-style configuration");
          extra_cfg_link(fp0_00,temp,__s2);
        }
        fwrite(&DAT_0815afce,1,2,(FILE *)fp0_00);
      }
      if (user_mode == 2) {
        uVar3 = gettext("RELOAD THE CHANGES");
        fprintf((FILE *)fp0_00,"  <a href=\"%s//reload\">%s</a>\n","LYNXCFG:",uVar3);
      }
      LYLocalFileToURL(&temp,lynx_cfg_file);
      HTSACopy(&cp1,lynx_cfg_file);
      __s2 = strchr(lynx_cfg_file,0x26);
      if ((__s2 != (char *)0x0) || (__s2 = strchr(lynx_cfg_file,0x3c), __s2 != (char *)0x0)) {
        LYEntify(&cp1,'\x01');
      }
      __s1 = temp;
      __s2 = cp1;
      uVar3 = gettext("Your primary configuration");
      fprintf((FILE *)fp0_00,"\n    #<em>%s <a href=\"%s\">%s</a></em>\n",uVar3,__s1,__s2);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      if (cp1 != (char *)0x0) {
        free(cp1);
        cp1 = (char *)0x0;
      }
    }
    else {
      uVar3 = gettext("The following is read from your lynx.cfg file.");
      fprintf((FILE *)fp0_00,"<em>%s</em>\n\n",uVar3);
    }
    read_cfg(lynx_cfg_file,"main program",1,fp0_00);
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYRegisterUIPage(lynxcfginfo_url,UIP_LYNXCFG);
  }
  HTSACopy(&newdoc->address,lynxcfginfo_url);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  BVar1 = HTLoadAbsolute(&WWWDoc);
  if (BVar1 != '\0') {
    lynx_edit_mode = '\0';
  }
  local_30 = (uint)(BVar1 != '\0');
  return local_30;
}



int lynx_compile_opts(DocInfo *newdoc)

{
  anon_struct_1 config_defines [184];
  anon_struct_0 config_cache [282];
  char tempfile [256];
  BOOLEAN BVar1;
  FILE *fp0_00;
  char *Title;
  undefined4 uVar2;
  FILE *local_30;
  uint local_28;
  DocAddress WWWDoc;
  FILE *fp0;
  uint n;
  
  if ((LYforce_no_cache == '\0') || (reloading == '\0')) {
    if ((configinfo_url != (char *)0x0) &&
       ((BVar1 = LYCanReadFile((char *)&ram0x08196f40), BVar1 == '\0' &&
        (configinfo_url != (char *)0x0)))) {
      free(configinfo_url);
      configinfo_url = (char *)0x0;
    }
  }
  else {
    if (configinfo_url != (char *)0x0) {
      free(configinfo_url);
      configinfo_url = (char *)0x0;
    }
  }
  if (configinfo_url == (char *)0x0) {
    fp0_00 = InternalPageFP((char *)0x8196f40,1);
    if (fp0_00 == (FILE *)0x0) {
      return 0;
    }
    LYLocalFileToURL(&configinfo_url,(char *)0x8196f40);
    Title = (char *)gettext("Configuration Definitions");
    BeginInternalPage(fp0_00,Title,(char *)0x0);
    local_30 = fp0_00;
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    uVar2 = gettext(
                   "The following data were derived during the automatic configuration/build\nprocess of this copy of Lynx.  When reporting a bug, please include a copy\nof this page."
                   );
    fprintf((FILE *)fp0_00,"\n%s<br>\n<em>config.cache</em>\n",uVar2);
    n = 0;
    while (n < 0x11a) {
      local_30 = *(FILE **)(n * 8 + 0x815d4a4);
      fprintf((FILE *)fp0_00,"%-35s %s\n",((anon_struct_0 *)&ram0x0815d4a0)[n].name,local_30);
      n = n + 1;
    }
    uVar2 = gettext(
                   "The following data were used as automatically-configured compile-time\ndefinitions when this copy of Lynx was built."
                   );
    fprintf((FILE *)fp0_00,"\n%s<br>\n<em>lynx_cfg.h</em>\n",uVar2,local_30);
    n = 0;
    while (n < 0xb8) {
      fprintf((FILE *)fp0_00,"%-35s %s\n",((anon_struct_1 *)&ram0x0815bc40)[n].name,
              *(undefined4 *)(n * 8 + 0x815bc44));
      n = n + 1;
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYRegisterUIPage(configinfo_url,UIP_CONFIG_DEF);
  }
  HTSACopy(&newdoc->address,configinfo_url);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  BVar1 = HTLoadAbsolute(&WWWDoc);
  if (BVar1 != '\0') {
    lynx_edit_mode = '\0';
  }
  local_28 = (uint)(BVar1 != '\0');
  return local_28;
}



BOOLEAN link_has_target(int cur,char *target)

{
  char *chptr;
  size_t __n;
  char *text;
  int count;
  char *cp;
  char *stars;
  OptionType *option;
  LinkInfo *a;
  
  stars = (char *)0x0;
  count = 0;
  while (chptr = LYGetHiliteStr(cur,count), chptr != (char *)0x0) {
    if (case_sensitive == '\0') {
      chptr = LYno_attr_char_case_strstr(chptr,target);
    }
    else {
      chptr = LYno_attr_char_strstr(chptr,target);
    }
    if (chptr != (char *)0x0) {
      return '\x01';
    }
    count = count + 1;
  }
  if (((links[cur].l_form != (_FormInfo *)0x0) && ((links[cur].l_form)->value != (char *)0x0)) &&
     ((links[cur].l_form)->type != 8)) {
    if ((links[cur].l_form)->type == 2) {
      if (case_sensitive == '\0') {
        chptr = LYno_attr_char_case_strstr((links[cur].l_form)->value,target);
      }
      else {
        chptr = LYno_attr_char_strstr((links[cur].l_form)->value,target);
      }
      if (chptr != (char *)0x0) {
        return '\x01';
      }
      HTSACopy(&stars,(links[cur].l_form)->value);
      __n = strlen(stars);
      memset(stars,0x2a,__n);
      if (case_sensitive == '\0') {
        chptr = LYno_attr_char_case_strstr(stars,target);
      }
      else {
        chptr = LYno_attr_char_strstr(stars,target);
      }
      if (chptr != (char *)0x0) {
        if (stars != (char *)0x0) {
          free(stars);
        }
        return '\x01';
      }
      if (stars != (char *)0x0) {
        free(stars);
      }
    }
    else {
      if ((links[cur].l_form)->type == 7) {
        option = (links[cur].l_form)->select_list;
        while (option != (OptionType *)0x0) {
          if (case_sensitive == '\0') {
            chptr = LYno_attr_char_case_strstr(option->name,target);
          }
          else {
            chptr = LYno_attr_char_strstr(option->name,target);
          }
          if (chptr != (char *)0x0) {
            return '\x01';
          }
          option = (OptionType *)option->next;
        }
      }
      else {
        if ((links[cur].l_form)->type == 4) {
          if ((links[cur].l_form)->num_value == 0) {
            cp = unchecked_radio;
          }
          else {
            cp = checked_radio;
          }
          if (case_sensitive == '\0') {
            chptr = LYno_attr_char_case_strstr(cp,target);
          }
          else {
            chptr = LYno_attr_char_strstr(cp,target);
          }
          if (chptr != (char *)0x0) {
            return '\x01';
          }
        }
        else {
          if ((links[cur].l_form)->type == 3) {
            if ((links[cur].l_form)->num_value == 0) {
              cp = unchecked_box;
            }
            else {
              cp = checked_box;
            }
            if (case_sensitive == '\0') {
              chptr = LYno_attr_char_case_strstr(cp,target);
            }
            else {
              chptr = LYno_attr_char_strstr(cp,target);
            }
            if (chptr != (char *)0x0) {
              return '\x01';
            }
          }
          else {
            if (case_sensitive == '\0') {
              chptr = LYno_attr_char_case_strstr((links[cur].l_form)->value,target);
            }
            else {
              chptr = LYno_attr_char_strstr((links[cur].l_form)->value,target);
            }
            if (chptr != (char *)0x0) {
              return '\x01';
            }
          }
        }
      }
    }
  }
  return '\0';
}



int check_next_target_in_links(int *cur,char *target)

{
  BOOLEAN BVar1;
  int local_18;
  int i;
  
  if (nlinks == 0) {
LAB_080aa2ce:
    local_18 = 0;
  }
  else {
    i = *cur;
    do {
      i = i + 1;
      if (nlinks <= i) goto LAB_080aa2ce;
      BVar1 = link_has_target(i,target);
    } while (BVar1 == '\0');
    *cur = i;
    local_18 = 1;
  }
  return local_18;
}



int check_prev_target_in_links(int *cur,char *target)

{
  BOOLEAN BVar1;
  int local_18;
  int i;
  
  if (nlinks == 0) {
LAB_080aa327:
    local_18 = 0;
  }
  else {
    i = *cur;
    do {
      i = i + -1;
      if (i < 0) goto LAB_080aa327;
      BVar1 = link_has_target(i,target);
    } while (BVar1 == '\0');
    *cur = i;
    local_18 = 1;
  }
  return local_18;
}



BOOLEAN textsearch(DocInfo *cur_doc,char *prev_target,int target_size,int direction)

{
  int cur;
  bool bVar1;
  bool bVar2;
  BOOLEAN first;
  char prev_target_buffer [512];
  RecallType recall_00;
  char *text;
  int iVar3;
  int local_2c;
  int QueryNum;
  int QueryTotal;
  RecallType recall;
  int ch;
  char *cp;
  int oldcur;
  int offset;
  BOOLEAN FirstRecall;
  
  cur = cur_doc->link;
  ch = 0;
  bVar2 = true;
  if (first != '\0') {
    prev_target_buffer[0] = '\0';
    first = '\0';
  }
  if (search_queries == (HTList *)0x0) {
    local_2c = 0;
  }
  else {
    local_2c = HTList_count(search_queries);
  }
  bVar1 = 0 < local_2c;
  recall_00 = (RecallType)bVar1;
  QueryNum = local_2c;
  if (direction != 0) {
    LYstrncpy(prev_target,(char *)0x81afaa0,target_size);
  }
  if (*prev_target == '\0') {
    mustshow = '\x01';
    text = (char *)gettext(0x815defc);
    statusline(text);
    ch = LYgetstr(prev_target,0,target_size,recall_00);
    if (ch < 0) {
      LYstrncpy(prev_target,(char *)0x81afaa0,target_size);
      text = (char *)gettext("Cancelled!!!");
      HTInfoMsg(text);
      return '\0';
    }
  }
  do {
    while( true ) {
      if ((*prev_target == '\0') && ((!bVar1 || ((ch != 0x100 && (ch != 0x101)))))) {
        text = (char *)gettext("Cancelled!!!");
        HTInfoMsg(text);
        return '\0';
      }
      if ((bVar1) && (ch == 0x100)) break;
      if ((!bVar1) || (ch != 0x101)) goto LAB_080aa821;
      if (bVar2) {
        bVar2 = false;
        if (prev_target_buffer[0] == '\0') {
          QueryNum = local_2c + -1;
        }
        else {
          QueryNum = 0;
          while ((QueryNum < local_2c + -1 &&
                 ((text = (char *)HTList_objectAt(search_queries,QueryNum), text == (char *)0x0 ||
                  (iVar3 = strcmp((char *)0x81afaa0,text), iVar3 != 0))))) {
            QueryNum = QueryNum + 1;
          }
        }
      }
      else {
        QueryNum = QueryNum + -1;
      }
      if (QueryNum < 0) {
        QueryNum = local_2c + -1;
      }
      text = (char *)HTList_objectAt(search_queries,QueryNum);
      if (text == (char *)0x0) goto LAB_080aa821;
      LYstrncpy(prev_target,text,target_size);
      if ((prev_target_buffer[0] == '\0') ||
         (iVar3 = strcmp((char *)0x81afaa0,prev_target), iVar3 != 0)) {
        if (((prev_target_buffer[0] == '\0') || (local_2c != 2)) &&
           ((prev_target_buffer[0] != '\0' || (local_2c != 1)))) {
          mustshow = '\x01';
          text = (char *)gettext("Edit a previous query: ");
          statusline(text);
        }
        else {
          mustshow = '\x01';
          text = (char *)gettext("Edit the previous query: ");
          statusline(text);
        }
      }
      else {
        mustshow = '\x01';
        text = (char *)gettext("Edit the current query: ");
        statusline(text);
      }
      ch = LYgetstr(prev_target,0,target_size,recall_00);
      if (ch < 0) {
        LYstrncpy(prev_target,(char *)0x81afaa0,target_size);
        text = (char *)gettext("Cancelled!!!");
        HTInfoMsg(text);
        return '\0';
      }
    }
    if (bVar2) {
      bVar2 = false;
      QueryNum = local_2c;
      if (prev_target_buffer[0] == '\0') {
        QueryNum = 0;
      }
      else {
        do {
          QueryNum = QueryNum + -1;
          if (QueryNum < 1) break;
          text = (char *)HTList_objectAt(search_queries,QueryNum);
        } while ((text == (char *)0x0) || (iVar3 = strcmp((char *)0x81afaa0,text), iVar3 != 0));
      }
    }
    else {
      QueryNum = QueryNum + 1;
    }
    if (local_2c <= QueryNum) {
      QueryNum = 0;
    }
    text = (char *)HTList_objectAt(search_queries,QueryNum);
    if (text == (char *)0x0) {
LAB_080aa821:
      LYstrncpy((char *)0x81afaa0,prev_target,0x1ff);
      HTAddSearchQuery((char *)0x81afaa0);
      if (direction < 0) {
        offset = 0;
        iVar3 = check_prev_target_in_links(&cur_doc->link,prev_target);
        if (iVar3 != 0) {
          LYhighlight(0,cur,prev_target);
          return '\x01';
        }
      }
      else {
        iVar3 = check_next_target_in_links(&cur_doc->link,prev_target);
        if (iVar3 != 0) {
          LYhighlight(0,cur,prev_target);
          return '\x01';
        }
        if (nlinks == 0) {
          offset = display_lines + -1;
        }
        else {
          offset = links[cur_doc->link].ly + -1;
        }
      }
      www_user_search(cur_doc->line + offset,cur_doc,prev_target,direction);
      if (cur_doc->link != cur) {
        LYhighlight(0,cur,prev_target);
        return '\x01';
      }
      return 0 < www_search_result;
    }
    LYstrncpy(prev_target,text,target_size);
    if ((prev_target_buffer[0] == '\0') ||
       (iVar3 = strcmp((char *)0x81afaa0,prev_target), iVar3 != 0)) {
      if (((prev_target_buffer[0] == '\0') || (local_2c != 2)) &&
         ((prev_target_buffer[0] != '\0' || (local_2c != 1)))) {
        mustshow = '\x01';
        text = (char *)gettext("Edit a previous query: ");
        statusline(text);
      }
      else {
        mustshow = '\x01';
        text = (char *)gettext("Edit the previous query: ");
        statusline(text);
      }
    }
    else {
      mustshow = '\x01';
      text = (char *)gettext("Edit the current query: ");
      statusline(text);
    }
    ch = LYgetstr(prev_target,0,target_size,recall_00);
    if (ch < 0) {
      LYstrncpy(prev_target,(char *)0x81afaa0,target_size);
      text = (char *)gettext("Cancelled!!!");
      HTInfoMsg(text);
      return '\0';
    }
  } while( true );
}



void trace_history(char *tag)

{
  int iVar1;
  int iVar2;
  int iVar3;
  FILE *__stream;
  
  iVar3 = nhist_extra;
  iVar2 = size_history;
  iVar1 = nhist;
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HISTORY %s %d/%d (%d extra)\n",tag,iVar1,iVar2,iVar3);
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fflush((FILE *)__stream);
    }
  }
  return;
}



void LYAddVisitedLink(DocInfo *doc)

{
  bool bVar1;
  BOOLEAN BVar2;
  int iVar3;
  VisitedLink *newObject;
  char *local_34;
  char *local_30;
  char *local_2c;
  VisitedLink *local_28;
  int l;
  VisitedLink *b;
  VisitedLink *a;
  int related;
  char *title;
  HTList *cur;
  VisitedLink *tmp;
  
  if (doc->title == (char *)0x0) {
    local_34 = (char *)gettext("(No title.)");
  }
  else {
    local_34 = doc->title;
  }
  if ((doc->address == (char *)0x0) || (*doc->address == '\0')) {
    PrevVisitedLink = (VisitedLink *)0x0;
    return;
  }
  if ((((doc->post_data == (bstring *)0x0) && (doc->isHEAD == '\0')) &&
      (doc->bookmark == (char *)0x0)) &&
     ((iVar3 = strncmp(doc->address,"LYNX",4), iVar3 != 0 &&
      (iVar3 = strncmp(doc->address,"file://localhost/",0x11), iVar3 != 0)))) {
LAB_080aad21:
    if (Visited_Links == (HTList *)0x0) {
      Visited_Links = HTList_new();
      Latest_last.prev_latest = (_VisitedLink *)&Latest_first;
      Latest_first.next_latest = (_VisitedLink *)&Latest_last;
      Latest_last.next_latest = (_VisitedLink *)0x0;
      Latest_first.prev_latest = (_VisitedLink *)0x0;
      First_tree = (VisitedLink *)0x0;
      Latest_tree = (VisitedLink *)0x0;
      Last_by_first = (VisitedLink *)0x0;
    }
    cur = Visited_Links;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_28 = (VisitedLink *)0x0;
      }
      else {
        local_28 = (VisitedLink *)cur->object;
      }
      if (local_28 == (VisitedLink *)0x0) {
        newObject = (VisitedLink *)calloc(1,0x1c);
        if (newObject == (VisitedLink *)0x0) {
          outofmem("./LYHistory.c","LYAddVisitedLink");
        }
        HTSACopy(&newObject->address,doc->address);
        LYformTitle((char **)newObject,local_34);
        HTList_appendObject(Visited_Links,newObject);
        *(VisitedLink **)&newObject->prev_first = Last_by_first;
        Last_by_first = newObject;
        if (PrevVisitedLink == (VisitedLink *)0x0) {
          if (Latest_tree != (VisitedLink *)0x0) {
            *(VisitedLink **)&Latest_tree->next_tree = newObject;
          }
          newObject->level = 0;
          newObject->next_tree = (_VisitedLink *)0x0;
          Latest_tree = newObject;
        }
        else {
          a = PrevVisitedLink;
          b = (VisitedLink *)PrevVisitedLink->next_tree;
          while ((b != (VisitedLink *)0x0 && (PrevVisitedLink->level < b->level))) {
            a = b;
            b = (VisitedLink *)b->next_tree;
          }
          if (b == (VisitedLink *)0x0) {
            Latest_tree = newObject;
          }
          newObject->next_tree = a->next_tree;
          *(VisitedLink **)&a->next_tree = newObject;
          newObject->level = PrevVisitedLink->level + 1;
        }
        if (First_tree == (VisitedLink *)0x0) {
          First_tree = newObject;
        }
        PrevVisitedLink = newObject;
        PrevActiveVisitedLink = newObject;
        *(VisitedLink **)&(Latest_last.prev_latest)->next_latest = newObject;
        newObject->prev_latest = Latest_last.prev_latest;
        *(VisitedLink **)&newObject->next_latest = &Latest_last;
        Latest_last.prev_latest = (_VisitedLink *)newObject;
        return;
      }
      if (doc->address == (char *)0x0) {
        local_30 = "";
      }
      else {
        local_30 = doc->address;
      }
      if (local_28->address == (char *)0x0) {
        local_2c = "";
      }
      else {
        local_2c = local_28->address;
      }
      iVar3 = strcmp(local_2c,local_30);
    } while (iVar3 != 0);
    PrevVisitedLink = local_28;
    PrevActiveVisitedLink = local_28;
    if ((VisitedLink *)local_28->next_latest != &Latest_last) {
      local_28->prev_latest->next_latest = local_28->next_latest;
      local_28->next_latest->prev_latest = local_28->prev_latest;
      *(VisitedLink **)&(Latest_last.prev_latest)->next_latest = local_28;
      local_28->prev_latest = Latest_last.prev_latest;
      *(VisitedLink **)&local_28->next_latest = &Latest_last;
      Latest_last.prev_latest = (_VisitedLink *)local_28;
    }
  }
  else {
    bVar1 = true;
    BVar2 = LYIsUIPage3(doc->address,UIP_HISTORY,1);
    if (((BVar2 == '\0') &&
        ((BVar2 = LYIsUIPage3(doc->address,UIP_VLINKS,1), BVar2 == '\0' &&
         (BVar2 = LYIsUIPage3(doc->address,UIP_SHOWINFO,1), BVar2 == '\0')))) &&
       (iVar3 = strncasecomp(doc->address,"LYNXMESSAGES:",0xd), iVar3 != 0)) {
      bVar1 = false;
      BVar2 = LYIsUIPage3(doc->address,UIP_DIRED_MENU,1);
      if (((((BVar2 == '\0') &&
            (BVar2 = LYIsUIPage3(doc->address,UIP_UPLOAD_OPTIONS,1), BVar2 == '\0')) &&
           (BVar2 = LYIsUIPage3(doc->address,UIP_PERMIT_OPTIONS,1), BVar2 == '\0')) &&
          (((BVar2 = LYIsUIPage3(doc->address,UIP_PRINT_OPTIONS,1), BVar2 == '\0' &&
            (BVar2 = LYIsUIPage3(doc->address,UIP_DOWNLOAD_OPTIONS,1), BVar2 == '\0')) &&
           ((BVar2 = LYIsUIPage3(doc->address,UIP_OPTIONS_MENU,1), BVar2 == '\0' &&
            ((iVar3 = strncasecomp(doc->address,"LYNXKEYMAP:",0xb), iVar3 != 0 &&
             (BVar2 = LYIsUIPage3(doc->address,UIP_LIST_PAGE,1), BVar2 == '\0')))))))) &&
         ((BVar2 = LYIsUIPage3(doc->address,UIP_CONFIG_DEF,1), BVar2 == '\0' &&
          (((BVar2 = LYIsUIPage3(doc->address,UIP_LYNXCFG,1), BVar2 == '\0' &&
            (iVar3 = strncasecomp(doc->address,"LYNXCOOKIE:",0xb), iVar3 != 0)) &&
           (BVar2 = LYIsUIPage3(doc->address,UIP_TRACELOG,1), BVar2 == '\0')))))) goto LAB_080aad21;
    }
    if (!bVar1) {
      PrevVisitedLink = (VisitedLink *)0x0;
    }
  }
  return;
}



BOOLEAN LYwouldPush(char *title,char *docurl)

{
  BOOLEAN BVar1;
  int iVar2;
  size_t sVar3;
  char *__s2;
  BOOLEAN local_1c;
  size_t ulen;
  BOOLEAN rc;
  
  if ((docurl != (char *)0x0) &&
     (((iVar2 = strncmp(docurl,"file://localhost/",0x11), iVar2 != 0 ||
       (sVar3 = strlen(docurl), sVar3 < 6)) ||
      (iVar2 = strcmp(docurl + (sVar3 - 5),".html"), iVar2 != 0)))) {
    return '\x01';
  }
  if (docurl != (char *)0x0) {
    BVar1 = LYIsUIPage3(docurl,UIP_HISTORY,1);
    if (((BVar1 == '\0') && (BVar1 = LYIsUIPage3(docurl,UIP_PRINT_OPTIONS,1), BVar1 == '\0')) &&
       ((BVar1 = LYIsUIPage3(docurl,UIP_DIRED_MENU,1), BVar1 == '\0' &&
        ((BVar1 = LYIsUIPage3(docurl,UIP_UPLOAD_OPTIONS,1), BVar1 == '\0' &&
         (BVar1 = LYIsUIPage3(docurl,UIP_PERMIT_OPTIONS,1), BVar1 == '\0')))))) {
      local_1c = '\x01';
    }
    else {
      local_1c = '\0';
    }
    return local_1c;
  }
  __s2 = (char *)gettext("History Page");
  iVar2 = strcmp(title,__s2);
  if (iVar2 != 0) {
    __s2 = (char *)gettext("Printing Options");
    iVar2 = strcmp(title,__s2);
    if (iVar2 != 0) {
      __s2 = (char *)gettext("File Management Options");
      iVar2 = strcmp(title,__s2);
      if (iVar2 != 0) {
        __s2 = (char *)gettext("Upload Options");
        iVar2 = strcmp(title,__s2);
        if (iVar2 != 0) {
          __s2 = (char *)gettext("File Permission Options");
          iVar2 = strcmp(title,__s2);
          if (iVar2 != 0) {
            return '\x01';
          }
        }
      }
    }
  }
  return '\0';
}



void LYFreePostData(DocInfo *doc)

{
  HTSABFree(&doc->post_data);
  if (doc->post_content_type != (char *)0x0) {
    free(doc->post_content_type);
    doc->post_content_type = (char *)0x0;
  }
  return;
}



void LYFreeDocInfo(DocInfo *doc)

{
  if (doc->title != (char *)0x0) {
    free(doc->title);
    doc->title = (char *)0x0;
  }
  if (doc->address != (char *)0x0) {
    free(doc->address);
    doc->address = (char *)0x0;
  }
  if (doc->bookmark != (char *)0x0) {
    free(doc->bookmark);
    doc->bookmark = (char *)0x0;
  }
  LYFreePostData(doc);
  return;
}



void clean_extra_history(void)

{
  trace_history("clean_extra_history");
  nhist = nhist + nhist_extra;
  while (0 < nhist_extra) {
    nhist = nhist + -1;
    LYFreeDocInfo((DocInfo *)(history + nhist));
    nhist_extra = nhist_extra + -1;
  }
  trace_history("...clean_extra_history");
  return;
}



int are_identical(HistInfo *doc,DocInfo *doc1)

{
  BOOLEAN BVar1;
  int iVar2;
  char *local_c;
  char *local_8;
  
  iVar2 = strcmp(doc1->address,(doc->hdoc).address);
  if ((iVar2 == 0) && (BVar1 = HTSABEql(doc1->post_data,(doc->hdoc).post_data), BVar1 != '\0')) {
    if ((doc->hdoc).bookmark == (char *)0x0) {
      local_c = "";
    }
    else {
      local_c = (doc->hdoc).bookmark;
    }
    if (doc1->bookmark == (char *)0x0) {
      local_8 = "";
    }
    else {
      local_8 = doc1->bookmark;
    }
    iVar2 = strcmp(local_8,local_c);
    if ((iVar2 == 0) && (doc1->isHEAD == (doc->hdoc).isHEAD)) {
      return 1;
    }
  }
  return 0;
}



void LYAllocHistory(int entries)

{
  HistInfo *__s;
  int iVar1;
  FILE *__stream;
  size_t __size;
  int save;
  uint want;
  
  iVar1 = size_history;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYAllocHistory %d vs %d\n",entries,iVar1);
  }
  if (size_history <= entries + 1) {
    save = size_history;
    size_history = (entries + 2) * 2;
    __size = (entries + 2) * 0x58;
    if (history == (HistInfo *)0x0) {
      history = (HistInfo *)malloc(__size);
    }
    else {
      history = (HistInfo *)realloc(history,__size);
    }
    if (history == (HistInfo *)0x0) {
      outofmem("./LYHistory.c","LYAllocHistory");
    }
    while (save < size_history) {
      __s = history + save;
      save = save + 1;
      memset(__s,0,0x2c);
    }
  }
  iVar1 = size_history;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"...LYAllocHistory %d vs %d\n",entries,iVar1);
  }
  return;
}



int LYpush(DocInfo *doc,BOOLEAN force_push)

{
  char *pcVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  int iVar4;
  HTParentAnchor *pHVar5;
  FILE *__stream;
  int local_44;
  char *local_40;
  int local_38;
  DocAddress WWWDoc;
  char *temp;
  HTParentAnchor *thatparent;
  HTParentAnchor *thisparent;
  
  if (*doc->address == '\0') {
    return 0;
  }
  if ((force_push == '\0') && (BVar3 = LYwouldPush(doc->title,doc->address), BVar3 == '\0')) {
    if (LYforce_no_cache == '\0') {
      LYoverride_no_cache = '\x01';
    }
    return 0;
  }
  if (((0 < nhist) && (iVar4 = are_identical(history + nhist + -1,doc), iVar4 != 0)) &&
     (history[nhist + -1].hdoc.internal_link == doc->internal_link)) {
    history[nhist + -1].hdoc.link = doc->link;
    history[nhist + -1].hdoc.line = doc->line;
    return 0;
  }
  if ((0 < nhist_extra) && (iVar4 = are_identical(history + nhist,doc), iVar4 != 0)) {
    history[nhist].hdoc.link = doc->link;
    history[nhist].hdoc.line = doc->line;
    nhist_extra = nhist_extra + -1;
    LYAllocHistory(nhist);
    nhist = nhist + 1;
    trace_history("LYpush: just move the cursor");
    return 1;
  }
  clean_extra_history();
  LYAllocHistory(nhist);
  history[nhist].hdoc.link = doc->link;
  history[nhist].hdoc.line = doc->line;
  history[nhist].hdoc.title = (char *)0x0;
  LYformTitle((char **)(history + nhist),doc->title);
  history[nhist].hdoc.address = (char *)0x0;
  HTSACopy(&history[nhist].hdoc.address,doc->address);
  history[nhist].hdoc.post_data = (bstring *)0x0;
  if (doc->post_data == (bstring *)0x0) {
    local_44 = 0;
  }
  else {
    local_44 = doc->post_data->len;
  }
  if (doc->post_data == (bstring *)0x0) {
    local_40 = (char *)0x0;
  }
  else {
    local_40 = doc->post_data->str;
  }
  HTSABCopy(&history[nhist].hdoc.post_data,local_40,local_44);
  history[nhist].hdoc.post_content_type = (char *)0x0;
  HTSACopy(&history[nhist].hdoc.post_content_type,doc->post_content_type);
  history[nhist].hdoc.bookmark = (char *)0x0;
  HTSACopy(&history[nhist].hdoc.bookmark,doc->bookmark);
  history[nhist].hdoc.isHEAD = doc->isHEAD;
  history[nhist].hdoc.safe = doc->safe;
  history[nhist].hdoc.internal_link = '\0';
  history[nhist].intern_seq_start = -1;
  if (doc->internal_link != '\0') {
    if (0 < nhist) {
      thatparent = (HTParentAnchor *)0x0;
      WWWDoc.address = doc->address;
      WWWDoc.post_data = doc->post_data;
      WWWDoc.post_content_type = doc->post_content_type;
      WWWDoc.bookmark = doc->bookmark;
      WWWDoc.isHEAD = doc->isHEAD;
      WWWDoc.safe = doc->safe;
      pHVar5 = HTAnchor_findAddress(&WWWDoc);
      if (pHVar5 != (HTParentAnchor *)0x0) {
        iVar4 = strncasecomp(history[nhist + -1].hdoc.address,"LYNXIMGMAP:",0xb);
        if ((iVar4 == 0) && (iVar4 = strncasecomp(doc->address,"LYNXIMGMAP:",0xb), iVar4 != 0)) {
          WWWDoc.address = history[nhist + -1].hdoc.address + 0xb;
        }
        else {
          iVar4 = strncasecomp(doc->address,"LYNXIMGMAP:",0xb);
          if ((iVar4 == 0) &&
             (iVar4 = strncasecomp(history[nhist + -1].hdoc.address,"LYNXIMGMAP:",0xb), iVar4 != 0))
          {
            temp = (char *)0x0;
            HTSACopy(&temp,"LYNXIMGMAP:");
            HTSACat(&temp,doc->address + 0xb);
            WWWDoc.address = temp;
            WWWDoc.post_content_type = history[nhist + -1].hdoc.post_content_type;
            WWWDoc.bookmark = history[nhist + -1].hdoc.bookmark;
            WWWDoc.isHEAD = history[nhist + -1].hdoc.isHEAD;
            WWWDoc.safe = history[nhist + -1].hdoc.safe;
            thatparent = HTAnchor_findAddress(&WWWDoc);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
          }
          else {
            WWWDoc.address = history[nhist + -1].hdoc.address;
          }
        }
        if (thatparent == (HTParentAnchor *)0x0) {
          WWWDoc.post_data = history[nhist + -1].hdoc.post_data;
          WWWDoc.post_content_type = history[nhist + -1].hdoc.post_content_type;
          WWWDoc.bookmark = history[nhist + -1].hdoc.bookmark;
          WWWDoc.isHEAD = history[nhist + -1].hdoc.isHEAD;
          WWWDoc.safe = history[nhist + -1].hdoc.safe;
          thatparent = HTAnchor_findAddress(&WWWDoc);
        }
        if ((thatparent == pHVar5) && ((HTMainText == (HText *)0x0 || (HTMainAnchor == pHVar5)))) {
          history[nhist].hdoc.internal_link = '\x01';
          if (history[nhist + -1].intern_seq_start < 0) {
            local_38 = nhist + -1;
          }
          else {
            local_38 = history[nhist + -1].intern_seq_start;
          }
          history[nhist].intern_seq_start = local_38;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"\nLYpush: pushed as internal link, OK\n");
          }
        }
      }
    }
    if ((history[nhist].hdoc.internal_link == '\0') && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\nLYpush: push as internal link requested, %s\n",
              "but didn\'t check out!");
    }
  }
  iVar4 = nhist;
  if (WWW_TraceFlag != '\0') {
    pcVar1 = doc->title;
    pcVar2 = doc->address;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nLYpush[%d]: address:%s\n        title:%s\n",iVar4,pcVar2,pcVar1);
  }
  nhist = nhist + 1;
  return 1;
}



void LYpop(DocInfo *doc)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  FILE *__stream;
  HistInfo *pHVar4;
  
  if (0 < nhist) {
    clean_extra_history();
    nhist = nhist + -1;
    LYFreeDocInfo(doc);
    pHVar4 = history + nhist;
    doc->title = (pHVar4->hdoc).title;
    doc->address = (pHVar4->hdoc).address;
    doc->post_data = (pHVar4->hdoc).post_data;
    doc->post_content_type = (pHVar4->hdoc).post_content_type;
    doc->bookmark = (pHVar4->hdoc).bookmark;
    *(undefined4 *)&doc->isHEAD = *(undefined4 *)&(pHVar4->hdoc).isHEAD;
    doc->link = (pHVar4->hdoc).link;
    doc->line = (pHVar4->hdoc).line;
    *(undefined4 *)&doc->internal_link = *(undefined4 *)&(pHVar4->hdoc).internal_link;
    doc->style = (pHVar4->hdoc).style;
    LYSetNewline(doc->line);
    iVar3 = nhist;
    if (WWW_TraceFlag != '\0') {
      pcVar1 = doc->title;
      pcVar2 = doc->address;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYpop[%d]: address:%s\n     title:%s\n",iVar3,pcVar2,pcVar1);
    }
  }
  return;
}



void LYhist_prev(DocInfo *doc)

{
  trace_history("LYhist_prev");
  if ((0 < nhist) && ((nhist_extra != 0 || (nhist < size_history)))) {
    nhist = nhist + -1;
    nhist_extra = nhist_extra + 1;
    LYpop_num(nhist,doc);
    trace_history("...LYhist_prev");
  }
  return;
}



void LYhist_prev_register(DocInfo *doc)

{
  int iVar1;
  
  trace_history("LYhist_prev_register");
  if (1 < nhist) {
    if (nhist_extra == 0) {
      iVar1 = LYpush(doc,'\0');
      if (iVar1 != 0) {
        nhist = nhist + -1;
        nhist_extra = nhist_extra + 1;
      }
    }
    else {
      history[nhist].hdoc.link = doc->link;
      history[nhist].hdoc.line = doc->line;
    }
    trace_history("...LYhist_prev_register");
  }
  return;
}



int LYhist_next(DocInfo *doc,DocInfo *newdoc)

{
  bool bVar1;
  uint local_8;
  
  bVar1 = 1 < nhist_extra;
  if (bVar1) {
    history[nhist].hdoc.link = doc->link;
    history[nhist].hdoc.line = doc->line;
    LYAllocHistory(nhist);
    nhist = nhist + 1;
    nhist_extra = nhist_extra + -1;
    LYpop_num(nhist,newdoc);
  }
  local_8 = (uint)bVar1;
  return local_8;
}



void LYpop_num(int number,DocInfo *doc)

{
  int iVar1;
  FILE *__stream;
  int local_18;
  char *local_14;
  char *local_10;
  char *local_c;
  
  if ((-1 < number) && (number < nhist + nhist_extra)) {
    doc->link = history[number].hdoc.link;
    doc->line = history[number].hdoc.line;
    HTSACopy((char **)doc,history[number].hdoc.title);
    HTSACopy(&doc->address,history[number].hdoc.address);
    if (history[number].hdoc.post_data == (bstring *)0x0) {
      local_18 = 0;
    }
    else {
      local_18 = (history[number].hdoc.post_data)->len;
    }
    if (history[number].hdoc.post_data == (bstring *)0x0) {
      local_14 = (char *)0x0;
    }
    else {
      local_14 = (history[number].hdoc.post_data)->str;
    }
    HTSABCopy(&doc->post_data,local_14,local_18);
    HTSACopy(&doc->post_content_type,history[number].hdoc.post_content_type);
    HTSACopy(&doc->bookmark,history[number].hdoc.bookmark);
    doc->isHEAD = history[number].hdoc.isHEAD;
    doc->safe = history[number].hdoc.safe;
    doc->internal_link = history[number].hdoc.internal_link;
    LYSetNewline(doc->line);
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYpop_num(%d)\n",number);
      }
      if (WWW_TraceFlag != '\0') {
        iVar1 = doc->link;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"  link    %d\n",iVar1);
      }
      if (WWW_TraceFlag != '\0') {
        iVar1 = doc->line;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"  line    %d\n",iVar1);
      }
      if (WWW_TraceFlag != '\0') {
        if (doc->title == (char *)0x0) {
          local_10 = "";
        }
        else {
          local_10 = doc->title;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"  title   %s\n",local_10);
      }
      if (WWW_TraceFlag != '\0') {
        if (doc->address == (char *)0x0) {
          local_c = "";
        }
        else {
          local_c = doc->address;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"  address %s\n",local_c);
      }
    }
  }
  return;
}



int showhistory(char **newfile)

{
  char tempfile [256];
  FILE *fp0_00;
  undefined4 uVar1;
  int local_44;
  char *local_48;
  FILE *local_40;
  int local_24;
  undefined *local_1c;
  undefined *local_18;
  FILE *fp0;
  int x;
  char *Title;
  
  Title = (char *)0x0;
  fp0_00 = InternalPageFP((char *)&ram0x08197080,1);
  if (fp0_00 == (FILE *)0x0) {
    local_24 = -1;
  }
  else {
    LYLocalFileToURL(newfile,(char *)0x8197080);
    LYforce_HTML_mode = '\x01';
    LYforce_no_cache = '\x01';
    local_48 = (char *)gettext("History Page");
    BeginInternalPage(fp0_00,local_48,"keystrokes/history_help.html.gz");
    uVar1 = gettext("Your recent statusline messages");
    fprintf((FILE *)fp0_00,"<p align=right> <a href=\"%s\">[%s]</a>\n","LYNXMESSAGES:",uVar1);
    local_40 = fp0_00;
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    local_44 = gettext("You selected:");
    local_48 = "<em>%s</em>\n";
    fprintf((FILE *)fp0_00,"<em>%s</em>\n",local_44);
    x = nhist + nhist_extra;
    while (x = x + -1, -1 < x) {
      if (history[x].hdoc.title == (char *)0x0) {
        local_48 = (char *)gettext("(No title.)",local_48,local_44,local_40);
        HTSACopy(&Title,local_48);
      }
      else {
        HTSACopy(&Title,history[x].hdoc.title);
        LYEntify(&Title,'\x01');
        LYTrimLeading(Title);
        LYTrimTrailing(Title);
        if (*Title == '\0') {
          local_48 = (char *)gettext("(No title.)");
          HTSACopy(&Title,local_48);
        }
      }
      if (x < 100) {
        if (x < 10) {
          local_18 = &DAT_0815e2c5;
        }
        else {
          local_18 = &DAT_0815e2c8;
        }
        local_1c = local_18;
      }
      else {
        local_1c = &DAT_0815dfd2;
      }
      fprintf((FILE *)fp0_00,"%s<em>%d</em>. <tab id=t%d><a href=\"%s%d\">%s</a>\n",local_1c,x,x,
              "LYNXHIST:",x,Title);
      if (history[x].hdoc.address == (char *)0x0) {
        local_48 = (char *)gettext("(no address)");
        HTSACopy(&Title,local_48);
      }
      else {
        HTSACopy(&Title,history[x].hdoc.address);
        LYEntify(&Title,'\x01');
      }
      if (history[x].hdoc.internal_link != '\0') {
        if (history[x].intern_seq_start == history[nhist + -1].intern_seq_start) {
          local_48 = (char *)gettext(" (internal)");
          HTSACat(&Title,local_48);
        }
        else {
          local_48 = (char *)gettext(" (was internal)");
          HTSACat(&Title,local_48);
        }
      }
      local_48 = "<tab to=t%d>%s\n";
      local_44 = x;
      local_40 = (FILE *)Title;
      fprintf((FILE *)fp0_00,"<tab to=t%d>%s\n");
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    if (Title != (char *)0x0) {
      free(Title);
    }
    local_24 = 0;
  }
  return local_24;
}



// WARNING: Removing unreachable block (ram,0x080ac7ff)

BOOLEAN historytarget(DocInfo *newdoc)

{
  BOOLEAN BVar1;
  size_t sVar2;
  ushort **ppuVar3;
  int number_00;
  char *__s1;
  int iVar4;
  char *__s2;
  HTParentAnchor *me;
  HyperDoc *pHVar5;
  DocAddress WWWDoc;
  HText *text;
  HTParentAnchor *tmpanchor;
  int number;
  BOOLEAN treat_as_intern;
  
  if ((((newdoc == (DocInfo *)0x0) || (newdoc->address == (char *)0x0)) ||
      (sVar2 = strlen(newdoc->address), sVar2 < 10)) ||
     (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)newdoc->address[9]] & 0x800) == 0)) {
    return '\0';
  }
  number_00 = atoi(newdoc->address + 9);
  if ((nhist + nhist_extra < number_00) || (number_00 < 0)) {
    return '\0';
  }
  if ((HTMainText != (HText *)0x0) && (0 < nhist)) {
    __s2 = (char *)gettext("History Page");
    __s1 = HTLoadedDocumentTitle();
    iVar4 = strcmp(__s1,__s2);
    if (iVar4 == 0) {
      __s2 = HTLoadedDocumentURL();
      BVar1 = LYIsUIPage3(__s2,UIP_HISTORY,0);
      if (BVar1 != '\0') {
        __s2 = history[nhist + -1].hdoc.address;
        __s1 = HTLoadedDocumentURL();
        iVar4 = strcmp(__s1,__s2);
        if (iVar4 != 0) {
          HTuncache_current_document();
        }
      }
    }
  }
  LYpop_num(number_00,newdoc);
  if ((((newdoc->internal_link == '\0') ||
       (history[number_00].intern_seq_start != history[nhist + -1].intern_seq_start)) &&
      ((nhist + -1 <= number_00 ||
       ((history[nhist + -1].hdoc.internal_link == '\0' ||
        (history[nhist + -1].intern_seq_start != number_00)))))) ||
     ((LYforce_no_cache == '\x01' && (LYoverride_no_cache == '\0')))) {
    newdoc->internal_link = '\0';
  }
  if (newdoc->post_data == (bstring *)0x0) goto LAB_080ac88a;
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  me = HTAnchor_findAddress(&WWWDoc);
  pHVar5 = HTAnchor_document(me);
  if ((LYresubmit_posts == '\x01') ||
     (((LYforce_no_cache == '\x01' && (LYoverride_no_cache == '\0')) || (pHVar5 == (HyperDoc *)0x0))
     )) {
    iVar4 = strncasecomp(newdoc->address,"LYNXIMGMAP:",0xb);
    if (iVar4 != 0) {
      __s2 = (char *)gettext("Document from Form with POST content.  Resubmit?");
      BVar1 = HTConfirm(__s2);
      if (BVar1 != '\x01') goto LAB_080ac85a;
    }
    LYforce_no_cache = '\x01';
    LYoverride_no_cache = '\0';
  }
  else {
LAB_080ac85a:
    if (pHVar5 == (HyperDoc *)0x0) {
      __s2 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(__s2);
      return '\0';
    }
    LYforce_no_cache = '\0';
    LYoverride_no_cache = '\x01';
  }
LAB_080ac88a:
  if (number_00 != 0) {
    __s2 = (char *)gettext(" (From History)");
    HTSACat((char **)newdoc,__s2);
  }
  return '\x01';
}



int LYShowVisitedLinks(char **newfile)

{
  HTList *pHVar1;
  int iVar2;
  char tempfile [256];
  FILE *fp0_00;
  int local_74;
  char *local_78;
  int local_68;
  int local_64;
  char *local_60;
  int local_50;
  VisitedLink *local_4c;
  char *local_48;
  int local_44;
  int local_40;
  FILE *local_3c;
  VisitedLink *local_38;
  char *post_arrow;
  char *arrow;
  int ret;
  int offset;
  HTList *cur;
  VisitedLink *vl;
  FILE *fp0;
  int tot;
  int x;
  char *Address;
  char *Title;
  
  pHVar1 = Visited_Links;
  Title = (char *)0x0;
  Address = (char *)0x0;
  cur = Visited_Links;
  ret = 0;
  if (Visited_Links == (HTList *)0x0) {
    local_50 = -1;
  }
  else {
    fp0_00 = InternalPageFP((char *)&ram0x08197180,1);
    if (fp0_00 == (FILE *)0x0) {
      local_50 = -1;
    }
    else {
      LYLocalFileToURL(newfile,(char *)0x8197180);
      LYRegisterUIPage(*newfile,UIP_VLINKS);
      LYforce_HTML_mode = '\x01';
      LYforce_no_cache = '\x01';
      local_78 = (char *)gettext("Visited Links Page");
      BeginInternalPage(fp0_00,local_78,"keystrokes/visited_help.html.gz");
      fprintf((FILE *)fp0_00,"<form action=\"%s\" method=\"post\">\n","LYNXOPTIONS:");
      LYMenuVisitedLinks(fp0_00,0);
      fwrite("<input type=\"submit\" value=\"Accept Changes\">\n",1,0x2d,(FILE *)fp0_00);
      fwrite("</form>\n",1,8,(FILE *)fp0_00);
      fwrite(&DAT_0815e437,1,4,(FILE *)fp0_00);
      local_3c = fp0_00;
      fwrite("<pre>\n",1,6,(FILE *)fp0_00);
      local_74 = gettext("You visited (POSTs, bookmark, menu and list files excluded):");
      local_78 = "<em>%s</em>\n";
      fprintf((FILE *)fp0_00,"<em>%s</em>\n",local_74);
      if ((Visited_Links_As & 4U) == 0) {
        x = -1;
      }
      else {
        x = HTList_count(Visited_Links);
      }
      iVar2 = x;
      if ((Visited_Links_As & 1U) == 0) {
        if ((Visited_Links_As & 2U) == 0) {
          if ((Visited_Links_As & 4U) == 0) {
            if ((pHVar1 == (HTList *)0x0) || (cur = pHVar1->next, cur == (HTList *)0x0)) {
              local_4c = (VisitedLink *)0x0;
            }
            else {
              local_4c = (VisitedLink *)cur->object;
            }
            vl = local_4c;
          }
          else {
            vl = Last_by_first;
          }
        }
        else {
          if ((Visited_Links_As & 4U) == 0) {
            vl = (VisitedLink *)Latest_first.next_latest;
          }
          else {
            vl = (VisitedLink *)Latest_last.prev_latest;
          }
          if ((vl == &Latest_last) || (vl == &Latest_first)) {
            vl = (VisitedLink *)0x0;
          }
        }
      }
      else {
        vl = First_tree;
      }
      while (vl != (VisitedLink *)0x0) {
        arrow = "";
        post_arrow = "";
        if ((Visited_Links_As & 4U) == 0) {
          x = x + 1;
        }
        else {
          x = x + -1;
        }
        if (vl == PrevActiveVisitedLink) {
          if ((Visited_Links_As & 4U) == 0) {
            ret = x + 3;
          }
          else {
            ret = (iVar2 - x) + 2;
          }
        }
        if (vl == PrevActiveVisitedLink) {
          post_arrow = "<A NAME=current></A>";
          if ((vl->level == 0) || (((byte)Visited_Links_As & 1) != 1)) {
            local_48 = "=>";
          }
          else {
            local_48 = "==>";
          }
          arrow = local_48;
          local_78 = "#current";
          HTSACat(newfile,"#current");
        }
        if ((Visited_Links_As & 1U) == 0) {
          if (x < 100) {
            if (x < 10) {
              local_40 = 2;
            }
            else {
              local_40 = 1;
            }
            local_44 = local_40;
          }
          else {
            local_44 = 0;
          }
          offset = local_44;
        }
        else {
          offset = vl->level * 2;
          if (0x18 < offset) {
            offset = (offset + 0x18) / 2;
          }
          if ((int)(((uint)(LYcols * 3 >> 0x1f) >> 0x1e) + LYcols * 3) >> 2 < offset) {
            offset = (int)(((uint)(LYcols * 3 >> 0x1f) >> 0x1e) + LYcols * 3) >> 2;
          }
        }
        if ((vl->title == (char *)0x0) || (*vl->title == '\0')) {
          local_78 = (char *)gettext("(No title.)",local_78,local_74,local_3c);
          HTSACopy(&Title,local_78);
        }
        else {
          HTSACopy(&Title,vl->title);
          LYEntify(&Title,'\x01');
          LYTrimLeading(Title);
          LYTrimTrailing(Title);
          if (*Title == '\0') {
            local_78 = (char *)gettext("(No title.)");
            HTSACopy(&Title,local_78);
          }
        }
        local_68 = x;
        local_64 = x;
        if ((vl->address == (char *)0x0) || (*vl->address == '\0')) {
          local_60 = Title;
          fprintf((FILE *)fp0_00,"%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",offset,arrow,
                  post_arrow,x,x,Title);
        }
        else {
          HTSACopy(&Address,vl->address);
          LYEntify(&Address,'\0');
          local_60 = Address;
          fprintf((FILE *)fp0_00,"%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",offset,
                  arrow,post_arrow,x,x,Address,Title);
        }
        if (Address != (char *)0x0) {
          HTSACopy(&Address,vl->address);
          LYEntify(&Address,'\x01');
        }
        if (Address == (char *)0x0) {
          local_3c = (FILE *)gettext("(no address)");
        }
        else {
          local_3c = (FILE *)Address;
        }
        local_78 = "<tab to=t%d>%s\n";
        local_74 = x;
        fprintf((FILE *)fp0_00,"<tab to=t%d>%s\n",x,local_3c,post_arrow,local_68,local_64,local_60);
        if ((Visited_Links_As & 1U) == 0) {
          if ((Visited_Links_As & 2U) == 0) {
            if ((Visited_Links_As & 4U) == 0) {
              if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
                local_38 = (VisitedLink *)0x0;
              }
              else {
                local_38 = (VisitedLink *)cur->object;
              }
              vl = local_38;
            }
            else {
              vl = (VisitedLink *)vl->prev_first;
            }
          }
          else {
            if ((Visited_Links_As & 4U) == 0) {
              vl = (VisitedLink *)vl->next_latest;
            }
            else {
              vl = (VisitedLink *)vl->prev_latest;
            }
            if ((vl == &Latest_last) || (vl == &Latest_first)) {
              vl = (VisitedLink *)0x0;
            }
          }
        }
        else {
          vl = (VisitedLink *)vl->next_tree;
        }
      }
      fwrite("</pre>\n",1,7,(FILE *)fp0_00);
      EndInternalPage(fp0_00);
      LYCloseTempFP(fp0_00);
      if (Title != (char *)0x0) {
        free(Title);
        Title = (char *)0x0;
      }
      if (Address != (char *)0x0) {
        free(Address);
      }
      local_50 = ret;
    }
  }
  return local_50;
}



void to_stack(char *str)

{
  if (0x27 < topOfStack) {
    topOfStack = 0;
  }
  if (buffstack[topOfStack] != (char *)0x0) {
    free(buffstack[topOfStack]);
    buffstack[topOfStack] = (char *)0x0;
  }
  buffstack[topOfStack] = str;
  topOfStack = topOfStack + 1;
  if (0x27 < topOfStack) {
    topOfStack = 0;
  }
  return;
}



void LYstatusline_messages_on_exit(char **buf)

{
  int i;
  
  HTSACat(buf,"\n");
  i = topOfStack + -1;
  while (i = i + 1, i < 0x28) {
    if (buffstack[i] != (char *)0x0) {
      HTSACat(buf,buffstack[i]);
      HTSACat(buf,"\n");
    }
  }
  i = -1;
  while (i = i + 1, i < topOfStack) {
    if (buffstack[i] != (char *)0x0) {
      HTSACat(buf,buffstack[i]);
      HTSACat(buf,"\n");
    }
  }
  return;
}



void LYstore_message2(char *message,char *argument)

{
  char *local_18;
  char *temp;
  
  if (message != (char *)0x0) {
    temp = (char *)0x0;
    if (argument == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = argument;
    }
    HTSprintf0(&temp,message,local_18);
    to_stack(temp);
  }
  return;
}



void LYstore_message(char *message)

{
  char *temp;
  
  if (message != (char *)0x0) {
    temp = (char *)0x0;
    HTSACopy(&temp,message);
    to_stack(temp);
  }
  return;
}



int LYLoadMESSAGES(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar3;
  HTAtom *rep_in;
  HTStream *pHVar4;
  char *fmt;
  size_t sVar5;
  undefined4 uVar6;
  int local_30;
  char *temp;
  int i;
  int nummsg;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  
  rep_in = HTAtom_for("text/html");
  buf = (char *)0x0;
  nummsg = 0;
  temp = (char *)0x0;
  i = 0x28;
  while (i = i + -1, -1 < i) {
    if (buffstack[i] != (char *)0x0) {
      nummsg = nummsg + 1;
    }
  }
  pHVar4 = HTStreamStack((HTFormat)rep_in,format_out,sink,anAnchor);
  if ((pHVar4 == (HTStream *)0x0) || (pHVar4 == (HTStream *)0x0)) {
    pcVar1 = format_out->name;
    pcVar2 = rep_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf,fmt,pcVar2,pcVar1);
    HTAlert(buf);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_30 = -29999;
  }
  else {
    anAnchor->no_cache = '\x01';
    HTSprintf0(&buf,"<html>\n<head>\n");
    paVar3 = pHVar4->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(pHVar4,buf,sVar5);
    HTSprintf0(&buf,"<META %s content=\"text/html;charset=%s\">\n","http-equiv=\"content-type\"",
               LYCharSet_UC[current_char_set].MIMEname);
    paVar3 = pHVar4->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(pHVar4,buf,sVar5);
    uVar6 = gettext("Your recent statusline messages");
    HTSprintf0(&buf,"<title>%s</title>\n</head>\n<body>\n",uVar6);
    paVar3 = pHVar4->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(pHVar4,buf,sVar5);
    if (nummsg == 0) {
      uVar6 = gettext("(No messages yet)");
      HTSprintf0(&buf,"<p>%s\n</body>\n</html>\n",uVar6);
    }
    else {
      HTSprintf0(&buf,"<ol>\n");
      paVar3 = pHVar4->isa->put_block;
      sVar5 = strlen(buf);
      (*paVar3)(pHVar4,buf,sVar5);
      i = topOfStack;
      while (i = i + -1, -1 < i) {
        if (buffstack[i] != (char *)0x0) {
          HTSACopy(&temp,buffstack[i]);
          LYEntify(&temp,'\x01');
          HTSprintf0(&buf,"<li value=%d> <em>%s</em>\n",nummsg,temp);
          nummsg = nummsg + -1;
          paVar3 = pHVar4->isa->put_block;
          sVar5 = strlen(buf);
          (*paVar3)(pHVar4,buf,sVar5);
        }
      }
      i = 0x28;
      while (i = i + -1, topOfStack <= i) {
        if (buffstack[i] != (char *)0x0) {
          HTSACopy(&temp,buffstack[i]);
          LYEntify(&temp,'\x01');
          HTSprintf0(&buf,"<li value=%d> <em>%s</em>\n",nummsg,temp);
          nummsg = nummsg + -1;
          paVar3 = pHVar4->isa->put_block;
          sVar5 = strlen(buf);
          (*paVar3)(pHVar4,buf,sVar5);
        }
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      HTSprintf0(&buf,"</ol>\n</body>\n</html>\n");
    }
    paVar3 = pHVar4->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(pHVar4,buf,sVar5);
    (*pHVar4->isa->_free)(pHVar4);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_30 = 200;
  }
  return local_30;
}



char ** options_list(OptionType *opt_ptr)

{
  OptionType *tmp_ptr;
  int pass;
  size_t len;
  char **result;
  
  result = (char **)0x0;
  pass = 0;
  while (pass < 2) {
    tmp_ptr = opt_ptr;
    len = 0;
    while (tmp_ptr != (OptionType *)0x0) {
      if (pass != 0) {
        result[len] = tmp_ptr->name;
      }
      len = len + 1;
      tmp_ptr = (OptionType *)tmp_ptr->next;
    }
    if (pass == 0) {
      result = (char **)calloc(len + 1,4);
    }
    else {
      result[len] = (char *)0x0;
    }
    pass = pass + 1;
  }
  return result;
}



int change_form_link_ex(int cur,DocInfo *newdoc,BOOLEAN *refresh_screen,BOOLEAN use_last_tfpos,
                       BOOLEAN immediate_submit,BOOLEAN redraw_only)

{
  FormInfo *submit_item;
  char *link_value_00;
  char **choices;
  size_t len;
  int iVar1;
  char *link_name_00;
  int local_6c;
  int local_68;
  char *local_60;
  char *local_54;
  char *local_50;
  int i_1;
  int i;
  OptionType *opt_ptr;
  int dummy;
  char **my_data;
  int title_adjust;
  int OrigNumValue;
  int c;
  int newdoc_changed;
  char *link_value;
  char *link_name;
  FormInfo *form;
  
  submit_item = (FormInfo *)links[cur].l_form;
  link_name_00 = submit_item->name;
  link_value_00 = submit_item->value;
  newdoc_changed = 0;
  c = 0x10e;
  if (no_title == '\0') {
    local_6c = 0;
  }
  else {
    local_6c = -1;
  }
  if (submit_item == (FormInfo *)0x0) {
    local_68 = 0x10e;
  }
  else {
    choices = options_list(submit_item->select_list);
    LYmove(links[cur].ly + local_6c,links[cur].lx);
    switch(submit_item->type) {
    case 1:
    case 2:
    case 9:
    case 0xb:
      c = form_getstr(cur,use_last_tfpos,redraw_only);
      if (submit_item->type == 2) {
        iVar1 = LYstrCells(submit_item->value);
        if (iVar1 < 0x400) {
          iVar1 = LYstrCells(submit_item->value);
          local_50 = star_string + (0x3ff - iVar1);
        }
        else {
          local_50 = star_string;
        }
        local_54 = local_50;
      }
      else {
        local_54 = submit_item->value;
      }
      LYSetHilite(cur,local_54);
      break;
    case 3:
      if (submit_item->disabled != 1) {
        if (submit_item->num_value == 0) {
          local_60 = checked_box;
        }
        else {
          local_60 = unchecked_box;
        }
        LYSetHilite(cur,local_60);
        submit_item->num_value = (uint)(submit_item->num_value == 0);
      }
      break;
    case 4:
      if (submit_item->disabled != 1) {
        if (submit_item->num_value == 0) {
          lynx_start_radio_color();
          i_1 = 0;
          while (i_1 < nlinks) {
            if ((((links[i_1].type == 1) && ((links[i_1].l_form)->type == 4)) &&
                ((links[i_1].l_form)->number == submit_item->number)) &&
               ((iVar1 = strcmp((links[i_1].l_form)->name,submit_item->name), iVar1 == 0 &&
                ((links[i_1].l_form)->num_value != 0)))) {
              LYmove(links[i_1].ly,links[i_1].lx);
              len = strlen(unchecked_radio);
              LYwaddnstr(LYwin,unchecked_radio,len);
              LYSetHilite(i_1,unchecked_radio);
            }
            i_1 = i_1 + 1;
          }
          lynx_stop_radio_color();
          HText_activateRadioButton(submit_item);
          LYSetHilite(cur,checked_radio);
        }
        else {
          if (user_mode == 0) {
            link_name_00 = (char *)gettext("One radio button must be checked at all times!");
            HTUserMsg(link_name_00);
          }
        }
      }
      break;
    case 5:
    case 0xd:
      if (submit_item->disabled != 1) {
        if ((submit_item->no_cache != '\0') && (submit_item->submit_method != 3)) {
          LYforce_no_cache = '\x01';
          reloading = '\x01';
        }
        newdoc_changed = HText_SubmitForm(submit_item,newdoc,link_name_00,link_value_00);
        if (submit_item->submit_method == 3) {
          *refresh_screen = '\x01';
        }
        else {
          newdoc->link = 0;
          newdoc->internal_link = '\0';
        }
      }
      break;
    case 6:
      if (submit_item->disabled != 1) {
        HText_ResetForm(submit_item);
        *refresh_screen = '\x01';
      }
      break;
    case 7:
      if (submit_item->select_list == (OptionType *)0x0) {
        link_name_00 = (char *)gettext("Bad HTML!!  Unable to create popup window!");
        HTAlert(link_name_00);
        c = 0x10e;
      }
      else {
        if (submit_item->disabled == 1) {
          LYhandlePopupList(submit_item->num_value,links[cur].ly,links[cur].lx,choices,
                            submit_item->size,submit_item->size_l,submit_item->disabled,'\0');
          if (enable_scrollback == '\0') {
            c = 0x17;
          }
          else {
            c = 0xc;
          }
        }
        else {
          iVar1 = LYhandlePopupList(submit_item->num_value,links[cur].ly,links[cur].lx,choices,
                                    submit_item->size,submit_item->size_l,submit_item->disabled,'\0'
                                   );
          submit_item->num_value = iVar1;
          opt_ptr = submit_item->select_list;
          i = 0;
          while (i < submit_item->num_value) {
            i = i + 1;
            opt_ptr = (OptionType *)opt_ptr->next;
          }
          submit_item->value = opt_ptr->name;
          submit_item->cp_submit_value = opt_ptr->cp_submit_value;
          submit_item->value_cs = opt_ptr->value_cs;
          if (enable_scrollback == '\0') {
            c = 0x17;
          }
          else {
            c = 0xc;
          }
        }
      }
      break;
    case 0xc:
      if (redraw_only == '\0') {
        if (immediate_submit == '\0') {
          c = form_getstr(cur,use_last_tfpos,'\0');
        }
        if ((submit_item->disabled == 1) &&
           (((c == 0xd || (c == 10)) || (immediate_submit != '\0')))) {
          iVar1 = peek_mouse_link();
          if (iVar1 < 0) {
            c = 9;
          }
          else {
            c = 0x827;
          }
        }
        else {
          if ((immediate_submit == '\0') &&
             ((((c != 0xd && (c != 10)) && (c != 0x828)) || (iVar1 = peek_mouse_link(), iVar1 != -1)
              ))) {
            LYSetHilite(cur,submit_item->value);
          }
          else {
            LYSetHilite(cur,submit_item->value);
            if ((submit_item->submit_action == (char *)0x0) || (*submit_item->submit_action == '\0')
               ) {
              link_name_00 = (char *)gettext("** Bad HTML!!  No form action defined. **");
              HTUserMsg(link_name_00);
              c = 0x10e;
            }
            else {
              if ((submit_item->submit_method == 3) && (no_mail != '\0')) {
                link_name_00 = (char *)gettext("Mail disallowed!  Cannot submit.");
                HTAlert(link_name_00);
                c = 0x10e;
              }
              else {
                if ((immediate_submit == '\0') &&
                   (((no_file_url != '\0' &&
                     (((*submit_item->submit_action == 'f' || (*submit_item->submit_action == 'F'))
                      && (iVar1 = strncasecomp(submit_item->submit_action,"file:",5), iVar1 == 0))))
                    || (iVar1 = strncasecomp(submit_item->submit_action,"lynx",4), iVar1 == 0)))) {
                  c = 0x828;
                }
                else {
                  if ((submit_item->no_cache != '\0') && (submit_item->submit_method != 3)) {
                    LYforce_no_cache = '\x01';
                    reloading = '\x01';
                  }
                  newdoc_changed =
                       HText_SubmitForm(submit_item,newdoc,link_name_00,submit_item->value);
                  if (submit_item->submit_method == 3) {
                    *refresh_screen = '\x01';
                  }
                  else {
                    newdoc->link = 0;
                    newdoc->internal_link = '\0';
                  }
                  c = 0x10e;
                }
              }
            }
          }
        }
      }
      else {
        c = form_getstr(cur,use_last_tfpos,'\x01');
      }
    }
    if (newdoc_changed == 0) {
      LYforce_no_cache = '\0';
      reloading = '\0';
    }
    else {
      c = 0x7fe;
    }
    if (choices != (char **)0x0) {
      free(choices);
    }
    local_68 = c;
  }
  return local_68;
}



int change_form_link(int cur,DocInfo *newdoc,BOOLEAN *refresh_screen,BOOLEAN use_last_tfpos,
                    BOOLEAN immediate_submit)

{
  int iVar1;
  
  iVar1 = change_form_link_ex(cur,newdoc,refresh_screen,use_last_tfpos,immediate_submit,'\0');
  return iVar1;
}



void LYSetLastTFPos(int pos)

{
  LastTFPos = pos;
  return;
}



int form_getstr(int cur,BOOLEAN use_last_tfpos,BOOLEAN redraw_only)

{
  int iVar1;
  FormInfo *form_00;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  size_t sVar5;
  char *Msg;
  int iVar6;
  uchar *puVar7;
  size_t sVar8;
  int in_GS_OFFSET;
  bool bVar9;
  byte local_44e0;
  int local_44dc;
  int local_44d8;
  uint local_44d4;
  int local_44d0;
  int local_44cc;
  int local_44c8;
  int local_44c4;
  int local_44bc;
  int local_44b4;
  MEVENT event;
  int new_len;
  int old_len;
  int rc;
  int c;
  uchar *e1;
  int len;
  char *buf;
  uchar *e;
  uchar *s;
  int cury;
  int curx;
  int last_xlkc;
  int repeat;
  int action;
  int startline;
  int startcol;
  int max_length;
  int far_col;
  int ch;
  char *value;
  FormInfo *form;
  BOOLEAN Edited;
  BOOLEAN refresh_mb;
  BOOLEAN HaveMaxlength;
  EditFieldData MyEdit;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  form_00 = (FormInfo *)links[cur].l_form;
  value = form_00->value;
  bVar3 = false;
  last_xlkc = -1;
  bVar2 = true;
  bVar4 = false;
  if (LYwin == (WINDOW *)0x0) {
    local_44dc = -1;
    local_44d8 = -1;
  }
  else {
    local_44dc = (int)LYwin->_cury;
    local_44d8 = (int)LYwin->_curx;
  }
  if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < form_00->size + local_44d8) {
    far_col = LYcols - (uint)(LYShowScrollbar != '\0');
  }
  else {
    far_col = form_00->size + local_44d8;
  }
  if ((form_00->maxlength == 0) || (0x3ff < form_00->maxlength)) {
    local_44d4 = 0x3ff;
  }
  else {
    local_44d4 = form_00->maxlength;
  }
  sVar5 = strlen(form_00->value);
  if (local_44d4 < sVar5) {
    sVar5 = strlen(form_00->value);
    value = value + (sVar5 - local_44d4);
    if ((form_00->disabled == 0) && ((form_00->submit_method != 3 || (no_mail == '\0')))) {
      Msg = (char *)gettext("Form field value exceeds buffer length!  Trim the tail.");
      HTUserMsg(Msg);
      if (redraw_only == '\0') {
        local_44d0 = 2;
      }
      else {
        local_44d0 = 0;
      }
      show_formlink_statusline(form_00,local_44d0);
      LYmove(local_44dc,local_44d8);
    }
  }
  LYSetupEdit(&MyEdit,value,local_44d4,far_col - local_44d8);
  MyEdit.pad = '_';
  MyEdit.hidden = form_00->type == 2;
  if ((((use_last_tfpos != '\0') && (-1 < LastTFPos)) && (LastTFPos < MyEdit.strlen)) &&
     (MyEdit.pos = LastTFPos, LastTFPos == 0)) {
    MyEdit.mark = ~MyEdit.strlen;
  }
  iVar6 = peek_mouse_levent();
  if ((iVar6 != 0) && (use_last_tfpos == '\0')) {
    MyEdit.pos = 0;
  }
  LYRefreshEdit(&MyEdit);
  if (redraw_only == '\0') {
again:
    repeat = -1;
    get_mouse_link();
    ch = LYgetch_input();
    if ((!bVar2) && (iVar6 = EditBinding(ch), iVar6 != 1)) goto code_r0x080ae1a1;
    goto LAB_080ae1b4;
  }
  local_44cc = 0;
LAB_080aecb1:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_44cc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x080ae1a1:
  iVar6 = EditBinding(ch);
  if (iVar6 != 0x18) goto again;
LAB_080ae1b4:
  action = 0;
  if (((ch != 0xffffffff) && ((ch & 0x800U) != 0)) && ((ch & 0x8000U) == 0)) goto breakfor;
  if (ch == 0x11d) {
    getmouse(&event);
    if (LYwin == (WINDOW *)0x0) {
      local_44c8 = -1;
      local_44c4 = -1;
    }
    else {
      local_44c8 = (int)LYwin->_cury;
      local_44c4 = (int)LYwin->_curx;
    }
    if (event.y == local_44c8) {
      repeat = event.x - local_44c4;
      if (repeat < 0) {
        action = 0x11;
        repeat = -repeat;
      }
      else {
        action = 0xf;
      }
    }
    else {
      MyEdit.dirty = '\x01';
    }
  }
  else {
    if ((ch & 0x8000U) == 0) {
      ch = ch | MyEdit.current_modifiers;
    }
    MyEdit.current_modifiers = 0;
    if ((last_xlkc != -1) && (ch == last_xlkc)) {
      ch = ch | 0x1000;
    }
  }
  iVar6 = peek_mouse_link();
  if (iVar6 != -1) goto breakfor;
  if (action == 0) {
    action = EditBinding(ch);
  }
  if (((action & 0x80U) == 0) || ((action & 0x1000U) != 0)) {
    last_xlkc = -1;
  }
  else {
    last_xlkc = ch;
    action = action & 0xffffff7f;
  }
  if (action == 0x1d) {
    MyEdit.current_modifiers = MyEdit.current_modifiers | 0x4000;
    goto again;
  }
  if (action == 0x1e) {
    MyEdit.current_modifiers = MyEdit.current_modifiers | 0x2000;
    goto again;
  }
  if ((action == 2) || (action == 6)) goto breakfor;
  if ((action & 0x1000U) != 0) {
    ch = ZEXT24(CONCAT11(8,(char)action));
    goto breakfor;
  }
  if (action == 0x17) {
    mustshow = '\x01';
    Msg = (char *)gettext("Enter Lynx keystroke command: ");
    statusline(Msg);
    ch = LYgetch();
    goto breakfor;
  }
  if (action == 0x25) {
    e1 = (uchar *)get_clip_grab();
    buf = (char *)0x0;
    if (e1 == (uchar *)0x0) goto breakfor;
    sVar5 = strlen((char *)e1);
    puVar7 = e1 + sVar5;
    s = e1;
    if ((int)sVar5 < 1) {
      Msg = (char *)gettext("Clipboard empty or Not text data.");
      HTInfoMsg(Msg);
      goto again;
    }
    while (e1 < puVar7) {
      if (*e1 < 0x20) {
        if (s < e1) {
          LYEditInsert(&MyEdit,s,(int)(e1 + -(int)s),-1,'\x01');
        }
        s = e1;
        if (*e1 != '\t') break;
        LYEditInsert(&MyEdit," ",1,-1,'\x01');
        e1 = e1 + 1;
        s = e1;
      }
      else {
        e1 = e1 + 1;
      }
    }
    if (s < e1) {
      LYEditInsert(&MyEdit,s,(int)(e1 + -(int)s),-1,'\x01');
    }
    while ((e1 < puVar7 && (*e1 == '\r'))) {
      e1 = e1 + 1;
    }
    if ((e1 + 1 < puVar7) && (*e1 == '\n')) {
      HTSACopy(&buf,(char *)(e1 + 1));
    }
    get_clip_release();
    if (MyEdit.strlen < (int)local_44d4) {
      if ((bVar3) && (MyEdit.strlen < (int)local_44d4)) {
        bVar3 = false;
        mustshow = '\x01';
        Msg = (char *)gettext("Enter text.  Use arrows or tab to move off of field.");
        statusline(Msg);
      }
    }
    else {
      bVar3 = true;
    }
    iVar6 = strcmp(value,MyEdit.buffer);
    if (iVar6 != 0) {
      bVar4 = true;
    }
    if (buf != (char *)0x0) {
      put_clip(buf);
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      ch = 10;
breakfor:
      if (bVar4) {
        if (form_00->value == value) {
          HTSACopy(&form_00->value,MyEdit.buffer);
        }
        else {
          sVar5 = strlen(form_00->value);
          sVar8 = strlen(value);
          if ((int)sVar8 < (int)sVar5) {
            local_44b4 = sVar5 - sVar8;
          }
          else {
            local_44b4 = 0;
          }
          form_00->value[local_44b4] = '\0';
          HTSACat(&form_00->value,MyEdit.buffer);
          Msg = (char *)gettext("Modified tail combined with head of form field value.");
          HTUserMsg(Msg);
        }
        if (LYtrimInputFields != '\0') {
          LYTrimTrailing(form_00->value);
        }
        if ((form_00->value != (char *)0x0) && (*form_00->value != '\0')) {
          form_00->value_cs = current_char_set;
        }
      }
      local_44cc = ch;
      goto LAB_080aecb1;
    }
    LYRefreshEdit(&MyEdit);
  }
  if (((action == 0x18) && (HTCJK == NOCJK)) && (0x97 < LYlowest_eightbit[current_char_set]))
  goto breakfor;
  if (action == 3) {
    ch = 9;
    goto breakfor;
  }
  if (action == 5) {
    local_44cc = 0x10e;
    goto LAB_080aecb1;
  }
  if (action == 4) {
    textfields_need_activation = '\x01';
    goto breakfor;
  }
  if (action == 0) {
    if (ch == -1) {
      bVar9 = keymap[0] == 0x15;
    }
    else {
      if ((ch & 0x8800U) == 0) {
        bVar9 = keymap[(ch & 0x7ffU) + 1] == 0x15;
      }
      else {
        bVar9 = (ch & 0xffU) == 0x15;
      }
    }
    if (bVar9) goto breakfor;
  }
  if (((action == 0x11) && (MyEdit.pos == 0)) && (repeat == -1)) {
    c = 1;
    if (textfield_prompt_at_left_edge == '\0') {
      iVar6 = strcmp(MyEdit.buffer,value);
      if (iVar6 != 0) {
        Msg = (char *)gettext("Do you want to go back to the previous document?");
        c = HTConfirmDefault(Msg,0);
      }
    }
    else {
      Msg = (char *)gettext("Do you want to go back to the previous document?");
      c = HTConfirmDefault(Msg,0);
    }
    if (c == 1) {
      local_44cc = ch;
      goto LAB_080aecb1;
    }
    if (form_00->disabled == 1) {
      mustshow = '\x01';
      Msg = (char *)gettext("Use arrows or tab to move off of field.");
      statusline(Msg);
    }
    else {
      mustshow = '\x01';
      Msg = (char *)gettext("Enter text.  Use arrows or tab to move off of field.");
      statusline(Msg);
    }
  }
  if ((form_00->disabled != 1) ||
     ((action - 0xdU < 0x16 &&
      (local_44e0 = (byte)(action - 0xdU), (1 << (local_44e0 & 0x1f) & 0x3000ffU) != 0)))) {
    if (repeat < 0) {
      repeat = 1;
    }
    while (bVar9 = repeat != 0, repeat = repeat + -1, bVar9) {
      iVar6 = LYEdit1(&MyEdit,ch,action & 0xffffff7f,'\x01');
      if (iVar6 < 0) {
        ch = -iVar6;
        if ((action != 0x12) && (action != 0x10)) goto breakfor;
        if ((-1 < cur) && (cur < nlinks)) {
          if (action == 0x10) {
            if (cur < nlinks + -1) {
LAB_080ae9f2:
              if (action == 0x10) {
                local_44bc = 1;
              }
              else {
                local_44bc = -1;
              }
              if (links[local_44bc + cur].ly == links[cur].ly) goto breakfor;
            }
          }
          else {
            if (0 < cur) goto LAB_080ae9f2;
          }
        }
      }
      if (iVar6 == 0) {
        if ((((HTCJK == NOCJK) || (ch < 0x80)) || (0xfe < ch)) || (!bVar2)) {
          bVar2 = true;
        }
        else {
          bVar2 = false;
        }
      }
      else {
        if (!bVar2) {
          LYEdit1(&MyEdit,0,9,'\x01');
        }
      }
    }
    if (MyEdit.strlen < (int)local_44d4) {
      if ((bVar3) && (MyEdit.strlen < (int)local_44d4)) {
        bVar3 = false;
        mustshow = '\x01';
        Msg = (char *)gettext("Enter text.  Use arrows or tab to move off of field.");
        statusline(Msg);
      }
    }
    else {
      bVar3 = true;
    }
    iVar6 = strcmp(value,MyEdit.buffer);
    if (iVar6 != 0) {
      bVar4 = true;
    }
    if (bVar2) {
      LYRefreshEdit(&MyEdit);
    }
    LYSetLastTFPos(MyEdit.pos);
  }
  goto again;
}



void show_formlink_statusline(FormInfo *form,int for_what)

{
  char *text;
  char *text_00;
  char *xkey_info_1;
  char *submit_str;
  char *xkey_info;
  
  switch(form->type) {
  case 1:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE form text field.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      if (for_what == 0) {
        text = (char *)gettext("(Text entry field) Inactive.  Press <return> to activate.");
        statusline(text);
      }
      else {
        text = (char *)gettext(
                              "(Text entry field) Enter text.  Use UP or DOWN arrows or tab to move off."
                              );
        statusline(text);
      }
    }
    break;
  case 2:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE form password.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      if (for_what == 0) {
        text = (char *)gettext("(Password entry field) Inactive.  Press <return> to activate.");
        statusline(text);
      }
      else {
        text = (char *)gettext(
                              "(Password entry field) Enter text.  Use UP or DOWN arrows or tab to move off."
                              );
        statusline(text);
      }
    }
    break;
  case 3:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE form checkbox.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      text = (char *)gettext("(Checkbox Field)   Use right-arrow or <return> to toggle.");
      statusline(text);
    }
    break;
  case 4:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE form radio button.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      text = (char *)gettext("(Radio Button)   Use right-arrow or <return> to toggle.");
      statusline(text);
    }
    break;
  case 5:
  case 0xd:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "DISABLED form submit button.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      if (form->submit_method == 3) {
        if (no_mail == '\0') {
          if (user_mode == 2) {
            submit_str = (char *)0x0;
            text = (char *)gettext("Submit mailto form to ");
            HTSACopy(&submit_str,text);
            HTSACat(&submit_str,form->submit_action);
            statusline(submit_str);
            if (submit_str != (char *)0x0) {
              free(submit_str);
            }
          }
          else {
            text = (char *)gettext(
                                  "(mailto form submit button) Use right-arrow or <return> to submit."
                                  );
            statusline(text);
          }
        }
        else {
          text = (char *)gettext(
                                "(mailto form submit button) Mail is disallowed so you cannot submit."
                                );
          statusline(text);
        }
      }
      else {
        if (form->no_cache == '\0') {
          if (user_mode == 2) {
            submit_str = (char *)0x0;
            text = (char *)gettext("Submit (\'x\' for no cache) to ");
            HTSACopy(&submit_str,text);
            HTSACat(&submit_str,form->submit_action);
            statusline(submit_str);
            if (submit_str != (char *)0x0) {
              free(submit_str);
            }
          }
          else {
            text = (char *)gettext(
                                  "(Form submit button) Use right-arrow or <return> to submit (\'x\' for no cache)."
                                  );
            statusline(text);
          }
        }
        else {
          if (user_mode == 2) {
            submit_str = (char *)0x0;
            text = (char *)gettext("Submit to ");
            HTSACopy(&submit_str,text);
            HTSACat(&submit_str,form->submit_action);
            statusline(submit_str);
            if (submit_str != (char *)0x0) {
              free(submit_str);
            }
          }
          else {
            text = (char *)gettext("(Form submit button) Use right-arrow or <return> to submit.");
            statusline(text);
          }
        }
      }
    }
    break;
  case 6:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "DISABLED form reset button.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      text = (char *)gettext(
                            "(Form reset button)   Use right-arrow or <return> to reset form to defaults."
                            );
      statusline(text);
    }
    break;
  case 7:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE option list.  Use return or arrow keys to review or leave."
                            );
      statusline(text);
    }
    else {
      text = (char *)gettext(
                            "(Option list) Hit return and use arrow keys and return to select option."
                            );
      statusline(text);
    }
    break;
  case 9:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE form text field.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      submit_str = (char *)0x0;
      xkey_info_1 = (char *)0x0;
      if ((((no_editor == '\0') && (editor != (char *)0x0)) && (editor != (char *)0x0)) &&
         (xkey_info_1 = key_for_func_ext(0x56,for_what), xkey_info_1 == (char *)0x0)) {
        xkey_info_1 = key_for_func_ext(0x55,for_what);
      }
      if ((xkey_info_1 == (char *)0x0) || (*xkey_info_1 == '\0')) {
        if (for_what == 0) {
          text = (char *)gettext("(Textarea) Inactive.  Press <return> to activate.");
          statusline(text);
        }
        else {
          text = (char *)gettext("(Textarea) Enter text. Use UP/DOWN arrows or TAB to move off.");
          statusline(text);
        }
      }
      else {
        if (for_what == 0) {
          text = (char *)gettext("(Textarea) Inactive.  Press <return> to activate (%s for editor)."
                                );
          HTSprintf0(&submit_str,text,xkey_info_1);
        }
        else {
          text = (char *)gettext(
                                "(Textarea) Enter text. Use UP/DOWN arrows or TAB to move off (%s for editor)."
                                );
          HTSprintf0(&submit_str,text,xkey_info_1);
        }
        statusline(submit_str);
        if (submit_str != (char *)0x0) {
          free(submit_str);
          submit_str = (char *)0x0;
        }
      }
      if (xkey_info_1 != (char *)0x0) {
        free(xkey_info_1);
      }
    }
    break;
  case 0xb:
    if (form->disabled == 1) {
      text = (char *)gettext(
                            "UNMODIFIABLE file entry field.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    else {
      text = (char *)gettext(
                            "(File entry field) Enter filename.  Use UP or DOWN arrows or tab to move off."
                            );
      statusline(text);
    }
    break;
  case 0xc:
    if (form->disabled == 1) {
      text = (char *)gettext("UNMODIFIABLE form field.  Use UP or DOWN arrows or tab to move off.");
      statusline(text);
    }
    else {
      if (form->submit_method == 3) {
        if (no_mail == '\0') {
          if (for_what == 0) {
            text = (char *)gettext("(mailto form field) Inactive.  Press <return> to change.");
            statusline(text);
          }
          else {
            text = (char *)gettext(
                                  "(mailto form field) Enter text.  Use <return> to submit, arrows to move off."
                                  );
            statusline(text);
          }
        }
        else {
          text = (char *)gettext("(mailto form field) Mail is disallowed so you cannot submit.");
          statusline(text);
        }
      }
      else {
        if (form->no_cache == '\0') {
          submit_str = (char *)0x0;
          text = key_for_func_ext(0x2e,for_what);
          if ((text == (char *)0x0) || (*text == '\0')) {
            if (for_what == 0) {
              text_00 = (char *)gettext("(Form field) Inactive.  Use <return> to edit.");
              statusline(text_00);
            }
            else {
              text_00 = (char *)gettext("(Form field) Enter text.  Use <return> to submit.");
              statusline(text_00);
            }
          }
          else {
            if (for_what == 0) {
              text_00 = (char *)gettext(
                                       "(Form field) Inactive.  Use <return> to edit (%s to submit with no cache)."
                                       );
              HTSprintf0(&submit_str,text_00,text);
            }
            else {
              text_00 = (char *)gettext(
                                       "(Form field) Enter text.  Use <return> to submit (%s for no cache)."
                                       );
              HTSprintf0(&submit_str,text_00,text);
            }
            statusline(submit_str);
            if (submit_str != (char *)0x0) {
              free(submit_str);
              submit_str = (char *)0x0;
            }
          }
          if (text != (char *)0x0) {
            free(text);
          }
        }
        else {
          if (for_what == 0) {
            text = (char *)gettext(
                                  "(Form field) Inactive. Press <return> to edit, press <return> twice to submit."
                                  );
            statusline(text);
          }
          else {
            text = (char *)gettext(
                                  "(Form field) Enter text.  Use <return> to submit, arrows or tab to move off."
                                  );
            statusline(text);
          }
        }
      }
    }
  }
  return;
}



void set_environ(int name,char *value,char *no_value)

{
  char *names [4];
  char *pointers [4];
  char *local_18;
  char *envbuffer;
  
  envbuffer = (char *)0x0;
  HTSACopy(&envbuffer,((char **)&ram0x081972a0)[name]);
  HTSACat(&envbuffer,"=");
  if (value == (char *)0x0) {
    local_18 = no_value;
  }
  else {
    local_18 = value;
  }
  HTSACat(&envbuffer,local_18);
  putenv(envbuffer);
  if (((char **)&ram0x081afda0)[name] != (char *)0x0) {
    free(*(void **)(name * 4 + 0x81afda0));
    *(undefined4 *)(name * 4 + 0x81afda0) = 0;
  }
  *(char **)(name * 4 + 0x81afda0) = envbuffer;
  return;
}



char * suggested_filename(DocInfo *newdoc)

{
  char *src;
  CompressFileType CVar1;
  FILE *__stream;
  int rootlen;
  char *sug_filename;
  
  sug_filename = (char *)0x0;
  src = HText_getSugFname();
  if (src == (char *)0x0) {
    HTSACopy(&sug_filename,newdoc->address);
  }
  else {
    src = HText_getSugFname();
    HTSACopy(&sug_filename,src);
  }
  CVar1 = HTCompressFileType(sug_filename,".",&rootlen);
  src = sug_filename;
  if (CVar1 != cftNone) {
    sug_filename[rootlen] = '\0';
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"suggest %s\n",src);
  }
  return sug_filename;
}



void SetupFilename(char *filename,char *sug_filename)

{
  char *pcVar1;
  int iVar2;
  char *__dest;
  HTFormat pHVar3;
  FILE *__stream;
  HTAtom *pHVar4;
  char *cp;
  HTAtom *encoding;
  HTFormat format;
  
  LYstrncpy(filename,sug_filename,0xff);
  change_sug_filename(filename);
  iVar2 = HTisDocumentSource();
  if (iVar2 == 0) {
    __dest = strrchr(filename,0x2e);
    if ((__dest != (char *)0x0) && ((int)(__dest + -(int)filename) < 0xfa)) {
      pHVar3 = HTFileFormat(filename,&encoding,(char **)0x0);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = pHVar3->name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"... format %s\n",pcVar1);
      }
      iVar2 = strcasecomp(pHVar3->name,"text/html");
      if (iVar2 != 0) {
        if (encoding == (HTAtom *)0x0) goto LAB_080af672;
        pHVar4 = HTAtom_for("identity");
        if (pHVar4 == encoding) goto LAB_080af672;
        pHVar4 = HTAtom_for("8bit");
        if (pHVar4 == encoding) goto LAB_080af672;
        pHVar4 = HTAtom_for("binary");
        if (pHVar4 == encoding) goto LAB_080af672;
        pHVar4 = HTAtom_for("7bit");
        if (pHVar4 == encoding) goto LAB_080af672;
      }
      memcpy(__dest,&DAT_0815f2de,5);
    }
  }
LAB_080af672:
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"... result %s\n",filename);
  }
  return;
}



int RecallFilename(char *filename,BOOLEAN *first,int *now,int *total,int flag)

{
  bool bVar1;
  int iVar2;
  char *src;
  int local_1c;
  RecallType recall;
  char *cp;
  int ch;
  
  if (*now < 0) {
    if (sug_filenames == (HTList *)0x0) {
      local_1c = 0;
    }
    else {
      local_1c = HTList_count(sug_filenames);
    }
    *total = local_1c;
    *now = *total;
  }
  bVar1 = 0 < *total;
  iVar2 = LYgetstr(filename,0,0x100,(uint)bVar1);
  if ((((-1 < iVar2) && (*filename != '\0')) && (iVar2 != 0x100)) && (iVar2 != 0x101)) {
    return 2;
  }
  if ((bVar1) && (iVar2 == 0x100)) {
    if (*first == '\0') {
      *now = *now + 1;
    }
    else {
      *first = '\0';
      *now = 0;
    }
    if (*total <= *now) {
      *first = '\x01';
      *now = *total;
      mustshow = '\x01';
      src = (char *)gettext("Enter a filename: ");
      statusline(src);
      return 0;
    }
    src = (char *)HTList_objectAt(sug_filenames,*now);
    if (src != (char *)0x0) {
      LYstrncpy(filename,src,0xff);
      if (*total == 1) {
        mustshow = '\x01';
        src = (char *)gettext("Edit the previous filename: ");
        statusline(src);
      }
      else {
        mustshow = '\x01';
        src = (char *)gettext("Edit a previous filename: ");
        statusline(src);
      }
      return 1;
    }
  }
  else {
    if ((bVar1) && (iVar2 == 0x101)) {
      if (*first == '\0') {
        *now = *now + -1;
      }
      else {
        *first = '\0';
        *now = *total + -1;
      }
      if (*now < 0) {
        *first = '\x01';
        *now = *total;
        mustshow = '\x01';
        src = (char *)gettext("Enter a filename: ");
        statusline(src);
        return 0;
      }
      src = (char *)HTList_objectAt(sug_filenames,*now);
      if (src != (char *)0x0) {
        LYstrncpy(filename,src,0xff);
        if (*total == 1) {
          mustshow = '\x01';
          src = (char *)gettext("Edit the previous filename: ");
          statusline(src);
        }
        else {
          mustshow = '\x01';
          src = (char *)gettext("Edit a previous filename: ");
          statusline(src);
        }
        return 1;
      }
    }
  }
  if (flag == 0) {
    src = (char *)gettext("Save request cancelled!!!");
    HTInfoMsg(src);
  }
  else {
    if (flag == 1) {
      return 3;
    }
  }
  return 3;
}



BOOLEAN confirm_by_pages(char *prompt,int lines_in_file,int lines_per_page)

{
  int iVar1;
  char *Msg;
  char *msg;
  int c;
  int pages;
  
  pages = lines_in_file / (lines_per_page + 1);
  if (0 < lines_in_file % (LYlines + 1)) {
    pages = pages + 1;
  }
  if (4 < pages) {
    msg = (char *)0x0;
    HTSprintf0(&msg,prompt,pages);
    iVar1 = HTConfirmDefault(msg,1);
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
    if (iVar1 != 1) {
      Msg = (char *)gettext("Print request cancelled!!!");
      HTInfoMsg(Msg);
      return '\0';
    }
    LYwaddnstr(LYwin,"   Ok...",8);
  }
  return '\x01';
}



void send_file_to_file(DocInfo *newdoc,char *content_base,char *sug_filename)

{
  int iVar1;
  BOOLEAN BVar2;
  size_t sVar3;
  size_t sVar4;
  int iVar5;
  FILE *__stream;
  int *piVar6;
  ushort **ppuVar7;
  char *text;
  char *__s1;
  int in_GS_OFFSET;
  bool bVar8;
  FILE *local_23c;
  int c;
  int FnameTotal;
  int FnameNum;
  FILE *outfile_fp;
  char *disp_charset;
  BOOLEAN use_cte;
  BOOLEAN FirstRecall;
  char filename [256];
  char buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FirstRecall = '\x01';
  FnameNum = -1;
  mustshow = '\x01';
  text = (char *)gettext("Enter a filename: ");
  statusline(text);
retry:
  while( true ) {
    do {
      SetupFilename(filename,sug_filename);
      if (lynx_save_space != (char *)0x0) {
        sVar3 = strlen(lynx_save_space);
        sVar4 = strlen(filename);
        if (sVar3 + sVar4 < 0x100) {
          strcpy(buffer,lynx_save_space);
          strcat(buffer,filename);
          strcpy(filename,buffer);
        }
      }
      do {
        iVar5 = RecallFilename(filename,&FirstRecall,&FnameNum,&FnameTotal,0);
      } while (iVar5 == 1);
      if (iVar5 == 3) goto done;
    } while (iVar5 == 0);
    BVar2 = LYValidateFilename(buffer,filename);
    if (BVar2 == '\0') {
      text = (char *)gettext("Save request cancelled!!!");
      HTInfoMsg(text);
      goto done;
    }
    iVar5 = LYValidateOutput(buffer);
    if (iVar5 != 0x4e) break;
    mustshow = '\x01';
    text = (char *)gettext("Enter a new filename: ");
    statusline(text);
    FirstRecall = '\x01';
    FnameNum = FnameTotal;
  }
  if (iVar5 != 0x59) goto done;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYPrint: filename is %s, action is `%c\'\n",buffer,0);
  }
  if (buffer[0] == '|') {
    if (no_shell != '\0') {
      text = (char *)gettext("Spawning is currently disabled.");
      HTUserMsg(text);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
      goto retry;
    }
    outfile_fp = (FILE *)popen(buffer + 1,"w");
    if (outfile_fp == (FILE *)0x0) {
      if (WWW_TraceFlag != '\0') {
        piVar6 = __errno_location();
        iVar5 = *piVar6;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYPrint: errno is %d\n",iVar5);
      }
      text = (char *)gettext("Cannot write to file.");
      HTAlert(text);
      mustshow = '\x01';
      text = (char *)gettext("Enter a new filename: ");
      statusline(text);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
      goto retry;
    }
  }
  else {
    ppuVar7 = __ctype_b_loc();
    if ((**ppuVar7 & 0x200) == 0) {
      bVar8 = false;
    }
    else {
      iVar5 = toupper(0);
      bVar8 = iVar5 == 0x41;
    }
    if (bVar8) {
      local_23c = LYAppendToTxtFile(buffer);
    }
    else {
      local_23c = LYNewTxtFile(buffer);
    }
    outfile_fp = local_23c;
    if (local_23c == (FILE *)0x0) {
      if (WWW_TraceFlag != '\0') {
        piVar6 = __errno_location();
        iVar5 = *piVar6;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYPrint: errno is %d\n",iVar5);
      }
      text = (char *)gettext("Cannot write to file.");
      HTAlert(text);
      mustshow = '\x01';
      text = (char *)gettext("Enter a new filename: ");
      statusline(text);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
      goto retry;
    }
  }
  if (LYPrependBaseToSource != '\0') {
    iVar5 = HTisDocumentSource();
    if (iVar5 != 0) {
      fprintf((FILE *)outfile_fp,"<!-- X-URL: %s -->\n",newdoc->address);
      text = HText_getDate();
      if (text != (char *)0x0) {
        text = HText_getDate();
        fprintf((FILE *)outfile_fp,"<!-- Date: %s -->\n",text);
        text = HText_getLastModified();
        if (text != (char *)0x0) {
          text = HText_getDate();
          __s1 = HText_getLastModified();
          iVar5 = strcmp(__s1,text);
          if (iVar5 != 0) {
            text = HText_getLastModified();
            iVar5 = strcmp(text,"Thu, 01 Jan 1970 00:00:01 GMT");
            if (iVar5 != 0) {
              text = HText_getLastModified();
              fprintf((FILE *)outfile_fp,"<!-- Last-Modified: %s -->\n",text);
            }
          }
        }
      }
      fprintf((FILE *)outfile_fp,"<BASE HREF=\"%s\">\n",content_base);
    }
  }
  if (LYPrependCharsetToSource != '\0') {
    iVar5 = HTisDocumentSource();
    if (iVar5 != 0) {
      BVar2 = HTLoadedDocumentEightbit();
      text = LYCharSet_UC[current_char_set].MIMEname;
      if ((BVar2 != '\0') && (LYHaveCJKCharacterSet == '\0')) {
        iVar5 = strncasecomp(text,"x-",2);
        if (iVar5 != 0) {
          fprintf((FILE *)outfile_fp,
                  "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",text);
        }
      }
    }
  }
  print_wwwfile_to_fd(outfile_fp,'\0','\0');
  if (keypad_mode != 0) {
    printlist(outfile_fp,'\0');
  }
  if (buffer[0] == '|') {
    pclose((FILE *)outfile_fp);
  }
  else {
    LYCloseOutput(outfile_fp);
  }
  HTAddSugFilename(buffer);
done:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080b060f)

void send_file_to_mail(DocInfo *newdoc,char *content_base,char *content_location)

{
  int iVar1;
  bool bVar2;
  BOOLEAN first_mail_preparsed;
  BOOLEAN BVar3;
  int iVar4;
  char *Msg;
  FILE *fp;
  int in_GS_OFFSET;
  char *subject;
  char *buffer;
  FILE *outfile_fp;
  char *disp_charset;
  BOOLEAN use_type;
  BOOLEAN use_cte;
  BOOLEAN use_mime;
  char user_response [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  subject = (char *)0x0;
  BVar3 = LYSystemMail();
  if (BVar3 == '\0') goto LAB_080b0649;
  if (((LYPreparsedSource == '\0') || (first_mail_preparsed == '\0')) ||
     (iVar4 = HTisDocumentSource(), iVar4 == 0)) {
LAB_080b0154:
    mustshow = '\x01';
    Msg = (char *)gettext("Please enter a valid internet mail address: ");
    statusline(Msg);
    LYstrncpy(user_response,personal_mail_address,0x3ff);
    iVar4 = LYgetstr(user_response,0,0x400,RECALL_MAIL);
    if ((iVar4 < 0) || (user_response[0] == '\0')) {
      Msg = (char *)gettext("Mail request cancelled!!!");
      HTInfoMsg(Msg);
    }
    else {
      disp_charset = LYCharSet_UC[current_char_set].MIMEname;
      BVar3 = HTLoadedDocumentEightbit();
      if ((BVar3 == '\0') || (iVar4 = strncasecomp(disp_charset,"x-",2), iVar4 == 0)) {
        disp_charset = (char *)0x0;
      }
      if (disp_charset == (char *)0x0) {
        HTisDocumentSource();
      }
      subject = subject_translate8bit(newdoc->title);
      if (newdoc->isHEAD != '\0') {
        if (subject != (char *)0x0) {
          free(subject);
          subject = (char *)0x0;
        }
        HTSACopy(&subject,"HEAD  ");
        HTSACat(&subject,newdoc->address);
      }
      fp = LYPipeToMailer();
      if (fp == (FILE *)0x0) {
        Msg = (char *)gettext("ERROR - Unable to mail file");
        HTAlert(Msg);
      }
      else {
        BVar3 = HTLoadedDocumentEightbit();
        disp_charset = LYCharSet_UC[current_char_set].MIMEname;
        if (((BVar3 == '\0') || (LYHaveCJKCharacterSet != '\0')) ||
           (iVar4 = strncasecomp(disp_charset,"x-",2), iVar4 == 0)) {
          disp_charset = (char *)0x0;
        }
        if ((disp_charset == (char *)0x0) && (iVar4 = HTisDocumentSource(), iVar4 == 0)) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
        if ((BVar3 != '\0') || (bVar2)) {
          bVar2 = true;
        }
        else {
          bVar2 = false;
        }
        if ((bVar2) && (fwrite("Mime-Version: 1.0\n",1,0x12,(FILE *)fp), BVar3 != '\0')) {
          fwrite("Content-Transfer-Encoding: 8bit\n",1,0x20,(FILE *)fp);
        }
        iVar4 = HTisDocumentSource();
        if (iVar4 == 0) {
          if (disp_charset != (char *)0x0) {
            fprintf((FILE *)fp,"Content-Type: text/plain; charset=%s\n",disp_charset);
          }
        }
        else {
          fwrite("Content-Type: text/html",1,0x17,(FILE *)fp);
          if (disp_charset == (char *)0x0) {
            fputc(10,(FILE *)fp);
          }
          else {
            fprintf((FILE *)fp,"; charset=%s\n",disp_charset);
          }
        }
        if (bVar2) {
          if (content_base != (char *)0x0) {
            fprintf((FILE *)fp,"Content-Base: %s\n",content_base);
          }
          if (content_location != (char *)0x0) {
            fprintf((FILE *)fp,"Content-Location: %s\n",content_location);
          }
        }
        fprintf((FILE *)fp,"To: %s\nSubject: %s\n",user_response,subject);
        fprintf((FILE *)fp,"X-URL: %s\n\n",newdoc->address);
        if ((LYPrependBaseToSource != '\0') && (iVar4 = HTisDocumentSource(), iVar4 != 0)) {
          fprintf((FILE *)fp,"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",newdoc->address,
                  content_base);
        }
        print_wwwfile_to_fd(fp,'\x01','\0');
        if (keypad_mode != 0) {
          printlist(fp,'\0');
        }
        pclose((FILE *)fp);
      }
    }
  }
  else {
    Msg = (char *)gettext("Viewing preparsed source.  Are you sure you want to mail it?");
    iVar4 = HTConfirmDefault(Msg,0);
    if (iVar4 == 1) {
      LYwaddnstr(LYwin,"   Ok...",8);
      first_mail_preparsed = '\0';
      goto LAB_080b0154;
    }
    Msg = (char *)gettext("Mail request cancelled!!!");
    HTInfoMsg(Msg);
  }
  if (subject != (char *)0x0) {
    free(subject);
    subject = (char *)0x0;
  }
LAB_080b0649:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void send_file_to_printer(DocInfo *newdoc,char *content_base,char *sug_filename,int printer_number)

{
  int iVar1;
  int iVar2;
  FILE *fp;
  char *text;
  int in_GS_OFFSET;
  char *local_23c;
  int count;
  lynx_list_item_type *cur_printer;
  int FnameNum;
  int FnameTotal;
  char *the_command;
  FILE *outfile_fp;
  BOOLEAN FirstRecall;
  char my_temp [256];
  char my_file [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FirstRecall = '\x01';
  the_command = (char *)0x0;
  FnameNum = -1;
  iVar2 = HTisDocumentSource();
  if (iVar2 == 0) {
    local_23c = ".txt";
  }
  else {
    local_23c = ".html";
  }
  fp = LYOpenTemp(my_temp,local_23c,"w");
  if (fp == (FILE *)0x0) {
    text = (char *)gettext("ERROR - Unable to allocate file space!!!");
    HTAlert(text);
  }
  else {
    if (LYPrependBaseToSource != '\0') {
      iVar2 = HTisDocumentSource();
      if (iVar2 != 0) {
        fprintf((FILE *)fp,"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",newdoc->address,content_base
               );
      }
    }
    print_wwwfile_to_fd(fp,'\0','\0');
    if (keypad_mode != 0) {
      printlist(fp,'\0');
    }
    LYCloseTempFP(fp);
    count = 0;
    cur_printer = printers;
    while (count < printer_number) {
      count = count + 1;
      cur_printer = (lynx_list_item_type *)cur_printer->next;
    }
    if (cur_printer->command == (char *)0x0) {
      text = (char *)gettext("ERROR! - printer is misconfigured!");
      HTAlert(text);
    }
    else {
      iVar2 = HTCountCommandArgs(cur_printer->command);
      if (iVar2 < 2) {
LAB_080b0950:
        HTAddParam(&the_command,cur_printer->command,1,my_temp);
        HTAddParam(&the_command,cur_printer->command,2,my_file);
        HTEndParam(&the_command,cur_printer->command,2);
        LYmove(1,1);
        stop_curses();
        text = the_command;
        if (WWW_TraceFlag != '\0') {
          fp = TraceFP();
          fprintf((FILE *)fp,"command: %s\n",text);
        }
        text = (char *)gettext("Printing file.  Please wait...");
        printf(text);
        text = HText_getTitle();
        set_environ(0,text,"");
        set_environ(1,newdoc->address,"");
        text = HText_getDate();
        set_environ(2,text,"");
        text = HText_getLastModified();
        set_environ(3,text,"");
        LYSystem(the_command);
        if (the_command != (char *)0x0) {
          free(the_command);
          the_command = (char *)0x0;
        }
        LYRemoveTemp(my_temp);
        set_environ(0,"","");
        set_environ(1,"","");
        set_environ(2,"","");
        set_environ(3,"","");
        fflush(stdout);
        signal(2,cleanup_sig);
        LYSleepMsg();
        start_curses();
      }
      else {
        mustshow = '\x01';
        text = (char *)gettext("Enter a filename: ");
        statusline(text);
again:
        do {
          SetupFilename(my_file,sug_filename);
          do {
            iVar2 = RecallFilename(my_file,&FirstRecall,&FnameNum,&FnameTotal,0);
          } while (iVar2 == 1);
          if (iVar2 == 3) goto done;
        } while (iVar2 == 0);
        if ((no_dotfiles != '\0') || (show_dotfiles == '\0')) {
          text = LYPathLeaf(my_file);
          if (*text == '.') {
            text = (char *)gettext("File name may not begin with a dot.");
            HTAlert(text);
            mustshow = '\x01';
            text = (char *)gettext("Enter a new filename: ");
            statusline(text);
            FirstRecall = '\x01';
            FnameNum = FnameTotal;
            goto again;
          }
        }
        iVar2 = strcmp(my_file,"/dev/null");
        if (iVar2 != 0) {
          HTAddSugFilename(my_file);
          goto LAB_080b0950;
        }
        text = (char *)gettext("Print request cancelled!!!");
        HTInfoMsg(text);
      }
    }
  }
done:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void send_file_to_screen(DocInfo *newdoc,char *content_base,BOOLEAN Lpansi)

{
  int iVar1;
  FILE *fp;
  char *text;
  int iVar2;
  undefined4 uVar3;
  int in_GS_OFFSET;
  FILE *outfile_fp;
  char prompt [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Lpansi == '\0') {
    mustshow = '\x01';
    text = (char *)gettext("Press <return> to begin: ");
    statusline(text);
  }
  else {
    mustshow = '\x01';
    text = (char *)gettext("Be sure your printer is on-line.  Press <return> to start printing:");
    statusline(text);
  }
  prompt[0] = '\0';
  iVar2 = LYgetstr(prompt,0,0x50,NORECALL);
  fp = stdout;
  if (iVar2 < 0) {
    text = (char *)gettext("Print request cancelled!!!");
    HTInfoMsg(text);
  }
  else {
    stop_curses();
    signal(2,(__sighandler_t)0x1);
    if (LYPrependBaseToSource != '\0') {
      iVar2 = HTisDocumentSource();
      if (iVar2 != 0) {
        fprintf((FILE *)fp,"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",newdoc->address,content_base
               );
      }
    }
    if (Lpansi != '\0') {
      printf("\x1b[5i");
    }
    print_wwwfile_to_fd(fp,'\0','\0');
    if (keypad_mode != 0) {
      printlist(fp,'\0');
    }
    if (Lpansi == '\0') {
      uVar3 = gettext("Press <return> to finish: ");
      fprintf((FILE *)stdout,"\n\n%s",uVar3);
      fflush((FILE *)stdout);
      LYgetch();
    }
    else {
      printf("\n\f");
      printf("\x1b[4i");
      fflush((FILE *)stdout);
    }
    start_curses();
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int printfile(DocInfo *newdoc)

{
  BOOLEAN BVar1;
  char *src;
  int lines_per_page;
  UrlTypes UVar2;
  char *prompt;
  int local_4c;
  DocAddress WWWDoc;
  int type;
  int printer_number;
  int pagelen;
  int lines_in_file;
  char *sug_filename;
  char *link_info;
  char *cp;
  char *content_location;
  char *content_base;
  BOOLEAN Lpansi;
  
  Lpansi = '\0';
  content_base = (char *)0x0;
  content_location = (char *)0x0;
  link_info = (char *)0x0;
  lines_in_file = 0;
  pagelen = 0;
  printer_number = 0;
  type = 0;
  HTSACopy(&link_info,newdoc->address + 0xc);
  LYpop(newdoc);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  BVar1 = HTLoadAbsolute(&WWWDoc);
  if (BVar1 == '\0') {
    local_4c = 0;
  }
  else {
    src = HText_getContentBase();
    if (src != (char *)0x0) {
      src = HText_getContentBase();
      HTSACopy(&content_base,src);
      LYRemoveBlanks(content_base);
      if (((content_base == (char *)0x0) || (*content_base == '\0')) &&
         (content_base != (char *)0x0)) {
        free(content_base);
        content_base = (char *)0x0;
      }
    }
    lines_per_page = HTisDocumentSource();
    if (lines_per_page != 0) {
      src = HText_getContentLocation();
      if (src != (char *)0x0) {
        src = HText_getContentLocation();
        HTSACopy(&content_location,src);
        LYRemoveBlanks(content_location);
        if (((content_location == (char *)0x0) || (*content_location == '\0')) &&
           (content_location != (char *)0x0)) {
          free(content_location);
          content_location = (char *)0x0;
        }
      }
      if (content_base == (char *)0x0) {
        if ((content_location == (char *)0x0) ||
           (UVar2 = is_url(content_location), UVar2 == NOT_A_URL_TYPE)) {
          HTSACopy(&content_base,newdoc->address);
        }
        else {
          HTSACopy(&content_base,content_location);
        }
      }
      if (content_location == (char *)0x0) {
        HTSACopy(&content_location,newdoc->address);
      }
    }
    src = suggested_filename(newdoc);
    prompt = strstr(link_info,"lines=");
    if (prompt != (char *)0x0) {
      *prompt = '\0';
      lines_in_file = atoi(prompt + 6);
    }
    prompt = strstr(link_info,"LOCAL_FILE");
    if (prompt == (char *)0x0) {
      prompt = strstr(link_info,"TO_SCREEN");
      if (prompt == (char *)0x0) {
        prompt = strstr(link_info,"LPANSI");
        if (prompt == (char *)0x0) {
          prompt = strstr(link_info,"MAIL_FILE");
          if (prompt == (char *)0x0) {
            prompt = strstr(link_info,"PRINTER");
            if (prompt != (char *)0x0) {
              type = 5;
              prompt = strstr(link_info,"number=");
              if (prompt != (char *)0x0) {
                printer_number = atoi(prompt + 7);
              }
              prompt = strstr(link_info,"pagelen=");
              if (prompt == (char *)0x0) {
                pagelen = 0x42;
              }
              else {
                pagelen = atoi(prompt + 8);
              }
            }
          }
          else {
            type = 4;
          }
        }
        else {
          Lpansi = '\x01';
          type = 2;
        }
      }
      else {
        type = 2;
      }
    }
    else {
      type = 1;
    }
    lines_per_page = LYlines;
    if (type == 2) {
      prompt = (char *)gettext("File is %d screens long.  Are you sure you want to print?");
      BVar1 = confirm_by_pages(prompt,lines_in_file,lines_per_page);
      if (BVar1 != '\0') {
        send_file_to_screen(newdoc,content_base,Lpansi);
      }
    }
    else {
      if ((uint)type < 3) {
        if (type == 1) {
          send_file_to_file(newdoc,content_base,src);
        }
      }
      else {
        if (type == 4) {
          send_file_to_mail(newdoc,content_base,content_location);
        }
        else {
          if (type == 5) {
            prompt = (char *)gettext("File is %d pages long.  Are you sure you want to print?");
            BVar1 = confirm_by_pages(prompt,lines_in_file,pagelen);
            if (BVar1 != '\0') {
              send_file_to_printer(newdoc,content_base,src,printer_number);
            }
          }
        }
      }
    }
    if (link_info != (char *)0x0) {
      free(link_info);
      link_info = (char *)0x0;
    }
    if (src != (char *)0x0) {
      free(src);
    }
    if (content_base != (char *)0x0) {
      free(content_base);
      content_base = (char *)0x0;
    }
    if (content_location != (char *)0x0) {
      free(content_location);
    }
    local_4c = 1;
  }
  return local_4c;
}



char * subject_translate8bit(char *source)

{
  int cs_to;
  char *local_18;
  int i;
  int charset_out;
  int charset_in;
  char *target;
  
  cs_to = outgoing_mail_charset;
  target = (char *)0x0;
  HTSACopy(&target,source);
  if ((((cs_to < 0) || (cs_to == current_char_set)) || (LYCharSet_UC[current_char_set].enc == 5)) ||
     (LYCharSet_UC[cs_to].enc == 5)) {
    local_18 = target;
  }
  else {
    LYUCTranslateBackFormData(&target,current_char_set,cs_to,'\x01');
    local_18 = target;
  }
  return local_18;
}



int print_options(char **newfile,char *printed_url,int lines_in_file)

{
  char my_temp [256];
  FILE *fp0_00;
  char *Title;
  undefined4 local_5c;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int local_60;
  int local_40;
  undefined4 local_38;
  undefined4 local_34;
  char *local_30;
  lynx_list_item_type *cur_printer;
  FILE *fp0;
  int pages;
  int count;
  char *buffer;
  
  buffer = (char *)0x0;
  fp0_00 = InternalPageFP((char *)&ram0x081972c0,1);
  if (fp0_00 == (FILE *)0x0) {
    local_40 = -1;
  }
  else {
    LYLocalFileToURL(newfile,(char *)0x81972c0);
    Title = (char *)gettext("Printing Options");
    BeginInternalPage(fp0_00,Title,"keystrokes/print_help.html.gz");
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    local_60 = (lines_in_file + 0x41) / 0x42;
    local_5c = gettext("(approximately)");
    if (local_60 < 2) {
      local_38 = gettext(&DAT_0815f8a8);
    }
    else {
      local_38 = gettext("pages");
    }
    uVar1 = gettext("Number of pages:");
    uVar2 = gettext("Number of lines:");
    uVar3 = gettext("Document:");
    HTSprintf0(&buffer,"   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",uVar3,
               printed_url,uVar2,lines_in_file,uVar1,local_60,local_38,local_5c);
    fputs(buffer,(FILE *)fp0_00);
    if (buffer != (char *)0x0) {
      free(buffer);
      buffer = (char *)0x0;
    }
    if (((no_print != '\0') || (no_disk_save != '\0')) || (no_mail != '\0')) {
      local_5c = gettext("Some print functions have been disabled!");
      fprintf((FILE *)fp0_00,"   <em>%s</em>\n",local_5c);
    }
    if (user_mode == 0) {
      local_34 = gettext("Standard print options:");
    }
    else {
      local_34 = gettext("Print options:");
    }
    fprintf((FILE *)fp0_00,"\n%s\n",local_34);
    if ((no_disk_save == '\0') && (no_print == '\0')) {
      local_5c = gettext("Save to a local file");
      fprintf((FILE *)fp0_00,"   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n","LYNXPRINT:",
              lines_in_file,local_5c);
    }
    else {
      local_5c = gettext("Save to disk disabled");
      fprintf((FILE *)fp0_00,"   <em>%s</em>\n",local_5c);
    }
    if ((no_mail == '\0') && (local_host_only == '\0')) {
      local_5c = gettext("Mail the file");
      fprintf((FILE *)fp0_00,"   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n","LYNXPRINT:",
              lines_in_file,local_5c);
    }
    local_5c = gettext("Print to the screen");
    fprintf((FILE *)fp0_00,"   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n","LYNXPRINT:",
            lines_in_file,local_5c);
    local_5c = gettext("Print out on a printer attached to your vt100 terminal");
    local_60 = lines_in_file;
    fprintf((FILE *)fp0_00,"   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n","LYNXPRINT:",lines_in_file,
            local_5c);
    if (user_mode == 0) {
      uVar1 = gettext("Local additions:");
      fprintf((FILE *)fp0_00,"\n%s\n",uVar1,local_60,local_5c);
    }
    count = 0;
    cur_printer = printers;
    while (cur_printer != (lynx_list_item_type *)0x0) {
      if ((no_print == '\0') || (cur_printer->always_enabled != 0)) {
        fprintf((FILE *)fp0_00,"   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
                "LYNXPRINT:",count,cur_printer->pagelen,lines_in_file);
        if (cur_printer->name == (char *)0x0) {
          local_30 = "No Name Given";
        }
        else {
          local_30 = cur_printer->name;
        }
        fputs(local_30,(FILE *)fp0_00);
        fwrite("</a>\n",1,5,(FILE *)fp0_00);
      }
      cur_printer = (lynx_list_item_type *)cur_printer->next;
      count = count + 1;
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYforce_no_cache = '\x01';
    local_40 = 0;
  }
  return local_40;
}



char * GetFileName(void)

{
  int iVar1;
  BOOLEAN BVar2;
  char *text;
  int iVar3;
  size_t sVar4;
  int in_GS_OFFSET;
  char *local_288;
  stat stat_info;
  int FnameTotal;
  int FnameNum;
  char *fn;
  BOOLEAN FirstRecall;
  char tbuf [256];
  char fbuf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FirstRecall = '\x01';
  FnameNum = -1;
  mustshow = '\x01';
  text = (char *)gettext("Enter a filename: ");
  statusline(text);
  while( true ) {
    do {
      SetupFilename(fbuf,"");
      do {
        iVar3 = RecallFilename(fbuf,&FirstRecall,&FnameNum,&FnameTotal,1);
      } while (iVar3 == 1);
      if (iVar3 == 3) goto quit;
    } while (iVar3 == 0);
    HTAddSugFilename(fbuf);
    BVar2 = LYValidateFilename(tbuf,fbuf);
    if (BVar2 == '\0') break;
    iVar3 = stat64(tbuf,(stat64 *)&stat_info);
    if ((iVar3 < 0) ||
       (((stat_info.st_mode & 0xf000) != 0x8000 && ((stat_info.st_mode & 0xf000) != 0xa000)))) {
      text = (char *)gettext("File does not exist.");
      HTInfoMsg(text);
      mustshow = '\x01';
      text = (char *)gettext("File does not exist - reenter or cancel:");
      statusline(text);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
    }
    else {
      BVar2 = LYCanReadFile(tbuf);
      if (BVar2 != '\0') {
        sVar4 = strlen(tbuf);
        text = (char *)calloc(sVar4 + 1,1);
        if (text == (char *)0x0) {
          outofmem("./LYPrint.c","GetFileName");
        }
        local_288 = strcpy(text,tbuf);
        goto LAB_080b1920;
      }
      text = (char *)gettext("File is not readable.");
      HTInfoMsg(text);
      mustshow = '\x01';
      text = (char *)gettext("File is not readable - reenter or cancel:");
      statusline(text);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
    }
  }
quit:
  local_288 = (char *)0x0;
LAB_080b1920:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_288;
}



BOOLEAN getBool(char *src)

{
  int iVar1;
  
  iVar1 = strncasecomp(src,"on",2);
  if ((iVar1 != 0) && (iVar1 = strncasecomp(src,"true",4), iVar1 != 0)) {
    return '\0';
  }
  return '\x01';
}



char * LYputEnum(Config_Enum *table,int value)

{
  while( true ) {
    if (table->name == (char *)0x0) {
      return "?";
    }
    if (table->value == value) break;
    table = table + 1;
  }
  return table->name;
}



BOOLEAN LYgetEnum(Config_Enum *table,char *name,int *result)

{
  size_t n;
  int iVar1;
  int match;
  uint len;
  Config_Enum *found;
  
  found = (Config_Enum *)0x0;
  n = strlen(name);
  match = 0;
  if (n != 0) {
    while (table->name != (char *)0x0) {
      iVar1 = strncasecomp(table->name,name,n);
      if (iVar1 == 0) {
        found = table;
        iVar1 = strcasecomp(table->name,name);
        if (iVar1 == 0) {
          match = 1;
          break;
        }
        match = match + 1;
      }
      table = table + 1;
    }
    if (match == 1) {
      *result = found->value;
      return '\x01';
    }
  }
  return '\0';
}



int get_assume_charset(char *value)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (LYNumCharsets <= i) {
      return 0;
    }
    iVar1 = strcasecomp(value,LYCharSet_UC[i].MIMEname);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  UCLYhndl_for_unspec = i;
  return 0;
}



void put_assume_charset(FILE *fp,config_type *tbl)

{
  int i;
  
  i = 0;
  while (i < LYNumCharsets) {
    fprintf((FILE *)fp,"#    %s\n",LYCharSet_UC[i].MIMEname);
    i = i + 1;
  }
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return;
}



int get_display_charset(char *value)

{
  int iVar1;
  int i;
  
  iVar1 = UCGetLYhndl_byAnyName(value);
  if (-1 < iVar1) {
    current_char_set = iVar1;
  }
  return 0;
}



void put_display_charset(FILE *fp,config_type *tbl)

{
  int i;
  
  i = 0;
  while (LYchar_set_names[i] != (char *)0x0) {
    fprintf((FILE *)fp,"#    %s\n",LYchar_set_names[i]);
    i = i + 1;
  }
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,LYchar_set_names[current_char_set]);
  return;
}



int get_editor(char *value)

{
  if (system_editor == '\0') {
    HTSACopy(&editor,value);
  }
  return 0;
}



void put_editor(FILE *fp,config_type *tbl)

{
  char *local_8;
  
  if (editor == (char *)0x0) {
    local_8 = "";
  }
  else {
    local_8 = editor;
  }
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,local_8);
  return;
}



int get_tagsoup(char *value)

{
  BOOLEAN BVar1;
  int found;
  
  found = Old_DTD;
  BVar1 = LYgetEnum(tbl_DTD_recovery,value,&found);
  if ((BVar1 != '\0') && (Old_DTD != found)) {
    Old_DTD = found;
    HTSwitchDTD((uint)(found == 0));
  }
  return 0;
}



void put_tagsoup(FILE *fp,config_type *tbl)

{
  char *pcVar1;
  
  pcVar1 = LYputEnum(tbl_DTD_recovery,Old_DTD);
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,pcVar1);
  return;
}



Config_Type * lookup_config(char *name)

{
  byte bVar1;
  ushort **ppuVar2;
  int iVar3;
  char local_1d;
  uint local_18;
  Config_Type *tbl;
  char ch1;
  char ch;
  
  tbl = Config_Table;
  ppuVar2 = __ctype_b_loc();
  if (((*ppuVar2)[(byte)*name] & 0x200) == 0) {
    local_1d = *name;
  }
  else {
    iVar3 = toupper((uint)(byte)*name);
    local_1d = (char)iVar3;
  }
  do {
    if (((Config_Type *)tbl)->name == (char *)0x0) {
      return (Config_Type *)tbl;
    }
    if (((Config_Type *)tbl)->type != 0) {
      bVar1 = *((Config_Type *)tbl)->name;
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[bVar1] & 0x200) == 0) {
        local_18 = (uint)bVar1;
      }
      else {
        local_18 = toupper((uint)bVar1);
      }
      if (((int)local_1d == local_18) &&
         (iVar3 = strcasecomp(name,((Config_Type *)tbl)->name), iVar3 == 0)) {
        return (Config_Type *)tbl;
      }
    }
    tbl = (Config_Type_conflict1 *)((Config_Type *)tbl + 2);
  } while( true );
}



int _f(char *c)

{
  int in_EAX;
  
  return in_EAX;
}



int _read_rc(int val)

{
  ParseUnion *q;
  ParseUnion _q;
  
  *q = 0x80b1dc5;
  if (val != 0) {
    _f((char *)0x0);
    (*(code *)*q)(0);
  }
  return val;
}



void read_rc(FILE *fp)

{
  int iVar1;
  int *piVar2;
  code cVar3;
  FILE *__stream;
  byte *__s;
  ushort **ppuVar4;
  size_t n_00;
  int iVar5;
  int **ppiVar6;
  char *pcVar7;
  char *src;
  int in_GS_OFFSET;
  FILE *local_23c;
  int ival;
  char *special;
  ParseUnion *q;
  Config_Type *tbl;
  char *notes;
  char *value;
  char *name;
  int n;
  char *buffer;
  char MBM_line [256];
  char rcfile [256];
  
  local_23c = fp;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  buffer = (char *)0x0;
  if (fp == (FILE *)0x0) {
    LYAddPathToHome(rcfile,0x100,".lynxrc");
    local_23c = (FILE *)fopen64(rcfile,"r");
    if (local_23c == (FILE *)0x0) goto LAB_080b2483;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"read_rc opened %s\n",rcfile);
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"read_rc used passed-in stream\n");
    }
  }
switchD_080b2107_caseD_0:
  src = LYSafeGets(&buffer,local_23c);
  if (src != (char *)0x0) {
    LYTrimTrailing(buffer);
    __s = (byte *)LYSkipBlanks(buffer);
    ppuVar4 = __ctype_b_loc();
    if ((((*ppuVar4)[*__s] & 4) == 0) && (*__s != 0)) {
      src = strchr((char *)__s,0x3d);
      if (src == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYrcFile: missing \'=\' %s\n",__s);
        }
        goto switchD_080b2107_caseD_0;
      }
      *src = '\0';
      LYTrimTrailing((char *)__s);
      src = LYSkipBlanks(src + 1);
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYrcFile %s:%s\n",__s,src);
      }
      tbl = lookup_config((char *)__s);
      if (tbl->name == (char *)0x0) {
        n_00 = strlen("multi_bookmark");
        iVar5 = strncasecomp((char *)__s,"multi_bookmark",n_00);
        if (iVar5 == 0) {
          tbl = lookup_config("multi_bookmark");
        }
        if (tbl->name == (char *)0x0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYrcFile: ignored %s=%s\n",__s,src);
          }
          goto switchD_080b2107_caseD_0;
        }
      }
      ppiVar6 = (int **)&tbl->help_string;
      switch(tbl->value) {
      case 1:
        n = 0;
        while (*(int *)(tbl[1].name + n * 4) != 0) {
          iVar5 = strcasecomp(src,*(char **)(tbl[1].name + n * 4));
          if (iVar5 == 0) {
            **ppiVar6 = n;
            break;
          }
          n = n + 1;
        }
        break;
      case 2:
        if (*ppiVar6 != (int *)0x0) {
          piVar2 = *ppiVar6;
          cVar3 = (code)getBool(src);
          *(code *)piVar2 = cVar3;
        }
        break;
      case 3:
        if (*ppiVar6 != (int *)0x0) {
          (*(code *)*ppiVar6)(src);
        }
        break;
      case 4:
        if ((*ppiVar6 != (int *)0x0) && (iVar5 = sscanf(src,"%d",&ival), iVar5 == 1)) {
          **ppiVar6 = ival;
        }
        break;
      case 5:
        if (tbl[1].type != 0) {
          LYgetEnum((Config_Enum *)tbl[1].type,src,*ppiVar6);
        }
        break;
      case 6:
        if (*ppiVar6 != (int *)0x0) {
          if (**ppiVar6 != 0) {
            HTSACat((char **)*ppiVar6,",");
          }
          HTSACat((char **)*ppiVar6,src);
        }
        break;
      case 7:
        n = 1;
        while (n < 0x1a) {
          iVar5 = LYindex2MBM(n);
          sprintf(MBM_line,"multi_bookmark%c",iVar5);
          iVar5 = strcasecomp((char *)__s,MBM_line);
          if (iVar5 == 0) {
            pcVar7 = strchr(src,0x2c);
            if (pcVar7 == (char *)0x0) {
              n_00 = strlen(src);
              notes = src + n_00;
            }
            else {
              *pcVar7 = '\0';
              LYTrimTrailing(src);
              notes = LYSkipBlanks(pcVar7 + 1);
            }
            HTSACopy(MBM_A_subbookmark + n,src);
            HTSACopy(MBM_A_subdescript + n,notes);
            break;
          }
          n = n + 1;
        }
        break;
      case 8:
        if (*ppiVar6 != (int *)0x0) {
          HTSACopy((char **)*ppiVar6,src);
        }
      }
    }
    goto switchD_080b2107_caseD_0;
  }
  LYCloseInput(local_23c);
  LYConfigCookies();
  if (LYrcShowColor == 0) {
    if (LYShowColor == 2) {
      LYShowColor = 1;
    }
  }
  else {
    if ((LYrcShowColor == 3) && (LYShowColor != 0)) {
      LYShowColor = 3;
    }
  }
  set_default_bookmark_page(bookmark_page);
LAB_080b2483:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void write_list(FILE *fp,char *list)

{
  char cVar1;
  bool bVar2;
  int ch;
  int first;
  
  bVar2 = true;
  while (*list != '\0') {
    cVar1 = *list;
    list = list + 1;
    if (bVar2) {
      fwrite(&DAT_081625f4,1,2,(FILE *)fp);
      bVar2 = false;
    }
    if ((int)cVar1 == 10) {
      bVar2 = true;
    }
    fputc((int)cVar1,(FILE *)fp);
  }
  return;
}



void explain_keypad_mode(FILE *fp)

{
  char *list;
  
  list = (char *)gettext(
                        "If keypad_mode is set to \"NUMBERS_AS_ARROWS\", then the numbers on\nyour keypad when the numlock is on will act as arrow keys:\n            8 = Up Arrow\n  4 = Left Arrow    6 = Right Arrow\n            2 = Down Arrow\nand the corresponding keyboard numbers will act as arrow keys,\nregardless of whether numlock is on.\n"
                        );
  write_list(fp,list);
  list = (char *)gettext(
                        "If keypad_mode is set to \"LINKS_ARE_NUMBERED\", then numbers will\nappear next to each link and numbers are used to select links.\n"
                        );
  write_list(fp,list);
  list = (char *)gettext(
                        "If keypad_mode is set to \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\", then\nnumbers will appear next to each link and visible form input field.\nNumbers are used to select links, or to move the \"current link\" to a\nform input field or button.  In addition, options in popup menus are\nindexed so that the user may type an option number to select an option in\na popup menu, even if the option isn\'t visible on the screen.  Reference\nlists and output from the list command also enumerate form inputs.\n"
                        );
  write_list(fp,list);
  list = (char *)gettext(
                        "NOTE: Some fixed format documents may look disfigured when\n\"LINKS_ARE_NUMBERED\" or \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\" are\nenabled.\n"
                        );
  write_list(fp,list);
  return;
}



// WARNING: Type propagation algorithm not settling

int save_rc(FILE *fp)

{
  int iVar1;
  undefined4 uVar2;
  FILE **ppFVar3;
  int in_GS_OFFSET;
  char *local_148;
  char *local_144;
  int local_13c;
  FILE *local_134;
  char *local_130;
  FILE *local_12c;
  FILE *local_128;
  ParseUnion *q;
  int n;
  Config_Type *tbl;
  BOOLEAN is_tempfile;
  char rcfile [256];
  
  local_128 = fp;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  tbl = Config_Table;
  if (fp == (FILE *)0x0) {
    LYAddPathToHome(rcfile,0x100,".lynxrc");
    local_128 = LYNewTxtFile(rcfile);
    if (local_128 == (FILE *)0x0) {
      local_13c = 0;
      goto LAB_080b2b68;
    }
  }
  local_144 = (char *)gettext("Lynx User Defaults File\n\n");
  write_list(local_128,local_144);
  local_144 = (char *)gettext(
                             "This file contains options saved from the Lynx Options Screen (normally\nwith the \'o\' key).  To save options with that screen, you must select the\ncheckbox:\n"
                             );
  write_list(local_128,local_144);
  uVar2 = gettext("Save options to disk");
  fprintf((FILE *)local_128,"#\t%s\n",uVar2);
  fwrite(&DAT_08162afc,1,2,(FILE *)local_128);
  local_144 = (char *)gettext(
                             "You must then save the settings using the link on the line above the\ncheckbox:\n"
                             );
  write_list(local_128,local_144);
  uVar2 = gettext("Accept Changes");
  fprintf((FILE *)local_128,"#\t%s\n",uVar2);
  local_144 = (char *)0x2;
  local_12c = local_128;
  fwrite(&DAT_08162afc,1,2,(FILE *)local_128);
  local_148 = (char *)gettext(
                             "You may also use the command-line option \"-forms_options\", which displays\nthe simpler Options Menu instead.  Save options with that using the \'>\' key.\n\n"
                             );
  write_list(local_128,local_148);
  local_148 = (char *)gettext(
                             "There is normally no need to edit this file manually, since the defaults\nhere can be controlled from the Options Screen, and the next time options\nare saved from the Options Screen this file will be completely rewritten.\nYou have been warned...\n\nIf you are looking for the general configuration file - it is normally\ncalled \"lynx.cfg\".  It has different content and a different format.\nIt is not this file.\n"
                             );
  write_list(local_128,local_148);
  local_148 = (char *)local_128;
  fputc(10,(FILE *)local_128);
  while (((Config_Type *)tbl)->name != (char *)0x0) {
    ppFVar3 = (FILE **)&((Config_Type *)tbl)->help_string;
    if (((Config_Type *)tbl)->type == 0) {
      tbl = (Config_Type_conflict1 *)((Config_Type *)tbl + 2);
    }
    else {
      if (((Config_Type *)tbl)[1].help_string == (char *)0x0) {
        if ((Config_Enum *)((Config_Type *)tbl)[1].type == tbl_keypad_mode) {
          explain_keypad_mode(local_128);
        }
      }
      else {
        local_148 = (char *)gettext(((Config_Type *)tbl)[1].help_string,local_148,local_144,
                                    local_12c);
        write_list(local_128,local_148);
      }
      switch(((Config_Type *)tbl)->value) {
      case 1:
        n = 0;
        while (*(int *)(((Config_Type *)tbl)[1].name + n * 4) != 0) {
          fprintf((FILE *)local_128,"#    %s\n",
                  *(undefined4 *)(((Config_Type *)tbl)[1].name + n * 4));
          n = n + 1;
        }
        local_12c = *(FILE **)(((Config_Type *)tbl)[1].name + (*ppFVar3)->_flags * 4);
        local_144 = ((Config_Type *)tbl)->name;
        local_148 = "%s=%s\n\n";
        fprintf((FILE *)local_128,"%s=%s\n\n");
        break;
      case 2:
        if (*(char *)&(*ppFVar3)->_flags == '\0') {
          local_134 = (FILE *)&DAT_0815fbd6;
        }
        else {
          local_134 = (FILE *)&DAT_0815fbd3;
        }
        local_144 = ((Config_Type *)tbl)->name;
        local_148 = "%s=%s\n\n";
        fprintf((FILE *)local_128,"%s=%s\n\n");
        local_12c = local_134;
        break;
      case 3:
        if (((Config_Type *)tbl)[1].value != 0) {
          local_148 = (char *)tbl;
          (*(code *)((Config_Type *)tbl)[1].value)(local_128);
        }
        break;
      case 4:
        local_12c = (FILE *)(*ppFVar3)->_flags;
        local_144 = ((Config_Type *)tbl)->name;
        local_148 = "%s=%d\n\n";
        fprintf((FILE *)local_128,"%s=%d\n\n");
        break;
      case 5:
        local_12c = (FILE *)LYputEnum((Config_Enum *)((Config_Type *)tbl)[1].type,(*ppFVar3)->_flags
                                     );
        local_144 = ((Config_Type *)tbl)->name;
        local_148 = "%s=%s\n\n";
        fprintf((FILE *)local_128,"%s=%s\n\n");
        break;
      case 6:
      case 8:
        if ((*ppFVar3 == (FILE *)0x0) || ((*ppFVar3)->_flags == 0)) {
          local_12c = (FILE *)&DAT_0815fe34;
        }
        else {
          local_12c = (FILE *)(*ppFVar3)->_flags;
        }
        local_144 = ((Config_Type *)tbl)->name;
        local_148 = "%s=%s\n\n";
        fprintf((FILE *)local_128,"%s=%s\n\n");
        break;
      case 7:
        n = 1;
        while (n < 0x1a) {
          local_144 = (char *)LYindex2MBM(n);
          fprintf((FILE *)local_128,"multi_bookmark%c=");
          if (MBM_A_subbookmark[n] == (char *)0x0) {
            local_130 = "";
          }
          else {
            local_130 = MBM_A_subbookmark[n];
          }
          fputs(local_130,(FILE *)local_128);
          if ((MBM_A_subdescript[n] != (char *)0x0) && (*MBM_A_subdescript[n] != '\0')) {
            local_144 = MBM_A_subdescript[n];
            fprintf((FILE *)local_128,",%s");
          }
          fputc(10,(FILE *)local_128);
          n = n + 1;
        }
        local_148 = (char *)local_128;
        fputc(10,(FILE *)local_128);
      }
      tbl = (Config_Type_conflict1 *)((Config_Type *)tbl + 2);
    }
  }
  if (fp == (FILE *)0x0) {
    LYCloseOutput(local_128);
  }
  else {
    LYCloseTempFP(local_128);
  }
  local_13c = 1;
LAB_080b2b68:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_13c;
}



BOOLEAN will_save_rc(char *name)

{
  Config_Type *pCVar1;
  Config_Type *tbl;
  
  pCVar1 = lookup_config(name);
  return (BOOLEAN)(pCVar1->name != (char *)0x0);
}



int enable_lynxrc(char *value)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  char *colon;
  Config_Type *tbl;
  
  pcVar2 = strchr(value,0x3a);
  if (pcVar2 != (char *)0x0) {
    *pcVar2 = '\0';
    LYTrimLeading(value);
    LYTrimTrailing(value);
    tbl = Config_Table;
    while (((Config_Type *)tbl)->name != (char *)0x0) {
      iVar3 = strcasecomp(value,((Config_Type *)tbl)->name);
      if (iVar3 == 0) {
        BVar1 = getBool(pcVar2 + 1);
        ((Config_Type *)tbl)->type = (int)BVar1;
        return 0;
      }
      tbl = (Config_Type_conflict1 *)((Config_Type *)tbl + 2);
    }
  }
  return 0;
}



void LYDownload(char *line)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  BOOLEAN BVar5;
  char *Msg;
  int iVar6;
  FILE *__stream;
  int in_GS_OFFSET;
  int local_254;
  int FnameNum;
  int FnameTotal;
  RecallType recall;
  int ch;
  lynx_list_item_type *download_command;
  char *cp;
  char *the_command;
  int count;
  int method_number;
  char *sug_file;
  char *file;
  char *method;
  char *Line;
  BOOLEAN SecondS;
  BOOLEAN FirstRecall;
  char command [256];
  char buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  Line = (char *)0x0;
  the_command = (char *)0x0;
  bVar3 = true;
  bVar4 = false;
  if (LYValidDownloadFile[0] != '\0') {
    HTSACopy(&Line,line);
    Msg = strstr(Line,"/File=");
    if (Msg != (char *)0x0) {
      *Msg = '\0';
      file = Msg + 6;
      sug_file = strstr(Msg + 7,"/SugFile=");
      if (sug_file != (char *)0x0) {
        *sug_file = '\0';
        sug_file = sug_file + 9;
        HTUnEscape(sug_file);
      }
      iVar6 = strcmp(file,LYValidDownloadFile);
      if (iVar6 == 0) {
        iVar6 = strncmp(file,"file://localhost",0x10);
        if (iVar6 == 0) {
          file = Msg + 0x16;
        }
        else {
          if (((*file == 'f') || (*file == 'F')) &&
             (iVar6 = strncasecomp(file,"file:",5), iVar6 == 0)) {
            file = Msg + 0xb;
          }
        }
        HTUnEscape(file);
        Msg = strstr(Line,"Method=");
        if (Msg != (char *)0x0) {
          iVar6 = atoi(Msg + 7);
          if (sug_filenames == (HTList *)0x0) {
            local_254 = 0;
          }
          else {
            local_254 = HTList_count(sug_filenames);
          }
          bVar2 = 0 < local_254;
          FnameNum = local_254;
          if (iVar6 < 0) {
            mustshow = '\x01';
            Msg = (char *)gettext("Enter a filename: ");
            statusline(Msg);
retry:
            do {
              FnameNum = local_254;
              bVar3 = true;
              if (sug_file == (char *)0x0) {
                buffer[0] = '\0';
              }
              else {
                LYstrncpy(buffer,sug_file,0x7f);
              }
              while( true ) {
                while( true ) {
                  iVar6 = LYgetstr(buffer,0,0x80,(uint)bVar2);
                  if (((-1 < iVar6) && (buffer[0] != '\0')) &&
                     ((iVar6 != 0x100 && (iVar6 != 0x101)))) {
                    strcpy(command,buffer);
                    BVar5 = LYValidateFilename(buffer,command);
                    if (BVar5 == '\0') goto cancelled;
                    if (buffer[0] == '|') {
                      Msg = (char *)gettext("Cannot write to file.");
                      HTAlert(Msg);
                      mustshow = '\x01';
                      Msg = (char *)gettext("Enter a new filename: ");
                      statusline(Msg);
                      goto retry;
                    }
                    iVar6 = LYValidateOutput(buffer);
                    if (iVar6 == 0x4e) {
                      mustshow = '\x01';
                      Msg = (char *)gettext("Enter a new filename: ");
                      statusline(Msg);
                      goto retry;
                    }
                    if (iVar6 != 0x59) {
                      if (Line != (char *)0x0) {
                        free(Line);
                        Line = (char *)0x0;
                      }
                      goto LAB_080b3888;
                    }
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"LYDownload: filename is %s\n",buffer);
                    }
                    BVar5 = LYCanWriteFile(buffer);
                    if (BVar5 == '\0') goto retry;
                    bVar4 = true;
                    Msg = (char *)gettext("Saving...");
                    HTInfoMsg(Msg);
                    LYCopyFile(file,buffer);
                    LYRelaxFilePermissions(buffer);
                    goto LAB_080b37db;
                  }
                  if ((!bVar2) || (iVar6 != 0x100)) break;
                  if (bVar3) {
                    bVar3 = false;
                    FnameNum = 0;
                  }
                  else {
                    FnameNum = FnameNum + 1;
                  }
                  if (local_254 <= FnameNum) {
                    mustshow = '\x01';
                    Msg = (char *)gettext("Enter a filename: ");
                    statusline(Msg);
                    goto retry;
                  }
                  Msg = (char *)HTList_objectAt(sug_filenames,FnameNum);
                  if (Msg == (char *)0x0) goto cancelled;
                  LYstrncpy(buffer,Msg,0xff);
                  if (local_254 == 1) {
                    mustshow = '\x01';
                    Msg = (char *)gettext("Edit the previous filename: ");
                    statusline(Msg);
                  }
                  else {
                    mustshow = '\x01';
                    Msg = (char *)gettext("Edit a previous filename: ");
                    statusline(Msg);
                  }
                }
                if ((!bVar2) || (iVar6 != 0x101)) goto cancelled;
                if (bVar3) {
                  bVar3 = false;
                  FnameNum = local_254;
                }
                FnameNum = FnameNum + -1;
                if (FnameNum < 0) break;
                Msg = (char *)HTList_objectAt(sug_filenames,FnameNum);
                if (Msg == (char *)0x0) goto cancelled;
                LYstrncpy(buffer,Msg,0xff);
                if (local_254 == 1) {
                  mustshow = '\x01';
                  Msg = (char *)gettext("Edit the previous filename: ");
                  statusline(Msg);
                }
                else {
                  mustshow = '\x01';
                  Msg = (char *)gettext("Edit a previous filename: ");
                  statusline(Msg);
                }
              }
              mustshow = '\x01';
              Msg = (char *)gettext("Enter a filename: ");
              statusline(Msg);
            } while( true );
          }
          buffer[0] = '\0';
          count = 0;
          download_command = downloaders;
          while (count < iVar6) {
            count = count + 1;
            download_command = (lynx_list_item_type *)download_command->next;
          }
          if (download_command->command != (char *)0x0) {
            iVar6 = HTCountCommandArgs(download_command->command);
            if (1 < iVar6) {
              mustshow = '\x01';
              Msg = (char *)gettext("Enter a filename: ");
              statusline(Msg);
again:
              do {
                if (sug_file == (char *)0x0) {
                  buffer[0] = '\0';
                }
                else {
                  strncpy(buffer,sug_file,0x7f);
                }
                while( true ) {
                  while( true ) {
                    iVar6 = LYgetstr(buffer,0,0x100,(uint)bVar2);
                    if ((((-1 < iVar6) && (buffer[0] != '\0')) && (iVar6 != 0x100)) &&
                       (iVar6 != 0x101)) {
                      if (((no_dotfiles != '\0') || (show_dotfiles == '\0')) &&
                         (Msg = LYPathLeaf(buffer), *Msg == '.')) {
                        Msg = (char *)gettext("File name may not begin with a dot.");
                        HTAlert(Msg);
                        mustshow = '\x01';
                        Msg = (char *)gettext("Enter a new filename: ");
                        statusline(Msg);
                        goto again;
                      }
                      iVar6 = strcmp(buffer,"/dev/null");
                      if (iVar6 == 0) goto cancelled;
                      bVar4 = true;
                      goto LAB_080b36b0;
                    }
                    if ((!bVar2) || (iVar6 != 0x100)) break;
                    if (bVar3) {
                      bVar3 = false;
                      FnameNum = 0;
                    }
                    else {
                      FnameNum = FnameNum + 1;
                    }
                    if (local_254 <= FnameNum) {
                      bVar3 = true;
                      FnameNum = local_254;
                      mustshow = '\x01';
                      Msg = (char *)gettext("Enter a filename: ");
                      statusline(Msg);
                      goto again;
                    }
                    Msg = (char *)HTList_objectAt(sug_filenames,FnameNum);
                    if (Msg == (char *)0x0) goto cancelled;
                    LYstrncpy(buffer,Msg,0xff);
                    if (local_254 == 1) {
                      mustshow = '\x01';
                      Msg = (char *)gettext("Edit the previous filename: ");
                      statusline(Msg);
                    }
                    else {
                      mustshow = '\x01';
                      Msg = (char *)gettext("Edit a previous filename: ");
                      statusline(Msg);
                    }
                  }
                  if ((!bVar2) || (iVar6 != 0x101)) goto cancelled;
                  if (bVar3) {
                    bVar3 = false;
                    FnameNum = local_254;
                  }
                  FnameNum = FnameNum + -1;
                  if (FnameNum < 0) break;
                  Msg = (char *)HTList_objectAt(sug_filenames,FnameNum);
                  if (Msg == (char *)0x0) goto cancelled;
                  LYstrncpy(buffer,Msg,0xff);
                  if (local_254 == 1) {
                    mustshow = '\x01';
                    Msg = (char *)gettext("Edit the previous filename: ");
                    statusline(Msg);
                  }
                  else {
                    mustshow = '\x01';
                    Msg = (char *)gettext("Edit a previous filename: ");
                    statusline(Msg);
                  }
                }
                bVar3 = true;
                FnameNum = local_254;
                mustshow = '\x01';
                Msg = (char *)gettext("Enter a filename: ");
                statusline(Msg);
              } while( true );
            }
LAB_080b36b0:
            count = 1;
            HTAddParam(&the_command,download_command->command,1,file);
            iVar6 = HTCountCommandArgs(download_command->command);
            if (1 < iVar6) {
              count = 2;
              HTAddParam(&the_command,download_command->command,2,buffer);
            }
            HTEndParam(&the_command,download_command->command,count);
            Msg = the_command;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"command: %s\n",Msg);
            }
            stop_curses();
            LYSystem(the_command);
            if (the_command != (char *)0x0) {
              free(the_command);
              the_command = (char *)0x0;
            }
            start_curses();
LAB_080b37db:
            if (bVar4) {
              HTAddSugFilename(buffer);
            }
            if (Line != (char *)0x0) {
              free(Line);
              Line = (char *)0x0;
            }
            goto LAB_080b3888;
          }
          Msg = (char *)gettext("ERROR! - download command is misconfigured.");
          HTAlert(Msg);
        }
      }
    }
  }
  Msg = (char *)gettext("Unable to download file.");
  HTAlert(Msg);
  if (Line != (char *)0x0) {
    free(Line);
    Line = (char *)0x0;
  }
  goto LAB_080b3888;
cancelled:
  Msg = (char *)gettext("Cancelling!");
  HTInfoMsg(Msg);
  if (Line != (char *)0x0) {
    free(Line);
    Line = (char *)0x0;
  }
LAB_080b3888:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int SuffixIs(char *filename,char *suffix)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  size_t need;
  size_t have;
  
  sVar1 = strlen(filename);
  sVar2 = strlen(suffix);
  if ((sVar2 < sVar1) && (iVar3 = strcmp(filename + (sVar1 - sVar2),suffix), iVar3 == 0)) {
    return 1;
  }
  return 0;
}



int LYdownload_options(char **newfile,char *data_file)

{
  char tempfile [256];
  FILE *fp0_00;
  undefined4 uVar1;
  int iVar2;
  char *source_00;
  char *local_50;
  undefined4 local_3c;
  char *local_30;
  char *local_2c;
  char *source;
  char *target;
  int count;
  lynx_list_item_type *cur_download;
  FILE *fp0;
  char *sug_filename;
  char *downloaded_url;
  
  downloaded_url = (char *)0x0;
  sug_filename = (char *)0x0;
  HTSACopy(&sug_filename,*newfile);
  change_sug_filename(sug_filename);
  fp0_00 = InternalPageFP((char *)&ram0x08197da0,1);
  if (fp0_00 != (FILE *)0x0) {
    HTSACopy(&downloaded_url,*newfile);
    LYLocalFileToURL(newfile,(char *)0x8197da0);
    LYstrncpy(LYValidDownloadFile,data_file,0xff);
    LYforce_no_cache = '\x01';
    local_50 = (char *)gettext("Download Options");
    BeginInternalPage(fp0_00,local_50,"Lynx_users_guide.html.gz#RemoteSource");
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    local_50 = downloaded_url;
    uVar1 = gettext("Downloaded link:");
    fprintf((FILE *)fp0_00,"<em>%s</em> %s\n",uVar1,local_50);
    if (downloaded_url != (char *)0x0) {
      free(downloaded_url);
      downloaded_url = (char *)0x0;
    }
    local_50 = sug_filename;
    uVar1 = gettext("Suggested file name:");
    fprintf((FILE *)fp0_00,"<em>%s</em> %s\n",uVar1,local_50);
    if (user_mode == 0) {
      local_3c = gettext("Standard download options:");
    }
    else {
      local_3c = gettext("Download options:");
    }
    fprintf((FILE *)fp0_00,"\n%s\n",local_3c,local_50);
    if (no_disk_save == '\0') {
      if (lynx_edit_mode == '\0') {
        uVar1 = gettext("Save to disk");
        if (lynx_save_space == (char *)0x0) {
          local_30 = "";
        }
        else {
          local_30 = lynx_save_space;
        }
        local_50 = data_file;
        fprintf((FILE *)fp0_00,"   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
                "LYNXDOWNLOAD:",data_file,local_30,sug_filename,uVar1);
        iVar2 = SuffixIs(data_file,".html");
        if ((iVar2 != 0) || (iVar2 = SuffixIs(data_file,".txt"), iVar2 != 0)) {
          target = (char *)0x0;
          source_00 = LYAddPathToSave(data_file);
          LYLocalFileToURL(&target,source_00);
          local_50 = (char *)gettext("View temporary file");
          fprintf((FILE *)fp0_00,"   <a href=\"%s\">%s</a>\n",target,local_50);
          if (source_00 != (char *)0x0) {
            free(source_00);
          }
          if (target != (char *)0x0) {
            free(target);
            target = (char *)0x0;
          }
        }
      }
    }
    else {
      uVar1 = gettext("Save to disk disabled.");
      fprintf((FILE *)fp0_00,"   <em>%s</em>\n",uVar1);
    }
    if (user_mode == 0) {
      uVar1 = gettext("Local additions:");
      fprintf((FILE *)fp0_00,"\n%s\n",uVar1,local_50);
    }
    if (downloaders != (lynx_list_item_type *)0x0) {
      count = 0;
      cur_download = downloaders;
      while (cur_download != (lynx_list_item_type *)0x0) {
        if ((no_download == '\0') || (cur_download->always_enabled != 0)) {
          fprintf((FILE *)fp0_00,"   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">","LYNXDOWNLOAD:",
                  count,data_file,sug_filename);
          if (cur_download->name == (char *)0x0) {
            local_2c = (char *)gettext("No Name Given");
          }
          else {
            local_2c = cur_download->name;
          }
          fputs(local_2c,(FILE *)fp0_00);
          fwrite("</a>\n",1,5,(FILE *)fp0_00);
        }
        cur_download = (lynx_list_item_type *)cur_download->next;
        count = count + 1;
      }
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYRegisterUIPage(*newfile,UIP_DOWNLOAD_OPTIONS);
    if (sug_filename != (char *)0x0) {
      free(sug_filename);
    }
    return 0;
  }
  return -1;
}



BOOLEAN message_has_content(char *filename,BOOLEAN *nonspaces)

{
  bool bVar1;
  FILE *fp_00;
  ushort **ppuVar2;
  char *pcVar3;
  char *local_1c;
  char *cp;
  char *buffer;
  FILE *fp;
  char firstnonblank;
  BOOLEAN in_headers;
  
  buffer = (char *)0x0;
  bVar1 = true;
  *nonspaces = '\0';
  if ((filename != (char *)0x0) && (fp_00 = (FILE *)fopen64(filename,"r"), fp_00 != (FILE *)0x0)) {
    while( true ) {
      pcVar3 = LYSafeGets(&buffer,fp_00);
      if (pcVar3 == (char *)0x0) {
        if (buffer != (char *)0x0) {
          free(buffer);
          buffer = (char *)0x0;
        }
        LYCloseInput(fp_00);
        return '\0';
      }
      cp = buffer;
      firstnonblank = '\0';
      LYTrimNewline(buffer);
      while (*cp != '\0') {
        if ((firstnonblank == '\0') && (ppuVar2 = __ctype_b_loc(), (short)(*ppuVar2)[(byte)*cp] < 0)
           ) {
          firstnonblank = *cp;
        }
        else {
          ppuVar2 = __ctype_b_loc();
          if (((*ppuVar2)[(byte)*cp] & 0x2000) == 0) {
            *nonspaces = '\x01';
          }
        }
        cp = cp + 1;
      }
      if (((firstnonblank != '\0') && (firstnonblank != '>')) && (!bVar1)) break;
      if (firstnonblank == '\0') {
        bVar1 = false;
      }
    }
    LYCloseInput(fp_00);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
    return '\x01';
  }
  if (WWW_TraceFlag != '\0') {
    if (filename == (char *)0x0) {
      local_1c = "(null)";
    }
    else {
      local_1c = filename;
    }
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"Failed to open file %s for reading!\n",local_1c);
  }
  return '\0';
}



// WARNING: Removing unreachable block (ram,0x080b4a23)
// WARNING: Removing unreachable block (ram,0x080b4a37)
// WARNING: Removing unreachable block (ram,0x080b4a01)
// WARNING: Removing unreachable block (ram,0x080b4a12)

char * LYNewsPost(char *newsgroups,BOOLEAN followup)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *fp_00;
  int iVar3;
  ushort **ppuVar4;
  size_t len_00;
  char *__s;
  char *fmt;
  FILE *fp_01;
  int in_GS_OFFSET;
  undefined *local_a68;
  size_t local_a64;
  char *local_a58;
  char *buffer_1;
  char *buffer;
  FILE *fp;
  char *org;
  char *References;
  char *NewsGroups;
  char *postfile;
  FILE *fc;
  FILE *fd;
  int len;
  int c;
  char *kp;
  char *cp;
  BOOLEAN nonspaces;
  BOOLEAN nonempty;
  char CJKinput [1024];
  char user_input [1024];
  char CJKfile [256];
  char my_tempfile [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp = (char *)0x0;
  fc = (FILE *)0x0;
  postfile = (char *)0x0;
  NewsGroups = (char *)0x0;
  References = (char *)0x0;
  nonempty = '\0';
  nonspaces = '\0';
  if (((newsgroups == (char *)0x0) || (*newsgroups == '\0')) || (no_newspost != '\0'))
  goto LAB_080b5121;
  fp_00 = LYOpenTemp(my_tempfile,".html","w");
  if (fp_00 == (FILE *)0x0) {
    __s = (char *)gettext("Can\'t open temporary file!");
    HTAlert(__s);
    goto LAB_080b5121;
  }
  CJKfile[0] = '\0';
  iVar3 = UCGetLYhndl_byMIME("euc-jp");
  if (((iVar3 == current_char_set) ||
      (iVar3 = UCGetLYhndl_byMIME("shift_jis"), iVar3 == current_char_set)) &&
     (fc = LYOpenTemp(CJKfile,".html","w"), fc == (FILE *)0x0)) {
    __s = (char *)gettext("Can\'t open temporary file!");
    HTAlert(__s);
    LYRemoveTemp(my_tempfile);
    goto LAB_080b5121;
  }
  HTSACopy(&NewsGroups,newsgroups);
  cp = strstr(NewsGroups,";ref=");
  if (cp != (char *)0x0) {
    *cp = '\0';
    cp = cp + 5;
    if (*cp == '<') {
      HTSACopy(&References,cp);
    }
    else {
      HTSACopy(&References,"<");
      HTSACat(&References,cp);
      HTSACat(&References,">");
    }
    HTUnEscape(References);
    cp = strchr(References,0x40);
    if ((((cp == (char *)0x0) || (cp <= References + 1)) ||
        (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp[1]] & 8) == 0)) &&
       (References != (char *)0x0)) {
      free(References);
      References = (char *)0x0;
    }
  }
  HTUnEscape(NewsGroups);
  if (*NewsGroups == '\0') {
    LYCloseTempFP(fp_00);
  }
  else {
    signal(2,terminate_message);
    term_message = '\0';
    LYclear();
    LYmove(2,0);
    scrollok(LYwin,1);
    __s = (char *)gettext("You will be posting to:");
    len_00 = strlen(__s);
    __s = (char *)gettext("You will be posting to:");
    LYwaddnstr(LYwin,__s,len_00);
    LYwaddnstr(LYwin,"\n\t",2);
    len_00 = strlen(NewsGroups);
    LYwaddnstr(LYwin,NewsGroups,len_00);
    waddch(LYwin,10);
    __s = (char *)gettext("\n\n Please provide your mail address for the From: header\n");
    len_00 = strlen(__s);
    __s = (char *)gettext("\n\n Please provide your mail address for the From: header\n");
    LYwaddnstr(LYwin,__s,len_00);
    if (personal_mail_address == (char *)0x0) {
      local_a58 = "";
    }
    else {
      local_a58 = personal_mail_address;
    }
    sprintf(user_input,"From: %.*s",0x3f8,local_a58);
    iVar3 = LYgetstr(user_input,0,0x400,NORECALL);
    if ((iVar3 < 0) || (term_message != '\0')) {
      __s = (char *)gettext("News Post Cancelled!!!");
      HTInfoMsg(__s);
      LYCloseTempFP(fp_00);
      scrollok(LYwin,0);
    }
    else {
      fprintf((FILE *)fp_00,"%s\n",user_input);
      __s = (char *)gettext("\n\n Please provide or edit the Subject: header\n");
      len_00 = strlen(__s);
      __s = (char *)gettext("\n\n Please provide or edit the Subject: header\n");
      LYwaddnstr(LYwin,__s,len_00);
      memcpy(user_input,"Subject: ",10);
      if (((followup == '\x01') && (0 < nhist)) && (__s = HText_getTitle(), __s != (char *)0x0)) {
        kp = LYSkipCBlanks(__s);
        if (HTCJK == JAPANESE) {
          CJKinput[0] = '\0';
          if (kanji_code == EUC) {
            TO_EUC((uchar *)kp,(uchar *)CJKinput);
            kp = CJKinput;
          }
          else {
            if (kanji_code == SJIS) {
              TO_SJIS((uchar *)kp,(uchar *)CJKinput);
              kp = CJKinput;
            }
          }
        }
        iVar3 = strncasecomp(kp,"Re:",3);
        if (iVar3 != 0) {
          local_a64 = 5;
          local_a68 = &DAT_0816321d;
          len_00 = strlen(user_input);
          memcpy(user_input + len_00,local_a68,local_a64);
        }
        len_00 = strlen(user_input);
        LYstrncpy(user_input + len_00,kp,0x3ff - len_00);
      }
      cp = (char *)0x0;
      iVar3 = LYgetstr(user_input,0,0x400,NORECALL);
      if ((iVar3 < 0) || (term_message != '\0')) {
        __s = (char *)gettext("News Post Cancelled!!!");
        HTInfoMsg(__s);
        LYCloseTempFP(fp_00);
        scrollok(LYwin,0);
      }
      else {
        fprintf((FILE *)fp_00,"%s\n",user_input);
        HTSACopy(&cp,"Organization: ");
        __s = LYGetEnv("ORGANIZATION");
        if (__s == (char *)0x0) {
          __s = LYGetEnv("NEWS_ORGANIZATION");
          if (__s == (char *)0x0) {
            fp_01 = (FILE *)fopen64("/etc/organization","r");
            if (fp_01 != (FILE *)0x0) {
              buffer = (char *)0x0;
              __s = LYSafeGets(&buffer,fp_01);
              if ((__s != (char *)0x0) && (user_input[0] != '\0')) {
                LYTrimNewline(buffer);
                HTSACat(&cp,buffer);
              }
              if (buffer != (char *)0x0) {
                free(buffer);
                buffer = (char *)0x0;
              }
              LYCloseInput(fp_01);
            }
          }
          else {
            HTSACat(&cp,__s);
          }
        }
        else {
          HTSACat(&cp,__s);
        }
        LYstrncpy(user_input,cp,0x3f0);
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        __s = (char *)gettext("\n\n Please provide or edit the Organization: header\n");
        len_00 = strlen(__s);
        __s = (char *)gettext("\n\n Please provide or edit the Organization: header\n");
        LYwaddnstr(LYwin,__s,len_00);
        iVar3 = LYgetstr(user_input,0,0x400,NORECALL);
        if ((iVar3 < 0) || (term_message != '\0')) {
          __s = (char *)gettext("News Post Cancelled!!!");
          HTInfoMsg(__s);
          LYCloseTempFP(fp_00);
          scrollok(LYwin,0);
        }
        else {
          fprintf((FILE *)fp_00,"%s\n",user_input);
          if (References != (char *)0x0) {
            fprintf((FILE *)fp_00,"References: %s\n",References);
          }
          fprintf((FILE *)fp_00,"Newsgroups: %s\nSummary: \nKeywords: \n\n",NewsGroups);
          if (((no_editor == '\0') && (editor != (char *)0x0)) && (*editor != '\0')) {
            if ((followup != '\0') && (0 < nhist)) {
              if (term_message == '\0') {
                __s = (char *)gettext("Do you wish to include the original message?");
                BVar2 = HTConfirm(__s);
                if (BVar2 == '\x01') {
                  print_wwwfile_to_fd(fp_00,'\0','\x01');
                }
              }
              else {
                mustshow = '\x01';
                __s = (char *)gettext("Do you wish to include the original message?");
                statusline(__s);
              }
            }
            LYCloseTempFP(fp_00);
            scrollok(LYwin,0);
            if ((term_message == '\0') && (keymap[1] != 0x2f)) {
              __s = (char *)gettext("Spawning your selected editor to edit news message");
              edit_temporary_file(my_tempfile,"",__s);
              nonempty = message_has_content(my_tempfile,&nonspaces);
LAB_080b4d09:
              if (nonempty == '\0') {
                __s = (char *)gettext("Message has no original text!");
                HTAlert(__s);
                if (nonspaces != '\0') {
                  __s = (char *)gettext("Post this message?");
                  iVar3 = HTConfirmDefault(__s,0);
                  if (iVar3 == 1) goto LAB_080b4da1;
                }
              }
              else {
                LYStatusLine = LYlines + -1;
                __s = (char *)gettext("Post this message?");
                BVar2 = HTConfirm(__s);
                LYStatusLine = -1;
                if (BVar2 == '\x01') {
LAB_080b4da1:
                  if ((LynxSigFile != (char *)0x0) &&
                     (fp_00 = (FILE *)fopen64(LynxSigFile,"r"), __s = LynxSigFile,
                     fp_00 != (FILE *)0x0)) {
                    buffer = (char *)0x0;
                    fmt = (char *)gettext("Append \'%s\'?");
                    HTSprintf0(&buffer,fmt,__s);
                    __s = LynxSigFile;
                    LYStatusLine = LYlines + -1;
                    if (term_message == '\0') {
                      BVar2 = HTConfirm(buffer);
                      if ((BVar2 == '\x01') &&
                         (fp_01 = LYAppendToTxtFile(my_tempfile), fp_01 != (FILE *)0x0)) {
                        buffer_1 = (char *)0x0;
                        fwrite(&DAT_081633fe,1,4,(FILE *)fp_01);
                        while (__s = LYSafeGets(&buffer_1,fp_00), __s != (char *)0x0) {
                          fputs(buffer_1,(FILE *)fp_01);
                        }
                        LYCloseOutput(fp_01);
                      }
                    }
                    else {
                      mustshow = '\x01';
                      fmt = (char *)gettext("Append \'%s\'?");
                      user_message(fmt,__s);
                    }
                    LYCloseInput(fp_00);
                    if (buffer != (char *)0x0) {
                      free(buffer);
                      buffer = (char *)0x0;
                    }
                    LYStatusLine = -1;
                  }
                  LYclear();
                  if (CJKfile[0] == '\0') {
                    HTSACopy(&postfile,my_tempfile);
                  }
                  else {
                    fp_00 = (FILE *)fopen64(my_tempfile,"r");
                    if (fp_00 == (FILE *)0x0) {
                      HTSACopy(&postfile,my_tempfile);
                    }
                    else {
                      buffer_1 = (char *)0x0;
                      while (__s = LYSafeGets(&buffer_1,fp_00), __s != (char *)0x0) {
                        TO_JIS((uchar *)buffer_1,(uchar *)CJKinput);
                        fputs(CJKinput,(FILE *)fc);
                      }
                      LYCloseTempFP(fc);
                      HTSACopy(&postfile,CJKfile);
                      LYCloseInput(fp_00);
                      LYRemoveTemp(my_tempfile);
                      strcpy(my_tempfile,CJKfile);
                      CJKfile[0] = '\0';
                    }
                  }
                  if (followup == '\0') {
                    LYforce_no_cache = '\x01';
                  }
                  LYStatusLine = LYlines + -1;
                  __s = (char *)gettext("Posting to newsgroup(s)...");
                  HTUserMsg(__s);
                  LYStatusLine = -1;
                }
                else {
                  LYclear();
                }
              }
            }
          }
          else {
            __s = (char *)gettext("\n\n Please enter your message below.");
            len_00 = strlen(__s);
            __s = (char *)gettext("\n\n Please enter your message below.");
            LYwaddnstr(LYwin,__s,len_00);
            __s = (char *)gettext("\n When you are done, press enter and put a single period (.)");
            len_00 = strlen(__s);
            __s = (char *)gettext("\n When you are done, press enter and put a single period (.)");
            LYwaddnstr(LYwin,__s,len_00);
            __s = (char *)gettext("\n on a line and press enter again.");
            len_00 = strlen(__s);
            __s = (char *)gettext("\n on a line and press enter again.");
            LYwaddnstr(LYwin,__s,len_00);
            LYwaddnstr(LYwin,"\n\n",2);
            LYrefresh();
            user_input[0] = '\0';
            iVar3 = LYgetstr(user_input,0,0x400,NORECALL);
            if ((iVar3 < 0) || (term_message != '\0')) {
              __s = (char *)gettext("News Post Cancelled!!!");
              HTInfoMsg(__s);
              LYCloseTempFP(fp_00);
              scrollok(LYwin,0);
            }
            else {
              do {
                iVar3 = strcmp(user_input,".");
                if ((iVar3 == 0) || (term_message != '\0')) {
                  fputc(10,(FILE *)fp_00);
                  LYCloseTempFP(fp_00);
                  scrollok(LYwin,0);
                  goto LAB_080b4d09;
                }
                waddch(LYwin,10);
                fprintf((FILE *)fp_00,"%s\n",user_input);
                if ((nonempty == '\0') && (user_input[0] != '\0')) {
                  nonempty = '\x01';
                }
                user_input[0] = '\0';
                iVar3 = LYgetstr(user_input,0,0x400,NORECALL);
              } while (-1 < iVar3);
              __s = (char *)gettext("News Post Cancelled!!!");
              HTInfoMsg(__s);
              LYCloseTempFP(fp_00);
              scrollok(LYwin,0);
            }
          }
        }
      }
    }
  }
  signal(2,cleanup_sig);
  term_message = '\0';
  if (postfile == (char *)0x0) {
    LYRemoveTemp(my_tempfile);
  }
  LYRemoveTemp(CJKfile);
  if (NewsGroups != (char *)0x0) {
    free(NewsGroups);
    NewsGroups = (char *)0x0;
  }
  if (References != (char *)0x0) {
    free(References);
    References = (char *)0x0;
  }
LAB_080b5121:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return postfile;
}



void terminate_message(int sig)

{
  term_message = '\x01';
  signal(2,terminate_message);
  return;
}



HTList * LYcommandList(void)

{
  HTList *myList;
  char *data;
  uint j;
  
  if (myList == (HTList *)0x0) {
    myList = HTList_new();
    j = 0;
    while (revmap[j].name != (char *)0x0) {
      if (revmap[j].doc != (char *)0x0) {
        data = (char *)0x0;
        HTSACopy(&data,revmap[j].name);
        HTList_addObject(myList,data);
      }
      j = j + 1;
    }
  }
  return myList;
}



Kcmd * LYKeycodeToKcmd(LYKeymapCode code)

{
  Kcmd *result;
  uint j;
  
  if (code != LYK_UNKNOWN) {
    j = 0;
    while (revmap[j].name != (char *)0x0) {
      if (revmap[j].code == code) {
        return revmap + j;
      }
      j = j + 1;
    }
  }
  return (Kcmd *)0x0;
}



Kcmd * LYStringToKcmd(char *name)

{
  bool bVar1;
  size_t n;
  int iVar2;
  Kcmd *local_28;
  Kcmd *maybe;
  Kcmd *result;
  uint j;
  uint need;
  BOOLEAN exact;
  
  n = strlen(name);
  bVar1 = false;
  result = (Kcmd *)0x0;
  maybe = (Kcmd *)0x0;
  if ((name != (char *)0x0) && (*name != '\0')) {
    j = 0;
    while (revmap[j].name != (char *)0x0) {
      iVar2 = strcasecomp(revmap[j].name,name);
      if (iVar2 == 0) {
        result = revmap + j;
        break;
      }
      if (!bVar1) {
        iVar2 = strncasecomp(revmap[j].name,name,n);
        if (iVar2 == 0) {
          if (maybe == (Kcmd *)0x0) {
            maybe = revmap + j;
          }
          else {
            if ((revmap[j].name[n] != '\0') && (maybe->name[n] != '\0')) {
              maybe = (Kcmd *)0x0;
              bVar1 = true;
            }
          }
        }
      }
      j = j + 1;
    }
  }
  if (result == (Kcmd *)0x0) {
    local_28 = maybe;
  }
  else {
    local_28 = result;
  }
  return local_28;
}



char * LYKeycodeToString(int c,BOOLEAN upper8)

{
  bool bVar1;
  char buf [30];
  uint n;
  BOOLEAN named;
  
  bVar1 = false;
  n = 0;
  do {
    if (0x17 < n) {
LAB_080b53fc:
      if (!bVar1) {
        if ((c < 0x21) || (0x7e < c)) {
          if ((upper8 == '\0') ||
             (((c < 0x21 || (0xff < c)) || (LYlowest_eightbit[current_char_set] < c)))) {
            if (c < 0x20) {
              sprintf((char *)0x81afdb8,"^%c",c | 0x40);
            }
            else {
              if (c < 0x100) {
                sprintf((char *)0x81afdb8,"0x%x",c);
              }
              else {
                sprintf((char *)0x81afdb8,"key-0x%x",c);
              }
            }
          }
          else {
            sprintf((char *)0x81afdb8,"%c",c);
          }
        }
        else {
          sprintf((char *)0x81afdb8,"%c",c);
        }
      }
      return (char *)&ram0x081afdb8;
    }
    if (named_keys[n].key == c) {
      bVar1 = true;
      strcpy((char *)0x81afdb8,named_keys[n].name);
      goto LAB_080b53fc;
    }
    n = n + 1;
  } while( true );
}



int LYStringToKeycode(char *src)

{
  size_t sVar1;
  int iVar2;
  char *dst;
  int len;
  int key;
  uint n;
  
  key = -1;
  sVar1 = strlen(src);
  if (sVar1 == 1) {
    key = (int)*src;
  }
  else {
    if ((sVar1 == 2) && (*src == '^')) {
      key = (int)src[1] & 0x1f;
    }
    else {
      if (((int)sVar1 < 3) || (iVar2 = strncasecomp(src,"0x",2), iVar2 != 0)) {
        if ((6 < (int)sVar1) && (iVar2 = strncasecomp(src,"key-",4), iVar2 == 0)) {
          dst = (char *)0x0;
          key = strtol(src + 4,&dst,0);
          if ((dst == (char *)0x0) || (*dst == '\0')) {
            key = -1;
          }
        }
      }
      else {
        dst = (char *)0x0;
        key = strtol(src,&dst,0);
        if ((dst != (char *)0x0) && (*dst != '\0')) {
          key = -1;
        }
      }
    }
  }
  if (key < 0) {
    n = 0;
    while (n < 0x18) {
      iVar2 = strcasecomp(named_keys[n].name,src);
      if (iVar2 == 0) {
        return named_keys[n].key;
      }
      n = n + 1;
    }
  }
  return key;
}



char * pretty_html(int c)

{
  char cVar1;
  bool bVar2;
  anon_struct_0 table [4];
  char buf [30];
  size_t sVar3;
  char *local_28;
  uint n;
  int adj;
  char *dst;
  char *src;
  BOOLEAN found;
  
  src = LYKeycodeToString(c,'\x01');
  if (src == (char *)0x0) {
    local_28 = (char *)0x0;
  }
  else {
    dst = &ram0x081afdd6;
    adj = 0;
    while( true ) {
      cVar1 = *src;
      src = src + 1;
      if ((int)cVar1 == 0) break;
      bVar2 = false;
      n = 0;
      while (n < 4) {
        if (((anon_struct_0 *)&ram0x08164cc0)[n].code == (int)cVar1) {
          bVar2 = true;
          strcpy(dst,*(char **)(n * 8 + 0x8164cc4));
          sVar3 = strlen(dst);
          adj = sVar3 + adj + -1;
          sVar3 = strlen(dst);
          dst = dst + sVar3;
          break;
        }
        n = n + 1;
      }
      if (!bVar2) {
        *dst = cVar1;
        dst = dst + 1;
      }
    }
    adj = adj + (0x81afde1 - (int)dst);
    while (bVar2 = 0 < adj, adj = adj + -1, bVar2) {
      *dst = ' ';
      dst = dst + 1;
    }
    *dst = '\0';
    local_28 = (char *)0x81afdd6;
  }
  return local_28;
}



char * format_binding(LYKeymap_t *table,int i)

{
  Kcmd *pKVar1;
  char *pcVar2;
  Kcmd *rmap;
  char *formatted;
  char *buf;
  LYKeymapCode the_key;
  
  buf = (char *)0x0;
  pKVar1 = LYKeycodeToKcmd((uint)table[i]);
  if ((((pKVar1 != (Kcmd *)0x0) && (pKVar1->name != (char *)0x0)) && (pKVar1->doc != (char *)0x0))
     && (pcVar2 = pretty_html(i + -1), pcVar2 != (char *)0x0)) {
    HTSprintf0(&buf,"%-*s %-13s %s\n",0xb,pcVar2,pKVar1->name,pKVar1->doc);
    return buf;
  }
  return (char *)0x0;
}



void print_binding(HTStream *target,int i,BOOLEAN both)

{
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar1;
  char *__s;
  size_t sVar2;
  LYKeymapCode lac1;
  char *buf;
  
  lac1 = LYK_UNKNOWN;
  if (((prev_lynx_edit_mode == '\0') || (no_dired_support != '\0')) ||
     (lac1 = (LYKeymapCode)key_override[i], key_override[i] == 0)) {
    __s = format_binding(keymap,i);
    if (__s != (char *)0x0) {
      lac1 = (LYKeymapCode)keymap[i];
      paVar1 = target->isa->put_block;
      sVar2 = strlen(__s);
      (*paVar1)(target,__s,sVar2);
      if (__s != (char *)0x0) {
        free(__s);
      }
    }
  }
  else {
    __s = format_binding(key_override,i);
    if (__s != (char *)0x0) {
      paVar1 = target->isa->put_block;
      sVar2 = strlen(__s);
      (*paVar1)(target,__s,sVar2);
      if (__s != (char *)0x0) {
        free(__s);
      }
    }
  }
  if (both != '\0') {
    i = i + -0x20;
    if (((prev_lynx_edit_mode == '\0') || (no_dired_support != '\0')) || (key_override[i] == 0)) {
      if ((uint)keymap[i] != lac1) {
        __s = format_binding(keymap,i);
        if (__s != (char *)0x0) {
          paVar1 = target->isa->put_block;
          sVar2 = strlen(__s);
          (*paVar1)(target,__s,sVar2);
          if (__s != (char *)0x0) {
            free(__s);
          }
        }
      }
    }
    else {
      if ((uint)key_override[i] != lac1) {
        __s = format_binding(key_override,i);
        if (__s != (char *)0x0) {
          paVar1 = target->isa->put_block;
          sVar2 = strlen(__s);
          (*paVar1)(target,__s,sVar2);
          if (__s != (char *)0x0) {
            free(__s);
          }
        }
      }
    }
  }
  return;
}



int lacname_to_lac(char *func)

{
  Kcmd *pKVar1;
  LYKeymapCode local_18;
  Kcmd *mp;
  
  pKVar1 = LYStringToKcmd(func);
  if (pKVar1 == (Kcmd *)0x0) {
    local_18 = ~LYK_UNKNOWN;
  }
  else {
    local_18 = pKVar1->code;
  }
  return local_18;
}



int lecname_to_lec(char *func)

{
  int iVar1;
  emap *mp;
  int i;
  
  if ((func != (char *)0x0) && (*func != '\0')) {
    mp = ekmap;
    while (mp->name != (char *)0x0) {
      iVar1 = strcmp(mp->name,func);
      if (iVar1 == 0) {
        return mp->code;
      }
      mp = mp + 1;
    }
  }
  return -1;
}



int lkcstring_to_lkc(char *src)

{
  size_t sVar1;
  ushort **ppuVar2;
  int iVar3;
  int local_18;
  int c;
  
  c = -1;
  sVar1 = strlen(src);
  if (sVar1 == 1) {
    c = (int)*src;
  }
  else {
    sVar1 = strlen(src);
    if ((sVar1 == 2) && (*src == '^')) {
      c = (int)src[1] & 0x1f;
    }
    else {
      sVar1 = strlen(src);
      if ((sVar1 < 2) || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*src] & 0x800) == 0)) {
        map_string_to_keysym(src,&c);
        if (-1 < c) {
          if ((0xff < (c & 0x7ffU)) && ((c & 0x400U) == 0)) {
            return -1;
          }
          c = c & 0xfffffbff;
        }
      }
      else {
        iVar3 = sscanf(src,"%i",&c);
        if (iVar3 != 1) {
          return -1;
        }
      }
    }
  }
  if (c == 0x1b) {
    escape_bound = 1;
  }
  if (c < -1) {
    local_18 = -1;
  }
  else {
    local_18 = c;
  }
  return local_18;
}



int LYLoadKeymap(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar3;
  HTAtom *rep_in;
  HTStream *target_00;
  char *fmt;
  undefined4 uVar4;
  size_t sVar5;
  ushort **ppuVar6;
  int local_20;
  int i;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  
  rep_in = HTAtom_for("text/html");
  buf = (char *)0x0;
  target_00 = HTStreamStack((HTFormat)rep_in,format_out,sink,anAnchor);
  if ((target_00 == (HTStream *)0x0) || (target_00 == (HTStream *)0x0)) {
    pcVar1 = format_out->name;
    pcVar2 = rep_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf,fmt,pcVar2,pcVar1);
    HTAlert(buf);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_20 = -29999;
  }
  else {
    anAnchor->no_cache = '\x01';
    uVar4 = gettext("Current Key Map");
    HTSprintf0(&buf,"<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",uVar4);
    paVar3 = target_00->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(target_00,buf,sVar5);
    HTSprintf0(&buf,"<pre>\n");
    paVar3 = target_00->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(target_00,buf,sVar5);
    i = 0x62;
    while (i < 0x7c) {
      print_binding(target_00,i,'\x01');
      i = i + 1;
    }
    i = 1;
    while (i < 0x295) {
      if ((i < 0x80) && (0x20 < i)) {
        ppuVar6 = __ctype_b_loc();
        if (((*ppuVar6)[(1 - i) * 0x7fffffff] & 0x400) == 0) goto LAB_080b5dac;
      }
      else {
LAB_080b5dac:
        if ((LYUseMouse != '\0') || (keymap[i] != 0x54)) {
          print_binding(target_00,i,'\0');
        }
      }
      i = i + 1;
    }
    HTSprintf0(&buf,"</pre>\n</body>\n</html>\n");
    paVar3 = target_00->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar3)(target_00,buf,sVar5);
    (*target_00->isa->_free)(target_00);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_20 = 200;
  }
  return local_20;
}



int remap(char *key,char *func,BOOLEAN for_dired)

{
  Kcmd *pKVar1;
  uint local_20;
  uint local_1c;
  int c;
  Kcmd *mp;
  
  if (func == (char *)0x0) {
    local_20 = 0;
  }
  else {
    c = lkcstring_to_lkc(key);
    if (c < 0) {
      local_20 = 0;
    }
    else {
      if (-1 < c) {
        if ((c & 0x8800U) != 0) {
          return 0;
        }
        if ((c & 0x7ffU) != c) {
          c = c & 0x7ff;
        }
      }
      if (c + 1 < 0x295) {
        pKVar1 = LYStringToKcmd(func);
        if (pKVar1 == (Kcmd *)0x0) {
          local_20 = 0;
        }
        else {
          if (for_dired == '\0') {
            keymap[c + 1] = (LYKeymap_t)pKVar1->code;
          }
          else {
            key_override[c + 1] = (LYKeymap_t)pKVar1->code;
          }
          if (c == 0) {
            local_1c = pKVar1->code | 0x800;
          }
          else {
            local_1c = c;
          }
          local_20 = local_1c;
        }
      }
      else {
        local_20 = 0;
      }
    }
  }
  return local_20;
}



void set_any_keys(ANY_KEYS *table,int size)

{
  int iVar1;
  int k;
  int j;
  
  j = 0;
  while (j < size) {
    iVar1 = table[j].code + 1;
    table[j].save = keymap[iVar1];
    keymap[iVar1] = table[j].map;
    j = j + 1;
  }
  return;
}



void reset_any_keys(ANY_KEYS *table,int size)

{
  int k;
  int j;
  
  j = 0;
  while (j < size) {
    keymap[table[j].code + 1] = table[j].save;
    j = j + 1;
  }
  return;
}



void set_vms_keys(void)

{
  set_any_keys(vms_keys_table,2);
  return;
}



void set_vi_keys(void)

{
  set_any_keys(vi_keys_table,4);
  did_vi_keys = '\x01';
  return;
}



void reset_vi_keys(void)

{
  if (did_vi_keys != '\0') {
    reset_any_keys(vi_keys_table,4);
    did_vi_keys = '\0';
  }
  return;
}



void set_emacs_keys(void)

{
  set_any_keys(emacs_keys_table,4);
  did_emacs_keys = '\x01';
  return;
}



void reset_emacs_keys(void)

{
  if (did_emacs_keys != '\0') {
    reset_any_keys(emacs_keys_table,4);
    did_emacs_keys = '\0';
  }
  return;
}



void set_numbers_as_arrows(void)

{
  set_any_keys(number_keys_table,9);
  did_number_keys = '\x01';
  return;
}



void reset_numbers_as_arrows(void)

{
  if (did_number_keys != '\0') {
    reset_any_keys(number_keys_table,9);
    did_number_keys = '\0';
  }
  return;
}



char * key_for_func(int func)

{
  char *buf;
  int c;
  char *local_18;
  char *formatted;
  int i;
  
  c = LYReverseKeymap(func);
  if (c < 0) {
    if (buf == (char *)0x0) {
      HTSACopy((char **)0x81afdf4,"");
    }
  }
  else {
    local_18 = LYKeycodeToString(c,'\x01');
    if (local_18 == (char *)0x0) {
      local_18 = "?";
    }
    HTSACopy((char **)0x81afdf4,local_18);
  }
  return buf;
}



char * fmt_keys(int lkc_first,int lkc_second)

{
  bool bVar1;
  char *pcVar2;
  char *__s;
  size_t sVar3;
  undefined *local_20;
  undefined *local_1c;
  char *fmt_second;
  char *fmt_first;
  char *buf;
  BOOLEAN quotes;
  
  buf = (char *)0x0;
  bVar1 = false;
  if (lkc_first < 0) {
    return (char *)0x0;
  }
  __s = LYKeycodeToString(lkc_first,'\x01');
  if (((__s != (char *)0x0) && (sVar3 = strlen(__s), sVar3 == 1)) && (*__s != '\'')) {
    bVar1 = true;
  }
  if (bVar1) {
    if (lkc_second < 0) {
      HTSprintf0(&buf,"\'%s\'",__s);
      return buf;
    }
    HTSprintf0(&buf,"\'%s",__s);
  }
  else {
    HTSACopy(&buf,__s);
  }
  if (-1 < lkc_second) {
    __s = LYKeycodeToString(lkc_second,'\x01');
    if (__s == (char *)0x0) {
      if (buf != (char *)0x0) {
        free(buf);
      }
      return (char *)0x0;
    }
    if (bVar1) {
      local_20 = &DAT_08164d9d;
    }
    else {
      local_20 = &DAT_081646f7;
    }
    sVar3 = strlen(__s);
    if (((sVar3 < 3) || (*__s == '<')) &&
       ((sVar3 = strlen(buf), pcVar2 = buf, sVar3 < 3 ||
        (sVar3 = strlen(buf), pcVar2[sVar3 - 1] == '>')))) {
      local_1c = &DAT_081646f7;
    }
    else {
      local_1c = &DAT_08164d9f;
    }
    HTSprintf(&buf,"%s%s%s",local_1c,__s,local_20);
  }
  return buf;
}



int best_reverse_keymap(int lac)

{
  uint local_40;
  uint local_3c;
  uint local_34;
  uint local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int c;
  int i;
  
  i = 0x61;
  while( true ) {
    if (i < 0) {
      return -1;
    }
    if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
      if (i == -1) {
        local_40 = (uint)key_override[0];
      }
      else {
        if ((i & 0x8800U) == 0) {
          local_3c = (uint)key_override[(i & 0x7ffU) + 1];
        }
        else {
          local_3c = i & 0xff;
        }
        local_40 = local_3c;
      }
      if (local_40 == lac) {
        return i;
      }
    }
    if (i == -1) {
      local_34 = (uint)keymap[0];
    }
    else {
      if ((i & 0x8800U) == 0) {
        local_30 = (uint)keymap[(i & 0x7ffU) + 1];
      }
      else {
        local_30 = i & 0xff;
      }
      local_34 = local_30;
    }
    if (local_34 == lac) break;
    if (i == 0x7a) {
      local_2c = 0x20;
    }
    else {
      if (i == 0x60) {
        local_28 = 0x7b;
      }
      else {
        if (i == 0x7e) {
          local_24 = 0;
        }
        else {
          if (i == 0x1f) {
            local_20 = 0x100;
          }
          else {
            if (i == 0x293) {
              local_1c = 0x7f;
            }
            else {
              if (i == 0xff) {
                local_18 = -1;
              }
              else {
                local_18 = i + 1;
              }
              local_1c = local_18;
            }
            local_20 = local_1c;
          }
          local_24 = local_20;
        }
        local_28 = local_24;
      }
      local_2c = local_28;
    }
    i = local_2c;
  }
  return i;
}



char * key_for_func_ext(int lac,int context_code)

{
  uint lkc_first;
  char *pcVar1;
  int lkc_first_00;
  char *local_18;
  int modkey;
  int lkc;
  
  modkey = -1;
  if ((context_code == 2) && (lkc_first = LYEditKeyForAction(lac,&modkey), -1 < (int)lkc_first)) {
    if ((lkc_first & 0x7000) != 0) {
      pcVar1 = fmt_keys(modkey,lkc_first & 0xffff8fff);
      return pcVar1;
    }
    pcVar1 = fmt_keys(lkc_first,-1);
    return pcVar1;
  }
  lkc_first_00 = best_reverse_keymap(lac);
  if (lkc_first_00 < 0) {
    local_18 = (char *)0x0;
  }
  else {
    if (context_code == 2) {
      modkey = LYKeyForEditAction(0x17);
      if (modkey < 0) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = fmt_keys(modkey,lkc_first_00);
      }
    }
    else {
      local_18 = fmt_keys(lkc_first_00,-1);
    }
  }
  return local_18;
}



BOOLEAN LYisNonAlnumKeyname(int ch,int KeyName)

{
  char *pcVar1;
  bool local_5;
  
  if ((ch < 0) || (0x294 < ch)) {
    local_5 = false;
  }
  else {
    if ((0 < ch) &&
       (pcVar1 = strchr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",ch),
       pcVar1 != (char *)0x0)) {
      return '\0';
    }
    local_5 = (uint)keymap[ch + 1] == KeyName;
  }
  return (BOOLEAN)local_5;
}



int LYReverseKeymap(int KeyName)

{
  int i;
  
  i = 1;
  while( true ) {
    if (0x294 < i) {
      return -1;
    }
    if ((uint)keymap[i] == KeyName) break;
    i = i + 1;
  }
  return i + -1;
}



void strtolower(char *i)

{
  ushort **ppuVar1;
  int iVar2;
  char local_5;
  
  if (i != (char *)0x0) {
    while (*i != '\0') {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)*i] & 0x100) == 0) {
        local_5 = *i;
      }
      else {
        iVar2 = tolower((uint)(byte)*i);
        local_5 = (char)iVar2;
      }
      *i = local_5;
      i = i + 1;
    }
  }
  return;
}



void actually_set_style(HTStructured *me)

{
  LYUCcharset *p_out;
  int cs_out;
  HText *pHVar1;
  
  if (me->text == (HText *)0x0) {
    LYGetChartransInfo(me);
    p_out = HTAnchor_getUCInfoStage(me->node_anchor,3);
    cs_out = HTAnchor_getUCLYhndl(me->node_anchor,3);
    UCSetTransParams(&me->T,me->UCLYhndl,me->UCI,cs_out,p_out);
    pHVar1 = HText_new2(me->node_anchor,me->target);
    me->text = pHVar1;
    HText_beginAppend(me->text);
    HText_setStyle(me->text,me->new_style);
    me->in_word = '\0';
    LYCheckForContentBase(me);
  }
  else {
    HText_setStyle(me->text,me->new_style);
  }
  me->old_style = me->new_style;
  me->style_change = '\0';
  return;
}



void change_paragraph_style(HTStructured *me,HTStyle *style)

{
  if (me->new_style != style) {
    me->style_change = '\x01';
    me->new_style = style;
  }
  me->in_word = '\0';
  return;
}



BOOLEAN LYBadHTML(HTStructured *me)

{
  char *Msg;
  BOOLEAN local_5;
  
  if ((WWW_TraceFlag == '\0') && (me->inBadHTML == '\0')) {
    Msg = (char *)gettext("** Bad HTML!!  Use -trace to diagnose. **");
    HTUserMsg(Msg);
    me->inBadHTML = '\x01';
    local_5 = '\0';
  }
  else {
    local_5 = '\x01';
  }
  return local_5;
}



void HTML_put_character(HTStructured *me,char c)

{
  int iVar1;
  char cVar2;
  char local_8;
  
  local_8 = c;
  if ((LYMapsOnly != '\0') && (me->sp->tag_number != 0x4f)) {
    return;
  }
  if ((me->lastraw == 0xd) && (c == '\n')) {
    me->lastraw = -1;
    return;
  }
  me->lastraw = (int)c;
  if (c == '\r') {
    local_8 = '\n';
  }
  switch(me->sp->tag_number) {
  case 0x1c:
    break;
  default:
    if ((me->inSELECT != '\0') && (me->sp->tag_number != 0)) {
      HTChunkPutc((HTChunk *)&me->option,local_8);
      return;
    }
    iVar1 = me->sp->tag_number;
    if (iVar1 == 0x55) {
LAB_080b6adf:
      if (local_8 != '\r') {
        me->inP = '\x01';
        me->inLABEL = '\0';
        HText_appendCharacter(me->text,(int)local_8);
      }
    }
    else {
      if (iVar1 < 0x56) {
        if (iVar1 == 0x46) goto LAB_080b6adf;
      }
      else {
        if (iVar1 == 0x56) {
          if ((local_8 != '\r') &&
             ((((local_8 != '\n' || (me->inLABEL == '\0')) || (me->inP != '\0')) &&
              ((local_8 != '\n' || (me->inPRE != '\0')))))) {
            me->inP = '\x01';
            me->inLABEL = '\0';
            HText_appendCharacter(me->text,(int)local_8);
          }
          me->inPRE = '\x01';
          goto LAB_080b6d21;
        }
        if (iVar1 == 0x75) goto LAB_080b6adf;
      }
      if (me->sp->style->id == 0x25) {
        if ((local_8 != '\r') &&
           ((((local_8 != '\n' || (me->inLABEL == '\0')) || (me->inP != '\0')) &&
            ((local_8 != '\n' || (me->inPRE != '\0')))))) {
          me->inP = '\x01';
          me->inLABEL = '\0';
          HText_appendCharacter(me->text,(int)local_8);
        }
        me->inPRE = '\x01';
      }
      else {
        if ((me->sp->style->id == 0x26) || (me->sp->style->id == 0x24)) {
          if (local_8 != '\r') {
            me->inP = '\x01';
            me->inLABEL = '\0';
            HText_appendCharacter(me->text,(int)local_8);
          }
        }
        else {
          if (me->style_change != '\0') {
            if (local_8 == '\n') {
              return;
            }
            if (local_8 == ' ') {
              return;
            }
            if (me->style_change != '\0') {
              actually_set_style(me);
            }
          }
          if (local_8 == '\n') {
            if (me->in_word != '\0') {
              cVar2 = HText_getLastChar(me->text);
              if (cVar2 != ' ') {
                me->inP = '\x01';
                me->inLABEL = '\0';
                HText_appendCharacter(me->text,0x20);
              }
              me->in_word = '\0';
            }
          }
          else {
            if ((local_8 == ' ') || (local_8 == '\t')) {
              cVar2 = HText_getLastChar(me->text);
              if (cVar2 != ' ') {
                me->inP = '\x01';
                me->inLABEL = '\0';
                HText_appendCharacter(me->text,0x20);
              }
            }
            else {
              if (local_8 != '\r') {
                me->inP = '\x01';
                me->inLABEL = '\0';
                HText_appendCharacter(me->text,(int)local_8);
                me->in_word = '\x01';
              }
            }
          }
        }
      }
    }
LAB_080b6d21:
    if ((local_8 == '\n') || (local_8 == '\t')) {
      HText_setLastChar(me->text,' ');
    }
    else {
      if ((local_8 == '\r') && (cVar2 = HText_getLastChar(me->text), cVar2 == ' ')) {
        HText_setLastChar(me->text,' ');
      }
      else {
        HText_setLastChar(me->text,local_8);
      }
    }
    break;
  case 0x49:
    HTChunkPutc((HTChunk *)&me->math,local_8);
    break;
  case 0x4f:
    HTChunkPutc((HTChunk *)&me->object,local_8);
    break;
  case 0x51:
  case 0x5b:
    HTChunkPutc((HTChunk *)&me->option,local_8);
    break;
  case 0x5a:
    HTChunkPutc((HTChunk *)&me->script,local_8);
    break;
  case 0x62:
    HTChunkPutc((HTChunk *)&me->style_block,local_8);
    break;
  case 0x69:
    HTChunkPutc((HTChunk *)&me->textarea,local_8);
    break;
  case 0x6e:
    if (local_8 != '\a') {
      if (((local_8 == '\n') || (local_8 == '\t')) || (local_8 == '\r')) {
        HTChunkPutc((HTChunk *)&me->title,' ');
      }
      else {
        HTChunkPutc((HTChunk *)&me->title,local_8);
      }
    }
  }
  return;
}



void HTML_put_string(HTStructured *me,char *s)

{
  char cVar1;
  char *p;
  char *translated_string;
  char c;
  
  translated_string = (char *)0x0;
  if (s == (char *)0x0) {
    return;
  }
  if ((LYMapsOnly != '\0') && (me->sp->tag_number != 0x4f)) {
    return;
  }
  if (psrc_convert_string != '\0') {
    HTSACopy(&translated_string,s);
    LYUCTranslateHTMLString
              (&translated_string,me->tag_charset,current_char_set,'\x01','\x01','\0',st_HTML);
    s = translated_string;
  }
  switch(me->sp->tag_number) {
  case 0x1c:
    break;
  default:
    if (me->sp->style->freeFormat == '\0') {
      if (psrc_view == '\0') {
        HText_appendText(me->text,s);
      }
      else {
        while (*s != '\0') {
          HTML_put_character(me,*s);
          s = s + 1;
        }
      }
    }
    else {
      p = s;
      if (me->style_change != '\0') {
        while ((*p != '\0' && ((((*p == '\n' || (*p == '\r')) || (*p == ' ')) || (*p == '\t'))))) {
          p = p + 1;
        }
        if (*p == '\0') break;
        if (me->style_change != '\0') {
          actually_set_style(me);
        }
      }
      while (*p != '\0') {
        if ((*p == '\r') && (p[1] != '\n')) {
          c = '\n';
        }
        else {
          c = *p;
        }
        if (me->style_change == '\0') {
LAB_080b7080:
          if (c == '\n') {
            if (me->in_word != '\0') {
              cVar1 = HText_getLastChar(me->text);
              if (cVar1 != ' ') {
                HText_appendCharacter(me->text,0x20);
              }
              me->in_word = '\0';
            }
          }
          else {
            if ((c == ' ') || (c == '\t')) {
              cVar1 = HText_getLastChar(me->text);
              if (cVar1 != ' ') {
                HText_appendCharacter(me->text,0x20);
              }
            }
            else {
              if (c != '\r') {
                HText_appendCharacter(me->text,(int)c);
                me->in_word = '\x01';
              }
            }
          }
          if ((c == '\n') || (c == '\t')) {
            HText_setLastChar(me->text,' ');
          }
          else {
            if ((c == '\r') && (cVar1 = HText_getLastChar(me->text), cVar1 == ' ')) {
              HText_setLastChar(me->text,' ');
            }
            else {
              HText_setLastChar(me->text,c);
            }
          }
        }
        else {
          if (((c != '\n') && (c != ' ')) && (c != '\t')) {
            if (me->style_change != '\0') {
              actually_set_style(me);
            }
            goto LAB_080b7080;
          }
        }
        p = p + 1;
      }
    }
    break;
  case 0x46:
  case 0x55:
  case 0x56:
  case 0x75:
    HText_appendText(me->text,s);
    break;
  case 0x49:
    HTChunkPuts((HTChunk *)&me->math,s);
    break;
  case 0x4f:
    HTChunkPuts((HTChunk *)&me->object,s);
    break;
  case 0x51:
  case 0x5b:
    HTChunkPuts((HTChunk *)&me->option,s);
    break;
  case 0x5a:
    HTChunkPuts((HTChunk *)&me->script,s);
    break;
  case 0x62:
    HTChunkPuts((HTChunk *)&me->style_block,s);
    break;
  case 0x69:
    HTChunkPuts((HTChunk *)&me->textarea,s);
    break;
  case 0x6e:
    HTChunkPuts((HTChunk *)&me->title,s);
  }
  if ((psrc_convert_string != '\0') &&
     (psrc_convert_string = '\0', translated_string != (char *)0x0)) {
    free(translated_string);
  }
  return;
}



void HTML_write(HTStructured *me,char *s,int l)

{
  char *e;
  char *p;
  
  if ((LYMapsOnly == '\0') || (me->sp->tag_number == 0x4f)) {
    p = s;
    while (p < s + l) {
      HTML_put_character(me,*p);
      p = p + 1;
    }
  }
  return;
}



void addClassName(char *prefix,char *actual,int length)

{
  size_t sVar1;
  char *pcVar2;
  uint need;
  uint have;
  int offset;
  
  sVar1 = strlen(prefix);
  pcVar2 = Style_className_end + -(int)Style_className;
  if (Style_className_len <= pcVar2 + sVar1 + length + 1) {
    Style_className_len = (int)(pcVar2 + sVar1 + length + 0x201) * 2 + Style_className_len;
    if (Style_className == (char *)0x0) {
      Style_className = (char *)malloc(Style_className_len);
    }
    else {
      Style_className = (char *)realloc(Style_className,Style_className_len);
    }
    if (Style_className == (char *)0x0) {
      outofmem("./HTML.c","addClassName");
    }
    Style_className_end = Style_className + (int)pcVar2;
  }
  if (sVar1 != 0) {
    strcpy(Style_className_end,prefix);
  }
  if (length != 0) {
    memcpy(Style_className_end + sVar1,actual,length);
  }
  Style_className_end[sVar1 + length] = '\0';
  strtolower(Style_className_end);
  Style_className_end = Style_className_end + sVar1 + length;
  return;
}



void HTMLSRC_apply_markup(HTStructured *context,HTlexeme lexeme,BOOLEAN start,int tag_charset)

{
  FILE *__stream;
  HT_tagspec **local_28;
  char *local_20;
  HT_tagspec *ts;
  
  if (start == '\0') {
    local_28 = lexeme_end;
  }
  else {
    local_28 = lexeme_start;
  }
  ts = local_28[lexeme];
  while (ts != (HT_tagspec *)0x0) {
    if (ts->start != '\0') {
      current_tag_style = ts->style;
      force_current_tag_style = '\x01';
      forced_classname = ts->class_name;
      force_classname = '\x01';
    }
    if (WWW_TraceFlag != '\0') {
      if (ts->start == '\0') {
        local_20 = "SRCSTOP %d\n";
      }
      else {
        local_20 = "SRCSTART %d\n";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,local_20,lexeme);
    }
    if (ts->start == '\0') {
      HTML_end_element(context,ts->element,(char **)0x0);
    }
    else {
      HTML_start_element(context,ts->element,ts->present,ts->value,tag_charset,(char **)0x0);
    }
    ts = (HT_tagspec *)ts->next;
  }
  return;
}



void LYStartArea(HTStructured *obj,char *href,char *alt,char *title,int tag_charset)

{
  int iVar1;
  int in_GS_OFFSET;
  char *new_value [18];
  int i;
  BOOLEAN new_present [18];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x12) {
    new_present[i] = '\0';
    i = i + 1;
  }
  if (alt != (char *)0x0) {
    new_present[1] = '\x01';
    new_value[1] = alt;
  }
  if ((title != (char *)0x0) && (*title != '\0')) {
    new_present[17] = '\x01';
    new_value[17] = title;
  }
  if (href != (char *)0x0) {
    new_present[6] = '\x01';
    new_value[6] = href;
  }
  (*obj->isa->start_element)(obj,5,new_present,new_value,tag_charset,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void LYHandleFIG(HTStructured *me,BOOLEAN *present,char **value,BOOLEAN isobject,BOOLEAN imagemap,
                char *id,char *src,BOOLEAN convert,BOOLEAN start,BOOLEAN *intern_flag)

{
  HTChildAnchor *pHVar1;
  BOOLEAN local_38;
  HTLinkType *local_34;
  char *local_30;
  char *local_2c;
  char *href;
  
  if (start == '\x01') {
    me->inFIG = '\x01';
    if (me->inA != '\0') {
      if (tags[0].contents != SGML_EMPTY) {
        me->skip_stack = me->skip_stack + 1;
      }
      HTML_end_element(me,0,(char **)0x0);
    }
    if (isobject == '\0') {
      LYEnsureDoubleSpace(me);
      LYResetParagraphAlignment(me);
      me->inFIGwithP = '\x01';
    }
    else {
      me->inFIGwithP = '\0';
      HTML_put_character(me,' ');
    }
    if ((id != (char *)0x0) && (*id != '\0')) {
      if ((present == (BOOLEAN *)0x0) || (convert == '\0')) {
        LYHandleID(me,id);
      }
      else {
        LYCheckForID(me,present,value,6);
      }
    }
    me->in_word = '\0';
    me->inP = '\0';
    if (((clickable_images != '\0') && (src != (char *)0x0)) && (*src != '\0')) {
      href = (char *)0x0;
      HTSACopy(&href,src);
      if ((href == (char *)0x0) || ((*href != '#' && (*href != '\0')))) {
        local_38 = '\0';
      }
      else {
        local_38 = '\x01';
      }
      *intern_flag = local_38;
      LYLegitimizeHREF(me,&href,'\x01','\x01');
      if (*href != '\0') {
        if (intern_flag == (BOOLEAN *)0x0) {
          local_34 = (HTLinkType *)0x0;
        }
        else {
          local_34 = HTInternalLink;
        }
        pHVar1 = HTAnchor_findChildAndLink(me->node_anchor,(char *)0x0,href,local_34);
        me->CurrentA = pHVar1;
        HText_beginAnchor(me->text,me->inUnderline,me->CurrentA);
        if (me->inBoldH == '\0') {
          HText_appendCharacter(me->text,5);
        }
        if (isobject == '\0') {
          local_30 = "[FIGURE]";
        }
        else {
          if (imagemap == '\0') {
            local_2c = "(OBJECT)";
          }
          else {
            local_2c = "(IMAGE)";
          }
          local_30 = local_2c;
        }
        HTML_put_string(me,local_30);
        if (me->inBoldH == '\0') {
          HText_appendCharacter(me->text,6);
        }
        HText_endAnchor(me->text,0);
        HTML_put_character(me,'-');
        HTML_put_character(me,' ');
        me->in_word = '\0';
      }
      if (href != (char *)0x0) {
        free(href);
      }
    }
  }
  else {
    if (me->inFIGwithP == '\0') {
      HTML_put_character(me,' ');
    }
    else {
      LYEnsureDoubleSpace(me);
    }
    LYResetParagraphAlignment(me);
    me->inFIGwithP = '\0';
    me->inFIG = '\0';
    change_paragraph_style(me,me->sp->style);
    if (-1 < me->List_Nesting_Level) {
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      HText_NegateLineOne(me->text);
    }
  }
  return;
}



void clear_objectdata(HTStructured *me)

{
  if (me != (HTStructured *)0x0) {
    HTChunkClear((HTChunk *)&me->object);
    me->object_started = '\0';
    me->object_declare = '\0';
    me->object_shapes = '\0';
    me->object_ismap = '\0';
    if (me->object_usemap != (char *)0x0) {
      free(me->object_usemap);
      me->object_usemap = (char *)0x0;
    }
    if (me->object_id != (char *)0x0) {
      free(me->object_id);
      me->object_id = (char *)0x0;
    }
    if (me->object_title != (char *)0x0) {
      free(me->object_title);
      me->object_title = (char *)0x0;
    }
    if (me->object_data != (char *)0x0) {
      free(me->object_data);
      me->object_data = (char *)0x0;
    }
    if (me->object_type != (char *)0x0) {
      free(me->object_type);
      me->object_type = (char *)0x0;
    }
    if (me->object_classid != (char *)0x0) {
      free(me->object_classid);
      me->object_classid = (char *)0x0;
    }
    if (me->object_codebase != (char *)0x0) {
      free(me->object_codebase);
      me->object_codebase = (char *)0x0;
    }
    if (me->object_codetype != (char *)0x0) {
      free(me->object_codetype);
      me->object_codetype = (char *)0x0;
    }
    if (me->object_name != (char *)0x0) {
      free(me->object_name);
      me->object_name = (char *)0x0;
    }
  }
  return;
}


/*
Unable to decompile 'HTML_start_element'
Cause: Exception while decompiling 080b7abc: process: timeout

*/


// WARNING: Removing unreachable block (ram,0x080cccc9)

int HTML_end_element(HTStructured *me,int element_number,char **include)

{
  int iVar1;
  stack_element *psVar2;
  bool bVar3;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *__stream;
  int iVar6;
  ushort **ppuVar7;
  size_t sVar8;
  char *src;
  int in_GS_OFFSET;
  bool bVar9;
  int local_200;
  char *local_1fc;
  char *local_1f8;
  char *local_1f4;
  char *local_1f0;
  char *local_1ec;
  char *local_1e8;
  char *local_1e4;
  undefined1 *local_1e0;
  undefined1 *local_1dc;
  char *local_1d8;
  undefined1 *local_1d4;
  char *local_1d0;
  char *local_1cc;
  char *local_1c8;
  undefined1 *local_1c4;
  undefined1 *local_1c0;
  char *local_1bc;
  undefined1 *local_1b8;
  char *local_1b4;
  int local_1b0;
  undefined1 *local_1ac;
  char local_1a1;
  char local_199;
  char **local_198;
  InputFieldData I;
  HTkcode specified_kcode;
  HTkcode kcode;
  char *ptr;
  int j_1;
  int j;
  char *data_1;
  int chars;
  char *data;
  char *last_map;
  char *first_map;
  char *last_end;
  char *first_end;
  char *start;
  int e;
  int s;
  int tag_charset;
  HTTag *tag;
  char *cp;
  char *temp;
  int status;
  int i;
  BOOLEAN have_param;
  BOOLEAN reached_awaited_stacked_elt;
  BOOLEAN skip_stack_requested;
  BOOLEAN intern_flag;
  BOOLEAN BreakFlag;
  char buf [200];
  
  local_198 = include;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  status = 0;
  temp = (char *)0x0;
  bVar4 = false;
  intern_flag = '\0';
  bVar3 = false;
  bVar9 = false;
  if (((psrc_view != '\0') && (sgml_in_psrc_was_initialized == '\0')) && (psrc_nested_call == '\0'))
  {
    psrc_nested_call = '\x01';
    HTMLSRC_apply_markup(me,HTL_abracket,'\x01',0);
    HTML_put_string(me,"</");
    HTMLSRC_apply_markup(me,HTL_abracket,'\0',0);
    HTMLSRC_apply_markup(me,HTL_tag,'\x01',0);
    if (tagname_transform == 0) {
      LYstrncpy(buf,tags[element_number].name,199);
      LYLowerCase(buf);
      HTML_put_string(me,buf);
    }
    else {
      HTML_put_string(me,tags[element_number].name);
    }
    HTMLSRC_apply_markup(me,HTL_tag,'\0',0);
    HTMLSRC_apply_markup(me,HTL_abracket,'\x01',0);
    HTML_put_character(me,'>');
    HTMLSRC_apply_markup(me,HTL_abracket,'\0',0);
    psrc_nested_call = '\0';
    local_200 = 0;
    goto LAB_080cd7d5;
  }
  if (((me->stack + 799 <= me->sp) || (me->sp->tag_number != element_number)) &&
     ((tags[element_number].contents != SGML_EMPTY && (WWW_TraceFlag != '\0')))) {
    if (me->sp == me->stack + 799) {
      local_1fc = "none";
    }
    else {
      if (me->sp->tag_number < 0) {
        local_1f8 = "*invalid tag*";
      }
      else {
        if (me->sp->tag_number < 0x76) {
          local_1f4 = tags[me->sp->tag_number].name;
        }
        else {
          local_1f4 = "special tag";
        }
        local_1f8 = local_1f4;
      }
      local_1fc = local_1f8;
    }
    src = tags[element_number].name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTML: end of element %s when expecting end of %s\n",src,local_1fc);
  }
  if (((LYMapsOnly != '\0') && (element_number != 0x47)) &&
     ((element_number != 5 && (element_number != 0x4f)))) {
    local_200 = 0;
    goto LAB_080cd7d5;
  }
  if (tags[element_number].contents != SGML_EMPTY) {
    bVar3 = 0 < me->skip_stack;
    if (((((me->sp->tag_number != element_number) && (me->skip_stack < 1)) &&
         (tags[67].contents != SGML_EMPTY)) &&
        (((me->sp->tag_number == 0x72 || (me->sp->tag_number == 0x50)) ||
         ((me->sp->tag_number == 0x4a ||
          ((me->sp->tag_number == 0x21 || (me->sp->tag_number == 0x44)))))))) &&
       ((element_number == 0x2f ||
        ((((element_number == 0x30 || (element_number == 0x31)) || (element_number == 0x32)) ||
         ((element_number == 0x33 || (element_number == 0x34)))))))) {
      bVar4 = true;
    }
    if (((me->skip_stack == 0) && (element_number == 0x4f)) &&
       ((me->sp->tag_number == 0x95 && (me->sp < me->stack + 799)))) {
      me->sp->tag_number = 0x4f;
    }
    if (me->skip_stack < 1) {
      if ((((element_number == 0x4f) && (me->sp->tag_number != 0x4f)) &&
          (me->sp->tag_number != 0x95)) &&
         ((0 < me->objects_mixed_open &&
          ((me->objects_figged_open < 1 || (me->sp->tag_number != 0x29)))))) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          if (me->sp->style->name == (char *)0x0) {
            local_1ec = "(null)";
          }
          else {
            local_1ec = me->sp->style->name;
          }
          iVar6 = me->objects_mixed_open;
          psVar2 = me->sp;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML:end_element[%d]: %s (level %d), %s - %s\n",
                  (int)me + (0x20ec - (int)psVar2) >> 3,"Special OBJECT handling",iVar6,
                  "leaving on stack",local_1ec);
        }
        me->objects_mixed_open = me->objects_mixed_open + -1;
      }
      else {
        if ((me->stack_overrun == '\x01') && (me->sp->tag_number != element_number)) {
          local_200 = 0;
          goto LAB_080cd7d5;
        }
        if ((element_number == 0x5b) && (me->sp->tag_number != 0x5b)) {
          local_200 = 0;
          goto LAB_080cd7d5;
        }
        if ((((me->sp->tag_number != element_number) && (tags[67].contents == SGML_EMPTY)) &&
            (((me->sp->tag_number == 0x72 ||
              (((me->sp->tag_number == 0x50 || (me->sp->tag_number == 0x4a)) ||
               (me->sp->tag_number == 0x21)))) || (me->sp->tag_number == 0x44)))) &&
           ((((element_number == 0x2f || (element_number == 0x30)) ||
             ((element_number == 0x31 || ((element_number == 0x32 || (element_number == 0x33))))))
            || (element_number == 0x34)))) {
          local_200 = 0;
          goto LAB_080cd7d5;
        }
        if (me->sp < me->stack + 799) {
          bVar9 = ((int)me + (0x7f4 - (int)me->sp) >> 3) + 800 == wait_for_this_stacked_elt;
          if (((element_number == 0x4f) && (me->sp->tag_number == 0x29)) &&
             (0 < me->objects_figged_open)) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
              if (me->sp->style->name == (char *)0x0) {
                local_1e8 = "(null)";
              }
              else {
                local_1e8 = me->sp->style->name;
              }
              iVar6 = me->objects_figged_open;
              psVar2 = me->sp;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTML:end_element[%d]: %s (level %d), %s - %s\n",
                      (int)me + (0x20ec - (int)psVar2) >> 3,"Special OBJECT->FIG handling",iVar6,
                      "treating as end FIG",local_1e8);
            }
            me->objects_figged_open = me->objects_figged_open + -1;
            element_number = 0x29;
          }
          me->sp = me->sp + 1;
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            if (me->sp->style->name == (char *)0x0) {
              local_1e4 = "(null)";
            }
            else {
              local_1e4 = me->sp->style->name;
            }
            psVar2 = me->sp;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTML:end_element[%d]: Popped style off stack - %s\n",
                    (int)me + (0x20ec - (int)psVar2) >> 3,local_1e4);
          }
        }
        else {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,
                    "Stack underflow error!  Tried to pop off more styles than exist in stack\n");
          }
        }
      }
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        if (me->sp->style->name == (char *)0x0) {
          local_1f0 = "(null)";
        }
        else {
          local_1f0 = me->sp->style->name;
        }
        iVar6 = me->skip_stack;
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",iVar6,
                local_1f0);
      }
      me->skip_stack = me->skip_stack + -1;
    }
  }
  if (bVar4) {
    if (bVar9) {
      wait_for_this_stacked_elt = -1;
    }
    local_200 = 0;
    goto LAB_080cd7d5;
  }
  if ((((me->inTEXTAREA != '\0') && (element_number != 0x69)) &&
      (BVar5 = LYBadHTML(me), BVar5 != '\0')) && (WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Bad HTML: Missing TEXTAREA end tag\n");
  }
  if (((me->text == (HText *)0x0) && (LYMapsOnly == '\0')) && (me->style_change != '\0')) {
    actually_set_style(me);
  }
  switch(element_number) {
  case 0:
    if (me->inA != '\0') {
      me->inA = '\0';
      if (((hidden_link_marker != (char *)0x0) && (*hidden_link_marker != '\0')) &&
         (BVar5 = HText_isAnchorBlank(me->text,me->CurrentANum), BVar5 != '\0')) {
        HText_appendText(me->text,hidden_link_marker);
      }
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      if ((me->inBoldA == '\x01') && (me->inBoldH == '\0')) {
        HText_appendCharacter(me->text,6);
      }
      HText_endAnchor(me->text,me->CurrentANum);
      me->CurrentANum = 0;
      me->inBoldA = '\0';
      if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
        HText_appendCharacter(me->text,3);
        me->inUnderline = '\x01';
      }
    }
    break;
  case 1:
  case 2:
  case 6:
  case 7:
  case 0xc:
  case 0xe:
  case 0x15:
  case 0x19:
  case 0x1e:
  case 0x20:
  case 0x25:
  case 0x3f:
  case 0x41:
  case 0x43:
  case 0x44:
  case 0x52:
  case 0x59:
  case 0x5d:
  case 0x5e:
  case 100:
  case 0x67:
  case 0x6b:
  case 0x6d:
  case 0x70:
  case 0x73:
    break;
  case 3:
  case 9:
  case 0x10:
  case 0x13:
  case 0x48:
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (me->sp->tag_number == element_number) {
      LYEnsureDoubleSpace(me);
    }
    if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    break;
  case 4:
    if (me->inAPPLETwithP == '\0') {
      HTML_put_character(me,' ');
    }
    else {
      LYEnsureDoubleSpace(me);
    }
    LYResetParagraphAlignment(me);
    me->inAPPLETwithP = '\0';
    me->inAPPLET = '\0';
    change_paragraph_style(me,me->sp->style);
    break;
  default:
    change_paragraph_style(me,me->sp->style);
    break;
  case 8:
  case 0xf:
  case 0x18:
  case 0x26:
  case 0x39:
  case 0x61:
  case 0x71:
    if (0 < me->Underline_Level) {
      me->Underline_Level = me->Underline_Level + -1;
      if ((me->inUnderline == '\0') || (0 < me->Underline_Level)) {
        if (WWW_TraceFlag != '\0') {
          iVar6 = me->Underline_Level;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Underline Level is %d\n",iVar6);
        }
      }
      else {
        HText_appendCharacter(me->text,4);
        me->inUnderline = '\0';
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Ending underline\n");
        }
      }
    }
    break;
  case 0x11:
    if ((((me->inA != '\0') || (me->inSELECT != '\0')) || (me->inTEXTAREA != '\0')) &&
       ((BVar5 = LYBadHTML(me), BVar5 != '\0' && (WWW_TraceFlag != '\0')))) {
      if (me->inA == '\0') {
        local_1c4 = &DAT_0816522e;
      }
      else {
        local_1c4 = &DAT_08166114;
      }
      if (((me->inSELECT == '\0') && (me->inTEXTAREA == '\0')) || (me->inA == '\0')) {
        local_1c0 = &DAT_0816522e;
      }
      else {
        local_1c0 = &DAT_08166116;
      }
      if (me->inTEXTAREA == '\0') {
        local_1bc = "";
      }
      else {
        local_1bc = "TEXTAREA";
      }
      if ((me->inSELECT == '\0') || (me->inTEXTAREA == '\0')) {
        local_1b8 = &DAT_0816522e;
      }
      else {
        local_1b8 = &DAT_08166116;
      }
      if (me->inSELECT == '\0') {
        local_1b4 = "";
      }
      else {
        local_1b4 = "SELECT";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Bad HTML: %s%s%s%s%s not closed before BODY end tag *****\n",
              local_1b4,local_1b8,local_1bc,local_1c0,local_1c4);
    }
    break;
  case 0x12:
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x16:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    me->inCAPTION = '\0';
    change_paragraph_style(me,me->sp->style);
    me->inLABEL = '\0';
    break;
  case 0x17:
  case 0x22:
    if (-1 < me->Division_Level) {
      me->Division_Level = me->Division_Level + -1;
    }
    if ((-1 < me->Division_Level) &&
       (me->sp->style->alignment !=
        *(short *)((int)&me->node_anchor + (me->Division_Level + 0xc0) * 2))) {
      if (me->inP != '\0') {
        LYEnsureSingleSpace(me);
      }
      me->sp->style->alignment = *(short *)((int)&me->node_anchor + (me->Division_Level + 0xc0) * 2)
      ;
    }
    change_paragraph_style(me,me->sp->style);
    if (me->style_change == '\0') {
      if (me->inP != '\0') {
        LYEnsureSingleSpace(me);
      }
    }
    else {
      actually_set_style(me);
      if (-1 < me->List_Nesting_Level) {
        HText_NegateLineOne(me->text);
      }
    }
    me->current_default_alignment = (int)me->sp->style->alignment;
    break;
  case 0x1b:
    if (me->inTABLE != '\0') {
      HText_endStblCOLGROUP(me->text);
    }
    break;
  case 0x1d:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    me->inCREDIT = '\0';
    change_paragraph_style(me,me->sp->style);
    me->inLABEL = '\0';
    break;
  case 0x1f:
  case 0x58:
  case 0x60:
    HTML_put_character(me,' ');
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,3);
    }
    HTML_put_string(me,":DEL]");
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,4);
    }
    HTML_put_character(me,' ');
    me->in_word = '\0';
    break;
  case 0x28:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x29:
    LYHandleFIG(me,(BOOLEAN *)0x0,(char **)0x0,'\0','\0',(char *)0x0,(char *)0x0,'\0','\0',
                &intern_flag);
    break;
  case 0x2a:
  case 0x4e:
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (me->sp->tag_number == element_number) {
      LYEnsureDoubleSpace(me);
    }
    if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    me->inLABEL = '\0';
    break;
  case 0x2b:
    me->inFONT = '\0';
    break;
  case 0x2c:
    if (((me->inFORM == '\0') && (BVar5 = LYBadHTML(me), BVar5 != '\0')) && (WWW_TraceFlag != '\0'))
    {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Bad HTML: Unmatched FORM end tag\n");
    }
    form_in_htext = '\0';
    if (me->inSELECT != '\0') {
      BVar5 = LYBadHTML(me);
      if ((BVar5 != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"
               );
      }
      if ((me->sp->tag_number != 0x5b) && (tags[91].contents != SGML_EMPTY)) {
        me->skip_stack = me->skip_stack + 1;
      }
      HTML_end_element(me,0x5b,include);
    }
    me->inFORM = '\0';
    HText_endForm(me->text);
    if ((me->List_Nesting_Level < 0) || (me->inP != '\0')) {
      LYEnsureSingleSpace(me);
    }
    break;
  case 0x2e:
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
    if (me->Division_Level < 0) {
      if ((me->sp->style->id == 0x2f) || (me->sp->style->id == 0x29)) {
        me->sp->style->alignment = 3;
      }
      else {
        if (me->sp->style->id == 0x31) {
          me->sp->style->alignment = 2;
        }
        else {
          me->sp->style->alignment = 1;
        }
      }
    }
    else {
      me->sp->style->alignment = *(short *)((int)&me->node_anchor + (me->Division_Level + 0xc0) * 2)
      ;
    }
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if ((styles[element_number]->font & 2U) != 0) {
      if ((me->inBoldA == '\0') && (me->inBoldH == '\x01')) {
        HText_appendCharacter(me->text,6);
      }
      me->inBoldH = '\0';
    }
    if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
      HText_appendCharacter(me->text,3);
      me->inUnderline = '\x01';
    }
    break;
  case 0x35:
    if ((me->inBASE != '\0') &&
       ((BVar5 = LYIsUIPage3(me->node_anchor->address,UIP_LIST_PAGE,0), BVar5 != '\0' ||
        (BVar5 = LYIsUIPage3(me->node_anchor->address,UIP_ADDRLIST_PAGE,0), BVar5 != '\0')))) {
      HTSACopy(&me->node_anchor->content_base,me->base_href);
    }
    BVar5 = HText_hasToolbar(me->text);
    if (BVar5 != '\0') {
      HText_appendParagraph(me->text);
    }
    break;
  case 0x37:
    if ((((me->inA != '\0') || (me->inSELECT != '\0')) || (me->inTEXTAREA != '\0')) &&
       ((BVar5 = LYBadHTML(me), BVar5 != '\0' && (WWW_TraceFlag != '\0')))) {
      if (me->inA == '\0') {
        local_1e0 = &DAT_0816522e;
      }
      else {
        local_1e0 = &DAT_08166114;
      }
      if (((me->inSELECT == '\0') && (me->inTEXTAREA == '\0')) || (me->inA == '\0')) {
        local_1dc = &DAT_0816522e;
      }
      else {
        local_1dc = &DAT_08166116;
      }
      if (me->inTEXTAREA == '\0') {
        local_1d8 = "";
      }
      else {
        local_1d8 = "TEXTAREA";
      }
      if ((me->inSELECT == '\0') || (me->inTEXTAREA == '\0')) {
        local_1d4 = &DAT_0816522e;
      }
      else {
        local_1d4 = &DAT_08166116;
      }
      if (me->inSELECT == '\0') {
        local_1d0 = "";
      }
      else {
        local_1d0 = "SELECT";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Bad HTML: %s%s%s%s%s not closed before HTML end tag *****\n",
              local_1d0,local_1d4,local_1d8,local_1dc,local_1e0);
    }
    break;
  case 0x3a:
  case 0x4d:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x3d:
    HTML_put_character(me,' ');
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,3);
    }
    HTML_put_string(me,":INS]");
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,4);
    }
    HTML_put_character(me,' ');
    me->in_word = '\0';
    break;
  case 0x42:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x47:
    if (me->map_address != (char *)0x0) {
      free(me->map_address);
      me->map_address = (char *)0x0;
    }
    break;
  case 0x49:
    HTChunkPutc((HTChunk *)&me->math,' ');
    HTChunkTerminate((HTChunk *)&me->math);
    if (2 < (me->math).size) {
      LYEnsureSingleSpace(me);
      if (me->inUnderline == '\0') {
        HText_appendCharacter(me->text,3);
      }
      HTML_put_string(me,"[MATH:");
      HText_appendCharacter(me->text,4);
      HTML_put_character(me,' ');
      HTML_put_string(me,(me->math).data);
      HText_appendCharacter(me->text,3);
      HTML_put_string(me,":MATH]");
      if (me->inUnderline == '\0') {
        HText_appendCharacter(me->text,4);
      }
      LYEnsureSingleSpace(me);
    }
    HTChunkClear((HTChunk *)&me->math);
    break;
  case 0x4f:
    s = 0;
    e = 0;
    start = (char *)0x0;
    first_end = (char *)0x0;
    last_end = (char *)0x0;
    first_map = (char *)0x0;
    last_map = (char *)0x0;
    bVar4 = false;
    data = (char *)0x0;
    HTChunkTerminate((HTChunk *)&me->object);
    data = (me->object).data;
    while (cp = strchr(data,0x3c), cp != (char *)0x0) {
      iVar6 = strncmp(cp,"<!--",4);
      if (iVar6 == 0) {
        cp = LYFindEndOfComment(cp);
      }
      else {
        if ((((((s == 0) && (iVar6 = strncasecomp(cp,"<PARAM",6), iVar6 == 0)) &&
              (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[6]] & 8) == 0)) &&
             ((cp[6] != '_' && (cp[6] != '-')))) && (cp[6] != '.')) && (cp[6] != ':')) {
          bVar4 = true;
        }
        else {
          iVar6 = strncasecomp(cp,"<OBJECT",7);
          if (((iVar6 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[7]] & 8) == 0)) &&
             ((cp[7] != '_' && (((cp[7] != '-' && (cp[7] != '.')) && (cp[7] != ':')))))) {
            if (s == 0) {
              start = cp;
            }
            s = s + 1;
          }
          else {
            iVar6 = strncasecomp(cp,"</OBJECT",8);
            if (((iVar6 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[8]] & 8) == 0)) &&
               ((cp[8] != '_' && (((cp[8] != '-' && (cp[8] != '.')) && (cp[8] != ':')))))) {
              if (e == 0) {
                first_end = cp;
              }
              e = e + 1;
              last_end = cp;
            }
            else {
              iVar6 = strncasecomp(cp,"<MAP",4);
              if (((((iVar6 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[4]] & 8) == 0)
                    ) && (cp[4] != '_')) && ((cp[4] != '-' && (cp[4] != '.')))) && (cp[4] != ':')) {
                last_map = cp;
                if (first_map == (char *)0x0) {
                  first_map = cp;
                }
              }
              else {
                iVar6 = strncasecomp(cp,"</MAP",5);
                if (((iVar6 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[5]] & 8) == 0)
                    ) && ((cp[5] != '_' && (((cp[5] != '-' && (cp[5] != '.')) && (cp[5] != ':'))))))
                {
                  last_map = cp;
                }
              }
            }
          }
        }
      }
      data = cp + 1;
    }
    if (s < e) {
      BVar5 = LYBadHTML(me);
      if ((BVar5 != '\0') && (WWW_TraceFlag != '\0')) {
        src = (me->object).data;
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",src);
      }
    }
    else {
      if (e < s) {
        if (((((me->object_declare == '\0') && (me->object_name == (char *)0x0)) &&
             ((me->object_shapes == '\0' || (LYMapsOnly != '\0')))) &&
            ((me->object_usemap == (char *)0x0 || (LYMapsOnly != '\0')))) &&
           ((clickable_images == '\0' ||
            (((((LYMapsOnly != '\0' || (me->object_data == (char *)0x0)) || (bVar4)) ||
              ((me->object_classid != (char *)0x0 || (me->object_codebase != (char *)0x0)))) ||
             (me->object_codetype != (char *)0x0)))))) {
          if (WWW_TraceFlag != '\0') {
            src = (me->object).data;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"%s:\n%s\n",
                    "HTML: Nested OBJECT tags.  Recycling incomplete contents",src);
          }
          status = 0x2bd;
          (me->object).size = (me->object).size + -1;
          HTChunkPuts((HTChunk *)&me->object,"</OBJECT>");
          if (include == (char **)0x0) {
            local_198 = &me->xinclude;
          }
          SNACat(local_198,(me->object).data,(me->object).size);
          clear_objectdata(me);
          HTML_start_element(me,0x4f,(BOOLEAN *)0x0,(char **)0x0,me->tag_charset,local_198);
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTML: Nested OBJECT tags.  Recycling.\n");
          }
          status = 700;
          (me->object).size = (me->object).size + -1;
          HTChunkPuts((HTChunk *)&me->object,"</OBJECT>");
          if (LYMapsOnly == '\0') {
            change_paragraph_style(me,me->sp->style);
          }
        }
        break;
      }
      if (WWW_TraceFlag != '\0') {
        src = (me->object).data;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTML:OBJECT content:\n%s\n",src);
      }
      if (me->object_declare == '\x01') {
        if (((me->object_id != (char *)0x0) && (*me->object_id != '\0')) && (LYMapsOnly == '\0')) {
          LYHandleID(me,me->object_id);
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML: DECLAREd OBJECT.  Ignoring!\n");
        }
      }
      else {
        if ((me->object_name == (char *)0x0) || (LYMapsOnly != '\0')) {
          if (s < 1) {
LAB_080cb916:
            if ((me->object_shapes == '\x01') && (LYMapsOnly == '\0')) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTML: OBJECT has SHAPES.  Converting to FIG.\n");
              }
              if (include == (char **)0x0) {
                local_198 = &me->xinclude;
              }
              HTSACat(local_198,"<FIG ISOBJECT IMAGEMAP");
              if (me->object_ismap == '\x01') {
                HTSACat(local_198," IMAGEMAP");
              }
              if (me->object_id != (char *)0x0) {
                HTSACat(local_198," ID=\"");
                HTSACat(local_198,me->object_id);
                HTSACat(local_198,"\"");
              }
              if ((me->object_data != (char *)0x0) && (me->object_classid == (char *)0x0)) {
                HTSACat(local_198," SRC=\"");
                HTSACat(local_198,me->object_data);
                HTSACat(local_198,"\"");
              }
              HTSACat(local_198,">");
              (me->object).size = (me->object).size + -1;
              HTChunkPuts((HTChunk *)&me->object,"</FIG>");
              HTChunkTerminate((HTChunk *)&me->object);
              HTSACat(local_198,(me->object).data);
            }
            else {
              if ((me->object_usemap == (char *)0x0) || (LYMapsOnly != '\0')) {
                if (((me->object_id != (char *)0x0) && (*me->object_id != '\0')) &&
                   (LYMapsOnly == '\0')) {
                  LYHandleID(me,me->object_id);
                }
                if (1 < (me->object).size) {
                  if (include == (char **)0x0) {
                    local_198 = &me->xinclude;
                  }
                  HTSACat(local_198,(me->object).data);
                }
                if ((((clickable_images != '\0') && (LYMapsOnly == '\0')) &&
                    ((me->object_data != (char *)0x0 &&
                     ((!bVar4 && (me->object_classid == (char *)0x0)))))) &&
                   ((me->object_codebase == (char *)0x0 && (me->object_codetype == (char *)0x0)))) {
                  if (local_198 == (char **)0x0) {
                    local_198 = &me->xinclude;
                  }
                  if (me->inA != '\0') {
                    HTSACat(local_198,"</A>");
                  }
                  HTSACat(local_198," -<A HREF=\"");
                  HTSACat(local_198,me->object_data);
                  HTSACat(local_198,"\">");
                  if ((me->object_type == (char *)0x0) ||
                     (iVar6 = strncasecomp(me->object_type,"image/",6), iVar6 != 0)) {
                    HTSACat(local_198,"(OBJECT)");
                  }
                  else {
                    HTSACat(local_198,"(IMAGE)");
                  }
                  HTSACat(local_198,"</A> ");
                }
              }
              else {
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"HTML: OBJECT has USEMAP.  Converting to IMG.\n");
                }
                if (include == (char **)0x0) {
                  local_198 = &me->xinclude;
                }
                HTSACat(local_198,"<IMG ISOBJECT");
                if (me->object_id != (char *)0x0) {
                  HTSACat(local_198," ID=\"");
                  HTSACat(local_198,me->object_id);
                  HTSACat(local_198,"\"");
                }
                if ((me->object_data != (char *)0x0) && (me->object_classid == (char *)0x0)) {
                  HTSACat(local_198," SRC=\"");
                  HTSACat(local_198,me->object_data);
                  HTSACat(local_198,"\"");
                }
                if (me->object_title != (char *)0x0) {
                  HTSACat(local_198," TITLE=\"");
                  HTSACat(local_198,me->object_title);
                  HTSACat(local_198,"\" ALT=\"");
                  HTSACat(local_198,me->object_title);
                  HTSACat(local_198,"\"");
                }
                if (me->object_usemap == (char *)0x0) {
                  HTSACat(local_198,">");
                }
                else {
                  HTSACat(local_198," USEMAP=\"");
                  HTSACat(local_198,me->object_usemap);
                  if (me->object_ismap == '\x01') {
                    HTSACat(local_198,"\" ISMAP>");
                  }
                  else {
                    HTSACat(local_198,"\">");
                  }
                }
                if (first_map != (char *)0x0) {
                  if (s == 0) {
                    HTSACat(local_198,(me->object).data);
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"HTML: MAP found, recycling object contents.\n");
                    }
                  }
                  else {
                    data = (char *)0x0;
                    if (last_map < start) {
                      *start = '\0';
                      i = 0;
                    }
                    else {
                      if (last_map < first_end) {
                        *first_end = '\0';
                        i = e;
                      }
                      else {
                        if (last_map < last_end) {
                          *last_end = '\0';
                          i = 1;
                        }
                        else {
                          i = 0;
                        }
                      }
                    }
                    if (last_end < first_map) {
                      HTSACopy(&data,"<OBJECT><");
                      HTSACat(&data,last_end + 1);
                      i = 0;
                    }
                    else {
                      if (start < first_map) {
                        HTSACopy(&data,start);
                      }
                      else {
                        HTSACopy(&data,(me->object).data);
                      }
                    }
                    while (src = data, 0 < i) {
                      HTSACat(&data,"</OBJECT>");
                      i = i + -1;
                    }
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"%s:\n%s\n",
                              "HTML: MAP and nested OBJECT tags.  Recycling parts",src);
                    }
                    HTSACat(local_198,data);
                    if (data != (char *)0x0) {
                      free(data);
                      data = (char *)0x0;
                    }
                  }
                }
              }
            }
          }
          else {
            if (((start == (char *)0x0) || (first_end == (char *)0x0)) || (first_end <= start)) {
              BVar5 = LYBadHTML(me);
              if ((BVar5 != '\0') && (WWW_TraceFlag != '\0')) {
                __stream = TraceFP();
                fprintf((FILE *)__stream,
                        "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n");
              }
            }
            else {
              if (LYMapsOnly == '\0') goto LAB_080cb916;
              if ((LYMapsOnly == '\0') || ((last_map != (char *)0x0 && (first_end <= last_map)))) {
                e = 0;
              }
              else {
                *first_end = '\0';
              }
              data = (char *)0x0;
              if ((LYMapsOnly == '\0') || ((first_map != (char *)0x0 && (first_map <= start)))) {
                HTSACopy(&data,(me->object).data);
              }
              else {
                HTSACopy(&data,start);
              }
              if (0 < e) {
                i = e;
                while (0 < i) {
                  HTSACat(&data,"</OBJECT>");
                  i = i + -1;
                }
              }
              if (include == (char **)0x0) {
                local_198 = &me->xinclude;
              }
              HTSACat(local_198,data);
              if (WWW_TraceFlag != '\0') {
                if (s < 2) {
                  local_1ac = &DAT_0816522e;
                }
                else {
                  local_1ac = &DAT_081663cc;
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTML: Recycling nested OBJECT%s.\n",local_1ac);
              }
              if (data != (char *)0x0) {
                free(data);
                data = (char *)0x0;
              }
            }
          }
        }
        else {
          if ((me->object_id != (char *)0x0) && (*me->object_id != '\0')) {
            LYHandleID(me,me->object_id);
          }
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTML: NAMEd OBJECT.  Ignoring!\n");
          }
        }
      }
    }
    clear_objectdata(me);
    if (LYMapsOnly == '\0') {
      change_paragraph_style(me,me->sp->style);
    }
    break;
  case 0x50:
    local_1b0 = me->List_Nesting_Level;
    if (0xb < local_1b0) {
      local_1b0 = 0xb;
    }
    *(int *)(&me->target + local_1b0 + 0x4c) = OL_VOID;
  case 0x21:
  case 0x23:
  case 0x4a:
  case 0x72:
    me->List_Nesting_Level = me->List_Nesting_Level + -1;
    if (WWW_TraceFlag != '\0') {
      iVar6 = me->List_Nesting_Level;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTML_end_element: Reducing List Nesting Level to %d\n",iVar6);
    }
    if (element_number == 0x23) {
      in_DT = '\0';
    }
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (-1 < me->List_Nesting_Level) {
      LYEnsureSingleSpace(me);
    }
    break;
  case 0x53:
    LYHandlePlike(me,(BOOLEAN *)0x0,(char **)0x0,include,0,'\0');
    break;
  case 0x56:
    HText_appendCharacter(me->text,10);
    me->inPRE = '\0';
  case 0x46:
  case 0x55:
  case 0x75:
    if (me->comment_start != (char *)0x0) {
      HText_appendText(me->text,me->comment_start);
    }
    change_paragraph_style(me,me->sp->style);
    if (-1 < me->List_Nesting_Level) {
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      HText_NegateLineOne(me->text);
    }
    break;
  case 0x57:
    if (0 < me->Quote_Level) {
      me->Quote_Level = me->Quote_Level + -1;
    }
    if ((me->Quote_Level & 1U) == 0) {
      HTML_put_character(me,'\"');
    }
    else {
      HTML_put_character(me,'\'');
    }
    break;
  case 0x5a:
    HTChunkTerminate((HTChunk *)&me->script);
    if (WWW_TraceFlag != '\0') {
      src = (me->script).data;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTML: SCRIPT content =\n%s\n",src);
    }
    HTChunkClear((HTChunk *)&me->script);
    break;
  case 0x5b:
    if (me->inSELECT == '\0') {
      BVar5 = LYBadHTML(me);
      if ((BVar5 != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: Unmatched SELECT end tag *****\n");
      }
    }
    else {
      me->inSELECT = '\0';
      me->select_disabled = '\0';
      if (((me->inFORM == '\0') && (BVar5 = LYBadHTML(me), BVar5 != '\0')) &&
         (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: SELECT end tag not within FORM element *****\n");
      }
      HTChunkTerminate((HTChunk *)&me->option);
      ptr = HText_setLastOptionValue
                      (me->text,(me->option).data,me->LastOptionValue,3,me->LastOptionChecked,
                       me->UCLYhndl,me->tag_charset);
      if (me->LastOptionValue != (char *)0x0) {
        free(me->LastOptionValue);
        me->LastOptionValue = (char *)0x0;
      }
      me->LastOptionChecked = '\0';
      if ((HTCurSelectGroupType == 3) || (LYSelectPopups == '\0')) {
        LYEnsureSingleSpace(me);
      }
      else {
        if (((ptr != (char *)0x0) &&
            (((me->sp->tag_number == 0x56 || (me->inPRE == '\x01')) ||
             (me->sp->style->freeFormat == '\0')))) && (sVar8 = strlen(ptr), 6 < sVar8)) {
          i = 0;
          while (i < 6) {
            if (*ptr == ' ') {
              HText_appendCharacter(me->text,1);
            }
            else {
              HText_appendCharacter(me->text,(int)*ptr);
            }
            ptr = ptr + 1;
            i = i + 1;
          }
          HText_setIgnoreExcess(me->text,'\x01');
        }
        while ((ptr != (char *)0x0 && (*ptr != '\0'))) {
          if (*ptr == ' ') {
            HText_appendCharacter(me->text,1);
          }
          else {
            kcode = NOKANJI;
            specified_kcode = NOKANJI;
            if (HTCJK == JAPANESE) {
              kcode = HText_getKcode(me->text);
              HText_updateKcode(me->text,kanji_code);
              specified_kcode = HText_getSpecifiedKcode(me->text);
              HText_updateSpecifiedKcode(me->text,kanji_code);
            }
            HText_appendCharacter(me->text,(int)*ptr);
            if (HTCJK == JAPANESE) {
              HText_updateKcode(me->text,kcode);
              HText_updateSpecifiedKcode(me->text,specified_kcode);
            }
          }
          ptr = ptr + 1;
        }
        if (me->first_option == '\0') {
          HText_appendCharacter(me->text,0x5d);
          HText_endInput(me->text);
          HText_setLastChar(me->text,']');
          me->in_word = '\x01';
        }
        HText_setIgnoreExcess(me->text,'\0');
      }
      HTChunkClear((HTChunk *)&me->option);
      if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
        HText_appendCharacter(me->text,3);
        me->inUnderline = '\x01';
      }
      if ((me->needBoldH == '\x01') && (me->inBoldH == '\0')) {
        HText_appendCharacter(me->text,5);
        me->inBoldH = '\x01';
        me->needBoldH = '\0';
      }
    }
    break;
  case 0x62:
    HTChunkTerminate((HTChunk *)&me->style_block);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      src = (me->style_block).data;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTML: STYLE content =\n%s\n",src);
    }
    HTChunkClear((HTChunk *)&me->style_block);
    break;
  case 99:
    HText_appendCharacter(me->text,0x5d);
    break;
  case 0x66:
    if (nested_tables == '\0') {
      me->inTABLE = '\0';
    }
    if (me->sp->style->id != 0x25) {
      if (-1 < me->Division_Level) {
        me->Division_Level = me->Division_Level + -1;
      }
      if (-1 < me->Division_Level) {
        me->sp->style->alignment =
             *(short *)((int)&me->node_anchor + (me->Division_Level + 0xc0) * 2);
      }
      change_paragraph_style(me,me->sp->style);
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      if (nested_tables == '\0') {
        HText_endStblTABLE(me->text);
      }
      else {
        iVar6 = HText_endStblTABLE(me->text);
        me->inTABLE = (BOOLEAN)iVar6;
      }
      me->current_default_alignment = (int)me->sp->style->alignment;
      if (-1 < me->List_Nesting_Level) {
        HText_NegateLineOne(me->text);
      }
    }
    break;
  case 0x68:
  case 0x6c:
    HText_endStblTD(me->text);
    break;
  case 0x69:
    if (me->inTEXTAREA == '\0') {
      BVar5 = LYBadHTML(me);
      if ((BVar5 != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: Unmatched TEXTAREA end tag\n");
      }
    }
    else {
      me->inTEXTAREA = '\0';
      memset(&I,0,0x58);
      I.value_cs = current_char_set;
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      HTML_put_character(me,' ');
      me->in_word = '\0';
      HText_appendCharacter(me->text,0xd);
      HTChunkTerminate((HTChunk *)&me->textarea);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      I.type = "textarea";
      I.size = me->textarea_cols;
      I.name = me->textarea_name;
      I.name_cs = me->textarea_name_cs;
      I.accept_cs = me->textarea_accept_cs;
      me->textarea_accept_cs = (char *)0x0;
      I.disabled = me->textarea_disabled;
      I.id = me->textarea_id;
      me->UsePlainSpace = '\x01';
      if (tags[element_number].contents == SGML_LITTERAL) {
        LYUCTranslateHTMLString
                  (&(me->textarea).data,me->UCLYhndl,current_char_set,'\0',me->UsePlainSpace,
                   me->HiddenValue,st_HTML);
      }
      else {
        LYUCFullyTranslateString
                  (&(me->textarea).data,me->UCLYhndl,current_char_set,'\0','\0',me->UsePlainSpace,
                   me->HiddenValue,'\0',st_HTML);
      }
      data_1 = (me->textarea).data;
      if (*data_1 != '\0') {
        sVar8 = strlen(data_1);
        cp = data_1 + (sVar8 - 1);
        while ((data_1 <= cp && (*cp == '\n'))) {
          *cp = '\0';
          cp = cp + -1;
        }
        while (*data_1 == '\n') {
          data_1 = data_1 + 1;
        }
      }
      src = strchr(data_1,10);
      if (src == (char *)0x0) {
        if (*data_1 == '\0') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        else {
          HTSACopy(&temp,data_1);
        }
        data_1 = "";
      }
      else {
        *src = '\0';
        HTSACopy(&temp,data_1);
        *src = '\n';
        data_1 = src + 1;
      }
      i = 0;
      while (i < me->textarea_rows) {
        j = 0;
        while ((temp != (char *)0x0 && (temp[j] != '\0'))) {
          if (temp[j] == '\r') {
            if (temp[j + 1] == '\0') {
              local_1a1 = '\0';
            }
            else {
              local_1a1 = ' ';
            }
            temp[j] = local_1a1;
          }
          j = j + 1;
        }
        I.value = temp;
        chars = HText_beginInput(me->text,me->inUnderline,&I);
        while (0 < chars) {
          HTML_put_character(me,'_');
          chars = chars + -1;
        }
        HText_appendCharacter(me->text,0xd);
        if (*data_1 == '\0') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        else {
          if (*data_1 == '\n') {
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
            data_1 = data_1 + 1;
          }
          else {
            src = strchr(data_1,10);
            if (src == (char *)0x0) {
              HTSACopy(&temp,data_1);
              data_1 = "";
            }
            else {
              *src = '\0';
              HTSACopy(&temp,data_1);
              *src = '\n';
              data_1 = src + 1;
            }
          }
        }
        i = i + 1;
      }
      while ((*data_1 != '\0' || (temp != (char *)0x0))) {
        j_1 = 0;
        while ((temp != (char *)0x0 && (temp[j_1] != '\0'))) {
          if (temp[j_1] == '\r') {
            if (temp[j_1 + 1] == '\0') {
              local_199 = '\0';
            }
            else {
              local_199 = ' ';
            }
            temp[j_1] = local_199;
          }
          j_1 = j_1 + 1;
        }
        I.value = temp;
        HText_beginInput(me->text,me->inUnderline,&I);
        chars = me->textarea_cols;
        while (0 < chars) {
          HTML_put_character(me,'_');
          chars = chars + -1;
        }
        HText_appendCharacter(me->text,0xd);
        if (*data_1 == '\n') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          data_1 = data_1 + 1;
        }
        else {
          src = strchr(data_1,10);
          if (src == (char *)0x0) {
            if (*data_1 == '\0') {
              if (temp != (char *)0x0) {
                free(temp);
                temp = (char *)0x0;
              }
            }
            else {
              HTSACopy(&temp,data_1);
              data_1 = "";
            }
          }
          else {
            *src = '\0';
            HTSACopy(&temp,data_1);
            *src = '\n';
            data_1 = src + 1;
          }
        }
      }
      me->UsePlainSpace = '\0';
      HTChunkClear((HTChunk *)&me->textarea);
      if (me->textarea_name != (char *)0x0) {
        free(me->textarea_name);
        me->textarea_name = (char *)0x0;
      }
      me->textarea_name_cs = -1;
      if (me->textarea_id != (char *)0x0) {
        free(me->textarea_id);
        me->textarea_id = (char *)0x0;
      }
    }
    break;
  case 0x6a:
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x6e:
    HTChunkTerminate((HTChunk *)&me->title);
    HTAnchor_setTitle(me->node_anchor,(me->title).data);
    HTChunkClear((HTChunk *)&me->title);
    if (((me->node_anchor->bookmark != (char *)0x0) && (*me->node_anchor->bookmark != '\0')) &&
       ((LYMultiBookmarks != 0 ||
        (((bookmark_page != (char *)0x0 && (*bookmark_page != '\0')) &&
         (iVar6 = strcmp(me->node_anchor->bookmark,bookmark_page), iVar6 != 0)))))) {
      if (include == (char **)0x0) {
        local_198 = &me->xinclude;
      }
      i = 0;
      while (i < 0x1a) {
        if ((MBM_A_subbookmark[i] != (char *)0x0) &&
           (iVar6 = strcmp(MBM_A_subbookmark[i],me->node_anchor->bookmark), iVar6 == 0)) {
          HTSACat(local_198,"<H2><EM>");
          src = (char *)gettext("Description:");
          HTSACat(local_198,src);
          HTSACat(local_198,"</EM> ");
          if ((MBM_A_subdescript[i] == (char *)0x0) || (*MBM_A_subdescript[i] == '\0')) {
            local_1cc = (char *)gettext("(none)");
          }
          else {
            local_1cc = MBM_A_subdescript[i];
          }
          HTSACopy(&temp,local_1cc);
          LYEntify(&temp,'\x01');
          HTSACat(local_198,temp);
          HTSACat(local_198,"<BR><EM>&nbsp;&nbsp;&nbsp;");
          src = (char *)gettext("Filepath:");
          HTSACat(local_198,src);
          HTSACat(local_198,"</EM> ");
          if ((MBM_A_subbookmark[i] == (char *)0x0) || (*MBM_A_subbookmark[i] == '\0')) {
            local_1c8 = (char *)gettext("(unknown)");
          }
          else {
            local_1c8 = MBM_A_subbookmark[i];
          }
          HTSACopy(&temp,local_1c8);
          LYEntify(&temp,'\x01');
          HTSACat(local_198,temp);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          HTSACat(local_198,"</H2>");
          break;
        }
        i = i + 1;
      }
    }
    break;
  case 0x6f:
    HText_endStblTR(me->text);
    BVar5 = HText_LastLineEmpty(me->text,'\0');
    if (BVar5 == '\0') {
      HText_setLastChar(me->text,' ');
      HText_appendCharacter(me->text,0xd);
    }
    me->in_word = '\0';
  }
  if (bVar9) {
    wait_for_this_stacked_elt = -1;
  }
  if (me->xinclude != (char *)0x0) {
    HText_appendText(me->text," *** LYNX ERROR ***\rUnparsed data:\r");
    HText_appendText(me->text,me->xinclude);
    if (me->xinclude != (char *)0x0) {
      free(me->xinclude);
      me->xinclude = (char *)0x0;
    }
  }
  if ((!bVar3) &&
     ((FastTrimColorClass(tags[element_number].name,tags[element_number].name_len,Style_className,
                          &Style_className_end,&hcode), tags[element_number].contents != SGML_EMPTY
      || ((tags[element_number].flags & 0x10U) != 0)))) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      src = tags[element_number].name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",src);
    }
    _internal_HTC(me->text,hcode,0);
  }
  local_200 = status;
LAB_080cd7d5:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_200;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int HTML_put_entity(HTStructured *me,int entity_number)

{
  int local_18;
  int nent;
  
  if (entity_number < (int)0x70) {
    HTML_put_string(me,p_entity_values[entity_number]);
    local_18 = 0;
  }
  else {
    local_18 = -4;
  }
  return local_18;
}



void HTML_free(HTStructured *me)

{
  BOOLEAN BVar1;
  FILE *__stream;
  int iVar2;
  char *s;
  char *include;
  
  include = (char *)0x0;
  if ((LYMapsOnly == '\0') || (me->text != (HText *)0x0)) {
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (me->comment_end != (char *)0x0) {
      HTML_put_string(me,me->comment_end);
    }
    if (me->text != (HText *)0x0) {
      if (me->inUnderline != '\0') {
        HText_appendCharacter(me->text,4);
        me->inUnderline = '\0';
        me->Underline_Level = 0;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML_free: Ending underline\n");
        }
      }
      if (me->inA != '\0') {
        HTML_end_element(me,0,&include);
        me->inA = '\0';
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML_free: Ending HTML_A\n");
        }
      }
      if (me->inFONT != '\0') {
        HTML_end_element(me,0x2b,&include);
        me->inFONT = '\0';
      }
      if (me->inFORM != '\0') {
        HTML_end_element(me,0x2c,&include);
        me->inFORM = '\0';
      }
      if (0 < (me->option).size) {
        BVar1 = LYBadHTML(me);
        if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Bad HTML: SELECT or OPTION not ended properly *****\n");
        }
        HTChunkTerminate((HTChunk *)&me->option);
        if (WWW_TraceFlag != '\0') {
          s = (me->option).data;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML_free: ***** leftover option data: %s\n",s);
        }
        HTML_put_string(me,(me->option).data);
        HTChunkClear((HTChunk *)&me->option);
      }
      if (0 < (me->textarea).size) {
        BVar1 = LYBadHTML(me);
        if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Bad HTML: TEXTAREA not used properly *****\n");
        }
        HTChunkTerminate((HTChunk *)&me->textarea);
        if (WWW_TraceFlag != '\0') {
          s = (me->textarea).data;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML_free: ***** leftover textarea data: %s\n",s);
        }
        HTML_put_string(me,(me->textarea).data);
        HTChunkClear((HTChunk *)&me->textarea);
      }
      if (dump_output_immediately == '\0') {
        iVar2 = HText_sourceAnchors(me->text);
        if (iVar2 < 1) {
          iVar2 = HText_HiddenLinkCount(me->text);
          if (0 < iVar2) {
            HTML_start_element(me,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,&include);
            HTML_put_character(me,'[');
            HTML_start_element(me,0x26,(BOOLEAN *)0x0,(char **)0x0,-1,&include);
            s = (char *)gettext("Document has only hidden links.  Use the \'l\'ist command.");
            HTML_put_string(me,s);
            HTML_end_element(me,0x26,&include);
            HTML_put_character(me,']');
            HTML_end_element(me,0x53,&include);
          }
        }
      }
      if (me->xinclude != (char *)0x0) {
        HText_appendText(me->text," *** LYNX ERROR ***\rUnparsed data:\r");
        HText_appendText(me->text,me->xinclude);
        if (me->xinclude != (char *)0x0) {
          free(me->xinclude);
          me->xinclude = (char *)0x0;
        }
      }
      HText_endAppend(me->text);
    }
    if (0 < (me->option).size) {
      BVar1 = LYBadHTML(me);
      if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: SELECT or OPTION not ended properly *****\n");
      }
      if (WWW_TraceFlag != '\0') {
        HTChunkTerminate((HTChunk *)&me->option);
        if (WWW_TraceFlag != '\0') {
          s = (me->option).data;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML_free: ***** leftover option data: %s\n",s);
        }
      }
      HTChunkClear((HTChunk *)&me->option);
    }
    if (0 < (me->textarea).size) {
      BVar1 = LYBadHTML(me);
      if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: TEXTAREA not used properly *****\n");
      }
      if (WWW_TraceFlag != '\0') {
        HTChunkTerminate((HTChunk *)&me->textarea);
        if (WWW_TraceFlag != '\0') {
          s = (me->textarea).data;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTML_free: ***** leftover textarea data: %s\n",s);
        }
      }
      HTChunkClear((HTChunk *)&me->textarea);
    }
    if (me->target != (HTStream *)0x0) {
      (*(me->targetClass)._free)(me->target);
    }
    if (((me->sp != (stack_element *)0x0) && (me->sp->style != (HTStyle *)0x0)) &&
       (me->sp->style->name != (char *)0x0)) {
      if (((me->sp->style->id == 1) || (me->sp->style->id == 0x2f)) || (me->sp->style->id == 0x29))
      {
        me->sp->style->alignment = 3;
      }
      else {
        if ((me->sp->style->id == 3) || (me->sp->style->id == 0x31)) {
          me->sp->style->alignment = 2;
        }
        else {
          me->sp->style->alignment = 1;
        }
      }
      styles[86]->alignment = 1;
    }
    if (me->base_href != (char *)0x0) {
      free(me->base_href);
      me->base_href = (char *)0x0;
    }
    if (me->map_address != (char *)0x0) {
      free(me->map_address);
      me->map_address = (char *)0x0;
    }
    if (me->LastOptionValue != (char *)0x0) {
      free(me->LastOptionValue);
      me->LastOptionValue = (char *)0x0;
    }
    clear_objectdata(me);
    if (me != (HTStructured *)0x0) {
      free(me);
    }
  }
  else {
    if (me->base_href != (char *)0x0) {
      free(me->base_href);
      me->base_href = (char *)0x0;
    }
    if (me->map_address != (char *)0x0) {
      free(me->map_address);
      me->map_address = (char *)0x0;
    }
    clear_objectdata(me);
    if (me->xinclude != (char *)0x0) {
      free(me->xinclude);
      me->xinclude = (char *)0x0;
    }
    if (me != (HTStructured *)0x0) {
      free(me);
    }
  }
  return;
}



void HTML_abort(HTStructured *me,HTError e)

{
  char *pcVar1;
  FILE *__stream;
  char *include;
  
  include = (char *)0x0;
  if (me->text != (HText *)0x0) {
    if (me->inUnderline != '\0') {
      HText_appendCharacter(me->text,4);
      me->inUnderline = '\0';
      me->Underline_Level = 0;
    }
    if (me->inA != '\0') {
      HTML_end_element(me,0,&include);
      me->inA = '\0';
    }
    if (me->inFONT != '\0') {
      HTML_end_element(me,0x2b,&include);
      me->inFONT = '\0';
    }
    if (me->inFORM != '\0') {
      HTML_end_element(me,0x2c,&include);
      me->inFORM = '\0';
    }
    HText_endAppend(me->text);
  }
  if (0 < (me->option).size) {
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTML_abort: SELECT or OPTION not ended properly *****\n");
      }
      HTChunkTerminate((HTChunk *)&me->option);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = (me->option).data;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTML_abort: ***** leftover option data: %s\n",pcVar1);
      }
    }
    HTChunkClear((HTChunk *)&me->option);
  }
  if (0 < (me->textarea).size) {
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTML_abort: TEXTAREA not used properly *****\n");
      }
      HTChunkTerminate((HTChunk *)&me->textarea);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = (me->textarea).data;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTML_abort: ***** leftover textarea data: %s\n",pcVar1);
      }
    }
    HTChunkClear((HTChunk *)&me->textarea);
  }
  if (me->target != (HTStream *)0x0) {
    (*(me->targetClass)._abort)(me->target,e);
  }
  if (((me->sp != (stack_element *)0x0) && (me->sp->style != (HTStyle *)0x0)) &&
     (me->sp->style->name != (char *)0x0)) {
    if (((me->sp->style->id == 1) || (me->sp->style->id == 0x2f)) || (me->sp->style->id == 0x29)) {
      me->sp->style->alignment = 3;
    }
    else {
      if ((me->sp->style->id == 3) || (me->sp->style->id == 0x31)) {
        me->sp->style->alignment = 2;
      }
      else {
        me->sp->style->alignment = 1;
      }
    }
    styles[86]->alignment = 1;
  }
  if (me->base_href != (char *)0x0) {
    free(me->base_href);
    me->base_href = (char *)0x0;
  }
  if (me->map_address != (char *)0x0) {
    free(me->map_address);
    me->map_address = (char *)0x0;
  }
  if (me->textarea_name != (char *)0x0) {
    free(me->textarea_name);
    me->textarea_name = (char *)0x0;
  }
  if (me->textarea_accept_cs != (char *)0x0) {
    free(me->textarea_accept_cs);
    me->textarea_accept_cs = (char *)0x0;
  }
  if (me->textarea_id != (char *)0x0) {
    free(me->textarea_id);
    me->textarea_id = (char *)0x0;
  }
  if (me->LastOptionValue != (char *)0x0) {
    free(me->LastOptionValue);
    me->LastOptionValue = (char *)0x0;
  }
  if (me->xinclude != (char *)0x0) {
    free(me->xinclude);
    me->xinclude = (char *)0x0;
  }
  clear_objectdata(me);
  if (me != (HTStructured *)0x0) {
    free(me);
  }
  return;
}



void get_styles(void)

{
  HTStyle **st;
  
  st = (HTStyle **)0x0;
  styleSheet = DefaultStyle(&st);
  default_style = *st;
  styles[3] = st[0x27];
  styles[9] = st[4];
  styles[16] = st[5];
  styles[19] = st[6];
  styles[33] = st[0xf];
  styles[35] = st[0x16];
  styles[36] = st[0x1d];
  styles[42] = st[7];
  styles[47] = st[0x29];
  styles[48] = st[0x2a];
  styles[49] = st[0x2b];
  styles[50] = st[0x2c];
  styles[51] = st[0x2d];
  styles[52] = st[0x2e];
  styles[70] = st[0x26];
  styles[74] = st[0xf];
  styles[78] = st[0x28];
  styles[80] = st[8];
  styles[85] = st[0x24];
  styles[86] = st[0x25];
  styles[114] = st[8];
  styles[117] = st[0x24];
  styles[119] = st[9];
  styles[120] = st[10];
  styles[121] = st[0xb];
  styles[122] = st[0xc];
  styles[123] = st[0xd];
  styles[124] = st[0xe];
  styles[125] = st[0x10];
  styles[126] = st[0x11];
  styles[127] = st[0x12];
  styles[128] = st[0x13];
  styles[129] = st[0x14];
  styles[130] = st[0x15];
  styles[131] = st[0x17];
  styles[132] = st[0x18];
  styles[133] = st[0x19];
  styles[134] = st[0x1a];
  styles[135] = st[0x1b];
  styles[136] = st[0x1c];
  styles[137] = st[0x1e];
  styles[138] = st[0x1f];
  styles[139] = st[0x20];
  styles[140] = st[0x21];
  styles[141] = st[0x22];
  styles[142] = st[0x23];
  styles[143] = st[0x2f];
  styles[144] = st[0x30];
  styles[145] = st[0x31];
  styles[146] = st[1];
  styles[147] = st[2];
  styles[148] = st[3];
  return;
}



HTStyle * LYstyles(int style_number)

{
  if (styles[style_number] == (HTStyle *)0x0) {
    get_styles();
  }
  return styles[style_number];
}



HTStructured * HTML_new(HTParentAnchor *anchor,HTFormat format_out,HTStream *stream)

{
  HTStreamClass *pHVar1;
  FILE *__stream;
  HTAtom *rep_in;
  HTStream *output;
  HTStructured *me_00;
  int iVar2;
  LYUCcharset *pLVar3;
  HTStream *intermediate;
  HTStructured *me;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"start HTML_new\n");
  }
  rep_in = HTAtom_for("text/plain");
  if ((rep_in != (HTAtom *)format_out) &&
     (rep_in = HTAtom_for("www/present"), rep_in != (HTAtom *)format_out)) {
    rep_in = HTAtom_for("text/html");
    output = HTStreamStack((HTFormat)rep_in,format_out,stream,anchor);
    if (output != (HTStream *)0x0) {
      me_00 = HTMLGenerator(output);
      return me_00;
    }
    fprintf(stderr,"\n** Internal error: can\'t parse HTML to %s\n",format_out->name);
    exit_immediately(1);
  }
  me_00 = (HTStructured *)calloc(1,0x2144);
  if (me_00 == (HTStructured *)0x0) {
    outofmem("./HTML.c","HTML_new");
  }
  get_styles();
  me_00->isa = (HTStructuredClass *)0x8166ae0;
  me_00->node_anchor = anchor;
  me_00->CurrentA = (HTChildAnchor *)0x0;
  me_00->CurrentANum = 0;
  me_00->base_href = (char *)0x0;
  me_00->map_address = (char *)0x0;
  HTChunkInit((HTChunk *)&me_00->title,0x80);
  HTChunkInit((HTChunk *)&me_00->object,0x80);
  me_00->object_started = '\0';
  me_00->object_declare = '\0';
  me_00->object_shapes = '\0';
  me_00->object_ismap = '\0';
  me_00->object_id = (char *)0x0;
  me_00->object_title = (char *)0x0;
  me_00->object_data = (char *)0x0;
  me_00->object_type = (char *)0x0;
  me_00->object_classid = (char *)0x0;
  me_00->object_codebase = (char *)0x0;
  me_00->object_codetype = (char *)0x0;
  me_00->object_usemap = (char *)0x0;
  me_00->object_name = (char *)0x0;
  HTChunkInit((HTChunk *)&me_00->option,0x80);
  me_00->first_option = '\x01';
  me_00->LastOptionValue = (char *)0x0;
  me_00->LastOptionChecked = '\0';
  me_00->select_disabled = '\0';
  HTChunkInit((HTChunk *)&me_00->textarea,0x80);
  me_00->textarea_name = (char *)0x0;
  me_00->textarea_name_cs = -1;
  me_00->textarea_accept_cs = (char *)0x0;
  me_00->textarea_cols = 0;
  me_00->textarea_rows = 4;
  me_00->textarea_disabled = 0;
  me_00->textarea_id = (char *)0x0;
  HTChunkInit((HTChunk *)&me_00->math,0x80);
  HTChunkInit((HTChunk *)&me_00->style_block,0x80);
  HTChunkInit((HTChunk *)&me_00->script,0x80);
  me_00->text = (HText *)0x0;
  me_00->style_change = '\x01';
  me_00->new_style = default_style;
  me_00->old_style = (HTStyle *)0x0;
  me_00->current_default_alignment = 1;
  me_00->sp = me_00->stack + 799;
  me_00->skip_stack = 0;
  me_00->sp->tag_number = -1;
  me_00->sp->style = default_style;
  me_00->sp->style->alignment = 1;
  me_00->stack_overrun = '\0';
  me_00->Division_Level = -1;
  me_00->Underline_Level = 0;
  me_00->Quote_Level = 0;
  me_00->UsePlainSpace = '\0';
  me_00->HiddenValue = '\0';
  me_00->lastraw = -1;
  me_00->List_Nesting_Level = -1;
  LYZero_OL_Counter(me_00);
  me_00->Last_OL_Count = 0;
  me_00->Last_OL_Type = '1';
  me_00->inA = '\0';
  me_00->inAPPLET = '\0';
  me_00->inAPPLETwithP = '\0';
  me_00->inBadBASE = '\0';
  me_00->inBadHREF = '\0';
  me_00->inBadHTML = '\0';
  me_00->inBASE = '\0';
  me_00->node_anchor->inBASE = '\0';
  me_00->inBoldA = '\0';
  me_00->inBoldH = '\0';
  me_00->inCAPTION = '\0';
  me_00->inCREDIT = '\0';
  me_00->inFIG = '\0';
  me_00->inFIGwithP = '\0';
  me_00->inFONT = '\0';
  me_00->inFORM = '\0';
  me_00->inLABEL = '\0';
  me_00->inP = '\0';
  me_00->inPRE = '\0';
  me_00->inSELECT = '\0';
  me_00->inTABLE = '\0';
  me_00->inUnderline = '\0';
  me_00->needBoldH = '\0';
  me_00->comment_start = (char *)0x0;
  me_00->comment_end = (char *)0x0;
  addClassName("","",0);
  class_string[0] = '\0';
  LYGetChartransInfo(me_00);
  UCTransParams_clear(&me_00->T);
  iVar2 = HTAnchor_getUCLYhndl(me_00->node_anchor,1);
  me_00->inUCLYhndl = iVar2;
  if (me_00->inUCLYhndl < 0) {
    iVar2 = HTAnchor_getUCLYhndl(me_00->node_anchor,0);
    me_00->inUCLYhndl = iVar2;
    pLVar3 = HTAnchor_getUCInfoStage(me_00->node_anchor,0);
    me_00->inUCI = pLVar3;
  }
  else {
    pLVar3 = HTAnchor_getUCInfoStage(me_00->node_anchor,1);
    me_00->inUCI = pLVar3;
  }
  pLVar3 = HTAnchor_getUCInfoStage(me_00->node_anchor,2);
  me_00->outUCI = pLVar3;
  iVar2 = HTAnchor_getUCLYhndl(me_00->node_anchor,2);
  me_00->outUCLYhndl = iVar2;
  me_00->target = stream;
  if (stream != (HTStream *)0x0) {
    pHVar1 = stream->isa;
    (me_00->targetClass).name = pHVar1->name;
    (me_00->targetClass)._free = pHVar1->_free;
    (me_00->targetClass)._abort = pHVar1->_abort;
    (me_00->targetClass).put_character = pHVar1->put_character;
    (me_00->targetClass).put_string = pHVar1->put_string;
    (me_00->targetClass).put_block = pHVar1->put_block;
  }
  return me_00;
}



void CacheThru_do_free(HTStream *me)

{
  anon_subr_void_HTStream_ptr_char_ptr_for_put_string *paVar1;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  HTStreamClass *pHVar3;
  FILE *__stream;
  int iVar4;
  char *Msg;
  char *cp_freeme_1;
  char *cp_freeme;
  
  if (me[1].isa[3].put_string != (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0) {
    if (WWW_TraceFlag != '\0') {
      paVar1 = me[1].isa[3].put_string;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SourceCacheWriter: Removing previous file %s\n",paVar1);
    }
    LYRemoveTemp((char *)me[1].isa[3].put_string);
    if (me[1].isa[3].put_string != (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0) {
      free(me[1].isa[3].put_string);
      me[1].isa[3].put_string = (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0;
    }
  }
  if (me[1].isa[3].put_block != (anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *)0x0) {
    if (WWW_TraceFlag != '\0') {
      paVar2 = me[1].isa[3].put_block;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SourceCacheWriter: Removing previous memory chunk %p\n",paVar2);
    }
    HTChunkFree((HTChunk *)me[1].isa[3].put_block);
    me[1].isa[3].put_block = (anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *)0x0;
  }
  if (me[2].isa == (HTStreamClass *)0x0) {
    if (me[8].isa != (HTStreamClass *)0x0) {
      if (me[4].isa != (HTStreamClass *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pHVar3 = me[4].isa;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SourceCacheWriter: memory chunk %p had errors.\n",pHVar3);
        }
        HTChunkFree((HTChunk *)me[4].isa);
        me[5].isa = (HTStreamClass *)0x0;
        me[4].isa = me[5].isa;
      }
      Msg = (char *)gettext("Source cache error - not enough memory!");
      HTAlert(Msg);
    }
  }
  else {
    fflush((FILE *)me[2].isa);
    iVar4 = ferror((FILE *)me[2].isa);
    if (iVar4 != 0) {
      me[8].isa = (HTStreamClass *)0xffffffff;
    }
    LYCloseTempFP((FILE *)me[2].isa);
    if (me[8].isa == (HTStreamClass *)0x0) {
      cp_freeme = (char *)0x0;
      *(HTStreamClass **)&me[1].isa[3].put_string = me[3].isa;
      if (WWW_TraceFlag != '\0') {
        cp_freeme = HTAnchor_address((HTAnchor *)me[1].isa);
        pHVar3 = me[3].isa;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SourceCacheWriter: Committing file %s for URL %s to anchor\n",
                pHVar3,cp_freeme);
      }
      if (cp_freeme != (char *)0x0) {
        free(cp_freeme);
      }
    }
    else {
      if (source_cache_file_error == '\0') {
        Msg = (char *)gettext("Source cache error - disk full?");
        HTAlert(Msg);
        source_cache_file_error = '\x01';
      }
      LYRemoveTemp((char *)me[3].isa);
      me[1].isa[3].put_string = (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0;
    }
  }
  if (me[4].isa != (HTStreamClass *)0x0) {
    cp_freeme_1 = (char *)0x0;
    *(HTStreamClass **)&me[1].isa[3].put_block = me[4].isa;
    if (WWW_TraceFlag != '\0') {
      cp_freeme_1 = HTAnchor_address((HTAnchor *)me[1].isa);
      pHVar3 = me[4].isa;
      __stream = TraceFP();
      fprintf((FILE *)__stream,
              "SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",pHVar3,
              cp_freeme_1);
    }
    if (cp_freeme_1 != (char *)0x0) {
      free(cp_freeme_1);
    }
  }
  return;
}



void CacheThru_free(HTStream *me)

{
  CacheThru_do_free(me);
  (*(me[6].isa)->_free)((HTStream *)me[7].isa);
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



void CacheThru_abort(HTStream *me,HTError e)

{
  HTStreamClass *pHVar1;
  FILE *__stream;
  
  if (me[2].isa != (HTStreamClass *)0x0) {
    LYCloseTempFP((FILE *)me[2].isa);
  }
  if (LYCacheSourceForAborted == 0) {
    if (me[3].isa != (HTStreamClass *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pHVar1 = me[3].isa;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SourceCacheWriter: Removing active file %s\n",pHVar1);
      }
      LYRemoveTemp((char *)me[3].isa);
      if (me[3].isa != (HTStreamClass *)0x0) {
        free(me[3].isa);
        me[3].isa = (HTStreamClass *)0x0;
      }
    }
    if (me[4].isa != (HTStreamClass *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pHVar1 = me[4].isa;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SourceCacheWriter: Removing active memory chunk %p\n",pHVar1);
      }
      HTChunkFree((HTChunk *)me[4].isa);
    }
  }
  else {
    me[8].isa = (HTStreamClass *)0x0;
    CacheThru_do_free(me);
  }
  (*(me[6].isa)->_abort)((HTStream *)me[7].isa,e);
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



void CacheThru_put_character(HTStream *me,char c_in)

{
  HTStreamClass *pHVar1;
  
  if (me[8].isa == (HTStreamClass *)0x0) {
    if (me[2].isa == (HTStreamClass *)0x0) {
      if (me[4].isa != (HTStreamClass *)0x0) {
        pHVar1 = (HTStreamClass *)HTChunkPutc2((HTChunk *)me[5].isa,c_in);
        me[5].isa = pHVar1;
        if ((me[5].isa == (HTStreamClass *)0x0) ||
           ((me[5].isa)->_abort == (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0)) {
          me[8].isa = (HTStreamClass *)0xffffffff;
        }
      }
    }
    else {
      fputc((int)c_in,(FILE *)me[2].isa);
    }
  }
  (*(me[6].isa)->put_character)((HTStream *)me[7].isa,c_in);
  return;
}



void CacheThru_put_string(HTStream *me,char *str)

{
  HTStreamClass *pHVar1;
  
  if (me[8].isa == (HTStreamClass *)0x0) {
    if (me[2].isa == (HTStreamClass *)0x0) {
      if (me[4].isa != (HTStreamClass *)0x0) {
        pHVar1 = (HTStreamClass *)HTChunkPuts2((HTChunk *)me[5].isa,str);
        me[5].isa = pHVar1;
        if ((me[5].isa == (HTStreamClass *)0x0) ||
           ((me[5].isa)->_abort == (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0)) {
          me[8].isa = (HTStreamClass *)0xffffffff;
        }
      }
    }
    else {
      fputs(str,(FILE *)me[2].isa);
    }
  }
  (*(me[6].isa)->put_string)((HTStream *)me[7].isa,str);
  return;
}



void CacheThru_write(HTStream *me,char *str,int l)

{
  int iVar1;
  HTStreamClass *pHVar2;
  
  if ((me[8].isa == (HTStreamClass *)0x0) && (l != 0)) {
    if (me[2].isa == (HTStreamClass *)0x0) {
      if (me[4].isa != (HTStreamClass *)0x0) {
        pHVar2 = (HTStreamClass *)HTChunkPutb2((HTChunk *)me[5].isa,str,l);
        me[5].isa = pHVar2;
        if ((me[5].isa == (HTStreamClass *)0x0) ||
           ((me[5].isa)->_abort == (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0)) {
          me[8].isa = (HTStreamClass *)0xffffffff;
        }
      }
    }
    else {
      fwrite(str,1,l,(FILE *)me[2].isa);
      iVar1 = ferror((FILE *)me[2].isa);
      if (iVar1 != 0) {
        me[8].isa = (HTStreamClass *)0xffffffff;
      }
    }
  }
  (*(me[6].isa)->put_block)((HTStream *)me[7].isa,str,l);
  return;
}



HTStream * CacheThru_new(HTParentAnchor *anchor,HTStream *target)

{
  int iVar1;
  char **ppcVar2;
  char *pcVar3;
  HTChunk *pHVar4;
  int iVar5;
  FILE *__stream;
  HTStreamClass *pHVar6;
  int in_GS_OFFSET;
  HTStream *local_124;
  HTProtocol *p;
  HTStream *stream;
  char *cp_freeme;
  char filename [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp_freeme = (char *)0x0;
  ppcVar2 = (char **)anchor->protocol;
  if (LYCacheSource == 0) {
    local_124 = target;
  }
  else {
    iVar5 = strcmp(*ppcVar2,"http");
    if ((iVar5 == 0) || (iVar5 = strcmp(*ppcVar2,"https"), iVar5 == 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"start CacheThru_new\n");
      }
      local_124 = (HTStream *)malloc(0x24);
      if (local_124 == (HTStream *)0x0) {
        outofmem("./HTML.c","CacheThru_new");
      }
      local_124->isa = (HTStreamClass *)0x8166d40;
      *(HTParentAnchor **)&local_124[1].isa = anchor;
      local_124[2].isa = (HTStreamClass *)0x0;
      local_124[3].isa = (HTStreamClass *)0x0;
      local_124[4].isa = (HTStreamClass *)0x0;
      *(HTStream **)&local_124[7].isa = target;
      local_124[6].isa = target->isa;
      local_124[8].isa = (HTStreamClass *)0x0;
      if (LYCacheSource == 1) {
        if ((anchor->source_cache_file != (char *)0x0) && (WWW_TraceFlag != '\0')) {
          pcVar3 = anchor->source_cache_file;
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "SourceCacheWriter: If successful, will replace source cache file %s\n",pcVar3);
        }
        __stream = LYOpenTemp(filename,".html","wb");
        *(FILE **)&local_124[2].isa = __stream;
        if (local_124[2].isa == (HTStreamClass *)0x0) {
          if (WWW_TraceFlag != '\0') {
            cp_freeme = HTAnchor_address((HTAnchor *)anchor);
            __stream = TraceFP();
            fprintf((FILE *)__stream,"SourceCacheWriter: Cannot open source cache file for URL %s\n"
                    ,cp_freeme);
          }
          if (local_124 != (HTStream *)0x0) {
            free(local_124);
          }
          if (cp_freeme != (char *)0x0) {
            free(cp_freeme);
          }
          local_124 = target;
          goto LAB_080cf851;
        }
        HTSACopy((char **)(local_124 + 3),filename);
        if (WWW_TraceFlag != '\0') {
          cp_freeme = HTAnchor_address((HTAnchor *)anchor);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SourceCacheWriter: Caching source for URL %s in file %s\n",
                  cp_freeme,filename);
        }
        if (cp_freeme != (char *)0x0) {
          free(cp_freeme);
          cp_freeme = (char *)0x0;
        }
      }
      if (LYCacheSource == 2) {
        if ((anchor->source_cache_chunk != (HTChunk *)0x0) && (WWW_TraceFlag != '\0')) {
          pHVar4 = anchor->source_cache_chunk;
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "SourceCacheWriter: If successful, will replace memory chunk %p\n",pHVar4);
        }
        pHVar6 = (HTStreamClass *)HTChunkCreateMayFail(0x1000,1);
        local_124[5].isa = pHVar6;
        local_124[4].isa = local_124[5].isa;
        if (local_124[4].isa == (HTStreamClass *)0x0) {
          local_124[8].isa = (HTStreamClass *)0xffffffff;
        }
        if (WWW_TraceFlag != '\0') {
          pHVar6 = local_124[4].isa;
          cp_freeme = HTAnchor_address((HTAnchor *)anchor);
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",cp_freeme,
                  pHVar6);
        }
        if (cp_freeme != (char *)0x0) {
          free(cp_freeme);
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pcVar3 = *ppcVar2;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SourceCacheWriter: Protocol is \"%s\"; not cached\n",pcVar3);
      }
      local_124 = target;
    }
  }
LAB_080cf851:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_124;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



HTStream * HTMLToPlain(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  FILE *__stream;
  HTStructured *target;
  HTStream *target_00;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLToPlain calling CacheThru_new\n");
  }
  target = HTML_new(anchor,(HTFormat)pres->rep_out,sink);
  target_00 = SGML_new(&HTML_dtd,anchor,target);
  target_00 = CacheThru_new(anchor,target_00);
  return target_00;
}



HTStream * HTMLParsedPresent(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTFormat rep_out;
  int LYhndl;
  HTAtom *rep_in;
  HTAtom *rep_in_00;
  FILE *__stream;
  HTStructured *target;
  HTStream *target_00;
  HTStream *local_1c;
  int structured_cset;
  int old_parser_cset;
  HTStream *intermediate;
  
  intermediate = sink;
  if (sink == (HTStream *)0x0) {
    LYhndl = HTAnchor_getUCLYhndl(anchor,1);
    structured_cset = HTAnchor_getUCLYhndl(anchor,2);
    if (structured_cset < 0) {
      structured_cset = HTAnchor_getUCLYhndl(anchor,3);
    }
    if (structured_cset < 0) {
      structured_cset = current_char_set;
    }
    HTAnchor_setUCInfoStage(anchor,structured_cset,1,5);
    if (pres->rep_out == WWW_SOURCE) {
      rep_in = HTAtom_for("www/present");
      rep_in_00 = HTAtom_for("text/plain");
      intermediate = HTStreamStack((HTFormat)rep_in_00,(HTFormat)rep_in,(HTStream *)0x0,anchor);
    }
    else {
      rep_out = (HTFormat)pres->rep_out;
      rep_in = HTAtom_for("text/plain");
      intermediate = HTStreamStack((HTFormat)rep_in,rep_out,(HTStream *)0x0,anchor);
    }
    if (LYhndl != structured_cset) {
      HTAnchor_resetUCInfoStage(anchor,LYhndl,1,0);
      if (-1 < LYhndl) {
        HTAnchor_setUCInfoStage(anchor,LYhndl,1,2);
      }
    }
  }
  if (intermediate == (HTStream *)0x0) {
    local_1c = (HTStream *)0x0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMLParsedPresent calling CacheThru_new\n");
    }
    target = HTMLGenerator(intermediate);
    target_00 = SGML_new(&HTML_dtd,anchor,target);
    local_1c = CacheThru_new(anchor,target_00);
  }
  return local_1c;
}



HTStream * HTMLToC(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTAtom *format_out;
  HTStructured *me;
  FILE *__stream;
  HTStream *target;
  HTStructured *html;
  
  if (sink != (HTStream *)0x0) {
    (*sink->isa->put_string)(sink,"/* ");
  }
  format_out = HTAtom_for("text/plain");
  me = HTML_new(anchor,(HTFormat)format_out,sink);
  me->comment_start = "/* ";
  me->comment_end = " */\n";
  if (sink == (HTStream *)0x0) {
    HTML_put_string(me,me->comment_start);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLToC calling CacheThru_new\n");
  }
  target = SGML_new(&HTML_dtd,anchor,me);
  target = CacheThru_new(anchor,target);
  return target;
}



HTStream * HTMLPresent(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  FILE *__stream;
  HTAtom *format_out;
  HTStructured *target;
  HTStream *target_00;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLPresent calling CacheThru_new\n");
  }
  format_out = HTAtom_for("www/present");
  target = HTML_new(anchor,(HTFormat)format_out,(HTStream *)0x0);
  target_00 = SGML_new(&HTML_dtd,anchor,target);
  target_00 = CacheThru_new(anchor,target_00);
  return target_00;
}



int HTLoadError(HTStream *sink,int number,char *message)

{
  HTAlert(message);
  return -number;
}



char * MakeNewTitle(char **value,int src_type)

{
  char *newtitle;
  char *ptr;
  
  newtitle = (char *)0x0;
  HTSACopy(&newtitle,"[");
  if ((value == (char **)0x0) || (value[src_type] == (char *)0x0)) {
    ptr = (char *)0x0;
  }
  else {
    ptr = strrchr(value[src_type],0x2f);
  }
  if (ptr == (char *)0x0) {
    HTSACat(&newtitle,value[src_type]);
  }
  else {
    HTSACat(&newtitle,ptr + 1);
  }
  HTSACat(&newtitle,"]");
  return newtitle;
}



char * MakeNewImageValue(char **value)

{
  char *local_18;
  char *newtitle;
  char *ptr;
  
  newtitle = (char *)0x0;
  HTSACopy(&newtitle,"[");
  if (value[0x1b] == (char *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = strrchr(value[0x1b],0x2f);
  }
  if (local_18 == (char *)0x0) {
    HTSACat(&newtitle,value[0x1b]);
  }
  else {
    HTSACat(&newtitle,local_18 + 1);
  }
  HTSACat(&newtitle,"]-Submit");
  return newtitle;
}



char * MakeNewMapValue(char **value,char *mapstr)

{
  char *pcVar1;
  char *newtitle;
  char *ptr;
  
  newtitle = (char *)0x0;
  HTSACopy(&newtitle,"[");
  HTSACat(&newtitle,mapstr);
  if (((verbose_img != '\0') && (value[0xf] != (char *)0x0)) && (*value[0xf] != '\0')) {
    HTSACat(&newtitle,":");
    pcVar1 = strrchr(value[0xf],0x2f);
    if (pcVar1 == (char *)0x0) {
      HTSACat(&newtitle,value[0xf]);
    }
    else {
      HTSACat(&newtitle,pcVar1 + 1);
    }
  }
  HTSACat(&newtitle,"]");
  return newtitle;
}



void HTFWriter_error(HTStream *me,char *id)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  int in_GS_OFFSET;
  char buf [200];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  piVar2 = __errno_location();
  pcVar3 = strerror(*piVar2);
  sprintf(buf,"%.60s: %.60s: %.60s",id,me->isa->name,pcVar3);
  HTAlert(buf);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTFWriter_put_character(HTStream *me,char c)

{
  if (me[1].isa != (HTStreamClass *)0x0) {
    _IO_putc((int)c,(_IO_FILE *)me[1].isa);
  }
  return;
}



void HTFWriter_put_string(HTStream *me,char *s)

{
  if (me[1].isa != (HTStreamClass *)0x0) {
    fputs(s,(FILE *)me[1].isa);
  }
  return;
}



void HTFWriter_write(HTStream *me,char *s,int l)

{
  size_t sVar1;
  size_t result;
  
  if (me[1].isa != (HTStreamClass *)0x0) {
    sVar1 = fwrite(s,1,l,(FILE *)me[1].isa);
    if (l != sVar1) {
      HTFWriter_error(me,"HTFWriter_write");
    }
  }
  return;
}



void HTFWriter_free(HTStream *me)

{
  HTStreamClass *pHVar1;
  bool bVar2;
  HTStreamClass *pHVar3;
  size_t sVar4;
  int iVar5;
  char *argument;
  char *message;
  bool bVar6;
  int status;
  char *addr;
  char *path;
  int len;
  BOOLEAN skip_loadfile;
  BOOLEAN found;
  BOOLEAN use_zread;
  
  path = (char *)0x0;
  addr = (char *)0x0;
  bVar2 = false;
  found = '\0';
  if (me[1].isa != (HTStreamClass *)0x0) {
    fflush((FILE *)me[1].isa);
  }
  if (me[2].isa != (HTStreamClass *)0x0) {
    LYCloseTempFP((FILE *)me[1].isa);
    pHVar1 = me[5].isa;
    pHVar3 = (HTStreamClass *)HTAtom_for("www/compressed");
    if (pHVar1 == pHVar3) {
      if (me[7].isa[4].name != (char *)0x0) {
        bVar6 = me[4].isa != (HTStreamClass *)0x0;
        HTSACopy(&path,me[7].isa[4].name);
        sVar4 = strlen(path);
        if (((int)sVar4 < 4) ||
           ((iVar5 = strcasecomp(path + (sVar4 - 2),"gz"), iVar5 != 0 &&
            (iVar5 = strcasecomp(path + (sVar4 - 2),"zz"), iVar5 != 0)))) {
          if (((int)sVar4 < 5) || (iVar5 = strcasecomp(path + (sVar4 - 3),"bz2"), iVar5 != 0)) {
            if ((2 < (int)sVar4) && (iVar5 = strcasecomp(path + (sVar4 - 1),"Z"), iVar5 == 0)) {
              path[sVar4 - 2] = '\0';
              remove(path);
            }
          }
          else {
            path[sVar4 - 4] = '\0';
            remove(path);
          }
        }
        else {
          if (bVar6) {
            path[sVar4 - 3] = '\0';
            remove(path);
          }
          else {
            bVar2 = true;
          }
        }
        if (!bVar2) {
          if (dump_output_immediately == '\0') {
            mustshow = '\x01';
            HTProgress((char *)me[2].isa);
          }
          if ((me[2].isa != (HTStreamClass *)0x0) && (*(char *)&(me[2].isa)->name != '\0')) {
            LYSystem((char *)me[2].isa);
          }
          found = LYCanReadFile(me[7].isa[4].name);
        }
        if (found == '\0') {
          LYLocalFileToURL(&addr,path);
          if (!bVar2) {
            LYRenamedTemp(me[7].isa[4].name,path);
            HTSACopy((char **)(me[7].isa + 4),path);
            HTSACopy((char **)&me[7].isa[5]._free,"binary");
          }
          if (path != (char *)0x0) {
            free(path);
            path = (char *)0x0;
          }
          if (!bVar6) {
            iVar5 = HTAnchor_getUCLYhndl((HTParentAnchor *)me[7].isa,1);
            if (iVar5 < 0) {
              HTAnchor_copyUCInfoStage((HTParentAnchor *)me[7].isa,1,0,2);
            }
            HTAnchor_copyUCInfoStage((HTParentAnchor *)me[7].isa,1,0,-1);
          }
          argument = addr;
          if (dump_output_immediately == '\0') {
            message = (char *)gettext("Using %s");
            LYstore_message2(message,argument);
          }
          if (bVar6) {
            if (me[2].isa != (HTStreamClass *)0x0) {
              free(me[2].isa);
              me[2].isa = (HTStreamClass *)0x0;
            }
            HTAddParam((char **)(me + 2),(char *)me[4].isa,1,me[7].isa[4].name);
            HTEndParam((char **)(me + 2),(char *)me[4].isa,1);
            if (dump_output_immediately == '\0') {
              HTProgress((char *)me[2].isa);
              stop_curses();
            }
            LYSystem((char *)me[2].isa);
            if ((me[3].isa != (HTStreamClass *)0x0) && (me[3].isa != (HTStreamClass *)0x0)) {
              free(me[3].isa);
              me[3].isa = (HTStreamClass *)0x0;
            }
            if (dump_output_immediately == '\0') {
              start_curses();
            }
          }
          else {
            HTLoadFile(addr,(HTParentAnchor *)me[7].isa,(HTFormat)me[6].isa,(HTStream *)me[8].isa);
          }
          if ((dump_output_immediately != '\0') &&
             (pHVar1 = me[6].isa, pHVar3 = (HTStreamClass *)HTAtom_for("www/present"),
             pHVar1 == pHVar3)) {
            if (addr != (char *)0x0) {
              free(addr);
              addr = (char *)0x0;
            }
            remove(me[7].isa[4].name);
            if (me[7].isa[4].name != (char *)0x0) {
              free(me[7].isa[4].name);
              me[7].isa[4].name = (char *)0x0;
            }
            if (me[3].isa != (HTStreamClass *)0x0) {
              free(me[3].isa);
              me[3].isa = (HTStreamClass *)0x0;
            }
            if (me[2].isa != (HTStreamClass *)0x0) {
              free(me[2].isa);
              me[2].isa = (HTStreamClass *)0x0;
            }
            if (me[4].isa != (HTStreamClass *)0x0) {
              free(me[4].isa);
              me[4].isa = (HTStreamClass *)0x0;
            }
            if (me == (HTStream *)0x0) {
              return;
            }
            free(me);
            return;
          }
        }
        else {
          if (dump_output_immediately == '\0') {
            lynx_force_repaint();
            LYrefresh();
          }
          argument = (char *)gettext("Error uncompressing temporary file!");
          HTAlert(argument);
          LYRemoveTemp(me[7].isa[4].name);
          if (me[7].isa[4].name != (char *)0x0) {
            free(me[7].isa[4].name);
            me[7].isa[4].name = (char *)0x0;
          }
        }
        if (addr != (char *)0x0) {
          free(addr);
          addr = (char *)0x0;
        }
      }
      if ((me[3].isa != (HTStreamClass *)0x0) && (me[3].isa != (HTStreamClass *)0x0)) {
        free(me[3].isa);
        me[3].isa = (HTStreamClass *)0x0;
      }
    }
    else {
      iVar5 = strcmp((char *)me[2].isa,"SaveToFile");
      if (iVar5 == 0) {
        if ((me[3].isa != (HTStreamClass *)0x0) && (me[3].isa != (HTStreamClass *)0x0)) {
          free(me[3].isa);
          me[3].isa = (HTStreamClass *)0x0;
        }
        if (dump_output_immediately == '\0') {
          start_curses();
        }
      }
      else {
        if (dump_output_immediately == '\0') {
          mustshow = '\x01';
          HTProgress((char *)me[2].isa);
          stop_curses();
        }
        LYSystem((char *)me[2].isa);
        if ((me[3].isa != (HTStreamClass *)0x0) && (me[3].isa != (HTStreamClass *)0x0)) {
          free(me[3].isa);
          me[3].isa = (HTStreamClass *)0x0;
        }
        if (dump_output_immediately == '\0') {
          start_curses();
        }
      }
    }
    if (me[2].isa != (HTStreamClass *)0x0) {
      free(me[2].isa);
      me[2].isa = (HTStreamClass *)0x0;
    }
  }
  if (me[4].isa != (HTStreamClass *)0x0) {
    free(me[4].isa);
    me[4].isa = (HTStreamClass *)0x0;
  }
  if (dump_output_immediately != '\0') {
    if (me[7].isa[4].name != (char *)0x0) {
      remove(me[7].isa[4].name);
    }
    if (me != (HTStream *)0x0) {
      free(me);
      me = (HTStream *)0x0;
    }
    if (persistent_cookies != '\0') {
      LYStoreCookies(LYCookieSaveFile);
    }
    exit_immediately(0);
  }
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



void HTFWriter_abort(HTStream *me,HTError e)

{
  int iVar1;
  HTStreamClass *pHVar2;
  FILE *__stream;
  int iVar3;
  int *piVar4;
  char *pcVar5;
  undefined4 uVar6;
  int in_GS_OFFSET;
  char buf [560];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFWriter_abort called\n");
  }
  LYCloseTempFP((FILE *)me[1].isa);
  if (me[4].isa != (HTStreamClass *)0x0) {
    free(me[4].isa);
    me[4].isa = (HTStreamClass *)0x0;
  }
  if (me[2].isa != (HTStreamClass *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFWriter: Aborting: file not executed or saved.\n");
    }
    if (me[2].isa != (HTStreamClass *)0x0) {
      free(me[2].isa);
      me[2].isa = (HTStreamClass *)0x0;
    }
    if (me[3].isa != (HTStreamClass *)0x0) {
      chmod((char *)me[3].isa,0x180);
      iVar3 = unlink((char *)me[3].isa);
      if (iVar3 != 0) {
        piVar4 = __errno_location();
        pcVar5 = strerror(*piVar4);
        pHVar2 = me[3].isa;
        uVar6 = gettext("Error deleting file");
        sprintf(buf,"%.60s \'%.400s\': %.60s",uVar6,pHVar2,pcVar5);
        HTAlert(buf);
      }
      if (me[3].isa != (HTStreamClass *)0x0) {
        free(me[3].isa);
        me[3].isa = (HTStreamClass *)0x0;
      }
    }
  }
  if (WWW_Download_File != (char *)0x0) {
    free(WWW_Download_File);
    WWW_Download_File = (char *)0x0;
  }
  if (me != (HTStream *)0x0) {
    free(me);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



HTStream * HTFWriter_new(FILE *fp)

{
  HTStream *local_18;
  HTStream *me;
  
  if (fp == (FILE *)0x0) {
    local_18 = (HTStream *)0x0;
  }
  else {
    local_18 = (HTStream *)calloc(1,0x24);
    if (local_18 == (HTStream *)0x0) {
      outofmem("./HTFWriter.c","HTFWriter_new");
    }
    local_18->isa = (HTStreamClass *)0x81670c4;
    *(FILE **)&local_18[1].isa = fp;
    local_18[2].isa = (HTStreamClass *)0x0;
    local_18[3].isa = (HTStreamClass *)0x0;
    local_18[7].isa = (HTStreamClass *)0x0;
    local_18[8].isa = (HTStreamClass *)0x0;
  }
  return local_18;
}



char * mailcap_substitute(HTParentAnchor *anchor,HTPresentation *pres,char *fnam)

{
  BOOLEAN BVar1;
  char *format;
  char *prepend;
  char *result;
  
  result = LYMakeMailcapCommand(pres->command,anchor->content_type_params,fnam);
  BVar1 = LYMailcapUsesPctS(pres->command);
  if (BVar1 == '\0') {
    prepend = (char *)0x0;
    HTSprintf(&prepend,"( %s",result);
    HTAddParam(&prepend,"( %s ) < %s",2,fnam);
    if (result != (char *)0x0) {
      free(result);
    }
    result = prepend;
  }
  return result;
}



HTStream * HTSaveAndExecute(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  int iVar1;
  BOOLEAN BVar2;
  int iVar3;
  char *Msg;
  char *fmt;
  FILE *pFVar4;
  HTStreamClass *pHVar5;
  int in_GS_OFFSET;
  HTStream *local_128;
  char *buf;
  HTStream *me;
  char *suffix;
  char fnam [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (traversal != '\0') {
    LYCancelledFetch = '\x01';
    local_128 = (HTStream *)0x0;
    goto LAB_080d0eeb;
  }
  if (pres->quality < 999.00000000) goto LAB_080d0bc4;
  if (dump_output_immediately != '\0') {
    LYCancelledFetch = '\x01';
    local_128 = (HTStream *)0x0;
    goto LAB_080d0eeb;
  }
  if (no_exec != '\0') {
    Msg = (char *)gettext("Execution is disabled.");
    HTAlert(Msg);
    local_128 = HTPlainPresent(pres,anchor,sink);
    goto LAB_080d0eeb;
  }
  if (local_exec == '\0') {
    if (local_exec_on_local_files == '\0') {
LAB_080d0b2d:
      buf = (char *)0x0;
      Msg = key_for_func(0x31);
      fmt = (char *)gettext(
                           "Execution is not enabled for this file.  See the Options menu (use %s)."
                           );
      HTSprintf0(&buf,fmt,Msg);
      HTAlert(buf);
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      local_128 = HTPlainPresent(pres,anchor,sink);
      goto LAB_080d0eeb;
    }
    if (LYJumpFileURL == '\0') {
      iVar3 = strncmp(anchor->address,"file://localhost",0x10);
      if (iVar3 != 0) goto LAB_080d0b2d;
    }
  }
LAB_080d0bc4:
  if (dump_output_immediately == '\0') {
    local_128 = (HTStream *)calloc(1,0x24);
    if (local_128 == (HTStream *)0x0) {
      outofmem("./HTFWriter.c","HTSaveAndExecute");
    }
    local_128->isa = (HTStreamClass *)0x81670c4;
    local_128[5].isa = (HTStreamClass *)pres->rep;
    local_128[6].isa = (HTStreamClass *)pres->rep_out;
    *(HTParentAnchor **)&local_128[7].isa = anchor;
    *(HTStream **)&local_128[8].isa = sink;
    BVar2 = LYCachedTemp(fnam,&anchor->FileCache);
    if (BVar2 == '\0') {
      iVar3 = strcasecomp(pres->rep->name,"text/html");
      if (iVar3 == 0) {
        suffix = ".html";
      }
      else {
        iVar3 = strncasecomp(pres->rep->name,"text/",5);
        if (iVar3 == 0) {
          suffix = ".txt";
        }
        else {
          suffix = HTFileSuffix(pres->rep,anchor->content_encoding);
          if ((suffix == (char *)0x0) || (*suffix != '.')) {
            iVar3 = strncasecomp(pres->rep->name,"application/",0xc);
            if (iVar3 == 0) {
              suffix = ".bin";
            }
            else {
              suffix = ".html";
            }
          }
        }
      }
      pFVar4 = LYOpenTemp(fnam,suffix,"wb");
      *(FILE **)&local_128[1].isa = pFVar4;
    }
    else {
      pFVar4 = LYOpenTempRewrite(fnam,".bin","wb");
      *(FILE **)&local_128[1].isa = pFVar4;
    }
    if (local_128[1].isa == (HTStreamClass *)0x0) {
      Msg = (char *)gettext("Can\'t open temporary file!");
      HTAlert(Msg);
      if (local_128 != (HTStream *)0x0) {
        free(local_128);
      }
      local_128 = (HTStream *)0x0;
    }
    else {
      HTSACopy((char **)(local_128 + 4),pres->command);
      pHVar5 = (HTStreamClass *)mailcap_substitute(anchor,pres,fnam);
      local_128[2].isa = pHVar5;
      local_128[3].isa = (HTStreamClass *)0x0;
      HTAddParam((char **)(local_128 + 3),"%s",1,fnam);
      HTEndParam((char **)(local_128 + 3),"%s",1);
      HTSACopy(&anchor->FileCache,fnam);
    }
  }
  else {
    local_128 = HTSaveToFile(pres,anchor,sink);
  }
LAB_080d0eeb:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_128;
}



HTStream * HTSaveToFile(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  int iVar1;
  LYKeymap_t LVar2;
  BOOLEAN BVar3;
  HTAtom *pHVar4;
  char *text;
  char *message;
  FILE *pFVar5;
  int iVar6;
  UrlTypes UVar7;
  int in_GS_OFFSET;
  HTStream *local_13c;
  char *local_138;
  char *temp;
  int c;
  char *cp;
  char *suffix;
  HTStream *ret_obj;
  BOOLEAN IsBinary;
  char fnam [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  c = 0;
  local_13c = (HTStream *)calloc(1,0x24);
  if (local_13c == (HTStream *)0x0) {
    outofmem("./HTFWriter.c","HTSaveToFile");
  }
  local_13c->isa = (HTStreamClass *)0x81670c4;
  local_13c[3].isa = (HTStreamClass *)0x0;
  local_13c[2].isa = (HTStreamClass *)0x0;
  local_13c[5].isa = (HTStreamClass *)pres->rep;
  local_13c[6].isa = (HTStreamClass *)pres->rep_out;
  *(HTParentAnchor **)&local_13c[7].isa = anchor;
  *(HTStream **)&local_13c[8].isa = sink;
  if (dump_output_immediately == '\0') {
    LYCancelDownload = '\0';
    pHVar4 = HTAtom_for("www/download");
    if (pHVar4 != (HTAtom *)HTOutputFormat) {
      if ((traversal != '\0') ||
         (((no_download != '\0' && (override_no_download == '\0')) && (no_disk_save != '\0')))) {
        if (traversal == '\0') {
          text = (char *)gettext("This file cannot be displayed on this terminal.");
          HTAlert(text);
        }
        LYCancelDownload = '\x01';
        if (traversal != '\0') {
          LYCancelledFetch = '\x01';
        }
        if (local_13c != (HTStream *)0x0) {
          free(local_13c);
        }
        local_13c = (HTStream *)0x0;
        goto LAB_080d197d;
      }
      text = strchr(pres->rep->name,0x3b);
      if ((text == (char *)0x0) || (text = strstr(text + 1,"charset"), text == (char *)0x0)) {
        if (*pres->rep->name == '\0') {
          mustshow = '\x01';
          text = (char *)gettext(
                                "This file cannot be displayed on this terminal:  D)ownload, or C)ancel"
                                );
          statusline(text);
        }
        else {
          mustshow = '\x01';
          text = pres->rep->name;
          message = (char *)gettext("%s  D)ownload, or C)ancel");
          user_message(message,text);
        }
      }
      else {
        mustshow = '\x01';
        text = pres->rep->name;
        message = (char *)gettext("%s  D)ownload, or C)ancel");
        user_message(message,text);
      }
      while (((c != 0x44 && (c != 0x43)) && ((c != 3 && (c != 7))))) {
        LVar2 = keymap[0];
        if (c == -1) {
joined_r0x080d11f7:
          if (LVar2 == 0x2f) break;
        }
        else {
          if ((c & 0x8800U) == 0) {
            LVar2 = keymap[(c & 0x7ffU) + 1];
            goto joined_r0x080d11f7;
          }
          if ((c & 0xffU) == 0x2f) break;
        }
        c = LYgetch_single();
      }
      if (((c != 0x43) && (c != 3)) && (c != 7)) {
        LVar2 = keymap[0];
        if (c != -1) {
          if ((c & 0x8800U) != 0) {
            if ((c & 0xffU) != 0x2f) goto LAB_080d1301;
            goto LAB_080d12af;
          }
          LVar2 = keymap[(c & 0x7ffU) + 1];
        }
        if (LVar2 != 0x2f) goto LAB_080d1301;
      }
LAB_080d12af:
      mustshow = '\x01';
      text = (char *)gettext("Cancelling file.");
      statusline(text);
      LYCancelDownload = '\x01';
      if (local_13c != (HTStream *)0x0) {
        free(local_13c);
      }
      local_13c = (HTStream *)0x0;
      goto LAB_080d197d;
    }
LAB_080d1301:
    BVar3 = LYCachedTemp(fnam,&anchor->FileCache);
    if (BVar3 == '\0') {
      iVar6 = strcasecomp(pres->rep->name,"text/html");
      if (iVar6 == 0) {
        suffix = ".html";
      }
      else {
        iVar6 = strncasecomp(pres->rep->name,"text/",5);
        if (iVar6 == 0) {
          suffix = ".txt";
        }
        else {
          iVar6 = strncasecomp(pres->rep->name,"application/",0xc);
          if (iVar6 == 0) {
            suffix = ".bin";
          }
          else {
            suffix = HTFileSuffix(pres->rep,anchor->content_encoding);
            if ((suffix == (char *)0x0) || (*suffix != '.')) {
              suffix = ".html";
            }
          }
        }
      }
      pFVar5 = LYOpenTemp(fnam,suffix,"wb");
      *(FILE **)&local_13c[1].isa = pFVar5;
    }
    else {
      pFVar5 = LYOpenTempRewrite(fnam,".bin","wb");
      *(FILE **)&local_13c[1].isa = pFVar5;
    }
    if (local_13c[1].isa == (HTStreamClass *)0x0) {
      text = (char *)gettext("Can\'t open output file!  Cancelling!");
      HTAlert(text);
      if (local_13c != (HTStream *)0x0) {
        free(local_13c);
      }
      local_13c = (HTStream *)0x0;
      goto LAB_080d197d;
    }
    iVar6 = strncasecomp(pres->rep->name,"text/",5);
    if ((iVar6 != 0) && (iVar6 = strcasecomp(pres->rep->name,"application/postscript"), iVar6 != 0))
    {
      strcasecomp(pres->rep->name,"application/x-RUNOFF-MANUAL");
    }
    text = pres->rep->name;
    message = (char *)gettext("Content-type: %s");
    HTInfoMsg2(message,text);
    HTSACopy(&WWW_Download_File,fnam);
    local_13c[3].isa = (HTStreamClass *)0x0;
    HTAddParam((char **)(local_13c + 3),"%s",1,fnam);
    HTEndParam((char **)(local_13c + 3),"%s",1);
    HTSACopy((char **)(local_13c + 2),"SaveToFile");
    mustshow = '\x01';
    text = (char *)gettext("Retrieving file.  - PLEASE WAIT -");
    statusline(text);
    HTSACopy(&anchor->FileCache,fnam);
  }
  else {
    local_13c[1].isa = stdout;
    pHVar4 = HTAtom_for("www/download");
    if (pHVar4 != (HTAtom *)HTOutputFormat) goto LAB_080d197d;
  }
  if (((LYPrependBaseToSource != '\0') &&
      (iVar6 = strncasecomp(pres->rep->name,"text/html",9), iVar6 == 0)) &&
     (anchor->content_encoding == (char *)0x0)) {
    temp = (char *)0x0;
    if ((anchor->content_base == (char *)0x0) || (*anchor->content_base == '\0')) {
      if ((anchor->content_location != (char *)0x0) && (*anchor->content_location != '\0')) {
        HTSACopy(&temp,anchor->content_location);
      }
    }
    else {
      HTSACopy(&temp,anchor->content_base);
    }
    if (temp != (char *)0x0) {
      LYRemoveBlanks(temp);
      UVar7 = is_url(temp);
      if ((UVar7 == NOT_A_URL_TYPE) && (temp != (char *)0x0)) {
        free(temp);
        temp = (char *)0x0;
      }
    }
    fprintf((FILE *)local_13c[1].isa,"<!-- X-URL: %s -->\n",anchor->address);
    if (((((anchor->date != (char *)0x0) && (*anchor->date != '\0')) &&
         (fprintf((FILE *)local_13c[1].isa,"<!-- Date: %s -->\n",anchor->date),
         anchor->last_modified != (char *)0x0)) &&
        ((*anchor->last_modified != '\0' &&
         (iVar6 = strcmp(anchor->last_modified,anchor->date), iVar6 != 0)))) &&
       (iVar6 = strcmp(anchor->last_modified,"Thu, 01 Jan 1970 00:00:01 GMT"), iVar6 != 0)) {
      fprintf((FILE *)local_13c[1].isa,"<!-- Last-Modified: %s -->\n",anchor->last_modified);
    }
    if (temp == (char *)0x0) {
      local_138 = anchor->address;
    }
    else {
      local_138 = temp;
    }
    fprintf((FILE *)local_13c[1].isa,"<BASE HREF=\"%s\">\n\n",local_138);
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
  }
  if (((LYPrependCharsetToSource != '\0') &&
      (iVar6 = strncasecomp(pres->rep->name,"text/html",9), iVar6 == 0)) &&
     (anchor->content_encoding == (char *)0x0)) {
    temp = (char *)0x0;
    if ((anchor->charset != (char *)0x0) && (*anchor->charset != '\0')) {
      HTSACopy(&temp,anchor->charset);
      LYRemoveBlanks(temp);
      fprintf((FILE *)local_13c[1].isa,
              "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",temp);
    }
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
  }
LAB_080d197d:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_13c;
}



HTStream * HTCompressed(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  int iVar1;
  bool bVar2;
  HTAtom *rep;
  int iVar3;
  HTPresentation *pHVar4;
  int iVar5;
  HTAtom *pHVar6;
  CompressFileType CVar7;
  char *src;
  size_t sVar8;
  FILE *pFVar9;
  int in_GS_OFFSET;
  undefined *local_278;
  size_t local_274;
  HTStream *local_25c;
  char *program;
  char *middle;
  char *compress_suffix;
  char *uncompress_mask;
  char *suffix;
  int i;
  int n;
  HTPresentation *Pnow;
  HTPresentation *Pres;
  char *type;
  HTFormat format;
  HTStream *me;
  BOOLEAN can_present;
  char temp [256];
  char fnam [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  type = (char *)0x0;
  Pres = (HTPresentation *)0x0;
  bVar2 = false;
  uncompress_mask = (char *)0x0;
  compress_suffix = "";
  if (((anchor == (HTParentAnchor *)0x0) || (anchor->content_encoding == (char *)0x0)) ||
     (anchor->content_type == (char *)0x0)) {
    rep = HTAtom_for("application/octet-stream");
    local_25c = HTStreamStack((HTFormat)rep,(HTFormat)pres->rep_out,sink,anchor);
  }
  else {
    iVar3 = HTList_count(HTPresentations);
    i = 0;
    while (i < iVar3) {
      pHVar4 = (HTPresentation *)HTList_objectAt(HTPresentations,i);
      iVar5 = strcasecomp(pHVar4->rep->name,anchor->content_type);
      if (((iVar5 == 0) &&
          (rep = pHVar4->rep_out, pHVar6 = HTAtom_for("www/present"), rep == pHVar6)) &&
         ((Pres == (HTPresentation *)0x0 || (Pres->quality <= pHVar4->quality)))) {
        bVar2 = true;
        CVar7 = HTEncodingToCompressType(anchor->content_encoding);
        Pres = pHVar4;
        if (CVar7 == cftGzip) {
          src = HTGetProgramPath(ppGZIP);
          if (src != (char *)0x0) {
            HTSACopy(&uncompress_mask,src);
            HTSACat(&uncompress_mask," -d --no-name %s");
            compress_suffix = "gz";
          }
        }
        else {
          if (CVar7 < cftBzip2) {
            if ((CVar7 == cftCompress) && (src = HTGetProgramPath(ppUNCOMPRESS), src != (char *)0x0)
               ) {
              HTSACopy(&uncompress_mask,src);
              HTSACat(&uncompress_mask," %s");
              compress_suffix = "Z";
            }
          }
          else {
            if (CVar7 == cftBzip2) {
              src = HTGetProgramPath(ppBZIP2);
              if (src != (char *)0x0) {
                HTSACopy(&uncompress_mask,src);
                HTSACat(&uncompress_mask," -d %s");
                compress_suffix = "bz2";
              }
            }
            else {
              if ((CVar7 == cftDeflate) && (src = HTGetProgramPath(ppINFLATE), src != (char *)0x0))
              {
                HTSACopy(&uncompress_mask,src);
                HTSACat(&uncompress_mask," %s");
                compress_suffix = "zz";
              }
            }
          }
        }
      }
      i = i + 1;
    }
    if (((((bVar2) && (uncompress_mask != (char *)0x0)) &&
         (src = strchr(anchor->content_type,0x3b), src == (char *)0x0)) &&
        ((rep = HTAtom_for("www/download"), rep != (HTAtom *)HTOutputFormat &&
         (iVar3 = strcasecomp(pres->rep_out->name,"www/download"), iVar3 != 0)))) &&
       ((traversal == '\0' ||
        ((iVar3 = strcasecomp(anchor->content_type,"text/html"), iVar3 == 0 ||
         (iVar3 = strcasecomp(anchor->content_type,"text/plain"), iVar3 == 0)))))) {
      local_25c = (HTStream *)calloc(1,0x24);
      if (local_25c == (HTStream *)0x0) {
        outofmem("./HTFWriter.c","HTCompressed");
      }
      local_25c->isa = (HTStreamClass *)0x81670c4;
      local_25c[5].isa = (HTStreamClass *)pres->rep;
      local_25c[6].isa = (HTStreamClass *)pres->rep_out;
      *(HTParentAnchor **)&local_25c[7].isa = anchor;
      *(HTStream **)&local_25c[8].isa = sink;
      if ((anchor->FileCache != (char *)0x0) &&
         (LYRemoveTemp(anchor->FileCache), anchor->FileCache != (char *)0x0)) {
        free(anchor->FileCache);
        anchor->FileCache = (char *)0x0;
      }
      middle = (char *)0x0;
      iVar3 = strcasecomp(anchor->content_type,"text/html");
      if (iVar3 == 0) {
        middle = "html";
      }
      else {
        iVar3 = strncasecomp(anchor->content_type,"text/",5);
        if (iVar3 == 0) {
          middle = "txt";
        }
        else {
          iVar3 = strncasecomp(anchor->content_type,"application/",0xc);
          if (iVar3 == 0) {
            middle = "bin";
          }
          else {
            rep = HTAtom_for(anchor->content_type);
            src = HTFileSuffix(rep,(char *)0x0);
            if ((src != (char *)0x0) && (*src == '.')) {
              middle = src + 1;
            }
          }
        }
      }
      temp[0] = '\0';
      if (middle != (char *)0x0) {
        local_274 = 2;
        local_278 = &DAT_0816744b;
        sVar8 = strlen(temp);
        memcpy(temp + sVar8,local_278,local_274);
        strcat(temp,middle);
        strcat(temp,".");
      }
      strcat(temp,compress_suffix);
      pFVar9 = LYOpenTemp(fnam,temp,"wb");
      *(FILE **)&local_25c[1].isa = pFVar9;
      if (local_25c[1].isa == (HTStreamClass *)0x0) {
        src = (char *)gettext("Can\'t open temporary file!");
        HTAlert(src);
        if (uncompress_mask != (char *)0x0) {
          free(uncompress_mask);
          uncompress_mask = (char *)0x0;
        }
        if (local_25c != (HTStream *)0x0) {
          free(local_25c);
        }
        local_25c = (HTStream *)0x0;
      }
      else {
        if (((dump_output_immediately == '\0') && (traversal == '\0')) &&
           ((Pres->quality < 999.00000000 ||
            ((no_exec == '\0' &&
             ((local_exec != '\0' ||
              ((local_exec_on_local_files != '\0' &&
               ((LYJumpFileURL != '\0' ||
                (iVar3 = strncmp(anchor->address,"file://localhost",0x10), iVar3 == 0)))))))))))) {
          HTSACopy((char **)(local_25c + 4),Pres->command);
        }
        if ((*compress_suffix == 'g') && (local_25c[4].isa == (HTStreamClass *)0x0)) {
          HTSACopy((char **)(local_25c + 2),"");
        }
        else {
          local_25c[2].isa = (HTStreamClass *)0x0;
          HTAddParam((char **)(local_25c + 2),uncompress_mask,1,fnam);
          HTEndParam((char **)(local_25c + 2),uncompress_mask,1);
        }
        if (uncompress_mask != (char *)0x0) {
          free(uncompress_mask);
          uncompress_mask = (char *)0x0;
        }
        local_25c[3].isa = (HTStreamClass *)0x0;
        HTAddParam((char **)(local_25c + 3),"%s",1,fnam);
        HTEndParam((char **)(local_25c + 3),"%s",1);
        HTSACopy(&anchor->FileCache,fnam);
      }
    }
    else {
      src = strchr(anchor->content_encoding,0x2f);
      if (src == (char *)0x0) {
        iVar3 = strncasecomp(anchor->content_encoding,"x-",2);
        if (iVar3 == 0) {
          HTSACopy(&type,"application/");
        }
        else {
          HTSACopy(&type,"application/x-");
        }
        HTSACat(&type,anchor->content_encoding);
      }
      else {
        HTSACopy(&type,anchor->content_encoding);
      }
      rep = HTAtom_for(type);
      if (type != (char *)0x0) {
        free(type);
        type = (char *)0x0;
      }
      if (uncompress_mask != (char *)0x0) {
        free(uncompress_mask);
        uncompress_mask = (char *)0x0;
      }
      local_25c = HTStreamStack((HTFormat)rep,(HTFormat)pres->rep_out,sink,anchor);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_25c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



HTStream * HTDumpToStdout(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTStream *pHVar1;
  HTStream *ret_obj;
  
  pHVar1 = (HTStream *)calloc(1,0x24);
  if (pHVar1 == (HTStream *)0x0) {
    outofmem("./HTFWriter.c","HTDumpToStdout");
  }
  pHVar1->isa = (HTStreamClass *)0x81670c4;
  pHVar1[3].isa = (HTStreamClass *)0x0;
  pHVar1[2].isa = (HTStreamClass *)0x0;
  *(HTParentAnchor **)&pHVar1[7].isa = anchor;
  pHVar1[1].isa = stdout;
  return pHVar1;
}



void HTFormatInit(void)

{
  BOOLEAN BVar1;
  FILE *__stream;
  char *name;
  HTAtom *rep_out;
  HTAtom *rep_in;
  AcceptMedia media;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFormatInit\n");
  }
  name = LYgetXDisplay();
  if (name != (char *)0x0) {
    HTSetPresentation("application/postscript","ghostview %s&",(char *)0x0,1.00000000,3.00000000,
                      0.00000000,0,mediaEXT);
    if ((XLoadImageCommand != (char *)0x0) && (*XLoadImageCommand != '\0')) {
      HTSetPresentation("image/gif",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,0.00000000,0
                        ,mediaEXT);
      HTSetPresentation("image/x-xbm",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,0.00000000
                        ,0,mediaEXT);
      HTSetPresentation("image/x-xbitmap",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,
                        0.00000000,0,mediaEXT);
      HTSetPresentation("image/x-png",XLoadImageCommand,(char *)0x0,2.00000000,3.00000000,0.00000000
                        ,0,mediaEXT);
      HTSetPresentation("image/png",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,0.00000000,0
                        ,mediaEXT);
      HTSetPresentation("image/x-rgb",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,0.00000000
                        ,0,mediaEXT);
      HTSetPresentation("image/x-tiff",XLoadImageCommand,(char *)0x0,2.00000000,3.00000000,
                        0.00000000,0,mediaEXT);
      HTSetPresentation("image/tiff",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,0.00000000,
                        0,mediaEXT);
      HTSetPresentation("image/jpeg",XLoadImageCommand,(char *)0x0,1.00000000,3.00000000,0.00000000,
                        0,mediaEXT);
    }
    HTSetPresentation("video/mpeg","mpeg_play %s &",(char *)0x0,1.00000000,3.00000000,0.00000000,0,
                      mediaEXT);
  }
  HTSetPresentation("application/x-csh","csh %s",(char *)0x0,999.00000000,3.00000000,0.00000000,0,
                    mediaEXT);
  HTSetPresentation("application/x-sh","sh %s",(char *)0x0,999.00000000,3.00000000,0.00000000,0,
                    mediaEXT);
  HTSetPresentation("application/x-ksh","ksh %s",(char *)0x0,999.00000000,3.00000000,0.00000000,0,
                    mediaEXT);
  HTSetConversion("message/x-http-redirection","*",HTMIMERedirect,2.00000000,0.00000000,0.00000000,0
                  ,mediaOpt1);
  HTSetConversion("message/x-http-redirection","www/present",HTMIMERedirect,2.00000000,0.00000000,
                  0.00000000,0,mediaOpt1);
  HTSetConversion("message/x-http-redirection","www/debug",HTMIMERedirect,1.00000000,0.00000000,
                  0.00000000,0,mediaOpt1);
  HTSetConversion("www/mime","www/present",HTMIMEConvert,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("www/mime","www/download",HTMIMEConvert,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("www/mime","www/source",HTMIMEConvert,1.00000000,0.00000000,0.00000000,0,mediaOpt1
                 );
  HTSetConversion("www/mime","www/dump",HTMIMEConvert,1.00000000,0.00000000,0.00000000,0,mediaOpt1);
  HTSetConversion("www/compressed","www/download",HTCompressed,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("www/compressed","www/present",HTCompressed,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("www/compressed","www/source",HTCompressed,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("www/compressed","www/dump",HTCompressed,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("application/html","text/x-c",HTMLToC,0.50000000,0.00000000,0.00000000,0,mediaOpt1
                 );
  HTSetConversion("application/html","text/plain",HTMLToPlain,0.50000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/css","text/plain",HTMLToPlain,0.50000000,0.00000000,0.00000000,0,mediaOpt1);
  HTSetConversion("application/html","www/present",HTMLPresent,2.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("application/xhtml+xml","www/present",HTMLPresent,2.00000000,0.00000000,0.00000000
                  ,0,mediaOpt1);
  HTSetConversion("application/xml","www/present",HTMLPresent,2.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("application/html","www/source",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("application/x-wais-source","www/source",HTPlainPresent,1.00000000,0.00000000,
                  0.00000000,0,mediaOpt1);
  HTSetConversion("application/x-wais-source","www/present",HTWSRCConvert,2.00000000,0.00000000,
                  0.00000000,0,mediaOpt1);
  HTSetConversion("application/x-wais-source","www/download",HTWSRCConvert,1.00000000,0.00000000,
                  0.00000000,0,mediaOpt1);
  HTSetConversion("application/x-wais-source","www/dump",HTWSRCConvert,1.00000000,0.00000000,
                  0.00000000,0,mediaOpt1);
  HTSetConversion("www/source","www/present",HTSaveToFile,1.00000000,3.00000000,0.00000000,0,
                  mediaEXT);
  HTSetConversion("www/source","www/source",HTSaveToFile,1.00000000,3.00000000,0.00000000,0,mediaEXT
                 );
  HTSetConversion("www/source","www/download",HTSaveToFile,1.00000000,3.00000000,0.00000000,0,
                  mediaEXT);
  HTSetConversion("www/source","*",HTSaveToFile,1.00000000,3.00000000,0.00000000,0,mediaEXT);
  HTSetConversion("www/source","www/dump",HTDumpToStdout,1.00000000,3.00000000,0.00000000,0,mediaEXT
                 );
  HTSetConversion("text/x-sgml","www/source",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/x-sgml","www/present",HTMLPresent,2.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/sgml","www/source",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/sgml","www/present",HTMLPresent,1.00000000,0.00000000,0.00000000,0,mediaOpt1
                 );
  HTSetConversion("text/css","www/present",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/plain","www/present",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/plain","www/source",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/html","www/source",HTPlainPresent,1.00000000,0.00000000,0.00000000,0,
                  mediaOpt1);
  HTSetConversion("text/html","text/x-c",HTMLToC,0.50000000,0.00000000,0.00000000,0,mediaOpt1);
  HTSetConversion("text/html","text/plain",HTMLToPlain,0.50000000,0.00000000,0.00000000,0,mediaOpt1)
  ;
  HTSetConversion("text/html","www/present",HTMLPresent,1.00000000,0.00000000,0.00000000,0,mediaOpt1
                 );
  HTSetConversion("text/xml","www/present",HTMLPresent,2.00000000,0.00000000,0.00000000,0,mediaOpt1)
  ;
  BVar1 = LYisAbsPath(global_type_map);
  if (BVar1 != '\0') {
    HTLoadTypesConfigFile(global_type_map,mediaSYS);
  }
  name = LYAbsOrHomePath(&personal_type_map);
  BVar1 = IsOurFile(name);
  if (BVar1 != '\0') {
    BVar1 = LYCanReadFile(personal_type_map);
    if (BVar1 != '\0') {
      HTLoadTypesConfigFile(personal_type_map,mediaUSR);
    }
  }
  rep_out = HTAtom_for("www/present");
  rep_in = HTAtom_for("text/plain");
  HTReorderPresentation((HTFormat)rep_in,(HTFormat)rep_out);
  rep_out = HTAtom_for("www/present");
  rep_in = HTAtom_for("text/html");
  HTReorderPresentation((HTFormat)rep_in,(HTFormat)rep_out);
  HTFilterPresentations();
  return;
}



void HTPreparsedFormatInit(void)

{
  FILE *__stream;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTPreparsedFormatInit\n");
  }
  if (LYPreparsedSource != '\0') {
    HTSetConversion("text/html","www/source",HTMLParsedPresent,1.00000000,0.00000000,0.00000000,0,
                    mediaOpt1);
    HTSetConversion("text/html","www/dump",HTMLParsedPresent,1.00000000,0.00000000,0.00000000,0,
                    mediaOpt1);
  }
  return;
}



char * GetCommand(char *s,char **t)

{
  bool bVar1;
  size_t sVar2;
  char *txt;
  int quoted;
  char *s2;
  
  bVar1 = false;
  s = LYSkipBlanks(s);
  sVar2 = strlen(s);
  s2 = (char *)malloc(sVar2 * 2 + 1);
  if (s2 == (char *)0x0) {
    txt = (char *)gettext("Memory exhausted!  Program aborted!");
    ExitWithError(txt);
  }
  *t = s2;
  while ((s != (char *)0x0 && (*s != '\0'))) {
    if (bVar1) {
      if (*s == '%') {
        *s2 = '%';
        s2 = s2 + 1;
      }
      *s2 = *s;
      s2 = s2 + 1;
      s = s + 1;
      bVar1 = false;
    }
    else {
      if (*s == ';') {
        *s2 = '\0';
        return s + 1;
      }
      if (*s == '\\') {
        bVar1 = true;
        s = s + 1;
      }
      else {
        *s2 = *s;
        s2 = s2 + 1;
        s = s + 1;
      }
    }
  }
  *s2 = '\0';
  return (char *)0x0;
}



char * Cleanse(char *s)

{
  LYTrimLeading(s);
  LYTrimTrailing(s);
  LYLowerCase(s);
  return s;
}



void TrimCommand(char *command)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  int c0;
  int ch;
  char *d;
  char *s;
  BOOLEAN squote;
  BOOLEAN dquote;
  BOOLEAN escape;
  
  LYTrimTrailing(command);
  s = command;
  d = command;
  c0 = 0x20;
  bVar1 = false;
  bVar3 = false;
  bVar2 = false;
LAB_080d36f2:
  ch = (int)*s;
  s = s + 1;
  if (ch == 0) {
    *d = '\0';
    return;
  }
  if (bVar1) {
    bVar1 = false;
  }
  else {
    if (bVar2) {
      if (ch == 0x27) {
        bVar2 = false;
      }
    }
    else {
      if (bVar3) {
        if (ch == 0x22) {
          bVar3 = false;
        }
      }
      else {
        if (ch == 0x27) {
          bVar2 = true;
        }
        else {
          if (ch == 0x5c) {
            if (bVar3) {
              bVar1 = true;
            }
          }
          else {
            if (ch == 0x22) {
              bVar3 = true;
            }
          }
        }
      }
    }
  }
  if (((!bVar1) && (!bVar3)) && (!bVar2)) goto code_r0x080d36c5;
  goto LAB_080d36de;
code_r0x080d36c5:
  if (ch == 9) {
    ch = 0x20;
  }
  if ((ch != 0x20) || (c0 != 0x20)) {
LAB_080d36de:
    *d = (char)ch;
    d = d + 1;
    c0 = ch;
  }
  goto LAB_080d36f2;
}



int ProcessMailcapEntry(FILE *fp,MailcapEntry *mc,AcceptMedia media)

{
  size_t sVar1;
  size_t sVar2;
  uint uVar3;
  char *txt;
  char *pcVar4;
  FILE *__stream;
  int iVar5;
  long lVar6;
  double dVar7;
  int local_44;
  char *mallocd_string;
  char *eq;
  char *arg;
  char *LineBuf;
  char *t;
  char *s;
  char *rawentry;
  size_t need;
  size_t len;
  size_t rawentryalloc;
  
  rawentryalloc = 2000;
  LineBuf = (char *)0x0;
  rawentry = (char *)malloc(2000);
  if (rawentry == (char *)0x0) {
    txt = (char *)gettext("Memory exhausted!  Program aborted!");
    ExitWithError(txt);
  }
  *rawentry = '\0';
  do {
    do {
      txt = LYSafeGets(&LineBuf,fp);
      if (txt == (char *)0x0) {
LAB_080d385c:
        if (LineBuf != (char *)0x0) {
          free(LineBuf);
          LineBuf = (char *)0x0;
        }
        txt = LYSkipBlanks(rawentry);
        if (*txt == '\0') {
          if (rawentry != (char *)0x0) {
            free(rawentry);
          }
          local_44 = 0;
        }
        else {
          pcVar4 = strchr(rawentry,0x3b);
          if (pcVar4 == (char *)0x0) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
                      rawentry);
            }
            if (rawentry != (char *)0x0) {
              free(rawentry);
            }
            local_44 = 0;
          }
          else {
            *pcVar4 = '\0';
            iVar5 = strncasecomp(txt,"text/html",9);
            if ((iVar5 == 0) || (iVar5 = strncasecomp(txt,"text/plain",10), iVar5 == 0)) {
              *pcVar4 = ';';
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
                        rawentry);
              }
              if (rawentry != (char *)0x0) {
                free(rawentry);
              }
              local_44 = 0;
            }
            else {
              LYRemoveBlanks(rawentry);
              LYLowerCase(rawentry);
              mc->needsterminal = 0;
              mc->copiousoutput = 0;
              mc->needtofree = 1;
              mc->testcommand = (char *)0x0;
              mc->label = (char *)0x0;
              mc->printcommand = (char *)0x0;
              mc->contenttype = (char *)0x0;
              HTSACopy((char **)mc,rawentry);
              mc->quality = 1.00000000;
              mc->maxbytes = 0;
              txt = GetCommand(pcVar4 + 1,&mc->command);
              if (txt != (char *)0x0) {
                s = LYSkipBlanks(txt);
                while (s != (char *)0x0) {
                  s = GetCommand(s,&mallocd_string);
                  txt = mallocd_string;
                  eq = strchr(mallocd_string,0x3d);
                  if (eq != (char *)0x0) {
                    *eq = '\0';
                    eq = LYSkipBlanks(eq + 1);
                  }
                  if ((txt != (char *)0x0) && (*txt != '\0')) {
                    txt = Cleanse(txt);
                    iVar5 = strcmp(txt,"needsterminal");
                    if (iVar5 == 0) {
                      mc->needsterminal = 1;
                    }
                    else {
                      iVar5 = strcmp(txt,"copiousoutput");
                      if (iVar5 == 0) {
                        mc->copiousoutput = 1;
                      }
                      else {
                        if ((eq == (char *)0x0) || (iVar5 = strcmp(txt,"test"), iVar5 != 0)) {
                          if ((eq == (char *)0x0) || (iVar5 = strcmp(txt,"description"), iVar5 != 0)
                             ) {
                            if ((eq == (char *)0x0) || (iVar5 = strcmp(txt,"label"), iVar5 != 0)) {
                              if ((eq == (char *)0x0) || (iVar5 = strcmp(txt,"print"), iVar5 != 0))
                              {
                                if ((eq == (char *)0x0) ||
                                   (iVar5 = strcmp(txt,"textualnewlines"), iVar5 != 0)) {
                                  if ((eq == (char *)0x0) || (iVar5 = strcmp(txt,"q"), iVar5 != 0))
                                  {
                                    if ((eq == (char *)0x0) ||
                                       (iVar5 = strcmp(txt,"mxb"), iVar5 != 0)) {
                                      iVar5 = strcmp(txt,"notes");
                                      if ((((iVar5 != 0) && (*txt != '\0')) &&
                                          (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 8U) != 0)) {
                                        __stream = TraceFP();
                                        fprintf((FILE *)__stream,
                                                                                                
                                                "ProcessMailcapEntry: Ignoring mailcap flag \'%s\'.\n"
                                                ,txt);
                                      }
                                    }
                                    else {
                                      lVar6 = atol(eq);
                                      mc->maxbytes = lVar6;
                                      if (mc->maxbytes < 0) {
                                        mc->maxbytes = 0;
                                      }
                                    }
                                  }
                                  else {
                                    dVar7 = atof(eq);
                                    mc->quality = (float)dVar7;
                                    if ((0.00000000 < mc->quality) && (mc->quality < 0.00100000)) {
                                      mc->quality = 0.00100000;
                                    }
                                  }
                                }
                              }
                              else {
                                mc->printcommand = eq;
                              }
                            }
                            else {
                              mc->label = eq;
                            }
                          }
                          else {
                            mc->label = eq;
                          }
                        }
                        else {
                          mc->testcommand = (char *)0x0;
                          HTSACopy(&mc->testcommand,eq);
                          TrimCommand(mc->testcommand);
                          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                            txt = mc->testcommand;
                            __stream = TraceFP();
                            fprintf((FILE *)__stream,"ProcessMailcapEntry: Found testcommand:%s\n",
                                    txt);
                          }
                        }
                      }
                    }
                  }
                  if (mallocd_string != (char *)0x0) {
                    free(mallocd_string);
                    mallocd_string = (char *)0x0;
                  }
                }
              }
              if (rawentry != (char *)0x0) {
                free(rawentry);
              }
              iVar5 = PassesTest(mc);
              if (iVar5 != 0) {
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                  txt = mc->command;
                  pcVar4 = mc->contenttype;
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"ProcessMailcapEntry Setting up conversion %s : %s\n",
                          pcVar4,txt);
                }
                HTSetPresentation(mc->contenttype,mc->command,mc->testcommand,(double)mc->quality,
                                  3.00000000,0.00000000,mc->maxbytes,media);
              }
              if (mc->command != (char *)0x0) {
                free(mc->command);
                mc->command = (char *)0x0;
              }
              if (mc->testcommand != (char *)0x0) {
                free(mc->testcommand);
                mc->testcommand = (char *)0x0;
              }
              if (mc->contenttype != (char *)0x0) {
                free(mc->contenttype);
                mc->contenttype = (char *)0x0;
              }
              local_44 = 1;
            }
          }
        }
        return local_44;
      }
      LYTrimNewline(LineBuf);
    } while ((*LineBuf == '#') || (*LineBuf == '\0'));
    sVar1 = strlen(LineBuf);
    sVar2 = strlen(rawentry);
    uVar3 = sVar2 + sVar1 + 1;
    if (rawentryalloc < uVar3) {
      rawentryalloc = uVar3 + rawentryalloc + 2000;
      rawentry = (char *)realloc(rawentry,rawentryalloc);
      if (rawentry == (char *)0x0) {
        txt = (char *)gettext("Memory exhausted!  Program aborted!");
        ExitWithError(txt);
      }
    }
    if ((sVar1 == 0) || (LineBuf[sVar1 - 1] != '\\')) {
      strcat(rawentry,LineBuf);
      goto LAB_080d385c;
    }
    LineBuf[sVar1 - 1] = '\0';
    strcat(rawentry,LineBuf);
  } while( true );
}



char * LYSkipQuoted(char *s)

{
  bool bVar1;
  int escaped;
  
  bVar1 = false;
  s = s + 1;
  do {
    if (*s == '\0') {
      return s;
    }
    if (bVar1) {
      bVar1 = false;
    }
    else {
      if (*s == '\\') {
        bVar1 = true;
      }
      else {
        if (*s == '\"') {
          return s + 1;
        }
      }
    }
    s = s + 1;
  } while( true );
}



char * LYSkipToken(char *s)

{
  char "\"()<>@,;:\\/[]?.=" [17];
  char *pcVar1;
  
  while ((*s != '\0' && (0x20 < (byte)*s))) {
    pcVar1 = strchr("\"()<>@,;:\\/[]?.=",(int)*s);
    if (pcVar1 != (char *)0x0) {
      return s;
    }
    s = s + 1;
  }
  return s;
}



char * LYSkipValue(char *s)

{
  if (*s == '\"') {
    s = LYSkipQuoted(s);
  }
  else {
    s = LYSkipToken(s);
  }
  return s;
}



char * LYCopyValue(char *s)

{
  char *pcVar1;
  int k;
  int j;
  char *result;
  char *t;
  
  result = (char *)0x0;
  if (*s == '\"') {
    pcVar1 = LYSkipQuoted(s);
    HTSACopy(&result,s + 1);
    result[(int)(pcVar1 + (-2 - (int)s))] = '\0';
    k = 0;
    j = 0;
    while( true ) {
      if (result[j] == '\\') {
        j = j + 1;
      }
      result[k] = result[j];
      if (result[k] == '\0') break;
      j = j + 1;
      k = k + 1;
    }
  }
  else {
    pcVar1 = LYSkipToken(s);
    HTSACopy(&result,s);
    result[(int)(pcVar1 + -(int)s)] = '\0';
  }
  return result;
}



char * LYGetContentType(char *name,char *params)

{
  bool bVar1;
  char *s;
  char *buffer;
  int iVar2;
  char *__n;
  char *next;
  char *test;
  size_t length;
  char *result;
  BOOLEAN found;
  
  result = (char *)0x0;
  if (params != (char *)0x0) {
    if (name == (char *)0x0) {
      HTSACopy(&result,params);
      __n = LYSkipNonBlanks(result);
      *__n = '\0';
    }
    else {
      __n = (char *)strlen(name);
      test = strchr(params,0x3b);
      do {
        if (test == (char *)0x0) {
          return result;
        }
        bVar1 = false;
        s = LYSkipCBlanks(test + 1);
        buffer = LYSkipToken(s);
        if ((buffer + -(int)s == __n) && (iVar2 = strncmp(s,name,(size_t)__n), iVar2 == 0)) {
          bVar1 = true;
        }
        test = LYSkipCBlanks(buffer);
        if (*test == '=') {
          s = LYSkipCBlanks(test + 1);
          if (bVar1) {
            __n = LYCopyValue(s);
            return __n;
          }
          s = LYSkipValue(s);
          test = LYSkipCBlanks(s);
        }
      } while (*test == ';');
    }
  }
  return result;
}



BOOLEAN LYMailcapUsesPctS(char *controlstring)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  char *pcVar4;
  int escaped;
  int prefixed;
  char *next;
  char *from;
  int result;
  
  result = 0;
  bVar3 = false;
  bVar2 = false;
  from = controlstring;
  while (*from != '\0') {
    if (bVar2) {
      bVar2 = false;
    }
    else {
      if (*from == '\\') {
        bVar2 = true;
      }
      else {
        if (bVar3) {
          bVar3 = false;
          cVar1 = *from;
          if (((cVar1 != 'n') && ('n' < cVar1)) && (cVar1 != 't')) {
            if (cVar1 == '{') {
              pcVar4 = strchr(from,0x7d);
              if (pcVar4 != (char *)0x0) {
                from = pcVar4;
              }
            }
            else {
              if (cVar1 == 's') {
                result = 1;
              }
            }
          }
        }
        else {
          if (*from == '%') {
            bVar3 = true;
          }
        }
      }
    }
    from = from + 1;
  }
  return (BOOLEAN)result;
}



int BuildCommand(HTChunk *cmd,char *controlstring,char *TmpFileName,char *params)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  size_t sVar4;
  char *s;
  char *s_00;
  int iVar5;
  FILE *__stream;
  int escaped;
  int prefixed;
  char *value;
  char *name;
  char *next;
  char *from;
  size_t TmpFileLen;
  int result;
  
  result = 0;
  sVar4 = strlen(TmpFileName);
  bVar3 = false;
  bVar2 = false;
  from = controlstring;
  do {
    if (*from == '\0') {
      HTChunkTerminate(cmd);
      return result;
    }
    if (bVar2) {
      bVar2 = false;
      HTChunkPutc(cmd,*from);
    }
    else {
      if (*from == '\\') {
        bVar2 = true;
      }
      else {
        if (bVar3) {
          bVar3 = false;
          cVar1 = *from;
          if (cVar1 == 'n') {
LAB_080d4396:
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"BuildCommand: Bad mailcap \"test\" clause: %s\n",
                      controlstring);
            }
          }
          else {
            if (cVar1 < 'o') {
              if (cVar1 != '%') {
                if (cVar1 != 'F') goto LAB_080d4583;
                goto LAB_080d4396;
              }
              HTChunkPutc(cmd,*from);
            }
            else {
              if (cVar1 == 't') {
                s = LYGetContentType((char *)0x0,params);
                if ((s != (char *)0x0) && (HTChunkPuts(cmd,s), s != (char *)0x0)) {
                  free(s);
                }
              }
              else {
                if (cVar1 == '{') {
                  s = strchr(from,0x7d);
                  if (s == (char *)0x0) goto LAB_080d4583;
                  if (params == (char *)0x0) {
                    result = -1;
                    from = s;
                  }
                  else {
                    name = (char *)0x0;
                    HTSprintf0(&name,"%.*s",s + -(int)(from + 1),from + 1);
                    s_00 = LYGetContentType(name,params);
                    if (s_00 == (char *)0x0) {
                      iVar5 = strcmp(name,"charset");
                      s_00 = name;
                      if (iVar5 == 0) {
                        HTChunkPuts(cmd,"ISO-8859-1");
                      }
                      else {
                        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                          __stream = TraceFP();
                          fprintf((FILE *)__stream,"BuildCommand no value for %s\n",s_00);
                        }
                      }
                    }
                    else {
                      HTChunkPuts(cmd,s_00);
                      if (s_00 != (char *)0x0) {
                        free(s_00);
                      }
                    }
                    from = s;
                    if (name != (char *)0x0) {
                      free(name);
                      name = (char *)0x0;
                    }
                  }
                }
                else {
                  if (cVar1 == 's') {
                    if ((sVar4 != 0) && (TmpFileName != (char *)0x0)) {
                      HTChunkPuts(cmd,TmpFileName);
                    }
                  }
                  else {
LAB_080d4583:
                    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                      cVar1 = *from;
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,
                                                            
                              "BuildCommand: Ignoring unrecognized format code in mailcap file \'%%%c\'.\n"
                              ,(int)cVar1);
                    }
                  }
                }
              }
            }
          }
        }
        else {
          if (*from == '%') {
            bVar3 = true;
          }
          else {
            HTChunkPutc(cmd,*from);
          }
        }
      }
    }
    from = from + 1;
  } while( true );
}



int LYTestMailcapCommand(char *testcommand,char *params)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  HTChunk *cmd;
  int iVar3;
  int in_GS_OFFSET;
  char *local_134;
  HTChunk *expanded;
  int result;
  char TmpFileName [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  BVar2 = LYMailcapUsesPctS(testcommand);
  if (BVar2 == '\0') {
    TmpFileName[0] = '\0';
  }
  else {
    __stream = LYOpenTemp(TmpFileName,".html","w");
    if (__stream == (FILE *)0x0) {
      local_134 = (char *)gettext("Can\'t open temporary file!");
      ExitWithError(local_134);
    }
    LYCloseTemp(TmpFileName);
  }
  cmd = HTChunkCreate(0x400);
  local_134 = TmpFileName;
  iVar3 = BuildCommand(cmd,testcommand,local_134,params);
  if (iVar3 == 0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      local_134 = cmd->data;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"PassesTest: Executing test command: %s\n",local_134);
    }
    result = LYSystem(cmd->data);
    if (result == 0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PassesTest: Test passed!\n",local_134);
      }
    }
    else {
      result = -1;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PassesTest: Test failed!\n",local_134);
      }
    }
  }
  else {
    result = 1;
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      local_134 = cmd->data;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"PassesTest: Deferring test command: %s\n",local_134);
    }
  }
  HTChunkFree(cmd);
  LYRemoveTemp(TmpFileName);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



char * LYMakeMailcapCommand(char *command,char *params,char *filename)

{
  HTChunk *cmd;
  char *result;
  HTChunk *expanded;
  
  result = (char *)0x0;
  cmd = HTChunkCreate(0x400);
  BuildCommand(cmd,command,filename,params);
  HTSACopy(&result,cmd->data);
  HTChunkFree(cmd);
  return result;
}



int RememberTestResult(int mode,char *cmd,int result)

{
  cmdlist_s *pcVar1;
  cmdlist_s *cmdlist;
  int iVar2;
  char **dest;
  int local_18;
  cmdlist_s *cur;
  
  if (mode == 1) {
    cur = cmdlist;
    while (cur != (cmdlist_s *)0x0) {
      iVar2 = strcmp(cmd,cur->cmd);
      if (iVar2 == 0) {
        return cur->result;
      }
      cur = cur->next;
    }
    local_18 = -1;
  }
  else {
    if (mode == 2) {
      dest = (char **)calloc(1,0xc);
      if (dest == (char **)0x0) {
        outofmem("./HTInit.c","RememberTestResult");
      }
      *(cmdlist_s **)(dest + 2) = cmdlist;
      HTSACopy(dest,cmd);
      *(int *)(dest + 1) = result;
    }
    else {
      pcVar1 = cmdlist;
      if (mode == 0) {
        while (cmdlist = pcVar1, cmdlist != (cmdlist_s *)0x0) {
          pcVar1 = cmdlist->next;
          if (cmdlist->cmd != (char *)0x0) {
            free(cmdlist->cmd);
            cmdlist->cmd = (char *)0x0;
          }
          if (cmdlist != (cmdlist_s *)0x0) {
            free(cmdlist);
          }
        }
      }
    }
    local_18 = 0;
  }
  return local_18;
}



int PassesTest(MailcapEntry *mc)

{
  int iVar1;
  FILE *__stream;
  char *pcVar2;
  int local_18;
  int result;
  
  if (mc->testcommand == (char *)0x0) {
    local_18 = 1;
  }
  else {
    iVar1 = strcmp(mc->testcommand,"test \"$DISPLAY\"");
    if (((iVar1 != 0) && (iVar1 = strcmp(mc->testcommand,"test \"$DISPLAY\" != \"\""), iVar1 != 0))
       && (iVar1 = strcmp(mc->testcommand,"test -n \"$DISPLAY\""), iVar1 != 0)) {
      iVar1 = strcmp(mc->testcommand,"test -z \"$DISPLAY\"");
      if (iVar1 == 0) {
        if (mc->testcommand != (char *)0x0) {
          free(mc->testcommand);
          mc->testcommand = (char *)0x0;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Testing for NON_XWINDOWS environment.\n");
        }
        pcVar2 = LYgetXDisplay();
        if (pcVar2 == (char *)0x0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"PassesTest: Test passed!\n");
          }
          return 1;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Test failed!\n");
        }
        return 0;
      }
      iVar1 = strcmp(mc->testcommand,"test -n \"$LYNX_VERSION\"");
      if (iVar1 == 0) {
        if (mc->testcommand != (char *)0x0) {
          free(mc->testcommand);
          mc->testcommand = (char *)0x0;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Testing for LYNX environment.\n");
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Test passed!\n");
        }
        return 1;
      }
      iVar1 = strcmp(mc->testcommand,"test -z \"$LYNX_VERSION\"");
      if (iVar1 == 0) {
        if (mc->testcommand != (char *)0x0) {
          free(mc->testcommand);
          mc->testcommand = (char *)0x0;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Testing for non-LYNX environment.\n");
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Test failed!\n");
        }
        return 0;
      }
      result = RememberTestResult(1,mc->testcommand,0);
      if (result == -1) {
        result = LYTestMailcapCommand(mc->testcommand,(char *)0x0);
        RememberTestResult(2,mc->testcommand,(uint)(result != 0));
      }
      if ((result != 1) && (mc->testcommand != (char *)0x0)) {
        free(mc->testcommand);
        mc->testcommand = (char *)0x0;
      }
      if (result < 0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Test failed!\n");
        }
      }
      else {
        if (((result == 0) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"PassesTest: Test passed!\n");
        }
      }
      return (uint)~result >> 0x1f;
    }
    if (mc->testcommand != (char *)0x0) {
      free(mc->testcommand);
      mc->testcommand = (char *)0x0;
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"PassesTest: Testing for XWINDOWS environment.\n");
    }
    pcVar2 = LYgetXDisplay();
    if (pcVar2 == (char *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PassesTest: Test failed!\n");
      }
      local_18 = 0;
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PassesTest: Test passed!\n");
      }
      local_18 = 1;
    }
  }
  return local_18;
}



int ProcessMailcapFile(char *file,AcceptMedia media)

{
  FILE *fp_00;
  int iVar1;
  int local_38;
  MailcapEntry mc;
  FILE *fp;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    fp_00 = TraceFP();
    fprintf((FILE *)fp_00,"ProcessMailcapFile: Loading file \'%s\'.\n",file);
  }
  fp_00 = (FILE *)fopen64(file,"r");
  if (fp_00 == (FILE *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"ProcessMailcapFile: Could not open \'%s\'.\n",file);
    }
    local_38 = 0;
  }
  else {
    while (fp_00 != (FILE *)0x0) {
      iVar1 = feof((FILE *)fp_00);
      if (iVar1 != 0) break;
      ProcessMailcapEntry(fp_00,&mc,media);
    }
    LYCloseInput(fp_00);
    RememberTestResult(0,(char *)0x0,0);
    local_38 = 1;
  }
  return local_38;
}



int ExitWithError(char *txt)

{
  FILE *__stream;
  
  if (txt != (char *)0x0) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Lynx: %s\n",txt);
  }
  exit_immediately(1);
  return -1;
}



int HTLoadTypesConfigFile(char *fn,AcceptMedia media)

{
  HTList *tail;
  HTList *pHVar1;
  int iVar2;
  HTList *saved;
  int result;
  
  tail = HTPresentations;
  if (reverse_mailcap != 0) {
    HTPresentations = (HTList *)0x0;
  }
  iVar2 = ProcessMailcapFile(fn,media);
  pHVar1 = HTPresentations;
  if (((reverse_mailcap != 0) && (pHVar1 = tail, iVar2 != 0)) && (HTPresentations != (HTList *)0x0))
  {
    HTList_reverse(HTPresentations);
    HTList_appendList(HTPresentations,tail);
    pHVar1 = HTPresentations;
    if (tail != (HTList *)0x0) {
      free(tail);
      pHVar1 = HTPresentations;
    }
  }
  HTPresentations = pHVar1;
  return iVar2;
}



void HTFileInit(void)

{
  BOOLEAN BVar1;
  FILE *__stream;
  char *name;
  
  if (LYUseBuiltinSuffixes == '\0') {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFileInit: Skipping all default (HTInit) extension maps!\n");
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFileInit: Loading default (HTInit) extension maps.\n");
    }
    HTSetSuffix5("*","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5("*.*","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".csh","application/x-csh","8bit",(char *)0x0,0.80000000);
    HTSetSuffix5(".sh","application/x-sh","8bit",(char *)0x0,0.80000000);
    HTSetSuffix5(".ksh","application/x-ksh","8bit",(char *)0x0,0.80000000);
    HTSetSuffix5(".saveme","application/x-Binary","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".dump","application/x-Binary","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".bin","application/x-Binary","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".arc","application/x-Compressed","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".alpha-exe","application/x-Executable","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".alpha_exe","application/x-Executable","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".AXP-exe","application/x-Executable","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".AXP_exe","application/x-Executable","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".VAX-exe","application/x-Executable","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".VAX_exe","application/x-Executable","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".exe","application/octet-stream","binary","Executable",1.00000000);
    HTSetSuffix5(".Z","application/x-compress","binary","UNIX Compressed",1.00000000);
    HTSetSuffix5(".Z",(char *)0x0,"compress","UNIX Compressed",1.00000000);
    HTSetSuffix5(".exe.Z","application/octet-stream","compress","Executable",1.00000000);
    HTSetSuffix5(".tar_Z","application/x-tar","compress","UNIX Compr. Tar",1.00000000);
    HTSetSuffix5(".tar.Z","application/x-tar","compress","UNIX Compr. Tar",1.00000000);
    HTSetSuffix5("-gz","application/x-gzip","binary","GNU Compressed",1.00000000);
    HTSetSuffix5("_gz","application/x-gzip","binary","GNU Compressed",1.00000000);
    HTSetSuffix5(".gz","application/x-gzip","binary","GNU Compressed",1.00000000);
    HTSetSuffix5("-gz",(char *)0x0,"gzip","GNU Compressed",1.00000000);
    HTSetSuffix5("_gz",(char *)0x0,"gzip","GNU Compressed",1.00000000);
    HTSetSuffix5(".gz",(char *)0x0,"gzip","GNU Compressed",1.00000000);
    HTSetSuffix5(".tar.gz","application/x-tar","gzip","GNU Compr. Tar",1.00000000);
    HTSetSuffix5(".tgz","application/x-tar","gzip","GNU Compr. Tar",1.00000000);
    HTSetSuffix5(".wsrc","application/x-wais-source","8bit","WAIS-source",1.00000000);
    HTSetSuffix5(".zip","application/zip","binary","Zip File",1.00000000);
    HTSetSuffix5(".zz","application/x-deflate","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".zz","application/deflate","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".bz2","application/x-bzip2","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".bz2","application/bzip2","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".uu","application/x-uuencoded","7bit","UUencoded",1.00000000);
    HTSetSuffix5(".hqx","application/mac-binhex40","8bit","Mac BinHex",1.00000000);
    HTSetSuffix5(".o","application/octet-stream","binary","Prog. Object",0.50000000);
    HTSetSuffix5(".a","application/octet-stream","binary","Prog. Library",0.50000000);
    HTSetSuffix5(".so","application/octet-stream","binary","Shared Lib",0.50000000);
    HTSetSuffix5(".oda","application/oda","binary","ODA",1.00000000);
    HTSetSuffix5(".pdf","application/pdf","binary","PDF",1.00000000);
    HTSetSuffix5(".eps","application/postscript","8bit","Postscript",1.00000000);
    HTSetSuffix5(".ai","application/postscript","8bit","Postscript",1.00000000);
    HTSetSuffix5(".ps","application/postscript","8bit","Postscript",1.00000000);
    HTSetSuffix5(".rtf","application/rtf","8bit","RTF",1.00000000);
    HTSetSuffix5(".dvi","application/x-dvi","8bit","DVI",1.00000000);
    HTSetSuffix5(".hdf","application/x-hdf","8bit","HDF",1.00000000);
    HTSetSuffix5(".cdf","application/x-netcdf","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".nc","application/x-netcdf","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".latex","application/x-latex","8bit","LaTeX",1.00000000);
    HTSetSuffix5(".tex","text/x-tex","8bit","TeX",1.00000000);
    HTSetSuffix5(".texinfo","application/x-texinfo","8bit","Texinfo",1.00000000);
    HTSetSuffix5(".texi","application/x-texinfo","8bit","Texinfo",1.00000000);
    HTSetSuffix5(".t","application/x-troff","8bit","Troff",1.00000000);
    HTSetSuffix5(".tr","application/x-troff","8bit","Troff",1.00000000);
    HTSetSuffix5(".roff","application/x-troff","8bit","Troff",1.00000000);
    HTSetSuffix5(".man","application/x-troff-man","8bit","Man Page",1.00000000);
    HTSetSuffix5(".me","application/x-troff-me","8bit","Troff me",1.00000000);
    HTSetSuffix5(".ms","application/x-troff-ms","8bit","Troff ms",1.00000000);
    HTSetSuffix5(".zoo","application/x-Zoo File","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".bak",(char *)0x0,"binary","Backup",0.50000000);
    HTSetSuffix5(".bkp","application/octet-stream","binary","VMS BAK File",1.00000000);
    HTSetSuffix5(".bck","application/octet-stream","binary","VMS BAK File",1.00000000);
    HTSetSuffix5(".hlb","application/octet-stream","binary","VMS Help Libr.",1.00000000);
    HTSetSuffix5(".olb","application/octet-stream","binary","VMS Obj. Libr.",1.00000000);
    HTSetSuffix5(".tlb","application/octet-stream","binary","VMS Text Libr.",1.00000000);
    HTSetSuffix5(".obj","application/octet-stream","binary","Prog. Object",1.00000000);
    HTSetSuffix5(".decw$book","application/octet-stream","binary","DEC BookReader",1.00000000);
    HTSetSuffix5(".mem","text/x-runoff-manual","8bit","RUNOFF-MANUAL",1.00000000);
    HTSetSuffix5(".vsd","application/visio","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".lha","application/x-lha","binary","lha File",1.00000000);
    HTSetSuffix5(".lzh","application/x-lzh","binary","lzh File",1.00000000);
    HTSetSuffix5(".sea","application/x-sea","binary","sea File",1.00000000);
    HTSetSuffix5(".sit","application/x-stuffit","binary","StuffIt",1.00000000);
    HTSetSuffix5(".dms","application/x-dms","binary","dms File",1.00000000);
    HTSetSuffix5(".iff","application/x-iff","binary","iff File",1.00000000);
    HTSetSuffix5(".bcpio","application/x-bcpio","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".cpio","application/x-cpio","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".shar","application/x-shar","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".share","application/x-share","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".sv4cpio","application/x-sv4cpio","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".sv4crc","application/x-sv4crc","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".tar","application/x-tar","binary","Tar File",1.00000000);
    HTSetSuffix5(".ustar","application/x-ustar","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".snd","audio/basic","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".au","audio/basic","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".aifc","audio/x-aiff","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".aif","audio/x-aiff","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".aiff","audio/x-aiff","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".wav","audio/x-wav","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".midi","audio/midi","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".mod","audio/mod","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".gif","image/gif","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".ief","image/ief","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".jfif","image/jpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".jfif-tbnl","image/jpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".jpe","image/jpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".jpg","image/jpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".jpeg","image/jpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".tif","image/tiff","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".tiff","image/tiff","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".ham","image/ham","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".ras","image/x-cmu-rast","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".pnm","image/x-portable-anymap","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".pbm","image/x-portable-bitmap","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".pgm","image/x-portable-graymap","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".ppm","image/x-portable-pixmap","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".png","image/png","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".rgb","image/x-rgb","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".xbm","image/x-xbitmap","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".xpm","image/x-xpixmap","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".xwd","image/x-xwindowdump","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".rtx","text/richtext","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".tsv","text/tab-separated-values","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".etx","text/x-setext","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".mpg","video/mpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".mpe","video/mpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".mpeg","video/mpeg","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".mov","video/quicktime","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".qt","video/quicktime","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".avi","video/x-msvideo","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".movie","video/x-sgi-movie","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".mv","video/x-sgi-movie","binary",(char *)0x0,1.00000000);
    HTSetSuffix5(".mime","message/rfc822","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".c","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".cc","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".c++","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".css","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".h","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".pl","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".text","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".txt","text/plain","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".php","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".php3","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".html3","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".ht3","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".phtml","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".shtml","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".sht","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".htmlx","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".htm","text/html","8bit",(char *)0x0,1.00000000);
    HTSetSuffix5(".html","text/html","8bit",(char *)0x0,1.00000000);
  }
  BVar1 = LYisAbsPath(global_extension_map);
  if (BVar1 != '\0') {
    HTLoadExtensionsConfigFile(global_extension_map);
  }
  name = LYAbsOrHomePath(&personal_extension_map);
  BVar1 = IsOurFile(name);
  if (BVar1 != '\0') {
    BVar1 = LYCanReadFile(personal_extension_map);
    if (BVar1 != '\0') {
      HTLoadExtensionsConfigFile(personal_extension_map);
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

int HTGetLine(char *s,int n,FILE *f)

{
  int iVar1;
  uint local_10;
  int local_c;
  int local_8;
  
  local_c = 0;
  if (f == (FILE *)0x0) {
    local_10 = 1;
  }
  else {
    while( true ) {
      local_8 = fgetc((FILE *)f);
      s[local_c] = (char)local_8;
      if (s[local_c] == '\r') {
        local_8 = fgetc((FILE *)f);
        if (local_8 == 10) {
          s[local_c] = '\n';
        }
        else {
          if (local_8 != -1) {
            ungetc(local_8,(FILE *)f);
          }
        }
      }
      if ((((local_8 == -1) || (s[local_c] == '\n')) || (s[local_c] == '\r')) || (n + -1 == local_c)
         ) break;
      local_c = local_c + 1;
    }
    s[local_c] = '\0';
    iVar1 = feof((FILE *)f);
    local_10 = (uint)(iVar1 != 0);
  }
  return local_10;
}



void HTGetWord(char *word,char *line,char stop,char stop2)

{
  char *pcVar1;
  int y;
  int x;
  
  x = 0;
  while (((line[x] != '\0' && (line[x] != stop)) && (line[x] != stop2))) {
    word[x] = line[x];
    x = x + 1;
  }
  word[x] = '\0';
  if (line[x] != '\0') {
    x = x + 1;
  }
  y = 0;
  do {
    pcVar1 = line + y;
    *pcVar1 = line[x];
    y = y + 1;
    x = x + 1;
  } while (*pcVar1 != '\0');
  return;
}



int HTLoadExtensionsConfigFile(char *fn)

{
  int iVar1;
  char *pcVar2;
  FILE *f_00;
  FILE *__stream;
  char *pcVar3;
  int iVar4;
  int in_GS_OFFSET;
  char *ext;
  int count;
  FILE *f;
  char *ct;
  char word [256];
  char line [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  count = 0;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    f_00 = TraceFP();
    fprintf((FILE *)f_00,"HTLoadExtensionsConfigFile: Loading file \'%s\'.\n",fn);
  }
  f_00 = (FILE *)fopen64(fn,"r");
  if (f_00 == (FILE *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      f_00 = TraceFP();
      fprintf((FILE *)f_00,"HTLoadExtensionsConfigFile: Could not open \'%s\'.\n",fn);
    }
  }
  else {
    while (iVar4 = HTGetLine(line,0x100,f_00), iVar4 == 0) {
      HTGetWord(word,line,' ','\t');
      if ((line[0] != '\0') && (word[0] != '#')) {
        ct = (char *)0x0;
        HTSACopy(&ct,word);
        LYLowerCase(ct);
        while (line[0] != '\0') {
          HTGetWord(word,line,' ','\t');
          if ((word[0] != '\0') && (word[0] != ' ')) {
            ext = (char *)0x0;
            HTSprintf0(&ext,".%s",word);
            LYLowerCase(ext);
            pcVar2 = ct;
            pcVar3 = ext;
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"setting suffix \'%s\' to \'%s\'.\n",pcVar3,pcVar2);
            }
            pcVar3 = strstr(ct,"tex");
            if ((((pcVar3 == (char *)0x0) &&
                 (pcVar3 = strstr(ct,"postscript"), pcVar3 == (char *)0x0)) &&
                (pcVar3 = strstr(ct,"sh"), pcVar3 == (char *)0x0)) &&
               ((pcVar3 = strstr(ct,"troff"), pcVar3 == (char *)0x0 &&
                (pcVar3 = strstr(ct,"rtf"), pcVar3 == (char *)0x0)))) {
              HTSetSuffix5(ext,ct,"binary",(char *)0x0,1.00000000);
            }
            else {
              HTSetSuffix5(ext,ct,"8bit",(char *)0x0,1.00000000);
            }
            count = count + 1;
            if (ext != (char *)0x0) {
              free(ext);
              ext = (char *)0x0;
            }
          }
        }
        if (ct != (char *)0x0) {
          free(ct);
          ct = (char *)0x0;
        }
      }
    }
    LYCloseInput(f_00);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return count;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



HTStyleSheet * DefaultStyle(HTStyle ***result_array)

{
  _HTStyle *p_Var1;
  HTStyleSheet *pHVar2;
  HTStyle *pHVar3;
  int iVar4;
  HTStyle *pHVar5;
  HTStyle *pHVar6;
  byte bVar7;
  HTStyle *r;
  HTStyle *q;
  HTStyle *p;
  
  bVar7 = 0;
  if (result == (HTStyleSheet *)0x0) {
    pHVar2 = HTStyleSheetNew();
    pHVar5 = sheet.styles;
    result = pHVar2;
    pHVar2->name = sheet.name;
    pHVar2->styles = pHVar5;
    result->styles = (HTStyle *)0x0;
    p = sheet.styles;
    while (p != (HTStyle *)0x0) {
      pHVar3 = HTStyleNew();
      iVar4 = 0x14;
      pHVar5 = p;
      pHVar6 = pHVar3;
      while (iVar4 != 0) {
        iVar4 = iVar4 + -1;
        pHVar6->next = pHVar5->next;
        pHVar5 = (HTStyle *)((int)pHVar5 + (uint)bVar7 * -8 + 4);
        pHVar6 = (HTStyle *)((int)pHVar6 + (uint)bVar7 * -8 + 4);
      }
      if (no_margins != '\0') {
        pHVar3->indent1st = 0;
        pHVar3->leftIndent = 0;
        pHVar3->rightIndent = 0;
      }
      st_array[pHVar3->id] = pHVar3;
      *(HTStyle **)&pHVar3->next = result->styles;
      result->styles = pHVar3;
      p = (HTStyle *)p->next;
    }
  }
  else {
    q = result->styles;
    p = sheet.styles;
    while ((p != (HTStyle *)0x0 && (q != (HTStyle *)0x0))) {
      p_Var1 = q->next;
      iVar4 = 0x14;
      pHVar5 = p;
      pHVar6 = q;
      while (iVar4 != 0) {
        iVar4 = iVar4 + -1;
        pHVar6->next = pHVar5->next;
        pHVar5 = (HTStyle *)&pHVar5->name;
        pHVar6 = (HTStyle *)&pHVar6->name;
      }
      if (no_margins != '\0') {
        q->indent1st = 0;
        q->leftIndent = 0;
        q->rightIndent = 0;
      }
      st_array[q->id] = q;
      q->next = p_Var1;
      p = (HTStyle *)p->next;
      q = (HTStyle *)q->next;
    }
  }
  *result_array = st_array;
  return result;
}



int LYUpload(char *line)

{
  int iVar1;
  BOOLEAN BVar2;
  char *Msg;
  char *text;
  int iVar3;
  FILE *__stream;
  int in_GS_OFFSET;
  int local_140;
  char *the_command;
  lynx_list_item_type *upload_command;
  char *filename;
  char *the_upload;
  int count;
  int method_number;
  char *directory;
  char *method;
  char tmpbuf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  the_upload = (char *)0x0;
  filename = (char *)0x0;
  the_command = (char *)0x0;
  Msg = strstr(line,"TO=");
  if (Msg != (char *)0x0) {
    Msg[-1] = '\0';
    text = strstr(line,"UPLOAD=");
    if (text != (char *)0x0) {
      iVar3 = atoi(text + 7);
      count = 0;
      upload_command = uploaders;
      while (count < iVar3) {
        count = count + 1;
        upload_command = (lynx_list_item_type *)upload_command->next;
      }
      if (upload_command->command != (char *)0x0) {
        iVar3 = HTCountCommandArgs(upload_command->command);
        if (iVar3 == 0) {
          HTSACopy(&the_upload,upload_command->command);
        }
        else {
          mustshow = '\x01';
          text = (char *)gettext("Enter a filename: ");
          statusline(text);
retry:
          do {
            do {
              tmpbuf[0] = '\0';
              iVar3 = LYgetstr(tmpbuf,0,0x100,NORECALL);
              if ((iVar3 < 0) || (tmpbuf[0] == '\0')) {
cancelled:
                Msg = (char *)gettext("Cancelling!");
                HTInfoMsg(Msg);
                local_140 = 0;
                goto LAB_080d7436;
              }
              text = strstr(tmpbuf,"../");
              if (text != (char *)0x0) {
                Msg = (char *)gettext("Illegal redirection \"../\" found! Request ignored.");
                HTAlert(Msg);
                goto cancelled;
              }
              text = strchr(tmpbuf,0x2f);
              if (text != (char *)0x0) {
                Msg = (char *)gettext("Illegal character \"/\" found! Request ignored.");
                HTAlert(Msg);
                goto cancelled;
              }
              if (tmpbuf[0] == '~') {
                Msg = (char *)gettext("Illegal redirection using \"~\" found! Request ignored.");
                HTAlert(Msg);
                goto cancelled;
              }
              HTSprintf0(&filename,"%s/%s",Msg + 3,tmpbuf);
              if (*filename == '|') {
                text = (char *)gettext("Cannot write to file.");
                HTAlert(text);
                mustshow = '\x01';
                text = (char *)gettext("Enter a new filename: ");
                statusline(text);
                goto retry;
              }
              iVar3 = LYValidateOutput(filename);
              text = filename;
            } while (iVar3 == 0x4e);
            if (iVar3 != 0x59) goto cancelled;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYUpload: filename is %s",text);
            }
            BVar2 = LYCanWriteFile(filename);
          } while (BVar2 == '\0');
          HTAddParam(&the_upload,upload_command->command,1,filename);
          HTEndParam(&the_upload,upload_command->command,1);
        }
        HTAddParam(&the_command,"cd %s ; ",1,Msg + 3);
        HTEndParam(&the_command,"cd %s ; ",1);
        HTSACat(&the_command,the_upload);
        Msg = the_command;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"command: %s\n",Msg);
        }
        stop_curses();
        LYSystem(the_command);
        start_curses();
        if (the_command != (char *)0x0) {
          free(the_command);
          the_command = (char *)0x0;
        }
        if (the_upload != (char *)0x0) {
          free(the_upload);
          the_upload = (char *)0x0;
        }
        if (filename != (char *)0x0) {
          chmod(filename,0x180);
        }
        if (filename != (char *)0x0) {
          free(filename);
          filename = (char *)0x0;
        }
        local_140 = 1;
        goto LAB_080d7436;
      }
      Msg = (char *)gettext("ERROR! - upload command is misconfigured");
      HTAlert(Msg);
    }
  }
  Msg = (char *)gettext("Unable to upload file.");
  HTAlert(Msg);
  local_140 = 0;
LAB_080d7436:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_140;
}



int LYUpload_options(char **newfile,char *directory)

{
  char curloc [256];
  char tempfile [256];
  FILE *fp0_00;
  char *__src;
  undefined4 uVar1;
  int local_1c;
  char *local_18;
  char *cp;
  int count;
  lynx_list_item_type *cur_upload;
  FILE *fp0;
  
  fp0_00 = InternalPageFP((char *)&ram0x081b0280,1);
  if (fp0_00 == (FILE *)0x0) {
    local_1c = -1;
  }
  else {
    __src = HTnameOfFile_WWW(directory,'\0','\x01');
    strcpy((char *)&ram0x081b0180,__src);
    LYTrimPathSep((char *)0x81b0180);
    if (__src != (char *)0x0) {
      free(__src);
    }
    LYLocalFileToURL(newfile,(char *)0x81b0280);
    LYRegisterUIPage(*newfile,UIP_UPLOAD_OPTIONS);
    __src = (char *)gettext("Upload Options");
    BeginInternalPage(fp0_00,__src,"Lynx_users_guide.html.gz#DirEd");
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    uVar1 = gettext("Upload To:");
    fprintf((FILE *)fp0_00,"   <em>%s</em> %s\n",uVar1,0x81b0180);
    uVar1 = gettext("Upload options:");
    fprintf((FILE *)fp0_00,"\n%s\n",uVar1);
    if (uploaders == (lynx_list_item_type *)0x0) {
      fwrite("   &lt;NONE&gt;\n",1,0x10,(FILE *)fp0_00);
    }
    else {
      count = 0;
      cur_upload = uploaders;
      while (cur_upload != (lynx_list_item_type *)0x0) {
        fprintf((FILE *)fp0_00,"   <a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\">",count,0x81b0180);
        if (cur_upload->name == (char *)0x0) {
          local_18 = (char *)gettext("No Name Given");
        }
        else {
          local_18 = cur_upload->name;
        }
        fputs(local_18,(FILE *)fp0_00);
        fwrite("</a>\n",1,5,(FILE *)fp0_00);
        cur_upload = (lynx_list_item_type *)cur_upload->next;
        count = count + 1;
      }
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYforce_no_cache = '\x01';
    local_1c = 0;
  }
  return local_1c;
}



void no_leak_checking(void)

{
  return;
}



int LYatexit(anon_subr_void *function)

{
  FILE *__stream;
  int local_8;
  
  if (topOfStack == 0x32) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"(LY)atexit: Too many functions, ignoring one!\n");
    }
    local_8 = -1;
  }
  else {
    callstack[topOfStack] = function;
    topOfStack = topOfStack + 1;
    local_8 = 0;
  }
  return local_8;
}



void LYCompleteExit(void)

{
  while (topOfStack = topOfStack + -1, -1 < topOfStack) {
    (*callstack[topOfStack])();
  }
  return;
}



void LYexit(int status)

{
  undefined4 uVar1;
  
  if (LYOutOfMemory == '\x01') {
    signal(1,(__sighandler_t)0x1);
    signal(0xf,(__sighandler_t)0x1);
    signal(2,(__sighandler_t)0x1);
    signal(0xb,(__sighandler_t)0x1);
    signal(4,(__sighandler_t)0x1);
    fflush(stderr);
    fflush(stdout);
    if (LYCursesON != '\0') {
      LYSleepAlert();
    }
    cleanup_sig(0);
    signal(0xb,(__sighandler_t)0x0);
    signal(4,(__sighandler_t)0x0);
  }
  LYCloselog();
  LYCompleteExit();
  LYCloseCmdLogfile();
  cleanup_files();
  fflush(stderr);
  if (LYOutOfMemory == '\x01') {
    LYOutOfMemory = '\0';
    uVar1 = gettext("Memory exhausted!  Program aborted!");
    printf("\r\n%s\r\n\r\n",uVar1);
    fflush(stdout);
  }
  LYCloseTracelog();
                    // WARNING: Subroutine does not return
  exit(status);
}



void outofmem(char *fname,char *func)

{
  undefined4 uVar1;
  
  uVar1 = gettext("Memory exhausted!  Aborting...");
  fprintf(stderr,"\n\n\n%s %s: %s\n",fname,func,uVar1);
  LYOutOfMemory = '\x01';
  LYexit(-1);
  return;
}



void LYJumpTable_free(void)

{
  JumpTable *pJVar1;
  JumpTable *next;
  JumpTable *cur;
  
  cur = JThead;
  pJVar1 = cur;
  while (cur = pJVar1, cur != (JumpTable *)0x0) {
    pJVar1 = cur->next;
    if (cur->msg != (char *)0x0) {
      free(cur->msg);
      cur->msg = (char *)0x0;
    }
    if (cur->file != (char *)0x0) {
      free(cur->file);
      cur->file = (char *)0x0;
    }
    if (cur->shortcut != (char *)0x0) {
      free(cur->shortcut);
      cur->shortcut = (char *)0x0;
    }
    if (cur->history != (HTList *)0x0) {
      LYFreeStringList(cur->history);
      cur->history = (HTList *)0x0;
    }
    if (cur->table != (JumpDatum *)0x0) {
      free(cur->table);
      cur->table = (JumpDatum *)0x0;
    }
    if (cur->mp != (char *)0x0) {
      free(cur->mp);
      cur->mp = (char *)0x0;
    }
    if (cur != (JumpTable *)0x0) {
      free(cur);
    }
  }
  JThead = (JumpTable *)0x0;
  return;
}



void LYAddJumpShortcut(HTList *historyp,char *shortcut)

{
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *tmp;
  
  tmp = (char *)0x0;
  cur = historyp;
  if (((historyp != (HTList *)0x0) && (shortcut != (char *)0x0)) && (*shortcut != '\0')) {
    HTSACopy(&tmp,shortcut);
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)cur->object;
      }
      if (local_18 == (char *)0x0) goto LAB_080d7ac1;
      iVar1 = strcmp(local_18,tmp);
    } while (iVar1 != 0);
    HTList_removeObject(historyp,local_18);
    if (local_18 != (char *)0x0) {
      free(local_18);
    }
LAB_080d7ac1:
    HTList_addObject(historyp,tmp);
  }
  return;
}



BOOLEAN LYJumpInit(char *config)

{
  char *src;
  int iVar1;
  size_t sVar2;
  HTList *pHVar3;
  BOOLEAN local_19;
  JumpTable *jtptmp;
  char *cp;
  JumpTable *jtp;
  
  jtp = (JumpTable *)calloc(1,0x24);
  if (jtp == (JumpTable *)0x0) {
    outofmem("./LYJump.c","LYJumpInit");
  }
  src = strtok(config,":\n");
  if (src == (char *)0x0) {
    if (jtp != (JumpTable *)0x0) {
      free(jtp);
    }
    local_19 = '\0';
  }
  else {
    src = strtok((char *)0x0,":\n");
    if (src == (char *)0x0) {
      if (jtp != (JumpTable *)0x0) {
        free(jtp);
      }
      local_19 = '\0';
    }
    else {
      HTSACopy(&jtp->file,src);
      cp = strtok((char *)0x0,":\n");
      if ((cp == (char *)0x0) && (JThead != (JumpTable *)0x0)) {
        jtptmp = JThead;
        jumpfile = jtp->file;
        if (jtp != (JumpTable *)0x0) {
          free(jtp);
        }
        while ((jtptmp != (JumpTable *)0x0 && (jtptmp->key != 0))) {
          jtptmp = jtptmp->next;
        }
        if (jtptmp == (JumpTable *)0x0) {
          local_19 = '\0';
        }
        else {
          HTSACopy(&jtptmp->file,jumpfile);
          HTSACopy(&jtptmp->msg,jumpprompt);
          local_19 = '\x01';
        }
      }
      else {
        if ((cp != (char *)0x0) && (JThead == (JumpTable *)0x0)) {
          JThead = jtp;
          HTSACopy(&jtp->msg,jumpprompt);
          if (jumpfile == (char *)0x0) {
            HTSACopy(&jumpfile,JThead->file);
          }
          jtp = (JumpTable *)calloc(1,0x24);
          if (jtp == (JumpTable *)0x0) {
            outofmem("./LYJump.c","LYJumpInit");
          }
          HTSACopy(&jtp->file,JThead->file);
        }
        if (cp != (char *)0x0) {
          iVar1 = remap(cp,"JUMP",'\0');
          jtp->key = iVar1;
          cp = strtok((char *)0x0,"\n");
          if ((cp == (char *)0x0) || (*cp == '\0')) {
            cp = (char *)0x0;
          }
          else {
            HTSACopy(&jtp->msg,cp);
          }
        }
        if (cp == (char *)0x0) {
          HTSACopy(&jtp->msg,jumpprompt);
        }
        src = jtp->msg;
        sVar2 = strlen(jtp->msg);
        if (src[sVar2 - 1] != ' ') {
          HTSACat(&jtp->msg," ");
        }
        pHVar3 = HTList_new();
        jtp->history = pHVar3;
        jtp->next = JThead;
        JThead = jtp;
        local_19 = '\x01';
      }
    }
  }
  return local_19;
}



char * LYJump(int key)

{
  bool bVar1;
  bool bVar2;
  char buf [124];
  uint uVar3;
  size_t sVar4;
  ushort **ppuVar5;
  int iVar6;
  char *text;
  char *src;
  void *pvVar7;
  bool bVar8;
  int local_40;
  char *local_38;
  JumpDatum seeking;
  char *msg;
  int ShortcutNum;
  int ShortcutTotal;
  RecallType recall;
  int ch;
  JumpTable *jtp;
  char *cp;
  char *bp;
  JumpDatum *found;
  BOOLEAN FirstShortcutRecall;
  
  if (JThead != (JumpTable *)0x0) {
    jtp = JThead;
    while (((jtp != (JumpTable *)0x0 && (jtp->key != 0)) && (jtp->key != key))) {
      jtp = jtp->next;
    }
    if (jtp == (JumpTable *)0x0) {
      msg = (char *)0x0;
      text = (char *)gettext("Key \'%c\' is not mapped to a jump file!");
      HTSprintf0(&msg,text,key);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
      }
    }
    else {
      if (jtp->table == (JumpDatum *)0x0) {
        uVar3 = LYRead_Jumpfile(jtp);
        jtp->nel = uVar3;
      }
      if (jtp->nel != 0) {
        if (((jump_buffer == '\0') || (jtp->shortcut == (char *)0x0)) || (*jtp->shortcut == '\0')) {
          buf[0] = '\0';
        }
        else {
          if ((jtp->shortcut != (char *)0x0) && (*jtp->shortcut != '\0')) {
            sVar4 = strlen(jtp->shortcut);
            if (0x77 < sVar4) {
              jtp->shortcut[0x77] = '\0';
            }
            strcpy((char *)0x81b04a0,jtp->shortcut);
          }
        }
        if (jtp->history == (HTList *)0x0) {
          local_40 = 0;
        }
        else {
          local_40 = HTList_count(jtp->history);
        }
        if ((jump_buffer == '\0') || (buf[0] == '\0')) {
          bVar1 = 0 < local_40;
          ShortcutNum = local_40;
          bVar2 = true;
        }
        else {
          bVar1 = 1 < local_40;
          ShortcutNum = 0;
          bVar2 = false;
        }
        recall = (RecallType)bVar1;
        statusline(jtp->msg);
        ch = LYgetstr((char *)0x81b04a0,0,0x78,recall);
        if (ch < 0) {
          text = (char *)gettext("Cancelled!!!");
          HTInfoMsg(text);
        }
        else {
          do {
            while( true ) {
              bp = (char *)0x81b04a0;
              ppuVar5 = __ctype_b_loc();
              if (((*ppuVar5)[key & 0xff] & 0x200) == 0) {
                bVar8 = (char)key == 'G';
              }
              else {
                iVar6 = toupper(key & 0xff);
                bVar8 = iVar6 == 0x47;
              }
              if ((bVar8) && (iVar6 = strncmp((char *)0x81b04a0,"o ",2), iVar6 == 0)) {
                bp = (char *)0x81b04a1;
              }
              text = LYSkipBlanks(bp);
              if ((*text == '\0') && ((bVar1 == false || ((ch != 0x100 && (ch != 0x101)))))) {
                buf[0] = '\0';
                HTSACopy(&jtp->shortcut,(char *)0x81b04a0);
                text = (char *)gettext("Cancelled!!!");
                HTInfoMsg(text);
                return (char *)0x0;
              }
              if ((bVar1 == false) || (ch != 0x100)) break;
              if (bVar2) {
                bVar2 = false;
                ShortcutNum = 0;
              }
              else {
                ShortcutNum = ShortcutNum + 1;
              }
              if (local_40 <= ShortcutNum) {
                ShortcutNum = 0;
              }
              src = (char *)HTList_objectAt(jtp->history,ShortcutNum);
              if (src == (char *)0x0) {
LAB_080d83cf:
                seeking.key = text;
                pvVar7 = bsearch(&seeking,jtp->table,jtp->nel,8,LYCompare);
                if (pvVar7 == (void *)0x0) {
                  user_message("Unknown target \'%s\'",(char *)0x81b04a0);
                  LYSleepAlert();
                }
                HTSACopy(&jtp->shortcut,text);
                LYAddJumpShortcut(jtp->history,jtp->shortcut);
                if (pvVar7 == (void *)0x0) {
                  local_38 = (char *)0x0;
                }
                else {
                  local_38 = *(char **)((int)pvVar7 + 4);
                }
                return local_38;
              }
              LYstrncpy((char *)0x81b04a0,src,0x7b);
              if (((jump_buffer == '\0') || (jtp->shortcut == (char *)0x0)) ||
                 (iVar6 = strcmp((char *)0x81b04a0,jtp->shortcut), iVar6 != 0)) {
                if (((jump_buffer == '\0') || (local_40 != 2)) &&
                   ((jump_buffer != '\0' || (local_40 != 1)))) {
                  mustshow = '\x01';
                  text = (char *)gettext("Edit a previous shortcut: ");
                  statusline(text);
                }
                else {
                  mustshow = '\x01';
                  text = (char *)gettext("Edit the previous shortcut: ");
                  statusline(text);
                }
              }
              else {
                mustshow = '\x01';
                text = (char *)gettext("Edit the current shortcut: ");
                statusline(text);
              }
              ch = LYgetstr((char *)0x81b04a0,0,0x7c,recall);
              if (ch < 0) {
                text = (char *)gettext("Cancelled!!!");
                HTInfoMsg(text);
                return (char *)0x0;
              }
            }
            if ((bVar1 == false) || (ch != 0x101)) goto LAB_080d83cf;
            if (bVar2) {
              bVar2 = false;
              ShortcutNum = local_40;
            }
            ShortcutNum = ShortcutNum + -1;
            if (ShortcutNum < 0) {
              ShortcutNum = local_40 + -1;
            }
            src = (char *)HTList_objectAt(jtp->history,ShortcutNum);
            if (src == (char *)0x0) goto LAB_080d83cf;
            LYstrncpy((char *)0x81b04a0,src,0x7b);
            if (((jump_buffer == '\0') || (jtp->shortcut == (char *)0x0)) ||
               (iVar6 = strcmp((char *)0x81b04a0,jtp->shortcut), iVar6 != 0)) {
              if (((jump_buffer == '\0') || (local_40 != 2)) &&
                 ((jump_buffer != '\0' || (local_40 != 1)))) {
                mustshow = '\x01';
                text = (char *)gettext("Edit a previous shortcut: ");
                statusline(text);
              }
              else {
                mustshow = '\x01';
                text = (char *)gettext("Edit the previous shortcut: ");
                statusline(text);
              }
            }
            else {
              mustshow = '\x01';
              text = (char *)gettext("Edit the current shortcut: ");
              statusline(text);
            }
            ch = LYgetstr((char *)0x81b04a0,0,0x7c,recall);
          } while (-1 < ch);
          text = (char *)gettext("Cancelled!!!");
          HTInfoMsg(text);
        }
      }
    }
  }
  return (char *)0x0;
}



uint LYRead_Jumpfile(JumpTable *jtp)

{
  FILE *__stream;
  int __fd;
  uint uVar1;
  JumpDatum *pJVar2;
  char *Msg;
  char *Msg_00;
  uint local_a0;
  stat st;
  uint i;
  char *cp;
  int fd;
  char *mp;
  uint nel;
  
  if ((jtp->file == (char *)0x0) || (*jtp->file == '\0')) {
    local_a0 = 0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      Msg_00 = jtp->file;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Read Jumpfile %s\n",Msg_00);
    }
    __fd = stat64(jtp->file,(stat64 *)&st);
    if (__fd < 0) {
      Msg_00 = (char *)gettext("Cannot locate jump file!");
      HTAlert(Msg_00);
      local_a0 = 0;
    }
    else {
      Msg_00 = (char *)calloc((size_t)st.st_size + 1,1);
      if (Msg_00 == (char *)0x0) {
        Msg_00 = (char *)gettext("Out of memory reading jump file!");
        HTAlert(Msg_00);
        local_a0 = 0;
      }
      else {
        __fd = open64(jtp->file,0);
        if (__fd < 0) {
          Msg = (char *)gettext("Cannot open jump file!");
          HTAlert(Msg);
          if (Msg_00 != (char *)0x0) {
            free(Msg_00);
          }
          local_a0 = 0;
        }
        else {
          uVar1 = read(__fd,Msg_00,(size_t)st.st_size);
          if ((st.st_size._4_4_ < (int)uVar1 >> 0x1f) ||
             ((st.st_size._4_4_ <= (int)uVar1 >> 0x1f && ((size_t)st.st_size <= uVar1)))) {
            Msg_00[(size_t)st.st_size] = '\0';
            close(__fd);
            nel = 0;
            cp = Msg_00;
            while( true ) {
              cp = strchr(cp,10);
              if (cp == (char *)0x0) break;
              nel = nel + 1;
              cp = cp + 1;
            }
            pJVar2 = (JumpDatum *)malloc(nel << 3);
            jtp->table = pJVar2;
            if (jtp->table == (JumpDatum *)0x0) {
              Msg = (char *)gettext("Out of memory reading jump table!");
              HTAlert(Msg);
              if (Msg_00 != (char *)0x0) {
                free(Msg_00);
              }
              local_a0 = 0;
            }
            else {
              jtp->mp = Msg_00;
              cp = jtp->mp;
              i = 0;
              do {
                while( true ) {
                  if (nel <= i) goto LAB_080d88cd;
                  __fd = strncmp(cp,"<!--",4);
                  if (__fd != 0) break;
LAB_080d8755:
                  cp = strchr(cp,10);
                  if (cp == (char *)0x0) goto LAB_080d88cd;
                  cp = cp + 1;
                }
                __fd = strncmp(cp,"<dl>",4);
                if (__fd == 0) goto LAB_080d8755;
                Msg_00 = LYstrstr(cp,"<dt>");
                if (Msg_00 == (char *)0x0) break;
                jtp->table[i].key = Msg_00 + 4;
                Msg_00 = LYstrstr(Msg_00 + 4,"<dd>");
                if (Msg_00 == (char *)0x0) break;
                *Msg_00 = '\0';
                Msg_00 = LYstrstr(Msg_00 + 4,"href=\"");
                if (Msg_00 == (char *)0x0) break;
                jtp->table[i].url = Msg_00 + 6;
                Msg_00 = strchr(Msg_00 + 6,0x22);
                if (Msg_00 == (char *)0x0) break;
                *Msg_00 = '\0';
                cp = strchr(Msg_00 + 1,10);
                if (cp == (char *)0x0) break;
                cp = cp + 1;
                if (WWW_TraceFlag != '\0') {
                  Msg_00 = jtp->table[i].url;
                  Msg = jtp->table[i].key;
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"Read jumpfile[%u] key=\'%s\', url=\'%s\'\n",i,Msg,Msg_00
                         );
                }
                i = i + 1;
              } while (cp != (char *)0x0);
LAB_080d88cd:
              local_a0 = i;
            }
          }
          else {
            Msg = (char *)gettext("Error reading jump file!");
            HTAlert(Msg);
            if (Msg_00 != (char *)0x0) {
              free(Msg_00);
            }
            local_a0 = 0;
          }
        }
      }
    }
  }
  return local_a0;
}



int LYCompare(void *e1,void *e2)

{
  int iVar1;
  
  iVar1 = strcasecomp(*(char **)e1,*(char **)e2);
  return iVar1;
}


/*
Unable to decompile 'showlist'
Cause: 
Low-level Error: Shared type id: 80000000000001b
  _state : eGridState
*/


void print_refs(FILE *fp,BOOLEAN titles,int refs)

{
  HTParentAnchor *me;
  HTParentAnchor *me_00;
  char *__ptr;
  char *local_34;
  char *local_30;
  undefined *local_2c;
  char *title;
  HTParentAnchor *parent;
  HTAnchor *dest;
  HTChildAnchor *child;
  void *helper;
  char *desc;
  char *address;
  int cnt;
  
  desc = (char *)gettext("unknown field or link");
  helper = (void *)0x0;
  cnt = 1;
  while (cnt <= refs) {
    me_00 = (HTParentAnchor *)HText_childNextNumber(cnt,&helper);
    if (me_00 == (HTParentAnchor *)0x0) {
      if ((keypad_mode == 3) || (keypad_mode == 2)) {
        HText_FormDescNumber(cnt,&desc);
        fprintf((FILE *)fp,"%4d. form field = %s\n",cnt,desc);
      }
    }
    else {
      me = (HTParentAnchor *)HTAnchor_followLink((HTChildAnchor *)me_00);
      if (me != me_00) {
        me_00 = HTAnchor_parent((HTAnchor *)me);
        if (titles == '\0') {
          local_34 = (char *)0x0;
        }
        else {
          local_34 = HTAnchor_title(me_00);
        }
        __ptr = HTAnchor_address((HTAnchor *)me);
        if ((keypad_mode == 1) || (keypad_mode == 2)) {
          fprintf((FILE *)fp,"%4d. ",cnt);
        }
        local_30 = __ptr;
        if (local_34 != (char *)0x0) {
          local_30 = local_34;
        }
        if ((me_00 == me) || (local_34 == (char *)0x0)) {
          local_2c = &DAT_08168e75;
        }
        else {
          local_2c = &DAT_08168e7a;
        }
        fprintf((FILE *)fp,"%s%s\n",local_2c,local_30);
        if (__ptr != (char *)0x0) {
          free(__ptr);
        }
      }
    }
    cnt = cnt + 1;
  }
  return;
}



void print_hidden_refs(FILE *fp,int refs,int hidden_links)

{
  undefined4 local_20;
  char *src;
  undefined *local_18;
  char *address;
  int cnt;
  
  address = (char *)0x0;
  local_20 = gettext("Hidden links:");
  if (refs < 1) {
    local_18 = &DAT_08168e75;
  }
  else {
    local_18 = &DAT_08168f21;
  }
  fprintf((FILE *)fp,"%s   %s\n",local_18,local_20);
  cnt = 0;
  while (cnt < hidden_links) {
    src = HText_HiddenLinkAt(HTMainText,cnt);
    HTSACopy(&address,src);
    if ((address == (char *)0x0) || (*address == '\0')) {
      if (address != (char *)0x0) {
        free(address);
        address = (char *)0x0;
      }
    }
    else {
      if ((keypad_mode == 1) || (keypad_mode == 2)) {
        fprintf((FILE *)fp,"%4d. ",cnt + 1 + refs,local_20);
      }
      fprintf((FILE *)fp,"%s\n",address);
      if (address != (char *)0x0) {
        free(address);
        address = (char *)0x0;
      }
    }
    cnt = cnt + 1;
  }
  return;
}



void printlist(FILE *fp,BOOLEAN titles)

{
  int refs_00;
  undefined4 uVar1;
  int hidden_links;
  int refs;
  
  refs_00 = HText_sourceAnchors(HTMainText);
  if ((0 < refs_00) || (LYHiddenLinks == 1)) {
    hidden_links = HText_HiddenLinkCount(HTMainText);
    if ((0 < refs_00) || (0 < hidden_links)) {
      if ((((keypad_mode == 1) || (keypad_mode == 2)) || (keypad_mode == 3)) || (keypad_mode == 2))
      {
        uVar1 = gettext("References");
        fprintf((FILE *)fp,"\n%s\n\n",uVar1);
      }
      if (LYHiddenLinks == 2) {
        hidden_links = 0;
      }
      if (0 < hidden_links) {
        uVar1 = gettext("Visible links");
        fprintf((FILE *)fp,"   %s\n",uVar1);
      }
      print_refs(fp,titles,refs_00);
      if (0 < hidden_links) {
        print_hidden_refs(fp,refs_00,hidden_links);
      }
    }
  }
  LYPrintImgMaps(fp);
  return;
}



void remember_alloced(void *ptr)

{
  if (alloced == (HTList *)0x0) {
    alloced = HTList_new();
  }
  HTList_addObject(alloced,ptr);
  return;
}



void add_environment_value(char *env_value)

{
  int iVar1;
  
  if (envc == envc_size) {
    if (env == (char **)0x0) {
      iVar1 = envc_size + 0xc;
      envc_size = envc_size + 10;
      env = (char **)malloc(iVar1 * 4);
      remember_alloced(env);
    }
    else {
      iVar1 = envc_size + 0xc;
      envc_size = envc_size + 10;
      env = (char **)realloc(env,iVar1 * 4);
    }
    if (env == (char **)0x0) {
      outofmem("./LYCgi.c","LYCgi");
    }
  }
  env[envc] = env_value;
  envc = envc + 1;
  env[envc] = (char *)0x0;
  return;
}



void add_lynxcgi_environment(char *variable_name)

{
  char *pcVar1;
  char *add_value;
  char *env_value;
  
  pcVar1 = LYGetEnv(variable_name);
  if (pcVar1 != (char *)0x0) {
    add_value = (char *)0x0;
    HTSprintf0(&add_value,"%s=%s",variable_name,pcVar1);
    add_environment_value(add_value);
    remember_alloced(add_value);
  }
  return;
}



BOOLEAN can_exec_cgi(char *linktext,char *linkargs)

{
  BOOLEAN BVar1;
  char *fmt;
  char *source;
  char *p;
  char *command;
  char *message;
  char *format;
  BOOLEAN result;
  
  fmt = (char *)gettext("Do you want to execute \"%s\"?");
  message = (char *)0x0;
  command = (char *)0x0;
  result = '\x01';
  source = HTLoadedDocumentURL();
  BVar1 = exec_ok(source,linktext,2);
  if (BVar1 == '\0') {
    result = '\0';
  }
  else {
    if (user_mode < 2) {
      HTSACopy(&command,linktext);
      if ((linkargs != (char *)0x0) && (*linkargs != '\0')) {
        HTSprintf(&command," %s",linkargs);
      }
      HTUnEscape(command);
      p = command;
      while (*p != '\0') {
        if (*p == '+') {
          *p = ' ';
        }
        p = p + 1;
      }
      HTSprintf0(&message,fmt,command);
      result = HTConfirm(message);
      if (message != (char *)0x0) {
        free(message);
        message = (char *)0x0;
      }
      if (command != (char *)0x0) {
        free(command);
      }
    }
  }
  return result;
}



int LYLoadCGI(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  BOOLEAN first_time;
  BOOLEAN BVar2;
  size_t sVar3;
  int iVar4;
  int *piVar5;
  char *local_520;
  FILE *__stream;
  char *fmt;
  __pid_t __pid;
  ssize_t sVar6;
  __pid_t _Var7;
  int __fd2;
  char **__argv;
  int in_GS_OFFSET;
  int local_510;
  int local_50c;
  char *local_504;
  int local_500;
  stat stat_buf;
  int fd2 [2];
  int fd1 [2];
  char *cr;
  int exec_errno;
  char **cur_argv;
  int argv_cnt;
  char **argv;
  int total_written;
  int remaining;
  int written;
  int total_chars;
  int chars;
  char *tmp;
  char *new_arg;
  int pid;
  HTStream *target;
  HTFormat format_in;
  char *path_translated;
  char *pgm_buff;
  char *path_info;
  char *document_root;
  char *orig_pgm;
  int statrv;
  char *pgm_args;
  char *pgm;
  char *cp;
  int status;
  char buf [1024];
  
  __fd2 = *(int *)(in_GS_OFFSET + 0x14);
  pgm = (char *)0x0;
  pgm_args = (char *)0x0;
  orig_pgm = (char *)0x0;
  document_root = (char *)0x0;
  path_info = (char *)0x0;
  pgm_buff = (char *)0x0;
  if ((arg != (char *)0x0) && (*arg != '\0')) {
    sVar3 = strlen(arg);
    if (8 < sVar3) {
      iVar4 = strncmp(arg,"lynxcgi://localhost",0x13);
      if (iVar4 == 0) {
        HTSACopy(&pgm,arg + 0x13);
      }
      else {
        HTSACopy(&pgm,arg + 8);
      }
      cp = strchr(pgm,0x3f);
      if (cp != (char *)0x0) {
        *cp = '\0';
        pgm_args = cp + 1;
        cp = pgm_args;
      }
      HTSACopy(&orig_pgm,pgm);
      cp = trimPoundSelector(pgm);
      if (cp != (char *)0x0) {
        pgm_args = (char *)0x0;
      }
      HTUnEscape(pgm);
      statrv = stat64(pgm,(stat64 *)&stat_buf);
      if (statrv < 0) {
        HTSACopy(&pgm_buff,pgm);
        while( true ) {
          if (-1 < statrv) {
            statrv = stat64(pgm_buff,(stat64 *)&stat_buf);
            if (-1 < statrv) goto LAB_080d9a59;
          }
          cp = strrchr(pgm_buff,0x2f);
          if (cp == (char *)0x0) break;
          *cp = '\0';
          statrv = 1;
        }
        if (WWW_TraceFlag != '\0') {
          piVar5 = __errno_location();
          local_520 = strerror(*piVar5);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","strrchr(pgm_buff, \'/\') returned NULL",
                  local_520);
        }
LAB_080d9a59:
        local_520 = pgm;
        if (statrv < 0) {
          if (WWW_TraceFlag != '\0') {
            piVar5 = __errno_location();
            local_520 = strerror(*piVar5);
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","stat() of pgm_buff failed",local_520);
          }
        }
        else {
          sVar3 = strlen(pgm_buff);
          HTSACopy(&path_info,local_520 + sVar3);
          strcpy(pgm,pgm_buff);
          pcVar1 = path_info;
          local_520 = pgm_buff;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
                    local_520,pcVar1);
          }
        }
        if (pgm_buff != (char *)0x0) {
          free(pgm_buff);
          pgm_buff = (char *)0x0;
        }
      }
      pcVar1 = pgm;
      local_520 = orig_pgm;
      if (statrv == 0) {
        if (((stat_buf.st_mode & 0xf000) == 0x8000) && ((stat_buf.st_mode & 0x49) != 0)) {
          if (((path_info != (char *)0x0) && (anAnchor != HTMainAnchor)) &&
             ((reloading == '\0' || (anAnchor->document == (HyperDoc *)0x0)))) {
            local_520 = HTLoadedDocumentURL();
            iVar4 = strcmp(arg,local_520);
            if (iVar4 != 0) {
              BVar2 = HText_AreDifferent(anAnchor,arg);
              if (BVar2 != '\0') {
                local_520 = HTUnEscape(orig_pgm);
                if (local_520 != (char *)0x0) {
                  BVar2 = can_exec_cgi(orig_pgm,"");
                  if (BVar2 == '\0') {
                    status = -29999;
                    goto LAB_080dae19;
                  }
                }
              }
            }
          }
          if (no_lynxcgi == '\0') {
            if (((no_bookmark_exec != '\0') && (anAnchor != HTMainAnchor)) &&
               ((reloading == '\0' || (anAnchor->document == (HyperDoc *)0x0)))) {
              local_520 = HTLoadedDocumentURL();
              iVar4 = strcmp(arg,local_520);
              if (iVar4 != 0) {
                BVar2 = HText_AreDifferent(anAnchor,arg);
                if (BVar2 != '\0') {
                  local_520 = HTLoadedDocumentBookmark();
                  if (local_520 != (char *)0x0) {
                    local_520 = (char *)gettext("Execution via bookmarks is disabled.");
                    HTUserMsg(local_520);
                    status = -29999;
                    goto LAB_080dae19;
                  }
                }
              }
            }
            if ((anAnchor != HTMainAnchor) &&
               ((reloading == '\0' || (anAnchor->document == (HyperDoc *)0x0)))) {
              local_520 = HTLoadedDocumentURL();
              iVar4 = strcmp(arg,local_520);
              if (iVar4 != 0) {
                BVar2 = HText_AreDifferent(anAnchor,arg);
                if (BVar2 != '\0') {
                  BVar2 = can_exec_cgi(pgm,pgm_args);
                  if (BVar2 == '\0') {
                    status = -29999;
                    goto LAB_080dae19;
                  }
                }
              }
            }
            if ((anAnchor->isHEAD == '\0') && (keep_mime_headers == '\0')) {
              format_in = (HTFormat)HTAtom_for("www/mime");
            }
            else {
              format_in = (HTFormat)HTAtom_for("text/plain");
            }
            local_520 = (char *)anAnchor;
            target = HTStreamStack(format_in,format_out,sink,anAnchor);
            if ((target == (HTStream *)0x0) || (target == (HTStream *)0x0)) {
              tmp = (char *)0x0;
              local_520 = format_out->name;
              pcVar1 = format_in->name;
              fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
              HTSprintf0(&tmp,fmt,pcVar1,local_520);
              HTAlert(tmp);
              if (tmp != (char *)0x0) {
                free(tmp);
                tmp = (char *)0x0;
              }
              status = -29999;
            }
            else {
              if (anAnchor->post_data != (bstring *)0x0) {
                iVar4 = pipe(fd1);
                if (iVar4 < 0) {
                  local_520 = (char *)gettext("Unable to set up connection.");
                  HTAlert(local_520);
                  if (WWW_TraceFlag != '\0') {
                    piVar5 = __errno_location();
                    local_520 = strerror(*piVar5);
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","pipe() failed",local_520);
                  }
                  status = -3;
                  goto LAB_080dadfa;
                }
              }
              iVar4 = pipe(fd2);
              if (iVar4 < 0) {
                local_520 = (char *)gettext("Unable to set up connection.");
                HTAlert(local_520);
                if (WWW_TraceFlag != '\0') {
                  piVar5 = __errno_location();
                  local_520 = strerror(*piVar5);
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","pipe() failed",local_520);
                }
                close(fd1[0]);
                close(fd1[1]);
                status = -3;
              }
              else {
                if (first_time != '\0') {
                  first_time = '\0';
                  add_environment_value("REMOTE_HOST=localhost");
                  add_environment_value("REMOTE_ADDR=127.0.0.1");
                  HTSprintf0(&user_agent,"HTTP_USER_AGENT=%s/%s libwww/%s",&DAT_081691b3,
                             "2.8.7dev.11",HTLibraryVersion);
                  add_environment_value(user_agent);
                  local_520 = "2.8.7dev.11";
                  sink = (HTStream *)&DAT_081691b3;
                  HTSprintf0(&server_software,"SERVER_SOFTWARE=%s/%s",&DAT_081691b3,"2.8.7dev.11");
                  add_environment_value(server_software);
                }
                fflush(stdout);
                fflush(stderr);
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fflush((FILE *)__stream);
                }
                __pid = fork();
                if (__pid < 1) {
                  if (__pid == 0) {
                    argv_cnt = 3;
                    close(fd2[0]);
                    __fd2 = fileno(stdout);
                    dup2(fd2[1],__fd2);
                    __fd2 = fileno(stderr);
                    dup2(fd2[1],__fd2);
                    close(fd2[1]);
                    if ((language != (char *)0x0) && (*language != '\0')) {
                      HTSprintf0(&accept_language,"HTTP_ACCEPT_LANGUAGE=%s",language);
                      add_environment_value(accept_language);
                    }
                    if ((pref_charset != (char *)0x0) && (*pref_charset != '\0')) {
                      cp = (char *)0x0;
                      HTSACopy(&cp,"HTTP_ACCEPT_CHARSET=");
                      HTSACat(&cp,pref_charset);
                      add_environment_value(cp);
                    }
                    if ((anAnchor->post_data != (bstring *)0x0) &&
                       (anAnchor->post_content_type != (char *)0x0)) {
                      cp = (char *)0x0;
                      HTSACopy(&cp,"CONTENT_TYPE=");
                      HTSACat(&cp,anAnchor->post_content_type);
                      add_environment_value(cp);
                    }
                    if (anAnchor->post_data == (bstring *)0x0) {
                      __fd2 = fileno(stdin);
                      close(__fd2);
                      if (anAnchor->isHEAD != '\0') {
                        add_environment_value("REQUEST_METHOD=HEAD");
                      }
                    }
                    else {
                      close(fd1[1]);
                      __fd2 = fileno(stdin);
                      dup2(fd1[0],__fd2);
                      close(fd1[0]);
                      add_environment_value("REQUEST_METHOD=POST");
                      if (anAnchor->post_data == (bstring *)0x0) {
                        local_500 = 0;
                      }
                      else {
                        local_500 = anAnchor->post_data->len;
                      }
                      HTSprintf0(&post_len,"CONTENT_LENGTH=%d",local_500);
                      add_environment_value(post_len);
                    }
                    if (pgm_args != (char *)0x0) {
                      cp = pgm_args;
                      while (*cp != '\0') {
                        if (*cp == '+') {
                          argv_cnt = argv_cnt + 1;
                        }
                        cp = cp + 1;
                      }
                    }
                    __argv = (char **)malloc(argv_cnt << 2);
                    if (__argv == (char **)0x0) {
                      outofmem("./LYCgi.c","LYCgi");
                    }
                    cur_argv = __argv + 1;
                    if (pgm_args == (char *)0x0) {
                      if ((anAnchor->isHEAD == '\0') && (anAnchor->post_data == (bstring *)0x0)) {
                        add_environment_value("REQUEST_METHOD=GET");
                      }
                    }
                    else {
                      if (is_www_index == '\0') {
                        if ((anAnchor->isHEAD == '\0') && (anAnchor->post_data == (bstring *)0x0)) {
                          add_environment_value("REQUEST_METHOD=GET");
                        }
                      }
                      else {
                        add_environment_value("REQUEST_METHOD=SEARCH");
                      }
                      cp = (char *)0x0;
                      HTSACopy(&cp,"QUERY_STRING=");
                      HTSACat(&cp,pgm_args);
                      add_environment_value(cp);
                      cp = pgm_args;
                      cr = pgm_args;
                      while (*cp != '\0') {
                        if (*cp == '+') {
                          *cp = '\0';
                          cp = cp + 1;
                          local_520 = HTUnEscape(cr);
                          *cur_argv = local_520;
                          cur_argv = cur_argv + 1;
                          cr = cp;
                        }
                        cp = cp + 1;
                      }
                      local_520 = HTUnEscape(cr);
                      *cur_argv = local_520;
                      cur_argv = cur_argv + 1;
                    }
                    *cur_argv = (char *)0x0;
                    *__argv = pgm;
                    if (LYCgiDocumentRoot != (char *)0x0) {
                      cp = (char *)0x0;
                      HTSACopy(&cp,"DOCUMENT_ROOT=");
                      HTSACat(&cp,LYCgiDocumentRoot);
                      add_environment_value(cp);
                    }
                    if (path_info != (char *)0x0) {
                      cp = (char *)0x0;
                      HTSACopy(&cp,"PATH_INFO=");
                      HTSACat(&cp,path_info);
                      add_environment_value(cp);
                    }
                    if ((LYCgiDocumentRoot != (char *)0x0) && (path_info != (char *)0x0)) {
                      HTSACopy(&document_root,LYCgiDocumentRoot);
                      LYTrimHtmlSep(document_root);
                      path_translated = document_root;
                      HTSACat(&path_translated,path_info);
                      cp = (char *)0x0;
                      HTSACopy(&cp,"PATH_TRANSLATED=");
                      HTSACat(&cp,path_translated);
                      add_environment_value(cp);
                      if (path_translated != (char *)0x0) {
                        free(path_translated);
                        path_translated = (char *)0x0;
                      }
                    }
                    execve(*__argv,__argv,env);
                    piVar5 = __errno_location();
                    __fd2 = *piVar5;
                    if (WWW_TraceFlag != '\0') {
                      piVar5 = __errno_location();
                      local_520 = strerror(*piVar5);
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","execve failed",local_520);
                    }
                    puts("Content-Type: text/plain\r\n\r");
                    if (anAnchor->isHEAD == '\0') {
                      printf("exec of %s failed",pgm);
                      local_520 = strerror(__fd2);
                      printf(": %s.\r\n",local_520);
                    }
                    fflush(stdout);
                    fflush(stderr);
                    // WARNING: Subroutine does not return
                    _exit(1);
                  }
                  local_520 = (char *)gettext("Unable to make connection");
                  HTAlert(local_520);
                  if (WWW_TraceFlag != '\0') {
                    piVar5 = __errno_location();
                    local_520 = strerror(*piVar5);
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","fork() failed",local_520);
                  }
                  close(fd1[0]);
                  close(fd1[1]);
                  close(fd2[0]);
                  close(fd2[1]);
                  status = -1;
                }
                else {
                  close(fd2[1]);
                  if (anAnchor->post_data != (bstring *)0x0) {
                    total_written = 0;
                    close(fd1[0]);
                    if (WWW_TraceFlag != '\0') {
                      if (WWW_TraceFlag != '\0') {
                        sink = (HTStream *)anAnchor->post_content_type;
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"LYNXCGI: Doing post, content-type \'%s\'\n",sink);
                      }
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"LYNXCGI: Writing:\n",sink);
                      }
                      trace_bstring(anAnchor->post_data);
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"----------------------------------\n");
                      }
                    }
                    if (anAnchor->post_data == (bstring *)0x0) {
                      local_50c = 0;
                    }
                    else {
                      local_50c = anAnchor->post_data->len;
                    }
                    remaining = local_50c;
                    do {
                      while( true ) {
                        if (anAnchor->post_data == (bstring *)0x0) {
                          local_504 = (char *)0x0;
                        }
                        else {
                          local_504 = anAnchor->post_data->str;
                        }
                        sVar6 = write(fd1[1],local_504 + total_written,remaining);
                        if (sVar6 == 0) goto LAB_080da45e;
                        if (-1 < sVar6) break;
                        piVar5 = __errno_location();
                        if (*piVar5 != 4) {
                          if (WWW_TraceFlag != '\0') {
                            piVar5 = __errno_location();
                            local_520 = strerror(*piVar5);
                            __stream = TraceFP();
                            fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n",
                                    "write() of POST data failed",local_520);
                          }
                          goto LAB_080da45e;
                        }
                      }
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"LYNXCGI: Wrote %d bytes of POST data.\n",sVar6);
                      }
                      total_written = total_written + sVar6;
                      remaining = remaining - sVar6;
                    } while (remaining != 0);
LAB_080da45e:
                    if ((remaining != 0) && (WWW_TraceFlag != '\0')) {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"LYNXCGI: %d bytes remain unwritten!\n",remaining,
                              local_520);
                    }
                    close(fd1[1]);
                  }
                  total_chars = 0;
                  HTReadProgress(0,0);
                  do {
                    while( true ) {
                      sVar6 = read(fd2[0],buf,0x400);
                      if (sVar6 == 0) goto LAB_080da5fd;
                      if (sVar6 < 0) break;
                      total_chars = total_chars + sVar6;
                      HTReadProgress((longlong)total_chars,0);
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"LYNXCGI: Rx: %.*s\n",sVar6,buf);
                      }
                      (*target->isa->put_block)(target,buf,sVar6);
                    }
                    piVar5 = __errno_location();
                  } while (*piVar5 == 4);
                  if (WWW_TraceFlag != '\0') {
                    piVar5 = __errno_location();
                    local_520 = strerror(*piVar5);
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","read() of CGI output failed",
                            local_520);
                  }
LAB_080da5fd:
                  if ((sVar6 < 0) && (total_chars == 0)) {
                    status = -29999;
                    (*target->isa->_abort)(target,(HTError)0x0);
                    target = (HTStream *)0x0;
                  }
                  else {
                    if (sVar6 == 0) {
                      status = 200;
                    }
                    else {
                      status = 0xce;
                    }
                  }
                  do {
                    _Var7 = waitpid(__pid,(int *)&new_arg,0);
                    if (_Var7 != -1) break;
                    piVar5 = __errno_location();
                  } while (*piVar5 == 4);
                  close(fd2[0]);
                }
              }
            }
LAB_080dadfa:
            if (target != (HTStream *)0x0) {
              (*target->isa->_free)(target);
            }
          }
          else {
            local_520 = (char *)gettext("cgi support has been disabled.");
            HTUserMsg(local_520);
            status = -29999;
          }
        }
        else {
          new_arg = (char *)0x0;
          if (path_info != (char *)0x0) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"%s is not a file and %s not an executable, giving up.\n",
                      local_520,pcVar1);
            }
            if (path_info != (char *)0x0) {
              free(path_info);
              path_info = (char *)0x0;
            }
            if (pgm != (char *)0x0) {
              free(pgm);
              pgm = (char *)0x0;
            }
            if (orig_pgm != (char *)0x0) {
              free(orig_pgm);
              orig_pgm = (char *)0x0;
            }
            local_510 = -4;
            goto LAB_080dae8b;
          }
          LYLocalFileToURL(&new_arg,orig_pgm);
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"%s is not an executable file, passing the buck.\n",arg);
          }
          status = HTLoadFile(new_arg,anAnchor,format_out,sink);
          if (new_arg != (char *)0x0) {
            free(new_arg);
            new_arg = (char *)0x0;
          }
        }
      }
      else {
        local_520 = (char *)gettext("Unable to access cgi script");
        HTAlert(local_520);
        if (WWW_TraceFlag != '\0') {
          piVar5 = __errno_location();
          local_520 = strerror(*piVar5);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYNXCGI: %s: %s\n","stat() failed",local_520);
        }
        status = -4;
      }
LAB_080dae19:
      if (path_info != (char *)0x0) {
        free(path_info);
        path_info = (char *)0x0;
      }
      if (pgm != (char *)0x0) {
        free(pgm);
        pgm = (char *)0x0;
      }
      if (orig_pgm != (char *)0x0) {
        free(orig_pgm);
        orig_pgm = (char *)0x0;
      }
      local_510 = status;
      goto LAB_080dae8b;
    }
  }
  local_520 = (char *)gettext("Bad request!");
  HTAlert(local_520);
  local_510 = -2;
LAB_080dae8b:
  if (__fd2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_510;
}



void final_perror(char *msg,BOOLEAN clean_flag)

{
  int iVar1;
  int *piVar2;
  EVP_PKEY_CTX *local_1c;
  int saved_errno;
  
  piVar2 = __errno_location();
  iVar1 = *piVar2;
  if (LYCursesON != '\0') {
    if (clean_flag == '\0') {
      stop_curses();
    }
    else {
      cleanup(local_1c);
    }
  }
  piVar2 = __errno_location();
  *piVar2 = iVar1;
  perror(msg);
  return;
}



void exit_with_perror(char *msg)

{
  final_perror(msg,'\x01');
  exit_immediately(1);
  return;
}



// WARNING: Could not reconcile some variable overlaps

BOOLEAN lookup_link(char *target)

{
  int iVar1;
  char *msg;
  int result;
  char *line;
  char *buffer;
  FILE *ifp;
  
  buffer = (char *)0x0;
  line = (char *)0x0;
  result._0_1_ = '\0';
  ifp = (FILE *)fopen64("traverse.dat","r");
  if (ifp == (FILE *)0x0) {
    ifp = LYNewTxtFile("traverse.dat");
    if (ifp != (FILE *)0x0) {
      LYCloseOutput(ifp);
      return '\0';
    }
    msg = (char *)gettext("Unable to open traversal file.");
    exit_with_perror(msg);
  }
  HTSprintf0(&line,"%s\n",target);
  do {
    msg = LYSafeGets(&buffer,ifp);
    if (msg == (char *)0x0) goto LAB_080dafe5;
    iVar1 = strcmp(line,buffer);
  } while (iVar1 != 0);
  result._0_1_ = '\x01';
LAB_080dafe5:
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  if (buffer != (char *)0x0) {
    free(buffer);
    buffer = (char *)0x0;
  }
  LYCloseInput(ifp);
  return (BOOLEAN)result;
}



void add_to_table(char *target)

{
  FILE *fp;
  char *msg;
  FILE *ifp;
  
  fp = LYAppendToTxtFile("traverse.dat");
  if (fp == (FILE *)0x0) {
    msg = (char *)gettext("Unable to open traversal file.");
    exit_with_perror(msg);
  }
  fprintf((FILE *)fp,"%s\n",target);
  LYCloseOutput(fp);
  return;
}



void add_to_traverse_list(char *fname,char *prev_link_name)

{
  FILE *fp;
  char *msg;
  FILE *ifp;
  
  fp = LYAppendToTxtFile("traverse2.dat");
  if (fp == (FILE *)0x0) {
    msg = (char *)gettext("Unable to open traversal found file.");
    exit_with_perror(msg);
  }
  fprintf((FILE *)fp,"%s\t%s\n",fname,prev_link_name);
  LYCloseOutput(fp);
  return;
}



void dump_traversal_history(void)

{
  FILE *fp;
  char *msg;
  undefined4 uVar1;
  undefined4 uVar2;
  FILE *ifp;
  int x;
  
  if (0 < nhist) {
    fp = LYAppendToTxtFile("traverse.dat");
    if (fp == (FILE *)0x0) {
      msg = (char *)gettext("Unable to open traversal file.");
      final_perror(msg,'\0');
    }
    else {
      uVar1 = gettext("here is a list of the history stack so that you may rebuild");
      uVar2 = gettext("TRAVERSAL WAS INTERRUPTED");
      fprintf((FILE *)fp,"\n\n%s\n\n\t    %s\n\n",uVar2,uVar1);
      x = nhist;
      while (x = x + -1, -1 < x) {
        fprintf((FILE *)fp,"%s\t%s\n",history[x].hdoc.title,history[x].hdoc.address);
      }
      LYCloseOutput(fp);
    }
  }
  return;
}



void add_to_reject_list(char *target)

{
  FILE *fp;
  char *msg;
  FILE *ifp;
  
  if (WWW_TraceFlag != '\0') {
    fp = TraceFP();
    fprintf((FILE *)fp,"add_to_reject_list(%s)\n",target);
  }
  fp = LYAppendToTxtFile("reject.dat");
  if (fp == (FILE *)0x0) {
    msg = (char *)gettext("Unable to open reject file.");
    exit_with_perror(msg);
  }
  fprintf((FILE *)fp,"%s\n",target);
  LYCloseOutput(fp);
  return;
}



BOOLEAN lookup_reject(char *target)

{
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  FILE *fp;
  int result;
  int len;
  char *line;
  char *buffer;
  FILE *ifp;
  
  buffer = (char *)0x0;
  line = (char *)0x0;
  result = 0;
  fp = (FILE *)fopen64("reject.dat","r");
  if (fp == (FILE *)0x0) {
    return '\0';
  }
  HTSprintf0(&line,"%s",target);
  while ((pcVar3 = LYSafeGets(&buffer,fp), pcVar3 != (char *)0x0 && (result == 0))) {
    LYTrimTrailing(buffer);
    sVar1 = strlen(buffer);
    if (0 < (int)sVar1) {
      if (buffer[sVar1 - 1] == '*') {
        if ((sVar1 == 1) || (iVar2 = strncmp(line,buffer,sVar1 - 1), iVar2 == 0)) {
          result = 1;
        }
      }
      else {
        iVar2 = strcmp(line,buffer);
        if (iVar2 == 0) {
          result = 1;
        }
      }
    }
  }
  if (buffer != (char *)0x0) {
    free(buffer);
    buffer = (char *)0x0;
  }
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  LYCloseInput(fp);
  if (WWW_TraceFlag != '\0') {
    fp = TraceFP();
    fprintf((FILE *)fp,"lookup_reject(%s) -> %d\n",target,result);
  }
  return (BOOLEAN)result;
}



int EditBinding(int xlkc)

{
  uint uVar1;
  uint local_28;
  uint local_24;
  int local_20;
  int local_1c;
  int local_18;
  int c;
  int xleac;
  int editaction;
  
  uVar1 = xlkc & 0x7ff;
  if (xlkc == -1) {
    local_28 = 0;
  }
  else {
    if ((xlkc & 0x8000U) == 0) {
      if ((xlkc & 0x4000U) == 0) {
        if ((xlkc & 0x2000U) == 0) {
          if ((xlkc & 0x1000U) == 0) {
            xleac = ZEXT14(LYLineEditors[current_lineedit][uVar1]);
          }
          else {
            if (uVar1 < 0x112) {
              local_18 = (int)Mod3Binding[uVar1];
            }
            else {
              local_18 = 0x1f;
            }
            xleac = local_18;
          }
        }
        else {
          if (uVar1 < 0x112) {
            local_1c = (int)Mod2Binding[uVar1];
          }
          else {
            local_1c = 0x1f;
          }
          xleac = local_1c;
        }
      }
      else {
        if (uVar1 < 0x112) {
          local_20 = (int)Mod1Binding[uVar1];
        }
        else {
          local_20 = 0x1f;
        }
        xleac = local_20;
      }
      if (xleac == 0x1f) {
        editaction = ZEXT14(LYLineEditors[current_lineedit][uVar1]);
      }
      else {
        editaction = xleac;
      }
      local_28 = editaction;
    }
    else {
      if ((xlkc == -1) || ((xlkc & 0x8000U) == 0)) {
        local_24 = xlkc;
      }
      else {
        local_24 = (int)(xlkc & 0xffff7fffU) >> 8 & 0xff;
      }
      local_28 = local_24;
    }
  }
  return local_28;
}



BOOLEAN LYRemapEditBinding(int xlkc,int lec,int select_edi)

{
  uint uVar1;
  short sVar2;
  BOOLEAN local_15;
  int c;
  int j;
  BOOLEAN success;
  
  uVar1 = xlkc & 0x7ff;
  success = '\0';
  if (((xlkc < 0) || ((xlkc & 0x800U) != 0)) || (0x295 < uVar1)) {
    local_15 = '\0';
  }
  else {
    sVar2 = (short)lec;
    if ((xlkc & 0x4000U) == 0) {
      if ((xlkc & 0x2000U) == 0) {
        if ((xlkc & 0x1000U) == 0) {
          if ((uint)lec < 0x100) {
            if (select_edi < 1) {
              j = 0;
              while (LYLineeditNames[j] != (char *)0x0) {
                success = '\x01';
                if ((-1 < select_edi) || (j + 1 + select_edi != 0)) {
                  LYLineEditors[j][uVar1] = (LYEditCode)lec;
                }
                j = j + 1;
              }
            }
            else {
              if ((uint)select_edi < 3) {
                LYLineEditors[select_edi + -1][uVar1] = (LYEditCode)lec;
                success = '\x01';
              }
            }
            local_15 = success;
          }
          else {
            local_15 = '\0';
          }
        }
        else {
          if (uVar1 < 0x112) {
            Mod3Binding[uVar1] = sVar2;
            local_15 = '\x01';
          }
          else {
            local_15 = '\0';
          }
        }
      }
      else {
        if (uVar1 < 0x112) {
          Mod2Binding[uVar1] = sVar2;
          local_15 = '\x01';
        }
        else {
          local_15 = '\0';
        }
      }
    }
    else {
      if (uVar1 < 0x112) {
        Mod1Binding[uVar1] = sVar2;
        local_15 = '\x01';
      }
      else {
        local_15 = '\0';
      }
    }
  }
  return local_15;
}



int LYKeyForEditAction(int lec)

{
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int i;
  int editaction;
  
  i = 0x61;
  while( true ) {
    if (i < 0) {
      return -1;
    }
    if ((uint)LYLineEditors[current_lineedit][i] == lec) break;
    if (i == 0x7a) {
      local_2c = 0x20;
    }
    else {
      if (i == 0x60) {
        local_28 = 0x7b;
      }
      else {
        if (i == 0x7e) {
          local_24 = 0;
        }
        else {
          if (i == 0x1f) {
            local_20 = 0x100;
          }
          else {
            if (i == 0x293) {
              local_1c = 0x7f;
            }
            else {
              if (i == 0xff) {
                local_18 = -1;
              }
              else {
                local_18 = i + 1;
              }
              local_1c = local_18;
            }
            local_20 = local_1c;
          }
          local_24 = local_20;
        }
        local_28 = local_24;
      }
      local_2c = local_28;
    }
    i = local_2c;
  }
  return i;
}



int LYEditKeyForAction(int lac,int *pmodkey)

{
  byte bVar1;
  uint uVar2;
  uint local_c4;
  uint local_c0;
  uint local_bc;
  uint local_b8;
  int local_b4;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  int local_a0;
  uint local_9c;
  uint local_98;
  uint local_94;
  uint local_90;
  int local_8c;
  int local_88;
  int local_84;
  int local_80;
  int local_7c;
  int local_78;
  uint local_74;
  uint local_70;
  uint local_6c;
  uint local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int mod3found;
  int mod2found;
  int mod1found;
  int c;
  int i;
  int editaction;
  
  mod1found = -1;
  mod2found = -1;
  mod3found = -1;
  if (pmodkey != (int *)0x0) {
    *pmodkey = -1;
  }
  i = 0x61;
  while (-1 < i) {
    bVar1 = LYLineEditors[current_lineedit][i];
    if ((lac | 0x1000U) == (uint)bVar1) {
      return i;
    }
    if (bVar1 == 6) {
      if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
        if (i == -1) {
          local_c4 = (uint)key_override[0];
        }
        else {
          if ((i & 0x8800U) == 0) {
            local_c0 = (uint)key_override[(i & 0x7ffU) + 1];
          }
          else {
            local_c0 = i & 0xff;
          }
          local_c4 = local_c0;
        }
        if (local_c4 == lac) {
          return i;
        }
      }
      if (i == -1) {
        local_bc = (uint)keymap[0];
      }
      else {
        if ((i & 0x8800U) == 0) {
          local_b8 = (uint)keymap[(i & 0x7ffU) + 1];
        }
        else {
          local_b8 = i & 0xff;
        }
        local_bc = local_b8;
      }
      if (local_bc == lac) {
        return i;
      }
    }
    if (bVar1 == 3) {
      if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) &&
         ((lac != 0 && ((uint)key_override[10] == lac)))) {
        return i;
      }
      if ((uint)keymap[10] == lac) {
        return i;
      }
    }
    if ((bVar1 == 0x1d) && (mod1found < 0)) {
      mod1found = i;
    }
    if ((bVar1 == 0x1e) && (mod2found < 0)) {
      mod2found = i;
    }
    if (((bVar1 & 0x80) != 0) && (mod3found < 0)) {
      mod3found = i;
    }
    if (i == 0x7a) {
      local_b4 = 0x20;
    }
    else {
      if (i == 0x60) {
        local_b0 = 0x7b;
      }
      else {
        if (i == 0x7e) {
          local_ac = 0;
        }
        else {
          if (i == 0x1f) {
            local_a8 = 0x100;
          }
          else {
            if (i == 0x293) {
              local_a4 = 0x7f;
            }
            else {
              if (i == 0xff) {
                local_a0 = -1;
              }
              else {
                local_a0 = i + 1;
              }
              local_a4 = local_a0;
            }
            local_a8 = local_a4;
          }
          local_ac = local_a8;
        }
        local_b0 = local_ac;
      }
      local_b4 = local_b0;
    }
    i = local_b4;
  }
  if (-1 < mod3found) {
    i = mod3found;
    while (-1 < i) {
      if ((LYLineEditors[current_lineedit][i] & 0x80) != 0) {
        uVar2 = SEXT24(Mod3Binding[i]);
        if (pmodkey != (int *)0x0) {
          *pmodkey = i;
        }
        if ((lac | 0x1000U) == uVar2) {
          return i | 0x1000;
        }
        if (uVar2 == 6) {
          if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
            if (i == -1) {
              local_9c = (uint)key_override[0];
            }
            else {
              if ((i & 0x8800U) == 0) {
                local_98 = (uint)key_override[(i & 0x7ffU) + 1];
              }
              else {
                local_98 = i & 0xff;
              }
              local_9c = local_98;
            }
            if (local_9c == lac) {
              return i | 0x1000;
            }
          }
          if (i == -1) {
            local_94 = (uint)keymap[0];
          }
          else {
            if ((i & 0x8800U) == 0) {
              local_90 = (uint)keymap[(i & 0x7ffU) + 1];
            }
            else {
              local_90 = i & 0xff;
            }
            local_94 = local_90;
          }
          if (local_94 == lac) {
            return i | 0x1000;
          }
        }
        if (uVar2 == 3) {
          if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) &&
             ((lac != 0 && ((uint)key_override[10] == lac)))) {
            return i | 0x1000;
          }
          if ((uint)keymap[10] == lac) {
            return i | 0x1000;
          }
        }
      }
      if (i == 0x7a) {
        local_8c = 0x20;
      }
      else {
        if (i == 0x60) {
          local_88 = 0x7b;
        }
        else {
          if (i == 0x7e) {
            local_84 = 0;
          }
          else {
            if (i == 0x1f) {
              local_80 = 0x100;
            }
            else {
              if (i == 0x111) {
                local_7c = 0x7f;
              }
              else {
                if (i == 0xff) {
                  local_78 = -1;
                }
                else {
                  local_78 = i + 1;
                }
                local_7c = local_78;
              }
              local_80 = local_7c;
            }
            local_84 = local_80;
          }
          local_88 = local_84;
        }
        local_8c = local_88;
      }
      i = local_8c;
    }
  }
  if (-1 < mod1found) {
    if (pmodkey != (int *)0x0) {
      *pmodkey = mod1found;
    }
    i = 0x61;
    while (-1 < i) {
      uVar2 = SEXT24(Mod1Binding[i]);
      if ((lac | 0x1000U) == uVar2) {
        return i | 0x4000;
      }
      if (uVar2 == 6) {
        if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
          if (i == -1) {
            local_74 = (uint)key_override[0];
          }
          else {
            if ((i & 0x8800U) == 0) {
              local_70 = (uint)key_override[(i & 0x7ffU) + 1];
            }
            else {
              local_70 = i & 0xff;
            }
            local_74 = local_70;
          }
          if (local_74 == lac) {
            return i | 0x4000;
          }
        }
        if (i == -1) {
          local_6c = (uint)keymap[0];
        }
        else {
          if ((i & 0x8800U) == 0) {
            local_68 = (uint)keymap[(i & 0x7ffU) + 1];
          }
          else {
            local_68 = i & 0xff;
          }
          local_6c = local_68;
        }
        if (local_6c == lac) {
          return i | 0x4000;
        }
      }
      if (uVar2 == 3) {
        if ((((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) &&
           ((uint)key_override[10] == lac)) {
          return i | 0x4000;
        }
        if ((uint)keymap[10] == lac) {
          return i | 0x4000;
        }
      }
      if (i == 0x7a) {
        local_64 = 0x20;
      }
      else {
        if (i == 0x60) {
          local_60 = 0x7b;
        }
        else {
          if (i == 0x7e) {
            local_5c = 0;
          }
          else {
            if (i == 0x1f) {
              local_58 = 0x100;
            }
            else {
              if (i == 0x111) {
                local_54 = 0x7f;
              }
              else {
                if (i == 0xff) {
                  local_50 = -1;
                }
                else {
                  local_50 = i + 1;
                }
                local_54 = local_50;
              }
              local_58 = local_54;
            }
            local_5c = local_58;
          }
          local_60 = local_5c;
        }
        local_64 = local_60;
      }
      i = local_64;
    }
  }
  if (-1 < mod2found) {
    if (pmodkey != (int *)0x0) {
      *pmodkey = mod1found;
    }
    i = 0x61;
    while (-1 < i) {
      uVar2 = SEXT24(Mod2Binding[i]);
      if ((lac | 0x1000U) == uVar2) {
        return i | 0x2000;
      }
      if (uVar2 == 6) {
        if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
          if (i == -1) {
            local_4c = (uint)key_override[0];
          }
          else {
            if ((i & 0x8800U) == 0) {
              local_48 = (uint)key_override[(i & 0x7ffU) + 1];
            }
            else {
              local_48 = i & 0xff;
            }
            local_4c = local_48;
          }
          if (local_4c == lac) {
            return i | 0x2000;
          }
        }
        if (i == -1) {
          local_44 = (uint)keymap[0];
        }
        else {
          if ((i & 0x8800U) == 0) {
            local_40 = (uint)keymap[(i & 0x7ffU) + 1];
          }
          else {
            local_40 = i & 0xff;
          }
          local_44 = local_40;
        }
        if (local_44 == lac) {
          return i | 0x2000;
        }
      }
      if (uVar2 == 3) {
        if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) &&
           ((lac != 0 && ((uint)key_override[10] == lac)))) {
          return i | 0x2000;
        }
        if ((uint)keymap[10] == lac) {
          return i | 0x2000;
        }
      }
      if (i == 0x7a) {
        local_3c = 0x20;
      }
      else {
        if (i == 0x60) {
          local_38 = 0x7b;
        }
        else {
          if (i == 0x7e) {
            local_34 = 0;
          }
          else {
            if (i == 0x1f) {
              local_30 = 0x100;
            }
            else {
              if (i == 0x111) {
                local_2c = 0x7f;
              }
              else {
                if (i == 0xff) {
                  local_28 = -1;
                }
                else {
                  local_28 = i + 1;
                }
                local_2c = local_28;
              }
              local_30 = local_2c;
            }
            local_34 = local_30;
          }
          local_38 = local_34;
        }
        local_3c = local_38;
      }
      i = local_3c;
    }
  }
  if (pmodkey != (int *)0x0) {
    *pmodkey = -1;
  }
  return -1;
}



int LYEditmapDeclared(void)

{
  int status;
  
  return 1;
}



void HTMLSetCharacterHandling(int i)

{
  char *__s1;
  int iVar1;
  BOOLEAN BVar2;
  int iVar3;
  int iVar4;
  FILE *__stream;
  BOOLEAN local_24;
  undefined *local_20;
  undefined *local_1c;
  char *mime;
  int UCLYhndl_for_unspec_flag;
  int chndl;
  BOOLEAN LYRawMode_flag;
  
  iVar3 = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
  BVar2 = LYRawMode;
  iVar1 = UCLYhndl_for_unspec;
  if (LYCharSet_UC[i].enc == 5) {
    __s1 = LYCharSet_UC[i].MIMEname;
    iVar4 = strcmp(__s1,"euc-cn");
    if (iVar4 == 0) {
      HTCJK = CHINESE;
      kanji_code = EUC;
    }
    else {
      iVar4 = strcmp(__s1,"euc-jp");
      if (iVar4 == 0) {
        HTCJK = JAPANESE;
        kanji_code = EUC;
      }
      else {
        iVar4 = strcmp(__s1,"shift_jis");
        if (iVar4 == 0) {
          HTCJK = JAPANESE;
          kanji_code = SJIS;
        }
        else {
          iVar4 = strcmp(__s1,"euc-kr");
          if (iVar4 == 0) {
            HTCJK = KOREAN;
            kanji_code = EUC;
          }
          else {
            iVar4 = strcmp(__s1,"big5");
            if (iVar4 == 0) {
              HTCJK = TAIPEI;
              kanji_code = EUC;
            }
          }
        }
      }
    }
    if (LYUseDefaultRawMode == '\0') {
      HTCJK = NOCJK;
    }
    LYRawMode = HTCJK != NOCJK;
    HTPassEightBitRaw = '\0';
    HTPassEightBitNum = '\0';
    HTPassHighCtrlRaw = HTCJK != NOCJK;
  }
  else {
    HTCJK = NOCJK;
    kanji_code = NOKANJI;
    if (i == iVar3) {
      LYRawMode = LYUseDefaultRawMode;
    }
    else {
      LYRawMode = LYUseDefaultRawMode == '\0';
    }
    if ((((uint)(&LYCharSet_UC[0].MIMEname)[(i * 2 + 1) * 4] & 2) == 0) &&
       (((&LYCharSet_UC[0].codepage)[(i * 2 + 1) * 4] & 0x100U) == 0)) {
      local_24 = '\0';
    }
    else {
      local_24 = '\x01';
    }
    HTPassEightBitNum = local_24;
    if (LYRawMode == '\0') {
      HTPassEightBitRaw = '\0';
      if (i != iVar3) {
        HTPassHighCtrlRaw = '\0';
        goto LAB_080dc462;
      }
    }
    else {
      HTPassEightBitRaw = LYlowest_eightbit[i] < 0xa1;
    }
    HTPassHighCtrlRaw = LYlowest_eightbit[i] < 0x83;
  }
LAB_080dc462:
  HTPassHighCtrlNum = '\0';
  if (LYRawMode == '\0') {
    if ((iVar3 == i) ||
       ((UCLYhndl_for_unspec = iVar3, LYCharSet_UC[i].enc == 5 && (LYCharSet_UC[iVar3].enc == 5))))
    {
      UCLYhndl_for_unspec = LATIN1;
    }
  }
  else {
    UCLYhndl_for_unspec = i;
  }
  ena_csi(0x9b < LYlowest_eightbit[current_char_set]);
  if (WWW_TraceFlag != '\0') {
    if ((BVar2 != LYRawMode) && (WWW_TraceFlag != '\0')) {
      if (LYRawMode == '\0') {
        local_20 = &DAT_0816980b;
      }
      else {
        local_20 = &DAT_08169808;
      }
      if (BVar2 == '\0') {
        local_1c = &DAT_0816980b;
      }
      else {
        local_1c = &DAT_08169808;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMLSetCharacterHandling: LYRawMode changed %s -> %s\n",local_1c,
              local_20);
    }
    iVar3 = UCLYhndl_for_unspec;
    if ((iVar1 != UCLYhndl_for_unspec) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMLSetCharacterHandling: UCLYhndl_for_unspec changed %d -> %d\n",
              iVar1,iVar3);
    }
  }
  return;
}



void Set_HTCJK(char *inMIMEname,char *outMIMEname)

{
  int iVar1;
  
  if (LYRawMode == '\0') {
    HTCJK = NOCJK;
    return;
  }
  iVar1 = strcmp(inMIMEname,"euc-jp");
  if ((((iVar1 == 0) || (iVar1 = strcmp(inMIMEname,"utf-8"), iVar1 == 0)) ||
      (iVar1 = strcmp(inMIMEname,"shift_jis"), iVar1 == 0)) &&
     ((iVar1 = strcmp(outMIMEname,"euc-jp"), iVar1 == 0 ||
      (iVar1 = strcmp(outMIMEname,"shift_jis"), iVar1 == 0)))) {
    HTCJK = JAPANESE;
  }
  else {
    iVar1 = strcmp(inMIMEname,"euc-cn");
    if ((iVar1 == 0) && (iVar1 = strcmp(outMIMEname,"euc-cn"), iVar1 == 0)) {
      HTCJK = CHINESE;
      return;
    }
    iVar1 = strcmp(inMIMEname,"big5");
    if ((iVar1 == 0) && (iVar1 = strcmp(outMIMEname,"big5"), iVar1 == 0)) {
      HTCJK = TAIPEI;
      return;
    }
    iVar1 = strcmp(inMIMEname,"euc-kr");
    if ((iVar1 == 0) && (iVar1 = strcmp(outMIMEname,"euc-kr"), iVar1 == 0)) {
      HTCJK = KOREAN;
      return;
    }
    HTCJK = NOCJK;
  }
  return;
}



void HTMLSetRawModeDefault(int i)

{
  LYDefaultRawMode = LYCharSet_UC[i].enc == 5;
  return;
}



void HTMLSetUseDefaultRawMode(int i,BOOLEAN modeflag)

{
  int iVar1;
  int chndl;
  
  if (LYCharSet_UC[i].enc == 5) {
    LYUseDefaultRawMode = modeflag;
  }
  else {
    iVar1 = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
    LYUseDefaultRawMode = modeflag;
    if (i != iVar1) {
      LYUseDefaultRawMode = modeflag == '\0';
    }
  }
  return;
}



void HTMLSetHaveCJKCharacterSet(int i)

{
  LYHaveCJKCharacterSet = LYCharSet_UC[i].enc == 5;
  return;
}



void HTMLSetDisplayCharsetMatchLocale(int i)

{
  int iVar1;
  BOOLEAN match;
  
  if (LYHaveCJKCharacterSet == '\0') {
    iVar1 = strncasecomp(LYCharSet_UC[i].MIMEname,"cp",2);
    if ((iVar1 == 0) && (iVar1 = strncasecomp(LYCharSet_UC[i].MIMEname,"windows",7), iVar1 == 0)) {
      match = '\x01';
      if (UCForce8bitTOUPPER != '\0') {
        match = '\0';
      }
    }
    else {
      match = '\0';
    }
    DisplayCharsetMatchLocale = match;
    return;
  }
  DisplayCharsetMatchLocale = '\x01';
  return;
}



int UCGetLYhndl_byAnyName(char *value)

{
  FILE *__stream;
  int iVar1;
  int local_18;
  int i;
  
  LYTrimTrailing(value);
  if (value == (char *)0x0) {
    local_18 = -1;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UCGetLYhndl_byAnyName(%s)\n",value);
    }
    i = 0;
    while ((i < 0x3c && (LYchar_set_names[i] != (char *)0x0))) {
      iVar1 = strcmp(value,LYchar_set_names[i]);
      if (iVar1 == 0) {
        return i;
      }
      i = i + 1;
    }
    i = 0;
    while (OLD_charset_names[i].fullname != (char *)0x0) {
      iVar1 = strcmp(value,OLD_charset_names[i].fullname);
      if (iVar1 == 0) {
        iVar1 = UCGetLYhndl_byMIME(OLD_charset_names[i].MIMEname);
        return iVar1;
      }
      i = i + 1;
    }
    local_18 = UCGetLYhndl_byMIME(value);
  }
  return local_18;
}



char * HTMLGetEntityName(UCode_t code)

{
  char *local_18;
  int MaxValue;
  
  if ((code < 0) || (0x5f < code)) {
    local_18 = "";
  }
  else {
    local_18 = LYEntityNames[code];
  }
  return local_18;
}



UCode_t HTMLGetEntityUCValue(char *name)

{
  UC_entity_info unicode_entities [996];
  size_t sVar1;
  int iVar2;
  UCode_t local_28;
  size_t number_of_unicode_entities;
  int diff;
  size_t low;
  size_t high;
  size_t i;
  UCode_t value;
  
  value = 0;
  if ((name == (char *)0x0) || (*name == '\0')) {
    local_28 = 0;
  }
  else {
    low = 0;
    high = 0x3e4;
    sVar1 = high;
    while (high = sVar1, low < high) {
      sVar1 = (high - low >> 1) + low;
      iVar2 = strcmp(((UC_entity_info *)&ram0x0816b4e0)[sVar1].name,name);
      if (iVar2 == 0) {
        value = ZEXT24(*(ushort *)(sVar1 * 8 + 0x816b4e4));
        break;
      }
      if (iVar2 < 0) {
        low = sVar1 + 1;
        sVar1 = high;
      }
    }
    local_28 = value;
  }
  return local_28;
}



void HTMLUseCharacterSet(int i)

{
  HTMLSetRawModeDefault(i);
  p_entity_values = LYCharSets[i];
  HTMLSetCharacterHandling(i);
  HTMLSetHaveCJKCharacterSet(i);
  HTMLSetDisplayCharsetMatchLocale(i);
  return;
}



int LYCharSetsDeclared(void)

{
  UCInit();
  return UCInitialized;
}



void LYEntify(char **str,BOOLEAN isTITLE)

{
  bool bVar1;
  bool bVar2;
  size_t sVar3;
  char *pcVar4;
  int in_sjis;
  _state state;
  int gts;
  int lts;
  int amps;
  char *cp;
  char *q;
  char *p;
  
  p = *str;
  amps = 0;
  lts = 0;
  gts = 0;
  state = S_text;
  bVar1 = false;
  if ((p != (char *)0x0) && (*p != '\0')) {
    while ((*p != '\0' && (p = strchr(p,0x26), p != (char *)0x0))) {
      amps = amps + 1;
      p = p + 1;
    }
    if (isTITLE == '\x01') {
      p = *str;
      while ((*p != '\0' && (p = strchr(p,0x3c), p != (char *)0x0))) {
        lts = lts + 1;
        p = p + 1;
      }
    }
    if (isTITLE == '\x01') {
      p = *str;
      while ((*p != '\0' && (p = strchr(p,0x3e), p != (char *)0x0))) {
        gts = gts + 1;
        p = p + 1;
      }
    }
    if (((amps != 0) || (lts != 0)) || (gts != 0)) {
      sVar3 = strlen(*str);
      pcVar4 = (char *)calloc(sVar3 + lts * 3 + amps * 4 + gts * 3 + 1,1);
      if (pcVar4 == (char *)0x0) {
        outofmem("./LYCharUtils.c","LYEntify");
      }
      p = *str;
      q = pcVar4;
      while (*p != '\0') {
        if (HTCJK == NOCJK) {
LAB_080dcf24:
          if (*p == '&') {
            *q = '&';
            q[1] = 'a';
            q[2] = 'm';
            q[3] = 'p';
            q[4] = ';';
            q = q + 5;
          }
          else {
            if ((isTITLE == '\0') || (*p != '<')) {
              if ((isTITLE == '\0') || (*p != '>')) {
                *q = *p;
                q = q + 1;
              }
              else {
                *q = '&';
                q[1] = 'g';
                q[2] = 't';
                q[3] = ';';
                q = q + 4;
              }
            }
            else {
              *q = '&';
              q[1] = 'l';
              q[2] = 't';
              q[3] = ';';
              q = q + 4;
            }
          }
        }
        else {
          switch(state) {
          case S_text:
            if (*p != '\x1b') goto switchD_080dcc08_caseD_6;
            state = S_esc;
            *q = *p;
            q = q + 1;
            break;
          case S_esc:
            if (*p == '$') {
              state = S_dollar;
              *q = *p;
              q = q + 1;
            }
            else {
              if (*p == '(') {
                state = S_paren;
                *q = *p;
                q = q + 1;
              }
              else {
                state = S_text;
                *q = *p;
                q = q + 1;
              }
            }
            break;
          case S_dollar:
            if (((*p == '@') || (*p == 'B')) || (*p == 'A')) {
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
            }
            else {
              if (*p == '(') {
                state = S_dollar_paren;
                *q = *p;
                q = q + 1;
              }
              else {
                state = S_text;
                *q = *p;
                q = q + 1;
              }
            }
            break;
          case S_paren:
            if (((*p == 'B') || (*p == 'J')) || (*p == 'T')) {
              state = S_text;
              *q = *p;
              q = q + 1;
            }
            else {
              if (*p != 'I') goto switchD_080dcc08_caseD_4;
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
            }
            break;
          case S_nonascii_text:
switchD_080dcc08_caseD_4:
            if (*p == '\x1b') {
              state = S_esc;
            }
            *q = *p;
            q = q + 1;
            break;
          case S_dollar_paren:
            if (*p == 'C') {
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
            }
            else {
              state = S_text;
              *q = *p;
              q = q + 1;
            }
            break;
          default:
switchD_080dcc08_caseD_6:
            if (p[1] == '\0') goto LAB_080dcf24;
            if ((((((byte)*p < 0xa1) || (*p == -1)) || ((byte)p[1] < 0xa1)) || (p[1] == -1)) &&
               (((*p != -0x72 || ((byte)p[1] < 0xa1)) || (0xdf < (byte)p[1])))) {
              if ((((byte)p[1] < 0x40) || (p[1] == '\x7f')) || (0xfc < (byte)p[1])) {
LAB_080dceb5:
                if ((((byte)*p < 0xa1) || (*p == -1)) ||
                   ((((byte)p[1] < 0x40 || (0x7e < (byte)p[1])) &&
                    (((byte)p[1] < 0xa1 || (p[1] == -1)))))) goto LAB_080dcf24;
              }
              else {
                if (((byte)*p < 0x81) || (0x9f < (byte)*p)) {
                  if ((bVar1) && ((0xdf < (byte)*p && ((byte)*p < 0xf0)))) {
                    bVar2 = true;
                  }
                  else {
                    bVar2 = false;
                  }
                  if (!bVar2) goto LAB_080dceb5;
                }
                else {
                  bVar1 = true;
                }
              }
            }
            *q = *p;
            p = p + 1;
            q[1] = *p;
            q = q + 2;
          }
        }
        p = p + 1;
      }
      *q = '\0';
      if (*str != (char *)0x0) {
        free(*str);
        *str = (char *)0x0;
      }
      *str = pcVar4;
    }
  }
  return;
}



void LYTrimHead(char *str)

{
  char *ns;
  char *s;
  
  s = str;
  if ((str != (char *)0x0) && (*str != '\0')) {
    while ((*s != '\0' && (((byte)*s < 0x21 && (*s != '\x1b'))))) {
      s = s + 1;
    }
    if (str < s) {
      ns = str;
      while (*s != '\0') {
        *ns = *s;
        ns = ns + 1;
        s = s + 1;
      }
      *ns = '\0';
    }
  }
  return;
}



void LYTrimTail(char *str)

{
  int i;
  
  if ((str != (char *)0x0) && (*str != '\0')) {
    i = strlen(str);
    while ((i = i - 1, -1 < i && ((byte)str[i] < 0x21))) {
      str[i] = '\0';
    }
  }
  return;
}



char * LYFindEndOfComment(char *str)

{
  int iVar1;
  char *local_18;
  comment_state state;
  char *cp1;
  char *cp;
  
  if (str == (char *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    iVar1 = strncmp(str,"<!--",4);
    if (iVar1 == 0) {
      cp = str + 4;
      local_18 = cp;
      if (*cp != '>') {
        local_18 = strchr(cp,0x3e);
        if (local_18 == (char *)0x0) {
          local_18 = str;
        }
        else {
          if (*cp != '-') {
            state = start2;
            while (*cp != '\0') {
              if (state == start2) {
                if (*cp == '-') {
                  state = end1;
                }
              }
              else {
                if (state == start1) {
                  if (*cp != '-') {
                    return local_18;
                  }
                  state = start2;
                }
                else {
                  if (state == end1) {
                    if (*cp != '-') {
                      return local_18;
                    }
                    state = end2;
                  }
                  else {
                    if (state == end2) {
                      if (*cp == '>') {
                        return cp;
                      }
                      if (*cp == '-') {
                        state = start1;
                      }
                      else {
                        if (0x20 < (byte)*cp) {
                          return local_18;
                        }
                        if (*cp == '\x1b') {
                          return local_18;
                        }
                      }
                    }
                  }
                }
              }
              cp = cp + 1;
            }
          }
        }
      }
    }
    else {
      local_18 = str;
    }
  }
  return local_18;
}



void LYFillLocalFileURL(char **href,char *base)

{
  int iVar1;
  int iVar2;
  char *pathname;
  char *pcVar3;
  int in_GS_OFFSET;
  char *temp2;
  char *temp;
  char curdir [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  temp = (char *)0x0;
  if ((*href == (char *)0x0) || (**href == '\0')) goto LAB_080dd617;
  iVar2 = strcmp(*href,"//");
  if (iVar2 == 0) {
LAB_080dd2f5:
    if ((base != (char *)0x0) && ((*base == 'f' || (*base == 'F')))) {
      iVar2 = strncasecomp(base,"file:",5);
      if (iVar2 == 0) {
        HTSACopy(&temp,"file:");
        HTSACat(&temp,*href);
        HTSACopy(href,temp);
      }
    }
  }
  else {
    iVar2 = strncmp(*href,"///",3);
    if (iVar2 == 0) goto LAB_080dd2f5;
  }
  if ((**href == 'f') || (**href == 'F')) {
    iVar2 = strncasecomp(*href,"file:",5);
    if (iVar2 == 0) {
      if ((*href)[5] == '\0') {
        HTSACat(href,"//localhost");
      }
      else {
        iVar2 = strcmp(*href,"file://");
        if (iVar2 == 0) {
          HTSACat(href,"localhost");
        }
        else {
          iVar2 = strncmp(*href,"file:///",8);
          if (iVar2 == 0) {
            HTSACopy(&temp,*href + 7);
            LYLocalFileToURL(href,temp);
          }
          else {
            iVar2 = strncmp(*href,"file:/",6);
            if ((iVar2 == 0) && ((*href)[6] != '/')) {
              HTSACopy(&temp,*href + 5);
              LYLocalFileToURL(href,temp);
            }
          }
        }
      }
    }
  }
  iVar2 = strcmp(*href,"file://localhost");
  if (iVar2 == 0) {
    pathname = Current_Dir(curdir);
    pathname = wwwName(pathname);
    if (*pathname != '/') {
      LYAddHtmlSep(href);
    }
    pcVar3 = strchr(pathname,0x25);
    if (pcVar3 == (char *)0x0) {
      pcVar3 = strchr(pathname,0x23);
      if (pcVar3 == (char *)0x0) {
        HTSACat(href,pathname);
        goto LAB_080dd5f5;
      }
    }
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
    temp = HTEscape(pathname,'\x04');
    HTSACat(href,temp);
  }
LAB_080dd5f5:
  if (temp != (char *)0x0) {
    free(temp);
    temp = (char *)0x0;
  }
LAB_080dd617:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void LYAddMETAcharsetToFD(FILE *fd,int disp_chndl)

{
  if (disp_chndl == -1) {
    disp_chndl = current_char_set;
  }
  if ((((fd != (FILE *)0x0) && (-1 < disp_chndl)) && (UCLYhndl_HTFile_for_unspec != disp_chndl)) &&
     (LYCharSet_UC[disp_chndl].enc != 0)) {
    fprintf((FILE *)fd,"<META %s content=\"text/html;charset=%s\">\n","http-equiv=\"content-type\"",
            LYCharSet_UC[disp_chndl].MIMEname);
  }
  return;
}



char * LYUppercaseA_OL_String(int seqnum)

{
  char OLstring [8];
  
  if (seqnum < 2) {
    memcpy((char *)&ram0x081b0658,&DAT_0816d4ca,4);
  }
  else {
    if (seqnum < 0x1b) {
      sprintf((char *)0x81b0658," %c.",seqnum + 0x40);
    }
    else {
      if (seqnum < 0x2bf) {
        sprintf((char *)0x81b0658,"%c%c.",(seqnum + -1) / 0x1a + 0x40,
                ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x40);
      }
      else {
        if (seqnum < 0x4767) {
          sprintf((char *)0x81b0658,"%c%c%c.",(seqnum + -0x1b) / 0x2a4 + 0x40,
                  (((seqnum + -0x1b) / 0x2a4) * -0x2a4 + seqnum + -1) / 0x1a + 0x40,
                  ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x40);
        }
        else {
          memcpy((void *)0x81b0658,&DAT_0816d4e1,5);
        }
      }
    }
  }
  return (char *)0x81b0658;
}



char * LYLowercaseA_OL_String(int seqnum)

{
  char OLstring [8];
  
  if (seqnum < 2) {
    memcpy((char *)&ram0x081b0660,&DAT_0816d4e6,4);
  }
  else {
    if (seqnum < 0x1b) {
      sprintf((char *)0x81b0660," %c.",seqnum + 0x60);
    }
    else {
      if (seqnum < 0x2bf) {
        sprintf((char *)0x81b0660,"%c%c.",(seqnum + -1) / 0x1a + 0x60,
                ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x60);
      }
      else {
        if (seqnum < 0x4767) {
          sprintf((char *)0x81b0660,"%c%c%c.",(seqnum + -0x1b) / 0x2a4 + 0x60,
                  (((seqnum + -0x1b) / 0x2a4) * -0x2a4 + seqnum + -1) / 0x1a + 0x60,
                  ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x60);
        }
        else {
          memcpy((void *)0x81b0660,&DAT_0816d4ea,5);
        }
      }
    }
  }
  return (char *)0x81b0660;
}



char * LYUppercaseI_OL_String(int seqnum)

{
  char OLstring [20];
  size_t sVar1;
  undefined *local_28;
  char *__src;
  size_t local_24;
  int Arabic;
  
  Arabic = seqnum;
  if (2999 < seqnum) {
    memcpy((void *)0x81b0668,&DAT_0816d4ef,5);
    return (char *)0x81b0668;
  }
  if (seqnum == 0x32) {
    memcpy((void *)0x81b0668,&DAT_0816d500,4);
    return (char *)0x81b0668;
  }
  if (seqnum < 0x33) {
    if (seqnum == 5) {
      memcpy((void *)0x81b0668,&DAT_0816d4f8,4);
      return (char *)0x81b0668;
    }
    if (seqnum == 10) {
      memcpy((void *)0x81b0668,&DAT_0816d4fc,4);
      return (char *)0x81b0668;
    }
    if (seqnum == 1) {
      memcpy((void *)0x81b0668,&DAT_0816d4f4,4);
      return (char *)0x81b0668;
    }
  }
  else {
    if (seqnum == 500) {
      memcpy((void *)0x81b0668,&DAT_0816d508,4);
      return (char *)0x81b0668;
    }
    if (seqnum == 1000) {
      memcpy((void *)0x81b0668,&DAT_0816d50c,4);
      return (char *)0x81b0668;
    }
    if (seqnum == 100) {
      memcpy((void *)0x81b0668,&DAT_0816d504,4);
      return (char *)0x81b0668;
    }
  }
  OLstring[0] = '\0';
  while (999 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d510;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -1000;
  }
  if (899 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d512;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -900;
  }
  if (499 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d515;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -500;
    while (499 < Arabic) {
      local_24 = 2;
      local_28 = &DAT_0816d517;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      Arabic = Arabic + -10;
    }
  }
  if (399 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d519;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -400;
  }
  while (99 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d517;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -100;
  }
  if (0x59 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d51c;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -0x5a;
  }
  if (0x31 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d51f;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -0x32;
    while (0x31 < Arabic) {
      local_24 = 2;
      local_28 = &DAT_0816d521;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      Arabic = Arabic + -10;
    }
  }
  if (0x27 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d523;
    sVar1 = strlen((char *)0x81b0668);
    memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
    Arabic = Arabic + -0x28;
  }
  do {
    switch(Arabic) {
    case 0:
      local_24 = 2;
      local_28 = &DAT_0816d54f;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 1:
      local_24 = 3;
      local_28 = &DAT_0816d526;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 2:
      local_24 = 4;
      local_28 = &DAT_0816d529;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 3:
      local_24 = 5;
      local_28 = &DAT_0816d52d;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 4:
      local_24 = 4;
      local_28 = &DAT_0816d532;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 5:
      local_24 = 3;
      local_28 = &DAT_0816d536;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 6:
      local_24 = 4;
      local_28 = &DAT_0816d539;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 7:
      local_24 = 5;
      local_28 = &DAT_0816d53d;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 8:
      local_24 = 6;
      __src = "VIII.";
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),__src,local_24);
      return (char *)0x81b0668;
    case 9:
      local_24 = 4;
      local_28 = &DAT_0816d548;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    case 10:
      local_24 = 3;
      local_28 = &DAT_0816d54c;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      return (char *)0x81b0668;
    default:
      local_24 = 2;
      local_28 = &DAT_0816d521;
      sVar1 = strlen((char *)0x81b0668);
      memcpy((void *)(sVar1 + 0x81b0668),local_28,local_24);
      Arabic = Arabic + -10;
    }
  } while( true );
}



char * LYLowercaseI_OL_String(int seqnum)

{
  char OLstring [20];
  size_t sVar1;
  undefined *local_28;
  char *__src;
  size_t local_24;
  int Arabic;
  
  Arabic = seqnum;
  if (2999 < seqnum) {
    memcpy((void *)0x81b067c,&DAT_0816d580,5);
    return (char *)0x81b067c;
  }
  if (seqnum == 0x32) {
    memcpy((void *)0x81b067c,&DAT_0816d591,4);
    return (char *)0x81b067c;
  }
  if (seqnum < 0x33) {
    if (seqnum == 5) {
      memcpy((void *)0x81b067c,&DAT_0816d589,4);
      return (char *)0x81b067c;
    }
    if (seqnum == 10) {
      memcpy((void *)0x81b067c,&DAT_0816d58d,4);
      return (char *)0x81b067c;
    }
    if (seqnum == 1) {
      memcpy((void *)0x81b067c,&DAT_0816d585,4);
      return (char *)0x81b067c;
    }
  }
  else {
    if (seqnum == 500) {
      memcpy((void *)0x81b067c,&DAT_0816d599,4);
      return (char *)0x81b067c;
    }
    if (seqnum == 1000) {
      memcpy((void *)0x81b067c,&DAT_0816d59d,4);
      return (char *)0x81b067c;
    }
    if (seqnum == 100) {
      memcpy((void *)0x81b067c,&DAT_0816d595,4);
      return (char *)0x81b067c;
    }
  }
  OLstring[0] = '\0';
  while (999 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d5a1;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -1000;
  }
  if (899 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d5a3;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -900;
  }
  if (499 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d5a6;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -500;
    while (499 < Arabic) {
      local_24 = 2;
      local_28 = &DAT_0816d5a8;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      Arabic = Arabic + -10;
    }
  }
  if (399 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d5aa;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -400;
  }
  while (99 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d5a8;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -100;
  }
  if (0x59 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d5ad;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -0x5a;
  }
  if (0x31 < Arabic) {
    local_24 = 2;
    local_28 = &DAT_0816d5b0;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -0x32;
    while (0x31 < Arabic) {
      local_24 = 2;
      local_28 = &DAT_0816d5b2;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      Arabic = Arabic + -10;
    }
  }
  if (0x27 < Arabic) {
    local_24 = 3;
    local_28 = &DAT_0816d5b4;
    sVar1 = strlen((char *)0x81b067c);
    memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
    Arabic = Arabic + -0x28;
  }
  do {
    switch(Arabic) {
    case 0:
      local_24 = 2;
      local_28 = &DAT_0816d54f;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 1:
      local_24 = 3;
      local_28 = &DAT_0816d5b7;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 2:
      local_24 = 4;
      local_28 = &DAT_0816d5ba;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 3:
      local_24 = 5;
      local_28 = &DAT_0816d5be;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 4:
      local_24 = 4;
      local_28 = &DAT_0816d5c3;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 5:
      local_24 = 3;
      local_28 = &DAT_0816d5c7;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 6:
      local_24 = 4;
      local_28 = &DAT_0816d5ca;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 7:
      local_24 = 5;
      local_28 = &DAT_0816d5ce;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 8:
      local_24 = 6;
      __src = "viii.";
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),__src,local_24);
      return (char *)0x81b067c;
    case 9:
      local_24 = 4;
      local_28 = &DAT_0816d5d9;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    case 10:
      local_24 = 3;
      local_28 = &DAT_0816d5dd;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      return (char *)0x81b067c;
    default:
      local_24 = 2;
      local_28 = &DAT_0816d5b2;
      sVar1 = strlen((char *)0x81b067c);
      memcpy((void *)(sVar1 + 0x81b067c),local_28,local_24);
      Arabic = Arabic + -10;
    }
  } while( true );
}



void LYZero_OL_Counter(HTStructured *me)

{
  int i;
  
  if (me != (HTStructured *)0x0) {
    i = 0;
    while (i < 0xc) {
      *(int *)(&me->target + i + 0x4c) = OL_VOID;
      me->OL_Type[i] = '1';
      i = i + 1;
    }
    me->Last_OL_Count = 0;
    me->Last_OL_Type = '1';
  }
  return;
}



void LYGetChartransInfo(HTStructured *me)

{
  int iVar1;
  LYUCcharset *pLVar2;
  int chndl;
  
  iVar1 = HTAnchor_getUCLYhndl(me->node_anchor,2);
  me->UCLYhndl = iVar1;
  if (me->UCLYhndl < 0) {
    chndl = HTAnchor_getUCLYhndl(me->node_anchor,3);
    if (chndl < 0) {
      chndl = current_char_set;
      HTAnchor_setUCInfoStage(me->node_anchor,current_char_set,3,3);
    }
    HTAnchor_setUCInfoStage(me->node_anchor,chndl,2,3);
    iVar1 = HTAnchor_getUCLYhndl(me->node_anchor,2);
    me->UCLYhndl = iVar1;
  }
  pLVar2 = HTAnchor_getUCInfoStage(me->node_anchor,2);
  me->UCI = pLVar2;
  return;
}



char * UCPutUtf8ToBuffer(char *q,UCode_t code,BOOLEAN terminate)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  char *local_1c;
  char *q_in;
  
  local_1c = q;
  if (q == (char *)0x0) {
    local_1c = (char *)0x0;
  }
  else {
    if ((code < 0x80) || (code == 0x7fffffff)) {
      local_1c = (char *)0x0;
    }
    else {
      bVar1 = (byte)(code >> 6);
      bVar5 = (byte)code;
      if (code < 0x800) {
        *q = bVar1 | 0xc0;
        q[1] = bVar5 & 0x3f | 0x80;
        q = q + 2;
      }
      else {
        bVar2 = (byte)(code >> 0xc);
        if (code < 0x10000) {
          *q = bVar2 | 0xe0;
          q[1] = bVar1 & 0x3f | 0x80;
          q[2] = bVar5 & 0x3f | 0x80;
          q = q + 3;
        }
        else {
          bVar3 = (byte)(code >> 0x12);
          if (code < 0x200000) {
            *q = bVar3 | 0xf0;
            q[1] = bVar2 & 0x3f | 0x80;
            q[2] = bVar1 & 0x3f | 0x80;
            q[3] = bVar5 & 0x3f | 0x80;
            q = q + 4;
          }
          else {
            bVar4 = (byte)((uint)code >> 0x18);
            if (code < 0x4000000) {
              *q = bVar4 | 0xf8;
              q[1] = bVar3 & 0x3f | 0x80;
              q[2] = bVar2 & 0x3f | 0x80;
              q[3] = bVar1 & 0x3f | 0x80;
              q[4] = bVar5 & 0x3f | 0x80;
              q = q + 5;
            }
            else {
              *q = (char)bVar4 >> 6 | 0xfc;
              q[1] = bVar4 & 0x3f | 0x80;
              q[2] = bVar3 & 0x3f | 0x80;
              q[3] = bVar2 & 0x3f | 0x80;
              q[4] = bVar1 & 0x3f | 0x80;
              q[5] = bVar5 & 0x3f | 0x80;
              q = q + 6;
            }
          }
        }
      }
      if (terminate == '\0') {
        local_1c = q;
      }
      else {
        *q = '\0';
      }
    }
  }
  return local_1c;
}



char ** LYUCFullyTranslateString
                  (char **str,int cs_from,int cs_to,BOOLEAN do_ent,BOOLEAN use_lynx_specials,
                  BOOLEAN plain_space,BOOLEAN hidden,BOOLEAN Back,CharUtil_st stype)

{
  int iVar1;
  ushort uVar2;
  bool bVar3;
  BOOLEAN BVar4;
  int iVar5;
  char *s;
  size_t sVar6;
  byte *__s;
  int iVar7;
  FILE *__stream;
  ushort **ppuVar8;
  int in_GS_OFFSET;
  bool bVar9;
  char **local_12c;
  BOOLEAN local_124;
  _state local_114;
  UCode_t local_104;
  char *local_100;
  char *local_e4;
  BOOLEAN local_b8;
  UCTransParams T;
  char *pp;
  int rev_c;
  _parsing_what what;
  _state state;
  char *puni;
  char *name;
  size_t len;
  ulong lcode;
  UCode_t code;
  int lowest_8;
  int uck;
  char *esc;
  char *cp;
  HTChunk *chunk;
  char *qs;
  char *q;
  char *p;
  BOOLEAN from_is_utf8;
  BOOLEAN no_bytetrans;
  BOOLEAN repl_translated_C0;
  BOOLEAN output_utf8;
  char cpe;
  char replace_buf [64];
  
  local_b8 = do_ent;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  chunk = (HTChunk *)0x0;
  cp = (char *)0x0;
  cpe = '\0';
  code = 0;
  output_utf8 = '\0';
  repl_translated_C0 = '\0';
  name = (char *)0x0;
  bVar9 = false;
  state = S_text;
  what = P_text;
  if (((str == (char **)0x0) || (*str == (char *)0x0)) || (**str == '\0')) {
    local_12c = str;
  }
  else {
    memset(replace_buf,0,0x40);
    if (((HTCJK == NOCJK) || (iVar5 = strcmp(LYCharSet_UC[cs_from].MIMEname,"utf-8"), iVar5 == 0))
       || (iVar5 = strcmp(LYCharSet_UC[cs_to].MIMEname,"utf-8"), iVar5 == 0)) {
      if (((cs_to < 1) && (cs_from == cs_to)) && ((Back == '\0' || (cs_to < 0)))) {
        bVar3 = true;
      }
      else {
        if (((use_lynx_specials == '\0') && (Back == '\0')) &&
           (BVar4 = UCNeedNotTranslate(cs_from,cs_to), BVar4 != '\0')) {
          bVar3 = true;
        }
        else {
          bVar3 = false;
        }
      }
    }
    else {
      bVar3 = true;
    }
    if (((do_ent != '\0') && (hidden != '\0')) &&
       ((stype != st_URL && (s = strchr(*str,0x26), s == (char *)0x0)))) {
      local_b8 = '\0';
    }
    BVar4 = UCCanTranslateFromTo(cs_from,cs_to);
    if (BVar4 == '\0') {
      if (cs_to < 0) {
        local_12c = (char **)0x0;
        goto LAB_080e06f3;
      }
      if ((local_b8 == '\0') && (bVar3)) {
        local_12c = (char **)0x0;
        goto LAB_080e06f3;
      }
      bVar3 = true;
    }
    else {
      if (cs_to < 0) {
        local_b8 = '\0';
      }
    }
    if ((local_b8 != '\0') || (!bVar3)) {
      qs = *str;
      if (bVar3) {
        if (local_b8 != '\0') {
          if ((LYCharSet_UC[cs_to].enc == 7) ||
             (BVar4 = HText_hasUTF8OutputSet(HTMainText), BVar4 != '\0')) {
            local_124 = '\x01';
          }
          else {
            local_124 = '\0';
          }
          output_utf8 = local_124;
          repl_translated_C0 = LYCharSet_UC[cs_to].enc == 3;
        }
      }
      else {
        UCTransParams_clear(&T);
        UCSetTransParams(&T,cs_from,LYCharSet_UC + cs_from,cs_to,LYCharSet_UC + cs_to);
        bVar9 = LYCharSet_UC[cs_from].enc == 7;
        output_utf8 = T.output_utf8;
        repl_translated_C0 = T.repl_translated_C0;
        puni = qs;
      }
      iVar5 = LYlowest_eightbit[cs_to];
      sVar6 = strlen(qs);
      len = sVar6 + 0x10;
      q = qs;
      p = qs;
      do {
        if ((*p == '\0') && ((state == S_text || (state == S_nonascii_text)))) goto LAB_080e0602;
        switch(state) {
        case S_text:
          code = ZEXT14((byte)*p);
          if (*p == '\x1b') {
            if (((HTCJK == NOCJK) || (hidden != '\0')) && (stype == st_HTML)) {
              if (hidden == '\0') {
                state = S_next_char;
              }
              else {
                state = S_trans_byte;
              }
            }
            else {
              state = S_esc;
              if (stype == st_URL) {
                if (q != qs) {
                  if (chunk == (HTChunk *)0x0) {
                    chunk = HTChunkCreate2(0x80,len + 1);
                  }
                  HTChunkPutb(chunk,qs,(int)(q + -(int)qs));
                }
                if (chunk == (HTChunk *)0x0) {
                  chunk = HTChunkCreate2(0x80,len + 1);
                }
                HTChunkPuts(chunk,"%1B");
                qs = *str;
                p = p + 1;
                q = qs;
              }
              else {
                if (stype == st_HTML) {
                  *q = *p;
                  q = q + 1;
                  p = p + 1;
                }
                else {
                  p = p + 1;
                }
              }
            }
          }
          else {
            if (local_b8 == '\0') {
              local_114 = S_trans_byte;
            }
            else {
              local_114 = S_check_ent;
            }
            state = local_114;
          }
          break;
        case S_esc:
          if (*p == '$') {
            state = S_dollar;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            if (*p == '(') {
              state = S_paren;
              *q = *p;
              q = q + 1;
              p = p + 1;
            }
            else {
              state = S_text;
            }
          }
          break;
        case S_dollar:
          if (((*p == '@') || (*p == 'B')) || (*p == 'A')) {
            state = S_nonascii_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            if (*p == '(') {
              state = S_dollar_paren;
              *q = *p;
              q = q + 1;
              p = p + 1;
            }
            else {
              state = S_text;
            }
          }
          break;
        case S_paren:
          if (((*p == 'B') || (*p == 'J')) || (*p == 'T')) {
            state = S_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            if (*p == 'I') {
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
              p = p + 1;
            }
            else {
              state = S_text;
            }
          }
          break;
        case S_nonascii_text:
          if ((*p == '\x1b') && (((HTCJK != NOCJK && (hidden == '\0')) || (stype != st_HTML)))) {
            state = S_esc;
            if (stype == st_URL) {
              if (q != qs) {
                if (chunk == (HTChunk *)0x0) {
                  chunk = HTChunkCreate2(0x80,len + 1);
                }
                HTChunkPutb(chunk,qs,(int)(q + -(int)qs));
              }
              if (chunk == (HTChunk *)0x0) {
                chunk = HTChunkCreate2(0x80,len + 1);
              }
              HTChunkPuts(chunk,"%1B");
              qs = *str;
              p = p + 1;
              q = qs;
              break;
            }
            if (stype != st_HTML) {
              p = p + 1;
              break;
            }
          }
          *q = *p;
          q = q + 1;
          p = p + 1;
          break;
        case S_dollar_paren:
          if (*p == 'C') {
            state = S_nonascii_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            state = S_text;
          }
          break;
        case S_trans_byte:
          if ((*p == '\0') || (bVar3)) {
            state = S_got_outchar;
            break;
          }
          if (Back == '\0') {
            if (code < 0x7f) {
              state = S_got_outchar;
              break;
            }
          }
          else {
            if ((*p == '\x01') || (*p == '\x02')) {
              if (plain_space != '\0') {
                *p = ' ';
                code = 0x20;
                state = S_got_outchar;
                break;
              }
              code = 0xa0;
              if ((LYCharSet_UC[cs_to].enc == 2) ||
                 (((&LYCharSet_UC[0].codepage)[(cs_to * 2 + 1) * 4] & 0x80U) != 0)) {
                state = S_got_outchar;
                break;
              }
              if ((LYCharSet_UC[cs_from].enc != 2) &&
                 (((&LYCharSet_UC[0].codepage)[(cs_from * 2 + 1) * 4] & 0x80U) == 0)) {
                state = S_check_uni;
                break;
              }
              *p = -0x60;
            }
            else {
              if (*p == '\a') {
                code = 0xad;
                if ((LYCharSet_UC[cs_to].enc == 2) ||
                   (((&LYCharSet_UC[0].codepage)[(cs_to * 2 + 1) * 4] & 0x80U) != 0)) {
                  state = S_got_outchar;
                  break;
                }
                if ((LYCharSet_UC[cs_from].enc != 2) &&
                   (((&LYCharSet_UC[0].codepage)[(cs_from * 2 + 1) * 4] & 0x80U) == 0)) {
                  state = S_check_uni;
                  break;
                }
                *p = -0x53;
              }
              else {
                if (output_utf8 == '\0') {
                  if ((code < 0x7f) || (T.transp != '\0')) {
                    state = S_got_outchar;
                    break;
                  }
                }
                else {
                  iVar7 = strcmp(LYCharSet_UC[cs_from].MIMEname,"euc-jp");
                  if (((iVar7 == 0) &&
                      (((((0xa0 < (byte)*p && (*p != -1)) && (0xa0 < (byte)p[1])) && (p[1] != -1))
                       || (((*p == -0x72 && (0xa0 < (byte)p[1])) && ((byte)p[1] < 0xe0)))))) ||
                     ((((iVar7 = strcmp(LYCharSet_UC[cs_from].MIMEname,"shift_jis"), iVar7 == 0 &&
                        (0x3f < (byte)p[1])) && ((p[1] != '\x7f' && ((byte)p[1] < 0xfd)))) &&
                      (((0x80 < (byte)*p && ((byte)*p < 0xa0)) ||
                       ((0xdf < (byte)*p && ((byte)*p < 0xf0)))))))) {
                    code = UCTransJPToUni(p,2,cs_from);
                    p = p + 1;
                    state = S_check_uni;
                    break;
                  }
                }
              }
            }
            iVar7 = UCReverseTransChar(*p,cs_to,cs_from);
            if (0x7f < iVar7) {
              *p = (char)iVar7;
              state = S_got_outchar;
              code = iVar7;
              break;
            }
          }
          if (bVar9) {
            if (((int)*p & 0xc0U) == 0xc0) {
              puni = p;
              code = UCGetUniFromUtf8String(&puni);
              if (code < 1) {
                code = ZEXT14((byte)*p);
              }
              else {
                what = P_utf8;
              }
            }
          }
          else {
            if ((((use_lynx_specials != '\0') && (Back == '\0')) &&
                ((code == 0xa0 || (code == 0xad)))) &&
               ((LYCharSet_UC[cs_from].enc == 2 ||
                (((&LYCharSet_UC[0].codepage)[(cs_from * 2 + 1) * 4] & 0x80U) != 0)))) {
              if (code == 0xa0) {
                *p = '\x01';
                code = 1;
              }
              else {
                if (code == 0xad) {
                  *p = '\a';
                  code = 7;
                }
              }
              state = S_got_outchar;
              break;
            }
            if (T.trans_to_uni == '\0') {
              if (T.trans_from_uni == '\0') {
                state = S_got_outchar;
                break;
              }
            }
            else {
              code = UCTransToUni(*p,cs_from);
              if (code < 1) {
                code = ZEXT14((byte)*p);
              }
            }
          }
          if (((use_lynx_specials == '\0') || (Back != '\0')) || ((code != 0xa0 && (code != 0xad))))
          {
            state = S_check_uni;
          }
          else {
            if (code == 0xa0) {
              local_104 = 1;
            }
            else {
              local_104 = 7;
            }
            code = local_104;
            state = S_got_outchar;
          }
          break;
        case S_check_ent:
          if (*p == '&') {
            __s = (byte *)(p + 1);
            len = strlen((char *)__s);
            if ((((*__s == 0x23) && (2 < len)) && ((p[2] == 'x' || (p[2] == 'X')))) &&
               (((byte)p[3] < 0x7f &&
                (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)p[3]] & 0x1000) != 0)))) {
              what = P_hex;
              state = S_ncr;
            }
            else {
              if ((*__s == 0x23) &&
                 (((2 < len && ((byte)p[2] < 0x7f)) &&
                  (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)p[2]] & 0x800) != 0)))) {
                what = P_decimal;
                state = S_ncr;
              }
              else {
                if ((*__s < 0x7f) && (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[*__s] & 0x400) != 0)) {
                  what = P_named;
                  state = S_named;
                }
                else {
                  state = S_trans_byte;
                }
              }
            }
          }
          else {
            state = S_trans_byte;
          }
          break;
        case S_ncr:
          if (what == P_hex) {
            p = p + 3;
          }
          else {
            p = p + 2;
          }
          s = p;
          cp = p;
          while ((*p != '\0' && ((byte)*p < 0x7f))) {
            if (what == P_hex) {
              ppuVar8 = __ctype_b_loc();
              uVar2 = (*ppuVar8)[(byte)*p] & 0x1000;
            }
            else {
              ppuVar8 = __ctype_b_loc();
              uVar2 = (*ppuVar8)[(byte)*p] & 0x800;
            }
            if (uVar2 == 0) break;
            p = p + 1;
          }
          cpe = *p;
          if (*p != '\0') {
            *p = '\0';
            p = p + 1;
          }
          if (what == P_hex) {
            iVar7 = sscanf(s,"%lx",&lcode);
          }
          else {
            iVar7 = sscanf(s,"%lu",&lcode);
          }
          if ((iVar7 == 1) && (-1 < (int)lcode)) {
            code = lcode;
            if ((lcode == 1) || ((0x7f < (int)lcode && ((int)lcode < 0x9c)))) {
              switch(lcode) {
              case 1:
                code = 0x263a;
                break;
              case 0x80:
                code = 0x20ac;
                break;
              case 0x82:
                code = 0x201a;
                break;
              case 0x84:
                code = 0x201e;
                break;
              case 0x85:
                code = 0x2026;
                break;
              case 0x86:
                code = 0x2020;
                break;
              case 0x87:
                code = 0x2021;
                break;
              case 0x89:
                code = 0x2030;
                break;
              case 0x8b:
                code = 0x2039;
                break;
              case 0x91:
                code = 0x2018;
                break;
              case 0x92:
                code = 0x2019;
                break;
              case 0x93:
                code = 0x201c;
                break;
              case 0x94:
                code = 0x201d;
                break;
              case 0x95:
                code = 0x2022;
                break;
              case 0x96:
                code = 0x2013;
                break;
              case 0x97:
                code = 0x2014;
                break;
              case 0x98:
                code = 0x2dc;
                break;
              case 0x99:
                code = 0x2122;
                break;
              case 0x9b:
                code = 0x203a;
              }
            }
            state = S_check_uni;
          }
          else {
            state = S_recover;
          }
          break;
        case S_check_uni:
          if (((((code < 0x20) && (code != 9)) &&
               ((code != 10 && ((code != 0xd && (HTCJK == NOCJK)))))) ||
              ((code == 0x7f && ((HTPassHighCtrlRaw == '\0' && (HTCJK == NOCJK)))))) ||
             ((0x7f < code && ((code < 0xa0 && (HTPassHighCtrlNum == '\0')))))) {
            state = S_recover;
            break;
          }
          if ((0x9f < code) && (stype == st_URL)) {
            state = S_got_oututf8;
            break;
          }
          if (code == 0xa0) {
            if (plain_space != '\0') {
              code = 0x20;
              state = S_got_outchar;
              break;
            }
            if (use_lynx_specials != '\0') {
              code = 1;
              state = S_got_outchar;
              break;
            }
            if ((((hidden != '\0') && (Back == '\0')) ||
                (((uint)(&LYCharSet_UC[0].MIMEname)[(cs_to * 2 + 1) * 4] & 2) != 0)) ||
               ((LYCharSet_UC[cs_to].enc == 2 ||
                (((&LYCharSet_UC[0].codepage)[(cs_to * 2 + 1) * 4] & 0x80U) != 0)))) {
              state = S_got_outchar;
              break;
            }
            if (((&LYCharSet_UC[0].UChndl)[(cs_to * 2 + 1) * 4] & 2U) == 0) {
              code = 0x20;
              state = S_got_outchar;
              break;
            }
          }
          if (code == 0xad) {
            if (plain_space != '\0') {
              replace_buf[0] = '\0';
              state = S_got_outstring;
              break;
            }
            if (((Back == '\0') || (LYCharSet_UC[cs_to].enc == 2)) ||
               (((&LYCharSet_UC[0].codepage)[(cs_to * 2 + 1) * 4] & 0x80U) != 0)) {
              if ((hidden != '\0') || (Back != '\0')) {
                state = S_got_outchar;
                break;
              }
              if (use_lynx_specials != '\0') {
                code = 7;
                state = S_got_outchar;
                break;
              }
            }
          }
          iVar7 = UCTransUniChar(code,cs_to);
          if (((0x1f < iVar7) && (iVar7 < 0x100)) && ((iVar7 < 0x7f || (iVar5 <= iVar7)))) {
            state = S_got_outchar;
            code = iVar7;
            break;
          }
          if (((iVar7 == -4) || (((repl_translated_C0 != '\0' && (0 < iVar7)) && (iVar7 < 0x20))))
             && (iVar7 = UCTransUniCharStr(replace_buf,0x3c,code,cs_to,0), -1 < iVar7)) {
            state = S_got_outstring;
            break;
          }
          if (((output_utf8 != '\0') && (0x7f < code)) && (code != 0x7fffffff)) {
            state = S_got_oututf8;
            break;
          }
          if (((code == 0x2002) || (code == 0x2003)) || (code == 0x2009)) {
            if (hidden == '\0') {
              if (plain_space == '\0') {
                code = 2;
                state = S_got_outchar;
              }
              else {
                code = 0x20;
                state = S_got_outchar;
              }
            }
            else {
              state = S_recover;
            }
            break;
          }
          if ((((code == 0x200c) || (code == 0x200d)) || (code == 0x200e)) || (code == 0x200f)) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYUCFullyTranslateString: Ignoring \'%ld\'.\n",code);
            }
            replace_buf[0] = '\0';
            state = S_got_outstring;
            break;
          }
          if (0xff < code) {
            state = S_recover;
            break;
          }
          if ((code < 0xa1) ||
             ((code < 0x100 && ((HTPassEightBitNum != '\0' || (cs_to == LATIN1)))))) {
            state = S_got_outchar;
            break;
          }
        case S_recover:
          if ((what == P_decimal) || (what == P_hex)) {
            *q = '&';
            q[1] = '#';
            s = q + 2;
            if (what == P_hex) {
              q[2] = 'x';
              s = q + 3;
            }
            q = s;
            if (cpe != '\0') {
              p[-1] = cpe;
            }
            p = cp;
            state = S_done;
          }
          else {
            if (what == P_named) {
              *cp = cpe;
              *q = '&';
              q = q + 1;
              state = S_done;
            }
            else {
              if ((((T.output_utf8 == '\0') && (stype == st_HTML)) && (hidden == '\0')) &&
                 ((HTPassEightBitRaw == '\0' || ((int)(uint)(byte)*p < iVar5)))) {
                sprintf(replace_buf,"U%.2lX",code);
                state = S_got_outstring;
              }
              else {
                puni = p;
                state = S_got_outchar;
                code = (uint)(byte)*p;
              }
            }
          }
          break;
        case S_named:
          name = p + 1;
          cp = name;
          while (((*cp != '\0' && ((byte)*cp < 0x7f)) &&
                 (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)*cp] & 8) != 0))) {
            cp = cp + 1;
          }
          cpe = *cp;
          *cp = '\0';
          state = S_check_name;
          p = name;
          break;
        case S_check_name:
          code = HTMLGetEntityUCValue(name);
          if ((code < 1) || ((cpe == '=' && (stype == st_URL)))) {
            state = S_recover;
          }
          else {
            state = S_check_uni;
          }
          break;
        case S_got_oututf8:
          if ((code < 0x100) && ((code < 0x80 || (LYCharSet_UC[cs_to].enc != 7)))) {
            state = S_got_outchar;
          }
          else {
            UCPutUtf8ToBuffer(replace_buf,code,'\x01');
            state = S_got_outstring;
          }
          break;
        case S_got_outstring:
          if ((what == P_decimal) || (what == P_hex)) {
            if ((cpe != ';') && (cpe != '\0')) {
              p = p + -1;
              *p = cpe;
            }
            p = p + -1;
          }
          else {
            if (what == P_named) {
              *cp = cpe;
              if (*cp == ';') {
                local_100 = cp;
              }
              else {
                local_100 = cp + -1;
              }
              p = local_100;
            }
            else {
              if (what == P_utf8) {
                p = puni;
              }
            }
          }
          if (replace_buf[0] == '\0') {
            state = S_next_char;
          }
          else {
            if ((stype == st_URL) &&
               ((code = (UCode_t)replace_buf[0], 0x7e < code ||
                ((((code < 0x20 && (code != 9)) && (code != 10)) && (code != 0)))))) {
              state = S_put_urlstring;
            }
            else {
              if (q != qs) {
                if (chunk == (HTChunk *)0x0) {
                  chunk = HTChunkCreate2(0x80,len + 1);
                }
                HTChunkPutb(chunk,qs,(int)(q + -(int)qs));
              }
              if (chunk == (HTChunk *)0x0) {
                chunk = HTChunkCreate2(0x80,len + 1);
              }
              HTChunkPuts(chunk,replace_buf);
              qs = *str;
              state = S_next_char;
              q = qs;
            }
          }
          break;
        case S_put_urlstring:
          s = HTEscape(replace_buf,'\x01');
          if (q != qs) {
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPutb(chunk,qs,(int)(q + -(int)qs));
          }
          if (chunk == (HTChunk *)0x0) {
            chunk = HTChunkCreate2(0x80,len + 1);
          }
          HTChunkPuts(chunk,s);
          qs = *str;
          if (s != (char *)0x0) {
            free(s);
          }
          state = S_next_char;
          q = qs;
          break;
        case S_got_outchar:
          if ((what == P_decimal) || (what == P_hex)) {
            if ((cpe != ';') && (cpe != '\0')) {
              p = p + -1;
              *p = cpe;
            }
            p = p + -1;
          }
          else {
            if (what == P_named) {
              *cp = cpe;
              if (*cp == ';') {
                local_e4 = cp;
              }
              else {
                local_e4 = cp + -1;
              }
              p = local_e4;
            }
            else {
              if (what == P_utf8) {
                p = puni;
              }
            }
          }
          if ((stype == st_URL) &&
             ((0x7e < code || (((code < 0x20 && (code != 9)) && (code != 10)))))) {
            state = S_put_urlchar;
          }
          else {
            if ((((hidden == '\0') && (code == 10)) && (*p == '\n')) &&
               ((q != qs && (q[-1] == '\r')))) {
              q[-1] = *p;
              p = p + 1;
              state = S_done;
            }
            else {
              *q = (char)code;
              q = q + 1;
              state = S_next_char;
            }
          }
          break;
        case S_put_urlchar:
          *q = '%';
          s = q + 1;
          if (p < s) {
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPutb(chunk,qs,(int)(s + -(int)qs));
            qs = *str;
            *qs = hex[code >> 4 & 0xf];
            q = qs + 1;
          }
          else {
            *s = hex[code >> 4 & 0xf];
            q = q + 2;
          }
          if (p < q) {
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPutb(chunk,qs,(int)(q + -(int)qs));
            qs = *str;
            *qs = hex[code & 0xf];
            q = qs + 1;
          }
          else {
            *q = hex[code & 0xf];
            q = q + 1;
          }
        case S_next_char:
          p = p + 1;
switchD_080dedaa_caseD_13:
          state = S_text;
          what = P_text;
          break;
        case S_done:
          goto switchD_080dedaa_caseD_13;
        }
      } while( true );
    }
    local_12c = str;
  }
  goto LAB_080e06f3;
LAB_080e0602:
  *q = '\0';
  if (chunk == (HTChunk *)0x0) {
    if ((stype == st_URL) || (stype == st_other)) {
      LYTrimHead(qs);
      LYTrimTail(qs);
    }
  }
  else {
    if (chunk == (HTChunk *)0x0) {
      chunk = HTChunkCreate2(0x80,len + 1);
    }
    HTChunkPutb(chunk,qs,(int)(q + (1 - (int)qs)));
    if ((stype == st_URL) || (stype == st_other)) {
      LYTrimHead(chunk->data);
      LYTrimTail(chunk->data);
    }
    HTSACopy(str,chunk->data);
    HTChunkFree(chunk);
  }
  local_12c = str;
LAB_080e06f3:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_12c;
}



BOOLEAN LYUCTranslateHTMLString
                  (char **str,int cs_from,int cs_to,BOOLEAN use_lynx_specials,BOOLEAN plain_space,
                  BOOLEAN hidden,CharUtil_st stype)

{
  char **ppcVar1;
  BOOLEAN ret;
  
  ppcVar1 = LYUCFullyTranslateString
                      (str,cs_from,cs_to,'\x01',use_lynx_specials,plain_space,hidden,'\0',stype);
  return (BOOLEAN)(ppcVar1 != (char **)0x0);
}



BOOLEAN LYUCTranslateBackFormData(char **str,int cs_from,int cs_to,BOOLEAN plain_space)

{
  char **ppcVar1;
  char **ret;
  
  ppcVar1 = LYUCFullyTranslateString(str,cs_from,cs_to,'\0','\0',plain_space,'\x01','\x01',st_HTML);
  return (BOOLEAN)(ppcVar1 != (char **)0x0);
}



char * LYParseTagParam(char *from,char *name)

{
  size_t n;
  ushort **ppuVar1;
  size_t sVar2;
  int iVar3;
  char *string;
  char *result;
  size_t len;
  
  n = strlen(name);
  result = (char *)0x0;
  string = from;
  while( true ) {
    string = strchr(string,0x3b);
    if (string == (char *)0x0) {
      return (char *)0x0;
    }
    while ((*string != '\0' &&
           ((*string == ';' ||
            (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*string] & 0x2000) != 0))))) {
      string = string + 1;
    }
    sVar2 = strlen(string);
    if (sVar2 < n) break;
    iVar3 = strncasecomp(string,name,n);
    if (iVar3 == 0) {
      string = string + n;
      while ((*string != '\0' &&
             ((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*string] & 0x2000) != 0 ||
              (*string == '='))))) {
        string = string + 1;
      }
      HTSACopy(&result,string);
      len = 0;
      while ((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)string[len]] & 0x4000) != 0 &&
             (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)string[len]] & 0x2000) == 0))) {
        len = len + 1;
      }
      result[len] = '\0';
      if ((2 < len) && ((*result == '\'' && (result[len - 1] == *result)))) {
        result[len - 1] = '\0';
        string = result;
        while (*string = string[1], *string != '\0') {
          string = string + 1;
        }
      }
      return result;
    }
  }
  return (char *)0x0;
}



void LYParseRefreshURL(char *content,char **p_seconds,char **p_address)

{
  byte *src;
  ushort **ppuVar1;
  char *pcVar2;
  FILE *__stream;
  char *local_1c;
  char *local_18;
  char *Seconds;
  char *cp1;
  char *cp;
  
  Seconds = (char *)0x0;
  src = (byte *)LYSkipBlanks(content);
  if ((*src != 0) && (ppuVar1 = __ctype_b_loc(), cp1 = (char *)src, ((*ppuVar1)[*src] & 0x800) != 0)
     ) {
    while ((*cp1 != '\0' && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*cp1] & 0x800) != 0))) {
      cp1 = cp1 + 1;
    }
    SNACopy(&Seconds,(char *)src,(int)(cp1 + -(int)src));
  }
  *p_seconds = Seconds;
  pcVar2 = LYParseTagParam(content,"URL");
  *p_address = pcVar2;
  if (WWW_TraceFlag != '\0') {
    if (*p_address == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = *p_address;
    }
    if (*p_seconds == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = *p_seconds;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
            content,local_18,local_1c);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080e1c0a)
// WARNING: Removing unreachable block (ram,0x080e1c16)

void LYHandleMETA(HTStructured *me,BOOLEAN *present,char **value,char **include)

{
  bool bVar1;
  bool bVar2;
  char *pcVar3;
  BOOLEAN BVar4;
  FILE *__stream;
  int LYhndl;
  ushort **ppuVar5;
  time_t tVar6;
  time_t tVar7;
  LYUCcharset *pLVar8;
  char *src;
  HTChildAnchor *pHVar9;
  UrlTypes UVar10;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_5c;
  char *local_58;
  char *local_54;
  char *local_50;
  char *cp3;
  int chndl;
  char *cp4;
  LYUCcharset *p_out;
  LYUCcharset *p_in;
  int url_type;
  char *cp1;
  char *cp0;
  char *cp;
  char *temp;
  char *id_string;
  char *href;
  char *content;
  char *name;
  char *http_equiv;
  BOOLEAN given_and_display_8859like;
  BOOLEAN given_is_8859like;
  BOOLEAN given_is_8859;
  BOOLEAN chartrans_ok;
  
  http_equiv = (char *)0x0;
  name = (char *)0x0;
  content = (char *)0x0;
  href = (char *)0x0;
  if (me == (HTStructured *)0x0) {
    return;
  }
  if (present == (BOOLEAN *)0x0) {
    return;
  }
  if (((present[1] != '\0') && (value[1] != (char *)0x0)) && (*value[1] != '\0')) {
    HTSACopy(&http_equiv,value[1]);
    convert_to_spaces(http_equiv,'\x01');
    LYUCTranslateHTMLString(&http_equiv,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
    if ((*http_equiv == '\0') && (http_equiv != (char *)0x0)) {
      free(http_equiv);
      http_equiv = (char *)0x0;
    }
  }
  if (((present[2] != '\0') && (value[2] != (char *)0x0)) && (*value[2] != '\0')) {
    HTSACopy(&name,value[2]);
    convert_to_spaces(name,'\x01');
    LYUCTranslateHTMLString(&name,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
    if ((*name == '\0') && (name != (char *)0x0)) {
      free(name);
      name = (char *)0x0;
    }
  }
  if (((*present != '\0') && (*value != (char *)0x0)) && (**value != '\0')) {
    HTSACopy(&content,*value);
    convert_to_spaces(content,'\0');
    LYTrimHead(content);
    LYTrimTail(content);
    if ((*content == '\0') && (content != (char *)0x0)) {
      free(content);
      content = (char *)0x0;
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (content == (char *)0x0) {
      local_94 = "NULL";
    }
    else {
      local_94 = content;
    }
    if (name == (char *)0x0) {
      local_90 = "NULL";
    }
    else {
      local_90 = name;
    }
    if (http_equiv == (char *)0x0) {
      local_8c = "NULL";
    }
    else {
      local_8c = http_equiv;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",local_8c
            ,local_90,local_94);
  }
  if (((http_equiv == (char *)0x0) && (name == (char *)0x0)) || (content == (char *)0x0))
  goto free_META_copies;
  if (http_equiv == (char *)0x0) {
    local_88 = "";
  }
  else {
    local_88 = http_equiv;
  }
  LYhndl = strcasecomp(local_88,"Pragma");
  if (LYhndl != 0) {
    if (http_equiv == (char *)0x0) {
      local_84 = "";
    }
    else {
      local_84 = http_equiv;
    }
    LYhndl = strcasecomp(local_84,"Cache-Control");
    if (LYhndl != 0) {
      if (http_equiv == (char *)0x0) {
        local_7c = "";
      }
      else {
        local_7c = http_equiv;
      }
      LYhndl = strcasecomp(local_7c,"Expires");
      if (LYhndl == 0) {
        LYUCTranslateHTMLString(&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
        HTSACopy(&me->node_anchor->expires,content);
        if (me->node_anchor->no_cache == '\0') {
          LYhndl = strcmp(content,"0");
          if (LYhndl == 0) {
            me->node_anchor->no_cache = '\x01';
            HText_setNoCache(me->text);
          }
          else {
            if (me->node_anchor->date == (char *)0x0) {
              tVar6 = LYmktime(content,'\0');
              if (tVar6 == 0) {
                me->node_anchor->no_cache = '\x01';
                HText_setNoCache(me->text);
              }
            }
            else {
              tVar6 = LYmktime(content,'\x01');
              tVar7 = LYmktime(me->node_anchor->date,'\x01');
              if (tVar6 <= tVar7) {
                me->node_anchor->no_cache = '\x01';
                HText_setNoCache(me->text);
              }
            }
          }
        }
      }
      else {
        if ((me->node_anchor->charset == (char *)0x0) || (*me->node_anchor->charset == '\0')) {
          if (http_equiv == (char *)0x0) {
            local_78 = "";
          }
          else {
            local_78 = http_equiv;
          }
          LYhndl = strcasecomp(local_78,"Content-Type");
          if (LYhndl == 0) {
            p_in = (LYUCcharset *)0x0;
            LYUCTranslateHTMLString
                      (&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
            LYLowerCase(content);
            cp1 = strstr(content,"charset");
            if (cp1 != (char *)0x0) {
              bVar1 = false;
              cp3 = (char *)0x0;
              cp1 = cp1 + 7;
              while (((*cp1 == ' ' || (*cp1 == '=')) || (*cp1 == '\"'))) {
                cp1 = cp1 + 1;
              }
              HTSACopy(&cp3,cp1);
              local_68 = cp3;
              cp4 = cp3;
              while (((*cp4 != '\0' && (*cp4 != '\"')) &&
                     ((*cp4 != ';' && ((*cp4 != ':' && (0x20 < (byte)*cp4))))))) {
                cp4 = cp4 + 1;
              }
              *cp4 = '\0';
              chndl = UCGetLYhndl_byMIME(cp3);
              BVar4 = UCCanTranslateFromTo(chndl,current_char_set);
              if (BVar4 == '\0') {
                if (chndl < 0) {
                  chndl = UCLYhndl_for_unrec;
                  if (UCLYhndl_for_unrec < 0) {
                    chndl = UCLYhndl_for_unspec;
                  }
                  BVar4 = UCCanTranslateFromTo(chndl,current_char_set);
                  if (BVar4 != '\0') {
                    bVar1 = true;
                    HTAnchor_setUCInfoStage(me->node_anchor,chndl,1,3);
                  }
                }
              }
              else {
                bVar1 = true;
                HTSACopy(&me->node_anchor->charset,local_68);
                HTAnchor_setUCInfoStage(me->node_anchor,chndl,1,3);
              }
              if (bVar1) {
                p_in = HTAnchor_getUCInfoStage(me->node_anchor,1);
                p_out = HTAnchor_setUCInfoStage(me->node_anchor,current_char_set,3,1);
                if (p_out == (LYUCcharset *)0x0) {
                  p_out = HTAnchor_getUCInfoStage(me->node_anchor,3);
                }
                LYhndl = strcmp(p_in->MIMEname,"x-transparent");
                if (LYhndl == 0) {
                  HTPassEightBitRaw = '\x01';
                  LYhndl = HTAnchor_getUCLYhndl(me->node_anchor,3);
                  HTAnchor_setUCInfoStage(me->node_anchor,LYhndl,1,1);
                }
                LYhndl = strcmp(p_out->MIMEname,"x-transparent");
                if (LYhndl == 0) {
                  HTPassEightBitRaw = '\x01';
                  LYhndl = HTAnchor_getUCLYhndl(me->node_anchor,1);
                  HTAnchor_setUCInfoStage(me->node_anchor,LYhndl,3,1);
                }
                if ((p_in->enc == 5) || (p_in->enc == 7)) {
                  if (p_out->enc == 5) {
                    Set_HTCJK(p_in->MIMEname,p_out->MIMEname);
                  }
                }
                else {
                  HTCJK = NOCJK;
                  if (((p_in->codepoints & 1U) == 0) && (chndl == current_char_set)) {
                    HTPassEightBitRaw = '\x01';
                  }
                }
                LYGetChartransInfo(me);
                if (me->UCLYhndl != chndl) {
                  HTAnchor_setUCInfoStage(me->node_anchor,chndl,0,3);
                  HTAnchor_setUCInfoStage(me->node_anchor,chndl,1,3);
                  LYhndl = HTAnchor_getUCLYhndl(me->node_anchor,1);
                  me->inUCLYhndl = LYhndl;
                  pLVar8 = HTAnchor_getUCInfoStage(me->node_anchor,1);
                  me->inUCI = pLVar8;
                }
                UCSetTransParams(&me->T,me->inUCLYhndl,me->inUCI,me->outUCLYhndl,me->outUCI);
              }
              else {
                LYhndl = strncmp(local_68,"iso-8859-",9);
                if ((LYhndl == 0) &&
                   (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)local_68[9]] & 0x800) != 0)) {
                  bVar1 = true;
                }
                else {
                  bVar1 = false;
                }
                if ((((bVar1) || (LYhndl = strncmp(local_68,"windows-",8), LYhndl == 0)) ||
                    (LYhndl = strncmp(local_68,"cp12",4), LYhndl == 0)) ||
                   (LYhndl = strncmp(local_68,"cp-12",5), LYhndl == 0)) {
                  bVar2 = true;
                }
                else {
                  bVar2 = false;
                }
                if ((bVar2) &&
                   ((src = strstr(LYchar_set_names[current_char_set],"ISO-8859"), src != (char *)0x0
                    || (src = strstr(LYchar_set_names[current_char_set],"windows-"),
                       src != (char *)0x0)))) {
                  bVar2 = true;
                }
                else {
                  bVar2 = false;
                }
                if (bVar1) {
                  cp1 = local_68 + 10;
                  while ((*cp1 != '\0' &&
                         (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp1] & 0x800) != 0))) {
                    cp1 = cp1 + 1;
                  }
                  *cp1 = '\0';
                }
                if (bVar2) {
                  HTSACopy(&me->node_anchor->charset,local_68);
                  HTPassEightBitRaw = '\x01';
                }
                if (*local_68 == '\0') {
                  local_68 = me->node_anchor->charset;
                }
                else {
                }
                HTAlert(local_68);
              }
              if (cp3 != (char *)0x0) {
                free(cp3);
                cp3 = (char *)0x0;
              }
              if ((me->node_anchor->charset != (char *)0x0) && (WWW_TraceFlag != '\0')) {
                src = me->node_anchor->charset;
                __stream = TraceFP();
                fprintf((FILE *)__stream,"LYHandleMETA: New charset: %s\n",src);
              }
            }
            HText_setKcode(me->text,me->node_anchor->charset,p_in);
            goto free_META_copies;
          }
        }
        if (http_equiv == (char *)0x0) {
          local_64 = "";
        }
        else {
          local_64 = http_equiv;
        }
        LYhndl = strcasecomp(local_64,"Refresh");
        if (LYhndl == 0) {
          cp3 = (char *)0x0;
          LYUCTranslateHTMLString
                    (&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
          LYParseRefreshURL(content,&cp3,&href);
          if (cp3 != (char *)0x0) {
            if (href == (char *)0x0) {
              HTSACopy(&href,me->node_anchor->address);
              HText_setNoCache(me->text);
            }
            else {
              LYhndl = LYLegitimizeHREF(me,&href,'\x01','\0');
              if (LYhndl == 0) {
                src = (char *)gettext("Refresh URL is not absolute.");
                HTUserMsg(src);
                if (*href == '\0') {
                  HTSACopy(&href,me->node_anchor->address);
                  HText_setNoCache(me->text);
                }
                else {
                  src = HTParse(href,me->node_anchor->address,0x1f);
                  HTSACopy(&href,src);
                  if (src != (char *)0x0) {
                    free(src);
                  }
                }
              }
              else {
                if (me->inBASE == '\0') {
                  local_60 = me->node_anchor->address;
                }
                else {
                  local_60 = me->base_href;
                }
                LYFillLocalFileURL(&href,local_60);
              }
              LYhndl = strcmp(href,me->node_anchor->address);
              if (LYhndl == 0) {
                HText_setNoCache(me->text);
              }
            }
            if (me->inA != '\0') {
              if ((me->inBoldA == '\x01') && (me->inBoldH == '\0')) {
                HText_appendCharacter(me->text,6);
              }
              me->inBoldA = '\0';
              HText_endAnchor(me->text,me->CurrentANum);
              me->inA = '\0';
              me->CurrentANum = 0;
            }
            pHVar9 = HTAnchor_findChildAndLink(me->node_anchor,(char *)0x0,href,(HTLinkType *)0x0);
            me->CurrentA = pHVar9;
            LYEnsureSingleSpace(me);
            if (me->inUnderline == '\0') {
              HText_appendCharacter(me->text,3);
            }
            HTML_put_string(me,"REFRESH(");
            HTML_put_string(me,cp3);
            HTML_put_string(me," sec):");
            if (cp3 != (char *)0x0) {
              free(cp3);
              cp3 = (char *)0x0;
            }
            if (me->inUnderline == '\0') {
              HText_appendCharacter(me->text,4);
            }
            HTML_put_character(me,' ');
            me->in_word = '\0';
            HText_beginAnchor(me->text,me->inUnderline,me->CurrentA);
            if (me->inBoldH == '\0') {
              HText_appendCharacter(me->text,5);
            }
            HTML_put_string(me,href);
            if (href != (char *)0x0) {
              free(href);
              href = (char *)0x0;
            }
            if (me->inBoldH == '\0') {
              HText_appendCharacter(me->text,6);
            }
            HText_endAnchor(me->text,0);
            LYEnsureSingleSpace(me);
          }
        }
        else {
          if ((me->node_anchor->SugFname == (char *)0x0) || (*me->node_anchor->SugFname == '\0')) {
            if (http_equiv == (char *)0x0) {
              local_5c = "";
            }
            else {
              local_5c = http_equiv;
            }
            LYhndl = strcasecomp(local_5c,"Content-Disposition");
            if (LYhndl == 0) {
              cp = content;
              while ((*cp != '\0' && (LYhndl = strncasecomp(cp,"filename",8), LYhndl != 0))) {
                cp = cp + 1;
              }
              if (*cp != '\0') {
                cp = LYSkipBlanks(cp + 8);
                if (*cp == '=') {
                  cp = cp + 1;
                }
                src = LYSkipBlanks(cp);
                if (*src != '\0') {
                  HTSACopy(&me->node_anchor->SugFname,src);
                  if (*me->node_anchor->SugFname == '\"') {
                    src = strchr(me->node_anchor->SugFname + 1,0x22);
                    if (src == (char *)0x0) {
                      if (me->node_anchor->SugFname != (char *)0x0) {
                        free(me->node_anchor->SugFname);
                        me->node_anchor->SugFname = (char *)0x0;
                      }
                    }
                    else {
                      src[1] = '\0';
                      HTMIME_TrimDoubleQuotes(me->node_anchor->SugFname);
                      if (((me->node_anchor->SugFname == (char *)0x0) ||
                          (*me->node_anchor->SugFname == '\0')) &&
                         (me->node_anchor->SugFname != (char *)0x0)) {
                        free(me->node_anchor->SugFname);
                        me->node_anchor->SugFname = (char *)0x0;
                      }
                    }
                  }
                  cp = me->node_anchor->SugFname;
                  if (cp != (char *)0x0) {
                    while (*cp != '\0') {
                      ppuVar5 = __ctype_b_loc();
                      if (((*ppuVar5)[(byte)*cp] & 0x2000) != 0) {
                        *cp = '_';
                      }
                      cp = cp + 1;
                    }
                  }
                }
              }
              goto free_META_copies;
            }
          }
          if (http_equiv == (char *)0x0) {
            local_58 = "";
          }
          else {
            local_58 = http_equiv;
          }
          LYhndl = strcasecomp(local_58,"Set-Cookie");
          if (LYhndl == 0) {
            if (me->inBASE == '\0') {
              local_54 = me->node_anchor->address;
            }
            else {
              local_54 = me->base_href;
            }
            UVar10 = is_url(local_54);
            if ((UVar10 == HTTP_URL_TYPE) || (UVar10 == HTTPS_URL_TYPE)) {
              if (me->inBASE == '\0') {
                local_50 = me->node_anchor->address;
              }
              else {
                local_50 = me->base_href;
              }
              LYSetCookie(content,(char *)0x0,local_50);
            }
          }
        }
      }
      goto free_META_copies;
    }
  }
  LYUCTranslateHTMLString(&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
  LYhndl = strcasecomp(content,"no-cache");
  if (LYhndl == 0) {
    me->node_anchor->no_cache = '\x01';
    HText_setNoCache(me->text);
  }
  if (me->node_anchor->cache_control == (char *)0x0) {
    if (http_equiv == (char *)0x0) {
      local_80 = "";
    }
    else {
      local_80 = http_equiv;
    }
    LYhndl = strcasecomp(local_80,"Cache-Control");
    if (LYhndl == 0) {
      LYLowerCase(content);
      HTSACopy(&me->node_anchor->cache_control,content);
      if (me->node_anchor->no_cache == '\0') {
        cp0 = content;
        while (cp = strstr(cp0,"no-cache"), cp != (char *)0x0) {
          cp = cp + 8;
          while ((*cp != '\0' && ((byte)*cp < 0x21))) {
            cp = cp + 1;
          }
          if ((*cp == '\0') || (*cp == ';')) {
            me->node_anchor->no_cache = '\x01';
            HText_setNoCache(me->text);
            break;
          }
          cp0 = cp;
        }
        if (me->node_anchor->no_cache != '\x01') {
          cp0 = content;
          while (cp = strstr(cp0,"max-age"), cp != (char *)0x0) {
            cp = cp + 7;
            while ((*cp != '\0' && ((byte)*cp < 0x21))) {
              cp = cp + 1;
            }
            if (*cp == '=') {
              do {
                src = cp;
                cp = src + 1;
                pcVar3 = cp;
                if (*cp == '\0') break;
              } while ((byte)*cp < 0x21);
              ppuVar5 = __ctype_b_loc();
              if (((*ppuVar5)[(byte)*cp] & 0x800) != 0) {
                while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x800) != 0) {
                  cp = cp + 1;
                }
                if ((*pcVar3 == '0') && (src + 2 == cp)) {
                  me->node_anchor->no_cache = '\x01';
                  HText_setNoCache(me->text);
                  break;
                }
              }
            }
            cp0 = cp;
          }
        }
      }
    }
  }
free_META_copies:
  if (http_equiv != (char *)0x0) {
    free(http_equiv);
    http_equiv = (char *)0x0;
  }
  if (name != (char *)0x0) {
    free(name);
    name = (char *)0x0;
  }
  if (content != (char *)0x0) {
    free(content);
  }
  return;
}



void LYHandlePlike(HTStructured *me,BOOLEAN *present,char **value,char **include,int align_idx,
                  BOOLEAN start)

{
  HTStyle *pHVar1;
  BOOLEAN BVar2;
  HTStyle *pHVar3;
  int iVar4;
  
  if (start != '\0') {
    if (me->inFIG != '\0') {
      me->inFIGwithP = '\x01';
    }
    if (me->inAPPLET != '\0') {
      me->inAPPLETwithP = '\x01';
    }
  }
  if (me->style_change != '\0') {
    actually_set_style(me);
  }
  if (me->List_Nesting_Level < 0) {
    if (me->sp->tag_number == 3) {
      BVar2 = HText_LastLineEmpty(me->text,'\0');
      if (BVar2 == '\0') {
        HText_setLastChar(me->text,' ');
        HText_appendCharacter(me->text,0xd);
      }
    }
    else {
      if (start == '\0') {
        if (me->sp->style->spaceAfter < 1) {
          LYEnsureSingleSpace(me);
        }
        else {
          LYEnsureDoubleSpace(me);
        }
      }
      else {
        if ((me->inLABEL == '\0') || (me->inP != '\0')) {
          HText_appendParagraph(me->text);
        }
      }
      me->inLABEL = '\0';
    }
  }
  else {
    if (me->inP != '\0') {
      if (((((me->inFIG == '\0') && (me->inAPPLET == '\0')) && (me->inCAPTION == '\0')) &&
          ((me->inCREDIT == '\0' && (me->sp->style->spaceAfter < 1)))) &&
         ((start == '\0' || (me->sp->style->spaceBefore < 1)))) {
        LYEnsureSingleSpace(me);
      }
      else {
        LYEnsureDoubleSpace(me);
      }
    }
  }
  me->in_word = '\0';
  BVar2 = LYoverride_default_alignment(me);
  if (BVar2 == '\0') {
    if (((me->List_Nesting_Level < 0) ||
        (((me->sp->style->id != 1 && (me->sp->style->id != 2)) && (me->sp->style->id != 3)))) &&
       ((-1 < me->Division_Level || ((me->sp->style->id != 0 && (me->sp->style->id != 0x25)))))) {
      me->sp->style->alignment = (short)me->current_default_alignment;
    }
    else {
      me->sp->style->alignment = 1;
    }
  }
  else {
    pHVar1 = me->sp->style;
    pHVar3 = LYstyles(me->sp->tag_number);
    pHVar1->alignment = pHVar3->alignment;
  }
  if ((((start != '\0') && (present != (BOOLEAN *)0x0)) && (present[align_idx] != '\0')) &&
     (value[align_idx] != (char *)0x0)) {
    iVar4 = strcasecomp(value[align_idx],"center");
    if ((iVar4 == 0) && ((me->List_Nesting_Level < 0 || (me->inP != '\0')))) {
      me->sp->style->alignment = 3;
    }
    else {
      iVar4 = strcasecomp(value[align_idx],"right");
      if ((iVar4 == 0) && ((me->List_Nesting_Level < 0 || (me->inP != '\0')))) {
        me->sp->style->alignment = 2;
      }
      else {
        iVar4 = strcasecomp(value[align_idx],"left");
        if (iVar4 != 0) {
          iVar4 = strcasecomp(value[align_idx],"justify");
          if (iVar4 != 0) goto LAB_080e2480;
        }
        me->sp->style->alignment = 1;
      }
    }
  }
LAB_080e2480:
  me->inP = '\0';
  return;
}



// WARNING: Removing unreachable block (ram,0x080e2845)

void LYHandleSELECT(HTStructured *me,BOOLEAN *present,char **value,char **include,BOOLEAN start)

{
  BOOLEAN BVar1;
  FILE *__stream;
  char *pcVar2;
  int iVar3;
  size_t sVar4;
  char *ptr;
  char *size;
  char *name;
  int i;
  BOOLEAN multiple;
  
  if (start == '\x01') {
    name = (char *)0x0;
    multiple = '\0';
    me->select_disabled = '\0';
    if (((me->inFORM == '\0') && (BVar1 = LYBadHTML(me), BVar1 != '\0')) && (WWW_TraceFlag != '\0'))
    {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Bad HTML: SELECT start tag not within FORM tag\n");
    }
    if (((me->inTEXTAREA != '\0') && (BVar1 = LYBadHTML(me), BVar1 != '\0')) &&
       (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Bad HTML: Missing TEXTAREA end tag\n");
    }
    me->inSELECT = '\x01';
    if (((present == (BOOLEAN *)0x0) || (present[0xb] == '\0')) ||
       ((value[0xb] == (char *)0x0 || (*value[0xb] == '\0')))) {
      HTSACopy(&name,"");
    }
    else {
      pcVar2 = strchr(value[0xb],0x26);
      if (pcVar2 == (char *)0x0) {
        HTSACopy(&name,value[0xb]);
      }
      else {
        HTSACopy(&name,value[0xb]);
        LYUCTranslateHTMLString(&name,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_HTML);
      }
    }
    if ((present != (BOOLEAN *)0x0) && (present[10] != '\0')) {
      multiple = '\x01';
    }
    if ((present != (BOOLEAN *)0x0) && (present[4] != '\0')) {
      me->select_disabled = '\x01';
    }
    if ((((present != (BOOLEAN *)0x0) && (present[0x10] != '\0')) && (value[0x10] != (char *)0x0))
       && ((*value[0x10] != '\0' && (WWW_TraceFlag != '\0')))) {
      pcVar2 = value[0x10];
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",pcVar2);
    }
    if ((me->inBoldH == '\x01') && ((multiple == '\0' || (LYSelectPopups == '\0')))) {
      HText_appendCharacter(me->text,6);
      me->inBoldH = '\0';
      me->needBoldH = '\x01';
    }
    if ((me->inUnderline == '\x01') && ((multiple == '\0' || (LYSelectPopups == '\0')))) {
      HText_appendCharacter(me->text,4);
      me->inUnderline = '\0';
    }
    if ((((multiple == '\0') && (LYSelectPopups == '\x01')) &&
        ((me->sp->tag_number == 0x56 ||
         ((me->inPRE == '\x01' || (me->sp->style->freeFormat == '\0')))))) &&
       (iVar3 = HText_LastLineSize(me->text,'\0'),
       (int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -7) < iVar3)) {
      HTML_put_character(me,'\n');
      me->in_word = '\0';
    }
    LYCheckForID(me,present,value,7);
    HText_beginSelect(name,me->tag_charset,multiple,(char *)0x0);
    if (name != (char *)0x0) {
      free(name);
    }
    me->first_option = '\x01';
  }
  else {
    if (me->inSELECT == '\0') {
      BVar1 = LYBadHTML(me);
      if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Bad HTML: Unmatched SELECT end tag\n");
      }
    }
    else {
      me->inSELECT = '\0';
      me->select_disabled = '\0';
      HTChunkTerminate((HTChunk *)&me->option);
      ptr = HText_setLastOptionValue
                      (me->text,(me->option).data,me->LastOptionValue,3,me->LastOptionChecked,
                       me->UCLYhndl,me->tag_charset);
      if (me->LastOptionValue != (char *)0x0) {
        free(me->LastOptionValue);
        me->LastOptionValue = (char *)0x0;
      }
      me->LastOptionChecked = '\0';
      if ((HTCurSelectGroupType == 3) || (LYSelectPopups == '\0')) {
        LYEnsureSingleSpace(me);
      }
      else {
        if (((ptr != (char *)0x0) && (me->sp->tag_number == 0x56)) &&
           (sVar4 = strlen(ptr), 6 < sVar4)) {
          i = 0;
          while (i < 6) {
            if (*ptr == ' ') {
              HText_appendCharacter(me->text,1);
            }
            else {
              HText_appendCharacter(me->text,(int)*ptr);
            }
            ptr = ptr + 1;
            i = i + 1;
          }
          HText_setIgnoreExcess(me->text,'\x01');
        }
        while ((ptr != (char *)0x0 && (*ptr != '\0'))) {
          if (*ptr == ' ') {
            HText_appendCharacter(me->text,1);
          }
          else {
            HText_appendCharacter(me->text,(int)*ptr);
          }
          ptr = ptr + 1;
        }
        if (me->first_option == '\0') {
          HText_appendCharacter(me->text,0x5d);
          HText_setLastChar(me->text,']');
          me->in_word = '\x01';
        }
        HText_setIgnoreExcess(me->text,'\0');
      }
      HTChunkClear((HTChunk *)&me->option);
      if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
        HText_appendCharacter(me->text,3);
        me->inUnderline = '\x01';
      }
      if ((me->needBoldH == '\x01') && (me->inBoldH == '\0')) {
        HText_appendCharacter(me->text,5);
        me->inBoldH = '\x01';
        me->needBoldH = '\0';
      }
    }
  }
  return;
}



int LYLegitimizeHREF(HTStructured *me,char **href,BOOLEAN force_slash,BOOLEAN strip_dots)

{
  BOOLEAN BVar1;
  char *local_50;
  char *local_54;
  int iVar2;
  char *aName;
  char *__s1;
  FILE *__stream;
  UrlTypes local_38;
  char *local_34;
  char *str;
  char *cp;
  char *path;
  char *temp;
  char *Base;
  char *pound;
  char *p;
  int url_type;
  
  if ((((me == (HTStructured *)0x0) || (href == (char **)0x0)) || (*href == (char *)0x0)) ||
     (**href == '\0')) {
    local_38 = NOT_A_URL_TYPE;
  }
  else {
    BVar1 = LYTrimStartfile(*href);
    if ((BVar1 == '\0') && (local_50 = LYSkipNonBlanks(*href), *local_50 != '\0')) {
      local_54 = strchr(*href,0x23);
      if ((local_54 == (char *)0x0) || (local_50 <= local_54)) {
        if (local_54 != (char *)0x0) {
          *local_54 = '\0';
        }
        BVar1 = LYRemoveNewlines(local_50);
        if ((BVar1 != '\0') || (aName = strchr(local_50,9), aName != (char *)0x0)) {
          LYRemoveBlanks(local_50);
        }
        if (local_54 != (char *)0x0) {
          local_50 = strchr(local_50,0);
          *local_54 = '#';
          convert_to_spaces(local_54,'\0');
          if (local_50 < local_54) {
            strcpy(local_50,local_54);
          }
        }
      }
      else {
        convert_to_spaces(local_50,'\0');
      }
    }
    if (**href == '\0') {
      local_38 = NOT_A_URL_TYPE;
    }
    else {
      local_50 = (char *)0x0;
      LYUCTranslateHTMLString(href,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_URL);
      if (me->inBASE == '\0') {
        local_34 = me->node_anchor->address;
      }
      else {
        local_34 = me->base_href;
      }
      local_38 = is_url(*href);
      if (((((local_38 == NOT_A_URL_TYPE) && (force_slash != '\0')) && (**href == '.')) &&
          ((iVar2 = strcmp(*href,"."), iVar2 == 0 || (iVar2 = strcmp(*href,".."), iVar2 == 0)))) &&
         (((*local_34 != 'f' && (*local_34 != 'F')) ||
          (iVar2 = strncasecomp(local_34,"file:",5), iVar2 != 0)))) {
        HTSACat(href,"/");
      }
      if (((local_38 == NOT_A_URL_TYPE) && (LYStripDotDotURLs != '\0')) &&
         ((strip_dots != '\0' &&
          ((**href == '.' && (iVar2 = strncasecomp(local_34,"http",4), iVar2 == 0)))))) {
        str = "";
        aName = HTParse(*href,local_34,0x1f);
        __s1 = HTParse(aName,"",5);
        local_54 = (char *)0x3;
        iVar2 = strncmp(__s1,"/..",3);
        if (iVar2 == 0) {
          cp = __s1 + 3;
          if ((*cp == '/') || (*cp == '\0')) {
            if (local_34[4] == 's') {
              str = "s";
            }
            if (WWW_TraceFlag != '\0') {
              local_54 = *href;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYLegitimizeHREF: Bad value \'%s\' for http%s URL.\n",
                      local_54,str);
              local_50 = str;
            }
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"                  Stripping lead dots.\n",local_54,local_50)
              ;
            }
            if (me->inBadHREF == '\0') {
              local_50 = (char *)gettext("Bad partial reference!  Stripping lead dots.");
              HTUserMsg(local_50);
              me->inBadHREF = '\x01';
            }
          }
          if (*cp == '\0') {
            HTSACopy(href,"/");
          }
          else {
            if (*cp == '/') {
              while (iVar2 = strncmp(cp,"/..",3), iVar2 == 0) {
                if (cp[3] != '/') {
                  if (cp[3] == '\0') {
                    cp[1] = '\0';
                    cp[2] = '\0';
                  }
                  break;
                }
                cp = cp + 3;
              }
              HTSACopy(href,cp);
            }
          }
        }
        if (aName != (char *)0x0) {
          free(aName);
        }
        if (__s1 != (char *)0x0) {
          free(__s1);
        }
      }
    }
  }
  return local_38;
}



void LYCheckForContentBase(HTStructured *me)

{
  UrlTypes UVar1;
  char *value [6];
  BOOLEAN present [6];
  int i;
  char *cp;
  
  cp = (char *)0x0;
  if (me == (HTStructured *)0x0) {
    return;
  }
  if (me->node_anchor == (HTParentAnchor *)0x0) {
    return;
  }
  if (me->node_anchor->content_base == (char *)0x0) {
    if (me->node_anchor->content_location == (char *)0x0) {
      return;
    }
    if (*me->node_anchor->content_location == '\0') {
      return;
    }
    HTSACopy(&cp,me->node_anchor->content_location);
    LYRemoveBlanks(cp);
    UVar1 = is_url(cp);
    if (UVar1 == NOT_A_URL_TYPE) {
      if (cp == (char *)0x0) {
        return;
      }
      free(cp);
      return;
    }
  }
  else {
    if (*me->node_anchor->content_base == '\0') {
      return;
    }
    HTSACopy(&cp,me->node_anchor->content_base);
    LYRemoveBlanks(cp);
  }
  if (*cp == '\0') {
    if (cp != (char *)0x0) {
      free(cp);
    }
  }
  else {
    i = 0;
    while (i < 6) {
      present[i] = '\0';
      i = i + 1;
    }
    present[1] = '\x01';
    value[1] = cp;
    (*me->isa->start_element)(me,10,present,value,0,(char **)0x0);
    if (cp != (char *)0x0) {
      free(cp);
    }
  }
  return;
}



void LYCheckForID(HTStructured *me,BOOLEAN *present,char **value,int attribute)

{
  HTChildAnchor *anc;
  char *temp;
  HTChildAnchor *ID_A;
  
  temp = (char *)0x0;
  if ((((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) && (present != (BOOLEAN *)0x0))
     && (((present[attribute] != '\0' && (value[attribute] != (char *)0x0)) &&
         (*value[attribute] != '\0')))) {
    HTSACopy(&temp,value[attribute]);
    LYUCTranslateHTMLString(&temp,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_URL);
    if (*temp != '\0') {
      anc = HTAnchor_findChildAndLink(me->node_anchor,temp,(char *)0x0,(HTLinkType *)0x0);
      if (anc != (HTChildAnchor *)0x0) {
        HText_beginAnchor(me->text,me->inUnderline,anc);
        HText_endAnchor(me->text,0);
      }
    }
    if (temp != (char *)0x0) {
      free(temp);
    }
  }
  return;
}



void LYHandleID(HTStructured *me,char *id)

{
  HTChildAnchor *anc;
  HTChildAnchor *ID_A;
  
  if ((((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) && (id != (char *)0x0)) &&
     (*id != '\0')) {
    anc = HTAnchor_findChildAndLink(me->node_anchor,id,(char *)0x0,(HTLinkType *)0x0);
    if (anc != (HTChildAnchor *)0x0) {
      HText_beginAnchor(me->text,me->inUnderline,anc);
      HText_endAnchor(me->text,0);
    }
  }
  return;
}



BOOLEAN LYoverride_default_alignment(HTStructured *me)

{
  int iVar1;
  BOOLEAN local_9;
  
  if (me == (HTStructured *)0x0) {
    return '\0';
  }
  iVar1 = me->sp->tag_number;
  if (iVar1 == 0x13) {
LAB_080e3423:
    me->sp->style->alignment = 1;
    local_9 = '\x01';
  }
  else {
    if (iVar1 < 0x14) {
      if ((iVar1 == 3) || (iVar1 == 0x10)) goto LAB_080e3423;
    }
    else {
      if ((iVar1 == 0x2a) || (iVar1 == 0x4e)) goto LAB_080e3423;
    }
    local_9 = '\0';
  }
  return local_9;
}



void LYEnsureDoubleSpace(HTStructured *me)

{
  BOOLEAN BVar1;
  
  if ((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) {
    BVar1 = HText_LastLineEmpty(me->text,'\0');
    if (BVar1 == '\0') {
      HText_setLastChar(me->text,' ');
      HText_appendCharacter(me->text,0xd);
      HText_appendCharacter(me->text,0xd);
    }
    else {
      BVar1 = HText_PreviousLineEmpty(me->text,'\0');
      if (BVar1 == '\0') {
        HText_setLastChar(me->text,' ');
        HText_appendCharacter(me->text,0xd);
      }
      else {
        if (-1 < me->List_Nesting_Level) {
          HText_NegateLineOne(me->text);
        }
      }
    }
    me->in_word = '\0';
  }
  return;
}



void LYEnsureSingleSpace(HTStructured *me)

{
  BOOLEAN BVar1;
  
  if ((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) {
    BVar1 = HText_LastLineEmpty(me->text,'\0');
    if (BVar1 == '\0') {
      HText_setLastChar(me->text,' ');
      HText_appendCharacter(me->text,0xd);
    }
    else {
      if (-1 < me->List_Nesting_Level) {
        HText_NegateLineOne(me->text);
      }
    }
    me->in_word = '\0';
  }
  return;
}



void LYResetParagraphAlignment(HTStructured *me)

{
  if (me != (HTStructured *)0x0) {
    if ((me->List_Nesting_Level < 0) &&
       ((-1 < me->Division_Level || ((me->sp->style->id != 0 && (me->sp->style->id != 0x25)))))) {
      me->sp->style->alignment = (short)me->current_default_alignment;
    }
    else {
      me->sp->style->alignment = 1;
    }
  }
  return;
}



BOOLEAN LYCheckForCSI(HTParentAnchor *anchor,char **url)

{
  BOOLEAN BVar1;
  int iVar2;
  
  if ((((anchor != (HTParentAnchor *)0x0) && (anchor->address != (char *)0x0)) &&
      ((*anchor->address == 'f' || (*anchor->address == 'F')))) &&
     (iVar2 = strncasecomp(anchor->address,"file:",5), iVar2 == 0)) {
    BVar1 = LYisLocalHost(anchor->address);
    if (BVar1 != '\0') {
      HTSACopy(url,anchor->address);
      return '\x01';
    }
    return '\0';
  }
  return '\0';
}



BOOLEAN LYCommentHacks(HTParentAnchor *anchor,char *comment)

{
  char *pcVar1;
  BOOLEAN BVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  size_t sVar6;
  char *p_1;
  char *messageid;
  char *p;
  size_t len;
  char *cp;
  
  if (((comment != (char *)0x0) && (anchor != (HTParentAnchor *)0x0)) &&
     (anchor->address != (char *)0x0)) {
    iVar3 = strncmp(comment,"!--X-Message-Id: ",0x11);
    if (iVar3 == 0) {
      messageid = (char *)0x0;
      cp = comment + 0x11;
      while (((*cp != '\0' && ((byte)*cp < 0x7f)) &&
             (ppuVar4 = __ctype_b_loc(), (short)(*ppuVar4)[(byte)*cp] < 0))) {
        cp = cp + 1;
      }
      iVar3 = strcmp(cp," --");
      if (iVar3 == 0) {
        HTSACopy(&messageid,comment + 0x11);
        BVar2 = LYUCTranslateHTMLString(&messageid,0,0,'\0','\0','\x01',st_URL);
        if (BVar2 != '\0') {
          p = messageid;
          while (((*p != '\0' && ((byte)*p < 0x7f)) &&
                 (ppuVar4 = __ctype_b_loc(), (short)(*ppuVar4)[(byte)*p] < 0))) {
            p = p + 1;
          }
          iVar3 = strcmp(p," --");
          if (iVar3 == 0) {
            pcVar5 = strchr(messageid,0x40);
            pcVar1 = messageid;
            if ((pcVar5 == (char *)0x0) || (pcVar5[1] == '\0')) {
              if (messageid != (char *)0x0) {
                free(messageid);
              }
            }
            else {
              sVar6 = strlen(messageid);
              if ((7 < sVar6) && (iVar3 = strcmp(pcVar1 + (sVar6 - 3)," --"), iVar3 == 0)) {
                pcVar1[sVar6 - 3] = '\0';
                BVar2 = HTAnchor_setMessageID(anchor,messageid);
                if (BVar2 != '\0') {
                  if (messageid != (char *)0x0) {
                    free(messageid);
                  }
                  return '\x01';
                }
                if (messageid != (char *)0x0) {
                  free(messageid);
                }
                return '\0';
              }
              if (messageid != (char *)0x0) {
                free(messageid);
              }
            }
          }
          else {
            if (messageid != (char *)0x0) {
              free(messageid);
            }
          }
        }
      }
    }
    else {
      iVar3 = strncmp(comment,"!--X-Subject: ",0xe);
      if (iVar3 == 0) {
        messageid = (char *)0x0;
        cp = comment + 0xe;
        while (*cp != '\0') {
          if ((0x7e < (byte)*cp) ||
             (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp] & 0x4000) == 0)) {
            return '\0';
          }
          cp = cp + 1;
        }
        HTSACopy(&messageid,comment + 0xe);
        BVar2 = LYUCTranslateHTMLString(&messageid,0,0,'\0','\x01','\0',st_HTML);
        if (BVar2 != '\0') {
          p_1 = messageid;
          while (pcVar1 = messageid, *p_1 != '\0') {
            if ((0x7e < (byte)*p_1) ||
               (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p_1] & 0x4000) == 0)) {
              if (messageid != (char *)0x0) {
                free(messageid);
              }
              return '\0';
            }
            p_1 = p_1 + 1;
          }
          sVar6 = strlen(messageid);
          if ((3 < sVar6) && (iVar3 = strcmp(pcVar1 + (sVar6 - 3)," --"), iVar3 == 0)) {
            pcVar1[sVar6 - 3] = '\0';
            BVar2 = HTAnchor_setSubject(anchor,messageid);
            if (BVar2 != '\0') {
              if (messageid != (char *)0x0) {
                free(messageid);
              }
              return '\x01';
            }
            if (messageid != (char *)0x0) {
              free(messageid);
            }
            return '\0';
          }
          if (messageid != (char *)0x0) {
            free(messageid);
          }
        }
      }
    }
  }
  return '\0';
}



void LYformTitle(char **dst,char *src)

{
  size_t sVar1;
  uchar *euc;
  FILE *__stream;
  char *tmp_buffer;
  
  if (HTCJK == JAPANESE) {
    sVar1 = strlen(src);
    euc = (uchar *)malloc(sVar1 + 1);
    if (euc == (uchar *)0x0) {
      outofmem("./LYCharUtils.c","LYformTitle");
    }
    if (kanji_code == EUC) {
      TO_EUC((uchar *)src,euc);
    }
    else {
      if (kanji_code == SJIS) {
        TO_SJIS((uchar *)src,euc);
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"\nLYformTitle: kanji_code is an unexpected value.");
        }
        strcpy((char *)euc,src);
      }
    }
    HTSACopy(dst,(char *)euc);
    if (euc != (uchar *)0x0) {
      free(euc);
    }
  }
  else {
    HTSACopy(dst,src);
  }
  return;
}



void ImageMapList_free(HTList *theList)

{
  void **local_1c;
  void **local_18;
  HTList *current;
  HTList *cur;
  LYMapElement *element;
  LYImageMap *map;
  
  cur = theList;
  if (theList != (HTList *)0x0) {
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void **)0x0;
      }
      else {
        local_18 = (void **)cur->object;
      }
      if (local_18 == (void **)0x0) break;
      if (*local_18 != (void *)0x0) {
        free(*local_18);
        *local_18 = (void *)0x0;
      }
      if (local_18[1] != (void *)0x0) {
        free(local_18[1]);
        local_18[1] = (void *)0x0;
      }
      if (local_18[2] != (void *)0x0) {
        current = (HTList *)local_18[2];
        while( true ) {
          if ((current == (HTList *)0x0) || (current = current->next, current == (HTList *)0x0)) {
            local_1c = (void **)0x0;
          }
          else {
            local_1c = (void **)current->object;
          }
          if (local_1c == (void **)0x0) break;
          if (*local_1c != (void *)0x0) {
            free(*local_1c);
            *local_1c = (void *)0x0;
          }
          if (local_1c[1] != (void *)0x0) {
            free(local_1c[1]);
            local_1c[1] = (void *)0x0;
          }
          if (local_1c != (void **)0x0) {
            free(local_1c);
          }
        }
        HTList_delete((HTList *)local_18[2]);
        local_18[2] = (void *)0x0;
      }
      if (local_18 != (void **)0x0) {
        free(local_18);
      }
    }
    HTList_delete(theList);
  }
  return;
}



BOOLEAN LYAddImageMap(char *address,char *title,HTParentAnchor *node_anchor)

{
  HTList *me;
  int iVar1;
  BOOLEAN local_31;
  void **local_30;
  LYImageMap *local_2c;
  LYImageMap *local_28;
  LYMapElement *ele;
  HTList *curele;
  HTList *theList;
  HTList *cur;
  LYImageMap *old;
  LYImageMap *tmp;
  
  old = (LYImageMap *)0x0;
  if ((address == (char *)0x0) || (*address == '\0')) {
    local_31 = '\0';
  }
  else {
    if ((node_anchor == (HTParentAnchor *)0x0) || (node_anchor->address == (char *)0x0)) {
      local_31 = '\0';
    }
    else {
      if (LynxMaps == (HTList *)0x0) {
        LynxMaps = HTList_new();
      }
      me = LynxMaps;
      if (LynxMaps != (HTList *)0x0) {
        cur = LynxMaps;
        do {
          do {
            if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
              local_2c = (LYImageMap *)0x0;
            }
            else {
              local_2c = (LYImageMap *)cur->object;
            }
            old = local_2c;
            if (local_2c == (LYImageMap *)0x0) goto LAB_080e3fd3;
          } while (local_2c->address == (char *)0x0);
          iVar1 = strcmp(local_2c->address,address);
        } while (iVar1 != 0);
        if (local_2c->address != (char *)0x0) {
          free(local_2c->address);
          local_2c->address = (char *)0x0;
        }
        if (local_2c->title != (char *)0x0) {
          free(local_2c->title);
          local_2c->title = (char *)0x0;
        }
        if (local_2c->elements != (HTList *)0x0) {
          curele = local_2c->elements;
          while( true ) {
            if ((curele == (HTList *)0x0) || (curele = curele->next, curele == (HTList *)0x0)) {
              local_30 = (void **)0x0;
            }
            else {
              local_30 = (void **)curele->object;
            }
            if (local_30 == (void **)0x0) break;
            if (*local_30 != (void *)0x0) {
              free(*local_30);
              *local_30 = (void *)0x0;
            }
            if (local_30[1] != (void *)0x0) {
              free(local_30[1]);
              local_30[1] = (void *)0x0;
            }
            if (local_30 != (void **)0x0) {
              free(local_30);
            }
          }
          HTList_delete(local_2c->elements);
          local_2c->elements = (HTList *)0x0;
        }
      }
LAB_080e3fd3:
      if (old == (LYImageMap *)0x0) {
        local_28 = (LYImageMap *)calloc(1,0xc);
      }
      else {
        local_28 = old;
      }
      if (local_28 == (LYImageMap *)0x0) {
        outofmem("./LYMap.c","LYAddImageMap");
        local_31 = '\0';
      }
      else {
        HTSACopy((char **)local_28,address);
        if ((title != (char *)0x0) && (*title != '\0')) {
          HTSACopy(&local_28->title,title);
        }
        if (local_28 != old) {
          HTList_addObject(me,local_28);
        }
        local_31 = '\x01';
      }
    }
  }
  return local_31;
}



BOOLEAN LYAddMapElement(char *map,char *address,char *title,HTParentAnchor *node_anchor,
                       BOOLEAN intern_flag)

{
  HTList *pHVar1;
  int iVar2;
  char **dest;
  FILE *__stream;
  BOOLEAN local_2d;
  char **local_2c;
  char **local_28;
  char *local_24;
  char *local_20;
  char *local_1c;
  HTList *cur;
  HTList *theList;
  LYImageMap *theMap;
  LYMapElement *tmp;
  
  if ((((map == (char *)0x0) || (*map == '\0')) || (address == (char *)0x0)) || (*address == '\0'))
  {
    local_2d = '\0';
  }
  else {
    if ((node_anchor == (HTParentAnchor *)0x0) || (node_anchor->address == (char *)0x0)) {
      local_2d = '\0';
    }
    else {
      if (LynxMaps == (HTList *)0x0) {
        LYAddImageMap(map,(char *)0x0,node_anchor);
      }
      cur = LynxMaps;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_2c = (char **)0x0;
        }
        else {
          local_2c = (char **)cur->object;
        }
        if (local_2c == (char **)0x0) break;
        iVar2 = strcmp(*local_2c,map);
      } while (iVar2 != 0);
      if (local_2c == (char **)0x0) {
        local_2d = '\0';
      }
      else {
        if (local_2c[2] == (char *)0x0) {
          pHVar1 = HTList_new();
          *(HTList **)(local_2c + 2) = pHVar1;
        }
        cur = (HTList *)local_2c[2];
        do {
          if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
            local_28 = (char **)0x0;
          }
          else {
            local_28 = (char **)cur->object;
          }
          if (local_28 == (char **)0x0) goto LAB_080e4252;
          iVar2 = strcmp(*local_28,address);
        } while (iVar2 != 0);
        if (*local_28 != (char *)0x0) {
          free(*local_28);
          *local_28 = (char *)0x0;
        }
        if (local_28[1] != (char *)0x0) {
          free(local_28[1]);
          local_28[1] = (char *)0x0;
        }
        HTList_removeObject((HTList *)local_2c[2],local_28);
        if (local_28 != (char **)0x0) {
          free(local_28);
        }
LAB_080e4252:
        dest = (char **)calloc(1,8);
        if (dest == (char **)0x0) {
          perror("Out of memory in LYAddMapElement");
          local_2d = '\0';
        }
        else {
          HTSACopy(dest,address);
          if ((title == (char *)0x0) || (*title == '\0')) {
            HTSACopy(dest + 1,address);
          }
          else {
            HTSACopy(dest + 1,title);
          }
          HTList_appendObject((HTList *)local_2c[2],dest);
          if (WWW_TraceFlag != '\0') {
            if (title == (char *)0x0) {
              local_24 = "";
            }
            else {
              local_24 = title;
            }
            if (address == (char *)0x0) {
              local_20 = "";
            }
            else {
              local_20 = address;
            }
            if (map == (char *)0x0) {
              local_1c = "";
            }
            else {
              local_1c = map;
            }
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYAddMapElement\n\tmap     %s\n\taddress %s\n\ttitle   %s)\n",
                    local_1c,local_20,local_24);
          }
          local_2d = '\x01';
        }
      }
    }
  }
  return local_2d;
}



BOOLEAN LYHaveImageMap(char *address)

{
  int iVar1;
  BOOLEAN local_19;
  char **local_18;
  HTList *cur;
  LYImageMap *Map;
  
  cur = LynxMaps;
  if (((LynxMaps == (HTList *)0x0) || (address == (char *)0x0)) || (*address == '\0')) {
    local_19 = '\0';
  }
  else {
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char **)0x0;
      }
      else {
        local_18 = (char **)cur->object;
      }
      if (local_18 == (char **)0x0) {
        return '\0';
      }
      iVar1 = strcmp(*local_18,address);
    } while (iVar1 != 0);
    local_19 = '\x01';
  }
  return local_19;
}



void fill_DocAddress(DocAddress *wwwdoc,char *address,HTParentAnchor *anAnchor,
                    HTParentAnchor **punderlying)

{
  HTParentAnchor *pHVar1;
  HTParentAnchor *underlying;
  
  if ((anAnchor == (HTParentAnchor *)0x0) || (anAnchor->post_data == (bstring *)0x0)) {
    wwwdoc->address = address;
    wwwdoc->post_data = (bstring *)0x0;
    wwwdoc->post_content_type = (char *)0x0;
    wwwdoc->bookmark = (char *)0x0;
    wwwdoc->isHEAD = '\0';
    wwwdoc->safe = '\0';
    if (punderlying != (HTParentAnchor **)0x0) {
      *punderlying = (HTParentAnchor *)0x0;
    }
  }
  else {
    wwwdoc->address = address;
    wwwdoc->post_data = anAnchor->post_data;
    wwwdoc->post_content_type = anAnchor->post_content_type;
    wwwdoc->bookmark = (char *)0x0;
    wwwdoc->isHEAD = '\0';
    wwwdoc->safe = '\0';
    pHVar1 = HTAnchor_findAddress(wwwdoc);
    if (pHVar1->safe != '\0') {
      wwwdoc->safe = '\x01';
    }
    if (punderlying != (HTParentAnchor **)0x0) {
      *punderlying = pHVar1;
    }
  }
  return;
}



HTList * get_the_list(DocAddress *wwwdoc,char *address,HTParentAnchor *anchor,
                     HTParentAnchor **punderlying)

{
  HTList *local_8;
  
  if ((anchor == (HTParentAnchor *)0x0) || (anchor->post_data == (bstring *)0x0)) {
    fill_DocAddress(wwwdoc,address,(HTParentAnchor *)0x0,punderlying);
    local_8 = LynxMaps;
  }
  else {
    fill_DocAddress(wwwdoc,address,anchor,punderlying);
    if ((punderlying == (HTParentAnchor **)0x0) || (*punderlying == (HTParentAnchor *)0x0)) {
      local_8 = anchor->imaps;
    }
    else {
      local_8 = (*punderlying)->imaps;
    }
  }
  return local_8;
}



int LYLoadIMGmap(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  BOOLEAN BVar3;
  HTFormat pHVar4;
  BOOLEAN BVar5;
  BOOLEAN BVar6;
  HTAtom *rep_in;
  int iVar7;
  char *Msg;
  HTStream *pHVar8;
  char *fmt;
  size_t sVar9;
  LYImageMap *local_70;
  LYImageMap *local_6c;
  undefined *local_68;
  char **local_64;
  undefined *local_60;
  DocAddress WWWDoc;
  HTFormat old_format_out;
  HTParentAnchor *underlying;
  char *cp;
  char *address;
  HTList *cur;
  HTList *theList;
  char *MapAddress;
  char *MapTitle;
  LYImageMap *theMap;
  LYMapElement *tmp;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  BOOLEAN old_reloading;
  BOOLEAN old_cache_setting;
  
  rep_in = HTAtom_for("text/html");
  BVar5 = reloading;
  pHVar4 = HTOutputFormat;
  BVar3 = LYforce_no_cache;
  buf = (char *)0x0;
  MapTitle = (char *)0x0;
  MapAddress = (char *)0x0;
  address = (char *)0x0;
  iVar7 = strncasecomp(arg,"LYNXIMGMAP:",0xb);
  if (iVar7 == 0) {
    address = arg + 0xb;
  }
  if ((address == (char *)0x0) || (Msg = strchr(address,0x3a), Msg == (char *)0x0)) {
    Msg = (char *)gettext("Misdirected client-side image MAP request!");
    HTAlert(Msg);
    return -29999;
  }
  theList = get_the_list(&WWWDoc,address,anAnchor,&underlying);
  if (WWWDoc.safe != '\0') {
    anAnchor->safe = '\x01';
  }
  if (theList == (HTList *)0x0) {
    if ((anAnchor->post_data != (bstring *)0x0) && (WWWDoc.safe == '\0')) {
      if ((underlying != (HTParentAnchor *)0x0) &&
         ((underlying->document != (HyperDoc *)0x0 && (LYforce_no_cache == '\0')))) {
LAB_080e4698:
        Msg = (char *)gettext("Image map from POST response not available!");
        HTAlert(Msg);
        return -29999;
      }
      Msg = (char *)gettext("Document from Form with POST content.  Resubmit?");
      BVar6 = HTConfirm(Msg);
      if (BVar6 != '\x01') goto LAB_080e4698;
    }
    LYforce_no_cache = '\x01';
    reloading = '\x01';
    HTOutputFormat = (HTFormat)HTAtom_for("www/present");
    LYMapsOnly = '\x01';
    BVar6 = HTLoadAbsolute(&WWWDoc);
    if (BVar6 == '\0') {
      LYMapsOnly = '\0';
      LYforce_no_cache = BVar3;
      HTOutputFormat = pHVar4;
      reloading = BVar5;
      Msg = (char *)gettext("Client-side image MAP is not accessible!");
      HTAlert(Msg);
      return -29999;
    }
    LYMapsOnly = '\0';
    LYforce_no_cache = BVar3;
    HTOutputFormat = pHVar4;
    reloading = BVar5;
    theList = get_the_list(&WWWDoc,address,anAnchor,&underlying);
  }
  if (theList == (HTList *)0x0) {
    Msg = (char *)gettext("No client-side image MAPs are available!");
    HTAlert(Msg);
    return -29999;
  }
  cur = theList;
  do {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_70 = (LYImageMap *)0x0;
    }
    else {
      local_70 = (LYImageMap *)cur->object;
    }
    theMap = local_70;
  } while ((local_70 != (LYImageMap *)0x0) &&
          (iVar7 = strcmp(local_70->address,address), iVar7 != 0));
  if ((local_70 != (LYImageMap *)0x0) && (iVar7 = HTList_count(local_70->elements), iVar7 == 0)) {
    if (anAnchor->post_data == (bstring *)0x0) {
      HTSACopy(&redirecting_url,address);
      return 399;
    }
    if ((WWWDoc.safe != '\0') ||
       (((underlying->document != (HyperDoc *)0x0 && (anAnchor->document == (HyperDoc *)0x0)) &&
        ((LYinternal_flag != '\0' || (LYoverride_no_cache != '\0')))))) {
      HTSACopy(&redirecting_url,address);
      redirect_post_content = '\x01';
      return 399;
    }
  }
  if ((local_70 == (LYImageMap *)0x0) || (local_70->elements == (HTList *)0x0)) {
    if ((anAnchor->post_data != (bstring *)0x0) && (WWWDoc.safe == '\0')) {
      if (((underlying != (HTParentAnchor *)0x0) && (underlying->document != (HyperDoc *)0x0)) &&
         (LYforce_no_cache == '\0')) {
LAB_080e48e5:
        Msg = (char *)gettext("Image map from POST response not available!");
        HTAlert(Msg);
        return -29999;
      }
      Msg = (char *)gettext("Document from Form with POST content.  Resubmit?");
      BVar6 = HTConfirm(Msg);
      if (BVar6 != '\x01') goto LAB_080e48e5;
    }
    LYforce_no_cache = '\x01';
    reloading = '\x01';
    HTOutputFormat = (HTFormat)HTAtom_for("www/present");
    LYMapsOnly = '\x01';
    BVar6 = HTLoadAbsolute(&WWWDoc);
    if (BVar6 == '\0') {
      LYMapsOnly = '\0';
      LYforce_no_cache = BVar3;
      HTOutputFormat = pHVar4;
      reloading = BVar5;
      Msg = (char *)gettext("Client-side image MAP is not accessible!");
      HTAlert(Msg);
      return -29999;
    }
    LYMapsOnly = '\0';
    LYforce_no_cache = BVar3;
    HTOutputFormat = pHVar4;
    reloading = BVar5;
    cur = get_the_list(&WWWDoc,address,anAnchor,&underlying);
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_6c = (LYImageMap *)0x0;
      }
      else {
        local_6c = (LYImageMap *)cur->object;
      }
      theMap = local_6c;
    } while ((local_6c != (LYImageMap *)0x0) &&
            (iVar7 = strcmp(local_6c->address,address), iVar7 != 0));
    if ((local_6c == (LYImageMap *)0x0) || (local_6c->elements == (HTList *)0x0)) {
      Msg = (char *)gettext("Client-side image MAP is not available!");
      HTAlert(Msg);
      return -29999;
    }
  }
  anAnchor->no_cache = '\x01';
  pHVar8 = HTStreamStack((HTFormat)rep_in,format_out,sink,anAnchor);
  if ((pHVar8 != (HTStream *)0x0) && (pHVar8 != (HTStream *)0x0)) {
    if ((theMap->title == (char *)0x0) || (*theMap->title == '\0')) {
      if ((anAnchor->title == (char *)0x0) || (*anAnchor->title == '\0')) {
        if (((LYRequestTitle == (char *)0x0) || (*LYRequestTitle == '\0')) ||
           (iVar7 = strcasecomp(LYRequestTitle,"[USEMAP]"), iVar7 == 0)) {
          Msg = strchr(address,0x23);
          if (Msg != (char *)0x0) {
            HTSACopy(&MapTitle,Msg + 1);
          }
        }
        else {
          HTSACopy(&MapTitle,LYRequestTitle);
        }
      }
      else {
        HTSACopy(&MapTitle,anAnchor->title);
      }
    }
    else {
      HTSACopy(&MapTitle,theMap->title);
    }
    if ((MapTitle == (char *)0x0) || (*MapTitle == '\0')) {
      HTSACopy(&MapTitle,"[USEMAP]");
    }
    else {
      LYEntify(&MapTitle,'\x01');
    }
    HTSprintf0(&buf,"<html>\n<head>\n");
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    HTSprintf0(&buf,"<META %s content=\"text/html;charset=%s\">\n","http-equiv=\"content-type\"",
               LYCharSet_UC[current_char_set].MIMEname);
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    HTSprintf0(&buf,"<title>%s</title>\n",MapTitle);
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    HTSprintf0(&buf,"</head>\n<body>\n");
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    HTSprintf0(&buf,"<h1><em>%s</em></h1>\n",MapTitle);
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    HTSACopy(&MapAddress,address);
    LYEntify(&MapAddress,'\0');
    HTSprintf0(&buf,"<h2><em>MAP:</em>&nbsp;%s</h2>\n",MapAddress);
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    if (keypad_mode == 0) {
      local_68 = &DAT_0816def0;
    }
    else {
      local_68 = &DAT_0816def3;
    }
    HTSprintf0(&buf,"<%s compact>\n",local_68);
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    cur = theMap->elements;
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_64 = (char **)0x0;
      }
      else {
        local_64 = (char **)cur->object;
      }
      if (local_64 == (char **)0x0) break;
      HTSACopy(&MapAddress,*local_64);
      LYEntify(&MapAddress,'\0');
      (*pHVar8->isa->put_block)(pHVar8,"<li><a href=\"",0xd);
      paVar2 = pHVar8->isa->put_block;
      sVar9 = strlen(MapAddress);
      (*paVar2)(pHVar8,MapAddress,sVar9);
      (*pHVar8->isa->put_block)(pHVar8,"\"",1);
      (*pHVar8->isa->put_block)(pHVar8,"\n>",2);
      LYformTitle(&MapTitle,local_64[1]);
      LYEntify(&MapTitle,'\x01');
      paVar2 = pHVar8->isa->put_block;
      sVar9 = strlen(MapTitle);
      (*paVar2)(pHVar8,MapTitle,sVar9);
      (*pHVar8->isa->put_block)(pHVar8,"</a>\n",5);
    }
    if (keypad_mode == 0) {
      local_60 = &DAT_0816def0;
    }
    else {
      local_60 = &DAT_0816def3;
    }
    HTSprintf0(&buf,"</%s>\n</body>\n</html>\n",local_60);
    paVar2 = pHVar8->isa->put_block;
    sVar9 = strlen(buf);
    (*paVar2)(pHVar8,buf,sVar9);
    (*pHVar8->isa->_free)(pHVar8);
    if (MapAddress != (char *)0x0) {
      free(MapAddress);
      MapAddress = (char *)0x0;
    }
    if (MapTitle != (char *)0x0) {
      free(MapTitle);
      MapTitle = (char *)0x0;
    }
    if (buf != (char *)0x0) {
      free(buf);
    }
    return 200;
  }
  Msg = format_out->name;
  pcVar1 = rep_in->name;
  fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
  HTSprintf0(&buf,fmt,pcVar1,Msg);
  HTAlert(buf);
  if (buf != (char *)0x0) {
    free(buf);
  }
  return -29999;
}



void LYPrintImgMaps(FILE *fp)

{
  char *__s;
  size_t __n;
  int iVar1;
  char *local_30;
  undefined4 *local_2c;
  char **local_28;
  int count;
  LYMapElement *elt;
  LYImageMap *map;
  HTList *inner;
  HTList *outer;
  int only_len;
  char *only;
  
  __s = HTLoadedDocumentURL();
  __n = strlen(__s);
  outer = LynxMaps;
  iVar1 = HTList_count(LynxMaps);
  if (0 < iVar1) {
    while( true ) {
      if ((outer == (HTList *)0x0) || (outer = outer->next, outer == (HTList *)0x0)) {
        local_28 = (char **)0x0;
      }
      else {
        local_28 = (char **)outer->object;
      }
      if (local_28 == (char **)0x0) break;
      if ((__n == 0) ||
         ((iVar1 = strncmp(__s,*local_28,__n), iVar1 == 0 &&
          (((*local_28)[__n] == '\0' || ((*local_28)[__n] == '#')))))) {
        if ((local_28[1] == (char *)0x0) || (*local_28[1] == '\0')) {
          local_30 = "[USEMAP]";
        }
        else {
          local_30 = local_28[1];
        }
        fprintf((FILE *)fp,"\n%s\n",local_30);
        fprintf((FILE *)fp,"%s\n",*local_28);
        inner = (HTList *)local_28[2];
        count = 0;
        while( true ) {
          if ((inner == (HTList *)0x0) || (inner = inner->next, inner == (HTList *)0x0)) {
            local_2c = (undefined4 *)0x0;
          }
          else {
            local_2c = (undefined4 *)inner->object;
          }
          if (local_2c == (undefined4 *)0x0) break;
          count = count + 1;
          fprintf((FILE *)fp,"%4d. %s",count,*local_2c);
          fputc(10,(FILE *)fp);
        }
      }
    }
  }
  return;
}



void MemAllocCopy(char **dest,char *start,char *end)

{
  char *dst;
  char *temp;
  
  if (((start == (char *)0x0) || (end == (char *)0x0)) || (end <= start)) {
    HTSACopy(dest,"");
  }
  else {
    dst = (char *)calloc((size_t)(end + (1 - (int)start)),1);
    if (dst == (char *)0x0) {
      outofmem("./LYCookie.c","MemAllocCopy");
    }
    LYstrncpy(dst,start,(int)(end + -(int)start));
    HTSACopy(dest,dst);
    if (dst != (char *)0x0) {
      free(dst);
    }
  }
  return;
}



cookie * newCookie(void)

{
  cookie *pstr;
  cookie *p;
  
  pstr = (cookie *)calloc(1,0x38);
  if (pstr == (cookie *)0x0) {
    outofmem("./LYCookie.c","newCookie");
  }
  HTSprintf0((char **)pstr,"%p",pstr);
  pstr->port = 0x50;
  return pstr;
}



void freeCookie(cookie *co)

{
  if (co != (cookie *)0x0) {
    if (co->lynxID != (char *)0x0) {
      free(co->lynxID);
      co->lynxID = (char *)0x0;
    }
    if (co->name != (char *)0x0) {
      free(co->name);
      co->name = (char *)0x0;
    }
    if (co->value != (char *)0x0) {
      free(co->value);
      co->value = (char *)0x0;
    }
    if (co->comment != (char *)0x0) {
      free(co->comment);
      co->comment = (char *)0x0;
    }
    if (co->commentURL != (char *)0x0) {
      free(co->commentURL);
      co->commentURL = (char *)0x0;
    }
    if (co->domain != (char *)0x0) {
      free(co->domain);
      co->domain = (char *)0x0;
    }
    if (co->path != (char *)0x0) {
      free(co->path);
      co->path = (char *)0x0;
    }
    if (co->PortList != (char *)0x0) {
      free(co->PortList);
      co->PortList = (char *)0x0;
    }
    if (co != (cookie *)0x0) {
      free(co);
    }
  }
  return;
}



BOOLEAN host_matches(char *A,char *B)

{
  int iVar1;
  size_t sVar2;
  size_t sVar3;
  int diff;
  
  if ((*B != '.') && (iVar1 = strcasecomp(A,B), iVar1 == 0)) {
    return '\x01';
  }
  if ((((*B == '.') && (B[1] != '\0')) && (B[1] != '.')) && (*A != '.')) {
    sVar2 = strlen(A);
    sVar3 = strlen(B);
    if ((0 < (int)(sVar2 - sVar3)) && (iVar1 = strcasecomp(A + (sVar2 - sVar3),B), iVar1 == 0)) {
      return '\x01';
    }
  }
  return '\0';
}



BOOLEAN port_matches(int port,char *list)

{
  ushort **ppuVar1;
  int iVar2;
  char *number;
  
  number = list;
  if ((list != (char *)0x0) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*list] & 0x800) != 0))
  {
    while (*number != '\0') {
      iVar2 = atoi(number);
      if (iVar2 == port) {
        return '\x01';
      }
      while (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*number] & 0x800) != 0) {
        number = number + 1;
      }
      while ((*number != '\0' &&
             (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*number] & 0x800) == 0))) {
        number = number + 1;
      }
    }
  }
  return '\0';
}



int ignore_trailing_slash(char *a)

{
  int len;
  
  len = strlen(a);
  while ((1 < len && (a[len + -1] == '/'))) {
    len = len + -1;
  }
  return len;
}



BOOLEAN is_prefix(char *a,char *b)

{
  size_t __n;
  int iVar1;
  int iVar2;
  BOOLEAN local_15;
  int len_b;
  int len_a;
  
  __n = ignore_trailing_slash(a);
  iVar1 = ignore_trailing_slash(b);
  if (iVar1 < (int)__n) {
    local_15 = '\0';
  }
  else {
    iVar2 = strncmp(a,b,__n);
    if (iVar2 == 0) {
      if ((((int)__n < iVar1) && (((1 < (int)__n || (*a != '/')) && (b[__n] != '\0')))) &&
         (b[__n] != '/')) {
        local_15 = '\0';
      }
      else {
        local_15 = '\x01';
      }
    }
    else {
      local_15 = '\0';
    }
  }
  return local_15;
}



domain_entry * find_domain_entry(char *name)

{
  invcheck_behaviour_t iVar1;
  behaviour_t bVar2;
  char *pcVar3;
  int iVar4;
  FILE *__stream;
  invcheck_behaviour_t local_28;
  behaviour_t local_24;
  domain_entry *de;
  HTList *hl;
  
  de = (domain_entry *)0x0;
  if ((name != (char *)0x0) && (*name != '\0')) {
    hl = domain_list;
    while (de = (domain_entry *)0x0, hl != (HTList *)0x0) {
      de = (domain_entry *)hl->object;
      if ((de != (domain_entry *)0x0) && (de->domain != (char *)0x0)) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          iVar1 = de->invcheck_bv;
          bVar2 = de->bv;
          pcVar3 = de->domain;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"...test_domain_entry(%s) bv:%u, invcheck_bv:%u\n",pcVar3,bVar2,
                  iVar1);
        }
        iVar4 = strcasecomp(name,de->domain);
        if (iVar4 == 0) break;
      }
      hl = hl->next;
    }
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    if (de == (domain_entry *)0x0) {
      local_28 = ~INVCHECK_QUERY;
      local_24 = ~ACCEPT_ALWAYS;
    }
    else {
      local_28 = de->invcheck_bv;
      local_24 = de->bv;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"find_domain_entry(%s) bv:%d, invcheck_bv:%d\n",name,local_24,local_28)
    ;
  }
  return de;
}



void store_cookie(cookie *co,char *hostname,char *path)

{
  cookie *co_00;
  bool bVar1;
  BOOLEAN BVar2;
  time_t tVar3;
  int iVar4;
  char *pcVar5;
  FILE *__stream;
  size_t sVar6;
  size_t sVar7;
  char *fmt;
  HTList *pHVar8;
  invcheck_behaviour_t local_40;
  invcheck_behaviour_t local_3c;
  char *msg;
  invcheck_behaviour_t invcheck_bv_1;
  invcheck_behaviour_t invcheck_bv;
  int invprompt_reasons;
  domain_entry *de;
  char *ptr;
  int pos;
  time_t now;
  cookie *c2;
  HTList *next;
  HTList *hl;
  BOOLEAN Replacement;
  
  tVar3 = time((time_t *)0x0);
  bVar1 = false;
  invprompt_reasons = 0;
  if (co == (cookie *)0x0) {
    return;
  }
  if (domain_list == (HTList *)0x0) {
    domain_list = HTList_new();
    total_cookies = 0;
  }
  cookie_list = (HTList *)0x0;
  de = find_domain_entry(co->domain);
  if (de != (domain_entry *)0x0) {
    cookie_list = de->cookie_list;
  }
  BVar2 = is_prefix(co->path,path);
  if (BVar2 == '\0') {
    if (de == (domain_entry *)0x0) {
      local_40 = INVCHECK_QUERY;
    }
    else {
      local_40 = de->invcheck_bv;
    }
    if (local_40 == INVCHECK_STRICT) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar5 = co->path;
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "store_cookie: Rejecting because \'%s\' is not a prefix of \'%s\'.\n",pcVar5,path);
      }
      freeCookie(co);
      return;
    }
    if (local_40 == INVCHECK_QUERY) {
      invprompt_reasons = 1;
    }
  }
  iVar4 = strcasecomp(co->domain,hostname);
  if (iVar4 != 0) {
    pcVar5 = strchr(hostname,0x2e);
    if (pcVar5 == (char *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"store_cookie: Rejecting because \'%s\' has no dot.\n",hostname);
      }
      freeCookie(co);
      return;
    }
    if ((*co->domain != '.') || (co->domain[1] == '\0')) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar5 = co->domain;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"store_cookie: Rejecting domain \'%s\'.\n",pcVar5);
      }
      freeCookie(co);
      return;
    }
    pcVar5 = strchr(co->domain + 1,0x2e);
    if ((pcVar5 == (char *)0x0) || (pcVar5[1] == '\0')) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar5 = co->domain;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"store_cookie: Rejecting domain \'%s\'.\n",pcVar5);
      }
      freeCookie(co);
      return;
    }
    BVar2 = host_matches(hostname,co->domain);
    if (BVar2 == '\0') {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar5 = co->domain;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"store_cookie: Rejecting domain \'%s\' for host \'%s\'.\n",pcVar5,
                hostname);
      }
      freeCookie(co);
      return;
    }
    sVar6 = strlen(hostname);
    sVar7 = strlen(co->domain);
    pcVar5 = strchr(hostname,0x2e);
    if (pcVar5 < hostname + (sVar6 - sVar7)) {
      if (de == (domain_entry *)0x0) {
        local_3c = INVCHECK_QUERY;
      }
      else {
        local_3c = de->invcheck_bv;
      }
      if (local_3c == INVCHECK_STRICT) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pcVar5 = co->path;
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "store_cookie: Rejecting because \'%s\' is not a prefix of \'%s\'.\n",pcVar5,path)
          ;
        }
        freeCookie(co);
        return;
      }
      if (local_3c == INVCHECK_QUERY) {
        invprompt_reasons = invprompt_reasons | 2;
      }
    }
  }
  if (invprompt_reasons != 0) {
    msg = (char *)0x0;
    if ((invprompt_reasons & 2U) != 0) {
      pcVar5 = co->domain;
      fmt = (char *)gettext("Accept invalid cookie domain=%s for \'%s\'?");
      HTSprintf0(&msg,fmt,pcVar5,hostname);
      iVar4 = HTForcedPrompt(cookie_noprompt,msg,0);
      if (iVar4 == 0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pcVar5 = co->domain;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"store_cookie: Rejecting domain \'%s\' for host \'%s\'.\n",pcVar5
                  ,hostname);
        }
        freeCookie(co);
        if (msg == (char *)0x0) {
          return;
        }
        free(msg);
        return;
      }
    }
    if ((invprompt_reasons & 1U) != 0) {
      pcVar5 = co->path;
      fmt = (char *)gettext("Accept invalid cookie path=%s as a prefix of \'%s\'?");
      HTSprintf0(&msg,fmt,pcVar5,path);
      iVar4 = HTForcedPrompt(cookie_noprompt,msg,0);
      if (iVar4 == 0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pcVar5 = co->path;
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "store_cookie: Rejecting because \'%s\' is not a prefix of \'%s\'.\n",pcVar5,path)
          ;
        }
        freeCookie(co);
        if (msg == (char *)0x0) {
          return;
        }
        free(msg);
        return;
      }
    }
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
  }
  if (de == (domain_entry *)0x0) {
    de = (domain_entry *)calloc(1,0x10);
    if (de == (domain_entry *)0x0) {
      outofmem("./LYCookie.c","store_cookie");
    }
    de->bv = QUERY_USER;
    de->invcheck_bv = INVCHECK_QUERY;
    pHVar8 = HTList_new();
    de->cookie_list = pHVar8;
    cookie_list = de->cookie_list;
    HTSACopy((char **)de,co->domain);
    HTList_appendObject(domain_list,de);
  }
  hl = cookie_list;
  pos = 0;
  while (hl != (HTList *)0x0) {
    co_00 = (cookie *)hl->object;
    hl = hl->next;
    if (((co_00 == (cookie *)0x0) || ((co_00->flags & 4U) == 0)) || (tVar3 < co_00->expires)) {
      if (((co_00 == (cookie *)0x0) || (iVar4 = strcasecomp(co->domain,co_00->domain), iVar4 != 0))
         || ((iVar4 = strcmp(co->path,co_00->path), iVar4 != 0 ||
             (iVar4 = strcmp(co->name,co_00->name), iVar4 != 0)))) {
        if ((co_00 != (cookie *)0x0) && (co->pathlen <= co_00->pathlen)) {
          pos = pos + 1;
        }
      }
      else {
        HTList_removeObject(cookie_list,co_00);
        freeCookie(co_00);
        total_cookies = total_cookies + -1;
        bVar1 = true;
      }
    }
    else {
      HTList_removeObject(cookie_list,co_00);
      freeCookie(co_00);
      total_cookies = total_cookies + -1;
    }
  }
  if (((co->flags & 4U) == 0) || (tVar3 < co->expires)) {
    iVar4 = HTList_count(cookie_list);
    if (max_cookies_domain < iVar4) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "store_cookie: Domain\'s cookie limit exceeded!  Rejecting cookie.\n");
      }
      freeCookie(co);
    }
    else {
      if (max_cookies_global < total_cookies) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n"
                 );
        }
        freeCookie(co);
      }
      else {
        if (co->value == (char *)0x0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"store_cookie: Value is NULL! Not storing cookie.\n");
          }
          freeCookie(co);
        }
        else {
          if (((bVar1) && (de != (domain_entry *)0x0)) && (de->bv != REJECT_ALWAYS)) {
            HTList_insertObjectAt(cookie_list,co,pos);
            total_cookies = total_cookies + 1;
          }
          else {
            if (((co->flags & 0x20U) == 0) &&
               (BVar2 = HTConfirmCookie(de,hostname,co->name,co->value), BVar2 == '\0')) {
              freeCookie(co);
            }
            else {
              HTList_insertObjectAt(cookie_list,co,pos);
              total_cookies = total_cookies + 1;
            }
          }
        }
      }
    }
  }
  else {
    freeCookie(co);
  }
  return;
}



char * scan_cookie_sublist(char *hostname,char *path,int port,HTList *sublist,char *header,
                          BOOLEAN secure)

{
  int iVar1;
  HTList *pHVar2;
  BOOLEAN BVar3;
  time_t tVar4;
  char *pcVar5;
  FILE *__stream;
  size_t sVar6;
  size_t sVar7;
  ushort **ppuVar8;
  int in_GS_OFFSET;
  char *local_58;
  char *local_54;
  char *local_50;
  undefined4 local_4c;
  char *local_40;
  char *local_38;
  HTList *local_34;
  char *local_30;
  char *local_2c;
  int len;
  time_t now;
  cookie *co;
  HTList *next;
  HTList *hl;
  char crlftab [8];
  
  local_2c = hostname;
  local_30 = path;
  local_34 = sublist;
  local_38 = header;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  hl = sublist;
  tVar4 = time((time_t *)0x0);
  len = 0;
  sprintf(crlftab,"%c%c%c",0xd,10,9);
  while (hl != (HTList *)0x0) {
    co = (cookie *)hl->object;
    pHVar2 = hl->next;
    if ((co != (cookie *)0x0) && (pcVar5 = LYstrstr(local_2c,co->domain), pcVar5 != (char *)0x0)) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        if (co->value == (char *)0x0) {
          local_58 = "(no value)";
        }
        else {
          local_58 = co->value;
        }
        if (co->name == (char *)0x0) {
          local_54 = "(no name)";
        }
        else {
          local_54 = co->name;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Checking cookie %p %s=%s\n",hl,local_54,local_58);
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        if ((co->flags & 1U) == 0) {
          local_50 = "";
        }
        else {
          local_50 = " secure";
        }
        if ((co->pathlen < 1) || (BVar3 = is_prefix(co->path,local_30), BVar3 != '\0')) {
          local_4c = 0;
        }
        else {
          local_4c = 1;
        }
        pcVar5 = co->path;
        BVar3 = host_matches(local_2c,co->domain);
        if (co->domain == (char *)0x0) {
          local_40 = "(no domain)";
        }
        else {
          local_40 = co->domain;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\t%s %s %d %s %s %d%s\n",local_2c,local_40,(int)BVar3,local_30,
                pcVar5,local_4c,local_50);
      }
    }
    if (((co != (cookie *)0x0) && ((co->flags & 4U) != 0)) && (co->expires <= tVar4)) {
      HTList_removeObject(local_34,co);
      freeCookie(co);
      co = (cookie *)0x0;
      total_cookies = total_cookies + -1;
    }
    hl = pHVar2;
    if (((((co != (cookie *)0x0) && (BVar3 = host_matches(local_2c,co->domain), BVar3 != '\0')) &&
         ((co->pathlen == 0 || (BVar3 = is_prefix(co->path,local_30), BVar3 != '\0')))) &&
        (((co->flags & 1U) == 0 || (secure != '\0')))) &&
       ((co->PortList == (char *)0x0 || (BVar3 = port_matches(port,co->PortList), BVar3 != '\0'))))
    {
      if (local_38 == (char *)0x0) {
        if (0 < co->version) {
          HTSprintf0(&local_38,"$Version=\"%d\"; ",co->version);
          sVar6 = strlen(local_38);
          len = sVar6 + len;
        }
      }
      else {
        HTSACat(&local_38,"; ");
      }
      HTSACat(&local_38,co->name);
      HTSACat(&local_38,"=");
      if (co->quoted != '\0') {
        HTSACat(&local_38,"\"");
        len = len + 1;
      }
      HTSACat(&local_38,co->value);
      if (co->quoted != '\0') {
        HTSACat(&local_38,"\"");
        len = len + 1;
      }
      sVar6 = strlen(co->name);
      sVar7 = strlen(co->value);
      len = sVar6 + sVar7 + len + 1;
      if (0 < co->version) {
        if ((co->path != (char *)0x0) && ((co->flags & 0x10U) != 0)) {
          HTSACat(&local_38,"; $Path=\"");
          HTSACat(&local_38,co->path);
          HTSACat(&local_38,"\"");
          sVar6 = strlen(co->path);
          len = sVar6 + len + 10;
        }
        if ((co->PortList != (char *)0x0) &&
           (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)*co->PortList] & 0x800) != 0)) {
          HTSACat(&local_38,"; $Port=\"");
          HTSACat(&local_38,co->PortList);
          HTSACat(&local_38,"\"");
          sVar6 = strlen(co->PortList);
          len = sVar6 + len + 10;
        }
        if ((co->domain != (char *)0x0) && ((co->flags & 8U) != 0)) {
          HTSACat(&local_38,"; $Domain=\"");
          HTSACat(&local_38,co->domain);
          HTSACat(&local_38,"\"");
          sVar6 = strlen(co->domain);
          len = sVar6 + len + 0xc;
        }
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_38;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * alloc_attr_value(char *value_start,char *value_end)

{
  int value_len;
  char *value;
  
  value = (char *)0x0;
  if ((value_start != (char *)0x0) && (value_start <= value_end)) {
    value_len = (int)(value_end + -(int)value_start);
    if (max_cookies_buffer < value_len) {
      value_len = max_cookies_buffer;
    }
    value = (char *)calloc(value_len + 1,1);
    if (value == (char *)0x0) {
      outofmem("./LYCookie.c","LYProcessSetCookies");
    }
    LYstrncpy(value,value_start,value_len);
  }
  return value;
}



uint parse_attribute(uint flags,cookie *cur_cookie,int *cookie_len,char *attr_start,int attr_len,
                    char *value,char *address,char *hostname,int port)

{
  uint uVar1;
  bool bVar2;
  BOOLEAN BVar3;
  int iVar4;
  size_t sVar5;
  char *pcVar6;
  UrlTypes UVar7;
  FILE *__stream;
  ushort **ppuVar8;
  long lVar9;
  int *piVar10;
  time_t tVar11;
  time_t tVar12;
  int temp_1;
  int temp;
  char *cp;
  char *ptr;
  int url_type;
  BOOLEAN known_attr;
  
  bVar2 = false;
  uVar1 = flags & 0xfffffffd;
  if (attr_len == 6) {
    iVar4 = strncasecomp(attr_start,"secure",6);
    if (iVar4 == 0) {
      if (value == (char *)0x0) {
        bVar2 = true;
        if (cur_cookie != (cookie *)0x0) {
          cur_cookie->flags = cur_cookie->flags | 1;
        }
      }
      else {
        bVar2 = false;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"discard",7);
    if (iVar4 == 0) {
      if (value == (char *)0x0) {
        bVar2 = true;
        if (cur_cookie != (cookie *)0x0) {
          cur_cookie->flags = cur_cookie->flags | 2;
        }
      }
      else {
        bVar2 = false;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"comment",7);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) &&
         (cur_cookie->comment == (char *)0x0)) {
        HTSACopy(&cur_cookie->comment,value);
        iVar4 = *cookie_len;
        sVar5 = strlen(cur_cookie->comment);
        *cookie_len = iVar4 + sVar5;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 10) {
    iVar4 = strncasecomp(attr_start,"commentURL",10);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) &&
         (cur_cookie->commentURL == (char *)0x0)) {
        pcVar6 = HTParse(value,address,0x1f);
        cur_cookie->commentURL = pcVar6;
        UVar7 = is_url(cur_cookie->commentURL);
        if ((UVar7 == NOT_A_URL_TYPE) || ((UVar7 != HTTP_URL_TYPE && (UVar7 != HTTPS_URL_TYPE)))) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pcVar6 = cur_cookie->commentURL;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYProcessSetCookies: Rejecting commentURL value \'%s\'\n",
                    pcVar6);
          }
          if (cur_cookie->commentURL != (char *)0x0) {
            free(cur_cookie->commentURL);
            cur_cookie->commentURL = (char *)0x0;
          }
        }
        else {
          iVar4 = *cookie_len;
          sVar5 = strlen(cur_cookie->commentURL);
          *cookie_len = iVar4 + sVar5;
        }
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 6) {
    iVar4 = strncasecomp(attr_start,"domain",6);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie == (cookie *)0x0) || (value == (char *)0x0)) ||
         ((cur_cookie->flags & 8U) != 0)) goto LAB_080e700e;
      iVar4 = *cookie_len;
      sVar5 = strlen(cur_cookie->domain);
      *cookie_len = iVar4 - sVar5;
      if (((*value != '.') && (*value != '\0')) && (value[1] != '\0')) {
        iVar4 = strcasecomp(value,hostname);
        if (iVar4 != 0) {
          pcVar6 = strchr(value,0x2e);
          if ((pcVar6 != (char *)0x0) && (pcVar6[1] != '\0')) {
            ptr = value;
            do {
              if (*ptr != '.') {
                ppuVar8 = __ctype_b_loc();
                if (((*ppuVar8)[(byte)*ptr] & 0x800) == 0) goto code_r0x080e6a85;
              }
              ptr = ptr + 1;
            } while( true );
          }
          HTSACopy(&cur_cookie->domain,value);
          goto LAB_080e6b34;
        }
      }
      HTSACopy(&cur_cookie->domain,value);
      goto LAB_080e6b34;
    }
  }
  if (attr_len == 4) {
    iVar4 = strncasecomp(attr_start,"path",4);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) &&
         ((cur_cookie->flags & 0x10U) == 0)) {
        iVar4 = *cookie_len;
        sVar5 = strlen(cur_cookie->path);
        *cookie_len = iVar4 - sVar5;
        HTSACopy(&cur_cookie->path,value);
        iVar4 = *cookie_len;
        sVar5 = strlen(cur_cookie->path);
        cur_cookie->pathlen = sVar5;
        *cookie_len = iVar4 + cur_cookie->pathlen;
        cur_cookie->flags = cur_cookie->flags | 0x10;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 4) {
    iVar4 = strncasecomp(attr_start,"port",4);
    if (iVar4 == 0) {
      if (((cur_cookie == (cookie *)0x0) || (value == (char *)0x0)) ||
         (cur_cookie->PortList != (char *)0x0)) {
        if (cur_cookie != (cookie *)0x0) {
          if (cur_cookie->PortList == (char *)0x0) {
            HTSprintf0(&cur_cookie->PortList,"%d",port);
            iVar4 = *cookie_len;
            sVar5 = strlen(cur_cookie->PortList);
            *cookie_len = iVar4 + sVar5;
          }
          bVar2 = true;
        }
      }
      else {
        cp = value;
        while (*cp != '\0') {
          ppuVar8 = __ctype_b_loc();
          if (((((*ppuVar8)[(byte)*cp] & 0x800) == 0) && (*cp != ',')) && (*cp != ' ')) break;
          cp = cp + 1;
        }
        if (*cp == '\0') {
          BVar3 = port_matches(port,value);
          if (BVar3 == '\0') {
            flags = uVar1 | 1;
          }
          else {
            HTSACopy(&cur_cookie->PortList,value);
            iVar4 = *cookie_len;
            sVar5 = strlen(cur_cookie->PortList);
            *cookie_len = iVar4 + sVar5;
            flags = uVar1;
          }
          bVar2 = true;
          uVar1 = flags;
        }
        else {
          bVar2 = false;
        }
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"version",7);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) && (cur_cookie->version < 1)) {
        lVar9 = strtol(value,(char **)0x0,10);
        piVar10 = __errno_location();
        if (*piVar10 != -0x22) {
          cur_cookie->version = lVar9;
        }
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"max-age",7);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) && ((flags & 4) == 0)) {
        lVar9 = strtol(value,(char **)0x0,10);
        cur_cookie->flags = cur_cookie->flags | 4;
        piVar10 = __errno_location();
        if (*piVar10 == -0x22) {
          cur_cookie->expires = 0;
        }
        else {
          tVar11 = time((time_t *)0x0);
          cur_cookie->expires = tVar11 + lVar9;
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pcVar6 = ctime(&cur_cookie->expires);
            tVar12 = cur_cookie->expires;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYSetCookie: expires %d, %s",tVar12,pcVar6);
          }
        }
        uVar1 = uVar1 | 4;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"expires",7);
    if ((((iVar4 == 0) && (bVar2 = true, cur_cookie != (cookie *)0x0)) && ((flags & 4) == 0)) &&
       (((cur_cookie->flags & 4U) == 0 && (value != (char *)0x0)))) {
      cur_cookie->flags = cur_cookie->flags | 4;
      tVar12 = LYmktime(value,'\0');
      cur_cookie->expires = tVar12;
      if ((0 < cur_cookie->expires) && ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 0x20U) != 0))))
      {
        pcVar6 = ctime(&cur_cookie->expires);
        tVar12 = cur_cookie->expires;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYSetCookie: expires %d, %s",tVar12,pcVar6);
      }
    }
  }
  goto LAB_080e700e;
code_r0x080e6a85:
  if (*ptr == '\0') {
    HTSACopy(&cur_cookie->domain,value);
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYProcessSetCookies: Adding lead dot for domain value \'%s\'\n",
              value);
    }
    HTSACopy(&cur_cookie->domain,".");
    HTSACat(&cur_cookie->domain,value);
  }
LAB_080e6b34:
  iVar4 = *cookie_len;
  sVar5 = strlen(cur_cookie->domain);
  *cookie_len = iVar4 + sVar5;
  cur_cookie->flags = cur_cookie->flags | 8;
LAB_080e700e:
  flags = uVar1;
  if (bVar2) {
    flags = flags | 2;
  }
  return flags;
}



void LYProcessSetCookies(char *SetCookie,char *SetCookie2,char *address,char *hostname,char *path,
                        int port)

{
  time_t tVar1;
  bool bVar2;
  char *end;
  HTList *me;
  FILE *__stream;
  byte *pbVar3;
  ushort **ppuVar4;
  char *value_00;
  size_t sVar5;
  char *a;
  int iVar6;
  char *local_cc;
  char *local_c4;
  char *local_c0;
  char *local_bc;
  char *local_b8;
  char *local_b4;
  char *local_b0;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *local_9c;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char *local_74;
  cookie *local_70;
  char *value_1;
  char *cp1_1;
  char *cp_1;
  int spaces_1;
  char *value;
  char *cp1;
  char *cp;
  int spaces;
  uint parse_flags;
  int NumCookies;
  int cookie_len;
  cookie *co;
  cookie *cur_cookie;
  HTList *cl;
  HTList *CombinedCookies;
  char *value_end;
  char *value_start;
  char *attr_end;
  char *attr_start;
  char *p;
  BOOLEAN escaped_1;
  BOOLEAN escaped;
  BOOLEAN Quoted;
  
  cur_cookie = (cookie *)0x0;
  cookie_len = 0;
  NumCookies = 0;
  Quoted = '\0';
  parse_flags = 0;
  if (((SetCookie != (char *)0x0) && (*SetCookie != '\0')) ||
     ((SetCookie2 != (char *)0x0 && (*SetCookie2 != '\0')))) {
    me = HTList_new();
    if (SetCookie2 == (char *)0x0) {
      local_cc = "";
    }
    else {
      local_cc = SetCookie2;
    }
    p = local_cc;
    if ((((SetCookie != (char *)0x0) && (*local_cc != '\0')) && (WWW_TraceFlag != '\0')) &&
       ((WWW_TraceMask & 0x20U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYProcessSetCookies: Using Set-Cookie2 header.\n");
    }
    while ((NumCookies <= max_cookies_domain && (*p != '\0'))) {
      value_end = (char *)0x0;
      value_start = (char *)0x0;
      a = LYSkipCBlanks(p);
      p = a;
      while (((end = p, *p != '\0' &&
              (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x2000) == 0)) &&
             ((*p != '=' && ((*p != ';' && (*p != ','))))))) {
        p = p + 1;
      }
      p = LYSkipCBlanks(p);
      if ((*p == '=') || (iVar6 = strncasecomp(a,"Expires",7), iVar6 == 0)) {
        if (*p == '=') {
          p = p + 1;
        }
        value_start = LYSkipCBlanks(p);
        p = value_start;
        if ((end + -(int)a == (char *)0x7) && (iVar6 = strncasecomp(a,"Expires",7), iVar6 == 0)) {
          ppuVar4 = __ctype_b_loc();
          if (((*ppuVar4)[(byte)*value_start] & 0x800) == 0) {
            while ((*p != '\0' && (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x400) != 0)))
            {
              p = p + 1;
            }
            while ((*p == ',' || (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x2000) != 0)))
            {
              p = p + 1;
            }
            spaces = 5;
          }
          else {
            spaces = 5;
          }
          while ((((*p != '\0' && (*p != ';')) && (*p != ',')) && (spaces != 0))) {
            p = p + 1;
            ppuVar4 = __ctype_b_loc();
            if (((*ppuVar4)[(byte)*p] & 0x2000) == 0) {
              if (*p == 0x2d) {
                spaces = spaces + -1;
              }
            }
            else {
              while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)p[1]] & 0x2000) != 0) {
                p = p + 1;
              }
              spaces = spaces + -1;
            }
          }
          value_end = p;
        }
        else {
          if ((end + -(int)a == &DAT_00000004) &&
             ((iVar6 = strncasecomp(a,"port",4), iVar6 == 0 &&
              (ppuVar4 = __ctype_b_loc(), pbVar3 = (byte *)value_start,
              ((*ppuVar4)[(byte)*value_start] & 0x800) != 0)))) {
            do {
              while (p = (char *)pbVar3, ppuVar4 = __ctype_b_loc(),
                    ((*ppuVar4)[(byte)*p] & 0x800) != 0) {
                pbVar3 = (byte *)(p + 1);
              }
              value_end = p;
              p = LYSkipCBlanks(p);
              if ((*p == '\0') || (*p == ';')) goto LAB_080e771a;
              if ((*p != ',') ||
                 ((pbVar3 = (byte *)LYSkipCBlanks(p + 1), *pbVar3 == 0 ||
                  (ppuVar4 = __ctype_b_loc(), cp1 = (char *)pbVar3,
                  ((*ppuVar4)[*pbVar3] & 0x800) == 0)))) break;
              while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp1] & 0x800) != 0) {
                cp1 = cp1 + 1;
              }
              value_00 = LYSkipCBlanks(cp1);
            } while (((*value_00 == '\0') || (*value_00 == ',')) || (*value_00 == ';'));
            while (((*p != '\0' && (*p != ';')) && (*p != ','))) {
              p = p + 1;
            }
            value_end = p;
            if ((value_start < p) &&
               (ppuVar4 = __ctype_b_loc(), value_00 = p, ((*ppuVar4)[(byte)p[-1]] & 0x2000) != 0)) {
              while (value_end = value_00 + -1, (byte *)value_start + 1 < value_end) {
                ppuVar4 = __ctype_b_loc();
                if ((((*ppuVar4)[(byte)*value_end] & 0x2000) == 0) ||
                   (ppuVar4 = __ctype_b_loc(), pbVar3 = (byte *)(value_00 + -2),
                   value_00 = value_end, ((*ppuVar4)[*pbVar3] & 0x2000) == 0)) break;
              }
            }
          }
          else {
            if (*value_start == 0x22) {
              bVar2 = false;
              pbVar3 = (byte *)value_start + 1;
              p = (char *)pbVar3;
              while ((*p != '\0' && ((*p != '\"' || (bVar2))))) {
                if ((bVar2) || (*p != '\\')) {
                  bVar2 = false;
                }
                else {
                  bVar2 = true;
                }
                p = p + 1;
              }
              if ((((byte *)p == pbVar3) || (*p != '\"')) || (bVar2)) {
                value_end = p;
                if (*p != '\0') {
                  p = p + 1;
                }
                Quoted = '\0';
              }
              else {
                value_end = p;
                p = p + 1;
                Quoted = '\x01';
                value_start = (char *)pbVar3;
              }
            }
            else {
              while (((*p != '\0' && (*p != ';')) && (*p != ','))) {
                p = p + 1;
              }
              value_end = p;
              if ((value_start < p) &&
                 (ppuVar4 = __ctype_b_loc(), value_00 = p, ((*ppuVar4)[(byte)p[-1]] & 0x2000) != 0))
              {
                while (value_end = value_00 + -1, (byte *)value_start + 1 < value_end) {
                  ppuVar4 = __ctype_b_loc();
                  if ((((*ppuVar4)[(byte)*value_end] & 0x2000) == 0) ||
                     (ppuVar4 = __ctype_b_loc(), pbVar3 = (byte *)(value_00 + -2),
                     value_00 = value_end, ((*ppuVar4)[*pbVar3] & 0x2000) == 0)) break;
                }
              }
            }
          }
        }
      }
LAB_080e771a:
      if ((*p == ';') || (*p == ',')) {
        p = p + 1;
      }
      if (a < end) {
        value_00 = alloc_attr_value(value_start,value_end);
        local_c0 = (char *)&cookie_len;
        local_c4 = a;
        parse_flags = parse_attribute(parse_flags,cur_cookie,(int *)local_c0,a,(int)(end + -(int)a),
                                      value_00,address,hostname,port);
        if ((((parse_flags & 2) == 0) && (value_00 != (char *)0x0)) && (value_start <= value_end)) {
          if (((max_cookies_buffer < cookie_len) || (cur_cookie == (cookie *)0x0)) ||
             ((parse_flags & 1) != 0)) {
            if (cur_cookie != (cookie *)0x0) {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                if (cur_cookie->value == (char *)0x0) {
                  local_c4 = "[no value]";
                }
                else {
                  local_c4 = cur_cookie->value;
                }
                if (cur_cookie->name == (char *)0x0) {
                  local_c0 = "[no name]";
                }
                else {
                  local_c0 = cur_cookie->name;
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
                        local_c0,local_c4);
              }
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                if ((parse_flags & 1) == 0) {
                  local_bc = "                     due to invalid port!\n";
                }
                else {
                  local_bc = "                     due to excessive length!\n";
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,local_bc,local_c0,local_c4);
              }
              if ((parse_flags & 1) != 0) {
                NumCookies = NumCookies + -1;
              }
              freeCookie(cur_cookie);
            }
          }
          else {
            if (cur_cookie->version < 1) {
              cur_cookie->version = 1;
            }
            HTList_appendObject(me,cur_cookie);
          }
          cur_cookie = newCookie();
          cookie_len = 0;
          NumCookies = NumCookies + 1;
          MemAllocCopy(&cur_cookie->name,a,end);
          sVar5 = strlen(cur_cookie->name);
          cookie_len = sVar5 + cookie_len;
          MemAllocCopy(&cur_cookie->value,value_start,value_end);
          sVar5 = strlen(cur_cookie->value);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->domain,hostname);
          sVar5 = strlen(cur_cookie->domain);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->path,path);
          sVar5 = strlen(cur_cookie->path);
          cur_cookie->pathlen = sVar5;
          cookie_len = cur_cookie->pathlen + cookie_len;
          cur_cookie->port = port;
          parse_flags = 0;
          cur_cookie->quoted = '\x01';
        }
        if (value_00 != (char *)0x0) {
          free(value_00);
        }
      }
    }
    if ((((max_cookies_domain < NumCookies) || (max_cookies_buffer < cookie_len)) ||
        (cur_cookie == (cookie *)0x0)) || ((parse_flags & 1) != 0)) {
      if ((cur_cookie == (cookie *)0x0) || ((parse_flags & 1) != 0)) {
        if (cur_cookie != (cookie *)0x0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            if (cur_cookie->value == (char *)0x0) {
              local_a4 = "[no value]";
            }
            else {
              local_a4 = cur_cookie->value;
            }
            if (cur_cookie->name == (char *)0x0) {
              local_a0 = "[no name]";
            }
            else {
              local_a0 = cur_cookie->name;
            }
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",local_a0,
                    local_a4);
          }
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"                     due to invalid port!\n");
          }
          freeCookie(cur_cookie);
        }
      }
      else {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (cur_cookie->value == (char *)0x0) {
            local_b8 = "[no value]";
          }
          else {
            local_b8 = cur_cookie->value;
          }
          if (cur_cookie->name == (char *)0x0) {
            local_b4 = "[no name]";
          }
          else {
            local_b4 = cur_cookie->name;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",local_b4,
                  local_b8);
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (max_cookies_domain < NumCookies) {
            local_b0 = "number!\n";
          }
          else {
            local_b0 = "!\n";
          }
          if ((max_cookies_buffer < cookie_len) && (max_cookies_domain < NumCookies)) {
            local_ac = " and ";
          }
          else {
            local_ac = "";
          }
          if (max_cookies_buffer < cookie_len) {
            local_a8 = "length";
          }
          else {
            local_a8 = "";
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"                     due to excessive %s%s%s\n",local_a8,
                  local_ac,local_b0);
        }
        freeCookie(cur_cookie);
      }
    }
    else {
      if (cur_cookie->version < 1) {
        cur_cookie->version = 1;
      }
      HTList_appendObject(me,cur_cookie);
    }
    cookie_len = 0;
    NumCookies = 0;
    cur_cookie = (cookie *)0x0;
    if ((SetCookie == (char *)0x0) || ((SetCookie2 != (char *)0x0 && (*SetCookie2 != '\0')))) {
      local_9c = "";
    }
    else {
      local_9c = SetCookie;
    }
    p = local_9c;
    if ((((SetCookie2 != (char *)0x0) && (*local_9c != '\0')) && (WWW_TraceFlag != '\0')) &&
       ((WWW_TraceMask & 0x20U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYProcessSetCookies: Using Set-Cookie header.\n");
    }
    while ((NumCookies <= max_cookies_domain && (*p != '\0'))) {
      value_end = (char *)0x0;
      value_start = (char *)0x0;
      a = LYSkipCBlanks(p);
      p = a;
      while (((end = p, *p != '\0' &&
              (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x2000) == 0)) &&
             ((*p != '=' && ((*p != ';' && (*p != ','))))))) {
        p = p + 1;
      }
      p = LYSkipCBlanks(p);
      if ((*p == '=') || (iVar6 = strncasecomp(a,"Expires",7), iVar6 == 0)) {
        if (*p == '=') {
          p = p + 1;
        }
        value_start = LYSkipCBlanks(p);
        p = value_start;
        if ((end + -(int)a == (char *)0x7) && (iVar6 = strncasecomp(a,"Expires",7), iVar6 == 0)) {
          ppuVar4 = __ctype_b_loc();
          if (((*ppuVar4)[(byte)*value_start] & 0x800) == 0) {
            while ((*p != '\0' && (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x400) != 0)))
            {
              p = p + 1;
            }
            while ((*p == ',' || (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x2000) != 0)))
            {
              p = p + 1;
            }
            spaces_1 = 5;
          }
          else {
            spaces_1 = 5;
          }
          while ((((*p != '\0' && (*p != ';')) && (*p != ',')) && (spaces_1 != 0))) {
            p = p + 1;
            ppuVar4 = __ctype_b_loc();
            if (((*ppuVar4)[(byte)*p] & 0x2000) == 0) {
              if (*p == 0x2d) {
                spaces_1 = spaces_1 + -1;
              }
            }
            else {
              while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)p[1]] & 0x2000) != 0) {
                p = p + 1;
              }
              spaces_1 = spaces_1 + -1;
            }
          }
          value_end = p;
        }
        else {
          if ((end + -(int)a == &DAT_00000004) &&
             ((iVar6 = strncasecomp(a,"port",4), iVar6 == 0 &&
              (ppuVar4 = __ctype_b_loc(), pbVar3 = (byte *)value_start,
              ((*ppuVar4)[(byte)*value_start] & 0x800) != 0)))) {
            do {
              while (p = (char *)pbVar3, ppuVar4 = __ctype_b_loc(),
                    ((*ppuVar4)[(byte)*p] & 0x800) != 0) {
                pbVar3 = (byte *)(p + 1);
              }
              value_end = p;
              p = LYSkipCBlanks(p);
              if ((*p == '\0') || (*p == ';')) goto LAB_080e837e;
              if ((*p != ',') ||
                 ((pbVar3 = (byte *)LYSkipCBlanks(p + 1), *pbVar3 == 0 ||
                  (ppuVar4 = __ctype_b_loc(), cp1_1 = (char *)pbVar3,
                  ((*ppuVar4)[*pbVar3] & 0x800) == 0)))) break;
              while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp1_1] & 0x800) != 0) {
                cp1_1 = cp1_1 + 1;
              }
              value_00 = LYSkipCBlanks(cp1_1);
            } while (((*value_00 == '\0') || (*value_00 == ',')) || (*value_00 == ';'));
            while (((*p != '\0' && (*p != ';')) && (*p != ','))) {
              p = p + 1;
            }
            value_end = p;
            if ((value_start < p) &&
               (ppuVar4 = __ctype_b_loc(), value_00 = p, ((*ppuVar4)[(byte)p[-1]] & 0x2000) != 0)) {
              while (value_end = value_00 + -1, (byte *)value_start + 1 < value_end) {
                ppuVar4 = __ctype_b_loc();
                if ((((*ppuVar4)[(byte)*value_end] & 0x2000) == 0) ||
                   (ppuVar4 = __ctype_b_loc(), pbVar3 = (byte *)(value_00 + -2),
                   value_00 = value_end, ((*ppuVar4)[*pbVar3] & 0x2000) == 0)) break;
              }
            }
          }
          else {
            if (*value_start == 0x22) {
              bVar2 = false;
              pbVar3 = (byte *)value_start + 1;
              p = (char *)pbVar3;
              while ((*p != '\0' && ((*p != '\"' || (bVar2))))) {
                if ((bVar2) || (*p != '\\')) {
                  bVar2 = false;
                }
                else {
                  bVar2 = true;
                }
                p = p + 1;
              }
              if ((((byte *)p == pbVar3) || (*p != '\"')) || (bVar2)) {
                value_end = p;
                if (*p != '\0') {
                  p = p + 1;
                }
                Quoted = '\0';
              }
              else {
                value_end = p;
                p = p + 1;
                Quoted = '\x01';
                value_start = (char *)pbVar3;
              }
            }
            else {
              while (((*p != '\0' && (*p != ';')) && (*p != ','))) {
                p = p + 1;
              }
              value_end = p;
              if ((value_start < p) &&
                 (ppuVar4 = __ctype_b_loc(), value_00 = p, ((*ppuVar4)[(byte)p[-1]] & 0x2000) != 0))
              {
                while (value_end = value_00 + -1, (byte *)value_start + 1 < value_end) {
                  ppuVar4 = __ctype_b_loc();
                  if ((((*ppuVar4)[(byte)*value_end] & 0x2000) == 0) ||
                     (ppuVar4 = __ctype_b_loc(), pbVar3 = (byte *)(value_00 + -2),
                     value_00 = value_end, ((*ppuVar4)[*pbVar3] & 0x2000) == 0)) break;
                }
              }
            }
          }
        }
      }
LAB_080e837e:
      if ((*p == ';') || (*p == ',')) {
        p = p + 1;
      }
      if (a < end) {
        value_00 = alloc_attr_value(value_start,value_end);
        local_90 = (char *)&cookie_len;
        local_94 = a;
        parse_flags = parse_attribute(parse_flags,cur_cookie,(int *)local_90,a,(int)(end + -(int)a),
                                      value_00,address,hostname,port);
        if ((((parse_flags & 2) == 0) && (value_00 != (char *)0x0)) && (value_start <= value_end)) {
          if ((max_cookies_buffer < cookie_len) || (cur_cookie == (cookie *)0x0)) {
            if (cur_cookie != (cookie *)0x0) {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                if (cur_cookie->value == (char *)0x0) {
                  local_94 = "[no value]";
                }
                else {
                  local_94 = cur_cookie->value;
                }
                if (cur_cookie->name == (char *)0x0) {
                  local_90 = "[no name]";
                }
                else {
                  local_90 = cur_cookie->name;
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,"LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",
                        local_90,local_94);
              }
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"                     due to excessive length!\n",local_90,
                        local_94);
              }
              freeCookie(cur_cookie);
            }
          }
          else {
            if (SetCookie2 != (char *)0x0) {
              if (cur_cookie->version < 1) {
                cur_cookie->version = 1;
              }
              cur_cookie->quoted = '\x01';
            }
            HTList_appendObject(me,cur_cookie);
          }
          cur_cookie = newCookie();
          NumCookies = NumCookies + 1;
          cookie_len = 0;
          MemAllocCopy(&cur_cookie->name,a,end);
          sVar5 = strlen(cur_cookie->name);
          cookie_len = sVar5 + cookie_len;
          MemAllocCopy(&cur_cookie->value,value_start,value_end);
          sVar5 = strlen(cur_cookie->value);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->domain,hostname);
          sVar5 = strlen(cur_cookie->domain);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->path,path);
          sVar5 = strlen(cur_cookie->path);
          cur_cookie->pathlen = sVar5;
          cookie_len = cur_cookie->pathlen + cookie_len;
          cur_cookie->port = port;
          parse_flags = 0;
          cur_cookie->quoted = Quoted;
          Quoted = '\0';
        }
        if (value_00 != (char *)0x0) {
          free(value_00);
        }
      }
    }
    cl = me;
    if (((max_cookies_domain < NumCookies) || (max_cookies_buffer < cookie_len)) ||
       (cur_cookie == (cookie *)0x0)) {
      if (cur_cookie != (cookie *)0x0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (cur_cookie->value == (char *)0x0) {
            local_8c = "[no value]";
          }
          else {
            local_8c = cur_cookie->value;
          }
          if (cur_cookie->name == (char *)0x0) {
            local_88 = "[no name]";
          }
          else {
            local_88 = cur_cookie->name;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",local_88,
                  local_8c);
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (max_cookies_domain < NumCookies) {
            local_84 = "number!\n";
          }
          else {
            local_84 = "!\n";
          }
          if ((max_cookies_buffer < cookie_len) && (max_cookies_domain < NumCookies)) {
            local_80 = " and ";
          }
          else {
            local_80 = "";
          }
          if (max_cookies_buffer < cookie_len) {
            local_7c = "length";
          }
          else {
            local_7c = "";
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"                     due to excessive %s%s%s\n",local_7c,
                  local_80,local_84);
        }
        freeCookie(cur_cookie);
      }
    }
    else {
      if (SetCookie2 != (char *)0x0) {
        if (cur_cookie->version < 1) {
          cur_cookie->version = 1;
        }
        cur_cookie->quoted = '\x01';
      }
      HTList_appendObject(me,cur_cookie);
    }
    while( true ) {
      if ((cl == (HTList *)0x0) || (cl = cl->next, cl == (HTList *)0x0)) {
        local_70 = (cookie *)0x0;
      }
      else {
        local_70 = (cookie *)cl->object;
      }
      if (local_70 == (cookie *)0x0) break;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        if (local_70->value == (char *)0x0) {
          local_78 = "[no value]";
        }
        else {
          local_78 = local_70->value;
        }
        if (local_70->name == (char *)0x0) {
          local_74 = "[no name]";
        }
        else {
          local_74 = local_70->name;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYProcessSetCookie: attr=value pair: \'%s=%s\'\n",local_74,
                local_78);
      }
      if (((0 < local_70->expires) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 0x20U) != 0)) {
        a = ctime(&local_70->expires);
        tVar1 = local_70->expires;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"                    expires: %d, %s\n",tVar1,a);
      }
      iVar6 = strncasecomp(address,"https:",6);
      if (((iVar6 == 0) && (LYForceSSLCookiesSecure == '\x01')) &&
         (((local_70->flags & 1U) == 0 &&
          ((local_70->flags = local_70->flags | 1, WWW_TraceFlag != '\0' &&
           ((WWW_TraceMask & 0x20U) != 0)))))) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"                    Forced the \'secure\' flag on.\n");
      }
      store_cookie(local_70,hostname,path);
    }
    HTList_delete(me);
  }
  return;
}



void LYSetCookie(char *SetCookie,char *SetCookie2,char *address)

{
  bool bVar1;
  char *__s;
  char *__s_00;
  int iVar2;
  char *pcVar3;
  FILE *__stream;
  char *local_2c;
  char *local_28;
  int port;
  char *ptr;
  char *path;
  char *hostname;
  BOOLEAN BadHeaders;
  
  bVar1 = false;
  port = 0x50;
  __s = HTParse(address,"",8);
  if ((__s == (char *)0x0) || (__s_00 = strchr(__s,0x3a), __s_00 == (char *)0x0)) {
    iVar2 = strncasecomp(address,"https:",6);
    if (iVar2 == 0) {
      port = 0x1bb;
    }
  }
  else {
    *__s_00 = '\0';
    port = atoi(__s_00 + 1);
  }
  local_28 = (char *)0x5;
  __s_00 = HTParse(address,"",5);
  if ((__s_00 != (char *)0x0) && (pcVar3 = strrchr(__s_00,0x2f), pcVar3 != (char *)0x0)) {
    if (pcVar3 == __s_00) {
      pcVar3[1] = '\0';
    }
    else {
      *pcVar3 = '\0';
    }
  }
  if (((SetCookie == (char *)0x0) || (*SetCookie == '\0')) &&
     ((SetCookie2 == (char *)0x0 || (*SetCookie2 == '\0')))) {
    bVar1 = true;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    local_2c = __s_00;
    if (__s_00 == (char *)0x0) {
      local_2c = "";
    }
    local_28 = __s;
    if (__s == (char *)0x0) {
      local_28 = "";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYSetCookie called with host \'%s\', path \'%s\',\n",local_28,local_2c
           );
  }
  if (((SetCookie != (char *)0x0) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 0x20U) != 0)) {
    __stream = TraceFP();
    local_28 = SetCookie;
    fprintf((FILE *)__stream,"    and Set-Cookie: \'%s\'\n",SetCookie);
  }
  if (((SetCookie2 != (char *)0x0) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 0x20U) != 0)) {
    __stream = TraceFP();
    local_28 = SetCookie2;
    fprintf((FILE *)__stream,"    and Set-Cookie2: \'%s\'\n",SetCookie2);
  }
  if (((LYSetCookies == '\0') || (bVar1)) &&
     ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 0x20U) != 0)))) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"    Ignoring this Set-Cookie/Set-Cookie2 request.\n",local_28);
  }
  if ((LYSetCookies == '\0') || (bVar1)) {
    if (__s != (char *)0x0) {
      free(__s);
    }
    if (__s_00 != (char *)0x0) {
      free(__s_00);
    }
  }
  else {
    LYProcessSetCookies(SetCookie,SetCookie2,address,__s,__s_00,port);
    if (__s != (char *)0x0) {
      free(__s);
    }
    if (__s_00 != (char *)0x0) {
      free(__s_00);
    }
  }
  return;
}



char * LYAddCookieHeader(char *hostname,char *path,int port,BOOLEAN secure)

{
  void **oldObject;
  FILE *__stream;
  char *local_24;
  char *local_20;
  char *local_1c;
  domain_entry *de;
  HTList *next;
  HTList *hl;
  char *header;
  
  header = (char *)0x0;
  hl = domain_list;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    if (path == (char *)0x0) {
      local_24 = "(null)";
    }
    else {
      local_24 = path;
    }
    if (hostname == (char *)0x0) {
      local_20 = "(null)";
    }
    else {
      local_20 = hostname;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYCookie: Searching for \'%s:%d\', \'%s\'.\n",local_20,port,local_24);
  }
  while (hl != (HTList *)0x0) {
    oldObject = (void **)hl->object;
    hl = hl->next;
    if (oldObject != (void **)0x0) {
      if ((oldObject[3] == (void *)0x0) || (*(int *)((int)oldObject[3] + 4) == 0)) {
        if ((oldObject[1] == (void *)0x2) && (oldObject[2] == (void *)0x0)) {
          if (*oldObject != (void *)0x0) {
            free(*oldObject);
            *oldObject = (void *)0x0;
          }
          HTList_delete((HTList *)oldObject[3]);
          oldObject[3] = (void *)0x0;
          HTList_removeObject(domain_list,oldObject);
          if (oldObject != (void **)0x0) {
            free(oldObject);
          }
        }
      }
      else {
        header = scan_cookie_sublist(hostname,path,port,(HTList *)oldObject[3],header,secure);
      }
    }
  }
  if (header == (char *)0x0) {
    local_1c = (char *)0x0;
  }
  else {
    local_1c = header;
  }
  return local_1c;
}



void LYLoadCookies(char *cookie_file)

{
  int iVar1;
  anon_struct_0 tok_values [8];
  char expires_a [16];
  char secure [8];
  char value [4100];
  char name [256];
  char path [256];
  char domain [256];
  FILE *fp;
  FILE *__stream;
  size_t sVar2;
  cookie *co;
  char *pcVar3;
  undefined *local_38;
  size_t local_34;
  char *tok_ptr;
  char *tok_out;
  int tok_loop;
  cookie *moo;
  time_t expires;
  char *buf;
  FILE *cookie_handle;
  
  buf = (char *)0x0;
  fp = (FILE *)fopen64(cookie_file,"r");
  if (fp != (FILE *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYLoadCookies: reading cookies from %s\n",cookie_file);
    }
    number_of_file_cookies = 0;
    while( true ) {
      pcVar3 = LYSafeGets(&buf,fp);
      if (pcVar3 == (char *)0x0) break;
      LYTrimNewline(buf);
      pcVar3 = buf;
      if ((*buf != '\0') && (*buf != '#')) {
        number_of_file_cookies = number_of_file_cookies + 1;
        local_34 = 2;
        local_38 = &DAT_0816e678;
        sVar2 = strlen(buf);
        memcpy(pcVar3 + sVar2,local_38,local_34);
        pcVar3 = buf;
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYLoadCookies: tokenising %s\n",pcVar3);
        }
        tok_ptr = buf;
        tok_out = LYstrsep(&tok_ptr,"\t");
        tok_loop = 0;
        while ((tok_out != (char *)0x0 &&
               (((anon_struct_0 *)&ram0x0819bda0)[tok_loop].s != (char *)0x0))) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            iVar1 = -(int)buf;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"\t%d:[%03d]:[%s]\n",tok_loop,tok_out + iVar1,tok_out);
          }
          LYstrncpy(*(char **)(tok_loop * 8 + 0x819bda0),tok_out,*(int *)(tok_loop * 8 + 0x819bda4))
          ;
          tok_out = LYstrsep(&tok_ptr,"\t");
          tok_loop = tok_loop + 1;
        }
        if (*(int *)(tok_loop * 8 + 0x819bda0) == 0) {
          expires = atol((char *)&ram0x081b06b0);
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pcVar3 = ctime(&expires);
            __stream = TraceFP();
            fprintf((FILE *)__stream,"expires:\t%s\n",pcVar3);
          }
          co = newCookie();
          HTSACopy(&co->domain,(char *)0x81b1900);
          HTSACopy(&co->path,(char *)&ram0x081b1800);
          HTSACopy(&co->name,(char *)&ram0x081b1700);
          if ((value[0] == '\"') && (value[1] != '\0')) {
            sVar2 = strlen((char *)0x81b06e0);
            if (*(char *)(sVar2 + 0x81b06df) != '\"') goto LAB_080e9178;
            sVar2 = strlen((char *)0x81b06e0);
            if (*(char *)(sVar2 + 0x81b06de) == '\\') goto LAB_080e9178;
            sVar2 = strlen((char *)0x81b06e0);
            *(undefined *)(sVar2 + 0x81b06df) = 0;
            HTSACopy(&co->value,(char *)0x81b06e1);
            co->quoted = '\x01';
          }
          else {
LAB_080e9178:
            HTSACopy(&co->value,(char *)0x81b06e0);
          }
          sVar2 = strlen(co->path);
          co->pathlen = sVar2;
          co->flags = co->flags | 0x34;
          if (domain[0] == '.') {
            co->flags = co->flags | 8;
          }
          if (secure[0] != 'F') {
            co->flags = co->flags | 1;
          }
          co->expires = expires;
          store_cookie(co,(char *)0x81b1900,(char *)0x81b1800);
        }
        else {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"*** wrong format: not enough tokens, ignoring line!\n");
          }
        }
      }
    }
    LYCloseInput(fp);
  }
  return;
}



FILE * NewCookieFile(char *cookie_file)

{
  FILE *__stream;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYStoreCookies: save cookies to %s on exit\n",cookie_file);
  }
  __stream = LYNewTxtFile(cookie_file);
  return __stream;
}



void LYStoreCookies(char *cookie_file)

{
  char **ppcVar1;
  void *pvVar2;
  time_t tVar3;
  int iVar4;
  FILE *__stream;
  char *local_74;
  undefined4 local_6c;
  undefined4 local_64;
  undefined4 local_60;
  undefined *local_48;
  undefined *local_44;
  undefined *local_40;
  char *local_34;
  char *local_2c;
  time_t now;
  FILE *cookie_handle;
  cookie *co;
  domain_entry *de;
  HTList *cl;
  HTList *dl;
  
  cookie_handle = (FILE *)0x0;
  tVar3 = time((time_t *)0x0);
  if ((((cookie_file != (char *)0x0) && (*cookie_file != '\0')) &&
      (iVar4 = strcmp(cookie_file,"/dev/null"), iVar4 != 0)) &&
     (((domain_list != (HTList *)0x0 && (domain_list->next != (HTList *)0x0)) ||
      (number_of_file_cookies != 0)))) {
    if ((number_of_file_cookies != 0) &&
       (cookie_handle = NewCookieFile(cookie_file), cookie_handle == (FILE *)0x0)) {
      return;
    }
    dl = domain_list;
    while (dl != (HTList *)0x0) {
      ppcVar1 = (char **)dl->object;
      if (ppcVar1 != (char **)0x0) {
        cl = (HTList *)ppcVar1[3];
        while (cl != (HTList *)0x0) {
          pvVar2 = cl->object;
          if (pvVar2 != (void *)0x0) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
              local_60 = *(undefined4 *)((int)pvVar2 + 0x30);
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYStoreCookies: %d cf %d ",tVar3,local_60);
            }
            if ((*(uint *)((int)pvVar2 + 0x2c) & 2) == 0) {
              if ((*(uint *)((int)pvVar2 + 0x2c) & 4) == 0) {
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"not stored - no expiration time\n");
                }
              }
              else {
                if (tVar3 < *(int *)((int)pvVar2 + 0x30)) {
                  if ((cookie_handle == (FILE *)0x0) &&
                     (cookie_handle = NewCookieFile(cookie_file), cookie_handle == (FILE *)0x0)) {
                    return;
                  }
                  if (*(char *)((int)pvVar2 + 0x34) == '\0') {
                    local_48 = &DAT_0816df60;
                  }
                  else {
                    local_48 = &DAT_0816e24f;
                  }
                  if (*(int *)((int)pvVar2 + 8) == 0) {
                    local_44 = &DAT_0816df60;
                  }
                  else {
                    local_44 = *(undefined **)((int)pvVar2 + 8);
                  }
                  if (*(char *)((int)pvVar2 + 0x34) == '\0') {
                    local_40 = &DAT_0816df60;
                  }
                  else {
                    local_40 = &DAT_0816e24f;
                  }
                  local_60 = *(undefined4 *)((int)pvVar2 + 4);
                  local_64 = *(undefined4 *)((int)pvVar2 + 0x30);
                  if ((*(uint *)((int)pvVar2 + 0x2c) & 1) == 0) {
                    local_34 = "FALSE";
                  }
                  else {
                    local_34 = "TRUE";
                  }
                  local_6c = *(undefined4 *)((int)pvVar2 + 0x24);
                  if (**ppcVar1 == '.') {
                    local_2c = "TRUE";
                  }
                  else {
                    local_2c = "FALSE";
                  }
                  local_74 = *ppcVar1;
                  fprintf((FILE *)cookie_handle,"%s\t%s\t%s\t%s\t%d\t%s\t%s%s%s\n",local_74,local_2c
                          ,local_6c,local_34,local_64,local_60,local_40,local_44,local_48);
                  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"STORED\n",local_74,local_2c,local_6c,local_34,local_64
                            ,local_60,local_40,local_44,local_48);
                  }
                }
                else {
                  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"not stored - EXPIRED\n");
                  }
                }
              }
            }
            else {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"not stored - DISCARD\n");
              }
            }
          }
          cl = cl->next;
        }
      }
      dl = dl->next;
    }
    if (cookie_handle != (FILE *)0x0) {
      LYCloseOutput(cookie_handle);
    }
  }
  return;
}



int LYHandleCookies(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  HTList *pHVar1;
  cookie *co_00;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  LYKeymap_t LVar5;
  BOOLEAN BVar6;
  HTAtom *rep_in;
  domain_entry *oldObject;
  int iVar7;
  uint uVar8;
  HTStream *pHVar9;
  char *fmt;
  undefined4 local_88;
  size_t local_94;
  undefined4 local_8c;
  char *fmt_00;
  char *local_90;
  int local_74;
  undefined *local_6c;
  undefined *local_68;
  undefined *local_64;
  char *local_60;
  int ch;
  char *Title;
  char *Address;
  char *comment;
  char *path;
  char *value;
  char *name;
  cookie *co;
  domain_entry *de;
  HTList *next;
  HTList *cl;
  HTList *dl;
  char *lynxID;
  char *domain;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  
  rep_in = HTAtom_for("text/html");
  buf = (char *)0x0;
  lynxID = (char *)0x0;
  name = (char *)0x0;
  value = (char *)0x0;
  path = (char *)0x0;
  comment = (char *)0x0;
  Address = (char *)0x0;
  Title = (char *)0x0;
  if ((domain_list == (HTList *)0x0) || (domain_list->next == (HTList *)0x0)) {
    local_90 = (char *)gettext("The Cookie Jar is empty.");
    HTProgress(local_90);
    LYSleepMsg();
    HTNoDataOK = 1;
    local_74 = -0xcc;
  }
  else {
    domain = HTParse(arg,"",8);
    if (domain != (char *)0x0) {
      if (*domain == '\0') {
        if (domain != (char *)0x0) {
          free(domain);
          domain = (char *)0x0;
        }
      }
      else {
        lynxID = HTParse(arg,"",4);
        if (((lynxID != (char *)0x0) && (*lynxID == '\0')) && (lynxID != (char *)0x0)) {
          free(lynxID);
          lynxID = (char *)0x0;
        }
      }
    }
    if (domain == (char *)0x0) {
      pHVar9 = HTStreamStack((HTFormat)rep_in,format_out,sink,anAnchor);
      if ((pHVar9 == (HTStream *)0x0) || (pHVar9 == (HTStream *)0x0)) {
        local_90 = format_out->name;
        fmt_00 = rep_in->name;
        fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
        HTSprintf0(&buf,fmt,fmt_00,local_90);
        HTAlert(buf);
        if (buf != (char *)0x0) {
          free(buf);
        }
        local_74 = -29999;
      }
      else {
        local_88 = gettext("Cookie Jar");
        HTSprintf0(&buf,"<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",local_88);
        paVar2 = pHVar9->isa->put_block;
        local_94 = strlen(buf);
        (*paVar2)(pHVar9,buf,local_94);
        local_88 = gettext("Cookie Jar");
        local_90 = helpfilepath;
        local_8c = gettext(", help on ");
        HTSprintf0(&buf,"<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",&DAT_0816ea71,"2.8.7dev.11",
                   local_8c,local_90,"Lynx_users_guide.html.gz#Cookies",local_88);
        paVar2 = pHVar9->isa->put_block;
        local_94 = strlen(buf);
        (*paVar2)(pHVar9,buf,local_94);
        local_88 = gettext("Activate links to gobble up cookies or entire domains,");
        HTSprintf0(&buf,"<note>%s\n",local_88);
        paVar2 = pHVar9->isa->put_block;
        local_94 = strlen(buf);
        (*paVar2)(pHVar9,buf,local_94);
        local_88 = gettext("or to change a domain\'s \'allow\' setting.");
        HTSprintf0(&buf,"%s</note>\n",local_88);
        paVar2 = pHVar9->isa->put_block;
        local_94 = strlen(buf);
        (*paVar2)(pHVar9,buf,local_94);
        HTSprintf0(&buf,"<dl compact>\n");
        paVar2 = pHVar9->isa->put_block;
        local_94 = strlen(buf);
        (*paVar2)(pHVar9,buf,local_94);
        dl = domain_list;
        while (dl != (HTList *)0x0) {
          puVar3 = (undefined4 *)dl->object;
          if (puVar3 != (undefined4 *)0x0) {
            local_88 = *puVar3;
            local_8c = *puVar3;
            local_90 = "LYNXCOOKIE:";
            HTSprintf0(&buf,"<dt>%s<dd><a href=\"%s//%s/\">Domain=%s</a>\n",*puVar3,"LYNXCOOKIE:",
                       local_8c,local_88);
            paVar2 = pHVar9->isa->put_block;
            local_94 = strlen(buf);
            (*paVar2)(pHVar9,buf,local_94);
            iVar7 = puVar3[1];
            if (iVar7 == 1) {
              fmt_00 = (char *)gettext("(Cookies never allowed.)");
              HTSprintf0(&buf,fmt_00,local_94,local_90,local_8c,local_88);
            }
            else {
              if (iVar7 == 0) {
                fmt_00 = (char *)gettext("(Cookies always allowed.)");
                HTSprintf0(&buf,fmt_00,local_94,local_90,local_8c,local_88);
              }
              else {
                if (iVar7 == 2) {
                  fmt_00 = (char *)gettext("(Cookies allowed via prompt.)");
                  HTSprintf0(&buf,fmt_00,local_94,local_90,local_8c,local_88);
                }
              }
            }
            paVar2 = pHVar9->isa->put_block;
            local_94 = strlen(buf);
            (*paVar2)(pHVar9,buf,local_94);
            HTSprintf0(&buf,"\n");
            paVar2 = pHVar9->isa->put_block;
            local_94 = strlen(buf);
            (*paVar2)(pHVar9,buf,local_94);
            cl = (HTList *)puVar3[3];
            while (cl != (HTList *)0x0) {
              puVar4 = (undefined4 *)cl->object;
              if (puVar4 != (undefined4 *)0x0) {
                if (puVar4[1] == 0) {
                  local_90 = (char *)gettext("(No name.)");
                  HTSACopy(&name,local_90);
                }
                else {
                  HTSACopy(&name,(char *)puVar4[1]);
                  LYEntify(&name,'\x01');
                }
                if (puVar4[2] == 0) {
                  local_90 = (char *)gettext("(No value.)");
                  HTSACopy(&value,local_90);
                }
                else {
                  HTSACopy(&value,(char *)puVar4[2]);
                  LYEntify(&value,'\x01');
                }
                HTSprintf0(&buf,"<dd><a href=\"%s//%s/%s\">%s=%s</a>\n","LYNXCOOKIE:",*puVar3,
                           *puVar4,name,value);
                if (name != (char *)0x0) {
                  free(name);
                  name = (char *)0x0;
                }
                if (value != (char *)0x0) {
                  free(value);
                  value = (char *)0x0;
                }
                paVar2 = pHVar9->isa->put_block;
                local_94 = strlen(buf);
                (*paVar2)(pHVar9,buf,local_94);
                if ((puVar4[0xb] & 0x20) != 0) {
                  local_88 = gettext("(from a previous session)");
                  HTSprintf0(&buf,"%s\n",local_88);
                  paVar2 = pHVar9->isa->put_block;
                  local_94 = strlen(buf);
                  (*paVar2)(pHVar9,buf,local_94);
                }
                if (puVar4[9] == 0) {
                  HTSACopy(&path,"/");
                }
                else {
                  HTSACopy(&path,(char *)puVar4[9]);
                  LYEntify(&path,'\x01');
                }
                if ((puVar4[0xb] & 2) == 0) {
                  local_6c = &DAT_0816ec17;
                }
                else {
                  local_6c = &DAT_0816ec13;
                }
                if ((puVar4[0xb] & 1) == 0) {
                  local_68 = &DAT_0816ec17;
                }
                else {
                  local_68 = &DAT_0816ec13;
                }
                local_88 = puVar4[7];
                HTSprintf0(&buf,"<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",path,local_88,
                           local_68,local_6c);
                if (path != (char *)0x0) {
                  free(path);
                  path = (char *)0x0;
                }
                paVar2 = pHVar9->isa->put_block;
                local_94 = strlen(buf);
                (*paVar2)(pHVar9,buf,local_94);
                if (puVar4[8] != 0) {
                  HTSprintf0(&buf,"<dD>PortList=\"%s\"\n",puVar4[8],local_88,local_68,local_6c);
                  paVar2 = pHVar9->isa->put_block;
                  local_94 = strlen(buf);
                  (*paVar2)(pHVar9,buf,local_94);
                }
                if (puVar4[5] != 0) {
                  HTSACopy(&Address,(char *)puVar4[5]);
                  LYEntify(&Address,'\0');
                  HTSACopy(&Title,(char *)puVar4[5]);
                  LYEntify(&Title,'\x01');
                  HTSprintf0(&buf,"<dd>CommentURL: <a href=\"%s\">%s</a>\n",Address,Title);
                  if (Address != (char *)0x0) {
                    free(Address);
                    Address = (char *)0x0;
                  }
                  if (Title != (char *)0x0) {
                    free(Title);
                    Title = (char *)0x0;
                  }
                  paVar2 = pHVar9->isa->put_block;
                  local_94 = strlen(buf);
                  (*paVar2)(pHVar9,buf,local_94);
                }
                if (puVar4[4] != 0) {
                  HTSACopy(&comment,(char *)puVar4[4]);
                  LYEntify(&comment,'\x01');
                  HTSprintf0(&buf,"<dd>Comment: %s\n",comment);
                  if (comment != (char *)0x0) {
                    free(comment);
                    comment = (char *)0x0;
                  }
                  paVar2 = pHVar9->isa->put_block;
                  local_94 = strlen(buf);
                  (*paVar2)(pHVar9,buf,local_94);
                }
                if ((puVar4[0xb] & 4) == 0) {
                  local_64 = &DAT_0816ebb4;
                }
                else {
                  local_64 = &DAT_0816df60;
                }
                if ((puVar4[0xb] & 4) == 0) {
                  local_60 = (char *)gettext("(End of session.)");
                }
                else {
                  local_60 = ctime(puVar4 + 0xc);
                }
                local_88 = gettext("Maximum Gobble Date:");
                HTSprintf0(&buf,"<dd><em>%s</em> %s%s",local_88,local_60,local_64);
                paVar2 = pHVar9->isa->put_block;
                local_94 = strlen(buf);
                (*paVar2)(pHVar9,buf,local_94);
              }
              cl = cl->next;
            }
            HTSprintf0(&buf,"</dt>\n");
            paVar2 = pHVar9->isa->put_block;
            local_94 = strlen(buf);
            (*paVar2)(pHVar9,buf,local_94);
          }
          dl = dl->next;
        }
        HTSprintf0(&buf,"</dl>\n</body>\n</html>\n");
        paVar2 = pHVar9->isa->put_block;
        local_94 = strlen(buf);
        (*paVar2)(pHVar9,buf,local_94);
        (*pHVar9->isa->_free)(pHVar9);
        if (buf != (char *)0x0) {
          free(buf);
        }
        local_74 = 200;
      }
    }
    else {
      oldObject = find_domain_entry(domain);
      if (oldObject != (domain_entry *)0x0) {
        if (domain != (char *)0x0) {
          free(domain);
          domain = (char *)0x0;
        }
        if (lynxID == (char *)0x0) {
          if ((oldObject->cookie_list == (HTList *)0x0) ||
             (oldObject->cookie_list->next == (HTList *)0x0)) {
            mustshow = '\x01';
            local_90 = (char *)gettext(
                                      "D)elete domain, set allow A)lways/P)rompt/neV)er, or C)ancel? "
                                      );
            statusline(local_90);
          }
          else {
            mustshow = '\x01';
            local_90 = (char *)gettext(
                                      "D)elete domain\'s cookies, set allow A)lways/P)rompt/neV)er, or C)ancel? "
                                      );
            statusline(local_90);
          }
          HTNoDataOK = 1;
LAB_080e9971:
          uVar8 = LYgetch_single();
          switch(uVar8) {
          case 0x41:
            oldObject->bv = ACCEPT_ALWAYS;
            local_90 = oldObject->domain;
            fmt_00 = (char *)gettext("\'A\'lways allowing from domain \'%s\'.");
            HTUserMsg2(fmt_00,local_90);
            return -0xcc;
          default:
            if ((uVar8 == 3) || (uVar8 == 7)) goto reject;
            LVar5 = keymap[0];
            if (uVar8 == 0xffffffff) {
joined_r0x080e9c76:
              if (LVar5 == 0x2f) goto reject;
            }
            else {
              if ((uVar8 & 0x8800) == 0) {
                LVar5 = keymap[(uVar8 & 0x7ff) + 1];
                goto joined_r0x080e9c76;
              }
              if ((uVar8 & 0xff) == 0x2f) {
reject:
                local_90 = (char *)gettext("Cancelled!!!");
                HTUserMsg(local_90);
                return -0xcc;
              }
            }
            goto LAB_080e9971;
          case 0x43:
            goto reject;
          case 0x44:
            if ((oldObject->cookie_list == (HTList *)0x0) ||
               (oldObject->cookie_list->next == (HTList *)0x0)) {
              if (oldObject->domain != (char *)0x0) {
                free(oldObject->domain);
                oldObject->domain = (char *)0x0;
              }
              HTList_delete(oldObject->cookie_list);
              oldObject->cookie_list = (HTList *)0x0;
              HTList_removeObject(domain_list,oldObject);
              if (oldObject != (domain_entry *)0x0) {
                free(oldObject);
              }
              local_90 = (char *)gettext("The domain has been eaten!");
              HTProgress(local_90);
              LYSleepMsg();
              goto LAB_080e9cc5;
            }
            break;
          case 0x50:
            oldObject->bv = QUERY_USER;
            local_90 = oldObject->domain;
            fmt_00 = (char *)gettext("\'P\'rompting to allow from domain \'%s\'.");
            HTUserMsg2(fmt_00,local_90);
            return -0xcc;
          case 0x56:
            oldObject->bv = REJECT_ALWAYS;
            local_90 = oldObject->domain;
            fmt_00 = (char *)gettext("ne\'V\'er allowing from domain \'%s\'.");
            HTUserMsg2(fmt_00,local_90);
            if ((oldObject->cookie_list == (HTList *)0x0) ||
               (oldObject->cookie_list->next == (HTList *)0x0)) {
              return -0xcc;
            }
            local_90 = (char *)gettext("Delete all cookies in this domain?");
            BVar6 = HTConfirm(local_90);
            if (BVar6 == '\0') {
              return -0xcc;
            }
          }
          cl = oldObject->cookie_list;
          while (cl != (HTList *)0x0) {
            pHVar1 = cl->next;
            co_00 = (cookie *)cl->object;
            cl = pHVar1;
            if (co_00 != (cookie *)0x0) {
              HTList_removeObject(oldObject->cookie_list,co_00);
              freeCookie(co_00);
              total_cookies = total_cookies + -1;
            }
          }
          local_90 = (char *)gettext("All cookies in the domain have been eaten!");
          HTProgress(local_90);
          LYSleepMsg();
          if (oldObject->bv != QUERY_USER) {
            return -0xcc;
          }
          local_90 = (char *)gettext("Delete this empty domain?");
          BVar6 = HTConfirm(local_90);
          if (BVar6 != '\0') {
            if (oldObject->domain != (char *)0x0) {
              free(oldObject->domain);
              oldObject->domain = (char *)0x0;
            }
            HTList_delete(oldObject->cookie_list);
            oldObject->cookie_list = (HTList *)0x0;
            HTList_removeObject(domain_list,oldObject);
            if (oldObject != (domain_entry *)0x0) {
              free(oldObject);
            }
            local_90 = (char *)gettext("The domain has been eaten!");
            HTProgress(local_90);
            LYSleepMsg();
          }
          goto LAB_080e9cc5;
        }
        cl = oldObject->cookie_list;
        while (cl != (HTList *)0x0) {
          co_00 = (cookie *)cl->object;
          if ((co_00 != (cookie *)0x0) && (iVar7 = strcmp(lynxID,co_00->lynxID), iVar7 == 0)) {
            local_90 = (char *)gettext("Delete this cookie?");
            BVar6 = HTConfirm(local_90);
            if (BVar6 == '\0') {
              if (lynxID != (char *)0x0) {
                free(lynxID);
              }
              HTNoDataOK = 1;
              return -0xcc;
            }
            HTList_removeObject(oldObject->cookie_list,co_00);
            freeCookie(co_00);
            total_cookies = total_cookies + -1;
            if ((oldObject->bv == QUERY_USER) &&
               ((oldObject->cookie_list == (HTList *)0x0 ||
                (oldObject->cookie_list->next == (HTList *)0x0)))) {
              local_90 = (char *)gettext("Delete this empty domain?");
              BVar6 = HTConfirm(local_90);
              if (BVar6 == '\0') goto LAB_080e98d8;
              if (oldObject->domain != (char *)0x0) {
                free(oldObject->domain);
                oldObject->domain = (char *)0x0;
              }
              HTList_delete(oldObject->cookie_list);
              oldObject->cookie_list = (HTList *)0x0;
              HTList_removeObject(domain_list,oldObject);
              if (oldObject != (domain_entry *)0x0) {
                free(oldObject);
              }
              local_90 = (char *)gettext("The domain has been eaten!");
              HTProgress(local_90);
            }
            else {
LAB_080e98d8:
              local_90 = (char *)gettext("The cookie has been eaten!");
              HTProgress(local_90);
            }
            LYSleepMsg();
            HTNoDataOK = 1;
            break;
          }
          cl = cl->next;
        }
      }
LAB_080e9cc5:
      if ((domain_list == (HTList *)0x0) || (domain_list->next == (HTList *)0x0)) {
        local_90 = (char *)gettext("All of the cookies in the jar have been eaten!");
        HTProgress(local_90);
        LYSleepMsg();
      }
      if (domain != (char *)0x0) {
        free(domain);
      }
      if (lynxID != (char *)0x0) {
        free(lynxID);
      }
      local_74 = -0xcc;
    }
  }
  return local_74;
}



// WARNING: Removing unreachable block (ram,0x080ea8ca)

void cookie_domain_flag_set(char *domainstr,int flag)

{
  invcheck_behaviour_t iVar1;
  behaviour_t bVar2;
  char **stringp;
  char *extra_prefix;
  HTList *pHVar3;
  FILE *__stream;
  char *Msg;
  char *strsmall;
  char *dstr;
  char **str;
  domain_entry *de;
  
  stringp = (char **)calloc(1,4);
  dstr = (char *)0x0;
  if (stringp == (char **)0x0) {
    Msg = (char *)gettext("cookie_domain_flag_set error, aborting program");
    extra_prefix = (char *)gettext("Internal");
    HTAlwaysAlert(extra_prefix,Msg);
    exit_immediately(1);
  }
  if (domain_list == (HTList *)0x0) {
    domain_list = HTList_new();
    total_cookies = 0;
  }
  HTSACopy(&dstr,domainstr);
  *stringp = dstr;
  while (Msg = LYstrsep(stringp,","), Msg != (char *)0x0) {
    if (*Msg != '\0') {
      de = find_domain_entry(Msg);
      if (de == (domain_entry *)0x0) {
        de = (domain_entry *)calloc(1,0x10);
        if (de == (domain_entry *)0x0) {
          outofmem("./LYCookie.c","cookie_domain_flag_set");
        }
        de->bv = ACCEPT_ALWAYS;
        de->invcheck_bv = INVCHECK_QUERY;
        switch(flag) {
        case 0:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 1:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 2:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 4:
          de->bv = QUERY_USER;
          break;
        case 5:
          de->bv = QUERY_USER;
          break;
        case 6:
          de->bv = QUERY_USER;
        }
        HTSACopy((char **)de,Msg);
        pHVar3 = HTList_new();
        de->cookie_list = pHVar3;
        HTList_appendObject(domain_list,de);
      }
      switch(flag) {
      case 0:
        de->bv = ACCEPT_ALWAYS;
        break;
      case 1:
        de->bv = REJECT_ALWAYS;
        break;
      case 2:
        de->bv = QUERY_USER;
        break;
      case 4:
        de->invcheck_bv = INVCHECK_QUERY;
        break;
      case 5:
        de->invcheck_bv = INVCHECK_STRICT;
        break;
      case 6:
        de->invcheck_bv = INVCHECK_LOOSE;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        iVar1 = de->invcheck_bv;
        bVar2 = de->bv;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"cookie_domain_flag_set (%s, bv=%u, invcheck_bv=%u)\n",Msg,bVar2,
                iVar1);
      }
    }
  }
  if (stringp != (char **)0x0) {
    free(stringp);
  }
  if (dstr != (char *)0x0) {
    free(dstr);
  }
  return;
}



void LYConfigCookies(void)

{
  anon_struct_0 table [10];
  uint n;
  
  n = 0;
  while (n < 10) {
    if (*((anon_struct_0 *)&ram0x0816ee20)[n].domain != (char *)0x0) {
      cookie_domain_flag_set(**(char ***)(n * 0xc + 0x816ee20),*(int *)(n * 0xc + 0x816ee24));
      if ((*(int *)(n * 0xc + 0x816ee28) != 0) && (**(int **)(n * 0xc + 0x816ee20) != 0)) {
        free(**(void ***)(n * 0xc + 0x816ee20));
        **(undefined4 **)(n * 0xc + 0x816ee20) = 0;
      }
    }
    n = n + 1;
  }
  return;
}



char * TrimLowercase(char *buffer)

{
  LYRemoveBlanks(buffer);
  strtolower(buffer);
  return buffer;
}



void parse_either(char *attrs,int dft_color,int *monop,int *colorp)

{
  size_t sVar1;
  uint uVar2;
  int iVar3;
  char local_15;
  char *next;
  int value;
  char save;
  
  while (*attrs != '\0') {
    next = strchr(attrs,0x2b);
    if (next == (char *)0x0) {
      local_15 = '\0';
      sVar1 = strlen(attrs);
      next = attrs + sVar1;
    }
    else {
      local_15 = *next;
    }
    if (local_15 != '\0') {
      *next = '\0';
    }
    uVar2 = string_to_attr(attrs);
    if (uVar2 == 0) {
      if ((colorp != (int *)0x0) && (iVar3 = check_color(attrs,dft_color), iVar3 != -3)) {
        *colorp = iVar3;
      }
    }
    else {
      *monop = *monop | uVar2;
    }
    attrs = next;
    if (local_15 != '\0') {
      *next = local_15;
      attrs = next + 1;
    }
  }
  return;
}



void parse_attributes(char *mono,char *fg,char *bg,int style,char *element)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int style_00;
  FILE *__stream;
  int iVar5;
  int iVar6;
  uint uVar7;
  int *local_70;
  int *piVar8;
  int iBlink;
  int iBold;
  int iBg;
  int iFg;
  int curPair;
  int newstyle;
  int cA;
  int bA;
  int fA;
  int mA;
  
  mA = 0;
  fA = default_fg;
  bA = default_bg;
  cA = 0;
  style_00 = hash_code(element);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"CSS(PA):style d=%d / h=%d, e=%s\n",style,style_00,element);
  }
  parse_either(mono,-3,&mA,(int *)0x0);
  parse_either(bg,default_bg,&cA,&bA);
  local_70 = &fA;
  parse_either(fg,default_fg,&cA,local_70);
  iVar3 = fA;
  iVar2 = bA;
  iVar1 = default_bg;
  piVar8 = (int *)default_fg;
  if (style == -1) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"CSS(DEF):default_fg=%d, default_bg=%d\n",iVar3,iVar2);
    }
    default_fg = fA;
    default_bg = bA;
    default_color_reset = '\x01';
  }
  else {
    if (fA == -2) {
      bA = -2;
    }
    else {
      if (COLORS == 0) {
        cA = 0x200000;
        fA = -2;
        bA = -2;
      }
      else {
        if ((COLORS <= fA) || (COLORS <= bA)) {
          cA = 0x200000;
        }
        if (COLORS <= fA) {
          fA = fA % COLORS;
        }
        if (COLORS <= bA) {
          bA = bA % COLORS;
        }
      }
    }
    iVar4 = fA;
    iVar3 = bA;
    iVar2 = cA;
    if (((lynx_has_color == 0) || (COLOR_PAIRS + -1 <= colorPairs)) || (fA == -2)) {
      if (((lynx_has_color != 0) && (fA != -2)) &&
         ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 2U) != 0)))) {
        iVar1 = COLOR_PAIRS + -1;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"CSS(NC): maximum of %d colorpairs exhausted\n",iVar1);
      }
      if (style < 0x85) {
        setStyle(style,-1,-1,mA);
      }
      setHashStyle(style_00,-1,-1,mA,element);
    }
    else {
      curPair = 0;
      iVar5 = (~(fA >> 0x1f) & fA) + 1;
      iVar6 = (~(bA >> 0x1f) & bA) + 1;
      uVar7 = (uint)((cA & 0x200000U) != 0);
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"parse_attributes %d/%d %d/%d %#x\n",iVar4,piVar8,iVar3,iVar1,iVar2
               );
        local_70 = piVar8;
      }
      if (((fA < 0x10) && (bA < 0x10)) && ((cA != 0 || ((fA != default_fg || (bA != default_bg))))))
      {
        if (our_pairs[iVar5 * 0x11 + uVar7 * 0x121 + iVar6] == '\0') {
          curPair = colorPairs + 1;
          colorPairs = curPair;
          init_pair((int)(short)curPair,(int)(short)fA,(int)(short)bA);
          our_pairs[iVar5 * 0x11 + uVar7 * 0x121 + iVar6] = (uchar)curPair;
        }
        else {
          curPair = ZEXT14(our_pairs[iVar5 * 0x11 + uVar7 * 0x121 + iVar6]);
        }
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"CSS(CURPAIR):%d\n",curPair,local_70);
      }
      if (style < 0x85) {
        setStyle(style,cA | curPair << 8,cA,mA);
      }
      setHashStyle(style_00,curPair << 8 | cA,cA,mA,element);
    }
  }
  return;
}



void parse_style(char *param)

{
  int *piVar1;
  bool bVar2;
  char *string;
  anon_struct_0 table [27];
  FILE *__stream;
  char *__s;
  char *__format;
  int iVar3;
  HTTag *pHVar4;
  undefined *local_3c;
  HTTag *t;
  int element_number;
  char *bg;
  char *fg;
  char *mono;
  char *element;
  char *tmp;
  char *buffer;
  uint n;
  BOOLEAN found;
  
  bVar2 = false;
  buffer = (char *)0x0;
  if (param != (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"parse_style(%s)\n",param);
    }
    HTSACopy(&buffer,param);
    if (buffer != (char *)0x0) {
      TrimLowercase(buffer);
      __s = strchr(buffer,0x3a);
      string = buffer;
      if (__s == (char *)0x0) {
        __format = (char *)gettext(
                                  "Syntax Error parsing style in lss file:\n[%s]\nThe line must be of the form:\nOBJECT:MONO:COLOR (ie em:bold:brightblue:white)\nwhere OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n\n"
                                  );
        fprintf(stderr,__format,string);
        exit_immediately(1);
      }
      string = buffer;
      *__s = '\0';
      __s = __s + 1;
      fg = strchr(__s,0x3a);
      if (fg == (char *)0x0) {
        fg = "nocolor";
        bg = "nocolor";
      }
      else {
        *fg = '\0';
        fg = fg + 1;
        bg = strchr(fg,0x3a);
        if (bg == (char *)0x0) {
          bg = "default";
        }
        else {
          *bg = '\0';
          bg = bg + 1;
        }
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        iVar3 = hash_code(string);
        if (hashStyles[iVar3].name == (char *)0x0) {
          local_3c = &DAT_0816f168;
        }
        else {
          local_3c = &DAT_0816f163;
        }
        iVar3 = hash_code(string);
        __stream = TraceFP();
        fprintf((FILE *)__stream,"CSSPARSE:%s => %d %s\n",string,iVar3,local_3c);
      }
      n = 0;
      while (n < 0x1b) {
        iVar3 = strcasecomp(string,((anon_struct_0 *)&ram0x0819bea0)[n].name);
        if (iVar3 == 0) {
          parse_attributes(__s,fg,bg,*(int *)(n * 0xc + 0x819bea4),*(char **)(n * 0xc + 0x819bea0));
          if (*(int *)(n * 0xc + 0x819bea8) != 0) {
            piVar1 = *(int **)(n * 0xc + 0x819bea8);
            iVar3 = hash_code(*(char **)(n * 0xc + 0x819bea0));
            *piVar1 = iVar3;
          }
          bVar2 = true;
          break;
        }
        n = n + 1;
      }
      if (bVar2) {
        iVar3 = strcasecomp(string,"normal");
        if (iVar3 == 0) {
          parse_attributes(__s,fg,bg,0x80,"html");
          s_normal = hash_code("html");
          LYnormalColor();
        }
      }
      else {
        element_number = -1;
        pHVar4 = SGMLFindTag(&HTML_dtd,string);
        if ((pHVar4 != (HTTag *)0x0) && (pHVar4->name != (char *)0x0)) {
          element_number = ((int)&pHVar4[-0x250ee9].contents >> 3) * -0x49249249;
        }
        if ((element_number < 0) || (0x75 < element_number)) {
          parse_attributes(__s,fg,bg,0x85,string);
        }
        else {
          parse_attributes(__s,fg,bg,element_number + 8,string);
        }
      }
      if (buffer != (char *)0x0) {
        free(buffer);
      }
    }
  }
  return;
}



void style_deleteStyleList(void)

{
  LYFreeStringList(lss_styles);
  lss_styles = (HTList *)0x0;
  return;
}



void free_colorstylestuff(void)

{
  style_initialiseHashTable();
  style_deleteStyleList();
  memset(our_pairs,0,0x242);
  FreeCachedStyles();
  return;
}



void initialise_default_stylesheet(void)

{
  int code_00;
  anon_struct_0 table2 [27];
  char *__ptr;
  char *__ptr_00;
  FILE *__stream;
  char *value;
  char *name;
  int code;
  char *strong;
  char *normal;
  uint n;
  
  __ptr = LYgetTableString(0);
  __ptr_00 = LYgetTableString(4);
  if (((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) ||
     ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 2U) != 0)))) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"initialise_default_stylesheet\n");
  }
  n = 0;
  while (n < 0x76) {
    name = (char *)0x0;
    HTSprintf0(&name,"%s:%s",tags[n].name,__ptr);
    parse_style(name);
    if (name != (char *)0x0) {
      free(name);
      name = (char *)0x0;
    }
    n = n + 1;
  }
  n = 0;
  while (n < 0x1b) {
    code_00 = ((anon_struct_0 *)&ram0x0816f2c0)[n].color;
    name = (char *)0x0;
    value = __ptr;
    if ((code_00 != 0) && (value = __ptr_00, code_00 != 4)) {
      value = LYgetTableString(code_00);
    }
    HTSprintf0(&name,"%s:%s",*(undefined4 *)(n * 8 + 0x816f2c4),value);
    parse_style(name);
    if (name != (char *)0x0) {
      free(name);
      name = (char *)0x0;
    }
    if (((value != __ptr) && (value != __ptr_00)) && (value != (char *)0x0)) {
      free(value);
    }
    n = n + 1;
  }
  if (__ptr != (char *)0x0) {
    free(__ptr);
  }
  if (__ptr_00 != (char *)0x0) {
    free(__ptr_00);
  }
  return;
}



void style_initialiseHashTable(void)

{
  int firsttime;
  int i;
  
  i = 0;
  while (i < 0x2001) {
    if (firsttime == 0) {
      if (hashStyles[i].name != (char *)0x0) {
        free(hashStyles[i].name);
        hashStyles[i].name = (char *)0x0;
      }
    }
    else {
      hashStyles[i].name = (char *)0x0;
    }
    hashStyles[i].color = 0;
    hashStyles[i].cattr = 0;
    hashStyles[i].mono = 0;
    i = i + 1;
  }
  if (firsttime != 0) {
    firsttime = 0;
  }
  s_alink = hash_code("alink");
  s_a = hash_code("a");
  s_status = hash_code("status");
  s_alert = hash_code("alert");
  s_title = hash_code("title");
  s_sb_bar = hash_code("scroll.bar");
  s_sb_bg = hash_code("scroll.back");
  s_sb_aa = hash_code("scroll.arrow");
  s_sb_naa = hash_code("scroll.noarrow");
  return;
}



void parse_userstyles(void)

{
  HTList *pHVar1;
  FILE *__stream;
  char *local_1c;
  char *local_18;
  HTList *cur;
  char *name;
  
  pHVar1 = lss_styles;
  cur = lss_styles;
  colorPairs = 0;
  style_initialiseHashTable();
  if ((pHVar1 == (HTList *)0x0) || (pHVar1->next == (HTList *)0x0)) {
    initialise_default_stylesheet();
  }
  else {
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)cur->object;
      }
      local_1c = local_18;
      if (local_18 == (char *)0x0) break;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        if (local_18 == (char *)0x0) {
          local_1c = "!?! empty !?!";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LSS:%s\n",local_1c);
      }
      if (local_18 != (char *)0x0) {
        parse_style(local_18);
      }
    }
  }
  if (s_prompt_edit == -1) {
    s_prompt_edit = s_normal;
  }
  if (s_prompt_edit_arr == -1) {
    s_prompt_edit_arr = s_prompt_edit;
  }
  if (s_prompt_edit_pad == -1) {
    s_prompt_edit_pad = s_prompt_edit;
  }
  if (s_prompt_sel == -1) {
    s_prompt_sel = s_prompt_edit;
  }
  if (s_aedit == -1) {
    s_aedit = s_alink;
  }
  if (s_aedit_arr == -1) {
    s_aedit_arr = s_aedit;
  }
  if (s_aedit_pad == -1) {
    s_aedit_pad = s_aedit;
  }
  if (s_curedit == -1) {
    s_curedit = s_aedit;
  }
  if (s_aedit_sel == -1) {
    s_aedit_sel = s_aedit;
  }
  if (s_menu_bg == -1) {
    s_menu_bg = s_normal;
  }
  if (s_menu_entry == -1) {
    s_menu_entry = s_menu_bg;
  }
  if (s_menu_frame == -1) {
    s_menu_frame = s_menu_bg;
  }
  if (s_menu_number == -1) {
    s_menu_number = s_menu_bg;
  }
  if (s_menu_active == -1) {
    s_menu_active = s_alink;
  }
  return;
}



void HStyle_addStyle(char *buffer)

{
  FILE *__stream;
  int iVar1;
  char *local_20;
  char *local_1c;
  char *local_18;
  char *name;
  
  name = (char *)0x0;
  if (((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) ||
     ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 2U) != 0)))) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HStyle_addStyle(%s)\n",buffer);
  }
  HTSACopy(&name,buffer);
  TrimLowercase(name);
  if (lss_styles == (HTList *)0x0) {
    lss_styles = HTList_new();
  }
  iVar1 = strncasecomp(name,"default:",8);
  if (iVar1 == 0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      if (name == (char *)0x0) {
        local_20 = "!?! empty !?!";
      }
      else {
        local_20 = name;
      }
      if (default_color_reset == '\0') {
        local_1c = "";
      }
      else {
        local_1c = ".ignore";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"READCSS.default%s:%s\n",local_1c,local_20);
    }
    if (default_color_reset == '\0') {
      parse_style(name);
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      if (name == (char *)0x0) {
        local_18 = "!?! empty !?!";
      }
      else {
        local_18 = name;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"READCSS:%s\n",local_18);
    }
    HTList_addObject(lss_styles,name);
  }
  return;
}



int style_readFromFileREC(char *lss_filename,char *parent_filename)

{
  FILE *fp;
  int iVar1;
  size_t sVar2;
  char *lss_filename_00;
  char *local_1c;
  int local_18;
  int len;
  char *buffer;
  FILE *fh;
  
  buffer = (char *)0x0;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    if (lss_filename == (char *)0x0) {
      local_1c = "?!? empty ?!?";
    }
    else {
      local_1c = lss_filename;
    }
    fp = TraceFP();
    fprintf((FILE *)fp,"CSS:Reading styles from file: %s\n",local_1c);
  }
  if ((lss_filename == (char *)0x0) || (*lss_filename == '\0')) {
    local_18 = -1;
  }
  else {
    fp = LYOpenCFG(lss_filename,parent_filename,"/etc/lynx-cur/lynx.lss");
    if (fp == (FILE *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        fp = TraceFP();
        fprintf((FILE *)fp,"CSS:Can\'t open style file \'%s\', using defaults\n",lss_filename);
      }
      local_18 = -1;
    }
    else {
      if (parent_filename == (char *)0x0) {
        free_colorstylestuff();
      }
      while( true ) {
        lss_filename_00 = LYSafeGets(&buffer,fp);
        if (lss_filename_00 == (char *)0x0) break;
        LYTrimTrailing(buffer);
        LYTrimTail(buffer);
        LYTrimHead(buffer);
        iVar1 = strncasecomp(buffer,"include:",8);
        if (iVar1 == 0) {
          lss_filename_00 = LYSkipBlanks(buffer + 8);
          style_readFromFileREC(lss_filename_00,lss_filename);
        }
        else {
          if (*buffer != '#') {
            sVar2 = strlen(buffer);
            if (0 < (int)sVar2) {
              HStyle_addStyle(buffer);
            }
          }
        }
      }
      LYCloseInput(fp);
      if ((parent_filename == (char *)0x0) && (LYCursesON != '\0')) {
        parse_userstyles();
      }
      local_18 = 0;
    }
  }
  return local_18;
}



int style_readFromFile(char *filename)

{
  int iVar1;
  
  iVar1 = style_readFromFileREC(filename,(char *)0x0);
  return iVar1;
}



void TrimColorClass(char *tagname,char *styleclassname,int *phcode)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  char *local_64;
  char *lookfrom;
  char *start;
  char *end;
  char tmp [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  start = (char *)0x0;
  sprintf(tmp,";%.*s",0x3d,tagname);
  TrimLowercase(tmp);
  lookfrom = styleclassname;
  if (styleclassname != (char *)0x0) {
    while (pcVar2 = strstr(lookfrom,tmp), pcVar2 != (char *)0x0) {
      lookfrom = pcVar2 + 1;
      start = pcVar2;
    }
    if (start != (char *)0x0) {
      *start = '\0';
    }
  }
  if ((lookfrom == (char *)0x0) || (*lookfrom == '\0')) {
    local_64 = tmp + 1;
  }
  else {
    local_64 = lookfrom;
  }
  iVar3 = hash_code(local_64);
  *phcode = iVar3;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void FastTrimColorClass(char *tag_name,int name_len,char *stylename,char **pstylename_end,
                       int *phcode)

{
  bool bVar1;
  FILE *__stream;
  int iVar2;
  char *local_18;
  char *tag_start;
  BOOLEAN found;
  
  tag_start = *pstylename_end;
  bVar1 = false;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"STYLE.fast-trim: [%s] from [%s]: ",tag_name,stylename);
  }
  do {
    if (tag_start < stylename) {
LAB_080ebe46:
      if (bVar1) {
        *tag_start = '\0';
        *pstylename_end = tag_start;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        if (bVar1) {
          local_18 = "success.\n";
        }
        else {
          local_18 = "failed.\n";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,local_18);
      }
      iVar2 = hash_code(tag_start + 1);
      *phcode = iVar2;
      return;
    }
    while ((stylename <= tag_start && (*tag_start != ';'))) {
      tag_start = tag_start + -1;
    }
    iVar2 = strncasecomp(tag_start + 1,tag_name,name_len);
    if (iVar2 == 0) {
      bVar1 = true;
      goto LAB_080ebe46;
    }
    tag_start = tag_start + -1;
  } while( true );
}



void cache_tag_styles(void)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  int i;
  char buf [200];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x76) {
    LYstrncpy(buf,tags[i].name,199);
    LYLowerCase(buf);
    iVar2 = hash_code(buf);
    cached_tag_styles[i] = iVar2;
    i = i + 1;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



uint * RefCachedStyle(int y,int x)

{
  uint *result;
  
  result = (uint *)0x0;
  if (cached_styles_ptr == (uint *)0x0) {
    cached_styles_rows = display_lines;
    cached_styles_cols = LYcols;
    cached_styles_ptr = (uint *)calloc(LYcols * display_lines,4);
  }
  if ((((-1 < y) && (-1 < x)) && (y < cached_styles_rows)) && (x < cached_styles_cols)) {
    result = cached_styles_ptr + cached_styles_cols * y + x;
  }
  return result;
}



BOOLEAN ValidCachedStyle(int y,int x)

{
  uint *puVar1;
  
  puVar1 = RefCachedStyle(y,x);
  return (BOOLEAN)(puVar1 != (uint *)0x0);
}



uint GetCachedStyle(int y,int x)

{
  uint *puVar1;
  uint *cache;
  uint value;
  
  value = 0;
  puVar1 = RefCachedStyle(y,x);
  if (puVar1 != (uint *)0x0) {
    value = *puVar1;
  }
  return value;
}



void SetCachedStyle(int y,int x,uint value)

{
  uint *puVar1;
  uint *cache;
  
  puVar1 = RefCachedStyle(y,x);
  if (puVar1 != (uint *)0x0) {
    *puVar1 = value;
  }
  return;
}



void ResetCachedStyles(void)

{
  if (cached_styles_ptr != (uint *)0x0) {
    memset(cached_styles_ptr,0,cached_styles_cols * cached_styles_rows * 4);
  }
  return;
}



void FreeCachedStyles(void)

{
  if (cached_styles_ptr != (uint *)0x0) {
    if (cached_styles_ptr != (uint *)0x0) {
      free(cached_styles_ptr);
      cached_styles_ptr = (uint *)0x0;
    }
    cached_styles_rows = 0;
    cached_styles_cols = 0;
  }
  return;
}



int hash_code(char *string)

{
  char *p;
  int hash;
  
  p = string;
  hash = 0;
  while (*p != '\0') {
    hash = (int)(hash * 3 + (uint)(byte)*p) % 0x2001;
    p = p + 1;
  }
  return hash;
}



int hash_code_lowercase_on_fly(char *string)

{
  ushort **ppuVar1;
  uint local_1c;
  char *p;
  int hash;
  
  p = string;
  hash = 0;
  while (*p != '\0') {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_1c = (uint)(byte)*p;
    }
    else {
      local_1c = tolower((uint)(byte)*p);
      local_1c = local_1c & 0xff;
    }
    hash = (int)(hash * 3 + local_1c) % 0x2001;
    p = p + 1;
  }
  return hash;
}



int hash_code_aggregate_char(char c,int hash)

{
  return (int)(hash * 3 + (uint)(byte)c) % 0x2001;
}



int hash_code_aggregate_lower_str(char *string,int hash_was)

{
  ushort **ppuVar1;
  uint local_1c;
  char *p;
  int hash;
  
  p = string;
  hash = hash_was;
  while (*p != '\0') {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_1c = (uint)(byte)*p;
    }
    else {
      local_1c = tolower((uint)(byte)*p);
      local_1c = local_1c & 0xff;
    }
    hash = (int)(hash * 3 + local_1c) % 0x2001;
    p = p + 1;
  }
  return hash;
}



int html_src_tag_index(char *tagname)

{
  HTTag *pHVar1;
  int local_18;
  HTTag *tag;
  
  pHVar1 = SGMLFindTag(&HTML_dtd,tagname);
  if ((pHVar1 == (HTTag *)0x0) || (pHVar1 == &HTTag_unrecognized)) {
    local_18 = -1;
  }
  else {
    local_18 = ((int)&pHVar1[-0x250ee9].contents >> 3) * -0x49249249;
  }
  return local_18;
}



void append_close_tag(char *tagname,HT_tagspec **head,HT_tagspec **tail)

{
  size_t __nmemb;
  HTMLElement HVar1;
  HT_tagspec *pHVar2;
  BOOLEAN *pBVar3;
  char **ppcVar4;
  HT_tagspec *subj;
  HTTag *tag;
  int nattr;
  int idx;
  
  HVar1 = html_src_tag_index(tagname);
  __nmemb = tags[HVar1].number_of_attributes;
  if (HVar1 == ~HTML_A) {
    fprintf(stderr,"internal error: previous check didn\'t find bad HTML tag %s",tagname);
    exit_immediately(1);
  }
  pHVar2 = (HT_tagspec *)calloc(1,0x1c);
  pHVar2->element = HVar1;
  pBVar3 = (BOOLEAN *)calloc(__nmemb,1);
  pHVar2->present = pBVar3;
  ppcVar4 = (char **)calloc(__nmemb,4);
  pHVar2->value = ppcVar4;
  pHVar2->start = '\0';
  pHVar2->class_name = (char *)0x0;
  if (*head == (HT_tagspec *)0x0) {
    *head = pHVar2;
    *tail = pHVar2;
  }
  else {
    *(HT_tagspec **)&(*tail)->next = pHVar2;
    *tail = pHVar2;
  }
  return;
}



void append_open_tag(char *tagname,char *classname,HT_tagspec **head,HT_tagspec **tail)

{
  HT_tagspec *pHVar1;
  int hash_was;
  int hcode;
  HTTag *tag;
  HT_tagspec *subj;
  
  append_close_tag(tagname,head,tail);
  pHVar1 = *tail;
  pHVar1->start = '\x01';
  hcode = hash_code_lowercase_on_fly(tagname);
  if ((classname == (char *)0x0) || (*classname == '\0')) {
    HTSACopy(&pHVar1->class_name,"");
  }
  else {
    hash_was = hash_code_aggregate_char('.',hcode);
    hcode = hash_code_aggregate_lower_str(classname,hash_was);
    HTSACopy(&pHVar1->class_name,classname);
  }
  pHVar1->style = hcode;
  return;
}



int html_src_parse_tagspec(char *ts,HTlexeme lexeme,BOOLEAN checkonly,BOOLEAN isstart)

{
  char cVar1;
  char cVar2;
  bool bVar3;
  bool bVar4;
  char *classname;
  FILE *__stream;
  ushort **ppuVar5;
  int iVar6;
  HT_tagspec **local_68;
  int idx_1;
  int idx;
  HT_tagspec **slot;
  HT_tagspec *tail;
  HT_tagspec *head;
  html_src_check_state state;
  char *classend;
  char *classstart;
  char *tagend;
  char *tagstart;
  char *p;
  char after_excl;
  char save1;
  char save;
  BOOLEAN code;
  BOOLEAN stop;
  
  bVar4 = false;
  code = '\0';
  p = ts;
  tagstart = (char *)0x0;
  tagend = (char *)0x0;
  bVar3 = false;
  state = HTSRC_CK_normal;
  head = (HT_tagspec *)0x0;
  tail = (HT_tagspec *)0x0;
  if (isstart == '\0') {
    local_68 = lexeme_end;
  }
  else {
    local_68 = lexeme_start;
  }
  do {
    classname = p;
    if (bVar4) {
      if ((code != '\0') && (checkonly == '\0')) {
        local_68[lexeme] = head;
      }
      return (int)code;
    }
    if (state == HTSRC_CK_after_tagname) {
      cVar1 = *p;
      if (cVar1 != ' ') {
        if (' ' < cVar1) {
          if (cVar1 == '.') {
            if (bVar3) {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"dot after \'!\' at column %d:\n\t%s\n",p + (1 - (int)ts),
                        ts);
              }
              bVar4 = true;
            }
            else {
              state = HTSRC_CK_seen_dot;
            }
            goto LAB_080ecb1a;
          }
LAB_080ec8f6:
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            cVar1 = *p;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"unexpected char \'%c\' after tagname at column %d:\n\t%s\n",
                    (int)cVar1,p + (1 - (int)ts),ts);
          }
          bVar4 = true;
          goto LAB_080ecb1a;
        }
        if (cVar1 == '\0') {
          bVar4 = true;
          code = '\x01';
        }
        else {
          if (cVar1 != '\t') goto LAB_080ec8f6;
        }
      }
      cVar1 = *tagend;
      *tagend = '\0';
      if (checkonly == '\0') {
        if (bVar3) {
          append_close_tag(tagstart,&head,&tail);
        }
        else {
          append_open_tag(tagstart,(char *)0x0,&head,&tail);
        }
      }
      else {
        iVar6 = html_src_tag_index(tagstart);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"tag index(%s) = %d\n",tagstart,iVar6);
        }
        *tagend = cVar1;
        if (iVar6 == -1) {
          bVar4 = true;
          goto LAB_080ecb1a;
        }
      }
      state = HTSRC_CK_normal;
      bVar3 = false;
    }
    else {
      if (state < HTSRC_CK_after_tagname) {
        cVar1 = *p;
        if (cVar1 != ' ') {
          if (cVar1 < '!') {
            if (cVar1 == '\0') {
              bVar4 = true;
              code = '\x01';
            }
            else {
              if (cVar1 != '\t') goto LAB_080ec6a6;
            }
          }
          else {
            if (cVar1 == '!') {
              if (state == HTSRC_CK_seen_excl) {
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"second \'!\' at column %d:\n\t%s\n",p + (1 - (int)ts),ts
                         );
                }
                bVar4 = true;
              }
              else {
                state = HTSRC_CK_seen_excl;
                bVar3 = true;
              }
            }
            else {
LAB_080ec6a6:
              ppuVar5 = __ctype_b_loc();
              if ((((*ppuVar5)[(byte)*p] & 0x400) == 0) && (*p != '_')) {
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"no name starting at column %d:\n\t%s\n",
                          p + (1 - (int)ts),ts);
                }
                bVar4 = true;
              }
              else {
                tagstart = p;
                while ((*p != '\0' &&
                       ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*p] & 8) != 0 || (*p == '_')))
                       )) {
                  p = p + 1;
                }
                tagend = p;
                p = p + -1;
                state = HTSRC_CK_after_tagname;
              }
            }
          }
        }
      }
      else {
        if (((state == HTSRC_CK_seen_dot) && (cVar1 = *p, cVar1 != '\t')) && (cVar1 != ' ')) {
          if (cVar1 == '\0') {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"expected text after dot at column %d:\n\t%s\n",
                      p + (1 - (int)ts),ts);
            }
            bVar4 = true;
          }
          else {
            ppuVar5 = __ctype_b_loc();
            if ((((*ppuVar5)[(byte)*p] & 0x400) == 0) && (*p != '_')) {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"no name starting at column %d:\n\t%s\n",p + (1 - (int)ts),
                        ts);
              }
              bVar4 = true;
            }
            else {
              while ((*p != '\0' &&
                     ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*p] & 8) != 0 || (*p == '_')))))
              {
                p = p + 1;
              }
              cVar1 = *p;
              *p = '\0';
              cVar2 = *tagend;
              *tagend = '\0';
              if (checkonly == '\0') {
                append_open_tag(tagstart,classname,&head,&tail);
              }
              else {
                iVar6 = html_src_tag_index(tagstart);
                *tagend = cVar2;
                *p = cVar1;
                if (iVar6 == -1) {
                  return 0;
                }
              }
              state = HTSRC_CK_normal;
              bVar3 = false;
              p = p + -1;
            }
          }
        }
      }
    }
LAB_080ecb1a:
    p = p + 1;
  } while( true );
}



void html_src_clean_item(HTlexeme l)

{
  HT_tagspec *pHVar1;
  HT_tagspec **local_18;
  HT_tagspec *ts;
  HT_tagspec **pts;
  HT_tagspec *cur;
  int i;
  
  if ((HTL_tagspecs[l] != (char *)0x0) && (HTL_tagspecs[l] != (char *)0x0)) {
    free(HTL_tagspecs[l]);
    HTL_tagspecs[l] = (char *)0x0;
  }
  i = 0;
  while (i < 2) {
    if (i == 0) {
      local_18 = lexeme_end;
    }
    else {
      local_18 = lexeme_start;
    }
    pHVar1 = local_18[l];
    local_18[l] = (HT_tagspec *)0x0;
    while (ts = pHVar1, ts != (HT_tagspec *)0x0) {
      if (ts->present != (BOOLEAN *)0x0) {
        free(ts->present);
        ts->present = (BOOLEAN *)0x0;
      }
      if (ts->value != (char **)0x0) {
        free(ts->value);
        ts->value = (char **)0x0;
      }
      if ((ts->start != '\0') && (ts->class_name != (char *)0x0)) {
        free(ts->class_name);
        ts->class_name = (char *)0x0;
      }
      pHVar1 = (HT_tagspec *)ts->next;
      if (ts != (HT_tagspec *)0x0) {
        free(ts);
      }
    }
    i = i + 1;
  }
  return;
}



void html_src_clean_data(void)

{
  int i;
  
  i = 0;
  while (i < 0xc) {
    html_src_clean_item(i);
    i = i + 1;
  }
  return;
}



void html_src_on_lynxcfg_reload(void)

{
  html_src_clean_data();
  HTMLSRC_init_caches('\x01');
  return;
}



void failed_init(char *tag,int lexeme)

{
  char *__format;
  
  __format = (char *)gettext("parse-error while caching %s tagspec of lexeme %d\n");
  fprintf(stderr,__format,tag,lexeme);
  __format = (char *)gettext("Use -trace -trace-mask=8 to see details in log.\n");
  fprintf(stderr,__format);
  exit_immediately(1);
  return;
}



void HTMLSRC_init_caches(BOOLEAN dont_exit)

{
  int iVar1;
  FILE *__stream;
  int iVar2;
  int in_GS_OFFSET;
  char *local_418;
  char *local_410;
  char *p;
  int i;
  char buf [1000];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLSRC_init_caches(%d tagspecs)\n",0xc);
  }
  i = 0;
  while (i < 0xc) {
    if (HTL_tagspecs[i] == (char *)0x0) {
      local_418 = HTL_tagspecs_defaults[i];
    }
    else {
      local_418 = HTL_tagspecs[i];
    }
    LYstrncpy(buf,local_418,999);
    HTSACopy(HTL_tagspecs + i,buf);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"parsing lexeme %d: %s\n",i + 1,buf);
    }
    local_410 = strchr(buf,0x3a);
    if (local_410 != (char *)0x0) {
      *local_410 = '\0';
    }
    iVar2 = html_src_parse_tagspec(buf,i,'\0','\x01');
    if ((iVar2 == 0) && (dont_exit == '\0')) {
      failed_init("1st",i);
    }
    if (local_410 == (char *)0x0) {
      local_410 = (char *)0x0;
    }
    else {
      local_410 = local_410 + 1;
    }
    iVar2 = html_src_parse_tagspec(local_410,i,'\0','\0');
    if ((iVar2 == 0) && (dont_exit == '\0')) {
      failed_init("2nd",i);
    }
    i = i + 1;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * cellstate_s(cellstate_t state)

{
  char *result;
  
  result = "?";
  switch(state) {
  case CS__new:
    result = "CS__new";
    break;
  case CS__0new:
    result = "CS__0new";
    break;
  case CS__0eb:
    result = "CS__0eb";
    break;
  case CS__eb:
    result = "CS__eb";
    break;
  case CS__0cb:
    result = "CS__0cb";
    break;
  case CS__cb:
    result = "CS__cb";
    break;
  case CS__0ef:
    result = "CS__0ef";
    break;
  case CS__ef:
    result = "CS__ef";
    break;
  case CS__0cf:
    result = "CS__0cf";
    break;
  case CS__cf:
    result = "CS__cf";
    break;
  case CS__ebc:
    result = "CS__ebc";
    break;
  case CS__cbc:
    result = "CS__cbc";
    break;
  case CS_invalid:
    result = "CS_invalid";
  }
  return result;
}



STable_info * Stbl_startTABLE(short alignment)

{
  STable_info *pSVar1;
  FILE *__stream;
  STable_info *me;
  
  pSVar1 = (STable_info *)calloc(1,0x78);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_startTABLE(align=%d)\n",(int)alignment);
  }
  if (pSVar1 != (STable_info *)0x0) {
    pSVar1->alignment = alignment;
    pSVar1->rowgroup_align = -1;
    pSVar1->pending_colgroup_align = -1;
    (pSVar1->s).x_td = -1;
    (pSVar1->s).icell_core = -1;
    if (nested_tables != '\0') {
      pSVar1->enclosing = (_STable_info *)0x0;
    }
  }
  return pSVar1;
}



void free_rowinfo(STable_rowinfo *me)

{
  if (((me != (STable_rowinfo *)0x0) && (me->allocated != 0)) &&
     (me->cells != (STable_cellinfo *)0x0)) {
    free(me->cells);
    me->cells = (STable_cellinfo *)0x0;
  }
  return;
}



void Stbl_free(STable_info *me)

{
  FILE *__stream;
  int i;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_free()\n");
  }
  if (((me != (STable_info *)0x0) && (me->allocated_rows != 0)) &&
     (me->rows != (STable_rowinfo *)0x0)) {
    i = 0;
    while (i < me->allocated_rows) {
      free_rowinfo(me->rows + i);
      i = i + 1;
    }
    if (me->rows != (STable_rowinfo *)0x0) {
      free(me->rows);
      me->rows = (STable_rowinfo *)0x0;
    }
  }
  free_rowinfo(&me->rowspans2eog);
  if ((me != (STable_info *)0x0) && (me->sumcols != (STable_cellinfo *)0x0)) {
    free(me->sumcols);
    me->sumcols = (STable_cellinfo *)0x0;
  }
  if (me != (STable_info *)0x0) {
    free(me);
  }
  return;
}



int Stbl_addCellToRow(STable_rowinfo *me,STable_cellinfo *colinfo,int ncolinfo,STable_states *s,
                     int colspan,int alignment,int isheader,int lineno,int *ppos)

{
  int iVar1;
  int iVar2;
  int iVar3;
  FILE *__stream;
  char *pcVar4;
  char *pcVar5;
  uint uVar6;
  byte local_4c;
  int local_48;
  int local_34;
  int growby;
  int ret;
  cellstate_t newstate;
  int last_colspan;
  int i;
  STable_cellinfo *cells;
  
  if (me->ncells == 0) {
    local_48 = 1;
  }
  else {
    local_48 = me->cells[me->ncells + -1].colspan;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    iVar1 = *ppos;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addCellToRow, line=%d, pos=%d, colspan=%d\n",lineno,iVar1,
            colspan);
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar4 = cellstate_s(s->state);
    pcVar5 = cellstate_s(s->prev_state);
    iVar1 = s->pending_len;
    iVar2 = s->lineno;
    iVar3 = me->ncells;
    __stream = TraceFP();
    fprintf((FILE *)__stream," ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n",iVar3
            ,iVar2,iVar1,pcVar5,pcVar4);
  }
  if (me->ncells == 0) {
    s->prev_state = CS_invalid;
  }
  else {
    if ((s->prev_state == CS_invalid) ||
       (((s->state != CS__0new && (s->state != CS__ef)) && (s->state != CS__0ef)))) {
      s->prev_state = s->state;
    }
  }
  if ((me->ncells == 0) || (*ppos == 0)) {
    newstate = CS__0new;
  }
  else {
    newstate = CS__new;
  }
  if ((0 < me->ncells) && (0 < s->pending_len)) {
    if (s->prev_state != CS__cbc) {
      me->cells[me->ncells + -1].len = s->pending_len;
    }
    s->pending_len = 0;
  }
  s->x_td = *ppos;
  if (s->lineno == lineno) {
    switch(s->prev_state) {
    case CS__new:
    case CS__cf:
      if ((me->fixed_line == '\0') || (me->Line == lineno)) {
        me->fixed_line = '\x01';
        me->Line = lineno;
      }
      break;
    default:
      goto switchD_080ed682_caseD_ffffffff;
    }
trace_and_fail:
    ret = -1;
  }
  else {
    if (me->fixed_line == '\0') {
      if ((me->ncells == 0) || (*ppos == 0)) {
        uVar6 = s->prev_state + 1;
        if (uVar6 < 10) {
          local_4c = (byte)uVar6;
          uVar6 = 1 << (local_4c & 0x1f);
          if ((uVar6 & 0x2ad) == 0) {
            if ((uVar6 & 0x40) != 0) {
              *ppos = me->cells[me->ncells + -1].pos + me->cells[me->ncells + -1].len;
            }
          }
          else {
            if (0 < me->ncells) {
              i = me->ncells + local_48 + -2;
              while (me->ncells + -1 <= i) {
                me->cells[i].pos = *ppos;
                me->cells[i].cLine = lineno;
                i = i + -1;
              }
            }
            me->Line = lineno;
          }
        }
      }
      else {
        switch(s->prev_state) {
        default:
          me->fixed_line = '\x01';
          break;
        case CS__0new:
        case CS__0eb:
        case CS__0ef:
          break;
        case CS__0cb:
        case CS__0cf:
          if (me->cells->pos < *ppos) {
            me->Line = lineno;
          }
          me->fixed_line = '\x01';
          break;
        case CS__cb:
        case CS__cf:
        case CS__cbc:
          goto trace_and_fail;
        }
      }
    }
    if ((me->fixed_line != '\0') && (me->Line != lineno)) {
      switch(s->prev_state) {
      default:
        *ppos = me->cells[me->ncells + -1].pos;
        break;
      case CS__0cb:
      case CS__0cf:
        if ((*ppos == 0) || (*ppos <= me->cells->pos)) {
          *ppos = me->cells[me->ncells + -1].pos + me->cells[me->ncells + -1].len;
        }
        break;
      case CS__cb:
      case CS__cf:
        if (0 < *ppos) goto trace_and_fail;
        *ppos = me->cells[me->ncells + -1].pos + me->cells[me->ncells + -1].len;
        break;
      case CS_invalid:
      case CS__0new:
      case CS__0eb:
      case CS__0ef:
      case CS__cbc:
        break;
      }
    }
    s->lineno = lineno;
switchD_080ed682_caseD_ffffffff:
    s->state = newstate;
    if ((0 < me->ncells) && (1 < me->cells[me->ncells + -1].colspan)) {
      me->ncells = me->ncells + me->cells[me->ncells + -1].colspan + -1;
    }
    while ((me->ncells < me->allocated && (me->cells[me->ncells].alignment == -2))) {
      me->ncells = me->ncells + 1;
    }
    growby = 0;
    while (me->allocated + growby < me->ncells + colspan + 1) {
      growby = growby + 0x10;
    }
    if (growby != 0) {
      if ((me->allocated == 0) && (me->cells == (STable_cellinfo *)0x0)) {
        cells = (STable_cellinfo *)calloc(growby,0x14);
      }
      else {
        cells = (STable_cellinfo *)realloc(me->cells,(me->allocated + growby) * 0x14);
        i = 0;
        while ((cells != (STable_cellinfo *)0x0 && (i < growby))) {
          cells[me->allocated + i].alignment = -1;
          i = i + 1;
        }
      }
      if (cells == (STable_cellinfo *)0x0) goto trace_and_fail;
      me->allocated = me->allocated + growby;
      me->cells = cells;
    }
    me->cells[me->ncells].cLine = lineno;
    me->cells[me->ncells].pos = *ppos;
    me->cells[me->ncells].len = -1;
    me->cells[me->ncells].colspan = colspan;
    if (alignment == -1) {
      if (ncolinfo < me->ncells + 1) {
        me->cells[me->ncells].alignment = me->alignment;
      }
      else {
        me->cells[me->ncells].alignment = colinfo[me->ncells].alignment;
      }
      if (me->cells[me->ncells].alignment == -1) {
        me->cells[me->ncells].alignment = me->alignment;
      }
      if (me->cells[me->ncells].alignment == -1) {
        if (isheader == 0) {
          local_34 = 1;
        }
        else {
          local_34 = 3;
        }
        me->cells[me->ncells].alignment = local_34;
      }
    }
    else {
      me->cells[me->ncells].alignment = alignment;
    }
    i = me->ncells;
    while (i = i + 1, i < me->ncells + colspan) {
      me->cells[i].cLine = lineno;
      me->cells[i].pos = *ppos;
      me->cells[i].len = -1;
      me->cells[i].colspan = 0;
      me->cells[i].alignment = 1;
    }
    me->cells[me->ncells + colspan].pos = -1;
    me->ncells = me->ncells + 1;
    ret = me->ncells + -1;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar4 = cellstate_s(s->state);
    pcVar5 = cellstate_s(s->prev_state);
    __stream = TraceFP();
    fprintf((FILE *)__stream," => prev_state=%s, state=%s, ret=%d\n",pcVar5,pcVar4,ret);
  }
  return ret;
}



int Stbl_reserveCellsInRow(STable_rowinfo *me,int icell,int colspan)

{
  FILE *__stream;
  STable_cellinfo *pSVar1;
  int iVar2;
  int growby;
  int i;
  STable_cellinfo *cells;
  
  iVar2 = (icell + 1 + colspan) - me->allocated;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_reserveCellsInRow(icell=%d, colspan=%d\n",icell,colspan);
  }
  if (0 < iVar2) {
    pSVar1 = (STable_cellinfo *)realloc(me->cells,(me->allocated + iVar2) * 0x14);
    if (pSVar1 == (STable_cellinfo *)0x0) {
      return -1;
    }
    i = 0;
    while (i < iVar2) {
      pSVar1[me->allocated + i].alignment = -1;
      i = i + 1;
    }
    me->allocated = me->allocated + iVar2;
    me->cells = pSVar1;
  }
  i = icell;
  while (i < icell + colspan) {
    me->cells[i].cLine = -1;
    me->cells[i].pos = -1;
    me->cells[i].len = -1;
    me->cells[i].colspan = 0;
    me->cells[i].alignment = -2;
    i = i + 1;
  }
  me->cells[icell].colspan = colspan;
  return 0;
}



int Stbl_finishCellInRow(STable_rowinfo *me,STable_states *s,int end_td,int lineno,int pos)

{
  STable_cellinfo *pSVar1;
  int iVar2;
  int iVar3;
  FILE *__stream;
  char *pcVar4;
  char *pcVar5;
  bool bVar6;
  int local_c8;
  uint local_c4;
  cellstate_t local_bc;
  cellstate_t local_b8;
  cellstate_t local_b4;
  int local_b0;
  cellstate_t local_ac;
  cellstate_t local_a8;
  cellstate_t local_a4;
  int local_a0;
  int local_9c;
  cellstate_t local_98;
  cellstate_t local_94;
  cellstate_t local_90;
  cellstate_t local_8c;
  cellstate_t local_88;
  int local_84;
  cellstate_t local_80;
  cellstate_t local_7c;
  int local_78;
  int local_74;
  cellstate_t local_70;
  cellstate_t local_6c;
  cellstate_t local_68;
  int local_64;
  cellstate_t local_60;
  cellstate_t local_5c;
  int local_58;
  int local_54;
  cellstate_t local_50;
  cellstate_t local_4c;
  cellstate_t local_48;
  cellstate_t local_44;
  int local_40;
  cellstate_t local_3c;
  int local_38;
  cellstate_t local_34;
  int ret;
  int empty;
  int multiline;
  cellstate_t newstate;
  STable_cellinfo *lastcell;
  
  newstate = CS_invalid;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    iVar2 = s->pending_len;
    iVar3 = me->ncells;
    __stream = TraceFP();
    fprintf((FILE *)__stream,
            "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",lineno,pos,
            end_td,iVar3,iVar2);
  }
  if (me->ncells < 1) {
    return -1;
  }
  pSVar1 = me->cells + me->ncells + -1;
  if ((pSVar1->cLine == lineno) && (s->lineno == lineno)) {
    local_c8 = 0;
  }
  else {
    local_c8 = 1;
  }
  if (local_c8 == 0) {
    bVar6 = pos <= s->x_td;
  }
  else {
    bVar6 = pos == 0;
  }
  local_c4 = (uint)bVar6;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar4 = cellstate_s(s->state);
    pcVar5 = cellstate_s(s->prev_state);
    iVar2 = s->lineno;
    iVar3 = pSVar1->cLine;
    __stream = TraceFP();
    fprintf((FILE *)__stream,
            " [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n",iVar3,iVar2,
            local_c8,local_c4,pcVar5,pcVar4);
  }
  if (local_c8 == 0) {
    if ((end_td & 1U) != 0) {
      s->x_td = -1;
      switch(s->state) {
      case CS__new:
        ret = -1;
        if ((bVar6 != false) || (s->prev_state != CS__cbc)) {
          if (bVar6 == false) {
            if (me->fixed_line == '\0') {
              me->fixed_line = '\x01';
              me->Line = lineno;
            }
            else {
              if (me->Line != lineno) goto trace_and_return;
            }
          }
          if (pSVar1->len < 0) {
            if (bVar6 == false) {
              local_40 = pos - pSVar1->pos;
            }
            else {
              local_40 = 0;
            }
            pSVar1->len = local_40;
          }
          if (bVar6 == false) {
            local_3c = CS__cf;
          }
          else {
            local_3c = CS__ef;
          }
          s->state = local_3c;
          if ((me->fixed_line == '\0') || (me->Line == lineno)) {
            local_38 = pSVar1->len;
          }
          else {
            local_38 = -1;
          }
          ret = local_38;
        }
        goto trace_and_return;
      case CS__0eb:
        newstate = CS__0ef;
        break;
      case CS__eb:
        if (bVar6 == false) {
          local_34 = CS__cf;
        }
        else {
          local_34 = CS__ef;
        }
        newstate = local_34;
        break;
      case CS__0cb:
        if (bVar6 == false) {
          local_44 = CS__cbc;
        }
        else {
          local_44 = CS__0cf;
        }
        newstate = local_44;
        break;
      case CS__cb:
        newstate = CS__cf;
        break;
      case CS__0ef:
        newstate = CS__0ef;
        break;
      case CS_invalid:
        if ((me->fixed_line == '\0') || (me->Line != pSVar1->cLine)) {
          pSVar1->len = 0;
        }
      case CS__0new:
        if (bVar6 == false) {
          local_48 = CS__0cf;
        }
        else {
          local_48 = CS__0ef;
        }
        newstate = local_48;
      }
      pSVar1->len = pos - pSVar1->pos;
      goto switchD_080ee77e_caseD_6;
    }
    switch(s->state) {
    case CS__new:
      ret = -1;
      if ((bVar6 != false) || (s->prev_state != CS__cbc)) {
        if (bVar6 == false) {
          if (me->fixed_line == '\0') {
            me->fixed_line = '\x01';
            me->Line = lineno;
          }
          else {
            if (me->Line != lineno) goto trace_and_return;
          }
        }
        if (bVar6 == false) {
          local_5c = CS__cb;
        }
        else {
          local_5c = CS__eb;
        }
        s->state = local_5c;
        if (me->fixed_line == '\0') {
          if (bVar6 == false) {
            local_58 = pos - pSVar1->pos;
          }
          else {
            local_58 = 0;
          }
          s->pending_len = local_58;
          ret = 0;
        }
        else {
          s->pending_len = 0;
          if (bVar6 == false) {
            local_54 = pos - pSVar1->pos;
          }
          else {
            local_54 = 0;
          }
          pSVar1->len = local_54;
          ret = pSVar1->len;
        }
      }
      goto trace_and_return;
    case CS__0eb:
      newstate = CS__eb;
      break;
    case CS__eb:
      if (bVar6 == false) {
        local_50 = CS__ebc;
      }
      else {
        local_50 = CS__eb;
      }
      newstate = local_50;
      break;
    case CS__0cb:
      newstate = CS__cb;
      break;
    case CS__cb:
      if (bVar6 == false) {
        local_4c = CS__cbc;
      }
      else {
        local_4c = CS__cb;
      }
      newstate = local_4c;
      break;
    case CS__ef:
      ret = 0;
      goto trace_and_return;
    case CS__cf:
      ret = pSVar1->len;
      goto trace_and_return;
    case CS_invalid:
    case CS__0new:
      if (bVar6 == false) {
        local_64 = pos - pSVar1->pos;
      }
      else {
        local_64 = 0;
      }
      s->pending_len = local_64;
      if (bVar6 == false) {
        local_60 = CS__0cb;
      }
      else {
        local_60 = CS__0eb;
      }
      s->state = local_60;
      ret = 0;
      goto trace_and_return;
    }
    goto switchD_080ee77e_caseD_6;
  }
  if ((end_td & 1U) != 0) {
    s->x_td = -1;
    switch(s->state) {
    case CS__new:
      if (bVar6 == false) {
        local_7c = CS__cf;
      }
      else {
        local_7c = CS__ef;
      }
      newstate = local_7c;
      break;
    case CS__0new:
      if (bVar6 == false) {
        local_8c = CS__0cf;
      }
      else {
        local_8c = CS__0ef;
      }
      newstate = local_8c;
      break;
    case CS__0eb:
      if (bVar6 == false) {
        local_88 = CS__0cf;
      }
      else {
        local_88 = CS__0ef;
      }
      s->state = local_88;
      if (me->fixed_line == '\0') {
        if (bVar6 == false) {
          ret = 0;
        }
        else {
          ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
        }
      }
      else {
        if (bVar6 == false) {
          if (pSVar1->len < 1) {
            local_84 = 0;
          }
          else {
            local_84 = -1;
          }
          ret = local_84;
        }
        else {
          ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
        }
      }
      goto trace_and_return;
    case CS__eb:
      s->state = CS__ef;
      if (me->fixed_line == '\0') {
        if (bVar6 == false) {
          if (pSVar1->len < 1) {
            local_74 = 0;
          }
          else {
            local_74 = -1;
          }
          ret = local_74;
        }
        else {
          ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
        }
      }
      else {
        if (bVar6 == false) {
          if (pSVar1->len < 1) {
            local_78 = 0;
          }
          else {
            local_78 = -1;
          }
          ret = local_78;
        }
        else {
          ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
        }
      }
      goto trace_and_return;
    case CS__0cb:
      if (s->pending_len != 0) {
        if (bVar6 == false) {
          pSVar1->len = 0;
        }
        else {
          pSVar1->len = s->pending_len;
        }
        s->pending_len = 0;
      }
      if (me->fixed_line == '\0') {
        if (bVar6 == false) {
          if (s->icell_core == -1) {
            me->Line = -1;
          }
        }
        else {
          if (s->icell_core == -1) {
            s->icell_core = me->ncells + -1;
          }
        }
      }
      if ((s->pending_len != 0) && (bVar6 != false)) {
        pSVar1->len = s->pending_len;
        s->pending_len = 0;
      }
      if (bVar6 == false) {
        local_80 = CS__cbc;
      }
      else {
        local_80 = CS__0cf;
      }
      newstate = local_80;
      break;
    case CS__cb:
      if ((s->pending_len != 0) && (bVar6 != false)) {
        pSVar1->len = s->pending_len;
        s->pending_len = 0;
      }
      ret = -1;
      if (bVar6 == false) goto trace_and_return;
      if (me->fixed_line == '\0') {
        me->fixed_line = '\x01';
        me->Line = pSVar1->cLine;
      }
      else {
        if (me->Line != pSVar1->cLine) goto trace_and_return;
      }
      if (bVar6 == false) {
        local_70 = CS__cbc;
      }
      else {
        local_70 = CS__cf;
      }
      newstate = local_70;
      break;
    case CS__0ef:
      newstate = CS__0ef;
      break;
    case CS__ebc:
      pSVar1->len = 0;
      if (((me->fixed_line == '\0') && (bVar6 == false)) && (s->icell_core == -1)) {
        pSVar1->cLine = -1;
      }
      s->pending_len = 0;
      if (bVar6 == false) {
        local_6c = CS__cbc;
      }
      else {
        local_6c = CS_invalid;
      }
      newstate = local_6c;
      break;
    case CS__cbc:
      pSVar1->len = 0;
      ret = -1;
      if ((me->fixed_line != '\0') && (me->Line == pSVar1->cLine)) goto trace_and_return;
      if ((me->fixed_line == '\0') && ((bVar6 != false && (s->icell_core == -1)))) {
        me->Line = lineno;
      }
      s->pending_len = 0;
      if (bVar6 == false) {
        local_68 = CS__cbc;
      }
      else {
        local_68 = CS_invalid;
      }
      newstate = local_68;
      break;
    case CS_invalid:
      if ((bVar6 == false) && (0 < pSVar1->len)) {
        s->state = CS__0cf;
        ret = -1;
        goto trace_and_return;
      }
      pSVar1->len = 0;
      pSVar1->cLine = -1;
      if (bVar6 == false) {
        local_90 = CS__cbc;
      }
      else {
        local_90 = CS_invalid;
      }
      newstate = local_90;
    }
    goto switchD_080ee77e_caseD_6;
  }
  switch(s->state) {
  case CS__new:
    if (bVar6 == false) {
      local_a8 = CS__cb;
    }
    else {
      local_a8 = CS__eb;
    }
    newstate = local_a8;
    break;
  case CS__0new:
    if (bVar6 == false) {
      local_b8 = CS__0cb;
    }
    else {
      local_b8 = CS__0eb;
    }
    newstate = local_b8;
    break;
  case CS__0eb:
    if (bVar6 == false) {
      local_b4 = CS__ebc;
    }
    else {
      local_b4 = CS__0eb;
    }
    s->state = local_b4;
    if (me->fixed_line == '\0') {
      if (bVar6 == false) {
        ret = 0;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
    }
    else {
      if (bVar6 == false) {
        if (pSVar1->len < 1) {
          local_b0 = 0;
        }
        else {
          local_b0 = -1;
        }
        ret = local_b0;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
    }
    goto trace_and_return;
  case CS__eb:
    if (bVar6 == false) {
      local_a4 = CS__ebc;
    }
    else {
      local_a4 = CS__eb;
    }
    s->state = local_a4;
    if (me->fixed_line == '\0') {
      if (bVar6 == false) {
        if (pSVar1->len < 1) {
          local_9c = 0;
        }
        else {
          local_9c = -1;
        }
        ret = local_9c;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
    }
    else {
      if (bVar6 == false) {
        if (pSVar1->len < 1) {
          local_a0 = 0;
        }
        else {
          local_a0 = -1;
        }
        ret = local_a0;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
    }
    goto trace_and_return;
  case CS__0cb:
    if (((me->fixed_line == '\0') && (bVar6 == false)) && (s->icell_core == -1)) {
      me->Line = -1;
    }
    if ((s->pending_len != 0) && (bVar6 != false)) {
      if (((me->fixed_line != '\0') && (me->Line == pSVar1->cLine)) ||
         (s->icell_core == me->ncells + -1)) {
        pSVar1->len = s->pending_len;
      }
      s->pending_len = 0;
    }
    if (bVar6 == false) {
      local_ac = CS__cbc;
    }
    else {
      local_ac = CS__0cb;
    }
    newstate = local_ac;
    break;
  case CS__cb:
    if ((s->pending_len != 0) && (bVar6 != false)) {
      pSVar1->len = s->pending_len;
      s->pending_len = 0;
    }
    ret = -1;
    if (bVar6 == false) {
      if (me->fixed_line == '\0') {
        me->fixed_line = '\x01';
        me->Line = pSVar1->cLine;
      }
      s->state = CS__cbc;
      goto trace_and_return;
    }
    if (me->fixed_line == '\0') {
      me->fixed_line = '\x01';
      me->Line = pSVar1->cLine;
    }
    else {
      if (me->Line != pSVar1->cLine) goto trace_and_return;
    }
    if (bVar6 == false) {
      local_98 = CS__cbc;
    }
    else {
      local_98 = CS__cb;
    }
    newstate = local_98;
    break;
  case CS__ef:
    ret = 0;
    goto trace_and_return;
  case CS__cf:
    ret = pSVar1->len;
    goto trace_and_return;
  case CS__cbc:
    if (me->fixed_line == '\0') {
      if (bVar6 == false) {
        if (s->icell_core == -1) {
          me->Line = -1;
        }
      }
      else {
        if (s->icell_core == -1) {
          me->Line = lineno;
        }
      }
    }
    s->pending_len = 0;
    if (bVar6 == false) {
      local_94 = CS__cbc;
    }
    else {
      local_94 = CS_invalid;
    }
    newstate = local_94;
    break;
  case CS_invalid:
    if (bVar6 == false) {
      local_bc = CS__cbc;
    }
    else {
      local_bc = CS_invalid;
    }
    newstate = local_bc;
  }
switchD_080ee77e_caseD_6:
  s->state = newstate;
  ret = pSVar1->len;
  if (((nested_tables != '\0') && (ret == -1)) && (pos == 0)) {
    ret = 0;
  }
trace_and_return:
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar4 = cellstate_s(s->state);
    pcVar5 = cellstate_s(s->prev_state);
    __stream = TraceFP();
    fprintf((FILE *)__stream," => prev_state=%s, state=%s, return=%d\n",pcVar5,pcVar4,ret);
  }
  return ret;
}



int Stbl_reserveCellsInTable(STable_info *me,int icell,int colspan,int rowspan)

{
  FILE *__stream;
  STable_cellinfo *pSVar1;
  STable_rowinfo *pSVar2;
  STable_rowinfo *pSVar3;
  int iVar4;
  int local_28;
  size_t local_24;
  size_t local_1c;
  int local_18;
  int i;
  int growby;
  STable_rowinfo *row;
  STable_rowinfo *rows;
  
  if (colspan < 0xc9) {
    if (rowspan < 0xc9) {
      if (me->nrows < 1) {
        local_28 = -1;
      }
      else {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n",icell,colspan,
                  rowspan);
        }
        if (rowspan == 0) {
          if ((me->rowspans2eog).cells == (STable_cellinfo *)0x0) {
            local_24 = icell + colspan;
            if ((int)local_24 < 1) {
              local_24 = 1;
            }
            pSVar1 = (STable_cellinfo *)calloc(local_24,0x14);
            (me->rowspans2eog).cells = pSVar1;
            if ((me->rowspans2eog).cells == (STable_cellinfo *)0x0) {
              return 0;
            }
            (me->rowspans2eog).allocated = icell + colspan;
          }
          Stbl_reserveCellsInRow(&me->rowspans2eog,icell,colspan);
        }
        iVar4 = (me->nrows + rowspan + -1) - me->allocated_rows;
        if (0 < iVar4) {
          pSVar2 = (STable_rowinfo *)realloc(me->rows,(me->allocated_rows + iVar4) * 0x24);
          if (pSVar2 == (STable_rowinfo *)0x0) {
            return 0;
          }
          i = 0;
          while (i < iVar4) {
            pSVar3 = pSVar2 + me->allocated_rows + i;
            pSVar3->allocated = 0;
            pSVar3->offset = 0;
            pSVar3->content = 0;
            if ((me->rowspans2eog).allocated == 0) {
              pSVar3->cells = (STable_cellinfo *)0x0;
            }
            else {
              pSVar1 = (STable_cellinfo *)calloc((me->rowspans2eog).allocated,0x14);
              pSVar3->cells = pSVar1;
              if (pSVar3->cells != (STable_cellinfo *)0x0) {
                pSVar3->allocated = (me->rowspans2eog).allocated;
                memcpy(pSVar3->cells,(me->rowspans2eog).cells,pSVar3->allocated * 0x14);
              }
            }
            pSVar3->ncells = 0;
            pSVar3->fixed_line = '\0';
            pSVar3->alignment = -1;
            i = i + 1;
          }
          me->allocated_rows = me->allocated_rows + iVar4;
          me->rows = pSVar2;
        }
        i = me->nrows;
        while( true ) {
          if (rowspan == 0) {
            local_18 = me->allocated_rows;
          }
          else {
            local_18 = me->nrows + rowspan + -1;
          }
          if (local_18 <= i) break;
          if (me->rows[i].allocated == 0) {
            pSVar2 = me->rows;
            local_1c = icell + colspan;
            if ((int)local_1c < 1) {
              local_1c = 1;
            }
            pSVar1 = (STable_cellinfo *)calloc(local_1c,0x14);
            pSVar2[i].cells = pSVar1;
            if (me->rows[i].cells == (STable_cellinfo *)0x0) {
              return 0;
            }
            me->rows[i].allocated = icell + colspan;
          }
          Stbl_reserveCellsInRow(me->rows + i,icell,colspan);
          i = i + 1;
        }
        local_28 = 0;
      }
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"TRST:*** ROWSPAN=%d is too large, ignored!\n",rowspan);
      }
      local_28 = -1;
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"TRST:*** COLSPAN=%d is too large, ignored!\n",colspan);
    }
    local_28 = -1;
  }
  return local_28;
}



void Stbl_cancelRowSpans(STable_info *me)

{
  FILE *__stream;
  int i;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_cancelRowSpans()");
  }
  i = me->nrows;
  while (i < me->allocated_rows) {
    if (me->rows[i].ncells == 0) {
      if (me->rows[i].cells != (STable_cellinfo *)0x0) {
        free(me->rows[i].cells);
        me->rows[i].cells = (STable_cellinfo *)0x0;
      }
      me->rows[i].allocated = 0;
    }
    i = i + 1;
  }
  free_rowinfo(&me->rowspans2eog);
  (me->rowspans2eog).allocated = 0;
  return;
}



int Stbl_addRowToTable(STable_info *me,int alignment,int lineno)

{
  short sVar1;
  FILE *__stream;
  STable_rowinfo *pSVar2;
  STable_cellinfo *pSVar3;
  int local_2c;
  int growby;
  int i;
  STable_states *s;
  STable_rowinfo *row;
  STable_rowinfo *rows;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addRowToTable(alignment=%d, lineno=%d)\n",alignment,lineno);
  }
  if ((0 < me->nrows) && (0 < me->rows[me->nrows + -1].ncells)) {
    if (0 < (me->s).pending_len) {
      me->rows[me->nrows + -1].cells[me->rows[me->nrows + -1].ncells + -1].len = (me->s).pending_len
      ;
    }
    (me->s).pending_len = 0;
  }
  Stbl_finishRowInTable(me);
  if ((0 < me->nrows) && (me->rows[me->nrows + -1].Line == lineno)) {
    me->rows[me->nrows + -1].Line = -1;
  }
  (me->s).pending_len = 0;
  (me->s).x_td = -1;
  growby = 0;
  while (me->allocated_rows + growby < me->nrows + 2) {
    growby = growby + 0x10;
  }
  if (growby != 0) {
    if ((me->allocated_rows != 0) || (me->rows != (STable_rowinfo *)0x0)) {
      rows = (STable_rowinfo *)realloc(me->rows,(me->allocated_rows + growby) * 0x24);
      i = 0;
      do {
        if ((rows == (STable_rowinfo *)0x0) || (growby <= i)) goto LAB_080ef3ae;
        pSVar2 = rows + me->allocated_rows + i;
        if ((me->rowspans2eog).allocated == 0) {
          pSVar2->allocated = 0;
          pSVar2->cells = (STable_cellinfo *)0x0;
        }
        else {
          pSVar3 = (STable_cellinfo *)calloc((me->rowspans2eog).allocated,0x14);
          pSVar2->cells = pSVar3;
          if (pSVar2->cells == (STable_cellinfo *)0x0) {
            if (rows != (STable_rowinfo *)0x0) {
              free(rows);
              rows = (STable_rowinfo *)0x0;
            }
            goto LAB_080ef3ae;
          }
          pSVar2->allocated = (me->rowspans2eog).allocated;
          memcpy(pSVar2->cells,(me->rowspans2eog).cells,pSVar2->allocated * 0x14);
        }
        pSVar2->ncells = 0;
        pSVar2->fixed_line = '\0';
        pSVar2->alignment = -1;
        pSVar2->offset = 0;
        pSVar2->content = 0;
        i = i + 1;
      } while( true );
    }
    rows = (STable_rowinfo *)calloc(growby,0x24);
LAB_080ef3ae:
    if (rows == (STable_rowinfo *)0x0) {
      return -1;
    }
    me->allocated_rows = me->allocated_rows + growby;
    me->rows = rows;
  }
  me->rows[me->nrows].Line = lineno;
  if (me->nrows == 0) {
    me->startline = lineno;
  }
  if (alignment == -1) {
    if (me->rowgroup_align == -1) {
      sVar1 = me->alignment;
    }
    else {
      sVar1 = me->rowgroup_align;
    }
    local_2c = (int)sVar1;
    me->rows[me->nrows].alignment = local_2c;
  }
  else {
    me->rows[me->nrows].alignment = alignment;
  }
  me->nrows = me->nrows + 1;
  if (me->ncolinfo < me->pending_colgroup_next) {
    me->ncolinfo = me->pending_colgroup_next;
    me->pending_colgroup_next = 0;
  }
  me->rows[me->nrows].Line = -1;
  me->rows[me->nrows].ended = ROW_not_ended;
  return me->nrows + -1;
}



int Stbl_finishRowInTable(STable_info *me)

{
  STable_rowinfo *pSVar1;
  FILE *__stream;
  int local_18;
  int ncells;
  STable_states *s;
  STable_rowinfo *lastrow;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishRowInTable()\n");
  }
  if ((me->rows == (STable_rowinfo *)0x0) || (me->nrows == 0)) {
    local_18 = -1;
  }
  else {
    pSVar1 = me->rows + me->nrows + -1;
    pSVar1->ended = ROW_ended_by_endtr;
    if (0 < pSVar1->ncells) {
      if (0 < (me->s).pending_len) {
        pSVar1->cells[pSVar1->ncells + -1].len = (me->s).pending_len;
      }
      (me->s).pending_len = 0;
    }
    (me->s).state = CS_invalid;
    (me->s).prev_state = (me->s).state;
    (me->s).lineno = -1;
    if (((-1 < (me->s).icell_core) && (pSVar1->fixed_line == '\0')) &&
       (-1 < pSVar1->cells[(me->s).icell_core].cLine)) {
      pSVar1->Line = pSVar1->cells[(me->s).icell_core].cLine;
    }
    (me->s).icell_core = -1;
    local_18 = me->nrows;
  }
  return local_18;
}



void update_sumcols0(STable_cellinfo *sumcols,STable_rowinfo *lastrow,int pos,int len,int icell,
                    int ispan,int allocated_sumcols)

{
  int local_18;
  int advance;
  int prevsumpos;
  int sumpos;
  int i;
  
  if (0 < len) {
    sumpos = pos;
    if (0 < ispan) {
      if (pos < lastrow->cells[icell].pos + len) {
        sumpos = lastrow->cells[icell].pos + len;
      }
      if (sumpos < sumcols[icell + ispan + -1].pos + sumcols[icell + ispan + -1].len) {
        sumpos = sumcols[icell + ispan + -1].pos + sumcols[icell + ispan + -1].len;
      }
    }
    advance = sumpos - sumcols[icell + ispan].pos;
    if (0 < advance) {
      i = icell + ispan;
      while (i < allocated_sumcols) {
        if (((0 < ispan) && (sumcols[i].colspan < -1)) && (sumcols[i].colspan + i < icell + ispan))
        {
          advance = sumpos - sumcols[i].pos;
          if (0 < i) {
            local_18 = (sumcols[i + -1].pos + sumcols[i + -1].len) - sumcols[i].pos;
            if (local_18 < advance) {
              local_18 = advance;
            }
            advance = local_18;
          }
          if (advance < 1) {
            return;
          }
        }
        if (sumcols[i].pos < 0) {
          sumcols[i].pos = sumpos;
          return;
        }
        sumcols[i].pos = sumcols[i].pos + advance;
        i = i + 1;
      }
    }
  }
  return;
}



int get_remaining_colspan
              (STable_rowinfo *me,STable_cellinfo *colinfo,int ncolinfo,int colspan,int ncols_sofar)

{
  FILE *__stream;
  int local_1c;
  int local_18;
  int last_colspan;
  int i;
  
  if (me->ncells == 0) {
    local_18 = 1;
  }
  else {
    local_18 = me->cells[me->ncells + -1].colspan;
  }
  if ((ncolinfo == 0) || (ncolinfo < me->ncells + local_18)) {
    local_1c = (1 - (me->ncells + local_18)) + ncols_sofar;
    if (200 < local_1c) {
      local_1c = 200;
    }
    colspan = local_1c;
  }
  else {
    i = me->ncells + local_18 + -1;
    while ((i < ncolinfo + -1 && (colinfo[i].cLine != -2))) {
      i = i + 1;
    }
    colspan = (2 - (me->ncells + local_18)) + i;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:get_remaining_colspan; colspan = %d\n",colspan);
  }
  return colspan;
}



int Stbl_fakeFinishCellInTable(STable_info *me,STable_rowinfo *lastrow,int lineno,int finishing)

{
  int *piVar1;
  int iVar2;
  int alignment;
  int iVar3;
  bool bVar4;
  FILE *__stream;
  int iVar5;
  STable_rowinfo *pSVar6;
  size_t __nmemb;
  STable_cellinfo *pSVar7;
  STable_rowinfo *pSVar8;
  STable_rowinfo *pSVar9;
  STable_rowinfo *pSVar10;
  int local_60;
  char *local_5c;
  int local_58;
  int n;
  int need_cells;
  STable_rowinfo *rows;
  int prev_row_n;
  int prev_row_n2;
  STable_rowinfo *prev_row;
  int prev_reserved_last;
  int need_reserved;
  int end_td;
  int ih;
  int rs;
  int cs;
  int al;
  int i;
  int ncells;
  int fake;
  STable_states *s;
  
  bVar4 = false;
  if ((me->s).state - 2U < 4) {
    bVar4 = true;
  }
  else {
    if (finishing == 0) {
      bVar4 = true;
    }
  }
  if (bVar4) {
    iVar2 = lastrow->ncells;
    alignment = lastrow->alignment;
    iVar3 = lastrow->cells[lastrow->ncells + -1].colspan;
    bVar4 = false;
    prev_reserved_last = -1;
    pSVar8 = (STable_rowinfo *)((int)lastrow - (int)me->rows);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,
              "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n",lineno,
              finishing);
    }
    if ((finishing == 0) || (iVar5 = Stbl_finishCellInTable(me,3,lineno,0,0), -1 < iVar5)) {
      iVar5 = Stbl_addRowToTable(me,alignment,lineno);
      if (iVar5 < 0) {
        local_60 = -1;
      }
      else {
        lastrow = me->rows + me->nrows + -1;
        lastrow->content = 4;
        i = 0;
        while (i < lastrow->allocated) {
          if (lastrow->cells[i].alignment == -2) {
            bVar4 = true;
            break;
          }
          i = i + 1;
        }
        piVar1 = &me->rows->Line + ((int)pSVar8 >> 2);
        i = iVar2;
        while (i < piVar1[6]) {
          if (*(int *)(piVar1[7] + i * 0x14 + 0x10) == -2) {
            prev_reserved_last = i;
          }
          i = i + 1;
        }
        if ((bVar4) || (-1 < prev_reserved_last)) {
          pSVar8 = me->rows;
          pSVar6 = (STable_rowinfo *)realloc(me->rows,(me->allocated_rows + 1) * 0x24);
          __nmemb = prev_reserved_last + 1;
          if (pSVar6 == (STable_rowinfo *)0x0) {
            return -1;
          }
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"TRST:Stbl_fakeFinishCellInTable REALLOC ROWSPAN\n");
          }
          me->rows = pSVar6;
          lastrow = me->rows + me->nrows + -1;
          pSVar6 = me->rows;
          me->allocated_rows = me->allocated_rows + 1;
          iVar5 = me->allocated_rows - me->nrows;
          while (n = iVar5 + -1, -1 < n) {
            pSVar9 = lastrow + iVar5;
            pSVar10 = lastrow + n;
            pSVar9->Line = pSVar10->Line;
            pSVar9->ncells = pSVar10->ncells;
            *(undefined4 *)&pSVar9->fixed_line = *(undefined4 *)&pSVar10->fixed_line;
            pSVar9->ended = pSVar10->ended;
            pSVar9->content = pSVar10->content;
            pSVar9->offset = pSVar10->offset;
            pSVar9->allocated = pSVar10->allocated;
            pSVar9->cells = pSVar10->cells;
            pSVar9->alignment = pSVar10->alignment;
            iVar5 = n;
          }
          lastrow->allocated = 0;
          lastrow->cells = (STable_cellinfo *)0x0;
          if (__nmemb != 0) {
            pSVar7 = (STable_cellinfo *)calloc(__nmemb,0x14);
            lastrow->cells = pSVar7;
            if (lastrow->cells == (STable_cellinfo *)0x0) {
              return -1;
            }
            lastrow->allocated = __nmemb;
            memcpy(lastrow->cells,(&pSVar6->cells)[(int)((int)piVar1 - (int)pSVar8) >> 2],
                   lastrow->allocated * 0x14);
            i = -1;
            while (i = i + 1, i < iVar2) {
              if (lastrow->cells[i].alignment == -2) {
                lastrow->cells[i].alignment = 1;
              }
            }
          }
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          if (finishing == 0) {
            local_5c = "";
          }
          else {
            local_5c = ", last unfinished";
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"TRST:Stbl_fakeFinishCellInTable FAKE %d elts%s\n",iVar2,local_5c
                 );
        }
        i = 0;
        do {
          i = i + 1;
          if (iVar2 < i) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n",
                      lineno);
            }
            return 1;
          }
          local_58 = iVar3;
          if (i != iVar2) {
            local_58 = 1;
          }
          iVar5 = Stbl_addCellToTable(me,local_58,1,alignment,0,lineno,0,0);
          if (iVar5 < 0) {
            return -1;
          }
          lastrow->content = lastrow->content & 0xfffffffd;
        } while (((finishing != 0) && (i == iVar2)) ||
                (iVar5 = Stbl_finishCellInRow(lastrow,&me->s,3,lineno,0), -1 < iVar5));
        local_60 = -1;
      }
    }
    else {
      local_60 = -1;
    }
  }
  else {
    local_60 = 0;
  }
  return local_60;
}



int Stbl_addCellToTable(STable_info *me,int colspan,int rowspan,int alignment,int isheader,
                       int lineno,int offset_not_used_yet,int pos)

{
  FILE *__stream;
  int iVar1;
  STable_cellinfo *pSVar2;
  int local_44;
  int local_3c;
  int growby;
  int rc;
  int sumpos;
  int ncells;
  int icell;
  int i;
  STable_cellinfo *sumcol;
  STable_cellinfo *sumcols;
  STable_rowinfo *lastrow;
  STable_states *s;
  
  iVar1 = pos;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,
            "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",lineno
            ,iVar1,isheader,colspan,rowspan,alignment);
  }
  if ((me->rows == (STable_rowinfo *)0x0) || (me->nrows == 0)) {
    local_44 = -1;
  }
  else {
    if (me->rows[me->nrows + -1].ended != ROW_not_ended) {
      Stbl_addRowToTable(me,alignment,lineno);
    }
    Stbl_finishCellInTable(me,1,lineno,0,pos);
    lastrow = me->rows + me->nrows + -1;
    if ((((nested_tables != '\0') && (pos == 0)) && (0 < lastrow->ncells)) &&
       (lastrow->cells[lastrow->ncells + -1].cLine != lineno)) {
      iVar1 = Stbl_fakeFinishCellInTable(me,lastrow,lineno,0);
      if (iVar1 < 0) {
        return -1;
      }
      if (iVar1 != 0) {
        lastrow = me->rows + me->nrows + -1;
      }
    }
    if (colspan == 0) {
      colspan = get_remaining_colspan(lastrow,me->sumcols,me->ncolinfo,0,me->ncols);
    }
    iVar1 = lastrow->ncells;
    local_44 = Stbl_addCellToRow(lastrow,me->sumcols,me->ncolinfo,&me->s,colspan,alignment,isheader,
                                 lineno,&pos);
    if (-1 < local_44) {
      if ((me->nrows == 1) && (me->startline < lastrow->Line)) {
        me->startline = lastrow->Line;
      }
      if (rowspan != 1) {
        Stbl_reserveCellsInTable(me,local_44,colspan,rowspan);
        lastrow = me->rows + me->nrows + -1;
      }
      lastrow->content = lastrow->content | 2;
      growby = 0;
      while (me->allocated_sumcols + growby < local_44 + colspan + 1) {
        growby = growby + 0x10;
      }
      if (growby != 0) {
        if ((me->allocated_sumcols == 0) && (me->sumcols == (STable_cellinfo *)0x0)) {
          sumcols = (STable_cellinfo *)calloc(growby,0x14);
        }
        else {
          sumcols = (STable_cellinfo *)realloc(me->sumcols,(me->allocated_sumcols + growby) * 0x14);
          i = 0;
          while ((sumcols != (STable_cellinfo *)0x0 && (i < growby))) {
            pSVar2 = sumcols + me->allocated_sumcols + i;
            pSVar2->pos = sumcols[me->allocated_sumcols + -1].pos;
            pSVar2->len = 0;
            pSVar2->colspan = 0;
            pSVar2->cLine = 0;
            pSVar2->alignment = -1;
            i = i + 1;
          }
        }
        if (sumcols == (STable_cellinfo *)0x0) {
          return -1;
        }
        me->allocated_sumcols = me->allocated_sumcols + growby;
        me->sumcols = sumcols;
      }
      if (me->ncols < local_44 + 1) {
        me->ncols = local_44 + 1;
      }
      if ((1 < colspan) && (0 < me->sumcols[local_44 + colspan].colspan + colspan)) {
        me->sumcols[local_44 + colspan].colspan = -colspan;
      }
      sumpos = pos;
      if (0 < iVar1) {
        sumpos = pos + (me->sumcols[iVar1 + -1].pos - lastrow->cells[iVar1 + -1].pos);
      }
      update_sumcols0(me->sumcols,lastrow,sumpos,sumpos - me->sumcols[local_44].pos,local_44,0,
                      me->allocated_sumcols);
      me->maxpos = me->sumcols[me->allocated_sumcols + -1].pos;
      if (LYwideLines == 0) {
        local_3c = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        local_3c = 0x3f5;
      }
      if (local_3c < me->maxpos) {
        local_44 = -1;
      }
      else {
        local_44 = 0;
      }
    }
  }
  return local_44;
}



int Stbl_finishCellInTable(STable_info *me,int end_td,int lineno,int offset,int pos)

{
  FILE *__stream;
  int iVar1;
  int local_5c;
  int local_58;
  int local_54;
  int local_4c;
  int local_44;
  int local_3c;
  int spanlend;
  int spanlen;
  int rc;
  int i;
  int icell;
  int xlen;
  int len;
  STable_rowinfo *lastrow;
  STable_states *s;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n",
            lineno,pos,offset,end_td);
  }
  if (me->nrows == 0) {
    local_58 = -1;
  }
  else {
    lastrow = me->rows + me->nrows + -1;
    local_58 = lastrow->ncells + -1;
    if (-1 < local_58) {
      if ((me->s).x_td == -1) {
        if ((end_td & 1U) == 0) {
          lastrow->ended = ROW_ended_by_splitline;
        }
        local_58 = 0;
      }
      else {
        icell = local_58;
        if (((nested_tables != '\0') && ((end_td & 2U) == 0)) &&
           (iVar1 = Stbl_fakeFinishCellInTable(me,lastrow,lineno,1), iVar1 != 0)) {
          if (iVar1 < 0) {
            return -1;
          }
          lastrow = me->rows + me->nrows + -1;
          icell = lastrow->ncells + -1;
        }
        local_58 = Stbl_finishCellInRow(lastrow,&me->s,end_td,lineno,pos);
        if (local_58 != -1) {
          local_54 = local_58;
          if (local_58 < 1) {
            local_54 = (me->s).pending_len;
          }
          len = local_58;
          if (lastrow->Line == lineno) {
            len = local_54;
          }
          if (lastrow->cells[icell].colspan < 2) {
            if (me->sumcols[icell].len < len) {
              if (-2 < me->sumcols[icell + 1].colspan) {
                me->maxlen = me->maxlen + (len - me->sumcols[icell].len);
              }
              me->sumcols[icell].len = len;
            }
          }
          else {
            spanlen = 0;
            spanlend = 0;
            i = icell;
            while (i < lastrow->cells[icell].colspan + icell) {
              if ((0 < me->sumcols[i].len) && (spanlen = spanlen + me->sumcols[i].len, icell < i)) {
                spanlen = spanlen + 1;
              }
              local_5c = me->sumcols[i + 1].pos - me->sumcols[icell].pos;
              if (local_5c < spanlend) {
                local_5c = spanlend;
              }
              spanlend = local_5c;
              i = i + 1;
            }
            if (spanlend != 0) {
              spanlend = spanlend + -1;
            }
            if (spanlen < spanlend) {
              spanlen = spanlend;
            }
            if (spanlen < len) {
              me->maxlen = me->maxlen + (len - spanlen);
            }
          }
          if (0 < len) {
            update_sumcols0(me->sumcols,lastrow,pos,len,icell,lastrow->cells[icell].colspan,
                            me->allocated_sumcols);
            me->maxpos = me->sumcols[me->allocated_sumcols + -1].pos;
          }
          if ((end_td & 1U) == 0) {
            lastrow->ended = ROW_ended_by_splitline;
            lastrow->content = lastrow->content | 0x20;
            lastrow->offset = offset;
          }
          if (nested_tables == '\0') {
            if (LYwideLines == 0) {
              local_44 = LYcols - (uint)(LYShowScrollbar != '\0');
            }
            else {
              local_44 = 0x3f5;
            }
            if (local_44 < me->maxlen + (local_54 - len)) {
              return -1;
            }
          }
          else {
            if (LYwideLines == 0) {
              local_4c = LYcols - (uint)(LYShowScrollbar != '\0');
            }
            else {
              local_4c = 0x3f5;
            }
            if (local_4c < me->maxlen) {
              return -1;
            }
          }
          if (LYwideLines == 0) {
            local_3c = LYcols - (uint)(LYShowScrollbar != '\0');
          }
          else {
            local_3c = 0x3f5;
          }
          if (local_3c < me->maxpos) {
            local_58 = -1;
          }
          else {
            local_58 = 0;
          }
        }
      }
    }
  }
  return local_58;
}



int Stbl_addColInfo(STable_info *me,int colspan,short alignment,BOOLEAN isgroup)

{
  int iVar1;
  FILE *__stream;
  STable_cellinfo *pSVar2;
  short local_30;
  int growby;
  int icolinfo;
  int i;
  STable_cellinfo *sumcol;
  STable_cellinfo *sumcols;
  
  local_30 = alignment;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addColInfo(cs=%d, al=%d, isgroup=%d)\n",colspan,
            (int)alignment,(int)isgroup);
  }
  if (isgroup == '\0') {
    i = me->pending_colgroup_next;
    while (i = i + -1, me->ncolinfo + colspan <= i) {
      me->sumcols[i].alignment = -1;
    }
    me->pending_colgroup_next = me->ncolinfo + colspan;
  }
  else {
    if (me->ncolinfo < me->pending_colgroup_next) {
      me->ncolinfo = me->pending_colgroup_next;
    }
    me->pending_colgroup_next = me->ncolinfo + colspan;
    if (0 < me->ncolinfo) {
      me->sumcols[me->ncolinfo + -1].cLine = -2;
    }
    me->pending_colgroup_align = alignment;
  }
  iVar1 = me->ncolinfo;
  if (isgroup == '\0') {
    me->ncolinfo = me->ncolinfo + colspan;
  }
  growby = 0;
  while (me->allocated_sumcols + growby < iVar1 + colspan + 1) {
    growby = growby + 0x10;
  }
  if (growby != 0) {
    if (me->allocated_sumcols == 0) {
      sumcols = (STable_cellinfo *)calloc(growby,0x14);
    }
    else {
      sumcols = (STable_cellinfo *)realloc(me->sumcols,(me->allocated_sumcols + growby) * 0x14);
      i = 0;
      while ((sumcols != (STable_cellinfo *)0x0 && (i < growby))) {
        pSVar2 = sumcols + me->allocated_sumcols + i;
        pSVar2->pos = sumcols[me->allocated_sumcols + -1].pos;
        pSVar2->len = 0;
        pSVar2->colspan = 0;
        pSVar2->cLine = 0;
        i = i + 1;
      }
    }
    if (sumcols == (STable_cellinfo *)0x0) {
      return -1;
    }
    me->allocated_sumcols = me->allocated_sumcols + growby;
    me->sumcols = sumcols;
  }
  i = iVar1;
  if (alignment == -1) {
    local_30 = me->pending_colgroup_align;
  }
  while (i < iVar1 + colspan) {
    me->sumcols[i].alignment = (int)local_30;
    i = i + 1;
  }
  return 0;
}



int Stbl_finishColGroup(STable_info *me)

{
  FILE *__stream;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishColGroup()\n");
  }
  if ((me->ncolinfo <= me->pending_colgroup_next) &&
     (me->ncolinfo = me->pending_colgroup_next, 0 < me->ncolinfo)) {
    me->sumcols[me->ncolinfo + -1].cLine = -2;
  }
  me->pending_colgroup_next = 0;
  me->pending_colgroup_align = -1;
  return 0;
}



int Stbl_addRowGroup(STable_info *me,short alignment)

{
  FILE *__stream;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addRowGroup()\n");
  }
  Stbl_cancelRowSpans(me);
  me->rowgroup_align = alignment;
  return 0;
}



int Stbl_finishTABLE(STable_info *me)

{
  int iVar1;
  ended_state eVar2;
  bool bVar3;
  FILE *__stream;
  int iVar4;
  int local_58;
  int local_54;
  int local_50;
  int curwid;
  int curcell;
  int max_width;
  int foundcell;
  int have_offsets;
  int minoffset;
  STable_rowinfo *nextrow;
  int non_empty;
  int leading;
  int j;
  int curpos;
  int i;
  STable_states *s;
  
  curpos = 0;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishTABLE()\n");
  }
  if (((me == (STable_info *)0x0) || (me->nrows < 1)) || (me->ncols < 1)) {
    local_58 = -1;
  }
  else {
    if ((0 < me->nrows) && (0 < me->rows[me->nrows + -1].ncells)) {
      if (0 < (me->s).pending_len) {
        me->rows[me->nrows + -1].cells[me->rows[me->nrows + -1].ncells + -1].len =
             (me->s).pending_len;
      }
      (me->s).pending_len = 0;
    }
    Stbl_finishRowInTable(me);
    i = 0;
    while (i < me->nrows + -1) {
      j = i + 1;
      non_empty = 0;
      nextrow = me->rows + j;
      iVar4 = i;
      if ((nextrow->content & 0x26U) == 0x24) {
        minoffset = nextrow[-1].offset;
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          eVar2 = nextrow[-1].ended;
          iVar4 = nextrow[-1].offset;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%u.\n",i,iVar4,
                  eVar2);
        }
        while ((j < me->nrows && ((nextrow->content & 0x26U) == 0x24))) {
          if (nextrow->offset < minoffset) {
            minoffset = nextrow->offset;
          }
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
            eVar2 = nextrow[-1].ended;
            iVar4 = nextrow->offset;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%u.\n",j,iVar4,
                    eVar2);
          }
          nextrow = nextrow + 1;
          j = j + 1;
        }
        iVar4 = j + -1;
        j = i;
        nextrow = me->rows + i;
        bVar3 = false;
        nextrow->content = nextrow->content | 0x10;
        while (j <= iVar4) {
          nextrow->offset = nextrow->offset - minoffset;
          nextrow->content = nextrow->content | 8;
          if (nextrow->offset != 0) {
            bVar3 = true;
          }
          nextrow = nextrow + 1;
          j = j + 1;
        }
        if (bVar3) {
          foundcell = -1;
          j = i + 1;
          nextrow = me->rows + j;
          while ((foundcell == -1 && (j <= iVar4))) {
            curcell = -1;
            while ((foundcell == -1 && (curcell = curcell + 1, curcell < nextrow->ncells))) {
              if (nextrow->cells[curcell].len != 0) {
                non_empty = j;
                foundcell = curcell;
              }
            }
            nextrow = nextrow + 1;
            j = j + 1;
          }
          if (foundcell != -1) {
            max_width = 0;
            j = i;
            nextrow = me->rows + i;
            while (j <= iVar4) {
              if ((foundcell < nextrow->ncells) &&
                 (iVar1 = nextrow->cells[foundcell].len + nextrow->offset, max_width < iVar1)) {
                max_width = iVar1;
              }
              nextrow = nextrow + 1;
              j = j + 1;
            }
            update_sumcols0(me->sumcols,me->rows + non_empty,0,max_width,foundcell,
                            me->rows[non_empty].cells[foundcell].colspan,me->allocated_sumcols);
            j = i;
            nextrow = me->rows + i;
            while (j <= iVar4) {
              if (foundcell < nextrow->ncells) {
                nextrow->cells[foundcell].len = max_width;
              }
              nextrow = nextrow + 1;
              j = j + 1;
            }
          }
        }
      }
      i = iVar4;
      i = i + 1;
    }
    i = 0;
    while (i < me->ncols) {
      if (me->sumcols[i].pos < curpos) {
        me->sumcols[i].pos = curpos;
      }
      else {
        curpos = me->sumcols[i].pos;
      }
      if (0 < me->sumcols[i].len) {
        curpos = curpos + me->sumcols[i].len;
      }
      i = i + 1;
    }
    if (LYwideLines == 0) {
      local_50 = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      local_50 = 0x3f5;
    }
    if (local_50 < curpos) {
      local_54 = -1;
    }
    else {
      local_54 = me->ncols;
    }
    local_58 = local_54;
  }
  return local_58;
}



short Stbl_getAlignment(STable_info *me)

{
  short local_6;
  
  if (me == (STable_info *)0x0) {
    local_6 = -1;
  }
  else {
    local_6 = me->alignment;
  }
  return local_6;
}



int get_fixup_positions(STable_rowinfo *me,int *oldpos,int *newpos,STable_cellinfo *sumcols)

{
  STable_cellinfo *pSVar1;
  int iVar2;
  int local_38;
  int local_34;
  int local_30;
  int offset;
  int ninserts;
  int newlen;
  int next_i;
  int ip;
  int i;
  
  i = 0;
  ip = 0;
  if (me == (STable_rowinfo *)0x0) {
    local_34 = -1;
  }
  else {
    do {
      while( true ) {
        if (me->ncells <= i) goto LAB_080f1726;
        local_30 = me->cells[i].colspan;
        if (local_30 < 1) {
          local_30 = 1;
        }
        local_30 = local_30 + i;
        if (me->cells[i].cLine != me->Line) break;
        oldpos[ip] = me->cells[i].pos;
        if (((me->content & 8U) == 0) || ((me->ncells + -1 != i && ((me->content & 0x10U) != 0)))) {
          offset = 0;
        }
        else {
          offset = me->offset;
        }
        newpos[ip] = sumcols[i].pos + offset;
        if (((me->cells[i].alignment == 3) || (me->cells[i].alignment == 2)) &&
           (0 < me->cells[i].len)) {
          iVar2 = (sumcols[local_30].pos - newpos[ip]) + -1;
          local_38 = sumcols[i].len;
          if (sumcols[i].len < iVar2) {
            local_38 = iVar2;
          }
          if (me->cells[i].len < local_38) {
            if (me->cells[i].alignment == 2) {
              newpos[ip] = newpos[ip] + (local_38 - me->cells[i].len);
            }
            else {
              newpos[ip] = newpos[ip] + (local_38 - me->cells[i].len) / 2;
            }
          }
        }
        ip = ip + 1;
        i = local_30;
      }
      pSVar1 = me->cells + i;
      i = local_30;
    } while (pSVar1->cLine <= me->Line);
LAB_080f1726:
    local_34 = ip;
  }
  return local_34;
}



int Stbl_getFixupPositions(STable_info *me,int lineno,int *oldpos,int *newpos)

{
  int local_18;
  int ninserts;
  int j;
  STable_rowinfo *row;
  
  ninserts = -1;
  if ((me == (STable_info *)0x0) || (me->nrows == 0)) {
    local_18 = -1;
  }
  else {
    j = 0;
    while (j < me->nrows) {
      if (me->rows[j].Line == lineno) {
        ninserts = get_fixup_positions(me->rows + j,oldpos,newpos,me->sumcols);
        break;
      }
      j = j + 1;
    }
    local_18 = ninserts;
  }
  return local_18;
}



int Stbl_getStartLine(STable_info *me)

{
  int local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = -1;
  }
  else {
    local_8 = me->startline;
  }
  return local_8;
}



int Stbl_getStartLineDeep(STable_info *me)

{
  int local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = -1;
  }
  else {
    while (me->enclosing != (_STable_info *)0x0) {
      me = (STable_info *)me->enclosing;
    }
    local_8 = me->startline;
  }
  return local_8;
}



void Stbl_update_enclosing(STable_info *me,int max_width,int last_lineno)

{
  _STable_info *p_Var1;
  FILE *__stream;
  int iVar2;
  STable_info *enclosing;
  STable_info *stbl;
  int l;
  
  if (((me != (STable_info *)0x0) && (me->enclosing != (_STable_info *)0x0)) && (max_width != 0)) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
      iVar2 = me->startline;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",max_width,
              iVar2,last_lineno);
    }
    l = me->startline;
    while (l <= last_lineno) {
      iVar2 = Stbl_finishCellInTable((STable_info *)me->enclosing,0,l,0,max_width);
      if (iVar2 < 0) {
        stbl = (STable_info *)me->enclosing;
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,
                  "TRST:Stbl_update_enclosing: width too large, aborting enclosing\n");
        }
        me->enclosing = (_STable_info *)0x0;
        while (stbl != (STable_info *)0x0) {
          p_Var1 = stbl->enclosing;
          Stbl_free(stbl);
          stbl = (STable_info *)p_Var1;
        }
        return;
      }
      l = l + 1;
    }
  }
  return;
}



void Stbl_set_enclosing(STable_info *me,STable_info *enclosing,
                       _TextAnchor *enclosing_last_anchor_before_stbl)

{
  if (me != (STable_info *)0x0) {
    *(STable_info **)&me->enclosing = enclosing;
    me->enclosing_last_anchor_before_stbl = enclosing_last_anchor_before_stbl;
  }
  return;
}



STable_info * Stbl_get_enclosing(STable_info *me)

{
  STable_info *local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = (STable_info *)0x0;
  }
  else {
    local_8 = (STable_info *)me->enclosing;
  }
  return local_8;
}



_TextAnchor * Stbl_get_last_anchor_before(STable_info *me)

{
  _TextAnchor *local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = (_TextAnchor *)0x0;
  }
  else {
    local_8 = me->enclosing_last_anchor_before_stbl;
  }
  return local_8;
}



void date_error(char *s)

{
  return;
}



time_t ToSeconds(time_t Hours,time_t Minutes,time_t Seconds,MERIDIAN Meridian)

{
  int local_8;
  
  if ((((Minutes < 0) || (0x3b < Minutes)) || (Seconds < 0)) || (0x3d < Seconds)) {
    local_8 = -1;
  }
  else {
    if (Meridian == MER24) {
      if ((Hours < 0) || (0x17 < Hours)) {
        return -1;
      }
    }
    else {
      if ((Hours < 1) || (0xc < Hours)) {
        return -1;
      }
      if (Hours == 0xc) {
        Hours = 0;
      }
      if (Meridian == MERpm) {
        Hours = Hours + 0xc;
      }
    }
    local_8 = Seconds + (Hours * 0x3c + Minutes) * 0x3c;
  }
  return local_8;
}



time_t Convert(time_t Month,time_t Day,time_t Year,time_t Hours,time_t Minutes,time_t Seconds,
              MERIDIAN Meridian,DSTMODE dst)

{
  int iVar1;
  int LeapYears [17];
  int DaysLeap [13];
  int DaysNormal [13];
  time_t tVar2;
  tm *ptVar3;
  time_t tod;
  time_t Julian;
  int i;
  int *mp;
  int *yp;
  
  if (Year < 0) {
    Year = -Year;
  }
  if (Year < 0x46) {
    Year = Year + 2000;
  }
  if (Year < 100) {
    Year = Year + 0x76c;
  }
  if (Year < 0x7b2) {
    Year = Year + 100;
  }
  mp = (int *)&ram0x08170dc0;
  yp = (int *)&ram0x08170d20;
  do {
    if (&DAT_08170d64 <= yp) {
LAB_080f1ab9:
      if (((((Year < 0x7b2) || (0x7f6 < Year)) || (Month < 1)) || ((0xc < Month || (Day < 1)))) ||
         (mp[Month] < Day)) {
        return -1;
      }
      Julian = Day + Year * 0x16d + -0xaf8cb;
      yp = (int *)0x8170d20;
      while ((yp < &DAT_08170d64 && (*yp < Year))) {
        yp = yp + 1;
        Julian = Julian + 1;
      }
      i = 1;
      while (i < Month) {
        mp = mp + 1;
        Julian = Julian + *mp;
        i = i + 1;
      }
      iVar1 = yyTimezone * 0x3c;
      tVar2 = ToSeconds(Hours,Minutes,Seconds,Meridian);
      if (-1 < tVar2) {
        Julian = Julian * 0x15180 + iVar1 + tVar2;
        if ((dst == DSTon) ||
           ((dst == DSTmaybe && (tod = Julian, ptVar3 = localtime(&tod), ptVar3->tm_isdst != 0)))) {
          Julian = Julian + -0xe10;
        }
        return Julian;
      }
      return -1;
    }
    if (*yp == Year) {
      mp = (int *)&ram0x08170d80;
      goto LAB_080f1ab9;
    }
    yp = yp + 1;
  } while( true );
}



time_t DSTcorrect(time_t Start,time_t Future)

{
  int iVar1;
  int iVar2;
  tm *ptVar3;
  time_t FutureDay;
  time_t StartDay;
  
  ptVar3 = localtime(&Start);
  iVar1 = ptVar3->tm_hour + 1;
  ptVar3 = localtime(&Future);
  iVar2 = ptVar3->tm_hour + 1;
  return (Future - Start) +
         ((iVar1 + ((iVar1 / 6 + (iVar1 >> 0x1f) >> 2) - (iVar1 >> 0x1f)) * -0x18) -
         (iVar2 + ((iVar2 / 6 + (iVar2 >> 0x1f) >> 2) - (iVar2 >> 0x1f)) * -0x18)) * 0xe10;
}



time_t RelativeMonth(time_t Start,time_t RelMonth)

{
  int iVar1;
  tm *ptVar2;
  int iVar3;
  time_t Future;
  time_t Year;
  time_t Month;
  tm *tm;
  
  ptVar2 = localtime(&Start);
  iVar3 = ptVar2->tm_year * 0xc + ptVar2->tm_mon + RelMonth;
  iVar1 = iVar3 >> 0x1f;
  Future = Convert(iVar3 + ((iVar3 / 6 + iVar1 >> 1) - iVar1) * -0xc + 1,ptVar2->tm_mday,
                   ((iVar3 / 6 + iVar1 >> 1) - iVar1) + 0x76c,ptVar2->tm_hour,ptVar2->tm_min,
                   ptVar2->tm_sec,MER24,DSTmaybe);
  Future = DSTcorrect(Start,Future);
  return Future;
}



int LookupWord(char *buff,int length)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  int c;
  TABLE *tp;
  char *q;
  char *p;
  
  cVar1 = *buff;
  if ((length == 3) || ((length == 4 && (buff[3] == '.')))) {
    tp = MonthDayTable;
    while (tp < (TABLE *)&DAT_081708e4) {
      pcVar2 = tp->name;
      if (((*pcVar2 == cVar1) && (buff[1] == pcVar2[1])) && (buff[2] == pcVar2[2])) {
        yylval = tp->value;
        return tp->type;
      }
      tp = tp + 1;
    }
  }
  else {
    tp = MonthDayTable;
    while (tp < (TABLE *)&DAT_081708e4) {
      if ((*tp->name == cVar1) && (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
        yylval = tp->value;
        return tp->type;
      }
      tp = tp + 1;
    }
  }
  tp = TimezoneTable;
  while (tp < (TABLE *)&DAT_08170d14) {
    if (((*tp->name == cVar1) && (buff[1] == tp->name[1])) &&
       (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
      yylval = tp->value;
      return tp->type;
    }
    tp = tp + 1;
  }
  iVar3 = strcmp(buff,"dst");
  if (iVar3 == 0) {
    return 0x10a;
  }
  tp = UnitsTable;
  while (tp < (TABLE *)&DAT_0817098c) {
    if ((*tp->name == cVar1) && (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
      yylval = tp->value;
      return tp->type;
    }
    tp = tp + 1;
  }
  iVar3 = length + -1;
  if ((0 < iVar3) && (buff[iVar3] == 's')) {
    buff[iVar3] = '\0';
    tp = UnitsTable;
    while (tp < (TABLE *)&DAT_0817098c) {
      if ((*tp->name == cVar1) && (iVar4 = strcmp(buff,tp->name), iVar4 == 0)) {
        buff[iVar3] = 's';
        yylval = tp->value;
        return tp->type;
      }
      tp = tp + 1;
    }
    buff[iVar3] = 's';
  }
  p = buff;
  q = buff;
  while (*q != '\0') {
    if (*q != '.') {
      *p = *q;
      p = p + 1;
    }
    q = q + 1;
  }
  *p = '\0';
  if ((buff[1] == 'm') && (buff[2] == '\0')) {
    if (*buff == 'a') {
      yylval = 0;
      return 0x103;
    }
    if (*buff == 'p') {
      yylval = 1;
      return 0x103;
    }
  }
  if (p + -(int)buff != (char *)length) {
    cVar1 = *buff;
    tp = TimezoneTable;
    while (tp < (TABLE *)&DAT_08170d14) {
      if (((*tp->name == cVar1) && (buff[1] == tp->name[1])) &&
         (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
        yylval = tp->value;
        return tp->type;
      }
      tp = tp + 1;
    }
  }
  yylval = 0;
  return 0x109;
}



int date_lex(void)

{
  char cVar1;
  ushort **ppuVar2;
  int __c;
  byte *pbVar3;
  uint uVar4;
  int in_GS_OFFSET;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  char local_35;
  int nesting;
  int i;
  int sign;
  char *p;
  int c;
  char buff [20];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  while( true ) {
    while ((-1 < *yyInput && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*yyInput] & 0x2000) != 0))) {
      yyInput = yyInput + 1;
    }
    cVar1 = *yyInput;
    __c = (int)cVar1;
    if (__c != 0x28) break;
    nesting = 1;
    pbVar3 = (byte *)yyInput;
LAB_080f220c:
    while( true ) {
      yyInput = (char *)pbVar3;
      pbVar3 = (byte *)(yyInput + 1);
      uVar4 = SEXT14((char)*pbVar3);
      if ((uVar4 == 0x29) && (nesting = nesting + -1, nesting == 0)) break;
      if (uVar4 != 0x28) {
        if (((uVar4 < 0x80) && (uVar4 != 0)) && (uVar4 != 0xd)) goto code_r0x080f21d1;
        goto LAB_080f2200;
      }
      nesting = nesting + 1;
    }
    yyInput = yyInput + 2;
  }
  if ((((cVar1 < '\0') || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[__c] & 0x800) == 0)) &&
      (__c != 0x2d)) && (__c != 0x2b)) {
    if ((cVar1 < '\0') || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[__c] & 0x400) == 0)) {
      local_48 = (int)*yyInput;
      yyInput = yyInput + 1;
    }
    else {
      p = buff;
      while( true ) {
        local_35 = *yyInput;
        __c = (int)local_35;
        yyInput = yyInput + 1;
        if ((__c != 0x2e) &&
           ((local_35 < '\0' || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[__c] & 0x400) == 0))))
        break;
        if (p < buff + 0x13) {
          if ((-1 < local_35) && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[__c] & 0x100) != 0)) {
            __c = tolower(__c);
            local_35 = (char)__c;
          }
          *p = local_35;
          p = p + 1;
        }
      }
      *p = '\0';
      yyInput = yyInput + -1;
      local_48 = LookupWord(buff,(int)(p + -(int)buff));
    }
  }
  else {
    if ((__c == 0x2d) || (__c == 0x2b)) {
      if (__c == 0x2d) {
        local_44 = -1;
      }
      else {
        local_44 = 1;
      }
      sign = local_44;
      yyInput = yyInput + 1;
      if ((*yyInput < '\0') || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*yyInput] & 0x800) == 0)) {
        local_48 = (int)yyInput[-1];
        goto LAB_080f24f2;
      }
    }
    else {
      sign = 0;
    }
    i = 0;
    while( true ) {
      cVar1 = *yyInput;
      __c = (int)cVar1;
      yyInput = yyInput + 1;
      if (((__c == 0) || (cVar1 < '\0')) ||
         (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[__c] & 0x800) == 0)) break;
      i = i * 10 + __c + -0x30;
    }
    yyInput = yyInput + -1;
    if (sign < 0) {
      local_40 = -i;
    }
    else {
      local_40 = i;
    }
    yylval = local_40;
    if (sign == 0) {
      local_3c = 0x108;
    }
    else {
      local_3c = 0x107;
    }
    local_48 = local_3c;
  }
LAB_080f24f2:
  if (local_8 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_48;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x080f21d1:
  if (uVar4 == 0x5c) {
    pbVar3 = (byte *)(yyInput + 2);
    if ((*pbVar3 == 0) || (0x7f < *pbVar3)) {
LAB_080f2200:
      yyInput = (char *)pbVar3;
      local_48 = 0x3f;
      goto LAB_080f24f2;
    }
  }
  goto LAB_080f220c;
}



int GetTimeInfo(TIMEINFO *Now)

{
  long LastTzone;
  time_t LastTime;
  int iVar1;
  tm *ptVar2;
  int local_18;
  timeval tv;
  tm *tm;
  
  iVar1 = gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
  if (iVar1 == -1) {
    local_18 = -1;
  }
  else {
    Now->time = tv.tv_sec;
    Now->usec = tv.tv_usec;
    if (0xe10 < Now->time - LastTime) {
      LastTime = Now->time;
      ptVar2 = localtime((time_t *)Now);
      if (ptVar2 == (tm *)0x0) {
        return -1;
      }
      LastTzone = -ptVar2->tm_gmtoff / 0x3c;
    }
    Now->tzone = LastTzone;
    local_18 = 0;
  }
  return local_18;
}



time_t parsedate(char *p,TIMEINFO *now)

{
  tm *ptVar1;
  int iVar2;
  time_t tVar3;
  time_t local_40;
  time_t local_34;
  TIMEINFO ti;
  time_t Start;
  tm *tm;
  
  yyInput = p;
  if (now == (TIMEINFO *)0x0) {
    now = &ti;
    GetTimeInfo(&ti);
  }
  ptVar1 = localtime((time_t *)now);
  yyYear = ptVar1->tm_year + 0x76c;
  yyMonth = ptVar1->tm_mon + 1;
  yyDay = ptVar1->tm_mday;
  yyTimezone = now->tzone;
  if (ptVar1->tm_isdst != 0) {
    yyTimezone = yyTimezone + 0x3c;
  }
  yyDSTmode = DSTmaybe;
  yyHour = 0;
  yyMinutes = 0;
  yySeconds = 0;
  yyMeridian = MER24;
  yyRelSeconds = 0;
  yyRelMonth = 0;
  yyHaveDate = 0;
  yyHaveRel = 0;
  yyHaveTime = 0;
  iVar2 = date_parse();
  if (((iVar2 == 0) && (yyHaveTime < 2)) && (yyHaveDate < 2)) {
    if ((yyHaveDate == 0) && (yyHaveTime == 0)) {
      Start = now->time;
      if (yyHaveRel == 0) {
        Start = Start + ((ptVar1->tm_hour * -0x3c - ptVar1->tm_min) * 0x3c - ptVar1->tm_sec);
      }
    }
    else {
      Start = Convert(yyMonth,yyDay,yyYear,yyHour,yyMinutes,yySeconds,yyMeridian,yyDSTmode);
      if (Start < 0) {
        return -1;
      }
    }
    Start = Start + yyRelSeconds;
    if (yyRelMonth != 0) {
      tVar3 = RelativeMonth(Start,yyRelMonth);
      Start = Start + tVar3;
    }
    if (Start == -1) {
      local_34 = 0;
    }
    else {
      local_34 = Start;
    }
    local_40 = local_34;
  }
  else {
    local_40 = -1;
  }
  return local_40;
}



int yygrowstack(void)

{
  int iVar1;
  int local_20;
  short *local_1c;
  YYSTYPE *local_18;
  YYSTYPE *newvs;
  short *newss;
  uint newsize;
  int i;
  
  if (yystacksize == 0) {
    newsize = 500;
  }
  else {
    if (499 < yystacksize) {
      return -1;
    }
    newsize = yystacksize << 1;
    if (500 < newsize) {
      newsize = 500;
    }
  }
  iVar1 = (int)((int)yyssp - (int)yyss) >> 1;
  if (yyss == (short *)0x0) {
    local_1c = (short *)malloc(newsize * 2);
  }
  else {
    local_1c = (short *)realloc(yyss,newsize * 2);
  }
  if (local_1c == (short *)0x0) {
    local_20 = -1;
  }
  else {
    yyss = local_1c;
    yyssp = local_1c + iVar1;
    if (yyvs == (YYSTYPE *)0x0) {
      local_18 = (YYSTYPE *)malloc(newsize << 2);
    }
    else {
      local_18 = (YYSTYPE *)realloc(yyvs,newsize << 2);
    }
    if (local_18 == (YYSTYPE *)0x0) {
      local_20 = -1;
    }
    else {
      yyvs = local_18;
      yyvsp = local_18 + iVar1;
      yystacksize = newsize;
      yysslim = yyss + (1 - newsize) * 0x7fffffff;
      local_20 = 0;
    }
  }
  return local_20;
}



int date_parse(void)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_1c;
  int i;
  int yystate;
  int yyn;
  int yym;
  
  yynerrs = 0;
  yyerrflag = 0;
  yychar = -1;
  if ((yyss == (short *)0x0) && (iVar3 = yygrowstack(), iVar3 != 0)) {
yyoverflow:
    date_error("yacc stack overflow");
yyabort:
    local_1c = 1;
  }
  else {
    yyssp = yyss;
    yyvsp = yyvs;
    yystate = 0;
    *yyss = 0;
yyloop:
    do {
      yyn = (int)yydefred[yystate];
      if (yyn == 0) {
        if ((yychar < 0) && (yychar = date_lex(), yychar < 0)) {
          yychar = 0;
        }
        if (((((int)yysindex[yystate] != 0) && (iVar3 = (int)yysindex[yystate] + yychar, -1 < iVar3)
             ) && (iVar3 < 0x12d)) && ((int)yycheck[iVar3] == yychar)) {
          if ((yysslim <= yyssp) && (iVar4 = yygrowstack(), iVar4 != 0)) goto yyoverflow;
          yystate = (int)yytable[iVar3];
          yyssp = yyssp + 1;
          *yyssp = yytable[iVar3];
          yyvsp = yyvsp + 1;
          *yyvsp = yylval;
          yychar = -1;
          if (0 < yyerrflag) {
            yyerrflag = yyerrflag + -1;
          }
          goto yyloop;
        }
        if ((((int)yyrindex[yystate] == 0) || (iVar3 = (int)yyrindex[yystate] + yychar, iVar3 < 0))
           || ((300 < iVar3 || ((int)yycheck[iVar3] != yychar)))) {
          if (yyerrflag == 0) {
            date_error("syntax error");
            yynerrs = yynerrs + 1;
          }
          if (yyerrflag < 3) {
            yyerrflag = 3;
            while (((((int)yysindex[*yyssp] == 0 ||
                     (iVar3 = (int)yysindex[*yyssp] + 0x100, iVar3 < 0)) || (300 < iVar3)) ||
                   (yycheck[iVar3] != 0x100))) {
              if (yyssp <= yyss) goto yyabort;
              yyssp = yyssp + -1;
              yyvsp = yyvsp + -1;
            }
            if ((yysslim <= yyssp) && (iVar4 = yygrowstack(), iVar4 != 0)) goto yyoverflow;
            yystate = (int)yytable[iVar3];
            yyssp = yyssp + 1;
            *yyssp = yytable[iVar3];
            yyvsp = yyvsp + 1;
            *yyvsp = yylval;
          }
          else {
            if (yychar == 0) goto yyabort;
            yychar = -1;
          }
          goto yyloop;
        }
        yyn = (int)yytable[iVar3];
      }
      iVar3 = (int)yylen[yyn];
      if (iVar3 == 0) {
        memset(&yyval,0,4);
      }
      else {
        yyval = yyvsp[1 - iVar3];
      }
      switch(yyn) {
      case 3:
        yyHaveTime = yyHaveTime + 1;
        break;
      case 4:
        yyHaveTime = yyHaveTime + 1;
        yyTimezone = *yyvsp;
        break;
      case 5:
        yyHaveDate = yyHaveDate + 1;
        break;
      case 6:
        yyHaveDate = yyHaveDate + 1;
        yyHaveTime = yyHaveTime + 1;
        break;
      case 7:
        yyHaveDate = yyHaveDate + 1;
        yyHaveTime = yyHaveTime + 1;
        yyTimezone = *yyvsp;
        break;
      case 8:
        yyHaveRel = 1;
        break;
      case 9:
        if ((int)yyvsp[-1] < 100) {
          yyHour = yyvsp[-1];
          yyMinutes = 0;
        }
        else {
          yyHour = (int)yyvsp[-1] / 100;
          yyMinutes = (int)yyvsp[-1] % 100;
        }
        yySeconds = 0;
        yyMeridian = *yyvsp;
        break;
      case 10:
        yyHour = yyvsp[-3];
        yyMinutes = yyvsp[-1];
        yySeconds = 0;
        yyMeridian = *yyvsp;
        break;
      case 0xb:
        yyHour = yyvsp[-3];
        yyMinutes = yyvsp[-1];
        yyTimezone = *yyvsp;
        yyMeridian = MER24;
        yyDSTmode = DSToff;
        break;
      case 0xc:
        yyHour = yyvsp[-5];
        yyMinutes = yyvsp[-3];
        yySeconds = yyvsp[-1];
        yyMeridian = *yyvsp;
        break;
      case 0xd:
        yyHour = yyvsp[-5];
        yyMinutes = yyvsp[-3];
        yySeconds = yyvsp[-1];
        yyTimezone = *yyvsp;
        yyMeridian = MER24;
        yyDSTmode = DSToff;
        break;
      case 0xe:
        yyval = *yyvsp;
        yyDSTmode = DSToff;
        break;
      case 0xf:
        yyval = *yyvsp;
        yyDSTmode = DSTon;
        break;
      case 0x10:
        yyTimezone = yyvsp[-1];
        yyDSTmode = DSTon;
        break;
      case 0x11:
        if (yyvsp[-1] != 0) goto yyabort;
        yyval = *yyvsp;
        yyDSTmode = DSToff;
        break;
      case 0x12:
        yyval = *yyvsp;
        yyDSTmode = DSToff;
        break;
      case 0x13:
        if ((int)*yyvsp < 0) {
          *yyvsp = -*yyvsp;
          if ((9999 < (int)*yyvsp) || (0x3b < (int)*yyvsp % 100)) goto yyabort;
          yyval = ((int)*yyvsp / 100) * 0x3c + (int)*yyvsp % 100;
        }
        else {
          if ((9999 < (int)*yyvsp) || (0x3b < (int)*yyvsp % 100)) goto yyabort;
          yyval = ((int)*yyvsp / 100) * -0x3c - (int)*yyvsp % 100;
        }
        break;
      case 0x14:
        yyMonth = yyvsp[-2];
        yyDay = *yyvsp;
        break;
      case 0x15:
        if ((int)yyvsp[-4] < 0x65) {
          yyMonth = yyvsp[-4];
          yyDay = yyvsp[-2];
          yyYear = *yyvsp;
        }
        else {
          yyYear = yyvsp[-4];
          yyMonth = yyvsp[-2];
          yyDay = *yyvsp;
        }
        break;
      case 0x16:
        yyMonth = yyvsp[-1];
        yyDay = *yyvsp;
        break;
      case 0x17:
        yyMonth = yyvsp[-3];
        yyDay = yyvsp[-2];
        yyYear = *yyvsp;
        break;
      case 0x18:
        yyDay = yyvsp[-1];
        yyMonth = *yyvsp;
        break;
      case 0x19:
        yyDay = yyvsp[-2];
        yyMonth = yyvsp[-1];
        yyYear = *yyvsp;
        break;
      case 0x1a:
        yyDay = yyvsp[-2];
        yyMonth = yyvsp[-1];
        yyYear = *yyvsp;
        break;
      case 0x1b:
        yyDay = yyvsp[-3];
        yyMonth = yyvsp[-1];
        yyYear = -*yyvsp;
        break;
      case 0x1c:
        yyDay = yyvsp[-2];
        yyMonth = -yyvsp[-1];
        yyYear = -*yyvsp;
        yyDSTmode = DSToff;
        yyTimezone = 0;
        break;
      case 0x1d:
        yyMonth = yyvsp[-7];
        yyDay = yyvsp[-6];
        yyYear = *yyvsp;
        yyHour = yyvsp[-5];
        yyMinutes = yyvsp[-3];
        yySeconds = yyvsp[-1];
        break;
      case 0x1e:
        yyRelSeconds = yyvsp[-1] * *yyvsp + yyRelSeconds;
        break;
      case 0x1f:
        yyRelSeconds = yyvsp[-1] * *yyvsp + yyRelSeconds;
        break;
      case 0x20:
        yyRelMonth = yyvsp[-1] * *yyvsp + yyRelMonth;
        break;
      case 0x21:
        yyRelMonth = yyvsp[-1] * *yyvsp + yyRelMonth;
        break;
      case 0x22:
        yyval = 2;
        break;
      case 0x23:
        yyval = *yyvsp;
      }
      yyssp = yyssp + iVar3 * 0x7fffffff;
      iVar4 = (int)*yyssp;
      yyvsp = yyvsp + iVar3 * 0x3fffffff;
      iVar3 = (int)yylhs[yyn];
      if ((iVar4 != 0) || (iVar3 != 0)) {
        if (((int)yygindex[iVar3] == 0) ||
           (((iVar2 = (int)yygindex[iVar3] + iVar4, iVar2 < 0 || (300 < iVar2)) ||
            ((int)yycheck[iVar2] != iVar4)))) {
          sVar1 = yydgoto[iVar3];
        }
        else {
          sVar1 = yytable[iVar2];
        }
        yystate = (int)sVar1;
        if ((yysslim <= yyssp) && (iVar3 = yygrowstack(), iVar3 != 0)) goto yyoverflow;
        yyssp = yyssp + 1;
        *yyssp = sVar1;
        yyvsp = yyvsp + 1;
        *yyvsp = yyval;
        goto yyloop;
      }
      yystate = 1;
      yyssp = yyssp + 1;
      *yyssp = 1;
      yyvsp = yyvsp + 1;
      *yyvsp = yyval;
      if ((yychar < 0) && (yychar = date_lex(), yychar < 0)) {
        yychar = 0;
      }
    } while (yychar != 0);
    local_1c = 0;
  }
  return local_1c;
}



void set_inverse_transl(int i)

{
  int iVar1;
  uchar *local_18;
  uchar *q;
  ushort *p;
  int glyph;
  int j;
  
  q = inverse_translations[i];
  if (q == (uchar *)0x0) {
    if (i == 0) {
      local_18 = inv_norm_transl;
    }
    else {
      local_18 = (uchar *)malloc(0x200);
    }
    inverse_translations[i] = local_18;
    q = inverse_translations[i];
    if (q == (uchar *)0x0) {
      return;
    }
  }
  j = 0;
  while (j < 0x200) {
    q[j] = '\0';
    j = j + 1;
  }
  j = 0;
  while (j < 0x100) {
    iVar1 = conv_uni_to_pc((uint)translations[i * 0x100 + j],0);
    if (((-1 < iVar1) && (iVar1 < 0x200)) && (q[iVar1] < 0x20)) {
      q[iVar1] = (uchar)j;
    }
    j = j + 1;
  }
  return;
}



ushort * set_translate(int m)

{
  if (inverse_translations[m] == (uchar *)0x0) {
    set_inverse_transl(m);
  }
  inv_translate = inverse_translations[m];
  return translations + m * 0x100;
}



int UC_valid_UC_charset(int UC_charset_hndl)

{
  int local_8;
  
  if ((UC_charset_hndl < 0) || (UCNumCharsets <= UC_charset_hndl)) {
    local_8 = 0;
  }
  else {
    local_8 = 1;
  }
  return local_8;
}



void UC_con_set_trans(int UC_charset_in_hndl,int Gn,int update_flag)

{
  int iVar1;
  FILE *__stream;
  ushort *ptrans;
  ushort *p;
  int j;
  int i;
  
  iVar1 = UC_valid_UC_charset(UC_charset_in_hndl);
  if (iVar1 == 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_con_set_trans: Invalid charset handle %d.\n",UC_charset_in_hndl);
    }
  }
  else {
    p = UCInfo[UC_charset_in_hndl].unitable;
    i = 0;
    while (i < 0x100) {
      j = ZEXT14(UCInfo[UC_charset_in_hndl].unicount[i]);
      if (UCInfo[UC_charset_in_hndl].unicount[i] == 0) {
        (translations + Gn * 0x100)[i] = 0xfffd;
      }
      else {
        (translations + Gn * 0x100)[i] = *p;
        while (j != 0) {
          p = p + 1;
          j = j + -1;
        }
      }
      i = i + 1;
    }
    if (update_flag != 0) {
      set_inverse_transl(Gn);
    }
  }
  return;
}



int con_insert_unipair(ushort unicode,ushort fontpos,int fordefault)

{
  uint uVar1;
  ushort *puVar2;
  ushort *p2;
  ushort **p1;
  int n;
  int i;
  
  if (fordefault == 0) {
    n = ZEXT24(unicode >> 0xb);
    p1 = uni_pagedir[n];
  }
  else {
    n = ZEXT24(unicode >> 0xb);
    p1 = unidefault_pagedir[n];
  }
  if (p1 == (ushort **)0x0) {
    p1 = (ushort **)malloc(0x80);
    if (fordefault == 0) {
      uni_pagedir[n] = p1;
    }
    else {
      unidefault_pagedir[n] = p1;
    }
    if (p1 == (ushort **)0x0) {
      return -1;
    }
    i = 0;
    while (i < 0x20) {
      p1[i] = (ushort *)0x0;
      i = i + 1;
    }
  }
  uVar1 = (uint)(unicode >> 6) & 0x1f;
  p2 = p1[uVar1];
  if (p2 == (ushort *)0x0) {
    puVar2 = (ushort *)malloc(0x80);
    p1[uVar1] = puVar2;
    p2 = p1[uVar1];
    if (p2 == (ushort *)0x0) {
      return -1;
    }
    i = 0;
    while (i < 0x40) {
      p2[i] = 0xffff;
      i = i + 1;
    }
  }
  p2[(uint)unicode & 0x3f] = fontpos;
  return 0;
}



int con_insert_unipair_str(ushort unicode,char *replace_str,int fordefault)

{
  uint uVar1;
  char **ppcVar2;
  char **p2;
  char ***p1;
  int n;
  int i;
  
  if (fordefault == 0) {
    n = ZEXT24(unicode >> 0xb);
    p1 = uni_pagedir_str[n];
  }
  else {
    n = ZEXT24(unicode >> 0xb);
    p1 = unidefault_pagedir_str[n];
  }
  if (p1 == (char ***)0x0) {
    p1 = (char ***)malloc(0x80);
    if (fordefault == 0) {
      uni_pagedir_str[n] = p1;
    }
    else {
      unidefault_pagedir_str[n] = p1;
    }
    if (p1 == (char ***)0x0) {
      return -1;
    }
    i = 0;
    while (i < 0x20) {
      p1[i] = (char **)0x0;
      i = i + 1;
    }
  }
  uVar1 = (uint)(unicode >> 6) & 0x1f;
  if (p1[uVar1] == (char **)0x0) {
    ppcVar2 = (char **)malloc(0x100);
    p1[uVar1] = ppcVar2;
    if (p1[uVar1] == (char **)0x0) {
      return -1;
    }
    ppcVar2 = p1[uVar1];
    i = 0;
    while (i < 0x40) {
      ppcVar2[i] = (char *)0x0;
      i = i + 1;
    }
  }
  p1[uVar1][(uint)unicode & 0x3f] = replace_str;
  return 0;
}



void con_clear_unimap(int fordefault)

{
  ushort **__ptr;
  ushort **p1;
  int j;
  int i;
  
  if (fordefault == 0) {
    i = 0;
    while (i < 0x20) {
      __ptr = uni_pagedir[i];
      if (__ptr != (ushort **)0x0) {
        j = 0;
        while (j < 0x20) {
          if (__ptr[j] != (ushort *)0x0) {
            free(__ptr[j]);
            __ptr[j] = (ushort *)0x0;
          }
          j = j + 1;
        }
        if (__ptr != (ushort **)0x0) {
          free(__ptr);
        }
      }
      uni_pagedir[i] = (ushort **)0x0;
      i = i + 1;
    }
    hashtable_contents_valid = 1;
  }
  else {
    i = 0;
    while (i < 0x20) {
      __ptr = unidefault_pagedir[i];
      if (__ptr != (ushort **)0x0) {
        j = 0;
        while (j < 0x20) {
          if (__ptr[j] != (ushort *)0x0) {
            free(__ptr[j]);
            __ptr[j] = (ushort *)0x0;
          }
          j = j + 1;
        }
        if (__ptr != (ushort **)0x0) {
          free(__ptr);
        }
      }
      unidefault_pagedir[i] = (ushort **)0x0;
      i = i + 1;
    }
    unidefault_contents_valid = 1;
  }
  return;
}



void con_clear_unimap_str(int fordefault)

{
  char ***__ptr;
  char ***p1;
  int j;
  int i;
  
  if (fordefault == 0) {
    i = 0;
    while (i < 0x20) {
      __ptr = uni_pagedir_str[i];
      if (__ptr != (char ***)0x0) {
        j = 0;
        while (j < 0x20) {
          if (__ptr[j] != (char **)0x0) {
            free(__ptr[j]);
            __ptr[j] = (char **)0x0;
          }
          j = j + 1;
        }
        if (__ptr != (char ***)0x0) {
          free(__ptr);
        }
      }
      uni_pagedir_str[i] = (char ***)0x0;
      i = i + 1;
    }
    hashtable_str_contents_valid = 1;
  }
  else {
    i = 0;
    while (i < 0x20) {
      __ptr = unidefault_pagedir_str[i];
      if (__ptr != (char ***)0x0) {
        j = 0;
        while (j < 0x20) {
          if (__ptr[j] != (char **)0x0) {
            free(__ptr[j]);
            __ptr[j] = (char **)0x0;
          }
          j = j + 1;
        }
        if (__ptr != (char ***)0x0) {
          free(__ptr);
        }
      }
      unidefault_pagedir_str[i] = (char ***)0x0;
      i = i + 1;
    }
    unidefault_str_contents_valid = 1;
  }
  return;
}



void con_set_default_unimap(void)

{
  ushort unicode;
  ushort *p;
  int j;
  int i;
  
  con_clear_unimap(1);
  p = dfont_unitable;
  i = 0;
  while (i < 0x100) {
    j = ZEXT14(""[i]);
    while (j != 0) {
      unicode = *p;
      p = p + 1;
      con_insert_unipair(unicode,(ushort)i,1);
      j = j + -1;
    }
    i = i + 1;
  }
  UC_default_unitable = dfont_unitable;
  con_clear_unimap_str(1);
  UC_con_set_unimap_str(0xa32,repl_map,1);
  UC_default_unitable_str = &dfont_replacedesc;
  return;
}



int UC_con_set_unimap(int UC_charset_out_hndl,int update_flag)

{
  ushort unicode;
  int iVar1;
  FILE *__stream;
  int local_18;
  ushort *p;
  int j;
  int i;
  
  iVar1 = UC_valid_UC_charset(UC_charset_out_hndl);
  if (iVar1 == 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_con_set_unimap: Invalid charset handle %d.\n",UC_charset_out_hndl
             );
    }
    local_18 = -1;
  }
  else {
    p = UCInfo[UC_charset_out_hndl].unitable;
    if (p == UC_current_unitable) {
      local_18 = update_flag;
    }
    else {
      UC_current_unitable = p;
      con_clear_unimap(0);
      i = 0;
      while (i < 0x100) {
        j = ZEXT14(UCInfo[UC_charset_out_hndl].unicount[i]);
        while (j != 0) {
          unicode = *p;
          p = p + 1;
          con_insert_unipair(unicode,(ushort)i,0);
          j = j + -1;
        }
        i = i + 1;
      }
      if (update_flag != 0) {
        i = 0;
        while (i < 4) {
          set_inverse_transl(i);
          i = i + 1;
        }
      }
      local_18 = 0;
    }
  }
  return local_18;
}



int UC_con_set_unimap_str(ushort ct,unipair_str *list,int fordefault)

{
  int iVar1;
  bool bVar2;
  ushort local_18;
  int err1;
  int err;
  
  local_18 = ct;
  err = 0;
  while (bVar2 = local_18 != 0, local_18 = local_18 - 1, bVar2) {
    iVar1 = con_insert_unipair_str(list->unicode,list->replace_str,fordefault);
    if (iVar1 != 0) {
      err = iVar1;
    }
    list = list + 1;
  }
  if (err == 0) {
    if (fordefault == 0) {
      hashtable_str_contents_valid = 1;
    }
    else {
      unidefault_str_contents_valid = 1;
    }
  }
  return err;
}



int conv_uni_to_pc(long ucs,int usedefault)

{
  ushort uVar1;
  uint local_18;
  ushort *p2;
  ushort **p1;
  int h;
  
  if (ucs < 0x10000) {
    if ((ucs < 0x20) || (0xfffd < ucs)) {
      return -1;
    }
    if ((ucs == 0xfeff) || ((0x200a < ucs && (ucs < 0x2010)))) {
      return -2;
    }
    if ((ucs & 0xfffffe00U) == 0xf000) {
      return ucs & 0x1ff;
    }
  }
  else {
    ucs = 0xfffd;
  }
  if (usedefault == 0) {
    if (hashtable_contents_valid == 0) {
      return -3;
    }
    p1 = uni_pagedir[ucs >> 0xb];
  }
  else {
    if (unidefault_contents_valid == 0) {
      return -3;
    }
    p1 = unidefault_pagedir[ucs >> 0xb];
  }
  if (((p1 == (ushort **)0x0) || (p1[ucs >> 6 & 0x1f] == (ushort *)0x0)) ||
     (uVar1 = p1[ucs >> 6 & 0x1f][ucs & 0x3f], local_18 = (uint)uVar1, 0x1ff < uVar1)) {
    local_18 = 0xfffffffc;
  }
  return local_18;
}



int conv_uni_to_str(char *outbuf,int buflen,long ucs,int usedefault)

{
  char *__src;
  int local_18;
  char **p2;
  char ***p1;
  char *h;
  
  if (ucs < 0x10000) {
    if ((ucs < 0x20) || (0xfffd < ucs)) {
      return -1;
    }
    if ((ucs == 0xfeff) || ((0x200a < ucs && (ucs < 0x2010)))) {
      return -2;
    }
  }
  else {
    ucs = 0xfffd;
  }
  if (usedefault == 0) {
    if (hashtable_str_contents_valid == 0) {
      return -3;
    }
    p1 = uni_pagedir_str[ucs >> 0xb];
  }
  else {
    if (unidefault_str_contents_valid == 0) {
      return -3;
    }
    p1 = unidefault_pagedir_str[ucs >> 0xb];
  }
  if (((p1 == (char ***)0x0) || (p1[ucs >> 6 & 0x1f] == (char **)0x0)) ||
     (__src = p1[ucs >> 6 & 0x1f][ucs & 0x3f], __src == (char *)0x0)) {
    local_18 = -4;
  }
  else {
    strncpy(outbuf,__src,buflen - 1);
    local_18 = 1;
  }
  return local_18;
}



void UCconsole_map_init(void)

{
  con_set_default_unimap();
  UCInitialized = 1;
  return;
}



int UCTransUniChar(long unicode,int charset_out)

{
  int local_2c;
  int local_28;
  ushort *ut;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int rc;
  
  rc = 0;
  trydefault = 0;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if (UChndl_out < 0) {
    if (LYCharSet_UC[charset_out].codepage < 0) {
      if (unicode < 0x80) {
        local_28 = unicode;
      }
      else {
        local_28 = LYCharSet_UC[charset_out].codepage;
      }
      return local_28;
    }
    UChndl_out = default_UChndl;
    if (default_UChndl < 0) {
      return -0xc;
    }
    isdefault = 1;
  }
  else {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  if (((isdefault != 0) ||
      (((UCInfo[UChndl_out].unitable == UC_current_unitable ||
        (local_2c = UC_con_set_unimap(UChndl_out,1), -1 < local_2c)) &&
       (local_2c = conv_uni_to_pc(unicode,0), rc = local_2c, local_2c < 0)))) &&
     (((isdefault == 0 && (trydefault == 0)) ||
      (local_2c = conv_uni_to_pc(unicode,1), rc = local_2c, local_2c < 0)))) {
    if ((isdefault == 0) && (rc == -4)) {
      rc = conv_uni_to_pc(0xfffd,0);
    }
    if (((isdefault != 0) || (trydefault != 0)) && (rc == -4)) {
      rc = conv_uni_to_pc(0xfffd,1);
    }
    local_2c = rc;
  }
  return local_2c;
}



int UCTransUniCharStr(char *outbuf,int buflen,long unicode,int charset_out,int chk_single_flag)

{
  int iVar1;
  unimapdesc_str *puVar2;
  size_t sVar3;
  FILE *__stream;
  int local_48;
  char *tocode;
  size_t outleft;
  size_t inleft;
  char *pout;
  char *pin;
  iconv_t cd;
  ushort *ut;
  unimapdesc_str *repl;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int ignore_err;
  int src;
  int rc;
  char str [3];
  
  rc = -0xe;
  src = 0;
  trydefault = 0;
  if (buflen < 2) {
    return -0xd;
  }
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if (UChndl_out < 0) {
    if (LYCharSet_UC[charset_out].codepage < 0) {
      return LYCharSet_UC[charset_out].codepage;
    }
    UChndl_out = default_UChndl;
    if (default_UChndl < 0) {
      return -0xc;
    }
    isdefault = 1;
  }
  else {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  if (chk_single_flag != 0) {
    if (((isdefault == 0) && (UCInfo[UChndl_out].unitable != UC_current_unitable)) &&
       (iVar1 = UC_con_set_unimap(UChndl_out,1), iVar1 < 0)) {
      return iVar1;
    }
    src = conv_uni_to_pc(unicode,isdefault);
    if (0x1f < src) {
      *outbuf = (char)src;
      outbuf[1] = '\0';
      return 1;
    }
  }
  puVar2 = &UCInfo[UChndl_out].replacedesc;
  if (isdefault == 0) {
    if (puVar2 != UC_current_unitable_str) {
      con_clear_unimap_str(0);
      UC_con_set_unimap_str(puVar2->entry_ct,UCInfo[UChndl_out].replacedesc.entries,0);
      UC_current_unitable_str = puVar2;
    }
    rc = conv_uni_to_str(outbuf,buflen,unicode,0);
    if (-1 < rc) {
      sVar3 = strlen(outbuf);
      return sVar3;
    }
  }
  if (((trydefault == 0) || (chk_single_flag == 0)) || (src = conv_uni_to_pc(unicode,1), src < 0x20)
     ) {
    if ((isdefault != 0) || (trydefault != 0)) {
      iVar1 = strcmp(LYCharSet_UC[charset_out].MIMEname,"shift_jis");
      if ((iVar1 == 0) || (iVar1 = strcmp(LYCharSet_UC[charset_out].MIMEname,"euc-jp"), iVar1 == 0))
      {
        tocode = (char *)0x0;
        str[0] = (char)((uint)unicode >> 8);
        str[1] = (char)unicode;
        str[2] = '\0';
        pin = str;
        inleft = 2;
        pout = outbuf;
        outleft = buflen;
        HTSprintf0(&tocode,"%s//TRANSLIT",LYCharSet_UC[charset_out].MIMEname);
        cd = iconv_open(tocode,"UTF-16BE");
        if (tocode != (char *)0x0) {
          free(tocode);
          tocode = (char *)0x0;
        }
        if (cd == (iconv_t)0xffffffff) {
          cd = iconv_open(LYCharSet_UC[charset_out].MIMEname,"UTF-16BE");
        }
        sVar3 = iconv(cd,&pin,&inleft,&pout,&outleft);
        iconv_close(cd);
        if (pout + -(int)outbuf == (char *)0x3) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"It seems to be a JIS X 0201 code(%ld). Not supported.\n",
                    unicode);
          }
          pin = str;
          inleft = 2;
          pout = outbuf;
          outleft = buflen;
        }
        else {
          if (-1 < (int)sVar3) {
            *pout = '\0';
            sVar3 = strlen(outbuf);
            return sVar3;
          }
        }
      }
      rc = conv_uni_to_str(outbuf,buflen,unicode,1);
      if (-1 < rc) {
        sVar3 = strlen(outbuf);
        return sVar3;
      }
    }
    if (rc == -4) {
      if (isdefault == 0) {
        rc = conv_uni_to_str(outbuf,buflen,0xfffd,0);
      }
      if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
        rc = conv_uni_to_str(outbuf,buflen,0xfffd,1);
      }
      if (-1 < rc) {
        sVar3 = strlen(outbuf);
        return sVar3;
      }
    }
    if ((chk_single_flag == 0) || (src != -4)) {
      local_48 = -4;
    }
    else {
      if (isdefault == 0) {
        rc = conv_uni_to_pc(0xfffd,0);
      }
      if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
        rc = conv_uni_to_pc(0xfffd,1);
      }
      if (rc < 0x20) {
        local_48 = rc;
      }
      else {
        *outbuf = (char)rc;
        outbuf[1] = '\0';
        local_48 = 1;
      }
    }
  }
  else {
    *outbuf = (char)src;
    outbuf[1] = '\0';
    local_48 = 1;
  }
  return local_48;
}



int UC_MapGN(int UChndl,int update_flag)

{
  char *pcVar1;
  bool bVar2;
  FILE *__stream;
  int local_1c;
  int lasthndl;
  int found;
  int Gn;
  int i;
  
  bVar2 = false;
  Gn = -1;
  i = 0;
  while ((i < 4 && (Gn < 0))) {
    if (UC_GNhandles[i] < 0) {
      Gn = i;
    }
    else {
      if (UC_GNhandles[i] == UChndl) {
        Gn = i;
        bVar2 = true;
      }
    }
    i = i + 1;
  }
  if (bVar2) {
    local_1c = Gn;
  }
  else {
    if (Gn < 0) {
      if (UC_lastautoGN == 1) {
        Gn = 2;
      }
      else {
        Gn = 1;
      }
      UC_lastautoGN = Gn;
      UCInfo[UC_GNhandles[Gn]].GN = -1;
      UCInfo[UChndl].GN = Gn;
      UC_GNhandles[Gn] = UChndl;
    }
    else {
      UCInfo[UChndl].GN = Gn;
      UC_GNhandles[Gn] = UChndl;
    }
    if (WWW_TraceFlag != '\0') {
      pcVar1 = UCInfo[UChndl].MIMEname;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_MapGN: Using %d <- %d (%s)\n",Gn,UChndl,pcVar1);
    }
    UC_con_set_trans(UChndl,Gn,update_flag);
    local_1c = Gn;
  }
  return local_1c;
}



int UCTransChar(char ch_in,int charset_in,int charset_out)

{
  ushort uVar1;
  int UChndl;
  bool bVar2;
  uint local_3c;
  int upd;
  ushort *ut;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int UChndl_in;
  int rc;
  int Gn;
  int unicode;
  
  rc = -4;
  trydefault = 0;
  if (charset_in == charset_out) {
    local_3c = (uint)(byte)ch_in;
  }
  else {
    if (charset_in < 0) {
      local_3c = 0xfffffff5;
    }
    else {
      UChndl = LYCharSet_UC[charset_in].UChndl;
      if (UChndl < 0) {
        local_3c = 0xfffffff5;
      }
      else {
        UChndl_out = LYCharSet_UC[charset_out].UChndl;
        if (UChndl_out < 0) {
          if (LYCharSet_UC[charset_out].codepage < 0) {
            return LYCharSet_UC[charset_out].codepage;
          }
          UChndl_out = default_UChndl;
          if (default_UChndl < 0) {
            return -0xc;
          }
          isdefault = 1;
        }
        else {
          isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
          trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
        }
        if (UCInfo[UChndl].num_uni == 0) {
          local_3c = 0xfffffff5;
        }
        else {
          Gn = UCInfo[UChndl].GN;
          bVar2 = Gn < 0;
          if (bVar2) {
            Gn = UC_MapGN(UChndl,0);
          }
          if (isdefault == 0) {
            if (UCInfo[UChndl_out].unitable == UC_current_unitable) {
              if (bVar2) {
                set_inverse_transl(Gn);
              }
            }
            else {
              rc = UC_con_set_unimap(UChndl_out,1);
              if (rc < 1) {
                if (rc < 0) {
                  return rc;
                }
              }
              else {
                set_inverse_transl(Gn);
              }
            }
          }
          UC_translate = set_translate(Gn);
          uVar1 = UC_translate[(byte)ch_in];
          if ((isdefault != 0) ||
             (local_3c = conv_uni_to_pc((uint)uVar1,0), rc = local_3c, (int)local_3c < 0)) {
            if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
              rc = conv_uni_to_pc((uint)uVar1,1);
            }
            if ((rc == -4) && (isdefault == 0)) {
              rc = conv_uni_to_pc(0xfffd,0);
            }
            if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
              rc = conv_uni_to_pc(0xfffd,1);
            }
            local_3c = rc;
          }
        }
      }
    }
  }
  return local_3c;
}



UCode_t UCTransJPToUni(char *inbuf,int buflen,int charset_in)

{
  iconv_t __cd;
  uint local_28;
  iconv_t cd;
  size_t olen;
  size_t ilen;
  size_t rc;
  char *pout;
  char *pin;
  char outbuf [3];
  
  pin = inbuf;
  pout = outbuf;
  ilen = 2;
  olen = buflen;
  __cd = iconv_open("UTF-16BE",LYCharSet_UC[charset_in].MIMEname);
  iconv(__cd,&pin,&ilen,&pout,&olen);
  iconv_close(__cd);
  if ((ilen == 0) && (olen == 0)) {
    local_28 = (uint)CONCAT11(outbuf[0],outbuf[1]);
  }
  else {
    local_28 = 0xfffffff5;
  }
  return local_28;
}



UCode_t UCTransToUni(char ch_in,int charset_in)

{
  int inx;
  char buffer [3];
  int UChndl;
  iconv_t __cd;
  uint local_3c;
  iconv_t cd;
  size_t olen;
  size_t ilen;
  size_t rc;
  char *pout;
  char *pin;
  int UChndl_in;
  int Gn;
  int unicode;
  char obuffer [3];
  uchar ch_iu;
  
  if (charset_in == LATIN1) {
    return (uint)(byte)ch_in;
  }
  UChndl = strcmp(LYCharSet_UC[charset_in].MIMEname,"shift_jis");
  if ((UChndl == 0) || (UChndl = strcmp(LYCharSet_UC[charset_in].MIMEname,"euc-jp"), UChndl == 0)) {
    pin = (char *)0x81b2130;
    pout = obuffer;
    olen = 2;
    ilen = 2;
    UChndl = strcmp(LYCharSet_UC[charset_in].MIMEname,"shift_jis");
    if (UChndl == 0) {
      if (inx == 0) {
        if (((0x80 < (byte)ch_in) && ((byte)ch_in < 0xa0)) ||
           ((0xdf < (byte)ch_in && ((byte)ch_in < 0xf0)))) {
          return -0xb;
        }
      }
      else {
        if (((0x3f < (byte)ch_in) && (ch_in != '\x7f')) && ((byte)ch_in < 0xfd)) {
          buffer[2] = '\0';
          buffer[1] = ch_in;
          __cd = iconv_open("UTF-16BE","Shift_JIS");
          iconv(__cd,&pin,&ilen,&pout,&olen);
          iconv_close(__cd);
          inx = 0;
          if ((ilen == 0) && (olen == 0)) {
            return (uint)CONCAT11(obuffer[0],obuffer[1]);
          }
        }
      }
    }
    UChndl = strcmp(LYCharSet_UC[charset_in].MIMEname,"euc-jp");
    if (UChndl == 0) {
      if (inx == 0) {
        if ((0xa0 < (byte)ch_in) && (ch_in != -1)) {
          return -0xb;
        }
      }
      else {
        if ((0xa0 < (byte)ch_in) && (ch_in != -1)) {
          buffer[2] = '\0';
          buffer[1] = ch_in;
          __cd = iconv_open("UTF-16BE","EUC-JP");
          iconv(__cd,&pin,&ilen,&pout,&olen);
          iconv_close(__cd);
          if ((ilen == 0) && (olen == 0)) {
            return (uint)CONCAT11(obuffer[0],obuffer[1]);
          }
        }
      }
    }
    inx = 0;
  }
  if ((ch_in < '\0') || ((byte)ch_in < 0x20)) {
    if (charset_in < 0) {
      local_3c = 0xfffffff5;
    }
    else {
      if (((byte)ch_in < 0x20) && (LYCharSet_UC[charset_in].enc != 3)) {
        local_3c = (uint)(byte)ch_in;
      }
      else {
        UChndl = LYCharSet_UC[charset_in].UChndl;
        if (UChndl < 0) {
          local_3c = 0xfffffff5;
        }
        else {
          if (UCInfo[UChndl].num_uni == 0) {
            local_3c = 0xfffffff5;
          }
          else {
            Gn = UCInfo[UChndl].GN;
            if (Gn < 0) {
              Gn = UC_MapGN(UChndl,1);
            }
            UC_translate = set_translate(Gn);
            local_3c = (uint)UC_translate[(byte)ch_in];
          }
        }
      }
    }
  }
  else {
    local_3c = (uint)(byte)ch_in;
  }
  return local_3c;
}



int UCReverseTransChar(char ch_out,int charset_in,int charset_out)

{
  int UChndl;
  uint local_2c;
  ushort *ut;
  int i_ch;
  int isdefault;
  int UChndl_out;
  int UChndl_in;
  int rc;
  int Gn;
  
  rc = -1;
  if (charset_in == charset_out) {
    local_2c = (uint)(byte)ch_out;
  }
  else {
    if (charset_in < 0) {
      local_2c = 0xfffffff5;
    }
    else {
      UChndl = LYCharSet_UC[charset_in].UChndl;
      if (UChndl < 0) {
        local_2c = 0xfffffff5;
      }
      else {
        if (UCInfo[UChndl].num_uni == 0) {
          local_2c = 0xfffffff5;
        }
        else {
          if (charset_out < 0) {
            local_2c = 0xfffffff4;
          }
          else {
            UChndl_out = LYCharSet_UC[charset_out].UChndl;
            if (UChndl_out < 0) {
              if (LYCharSet_UC[charset_out].codepage < 0) {
                return LYCharSet_UC[charset_out].codepage;
              }
              UChndl_out = default_UChndl;
              if (default_UChndl < 0) {
                return -0xc;
              }
              isdefault = 1;
            }
            else {
              isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
            }
            if ((isdefault == 0) && (UCInfo[UChndl_out].unitable == UC_current_unitable)) {
              Gn = UCInfo[UChndl].GN;
              if (Gn < 0) {
                Gn = UC_MapGN(UChndl,1);
              }
              UC_translate = set_translate(Gn);
              if (inv_translate != (uchar *)0x0) {
                rc = ZEXT14(inv_translate[(byte)ch_out]);
              }
              if (0x1f < rc) {
                return rc;
              }
            }
            local_2c = UCTransChar(ch_out,charset_out,charset_in);
          }
        }
      }
    }
  }
  return local_2c;
}



int UCTransCharStr(char *outbuf,int buflen,char ch_in,int charset_in,int charset_out,
                  int chk_single_flag)

{
  uint ucs;
  int UChndl;
  unimapdesc_str *puVar1;
  size_t sVar2;
  size_t local_3c;
  int upd;
  ushort *ut;
  unimapdesc_str *repl;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int UChndl_in;
  int ignore_err;
  int src;
  int rc;
  int Gn;
  int unicode;
  
  rc = -0xe;
  src = 0;
  trydefault = 0;
  upd = 0;
  if (buflen < 2) {
    local_3c = 0xfffffff3;
  }
  else {
    if ((chk_single_flag == 0) || (charset_in != charset_out)) {
      if (charset_in < 0) {
        local_3c = 0xfffffff5;
      }
      else {
        UChndl = LYCharSet_UC[charset_in].UChndl;
        if (UChndl < 0) {
          local_3c = 0xfffffff5;
        }
        else {
          if (UCInfo[UChndl].num_uni == 0) {
            local_3c = 0xfffffff5;
          }
          else {
            UChndl_out = LYCharSet_UC[charset_out].UChndl;
            if (UChndl_out < 0) {
              if (LYCharSet_UC[charset_out].codepage < 0) {
                return LYCharSet_UC[charset_out].codepage;
              }
              UChndl_out = default_UChndl;
              if (default_UChndl < 0) {
                return -0xc;
              }
              isdefault = 1;
            }
            else {
              isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
              trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
            }
            Gn = UCInfo[UChndl].GN;
            if (Gn < 0) {
              Gn = UC_MapGN(UChndl,(uint)(chk_single_flag == 0));
              upd = chk_single_flag;
            }
            UC_translate = set_translate(Gn);
            ucs = (uint)UC_translate[(byte)ch_in];
            if (chk_single_flag != 0) {
              if (isdefault == 0) {
                if (UCInfo[UChndl_out].unitable == UC_current_unitable) {
                  if (upd != 0) {
                    set_inverse_transl(Gn);
                  }
                }
                else {
                  UChndl = UC_con_set_unimap(UChndl_out,1);
                  if (UChndl < 1) {
                    if (UChndl < 0) {
                      return UChndl;
                    }
                  }
                  else {
                    set_inverse_transl(Gn);
                  }
                }
              }
              src = conv_uni_to_pc(ucs,isdefault);
              if (0x1f < src) {
                *outbuf = (char)src;
                outbuf[1] = '\0';
                return 1;
              }
            }
            puVar1 = &UCInfo[UChndl_out].replacedesc;
            if (isdefault == 0) {
              if (puVar1 != UC_current_unitable_str) {
                con_clear_unimap_str(0);
                UC_con_set_unimap_str(puVar1->entry_ct,UCInfo[UChndl_out].replacedesc.entries,0);
                UC_current_unitable_str = puVar1;
              }
              rc = conv_uni_to_str(outbuf,buflen,ucs,0);
              if (-1 < rc) {
                sVar2 = strlen(outbuf);
                return sVar2;
              }
            }
            if (((trydefault == 0) || (chk_single_flag == 0)) ||
               (src = conv_uni_to_pc(ucs,1), src < 0x20)) {
              if (((isdefault == 0) && (trydefault == 0)) ||
                 (rc = conv_uni_to_str(outbuf,buflen,ucs,1), rc < 0)) {
                if (rc == -4) {
                  if (isdefault == 0) {
                    rc = conv_uni_to_str(outbuf,buflen,0xfffd,0);
                  }
                  if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
                    rc = conv_uni_to_str(outbuf,buflen,0xfffd,1);
                  }
                  if (-1 < rc) {
                    sVar2 = strlen(outbuf);
                    return sVar2;
                  }
                }
                if ((chk_single_flag == 0) || (src != -4)) {
                  local_3c = 0xfffffffc;
                }
                else {
                  if (isdefault == 0) {
                    rc = conv_uni_to_pc(0xfffd,0);
                  }
                  if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
                    rc = conv_uni_to_pc(0xfffd,1);
                  }
                  if (rc < 0x20) {
                    if (rc < 1) {
                      *outbuf = '\0';
                      local_3c = rc;
                    }
                    else {
                      local_3c = rc;
                    }
                  }
                  else {
                    *outbuf = (char)rc;
                    outbuf[1] = '\0';
                    local_3c = 1;
                  }
                }
              }
              else {
                local_3c = strlen(outbuf);
              }
            }
            else {
              *outbuf = (char)src;
              outbuf[1] = '\0';
              local_3c = 1;
            }
          }
        }
      }
    }
    else {
      *outbuf = ch_in;
      outbuf[1] = '\0';
      local_3c = 1;
    }
  }
  return local_3c;
}



int UC_FindGN_byMIME(char *UC_MIMEcharset)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (3 < i) {
      return -1;
    }
    iVar1 = strcmp(UC_MIMEcharset,UC_GNsetMIMEnames[i]);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return i;
}



int UCGetRawUniMode_byLYhndl(int i)

{
  int local_8;
  
  if (i < 0) {
    local_8 = 0;
  }
  else {
    local_8 = LYCharSet_UC[i].enc;
  }
  return local_8;
}



int getLYhndl_byCP(char *prefix,char *codepage)

{
  int nested;
  bool bVar1;
  char *cptmp;
  int result;
  
  result = -1;
  bVar1 = nested == 0;
  nested = nested + 1;
  if (bVar1) {
    cptmp = (char *)0x0;
    HTSACopy(&cptmp,prefix);
    HTSACat(&cptmp,codepage);
    result = UCGetLYhndl_byMIME(cptmp);
    if (cptmp != (char *)0x0) {
      free(cptmp);
    }
  }
  return result;
}



int UCGetLYhndl_byMIME(char *value)

{
  FILE *__stream;
  int iVar1;
  ushort **ppuVar2;
  int local_18;
  int LYhndl;
  int i;
  
  if ((value == (char *)0x0) || (*value == '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n");
    }
    local_18 = -1;
  }
  else {
    i = 0;
    while (((i < 0x3c && (i < LYNumCharsets)) && (LYchar_set_names[i] != (char *)0x0))) {
      if ((LYCharSet_UC[i].MIMEname != (char *)0x0) &&
         (iVar1 = strcasecomp(value,LYCharSet_UC[i].MIMEname), iVar1 == 0)) {
        return i;
      }
      i = i + 1;
    }
    iVar1 = strcasecomp(value,"unicode-1-1-utf-8");
    if ((iVar1 == 0) || (iVar1 = strcasecomp(value,"utf8"), iVar1 == 0)) {
      local_18 = UCGetLYhndl_byMIME("utf-8");
    }
    else {
      iVar1 = strcasecomp(value,"x-euc-jp");
      if (iVar1 == 0) {
        local_18 = UCGetLYhndl_byMIME("euc-jp");
      }
      else {
        iVar1 = strcasecomp(value,"x-shift-jis");
        if ((iVar1 == 0) || (iVar1 = strcasecomp(value,"x-sjis"), iVar1 == 0)) {
          local_18 = UCGetLYhndl_byMIME("shift_jis");
        }
        else {
          iVar1 = strcasecomp(value,"iso-2022-kr");
          if (iVar1 == 0) {
            local_18 = UCGetLYhndl_byMIME("euc-kr");
          }
          else {
            iVar1 = strcasecomp(value,"gb2312");
            if (((iVar1 == 0) || (iVar1 = strncasecomp(value,"cn-gb",5), iVar1 == 0)) ||
               (iVar1 = strcasecomp(value,"iso-2022-cn"), iVar1 == 0)) {
              local_18 = UCGetLYhndl_byMIME("euc-cn");
            }
            else {
              iVar1 = strcasecomp(value,"cn-big5");
              if (iVar1 == 0) {
                local_18 = UCGetLYhndl_byMIME("big5");
              }
              else {
                iVar1 = strcasecomp(value,"x-mac-roman");
                if ((iVar1 == 0) || (iVar1 = strcasecomp(value,"mac-roman"), iVar1 == 0)) {
                  local_18 = UCGetLYhndl_byMIME("macintosh");
                }
                else {
                  iVar1 = strcasecomp(value,"x-next");
                  if (((iVar1 == 0) || (iVar1 = strcasecomp(value,"nextstep"), iVar1 == 0)) ||
                     (iVar1 = strcasecomp(value,"x-nextstep"), iVar1 == 0)) {
                    local_18 = UCGetLYhndl_byMIME("next");
                  }
                  else {
                    iVar1 = strcasecomp(value,"iso-8859-1-windows-3.1-latin-1");
                    if ((((iVar1 == 0) || (iVar1 = strcasecomp(value,"cp1252"), iVar1 == 0)) ||
                        (iVar1 = strcasecomp(value,"cp-1252"), iVar1 == 0)) ||
                       ((iVar1 = strcasecomp(value,"ibm1252"), iVar1 == 0 ||
                        (iVar1 = strcasecomp(value,"iso-8859-1-windows-3.0-latin-1"), iVar1 == 0))))
                    {
                      local_18 = UCGetLYhndl_byMIME("windows-1252");
                    }
                    else {
                      iVar1 = strcasecomp(value,"iso-8859-2-windows-latin-2");
                      if (((iVar1 == 0) || (iVar1 = strcasecomp(value,"cp1250"), iVar1 == 0)) ||
                         ((iVar1 = strcasecomp(value,"cp-1250"), iVar1 == 0 ||
                          (iVar1 = strcasecomp(value,"ibm1250"), iVar1 == 0)))) {
                        local_18 = UCGetLYhndl_byMIME("windows-1250");
                      }
                      else {
                        iVar1 = strncasecomp(value,"ibm",3);
                        if ((((iVar1 == 0) || (iVar1 = strncasecomp(value,"cp-",3), iVar1 == 0)) &&
                            (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)value[3]] & 0x800) != 0))
                           && ((ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)value[4]] & 0x800) != 0
                               && (ppuVar2 = __ctype_b_loc(),
                                  ((*ppuVar2)[(byte)value[5]] & 0x800) != 0)))) {
                          local_18 = getLYhndl_byCP("cp",value + 3);
                          if (local_18 < 0) {
                            local_18 = getLYhndl_byCP("windows-",value + 3);
                          }
                        }
                        else {
                          iVar1 = strncasecomp(value,"windows-",8);
                          if (((iVar1 == 0) &&
                              ((ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)value[8]] & 0x800) != 0
                               && (ppuVar2 = __ctype_b_loc(),
                                  ((*ppuVar2)[(byte)value[9]] & 0x800) != 0)))) &&
                             (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)value[10]] & 0x800) != 0)
                             ) {
                            local_18 = getLYhndl_byCP("cp",value + 8);
                          }
                          else {
                            iVar1 = strcasecomp(value,"koi-8");
                            if (iVar1 == 0) {
                              local_18 = UCGetLYhndl_byMIME("koi8-r");
                            }
                            else {
                              iVar1 = strcasecomp(value,"ANSI_X3.4-1968");
                              if (iVar1 == 0) {
                                local_18 = US_ASCII;
                              }
                              else {
                                if (WWW_TraceFlag != '\0') {
                                  __stream = TraceFP();
                                  fprintf((FILE *)__stream,
                                          "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n",
                                          value);
                                }
                                local_18 = -1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return local_18;
}



void UCreset_allocated_LYCharSets(void)

{
  int i;
  
  i = 0;
  while (i < 0x3c) {
    remember_allocated_LYCharSets[i] = (char **)0x0;
    i = i + 1;
  }
  return;
}



char ** UC_setup_LYCharSets_repl(int UC_charset_in_hndl,uint lowest8)

{
  ushort uVar1;
  char *__s1;
  byte *pbVar2;
  char **ppcVar3;
  char dummy [2];
  void *__ptr;
  void *__ptr_00;
  HTAtom *pHVar4;
  int iVar5;
  bool bVar6;
  char **local_48;
  unipair_str *list;
  uchar *ti;
  int changed;
  int j;
  size_t i;
  char *s8;
  char *s7;
  char **tp;
  ushort *pp;
  char **prepl;
  char **p;
  char **ISO_Latin1;
  ushort ct;
  ushort k;
  
  ppcVar3 = LYCharSets[0];
  __ptr = malloc(0x180);
  if (__ptr == (void *)0x0) {
    local_48 = (char **)0x0;
  }
  else {
    i = 0;
    while (i < 0x60) {
      *(undefined4 *)(i * 4 + (int)__ptr) = 0;
      i = i + 1;
    }
    __ptr_00 = malloc(0x60);
    if (__ptr_00 == (void *)0x0) {
      if (__ptr != (void *)0x0) {
        free(__ptr);
      }
      local_48 = (char **)0x0;
    }
    else {
      i = 0;
      while (i < 0x60) {
        *(undefined *)((int)__ptr_00 + i) = 0;
        i = i + 1;
      }
      pp = UCInfo[UC_charset_in_hndl].unitable;
      if (0 < UCInfo[UC_charset_in_hndl].num_uni) {
        i = 0;
        while (i < 0x100) {
          j = ZEXT14(UCInfo[UC_charset_in_hndl].unicount[i]);
          if (UCInfo[UC_charset_in_hndl].unicount[i] != 0) {
            uVar1 = *pp;
            if (((0x9f < uVar1) && (uVar1 < 0x100)) && (lowest8 <= i)) {
              *(undefined *)(((uint)uVar1 - 0xa0) + (int)__ptr_00) = (char)i;
            }
            while (j != 0) {
              pp = pp + 1;
              j = j + -1;
            }
          }
          i = i + 1;
        }
      }
      ct = UCInfo[UC_charset_in_hndl].replacedesc.entry_ct;
      list = UCInfo[UC_charset_in_hndl].replacedesc.entries;
      while (bVar6 = ct != 0, ct = ct - 1, bVar6) {
        uVar1 = list->unicode;
        if ((0x9f < uVar1) && (uVar1 < 0x100)) {
          *(char **)(((uint)uVar1 - 0xa0) * 4 + (int)__ptr) = list->replace_str;
        }
        list = list + 1;
      }
      local_48 = (char **)malloc(0x1c0);
      if (local_48 == (char **)0x0) {
        if (__ptr != (void *)0x0) {
          free(__ptr);
        }
        if (__ptr_00 != (void *)0x0) {
          free(__ptr_00);
        }
        local_48 = (char **)0x0;
      }
      else {
        bVar6 = false;
        i = 0;
        p = local_48;
        while (i < 0x70) {
          __s1 = SevenBitApproximations[i];
          pbVar2 = (byte *)ppcVar3[i];
          *p = __s1;
          if (((pbVar2 != (byte *)0x0) && (0x9f < *pbVar2)) && (pbVar2[1] == 0)) {
            if ((*(byte *)(((uint)*pbVar2 - 0xa0) + (int)__ptr_00) < (byte)lowest8) ||
               (((int)*__s1 == (uint)*(byte *)(((uint)*pbVar2 - 0xa0) + (int)__ptr_00) &&
                (__s1[1] == '\0')))) {
              if ((*(int *)(((uint)*pbVar2 - 0xa0) * 4 + (int)__ptr) != 0) &&
                 (iVar5 = strcmp(__s1,*(char **)(((uint)*pbVar2 - 0xa0) * 4 + (int)__ptr)),
                 iVar5 != 0)) {
                *p = *(char **)(((uint)*pbVar2 - 0xa0) * 4 + (int)__ptr);
                bVar6 = true;
              }
            }
            else {
              if (*(byte *)(((uint)*pbVar2 - 0xa0) + (int)__ptr_00) == *pbVar2) {
                *(byte **)p = pbVar2;
              }
              else {
                dummy[0] = *(char *)(((uint)*pbVar2 - 0xa0) + (int)__ptr_00);
                pHVar4 = HTAtom_for((char *)0x81b2138);
                *p = pHVar4->name;
              }
              bVar6 = true;
            }
          }
          i = i + 1;
          p = p + 1;
        }
        if (__ptr != (void *)0x0) {
          free(__ptr);
        }
        if (__ptr_00 != (void *)0x0) {
          free(__ptr_00);
        }
        if (!bVar6) {
          if (local_48 != (char **)0x0) {
            free(local_48);
          }
          local_48 = (char **)0x0;
        }
      }
    }
  }
  return local_48;
}



int UC_Register_with_LYCharSets(int s,char *UC_MIMEcharset,char *UC_LYNXcharset,int lowest_eightbit)

{
  int *piVar1;
  bool bVar2;
  int iVar3;
  FILE *__stream;
  char **ppcVar4;
  char **repl;
  int found;
  int LYhndl;
  int i;
  
  LYhndl = -1;
  if (LYNumCharsets == 0) {
    i = 0;
    while ((i < 0x3c && (LYchar_set_names[i] != (char *)0x0))) {
      LYNumCharsets = i + 1;
      i = i + 1;
    }
  }
  i = 0;
  while (((iVar3 = LYNumCharsets, i < 0x3c && (LYchar_set_names[i] != (char *)0x0)) && (LYhndl < 0))
        ) {
    if ((LYCharSet_UC[i].MIMEname != (char *)0x0) &&
       (iVar3 = strcmp(UC_MIMEcharset,LYCharSet_UC[i].MIMEname), iVar3 == 0)) {
      LYhndl = i;
    }
    i = i + 1;
  }
  if (LYhndl < 0) {
    bVar2 = false;
    if (0x3b < LYNumCharsets) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
                UC_MIMEcharset,UC_LYNXcharset);
      }
      return -1;
    }
    LYhndl = LYNumCharsets;
    piVar1 = LYlowest_eightbit + LYNumCharsets;
    LYNumCharsets = LYNumCharsets + 1;
    *piVar1 = 999;
    LYCharSets[iVar3] = (char **)0x819afc0;
    LYchar_set_names[iVar3] = UC_LYNXcharset;
    LYchar_set_names[iVar3 + 1] = (char *)0x0;
  }
  else {
    bVar2 = true;
  }
  LYCharSet_UC[LYhndl].UChndl = s;
  LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
  LYCharSet_UC[LYhndl].enc = UCInfo[s].enc;
  LYCharSet_UC[LYhndl].codepage = UCInfo[s].codepage;
  if (lowest_eightbit < LYlowest_eightbit[LYhndl]) {
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
  }
  else {
    if (LYlowest_eightbit[LYhndl] < lowest_eightbit) {
      UCInfo[s].lowest_eight = LYlowest_eightbit[LYhndl];
    }
  }
  if (((!bVar2) && (0 < LYhndl)) &&
     (ppcVar4 = UC_setup_LYCharSets_repl(s,UCInfo[s].lowest_eight), ppcVar4 != (char **)0x0)) {
    LYCharSets[LYhndl] = ppcVar4;
    remember_allocated_LYCharSets[LYhndl] = ppcVar4;
  }
  return LYhndl;
}



void UC_Charset_Setup(char *UC_MIMEcharset,char *UC_LYNXcharset,uchar *unicount,ushort *unitable,
                     int nnuni,unimapdesc_str replacedesc,int lowest_eight,int UC_rawuni,
                     int codepage)

{
  FILE *__stream;
  int iVar1;
  int found;
  int status;
  int i;
  int Gn;
  int s;
  
  found = -1;
  i = 0;
  while ((i < UCNumCharsets && (found < 0))) {
    iVar1 = strcmp(UCInfo[i].MIMEname,UC_MIMEcharset);
    if (iVar1 == 0) {
      found = i;
    }
    i = i + 1;
  }
  if (found < 0) {
    if (0x3b < UCNumCharsets) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_Charset_Setup: Too many.  Ignoring %s/%s.",UC_MIMEcharset,
              UC_LYNXcharset);
      return;
    }
    s = UCNumCharsets;
    UCInfo[UCNumCharsets].MIMEname = UC_MIMEcharset;
  }
  else {
    s = found;
  }
  UCInfo[s].LYNXname = UC_LYNXcharset;
  UCInfo[s].unicount = unicount;
  UCInfo[s].unitable = unitable;
  UCInfo[s].num_uni = nnuni;
  *(undefined4 *)&UCInfo[s].replacedesc = replacedesc._0_4_;
  UCInfo[s].replacedesc.entries = replacedesc.entries;
  UCInfo[s].replacedesc.isdefault = replacedesc.isdefault;
  UCInfo[s].replacedesc.trydefault = replacedesc.trydefault;
  if (replacedesc.isdefault != 0) {
    default_UChndl = s;
  }
  iVar1 = UC_FindGN_byMIME(UC_MIMEcharset);
  if (-1 < iVar1) {
    UC_GNhandles[iVar1] = s;
  }
  UCInfo[s].GN = iVar1;
  if (UC_rawuni == 7) {
    lowest_eight = 0x80;
  }
  UCInfo[s].lowest_eight = lowest_eight;
  UCInfo[s].enc = UC_rawuni;
  UCInfo[s].codepage = codepage;
  iVar1 = UC_Register_with_LYCharSets(s,UC_MIMEcharset,UC_LYNXcharset,lowest_eight);
  UCInfo[s].LYhndl = iVar1;
  UCInfo[s].uc_status = 0;
  if (found < 0) {
    UCNumCharsets = UCNumCharsets + 1;
  }
  return;
}



int UC_NoUctb_Register_with_LYCharSets
              (char *UC_MIMEcharset,char *UC_LYNXcharset,int lowest_eightbit,int UC_rawuni,
              int codepage)

{
  int *piVar1;
  int iVar2;
  FILE *__stream;
  int local_18;
  int LYhndl;
  int i;
  
  if (LYNumCharsets == 0) {
    i = 0;
    while ((i < 0x3c && (LYchar_set_names[i] != (char *)0x0))) {
      LYNumCharsets = i + 1;
      i = i + 1;
    }
  }
  i = 0;
  while( true ) {
    local_18 = LYNumCharsets;
    if ((0x3b < i) || (LYchar_set_names[i] == (char *)0x0)) {
      if (LYNumCharsets < 0x3c) {
        piVar1 = LYlowest_eightbit + LYNumCharsets;
        LYNumCharsets = LYNumCharsets + 1;
        *piVar1 = lowest_eightbit;
        LYCharSets[local_18] = (char **)0x819afc0;
        LYchar_set_names[local_18] = UC_LYNXcharset;
        LYchar_set_names[local_18 + 1] = (char *)0x0;
        LYCharSet_UC[local_18].UChndl = -1;
        LYCharSet_UC[local_18].MIMEname = UC_MIMEcharset;
        LYCharSet_UC[local_18].enc = UC_rawuni;
        LYCharSet_UC[local_18].codepage = codepage;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
                  UC_MIMEcharset,UC_LYNXcharset);
        }
        local_18 = -1;
      }
      return local_18;
    }
    if ((LYCharSet_UC[i].MIMEname != (char *)0x0) &&
       (iVar2 = strcmp(UC_MIMEcharset,LYCharSet_UC[i].MIMEname), iVar2 == 0)) break;
    i = i + 1;
  }
  return -1;
}



void UC_Charset_NoUctb_Setup
               (char *UC_MIMEcharset,char *UC_LYNXcharset,int trydefault,int lowest_eight,
               int UC_rawuni,int codepage)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (UCNumCharsets <= i) {
      if (UC_rawuni == 7) {
        lowest_eight = 0x80;
      }
      if ((trydefault == 0) && (codepage == 0)) {
        codepage = -0xc;
      }
      UC_NoUctb_Register_with_LYCharSets
                (UC_MIMEcharset,UC_LYNXcharset,lowest_eight,UC_rawuni,codepage);
      return;
    }
    iVar1 = strcmp(UCInfo[i].MIMEname,UC_MIMEcharset);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return;
}



void UCInit(void)

{
  UCreset_allocated_LYCharSets();
  UCconsole_map_init();
  UC_Charset_Setup("iso-8859-1","Western (ISO-8859-1)","",dfont_unitable_iso_8859_1,0xc9,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a146000000043)),0xa0,2,0x333);
  UC_Charset_Setup("iso-8859-15","Western (ISO-8859-15)","",dfont_unitable_iso_8859_15,0xbf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,2,0);
  UC_Charset_Setup("cp850","Western (cp850)","",dfont_unitable_cp850,0xf7,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x819c1a000000008)),0x80,1,0x352);
  UC_Charset_Setup("windows-1252","Western (windows-1252)","",dfont_unitable_windows_1252,0xe5,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x819c08000000009)),0x80,1,0x4e4);
  UC_Charset_Setup("cp437","IBM PC US codepage (cp437)","",dfont_unitable_cp437,0xf7,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x819c0e00000000c)),0x80,1,0x1b5);
  UC_Charset_Setup("dec-mcs","DEC Multinational","",dfont_unitable_dec_mcs,0xb0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a13c000000011)),0xa1,2,0);
  UC_Charset_Setup("macintosh","Macintosh (8 bit)","",dfont_unitable_macintosh,0xe2,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a18400000000e)),0x80,1,0);
  UC_Charset_Setup("next","NeXT character set","",dfont_unitable_next,0xde,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0);
  UC_Charset_Setup("hp-roman8","HP Roman8","",dfont_unitable_hp_roman8,0xbe,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,1,0);
  UC_Charset_NoUctb_Setup("euc-cn","Chinese",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("euc-jp","Japanese (EUC-JP)",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("shift_jis","Japanese (Shift_JIS)",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("euc-kr","Korean",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("big5","Taipei (Big5)",1,0x80,5,0);
  UC_Charset_Setup("viscii","Vietnamese (VISCII)","",dfont_unitable_viscii,0x8e,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a8f6000000008)),0x80,3,0);
  UC_Charset_Setup("us-ascii","7 bit approximations (US-ASCII)","",dfont_unitable,0x268,
                   (unimapdesc_str)ZEXT1216(CONCAT48(1,0x819c22000000a32)),999,0,0);
  UC_Charset_NoUctb_Setup("x-transparent","Transparent",0,0x80,1,0);
  UC_Charset_Setup("iso-8859-2","Eastern European (ISO-8859-2)","",dfont_unitable_iso_8859_2,0xd1,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a168000000007)),0xa0,2,0x390);
  UC_Charset_Setup("cp852","Eastern European (cp852)","",dfont_unitable_cp852,0xfb,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x819c1e000000007)),0x80,1,0x354);
  UC_Charset_Setup("windows-1250","Eastern European (windows-1250)","",dfont_unitable_windows_1250,
                   0xeb,(unimapdesc_str)CONCAT412(1,ZEXT812(0x819c04000000008)),0x80,1,0x4e2);
  UC_Charset_Setup("iso-8859-3","Latin 3 (ISO-8859-3)","",dfont_unitable_iso_8859_3,0xb8,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,2,0x391);
  UC_Charset_Setup("iso-8859-4","Latin 4 (ISO-8859-4)","",dfont_unitable_iso_8859_4,0x61,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,2,0x392);
  UC_Charset_Setup("iso-8859-13","Baltic Rim (ISO-8859-13)","",dfont_unitable_iso_8859_13,0xbf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,2,0);
  UC_Charset_Setup("cp775","Baltic Rim (cp775)","",dfont_unitable_cp775,0xdf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x307);
  UC_Charset_Setup("windows-1257","Baltic Rim (windows-1257)","",dfont_unitable_windows_1257,0xd3,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x4e9);
  UC_Charset_Setup("iso-8859-5","Cyrillic (ISO-8859-5)","",dfont_unitable_iso_8859_5,0xd0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a16c000000004)),0xa0,2,0x393);
  UC_Charset_Setup("cp866","Cyrillic (cp866)","",dfont_unitable_cp866,0xe0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x362);
  UC_Charset_Setup("windows-1251","Cyrillic (windows-1251)","",dfont_unitable_windows_1251,0xde,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x4e3);
  UC_Charset_Setup("koi8-r","Cyrillic (KOI8-R)","",dfont_unitable_koi8_r,0xef,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x36e);
  UC_Charset_Setup("iso-8859-6","Arabic (ISO-8859-6)","",dfont_unitable_iso_8859_6,0x92,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,2,0x441);
  UC_Charset_Setup("cp864","Arabic (cp864)","",dfont_unitable_cp864,0xda,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x360);
  UC_Charset_Setup("windows-1256","Arabic (windows-1256)","",dfont_unitable_windows_1256,0xdf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x4e8);
  UC_Charset_Setup("iso-8859-14","Celtic (ISO-8859-14)","",dfont_unitable_iso_8859_14,0xbf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0xa0,2,0);
  UC_Charset_Setup("iso-8859-7","Greek (ISO-8859-7)","",dfont_unitable_iso_8859_7,0xdc,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a16e000000006)),0xa0,2,0x32d);
  UC_Charset_Setup("cp737","Greek (cp737)","",dfont_unitable_cp737,0xe7,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x819c14000000009)),0x80,1,0x2e1);
  UC_Charset_Setup("cp869","Greek2 (cp869)","",dfont_unitable_cp869,0xd9,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x86,1,0x365);
  UC_Charset_Setup("windows-1253","Greek (windows-1253)","",dfont_unitable_windows_1253,0xd0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x4e5);
  UC_Charset_Setup("iso-8859-8","Hebrew (ISO-8859-8)","",dfont_unitable_iso_8859_8,0x9b,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a172000000016)),0xa0,2,0x394);
  UC_Charset_Setup("cp862","Hebrew (cp862)","",dfont_unitable_cp862,0xe0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x35e);
  UC_Charset_Setup("windows-1255","Hebrew (windows-1255)","",dfont_unitable_windows_1255,200,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x4e7);
  UC_Charset_Setup("iso-8859-9","Turkish (ISO-8859-9)","",dfont_unitable_iso_8859_9,0xcd,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a17e000000008)),0xa0,2,0x398);
  UC_Charset_Setup("cp857","Turkish (cp857)","",dfont_unitable_cp857,0xdd,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x359);
  UC_Charset_Setup("iso-8859-10","North European (ISO-8859-10)","",dfont_unitable_iso_8859_10,0xbf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0x81a182000000001)),0xa0,2,0);
  UC_Charset_NoUctb_Setup("utf-8","UNICODE (UTF-8)",0,0x80,7,-4);
  UC_Charset_Setup("mnemonic+ascii+0","RFC 1345 w/o Intro","",dfont_unitable_mnemonic_ascii_0,0,
                   (unimapdesc_str)ZEXT816(0x81a52a000000795),999,0,0);
  UC_Charset_Setup("mnemonic","RFC 1345 Mnemonic","",dfont_unitable_mnemonic,0,
                   (unimapdesc_str)ZEXT816(0x81a18c00000073b),999,0,0);
  UC_Charset_Setup("cp866u","Ukrainian Cyrillic (cp866u)","",dfont_unitable_cp866u,0xe0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0);
  UC_Charset_Setup("koi8-u","Ukrainian Cyrillic (KOI8-U)","",dfont_unitable_koi8_u,0xe0,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0);
  UC_Charset_Setup("ptcp154","Cyrillic-Asian (PT154)","",dfont_unitable_ptcp154,0xdf,
                   (unimapdesc_str)CONCAT412(1,ZEXT812(0)),0x80,1,0x604);
  LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
  US_ASCII = UCGetLYhndl_byMIME("us-ascii");
  UTF8_handle = UCGetLYhndl_byMIME("utf-8");
  TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
  return;
}



int safeUCGetLYhndl_byMIME(char *value)

{
  FILE *__stream;
  int i;
  
  i = UCGetLYhndl_byMIME(value);
  if ((i == -1) && (i = LATIN1, WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n");
  }
  return i;
}



void LYFindLocaleCharset(void)

{
  bool bVar1;
  FILE *__stream;
  char *value_00;
  int iVar2;
  int value;
  char *name;
  BOOLEAN found;
  
  bVar1 = false;
  if (WWW_TraceFlag != '\0') {
    iVar2 = (int)LYLocaleCharset;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYFindLocaleCharset(%d)\n",iVar2);
  }
  value_00 = nl_langinfo(0xe);
  if (value_00 == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Cannot find a MIME name for locale\n");
    }
  }
  else {
    iVar2 = UCGetLYhndl_byMIME(value_00);
    if (iVar2 < 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Cannot find a handle for MIME name \"%s\"\n",value_00);
      }
    }
    else {
      bVar1 = true;
      linedrawing_char_set = iVar2;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Found name \"%s\" -> %d\n",value_00,iVar2);
      }
    }
  }
  if ((bVar1) && (LYLocaleCharset != '\0')) {
    current_char_set = linedrawing_char_set;
  }
  return;
}



BOOLEAN UCCanUniTranslateFrom(int from)

{
  int iVar1;
  BOOLEAN local_5;
  
  if (from < 0) {
    local_5 = '\0';
  }
  else {
    iVar1 = strcmp(LYCharSet_UC[from].MIMEname,"x-transparent");
    if (iVar1 == 0) {
      local_5 = '\0';
    }
    else {
      local_5 = '\x01';
    }
  }
  return local_5;
}



BOOLEAN UCCanTranslateUniTo(int to)

{
  return (BOOLEAN)(-1 < to);
}



BOOLEAN UCCanTranslateFromTo(int from,int to)

{
  char *__s1;
  char *__s1_00;
  BOOLEAN BVar1;
  int iVar2;
  char *toname;
  char *fromname;
  
  if (from == to) {
    return '\x01';
  }
  if ((from < 0) || (to < 0)) {
    return '\0';
  }
  if (from == LATIN1) {
    BVar1 = UCCanTranslateUniTo(to);
    return BVar1;
  }
  if ((to != LATIN1) && (LYCharSet_UC[to].enc != 7)) {
    __s1 = LYCharSet_UC[from].MIMEname;
    __s1_00 = LYCharSet_UC[to].MIMEname;
    iVar2 = strcmp(__s1,"x-transparent");
    if ((iVar2 == 0) || (iVar2 = strcmp(__s1_00,"x-transparent"), iVar2 == 0)) {
      return '\x01';
    }
    iVar2 = strcmp(__s1,"us-ascii");
    if (iVar2 == 0) {
      return '\x01';
    }
    if (LYCharSet_UC[from].enc == 5) {
      if (LYCharSet_UC[to].enc != 5) {
        return '\0';
      }
      iVar2 = strcmp(__s1_00,"euc-jp");
      if (((iVar2 == 0) || (iVar2 = strcmp(__s1_00,"shift_jis"), iVar2 == 0)) &&
         ((iVar2 = strcmp(__s1,"euc-jp"), iVar2 == 0 ||
          (iVar2 = strcmp(__s1,"shift_jis"), iVar2 == 0)))) {
        return '\x01';
      }
      return '\0';
    }
    return '\x01';
  }
  BVar1 = UCCanUniTranslateFrom(from);
  return BVar1;
}



BOOLEAN UCNeedNotTranslate(int from,int to)

{
  char *__s1;
  int iVar1;
  char *toname;
  char *fromname;
  
  if (from == to) {
    return '\x01';
  }
  if (from < 0) {
    return '\0';
  }
  if (LYCharSet_UC[from].enc == 0) {
    return '\x01';
  }
  __s1 = LYCharSet_UC[from].MIMEname;
  iVar1 = strcmp(__s1,"x-transparent");
  if ((iVar1 == 0) || (iVar1 = strcmp(__s1,"us-ascii"), iVar1 == 0)) {
    return '\x01';
  }
  if (to < 0) {
    return '\0';
  }
  if ((to == LATIN1) && (((uint)(&LYCharSet_UC[0].MIMEname)[(from * 2 + 1) * 4] & 1) != 0)) {
    return '\x01';
  }
  iVar1 = strcmp(LYCharSet_UC[to].MIMEname,"x-transparent");
  if (iVar1 == 0) {
    return '\x01';
  }
  if (LYCharSet_UC[to].enc != 7) {
    if ((from == LATIN1) && (((uint)(&LYCharSet_UC[0].MIMEname)[(from * 2 + 1) * 4] & 2) != 0)) {
      return '\x01';
    }
    if (LYCharSet_UC[from].enc != 5) {
      return '\0';
    }
    if (HTCJK != NOCJK) {
      if ((HTCJK == JAPANESE) &&
         ((iVar1 = strcmp(__s1,"euc-jp"), iVar1 == 0 ||
          (iVar1 = strcmp(__s1,"shift_jis"), iVar1 == 0)))) {
        return '\x01';
      }
      return '\0';
    }
    return '\0';
  }
  return '\0';
}



void UCSetTransParams(UCTransParams *pT,int cs_in,LYUCcharset *p_in,int cs_out,LYUCcharset *p_out)

{
  char *pcVar1;
  char *pcVar2;
  bool bVar3;
  BOOLEAN BVar4;
  int iVar5;
  int iVar6;
  FILE *__stream;
  BOOLEAN local_48;
  BOOLEAN local_44;
  BOOLEAN local_40;
  BOOLEAN local_38;
  BOOLEAN local_34;
  BOOLEAN local_2c;
  BOOLEAN local_28;
  BOOLEAN local_24;
  BOOLEAN use_ucs;
  BOOLEAN intm_ucs;
  
  if (WWW_TraceFlag != '\0') {
    iVar5 = UCGetLYhndl_byMIME(p_out->MIMEname);
    pcVar1 = p_out->MIMEname;
    iVar6 = UCGetLYhndl_byMIME(p_in->MIMEname);
    pcVar2 = p_in->MIMEname;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"UCSetTransParams: from %s(%d) to %s(%d)\n",pcVar2,iVar6,pcVar1,iVar5);
  }
  pT->trans_C0_to_uni = '\0';
  iVar5 = strcmp(p_in->MIMEname,"x-transparent");
  if ((iVar5 == 0) || (iVar5 = strcmp(p_out->MIMEname,"x-transparent"), iVar5 == 0)) {
    local_48 = '\x01';
  }
  else {
    local_48 = '\0';
  }
  pT->transp = local_48;
  if (pT->transp == '\0') {
    if ((p_in->enc == 5) && (HTCJK != NOCJK)) {
      local_40 = '\x01';
    }
    else {
      local_40 = '\0';
    }
    pT->do_cjk = local_40;
    *(bool *)&pT->decode_utf8 = p_in->enc == 7;
    *(bool *)&pT->output_utf8 = p_out->enc == 7;
    if (pT->do_cjk == '\0') {
      if (((cs_in == LATIN1) || (pT->decode_utf8 != '\0')) || ((p_in->codepoints & 5U) != 0)) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
      if ((bVar3) || (BVar4 = UCCanUniTranslateFrom(cs_in), BVar4 == '\0')) {
        local_38 = '\0';
      }
      else {
        local_38 = '\x01';
      }
      pT->trans_to_uni = local_38;
      if ((pT->trans_to_uni == '\0') || (p_in->enc != 3)) {
        local_34 = '\0';
      }
      else {
        local_34 = '\x01';
      }
      pT->trans_C0_to_uni = local_34;
      *(bool *)&pT->repl_translated_C0 = p_out->enc == 3;
      pT->strip_raw_char_in = '\0';
      if ((bVar3) || (pT->trans_to_uni != '\0')) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
      *(bool *)&pT->do_8bitraw = !bVar3;
      if ((bVar3) || ((p_in->like8859 & 0x80U) != 0)) {
        local_2c = '\0';
      }
      else {
        local_2c = '\x01';
      }
      pT->pass_160_173_raw = local_2c;
      if (((pT->output_utf8 == '\0') && (cs_in == cs_out)) && (pT->trans_C0_to_uni == '\0')) {
        local_28 = '\x01';
      }
      else {
        local_28 = '\0';
      }
      pT->use_raw_char_in = local_28;
      if (((bVar3) && (pT->do_8bitraw == '\0')) &&
         ((pT->use_raw_char_in == '\0' && (BVar4 = UCCanTranslateUniTo(cs_out), BVar4 != '\0')))) {
        local_24 = '\x01';
      }
      else {
        local_24 = '\0';
      }
      pT->trans_from_uni = local_24;
      return;
    }
    pT->trans_to_uni = '\0';
    pT->do_8bitraw = '\0';
    pT->pass_160_173_raw = '\x01';
    pT->use_raw_char_in = '\0';
    pT->repl_translated_C0 = '\0';
    pT->trans_from_uni = '\0';
    return;
  }
  pT->do_cjk = '\0';
  pT->decode_utf8 = '\0';
  pT->output_utf8 = '\0';
  pT->do_8bitraw = '\x01';
  pT->use_raw_char_in = '\x01';
  pT->strip_raw_char_in = '\0';
  pT->pass_160_173_raw = '\x01';
  *(bool *)&pT->repl_translated_C0 = p_out->enc == 3;
  if ((p_in->enc == 3) || (p_out->enc == 3)) {
    local_44 = '\x01';
  }
  else {
    local_44 = '\0';
  }
  pT->trans_C0_to_uni = local_44;
  return;
}



void UCTransParams_clear(UCTransParams *pT)

{
  pT->transp = '\0';
  pT->do_cjk = '\0';
  pT->decode_utf8 = '\0';
  pT->output_utf8 = '\0';
  pT->do_8bitraw = '\0';
  pT->use_raw_char_in = '\0';
  pT->strip_raw_char_in = '\0';
  pT->pass_160_173_raw = '\0';
  pT->trans_to_uni = '\0';
  pT->trans_C0_to_uni = '\0';
  pT->repl_translated_C0 = '\0';
  pT->trans_from_uni = '\0';
  return;
}



// WARNING: Removing unreachable block (ram,0x080f85a7)
// WARNING: Removing unreachable block (ram,0x080f85ad)
// WARNING: Removing unreachable block (ram,0x080f85b4)
// WARNING: Removing unreachable block (ram,0x080f85ba)

void UCSetBoxChars(int cset,int *pvert_out,int *phori_out,int vert_in,int hori_in)

{
  BOOLEAN fix_lines;
  
  *pvert_out = vert_in;
  *phori_out = hori_in;
  return;
}



BOOLEAN UCPutUtf8_charstring(HTStream *target,putc_func_t *myPutc,long code)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  BOOLEAN local_5;
  
  if (code < 0x80) {
    local_5 = '\0';
  }
  else {
    bVar1 = (byte)(code >> 6);
    bVar2 = (byte)code;
    if (code < 0x800) {
      (*myPutc)(target,bVar1 | 0xc0);
      (*myPutc)(target,bVar2 & 0x3f | 0x80);
    }
    else {
      bVar3 = (byte)(code >> 0xc);
      if (code < 0x10000) {
        (*myPutc)(target,bVar3 | 0xe0);
        (*myPutc)(target,bVar1 & 0x3f | 0x80);
        (*myPutc)(target,bVar2 & 0x3f | 0x80);
      }
      else {
        bVar4 = (byte)(code >> 0x12);
        if (code < 0x200000) {
          (*myPutc)(target,bVar4 | 0xf0);
          (*myPutc)(target,bVar3 & 0x3f | 0x80);
          (*myPutc)(target,bVar1 & 0x3f | 0x80);
          (*myPutc)(target,bVar2 & 0x3f | 0x80);
        }
        else {
          bVar5 = (byte)((uint)code >> 0x18);
          if (code < 0x4000000) {
            (*myPutc)(target,bVar5 | 0xf8);
            (*myPutc)(target,bVar4 & 0x3f | 0x80);
            (*myPutc)(target,bVar3 & 0x3f | 0x80);
            (*myPutc)(target,bVar1 & 0x3f | 0x80);
            (*myPutc)(target,bVar2 & 0x3f | 0x80);
          }
          else {
            (*myPutc)(target,(char)bVar5 >> 6 | 0xfc);
            (*myPutc)(target,bVar5 & 0x3f | 0x80);
            (*myPutc)(target,bVar4 & 0x3f | 0x80);
            (*myPutc)(target,bVar3 & 0x3f | 0x80);
            (*myPutc)(target,bVar1 & 0x3f | 0x80);
            (*myPutc)(target,bVar2 & 0x3f | 0x80);
          }
        }
      }
    }
    local_5 = '\x01';
  }
  return local_5;
}



BOOLEAN UCConvertUniToUtf8(UCode_t code,char *buffer)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  BOOLEAN local_15;
  char *ch;
  
  if (buffer == (char *)0x0) {
    local_15 = '\0';
  }
  else {
    if (code < 1) {
      *buffer = '\0';
      local_15 = '\0';
    }
    else {
      bVar1 = (byte)(code >> 6);
      bVar5 = (byte)code;
      if (code < 0x800) {
        *buffer = bVar1 | 0xc0;
        buffer[1] = bVar5 & 0x3f | 0x80;
        buffer[2] = '\0';
      }
      else {
        bVar2 = (byte)(code >> 0xc);
        if (code < 0x10000) {
          *buffer = bVar2 | 0xe0;
          buffer[1] = bVar1 & 0x3f | 0x80;
          buffer[2] = bVar5 & 0x3f | 0x80;
          buffer[3] = '\0';
        }
        else {
          bVar3 = (byte)(code >> 0x12);
          if (code < 0x200000) {
            *buffer = bVar3 | 0xf0;
            buffer[1] = bVar2 & 0x3f | 0x80;
            buffer[2] = bVar1 & 0x3f | 0x80;
            buffer[3] = bVar5 & 0x3f | 0x80;
            buffer[4] = '\0';
          }
          else {
            bVar4 = (byte)((uint)code >> 0x18);
            if (code < 0x4000000) {
              *buffer = bVar4 | 0xf8;
              buffer[1] = bVar3 & 0x3f | 0x80;
              buffer[2] = bVar2 & 0x3f | 0x80;
              buffer[3] = bVar1 & 0x3f | 0x80;
              buffer[4] = bVar5 & 0x3f | 0x80;
              buffer[5] = '\0';
            }
            else {
              *buffer = (char)bVar4 >> 6 | 0xfc;
              buffer[1] = bVar4 & 0x3f | 0x80;
              buffer[2] = bVar3 & 0x3f | 0x80;
              buffer[3] = bVar2 & 0x3f | 0x80;
              buffer[4] = bVar1 & 0x3f | 0x80;
              buffer[5] = bVar5 & 0x3f | 0x80;
              buffer[6] = '\0';
            }
          }
        }
      }
      local_15 = '\x01';
    }
  }
  return local_15;
}



UCode_t UCGetUniFromUtf8String(char **ppuni)

{
  char *pcVar1;
  int local_18;
  int i;
  int utf_count;
  char *p;
  UCode_t uc_out;
  
  uc_out = 0;
  pcVar1 = *ppuni;
  if (**ppuni < '\0') {
    if ((**ppuni & 0x40U) == 0) {
      local_18 = -1;
    }
    else {
      if (((int)*pcVar1 & 0xe0U) == 0xc0) {
        utf_count = 1;
      }
      else {
        if (((int)*pcVar1 & 0xf0U) == 0xe0) {
          utf_count = 2;
        }
        else {
          if (((int)*pcVar1 & 0xf8U) == 0xf0) {
            utf_count = 3;
          }
          else {
            if (((int)*pcVar1 & 0xfcU) == 0xf8) {
              utf_count = 4;
            }
            else {
              if (((int)*pcVar1 & 0xfeU) != 0xfc) {
                return -1;
              }
              utf_count = 5;
            }
          }
        }
      }
      p = *ppuni;
      i = 0;
      while (i < utf_count) {
        p = p + 1;
        if (((int)*p & 0xc0U) != 0x80) {
          return -1;
        }
        i = i + 1;
      }
      pcVar1 = *ppuni;
      switch(utf_count) {
      case 1:
        uc_out = (int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 0x1fU) << 6;
        break;
      case 2:
        uc_out = (int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 0xfU) << 6) << 6
        ;
        break;
      case 3:
        uc_out = (int)pcVar1[3] & 0x3fU |
                 ((int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 7U) << 6) << 6)
                 << 6;
        break;
      case 4:
        uc_out = (int)pcVar1[4] & 0x3fU |
                 ((int)pcVar1[3] & 0x3fU |
                 ((int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 3U) << 6) << 6)
                 << 6) << 6;
        break;
      case 5:
        uc_out = (int)pcVar1[5] & 0x3fU |
                 ((int)pcVar1[4] & 0x3fU |
                 ((int)pcVar1[3] & 0x3fU |
                 ((int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 1U) << 6) << 6)
                 << 6) << 6) << 6;
      }
      *ppuni = pcVar1 + utf_count;
      local_18 = uc_out;
    }
  }
  else {
    local_18 = (int)**ppuni;
  }
  return local_18;
}



void UCChangeTerminalCodepage(int newcs,LYUCcharset *p)

{
  FILE *__stream;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"UCChangeTerminalCodepage: Called, but not implemented!");
  }
  return;
}



void format(char **result,char *fmt,char *parm)

{
  *result = (char *)0x0;
  HTAddParam(result,fmt,1,parm);
  HTEndParam(result,fmt,1);
  return;
}



char * format_command(char *command,char *param)

{
  char *cmdbuf;
  
  cmdbuf = (char *)0x0;
  format(&cmdbuf,command,param);
  return cmdbuf;
}



char * lookup_external(char *param,BOOLEAN only_overriders)

{
  int iVar1;
  FILE *__stream;
  char *Msg;
  int local_44;
  int local_40;
  int old_x;
  int old_y;
  lynx_list_item_type *ptr;
  char **choices;
  char *cmdbuf;
  int length;
  int cur_choice;
  int num_choices;
  int num_matched;
  int num_disabled;
  int pass;
  
  length = 0;
  cmdbuf = (char *)0x0;
  choices = (char **)0x0;
  pass = 0;
  while (pass < 2) {
    num_disabled = 0;
    num_matched = 0;
    num_choices = 0;
    ptr = externals;
    while (ptr != (lynx_list_item_type *)0x0) {
      iVar1 = match_item_by_name(ptr,param,only_overriders);
      if (iVar1 != 0) {
        num_matched = num_matched + 1;
        if (WWW_TraceFlag != '\0') {
          Msg = ptr->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"EXTERNAL: \'%s\' <==> \'%s\'\n",Msg,param);
        }
        if (((no_externals == '\0') || (ptr->always_enabled != 0)) || (only_overriders != '\0')) {
          if (pass == 0) {
            length = length + 1;
          }
          else {
            if ((pass != 0) && (cmdbuf = format_command(ptr->command,param), 1 < length)) {
              choices[num_choices] = cmdbuf;
            }
          }
          num_choices = num_choices + 1;
        }
        else {
          num_disabled = num_disabled + 1;
        }
      }
      ptr = (lynx_list_item_type *)ptr->next;
    }
    if (1 < length) {
      if (pass == 0) {
        choices = (char **)calloc(length + 1,4);
      }
      else {
        choices[num_choices] = (char *)0x0;
      }
    }
    pass = pass + 1;
  }
  if ((num_disabled == 0) || (num_disabled != num_matched)) {
    if (1 < num_choices) {
      if (LYwin == (WINDOW *)0x0) {
        local_44 = -1;
        local_40 = -1;
      }
      else {
        local_44 = (int)LYwin->_cury;
        local_40 = (int)LYwin->_curx;
      }
      iVar1 = LYhandlePopupList(-1,0,local_40,choices,-1,-1,0,'\x01');
      wmove(LYwin,local_44,local_40);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"selected choice %d of %d\n",iVar1,num_choices);
      }
      if (iVar1 < 0) {
        Msg = (char *)gettext("Cancelled!!!");
        HTInfoMsg(Msg);
        cmdbuf = (char *)0x0;
      }
      pass = 0;
      while (choices[pass] != (char *)0x0) {
        if (pass == iVar1) {
          cmdbuf = choices[pass];
        }
        else {
          if (choices[pass] != (char *)0x0) {
            free(choices[pass]);
            choices[pass] = (char *)0x0;
          }
        }
        pass = pass + 1;
      }
      if (choices != (char **)0x0) {
        free(choices);
      }
    }
  }
  else {
    Msg = (char *)gettext("External support is currently disabled.");
    HTUserMsg(Msg);
  }
  return cmdbuf;
}



BOOLEAN run_external(char *param,BOOLEAN only_overriders)

{
  char *Msg;
  BOOLEAN local_19;
  int confirmed;
  char *cmdbuf;
  int redraw_flag;
  BOOLEAN found;
  
  found = '\0';
  if (externals == (lynx_list_item_type *)0x0) {
    local_19 = '\0';
  }
  else {
    Msg = lookup_external(param,only_overriders);
    if ((Msg != (char *)0x0) && (*Msg != '\0')) {
      HTUserMsg(Msg);
      found = '\x01';
      stop_curses();
      fflush(stdout);
      LYSystem(Msg);
      fflush(stdout);
      start_curses();
    }
    if (Msg != (char *)0x0) {
      free(Msg);
    }
    local_19 = found;
  }
  return local_19;
}



BOOLEAN cannot_stat(char *name)

{
  char *fmt;
  char *tmpbuf;
  
  tmpbuf = (char *)0x0;
  fmt = (char *)gettext("Unable to get status of \'%s\'.");
  HTSprintf0(&tmpbuf,fmt,name);
  HTAlert(tmpbuf);
  if (tmpbuf != (char *)0x0) {
    free(tmpbuf);
  }
  return '\0';
}



BOOLEAN ok_stat(char *name,stat *sb)

{
  FILE *__stream;
  int iVar1;
  BOOLEAN local_5;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"testing ok_stat(%s)\n",name);
  }
  iVar1 = stat64(name,(stat64 *)sb);
  if (iVar1 == 0) {
    local_5 = '\x01';
  }
  else {
    local_5 = cannot_stat(name);
  }
  return local_5;
}



BOOLEAN ok_lstat(char *name,stat *sb)

{
  FILE *__stream;
  int iVar1;
  BOOLEAN local_5;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"testing ok_lstat(%s)\n",name);
  }
  iVar1 = lstat64(name,(stat64 *)sb);
  if (iVar1 < 0) {
    local_5 = cannot_stat(name);
  }
  else {
    local_5 = '\x01';
  }
  return local_5;
}



BOOLEAN ok_file_or_dir(stat *sb)

{
  char *Msg;
  BOOLEAN local_5;
  
  if (((sb->st_mode & 0xf000) == 0x4000) || ((sb->st_mode & 0xf000) == 0x8000)) {
    local_5 = '\x01';
  }
  else {
    Msg = (char *)gettext("The selected item is not a file or a directory!  Request ignored.");
    HTAlert(Msg);
    local_5 = '\0';
  }
  return local_5;
}



int LYExecv(char *path,char **argv,char *msg)

{
  FILE *__stream;
  __pid_t __pid;
  char *fmt;
  int *piVar1;
  __pid_t _Var2;
  anon_union_for___u __u_3;
  anon_union_for___u __u_2;
  anon_union_for___u __u_1;
  anon_union_for___u __u;
  int wstatus;
  int pid;
  char *tmpbuf;
  int n;
  int rc;
  
  tmpbuf = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYExecv path=\'%s\'\n",path);
    }
    n = 0;
    while (argv[n] != (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        fmt = argv[n];
        __stream = TraceFP();
        fprintf((FILE *)__stream,"argv[%d] = \'%s\'\n",n,fmt);
      }
      n = n + 1;
    }
  }
  rc = 1;
  stop_curses();
  __pid = fork();
  if (__pid == -1) {
    fmt = (char *)gettext("Unable to %s due to system error!");
    HTSprintf0(&tmpbuf,fmt,msg);
    rc = 0;
  }
  else {
    if (__pid == 0) {
      execv(path,argv);
      LYexit(1);
    }
    do {
      _Var2 = waitpid(__pid,&wstatus,0);
      if (_Var2 != -1) break;
      piVar1 = __errno_location();
    } while (*piVar1 == 4);
    if ((((wstatus & 0x7fU) == 0) && ((int)(wstatus & 0xff00U) >> 8 != 0)) ||
       (('\0' < (char)(((byte)wstatus & 0x7f) + 1) >> 1 && ((wstatus & 0x7fU) != 0)))) {
      fmt = (char *)gettext("Probable failure to %s due to system error!");
      HTSprintf0(&tmpbuf,fmt,msg);
      rc = 0;
    }
  }
  if (rc == 0) {
    LYSleepAlert();
  }
  start_curses();
  if (tmpbuf != (char *)0x0) {
    if (rc == 0) {
      HTAlert(tmpbuf);
    }
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
  }
  return rc;
}



int make_directory(char *path)

{
  char *path_00;
  int iVar1;
  int local_2c;
  int local_28;
  char *args [5];
  char *msg;
  char *program;
  int code;
  
  path_00 = HTGetProgramPath(ppMKDIR);
  if (path_00 == (char *)0x0) {
    iVar1 = mkdir(path,0x1ff);
    if (iVar1 == 0) {
      local_28 = 1;
    }
    else {
      local_28 = -1;
    }
    code = local_28;
  }
  else {
    msg = (char *)0x0;
    HTSprintf0(&msg,"make directory %s",path);
    args[0] = "mkdir";
    args[1] = path;
    args[2] = (char *)0x0;
    iVar1 = LYExecv(path_00,args,msg);
    if (iVar1 < 1) {
      local_2c = -1;
    }
    else {
      local_2c = 1;
    }
    code = local_2c;
    if (msg != (char *)0x0) {
      free(msg);
    }
  }
  return code;
}



int remove_file(char *path)

{
  char *path_00;
  char *fmt;
  int iVar1;
  int local_28;
  char *args [5];
  char *tmpbuf;
  char *program;
  int code;
  
  path_00 = HTGetProgramPath(ppRM);
  if (path_00 == (char *)0x0) {
    iVar1 = remove(path);
    if (iVar1 == 0) {
      local_28 = 1;
    }
    else {
      local_28 = -1;
    }
    code = local_28;
  }
  else {
    tmpbuf = (char *)0x0;
    args[0] = "rm";
    args[1] = "-f";
    args[2] = path;
    args[3] = (char *)0x0;
    fmt = (char *)gettext("remove %s");
    HTSprintf0(&tmpbuf,fmt,path);
    code = LYExecv(path_00,args,tmpbuf);
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
  }
  return code;
}



int remove_directory(char *path)

{
  char *path_00;
  char *fmt;
  int iVar1;
  int local_28;
  char *args [5];
  char *tmpbuf;
  char *program;
  int code;
  
  path_00 = HTGetProgramPath(ppRMDIR);
  if (path_00 == (char *)0x0) {
    iVar1 = rmdir(path);
    if (iVar1 == 0) {
      local_28 = 1;
    }
    else {
      local_28 = -1;
    }
    code = local_28;
  }
  else {
    tmpbuf = (char *)0x0;
    args[0] = "rmdir";
    args[1] = path;
    args[2] = (char *)0x0;
    fmt = (char *)gettext("remove %s");
    HTSprintf0(&tmpbuf,fmt,path);
    code = LYExecv(path_00,args,tmpbuf);
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
  }
  return code;
}



int touch_file(char *path)

{
  char *path_00;
  char *fmt;
  int iVar1;
  FILE *__stream;
  int local_38;
  char *args [5];
  FILE *fp;
  char *msg;
  char *program;
  int code;
  
  path_00 = HTGetProgramPath(ppTOUCH);
  if (path_00 == (char *)0x0) {
    __stream = fopen64(path,"w");
    if (__stream == (FILE *)0x0) {
      code = -1;
    }
    else {
      fclose(__stream);
      code = 1;
    }
  }
  else {
    msg = (char *)0x0;
    fmt = (char *)gettext("touch %s");
    HTSprintf0(&msg,fmt,path);
    args[0] = "touch";
    args[1] = path;
    args[2] = (char *)0x0;
    iVar1 = LYExecv(path_00,args,msg);
    if (iVar1 < 1) {
      local_38 = -1;
    }
    else {
      local_38 = 1;
    }
    code = local_38;
    if (msg != (char *)0x0) {
      free(msg);
    }
  }
  return code;
}



int move_file(char *source,char *target)

{
  char *path;
  char *fmt;
  int iVar1;
  FILE *__stream;
  int local_78;
  char *args [5];
  char *msg;
  char *program;
  int code;
  
  path = HTGetProgramPath(ppMV);
  if (path == (char *)0x0) {
    msg = (char *)0x0;
    iVar1 = stat64(target,(stat64 *)args);
    if ((iVar1 == 0) && (((uint)args[4] & 0xf000) == 0x4000)) {
      path = LYPathLeaf(source);
      HTSprintf0(&msg,"%s/%s",target,path);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"move_file source=%s, target=%s\n",source,target);
      }
      target = msg;
    }
    code = rename(source,target);
    if (code != 0) {
      code = LYCopyFile(source,target);
      if (-1 < code) {
        code = remove(source);
      }
    }
    if (code == 0) {
      code = 1;
    }
    if ((msg != target) && (msg != (char *)0x0)) {
      free(msg);
    }
  }
  else {
    msg = (char *)0x0;
    fmt = (char *)gettext("move %s to %s");
    HTSprintf0(&msg,fmt,source,target);
    args[0] = "mv";
    args[1] = source;
    args[2] = target;
    args[3] = (char *)0x0;
    iVar1 = LYExecv(path,args,msg);
    if (iVar1 < 1) {
      local_78 = -1;
    }
    else {
      local_78 = 1;
    }
    code = local_78;
    if (msg != (char *)0x0) {
      free(msg);
    }
  }
  return code;
}



BOOLEAN not_already_exists(char *name)

{
  int iVar1;
  int *piVar2;
  char *Msg;
  stat dir_info;
  
  iVar1 = stat64(name,(stat64 *)&dir_info);
  if (iVar1 == 0) {
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      Msg = (char *)gettext("There is already a directory with that name!  Request ignored.");
      HTAlert(Msg);
    }
    else {
      if ((dir_info.st_mode & 0xf000) == 0x8000) {
        Msg = (char *)gettext("There is already a file with that name!  Request ignored.");
        HTAlert(Msg);
      }
      else {
        Msg = (char *)gettext("The specified name is already in use!  Request ignored.");
        HTAlert(Msg);
      }
    }
  }
  else {
    piVar2 = __errno_location();
    if (*piVar2 == 2) {
      return '\x01';
    }
    cannot_stat(name);
  }
  return '\0';
}



BOOLEAN dir_has_same_owner(stat *info,int owner)

{
  char *Msg;
  
  if ((info->st_mode & 0xf000) == 0x4000) {
    if (info->st_uid == owner) {
      return '\x01';
    }
    Msg = (char *)gettext("Destination has different owner!  Request denied.");
    HTAlert(Msg);
  }
  else {
    Msg = (char *)gettext("Destination is not a valid directory!  Request denied.");
    HTAlert(Msg);
  }
  return '\0';
}



// WARNING: Removing unreachable block (ram,0x080f9d29)

int remove_tagged(void)

{
  bool bVar1;
  BOOLEAN BVar2;
  BOOLEAN BVar3;
  char *Msg;
  UrlTypes UVar4;
  int iVar5;
  int local_8c;
  char *local_88;
  stat dir_info;
  HTList *tag;
  int count;
  char *testpath;
  char *tmpbuf;
  char *cp;
  int ans;
  BOOLEAN will_clear;
  
  testpath = (char *)0x0;
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    local_8c = 0;
  }
  else {
    Msg = (char *)gettext("Remove all tagged files and directories?");
    BVar2 = HTConfirm(Msg);
    count = 0;
    tag = tagged;
    while (bVar1 = true, BVar2 == '\x01') {
      if ((tag == (HTList *)0x0) || (tag = tag->next, tag == (HTList *)0x0)) {
        local_88 = (char *)0x0;
      }
      else {
        local_88 = (char *)tag->object;
      }
      if (local_88 == (char *)0x0) break;
      UVar4 = is_url(local_88);
      if (UVar4 == FILE_URL_TYPE) {
        testpath = HTnameOfFile_WWW(local_88,'\0','\x01');
        LYTrimPathSep(testpath);
        BVar3 = ok_stat(testpath,&dir_info);
        if (BVar3 == '\0') {
          bVar1 = false;
          break;
        }
        iVar5 = remove_file(testpath);
        if (iVar5 < 1) {
          if (count == 0) {
            count = -1;
          }
          bVar1 = false;
          break;
        }
        count = count + 1;
        if (testpath != (char *)0x0) {
          free(testpath);
          testpath = (char *)0x0;
        }
      }
    }
    if (testpath != (char *)0x0) {
      free(testpath);
    }
    if (bVar1) {
      clear_tags();
    }
    local_8c = count;
  }
  return local_8c;
}



// WARNING: Could not reconcile some variable overlaps

int modify_tagged(char *testpath)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  BOOLEAN BVar6;
  int iVar7;
  char *text;
  size_t sVar8;
  int in_GS_OFFSET;
  int local_4a4;
  char *local_4a0;
  char *local_49c;
  char *local_498;
  stat dir_info;
  ino_t inode;
  dev_t dev;
  char *cp1;
  HTList *tag;
  int count;
  char *srcpath;
  char *savepath;
  int owner;
  char *cp;
  char tmpbuf [1024];
  
  local_498 = testpath;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  srcpath = (char *)0x0;
  count = 0;
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    local_4a4 = 0;
    goto LAB_080fa410;
  }
  mustshow = '\x01';
  text = (char *)gettext("Enter new location for tagged items: ");
  statusline(text);
  tmpbuf[0] = '\0';
  LYgetstr(tmpbuf,0,0x400,NORECALL);
  if (tmpbuf[0] == '\0') {
    local_4a4 = 0;
    goto LAB_080fa410;
  }
  if ((testpath == (char *)0x0) || (*testpath == '\0')) {
LAB_080f9e43:
    if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
      local_4a0 = (char *)0x0;
    }
    else {
      local_4a0 = (char *)tagged->next->object;
    }
    cp = local_4a0;
    local_498 = (char *)0x0;
  }
  else {
    iVar7 = strcmp(testpath,"/");
    if (iVar7 == 0) goto LAB_080f9e43;
    cp = testpath;
  }
  if (local_498 == (char *)0x0) {
    if (cp == (char *)0x0) {
      savepath = HTURLPath_toFile(".",'\x01','\0');
    }
    else {
      text = strip_trailing_slash(cp);
      text = HTParse(".",text,5);
      savepath = HTURLPath_toFile(text,'\x01','\0');
      if (text != (char *)0x0) {
        free(text);
      }
    }
  }
  else {
    iVar7 = strncmp(cp,"file://localhost",0x10);
    if (iVar7 == 0) {
      cp = cp + 0x10;
    }
    else {
      if ((*cp == 'f') || (*cp == 'F')) {
        iVar7 = strncasecomp(cp,"file:",5);
        if (iVar7 == 0) {
          cp = cp + 5;
        }
      }
    }
    savepath = HTURLPath_toFile(cp,'\x01','\0');
  }
  BVar6 = ok_stat(savepath,&dir_info);
  uVar5 = dir_info.st_ino._4_4_;
  uVar4 = (uint)dir_info.st_ino;
  uVar3 = dir_info.st_dev._4_4_;
  uVar2 = (uint)dir_info.st_dev;
  if (BVar6 == '\0') {
    if (savepath != (char *)0x0) {
      free(savepath);
      savepath = (char *)0x0;
    }
    local_4a4 = 0;
  }
  else {
    if ((tmpbuf[0] == '~') && (tmpbuf[1] == '/')) {
      cp1 = (char *)0x0;
      text = Home_Dir();
      HTSACopy(&cp1,text);
      HTSACat(&cp1,tmpbuf + 1);
      sVar8 = strlen(cp1);
      if (0x3ff < sVar8) {
        text = (char *)gettext("Path too long");
        HTAlert(text);
        if (savepath != (char *)0x0) {
          free(savepath);
          savepath = (char *)0x0;
        }
        if (cp1 != (char *)0x0) {
          free(cp1);
          cp1 = (char *)0x0;
        }
        local_4a4 = 0;
        goto LAB_080fa410;
      }
      LYstrncpy(tmpbuf,cp1,0x3ff);
      if (cp1 != (char *)0x0) {
        free(cp1);
        cp1 = (char *)0x0;
      }
    }
    if (tmpbuf[0] == '/') {
      HTSACopy(&savepath,tmpbuf);
    }
    else {
      LYAddPathSep(&savepath);
      HTSACat(&savepath,tmpbuf);
    }
    BVar6 = ok_stat(savepath,&dir_info);
    if (BVar6 == '\0') {
      if (savepath != (char *)0x0) {
        free(savepath);
        savepath = (char *)0x0;
      }
      local_4a4 = 0;
    }
    else {
      if ((((uint)dir_info.st_dev ^ uVar2 | dir_info.st_dev._4_4_ ^ uVar3) == 0) &&
         (((uint)dir_info.st_ino ^ uVar4 | dir_info.st_ino._4_4_ ^ uVar5) == 0)) {
        text = (char *)gettext("Source and destination are the same location - request ignored!");
        HTAlert(text);
        if (savepath != (char *)0x0) {
          free(savepath);
          savepath = (char *)0x0;
        }
        local_4a4 = 0;
      }
      else {
        BVar6 = dir_has_same_owner(&dir_info,dir_info.st_uid);
        if (BVar6 != '\0') {
          count = 0;
          tag = tagged;
          while( true ) {
            if ((tag == (HTList *)0x0) || (tag = tag->next, tag == (HTList *)0x0)) {
              local_49c = (char *)0x0;
            }
            else {
              local_49c = (char *)tag->object;
            }
            if (local_49c == (char *)0x0) goto LAB_080fa3b0;
            srcpath = HTnameOfFile_WWW(local_49c,'\0','\x01');
            iVar7 = move_file(srcpath,savepath);
            if (iVar7 < 0) break;
            if (srcpath != (char *)0x0) {
              free(srcpath);
              srcpath = (char *)0x0;
            }
            count = count + 1;
          }
          if (count == 0) {
            count = -1;
          }
LAB_080fa3b0:
          clear_tags();
          if (srcpath != (char *)0x0) {
            free(srcpath);
          }
        }
        if (savepath != (char *)0x0) {
          free(savepath);
          savepath = (char *)0x0;
        }
        local_4a4 = count;
      }
    }
  }
LAB_080fa410:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_4a4;
}



int modify_name(char *testpath)

{
  int iVar1;
  BOOLEAN BVar2;
  char *name;
  char *src;
  int in_GS_OFFSET;
  int local_27c;
  stat dir_info;
  int code;
  char *newpath;
  char *cp;
  char tmpbuf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  newpath = (char *)0x0;
  code = 0;
  name = strip_trailing_slash(testpath);
  BVar2 = ok_stat(name,&dir_info);
  if (BVar2 != '\0') {
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      cp = (char *)gettext("Enter new name for directory: ");
    }
    else {
      if ((dir_info.st_mode & 0xf000) != 0x8000) {
        BVar2 = ok_file_or_dir(&dir_info);
        local_27c = (int)BVar2;
        goto LAB_080fa665;
      }
      cp = (char *)gettext("Enter new name for file: ");
    }
    src = LYPathLeaf(name);
    LYstrncpy(tmpbuf,src,0x1ff);
    src = get_filename(cp,tmpbuf,0x200);
    if (src == (char *)0x0) {
      local_27c = 0;
      goto LAB_080fa665;
    }
    src = LYLastPathSep(tmpbuf);
    if (src == (char *)0x0) {
      if (tmpbuf[0] != '\0') {
        src = LYLastPathSep(name);
        if (src == (char *)0x0) {
          HTSACopy(&newpath,tmpbuf);
        }
        else {
          HTSprintf0(&newpath,"%.*s%s",src + (1 - (int)name),name,tmpbuf);
        }
        BVar2 = not_already_exists(newpath);
        if (BVar2 != '\0') {
          code = move_file(name,newpath);
        }
        if (newpath != (char *)0x0) {
          free(newpath);
          newpath = (char *)0x0;
        }
      }
    }
    else {
      name = (char *)gettext("Illegal character (path-separator) found! Request ignored.");
      HTAlert(name);
    }
  }
  local_27c = code;
LAB_080fa665:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_27c;
}



// WARNING: Could not reconcile some variable overlaps

int modify_location(char *testpath)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  BOOLEAN BVar6;
  char *name;
  char *pcVar7;
  int in_GS_OFFSET;
  int local_49c;
  stat dir_info;
  ino_t inode;
  dev_t dev;
  int code;
  char *savepath;
  char *newpath;
  int owner;
  char *sp;
  char *cp;
  char tmpbuf [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  newpath = (char *)0x0;
  savepath = (char *)0x0;
  code = 0;
  name = strip_trailing_slash(testpath);
  BVar6 = ok_stat(name,&dir_info);
  if (BVar6 == '\0') {
    local_49c = 0;
  }
  else {
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      pcVar7 = HTGetProgramPath(ppMV);
      if (pcVar7 == (char *)0x0) {
        name = (char *)gettext("Could not access directory.");
        HTAlert(name);
        local_49c = 0;
        goto LAB_080faad9;
      }
      cp = (char *)gettext("Enter new location for directory: ");
    }
    else {
      if ((dir_info.st_mode & 0xf000) != 0x8000) {
        BVar6 = ok_file_or_dir(&dir_info);
        local_49c = (int)BVar6;
        goto LAB_080faad9;
      }
      cp = (char *)gettext("Enter new location for file: ");
    }
    LYstrncpy(tmpbuf,name,0x3ff);
    pcVar7 = LYPathLeaf(tmpbuf);
    *pcVar7 = '\0';
    pcVar7 = get_filename(cp,tmpbuf,0x400);
    if (pcVar7 == (char *)0x0) {
      local_49c = 0;
    }
    else {
      if (tmpbuf[0] != '\0') {
        HTSACopy(&savepath,name);
        HTSACopy(&newpath,name);
        if ((tmpbuf[0] == '~') && ((tmpbuf[1] == '\0' || (tmpbuf[1] == '/')))) {
          name = Home_Dir();
          HTSACopy(&newpath,name);
          HTSACat(&newpath,tmpbuf + 1);
          LYstrncpy(tmpbuf,newpath,0x3ff);
        }
        BVar6 = LYisAbsPath(tmpbuf);
        if (BVar6 == '\0') {
          name = LYLastPathSep(newpath);
          if (name == (char *)0x0) {
            name = (char *)gettext("Unexpected failure - unable to find trailing path separator");
            HTAlert(name);
            if (newpath != (char *)0x0) {
              free(newpath);
              newpath = (char *)0x0;
            }
            if (savepath != (char *)0x0) {
              free(savepath);
              savepath = (char *)0x0;
            }
            local_49c = 0;
            goto LAB_080faad9;
          }
          name[1] = '\0';
          HTSACat(&newpath,tmpbuf);
        }
        else {
          HTSACopy(&newpath,tmpbuf);
        }
        uVar5 = dir_info.st_ino._4_4_;
        uVar4 = (uint)dir_info.st_ino;
        uVar3 = dir_info.st_dev._4_4_;
        uVar2 = (uint)dir_info.st_dev;
        BVar6 = ok_stat(newpath,&dir_info);
        if (BVar6 == '\0') {
          code = 0;
        }
        else {
          if ((((uint)dir_info.st_dev ^ uVar2 | dir_info.st_dev._4_4_ ^ uVar3) == 0) &&
             (((uint)dir_info.st_ino ^ uVar4 | dir_info.st_ino._4_4_ ^ uVar5) == 0)) {
            name = (char *)gettext("Source and destination are the same location!  Request ignored!"
                                  );
            HTAlert(name);
            code = 0;
          }
          else {
            BVar6 = dir_has_same_owner(&dir_info,dir_info.st_uid);
            if (BVar6 != '\0') {
              code = move_file(savepath,newpath);
            }
          }
        }
        if (newpath != (char *)0x0) {
          free(newpath);
          newpath = (char *)0x0;
        }
        if (savepath != (char *)0x0) {
          free(savepath);
          savepath = (char *)0x0;
        }
      }
      local_49c = code;
    }
  }
LAB_080faad9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_49c;
}



int local_modify(DocInfo *doc,char **newpath)

{
  int iVar1;
  char *text;
  int __c;
  size_t sVar2;
  int in_GS_OFFSET;
  int local_220;
  int count;
  char *cp;
  int ans;
  char testpath [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    if ((doc->link < 0) || (nlinks < doc->link)) {
      local_220 = 0;
    }
    else {
      mustshow = '\x01';
      text = (char *)gettext("Modify name, location, or permission (n, l, or p): ");
      statusline(text);
      __c = LYgetch_single();
      text = strchr("NLP",__c);
      if (text != (char *)0x0) {
        text = HTnameOfFile_WWW(links[doc->link].lname,'\0','\x01');
        sVar2 = strlen(text);
        if (0x1ff < sVar2) {
          if (text != (char *)0x0) {
            free(text);
          }
          local_220 = 0;
          goto LAB_080fade0;
        }
        LYstrncpy(testpath,text,0x1ff);
        if (text != (char *)0x0) {
          free(text);
        }
        if (__c == 0x4e) {
          local_220 = modify_name(testpath);
          goto LAB_080fade0;
        }
        if (__c == 0x4c) {
          __c = modify_location(testpath);
          if (__c != 0) {
            if (doc->link == nlinks + -1) {
              doc->link = doc->link + -1;
            }
            local_220 = 1;
            goto LAB_080fade0;
          }
        }
        else {
          if (__c == 0x50) {
            local_220 = permit_location((char *)0x0,testpath,newpath);
            goto LAB_080fade0;
          }
          text = (char *)gettext("This feature not yet implemented!");
          HTAlert(text);
        }
      }
      local_220 = 0;
    }
  }
  else {
    text = HTnameOfFile_WWW(doc->address,'\0','\0');
    local_220 = modify_tagged(text);
    if (text != (char *)0x0) {
      free(text);
    }
    if ((nlinks - local_220) + -1 < doc->link) {
      doc->link = (nlinks - local_220) + -1;
    }
    doc->link = doc->link & ~(doc->link >> 0x1f);
  }
LAB_080fade0:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_220;
}



int create_file(char *current_location)

{
  int iVar1;
  BOOLEAN BVar2;
  char *prompt;
  int in_GS_OFFSET;
  char *local_21c;
  char *testpath;
  int code;
  char tmpbuf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  code = 0;
  testpath = (char *)0x0;
  tmpbuf[0] = '\0';
  prompt = (char *)gettext("Enter name of file to create: ");
  prompt = get_filename(prompt,tmpbuf,0x200);
  if (prompt != (char *)0x0) {
    prompt = strstr(tmpbuf,"//");
    if (prompt == (char *)0x0) {
      if (tmpbuf[0] != '\0') {
        if ((no_dotfiles == '\0') && (show_dotfiles != '\0')) {
          local_21c = "~/";
        }
        else {
          local_21c = ".~/";
        }
        prompt = strchr(local_21c,(int)tmpbuf[0]);
        if (prompt == (char *)0x0) {
          HTSACopy(&testpath,current_location);
          LYAddPathSep(&testpath);
          HTSACat(&testpath,tmpbuf);
          BVar2 = not_already_exists(testpath);
          if (BVar2 != '\0') {
            code = touch_file(testpath);
          }
          if (testpath != (char *)0x0) {
            free(testpath);
            testpath = (char *)0x0;
          }
        }
      }
    }
    else {
      prompt = (char *)gettext("Illegal redirection \"//\" found! Request ignored.");
      HTAlert(prompt);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



int create_directory(char *current_location)

{
  int iVar1;
  BOOLEAN BVar2;
  char *prompt;
  int in_GS_OFFSET;
  char *local_21c;
  char *testpath;
  int code;
  char tmpbuf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  code = 0;
  testpath = (char *)0x0;
  tmpbuf[0] = '\0';
  prompt = (char *)gettext("Enter name for new directory: ");
  prompt = get_filename(prompt,tmpbuf,0x200);
  if (prompt != (char *)0x0) {
    prompt = strstr(tmpbuf,"//");
    if (prompt == (char *)0x0) {
      if (tmpbuf[0] != '\0') {
        if ((no_dotfiles == '\0') && (show_dotfiles != '\0')) {
          local_21c = "~/";
        }
        else {
          local_21c = ".~/";
        }
        prompt = strchr(local_21c,(int)tmpbuf[0]);
        if (prompt == (char *)0x0) {
          HTSACopy(&testpath,current_location);
          LYAddPathSep(&testpath);
          HTSACat(&testpath,tmpbuf);
          BVar2 = not_already_exists(testpath);
          if (BVar2 != '\0') {
            code = make_directory(testpath);
          }
          if (testpath != (char *)0x0) {
            free(testpath);
            testpath = (char *)0x0;
          }
        }
      }
    }
    else {
      prompt = (char *)gettext("Illegal redirection \"//\" found! Request ignored.");
      HTAlert(prompt);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



int local_create(DocInfo *doc)

{
  int iVar1;
  char *__s;
  size_t sVar2;
  int iVar3;
  int in_GS_OFFSET;
  int local_21c;
  char *cp;
  int ans;
  char testpath [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __s = HTnameOfFile_WWW(doc->address,'\0','\x01');
  sVar2 = strlen(__s);
  if (sVar2 < 0x200) {
    strcpy(testpath,__s);
    if (__s != (char *)0x0) {
      free(__s);
    }
    mustshow = '\x01';
    __s = (char *)gettext("Create file or directory (f or d): ");
    statusline(__s);
    iVar3 = LYgetch_single();
    if (iVar3 == 0x46) {
      local_21c = create_file(testpath);
    }
    else {
      if (iVar3 == 0x44) {
        local_21c = create_directory(testpath);
      }
      else {
        local_21c = 0;
      }
    }
  }
  else {
    if (__s != (char *)0x0) {
      free(__s);
    }
    local_21c = 0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_21c;
}



int remove_single(char *testpath)

{
  bool bVar1;
  BOOLEAN BVar2;
  size_t sVar3;
  char *fmt;
  int local_7c;
  int local_78;
  stat dir_info;
  char *tmpbuf;
  char *cp;
  int code;
  BOOLEAN is_directory;
  
  code = 0;
  tmpbuf = (char *)0x0;
  bVar1 = false;
  BVar2 = ok_lstat(testpath,&dir_info);
  if (BVar2 == '\0') {
    local_7c = 0;
  }
  else {
    cp = LYLastPathSep(testpath);
    if (cp == (char *)0x0) {
      cp = testpath;
    }
    else {
      cp = cp + 1;
    }
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      sVar3 = strlen(cp);
      if (sVar3 < 0x25) {
        fmt = (char *)gettext("Remove directory \'%s\'?");
        HTSprintf0(&tmpbuf,fmt,cp);
      }
      else {
        fmt = (char *)gettext("Remove directory?");
        HTSprintf0(&tmpbuf,fmt);
      }
      bVar1 = true;
    }
    else {
      if ((dir_info.st_mode & 0xf000) == 0x8000) {
        sVar3 = strlen(cp);
        if (sVar3 < 0x3c) {
          fmt = (char *)gettext("Remove file \'%s\'?");
          HTSprintf0(&tmpbuf,fmt,cp);
        }
        else {
          fmt = (char *)gettext("Remove file?");
          HTSprintf0(&tmpbuf,fmt);
        }
      }
      else {
        if ((dir_info.st_mode & 0xf000) != 0xa000) {
          cannot_stat(testpath);
          if (tmpbuf != (char *)0x0) {
            free(tmpbuf);
          }
          return 0;
        }
        sVar3 = strlen(cp);
        if (sVar3 < 0x32) {
          fmt = (char *)gettext("Remove symbolic link \'%s\'?");
          HTSprintf0(&tmpbuf,fmt,cp);
        }
        else {
          fmt = (char *)gettext("Remove symbolic link?");
          HTSprintf0(&tmpbuf,fmt);
        }
      }
    }
    BVar2 = HTConfirm(tmpbuf);
    if (BVar2 == '\x01') {
      if (bVar1) {
        local_78 = remove_directory(testpath);
      }
      else {
        local_78 = remove_file(testpath);
      }
      code = local_78;
    }
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
    local_7c = code;
  }
  return local_7c;
}



int local_remove(DocInfo *doc)

{
  int iVar1;
  UrlTypes UVar2;
  char *__s;
  size_t sVar3;
  int iVar4;
  int in_GS_OFFSET;
  int local_22c;
  int i;
  int count;
  char *tp;
  char *cp;
  char testpath [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    if ((doc->link < 0) || (nlinks < doc->link)) {
      local_22c = 0;
    }
    else {
      cp = links[doc->link].lname;
      UVar2 = is_url(cp);
      if (UVar2 == FILE_URL_TYPE) {
        __s = HTnameOfFile_WWW(cp,'\0','\x01');
        sVar3 = strlen(__s);
        if (0x1ff < sVar3) {
          if (__s != (char *)0x0) {
            free(__s);
          }
          local_22c = 0;
          goto LAB_080fb6da;
        }
        strcpy(testpath,__s);
        if (__s != (char *)0x0) {
          free(__s);
        }
        sVar3 = strlen(testpath);
        if ((sVar3 != 0) && (*(char *)((int)&cp + sVar3 + 3) == '/')) {
          *(undefined *)((int)&cp + sVar3 + 3) = 0;
        }
        iVar4 = remove_single(testpath);
        if (iVar4 != 0) {
          if (doc->link == nlinks + -1) {
            doc->link = doc->link + -1;
          }
          local_22c = 1;
          goto LAB_080fb6da;
        }
      }
      local_22c = 0;
    }
  }
  else {
    local_22c = remove_tagged();
    if ((nlinks - local_22c) + -1 < doc->link) {
      doc->link = (nlinks - local_22c) + -1;
    }
    doc->link = doc->link & ~(doc->link >> 0x1f);
  }
LAB_080fb6da:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_22c;
}



long permit_bits(char *string_mode)

{
  int iVar1;
  long local_8;
  
  iVar1 = strcmp(string_mode,"IRUSR");
  if (iVar1 == 0) {
    local_8 = 0x100;
  }
  else {
    iVar1 = strcmp(string_mode,"IWUSR");
    if (iVar1 == 0) {
      local_8 = 0x80;
    }
    else {
      iVar1 = strcmp(string_mode,"IXUSR");
      if (iVar1 == 0) {
        local_8 = 0x40;
      }
      else {
        iVar1 = strcmp(string_mode,"IRGRP");
        if (iVar1 == 0) {
          local_8 = 0x20;
        }
        else {
          iVar1 = strcmp(string_mode,"IWGRP");
          if (iVar1 == 0) {
            local_8 = 0x10;
          }
          else {
            iVar1 = strcmp(string_mode,"IXGRP");
            if (iVar1 == 0) {
              local_8 = 8;
            }
            else {
              iVar1 = strcmp(string_mode,"IROTH");
              if (iVar1 == 0) {
                local_8 = 4;
              }
              else {
                iVar1 = strcmp(string_mode,"IWOTH");
                if (iVar1 == 0) {
                  local_8 = 2;
                }
                else {
                  iVar1 = strcmp(string_mode,"IXOTH");
                  if (iVar1 == 0) {
                    local_8 = 1;
                  }
                  else {
                    local_8 = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return local_8;
}



int permit_location(char *destpath,char *srcpath,char **newpath)

{
  int iVar1;
  char tempfile [256];
  BOOLEAN BVar2;
  char *local_210;
  char *path;
  FILE *fp;
  undefined4 uVar3;
  char *__ptr;
  size_t sVar4;
  int iVar5;
  uint uVar6;
  int in_GS_OFFSET;
  int local_1fc;
  char *local_1f8;
  char *local_1f4;
  char *local_1f0;
  char *local_1ec;
  char *local_1e8;
  char *local_1e4;
  char *local_1e0;
  char *local_1dc;
  char *local_1d8;
  char *local_1d4;
  char *local_1d0;
  char *local_1cc;
  char *local_1c8;
  char *local_1c4;
  stat dir_info;
  char *args [5];
  char *tmpbuf;
  long mask;
  char *cr;
  mode_t new_mode;
  char *srcpath_url;
  char *group_name;
  char *user_filename;
  FILE *fp0;
  char *program;
  char *cp;
  char tmpdst [256];
  char amode [10];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (srcpath == (char *)0x0) {
    new_mode = 0;
    if (LYValidPermitFile[0] == '\0') {
      if (LYCursesON == '\0') {
        uVar3 = gettext("Special URL only valid from current File Permission menu!");
        fprintf(stderr,"%s\n",uVar3);
      }
      else {
        local_210 = (char *)gettext("Special URL only valid from current File Permission menu!");
        HTAlert(local_210);
      }
      if (WWW_TraceFlag != '\0') {
        if (destpath == (char *)0x0) {
          local_1c4 = "NULL URL pointer";
        }
        else {
          local_1c4 = destpath;
        }
        fp = TraceFP();
        fprintf((FILE *)fp,"permit_location: called for <%s>.\n",local_1c4);
      }
      local_1fc = 0;
    }
    else {
      cp = destpath;
      while ((*cp != '\0' && (*cp != '?'))) {
        cp = cp + 1;
      }
      if (*cp == '\0') {
        local_1fc = 0;
      }
      else {
        *cp = '\0';
        cp = cp + 1;
        local_210 = HTURLPath_toFile(destpath,'\x01','\0');
        if (local_210 == (char *)0x0) {
          local_1fc = 0;
        }
        else {
          sVar4 = strlen(local_210);
          if (sVar4 < 0x100) {
            strcpy(tmpdst,local_210);
            if (local_210 != (char *)0x0) {
              free(local_210);
            }
            iVar5 = strcmp(tmpdst,LYValidPermitFile);
            if (iVar5 == 0) {
              local_210 = strip_trailing_slash(tmpdst);
              BVar2 = ok_stat(local_210,&dir_info);
              if (BVar2 != '\0') {
                BVar2 = ok_file_or_dir(&dir_info);
                if (BVar2 != '\0') {
                  while (*cp != '\0') {
                    cr = cp;
                    while ((*cr != '\0' && (*cr != '&'))) {
                      cr = cr + 1;
                    }
                    if (*cr != '\0') {
                      *cr = '\0';
                      cr = cr + 1;
                    }
                    iVar5 = strncmp(cp,"mode=",5);
                    if (iVar5 != 0) {
                      local_210 = (char *)gettext("Invalid syntax format.");
                      HTAlert(local_210);
                      local_1fc = 0;
                      goto LAB_080fc443;
                    }
                    uVar6 = permit_bits(cp + 5);
                    if (uVar6 == 0) {
                      local_210 = (char *)gettext("Invalid mode format.");
                      HTAlert(local_210);
                      local_1fc = 0;
                      goto LAB_080fc443;
                    }
                    if (no_change_exec_perms == '\0') {
LAB_080fc288:
                      new_mode = new_mode | uVar6;
                    }
                    else {
                      path = strchr(cp + 5,0x58);
                      if ((path == (char *)0x0) || ((dir_info.st_mode & 0xf000) == 0x4000))
                      goto LAB_080fc288;
                    }
                    cp = cr;
                  }
                  path = HTGetProgramPath(ppCHMOD);
                  if (path == (char *)0x0) {
                    iVar5 = chmod(local_210,new_mode);
                    if (iVar5 < 0) {
                      local_1fc = -1;
                      goto LAB_080fc443;
                    }
                  }
                  else {
                    tmpbuf = (char *)0x0;
                    HTSprintf0(&tmpbuf,"chmod %.4o %s",new_mode,local_210);
                    sprintf(amode,"%.4o",new_mode);
                    args[0] = "chmod";
                    args[1] = amode;
                    args[3] = (char *)0x0;
                    args[2] = local_210;
                    iVar5 = LYExecv(path,args,tmpbuf);
                    if (iVar5 < 1) {
                      if (tmpbuf != (char *)0x0) {
                        free(tmpbuf);
                        tmpbuf = (char *)0x0;
                      }
                      local_1fc = -1;
                      goto LAB_080fc443;
                    }
                    if (tmpbuf != (char *)0x0) {
                      free(tmpbuf);
                      tmpbuf = (char *)0x0;
                    }
                  }
                  LYforce_no_cache = '\x01';
                  local_1fc = 1;
                  goto LAB_080fc443;
                }
              }
              local_1fc = 0;
            }
            else {
              if (LYCursesON == '\0') {
                uVar3 = gettext("Special URL only valid from current File Permission menu!");
                fprintf(stderr,"%s\n",uVar3);
              }
              else {
                local_210 = (char *)gettext(
                                           "Special URL only valid from current File Permission menu!"
                                           );
                HTAlert(local_210);
              }
              if (WWW_TraceFlag != '\0') {
                fp = TraceFP();
                fprintf((FILE *)fp,"permit_location: called for file \'%s\'.\n",tmpdst);
              }
              local_1fc = 0;
            }
          }
          else {
            if (local_210 != (char *)0x0) {
              free(local_210);
            }
            local_1fc = 0;
          }
        }
      }
    }
  }
  else {
    local_210 = strip_trailing_slash(srcpath);
    BVar2 = ok_lstat(local_210,&dir_info);
    if (BVar2 != '\0') {
      BVar2 = ok_file_or_dir(&dir_info);
      if (BVar2 != '\0') {
        path = LYPathLeaf(local_210);
        LYRemoveTemp((char *)&ram0x081a9c00);
        fp = LYOpenTemp((char *)0x81a9c00,".html","w");
        if (fp == (FILE *)0x0) {
          local_210 = (char *)gettext("Unable to open permit options file");
          HTAlert(local_210);
          local_1fc = 0;
        }
        else {
          LYLocalFileToURL(newpath,(char *)0x81a9c00);
          LYRegisterUIPage(*newpath,UIP_PERMIT_OPTIONS);
          local_1e0 = HTAA_GidToName(dir_info.st_gid);
          LYstrncpy(LYValidPermitFile,local_210,0xff);
          uVar3 = gettext("File Permission Options");
          fprintf((FILE *)fp,"<Html><Head>\n<Title>%s</Title>\n</Head>\n<Body>\n",uVar3);
          uVar3 = gettext("Permissions for ");
          fprintf((FILE *)fp,"<H1>%s%s</H1>\n",uVar3,path);
          __ptr = HTEscape(local_210,'\x04');
          local_210 = __ptr;
          fprintf((FILE *)fp,"<Form Action=\"%s//PERMIT_LOCATION%s\">\n","LYNXDIRED:",__ptr);
          if (__ptr != (char *)0x0) {
            free(__ptr);
          }
          uVar3 = gettext("Specify permissions below:");
          fprintf((FILE *)fp,"<Ol><Li>%s<Br><Br>\n",uVar3,local_210);
          uVar3 = gettext("Owner:");
          fprintf((FILE *)fp,"%s:<Br>\n",uVar3);
          if ((dir_info.st_mode & 0x100) == 0) {
            local_1f8 = "";
          }
          else {
            local_1f8 = "checked";
          }
          fprintf((FILE *)fp,"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n"
                  ,local_1f8);
          if ((dir_info.st_mode & 0x80) == 0) {
            local_1f4 = "";
          }
          else {
            local_1f4 = "checked";
          }
          fprintf((FILE *)fp,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",local_1f4
                 );
          if ((no_change_exec_perms == '\0') || ((dir_info.st_mode & 0xf000) == 0x4000)) {
            if ((dir_info.st_mode & 0xf000) == 0x4000) {
              local_1f0 = "Search";
            }
            else {
              local_1f0 = "Execute";
            }
            if ((dir_info.st_mode & 0x40) == 0) {
              local_1ec = "";
            }
            else {
              local_1ec = "checked";
            }
            fprintf((FILE *)fp,"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n"
                    ,local_1ec,local_1f0);
          }
          uVar3 = gettext("Group");
          fprintf((FILE *)fp,"%s %s:<Br>\n",uVar3,local_1e0);
          if ((dir_info.st_mode & 0x20) == 0) {
            local_1e8 = "";
          }
          else {
            local_1e8 = "checked";
          }
          fprintf((FILE *)fp,"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n"
                  ,local_1e8,local_1e0);
          if ((dir_info.st_mode & 0x10) == 0) {
            local_1e4 = "";
          }
          else {
            local_1e4 = "checked";
          }
          fprintf((FILE *)fp,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",local_1e4
                  ,local_1e0);
          if ((no_change_exec_perms == '\0') || ((dir_info.st_mode & 0xf000) == 0x4000)) {
            if ((dir_info.st_mode & 0xf000) == 0x4000) {
              local_1e0 = "Search";
            }
            else {
              local_1e0 = "Execute";
            }
            if ((dir_info.st_mode & 8) == 0) {
              local_1dc = "";
            }
            else {
              local_1dc = "checked";
            }
            fprintf((FILE *)fp,"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n"
                    ,local_1dc,local_1e0);
          }
          uVar3 = gettext("Others:");
          fprintf((FILE *)fp,"%s<Br>\n",uVar3,local_1e0);
          if ((dir_info.st_mode & 4) == 0) {
            local_1d8 = "";
          }
          else {
            local_1d8 = "checked";
          }
          fprintf((FILE *)fp,"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n"
                  ,local_1d8,local_1e0);
          if ((dir_info.st_mode & 2) == 0) {
            local_1d4 = "";
          }
          else {
            local_1d4 = "checked";
          }
          fprintf((FILE *)fp,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",local_1d4
                 );
          if ((no_change_exec_perms == '\0') || ((dir_info.st_mode & 0xf000) == 0x4000)) {
            if ((dir_info.st_mode & 0xf000) == 0x4000) {
              local_1d0 = "Search";
            }
            else {
              local_1d0 = "Execute";
            }
            if ((dir_info.st_mode & 1) == 0) {
              local_1cc = "";
            }
            else {
              local_1cc = "checked";
            }
            fprintf((FILE *)fp,"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n"
                    ,local_1cc,local_1d0);
          }
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            local_1c8 = "directory";
          }
          else {
            local_1c8 = "file";
          }
          uVar3 = gettext("form to permit");
          fprintf((FILE *)fp,
                  "<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
                  uVar3,local_1c8,path);
          fwrite("</Body></Html>",1,0xe,(FILE *)fp);
          LYCloseTempFP(fp);
          LYforce_no_cache = '\x01';
          local_1fc = -99;
        }
        goto LAB_080fc443;
      }
    }
    local_1fc = 0;
  }
LAB_080fc443:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_1fc;
}



void tagflag(int flag,int cur)

{
  if (0 < nlinks) {
    LYmove(links[cur].ly,2);
    lynx_stop_reverse();
    if (flag == 1) {
      waddch(LYwin,0x2b);
    }
    else {
      waddch(LYwin,0x20);
    }
    if (LYShowCursor == '\0') {
      LYmove(LYlines + -1,(LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
    }
    else {
      LYmove(links[cur].ly,links[cur].lx);
    }
    LYrefresh();
  }
  return;
}



void showtags(HTList *t)

{
  int iVar1;
  char *local_18;
  char *name;
  HTList *s;
  int i;
  
  i = 0;
  do {
    if (nlinks <= i) {
      return;
    }
    s = t;
    do {
      if ((s == (HTList *)0x0) || (s = s->next, s == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)s->object;
      }
      if (local_18 == (char *)0x0) goto LAB_080fc5c5;
      iVar1 = strcmp(links[i].lname,local_18);
    } while (iVar1 != 0);
    tagflag(1,i);
LAB_080fc5c5:
    i = i + 1;
  } while( true );
}



char * DirectoryOf(char *pathname)

{
  BOOLEAN BVar1;
  char *src;
  char *result1;
  char *leaf;
  char *result;
  
  result = (char *)0x0;
  HTSACopy(&result,pathname);
  src = LYPathLeaf(result);
  if (src != result) {
    *src = '\0';
    BVar1 = LYisRootPath(result);
    if (BVar1 == '\0') {
      LYTrimPathSep(result);
    }
    src = wwwName(result);
    HTSACopy(&result,src);
  }
  return result;
}



char * match_op(char *prefix,char *data)

{
  size_t __n;
  int iVar1;
  int len;
  
  __n = strlen(prefix);
  iVar1 = strncmp("LYNXDIRED://",data,0xc);
  if ((iVar1 == 0) && (iVar1 = strncmp(prefix,data + 0xc,__n), iVar1 == 0)) {
    return data + __n + 0xc;
  }
  return (char *)0x0;
}



char * build_command(char *line,char *dirname,char *arg)

{
  char *parameter;
  char *parameter_00;
  char *parameter_01;
  char *parameter_02;
  char *local_18;
  char *tar_path;
  char *program;
  char *buffer;
  
  buffer = (char *)0x0;
  parameter = HTGetProgramPath(ppTAR);
  parameter_00 = match_op("DECOMPRESS",line);
  if (parameter_00 == (char *)0x0) {
    parameter_00 = match_op("UUDECODE",line);
    if (parameter_00 == (char *)0x0) {
      if (parameter != (char *)0x0) {
        parameter_00 = match_op("UNTAR_GZ",line);
        if (parameter_00 != (char *)0x0) {
          parameter_01 = HTGetProgramPath(ppGZIP);
          if (parameter_01 != (char *)0x0) {
            parameter_02 = DirectoryOf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",1,parameter_02);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",2,parameter_01);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",3,parameter_00);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",4,parameter);
            HTAddToCmd(&buffer,"cd %s; %s -qdc %s |  %s %s %s",5,"-xf");
            HTAddToCmd(&buffer,"cd %s; %s -qdc %s |  %s %s %s",6,"-");
            HTEndParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",6);
          }
          return buffer;
        }
        parameter_00 = match_op("UNTAR_Z",line);
        if (parameter_00 != (char *)0x0) {
          parameter_01 = HTGetProgramPath(ppZCAT);
          if (parameter_01 != (char *)0x0) {
            parameter_02 = DirectoryOf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",1,parameter_02);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",2,parameter_01);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",3,parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",4,parameter);
            HTAddToCmd(&buffer,"cd %s; %s %s |  %s %s %s",5,"-xf");
            HTAddToCmd(&buffer,"cd %s; %s %s |  %s %s %s",6,"-");
            HTEndParam(&buffer,"cd %s; %s %s |  %s %s %s",6);
          }
          return buffer;
        }
        parameter_00 = match_op("UNTAR",line);
        if (parameter_00 != (char *)0x0) {
          parameter_01 = DirectoryOf(parameter_00);
          HTAddParam(&buffer,"cd %s; %s %s %s",1,parameter_01);
          HTAddParam(&buffer,"cd %s; %s %s %s",2,parameter);
          HTAddToCmd(&buffer,"cd %s; %s %s %s",3,"-xf");
          HTAddParam(&buffer,"cd %s; %s %s %s",4,parameter_00);
          HTEndParam(&buffer,"cd %s; %s %s %s",4);
          return buffer;
        }
        parameter_00 = match_op("TAR_GZ",line);
        if (parameter_00 != (char *)0x0) {
          parameter_01 = HTGetProgramPath(ppGZIP);
          if (parameter_01 != (char *)0x0) {
            parameter_02 = DirectoryOf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",1,parameter_02);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",2,parameter);
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",3,"-cf");
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",4,"-");
            parameter = LYPathLeaf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",5,parameter);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",6,parameter_01);
            parameter = LYPathLeaf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",7,parameter);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",8,".tar.gz");
            HTEndParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",8);
          }
          return buffer;
        }
        parameter_00 = match_op("TAR_Z",line);
        if (parameter_00 != (char *)0x0) {
          parameter_01 = HTGetProgramPath(ppCOMPRESS);
          if (parameter_01 != (char *)0x0) {
            parameter_02 = DirectoryOf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",1,parameter_02);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",2,parameter);
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s >%s%s",3,"-cf");
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s >%s%s",4,"-");
            parameter = LYPathLeaf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",5,parameter);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",6,parameter_01);
            parameter = LYPathLeaf(parameter_00);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",7,parameter);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",8,".tar.Z");
            HTEndParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",8);
          }
          return buffer;
        }
        parameter_00 = match_op("TAR",line);
        if (parameter_00 != (char *)0x0) {
          parameter_01 = DirectoryOf(parameter_00);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",1,parameter_01);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",2,parameter);
          HTAddToCmd(&buffer,"cd %s; %s %s %s %s.tar %s",3,"-cf");
          HTAddToCmd(&buffer,"cd %s; %s %s %s %s.tar %s",4,"");
          parameter = LYPathLeaf(parameter_00);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",5,parameter);
          parameter = LYPathLeaf(parameter_00);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",6,parameter);
          HTEndParam(&buffer,"cd %s; %s %s %s %s.tar %s",6);
          return buffer;
        }
      }
      parameter = match_op("GZIP",line);
      if (parameter == (char *)0x0) {
        parameter = match_op("UNGZIP",line);
        if (parameter == (char *)0x0) {
          parameter = match_op("ZIP",line);
          if (parameter == (char *)0x0) {
            parameter = match_op("UNZIP",line);
            if (parameter == (char *)0x0) {
              parameter = match_op("COMPRESS",line);
              if (parameter == (char *)0x0) {
                local_18 = (char *)0x0;
              }
              else {
                parameter_00 = HTGetProgramPath(ppCOMPRESS);
                if (parameter_00 != (char *)0x0) {
                  HTAddParam(&buffer,"%s %s",1,parameter_00);
                  HTAddParam(&buffer,"%s %s",2,parameter);
                  HTEndParam(&buffer,"%s %s",2);
                }
                local_18 = buffer;
              }
            }
            else {
              parameter_00 = HTGetProgramPath(ppUNZIP);
              if (parameter_00 != (char *)0x0) {
                parameter_01 = DirectoryOf(parameter);
                HTAddParam(&buffer,"cd %s; %s -q %s",1,parameter_01);
                HTAddParam(&buffer,"cd %s; %s -q %s",2,parameter_00);
                HTAddParam(&buffer,"cd %s; %s -q %s",3,parameter);
                HTEndParam(&buffer,"cd %s; %s -q %s",3);
              }
              local_18 = buffer;
            }
          }
          else {
            parameter_00 = HTGetProgramPath(ppZIP);
            if (parameter_00 != (char *)0x0) {
              parameter_01 = DirectoryOf(parameter);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",1,parameter_01);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",2,parameter_00);
              parameter_00 = LYPathLeaf(parameter);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",3,parameter_00);
              parameter = LYPathLeaf(parameter);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",4,parameter);
              HTEndParam(&buffer,"cd %s; %s -rq %s.zip %s",4);
            }
            local_18 = buffer;
          }
        }
        else {
          parameter_00 = HTGetProgramPath(ppGZIP);
          if (parameter_00 != (char *)0x0) {
            HTAddParam(&buffer,"%s -d %s",1,parameter_00);
            HTAddParam(&buffer,"%s -d %s",2,parameter);
            HTEndParam(&buffer,"%s -d %s",2);
          }
          local_18 = buffer;
        }
      }
      else {
        parameter_00 = HTGetProgramPath(ppGZIP);
        if (parameter_00 != (char *)0x0) {
          HTAddParam(&buffer,"%s -q %s",1,parameter_00);
          HTAddParam(&buffer,"%s -q %s",2,parameter);
          HTEndParam(&buffer,"%s -q %s",2);
        }
        local_18 = buffer;
      }
    }
    else {
      parameter = HTGetProgramPath(ppUUDECODE);
      if (parameter != (char *)0x0) {
        HTAddParam(&buffer,"%s %s",1,parameter);
        HTAddParam(&buffer,"%s %s",2,parameter_00);
        HTEndParam(&buffer,"%s %s",2);
        parameter = (char *)gettext(
                                   "Warning!  UUDecoded file will exist in the directory you started Lynx."
                                   );
        HTAlert(parameter);
      }
      local_18 = buffer;
    }
  }
  else {
    parameter = HTGetProgramPath(ppUNCOMPRESS);
    if (parameter != (char *)0x0) {
      HTAddParam(&buffer,"%s %s",1,parameter);
      HTAddParam(&buffer,"%s %s",2,parameter_00);
      HTEndParam(&buffer,"%s %s",2);
    }
    local_18 = buffer;
  }
  return local_18;
}



// WARNING: Removing unreachable block (ram,0x080fd854)

int local_dired(DocInfo *doc)

{
  bool bVar1;
  FILE *__stream;
  char *testpath;
  int iVar2;
  char *str;
  size_t sVar3;
  char *local_30;
  char *dirname;
  char *buffer;
  char *tmpbuf;
  char *tp;
  char *arg;
  char *line;
  char *line_url;
  BOOLEAN do_pop_doc;
  
  line = (char *)0x0;
  tp = (char *)0x0;
  tmpbuf = (char *)0x0;
  buffer = (char *)0x0;
  bVar1 = true;
  str = doc->address;
  if (WWW_TraceFlag != '\0') {
    local_30 = str;
    if (str == (char *)0x0) {
      local_30 = (char *)gettext("NULL URL pointer");
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"local_dired: called for <%s>.\n",local_30);
  }
  HTUnEscapeSome(str,"/");
  HTSACopy(&line,str);
  HTUnEscape(line);
  testpath = match_op("CHDIR",line);
  if (testpath == (char *)0x0) {
    testpath = match_op("NEW_FILE",line);
    if (testpath == (char *)0x0) {
      testpath = match_op("NEW_FOLDER",line);
      if (testpath == (char *)0x0) {
        testpath = match_op("MODIFY_NAME",line);
        if (testpath == (char *)0x0) {
          testpath = match_op("MODIFY_LOCATION",line);
          if (testpath == (char *)0x0) {
            testpath = match_op("MOVE_TAGGED",str);
            if (testpath == (char *)0x0) {
              testpath = match_op("PERMIT_SRC",line);
              if (testpath != (char *)0x0) {
                permit_location((char *)0x0,testpath,&tp);
                if (tp != (char *)0x0) {
                  if (doc->address != (char *)0x0) {
                    free(doc->address);
                    doc->address = (char *)0x0;
                  }
                  doc->address = tp;
                }
                if (line == (char *)0x0) {
                  return 0;
                }
                free(line);
                return 0;
              }
              testpath = match_op("PERMIT_LOCATION",str);
              if (testpath == (char *)0x0) {
                testpath = match_op("REMOVE_SINGLE",line);
                if (testpath == (char *)0x0) {
                  testpath = match_op("REMOVE_TAGGED",line);
                  if (testpath == (char *)0x0) {
                    testpath = match_op("CLEAR_TAGGED",line);
                    if (testpath == (char *)0x0) {
                      testpath = match_op("UPLOAD",line);
                      if (testpath == (char *)0x0) {
                        LYTrimPathSep(line);
                        str = LYLastPathSep(line);
                        if (str == (char *)0x0) {
                          if (line == (char *)0x0) {
                            return 0;
                          }
                          free(line);
                          return 0;
                        }
                        buffer = build_command(line,(char *)0x0,(char *)0x0);
                        if (buffer != (char *)0x0) {
                          sVar3 = strlen(buffer);
                          if ((int)sVar3 < (int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -0xe))
                          {
                            str = (char *)gettext("Executing %s ");
                            HTSprintf0(&tmpbuf,str,buffer);
                          }
                          else {
                            str = (char *)gettext(
                                                 "Executing system command. This might take a while."
                                                 );
                            HTSprintf0(&tmpbuf,str);
                          }
                          mustshow = '\x01';
                          statusline(tmpbuf);
                          stop_curses();
                          printf("%s\r\n",tmpbuf);
                          LYSystem(buffer);
                          start_curses();
                          LYforce_no_cache = '\x01';
                        }
                      }
                      else {
                        iVar2 = LYUpload(str);
                        if (iVar2 != 0) {
                          LYforce_no_cache = '\x01';
                        }
                      }
                    }
                    else {
                      clear_tags();
                    }
                  }
                  else {
                    iVar2 = remove_tagged();
                    if (iVar2 != 0) {
                      LYforce_no_cache = '\x01';
                    }
                  }
                }
                else {
                  iVar2 = remove_single(testpath);
                  if (0 < iVar2) {
                    LYforce_no_cache = '\x01';
                  }
                }
              }
              else {
                permit_location(testpath,(char *)0x0,&tp);
              }
            }
            else {
              iVar2 = modify_tagged(testpath);
              if (0 < iVar2) {
                LYforce_no_cache = '\x01';
              }
            }
          }
          else {
            iVar2 = modify_location(testpath);
            if (0 < iVar2) {
              LYforce_no_cache = '\x01';
            }
          }
        }
        else {
          iVar2 = modify_name(testpath);
          if (0 < iVar2) {
            LYforce_no_cache = '\x01';
          }
        }
      }
      else {
        iVar2 = create_directory(testpath);
        if (0 < iVar2) {
          LYforce_no_cache = '\x01';
        }
      }
    }
    else {
      iVar2 = create_file(testpath);
      if (0 < iVar2) {
        LYforce_no_cache = '\x01';
      }
    }
  }
  else {
    handle_LYK_CHDIR();
    bVar1 = false;
  }
  if (tmpbuf != (char *)0x0) {
    free(tmpbuf);
    tmpbuf = (char *)0x0;
  }
  if (buffer != (char *)0x0) {
    free(buffer);
  }
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  if (tp != (char *)0x0) {
    free(tp);
    tp = (char *)0x0;
  }
  if (bVar1) {
    LYpop(doc);
  }
  return 0;
}



int dired_options(DocInfo *doc,char **newfile)

{
  int iVar1;
  bool bVar2;
  char tempfile [256];
  BOOLEAN BVar3;
  FILE *fp0_00;
  char *path_00;
  undefined4 uVar4;
  size_t sVar5;
  size_t sVar6;
  int iVar7;
  char *local_8e0;
  char *path_01;
  char *pcVar8;
  int in_GS_OFFSET;
  int local_8d0;
  undefined4 local_8c4;
  char *local_8c0;
  undefined1 *local_8b8;
  stat dir_info;
  int m;
  int i;
  char *cd;
  char *cp1;
  int n;
  dired_menu *mp;
  int count;
  char *path_url;
  char *dir_url;
  FILE *fp0;
  lynx_list_item_type *nxt;
  char *dir;
  char *path;
  BOOLEAN nothing_tagged;
  char buf [2048];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  fp0_00 = InternalPageFP((char *)&ram0x081b3280,0);
  if (fp0_00 != (FILE *)0x0) {
    LYLocalFileToURL(newfile,(char *)0x81b3280);
    LYRegisterUIPage(*newfile,UIP_DIRED_MENU);
    if ((doc->link < 0) || (nlinks + 1 <= doc->link)) {
      HTSACopy(&path,"");
    }
    else {
      path = HTnameOfFile_WWW(links[doc->link].lname,'\0','\x01');
      LYTrimPathSep(path);
      BVar3 = ok_lstat(path,&dir_info);
      if (BVar3 == '\0') {
        LYCloseTempFP(fp0_00);
        if (path != (char *)0x0) {
          free(path);
          path = (char *)0x0;
        }
        goto LAB_080fe2a9;
      }
    }
    path_00 = HTnameOfFile_WWW(doc->address,'\0','\x01');
    LYTrimPathSep(path_00);
    if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
      bVar2 = true;
    }
    else {
      bVar2 = false;
    }
    local_8e0 = (char *)gettext("File Management Options");
    BeginInternalPage(fp0_00,local_8e0,"keystrokes/dired_help.html.gz");
    uVar4 = gettext("Current directory:");
    local_8e0 = path_00;
    fprintf((FILE *)fp0_00,"<em>%s</em> %s<br>\n",uVar4,path_00);
    if (bVar2) {
      uVar4 = gettext("Current selection:");
      fprintf((FILE *)fp0_00,"<em>%s</em> ",uVar4,local_8e0);
      if (*path == '\0') {
        uVar4 = gettext("Nothing currently selected.");
        fprintf((FILE *)fp0_00,"%s.<p>\n",uVar4,local_8e0);
      }
      else {
        fprintf((FILE *)fp0_00,"%s<p>\n",path,local_8e0);
      }
    }
    else {
      iVar7 = HTList_count(tagged);
      cp1 = (char *)0x0;
      cd = (char *)0x0;
      if (iVar7 == 1) {
        local_8c4 = gettext("tagged item:");
      }
      else {
        local_8c4 = gettext("tagged items:");
      }
      uVar4 = gettext("Current selection:");
      fprintf((FILE *)fp0_00,"<em>%s</em> %d %s",uVar4,iVar7,local_8c4);
      HTSACopy(&cd,doc->address);
      HTUnEscapeSome(cd,"/");
      LYAddHtmlSep(&cd);
      local_8d0 = iVar7;
      if (10 < iVar7) {
        local_8d0 = 10;
      }
      i = 1;
      while (i <= local_8d0) {
        if (*cd == '\0') {
          local_8c0 = "file://localhost";
        }
        else {
          local_8c0 = cd;
        }
        local_8e0 = (char *)HTList_objectAt(tagged,i + -1);
        cp1 = HTRelative(local_8e0,local_8c0);
        HTUnEscape(cp1);
        LYEntify(&cp1,'\x01');
        if (i == 1) {
          local_8b8 = &DAT_0817d5c4;
        }
        else {
          local_8b8 = &DAT_0817e8fd;
        }
        fprintf((FILE *)fp0_00,"%s<br>\n&nbsp;&nbsp;&nbsp;%s",local_8b8,cp1);
        if (cp1 != (char *)0x0) {
          free(cp1);
          cp1 = (char *)0x0;
        }
        i = i + 1;
      }
      if (local_8d0 < iVar7) {
        fwrite(" , ...",1,6,(FILE *)fp0_00);
      }
      fwrite(&DAT_0817e923,1,4,(FILE *)fp0_00);
      if (cd != (char *)0x0) {
        free(cd);
        cd = (char *)0x0;
      }
    }
    if (menu_head == (dired_menu *)0x0) {
      mp = defmenu;
      while (mp->href != (char *)0x0) {
        mp->next = mp + 1;
        mp = mp + 1;
      }
      mp[-1].next = (dired_menu *)0x0;
      menu_head = defmenu;
    }
    mp = menu_head;
    while (mp != (dired_menu *)0x0) {
      if (((((mp->cond == 1) || (bVar2)) && ((mp->cond != 1 || (!bVar2)))) &&
          ((mp->cond != 2 || ((*path != '\0' && ((dir_info.st_mode & 0xf000) == 0x4000)))))) &&
         (((mp->cond != 3 || ((*path != '\0' && ((dir_info.st_mode & 0xf000) == 0x8000)))) &&
          ((mp->cond != 4 || ((*path != '\0' && ((dir_info.st_mode & 0xf000) == 0xa000)))))))) {
        if (*mp->sfx == '\0') {
LAB_080fdff9:
          local_8e0 = HTEscape(path_00,'\x04');
          path_01 = HTEscape(path,'\x04');
          pcVar8 = render_item(mp->href,path_01,local_8e0,buf,0x800,'\x01');
          fprintf((FILE *)fp0_00,"<a href=\"%s",pcVar8);
          pcVar8 = render_item(mp->link,path,path_00,buf,0x800,'\0');
          fprintf((FILE *)fp0_00,"\">%s</a> ",pcVar8);
          pcVar8 = render_item(mp->rest,path,path_00,buf,0x800,'\0');
          fprintf((FILE *)fp0_00,"%s<br>\n",pcVar8);
          if (local_8e0 != (char *)0x0) {
            free(local_8e0);
          }
          if (path_01 != (char *)0x0) {
            free(path_01);
          }
        }
        else {
          sVar5 = strlen(path);
          sVar6 = strlen(mp->sfx);
          local_8e0 = path;
          if (sVar6 <= sVar5) {
            sVar5 = strlen(path);
            sVar6 = strlen(mp->sfx);
            iVar7 = strcmp(mp->sfx,local_8e0 + (sVar5 - sVar6));
            if (iVar7 == 0) goto LAB_080fdff9;
          }
        }
      }
      mp = mp->next;
    }
    if (path != (char *)0x0) {
      free(path);
      path = (char *)0x0;
    }
    if (uploaders != (lynx_list_item_type *)0x0) {
      fwrite("<p>Upload to current directory:<p>\n",1,0x23,(FILE *)fp0_00);
      count = 0;
      nxt = uploaders;
      while (nxt != (lynx_list_item_type *)0x0) {
        fprintf((FILE *)fp0_00,"<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",count,
                path_00,nxt->name);
        nxt = (lynx_list_item_type *)nxt->next;
        count = count + 1;
      }
    }
    if (path_00 != (char *)0x0) {
      free(path_00);
    }
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYforce_no_cache = '\x01';
  }
LAB_080fe2a9:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * get_filename(char *prompt,char *buf,size_t bufsize)

{
  char *Msg;
  char *local_18;
  char *cp;
  
  mustshow = '\x01';
  statusline(prompt);
  LYgetstr(buf,0,bufsize,NORECALL);
  Msg = strstr(buf,"../");
  if (Msg == (char *)0x0) {
    if ((no_dotfiles != '\0') || (show_dotfiles == '\0')) {
      cp = LYLastPathSep(buf);
      if (cp == (char *)0x0) {
        cp = buf;
      }
      else {
        cp = cp + 1;
      }
      if (*cp == '.') {
        Msg = (char *)gettext("Illegal filename; request ignored.");
        HTAlert(Msg);
        return (char *)0x0;
      }
    }
    local_18 = buf;
  }
  else {
    Msg = (char *)gettext("Illegal filename; request ignored.");
    HTAlert(Msg);
    local_18 = (char *)0x0;
  }
  return local_18;
}



void clear_tags(void)

{
  void *__ptr;
  char *cp;
  
  while( true ) {
    __ptr = HTList_removeLastObject(tagged);
    if (__ptr == (void *)0x0) break;
    if (__ptr != (void *)0x0) {
      free(__ptr);
    }
  }
  if (((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) && (tagged != (HTList *)0x0)) {
    free(tagged);
    tagged = (HTList *)0x0;
  }
  return;
}



void add_menu_item(char *str)

{
  dired_menu *pdVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  char *cp;
  dired_menu *mp;
  dired_menu *tmp;
  
  if (menu_head == defmenu) {
    menu_head = (dired_menu *)0x0;
  }
  pdVar1 = (dired_menu *)calloc(1,0x18);
  if (pdVar1 == (dired_menu *)0x0) {
    outofmem("./LYLocal.c","add_menu_item");
  }
  pcVar2 = strchr(str,0x3a);
  *pcVar2 = '\0';
  iVar3 = strcasecomp(str,"tag");
  if (iVar3 == 0) {
    pdVar1->cond = 1;
  }
  else {
    iVar3 = strcasecomp(str,"dir");
    if (iVar3 == 0) {
      pdVar1->cond = 2;
    }
    else {
      iVar3 = strcasecomp(str,"file");
      if (iVar3 == 0) {
        pdVar1->cond = 3;
      }
      else {
        iVar3 = strcasecomp(str,"link");
        if (iVar3 == 0) {
          pdVar1->cond = 4;
        }
      }
    }
  }
  pcVar4 = strchr(pcVar2 + 1,0x3a);
  *pcVar4 = '\0';
  HTSACopy(&pdVar1->sfx,pcVar2 + 1);
  pcVar2 = strchr(pcVar4 + 1,0x3a);
  *pcVar2 = '\0';
  HTSACopy(&pdVar1->link,pcVar4 + 1);
  pcVar4 = strchr(pcVar2 + 1,0x3a);
  *pcVar4 = '\0';
  HTSACopy(&pdVar1->rest,pcVar2 + 1);
  HTSACopy(&pdVar1->href,pcVar4 + 1);
  if (menu_head != (dired_menu *)0x0) {
    mp = menu_head;
    while ((mp != (dired_menu *)0x0 && (mp->next != (dired_menu *)0x0))) {
      mp = mp->next;
    }
    mp->next = pdVar1;
    pdVar1 = menu_head;
  }
  menu_head = pdVar1;
  return;
}



void reset_dired_menu(void)

{
  dired_menu *mp_next;
  dired_menu *mp;
  
  if (menu_head != defmenu) {
    mp = menu_head;
    while (mp != (dired_menu *)0x0) {
      if (mp->sfx != (char *)0x0) {
        free(mp->sfx);
        mp->sfx = (char *)0x0;
      }
      if (mp->link != (char *)0x0) {
        free(mp->link);
        mp->link = (char *)0x0;
      }
      if (mp->rest != (char *)0x0) {
        free(mp->rest);
        mp->rest = (char *)0x0;
      }
      if (mp->href != (char *)0x0) {
        free(mp->href);
        mp->href = (char *)0x0;
      }
      if (mp != (dired_menu *)0x0) {
        free(mp);
      }
      mp = (dired_menu *)0x0;
    }
    menu_head = (dired_menu *)0x0;
  }
  return;
}



char * render_item(char *s,char *path,char *dir,char *buf,int bufsize,BOOLEAN url_syntax)

{
  char cVar1;
  char *Msg;
  char *local_54;
  char *local_50;
  char *local_4c;
  char *local_48;
  char *local_44;
  char *local_40;
  char *local_3c;
  char *local_38;
  char *local_34;
  char *local_30;
  char *local_2c;
  char *name;
  HTList *cur;
  char *taglist;
  char *bp;
  char *cp;
  char overrun;
  
  overrun = '\0';
  taglist = (char *)0x0;
  bp = buf;
  do {
    if ((*s == '\0') || (overrun != '\0')) {
      if ((byte)(overrun & url_syntax) != 0) {
        Msg = (char *)gettext("Temporary URL or list would be too long.");
        HTAlert(Msg);
        bp = buf;
      }
      *bp = '\0';
      return buf;
    }
    if (*s == '%') {
      s = s + 1;
      cVar1 = *s;
      if (cVar1 == 'l') {
LAB_080fe8ef:
        if ((tagged != (HTList *)0x0) && (tagged->next != (HTList *)0x0)) {
          cur = tagged;
          while (overrun == '\0') {
            if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
              local_3c = (char *)0x0;
            }
            else {
              local_3c = (char *)cur->object;
            }
            if (local_3c == (char *)0x0) break;
            if ((*s == 'l') && (cp = strrchr(local_3c,0x2f), cp != (char *)0x0)) {
              cp = cp + 1;
            }
            else {
              cp = local_3c;
            }
            HTSACat(&taglist,cp);
            HTSACat(&taglist," ");
          }
        }
        if (taglist != (char *)0x0) {
          cp = taglist;
          while (*cp != '\0') {
            if (buf + bufsize + -2 < bp) {
              local_38 = &overrun;
            }
            else {
              local_38 = bp;
              bp = bp + 1;
            }
            *local_38 = *cp;
            cp = cp + 1;
          }
          if (taglist != (char *)0x0) {
            free(taglist);
            taglist = (char *)0x0;
          }
        }
      }
      else {
        if (cVar1 < 'm') {
          if (cVar1 == 'd') {
            cp = dir;
            if (*dir != '/') {
              if (buf + bufsize + -2 < bp) {
                local_48 = &overrun;
              }
              else {
                local_48 = bp;
                bp = bp + 1;
              }
              *local_48 = '/';
            }
            while (*cp != '\0') {
              if (buf + bufsize + -2 < bp) {
                local_44 = &overrun;
              }
              else {
                local_44 = bp;
                bp = bp + 1;
              }
              *local_44 = *cp;
              cp = cp + 1;
            }
          }
          else {
            if (cVar1 == 'f') {
              cp = LYLastPathSep(path);
              if (cp == (char *)0x0) {
                cp = path;
              }
              else {
                cp = cp + 1;
              }
              while (*cp != '\0') {
                if (buf + bufsize + -2 < bp) {
                  local_40 = &overrun;
                }
                else {
                  local_40 = bp;
                  bp = bp + 1;
                }
                *local_40 = *cp;
                cp = cp + 1;
              }
            }
            else {
              if (cVar1 != '%') goto LAB_080fea16;
              if (buf + bufsize + -2 < bp) {
                local_54 = &overrun;
              }
              else {
                local_54 = bp;
                bp = bp + 1;
              }
              *local_54 = '%';
            }
          }
        }
        else {
          if (cVar1 == 'p') {
            cp = path;
            if (*path != '/') {
              if (buf + bufsize + -2 < bp) {
                local_50 = &overrun;
              }
              else {
                local_50 = bp;
                bp = bp + 1;
              }
              *local_50 = '/';
            }
            while (*cp != '\0') {
              if (buf + bufsize + -2 < bp) {
                local_4c = &overrun;
              }
              else {
                local_4c = bp;
                bp = bp + 1;
              }
              *local_4c = *cp;
              cp = cp + 1;
            }
          }
          else {
            if (cVar1 == 't') goto LAB_080fe8ef;
LAB_080fea16:
            if (buf + bufsize + -2 < bp) {
              local_34 = &overrun;
            }
            else {
              local_34 = bp;
              bp = bp + 1;
            }
            *local_34 = '%';
            if (buf + bufsize + -2 < bp) {
              local_30 = &overrun;
            }
            else {
              local_30 = bp;
              bp = bp + 1;
            }
            *local_30 = *s;
          }
        }
      }
    }
    else {
      if (buf + bufsize + -2 < bp) {
        local_2c = &overrun;
      }
      else {
        local_2c = bp;
        bp = bp + 1;
      }
      *local_2c = *s;
    }
    s = s + 1;
  } while( true );
}



char * HTStrip(char *s)

{
  char *p;
  
  p = s;
  while (*p != '\0') {
    p = p + 1;
  }
  while ((p = p + -1, s <= p && (((*p == ' ' || (*p == '\t')) || (*p == '\n'))))) {
    *p = '\0';
  }
  while (((*s == ' ' || (*s == '\t')) || (*s == '\n'))) {
    s = s + 1;
  }
  return s;
}



void scan(char *name,struct_parts *parts)

{
  char *pcVar1;
  int iVar2;
  char *local_18;
  char *p;
  char *after_access;
  
  parts->access = (char *)0x0;
  parts->host = (char *)0x0;
  parts->absolute = (char *)0x0;
  parts->relative = (char *)0x0;
  parts->search = (char *)0x0;
  parts->anchor = (char *)0x0;
  after_access = name;
  p = name;
  while (*p != '\0') {
    if (*p == ':') {
      *p = '\0';
      parts->access = name;
      after_access = p + 1;
      break;
    }
    if ((((*p == '/') || (*p == '#')) || (*p == ';')) || (*p == '?')) break;
    p = p + 1;
  }
  p = after_access;
  do {
    if (*p == '\0') {
LAB_080fec3d:
      if (*after_access == '/') {
        if (after_access[1] == '/') {
          parts->host = after_access + 2;
          *after_access = '\0';
          pcVar1 = strchr(parts->host,0x2f);
          if (pcVar1 == (char *)0x0) {
            pcVar1 = strchr(parts->host,0x3f);
            if (pcVar1 != (char *)0x0) {
              *pcVar1 = '\0';
              parts->search = pcVar1 + 1;
            }
          }
          else {
            *pcVar1 = '\0';
            parts->absolute = pcVar1 + 1;
          }
        }
        else {
          parts->absolute = after_access + 1;
        }
      }
      else {
        if (*after_access == '\0') {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = after_access;
        }
        parts->relative = local_18;
      }
      if (parts->access == (char *)0x0) {
        return;
      }
      if (parts->anchor == (char *)0x0) {
        return;
      }
      pcVar1 = strchr("lnsdLNSD",(int)*parts->access);
      if (pcVar1 != (char *)0x0) {
        if ((((parts->host != (char *)0x0) ||
             (iVar2 = strcasecomp(parts->access,"lynxcgi"), iVar2 == 0)) &&
            ((iVar2 = strcasecomp(parts->access,"nntp"), iVar2 != 0 &&
             ((iVar2 = strcasecomp(parts->access,"snews"), iVar2 != 0 &&
              (iVar2 = strcasecomp(parts->access,"news"), iVar2 != 0)))))) &&
           (iVar2 = strcasecomp(parts->access,"data"), iVar2 != 0)) {
          return;
        }
        if ((parts->relative != (char *)0x0) || (parts->absolute != (char *)0x0)) {
          parts->anchor[-1] = '#';
          parts->anchor = (char *)0x0;
        }
        return;
      }
      return;
    }
    if (*p == '#') {
      parts->anchor = p + 1;
      *p = '\0';
      goto LAB_080fec3d;
    }
    p = p + 1;
  } while( true );
}



char * strchr_or_end(char *string,int ch)

{
  size_t sVar1;
  char *result;
  
  result = strchr(string,ch);
  if (result == (char *)0x0) {
    sVar1 = strlen(string);
    result = string + sVar1;
  }
  return result;
}



char * HTParsePort(char *host,int *portp)

{
  char cVar1;
  int iVar2;
  byte *__nptr;
  ushort **ppuVar3;
  long lVar4;
  FILE *__stream;
  char *next;
  char *result;
  int brackets;
  
  brackets = 0;
  result = (char *)0x0;
  *portp = 0;
  __nptr = (byte *)host;
  if (host != (char *)0x0) {
    while ((host = (char *)__nptr, *host != '\0' && (result == (char *)0x0))) {
      cVar1 = *host;
      __nptr = (byte *)(host + 1);
      if (cVar1 == '[') {
        brackets = brackets + 1;
      }
      else {
        if (cVar1 == ']') {
          brackets = brackets + -1;
        }
        else {
          if (((cVar1 == ':') && (brackets == 0)) &&
             (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*__nptr] & 0x800) != 0)) {
            next = (char *)0x0;
            lVar4 = strtol((char *)__nptr,&next,10);
            *portp = lVar4;
            if (((next != (char *)0x0) && ((byte *)next != __nptr)) &&
               ((*next == '\0' && (result = host, WWW_TraceFlag != '\0')))) {
              iVar2 = *portp;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTParsePort %d\n",iVar2);
            }
          }
        }
      }
    }
  }
  return result;
}



char * HTParse(char *aName,char *relatedName,int wanted)

{
  int iVar1;
  char empty_string [1];
  FILE *__stream;
  size_t sVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  int in_GS_OFFSET;
  char *local_e4;
  char *local_e0;
  char *local_dc;
  char *local_d8;
  char *local_d4;
  char *local_d0;
  char *local_cc;
  char *local_c0;
  char *local_bc;
  char *local_b8;
  char *local_b4;
  char *local_b0;
  char *local_ac;
  char *local_a8;
  char **local_a4;
  char *local_a0;
  char *local_9c;
  int local_98;
  UrlTypes local_94;
  char *local_90;
  char *local_8c;
  struct_parts related;
  struct_parts given;
  char *base;
  int want_detail;
  int len3;
  int portnumber;
  char *h;
  char *p2;
  char *acc_method;
  char *q;
  char *p;
  char *rel;
  char *name;
  uint len2;
  uint len1;
  uint len;
  char *return_value;
  char *tail;
  char *result;
  int local_c;
  
  local_8c = aName;
  local_90 = relatedName;
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  return_value = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    local_e4 = local_8c;
    fprintf((FILE *)__stream,"HTParse: aName:`%s\'\n");
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    local_e4 = local_90;
    fprintf((FILE *)__stream,"   relatedName:`%s\'\n");
  }
  if ((wanted & 0x60U) != 0) {
    if ((wanted & 0x60U) == 0x60) {
      wanted = wanted | 4;
    }
    if ((wanted & 4U) != 0) {
      wanted = wanted & 0xffffff9f;
    }
  }
  if (WWW_TraceFlag != '\0') {
    if ((wanted & 0x40U) == 0) {
      local_c0 = "";
    }
    else {
      local_c0 = " QUERY";
    }
    if ((wanted & 0x20U) == 0) {
      local_bc = "";
    }
    else {
      local_bc = " PATH";
    }
    if ((wanted & 0x10U) == 0) {
      local_b8 = "";
    }
    else {
      local_b8 = " access";
    }
    if ((wanted & 8U) == 0) {
      local_b4 = "";
    }
    else {
      local_b4 = " host";
    }
    if ((wanted & 4U) == 0) {
      local_b0 = "";
    }
    else {
      local_b0 = " path";
    }
    if ((wanted & 2U) == 0) {
      local_ac = "";
    }
    else {
      local_ac = " anchor";
    }
    if ((wanted & 1U) == 0) {
      local_a8 = "";
    }
    else {
      local_a8 = " punc";
    }
    __stream = TraceFP();
    local_cc = local_c0;
    local_d0 = local_bc;
    local_d4 = local_b8;
    local_d8 = local_b4;
    local_dc = local_b0;
    local_e0 = local_ac;
    local_e4 = local_a8;
    fprintf((FILE *)__stream,"   want:%s%s%s%s%s%s%s\n");
  }
  sVar2 = strlen(local_8c);
  len1 = sVar2 + 1;
  sVar2 = strlen(local_90);
  len2 = sVar2 + 1;
  len = len1 + len2 + 8;
  iVar1 = -(len * 2 + len1 + len2 + 0x1e & 0xfffffff0);
  tail = (char *)((int)&local_c0 + iVar1);
  local_a4 = (char **)tail;
  result = tail;
  if ((char **)tail == (char **)0x0) {
    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eac8;
    *(undefined4 *)(&stack0xffffff14 + iVar1) = 0x817ead0;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff205;
    outofmem(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
  }
  *result = '\0';
  name = result + len;
  rel = name + len1;
  *(uint *)((int)&local_e4 + iVar1) = len1;
  *(char **)(&stack0xffffff18 + iVar1) = local_8c;
  *(char **)(&stack0xffffff14 + iVar1) = name;
  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff23d;
  memcpy(*(void **)(&stack0xffffff14 + iVar1),*(void **)(&stack0xffffff18 + iVar1),
         (size_t)*(char **)((int)&local_e4 + iVar1));
  *(struct_parts **)(&stack0xffffff18 + iVar1) = &given;
  *(char **)(&stack0xffffff14 + iVar1) = name;
  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff24f;
  scan(*(char **)(&stack0xffffff14 + iVar1),*(struct_parts **)(&stack0xffffff18 + iVar1));
  if ((((given.access == (char *)0x0) || (given.host == (char *)0x0)) ||
      (given.absolute == (char *)0x0)) && (*local_90 != '\0')) {
    *(uint *)((int)&local_e4 + iVar1) = len2;
    *(char **)(&stack0xffffff18 + iVar1) = local_90;
    *(char **)(&stack0xffffff14 + iVar1) = rel;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff2b9;
    memcpy(*(void **)(&stack0xffffff14 + iVar1),*(void **)(&stack0xffffff18 + iVar1),
           (size_t)*(char **)((int)&local_e4 + iVar1));
    *(struct_parts **)(&stack0xffffff18 + iVar1) = &related;
    *(char **)(&stack0xffffff14 + iVar1) = rel;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff2cb;
    scan(*(char **)(&stack0xffffff14 + iVar1),*(struct_parts **)(&stack0xffffff18 + iVar1));
  }
  else {
    related.access = (char *)0x0;
    related.host = (char *)0x0;
    related.absolute = (char *)0x0;
    related.relative = (char *)0x0;
    related.search = (char *)0x0;
    related.anchor = (char *)0x0;
  }
  pcVar4 = given.access;
  if (((given.access != (char *)0x0) && (given.host != (char *)0x0)) &&
     ((given.relative == (char *)0x0 && (given.absolute == (char *)0x0)))) {
    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eafe;
    *(char **)(&stack0xffffff14 + iVar1) = pcVar4;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff2fa;
    iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    pcVar4 = given.access;
    if (iVar3 != 0) {
      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb03;
      *(char **)(&stack0xffffff14 + iVar1) = pcVar4;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff311;
      iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      pcVar4 = given.access;
      if (iVar3 != 0) {
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb09;
        *(char **)(&stack0xffffff14 + iVar1) = pcVar4;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff328;
        iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
        if (iVar3 != 0) goto LAB_080ff333;
      }
    }
    given.absolute = &ram0x081a9d00;
  }
LAB_080ff333:
  if (given.access == (char *)0x0) {
    local_a0 = related.access;
  }
  else {
    local_a0 = given.access;
  }
  acc_method = local_a0;
  if (((wanted & 0x10U) != 0) && (local_a0 != (char *)0x0)) {
    *(char **)(&stack0xffffff18 + iVar1) = local_a0;
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff379;
    strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff384;
    sVar2 = strlen(*(char **)(&stack0xffffff14 + iVar1));
    tail = tail + sVar2;
    if ((wanted & 1U) != 0) {
      *tail = ':';
      tail = tail + 1;
      *tail = '\0';
    }
  }
  if ((given.access != (char *)0x0) && (related.access != (char *)0x0)) {
    *(char **)(&stack0xffffff18 + iVar1) = related.access;
    *(char **)(&stack0xffffff14 + iVar1) = given.access;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff3c1;
    iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    if (iVar3 != 0) {
      related.host = (char *)0x0;
      related.absolute = (char *)0x0;
      related.relative = (char *)0x0;
      related.search = (char *)0x0;
      related.anchor = (char *)0x0;
    }
  }
  if (((wanted & 8U) != 0) && ((given.host != (char *)0x0 || (related.host != (char *)0x0)))) {
    if ((wanted & 1U) != 0) {
      *tail = '/';
      tail[1] = '/';
      tail = tail + 2;
    }
    if (given.host == (char *)0x0) {
      local_9c = related.host;
    }
    else {
      local_9c = given.host;
    }
    *(char **)(&stack0xffffff18 + iVar1) = local_9c;
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff456;
    strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x40;
    *(char **)(&stack0xffffff14 + iVar1) = result;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff469;
    pcVar4 = strchr(*(char **)(&stack0xffffff14 + iVar1),*(int *)(&stack0xffffff18 + iVar1));
    if (pcVar4 != (char *)0x0) {
      tail = pcVar4 + 1;
    }
    *(int **)(&stack0xffffff18 + iVar1) = &portnumber;
    *(char **)(&stack0xffffff14 + iVar1) = result;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff48d;
    p2 = HTParsePort(*(char **)(&stack0xffffff14 + iVar1),*(int **)(&stack0xffffff18 + iVar1));
    if ((p2 != (char *)0x0) && (acc_method != (char *)0x0)) {
      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eafe;
      *(char **)(&stack0xffffff14 + iVar1) = acc_method;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff4b7;
      iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      if ((iVar3 != 0) || (portnumber != 0x50)) {
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb03;
        *(char **)(&stack0xffffff14 + iVar1) = acc_method;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff4da;
        iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
        if ((iVar3 != 0) || (portnumber != 0x1bb)) {
          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb0d;
          *(char **)(&stack0xffffff14 + iVar1) = acc_method;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff4ff;
          iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          if ((iVar3 != 0) || (portnumber != 0x46)) {
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb09;
            *(char **)(&stack0xffffff14 + iVar1) = acc_method;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff522;
            iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1)
                          );
            if ((iVar3 != 0) || (portnumber != 0x15)) {
              *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb14;
              *(char **)(&stack0xffffff14 + iVar1) = acc_method;
              *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff545;
              iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                             *(char **)(&stack0xffffff18 + iVar1));
              if ((iVar3 != 0) || (portnumber != 0xd2)) {
                *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ea31;
                *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff56a;
                iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                               *(char **)(&stack0xffffff18 + iVar1));
                if ((iVar3 != 0) || (portnumber != 0x77)) {
                  *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ea3c;
                  *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff58d;
                  iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                 *(char **)(&stack0xffffff18 + iVar1));
                  if ((iVar3 != 0) || (portnumber != 0x77)) {
                    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb19;
                    *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff5b0;
                    iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                   *(char **)(&stack0xffffff18 + iVar1));
                    if ((iVar3 != 0) || (portnumber != 0x77)) {
                      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb22;
                      *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff5d3;
                      iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                     *(char **)(&stack0xffffff18 + iVar1));
                      if ((iVar3 != 0) || (portnumber != 0x77)) {
                        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ea36;
                        *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff5f6;
                        iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                       *(char **)(&stack0xffffff18 + iVar1));
                        if ((iVar3 != 0) || (portnumber != 0x233)) {
                          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb2c;
                          *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff61b;
                          iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                         *(char **)(&stack0xffffff18 + iVar1));
                          if ((iVar3 != 0) || (portnumber != 0x233)) {
                            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb36;
                            *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff640;
                            iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                           *(char **)(&stack0xffffff18 + iVar1));
                            if ((iVar3 != 0) || (portnumber != 0x233)) {
                              *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb41;
                              *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                              *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff665;
                              iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                             *(char **)(&stack0xffffff18 + iVar1));
                              if ((iVar3 != 0) || (portnumber != 0x4f)) {
                                *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb48;
                                *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                                *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff684;
                                iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                               *(char **)(&stack0xffffff18 + iVar1));
                                if ((iVar3 != 0) || (portnumber != 0x17)) {
                                  *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb4f;
                                  *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                                  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff6a3;
                                  iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                                 *(char **)(&stack0xffffff18 + iVar1));
                                  if ((iVar3 != 0) || (portnumber != 0x17)) {
                                    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb56;
                                    *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                                    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff6c2;
                                    iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                                   *(char **)(&stack0xffffff18 + iVar1));
                                    if ((iVar3 != 0) || (portnumber != 0x201)) {
                                      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb5d;
                                      *(char **)(&stack0xffffff14 + iVar1) = acc_method;
                                      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff6e3;
                                      iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),
                                                     *(char **)(&stack0xffffff18 + iVar1));
                                      if ((iVar3 != 0) || (portnumber != 0x69)) goto LAB_080ff6f5;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      *p2 = '\0';
    }
LAB_080ff6f5:
    if (p2 == (char *)0x0) {
      *(char **)(&stack0xffffff14 + iVar1) = tail;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff706;
      sVar2 = strlen(*(char **)(&stack0xffffff14 + iVar1));
      if ((0 < (int)sVar2) && (tail[sVar2 - 1] == '.')) {
        tail[sVar2 - 1] = '\0';
      }
    }
    else {
      if ((p2 != result) && (h = p2 + -1, *h == '.')) {
        while (*p2 != '\0') {
          *h = *p2;
          h = h + 1;
          p2 = p2 + 1;
        }
        *h = '\0';
      }
    }
  }
  *(char **)(&stack0xffffff14 + iVar1) = result;
  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff779;
  tail = LYRemoveBlanks(*(char **)(&stack0xffffff14 + iVar1));
  if ((given.search == (char *)0x0) || (given.search[-1] != '\0')) {
    if ((related.search != (char *)0x0) &&
       ((related.absolute == (char *)0x0 && (related.search[-1] == '\0')))) {
      related.absolute = related.search + -1;
      related.search[-1] = '?';
    }
  }
  else {
    given.absolute = given.search + -1;
    given.search[-1] = '?';
  }
  if ((given.host != (char *)0x0) && (related.host != (char *)0x0)) {
    *(char **)(&stack0xffffff18 + iVar1) = related.host;
    *(char **)(&stack0xffffff14 + iVar1) = given.host;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff7eb;
    iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    if (iVar3 != 0) {
      related.absolute = (char *)0x0;
      related.relative = (char *)0x0;
      related.anchor = (char *)0x0;
    }
  }
  if ((wanted & 100U) == 0) goto LAB_080ffc76;
  want_detail = wanted & 0x60;
  if (((acc_method != (char *)0x0) && (given.absolute == (char *)0x0)) &&
     (given.relative != (char *)0x0)) {
    local_98 = (int)*acc_method;
    if (local_98 == 0x53) {
LAB_080ff8e1:
      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ea36;
      *(char **)(&stack0xffffff14 + iVar1) = acc_method;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff8f4;
      iVar3 = strcasecomp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1))
      ;
      if (iVar3 == 0) {
        given.absolute = given.relative;
        given.relative = (char *)0x0;
      }
    }
    else {
      if (local_98 < 0x54) {
        if (local_98 == 0x4e) {
LAB_080ff885:
          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ea31;
          *(char **)(&stack0xffffff14 + iVar1) = acc_method;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff898;
          iVar3 = strcasecomp(*(char **)(&stack0xffffff14 + iVar1),
                              *(char **)(&stack0xffffff18 + iVar1));
          if (iVar3 == 0) {
LAB_080ff8d2:
            given.absolute = given.relative;
            given.relative = (char *)0x0;
          }
          else {
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ea3c;
            *(char **)(&stack0xffffff14 + iVar1) = acc_method;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff8af;
            iVar3 = strcasecomp(*(char **)(&stack0xffffff14 + iVar1),
                                *(char **)(&stack0xffffff18 + iVar1));
            if (iVar3 == 0) {
              *(char **)((int)&local_e4 + iVar1) = (char *)0x7;
              *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb61;
              *(char **)(&stack0xffffff14 + iVar1) = result;
              *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff8ce;
              iVar3 = strncasecomp(*(char **)(&stack0xffffff14 + iVar1),
                                   *(char **)(&stack0xffffff18 + iVar1),
                                   (int)*(char **)((int)&local_e4 + iVar1));
              if (iVar3 == 0) goto LAB_080ff8d2;
            }
          }
        }
      }
      else {
        if (local_98 == 0x6e) goto LAB_080ff885;
        if (local_98 == 0x73) goto LAB_080ff8e1;
      }
    }
  }
  if (given.absolute == (char *)0x0) {
    if (related.absolute == (char *)0x0) {
      if (given.relative == (char *)0x0) {
        if (related.relative == (char *)0x0) {
          if ((*local_8c == 'l') || (*local_8c == 'L')) {
            *(char **)((int)&local_e4 + iVar1) = (char *)0x8;
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ebbb;
            *(char **)(&stack0xffffff14 + iVar1) = local_8c;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffb6a;
            iVar3 = strncasecomp(*(char **)(&stack0xffffff14 + iVar1),
                                 *(char **)(&stack0xffffff18 + iVar1),
                                 (int)*(char **)((int)&local_e4 + iVar1));
            if (iVar3 != 0) goto LAB_080ffb72;
          }
          else {
LAB_080ffb72:
            if ((*local_8c == 'l') || (*local_8c == 'L')) {
              *(char **)((int)&local_e4 + iVar1) = (char *)0x9;
              *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ebc4;
              *(char **)(&stack0xffffff14 + iVar1) = local_8c;
              *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffbaa;
              iVar3 = strncasecomp(*(char **)(&stack0xffffff14 + iVar1),
                                   *(char **)(&stack0xffffff18 + iVar1),
                                   (int)*(char **)((int)&local_e4 + iVar1));
              if (iVar3 == 0) goto LAB_080ffbfa;
            }
            if ((*local_8c == 'l') || (*local_8c == 'L')) {
              *(char **)((int)&local_e4 + iVar1) = (char *)0x9;
              *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ebce;
              *(char **)(&stack0xffffff14 + iVar1) = local_8c;
              *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffbe6;
              iVar3 = strncasecomp(*(char **)(&stack0xffffff14 + iVar1),
                                   *(char **)(&stack0xffffff18 + iVar1),
                                   (int)*(char **)((int)&local_e4 + iVar1));
              if (iVar3 == 0) goto LAB_080ffbfa;
            }
            *tail = '/';
            tail = tail + 1;
            *tail = '\0';
          }
LAB_080ffbfa:
          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ebd8;
          *(char **)(&stack0xffffff14 + iVar1) = result;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffc0d;
          iVar3 = strcmp(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          if (iVar3 == 0) {
            result[5] = '*';
          }
          if (WWW_TraceFlag != '\0') {
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffc2a;
            __stream = TraceFP((&stack0xffffff10)[iVar1]);
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ebdf;
            *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffc3a;
            fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          }
        }
        else {
          *(char **)(&stack0xffffff18 + iVar1) = related.relative;
          *(char **)(&stack0xffffff14 + iVar1) = tail;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffb07;
          strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          if (WWW_TraceFlag != '\0') {
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffb1b;
            __stream = TraceFP((&stack0xffffff10)[iVar1]);
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eba3;
            *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffb2b;
            fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          }
        }
      }
      else {
        *(char **)(&stack0xffffff18 + iVar1) = given.relative;
        *(char **)(&stack0xffffff14 + iVar1) = tail;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffac3;
        strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
        if (WWW_TraceFlag != '\0') {
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffad7;
          __stream = TraceFP((&stack0xffffff10)[iVar1]);
          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb93;
          *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffae7;
          fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
        }
      }
    }
    else {
      base = tail;
      *tail = '/';
      tail = tail + 1;
      *(char **)(&stack0xffffff18 + iVar1) = related.absolute;
      *(char **)(&stack0xffffff14 + iVar1) = tail;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff98a;
      strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      pcVar4 = given.relative;
      if (given.relative != (char *)0x0) {
        if (*given.relative == ';') {
          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x3b;
          *(char **)(&stack0xffffff14 + iVar1) = tail;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff9b5;
          pcVar5 = strchr_or_end(*(char **)(&stack0xffffff14 + iVar1),
                                 *(int *)(&stack0xffffff18 + iVar1));
          *(char **)(&stack0xffffff18 + iVar1) = pcVar4;
          *(char **)(&stack0xffffff14 + iVar1) = pcVar5;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff9c1;
          strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
        }
        else {
          if (*given.relative == '?') {
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x3f;
            *(char **)(&stack0xffffff14 + iVar1) = tail;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff9e6;
            pcVar5 = strchr_or_end(*(char **)(&stack0xffffff14 + iVar1),
                                   *(int *)(&stack0xffffff18 + iVar1));
            *(char **)(&stack0xffffff18 + iVar1) = pcVar4;
            *(char **)(&stack0xffffff14 + iVar1) = pcVar5;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff9f2;
            strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          }
          else {
            *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x3f;
            *(char **)(&stack0xffffff14 + iVar1) = tail;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffa07;
            p = strchr(*(char **)(&stack0xffffff14 + iVar1),*(int *)(&stack0xffffff18 + iVar1));
            if (p == (char *)0x0) {
              *(char **)(&stack0xffffff14 + iVar1) = tail;
              *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffa1b;
              sVar2 = strlen(*(char **)(&stack0xffffff14 + iVar1));
              p = tail + (sVar2 - 1);
            }
            while (*p != '/') {
              p = p + -1;
            }
            p[1] = '\0';
            *(char **)(&stack0xffffff18 + iVar1) = given.relative;
            *(char **)(&stack0xffffff14 + iVar1) = p;
            *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffa4f;
            strcat(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
          }
        }
        *(char **)(&stack0xffffff14 + iVar1) = base;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffa5a;
        HTSimplify(*(char **)(&stack0xffffff14 + iVar1));
        if (*base == '\0') {
          *(char **)((int)&local_e4 + iVar1) = (char *)0x2;
          *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb79;
          *(char **)(&stack0xffffff14 + iVar1) = base;
          *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffa7f;
          memcpy(*(void **)(&stack0xffffff14 + iVar1),*(void **)(&stack0xffffff18 + iVar1),
                 (size_t)*(char **)((int)&local_e4 + iVar1));
        }
      }
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffa93;
        __stream = TraceFP((&stack0xffffff10)[iVar1]);
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb7b;
        *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffaa3;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      }
    }
  }
  else {
    if ((wanted & 1U) != 0) {
      *tail = '/';
      tail = tail + 1;
    }
    *(char **)(&stack0xffffff18 + iVar1) = given.absolute;
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff932;
    strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    if (WWW_TraceFlag != '\0') {
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff946;
      __stream = TraceFP((&stack0xffffff10)[iVar1]);
      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817eb69;
      *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ff956;
      fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    }
  }
  if (want_detail != 0) {
    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x3f;
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffc55;
    pcVar4 = strchr(*(char **)(&stack0xffffff14 + iVar1),*(int *)(&stack0xffffff18 + iVar1));
    if (pcVar4 == (char *)0x0) {
      if ((wanted & 0x40U) != 0) {
        *tail = '\0';
      }
    }
    else {
      *pcVar4 = '\0';
    }
  }
LAB_080ffc76:
  if ((((wanted & 2U) != 0) && (given.anchor != (char *)0x0)) && (*given.anchor != '\0')) {
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffc9c;
    sVar2 = strlen(*(char **)(&stack0xffffff14 + iVar1));
    tail = tail + sVar2;
    if ((wanted & 1U) != 0) {
      *tail = '#';
      tail = tail + 1;
    }
    *(char **)(&stack0xffffff18 + iVar1) = given.anchor;
    *(char **)(&stack0xffffff14 + iVar1) = tail;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffcc5;
    strcpy(*(char **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
  }
  *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x20;
  *(char **)(&stack0xffffff14 + iVar1) = result;
  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffcd8;
  p = strchr(*(char **)(&stack0xffffff14 + iVar1),*(int *)(&stack0xffffff18 + iVar1));
  if (p != (char *)0x0) {
    *(char **)(&stack0xffffff14 + iVar1) = result;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffcf0;
    local_94 = is_url(*(char **)(&stack0xffffff14 + iVar1));
    switch(local_94) {
    default:
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffd82;
        __stream = TraceFP((&stack0xffffff10)[iVar1]);
        *(char **)((int)&local_e4 + iVar1) = result;
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ec30;
        *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffd99;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      }
      do {
        *(char **)(&stack0xffffff14 + iVar1) = p;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffda6;
        sVar2 = strlen(*(char **)(&stack0xffffff14 + iVar1));
        q = p + sVar2 + 2;
        while (p + 1 != q) {
          *q = q[-2];
          q = q + -1;
        }
        *p = '%';
        p[1] = '2';
        p[2] = '0';
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x20;
        *(char **)(&stack0xffffff14 + iVar1) = result;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffdf9;
        p = strchr(*(char **)(&stack0xffffff14 + iVar1),*(int *)(&stack0xffffff18 + iVar1));
      } while (p != (char *)0x0);
      break;
    case UNKNOWN_URL_TYPE:
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffd22;
        __stream = TraceFP((&stack0xffffff10)[iVar1]);
        *(char **)((int)&local_e4 + iVar1) = result;
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ebfa;
        *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffd39;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      }
      break;
    case LYNXCGI_URL_TYPE:
    case LYNXEXEC_URL_TYPE:
    case LYNXPROG_URL_TYPE:
    case LYNXCACHE_URL_TYPE:
    case LYNXCFG_URL_TYPE:
    case LYNXCOMPILE_OPTS_URL_TYPE:
    case LYNXCOOKIE_URL_TYPE:
    case LYNXDIRED_URL_TYPE:
    case LYNXDOWNLOAD_URL_TYPE:
    case LYNXHIST_URL_TYPE:
    case LYNXIMGMAP_URL_TYPE:
    case LYNXKEYMAP_URL_TYPE:
    case LYNXMESSAGES_URL_TYPE:
    case LYNXOPTIONS_URL_TYPE:
    case LYNXPRINT_URL_TYPE:
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffd54;
        __stream = TraceFP((&stack0xffffff10)[iVar1]);
        *(char **)((int)&local_e4 + iVar1) = result;
        *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ec15;
        *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
        *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffd6b;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffe12;
    __stream = TraceFP((&stack0xffffff10)[iVar1]);
    *(char **)((int)&local_e4 + iVar1) = result;
    *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ec4b;
    *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffe29;
    fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
  }
  *(char **)(&stack0xffffff18 + iVar1) = result;
  *(char ***)(&stack0xffffff14 + iVar1) = &return_value;
  *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffe3d;
  HTSACopy(*(char ***)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
  if ((*local_90 != '\0') && ((wanted & 0x1dU) == 0x1d)) {
    *(char **)(&stack0xffffff18 + iVar1) = local_90;
    *(char ***)(&stack0xffffff14 + iVar1) = &return_value;
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffe6a;
    LYFillLocalFileURL(*(char ***)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    pcVar4 = return_value;
    if (WWW_TraceFlag != '\0') {
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffe7d;
      __stream = TraceFP((&stack0xffffff10)[iVar1]);
      *(char **)((int)&local_e4 + iVar1) = pcVar4;
      *(undefined4 *)(&stack0xffffff18 + iVar1) = 0x817ec66;
      *(FILE **)(&stack0xffffff14 + iVar1) = __stream;
      *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffe91;
      fprintf(*(FILE **)(&stack0xffffff14 + iVar1),*(char **)(&stack0xffffff18 + iVar1));
    }
  }
  if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)(&stack0xffffff10 + iVar1) = 0x80ffea7;
    __stack_chk_fail();
  }
  return return_value;
}



char * HTParseAnchor(char *aName)

{
  int iVar1;
  size_t sVar2;
  undefined *puVar3;
  int in_GS_OFFSET;
  struct_parts *apsStack72 [2];
  char *local_40;
  struct_parts *local_3c;
  struct_parts given;
  char *name;
  char *p;
  int local_c;
  
  local_3c = (struct_parts *)aName;
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  p = aName;
  while ((*p != '\0' && (*p != '#'))) {
    p = p + 1;
  }
  puVar3 = &stack0xffffffb4;
  if (*p == '#') {
    sVar2 = strlen(p);
    iVar1 = -((uint)(p + (sVar2 - (int)aName) + 0x1f) & 0xfffffff0);
    name = (char *)((int)apsStack72 + iVar1 + 8);
    local_40 = name;
    if (name == (char *)0x0) {
      *(struct_parts **)((int)apsStack72 + iVar1) = (struct_parts *)0x817ed34;
      *(undefined4 *)(&stack0xffffffb4 + iVar1) = 0x817ead0;
      *(undefined4 *)(&stack0xffffffb0 + iVar1) = 0x80fff55;
      outofmem(*(char **)(&stack0xffffffb4 + iVar1),
               (char *)*(struct_parts **)((int)apsStack72 + iVar1));
    }
    *(struct_parts **)((int)apsStack72 + iVar1) = local_3c;
    *(char **)(&stack0xffffffb4 + iVar1) = name;
    *(undefined4 *)(&stack0xffffffb0 + iVar1) = 0x80fff67;
    strcpy(*(char **)(&stack0xffffffb4 + iVar1),(char *)*(struct_parts **)((int)apsStack72 + iVar1))
    ;
    *(struct_parts **)((int)apsStack72 + iVar1) = &given;
    *(char **)(&stack0xffffffb4 + iVar1) = name;
    *(undefined4 *)(&stack0xffffffb0 + iVar1) = 0x80fff79;
    scan(*(char **)(&stack0xffffffb4 + iVar1),*(struct_parts **)((int)apsStack72 + iVar1));
    p = p + 1;
    puVar3 = &stack0xffffffb4 + iVar1;
    if (given.anchor == (char *)0x0) {
      while (puVar3 = &stack0xffffffb4 + iVar1, *p != '\0') {
        p = p + 1;
      }
    }
  }
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return p;
  }
                    // WARNING: Subroutine does not return
  *(undefined4 *)(puVar3 + -4) = 0x80fffa8;
  __stack_chk_fail();
}



void HTSimplify(char *filename)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  char *q1;
  char *q;
  char *p;
  
  if ((((((filename != (char *)0x0) && (*filename != '\0')) && (filename[1] != '\0')) &&
       ((*filename != '?' && (filename[1] != '?')))) && (filename[2] != '?')) &&
     (pcVar2 = strchr(filename,0x2f), pcVar2 != (char *)0x0)) {
    p = filename + 2;
    while ((*p != '\0' && (*p != '?'))) {
      if (*p == '/') {
        if (((p[1] == '.') && (p[2] == '.')) &&
           ((pcVar2 = p, p[3] == '/' || ((p[3] == '?' || (p[3] == '\0')))))) {
          do {
            pcVar1 = pcVar2;
            q = pcVar1 + -1;
            if (q < filename) break;
            pcVar2 = q;
          } while (*q != '/');
          if ((((*q == '/') && (iVar3 = strncmp(q,"/../",4), iVar3 != 0)) &&
              (iVar3 = strncmp(q,"/..?",4), iVar3 != 0)) &&
             ((pcVar1 + -2 <= filename || (pcVar1[-2] != '/')))) {
            q1 = p + 3;
            p = q;
            while (*q1 != '\0') {
              *p = *q1;
              p = p + 1;
              q1 = q1 + 1;
            }
            *p = '\0';
            p = pcVar1 + -2;
          }
        }
        else {
          if ((p[1] == '.') && (p[2] == '/')) {
            q = p;
            q1 = p + 2;
            while (*q1 != '\0') {
              *q = *q1;
              q = q + 1;
              q1 = q1 + 1;
            }
            *q = '\0';
            p = p + -1;
          }
          else {
            if ((p[1] == '.') && (p[2] == '?')) {
              q1 = p + 2;
              q = p;
              while (q = q + 1, *q1 != '\0') {
                *q = *q1;
                q1 = q1 + 1;
              }
              *q = '\0';
              p = p + -1;
            }
            else {
              if ((p[1] == '.') && (p[2] == '\0')) {
                p[1] = '\0';
              }
            }
          }
        }
      }
      p = p + 1;
    }
    if (((filename + 2 <= p) && (*p == '?')) && (p[-1] == '.')) {
      if (p[-2] == '/') {
        q = p + -1;
        q1 = p;
        while (*q1 != '\0') {
          *q = *q1;
          q = q + 1;
          q1 = q1 + 1;
        }
        *q = '\0';
      }
      else {
        if ((((p[-2] == '.') && (filename + 4 <= p)) && (p[-3] == '/')) &&
           ((p[-4] != '/' || ((filename + 4 < p && (p[-5] != ':')))))) {
          q = p + -4;
          while ((filename < q && (*q != '/'))) {
            q = q + -1;
          }
          if (*q == '/') {
            if ((filename < q) && (q[-1] == '/')) {
              if (q <= filename + 1) {
                return;
              }
              if (q[-1] == ':') {
                return;
              }
            }
            q = q + 1;
          }
          iVar3 = strncmp(q,"../",3);
          if ((iVar3 != 0) && (iVar3 = strncmp(q,"./",2), iVar3 != 0)) {
            q1 = p;
            p = q;
            while (*q1 != '\0') {
              *p = *q1;
              p = p + 1;
              q1 = q1 + 1;
            }
            *p = '\0';
          }
        }
      }
    }
  }
  return;
}



char * HTRelative(char *aName,char *relatedName)

{
  char *pcVar1;
  size_t sVar2;
  FILE *__stream;
  int levels;
  int slashes;
  char *last_slash;
  char *path;
  char *after_access;
  char *q;
  char *p;
  char *result;
  
  result = (char *)0x0;
  p = aName;
  q = relatedName;
  after_access = (char *)0x0;
  path = (char *)0x0;
  last_slash = (char *)0x0;
  slashes = 0;
  while ((*p != '\0' && (*p == *q))) {
    if (*p == ':') {
      after_access = p + 1;
    }
    if (*p == '/') {
      last_slash = p;
      slashes = slashes + 1;
      if (slashes == 3) {
        path = p;
      }
    }
    p = p + 1;
    q = q + 1;
  }
  if (after_access == (char *)0x0) {
    HTSACopy(&result,aName);
  }
  else {
    if (slashes < 3) {
      HTSACopy(&result,after_access);
    }
    else {
      if (slashes == 3) {
        HTSACopy(&result,path);
      }
      else {
        levels = 0;
        while ((*q != '\0' && (*q != '#'))) {
          if (*q == '/') {
            levels = levels + 1;
          }
          q = q + 1;
        }
        sVar2 = strlen(last_slash);
        result = (char *)calloc(levels * 3 + sVar2 + 1,1);
        if (result == (char *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTParse.c","HTRelative");
        }
        *result = '\0';
        while (levels != 0) {
          strcat(result,"../");
          levels = levels + -1;
        }
        strcat(result,last_slash + 1);
      }
    }
  }
  pcVar1 = result;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n",aName,
            relatedName,pcVar1);
  }
  return result;
}



char * HTEscape(char *str,uchar mask)

{
  byte bVar1;
  char *pcVar2;
  uint unacceptable;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  unacceptable = 0;
  p = str;
  while (*p != '\0') {
    if ((((byte)*p < 0x20) || (*p < '\0')) ||
       (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[(uint)(byte)*p + 0x20] &
        mask) == 0)) {
      unacceptable = unacceptable + 1;
    }
    p = p + 1;
  }
  pcVar2 = (char *)calloc((size_t)(p + (unacceptable * 2 - (int)str) + 1),1);
  if (pcVar2 == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTParse.c","HTEscape");
  }
  p = str;
  q = pcVar2;
  while (*p != '\0') {
    bVar1 = *p;
    if (((bVar1 < 0x20) || ((char)bVar1 < '\0')) ||
       (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[(uint)bVar1 + 0x20] & mask
        ) == 0)) {
      *q = '%';
      q[1] = hex[bVar1 >> 4];
      q[2] = hex[(uint)bVar1 & 0xf];
      q = q + 3;
    }
    else {
      *q = *p;
      q = q + 1;
    }
    p = p + 1;
  }
  *q = '\0';
  return pcVar2;
}



char * HTEscapeUnsafe(char *str)

{
  byte bVar1;
  char *pcVar2;
  uint unacceptable;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  unacceptable = 0;
  p = str;
  while (*p != '\0') {
    if (((byte)*p < 0x21) || (0x7e < (byte)*p)) {
      unacceptable = unacceptable + 1;
    }
    p = p + 1;
  }
  pcVar2 = (char *)calloc((size_t)(p + (unacceptable * 2 - (int)str) + 1),1);
  if (pcVar2 == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTParse.c","HTEscapeUnsafe");
  }
  p = str;
  q = pcVar2;
  while (*p != '\0') {
    bVar1 = *p;
    if ((bVar1 < 0x21) || (0x7e < bVar1)) {
      *q = '%';
      q[1] = hex[bVar1 >> 4];
      q[2] = hex[(uint)bVar1 & 0xf];
      q = q + 3;
    }
    else {
      *q = *p;
      q = q + 1;
    }
    p = p + 1;
  }
  *q = '\0';
  return pcVar2;
}



char * HTEscapeSP(char *str,uchar mask)

{
  byte bVar1;
  char *pcVar2;
  uint unacceptable;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  unacceptable = 0;
  p = str;
  while (*p != '\0') {
    if ((*p != ' ') &&
       ((((byte)*p < 0x20 || (*p < '\0')) ||
        (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[(uint)(byte)*p + 0x20] &
         mask) == 0)))) {
      unacceptable = unacceptable + 1;
    }
    p = p + 1;
  }
  pcVar2 = (char *)calloc((size_t)(p + (unacceptable * 2 - (int)str) + 1),1);
  if (pcVar2 == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTParse.c","HTEscape");
  }
  p = str;
  q = pcVar2;
  while (*p != '\0') {
    bVar1 = *p;
    if (bVar1 == 0x20) {
      *q = '+';
      q = q + 1;
    }
    else {
      if (((bVar1 < 0x20) || ((char)bVar1 < '\0')) ||
         (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[(uint)bVar1 + 0x20] &
          mask) == 0)) {
        *q = '%';
        q[1] = hex[bVar1 >> 4];
        q[2] = hex[(uint)bVar1 & 0xf];
        q = q + 3;
      }
      else {
        *q = *p;
        q = q + 1;
      }
    }
    p = p + 1;
  }
  *q = '\0';
  return pcVar2;
}



char from_hex(char c)

{
  char local_a;
  char local_9;
  
  if ((c < '0') || ('9' < c)) {
    if ((c < 'A') || ('F' < c)) {
      local_9 = c + -0x57;
    }
    else {
      local_9 = c + -0x37;
    }
    local_a = local_9;
  }
  else {
    local_a = c + -0x30;
  }
  return local_a;
}



char * HTUnEscape(char *str)

{
  char *pcVar1;
  char cVar2;
  char c;
  ushort **ppuVar3;
  char *q;
  char *p;
  
  p = str;
  q = str;
  if ((str != (char *)0x0) && (*str != '\0')) {
    while (*p != '\0') {
      if ((((*p == '%') && (p[1] != '\0')) && (p[2] != '\0')) &&
         ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[1]] & 0x1000) != 0 &&
          (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[2]] & 0x1000) != 0)))) {
        pcVar1 = p + 1;
        if (*pcVar1 != '\0') {
          cVar2 = from_hex(*pcVar1);
          *q = (char)((int)cVar2 << 4);
          pcVar1 = p + 2;
        }
        p = pcVar1;
        if (*p != '\0') {
          cVar2 = *q;
          c = *p;
          p = p + 1;
          c = from_hex(c);
          *q = cVar2 + c;
        }
        *q = *q;
        q = q + 1;
      }
      else {
        *q = *p;
        q = q + 1;
        p = p + 1;
      }
    }
    *q = '\0';
  }
  return str;
}



char * HTUnEscapeSome(char *str,char *do_trans)

{
  char cVar1;
  char cVar2;
  ushort **ppuVar3;
  char *pcVar4;
  char *q;
  char *p;
  char testcode;
  
  p = str;
  q = str;
  if ((((str != (char *)0x0) && (*str != '\0')) && (do_trans != (char *)0x0)) && (*do_trans != '\0')
     ) {
    while (*p != '\0') {
      if (((*p == '%') && (p[1] != '\0')) &&
         ((p[2] != '\0' &&
          ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[1]] & 0x1000) != 0 &&
           (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[2]] & 0x1000) != 0)))))) {
        cVar1 = from_hex(p[1]);
        cVar2 = from_hex(p[2]);
        cVar2 = cVar1 * '\x10' + cVar2;
        if ((cVar2 == '\0') || (pcVar4 = strchr(do_trans,(int)cVar2), pcVar4 == (char *)0x0))
        goto LAB_08100c87;
        *q = cVar2;
        q = q + 1;
        p = p + 3;
      }
      else {
LAB_08100c87:
        *q = *p;
        q = q + 1;
        p = p + 1;
      }
    }
    *q = '\0';
  }
  return str;
}



void HTMake822Word(char **str,int quoted)

{
  byte bVar1;
  char *pcVar2;
  char *pcVar3;
  char *local_28;
  uint added;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  added = 0;
  if ((*str == (char *)0x0) || (**str == '\0')) {
    if (quoted == 0) {
      local_28 = "";
    }
    else {
      local_28 = "\"\"";
    }
    HTSACopy(str,local_28);
  }
  else {
    p = *str;
    while (*p != '\0') {
      bVar1 = *p;
      if (((bVar1 < 0x20) || ((char)bVar1 < '\0')) ||
         (("HTEscapeUnsafe"[(uint)bVar1 + 6] & 1U) != 0)) {
        if (added == 0) {
          added = 2;
        }
        if ((bVar1 < 0xa0) && (bVar1 != 9)) {
          if ((bVar1 == 0xd) || (bVar1 == 10)) {
            added = added + 2;
          }
          else {
            if (((bVar1 & 0x7f) < 0x20) || (("HTEscapeUnsafe"[(uint)bVar1 + 6] & 2U) != 0)) {
              added = added + 1;
            }
          }
        }
      }
      p = p + 1;
    }
    if (added != 0) {
      pcVar3 = (char *)calloc((size_t)(p + (added - (int)*str) + 1),1);
      if (pcVar3 == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTParse.c","HTMake822Word");
      }
      q = pcVar3;
      if (quoted != 0) {
        *pcVar3 = '\"';
        q = pcVar3 + 1;
      }
      p = *str;
      while (*p != '\0') {
        bVar1 = *p;
        if ((bVar1 != 9) &&
           (((bVar1 & 0x7f) < 0x20 ||
            ((-1 < (char)bVar1 && (("HTEscapeUnsafe"[(uint)bVar1 + 6] & 2U) != 0)))))) {
          *q = '\\';
          q = q + 1;
        }
        *q = *p;
        pcVar2 = q + 1;
        if ((bVar1 == 10) || ((bVar1 == 0xd && (p[1] != '\n')))) {
          *pcVar2 = ' ';
          pcVar2 = q + 2;
        }
        q = pcVar2;
        p = p + 1;
      }
      if (quoted != 0) {
        *q = '\"';
        q = q + 1;
      }
      *q = '\0';
      if (*str != (char *)0x0) {
        free(*str);
        *str = (char *)0x0;
      }
      *str = pcVar3;
    }
  }
  return;
}



BOOLEAN HTRegisterProtocol(HTProtocol *protocol)

{
  if (protocols == (HTList *)0x0) {
    protocols = HTList_new();
  }
  HTList_addObject(protocols,protocol);
  return '\x01';
}



void HTAccessInit(void)

{
  HTRegisterProtocol(&HTTP);
  HTRegisterProtocol(&HTTPS);
  HTRegisterProtocol(&HTFile);
  HTRegisterProtocol(&HTTelnet);
  HTRegisterProtocol(&HTTn3270);
  HTRegisterProtocol(&HTRlogin);
  HTRegisterProtocol(&HTFTP);
  HTRegisterProtocol(&HTNews);
  HTRegisterProtocol(&HTNNTP);
  HTRegisterProtocol(&HTNewsPost);
  HTRegisterProtocol(&HTNewsReply);
  HTRegisterProtocol(&HTSNews);
  HTRegisterProtocol(&HTSNewsPost);
  HTRegisterProtocol(&HTSNewsReply);
  HTRegisterProtocol(&HTGopher);
  HTRegisterProtocol(&HTCSO);
  HTRegisterProtocol(&HTFinger);
  LYRegisterLynxProtocols();
  return;
}



BOOLEAN override_proxy(char *addr)

{
  int iVar1;
  char *__s;
  char *__s2;
  char *__s2_00;
  size_t sVar2;
  ushort **ppuVar3;
  char *local_38;
  int t_len;
  int templ_port;
  char *colon;
  char *end;
  int h_len;
  int port;
  char *acc_method;
  char *Host;
  char *host;
  char *at;
  char *p;
  char *no_proxy;
  
  no_proxy = getenv("no_proxy");
  port = 0;
  if ((no_proxy != (char *)0x0) && (iVar1 = strcmp(no_proxy,"*"), iVar1 == 0)) {
    return '\x01';
  }
  if (addr == (char *)0x0) {
    return '\0';
  }
  __s = HTParse(addr,"",8);
  if (__s == (char *)0x0) {
    return '\0';
  }
  if (*__s == '\0') {
    if (__s != (char *)0x0) {
      free(__s);
    }
    return '\0';
  }
  __s2 = strchr(__s,0x40);
  local_38 = __s;
  if (__s2 != (char *)0x0) {
    local_38 = __s2 + 1;
  }
  __s2 = HTParse(addr,"",0x10);
  if (__s2 != (char *)0x0) {
    iVar1 = strcmp("file",__s2);
    if (iVar1 == 0) {
      iVar1 = strcmp(local_38,"localhost");
      if (iVar1 == 0) {
LAB_0810116a:
        if (__s != (char *)0x0) {
          free(__s);
        }
        if (__s2 != (char *)0x0) {
          free(__s2);
        }
        return '\x01';
      }
      __s2_00 = HTHostName();
      iVar1 = strcmp(local_38,__s2_00);
      if (iVar1 == 0) goto LAB_0810116a;
    }
    if (__s2 != (char *)0x0) {
      free(__s2);
    }
  }
  if (no_proxy == (char *)0x0) {
    if (__s != (char *)0x0) {
      free(__s);
    }
  }
  else {
    __s2 = strrchr(local_38,0x3a);
    if (__s2 == (char *)0x0) {
      __s2 = HTParse(addr,"",0x10);
      if (__s2 != (char *)0x0) {
        iVar1 = strcmp(__s2,"http");
        if (iVar1 == 0) {
          port = 0x50;
        }
        else {
          iVar1 = strcmp(__s2,"https");
          if (iVar1 == 0) {
            port = 0x1bb;
          }
          else {
            iVar1 = strcmp(__s2,"ftp");
            if (iVar1 == 0) {
              port = 0x15;
            }
            else {
              iVar1 = strcmp(__s2,"gopher");
              if (iVar1 == 0) {
                port = 0x46;
              }
              else {
                iVar1 = strcmp(__s2,"cso");
                if (iVar1 == 0) {
                  port = 0x69;
                }
                else {
                  iVar1 = strcmp(__s2,"news");
                  if (iVar1 == 0) {
                    port = 0x77;
                  }
                  else {
                    iVar1 = strcmp(__s2,"nntp");
                    if (iVar1 == 0) {
                      port = 0x77;
                    }
                    else {
                      iVar1 = strcmp(__s2,"newspost");
                      if (iVar1 == 0) {
                        port = 0x77;
                      }
                      else {
                        iVar1 = strcmp(__s2,"newsreply");
                        if (iVar1 == 0) {
                          port = 0x77;
                        }
                        else {
                          iVar1 = strcmp(__s2,"snews");
                          if (iVar1 == 0) {
                            port = 0x233;
                          }
                          else {
                            iVar1 = strcmp(__s2,"snewspost");
                            if (iVar1 == 0) {
                              port = 0x233;
                            }
                            else {
                              iVar1 = strcmp(__s2,"snewsreply");
                              if (iVar1 == 0) {
                                port = 0x233;
                              }
                              else {
                                iVar1 = strcmp(__s2,"wais");
                                if (iVar1 == 0) {
                                  port = 0xd2;
                                }
                                else {
                                  iVar1 = strcmp(__s2,"finger");
                                  if (iVar1 == 0) {
                                    port = 0x4f;
                                  }
                                  else {
                                    iVar1 = strcmp(__s2,"telnet");
                                    if (iVar1 == 0) {
                                      port = 0x17;
                                    }
                                    else {
                                      iVar1 = strcmp(__s2,"tn3270");
                                      if (iVar1 == 0) {
                                        port = 0x17;
                                      }
                                      else {
                                        iVar1 = strcmp(__s2,"rlogin");
                                        if (iVar1 == 0) {
                                          port = 0x201;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (__s2 != (char *)0x0) {
          free(__s2);
        }
      }
    }
    else {
      *__s2 = '\0';
      port = atoi(__s2 + 1);
    }
    if (port == 0) {
      port = 0x50;
    }
    sVar2 = strlen(local_38);
    while (*no_proxy != '\0') {
      colon = (char *)0x0;
      templ_port = 0;
      while ((*no_proxy != '\0' && (((byte)*no_proxy < 0x21 || (*no_proxy == ','))))) {
        no_proxy = no_proxy + 1;
      }
      end = no_proxy;
      while (((*end != '\0' && (0x20 < (byte)*end)) && (*end != ','))) {
        if (*end == ':') {
          colon = end;
        }
        end = end + 1;
      }
      if (colon == (char *)0x0) {
        t_len = (int)(end + -(int)no_proxy);
      }
      else {
        templ_port = atoi(colon + 1);
        t_len = (int)(colon + -(int)no_proxy);
      }
      if (((templ_port == 0) || (templ_port == port)) &&
         ((0 < t_len &&
          ((t_len <= (int)sVar2 &&
           (iVar1 = strncasecomp(local_38 + (sVar2 - t_len),no_proxy,t_len), iVar1 == 0)))))) {
        if (__s != (char *)0x0) {
          free(__s);
        }
        return '\x01';
      }
      if (((((templ_port == 0) || (templ_port == port)) && (0 < t_len)) &&
          ((t_len <= (int)sVar2 &&
           (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*no_proxy] & 0x800) != 0)))) &&
         (iVar1 = strncmp(__s,no_proxy,t_len), iVar1 == 0)) {
        if (__s != (char *)0x0) {
          free(__s);
        }
        return '\x01';
      }
      if (*end == '\0') break;
      no_proxy = end + 1;
    }
    if (__s != (char *)0x0) {
      free(__s);
    }
  }
  return '\0';
}



int get_physical(char *addr,HTParentAnchor *anchor)

{
  FILE *__stream;
  int iVar1;
  char *aName;
  char *src;
  char **protocol;
  int iVar2;
  int local_58;
  HTProtocol *p;
  int n;
  int i;
  char *gatewayed_1;
  char *path;
  char *cp;
  char *gatewayed;
  char *proxy;
  char *gateway;
  char *gateway_parameter;
  char *host_1;
  char *host;
  char *Server_addr;
  char *physical;
  char *acc_method;
  int result;
  BOOLEAN override_flag;
  
  physical = (char *)0x0;
  Server_addr = (char *)0x0;
  override_flag = '\0';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"get_physical %s\n",addr);
  }
  using_proxy = '\0';
  physical = HTTranslate(addr);
  if (physical == (char *)0x0) {
    if (redirecting_url == (char *)0x0) {
      local_58 = -0x193;
    }
    else {
      local_58 = 399;
    }
  }
  else {
    if (anchor->isISMAPScript == '\x01') {
      HTSACat(&physical,"?0,0");
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTAccess: Appending \'?0,0\' coordinate pair.\n");
      }
    }
    iVar1 = strncmp(physical,"Proxied=",8);
    if (iVar1 == 0) {
      HTAnchor_setPhysical(anchor,physical + 8);
      using_proxy = '\x01';
    }
    else {
      iVar1 = strncmp(physical,"NoProxy=",8);
      if (iVar1 == 0) {
        HTAnchor_setPhysical(anchor,physical + 8);
        override_flag = '\x01';
      }
      else {
        HTAnchor_setPhysical(anchor,physical);
      }
    }
    if (physical != (char *)0x0) {
      free(physical);
      physical = (char *)0x0;
    }
    aName = HTAnchor_physical(anchor);
    acc_method = HTParse(aName,"file:",0x10);
    if ((override_flag == '\0') && (using_proxy == '\0')) {
      iVar1 = strcasecomp(acc_method,"news");
      if (iVar1 == 0) {
        aName = HTParse(addr,"",8);
        if (aName == (char *)0x0) {
          aName = LYGetEnv("NNTPSERVER");
          if (aName != (char *)0x0) {
            HTSACopy(&Server_addr,"news://");
            aName = LYGetEnv("NNTPSERVER");
            HTSACat(&Server_addr,aName);
            HTSACat(&Server_addr,":119/");
          }
        }
        else {
          src = strchr(aName,0x3a);
          if (src == (char *)0x0) {
            HTSACopy(&Server_addr,"news://");
            HTSACat(&Server_addr,aName);
            HTSACat(&Server_addr,":119/");
          }
          if (aName != (char *)0x0) {
            free(aName);
          }
        }
      }
      else {
        iVar1 = strcasecomp(acc_method,"wais");
        if (iVar1 == 0) {
          aName = HTParse(addr,"",8);
          if (aName == (char *)0x0) {
            HTSACopy(&Server_addr,addr);
          }
          else {
            src = strchr(aName,0x3a);
            if (src == (char *)0x0) {
              HTSACopy(&Server_addr,"wais://");
              HTSACat(&Server_addr,aName);
              HTSACat(&Server_addr,":210/");
            }
            if (aName != (char *)0x0) {
              free(aName);
            }
          }
        }
        else {
          HTSACopy(&Server_addr,addr);
        }
      }
      override_flag = override_proxy(Server_addr);
    }
    if ((override_flag == '\0') && (using_proxy == '\0')) {
      gateway_parameter = (char *)0x0;
      HTSprintf0(&gateway_parameter,"WWW_%s_GATEWAY",acc_method);
      aName = LYGetEnv(gateway_parameter);
      iVar1 = strcmp(acc_method,"file");
      if (iVar1 == 0) {
        memcpy(gateway_parameter,"ftp_proxy",10);
      }
      else {
        sprintf(gateway_parameter,"%s_proxy",acc_method);
      }
      src = LYGetEnv(gateway_parameter);
      if (gateway_parameter != (char *)0x0) {
        free(gateway_parameter);
        gateway_parameter = (char *)0x0;
      }
      if ((aName != (char *)0x0) && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Gateway found: %s\n",aName);
      }
      if ((src != (char *)0x0) && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"proxy server found: %s\n",src);
      }
      if (src == (char *)0x0) {
        if (aName != (char *)0x0) {
          src = HTParse(addr,"",0xd);
          aName = HTParse(src + 1,aName,0x1f);
          if (src != (char *)0x0) {
            free(src);
          }
          HTAnchor_setPhysical(anchor,aName);
          if (aName != (char *)0x0) {
            free(aName);
          }
          if (acc_method != (char *)0x0) {
            free(acc_method);
          }
          aName = HTAnchor_physical(anchor);
          acc_method = HTParse(aName,"http:",0x10);
        }
      }
      else {
        gatewayed = (char *)0x0;
        HTSACopy(&gatewayed,src);
        iVar1 = strncmp(gatewayed,"http",4);
        if (iVar1 == 0) {
          aName = strrchr(gatewayed,0x2f);
          if ((aName != (char *)0x0) && ((int)(aName + -(int)gatewayed) < 8)) {
            LYAddHtmlSep(&gatewayed);
          }
        }
        iVar1 = strncmp(addr,"file",4);
        if (iVar1 == 0) {
          HTSACat(&gatewayed,"ftp");
          HTSACat(&gatewayed,addr + 4);
        }
        else {
          HTSACat(&gatewayed,addr);
        }
        using_proxy = '\x01';
        if (anchor->isISMAPScript == '\x01') {
          HTSACat(&gatewayed,"?0,0");
        }
        HTAnchor_setPhysical(anchor,gatewayed);
        if (gatewayed != (char *)0x0) {
          free(gatewayed);
          gatewayed = (char *)0x0;
        }
        if (acc_method != (char *)0x0) {
          free(acc_method);
        }
        aName = HTAnchor_physical(anchor);
        acc_method = HTParse(aName,"http:",0x10);
      }
    }
    if (Server_addr != (char *)0x0) {
      free(Server_addr);
      Server_addr = (char *)0x0;
    }
    result = -0x191;
    if (protocols == (HTList *)0x0) {
      HTAccessInit();
    }
    iVar1 = HTList_count(protocols);
    i = 0;
    while (i < iVar1) {
      protocol = (char **)HTList_objectAt(protocols,i);
      iVar2 = strcmp(*protocol,acc_method);
      if (iVar2 == 0) {
        HTAnchor_setProtocol(anchor,protocol);
        if (acc_method != (char *)0x0) {
          free(acc_method);
          acc_method = (char *)0x0;
        }
        result = 0;
        break;
      }
      i = i + 1;
    }
    if (acc_method != (char *)0x0) {
      free(acc_method);
    }
    local_58 = result;
  }
  return local_58;
}



void LYUCPushAssumed(HTParentAnchor *anchor)

{
  int iVar1;
  char *src;
  int iVar2;
  FILE *__stream;
  LYUCcharset *anchor_UCI;
  int anchor_LYhndl;
  
  anchor_UCI = (LYUCcharset *)0x0;
  if (anchor != (HTParentAnchor *)0x0) {
    iVar2 = HTAnchor_getUCLYhndl(anchor,1);
    if (-1 < iVar2) {
      anchor_UCI = HTAnchor_getUCInfoStage(anchor,1);
    }
    src = UCAssume_MIMEcharset;
    if ((anchor_UCI != (LYUCcharset *)0x0) && (anchor_UCI->MIMEname != (char *)0x0)) {
      pushed_assume_MIMEname = UCAssume_MIMEcharset;
      UCAssume_MIMEcharset = (char *)0x0;
      if (HTCJK == JAPANESE) {
        HTSACopy(&UCAssume_MIMEcharset,src);
      }
      else {
        HTSACopy(&UCAssume_MIMEcharset,anchor_UCI->MIMEname);
      }
      iVar1 = UCLYhndl_for_unspec;
      if (UCLYhndl_for_unspec == iVar2) {
        UCLYhndl_for_unspec = iVar2;
        pushed_assume_LYhndl = iVar2;
        return;
      }
      if (WWW_TraceFlag == '\0') {
        UCLYhndl_for_unspec = iVar2;
        pushed_assume_LYhndl = iVar2;
        return;
      }
      pushed_assume_LYhndl = iVar2;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",iVar1,iVar2
             );
      UCLYhndl_for_unspec = iVar2;
      return;
    }
  }
  pushed_assume_LYhndl = -1;
  if (pushed_assume_MIMEname != (char *)0x0) {
    free(pushed_assume_MIMEname);
    pushed_assume_MIMEname = (char *)0x0;
  }
  return;
}



int LYUCPopAssumed(void)

{
  int iVar1;
  int iVar2;
  FILE *__stream;
  int local_10;
  
  iVar2 = pushed_assume_LYhndl;
  iVar1 = UCLYhndl_for_unspec;
  if (pushed_assume_LYhndl < 0) {
    local_10 = -1;
  }
  else {
    if ((UCLYhndl_for_unspec != pushed_assume_LYhndl) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",iVar1,iVar2)
      ;
    }
    UCLYhndl_for_unspec = pushed_assume_LYhndl;
    pushed_assume_LYhndl = -1;
    if (UCAssume_MIMEcharset != (char *)0x0) {
      free(UCAssume_MIMEcharset);
    }
    UCAssume_MIMEcharset = pushed_assume_MIMEname;
    pushed_assume_MIMEname = (char *)0x0;
    local_10 = UCLYhndl_for_unspec;
  }
  return local_10;
}



int HTLoad(char *addr,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  code *pcVar1;
  char *physical;
  void *pvVar2;
  int status;
  HTProtocol *p;
  
  status = get_physical(addr,anchor);
  if (status == -0x193) {
    LYFixCursesOn("show alert:");
    physical = (char *)gettext("Access forbidden by rule");
    status = HTLoadError(sink,500,physical);
  }
  else {
    if ((status != 399) && (-1 < status)) {
      physical = HTAnchor_physical(anchor);
      LYFixCursesOnForAccess(addr,physical);
      pvVar2 = HTAnchor_protocol(anchor);
      anchor->parent->underway = '\x01';
      pcVar1 = *(code **)((int)pvVar2 + 4);
      physical = HTAnchor_physical(anchor);
      status = (*pcVar1)(physical,anchor,format_out,sink);
      anchor->parent->underway = '\0';
      LYUCPopAssumed();
    }
  }
  return status;
}



HTStream * HTSaveStream(HTParentAnchor *anchor)

{
  void *pvVar1;
  HTStream *local_18;
  HTProtocol *p;
  
  pvVar1 = HTAnchor_protocol(anchor);
  if (pvVar1 == (void *)0x0) {
    local_18 = (HTStream *)0x0;
  }
  else {
    local_18 = (HTStream *)(**(code **)((int)pvVar1 + 8))(anchor);
  }
  return local_18;
}



BOOLEAN HTLoadDocument(char *full_address,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  BOOLEAN BVar1;
  FILE *__stream;
  char *Msg;
  HyperDoc *pHVar2;
  int iVar3;
  HText *text_00;
  HTFormat pHVar4;
  HTAtom *pHVar5;
  HText *pHVar6;
  BOOLEAN local_49;
  undefined *local_48;
  char *local_44;
  undefined *local_40;
  char *local_3c;
  DocAddress NewDoc;
  time_t theTime;
  char *cp;
  char *address_to_load;
  HText *text;
  int status;
  BOOLEAN ForcingNoCache;
  
  ForcingNoCache = LYforce_no_cache;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTAccess: loading document %s\n",full_address);
  }
  if (use_this_url_instead != (char *)0x0) {
    free(use_this_url_instead);
    use_this_url_instead = (char *)0x0;
  }
  permanent_redirection = '\0';
  if (redirection_attempts < 0xb) {
    pHVar2 = HTAnchor_document(anchor);
    if ((((LYinternal_flag != '\0') && (pHVar2 == (HyperDoc *)0x0)) && (LYforce_no_cache == '\0'))
       && (((anchor->post_data != (bstring *)0x0 && (anchor->safe == '\0')) &&
           (iVar3 = strncasecomp(full_address,"LYNXIMGMAP:",0xb), iVar3 != 0)))) {
      Msg = (char *)gettext("Document with POST content not found in cache.  Resubmit?");
      BVar1 = HTConfirm(Msg);
      if (BVar1 != '\x01') {
        return '\0';
      }
    }
    if (anchor->post_data == (bstring *)0x0) {
      while ((cp = HTAnchor_physical(anchor), cp != (char *)0x0 &&
             (iVar3 = strncmp(cp,"Location=",9), iVar3 == 0))) {
        if (WWW_TraceFlag != '\0') {
          Msg = anchor->address;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTAccess: \'%s\' is a redirection URL.\n",Msg);
        }
        if (WWW_TraceFlag != '\0') {
          Msg = cp + 9;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTAccess: Redirecting to \'%s\'\n",Msg);
        }
        redirection_attempts = redirection_attempts + 1;
        if (10 < redirection_attempts) {
          Msg = (char *)gettext("Redirection limit of 10 URL\'s reached.");
          HTAlert(Msg);
          redirection_attempts = 0;
          if (use_this_url_instead != (char *)0x0) {
            free(use_this_url_instead);
            use_this_url_instead = (char *)0x0;
          }
          return '\0';
        }
        HTSACopy(&use_this_url_instead,cp + 9);
        NewDoc.address = use_this_url_instead;
        NewDoc.post_data = (bstring *)0x0;
        NewDoc.post_content_type = (char *)0x0;
        NewDoc.bookmark = anchor->bookmark;
        NewDoc.isHEAD = anchor->isHEAD;
        NewDoc.safe = anchor->safe;
        anchor = HTAnchor_findAddress(&NewDoc);
      }
    }
    if (use_this_url_instead == (char *)0x0) {
      text_00 = (HText *)HTAnchor_document(anchor);
      if ((text_00 != (HText *)0x0) && (LYforce_no_cache == '\0')) {
        if ((LYoverride_no_cache != '\0') ||
           ((BVar1 = HText_hasNoCacheSet(text_00), BVar1 == '\0' ||
            (BVar1 = HText_AreDifferent(anchor,full_address), BVar1 == '\0')))) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTAccess: Document already in memory.\n");
          }
          HText_select(text_00);
          pHVar4 = HTAnchor_format(anchor);
          pHVar5 = HTAtom_for("www/dired");
          if (pHVar4 == (HTFormat)pHVar5) {
            lynx_edit_mode = '\x01';
          }
          redirection_attempts = 0;
          return '\x01';
        }
        ForcingNoCache = '\x01';
        HTSABFree(&anchor->post_data);
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTAccess: Auto-reloading document.\n");
        }
      }
      BVar1 = HText_HaveUserChangedForms(text_00);
      if (BVar1 != '\0') {
        Msg = (char *)gettext("Reloading document.  Any form entries will be lost!");
        HTAlert(Msg);
      }
      LYforce_no_cache = '\0';
      if ((ForcingNoCache != '\0') && (anchor->title != (char *)0x0)) {
        free(anchor->title);
        anchor->title = (char *)0x0;
      }
      local_44 = (char *)sink;
      pHVar4 = (HTFormat)HTLoad(full_address,anchor,format_out,sink);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        format_out = pHVar4;
        fprintf((FILE *)__stream,"HTAccess:  status=%d\n",pHVar4);
      }
      if (((text_00 == (HText *)0x0) || (-1 < (int)pHVar4)) ||
         (pHVar6 = (HText *)HTAnchor_document(anchor), pHVar6 != text_00)) {
        if (HTlogfile != (FILE *)0x0) {
          time(&theTime);
          if ((int)pHVar4 < 0) {
            local_48 = &DAT_0817f298;
          }
          else {
            local_48 = &DAT_0817f29d;
          }
          if (HTClientHost == (char *)0x0) {
            local_44 = "local";
          }
          else {
            local_44 = HTClientHost;
          }
          format_out = (HTFormat)ctime(&theTime);
          fprintf((FILE *)HTlogfile,"%24.24s %s %s %s\n",format_out,local_44,local_48,full_address);
          fflush((FILE *)HTlogfile);
          if (WWW_TraceFlag != '\0') {
            if ((int)pHVar4 < 0) {
              local_40 = &DAT_0817f298;
            }
            else {
              local_40 = &DAT_0817f29d;
            }
            if (HTClientHost == (char *)0x0) {
              local_3c = "local";
            }
            else {
              local_3c = HTClientHost;
            }
            format_out = (HTFormat)ctime(&theTime);
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Log: %24.24s %s %s %s\n",format_out,local_3c,local_40,
                    full_address);
            local_44 = local_3c;
          }
        }
        if (pHVar4 == (HTFormat)0x18f) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTAccess: \'%s\' is a redirection URL.\n",full_address,
                    local_44);
          }
          Msg = redirecting_url;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTAccess: Redirecting to \'%s\'\n",Msg,local_44);
          }
          iVar3 = strcmp(full_address,redirecting_url);
          if (iVar3 == 0) {
            redirection_attempts = redirection_attempts + 1;
            if (redirecting_url != (char *)0x0) {
              free(redirecting_url);
              redirecting_url = (char *)0x0;
            }
            permanent_redirection = '\0';
            local_49 = '\x01';
          }
          else {
            if (permanent_redirection != '\0') {
              HTSACopy(&anchor->physical,"Location=");
              HTSACat(&anchor->physical,redirecting_url);
            }
            HTSACopy(&use_this_url_instead,redirecting_url);
            if (ForcingNoCache != '\0') {
              LYforce_no_cache = '\x01';
            }
            redirection_attempts = redirection_attempts + 1;
            if (redirecting_url != (char *)0x0) {
              free(redirecting_url);
              redirecting_url = (char *)0x0;
            }
            permanent_redirection = '\0';
            local_49 = '\0';
          }
        }
        else {
          redirection_attempts = 0;
          if (redirecting_url != (char *)0x0) {
            free(redirecting_url);
            redirecting_url = (char *)0x0;
          }
          permanent_redirection = '\0';
          if (pHVar4 == (HTFormat)0xc8) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTAccess: `%s\' has been accessed.\n",full_address,local_44)
              ;
            }
            local_49 = '\x01';
          }
          else {
            if (pHVar4 == (HTFormat)0xce) {
              Msg = (char *)gettext("Loading incomplete.");
              HTAlert(Msg);
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTAccess: `%s\' has been accessed, partial content.\n",
                        full_address);
              }
              local_49 = '\x01';
            }
            else {
              if (pHVar4 == (HTFormat)0xffffff34) {
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"HTAccess: `%s\' has been accessed, No data left.\n",
                          full_address,local_44);
                }
                local_49 = '\0';
              }
              else {
                if (pHVar4 == (HTFormat)0xffff8ad1) {
                  if (WWW_TraceFlag != '\0') {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"HTAccess: `%s\' has been accessed, No data loaded.\n",
                            full_address,local_44);
                  }
                  local_49 = '\0';
                }
                else {
                  if (pHVar4 == (HTFormat)0xffff8ad2) {
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,
                              "HTAccess: `%s\' has been accessed, transfer interrupted.\n",
                              full_address,local_44);
                    }
                    local_49 = '\0';
                  }
                  else {
                    if (0 < (int)pHVar4) {
                      Msg = (char *)gettext(
                                           "**** HTAccess: socket or file number returned by obsolete load routine!\n"
                                           );
                      fprintf(stderr,Msg,format_out,local_44);
                      Msg = (char *)gettext(
                                           "**** HTAccess: Internal software error.  Please mail lynx-dev@nongnu.org!\n"
                                           );
                      fprintf(stderr,Msg);
                      Msg = (char *)gettext("**** HTAccess: Status returned was: %d\n");
                      fprintf(stderr,Msg,pHVar4);
                      exit_immediately(1);
                    }
                    cp = (char *)0x0;
                    Msg = (char *)gettext("Can\'t Access");
                    HTSACopy(&cp,Msg);
                    HTSACat(&cp," `");
                    HTSACat(&cp,full_address);
                    HTSACat(&cp,"\'");
                    mustshow = '\x01';
                    HTProgress(cp);
                    if (cp != (char *)0x0) {
                      free(cp);
                      cp = (char *)0x0;
                    }
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"HTAccess: Can\'t access `%s\'\n",full_address);
                    }
                    Msg = (char *)gettext("Unable to access document.");
                    HTLoadError(sink,500,Msg);
                    local_49 = '\0';
                  }
                }
              }
            }
          }
        }
      }
      else {
        Msg = (char *)gettext("Loading failed, use a previous copy.");
        HTAlert(Msg);
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTAccess: Loading failed, use a previous copy.\n");
        }
        HText_select(text_00);
        pHVar4 = HTAnchor_format(anchor);
        pHVar5 = HTAtom_for("www/dired");
        if (pHVar4 == (HTFormat)pHVar5) {
          lynx_edit_mode = '\x01';
        }
        redirection_attempts = 0;
        local_49 = '\x01';
      }
    }
    else {
      if (redirecting_url != (char *)0x0) {
        free(redirecting_url);
        redirecting_url = (char *)0x0;
      }
      local_49 = '\0';
    }
  }
  else {
    redirection_attempts = 0;
    Msg = (char *)gettext("Redirection limit of 10 URL\'s reached.");
    HTAlert(Msg);
    local_49 = '\0';
  }
  return local_49;
}



BOOLEAN HTLoadAbsolute(DocAddress *docaddr)

{
  HTStream *sink;
  BOOLEAN BVar1;
  HTParentAnchor *anchor;
  HTAtom *local_8;
  
  sink = HTOutputStream;
  if (HTOutputFormat == (HTFormat)0x0) {
    local_8 = HTAtom_for("www/present");
  }
  else {
    local_8 = (HTAtom *)HTOutputFormat;
  }
  anchor = HTAnchor_findAddress(docaddr);
  BVar1 = HTLoadDocument(docaddr->address,anchor,(HTFormat)local_8,sink);
  return BVar1;
}



BOOLEAN HTLoadRelative(char *relative_name,HTParentAnchor *here)

{
  BOOLEAN BVar1;
  char *aName;
  DocAddress full_address;
  char *stripped;
  char *mycopy;
  BOOLEAN result;
  
  mycopy = (char *)0x0;
  full_address.address = (char *)0x0;
  full_address.post_data = (bstring *)0x0;
  full_address.post_content_type = (char *)0x0;
  full_address.bookmark = (char *)0x0;
  full_address.isHEAD = '\0';
  full_address.safe = '\0';
  HTSACopy(&mycopy,relative_name);
  aName = HTStrip(mycopy);
  full_address.address = HTParse(aName,here->address,0x1d);
  BVar1 = HTLoadAbsolute(&full_address);
  if (full_address.address != (char *)0x0) {
    free(full_address.address);
    full_address.address = (char *)0x0;
  }
  if (mycopy != (char *)0x0) {
    free(mycopy);
  }
  return BVar1;
}



BOOLEAN HTLoadAnchor(HTAnchor *destination)

{
  bool bVar1;
  HTStream *sink;
  BOOLEAN BVar2;
  HTParentAnchor *me;
  HyperDoc *pHVar3;
  HText *text_00;
  BOOLEAN local_1d;
  HTAtom *local_18;
  HText *text;
  HTParentAnchor *parent;
  BOOLEAN result;
  BOOLEAN loaded;
  
  bVar1 = false;
  if (destination == (HTAnchor *)0x0) {
    local_1d = '\0';
  }
  else {
    me = HTAnchor_parent(destination);
    pHVar3 = HTAnchor_document(me);
    sink = HTOutputStream;
    if (pHVar3 == (HyperDoc *)0x0) {
      if (HTOutputFormat == (HTFormat)0x0) {
        local_18 = HTAtom_for("www/present");
      }
      else {
        local_18 = (HTAtom *)HTOutputFormat;
      }
      BVar2 = HTLoadDocument(me->address,me,(HTFormat)local_18,sink);
      if (BVar2 == '\0') {
        return '\0';
      }
      bVar1 = true;
    }
    text_00 = (HText *)HTAnchor_document(me);
    if (((HTParentAnchor *)destination == me) || (me->parent == (HTParentAnchor0 *)destination)) {
      if (!bVar1) {
        HText_select(text_00);
      }
    }
    else {
      HText_selectAnchor(text_00,(HTChildAnchor *)destination);
    }
    local_1d = '\x01';
  }
  return local_1d;
}



char hex(int i)

{
  char *hexchars;
  
  return "0123456789ABCDEF"[i];
}



BOOLEAN HTSearch(char *keywords,HTParentAnchor *here)

{
  byte bVar1;
  char cVar2;
  BOOLEAN BVar3;
  size_t sVar4;
  char *src;
  char *pcVar5;
  char *escaped;
  char *address;
  char *e;
  char *s;
  char *p;
  char *u;
  char *q;
  uchar c;
  BOOLEAN result;
  
  address = (char *)0x0;
  sVar4 = strlen(keywords);
  src = (char *)calloc(sVar4 * 3 + 1,1);
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAccess.c","HTSearch");
  }
  HTSACopy(&address,here->isIndexAction);
  s = keywords;
  while ((*s != '\0' && ((byte)*s < 0x21))) {
    s = s + 1;
  }
  sVar4 = strlen(s);
  e = s + sVar4;
  while ((s < e && ((byte)e[-1] < 0x21))) {
    e = e + -1;
  }
  p = s;
  q = src;
  while (p < e) {
    bVar1 = *p;
    if ((byte)*p < 0x21) {
      *q = '+';
      q = q + 1;
    }
    else {
      if (HTCJK == NOCJK) {
        if (((bVar1 < 0x20) || ((char)bVar1 < '\0')) ||
           ("0123456789ABCDEF"[(uint)bVar1 + 10] == '\0')) {
          *q = '%';
          cVar2 = hex((uint)(bVar1 >> 4));
          q[1] = cVar2;
          cVar2 = hex((uint)bVar1 & 0xf);
          q[2] = cVar2;
          q = q + 3;
        }
        else {
          *q = *p;
          q = q + 1;
        }
      }
      else {
        *q = *p;
        q = q + 1;
      }
    }
    p = p + 1;
  }
  *q = '\0';
  pcVar5 = strchr(address,0x3f);
  if (pcVar5 != (char *)0x0) {
    *pcVar5 = '\0';
  }
  HTSACat(&address,"?");
  HTSACat(&address,src);
  if (src != (char *)0x0) {
    free(src);
  }
  BVar3 = HTLoadRelative(address,here);
  if (address != (char *)0x0) {
    free(address);
  }
  return BVar3;
}



BOOLEAN HTSearchAbsolute(char *keywords,char *indexname)

{
  BOOLEAN BVar1;
  HTParentAnchor *here;
  DocAddress abs_doc;
  HTParentAnchor *anchor;
  
  abs_doc.address = indexname;
  abs_doc.post_data = (bstring *)0x0;
  abs_doc.post_content_type = (char *)0x0;
  abs_doc.bookmark = (char *)0x0;
  abs_doc.isHEAD = '\0';
  abs_doc.safe = '\0';
  here = HTAnchor_findAddress(&abs_doc);
  BVar1 = HTSearch(keywords,here);
  return BVar1;
}



void strip_userid(char *host)

{
  char cVar1;
  char *fmt;
  FILE *__stream;
  char *msg;
  char *fake;
  char *p2;
  char *p1;
  
  p1 = host;
  p2 = strchr(host,0x40);
  if (p2 != (char *)0x0) {
    *p2 = '\0';
    p2 = p2 + 1;
    fmt = HTParse(host,"",8);
    if (fmt != (char *)0x0) {
      msg = (char *)0x0;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"parsed:%s\n",fmt);
      }
      fmt = (char *)gettext("Address contains a username: %s");
      HTSprintf0(&msg,fmt,host);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
      }
    }
    do {
      *p1 = *p2;
      cVar1 = *p1;
      p1 = p1 + 1;
      p2 = p2 + 1;
    } while (cVar1 != '\0');
  }
  return;
}



BOOLEAN acceptEncoding(int code)

{
  char *program;
  BOOLEAN result;
  
  result = '\0';
  if ((LYAcceptEncoding & code) != 0) {
    program = (char *)0x0;
    if (code == 2) {
      program = HTGetProgramPath(ppINFLATE);
    }
    else {
      if (code < 3) {
        if (code == 1) {
          program = HTGetProgramPath(ppGZIP);
        }
      }
      else {
        if (code == 4) {
          program = HTGetProgramPath(ppCOMPRESS);
        }
        else {
          if (code == 8) {
            program = HTGetProgramPath(ppBZIP2);
          }
        }
      }
    }
    result = program != (char *)0x0;
  }
  return result;
}



// WARNING: Removing unreachable block (ram,0x0810527e)
// WARNING: Removing unreachable block (ram,0x08105286)
// WARNING: Removing unreachable block (ram,0x0810528e)
// WARNING: Removing unreachable block (ram,0x08105296)
// WARNING: Removing unreachable block (ram,0x0810529e)
// WARNING: Removing unreachable block (ram,0x081052a6)
// WARNING: Removing unreachable block (ram,0x08105496)
// WARNING: Removing unreachable block (ram,0x081054b3)
// WARNING: Removing unreachable block (ram,0x081054ca)
// WARNING: Removing unreachable block (ram,0x081054e4)
// WARNING: Removing unreachable block (ram,0x081054d3)
// WARNING: Removing unreachable block (ram,0x081054ef)
// WARNING: Removing unreachable block (ram,0x08105522)
// WARNING: Removing unreachable block (ram,0x08105504)
// WARNING: Removing unreachable block (ram,0x0810552c)
// WARNING: Removing unreachable block (ram,0x08105554)
// WARNING: Removing unreachable block (ram,0x08105572)
// WARNING: Removing unreachable block (ram,0x081055a9)
// WARNING: Removing unreachable block (ram,0x08105dfd)
// WARNING: Removing unreachable block (ram,0x08105e16)
// WARNING: Removing unreachable block (ram,0x08105e33)
// WARNING: Removing unreachable block (ram,0x08105e42)
// WARNING: Removing unreachable block (ram,0x08105e5a)
// WARNING: Removing unreachable block (ram,0x08105935)
// WARNING: Removing unreachable block (ram,0x08105951)
// WARNING: Removing unreachable block (ram,0x08105d5e)
// WARNING: Removing unreachable block (ram,0x08105961)
// WARNING: Removing unreachable block (ram,0x08105d89)
// WARNING: Removing unreachable block (ram,0x08105dbf)
// WARNING: Removing unreachable block (ram,0x08105dce)
// WARNING: Removing unreachable block (ram,0x08105de6)
// WARNING: Removing unreachable block (ram,0x08105da2)
// WARNING: Removing unreachable block (ram,0x08105971)
// WARNING: Removing unreachable block (ram,0x0810597b)
// WARNING: Removing unreachable block (ram,0x081059ad)
// WARNING: Removing unreachable block (ram,0x081059c6)
// WARNING: Removing unreachable block (ram,0x081059cf)
// WARNING: Removing unreachable block (ram,0x08105a28)
// WARNING: Removing unreachable block (ram,0x08105a33)
// WARNING: Removing unreachable block (ram,0x08105a64)
// WARNING: Removing unreachable block (ram,0x08105a88)
// WARNING: Removing unreachable block (ram,0x08105aa0)
// WARNING: Removing unreachable block (ram,0x08105aad)
// WARNING: Removing unreachable block (ram,0x08105aca)
// WARNING: Removing unreachable block (ram,0x08105ad5)
// WARNING: Removing unreachable block (ram,0x08105ae0)
// WARNING: Removing unreachable block (ram,0x08105afc)
// WARNING: Removing unreachable block (ram,0x08105b07)
// WARNING: Removing unreachable block (ram,0x08105b12)
// WARNING: Removing unreachable block (ram,0x08105b26)
// WARNING: Removing unreachable block (ram,0x08105b43)
// WARNING: Removing unreachable block (ram,0x08105b52)
// WARNING: Removing unreachable block (ram,0x08105b5c)
// WARNING: Removing unreachable block (ram,0x08105cab)
// WARNING: Removing unreachable block (ram,0x08105cb6)
// WARNING: Removing unreachable block (ram,0x08105cc1)
// WARNING: Removing unreachable block (ram,0x08105cd9)
// WARNING: Removing unreachable block (ram,0x08105ce8)
// WARNING: Removing unreachable block (ram,0x08105d00)
// WARNING: Removing unreachable block (ram,0x08105d17)
// WARNING: Removing unreachable block (ram,0x08105d22)
// WARNING: Removing unreachable block (ram,0x08105d2d)
// WARNING: Removing unreachable block (ram,0x08105d41)
// WARNING: Removing unreachable block (ram,0x08105b8e)
// WARNING: Removing unreachable block (ram,0x08105ba7)
// WARNING: Removing unreachable block (ram,0x08105bb0)
// WARNING: Removing unreachable block (ram,0x08105c09)
// WARNING: Removing unreachable block (ram,0x08105c14)
// WARNING: Removing unreachable block (ram,0x08105c45)
// WARNING: Removing unreachable block (ram,0x08105c69)
// WARNING: Removing unreachable block (ram,0x08105c81)
// WARNING: Removing unreachable block (ram,0x08105c8e)
// WARNING: Removing unreachable block (ram,0x081056c6)
// WARNING: Removing unreachable block (ram,0x081056d1)
// WARNING: Removing unreachable block (ram,0x081056d7)
// WARNING: Removing unreachable block (ram,0x081056e2)
// WARNING: Removing unreachable block (ram,0x081056f5)
// WARNING: Removing unreachable block (ram,0x08105776)
// WARNING: Removing unreachable block (ram,0x081057a0)
// WARNING: Removing unreachable block (ram,0x081057ad)
// WARNING: Removing unreachable block (ram,0x081057ba)
// WARNING: Removing unreachable block (ram,0x081057c7)
// WARNING: Removing unreachable block (ram,0x081057fd)
// WARNING: Removing unreachable block (ram,0x0810580c)
// WARNING: Removing unreachable block (ram,0x08105824)
// WARNING: Removing unreachable block (ram,0x081057e0)
// WARNING: Removing unreachable block (ram,0x0810583b)
// WARNING: Removing unreachable block (ram,0x08105846)
// WARNING: Removing unreachable block (ram,0x08105851)
// WARNING: Removing unreachable block (ram,0x08105857)
// WARNING: Removing unreachable block (ram,0x08105864)
// WARNING: Removing unreachable block (ram,0x08105871)
// WARNING: Removing unreachable block (ram,0x081058cc)
// WARNING: Removing unreachable block (ram,0x081058e7)
// WARNING: Removing unreachable block (ram,0x08105925)
// WARNING: Removing unreachable block (ram,0x081058ed)
// WARNING: Removing unreachable block (ram,0x081058f8)
// WARNING: Removing unreachable block (ram,0x0810590f)
// WARNING: Removing unreachable block (ram,0x0810592c)
// WARNING: Removing unreachable block (ram,0x0810587e)
// WARNING: Removing unreachable block (ram,0x081058b9)
// WARNING: Removing unreachable block (ram,0x08105783)
// WARNING: Removing unreachable block (ram,0x08105702)
// WARNING: Removing unreachable block (ram,0x0810571b)
// WARNING: Removing unreachable block (ram,0x08105738)
// WARNING: Removing unreachable block (ram,0x08105747)
// WARNING: Removing unreachable block (ram,0x0810575f)
// WARNING: Removing unreachable block (ram,0x081055d5)
// WARNING: Removing unreachable block (ram,0x081055db)
// WARNING: Removing unreachable block (ram,0x081055ee)
// WARNING: Removing unreachable block (ram,0x08105657)
// WARNING: Removing unreachable block (ram,0x08105606)
// WARNING: Removing unreachable block (ram,0x08105688)
// WARNING: Removing unreachable block (ram,0x08105612)
// WARNING: Removing unreachable block (ram,0x081056b3)
// WARNING: Removing unreachable block (ram,0x08105622)
// WARNING: Removing unreachable block (ram,0x081055b8)
// WARNING: Removing unreachable block (ram,0x08105e6e)
// WARNING: Removing unreachable block (ram,0x08105eb8)
// WARNING: Removing unreachable block (ram,0x08105ec3)
// WARNING: Removing unreachable block (ram,0x08105ed7)
// WARNING: Removing unreachable block (ram,0x08105e9b)
// WARNING: Removing unreachable block (ram,0x0810553a)
// WARNING: Recovered jumptable eliminated as dead code
// WARNING: Removing unreachable block (ram,0x08106170)
// WARNING: Removing unreachable block (ram,0x0810617b)
// WARNING: Removing unreachable block (ram,0x08105f9c)
// WARNING: Removing unreachable block (ram,0x08105fff)
// WARNING: Removing unreachable block (ram,0x0810600a)
// WARNING: Removing unreachable block (ram,0x0810601e)
// WARNING: Removing unreachable block (ram,0x08105fd7)
// WARNING: Removing unreachable block (ram,0x08105ff2)
// WARNING: Removing unreachable block (ram,0x08105f06)
// WARNING: Removing unreachable block (ram,0x08105f11)
// WARNING: Removing unreachable block (ram,0x08105f28)
// WARNING: Removing unreachable block (ram,0x081061d5)
// WARNING: Removing unreachable block (ram,0x081062ee)
// WARNING: Removing unreachable block (ram,0x081064bf)
// WARNING: Removing unreachable block (ram,0x081064d6)
// WARNING: Removing unreachable block (ram,0x081064ca)
// WARNING: Removing unreachable block (ram,0x081064e0)
// WARNING: Removing unreachable block (ram,0x081062fb)
// WARNING: Removing unreachable block (ram,0x08106306)
// WARNING: Removing unreachable block (ram,0x08106327)
// WARNING: Removing unreachable block (ram,0x08106384)
// WARNING: Removing unreachable block (ram,0x0810639f)
// WARNING: Removing unreachable block (ram,0x081063bf)
// WARNING: Removing unreachable block (ram,0x081063d3)
// WARNING: Removing unreachable block (ram,0x081063f7)
// WARNING: Removing unreachable block (ram,0x08106418)
// WARNING: Removing unreachable block (ram,0x0810641e)
// WARNING: Removing unreachable block (ram,0x0810642b)
// WARNING: Removing unreachable block (ram,0x08106438)
// WARNING: Removing unreachable block (ram,0x08106447)
// WARNING: Removing unreachable block (ram,0x0810647c)
// WARNING: Removing unreachable block (ram,0x08106489)
// WARNING: Removing unreachable block (ram,0x081064a0)
// WARNING: Removing unreachable block (ram,0x0810646e)
// WARNING: Removing unreachable block (ram,0x0810647a)
// WARNING: Removing unreachable block (ram,0x081064b3)
// WARNING: Removing unreachable block (ram,0x08106333)
// WARNING: Removing unreachable block (ram,0x0810633c)
// WARNING: Removing unreachable block (ram,0x08106353)
// WARNING: Removing unreachable block (ram,0x0810635e)
// WARNING: Removing unreachable block (ram,0x08106375)

int HTLoadHTTP(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  char *empty;
  BOOLEAN BVar7;
  int iVar8;
  FILE *__stream;
  int *piVar9;
  char *local_1ec;
  size_t sVar10;
  char *__s1;
  char *host_00;
  char *host_01;
  int iVar11;
  char *docname_00;
  char *Msg;
  ssize_t sVar12;
  FILE *__stream_00;
  HTAtom *pHVar13;
  HTStream *sink_00;
  int in_GS_OFFSET;
  undefined8 local_1f4;
  undefined4 uVar14;
  char *local_1b0;
  char *local_1ac;
  char *local_1a4;
  char *local_1a0;
  char *local_19c;
  HTAtom *local_198;
  char *local_194;
  char *local_190;
  char *local_188;
  int local_184;
  int local_180;
  int local_17c;
  char *local_178;
  size_t local_170;
  char *local_16c;
  int port2;
  FILE *error_file;
  int fields;
  int buffer_length;
  char *path2;
  char *host2;
  char *cookie;
  char *auth;
  char *list;
  char *colon;
  char *hostname;
  char *docname;
  char *abspath;
  int nn;
  char *pound;
  char *cp_1;
  char *cp;
  int k;
  int j;
  HTPresentation *pres;
  char *host;
  int i;
  int n;
  char *p1;
  void *handle;
  int len;
  int server_status;
  int rv;
  int rawlength;
  int length;
  char *linebuf;
  int real_length_of_line;
  char *line_kept_clean;
  char *line_buffer;
  char *METHOD;
  HTFormat format_in;
  HTStream *target;
  int bytes_already_read;
  int status;
  char *start_of_data;
  char *eol;
  bstring *command;
  char *url;
  int s;
  char crlf [3];
  BOOLEAN end_of_file;
  BOOLEAN secure;
  BOOLEAN already_retrying;
  BOOLEAN doing_redirect;
  BOOLEAN auth_proxy;
  BOOLEAN show_407;
  BOOLEAN show_401;
  BOOLEAN first_Accept;
  BOOLEAN extensions;
  BOOLEAN had_header;
  BOOLEAN do_post;
  BOOLEAN do_head;
  char temp [80];
  char server_version [21];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  command = (bstring *)0x0;
  bVar3 = false;
  bVar2 = false;
  linebuf = (char *)0x0;
  bVar6 = false;
  if (anAnchor->isHEAD == '\0') {
    if (anAnchor->post_data != (bstring *)0x0) {
      bVar2 = true;
    }
  }
  else {
    bVar3 = true;
  }
  if (arg == (char *)0x0) {
    status = -3;
    mustshow = '\x01';
    local_1ec = (char *)gettext("Bad request!");
    HTProgress(local_1ec);
  }
  else {
    if (*arg == '\0') {
      status = -2;
      mustshow = '\x01';
      local_1ec = (char *)gettext("Bad request!");
      HTProgress(local_1ec);
    }
    else {
      sprintf(crlf,"%c%c");
      bVar4 = true;
try_again:
      length = 0;
      permanent_redirection = '\0';
      redirect_post_content = '\0';
      line_kept_clean = (char *)0x0;
      iVar8 = strncmp(arg,"https",5);
      if (iVar8 != 0) {
        iVar8 = HTDoConnect(arg,"HTTP",0x50,&s);
        if (iVar8 == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTP: Interrupted on connect; recovering cleanly.\n");
          }
          mustshow = '\x01';
          local_1ec = (char *)gettext("Connection interrupted.");
          HTProgress(local_1ec);
          status = -29999;
          goto done;
        }
        if (iVar8 < 0) {
          if (WWW_TraceFlag != '\0') {
            piVar9 = __errno_location();
            iVar8 = *piVar9;
            __stream = TraceFP();
            fprintf((FILE *)__stream,
                    "HTTP: Unable to connect to remote host for `%s\' (errno = %d).\n",arg,iVar8);
          }
          local_1ec = (char *)gettext("Unable to connect to remote host.");
          HTAlert(local_1ec);
          status = -29999;
          goto done;
        }
        local_1ec = HTParse(arg,"",5);
        if (bVar2) {
          HTSABCopy0(&command,"POST ");
        }
        else {
          if (bVar3) {
            HTSABCopy0(&command,"HEAD ");
          }
          else {
            HTSABCopy0(&command,"GET ");
          }
        }
        if (using_proxy == '\0') {
          HTSABCat0(&command,local_1ec);
        }
        else {
          HTSABCat0(&command,local_1ec + 1);
        }
        if (local_1ec != (char *)0x0) {
          free(local_1ec);
        }
        if (bVar4) {
          HTSABCat0(&command," ");
          HTSABCat0(&command,"HTTP/1.0");
        }
        HTSABCat0(&command,crlf);
        if (bVar4) {
          local_1ec = HTParse(anAnchor->address,"",8);
          if (local_1ec != (char *)0x0) {
            strip_userid(local_1ec);
            HTBprintf(&command,"Host: %s%c%c",local_1ec,0xd,10);
            if (local_1ec != (char *)0x0) {
              free(local_1ec);
            }
          }
          if (HTPresentations == (HTList *)0x0) {
            HTFormatInit();
          }
          iVar8 = HTList_count(HTPresentations);
          bVar5 = true;
          len = 0;
          i = 0;
          while (i < iVar8) {
            piVar9 = (int *)HTList_objectAt(HTPresentations,i);
            if (*(char *)(piVar9 + 10) != '\0') {
              if (1.00000000 <= (float)piVar9[5]) {
                if ((piVar9[9] < 0) || ((piVar9[9] < 1 && (piVar9[8] == 0)))) {
                  temp[0] = '\0';
                }
                else {
                  sprintf(temp,";mxb=%lld");
                }
              }
              else {
                if ((piVar9[9] < 0) || ((piVar9[9] < 1 && (piVar9[8] == 0)))) {
                  sprintf(temp,";q=%4.3f");
                }
                else {
                  sprintf(temp,";q=%4.3f;mxb=%lld",(double)(float)piVar9[5],piVar9[8],piVar9[9]);
                }
              }
              if (bVar5) {
                local_1b0 = "Accept: ";
              }
              else {
                local_1b0 = ", ";
              }
              local_1ec = temp;
              HTSprintf0(&linebuf,"%s%s%s",local_1b0,*(undefined4 *)(*piVar9 + 4),local_1ec);
              sVar10 = strlen(linebuf);
              len = sVar10 + len;
              if ((0xfc < len) && (!bVar5)) {
                HTSABCat0(&command,crlf);
                HTSprintf0(&linebuf,"Accept: %s%s",*(undefined4 *)(*piVar9 + 4),temp,local_1ec);
                len = strlen(linebuf);
              }
              HTSABCat0(&command,linebuf);
              bVar5 = false;
            }
            i = i + 1;
          }
          if (bVar5) {
            local_1ac = "Accept: ";
          }
          else {
            local_1ac = ", ";
          }
          uVar14 = 10;
          HTBprintf(&command,"%s*/*;q=0.01%c%c",local_1ac,0xd,10);
          if ((LYPrependBaseToSource == '\0') || (dump_output_immediately == '\0')) {
            list = (char *)0x0;
            j = 1;
            while (j < 0xf) {
              BVar7 = acceptEncoding(j);
              if (BVar7 != '\0') {
                k = 0;
                while (tbl_preferred_encoding[k].name != (char *)0x0) {
                  if (tbl_preferred_encoding[k].value == j) {
                    if (list != (char *)0x0) {
                      HTSACat(&list,", ");
                    }
                    HTSACat(&list,tbl_preferred_encoding[k].name);
                    break;
                  }
                  k = k + 1;
                }
              }
              j = j << 1;
            }
            if (list != (char *)0x0) {
              uVar14 = 10;
              HTBprintf(&command,"Accept-Encoding: %s%c%c",list,0xd,10);
              free(list);
            }
          }
          else {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,
                      "omit Accept-Encoding to work-around interaction with -source\n");
            }
          }
          if ((language != (char *)0x0) && (*language != '\0')) {
            uVar14 = 10;
            HTBprintf(&command,"Accept-Language: %s%c%c",language,0xd,10);
          }
          if ((pref_charset != (char *)0x0) && (*pref_charset != '\0')) {
            HTSABCat0(&command,"Accept-Charset: ");
            HTSACopy(&linebuf,pref_charset);
            local_1ec = linebuf;
            sVar10 = strlen(linebuf);
            __s1 = linebuf;
            if (local_1ec[sVar10 - 1] == ',') {
              sVar10 = strlen(linebuf);
              __s1[sVar10 - 1] = '\0';
            }
            LYLowerCase(linebuf);
            local_1ec = strstr(linebuf,"iso-8859-1");
            if (local_1ec == (char *)0x0) {
              HTSACat(&linebuf,", iso-8859-1;q=0.01");
            }
            local_1ec = strstr(linebuf,"us-ascii");
            if (local_1ec == (char *)0x0) {
              HTSACat(&linebuf,", us-ascii;q=0.01");
            }
            HTSABCat0(&command,linebuf);
            HTBprintf(&command,"%c%c");
          }
          if (reloading != '\0') {
            HTBprintf(&command,"Pragma: no-cache%c%c",0xd,10,uVar14);
            HTBprintf(&command,"Cache-Control: no-cache%c%c");
          }
          if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
            if (HTAppVersion == (char *)0x0) {
              local_1a4 = "0.0";
            }
            else {
              local_1a4 = HTAppVersion;
            }
            if (HTAppName == (char *)0x0) {
              local_1a0 = "unknown";
            }
            else {
              local_1a0 = HTAppName;
            }
            HTBprintf(&command,"User-Agent: %s/%s  libwww-FM/%s%c%c",local_1a0,local_1a4,
                      HTLibraryVersion,0xd,10);
          }
          else {
            local_1ec = LYSkipBlanks(LYUserAgent);
            if (*local_1ec != '\0') {
              HTBprintf(&command,"User-Agent: %.*s%c%c",0x5f1,LYUserAgent,0xd,10);
            }
          }
          if ((personal_mail_address != (char *)0x0) && (LYNoFromHeader == '\0')) {
            HTBprintf(&command,"From: %s%c%c",personal_mail_address,0xd,10);
          }
          if ((((LYUserSpecifiedURL == '\0') && (LYNoRefererHeader == '\0')) &&
              (LYNoRefererForThis == '\0')) &&
             (local_1ec = HTLoadedDocumentURL(), *local_1ec != '\0')) {
            cp_1 = LYRequestReferer;
            if (LYRequestReferer == (char *)0x0) {
              cp_1 = HTLoadedDocumentURL();
            }
            HTSABCat0(&command,"Referer: ");
            iVar8 = strncasecomp(cp_1,"LYNXIMGMAP:",0xb);
            if (iVar8 == 0) {
              local_19c = strchr(cp_1,0x23);
              if (local_19c == (char *)0x0) {
                local_19c = (char *)strlen(cp_1);
              }
              else {
                local_19c = local_19c + -(int)cp_1;
              }
              HTSABCat(&command,cp_1 + 0xb,(int)local_19c);
            }
            else {
              HTSABCat0(&command,cp_1);
            }
            HTBprintf(&command,"%c%c");
          }
          cookie = (char *)0x0;
          iVar8 = strncmp(anAnchor->address,"https",5);
          local_1ec = HTParse(arg,"",5);
          __s1 = HTParse(arg,"",4);
          host_00 = HTParse(arg,"",8);
          if ((host_00 == (char *)0x0) ||
             (host_01 = HTParsePort(host_00,(int *)&list), host_01 == (char *)0x0)) {
            iVar11 = strncmp(arg,"https",5);
            if (iVar11 == 0) {
              list = (char *)0x1bb;
            }
            else {
              list = (char *)0x50;
            }
          }
          else {
            *host_01 = '\0';
          }
          if (using_proxy == '\0') {
            cookie = LYAddCookieHeader(host_00,local_1ec,(int)list,iVar8 == 0);
            auth_proxy = '\0';
          }
          else {
            iVar11 = strncmp(__s1,"https",5);
            if (iVar11 == 0) {
              local_198 = (HTAtom *)0x1bb;
            }
            else {
              local_198 = (HTAtom *)0x50;
            }
            port2 = (int)local_198;
            host_01 = HTParse(__s1,"",8);
            docname_00 = HTParse(__s1,"",5);
            if ((host_01 != (char *)0x0) && (Msg = HTParsePort(host_01,&port2), Msg != (char *)0x0))
            {
              *Msg = '\0';
            }
            Msg = HTAA_composeAuth(host_01,port2,docname_00,'\0');
            if ((Msg == (char *)0x0) || (*Msg == '\0')) {
              if ((Msg != (char *)0x0) && (*Msg == '\0')) {
                if ((traversal == '\0') && (dump_output_immediately == '\0')) {
                  Msg = (char *)gettext("Proceed without a username and password?");
                  BVar7 = HTConfirm(Msg);
                  if (BVar7 != '\0') goto LAB_08104288;
                }
                if ((traversal != '\0') || (dump_output_immediately != '\0')) {
                  Msg = (char *)gettext("Can\'t proceed without a username and password.");
                  HTAlert(Msg);
                }
                HTSABFree(&command);
                if (host_00 != (char *)0x0) {
                  free(host_00);
                }
                if (__s1 != (char *)0x0) {
                  free(__s1);
                }
                if (local_1ec != (char *)0x0) {
                  free(local_1ec);
                }
                if (host_01 != (char *)0x0) {
                  free(host_01);
                }
                if (docname_00 != (char *)0x0) {
                  free(docname_00);
                }
                status = -29999;
                goto done;
              }
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTTP: Not sending authorization (yet).\n");
              }
            }
            else {
              HTBprintf(&command,"%s%c%c",Msg,0xd,10);
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTTP: Sending authorization: %s\n");
              }
            }
LAB_08104288:
            iVar11 = strncmp(__s1,"http",4);
            if (iVar11 == 0) {
              cookie = LYAddCookieHeader(host_01,docname_00,port2,iVar8 == 0);
            }
            if (host_01 != (char *)0x0) {
              free(host_01);
            }
            if (docname_00 != (char *)0x0) {
              free(docname_00);
            }
            auth_proxy = '\x01';
          }
          if (cookie != (char *)0x0) {
            if (*cookie != '$') {
              HTSABCat0(&command,"Cookie2: $Version=\"1\"");
              HTSABCat0(&command,crlf);
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTTP: Sending Cookie2: $Version =\"1\"\n");
              }
            }
            if (*cookie != '\0') {
              HTSABCat0(&command,"Cookie: ");
              HTSABCat0(&command,cookie);
              HTSABCat0(&command,crlf);
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTTP: Sending Cookie: %s\n");
              }
            }
            if (cookie != (char *)0x0) {
              free(cookie);
            }
          }
          if (local_1ec != (char *)0x0) {
            free(local_1ec);
          }
          local_1ec = HTAA_composeAuth(host_00,(int)list,__s1,auth_proxy);
          if ((local_1ec == (char *)0x0) || (*local_1ec == '\0')) {
            if ((local_1ec != (char *)0x0) && (*local_1ec == '\0')) {
              if ((traversal == '\0') && (dump_output_immediately == '\0')) {
                local_1ec = (char *)gettext("Proceed without a username and password?");
                BVar7 = HTConfirm(local_1ec);
                if (BVar7 != '\0') goto LAB_08104679;
              }
              if ((traversal != '\0') || (dump_output_immediately != '\0')) {
                local_1ec = (char *)gettext("Can\'t proceed without a username and password.");
                HTAlert(local_1ec);
              }
              HTSABFree(&command);
              if (host_00 != (char *)0x0) {
                free(host_00);
              }
              if (__s1 != (char *)0x0) {
                free(__s1);
              }
              status = -29999;
              goto done;
            }
            if (WWW_TraceFlag != '\0') {
              if (auth_proxy == '\0') {
                local_190 = "HTTP: Not sending authorization (yet).\n";
              }
              else {
                local_190 = "HTTP: Not sending proxy authorization (yet).\n";
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,local_190);
            }
          }
          else {
            HTBprintf(&command,"%s%c%c",local_1ec,0xd,10);
            if (WWW_TraceFlag != '\0') {
              if (auth_proxy == '\0') {
                local_194 = "HTTP: Sending authorization: %s\n";
              }
              else {
                local_194 = "HTTP: Sending proxy authorization: %s\n";
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,local_194);
            }
          }
LAB_08104679:
          if (host_00 != (char *)0x0) {
            free(host_00);
          }
          if (__s1 != (char *)0x0) {
            free(__s1);
          }
        }
        if (bVar2) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTP: Doing post, content-type \'%s\'\n");
          }
          if (anAnchor->post_content_type == (char *)0x0) {
            local_188 = "lose";
          }
          else {
            local_188 = anAnchor->post_content_type;
          }
          HTBprintf(&command,"Content-type: %s%c%c",local_188,0xd,10);
          if (((anAnchor->post_data == (bstring *)0x0) || (anAnchor->post_data == (bstring *)0x0))
             || (anAnchor->post_data->len == 0)) {
            local_184 = 0;
          }
          else {
            if (anAnchor->post_data == (bstring *)0x0) {
              local_180 = 0;
            }
            else {
              local_180 = anAnchor->post_data->len;
            }
            local_184 = local_180;
          }
          HTBprintf(&command,"Content-length: %d%c%c",local_184,0xd,10);
          HTSABCat0(&command,crlf);
          if (anAnchor->post_data == (bstring *)0x0) {
            local_17c = 0;
          }
          else {
            local_17c = anAnchor->post_data->len;
          }
          if (anAnchor->post_data == (bstring *)0x0) {
            local_178 = (char *)0x0;
          }
          else {
            local_178 = anAnchor->post_data->str;
          }
          HTSABCat(&command,local_178,local_17c);
        }
        else {
          HTSABCat0(&command,crlf);
        }
        if (WWW_TraceFlag != '\0') {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Writing:\n");
          }
          trace_bstring(command);
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"%s");
          }
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"----------------------------------\n");
          }
        }
        mustshow = '\x01';
        local_1ec = (char *)gettext("Sending HTTP request.");
        HTProgress(local_1ec);
        if (command == (bstring *)0x0) {
          local_170 = 0;
          local_16c = (char *)0x0;
        }
        else {
          local_170 = command->len;
          local_16c = command->str;
        }
        sVar12 = write(s,local_16c,local_170);
        HTSABFree(&command);
        if (linebuf != (char *)0x0) {
          free(linebuf);
          linebuf = (char *)0x0;
        }
        if (sVar12 < 1) {
          if (sVar12 != 0) {
            piVar9 = __errno_location();
            if ((((*piVar9 != 0x6b) && (piVar9 = __errno_location(), *piVar9 != 0x68)) &&
                (piVar9 = __errno_location(), *piVar9 != 0x20)) || ((bVar6 || (bVar2)))) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,
                        "HTTP: Hit unexpected network WRITE error; aborting connection.\n");
              }
              close(s);
              status = -1;
              local_1ec = (char *)gettext("Unexpected network write error; connection aborted.");
              HTAlert(local_1ec);
              goto done;
            }
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n");
            }
            mustshow = '\x01';
            local_1ec = (char *)gettext("Retrying as HTTP0 request.");
            HTProgress(local_1ec);
            close(s);
            bVar4 = false;
            bVar6 = true;
            goto try_again;
          }
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTP: Got status 0 in initial write\n");
          }
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTTP: WRITE delivered OK\n");
        }
        mustshow = '\x01';
        local_1ec = (char *)gettext("HTTP request sent; waiting for response.");
        HTProgress(local_1ec);
        buffer_length = 0x600;
        line_buffer = (char *)calloc(0x600,1);
        if (line_buffer == (char *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTTP.c","HTLoadHTTP");
        }
        bytes_already_read = 0;
        local_1f4 = 0;
        HTReadProgress(0,0);
        do {
          uVar14 = (undefined4)((ulonglong)local_1f4 >> 0x20);
          if (buffer_length - length < 0x100) {
            buffer_length = buffer_length * 2;
            line_buffer = (char *)realloc(line_buffer,buffer_length);
            if (line_buffer == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTTP.c","HTLoadHTTP");
            }
          }
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTP: Trying to read %d\n");
          }
          iVar8 = HTDoRead(s,line_buffer + length,(buffer_length - length) - 1);
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTP: Read %d\n");
          }
          if (iVar8 < 1) {
            if (iVar8 == -0x752e) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTTP: Interrupted initial read.\n");
              }
              mustshow = '\x01';
              local_1ec = (char *)gettext("Connection interrupted.");
              HTProgress(local_1ec);
              close(s);
              status = -0xcc;
              goto clean_up;
            }
            if ((-1 < iVar8) ||
               ((((piVar9 = __errno_location(), *piVar9 != 0x6b &&
                  (piVar9 = __errno_location(), *piVar9 != 0x68)) &&
                 (piVar9 = __errno_location(), *piVar9 != 0x20)) || ((bVar6 || (bVar2)))))) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,
                        "HTTP: Hit unexpected network read error; aborting connection; status %d.\n"
                        ,iVar8,uVar14);
              }
              local_1ec = (char *)gettext("Unexpected network read error; connection aborted.");
              HTAlert(local_1ec);
              close(s);
              status = -1;
              goto clean_up;
            }
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTTP: BONZO Trying again with HTTP0 request.\n");
            }
            close(s);
            if (line_buffer != (char *)0x0) {
              free(line_buffer);
            }
            if (line_kept_clean != (char *)0x0) {
              free(line_kept_clean);
            }
            bVar4 = false;
            bVar6 = true;
            mustshow = '\x01';
            local_1ec = (char *)gettext("Retrying as HTTP0 request.");
            HTProgress(local_1ec);
            goto try_again;
          }
          bytes_already_read = bytes_already_read + iVar8;
          local_1f4 = 0;
          HTReadProgress((longlong)bytes_already_read,0);
          uVar14 = (undefined4)((ulonglong)local_1f4 >> 0x20);
          if (iVar8 == 0) break;
          line_buffer[length + iVar8] = '\0';
          if (line_buffer != (char *)0x0) {
            if (line_kept_clean != (char *)0x0) {
              free(line_kept_clean);
            }
            line_kept_clean = (char *)malloc(buffer_length);
            if (line_kept_clean == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTTP.c","HTLoadHTTP");
            }
            local_1f4 = CONCAT44(uVar14,buffer_length);
            memcpy(line_kept_clean,line_buffer,buffer_length);
          }
          local_1ec = strchr(line_buffer + length,10);
          if (((local_1ec != (char *)0x0) && (local_1ec != line_buffer)) && (local_1ec[-1] == '\r'))
          {
            local_1ec[-1] = ' ';
          }
          length = length + iVar8;
          if (local_1ec != (char *)0x0) {
            *local_1ec = '\0';
            break;
          }
        } while (bytes_already_read < 100);
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTTP: Rx: %s\n");
        }
        if ((!bVar4) ||
           (((iVar8 = strncmp(line_buffer,"<TITLE>Bad File Request</TITLE>",0x1f), iVar8 != 0 &&
             (iVar8 = strncmp(line_buffer,"Address should begin with",0x19), iVar8 != 0)) &&
            ((iVar8 = strncmp(line_buffer,"<TITLE>Help ",0xc), iVar8 != 0 &&
             (iVar8 = strcmp(line_buffer,"Document address invalid or access not authorised"),
             iVar8 != 0)))))) {
          sscanf(line_buffer,"%20s %d");
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTP: Scanned %d fields from line_buffer\n");
          }
          if ((http_error_file != (char *)0x0) &&
             (__stream_00 = fopen64(http_error_file,"a+"), __stream_00 != (FILE *)0x0)) {
            fprintf(__stream_00,"   URL=%s (%s)\n");
            fprintf(__stream_00,"STATUS=%s\n");
            fclose(__stream_00);
          }
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"--- Talking HTTP0.\n");
          }
          format_in = HTFileFormat(arg,(HTAtom **)&port2,(char **)0x0);
          iVar8 = strncmp(format_in->name,"text/plain",10);
          if (iVar8 == 0) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTTP: format_in being changed to text/HTML\n");
            }
            format_in = (HTFormat)HTAtom_for("text/html");
          }
          if (((((HTAtom *)port2 != (HTAtom *)0x0) &&
               (pHVar13 = HTAtom_for("identity"), pHVar13 != (HTAtom *)port2)) &&
              (pHVar13 = HTAtom_for("8bit"), pHVar13 != (HTAtom *)port2)) &&
             ((pHVar13 = HTAtom_for("binary"), pHVar13 != (HTAtom *)port2 &&
              (pHVar13 = HTAtom_for("7bit"), pHVar13 != (HTAtom *)port2)))) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTTP: format_in is \'%s\',\n");
            }
            HTSACopy(&anAnchor->content_type,format_in->name);
            HTSACopy(&anAnchor->content_encoding,*(char **)(port2 + 4));
            format_in = (HTFormat)HTAtom_for("www/compressed");
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"        Treating as \'%s\' with encoding \'%s\'\n");
            }
          }
          iVar8 = HTCheckForInterrupt();
          if (iVar8 == 0) {
            if ((bVar3) || (keep_mime_headers != '\0')) {
              format_in = (HTFormat)HTAtom_for("text/plain");
            }
            sink_00 = HTStreamStack(format_in,format_out,sink,anAnchor);
            if (sink_00 == (HTStream *)0x0) {
              port2 = 0;
              close(s);
              local_1ec = format_out->name;
              __s1 = format_in->name;
              host_00 = (char *)gettext("Sorry, no known way of converting %s to %s.");
              HTSprintf0((char **)&port2,host_00,__s1,local_1ec);
              mustshow = '\x01';
              HTProgress((char *)port2);
              if ((HTAtom *)port2 != (HTAtom *)0x0) {
                free((void *)port2);
                port2 = 0;
              }
              status = -1;
            }
            else {
              (*sink_00->isa->put_block)(sink_00,line_kept_clean,length);
              iVar8 = HTCopy(anAnchor,s,(void *)0x0,sink_00);
              if (iVar8 == -1) {
                status = -0x752e;
                close(s);
              }
              else {
                if (iVar8 == -2) {
                  (*sink_00->isa->_abort)(sink_00,(HTError)0x0);
                  close(s);
                  if ((!bVar6) && (!bVar2)) {
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"HTTP: Trying again with HTTP0 request.\n");
                    }
                    if (line_buffer != (char *)0x0) {
                      free(line_buffer);
                    }
                    if (line_kept_clean != (char *)0x0) {
                      free(line_kept_clean);
                    }
                    bVar4 = false;
                    bVar6 = true;
                    mustshow = '\x01';
                    local_1ec = (char *)gettext("Retrying as HTTP0 request.");
                    HTProgress(local_1ec);
                    goto try_again;
                  }
                  status = -29999;
                }
                else {
                  if ((iVar8 == -0x752e) || (iVar8 == -2)) {
                    close(s);
                  }
                  else {
                    (*sink_00->isa->_free)(sink_00);
                  }
                  status = 200;
                }
              }
            }
          }
          else {
            close(s);
            status = -0x752e;
          }
clean_up:
          if (line_buffer != (char *)0x0) {
            free(line_buffer);
          }
          if (line_kept_clean != (char *)0x0) {
            free(line_kept_clean);
          }
          goto done;
        }
        if (line_buffer != (char *)0x0) {
          free(line_buffer);
        }
        if (line_kept_clean != (char *)0x0) {
          free(line_kept_clean);
        }
        bVar4 = false;
        bVar6 = true;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTTP: close socket %d to retry with HTTP0\n");
        }
        close(s);
        mustshow = '\x01';
        local_1ec = (char *)gettext("Retrying as HTTP0 request.");
        HTProgress(local_1ec);
        goto try_again;
      }
      local_1ec = (char *)gettext("This client does not contain support for HTTPS URLs.");
      HTAlert(local_1ec);
      status = -29999;
    }
  }
done:
  reloading = '\0';
  dump_server_status = server_status;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    reloading = '\0';
    return status;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * FormatStr(char **bufp,char *start,char *entry)

{
  int iVar1;
  int in_GS_OFFSET;
  char fmt [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (*start == '\0') {
    if ((*bufp == (char *)0x0) || ((entry != (char *)0x0 && (*entry != '\0')))) {
      if (entry != (char *)0x0) {
        HTSACopy(bufp,entry);
      }
    }
    else {
      **bufp = '\0';
    }
  }
  else {
    sprintf(fmt,"%%%.*ss",0x1fd,start);
    HTSprintf0(bufp,fmt,entry);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *bufp;
}



char * FormatNum(char **bufp,char *start,int entry)

{
  int iVar1;
  int in_GS_OFFSET;
  char fmt [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (*start == '\0') {
    sprintf(fmt,"%d",entry);
    HTSACopy(bufp,fmt);
  }
  else {
    sprintf(fmt,"%%%.*sd",0x1fd,start);
    HTSprintf0(bufp,fmt,entry);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *bufp;
}



void LYListFmtParse(char *fmtstr,DIRED *data,char *file,HTStructured *target,char *tail)

{
  char cVar1;
  char *start_00;
  char *pcVar2;
  char *ptbits [9];
  char *psbits [9];
  char *pbits [9];
  size_t sVar3;
  ushort **ppuVar4;
  ssize_t sVar5;
  HTFormat pHVar6;
  int iVar7;
  time_t tVar8;
  char *entry;
  uint uVar9;
  uint uVar10;
  int in_GS_OFFSET;
  char *local_170;
  char *local_16c;
  char *local_168;
  char *local_154;
  HTFormat format;
  char *cp2;
  int len;
  char *datestr;
  time_t now;
  char *name;
  char *buf;
  char *str;
  char *start;
  char *end;
  char *s;
  char type;
  char c;
  char tmp [256];
  int local_14;
  
  local_154 = fmtstr;
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  str = (char *)0x0;
  buf = (char *)0x0;
  if ((data->file_info).st_mode == 0) {
    local_154 = "    %a";
  }
  HTSACopy(&str,local_154);
  pcVar2 = str;
  s = str;
  sVar3 = strlen(str);
LAB_08107166:
  do {
    start_00 = s;
    if (*s == '\0') {
LAB_08107177:
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      (*target->isa->put_character)(target,'\n');
      if (str != (char *)0x0) {
        free(str);
        str = (char *)0x0;
      }
      if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    while (*s != '\0') {
      if (*s == '%') {
        if (s[1] != '%') break;
        s = s + 1;
      }
      s = s + 1;
    }
    *s = '\0';
    if (start_00 < s) {
      (*target->isa->put_string)(target,start_00);
    }
    if (s == pcVar2 + sVar3) goto LAB_08107177;
    start_00 = s + 1;
    s = start_00;
    while (((((ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*s] & 0x800) != 0 || (*s == '.')) ||
             (*s == '-')) || ((*s == ' ' || (*s == '#')))) || ((*s == '+' || (*s == '\''))))) {
      s = s + 1;
    }
    cVar1 = *s;
    *s = '\0';
    switch(cVar1) {
    case '\0':
      (*target->isa->put_string)(target,start_00);
      goto LAB_08107166;
    default:
      fprintf(stderr,"Unknown format character `%c\' in list format\n",(int)cVar1);
      break;
    case '%':
      FormatStr(&buf,start_00,"%");
      break;
    case 'A':
    case 'a':
      HTDirEntry(target,tail,data->file_name);
      FormatStr(&buf,start_00,data->file_name);
      (*target->isa->put_string)(target,buf);
      (*target->isa->end_element)(target,0,(char **)0x0);
      *buf = '\0';
      if (((cVar1 != 'A') && (((data->file_info).st_mode & 0xf000) == 0xa000)) &&
         (sVar5 = readlink(file,tmp,0xff), -1 < sVar5)) {
        (*target->isa->put_string)(target," -> ");
        tmp[sVar5] = '\0';
        (*target->isa->put_string)(target,tmp);
      }
      break;
    case 'K':
      if (((data->file_info).st_mode & 0xf000) != 0x4000) goto switchD_0810694b_caseD_6b;
      FormatStr(&buf,start_00,"");
      HTSACat(&buf," ");
      break;
    case 'T':
    case 't':
      if (((data->file_info).st_mode & 0xf000) == 0x4000) {
        if (cVar1 == 'T') {
          FormatStr(&buf,start_00,"");
        }
        else {
          entry = (char *)gettext("Directory");
          FormatStr(&buf,start_00,entry);
        }
      }
      else {
        pHVar6 = HTFileFormat(file,(HTAtom **)0x0,&cp2);
        if (cVar1 == 'T') {
          FormatStr(&buf,start_00,pHVar6->name);
        }
        else {
          if (cp2 == (char *)0x0) {
            iVar7 = strncmp(pHVar6->name,"application",0xb);
            if (iVar7 == 0) {
              cp2 = pHVar6->name + 0xc;
              iVar7 = strncmp(cp2,"x-",2);
              if (iVar7 == 0) {
                cp2 = cp2 + 2;
              }
            }
            else {
              cp2 = pHVar6->name;
            }
          }
          FormatStr(&buf,start_00,cp2);
        }
      }
      break;
    case 'd':
      tVar8 = time((time_t *)0x0);
      entry = ctime((time_t *)&(data->file_info).st_mtim);
      if (tVar8 - (data->file_info).st_mtim.tv_sec < 0xf099c0) {
        sprintf(tmp,"%.12s",entry + 4);
      }
      else {
        sprintf(tmp,"%.7s %.4s ",entry + 4,entry + 0x14);
      }
      FormatStr(&buf,start_00,tmp);
      break;
    case 'g':
      entry = HTAA_GidToName((data->file_info).st_gid);
      if (*entry == '\0') {
        FormatNum(&buf,start_00,(data->file_info).st_gid);
      }
      else {
        FormatStr(&buf,start_00,entry);
      }
      break;
    case 'k':
switchD_0810694b_caseD_6b:
      uVar9 = *(uint *)&(data->file_info).st_size;
      uVar10 = uVar9 + 0x3ff;
      iVar7 = *(int *)((int)&(data->file_info).st_size + 4) + (uint)(0xfffffc00 < uVar9);
      uVar9 = iVar7 >> 0x1f & 0x3ff;
      FormatNum(&buf,start_00,uVar9 + uVar10 >> 10 | (iVar7 + (uint)CARRY4(uVar9,uVar10)) * 0x400000
               );
      HTSACat(&buf,"K");
      break;
    case 'l':
      FormatNum(&buf,start_00,(data->file_info).st_nlink);
      break;
    case 'o':
      entry = HTAA_UidToName((data->file_info).st_uid);
      if (*entry == '\0') {
        FormatNum(&buf,start_00,(data->file_info).st_uid);
      }
      else {
        FormatStr(&buf,start_00,entry);
      }
      break;
    case 'p':
      uVar9 = (data->file_info).st_mode & 0xf000;
      if (uVar9 == 0x6000) {
        type = 'b';
      }
      else {
        if (uVar9 < 0x6001) {
          if (uVar9 == 0x2000) {
            type = 'c';
          }
          else {
            if (uVar9 == 0x4000) {
              type = 'd';
            }
            else {
              if (uVar9 == 0x1000) {
                type = 'p';
              }
              else {
LAB_08106e99:
                type = '?';
              }
            }
          }
        }
        else {
          if (uVar9 == 0xa000) {
            type = 'l';
          }
          else {
            if (uVar9 == 0xc000) {
              type = 's';
            }
            else {
              if (uVar9 != 0x8000) goto LAB_08106e99;
              type = '-';
            }
          }
        }
      }
      if (((data->file_info).st_mode & 0x200) == 0) {
        local_170 = *(char **)(((data->file_info).st_mode & 7) * 4 + 0x81a9e00);
      }
      else {
        local_170 = ((char **)&ram0x081a9d80)[(data->file_info).st_mode & 7];
      }
      if (((data->file_info).st_mode & 0x400) == 0) {
        local_16c = *(char **)(((data->file_info).st_mode >> 3 & 7) * 4 + 0x81a9e00);
      }
      else {
        local_16c = ((char **)&ram0x081a9dc0)[(data->file_info).st_mode >> 3 & 7];
      }
      if (((data->file_info).st_mode & 0x800) == 0) {
        local_168 = ((char **)&ram0x081a9e00)[(data->file_info).st_mode >> 6 & 7];
      }
      else {
        local_168 = *(char **)(((data->file_info).st_mode >> 6 & 7) * 4 + 0x81a9dc0);
      }
      sprintf(tmp,"%c%s%s%s",(int)type,local_168,local_16c,local_170);
      FormatStr(&buf,start_00,tmp);
      break;
    case 's':
      FormatNum(&buf,start_00,*(int *)&(data->file_info).st_size);
    }
    if (buf != (char *)0x0) {
      (*target->isa->put_string)(target,buf);
    }
    s = s + 1;
  } while( true );
}



void HTSetSuffix5(char *suffix,char *representation,char *encoding,char *desc,double value)

{
  bool bVar1;
  int iVar2;
  HTAtom *pHVar3;
  HTAtom *pHVar4;
  HTSuffix *local_2c;
  HTList *cur;
  HTSuffix *suff;
  BOOLEAN trivial_enc;
  
  if ((encoding != (char *)0x0) && (*encoding != '\0')) {
    iVar2 = strcmp(encoding,"identity");
    if (iVar2 != 0) {
      iVar2 = strcmp(encoding,"8bit");
      if (iVar2 != 0) {
        iVar2 = strcmp(encoding,"binary");
        if (iVar2 != 0) {
          iVar2 = strcmp(encoding,"7bit");
          if (iVar2 != 0) {
            bVar1 = false;
            goto LAB_08107284;
          }
        }
      }
    }
  }
  bVar1 = true;
LAB_08107284:
  iVar2 = strcmp(suffix,"*");
  if (iVar2 == 0) {
    suff = &no_suffix;
  }
  else {
    iVar2 = strcmp(suffix,"*.*");
    if (iVar2 == 0) {
      suff = &unknown_suffix;
    }
    else {
      cur = HTSuffixes;
      do {
        do {
          do {
            do {
              do {
                do {
                  do {
                    do {
                      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
                        local_2c = (HTSuffix *)0x0;
                      }
                      else {
                        local_2c = (HTSuffix *)cur->object;
                      }
                      suff = local_2c;
                      if (local_2c == (HTSuffix *)0x0) goto LAB_0810743d;
                    } while (local_2c->suffix == (char *)0x0);
                    iVar2 = strcmp(local_2c->suffix,suffix);
                  } while (iVar2 != 0);
                  if (bVar1) {
                    if (local_2c->encoding == (HTAtom *)0x0) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("identity");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("8bit");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("binary");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("7bit");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                  }
                } while ((bVar1) || (local_2c->encoding == (HTAtom *)0x0));
                pHVar4 = local_2c->encoding;
                pHVar3 = HTAtom_for("identity");
              } while (pHVar4 == pHVar3);
              pHVar4 = local_2c->encoding;
              pHVar3 = HTAtom_for("8bit");
            } while (pHVar4 == pHVar3);
            pHVar4 = local_2c->encoding;
            pHVar3 = HTAtom_for("binary");
          } while (pHVar4 == pHVar3);
          pHVar4 = local_2c->encoding;
          pHVar3 = HTAtom_for("7bit");
        } while (pHVar4 == pHVar3);
        iVar2 = strcmp(encoding,local_2c->encoding->name);
      } while (iVar2 != 0);
LAB_0810743d:
      if (local_2c == (HTSuffix *)0x0) {
        suff = (HTSuffix *)calloc(1,0x14);
        if (suff == (HTSuffix *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTFile.c","HTSetSuffix");
        }
        if (HTSuffixes == (HTList *)0x0) {
          HTSuffixes = HTList_new();
        }
        HTList_addObject(HTSuffixes,suff);
        HTSACopy((char **)suff,suffix);
      }
    }
  }
  if (representation != (char *)0x0) {
    pHVar4 = HTAtom_for(representation);
    suff->rep = pHVar4;
  }
  pHVar4 = HTAtom_for(encoding);
  suff->encoding = pHVar4;
  HTSACopy(&suff->desc,desc);
  suff->quality = (float)value;
  return;
}



char * HTCacheFileName(char *name)

{
  char *__ptr;
  char *__ptr_00;
  char *__ptr_01;
  char *result;
  char *path;
  char *host;
  char *acc_method;
  
  __ptr = HTParse(name,"",0x10);
  __ptr_00 = HTParse(name,"",8);
  __ptr_01 = HTParse(name,"",5);
  result = (char *)0x0;
  HTSprintf0(&result,"%s/WWW/%s/%s%s",HTCacheRoot,__ptr,__ptr_00,__ptr_01);
  if (__ptr_01 != (char *)0x0) {
    free(__ptr_01);
  }
  if (__ptr != (char *)0x0) {
    free(__ptr);
  }
  if (__ptr_00 != (char *)0x0) {
    free(__ptr_00);
  }
  return result;
}



char * HTURLPath_toFile(char *name,BOOLEAN expand_all,BOOLEAN is_remote)

{
  char *pcVar1;
  FILE *__stream;
  char *result;
  char *path;
  
  path = (char *)0x0;
  result = (char *)0x0;
  HTSACopy(&path,name);
  if (expand_all == '\0') {
    HTUnEscapeSome(path,"/");
  }
  else {
    HTUnEscape(path);
  }
  pcVar1 = path;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"URLPath `%s\' means path `%s\'\n",name,pcVar1);
  }
  HTSACopy(&result,path);
  if (path != (char *)0x0) {
    free(path);
  }
  return result;
}



char * HTnameOfFile_WWW(char *name,BOOLEAN WWW_prefix,BOOLEAN expand_all)

{
  char *__s1;
  char *a;
  char *str;
  int iVar1;
  char *b;
  FILE *__stream;
  char *result;
  char *home;
  char *path;
  char *host;
  char *acc_method;
  
  __s1 = HTParse(name,"",0x10);
  a = HTParse(name,"",8);
  str = HTParse(name,"",5);
  result = (char *)0x0;
  if (expand_all == '\0') {
    HTUnEscapeSome(str,"/");
  }
  else {
    HTUnEscape(str);
  }
  iVar1 = strcmp(__s1,"file");
  if ((iVar1 == 0) || (*__s1 == '\0')) {
    b = HTHostName();
    iVar1 = strcasecomp(a,b);
    if (iVar1 != 0) {
      iVar1 = strcasecomp(a,"localhost");
      if ((iVar1 != 0) && (*a != '\0')) {
        if (WWW_prefix == '\0') {
          HTSACopy(&result,str);
        }
        else {
          HTSprintf0(&result,"%s%s%s","/Net/",a,str);
          b = result;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Node `%s\' means file `%s\'\n",name,b);
          }
        }
        goto LAB_081078cc;
      }
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Node `%s\' means path `%s\'\n",name,str);
    }
    HTSACopy(&result,str);
  }
  else {
    if (WWW_prefix == '\0') {
      HTSACopy(&result,str);
    }
    else {
      home = LYGetEnv("HOME");
      if (home == (char *)0x0) {
        home = "/tmp";
      }
      HTSprintf0(&result,"%s/WWW/%s/%s%s",home,__s1,a,str);
    }
  }
LAB_081078cc:
  if (a != (char *)0x0) {
    free(a);
  }
  if (str != (char *)0x0) {
    free(str);
  }
  if (__s1 != (char *)0x0) {
    free(__s1);
  }
  __s1 = result;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTnameOfFile_WWW(%s,%d,%d) = %s\n",name,(int)WWW_prefix,
            (int)expand_all,__s1);
  }
  return result;
}



char * WWW_nameOfFile(char *name)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  char *result;
  
  result = (char *)0x0;
  iVar1 = strncmp(HTMountRoot,name,5);
  if (iVar1 == 0) {
    HTSprintf0(&result,"%s//%s","file:",name + 5);
  }
  else {
    pcVar2 = HTHostName();
    HTSprintf0(&result,"%s//%s%s","file:",pcVar2,name);
  }
  pcVar2 = result;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"File `%s\'\n\tmeans node `%s\'\n",name,pcVar2);
  }
  return result;
}



char * HTFileSuffix(HTAtom *rep,char *enc)

{
  HTAtom *pHVar1;
  bool bVar2;
  int iVar3;
  char **ppcVar4;
  HTAtom *pHVar5;
  int iVar6;
  int i;
  int n;
  HTSuffix *suff;
  BOOLEAN trivial_enc;
  
  if ((((enc == (char *)0x0) || (*enc == '\0')) || (iVar3 = strcmp(enc,"identity"), iVar3 == 0)) ||
     (((iVar3 = strcmp(enc,"8bit"), iVar3 == 0 || (iVar3 = strcmp(enc,"binary"), iVar3 == 0)) ||
      (iVar3 = strcmp(enc,"7bit"), iVar3 == 0)))) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  iVar3 = HTList_count(HTSuffixes);
  i = 0;
  while( true ) {
    if (iVar3 <= i) {
      return "";
    }
    ppcVar4 = (char **)HTList_objectAt(HTSuffixes,i);
    if (((HTAtom *)ppcVar4[1] == rep) &&
       (((bVar2 && (((ppcVar4[2] == (char *)0x0 ||
                     (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("identity"),
                     pHVar1 == pHVar5)) ||
                    ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("8bit"), pHVar1 == pHVar5
                     || ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("binary"),
                         pHVar1 == pHVar5 ||
                         (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("7bit"),
                         pHVar1 == pHVar5)))))))) ||
        ((!bVar2 &&
         (((((ppcVar4[2] != (char *)0x0 &&
             (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("identity"), pHVar1 != pHVar5)) &&
            (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("8bit"), pHVar1 != pHVar5)) &&
           ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("binary"), pHVar1 != pHVar5 &&
            (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("7bit"), pHVar1 != pHVar5)))) &&
          (iVar6 = strcmp(enc,*(char **)(ppcVar4[2] + 4)), iVar6 == 0)))))))) break;
    i = i + 1;
  }
  return *ppcVar4;
}



HTFormat HTFileFormat(char *filename,HTAtom **pencoding,char **pdesc)

{
  HTAtom *pHVar1;
  size_t sVar2;
  int iVar3;
  char **ppcVar4;
  size_t sVar5;
  int iVar6;
  size_t n_00;
  HTAtom *pHVar7;
  char *pcVar8;
  HTAtom *local_3c;
  HTSuffix *local_38;
  HTSuffix *local_34;
  HTAtom *local_30;
  HTAtom *local_2c;
  int ls2;
  int j;
  int ls;
  int lf;
  int i;
  int n;
  HTSuffix *suff;
  
  if (pencoding != (HTAtom **)0x0) {
    *pencoding = (HTAtom *)0x0;
  }
  if (pdesc != (char **)0x0) {
    *pdesc = (char *)0x0;
  }
  if (LYforce_HTML_mode == '\0') {
    sVar2 = strlen(filename);
    iVar3 = HTList_count(HTSuffixes);
    i = 0;
    while (i < iVar3) {
      ppcVar4 = (char **)HTList_objectAt(HTSuffixes,i);
      sVar5 = strlen(*ppcVar4);
      if (((int)sVar5 <= (int)sVar2) &&
         (iVar6 = strcasecomp(*ppcVar4,filename + (sVar2 - sVar5)), iVar6 == 0)) {
        if (pencoding != (HTAtom **)0x0) {
          *pencoding = (HTAtom *)ppcVar4[2];
        }
        if (pdesc != (char **)0x0) {
          *pdesc = ppcVar4[3];
        }
        if (ppcVar4[1] != (char *)0x0) {
          return (HTFormat)ppcVar4[1];
        }
        j = 0;
        while (j < iVar3) {
          ppcVar4 = (char **)HTList_objectAt(HTSuffixes,j);
          n_00 = strlen(*ppcVar4);
          if ((((int)(sVar5 + n_00) <= (int)sVar2) &&
              (iVar6 = strncasecomp(*ppcVar4,filename + ((sVar2 - sVar5) - n_00),n_00), iVar6 == 0))
             && (ppcVar4[1] != (char *)0x0)) {
            if ((pdesc != (char **)0x0) && (*pdesc == (char *)0x0)) {
              *pdesc = ppcVar4[3];
            }
            if (((pencoding != (HTAtom **)0x0) &&
                ((((*pencoding == (HTAtom *)0x0 ||
                   (pHVar1 = *pencoding, pHVar7 = HTAtom_for("identity"), pHVar1 == pHVar7)) ||
                  ((pHVar1 = *pencoding, pHVar7 = HTAtom_for("8bit"), pHVar1 == pHVar7 ||
                   ((pHVar1 = *pencoding, pHVar7 = HTAtom_for("binary"), pHVar1 == pHVar7 ||
                    (pHVar1 = *pencoding, pHVar7 = HTAtom_for("7bit"), pHVar1 == pHVar7)))))) &&
                 (pHVar1 = *pencoding, pHVar7 = HTAtom_for("7bit"), pHVar1 != pHVar7)))) &&
               ((((ppcVar4[2] != (char *)0x0 &&
                  (pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("identity"), pHVar1 != pHVar7)
                  ) && (pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("8bit"), pHVar1 != pHVar7
                       )) &&
                ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("binary"), pHVar1 != pHVar7 &&
                 (pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("7bit"), pHVar1 != pHVar7))))))
            {
              *pencoding = (HTAtom *)ppcVar4[2];
            }
            return (HTFormat)ppcVar4[1];
          }
          j = j + 1;
        }
      }
      i = i + 1;
    }
    pcVar8 = strchr(filename,0x2e);
    if (pcVar8 == (char *)0x0) {
      local_38 = &no_suffix;
    }
    else {
      if (unknown_suffix.rep == (HTAtom *)0x0) {
        local_34 = &no_suffix;
      }
      else {
        local_34 = &unknown_suffix;
      }
      local_38 = local_34;
    }
    if ((pencoding != (HTAtom **)0x0) && (*pencoding == (HTAtom *)0x0)) {
      if (local_38->encoding == (HTAtom *)0x0) {
        local_30 = HTAtom_for("binary");
      }
      else {
        local_30 = local_38->encoding;
      }
      *pencoding = local_30;
    }
    if (local_38->rep == (HTAtom *)0x0) {
      local_2c = HTAtom_for("application/octet-stream");
    }
    else {
      local_2c = local_38->rep;
    }
    local_3c = local_2c;
  }
  else {
    if (pencoding != (HTAtom **)0x0) {
      pHVar1 = HTAtom_for("8bit");
      *pencoding = pHVar1;
    }
    local_3c = HTAtom_for("text/html");
  }
  return (HTFormat)local_3c;
}



HTFormat HTCharsetFormat(HTFormat format,HTParentAnchor *anchor,int default_LYhndl)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  BOOLEAN BVar4;
  char *__haystack;
  FILE *__stream;
  LYUCcharset *pLVar5;
  int LYhndl;
  ushort **ppuVar6;
  char *pcVar7;
  char *local_3c;
  LYUCcharset *p_out;
  LYUCcharset *p_in;
  int chndl;
  char *cp4;
  char *cp3;
  char *cp2;
  char *cp1;
  char *cp;
  BOOLEAN given_and_display_8859like;
  BOOLEAN given_is_8859like;
  BOOLEAN given_is_8859;
  BOOLEAN chartrans_ok;
  
  cp = (char *)0x0;
  cp3 = (char *)0x0;
  bVar1 = false;
  if (anchor->charset != (char *)0x0) {
    free(anchor->charset);
    anchor->charset = (char *)0x0;
  }
  HTSACopy(&cp,format->name);
  LYLowerCase(cp);
  __haystack = strchr(cp,0x3b);
  if (__haystack != (char *)0x0) {
    cp2 = strstr(__haystack,"charset");
    if (cp2 != (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pcVar7 = format->name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTCharsetFormat: Extended MIME Content-Type is %s\n",pcVar7);
      }
      cp2 = cp2 + 7;
      while ((*cp2 == ' ' || (*cp2 == '='))) {
        cp2 = cp2 + 1;
      }
      HTSACopy(&cp3,cp2);
      local_3c = cp3;
      cp4 = cp3;
      while ((((*cp4 != '\0' && (*cp4 != '\"')) && (*cp4 != ';')) &&
             ((*cp4 != ':' && (0x20 < (byte)*cp4))))) {
        cp4 = cp4 + 1;
      }
      *cp4 = '\0';
      chndl = UCGetLYhndl_byMIME(cp3);
      BVar4 = UCCanTranslateFromTo(chndl,current_char_set);
      if (BVar4 == '\0') {
        if (chndl < 0) {
          chndl = UCLYhndl_for_unrec;
          if (UCLYhndl_for_unrec < 0) {
            chndl = UCLYhndl_for_unspec;
          }
          BVar4 = UCCanTranslateFromTo(chndl,current_char_set);
          if (BVar4 != '\0') {
            bVar1 = true;
            HTAnchor_setUCInfoStage(anchor,chndl,0,1);
          }
        }
      }
      else {
        bVar1 = true;
        *__haystack = '\0';
        format = (HTFormat)HTAtom_for(cp);
        HTSACopy(&anchor->charset,local_3c);
        HTAnchor_setUCInfoStage(anchor,chndl,0,5);
      }
      if (bVar1) {
        pLVar5 = HTAnchor_getUCInfoStage(anchor,0);
        p_out = HTAnchor_setUCInfoStage(anchor,current_char_set,3,1);
        if (p_out == (LYUCcharset *)0x0) {
          p_out = HTAnchor_getUCInfoStage(anchor,3);
        }
        LYhndl = strcmp(pLVar5->MIMEname,"x-transparent");
        if (LYhndl == 0) {
          HTPassEightBitRaw = '\x01';
          LYhndl = HTAnchor_getUCLYhndl(anchor,3);
          HTAnchor_setUCInfoStage(anchor,LYhndl,0,1);
        }
        LYhndl = strcmp(p_out->MIMEname,"x-transparent");
        if (LYhndl == 0) {
          HTPassEightBitRaw = '\x01';
          LYhndl = HTAnchor_getUCLYhndl(anchor,0);
          HTAnchor_setUCInfoStage(anchor,LYhndl,3,1);
        }
        if (pLVar5->enc == 5) {
          if (p_out->enc == 5) {
            Set_HTCJK(pLVar5->MIMEname,p_out->MIMEname);
          }
        }
        else {
          HTCJK = NOCJK;
          if (((pLVar5->codepoints & 1U) == 0) && (chndl == current_char_set)) {
            HTPassEightBitRaw = '\x01';
          }
        }
      }
      else {
        LYhndl = strncmp(local_3c,"iso-8859-",9);
        if (LYhndl == 0) {
          ppuVar6 = __ctype_b_loc();
          if (((*ppuVar6)[(byte)local_3c[9]] & 0x800) == 0) goto LAB_08108384;
          bVar2 = true;
        }
        else {
LAB_08108384:
          bVar2 = false;
        }
        if (bVar2) {
LAB_081083f5:
          bVar3 = true;
        }
        else {
          LYhndl = strncmp(local_3c,"windows-",8);
          if (LYhndl == 0) goto LAB_081083f5;
          LYhndl = strncmp(local_3c,"cp12",4);
          if (LYhndl == 0) goto LAB_081083f5;
          LYhndl = strncmp(local_3c,"cp-12",5);
          if (LYhndl == 0) goto LAB_081083f5;
          bVar3 = false;
        }
        if (bVar3) {
          pcVar7 = strstr(LYchar_set_names[current_char_set],"ISO-8859");
          if (pcVar7 == (char *)0x0) {
            pcVar7 = strstr(LYchar_set_names[current_char_set],"windows-");
            if (pcVar7 == (char *)0x0) goto LAB_0810845b;
          }
          bVar3 = true;
        }
        else {
LAB_0810845b:
          bVar3 = false;
        }
        if (bVar3) {
          *__haystack = '\0';
          format = (HTFormat)HTAtom_for(cp);
        }
        if (bVar2) {
          cp1 = local_3c + 10;
          while (*cp1 != '\0') {
            ppuVar6 = __ctype_b_loc();
            if (((*ppuVar6)[(byte)*cp1] & 0x800) == 0) break;
            cp1 = cp1 + 1;
          }
          *cp1 = '\0';
        }
        if (bVar3) {
          HTSACopy(&anchor->charset,local_3c);
          HTPassEightBitRaw = '\x01';
        }
        if (*local_3c == '\0') {
          local_3c = anchor->charset;
        }
        else {
        }
        HTAlert(local_3c);
      }
      if (cp3 != (char *)0x0) {
        free(cp3);
        cp3 = (char *)0x0;
      }
      goto LAB_08108549;
    }
  }
  if (__haystack != (char *)0x0) {
    *__haystack = '\0';
    format = (HTFormat)HTAtom_for(cp);
  }
LAB_08108549:
  if (cp != (char *)0x0) {
    free(cp);
    cp = (char *)0x0;
  }
  if (((!bVar1) && (anchor->charset == (char *)0x0)) && (-1 < default_LYhndl)) {
    HTAnchor_setUCInfoStage(anchor,default_LYhndl,0,1);
  }
  HTAnchor_copyUCInfoStage(anchor,1,0,-1);
  return format;
}



void LYGetFileInfo(char *filename,HTParentAnchor **pfile_anchor,HTFormat *pformat,HTAtom **pencoding
                  ,char **pdesc,char **pcharset,int *pfile_cs)

{
  char *pcVar1;
  char *source;
  HTParentAnchor *anchor;
  HTFormat format_00;
  int iVar2;
  FILE *__stream;
  char *local_34;
  undefined *local_30;
  undefined *local_2c;
  undefined *local_28;
  int file_cs;
  char *file_csname;
  HTParentAnchor *file_anchor;
  HTAtom *myEnc;
  HTFormat format;
  char *Aname;
  char *Afn;
  
  Aname = (char *)0x0;
  myEnc = (HTAtom *)0x0;
  source = HTEscape(filename,'\x04');
  LYLocalFileToURL(&Aname,source);
  anchor = HTAnchor_findSimpleAddress(Aname);
  file_csname = anchor->charset;
  format_00 = HTFileFormat(filename,&myEnc,pdesc);
  format_00 = HTCharsetFormat(format_00,anchor,UCLYhndl_HTFile_for_unspec);
  iVar2 = HTAnchor_getUCLYhndl(anchor,0);
  if (file_csname == (char *)0x0) {
    if (iVar2 < 0) {
      file_csname = "display character set";
    }
    else {
      file_csname = LYCharSet_UC[iVar2].MIMEname;
    }
  }
  if (WWW_TraceFlag == '\0') goto LAB_08108757;
  pcVar1 = format_00->name;
  if (myEnc == (HTAtom *)0x0) {
    local_34 = "";
LAB_081086d2:
    if (myEnc == (HTAtom *)0x0) {
      if (*format_00->name == 'a') {
        local_28 = &DAT_08180872;
      }
      else {
        local_28 = &DAT_08180464;
      }
      local_2c = local_28;
    }
    else {
      local_2c = &DAT_08180464;
    }
    local_30 = local_2c;
  }
  else {
    local_34 = myEnc->name;
    if (*myEnc->name != '8') goto LAB_081086d2;
    local_30 = &DAT_08180872;
  }
  __stream = TraceFP();
  fprintf((FILE *)__stream,"GetFileInfo: \'%s\' is a%s %s %s file, charset=%s (%d).\n",filename,
          local_30,local_34,pcVar1,file_csname,iVar2);
LAB_08108757:
  if (source != (char *)0x0) {
    free(source);
  }
  if (Aname != (char *)0x0) {
    free(Aname);
  }
  if (pfile_anchor != (HTParentAnchor **)0x0) {
    *pfile_anchor = anchor;
  }
  if (pformat != (HTFormat *)0x0) {
    *pformat = format_00;
  }
  if (pencoding != (HTAtom **)0x0) {
    *pencoding = myEnc;
  }
  if (pcharset != (char **)0x0) {
    *pcharset = file_csname;
  }
  if (pfile_cs != (int *)0x0) {
    *pfile_cs = iVar2;
  }
  return;
}



float HTFileValue(char *filename)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  char **ppcVar4;
  size_t sVar5;
  int iVar6;
  FILE *__stream;
  int ls;
  int lf;
  int i;
  int n;
  HTSuffix *suff;
  
  sVar2 = strlen(filename);
  iVar3 = HTList_count(HTSuffixes);
  i = 0;
  while( true ) {
    if (iVar3 <= i) {
      return 0.30000001;
    }
    ppcVar4 = (char **)HTList_objectAt(HTSuffixes,i);
    sVar5 = strlen(*ppcVar4);
    if (((int)sVar5 <= (int)sVar2) &&
       (iVar6 = strcmp(*ppcVar4,filename + (sVar2 - sVar5)), iVar6 == 0)) break;
    i = i + 1;
  }
  if (WWW_TraceFlag != '\0') {
    pcVar1 = ppcVar4[4];
    __stream = TraceFP();
    fprintf((FILE *)__stream,"File: Value of %s is %.3f\n",filename,(double)(float)pcVar1);
  }
  return (float)ppcVar4[4];
}



CompressFileType HTCompressFileType(char *filename,char *dots,int *rootlen)

{
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  FILE *__stream;
  char *ftype;
  size_t len;
  CompressFileType result;
  
  result = cftNone;
  sVar1 = strlen(filename);
  ftype = filename + sVar1;
  if (4 < sVar1) {
    iVar2 = strcasecomp(ftype + -3,"bz2");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-4]);
      if (pcVar3 != (char *)0x0) {
        result = cftBzip2;
        ftype = ftype + -4;
        goto LAB_08108a16;
      }
    }
  }
  if (3 < sVar1) {
    iVar2 = strcasecomp(ftype + -2,"gz");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-3]);
      if (pcVar3 != (char *)0x0) {
        result = cftGzip;
        ftype = ftype + -3;
        goto LAB_08108a16;
      }
    }
  }
  if (3 < sVar1) {
    iVar2 = strcasecomp(ftype + -2,"zz");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-3]);
      if (pcVar3 != (char *)0x0) {
        result = cftDeflate;
        ftype = ftype + -3;
        goto LAB_08108a16;
      }
    }
  }
  if (2 < sVar1) {
    iVar2 = strcmp(ftype + -1,"Z");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-2]);
      if (pcVar3 != (char *)0x0) {
        result = cftCompress;
        ftype = ftype + -2;
      }
    }
  }
LAB_08108a16:
  *(char **)rootlen = ftype + -(int)filename;
  if (WWW_TraceFlag != '\0') {
    iVar2 = *rootlen;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTCompressFileType(%s) returns %d:%s\n",filename,result,
            filename + iVar2);
  }
  return result;
}



char * HTCompressTypeToSuffix(CompressFileType method)

{
  char *result;
  
  if (method == cftGzip) {
    result = ".gz";
    return result;
  }
  if (method < cftBzip2) {
    if (method == cftCompress) {
      result = ".Z";
      return result;
    }
  }
  else {
    if (method == cftBzip2) {
      result = ".bz2";
      return result;
    }
    if (method == cftDeflate) {
      result = ".zz";
      return result;
    }
  }
  result = "";
  return result;
}



char * HTCompressTypeToEncoding(CompressFileType method)

{
  char *result;
  
  if (method == cftGzip) {
    result = "gzip";
    return result;
  }
  if (method < cftBzip2) {
    if (method == cftCompress) {
      result = "compress";
      return result;
    }
  }
  else {
    if (method == cftBzip2) {
      result = "bzip2";
      return result;
    }
    if (method == cftDeflate) {
      result = "deflate";
      return result;
    }
  }
  return (char *)0x0;
}



CompressFileType HTEncodingToCompressType(char *coding)

{
  int iVar1;
  CompressFileType result;
  
  if (coding == (char *)0x0) {
    result = cftNone;
  }
  else {
    iVar1 = strcasecomp(coding,"gzip");
    if ((iVar1 != 0) && (iVar1 = strcasecomp(coding,"x-gzip"), iVar1 != 0)) {
      iVar1 = strcasecomp(coding,"compress");
      if ((iVar1 == 0) || (iVar1 = strcasecomp(coding,"x-compress"), iVar1 == 0)) {
        return cftCompress;
      }
      iVar1 = strcasecomp(coding,"bzip2");
      if ((iVar1 == 0) || (iVar1 = strcasecomp(coding,"x-bzip2"), iVar1 == 0)) {
        return cftBzip2;
      }
      iVar1 = strcasecomp(coding,"deflate");
      if ((iVar1 != 0) && (iVar1 = strcasecomp(coding,"x-deflate"), iVar1 != 0)) {
        return cftNone;
      }
      return cftDeflate;
    }
    result = cftGzip;
  }
  return result;
}



CompressFileType HTContentTypeToCompressType(char *ct)

{
  int iVar1;
  CompressFileType method;
  
  if (ct == (char *)0x0) {
    method = cftNone;
  }
  else {
    iVar1 = strncasecomp(ct,"application/gzip",0x10);
    if ((iVar1 != 0) && (iVar1 = strncasecomp(ct,"application/x-gzip",0x12), iVar1 != 0)) {
      iVar1 = strncasecomp(ct,"application/compress",0x14);
      if ((iVar1 != 0) && (iVar1 = strncasecomp(ct,"application/x-compress",0x16), iVar1 != 0)) {
        iVar1 = strncasecomp(ct,"application/bzip2",0x11);
        if ((iVar1 != 0) && (iVar1 = strncasecomp(ct,"application/x-bzip2",0x13), iVar1 != 0)) {
          return cftNone;
        }
        return cftBzip2;
      }
      return cftCompress;
    }
    method = cftGzip;
  }
  return method;
}



CompressFileType HTContentToCompressType(HTParentAnchor *anchor)

{
  char *ct_00;
  char *coding;
  char *ce;
  char *ct;
  CompressFileType method;
  
  method = cftNone;
  ct_00 = HTAnchor_content_type(anchor);
  coding = HTAnchor_content_encoding(anchor);
  if ((coding == (char *)0x0) && (ct_00 != (char *)0x0)) {
    method = HTContentTypeToCompressType(ct_00);
  }
  else {
    if (coding != (char *)0x0) {
      method = HTEncodingToCompressType(coding);
    }
  }
  return method;
}



BOOLEAN HTEditable(char *filename)

{
  gid_t gVar1;
  __mode_t _Var2;
  int iVar3;
  __uid_t _Var4;
  FILE *__stream;
  __uid_t _Var5;
  __gid_t _Var6;
  __uid_t _Var7;
  int iVar8;
  BOOLEAN BStack262277;
  gid_t groups [65536];
  stat fileStatus;
  int i2;
  int i;
  int ngroups;
  uid_t myUid;
  
  iVar3 = stat64(filename,(stat64 *)&fileStatus);
  if (iVar3 == 0) {
    iVar3 = getgroups(0x10000,groups);
    _Var4 = geteuid();
    _Var6 = fileStatus.st_gid;
    _Var5 = fileStatus.st_uid;
    _Var2 = fileStatus.st_mode;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      _Var7 = _Var4;
      iVar8 = iVar3;
      fprintf((FILE *)__stream,"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",_Var2,
              _Var5,_Var6,_Var4,iVar3);
      i2 = 0;
      while (i2 < iVar3) {
        gVar1 = groups[i2];
        __stream = TraceFP();
        fprintf((FILE *)__stream," %d",gVar1,_Var5,_Var6,_Var7,iVar8);
        i2 = i2 + 1;
      }
      __stream = TraceFP();
      fwrite(&DAT_081809fd,1,2,(FILE *)__stream);
    }
    if ((fileStatus.st_mode & 2) == 0) {
      if (((fileStatus.st_mode & 0x80) == 0) || (fileStatus.st_uid != _Var4)) {
        if ((fileStatus.st_mode & 0x10) != 0) {
          i = 0;
          while (i < iVar3) {
            if (groups[i] == fileStatus.st_gid) {
              return '\x01';
            }
            i = i + 1;
          }
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"\tFile is not editable.\n");
        }
        BStack262277 = '\0';
      }
      else {
        BStack262277 = '\x01';
      }
    }
    else {
      BStack262277 = '\x01';
    }
  }
  else {
    BStack262277 = '\0';
  }
  return BStack262277;
}



HTStream * HTFileSaveStream(HTParentAnchor *anchor)

{
  char *__filename;
  FILE *fp_00;
  HTStream *local_18;
  FILE *fp;
  char *localname;
  char *addr;
  
  __filename = HTnameOfFile_WWW(anchor->address,'\x01','\x01');
  fp_00 = (FILE *)fopen64(__filename,"wb");
  if (__filename != (char *)0x0) {
    free(__filename);
  }
  if (fp_00 == (FILE *)0x0) {
    local_18 = (HTStream *)0x0;
  }
  else {
    local_18 = HTFWriter_new(fp_00);
  }
  return local_18;
}



void HTDirEntry(HTStructured *target,char *tail,char *entry)

{
  int iVar1;
  size_t sVar2;
  ushort **ppuVar3;
  bool bVar4;
  char *local_20;
  undefined *local_18;
  int len;
  char *escaped;
  char *stripped;
  char *relative;
  
  relative = (char *)0x0;
  stripped = (char *)0x0;
  escaped = (char *)0x0;
  HTSACopy(&escaped,entry);
  LYTrimPathSep(escaped);
  iVar1 = strcmp(escaped,"..");
  if (iVar1 != 0) {
    stripped = escaped;
    escaped = HTEscape(escaped,'\x02');
    sVar2 = strlen(escaped);
    if (((2 < (int)sVar2) && (escaped[sVar2 - 3] == '%')) && (escaped[sVar2 - 2] == '2')) {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)escaped[sVar2 - 1]] & 0x200) == 0) {
        bVar4 = escaped[sVar2 - 1] == 'F';
      }
      else {
        iVar1 = toupper((uint)(byte)escaped[sVar2 - 1]);
        bVar4 = iVar1 == 0x46;
      }
      if (bVar4) {
        escaped[sVar2 - 3] = '\0';
      }
    }
  }
  if ((tail == (char *)0x0) || (*tail == '\0')) {
    if (*escaped == '\0') {
      local_20 = "/";
    }
    else {
      local_20 = escaped;
    }
    HTStartAnchor(target,(char *)0x0,local_20);
  }
  else {
    relative = (char *)0x0;
    if (*escaped == '\0') {
      local_18 = &DAT_08180464;
    }
    else {
      local_18 = &DAT_081806fc;
    }
    HTSprintf0(&relative,"%s%s%s",tail,local_18,escaped);
    HTStartAnchor(target,(char *)0x0,relative);
    if (relative != (char *)0x0) {
      free(relative);
      relative = (char *)0x0;
    }
  }
  if (stripped != (char *)0x0) {
    free(stripped);
  }
  if (escaped != (char *)0x0) {
    free(escaped);
  }
  return;
}



BOOLEAN view_structured(HTFormat format_out)

{
  HTAtom *pHVar1;
  BOOLEAN result;
  
  if ((psrc_view == '\0') && (pHVar1 = HTAtom_for("www/dump"), pHVar1 != (HTAtom *)format_out)) {
    return '\0';
  }
  return '\x01';
}



void HTStructured_doctype(HTStructured *target,HTFormat format_out)

{
  BOOLEAN BVar1;
  
  BVar1 = view_structured(format_out);
  if (BVar1 != '\0') {
    (*target->isa->put_string)
              (target,"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
  }
  return;
}



void HTStructured_meta(HTStructured *target,HTFormat format_out)

{
  BOOLEAN BVar1;
  
  BVar1 = view_structured(format_out);
  if (BVar1 != '\0') {
    (*target->isa->put_string)
              (target,
               "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n");
  }
  return;
}



BOOLEAN HTDirTitles(HTStructured *target,HTParentAnchor *anchor,HTFormat format_out,
                   BOOLEAN tildeIsTop)

{
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar1;
  BOOLEAN BVar2;
  char *__s1;
  int iVar3;
  ushort **ppuVar4;
  char *a;
  char *__s1_00;
  DIR *__dirp;
  char *aName;
  char *local_60;
  char *local_58;
  char *local_50;
  char *local_48;
  char *local_40;
  char *fullparentpath;
  DIR *dp;
  char *printable;
  char *parent;
  int i;
  char *cp;
  char *current;
  char *path;
  char *logical;
  BOOLEAN need_parent_link;
  
  aName = anchor->address;
  __s1 = HTParse(aName,"",5);
  cp = (char *)0x0;
  if ((tildeIsTop != '\0') && (iVar3 = strncmp(__s1,"/~",2), iVar3 == 0)) {
    if (__s1[2] == '\0') {
      __s1[1] = '\0';
    }
    else {
      i = 0;
      while (__s1[i + 2] != '\0') {
        __s1[i] = __s1[i + 2];
        i = i + 1;
      }
      __s1[i] = '\0';
    }
  }
  cp = strrchr(__s1,0x3b);
  if (cp == (char *)0x0) goto LAB_0810946b;
  iVar3 = strncasecomp(cp + 1,"type=",5);
  if (iVar3 != 0) goto LAB_08109464;
  ppuVar4 = __ctype_b_loc();
  if (((*ppuVar4)[(byte)cp[6]] & 0x200) == 0) {
    if (cp[6] != 'D') goto LAB_081093c0;
LAB_0810945e:
    *cp = '\0';
  }
  else {
    iVar3 = toupper((uint)(byte)cp[6]);
    if (iVar3 == 0x44) goto LAB_0810945e;
LAB_081093c0:
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[(byte)cp[6]] & 0x200) == 0) {
      if (cp[6] != 'A') goto LAB_0810940f;
      goto LAB_0810945e;
    }
    iVar3 = toupper((uint)(byte)cp[6]);
    if (iVar3 == 0x41) goto LAB_0810945e;
LAB_0810940f:
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[(byte)cp[6]] & 0x200) == 0) {
      if (cp[6] == 'I') goto LAB_0810945e;
    }
    else {
      iVar3 = toupper((uint)(byte)cp[6]);
      if (iVar3 == 0x49) goto LAB_0810945e;
    }
  }
LAB_08109464:
  cp = (char *)0x0;
LAB_0810946b:
  a = LYPathLeaf(__s1);
  printable = (char *)0x0;
  iVar3 = strncasecomp(__s1,"/%2F",4);
  local_60 = __s1;
  if (iVar3 == 0) {
    local_60 = __s1 + 1;
  }
  printable = HTURLPath_toFile(local_60,'\x01','\x01');
  iVar3 = strncasecomp(printable,"/vmsysu:",8);
  if ((iVar3 == 0) || (iVar3 = strncasecomp(printable,"/anonymou.",10), iVar3 == 0)) {
    HTSACopy(&cp,printable + 1);
    HTSACopy(&printable,cp);
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
  }
  HTStructured_doctype(target,format_out);
  (*target->isa->start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  (*target->isa->start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  paVar1 = target->isa->put_string;
  if (*printable == '\0') {
    local_58 = (char *)gettext("Welcome");
  }
  else {
    local_58 = printable;
  }
  (*paVar1)(target,local_58);
  paVar1 = target->isa->put_string;
  __s1_00 = (char *)gettext(" directory");
  (*paVar1)(target,__s1_00);
  (*target->isa->end_element)(target,0x6e,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  HTStructured_meta(target,format_out);
  (*target->isa->end_element)(target,0x35,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  (*target->isa->start_element)(target,0x11,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  (*target->isa->start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  paVar1 = target->isa->put_string;
  if (*printable == '\0') {
    local_50 = "";
  }
  else {
    local_50 = (char *)gettext("Current directory is ");
  }
  (*paVar1)(target,local_50);
  paVar1 = target->isa->put_string;
  if (*printable == '\0') {
    local_48 = (char *)gettext("Welcome");
  }
  else {
    local_48 = printable;
  }
  (*paVar1)(target,local_48);
  (*target->isa->end_element)(target,0x30,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  iVar3 = strncasecomp(printable,"vmsysu:",7);
  if ((((iVar3 == 0) && (cp = strchr(printable,0x2e), cp != (char *)0x0)) &&
      (__s1_00 = strchr(cp,0x2f), __s1_00 == (char *)0x0)) ||
     ((iVar3 = strncasecomp(printable,"anonymou.",9), iVar3 == 0 &&
      (__s1_00 = strchr(printable,0x2f), __s1_00 == (char *)0x0)))) {
    if (printable != (char *)0x0) {
      free(printable);
      printable = (char *)0x0;
    }
    if (__s1 != (char *)0x0) {
      free(__s1);
    }
    return '\0';
  }
  if (printable != (char *)0x0) {
    free(printable);
    printable = (char *)0x0;
  }
  if (((a != __s1 && -1 < (int)(a + -(int)__s1)) && (a[-1] == '/')) && (*a != '\0')) {
    printable = (char *)0x0;
    a[-1] = '\0';
    __s1_00 = strrchr(__s1,0x2f);
    if (((__s1_00 != (char *)0x0) &&
        ((iVar3 = strcmp(__s1_00,"/.."), iVar3 == 0 ||
         (iVar3 = strncasecomp(__s1_00,"/%2F",4), iVar3 == 0)))) ||
       (iVar3 = strncasecomp(a,"%2F",3), iVar3 == 0)) {
      if (__s1 != (char *)0x0) {
        free(__s1);
      }
      return '\0';
    }
    printable = (char *)0x0;
    HTSprintf0(&printable,"%s/..",a);
    BVar2 = LYisLocalFile(aName);
    if (BVar2 != '\0') {
      fullparentpath = (char *)0x0;
      local_40 = __s1;
      if (*__s1 == '\0') {
        local_40 = "/";
      }
      HTSACopy(&fullparentpath,local_40);
      iVar3 = strcmp(a,"..");
      if (iVar3 == 0) {
        HTSACat(&fullparentpath,"/../..");
      }
      else {
        iVar3 = strcmp(a,".");
        if (iVar3 == 0) {
          HTSACat(&fullparentpath,"/..");
        }
      }
      HTUnEscape(fullparentpath);
      __dirp = opendir(fullparentpath);
      if (__dirp == (DIR *)0x0) {
        if (fullparentpath != (char *)0x0) {
          free(fullparentpath);
          fullparentpath = (char *)0x0;
        }
        if (printable != (char *)0x0) {
          free(printable);
          printable = (char *)0x0;
        }
        if (__s1 != (char *)0x0) {
          free(__s1);
        }
        return '\0';
      }
      closedir(__dirp);
      if (fullparentpath != (char *)0x0) {
        free(fullparentpath);
        fullparentpath = (char *)0x0;
      }
      if (__s1 != (char *)0x0) {
        free(__s1);
      }
      if (printable != (char *)0x0) {
        free(printable);
      }
      return '\x01';
    }
    HTStartAnchor(target,"",printable);
    if (printable != (char *)0x0) {
      free(printable);
      printable = (char *)0x0;
    }
    paVar1 = target->isa->put_string;
    aName = (char *)gettext("Up to ");
    (*paVar1)(target,aName);
    if (__s1_00 == (char *)0x0) {
      (*target->isa->put_character)(target,'/');
    }
    else {
      iVar3 = strcmp(a,".");
      if ((iVar3 == 0) || (iVar3 = strcmp(a,".."), iVar3 == 0)) {
        (*target->isa->put_string)(target,"..");
      }
      else {
        fullparentpath = (char *)0x0;
        HTSACopy(&fullparentpath,__s1_00 + 1);
        HTUnEscape(fullparentpath);
        (*target->isa->put_string)(target,fullparentpath);
        if (fullparentpath != (char *)0x0) {
          free(fullparentpath);
          fullparentpath = (char *)0x0;
        }
      }
    }
    (*target->isa->end_element)(target,0,(char **)0x0);
    (*target->isa->put_character)(target,'\n');
  }
  if (__s1 != (char *)0x0) {
    free(__s1);
  }
  return '\0';
}



// WARNING: Variable defined which should be unmapped: targetClass

void do_readme(HTStructured *target,char *localname)

{
  FILE *__stream;
  int iVar1;
  HTStructuredClass targetClass;
  int ch;
  char *readme_file_name;
  FILE *fp;
  
  readme_file_name = (char *)0x0;
  HTSprintf0(&readme_file_name,"%s/%s",localname,"README");
  __stream = fopen64(readme_file_name,"r");
  if (__stream != (FILE *)0x0) {
    (*target->isa->start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    while( true ) {
      iVar1 = fgetc(__stream);
      if (iVar1 == -1) break;
      (*target->isa->put_character)(target,(char)iVar1);
    }
    (*target->isa->end_element)(target,0x56,(char **)0x0);
    HTDisplayPartial();
    fclose(__stream);
  }
  if (readme_file_name != (char *)0x0) {
    free(readme_file_name);
  }
  return;
}



char * file_type(char *path)

{
  char *type;
  
  while (*path == '.') {
    path = path + 1;
  }
  type = strchr(path,0x2e);
  if (type == (char *)0x0) {
    type = "";
  }
  return type;
}



int dired_cmp(void *a,void *b)

{
  char *__s2;
  char *__s1;
  int local_58;
  int local_30;
  int local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  int code;
  DIRED *q;
  DIRED *p;
  
  code = (int)*(char *)((int)a + 0x60) - (int)*(char *)((int)b + 0x60);
  if (code == 0) {
    switch(dir_list_order) {
    default:
      code = 0;
      break;
    case 1:
      if ((*(int *)((int)a + 0x30) < *(int *)((int)b + 0x30)) ||
         ((*(int *)((int)a + 0x30) <= *(int *)((int)b + 0x30) &&
          (*(uint *)((int)a + 0x2c) < *(uint *)((int)b + 0x2c))))) {
        local_58 = 1;
      }
      else {
        local_30 = 1;
        if ((*(int *)((int)a + 0x30) <= *(int *)((int)b + 0x30)) &&
           ((*(int *)((int)a + 0x30) < *(int *)((int)b + 0x30) ||
            (*(uint *)((int)a + 0x2c) <= *(uint *)((int)b + 0x2c))))) {
          local_30 = 0;
        }
        local_58 = -local_30;
      }
      code = local_58;
      break;
    case 2:
      if (*(int *)((int)a + 0x48) < *(int *)((int)b + 0x48)) {
        local_2c = 1;
      }
      else {
        local_2c = -(uint)(*(int *)((int)b + 0x48) < *(int *)((int)a + 0x48));
      }
      code = local_2c;
      break;
    case 3:
      if (*(uint *)((int)a + 0x10) < *(uint *)((int)b + 0x10)) {
        local_28 = 0xffffffff;
      }
      else {
        local_28 = (uint)(*(uint *)((int)b + 0x10) < *(uint *)((int)a + 0x10));
      }
      code = local_28;
      break;
    case 4:
      __s2 = file_type((char *)((int)b + 0x61));
      __s1 = file_type((char *)((int)a + 0x61));
      code = strcmp(__s1,__s2);
      break;
    case 5:
      if (*(uint *)((int)a + 0x18) < *(uint *)((int)b + 0x18)) {
        local_24 = 0xffffffff;
      }
      else {
        local_24 = (uint)(*(uint *)((int)b + 0x18) < *(uint *)((int)a + 0x18));
      }
      code = local_24;
      break;
    case 6:
      if (*(uint *)((int)a + 0x1c) < *(uint *)((int)b + 0x1c)) {
        local_20 = 0xffffffff;
      }
      else {
        local_20 = (uint)(*(uint *)((int)b + 0x1c) < *(uint *)((int)a + 0x1c));
      }
      code = local_20;
    }
  }
  if (code == 0) {
    code = strcmp((char *)((int)a + 0x61),(char *)((int)b + 0x61));
  }
  return code;
}



int print_local_dir(DIR *dp,char *localname,HTParentAnchor *anchor,HTFormat format_out,
                   HTStream *sink)

{
  int iVar1;
  anon_subr_void_HTStructured_ptr_HTError_for__abort *paVar2;
  DIRED *data_00;
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar3;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *__stream;
  char *__s;
  HTStructured *target_00;
  int iVar6;
  HTAtom *form;
  HTBTree *tree;
  size_t sVar7;
  stat64 *__buf;
  dirent64 *pdVar8;
  int in_GS_OFFSET;
  int local_11c;
  char local_116;
  char local_115;
  char *local_110;
  int local_10c;
  stat link_info;
  HTStructuredClass targetClass;
  DIRED *entry;
  int num_of_entries_output;
  HTBTElement *next_element;
  DIRED *data;
  int num_of_entries;
  stat *actual_info;
  int i;
  int status;
  char *tmpfilename;
  char *p;
  char *tail;
  char *pathname;
  dirent *dirbuf;
  HTBTree *bt;
  HTStructured *target;
  char test;
  char state;
  BOOLEAN preformatted;
  BOOLEAN need_parent_link;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  tail = (char *)0x0;
  tmpfilename = (char *)0x0;
  bVar4 = false;
  num_of_entries = 0;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"print_local_dir() started\n");
  }
  __s = HTParse(anchor->address,"",5);
  p = strrchr(__s,0x2f);
  if (p == (char *)0x0) {
    p = "/";
  }
  HTSACopy(&tail,p + 1);
  if (__s != (char *)0x0) {
    free(__s);
  }
  if (-1 < UCLYhndl_HTFile_for_unspec) {
    HTAnchor_setUCInfoStage(anchor,UCLYhndl_HTFile_for_unspec,1,1);
  }
  target_00 = HTML_new(anchor,format_out,sink);
  paVar2 = target_00->isa->_abort;
  i = 0;
  while (i < 0x19) {
    *(bool *)(present + i) = i == 6;
    i = i + 1;
  }
  BVar5 = HTDirTitles(target_00,anchor,format_out,'\0');
  if ((*anchor->address == 'l') || (*anchor->address == 'L')) {
    iVar6 = strncasecomp(anchor->address,"lynxcgi:",8);
    if (iVar6 == 0) goto LAB_0810a2bf;
  }
  form = HTAtom_for("www/dired");
  HTAnchor_setFormat(anchor,(HTFormat)form);
  lynx_edit_mode = '\x01';
LAB_0810a2bf:
  if (HTDirReadme == 1) {
    do_readme(target_00,localname);
  }
  tree = HTBTree_new(dired_cmp);
  mustshow = '\x01';
  __s = (char *)gettext("Reading directory...");
  HTProgress(__s);
  status = 200;
  while( true ) {
    pdVar8 = readdir64((DIR *)dp);
    if (pdVar8 == (dirent64 *)0x0) break;
    if ((*(uint *)&pdVar8->d_ino | *(uint *)((int)&pdVar8->d_ino + 4)) != 0) {
      iVar6 = strcmp(pdVar8->d_name,".");
      if (iVar6 != 0) {
        iVar6 = strcmp(pdVar8->d_name,"..");
        if ((iVar6 != 0) || (BVar5 != '\0')) {
          iVar6 = strcmp(pdVar8->d_name,"..");
          if (((iVar6 == 0) || (pdVar8->d_name[0] != '.')) ||
             ((no_dotfiles == '\0' && (show_dotfiles != '\0')))) {
            HTSACopy(&tmpfilename,localname);
            LYAddPathSep(&tmpfilename);
            HTSACat(&tmpfilename,pdVar8->d_name);
            sVar7 = strlen(pdVar8->d_name);
            __buf = (stat64 *)malloc(sVar7 + 0x68);
            if (__buf == (stat64 *)0x0) {
              status = 0xce;
              break;
            }
            LYTrimPathSep(tmpfilename);
            iVar6 = lstat64(tmpfilename,__buf);
            actual_info = (stat *)__buf;
            if (iVar6 < 0) {
              __buf->st_mode = 0;
            }
            else {
              if ((__buf->st_mode & 0xf000) == 0xa000) {
                actual_info = &link_info;
                iVar6 = stat64(tmpfilename,(stat64 *)actual_info);
                if (iVar6 < 0) {
                  link_info.st_mode = 0;
                }
              }
            }
            strcpy((char *)((int)&__buf[1].st_dev + 1),pdVar8->d_name);
            if ((actual_info->st_mode & 0xf000) == 0x4000) {
              if (dir_list_style == 2) {
                *(undefined *)&__buf[1].st_dev = 0x20;
                LYAddPathSep0((char *)((int)&__buf[1].st_dev + 1));
              }
              else {
                iVar6 = strcmp(pdVar8->d_name,"..");
                if (iVar6 == 0) {
                  *(undefined *)&__buf[1].st_dev = 0x41;
                }
                else {
                  *(undefined *)&__buf[1].st_dev = 0x44;
                }
              }
            }
            else {
              if (dir_list_style == 2) {
                *(undefined *)&__buf[1].st_dev = 0x20;
              }
              else {
                if (dir_list_style == 1) {
                  *(undefined *)&__buf[1].st_dev = 0x43;
                }
                else {
                  *(undefined *)&__buf[1].st_dev = 0x46;
                }
              }
            }
            HTBTree_add(tree,__buf);
            if (partial_threshold < 1) {
              local_11c = display_lines;
            }
            else {
              local_11c = partial_threshold;
            }
            if (num_of_entries % local_11c == 0) {
              iVar6 = HTCheckForInterrupt();
              if (iVar6 != 0) {
                status = 0xce;
                break;
              }
            }
            num_of_entries = num_of_entries + 1;
          }
        }
      }
    }
  }
  if (status == 0xce) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Reading the directory interrupted by user\n");
    }
  }
  else {
    mustshow = '\x01';
    __s = (char *)gettext(&DAT_08180b9f);
    HTProgress(__s);
  }
  next_element = HTBTree_next(tree,(HTBTElement *)0x0);
  num_of_entries_output = 0;
  state = 'I';
  do {
    if (next_element == (HTBTElement *)0x0) {
LAB_0810a948:
      if ((status == 200) && (state == 'I')) {
        (*target_00->isa->start_element)(target_00,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0)
        ;
        (*target_00->isa->put_string)(target_00,"Empty Directory");
      }
      if (bVar4) {
        (*target_00->isa->end_element)(target_00,0x56,(char **)0x0);
        (*target_00->isa->put_character)(target_00,'\n');
      }
      (*target_00->isa->end_element)(target_00,0x11,(char **)0x0);
      (*target_00->isa->put_character)(target_00,'\n');
      if (tmpfilename != (char *)0x0) {
        free(tmpfilename);
        tmpfilename = (char *)0x0;
      }
      if (tail != (char *)0x0) {
        free(tail);
        tail = (char *)0x0;
      }
      HTBTreeAndObject_free(tree);
      if (status == 200) {
        if (HTDirReadme == 2) {
          do_readme(target_00,localname);
        }
        (*target_00->isa->_free)(target_00);
      }
      else {
        (*paVar2)(target_00,(HTError)0x0);
      }
      HTFinishDisplayPartial();
      if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return status;
    }
    HTSACopy(&tmpfilename,localname);
    LYAddPathSep(&tmpfilename);
    data_00 = (DIRED *)next_element->object;
    HTSACat(&tmpfilename,data_00->file_name);
    HTSimplify(tmpfilename);
    iVar6 = strcmp((char *)((int)next_element->object + 0x61),"..");
    if (iVar6 != 0) {
      if (*(char *)((int)next_element->object + 0x60) == 'D') {
        local_116 = 'D';
      }
      else {
        local_116 = 'F';
      }
      if (state != local_116) {
        if (*(char *)((int)next_element->object + 0x60) == 'D') {
          local_115 = 'D';
        }
        else {
          local_115 = 'F';
        }
        state = local_115;
        if (bVar4) {
          (*target_00->isa->end_element)(target_00,0x56,(char **)0x0);
          (*target_00->isa->put_character)(target_00,'\n');
          bVar4 = false;
        }
        (*target_00->isa->start_element)(target_00,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0)
        ;
        if (dir_list_style != 2) {
          (*target_00->isa->start_element)
                    (target_00,0x26,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          paVar3 = target_00->isa->put_string;
          if (local_115 == 'D') {
            local_110 = (char *)gettext("Subdirectories:");
          }
          else {
            local_110 = (char *)gettext("Files:");
          }
          (*paVar3)(target_00,local_110);
          (*target_00->isa->end_element)(target_00,0x26,(char **)0x0);
        }
        (*target_00->isa->end_element)(target_00,0x30,(char **)0x0);
        (*target_00->isa->put_character)(target_00,'\n');
      }
    }
    if (!bVar4) {
      (*target_00->isa->start_element)(target_00,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*target_00->isa->put_character)(target_00,'\n');
      bVar4 = true;
    }
    LYListFmtParse(list_format,data_00,tmpfilename,target_00,tail);
    next_element = HTBTree_next(tree,next_element);
    if (partial_threshold < 1) {
      local_10c = display_lines;
    }
    else {
      local_10c = partial_threshold;
    }
    if (num_of_entries_output % local_10c == 0) {
      HTDisplayPartial();
      iVar6 = HTCheckForInterrupt();
      if (iVar6 != 0) {
        mustshow = '\x01';
        __s = (char *)gettext("Data transfer interrupted.");
        HTProgress(__s);
        status = 0xce;
        goto LAB_0810a948;
      }
    }
    num_of_entries_output = num_of_entries_output + 1;
  } while( true );
}



int HTStat(char *filename,stat *data)

{
  size_t sVar1;
  char *temp_name;
  size_t len;
  int result;
  
  sVar1 = strlen(filename);
  if ((sVar1 == 0) || (filename[sVar1 - 1] != '/')) {
    result = stat64(filename,(stat64 *)data);
  }
  else {
    temp_name = (char *)0x0;
    HTSprintf0(&temp_name,"%s.",filename);
    result = HTStat(temp_name,data);
    if (temp_name != (char *)0x0) {
      free(temp_name);
    }
  }
  return result;
}



int decompressAndParse(HTParentAnchor *anchor,HTFormat format_out,HTStream *sink,char *nodename,
                      char *filename,HTAtom *myEncoding,HTFormat format,int *statusp)

{
  BOOLEAN BVar1;
  CompressFileType CVar2;
  FILE *__stream;
  HTAtom *object;
  HTList *me;
  int iVar3;
  FILE *__stream_00;
  HTFormat format_00;
  char *str;
  char *pcVar4;
  bool bVar5;
  char *local_4c;
  char *lastslash;
  char *anchor_path;
  char *cp;
  CompressFileType cft;
  CompressFileType method;
  HTList *methods;
  HTAtom *put;
  FILE *fp;
  int bin;
  char *localname;
  int rootlen;
  CompressFileType internal_decompress;
  gzFile gzfp;
  FILE *zzfp;
  HTAtom *encoding;
  BOOLEAN failed_decompress;
  
  encoding = (HTAtom *)0x0;
  zzfp = (FILE *)0x0;
  gzfp = (gzFile)0x0;
  internal_decompress = cftNone;
  rootlen = 0;
  CVar2 = HTCompressFileType(filename,".",&rootlen);
  if (CVar2 == cftNone) {
    local_4c = "r";
  }
  else {
    local_4c = "rb";
  }
  __stream_00 = (FILE *)fopen64(filename,local_4c);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTLoadFile: Opening `%s\' gives %p\n",filename,__stream_00);
  }
  if (__stream_00 == (FILE *)0x0) {
    return 0;
  }
  BVar1 = HTEditable(filename);
  if (BVar1 != '\0') {
    object = HTAtom_for("PUT");
    me = HTAnchor_methods(anchor);
    iVar3 = HTList_indexOf(me,object);
    if (iVar3 == -1) {
      HTList_addObject(me,object);
    }
  }
  fp = __stream_00;
  if ((((myEncoding == (HTAtom *)0x0) || (object = HTAtom_for("identity"), object == myEncoding)) ||
      (object = HTAtom_for("8bit"), object == myEncoding)) ||
     ((object = HTAtom_for("binary"), object == myEncoding ||
      (object = HTAtom_for("7bit"), object == myEncoding)))) {
    CVar2 = HTCompressFileType(filename,".",&rootlen);
    if (CVar2 != cftNone) {
      cp = (char *)0x0;
      HTSACopy(&cp,filename);
      cp[rootlen] = '\0';
      format_00 = HTFileFormat(cp,&encoding,(char **)0x0);
      if (cp != (char *)0x0) {
        free(cp);
        cp = (char *)0x0;
      }
      format = HTCharsetFormat(format_00,anchor,UCLYhndl_HTFile_for_unspec);
      HTSACopy(&anchor->content_type,format->name);
    }
    if (CVar2 == cftGzip) {
      HTSACopy(&anchor->content_encoding,"x-gzip");
      iVar3 = strcmp(format_out->name,"www/download");
      if (iVar3 != 0) {
        fclose((FILE *)__stream_00);
        gzfp = (gzFile)gzopen64(filename,&DAT_08180c15);
        if (WWW_TraceFlag != '\0') {
          __stream_00 = TraceFP();
          fprintf((FILE *)__stream_00,"HTLoadFile: gzopen of `%s\' gives %p\n",filename,gzfp);
        }
        internal_decompress = cftGzip;
      }
    }
    else {
      if (CVar2 < cftBzip2) {
        if (CVar2 == cftCompress) {
          HTSACopy(&anchor->content_encoding,"x-compress");
          format = (HTFormat)HTAtom_for("www/compressed");
        }
      }
      else {
        if (CVar2 == cftBzip2) {
          HTSACopy(&anchor->content_encoding,"x-bzip2");
          format = (HTFormat)HTAtom_for("www/compressed");
        }
        else {
          if (CVar2 == cftDeflate) {
            HTSACopy(&anchor->content_encoding,"x-deflate");
            iVar3 = strcmp(format_out->name,"www/download");
            if (iVar3 != 0) {
              fp = (FILE *)0x0;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTLoadFile: zzopen of `%s\' gives %p\n",filename,
                        __stream_00);
              }
              internal_decompress = cftDeflate;
              zzfp = __stream_00;
            }
          }
        }
      }
    }
  }
  else {
    CVar2 = HTEncodingToCompressType(myEncoding->name);
    iVar3 = strcmp(format_out->name,"www/download");
    if ((iVar3 == 0) || (CVar2 != cftGzip)) {
      iVar3 = strcmp(format_out->name,"www/download");
      if ((iVar3 == 0) || (CVar2 != cftDeflate)) {
        HTSACopy(&anchor->content_type,format->name);
        HTSACopy(&anchor->content_encoding,myEncoding->name);
        format = (HTFormat)HTAtom_for("www/compressed");
      }
      else {
        fp = (FILE *)0x0;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTLoadFile: zzopen of `%s\' gives %p\n",filename,__stream_00);
        }
        internal_decompress = cftDeflate;
        zzfp = __stream_00;
      }
    }
    else {
      fclose((FILE *)__stream_00);
      gzfp = (gzFile)gzopen64(filename,&DAT_08180c15);
      if (WWW_TraceFlag != '\0') {
        __stream_00 = TraceFP();
        fprintf((FILE *)__stream_00,"HTLoadFile: gzopen of `%s\' gives %p\n",filename,gzfp);
      }
      internal_decompress = cftGzip;
    }
  }
  if (internal_decompress == cftNone) {
    iVar3 = HTParseFile(format,format_out,anchor,fp,sink);
    *statusp = iVar3;
    fclose((FILE *)fp);
    return 1;
  }
  if (internal_decompress != cftNone) {
    if (internal_decompress < cftBzip2) {
      bVar5 = gzfp == (gzFile)0x0;
      goto LAB_0810b099;
    }
    if (internal_decompress == cftDeflate) {
      bVar5 = zzfp == (FILE *)0x0;
      goto LAB_0810b099;
    }
  }
  bVar5 = true;
LAB_0810b099:
  if (bVar5) {
    str = (char *)gettext("Could not open file for decompression!");
    iVar3 = HTLoadError((HTStream *)0x0,1,str);
    *statusp = iVar3;
  }
  else {
    cp = (char *)0x0;
    if (anchor->SugFname == (char *)0x0) {
      str = HTParse(anchor->address,"",5);
      HTUnEscape(str);
      pcVar4 = strrchr(str,0x2f);
      if (pcVar4 != (char *)0x0) {
        HTSACopy(&cp,pcVar4 + 1);
      }
      if (str != (char *)0x0) {
        free(str);
      }
    }
    else {
      HTSACopy(&cp,anchor->SugFname);
    }
    if (anchor->content_encoding != (char *)0x0) {
      free(anchor->content_encoding);
      anchor->content_encoding = (char *)0x0;
    }
    if ((cp != (char *)0x0) && (*cp != '\0')) {
      HTCheckFnameForCompression(&cp,anchor,'\x01');
    }
    if ((cp != (char *)0x0) && (*cp != '\0')) {
      HTSACopy(&anchor->SugFname,cp);
    }
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
    if (gzfp == (gzFile)0x0) {
      if (zzfp != (FILE *)0x0) {
        iVar3 = HTParseZzFile(format,format_out,anchor,zzfp,sink);
        *statusp = iVar3;
      }
    }
    else {
      iVar3 = HTParseGzFile(format,format_out,anchor,gzfp,sink);
      *statusp = iVar3;
    }
  }
  return 1;
}



int HTLoadFile(char *addr,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  bool bVar1;
  char *filename_00;
  char *__s2;
  char *__s2_00;
  int iVar2;
  char *__s2_01;
  size_t sVar3;
  HTFormat format_00;
  CompressFileType CVar4;
  dirent64 *pdVar5;
  FILE *__stream;
  DIR *__dirp;
  int *piVar6;
  float initial_value;
  int local_150;
  stat file_info;
  stat dir_info;
  char *cp;
  DIR *dp_1;
  CompressFileType cft;
  char *atomname;
  int rootlen;
  float value;
  float filevalue;
  HTFormat rep;
  HTAtom *enc;
  uint baselen;
  char *base;
  char *best_name;
  HTAtom *best_enc;
  HTFormat best_rep;
  float best;
  dirent *dirbuf;
  DIR *dp;
  char *localname;
  int default_UCLYhndl;
  char *ftp_newhost;
  int status;
  HTAtom *myEncoding;
  char *newname;
  char *nodename;
  HTFormat format;
  char *acc_method;
  char *filename;
  BOOLEAN forget_multi;
  
  newname = (char *)0x0;
  myEncoding = (HTAtom *)0x0;
  status = -1;
  HTSACopy(&newname,addr);
  filename_00 = HTParse(newname,"",5);
  __s2 = HTParse(newname,"",8);
  __s2_00 = HTParse(newname,"",0x10);
  iVar2 = strcmp("ftp",__s2_00);
  if (iVar2 != 0) {
    iVar2 = strcmp("localhost",__s2);
    if (iVar2 != 0) {
      __s2_01 = HTHostName();
      iVar2 = strcmp(__s2,__s2_01);
      if (iVar2 != 0) goto LAB_0810b3a0;
    }
    if (newname != (char *)0x0) {
      free(newname);
      newname = (char *)0x0;
    }
    if (__s2_00 != (char *)0x0) {
      free(__s2_00);
    }
    if ((anchor->content_type == (char *)0x0) || (anchor->content_encoding == (char *)0x0)) {
      default_UCLYhndl = UCLYhndl_HTFile_for_unspec;
      if (force_old_UCLYhndl_on_reload != '\0') {
        force_old_UCLYhndl_on_reload = '\0';
        default_UCLYhndl = forced_UCLYhdnl;
      }
      format_00 = HTFileFormat(filename_00,&myEncoding,(char **)0x0);
      format = HTCharsetFormat(format_00,anchor,default_UCLYhndl);
    }
    else {
      format = (HTFormat)HTAtom_for(anchor->content_type);
      myEncoding = HTAtom_for(anchor->content_encoding);
    }
    if (filename_00 != (char *)0x0) {
      free(filename_00);
    }
    if (HTSecure == '\0') {
      localname = HTnameOfFile_WWW(addr,'\x01','\x01');
      sVar3 = strlen(localname);
      filename_00 = localname;
      if (6 < sVar3) {
        sVar3 = strlen(localname);
        iVar2 = strcmp(filename_00 + (sVar3 - 6),".multi");
        if (iVar2 == 0) {
          dp = (DIR *)0x0;
          bVar1 = false;
          best = -100000002004087734272.00000000;
          best_rep = (HTFormat)0x0;
          best_enc = (HTAtom *)0x0;
          best_name = (char *)0x0;
          base = strrchr(localname,0x2f);
          baselen = 0;
          if ((base == (char *)0x0) || (base == localname)) {
            bVar1 = true;
          }
          else {
            *base = '\0';
            base = base + 1;
            sVar3 = strlen(base);
            baselen = sVar3 - 6;
            base[baselen] = '\0';
            dp = (DIR *)opendir(localname);
          }
          if ((bVar1) || (dp == (DIR *)0x0)) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (__s2 != (char *)0x0) {
              free(__s2);
            }
            filename_00 = (char *)gettext("Multiformat: directory scan failed.");
            iVar2 = HTLoadError(sink,500,filename_00);
            return iVar2;
          }
          while (pdVar5 = readdir64((DIR *)dp), pdVar5 != (dirent64 *)0x0) {
            if ((((*(uint *)&pdVar5->d_ino | *(uint *)((int)&pdVar5->d_ino + 4)) != 0) &&
                (sVar3 = strlen(pdVar5->d_name), baselen < sVar3)) &&
               (iVar2 = strncmp(pdVar5->d_name,base,baselen), iVar2 == 0)) {
              format_00 = HTFileFormat(pdVar5->d_name,&enc,(char **)0x0);
              initial_value = HTFileValue(pdVar5->d_name);
              value = HTStackValue(format_00,format_out,initial_value,0);
              if (value <= 0.00000000) {
                rootlen = 0;
                atomname = (char *)0x0;
                CVar4 = HTCompressFileType(pdVar5->d_name,".",&rootlen);
                cp = (char *)0x0;
                enc = (HTAtom *)0x0;
                if (CVar4 != cftNone) {
                  HTSACopy(&cp,pdVar5->d_name);
                  cp[rootlen] = '\0';
                  format = HTFileFormat(cp,(HTAtom **)0x0,(char **)0x0);
                  if (cp != (char *)0x0) {
                    free(cp);
                    cp = (char *)0x0;
                  }
                  value = HTStackValue(format,format_out,initial_value,0);
                  if (CVar4 == cftGzip) {
                    atomname = "application/x-gzip";
                  }
                  else {
                    if (CVar4 < cftBzip2) {
                      if (CVar4 == cftCompress) {
                        atomname = "application/x-compressed";
                      }
                    }
                    else {
                      if (CVar4 == cftBzip2) {
                        atomname = "application/x-bzip2";
                      }
                      else {
                        if (CVar4 == cftDeflate) {
                          atomname = "application/x-deflate";
                        }
                      }
                    }
                  }
                }
                if (atomname != (char *)0x0) {
                  value = HTStackValue(format,format_out,initial_value,0);
                  if (value <= 0.00000000) {
                    format = (HTFormat)HTAtom_for(atomname);
                    value = HTStackValue(format,format_out,initial_value,0);
                  }
                  if (value <= 0.00000000) {
                    format = (HTFormat)HTAtom_for("www/compressed");
                    value = HTStackValue(format,format_out,initial_value,0);
                  }
                }
              }
              if (value < -99999993207994712064.00000000) {
                if (WWW_TraceFlag != '\0') {
                  filename_00 = format_00->name;
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"HTLoadFile: value of presenting %s is %f\n",filename_00)
                  ;
                }
                if (best < value) {
                  best_enc = enc;
                  best = value;
                  HTSACopy(&best_name,pdVar5->d_name);
                  best_rep = format_00;
                }
              }
            }
          }
          closedir((DIR *)dp);
          if (best_rep == (HTFormat)0x0) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (__s2 != (char *)0x0) {
              free(__s2);
            }
            filename_00 = (char *)gettext("Could not find suitable representation for transmission."
                                         );
            iVar2 = HTLoadError(sink,0x193,filename_00);
            return iVar2;
          }
          format = best_rep;
          myEncoding = best_enc;
          base[-1] = '/';
          *base = '\0';
          HTSACat(&localname,best_name);
          if (best_name != (char *)0x0) {
            free(best_name);
            best_name = (char *)0x0;
          }
        }
      }
      iVar2 = HTStat(localname,&dir_info);
      filename_00 = localname;
      if (iVar2 == -1) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTLoadFile: can\'t stat %s\n",filename_00);
        }
      }
      else {
        if ((dir_info.st_mode & 0xf000) == 0x4000) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"%s is a directory\n",filename_00);
          }
          if (HTDirAccess == 0) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (__s2 != (char *)0x0) {
              free(__s2);
            }
            filename_00 = (char *)gettext("Directory browsing is not allowed.");
            iVar2 = HTLoadError(sink,0x193,filename_00);
            return iVar2;
          }
          if (HTDirAccess == 1) {
            cp = (char *)0x0;
            HTSprintf0(&cp,"%s/%s",localname);
            iVar2 = stat64(cp,(stat64 *)&file_info);
            if (iVar2 != 0) {
              if (localname != (char *)0x0) {
                free(localname);
                localname = (char *)0x0;
              }
              if (__s2 != (char *)0x0) {
                free(__s2);
              }
              if (cp != (char *)0x0) {
                free(cp);
                cp = (char *)0x0;
              }
              filename_00 = (char *)gettext("Selective access is not enabled for this directory");
              iVar2 = HTLoadError(sink,0x193,filename_00);
              return iVar2;
            }
          }
          filename_00 = localname;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Opening directory %s\n",filename_00);
          }
          __dirp = opendir(localname);
          if (__dirp == (DIR *)0x0) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (__s2 != (char *)0x0) {
              free(__s2);
            }
            filename_00 = (char *)gettext("This directory is not readable.");
            iVar2 = HTLoadError(sink,0x193,filename_00);
            return iVar2;
          }
          status = print_local_dir((DIR *)__dirp,localname,anchor,format_out,sink);
          closedir(__dirp);
          if (localname != (char *)0x0) {
            free(localname);
            localname = (char *)0x0;
          }
          if (__s2 != (char *)0x0) {
            free(__s2);
          }
          return status;
        }
        if ((((dir_info.st_mode & 0xf000) == 0x8000) && (dir_info.st_size._4_4_ < 1)) &&
           ((dir_info.st_size._4_4_ < 0 || ((uint)dir_info.st_size < 0x80000000)))) {
          anchor->content_length = (uint)dir_info.st_size;
        }
      }
      iVar2 = decompressAndParse(anchor,format_out,sink,__s2,localname,myEncoding,format,&status);
      if (iVar2 != 0) {
        if (__s2 != (char *)0x0) {
          free(__s2);
        }
        if (localname != (char *)0x0) {
          free(localname);
        }
        return status;
      }
      if (localname != (char *)0x0) {
        free(localname);
        localname = (char *)0x0;
      }
    }
    filename_00 = HTHostName();
    iVar2 = strcmp(__s2,filename_00);
    if (iVar2 == 0) {
      if (__s2 != (char *)0x0) {
        free(__s2);
      }
      if (WWW_TraceFlag != '\0') {
        piVar6 = __errno_location();
        iVar2 = *piVar6;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Can\'t open `%s\', errno=%d\n",addr,iVar2);
      }
      filename_00 = (char *)gettext("Can\'t access requested file.");
      local_150 = HTLoadError(sink,0x193,filename_00);
    }
    else {
      status = -1;
      if (__s2 != (char *)0x0) {
        free(__s2);
      }
      iVar2 = strncmp(addr,"file://localhost",0x10);
      if (iVar2 != 0) {
        status = HTFTPLoad(addr,anchor,format_out,sink);
      }
      local_150 = status;
    }
    return local_150;
  }
LAB_0810b3a0:
  status = -1;
  if (newname != (char *)0x0) {
    free(newname);
    newname = (char *)0x0;
  }
  if (filename_00 != (char *)0x0) {
    free(filename_00);
  }
  if (__s2 != (char *)0x0) {
    free(__s2);
  }
  if (__s2_00 != (char *)0x0) {
    free(__s2_00);
  }
  filename_00 = HTParse(addr,"",8);
  iVar2 = strcmp(ftp_lasthost,filename_00);
  if (iVar2 != 0) {
    ftp_local_passive = ftp_passive;
  }
  status = HTFTPLoad(addr,anchor,format_out,sink);
  if ((ftp_passive == ftp_local_passive) && ((399 < status || (status < 0)))) {
    ftp_local_passive = ftp_passive == '\0';
    status = HTFTPLoad(addr,anchor,format_out,sink);
  }
  free(ftp_lasthost);
  ftp_lasthost = filename_00;
  return status;
}



char * HTGetProgramPath(ProgramPaths code)

{
  char *result;
  
  result = (char *)0x0;
  if ((code != ppUnknown) && (code < pp_Last)) {
    result = program_paths[code];
  }
  return result;
}



void HTSetProgramPath(ProgramPaths code,char *path)

{
  char *local_8;
  
  if ((code != ppUnknown) && (code < pp_Last)) {
    if ((path == (char *)0x0) || (*path == '\0')) {
      local_8 = (char *)0x0;
    }
    else {
      local_8 = path;
    }
    program_paths[code] = local_8;
  }
  return;
}



void HTInitProgramPaths(void)

{
  char *__ptr;
  char *test;
  char *path;
  int n;
  ProgramPaths code;
  
  n = 1;
  do {
    switch(n) {
    case 0:
    case 2:
    case 4:
    case 5:
    case 7:
    case 9:
    case 0xd:
    case 0xe:
    case 0x11:
    case 0x12:
      path = (char *)0x0;
      break;
    case 1:
      path = "/bin/bzip2";
      break;
    case 3:
      path = "/usr/bin/compress";
      break;
    case 6:
      path = "/bin/gzip";
      break;
    case 8:
      path = "/usr/bin/install";
      break;
    case 10:
      path = "/bin/mv";
      break;
    case 0xb:
      path = "/usr/bin/rlogin";
      break;
    case 0xc:
      path = "/bin/rm";
      break;
    case 0xf:
      path = "/bin/tar";
      break;
    case 0x10:
      path = "/usr/bin/telnet";
      break;
    case 0x13:
      path = "/bin/gunzip";
      break;
    case 0x14:
      path = "/usr/bin/unzip";
      break;
    case 0x15:
      path = "/usr/bin/uudecode";
      break;
    case 0x16:
      path = "/bin/zcat";
      break;
    case 0x17:
      path = "/usr/bin/zip";
      break;
    default:
      return;
    }
    __ptr = HTGetProgramPath(n);
    if ((__ptr != (char *)0x0) && (__ptr != path)) {
      free(__ptr);
    }
    HTSetProgramPath(n,path);
    n = n + 1;
  } while( true );
}



HTBTree * HTBTree_new(HTComparer *comp)

{
  HTBTree *pHVar1;
  HTBTree *tree;
  
  pHVar1 = (HTBTree *)malloc(8);
  if (pHVar1 == (HTBTree *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_new");
  }
  pHVar1->compare = comp;
  pHVar1->top = (_HTBTree_element *)0x0;
  return pHVar1;
}



void HTBTElement_free(HTBTElement *element)

{
  if (element != (HTBTElement *)0x0) {
    if (element->left != (_HTBTree_element *)0x0) {
      HTBTElement_free((HTBTElement *)element->left);
    }
    if (element->right != (_HTBTree_element *)0x0) {
      HTBTElement_free((HTBTElement *)element->right);
    }
    if (element != (HTBTElement *)0x0) {
      free(element);
    }
  }
  return;
}



void HTBTree_free(HTBTree *tree)

{
  HTBTElement_free((HTBTElement *)tree->top);
  if (tree != (HTBTree *)0x0) {
    free(tree);
  }
  return;
}



void HTBTElementAndObject_free(HTBTElement *element)

{
  if (element != (HTBTElement *)0x0) {
    if (element->left != (_HTBTree_element *)0x0) {
      HTBTElementAndObject_free((HTBTElement *)element->left);
    }
    if (element->right != (_HTBTree_element *)0x0) {
      HTBTElementAndObject_free((HTBTElement *)element->right);
    }
    if (element->object != (void *)0x0) {
      free(element->object);
      element->object = (void *)0x0;
    }
    if (element != (HTBTElement *)0x0) {
      free(element);
    }
  }
  return;
}



void HTBTreeAndObject_free(HTBTree *tree)

{
  HTBTElementAndObject_free((HTBTElement *)tree->top);
  if (tree != (HTBTree *)0x0) {
    free(tree);
  }
  return;
}



void * HTBTree_search(HTBTree *tree,void *object)

{
  int iVar1;
  int res;
  HTBTElement *cur;
  
  cur = (HTBTElement *)tree->top;
  while( true ) {
    if (cur == (HTBTElement *)0x0) {
      return (void *)0x0;
    }
    iVar1 = (*tree->compare)(object,cur->object);
    if (iVar1 == 0) break;
    if (iVar1 < 0) {
      cur = (HTBTElement *)cur->left;
    }
    else {
      if (0 < iVar1) {
        cur = (HTBTElement *)cur->right;
      }
    }
  }
  return cur->object;
}



void HTBTree_add(HTBTree *tree,void *object)

{
  HTBTElement *pHVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  _HTBTree_element *p_Var5;
  int local_90;
  int local_88;
  int local_80;
  int local_78;
  int local_70;
  int local_68;
  int local_60;
  int local_58;
  int local_50;
  int local_48;
  int local_40;
  int local_38;
  int res;
  int corrections;
  int depth2;
  int depth;
  HTBTElement *father_of_forefather;
  HTBTElement *forefather_of_element;
  HTBTElement *added_element;
  HTBTElement *father_of_element;
  BOOLEAN first_time_1;
  BOOLEAN first_time;
  BOOLEAN top_found;
  BOOLEAN father_found;
  
  if (tree->top == (_HTBTree_element *)0x0) {
    p_Var5 = (_HTBTree_element *)malloc(0x18);
    tree->top = p_Var5;
    if (tree->top == (_HTBTree_element *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_add");
    }
    tree->top->up = (_HTBTree_element *)0x0;
    tree->top->object = object;
    tree->top->left = (_HTBTree_element *)0x0;
    tree->top->left_depth = 0;
    tree->top->right = (_HTBTree_element *)0x0;
    tree->top->right_depth = 0;
  }
  else {
    bVar3 = true;
    father_of_element = (HTBTElement *)tree->top;
    added_element = (HTBTElement *)0x0;
    while (bVar3) {
      iVar4 = (*tree->compare)(object,father_of_element->object);
      if (iVar4 < 0) {
        if (father_of_element->left == (_HTBTree_element *)0x0) {
          bVar3 = false;
          p_Var5 = (_HTBTree_element *)malloc(0x18);
          father_of_element->left = p_Var5;
          if (father_of_element->left == (_HTBTree_element *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_add");
          }
          added_element = (HTBTElement *)father_of_element->left;
          *(HTBTElement **)&added_element->up = father_of_element;
          added_element->object = object;
          added_element->left = (_HTBTree_element *)0x0;
          added_element->left_depth = 0;
          added_element->right = (_HTBTree_element *)0x0;
          added_element->right_depth = 0;
        }
        else {
          father_of_element = (HTBTElement *)father_of_element->left;
        }
      }
      else {
        if (father_of_element->right == (_HTBTree_element *)0x0) {
          bVar3 = false;
          p_Var5 = (_HTBTree_element *)malloc(0x18);
          father_of_element->right = p_Var5;
          if (father_of_element->right == (_HTBTree_element *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_add");
          }
          added_element = (HTBTElement *)father_of_element->right;
          *(HTBTElement **)&added_element->up = father_of_element;
          added_element->object = object;
          added_element->left = (_HTBTree_element *)0x0;
          added_element->left_depth = 0;
          added_element->right = (_HTBTree_element *)0x0;
          added_element->right_depth = 0;
        }
        else {
          father_of_element = (HTBTElement *)father_of_element->right;
        }
      }
    }
    father_of_forefather = father_of_element;
    forefather_of_element = added_element;
    do {
      if (father_of_forefather->left == (_HTBTree_element *)forefather_of_element) {
        depth = father_of_forefather->left_depth;
        local_90 = forefather_of_element->left_depth;
        if (forefather_of_element->left_depth < forefather_of_element->right_depth) {
          local_90 = forefather_of_element->right_depth;
        }
        father_of_forefather->left_depth = local_90 + 1;
        depth2 = father_of_forefather->left_depth;
      }
      else {
        depth = father_of_forefather->right_depth;
        local_88 = forefather_of_element->left_depth;
        if (forefather_of_element->left_depth < forefather_of_element->right_depth) {
          local_88 = forefather_of_element->right_depth;
        }
        father_of_forefather->right_depth = local_88 + 1;
        depth2 = father_of_forefather->right_depth;
      }
      forefather_of_element = father_of_forefather;
      father_of_forefather = (HTBTElement *)father_of_forefather->up;
    } while ((depth != depth2) && (father_of_forefather != (HTBTElement *)0x0));
    bVar3 = true;
    corrections = 0;
    while ((bVar3 && (corrections < 7))) {
      if ((father_of_element->left_depth - father_of_element->right_depth < -1) ||
         (1 < father_of_element->left_depth - father_of_element->right_depth)) {
        corrections = corrections + 1;
        if ((((father_of_element->left == (_HTBTree_element *)0x0) &&
             (father_of_element->right->right == (_HTBTree_element *)0x0)) &&
            (father_of_element->right->left->left == (_HTBTree_element *)0x0)) &&
           (father_of_element->right->left->right == (_HTBTree_element *)0x0)) {
          corrections = 7;
        }
        if (((father_of_element->right == (_HTBTree_element *)0x0) &&
            (father_of_element->left->left == (_HTBTree_element *)0x0)) &&
           ((father_of_element->left->right->right == (_HTBTree_element *)0x0 &&
            (father_of_element->left->right->left == (_HTBTree_element *)0x0)))) {
          corrections = 7;
        }
        if (father_of_element->right_depth < father_of_element->left_depth) {
          pHVar1 = (HTBTElement *)father_of_element->left;
          father_of_element->left_depth = pHVar1->right_depth;
          local_80 = father_of_element->left_depth;
          if (father_of_element->left_depth < father_of_element->right_depth) {
            local_80 = father_of_element->right_depth;
          }
          pHVar1->right_depth = local_80 + 1;
          if (father_of_element->up == (_HTBTree_element *)0x0) {
            pHVar1->up = (_HTBTree_element *)0x0;
            father_of_element->left = pHVar1->right;
            *(HTBTElement **)&pHVar1->right = father_of_element;
          }
          else {
            father_of_forefather = (HTBTElement *)father_of_element->up;
            bVar2 = true;
            forefather_of_element = pHVar1;
            do {
              if (father_of_forefather->left == forefather_of_element->up) {
                depth = father_of_forefather->left_depth;
                if (bVar2) {
                  local_78 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_78 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->left_depth = local_78 + 1;
                  bVar2 = false;
                }
                else {
                  local_70 = forefather_of_element->up->right_depth;
                  iVar4 = forefather_of_element->up->left_depth;
                  if (local_70 < iVar4) {
                    local_70 = iVar4;
                  }
                  father_of_forefather->left_depth = local_70 + 1;
                }
                depth2 = father_of_forefather->left_depth;
              }
              else {
                depth = father_of_forefather->right_depth;
                if (bVar2) {
                  local_68 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_68 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->right_depth = local_68 + 1;
                  bVar2 = false;
                }
                else {
                  local_60 = forefather_of_element->up->right_depth;
                  iVar4 = forefather_of_element->up->left_depth;
                  if (local_60 < iVar4) {
                    local_60 = iVar4;
                  }
                  father_of_forefather->right_depth = local_60 + 1;
                }
                depth2 = father_of_forefather->right_depth;
              }
              forefather_of_element = (HTBTElement *)forefather_of_element->up;
              father_of_forefather = (HTBTElement *)father_of_forefather->up;
            } while ((depth != depth2) && (father_of_forefather != (HTBTElement *)0x0));
            p_Var5 = father_of_element->up;
            if (p_Var5->left == (_HTBTree_element *)father_of_element) {
              *(HTBTElement **)&p_Var5->left = pHVar1;
              father_of_element->left = pHVar1->right;
              *(HTBTElement **)&pHVar1->right = father_of_element;
            }
            if (p_Var5->right == (_HTBTree_element *)father_of_element) {
              *(HTBTElement **)&p_Var5->right = pHVar1;
              father_of_element->left = pHVar1->right;
              *(HTBTElement **)&pHVar1->right = father_of_element;
            }
            pHVar1->up = p_Var5;
          }
          *(HTBTElement **)&father_of_element->up = pHVar1;
          if (father_of_element->left != (_HTBTree_element *)0x0) {
            *(HTBTElement **)&father_of_element->left->up = father_of_element;
          }
        }
        else {
          pHVar1 = (HTBTElement *)father_of_element->right;
          father_of_element->right_depth = pHVar1->left_depth;
          local_58 = father_of_element->left_depth;
          if (father_of_element->left_depth < father_of_element->right_depth) {
            local_58 = father_of_element->right_depth;
          }
          pHVar1->left_depth = local_58 + 1;
          if (father_of_element->up == (_HTBTree_element *)0x0) {
            pHVar1->up = (_HTBTree_element *)0x0;
            father_of_element->right = pHVar1->left;
            *(HTBTElement **)&pHVar1->left = father_of_element;
          }
          else {
            father_of_forefather = (HTBTElement *)father_of_element->up;
            bVar2 = true;
            forefather_of_element = pHVar1;
            do {
              if (father_of_forefather->left == forefather_of_element->up) {
                depth = father_of_forefather->left_depth;
                if (bVar2) {
                  local_50 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_50 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->left_depth = local_50 + 1;
                  bVar2 = false;
                }
                else {
                  local_48 = forefather_of_element->up->right_depth;
                  iVar4 = forefather_of_element->up->left_depth;
                  if (local_48 < iVar4) {
                    local_48 = iVar4;
                  }
                  father_of_forefather->left_depth = local_48 + 1;
                }
                depth2 = father_of_forefather->left_depth;
              }
              else {
                depth = father_of_forefather->right_depth;
                if (bVar2) {
                  local_40 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_40 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->right_depth = local_40 + 1;
                  bVar2 = false;
                }
                else {
                  local_38 = forefather_of_element->up->right_depth;
                  iVar4 = forefather_of_element->up->left_depth;
                  if (local_38 < iVar4) {
                    local_38 = iVar4;
                  }
                  father_of_forefather->right_depth = local_38 + 1;
                }
                depth2 = father_of_forefather->right_depth;
              }
              father_of_forefather = (HTBTElement *)father_of_forefather->up;
              forefather_of_element = (HTBTElement *)forefather_of_element->up;
            } while ((depth != depth2) && (father_of_forefather != (HTBTElement *)0x0));
            p_Var5 = father_of_element->up;
            if (p_Var5->left == (_HTBTree_element *)father_of_element) {
              *(HTBTElement **)&p_Var5->left = pHVar1;
              father_of_element->right = pHVar1->left;
              *(HTBTElement **)&pHVar1->left = father_of_element;
            }
            if (p_Var5->right == (_HTBTree_element *)father_of_element) {
              *(HTBTElement **)&p_Var5->right = pHVar1;
              father_of_element->right = pHVar1->left;
              *(HTBTElement **)&pHVar1->left = father_of_element;
            }
            pHVar1->up = p_Var5;
          }
          *(HTBTElement **)&father_of_element->up = pHVar1;
          if (father_of_element->right != (_HTBTree_element *)0x0) {
            *(HTBTElement **)&father_of_element->right->up = father_of_element;
          }
        }
      }
      else {
        if (father_of_element->up == (_HTBTree_element *)0x0) {
          bVar3 = false;
        }
        else {
          father_of_element = (HTBTElement *)father_of_element->up;
        }
      }
    }
    while (father_of_element->up != (_HTBTree_element *)0x0) {
      father_of_element = (HTBTElement *)father_of_element->up;
    }
    *(HTBTElement **)&tree->top = father_of_element;
  }
  return;
}



HTBTElement * HTBTree_next(HTBTree *tree,HTBTElement *ele)

{
  HTBTElement *father_of_forefather;
  HTBTElement *father_of_element;
  
  if (ele == (HTBTElement *)0x0) {
    father_of_element = (HTBTElement *)tree->top;
    if (father_of_element != (HTBTElement *)0x0) {
      while (father_of_element->left != (_HTBTree_element *)0x0) {
        father_of_element = (HTBTElement *)father_of_element->left;
      }
    }
  }
  else {
    father_of_element = ele;
    if (ele->right == (_HTBTree_element *)0x0) {
      father_of_forefather = (HTBTElement *)ele->up;
      while ((father_of_forefather != (HTBTElement *)0x0 &&
             (father_of_forefather->right == (_HTBTree_element *)father_of_element))) {
        father_of_element = father_of_forefather;
        father_of_forefather = (HTBTElement *)father_of_forefather->up;
      }
      father_of_element = father_of_forefather;
    }
    else {
      father_of_element = (HTBTElement *)ele->right;
      while (father_of_element->left != (_HTBTree_element *)0x0) {
        father_of_element = (HTBTElement *)father_of_element->left;
      }
    }
  }
  return father_of_element;
}



char * HTVMS_name(char *nn,char *fn)

{
  char *vmsname;
  size_t sVar1;
  char *__dest;
  char *__dest_00;
  int iVar2;
  ushort **ppuVar3;
  char *pcVar4;
  char *pcVar5;
  undefined *local_58;
  size_t local_54;
  uint local_3c;
  uint local_38;
  char *p_1;
  char *r;
  char *q;
  char *p;
  char *hostname;
  char *last;
  char *second;
  char *nodename;
  char *filename;
  
  sVar1 = strlen(fn);
  __dest = (char *)malloc(sVar1 + 1);
  sVar1 = strlen(nn);
  __dest_00 = (char *)malloc(sVar1 + 3);
  p = HTHostName();
  if ((__dest == (char *)0x0) || (__dest_00 == (char *)0x0)) {
    outofmem("../../../WWW/Library/Implementation/HTFTP.c","HTVMSname");
  }
  strcpy(__dest,fn);
  memcpy(__dest_00,&DAT_08181050,1);
  iVar2 = strncmp(nn,"localhost",9);
  if (iVar2 != 0) {
    q = nn;
    while( true ) {
      if ((((*p == '\0') || (*p == '.')) || (*q == '\0')) || (*q == '.')) goto LAB_0810ce15;
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*p] & 0x200) == 0) {
        local_3c = (uint)(byte)*p;
      }
      else {
        local_3c = toupper((uint)(byte)*p);
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*q] & 0x200) == 0) {
        local_38 = (uint)(byte)*q;
      }
      else {
        local_38 = toupper((uint)(byte)*q);
      }
      if (local_3c != local_38) break;
      p = p + 1;
      q = q + 1;
    }
    strcpy(__dest_00,nn);
    pcVar4 = strchr(__dest_00,0x2e);
    if (pcVar4 != (char *)0x0) {
      *pcVar4 = '\0';
    }
    local_54 = 3;
    local_58 = &DAT_0818105b;
    sVar1 = strlen(__dest_00);
    memcpy(__dest_00 + sVar1,local_58,local_54);
  }
LAB_0810ce15:
  pcVar4 = strchr(__dest + 1,0x2f);
  pcVar5 = strrchr(__dest,0x2f);
  if (pcVar4 == (char *)0x0) {
    HTSprintf0((char **)0x81b3474,"%s%s",__dest_00,__dest + 1);
  }
  else {
    if (pcVar4 == pcVar5) {
      *pcVar4 = '\0';
      HTSprintf0((char **)0x81b3474,"%s%s:%s",__dest_00,__dest + 1,pcVar4 + 1);
      *pcVar4 = '/';
    }
    else {
      *pcVar4 = '\0';
      *pcVar5 = '\0';
      HTSprintf0((char **)0x81b3474,"%s%s:[%s]%s",__dest_00,__dest + 1,pcVar4 + 1,pcVar5 + 1);
      *pcVar5 = '/';
      *pcVar4 = *pcVar5;
      p_1 = strchr(vmsname,0x5b);
      while (*p_1 != ']') {
        if (*p_1 == '/') {
          *p_1 = '.';
        }
        p_1 = p_1 + 1;
      }
    }
  }
  if (__dest_00 != (char *)0x0) {
    free(__dest_00);
  }
  if (__dest != (char *)0x0) {
    free(__dest);
  }
  return vmsname;
}



int next_data_char(void)

{
  byte bVar1;
  int iVar2;
  int status;
  
  if (data_write_pointer <= data_read_pointer) {
    iVar2 = HTDoRead(data_soc,data_buffer,0x800);
    if (iVar2 == -0x752e) {
      interrupted_in_next_data_char = 1;
    }
    if (iVar2 < 1) {
      return -1;
    }
    data_write_pointer = data_buffer + iVar2;
    data_read_pointer = data_buffer;
  }
  bVar1 = *data_read_pointer;
  data_read_pointer = data_read_pointer + 1;
  return (uint)bVar1;
}



int close_connection(connection *con)

{
  int iVar1;
  FILE *__stream;
  int *piVar2;
  char *pcVar3;
  int local_1c;
  int status;
  connection *scan;
  
  if (WWW_TraceFlag != '\0') {
    iVar1 = con->socket;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTP: Closing control socket %d\n",iVar1);
  }
  local_1c = close(con->socket);
  if (((WWW_TraceFlag != '\0') && (local_1c != 0)) && (WWW_TraceFlag != '\0')) {
    piVar2 = __errno_location();
    pcVar3 = strerror(*piVar2);
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTP:close_connection: %s",pcVar3);
  }
  con->socket = -1;
  if (connections == con) {
    connections = (connection *)con->next;
  }
  else {
    scan = connections;
    while (scan != (connection *)0x0) {
      if ((connection *)scan->next == con) {
        scan->next = con->next;
        if (control != con) {
          return local_1c;
        }
        control = (connection *)0x0;
        return local_1c;
      }
      scan = (connection *)scan->next;
    }
    local_1c = -1;
  }
  return local_1c;
}



void init_help_message_cache(void)

{
  if (help_message_buffer != (char *)0x0) {
    free(help_message_buffer);
    help_message_buffer = (char *)0x0;
  }
  return;
}



void help_message_cache_add(char *string)

{
  FILE *__stream;
  
  if (help_message_buffer == (char *)0x0) {
    HTSACopy(&help_message_buffer,string);
  }
  else {
    HTSACat(&help_message_buffer,string);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Adding message to help cache: %s\n",string);
  }
  return;
}



char * help_message_cache_non_empty(void)

{
  return help_message_buffer;
}



char * help_message_cache_contents(void)

{
  return help_message_buffer;
}



int write_cmd(char *cmd)

{
  int iVar1;
  FILE *__stream;
  size_t __n;
  ssize_t sVar2;
  int local_1c;
  int status;
  
  if (control == (connection *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: No control connection set up!!\n");
    }
    local_1c = -99;
  }
  else {
    if (cmd != (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"  Tx: %s",cmd);
      }
      __n = strlen(cmd);
      sVar2 = write(control->socket,cmd,__n);
      if (sVar2 < 0) {
        if (WWW_TraceFlag != '\0') {
          iVar1 = control->socket;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Error %d sending command: closing socket %d\n",sVar2,
                  iVar1);
        }
        close_connection(control);
        return sVar2;
      }
    }
    local_1c = 1;
  }
  return local_1c;
}



BOOLEAN find_response(HTList *list)

{
  char *pcVar1;
  char *local_18;
  char *value;
  HTList *p;
  BOOLEAN result;
  
  p = list;
  while( true ) {
    if ((p == (HTList *)0x0) || (p = p->next, p == (HTList *)0x0)) {
      local_18 = (char *)0x0;
    }
    else {
      local_18 = (char *)p->object;
    }
    if (local_18 == (char *)0x0) break;
    pcVar1 = LYstrstr(response_text,local_18);
    if (pcVar1 != (char *)0x0) {
      return '\x01';
    }
  }
  return '\0';
}



int response(char *cmd)

{
  char cVar1;
  BOOLEAN BVar2;
  int iVar3;
  FILE *__stream;
  int local_2c;
  int ich;
  char *p;
  int status;
  int continuation_response;
  int result;
  char continuation;
  
  continuation_response = -1;
  local_2c = write_cmd(cmd);
  if (-1 < local_2c) {
    do {
      p = response_text;
      while( true ) {
        iVar3 = HTGetCharacter();
        *p = (char)iVar3;
        cVar1 = *p;
        p = p + 1;
        if ((cVar1 == '\n') || (p == response_text + 0x100)) break;
        if (interrupted_in_htgetcharacter != 0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFTP: Interrupted in HTGetCharacter, apparently.\n");
          }
          close(control->socket);
          control->socket = -1;
          return -0x752e;
        }
        if (iVar3 == -1) {
          if (WWW_TraceFlag != '\0') {
            iVar3 = control->socket;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Error on rx: closing socket %d\n",iVar3);
          }
          memcpy(response_text,"000 *** TCP read error on response\n",0x24);
          close_connection(control);
          return -1;
        }
      }
      if (interrupted_in_htgetcharacter != 0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Interrupted in HTGetCharacter, apparently.\n");
        }
        close(control->socket);
        control->socket = -1;
        return -0x752e;
      }
      *p = '\0';
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"    Rx: %s",response_text);
      }
      iVar3 = strncmp(response_text,"230-",4);
      if (((iVar3 == 0) || (iVar3 = strncmp(response_text,"250-",4), iVar3 == 0)) ||
         (iVar3 = strncmp(response_text,"220-",4), iVar3 == 0)) {
        help_message_cache_add(response_text + 4);
      }
      sscanf(response_text,"%d%c",&result,&continuation);
      if (continuation_response == -1) {
        if (continuation == '-') {
          continuation_response = result;
        }
      }
      else {
        if ((continuation_response == result) && (continuation == ' ')) {
          continuation_response = -1;
        }
      }
      if (((result == 0xdc) && (BVar2 = find_response(broken_ftp_retr), BVar2 != '\0')) &&
         (Broken_RETR = 1, WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"This server is broken (RETR)\n");
      }
      if (((result == 0xdc) && (BVar2 = find_response(broken_ftp_epsv), BVar2 != '\0')) &&
         (Broken_EPSV = 1, WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"This server is broken (EPSV)\n");
      }
    } while (continuation_response != -1);
    if (result == 0x1a5) {
      if (WWW_TraceFlag != '\0') {
        iVar3 = control->socket;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: They close so we close socket %d\n",iVar3);
      }
      close_connection(control);
      local_2c = -1;
    }
    else {
      if (((result == 0xff) && (server_type == CMS_SERVER)) &&
         ((iVar3 = strncasecomp(cmd,"CWD",3), iVar3 == 0 ||
          (iVar3 = strcasecomp(cmd,"CDUP"), iVar3 == 0)))) {
        result = 0x22b;
      }
      local_2c = result / 100;
    }
  }
  return local_2c;
}



int send_cmd_1(char *verb)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  char command [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sprintf(command,"%.*s%c%c",0x4c,verb,0xd,10);
  iVar2 = response(command);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



int send_cmd_2(char *verb,char *param)

{
  int iVar1;
  int status;
  char *command;
  
  command = (char *)0x0;
  HTSprintf0(&command,"%s %s%c%c",verb,param,0xd,10);
  iVar1 = response(command);
  if (command != (char *)0x0) {
    free(command);
  }
  return iVar1;
}



int set_mac_binary(eServerType ServerType)

{
  int iVar1;
  uint local_8;
  
  if ((ServerType == APPLESHARE_SERVER) || (ServerType == NETPRESENZ_SERVER)) {
    iVar1 = response("MACB E\r\n");
  }
  else {
    iVar1 = response("MACB\r\n");
  }
  local_8 = (uint)(iVar1 == 2);
  return local_8;
}



void get_ftp_pwd(eServerType *ServerType,BOOLEAN *UseList)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  size_t sVar3;
  eServerType local_1c;
  undefined *local_18;
  int status;
  char *cp;
  
  iVar1 = response("PWD\r\n");
  if (-1 < iVar1) {
    pcVar2 = strchr(response_text + 5,0x22);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    if (*ServerType == TCPC_SERVER) {
      if (response_text[5] == '/') {
        local_1c = NCSA_SERVER;
      }
      else {
        local_1c = TCPC_SERVER;
      }
      *ServerType = local_1c;
      if (WWW_TraceFlag != '\0') {
        if (*ServerType == NCSA_SERVER) {
          local_18 = &DAT_0818126f;
        }
        else {
          local_18 = &DAT_08181274;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Treating as %s server.\n",local_18);
      }
    }
    else {
      if (response_text[5] == '/') {
        iVar1 = set_mac_binary(*ServerType);
        if (iVar1 == 0) {
          *ServerType = UNIX_SERVER;
          *UseList = '\x01';
          if (WWW_TraceFlag == '\0') {
            return;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Treating as Unix server.\n");
          return;
        }
        *ServerType = NCSA_SERVER;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Treating as NCSA server.\n");
        return;
      }
      sVar3 = strlen(response_text);
      if ((&DAT_081b349f)[sVar3] == ']') {
        *ServerType = VMS_SERVER;
        *UseList = '\x01';
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Treating as VMS server.\n");
        }
      }
      else {
        *ServerType = GENERIC_SERVER;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Treating as Generic server.\n");
        }
      }
    }
    if ((((*ServerType == NCSA_SERVER) || (*ServerType == TCPC_SERVER)) ||
        (*ServerType == PETER_LEWIS_SERVER)) || (*ServerType == NETPRESENZ_SERVER)) {
      set_mac_binary(*ServerType);
    }
  }
  return;
}



void set_unix_dirstyle(eServerType *ServerType,BOOLEAN *UseList)

{
  int iVar1;
  FILE *__stream;
  char *__haystack;
  int status;
  char *cp;
  
  iVar1 = response("SITE DIRSTYLE\r\n");
  if (iVar1 == 2) {
    *UseList = '\x01';
    __haystack = strstr(response_text + 4,"MSDOS");
    if ((__haystack != (char *)0x0) &&
       (__haystack = strstr(__haystack," off"), __haystack != (char *)0x0)) {
      return;
    }
    response("SITE DIRSTYLE\r\n");
  }
  else {
    *ServerType = GENERIC_SERVER;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: DIRSTYLE failed, treating as Generic server.\n");
    }
  }
  return;
}



int get_connection(char *arg,HTParentAnchor *anchor)

{
  connection *pcVar1;
  BOOLEAN firstuse;
  FILE *__stream;
  char *__s;
  char *fmt;
  int iVar2;
  size_t sVar3;
  int local_50;
  char *local_4c;
  char *tilde;
  char *cp_1;
  char *host;
  char *tmp;
  char *the_address;
  char *cp;
  char *pw;
  char *p2;
  char *p1;
  char *password;
  char *username;
  connection *con;
  char *command;
  int status;
  
  command = (char *)0x0;
  username = (char *)0x0;
  password = (char *)0x0;
  if (firstuse != '\0') {
    firstuse = '\0';
  }
  if (control == (connection *)0x0) {
    con = (connection *)calloc(1,0x10);
    if (con == (connection *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTFTP.c","get_connection");
    }
  }
  else {
    if (control->socket != -1) {
      close(control->socket);
    }
    pcVar1 = control;
    con = control;
    control->addr = 0;
    pcVar1->binary = '\0';
  }
  con->socket = -1;
  if (arg == (char *)0x0) {
    local_50 = -1;
  }
  else {
    if (*arg == '\0') {
      local_50 = -1;
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"get_connection(%s)\n",arg);
      }
      __s = HTParse(arg,"",8);
      fmt = strrchr(__s,0x40);
      p1 = __s;
      if (fmt != (char *)0x0) {
        *fmt = '\0';
        p1 = fmt + 1;
        fmt = strchr(__s,0x3a);
        if (fmt != (char *)0x0) {
          *fmt = '\0';
          password = HTUnEscape(fmt + 1);
        }
        if (*__s != '\0') {
          HTUnEscape(__s);
        }
        username = __s;
        if (password == (char *)0x0) {
          tmp = (char *)0x0;
          HTSprintf0(&tmp,"%s@%s",__s,p1);
          if (((last_username_and_host == (char *)0x0) ||
              (iVar2 = strcmp(tmp,last_username_and_host), iVar2 != 0)) ||
             (user_entered_password == (char *)0x0)) {
            HTSACopy(&last_username_and_host,tmp);
            fmt = (char *)gettext("Enter password for user %s@%s:");
            HTSprintf0(&tmp,fmt,__s,p1);
            if (user_entered_password != (char *)0x0) {
              free(user_entered_password);
              user_entered_password = (char *)0x0;
            }
            user_entered_password = HTPromptPassword(tmp);
          }
          password = user_entered_password;
          if (tmp != (char *)0x0) {
            free(tmp);
            tmp = (char *)0x0;
          }
        }
      }
      if ((username == (char *)0x0) && (p1 != (char *)0x0)) {
        free(p1);
      }
      status = HTDoConnect(arg,"FTP",0x15,&con->socket);
      if (status < 0) {
        if (status == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFTP: Interrupted on connect\n");
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFTP: Unable to connect to remote host for `%s\'.\n",arg);
          }
        }
        if (status == -0x752e) {
          mustshow = '\x01';
          __s = (char *)gettext("Connection interrupted.");
          HTProgress(__s);
          status = -29999;
        }
        else {
          __s = (char *)gettext("Unable to connect to FTP host.");
          HTAlert(__s);
        }
        if (con->socket != -1) {
          close(con->socket);
        }
        if (username != (char *)0x0) {
          free(username);
        }
        if (control == con) {
          control = (connection *)0x0;
        }
        if (con != (connection *)0x0) {
          free(con);
        }
        local_50 = status;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          iVar2 = con->socket;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"FTP connected, socket %d  control %p\n",iVar2,con);
        }
        control = con;
        HTInitInput(con->socket);
        init_help_message_cache();
        status = response((char *)0x0);
        if (status == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFTP: Interrupted at beginning of login.\n");
          }
          mustshow = '\x01';
          __s = (char *)gettext("Connection interrupted.");
          HTProgress(__s);
          close(control->socket);
          control->socket = -1;
          local_50 = -0x752e;
        }
        else {
          server_type = GENERIC_SERVER;
          if (status == 2) {
            sVar3 = strlen(response_text);
            if (sVar3 < 5) {
              cp = response_text;
            }
            else {
              cp = strstr(response_text," awaits your command");
              if ((cp != (char *)0x0) || (cp = strstr(response_text," ready."), cp != (char *)0x0))
              {
                *cp = '\0';
              }
              cp = response_text + 4;
              iVar2 = strncasecomp(response_text + 4,"NetPresenz",10);
              if (iVar2 == 0) {
                server_type = NETPRESENZ_SERVER;
              }
            }
            HTSACopy(&anchor->server,cp);
            if ((username == (char *)0x0) || (*username == '\0')) {
              local_4c = "anonymous";
            }
            else {
              local_4c = username;
            }
            status = send_cmd_2("USER",local_4c);
            if (status == -0x752e) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTFTP: Interrupted while sending username.\n");
              }
              mustshow = '\x01';
              __s = (char *)gettext("Connection interrupted.");
              HTProgress(__s);
              close(control->socket);
              control->socket = -1;
              return -0x752e;
            }
          }
          if (status == 3) {
            if (password == (char *)0x0) {
              tmp = (char *)0x0;
              the_address = anonftp_password;
              if ((anonftp_password == (char *)0x0) || (*anonftp_password == '\0')) {
                the_address = personal_mail_address;
              }
              if ((the_address == (char *)0x0) || (*the_address == '\0')) {
                the_address = LYGetEnv("USER");
              }
              if ((the_address == (char *)0x0) || (*the_address == '\0')) {
                the_address = "WWWuser";
              }
              HTSACopy(&tmp,the_address);
              host = strchr(tmp,0x40);
              if (host == (char *)0x0) {
                host = HTHostName();
              }
              else {
                *host = '\0';
                host = host + 1;
                if (*host == '\0') {
                  host = HTHostName();
                }
              }
              if ((host == (char *)0x0) || (__s = strchr(host,0x2e), __s == (char *)0x0)) {
                host = "";
              }
              HTSprintf0(&command,"PASS %s@%s%c%c",tmp,host,0xd,10);
              if (tmp != (char *)0x0) {
                free(tmp);
                tmp = (char *)0x0;
              }
            }
            else {
              HTSprintf0(&command,"PASS %s%c%c",password,0xd,10);
            }
            status = response(command);
            if (command != (char *)0x0) {
              free(command);
              command = (char *)0x0;
            }
            if (status == -0x752e) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTFTP: Interrupted while sending password.\n");
              }
              mustshow = '\x01';
              __s = (char *)gettext("Connection interrupted.");
              HTProgress(__s);
              close(control->socket);
              control->socket = -1;
              return -0x752e;
            }
          }
          if (username != (char *)0x0) {
            free(username);
          }
          if ((status == 3) && (status = send_cmd_1("ACCT noaccount"), status == -0x752e)) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTFTP: Interrupted while sending password.\n");
            }
            mustshow = '\x01';
            __s = (char *)gettext("Connection interrupted.");
            HTProgress(__s);
            close(control->socket);
            control->socket = -1;
            local_50 = -0x752e;
          }
          else {
            if (status == 2) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTFTP: Logged in.\n");
              }
              if (server_type != NETPRESENZ_SERVER) {
                server_type = GENERIC_SERVER;
              }
              use_list = '\0';
              iVar2 = response("SYST\r\n");
              if (iVar2 == 2) {
                iVar2 = strncmp(response_text + 4,"UNIX Type: L8 MAC-OS MachTen",0x1c);
                if (iVar2 == 0) {
                  server_type = MACHTEN_SERVER;
                  use_list = '\x01';
                  if (WWW_TraceFlag != '\0') {
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,"HTFTP: Treating as MachTen server.\n");
                  }
                }
                else {
                  __s = strstr(response_text + 4,"UNIX");
                  if ((__s == (char *)0x0) &&
                     (__s = strstr(response_text + 4,"Unix"), __s == (char *)0x0)) {
                    __s = strstr(response_text + 4,"MSDOS");
                    if (__s == (char *)0x0) {
                      iVar2 = strncmp(response_text + 4,"VMS",3);
                      if (iVar2 == 0) {
                        __s = strstr(arg,"/~");
                        use_list = '\x01';
                        if (((__s == (char *)0x0) || (__s[2] == '\0')) ||
                           (__s = strstr(response_text + 4,"MadGoat"), __s == (char *)0x0)) {
                          server_type = VMS_SERVER;
                          if (WWW_TraceFlag != '\0') {
                            __stream = TraceFP();
                            fprintf((FILE *)__stream,"HTFTP: Treating as VMS server.\n");
                          }
                        }
                        else {
                          server_type = UNIX_SERVER;
                          if (WWW_TraceFlag != '\0') {
                            __stream = TraceFP();
                            fprintf((FILE *)__stream,"HTFTP: Treating VMS as UNIX server.\n");
                          }
                        }
                      }
                      else {
                        iVar2 = strncmp(response_text + 4,"VM/CMS",6);
                        if ((iVar2 == 0) || (iVar2 = strncmp(response_text + 4,"VM ",3), iVar2 == 0)
                           ) {
                          server_type = CMS_SERVER;
                          use_list = '\x01';
                          if (WWW_TraceFlag != '\0') {
                            __stream = TraceFP();
                            fprintf((FILE *)__stream,"HTFTP: Treating as CMS server.\n");
                          }
                        }
                        else {
                          iVar2 = strncmp(response_text + 4,"DCTS",4);
                          if (iVar2 == 0) {
                            server_type = DCTS_SERVER;
                            if (WWW_TraceFlag != '\0') {
                              __stream = TraceFP();
                              fprintf((FILE *)__stream,"HTFTP: Treating as DCTS server.\n");
                            }
                          }
                          else {
                            __s = strstr(response_text + 4,"MAC-OS TCP/Connect II");
                            if (__s == (char *)0x0) {
                              if (server_type == NETPRESENZ_SERVER) {
                                use_list = '\x01';
                                set_mac_binary(NETPRESENZ_SERVER);
                                if (WWW_TraceFlag != '\0') {
                                  __stream = TraceFP();
                                  fprintf((FILE *)__stream,
                                          "HTFTP: Treating as NetPresenz (MACOS) server.\n");
                                }
                              }
                              else {
                                iVar2 = strncmp(response_text + 4,"MACOS Peter\'s Server",0x14);
                                if (iVar2 == 0) {
                                  server_type = PETER_LEWIS_SERVER;
                                  use_list = '\x01';
                                  set_mac_binary(PETER_LEWIS_SERVER);
                                  if (WWW_TraceFlag != '\0') {
                                    __stream = TraceFP();
                                    fprintf((FILE *)__stream,
                                            "HTFTP: Treating as Peter Lewis (MACOS) server.\n");
                                  }
                                }
                                else {
                                  iVar2 = strncmp(response_text + 4,"Windows_NT",10);
                                  if (iVar2 == 0) {
                                    server_type = WINDOWS_NT_SERVER;
                                    if (WWW_TraceFlag != '\0') {
                                      __stream = TraceFP();
                                      fprintf((FILE *)__stream,
                                              "HTFTP: Treating as Window_NT server.\n");
                                    }
                                    set_unix_dirstyle(&server_type,&use_list);
                                  }
                                  else {
                                    iVar2 = strncmp(response_text + 4,"Windows2000",0xb);
                                    if (iVar2 == 0) {
                                      server_type = WINDOWS_2K_SERVER;
                                      if (WWW_TraceFlag != '\0') {
                                        __stream = TraceFP();
                                        fprintf((FILE *)__stream,
                                                "HTFTP: Treating as Window_2K server.\n");
                                      }
                                      set_unix_dirstyle(&server_type,&use_list);
                                    }
                                    else {
                                      iVar2 = strncmp(response_text + 4,"MS Windows",10);
                                      if (iVar2 == 0) {
                                        server_type = MS_WINDOWS_SERVER;
                                        use_list = '\x01';
                                        if (WWW_TraceFlag != '\0') {
                                          __stream = TraceFP();
                                          fprintf((FILE *)__stream,
                                                  "HTFTP: Treating as MS Windows server.\n");
                                        }
                                      }
                                      else {
                                        iVar2 = strncmp(response_text + 4,
                                                        "MACOS AppleShare IP FTP Server",0x1e);
                                        if (iVar2 == 0) {
                                          server_type = APPLESHARE_SERVER;
                                          use_list = '\x01';
                                          set_mac_binary(APPLESHARE_SERVER);
                                          if (WWW_TraceFlag != '\0') {
                                            __stream = TraceFP();
                                            fprintf((FILE *)__stream,
                                                    "HTFTP: Treating as AppleShare server.\n");
                                          }
                                        }
                                        else {
                                          server_type = GENERIC_SERVER;
                                          if (WWW_TraceFlag != '\0') {
                                            __stream = TraceFP();
                                            fprintf((FILE *)__stream,
                                                    "HTFTP: Ugh!  A Generic server.\n");
                                          }
                                          get_ftp_pwd(&server_type,&use_list);
                                          unsure_type = 1;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            else {
                              server_type = TCPC_SERVER;
                              if (WWW_TraceFlag != '\0') {
                                __stream = TraceFP();
                                fprintf((FILE *)__stream,"HTFTP: Looks like a TCPC server.\n");
                              }
                              get_ftp_pwd(&server_type,&use_list);
                              unsure_type = 1;
                            }
                          }
                        }
                      }
                    }
                    else {
                      server_type = MSDOS_SERVER;
                      use_list = '\x01';
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,
                                "HTFTP: Treating as MSDOS (Unix emulation) server.\n");
                      }
                    }
                  }
                  else {
                    server_type = UNIX_SERVER;
                    unsure_type = 0;
                    use_list = '\x01';
                    if (WWW_TraceFlag != '\0') {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"HTFTP: Treating as Unix server.\n");
                    }
                  }
                }
              }
              else {
                get_ftp_pwd(&server_type,&use_list);
              }
              local_50 = con->socket;
            }
            else {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTFTP: Login fail: %s",response_text);
              }
              local_50 = -1;
            }
          }
        }
      }
    }
  }
  return local_50;
}



void reset_master_socket(void)

{
  have_socket = '\0';
  return;
}



void set_master_socket(int value)

{
  have_socket = -((char)~(byte)((uint)value >> 0x18) >> 7);
  if (have_socket != '\0') {
    master_socket = value;
  }
  return;
}



int close_master_socket(void)

{
  uint uVar1;
  FILE *__stream;
  char *where;
  int local_1c;
  int status;
  
  if (have_socket != '\0') {
    open_sockets.fds_bits[master_socket >> 5] =
         ~(1 << ((byte)master_socket & 0x1f)) & open_sockets.fds_bits[master_socket >> 5];
  }
  local_1c = close(master_socket);
  uVar1 = master_socket;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTP: Closed master socket %u\n",uVar1);
  }
  reset_master_socket();
  if (local_1c < 0) {
    where = (char *)gettext("close master socket");
    local_1c = HTInetStatus(where);
  }
  return local_1c;
}



// WARNING: Removing unreachable block (ram,0x0810eef1)

int get_listen_socket(void)

{
  int iVar1;
  uint16_t uVar2;
  int __fd;
  FILE *__stream;
  int iVar3;
  char *where;
  int in_GS_OFFSET;
  uint local_150;
  socklen_t local_14c;
  int status_1;
  socklen_t address_length;
  int status;
  fd_set *__arr;
  uint __i;
  int new_socket;
  socklen_t slen;
  int af;
  sockaddr_in *soc_in;
  sockaddr_storage soc_address;
  char portbuf [64];
  char hostbuf [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __i = 0;
  while (__i < 0x20) {
    open_sockets.fds_bits[__i] = 0;
    __i = __i + 1;
  }
  num_sockets = 0;
  slen = 0x80;
  __fd = getsockname(control->socket,(sockaddr *)&soc_address,&slen);
  if (__fd < 0) {
    local_150 = HTInetStatus("getsockname failed");
  }
  else {
    memset(&soc_address,0,0x80);
    __fd = socket((uint)soc_address.ss_family,1,6);
    if (__fd < 0) {
      where = (char *)gettext("socket for master socket");
      local_150 = HTInetStatus(where);
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Opened master socket number %d\n",__fd);
      }
      memset(&soc_address,0,0x80);
      if ((soc_address.ss_family != 2) && (soc_address.ss_family != 10)) {
        HTInetStatus("AF");
      }
      address_length = 0x80;
      iVar3 = getsockname(control->socket,(sockaddr *)&soc_address,&address_length);
      if (iVar3 < 0) {
        local_150 = HTInetStatus("getsockname");
      }
      else {
        if (WWW_TraceFlag != '\0') {
          where = HTInetString((SockA *)&soc_address);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: This host is %s\n",where);
        }
        soc_address._2_2_ = 0;
        if (soc_address.ss_family == 10) {
          local_14c = 0x1c;
        }
        else {
          local_14c = 0x10;
        }
        iVar3 = bind(__fd,(sockaddr *)&soc_address,local_14c);
        if (iVar3 < 0) {
          local_150 = HTInetStatus("bind");
        }
        else {
          address_length = 0x80;
          iVar3 = getsockname(__fd,(sockaddr *)&soc_address,&address_length);
          if (iVar3 < 0) {
            local_150 = HTInetStatus("getsockname");
          }
          else {
            if (WWW_TraceFlag != '\0') {
              where = HTInetString((SockA *)&soc_address);
              uVar2 = ntohs(soc_address._2_2_);
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTFTP: bound to port %d on %s\n",(uint)uVar2,where);
            }
            if (have_socket != '\0') {
              close_master_socket();
            }
            set_master_socket(__fd);
            HTHostName();
            if (soc_address.ss_family == 2) {
              sprintf(port_command,"PORT %d,%d,%d,%d,%d,%d%c%c",(uint)(byte)soc_address.__ss_align,
                      (uint)soc_address.__ss_align._1_1_,(uint)soc_address.__ss_align._2_1_,
                      (uint)soc_address.__ss_align._3_1_,(uint)soc_address._2_1_,
                      (uint)soc_address._3_1_,0xd,10);
            }
            else {
              if (soc_address.ss_family == 10) {
                getnameinfo((sockaddr *)&soc_address,0x1c,hostbuf,0x40,portbuf,0x40,3);
                sprintf(port_command,"EPRT |%d|%s|%s|%c%c",2,hostbuf,portbuf,0xd,10);
              }
              else {
                sprintf(port_command,"JUNK%c%c",0xd,10);
              }
            }
            __fd = listen(master_socket,1);
            if (__fd < 0) {
              reset_master_socket();
              local_150 = HTInetStatus("listen");
            }
            else {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"TCP: Master socket(), bind() and listen() all OK\n");
              }
              open_sockets.fds_bits[master_socket >> 5] =
                   1 << ((byte)master_socket & 0x1f) | open_sockets.fds_bits[master_socket >> 5];
              if (num_sockets < master_socket + 1) {
                num_sockets = master_socket + 1;
              }
              local_150 = master_socket;
            }
          }
        }
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_150;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void set_years_and_date(void)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  int i;
  time_t NowTime;
  char date [12];
  char month [8];
  char day [8];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  NowTime = time((time_t *)0x0);
  pcVar2 = ctime(&NowTime);
  strncpy(day,pcVar2 + 8,2);
  day[2] = '\0';
  if (day[0] == ' ') {
    day[0] = '0';
  }
  pcVar2 = ctime(&NowTime);
  strncpy(month,pcVar2 + 4,3);
  month[3] = '\0';
  i = 0;
  while (i < 0xc) {
    iVar3 = strcasecomp(month,months[i]);
    if (iVar3 == 0) break;
    i = i + 1;
  }
  sprintf(date,"9999%02d%.2s",i + 1,day);
  TheDate = atoi(date);
  pcVar2 = ctime(&NowTime);
  strcpy(ThisYear,pcVar2 + 0x14);
  ThisYear[4] = '\0';
  iVar3 = atoi(ThisYear);
  sprintf(LastYear,"%d",iVar3 + -1);
  HaveYears = '\x01';
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  HaveYears = '\x01';
  return;
}



void free_entryinfo_struct_contents(EntryInfo *entry_info)

{
  if (entry_info != (EntryInfo *)0x0) {
    if (entry_info->filename != (char *)0x0) {
      free(entry_info->filename);
      entry_info->filename = (char *)0x0;
    }
    if (entry_info->linkname != (char *)0x0) {
      free(entry_info->linkname);
      entry_info->linkname = (char *)0x0;
    }
    if (entry_info->type != (char *)0x0) {
      free(entry_info->type);
      entry_info->type = (char *)0x0;
    }
    if (entry_info->date != (char *)0x0) {
      free(entry_info->date);
      entry_info->date = (char *)0x0;
    }
  }
  return;
}



BOOLEAN is_ls_date(char *s)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  if (((*ppuVar1)[(byte)*s] & 0x400) != 0) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)s[1]] & 0x400) != 0) {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)s[2]] & 0x400) != 0) {
        if ((s[3] != ' ') && (s[3] != '\x01')) {
          return '\0';
        }
        if ((s[4] != 0x20) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[4]] & 0x800) == 0)) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)s[5]] & 0x800) == 0) {
          return '\0';
        }
        if (s[6] != ' ') {
          return '\0';
        }
        if ((s[7] != 0x20) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[7]] & 0x800) == 0)) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)s[8]] & 0x800) == 0) {
          return '\0';
        }
        if ((s[9] != 0x3a) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[9]] & 0x800) == 0)) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)s[10]] & 0x800) == 0) {
          return '\0';
        }
        if ((s[0xb] != 0x20) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[0xb]] & 0x800) == 0)
           ) {
          return '\0';
        }
        if (s[0xc] != ' ') {
          return '\0';
        }
        return '\x01';
      }
    }
  }
  return '\0';
}



void parse_eplf_line(char *line,EntryInfo *info)

{
  int iVar1;
  char cVar2;
  int flagbase;
  time_t base;
  char *__src;
  int in_GS_OFFSET;
  tm t;
  time_t secs;
  ulong size;
  char *cp;
  char ct [26];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp = line;
  if (flagbase == 0) {
    t.tm_year = 0x46;
    t.tm_mon = 0;
    t.tm_mday = 0;
    t.tm_hour = 0;
    t.tm_min = 0;
    t.tm_sec = 0;
    t.tm_isdst = -1;
    base = mktime((tm *)&t);
    flagbase = 1;
  }
LAB_0810f6cc:
  do {
    if (*cp == '\0') {
LAB_0810f6da:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    cVar2 = *cp;
    if (cVar2 == 'm') {
      secs = 0;
      while ((cp = cp + 1, *cp != '\0' && (*cp != ','))) {
        secs = secs * 10 + (int)*cp + -0x30;
      }
      secs = secs + base;
      __src = ctime(&secs);
      strcpy(ct,__src);
      ct[24] = '\0';
      HTSACopy(&info->date,ct);
      goto LAB_0810f6cc;
    }
    if (cVar2 < 'n') {
      if (cVar2 == '\t') {
        HTSACopy((char **)info,cp + 1);
        goto LAB_0810f6da;
      }
      if (cVar2 == '/') {
        __src = (char *)gettext("Directory");
        HTSACopy(&info->type,__src);
      }
LAB_0810f6c2:
      do {
        if (*cp == '\0') break;
        cVar2 = *cp;
        cp = cp + 1;
      } while (cVar2 != ',');
    }
    else {
      if (cVar2 != 's') goto LAB_0810f6c2;
      size = 0;
      while ((cp = cp + 1, *cp != '\0' && (*cp != ','))) {
        size = (size * 10 + (int)*cp) - 0x30;
      }
      info->size = size;
    }
  } while( true );
}



void parse_ls_line(char *line,EntryInfo *entry_info)

{
  size_t sVar1;
  BOOLEAN BVar2;
  ushort **ppuVar3;
  int size_num;
  int base;
  int j;
  int i;
  
  base = 1;
  size_num = 0;
  i = strlen(line);
  do {
    sVar1 = i;
    i = sVar1 - 1;
    if (i < 0xe) break;
    ppuVar3 = __ctype_b_loc();
  } while ((((*ppuVar3)[(byte)line[i]] & 0x2000) == 0) ||
          (BVar2 = is_ls_date(line + (sVar1 - 0xd)), BVar2 == '\0'));
  line[i] = '\0';
  if (0xd < i) {
    HTSACopy(&entry_info->date,line + (sVar1 - 0xd));
    if ((entry_info->date[4] == ' ') || (entry_info->date[4] == '0')) {
      entry_info->date[4] = '\x01';
    }
    if (entry_info->date[0xb] == ' ') {
      j = 0xb;
      while (6 < j) {
        entry_info->date[j] = entry_info->date[j + -1];
        j = j + -1;
      }
    }
  }
  j = sVar1 - 0xf;
  while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)line[j]] & 0x800) != 0) {
    size_num = size_num + ((int)line[j] + -0x30) * base;
    base = base * 10;
    j = j + -1;
  }
  entry_info->size = size_num;
  HTSACopy((char **)entry_info,line + sVar1);
  return;
}



void parse_dls_line(char *line,EntryInfo *entry_info,char **pspilledname)

{
  size_t sVar1;
  char *src;
  ushort **ppuVar2;
  int iVar3;
  char *src_00;
  char *cps;
  int len;
  int size_num;
  int base;
  short j;
  
  base = 1;
  size_num = 0;
  sVar1 = strlen(line);
  if (sVar1 == 0) {
    if (*pspilledname != (char *)0x0) {
      free(*pspilledname);
      *pspilledname = (char *)0x0;
    }
    entry_info->display = '\0';
  }
  else {
    src = LYSkipNonBlanks(line);
    if (*src == '\0') {
      HTSACopy(pspilledname,line);
      entry_info->display = '\0';
    }
    else {
      if (((0x17 < (int)sVar1) && (line[0x17] == ' ')) &&
         ((ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*line] & 0x2000) == 0 ||
          (*pspilledname != (char *)0x0)))) {
        j = 0x16;
        if ((line[0x16] == '=') || (line[0x16] == '-')) {
          src = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,src);
        }
        else {
          while (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)line[j]] & 0x800) != 0) {
            size_num = size_num + ((int)line[j] + -0x30) * base;
            base = base * 10;
            j = j + -1;
          }
        }
        entry_info->size = size_num;
        src = LYSkipBlanks(line + 0x17);
        iVar3 = strncmp(src,"-> ",3);
        if (((iVar3 == 0) && (src[3] != '\0')) && (src[3] != ' ')) {
          src_00 = (char *)gettext("Symbolic Link");
          HTSACopy(&entry_info->type,src_00);
          src = LYSkipBlanks(src + 3);
          HTSACopy(&entry_info->linkname,src);
          entry_info->size = 0;
        }
        if (0 < j) {
          line[j] = '\0';
        }
        LYTrimTrailing(line);
        len = strlen(line);
        if (((len == 0) && (*pspilledname != (char *)0x0)) && (**pspilledname != '\0')) {
          line = *pspilledname;
          len = strlen(*pspilledname);
        }
        if ((0 < len) && (line[len + -1] == '/')) {
          if (1 < len) {
            line[len + -1] = '\0';
          }
          if (entry_info->type == (char *)0x0) {
            src = (char *)gettext("Directory");
            HTSACopy(&entry_info->type,src);
          }
        }
        HTSACopy((char **)entry_info,line);
        if (*pspilledname == (char *)0x0) {
          return;
        }
        free(*pspilledname);
        *pspilledname = (char *)0x0;
        return;
      }
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)*line] & 0x2000) == 0) {
        *src = '\0';
      }
      if ((*pspilledname == (char *)0x0) || (*line != '\0')) {
        HTSACopy((char **)entry_info,line);
        if ((src == (char *)0x0) || ((src == line || (src[-1] != '/')))) {
          HTSACopy(&entry_info->type,"");
        }
        else {
          src = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,src);
        }
        if (*pspilledname != (char *)0x0) {
          free(*pspilledname);
          *pspilledname = (char *)0x0;
        }
      }
      else {
        entry_info->filename = *pspilledname;
        *pspilledname = (char *)0x0;
        src = entry_info->filename;
        sVar1 = strlen(entry_info->filename);
        if (src[sVar1 - 1] == '/') {
          src = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,src);
        }
        else {
          HTSACopy(&entry_info->type,"");
        }
      }
    }
  }
  return;
}



void parse_vms_dir_entry(char *line,EntryInfo *entry_info)

{
  int iVar1;
  char *__s;
  size_t sVar2;
  ushort **ppuVar3;
  int iVar4;
  uint uVar5;
  char *__s_00;
  FILE *__stream;
  int in_GS_OFFSET;
  char local_51;
  char local_49;
  char *local_44;
  char *sp;
  char *cps;
  char *cpd;
  char *cp;
  uint ialloc;
  int j;
  int i;
  char date [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((*line == '\0') || (cps = strchr(line,0x3b), cps == (char *)0x0)) {
    entry_info->display = '\0';
  }
  else {
    *cps = '\0';
    __s_00 = cps + 1;
    HTSACopy((char **)entry_info,line);
    __s = strstr(entry_info->filename,"READ");
    if (__s == (char *)0x0) {
      LYLowerCase(entry_info->filename);
      i = strlen(entry_info->filename);
    }
    else {
      __s = strstr(entry_info->filename,"READ");
      __s = __s + -(int)entry_info->filename;
      iVar4 = strncmp(__s + 4 + (int)entry_info->filename,"ME",2);
      if (iVar4 == 0) {
        i = (int)(__s + 6);
        while ((entry_info->filename[i] != '\0' && (entry_info->filename[i] != '.'))) {
          i = i + 1;
        }
      }
      else {
        iVar4 = strncmp(__s + 4 + (int)entry_info->filename,".ME",3);
        if (iVar4 == 0) {
          i = strlen(entry_info->filename);
        }
        else {
          i = 0;
        }
      }
      LYLowerCase(entry_info->filename + i);
    }
    iVar4 = i + -1;
    if (((2 < iVar4) && (entry_info->filename[iVar4] == 'z')) &&
       ((entry_info->filename[i + -2] == '.' || (entry_info->filename[i + -2] == '_')))) {
      entry_info->filename[iVar4] = 'Z';
    }
    while (cps = strchr(cps + 1,9), cps != (char *)0x0) {
      *cps = ' ';
    }
    i = 0;
    j = 1;
    while (__s_00[j] != '\0') {
      if ((__s_00[i] == ' ') && (__s_00[j] == ' ')) {
        j = j + 1;
      }
      else {
        i = i + 1;
        __s_00[i] = __s_00[j];
        j = j + 1;
      }
    }
    __s_00[i + 1] = '\0';
    if (HaveYears == '\0') {
      set_years_and_date();
    }
    __s = strchr(__s_00,0x2d);
    if ((((__s != (char *)0x0) && (sVar2 = strlen(__s), 9 < sVar2)) &&
        (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)__s[-1]] & 0x800) != 0)) &&
       ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)__s[1]] & 0x400) != 0 && (__s[4] == '-')))) {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)__s[2]] & 0x100) == 0) {
        local_51 = __s[2];
      }
      else {
        iVar4 = tolower((uint)(byte)__s[2]);
        local_51 = (char)iVar4;
      }
      __s[2] = local_51;
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)__s[3]] & 0x100) == 0) {
        local_49 = __s[3];
      }
      else {
        iVar4 = tolower((uint)(byte)__s[3]);
        local_49 = (char)iVar4;
      }
      __s[3] = local_49;
      sprintf(date,"%.3s ",__s + 1);
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)__s[-2]] & 0x800) == 0) {
        sprintf(date + 4,"%c%.1s ",1,__s + -1);
      }
      else {
        sprintf(date + 4,"%.2s ",__s + -2);
      }
      iVar4 = strncmp(ThisYear,__s + 5,4);
      if (((iVar4 == 0) && (sVar2 = strlen(__s), 0xf < sVar2)) && (__s[0xc] == ':')) {
        sprintf(date + 7,"%.5s",__s + 10);
      }
      else {
        sprintf(date + 7," %.4s",__s + 5);
      }
      HTSACopy(&entry_info->date,date);
    }
    __s = strchr(__s_00,0x2f);
    cps = __s;
    if (__s == (char *)0x0) {
      __s_00 = strtok(__s_00," ");
      if (__s_00 != (char *)0x0) {
        do {
          __s_00 = strtok((char *)0x0," ");
          cpd = __s_00;
          if (__s_00 == (char *)0x0) goto LAB_08110308;
          while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*cpd] & 0x800) != 0) {
            cpd = cpd + 1;
          }
        } while (*cpd != '\0');
        iVar4 = atoi(__s_00);
        entry_info->size = iVar4 << 9;
      }
    }
    else {
      while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)cps[-1]] & 0x800) != 0) {
        cps = cps + -1;
      }
      if (cps < __s) {
        *__s = '\0';
      }
      uVar5 = atoi(cps);
      entry_info->size = uVar5;
      cps = __s;
      do {
        cps = cps + 1;
        ppuVar3 = __ctype_b_loc();
      } while (((*ppuVar3)[(byte)*cps] & 0x800) != 0);
      *cps = '\0';
      uVar5 = atoi(__s + 1);
      if (entry_info->size <= uVar5) {
        entry_info->size = entry_info->size << 9;
      }
    }
LAB_08110308:
    if (WWW_TraceFlag != '\0') {
      uVar5 = entry_info->size;
      if (entry_info->date == (char *)0x0) {
        local_44 = "";
      }
      else {
        local_44 = entry_info->date;
      }
      __s_00 = entry_info->filename;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: VMS filename: %s  date: %s  size: %u\n",__s_00,local_44,uVar5
             );
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void parse_ms_windows_dir_entry(char *line,EntryInfo *entry_info)

{
  int iVar1;
  size_t sVar2;
  char *buffer;
  byte *buffer_00;
  ushort **ppuVar3;
  uint uVar4;
  int iVar5;
  FILE *__stream;
  int in_GS_OFFSET;
  char *local_44;
  char *end;
  char *cpd;
  char *cps;
  char *cp;
  char date [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar2 = strlen(line);
  buffer = LYSkipBlanks(line);
  if (*buffer == '\0') {
    entry_info->display = '\0';
  }
  else {
    cpd = LYSkipNonBlanks(buffer);
    *cpd = '\0';
    cpd = cpd + 1;
    HTSACopy((char **)entry_info,buffer);
    if (cpd < line + sVar2) {
      buffer_00 = (byte *)LYSkipBlanks(cpd);
      cpd = LYSkipNonBlanks((char *)buffer_00);
      *cpd = '\0';
      cpd = cpd + 1;
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[*buffer_00] & 0x800) == 0) {
        buffer = (char *)gettext("Directory");
        HTSACopy(&entry_info->type,buffer);
      }
      else {
        uVar4 = atoi((char *)buffer_00);
        entry_info->size = uVar4;
      }
    }
    else {
      HTSACopy(&entry_info->type,"");
    }
    if (HaveYears == '\0') {
      set_years_and_date();
    }
    if (cpd < line + sVar2) {
      buffer = LYSkipBlanks(cpd);
      sVar2 = strlen(buffer);
      if (0x11 < sVar2) {
        buffer[6] = '\0';
        buffer[0xb] = '\0';
        buffer[0x11] = '\0';
        iVar5 = strcmp(ThisYear,buffer + 7);
        if (iVar5 == 0) {
          sprintf(date,"%.6s %.5s",buffer,buffer + 0xc);
        }
        else {
          sprintf(date,"%.6s  %.4s",buffer,buffer + 7);
        }
        HTSACopy(&entry_info->date,date);
        if ((entry_info->date[4] == ' ') || (entry_info->date[4] == '0')) {
          entry_info->date[4] = '\x01';
        }
      }
    }
    if (WWW_TraceFlag != '\0') {
      uVar4 = entry_info->size;
      if (entry_info->date == (char *)0x0) {
        local_44 = "";
      }
      else {
        local_44 = entry_info->date;
      }
      buffer = entry_info->filename;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: MS Windows filename: %s  date: %s  size: %u\n",buffer,
              local_44,uVar4);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void parse_cms_dir_entry(char *line,EntryInfo *entry_info)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  char *local_50;
  char *buffer;
  char *__s2;
  int iVar4;
  byte *buffer_00;
  ushort **ppuVar5;
  FILE *__stream;
  int in_GS_OFFSET;
  char *local_44;
  int i;
  int Records;
  int RecordLength;
  char *end;
  char *cpd;
  char *cps;
  char *cp;
  char date [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar3 = strlen(line);
  local_50 = line + sVar3;
  RecordLength = 0;
  Records = 0;
  buffer = LYSkipBlanks(line);
  if (*buffer == '\0') {
    entry_info->display = '\0';
  }
  else {
    __s2 = LYSkipNonBlanks(buffer);
    *__s2 = '\0';
    HTSACopy((char **)entry_info,buffer);
    buffer = strchr(entry_info->filename,0x2e);
    if (buffer == (char *)0x0) {
      buffer = LYSkipBlanks(__s2 + 1);
      if (*buffer == '\0') {
        if (entry_info->filename != (char *)0x0) {
          free(entry_info->filename);
          entry_info->filename = (char *)0x0;
        }
        if (entry_info->type != (char *)0x0) {
          free(entry_info->type);
          entry_info->type = (char *)0x0;
        }
        entry_info->display = '\0';
      }
      else {
        cps = LYSkipNonBlanks(buffer);
        *cps = '\0';
        cps = cps + 1;
        iVar4 = strcasecomp(buffer,"DIR");
        if ((iVar4 == 0) && (0x11 < (int)(buffer + -(int)line))) {
          buffer = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,buffer);
          entry_info->size = 0;
        }
        else {
          buffer[-1] = '.';
          HTSACat((char **)entry_info,buffer + -1);
          if (cps < local_50) {
            buffer = LYSkipBlanks(cps);
            cps = LYSkipNonBlanks(buffer);
            *cps = '\0';
            cps = cps + 1;
          }
        }
        if (cps < local_50) {
          buffer_00 = (byte *)LYSkipBlanks(cps);
          cps = LYSkipNonBlanks((char *)buffer_00);
          *cps = '\0';
          cps = cps + 1;
          ppuVar5 = __ctype_b_loc();
          if (((*ppuVar5)[*buffer_00] & 0x800) != 0) {
            RecordLength = atoi((char *)buffer_00);
          }
        }
        if (cps < local_50) {
          buffer_00 = (byte *)LYSkipBlanks(cps);
          cps = LYSkipNonBlanks((char *)buffer_00);
          *cps = '\0';
          cps = cps + 1;
          ppuVar5 = __ctype_b_loc();
          if (((*ppuVar5)[*buffer_00] & 0x800) != 0) {
            Records = atoi((char *)buffer_00);
          }
          if ((0 < Records) && (0 < RecordLength)) {
            entry_info->size = Records * RecordLength;
          }
        }
        if (HaveYears == '\0') {
          set_years_and_date();
        }
        if (cps < local_50) {
          buffer = strchr(cps,0x3a);
          if ((buffer != (char *)0x0) && (buffer < local_50 + -3)) {
            ppuVar5 = __ctype_b_loc();
            if (((*ppuVar5)[(byte)buffer[1]] & 0x800) != 0) {
              ppuVar5 = __ctype_b_loc();
              if ((((*ppuVar5)[(byte)buffer[2]] & 0x800) != 0) && (buffer[3] == ':')) {
                buffer[3] = '\0';
                if (0xd < (int)(buffer + 3 + -(int)cps)) {
                  local_50 = buffer + -0xb;
                  buffer[-9] = '\0';
                  buffer[-6] = '\0';
                  buffer[-3] = '\0';
                  if (*local_50 == ' ') {
                    *local_50 = '0';
                  }
                  iVar4 = atoi(local_50);
                  local_50 = buffer + -8;
                  sprintf(date,"%.3s %.2s",months[iVar4 + -1],local_50);
                  if (date[4] == '0') {
                    date[4] = ' ';
                  }
                  __s2 = buffer + -5;
                  iVar4 = strcmp(ThisYear + 2,__s2);
                  if (iVar4 == 0) {
                    *buffer = '\0';
                    iVar4 = atoi(buffer + -2);
                    sprintf(date + 6," %02d:%.2s",iVar4,buffer + 1);
                  }
                  else {
                    iVar4 = atoi(__s2);
                    if (iVar4 < 0x46) {
                      sprintf(date + 6,"  20%.2s",__s2,local_50);
                    }
                    else {
                      sprintf(date + 6,"  19%.2s",__s2,local_50);
                    }
                  }
                  HTSACopy(&entry_info->date,date);
                  if ((entry_info->date[4] == ' ') || (entry_info->date[4] == '0')) {
                    entry_info->date[4] = '\x01';
                  }
                }
              }
            }
          }
        }
        if (WWW_TraceFlag != '\0') {
          uVar2 = entry_info->size;
          if (entry_info->date == (char *)0x0) {
            local_44 = "";
          }
          else {
            local_44 = entry_info->date;
          }
          local_50 = entry_info->filename;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: VM/CMS filename: %s  date: %s  size: %u\n",local_50,
                  local_44,uVar2);
        }
      }
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



EntryInfo * parse_dir_entry(char *entry,BOOLEAN *first,char **pspilledname)

{
  bool bVar1;
  EntryInfo *entry_info_00;
  size_t sVar2;
  char *src;
  FILE *__stream;
  int iVar3;
  ushort **ppuVar4;
  HTFormat pHVar5;
  bool bVar6;
  HTAtom *encoding;
  HTFormat format;
  char *cp2;
  char *cp;
  int len;
  int i;
  EntryInfo *entry_info;
  BOOLEAN remove_size;
  
  bVar1 = false;
  entry_info_00 = (EntryInfo *)malloc(0x18);
  if (entry_info_00 == (EntryInfo *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFTP.c","parse_dir_entry");
  }
  entry_info_00->filename = (char *)0x0;
  entry_info_00->linkname = (char *)0x0;
  entry_info_00->type = (char *)0x0;
  entry_info_00->date = (char *)0x0;
  entry_info_00->size = 0;
  entry_info_00->display = '\x01';
  switch(server_type) {
  default:
    HTSACopy((char **)entry_info_00,entry);
    return entry_info_00;
  case VMS_SERVER:
    parse_vms_dir_entry(entry,entry_info_00);
    if (entry_info_00->display == '\0') {
      return entry_info_00;
    }
    sVar2 = strlen(entry_info_00->filename);
    if ((4 < (int)sVar2) &&
       (iVar3 = strcmp(entry_info_00->filename + (sVar2 - 4),".dir"), iVar3 == 0)) {
      entry_info_00->filename[sVar2 - 4] = '\0';
      src = (char *)gettext("Directory");
      HTSACopy(&entry_info_00->type,src);
      bVar1 = true;
    }
    break;
  case CMS_SERVER:
    parse_cms_dir_entry(entry,entry_info_00);
    if (entry_info_00->display == '\0') {
      return entry_info_00;
    }
    if ((entry_info_00->type != (char *)0x0) && (*entry_info_00->type == '\0')) {
      if (entry_info_00->type == (char *)0x0) {
        return entry_info_00;
      }
      free(entry_info_00->type);
      entry_info_00->type = (char *)0x0;
      return entry_info_00;
    }
    break;
  case TCPC_SERVER:
  case NCSA_SERVER:
    HTSACopy((char **)entry_info_00,entry);
    sVar2 = strlen(entry);
    if (entry[sVar2 - 1] == '/') {
      entry[sVar2 - 1] = '\0';
      src = (char *)gettext("Directory");
      HTSACopy(&entry_info_00->type,src);
      bVar1 = true;
    }
    break;
  case MS_WINDOWS_SERVER:
    parse_ms_windows_dir_entry(entry,entry_info_00);
    if (entry_info_00->display == '\0') {
      return entry_info_00;
    }
    if ((entry_info_00->type != (char *)0x0) && (*entry_info_00->type == '\0')) {
      if (entry_info_00->type == (char *)0x0) {
        return entry_info_00;
      }
      free(entry_info_00->type);
      entry_info_00->type = (char *)0x0;
      return entry_info_00;
    }
    break;
  case DLS_SERVER:
    if (*first != '\0') {
      sVar2 = strlen(entry);
      if ((((sVar2 == 0) || (*entry == ' ')) || ((0x17 < (int)sVar2 && (entry[0x17] != ' ')))) ||
         (((int)sVar2 < 0x18 && (src = strchr(entry,0x20), src != (char *)0x0)))) {
        server_type = UNIX_SERVER;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Falling back to treating as Unix server.\n");
        }
      }
      else {
        *first = '\0';
      }
    }
    if (server_type == DLS_SERVER) {
      parse_dls_line(entry,entry_info_00,pspilledname);
      if ((entry_info_00->filename == (char *)0x0) || (*entry_info_00->filename == '\0')) {
        entry_info_00->display = '\0';
        return entry_info_00;
      }
      iVar3 = strcmp(entry_info_00->filename,"..");
      if ((iVar3 == 0) || (iVar3 = strcmp(entry_info_00->filename,"."), iVar3 == 0)) {
        entry_info_00->display = '\0';
      }
      if ((entry_info_00->type != (char *)0x0) && (*entry_info_00->type == '\0')) {
        if (entry_info_00->type == (char *)0x0) {
          return entry_info_00;
        }
        free(entry_info_00->type);
        entry_info_00->type = (char *)0x0;
        return entry_info_00;
      }
      break;
    }
  case MACHTEN_SERVER:
  case UNIX_SERVER:
  case PETER_LEWIS_SERVER:
  case WINDOWS_NT_SERVER:
  case WINDOWS_2K_SERVER:
  case MSDOS_SERVER:
  case APPLESHARE_SERVER:
  case NETPRESENZ_SERVER:
    if (*entry == '+') {
      parse_eplf_line(entry,entry_info_00);
    }
    else {
      i = strlen(entry);
      if (*first != '\0') {
        iVar3 = strcmp(entry,"can not access directory .");
        if (iVar3 == 0) {
          entry_info_00->display = '\0';
          return entry_info_00;
        }
        *first = '\0';
        iVar3 = strncmp(entry,"total ",6);
        if ((iVar3 == 0) || (src = strstr(entry,"not available"), src != (char *)0x0)) {
          entry_info_00->display = '\0';
          return entry_info_00;
        }
        if (unsure_type != 0) {
          server_type = GENERIC_SERVER;
          entry_info_00->display = '\0';
          return entry_info_00;
        }
      }
      ppuVar4 = __ctype_b_loc();
      if (((*ppuVar4)[(byte)*entry] & 0x200) == 0) {
        bVar6 = *entry == 'D';
      }
      else {
        iVar3 = toupper((uint)(byte)*entry);
        bVar6 = iVar3 == 0x44;
      }
      if (bVar6) {
        src = (char *)gettext("Directory");
        HTSACopy(&entry_info_00->type,src);
        bVar1 = true;
      }
      else {
        if (*entry == 'l') {
          src = (char *)gettext("Symbolic Link");
          HTSACopy(&entry_info_00->type,src);
          bVar1 = true;
          do {
            sVar2 = i;
            i = sVar2 - 1;
            if (i < 4) break;
            ppuVar4 = __ctype_b_loc();
          } while ((((((*ppuVar4)[(byte)entry[i]] & 0x2000) == 0) || (entry[sVar2 - 2] != '>')) ||
                   (entry[sVar2 - 3] != '-')) || (entry[sVar2 - 4] != ' '));
          if (3 < i) {
            entry[sVar2 - 4] = '\0';
            src = LYSkipBlanks(entry + i);
            HTSACopy(&entry_info_00->linkname,src);
          }
        }
      }
      parse_ls_line(entry,entry_info_00);
      iVar3 = strcmp(entry_info_00->filename,"..");
      if ((iVar3 == 0) || (iVar3 = strcmp(entry_info_00->filename,"."), iVar3 == 0)) {
        entry_info_00->display = '\0';
      }
    }
  }
  if ((bVar1) && (entry_info_00->size != 0)) {
    entry_info_00->size = 0;
  }
  if (((((entry_info_00->filename != (char *)0x0) &&
        (sVar2 = strlen(entry_info_00->filename), 3 < sVar2)) &&
       (src = strrchr(entry_info_00->filename,0x2e), src != (char *)0x0)) &&
      ((iVar3 = strncasecomp(src,".me",3), iVar3 == 0 && ((src[3] == '\0' || (src[3] == ';')))))) &&
     ((server_type != UNIX_SERVER ||
      ((entry_info_00->filename + 3 < src &&
       (iVar3 = strncasecomp(src + -4,"read.me",7), iVar3 == 0)))))) {
    HTSACopy(&entry_info_00->type,"text/plain");
  }
  if (entry_info_00->type == (char *)0x0) {
    pHVar5 = HTFileFormat(entry_info_00->filename,&encoding,&cp2);
    if (cp2 == (char *)0x0) {
      iVar3 = strncmp(pHVar5->name,"application",0xb);
      if (iVar3 == 0) {
        cp2 = pHVar5->name + 0xc;
        iVar3 = strncmp(cp2,"x-",2);
        if (iVar3 == 0) {
          cp2 = cp2 + 2;
        }
      }
      else {
        cp2 = pHVar5->name;
      }
    }
    HTSACopy(&entry_info_00->type,cp2);
  }
  return entry_info_00;
}



int compare_EntryInfo_structs(EntryInfo *entry1,EntryInfo *entry2)

{
  size_t sVar1;
  int iVar2;
  int in_GS_OFFSET;
  int local_50;
  char month [4];
  int status;
  int i;
  char date2 [16];
  char date1 [16];
  char time2 [8];
  char time1 [8];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  if (HTfileSortMethod == 2) {
    if (entry1->size == entry2->size) {
      local_50 = strcmp(entry1->filename,entry2->filename);
    }
    else {
      if (entry2->size < entry1->size) {
        local_50 = 1;
      }
      else {
        local_50 = -1;
      }
    }
  }
  else {
    if (HTfileSortMethod == 3) {
      if ((entry1->date != (char *)0x0) && (entry2->date != (char *)0x0)) {
        sVar1 = strlen(entry1->date);
        if ((sVar1 != 0xc) || (sVar1 = strlen(entry2->date), sVar1 != 0xc)) {
          local_50 = strcmp(entry1->filename,entry2->filename);
          goto LAB_0811186f;
        }
        if (HaveYears == '\0') {
          set_years_and_date();
        }
        if (entry1->date[9] == ':') {
          memcpy(date1,&DAT_08181be0,5);
          strcpy(time1,entry1->date + 7);
          if (time1[0] == ' ') {
            time1[0] = '0';
          }
        }
        else {
          strcpy(date1,entry1->date + 8);
          memcpy(time1,"00:00",6);
        }
        strncpy(month,entry1->date,3);
        month[3] = '\0';
        i = 0;
        while ((i < 0xc && (iVar2 = strcasecomp(month,months[i]), iVar2 != 0))) {
          i = i + 1;
        }
        sprintf(month,"%02d",i + 1);
        strcat(date1,month);
        strncat(date1,entry1->date + 4,2);
        date1[8] = '\0';
        if ((date1[6] == ' ') || (date1[6] == '\x01')) {
          date1[6] = '0';
        }
        if ((date1[0] == '9') && (iVar2 = atoi(date1), TheDate + 1 < iVar2)) {
          i = 0;
          while (i < 4) {
            date1[i] = LastYear[i];
            i = i + 1;
          }
        }
        strcat(date1,time1);
        if (entry2->date[9] == ':') {
          memcpy(date2,&DAT_08181be0,5);
          strcpy(time2,entry2->date + 7);
          if (time2[0] == ' ') {
            time2[0] = '0';
          }
        }
        else {
          strcpy(date2,entry2->date + 8);
          memcpy(time2,"00:00",6);
        }
        strncpy(month,entry2->date,3);
        month[3] = '\0';
        i = 0;
        while ((i < 0xc && (iVar2 = strcasecomp(month,months[i]), iVar2 != 0))) {
          i = i + 1;
        }
        sprintf(month,"%02d",i + 1);
        strcat(date2,month);
        strncat(date2,entry2->date + 4,2);
        date2[8] = '\0';
        if ((date2[6] == ' ') || (date2[6] == '\x01')) {
          date2[6] = '0';
        }
        if ((date2[0] == '9') && (iVar2 = atoi(date2), TheDate + 1 < iVar2)) {
          i = 0;
          while (i < 4) {
            date2[i] = LastYear[i];
            i = i + 1;
          }
        }
        strcat(date2,time2);
        local_50 = strcasecomp(date2,date1);
        if (local_50 != 0) goto LAB_0811186f;
      }
      local_50 = strcmp(entry1->filename,entry2->filename);
    }
    else {
      if (HTfileSortMethod == 1) {
        if (((entry1->type == (char *)0x0) || (entry2->type == (char *)0x0)) ||
           (local_50 = strcasecomp(entry1->type,entry2->type), local_50 == 0)) {
          local_50 = strcmp(entry1->filename,entry2->filename);
        }
      }
      else {
        local_50 = strcmp(entry1->filename,entry2->filename);
      }
    }
  }
LAB_0811186f:
  if (local_8 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_50;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int read_directory(HTParentAnchor *parent,char *address,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  HTStructuredClass *pHVar2;
  anon_subr_void_HTStructured_ptr_for__free *paVar3;
  anon_subr_void_HTStructured_ptr_char_for_put_character *paVar4;
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar5;
  anon_subr_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_for_start_element
  *paVar6;
  anon_subr_int_HTStructured_ptr_int_char_ptr_ptr_for_end_element *paVar7;
  bool bVar8;
  char c;
  HTStructured *target_00;
  char *__s1;
  char *Msg;
  ushort **ppuVar9;
  HTBTree *tree;
  HTChunk *ch;
  EntryInfo *entry_info_00;
  FILE *__stream;
  int iVar10;
  int in_GS_OFFSET;
  int local_110;
  HTStructuredClass targetClass;
  int i;
  HTBTElement *ele;
  char *spilledname;
  int BytesReported;
  int BytesReceived;
  HTChunk *chunk;
  int ic;
  HTBTree *bt;
  char *cp;
  char *p;
  char *lastpath;
  EntryInfo *entry_info;
  char *filename;
  HTStructured *target;
  int status;
  BOOLEAN tildeIsTop;
  BOOLEAN need_parent_link;
  BOOLEAN first;
  BOOLEAN WasInterrupted;
  char NumBytes [64];
  char string_buffer [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  bVar8 = false;
  target_00 = HTML_new(parent,format_out,sink);
  __s1 = HTParse(address,"",5);
  first = '\x01';
  lastpath = (char *)0x0;
  pHVar2 = target_00->isa;
  paVar3 = pHVar2->_free;
  paVar4 = pHVar2->put_character;
  paVar5 = pHVar2->put_string;
  paVar6 = pHVar2->start_element;
  paVar7 = pHVar2->end_element;
  mustshow = '\x01';
  Msg = (char *)gettext("Receiving FTP directory.");
  HTProgress(Msg);
  HaveYears = '\0';
  HTDirTitles(target_00,parent,format_out,server_type == VMS_SERVER);
  data_write_pointer = data_buffer;
  data_read_pointer = data_buffer;
  if (*__s1 == '\0') {
    HTSACopy(&lastpath,"/");
    goto LAB_08111c26;
  }
  iVar10 = strcmp(__s1,"/");
  if (iVar10 == 0) {
    HTSACopy(&lastpath,"/foo/..");
    goto LAB_08111c26;
  }
  Msg = strrchr(__s1,0x2f);
  if (server_type == CMS_SERVER) {
    HTSACopy(&lastpath,__s1);
  }
  else {
    HTSACopy(&lastpath,Msg + 1);
  }
  Msg = strrchr(lastpath,0x3b);
  if ((Msg == (char *)0x0) || (iVar10 = strncasecomp(Msg + 1,"type=",5), iVar10 != 0))
  goto LAB_08111c26;
  ppuVar9 = __ctype_b_loc();
  if (((*ppuVar9)[(byte)Msg[6]] & 0x200) == 0) {
    if (Msg[6] != 'D') goto LAB_08111b6d;
  }
  else {
    iVar10 = toupper((uint)(byte)Msg[6]);
    if (iVar10 != 0x44) {
LAB_08111b6d:
      ppuVar9 = __ctype_b_loc();
      if (((*ppuVar9)[(byte)Msg[6]] & 0x200) == 0) {
        if (Msg[6] != 'A') goto LAB_08111bc5;
      }
      else {
        iVar10 = toupper((uint)(byte)Msg[6]);
        if (iVar10 != 0x41) {
LAB_08111bc5:
          ppuVar9 = __ctype_b_loc();
          if (((*ppuVar9)[(byte)Msg[6]] & 0x200) == 0) {
            if (Msg[6] != 'I') goto LAB_08111c26;
          }
          else {
            iVar10 = toupper((uint)(byte)Msg[6]);
            if (iVar10 != 0x49) goto LAB_08111c26;
          }
        }
      }
    }
  }
  *Msg = '\0';
LAB_08111c26:
  if (__s1 != (char *)0x0) {
    free(__s1);
  }
  tree = HTBTree_new(compare_EntryInfo_structs);
  ch = HTChunkCreate(0x80);
  BytesReceived = 0;
  BytesReported = 0;
  spilledname = (char *)0x0;
  (*paVar4)(target_00,'\n');
  ic = 0;
  do {
    if (ic == -1) {
unload_btree:
      HTChunkFree(ch);
      if (spilledname != (char *)0x0) {
        free(spilledname);
        spilledname = (char *)0x0;
      }
      __s1 = help_message_cache_non_empty();
      if (__s1 == (char *)0x0) {
        (*paVar6)(target_00,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*paVar4)(target_00,'\n');
      }
      else {
        (*paVar6)(target_00,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*paVar6)(target_00,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*paVar4)(target_00,'\n');
        __s1 = help_message_cache_contents();
        (*paVar5)(target_00,__s1);
        init_help_message_cache();
        (*paVar6)(target_00,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*paVar4)(target_00,'\n');
      }
      ele = HTBTree_next(tree,(HTBTElement *)0x0);
      while (ele != (HTBTElement *)0x0) {
        entry_info_00 = (EntryInfo *)ele->object;
        if (entry_info_00->date == (char *)0x0) {
          (*paVar5)(target_00,"     * ");
        }
        else {
          (*paVar5)(target_00,entry_info_00->date);
          (*paVar5)(target_00,"  ");
        }
        if (entry_info_00->type != (char *)0x0) {
          i = 0;
          while ((entry_info_00->type[i] != '\0' && (i < 0x10))) {
            (*paVar4)(target_00,entry_info_00->type[i]);
            i = i + 1;
          }
          while (i < 0x11) {
            (*paVar4)(target_00,' ');
            i = i + 1;
          }
        }
        HTDirEntry(target_00,lastpath,entry_info_00->filename);
        (*paVar5)(target_00,entry_info_00->filename);
        (*paVar7)(target_00,0,(char **)0x0);
        if (entry_info_00->size == 0) {
          if (entry_info_00->linkname != (char *)0x0) {
            (*paVar5)(target_00," -> ");
            (*paVar5)(target_00,entry_info_00->linkname);
          }
        }
        else {
          if (entry_info_00->size < 0x400) {
            sprintf(string_buffer,"  %u bytes",entry_info_00->size);
          }
          else {
            sprintf(string_buffer,"  %uKb",entry_info_00->size >> 10);
          }
          (*paVar5)(target_00,string_buffer);
        }
        (*paVar4)(target_00,'\n');
        free_entryinfo_struct_contents(entry_info_00);
        ele = HTBTree_next(tree,ele);
      }
      (*paVar7)(target_00,0x56,(char **)0x0);
      (*paVar7)(target_00,0x11,(char **)0x0);
      (*paVar3)(target_00);
      HTBTreeAndObject_free(tree);
      if (lastpath != (char *)0x0) {
        free(lastpath);
        lastpath = (char *)0x0;
      }
      iVar10 = data_soc;
      if ((bVar8) || (data_soc != -1)) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Closing data socket %d\n",iVar10);
        }
        iVar10 = close(data_soc);
        if (iVar10 == -1) {
          HTInetStatus("close");
        }
        data_soc = -1;
      }
      if ((bVar8) || (iVar10 = HTCheckForInterrupt(), iVar10 != 0)) {
        mustshow = '\x01';
        __s1 = (char *)gettext("Data transfer interrupted.");
        HTProgress(__s1);
      }
      local_110 = 200;
LAB_08112639:
      if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return local_110;
    }
    HTChunkClear(ch);
    iVar10 = HTCheckForInterrupt();
    if (iVar10 != 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"read_directory: interrupted after %d bytes\n",BytesReceived);
      }
      bVar8 = true;
      if (BytesReceived == 0) {
        (*paVar3)(target_00);
        HTBTreeAndObject_free(tree);
        if (spilledname != (char *)0x0) {
          free(spilledname);
          spilledname = (char *)0x0;
        }
        local_110 = -0x752e;
        goto LAB_08112639;
      }
      goto unload_btree;
    }
    interrupted_in_next_data_char = 0;
LAB_08111d67:
    ic = next_data_char();
    while( true ) {
      if (interrupted_in_next_data_char != 0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"read_directory: interrupted_in_next_data_char after %d bytes\n",
                  BytesReceived);
        }
        bVar8 = true;
        if (BytesReceived != 0) goto unload_btree;
        (*paVar3)(target_00);
        HTBTreeAndObject_free(tree);
        if (spilledname != (char *)0x0) {
          free(spilledname);
          spilledname = (char *)0x0;
        }
        local_110 = -0x752e;
        goto LAB_08112639;
      }
      c = (char)ic;
      if ((c != '\r') && (c != '\n')) {
        if (ic == -1) goto LAB_08111f3c;
        HTChunkPutc(ch,c);
        goto LAB_08111d67;
      }
      if (ch->size == 0) goto LAB_08111d67;
      if (server_type != VMS_SERVER) goto LAB_08111f3c;
      if ((data_read_pointer < data_write_pointer) && (data_read_pointer[1] == ' ')) {
        data_read_pointer = data_read_pointer + 1;
        goto LAB_08111d67;
      }
      if (data_read_pointer < data_write_pointer) goto LAB_08111f3c;
      iVar10 = HTDoRead(data_soc,data_buffer,0x800);
      if (iVar10 != -0x752e) break;
      interrupted_in_next_data_char = 1;
    }
    if (0 < iVar10) {
      data_write_pointer = data_buffer + iVar10;
      data_read_pointer = data_buffer;
      if (data_buffer[0] != ' ') goto LAB_08111f3c;
      data_read_pointer = data_buffer + 1;
      goto LAB_08111d67;
    }
    ic = -1;
LAB_08111f3c:
    HTChunkTerminate(ch);
    BytesReceived = BytesReceived + ch->size;
    if (BytesReported + 0x400 < BytesReceived) {
      __s1 = (char *)gettext("Transferred %d bytes");
      sprintf(NumBytes,__s1,BytesReceived);
      HTProgress(NumBytes);
      BytesReported = BytesReceived;
    }
    __s1 = lastpath;
    if ((ic == -1) && (ch->size == 1)) goto unload_btree;
    if (WWW_TraceFlag != '\0') {
      Msg = ch->data;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: Line in %s is %s\n",__s1,Msg);
    }
    entry_info_00 = parse_dir_entry(ch->data,&first,&spilledname);
    if (entry_info_00->display == '\0') {
      free_entryinfo_struct_contents(entry_info_00);
      if (entry_info_00 != (EntryInfo *)0x0) {
        free(entry_info_00);
      }
    }
    else {
      if (spilledname != (char *)0x0) {
        free(spilledname);
        spilledname = (char *)0x0;
      }
      if (WWW_TraceFlag != '\0') {
        __s1 = entry_info_00->filename;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Adding file to BTree: %s\n",__s1);
      }
      HTBTree_add(tree,entry_info_00);
    }
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps

int setup_connection(char *name,HTParentAnchor *anchor)

{
  int iVar1;
  FILE *__stream;
  int iVar2;
  ushort **ppuVar3;
  uint uVar4;
  char *where;
  int in_GS_OFFSET;
  socklen_t sslen;
  int p1;
  int p0;
  int h3;
  int h2;
  int h1;
  int h0;
  char *p;
  char *command;
  int status;
  int retry;
  char c3;
  char c2;
  char c1;
  char c0;
  char dst [257];
  sockaddr_storage ss;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  status = -99;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"setup_connection(%s)\n",name);
  }
  use_list = '\0';
  server_type = GENERIC_SERVER;
  Broken_RETR = 0;
  Broken_EPSV = 0;
  retry = 0;
LAB_08112d91:
  if ((1 < retry) || (status = get_connection(name,anchor), status < 0)) goto LAB_08112d9e;
  if (ftp_local_passive == '\0') {
    status = get_listen_socket();
    if (status < 0) {
      close(control->socket);
      control->socket = -1;
      if (have_socket != '\0') {
        close_master_socket();
      }
      goto LAB_08112d9e;
    }
    status = response(port_command);
    if (status == -0x752e) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Interrupted in response (port_command)\n");
      }
      mustshow = '\x01';
      where = (char *)gettext("Connection interrupted.");
      HTProgress(where);
      close(control->socket);
      control->socket = -1;
      close_master_socket();
      status = -0x752e;
      goto LAB_08112d9e;
    }
    if (status == 2) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Port defined.\n");
      }
      goto LAB_08112d7e;
    }
    if (-1 < status) {
      status = -status;
      goto LAB_08112d9e;
    }
  }
  else {
    command = (char *)0x0;
    p = "?";
    data_soc = status;
    if (Broken_EPSV == 0) {
      p = "EPSV";
      status = send_cmd_1("EPSV");
    }
    else {
      status = 1;
    }
    if (-1 < status) {
      if (status != 2) {
        p = "PASV";
        status = send_cmd_1("PASV");
        if (status < 0) goto LAB_08112d8a;
        if (status != 2) {
          status = -status;
          goto LAB_08112d9e;
        }
      }
      iVar2 = strcmp(p,"PASV");
      if (iVar2 != 0) {
        iVar2 = strcmp(p,"EPSV");
        if (iVar2 == 0) {
          p = response_text;
          while ((*p != '\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*p] & 0x2000) == 0))) {
            p = p + 1;
          }
          while ((*p != '\0' && ((*p != '\0' && (*p != '('))))) {
            p = p + 1;
          }
          iVar2 = sscanf(p,"(%c%c%c%d%c)",&c0,&c1,&c2,&p0,&c3);
          if (iVar2 != 5) {
            __stream = TraceFP();
            fwrite("HTFTP: EPSV reply has invalid format!\n",1,0x26,(FILE *)__stream);
            status = -99;
            goto LAB_08112d9e;
          }
          passive_port = (PortNumber)p0;
          sslen = 0x80;
          iVar2 = getpeername(control->socket,(sockaddr *)&ss,&sslen);
          if (iVar2 < 0) {
            __stream = TraceFP();
            fwrite("HTFTP: getpeername(control) failed\n",1,0x23,(FILE *)__stream);
            status = -99;
            goto LAB_08112d9e;
          }
          iVar2 = getnameinfo((sockaddr *)&ss,sslen,dst,0x101,(char *)0x0,0,1);
          if (iVar2 != 0) {
            __stream = TraceFP();
            fwrite("HTFTP: getnameinfo failed\n",1,0x1a,(FILE *)__stream);
            status = -99;
            goto LAB_08112d9e;
          }
        }
        goto LAB_08112c6c;
      }
      p = response_text;
      while ((where = p, *p != '\0' && (*p != ','))) {
        p = p + 1;
      }
      do {
        p = where;
        where = p + -1;
        if ((where < response_text + 1) || (*where < '0')) break;
      } while (*where < ':');
      iVar2 = sscanf(p,"%d,%d,%d,%d,%d,%d",&h0,&h1,&h2,&h3,&p0,&p1);
      if (iVar2 < 4) {
        __stream = TraceFP();
        fwrite("HTFTP: PASV reply has no inet address!\n",1,0x27,(FILE *)__stream);
        status = -99;
        goto LAB_08112d9e;
      }
      passive_port = (short)(p0 << 8) + (short)p1;
      sprintf(dst,"%d.%d.%d.%d",h0,h1,h2,h3);
LAB_08112c6c:
      if (WWW_TraceFlag != '\0') {
        uVar4 = (uint)passive_port;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Server is listening on port %d\n",uVar4);
      }
      HTSprintf0(&command,"%s//%s:%d/",&DAT_08181e7f,dst,(uint)passive_port);
      status = HTDoConnect(command,"FTP data",(uint)passive_port,&data_soc);
      if (command != (char *)0x0) {
        free(command);
        command = (char *)0x0;
      }
      iVar2 = data_soc;
      if (status < 0) {
        where = (char *)gettext("connect for data");
        HTInetStatus(where);
        close(data_soc);
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"FTP data connected, socket %d\n",iVar2);
        }
LAB_08112d7e:
        status = 0;
      }
LAB_08112d9e:
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"setup_connection returns %d\n",status);
      }
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return status;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
  }
LAB_08112d8a:
  retry = retry + 1;
  goto LAB_08112d91;
}



int HTFTPLoad(char *name,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  FILE *__stream;
  char *a;
  ushort **ppuVar2;
  int iVar3;
  size_t sVar4;
  HTAtom *pHVar5;
  uint uVar6;
  char *local_130;
  char *pcVar7;
  char *local_134;
  CompressFileType CVar8;
  HTFormat format_00;
  int iVar9;
  int in_GS_OFFSET;
  bool bVar10;
  bool bVar11;
  char *local_12c;
  char *local_124;
  int local_120;
  uint local_118;
  char local_114;
  char *local_110;
  CompressFileType cft;
  char *fn;
  char *FileName;
  int rv;
  int check;
  int cplen;
  int i;
  char *cp2_2;
  char *cp1;
  char *mode;
  char *cp2_1;
  char *cp2;
  char *cp;
  char *types;
  char *type;
  char *vmsname;
  char *fname;
  char *filename;
  HTFormat format;
  int outstanding;
  int final_status;
  int status;
  HTAtom *encoding;
  BOOLEAN found_tilde;
  BOOLEAN included_device;
  BOOLEAN binary;
  BOOLEAN isDirectory;
  sockaddr_storage soc_address;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  bVar11 = false;
  encoding = (HTAtom *)0x0;
  outstanding = 1;
  if (WWW_TraceFlag != '\0') {
    if (ftp_local_passive == '\0') {
      local_124 = "normal";
    }
    else {
      local_124 = "passive";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTPLoad(%s) %s connection\n",name,local_124);
  }
  HTReadProgress(0,0);
  local_120 = setup_connection(name,anchor);
  if (local_120 < 0) goto LAB_0811504e;
  fname = HTParse(name,"",5);
  vmsname = (char *)0x0;
  filename = fname;
  if ((server_type == CMS_SERVER) && (a = strstr(fname,"%2"), a != (char *)0x0)) {
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[(byte)a[2]] & 0x200) == 0) {
      bVar10 = a[2] == 'F';
    }
    else {
      iVar3 = toupper((uint)(byte)a[2]);
      bVar10 = iVar3 == 0x46;
    }
    if (bVar10) {
      if (fname != (char *)0x0) {
        free(fname);
      }
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Rejecting path due to illegal escaped slash.\n");
      }
      local_120 = -1;
      goto LAB_0811504e;
    }
  }
  if (*filename == '\0') {
    HTSACopy(&filename,"/");
    type = "D";
  }
  else {
    type = strrchr(filename,0x3b);
    if (type != (char *)0x0) {
      iVar3 = strncasecomp(type + 1,"type=",5);
      if (iVar3 == 0) {
        ppuVar2 = __ctype_b_loc();
        if (((*ppuVar2)[(byte)type[6]] & 0x200) == 0) {
          local_118 = (uint)(byte)type[6];
        }
        else {
          local_118 = toupper((uint)(byte)type[6]);
        }
        if (local_118 == 0x44) {
          *type = '\0';
          type = "D";
        }
        else {
          if (local_118 == 0x49) {
            *type = '\0';
            type = "I";
          }
          else {
            if (local_118 == 0x41) {
              *type = '\0';
              type = "A";
            }
            else {
              type = "";
            }
          }
        }
        if (*filename == '\0') {
          *filename = '/';
          filename[1] = '\0';
        }
      }
      if ((*type != '\0') && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: type=%s\n",type);
      }
    }
  }
  HTUnEscape(filename);
  a = filename;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTP: UnEscaped %s\n",a);
  }
  if (filename[1] == '~') {
    fn = (char *)0x0;
    cp2 = strchr(filename + 1,0x2f);
    if (cp2 != (char *)0x0) {
      *cp2 = '\0';
    }
    iVar3 = send_cmd_1("PWD");
    if (((iVar3 == 2) && (response_text[5] == '/')) &&
       (iVar3 = send_cmd_2("CWD",filename + 1), iVar3 == 2)) {
      HTSACopy(&fn,filename + 1);
      a = fn;
      if (cp2 != (char *)0x0) {
        *cp2 = '/';
        sVar4 = strlen(fn);
        if (a[sVar4 - 1] == '/') {
          HTSACat(&fn,cp2 + 1);
        }
        else {
          HTSACat(&fn,cp2);
        }
        cp2 = (char *)0x0;
      }
      if (fname != (char *)0x0) {
        free(fname);
      }
      filename = fn;
      fname = fn;
    }
    if (cp2 != (char *)0x0) {
      *cp2 = '/';
    }
  }
  sVar4 = strlen(filename);
  if (sVar4 < 4) {
    format = HTFileFormat(filename,&encoding,(char **)0x0);
  }
  else {
    a = strrchr(filename,0x2e);
    if (((a == (char *)0x0) || (iVar3 = strncasecomp(a,".me",3), iVar3 != 0)) ||
       ((a[3] != '\0' && (a[3] != ';')))) {
      format = HTFileFormat(filename,&encoding,(char **)0x0);
    }
    else {
      if ((server_type == UNIX_SERVER) &&
         ((a <= filename + 3 || (iVar3 = strncasecomp(a + -4,"read.me",7), iVar3 != 0)))) {
        format = HTFileFormat(filename,&encoding,(char **)0x0);
      }
      else {
        *a = '\0';
        format = HTFileFormat(filename,&encoding,(char **)0x0);
        *a = '.';
      }
    }
  }
  format = HTCharsetFormat(format,anchor,-1);
  pHVar5 = HTAtom_for("8bit");
  if ((pHVar5 == encoding) || (pHVar5 = HTAtom_for("7bit"), pHVar5 == encoding)) {
    local_114 = '\0';
  }
  else {
    local_114 = '\x01';
  }
  binary = local_114;
  if ((local_114 == '\0') &&
     ((((format_out == (HTFormat)WWW_SOURCE ||
        (pHVar5 = HTAtom_for("www/download"), pHVar5 == (HTAtom *)format_out)) ||
       (pHVar5 = HTAtom_for("www/dump"), pHVar5 == (HTAtom *)format_out)) &&
      (server_type != CMS_SERVER)))) {
    binary = '\x01';
  }
  if (((binary == '\0') && (type != (char *)0x0)) && (*type == 'I')) {
    binary = '\x01';
  }
  else {
    if (((binary != '\0') && (type != (char *)0x0)) && (*type == 'A')) {
      binary = '\0';
    }
  }
  if (control->binary != binary) {
    if (binary == '\0') {
      local_110 = "A";
    }
    else {
      local_110 = "I";
    }
    uVar6 = send_cmd_2("TYPE",local_110);
    if (uVar6 != 2) {
      init_help_message_cache();
      local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
      goto LAB_0811504e;
    }
    control->binary = binary;
  }
  if (server_type == VMS_SERVER) {
    bVar10 = false;
    a = strchr(filename,0x3a);
    if ((a != (char *)0x0) || (a = strchr(filename,0x5b), a != (char *)0x0)) {
      if (fname != (char *)0x0) {
        free(fname);
      }
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Rejecting path due to non-Unix-style syntax.\n");
      }
      local_120 = -1;
      goto LAB_0811504e;
    }
    local_134 = (char *)0x2;
    iVar3 = strncmp(filename,"//",2);
    a = filename;
    if (iVar3 == 0) {
      bVar10 = true;
      i = 0;
      while (filename[i + 1] != '\0') {
        filename[i] = filename[i + 1];
        i = i + 1;
      }
      filename[i] = '\0';
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Trimmed \'%s\'\n",a);
        local_134 = a;
      }
      a = HTVMS_name("",filename);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        local_134 = a;
        fprintf((FILE *)__stream,"HTFTP: VMSized \'%s\'\n",a);
      }
      local_130 = strrchr(a,0x5d);
      if (local_130 == (char *)0x0) {
        local_130 = strchr(a,0x3a);
        if (((local_130 == (char *)0x0) || (pcVar7 = strchr(a,0x5b), pcVar7 != (char *)0x0)) ||
           (pcVar7 = strchr(a,0x5d), pcVar7 != (char *)0x0)) {
          iVar3 = strcmp(a,filename + 1);
          if (iVar3 == 0) {
            iVar3 = send_cmd_2("CWD",a);
            if (iVar3 != 2) {
              HTSprintf0(&vmsname,"%s:",a);
              uVar6 = send_cmd_2("CWD",vmsname);
              local_134 = a;
              if (uVar6 != 2) {
                if (fname != (char *)0x0) {
                  free(fname);
                }
                init_help_message_cache();
                close(control->socket);
                control->socket = -1;
                local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
                goto LAB_0811504e;
              }
            }
            HTSprintf0(&vmsname,"000000",local_134);
            filename = vmsname;
          }
        }
        else {
          local_130 = local_130 + 1;
          if (*local_130 != '\0') {
            pcVar7 = local_130 + -(int)a;
            strcpy(filename,local_130);
            local_134 = filename;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTFTP: Filename \'%s\'\n",local_134);
            }
            local_134 = pcVar7;
            local_130 = a;
            local_12c = filename;
            HTSprintf0(&vmsname,"%.*s[%s]",pcVar7,a,filename);
            iVar3 = send_cmd_2("CWD",vmsname);
            if (iVar3 == 2) {
              HTSprintf0(&vmsname,"000000",local_134,local_130,local_12c);
              filename = vmsname;
            }
            else {
              HTSprintf(&vmsname,"%.*s[000000]",pcVar7,a);
              iVar3 = send_cmd_2("CWD",vmsname);
              if (iVar3 != 2) {
                HTSprintf(&vmsname,"%.*s",pcVar7,a);
                uVar6 = send_cmd_2("CWD",vmsname);
                if (uVar6 != 2) {
                  if (fname != (char *)0x0) {
                    free(fname);
                  }
                  init_help_message_cache();
                  close(control->socket);
                  control->socket = -1;
                  local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
                  goto LAB_0811504e;
                }
              }
            }
          }
        }
      }
      else {
        strcpy(filename,local_130 + 1);
        local_134 = filename;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Filename \'%s\'\n",local_134);
        }
        local_130[1] = '\0';
        uVar6 = send_cmd_2("CWD",a);
        if (uVar6 != 2) {
          fn = (char *)0x0;
          local_134 = strchr(a,0x5b);
          if (local_134 == (char *)0x0) {
            if (fname != (char *)0x0) {
              free(fname);
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
            goto LAB_0811504e;
          }
          *local_134 = '\0';
          uVar6 = send_cmd_2("CWD",a);
          if (uVar6 != 2) {
            if (fname != (char *)0x0) {
              free(fname);
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
            goto LAB_0811504e;
          }
          HTSprintf0(&fn,"[.%s",local_134 + 1);
          uVar6 = send_cmd_2("CWD",fn);
          if (fn != (char *)0x0) {
            free(fn);
            fn = (char *)0x0;
          }
          if (uVar6 != 2) {
            if (fname != (char *)0x0) {
              free(fname);
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
            goto LAB_0811504e;
          }
        }
      }
    }
    sVar4 = strlen(filename);
    a = filename;
    if ((1 < sVar4) && (sVar4 = strlen(filename), local_134 = filename, a[sVar4 - 1] == '/')) {
      sVar4 = strlen(filename);
      local_134[sVar4 - 1] = '\0';
    }
    iVar3 = strcmp(filename,"/~");
    if (((iVar3 != 0) && ((!bVar10 || (iVar3 = strcmp(filename,"000000"), iVar3 != 0)))) &&
       ((sVar4 = strlen(filename), sVar4 != 1 || (*filename != '/')))) {
      iVar3 = strncmp(filename,"/~",2);
      if (iVar3 == 0) {
        filename = filename + 2;
      }
      a = filename;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"check \'%s\' to translate x/y/ to [.x.y]\n",a);
      }
      if ((((bVar10) || (a = strchr(filename,0x2f), a == (char *)0x0)) ||
          (local_134 = strrchr(a,0x2f), local_134 == (char *)0x0)) ||
         ((int)(local_134 + -(int)a) < 2)) {
        if ((!bVar10) && (iVar3 != 0)) {
          filename = filename + 1;
        }
      }
      else {
        fn = (char *)0x0;
        HTSprintf0(&fn,"[.%.*s]",local_134 + (-1 - (int)a),a + 1);
        a = fn;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"change path \'%s\'\n",a);
        }
        while (local_130 = strrchr(fn,0x2f), a = fn, local_130 != (char *)0x0) {
          *local_130 = '.';
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"...to  path \'%s\'\n",a);
        }
        uVar6 = send_cmd_2("CWD",fn);
        if (fn != (char *)0x0) {
          free(fn);
          fn = (char *)0x0;
        }
        if (uVar6 != 2) {
          if (fname != (char *)0x0) {
            free(fname);
          }
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
          goto LAB_0811504e;
        }
        filename = local_134 + 1;
      }
      goto LAB_08114651;
    }
    bVar11 = true;
    uVar6 = send_cmd_1("LIST");
    if (fname != (char *)0x0) {
      free(fname);
    }
    if (uVar6 != 1) {
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
      goto LAB_0811504e;
    }
  }
  else {
    if (server_type == CMS_SERVER) {
      sVar4 = strlen(filename);
      if ((((sVar4 == 1) && (*filename == '/')) ||
          ((iVar3 = strncasecomp(filename + 1,"vmsysu:",7), iVar3 == 0 &&
           ((a = strchr(filename + 1,0x2e), a != (char *)0x0 &&
            (a = strchr(a,0x2f), a == (char *)0x0)))))) ||
         ((iVar3 = strncasecomp(filename + 1,"anonymou.",9), iVar3 == 0 &&
          (a = strchr(filename + 1,0x2f), a == (char *)0x0)))) {
        if ((filename[1] != '\0') && (uVar6 = send_cmd_2("CWD",filename + 1), uVar6 != 2)) {
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -(((int)uVar6 >> 0x1f ^ uVar6) - ((int)uVar6 >> 0x1f));
          goto LAB_0811504e;
        }
        bVar11 = true;
        if (use_list == '\0') {
          status = send_cmd_1("NLST");
        }
        else {
          status = send_cmd_1("LIST");
        }
        if (fname != (char *)0x0) {
          free(fname);
        }
        if (status != 1) {
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
          goto LAB_0811504e;
        }
      }
      else {
        a = filename + 1;
        do {
          filename = a;
          local_134 = strchr(filename,0x2f);
          if (local_134 == (char *)0x0) goto LAB_08114651;
          *local_134 = '\0';
          iVar3 = send_cmd_2("CWD",filename);
          a = filename;
        } while ((iVar3 != 2) || (a = local_134 + 1, local_134[1] != '\0'));
        bVar11 = true;
        if (use_list == '\0') {
          status = send_cmd_1("NLST");
        }
        else {
          status = send_cmd_1("LIST");
        }
        if (fname != (char *)0x0) {
          free(fname);
        }
        if (status != 1) {
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
          goto LAB_0811504e;
        }
        init_help_message_cache();
      }
    }
    else {
      iVar3 = strncmp(filename,"//",2);
      if (iVar3 == 0) {
        filename = filename + 1;
      }
LAB_08114651:
      if ((type == (char *)0x0) || ((type != (char *)0x0 && (*type != 'D')))) {
        status = send_cmd_2("RETR",filename);
        if ((4 < status) && (Broken_RETR != 0)) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"{{reconnecting...\n");
          }
          close_connection(control);
          local_120 = setup_connection(name,anchor);
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"...done }}reconnecting\n");
          }
          if (local_120 < 0) goto LAB_0811504e;
        }
      }
      else {
        status = 5;
      }
      if (status != 1) {
        iVar3 = strcmp(filename,"/");
        if (iVar3 != 0) {
          init_help_message_cache();
        }
        status = send_cmd_2("CWD",filename);
        if (status == 2) {
          bVar11 = true;
          if (use_list == '\0') {
            status = send_cmd_1("NLST");
          }
          else {
            status = send_cmd_1("LIST");
          }
        }
      }
      if (fname != (char *)0x0) {
        free(fname);
      }
      if (vmsname != (char *)0x0) {
        free(vmsname);
        vmsname = (char *)0x0;
      }
      if (status != 1) {
        init_help_message_cache();
        close(control->socket);
        control->socket = -1;
        if (status < 0) {
          local_120 = status;
        }
        else {
          local_120 = -status;
        }
        goto LAB_0811504e;
      }
    }
  }
  iVar3 = data_soc;
  if (ftp_local_passive == '\0') {
    fn = (char *)0x80;
    iVar3 = accept(master_socket,(sockaddr *)&soc_address,(socklen_t *)&fn);
    if (iVar3 < 0) {
      init_help_message_cache();
      local_120 = HTInetStatus("accept");
      goto LAB_0811504e;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"TCP: Accepted new socket %d\n",iVar3);
    }
  }
  data_soc = iVar3;
  if (bVar11) {
    if (((server_type == UNIX_SERVER) && (unsure_type == 0)) &&
       (iVar3 = strcmp(response_text,"150 Opening ASCII mode data connection for /bin/dl.\n"),
       iVar3 == 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Treating as \"dls\" server.\n");
      }
      server_type = DLS_SERVER;
    }
    final_status = read_directory(anchor,name,format_out,sink);
    if (final_status < 1) {
      outstanding = 0;
    }
    else {
      if (server_type != CMS_SERVER) {
        outstanding = 0;
        iVar3 = response((char *)0x0);
        if ((iVar3 < 0) || ((iVar3 == 2 && (iVar3 = strncmp(response_text,"221",3), iVar3 == 0)))) {
          outstanding = 0;
        }
      }
    }
    iVar3 = data_soc;
    status = final_status;
    if (data_soc != -1) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Closing data socket %d\n",iVar3);
      }
      iVar3 = close(data_soc);
      if (iVar3 == -1) {
        HTInetStatus("close");
      }
    }
  }
  else {
    a = HTParse(name,"",5);
    init_help_message_cache();
    HTUnEscape(a);
    if ((((encoding == (HTAtom *)0x0) || (pHVar5 = HTAtom_for("identity"), pHVar5 == encoding)) ||
        (pHVar5 = HTAtom_for("8bit"), pHVar5 == encoding)) ||
       ((pHVar5 = HTAtom_for("binary"), pHVar5 == encoding ||
        (pHVar5 = HTAtom_for("7bit"), pHVar5 == encoding)))) {
      CVar8 = HTCompressFileType(a,"._-",(int *)&fn);
      if (CVar8 != cftNone) {
        fn[(int)a] = '\0';
        format_00 = HTFileFormat(a,&encoding,(char **)0x0);
        format_00 = HTCharsetFormat(format_00,anchor,-1);
        HTSACopy(&anchor->content_type,format_00->name);
        format = (HTFormat)HTAtom_for("www/compressed");
        if (CVar8 == cftGzip) {
          HTSACopy(&anchor->content_encoding,"x-gzip");
        }
        else {
          if (CVar8 < cftBzip2) {
            if (CVar8 == cftCompress) {
              HTSACopy(&anchor->content_encoding,"x-compress");
            }
          }
          else {
            if (CVar8 == cftBzip2) {
              HTSACopy(&anchor->content_encoding,"x-bzip2");
            }
            else {
              if (CVar8 == cftDeflate) {
                HTSACopy(&anchor->content_encoding,"x-deflate");
              }
            }
          }
        }
      }
    }
    else {
      HTSACopy(&anchor->content_type,format->name);
      HTSACopy(&anchor->content_encoding,encoding->name);
      format = (HTFormat)HTAtom_for("www/compressed");
    }
    if (a != (char *)0x0) {
      free(a);
    }
    mustshow = '\x01';
    a = (char *)gettext("Receiving FTP file.");
    HTProgress(a);
    iVar9 = HTParseSocket(format,format_out,anchor,data_soc,sink);
    HTInitInput(control->socket);
    iVar3 = data_soc;
    if (iVar9 < 0) {
      if (iVar9 == -2) {
        outstanding = 0;
      }
      else {
        if ((iVar9 == -0x752e) || (iVar9 == -1)) {
          outstanding = 0;
        }
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFTP: Closing data socket %d\n",iVar3);
      }
      status = close(data_soc);
    }
    else {
      status = 2;
    }
    if (((status < 0) && (iVar9 != -0x752e)) && (iVar9 != -1)) {
      HTInetStatus("close");
    }
    else {
      if ((iVar9 != 200) && (bVar11 = outstanding != 0, outstanding = outstanding + -1, bVar11)) {
        status = response((char *)0x0);
        if ((status != 2) && ((iVar9 != -0x752e && (iVar9 != -1)))) {
          data_soc = -1;
          init_help_message_cache();
          local_120 = HTLoadError(sink,500,response_text);
          goto LAB_0811504e;
        }
        if (status < 1) {
          outstanding = 0;
        }
        else {
          if ((status == 2) && (iVar3 = strncmp(response_text,"221",3), iVar3 == 0)) {
            outstanding = 0;
          }
        }
      }
    }
    final_status = 200;
  }
  do {
    iVar3 = outstanding + -1;
    if ((outstanding < 1) || (status < 1)) break;
    status = response((char *)0x0);
    outstanding = iVar3;
  } while ((status != 2) || (iVar3 = strncmp(response_text,"221",3), iVar3 != 0));
  data_soc = -1;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTPLoad: normal end; ");
  }
  if (control->socket < 0) {
    if (WWW_TraceFlag != '\0') {
      iVar3 = control->socket;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"control socket is %d\n",iVar3);
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      iVar3 = control->socket;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"closing control socket %d\n",iVar3);
    }
    iVar3 = close(control->socket);
    if (iVar3 == -1) {
      HTInetStatus("control connection close");
    }
  }
  control->socket = -1;
  init_help_message_cache();
  local_120 = final_status;
LAB_0811504e:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_120;
}



void HTClearFTPPassword(void)

{
  if (user_entered_password != (char *)0x0) {
    free(user_entered_password);
    user_entered_password = (char *)0x0;
  }
  return;
}



int HTInetStatus(char *where)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  FILE *__stream;
  int saved_errno;
  int status;
  
  piVar3 = __errno_location();
  iVar1 = *piVar3;
  if (WWW_TraceFlag != '\0') {
    piVar3 = __errno_location();
    pcVar4 = strerror(*piVar3);
    piVar3 = __errno_location();
    iVar2 = *piVar3;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TCP: Error %d in `SOCKET_ERRNO\' after call to %s() failed.\n\t%s\n",
            iVar2,where,pcVar4);
  }
  piVar3 = __errno_location();
  *piVar3 = iVar1;
  piVar3 = __errno_location();
  return -*piVar3;
}



uint HTCardinal(int *pstatus,char **pp,uint max_value)

{
  uint local_18;
  uint n;
  
  if ((**pp < '0') || ('9' < **pp)) {
    *pstatus = -3;
    local_18 = 0;
  }
  else {
    n = 0;
    while (('/' < **pp && (**pp < ':'))) {
      n = (n * 10 + (int)**pp) - 0x30;
      *pp = *pp + 1;
    }
    if (max_value < n) {
      *pstatus = -4;
      local_18 = 0;
    }
    else {
      local_18 = n;
    }
  }
  return local_18;
}



char * HTInetString(SockA *soc_in)

{
  char hostbuf [64];
  socklen_t local_8;
  
  if ((short)soc_in == 10) {
    local_8 = 0x1c;
  }
  else {
    local_8 = 0x10;
  }
  getnameinfo((sockaddr *)soc_in,local_8,(char *)0x81b3fa0,0x40,(char *)0x0,0,1);
  return (char *)&ram0x081b3fa0;
}



BOOLEAN valid_hostname(char *name)

{
  ushort **ppuVar1;
  BOOLEAN local_19;
  BOOLEAN local_18;
  char *cp;
  int iseg;
  int i;
  
  i = 1;
  iseg = 0;
  cp = name;
  if ((name == (char *)0x0) || (*name == '\0')) {
    local_19 = '\0';
  }
  else {
    while ((*cp != '\0' && (i < 0xfe))) {
      if (*cp == '.') {
        if (iseg == 0) {
          return '\0';
        }
        iseg = 0;
      }
      else {
        if ((iseg == 0) && ((*cp == '-' || (*cp == '+')))) {
          return '\0';
        }
        iseg = iseg + 1;
        if (0x3f < iseg) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if ((((((*ppuVar1)[(byte)*cp] & 8) == 0) && (*cp != '-')) && (*cp != '_')) &&
           ((*cp != '$' && (*cp != '+')))) {
          return '\0';
        }
      }
      cp = cp + 1;
      i = i + 1;
    }
    if ((*cp == '\0') || (((*cp == '.' && (iseg != 0)) && (cp[1] == '\0')))) {
      local_18 = '\x01';
    }
    else {
      local_18 = '\0';
    }
    local_19 = local_18;
  }
  return local_19;
}



void quench(int sig)

{
                    // WARNING: Subroutine does not return
  _exit(2);
}



void dump_hostent(char *msgprefix,hostent *phost)

{
  byte bVar1;
  char *pcVar2;
  char **ppcVar3;
  char *pcVar4;
  int iVar5;
  FILE *__stream;
  undefined *local_34;
  undefined *local_30;
  undefined *local_28;
  undefined *local_24;
  undefined *local_1c;
  char **pcnt;
  int i;
  
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s: %p ",msgprefix,phost);
    }
    if (phost != (hostent *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pcVar2 = phost->h_name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"{ h_name = %p",pcVar2);
      }
      if (phost->h_name == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,",");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar2 = phost->h_name;
          __stream = TraceFP();
          fprintf((FILE *)__stream," \"%s\",",pcVar2);
        }
      }
      if (WWW_TraceFlag != '\0') {
        ppcVar3 = phost->h_aliases;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\n\t h_aliases = %p",ppcVar3);
      }
      if (phost->h_aliases == (char **)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,",\n\t");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream," {");
        }
        pcnt = phost->h_aliases;
        while (*pcnt != (char *)0x0) {
          if (WWW_TraceFlag != '\0') {
            pcVar2 = *pcnt;
            pcVar4 = *pcnt;
            if (phost->h_aliases == pcnt) {
              local_34 = &DAT_0818229c;
            }
            else {
              local_34 = &DAT_0818229e;
            }
            __stream = TraceFP();
            fprintf((FILE *)__stream,"%s %p \"%s\"",local_34,pcVar4,pcVar2);
          }
          pcnt = pcnt + 1;
        }
        if (WWW_TraceFlag != '\0') {
          if (*phost->h_aliases == (char *)0x0) {
            local_30 = &DAT_0818229c;
          }
          else {
            local_30 = &DAT_0818229e;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"%s0x0 },\n\t",local_30);
        }
      }
      if (WWW_TraceFlag != '\0') {
        iVar5 = phost->h_addrtype;
        __stream = TraceFP();
        fprintf((FILE *)__stream," h_addrtype = %d,",iVar5);
      }
      if (WWW_TraceFlag != '\0') {
        iVar5 = phost->h_length;
        __stream = TraceFP();
        fprintf((FILE *)__stream," h_length = %d,\n\t",iVar5);
      }
      if (WWW_TraceFlag != '\0') {
        ppcVar3 = phost->h_addr_list;
        __stream = TraceFP();
        fprintf((FILE *)__stream," h_addr_list = %p",ppcVar3);
      }
      if (phost->h_addr_list == (char **)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"}");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream," {");
        }
        pcnt = phost->h_addr_list;
        while (*pcnt != (char *)0x0) {
          if (WWW_TraceFlag != '\0') {
            pcVar2 = *pcnt;
            if (phost->h_addr_list == pcnt) {
              local_28 = &DAT_081822f1;
            }
            else {
              local_28 = &DAT_08182285;
            }
            __stream = TraceFP();
            fprintf((FILE *)__stream,"%s %p",local_28,pcVar2);
          }
          i = 0;
          while (i < phost->h_length) {
            if (WWW_TraceFlag != '\0') {
              if (i + 1 == phost->h_length) {
                local_24 = &DAT_081822f8;
              }
              else {
                local_24 = &DAT_081822f1;
              }
              bVar1 = (*pcnt)[i];
              if (i == 0) {
                local_1c = &DAT_081822fa;
              }
              else {
                local_1c = &DAT_081822fd;
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,"%s%d%s",local_1c,(uint)bVar1,local_24);
            }
            i = i + 1;
          }
          pcnt = pcnt + 1;
        }
        if (*phost->h_addr_list == (char *)0x0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream," 0x0 } }");
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,", 0x0 } }");
          }
        }
      }
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
    __stream = TraceFP();
    fflush((FILE *)__stream);
  }
  return;
}



size_t fill_rehostent(char *rehostent,size_t rehostentsize,hostent *phost)

{
  uint uVar1;
  size_t sVar2;
  char *local_48;
  int i_alias;
  int i_addr;
  size_t required_this_alias;
  size_t mem_this_alias;
  size_t chk_available;
  size_t available;
  size_t curlen;
  size_t required_per_addr;
  size_t name_len;
  char **p_next_charptr;
  char *p_next_char;
  char **pcnt;
  int num_aliases;
  int num_addrs;
  AlignedHOSTENT *data;
  
  num_addrs = 0;
  num_aliases = 0;
  name_len = 0;
  available = rehostentsize - 0x14;
  if (phost == (hostent *)0x0) {
    local_48 = (char *)0x0;
  }
  else {
    uVar1 = phost->h_length + 4;
    if (phost->h_addr_list != (char **)0x0) {
      available = rehostentsize - 0x18;
    }
    if (phost->h_aliases != (char **)0x0) {
      available = available - 4;
    }
    if (phost->h_name != (char *)0x0) {
      available = available - 1;
    }
    if (((phost->h_addr_list != (char **)0x0) && (*phost->h_addr_list != (char *)0x0)) &&
       (uVar1 <= available)) {
      num_addrs = 1;
      available = available - uVar1;
    }
    if (phost->h_name != (char *)0x0) {
      name_len = strlen(phost->h_name);
      if (available < name_len) {
        name_len = 0;
      }
      else {
        available = available - name_len;
      }
    }
    if (num_addrs != 0) {
      pcnt = phost->h_addr_list;
      while ((pcnt = pcnt + 1, *pcnt != (char *)0x0 && (uVar1 <= available))) {
        num_addrs = num_addrs + 1;
        available = available - uVar1;
      }
    }
    chk_available = available;
    if (phost->h_aliases != (char **)0x0) {
      pcnt = phost->h_aliases;
      while (*pcnt != (char *)0x0) {
        sVar2 = strlen(*pcnt);
        if (sVar2 + 5 <= chk_available) {
          num_aliases = num_aliases + 1;
          chk_available = chk_available - (sVar2 + 5);
        }
        pcnt = pcnt + 1;
      }
    }
    *(int *)(rehostent + 8) = phost->h_addrtype;
    *(int *)(rehostent + 0xc) = phost->h_length;
    p_next_charptr = (char **)(rehostent + 0x14);
    p_next_char = rehostent + 0x14;
    if (phost->h_addr_list != (char **)0x0) {
      p_next_char = p_next_char + (num_addrs + 1) * 4;
    }
    if (phost->h_aliases != (char **)0x0) {
      p_next_char = p_next_char + (num_aliases + 1) * 4;
    }
    if (phost->h_addr_list == (char **)0x0) {
      *(undefined4 *)(rehostent + 0x10) = 0;
    }
    else {
      *(char ***)(rehostent + 0x10) = p_next_charptr;
      pcnt = phost->h_addr_list;
      i_addr = 0;
      while (i_addr < num_addrs) {
        memcpy(p_next_char,*pcnt,4);
        *p_next_charptr = p_next_char;
        p_next_charptr = p_next_charptr + 1;
        p_next_char = p_next_char + 4;
        pcnt = pcnt + 1;
        i_addr = i_addr + 1;
      }
      *p_next_charptr = (char *)0x0;
      p_next_charptr = p_next_charptr + 1;
    }
    if (phost->h_name == (char *)0x0) {
      *(undefined4 *)rehostent = 0;
    }
    else {
      *(char **)rehostent = p_next_char;
      if (name_len == 0) {
        *p_next_char = '\0';
        p_next_char = p_next_char + 1;
      }
      else {
        strcpy(p_next_char,phost->h_name);
        p_next_char = p_next_char + name_len + 1;
      }
    }
    if (phost->h_aliases == (char **)0x0) {
      *(undefined4 *)(rehostent + 4) = 0;
    }
    else {
      *(char ***)(rehostent + 4) = p_next_charptr;
      pcnt = phost->h_aliases;
      i_alias = 0;
      while ((*pcnt != (char *)0x0 && (i_alias < num_addrs))) {
        sVar2 = strlen(*pcnt);
        if (sVar2 + 5 <= available) {
          i_alias = i_alias + 1;
          available = available - (sVar2 + 5);
          strcpy(p_next_char,*pcnt);
          *p_next_charptr = p_next_char;
          p_next_charptr = p_next_charptr + 1;
          p_next_char = p_next_char + sVar2 + 1;
        }
        p_next_char = p_next_char + 4;
        pcnt = pcnt + 1;
        i_alias = i_alias + 1;
      }
      *p_next_charptr = (char *)0x0;
    }
    local_48 = p_next_char + -(int)rehostent;
  }
  return (size_t)local_48;
}



uint readit(int fd,char *buffer,uint length)

{
  ssize_t sVar1;
  uint got;
  uint result;
  
  result = 0;
  while( true ) {
    if (length == 0) {
      return result;
    }
    sVar1 = read(fd,buffer,length);
    if (sVar1 == 0) break;
    result = result + sVar1;
    buffer = buffer + sVar1;
    length = length - sVar1;
  }
  return result;
}



hostent * LYGetHostByName(char *str)

{
  AlignedHOSTENT aligned_full_rehostent;
  BOOLEAN BVar1;
  FILE *__stream;
  int iVar2;
  __pid_t _Var3;
  int *piVar4;
  hostent *phost_00;
  ulong *puVar5;
  time_t tVar6;
  uint uVar7;
  size_t local_234;
  fd_set readfds;
  sigset_t new_sigset;
  sigset_t old_sigset;
  _statuses statuses;
  timeval one_second;
  int pfd [2];
  anon_union_for___u __u_8;
  anon_union_for___u __u_7;
  anon_union_for___u __u_6;
  anon_union_for___u __u_5;
  anon_union_for___u __u_4;
  anon_union_for___u __u_3;
  anon_union_for___u __u_2;
  anon_union_for___u __u_1;
  anon_union_for___u __u;
  int kbd_fd;
  fd_set *__arr;
  uint __i;
  hostent *phost;
  int child_exited;
  long dns_patience;
  time_t start_time;
  int waitstat;
  int readret;
  int selret;
  int waitret;
  int fpid;
  int got_rehostent;
  hostent *result_phost;
  size_t rehostentlen;
  char *rehostent;
  char *host;
  
  host = str;
  rehostent = (char *)0x81b3fe0;
  rehostentlen = 0;
  result_phost = (hostent *)0x0;
  if (str == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYGetHostByName: Can\'t parse `NULL\'.\n");
    }
    lynx_nsl_status = -900;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYGetHostByName: parsing `%s\'.\n",str);
    }
    iVar2 = HTCheckForInterrupt();
    if (iVar2 == 0) {
      BVar1 = valid_hostname(str);
      if (BVar1 == '\0') {
        lynx_nsl_status = -0x196;
        my_errno = 3;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fflush((FILE *)__stream);
        }
        lynx_nsl_status = -900;
        statuses.h_errno_valid = '\0';
        got_rehostent = 0;
        waitstat = 0;
        start_time = time((time_t *)0x0);
        dns_patience = 0x1e;
        child_exited = 0;
        do {
          do {
            _Var3 = waitpid(-1,(int *)0x0,1);
          } while (0 < _Var3);
        } while ((_Var3 == -1) && (piVar4 = __errno_location(), *piVar4 == 4));
        waitret = 0;
        pipe(pfd);
        sigemptyset((sigset_t *)&new_sigset);
        sigaddset((sigset_t *)&new_sigset,0xf);
        sigaddset((sigset_t *)&new_sigset,2);
        sigaddset((sigset_t *)&new_sigset,1);
        sigaddset((sigset_t *)&new_sigset,0x14);
        sigaddset((sigset_t *)&new_sigset,0x1c);
        sigprocmask(0,(sigset_t *)&new_sigset,(sigset_t *)&old_sigset);
        fpid = fork();
        if (fpid == 0) {
          signal(0xf,quench);
          signal(2,quench);
          signal(1,quench);
          if (no_suspend == '\0') {
            signal(0x14,(__sighandler_t)0x0);
          }
          else {
            signal(0x14,(__sighandler_t)0x1);
          }
          signal(0x1c,(__sighandler_t)0x1);
          signal(0xb,(__sighandler_t)0x0);
          signal(4,(__sighandler_t)0x0);
          sigprocmask(2,(sigset_t *)&old_sigset,(sigset_t *)0x0);
          close(pfd[0]);
          piVar4 = __errno_location();
          *piVar4 = 0;
          phost_00 = gethostbyname(str);
          puVar5 = (ulong *)__errno_location();
          statuses.child_errno = *puVar5;
          statuses.child_h_errno = my_errno;
          dump_hostent("CHILD gethostbyname",(hostent *)phost_00);
          if ((phost_00 != (hostent *)0x0) && (phost_00->h_length != 0)) {
            rehostentlen = fill_rehostent((char *)0x81b3fe0,0x80,(hostent *)phost_00);
            dump_hostent("CHILD fill_rehostent",(hostent *)0x81b3fe0);
          }
          if ((rehostentlen < 0x15) || (aligned_full_rehostent.h.h_length == 0)) {
            rehostentlen = 0;
            statuses.h_length = 0;
          }
          else {
            statuses.h_length = aligned_full_rehostent.h.h_length;
          }
          if (statuses.child_errno == 0) {
            puVar5 = (ulong *)__errno_location();
            statuses.child_errno = *puVar5;
          }
          statuses.rehostentlen = rehostentlen;
          write(pfd[1],&statuses,0x14);
          if (rehostentlen == 0) {
                    // WARNING: Subroutine does not return
            _exit(1);
          }
          write(pfd[1],(void *)0x81b3fe0,rehostentlen);
          close(pfd[1]);
                    // WARNING: Subroutine does not return
          _exit(0);
        }
        local_234 = 0;
        sigprocmask(2,(sigset_t *)&old_sigset,(sigset_t *)0x0);
        close(pfd[1]);
        if (fpid < 0) {
          close(pfd[0]);
failed:
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYGetHostByName: Can\'t find internet node name `%s\'.\n",host
                   );
          }
        }
        else {
LAB_08116337:
          do {
            if ((child_exited == 0) &&
               (tVar6 = time((time_t *)0x0), dns_patience <= tVar6 - start_time)) {
LAB_08116359:
              close(pfd[0]);
              if (waitret < 1) {
                kill(fpid,0xf);
                local_234 = 1;
                waitret = waitpid(fpid,&waitstat,1);
              }
              if (0 < waitret) {
                if ((waitstat & 0x7fU) == 0) {
                  if (WWW_TraceFlag != '\0') {
                    uVar7 = waitstat & 0xff00;
                    __stream = TraceFP();
                    fprintf((FILE *)__stream,
                            "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",waitret,
                            (int)uVar7 >> 8);
                    local_234 = waitret;
                  }
                }
                else {
                  if ((char)(((byte)waitstat & 0x7f) + 1) >> 1 < '\x01') {
                    if (((waitstat & 0xffU) == 0x7f) && (WWW_TraceFlag != '\0')) {
                      uVar7 = waitstat & 0xff00;
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,
                              "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
                              waitret,(int)uVar7 >> 8);
                      local_234 = waitret;
                    }
                  }
                  else {
                    if (WWW_TraceFlag != '\0') {
                      uVar7 = waitstat & 0x7f;
                      __stream = TraceFP();
                      local_234 = waitret;
                      fprintf((FILE *)__stream,
                              "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
                              waitret,uVar7);
                    }
                    if (((waitstat & 0x80U) != 0) && (WWW_TraceFlag != '\0')) {
                      __stream = TraceFP();
                      fprintf((FILE *)__stream,"LYGetHostByName: NSL_FORK child %d dumped core!\n",
                              waitret);
                      local_234 = waitret;
                    }
                  }
                }
              }
              if (got_rehostent != 0) {
                dump_hostent("End of LYGetHostByName",result_phost);
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"LYGetHostByName: Resolved name to a hostent.\n",
                          local_234);
                }
                return result_phost;
              }
              goto failed;
            }
            __i = 0;
            while (__i < 0x20) {
              readfds.fds_bits[__i] = 0;
              __i = __i + 1;
            }
            uVar7 = LYConsoleInputFD('\x01');
            if (uVar7 != 0xffffffff) {
              readfds.fds_bits[uVar7 >> 5] =
                   1 << ((byte)uVar7 & 0x1f) | readfds.fds_bits[uVar7 >> 5];
            }
            one_second.tv_sec = 1;
            one_second.tv_usec = 0;
            readfds.fds_bits[(uint)pfd[0] >> 5] =
                 1 << ((byte)pfd[0] & 0x1f) | readfds.fds_bits[(uint)pfd[0] >> 5];
            iVar2 = select(pfd[0] + 1,(fd_set *)&readfds,(fd_set *)0x0,(fd_set *)0x0,
                           (timeval *)&one_second);
            if ((0 < iVar2) &&
               ((readfds.fds_bits[(uint)pfd[0] >> 5] >> ((byte)pfd[0] & 0x1f) & 1U) != 0)) {
              local_234 = 0x14;
              uVar7 = readit(pfd[0],(char *)&statuses,0x14);
              if (uVar7 == 0x14) {
                my_errno = statuses.child_h_errno;
                puVar5 = (ulong *)__errno_location();
                *puVar5 = statuses.child_errno;
                if (0x14 < statuses.rehostentlen) {
                  local_234 = statuses.rehostentlen;
                  uVar7 = readit(pfd[0],rehostent,statuses.rehostentlen);
                  dump_hostent("Read from pipe",(hostent *)rehostent);
                  if (statuses.rehostentlen == uVar7) {
                    got_rehostent = 1;
                    result_phost = (hostent *)rehostent;
                    lynx_nsl_status = 0;
                  }
                  else {
                    if (statuses.h_errno_valid == '\0') {
                      lynx_nsl_status = -900;
                    }
                  }
                }
              }
              else {
                lynx_nsl_status = -1;
              }
              if (child_exited == 0) {
                local_234 = 1;
                waitret = waitpid(fpid,&waitstat,1);
              }
              if (((waitstat & 0x7fU) != 0) && ((char)(((byte)waitstat & 0x7f) + 1) >> 1 < '\x01'))
              {
                kill(fpid,0xf);
                local_234 = 1;
                waitret = waitpid(fpid,&waitstat,1);
              }
              goto LAB_08116359;
            }
            if (child_exited != 0) {
              local_234 = 1;
              waitret = waitpid(fpid,&waitstat,1);
              goto LAB_08116359;
            }
            local_234 = 1;
            waitret = waitpid(fpid,&waitstat,1);
            if (0 < waitret) {
              child_exited = 1;
              goto LAB_08116337;
            }
            iVar2 = HTCheckForInterrupt();
          } while (iVar2 == 0);
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"LYGetHostByName: INTERRUPTED gethostbyname.\n");
          }
          kill(fpid,0xf);
          waitpid(fpid,(int *)0x0,1);
          close(pfd[0]);
          lynx_nsl_status = -0x752e;
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LYGetHostByName: INTERRUPTED for \'%s\'.\n",str);
      }
      lynx_nsl_status = -0x752e;
    }
  }
  return (hostent *)0x0;
}



addrinfo * HTGetAddrInfo(char *str,int defport)

{
  int iVar1;
  int __ecode;
  char *pcVar2;
  FILE *__stream;
  int in_GS_OFFSET;
  addrinfo hints;
  char *port;
  char *host;
  char *s;
  char *p;
  int error;
  addrinfo *res;
  char pbuf [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  s = (char *)0x0;
  HTSACopy(&s,str);
  if (*s == '[') {
    p = strchr(s,0x5d);
    if (p != (char *)0x0) {
      *p = '\0';
      p = p + 1;
      host = s + 1;
      goto LAB_081165f0;
    }
  }
  p = s;
  host = s;
LAB_081165f0:
  port = strrchr(p,0x3a);
  if (port == (char *)0x0) {
    sprintf(pbuf,"%d",defport);
    port = pbuf;
  }
  else {
    *port = '\0';
    port = port + 1;
  }
  memset(&hints,0,0x20);
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  __ecode = getaddrinfo(host,port,(addrinfo *)&hints,(addrinfo **)&res);
  if ((__ecode != 0) || (res == (addrinfo *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      pcVar2 = gai_strerror(__ecode);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTGetAddrInfo: getaddrinfo(%s, %s): %s\n",host,port,pcVar2);
    }
    res = (addrinfo *)0x0;
  }
  free(s);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return res;
}



void get_host_details(void)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int in_GS_OFFSET;
  int namelength;
  char name [65];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (hostname == (char *)0x0) {
    gethostname(name,0x41);
    HTSACopy(&hostname,name);
    pcVar2 = hostname;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"TCP: Local host name is %s\n",pcVar2);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * HTHostName(void)

{
  get_host_details();
  return hostname;
}



BOOLEAN HTWasInterrupted(int *status)

{
  int iVar1;
  int *piVar2;
  BOOLEAN result;
  
  iVar1 = HTCheckForInterrupt();
  if (iVar1 != 0) {
    *status = -0x752e;
    piVar2 = __errno_location();
    *piVar2 = 4;
  }
  return (BOOLEAN)(iVar1 != 0);
}



void set_timeout(timeval *timeoutp)

{
  timeoutp->tv_sec = 0;
  timeoutp->tv_usec = 100000;
  return;
}



int HTDoConnect(char *url,char *protocol,int default_port,int *s)

{
  BOOLEAN BVar1;
  char *local_900;
  char *pcVar2;
  undefined4 uVar3;
  char *fmt;
  int *piVar4;
  FILE *__stream;
  int iVar5;
  int in_GS_OFFSET;
  int local_8e8;
  fd_set writefds;
  timeval select_timeout;
  int ret_2;
  int val;
  fd_set *__arr;
  uint __i;
  int tries;
  int ret_1;
  int ret;
  addrinfo *res0;
  addrinfo *res;
  char *host;
  char *at_sign;
  char *p1;
  char *line;
  int status;
  char portbuf [1024];
  char hostbuf [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  status = 0;
  line = (char *)0x0;
  host = (char *)0x0;
  local_900 = HTParse(url,"",8);
  pcVar2 = strchr(local_900,0x40);
  if (pcVar2 == (char *)0x0) {
    HTSACopy(&host,local_900);
  }
  else {
    HTSACopy(&host,pcVar2 + 1);
  }
  if (local_900 != (char *)0x0) {
    free(local_900);
  }
  local_900 = host;
  uVar3 = gettext("Looking up ");
  HTSprintf0(&line,"%s%s",uVar3,local_900);
  mustshow = '\x01';
  HTProgress(line);
  res0 = HTGetAddrInfo(host,default_port);
  pcVar2 = host;
  if (res0 == (addrinfo *)0x0) {
    fmt = (char *)gettext("Unable to locate remote host %s.");
    HTSprintf0(&line,fmt,pcVar2,local_900);
    mustshow = '\x01';
    HTProgress(line);
    if (host != (char *)0x0) {
      free(host);
      host = (char *)0x0;
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    local_8e8 = -0xcc;
  }
  else {
    local_900 = (char *)gettext("Making %s connection to %s");
    HTSprintf0(&line,local_900,protocol,pcVar2);
    mustshow = '\x01';
    HTProgress(line);
    if (host != (char *)0x0) {
      free(host);
      host = (char *)0x0;
    }
    res = res0;
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    while (res != (addrinfo *)0x0) {
      iVar5 = socket(res->ai_family,res->ai_socktype,res->ai_protocol);
      *s = iVar5;
      if (*s == -1) {
        getnameinfo((sockaddr *)res->ai_addr,res->ai_addrlen,hostbuf,0x400,portbuf,0x400,3);
        iVar5 = res->ai_family;
        local_900 = (char *)gettext("socket failed: family %d addr %s port %s.");
        HTSprintf0(&line,local_900,iVar5,hostbuf,portbuf);
        mustshow = '\x01';
        HTProgress(line);
        if (line != (char *)0x0) {
          free(line);
          line = (char *)0x0;
        }
      }
      else {
        val = 1;
        iVar5 = ioctl(*s,0x5421,&val);
        if (iVar5 == -1) {
          mustshow = '\x01';
          local_900 = (char *)gettext("Could not make connection non-blocking.");
          HTProgress(local_900);
        }
        status = connect(*s,(sockaddr *)res->ai_addr,res->ai_addrlen);
        if ((status < 0) &&
           ((piVar4 = __errno_location(), *piVar4 == 0x73 ||
            (piVar4 = __errno_location(), *piVar4 == 0xb)))) {
          tries = 0;
          HTInetStatus("this socket\'s first connect");
          ret_1 = 0;
          do {
            do {
              iVar5 = status;
              if (0 < ret_1) goto LAB_08116fbc;
              iVar5 = tries / 10;
              tries = tries + 1;
              if (connect_timeout <= iVar5) {
                local_900 = (char *)gettext("Connection failed (too many retries).");
                HTAlert(local_900);
                if (line != (char *)0x0) {
                  free(line);
                  line = (char *)0x0;
                }
                if (res0 != (addrinfo *)0x0) {
                  freeaddrinfo((addrinfo *)res0);
                }
                local_8e8 = -0xcc;
                goto LAB_081170b7;
              }
              set_timeout(&select_timeout);
              __i = 0;
              while (__i < 0x20) {
                writefds.fds_bits[__i] = 0;
                __i = __i + 1;
              }
              writefds.fds_bits[(uint)*s >> 5] =
                   1 << ((byte)*s & 0x1f) | writefds.fds_bits[(uint)*s >> 5];
              ret_1 = select(*s + 1,(fd_set *)0x0,(fd_set *)&writefds,(fd_set *)0x0,
                             (timeval *)&select_timeout);
              if (tries == 1) {
                HTInetStatus("this socket\'s first select");
              }
            } while ((ret_1 == -1) && (piVar4 = __errno_location(), *piVar4 == 4));
            if (ret_1 < 0) {
              HTInetStatus("failed select");
              piVar4 = __errno_location();
              iVar5 = ret_1;
              if (*piVar4 != 0x72) goto LAB_08116fbc;
            }
            if (ret_1 < 1) {
              status = connect(*s,(sockaddr *)res->ai_addr,res->ai_addrlen);
              if ((((status < 0) && (piVar4 = __errno_location(), *piVar4 != 0x72)) &&
                  (piVar4 = __errno_location(), *piVar4 != 0xb)) &&
                 (piVar4 = __errno_location(), *piVar4 != 0x6a)) {
                HTInetStatus("confirm-not-ready connect");
                iVar5 = status;
                goto LAB_08116fbc;
              }
            }
            else {
              status = connect(*s,(sockaddr *)res->ai_addr,res->ai_addrlen);
              if ((status < 0) && (piVar4 = __errno_location(), *piVar4 == 0x6a)) {
                status = 0;
              }
              if ((status == 0) || (piVar4 = __errno_location(), *piVar4 != 0x72)) {
                iVar5 = status;
                if (status < 0) {
                  HTInetStatus("confirm-ready connect");
                  iVar5 = status;
                }
                goto LAB_08116fbc;
              }
              ret_1 = 0;
            }
            BVar1 = HTWasInterrupted(&status);
          } while (BVar1 == '\0');
          iVar5 = status;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"*** INTERRUPTED in middle of connect.\n");
            iVar5 = status;
          }
        }
        else {
          iVar5 = status;
          if (status < 0) {
            HTInetStatus("this socket\'s first and only connect");
            iVar5 = status;
          }
        }
LAB_08116fbc:
        status = iVar5;
        if (-1 < status) break;
        close(*s);
        *s = -1;
      }
      res = res->ai_next;
    }
    if (*s < 0) {
      close(*s);
    }
    else {
      val = 0;
      iVar5 = ioctl(*s,0x5421,&val);
      if (iVar5 == -1) {
        mustshow = '\x01';
        local_900 = (char *)gettext("Could not restore socket to blocking.");
        HTProgress(local_900);
      }
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    if (res0 != (addrinfo *)0x0) {
      freeaddrinfo((addrinfo *)res0);
    }
    local_8e8 = status;
  }
LAB_081170b7:
  if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_8e8;
}



int HTDoRead(int fildes,void *buf,uint nbyte)

{
  BOOLEAN BVar1;
  int iVar2;
  FILE *__stream;
  char *Msg;
  int *piVar3;
  time_t tVar4;
  int local_c0;
  fd_set readfds;
  timeval select_timeout;
  fd_set *__arr;
  uint __i;
  time_t t;
  time_t start;
  time_t otime;
  int otries;
  int tries;
  int ret;
  int result;
  BOOLEAN ready;
  
  tries = 0;
  otries = 0;
  start = time((time_t *)0x0);
  if (fildes == 0) {
    iVar2 = isatty(0);
    if (iVar2 != 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTDoRead - refusing to read fd 0 which is a tty!\n");
      }
      return -1;
    }
  }
  else {
    if (fildes < 1) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTDoRead - no file descriptor!\n");
      }
      return -1;
    }
  }
  BVar1 = HTWasInterrupted(&result);
  if (BVar1 == '\0') {
    ready = '\0';
    otime = start;
    do {
      while( true ) {
        if (ready != '\0') goto LAB_0811735c;
        iVar2 = tries / 10;
        tries = tries + 1;
        if (reading_timeout <= iVar2) {
          Msg = (char *)gettext("Socket read failed (too many tries).");
          HTAlert(Msg);
          piVar3 = __errno_location();
          *piVar3 = 4;
          result = -0x752e;
          goto LAB_0811735c;
        }
        if ((10 < tries - otries) &&
           (tVar4 = time((time_t *)0x0), otries = tries, 4 < tVar4 - otime)) {
          HTReadProgress(-1,0);
          otime = tVar4;
        }
        do {
          set_timeout(&select_timeout);
          __i = 0;
          while (__i < 0x20) {
            readfds.fds_bits[__i] = 0;
            __i = __i + 1;
          }
          readfds.fds_bits[(uint)fildes >> 5] =
               1 << ((byte)fildes & 0x1f) | readfds.fds_bits[(uint)fildes >> 5];
          iVar2 = select(fildes + 1,(fd_set *)&readfds,(fd_set *)0x0,(fd_set *)0x0,
                         (timeval *)&select_timeout);
        } while ((iVar2 == -1) && (piVar3 = __errno_location(), *piVar3 == 4));
        if (iVar2 < 0) {
          result = -1;
          goto LAB_0811735c;
        }
        if (iVar2 < 1) break;
        ready = '\x01';
      }
      BVar1 = HTWasInterrupted(&result);
    } while (BVar1 == '\0');
LAB_0811735c:
    if (ready != '\0') {
      do {
        result = read(fildes,buf,nbyte);
        if (result != -1) goto LAB_081173a2;
        piVar3 = __errno_location();
      } while (*piVar3 == 4);
      HTInetStatus("read");
    }
LAB_081173a2:
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x100U) != 0)) {
      tVar4 = time((time_t *)0x0);
      iVar2 = result;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...HTDoRead returns %d (%d seconds)\n",iVar2,tVar4 - start);
    }
    local_c0 = result;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTDoRead - interrupted before starting!\n");
    }
    local_c0 = result;
  }
  return local_c0;
}



void fake_put_character(void *p,char c)

{
  return;
}



char * state_name(sgml_state n)

{
  char *result;
  
  result = "?";
  switch(n) {
  case S_text:
    result = "S_text";
    break;
  case S_attr:
    result = "S_attr";
    break;
  case S_attr_gap:
    result = "S_attr_gap";
    break;
  case S_comment:
    result = "S_comment";
    break;
  case S_cro:
    result = "S_cro";
    break;
  case S_doctype:
    result = "S_doctype";
    break;
  case S_dollar:
    result = "S_dollar";
    break;
  case S_dollar_dq:
    result = "S_dollar_dq";
    break;
  case S_dollar_paren:
    result = "S_dollar_paren";
    break;
  case S_dollar_paren_dq:
    result = "S_dollar_paren_dq";
    break;
  case S_dollar_paren_sq:
    result = "S_dollar_paren_sq";
    break;
  case S_dollar_sq:
    result = "S_dollar_sq";
    break;
  case S_dquoted:
    result = "S_dquoted";
    break;
  case S_end:
    result = "S_end";
    break;
  case S_entity:
    result = "S_entity";
    break;
  case S_equals:
    result = "S_equals";
    break;
  case S_ero:
    result = "S_ero";
    break;
  case S_esc:
    result = "S_esc";
    break;
  case S_esc_dq:
    result = "S_esc_dq";
    break;
  case S_esc_sq:
    result = "S_esc_sq";
    break;
  case S_exclamation:
    result = "S_exclamation";
    break;
  case S_in_kanji:
    result = "S_in_kanji";
    break;
  case S_incro:
    result = "S_incro";
    break;
  case S_junk_tag:
    result = "S_junk_tag";
    break;
  case S_litteral:
    result = "S_litteral";
    break;
  case S_marked:
    result = "S_marked";
    break;
  case S_nonascii_text:
    result = "S_nonascii_text";
    break;
  case S_nonascii_text_dq:
    result = "S_nonascii_text_dq";
    break;
  case S_nonascii_text_sq:
    result = "S_nonascii_text_sq";
    break;
  case S_paren:
    result = "S_paren";
    break;
  case S_paren_dq:
    result = "S_paren_dq";
    break;
  case S_paren_sq:
    result = "S_paren_sq";
    break;
  case S_pcdata:
    result = "S_pcdata";
    break;
  case S_pi:
    result = "S_pi";
    break;
  case S_script:
    result = "S_script";
    break;
  case S_sgmlatt:
    result = "S_sgmlatt";
    break;
  case S_sgmlele:
    result = "S_sgmlele";
    break;
  case S_sgmlent:
    result = "S_sgmlent";
    break;
  case S_squoted:
    result = "S_squoted";
    break;
  case S_tag:
    result = "S_tag";
    break;
  case S_tag_gap:
    result = "S_tag_gap";
    break;
  case S_tagname_slash:
    result = "S_tagname_slash";
    break;
  case S_value:
    result = "S_value";
  }
  return result;
}



HTElement * pool_alloc(void)

{
  HTElement *local_8;
  
  depth = depth + 1;
  if (depth < 0xb) {
    local_8 = pool + (1 - depth) * 0x1fffffff;
  }
  else {
    local_8 = (HTElement *)malloc(8);
  }
  return local_8;
}



void pool_free(HTElement *e)

{
  if ((10 < depth) && (e != (HTElement *)0x0)) {
    free(e);
  }
  depth = depth + -1;
  return;
}



void HTMLSRC_apply_markup(HTStream *context,HTlexeme lexeme,BOOLEAN start)

{
  FILE *__stream;
  HT_tagspec **local_34;
  char *local_2c;
  HT_tagspec *ts;
  
  if (start == '\0') {
    local_34 = lexeme_end;
  }
  else {
    local_34 = lexeme_start;
  }
  ts = local_34[lexeme];
  while (ts != (HT_tagspec *)0x0) {
    if (ts->start != '\0') {
      current_tag_style = ts->style;
      force_current_tag_style = '\x01';
      forced_classname = ts->class_name;
      force_classname = '\x01';
    }
    if (WWW_TraceFlag != '\0') {
      if (ts->start == '\0') {
        local_2c = "SRCSTOP %d\n";
      }
      else {
        local_2c = "SRCSTART %d\n";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,local_2c,lexeme);
    }
    if (ts->start == '\0') {
      (*context[2].isa[1]._free)((HTStream *)context[3].isa);
    }
    else {
      (*(code *)context[2].isa[1].name)
                (context[3].isa,ts->element,ts->present,ts->value,context[0x4b].isa,context + 0x4e);
    }
    ts = (HT_tagspec *)ts->next;
  }
  return;
}



void set_chartrans_handling(HTStream *context,HTParentAnchor *anchor,int chndl)

{
  LYUCcharset *pLVar1;
  HTStreamClass *pHVar2;
  
  if (chndl < 0) {
    chndl = HTAnchor_getUCLYhndl(anchor,2);
    if (chndl < 0) {
      chndl = HTAnchor_getUCLYhndl(anchor,3);
    }
    if (chndl < 0) {
      chndl = current_char_set;
    }
    HTAnchor_setUCInfoStage(anchor,chndl,3,1);
    HTAnchor_setUCInfoStage(anchor,chndl,2,1);
    pLVar1 = HTAnchor_getUCInfoStage(anchor,2);
    *(LYUCcharset **)&context[0x41].isa = pLVar1;
    pHVar2 = (HTStreamClass *)HTAnchor_getUCLYhndl((HTParentAnchor *)context[0x3e].isa,2);
    context[0x42].isa = pHVar2;
  }
  UCSetTransParams((UCTransParams *)(context + 0x48),(int)context[0x40].isa,
                   (LYUCcharset *)context[0x3f].isa,(int)context[0x42].isa,
                   (LYUCcharset *)context[0x41].isa);
  if (*(char *)&context[0x48].isa == '\0') {
    if (*(char *)((int)&context[0x48].isa + 2) == '\0') {
      if ((*(char *)((int)&context[0x49].isa + 3) == '\0') && (*(char *)&context[0x49].isa == '\0'))
      {
        if ((*(char *)((int)&context[0x48].isa + 3) == '\0') &&
           (*(char *)((int)&context[0x4a].isa + 3) == '\0')) {
          *(int *)&context[0x4b].isa = LATIN1;
        }
        else {
          pHVar2 = (HTStreamClass *)UCGetLYhndl_byMIME("utf-8");
          context[0x4b].isa = pHVar2;
        }
      }
      else {
        context[0x4b].isa = context[0x40].isa;
      }
    }
    else {
      context[0x4b].isa = context[0x40].isa;
    }
  }
  else {
    context[0x4b].isa = context[0x40].isa;
  }
  return;
}



void change_chartrans_handling(HTStream *context)

{
  HTStreamClass *pHVar1;
  LYUCcharset *pLVar2;
  LYUCcharset *pLVar3;
  HTStreamClass *chndl;
  int next_LYhndl;
  LYUCcharset *next_UCI;
  LYUCcharset *new_UCI;
  int new_LYhndl;
  
  pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl((HTParentAnchor *)context[0x3e].isa,1);
  if ((context[0x40].isa != pHVar1) && (-1 < (int)pHVar1)) {
    pLVar2 = HTAnchor_getUCInfoStage((HTParentAnchor *)context[0x3e].isa,1);
    if (pLVar2 != (LYUCcharset *)0x0) {
      pLVar3 = HTAnchor_getUCInfoStage((HTParentAnchor *)context[0x3e].isa,2);
      chndl = (HTStreamClass *)HTAnchor_getUCLYhndl((HTParentAnchor *)context[0x3e].isa,2);
      *(LYUCcharset **)&context[0x3f].isa = pLVar2;
      context[0x40].isa = pHVar1;
      *(LYUCcharset **)&context[0x41].isa = pLVar3;
      context[0x42].isa = chndl;
      set_chartrans_handling(context,(HTParentAnchor *)context[0x3e].isa,(int)chndl);
    }
  }
  return;
}



void handle_attribute_name(HTStream *context,char *s)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  HTStreamClass *pHVar2;
  ushort **ppuVar3;
  uint uVar4;
  FILE *__stream;
  int local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  char *local_2c;
  int diff;
  int i;
  int low;
  int high;
  attr *attributes;
  HTTag *tag;
  
  pHVar2 = context[4].isa;
  paVar1 = pHVar2->put_character;
  if (psrc_view != '\0') {
    *(undefined *)&context[0x54].isa = 0;
    *(undefined *)((int)&context[0x54].isa + 1) = 0;
  }
  if (context[6].isa == pHVar2) {
    if (psrc_view != '\0') {
      context[8].isa = (HTStreamClass *)0x1;
    }
  }
  else {
    low = 0;
    pHVar2 = (HTStreamClass *)pHVar2->put_string;
    while (high = (int)pHVar2, low < high) {
      pHVar2 = (HTStreamClass *)((high - low) / 2 + low);
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[**(byte **)(paVar1 + (int)pHVar2 * 8)] & 0x200) == 0) {
        local_3c = (uint)**(byte **)(paVar1 + (int)pHVar2 * 8);
      }
      else {
        local_3c = toupper((uint)**(byte **)(paVar1 + (int)pHVar2 * 8));
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*s] & 0x200) == 0) {
        local_38 = (uint)(byte)*s;
      }
      else {
        local_38 = toupper((uint)(byte)*s);
      }
      if (local_3c == local_38) {
        local_40 = strcasecomp(*(char **)(paVar1 + (int)pHVar2 * 8),s);
      }
      else {
        ppuVar3 = __ctype_b_loc();
        if (((*ppuVar3)[**(byte **)(paVar1 + (int)pHVar2 * 8)] & 0x200) == 0) {
          local_34 = (uint)**(byte **)(paVar1 + (int)pHVar2 * 8);
        }
        else {
          local_34 = toupper((uint)**(byte **)(paVar1 + (int)pHVar2 * 8));
        }
        ppuVar3 = __ctype_b_loc();
        if (((*ppuVar3)[(byte)*s] & 0x200) == 0) {
          local_30 = (uint)(byte)*s;
        }
        else {
          local_30 = toupper((uint)(byte)*s);
        }
        local_40 = local_34 - local_30;
      }
      if (local_40 == 0) {
        context[8].isa = pHVar2;
        if (psrc_view != '\0') {
          *(bool *)((int)&context[0x54].isa + 1) =
               paVar1[(int)pHVar2 * 8 + 4] ==
               (anon_subr_void_HTStream_ptr_char_for_put_character)0x1;
          *(bool *)&context[0x54].isa =
               paVar1[(int)pHVar2 * 8 + 4] ==
               (anon_subr_void_HTStream_ptr_char_for_put_character)0x2;
          return;
        }
        *(undefined *)((int)&context[0xe].isa + (int)pHVar2 + 1) = 1;
        if (context[(int)(pHVar2 + 1)].isa != (HTStreamClass *)0x0) {
          *(undefined *)&(context[(int)(pHVar2 + 1)].isa)->name = 0;
        }
        uVar4 = (uint)(paVar1[(int)pHVar2 * 8 + 4] ==
                      (anon_subr_void_HTStream_ptr_char_for_put_character)0x4);
        if (WWW_TraceFlag == '\0') {
          current_is_class = uVar4;
          return;
        }
        current_is_class = uVar4;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SGML: found attribute %s, %d\n",s,uVar4);
        return;
      }
      if (local_40 < 0) {
        low = (int)&pHVar2->name + 1;
        pHVar2 = (HTStreamClass *)high;
      }
    }
    if (WWW_TraceFlag != '\0') {
      if ((context[4].isa)->name == (char *)0x0) {
        local_2c = "";
      }
      else {
        local_2c = (context[4].isa)->name;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: Unknown attribute %s for tag %s\n",s,local_2c);
    }
    context[8].isa = (HTStreamClass *)0xffffffff;
  }
  return;
}



void handle_attribute_value(HTStream *context,char *s)

{
  FILE *__stream;
  
  if (context[8].isa == (HTStreamClass *)0xffffffff) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: Attribute value %s ***ignored\n",s);
    }
  }
  else {
    HTSACopy_extra((char **)(context + (int)(context[8].isa + 1)),s);
    if (current_is_class == 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SGML: attribute value is \'%s\'\n",s);
      }
    }
    else {
      strncpy(class_string,s,0x100);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SGML: class is \'%s\'\n",s);
      }
    }
  }
  context[8].isa = (HTStreamClass *)0xffffffff;
  return;
}



BOOLEAN put_special_unicodes(HTStream *context,UCode_t code)

{
  BOOLEAN local_5;
  
  if (*(char *)((int)&context[7].isa + 3) == '\0') {
    if (code == 0xa0) {
      if (psrc_view == '\0') {
        (*(context[2].isa)->put_character)((HTStream *)context[3].isa,'\x01');
      }
    }
    else {
      if (code == 0xad) {
        if (psrc_view == '\0') {
          (*(context[2].isa)->put_character)((HTStream *)context[3].isa,'\a');
        }
      }
      else {
        if ((code == 0x2002) || (code == 0x2009)) {
          if (psrc_view == '\0') {
            (*(context[2].isa)->put_character)((HTStream *)context[3].isa,'\x02');
          }
        }
        else {
          if (code != 0x2003) {
            return '\0';
          }
          if (psrc_view == '\0') {
            (*(context[2].isa)->put_character)((HTStream *)context[3].isa,'\x02');
          }
        }
      }
    }
    local_5 = '\x01';
  }
  else {
    local_5 = '\0';
  }
  return local_5;
}



void put_pretty_entity(HTStream *context,int term)

{
  HTMLSRC_apply_markup(context,HTL_entity,'\x01');
  (*(context[2].isa)->put_character)((HTStream *)context[3].isa,'&');
  (*(context[2].isa)->put_string)((HTStream *)context[3].isa,entity_string);
  if (term != 0) {
    (*(context[2].isa)->put_character)((HTStream *)context[3].isa,(char)term);
  }
  HTMLSRC_apply_markup(context,HTL_entity,'\0');
  return;
}



void put_pretty_number(HTStream *context)

{
  char *local_8;
  
  HTMLSRC_apply_markup(context,HTL_entity,'\x01');
  if (*(char *)((int)&context[0x3d].isa + 2) == '\0') {
    local_8 = "&#";
  }
  else {
    local_8 = "&#x";
  }
  (*(context[2].isa)->put_string)((HTStream *)context[3].isa,local_8);
  (*(context[2].isa)->put_string)((HTStream *)context[3].isa,entity_string);
  (*(context[2].isa)->put_character)((HTStream *)context[3].isa,';');
  HTMLSRC_apply_markup(context,HTL_entity,'\0');
  return;
}



void handle_entity(HTStream *context,char term)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *name;
  BOOLEAN BVar1;
  char cVar2;
  UCode_t code_00;
  uint uVar3;
  int iVar4;
  FILE *__stream;
  bool local_19;
  char *s;
  long uck;
  UCode_t code;
  
  uck = -1;
  name = (context[9].isa)->put_character;
  FoundEntity = '\0';
  code_00 = HTMLGetEntityUCValue((char *)name);
  if (code_00 != 0) {
    BVar1 = put_special_unicodes(context,code_00);
    if (BVar1 != '\0') {
      if (psrc_view != '\0') {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    uck = UCTransUniChar(code_00,(int)context[0x42].isa);
    if (((0x1f < uck) && (uck < 0x100)) &&
       ((uck < 0x7f || (LYlowest_eightbit[(int)context[0x42].isa] <= uck)))) {
      if (psrc_view == '\0') {
        (*(context[2].isa)->put_character)((HTStream *)context[3].isa,(char)uck);
      }
      else {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    if ((uck == -4) ||
       (((*(char *)((int)&context[0x4a].isa + 2) != '\0' && (0 < uck)) && (uck < 0x20)))) {
      uVar3 = UCTransUniCharStr(replace_buf,0x3c,code_00,(int)context[0x42].isa,0);
      uck = -((int)~uVar3 >> 0x1f);
      if (uck != 0) {
        if (psrc_view == '\0') {
          (*(context[2].isa)->put_string)((HTStream *)context[3].isa,replace_buf);
        }
        else {
          put_pretty_entity(context,(int)term);
        }
        FoundEntity = '\x01';
        return;
      }
    }
    if (*(char *)((int)&context[0x48].isa + 3) != '\0') {
      if (psrc_view == '\0') {
        cVar2 = UCPutUtf8_charstring
                          ((HTStream *)context[3].isa,(putc_func_t *)(context[2].isa)->put_character
                           ,code_00);
      }
      else {
        cVar2 = UCPutUtf8_charstring((HTStream *)context[3].isa,fake_put_character,code_00);
      }
      local_19 = cVar2 != '\0';
      if (local_19) {
        if (psrc_view != '\0') {
          put_pretty_entity(context,(int)term);
        }
        FoundEntity = '\x01';
        return;
      }
    }
    if ((0x1f < code_00) && (code_00 < 0x7f)) {
      if (psrc_view == '\0') {
        (*(context[2].isa)->put_character)((HTStream *)context[3].isa,(char)code_00);
      }
      else {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    iVar4 = strcmp((char *)name,"zwnj");
    if ((iVar4 == 0) || (iVar4 = strcmp((char *)name,"zwj"), iVar4 == 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"handle_entity: Ignoring \'%s\'.\n",name);
      }
      if (psrc_view != '\0') {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    iVar4 = strcmp((char *)name,"lrm");
    if ((iVar4 == 0) || (iVar4 = strcmp((char *)name,"rlm"), iVar4 == 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"handle_entity: Ignoring \'%s\'.\n",name);
      }
      if (psrc_view != '\0') {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
  }
  if (psrc_view != '\0') {
    HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML: Unknown entity \'%s\' %ld %ld\n",name,code_00,uck);
  }
  (*(context[2].isa)->put_character)((HTStream *)context[3].isa,'&');
  (*(context[2].isa)->put_string)((HTStream *)context[3].isa,(char *)name);
  if (term != '\0') {
    (*(context[2].isa)->put_character)((HTStream *)context[3].isa,term);
  }
  if (psrc_view != '\0') {
    HTMLSRC_apply_markup(context,HTL_badseq,'\0');
  }
  return;
}



void handle_comment(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *__s1;
  BOOLEAN BVar1;
  FILE *__stream;
  int iVar2;
  char *s;
  
  __s1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Comment:\n<%s>\n",__s1);
  }
  if (((context[0x52].isa == (HTStreamClass *)0x0) &&
      (iVar2 = strncmp((char *)__s1,"!--#",4), iVar2 == 0)) &&
     (BVar1 = LYCheckForCSI((HTParentAnchor *)context[0x3e].isa,(char **)(context + 0x51)),
     BVar1 == '\x01')) {
    LYDoCSI((char *)context[0x51].isa,(char *)__s1,(char **)(context + 0x52));
    return;
  }
  LYCommentHacks((HTParentAnchor *)context[0x3e].isa,(char *)(context[9].isa)->put_character);
  return;
}



void handle_identifier(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  FILE *__stream;
  char *s;
  
  paVar1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Identifier:\n<%s>\n",paVar1);
  }
  return;
}



void handle_doctype(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *__haystack;
  FILE *__stream;
  char *pcVar1;
  char *s;
  
  __haystack = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Doctype:\n<%s>\n",__haystack);
  }
  pcVar1 = strstr((char *)__haystack,"DTD XHTML ");
  if (pcVar1 != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...processing extended HTML\n");
    }
    *(undefined *)&context[7].isa = 1;
  }
  return;
}



void handle_marked(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  FILE *__stream;
  int iVar2;
  char *s;
  
  paVar1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Marked Section:\n<%s>\n",paVar1);
  }
  iVar2 = strncmp((char *)(context[9].isa)->put_character,"![INCLUDE[",10);
  if (iVar2 == 0) {
    (context[9].isa)->put_character[(int)((context[9].isa)->name + -3)] =
         (anon_subr_void_HTStream_ptr_char_for_put_character)0x0;
    HTSACat((char **)(context + 0x4e),(char *)((context[9].isa)->put_character + 10));
  }
  else {
    iVar2 = strncmp((char *)(context[9].isa)->put_character,"![CDATA[",8);
    if (iVar2 == 0) {
      (*(context[2].isa)->put_block)
                ((HTStream *)context[3].isa,(char *)((context[9].isa)->put_character + 8),
                 (int)((context[9].isa)->name + -0xb));
    }
  }
  return;
}



void handle_processing_instruction(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *__s1;
  FILE *__stream;
  int iVar1;
  char *pcVar2;
  char *t;
  int flag;
  char *s;
  
  __s1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Processing instruction:\n<%s>\n",__s1);
  }
  iVar1 = strncmp((char *)__s1,"?xml ",5);
  if (iVar1 == 0) {
    flag = (int)*(char *)((int)&context[0x48].isa + 2);
    *(undefined *)((int)&context[7].isa + 1) = 1;
    if (flag == 0) {
      pcVar2 = strstr((char *)__s1,"encoding=");
      if (pcVar2 != (char *)0x0) {
        t = pcVar2 + 9;
        if (*t == '\"') {
          t = pcVar2 + 10;
        }
        iVar1 = strncmp(t,"utf-8",5);
        flag = ZEXT14(iVar1 == 0);
      }
      if (flag != 0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"...Use UTF-8 for XML\n");
        }
        *(undefined *)((int)&context[0x48].isa + 2) = 1;
      }
    }
  }
  return;
}



void handle_sgmlent(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  FILE *__stream;
  char *s;
  
  paVar1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Entity Declaration:\n<%s>\n",paVar1);
  }
  return;
}



void handle_sgmlele(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  FILE *__stream;
  char *s;
  
  paVar1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Element Declaration:\n<%s>\n",paVar1);
  }
  return;
}



void handle_sgmlatt(HTStream *context)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  FILE *__stream;
  char *s;
  
  paVar1 = (context[9].isa)->put_character;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Attribute Declaration:\n<%s>\n",paVar1);
  }
  return;
}



BOOLEAN element_valid_within(HTTag *new_tag,HTTag *stacked_tag,BOOLEAN direct)

{
  uint uVar1;
  BOOLEAN local_29;
  uint local_24;
  BOOLEAN local_20;
  BOOLEAN local_1c;
  TagClass usecontained;
  TagClass usecontains;
  
  if ((stacked_tag == (HTTag *)0x0) || (new_tag == (HTTag *)0x0)) {
    local_29 = '\x01';
  }
  else {
    if (direct == '\0') {
      uVar1 = stacked_tag->icontains;
      local_24 = new_tag->icontained;
    }
    else {
      uVar1 = stacked_tag->contains;
      local_24 = new_tag->contained;
    }
    if (new_tag == stacked_tag) {
      if (((uVar1 & 0x80000) == 0) || ((local_24 & 0x80000) == 0)) {
        local_20 = '\0';
      }
      else {
        local_20 = '\x01';
      }
      local_29 = local_20;
    }
    else {
      if (((new_tag->tagclass & uVar1) == 0) || ((stacked_tag->tagclass & local_24) == 0)) {
        local_1c = '\0';
      }
      else {
        local_1c = '\x01';
      }
      local_29 = local_1c;
    }
  }
  return local_29;
}



canclose_t can_close(HTTag *new_tag,HTTag *stacked_tag)

{
  canclose_t local_8;
  
  if (stacked_tag == (HTTag *)0x0) {
    local_8 = close_NO;
  }
  else {
    if ((stacked_tag->flags & 1U) == 0) {
      if (new_tag == stacked_tag) {
        local_8 = (canclose_t)((new_tag->canclose & 0x80000U) != 0);
      }
      else {
        local_8 = (canclose_t)((new_tag->canclose & stacked_tag->tagclass) != 0);
      }
    }
    else {
      local_8 = close_valid;
    }
  }
  return local_8;
}



void do_close_stacked(HTStream *context)

{
  HTStreamClass *e_00;
  int iVar1;
  byte local_19;
  HTMLElement e;
  HTElement *stacked;
  
  e_00 = context[0xc].isa;
  if (e_00 != (HTStreamClass *)0x0) {
    if ((*(char *)((int)&context[7].isa + 2) != '\0') &&
       (iVar1 = strcasecomp(((HTTag *)e_00->_free)->name,"SELECT"), iVar1 == 0)) {
      *(undefined *)((int)&context[7].isa + 2) = 0;
    }
    if (psrc_view == '\0') {
      (*context[2].isa[1]._free)((HTStream *)context[3].isa);
    }
    context[0xc].isa = (HTStreamClass *)e_00->name;
    pool_free((HTElement *)e_00);
    if (context[0xc].isa == (HTStreamClass *)0x0) {
      local_19 = 0;
    }
    else {
      local_19 = (byte)*(undefined4 *)((context[0xc].isa)->_free + 0x34) & 0x40;
    }
    *(byte *)((int)&context[7].isa + 3) = local_19;
  }
  return;
}



int is_on_stack(HTStream *context,HTTag *old_tag)

{
  int local_1c;
  int i;
  HTElement *stacked;
  
  stacked = (HTElement *)context[0xc].isa;
  i = 1;
  while( true ) {
    if (stacked == (HTElement *)0x0) {
      return 0;
    }
    if (stacked->tag == old_tag) break;
    if ((uint)((int)old_tag + (-0x1148 - (int)(context[1].isa)->name)) < 0x38) {
      local_1c = 0x19d0;
    }
    else {
      local_1c = ((int)((int)old_tag - (int)(context[1].isa)->name) >> 3) * 8;
    }
    if (stacked->tag == (HTTag *)((context[1].isa)->name + local_1c)) {
      return i;
    }
    stacked = (HTElement *)stacked->next;
    i = i + 1;
  }
  return i;
}



void end_element(HTStream *context,HTTag *old_tag)

{
  char *pcVar1;
  char *pcVar2;
  undefined4 uVar3;
  HTStreamClass *e_00;
  char *pcVar4;
  bool bVar5;
  BOOLEAN BVar6;
  FILE *__stream;
  int iVar7;
  char *local_60;
  undefined *local_54;
  HTTag *local_50;
  int local_48;
  int local_44;
  int local_38;
  byte local_31;
  HTTag *t;
  HTElement *N;
  HTMLElement e;
  int status;
  int stackpos;
  canclose_t canclose_check;
  BOOLEAN extra_action_taken;
  
  bVar5 = false;
  canclose_check = close_valid;
  stackpos = is_on_stack(context,old_tag);
  if (Old_DTD == 0) {
    while (((canclose_check != close_NO && (context[0xc].isa != (HTStreamClass *)0x0)) &&
           ((1 < stackpos || ((!bVar5 && (stackpos == 0))))))) {
      if ((stackpos == 0) &&
         (((old_tag->flags & 2U) != 0 &&
          (BVar6 = element_valid_within(old_tag,(HTTag *)(context[0xc].isa)->_free,'\x01'),
          BVar6 != '\0')))) {
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pcVar1 = old_tag->name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SGML: </%s> ignored\n",pcVar1);
        return;
      }
      canclose_check = can_close(old_tag,(HTTag *)(context[0xc].isa)->_free);
      if (canclose_check != close_NO) {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = old_tag->name;
          if (canclose_check == close_valid) {
            local_60 = "supplied,";
          }
          else {
            local_60 = "***forced by";
          }
          uVar3 = *(undefined4 *)(context[0xc].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: End </%s> \t<- %s end </%s>\n",uVar3,local_60,pcVar1);
        }
        do_close_stacked(context);
        bVar5 = true;
        stackpos = is_on_stack(context,old_tag);
      }
    }
    if ((stackpos == 0) && (old_tag->contents != SGML_EMPTY)) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = old_tag->name;
      pcVar2 = old_tag->name;
      if (context[0xc].isa == (HTStreamClass *)0x0) {
        local_54 = &DAT_08182d6a;
      }
      else {
        local_54 = *(undefined **)(context[0xc].isa)->_free;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: Still open %s, ***no open %s for </%s>\n",local_54,pcVar2,
              pcVar1);
      return;
    }
    if (1 < stackpos) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = old_tag->name;
      uVar3 = *(undefined4 *)(context[0xc].isa)->_free;
      pcVar2 = old_tag->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",pcVar2,uVar3,
              pcVar1);
      return;
    }
  }
  if (*(char *)((int)&context[7].isa + 2) != '\0') {
    iVar7 = strcasecomp(old_tag->name,"SELECT");
    if (iVar7 != 0) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = old_tag->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: ***Ignoring end tag </%s> in SELECT block.\n",pcVar1);
      return;
    }
    *(undefined *)((int)&context[7].isa + 2) = 0;
  }
  if (WWW_TraceFlag != '\0') {
    pcVar1 = old_tag->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML: End </%s>\n",pcVar1);
  }
  if (old_tag->contents == SGML_EMPTY) {
    if (WWW_TraceFlag != '\0') {
      pcVar1 = old_tag->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: ***Illegal end tag </%s> found.\n",pcVar1);
    }
  }
  else {
    if (context[0xc].isa == (HTStreamClass *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = old_tag->name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"SGML: Extra end tag </%s> found and ignored.\n",pcVar1);
      }
    }
    else {
      status = 0;
      e_00 = context[0xc].isa;
      if ((HTTag *)e_00->_free == old_tag) {
        local_50 = (HTTag *)e_00->_free;
      }
      else {
        if ((int)((int)e_00->_free - (int)(context[1].isa)->name) < 0x19d0) {
          local_48 = ((int)((int)e_00->_free - (int)(context[1].isa)->name) >> 3) * 8;
        }
        else {
          local_48 = 0x1148;
        }
        local_50 = (HTTag *)((context[1].isa)->name + local_48);
      }
      if (old_tag != local_50) {
        if ((context[0xc].isa)->name == (char *)0x0) {
          if (WWW_TraceFlag == '\0') {
            return;
          }
          pcVar1 = old_tag->name;
          pcVar2 = local_50->name;
          pcVar4 = old_tag->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
                  pcVar4,pcVar2,pcVar1);
          return;
        }
        if (WWW_TraceFlag != '\0') {
          pcVar1 = local_50->name;
          pcVar2 = local_50->name;
          pcVar4 = old_tag->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
                  pcVar4,pcVar2,pcVar1);
        }
      }
      if ((int)((int)local_50 - (int)(context[1].isa)->name) < 0x19d0) {
        local_44 = ((int)((int)local_50 - (int)(context[1].isa)->name) >> 3) * -0x49249249;
      }
      else {
        local_44 = 0x4f;
      }
      if ((WWW_TraceFlag != '\0') && (((byte)WWW_TraceMask & 1) == 1)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"tagnum(%p) = %d\n",local_50,local_44);
      }
      if (psrc_view == '\0') {
        status = (*context[2].isa[1]._free)((HTStream *)context[3].isa);
      }
      if (status == 700) {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = local_50->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: Restart <%s>\n",pcVar1);
        }
        (*(code *)context[2].isa[1].name)
                  (context[3].isa,local_44,0,0,context[0x4b].isa,context + 0x4e);
      }
      else {
        if (status == 0x2bd) {
          if (WWW_TraceFlag != '\0') {
            pcVar1 = local_50->name;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"SGML: Continue with other content model for <%s>\n",pcVar1);
          }
          if (local_44 == 0x4f) {
            local_38 = 0x19d0;
          }
          else {
            local_38 = local_44 * 0x38;
          }
          *(char **)&(context[0xc].isa)->_free = (context[1].isa)->name + local_38;
        }
        else {
          context[0xc].isa = (HTStreamClass *)e_00->name;
          pool_free((HTElement *)e_00);
        }
      }
      if (context[0xc].isa == (HTStreamClass *)0x0) {
        local_31 = 0;
      }
      else {
        local_31 = (byte)*(undefined4 *)((context[0xc].isa)->_free + 0x34) & 0x40;
      }
      *(byte *)((int)&context[7].isa + 3) = local_31;
    }
  }
  return;
}



void start_element(HTStream *context)

{
  char *pcVar1;
  undefined4 uVar2;
  char *pcVar3;
  bool bVar4;
  BOOLEAN BVar5;
  uint uVar6;
  FILE *__stream;
  ushort **ppuVar7;
  int iVar8;
  HTTag *old_tag;
  HTStreamClass *pHVar9;
  bool bVar10;
  char *local_54;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  int local_34;
  HTElement *N;
  int i;
  canclose_t canclose_check;
  HTMLElement e;
  HTTag *new_tag;
  int status;
  BOOLEAN has_attributes;
  BOOLEAN extra_action_taken;
  BOOLEAN direct_container;
  BOOLEAN valid;
  BOOLEAN ok;
  
  new_tag = (HTTag *)context[4].isa;
  uVar6 = ((int)((int)new_tag - (int)(context[1].isa)->name) >> 3) * -0x49249249;
  bVar4 = false;
  valid = '\x01';
  direct_container = '\x01';
  bVar10 = false;
  canclose_check = close_valid;
  if (Old_DTD == 0) {
    while ((context[0xc].isa != (HTStreamClass *)0x0 &&
           (((canclose_check == close_valid ||
             ((canclose_check == close_error && ((HTTag *)(context[0xc].isa)->_free == new_tag))))
            && (valid = element_valid_within
                                  (new_tag,(HTTag *)(context[0xc].isa)->_free,direct_container),
               valid == '\0'))))) {
      canclose_check = can_close(new_tag,(HTTag *)(context[0xc].isa)->_free);
      if (canclose_check == close_NO) {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = new_tag->name;
          uVar2 = *(undefined4 *)(context[0xc].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: Still open %s \t<- ***invalid start <%s>\n",uVar2,pcVar1);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = new_tag->name;
          if (canclose_check == close_valid) {
            local_54 = "supplied,";
          }
          else {
            local_54 = "***forced by";
          }
          uVar2 = *(undefined4 *)(context[0xc].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: End </%s> \t<- %s start <%s>\n",uVar2,local_54,pcVar1);
        }
        do_close_stacked(context);
        bVar10 = true;
        if (canclose_check == close_error) {
          direct_container = '\0';
        }
      }
    }
    if ((((context[0xc].isa != (HTStreamClass *)0x0) && (valid == '\0')) &&
        ((*(uint *)((context[0xc].isa)->_free + 0x34) & 8) != 0)) &&
       (valid = element_valid_within(new_tag,(HTTag *)(context[0xc].isa)->_free,direct_container),
       valid == '\0')) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = new_tag->name;
      uVar2 = *(undefined4 *)(context[0xc].isa)->_free;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: Still open %s \t<- ***ignoring start <%s>\n",uVar2,pcVar1);
      return;
    }
    if (((context[0xc].isa != (HTStreamClass *)0x0) && (!bVar10)) &&
       ((canclose_check == close_NO && ((valid == '\0' && ((new_tag->flags & 4U) != 0)))))) {
      has_attributes = '\0';
      i = 0;
      while ((i < new_tag->number_of_attributes && (has_attributes == '\0'))) {
        has_attributes = *(BOOLEAN *)((int)&context[0xe].isa + i + 1);
        i = i + 1;
      }
      if (has_attributes == '\0') {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = new_tag->name;
          pcVar3 = new_tag->name;
          uVar2 = *(undefined4 *)(context[0xc].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
                  uVar2,pcVar3,pcVar1);
        }
        end_element(context,new_tag);
        return;
      }
    }
    if ((((context[0xc].isa != (HTStreamClass *)0x0) && (canclose_check == close_error)) &&
        (BVar5 = element_valid_within(new_tag,(HTTag *)(context[0xc].isa)->_free,direct_container),
        BVar5 == '\0')) && (WWW_TraceFlag != '\0')) {
      pcVar1 = new_tag->name;
      uVar2 = *(undefined4 *)(context[0xc].isa)->_free;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SGML: Still open %s \t<- ***invalid start <%s>\n",uVar2,pcVar1);
    }
  }
  if (*(char *)((int)&context[7].isa + 2) == '\0') {
    ppuVar7 = __ctype_b_loc();
    if (((*ppuVar7)[(byte)*new_tag->name] & 0x200) == 0) {
      local_4c = (uint)(byte)*new_tag->name;
    }
    else {
      local_4c = toupper((uint)(byte)*new_tag->name);
    }
    ppuVar7 = __ctype_b_loc();
    if (((*ppuVar7)[0x53] & 0x200) == 0) {
      local_48 = 0x53;
    }
    else {
      local_48 = toupper(0x53);
    }
    if (local_4c == local_48) {
      iVar8 = strcasecomp(new_tag->name,"SELECT");
      bVar10 = iVar8 == 0;
    }
    else {
      ppuVar7 = __ctype_b_loc();
      if (((*ppuVar7)[(byte)*new_tag->name] & 0x200) == 0) {
        local_44 = (uint)(byte)*new_tag->name;
      }
      else {
        local_44 = toupper((uint)(byte)*new_tag->name);
      }
      ppuVar7 = __ctype_b_loc();
      if (((*ppuVar7)[0x53] & 0x200) == 0) {
        local_40 = 0x53;
      }
      else {
        local_40 = toupper(0x53);
      }
      bVar10 = local_44 == local_40;
    }
    if (bVar10) {
      *(undefined *)((int)&context[7].isa + 2) = 1;
    }
    goto LAB_0811998c;
  }
  iVar8 = strcasecomp(new_tag->name,"OPTION");
  if (iVar8 == 0) goto LAB_0811998c;
  if (uVar6 == 0x3c) {
LAB_081198fc:
    bVar4 = true;
  }
  else {
    if (uVar6 < 0x3d) {
      if (((uVar6 != 0x28) && (uVar6 != 0x2c)) && (uVar6 != 0x15)) goto LAB_08119900;
      goto LAB_081198fc;
    }
    if (uVar6 == 0x5b) goto LAB_081198fc;
    if (uVar6 < 0x5c) {
      if (uVar6 - 0x41 < 2) goto LAB_081198fc;
    }
    else {
      if (uVar6 == 0x69) goto LAB_081198fc;
    }
  }
LAB_08119900:
  if (!bVar4) {
    if (WWW_TraceFlag == '\0') {
      return;
    }
    pcVar1 = new_tag->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML: ***Ignoring start tag <%s> in SELECT block.\n",pcVar1);
    return;
  }
  if (WWW_TraceFlag != '\0') {
    pcVar1 = new_tag->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML: ***Faking SELECT end tag before <%s> start tag.\n",pcVar1);
  }
  old_tag = SGMLFindTag((SGML_dtd *)context[1].isa,"SELECT");
  end_element(context,old_tag);
LAB_0811998c:
  if (WWW_TraceFlag != '\0') {
    pcVar1 = new_tag->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML: Start <%s>\n",pcVar1);
  }
  iVar8 = (*(code *)context[2].isa[1].name)
                    (context[3].isa,
                     ((int)((int)new_tag - (int)(context[1].isa)->name) >> 3) * -0x49249249,
                     (int)&context[0xe].isa + 1,context + 0x18,context[0x4b].isa,context + 0x4e);
  if (iVar8 == 0x2bd) {
    if ((HTTag *)((int)new_tag - (int)(context[1].isa)->name) + -0x4f < (HTTag *)0x38) {
      local_34 = 0x19d0;
    }
    else {
      local_34 = ((int)((int)new_tag - (int)(context[1].isa)->name) >> 3) * 8;
    }
    new_tag = (HTTag *)((context[1].isa)->name + local_34);
  }
  if (new_tag->contents == SGML_EMPTY) {
    if (uVar6 == 0x4b) {
      change_chartrans_handling(context);
    }
  }
  else {
    pHVar9 = (HTStreamClass *)pool_alloc();
    if (pHVar9 == (HTStreamClass *)0x0) {
      outofmem("../../../WWW/Library/Implementation/SGML.c","start_element");
    }
    *(HTStreamClass **)&pHVar9->name = context[0xc].isa;
    *(HTTag **)&pHVar9->_free = new_tag;
    context[0xc].isa = pHVar9;
    *(byte *)((int)&context[7].isa + 3) = (byte)new_tag->flags & 0x40;
  }
  return;
}



HTTag * SGMLFindTag(SGML_dtd *dtd,char *s)

{
  HTTag *last [64];
  HTTag **ppHVar1;
  int iVar2;
  ushort **ppuVar3;
  HTTag *local_40;
  int local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  HTTag **res;
  int diff;
  int i;
  int low;
  int high;
  
  ppHVar1 = (HTTag **)&ram0x081b40a0 + ((uint)(byte)*s & 0x3f);
  if (*ppHVar1 != (HTTag *)0x0) {
    if ((*ppHVar1)->name == (char *)0x0) {
      return (HTTag *)0x0;
    }
    iVar2 = strcasecomp((*ppHVar1)->name,s);
    if (iVar2 == 0) {
      return *ppHVar1;
    }
  }
  low = 0;
  iVar2 = dtd->number_of_tags;
  while( true ) {
    high = iVar2;
    if (high <= low) {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*s] & 0x400) == 0) {
        local_40 = (HTTag *)0x0;
      }
      else {
        local_40 = &HTTag_unrecognized;
      }
      return local_40;
    }
    iVar2 = (high - low) / 2 + low;
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[(byte)*dtd->tags[iVar2].name] & 0x200) == 0) {
      local_38 = (uint)(byte)*dtd->tags[iVar2].name;
    }
    else {
      local_38 = toupper((uint)(byte)*dtd->tags[iVar2].name);
    }
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[(byte)*s] & 0x200) == 0) {
      local_34 = (uint)(byte)*s;
    }
    else {
      local_34 = toupper((uint)(byte)*s);
    }
    if (local_38 == local_34) {
      local_3c = strcasecomp(dtd->tags[iVar2].name,s);
    }
    else {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*dtd->tags[iVar2].name] & 0x200) == 0) {
        local_30 = (uint)(byte)*dtd->tags[iVar2].name;
      }
      else {
        local_30 = toupper((uint)(byte)*dtd->tags[iVar2].name);
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*s] & 0x200) == 0) {
        local_2c = (uint)(byte)*s;
      }
      else {
        local_2c = toupper((uint)(byte)*s);
      }
      local_3c = local_30 - local_2c;
    }
    if (local_3c == 0) break;
    if (local_3c < 0) {
      low = iVar2 + 1;
      iVar2 = high;
    }
  }
  *ppHVar1 = dtd->tags + iVar2;
  return *ppHVar1;
}



void SGML_free(HTStream *context)

{
  HTStreamClass *e;
  HTTag *t;
  HTElement *cur;
  int i;
  
  if (context[0x4c].isa != (HTStreamClass *)0x0) {
    free(context[0x4c].isa);
    context[0x4c].isa = (HTStreamClass *)0x0;
  }
  if (context[0x51].isa != (HTStreamClass *)0x0) {
    free(context[0x51].isa);
    context[0x51].isa = (HTStreamClass *)0x0;
  }
  if (context[0x52].isa != (HTStreamClass *)0x0) {
    free(context[0x52].isa);
    context[0x52].isa = (HTStreamClass *)0x0;
  }
  if (context[0x4e].isa != (HTStreamClass *)0x0) {
    free(context[0x4e].isa);
    context[0x4e].isa = (HTStreamClass *)0x0;
  }
  if (context[0x4f].isa != (HTStreamClass *)0x0) {
    free(context[0x4f].isa);
    context[0x4f].isa = (HTStreamClass *)0x0;
  }
  while (context[0xc].isa != (HTStreamClass *)0x0) {
    e = context[0xc].isa;
    context[0xc].isa = (HTStreamClass *)e->name;
    pool_free((HTElement *)e);
    if (psrc_view == '\0') {
      (*context[2].isa[1]._free)((HTStream *)context[3].isa);
    }
    if (context[0x4e].isa != (HTStreamClass *)0x0) {
      free(context[0x4e].isa);
      context[0x4e].isa = (HTStreamClass *)0x0;
    }
  }
  (*(context[2].isa)->_free)((HTStream *)context[3].isa);
  HTChunkFree((HTChunk *)context[9].isa);
  i = 0;
  while (i < 0x24) {
    if (context[i + 0x18].isa != (HTStreamClass *)0x0) {
      HTSAFree_extra((char *)context[i + 0x18].isa);
      context[i + 0x18].isa = (HTStreamClass *)0x0;
    }
    i = i + 1;
  }
  if (context != (HTStream *)0x0) {
    free(context);
  }
  sgml_in_psrc_was_initialized = '\0';
  return;
}



void SGML_abort(HTStream *context,HTError e)

{
  HTStreamClass *e_00;
  HTElement *cur;
  int i;
  
  (*(context[2].isa)->_abort)((HTStream *)context[3].isa,e);
  if (context[0x4c].isa != (HTStreamClass *)0x0) {
    free(context[0x4c].isa);
    context[0x4c].isa = (HTStreamClass *)0x0;
  }
  if (context[0x4e].isa != (HTStreamClass *)0x0) {
    free(context[0x4e].isa);
    context[0x4e].isa = (HTStreamClass *)0x0;
  }
  if (context[0x4f].isa != (HTStreamClass *)0x0) {
    free(context[0x4f].isa);
    context[0x4f].isa = (HTStreamClass *)0x0;
  }
  if (context[0x51].isa != (HTStreamClass *)0x0) {
    free(context[0x51].isa);
    context[0x51].isa = (HTStreamClass *)0x0;
  }
  if (context[0x52].isa != (HTStreamClass *)0x0) {
    free(context[0x52].isa);
    context[0x52].isa = (HTStreamClass *)0x0;
  }
  while (context[0xc].isa != (HTStreamClass *)0x0) {
    e_00 = context[0xc].isa;
    context[0xc].isa = (HTStreamClass *)e_00->name;
    pool_free((HTElement *)e_00);
  }
  HTChunkFree((HTChunk *)context[9].isa);
  i = 0;
  while (i < 0x24) {
    if (context[i + 0x18].isa != (HTStreamClass *)0x0) {
      HTSAFree_extra((char *)context[i + 0x18].isa);
      context[i + 0x18].isa = (HTStreamClass *)0x0;
    }
    i = i + 1;
  }
  if (context != (HTStream *)0x0) {
    free(context);
  }
  sgml_in_psrc_was_initialized = '\0';
  return;
}



void transform_tag(HTStream *context,HTChunk *string)

{
  if ((*(char *)((int)&context[7].isa + 1) == '\0') && (tagname_transform != 1)) {
    if (tagname_transform == 0) {
      LYLowerCase(string->data);
    }
    else {
      LYUpperCase(string->data);
    }
  }
  return;
}



BOOLEAN ignore_when_empty(HTTag *tag)

{
  FILE *__stream;
  char *local_1c;
  undefined *local_18;
  BOOLEAN result;
  
  result = '\0';
  if ((((((LYPreparsedSource == '\0') && (LYxhtml_parsing != '\0')) && (tag->name != (char *)0x0))
       && (((tag->flags & 4U) == 0 && (tag->contents != SGML_EMPTY)))) && (tag->tagclass != 0x100))
     && ((tag->tagclass == 0x40 || ((tag->contains != 0 && (tag->icontains != 0)))))) {
    result = '\x01';
  }
  if (WWW_TraceFlag != '\0') {
    if (tag->name == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = tag->name;
    }
    if (result == '\0') {
      local_18 = &DAT_081830bf;
    }
    else {
      local_18 = &DAT_08182ae5;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Do%s ignore_when_empty:%s\n",local_18,local_1c);
  }
  return result;
}



void discard_empty(HTStream *context)

{
  HTTag empty_tag;
  FILE *__stream;
  char *local_8;
  
  if (WWW_TraceFlag != '\0') {
    if ((context[4].isa)->name == (char *)0x0) {
      local_8 = "";
    }
    else {
      local_8 = (context[4].isa)->name;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML discarding empty %s\n",local_8);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fflush((FILE *)__stream);
  }
  memset((HTTag *)&ram0x081b41a0,0,0x38);
  context[4].isa = (HTStreamClass *)0x81b41a0;
  (context[9].isa)->name = (char *)0x0;
  return;
}



BOOLEAN end_if_prettysrc(HTStream *context,HTChunk *string,char end_ch)

{
  BOOLEAN BVar1;
  BOOLEAN result;
  
  BVar1 = psrc_view;
  if (psrc_view != '\0') {
    if (*(char *)((int)&context[0x54].isa + 1) == '\0') {
      if (*(char *)&context[0x54].isa != '\0') {
        HTMLSRC_apply_markup(context,HTL_href,'\x01');
        HTStartAnchor((HTStructured *)context[3].isa,(char *)0x0,string->data);
      }
    }
    else {
      HTStartAnchor((HTStructured *)context[3].isa,string->data,(char *)0x0);
      (*context[2].isa[1]._free)((HTStream *)context[3].isa);
    }
    psrc_convert_string = '\x01';
    (*(context[2].isa)->put_string)((HTStream *)context[3].isa,string->data);
    if (*(char *)&context[0x54].isa != '\0') {
      (*context[2].isa[1]._free)((HTStream *)context[3].isa);
      HTMLSRC_apply_markup(context,HTL_href,'\0');
    }
    if (end_ch != '\0') {
      (*(context[2].isa)->put_character)((HTStream *)context[3].isa,end_ch);
    }
    HTMLSRC_apply_markup(context,HTL_attrval,'\0');
  }
  return BVar1;
}


/*
Unable to decompile 'SGML_character'
Cause: Pcode: XML comms: Invalid storage: Unsupported varnode size: -1
*/


void SGML_string(HTStream *context,char *str)

{
  char *p;
  
  p = str;
  while (*p != '\0') {
    SGML_character(context,*p);
    p = p + 1;
  }
  return;
}



void SGML_write(HTStream *context,char *str,int l)

{
  char *e;
  char *p;
  
  p = str;
  while (p < str + l) {
    SGML_character(context,*p);
    p = p + 1;
  }
  return;
}



HTStream * SGML_new(SGML_dtd *dtd,HTParentAnchor *anchor,HTStructured *target)

{
  HTStream *context_00;
  HTStreamClass *pHVar1;
  LYUCcharset *pLVar2;
  HTStream *context;
  
  context_00 = (HTStream *)calloc(1,0x154);
  if (context_00 == (HTStream *)0x0) {
    outofmem("../../../WWW/Library/Implementation/SGML.c","SGML_begin");
  }
  context_00->isa = (HTStreamClass *)0x8183914;
  pHVar1 = (HTStreamClass *)HTChunkCreate(0x80);
  context_00[9].isa = pHVar1;
  *(SGML_dtd **)&context_00[1].isa = dtd;
  *(HTStructured **)&context_00[3].isa = target;
  *(HTStructuredClass **)&context_00[2].isa = target->isa;
  context_00[6].isa = (HTStreamClass *)0x81b42a0;
  context_00[5].isa = (HTStreamClass *)0x0;
  context_00[4].isa = context_00[5].isa;
  context_00[0xd].isa = (HTStreamClass *)0x0;
  *(HTParentAnchor **)&context_00[0x3e].isa = anchor;
  context_00[0x47].isa = (HTStreamClass *)(context_00 + 0x45);
  UCTransParams_clear((UCTransParams *)(context_00 + 0x48));
  pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl(anchor,1);
  context_00[0x40].isa = pHVar1;
  if ((int)context_00[0x40].isa < 0) {
    HTAnchor_copyUCInfoStage(anchor,1,0,-1);
    pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl(anchor,1);
    context_00[0x40].isa = pHVar1;
  }
  pLVar2 = HTAnchor_getUCInfoStage(anchor,1);
  *(LYUCcharset **)&context_00[0x3f].isa = pLVar2;
  set_chartrans_handling(context_00,anchor,-1);
  context_00[0x4c].isa = (HTStreamClass *)0x0;
  context_00[0x4d].isa = (HTStreamClass *)0x0;
  context_00[0x4e].isa = (HTStreamClass *)0x0;
  context_00[0x4f].isa = (HTStreamClass *)0x0;
  context_00[0x50].isa = (HTStreamClass *)0x0;
  context_00[0x51].isa = (HTStreamClass *)0x0;
  context_00[0x52].isa = (HTStreamClass *)0x0;
  context_00[0x53].isa = (HTStreamClass *)0x0;
  if (psrc_view != '\0') {
    psrc_view = '\0';
    mark_htext_as_source = '\x01';
    SGML_string(context_00,"<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
    psrc_view = '\x01';
    psrc_convert_string = '\0';
    sgml_in_psrc_was_initialized = '\x01';
  }
  sgml_offset = 0;
  return context_00;
}



int SGML_offset(void)

{
  return psrc_view + sgml_offset;
}



void JISx0201TO0208_EUC(uchar IHI,uchar ILO,uchar *OHI,uchar *OLO)

{
  char *table [63];
  
  if (((IHI == -0x72) && (0xa0 < ILO)) && (ILO < 0xe0)) {
    *OHI = *((char **)&ram0x081a9ec0)[(uint)ILO - 0xa1];
    *OLO = *(uchar *)(*(int *)(((uint)ILO - 0xa1) * 4 + 0x81a9ec0) + 1);
  }
  else {
    *OHI = IHI;
    *OLO = ILO;
  }
  return;
}



int IS_SJIS_STR(uchar *str)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  int is_sjis;
  uchar *s;
  uchar ch;
  
  bVar2 = false;
  s = str;
  do {
    do {
      bVar1 = *s;
      s = s + 1;
      if (bVar1 == 0) {
        return 0;
      }
    } while (-1 < (char)bVar1);
    if (((*s < 0x40) || (*s == 0x7f)) || (0xfc < *s)) {
      bVar3 = false;
    }
    else {
      if ((bVar1 < 0x81) || (0x9f < bVar1)) {
        if ((bVar2) && ((0xdf < bVar1 && (bVar1 < 0xf0)))) {
          bVar3 = true;
        }
        else {
          bVar3 = false;
        }
      }
      else {
        bVar2 = true;
        bVar3 = true;
      }
    }
  } while (!bVar3);
  return 1;
}



uchar * SJIS_TO_JIS1(void)

{
  char cVar1;
  byte in_stack_00000004;
  byte in_stack_00000008;
  uchar *in_stack_0000000c;
  byte local_7;
  uchar local_6;
  char local_5;
  
  local_7 = in_stack_00000008;
  if (in_stack_00000004 < 0xa0) {
    local_5 = 'q';
  }
  else {
    local_5 = -0x4f;
  }
  cVar1 = (in_stack_00000004 - local_5) * '\x02';
  local_6 = cVar1 + '\x01';
  if ((char)in_stack_00000008 < '\0') {
    local_7 = in_stack_00000008 - 1;
  }
  if (local_7 < 0x9e) {
    local_7 = local_7 - 0x1f;
  }
  else {
    local_7 = local_7 + 0x83;
    local_6 = cVar1 + '\x02';
  }
  *in_stack_0000000c = local_6;
  in_stack_0000000c[1] = local_7;
  return in_stack_0000000c;
}



uchar * JIS_TO_SJIS1(void)

{
  char cVar1;
  byte in_stack_00000004;
  char in_stack_00000008;
  byte *in_stack_0000000c;
  byte local_6;
  byte local_5;
  
  if ((in_stack_00000004 & 1) == 0) {
    local_6 = in_stack_00000008 + 0x7d;
  }
  else {
    local_6 = in_stack_00000008 + 0x1f;
  }
  if (0x7e < local_6) {
    local_6 = local_6 + 1;
  }
  cVar1 = (char)((int)((uint)in_stack_00000004 - 0x21) >> 1);
  local_5 = cVar1 + 0x81;
  if (0x9f < local_5) {
    local_5 = cVar1 - 0x3f;
  }
  *in_stack_0000000c = local_5;
  in_stack_0000000c[1] = local_6;
  return in_stack_0000000c;
}



uchar * EUC_TO_SJIS1(uchar HI,uchar LO)

{
  uchar *in_stack_0000000c;
  uchar local_c [4];
  uchar local_8 [4];
  
  local_8[0] = HI;
  local_c[0] = LO;
  if (HI == -0x72) {
    JISx0201TO0208_EUC(-0x72,LO,local_8,local_c);
  }
  JIS_TO_SJIS1();
  return in_stack_0000000c;
}



void __regparm3 JISx0201TO0208_SJIS(uchar I,uchar *OHI,uchar *OLO)

{
  uchar in_stack_00000004;
  uchar *in_stack_00000008;
  uchar *in_stack_0000000c;
  uchar SJCODE [2];
  
  JISx0201TO0208_EUC(-0x72,in_stack_00000004,in_stack_00000008,in_stack_0000000c);
  JIS_TO_SJIS1();
  *in_stack_00000008 = SJCODE[0];
  *in_stack_0000000c = SJCODE[1];
  return;
}



uchar * SJIS_TO_EUC1(uchar HI,uchar LO,uchar *data)

{
  SJIS_TO_JIS1();
  *data = *data | 0x80;
  data[1] = data[1] | 0x80;
  return data;
}



uchar * SJIS_TO_EUC(uchar *src,uchar *dst)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  byte *local_10;
  byte *local_c;
  int local_8;
  
  local_8 = IS_SJIS_STR(src);
  local_10 = src;
  local_c = dst;
  do {
    while( true ) {
      bVar2 = *local_10;
      if (bVar2 == 0) {
        *local_c = 0;
        return dst;
      }
      bVar1 = local_10[1];
      if ((((TREAT_SJIS != 0) && (0x3f < bVar1)) && (bVar1 != 0x7f)) && (bVar1 < 0xfd)) break;
LAB_081212fc:
      *local_c = *local_10;
      local_c = local_c + 1;
      local_10 = local_10 + 1;
    }
    if ((bVar2 < 0x81) || (0x9f < bVar2)) {
      if ((local_8 == 0) || ((bVar2 < 0xe0 || (0xef < bVar2)))) {
        bVar3 = false;
      }
      else {
        bVar3 = true;
      }
      if (!bVar3) goto LAB_081212fc;
    }
    else {
      local_8 = 1;
    }
    SJIS_TO_JIS1();
    *local_c = *local_c | 0x80;
    local_c[1] = local_c[1] | 0x80;
    local_c = local_c + 2;
    local_10 = local_10 + 2;
  } while( true );
}



uchar * EUC_TO_SJIS(uchar *src,uchar *dst)

{
  uchar *local_c;
  uchar *local_8;
  
  local_c = src;
  local_8 = dst;
  while (*local_c != '\0') {
    if ((char)*local_c < '\0') {
      if ((local_c[1] == '\0') || (-1 < (char)local_c[1])) {
        local_c = local_c + 1;
      }
      else {
        JIS_TO_SJIS1();
        local_8 = local_8 + 2;
        local_c = local_c + 2;
      }
    }
    else {
      *local_8 = *local_c;
      local_8 = local_8 + 1;
      local_c = local_c + 1;
    }
  }
  *local_8 = '\0';
  return dst;
}



uchar * EUC_TO_JIS(uchar *src,uchar *dst,char *toK,char *toA)

{
  byte bVar1;
  byte *pbVar2;
  size_t sVar3;
  byte local_1e;
  byte *local_1c;
  byte *local_18;
  int is_JIS;
  
  local_1e = 0;
  local_1c = src;
  local_18 = dst;
  is_JIS = 0;
  pbVar2 = local_1c;
  while( true ) {
    local_1c = pbVar2;
    bVar1 = *local_1c;
    pbVar2 = local_1c + 1;
    if (bVar1 == 0) break;
    if ((char)bVar1 < '\0') {
      if (((((bVar1 < 0xa1) || (bVar1 == 0xff)) || (*pbVar2 < 0xa1)) || (*pbVar2 == 0xff)) &&
         (((bVar1 != 0x8e || (*pbVar2 < 0xa1)) || (0xdf < *pbVar2)))) {
        if ((bVar1 != 0xa0) || (is_JIS == 0)) {
          is_JIS = is_JIS + 1;
          *local_18 = bVar1;
          local_18 = local_18 + 1;
        }
      }
      else {
        if (local_1e == 0) {
          local_1e = 0xff;
          strcpy((char *)local_18,toK);
          sVar3 = strlen((char *)local_18);
          local_18 = local_18 + sVar3;
        }
        if ((char)*pbVar2 < '\0') {
          *local_18 = bVar1 & 0x7f;
          local_18[1] = *pbVar2 & 0x7f;
          local_18 = local_18 + 2;
          pbVar2 = local_1c + 2;
        }
      }
    }
    else {
      if (local_1e != 0) {
        local_1e = ~local_1e;
        strcpy((char *)local_18,toA);
        sVar3 = strlen((char *)local_18);
        local_18 = local_18 + sVar3;
      }
      *local_18 = bVar1;
      local_18 = local_18 + 1;
    }
  }
  if (local_1e != 0) {
    strcpy((char *)local_18,toA);
    sVar3 = strlen((char *)local_18);
    local_18 = local_18 + sVar3;
  }
  if (local_18 != (byte *)0x0) {
    *local_18 = 0;
  }
  return dst;
}



uchar * repairJIStoEUC(uchar *src,uchar **dstp)

{
  byte bVar1;
  byte bVar2;
  uchar *d;
  uchar *s;
  uchar ch2;
  uchar ch1;
  
  d = *dstp;
  s = src;
  while( true ) {
    bVar1 = *s;
    if ((bVar1 == 0) || (bVar2 = s[1], bVar2 == 0)) {
      return (uchar *)0x0;
    }
    s = s + 2;
    if ((bVar1 == 0x28) && ((bVar2 == 0x42 || (bVar2 == 0x4a)))) break;
    if ((((bVar1 < 0x21) || (0x7e < bVar1)) || (bVar2 < 0x21)) || (0x7e < bVar2)) {
      return (uchar *)0x0;
    }
    *d = bVar1 | 0x80;
    d[1] = bVar2 | 0x80;
    d = d + 2;
  }
  *dstp = d;
  return s;
}



uchar * TO_EUC(uchar *jis,uchar *euc)

{
  byte HI;
  byte *pbVar1;
  bool bVar2;
  int nje;
  byte *pbVar3;
  byte *local_28;
  byte local_21;
  int local_18;
  uchar *ts;
  int is_JIS;
  int n8bits;
  uchar *d;
  
  nje = nje + 1;
  n8bits = 0;
  local_28 = jis;
  d = euc;
  local_21 = 0;
  local_18 = IS_SJIS_STR(jis);
  is_JIS = 0;
  pbVar3 = local_28;
LAB_081218be:
  do {
    while( true ) {
      do {
        local_28 = pbVar3;
        HI = *local_28;
        pbVar1 = local_28 + 1;
        if (HI == 0) {
          *d = '\0';
          return euc;
        }
        pbVar3 = pbVar1;
      } while (((HI == 0x80) || ((HI == 0xa0 && (is_JIS != 0)))) ||
              ((HI == 0x24 &&
               ((((local_21 == 0 && (repair_JIS != 0)) && ((*pbVar1 == 0x42 || (*pbVar1 == 0x40))))
                && (pbVar3 = repairJIStoEUC(local_28 + 2,&d), pbVar3 != (byte *)0x0))))));
      if (HI == 0x1b) break;
LAB_08121756:
      if ((char)HI < '\0') {
        n8bits = n8bits + 1;
      }
      if (((*pbVar1 < 0x40) || (*pbVar1 == 0x7f)) || (0xfc < *pbVar1)) {
        bVar2 = false;
      }
      else {
        if ((HI < 0x81) || (0x9f < HI)) {
          if ((local_18 == 0) || ((HI < 0xe0 || (0xef < HI)))) {
            bVar2 = false;
          }
          else {
            bVar2 = true;
          }
        }
        else {
          local_18 = 1;
          bVar2 = true;
        }
      }
      if (bVar2) {
        SJIS_TO_EUC1(HI,*pbVar1,d);
        d = d + 2;
        is_JIS = is_JIS + 1;
        pbVar3 = local_28 + 2;
      }
      else {
        if (local_21 == 0) {
          if ((n8bits != 0) || ((pbVar3 = pbVar1, HI != 0xf && (HI != 0xe)))) {
            *d = HI;
            d = d + 1;
            pbVar3 = pbVar1;
          }
        }
        else {
          if ((HI < 0x21) || (0x7e < HI)) {
            *d = HI;
            d = d + 1;
            pbVar3 = pbVar1;
            if (HI == 10) {
              local_21 = 0;
            }
          }
          else {
            if ((((HI < 0x21) || (0x7e < HI)) || (*pbVar1 < 0x21)) || (0x7e < *pbVar1)) {
              *d = HI;
              d = d + 1;
              pbVar3 = pbVar1;
            }
            else {
              *d = local_21 | HI;
              d[1] = *pbVar1 | local_21;
              d = d + 2;
              pbVar3 = local_28 + 2;
            }
          }
        }
      }
    }
    if (*pbVar1 == 0x24) {
      if ((local_28[2] != 0x42) && (local_28[2] != 0x40)) {
        local_21 = 0;
        goto LAB_08121756;
      }
      local_21 = 0x80;
      is_JIS = is_JIS + 1;
      pbVar3 = local_28 + 3;
      goto LAB_081218be;
    }
    if (*pbVar1 != 0x28) {
      if (*pbVar1 == 0x2c) {
        local_21 = 0;
      }
      goto LAB_08121756;
    }
    local_21 = 0;
    if (((local_28[2] != 0x42) && (local_28[2] != 0x4a)) && (local_28[2] != 0x48))
    goto LAB_08121756;
    pbVar3 = local_28 + 3;
  } while( true );
}



int is_EUC_JP(uchar *euc)

{
  byte bVar1;
  byte bVar2;
  int ch2;
  int ch1;
  uchar *cp;
  
  cp = euc;
  do {
    bVar2 = *cp;
    if (bVar2 == 0) {
      return 1;
    }
    if ((bVar2 & 0x80) != 0) {
      bVar1 = cp[1];
      if ((bVar1 & 0x80) == 0) {
        return 0;
      }
      if (((((bVar2 & 0x7f) < 0x21) || ((bVar2 & 0x7f) == 0x7f)) || ((bVar1 & 0x7f) < 0x21)) ||
         ((bVar1 & 0x7f) == 0x7f)) {
        return 0;
      }
      cp = cp + 1;
    }
    cp = cp + 1;
  } while( true );
}



void TO_SJIS(uchar *arg,uchar *sjis)

{
  size_t sVar1;
  uchar *euc_00;
  int iVar2;
  uchar *euc;
  
  sVar1 = strlen((char *)arg);
  euc_00 = (uchar *)malloc(sVar1 + 1);
  if (euc_00 == (uchar *)0x0) {
    outofmem("../../../WWW/Library/Implementation/SGML.c","TO_SJIS");
  }
  TO_EUC(arg,euc_00);
  iVar2 = is_EUC_JP(euc_00);
  if (iVar2 == 0) {
    strcpy((char *)sjis,(char *)arg);
  }
  else {
    EUC_TO_SJIS(euc_00,sjis);
  }
  free(euc_00);
  return;
}



void TO_JIS(uchar *arg,uchar *jis)

{
  size_t sVar1;
  uchar *euc_00;
  uchar *euc;
  
  if (*arg == '\0') {
    *jis = '\0';
  }
  else {
    sVar1 = strlen((char *)arg);
    euc_00 = (uchar *)malloc(sVar1 + 1);
    if (euc_00 == (uchar *)0x0) {
      outofmem("../../../WWW/Library/Implementation/SGML.c","TO_JIS");
    }
    TO_EUC(arg,euc_00);
    is_EUC_JP(euc_00);
    EUC_TO_JIS(euc_00,jis,"\x1b$B","\x1b(B");
    free(euc_00);
  }
  return;
}



void HTSwitchDTD(int new_flag)

{
  FILE *__stream;
  char *local_8;
  
  if ((WWW_TraceFlag != '\0') && (WWW_TraceFlag != '\0')) {
    if (new_flag == 0) {
      local_8 = "tagsoup";
    }
    else {
      local_8 = "strict";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLDTD: Copying %s DTD element info of size %d, %d * %d\n",local_8,
            0x1a08,0x77,0x38);
  }
  if (new_flag == 0) {
    memcpy(tags,tags_table0,0x1a08);
  }
  else {
    memcpy(tags,tags_table1,0x1a08);
  }
  return;
}



void HTStartAnchor(HTStructured *obj,char *name,char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x19) {
    present[i] = '\0';
    i = i + 1;
  }
  if ((name != (char *)0x0) && (*name != '\0')) {
    present[12] = '\x01';
    value[12] = name;
  }
  if (href != (char *)0x0) {
    present[6] = '\x01';
    value[6] = href;
  }
  (*obj->isa->start_element)(obj,0,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTStartAnchor5(HTStructured *obj,char *name,char *href,char *linktype,int tag_charset)

{
  int iVar1;
  int in_GS_OFFSET;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x19) {
    present[i] = '\0';
    i = i + 1;
  }
  if ((name != (char *)0x0) && (*name != '\0')) {
    present[12] = '\x01';
    value[12] = name;
  }
  if ((href != (char *)0x0) && (*href != '\0')) {
    present[6] = '\x01';
    value[6] = href;
  }
  if ((linktype != (char *)0x0) && (*linktype != '\0')) {
    present[23] = '\x01';
    value[23] = linktype;
  }
  (*obj->isa->start_element)(obj,0,present,value,tag_charset,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTStartIsIndex(HTStructured *obj,char *prompt,char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *value [9];
  int i;
  BOOLEAN present [9];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 9) {
    present[i] = '\0';
    i = i + 1;
  }
  if ((prompt != (char *)0x0) && (*prompt != '\0')) {
    present[6] = '\x01';
    value[6] = prompt;
  }
  if (href != (char *)0x0) {
    present[3] = '\x01';
    value[3] = href;
  }
  (*obj->isa->start_element)(obj,0x3e,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTChunkInit(HTChunk *ch,int grow)

{
  ch->data = (char *)0x0;
  ch->growby = grow;
  ch->size = 0;
  ch->allocated = 0;
  return;
}



HTChunk * HTChunkCreate(int grow)

{
  HTChunk *ch_00;
  HTChunk *ch;
  
  ch_00 = (HTChunk *)calloc(1,0x18);
  if (ch_00 == (HTChunk *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","creation of chunk");
  }
  HTChunkInit(ch_00,grow);
  return ch_00;
}



HTChunk * HTChunkCreateMayFail(int grow,int failok)

{
  HTChunk *ch_00;
  HTChunk *ch;
  
  ch_00 = (HTChunk *)calloc(1,0x18);
  if (ch_00 == (HTChunk *)0x0) {
    if (failok != 0) {
      return (HTChunk *)0x0;
    }
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","creation of chunk");
  }
  HTChunkInit(ch_00,grow);
  ch_00->failok = failok;
  return ch_00;
}



HTChunk * HTChunkCreate2(int grow,size_t needed)

{
  int iVar1;
  HTChunk *ch_00;
  FILE *__stream;
  char *pcVar2;
  HTChunk *ch;
  
  ch_00 = (HTChunk *)calloc(1,0x18);
  if (ch_00 == (HTChunk *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkCreate2");
  }
  HTChunkInit(ch_00,grow);
  if (needed != 0) {
    ch_00->allocated = (needed - (needed - 1) % ch_00->growby) + ch_00->growby + -1;
    if (WWW_TraceFlag != '\0') {
      iVar1 = ch_00->allocated;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTChunkCreate2: requested %d, allocate %d\n",needed,iVar1);
    }
    pcVar2 = (char *)calloc(ch_00->allocated,1);
    ch_00->data = pcVar2;
    if (ch_00->data == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkCreate2 data");
    }
  }
  return ch_00;
}



void HTChunkClear(HTChunk *ch)

{
  if (ch->data != (char *)0x0) {
    free(ch->data);
    ch->data = (char *)0x0;
  }
  ch->size = 0;
  ch->allocated = 0;
  return;
}



void HTChunkFree(HTChunk *ch)

{
  HTChunk *pHVar1;
  HTChunk *next;
  
  do {
    pHVar1 = ch->next;
    if (ch->data != (char *)0x0) {
      free(ch->data);
      ch->data = (char *)0x0;
    }
    if (ch != (HTChunk *)0x0) {
      free(ch);
    }
    ch = pHVar1;
  } while (pHVar1 != (HTChunk *)0x0);
  return;
}



BOOLEAN HTChunkRealloc(HTChunk *ch,int growby)

{
  char *local_1c;
  char *data;
  
  ch->allocated = ch->allocated + growby;
  if (ch->data == (char *)0x0) {
    local_1c = (char *)calloc(ch->allocated,1);
  }
  else {
    local_1c = (char *)realloc(ch->data,ch->allocated);
  }
  if (local_1c == (char *)0x0) {
    if (ch->failok != 0) {
      HTChunkClear(ch);
      return '\0';
    }
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkRealloc");
  }
  else {
    ch->data = local_1c;
  }
  return '\x01';
}



void HTChunkPutc(HTChunk *ch,char c)

{
  int iVar1;
  BOOLEAN BVar2;
  
  if ((ch->allocated <= ch->size) && (BVar2 = HTChunkRealloc(ch,ch->growby), BVar2 == '\0')) {
    return;
  }
  iVar1 = ch->size;
  ch->data[iVar1] = c;
  ch->size = iVar1 + 1;
  return;
}



HTChunk * HTChunkPutc2(HTChunk *ch,char c)

{
  int iVar1;
  HTChunk *local_1c;
  HTChunk *chunk;
  
  if (ch->size < ch->allocated) {
    iVar1 = ch->size;
    ch->data[iVar1] = c;
    ch->size = iVar1 + 1;
    local_1c = ch;
  }
  else {
    local_1c = HTChunkCreateMayFail(ch->growby,ch->failok);
    ch->next = local_1c;
    HTChunkPutc(local_1c,c);
  }
  return local_1c;
}



void HTChunkEnsure(HTChunk *ch,int needed)

{
  char *local_8;
  
  if (ch->allocated < needed) {
    ch->allocated = ((needed + -1) - (needed + -1) % ch->growby) + ch->growby;
    if (ch->data == (char *)0x0) {
      local_8 = (char *)calloc(ch->allocated,1);
    }
    else {
      local_8 = (char *)realloc(ch->data,ch->allocated);
    }
    ch->data = local_8;
    if (ch->data == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkEnsure");
    }
  }
  return;
}



void HTChunkPutb(HTChunk *ch,char *b,int l)

{
  BOOLEAN BVar1;
  int growby;
  
  if (0 < l) {
    if ((ch->allocated < ch->size + l) &&
       (BVar1 = HTChunkRealloc(ch,(l - l % ch->growby) + ch->growby), BVar1 == '\0')) {
      return;
    }
    memcpy(ch->data + ch->size,b,l);
    ch->size = ch->size + l;
  }
  return;
}



HTChunk * HTChunkPutb2(HTChunk *ch,char *b,int l)

{
  size_t __n;
  HTChunk *local_18;
  int m;
  HTChunk *chunk;
  
  if (l < 1) {
    local_18 = ch;
  }
  else {
    if (ch->allocated < ch->size + l) {
      __n = ch->allocated - ch->size;
      memcpy(ch->data + ch->size,b,__n);
      ch->size = ch->size + __n;
      local_18 = HTChunkCreateMayFail(ch->growby,ch->failok);
      ch->next = local_18;
      HTChunkPutb(local_18,b + __n,l - __n);
    }
    else {
      memcpy(ch->data + ch->size,b,l);
      ch->size = ch->size + l;
      local_18 = ch;
    }
  }
  return local_18;
}



void HTChunkPutUtf8Char(HTChunk *ch,UCode_t code)

{
  int iVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  BOOLEAN BVar6;
  int local_18;
  int growby;
  int utflen;
  
  if (code < 0x80) {
    utflen = 1;
  }
  else {
    if (code < 0x800) {
      utflen = 2;
    }
    else {
      if (code < 0x10000) {
        utflen = 3;
      }
      else {
        if (code < 0x200000) {
          utflen = 4;
        }
        else {
          if (code < 0x4000000) {
            utflen = 5;
          }
          else {
            utflen = 6;
          }
        }
      }
    }
  }
  if (ch->allocated < ch->size + utflen) {
    local_18 = ch->growby;
    if (local_18 < utflen) {
      local_18 = utflen;
    }
    BVar6 = HTChunkRealloc(ch,local_18);
    if (BVar6 == '\0') {
      return;
    }
  }
  bVar2 = (byte)(code >> 6);
  bVar3 = (byte)(code >> 0xc);
  bVar4 = (byte)(code >> 0x12);
  bVar5 = (byte)((uint)code >> 0x18);
  switch(utflen) {
  case 0:
    goto switchD_081224f6_caseD_0;
  case 1:
    iVar1 = ch->size;
    ch->data[iVar1] = (byte)code;
    ch->size = iVar1 + 1;
    return;
  case 2:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar2 | 0xc0;
    ch->size = iVar1 + 1;
    break;
  case 3:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar3 | 0xe0;
    ch->size = iVar1 + 1;
    break;
  case 4:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar4 | 0xf0;
    ch->size = iVar1 + 1;
    break;
  case 5:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar5 | 0xf8;
    ch->size = iVar1 + 1;
    break;
  case 6:
    iVar1 = ch->size;
    ch->data[iVar1] = (char)bVar5 >> 6 | 0xfc;
    ch->size = iVar1 + 1;
  }
  switch(utflen) {
  case 6:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar5 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 5:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar4 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 4:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar3 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 3:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar2 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 2:
    iVar1 = ch->size;
    ch->data[iVar1] = (byte)code & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  }
switchD_081224f6_caseD_0:
  return;
}



void HTChunkTerminate(HTChunk *ch)

{
  HTChunkPutc(ch,'\0');
  return;
}



void HTChunkPuts(HTChunk *ch,char *s)

{
  int iVar1;
  BOOLEAN BVar2;
  char *p;
  
  if (s != (char *)0x0) {
    p = s;
    while (*p != '\0') {
      if ((ch->allocated <= ch->size) && (BVar2 = HTChunkRealloc(ch,ch->growby), BVar2 == '\0')) {
        return;
      }
      iVar1 = ch->size;
      ch->data[iVar1] = *p;
      ch->size = iVar1 + 1;
      p = p + 1;
    }
  }
  return;
}



HTChunk * HTChunkPuts2(HTChunk *ch,char *s)

{
  int iVar1;
  HTChunk *ch_00;
  HTChunk *chunk;
  char *p;
  
  if (s != (char *)0x0) {
    p = s;
    while (*p != '\0') {
      if (ch->allocated <= ch->size) {
        ch_00 = HTChunkCreateMayFail(ch->growby,ch->failok);
        ch->next = ch_00;
        HTChunkPuts(ch_00,p);
        return ch_00;
      }
      iVar1 = ch->size;
      ch->data[iVar1] = *p;
      ch->size = iVar1 + 1;
      p = p + 1;
    }
  }
  return ch;
}



void HTPlain_getChartransInfo(HTStream *me,HTParentAnchor *anchor)

{
  HTStreamClass *pHVar1;
  LYUCcharset *pLVar2;
  int chndl;
  
  if ((int)me[3].isa < 0) {
    HTAnchor_copyUCInfoStage(anchor,1,0,4);
    pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl(anchor,1);
    me[3].isa = pHVar1;
  }
  if ((int)me[5].isa < 0) {
    chndl = HTAnchor_getUCLYhndl(anchor,3);
    if (chndl < 0) {
      chndl = current_char_set;
      HTAnchor_setUCInfoStage(anchor,current_char_set,3,1);
    }
    HTAnchor_setUCInfoStage(anchor,chndl,3,1);
    pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl(anchor,3);
    me[5].isa = pHVar1;
  }
  pLVar2 = HTAnchor_getUCInfoStage(anchor,1);
  *(LYUCcharset **)&me[2].isa = pLVar2;
  pLVar2 = HTAnchor_getUCInfoStage(anchor,3);
  *(LYUCcharset **)&me[4].isa = pLVar2;
  return;
}



void HTPlain_put_character(HTStream *me,char c)

{
  char *__s;
  size_t __n;
  int iVar1;
  char local_28 [8];
  UCode_t value;
  char *name;
  int diff;
  int i;
  int low;
  int high;
  int len;
  
  local_28[0] = c;
  if ((HTPlain_lastraw == 0xd) && (c == '\n')) {
    HTPlain_lastraw = -1;
  }
  else {
    if ((c == '\b') || ((c == '_' || (HTPlain_bs_pending != 0)))) {
      HTPlain_write(me,local_28,1);
    }
    else {
      HTPlain_lastraw = ZEXT14((byte)c);
      if (c == '\r') {
        HText_appendCharacter((HText *)me[1].isa,10);
      }
      else {
        if ((byte)c < 0x7f) {
          if (HTCJK == NOCJK) {
            if ((((byte)c < 0x7f) || (0xa0 < (byte)c)) || (HTPassHighCtrlRaw == '\0')) {
              if (c == -0x60) {
                HText_appendCharacter((HText *)me[1].isa,0x20);
              }
              else {
                if (c != -0x53) {
                  if ((((byte)c < 0x20) || (0x7e < (byte)c)) && ((c != '\n' && (c != '\t')))) {
                    if (0xa0 < (byte)c) {
                      if (((HTPassEightBitRaw == '\0') && (me[5].isa != (HTStreamClass *)LATIN1)) &&
                         (((uint)(me[4].isa)->_abort & 2) == 0)) {
                        diff = 1;
                        value = (uint)(byte)c - 0xa0;
                        __s = HTMLGetEntityName(value);
                        __n = strlen(__s);
                        low = 0;
                        high = 0x70;
                        iVar1 = high;
                        while (high = iVar1, low < high) {
                          iVar1 = (high - low) / 2 + low;
                          diff = strncmp(entities[iVar1],__s,__n);
                          if (diff == 0) {
                            HText_appendText((HText *)me[1].isa,LYCharSets[(int)me[5].isa][iVar1]);
                            break;
                          }
                          if (diff < 0) {
                            low = iVar1 + 1;
                            iVar1 = high;
                          }
                        }
                        if (diff != 0) {
                          HText_appendCharacter((HText *)me[1].isa,(int)local_28[0]);
                        }
                      }
                      else {
                        HText_appendCharacter((HText *)me[1].isa,(int)c);
                      }
                    }
                  }
                  else {
                    HText_appendCharacter((HText *)me[1].isa,(int)c);
                  }
                }
              }
            }
            else {
              HText_appendCharacter((HText *)me[1].isa,(int)c);
            }
          }
          else {
            HText_appendCharacter((HText *)me[1].isa,(int)c);
          }
        }
        else {
          HTPlain_write(me,local_28,1);
        }
      }
    }
  }
  return;
}



void HTPlain_put_string(HTStream *me,char *s)

{
  char *p;
  
  if (s != (char *)0x0) {
    p = s;
    while (*p != '\0') {
      HTPlain_put_character(me,*p);
      p = p + 1;
    }
  }
  return;
}



void HTPlain_write(HTStream *me,char *s,int l)

{
  HTStreamClass *pHVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  uint uVar3;
  HTStreamClass *pHVar4;
  int charset_out;
  bool bVar5;
  UCode_t uck;
  UCode_t code;
  uint c_unsign;
  char *e;
  char *p;
  char saved_char_in;
  BOOLEAN chk;
  char c;
  
  uck = -1;
  p = s;
  do {
    if (s + l <= p) {
      return;
    }
    if (*p == '\b') {
      if (((HTPlain_lastraw < 0x20) || (HTPlain_lastraw == 0xd)) || (HTPlain_lastraw == 10)) {
LAB_08122c7c:
        if (1 < HTPlain_bs_pending) {
          HText_appendCharacter((HText *)me[1].isa,0x5f);
        }
        HTPlain_bs_pending = 0;
        goto LAB_08122cd8;
      }
      if (HTPlain_bs_pending == 0) {
        HTPlain_bs_pending = 1;
      }
      else {
        if (HTPlain_bs_pending != 2) goto LAB_08122c7c;
        HTPlain_bs_pending = 3;
      }
    }
    else {
      if ((*p == '_') && (HTPlain_bs_pending == 0)) {
        HTPlain_bs_pending = 2;
        HTPlain_lastraw = ZEXT14((byte)*p);
        goto LAB_0812380c;
      }
LAB_08122cd8:
      if ((HTPlain_lastraw == 0xd) && (*p == '\n')) {
        HTPlain_lastraw = -1;
      }
      else {
        if ((HTPlain_bs_pending != 0) &&
           ((((byte)*p < 0x20 || (*p == '\r')) ||
            ((*p == '\n' ||
             ((((uint)(byte)*p != HTPlain_lastraw && (HTPlain_lastraw != 0x5f)) && (*p != '_')))))))
           ) {
          if (1 < HTPlain_bs_pending) {
            HText_appendCharacter((HText *)me[1].isa,0x5f);
          }
          goto LAB_08122e03;
        }
        if (HTPlain_bs_pending == 1) {
          HTPlain_bs_pending = 0;
        }
        else {
          if (HTPlain_bs_pending == 3) {
            if (*p == '_') {
              HTPlain_bs_pending = 2;
            }
            else {
LAB_08122e03:
              HTPlain_bs_pending = 0;
              HTPlain_lastraw = ZEXT14((byte)*p);
              if (*p == '\r') {
                HText_appendCharacter((HText *)me[1].isa,10);
              }
              else {
                c = *p;
                c_unsign = (uint)(byte)c;
                saved_char_in = '\0';
                code = c_unsign;
                if (*(char *)((int)&me[0xb].isa + 2) != '\0') {
                  if (0x7f < (byte)c) {
                    if ((*(char *)&me[6].isa < '\x01') || (((int)c & 0xc0U) != 0x80)) {
                      *(char *)&(me[10].isa)->name = c;
                      me[10].isa = (HTStreamClass *)((int)&me[8].isa + 1);
                      if (((int)*p & 0xe0U) == 0xc0) {
                        *(undefined *)&me[6].isa = 1;
                        me[7].isa = (HTStreamClass *)((int)c & 0x1f);
                      }
                      else {
                        if (((int)*p & 0xf0U) == 0xe0) {
                          *(undefined *)&me[6].isa = 2;
                          me[7].isa = (HTStreamClass *)((int)c & 0xf);
                        }
                        else {
                          if (((int)*p & 0xf8U) == 0xf0) {
                            *(undefined *)&me[6].isa = 3;
                            me[7].isa = (HTStreamClass *)((int)c & 7);
                          }
                          else {
                            if (((int)*p & 0xfcU) == 0xf8) {
                              *(undefined *)&me[6].isa = 4;
                              me[7].isa = (HTStreamClass *)((int)c & 3);
                            }
                            else {
                              if (((int)*p & 0xfeU) == 0xfc) {
                                *(undefined *)&me[6].isa = 5;
                                me[7].isa = (HTStreamClass *)((int)c & 1);
                              }
                              else {
                                *(undefined *)&me[6].isa = 0;
                                *(undefined *)&(me[10].isa)->name = 0;
                                me[10].isa = (HTStreamClass *)(me + 8);
                              }
                            }
                          }
                        }
                      }
                    }
                    else {
                      me[7].isa = (HTStreamClass *)((int)me[7].isa << 6 | (int)c & 0x3fU);
                      *(char *)&me[6].isa = *(char *)&me[6].isa + -1;
                      *(char *)&(me[10].isa)->name = c;
                      me[10].isa = (HTStreamClass *)((int)&(me[10].isa)->name + 1);
                      if (*(char *)&me[6].isa == '\0') {
                        *(undefined *)&(me[10].isa)->name = 0;
                        code = (UCode_t)me[7].isa;
                        if ((0 < code) && (code < 0x100)) {
                          c = (char)code;
                          c_unsign = code & 0xff;
                        }
                        goto LAB_0812307d;
                      }
                    }
                    goto LAB_0812380c;
                  }
                  if ('\0' < *(char *)&me[6].isa) {
                    *(undefined *)&me[6].isa = 0;
                    *(undefined *)&me[8].isa = 0;
                    me[10].isa = (HTStreamClass *)(me + 8);
                  }
                }
LAB_0812307d:
                if ((*(char *)((int)&me[0xb].isa + 2) == '\0') || (-1 < *p)) {
                  if ((*(char *)&me[0xd].isa == '\0') ||
                     ((code < LYlowest_eightbit[(int)me[3].isa] &&
                      (((0x1f < code || (code == 0)) || (*(char *)((int)&me[0xd].isa + 1) == '\0')))
                      ))) {
                    if (((code < 0x20) && (code != 0)) && (*(char *)((int)&me[0xd].isa + 1) != '\0')
                       ) {
                      if ((*(char *)((int)&me[0xd].isa + 3) == '\0') ||
                         ((code = UCTransToUni(c,(int)me[3].isa), code < 0x20 &&
                          ((*(char *)&me[0xb].isa == '\0' ||
                           (code = UCTransToUni(c,(int)me[3].isa), code < 1)))))) {
                        uck = -1;
                        if (*(char *)&me[0xb].isa != '\0') {
                          uck = UCTransCharStr(replace_buf,0x3c,c,(int)me[3].isa,(int)me[3].isa,0);
                        }
                        if ((*(char *)&me[0xb].isa == '\0') || (uck < 0)) {
                          uck = UCTransCharStr(replace_buf,0x3c,c,(int)me[3].isa,(int)me[5].isa,1);
                        }
                        if (uck == 0) goto LAB_0812380c;
                        if (uck < 0) {
                          *(undefined *)&me[8].isa = 0;
                        }
                        else {
                          c = replace_buf[0];
                          if ((replace_buf[0] != '\0') && (replace_buf[1] != '\0')) {
                            HText_appendText((HText *)me[1].isa,replace_buf);
                            goto LAB_0812380c;
                          }
                        }
                        *(undefined *)&me[8].isa = 0;
                        code = ZEXT14((byte)c);
                      }
                      else {
                        saved_char_in = c;
                        if (code < 0x100) {
                          c = (char)code;
                          c_unsign = code & 0xff;
                        }
                      }
                    }
                    else {
                      *(undefined *)&me[8].isa = 0;
                      code = ZEXT14((byte)c);
                    }
                  }
                  else {
                    code = UCTransToUni(c,(int)me[3].isa);
                    if ((0 < code) && (saved_char_in = c, code < 0x100)) {
                      c = (char)code;
                      c_unsign = code & 0xff;
                    }
                  }
                }
                if (HTCJK == NOCJK) {
                  if ((((code < 0x7f) || (0xa0 < code)) ||
                      ((*(char *)&me[0xb].isa == '\0' && (code < LYlowest_eightbit[(int)me[3].isa]))
                      )) || (*(char *)((int)&me[0xc].isa + 2) == '\0')) {
                    if ((code == 0xad) && (*(char *)((int)&me[0xc].isa + 2) != '\0')) {
                      HText_appendCharacter((HText *)me[1].isa,(int)c);
                    }
                    else {
                      if (code == 0xa0) {
                        HText_appendCharacter((HText *)me[1].isa,0x20);
                      }
                      else {
                        if (code != 0xad) {
                          if ((((code < 0x20) || (0x7e < code)) &&
                              (((HTPassEightBitRaw == '\0' &&
                                ((*(char *)((int)&me[0xc].isa + 3) == '\0' ||
                                 (*(char *)((int)&me[0xd].isa + 3) != '\0')))) ||
                               ((int)c < LYlowest_eightbit[(int)me[5].isa])))) &&
                             ((*p != '\n' && (*p != '\t')))) {
                            if (((code == 0x2002) || (code == 0x2003)) || (code == 0x2009)) {
                              HText_appendCharacter((HText *)me[1].isa,0x20);
                            }
                            else {
                              if ((*(char *)&me[0xc].isa == '\0') || (saved_char_in == '\0')) {
                                if ((*(char *)((int)&me[0xd].isa + 3) == '\0') || (code < 0xa0)) {
                                  bVar5 = false;
                                }
                                else {
                                  bVar5 = true;
                                }
                                if (((bVar5) &&
                                    (uck = UCTransUniChar(code,(int)me[5].isa), 0x1f < uck)) &&
                                   (uck < 0x100)) {
                                  if (WWW_TraceFlag != '\0') {
                                    __stream = TraceFP();
                                    fprintf((FILE *)__stream,
                                            "UCTransUniChar returned 0x%.2lX:\'%c\'.\n",uck,
                                            (int)(char)uck);
                                  }
                                  HText_appendCharacter((HText *)me[1].isa,(int)(char)uck);
                                }
                                else {
                                  if ((bVar5) &&
                                     ((uck == -4 ||
                                      (((*(char *)((int)&me[0xd].isa + 2) != '\0' && (0 < uck)) &&
                                       (uck < 0x20)))))) {
                                    uVar3 = UCTransUniCharStr(replace_buf,0x3c,code,(int)me[5].isa,0
                                                             );
                                    uck = -((int)~uVar3 >> 0x1f);
                                    if (uck != 0) {
                                      HText_appendText((HText *)me[1].isa,replace_buf);
                                      goto LAB_0812380c;
                                    }
                                  }
                                  if (((bVar5) && (0x7f < code)) &&
                                     (*(char *)((int)&me[0xb].isa + 3) != '\0')) {
                                    if (*(char *)&me[8].isa == '\0') {
                                      BVar2 = UCConvertUniToUtf8(code,replace_buf);
                                      if (BVar2 == '\0') {
                                        sprintf(replace_buf,"U%.2lX",code);
                                        HText_appendText((HText *)me[1].isa,replace_buf);
                                      }
                                      else {
                                        HText_appendText((HText *)me[1].isa,replace_buf);
                                      }
                                    }
                                    else {
                                      HText_appendText((HText *)me[1].isa,(char *)(me + 8));
                                      *(undefined *)&me[8].isa = 0;
                                      me[10].isa = (HTStreamClass *)(me + 8);
                                    }
                                  }
                                  else {
                                    if (((c_unsign == 0) ||
                                        (LYlowest_eightbit[(int)me[5].isa] <= (int)c_unsign)) &&
                                       ((*(char *)((int)&me[0xd].isa + 3) == '\0' ||
                                        (HTPassEightBitRaw != '\0')))) {
                                      if ((c_unsign != 0) && (c_unsign < 0x100)) {
                                        HText_appendCharacter((HText *)me[1].isa,(int)c);
                                      }
                                    }
                                    else {
                                      pHVar1 = me[5].isa;
                                      pHVar4 = (HTStreamClass *)UCGetLYhndl_byMIME("us-ascii");
                                      bVar5 = pHVar1 != pHVar4;
                                      if (bVar5) {
                                        charset_out = UCGetLYhndl_byMIME("us-ascii");
                                        uck = UCTransUniChar(code,charset_out);
                                        if ((0x1f < uck) && (uck < 0x7f)) {
                                          HText_appendCharacter((HText *)me[1].isa,(int)(char)uck);
                                          goto LAB_0812380c;
                                        }
                                      }
                                      if ((bVar5) && (uck == -4)) {
                                        charset_out = UCGetLYhndl_byMIME("us-ascii");
                                        uVar3 = UCTransUniCharStr(replace_buf,0x3c,code,charset_out,
                                                                  0);
                                        uck = -((int)~uVar3 >> 0x1f);
                                        if (uck != 0) {
                                          HText_appendText((HText *)me[1].isa,replace_buf);
                                          goto LAB_0812380c;
                                        }
                                      }
                                      if ((code == 0x200c) || (code == 0x200d)) {
                                        if (WWW_TraceFlag != '\0') {
                                          __stream = TraceFP();
                                          fprintf((FILE *)__stream,
                                                  "HTPlain_write: Ignoring \'%ld\'.\n",code);
                                        }
                                      }
                                      else {
                                        if (((code == 0x200e) || (code == 0x200f)) &&
                                           (WWW_TraceFlag != '\0')) {
                                          __stream = TraceFP();
                                          fprintf((FILE *)__stream,
                                                  "HTPlain_write: Ignoring \'%ld\'.\n",code);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              else {
                                HText_appendCharacter((HText *)me[1].isa,(int)saved_char_in);
                              }
                            }
                          }
                          else {
                            HText_appendCharacter((HText *)me[1].isa,(int)c);
                          }
                        }
                      }
                    }
                  }
                  else {
                    HText_appendCharacter((HText *)me[1].isa,(int)c);
                  }
                }
                else {
                  HText_appendCharacter((HText *)me[1].isa,(int)c);
                }
              }
            }
          }
          else {
            if ((HTPlain_bs_pending != 2) ||
               (HText_appendCharacter((HText *)me[1].isa,0x5f), *p != '_')) goto LAB_08122e03;
          }
        }
      }
    }
LAB_0812380c:
    p = p + 1;
  } while( true );
}



void HTPlain_free(HTStream *me)

{
  if (1 < HTPlain_bs_pending) {
    HText_appendCharacter((HText *)me[1].isa,0x5f);
  }
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



void HTPlain_abort(HTStream *me,HTError e)

{
  HTPlain_free(me);
  return;
}



HTStream * HTPlainPresent(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTStream *me_00;
  HTStreamClass *pHVar1;
  LYUCcharset *p_out;
  HText *pHVar2;
  HTStyle *style;
  HTStream *me;
  
  me_00 = (HTStream *)malloc(0x38);
  if (me_00 == (HTStream *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTPlain.c","HTPlain_new");
  }
  me_00->isa = (HTStreamClass *)0x818b2d4;
  HTPlain_lastraw = -1;
  *(undefined *)&me_00[6].isa = 0;
  me_00[7].isa = (HTStreamClass *)0x0;
  *(undefined *)((int)&me_00[9].isa + 3) = 0;
  *(undefined *)((int)&me_00[9].isa + 2) = *(undefined *)((int)&me_00[9].isa + 3);
  *(undefined *)&me_00[8].isa = *(undefined *)((int)&me_00[9].isa + 2);
  me_00[10].isa = (HTStreamClass *)(me_00 + 8);
  pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl(anchor,3);
  me_00[5].isa = pHVar1;
  pHVar1 = (HTStreamClass *)HTAnchor_getUCLYhndl(anchor,1);
  me_00[3].isa = pHVar1;
  HTPlain_getChartransInfo(me_00,anchor);
  p_out = HTAnchor_getUCInfoStage(anchor,3);
  UCSetTransParams((UCTransParams *)(me_00 + 0xb),(int)me_00[3].isa,(LYUCcharset *)me_00[2].isa,
                   (int)me_00[5].isa,p_out);
  pHVar2 = HText_new(anchor);
  *(HText **)&me_00[1].isa = pHVar2;
  style = LYstyles(0x75);
  HText_setStyle((HText *)me_00[1].isa,style);
  HText_beginAppend((HText *)me_00[1].isa);
  return me_00;
}



void flush_breaks(HTStructured *me)

{
  int i;
  
  i = 0;
  while (i < 0x15) {
    (&me->node_anchor)[i + 0x3c] = (HTParentAnchor *)0x0;
    i = i + 1;
  }
  return;
}



void HTMLGen_flush(HTStructured *me)

{
  (*(me->targetClass).put_character)((HTStream *)me->node_anchor,(char)me + ' ');
  *(anon_subr_void_HTStream_ptr_char_ptr_for_put_string ***)&(me->math).size =
       &(me->targetClass).put_string;
  flush_breaks(me);
  me->OL_Counter[3] = 0;
  *(undefined *)((int)me->OL_Counter + 0x11) = 0;
  return;
}



void do_cstyle_flush(HTStructured *me)

{
  if ((me->OL_Counter[0xb] == 0) && (LYPreparsedSource != '\0')) {
    *(HText **)(me->OL_Counter + 0xb) = HTMainText;
  }
  if (me->OL_Counter[0xb] != 0) {
    HTMLGen_flush(me);
  }
  return;
}



void allow_break(HTStructured *me,int new_cleanness,BOOLEAN dlbc)

{
  HTParentAnchor *local_c;
  BOOLEAN local_8;
  
  local_8 = dlbc;
  if ((dlbc != '\0') &&
     ((anon_subr_void_HTStream_ptr_char_ptr_for_put_string **)(me->math).size ==
      &(me->targetClass).put_string)) {
    local_8 = '\0';
  }
  if (local_8 == '\0') {
    local_c = (HTParentAnchor *)(me->math).size;
  }
  else {
    local_c = (HTParentAnchor *)((me->math).size + -1);
  }
  (&me->node_anchor)[new_cleanness + 0x3c] = local_c;
  *(char *)((int)me->OL_Counter + new_cleanness + 0x11) = local_8;
  if ((me->OL_Counter[3] <= new_cleanness) &&
     ((*(char *)(me->OL_Counter + 4) != '\0' ||
      ((HTParentAnchor *)&(me->targetClass).put_string < (&me->node_anchor)[new_cleanness + 0x3c])))
     ) {
    me->OL_Counter[3] = new_cleanness;
  }
  return;
}



void HTMLGen_put_character(HTStructured *me,char c)

{
  undefined uVar1;
  char *pcVar2;
  char local_40;
  char delims [5];
  int i;
  char *q;
  char *p_1;
  char *saved;
  char *p;
  int new_cleanness;
  char line_break_char;
  
  local_40 = c;
  if (((*(char *)((int)me->OL_Counter + 0x27) != '\0') && ((byte)c < 0x20)) &&
     ((c == '\x01' || ((c == '\x02' || (c == '\a')))))) {
    HTMLGen_put_character(me,'&');
    HTMLGen_put_character(me,'#');
    HTMLGen_put_character(me,'x');
    if (c == '\x02') {
      HTMLGen_put_character(me,'2');
      HTMLGen_put_character(me,'0');
      HTMLGen_put_character(me,'0');
      HTMLGen_put_character(me,'2');
    }
    else {
      if (c == '\a') {
        HTMLGen_put_character(me,'A');
        HTMLGen_put_character(me,'D');
      }
      else {
        if (c == '\x01') {
          HTMLGen_put_character(me,'A');
          HTMLGen_put_character(me,'0');
        }
      }
    }
    local_40 = ';';
  }
  pcVar2 = (char *)(me->math).size;
  *pcVar2 = local_40;
  *(char **)&(me->math).size = pcVar2 + 1;
  if (local_40 == '\n') {
    HTMLGen_flush(me);
  }
  else {
    if ((*(char *)((int)me->OL_Counter + 0x26) == '\0') && ((local_40 == ' ' || (local_40 == '\t')))
       ) {
      new_cleanness = 3;
      if ((int)&(me->targetClass).put_string + 1U < (uint)(me->math).size) {
        memcpy(delims,&DAT_0818b340,5);
        pcVar2 = strchr(delims,(int)*(char *)((me->math).size + -2));
        if (pcVar2 != (char *)0x0) {
          new_cleanness = (int)(pcVar2 + (6 - (int)delims));
        }
        if (*(char *)(me->OL_Counter + 10) == '\0') {
          new_cleanness = new_cleanness + 10;
        }
      }
      allow_break(me,new_cleanness,'\x01');
    }
    if (((uint)((int)((int)me + 0x20) + (int)me->textarea_id) <= (uint)(me->math).size) ||
       ((*(char *)(me->OL_Counter + 4) != '\0' && (me->OL_Counter[3] != 0)))) {
      if (me->OL_Counter[3] == 0) {
        (*(me->targetClass).put_character)((HTStream *)me->node_anchor,(char)me + ' ');
        *(anon_subr_void_HTStream_ptr_char_ptr_for_put_string ***)&(me->math).size =
             &(me->targetClass).put_string;
        flush_breaks(me);
        *(undefined *)(me->OL_Counter + 4) = 1;
      }
      else {
        uVar1 = *(undefined *)&(&me->node_anchor)[me->OL_Counter[3] + 0x3c]->parent;
        saved = (char *)(&me->node_anchor)[me->OL_Counter[3] + 0x3c];
        if (*(char *)((int)me->OL_Counter + me->OL_Counter[3] + 0x11) != '\0') {
          saved = (char *)((int)&((HTParentAnchor *)saved)->parent + 1);
        }
        *(undefined *)&(&me->node_anchor)[me->OL_Counter[3] + 0x3c]->parent = 10;
        (*(me->targetClass).put_character)((HTStream *)me->node_anchor,(char)me + ' ');
        *(undefined *)&(&me->node_anchor)[me->OL_Counter[3] + 0x3c]->parent = uVar1;
        p_1 = saved;
        q = (char *)&(me->targetClass).put_string;
        while (p_1 < (char *)(me->math).size) {
          *q = *p_1;
          q = q + 1;
          p_1 = p_1 + 1;
        }
        me->OL_Counter[3] = 0;
        i = 0;
        while (i < 0x15) {
          if (((&me->node_anchor)[i + 0x3c] == (HTParentAnchor *)0x0) ||
             ((&me->node_anchor)[i + 0x3c] <= saved)) {
            (&me->node_anchor)[i + 0x3c] = (HTParentAnchor *)0x0;
          }
          else {
            (&me->node_anchor)[i + 0x3c] =
                 (HTParentAnchor *)
                 ((int)me + (int)(&me->node_anchor)[i + 0x3c] + (0x20 - (int)saved));
            me->OL_Counter[3] = i;
          }
          i = i + 1;
        }
        *(undefined *)((int)me->OL_Counter + 0x11) = 0;
        (me->math).size = (int)me + (me->math).size + (0x20 - (int)saved);
        *(undefined *)(me->OL_Counter + 4) = 0;
      }
    }
  }
  return;
}



void HTMLGen_put_string(HTStructured *me,char *s)

{
  char *p;
  
  p = s;
  while (*p != '\0') {
    HTMLGen_put_character(me,*p);
    p = p + 1;
  }
  return;
}



void HTMLGen_write(HTStructured *me,char *s,int l)

{
  char *p;
  
  p = s;
  while (p < s + l) {
    HTMLGen_put_character(me,*p);
    p = p + 1;
  }
  return;
}



int HTMLGen_start_element
              (HTStructured *me,int element_number,BOOLEAN *present,char **value,int charset,
              char **insert)

{
  bool bVar1;
  size_t sVar2;
  FILE *__stream;
  char *pcVar3;
  int iVar4;
  int local_50;
  undefined local_3d;
  char *p;
  int hcd;
  char *rp;
  int len;
  char *title_tmp;
  char *title;
  HTTag *tag;
  int i;
  BOOLEAN had_attr;
  BOOLEAN was_preformatted;
  
  local_3d = *(undefined *)((int)me->OL_Counter + 0x26);
  title = (char *)0x0;
  title_tmp = (char *)0x0;
  if (LYPreparsedSource != '\0') {
    HTSprintf(&Style_className,";%s",tags[element_number].name);
    strcpy(myHash,tags[element_number].name);
    if (class_string[0] != '\0') {
      sVar2 = strlen(myHash);
      sprintf(myHash + sVar2,".%.*s",0x7e - sVar2,class_string);
      HTSprintf(&Style_className,".%s",class_string);
    }
    class_string[0] = '\0';
    strtolower(myHash);
    hcode = hash_code(myHash);
    strtolower(Style_className);
    local_50 = hcode;
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"CSSTRIM:%s -> %d",myHash,local_50);
      if (hashStyles[hcode].code == hcode) {
        iVar4 = hashStyles[hcode].color;
        __stream = TraceFP();
        fprintf((FILE *)__stream," ca=%d\n",iVar4,local_50);
      }
      else {
        pcVar3 = strrchr(myHash,0x2e);
        __stream = TraceFP();
        fprintf((FILE *)__stream," (undefined) %s\n",myHash,local_50);
        if (pcVar3 != (char *)0x0) {
          *pcVar3 = '\0';
          iVar4 = hash_code(myHash);
          __stream = TraceFP();
          local_50 = iVar4;
          fprintf((FILE *)__stream,"CSS:%s -> %d",myHash,iVar4);
          if (hashStyles[iVar4].code == iVar4) {
            iVar4 = hashStyles[iVar4].color;
            __stream = TraceFP();
            fprintf((FILE *)__stream," ca=%d\n",iVar4,local_50);
          }
          else {
            __stream = TraceFP();
            fprintf((FILE *)__stream," (undefined) %s\n",myHash,local_50);
          }
        }
      }
    }
    if (-2 < displayStyles[element_number + 8].color) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pcVar3 = tags[element_number].name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"CSSTRIM: start_element: top <%s>\n",pcVar3);
      }
      do_cstyle_flush(me);
      _internal_HTC((HText *)me->OL_Counter[0xb],hcode,1);
    }
  }
  *(undefined *)((int)me->OL_Counter + 0x26) = 1;
  HTMLGen_put_character(me,'<');
  HTMLGen_put_string(me,tags[element_number].name);
  if (present != (BOOLEAN *)0x0) {
    bVar1 = false;
    i = 0;
    while (i < tags[element_number].number_of_attributes) {
      if (present[i] != '\0') {
        bVar1 = true;
        HTMLGen_put_character(me,' ');
        allow_break(me,0xb,'\x01');
        if ((((LYPreparsedSource != '\0') && (element_number == 0x45)) && (title == (char *)0x0)) &&
           ((((present[1] != '\0' && (value != (char **)0x0)) &&
             ((*value[1] != '\0' && (present[9] == '\0')))) &&
            ((present[8] != '\0' || (present[3] != '\0')))))) {
          if ((present[0xc] != '\0') && (*value[0xc] != '\0')) {
            HTSACopy(&title,value[0xc]);
            LYTrimHead(title);
            LYTrimTail(title);
          }
          if (((title == (char *)0x0) || (*title == '\0')) && (present[8] != '\0')) {
            HTSACopy(&title,value[8]);
          }
          if ((title != (char *)0x0) && (*title != '\0')) {
            HTSprintf0(&title_tmp,"link.%s.%s",value[1],title);
            pcVar3 = title_tmp;
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"CSSTRIM:link=%s\n",pcVar3);
            }
            do_cstyle_flush(me);
            local_50 = hash_code(title_tmp);
            _internal_HTC((HText *)me->OL_Counter[0xb],local_50,1);
          }
        }
        HTMLGen_put_string(me,tags[element_number].attributes[i].name);
        if (value[i] != (char *)0x0) {
          *(undefined *)((int)me->OL_Counter + 0x26) = local_3d;
          *(undefined *)(me->OL_Counter + 10) = 1;
          pcVar3 = strchr(value[i],0x22);
          if (pcVar3 == (char *)0x0) {
            HTMLGen_put_string(me,"=\"");
            HTMLGen_put_string(me,value[i]);
            HTMLGen_put_character(me,'\"');
          }
          else {
            pcVar3 = strchr(value[i],0x27);
            if (pcVar3 == (char *)0x0) {
              HTMLGen_put_string(me,"=\'");
              HTMLGen_put_string(me,value[i]);
              HTMLGen_put_character(me,'\'');
            }
            else {
              HTMLGen_put_string(me,"=\"");
              p = value[i];
              while (*p != '\0') {
                if (*p == '\"') {
                  HTMLGen_put_string(me,"&#34;");
                }
                else {
                  HTMLGen_put_character(me,*p);
                }
                p = p + 1;
              }
              HTMLGen_put_character(me,'\"');
            }
          }
          *(undefined *)((int)me->OL_Counter + 0x26) = 1;
          *(undefined *)(me->OL_Counter + 10) = 0;
        }
      }
      i = i + 1;
    }
    if (((bVar1) && (LYPreparsedSource != '\0')) && (element_number == 0x45)) {
      if ((title != (char *)0x0) && (*title != '\0')) {
        do_cstyle_flush(me);
        local_50 = hash_code(title_tmp);
        _internal_HTC((HText *)me->OL_Counter[0xb],local_50,0);
        if (title_tmp != (char *)0x0) {
          free(title_tmp);
          title_tmp = (char *)0x0;
        }
      }
      if (title != (char *)0x0) {
        free(title);
        title = (char *)0x0;
      }
    }
    if (bVar1) {
      allow_break(me,0xc,'\0');
    }
  }
  HTMLGen_put_string(me,">");
  if (element_number == 0x56) {
    local_3d = 1;
  }
  *(undefined *)((int)me->OL_Counter + 0x26) = local_3d;
  if ((*(char *)((int)me->OL_Counter + 0x26) == '\0') &&
     (tags[element_number].contents != SGML_EMPTY)) {
    if (tags[element_number].contents == SGML_ELEMENT) {
      allow_break(me,0xf,'\0');
    }
    else {
      allow_break(me,2,'\0');
    }
  }
  if (((LYPreparsedSource != '\0') && (tags[element_number].contents == SGML_EMPTY)) &&
     ((tags[element_number].flags & 0x10U) == 0)) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"STYLE:begin_element:ending EMPTY element style\n");
    }
    do_cstyle_flush(me);
    _internal_HTC((HText *)me->OL_Counter[0xb],hcode,0);
    TrimColorClass(tags[element_number].name,Style_className,&hcode);
  }
  if ((element_number == 0x4f) && (tags[0x4f].contents == SGML_LITTERAL)) {
    if (present == (BOOLEAN *)0x0) {
      return 0x2bd;
    }
    if (((present[8] == '\0') &&
        (((present[0xf] == '\0' || (value[0xf] == (char *)0x0)) || (*value[0xf] == '\0')))) &&
       ((((present[0x11] != '\0' || (present[0x17] == '\0')) || (value[0x17] == (char *)0x0)) ||
        (*value[0x17] == '\0')))) {
      return 0x2bd;
    }
  }
  return 0;
}



int HTMLGen_end_element(HTStructured *me,int element_number,char **insert)

{
  FILE *__stream;
  
  if ((*(char *)((int)me->OL_Counter + 0x26) == '\0') &&
     (tags[element_number].contents != SGML_EMPTY)) {
    if (tags[element_number].contents == SGML_ELEMENT) {
      allow_break(me,0xe,'\0');
    }
    else {
      allow_break(me,1,'\0');
    }
  }
  HTMLGen_put_string(me,"</");
  HTMLGen_put_string(me,tags[element_number].name);
  HTMLGen_put_character(me,'>');
  if (element_number == 0x56) {
    *(undefined *)((int)me->OL_Counter + 0x26) = 0;
  }
  TrimColorClass(tags[element_number].name,Style_className,&hcode);
  if ((LYPreparsedSource != '\0') &&
     ((tags[element_number].contents != SGML_EMPTY || ((tags[element_number].flags & 0x10U) != 0))))
  {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"STYLE:end_element: ending non-EMPTY style\n");
    }
    do_cstyle_flush(me);
    _internal_HTC((HText *)me->OL_Counter[0xb],hcode,0);
  }
  return 0;
}



int HTMLGen_put_entity(HTStructured *me,int entity_number)

{
  int nent;
  
  HTMLGen_put_character(me,'&');
  if (entity_number < (int)0x70) {
    HTMLGen_put_string(me,entities[entity_number]);
  }
  HTMLGen_put_character(me,';');
  return 0;
}



void HTMLGen_free(HTStructured *me)

{
  (*(me->targetClass)._free)((HTStream *)me->node_anchor);
  HTMLGen_flush(me);
  (*(code *)me->target)(me->node_anchor);
  if (Style_className != (char *)0x0) {
    free(Style_className);
    Style_className = (char *)0x0;
  }
  if (me != (HTStructured *)0x0) {
    free(me);
  }
  return;
}



void PlainToHTML_free(HTStructured *me)

{
  HTMLGen_end_element(me,0x56,(char **)0x0);
  HTMLGen_free(me);
  return;
}



void HTMLGen_abort(HTStructured *me,HTError e)

{
  HTMLGen_free(me);
  if (Style_className != (char *)0x0) {
    free(Style_className);
    Style_className = (char *)0x0;
  }
  return;
}



void PlainToHTML_abort(HTStructured *me,HTError e)

{
  PlainToHTML_free(me);
  return;
}



HTStructured * HTMLGenerator(HTStream *output)

{
  HTParentAnchor0 *pHVar1;
  HTStructured *me_00;
  HTStructured *me;
  
  me_00 = (HTStructured *)malloc(0x16c);
  if (me_00 == (HTStructured *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMLGen.c","HTMLGenerator");
  }
  me_00->isa = (HTStructuredClass *)0x818b440;
  *(HTStream **)&me_00->node_anchor = output;
  pHVar1 = me_00->node_anchor->parent;
  me_00->text = (HText *)pHVar1->parent;
  me_00->target = (HTStream *)pHVar1->address;
  *(HTParentAnchor **)&(me_00->targetClass).name = pHVar1->info;
  *(HTBTree **)&(me_00->targetClass)._free = pHVar1->children;
  (me_00->targetClass)._abort = (pHVar1->sources).object;
  *(HTList **)&(me_00->targetClass).put_character = (pHVar1->sources).next;
  *(anon_subr_void_HTStream_ptr_char_ptr_for_put_string ***)&(me_00->math).size =
       &(me_00->targetClass).put_string;
  flush_breaks(me_00);
  *(anon_subr_void_HTStream_ptr_char_ptr_for_put_string ***)&(me_00->math).growby =
       &(me_00->targetClass).put_string;
  me_00->OL_Counter[3] = 0;
  *(undefined *)(me_00->OL_Counter + 4) = 0;
  *(undefined *)((int)me_00->OL_Counter + 0x11) = 0;
  *(undefined *)((int)me_00->OL_Counter + 0x26) = 0;
  *(undefined *)(me_00->OL_Counter + 10) = 0;
  if (LYPreparsedSource == '\0') {
    me_00->textarea_id = (char *)0x50;
  }
  else {
    if (dump_output_width < 2) {
      if (dump_output_immediately == '\0') {
        me_00->textarea_id = (char *)((LYcols - (uint)(LYShowScrollbar != '\0')) + -1);
        if ((int)me_00->textarea_id < 0x26) {
          me_00->textarea_id = (char *)0x28;
        }
      }
      else {
        me_00->textarea_id = (char *)0x50;
      }
    }
    else {
      *(int *)&me_00->textarea_id = dump_output_width;
    }
  }
  if (900 < (int)me_00->textarea_id) {
    me_00->textarea_id = (char *)0x4e;
  }
  if (200 < (int)me_00->textarea_id) {
    me_00->textarea_id = (char *)0xc6;
  }
  *(BOOLEAN *)((int)me_00->OL_Counter + 0x27) = LYPreparsedSource;
  me_00->OL_Counter[0xb] = 0;
  if (Style_className != (char *)0x0) {
    free(Style_className);
    Style_className = (char *)0x0;
  }
  class_string[0] = '\0';
  return me_00;
}



HTStream * HTPlainToHTML(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTParentAnchor0 *pHVar1;
  HTStructured *me_00;
  char *local_18;
  HTStructured *me;
  
  me_00 = (HTStructured *)malloc(0x16c);
  if (me_00 == (HTStructured *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMLGen.c","PlainToHTML");
  }
  me_00->isa = (HTStructuredClass *)0x818b4c0;
  *(HTStream **)&me_00->node_anchor = sink;
  pHVar1 = me_00->node_anchor->parent;
  me_00->text = (HText *)pHVar1->parent;
  me_00->target = (HTStream *)pHVar1->address;
  *(HTParentAnchor **)&(me_00->targetClass).name = pHVar1->info;
  *(HTBTree **)&(me_00->targetClass)._free = pHVar1->children;
  (me_00->targetClass)._abort = (pHVar1->sources).object;
  *(HTList **)&(me_00->targetClass).put_character = (pHVar1->sources).next;
  *(anon_subr_void_HTStream_ptr_char_ptr_for_put_string ***)&(me_00->math).size =
       &(me_00->targetClass).put_string;
  flush_breaks(me_00);
  me_00->OL_Counter[3] = 0;
  *(undefined *)(me_00->OL_Counter + 4) = 0;
  *(undefined *)((int)me_00->OL_Counter + 0x11) = 0;
  if (dump_output_width < 2) {
    local_18 = (char *)0x50;
  }
  else {
    local_18 = (char *)dump_output_width;
  }
  me_00->textarea_id = local_18;
  HTMLGen_put_string(me_00,"<HTML>\n<BODY>\n<PRE>\n");
  *(undefined *)((int)me_00->OL_Counter + 0x26) = 1;
  *(undefined *)((int)me_00->OL_Counter + 0x27) = 0;
  *(undefined *)(me_00->OL_Counter + 10) = 0;
  return (HTStream *)me_00;
}



HTAtom * HTAtom_for(char *string)

{
  size_t sVar1;
  int iVar2;
  HTAtom *pHVar3;
  char *pcVar4;
  uint uVar5;
  int i;
  HTAtom *a;
  int hash;
  
  if (initialised == '\0') {
    i = 0;
    while (i < 0x65) {
      hash_table[i] = (HTAtom *)0x0;
      i = i + 1;
    }
    initialised = '\x01';
  }
  sVar1 = strlen(string);
  uVar5 = (sVar1 * (byte)*string) % 0x65;
  a = hash_table[uVar5];
  while( true ) {
    if (a == (HTAtom *)0x0) {
      pHVar3 = (HTAtom *)malloc(8);
      if (pHVar3 == (HTAtom *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTAtom.c","HTAtom_for");
      }
      sVar1 = strlen(string);
      pcVar4 = (char *)malloc(sVar1 + 1);
      pHVar3->name = pcVar4;
      if (pHVar3->name == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTAtom.c","HTAtom_for");
      }
      strcpy(pHVar3->name,string);
      pHVar3->next = hash_table[uVar5];
      hash_table[uVar5] = pHVar3;
      return pHVar3;
    }
    iVar2 = strcasecomp(a->name,string);
    if (iVar2 == 0) break;
    a = a->next;
  }
  return a;
}



BOOLEAN mime_match(char *name,char *templ)

{
  char *t1;
  char *n1;
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  char *t2;
  char *n2;
  
  if ((name != (char *)0x0) && (templ != (char *)0x0)) {
    HTSACopy((char **)0x81b5e28,name);
    HTSACopy((char **)0x81b5e24,templ);
    pcVar1 = strchr(n1,0x2f);
    if ((pcVar1 != (char *)0x0) && (pcVar2 = strchr(t1,0x2f), pcVar2 != (char *)0x0)) {
      *pcVar1 = '\0';
      *pcVar2 = '\0';
      iVar3 = strcmp(t1,"*");
      if (((iVar3 == 0) || (iVar3 = strcmp(t1,n1), iVar3 == 0)) &&
         ((iVar3 = strcmp(pcVar2 + 1,"*"), iVar3 == 0 ||
          (iVar3 = strcmp(pcVar2 + 1,pcVar1 + 1), iVar3 == 0)))) {
        return '\x01';
      }
    }
  }
  return '\0';
}



HTList * HTAtom_templateMatches(char *templ)

{
  BOOLEAN BVar1;
  HTList *me;
  HTAtom *cur;
  int i;
  HTList *matches;
  
  me = HTList_new();
  if ((initialised != '\0') && (templ != (char *)0x0)) {
    i = 0;
    while (i < 0x65) {
      cur = hash_table[i];
      while (cur != (HTAtom *)0x0) {
        BVar1 = mime_match(cur->name,templ);
        if (BVar1 != '\0') {
          HTList_addObject(me,cur);
        }
        cur = cur->next;
      }
      i = i + 1;
    }
  }
  return me;
}



ushort HASH_FUNCTION(char *cp_address)

{
  int iVar1;
  ushort local_1c;
  uchar *p;
  ushort hash;
  
  p = (uchar *)cp_address;
  hash = 0;
  while (*p != '\0') {
    iVar1 = (uint)hash * 3 + (uint)*p;
    local_1c = (short)iVar1 + (short)((ulonglong)((longlong)iVar1 * 0x4178749f) >> 0x28) * -0x3e9;
    hash = local_1c;
    p = p + 1;
  }
  return hash;
}



HTParentAnchor0 * HTParentAnchor0_new(char *address,ushort hash)

{
  HTParentAnchor0 *pHVar1;
  HTParentAnchor0 *newAnchor;
  
  pHVar1 = (HTParentAnchor0 *)calloc(1,0x24);
  if (pHVar1 == (HTParentAnchor0 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTParentAnchor0_new");
  }
  *(HTParentAnchor0 **)&pHVar1->parent = pHVar1;
  HTSACopy(&pHVar1->address,address);
  pHVar1->adult_hash = hash;
  return pHVar1;
}



HTParentAnchor * HTParentAnchor_new(HTParentAnchor0 *parent)

{
  HTParentAnchor *pHVar1;
  HTParentAnchor *newAnchor;
  
  pHVar1 = (HTParentAnchor *)calloc(1,0xb8);
  if (pHVar1 == (HTParentAnchor *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTParentAnchor_new");
  }
  *(HTParentAnchor0 **)&pHVar1->parent = parent;
  parent->info = pHVar1;
  pHVar1->address = parent->address;
  pHVar1->isISMAPScript = '\0';
  pHVar1->isHEAD = '\0';
  pHVar1->safe = '\0';
  pHVar1->no_cache = '\0';
  pHVar1->inBASE = '\0';
  pHVar1->content_length = 0;
  return pHVar1;
}



HTChildAnchor * HTChildAnchor_new(HTParentAnchor0 *parent)

{
  HTChildAnchor *pHVar1;
  HTChildAnchor *p;
  
  pHVar1 = (HTChildAnchor *)calloc(1,0x20);
  if (pHVar1 == (HTChildAnchor *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTChildAnchor_new");
  }
  pHVar1->parent = parent;
  return pHVar1;
}



HTChildAnchor * HText_pool_ChildAnchor_new(HTParentAnchor *parent)

{
  HTChildAnchor *pHVar1;
  HTChildAnchor *p;
  
  pHVar1 = (HTChildAnchor *)HText_pool_calloc((HText *)parent->document,0x20);
  if (pHVar1 == (HTChildAnchor *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HText_pool_ChildAnchor_new");
  }
  pHVar1->parent = (HTParentAnchor0 *)parent->parent;
  return pHVar1;
}



BOOLEAN HTSEquivalent(char *s,char *t)

{
  bool local_5;
  
  if ((s == (char *)0x0) || (t == (char *)0x0)) {
    local_5 = s == t;
  }
  else {
    while ((*s != '\0' && (*t != '\0'))) {
      if (*s != *t) {
        return '\0';
      }
      s = s + 1;
      t = t + 1;
    }
    local_5 = *s == *t;
  }
  return (BOOLEAN)local_5;
}



BOOLEAN HTBEquivalent(bstring *s,bstring *t)

{
  int local_30;
  int local_2c;
  int local_28;
  char *local_24;
  char *local_1c;
  int len;
  int j;
  
  if ((s != (bstring *)0x0) && (t != (bstring *)0x0)) {
    if (s == (bstring *)0x0) {
      local_30 = 0;
    }
    else {
      local_30 = s->len;
    }
    if (t == (bstring *)0x0) {
      local_2c = 0;
    }
    else {
      local_2c = t->len;
    }
    if (local_30 == local_2c) {
      if (s == (bstring *)0x0) {
        local_28 = 0;
      }
      else {
        local_28 = s->len;
      }
      j = 0;
      while( true ) {
        if (local_28 <= j) {
          return '\x01';
        }
        if (s == (bstring *)0x0) {
          local_24 = (char *)0x0;
        }
        else {
          local_24 = s->str;
        }
        if (t == (bstring *)0x0) {
          local_1c = (char *)0x0;
        }
        else {
          local_1c = t->str;
        }
        if (local_24[j] != local_1c[j]) break;
        j = j + 1;
      }
      return '\0';
    }
  }
  return (BOOLEAN)(s == t);
}



int compare_anchors(void *l,void *r)

{
  int iVar1;
  char *b;
  char *a;
  
  iVar1 = strcmp(*(char **)((int)l + 4),*(char **)((int)r + 4));
  return iVar1;
}



HTChildAnchor * HTAnchor_findNamedChild(HTParentAnchor0 *parent,char *tag)

{
  HTParentAnchor0 *pHVar1;
  HTChildAnchor *pHVar2;
  FILE *__stream;
  HTBTree *pHVar3;
  HTChildAnchor *local_40;
  char *local_38;
  HTChildAnchor sample;
  HTChildAnchor *child;
  
  if (((parent == (HTParentAnchor0 *)0x0) || (tag == (char *)0x0)) || (*tag == '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAnchor_findNamedChild called with NULL parent.\n");
    }
    local_40 = (HTChildAnchor *)0x0;
  }
  else {
    if (parent->children == (HTBTree *)0x0) {
      pHVar3 = HTBTree_new(compare_anchors);
      parent->children = pHVar3;
    }
    else {
      sample.tag = tag;
      pHVar2 = (HTChildAnchor *)HTBTree_search(parent->children,&sample);
      if (pHVar2 != (HTChildAnchor *)0x0) {
        if (WWW_TraceFlag == '\0') {
          return pHVar2;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Child anchor %p of parent %p with name `%s\' already exists.\n",
                pHVar2,parent,tag);
        return pHVar2;
      }
    }
    local_40 = HTChildAnchor_new(parent);
    if (WWW_TraceFlag != '\0') {
      pHVar1 = local_40->parent;
      if (tag == (char *)0x0) {
        local_38 = "";
      }
      else {
        local_38 = tag;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAnchor: New Anchor %p named `%s\' is child of %p\n",local_40,
              local_38,pHVar1);
    }
    HTSACopy(&local_40->tag,tag);
    HTBTree_add(parent->children,local_40);
  }
  return local_40;
}



HTChildAnchor * HTAnchor_addChild(HTParentAnchor *parent)

{
  HTParentAnchor0 *pHVar1;
  FILE *__stream;
  HTChildAnchor *local_1c;
  HTChildAnchor *child;
  
  if (parent == (HTParentAnchor *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAnchor_addChild called with NULL parent.\n");
    }
    local_1c = (HTChildAnchor *)0x0;
  }
  else {
    local_1c = HText_pool_ChildAnchor_new(parent);
    if (WWW_TraceFlag != '\0') {
      pHVar1 = local_1c->parent;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAnchor: New unnamed Anchor %p is child of %p\n",local_1c,pHVar1);
    }
    local_1c->tag = (char *)0x0;
    HTList_linkObject((HTList *)&parent->children_notag,local_1c,
                      (HTList *)&local_1c->_add_children_notag);
  }
  return local_1c;
}



HTChildAnchor *
HTAnchor_findChildAndLink(HTParentAnchor *parent,char *tag,char *href,HTLinkType *ltype)

{
  HTAnchor *pHVar1;
  FILE *__stream;
  char *local_4c;
  char *local_48;
  char *local_44;
  char *local_40;
  char *local_3c;
  DocAddress parsed_doc;
  char *relative_to;
  HTParentAnchor0 *dest;
  char *fragment;
  HTChildAnchor *child;
  
  if (WWW_TraceFlag != '\0') {
    if (href == (char *)0x0) {
      local_4c = "";
    }
    else {
      local_4c = href;
    }
    if (ltype == HTInternalLink) {
      local_48 = " (internal link)";
    }
    else {
      local_48 = "";
    }
    if (tag == (char *)0x0) {
      local_44 = "";
    }
    else {
      local_44 = tag;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Entered HTAnchor_findChildAndLink:  tag=`%s\',%s href=`%s\'\n",
            local_44,local_48,local_4c);
  }
  if ((tag == (char *)0x0) || (*tag == '\0')) {
    child = HTAnchor_addChild(parent);
  }
  else {
    child = HTAnchor_findNamedChild((HTParentAnchor0 *)parent->parent,tag);
  }
  if ((href != (char *)0x0) && (*href != '\0')) {
    if ((ltype == HTInternalLink) && (*href == '#')) {
      dest = (HTParentAnchor0 *)parent->parent;
    }
    else {
      if ((parent->inBASE == '\0') || (*href == '#')) {
        local_40 = parent->address;
      }
      else {
        local_40 = parent->content_base;
      }
      parsed_doc.address = HTParse(href,local_40,0x1d);
      parsed_doc.post_data = (bstring *)0x0;
      parsed_doc.post_content_type = (char *)0x0;
      if (((ltype != (HTLinkType *)0x0) && (parent->post_data != (bstring *)0x0)) &&
         (ltype == HTInternalLink)) {
        parsed_doc.post_data = parent->post_data;
        parsed_doc.post_content_type = parent->post_content_type;
      }
      parsed_doc.bookmark = (char *)0x0;
      parsed_doc.isHEAD = '\0';
      parsed_doc.safe = '\0';
      dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
      if (parsed_doc.address != (char *)0x0) {
        free(parsed_doc.address);
        parsed_doc.address = (char *)0x0;
      }
    }
    if (*href == '#') {
      local_3c = href + 1;
    }
    else {
      local_3c = HTParseAnchor(href);
    }
    if (*local_3c != '\0') {
      dest = (HTParentAnchor0 *)HTAnchor_findNamedChild(dest,local_3c);
    }
    if (((tag != (char *)0x0) && (*tag != '\0')) && (child->dest != (HTAnchor *)0x0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** Duplicate ChildAnchor %p named `%s\'",child,tag);
      }
      if (((HTParentAnchor0 *)child->dest != dest) || (child->type != ltype)) {
        if (WWW_TraceFlag != '\0') {
          pHVar1 = child->dest;
          __stream = TraceFP();
          fprintf((FILE *)__stream,", different dest %p or type, creating unnamed child\n",pHVar1);
        }
        child = HTAnchor_addChild(parent);
      }
    }
    HTAnchor_link(child,(HTAnchor *)dest,ltype);
  }
  return child;
}



HTParentAnchor * HTAnchor_findAddress(DocAddress *newdoc)

{
  char *tag_00;
  FILE *__stream;
  HTParentAnchor0 *parent;
  HTParentAnchor *local_28;
  DocAddress parsed_doc;
  HTChildAnchor *foundAnchor;
  HTParentAnchor0 *foundParent;
  char *tag;
  
  tag_00 = HTParseAnchor(newdoc->address);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Entered HTAnchor_findAddress\n");
  }
  if (*tag_00 == '\0') {
    parent = HTAnchor_findAddress_in_adult_table(newdoc);
    local_28 = HTAnchor_parent((HTAnchor *)parent);
  }
  else {
    parsed_doc.address = HTParse(newdoc->address,"",0x1d);
    parsed_doc.post_data = newdoc->post_data;
    parsed_doc.post_content_type = newdoc->post_content_type;
    parsed_doc.bookmark = newdoc->bookmark;
    parsed_doc.isHEAD = newdoc->isHEAD;
    parsed_doc.safe = newdoc->safe;
    parent = HTAnchor_findAddress_in_adult_table(&parsed_doc);
    HTAnchor_findNamedChild(parent,tag_00);
    if (parsed_doc.address != (char *)0x0) {
      free(parsed_doc.address);
      parsed_doc.address = (char *)0x0;
    }
    local_28 = HTAnchor_parent((HTAnchor *)parent);
  }
  return local_28;
}



HTParentAnchor0 * HTAnchor_findAddress_in_adult_table(DocAddress *newdoc)

{
  char *pcVar1;
  bool bVar2;
  BOOLEAN BVar3;
  ushort hash_00;
  HTParentAnchor0 *parent;
  FILE *__stream;
  HTParentAnchor *pHVar4;
  HTParentAnchor0 *local_38;
  int local_34;
  char *local_30;
  HTParentAnchor *p;
  HTParentAnchor0 *foundAnchor;
  HTList *grownups;
  HTList *adults;
  ushort hash;
  BOOLEAN need_extra_info;
  
  if ((((newdoc->post_data == (bstring *)0x0) && (newdoc->post_content_type == (char *)0x0)) &&
      (newdoc->bookmark == (char *)0x0)) && ((newdoc->isHEAD == '\0' && (newdoc->safe == '\0')))) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  hash_00 = HASH_FUNCTION(newdoc->address);
  grownups = (HTList *)(adult_table + hash_00);
  while( true ) {
    if ((grownups == (HTList *)0x0) || (grownups = grownups->next, grownups == (HTList *)0x0)) {
      local_38 = (HTParentAnchor0 *)0x0;
    }
    else {
      local_38 = (HTParentAnchor0 *)grownups->object;
    }
    if (local_38 == (HTParentAnchor0 *)0x0) break;
    BVar3 = HTSEquivalent(local_38->address,newdoc->address);
    if ((BVar3 != '\0') &&
       (((local_38->info == (HTParentAnchor *)0x0 && (!bVar2)) ||
        ((local_38->info != (HTParentAnchor *)0x0 &&
         ((BVar3 = HTBEquivalent(local_38->info->post_data,newdoc->post_data), BVar3 != '\0' &&
          (local_38->info->isHEAD == newdoc->isHEAD)))))))) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = newdoc->address;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Anchor %p with address `%s\' already exists.\n",local_38,pcVar1);
      }
      return local_38;
    }
  }
  parent = HTParentAnchor0_new(newdoc->address,hash_00);
  if (WWW_TraceFlag != '\0') {
    pcVar1 = newdoc->address;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"New anchor %p has hash %d and address `%s\'\n",parent,(uint)hash_00,
            pcVar1);
  }
  if (bVar2) {
    pHVar4 = HTParentAnchor_new(parent);
    if (newdoc->post_data != (bstring *)0x0) {
      if (newdoc->post_data == (bstring *)0x0) {
        local_34 = 0;
      }
      else {
        local_34 = newdoc->post_data->len;
      }
      if (newdoc->post_data == (bstring *)0x0) {
        local_30 = (char *)0x0;
      }
      else {
        local_30 = newdoc->post_data->str;
      }
      HTSABCopy(&pHVar4->post_data,local_30,local_34);
    }
    if (newdoc->post_content_type != (char *)0x0) {
      HTSACopy(&pHVar4->post_content_type,newdoc->post_content_type);
    }
    if (newdoc->bookmark != (char *)0x0) {
      HTSACopy(&pHVar4->bookmark,newdoc->bookmark);
    }
    pHVar4->isHEAD = newdoc->isHEAD;
    pHVar4->safe = newdoc->safe;
  }
  HTList_linkObject((HTList *)(adult_table + hash_00),parent,(HTList *)&parent->_add_adult);
  return parent;
}



HTParentAnchor * HTAnchor_findSimpleAddress(char *url)

{
  HTParentAnchor *pHVar1;
  DocAddress urldoc;
  
  urldoc.address = url;
  urldoc.post_data = (bstring *)0x0;
  urldoc.post_content_type = (char *)0x0;
  urldoc.bookmark = (char *)0x0;
  urldoc.isHEAD = '\0';
  urldoc.safe = '\0';
  pHVar1 = HTAnchor_findAddress(&urldoc);
  return pHVar1;
}



BOOLEAN HTAnchor_link(HTChildAnchor *child,HTAnchor *destination,HTLinkType *type)

{
  FILE *__stream;
  BOOLEAN local_5;
  
  if ((child == (HTChildAnchor *)0x0) || (destination == (HTAnchor *)0x0)) {
    local_5 = '\0';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Linking child %p to anchor %p\n",child,destination);
    }
    if (child->dest == (HTAnchor *)0x0) {
      child->dest = destination;
      child->type = type;
      if (child->parent != destination->parent) {
        HTList_linkObject((HTList *)&destination->parent->sources,child,
                          (HTList *)&child->_add_sources);
      }
      local_5 = '\x01';
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** child anchor already has destination, exiting!\n");
      }
      local_5 = '\0';
    }
  }
  return local_5;
}



void deleteLinks(HTChildAnchor *me)

{
  HTParentAnchor0 *me_00;
  HTParentAnchor0 *parent;
  
  if (me->dest != (HTAnchor *)0x0) {
    me_00 = me->dest->parent;
    me->dest = (HTAnchor *)0x0;
    if ((me->parent != me_00) && ((me_00->sources).next != (HTList *)0x0)) {
      HTList_unlinkObject((HTList *)&me_00->sources,me);
    }
    if (((me->parent != me_00) && (me_00->underway == '\0')) &&
       ((me_00->info == (HTParentAnchor *)0x0 || (me_00->info->document == (HyperDoc *)0x0)))) {
      HTAnchor_delete(me_00);
    }
    me->type = (HTLinkType *)0x0;
  }
  return;
}



BOOLEAN HTAnchor_delete(HTParentAnchor0 *me)

{
  void *__ptr;
  BOOLEAN local_15;
  HTChildAnchor *child;
  HTBTElement *ele;
  
  if (me == (HTParentAnchor0 *)0x0) {
    local_15 = '\0';
  }
  else {
    if ((me->underway == '\0') &&
       ((me->info == (HTParentAnchor *)0x0 || (me->info->document == (HyperDoc *)0x0)))) {
      me->underway = '\x01';
      if (me->children != (HTBTree *)0x0) {
        ele = HTBTree_next(me->children,(HTBTElement *)0x0);
        while (ele != (HTBTElement *)0x0) {
          if (((HTChildAnchor *)ele->object)->dest != (HTAnchor *)0x0) {
            deleteLinks((HTChildAnchor *)ele->object);
          }
          ele = HTBTree_next(me->children,ele);
        }
      }
      me->underway = '\0';
      if ((me->sources).next == (HTList *)0x0) {
        if (me->children != (HTBTree *)0x0) {
          ele = HTBTree_next(me->children,(HTBTElement *)0x0);
          while (ele != (HTBTElement *)0x0) {
            __ptr = ele->object;
            if (*(int *)((int)__ptr + 4) != 0) {
              free(*(void **)((int)__ptr + 4));
              *(undefined4 *)((int)__ptr + 4) = 0;
            }
            if (__ptr != (void *)0x0) {
              free(__ptr);
            }
            ele = HTBTree_next(me->children,ele);
          }
          HTBTree_free(me->children);
        }
        if (me->info != (HTParentAnchor *)0x0) {
          HTParentAnchor_free(me->info);
          if (me->info != (HTParentAnchor *)0x0) {
            free(me->info);
            me->info = (HTParentAnchor *)0x0;
          }
        }
        HTList_unlinkObject((HTList *)(adult_table + me->adult_hash),me);
        if (me->address != (char *)0x0) {
          free(me->address);
          me->address = (char *)0x0;
        }
        if (me != (HTParentAnchor0 *)0x0) {
          free(me);
        }
        local_15 = '\x01';
      }
      else {
        local_15 = '\0';
      }
    }
    else {
      local_15 = '\0';
    }
  }
  return local_15;
}



void HTAnchor_delete_links(HTParentAnchor *me)

{
  HTChildAnchor *me_00;
  HTChildAnchor *child;
  HTList *cur;
  
  if ((me != (HTParentAnchor *)0x0) && (me->document != (HyperDoc *)0x0)) {
    me->parent->underway = '\x01';
    if ((me->children_notag).next != (HTList *)0x0) {
      while( true ) {
        me_00 = (HTChildAnchor *)HTList_unlinkLastObject((HTList *)&me->children_notag);
        if (me_00 == (HTChildAnchor *)0x0) break;
        deleteLinks(me_00);
      }
    }
    me->parent->underway = '\0';
  }
  return;
}



void HTParentAnchor_free(HTParentAnchor *me)

{
  FILE *__stream;
  FILE *fd;
  
  if (me->methods != (HTList *)0x0) {
    HTList_delete(me->methods);
    me->methods = (HTList *)0x0;
  }
  if (me->charset != (char *)0x0) {
    free(me->charset);
    me->charset = (char *)0x0;
  }
  if (me->isIndexAction != (char *)0x0) {
    free(me->isIndexAction);
    me->isIndexAction = (char *)0x0;
  }
  if (me->isIndexPrompt != (char *)0x0) {
    free(me->isIndexPrompt);
    me->isIndexPrompt = (char *)0x0;
  }
  if (me->title != (char *)0x0) {
    free(me->title);
    me->title = (char *)0x0;
  }
  if (me->physical != (char *)0x0) {
    free(me->physical);
    me->physical = (char *)0x0;
  }
  HTSABFree(&me->post_data);
  if (me->post_content_type != (char *)0x0) {
    free(me->post_content_type);
    me->post_content_type = (char *)0x0;
  }
  if (me->bookmark != (char *)0x0) {
    free(me->bookmark);
    me->bookmark = (char *)0x0;
  }
  if (me->owner != (char *)0x0) {
    free(me->owner);
    me->owner = (char *)0x0;
  }
  if (me->RevTitle != (char *)0x0) {
    free(me->RevTitle);
    me->RevTitle = (char *)0x0;
  }
  if (me->citehost != (char *)0x0) {
    free(me->citehost);
    me->citehost = (char *)0x0;
  }
  HTAnchor_clearSourceCache(me);
  if (me->FileCache != (char *)0x0) {
    __stream = fopen64(me->FileCache,"r");
    if (__stream != (FILE *)0x0) {
      fclose(__stream);
      remove(me->FileCache);
    }
    if (me->FileCache != (char *)0x0) {
      free(me->FileCache);
      me->FileCache = (char *)0x0;
    }
  }
  if (me->SugFname != (char *)0x0) {
    free(me->SugFname);
    me->SugFname = (char *)0x0;
  }
  if (me->cache_control != (char *)0x0) {
    free(me->cache_control);
    me->cache_control = (char *)0x0;
  }
  if (me->content_type_params != (char *)0x0) {
    free(me->content_type_params);
    me->content_type_params = (char *)0x0;
  }
  if (me->content_type != (char *)0x0) {
    free(me->content_type);
    me->content_type = (char *)0x0;
  }
  if (me->content_language != (char *)0x0) {
    free(me->content_language);
    me->content_language = (char *)0x0;
  }
  if (me->content_encoding != (char *)0x0) {
    free(me->content_encoding);
    me->content_encoding = (char *)0x0;
  }
  if (me->content_base != (char *)0x0) {
    free(me->content_base);
    me->content_base = (char *)0x0;
  }
  if (me->content_disposition != (char *)0x0) {
    free(me->content_disposition);
    me->content_disposition = (char *)0x0;
  }
  if (me->content_location != (char *)0x0) {
    free(me->content_location);
    me->content_location = (char *)0x0;
  }
  if (me->content_md5 != (char *)0x0) {
    free(me->content_md5);
    me->content_md5 = (char *)0x0;
  }
  if (me->message_id != (char *)0x0) {
    free(me->message_id);
    me->message_id = (char *)0x0;
  }
  if (me->subject != (char *)0x0) {
    free(me->subject);
    me->subject = (char *)0x0;
  }
  if (me->date != (char *)0x0) {
    free(me->date);
    me->date = (char *)0x0;
  }
  if (me->expires != (char *)0x0) {
    free(me->expires);
    me->expires = (char *)0x0;
  }
  if (me->last_modified != (char *)0x0) {
    free(me->last_modified);
    me->last_modified = (char *)0x0;
  }
  if (me->ETag != (char *)0x0) {
    free(me->ETag);
    me->ETag = (char *)0x0;
  }
  if (me->server != (char *)0x0) {
    free(me->server);
    me->server = (char *)0x0;
  }
  if (me->style != (char *)0x0) {
    free(me->style);
    me->style = (char *)0x0;
  }
  if (me->UCStages != (UCAnchorInfo *)0x0) {
    free(me->UCStages);
    me->UCStages = (UCAnchorInfo *)0x0;
  }
  ImageMapList_free(me->imaps);
  return;
}



void HTAnchor_clearSourceCache(HTParentAnchor *me)

{
  char *pcVar1;
  HTChunk *pHVar2;
  FILE *__stream;
  
  if (me->source_cache_file != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pcVar1 = me->source_cache_file;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SourceCache: Removing file %s\n",pcVar1);
    }
    LYRemoveTemp(me->source_cache_file);
    if (me->source_cache_file != (char *)0x0) {
      free(me->source_cache_file);
      me->source_cache_file = (char *)0x0;
    }
  }
  if (me->source_cache_chunk != (HTChunk *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pHVar2 = me->source_cache_chunk;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"SourceCache: Removing memory chunk %p\n",pHVar2);
    }
    HTChunkFree(me->source_cache_chunk);
    me->source_cache_chunk = (HTChunk *)0x0;
  }
  return;
}



HTParentAnchor * HTAnchor_parent(HTAnchor *me)

{
  HTParentAnchor *local_8;
  
  if (me == (HTAnchor *)0x0) {
    local_8 = (HTParentAnchor *)0x0;
  }
  else {
    if (me->parent->info == (HTParentAnchor *)0x0) {
      local_8 = HTParentAnchor_new(me->parent);
    }
    else {
      local_8 = me->parent->info;
    }
  }
  return local_8;
}



void HTAnchor_setDocument(HTParentAnchor *me,HyperDoc *doc)

{
  if (me != (HTParentAnchor *)0x0) {
    me->document = doc;
  }
  return;
}



HyperDoc * HTAnchor_document(HTParentAnchor *me)

{
  HyperDoc *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (HyperDoc *)0x0;
  }
  else {
    local_8 = me->document;
  }
  return local_8;
}



char * HTAnchor_address(HTAnchor *me)

{
  char *addr;
  
  addr = (char *)0x0;
  if (me != (HTAnchor *)0x0) {
    if (((me->parent == (HTParentAnchor0 *)me) || (me->parent->info == (HTParentAnchor *)me)) ||
       (me[1].parent == (HTParentAnchor0 *)0x0)) {
      HTSACopy(&addr,me->parent->address);
    }
    else {
      HTSprintf0(&addr,"%s#%s",me->parent->address,me[1].parent);
    }
  }
  return addr;
}



void HTAnchor_setFormat(HTParentAnchor *me,HTFormat form)

{
  if (me != (HTParentAnchor *)0x0) {
    me->format = form;
  }
  return;
}



HTFormat HTAnchor_format(HTParentAnchor *me)

{
  HTFormat local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (HTFormat)0x0;
  }
  else {
    local_8 = me->format;
  }
  return local_8;
}



void HTAnchor_setIndex(HTParentAnchor *me,char *address)

{
  if (me != (HTParentAnchor *)0x0) {
    me->isIndex = '\x01';
    HTSACopy(&me->isIndexAction,address);
  }
  return;
}



void HTAnchor_setPrompt(HTParentAnchor *me,char *prompt)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->isIndexPrompt,prompt);
  }
  return;
}



BOOLEAN HTAnchor_isIndex(HTParentAnchor *me)

{
  BOOLEAN local_5;
  
  if (me == (HTParentAnchor *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = me->isIndex;
  }
  return local_5;
}



BOOLEAN HTAnchor_isISMAPScript(HTAnchor *me)

{
  BOOLEAN local_5;
  
  if ((me == (HTAnchor *)0x0) || (me->parent->info == (HTParentAnchor *)0x0)) {
    local_5 = '\0';
  }
  else {
    local_5 = me->parent->info->isISMAPScript;
  }
  return local_5;
}



char * HTAnchor_style(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->style;
  }
  return local_8;
}



void HTAnchor_setStyle(HTParentAnchor *me,char *style)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->style,style);
  }
  return;
}



char * HTAnchor_title(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->title;
  }
  return local_8;
}



void HTAnchor_setTitle(HTParentAnchor *me,char *title)

{
  char *pcVar1;
  FILE *__stream;
  int i;
  
  if (me != (HTParentAnchor *)0x0) {
    if (title == (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTAnchor_setTitle: New title is NULL! ");
      }
      if (me->title == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Old title was NULL.\n");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = me->title;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Old title was \"%s\".\n",pcVar1);
        }
        if (me->title != (char *)0x0) {
          free(me->title);
          me->title = (char *)0x0;
        }
      }
    }
    else {
      HTSACopy(&me->title,title);
      i = 0;
      while (me->title[i] != '\0') {
        if ((me->title[i] == '\x01') || (me->title[i] == '\x02')) {
          me->title[i] = ' ';
        }
        i = i + 1;
      }
    }
  }
  return;
}



void HTAnchor_appendTitle(HTParentAnchor *me,char *title)

{
  int i;
  
  if (me != (HTParentAnchor *)0x0) {
    HTSACat(&me->title,title);
    i = 0;
    while (me->title[i] != '\0') {
      if ((me->title[i] == '\x01') || (me->title[i] == '\x02')) {
        me->title[i] = ' ';
      }
      i = i + 1;
    }
  }
  return;
}



char * HTAnchor_bookmark(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->bookmark;
  }
  return local_8;
}



void HTAnchor_setBookmark(HTParentAnchor *me,char *bookmark)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->bookmark,bookmark);
  }
  return;
}



char * HTAnchor_owner(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->owner;
  }
  return local_8;
}



void HTAnchor_setOwner(HTParentAnchor *me,char *owner)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->owner,owner);
  }
  return;
}



char * HTAnchor_RevTitle(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->RevTitle;
  }
  return local_8;
}



void HTAnchor_setRevTitle(HTParentAnchor *me,char *title)

{
  int i;
  
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->RevTitle,title);
    i = 0;
    while (me->RevTitle[i] != '\0') {
      if ((me->RevTitle[i] == '\x01') || (me->RevTitle[i] == '\x02')) {
        me->RevTitle[i] = ' ';
      }
      i = i + 1;
    }
  }
  return;
}



char * HTAnchor_citehost(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->citehost;
  }
  return local_8;
}



void HTAnchor_setCitehost(HTParentAnchor *me,char *citehost)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->citehost,citehost);
  }
  return;
}



char * HTAnchor_SugFname(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->SugFname;
  }
  return local_8;
}



char * HTAnchor_content_type_params(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_type_params;
  }
  return local_8;
}



char * HTAnchor_content_encoding(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_encoding;
  }
  return local_8;
}



char * HTAnchor_content_type(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_type;
  }
  return local_8;
}



char * HTAnchor_last_modified(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->last_modified;
  }
  return local_8;
}



char * HTAnchor_date(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->date;
  }
  return local_8;
}



char * HTAnchor_server(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->server;
  }
  return local_8;
}



BOOLEAN HTAnchor_safe(HTParentAnchor *me)

{
  BOOLEAN local_5;
  
  if (me == (HTParentAnchor *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = me->safe;
  }
  return local_5;
}



char * HTAnchor_content_base(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_base;
  }
  return local_8;
}



char * HTAnchor_content_location(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_location;
  }
  return local_8;
}



char * HTAnchor_messageID(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->message_id;
  }
  return local_8;
}



BOOLEAN HTAnchor_setMessageID(HTParentAnchor *me,char *messageid)

{
  BOOLEAN local_5;
  
  if (((me == (HTParentAnchor *)0x0) || (messageid == (char *)0x0)) || (*messageid == '\0')) {
    local_5 = '\0';
  }
  else {
    HTSACopy(&me->message_id,messageid);
    local_5 = '\x01';
  }
  return local_5;
}



char * HTAnchor_subject(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->subject;
  }
  return local_8;
}



BOOLEAN HTAnchor_setSubject(HTParentAnchor *me,char *subject)

{
  BOOLEAN local_5;
  
  if (((me == (HTParentAnchor *)0x0) || (subject == (char *)0x0)) || (*subject == '\0')) {
    local_5 = '\0';
  }
  else {
    HTSACopy(&me->subject,subject);
    local_5 = '\x01';
  }
  return local_5;
}



HTAnchor * HTAnchor_followLink(HTChildAnchor *me)

{
  return me->dest;
}



HTAnchor * HTAnchor_followTypedLink(HTChildAnchor *me,HTLinkType *type)

{
  HTAnchor *local_8;
  
  if (me->type == type) {
    local_8 = me->dest;
  }
  else {
    local_8 = (HTAnchor *)0x0;
  }
  return local_8;
}



HTList * HTAnchor_methods(HTParentAnchor *me)

{
  HTList *pHVar1;
  
  if (me->methods == (HTList *)0x0) {
    pHVar1 = HTList_new();
    me->methods = pHVar1;
  }
  return me->methods;
}



void * HTAnchor_protocol(HTParentAnchor *me)

{
  return me->protocol;
}



void HTAnchor_setProtocol(HTParentAnchor *me,void *protocol)

{
  me->protocol = protocol;
  return;
}



char * HTAnchor_physical(HTParentAnchor *me)

{
  return me->physical;
}



void HTAnchor_setPhysical(HTParentAnchor *me,char *physical)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->physical,physical);
  }
  return;
}



LYUCcharset * HTAnchor_getUCInfoStage(HTParentAnchor *me,int which_stage)

{
  UCAnchorInfo *pUVar1;
  LYUCcharset *local_18;
  UCAnchorInfo *stages;
  int chndl;
  int i;
  
  if ((me != (HTParentAnchor *)0x0) && (me->UCStages == (UCAnchorInfo *)0x0)) {
    chndl = UCLYhndl_for_unspec;
    pUVar1 = (UCAnchorInfo *)calloc(1,0xa0);
    if (pUVar1 == (UCAnchorInfo *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTAnchor_getUCInfoStage");
    }
    i = 0;
    while (i < 4) {
      pUVar1->s[i].C.MIMEname = "";
      pUVar1->s[i].LYhndl = -1;
      i = i + 1;
    }
    if (me->charset != (char *)0x0) {
      chndl = UCGetLYhndl_byMIME(me->charset);
      if (chndl < 0) {
        chndl = UCLYhndl_for_unrec;
      }
      if (chndl < 0) {
        chndl = UCLYhndl_for_unspec;
      }
    }
    memcpy(&pUVar1->s[0].C,LYCharSet_UC + chndl,0x20);
    pUVar1->s[0].lock = 1;
    pUVar1->s[0].LYhndl = chndl;
    me->UCStages = pUVar1;
  }
  if (me == (HTParentAnchor *)0x0) {
    local_18 = (LYUCcharset *)0x0;
  }
  else {
    local_18 = &me->UCStages->s[which_stage].C;
  }
  return local_18;
}



int HTAnchor_getUCLYhndl(HTParentAnchor *me,int which_stage)

{
  if (me != (HTParentAnchor *)0x0) {
    if (me->UCStages == (UCAnchorInfo *)0x0) {
      HTAnchor_getUCInfoStage(me,which_stage);
    }
    if (0 < me->UCStages->s[which_stage].lock) {
      return me->UCStages->s[which_stage].LYhndl;
    }
  }
  return -1;
}



LYUCcharset * HTAnchor_setUCInfoStage(HTParentAnchor *me,int LYhndl,int which_stage,int set_by)

{
  LYUCcharset *local_18;
  LYUCcharset *p;
  
  if ((me == (HTParentAnchor *)0x0) ||
     (local_18 = HTAnchor_getUCInfoStage(me,which_stage), set_by < me->UCStages->s[which_stage].lock
     )) {
    local_18 = (LYUCcharset *)0x0;
  }
  else {
    me->UCStages->s[which_stage].lock = set_by;
    me->UCStages->s[which_stage].LYhndl = LYhndl;
    if (LYhndl < 0) {
      local_18->UChndl = -1;
    }
    else {
      memcpy(local_18,LYCharSet_UC + LYhndl,0x20);
    }
  }
  return local_18;
}



LYUCcharset * HTAnchor_resetUCInfoStage(HTParentAnchor *me,int LYhndl,int which_stage,int set_by)

{
  LYUCcharset *local_18;
  int ohandle;
  
  if ((me == (HTParentAnchor *)0x0) || (me->UCStages == (UCAnchorInfo *)0x0)) {
    local_18 = (LYUCcharset *)0x0;
  }
  else {
    me->UCStages->s[which_stage].lock = set_by;
    me->UCStages->s[which_stage].LYhndl = LYhndl;
    local_18 = &me->UCStages->s[which_stage].C;
  }
  return local_18;
}



LYUCcharset * HTAnchor_copyUCInfoStage(HTParentAnchor *me,int to_stage,int from_stage,int set_by)

{
  LYUCcharset *__src;
  LYUCcharset *__dest;
  LYUCcharset *p_to;
  LYUCcharset *p_from;
  
  if (me != (HTParentAnchor *)0x0) {
    __src = HTAnchor_getUCInfoStage(me,from_stage);
    __dest = HTAnchor_getUCInfoStage(me,to_stage);
    if (set_by == -1) {
      set_by = me->UCStages->s[from_stage].lock;
    }
    if (set_by == 0) {
      set_by = 1;
    }
    if (me->UCStages->s[to_stage].lock <= set_by) {
      me->UCStages->s[to_stage].lock = set_by;
      me->UCStages->s[to_stage].LYhndl = me->UCStages->s[from_stage].LYhndl;
      if (__dest == __src) {
        return __dest;
      }
      memcpy(__dest,__src,0x20);
      return __dest;
    }
  }
  return (LYUCcharset *)0x0;
}



HTStyle * HTStyleNew(void)

{
  HTStyle *pHVar1;
  HTStyle *self;
  
  pHVar1 = (HTStyle *)calloc(1,0x50);
  if (pHVar1 == (HTStyle *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTStyle.c","HTStyleNew");
  }
  return pHVar1;
}



HTStyle * HTStyleNewNamed(char *name)

{
  HTStyle *pHVar1;
  HTStyle *self;
  
  pHVar1 = HTStyleNew();
  HTSACopy(&pHVar1->name,name);
  pHVar1->id = -1;
  return pHVar1;
}



HTStyle * HTStyleFree(HTStyle *self)

{
  if (self->name != (char *)0x0) {
    free(self->name);
    self->name = (char *)0x0;
  }
  if (self->SGMLTag != (char *)0x0) {
    free(self->SGMLTag);
    self->SGMLTag = (char *)0x0;
  }
  if (self != (HTStyle *)0x0) {
    free(self);
  }
  return (HTStyle *)0x0;
}



HTStyle * HTStyleNamed(HTStyleSheet *self,char *name)

{
  int iVar1;
  FILE *__stream;
  HTStyle *scan;
  
  scan = self->styles;
  while( true ) {
    if (scan == (HTStyle *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"StyleSheet: No style named `%s\'\n",name);
      }
      return (HTStyle *)0x0;
    }
    iVar1 = strcmp(scan->name,name);
    if (iVar1 == 0) break;
    scan = (HTStyle *)scan->next;
  }
  return scan;
}



HTStyleSheet * HTStyleSheetAddStyle(HTStyleSheet *self,HTStyle *style)

{
  HTStyle *scan;
  
  style->next = (_HTStyle *)0x0;
  if (self->styles == (HTStyle *)0x0) {
    self->styles = style;
  }
  else {
    scan = self->styles;
    while (scan->next != (_HTStyle *)0x0) {
      scan = (HTStyle *)scan->next;
    }
    *(HTStyle **)&scan->next = style;
  }
  return self;
}



HTStyleSheet * HTStyleSheetRemoveStyle(HTStyleSheet *self,HTStyle *style)

{
  HTStyleSheet *local_18;
  HTStyle *scan;
  
  if (self->styles == style) {
    self->styles = (HTStyle *)style->next;
    local_18 = self;
  }
  else {
    scan = self->styles;
    while (scan != (HTStyle *)0x0) {
      if ((HTStyle *)scan->next == style) {
        scan->next = style->next;
        return self;
      }
      scan = (HTStyle *)scan->next;
    }
    local_18 = (HTStyleSheet *)0x0;
  }
  return local_18;
}



HTStyleSheet * HTStyleSheetNew(void)

{
  HTStyleSheet *pHVar1;
  HTStyleSheet *self;
  
  pHVar1 = (HTStyleSheet *)calloc(1,8);
  if (pHVar1 == (HTStyleSheet *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTStyle.c","HTStyleSheetNew");
  }
  return pHVar1;
}



HTStyleSheet * HTStyleSheetFree(HTStyleSheet *self)

{
  HTStyle *self_00;
  HTStyle *style;
  
  while (self_00 = self->styles, self_00 != (HTStyle *)0x0) {
    *(_HTStyle **)&self->styles = self_00->next;
    HTStyleFree(self_00);
  }
  if (self != (HTStyleSheet *)0x0) {
    free(self);
  }
  return (HTStyleSheet *)0x0;
}



HTList * HTList_new(void)

{
  HTList *pHVar1;
  HTList *newList;
  
  pHVar1 = (HTList *)malloc(8);
  if (pHVar1 == (HTList *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTList.c","HTList_new");
  }
  pHVar1->object = (void *)0x0;
  pHVar1->next = (HTList *)0x0;
  return pHVar1;
}



void HTList_delete(HTList *me)

{
  HTList *pHVar1;
  HTList *current;
  
  pHVar1 = me;
  while (me = pHVar1, me != (HTList *)0x0) {
    pHVar1 = me->next;
    if (me != (HTList *)0x0) {
      free(me);
    }
  }
  return;
}



HTList * HTList_reverse(HTList *start)

{
  HTList *pHVar1;
  HTList *succ;
  HTList *cur;
  
  if (((start != (HTList *)0x0) && (start->next != (HTList *)0x0)) &&
     (cur = start->next->next, cur != (HTList *)0x0)) {
    start->next->next = (HTList *)0x0;
    while (cur != (HTList *)0x0) {
      pHVar1 = cur->next;
      cur->next = start->next;
      start->next = cur;
      cur = pHVar1;
    }
  }
  return start;
}



HTList * HTList_appendList(HTList *start,HTList *tail)

{
  FILE *__stream;
  HTList *local_18;
  HTList *temp;
  
  temp = start;
  if (start == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Trying to append list %p to a nonexisting list\n",tail);
    }
    local_18 = (HTList *)0x0;
  }
  else {
    if ((tail == (HTList *)0x0) || (tail->next == (HTList *)0x0)) {
      local_18 = start;
    }
    else {
      while (temp->next != (HTList *)0x0) {
        temp = temp->next;
      }
      temp->next = tail->next;
      tail->next = (HTList *)0x0;
      local_18 = start;
    }
  }
  return local_18;
}



void HTList_linkObject(HTList *me,void *newObject,HTList *newNode)

{
  FILE *__stream;
  
  if (me == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Trying to link object %p to a nonexisting list\n",newObject)
      ;
    }
  }
  else {
    if ((newNode->object == (void *)0x0) && (newNode->next == (HTList *)0x0)) {
      newNode->object = newObject;
      newNode->next = me->next;
      me->next = newNode;
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** HTList: Refuse linking already linked obj ");
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%p, node %p, list %p\n",newObject,newNode,me);
      }
    }
  }
  return;
}



void HTList_addObject(HTList *me,void *newObject)

{
  HTList *pHVar1;
  FILE *__stream;
  HTList *newNode;
  
  if (me == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Trying to add object %p to a nonexisting list\n",newObject);
    }
  }
  else {
    pHVar1 = (HTList *)malloc(8);
    if (pHVar1 == (HTList *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTList.c","HTList_addObject");
    }
    pHVar1->object = newObject;
    pHVar1->next = me->next;
    me->next = pHVar1;
  }
  return;
}



void HTList_appendObject(HTList *me,void *newObject)

{
  HTList *temp;
  
  temp = me;
  if ((me != (HTList *)0x0) && (newObject != (void *)0x0)) {
    while (temp->next != (HTList *)0x0) {
      temp = temp->next;
    }
    HTList_addObject(temp,newObject);
  }
  return;
}



void HTList_insertObjectAt(HTList *me,void *newObject,int pos)

{
  HTList *pHVar1;
  FILE *__stream;
  HTList *pHVar2;
  int Pos;
  HTList *prevNode;
  HTList *temp;
  HTList *newNode;
  
  temp = me;
  Pos = pos;
  if (me == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Trying to add object %p to a nonexisting list\n",newObject);
    }
  }
  else {
    if ((pos < 0) && (Pos = 0, WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Treating negative object position %d as %d.\n",pos,0);
    }
    while (pHVar1 = temp->next, pHVar1 != (HTList *)0x0) {
      if (Pos == 0) {
        pHVar2 = (HTList *)malloc(8);
        if (pHVar2 == (HTList *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTList.c","HTList_addObjectAt");
        }
        pHVar2->object = newObject;
        pHVar2->next = pHVar1;
        if (temp == (HTList *)0x0) {
          return;
        }
        temp->next = pHVar2;
        return;
      }
      Pos = Pos + -1;
      temp = pHVar1;
    }
    if (-1 < Pos) {
      HTList_addObject(temp,newObject);
    }
  }
  return;
}



BOOLEAN HTList_unlinkObject(HTList *me,void *oldObject)

{
  HTList *pHVar1;
  BOOLEAN local_15;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  if ((me == (HTList *)0x0) || (pHVar1 = temp, oldObject == (void *)0x0)) {
LAB_08127d08:
    local_15 = '\0';
  }
  else {
    do {
      temp = pHVar1;
      if (temp->next == (HTList *)0x0) goto LAB_08127d08;
      pHVar1 = temp->next;
    } while (pHVar1->object != oldObject);
    temp->next = pHVar1->next;
    pHVar1->next = (HTList *)0x0;
    pHVar1->object = (void *)0x0;
    local_15 = '\x01';
  }
  return local_15;
}



BOOLEAN HTList_removeObject(HTList *me,void *oldObject)

{
  HTList *__ptr;
  BOOLEAN local_15;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  if ((me == (HTList *)0x0) || (__ptr = temp, oldObject == (void *)0x0)) {
LAB_08127d79:
    local_15 = '\0';
  }
  else {
    do {
      temp = __ptr;
      if (temp->next == (HTList *)0x0) goto LAB_08127d79;
      __ptr = temp->next;
    } while (__ptr->object != oldObject);
    temp->next = __ptr->next;
    if (__ptr != (HTList *)0x0) {
      free(__ptr);
    }
    local_15 = '\x01';
  }
  return local_15;
}



void * HTList_removeObjectAt(HTList *me,int position)

{
  HTList *__ptr;
  int pos;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  pos = position;
  if ((me != (HTList *)0x0) && (-1 < position)) {
    while (__ptr = temp->next, __ptr != (HTList *)0x0) {
      if (pos == 0) {
        temp->next = __ptr->next;
        if (__ptr != (HTList *)0x0) {
          free(__ptr);
        }
        return __ptr->object;
      }
      pos = pos + -1;
      temp = __ptr;
    }
  }
  return (void *)0x0;
}



void * HTList_unlinkLastObject(HTList *me)

{
  HTList *pHVar1;
  void *local_18;
  void *lastObject;
  HTList *lastNode;
  
  if ((me == (HTList *)0x0) || (me->next == (HTList *)0x0)) {
    local_18 = (void *)0x0;
  }
  else {
    pHVar1 = me->next;
    local_18 = pHVar1->object;
    me->next = pHVar1->next;
    pHVar1->next = (HTList *)0x0;
    pHVar1->object = (void *)0x0;
  }
  return local_18;
}



void * HTList_removeLastObject(HTList *me)

{
  HTList *__ptr;
  void *local_18;
  void *lastObject;
  HTList *lastNode;
  
  if ((me == (HTList *)0x0) || (me->next == (HTList *)0x0)) {
    local_18 = (void *)0x0;
  }
  else {
    __ptr = me->next;
    local_18 = __ptr->object;
    me->next = __ptr->next;
    if (__ptr != (HTList *)0x0) {
      free(__ptr);
    }
  }
  return local_18;
}



void * HTList_removeFirstObject(HTList *me)

{
  void *local_18;
  void *firstObject;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  if (me == (HTList *)0x0) {
    local_18 = (void *)0x0;
  }
  else {
    prevNode = me;
    if (me->next == (HTList *)0x0) {
      local_18 = (void *)0x0;
    }
    else {
      while (temp->next != (HTList *)0x0) {
        prevNode = temp;
        temp = temp->next;
      }
      local_18 = temp->object;
      prevNode->next = (HTList *)0x0;
      if (temp != (HTList *)0x0) {
        free(temp);
      }
    }
  }
  return local_18;
}



int HTList_count(HTList *me)

{
  int count;
  HTList *temp;
  
  temp = me;
  count = 0;
  if (me != (HTList *)0x0) {
    while (temp = temp->next, temp != (HTList *)0x0) {
      count = count + 1;
    }
  }
  return count;
}



int HTList_indexOf(HTList *me,void *object)

{
  int position;
  HTList *temp;
  
  temp = me;
  position = 0;
  if (me != (HTList *)0x0) {
    while (temp = temp->next, temp != (HTList *)0x0) {
      if (temp->object == object) {
        return position;
      }
      position = position + 1;
    }
  }
  return -1;
}



void * HTList_objectAt(HTList *me,int position)

{
  int pos;
  HTList *temp;
  
  temp = me;
  pos = position;
  if ((me != (HTList *)0x0) && (-1 < position)) {
    while (temp = temp->next, temp != (HTList *)0x0) {
      if (pos == 0) {
        return temp->object;
      }
      pos = pos + -1;
    }
  }
  return (void *)0x0;
}



int strcasecomp8(char *a,char *b)

{
  int iVar1;
  int local_18;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while ((*p != '\0' && (*q != '\0'))) {
    iVar1 = UPPER8((int)*p,(int)*q);
    if (iVar1 != 0) {
      return iVar1;
    }
    p = p + 1;
    q = q + 1;
  }
  if (*p == '\0') {
    if (*q == '\0') {
      local_18 = 0;
    }
    else {
      local_18 = -1;
    }
  }
  else {
    local_18 = 1;
  }
  return local_18;
}



int strncasecomp8(char *a,char *b,int n)

{
  int iVar1;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while( true ) {
    if (a + n == p) {
      return 0;
    }
    if ((*p == '\0') || (*q == '\0')) break;
    iVar1 = UPPER8((int)*p,(int)*q);
    if (iVar1 != 0) {
      return iVar1;
    }
    p = p + 1;
    q = q + 1;
  }
  return (int)*p - (int)*q;
}



int strcasecomp(char *a,char *b)

{
  ushort **ppuVar1;
  uint local_20;
  uint local_1c;
  int local_18;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while( true ) {
    if ((*p == '\0') || (*q == '\0')) {
      if (*p == '\0') {
        if (*q == '\0') {
          local_18 = 0;
        }
        else {
          local_18 = -1;
        }
      }
      else {
        local_18 = 1;
      }
      return local_18;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_20 = (uint)(byte)*p;
    }
    else {
      local_20 = tolower((uint)(byte)*p);
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*q] & 0x100) == 0) {
      local_1c = (uint)(byte)*q;
    }
    else {
      local_1c = tolower((uint)(byte)*q);
    }
    if (local_20 - local_1c != 0) break;
    p = p + 1;
    q = q + 1;
  }
  return local_20 - local_1c;
}



int strncasecomp(char *a,char *b,int n)

{
  ushort **ppuVar1;
  uint local_1c;
  uint local_18;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while( true ) {
    if (a + n == p) {
      return 0;
    }
    if ((*p == '\0') || (*q == '\0')) break;
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_1c = (uint)(byte)*p;
    }
    else {
      local_1c = tolower((uint)(byte)*p);
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*q] & 0x100) == 0) {
      local_18 = (uint)(byte)*q;
    }
    else {
      local_18 = tolower((uint)(byte)*q);
    }
    if (local_1c - local_18 != 0) {
      return local_1c - local_18;
    }
    p = p + 1;
    q = q + 1;
  }
  return (int)*p - (int)*q;
}



int strcasecomp_asterisk(char *a,char *b)

{
  int iVar1;
  ushort **ppuVar2;
  bool bVar3;
  uint local_1c;
  uint local_18;
  int done;
  int result;
  char *p;
  
  result = 0;
  bVar3 = false;
  do {
    if (result != 0) {
      return result;
    }
    if (bVar3) {
      return 0;
    }
    if (*a == '*') {
      p = b;
      while ((*p != '.' && (*p != '\0'))) {
        iVar1 = strcasecomp_asterisk(a + 1,p);
        if (iVar1 == 0) {
          b = p + -1;
          result = 0;
          bVar3 = true;
          goto LAB_08128520;
        }
        p = p + 1;
      }
      if ((a[1] == '.') || (a[1] == '\0')) {
        b = p + -1;
        result = 0;
      }
      else {
        result = 1;
      }
    }
    else {
      if (*b == '*') {
        result = strcasecomp_asterisk(b,a);
        bVar3 = result == 0;
      }
      else {
        if ((*a == '\0') || (*b == '\0')) {
          return (uint)(*a != *b);
        }
        ppuVar2 = __ctype_b_loc();
        if (((*ppuVar2)[(byte)*a] & 0x100) == 0) {
          local_1c = (uint)(byte)*a;
        }
        else {
          local_1c = tolower((uint)(byte)*a);
        }
        ppuVar2 = __ctype_b_loc();
        if (((*ppuVar2)[(byte)*b] & 0x100) == 0) {
          local_18 = (uint)(byte)*b;
        }
        else {
          local_18 = tolower((uint)(byte)*b);
        }
        if (local_1c != local_18) {
          return 1;
        }
      }
    }
LAB_08128520:
    a = a + 1;
    b = b + 1;
  } while( true );
}



char * HTSACopy(char **dest,char *src)

{
  size_t sVar1;
  char *pcVar2;
  size_t size;
  
  if (src == (char *)0x0) {
    if (*dest != (char *)0x0) {
      free(*dest);
      *dest = (char *)0x0;
    }
  }
  else {
    if (*dest != src) {
      sVar1 = strlen(src);
      if (*dest != (char *)0x0) {
        free(*dest);
        *dest = (char *)0x0;
      }
      pcVar2 = (char *)malloc(sVar1 + 1);
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACopy");
      }
      memcpy(*dest,src,sVar1 + 1);
    }
  }
  return *dest;
}



char * HTSACat(char **dest,char *src)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  size_t length;
  
  if (((src != (char *)0x0) && (*src != '\0')) && (*dest != src)) {
    if (*dest == (char *)0x0) {
      sVar1 = strlen(src);
      pcVar3 = (char *)malloc(sVar1 + 1);
      *dest = pcVar3;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
      strcpy(*dest,src);
    }
    else {
      sVar1 = strlen(*dest);
      sVar2 = strlen(src);
      pcVar3 = (char *)realloc(*dest,sVar2 + sVar1 + 1);
      *dest = pcVar3;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
      strcpy(*dest + sVar1,src);
    }
  }
  return *dest;
}



void HTSAFree_extra(char *s)

{
  free(s + -4);
  return;
}



char * HTSACopy_extra(char **dest,char *src)

{
  size_t sVar1;
  uint __n;
  char *pcVar2;
  size_t size;
  size_t srcsize;
  
  if (src == (char *)0x0) {
    if (*dest != (char *)0x0) {
      **dest = '\0';
    }
  }
  else {
    sVar1 = strlen(src);
    __n = sVar1 + 1;
    size = 0;
    if (*dest != (char *)0x0) {
      size = *(size_t *)(*dest + -4);
    }
    if (size < __n) {
      if (*dest != (char *)0x0) {
        HTSAFree_extra(*dest);
        *dest = (char *)0x0;
      }
      pcVar2 = (char *)malloc(__n * 2 + 4);
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACopy_extra");
      }
      *(uint *)*dest = __n * 2;
      *dest = *dest + 4;
    }
    memcpy(*dest,src,__n);
  }
  return *dest;
}



char * HTNextField(char **pstr)

{
  char *local_18;
  char *start;
  char *p;
  
  p = *pstr;
  while ((*p != '\0' && ((byte)*p < 0x21))) {
    p = p + 1;
  }
  if (*p == '\0') {
    *pstr = p;
    local_18 = (char *)0x0;
  }
  else {
    if (*p == '\"') {
      start = p + 1;
      p = start;
      while ((*p != '\0' && (*p != '\"'))) {
        if ((*p == '\\') && (p[1] != '\0')) {
          p = p + 1;
        }
        p = p + 1;
      }
    }
    else {
      start = p;
      while ((*p != '\0' && (0x20 < (byte)*p))) {
        p = p + 1;
      }
    }
    if (*p != '\0') {
      *p = '\0';
      p = p + 1;
    }
    *pstr = p;
    local_18 = start;
  }
  return local_18;
}



char * HTNextTok(char **pstr,char *delims,char *bracks,char *found)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  char *pcVar4;
  bool bVar5;
  bool bVar6;
  char *local_34;
  int comment_level;
  char *start;
  char *p;
  char closer;
  BOOLEAN get_closing_char_too;
  BOOLEAN get_comments;
  BOOLEAN skip_comments;
  BOOLEAN get_blanks;
  
  p = *pstr;
  start = (char *)0x0;
  bVar6 = false;
  if ((pstr == (char **)0x0) || (*pstr == (char *)0x0)) {
    local_34 = (char *)0x0;
  }
  else {
    if (delims == (char *)0x0) {
      delims = " ;,=";
    }
    if (bracks == (char *)0x0) {
      bracks = "<\"";
    }
    pcVar4 = strchr(delims,0x20);
    if ((pcVar4 == (char *)0x0) && (pcVar4 = strchr(bracks,0x20), pcVar4 == (char *)0x0)) {
      bVar2 = true;
    }
    else {
      bVar2 = false;
    }
    pcVar4 = strchr(bracks,0x28);
    bVar5 = pcVar4 != (char *)0x0;
    if (((bVar5) || (pcVar4 = strchr(delims,0x28), pcVar4 != (char *)0x0)) || (bVar2)) {
      bVar3 = false;
    }
    else {
      bVar3 = true;
    }
    while (((*p != '\0' && (!bVar2)) && ((byte)*p < 0x21))) {
      p = p + 1;
    }
    if (*p == '\0') {
      *pstr = p;
      if (found != (char *)0x0) {
        *found = '\0';
      }
      local_34 = (char *)0x0;
    }
    else {
LAB_08128a09:
      while( true ) {
        while ((*p != '\0' &&
               (((!bVar2 && ((byte)*p < 0x21)) ||
                (pcVar4 = strchr(delims,(int)*p), pcVar4 != (char *)0x0))))) {
          p = p + 1;
        }
        if (*p == '\0') {
          *pstr = p;
          if (found != (char *)0x0) {
            *found = p[-1];
          }
          return (char *)0x0;
        }
        if ((*p != '(') || ((!bVar3 && (!bVar5)))) break;
        comment_level = 0;
        if ((bVar5) && (start == (char *)0x0)) {
          start = p + 1;
        }
        while ((*p != '\0' &&
               ((*p != ')' || (comment_level = comment_level + -1, 0 < comment_level))))) {
          if (*p == '(') {
            comment_level = comment_level + 1;
          }
          else {
            if (*p == '\"') {
              while ((pcVar4 = p, p = pcVar4 + 1, *p != '\0' && (*p != '\"'))) {
                if ((*p == '\\') && (pcVar4[2] != '\0')) {
                  p = pcVar4 + 2;
                }
              }
              if (*p == '\0') break;
            }
          }
          if ((*p == '\\') && (p[1] != '\0')) {
            p = p + 1;
          }
          p = p + 1;
        }
        if (bVar5) goto LAB_08128e17;
        if (*p != '\0') {
          p = p + 1;
        }
        if (bVar6) {
          if ((*p == '\0') ||
             ((pcVar4 = strchr(bracks,(int)*p), pcVar4 == (char *)0x0 &&
              (pcVar4 = strchr(delims,(int)*p), pcVar4 != (char *)0x0)))) goto LAB_08128e17;
          pcVar4 = strchr(bracks,(int)*p);
          bVar6 = pcVar4 != (char *)0x0;
        }
      }
      pcVar4 = strchr(bracks,(int)*p);
      if (pcVar4 != (char *)0x0) {
        cVar1 = *p;
        if (cVar1 == '<') {
          closer = '>';
        }
        else {
          if (cVar1 < '=') {
            if (cVar1 == ':') {
              closer = ';';
            }
            else {
LAB_08128c4e:
              closer = *p;
            }
          }
          else {
            if (cVar1 == '[') {
              closer = ']';
            }
            else {
              if (cVar1 != '{') goto LAB_08128c4e;
              closer = '}';
            }
          }
        }
        if (start == (char *)0x0) {
          start = p + 1;
          p = start;
        }
        while ((*p != '\0' && (*p != closer))) {
          if ((*p == '\\') && (p[1] != '\0')) {
            p = p + 1;
          }
          p = p + 1;
        }
        if (((!bVar6) || (p = p + 1, *p == '\0')) ||
           ((pcVar4 = strchr(bracks,(int)*p), pcVar4 == (char *)0x0 &&
            (pcVar4 = strchr(delims,(int)*p), pcVar4 != (char *)0x0)))) goto LAB_08128e17;
        pcVar4 = strchr(bracks,(int)*p);
        bVar6 = pcVar4 != (char *)0x0;
        goto LAB_08128a09;
      }
      if (start == (char *)0x0) {
        start = p;
      }
      while ((*p != '\0' &&
             ((((bVar2 || (0x20 < (byte)*p)) &&
               (pcVar4 = strchr(bracks,(int)*p), pcVar4 == (char *)0x0)) &&
              (pcVar4 = strchr(delims,(int)*p), pcVar4 == (char *)0x0))))) {
        p = p + 1;
      }
      if ((*p != '\0') && (pcVar4 = strchr(bracks,(int)*p), pcVar4 != (char *)0x0)) {
        bVar6 = true;
        goto LAB_08128a09;
      }
      if ((*p == '(') && (bVar3)) {
        *pstr = p;
        HTNextTok(pstr,(char *)0x0,"(",found);
        *p = '\0';
        if ((*pstr != (char *)0x0) && (**pstr != '\0')) {
          *pstr = *pstr + 1;
        }
        return start;
      }
LAB_08128e17:
      if (found != (char *)0x0) {
        *found = *p;
      }
      if (*p != '\0') {
        *p = '\0';
        p = p + 1;
      }
      *pstr = p;
      local_34 = start;
    }
  }
  return local_34;
}



char * HTAlloc(char *ptr,size_t length)

{
  if (ptr == (char *)0x0) {
    ptr = (char *)malloc(length);
  }
  else {
    ptr = (char *)realloc(ptr,length);
  }
  if (ptr == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTString.c","HTAlloc");
  }
  return ptr;
}



char * StrAllocVsprintf(char **pstr,size_t dst_len,char *fmt,va_list *ap)

{
  int iVar1;
  size_t sVar2;
  char *local_18;
  int new_len;
  int src_len;
  char *temp;
  char *result;
  
  result = (char *)0x0;
  temp = (char *)0x0;
  if ((((pstr != (char **)0x0) && (dst_len == 0)) && (*pstr != (char *)0x0)) &&
     (*pstr != (char *)0x0)) {
    free(*pstr);
    *pstr = (char *)0x0;
  }
  iVar1 = vasprintf(&temp,fmt,*ap);
  if (-1 < iVar1) {
    if (dst_len == 0) {
      result = temp;
    }
    else {
      sVar2 = strlen(temp);
      if (pstr == (char **)0x0) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = *pstr;
      }
      result = HTAlloc(local_18,sVar2 + dst_len + 1);
      if (result != (char *)0x0) {
        strcpy(result + dst_len,temp);
      }
      free(temp);
    }
  }
  if (pstr != (char **)0x0) {
    *pstr = result;
  }
  return result;
}



char * HTSprintf(char **pstr,char *fmt,...)

{
  char *pcVar1;
  va_list ap;
  size_t inuse;
  char *result;
  
  inuse = 0;
  ap = &stack0x0000000c;
  if ((pstr != (char **)0x0) && (*pstr != (char *)0x0)) {
    inuse = strlen(*pstr);
  }
  pcVar1 = StrAllocVsprintf(pstr,inuse,fmt,&ap);
  return pcVar1;
}



char * HTSprintf0(char **pstr,char *fmt,...)

{
  char *pcVar1;
  va_list ap;
  char *result;
  
  ap = &stack0x0000000c;
  pcVar1 = StrAllocVsprintf(pstr,0,fmt,&ap);
  return pcVar1;
}



char * HTQuoteParameter(char *parameter)

{
  size_t sVar1;
  char *pcVar2;
  ushort **ppuVar3;
  char *result;
  size_t quoted;
  size_t n;
  size_t last;
  size_t i;
  
  quoted = 0;
  if (parameter == (char *)0x0) {
    parameter = "";
  }
  sVar1 = strlen(parameter);
  i = 0;
  do {
    if (sVar1 <= i) {
      pcVar2 = (char *)malloc(quoted * 5 + sVar1 + 3);
      if (pcVar2 == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTQuoteParameter");
      }
      if (quoted != 0) {
        *pcVar2 = '\'';
      }
      n = (size_t)(quoted != 0);
      i = 0;
      while (i < sVar1) {
        if (parameter[i] == '\'') {
          pcVar2[n] = '\'';
          pcVar2[n + 1] = '\"';
          pcVar2[n + 2] = parameter[i];
          pcVar2[n + 3] = '\"';
          pcVar2[n + 4] = '\'';
          n = n + 5;
        }
        else {
          pcVar2[n] = parameter[i];
          n = n + 1;
        }
        i = i + 1;
      }
      if (quoted != 0) {
        pcVar2[n] = '\'';
        n = n + 1;
      }
      pcVar2[n] = '\0';
      return pcVar2;
    }
    pcVar2 = strchr("\\&#$^*?(){}<>\"\';`|",(int)parameter[i]);
    if (pcVar2 == (char *)0x0) {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)parameter[i]] & 0x2000) != 0) goto LAB_081290bf;
    }
    else {
LAB_081290bf:
      quoted = quoted + 1;
    }
    i = i + 1;
  } while( true );
}



int HTCountCommandArgs(char *command)

{
  int number;
  
  number = 0;
  while (*command != '\0') {
    if ((*command == '%') && (command[1] == 's')) {
      number = number + 1;
    }
    command = command + 1;
  }
  return number;
}



char * HTAfterCommandArg(char *command,int number)

{
  while ((0 < number && (*command != '\0'))) {
    if ((*command == '%') && (command[1] == 's')) {
      number = number + -1;
      command = command + 1;
    }
    command = command + 1;
  }
  return command;
}



void HTAddXpand(char **result,char *command,int number,char *parameter)

{
  char *src;
  FILE *__stream;
  size_t local_1c;
  size_t len;
  char *next;
  char *last;
  
  if (0 < number) {
    src = HTAfterCommandArg(command,number + -1);
    next = src;
    if ((number < 2) && (*result != (char *)0x0)) {
      free(*result);
      *result = (char *)0x0;
    }
    while (*next != '\0') {
      if ((*next == '%') && (next[1] == 's')) {
        if (next != src) {
          if (*result == (char *)0x0) {
            local_1c = 0;
          }
          else {
            local_1c = strlen(*result);
          }
          HTSACat(result,src);
          (*result)[(int)(next + (local_1c - (int)src))] = '\0';
        }
        HTSACat(result,parameter);
        if (WWW_TraceFlag == '\0') {
          return;
        }
        src = *result;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PARAM-EXP:%s\n",src);
        return;
      }
      next = next + 1;
    }
  }
  return;
}



void HTAddToCmd(char **result,char *command,int number,char *string)

{
  char *src;
  FILE *__stream;
  size_t local_1c;
  size_t len;
  char *next;
  char *last;
  
  if (0 < number) {
    src = HTAfterCommandArg(command,number + -1);
    if ((number < 2) && (*result != (char *)0x0)) {
      free(*result);
      *result = (char *)0x0;
    }
    next = src;
    if (string == (char *)0x0) {
      string = "";
    }
    while (*next != '\0') {
      if ((*next == '%') && (next[1] == 's')) {
        if (next != src) {
          if (*result == (char *)0x0) {
            local_1c = 0;
          }
          else {
            local_1c = strlen(*result);
          }
          HTSACat(result,src);
          (*result)[(int)(next + (local_1c - (int)src))] = '\0';
        }
        HTSACat(result,string);
        if (WWW_TraceFlag == '\0') {
          return;
        }
        src = *result;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PARAM-ADD:%s\n",src);
        return;
      }
      next = next + 1;
    }
  }
  return;
}



void HTAddParam(char **result,char *command,int number,char *parameter)

{
  char *string;
  char *quoted;
  
  if (0 < number) {
    string = HTQuoteParameter(parameter);
    HTAddToCmd(result,command,number,string);
    if (string != (char *)0x0) {
      free(string);
    }
  }
  return;
}



void HTEndParam(char **result,char *command,int number)

{
  int iVar1;
  char *src;
  FILE *__stream;
  int count;
  char *last;
  
  iVar1 = HTCountCommandArgs(command);
  if (iVar1 < number) {
    number = iVar1;
  }
  src = HTAfterCommandArg(command,number);
  if (*src != '\0') {
    HTSACat(result,src);
  }
  if (WWW_TraceFlag != '\0') {
    src = *result;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"PARAM-END:%s\n",src);
  }
  return;
}



void HTSABCopy(bstring **dest,char *src,int len)

{
  FILE *__stream;
  bstring *pbVar1;
  char *pcVar2;
  int local_18;
  uint need;
  bstring *t;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTSABCopy(%p, %p, %d)\n",dest,src,len);
  }
  HTSABFree(dest);
  if (src != (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"===    %4d:",len);
      }
      trace_bstring2(src,len);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\n");
      }
    }
    pbVar1 = (bstring *)malloc(8);
    if (pbVar1 == (bstring *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSABCopy");
    }
    pcVar2 = (char *)malloc(len + 1);
    pbVar1->str = pcVar2;
    if (pbVar1->str == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSABCopy");
    }
    memcpy(pbVar1->str,src,len);
    pbVar1->len = len;
    pbVar1->str[pbVar1->len] = '\0';
    *dest = pbVar1;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    if (WWW_TraceFlag != '\0') {
      if (*dest == (bstring *)0x0) {
        local_18 = 0;
      }
      else {
        local_18 = (*dest)->len;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"=>     %4d:",local_18);
    }
    trace_bstring(*dest);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
  }
  return;
}



void HTSABCopy0(bstring **dest,char *src)

{
  size_t len;
  
  len = strlen(src);
  HTSABCopy(dest,src,len);
  return;
}



void HTSABCat(bstring **dest,char *src,int len)

{
  FILE *__stream;
  char *pcVar1;
  int local_18;
  uint length;
  uint need;
  bstring *t;
  
  t = *dest;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTSABCat(%p, %p, %d)\n",dest,src,len);
  }
  if (src != (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"===    %4d:",len);
      }
      trace_bstring2(src,len);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\n");
      }
    }
    if (t == (bstring *)0x0) {
      t = (bstring *)calloc(1,8);
      if (t == (bstring *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
      pcVar1 = (char *)malloc(len + 1U);
      t->str = pcVar1;
    }
    else {
      pcVar1 = (char *)realloc(t->str,t->len + len + 1U);
      t->str = pcVar1;
      if (t->str == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
    }
    if (t->str == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
    }
    memcpy(t->str + t->len,src,len);
    t->len = t->len + len;
    t->str[t->len] = '\0';
    *dest = t;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    if (WWW_TraceFlag != '\0') {
      if (*dest == (bstring *)0x0) {
        local_18 = 0;
      }
      else {
        local_18 = (*dest)->len;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"=>     %4d:",local_18);
    }
    trace_bstring(*dest);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
  }
  return;
}



void HTSABCat0(bstring **dest,char *src)

{
  size_t len;
  
  len = strlen(src);
  HTSABCat(dest,src,len);
  return;
}



BOOLEAN HTSABEql(bstring *a,bstring *b)

{
  int iVar1;
  int local_20;
  int local_1c;
  BOOLEAN local_15;
  uint len_b;
  uint len_a;
  
  if (a == (bstring *)0x0) {
    local_20 = 0;
  }
  else {
    local_20 = a->len;
  }
  if (b == (bstring *)0x0) {
    local_1c = 0;
  }
  else {
    local_1c = b->len;
  }
  if (local_20 == local_1c) {
    if (local_20 != 0) {
      iVar1 = memcmp(a->str,b->str,a->len);
      if (iVar1 != 0) goto LAB_08129ae3;
    }
    local_15 = '\x01';
  }
  else {
LAB_08129ae3:
    local_15 = '\0';
  }
  return local_15;
}



void HTSABFree(bstring **ptr)

{
  if (*ptr != (bstring *)0x0) {
    if ((*ptr)->str != (char *)0x0) {
      free((*ptr)->str);
      (*ptr)->str = (char *)0x0;
    }
    if (*ptr != (bstring *)0x0) {
      free(*ptr);
      *ptr = (bstring *)0x0;
    }
    *ptr = (bstring *)0x0;
  }
  return;
}



bstring * HTBprintf(bstring **pstr,char *fmt,...)

{
  size_t len;
  va_list ap;
  char *temp;
  bstring *result;
  
  temp = (char *)0x0;
  ap = &stack0x0000000c;
  temp = StrAllocVsprintf(&temp,0,fmt,&ap);
  if ((temp != (char *)0x0) && (*temp != '\0')) {
    len = strlen(temp);
    HTSABCat(pstr,temp,len);
  }
  if (temp != (char *)0x0) {
    free(temp);
  }
  return *pstr;
}



void trace_bstring2(char *text,int size)

{
  byte bVar1;
  uint __c;
  ushort **ppuVar2;
  FILE *__s;
  int ch;
  int n;
  
  if (text != (char *)0x0) {
    n = 0;
    while (n < size) {
      bVar1 = text[n];
      __c = (uint)bVar1;
      if (bVar1 == 0xc) {
        __s = TraceFP();
        fwrite(&DAT_0818bc11,1,2,(FILE *)__s);
      }
      else {
        if (bVar1 < 0xd) {
          if (bVar1 == 9) {
            __s = TraceFP();
            fwrite(&DAT_0818bc0e,1,2,(FILE *)__s);
          }
          else {
LAB_08129ce2:
            ppuVar2 = __ctype_b_loc();
            if ((((*ppuVar2)[__c] & 0x4000) == 0) &&
               (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[__c] & 0x2000) == 0)) {
              __s = TraceFP();
              fprintf((FILE *)__s,"\\%03o",__c);
            }
            else {
              __s = TraceFP();
              fputc(__c,(FILE *)__s);
            }
          }
        }
        else {
          if (bVar1 == 0xd) {
            __s = TraceFP();
            fwrite(&DAT_0818bc0b,1,2,(FILE *)__s);
          }
          else {
            if (bVar1 != 0x5c) goto LAB_08129ce2;
            __s = TraceFP();
            fwrite(&DAT_0818bc08,1,2,(FILE *)__s);
          }
        }
      }
      n = n + 1;
    }
  }
  return;
}



void trace_bstring(bstring *data)

{
  int local_c;
  char *local_8;
  
  if (data == (bstring *)0x0) {
    local_c = 0;
    local_8 = (char *)0x0;
  }
  else {
    local_c = data->len;
    local_8 = data->str;
  }
  trace_bstring2(local_8,local_c);
  return;
}



int HTAddRule(HTRuleOp op,char *pattern,char *equiv,char *cond_op,char *cond)

{
  rule *prVar1;
  rule *prVar2;
  FILE *__stream;
  char *local_1c;
  char *pEquiv;
  char *pPattern;
  rule *temp;
  
  pPattern = (char *)0x0;
  prVar2 = (rule *)calloc(1,0x18);
  if (prVar2 == (rule *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTRules.c","HTAddRule");
  }
  if (equiv == (char *)0x0) {
    prVar2->equiv = (char *)0x0;
  }
  else {
    pEquiv = (char *)0x0;
    HTSACopy(&pEquiv,equiv);
    prVar2->equiv = pEquiv;
  }
  if (cond_op != (char *)0x0) {
    HTSACopy(&prVar2->condition_op,cond_op);
    HTSACopy(&prVar2->condition,cond);
  }
  HTSACopy(&pPattern,pattern);
  prVar2->pattern = pPattern;
  prVar2->op = op;
  if (equiv == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Rule: For `%s\' op %d",pattern,op);
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Rule: For `%s\' op %d `%s\'",pattern,op,equiv);
    }
  }
  if (cond_op == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\n");
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      if (cond == (char *)0x0) {
        local_1c = "(null)";
      }
      else {
        local_1c = cond;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\t%s %s\n",cond_op,local_1c);
    }
  }
  prVar2->next = (_rule *)0x0;
  prVar1 = prVar2;
  if (rule_tail != (rule *)0x0) {
    *(rule **)&rule_tail->next = prVar2;
    prVar1 = rules;
  }
  rules = prVar1;
  rule_tail = prVar2;
  return 0;
}



void HTClearRules(void)

{
  char **ppcVar1;
  rule *__ptr;
  rule *prVar2;
  rule *temp;
  
  while (__ptr = rules, rules != (rule *)0x0) {
    prVar2 = (rule *)rules->next;
    if (rules->pattern != (char *)0x0) {
      ppcVar1 = &rules->pattern;
      rules = (rule *)rules->next;
      free(*ppcVar1);
      __ptr->pattern = (char *)0x0;
      prVar2 = rules;
    }
    rules = prVar2;
    if (__ptr->equiv != (char *)0x0) {
      free(__ptr->equiv);
      __ptr->equiv = (char *)0x0;
    }
    if (__ptr->condition_op != (char *)0x0) {
      free(__ptr->condition_op);
      __ptr->condition_op = (char *)0x0;
    }
    if (__ptr->condition != (char *)0x0) {
      free(__ptr->condition);
      __ptr->condition = (char *)0x0;
    }
    if (__ptr != (rule *)0x0) {
      free(__ptr);
    }
  }
  rule_tail = (rule *)0x0;
  return;
}



BOOLEAN rule_cond_ok(rule *r)

{
  char *pcVar1;
  int iVar2;
  FILE *__stream;
  bool local_1d;
  char *local_1c;
  BOOLEAN result;
  
  if (r->condition_op == (char *)0x0) {
    local_1d = true;
  }
  else {
    iVar2 = strcmp(r->condition_op,"if");
    if ((iVar2 != 0) && (iVar2 = strcmp(r->condition_op,"unless"), iVar2 != 0)) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = r->condition_op;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"....... rule ignored, unrecognized `%s\'!\n",pcVar1);
      }
      return '\0';
    }
    iVar2 = strcmp(r->condition,"redirected");
    if (iVar2 == 0) {
      result = 0 < redirection_attempts;
    }
    else {
      iVar2 = strcmp(r->condition,"userspec");
      if (iVar2 != 0) {
        if (WWW_TraceFlag != '\0') {
          if (r->condition == (char *)0x0) {
            local_1c = "(null)";
          }
          else {
            local_1c = r->condition;
          }
          pcVar1 = r->condition_op;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"....... rule ignored, unrecognized `%s %s\'!\n",pcVar1,local_1c)
          ;
        }
        return '\0';
      }
      result = LYUserSpecifiedURL;
    }
    iVar2 = strcmp(r->condition_op,"if");
    if (iVar2 == 0) {
      local_1d = (bool)result;
    }
    else {
      local_1d = result == '\0';
    }
  }
  return (BOOLEAN)local_1d;
}



char * HTTranslate(char *required)

{
  HTRuleOp HVar1;
  char *pcVar2;
  bool bVar3;
  BOOLEAN BVar4;
  BOOLEAN BVar5;
  size_t sVar6;
  size_t sVar7;
  int iVar8;
  char *pcVar9;
  FILE *__stream;
  char *local_78;
  char *local_74;
  char *local_70;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_58;
  char *local_54;
  char *local_50;
  char *p2;
  char *ins;
  char *prot_file;
  char *eff_ids;
  char *local_copy;
  char *q;
  int m;
  char *p;
  int permitredir_flag;
  int proxy_none_flag;
  char *pMsg;
  char *msgtmp;
  char *current;
  rule *r;
  
  current = (char *)0x0;
  msgtmp = (char *)0x0;
  bVar3 = false;
  BVar4 = '\0';
  HTSACopy(&current,required);
  HTAA_clearProtections();
  r = rules;
  do {
    if (r == (rule *)0x0) {
      if (bVar3) {
        p2 = (char *)0x0;
        HTSACopy(&p2,"NoProxy=");
        HTSACat(&p2,current);
        if (current != (char *)0x0) {
          free(current);
        }
        local_58 = p2;
      }
      else {
        local_58 = current;
      }
      return local_58;
    }
    p = r->pattern;
    m = 0;
    q = current;
    while (((*p != '\0' && (*q != '\0')) && (*p == *q))) {
      p = p + 1;
      q = q + 1;
    }
    if (*p == '*') {
      sVar6 = strlen(q);
      sVar7 = strlen(p + 1);
      m = sVar6 - sVar7;
      if ((-1 < m) && (iVar8 = strcmp(q + m,p + 1), iVar8 == 0)) goto LAB_0812a2c2;
    }
    else {
      if (*p == *q) {
LAB_0812a2c2:
        BVar5 = rule_cond_ok(r);
        pcVar9 = current;
        if (BVar5 != '\0') {
          switch(r->op) {
          case HT_Invalid:
          case HT_Fail:
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTRule: *** FAIL `%s\'\n",pcVar9);
            }
            if (current != (char *)0x0) {
              free(current);
            }
            return (char *)0x0;
          case HT_Pass:
            if (r->equiv == (char *)0x0) {
              if (bVar3) {
                p2 = (char *)0x0;
                HTSACopy(&p2,"NoProxy=");
                HTSACat(&p2,current);
                if (current != (char *)0x0) {
                  free(current);
                }
                current = p2;
              }
              pcVar9 = current;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTRule: Pass `%s\'\n",pcVar9);
              }
              return current;
            }
          case HT_Map:
          case HT_Redirect:
          case HT_RedirectPerm:
            if (*p == *q) {
              if (WWW_TraceFlag != '\0') {
                pcVar2 = r->equiv;
                __stream = TraceFP();
                fprintf((FILE *)__stream,"For `%s\' using `%s\'\n",pcVar9,pcVar2);
              }
              HTSACopy(&current,r->equiv);
            }
            else {
              pcVar9 = strchr(r->equiv,0x2a);
              if (pcVar9 == (char *)0x0) {
                p2 = (char *)0x0;
                HTSACopy(&p2,r->equiv);
                pcVar2 = current;
                pcVar9 = p2;
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"For `%s\' using `%s\'\n",pcVar2,pcVar9);
                }
                if (current != (char *)0x0) {
                  free(current);
                }
                current = p2;
              }
              else {
                p2 = (char *)0x0;
                HTSprintf0(&p2,"%.*s%.*s%s",pcVar9 + -(int)r->equiv,r->equiv,m,q,pcVar9 + 1);
                pcVar2 = current;
                pcVar9 = p2;
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"For `%s\' using `%s\'\n",pcVar2,pcVar9);
                }
                if (current != (char *)0x0) {
                  free(current);
                }
                current = p2;
              }
            }
            pcVar9 = current;
            if (r->op == HT_Pass) {
              if (bVar3) {
                p2 = (char *)0x0;
                HTSACopy(&p2,"NoProxy=");
                HTSACat(&p2,current);
                if (current != (char *)0x0) {
                  free(current);
                }
                current = p2;
              }
              pcVar9 = current;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTRule: ...and pass `%s\'\n",pcVar9);
              }
              return current;
            }
            if (r->op == HT_Redirect) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTRule: ...and redirect to `%s\'\n",pcVar9);
              }
              HTPermitRedir = BVar4;
              redirecting_url = current;
              return (char *)0x0;
            }
            if (r->op == HT_RedirectPerm) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTRule: ...and redirect like 301 to `%s\'\n",pcVar9);
              }
              HTPermitRedir = BVar4;
              redirecting_url = current;
              permanent_redirection = '\x01';
              return (char *)0x0;
            }
            break;
          case HT_DefProt:
          case HT_Protect:
            local_copy = (char *)0x0;
            eff_ids = (char *)0x0;
            prot_file = (char *)0x0;
            if (WWW_TraceFlag != '\0') {
              if (r->equiv == (char *)0x0) {
                if (r->op == HT_Protect) {
                  local_74 = "DEFAULT";
                }
                else {
                  local_74 = "NULL!!";
                }
                local_78 = local_74;
              }
              else {
                local_78 = r->equiv;
              }
              if (r->op == HT_Protect) {
                local_70 = "Protect";
              }
              else {
                local_70 = "DefProt";
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTRule: `%s\' matched %s %s: `%s\'\n",pcVar9,local_70,
                      "rule, setup",local_78);
            }
            if (r->equiv != (char *)0x0) {
              HTSACopy(&local_copy,r->equiv);
              p2 = local_copy;
              prot_file = HTNextField(&p2);
              eff_ids = HTNextField(&p2);
            }
            if (r->op == HT_Protect) {
              HTAA_setCurrentProtection(current,prot_file,eff_ids);
            }
            else {
              HTAA_setDefaultProtection(current,prot_file,eff_ids);
            }
            if (local_copy != (char *)0x0) {
              free(local_copy);
              local_copy = (char *)0x0;
            }
            break;
          case HT_Progress:
          case HT_InfoMsg:
          case HT_Alert:
            LYFixCursesOn("show rule message:");
          case HT_AlwaysAlert:
            if (r->equiv == (char *)0x0) {
              if (r->op == HT_AlwaysAlert) {
                local_60 = "%s";
              }
              else {
                local_60 = "Rule: %s";
              }
              local_64 = local_60;
            }
            else {
              local_64 = r->equiv;
            }
            pMsg = local_64;
            pcVar9 = strchr(local_64,0x25);
            if (pcVar9 != (char *)0x0) {
              HTSprintf0(&msgtmp,local_64,current);
              pMsg = msgtmp;
            }
            HVar1 = r->op;
            if (HVar1 == HT_InfoMsg) {
              HTInfoMsg(pMsg);
            }
            else {
              if (HVar1 < HT_UserMsg) {
                if (HVar1 == HT_Progress) {
                  HTProgress(pMsg);
                }
              }
              else {
                if (HVar1 == HT_Alert) {
                  HTAlert(pMsg);
                }
                else {
                  if (HVar1 == HT_AlwaysAlert) {
                    HTAlwaysAlert("Rule alert:",pMsg);
                  }
                }
              }
            }
            if (msgtmp != (char *)0x0) {
              free(msgtmp);
              msgtmp = (char *)0x0;
            }
            break;
          case HT_UserMsg:
            LYFixCursesOn("show rule message:");
            if (r->equiv == (char *)0x0) {
              local_68 = "Rule: %s";
            }
            else {
              local_68 = r->equiv;
            }
            HTUserMsg2(local_68,current);
            break;
          case HT_PermitRedir:
            BVar4 = '\x01';
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTRule: Mark for redirection permitted\n");
            }
            break;
          case HT_UseProxy:
            if ((r->equiv == (char *)0x0) ||
               (iVar8 = strcasecomp(r->equiv,"none"), pcVar9 = current, iVar8 != 0)) {
              pcVar9 = current;
              if (!bVar3) {
                p2 = (char *)0x0;
                HTSACopy(&p2,"Proxied=");
                HTSACat(&p2,r->equiv);
                HTSACat(&p2,current);
                if (WWW_TraceFlag != '\0') {
                  if (r->equiv == (char *)0x0) {
                    local_50 = "(null)";
                  }
                  else {
                    local_50 = r->equiv;
                  }
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"HTRule: proxy server found: %s\n",local_50);
                }
                if (current != (char *)0x0) {
                  free(current);
                }
                return p2;
              }
              if (WWW_TraceFlag != '\0') {
                if (r->equiv == (char *)0x0) {
                  local_54 = "(null)";
                }
                else {
                  local_54 = r->equiv;
                }
                __stream = TraceFP();
                fprintf((FILE *)__stream,"For `%s\' proxy server ignored: %s\n",pcVar9,local_54);
              }
            }
            else {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"For `%s\' will not use proxy\n",pcVar9);
              }
              bVar3 = true;
            }
          }
        }
      }
    }
    r = (rule *)r->next;
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps

int HTSetConfiguration(char *config)

{
  char *a;
  int iVar1;
  undefined4 uVar2;
  char *a_00;
  FILE *__stream;
  size_t n;
  double local_c4;
  char *local_bc;
  long local_b8;
  double local_b4;
  double local_ac;
  double local_a4;
  HTRuleOp local_98;
  HTRuleOp local_94;
  HTRuleOp local_90;
  HTRuleOp local_8c;
  HTRuleOp local_88;
  HTRuleOp local_84;
  HTRuleOp local_80;
  HTRuleOp local_7c;
  HTRuleOp local_78;
  HTRuleOp local_74;
  HTRuleOp local_70;
  HTRuleOp local_6c;
  HTRuleOp local_68;
  HTRuleOp local_64;
  HTRuleOp local_60;
  off_t maxbytes;
  char *cp2;
  char *cp1;
  char *cp;
  char *encoding;
  char *p;
  int status;
  float secs_per_byte;
  float secs;
  float quality;
  char *cond;
  char *cond_op;
  char *word3;
  char *word2;
  char *word1;
  char *pointer;
  char *line;
  HTRuleOp op;
  
  line = (char *)0x0;
  pointer = (char *)0x0;
  cond_op = (char *)0x0;
  cond = (char *)0x0;
  HTSACopy(&line,config);
  a = strchr(line,0x23);
  if (a != (char *)0x0) {
    *a = '\0';
  }
  pointer = line;
  a = HTNextField(&pointer);
  if (a == (char *)0x0) {
    if (line != (char *)0x0) {
      free(line);
    }
    return 0;
  }
  word2 = HTNextField(&pointer);
  iVar1 = strcasecomp(a,"defprot");
  if ((iVar1 == 0) || (iVar1 = strcasecomp(a,"protect"), iVar1 == 0)) {
    word3 = pointer;
  }
  else {
    word3 = HTNextField(&pointer);
  }
  a_00 = line;
  if (word2 == (char *)0x0) {
    uVar2 = gettext("Insufficient operands:");
    fprintf(stderr,"HTRule: %s %s\n",uVar2,a_00);
    if (line != (char *)0x0) {
      free(line);
    }
    return -2;
  }
  iVar1 = strcasecomp(a,"suffix");
  if (iVar1 == 0) {
    local_bc = HTNextField(&pointer);
    if (pointer == (char *)0x0) {
      status = 0;
    }
    else {
      status = sscanf(pointer,"%f",&quality);
    }
    if (status < 1) {
      local_c4 = 1.00000000;
    }
    else {
      local_c4 = (double)quality;
    }
    if (local_bc == (char *)0x0) {
      local_bc = "binary";
    }
    HTSetSuffix5(word2,word3,local_bc,(char *)0x0,local_c4);
    goto LAB_0812b632;
  }
  iVar1 = strcasecomp(a,"presentation");
  if (iVar1 == 0) {
    if (pointer == (char *)0x0) {
      status = 0;
    }
    else {
      status = sscanf(pointer,"%f%f%f%lld",&quality,&secs,&secs_per_byte,&maxbytes);
    }
    if (status < 4) {
      local_b8 = 0;
    }
    else {
      local_b8 = (long)maxbytes;
    }
    if (status < 3) {
      local_b4 = 0.00000000;
    }
    else {
      local_b4 = (double)secs_per_byte;
    }
    if (status < 2) {
      local_ac = 0.00000000;
    }
    else {
      local_ac = (double)secs;
    }
    if (status < 1) {
      local_a4 = 1.00000000;
    }
    else {
      local_a4 = (double)quality;
    }
    HTSetPresentation(word2,word3,(char *)0x0,local_a4,local_ac,local_b4,local_b8,mediaCFG);
    goto LAB_0812b632;
  }
  iVar1 = strncasecomp(a,"htbin",5);
  if ((iVar1 == 0) || (iVar1 = strncasecomp(a,"bindir",6), iVar1 == 0)) {
    HTSACopy(&HTBinDir,word2);
    goto LAB_0812b632;
  }
  iVar1 = strncasecomp(a,"search",6);
  if (iVar1 == 0) {
    HTSACopy(&HTSearchScript,word2);
    goto LAB_0812b632;
  }
  iVar1 = strcasecomp(a,"map");
  if (iVar1 == 0) {
    local_98 = HT_Map;
  }
  else {
    iVar1 = strcasecomp(a,"pass");
    if (iVar1 == 0) {
      local_94 = HT_Pass;
    }
    else {
      iVar1 = strcasecomp(a,"fail");
      if (iVar1 == 0) {
        local_90 = HT_Fail;
      }
      else {
        iVar1 = strcasecomp(a,"redirect");
        if (iVar1 == 0) {
          local_8c = HT_Redirect;
        }
        else {
          iVar1 = strncasecomp(a,"redirectperm",0xc);
          if (iVar1 == 0) {
            local_88 = HT_RedirectPerm;
          }
          else {
            iVar1 = strcasecomp(a,"redirecttemp");
            if (iVar1 == 0) {
              local_84 = HT_Redirect;
            }
            else {
              iVar1 = strcasecomp(a,"permitredirection");
              if (iVar1 == 0) {
                local_80 = HT_PermitRedir;
              }
              else {
                iVar1 = strcasecomp(a,"useproxy");
                if (iVar1 == 0) {
                  local_7c = HT_UseProxy;
                }
                else {
                  iVar1 = strcasecomp(a,"alert");
                  if (iVar1 == 0) {
                    local_78 = HT_Alert;
                  }
                  else {
                    iVar1 = strcasecomp(a,"alwaysalert");
                    if (iVar1 == 0) {
                      local_74 = HT_AlwaysAlert;
                    }
                    else {
                      iVar1 = strcasecomp(a,"progress");
                      if (iVar1 == 0) {
                        local_70 = HT_Progress;
                      }
                      else {
                        iVar1 = strcasecomp(a,"usermsg");
                        if (iVar1 == 0) {
                          local_6c = HT_UserMsg;
                        }
                        else {
                          iVar1 = strcasecomp(a,"infomsg");
                          if (iVar1 == 0) {
                            local_68 = HT_InfoMsg;
                          }
                          else {
                            iVar1 = strcasecomp(a,"defprot");
                            if (iVar1 == 0) {
                              local_64 = HT_DefProt;
                            }
                            else {
                              iVar1 = strcasecomp(a,"protect");
                              if (iVar1 == 0) {
                                local_60 = HT_Protect;
                              }
                              else {
                                local_60 = HT_Invalid;
                              }
                              local_64 = local_60;
                            }
                            local_68 = local_64;
                          }
                          local_6c = local_68;
                        }
                        local_70 = local_6c;
                      }
                      local_74 = local_70;
                    }
                    local_78 = local_74;
                  }
                  local_7c = local_78;
                }
                local_80 = local_7c;
              }
              local_84 = local_80;
            }
            local_88 = local_84;
          }
          local_8c = local_88;
        }
        local_90 = local_8c;
      }
      local_94 = local_90;
    }
    local_98 = local_94;
  }
  op = local_98;
  switch(local_98) {
  case HT_Map:
  case HT_Redirect:
  case HT_RedirectPerm:
  case HT_UseProxy:
switchD_0812b1d4_caseD_1:
    a_00 = HTNextField(&pointer);
    cond_op = a_00;
    if ((((local_98 == HT_Redirect) && (iVar1 = strcasecomp(a,"redirect"), iVar1 == 0)) &&
        (a_00 != (char *)0x0)) &&
       ((iVar1 = strcasecomp(a_00,"if"), iVar1 != 0 &&
        (iVar1 = strcasecomp(a_00,"unless"), iVar1 != 0)))) {
      iVar1 = strcmp(word2,"301");
      if ((iVar1 == 0) || (iVar1 = strcasecomp(word2,"permanent"), iVar1 == 0)) {
        op = HT_RedirectPerm;
      }
      else {
        iVar1 = strcmp(word2,"302");
        if (((iVar1 != 0) && (iVar1 = strcmp(word2,"303"), iVar1 != 0)) &&
           ((iVar1 = strcasecomp(word2,"temp"), iVar1 != 0 &&
            ((iVar1 = strcasecomp(word2,"seeother"), iVar1 != 0 && (WWW_TraceFlag != '\0')))))) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Rule: Ignoring `%s\' in Redirect\n",word2);
        }
      }
      word2 = word3;
      cond_op = HTNextField(&pointer);
      word3 = a_00;
    }
    if ((cond_op != (char *)0x0) && (*cond_op != '\0')) {
      cond = HTNextField(&pointer);
    }
    break;
  case HT_Pass:
    if ((word3 == (char *)0x0) ||
       ((iVar1 = strcasecomp(word3,"if"), iVar1 != 0 &&
        (iVar1 = strcasecomp(word3,"unless"), iVar1 != 0)))) goto switchD_0812b1d4_caseD_1;
    cond_op = word3;
    word3 = (char *)0x0;
    cond = HTNextField(&pointer);
    break;
  case HT_Fail:
  case HT_PermitRedir:
    cond_op = word3;
    if ((word3 != (char *)0x0) && (*word3 != '\0')) {
      word3 = (char *)0x0;
      cond = HTNextField(&pointer);
    }
    break;
  case HT_DefProt:
  case HT_Protect:
    break;
  case HT_Progress:
  case HT_InfoMsg:
  case HT_UserMsg:
  case HT_Alert:
  case HT_AlwaysAlert:
    cond_op = HTNextField(&pointer);
    if ((cond_op != (char *)0x0) && (*cond_op != '\0')) {
      cond = HTNextField(&pointer);
    }
    if (word3 != (char *)0x0) {
      cp = word3;
      while (cp1 = strchr(cp,0x25), cp1 != (char *)0x0) {
        if (cp1[1] == '\0') {
          *cp1 = '\0';
          break;
        }
        if (cp1[1] != '%') goto LAB_0812b480;
        cp = cp1 + 2;
      }
    }
    break;
  default:
    uVar2 = gettext("Bad rule");
    fprintf(stderr,"HTRule: %s \'%s\'\n",uVar2,config);
    goto LAB_0812b632;
  }
switchD_0812b1d4_caseD_4:
  if ((((cond_op == (char *)0x0) || (cond == (char *)0x0)) || (*cond == '\0')) ||
     (iVar1 = strcasecomp(cond_op,"unless"), iVar1 != 0)) {
    if (((cond_op == (char *)0x0) || (cond == (char *)0x0)) ||
       ((*cond == '\0' || (iVar1 = strcasecomp(cond_op,"if"), iVar1 != 0)))) {
      if ((cond_op != (char *)0x0) || (cond != (char *)0x0)) {
        uVar2 = gettext("Bad rule");
        fprintf(stderr,"HTRule: %s \'%s\'\n",uVar2,config);
        if (line != (char *)0x0) {
          free(line);
        }
        return -2;
      }
    }
    else {
      cond_op = "if";
    }
  }
  else {
    cond_op = "unless";
  }
  if (cond == (char *)0x0) {
LAB_0812b5c8:
    if ((cond != (char *)0x0) && (n = strlen(cond), 7 < n)) {
      n = strlen(cond);
      iVar1 = strncasecomp(cond,"userspecified",n);
      if (iVar1 == 0) {
        cond = "userspec";
      }
    }
  }
  else {
    n = strlen(cond);
    iVar1 = strncasecomp(cond,"redirected",n);
    if (iVar1 != 0) goto LAB_0812b5c8;
    cond = "redirected";
  }
  HTAddRule(op,word2,word3,cond_op,cond);
LAB_0812b632:
  if (line != (char *)0x0) {
    free(line);
  }
  return 0;
LAB_0812b480:
  cp1 = strchr(cp1 + 2,0x25);
  if (cp1 != (char *)0x0) {
    if (cp1[1] == '\0') {
      *cp1 = '\0';
      goto switchD_0812b1d4_caseD_4;
    }
    if (cp1[1] != '%') {
      *cp1 = '?';
    }
    goto LAB_0812b480;
  }
  goto switchD_0812b1d4_caseD_4;
}



int HTLoadRules(char *filename)

{
  int iVar1;
  FILE *__stream;
  FILE *__stream_00;
  char *pcVar2;
  int in_GS_OFFSET;
  int local_11c;
  FILE *fp;
  char line [257];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen64(filename,"r");
  if (__stream == (FILE *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream_00 = TraceFP();
      fprintf((FILE *)__stream_00,"HTRules: Can\'t open rules file %s\n",filename);
    }
    local_11c = -1;
  }
  else {
    while( true ) {
      pcVar2 = fgets(line,0x101,__stream);
      if (pcVar2 == (char *)0x0) break;
      HTSetConfiguration(line);
    }
    fclose(__stream);
    local_11c = 0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_11c;
}



void HTSetPresentation(char *representation,char *command,char *testcommand,double quality,
                      double secs,double secs_per_byte,long maxbytes,AcceptMedia media)

{
  HTPresentation *newObject;
  FILE *__stream;
  HTAtom *pHVar1;
  int iVar2;
  char *local_3c;
  char *local_38;
  char *local_34;
  HTPresentation *pres;
  
  newObject = (HTPresentation *)calloc(1,0x30);
  if (newObject == (HTPresentation *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFormat.c","HTSetPresentation");
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    if (testcommand == (char *)0x0) {
      local_3c = "";
    }
    else {
      local_3c = testcommand;
    }
    if (command == (char *)0x0) {
      local_38 = "";
    }
    else {
      local_38 = command;
    }
    if (representation == (char *)0x0) {
      local_34 = "";
    }
    else {
      local_34 = representation;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTSetPresentation rep=%s, command=%s, test=%s, qual=%f\n",local_34,
            local_38,local_3c,quality);
  }
  pHVar1 = HTAtom_for(representation);
  newObject->rep = pHVar1;
  pHVar1 = HTAtom_for("www/present");
  newObject->rep_out = pHVar1;
  newObject->converter = HTSaveAndExecute;
  newObject->quality = (float)quality;
  newObject->secs = (float)secs;
  newObject->secs_per_byte = (float)secs_per_byte;
  *(long *)&newObject->maxbytes = maxbytes;
  *(int *)((int)&newObject->maxbytes + 4) = maxbytes >> 0x1f;
  newObject->get_accept = '\0';
  newObject->accept_opt = media;
  newObject->command = (char *)0x0;
  HTSACopy(&newObject->command,command);
  newObject->testcommand = (char *)0x0;
  HTSACopy(&newObject->testcommand,testcommand);
  if (HTPresentations == (HTList *)0x0) {
    HTPresentations = HTList_new();
  }
  iVar2 = strcmp(representation,"*");
  if (iVar2 == 0) {
    if (default_presentation != (HTPresentation *)0x0) {
      free(default_presentation);
    }
  }
  else {
    HTList_addObject(HTPresentations,newObject);
    newObject = default_presentation;
  }
  default_presentation = newObject;
  return;
}



void HTSetConversion(char *representation_in,char *representation_out,HTConverter *converter,
                    float quality,float secs,float secs_per_byte,long maxbytes,AcceptMedia media)

{
  HTAtom **newObject;
  FILE *__stream;
  HTAtom *pHVar1;
  char *local_1c;
  char *local_18;
  HTPresentation *pres;
  
  newObject = (HTAtom **)calloc(1,0x30);
  if (newObject == (HTAtom **)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFormat.c","HTSetConversion");
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    if (representation_out == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = representation_out;
    }
    if (representation_in == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = representation_in;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTSetConversion rep_in=%s, rep_out=%s, qual=%f\n",local_18,local_1c,
            (double)quality);
  }
  pHVar1 = HTAtom_for(representation_in);
  *newObject = pHVar1;
  pHVar1 = HTAtom_for(representation_out);
  newObject[1] = pHVar1;
  *(HTConverter **)(newObject + 2) = converter;
  newObject[3] = (HTAtom *)0x0;
  newObject[4] = (HTAtom *)0x0;
  *(float *)(newObject + 5) = quality;
  *(float *)(newObject + 6) = secs;
  *(float *)(newObject + 7) = secs_per_byte;
  *(long *)(newObject + 8) = maxbytes;
  newObject[9] = (HTAtom *)(maxbytes >> 0x1f);
  *(undefined *)(newObject + 10) = 1;
  *(AcceptMedia *)(newObject + 0xb) = media;
  if (HTPresentations == (HTList *)0x0) {
    HTPresentations = HTList_new();
  }
  HTList_addObject(HTPresentations,newObject);
  return;
}



void HTInitInput(int file_number)

{
  input_pointer = input_buffer;
  input_limit = input_buffer;
  input_file_number = file_number;
  return;
}



int HTGetCharacter(void)

{
  byte bVar1;
  int iVar2;
  FILE *__stream;
  int status;
  char ch;
  
  interrupted_in_htgetcharacter = 0;
  do {
    if (input_limit <= input_pointer) {
      iVar2 = HTDoRead(input_file_number,input_buffer,0x1000);
      if (iVar2 < 1) {
        if (iVar2 == 0) {
          return -1;
        }
        if (iVar2 == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFormat: Interrupted in HTGetCharacter\n");
          }
          interrupted_in_htgetcharacter = 1;
          return -1;
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFormat: File read error %d\n",iVar2);
        }
        return -1;
      }
      input_pointer = input_buffer;
      input_limit = input_buffer + iVar2;
    }
    bVar1 = *input_pointer;
    input_pointer = input_pointer + 1;
    if (bVar1 != 0xd) {
      return (uint)bVar1;
    }
  } while( true );
}



int half_match(char *trial_type,char *target)

{
  char *pcVar1;
  FILE *__stream;
  int iVar2;
  int local_18;
  char *cp;
  
  pcVar1 = strchr(trial_type,0x2f);
  if ((pcVar1 == (char *)0x0) || (pcVar1[1] != '*')) {
    local_18 = 0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFormat: comparing %s and %s for half match\n",trial_type,target);
    }
    iVar2 = strncmp(trial_type,target,(size_t)(pcVar1 + (-1 - (int)trial_type)));
    if (iVar2 == 0) {
      local_18 = 1;
    }
    else {
      local_18 = 0;
    }
  }
  return local_18;
}



BOOLEAN failsMailcap(HTPresentation *pres,HTParentAnchor *anchor)

{
  int iVar1;
  
  if ((pres->testcommand != (char *)0x0) &&
     (iVar1 = LYTestMailcapCommand(pres->testcommand,anchor->content_type_params), iVar1 != 0)) {
    return '\x01';
  }
  return '\0';
}



HTPresentation *
HTFindPresentation(HTFormat rep_in,HTFormat rep_out,HTPresentation *fill_in,HTParentAnchor *anchor)

{
  char *pcVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  FILE *__stream;
  int iVar4;
  HTPresentation *pres_00;
  int iVar5;
  HTPresentation *local_4c;
  HTPresentation *local_48;
  HTPresentation *local_44;
  HTPresentation *local_40;
  HTPresentation *strong_subtype_wildcard_match;
  HTPresentation *last_default_match;
  HTPresentation *weak_wildcard_match;
  HTPresentation *strong_wildcard_match;
  HTPresentation *match;
  HTPresentation *pres;
  int i;
  int n;
  HTAtom *wildcard;
  
  wildcard = (HTAtom *)0x0;
  strong_wildcard_match = (HTPresentation *)0x0;
  weak_wildcard_match = (HTPresentation *)0x0;
  last_default_match = (HTPresentation *)0x0;
  strong_subtype_wildcard_match = (HTPresentation *)0x0;
  if (WWW_TraceFlag != '\0') {
    pcVar1 = rep_out->name;
    pcVar2 = rep_in->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFormat: Looking up presentation for %s to %s\n",pcVar2,pcVar1);
  }
  iVar4 = HTList_count(HTPresentations);
  i = 0;
  do {
    if (iVar4 <= i) {
      if (strong_subtype_wildcard_match == (HTPresentation *)0x0) {
        if (strong_wildcard_match == (HTPresentation *)0x0) {
          if (weak_wildcard_match == (HTPresentation *)0x0) {
            local_40 = last_default_match;
          }
          else {
            local_40 = weak_wildcard_match;
          }
          local_44 = local_40;
        }
        else {
          local_44 = strong_wildcard_match;
        }
        local_48 = local_44;
      }
      else {
        local_48 = strong_subtype_wildcard_match;
      }
      if (local_48 == (HTPresentation *)0x0) {
        local_4c = (HTPresentation *)0x0;
      }
      else {
        fill_in->rep = local_48->rep;
        fill_in->rep_out = local_48->rep_out;
        fill_in->converter = local_48->converter;
        fill_in->command = local_48->command;
        fill_in->testcommand = local_48->testcommand;
        fill_in->quality = local_48->quality;
        fill_in->secs = local_48->secs;
        fill_in->secs_per_byte = local_48->secs_per_byte;
        *(undefined4 *)&fill_in->maxbytes = *(undefined4 *)&local_48->maxbytes;
        *(undefined4 *)((int)&fill_in->maxbytes + 4) = *(undefined4 *)((int)&local_48->maxbytes + 4)
        ;
        *(undefined4 *)&fill_in->get_accept = *(undefined4 *)&local_48->get_accept;
        fill_in->accept_opt = local_48->accept_opt;
        *(HTFormat *)&fill_in->rep = rep_in;
        *(HTFormat *)&fill_in->rep_out = rep_out;
        local_4c = fill_in;
      }
      return local_4c;
    }
    pres_00 = (HTPresentation *)HTList_objectAt(HTPresentations,i);
    if (pres_00->rep == (HTAtom *)rep_in) {
      if (pres_00->rep_out == (HTAtom *)rep_out) {
        BVar3 = failsMailcap(pres_00,anchor);
        if (BVar3 == '\0') {
          if (WWW_TraceFlag == '\0') {
            return pres_00;
          }
          pcVar1 = pres_00->rep_out->name;
          pcVar2 = pres_00->rep->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"FindPresentation: found exact match: %s -> %s\n",pcVar2,pcVar1);
          return pres_00;
        }
      }
      else {
        if (fill_in != (HTPresentation *)0x0) {
          if (wildcard == (HTAtom *)0x0) {
            wildcard = HTAtom_for("*");
          }
          if (pres_00->rep_out == wildcard) {
            BVar3 = failsMailcap(pres_00,anchor);
            if (BVar3 != '\0') goto LAB_0812bfa4;
            if (strong_wildcard_match == (HTPresentation *)0x0) {
              strong_wildcard_match = pres_00;
            }
            if (WWW_TraceFlag != '\0') {
              pcVar1 = pres_00->rep_out->name;
              pcVar2 = pres_00->rep->name;
              __stream = TraceFP();
              fprintf((FILE *)__stream,"StreamStack: found strong wildcard match: %s -> %s\n",pcVar2
                      ,pcVar1);
            }
          }
          goto LAB_0812bef2;
        }
      }
    }
    else {
      if (fill_in != (HTPresentation *)0x0) {
        iVar5 = half_match(pres_00->rep->name,rep_in->name);
        if ((iVar5 != 0) && (pres_00->rep_out == (HTAtom *)rep_out)) {
          BVar3 = failsMailcap(pres_00,anchor);
          if (BVar3 != '\0') goto LAB_0812bfa4;
          if (strong_subtype_wildcard_match == (HTPresentation *)0x0) {
            strong_subtype_wildcard_match = pres_00;
          }
          if (WWW_TraceFlag != '\0') {
            pcVar1 = pres_00->rep_out->name;
            pcVar2 = pres_00->rep->name;
            __stream = TraceFP();
            fprintf((FILE *)__stream,"StreamStack: found strong subtype wildcard match: %s -> %s\n",
                    pcVar2,pcVar1);
          }
        }
LAB_0812bef2:
        if (pres_00->rep == WWW_SOURCE) {
          if (pres_00->rep_out == (HTAtom *)rep_out) {
            BVar3 = failsMailcap(pres_00,anchor);
            if (BVar3 == '\0') {
              if (weak_wildcard_match == (HTPresentation *)0x0) {
                weak_wildcard_match = pres_00;
              }
              if (WWW_TraceFlag != '\0') {
                pcVar1 = pres_00->rep_out->name;
                __stream = TraceFP();
                fprintf((FILE *)__stream,"StreamStack: found weak wildcard match: %s\n",pcVar1);
              }
            }
          }
          else {
            if (last_default_match == (HTPresentation *)0x0) {
              if (wildcard == (HTAtom *)0x0) {
                wildcard = HTAtom_for("*");
              }
              if ((pres_00->rep_out == wildcard) &&
                 (BVar3 = failsMailcap(pres_00,anchor), BVar3 == '\0')) {
                last_default_match = pres_00;
              }
            }
          }
        }
      }
    }
LAB_0812bfa4:
    i = i + 1;
  } while( true );
}



HTStream * HTStreamStack(HTFormat rep_in,HTFormat rep_out,HTStream *sink,HTParentAnchor *anchor)

{
  char *pcVar1;
  char *pcVar2;
  FILE *__stream;
  HTPresentation *pHVar3;
  char *local_50;
  HTPresentation temp;
  HTStream *result;
  HTPresentation *match;
  
  if (WWW_TraceFlag != '\0') {
    if (anchor->content_type_params == (char *)0x0) {
      local_50 = "(null)";
    }
    else {
      local_50 = anchor->content_type_params;
    }
    pcVar1 = rep_out->name;
    pcVar2 = rep_in->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFormat: Constructing stream stack for %s to %s (%s)\n",pcVar2,pcVar1
            ,local_50);
  }
  if (rep_out == rep_in) {
    result = sink;
  }
  else {
    pHVar3 = HTFindPresentation(rep_in,rep_out,(HTPresentation *)&temp,anchor);
    if (pHVar3 == (HTPresentation *)0x0) {
      result = (HTStream *)0x0;
    }
    else {
      if (pHVar3 == (HTPresentation *)&temp) {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = (temp.rep_out)->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"StreamStack: Using %s\n",pcVar1);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = pHVar3->rep_out->name;
          pcVar2 = pHVar3->rep->name;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"StreamStack: found exact match: %s -> %s\n",pcVar2,pcVar1);
        }
      }
      result = (*pHVar3->converter)(pHVar3,anchor,sink);
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (((result == (HTStream *)0x0) || (result->isa == (HTStreamClass *)0x0)) ||
       (result->isa->name == (char *)0x0)) {
      if (result == (HTStream *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"StreamStack: Returning NULL!\n");
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fflush((FILE *)__stream);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"StreamStack: Returning *unknown* stream!\n");
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = result->isa->name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"StreamStack: Returning \"%s\"\n",pcVar1);
      }
    }
  }
  return result;
}



void HTReorderPresentation(HTFormat rep_in,HTFormat rep_out)

{
  HTPresentation *oldObject;
  HTPresentation *match;
  
  oldObject = HTFindPresentation(rep_in,rep_out,(HTPresentation *)0x0,(HTParentAnchor *)0x0);
  if (oldObject != (HTPresentation *)0x0) {
    HTList_removeObject(HTPresentations,oldObject);
    HTList_addObject(HTPresentations,oldObject);
  }
  return;
}



void HTFilterPresentations(void)

{
  char *a;
  HTAtom *pHVar1;
  char *b;
  int iVar2;
  FILE *__stream;
  HTAtom **ppHVar3;
  HTAtom *pHVar4;
  int iVar5;
  int *piVar6;
  char *t;
  char *s;
  HTPresentation *q;
  HTPresentation *p;
  int n;
  int j;
  int i;
  BOOLEAN matched;
  
  iVar2 = HTList_count(HTPresentations);
  iVar5 = LYAcceptMedia;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFilterPresentations (AcceptMedia %#x)\n",iVar5);
  }
  i = 0;
  do {
    if (iVar2 <= i) {
      return;
    }
    ppHVar3 = (HTAtom **)HTList_objectAt(HTPresentations,i);
    a = (*ppHVar3)->name;
    *(undefined *)(ppHVar3 + 10) = 0;
    if ((LYAcceptMedia & (uint)ppHVar3[0xb]) != 0) {
      pHVar1 = ppHVar3[1];
      pHVar4 = HTAtom_for("www/present");
      if ((pHVar1 == pHVar4) && (*ppHVar3 != WWW_SOURCE)) {
        iVar5 = strcasecomp(a,"www/mime");
        if (iVar5 != 0) {
          iVar5 = strcasecomp(a,"www/compressed");
          if (((iVar5 != 0) && ((float)ppHVar3[5] <= 1.00000000)) &&
             (0.00000000 <= (float)ppHVar3[5])) {
            matched = '\x01';
            j = 0;
            while (j < i) {
              piVar6 = (int *)HTList_objectAt(HTPresentations,j);
              b = *(char **)(*piVar6 + 4);
              iVar5 = strcasecomp(a,b);
              if (iVar5 == 0) {
                matched = '\0';
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"  match %s %s\n",a,b);
                }
                break;
              }
              j = j + 1;
            }
            *(BOOLEAN *)(ppHVar3 + 10) = matched;
          }
        }
      }
    }
    i = i + 1;
  } while( true );
}



float HTStackValue(HTFormat rep_in,HTFormat rep_out,float initial_value,long length)

{
  char *pcVar1;
  char *pcVar2;
  HTAtom *pHVar3;
  FILE *__stream;
  int iVar4;
  HTFormat *ppHVar5;
  float local_30;
  float value;
  HTPresentation *pres;
  int i;
  int n;
  HTAtom *wildcard;
  
  pHVar3 = HTAtom_for("*");
  if (WWW_TraceFlag != '\0') {
    pcVar1 = rep_out->name;
    pcVar2 = rep_in->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",pcVar2,
            (double)initial_value,pcVar1);
  }
  if ((rep_out == (HTFormat)WWW_SOURCE) || (rep_out == rep_in)) {
    local_30 = 0.00000000;
  }
  else {
    iVar4 = HTList_count(HTPresentations);
    i = 0;
    while (i < iVar4) {
      ppHVar5 = (HTFormat *)HTList_objectAt(HTPresentations,i);
      if ((*ppHVar5 == rep_in) && ((ppHVar5[1] == rep_out || ((HTAtom *)ppHVar5[1] == pHVar3)))) {
        value = (float)ppHVar5[5] * initial_value;
        if (0.00000000 < HTMaxSecs) {
          value = value - ((float)ppHVar5[6] + (float)ppHVar5[7] * (float)length) / HTMaxSecs;
        }
        return value;
      }
      i = i + 1;
    }
    local_30 = -1000000015047466219876688855040.00000000;
  }
  return local_30;
}



void HTDisplayPartial(void)

{
  bool bVar1;
  BOOLEAN BVar2;
  int line_num;
  int iVar3;
  int iVar4;
  int Newline_partial;
  
  if (display_partial != '\0') {
    line_num = LYGetNewline();
    if (NumOfLines_partial < display_lines + line_num + -1) {
      if (partial_threshold < 1) {
        iVar3 = display_lines + line_num;
        iVar4 = HText_getNumOfLines();
        bVar1 = iVar3 + -1 <= iVar4;
      }
      else {
        iVar3 = partial_threshold + line_num;
        iVar4 = HText_getNumOfLines();
        bVar1 = iVar3 + -1 <= iVar4;
      }
      if (bVar1) {
        BVar2 = LYMainLoop_pageDisplay(line_num);
        if (BVar2 != '\0') {
          NumOfLines_partial = HText_getNumOfLines();
        }
      }
    }
  }
  return;
}



void HTFinishDisplayPartial(void)

{
  display_partial = '\0';
  return;
}



int HTCopy(HTParentAnchor *anchor,int file_number,void *handle,HTStream *sink)

{
  anon_subr_void_HTStream_ptr_HTError_for__abort *paVar1;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  bool bVar3;
  int iVar4;
  char *Msg;
  int *piVar5;
  FILE *__stream;
  int iVar6;
  int local_44;
  int local_40;
  HTStreamClass targetClass;
  int status;
  int rv;
  int bytes;
  BOOLEAN suppress_readprogress;
  
  paVar1 = sink->isa->_abort;
  paVar2 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0,0);
  do {
    if (LYCancelDownload != '\0') {
      LYCancelDownload = '\0';
      (*paVar1)(sink,(HTError)0x0);
      rv = -1;
finished:
      HTFinishDisplayPartial();
      return rv;
    }
    iVar4 = HTCheckForInterrupt();
    if (iVar4 != 0) {
      mustshow = '\x01';
      Msg = (char *)gettext("Data transfer interrupted.");
      HTProgress(Msg);
      (*paVar1)(sink,(HTError)0x0);
      if (bytes == 0) {
        rv = -1;
      }
      else {
        rv = -0x752e;
      }
      goto finished;
    }
    iVar4 = HTDoRead(file_number,input_buffer,0x1000);
    if (iVar4 < 1) {
      if (iVar4 != 0) {
        if (iVar4 == -0x752e) {
          mustshow = '\x01';
          Msg = (char *)gettext("Data transfer interrupted.");
          HTProgress(Msg);
          (*paVar1)(sink,(HTError)0x0);
          if (bytes == 0) {
            rv = -1;
          }
          else {
            rv = -0x752e;
          }
          goto finished;
        }
        piVar5 = __errno_location();
        if (((*piVar5 != 0x6b) && (piVar5 = __errno_location(), *piVar5 != 0x68)) &&
           (piVar5 = __errno_location(), *piVar5 != 0x20)) {
          HTInetStatus("NETREAD");
          HTAlert("Unexpected read error.");
          if (bytes == 0) {
            (*paVar1)(sink,(HTError)0x0);
            rv = -1;
          }
          else {
            close(file_number);
            rv = 200;
          }
          goto finished;
        }
        if (bytes < 1) {
          rv = -2;
          goto finished;
        }
        HTInetStatus("NETREAD");
        HTAlert("Unexpected server disconnect.");
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTCopy: Unexpected server disconnect. Treating as completed.\n")
          ;
        }
      }
      mustshow = '\x01';
      Msg = (char *)gettext("Data transfer complete");
      HTProgress(Msg);
      close(file_number);
      rv = 200;
      goto finished;
    }
    if (((anchor == (HTParentAnchor *)0x0) || (anchor->content_type == (char *)0x0)) ||
       (iVar6 = strcmp(anchor->content_type,"message/x-http-redirection"), iVar6 != 0)) {
      bVar3 = false;
    }
    else {
      bVar3 = true;
    }
    (*paVar2)(sink,input_buffer,iVar4);
    bytes = bytes + iVar4;
    if (!bVar3) {
      if (anchor == (HTParentAnchor *)0x0) {
        local_44 = 0;
        local_40 = 0;
      }
      else {
        local_44 = anchor->content_length;
        local_40 = local_44 >> 0x1f;
      }
      HTReadProgress((longlong)bytes,CONCAT44(local_40,local_44));
    }
    HTDisplayPartial();
  } while( true );
}



int HTFileCopy(FILE *fp,HTStream *sink)

{
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar1;
  size_t sVar2;
  int iVar3;
  FILE *__stream;
  char *Msg;
  HTStreamClass targetClass;
  int rv;
  int bytes;
  int status;
  
  paVar1 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0,0);
  do {
    sVar2 = fread(input_buffer,1,0x1000,(FILE *)fp);
    if (sVar2 == 0) {
      iVar3 = ferror((FILE *)fp);
      if (iVar3 == 0) {
        rv = 200;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          iVar3 = ferror((FILE *)fp);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFormat: Read error, read returns %d\n",iVar3);
        }
        if (bytes == 0) {
          rv = -1;
        }
        else {
          rv = 0xce;
        }
      }
      goto LAB_0812cb35;
    }
    (*paVar1)(sink,input_buffer,sVar2);
    bytes = bytes + sVar2;
    HTReadProgress((longlong)bytes,0);
    if ((display_partial != '\0') && (HTMainAnchor->content_length != bytes)) {
      HTDisplayPartial();
    }
    iVar3 = HTCheckForInterrupt();
  } while (iVar3 == 0);
  mustshow = '\x01';
  Msg = (char *)gettext("Data transfer interrupted.");
  HTProgress(Msg);
  if (bytes == 0) {
    rv = -1;
  }
  else {
    rv = -0x752e;
  }
LAB_0812cb35:
  HTFinishDisplayPartial();
  return rv;
}



int HTMemCopy(HTChunk *chunk,HTStream *sink)

{
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar1;
  int iVar2;
  char *Msg;
  HTStreamClass targetClass;
  int rv;
  int bytes;
  
  bytes = 0;
  rv = 0;
  paVar1 = sink->isa->put_block;
  HTReadProgress(0,0);
  do {
    if (chunk == (HTChunk *)0x0) {
LAB_0812cc46:
      HTFinishDisplayPartial();
      return rv;
    }
    (*paVar1)(sink,chunk->data,chunk->size);
    bytes = bytes + chunk->size;
    HTReadProgress((longlong)bytes,0);
    HTDisplayPartial();
    iVar2 = HTCheckForInterrupt();
    if (iVar2 != 0) {
      mustshow = '\x01';
      Msg = (char *)gettext("Data transfer interrupted.");
      HTProgress(Msg);
      if (bytes == 0) {
        rv = -1;
      }
      else {
        rv = -0x752e;
      }
      goto LAB_0812cc46;
    }
    chunk = chunk->next;
  } while( true );
}



int HTGzFileCopy(gzFile gzfp,HTStream *sink)

{
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar1;
  int iVar2;
  FILE *__stream;
  undefined4 uVar3;
  char *Msg;
  HTStreamClass targetClass;
  int rv;
  int gzerrnum;
  int bytes;
  int status;
  
  paVar1 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0,0);
  do {
    iVar2 = gzread(gzfp,input_buffer,0x1000);
    if (iVar2 < 1) {
      if (iVar2 == 0) {
        rv = 200;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTGzFileCopy: Read error, gzread returns %d\n",iVar2);
        }
        if (WWW_TraceFlag != '\0') {
          uVar3 = gzerror(gzfp,&gzerrnum);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"gzerror   : %s\n",uVar3);
        }
        if ((WWW_TraceFlag != '\0') && (gzerrnum == -1)) {
          perror("gzerror   ");
        }
        if (bytes == 0) {
          rv = -1;
        }
        else {
          rv = 0xce;
        }
      }
      goto LAB_0812ce12;
    }
    (*paVar1)(sink,input_buffer,iVar2);
    bytes = bytes + iVar2;
    HTReadProgress((longlong)bytes,-1);
    HTDisplayPartial();
    iVar2 = HTCheckForInterrupt();
  } while (iVar2 == 0);
  mustshow = '\x01';
  Msg = (char *)gettext("Data transfer interrupted.");
  HTProgress(Msg);
  if (bytes == 0) {
    rv = -1;
  }
  else {
    rv = -0x752e;
  }
LAB_0812ce12:
  HTFinishDisplayPartial();
  return rv;
}



char * LynxZError(int status)

{
  char result [80];
  
  sprintf((char *)0x81b7f60,"zlib error %d",status);
  return (char *)&ram0x081b7f60;
}



int HTZzFileCopy(FILE *zzfp,HTStream *sink)

{
  int iVar1;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  char dummy_head [2];
  int status_00;
  char *Msg;
  FILE *__stream;
  int in_GS_OFFSET;
  bool bVar3;
  int local_108c;
  int local_1088;
  int local_1084;
  z_stream s;
  HTStreamClass targetClass;
  int len;
  int retry;
  int flush;
  int status;
  int rv;
  int bytes;
  char output_buffer [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  retry = 0;
  len = 0;
  paVar2 = sink->isa->put_block;
  s.zalloc = (alloc_func *)0x0;
  s.zfree = (free_func *)0x0;
  s.opaque = (voidpf)0x0;
  status_00 = inflateInit_(&s,"1.2.3.3",0x38);
  if (status_00 != 0) {
    if (WWW_TraceFlag != '\0') {
      Msg = LynxZError(status_00);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTZzFileCopy inflateInit() %s\n",Msg);
    }
    exit_immediately(1);
  }
  s.avail_in = 0;
  s.next_out = (Bytef *)output_buffer;
  s.avail_out = 0x1000;
  bytes = 0;
  HTReadProgress(0,0);
  while( true ) {
    while( true ) {
      if (s.avail_in == 0) {
        s.next_in = (Bytef *)input_buffer;
        s.avail_in = fread(input_buffer,1,0x1000,(FILE *)zzfp);
        len = s.avail_in;
      }
      status_00 = inflate(&s,0);
      if ((status_00 == 1) || (status_00 == -5)) {
        status_00 = 0x1000 - s.avail_out;
        if (0 < status_00) {
          (*paVar2)(sink,output_buffer,status_00);
          HTReadProgress((longlong)(bytes + status_00),-1);
          HTDisplayPartial();
        }
        rv = 200;
        goto LAB_0812d311;
      }
      if ((status_00 != -3) || (bVar3 = retry != 0, retry = retry + 1, bVar3)) break;
      status_00 = inflateReset(&s);
      if (status_00 != 0) {
        if (WWW_TraceFlag != '\0') {
          Msg = LynxZError(status_00);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTZzFileCopy inflateReset() %s\n",Msg);
        }
        if (bytes == 0) {
          local_108c = -1;
        }
        else {
          local_108c = 0xce;
        }
        rv = local_108c;
        goto LAB_0812d311;
      }
      s.next_in = &ram0x081aa18c;
      s.avail_in = 2;
      inflate(&s,0);
      s.next_in = (Bytef *)input_buffer;
      s.avail_in = len;
    }
    if (status_00 != 0) break;
    if (s.avail_out == 0) {
      len = 0x1000;
      s.next_out = (Bytef *)output_buffer;
      s.avail_out = 0x1000;
      (*paVar2)(sink,output_buffer,0x1000);
      bytes = bytes + 0x1000;
      HTReadProgress((longlong)bytes,-1);
      HTDisplayPartial();
      status_00 = HTCheckForInterrupt();
      if (status_00 != 0) {
        mustshow = '\x01';
        Msg = (char *)gettext("Data transfer interrupted.");
        HTProgress(Msg);
        if (bytes == 0) {
          local_1084 = -1;
        }
        else {
          local_1084 = -0x752e;
        }
        rv = local_1084;
LAB_0812d311:
        inflateEnd(&s);
        HTFinishDisplayPartial();
        if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
          __stack_chk_fail();
        }
        return rv;
      }
    }
    retry = 1;
  }
  if (WWW_TraceFlag != '\0') {
    Msg = LynxZError(status_00);
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTZzFileCopy inflate() %s\n",Msg);
  }
  if (bytes == 0) {
    local_1088 = -1;
  }
  else {
    local_1088 = 0xce;
  }
  rv = local_1088;
  goto LAB_0812d311;
}



void HTCopyNoCR(HTParentAnchor *anchor,int file_number,HTStream *sink)

{
  anon_subr_void_HTStream_ptr_char_for_put_character *paVar1;
  int iVar2;
  HTStreamClass targetClass;
  int character;
  
  paVar1 = sink->isa->put_character;
  HTInitInput(file_number);
  while( true ) {
    iVar2 = HTGetCharacter();
    if (iVar2 == -1) break;
    (*paVar1)(sink,(char)iVar2);
  }
  return;
}



int HTParseSocket(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,int file_number,
                 HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_for__free *paVar3;
  HTStream *sink_00;
  char *fmt;
  FILE *__stream;
  HTStreamClass targetClass;
  char *buffer;
  int rv;
  HTStream *stream;
  
  sink_00 = HTStreamStack(rep_in,format_out,sink,anchor);
  if (sink_00 == (HTStream *)0x0) {
    buffer = (char *)0x0;
    if (LYCancelDownload != '\0') {
      LYCancelDownload = '\0';
      return -1;
    }
    pcVar1 = format_out->name;
    pcVar2 = rep_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
    pcVar1 = buffer;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFormat: %s\n",pcVar1);
    }
    rv = HTLoadError(sink,0x1f5,buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  else {
    paVar3 = sink_00->isa->_free;
    rv = HTCopy(anchor,file_number,(void *)0x0,sink_00);
    if ((rv != -1) && (rv != -0x752e)) {
      (*paVar3)(sink_00);
    }
  }
  return rv;
}



int HTParseFile(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,FILE *fp,HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_for__free *paVar3;
  anon_subr_void_HTStream_ptr_HTError_for__abort *paVar4;
  HTStream *sink_00;
  char *fmt;
  FILE *__stream;
  int iVar5;
  int local_40;
  HTStreamClass targetClass;
  char *buffer;
  int rv;
  HTStream *stream;
  
  sink_00 = HTStreamStack(rep_in,format_out,sink,anchor);
  if (sink_00 == (HTStream *)0x0) {
    buffer = (char *)0x0;
    if (LYCancelDownload == '\0') {
      pcVar1 = format_out->name;
      pcVar2 = rep_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
      pcVar1 = buffer;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFormat(in HTParseFile): %s\n",pcVar1);
      }
      local_40 = HTLoadError(sink,0x1f5,buffer);
      if (buffer != (char *)0x0) {
        free(buffer);
      }
    }
    else {
      LYCancelDownload = '\0';
      local_40 = -1;
    }
  }
  else {
    paVar3 = sink_00->isa->_free;
    paVar4 = sink_00->isa->_abort;
    iVar5 = HTFileCopy(fp,sink_00);
    if ((iVar5 == -1) || (iVar5 == -0x752e)) {
      (*paVar4)(sink_00,(HTError)0x0);
    }
    else {
      (*paVar3)(sink_00);
    }
    if (iVar5 == -1) {
      local_40 = -0xcc;
    }
    else {
      if ((iVar5 == -0x752e) || ((0 < iVar5 && (iVar5 != 200)))) {
        local_40 = 0xce;
      }
      else {
        local_40 = 200;
      }
    }
  }
  return local_40;
}



int HTParseMem(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,HTChunk *chunk,
              HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_for__free *paVar3;
  HTStream *sink_00;
  char *fmt;
  FILE *__stream;
  int local_40;
  HTStreamClass targetClass;
  char *buffer;
  int rv;
  HTStream *stream;
  
  sink_00 = HTStreamStack(rep_in,format_out,sink,anchor);
  if (sink_00 == (HTStream *)0x0) {
    buffer = (char *)0x0;
    pcVar1 = format_out->name;
    pcVar2 = rep_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
    pcVar1 = buffer;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFormat(in HTParseMem): %s\n",pcVar1);
    }
    local_40 = HTLoadError(sink,0x1f5,buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  else {
    paVar3 = sink_00->isa->_free;
    HTMemCopy(chunk,sink_00);
    (*paVar3)(sink_00);
    local_40 = 200;
  }
  return local_40;
}



int HTCloseGzFile(gzFile gzfp)

{
  FILE *__stream;
  int local_18;
  int gzres;
  
  if (gzfp == (gzFile)0x0) {
    local_18 = 0;
  }
  else {
    local_18 = gzclose(gzfp);
    if (WWW_TraceFlag != '\0') {
      if (local_18 == -1) {
        perror("gzclose   ");
      }
      else {
        if ((local_18 != 0) && (WWW_TraceFlag != '\0')) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"gzclose   : error number %d\n",local_18);
        }
      }
    }
  }
  return local_18;
}



int HTParseGzFile(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,gzFile gzfp,
                 HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_for__free *paVar3;
  anon_subr_void_HTStream_ptr_HTError_for__abort *paVar4;
  HTStream *sink_00;
  char *fmt;
  FILE *__stream;
  int iVar5;
  int local_40;
  HTStreamClass targetClass;
  char *buffer;
  int rv;
  HTStream *stream;
  
  sink_00 = HTStreamStack(rep_in,format_out,sink,anchor);
  if (sink_00 == (HTStream *)0x0) {
    buffer = (char *)0x0;
    HTCloseGzFile(gzfp);
    if (LYCancelDownload == '\0') {
      pcVar1 = format_out->name;
      pcVar2 = rep_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
      pcVar1 = buffer;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFormat(in HTParseGzFile): %s\n",pcVar1);
      }
      local_40 = HTLoadError(sink,0x1f5,buffer);
      if (buffer != (char *)0x0) {
        free(buffer);
      }
    }
    else {
      LYCancelDownload = '\0';
      local_40 = -1;
    }
  }
  else {
    paVar3 = sink_00->isa->_free;
    paVar4 = sink_00->isa->_abort;
    iVar5 = HTGzFileCopy(gzfp,sink_00);
    if ((iVar5 == -1) || (iVar5 == -0x752e)) {
      (*paVar4)(sink_00,(HTError)0x0);
    }
    else {
      (*paVar3)(sink_00);
    }
    HTCloseGzFile(gzfp);
    if (iVar5 == -1) {
      local_40 = -0xcc;
    }
    else {
      if ((iVar5 == -0x752e) || ((0 < iVar5 && (iVar5 != 200)))) {
        local_40 = 0xce;
      }
      else {
        local_40 = 200;
      }
    }
  }
  return local_40;
}



int HTParseZzFile(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,FILE *zzfp,
                 HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_for__free *paVar3;
  anon_subr_void_HTStream_ptr_HTError_for__abort *paVar4;
  HTStream *sink_00;
  char *fmt;
  FILE *__stream;
  int iVar5;
  int local_40;
  HTStreamClass targetClass;
  char *buffer;
  int rv;
  HTStream *stream;
  
  sink_00 = HTStreamStack(rep_in,format_out,sink,anchor);
  if (sink_00 == (HTStream *)0x0) {
    buffer = (char *)0x0;
    fclose((FILE *)zzfp);
    if (LYCancelDownload == '\0') {
      pcVar1 = format_out->name;
      pcVar2 = rep_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
      pcVar1 = buffer;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFormat(in HTParseGzFile): %s\n",pcVar1);
      }
      local_40 = HTLoadError(sink,0x1f5,buffer);
      if (buffer != (char *)0x0) {
        free(buffer);
      }
    }
    else {
      LYCancelDownload = '\0';
      local_40 = -1;
    }
  }
  else {
    paVar3 = sink_00->isa->_free;
    paVar4 = sink_00->isa->_abort;
    iVar5 = HTZzFileCopy(zzfp,sink_00);
    if ((iVar5 == -1) || (iVar5 == -0x752e)) {
      (*paVar4)(sink_00,(HTError)0x0);
    }
    else {
      (*paVar3)(sink_00);
    }
    fclose((FILE *)zzfp);
    if (iVar5 == -1) {
      local_40 = -0xcc;
    }
    else {
      if ((iVar5 == -0x752e) || ((0 < iVar5 && (iVar5 != 200)))) {
        local_40 = 0xce;
      }
      else {
        local_40 = 200;
      }
    }
  }
  return local_40;
}



void NetToText_put_character(HTStream *me,char net_char)

{
  char c;
  
  if (*(char *)&me[1].isa != '\0') {
    if (net_char == '\n') {
      (**(code **)((me[2].isa)->name + 0xc))(me[2].isa,10);
      *(undefined *)&me[1].isa = 0;
      return;
    }
    (**(code **)((me[2].isa)->name + 0xc))(me[2].isa,0xd);
  }
  *(bool *)&me[1].isa = net_char == '\r';
  if (*(char *)&me[1].isa == '\0') {
    (**(code **)((me[2].isa)->name + 0xc))(me[2].isa,(int)net_char);
  }
  return;
}



void NetToText_put_string(HTStream *me,char *s)

{
  char *p;
  
  p = s;
  while (*p != '\0') {
    NetToText_put_character(me,*p);
    p = p + 1;
  }
  return;
}



void NetToText_put_block(HTStream *me,char *s,int l)

{
  char *p;
  
  p = s;
  while (p < s + l) {
    NetToText_put_character(me,*p);
    p = p + 1;
  }
  return;
}



void NetToText_free(HTStream *me)

{
  (**(code **)((me[2].isa)->name + 4))(me[2].isa);
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



void NetToText_abort(HTStream *me,HTError e)

{
  (**(code **)((me[2].isa)->name + 8))(me[2].isa,e);
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



HTStream * HTNetToText(HTStream *sink)

{
  HTStream *pHVar1;
  HTStream *me;
  
  pHVar1 = (HTStream *)calloc(1,0xc);
  if (pHVar1 == (HTStream *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFormat.c","NetToText");
  }
  pHVar1->isa = (HTStreamClass *)0x81aa190;
  *(undefined *)&pHVar1[1].isa = 0;
  *(HTStream **)&pHVar1[2].isa = sink;
  return pHVar1;
}



void HTErrorStream_put_character(HTStream *me,char c)

{
  LYCancelDownload = '\x01';
  return;
}



void HTErrorStream_put_string(HTStream *me,char *s)

{
  if ((s != (char *)0x0) && (*s != '\0')) {
    LYCancelDownload = '\x01';
  }
  return;
}



void HTErrorStream_write(HTStream *me,char *s,int l)

{
  if ((l != 0) && (s != (char *)0x0)) {
    LYCancelDownload = '\x01';
  }
  return;
}



void HTErrorStream_free(HTStream *me)

{
  return;
}



void HTErrorStream_abort(HTStream *me,HTError e)

{
  return;
}



HTStream * HTErrorStream(void)

{
  FILE *__stream;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"ErrorStream. Created\n");
  }
  HTBaseStreamInstance = &HTErrorStreamClass;
  return (HTStream *)&HTBaseStreamInstance;
}



void HTMIME_TrimDoubleQuotes(char *value)

{
  size_t sVar1;
  char *cp;
  int i;
  
  if (((value != (char *)0x0) && (*value != '\0')) && (*value == '\"')) {
    sVar1 = strlen(value);
    if (value[sVar1 - 1] == '\"') {
      value[sVar1 - 1] = '\0';
      i = 0;
      while (value[i] != '\0') {
        value[i] = value[i + 1];
        i = i + 1;
      }
    }
  }
  return;
}



BOOLEAN content_is_compressed(HTStream *me)

{
  CompressFileType CVar1;
  FILE *__stream;
  undefined *local_18;
  char *encoding;
  BOOLEAN result;
  
  CVar1 = HTEncodingToCompressType((char *)me[0x509].isa[5]._free);
  if (WWW_TraceFlag != '\0') {
    if (CVar1 != cftNone) {
      local_18 = &DAT_0818c740;
    }
    else {
      local_18 = &DAT_0818c741;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"content is%s compressed\n",local_18);
  }
  return (BOOLEAN)(CVar1 != cftNone);
}



void dequote(char *url)

{
  size_t sVar1;
  int len;
  
  sVar1 = strlen(url);
  if (((*url == '\'') && (1 < (int)sVar1)) && (url[sVar1 - 1] == *url)) {
    url[sVar1 - 1] = '\0';
    while (*url = url[1], *url != '\0') {
      url = url + 1;
    }
  }
  return;
}



char * UncompressedContentType(HTStream *me,CompressFileType method)

{
  anon_subr_void_HTStream_ptr_char_ptr_for_put_string *__s;
  char *b;
  char *a;
  int iVar1;
  HTFormat pHVar2;
  char *description;
  HTAtom *pencoding;
  HTFormat format;
  char *actual;
  char *expected;
  char *address;
  char *result;
  
  result = (char *)0x0;
  __s = (me[0x509].isa)->put_string;
  b = HTCompressTypeToSuffix(method);
  a = strrchr((char *)__s,0x2e);
  if (a != (char *)0x0) {
    iVar1 = strcasecomp(a,b);
    if (iVar1 == 0) {
      pencoding = (HTAtom *)0x0;
      description = (char *)0x0;
      pHVar2 = HTFileFormat((char *)__s,&pencoding,&description);
      result = pHVar2->name;
    }
  }
  return result;
}



// WARNING: Type propagation algorithm not settling

int pumpData(HTStream *me)

{
  anon_subr_void_HTStream_ptr_char_ptr_for_put_string *paVar1;
  anon_subr_void_HTStream_ptr_for__free *paVar2;
  anon_subr_void_HTStream_ptr_for__free *paVar3;
  bool bVar4;
  bool bVar5;
  BOOLEAN BVar6;
  FILE *__stream;
  CompressFileType method_00;
  char *__src;
  char *src;
  HTStreamClass *pHVar7;
  LYUCcharset *pLVar8;
  int LYhndl;
  ushort **ppuVar9;
  time_t tVar10;
  time_t tVar11;
  HTStreamClass *pHVar12;
  anon_subr_void_HTStream_ptr_char_for_put_character *local_50;
  char *base;
  char *txt;
  char *cp;
  char *cp3;
  LYUCcharset *p_out;
  LYUCcharset *p_in;
  int chndl;
  char *cp4;
  char *cp2;
  char *cp1;
  char *new_content;
  char *new_encoding;
  CompressFileType method;
  BOOLEAN given_and_display_8859like;
  BOOLEAN given_is_8859like;
  BOOLEAN given_is_8859;
  BOOLEAN chartrans_ok;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Begin pumpData\n");
  }
  if (WWW_TraceFlag != '\0') {
    paVar1 = (me[0x509].isa)->put_string;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"...address{%s}\n",paVar1);
  }
  method_00 = HTContentTypeToCompressType((char *)me[0x509].isa[4].put_string);
  if ((method_00 != cftNone) &&
     ((me[0x509].isa[5]._free == (anon_subr_void_HTStream_ptr_for__free *)0x0 ||
      (*me[0x509].isa[5]._free == (anon_subr_void_HTStream_ptr_for__free)0x0)))) {
    __src = UncompressedContentType(me,method_00);
    if (__src != (char *)0x0) {
      src = HTCompressTypeToEncoding(method_00);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"reinterpreting as content-type:%s, encoding:%s\n",__src,src);
      }
      HTSACopy((char **)&me[0x509].isa[5]._free,src);
      if (me[0x511].isa != (HTStreamClass *)0x0) {
        free(me[0x511].isa);
        me[0x511].isa = (HTStreamClass *)0x0;
      }
      HTSACopy((char **)(me + 0x511),src);
      strcpy((char *)(me + 9),__src);
      HTSACopy((char **)&me[0x509].isa[4].put_string,(char *)(me + 9));
      pHVar7 = (HTStreamClass *)HTAtom_for((char *)(me + 9));
      me[0x514].isa = pHVar7;
    }
  }
  __src = strchr((char *)(me[0x514].isa)->_free,0x3b);
  if (__src == (char *)0x0) goto LAB_0812e870;
  cp = (char *)0x0;
  cp3 = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    paVar2 = (me[0x514].isa)->_free;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMIME: Extended MIME Content-Type is %s\n",paVar2);
  }
  HTSACopy(&cp,(char *)(me[0x514].isa)->_free);
  LYLowerCase(cp);
  __src = strchr(cp,0x3b);
  if (__src != (char *)0x0) {
    bVar4 = false;
    cp2 = strstr(__src,"charset");
    if (cp2 == (char *)0x0) {
      *__src = '\0';
      pHVar7 = (HTStreamClass *)HTAtom_for(cp);
      me[0x514].isa = pHVar7;
    }
    else {
      cp2 = cp2 + 7;
      while (((*cp2 == ' ' || (*cp2 == '=')) || (*cp2 == '\"'))) {
        cp2 = cp2 + 1;
      }
      HTSACopy(&cp3,cp2);
      local_50 = (anon_subr_void_HTStream_ptr_char_for_put_character *)cp3;
      cp4 = cp3;
      while (((*cp4 != '\0' && (*cp4 != '\"')) &&
             ((*cp4 != ';' && ((*cp4 != ':' && (0x20 < (byte)*cp4))))))) {
        cp4 = cp4 + 1;
      }
      *cp4 = '\0';
      chndl = UCGetLYhndl_byMIME(cp3);
      BVar6 = UCCanTranslateFromTo(chndl,current_char_set);
      if (BVar6 == '\0') {
        if (chndl < 0) {
          chndl = UCLYhndl_for_unrec;
          if (UCLYhndl_for_unrec < 0) {
            chndl = UCLYhndl_for_unspec;
          }
          BVar6 = UCCanTranslateFromTo(chndl,current_char_set);
          if (BVar6 != '\0') {
            bVar4 = true;
            *__src = '\0';
            pHVar7 = (HTStreamClass *)HTAtom_for(cp);
            me[0x514].isa = pHVar7;
            HTAnchor_setUCInfoStage((HTParentAnchor *)me[0x509].isa,chndl,0,1);
          }
        }
        else {
          *__src = '\0';
          pHVar7 = (HTStreamClass *)HTAtom_for(cp);
          me[0x514].isa = pHVar7;
          HTSACopy((char **)&me[0x509].isa[1].put_character,(char *)local_50);
          HTAnchor_setUCInfoStage((HTParentAnchor *)me[0x509].isa,chndl,0,5);
        }
      }
      else {
        bVar4 = true;
        *__src = '\0';
        pHVar7 = (HTStreamClass *)HTAtom_for(cp);
        me[0x514].isa = pHVar7;
        HTSACopy((char **)&me[0x509].isa[1].put_character,(char *)local_50);
        HTAnchor_setUCInfoStage((HTParentAnchor *)me[0x509].isa,chndl,0,5);
      }
      if (bVar4) {
        pLVar8 = HTAnchor_getUCInfoStage((HTParentAnchor *)me[0x509].isa,0);
        p_out = HTAnchor_setUCInfoStage((HTParentAnchor *)me[0x509].isa,current_char_set,3,1);
        if (p_out == (LYUCcharset *)0x0) {
          p_out = HTAnchor_getUCInfoStage((HTParentAnchor *)me[0x509].isa,3);
        }
        LYhndl = strcmp(pLVar8->MIMEname,"x-transparent");
        if (LYhndl == 0) {
          HTPassEightBitRaw = '\x01';
          LYhndl = HTAnchor_getUCLYhndl((HTParentAnchor *)me[0x509].isa,3);
          HTAnchor_setUCInfoStage((HTParentAnchor *)me[0x509].isa,LYhndl,0,1);
        }
        LYhndl = strcmp(p_out->MIMEname,"x-transparent");
        if (LYhndl == 0) {
          HTPassEightBitRaw = '\x01';
          LYhndl = HTAnchor_getUCLYhndl((HTParentAnchor *)me[0x509].isa,0);
          HTAnchor_setUCInfoStage((HTParentAnchor *)me[0x509].isa,LYhndl,3,1);
        }
        if ((pLVar8->enc == 5) || ((pLVar8->enc == 7 && (p_out->enc == 5)))) {
          if (p_out->enc == 5) {
            Set_HTCJK(pLVar8->MIMEname,p_out->MIMEname);
          }
        }
        else {
          HTCJK = NOCJK;
          if (((pLVar8->codepoints & 1U) == 0) && (chndl == current_char_set)) {
            HTPassEightBitRaw = '\x01';
          }
        }
      }
      else {
        LYhndl = strncmp((char *)local_50,"iso-8859-",9);
        if (LYhndl == 0) {
          ppuVar9 = __ctype_b_loc();
          if (((*ppuVar9)[(byte)((char *)local_50)[9]] & 0x800) == 0) goto LAB_0812e67c;
          bVar4 = true;
        }
        else {
LAB_0812e67c:
          bVar4 = false;
        }
        if (bVar4) {
LAB_0812e6ed:
          bVar5 = true;
        }
        else {
          LYhndl = strncmp((char *)local_50,"windows-",8);
          if (LYhndl == 0) goto LAB_0812e6ed;
          LYhndl = strncmp((char *)local_50,"cp12",4);
          if (LYhndl == 0) goto LAB_0812e6ed;
          LYhndl = strncmp((char *)local_50,"cp-12",5);
          if (LYhndl == 0) goto LAB_0812e6ed;
          bVar5 = false;
        }
        if (bVar5) {
          src = strstr(LYchar_set_names[current_char_set],"ISO-8859");
          if (src == (char *)0x0) {
            src = strstr(LYchar_set_names[current_char_set],"windows-");
            if (src == (char *)0x0) goto LAB_0812e753;
          }
          bVar5 = true;
        }
        else {
LAB_0812e753:
          bVar5 = false;
        }
        if (bVar5) {
          *__src = '\0';
          pHVar7 = (HTStreamClass *)HTAtom_for(cp);
          me[0x514].isa = pHVar7;
        }
        if (bVar4) {
          cp1 = (char *)local_50 + 10;
          while (*cp1 != '\0') {
            ppuVar9 = __ctype_b_loc();
            if (((*ppuVar9)[(byte)*cp1] & 0x800) == 0) break;
            cp1 = cp1 + 1;
          }
          *cp1 = '\0';
        }
        if (bVar5) {
          HTSACopy((char **)&me[0x509].isa[1].put_character,(char *)local_50);
          HTPassEightBitRaw = '\x01';
        }
        if (*local_50 == (anon_subr_void_HTStream_ptr_char_for_put_character)0x0) {
          local_50 = me[0x509].isa[1].put_character;
        }
        else {
        }
        HTAlert((char *)local_50);
      }
      if (cp3 != (char *)0x0) {
        free(cp3);
        cp3 = (char *)0x0;
      }
    }
  }
  if (cp != (char *)0x0) {
    free(cp);
    cp = (char *)0x0;
  }
LAB_0812e870:
  if ((*(char *)&me[0x509].isa[4].put_character == '\0') &&
     (me[0x509].isa[6].put_string != (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0)) {
    LYhndl = strcmp((char *)me[0x509].isa[6].put_string,"0");
    if (LYhndl == 0) {
      *(undefined *)&me[0x509].isa[4].put_character = 1;
    }
    else {
      if (me[0x509].isa[6].put_character ==
          (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0) {
        tVar10 = LYmktime((char *)me[0x509].isa[6].put_string,'\0');
        if (tVar10 == 0) {
          *(undefined *)&me[0x509].isa[4].put_character = 1;
        }
      }
      else {
        tVar10 = LYmktime((char *)me[0x509].isa[6].put_string,'\x01');
        tVar11 = LYmktime((char *)me[0x509].isa[6].put_character,'\x01');
        if (tVar10 <= tVar11) {
          *(undefined *)&me[0x509].isa[4].put_character = 1;
        }
      }
    }
  }
  HTSACopy((char **)&me[0x509].isa[4].put_block,(char *)(me[0x514].isa)->_free);
  if ((me[0x50c].isa != (HTStreamClass *)0x0) || (me[0x50d].isa != (HTStreamClass *)0x0)) {
    LYSetCookie((char *)me[0x50c].isa,(char *)me[0x50d].isa,(char *)(me[0x509].isa)->put_string);
    if (me[0x50c].isa != (HTStreamClass *)0x0) {
      free(me[0x50c].isa);
      me[0x50c].isa = (HTStreamClass *)0x0;
    }
    if (me[0x50d].isa != (HTStreamClass *)0x0) {
      free(me[0x50d].isa);
      me[0x50d].isa = (HTStreamClass *)0x0;
    }
  }
  if (*(char *)((int)&me[6].isa + 1) != '\0') {
    if ((me[0x50e].isa == (HTStreamClass *)0x0) || (*(char *)&(me[0x50e].isa)->name == '\0')) {
      permanent_redirection = '\0';
      if (me[0x50e].isa != (HTStreamClass *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTTP: \'Location:\' is zero-length!\n");
        }
        HTAlert("Got redirection with a bad Location header.");
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTTP: Failed to pick up location.\n");
      }
      if (me[0x50e].isa == (HTStreamClass *)0x0) {
        HTAlert("Got redirection with no Location header.");
      }
      else {
        if (me[0x50e].isa != (HTStreamClass *)0x0) {
          free(me[0x50e].isa);
          me[0x50e].isa = (HTStreamClass *)0x0;
        }
      }
    }
    else {
      redirecting_url = (char *)me[0x50e].isa;
      me[0x50e].isa = (HTStreamClass *)0x0;
      pHVar7 = me[0x51c].isa;
      pHVar12 = (HTStreamClass *)HTAtom_for("www/debug");
      if ((pHVar7 != pHVar12) || (me[0x50a].isa != (HTStreamClass *)0x0)) {
        *(undefined *)&me[6].isa = 1;
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"...pumpData finished reading header\n");
  }
  if (*(char *)&me[6].isa == '\0') {
    if (*(char *)((int)&me[6].isa + 2) == '\0') {
      if (me[0x511].isa == (HTStreamClass *)0x0) {
        if (WWW_TraceFlag != '\0') {
          paVar2 = (me[0x51c].isa)->_free;
          paVar3 = (me[0x514].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTMIME: MIME Content-Type is \'%s\', converting to \'%s\'\n",
                  paVar3,paVar2);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          paVar2 = (me[0x514].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTMIME: MIME Content-Type is \'%s\',\n",paVar2);
        }
        pHVar7 = (HTStreamClass *)HTAtom_for("www/compressed");
        me[0x514].isa = pHVar7;
        if (WWW_TraceFlag != '\0') {
          paVar2 = (me[0x51c].isa)->_free;
          paVar3 = (me[0x514].isa)->_free;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"        Treating as \'%s\'.  Converting to \'%s\'\n",paVar3,
                  paVar2);
        }
        if (me[0x511].isa != (HTStreamClass *)0x0) {
          free(me[0x511].isa);
          me[0x511].isa = (HTStreamClass *)0x0;
        }
      }
      pHVar7 = (HTStreamClass *)
               HTStreamStack((HTFormat)me[0x514].isa,(HTFormat)me[0x51c].isa,
                             (HTStream *)me[0x50a].isa,(HTParentAnchor *)me[0x509].isa);
      me[0x515].isa = pHVar7;
      if (me[0x515].isa == (HTStreamClass *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTMIME: Can\'t translate! ** \n");
        }
        me[0x515].isa = me[0x50a].isa;
      }
    }
    else {
      me[0x515].isa = me[0x50a].isa;
    }
    if (me[0x515].isa == (HTStreamClass *)0x0) {
      me[2].isa = (HTStreamClass *)0x4f;
    }
    else {
      pHVar7 = (HTStreamClass *)(me[0x515].isa)->name;
      me[0x516].isa = (HTStreamClass *)pHVar7->name;
      me[0x517].isa = (HTStreamClass *)pHVar7->_free;
      me[0x518].isa = (HTStreamClass *)pHVar7->_abort;
      me[0x519].isa = (HTStreamClass *)pHVar7->put_character;
      me[0x51a].isa = (HTStreamClass *)pHVar7->put_string;
      me[0x51b].isa = (HTStreamClass *)pHVar7->put_block;
      me[2].isa = (HTStreamClass *)(uint)(*(char *)&me[0x512].isa != '\0');
    }
    if (me[0x50f].isa != (HTStreamClass *)0x0) {
      BVar6 = content_is_compressed(me);
      if (BVar6 == '\0') {
        cp3 = (char *)0x0;
        cp = (char *)0x0;
        txt = (char *)0x0;
        LYParseRefreshURL((char *)me[0x50f].isa,&cp,&cp3);
        if (cp3 != (char *)0x0) {
          pHVar7 = me[0x514].isa;
          pHVar12 = (HTStreamClass *)HTAtom_for("text/html");
          if (pHVar7 == pHVar12) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"Formatting refresh-url as first line of result\n");
            }
            __src = (char *)gettext("Refresh: ");
            HTSprintf0(&txt,__src);
            __src = cp;
            src = (char *)gettext("%s seconds ");
            HTSprintf(&txt,src,__src);
            dequote(cp3);
            HTSprintf(&txt,"<a href=\"%s%s\">%s</a><br>",&DAT_0818c740,cp3,cp3);
            __src = cp3;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"URL %s%s\n",&DAT_0818c740,__src);
            }
            (*me->isa->put_string)(me,txt);
            free(txt);
          }
        }
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        if (cp3 != (char *)0x0) {
          free(cp3);
          cp3 = (char *)0x0;
        }
      }
    }
  }
  else {
    me[2].isa = (HTStreamClass *)0x4f;
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"...end of pumpData\n");
  }
  return 0;
}



int dispatchField(HTStream *me)

{
  char *pcVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  anon_subr_void_HTStream_ptr_HTError_for__abort *paVar4;
  ushort **ppuVar5;
  HTStreamClass *pHVar6;
  int iVar7;
  FILE *__stream;
  undefined local_2d;
  char *cp0;
  char *cp1;
  char *cp;
  int j;
  int i;
  
  *(undefined *)&(me[8].isa)->name = 0;
  cp = (char *)me[8].isa;
  while ((me + 9 < cp && (cp = cp + -1, *cp == ' '))) {
    *cp = '\0';
  }
  switch(me[4].isa) {
  case (HTStreamClass *)0xb:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Accept-Ranges: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0xc:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Age: \'%s\'\n",me + 9);
    }
    break;
  default:
    return -1;
  case (HTStreamClass *)0xe:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Allow: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0xf:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Alternates: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x11:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Cache-Control: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      LYLowerCase((char *)(me + 9));
      HTSACopy((char **)&me[0x509].isa[4]._abort,(char *)(me + 9));
      cp0 = (char *)(me + 9);
      while (cp1 = strstr(cp0,"no-cache"), cp1 != (char *)0x0) {
        cp1 = cp1 + 8;
        while ((*cp1 != '\0' && ((byte)*cp1 < 0x21))) {
          cp1 = cp1 + 1;
        }
        if ((*cp1 == '\0') || (*cp1 == ';')) {
          *(undefined *)&me[0x509].isa[4].put_character = 1;
          break;
        }
        cp0 = cp1;
      }
      if (*(char *)&me[0x509].isa[4].put_character != '\x01') {
        cp0 = (char *)(me + 9);
        while (cp1 = strstr(cp0,"max-age"), cp1 != (char *)0x0) {
          cp1 = cp1 + 7;
          while ((*cp1 != '\0' && ((byte)*cp1 < 0x21))) {
            cp1 = cp1 + 1;
          }
          if (*cp1 == '=') {
            do {
              pcVar3 = cp1;
              cp1 = pcVar3 + 1;
              pcVar1 = cp1;
              if (*cp1 == '\0') break;
            } while ((byte)*cp1 < 0x21);
            ppuVar5 = __ctype_b_loc();
            if (((*ppuVar5)[(byte)*cp1] & 0x800) != 0) {
              while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp1] & 0x800) != 0) {
                cp1 = cp1 + 1;
              }
              if ((*pcVar1 == '0') && (pcVar3 + 2 == cp1)) {
                *(undefined *)&me[0x509].isa[4].put_character = 1;
                return 0;
              }
            }
          }
          cp0 = cp1;
        }
      }
    }
    break;
  case (HTStreamClass *)0x13:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Cookie: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x15:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Connection: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x17:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Base: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[5]._abort,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x18:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Disposition: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[5].put_character,(char *)(me + 9));
      cp = (char *)me[0x509].isa[5].put_character;
      while ((*cp != '\0' && (iVar7 = strncasecomp(cp,"filename",8), iVar7 != 0))) {
        cp = cp + 1;
      }
      if (*cp != '\0') {
        cp = cp + 8;
        while ((*cp != '\0' && (((byte)*cp < 0x21 || (*cp == '='))))) {
          cp = cp + 1;
        }
        if (*cp != '\0') {
          while ((*cp != '\0' && ((byte)*cp < 0x21))) {
            cp = cp + 1;
          }
          if (*cp != '\0') {
            HTSACopy((char **)&me[0x509].isa[4]._free,cp);
            if (*me[0x509].isa[4]._free == (anon_subr_void_HTStream_ptr_for__free)0x22) {
              pcVar3 = strchr((char *)(me[0x509].isa[4]._free + 1),0x22);
              if (pcVar3 == (char *)0x0) {
                if (me[0x509].isa[4]._free == (anon_subr_void_HTStream_ptr_for__free *)0x0) {
                  return 0;
                }
                free(me[0x509].isa[4]._free);
                me[0x509].isa[4]._free = (anon_subr_void_HTStream_ptr_for__free *)0x0;
                return 0;
              }
              pcVar3[1] = '\0';
              HTMIME_TrimDoubleQuotes((char *)me[0x509].isa[4]._free);
            }
            cp = (char *)me[0x509].isa[4]._free;
            while ((*cp != '\0' && (0x20 < (byte)*cp))) {
              cp = cp + 1;
            }
            *cp = '\0';
            if ((*me[0x509].isa[4]._free == (anon_subr_void_HTStream_ptr_for__free)0x0) &&
               (me[0x509].isa[4]._free != (anon_subr_void_HTStream_ptr_for__free *)0x0)) {
              free(me[0x509].isa[4]._free);
              me[0x509].isa[4]._free = (anon_subr_void_HTStream_ptr_for__free *)0x0;
            }
          }
        }
      }
    }
    break;
  case (HTStreamClass *)0x19:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Encoding: \'%s\'\n",me + 9);
    }
    if ((*(char *)&me[9].isa != '\0') &&
       (iVar7 = strcasecomp((char *)(me + 9),"identity"), iVar7 != 0)) {
      LYLowerCase((char *)(me + 9));
      HTSACopy((char **)&me[0x509].isa[5]._free,(char *)(me + 9));
      if (me[0x511].isa != (HTStreamClass *)0x0) {
        free(me[0x511].isa);
        me[0x511].isa = (HTStreamClass *)0x0;
      }
      BVar2 = content_is_compressed(me);
      if (BVar2 == '\0') {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"                Ignoring it!\n");
        }
      }
      else {
        HTSACopy((char **)(me + 0x511),(char *)(me + 9));
      }
    }
    break;
  case (HTStreamClass *)0x1a:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Features: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x1c:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Language: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      LYLowerCase((char *)(me + 9));
      HTSACopy((char **)(me[0x509].isa + 5),(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x1d:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Length: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      pHVar6 = me[0x509].isa;
      paVar4 = (anon_subr_void_HTStream_ptr_HTError_for__abort *)atoi((char *)(me + 9));
      pHVar6[6]._abort = paVar4;
      if ((int)me[0x509].isa[6]._abort < 0) {
        me[0x509].isa[6]._abort = (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0;
      }
      if (WWW_TraceFlag != '\0') {
        paVar4 = me[0x509].isa[6]._abort;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"        Converted to integer: \'%d\'\n",paVar4);
      }
    }
    break;
  case (HTStreamClass *)0x1e:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Location: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[5].put_string,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x1f:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-MD5: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[5].put_block,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x20:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Range: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x22:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Transfer-Encoding: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      LYLowerCase((char *)(me + 9));
      pHVar6 = (HTStreamClass *)HTAtom_for((char *)(me + 9));
      me[0x510].isa = pHVar6;
    }
    break;
  case (HTStreamClass *)0x23:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Content-Type: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      i = 0;
      j = 0;
      while (*(char *)((int)&me[9].isa + i) != '\0') {
        if ((*(char *)((int)&me[9].isa + i) != ' ') && (*(char *)((int)&me[9].isa + i) != '\"')) {
          ppuVar5 = __ctype_b_loc();
          if (((*ppuVar5)[*(byte *)((int)&me[9].isa + i)] & 0x100) == 0) {
            local_2d = *(undefined *)((int)&me[9].isa + i);
          }
          else {
            iVar7 = tolower((uint)*(byte *)((int)&me[9].isa + i));
            local_2d = (undefined)iVar7;
          }
          *(undefined *)((int)&me[9].isa + j) = local_2d;
          j = j + 1;
        }
        i = i + 1;
      }
      *(undefined *)((int)&me[9].isa + j) = 0;
      pHVar6 = (HTStreamClass *)HTAtom_for((char *)(me + 9));
      me[0x514].isa = pHVar6;
      HTSACopy((char **)&me[0x509].isa[4].put_string,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x24:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Date: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[6].put_character,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x26:
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP ETag: %s\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)(me[0x509].isa + 7),(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x27:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Expires: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[6].put_string,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x28:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Keep-Alive: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x2a:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Last-Modified: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[6].put_block,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x2b:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Link: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x2c:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Location: \'%s\'\n",me + 9);
    }
    if ((*(char *)((int)&me[6].isa + 1) == '\0') || (me[0x50e].isa != (HTStreamClass *)0x0)) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: *** Ignoring Location!\n");
      }
    }
    else {
      HTSACopy((char **)(me + 0x50e),(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x2f:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Pragma: \'%s\'\n",me + 9);
    }
    if ((*(char *)&me[9].isa != '\0') && (iVar7 = strcmp((char *)(me + 9),"no-cache"), iVar7 == 0))
    {
      *(undefined *)&me[0x509].isa[4].put_character = 1;
    }
    break;
  case (HTStreamClass *)0x30:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Proxy-Authenticate: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x31:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Public: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x34:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Refresh: \'%s\'\n",me + 9);
    }
    HTSACopy((char **)(me + 0x50f),(char *)(me + 9));
    break;
  case (HTStreamClass *)0x35:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Retry-After: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x37:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Safe: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      iVar7 = strcasecomp((char *)(me + 9),"YES");
      if ((iVar7 == 0) || (iVar7 = strcasecomp((char *)(me + 9),"TRUE"), iVar7 == 0)) {
        *(undefined *)((int)&me[0x509].isa[3].put_character + 2) = 1;
      }
      else {
        iVar7 = strcasecomp((char *)(me + 9),"NO");
        if ((iVar7 == 0) || (iVar7 = strcasecomp((char *)(me + 9),"FALSE"), iVar7 == 0)) {
          *(undefined *)((int)&me[0x509].isa[3].put_character + 2) = 0;
        }
      }
    }
    break;
  case (HTStreamClass *)0x39:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Server: \'%s\'\n",me + 9);
    }
    if (*(char *)&me[9].isa != '\0') {
      HTSACopy((char **)&me[0x509].isa[7]._free,(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x3b:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Set-Cookie: \'%s\'\n",me + 9);
    }
    if (me[0x50c].isa == (HTStreamClass *)0x0) {
      HTSACopy((char **)(me + 0x50c),(char *)(me + 9));
    }
    else {
      HTSACat((char **)(me + 0x50c),", ");
      HTSACat((char **)(me + 0x50c),(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x3c:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Set-Cookie2: \'%s\'\n",me + 9);
    }
    if (me[0x50d].isa == (HTStreamClass *)0x0) {
      HTSACopy((char **)(me + 0x50d),(char *)(me + 9));
    }
    else {
      HTSACat((char **)(me + 0x50d),", ");
      HTSACat((char **)(me + 0x50d),(char *)(me + 9));
    }
    break;
  case (HTStreamClass *)0x3e:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Title: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x3f:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Transfer-Encoding: \'%s\'\n",me + 9);
    }
    iVar7 = strcmp((char *)(me + 9),"chunked");
    if (iVar7 == 0) {
      *(undefined *)&me[0x512].isa = 1;
    }
    break;
  case (HTStreamClass *)0x41:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Upgrade: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x42:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP URI: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x44:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Vary: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x45:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Via: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x47:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP Warning: \'%s\'\n",me + 9);
    }
    break;
  case (HTStreamClass *)0x48:
    HTMIME_TrimDoubleQuotes((char *)(me + 9));
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: PICKED UP WWW-Authenticate: \'%s\'\n",me + 9);
    }
  }
  return 0;
}



void HTMIME_put_character(HTStream *me,char c)

{
  char cVar1;
  HTStreamClass *pHVar2;
  uint uVar3;
  ushort **ppuVar4;
  FILE *__stream;
  HTStreamClass *local_60;
  uint local_18;
  byte local_10;
  
  local_10 = c;
  switch(me[2].isa) {
  case (HTStreamClass *)0x1:
    while( true ) {
      me[0x513].isa = (HTStreamClass *)0x0;
      me[2].isa = (HTStreamClass *)0x2;
switchD_081304f3_caseD_2:
      ppuVar4 = __ctype_b_loc();
      if (((*ppuVar4)[(byte)c] & 0x1000) != 0) {
        me[0x513].isa = (HTStreamClass *)((int)me[0x513].isa << 4);
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[(byte)c] & 0x800) != 0) {
          me[0x513].isa = (HTStreamClass *)((int)&me[0x513].isa[-2].name + (uint)(byte)c);
          return;
        }
        pHVar2 = me[0x513].isa;
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[(byte)c] & 0x200) == 0) {
          uVar3 = (uint)(byte)c;
        }
        else {
          uVar3 = toupper((uint)(byte)c);
        }
        me[0x513].isa = (HTStreamClass *)((int)&pHVar2[-3].put_string + uVar3 + 1);
        return;
      }
      if (c == ';') {
        me[2].isa = (HTStreamClass *)0x5;
      }
switchD_081304f3_caseD_5:
      if ((c != '\r') && (c != '\n')) break;
      me[2].isa = (HTStreamClass *)0x3;
switchD_081304f3_caseD_3:
      me[2].isa = (HTStreamClass *)0x4;
      if (c == '\r') {
        return;
      }
switchD_081304f3_caseD_4:
      if (me[0x513].isa == (HTStreamClass *)0x0) {
        local_60 = (HTStreamClass *)0x1;
      }
      else {
        local_60 = (HTStreamClass *)0x6;
      }
      me[2].isa = local_60;
      if (c == '\n') {
        return;
      }
    }
    return;
  case (HTStreamClass *)0x2:
    goto switchD_081304f3_caseD_2;
  case (HTStreamClass *)0x3:
    goto switchD_081304f3_caseD_3;
  case (HTStreamClass *)0x4:
    goto switchD_081304f3_caseD_4;
  case (HTStreamClass *)0x5:
    goto switchD_081304f3_caseD_5;
  case (HTStreamClass *)0x6:
    (*(code *)me[0x519].isa)(me[0x515].isa,(int)c);
    me[0x513].isa = (HTStreamClass *)((int)&me[0x513].isa[-1].put_block + 3);
    if (0 < (int)me[0x513].isa) {
      return;
    }
    me[2].isa = (HTStreamClass *)0x7;
    return;
  case (HTStreamClass *)0x7:
    me[2].isa = (HTStreamClass *)0x8;
    if (c == '\r') {
      return;
    }
  case (HTStreamClass *)0x8:
    me[2].isa = (HTStreamClass *)0x1;
    if (c == '\n') {
      return;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTIME_put_character expected LF in chunked data\n");
    }
    me[2].isa = (HTStreamClass *)0x0;
  case (HTStreamClass *)0x0:
    (*(code *)me[0x519].isa)(me[0x515].isa,(int)c);
    return;
  default:
    if (*(char *)&me[1].isa != '\0') {
      if (c == '\r') {
        return;
      }
      if (c == '\n') {
        local_10 = 10;
      }
    }
  }
  switch(me[2].isa) {
  default:
    goto switchD_08130774_caseD_0;
  case (HTStreamClass *)0xa:
    switch(local_10) {
    case 0x43:
    case 99:
      me[7].isa = (HTStreamClass *)0x818d4df;
      me[3].isa = (HTStreamClass *)0xb;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was A, found C, checking for \'cept-ranges:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
                (int)(char)local_10,"\'g\' or \'l\'");
      }
      break;
    case 0x47:
    case 0x67:
      me[7].isa = (HTStreamClass *)0x818d521;
      me[3].isa = (HTStreamClass *)0xc;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was A, found G, checking for \'e:\'\n");
      return;
    case 0x4c:
    case 0x6c:
      me[2].isa = (HTStreamClass *)0xd;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was A, found L, state now AL\'\n");
      return;
    }
    break;
  case (HTStreamClass *)0xb:
  case (HTStreamClass *)0xc:
  case (HTStreamClass *)0xe:
  case (HTStreamClass *)0xf:
  case (HTStreamClass *)0x11:
  case (HTStreamClass *)0x13:
  case (HTStreamClass *)0x15:
  case (HTStreamClass *)0x17:
  case (HTStreamClass *)0x18:
  case (HTStreamClass *)0x19:
  case (HTStreamClass *)0x1a:
  case (HTStreamClass *)0x1c:
  case (HTStreamClass *)0x1d:
  case (HTStreamClass *)0x1e:
  case (HTStreamClass *)0x1f:
  case (HTStreamClass *)0x20:
  case (HTStreamClass *)0x22:
  case (HTStreamClass *)0x23:
  case (HTStreamClass *)0x24:
  case (HTStreamClass *)0x26:
  case (HTStreamClass *)0x27:
  case (HTStreamClass *)0x28:
  case (HTStreamClass *)0x2a:
  case (HTStreamClass *)0x2b:
  case (HTStreamClass *)0x2c:
  case (HTStreamClass *)0x2f:
  case (HTStreamClass *)0x30:
  case (HTStreamClass *)0x31:
  case (HTStreamClass *)0x34:
  case (HTStreamClass *)0x35:
  case (HTStreamClass *)0x37:
  case (HTStreamClass *)0x39:
  case (HTStreamClass *)0x3b:
  case (HTStreamClass *)0x3c:
  case (HTStreamClass *)0x3e:
  case (HTStreamClass *)0x3f:
  case (HTStreamClass *)0x41:
  case (HTStreamClass *)0x42:
  case (HTStreamClass *)0x44:
  case (HTStreamClass *)0x45:
  case (HTStreamClass *)0x47:
  case (HTStreamClass *)0x48:
    me[4].isa = me[2].isa;
    me[2].isa = (HTStreamClass *)0x49;
  case (HTStreamClass *)0x49:
    if (local_10 == 10) {
      me[5].isa = me[2].isa;
      me[2].isa = (HTStreamClass *)0x4c;
      return;
    }
    if (local_10 < 0x21) {
      return;
    }
    me[8].isa = (HTStreamClass *)(me + 9);
    me[2].isa = (HTStreamClass *)0x4a;
  case (HTStreamClass *)0x4a:
GET_VALUE:
    if (local_10 == 10) {
switchD_08130774_caseD_4b:
      if (local_10 != 10) {
        return;
      }
      me[5].isa = me[2].isa;
      me[2].isa = (HTStreamClass *)0x4c;
      return;
    }
    if (me[8].isa < (HTStreamClass *)((int)&me[0x508].isa + 3U)) {
      pHVar2 = me[8].isa;
      *(byte *)&pHVar2->name = local_10;
      me[8].isa = (HTStreamClass *)((int)&pHVar2->name + 1);
      return;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: *** Syntax error. (string too long)\n");
    }
    break;
  case (HTStreamClass *)0xd:
    if (local_10 == 0x54) {
LAB_08130cc9:
      me[7].isa = (HTStreamClass *)0x818d5ed;
      me[3].isa = (HTStreamClass *)0xf;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was AL, found T, checking for \'ernates:\'\n");
      return;
    }
    if ((char)local_10 < 'U') {
      if (local_10 == 0x4c) {
LAB_08130c80:
        me[7].isa = (HTStreamClass *)0x818d5ba;
        me[3].isa = (HTStreamClass *)0xe;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was AL, found L, checking for \'ow:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x6c) goto LAB_08130c80;
      if (local_10 == 0x74) goto LAB_08130cc9;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'l\' or \'t\'");
    }
    break;
  case (HTStreamClass *)0x10:
    if (local_10 == 0x4f) {
LAB_08130dc2:
      me[2].isa = (HTStreamClass *)0x12;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was C, found O, state now CO\'\n");
      return;
    }
    if ((char)local_10 < 'P') {
      if (local_10 == 0x41) {
LAB_08130d79:
        me[7].isa = (HTStreamClass *)0x818d635;
        me[3].isa = (HTStreamClass *)0x11;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was C, found A, checking for \'che-control:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x61) goto LAB_08130d79;
      if (local_10 == 0x6f) goto LAB_08130dc2;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'a\' or \'o\'");
    }
    break;
  case (HTStreamClass *)0x12:
    if (local_10 == 0x4f) {
LAB_08130e93:
      me[7].isa = (HTStreamClass *)0x818d6d8;
      me[3].isa = (HTStreamClass *)0x13;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CO, found O, checking for \'kie:\'\n");
      return;
    }
    if ((char)local_10 < 'P') {
      if (local_10 == 0x4e) {
LAB_08130e5e:
        me[2].isa = (HTStreamClass *)0x14;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was CO, found N, state now CON\n");
        return;
      }
    }
    else {
      if (local_10 == 0x6e) goto LAB_08130e5e;
      if (local_10 == 0x6f) goto LAB_08130e93;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'n\' or \'o\'");
    }
    break;
  case (HTStreamClass *)0x14:
    if (local_10 == 0x54) {
LAB_08130f8f:
      me[7].isa = (HTStreamClass *)0x818d756;
      me[3].isa = (HTStreamClass *)0x16;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CON, found T, checking for \'ent-\'\n");
      return;
    }
    if ((char)local_10 < 'U') {
      if (local_10 == 0x4e) {
LAB_08130f46:
        me[7].isa = (HTStreamClass *)0x818d719;
        me[3].isa = (HTStreamClass *)0x15;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was CON, found N, checking for \'ection:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x6e) goto LAB_08130f46;
      if (local_10 == 0x74) goto LAB_08130f8f;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'n\' or \'t\'");
    }
    break;
  case (HTStreamClass *)0x16:
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: in case CONTENT_\n");
    }
    switch(local_10) {
    case 0x42:
    case 0x62:
      me[7].isa = (HTStreamClass *)0x818dd9d;
      me[3].isa = (HTStreamClass *)0x17;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found B, checking for \'ase:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found nothing; bleah\n");
      }
      break;
    case 0x44:
    case 100:
      me[7].isa = (HTStreamClass *)0x818ddd8;
      me[3].isa = (HTStreamClass *)0x18;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found D, checking for \'isposition:\'\n");
      return;
    case 0x45:
    case 0x65:
      me[7].isa = (HTStreamClass *)0x818de1f;
      me[3].isa = (HTStreamClass *)0x19;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found E, checking for \'ncoding:\'\n");
      return;
    case 0x46:
    case 0x66:
      me[7].isa = (HTStreamClass *)0x818de60;
      me[3].isa = (HTStreamClass *)0x1a;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found F, checking for \'eatures:\'\n");
      return;
    case 0x4c:
    case 0x6c:
      me[2].isa = (HTStreamClass *)0x1b;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found L, state now CONTENT_L\n");
      return;
    case 0x4d:
    case 0x6d:
      me[7].isa = (HTStreamClass *)0x818ded8;
      me[3].isa = (HTStreamClass *)0x1f;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found M, checking for \'d5:\'\n");
      return;
    case 0x52:
    case 0x72:
      me[7].isa = (HTStreamClass *)0x818df0f;
      me[3].isa = (HTStreamClass *)0x20;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found R, checking for \'ange:\'\n");
      return;
    case 0x54:
    case 0x74:
      me[2].isa = (HTStreamClass *)0x21;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_, found T, state now CONTENT_T\n");
      return;
    }
    break;
  case (HTStreamClass *)0x1b:
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: in case CONTENT_L\n");
    }
    switch(local_10) {
    case 0x41:
    case 0x61:
      me[7].isa = (HTStreamClass *)0x818dfcb;
      me[3].isa = (HTStreamClass *)0x1c;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_L, found A, checking for \'nguage:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was CONTENT_L, found nothing; bleah\n");
      }
      break;
    case 0x45:
    case 0x65:
      me[7].isa = (HTStreamClass *)0x818e00c;
      me[3].isa = (HTStreamClass *)0x1d;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_L, found E, checking for \'ngth:\'\n");
      return;
    case 0x4f:
    case 0x6f:
      me[7].isa = (HTStreamClass *)0x818d880;
      me[3].isa = (HTStreamClass *)0x1e;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_L, found O, checking for \'cation:\'\n");
      return;
    }
    break;
  case (HTStreamClass *)0x21:
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: in case CONTENT_T\n");
    }
    if (local_10 == 0x59) {
LAB_08132194:
      me[7].isa = (HTStreamClass *)0x818e10d;
      me[3].isa = (HTStreamClass *)0x23;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_T, found Y, checking for \'pe:\'\n");
      return;
    }
    if ((char)local_10 < 'Z') {
      if (local_10 == 0x52) {
LAB_0813214b:
        me[7].isa = (HTStreamClass *)0x818dbc1;
        me[3].isa = (HTStreamClass *)0x22;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,
                "HTMIME: Was CONTENT_T, found R, checking for \'ansfer-encoding:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x72) goto LAB_0813214b;
      if (local_10 == 0x79) goto LAB_08132194;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was CONTENT_T, found nothing; bleah\n");
    }
    break;
  case (HTStreamClass *)0x25:
    if (local_10 == 0x58) {
LAB_0813108b:
      me[7].isa = (HTStreamClass *)0x818d7c8;
      me[3].isa = (HTStreamClass *)0x27;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was E, found X, checking for \'pires:\'\n");
      return;
    }
    if ((char)local_10 < 'Y') {
      if (local_10 == 0x54) {
LAB_08131042:
        me[7].isa = (HTStreamClass *)0x818d796;
        me[3].isa = (HTStreamClass *)0x26;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was E, found T, checking for \'ag:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x74) goto LAB_08131042;
      if (local_10 == 0x78) goto LAB_0813108b;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'t\' or \'x\'");
    }
    break;
  case (HTStreamClass *)0x29:
    switch(local_10) {
    case 0x41:
    case 0x61:
      me[7].isa = (HTStreamClass *)0x818d80a;
      me[3].isa = (HTStreamClass *)0x2a;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was L, found A, checking for \'st-modified:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
                (int)(char)local_10,"\'a\', \'i\' or \'o\'");
      }
      break;
    case 0x49:
    case 0x69:
      me[7].isa = (HTStreamClass *)0x818d84d;
      me[3].isa = (HTStreamClass *)0x2b;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was L, found I, checking for \'nk:\'\n");
      return;
    case 0x4f:
    case 0x6f:
      me[7].isa = (HTStreamClass *)0x818d880;
      me[3].isa = (HTStreamClass *)0x2c;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was L, found O, checking for \'cation:\'\n");
      return;
    }
    break;
  case (HTStreamClass *)0x2d:
    if (local_10 == 0x55) {
LAB_081312a6:
      me[7].isa = (HTStreamClass *)0x818d8ef;
      me[3].isa = (HTStreamClass *)0x31;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was P, found U, checking for \'blic:\'\n");
      return;
    }
    if ((char)local_10 < 'V') {
      if (local_10 == 0x52) {
LAB_08131271:
        me[2].isa = (HTStreamClass *)0x2e;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was P, found R, state now PR\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x72) goto LAB_08131271;
      if (local_10 == 0x75) goto LAB_081312a6;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'r\' or \'u\'");
    }
    break;
  case (HTStreamClass *)0x2e:
    if (local_10 == 0x4f) {
LAB_081313a2:
      me[7].isa = (HTStreamClass *)0x818d965;
      me[3].isa = (HTStreamClass *)0x30;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was PR, found O, checking for \'xy-authenticate\'\n");
      return;
    }
    if ((char)local_10 < 'P') {
      if (local_10 == 0x41) {
LAB_08131359:
        me[7].isa = (HTStreamClass *)0x818d931;
        me[3].isa = (HTStreamClass *)0x2f;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was PR, found A, checking for \'gma\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x61) goto LAB_08131359;
      if (local_10 == 0x6f) goto LAB_081313a2;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'a\' or \'o\'");
    }
    break;
  case (HTStreamClass *)0x32:
    if ((local_10 == 0x45) || (local_10 == 0x65)) {
      me[2].isa = (HTStreamClass *)0x33;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was R, found E\n");
      return;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,&DAT_0818d9c9);
    }
    break;
  case (HTStreamClass *)0x33:
    if (local_10 == 0x54) {
LAB_0813152b:
      me[7].isa = (HTStreamClass *)0x818da00;
      me[3].isa = (HTStreamClass *)0x35;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pHVar2 = me[7].isa;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was RE, found T, checking for \'%s\'\n",pHVar2);
      return;
    }
    if ((char)local_10 < 'U') {
      if (local_10 == 0x46) {
LAB_081314d8:
        me[7].isa = (HTStreamClass *)0x818d9cd;
        me[3].isa = (HTStreamClass *)0x34;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pHVar2 = me[7].isa;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was RE, found F, checking for \'%s\'\n",pHVar2);
        return;
      }
    }
    else {
      if (local_10 == 0x66) goto LAB_081314d8;
      if (local_10 == 0x74) goto LAB_0813152b;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'f\' or \'t\'");
    }
    break;
  case (HTStreamClass *)0x36:
    if (local_10 == 0x45) {
LAB_0813162e:
      me[2].isa = (HTStreamClass *)0x38;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was S, found E, state now SE\'\n");
      return;
    }
    if ((char)local_10 < 'F') {
      if (local_10 == 0x41) {
LAB_081315e5:
        me[7].isa = (HTStreamClass *)0x818da43;
        me[3].isa = (HTStreamClass *)0x37;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was S, found A, checking for \'fe:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x61) goto LAB_081315e5;
      if (local_10 == 0x65) goto LAB_0813162e;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'a\' or \'e\'");
    }
    break;
  case (HTStreamClass *)0x38:
    if (local_10 == 0x54) {
LAB_08131716:
      me[7].isa = (HTStreamClass *)0x818dad9;
      me[3].isa = (HTStreamClass *)0x3a;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was SE, found T, checking for \'-cookie\'\n");
      return;
    }
    if ((char)local_10 < 'U') {
      if (local_10 == 0x52) {
LAB_081316cd:
        me[7].isa = (HTStreamClass *)0x818daa6;
        me[3].isa = (HTStreamClass *)0x39;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was SE, found R, checking for \'ver\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x72) goto LAB_081316cd;
      if (local_10 == 0x74) goto LAB_08131716;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'r\' or \'t\'");
    }
    break;
  case (HTStreamClass *)0x3a:
    if (local_10 == 0x32) {
      me[7].isa = (HTStreamClass *)0x818db4d;
      me[3].isa = (HTStreamClass *)0x3c;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was SET_COOKIE, found 2, checking for \':\'\n");
      return;
    }
    if (local_10 == 0x3a) {
      me[4].isa = (HTStreamClass *)0x3b;
      me[2].isa = (HTStreamClass *)0x49;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was SET_COOKIE, found :, processing\n");
      return;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\':\' or \'2\'");
    }
    break;
  case (HTStreamClass *)0x3d:
    if (local_10 == 0x52) {
LAB_081318ec:
      me[7].isa = (HTStreamClass *)0x818dbc1;
      me[3].isa = (HTStreamClass *)0x3f;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was T, found R, checking for \'ansfer-encoding\'\n");
      return;
    }
    if ((char)local_10 < 'S') {
      if (local_10 == 0x49) {
LAB_081318a3:
        me[7].isa = (HTStreamClass *)0x818db8e;
        me[3].isa = (HTStreamClass *)0x3e;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was T, found I, checking for \'tle:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x69) goto LAB_081318a3;
      if (local_10 == 0x72) goto LAB_081318ec;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'i\' or \'r\'");
    }
    break;
  case (HTStreamClass *)0x40:
    if (local_10 == 0x52) {
LAB_081319e8:
      me[7].isa = (HTStreamClass *)0x818dc4f;
      me[3].isa = (HTStreamClass *)0x42;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was U, found R, checking for \'i:\'\n");
      return;
    }
    if ((char)local_10 < 'S') {
      if (local_10 == 0x50) {
LAB_0813199f:
        me[7].isa = (HTStreamClass *)0x818dc17;
        me[3].isa = (HTStreamClass *)0x41;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was U, found P, checking for \'grade:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x70) goto LAB_0813199f;
      if (local_10 == 0x72) goto LAB_081319e8;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'p\' or \'r\'");
    }
    break;
  case (HTStreamClass *)0x43:
    if (local_10 == 0x49) {
LAB_08131ae4:
      me[7].isa = (HTStreamClass *)0x818dcbc;
      me[3].isa = (HTStreamClass *)0x45;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was V, found I, checking for \'a:\'\n");
      return;
    }
    if ((char)local_10 < 'J') {
      if (local_10 == 0x41) {
LAB_08131a9b:
        me[7].isa = (HTStreamClass *)0x818dc8a;
        me[3].isa = (HTStreamClass *)0x44;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was V, found A, checking for \'ry:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x61) goto LAB_08131a9b;
      if (local_10 == 0x69) goto LAB_08131ae4;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'a\' or \'i\'");
    }
    break;
  case (HTStreamClass *)0x46:
    if (local_10 == 0x57) {
LAB_08131be0:
      me[7].isa = (HTStreamClass *)0x818dd2f;
      me[3].isa = (HTStreamClass *)0x48;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Was W, found W, checking for \'w-authenticate:\'\n");
      return;
    }
    if ((char)local_10 < 'X') {
      if (local_10 == 0x41) {
LAB_08131b97:
        me[7].isa = (HTStreamClass *)0x818dcf6;
        me[3].isa = (HTStreamClass *)0x47;
        me[2].isa = (HTStreamClass *)0x4d;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME: Was W, found A, checking for \'rning:\'\n");
        return;
      }
    }
    else {
      if (local_10 == 0x61) goto LAB_08131b97;
      if (local_10 == 0x77) goto LAB_08131be0;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,"\'a\' or \'w\'");
    }
    break;
  case (HTStreamClass *)0x4b:
    goto switchD_08130774_caseD_4b;
  case (HTStreamClass *)0x4c:
    if ((local_10 != 10) && (local_10 < 0x21)) {
      me[2].isa = me[5].isa;
      if (me[2].isa != (HTStreamClass *)0x4a) {
        return;
      }
      if (me[8].isa == (HTStreamClass *)0x0) {
        return;
      }
      if (me[8].isa == (HTStreamClass *)(me + 9)) {
        return;
      }
      if (*(byte *)((int)&me[8].isa[-1].put_block + 3) < 0x21) {
        return;
      }
      local_10 = 0x20;
      goto GET_VALUE;
    }
    if (me[5].isa == (HTStreamClass *)0x4a) {
      dispatchField(me);
    }
  case (HTStreamClass *)0x9:
    *(undefined *)&me[1].isa = 1;
    switch(local_10) {
    case 10:
      *(undefined *)&me[1].isa = 0;
      pumpData(me);
      return;
    case 0x41:
    case 0x61:
      me[2].isa = (HTStreamClass *)0xa;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'A\' at beginning of line, state now A\n");
      return;
    case 0x43:
    case 99:
      me[2].isa = (HTStreamClass *)0x10;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'C\' at beginning of line, state now C\n");
      return;
    case 0x44:
    case 100:
      me[7].isa = (HTStreamClass *)0x818d27b;
      me[3].isa = (HTStreamClass *)0x24;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'D\' at beginning of line, checking for \'ate:\'\n");
      return;
    case 0x45:
    case 0x65:
      me[2].isa = (HTStreamClass *)0x25;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'E\' at beginning of line, state now E\n");
      return;
    case 0x4b:
    case 0x6b:
      me[7].isa = (HTStreamClass *)0x818d2ef;
      me[3].isa = (HTStreamClass *)0x28;
      me[2].isa = (HTStreamClass *)0x4d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,
              "HTMIME: Got \'K\' at beginning of line, checking for \'eep-alive:\'\n");
      return;
    case 0x4c:
    case 0x6c:
      me[2].isa = (HTStreamClass *)0x29;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'L\' at beginning of line, state now L\n");
      return;
    case 0x50:
    case 0x70:
      me[2].isa = (HTStreamClass *)0x2d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'P\' at beginning of line, state now P\n");
      return;
    case 0x52:
    case 0x72:
      me[2].isa = (HTStreamClass *)0x32;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'R\' at beginning of line, state now R\n");
      return;
    case 0x53:
    case 0x73:
      me[2].isa = (HTStreamClass *)0x36;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'S\' at beginning of line, state now S\n");
      return;
    case 0x54:
    case 0x74:
      me[2].isa = (HTStreamClass *)0x3d;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'T\' at beginning of line, state now T\n");
      return;
    case 0x55:
    case 0x75:
      me[2].isa = (HTStreamClass *)0x40;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'U\' at beginning of line, state now U\n");
      return;
    case 0x56:
    case 0x76:
      me[2].isa = (HTStreamClass *)0x43;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'V\' at beginning of line, state now V\n");
      return;
    case 0x57:
    case 0x77:
      me[2].isa = (HTStreamClass *)0x46;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Got \'W\' at beginning of line, state now W\n");
      return;
    }
    break;
  case (HTStreamClass *)0x4d:
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[local_10] & 0x100) == 0) {
      local_18 = (uint)local_10;
    }
    else {
      local_18 = tolower((uint)local_10);
    }
    cVar1 = *(char *)&(me[7].isa)->name;
    me[7].isa = (HTStreamClass *)((int)&(me[7].isa)->name + 1);
    if (local_18 == (int)cVar1) {
      if (*(char *)&(me[7].isa)->name != '\0') {
        return;
      }
      me[2].isa = me[3].isa;
      return;
    }
    if (WWW_TraceFlag != '\0') {
      pHVar2 = me[7].isa;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
              (int)(char)local_10,(int)&pHVar2[-1].put_block + 3);
    }
    break;
  case (HTStreamClass *)0x4e:
    (*(code *)me[0x519].isa)(me[0x515].isa,(int)(char)local_10);
    return;
  }
  me[2].isa = (HTStreamClass *)0x4b;
switchD_08130774_caseD_0:
  return;
}



void HTMIME_put_string(HTStream *me,char *s)

{
  FILE *__stream;
  char *p;
  
  if (me[2].isa == (HTStreamClass *)0x0) {
    (*(code *)me[0x51a].isa)(me[0x515].isa,s);
  }
  else {
    if (me[2].isa != (HTStreamClass *)0x4f) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTMIME:  %s\n",s);
      }
      p = s;
      while (*p != '\0') {
        HTMIME_put_character(me,*p);
        p = p + 1;
      }
    }
  }
  return;
}



void HTMIME_write(HTStream *me,char *s,int l)

{
  FILE *__stream;
  char *p;
  
  if (me[2].isa == (HTStreamClass *)0x0) {
    (*(code *)me[0x51b].isa)(me[0x515].isa,s,l);
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME:  %.*s\n",l,s);
    }
    p = s;
    while (p < s + l) {
      HTMIME_put_character(me,*p);
      p = p + 1;
    }
  }
  return;
}



void HTMIME_free(HTStream *me)

{
  if (me != (HTStream *)0x0) {
    if (me[0x50e].isa != (HTStreamClass *)0x0) {
      free(me[0x50e].isa);
      me[0x50e].isa = (HTStreamClass *)0x0;
    }
    if (me[0x511].isa != (HTStreamClass *)0x0) {
      free(me[0x511].isa);
      me[0x511].isa = (HTStreamClass *)0x0;
    }
    if (me[0x515].isa != (HTStreamClass *)0x0) {
      (*(code *)me[0x517].isa)(me[0x515].isa);
    }
    if (me != (HTStream *)0x0) {
      free(me);
    }
  }
  return;
}



void HTMIME_abort(HTStream *me,HTError e)

{
  if (me != (HTStream *)0x0) {
    if (me[0x50e].isa != (HTStreamClass *)0x0) {
      free(me[0x50e].isa);
      me[0x50e].isa = (HTStreamClass *)0x0;
    }
    if (me[0x511].isa != (HTStreamClass *)0x0) {
      free(me[0x511].isa);
      me[0x511].isa = (HTStreamClass *)0x0;
    }
    if (me[0x515].isa != (HTStreamClass *)0x0) {
      (*(code *)me[0x518].isa)(me[0x515].isa,e);
    }
    if (me != (HTStream *)0x0) {
      free(me);
    }
  }
  return;
}



HTStream * HTMIMEConvert(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTStream *pHVar1;
  HTStreamClass *pHVar2;
  HTStream *me;
  
  pHVar1 = (HTStream *)calloc(1,0x1474);
  if (pHVar1 == (HTStream *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTMIMEConvert");
  }
  pHVar1->isa = (HTStreamClass *)0x818e7d8;
  *(HTStream **)&pHVar1[0x50a].isa = sink;
  *(HTParentAnchor **)&pHVar1[0x509].isa = anchor;
  *(undefined *)((int)&pHVar1[0x509].isa[3].put_character + 2) = 0;
  *(undefined *)&pHVar1[0x509].isa[4].put_character = 0;
  if (pHVar1[0x509].isa[4]._abort != (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0) {
    free(pHVar1[0x509].isa[4]._abort);
    pHVar1[0x509].isa[4]._abort = (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0;
  }
  if (pHVar1[0x509].isa[4]._free != (anon_subr_void_HTStream_ptr_for__free *)0x0) {
    free(pHVar1[0x509].isa[4]._free);
    pHVar1[0x509].isa[4]._free = (anon_subr_void_HTStream_ptr_for__free *)0x0;
  }
  if (pHVar1[0x509].isa[1].put_character !=
      (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0) {
    free(pHVar1[0x509].isa[1].put_character);
    pHVar1[0x509].isa[1].put_character = (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0;
  }
  if (pHVar1[0x509].isa[4].put_string != (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0)
  {
    free(pHVar1[0x509].isa[4].put_string);
    pHVar1[0x509].isa[4].put_string = (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0;
  }
  if (pHVar1[0x509].isa[5].name != (char *)0x0) {
    free(pHVar1[0x509].isa[5].name);
    pHVar1[0x509].isa[5].name = (char *)0x0;
  }
  if (pHVar1[0x509].isa[5]._free != (anon_subr_void_HTStream_ptr_for__free *)0x0) {
    free(pHVar1[0x509].isa[5]._free);
    pHVar1[0x509].isa[5]._free = (anon_subr_void_HTStream_ptr_for__free *)0x0;
  }
  if (pHVar1[0x509].isa[5]._abort != (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0) {
    free(pHVar1[0x509].isa[5]._abort);
    pHVar1[0x509].isa[5]._abort = (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0;
  }
  if (pHVar1[0x509].isa[5].put_character !=
      (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0) {
    free(pHVar1[0x509].isa[5].put_character);
    pHVar1[0x509].isa[5].put_character = (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0;
  }
  if (pHVar1[0x509].isa[5].put_string != (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0)
  {
    free(pHVar1[0x509].isa[5].put_string);
    pHVar1[0x509].isa[5].put_string = (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0;
  }
  if (pHVar1[0x509].isa[5].put_block !=
      (anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *)0x0) {
    free(pHVar1[0x509].isa[5].put_block);
    pHVar1[0x509].isa[5].put_block = (anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *)0x0;
  }
  pHVar1[0x509].isa[6]._abort = (anon_subr_void_HTStream_ptr_HTError_for__abort *)0x0;
  if (pHVar1[0x509].isa[6].put_character !=
      (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0) {
    free(pHVar1[0x509].isa[6].put_character);
    pHVar1[0x509].isa[6].put_character = (anon_subr_void_HTStream_ptr_char_for_put_character *)0x0;
  }
  if (pHVar1[0x509].isa[6].put_string != (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0)
  {
    free(pHVar1[0x509].isa[6].put_string);
    pHVar1[0x509].isa[6].put_string = (anon_subr_void_HTStream_ptr_char_ptr_for_put_string *)0x0;
  }
  if (pHVar1[0x509].isa[6].put_block !=
      (anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *)0x0) {
    free(pHVar1[0x509].isa[6].put_block);
    pHVar1[0x509].isa[6].put_block = (anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *)0x0;
  }
  if (pHVar1[0x509].isa[7].name != (char *)0x0) {
    free(pHVar1[0x509].isa[7].name);
    pHVar1[0x509].isa[7].name = (char *)0x0;
  }
  if (pHVar1[0x509].isa[7]._free != (anon_subr_void_HTStream_ptr_for__free *)0x0) {
    free(pHVar1[0x509].isa[7]._free);
    pHVar1[0x509].isa[7]._free = (anon_subr_void_HTStream_ptr_for__free *)0x0;
  }
  pHVar1[0x515].isa = (HTStreamClass *)0x0;
  pHVar1[2].isa = (HTStreamClass *)0x9;
  pHVar2 = (HTStreamClass *)HTAtom_for("text/html");
  pHVar1[0x514].isa = pHVar2;
  pHVar1[0x51c].isa = (HTStreamClass *)pres->rep_out;
  pHVar1[0x50b].isa = (HTStreamClass *)0x0;
  pHVar1[0x50c].isa = (HTStreamClass *)0x0;
  pHVar1[0x50d].isa = (HTStreamClass *)0x0;
  pHVar1[0x50f].isa = (HTStreamClass *)0x0;
  pHVar1[0x510].isa = (HTStreamClass *)0x0;
  pHVar1[0x511].isa = (HTStreamClass *)0x0;
  *(undefined *)&pHVar1[1].isa = 0;
  HTAnchor_setUCInfoStage((HTParentAnchor *)pHVar1[0x509].isa,current_char_set,2,1);
  HTAnchor_setUCInfoStage((HTParentAnchor *)pHVar1[0x509].isa,current_char_set,3,1);
  return pHVar1;
}



HTStream * HTNetMIME(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTStream *local_18;
  HTStream *me;
  
  local_18 = HTMIMEConvert(pres,anchor,sink);
  if (local_18 == (HTStream *)0x0) {
    local_18 = (HTStream *)0x0;
  }
  else {
    *(undefined *)&local_18[1].isa = 1;
  }
  return local_18;
}



HTStream * HTMIMERedirect(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTStreamClass *pHVar1;
  HTStreamClass *pHVar2;
  HTStream *local_1c;
  HTStream *me;
  
  local_1c = HTMIMEConvert(pres,anchor,sink);
  if (local_1c == (HTStream *)0x0) {
    local_1c = (HTStream *)0x0;
  }
  else {
    *(undefined *)((int)&local_1c[6].isa + 1) = 1;
    pHVar1 = local_1c[0x51c].isa;
    pHVar2 = (HTStreamClass *)HTAtom_for("www/debug");
    if ((pHVar1 == pHVar2) && (sink != (HTStream *)0x0)) {
      *(undefined *)((int)&local_1c[6].isa + 2) = 1;
    }
  }
  return local_1c;
}



void HTmmdec_base64(char **t,char *s)

{
  size_t sVar1;
  char *src;
  char *pcVar2;
  char *p;
  char nw [4];
  char *bp;
  char *buf;
  int val;
  int j;
  int count;
  int d;
  
  sVar1 = strlen(s);
  src = (char *)malloc(sVar1 * 3 + 1);
  bp = src;
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTmmdec_base64");
  }
  do {
    if (*s == '\0') {
      *bp = '\0';
      HTSACopy(t,src);
      if (src != (char *)0x0) {
        free(src);
      }
      return;
    }
    val = 0;
    if (s[2] == '=') {
      count = 1;
    }
    else {
      if (s[3] == '=') {
        count = 2;
      }
      else {
        count = 3;
      }
    }
    j = 0;
    while (j <= count) {
      pcVar2 = strchr(HTmm64,(int)s[j]);
      if (pcVar2 == (char *)0x0) {
        return;
      }
      val = val + ((int)(pcVar2 + -0x81aa1c0) << (('\x03' - (char)j) * '\x06' & 0x1fU));
      j = j + 1;
    }
    j = 2;
    while (-1 < j) {
      nw[j] = (char)val;
      val = val >> 8;
      j = j + -1;
    }
    if (count != 0) {
      *bp = nw[0];
      bp = bp + 1;
    }
    if (count != 1) {
      *bp = nw[1];
      bp = bp + 1;
    }
    if (count != 2) {
      *bp = nw[2];
      bp = bp + 1;
    }
    s = s + 4;
  } while( true );
}



void HTmmdec_quote(char **t,char *s)

{
  size_t sVar1;
  char *src;
  char *pcVar2;
  char *pcVar3;
  char *p;
  char *bp;
  char *buf;
  char cval;
  
  sVar1 = strlen(s);
  src = (char *)malloc(sVar1 + 1);
  bp = src;
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTmmdec_quote");
  }
  while (*s != '\0') {
    if (*s == '=') {
      if ((s[1] == '\0') || (pcVar2 = strchr(HTmmquote,(int)s[1]), pcVar2 == (char *)0x0)) {
        *bp = *s;
        s = s + 1;
        bp = bp + 1;
      }
      else {
        if ((s[2] == '\0') || (pcVar3 = strchr(HTmmquote,(int)s[2]), pcVar3 == (char *)0x0)) {
          *bp = *s;
          s = s + 1;
          bp = bp + 1;
        }
        else {
          *bp = (char)pcVar3 + (char)((int)(char)((char)pcVar2 + -2) << 4) + -2;
          s = s + 3;
          bp = bp + 1;
        }
      }
    }
    else {
      if (*s == '_') {
        *bp = ' ';
        s = s + 1;
        bp = bp + 1;
      }
      else {
        *bp = *s;
        s = s + 1;
        bp = bp + 1;
      }
    }
  }
  *bp = '\0';
  HTSACopy(t,src);
  if (src != (char *)0x0) {
    free(src);
  }
  return;
}



void HTmmdecode(char **target,char *source)

{
  size_t sVar1;
  char *src;
  int iVar2;
  int iVar3;
  int quote;
  int base64;
  char *u;
  char *t;
  char *s;
  char *m2buf;
  char *mmbuf;
  char *buf;
  
  mmbuf = (char *)0x0;
  m2buf = (char *)0x0;
  sVar1 = strlen(source);
  src = (char *)malloc(sVar1 + 1);
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTmmdecode");
  }
  s = source;
  u = src;
  while (*s != '\0') {
    iVar2 = strncasecomp(s,"=?ISO-2022-JP?B?",0x10);
    iVar3 = strncasecomp(s,"=?ISO-2022-JP?Q?",0x10);
    if ((iVar2 == 0) || (iVar3 == 0)) {
      t = s;
      if (HTmmcont != 0) {
        while ((t = t + -1, source <= t && ((*t == ' ' || (*t == '\t'))))) {
          u = u + -1;
        }
      }
      if (mmbuf == (char *)0x0) {
        HTSACopy(&mmbuf,source);
      }
      s = s + 0x10;
      t = mmbuf;
      while ((*s != '\0' && ((*s != '?' || (s[1] != '='))))) {
        *t = *s;
        t = t + 1;
        s = s + 1;
        *t = '\0';
      }
      if ((*s != '?') || (s[1] != '=')) goto end;
      s = s + 2;
      *t = '\0';
      if (iVar2 == 0) {
        HTmmdec_base64(&m2buf,mmbuf);
      }
      if (iVar3 == 0) {
        HTmmdec_quote(&m2buf,mmbuf);
      }
      t = m2buf;
      while (*t != '\0') {
        *u = *t;
        u = u + 1;
        t = t + 1;
      }
      HTmmcont = 1;
    }
    else {
      if ((*s != ' ') && (*s != '\t')) {
        HTmmcont = 0;
      }
      *u = *s;
      u = u + 1;
      s = s + 1;
    }
  }
  *u = '\0';
end:
  HTSACopy(target,src);
  if (m2buf != (char *)0x0) {
    free(m2buf);
    m2buf = (char *)0x0;
  }
  if (mmbuf != (char *)0x0) {
    free(mmbuf);
    mmbuf = (char *)0x0;
  }
  if (src != (char *)0x0) {
    free(src);
  }
  return;
}



int HTrjis(char **t,char *s)

{
  bool bVar1;
  char *src;
  size_t sVar2;
  int iVar3;
  int local_18;
  int kanji;
  char *buf;
  char *p;
  
  bVar1 = false;
  src = strchr(s,0x1b);
  if ((src == (char *)0x0) && (src = strchr(s,0x24), src != (char *)0x0)) {
    sVar2 = strlen(s);
    src = (char *)malloc(sVar2 * 2 + 1);
    p = src;
    if (src == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTrjis");
    }
    while (*s != '\0') {
      if (((bVar1) || (*s != '$')) || ((s[1] != '@' && (s[1] != 'B')))) {
        if (((bVar1) && (*s == '(')) && ((s[1] == 'J' || (s[1] == 'B')))) {
          bVar1 = false;
          *p = '\x1b';
          p[1] = *s;
          p[2] = s[1];
          s = s + 2;
          p = p + 3;
        }
        else {
          *p = *s;
          s = s + 1;
          p = p + 1;
        }
      }
      else {
        iVar3 = HTmaybekanji((int)s[2],(int)s[3]);
        if (iVar3 == 0) {
          *p = *s;
          s = s + 1;
          p = p + 1;
        }
        else {
          bVar1 = true;
          *p = '\x1b';
          p[1] = *s;
          p[2] = s[1];
          p[3] = s[2];
          p[4] = s[3];
          s = s + 4;
          p = p + 5;
        }
      }
    }
    *p = *s;
    HTSACopy(t,src);
    if (src != (char *)0x0) {
      free(src);
    }
    local_18 = 0;
  }
  else {
    if (*t != s) {
      HTSACopy(t,s);
    }
    local_18 = 1;
  }
  return local_18;
}



int HTmaybekanji(int c1,int c2)

{
  int local_c;
  
  if ((c2 < 0x21) || (0x7e < c2)) {
    local_c = 0;
  }
  else {
    if ((c1 < 0x21) || (((0x28 < c1 && (c1 < 0x30)) || (0x74 < c1)))) {
      local_c = 0;
    }
    else {
      c2 = c2 + -0x20;
      switch(c1) {
      case 0x22:
        if ((0xe < c2) && (c2 < 0x1a)) {
          return 0;
        }
        if ((0x21 < c2) && (c2 < 0x2a)) {
          return 0;
        }
        if ((0x30 < c2) && (c2 < 0x3c)) {
          return 0;
        }
        if ((0x4a < c2) && (c2 < 0x52)) {
          return 0;
        }
        if ((0x59 < c2) && (c2 < 0x5e)) {
          return 0;
        }
        break;
      case 0x23:
        if (c2 < 0x10) {
          return 0;
        }
        if ((0x19 < c2) && (c2 < 0x21)) {
          return 0;
        }
        if ((0x3a < c2) && (c2 < 0x41)) {
          return 0;
        }
        if (0x5a < c2) {
          return 0;
        }
        break;
      case 0x24:
        if (0x53 < c2) {
          return 0;
        }
        break;
      case 0x25:
        if (0x56 < c2) {
          return 0;
        }
        break;
      case 0x26:
        if ((0x18 < c2) && (c2 < 0x21)) {
          return 0;
        }
        if (0x38 < c2) {
          return 0;
        }
        break;
      case 0x27:
        if ((0x21 < c2) && (c2 < 0x31)) {
          return 0;
        }
        if (0x51 < c2) {
          return 0;
        }
        break;
      case 0x28:
        if (0x20 < c2) {
          return 0;
        }
        break;
      case 0x4f:
        if (0x33 < c2) {
          return 0;
        }
        break;
      case 0x74:
        if (6 < c2) {
          return 0;
        }
      }
      local_c = 1;
    }
  }
  return local_c;
}



void free_NNTP_AuthInfo(void)

{
  void **local_18;
  NNTPAuth *auth;
  HTList *cur;
  
  cur = NNTP_AuthInfo;
  if (NNTP_AuthInfo != (HTList *)0x0) {
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void **)0x0;
      }
      else {
        local_18 = (void **)cur->object;
      }
      if (local_18 == (void **)0x0) break;
      if (*local_18 != (void *)0x0) {
        free(*local_18);
        *local_18 = (void *)0x0;
      }
      if (local_18[1] != (void *)0x0) {
        free(local_18[1]);
        local_18[1] = (void *)0x0;
      }
      if (local_18[2] != (void *)0x0) {
        free(local_18[2]);
        local_18[2] = (void *)0x0;
      }
      if (local_18 != (void **)0x0) {
        free(local_18);
      }
    }
    HTList_delete(NNTP_AuthInfo);
    NNTP_AuthInfo = (HTList *)0x0;
  }
  return;
}



void load_NNTP_AuthInfo(void)

{
  int iVar1;
  FILE *__stream;
  int iVar2;
  char **dest;
  char *pcVar3;
  int in_GS_OFFSET;
  NNTPAuth *auth;
  FILE *fp;
  char the_user [513];
  char the_pass [513];
  char the_host [513];
  char buffer [513];
  char fname [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  LYAddPathToHome(fname,0x100,".newsauth");
  __stream = fopen64(fname,"r");
  if (__stream != (FILE *)0x0) {
    while (pcVar3 = fgets(buffer,0x201,__stream), pcVar3 != (char *)0x0) {
      iVar2 = sscanf(buffer,"%s%s%s",the_host,the_pass,the_user);
      if ((((iVar2 == 3) && (the_host[0] != '\0')) && (the_pass[0] != '\0')) &&
         (the_user[0] != '\0')) {
        dest = (char **)calloc(1,0xc);
        if (dest == (char **)0x0) break;
        HTSACopy(dest,the_host);
        HTSACopy(dest + 2,the_pass);
        HTSACopy(dest + 1,the_user);
        HTList_appendObject(NNTP_AuthInfo,dest);
      }
    }
    fclose(__stream);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * HTGetNewsHost(void)

{
  return HTNewsHost;
}



void HTSetNewsHost(char *value)

{
  HTSACopy(&HTNewsHost,value);
  return;
}



BOOLEAN initialize(void)

{
  int iVar1;
  char *src;
  FILE *__stream;
  FILE *__stream_00;
  int in_GS_OFFSET;
  char *p;
  FILE *fp;
  char server_name [65];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  src = LYGetEnv("NNTPSERVER");
  if (src == (char *)0x0) {
    __stream_00 = fopen64("/usr/local/lib/rn/server","r");
    if (__stream_00 != (FILE *)0x0) {
      src = fgets(server_name,0x41,__stream_00);
      if (src != (char *)0x0) {
        src = strchr(server_name,10);
        if (src != (char *)0x0) {
          *src = '\0';
        }
        HTSACopy(&HTNewsHost,server_name);
        src = HTNewsHost;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTNews: File %s defines news host as `%s\'\n",
                  "/usr/local/lib/rn/server",src);
        }
      }
      fclose(__stream_00);
    }
  }
  else {
    src = LYGetEnv("NNTPSERVER");
    HTSACopy(&HTNewsHost,src);
    src = HTNewsHost;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTNews: NNTPSERVER defined as `%s\'\n",src);
    }
  }
  if (HTNewsHost == (char *)0x0) {
    HTSACopy(&HTNewsHost,"news");
  }
  s = -1;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  s = -1;
  return '\x01';
}



int response(char *command)

{
  char *pcVar1;
  size_t __n;
  FILE *__stream;
  ssize_t sVar2;
  int iVar3;
  int local_2c;
  int length;
  int status;
  int ich;
  char *p;
  int result;
  
  p = response_text;
  pcVar1 = p;
  if (command != (char *)0x0) {
    __n = strlen(command);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"NNTP command to be sent: %s",command);
    }
    sVar2 = write(s,command,__n);
    if (sVar2 < 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTNews: Unable to send command. Disconnecting.\n");
      }
      close(s);
      s = -1;
      return sVar2;
    }
  }
  while( true ) {
    p = pcVar1;
    iVar3 = HTGetCharacter();
    *p = (char)iVar3;
    if ((*p == '\n') || (p + 1 == response_text + 0x200)) break;
    pcVar1 = p + 1;
    if (iVar3 == -1) {
      *p = '\0';
      iVar3 = s;
      if (interrupted_in_htgetcharacter == 0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTNews: EOF on read, closing socket %d\n",iVar3);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTNews: Interrupted on read, closing socket %d\n",iVar3);
        }
      }
      close(s);
      if (interrupted_in_htgetcharacter == 0) {
        local_2c = -1;
      }
      else {
        interrupted_in_htgetcharacter = 0;
        local_2c = -0x752e;
      }
      s = -1;
      return local_2c;
    }
  }
  *p = '\0';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"NNTP Response: %s\n",response_text);
  }
  sscanf(response_text,"%d",&result);
  return result;
}



BOOLEAN match(char *unknown,char *ctemplate)

{
  ushort **ppuVar1;
  uint local_18;
  char *t;
  char *u;
  
  u = unknown;
  t = ctemplate;
  while ((*u != '\0' && (*t != '\0'))) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*u] & 0x200) == 0) {
      local_18 = (uint)(byte)*u;
    }
    else {
      local_18 = toupper((uint)(byte)*u);
    }
    if (local_18 != (int)*t) break;
    u = u + 1;
    t = t + 1;
  }
  return (BOOLEAN)(*t == '\0');
}



NNTPAuthResult HTHandleAuthInfo(char *host)

{
  int iVar1;
  BOOLEAN BVar2;
  char *fmt;
  char **dest;
  int iVar3;
  int in_GS_OFFSET;
  NNTPAuthResult local_230;
  char **local_22c;
  int tries;
  int status;
  char *msg;
  char *PassWord;
  char *UserName;
  NNTPAuth *auth;
  HTList *cur;
  char buffer [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  UserName = (char *)0x0;
  PassWord = (char *)0x0;
  msg = (char *)0x0;
  if (((dump_output_immediately == '\0') && (host != (char *)0x0)) && (*host != '\0')) {
    if (NNTP_AuthInfo == (HTList *)0x0) {
      NNTP_AuthInfo = HTList_new();
      load_NNTP_AuthInfo();
    }
    cur = NNTP_AuthInfo;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_22c = (char **)0x0;
      }
      else {
        local_22c = (char **)cur->object;
      }
      if (local_22c == (char **)0x0) goto LAB_08133cbb;
      iVar3 = strcmp(*local_22c,host);
    } while (iVar3 != 0);
    UserName = local_22c[1];
    PassWord = local_22c[2];
LAB_08133cbb:
    buffer[511] = '\0';
    tries = 3;
    do {
      if (tries == 0) {
LAB_081340ee:
        if (status != 0x17d) goto LAB_081346b4;
        tries = 3;
        goto LAB_081346a7;
      }
      if (UserName == (char *)0x0) {
        fmt = (char *)gettext("Username for news host \'%s\':");
        HTSprintf0(&msg,fmt,host);
        UserName = HTPrompt(msg,(char *)0x0);
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
        if ((UserName == (char *)0x0) || (*UserName == '\0')) {
          if (UserName != (char *)0x0) {
            free(UserName);
          }
          local_230 = NNTPAUTH_ERROR;
          goto LAB_081346be;
        }
      }
      sprintf(buffer,"AUTHINFO USER %.*s%c%c",0x1ef,UserName,0xd,10);
      status = response(buffer);
      if (status < 0) {
        if (status == -0x752e) {
          mustshow = '\x01';
          fmt = (char *)gettext("Connection interrupted.");
          HTProgress(fmt);
        }
        else {
          fmt = (char *)gettext("Connection closed ???");
          HTAlert(fmt);
        }
        if (local_22c == (char **)0x0) {
          if (UserName != (char *)0x0) {
            free(UserName);
          }
        }
        else {
          if (local_22c[1] != UserName) {
            if (local_22c[1] != (char *)0x0) {
              free(local_22c[1]);
              local_22c[1] = (char *)0x0;
            }
            local_22c[1] = UserName;
          }
        }
        local_230 = NNTPAUTH_CLOSE;
        goto LAB_081346be;
      }
      if (status == 0x119) {
        if (local_22c == (char **)0x0) {
          dest = (char **)calloc(1,0xc);
          if (dest != (char **)0x0) {
            HTSACopy(dest,host);
            dest[1] = UserName;
            HTList_appendObject(NNTP_AuthInfo,dest);
          }
        }
        else {
          if (local_22c[1] != UserName) {
            if (local_22c[1] != (char *)0x0) {
              free(local_22c[1]);
              local_22c[1] = (char *)0x0;
            }
            local_22c[1] = UserName;
          }
        }
        local_230 = NNTPAUTH_OK;
        goto LAB_081346be;
      }
      if (status == 0x17d) goto LAB_081340ee;
      HTAlert(response_text);
      tries = tries + -1;
      if (tries < 1) goto LAB_08134041;
      fmt = (char *)gettext("Change username?");
      BVar2 = HTConfirm(fmt);
      if (BVar2 == '\0') goto LAB_08134041;
      if (((local_22c == (char **)0x0) || (local_22c[1] != UserName)) && (UserName != (char *)0x0))
      {
        free(UserName);
        UserName = (char *)0x0;
      }
      fmt = (char *)gettext("Username:");
      UserName = HTPrompt(fmt,UserName);
      if ((UserName == (char *)0x0) || (*UserName == '\0')) goto LAB_08134041;
    } while( true );
  }
  local_230 = NNTPAUTH_ERROR;
  goto LAB_081346be;
LAB_08134041:
  if (local_22c != (char **)0x0) {
    if ((local_22c[1] != UserName) && (local_22c[1] != (char *)0x0)) {
      free(local_22c[1]);
      local_22c[1] = (char *)0x0;
    }
    if (local_22c[2] != (char *)0x0) {
      free(local_22c[2]);
      local_22c[2] = (char *)0x0;
    }
  }
  if (UserName != (char *)0x0) {
    free(UserName);
  }
  local_230 = NNTPAUTH_ERROR;
  goto LAB_081346be;
  while( true ) {
    fmt = (char *)gettext("Change password?");
    BVar2 = HTConfirm(fmt);
    if (BVar2 == '\0') break;
LAB_081346a7:
    if (tries == 0) goto LAB_081346b4;
    if (PassWord == (char *)0x0) {
      fmt = (char *)gettext("Password for news host \'%s\':");
      HTSprintf0(&msg,fmt,host);
      PassWord = HTPromptPassword(msg);
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
      if ((PassWord == (char *)0x0) || (*PassWord == '\0')) {
        if (PassWord != (char *)0x0) {
          free(PassWord);
        }
        local_230 = NNTPAUTH_ERROR;
        goto LAB_081346be;
      }
    }
    sprintf(buffer,"AUTHINFO PASS %.*s%c%c",0x1ef,PassWord,0xd,10);
    iVar3 = response(buffer);
    if (iVar3 < 0) {
      if (iVar3 == -0x752e) {
        mustshow = '\x01';
        fmt = (char *)gettext("Connection interrupted.");
        HTProgress(fmt);
      }
      else {
        fmt = (char *)gettext("Connection closed ???");
        HTAlert(fmt);
      }
      if (local_22c == (char **)0x0) {
        if (UserName != (char *)0x0) {
          free(UserName);
        }
        if (PassWord != (char *)0x0) {
          free(PassWord);
        }
      }
      else {
        if (local_22c[1] != UserName) {
          if (local_22c[1] != (char *)0x0) {
            free(local_22c[1]);
            local_22c[1] = (char *)0x0;
          }
          local_22c[1] = UserName;
        }
        if (local_22c[2] != PassWord) {
          if (local_22c[2] != (char *)0x0) {
            free(local_22c[2]);
            local_22c[2] = (char *)0x0;
          }
          local_22c[2] = PassWord;
        }
      }
      local_230 = NNTPAUTH_CLOSE;
      goto LAB_081346be;
    }
    if (iVar3 == 0x1f6) {
      HTAlert(response_text);
      if (local_22c != (char **)0x0) {
        if (local_22c[1] == UserName) {
          UserName = (char *)0x0;
        }
        if (local_22c[1] != (char *)0x0) {
          free(local_22c[1]);
          local_22c[1] = (char *)0x0;
        }
        if (local_22c[2] == PassWord) {
          PassWord = (char *)0x0;
        }
        if (local_22c[2] != (char *)0x0) {
          free(local_22c[2]);
          local_22c[2] = (char *)0x0;
        }
      }
      if (UserName != (char *)0x0) {
        free(UserName);
      }
      if (PassWord != (char *)0x0) {
        free(PassWord);
      }
      local_230 = NNTPAUTH_CLOSE;
      goto LAB_081346be;
    }
    if (iVar3 == 0x119) {
      if (local_22c == (char **)0x0) {
        dest = (char **)calloc(1,0xc);
        if (dest != (char **)0x0) {
          HTSACopy(dest,host);
          dest[1] = UserName;
          dest[2] = PassWord;
          HTList_appendObject(NNTP_AuthInfo,dest);
        }
      }
      else {
        if (local_22c[1] != UserName) {
          if (local_22c[1] != (char *)0x0) {
            free(local_22c[1]);
            local_22c[1] = (char *)0x0;
          }
          local_22c[1] = UserName;
        }
        if (local_22c[2] != PassWord) {
          if (local_22c[2] != (char *)0x0) {
            free(local_22c[2]);
            local_22c[2] = (char *)0x0;
          }
          local_22c[2] = PassWord;
        }
      }
      local_230 = NNTPAUTH_OK;
      goto LAB_081346be;
    }
    HTAlert(response_text);
    if ((local_22c == (char **)0x0) || (local_22c[2] != PassWord)) {
      if (PassWord != (char *)0x0) {
        free(PassWord);
        PassWord = (char *)0x0;
      }
    }
    else {
      PassWord = (char *)0x0;
    }
    tries = tries + -1;
    if (tries < 1) break;
  }
  if (local_22c != (char **)0x0) {
    if (local_22c[1] == UserName) {
      UserName = (char *)0x0;
    }
    if (local_22c[1] != (char *)0x0) {
      free(local_22c[1]);
      local_22c[1] = (char *)0x0;
    }
    if (local_22c[2] != (char *)0x0) {
      free(local_22c[2]);
      local_22c[2] = (char *)0x0;
    }
  }
  if (UserName != (char *)0x0) {
    free(UserName);
  }
LAB_081346b4:
  local_230 = NNTPAUTH_ERROR;
LAB_081346be:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_230;
}



char * author_name(char *email)

{
  char cVar1;
  FILE *__stream;
  char *pcVar2;
  char *pcVar3;
  char *e;
  char *p;
  
  HTSACopy(&name,email);
  pcVar2 = name;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Trying to find name in: %s\n",pcVar2);
  }
  pcVar2 = strrchr(name,0x28);
  if (((pcVar2 != (char *)0x0) && (pcVar3 = strrchr(name,0x29), pcVar3 != (char *)0x0)) &&
     (pcVar2 < pcVar3)) {
    *pcVar3 = '\0';
    pcVar2 = HTStrip(pcVar2 + 1);
    return pcVar2;
  }
  p = strrchr(name,0x3c);
  if (((p != (char *)0x0) && (e = strrchr(name,0x3e), e != (char *)0x0)) && (p < e)) {
    do {
      e = e + 1;
      *p = *e;
      cVar1 = *p;
      p = p + 1;
    } while (cVar1 != '\0');
    pcVar2 = HTStrip(name);
    return pcVar2;
  }
  pcVar2 = HTStrip(name);
  return pcVar2;
}



char * author_address(char *email)

{
  FILE *__stream;
  char *__s;
  char *pcVar1;
  char *pcVar2;
  ushort **ppuVar3;
  char *local_1c;
  char *e;
  char *at;
  char *p;
  
  HTSACopy(&address,email);
  __s = address;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Trying to find address in: %s\n",__s);
  }
  __s = strrchr(address,0x3c);
  if ((((__s == (char *)0x0) || (pcVar1 = strrchr(__s,0x3e), pcVar1 == (char *)0x0)) ||
      (pcVar2 = strrchr(__s,0x40), pcVar2 == (char *)0x0)) || (pcVar1 <= pcVar2)) {
    __s = strrchr(address,0x28);
    if (((__s == (char *)0x0) || (pcVar1 = strrchr(address,0x29), pcVar1 == (char *)0x0)) ||
       ((pcVar2 = strchr(address,0x40), pcVar2 == (char *)0x0 ||
        ((pcVar1 <= __s || (pcVar1 <= pcVar2)))))) {
      p = strrchr(address,0x40);
      if ((p == (char *)0x0) || (p <= address)) {
        p = address;
        while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x2000) != 0) {
          p = p + 1;
        }
        e = p;
        while ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*e] & 0x2000) == 0 && (*e != '\0'))) {
          e = e + 1;
        }
        *e = '\0';
        local_1c = p;
      }
      else {
        e = p + 1;
        do {
          p = p + -1;
          if (p <= address) break;
          ppuVar3 = __ctype_b_loc();
        } while (((*ppuVar3)[(byte)*p] & 0x2000) == 0);
        while ((*e != '\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*e] & 0x2000) == 0))) {
          e = e + 1;
        }
        *e = '\0';
        local_1c = HTStrip(p);
      }
    }
    else {
      *__s = '\0';
      local_1c = HTStrip(address);
    }
  }
  else {
    *pcVar1 = '\0';
    local_1c = HTStrip(__s + 1);
  }
  return local_1c;
}



void start_anchor(char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x19) {
    *(bool *)(present + i) = i == 6;
    i = i + 1;
  }
  value[6] = href;
  (*targetClass.start_element)(target,0,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void start_link(char *href,char *rev)

{
  int iVar1;
  int in_GS_OFFSET;
  BOOLEAN local_60;
  char *value [14];
  int i;
  BOOLEAN present [14];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0xe) {
    if ((i == 3) || (i == 9)) {
      local_60 = '\x01';
    }
    else {
      local_60 = '\0';
    }
    present[i] = local_60;
    i = i + 1;
  }
  value[3] = href;
  value[9] = rev;
  (*targetClass.start_element)(target,0x45,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void start_list(int seqnum)

{
  int iVar1;
  int in_GS_OFFSET;
  BOOLEAN local_68;
  char *value [12];
  int i;
  char SeqNum [20];
  BOOLEAN present [12];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0xc) {
    if ((i == 7) || (i == 8)) {
      local_68 = '\x01';
    }
    else {
      local_68 = '\0';
    }
    present[i] = local_68;
    i = i + 1;
  }
  sprintf(SeqNum,"%d",seqnum);
  value[7] = SeqNum;
  value[8] = SeqNum;
  (*targetClass.start_element)(target,0x50,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void write_anchor(char *text,char *addr)

{
  int iVar1;
  size_t sVar2;
  int in_GS_OFFSET;
  char *q;
  char *p;
  char href [513];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = addr;
  while ((((*p != '\0' && (*p != '>')) && (0x20 < (byte)*p)) && (*p != ','))) {
    p = p + 1;
  }
  sVar2 = strlen(NewsHREF);
  if (p + (sVar2 - (int)addr) + 1 < (char *)0x201) {
    q = href;
    strcpy(q,NewsHREF);
    strncat(q,addr,(size_t)(p + -(int)addr));
  }
  else {
    q = (char *)0x0;
    HTSprintf0(&q,"%s%.*s",NewsHREF,p + -(int)addr,addr);
  }
  start_anchor(q);
  (*targetClass.put_string)(target,text);
  (*targetClass.end_element)(target,0,(char **)0x0);
  if ((q != href) && (q != (char *)0x0)) {
    free(q);
    q = (char *)0x0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void write_anchors(char *text)

{
  char cVar1;
  char *end;
  char *start;
  char c;
  
  start = text;
  while( true ) {
    while ((*start != '\0' && ((byte)*start < 0x21))) {
      start = start + 1;
    }
    if (*start == '\0') break;
    end = start;
    while (((*end != '\0' && (*end != ' ')) && (*end != ','))) {
      end = end + 1;
    }
    if (*end != '\0') {
      end = end + 1;
    }
    cVar1 = *end;
    *end = '\0';
    if (*start == '<') {
      write_anchor(start,start + 1);
    }
    else {
      write_anchor(start,start);
    }
    (*targetClass.start_element)(target,0x14,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    *end = cVar1;
    start = end;
  }
  return;
}



void abort_socket(void)

{
  int iVar1;
  FILE *__stream;
  
  iVar1 = s;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTNews: EOF on read, closing socket %d\n",iVar1);
  }
  close(s);
  if (rawtext == '\0') {
    (*targetClass.put_string)(target,"Network Error: connection lost");
    (*targetClass.put_character)(target,'\n');
  }
  else {
    (*rawtargetClass.put_string)(rawtarget,"Network Error: connection lost\n");
  }
  s = -1;
  return;
}



BOOLEAN valid_header(char *line)

{
  char *pcVar1;
  char *pcVar2;
  ushort **ppuVar3;
  BOOLEAN local_15;
  char *space;
  char *colon;
  
  if ((*line == ' ') || (*line == '\t')) {
    local_15 = '\x01';
  }
  else {
    pcVar1 = strchr(line,0x3a);
    pcVar2 = strchr(line,0x20);
    ppuVar3 = __ctype_b_loc();
    if ((((*ppuVar3)[(byte)*line] & 0x400) == 0) ||
       ((pcVar1 == (char *)0x0 || (pcVar1 + 1 != pcVar2)))) {
      local_15 = '\0';
    }
    else {
      local_15 = '\x01';
    }
  }
  return local_15;
}



void post_article(char *postfile)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *__stream;
  size_t sVar6;
  char *Msg;
  int iVar7;
  int in_GS_OFFSET;
  undefined *local_458;
  size_t local_454;
  size_t __n;
  char *local_440;
  int llen;
  int blen;
  int seen_fromline;
  int seen_header;
  int in_header;
  FILE *fd;
  int status;
  char *cp;
  char crlf [3];
  char buf [512];
  char line [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  bVar2 = true;
  bVar3 = false;
  bVar4 = false;
  blen = 0;
  if (postfile == (char *)0x0) {
    local_440 = "";
  }
  else {
    local_440 = postfile;
  }
  __stream = fopen64(local_440,"r");
  if (__stream == (FILE *)0x0) {
    Msg = (char *)gettext("Cannot open temporary file for news POST.");
    HTAlert(Msg);
  }
  else {
    buf[0] = '\0';
    sprintf(crlf,"%c%c",0xd,10);
    while( true ) {
      Msg = fgets(line,0x1fe,__stream);
      if (Msg == (char *)0x0) break;
      Msg = strchr(line,10);
      if (Msg != (char *)0x0) {
        *Msg = '\0';
      }
      if (line[0] == '.') {
        local_454 = 2;
        local_458 = &DAT_0818ec97;
        sVar6 = strlen(buf);
        memcpy(buf + sVar6,local_458,local_454);
        blen = blen + 1;
      }
      sVar6 = strlen(line);
      if (bVar2) {
        iVar7 = strncasecomp(line,"From:",5);
        if (iVar7 == 0) {
          bVar3 = true;
          bVar4 = true;
        }
      }
      if ((bVar2) && (line[0] == '\0')) {
        if (bVar3) {
          bVar2 = false;
          if (!bVar4) {
            if (0x1dc < blen) {
              write(s,buf,blen);
              blen = 0;
              buf[0] = '\0';
            }
            __n = 0x21;
            Msg = "From: anonymous@nowhere.you.know";
            local_454 = strlen(buf);
            memcpy(buf + local_454,Msg,__n);
            strcat(buf,crlf);
            blen = blen + 0x22;
          }
          goto LAB_08135348;
        }
      }
      else {
        if (!bVar2) goto LAB_08135348;
        BVar5 = valid_header(line);
        if (BVar5 != '\0') {
          bVar3 = true;
LAB_08135348:
          strcat(line,crlf);
          if (0x1fe < (int)(blen + sVar6 + 2)) {
            write(s,buf,blen);
            blen = 0;
            buf[0] = '\0';
          }
          strcat(buf,line);
          blen = blen + sVar6 + 2;
        }
      }
    }
    fclose(__stream);
    remove(postfile);
    if (0x1fb < blen) {
      write(s,buf,blen);
      blen = 0;
      buf[0] = '\0';
    }
    strcat(buf,".");
    strcat(buf,crlf);
    write(s,buf,blen + 3);
    iVar7 = response((char *)0x0);
    if (iVar7 == 0xf0) {
      HTProgress(response_text);
    }
    else {
      HTAlert(response_text);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



char * decode_mime(char **str)

{
  char empty [1];
  int iVar1;
  char *local_8;
  
  HTmmdecode(str,*str);
  iVar1 = HTrjis(str,*str);
  if (iVar1 == 0) {
    local_8 = &ram0x081aa21c;
  }
  else {
    local_8 = *str;
  }
  return local_8;
}



int read_article(HTParentAnchor *thisanchor)

{
  char cVar1;
  char cVar2;
  bool bVar3;
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar4;
  BOOLEAN BVar5;
  size_t sVar6;
  char *__s;
  int iVar7;
  char *pcVar8;
  int iVar9;
  FILE *__stream;
  char *pcVar10;
  char *href_00;
  int in_GS_OFFSET;
  int local_28c;
  char *local_288;
  char *local_284;
  char *local_280;
  char *at;
  char *q;
  char *p2;
  char *l;
  int ich_1;
  char *cp1;
  char *temp;
  char *msgid;
  int i;
  int ich;
  char *ccp;
  char *cp;
  char *p;
  char *href;
  char *followupto;
  char *newsgroups;
  char *references;
  char *organization;
  char *date;
  char *replyto;
  char *from;
  char *subject;
  char *full_line;
  char c;
  BOOLEAN done;
  char line [513];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  full_line = (char *)0x0;
  subject = (char *)0x0;
  from = (char *)0x0;
  replyto = (char *)0x0;
  date = (char *)0x0;
  organization = (char *)0x0;
  references = (char *)0x0;
  newsgroups = (char *)0x0;
  followupto = (char *)0x0;
  href = (char *)0x0;
  bVar3 = false;
  if ((diagnostic == 0) && (__s = line, rawtext == '\0')) {
    while( true ) {
      p = __s;
      iVar9 = HTGetCharacter();
      iVar7 = s;
      *p = (char)iVar9;
      if (iVar9 == -1) break;
      if (((char)iVar9 == '\n') || (__s = p + 1, p + 1 == line + 0x200)) {
        *p = '\0';
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"H %s\n",line);
        }
        if ((line[0] == '\t') || (line[0] == ' ')) {
          i = 0;
          while (line[i] != '\0') {
            if (line[i] == '\t') {
              line[i] = ' ';
            }
            i = i + 1;
          }
          if (full_line == (char *)0x0) {
            HTSACopy(&full_line,line);
          }
          else {
            HTSACat(&full_line,line);
          }
        }
        else {
          HTSACopy(&full_line,line);
        }
        if (*full_line == '.') {
          if ((byte)full_line[1] < 0x20) {
            bVar3 = true;
LAB_08135b75:
            if (full_line != (char *)0x0) {
              free(full_line);
              full_line = (char *)0x0;
            }
            (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            (*targetClass.put_character)(target,'\n');
            (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            if ((subject == (char *)0x0) || (*subject == '\0')) {
              (*targetClass.put_string)(target,"No Subject");
            }
            else {
              (*targetClass.put_string)(target,subject);
            }
            (*targetClass.end_element)(target,0x6e,(char **)0x0);
            (*targetClass.put_character)(target,'\n');
            if ((from != (char *)0x0) || (replyto != (char *)0x0)) {
              temp = (char *)0x0;
              if (replyto == (char *)0x0) {
                local_288 = from;
              }
              else {
                local_288 = replyto;
              }
              __s = author_address(local_288);
              HTSACopy(&temp,__s);
              HTSACopy(&href,"mailto:");
              __s = strchr(temp,0x25);
              if ((__s == (char *)0x0) && (__s = strchr(temp,0x3f), __s == (char *)0x0)) {
                HTSACat(&href,temp);
              }
              else {
                __s = HTEscape(temp,'\x02');
                HTSACat(&href,__s);
                if (__s != (char *)0x0) {
                  free(__s);
                }
              }
              start_link(href,"made");
              (*targetClass.put_character)(target,'\n');
              if (temp != (char *)0x0) {
                free(temp);
                temp = (char *)0x0;
              }
            }
            (*targetClass.end_element)(target,0x35,(char **)0x0);
            (*targetClass.put_character)(target,'\n');
            (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            if ((subject == (char *)0x0) || (*subject == '\0')) {
              (*targetClass.put_string)(target,"No Subject");
            }
            else {
              (*targetClass.put_string)(target,subject);
            }
            (*targetClass.end_element)(target,0x2f,(char **)0x0);
            (*targetClass.put_character)(target,'\n');
            if ((subject != (char *)0x0) && (subject != (char *)0x0)) {
              free(subject);
              subject = (char *)0x0;
            }
            (*targetClass.start_element)(target,0x24,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            (*targetClass.put_character)(target,'\n');
            if ((from != (char *)0x0) || (replyto != (char *)0x0)) {
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"From:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,' ');
              if (from == (char *)0x0) {
                (*targetClass.put_string)(target,replyto);
              }
              else {
                (*targetClass.put_string)(target,from);
              }
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              if (replyto == (char *)0x0) {
                HTSACopy(&replyto,from);
              }
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"Reply to:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,' ');
              start_anchor(href);
              paVar4 = targetClass.put_string;
              if (*replyto == '<') {
                __s = author_address(replyto);
                (*paVar4)(target,__s);
              }
              else {
                __s = author_name(replyto);
                (*paVar4)(target,__s);
              }
              (*targetClass.end_element)(target,0,(char **)0x0);
              (*targetClass.start_element)(target,0x14,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              if (from != (char *)0x0) {
                free(from);
                from = (char *)0x0;
              }
              if (replyto != (char *)0x0) {
                free(replyto);
                replyto = (char *)0x0;
              }
            }
            if (date != (char *)0x0) {
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"Date:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,' ');
              (*targetClass.put_string)(target,date);
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              if (date != (char *)0x0) {
                free(date);
                date = (char *)0x0;
              }
            }
            if (organization != (char *)0x0) {
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"Organization:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,' ');
              (*targetClass.put_string)(target,organization);
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              if (organization != (char *)0x0) {
                free(organization);
                organization = (char *)0x0;
              }
            }
            if ((newsgroups != (char *)0x0) &&
               ((cp = strchr(newsgroups,0x2f), cp != (char *)0x0 ||
                (cp = strchr(newsgroups,0x28), cp != (char *)0x0)))) {
              *cp = '\0';
            }
            if (((newsgroups != (char *)0x0) && (*newsgroups == '\0')) &&
               (newsgroups != (char *)0x0)) {
              free(newsgroups);
              newsgroups = (char *)0x0;
            }
            if ((followupto != (char *)0x0) &&
               ((cp = strchr(followupto,0x2f), cp != (char *)0x0 ||
                (cp = strchr(followupto,0x28), cp != (char *)0x0)))) {
              *cp = '\0';
            }
            if (((followupto != (char *)0x0) && (*followupto == '\0')) &&
               (followupto != (char *)0x0)) {
              free(followupto);
              followupto = (char *)0x0;
            }
            if ((newsgroups != (char *)0x0) && (HTCanPost != 0)) {
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"Newsgroups:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,'\n');
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.start_element)(target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              write_anchors(newsgroups);
              if (tags[30].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x1e,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
            }
            if ((followupto != (char *)0x0) &&
               (iVar7 = strcasecomp(followupto,"poster"), iVar7 == 0)) {
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"Followup to:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,' ');
              if (href == (char *)0x0) {
                (*targetClass.put_string)(target,"poster");
              }
              else {
                start_anchor(href);
                (*targetClass.put_string)(target,"poster");
                (*targetClass.end_element)(target,0,(char **)0x0);
              }
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              if (followupto != (char *)0x0) {
                free(followupto);
                followupto = (char *)0x0;
              }
            }
            if ((newsgroups != (char *)0x0) && (HTCanPost != 0)) {
              iVar7 = strncasecomp(NewsHREF,"snews:",6);
              if (iVar7 == 0) {
                HTSACopy(&href,"snewsreply://");
              }
              else {
                HTSACopy(&href,"newsreply://");
              }
              HTSACat(&href,NewsHost);
              HTSACat(&href,"/");
              if (followupto == (char *)0x0) {
                local_284 = newsgroups;
              }
              else {
                local_284 = followupto;
              }
              HTSACat(&href,local_284);
              if (((*href == 'n') && (__s = HTAnchor_messageID(thisanchor), __s != (char *)0x0)) &&
                 (*__s != '\0')) {
                HTSACat(&href,";ref=");
                pcVar8 = strchr(__s,0x3c);
                if (((((pcVar8 == (char *)0x0) && (pcVar8 = strchr(__s,0x26), pcVar8 == (char *)0x0)
                      ) && ((pcVar8 = strchr(__s,0x20), pcVar8 == (char *)0x0 &&
                            ((pcVar8 = strchr(__s,0x3a), pcVar8 == (char *)0x0 &&
                             (pcVar8 = strchr(__s,0x2f), pcVar8 == (char *)0x0)))))) &&
                    (pcVar8 = strchr(__s,0x25), pcVar8 == (char *)0x0)) &&
                   (pcVar8 = strchr(__s,0x3b), pcVar8 == (char *)0x0)) {
                  HTSACat(&href,__s);
                }
                else {
                  __s = HTEscape(__s,'\x02');
                  HTSACat(&href,__s);
                  if (__s != (char *)0x0) {
                    free(__s);
                  }
                }
              }
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"Followup to:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              (*targetClass.put_character)(target,' ');
              start_anchor(href);
              if (followupto == (char *)0x0) {
                local_280 = newsgroups;
              }
              else {
                local_280 = followupto;
              }
              __s = strchr(local_280,0x2c);
              if (__s == (char *)0x0) {
                (*targetClass.put_string)(target,"newsgroup");
              }
              else {
                (*targetClass.put_string)(target,"newsgroups");
              }
              (*targetClass.end_element)(target,0,(char **)0x0);
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
            }
            if (newsgroups != (char *)0x0) {
              free(newsgroups);
              newsgroups = (char *)0x0;
            }
            if (followupto != (char *)0x0) {
              free(followupto);
              followupto = (char *)0x0;
            }
            if (references != (char *)0x0) {
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,"References:");
              (*targetClass.end_element)(target,8,(char **)0x0);
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              (*targetClass.start_element)(target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              write_anchors(references);
              if (tags[30].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x1e,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              if (references != (char *)0x0) {
                free(references);
                references = (char *)0x0;
              }
            }
            (*targetClass.end_element)(target,0x24,(char **)0x0);
            (*targetClass.put_character)(target,'\n');
            if (href != (char *)0x0) {
              free(href);
              href = (char *)0x0;
            }
            goto LAB_08137089;
          }
        }
        else {
          if ((byte)*full_line < 0x20) goto LAB_08135b75;
          BVar5 = match(full_line,"SUBJECT:");
          if (BVar5 == '\0') {
            BVar5 = match(full_line,"DATE:");
            if (BVar5 == '\0') {
              BVar5 = match(full_line,"ORGANIZATION:");
              if (BVar5 == '\0') {
                BVar5 = match(full_line,"FROM:");
                if (BVar5 == '\0') {
                  BVar5 = match(full_line,"REPLY-TO:");
                  if (BVar5 == '\0') {
                    BVar5 = match(full_line,"NEWSGROUPS:");
                    if (BVar5 == '\0') {
                      BVar5 = match(full_line,"REFERENCES:");
                      if (BVar5 == '\0') {
                        BVar5 = match(full_line,"FOLLOWUP-TO:");
                        if (BVar5 == '\0') {
                          BVar5 = match(full_line,"MESSAGE-ID:");
                          if (((BVar5 != '\0') && (__s = HTStrip(full_line + 0xb), *__s == '<')) &&
                             (sVar6 = strlen(__s), __s[sVar6 - 1] == '>')) {
                            sVar6 = strlen(__s);
                            __s[sVar6 - 1] = '\0';
                            HTAnchor_setMessageID(thisanchor,__s + 1);
                          }
                        }
                        else {
                          __s = strchr(full_line,0x3a);
                          __s = HTStrip(__s + 1);
                          HTSACopy(&followupto,__s);
                        }
                      }
                      else {
                        __s = strchr(full_line,0x3a);
                        __s = HTStrip(__s + 1);
                        HTSACopy(&references,__s);
                      }
                    }
                    else {
                      __s = strchr(full_line,0x3a);
                      __s = HTStrip(__s + 1);
                      HTSACopy(&newsgroups,__s);
                    }
                  }
                  else {
                    __s = strchr(full_line,0x3a);
                    __s = HTStrip(__s + 1);
                    HTSACopy(&replyto,__s);
                    decode_mime(&replyto);
                  }
                }
                else {
                  __s = strchr(full_line,0x3a);
                  __s = HTStrip(__s + 1);
                  HTSACopy(&from,__s);
                  decode_mime(&from);
                }
              }
              else {
                __s = strchr(full_line,0x3a);
                __s = HTStrip(__s + 1);
                HTSACopy(&organization,__s);
                decode_mime(&organization);
              }
            }
            else {
              __s = strchr(full_line,0x3a);
              __s = HTStrip(__s + 1);
              HTSACopy(&date,__s);
            }
          }
          else {
            __s = strchr(full_line,0x3a);
            __s = HTStrip(__s + 1);
            HTSACopy(&subject,__s);
            decode_mime(&subject);
          }
        }
        __s = line;
      }
    }
    if (interrupted_in_htgetcharacter == 0) {
      abort_socket();
      local_28c = 200;
    }
    else {
      interrupted_in_htgetcharacter = 0;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTNews: Interrupted on read, closing socket %d\n",iVar7);
      }
      close(s);
      s = -1;
      local_28c = -0x752e;
    }
  }
  else {
LAB_08137089:
    if (rawtext == '\0') {
      if (diagnostic == 0) {
        (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*targetClass.put_character)(target,'\n');
      }
      else {
        (*targetClass.start_element)(target,0x75,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*targetClass.put_character)(target,'\n');
      }
    }
    p = line;
    while (!bVar3) {
      iVar9 = HTGetCharacter();
      iVar7 = s;
      *p = (char)iVar9;
      p = p + 1;
      if (iVar9 == -1) {
        if (interrupted_in_htgetcharacter == 0) {
          abort_socket();
          local_28c = 200;
        }
        else {
          interrupted_in_htgetcharacter = 0;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTNews: Interrupted on read, closing socket %d\n",iVar7);
          }
          close(s);
          s = -1;
          local_28c = -0x752e;
        }
        goto LAB_08137be0;
      }
      if (((char)iVar9 == '\n') || (p == line + 0x200)) {
        *p = '\0';
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"B %s",line);
        }
        if (line[0] == '.') {
          if ((byte)line[1] < 0x20) break;
          if (rawtext == '\0') {
            (*targetClass.put_string)(target,line + 1);
          }
          else {
            (*rawtargetClass.put_string)(rawtarget,line + 1);
          }
        }
        else {
          if (rawtext == '\0') {
            if ((diagnostic == 0) && (scan_for_buried_news_references != '\0')) {
              l = line;
              while (__s = strstr(l,"rticle <"), __s != (char *)0x0) {
                pcVar8 = strrchr(__s,0x3e);
                pcVar10 = strrchr(__s,0x40);
                if (((pcVar8 == (char *)0x0) || (pcVar10 == (char *)0x0)) || (pcVar8 <= pcVar10))
                break;
                cVar2 = pcVar8[1];
                pcVar8[1] = '\0';
                pcVar10 = __s + 7;
                *pcVar10 = '\0';
                while (*l != '\0') {
                  iVar7 = strncmp(l,"news:",5);
                  if ((((iVar7 == 0) || (iVar7 = strncmp(l,"snews://",8), iVar7 == 0)) ||
                      ((iVar7 = strncmp(l,"nntp://",7), iVar7 == 0 ||
                       ((iVar7 = strncmp(l,"snewspost:",10), iVar7 == 0 ||
                        (iVar7 = strncmp(l,"snewsreply:",0xb), iVar7 == 0)))))) ||
                     ((iVar7 = strncmp(l,"newspost:",9), iVar7 == 0 ||
                      (((((((iVar7 = strncmp(l,"newsreply:",10), iVar7 == 0 ||
                            (iVar7 = strncmp(l,"ftp://",6), iVar7 == 0)) ||
                           (iVar7 = strncmp(l,"file:/",6), iVar7 == 0)) ||
                          ((iVar7 = strncmp(l,"finger://",9), iVar7 == 0 ||
                           (iVar7 = strncmp(l,"http://",7), iVar7 == 0)))) ||
                         (iVar7 = strncmp(l,"https://",8), iVar7 == 0)) ||
                        ((iVar7 = strncmp(l,"wais://",7), iVar7 == 0 ||
                         (iVar7 = strncmp(l,"mailto:",7), iVar7 == 0)))) ||
                       ((iVar7 = strncmp(l,"cso://",6), iVar7 == 0 ||
                        (iVar7 = strncmp(l,"gopher://",9), iVar7 == 0)))))))) {
                    HTSACopy(&href,l);
                    href_00 = strtok(href," \r\n\t,>)\"");
                    start_anchor(href_00);
                    while ((*l != '\0' &&
                           (href_00 = strchr(" \r\n\t,>)\"",(int)*l), href_00 == (char *)0x0))) {
                      cVar1 = *l;
                      l = l + 1;
                      (*targetClass.put_character)(target,cVar1);
                    }
                    (*targetClass.end_element)(target,0,(char **)0x0);
                    if (href != (char *)0x0) {
                      free(href);
                      href = (char *)0x0;
                    }
                  }
                  else {
                    cVar1 = *l;
                    l = l + 1;
                    (*targetClass.put_character)(target,cVar1);
                  }
                }
                *pcVar10 = '<';
                *pcVar8 = '\0';
                start_anchor(__s + 8);
                *pcVar8 = '>';
                (*targetClass.put_string)(target,pcVar10);
                (*targetClass.end_element)(target,0,(char **)0x0);
                pcVar8[1] = cVar2;
                l = pcVar8 + 1;
              }
              while (*l != '\0') {
                iVar7 = strncmp(l,"news:",5);
                if ((((((iVar7 == 0) || (iVar7 = strncmp(l,"snews://",8), iVar7 == 0)) ||
                      (iVar7 = strncmp(l,"nntp://",7), iVar7 == 0)) ||
                     (((iVar7 = strncmp(l,"snewspost:",10), iVar7 == 0 ||
                       (iVar7 = strncmp(l,"snewsreply:",0xb), iVar7 == 0)) ||
                      ((iVar7 = strncmp(l,"newspost:",9), iVar7 == 0 ||
                       ((iVar7 = strncmp(l,"newsreply:",10), iVar7 == 0 ||
                        (iVar7 = strncmp(l,"ftp://",6), iVar7 == 0)))))))) ||
                    ((iVar7 = strncmp(l,"file:/",6), iVar7 == 0 ||
                     (((iVar7 = strncmp(l,"finger://",9), iVar7 == 0 ||
                       (iVar7 = strncmp(l,"http://",7), iVar7 == 0)) ||
                      (iVar7 = strncmp(l,"https://",8), iVar7 == 0)))))) ||
                   (((iVar7 = strncmp(l,"wais://",7), iVar7 == 0 ||
                     (iVar7 = strncmp(l,"mailto:",7), iVar7 == 0)) ||
                    ((iVar7 = strncmp(l,"cso://",6), iVar7 == 0 ||
                     (iVar7 = strncmp(l,"gopher://",9), iVar7 == 0)))))) {
                  HTSACopy(&href,l);
                  __s = strtok(href," \r\n\t,>)\"");
                  start_anchor(__s);
                  while ((*l != '\0' && (__s = strchr(" \r\n\t,>)\"",(int)*l), __s == (char *)0x0)))
                  {
                    cVar2 = *l;
                    l = l + 1;
                    (*targetClass.put_character)(target,cVar2);
                  }
                  (*targetClass.end_element)(target,0,(char **)0x0);
                  if (href != (char *)0x0) {
                    free(href);
                    href = (char *)0x0;
                  }
                }
                else {
                  cVar2 = *l;
                  l = l + 1;
                  (*targetClass.put_character)(target,cVar2);
                }
              }
            }
            else {
              (*targetClass.put_string)(target,line);
            }
          }
          else {
            (*rawtargetClass.put_string)(rawtarget,line);
          }
        }
        p = line;
      }
    }
    if (rawtext == '\0') {
      if (diagnostic == 0) {
        (*targetClass.end_element)(target,0x56,(char **)0x0);
      }
      else {
        (*targetClass.end_element)(target,0x75,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      local_28c = 200;
    }
    else {
      local_28c = 200;
    }
  }
LAB_08137be0:
  if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_28c;
}



int read_list(char *arg)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  size_t sVar5;
  int iVar6;
  FILE *__stream;
  char *fmt;
  int iVar7;
  int in_GS_OFFSET;
  int local_240;
  char *msg;
  int i;
  int ich;
  int len;
  char *pattern;
  int listing;
  char *p;
  char ch;
  BOOLEAN skip_rest_of_line;
  BOOLEAN skip_this_line;
  BOOLEAN tail;
  BOOLEAN head;
  BOOLEAN done;
  char line [513];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  bVar2 = false;
  bVar1 = false;
  bVar3 = false;
  bVar4 = false;
  listing = 0;
  pattern = (char *)0x0;
  len = 0;
  if ((arg != (char *)0x0) && (sVar5 = strlen(arg), 1 < sVar5)) {
    if (*arg == '*') {
      bVar1 = true;
      HTSACopy(&pattern,arg + 1);
    }
    else {
      sVar5 = strlen(arg);
      if (arg[sVar5 - 1] == '*') {
        bVar2 = true;
        HTSACopy(&pattern,arg);
        fmt = pattern;
        sVar5 = strlen(pattern);
        fmt[sVar5 - 1] = '\0';
      }
    }
    if ((bVar1) || (bVar2)) {
      len = strlen(pattern);
    }
  }
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_string)(target,"Newsgroups");
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_string)(target,"Newsgroups");
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  p = line;
  (*targetClass.start_element)(target,0x24,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
LAB_0813859b:
  do {
    iVar6 = HTGetCharacter();
    iVar7 = s;
    ch = (char)iVar6;
    if (iVar6 == -1) {
      if (interrupted_in_htgetcharacter == 0) {
        abort_socket();
        if (pattern != (char *)0x0) {
          free(pattern);
          pattern = (char *)0x0;
        }
        local_240 = 200;
      }
      else {
        interrupted_in_htgetcharacter = 0;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTNews: Interrupted on read, closing socket %d\n",iVar7);
        }
        close(s);
        s = -1;
        local_240 = -0x752e;
      }
LAB_081386f3:
      if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return local_240;
    }
    if (bVar3) {
      if (ch == 10) {
        bVar4 = false;
        bVar3 = false;
        p = line;
      }
      goto LAB_0813859b;
    }
    if (bVar4) {
      if (ch == 10) {
LAB_0813814f:
        if (ch == '\n') {
          bVar4 = false;
          *p = '\0';
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"B %s",line);
          }
          if (line[0] == '.') {
            if ((byte)line[1] < 0x20) {
              if (listing == 0) {
                msg = (char *)0x0;
                (*targetClass.start_element)
                          (target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
                fmt = (char *)gettext("No matches for: %s");
                HTSprintf0(&msg,fmt,arg);
                (*targetClass.put_string)(target,msg);
                if (tags[37].contents != SGML_EMPTY) {
                  (*targetClass.end_element)(target,0x25,(char **)0x0);
                }
                if (msg != (char *)0x0) {
                  free(msg);
                  msg = (char *)0x0;
                }
              }
              (*targetClass.end_element)(target,0x24,(char **)0x0);
              (*targetClass.put_character)(target,'\n');
              if (pattern != (char *)0x0) {
                free(pattern);
                pattern = (char *)0x0;
              }
              local_240 = 200;
              goto LAB_081386f3;
            }
            (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            (*targetClass.put_string)(target,line + 1);
            if (tags[37].contents != SGML_EMPTY) {
              (*targetClass.end_element)(target,0x25,(char **)0x0);
            }
          }
          else {
            if (line[0] == '#') {
              p = line;
              goto LAB_0813859b;
            }
            i = 0;
            while ((line[i] != '\0' && (0x20 < (byte)line[i]))) {
              i = i + 1;
            }
            if (line[i] == '\0') {
              if (((bVar2) && (iVar7 = strncasecomp(line,pattern,len), iVar7 != 0)) ||
                 ((bVar1 && ((i < len || (iVar7 = strcasecomp(line + (i - len),pattern), iVar7 != 0)
                             ))))) {
                p = line;
                goto LAB_0813859b;
              }
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              write_anchor(line,line);
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              listing = listing + 1;
            }
            else {
              line[i] = '\0';
              if (((bVar2) && (iVar7 = strncasecomp(line,pattern,len), iVar7 != 0)) ||
                 ((bVar1 && ((i < len || (iVar7 = strcasecomp(line + (i - len),pattern), iVar7 != 0)
                             ))))) {
                p = line;
                goto LAB_0813859b;
              }
              (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              write_anchor(line,line);
              listing = listing + 1;
              if (tags[37].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x25,(char **)0x0);
              }
              (*targetClass.put_character)(target,'\n');
              (*targetClass.start_element)(target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
              (*targetClass.put_string)(target,line + i + 1);
              if (tags[30].contents != SGML_EMPTY) {
                (*targetClass.end_element)(target,0x1e,(char **)0x0);
              }
            }
          }
          p = line;
        }
      }
      goto LAB_0813859b;
    }
    if (p != line + 0x200) {
      *p = ch;
      p = p + 1;
      goto LAB_0813814f;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"b %.*s%c[...]\n",0x200,line,(int)ch);
    }
    *p = '\0';
    if (ch == 10) goto LAB_0813814f;
    if ((byte)ch < 0x21) {
      ch = '\n';
      bVar3 = true;
      goto LAB_0813814f;
    }
    fmt = strchr(line,0x20);
    if ((fmt != (char *)0x0) || (fmt = strchr(line,9), fmt != (char *)0x0)) {
      bVar4 = true;
      goto LAB_0813814f;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTNews..... group name too long, discarding.\n");
    }
    bVar3 = true;
  } while( true );
}



int read_group(char *groupName,int first_required,int last_required)

{
  bool bVar1;
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar2;
  BOOLEAN BVar3;
  FILE *__stream;
  int iVar4;
  char *__s;
  size_t sVar5;
  char *fmt;
  int iVar6;
  int in_GS_OFFSET;
  int *local_48c;
  int *piVar7;
  int *local_488;
  int *piVar8;
  int local_46c;
  char *local_468;
  char *href;
  int after;
  char *p2;
  char *addr;
  int ich;
  int before;
  int last;
  int first;
  int count;
  int status;
  int art;
  char *reference;
  char *temp;
  char *p;
  int i;
  char *date;
  char *subject;
  char *author;
  BOOLEAN done;
  char buffer [513];
  char line [513];
  int local_14;
  
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  author = (char *)0x0;
  subject = (char *)0x0;
  date = (char *)0x0;
  temp = (char *)0x0;
  reference = (char *)0x0;
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_string)(target,"Newsgroup ");
  (*targetClass.put_string)(target,groupName);
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  local_488 = &last;
  local_48c = &first;
  sscanf(response_text," %d %d %d %d",&status,&count,local_48c,local_488);
  iVar6 = status;
  piVar7 = (int *)first;
  piVar8 = (int *)last;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",iVar6,count
            ,piVar7,piVar8,first_required,last_required);
    local_48c = piVar7;
    local_488 = piVar8;
  }
  paVar2 = targetClass.put_string;
  if (last == 0) {
    fmt = (char *)gettext("\nNo articles in this group.\n");
    (*paVar2)(target,fmt);
  }
  else {
    if (first_required < first) {
      first_required = first;
    }
    if ((last_required == 0) || (last < last_required)) {
      last_required = last;
    }
    if (last_required < first_required) {
      fmt = (char *)gettext("\nNo articles in this range.\n");
      (*paVar2)(target,fmt);
    }
    else {
      if (HTNewsMaxChunk < (last_required - first_required) + 1) {
        first_required = (last_required - HTNewsChunkSize) + 1;
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"    Chunk will be (%d-%d)\n",first_required,last_required,
                local_48c,local_488);
      }
      fmt = (char *)gettext("%s,  Articles %d-%d");
      HTSprintf0(&temp,fmt,groupName,first_required,last_required);
      (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,temp);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      (*targetClass.end_element)(target,0x2f,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      if (first < first_required) {
        if (first < first_required - HTNewsMaxChunk) {
          before = first_required - HTNewsChunkSize;
        }
        else {
          before = first;
        }
        HTSprintf0(&dbuf,"%s%s/%d-%d",NewsHREF,groupName,before,first_required + -1);
        fmt = dbuf;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"    Block before is %s\n",fmt);
        }
        (*targetClass.put_character)(target,'(');
        start_anchor(dbuf);
        paVar2 = targetClass.put_string;
        fmt = (char *)gettext("Earlier articles");
        (*paVar2)(target,fmt);
        (*targetClass.end_element)(target,0,(char **)0x0);
        (*targetClass.put_string)(target,"...)\n");
        (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*targetClass.put_character)(target,'\n');
      }
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      paVar2 = targetClass.put_string;
      if ((first == first_required) && (last == last_required)) {
        fmt = (char *)gettext("All available articles in ");
        (*paVar2)(target,fmt);
      }
      else {
        (*targetClass.put_string)(target,"Articles in ");
      }
      (*targetClass.put_string)(target,groupName);
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      if (LYListNewsNumbers == '\0') {
        (*targetClass.start_element)(target,0x72,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      }
      else {
        start_list(first_required);
      }
      art = first_required;
      while (art <= last_required) {
        sprintf(buffer,"HEAD %d%c%c",art,0xd,10);
        status = response(buffer);
        iVar6 = s;
        if (status == 0xdd) {
          bVar1 = false;
          fmt = line;
          while (p = fmt, !bVar1) {
            iVar4 = HTGetCharacter();
            iVar6 = s;
            *p = (char)iVar4;
            if (iVar4 == -1) {
              if (interrupted_in_htgetcharacter == 0) {
                abort_socket();
                local_46c = 200;
              }
              else {
                interrupted_in_htgetcharacter = 0;
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"HTNews: Interrupted on read, closing socket %d\n",iVar6)
                  ;
                }
                close(s);
                s = -1;
                local_46c = -0x752e;
              }
              goto LAB_08139a0a;
            }
            if (((char)iVar4 == '\n') || (fmt = p + 1, p + 1 == line + 0x200)) {
              *p = '\0';
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"G %s\n",line);
              }
              fmt = line;
              switch(line[0]) {
              case '.':
                bVar1 = (byte)line[1] < 0x20;
                break;
              case 'D':
              case 'd':
                if ((LYListNewsDates != '\0') && (BVar3 = match(line,"DATE:"), BVar3 != '\0')) {
                  __s = strchr(line,0x3a);
                  __s = HTStrip(__s + 1);
                  HTSACopy(&date,__s);
                }
                break;
              case 'F':
              case 'f':
                BVar3 = match(line,"FROM:");
                if (BVar3 != '\0') {
                  __s = strchr(line,0x3a);
                  HTSACopy(&author,__s + 1);
                  decode_mime(&author);
                  __s = author;
                  sVar5 = strlen(author);
                  if (__s[sVar5 - 1] == '\n') {
                    __s[sVar5 - 1] = '\0';
                  }
                }
                break;
              case 'M':
              case 'm':
                BVar3 = match(line,"MESSAGE-ID:");
                if (BVar3 != '\0') {
                  __s = HTStrip(line + 0xb);
                  __s = __s + 1;
                  sVar5 = strlen(__s);
                  __s[sVar5 - 1] = '\0';
                  HTSACopy(&reference,__s);
                }
                break;
              case 'S':
              case 's':
                BVar3 = match(line,"SUBJECT:");
                if (BVar3 != '\0') {
                  HTSACopy(&subject,line + 9);
                  decode_mime(&subject);
                }
              }
            }
          }
          (*targetClass.put_character)(target,'\n');
          (*targetClass.start_element)(target,0x44,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          local_468 = decode_mime(&subject);
          if (local_468 == (char *)0x0) {
            local_468 = "";
          }
          HTSprintf0(&temp,"\"%s\"",local_468);
          if (reference == (char *)0x0) {
            (*targetClass.put_string)(target,temp);
          }
          else {
            write_anchor(temp,reference);
            if (reference != (char *)0x0) {
              free(reference);
              reference = (char *)0x0;
            }
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          if (author != (char *)0x0) {
            (*targetClass.put_string)(target," - ");
            if (LYListNewsDates != '\0') {
              (*targetClass.start_element)(target,0x39,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            }
            paVar2 = targetClass.put_string;
            fmt = decode_mime(&author);
            (*paVar2)(target,fmt);
            if (LYListNewsDates != '\0') {
              (*targetClass.end_element)(target,0x39,(char **)0x0);
            }
            if (author != (char *)0x0) {
              free(author);
              author = (char *)0x0;
            }
          }
          if (date != (char *)0x0) {
            if (diagnostic == 0) {
              i = 0;
              while (date[i] != '\0') {
                if (date[i] == ' ') {
                  date[i] = '\x01';
                }
                i = i + 1;
              }
            }
            sprintf(buffer," [%.*s]",0x1fd,date);
            (*targetClass.put_string)(target,buffer);
            if (date != (char *)0x0) {
              free(date);
              date = (char *)0x0;
            }
          }
          if (tags[68].contents != SGML_EMPTY) {
            (*targetClass.end_element)(target,0x44,(char **)0x0);
          }
        }
        else {
          if (status == -0x752e) {
            interrupted_in_htgetcharacter = 0;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTNews: Interrupted on read, closing socket %d\n",iVar6);
            }
            close(s);
            s = -1;
            local_46c = -0x752e;
            goto LAB_08139a0a;
          }
          (*targetClass.put_character)(target,'\n');
          (*targetClass.start_element)(target,0x44,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          (*targetClass.start_element)(target,0x39,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          if (LYListNewsNumbers == '\0') {
            sprintf(buffer,"Status (ARTICLE %d):",art);
          }
          else {
            LYstrncpy(buffer,"Status:",0x200);
          }
          (*targetClass.put_string)(target,buffer);
          (*targetClass.end_element)(target,0x39,(char **)0x0);
          (*targetClass.put_character)(target,' ');
          (*targetClass.put_string)(target,response_text);
          if (tags[68].contents != SGML_EMPTY) {
            (*targetClass.end_element)(target,0x44,(char **)0x0);
          }
        }
        art = art + 1;
      }
      if (author != (char *)0x0) {
        free(author);
        author = (char *)0x0;
      }
      if (subject != (char *)0x0) {
        free(subject);
        subject = (char *)0x0;
      }
      (*targetClass.put_character)(target,'\n');
      if (LYListNewsNumbers == '\0') {
        (*targetClass.end_element)(target,0x72,(char **)0x0);
      }
      else {
        (*targetClass.end_element)(target,0x50,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (last_required < last) {
        if (HTNewsChunkSize + last_required == last) {
          HTSprintf0(&dbuf,"%s%s",NewsHREF,groupName);
        }
        else {
          HTSprintf0(&dbuf,"%s%s/%d-%d",NewsHREF,groupName,last_required + 1,
                     HTNewsChunkSize + last_required);
        }
        fmt = dbuf;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"    Block after is %s\n",fmt);
        }
        (*targetClass.put_character)(target,'(');
        start_anchor(dbuf);
        paVar2 = targetClass.put_string;
        fmt = (char *)gettext("Later articles");
        (*paVar2)(target,fmt);
        (*targetClass.end_element)(target,0,(char **)0x0);
        (*targetClass.put_string)(target,"...)\n");
      }
    }
  }
  if (HTCanPost == 0) {
    (*targetClass.start_element)(target,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  }
  else {
    href = (char *)0x0;
    (*targetClass.start_element)(target,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    iVar6 = strncasecomp(NewsHREF,"snews:",6);
    if (iVar6 == 0) {
      HTSACopy(&href,"snewspost://");
    }
    else {
      HTSACopy(&href,"newspost://");
    }
    HTSACat(&href,NewsHost);
    HTSACat(&href,"/");
    HTSACat(&href,groupName);
    start_anchor(href);
    paVar2 = targetClass.put_string;
    fmt = (char *)gettext("Post to ");
    (*paVar2)(target,fmt);
    (*targetClass.put_string)(target,groupName);
    (*targetClass.end_element)(target,0,(char **)0x0);
    if (href != (char *)0x0) {
      free(href);
      href = (char *)0x0;
    }
  }
  (*targetClass.put_character)(target,'\n');
  local_46c = 200;
LAB_08139a0a:
  if (local_14 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_46c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int HTLoadNews(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *stream)

{
  HTStreamClass *pHVar1;
  HTStructuredClass *pHVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  HTAtom *rep_in;
  FILE *__stream;
  int iVar9;
  char *b;
  size_t __n;
  ushort **ppuVar10;
  uint uVar11;
  char *fmt;
  uint uVar12;
  ssize_t sVar13;
  int iVar14;
  NNTPAuthResult NVar15;
  int in_GS_OFFSET;
  int local_4c8;
  int local_4c4;
  char *local_4a0;
  char *local_49c;
  char *local_498;
  undefined *local_494;
  undefined *local_48c;
  BOOLEAN local_488;
  BOOLEAN local_484;
  char *local_47c;
  NNTPAuthResult auth_result_1;
  NNTPAuthResult auth_result;
  char *p;
  int add_close;
  int add_open;
  char *slash;
  char *p1;
  char *postfile;
  char *ProxyHREF;
  char *ProxyHost;
  char *ListArg;
  char *cp;
  int last;
  int first;
  int retries;
  int status;
  BOOLEAN head_wanted;
  BOOLEAN sreply_wanted;
  BOOLEAN spost_wanted;
  BOOLEAN reply_wanted;
  BOOLEAN post_wanted;
  BOOLEAN list_wanted;
  BOOLEAN group_wanted;
  BOOLEAN normal_url;
  char command [262];
  char url [260];
  char proxycmd [260];
  char groupName [256];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  head_wanted = '\0';
  cp = (char *)0x0;
  ListArg = (char *)0x0;
  ProxyHost = (char *)0x0;
  ProxyHREF = (char *)0x0;
  postfile = (char *)0x0;
  if (((format_out == (HTFormat)WWW_SOURCE) ||
      (rep_in = HTAtom_for("www/download"), rep_in == (HTAtom *)format_out)) ||
     (rep_in = HTAtom_for("www/dump"), rep_in == (HTAtom *)format_out)) {
    local_4c8 = 1;
  }
  else {
    local_4c8 = 0;
  }
  diagnostic = local_4c8;
  rawtext = '\0';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTNews: Looking for %s\n",arg);
  }
  if (initialized == '\0') {
    initialized = initialize();
  }
  if (initialized == '\0') {
    local_4c4 = -1;
  }
  else {
    if (NewsHREF != (char *)0x0) {
      free(NewsHREF);
      NewsHREF = (char *)0x0;
    }
    command[0] = '\0';
    command[261] = '\0';
    proxycmd[0] = '\0';
    proxycmd[259] = '\0';
    iVar9 = strncmp(arg,"news:",5);
    if ((iVar9 == 0) || (iVar9 = strncmp(arg,"nntp:",5), iVar9 == 0)) {
      bVar3 = true;
    }
    else {
      bVar3 = false;
    }
    if ((bVar3) || (b = strstr(arg,"snewspost:"), b == (char *)0x0)) {
      bVar4 = false;
    }
    else {
      bVar4 = true;
    }
    if (((bVar3) || (bVar4)) || (b = strstr(arg,"snewsreply:"), b == (char *)0x0)) {
      bVar5 = false;
    }
    else {
      bVar5 = true;
    }
    if (((bVar3) || (bVar4)) || ((bVar5 || (b = strstr(arg,"newspost:"), b == (char *)0x0)))) {
      bVar6 = false;
    }
    else {
      bVar6 = true;
    }
    if (((bVar3) || (bVar4)) ||
       ((bVar5 || ((bVar6 || (b = strstr(arg,"newsreply:"), b == (char *)0x0)))))) {
      bVar3 = false;
    }
    else {
      bVar3 = true;
    }
    if (((((bVar4) || (bVar5)) || (bVar6)) || ((bVar3 || (b = strchr(arg,0x40), b != (char *)0x0))))
       || (b = strchr(arg,0x2a), b != (char *)0x0)) {
      bVar7 = false;
    }
    else {
      bVar7 = true;
    }
    if ((((bVar4) || (bVar5)) ||
        ((bVar6 || (((bVar3 || (bVar7)) || (b = strchr(arg,0x40), b != (char *)0x0)))))) ||
       (b = strchr(arg,0x2a), b == (char *)0x0)) {
      bVar8 = false;
    }
    else {
      bVar8 = true;
    }
    iVar9 = strncasecomp(arg,"snewspost:",10);
    if ((iVar9 == 0) || (iVar9 = strncasecomp(arg,"snewsreply:",0xb), iVar9 == 0)) {
      b = (char *)gettext("This client does not contain support for posting to news with SSL.");
      HTAlert(b);
      local_4c4 = -29999;
    }
    else {
      if (((bVar6) || ((bVar3 || (bVar4)))) || (bVar5)) {
        p1 = strrchr(arg,0x2f);
        if (p1 == (char *)0x0) {
          p1 = strrchr(arg,0x3a);
          if (p1 != (char *)0x0) {
            p1 = p1 + 1;
          }
        }
        else {
          p1 = p1 + 1;
        }
        if ((p1 == (char *)0x0) || (*p1 == '\0')) {
          b = (char *)gettext("Illegal URL: %s");
          HTAlert(b);
          local_4c4 = -0xcc;
          goto LAB_0813c941;
        }
        b = HTParse(arg,"",8);
        if ((b == (char *)0x0) || (*b == '\0')) {
          if ((-1 < s) &&
             ((NewsHost != (char *)0x0 && (iVar9 = strcasecomp(NewsHost,HTNewsHost), iVar9 != 0))))
          {
            close(s);
            s = -1;
          }
          HTSACopy(&NewsHost,HTNewsHost);
        }
        else {
          if (((-1 < s) && (NewsHost != (char *)0x0)) &&
             (iVar9 = strcasecomp(NewsHost,b), iVar9 != 0)) {
            close(s);
            s = -1;
          }
          HTSACopy(&NewsHost,b);
        }
        if (b != (char *)0x0) {
          free(b);
        }
        if (bVar6) {
          local_4a0 = "newspost";
        }
        else {
          if (bVar3) {
            local_49c = "newreply";
          }
          else {
            if (bVar4) {
              local_498 = "snewspost";
            }
            else {
              local_498 = "snewsreply";
            }
            local_49c = local_498;
          }
          local_4a0 = local_49c;
        }
        HTSprintf0(&NewsHREF,"%s://%.*s/",local_4a0,0xf7,NewsHost);
        if ((bVar4) && (iVar9 = strncasecomp(arg,"snewspost:",10), iVar9 != 0)) {
          p1 = strstr(arg,"snewspost:");
        }
        if ((bVar5) && (iVar9 = strncasecomp(arg,"snewsreply:",0xb), iVar9 != 0)) {
          p1 = strstr(arg,"snewsreply:");
        }
      }
      else {
        iVar9 = strncasecomp(arg,"nntp:",5);
        if (iVar9 == 0) {
          if ((((arg[5] == '\0') || (iVar9 = strcmp(arg + 5,"/"), iVar9 == 0)) ||
              ((iVar9 = strcmp(arg + 5,"//"), iVar9 == 0 ||
               (iVar9 = strcmp(arg + 5,"///"), iVar9 == 0)))) ||
             ((iVar9 = strncmp(arg + 5,"//",2), iVar9 == 0 &&
              ((cp = strchr(arg + 7,0x2f), cp == (char *)0x0 || (cp[1] == '\0')))))) {
            p1 = "*";
            bVar7 = false;
            bVar8 = true;
          }
          else {
            if (arg[5] == '/') {
              if ((arg[5] == '/') && (arg[6] != '/')) {
                p1 = arg + 6;
              }
              else {
                p1 = cp + 1;
              }
            }
            else {
              p1 = arg + 5;
            }
          }
          b = HTParse(arg,"",8);
          if ((b == (char *)0x0) || (*b == '\0')) {
            if ((-1 < s) &&
               ((NewsHost != (char *)0x0 && (iVar9 = strcasecomp(NewsHost,HTNewsHost), iVar9 != 0)))
               ) {
              close(s);
              s = -1;
            }
            HTSACopy(&NewsHost,HTNewsHost);
          }
          else {
            if (((-1 < s) && (NewsHost != (char *)0x0)) &&
               (iVar9 = strcasecomp(NewsHost,b), iVar9 != 0)) {
              close(s);
              s = -1;
            }
            HTSACopy(&NewsHost,b);
          }
          if (b != (char *)0x0) {
            free(b);
          }
          sprintf(command,"%s//%.*s/","nntp:",0xfd,NewsHost);
          HTSACopy(&NewsHREF,command);
        }
        else {
          iVar9 = strncasecomp(arg,"snews:",6);
          if (iVar9 == 0) {
            b = (char *)gettext("This client does not contain support for SNEWS URLs.");
            HTAlert(b);
            local_4c4 = -29999;
            goto LAB_0813c941;
          }
          iVar9 = strncasecomp(arg,"news:/",6);
          if (iVar9 == 0) {
            if ((((arg[6] == '\0') || (iVar9 = strcmp(arg + 6,"/"), iVar9 == 0)) ||
                (iVar9 = strcmp(arg + 6,"//"), iVar9 == 0)) ||
               ((arg[6] == '/' &&
                ((cp = strchr(arg + 7,0x2f), cp == (char *)0x0 || (cp[1] == '\0')))))) {
              p1 = "*";
              bVar7 = false;
              bVar8 = true;
            }
            else {
              if (arg[6] == '/') {
                p1 = cp + 1;
              }
              else {
                p1 = arg + 6;
              }
            }
            b = HTParse(arg,"",8);
            if ((b == (char *)0x0) || (*b == '\0')) {
              if ((-1 < s) &&
                 ((NewsHost != (char *)0x0 && (iVar9 = strcasecomp(NewsHost,HTNewsHost), iVar9 != 0)
                  ))) {
                close(s);
                s = -1;
              }
              HTSACopy(&NewsHost,HTNewsHost);
            }
            else {
              if (((-1 < s) && (NewsHost != (char *)0x0)) &&
                 (iVar9 = strcasecomp(NewsHost,b), iVar9 != 0)) {
                close(s);
                s = -1;
              }
              HTSACopy(&NewsHost,b);
            }
            if (b != (char *)0x0) {
              free(b);
            }
            sprintf(command,"news://%.*s/",0xfd,NewsHost);
            HTSACopy(&NewsHREF,command);
          }
          else {
            p1 = arg + 5;
            if (*p1 == '\0') {
              p1 = "*";
              bVar7 = false;
              bVar8 = true;
            }
            if (((-1 < s) && (NewsHost != (char *)0x0)) &&
               (iVar9 = strcasecomp(NewsHost,HTNewsHost), iVar9 != 0)) {
              close(s);
              s = -1;
            }
            HTSACopy(&NewsHost,HTNewsHost);
            HTSACopy(&NewsHREF,"news:");
          }
        }
      }
      iVar9 = strncasecomp(p1,"snews:",6);
      if (((iVar9 == 0) || (iVar9 = strncasecomp(p1,"snewspost:",10), iVar9 == 0)) ||
         (iVar9 = strncasecomp(p1,"snewsreply:",0xb), iVar9 == 0)) {
        HTSACopy(&ProxyHost,NewsHost);
        b = HTParse(p1,"",8);
        if ((b == (char *)0x0) || (*b == '\0')) {
          sprintf(command,"%s//%.*s","snews:",0xfc,NewsHost);
        }
        else {
          sprintf(command,"%s//%.*s","snews:",0xfc,b);
          HTSACopy(&NewsHost,b);
        }
        command[260] = '\0';
        if (b != (char *)0x0) {
          free(b);
        }
        sprintf(proxycmd,"GET %.*s%c%c%c%c",0xfb,command,0xd,10,0xd,10);
        if (WWW_TraceFlag != '\0') {
          __n = strlen(proxycmd);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTNews: Proxy command is \'%.*s\'\n",__n - 4,proxycmd);
        }
        strcat(command,"/");
        HTSACopy(&ProxyHREF,NewsHREF);
        HTSACopy(&NewsHREF,command);
        if ((bVar4) || (bVar5)) {
          p1 = strrchr(arg,0x2f);
          if (p1 == (char *)0x0) {
            p1 = strrchr(arg,0x3a);
            p1 = p1 + 1;
          }
          else {
            p1 = p1 + 1;
          }
        }
        else {
          p1 = strrchr(p1 + 6,0x2f);
          if ((p1 == (char *)0x0) || (p1[1] == '\0')) {
            p1 = "*";
            bVar7 = false;
            bVar8 = true;
          }
          else {
            p1 = p1 + 1;
          }
        }
      }
      if ((((bVar6) || (bVar3)) || (bVar4)) || (bVar5)) {
        memcpy(command,&DAT_0818f2d5,5);
      }
      else {
        if (bVar8) {
          __n = strlen(p1);
          if (0xf9 < __n) {
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            b = (char *)gettext("URL too long");
            HTAlert(b);
            local_4c4 = -400;
            goto LAB_0813c941;
          }
          sprintf(command,"XGTITLE %.*s",0xfb,p1);
        }
        else {
          if (bVar7) {
            b = strchr(p1,0x2f);
            first = 0;
            last = 0;
            if (b == (char *)0x0) {
              __n = strlen(p1);
              if (0xff < __n) {
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
                b = (char *)gettext("URL too long");
                HTAlert(b);
                local_4c4 = -400;
                goto LAB_0813c941;
              }
              LYstrncpy(groupName,p1,0xff);
            }
            else {
              *b = '\0';
              __n = strlen(p1);
              if (0xff < __n) {
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
                b = (char *)gettext("URL too long");
                HTAlert(b);
                local_4c4 = -400;
                goto LAB_0813c941;
              }
              LYstrncpy(groupName,p1,0xff);
              *b = '/';
              sscanf(b + 1,"%d-%d",&first,&last);
              if (((0 < first) &&
                  (ppuVar10 = __ctype_b_loc(), ((*ppuVar10)[(byte)b[1]] & 0x800) != 0)) &&
                 ((b = strchr(b + 1,0x2d), b == (char *)0x0 || (first == last)))) {
                last = -1;
              }
            }
            sprintf(command,"GROUP %.*s",0xfd,groupName);
          }
          else {
            b = strchr(p1,0x3c);
            uVar11 = (uint)(b == (char *)0x0);
            fmt = strchr(p1,0x3e);
            uVar12 = (uint)(fmt == (char *)0x0);
            __n = strlen(p1);
            if (0xfb < __n + uVar11 + uVar12) {
              if (ProxyHost != (char *)0x0) {
                free(ProxyHost);
                ProxyHost = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                free(ProxyHREF);
                ProxyHREF = (char *)0x0;
              }
              b = (char *)gettext("URL too long");
              HTAlert(b);
              local_4c4 = -400;
              goto LAB_0813c941;
            }
            if (fmt == (char *)0x0) {
              local_494 = &DAT_0818f305;
            }
            else {
              local_494 = &DAT_0818ec67;
            }
            if (b == (char *)0x0) {
              local_48c = &DAT_0818f307;
            }
            else {
              local_48c = &DAT_0818ec67;
            }
            sprintf(command,"ARTICLE %s%.*s%s",local_48c,(-uVar12 - uVar11) + 0xfb,p1,local_494);
          }
        }
      }
      __n = strlen(command);
      command[__n] = '\r';
      command[__n + 1] = '\n';
      command[__n + 2] = '\0';
      HTSACopy(&ListArg,p1);
      if (*arg != '\0') {
        if (((!bVar6) && (!bVar3)) &&
           (((!bVar4 && (!bVar5)) && (((!bVar7 || (last == -1)) && (!bVar8)))))) {
          head_wanted = anAnchor->isHEAD;
          if ((head_wanted != '\0') && (iVar9 = strncmp(command,"ARTICLE ",8), iVar9 == 0)) {
            memcpy(command,"HEAD ",6);
            cp = command + 5;
            while (*cp = cp[3], *cp != '\0') {
              cp = cp + 1;
            }
          }
          if ((head_wanted == '\0') && (keep_mime_headers == '\0')) {
            local_488 = '\0';
          }
          else {
            local_488 = '\x01';
          }
          rawtext = local_488;
        }
        if (rawtext == '\0') {
          if ((((!bVar6) && (!bVar3)) && (!bVar4)) && (!bVar5)) {
            node_anchor = anAnchor;
            target = HTML_new(anAnchor,format_out,stream);
            pHVar2 = target->isa;
            targetClass.name = pHVar2->name;
            targetClass._free = pHVar2->_free;
            targetClass._abort = pHVar2->_abort;
            targetClass.put_character = pHVar2->put_character;
            targetClass.put_string = pHVar2->put_string;
            targetClass.put_block = pHVar2->put_block;
            targetClass.start_element = pHVar2->start_element;
            targetClass.end_element = pHVar2->end_element;
            targetClass.put_entity = pHVar2->put_entity;
          }
        }
        else {
          node_anchor = anAnchor;
          rep_in = HTAtom_for("text/plain");
          rawtarget = HTStreamStack((HTFormat)rep_in,format_out,stream,anAnchor);
          if (rawtarget == (HTStream *)0x0) {
            if (NewsHost != (char *)0x0) {
              free(NewsHost);
              NewsHost = (char *)0x0;
            }
            if (NewsHREF != (char *)0x0) {
              free(NewsHREF);
              NewsHREF = (char *)0x0;
            }
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            b = (char *)gettext("No target for raw text!");
            HTAlert(b);
            local_4c4 = -29999;
            goto LAB_0813c941;
          }
          pHVar1 = rawtarget->isa;
          rawtargetClass.name = pHVar1->name;
          rawtargetClass._free = pHVar1->_free;
          rawtargetClass._abort = pHVar1->_abort;
          rawtargetClass.put_character = pHVar1->put_character;
          rawtargetClass.put_string = pHVar1->put_string;
          rawtargetClass.put_block = pHVar1->put_block;
        }
        retries = 0;
LAB_0813c7eb:
        if (1 < retries) goto LAB_0813c7f8;
        if (-1 < s) {
LAB_0813bd99:
          if ((((bVar6) || (bVar3)) || (bVar4)) || (bVar5)) {
            if (HTCanPost == 0) {
              b = (char *)gettext("Cannot POST to this host.");
              HTAlert(b);
              if (NewsHREF != (char *)0x0) {
                free(NewsHREF);
                NewsHREF = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                HTSACopy(&NewsHost,ProxyHost);
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
              }
              if (ListArg != (char *)0x0) {
                free(ListArg);
                ListArg = (char *)0x0;
              }
              if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
                free(postfile);
              }
              local_4c4 = -29999;
              goto LAB_0813c941;
            }
            if (postfile == (char *)0x0) {
              if ((bVar3) || (bVar5)) {
                local_484 = '\x01';
              }
              else {
                local_484 = '\0';
              }
              postfile = LYNewsPost(ListArg,local_484);
            }
            if (postfile == (char *)0x0) {
              b = (char *)gettext("Cancelled!!!");
              HTProgress(b);
              if (NewsHREF != (char *)0x0) {
                free(NewsHREF);
                NewsHREF = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                HTSACopy(&NewsHost,ProxyHost);
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
              }
              if (ListArg != (char *)0x0) {
                free(ListArg);
                ListArg = (char *)0x0;
              }
              local_4c4 = -29999;
              goto LAB_0813c941;
            }
          }
          else {
            sprintf(url,"mode reader%c%c",0xd,10);
            iVar9 = response(url);
            if (iVar9 == -0x752e) {
              mustshow = '\x01';
              b = (char *)gettext("Connection interrupted.");
              HTProgress(b);
              goto LAB_0813c7f8;
            }
            if (iVar9 == 0x1e0) {
              NVar15 = HTHandleAuthInfo(NewsHost);
              if ((((NVar15 == NNTPAUTH_CLOSE) && (s != -1)) && (ProxyHost == (char *)0x0)) &&
                 (ProxyHREF == (char *)0x0)) {
                close(s);
                s = -1;
              }
              if (NVar15 != NNTPAUTH_OK) goto LAB_0813c7f8;
              iVar9 = response(url);
              if (iVar9 == -0x752e) {
                mustshow = '\x01';
                b = (char *)gettext("Connection interrupted.");
                HTProgress(b);
                goto LAB_0813c7f8;
              }
            }
          }
Send_NNTP_command:
          do {
            iVar9 = response(command);
            if (iVar9 == -0x752e) {
              mustshow = '\x01';
              b = (char *)gettext("Connection interrupted.");
              HTProgress(b);
              goto LAB_0813c7f8;
            }
            if (iVar9 < 0) {
              if (0 < retries) goto LAB_0813c7f8;
              goto LAB_0813c7e4;
            }
            if (((iVar9 == 0x19b) && (bVar7)) &&
               ((iVar14 = strncmp(command,"GROUP ",6), iVar14 == 0 &&
                ((iVar14 = strncasecomp(response_text + 3," No such group ",0xf), iVar14 == 0 &&
                 (iVar14 = strcmp(response_text + 0x12,groupName), iVar14 == 0)))))) {
              HTAlert(response_text);
              goto LAB_0813c7f8;
            }
            if ((((iVar9 == 0x1ae) && (!bVar7)) && (!bVar8)) &&
               ((iVar14 = strncmp(command,"ARTICLE <",9), iVar14 == 0 &&
                (iVar14 = strcasecomp(response_text + 3," No such article"), iVar14 == 0)))) {
              HTAlert(response_text);
              goto LAB_0813c7f8;
            }
            if (((99 < iVar9 - 200U) && (iVar9 != 0x154)) && (iVar9 != 0x1e0)) {
              if (retries == 0) {
                mustshow = '\x01';
                HTProgress(response_text);
              }
              else {
                if ((bVar8) && (iVar9 = strncmp(command,"XGTITLE",7), iVar9 == 0)) {
                  sprintf(command,"LIST NEWSGROUPS%c%c",0xd,10);
                  goto Send_NNTP_command;
                }
                HTAlert(response_text);
              }
              close(s);
              s = -1;
              goto LAB_0813c7e4;
            }
            if (iVar9 != 0x1e0) {
              if (((bVar6) || (bVar3)) || ((bVar4 || (bVar5)))) {
                if (iVar9 == 0x154) {
                  post_article(postfile);
                }
                else {
                  b = (char *)gettext("Cannot POST to this host.");
                  HTAlert(b);
                  if (postfile != (char *)0x0) {
                    remove(postfile);
                  }
                }
                if (postfile != (char *)0x0) {
                  free(postfile);
                  postfile = (char *)0x0;
                }
                status = -29999;
                goto LAB_0813c61c;
              }
              if (bVar8) {
                mustshow = '\x01';
                b = (char *)gettext("Reading list of available newsgroups.");
                HTProgress(b);
                status = read_list(ListArg);
                goto LAB_0813c61c;
              }
              if (!bVar7) {
                mustshow = '\x01';
                b = (char *)gettext("Reading news article.");
                HTProgress(b);
                status = read_article(anAnchor);
                goto LAB_0813c61c;
              }
              if (-1 < last) {
                mustshow = '\x01';
                b = (char *)gettext("Reading list of articles in newsgroup.");
                HTProgress(b);
                status = read_group(groupName,first,last);
                goto LAB_0813c61c;
              }
              if (head_wanted == '\0') {
                local_47c = "ARTICLE";
              }
              else {
                local_47c = "HEAD";
              }
              sprintf(command,"%s %d%c%c",local_47c,first,0xd,10);
              bVar7 = false;
              retries = 2;
              goto Send_NNTP_command;
            }
            if ((((bVar8) && (iVar9 = strncmp(command,"XGTITLE",7), iVar9 == 0)) &&
                (b = strstr(response_text,"uthenticat"), b == (char *)0x0)) &&
               (b = strstr(response_text,"uthor"), b == (char *)0x0)) {
              sprintf(command,"LIST NEWSGROUPS%c%c",0xd,10);
              goto Send_NNTP_command;
            }
            NVar15 = HTHandleAuthInfo(NewsHost);
          } while (NVar15 == NNTPAUTH_OK);
          if (NVar15 == NNTPAUTH_CLOSE) {
            if (((s != -1) && (ProxyHost == (char *)0x0)) && (ProxyHREF == (char *)0x0)) {
              close(s);
              s = -1;
            }
            if (retries < 1) goto LAB_0813c7e4;
          }
          status = -29999;
LAB_0813c61c:
          if (status == -0x752e) {
            mustshow = '\x01';
            b = (char *)gettext("Connection interrupted.");
            HTProgress(b);
            status = 200;
          }
          if (((!bVar6) && (!bVar3)) && ((!bVar4 && (!bVar5)))) {
            if (status == -29999) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            else {
              if (rawtext == '\0') {
                (*targetClass._free)(target);
              }
              else {
                (*rawtargetClass._free)(rawtarget);
              }
            }
          }
          if (NewsHREF != (char *)0x0) {
            free(NewsHREF);
            NewsHREF = (char *)0x0;
          }
          if (ProxyHREF != (char *)0x0) {
            HTSACopy(&NewsHost,ProxyHost);
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
          }
          if (ListArg != (char *)0x0) {
            free(ListArg);
            ListArg = (char *)0x0;
          }
          if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
            free(postfile);
          }
          local_4c4 = status;
          goto LAB_0813c941;
        }
        iVar9 = strcmp(NewsHREF,"news:");
        if (iVar9 == 0) {
          sprintf(url,"lose://%.*s/",0xfb,NewsHost);
        }
        else {
          if (ProxyHREF == (char *)0x0) {
            sprintf(url,"%.*s",0x103,NewsHREF);
          }
          else {
            sprintf(url,"%.*s",0x103,ProxyHREF);
          }
        }
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"News: doing HTDoConnect on \'%s\'\n",url);
        }
        mustshow = '\x01';
        b = (char *)gettext("Connecting to NewsHost ...");
        HTProgress(b);
        iVar9 = HTDoConnect(url,"NNTP",0x77,&s);
        b = NewsHost;
        if (iVar9 == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTNews: Interrupted on connect; recovering cleanly.\n");
          }
          mustshow = '\x01';
          b = (char *)gettext("Connection interrupted.");
          HTProgress(b);
          if (((!bVar6) && (!bVar3)) && ((!bVar4 && (!bVar5)))) {
            if (rawtext == '\0') {
              (*targetClass._abort)(target,(HTError)0x0);
            }
            else {
              (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
            }
          }
          if (NewsHost != (char *)0x0) {
            free(NewsHost);
            NewsHost = (char *)0x0;
          }
          if (NewsHREF != (char *)0x0) {
            free(NewsHREF);
            NewsHREF = (char *)0x0;
          }
          if (ProxyHost != (char *)0x0) {
            free(ProxyHost);
            ProxyHost = (char *)0x0;
          }
          if (ProxyHREF != (char *)0x0) {
            free(ProxyHREF);
            ProxyHREF = (char *)0x0;
          }
          if (ListArg != (char *)0x0) {
            free(ListArg);
            ListArg = (char *)0x0;
          }
          if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
            free(postfile);
          }
          local_4c4 = -29999;
          goto LAB_0813c941;
        }
        if (iVar9 < 0) {
          close(s);
          s = -1;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTNews: Unable to connect to news host.\n");
          }
          if (0 < retries) {
            if (((!bVar6) && (!bVar3)) && ((!bVar4 && (!bVar5)))) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            b = NewsHost;
            fmt = (char *)gettext("Could not access %s.");
            HTSprintf0(&dbuf,fmt,b);
            if (NewsHost != (char *)0x0) {
              free(NewsHost);
              NewsHost = (char *)0x0;
            }
            if (NewsHREF != (char *)0x0) {
              free(NewsHREF);
              NewsHREF = (char *)0x0;
            }
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
              free(postfile);
            }
            local_4c4 = HTLoadError(stream,500,dbuf);
            goto LAB_0813c941;
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTNews: Connected to news host %s.\n",b);
          }
          HTInitInput(s);
          if (proxycmd[0] != '\0') {
            __n = strlen(proxycmd);
            sVar13 = write(s,proxycmd,__n);
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTNews: Proxy command returned status \'%d\'.\n",sVar13);
            }
          }
          iVar9 = response((char *)0x0);
          if (iVar9 - 200U < 100) {
            if (iVar9 != 200) {
              HTCanPost = 0;
              if ((((!bVar6) && (!bVar3)) && (!bVar4)) && (!bVar5)) goto LAB_0813bd99;
              b = (char *)gettext("Cannot POST to this host.");
              HTAlert(b);
              if (NewsHREF != (char *)0x0) {
                free(NewsHREF);
                NewsHREF = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                HTSACopy(&NewsHost,ProxyHost);
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
              }
              if (ListArg != (char *)0x0) {
                free(ListArg);
                ListArg = (char *)0x0;
              }
              if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
                free(postfile);
              }
              local_4c4 = -29999;
              goto LAB_0813c941;
            }
            HTCanPost = 1;
            goto LAB_0813bd99;
          }
          close(s);
          s = -1;
          if (iVar9 == -0x752e) {
            mustshow = '\x01';
            b = (char *)gettext("Connection interrupted.");
            HTProgress(b);
            if (((!bVar6) && (!bVar3)) && ((!bVar4 && (!bVar5)))) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            if (NewsHost != (char *)0x0) {
              free(NewsHost);
              NewsHost = (char *)0x0;
            }
            if (NewsHREF != (char *)0x0) {
              free(NewsHREF);
              NewsHREF = (char *)0x0;
            }
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
              free(postfile);
            }
            local_4c4 = -29999;
            goto LAB_0813c941;
          }
          if (0 < retries) {
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            if (postfile != (char *)0x0) {
              free(postfile);
            }
            if ((((!bVar6) && (!bVar3)) && (!bVar4)) && (!bVar5)) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            b = NewsHost;
            if (response_text[0] == '\0') {
              fmt = (char *)gettext("Can\'t read news info, empty response from host %s");
              HTSprintf0(&dbuf,fmt,b);
            }
            else {
              fmt = (char *)gettext("Can\'t read news info.  News host %.20s responded: %.200s");
              HTSprintf0(&dbuf,fmt,b,response_text);
            }
            local_4c4 = HTLoadError(stream,500,dbuf);
            goto LAB_0813c941;
          }
        }
LAB_0813c7e4:
        retries = retries + 1;
        goto LAB_0813c7eb;
      }
      if (NewsHREF != (char *)0x0) {
        free(NewsHREF);
        NewsHREF = (char *)0x0;
      }
      if (ProxyHost != (char *)0x0) {
        free(ProxyHost);
        ProxyHost = (char *)0x0;
      }
      if (ProxyHREF != (char *)0x0) {
        free(ProxyHREF);
        ProxyHREF = (char *)0x0;
      }
      if (ListArg != (char *)0x0) {
        free(ListArg);
        ListArg = (char *)0x0;
      }
      local_4c4 = 0;
    }
  }
  goto LAB_0813c941;
LAB_0813c7f8:
  if (((!bVar6) && (!bVar3)) && ((!bVar4 && (!bVar5)))) {
    if (rawtext == '\0') {
      (*targetClass._abort)(target,(HTError)0x0);
    }
    else {
      (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
    }
  }
  if (NewsHREF != (char *)0x0) {
    free(NewsHREF);
    NewsHREF = (char *)0x0;
  }
  if (ProxyHREF != (char *)0x0) {
    HTSACopy(&NewsHost,ProxyHost);
    if (ProxyHost != (char *)0x0) {
      free(ProxyHost);
      ProxyHost = (char *)0x0;
    }
    if (ProxyHREF != (char *)0x0) {
      free(ProxyHREF);
      ProxyHREF = (char *)0x0;
    }
  }
  if (ListArg != (char *)0x0) {
    free(ListArg);
    ListArg = (char *)0x0;
  }
  if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
    free(postfile);
  }
  local_4c4 = -29999;
LAB_0813c941:
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_4c4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void HTClearNNTPAuthInfo(void)

{
  free_NNTP_AuthInfo();
  return;
}



void init_acceptable(void)

{
  char *good;
  uint i;
  
  good = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
  i = 0;
  while (i < 0x100) {
    acceptable[i] = '\0';
    i = i + 1;
  }
  while (*good != '\0') {
    acceptable[*good] = '\x01';
    good = good + 1;
  }
  acceptable_inited = '\x01';
  return;
}



char from_hex(char c)

{
  char local_b;
  char local_a;
  char local_9;
  
  if ((c < '0') || ('9' < c)) {
    if ((c < 'A') || ('F' < c)) {
      if ((c < 'a') || ('f' < c)) {
        local_9 = '\0';
      }
      else {
        local_9 = c + -0x57;
      }
      local_a = local_9;
    }
    else {
      local_a = c + -0x37;
    }
    local_b = local_a;
  }
  else {
    local_b = c + -0x30;
  }
  return local_b;
}



void write_anchor(char *text,char *addr)

{
  int iVar1;
  FILE *__stream;
  int in_GS_OFFSET;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x19) {
    present[i] = '\0';
    i = i + 1;
  }
  present[6] = '\x01';
  value[6] = addr;
  present[22] = '\x01';
  value[22] = text;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTGopher: adding URL: %s\n",addr);
  }
  HT_Is_Gopher_URL = '\x01';
  (*targetClass.start_element)(target,0,present,value,-1,(char **)0x0);
  (*targetClass.put_string)(target,text);
  (*targetClass.end_element)(target,0,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void parse_menu(char *arg,HTParentAnchor *anAnchor)

{
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar1;
  char cVar2;
  char *local_4ec;
  FILE *__stream;
  char *__format;
  char *__s;
  int local_4f0;
  int in_GS_OFFSET;
  char *local_4d4;
  char *r;
  char *format;
  char *address;
  int i;
  char *junk;
  int BytesReported;
  int bytes;
  char *title;
  char *p;
  char *port;
  char *host;
  char *selector;
  char *name;
  int ich;
  char gtype;
  char line [1024];
  char buffer [128];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  name = (char *)0x0;
  selector = (char *)0x0;
  host = (char *)0x0;
  p = line;
  bytes = 0;
  BytesReported = 0;
  (*targetClass.start_element)(target,0x37,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  local_4ec = HTAnchor_title(anAnchor);
  paVar1 = targetClass.put_string;
  if (local_4ec == (char *)0x0) {
    local_4ec = (char *)gettext("Gopher Menu");
    (*paVar1)(target,local_4ec);
  }
  else {
    (*targetClass.put_string)(target,local_4ec);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x11,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  local_4ec = HTAnchor_title(anAnchor);
  paVar1 = targetClass.put_string;
  if (local_4ec == (char *)0x0) {
    local_4ec = (char *)gettext("Gopher Menu");
    (*paVar1)(target,local_4ec);
  }
  else {
    (*targetClass.put_string)(target,local_4ec);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  local_4ec = (char *)0xffffffff;
  (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  do {
    local_4f0 = HTGetCharacter();
    if (local_4f0 == -1) {
end_html:
      (*targetClass.end_element)(target,0x56,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x11,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x37,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass._free)(target);
      if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    if (interrupted_in_htgetcharacter != 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTGopher: Interrupted in HTGetCharacter, apparently.\n");
      }
      goto end_html;
    }
    if ((char)local_4f0 == '\n') {
      *p = '\0';
      bytes = (int)(p + bytes + (1 - (int)line));
      port = (char *)0x0;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTGopher: Menu item: %s\n",line);
      }
      cVar2 = line[0];
      gtype = line[0];
      __s = line + 1;
      if (BytesReported + 0x400 < bytes) {
        __format = (char *)gettext("Transferred %d bytes");
        sprintf(buffer,__format,bytes);
        HTProgress(buffer);
        BytesReported = bytes;
      }
      if ((cVar2 == '.') && ((line[1] == '\r' || (line[1] == '\0')))) goto end_html;
      if (((cVar2 != '\0') && (line[1] != '\0')) &&
         (selector = strchr(__s,9), name = __s, selector != (char *)0x0)) {
        *selector = '\0';
        selector = selector + 1;
        if ((cVar2 == '0') && ((*selector == '9' || (*selector == '5')))) {
          gtype = *selector;
        }
        host = strchr(selector,9);
        if (host != (char *)0x0) {
          *host = '\0';
          host = host + 1;
          port = strchr(host,9);
          if (port != (char *)0x0) {
            *port = ':';
            __s = strchr(port,9);
            if (__s != (char *)0x0) {
              *__s = '\0';
            }
            if ((port[1] == '0') && (port[2] == '\0')) {
              *port = '\0';
            }
          }
        }
      }
      if (gtype == '0') {
        i = strlen(name);
        while ((i = i - 1, name[i] == ' ' && (-1 < i))) {
          name[i] = '\0';
        }
        if (i < 0) {
          gtype = 'i';
        }
      }
      if (gtype == 'w') {
        (*targetClass.put_string)(target,"(HTML) ");
        write_anchor(name,selector);
      }
      else {
        if (gtype == 'i') {
          (*targetClass.put_string)(target,"       ");
          (*targetClass.put_string)(target,name);
        }
        else {
          if (port == (char *)0x0) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTGopher: Bad menu item.\n");
            }
            (*targetClass.put_string)(target,line);
          }
          else {
            address = (char *)0x0;
            if (*selector == '\0') {
              local_4d4 = "%s//%s/";
            }
            else {
              local_4d4 = "%s//%s@%s/";
            }
            if (gtype == '8') {
              (*targetClass.put_string)(target," (TEL) ");
              local_4ec = host;
              HTSprintf0(&address,local_4d4,"telnet:",selector);
            }
            else {
              if (gtype == 'T') {
                (*targetClass.put_string)(target,"(3270) ");
                local_4ec = host;
                HTSprintf0(&address,local_4d4,"tn3270:",selector);
              }
              else {
                switch(gtype) {
                case '0':
                  (*targetClass.put_string)(target,"(FILE) ");
                  break;
                case '1':
                  (*targetClass.put_string)(target," (DIR) ");
                  break;
                case '2':
                  (*targetClass.put_string)(target," (CSO) ");
                  break;
                default:
                  (*targetClass.put_string)(target,"(UNKN) ");
                  break;
                case '4':
                  (*targetClass.put_string)(target," (HQX) ");
                  break;
                case '5':
                  (*targetClass.put_string)(target," (BIN) ");
                  break;
                case '6':
                  (*targetClass.put_string)(target," (UUE) ");
                  break;
                case '7':
                  (*targetClass.put_string)(target,"  (?)  ");
                  break;
                case '9':
                  (*targetClass.put_string)(target," (BIN) ");
                  break;
                case ':':
                case 'I':
                case 'g':
                  (*targetClass.put_string)(target," (IMG) ");
                  break;
                case ';':
                  (*targetClass.put_string)(target," (MOV) ");
                  break;
                case '<':
                case 's':
                  (*targetClass.put_string)(target," (SND) ");
                  break;
                case 'H':
                case 'h':
                  (*targetClass.put_string)(target,"(HTML) ");
                  break;
                case 'P':
                  (*targetClass.put_string)(target," (PDF) ");
                  break;
                case 'm':
                  (*targetClass.put_string)(target,"(MIME) ");
                }
                local_4f0 = (int)gtype;
                HTSprintf0(&address,"//%s/%c",host,local_4f0);
                r = selector;
                while (*r != '\0') {
                  if (acceptable[(byte)*r] == '\0') {
                    local_4ec = (char *)(int)"0123456789abcdef"[(int)*r & 0xf];
                    local_4f0 = (int)"0123456789abcdef"[*r >> 4];
                    HTSprintf(&address,"%c%c%c",0x25,local_4f0,local_4ec);
                  }
                  else {
                    HTSprintf(&address,"%c",(int)*r,local_4f0,local_4ec);
                  }
                  r = r + 1;
                }
              }
            }
            local_4f0 = strcmp(address,"gopher://error.host:1/0");
            if (local_4f0 == 0) {
              (*targetClass.put_string)(target,name);
            }
            else {
              write_anchor(name,address);
            }
            if (address != (char *)0x0) {
              free(address);
              address = (char *)0x0;
            }
          }
        }
      }
      (*targetClass.put_character)(target,'\n');
      p = line;
    }
    else {
      *p = (char)local_4f0;
      if (p < line + 0x3ff) {
        p = p + 1;
      }
    }
  } while( true );
}



void parse_cso(char *arg,HTParentAnchor *anAnchor)

{
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  char *title;
  char *second_colon;
  char *first_colon;
  char *p;
  int ich;
  char last_char;
  char line [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  p = line;
  last_char = '\0';
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  paVar1 = targetClass.put_string;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (char *)gettext("CSO Search Results");
    (*paVar1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    (*targetClass.put_string)(target,arg);
    paVar1 = targetClass.put_string;
    pcVar2 = (char *)gettext(" Search Results");
    (*paVar1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
LAB_0813dd1a:
  do {
    iVar3 = HTGetCharacter();
    if (iVar3 == -1) {
LAB_0813dd32:
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x56,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass._free)(target);
      if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    if ((char)iVar3 != '\n') {
      *p = (char)iVar3;
      if (p < line + 0x3ff) {
        p = p + 1;
      }
      goto LAB_0813dd1a;
    }
    *p = '\0';
    p = line;
    if (line[0] == '2') goto LAB_0813dd32;
    if (line[0] == '5') {
      (*targetClass.start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,line + 4);
      (*targetClass.end_element)(target,0x30,(char **)0x0);
      goto LAB_0813dd32;
    }
    if (line[0] == '-') {
      second_colon = (char *)0x0;
      pcVar2 = strchr(p,0x3a);
      if (pcVar2 != (char *)0x0) {
        second_colon = strchr(pcVar2 + 1,0x3a);
      }
      if (second_colon != (char *)0x0) {
        if (second_colon[-1] != last_char) {
          (*targetClass.end_element)(target,0x56,(char **)0x0);
          (*targetClass.start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        }
        (*targetClass.put_string)(target,second_colon + 1);
        (*targetClass.put_character)(target,'\n');
        if (second_colon[-1] != last_char) {
          (*targetClass.end_element)(target,0x30,(char **)0x0);
          (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        }
        last_char = second_colon[-1];
      }
    }
  } while( true );
}



void display_cso(char *arg,HTParentAnchor *anAnchor)

{
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar1;
  char *pcVar2;
  char *title;
  
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  paVar1 = targetClass.put_string;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (char *)gettext("CSO index");
    (*paVar1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x3e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    (*targetClass.put_string)(target,arg);
    paVar1 = targetClass.put_string;
    pcVar2 = (char *)gettext(" index");
    (*paVar1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  paVar1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nThis is a searchable index of a CSO database.\n");
  (*paVar1)(target,pcVar2);
  (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  paVar1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nPress the \'s\' key and enter search keywords.\n");
  (*paVar1)(target,pcVar2);
  (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  paVar1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nThe keywords that you enter will allow you to search on a");
  (*paVar1)(target,pcVar2);
  paVar1 = targetClass.put_string;
  pcVar2 = (char *)gettext(" person\'s name in the database.\n");
  (*paVar1)(target,pcVar2);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    HTAnchor_setTitle(anAnchor,arg);
  }
  (*targetClass._free)(target);
  return;
}



void display_index(char *arg,HTParentAnchor *anAnchor)

{
  anon_subr_void_HTStructured_ptr_char_ptr_for_put_string *paVar1;
  char *pcVar2;
  char *title;
  
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  paVar1 = targetClass.put_string;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (char *)gettext("Gopher index");
    (*paVar1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x3e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    (*targetClass.put_string)(target,arg);
    paVar1 = targetClass.put_string;
    pcVar2 = (char *)gettext(" index");
    (*paVar1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  paVar1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nThis is a searchable Gopher index.\n");
  (*paVar1)(target,pcVar2);
  (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  paVar1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nPlease enter search keywords.\n");
  (*paVar1)(target,pcVar2);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    HTAnchor_setTitle(anAnchor,arg);
  }
  (*targetClass._free)(target);
  return;
}



void de_escape(char *command,char *selector)

{
  char *pcVar1;
  char cVar2;
  char cVar3;
  uint b;
  char *q;
  char *p;
  char c;
  
  p = selector;
  q = command;
  if (command == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
  }
  while (*p != '\0') {
    if (*p == '%') {
      pcVar1 = p + 2;
      cVar2 = from_hex(p[1]);
      p = p + 3;
      if (*pcVar1 == '\0') break;
      cVar3 = from_hex(*pcVar1);
      *q = (char)((int)cVar2 << 4) + cVar3;
      q = q + 1;
    }
    else {
      *q = *p;
      q = q + 1;
      p = p + 1;
    }
  }
  *q = '\0';
  return;
}



void free_CSOfields(void)

{
  _CSOfield_info *p_Var1;
  CSOfield_info *prev;
  CSOfield_info *cur;
  
  cur = CSOfields;
  p_Var1 = (_CSOfield_info *)cur;
  while (cur = (CSOfield_info *)p_Var1, cur != (CSOfield_info *)0x0) {
    if ((cur->name != cur->name_buf) && (cur->name != (char *)0x0)) {
      free(cur->name);
      cur->name = (char *)0x0;
    }
    if ((cur->attributes != cur->attr_buf) && (cur->attributes != (char *)0x0)) {
      free(cur->attributes);
      cur->attributes = (char *)0x0;
    }
    if ((cur->description != cur->desc_buf) && (cur->description != (char *)0x0)) {
      free(cur->description);
      cur->description = (char *)0x0;
    }
    p_Var1 = cur->next;
    if (cur != (CSOfield_info *)0x0) {
      free(cur);
    }
  }
  return;
}



void interpret_cso_key(char *key,char *buf,int *length,CSOformgen_context *ctx,HTStream *Target)

{
  CSOfield_info *pCVar1;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  bool bVar3;
  int iVar4;
  size_t sVar5;
  char *local_30;
  char *local_2c;
  int local_24;
  int local_1c;
  size_t out;
  int error;
  CSOfield_info *fld;
  
  pCVar1 = ctx->fld;
  if (pCVar1 != (CSOfield_info *)0x0) {
    bVar3 = false;
    iVar4 = strncmp(key,"$(FID)",6);
    if (iVar4 == 0) {
      sprintf(buf,"%d",pCVar1->id);
    }
    else {
      iVar4 = strncmp(key,"$(FDESC)",8);
      if (iVar4 == 0) {
        sprintf(buf,"%.2046s",pCVar1->description);
      }
      else {
        iVar4 = strncmp(key,"$(FDEF)",7);
        if (iVar4 == 0) {
          if (pCVar1->defreturn == 0) {
            local_30 = "";
          }
          else {
            local_30 = " checked";
          }
          strcpy(buf,local_30);
        }
        else {
          iVar4 = strncmp(key,"$(FNDX)",7);
          if (iVar4 == 0) {
            if (pCVar1->indexed == 0) {
              local_2c = "";
            }
            else {
              local_2c = "*";
            }
            strcpy(buf,local_2c);
          }
          else {
            iVar4 = strncmp(key,"$(FSIZE)",8);
            if (iVar4 == 0) {
              local_24 = pCVar1->max_size;
              if (0x37 < local_24) {
                local_24 = 0x37;
              }
              sprintf(buf," size=%d maxlength=%d",local_24,pCVar1->max_size);
            }
            else {
              iVar4 = strncmp(key,"$(FSIZE2)",9);
              if (iVar4 == 0) {
                sprintf(buf," maxlength=%d",pCVar1->max_size);
              }
              else {
                bVar3 = true;
              }
            }
          }
        }
      }
    }
    if (!bVar3) {
      sVar5 = strlen(buf);
      *length = sVar5;
      return;
    }
  }
  *buf = '\0';
  iVar4 = strncmp(key,"$(NEXTFLD)",10);
  if (iVar4 == 0) {
    if (ctx->fld == (CSOfield_info *)0x0) {
      fld = CSOfields;
    }
    else {
      fld = (CSOfield_info *)ctx->fld->next;
    }
    iVar4 = ctx->field_select;
    if (iVar4 == 1) {
      while ((fld != (CSOfield_info *)0x0 && (fld->lookup != 1))) {
        fld = (CSOfield_info *)fld->next;
      }
    }
    else {
      if (iVar4 == 2) {
        while ((fld != (CSOfield_info *)0x0 && (fld->gpublic == 0))) {
          fld = (CSOfield_info *)fld->next;
        }
      }
      else {
        if (iVar4 == 0) {
          while ((fld != (CSOfield_info *)0x0 && ((fld->gpublic == 0 || (fld->lookup != 1))))) {
            fld = (CSOfield_info *)fld->next;
          }
        }
      }
    }
    if (fld != (CSOfield_info *)0x0) {
      ctx->cur_line = ctx->rep_line;
      ctx->cur_off = ctx->rep_off;
    }
    ctx->fld = fld;
  }
  else {
    iVar4 = strncmp(key,"$(QFIELDS)",10);
    if ((iVar4 == 0) || (iVar4 = strncmp(key,"$(RFIELDS)",10), iVar4 == 0)) {
      ctx->rep_line = ctx->cur_line;
      ctx->rep_off = ctx->cur_off;
      ctx->fld = (CSOfield_info *)0x0;
      ctx->seek = "$(NEXTFLD)";
      if (key[2] == 'Q') {
        local_1c = 0;
      }
      else {
        local_1c = 2;
      }
      ctx->field_select = local_1c;
      if (ctx->public_override != 0) {
        ctx->field_select = ctx->field_select + 1;
      }
    }
    else {
      iVar4 = strncmp(key,"$(NAMEFLD)",10);
      if (iVar4 == 0) {
        fld = CSOfields;
        while (fld != (CSOfield_info *)0x0) {
          iVar4 = strcmp(fld->name,"name");
          if ((iVar4 == 0) || (iVar4 = strcmp(fld->name,"Name"), iVar4 == 0)) {
            if (fld->lookup != 0) {
              fld->lookup = 2;
            }
            break;
          }
          fld = (CSOfield_info *)fld->next;
        }
        ctx->fld = fld;
      }
      else {
        iVar4 = strncmp(key,"$(HOST)",7);
        if (iVar4 == 0) {
          strcpy(buf,ctx->host);
        }
        else {
          iVar4 = strncmp(key,"$(PORT)",7);
          if (iVar4 != 0) {
            out = 0;
            while ((*key != '\0' && (*key != ')'))) {
              buf[out] = *key;
              out = out + 1;
              key = key + 1;
              if (2 < out) {
                buf[out] = '\0';
                paVar2 = Target->isa->put_block;
                sVar5 = strlen(buf);
                (*paVar2)(Target,buf,sVar5);
                out = 0;
              }
            }
            buf[out] = ')';
            buf[out + 1] = '\0';
            sVar5 = strlen(buf);
            *length = sVar5;
            return;
          }
          sprintf(buf,"%d",ctx->port);
        }
      }
    }
  }
  sVar5 = strlen(buf);
  *length = sVar5;
  return;
}



int parse_cso_field_info(CSOfield_info *blk)

{
  char *pcVar1;
  char *arg_buffer;
  char *max_spec;
  char *info;
  
  blk->url = 0;
  blk->max_size = blk->url;
  blk->reserved = blk->max_size;
  blk->lookup = blk->reserved;
  blk->indexed = blk->lookup;
  blk->gpublic = 0;
  blk->explicit_return = blk->gpublic;
  blk->defreturn = blk->explicit_return;
  arg_buffer = blk->attributes;
  LYLowerCase(arg_buffer);
  pcVar1 = strstr(arg_buffer,"indexed ");
  if (pcVar1 != (char *)0x0) {
    blk->indexed = 1;
  }
  pcVar1 = strstr(arg_buffer,"default ");
  if (pcVar1 != (char *)0x0) {
    blk->defreturn = 1;
  }
  pcVar1 = strstr(arg_buffer,"public ");
  if (pcVar1 != (char *)0x0) {
    blk->gpublic = 1;
  }
  pcVar1 = strstr(arg_buffer,"lookup ");
  if (pcVar1 != (char *)0x0) {
    blk->lookup = 1;
  }
  pcVar1 = strstr(arg_buffer,"url ");
  if (pcVar1 != (char *)0x0) {
    blk->url = 1;
    blk->defreturn = 1;
  }
  arg_buffer = strstr(arg_buffer,"max ");
  if (arg_buffer == (char *)0x0) {
    blk->max_size = 0x20;
  }
  else {
    sscanf(arg_buffer + 4,"%d",&blk->max_size);
  }
  return 0;
}



int parse_cso_fields(char *buf,int size)

{
  CSOfield_info *pCVar1;
  FILE *__stream;
  size_t sVar2;
  CSOfield_info *blk;
  char *pcVar3;
  int iVar4;
  int local_38;
  CSOfield_info *newf;
  CSOfield_info *last;
  char *name;
  char *indx;
  size_t alen;
  int prev_code;
  int code;
  int i;
  char *p;
  int ich;
  
  p = buf;
  code = 0;
  CSOfields = (CSOfield_info *)0x0;
  last = (CSOfield_info *)0x0;
  prev_code = -0x9fb;
  *buf = '\0';
  while (iVar4 = HTGetCharacter(), iVar4 != -1) {
    if (interrupted_in_htgetcharacter != 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
      }
      free_CSOfields();
      *buf = '\0';
      return -0x752e;
    }
    if ((char)iVar4 == '\n') {
      *p = '\0';
      p = buf;
      if (*buf == '2') break;
      if (*buf == '5') {
        strcpy(buf,buf);
        return 5;
      }
      if ((*buf == '-') && (buf[1] == '2')) {
        indx = (char *)0x0;
        name = (char *)0x0;
        i = 0;
        while (buf[i] != '\0') {
          if (buf[i] == ':') {
            buf[i] = '\0';
            if (indx == (char *)0x0) {
              indx = buf + i + 1;
              code = atoi(indx);
            }
            else {
              if (name != (char *)0x0) {
                i = i + 1;
                break;
              }
              name = buf + i + 1;
            }
          }
          i = i + 1;
        }
        if (name == (char *)0x0) break;
        if (code == prev_code) {
          sVar2 = strlen(buf + i);
          if (0x20 < sVar2 + 1) {
            if ((last->description != last->desc_buf) && (last->description != (char *)0x0)) {
              free(last->description);
              last->description = (char *)0x0;
            }
            pcVar3 = (char *)malloc(sVar2 + 1);
            last->description = pcVar3;
            if (last->description == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
            }
          }
          strcpy(last->description,buf + i);
        }
        else {
          blk = (CSOfield_info *)calloc(1,0xb4);
          if (blk == (CSOfield_info *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
          }
          pCVar1 = blk;
          if (last != (CSOfield_info *)0x0) {
            *(CSOfield_info **)&last->next = blk;
            pCVar1 = CSOfields;
          }
          CSOfields = pCVar1;
          blk->next = (_CSOfield_info *)0x0;
          blk->name = blk->name_buf;
          sVar2 = strlen(name);
          if (0x10 < sVar2 + 1) {
            pcVar3 = (char *)malloc(sVar2 + 1);
            blk->name = pcVar3;
            if (blk->name == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
            }
          }
          strcpy(blk->name,name);
          blk->attributes = blk->attr_buf;
          sVar2 = strlen(buf + i);
          if (0x50 < sVar2 + 2) {
            pcVar3 = (char *)malloc(sVar2 + 2);
            blk->attributes = pcVar3;
            if (blk->attributes == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
            }
          }
          strcpy(blk->attributes,buf + i);
          memcpy(blk->attributes + sVar2,&DAT_0818fb91,2);
          blk->description = blk->desc_buf;
          blk->desc_buf[0] = '\0';
          iVar4 = atoi(indx);
          blk->id = iVar4;
          parse_cso_field_info(blk);
          last = blk;
        }
        prev_code = code;
      }
    }
    else {
      *p = (char)iVar4;
      if (p < buf + size + -1) {
        p = p + 1;
      }
    }
  }
  if (*buf == '\0') {
    local_38 = -1;
  }
  else {
    *buf = '\0';
    local_38 = 0;
  }
  return local_38;
}



int generate_cso_form(char *host,int port,char *buf,HTStream *Target)

{
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar1;
  char *ctemplate [25];
  char *key_00;
  int iVar2;
  char *fmt;
  size_t __n;
  CSOformgen_context ctx;
  char *temp;
  int slen;
  char *line;
  char *key;
  int full_flag;
  size_t out;
  int length;
  int j;
  int i;
  
  memset(&ctx,0,0x28);
  ctx.host = host;
  ctx.seek = (char *)0x0;
  ctx.port = port;
  ctx.fld = (CSOfield_info *)0x0;
  ctx.public_override = 1;
  out = 0;
  *buf = '\0';
  i = 0;
  do {
    if (((char **)&ram0x081aa280)[i] == (char *)0x0) {
      if (out != 0) {
        paVar1 = Target->isa->put_block;
        __n = strlen(buf);
        (*paVar1)(Target,buf,__n);
      }
      return 0;
    }
    line = *(char **)(i * 4 + 0x81aa280);
    j = 0;
    while (line[j] != '\0') {
      if ((line[j] == '$') && (line[j + 1] == '(')) {
        buf[out] = '\0';
        if (out != 0) {
          paVar1 = Target->isa->put_block;
          __n = strlen(buf);
          (*paVar1)(Target,buf,__n);
        }
        key_00 = line + j;
        while ((line[j + 1] != '\0' && (line[j] != ')'))) {
          j = j + 1;
        }
        ctx.cur_line = i;
        ctx.cur_off = j;
        interpret_cso_key(key_00,buf,&length,&ctx,Target);
        i = ctx.cur_line;
        j = ctx.cur_off;
        line = *(char **)(ctx.cur_line * 4 + 0x81aa280);
        out = length;
        if (ctx.seek != (char *)0x0) {
          __n = strlen(ctx.seek);
          while (*(int *)(i * 4 + 0x81aa280) != 0) {
            line = *(char **)(i * 4 + 0x81aa280);
            while (line[j] != '\0') {
              if ((line[j] == '$') && (iVar2 = strncmp(ctx.seek,line + j,__n), iVar2 == 0)) {
                if (j == 0) {
                  i = i + -1;
                  j = strlen(*(char **)(i * 4 + 0x81aa280));
                }
                j = j - 1;
                line = *(char **)(i * 4 + 0x81aa280);
                ctx.seek = (char *)0x0;
                break;
              }
              j = j + 1;
            }
            if (ctx.seek == (char *)0x0) break;
            j = 0;
            i = i + 1;
          }
          key_00 = ctx.seek;
          if (ctx.seek != (char *)0x0) {
            temp = (char *)0x0;
            fmt = (char *)gettext("Seek fail on %s\n");
            HTSprintf0(&temp,fmt,key_00);
            paVar1 = Target->isa->put_block;
            __n = strlen(temp);
            (*paVar1)(Target,temp,__n);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
          }
        }
      }
      else {
        buf[out] = line[j];
        out = out + 1;
        if (1 < out) {
          buf[out] = '\0';
          paVar1 = Target->isa->put_block;
          __n = strlen(buf);
          (*paVar1)(Target,buf,__n);
          out = 0;
        }
      }
      j = j + 1;
    }
    buf[out] = '\n';
    out = out + 1;
    buf[out] = '\0';
    i = i + 1;
  } while( true );
}



int generate_cso_report(HTStream *Target)

{
  char cVar1;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar2;
  bool bVar3;
  FILE *__stream;
  char *src;
  int iVar4;
  size_t sVar5;
  int in_GS_OFFSET;
  char *local_454;
  char *local_450;
  CSOfield_info *fld;
  char *l;
  char *fvalue;
  char *fname;
  char *ndx_str;
  char *rcode;
  int ndx;
  int prev_ndx;
  int i;
  int len;
  char *href;
  char *p;
  char *buf;
  int ich;
  BOOLEAN stop;
  char line [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  buf = (char *)0x0;
  p = line;
  href = (char *)0x0;
  bVar3 = false;
  prev_ndx = -100;
  while( true ) {
    if ((bVar3) || (iVar4 = HTGetCharacter(), iVar4 == -1)) goto end_CSOreport;
    if (interrupted_in_htgetcharacter != 0) break;
    if ((char)iVar4 == '\n') {
      *p = '\0';
      p = line;
      if ((line[0] != '-') && (line[0] != '1')) {
        bVar3 = true;
      }
      local_454 = p;
      if (line[0] == '-') {
        local_454 = line + 1;
      }
      fname = (char *)0x0;
      ndx_str = (char *)0x0;
      sVar5 = strlen(p);
      i = 0;
      while (i < (int)sVar5) {
        if (p[i] == ':') {
          p[i] = '\0';
          if (ndx_str != (char *)0x0) {
            fname = p + i + 1;
            break;
          }
          fname = p + i + 1;
          ndx_str = fname;
        }
        i = i + 1;
      }
      if (ndx_str == (char *)0x0) {
        HTSprintf0(&buf,"<DD>%s\n",local_454);
        paVar2 = Target->isa->put_block;
        sVar5 = strlen(buf);
        (*paVar2)(Target,buf,sVar5);
      }
      else {
        iVar4 = atoi(ndx_str);
        if (prev_ndx != iVar4) {
          if (prev_ndx != -100) {
            HTSprintf0(&buf,"</DL></DL>\n");
            paVar2 = Target->isa->put_block;
            sVar5 = strlen(buf);
            (*paVar2)(Target,buf,sVar5);
          }
          prev_ndx = iVar4;
          if (iVar4 == 0) {
            HTSprintf0(&buf,"<HR><DL><DT>Information/status<DD><DL><DT>\n");
            paVar2 = Target->isa->put_block;
            sVar5 = strlen(buf);
            (*paVar2)(Target,buf,sVar5);
          }
          else {
            HTSprintf0(&buf,"<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n",iVar4);
            paVar2 = Target->isa->put_block;
            sVar5 = strlen(buf);
            (*paVar2)(Target,buf,sVar5);
          }
        }
        if (((*local_454 < '2') || ('5' < *local_454)) || (fname == ndx_str)) {
          if (fname == (char *)0x0) {
            local_450 = local_454;
          }
          else {
            local_450 = fname;
          }
          HTSprintf0(&buf,"<DD>%s\n",local_450);
          paVar2 = Target->isa->put_block;
          sVar5 = strlen(buf);
          (*paVar2)(Target,buf,sVar5);
        }
        else {
          while (*fname == ' ') {
            fname = fname + 1;
          }
          fvalue = fname;
          while( true ) {
            if (*fvalue == '\0') goto LAB_0813f8a6;
            if (*fvalue == ':') break;
            fvalue = fvalue + 1;
          }
          *fvalue = '\0';
          fvalue = fvalue + 1;
          i = strlen(fname);
          while ((i = i - 1, -1 < i && (fname[i] == ' '))) {
            fname[i] = '\0';
          }
LAB_0813f8a6:
          if (fvalue != (char *)0x0) {
            while (*fvalue == ' ') {
              fvalue = fvalue + 1;
            }
          }
          if (*fname == '\0') {
            HTSprintf0(&buf,"<DD>");
            paVar2 = Target->isa->put_block;
            sVar5 = strlen(buf);
            (*paVar2)(Target,buf,sVar5);
            *buf = '\0';
            l = fvalue;
            while (*l != '\0') {
              if (*l == '<') {
                HTSACat(&buf,"&lt;");
                l = l + 1;
              }
              else {
                if (*l == '>') {
                  HTSACat(&buf,"&gt;");
                  l = l + 1;
                }
                else {
                  iVar4 = strncmp(l,"news:",5);
                  if (((((iVar4 == 0) || (iVar4 = strncmp(l,"snews://",8), iVar4 == 0)) ||
                       ((iVar4 = strncmp(l,"nntp://",7), iVar4 == 0 ||
                        ((((iVar4 = strncmp(l,"snewspost:",10), iVar4 == 0 ||
                           (iVar4 = strncmp(l,"snewsreply:",0xb), iVar4 == 0)) ||
                          (iVar4 = strncmp(l,"newspost:",9), iVar4 == 0)) ||
                         ((iVar4 = strncmp(l,"newsreply:",10), iVar4 == 0 ||
                          (iVar4 = strncmp(l,"ftp://",6), iVar4 == 0)))))))) ||
                      ((iVar4 = strncmp(l,"file:/",6), iVar4 == 0 ||
                       ((iVar4 = strncmp(l,"finger://",9), iVar4 == 0 ||
                        (iVar4 = strncmp(l,"http://",7), iVar4 == 0)))))) ||
                     (((iVar4 = strncmp(l,"https://",8), iVar4 == 0 ||
                       (((iVar4 = strncmp(l,"wais://",7), iVar4 == 0 ||
                         (iVar4 = strncmp(l,"mailto:",7), iVar4 == 0)) ||
                        (iVar4 = strncmp(l,"cso://",6), iVar4 == 0)))) ||
                      (iVar4 = strncmp(l,"gopher://",9), iVar4 == 0)))) {
                    HTSACat(&buf,"<a href=\"");
                    HTSACopy(&href,l);
                    src = strtok(href," \r\n\t,>)\"");
                    HTSACat(&buf,src);
                    HTSACat(&buf,"\">");
                    while ((*l != '\0' && (src = strchr(" \r\n\t,>)\"",(int)*l), src == (char *)0x0)
                           )) {
                      cVar1 = *l;
                      l = l + 1;
                      HTSprintf(&buf,"%c",(int)cVar1);
                    }
                    HTSACat(&buf,"</a>");
                    if (href != (char *)0x0) {
                      free(href);
                      href = (char *)0x0;
                    }
                  }
                  else {
                    cVar1 = *l;
                    l = l + 1;
                    HTSprintf(&buf,"%c",(int)cVar1);
                  }
                }
              }
            }
            HTSACat(&buf,"\n");
            paVar2 = Target->isa->put_block;
            sVar5 = strlen(buf);
            (*paVar2)(Target,buf,sVar5);
          }
          else {
            fld = CSOfields;
            while (fld != (CSOfield_info *)0x0) {
              iVar4 = strcmp(fld->name,fname);
              if (iVar4 == 0) {
                if (fld->description != (char *)0x0) {
                  fname = fld->description;
                }
                break;
              }
              fld = (CSOfield_info *)fld->next;
            }
            if ((fld == (CSOfield_info *)0x0) || (fld->url == 0)) {
              HTSprintf0(&buf,"<DT><I>%s</I><DD>",fname);
              paVar2 = Target->isa->put_block;
              sVar5 = strlen(buf);
              (*paVar2)(Target,buf,sVar5);
              *buf = '\0';
              l = fvalue;
              while (*l != '\0') {
                if (*l == '<') {
                  HTSACat(&buf,"&lt;");
                  l = l + 1;
                }
                else {
                  if (*l == '>') {
                    HTSACat(&buf,"&gt;");
                    l = l + 1;
                  }
                  else {
                    iVar4 = strncmp(l,"news:",5);
                    if ((((((iVar4 == 0) || (iVar4 = strncmp(l,"snews://",8), iVar4 == 0)) ||
                          (iVar4 = strncmp(l,"nntp://",7), iVar4 == 0)) ||
                         (((iVar4 = strncmp(l,"snewspost:",10), iVar4 == 0 ||
                           (iVar4 = strncmp(l,"snewsreply:",0xb), iVar4 == 0)) ||
                          ((iVar4 = strncmp(l,"newspost:",9), iVar4 == 0 ||
                           ((iVar4 = strncmp(l,"newsreply:",10), iVar4 == 0 ||
                            (iVar4 = strncmp(l,"ftp://",6), iVar4 == 0)))))))) ||
                        (iVar4 = strncmp(l,"file:/",6), iVar4 == 0)) ||
                       (((((iVar4 = strncmp(l,"finger://",9), iVar4 == 0 ||
                           (iVar4 = strncmp(l,"http://",7), iVar4 == 0)) ||
                          (iVar4 = strncmp(l,"https://",8), iVar4 == 0)) ||
                         ((iVar4 = strncmp(l,"wais://",7), iVar4 == 0 ||
                          (iVar4 = strncmp(l,"mailto:",7), iVar4 == 0)))) ||
                        ((iVar4 = strncmp(l,"cso://",6), iVar4 == 0 ||
                         (iVar4 = strncmp(l,"gopher://",9), iVar4 == 0)))))) {
                      HTSACat(&buf,"<a href=\"");
                      HTSACopy(&href,l);
                      src = strtok(href," \r\n\t,>)\"");
                      HTSACat(&buf,src);
                      HTSACat(&buf,"\">");
                      while ((*l != '\0' &&
                             (src = strchr(" \r\n\t,>)\"",(int)*l), src == (char *)0x0))) {
                        cVar1 = *l;
                        l = l + 1;
                        HTSprintf(&buf,"%c",(int)cVar1);
                      }
                      HTSACat(&buf,"</a>");
                      if (href != (char *)0x0) {
                        free(href);
                        href = (char *)0x0;
                      }
                    }
                    else {
                      cVar1 = *l;
                      l = l + 1;
                      HTSprintf(&buf,"%c",(int)cVar1);
                    }
                  }
                }
              }
              HTSACat(&buf,"\n");
              paVar2 = Target->isa->put_block;
              sVar5 = strlen(buf);
              (*paVar2)(Target,buf,sVar5);
            }
            else {
              HTSprintf0(&buf,"<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",fname,fvalue,fvalue);
              paVar2 = Target->isa->put_block;
              sVar5 = strlen(buf);
              (*paVar2)(Target,buf,sVar5);
            }
          }
        }
      }
    }
    else {
      *p = (char)iVar4;
      if (p < line + 0x3ff) {
        p = p + 1;
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
  }
  mustshow = '\x01';
  src = (char *)gettext("Connection interrupted.");
  HTProgress(src);
end_CSOreport:
  if (prev_ndx != -100) {
    HTSprintf0(&buf,"</DL></DL>\n");
    paVar2 = Target->isa->put_block;
    sVar5 = strlen(buf);
    (*paVar2)(Target,buf,sVar5);
  }
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int HTLoadCSO(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  char *pcVar2;
  anon_subr_void_HTStream_ptr_char_ptr_int_for_put_block *paVar3;
  bool bVar4;
  char "</BODY>\n</HTML>\n" [17];
  HTAtom *rep_in;
  FILE *__stream;
  int iVar5;
  ssize_t sVar6;
  HTStream *Target_00;
  char *fmt;
  char *Msg;
  size_t sVar7;
  int in_GS_OFFSET;
  HTParentAnchor *local_8d0;
  int local_8c8;
  size_t local_8c4;
  char *local_8c0;
  int local_8b8;
  char *local_8b4;
  int local_8b0;
  char *local_8ac;
  char *local_8a8;
  int local_8a4;
  char *local_8a0;
  int local_89c;
  char *local_898;
  int local_894;
  int local_88c;
  char *local_888;
  size_t local_884;
  char *local_880;
  char *temp;
  HTStream *Target;
  HTFormat format_in;
  CSOfield_info *fld;
  int has_indexed;
  int return_type;
  int ndx;
  int flen;
  int finish;
  int start;
  int j;
  int i;
  int len;
  bstring *content;
  bstring *command;
  int status;
  int port;
  char *data;
  char *cp;
  char *host;
  char buf [2048];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  port = 0x69;
  command = (bstring *)0x0;
  content = (bstring *)0x0;
  rep_in = HTAtom_for("text/html");
  if (acceptable_inited == '\0') {
    init_acceptable();
  }
  if (arg == (char *)0x0) {
    local_8c8 = -3;
  }
  else {
    if (*arg == '\0') {
      local_8c8 = -2;
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTLoadCSO: Looking for %s\n",arg);
      }
      iVar5 = HTDoConnect(arg,"cso",0x69,&s);
      if (iVar5 == -0x752e) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTLoadCSO: Interrupted on connect; recovering cleanly.\n");
        }
        mustshow = '\x01';
        Msg = (char *)gettext("Connection interrupted.");
        HTProgress(Msg);
        local_8c8 = -29999;
      }
      else {
        if (iVar5 < 0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTLoadCSO: Unable to connect to remote host for `%s\'.\n",arg)
            ;
          }
          local_8c8 = HTInetStatus("connect");
        }
        else {
          HTInitInput(s);
          HTBprintf(&command,"fields%c%c",0xd,10);
          if (WWW_TraceFlag != '\0') {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTLoadCSO: Connected, writing command `");
            }
            trace_bstring(command);
            iVar5 = s;
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"\' to socket %d\n",iVar5);
            }
          }
          mustshow = '\x01';
          Msg = (char *)gettext("Sending CSO/PH request.");
          HTProgress(Msg);
          if (command == (bstring *)0x0) {
            local_8c4 = 0;
            local_8c0 = (char *)0x0;
          }
          else {
            local_8c4 = command->len;
            local_8c0 = command->str;
          }
          sVar6 = write(s,local_8c0,local_8c4);
          HTSABFree(&command);
          if (sVar6 < 0) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTLoadCSO: Unable to send command.\n");
            }
            local_8c8 = HTInetStatus("send");
          }
          else {
            mustshow = '\x01';
            Msg = (char *)gettext("CSO/PH request sent; waiting for response.");
            HTProgress(Msg);
            iVar5 = parse_cso_fields(buf,0x800);
            if (iVar5 == 0) {
              local_8d0 = anAnchor;
              Target_00 = HTStreamStack((HTFormat)rep_in,format_out,sink,anAnchor);
              if ((Target_00 == (HTStream *)0x0) || (Target_00 == (HTStream *)0x0)) {
                temp = (char *)0x0;
                Msg = format_out->name;
                pcVar2 = rep_in->name;
                fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
                HTSprintf0(&temp,fmt,pcVar2,Msg);
                HTAlert(temp);
                if (temp != (char *)0x0) {
                  free(temp);
                  temp = (char *)0x0;
                }
                close(s);
                local_8c8 = -29999;
              }
              else {
                host = HTParse(arg,"",8);
                Msg = strchr(host,0x3a);
                if ((((Msg != (char *)0x0) && ('/' < Msg[1])) && (Msg[1] < ':')) &&
                   (port = atoi(Msg + 1), port == 0x69)) {
                  *Msg = '\0';
                }
                anAnchor->safe = '\x01';
                if (((anAnchor->post_data == (bstring *)0x0) ||
                    (anAnchor->post_data == (bstring *)0x0)) || (anAnchor->post_data->len == 0)) {
                  generate_cso_form(host,port,buf,Target_00);
                  (*Target_00->isa->_free)(Target_00);
                  if (host != (char *)0x0) {
                    free(host);
                  }
                  close(s);
                  free_CSOfields();
                  local_8c8 = 200;
                }
                else {
                  HTBprintf(&command,
                            "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n"
                            ,host);
                  if (command == (bstring *)0x0) {
                    local_8b8 = 0;
                    local_8b4 = (char *)0x0;
                  }
                  else {
                    local_8b8 = command->len;
                    local_8b4 = command->str;
                  }
                  (*Target_00->isa->put_block)(Target_00,local_8b4,local_8b8);
                  HTSABFree(&command);
                  if (host != (char *)0x0) {
                    free(host);
                    host = (char *)0x0;
                  }
                  if (anAnchor->post_data == (bstring *)0x0) {
                    local_8b0 = 0;
                  }
                  else {
                    local_8b0 = anAnchor->post_data->len;
                  }
                  if (anAnchor->post_data == (bstring *)0x0) {
                    local_8ac = (char *)0x0;
                  }
                  else {
                    local_8ac = anAnchor->post_data->str;
                  }
                  HTSABCopy(&content,local_8ac,local_8b0);
                  if (content == (bstring *)0x0) {
                    local_8a8 = (char *)0x0;
                    local_8a4 = -1;
                  }
                  else {
                    local_8a8 = content->str;
                    local_8a4 = content->len + -1;
                  }
                  if (local_8a8[local_8a4] != '&') {
                    HTSABCat0(&content,"&");
                  }
                  if (content == (bstring *)0x0) {
                    local_8a0 = (char *)0x0;
                    local_89c = 0;
                  }
                  else {
                    local_8a0 = content->str;
                    local_89c = content->len;
                  }
                  i = 0;
                  while (i < local_89c) {
                    if (local_8a0[i] == '+') {
                      local_8a0[i] = ' ';
                    }
                    i = i + 1;
                  }
                  if (content == (bstring *)0x0) {
                    local_898 = (char *)0x0;
                  }
                  else {
                    local_898 = content->str;
                  }
                  HTUnEscape(local_898);
                  if (content == (bstring *)0x0) {
                    local_894 = 0;
                  }
                  else {
                    local_894 = content->len;
                  }
                  return_type = 0;
                  bVar4 = false;
                  start = 0;
                  i = 0;
                  while (i < local_894) {
                    if ((local_898[i] == '\0') || (local_898[i] == '&')) {
                      local_898[i] = '\0';
                      j = start;
                      while (j < i) {
                        if (local_898[j] == '=') {
                          if ((local_898[start + 1] == '_') &&
                             ((local_898[start] == 'r' || (local_898[start] == 'q')))) {
                            sscanf(local_898 + start + 2,"%d=",&ndx,local_8d0);
                            fld = CSOfields;
                            while (fld != (CSOfield_info *)0x0) {
                              if (fld->id == ndx) {
                                if (j + 1 < i) {
                                  if (local_898[start] == 'q') {
                                    if (fld->lookup == 0) {
                                      memcpy(buf,"Warning: non-lookup field ignored<BR>\n",0x27);
                                      paVar3 = Target_00->isa->put_block;
                                      sVar7 = strlen(buf);
                                      (*paVar3)(Target_00,buf,sVar7);
                                    }
                                    else {
                                      if (fld->indexed != 0) {
                                        bVar4 = true;
                                      }
                                      if (((command == (bstring *)0x0) ||
                                          (command == (bstring *)0x0)) || (command->len == 0)) {
                                        HTSABCopy0(&command,"query ");
                                      }
                                      else {
                                        HTSABCat0(&command," ");
                                      }
                                      local_8d0 = (HTParentAnchor *)(local_898 + j + 1);
                                      HTBprintf(&command,"%s=\"%s\"",fld->name);
                                    }
                                  }
                                  else {
                                    if (local_898[start] == 'r') {
                                      fld->explicit_return = 1;
                                    }
                                  }
                                }
                                break;
                              }
                              fld = (CSOfield_info *)fld->next;
                            }
                          }
                          else {
                            iVar5 = strncmp(local_898 + start,"return=",7);
                            if (iVar5 == 0) {
                              iVar5 = strcmp(local_898 + start + 7,"all");
                              if (iVar5 == 0) {
                                return_type = 1;
                              }
                              else {
                                iVar5 = strcmp(local_898 + start + 7,"selected");
                                if (iVar5 == 0) {
                                  return_type = 2;
                                }
                              }
                            }
                          }
                        }
                        j = j + 1;
                      }
                      start = i + 1;
                    }
                    i = i + 1;
                  }
                  HTSABFree(&content);
                  if (((command == (bstring *)0x0) || (command == (bstring *)0x0)) ||
                     ((command->len == 0 || (!bVar4)))) {
                    close(s);
                    memcpy(buf,
                           "<EM>Error:</EM> At least one indexed field value must be specified!\n",
                           0x45);
                    paVar3 = Target_00->isa->put_block;
                    sVar7 = strlen(buf);
                    (*paVar3)(Target_00,buf,sVar7);
                    memcpy(buf,"</BODY>\n</HTML>\n",0x11);
                    paVar3 = Target_00->isa->put_block;
                    sVar7 = strlen(buf);
                    (*paVar3)(Target_00,buf,sVar7);
                    (*Target_00->isa->_free)(Target_00);
                    free_CSOfields();
                    local_8c8 = 200;
                  }
                  else {
                    if (return_type == 1) {
                      HTSABCat0(&command," return all");
                    }
                    else {
                      if (return_type == 2) {
                        HTSABCat0(&command," return");
                        fld = CSOfields;
                        while (fld != (CSOfield_info *)0x0) {
                          if (fld->explicit_return != 0) {
                            HTBprintf(&command," %s",fld->name);
                          }
                          fld = (CSOfield_info *)fld->next;
                        }
                      }
                    }
                    HTBprintf(&command,"%c%c",0xd,10);
                    memcpy(buf,"<H2>\n<EM>CSO/PH command:</EM> ",0x1f);
                    paVar3 = Target_00->isa->put_block;
                    sVar7 = strlen(buf);
                    (*paVar3)(Target_00,buf,sVar7);
                    if (command == (bstring *)0x0) {
                      local_88c = 0;
                      local_888 = (char *)0x0;
                    }
                    else {
                      local_88c = command->len;
                      local_888 = command->str;
                    }
                    (*Target_00->isa->put_block)(Target_00,local_888,local_88c);
                    memcpy(buf,"</H2>\n",7);
                    paVar3 = Target_00->isa->put_block;
                    sVar7 = strlen(buf);
                    (*paVar3)(Target_00,buf,sVar7);
                    if (WWW_TraceFlag != '\0') {
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"HTLoadCSO: Writing command `");
                      }
                      trace_bstring(command);
                      iVar5 = s;
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"\' to socket %d\n",iVar5);
                      }
                    }
                    if (command == (bstring *)0x0) {
                      local_884 = 0;
                      local_880 = (char *)0x0;
                    }
                    else {
                      local_884 = command->len;
                      local_880 = command->str;
                    }
                    sVar6 = write(s,local_880,local_884);
                    HTSABFree(&command);
                    if (sVar6 < 0) {
                      if (WWW_TraceFlag != '\0') {
                        __stream = TraceFP();
                        fprintf((FILE *)__stream,"HTLoadCSO: Unable to send command.\n");
                      }
                      free_CSOfields();
                      local_8c8 = HTInetStatus("send");
                    }
                    else {
                      generate_cso_report(Target_00);
                      close(s);
                      (*Target_00->isa->put_block)(Target_00,"</BODY>\n</HTML>\n",0x10);
                      (*Target_00->isa->_free)(Target_00);
                      if (host != (char *)0x0) {
                        free(host);
                      }
                      free_CSOfields();
                      local_8c8 = 200;
                    }
                  }
                }
              }
            }
            else {
              close(s);
              if (iVar5 == -0x752e) {
                mustshow = '\x01';
                Msg = (char *)gettext("Connection interrupted.");
                HTProgress(Msg);
              }
              else {
                if (buf[0] == '\0') {
                  Msg = (char *)gettext("No response from server!");
                  HTAlert(Msg);
                }
                else {
                  HTAlert(buf);
                }
              }
              local_8c8 = -29999;
            }
          }
        }
      }
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_8c8;
}



int HTLoadGopher(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  HTStructuredClass *pHVar1;
  FILE *__stream;
  size_t __n;
  int file_number;
  char *Msg;
  char *__s;
  size_t local_54;
  ssize_t sVar2;
  HTAtom *rep_in;
  undefined *local_58;
  int local_3c;
  char *p_2;
  char *p_1;
  char *query_1;
  char *p;
  char *query;
  char *p1;
  int len;
  char *selector;
  int status;
  char *command;
  char gtype;
  
  if (acceptable_inited == '\0') {
    init_acceptable();
  }
  if (arg == (char *)0x0) {
    local_3c = -3;
  }
  else {
    if (*arg == '\0') {
      local_3c = -2;
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTGopher: Looking for %s\n",arg);
      }
      __n = strlen(arg);
      if (((int)__n < 6) || (file_number = strcmp(arg + (__n - 6),":105/2"), file_number != 0)) {
        Msg = strstr(arg,":79/0");
        if (Msg == (char *)0x0) {
          Msg = HTParse(arg,"",5);
          gtype = '1';
          selector = Msg + 1;
          if ((*Msg == '/') && (*selector != '\0')) {
            gtype = *selector;
            selector = Msg + 2;
          }
          if (gtype == '7') {
            HTAnchor_setIndex(anAnchor,anAnchor->address);
            __s = strchr(selector,0x3f);
            if ((__s == (char *)0x0) || (__s[1] == '\0')) {
              target = HTML_new(anAnchor,format_out,sink);
              pHVar1 = target->isa;
              targetClass.name = pHVar1->name;
              targetClass._free = pHVar1->_free;
              targetClass._abort = pHVar1->_abort;
              targetClass.put_character = pHVar1->put_character;
              targetClass.put_string = pHVar1->put_string;
              targetClass.put_block = pHVar1->put_block;
              targetClass.start_element = pHVar1->start_element;
              targetClass.end_element = pHVar1->end_element;
              targetClass.put_entity = pHVar1->put_entity;
              display_index(arg,anAnchor);
              return 200;
            }
            *__s = '\0';
            __s = __s + 1;
            __n = strlen(selector);
            local_54 = strlen(__s);
            command = (char *)malloc(__n + local_54 + 4);
            if (command == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
            }
            de_escape(command,selector);
            local_54 = 2;
            local_58 = &DAT_08190506;
            __n = strlen(command);
            memcpy(command + __n,local_58,local_54);
            p = __s;
            while (*p != '\0') {
              if (*p == '+') {
                *p = ' ';
              }
              p = p + 1;
            }
            __n = strlen(command);
            de_escape(command + __n,__s);
          }
          else {
            if (gtype == '2') {
              __s = strchr(selector,0x3f);
              if ((__s == (char *)0x0) || (__s[1] == '\0')) {
                target = HTML_new(anAnchor,format_out,sink);
                pHVar1 = target->isa;
                targetClass.name = pHVar1->name;
                targetClass._free = pHVar1->_free;
                targetClass._abort = pHVar1->_abort;
                targetClass.put_character = pHVar1->put_character;
                targetClass.put_string = pHVar1->put_string;
                targetClass.put_block = pHVar1->put_block;
                targetClass.start_element = pHVar1->start_element;
                targetClass.end_element = pHVar1->end_element;
                targetClass.put_entity = pHVar1->put_entity;
                display_cso(arg,anAnchor);
                return 200;
              }
              HTAnchor_setIndex(anAnchor,anAnchor->address);
              *__s = '\0';
              __s = __s + 1;
              __n = strlen(__s);
              command = (char *)malloc(__n + 9);
              if (command == (char *)0x0) {
                outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
              }
              de_escape(command,selector);
              memcpy(command,"query ",7);
              p_1 = __s;
              while (*p_1 != '\0') {
                if (*p_1 == '+') {
                  *p_1 = ' ';
                }
                p_1 = p_1 + 1;
              }
              __n = strlen(command);
              de_escape(command + __n,__s);
            }
            else {
              __n = strlen(selector);
              command = (char *)malloc(__n + 3);
              if (command == (char *)0x0) {
                outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
              }
              de_escape(command,selector);
            }
          }
          if (Msg != (char *)0x0) {
            free(Msg);
          }
          __n = strlen(command);
          Msg = command + __n;
          *Msg = '\r';
          Msg[1] = '\n';
          Msg[2] = '\0';
          file_number = HTDoConnect(arg,"gopher",0x46,&s);
          if (file_number == -0x752e) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTGopher: Interrupted on connect; recovering cleanly.\n");
            }
            mustshow = '\x01';
            Msg = (char *)gettext("Connection interrupted.");
            HTProgress(Msg);
            if (command != (char *)0x0) {
              free(command);
            }
            local_3c = -29999;
          }
          else {
            if (file_number < 0) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTGopher: Unable to connect to remote host for `%s\'.\n",
                        arg);
              }
              if (command != (char *)0x0) {
                free(command);
              }
              local_3c = HTInetStatus("connect");
            }
            else {
              HTInitInput(s);
              file_number = s;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTGopher: Connected, writing command `%s\' to socket %d\n"
                        ,command,file_number);
              }
              mustshow = '\x01';
              Msg = (char *)gettext("Sending Gopher request.");
              HTProgress(Msg);
              __n = strlen(command);
              sVar2 = write(s,command,__n);
              if (command != (char *)0x0) {
                free(command);
              }
              if (sVar2 < 0) {
                if (WWW_TraceFlag != '\0') {
                  __stream = TraceFP();
                  fprintf((FILE *)__stream,"HTGopher: Unable to send command.\n");
                }
                local_3c = HTInetStatus("send");
              }
              else {
                mustshow = '\x01';
                Msg = (char *)gettext("Gopher request sent; waiting for response.");
                HTProgress(Msg);
                file_number = s;
                switch(gtype) {
                case '0':
                  rep_in = HTAtom_for("text/plain");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                  break;
                case '1':
                case '7':
                  target = HTML_new(anAnchor,format_out,sink);
                  pHVar1 = target->isa;
                  targetClass.name = pHVar1->name;
                  targetClass._free = pHVar1->_free;
                  targetClass._abort = pHVar1->_abort;
                  targetClass.put_character = pHVar1->put_character;
                  targetClass.put_string = pHVar1->put_string;
                  targetClass.put_block = pHVar1->put_block;
                  targetClass.start_element = pHVar1->start_element;
                  targetClass.end_element = pHVar1->end_element;
                  targetClass.put_entity = pHVar1->put_entity;
                  parse_menu(arg,anAnchor);
                  break;
                case '2':
                  target = HTML_new(anAnchor,format_out,sink);
                  pHVar1 = target->isa;
                  targetClass.name = pHVar1->name;
                  targetClass._free = pHVar1->_free;
                  targetClass._abort = pHVar1->_abort;
                  targetClass.put_character = pHVar1->put_character;
                  targetClass.put_string = pHVar1->put_string;
                  targetClass.put_block = pHVar1->put_block;
                  targetClass.start_element = pHVar1->start_element;
                  targetClass.end_element = pHVar1->end_element;
                  targetClass.put_entity = pHVar1->put_entity;
                  parse_cso(arg,anAnchor);
                  break;
                default:
                  rep_in = HTAtom_for("www/unknown");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                  break;
                case ':':
                case 'I':
                case 'g':
                  rep_in = HTAtom_for("image/gif");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                  break;
                case ';':
                  rep_in = HTAtom_for("video/mpeg");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                  break;
                case '<':
                case 's':
                  rep_in = HTAtom_for("audio/basic");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                  break;
                case 'H':
                case 'h':
                  rep_in = HTAtom_for("text/html");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                  break;
                case 'P':
                  rep_in = HTAtom_for("application/pdf");
                  HTParseSocket((HTFormat)rep_in,format_out,anAnchor,file_number,sink);
                }
                close(s);
                local_3c = 200;
              }
            }
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTGopher: Passing to finger gateway.\n");
          }
          local_3c = HTLoadFinger(arg,anAnchor,format_out,sink);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTGopher: Passing to CSO/PH gateway.\n");
        }
        local_3c = HTLoadCSO(arg,anAnchor,format_out,sink);
      }
    }
  }
  return local_3c;
}



void do_system(char *command)

{
  FILE *__stream;
  
  if ((command != (char *)0x0) && (*command != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTTelnet: Command is: %s\n\n",command);
    }
    LYSystem(command);
    if (command != (char *)0x0) {
      free(command);
    }
  }
  return;
}



int remote_session(char *acc_method,char *host)

{
  BOOLEAN BVar1;
  int iVar2;
  char *parameter;
  ushort **ppuVar3;
  FILE *__stream;
  int local_48;
  int local_44;
  char *local_40;
  char *local_38;
  char *line;
  char *prefix;
  _login_protocol login_protocol;
  char *command;
  char *port;
  char *hostname;
  char *cp;
  char *password;
  char *user;
  char *program;
  
  user = host;
  password = (char *)0x0;
  command = (char *)0x0;
  iVar2 = strcmp(acc_method,"rlogin");
  if (iVar2 == 0) {
    local_48 = 1;
  }
  else {
    iVar2 = strcmp(acc_method,"tn3270");
    if (iVar2 == 0) {
      local_44 = 2;
    }
    else {
      local_44 = 0;
    }
    local_48 = local_44;
  }
  parameter = strchr(host,0x40);
  if (parameter == (char *)0x0) {
    local_40 = host;
  }
  else {
    local_40 = strchr(host,0x40);
  }
  cp = local_40;
  do {
    if (*cp == '\0') {
LAB_081420ca:
      hostname = strchr(host,0x40);
      if (hostname == (char *)0x0) {
        hostname = host;
        user = (char *)0x0;
      }
      else {
        *hostname = '\0';
        hostname = hostname + 1;
      }
      port = strchr(hostname,0x3a);
      if (port != (char *)0x0) {
        *port = '\0';
        port = port + 1;
      }
      if ((hostname == (char *)0x0) || (*hostname == '\0')) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTTelnet: No host specified!\n");
        }
      }
      else {
        BVar1 = valid_hostname(hostname);
        if (BVar1 == '\0') {
          prefix = (char *)0x0;
          line = (char *)0x0;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTTelnet: Invalid hostname %s!\n",host);
          }
          parameter = (char *)gettext("remote %s session:");
          HTSprintf0(&prefix,parameter,acc_method);
          parameter = (char *)gettext("Invalid hostname %s");
          HTSprintf0(&line,parameter,host);
          HTAlwaysAlert(prefix,line);
          if (prefix != (char *)0x0) {
            free(prefix);
            prefix = (char *)0x0;
          }
          if (line != (char *)0x0) {
            free(line);
          }
        }
        else {
          if ((user != (char *)0x0) && (password = strchr(user,0x3a), password != (char *)0x0)) {
            *password = '\0';
            password = password + 1;
          }
          if (HTSecure == '\0') {
            if ((user != (char *)0x0) && (local_48 != 1)) {
              printf("When you are connected, log in as:  %s\n",user);
            }
            if ((password != (char *)0x0) && (local_48 != 1)) {
              printf("                  The password is:  %s\n",password);
            }
            fflush(stdout);
            if (local_48 == 1) {
              parameter = HTGetProgramPath(ppRLOGIN);
              if (parameter != (char *)0x0) {
                HTAddParam(&command,"%s %s%s%s",1,parameter);
                HTAddParam(&command,"%s %s%s%s",2,hostname);
                if (user == (char *)0x0) {
                  local_38 = "";
                }
                else {
                  local_38 = " -l ";
                }
                HTSACat(&command,local_38);
                HTAddParam(&command,"%s %s%s%s",4,user);
                HTEndParam(&command,"%s %s%s%s",4);
              }
            }
            else {
              if (local_48 == 0) {
                parameter = HTGetProgramPath(ppTELNET);
                if (parameter != (char *)0x0) {
                  HTAddParam(&command,"%s %s %s",1,parameter);
                  HTAddParam(&command,"%s %s %s",2,hostname);
                  HTAddParam(&command,"%s %s %s",3,port);
                  HTEndParam(&command,"%s %s %s",3);
                }
              }
              else {
                if ((local_48 == 2) &&
                   (parameter = HTGetProgramPath(ppTN3270), parameter != (char *)0x0)) {
                  HTAddParam(&command,"%s %s %s",1,parameter);
                  HTAddParam(&command,"%s %s %s",2,hostname);
                  HTAddParam(&command,"%s %s %s",3,port);
                  HTEndParam(&command,"%s %s %s",3);
                }
              }
            }
            LYSystem(command);
          }
          else {
            puts("\n\nSorry, but the service you have selected is one");
            puts("to which you have to log in.  If you were running www");
            puts("on your own computer, you would be automatically connected.");
            puts("For security reasons, this is not allowed when");
            puts("you log in to this information service remotely.\n");
            printf("You can manually connect to this service using %s\n",acc_method);
            printf("to host %s",hostname);
            if (user != (char *)0x0) {
              printf(", user name %s",user);
            }
            if (password != (char *)0x0) {
              printf(", password %s",password);
            }
            if (port != (char *)0x0) {
              printf(", port %s",port);
            }
            puts(".\n");
          }
        }
      }
      return -0xcc;
    }
    ppuVar3 = __ctype_b_loc();
    if (((((((*ppuVar3)[(byte)*cp] & 8) == 0) && (*cp != '_')) && (*cp != '-')) &&
        ((*cp != ':' && (*cp != '.')))) && (*cp != '@')) {
      *cp = '\0';
      goto LAB_081420ca;
    }
    cp = cp + 1;
  } while( true );
}



int HTLoadTelnet(char *addr,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  FILE *__stream;
  char *acc_method_00;
  char *host_00;
  int local_18;
  int status;
  char *host;
  char *acc_method;
  
  if (sink == (HTStream *)0x0) {
    acc_method_00 = HTParse(addr,"file:",0x10);
    host_00 = HTParse(addr,"",8);
    if ((host_00 == (char *)0x0) || (*host_00 == '\0')) {
      status = -0xcc;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTTelnet: No host specified!\n");
      }
    }
    else {
      status = remote_session(acc_method_00,host_00);
    }
    if (host_00 != (char *)0x0) {
      free(host_00);
    }
    if (acc_method_00 != (char *)0x0) {
      free(acc_method_00);
    }
    local_18 = status;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTTelnet: Can\'t output a live session -- must be interactive!\n");
    }
    local_18 = -0xcc;
  }
  return local_18;
}



BOOLEAN initialize(void)

{
  finger_fd = -1;
  return '\x01';
}



void start_anchor(char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  while (i < 0x19) {
    *(bool *)(present + i) = i == 6;
    i = i + 1;
  }
  value[6] = href;
  (*targetClass.start_element)(target,0,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int response(char *command,char *sitename,HTParentAnchor *anAnchor,HTFormat format_out,
            HTStream *sink)

{
  char cVar1;
  HTStructuredClass *pHVar2;
  size_t __n;
  FILE *__stream;
  char *href_00;
  int iVar3;
  int in_GS_OFFSET;
  ssize_t local_44c;
  char *href;
  char *p;
  char *cmd;
  char *l;
  int i;
  int ch;
  int length;
  int status;
  char line [1024];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  __n = strlen(command);
  cmd = (char *)0x0;
  p = line;
  href = (char *)0x0;
  if (__n == 0) {
    local_44c = -1;
  }
  else {
    HTInitInput(finger_fd);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFinger command to be sent: %s",command);
    }
    local_44c = write(finger_fd,command,__n);
    if (local_44c < 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFinger: Unable to send command. Disconnecting.\n");
      }
      close(finger_fd);
      finger_fd = -1;
    }
    else {
      target = HTML_new(anAnchor,format_out,sink);
      pHVar2 = target->isa;
      targetClass.name = pHVar2->name;
      targetClass._free = pHVar2->_free;
      targetClass._abort = pHVar2->_abort;
      targetClass.put_character = pHVar2->put_character;
      targetClass.put_string = pHVar2->put_string;
      targetClass.put_block = pHVar2->put_block;
      targetClass.start_element = pHVar2->start_element;
      targetClass.end_element = pHVar2->end_element;
      targetClass.put_entity = pHVar2->put_entity;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFinger: Reading finger information\n");
      }
      (*targetClass.start_element)(target,0x37,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Finger server on ");
      (*targetClass.put_string)(target,sitename);
      (*targetClass.end_element)(target,0x6e,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x35,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x11,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Finger server on ");
      (*targetClass.start_element)(target,0x26,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,sitename);
      (*targetClass.end_element)(target,0x26,(char **)0x0);
      (*targetClass.put_string)(target,": ");
      if (command == (char *)0x0) {
        HTSACopy(&cmd,"");
      }
      else {
        HTSACopy(&cmd,command);
      }
      i = strlen(cmd);
      while ((i = i - 1, -1 < i && ((cmd[i] == '\n' || (cmd[i] == '\r'))))) {
        cmd[i] = '\0';
      }
      (*targetClass.put_string)(target,cmd);
      if (cmd != (char *)0x0) {
        free(cmd);
        cmd = (char *)0x0;
      }
      (*targetClass.end_element)(target,0x2f,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      while( true ) {
        iVar3 = HTGetCharacter();
        if (iVar3 == -1) break;
        if (interrupted_in_htgetcharacter != 0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFinger: Interrupted in HTGetCharacter, apparently.\n");
          }
          mustshow = '\x01';
          href_00 = (char *)gettext("Connection interrupted.");
          HTProgress(href_00);
          goto end_html;
        }
        if (iVar3 == 10) {
          *p = '\0';
          p = line;
          l = p;
LAB_0814314c:
          if (*l != '\0') {
            iVar3 = strncmp(l,"news:",5);
            if (iVar3 != 0) {
              iVar3 = strncmp(l,"snews://",8);
              if (iVar3 != 0) {
                iVar3 = strncmp(l,"nntp://",7);
                if (iVar3 != 0) {
                  iVar3 = strncmp(l,"snewspost:",10);
                  if (iVar3 != 0) {
                    iVar3 = strncmp(l,"snewsreply:",0xb);
                    if (iVar3 != 0) {
                      iVar3 = strncmp(l,"newspost:",9);
                      if (iVar3 != 0) {
                        iVar3 = strncmp(l,"newsreply:",10);
                        if (iVar3 != 0) {
                          iVar3 = strncmp(l,"ftp://",6);
                          if (iVar3 != 0) {
                            iVar3 = strncmp(l,"file:/",6);
                            if (iVar3 != 0) {
                              iVar3 = strncmp(l,"finger://",9);
                              if (iVar3 != 0) {
                                iVar3 = strncmp(l,"http://",7);
                                if (iVar3 != 0) {
                                  iVar3 = strncmp(l,"https://",8);
                                  if (iVar3 != 0) {
                                    iVar3 = strncmp(l,"wais://",7);
                                    if (iVar3 != 0) {
                                      iVar3 = strncmp(l,"mailto:",7);
                                      if (iVar3 != 0) {
                                        iVar3 = strncmp(l,"cso://",6);
                                        if (iVar3 != 0) {
                                          iVar3 = strncmp(l,"gopher://",9);
                                          if (iVar3 != 0) {
                                            cVar1 = *l;
                                            l = l + 1;
                                            (*targetClass.put_character)(target,cVar1);
                                            goto LAB_0814314c;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            HTSACopy(&href,l);
            href_00 = strtok(href," \r\n\t,>)\"");
            start_anchor(href_00);
            while (*l != '\0') {
              href_00 = strchr(" \r\n\t,>)\"",(int)*l);
              if (href_00 != (char *)0x0) break;
              cVar1 = *l;
              l = l + 1;
              (*targetClass.put_character)(target,cVar1);
            }
            (*targetClass.end_element)(target,0,(char **)0x0);
            if (href != (char *)0x0) {
              free(href);
              href = (char *)0x0;
            }
            goto LAB_0814314c;
          }
          (*targetClass.put_character)(target,'\n');
        }
        else {
          *p = (char)iVar3;
          if (p < line + 0x3ff) {
            p = p + 1;
          }
        }
      }
      close(finger_fd);
      finger_fd = -1;
end_html:
      (*targetClass.end_element)(target,0x56,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x11,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x37,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass._free)(target);
      local_44c = 0;
    }
  }
  if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_44c;
}



int HTLoadFinger(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *stream)

{
  bool bVar1;
  FILE *__stream;
  int local_64;
  char *Msg;
  int iVar2;
  char *local_50;
  int local_4c;
  char *p1;
  int result;
  int status;
  int port;
  char *param;
  char *str;
  char *command;
  char *at_sign;
  char *slash;
  char *colon;
  char *sitename;
  char *username;
  BOOLEAN IsGopherURL;
  
  result = 200;
  bVar1 = false;
  p1 = arg;
  if (WWW_TraceFlag != '\0') {
    if (arg == (char *)0x0) {
      local_50 = "NULL";
    }
    else {
      local_50 = arg;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFinger: Looking for %s\n",local_50);
  }
  if ((arg == (char *)0x0) || (*arg == '\0')) {
    Msg = (char *)gettext("Could not load data.");
    HTAlert(Msg);
    local_4c = -29999;
  }
  else {
    if (initialized == '\0') {
      initialized = initialize();
    }
    if (initialized == '\0') {
      Msg = (char *)gettext("Could not set up finger connection.");
      HTAlert(Msg);
      local_4c = -29999;
    }
    else {
      local_64 = strncasecomp(arg,"finger://",9);
      if (local_64 == 0) {
        p1 = arg + 9;
      }
      else {
        local_64 = strncasecomp(arg,"gopher://",9);
        if (local_64 == 0) {
          p1 = arg + 9;
          bVar1 = true;
        }
      }
      param = (char *)0x0;
      username = HTSACopy(&param,p1);
      if (param == (char *)0x0) {
        Msg = (char *)gettext("Could not load data.");
        HTAlert(Msg);
        local_4c = -29999;
      }
      else {
        Msg = strchr(username,0x2f);
        slash = Msg;
        if (Msg != (char *)0x0) {
          *Msg = '\0';
          slash = Msg + 1;
          HTUnEscape(slash);
          if (bVar1) {
            if (*slash != '0') {
              Msg = (char *)gettext("Could not load data.");
              HTAlert(Msg);
              return -29999;
            }
            *slash = '\0';
            slash = Msg + 2;
          }
        }
        at_sign = strchr(username,0x40);
        if (at_sign == (char *)0x0) {
          sitename = username;
          if (slash == (char *)0x0) {
            username = "";
          }
          else {
            username = slash;
          }
        }
        else {
          if (bVar1) {
            Msg = (char *)gettext("Could not load data.");
            HTAlert(Msg);
            return -29999;
          }
          *at_sign = '\0';
          at_sign = at_sign + 1;
          HTUnEscape(username);
          sitename = at_sign;
        }
        if (*sitename == '\0') {
          Msg = (char *)gettext("Could not load data (no sitename in finger URL)");
          HTAlert(Msg);
          result = -29999;
        }
        else {
          Msg = strchr(sitename,0x3a);
          if (Msg != (char *)0x0) {
            *Msg = '\0';
            local_64 = atoi(Msg + 1);
            if (local_64 != 0x4f) {
              Msg = (char *)gettext("Invalid port number - will only use port 79!");
              HTAlert(Msg);
              result = -29999;
            }
          }
        }
        if (result == 200) {
          str = (char *)0x0;
          HTSprintf0(&str,"lose://%s/",sitename);
          command = (char *)0x0;
          if ((at_sign == (char *)0x0) || (slash == (char *)0x0)) {
            if (at_sign == (char *)0x0) {
              if (*username == '/') {
                Msg = strchr(username + 1,0x2f);
                if (Msg != (char *)0x0) {
                  *Msg = ' ';
                }
                HTSprintf0(&command,"%s%c%c",username,0xd,10);
              }
              else {
                if (((*username == 'w') || (*username == 'W')) && (username[1] == '/')) {
                  if (*username == -2) {
                    username[1] = '\0';
                  }
                  else {
                    username[1] = ' ';
                  }
                  HTSprintf0(&command,"/%s%c%c",username,0xd,10);
                }
                else {
                  if (((*username == 'w') || (*username == 'W')) && (username[1] == '\0')) {
                    HTSprintf0(&command,"/%s%c%c",username,0xd,10);
                  }
                  else {
                    Msg = strchr(username,0x2f);
                    if (Msg == (char *)0x0) {
                      HTSprintf0(&command,"%s%c%c",username,0xd,10);
                    }
                    else {
                      *Msg = '\0';
                      if ((Msg[1] == 'w') || (Msg[1] == 'W')) {
                        HTSprintf0(&command,"/w %s%c%c",username,0xd,10);
                      }
                      else {
                        HTSprintf0(&command,"%s%c%c",username,0xd,10);
                      }
                    }
                  }
                }
              }
            }
            else {
              HTSprintf0(&command,"%s%c%c",username,0xd,10);
            }
          }
          else {
            if ((*slash == 'w') || (*slash == 'W')) {
              HTSprintf0(&command,"/w %s%c%c",username,0xd,10);
            }
            else {
              HTSprintf0(&command,"%s%c%c",username,0xd,10);
            }
          }
          Msg = str;
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"HTFinger: doing HTDoConnect on \'%s\'\n",Msg);
          }
          local_64 = 0x4f;
          iVar2 = HTDoConnect(str,"finger",0x4f,&finger_fd);
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            local_64 = iVar2;
            fprintf((FILE *)__stream,"HTFinger: Done DoConnect; status %d\n",iVar2);
          }
          Msg = str;
          if (iVar2 == -0x752e) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"HTFinger: Interrupted on connect; recovering cleanly.\n",
                      local_64);
            }
            Msg = (char *)gettext("Connection interrupted.");
            HTProgress(Msg);
            result = -29999;
          }
          else {
            if (iVar2 < 0) {
              close(finger_fd);
              finger_fd = -1;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTFinger: Unable to connect to finger host.\n",local_64);
              }
              Msg = (char *)gettext("Could not access finger host.");
              HTAlert(Msg);
              result = -29999;
            }
            else {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"HTFinger: Connected to finger host \'%s\'.\n",Msg);
              }
              local_64 = response(command,sitename,anAnchor,format_out,stream);
              if (local_64 != 0) {
                Msg = (char *)gettext("No response from finger server.");
                HTAlert(Msg);
                result = -29999;
              }
            }
          }
          if (str != (char *)0x0) {
            free(str);
            str = (char *)0x0;
          }
          if (command != (char *)0x0) {
            free(command);
            command = (char *)0x0;
          }
        }
        if (param != (char *)0x0) {
          free(param);
        }
        local_4c = result;
      }
    }
  }
  return local_4c;
}



char from_hex(char c)

{
  char local_b;
  char local_a;
  char local_9;
  
  if ((c < '0') || ('9' < c)) {
    if ((c < 'A') || ('F' < c)) {
      if ((c < 'a') || ('f' < c)) {
        local_9 = '\0';
      }
      else {
        local_9 = c + -0x57;
      }
      local_a = local_9;
    }
    else {
      local_a = c + -0x37;
    }
    local_b = local_a;
  }
  else {
    local_b = c + -0x30;
  }
  return local_b;
}



void WSRCParser_put_character(HTStream *me,char c)

{
  HTStreamClass *pHVar1;
  int iVar2;
  FILE *__stream;
  HTStreamClass *local_14;
  HTStreamClass *local_10;
  
  switch(me[0x19].isa) {
  case (HTStreamClass *)0x0:
    if (c == '(') {
      me[0x19].isa = (HTStreamClass *)0x1;
    }
    break;
  case (HTStreamClass *)0x1:
    if (c == ')') {
      me[0x19].isa = (HTStreamClass *)0x8;
    }
    else {
      if (c == ':') {
        me[0x9e0].isa = (HTStreamClass *)0x0;
        me[0x19].isa = (HTStreamClass *)0x2;
      }
    }
    break;
  case (HTStreamClass *)0x2:
    if ((byte)c < 0x21) {
      pHVar1 = me[0x9e0].isa;
      *(undefined *)((int)&me[0x1a].isa + (int)pHVar1) = 0;
      me[0x9e0].isa = (HTStreamClass *)((int)&pHVar1->name + 1);
      me[0x9df].isa = (HTStreamClass *)0x0;
      while ((par_name[(int)me[0x9df].isa] != (char *)0x0 &&
             (iVar2 = strcmp(par_name[(int)me[0x9df].isa],(char *)(me + 0x1a)), iVar2 != 0))) {
        me[0x9df].isa = (HTStreamClass *)((int)&(me[0x9df].isa)->name + 1);
      }
      if (par_name[(int)me[0x9df].isa] == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTWSRC: Unknown field `%s\' in source file\n",me + 0x1a);
        }
        me[0x9df].isa = (HTStreamClass *)0x16;
        me[0x19].isa = (HTStreamClass *)0x3;
      }
      else {
        me[0x19].isa = (HTStreamClass *)0x3;
      }
    }
    else {
      if ((int)me[0x9e0].isa < 10000) {
        pHVar1 = me[0x9e0].isa;
        *(char *)((int)&me[0x1a].isa + (int)pHVar1) = c;
        me[0x9e0].isa = (HTStreamClass *)((int)&pHVar1->name + 1);
      }
    }
    break;
  case (HTStreamClass *)0x3:
    if (c == ')') {
      me[0x19].isa = (HTStreamClass *)0x8;
    }
    else {
      if (0x20 < (byte)c) {
        me[0x9e0].isa = (HTStreamClass *)0x0;
        if (c == '\"') {
          me[0x19].isa = (HTStreamClass *)0x6;
        }
        else {
          if (c == '\"') {
            local_14 = (HTStreamClass *)0x6;
          }
          else {
            if (c == '(') {
              local_10 = (HTStreamClass *)0x5;
            }
            else {
              local_10 = (HTStreamClass *)0x4;
            }
            local_14 = local_10;
          }
          me[0x19].isa = local_14;
          pHVar1 = me[0x9e0].isa;
          *(char *)((int)&me[0x1a].isa + (int)pHVar1) = c;
          me[0x9e0].isa = (HTStreamClass *)((int)&pHVar1->name + 1);
        }
      }
    }
    break;
  case (HTStreamClass *)0x4:
    if ((byte)c < 0x21) {
      *(undefined *)((int)&me[0x1a].isa + (int)me[0x9e0].isa) = 0;
      HTSACopy((char **)(me + (int)&(me[0x9df].isa)->name + 2),(char *)(me + 0x1a));
      me[0x19].isa = (HTStreamClass *)0x1;
    }
    else {
      if ((int)me[0x9e0].isa < 10000) {
        pHVar1 = me[0x9e0].isa;
        *(char *)((int)&me[0x1a].isa + (int)pHVar1) = c;
        me[0x9e0].isa = (HTStreamClass *)((int)&pHVar1->name + 1);
      }
    }
    break;
  case (HTStreamClass *)0x5:
    if (c == ')') {
      *(undefined *)((int)&me[0x1a].isa + (int)me[0x9e0].isa) = 0;
      HTSACopy((char **)(me + (int)&(me[0x9df].isa)->name + 2),(char *)(me + 0x1a));
      me[0x19].isa = (HTStreamClass *)0x1;
    }
    else {
      if ((int)me[0x9e0].isa < 10000) {
        pHVar1 = me[0x9e0].isa;
        *(char *)((int)&me[0x1a].isa + (int)pHVar1) = c;
        me[0x9e0].isa = (HTStreamClass *)((int)&pHVar1->name + 1);
      }
    }
    break;
  case (HTStreamClass *)0x6:
    if (c == '\"') {
      *(undefined *)((int)&me[0x1a].isa + (int)me[0x9e0].isa) = 0;
      HTSACopy((char **)(me + (int)&(me[0x9df].isa)->name + 2),(char *)(me + 0x1a));
      me[0x19].isa = (HTStreamClass *)0x1;
      return;
    }
    if (c == '\\') {
      me[0x19].isa = (HTStreamClass *)0x7;
      return;
    }
  case (HTStreamClass *)0x7:
    if ((int)me[0x9e0].isa < 10000) {
      pHVar1 = me[0x9e0].isa;
      *(char *)((int)&me[0x1a].isa + (int)pHVar1) = c;
      me[0x9e0].isa = (HTStreamClass *)((int)&pHVar1->name + 1);
    }
    me[0x19].isa = (HTStreamClass *)0x6;
  }
  return;
}



void give_parameter(HTStream *me,int p)

{
  code *pcVar1;
  undefined4 uVar2;
  
  (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,par_name[p]);
  if (me[p + 2].isa == (HTStreamClass *)0x0) {
    pcVar1 = *(code **)((me[1].isa)->name + 0x10);
    uVar2 = gettext(" NOT GIVEN in source file; ");
    (*pcVar1)(me[1].isa,uVar2);
  }
  else {
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,&DAT_08190eec);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,me[p + 2].isa);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,&DAT_08190eef);
  }
  return;
}



void WSRC_gen_html(HTStream *me,BOOLEAN source_file)

{
  code *pcVar1;
  size_t sVar2;
  int iVar3;
  undefined4 uVar4;
  char *__ptr;
  undefined4 local_30;
  undefined4 local_28;
  HTStreamClass *local_24;
  undefined *local_20;
  char *www_database;
  char *shortname;
  int l;
  
  if (me[6].isa != (HTStreamClass *)0x0) {
    shortname = (char *)0x0;
    HTSACopy(&shortname,(char *)me[6].isa);
    sVar2 = strlen(shortname);
    if (4 < (int)sVar2) {
      iVar3 = strcasecomp(shortname + (sVar2 - 4),".src");
      if (iVar3 == 0) {
        shortname[sVar2 - 4] = '\0';
      }
    }
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x35,0,0,0xffffffff,0);
    (**(code **)((me[1].isa)->name + 0xc))(me[1].isa,10);
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x6e,0,0,0xffffffff,0);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,shortname);
    pcVar1 = *(code **)((me[1].isa)->name + 0x10);
    if (source_file == '\0') {
      local_30 = gettext(" index");
    }
    else {
      local_30 = gettext(" WAIS source file");
    }
    (*pcVar1)(me[1].isa,local_30);
    (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x6e,0);
    (**(code **)((me[1].isa)->name + 0xc))(me[1].isa,10);
    (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x35,0);
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x2f,0,0,0xffffffff,0);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,shortname);
    pcVar1 = *(code **)((me[1].isa)->name + 0x10);
    if (source_file == '\0') {
      local_28 = gettext(" index");
    }
    else {
      local_28 = gettext(" description");
    }
    (*pcVar1)(me[1].isa,local_28);
    (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x2f,0);
    (**(code **)((me[1].isa)->name + 0xc))(me[1].isa,10);
    if (shortname != (char *)0x0) {
      free(shortname);
      shortname = (char *)0x0;
    }
  }
  (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x23,0,0,0xffffffff,0);
  if (source_file != '\0') {
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x25,0,0,0xffffffff,0);
    pcVar1 = *(code **)((me[1].isa)->name + 0x10);
    uVar4 = gettext("Access links");
    (*pcVar1)(me[1].isa,uVar4);
    if (tags[37].contents != SGML_EMPTY) {
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x25,0);
    }
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x1e,0,0,0xffffffff,0);
    if ((me[4].isa == (HTStreamClass *)0x0) || (me[6].isa == (HTStreamClass *)0x0)) {
      give_parameter(me,2);
      give_parameter(me,4);
    }
    else {
      shortname = (char *)0x0;
      __ptr = HTEscape((char *)me[6].isa,'\x01');
      if (me[5].isa == (HTStreamClass *)0x0) {
        local_24 = (HTStreamClass *)&DAT_08190f46;
      }
      else {
        local_24 = me[5].isa;
      }
      if (me[5].isa == (HTStreamClass *)0x0) {
        local_20 = &DAT_08190f46;
      }
      else {
        local_20 = &DAT_08190f47;
      }
      HTSprintf0(&shortname,"%s//%s%s%s/%s","wais:",me[4].isa,local_20,local_24,__ptr);
      HTStartAnchor((HTStructured *)me[1].isa,(char *)0x0,shortname);
      pcVar1 = *(code **)((me[1].isa)->name + 0x10);
      uVar4 = gettext("Direct access");
      (*pcVar1)(me[1].isa,uVar4);
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0,0);
      pcVar1 = *(code **)((me[1].isa)->name + 0x10);
      uVar4 = gettext(" (or via proxy server, if defined)");
      (*pcVar1)(me[1].isa,uVar4);
      if (__ptr != (char *)0x0) {
        free(__ptr);
      }
      if (shortname != (char *)0x0) {
        free(shortname);
        shortname = (char *)0x0;
      }
    }
    if (tags[30].contents != SGML_EMPTY) {
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x1e,0);
    }
  }
  if (me[10].isa != (HTStreamClass *)0x0) {
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x25,0,0,0xffffffff,0);
    pcVar1 = *(code **)((me[1].isa)->name + 0x10);
    uVar4 = gettext("Maintainer");
    (*pcVar1)(me[1].isa,uVar4);
    if (tags[37].contents != SGML_EMPTY) {
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x25,0);
    }
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x1e,0,0,0xffffffff,0);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,me[10].isa);
    if (tags[30].contents != SGML_EMPTY) {
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x1e,0);
    }
  }
  if (me[4].isa != (HTStreamClass *)0x0) {
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x25,0,0,0xffffffff,0);
    pcVar1 = *(code **)((me[1].isa)->name + 0x10);
    uVar4 = gettext(&DAT_08190f9a);
    (*pcVar1)(me[1].isa,uVar4);
    if (tags[37].contents != SGML_EMPTY) {
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x25,0);
    }
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x1e,0,0,0xffffffff,0);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,me[4].isa);
    if (tags[30].contents != SGML_EMPTY) {
      (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x1e,0);
    }
  }
  (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x23,0);
  if (me[0xb].isa != (HTStreamClass *)0x0) {
    (**(code **)((me[1].isa)->name + 0x18))(me[1].isa,0x56,0,0,0xffffffff,0);
    (**(code **)((me[1].isa)->name + 0x10))(me[1].isa,me[0xb].isa);
    (**(code **)((me[1].isa)->name + 0x1c))(me[1].isa,0x56,0);
  }
  (**(code **)((me[1].isa)->name + 4))(me[1].isa);
  return;
}



void WSRCParser_put_string(HTStream *context,char *str)

{
  char *p;
  
  p = str;
  while (*p != '\0') {
    WSRCParser_put_character(context,*p);
    p = p + 1;
  }
  return;
}



void WSRCParser_write(HTStream *context,char *str,int l)

{
  char *e;
  char *p;
  
  p = str;
  while (p < str + l) {
    WSRCParser_put_character(context,*p);
    p = p + 1;
  }
  return;
}



void WSRCParser_free(HTStream *me)

{
  int p;
  
  WSRC_gen_html(me,'\x01');
  p = 0;
  while (par_name[p] != (char *)0x0) {
    if (me[p + 2].isa != (HTStreamClass *)0x0) {
      free(me[p + 2].isa);
      me[p + 2].isa = (HTStreamClass *)0x0;
    }
    p = p + 1;
  }
  if (me != (HTStream *)0x0) {
    free(me);
  }
  return;
}



void WSRCParser_abort(HTStream *me,HTError e)

{
  WSRCParser_free(me);
  return;
}



HTStream * HTWSRCConvert(HTPresentation *pres,HTParentAnchor *anchor,HTStream *sink)

{
  HTStream *pHVar1;
  HTStructured *pHVar2;
  int p;
  HTStream *me;
  
  pHVar1 = (HTStream *)malloc(0x2784);
  if (pHVar1 == (HTStream *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTWSRC.c","HTWSRCConvert");
  }
  pHVar1->isa = (HTStreamClass *)0x81aa3a0;
  pHVar2 = HTML_new(anchor,(HTFormat)pres->rep_out,sink);
  *(HTStructured **)&pHVar1[1].isa = pHVar2;
  p = 0;
  while (p < 0x17) {
    pHVar1[p + 2].isa = (HTStreamClass *)0x0;
    p = p + 1;
  }
  pHVar1[0x19].isa = (HTStreamClass *)0x0;
  return pHVar1;
}



void HTAAForwardAuth_set(char *scheme_name,char *scheme_specifics)

{
  size_t sVar1;
  int local_1c;
  size_t local_18;
  int len;
  
  if (scheme_name == (char *)0x0) {
    local_1c = 0x14;
  }
  else {
    sVar1 = strlen(scheme_name);
    local_1c = sVar1 + 0x14;
  }
  if (scheme_specifics == (char *)0x0) {
    local_18 = 0;
  }
  else {
    local_18 = strlen(scheme_specifics);
  }
  if (HTAAForwardAuth != (char *)0x0) {
    free(HTAAForwardAuth);
    HTAAForwardAuth = (char *)0x0;
  }
  HTAAForwardAuth = (char *)calloc(local_1c + local_18,1);
  if (HTAAForwardAuth == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAAForwardAuth_set");
  }
  memcpy(HTAAForwardAuth,"Authorization: ",0x10);
  if (scheme_name != (char *)0x0) {
    strcat(HTAAForwardAuth,scheme_name);
    strcat(HTAAForwardAuth," ");
    if (scheme_specifics != (char *)0x0) {
      strcat(HTAAForwardAuth,scheme_specifics);
    }
  }
  return;
}



void HTAAForwardAuth_reset(void)

{
  if (HTAAForwardAuth != (char *)0x0) {
    free(HTAAForwardAuth);
    HTAAForwardAuth = (char *)0x0;
  }
  return;
}



HTAAServer * HTAAServer_new(char *hostname,int portnumber,BOOLEAN IsProxy)

{
  HTAAServer *newObject;
  HTList *pHVar1;
  int local_1c;
  HTAAServer *server;
  
  newObject = (HTAAServer *)calloc(1,0x14);
  if (newObject == (HTAAServer *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAAServer_new");
  }
  newObject->hostname = (char *)0x0;
  if (portnumber < 1) {
    local_1c = 0x50;
  }
  else {
    local_1c = portnumber;
  }
  newObject->portnumber = local_1c;
  newObject->IsProxy = IsProxy;
  pHVar1 = HTList_new();
  newObject->setups = pHVar1;
  pHVar1 = HTList_new();
  newObject->realms = pHVar1;
  if (hostname != (char *)0x0) {
    HTSACopy((char **)newObject,hostname);
  }
  if (server_table == (HTList *)0x0) {
    server_table = HTList_new();
  }
  HTList_addObject(server_table,newObject);
  return newObject;
}



void HTAAServer_delete(HTAAServer *killme)

{
  HTAASetup *killme_00;
  void **local_28;
  HTList *cur;
  HTAARealm *realm;
  HTAASetup *setup;
  int i;
  int n;
  
  if (killme != (HTAAServer *)0x0) {
    if (killme->setups != (HTList *)0x0) {
      i = HTList_count(killme->setups);
      while (i = i + -1, -1 < i) {
        killme_00 = (HTAASetup *)HTList_objectAt(killme->setups,i);
        if (killme_00 != (HTAASetup *)0x0) {
          HTAASetup_delete(killme_00);
        }
      }
      HTList_delete(killme->setups);
      killme->setups = (HTList *)0x0;
    }
    cur = killme->realms;
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_28 = (void **)0x0;
      }
      else {
        local_28 = (void **)cur->object;
      }
      if (local_28 == (void **)0x0) break;
      if (*local_28 != (void *)0x0) {
        free(*local_28);
        *local_28 = (void *)0x0;
      }
      if (local_28[1] != (void *)0x0) {
        free(local_28[1]);
        local_28[1] = (void *)0x0;
      }
      if (local_28[2] != (void *)0x0) {
        free(local_28[2]);
        local_28[2] = (void *)0x0;
      }
      if (local_28 != (void **)0x0) {
        free(local_28);
      }
    }
    HTList_delete(killme->realms);
    killme->realms = (HTList *)0x0;
    if (killme->hostname != (char *)0x0) {
      free(killme->hostname);
      killme->hostname = (char *)0x0;
    }
    HTList_removeObject(server_table,killme);
    if (killme != (HTAAServer *)0x0) {
      free(killme);
    }
  }
  return;
}



HTAAServer * HTAAServer_lookup(char *hostname,int portnumber,BOOLEAN IsProxy)

{
  int iVar1;
  HTAAServer *local_20;
  HTAAServer *local_1c;
  HTAAServer *server;
  HTList *cur;
  
  if (hostname == (char *)0x0) {
LAB_08144e03:
    local_20 = (HTAAServer *)0x0;
  }
  else {
    cur = server_table;
    if (portnumber < 1) {
      portnumber = 0x50;
    }
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_1c = (HTAAServer *)0x0;
      }
      else {
        local_1c = (HTAAServer *)cur->object;
      }
      local_20 = local_1c;
      if (local_1c == (HTAAServer *)0x0) goto LAB_08144e03;
    } while (((local_1c->portnumber != portnumber) ||
             (iVar1 = strcmp(local_1c->hostname,hostname), iVar1 != 0)) ||
            (local_1c->IsProxy != IsProxy));
  }
  return local_20;
}



HTAASetup * HTAASetup_lookup(char *hostname,int portnumber,char *docname,BOOLEAN IsProxy)

{
  char *pcVar1;
  BOOLEAN BVar2;
  HTAAServer *pHVar3;
  FILE *__stream;
  char *local_2c;
  HTAASetup *local_24;
  char *local_20;
  HTList *cur;
  HTAASetup *setup;
  HTAAServer *server;
  
  if (portnumber < 1) {
    portnumber = 0x50;
  }
  if ((((hostname != (char *)0x0) && (docname != (char *)0x0)) && (*hostname != '\0')) &&
     ((*docname != '\0' &&
      (pHVar3 = HTAAServer_lookup(hostname,portnumber,IsProxy), pHVar3 != (HTAAServer *)0x0)))) {
    cur = pHVar3->setups;
    if (WWW_TraceFlag != '\0') {
      if (IsProxy == '\0') {
        local_2c = "server";
      }
      else {
        local_2c = "proxy";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s %s (%s:%d:%s)\n","HTAASetup_lookup: resolving setup for",local_2c
              ,hostname,portnumber,docname);
    }
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_24 = (HTAASetup *)0x0;
      }
      else {
        local_24 = (HTAASetup *)cur->object;
      }
      if (local_24 == (HTAASetup *)0x0) break;
      BVar2 = HTAA_templateMatch(local_24->ctemplate,docname);
      if (BVar2 != '\0') {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = local_24->ctemplate;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"%s `%s\' %s `%s\'\n","HTAASetup_lookup:",docname,
                  "matched template",pcVar1);
        }
        return local_24;
      }
      if (WWW_TraceFlag != '\0') {
        pcVar1 = local_24->ctemplate;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s `%s\' %s `%s\'\n","HTAASetup_lookup:",docname,
                "did NOT match template",pcVar1);
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (docname == (char *)0x0) {
      local_20 = "(null)";
    }
    else {
      local_20 = docname;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"%s `%s\' %s\n","HTAASetup_lookup: No template matched",local_20,
            "(so probably not protected)");
  }
  return (HTAASetup *)0x0;
}



HTAASetup *
HTAASetup_new(HTAAServer *server,char *ctemplate,HTList *valid_schemes,
             HTAssocList **scheme_specifics)

{
  HTAASetup *local_18;
  HTAASetup *setup;
  
  if (((server == (HTAAServer *)0x0) || (ctemplate == (char *)0x0)) || (*ctemplate == '\0')) {
    local_18 = (HTAASetup *)0x0;
  }
  else {
    local_18 = (HTAASetup *)calloc(1,0x14);
    if (local_18 == (HTAASetup *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAASetup_new");
    }
    local_18->retry = '\0';
    local_18->server = server;
    local_18->ctemplate = (char *)0x0;
    if (ctemplate != (char *)0x0) {
      HTSACopy(&local_18->ctemplate,ctemplate);
    }
    local_18->valid_schemes = valid_schemes;
    local_18->scheme_specifics = scheme_specifics;
    HTList_addObject(server->setups,local_18);
  }
  return local_18;
}



void HTAASetup_delete(HTAASetup *killme)

{
  int scheme;
  
  if (killme != (HTAASetup *)0x0) {
    if (killme->ctemplate != (char *)0x0) {
      free(killme->ctemplate);
      killme->ctemplate = (char *)0x0;
    }
    if (killme->valid_schemes != (HTList *)0x0) {
      HTList_delete(killme->valid_schemes);
      killme->valid_schemes = (HTList *)0x0;
    }
    scheme = 0;
    while (scheme < 6) {
      if (killme->scheme_specifics[scheme] != (HTAssocList *)0x0) {
        HTAssocList_delete(killme->scheme_specifics[scheme]);
      }
      scheme = scheme + 1;
    }
    if (killme->scheme_specifics != (HTAssocList **)0x0) {
      free(killme->scheme_specifics);
      killme->scheme_specifics = (HTAssocList **)0x0;
    }
    if (killme != (HTAASetup *)0x0) {
      free(killme);
    }
  }
  return;
}



void HTAASetup_updateSpecifics(HTAASetup *setup,HTAssocList **specifics)

{
  int scheme;
  
  if (setup != (HTAASetup *)0x0) {
    if (setup->scheme_specifics != (HTAssocList **)0x0) {
      scheme = 0;
      while (scheme < 6) {
        if (setup->scheme_specifics[scheme] != (HTAssocList *)0x0) {
          HTAssocList_delete(setup->scheme_specifics[scheme]);
        }
        scheme = scheme + 1;
      }
      if (setup->scheme_specifics != (HTAssocList **)0x0) {
        free(setup->scheme_specifics);
        setup->scheme_specifics = (HTAssocList **)0x0;
      }
    }
    setup->scheme_specifics = specifics;
  }
  return;
}



HTAARealm * HTAARealm_lookup(HTList *realm_table,char *realmname)

{
  int iVar1;
  HTAARealm *local_1c;
  HTAARealm *local_18;
  HTAARealm *realm;
  HTList *cur;
  
  if ((realm_table == (HTList *)0x0) || (realmname == (char *)0x0)) {
LAB_081452b2:
    local_1c = (HTAARealm *)0x0;
  }
  else {
    cur = realm_table;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (HTAARealm *)0x0;
      }
      else {
        local_18 = (HTAARealm *)cur->object;
      }
      local_1c = local_18;
      if (local_18 == (HTAARealm *)0x0) goto LAB_081452b2;
      iVar1 = strcmp(local_18->realmname,realmname);
    } while (iVar1 != 0);
  }
  return local_1c;
}



HTAARealm * HTAARealm_new(HTList *realm_table,char *realmname,char *username,char *password)

{
  HTAARealm *realm;
  
  realm = HTAARealm_lookup(realm_table,realmname);
  if (realm == (HTAARealm *)0x0) {
    realm = (HTAARealm *)calloc(1,0xc);
    if (realm == (HTAARealm *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAARealm_new");
    }
    realm->realmname = (char *)0x0;
    realm->username = (char *)0x0;
    realm->password = (char *)0x0;
    HTSACopy((char **)realm,realmname);
    if (realm_table != (HTList *)0x0) {
      HTList_addObject(realm_table,realm);
    }
  }
  if (username != (char *)0x0) {
    HTSACopy(&realm->username,username);
  }
  if (password != (char *)0x0) {
    HTSACopy(&realm->password,password);
  }
  return realm;
}



char * compose_auth_string(HTAAScheme scheme,HTAASetup *setup,BOOLEAN IsProxy)

{
  char *realmname_00;
  FILE *__stream;
  char *fmt;
  size_t nbytes;
  size_t sVar1;
  uchar *bufin;
  void *__ptr;
  char *local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_5c;
  char *local_54;
  char *local_50;
  char *timestamp;
  char *i_net_addr;
  HTAARealm *realm;
  char *thePort;
  char *proxiedHost;
  char *theHost;
  char *realmname;
  char *password;
  char *username;
  char *msg;
  int len;
  char *ciphertext;
  char *cleartext;
  
  msg = (char *)0x0;
  username = (char *)0x0;
  password = (char *)0x0;
  theHost = (char *)0x0;
  proxiedHost = (char *)0x0;
  thePort = (char *)0x0;
  if (compose_auth_stringResult != (char *)0x0) {
    free(compose_auth_stringResult);
    compose_auth_stringResult = (char *)0x0;
  }
  if (((((scheme != HTAA_BASIC) && (scheme != HTAA_PUBKEY)) || (setup == (HTAASetup *)0x0)) ||
      ((setup->scheme_specifics == (HTAssocList **)0x0 ||
       (setup->scheme_specifics[scheme] == (HTAssocList *)0x0)))) ||
     ((setup->server == (HTAAServer *)0x0 || (setup->server->realms == (HTList *)0x0)))) {
    return (char *)0x0;
  }
  realmname_00 = HTAssocList_lookup(setup->scheme_specifics[scheme],"realm");
  if (realmname_00 == (char *)0x0) {
    return (char *)0x0;
  }
  realm = HTAARealm_lookup(setup->server->realms,realmname_00);
  if (((realm == (HTAARealm *)0x0) || (realm->username == (char *)0x0)) ||
     ((*realm->username == '\0' || ((realm->password == (char *)0x0 || (setup->retry != '\0')))))) {
    if (realm == (HTAARealm *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s `%s\' %s\n","compose_auth_string: realm:",realmname_00,
                "not found -- creating");
      }
      realm = HTAARealm_new(setup->server->realms,realmname_00,(char *)0x0,(char *)0x0);
    }
    if ((((IsProxy == '\0') && (using_proxy != '\0')) && (setup->ctemplate != (char *)0x0)) &&
       ((proxiedHost = HTParse(setup->ctemplate,"",8), proxiedHost != (char *)0x0 &&
        (*proxiedHost != '\0')))) {
      theHost = proxiedHost;
    }
    if (theHost == (char *)0x0) {
      theHost = setup->server->hostname;
    }
    if ((0 < setup->server->portnumber) && (setup->server->portnumber != 0x50)) {
      HTSprintf0(&thePort,":%d",setup->server->portnumber);
    }
    strlen(realm->realmname);
    if (theHost == (char *)0x0) {
      local_6c = "??";
    }
    else {
      local_6c = theHost;
    }
    strlen(local_6c);
    if (thePort == (char *)0x0) {
      local_68 = "";
    }
    else {
      local_68 = thePort;
    }
    if (theHost == (char *)0x0) {
      local_64 = "??";
    }
    else {
      local_64 = theHost;
    }
    if (IsProxy == '\0') {
      local_60 = "server";
    }
    else {
      local_60 = "proxy";
    }
    realmname_00 = realm->realmname;
    fmt = (char *)gettext("Username for \'%s\' at %s \'%s%s\':");
    HTSprintf0(&msg,fmt,realmname_00,local_60,local_64,local_68);
    if (proxiedHost != (char *)0x0) {
      free(proxiedHost);
    }
    if (thePort != (char *)0x0) {
      free(thePort);
      thePort = (char *)0x0;
    }
    username = realm->username;
    password = (char *)0x0;
    HTPromptUsernameAndPassword(msg,&username,&password,IsProxy);
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
    if (realm->username != (char *)0x0) {
      free(realm->username);
      realm->username = (char *)0x0;
    }
    if (realm->password != (char *)0x0) {
      free(realm->password);
      realm->password = (char *)0x0;
    }
    realm->username = username;
    realm->password = password;
    if ((realm->username == (char *)0x0) || (realm->password == (char *)0x0)) {
      return (char *)0x0;
    }
    if (*realm->username == '\0') {
      HTSACopy(&compose_auth_stringResult,"");
      return compose_auth_stringResult;
    }
  }
  if (realm->username == (char *)0x0) {
    local_5c = "";
  }
  else {
    local_5c = realm->username;
  }
  nbytes = strlen(local_5c);
  if (realm->password == (char *)0x0) {
    local_54 = "";
  }
  else {
    local_54 = realm->password;
  }
  sVar1 = strlen(local_54);
  len = sVar1 + nbytes + 3;
  if (scheme == HTAA_PUBKEY) {
    if (secret_key == (char *)0x0) {
      local_50 = "";
    }
    else {
      local_50 = secret_key;
    }
    nbytes = strlen(local_50);
    len = nbytes + len + 0x1e;
  }
  else {
    if (secret_key != (char *)0x0) {
      free(secret_key);
      secret_key = (char *)0x0;
    }
  }
  bufin = (uchar *)calloc(len,1);
  if (bufin == (uchar *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c","compose_auth_string");
  }
  if (realm->username == (char *)0x0) {
    *bufin = '\0';
  }
  else {
    strcpy((char *)bufin,realm->username);
  }
  strcat((char *)bufin,":");
  if (realm->password != (char *)0x0) {
    strcat((char *)bufin,realm->password);
  }
  if (scheme == HTAA_PUBKEY) {
    strcat((char *)bufin,":");
    strcat((char *)bufin,"0.0.0.0");
    strcat((char *)bufin,":");
    strcat((char *)bufin,"42");
    strcat((char *)bufin,":");
    if (secret_key != (char *)0x0) {
      strcat((char *)bufin,secret_key);
    }
    __ptr = calloc(len * 2,1);
    if ((__ptr == (void *)0x0) ||
       (compose_auth_stringResult = (char *)calloc(len * 3,1),
       compose_auth_stringResult == (char *)0x0)) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","compose_auth_string");
    }
    if (bufin != (uchar *)0x0) {
      free(bufin);
    }
    if (__ptr != (void *)0x0) {
      free(__ptr);
    }
  }
  else {
    compose_auth_stringResult = (char *)calloc(((len + 2) / 3) * 4 + 1,1);
    if (compose_auth_stringResult == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","compose_auth_string");
    }
    realmname_00 = compose_auth_stringResult;
    nbytes = strlen((char *)bufin);
    HTUU_encode(bufin,nbytes,realmname_00);
    if (bufin != (uchar *)0x0) {
      free(bufin);
    }
  }
  return compose_auth_stringResult;
}



HTAAScheme HTAA_selectScheme(HTAASetup *setup)

{
  int iVar1;
  void *object;
  int scheme;
  
  if ((setup != (HTAASetup *)0x0) && (setup->valid_schemes != (HTList *)0x0)) {
    scheme = 2;
    while (scheme < 6) {
      iVar1 = HTList_indexOf(setup->valid_schemes,(void *)scheme);
      if (-1 < iVar1) {
        return scheme;
      }
      scheme = scheme + 1;
    }
  }
  return HTAA_BASIC;
}



void free_HTAAGlobals(void)

{
  HTAAServer *killme;
  int i;
  int n;
  HTAAServer *server;
  
  if (server_table != (HTList *)0x0) {
    i = HTList_count(server_table);
    while (i = i + -1, -1 < i) {
      killme = (HTAAServer *)HTList_objectAt(server_table,i);
      if (killme != (HTAAServer *)0x0) {
        HTAAServer_delete(killme);
      }
    }
    HTList_delete(server_table);
    server_table = (HTList *)0x0;
  }
  HTAAForwardAuth_reset();
  if (HTAA_composeAuthResult != (char *)0x0) {
    free(HTAA_composeAuthResult);
    HTAA_composeAuthResult = (char *)0x0;
  }
  if (current_hostname != (char *)0x0) {
    free(current_hostname);
    current_hostname = (char *)0x0;
  }
  if (current_docname != (char *)0x0) {
    free(current_docname);
    current_docname = (char *)0x0;
  }
  if (proxy_hostname != (char *)0x0) {
    free(proxy_hostname);
    proxy_hostname = (char *)0x0;
  }
  if (proxy_docname != (char *)0x0) {
    free(proxy_docname);
    proxy_docname = (char *)0x0;
  }
  if (compose_auth_stringResult != (char *)0x0) {
    free(compose_auth_stringResult);
    compose_auth_stringResult = (char *)0x0;
  }
  if (secret_key != (char *)0x0) {
    free(secret_key);
    secret_key = (char *)0x0;
  }
  return;
}



char * HTAA_composeAuth(char *hostname,int portnumber,char *docname,BOOLEAN IsProxy)

{
  bool bVar1;
  FILE *__stream;
  int iVar2;
  undefined4 uVar3;
  size_t sVar4;
  char *__s;
  size_t sVar5;
  char *msg;
  int len;
  HTAAScheme scheme;
  char *auth_string;
  BOOLEAN retry;
  
  if (free_HTAAGlobalsSet == '\0') {
    free_HTAAGlobalsSet = '\x01';
  }
  if (HTAAForwardAuth != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAA_composeAuth: %s\n","Forwarding received authorization");
    }
    HTSACopy(&HTAA_composeAuthResult,HTAAForwardAuth);
    HTAAForwardAuth_reset();
    return HTAA_composeAuthResult;
  }
  if (HTAA_composeAuthResult != (char *)0x0) {
    free(HTAA_composeAuthResult);
    HTAA_composeAuthResult = (char *)0x0;
  }
  if (IsProxy == '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Composing Authorization for %s:%d/%s\n",hostname,portnumber,docname)
      ;
    }
    if (((((current_portnumber == portnumber) && (current_hostname != (char *)0x0)) &&
         (current_docname != (char *)0x0)) &&
        ((hostname != (char *)0x0 && (docname != (char *)0x0)))) &&
       ((iVar2 = strcmp(current_hostname,hostname), iVar2 == 0 &&
        (iVar2 = strcmp(current_docname,docname), iVar2 == 0)))) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
      current_portnumber = portnumber;
      if (hostname == (char *)0x0) {
        if (current_hostname != (char *)0x0) {
          free(current_hostname);
          current_hostname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&current_hostname,hostname);
      }
      if (docname == (char *)0x0) {
        if (current_docname != (char *)0x0) {
          free(current_docname);
          current_docname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&current_docname,docname);
      }
    }
    if ((current_setup == (HTAASetup *)0x0) || (!bVar1)) {
      current_setup = HTAASetup_lookup(hostname,portnumber,docname,'\0');
    }
    if (current_setup == (HTAASetup *)0x0) {
      return (char *)0x0;
    }
    scheme = HTAA_selectScheme(current_setup);
    if (scheme + ~HTAA_NONE < 2) {
      auth_string = compose_auth_string(scheme,current_setup,'\0');
    }
    else {
      msg = (char *)0x0;
      __s = HTAAScheme_name(scheme);
      uVar3 = gettext(
                     "This client doesn\'t know how to compose authorization information for scheme"
                     );
      HTSprintf0(&msg,"%s `%s\'",uVar3,__s);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
      auth_string = (char *)0x0;
    }
    current_setup->retry = '\0';
    if (auth_string == (char *)0x0) {
      return (char *)0x0;
    }
    if (*auth_string == '\0') {
      HTSACopy(&HTAA_composeAuthResult,"");
      return HTAA_composeAuthResult;
    }
    sVar4 = strlen(auth_string);
    __s = HTAAScheme_name(scheme);
    sVar5 = strlen(__s);
    HTAA_composeAuthResult = (char *)calloc(sVar4 + sVar5 + 0x14,1);
    if (HTAA_composeAuthResult == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAA_composeAuth");
    }
    memcpy(HTAA_composeAuthResult,"Authorization: ",0x10);
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Composing Proxy Authorization for %s:%d/%s\n",hostname,portnumber,
              docname);
    }
    if ((((proxy_portnumber == portnumber) && (proxy_hostname != (char *)0x0)) &&
        (proxy_docname != (char *)0x0)) &&
       (((hostname != (char *)0x0 && (docname != (char *)0x0)) &&
        ((iVar2 = strcmp(proxy_hostname,hostname), iVar2 == 0 &&
         (iVar2 = strcmp(proxy_docname,docname), iVar2 == 0)))))) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
      proxy_portnumber = portnumber;
      if (hostname == (char *)0x0) {
        if (proxy_hostname != (char *)0x0) {
          free(proxy_hostname);
          proxy_hostname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&proxy_hostname,hostname);
      }
      if (docname == (char *)0x0) {
        if (proxy_docname != (char *)0x0) {
          free(proxy_docname);
          proxy_docname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&proxy_docname,docname);
      }
    }
    if ((proxy_setup == (HTAASetup *)0x0) || (!bVar1)) {
      proxy_setup = HTAASetup_lookup(hostname,portnumber,docname,IsProxy);
    }
    if (proxy_setup == (HTAASetup *)0x0) {
      return (char *)0x0;
    }
    scheme = HTAA_selectScheme(proxy_setup);
    if (scheme + ~HTAA_NONE < 2) {
      auth_string = compose_auth_string(scheme,proxy_setup,IsProxy);
    }
    else {
      msg = (char *)0x0;
      __s = HTAAScheme_name(scheme);
      uVar3 = gettext(
                     "This client doesn\'t know how to compose proxy authorization information for scheme"
                     );
      HTSprintf0(&msg,"%s `%s\'",uVar3,__s);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
      auth_string = (char *)0x0;
    }
    proxy_setup->retry = '\0';
    if (auth_string == (char *)0x0) {
      return (char *)0x0;
    }
    if (*auth_string == '\0') {
      HTSACopy(&HTAA_composeAuthResult,"");
      return HTAA_composeAuthResult;
    }
    sVar4 = strlen(auth_string);
    __s = HTAAScheme_name(scheme);
    sVar5 = strlen(__s);
    HTAA_composeAuthResult = (char *)calloc(sVar4 + sVar5 + 0x1a,1);
    if (HTAA_composeAuthResult == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAA_composeAuth");
    }
    memcpy(HTAA_composeAuthResult,"Proxy-Authorization: ",0x16);
  }
  __s = HTAAScheme_name(scheme);
  strcat(HTAA_composeAuthResult,__s);
  strcat(HTAA_composeAuthResult," ");
  strcat(HTAA_composeAuthResult,auth_string);
  return HTAA_composeAuthResult;
}



BOOLEAN HTAA_shouldRetryWithAuth(char *start_of_headers,int length,int soc,BOOLEAN IsProxy)

{
  BOOLEAN BVar1;
  HTList *me;
  FILE *__stream;
  char *str;
  char *a;
  int iVar2;
  void *newObject;
  HTList *pHVar3;
  char *__s;
  char *local_68;
  undefined *local_64;
  char *local_60;
  undefined *local_5c;
  char *local_58;
  char *local_54;
  BOOLEAN local_4d;
  HTAAServer *server_1;
  HTAAServer *server;
  int i;
  char *args;
  char *arg1;
  char *fieldname;
  char *p;
  char *temp;
  char *ctemplate;
  HTAssocList **scheme_specifics;
  HTList *valid_schemes;
  int num_schemes;
  char *line;
  HTAAScheme scheme;
  
  num_schemes = 0;
  me = HTList_new();
  scheme_specifics = (HTAssocList **)0x0;
  ctemplate = (char *)0x0;
  temp = (char *)0x0;
  if (free_HTAAGlobalsSet == '\0') {
    free_HTAAGlobalsSet = '\x01';
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Server reply header lines:\n");
  }
  HTAA_setupReader(start_of_headers,length,soc);
  while ((__s = HTAA_getUnfoldedLine(), __s != (char *)0x0 && (*__s != '\0'))) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s\n",__s);
    }
    str = strchr(__s,0x3a);
    if (str == (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Invalid header line `%s\' ignored\n",__s);
      }
    }
    else {
      p = __s;
      a = HTNextField(&p);
      local_54 = HTNextField(&p);
      str = p;
      if (((IsProxy == '\0') || (iVar2 = strcasecomp(a,"Proxy-Authenticate:"), iVar2 != 0)) &&
         ((IsProxy != '\0' || (iVar2 = strcasecomp(a,"WWW-Authenticate:"), iVar2 != 0)))) {
        if ((IsProxy == '\0') && (iVar2 = strcasecomp(a,"WWW-Protection-Template:"), iVar2 == 0)) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Protection template set to `%s\'\n",local_54);
          }
          HTSACopy(&ctemplate,local_54);
        }
      }
      else {
        if ((((local_54 == (char *)0x0) || (*local_54 == '\0')) || (str == (char *)0x0)) ||
           (*str == '\0')) {
          if ((str == (char *)0x0) || (*str == '\0')) {
            local_68 = "";
          }
          else {
            local_68 = str;
          }
          if ((str == (char *)0x0) || (*str == '\0')) {
            local_64 = &DAT_08191195;
          }
          else {
            local_64 = &DAT_0819103b;
          }
          if ((local_54 == (char *)0x0) || (local_60 = local_54, *local_54 == '\0')) {
            local_60 = "";
          }
          if ((local_54 == (char *)0x0) || (*local_54 == '\0')) {
            local_5c = &DAT_08191195;
          }
          else {
            local_5c = &DAT_0819103b;
          }
          str = (char *)gettext("Invalid header \'%s%s%s%s%s\'");
          HTSprintf0(&temp,str,__s,local_5c,local_60,local_64,local_68);
          HTAlert(temp);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        else {
          newObject = (void *)HTAAScheme_enum(local_54);
          if (newObject == (void *)0x0) {
            if (WWW_TraceFlag != '\0') {
              if (IsProxy == '\0') {
                local_58 = "in WWW-Authenticate: field";
              }
              else {
                local_58 = "in Proxy-Authenticate: field";
              }
              if (local_54 == (char *)0x0) {
                local_54 = "(null)";
              }
              __stream = TraceFP();
              fprintf((FILE *)__stream,"Unknown scheme `%s\' %s\n",local_54,local_58);
            }
          }
          else {
            HTList_addObject(me,newObject);
            if (scheme_specifics == (HTAssocList **)0x0) {
              scheme_specifics = (HTAssocList **)calloc(6,4);
              if (scheme_specifics == (HTAssocList **)0x0) {
                outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAA_shouldRetryWithAuth"
                        );
              }
              i = 0;
              while (i < 6) {
                scheme_specifics[i] = (HTAssocList *)0x0;
                i = i + 1;
              }
            }
            pHVar3 = HTAA_parseArgList(str);
            *(HTList **)(scheme_specifics + (int)newObject) = pHVar3;
            num_schemes = num_schemes + 1;
          }
        }
      }
    }
    if (__s != (char *)0x0) {
      free(__s);
    }
  }
  if (__s != (char *)0x0) {
    free(__s);
  }
  if (IsProxy == '\0') {
    if (num_schemes == 0) {
      current_setup = (HTAASetup *)0x0;
      local_4d = '\0';
    }
    else {
      if ((current_setup == (HTAASetup *)0x0) || (current_setup->server == (HTAAServer *)0x0)) {
        server_1 = HTAAServer_lookup(current_hostname,current_portnumber,'\0');
        if (server_1 == (HTAAServer *)0x0) {
          server_1 = HTAAServer_new(current_hostname,current_portnumber,'\0');
        }
        if (ctemplate == (char *)0x0) {
          ctemplate = HTAA_makeProtectionTemplate(current_docname);
        }
        current_setup = HTAASetup_new(server_1,ctemplate,me,scheme_specifics);
        if (ctemplate != (char *)0x0) {
          free(ctemplate);
          ctemplate = (char *)0x0;
        }
        __s = (char *)gettext("Access without authorization denied -- retrying");
        HTAlert(__s);
        local_4d = '\x01';
      }
      else {
        HTAASetup_updateSpecifics(current_setup,scheme_specifics);
        __s = (char *)gettext("Authorization failed.  Retry?");
        BVar1 = HTConfirm(__s);
        if (BVar1 == '\0') {
          current_setup = (HTAASetup *)0x0;
          local_4d = '\0';
        }
        else {
          current_setup->retry = '\x01';
          local_4d = '\x01';
        }
      }
    }
  }
  else {
    if (num_schemes == 0) {
      proxy_setup = (HTAASetup *)0x0;
      local_4d = '\0';
    }
    else {
      if ((proxy_setup == (HTAASetup *)0x0) || (proxy_setup->server == (HTAAServer *)0x0)) {
        server = HTAAServer_lookup(proxy_hostname,proxy_portnumber,IsProxy);
        if (server == (HTAAServer *)0x0) {
          server = HTAAServer_new(proxy_hostname,proxy_portnumber,IsProxy);
        }
        if (ctemplate == (char *)0x0) {
          HTSACopy(&ctemplate,"*");
        }
        proxy_setup = HTAASetup_new(server,ctemplate,me,scheme_specifics);
        if (ctemplate != (char *)0x0) {
          free(ctemplate);
          ctemplate = (char *)0x0;
        }
        __s = (char *)gettext("Proxy authorization required -- retrying");
        HTAlert(__s);
        local_4d = '\x01';
      }
      else {
        HTAASetup_updateSpecifics(proxy_setup,scheme_specifics);
        __s = (char *)gettext("Authorization failed.  Retry?");
        BVar1 = HTConfirm(__s);
        if (BVar1 == '\0') {
          proxy_setup = (HTAASetup *)0x0;
          local_4d = '\0';
        }
        else {
          proxy_setup->retry = '\x01';
          local_4d = '\x01';
        }
      }
    }
  }
  return local_4d;
}



void HTClearHTTPAuthInfo(void)

{
  free_HTAAGlobals();
  free_HTAAGlobalsSet = '\0';
  return;
}



BOOLEAN isNumber(char *s)

{
  BOOLEAN local_15;
  char *cur;
  
  cur = s;
  if ((s == (char *)0x0) || (*s == '\0')) {
    local_15 = '\0';
  }
  else {
    if (*s == '-') {
      cur = s + 1;
    }
    while (*cur != '\0') {
      if ((*cur < '0') || ('9' < *cur)) {
        return '\0';
      }
      cur = cur + 1;
    }
    local_15 = '\x01';
  }
  return local_15;
}



int HTAA_getUid(void)

{
  BOOLEAN BVar1;
  int uid_00;
  char *pcVar2;
  int local_18;
  int uid;
  
  if ((current_prot != (HTAAProt *)0x0) && (current_prot->uid_name != (char *)0x0)) {
    BVar1 = isNumber(current_prot->uid_name);
    if (BVar1 == '\0') {
      uid_00 = HTAA_NameToUid(current_prot->uid_name);
      if (uid_00 != 0xfffd) {
        return uid_00;
      }
    }
    else {
      uid_00 = atoi(current_prot->uid_name);
      pcVar2 = HTAA_UidToName(uid_00);
      if (*pcVar2 != '\0') {
        return uid_00;
      }
    }
  }
  local_18 = HTAA_NameToUid("nobody");
  if (local_18 == 0xfffd) {
    local_18 = 0xfffe;
  }
  return local_18;
}



int HTAA_getGid(void)

{
  BOOLEAN BVar1;
  int gid_00;
  char *pcVar2;
  int local_18;
  int gid;
  
  if ((current_prot != (HTAAProt *)0x0) && (current_prot->gid_name != (char *)0x0)) {
    BVar1 = isNumber(current_prot->gid_name);
    if (BVar1 == '\0') {
      gid_00 = HTAA_NameToGid(current_prot->gid_name);
      if (gid_00 != 0xfffd) {
        return gid_00;
      }
    }
    else {
      gid_00 = atoi(current_prot->gid_name);
      pcVar2 = HTAA_GidToName(gid_00);
      if (*pcVar2 != '\0') {
        return gid_00;
      }
    }
  }
  local_18 = HTAA_NameToGid("nogroup");
  if (local_18 == 0xfffd) {
    local_18 = 0xfffe;
  }
  return local_18;
}



void HTAA_setIds(HTAAProt *prot,char *ids)

{
  char *pcVar1;
  char *point;
  char *local_copy;
  
  if (ids == (char *)0x0) {
    HTSACopy(&prot->uid_name,"nobody");
    HTSACopy(&prot->gid_name,"nogroup");
  }
  else {
    local_copy = (char *)0x0;
    HTSACopy(&local_copy,ids);
    pcVar1 = strchr(local_copy,0x2e);
    if (pcVar1 == (char *)0x0) {
      HTSACopy(&prot->gid_name,"nogroup");
    }
    else {
      *pcVar1 = '\0';
      HTSACopy(&prot->gid_name,pcVar1 + 1);
    }
    HTSACopy(&prot->uid_name,local_copy);
    if (local_copy != (char *)0x0) {
      free(local_copy);
    }
  }
  return;
}



void HTAA_parseProtFile(HTAAProt *prot,FILE *fp)

{
  LexItem lex_item_00;
  int iVar1;
  void *newObject;
  HTList *pHVar2;
  char *pcVar3;
  GroupDef *pGVar4;
  HTAssocList *pHVar5;
  FILE *__stream;
  HTAAScheme scheme;
  char *fieldname;
  LexItem lex_item;
  
  if ((prot != (HTAAProt *)0x0) && (fp != (FILE *)0x0)) {
    fieldname = (char *)0x0;
LAB_08146fc5:
    lex_item = lex(fp);
    if (lex_item != LEX_EOF) {
      while (lex_item == LEX_REC_SEP) {
        lex_item = lex(fp);
      }
      if (lex_item == LEX_EOF) goto LAB_08146fdd;
      if (lex_item == LEX_ALPH_STR) {
        HTSACopy(&fieldname,HTlex_buffer);
        lex_item_00 = lex(fp);
        if (lex_item_00 != LEX_FIELD_SEP) {
          unlex(lex_item_00);
        }
        iVar1 = strncasecomp(fieldname,"Auth",4);
        if (iVar1 == 0) {
          lex_item = lex(fp);
          while (lex_item == LEX_ALPH_STR) {
            newObject = (void *)HTAAScheme_enum(HTlex_buffer);
            if (newObject == (void *)0x0) {
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"%s %s `%s\'\n","HTAA_parseProtFile: unknown",
                        "authentication scheme:",HTlex_buffer);
              }
            }
            else {
              if (prot->valid_schemes == (HTList *)0x0) {
                pHVar2 = HTList_new();
                prot->valid_schemes = pHVar2;
              }
              HTList_addObject(prot->valid_schemes,newObject);
              if (WWW_TraceFlag != '\0') {
                pcVar3 = HTAAScheme_name((HTAAScheme)newObject);
                __stream = TraceFP();
                fprintf((FILE *)__stream,"%s %s `%s\'\n","HTAA_parseProtFile: valid",
                        "authentication scheme:",pcVar3);
              }
            }
            lex_item = lex(fp);
            if (lex_item != LEX_ITEM_SEP) break;
            do {
              lex_item = lex(fp);
            } while (lex_item == LEX_REC_SEP);
          }
        }
        else {
          iVar1 = strncasecomp(fieldname,"mask",4);
          if (iVar1 == 0) {
            pGVar4 = HTAA_parseGroupDef(fp);
            prot->mask_group = pGVar4;
            lex_item = LEX_REC_SEP;
            if (WWW_TraceFlag != '\0') {
              if (prot->mask_group == (GroupDef *)0x0) {
                __stream = TraceFP();
                fwrite("HTAA_parseProtFile: Mask group syntax error\n",1,0x2c,(FILE *)__stream);
              }
              else {
                __stream = TraceFP();
                fwrite("HTAA_parseProtFile: Mask group:\n",1,0x20,(FILE *)__stream);
                HTAA_printGroupDef(prot->mask_group);
              }
            }
          }
          else {
            lex_item = lex(fp);
            if (lex_item == LEX_ALPH_STR) {
              if (prot->values == (HTAssocList *)0x0) {
                pHVar5 = HTAssocList_new();
                prot->values = pHVar5;
              }
              HTAssocList_add(prot->values,fieldname,HTlex_buffer);
              lex_item = lex(fp);
              pcVar3 = fieldname;
              if (WWW_TraceFlag != '\0') {
                __stream = TraceFP();
                fprintf((FILE *)__stream,"%s `%s\' bound to value `%s\'\n",
                        "HTAA_parseProtFile: Name",pcVar3,HTlex_buffer);
              }
            }
          }
        }
      }
      iVar1 = HTlex_line;
      if ((lex_item != LEX_EOF) && (lex_item != LEX_REC_SEP)) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"%s %s %d (that line ignored)\n",
                  "HTAA_parseProtFile: Syntax error","in protection setup file at line",iVar1);
        }
        do {
          lex_item_00 = lex(fp);
          if (lex_item_00 == LEX_EOF) break;
        } while (lex_item_00 != LEX_REC_SEP);
      }
      goto LAB_08146fc5;
    }
LAB_08146fdd:
    if (fieldname != (char *)0x0) {
      free(fieldname);
    }
  }
  return;
}



HTAAProt * HTAAProt_new(char *cur_docname,char *prot_filename,char *ids)

{
  int iVar1;
  FILE *fp_00;
  HTList *pHVar2;
  HTAssocList *pHVar3;
  char **dest;
  char **local_1c;
  char *local_18;
  FILE *fp;
  HTAAProt *prot;
  HTAAProtCache *cache_item;
  HTList *cur;
  
  cur = prot_cache;
  if (prot_cache == (HTList *)0x0) {
    prot_cache = HTList_new();
  }
  do {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_1c = (char **)0x0;
    }
    else {
      local_1c = (char **)cur->object;
    }
    if (local_1c == (char **)0x0) break;
    iVar1 = strcmp(*local_1c,prot_filename);
  } while (iVar1 != 0);
  if (local_1c == (char **)0x0) {
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"HTAAProt_new: Loading protection file `%s\'\n",prot_filename);
    }
    prot = (HTAAProt *)calloc(1,0x1c);
    if (prot == (HTAAProt *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAAProt.c","HTAAProt_new");
    }
    prot->ctemplate = (char *)0x0;
    prot->filename = (char *)0x0;
    prot->uid_name = (char *)0x0;
    prot->gid_name = (char *)0x0;
    pHVar2 = HTList_new();
    prot->valid_schemes = pHVar2;
    prot->mask_group = (GroupDef *)0x0;
    pHVar3 = HTAssocList_new();
    prot->values = pHVar3;
    if (prot_filename != (char *)0x0) {
      fp_00 = (FILE *)fopen64(prot_filename,"r");
      if (fp_00 != (FILE *)0x0) {
        HTAA_parseProtFile(prot,fp_00);
        fclose((FILE *)fp_00);
        dest = (char **)calloc(1,8);
        if (dest == (char **)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTAAProt.c","HTAAProt_new");
        }
        *(HTAAProt **)(dest + 1) = prot;
        *dest = (char *)0x0;
        HTSACopy(dest,prot_filename);
        HTList_addObject(prot_cache,dest);
        goto LAB_08147257;
      }
    }
    if (WWW_TraceFlag != '\0') {
      if (prot_filename == (char *)0x0) {
        local_18 = "(null)";
      }
      else {
        local_18 = prot_filename;
      }
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"HTAAProt_new: %s `%s\'\n","Unable to open protection setup file",
              local_18);
    }
  }
  else {
    prot = (HTAAProt *)local_1c[1];
    if (WWW_TraceFlag != '\0') {
      fp_00 = TraceFP();
      fprintf((FILE *)fp_00,"%s `%s\' already in cache\n","HTAAProt_new: Protection file",
              prot_filename);
    }
  }
LAB_08147257:
  if (cur_docname != (char *)0x0) {
    HTSACopy(&prot->filename,cur_docname);
  }
  HTAA_setIds(prot,ids);
  return prot;
}



void HTAA_setDefaultProtection(char *cur_docname,char *prot_filename,char *ids)

{
  FILE *__stream;
  
  default_prot = (HTAAProt *)0x0;
  if (prot_filename == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s %s\n","HTAA_setDefaultProtection: ERROR: Protection file",
              "not specified (obligatory for DefProt rule)!!\n");
    }
  }
  else {
    default_prot = HTAAProt_new(cur_docname,prot_filename,ids);
  }
  return;
}



void HTAA_setCurrentProtection(char *cur_docname,char *prot_filename,char *ids)

{
  FILE *__stream;
  
  current_prot = (HTAAProt *)0x0;
  if (prot_filename == (char *)0x0) {
    if (default_prot == (HTAAProt *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s %s %s\n","HTAA_setCurrentProtection: ERROR: Protection",
                "file not specified for Protect rule, and","default protection is not set!!");
      }
    }
    else {
      current_prot = default_prot;
      HTAA_setIds(default_prot,ids);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s %s %s\n","HTAA_setCurrentProtection: Protection file",
                "not specified for Protect rule","-- using default protection");
      }
    }
  }
  else {
    current_prot = HTAAProt_new(cur_docname,prot_filename,ids);
  }
  return;
}



HTAAProt * HTAA_getCurrentProtection(void)

{
  return current_prot;
}



HTAAProt * HTAA_getDefaultProtection(void)

{
  if (current_prot == (HTAAProt *)0x0) {
    current_prot = default_prot;
    default_prot = (HTAAProt *)0x0;
  }
  return current_prot;
}



void HTAA_clearProtections(void)

{
  default_prot = (HTAAProt *)0x0;
  current_prot = (HTAAProt *)0x0;
  return;
}



void save_gid_info(char *name,int user)

{
  char **dest;
  USER_DATA *data;
  
  dest = (char **)calloc(1,8);
  if (dest != (char **)0x0) {
    if (known_grp == (HTList *)0x0) {
      known_grp = HTList_new();
      if (uidgid_cache_inited == '\0') {
        uidgid_cache_inited = '\x01';
      }
    }
    HTSACopy(dest,name);
    *(int *)(dest + 1) = user;
    HTList_addObject(known_grp,dest);
  }
  return;
}



void save_uid_info(char *name,int user)

{
  char **dest;
  USER_DATA *data;
  
  dest = (char **)calloc(1,8);
  if (dest != (char **)0x0) {
    if (known_pwd == (HTList *)0x0) {
      known_pwd = HTList_new();
      if (uidgid_cache_inited == '\0') {
        uidgid_cache_inited = '\x01';
      }
    }
    HTSACopy(dest,name);
    *(int *)(dest + 1) = user;
    HTList_addObject(known_pwd,dest);
  }
  return;
}



char * HTAA_UidToName(int uid)

{
  __uid_t _Var1;
  char *pcVar2;
  passwd *ppVar3;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  passwd *pw;
  
  me = known_pwd;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    if (*(char **)(me->object + 1) == (char *)uid) {
      return *(char **)me->object;
    }
  }
  ppVar3 = getpwuid(uid);
  if ((ppVar3 != (passwd *)0x0) && (ppVar3->pw_name != (char *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      _Var1 = ppVar3->pw_uid;
      pcVar2 = ppVar3->pw_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%d) returned (%s:%d:...)\n","HTAA_UidToName: getpwuid",uid,pcVar2
              ,_Var1);
    }
    save_uid_info(ppVar3->pw_name,ppVar3->pw_uid);
    return ppVar3->pw_name;
  }
  return "";
}



int HTAA_NameToUid(char *name)

{
  char **ppcVar1;
  __uid_t _Var2;
  char *pcVar3;
  int iVar4;
  passwd *ppVar5;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  passwd *pw;
  
  me = known_pwd;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    ppcVar1 = (char **)me->object;
    iVar4 = strcmp(name,*ppcVar1);
    if (iVar4 == 0) {
      return (int)ppcVar1[1];
    }
  }
  ppVar5 = getpwnam(name);
  if (ppVar5 != (passwd *)0x0) {
    if (WWW_TraceFlag != '\0') {
      _Var2 = ppVar5->pw_uid;
      pcVar3 = ppVar5->pw_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%s) returned (%s:%d:...)\n","HTAA_NameToUid: getpwnam",name,
              pcVar3,_Var2);
    }
    save_uid_info(ppVar5->pw_name,ppVar5->pw_uid);
    return ppVar5->pw_uid;
  }
  return 0xfffd;
}



char * HTAA_GidToName(int gid)

{
  __gid_t _Var1;
  char *pcVar2;
  group *pgVar3;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  group *gr;
  
  me = known_grp;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    if (*(char **)(me->object + 1) == (char *)gid) {
      return *(char **)me->object;
    }
  }
  pgVar3 = getgrgid(gid);
  if ((pgVar3 != (group *)0x0) && (pgVar3->gr_name != (char *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      _Var1 = pgVar3->gr_gid;
      pcVar2 = pgVar3->gr_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%d) returned (%s:%d:...)\n","HTAA_GidToName: getgrgid",gid,pcVar2
              ,_Var1);
    }
    save_gid_info(pgVar3->gr_name,pgVar3->gr_gid);
    return pgVar3->gr_name;
  }
  return "";
}



int HTAA_NameToGid(char *name)

{
  char **ppcVar1;
  __gid_t _Var2;
  char *pcVar3;
  int iVar4;
  group *pgVar5;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  group *gr;
  
  me = known_grp;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    ppcVar1 = (char **)me->object;
    iVar4 = strcmp(name,*ppcVar1);
    if (iVar4 == 0) {
      return (int)ppcVar1[1];
    }
  }
  pgVar5 = getgrnam(name);
  if (pgVar5 != (group *)0x0) {
    if (WWW_TraceFlag != '\0') {
      _Var2 = pgVar5->gr_gid;
      pcVar3 = pgVar5->gr_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%s) returned (%s:%d:...)\n","HTAA_NameToGid: getgrnam",name,
              pcVar3,_Var2);
    }
    save_gid_info(pgVar5->gr_name,pgVar5->gr_gid);
    return pgVar5->gr_gid;
  }
  return 0xfffd;
}



HTAssocList * HTAssocList_new(void)

{
  HTList *pHVar1;
  
  pHVar1 = HTList_new();
  return (HTAssocList *)pHVar1;
}



void HTAssocList_delete(HTAssocList *alist)

{
  void **local_18;
  HTAssoc *assoc;
  HTAssocList *cur;
  
  if (alist != (HTAssocList *)0x0) {
    cur = alist;
    while( true ) {
      if ((cur == (HTAssocList *)0x0) || (cur = (HTAssocList *)cur->next, cur == (HTAssocList *)0x0)
         ) {
        local_18 = (void **)0x0;
      }
      else {
        local_18 = (void **)((HTList *)cur)->object;
      }
      if (local_18 == (void **)0x0) break;
      if (*local_18 != (void *)0x0) {
        free(*local_18);
        *local_18 = (void *)0x0;
      }
      if (local_18[1] != (void *)0x0) {
        free(local_18[1]);
        local_18[1] = (void *)0x0;
      }
      if (local_18 != (void **)0x0) {
        free(local_18);
      }
    }
    HTList_delete((HTList *)alist);
  }
  return;
}



void HTAssocList_add(HTAssocList *alist,char *name,char *value)

{
  char **dest;
  FILE *__stream;
  HTAssoc *assoc;
  
  if (alist == (HTAssocList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAssoc_add: ERROR: assoc list NULL!!\n");
    }
  }
  else {
    dest = (char **)malloc(8);
    if (dest == (char **)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAssoc.c","HTAssoc_add");
    }
    *dest = (char *)0x0;
    dest[1] = (char *)0x0;
    if (name != (char *)0x0) {
      HTSACopy(dest,name);
    }
    if (value != (char *)0x0) {
      HTSACopy(dest + 1,value);
    }
    HTList_addObject((HTList *)alist,dest);
  }
  return;
}



char * HTAssocList_lookup(HTAssocList *alist,char *name)

{
  size_t n;
  int iVar1;
  char **local_18;
  HTAssoc *assoc;
  HTAssocList *cur;
  
  cur = alist;
  while( true ) {
    if ((cur == (HTAssocList *)0x0) || (cur = (HTAssocList *)cur->next, cur == (HTAssocList *)0x0))
    {
      local_18 = (char **)0x0;
    }
    else {
      local_18 = (char **)((HTList *)cur)->object;
    }
    if (local_18 == (char **)0x0) break;
    n = strlen(name);
    iVar1 = strncasecomp(*local_18,name,n);
    if (iVar1 == 0) {
      return local_18[1];
    }
  }
  return (char *)0x0;
}



void unlex(LexItem lex_item)

{
  lex_pushed_back = lex_item;
  return;
}



LexItem lex(FILE *fp)

{
  int __c;
  LexItem LVar1;
  LexItem ret;
  int ch;
  
  if (fp != cache) {
    cache = fp;
    HTlex_line = 1;
  }
  if (lex_pushed_back != LEX_NONE) {
    LVar1 = lex_pushed_back;
    lex_pushed_back = LEX_NONE;
    return LVar1;
  }
  lex_cnt = 0;
  lex_template = '\0';
  do {
    __c = _IO_getc((_IO_FILE *)fp);
    switch(__c) {
    default:
      if (lex_cnt < 0x27) {
        HTlex_buffer[lex_cnt] = (char)__c;
        lex_cnt = lex_cnt + 1;
      }
      HTlex_buffer[lex_cnt] = '\0';
      if (__c == 0x2a) {
        lex_template = '\x01';
      }
      break;
    case -1:
    case 9:
    case 10:
    case 0xd:
    case 0x20:
    case 0x28:
    case 0x29:
    case 0x2c:
    case 0x3a:
    case 0x40:
      if (0 < lex_cnt) {
        if (__c != -1) {
          ungetc(__c,(FILE *)fp);
        }
        if (lex_template != '\0') {
          return LEX_TMPL_STR;
        }
        return LEX_ALPH_STR;
      }
      switch(__c) {
      case -1:
        return LEX_EOF;
      case 10:
        HTlex_line = HTlex_line + 1;
        return LEX_REC_SEP;
      case 0x28:
        return LEX_OPEN_PAREN;
      case 0x29:
        return LEX_CLOSE_PAREN;
      case 0x2c:
        return LEX_ITEM_SEP;
      case 0x3a:
        return LEX_FIELD_SEP;
      case 0x40:
        return LEX_AT_SIGN;
      }
    }
  } while( true );
}



char * lex_verbose(LexItem lex_item)

{
  char msg [70];
  char *local_8;
  
  switch(lex_item) {
  case LEX_NONE:
    local_8 = "NO-LEX-ITEM";
    break;
  case LEX_EOF:
    local_8 = "end-of-file";
    break;
  case LEX_REC_SEP:
    local_8 = "record separator (newline)";
    break;
  case LEX_FIELD_SEP:
    local_8 = "field separator \':\'";
    break;
  case LEX_ITEM_SEP:
    local_8 = "item separator \',\'";
    break;
  case LEX_OPEN_PAREN:
    local_8 = "\'(\'";
    break;
  case LEX_CLOSE_PAREN:
    local_8 = "\')\'";
    break;
  case LEX_AT_SIGN:
    local_8 = "address qualifier \'@\'";
    break;
  case LEX_ALPH_STR:
    sprintf((char *)0x81b94c0,"alphanumeric string \'%.*s\'",0x28,HTlex_buffer);
    local_8 = &ram0x081b94c0;
    break;
  case LEX_TMPL_STR:
    sprintf((char *)0x81b94c0,"template string \'%.*s\'",0x28,HTlex_buffer);
    local_8 = (char *)0x81b94c0;
    break;
  default:
    local_8 = "UNKNOWN-LEX-ITEM";
  }
  return local_8;
}



int HTUU_encode(uchar *bufin,uint nbytes,char *bufcoded)

{
  char *local_18;
  uint i;
  
  local_18 = bufcoded;
  i = 0;
  while (i < nbytes) {
    *local_18 = six2pr[*bufin >> 2];
    local_18[1] = six2pr[(uint)(bufin[1] >> 4) | ((uint)*bufin & 3) << 4];
    local_18[2] = six2pr[(uint)(bufin[2] >> 6) | ((uint)bufin[1] & 0xf) << 2];
    local_18[3] = six2pr[(uint)bufin[2] & 0x3f];
    local_18 = local_18 + 4;
    bufin = bufin + 3;
    i = i + 3;
  }
  if (nbytes + 1 == i) {
    local_18[-1] = '=';
  }
  else {
    if (nbytes + 2 == i) {
      local_18[-1] = '=';
      local_18[-2] = '=';
    }
  }
  *local_18 = '\0';
  return (int)(local_18 + -(int)bufcoded);
}



int HTUU_decode(char *bufcoded,uchar *bufplain,int outbufsize)

{
  byte bVar1;
  int first;
  byte *local_20;
  byte *local_1c;
  byte *local_18;
  int j;
  int nbytesdecoded;
  
  local_1c = bufplain;
  if (first != 0) {
    j = 0;
    while (j < 0x100) {
      pr2six[j] = '@';
      j = j + 1;
    }
    j = 0;
    while (j < 0x40) {
      pr2six[(byte)six2pr[j]] = (uchar)j;
      j = j + 1;
    }
  }
  while ((*bufcoded == ' ' || (*bufcoded == '\t'))) {
    bufcoded = bufcoded + 1;
  }
  local_20 = (byte *)bufcoded;
  do {
    bVar1 = *local_20;
    local_20 = local_20 + 1;
  } while (pr2six[bVar1] < 0x40);
  local_20 = local_20 + -(int)bufcoded;
  local_18 = local_20 + -1;
  nbytesdecoded = ((int)(local_20 + 2 + ((uint)((int)(local_20 + 2) >> 0x1f) >> 0x1e)) >> 2) * 3;
  if (outbufsize < nbytesdecoded) {
    local_18 = (byte *)((outbufsize << 2) / 3);
  }
  local_20 = (byte *)bufcoded;
  while (0 < (int)local_18) {
    *local_1c = pr2six[((char *)local_20)[1]] >> 4 | pr2six[(char)*local_20] << 2;
    local_1c[1] = pr2six[((char *)local_20)[2]] >> 2 | pr2six[((char *)local_20)[1]] << 4;
    local_1c[2] = pr2six[((char *)local_20)[3]] | pr2six[((char *)local_20)[2]] << 6;
    local_1c = local_1c + 3;
    local_20 = (byte *)((char *)local_20 + 4);
    local_18 = local_18 + -4;
  }
  if (((uint)local_18 & 3) != 0) {
    if (pr2six[((char *)local_20)[-2]] < 0x40) {
      nbytesdecoded = nbytesdecoded + -1;
    }
    else {
      nbytesdecoded = nbytesdecoded + -2;
    }
  }
  return nbytesdecoded;
}



HTAAScheme HTAAScheme_enum(char *name)

{
  int iVar1;
  HTAAScheme local_18;
  char *upcased;
  
  upcased = (char *)0x0;
  if (name == (char *)0x0) {
    local_18 = HTAA_UNKNOWN;
  }
  else {
    HTSACopy(&upcased,name);
    LYUpperCase(upcased);
    iVar1 = strncmp(upcased,"NONE",4);
    if (iVar1 == 0) {
      if (upcased != (char *)0x0) {
        free(upcased);
      }
      local_18 = HTAA_NONE;
    }
    else {
      iVar1 = strncmp(upcased,"BASIC",5);
      if (iVar1 == 0) {
        if (upcased != (char *)0x0) {
          free(upcased);
        }
        local_18 = HTAA_BASIC;
      }
      else {
        iVar1 = strncmp(upcased,"PUBKEY",6);
        if (iVar1 == 0) {
          if (upcased != (char *)0x0) {
            free(upcased);
          }
          local_18 = HTAA_PUBKEY;
        }
        else {
          iVar1 = strncmp(upcased,"KERBEROSV4",10);
          if (iVar1 == 0) {
            if (upcased != (char *)0x0) {
              free(upcased);
            }
            local_18 = HTAA_KERBEROS_V4;
          }
          else {
            iVar1 = strncmp(upcased,"KERBEROSV5",10);
            if (iVar1 == 0) {
              if (upcased != (char *)0x0) {
                free(upcased);
              }
              local_18 = HTAA_KERBEROS_V5;
            }
            else {
              if (upcased != (char *)0x0) {
                free(upcased);
              }
              local_18 = HTAA_UNKNOWN;
            }
          }
        }
      }
    }
  }
  return local_18;
}



char * HTAAScheme_name(HTAAScheme scheme)

{
  char *local_8;
  
  switch(scheme) {
  case HTAA_UNKNOWN:
    local_8 = "UNKNOWN";
    break;
  case HTAA_NONE:
    local_8 = "None";
    break;
  case HTAA_BASIC:
    local_8 = "Basic";
    break;
  case HTAA_PUBKEY:
    local_8 = "Pubkey";
    break;
  case HTAA_KERBEROS_V4:
    local_8 = "KerberosV4";
    break;
  case HTAA_KERBEROS_V5:
    local_8 = "KerberosV5";
    break;
  default:
    local_8 = "THIS-IS-A-BUG";
  }
  return local_8;
}



HTAAMethod HTAAMethod_enum(char *name)

{
  int iVar1;
  HTAAMethod local_8;
  
  if (name == (char *)0x0) {
    local_8 = METHOD_UNKNOWN;
  }
  else {
    iVar1 = strcasecomp(name,"GET");
    if (iVar1 == 0) {
      local_8 = METHOD_GET;
    }
    else {
      iVar1 = strcasecomp(name,"PUT");
      if (iVar1 == 0) {
        local_8 = METHOD_PUT;
      }
      else {
        local_8 = METHOD_UNKNOWN;
      }
    }
  }
  return local_8;
}



char * HTAAMethod_name(HTAAMethod method)

{
  char *local_8;
  
  if (method == METHOD_GET) {
    local_8 = "GET";
  }
  else {
    if (method == METHOD_UNKNOWN) {
      local_8 = "UNKNOWN";
    }
    else {
      if (method == METHOD_PUT) {
        local_8 = "PUT";
      }
      else {
        local_8 = "THIS-IS-A-BUG";
      }
    }
  }
  return local_8;
}



BOOLEAN HTAAMethod_inList(HTAAMethod method,HTList *list)

{
  FILE *__stream;
  HTAAMethod HVar1;
  char *local_18;
  char *item;
  HTList *cur;
  
  cur = list;
  while( true ) {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_18 = (char *)0x0;
    }
    else {
      local_18 = (char *)cur->object;
    }
    if (local_18 == (char *)0x0) break;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream," %s",local_18);
    }
    HVar1 = HTAAMethod_enum(local_18);
    if (HVar1 == method) {
      return '\x01';
    }
  }
  return '\0';
}



BOOLEAN HTAA_templateMatch(char *ctemplate,char *filename)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  BOOLEAN local_19;
  int m;
  char *q;
  char *p;
  
  p = ctemplate;
  q = filename;
  while (((*p != '\0' && (*q != '\0')) && (*p == *q))) {
    p = p + 1;
    q = q + 1;
  }
  if ((*p == '\0') && (*q == '\0')) {
    local_19 = '\x01';
  }
  else {
    if (*p == '*') {
      sVar1 = strlen(q);
      sVar2 = strlen(p + 1);
      if ((int)(sVar1 - sVar2) < 0) {
        local_19 = '\0';
      }
      else {
        iVar3 = strcmp(p + 1,q + (sVar1 - sVar2));
        if (iVar3 == 0) {
          local_19 = '\x01';
        }
        else {
          local_19 = '\0';
        }
      }
    }
    else {
      local_19 = '\0';
    }
  }
  return local_19;
}



BOOLEAN HTAA_templateCaseMatch(char *ctemplate,char *filename)

{
  ushort **ppuVar1;
  size_t sVar2;
  size_t sVar3;
  int iVar4;
  uint local_24;
  uint local_20;
  BOOLEAN local_19;
  int m;
  char *q;
  char *p;
  
  p = ctemplate;
  q = filename;
  while ((*p != '\0' && (*q != '\0'))) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x200) == 0) {
      local_24 = (uint)(byte)*p;
    }
    else {
      local_24 = toupper((uint)(byte)*p);
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*q] & 0x200) == 0) {
      local_20 = (uint)(byte)*q;
    }
    else {
      local_20 = toupper((uint)(byte)*q);
    }
    if (local_24 != local_20) break;
    p = p + 1;
    q = q + 1;
  }
  if ((*p == '\0') && (*q == '\0')) {
    local_19 = '\x01';
  }
  else {
    if (*p == '*') {
      sVar2 = strlen(q);
      sVar3 = strlen(p + 1);
      if ((int)(sVar2 - sVar3) < 0) {
        local_19 = '\0';
      }
      else {
        iVar4 = strcasecomp(p + 1,q + (sVar2 - sVar3));
        if (iVar4 == 0) {
          local_19 = '\x01';
        }
        else {
          local_19 = '\0';
        }
      }
    }
    else {
      local_19 = '\0';
    }
  }
  return local_19;
}



char * HTAA_makeProtectionTemplate(char *docname)

{
  char *pcVar1;
  FILE *__stream;
  char *slash;
  char *ctemplate;
  
  ctemplate = (char *)0x0;
  if (docname == (char *)0x0) {
    HTSACopy(&ctemplate,"*");
  }
  else {
    HTSACopy(&ctemplate,docname);
    slash = strrchr(ctemplate,0x2f);
    if (slash == (char *)0x0) {
      slash = ctemplate;
    }
    else {
      slash = slash + 1;
    }
    *slash = '\0';
    HTSACat(&ctemplate,"*");
  }
  pcVar1 = ctemplate;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"make_template: made template `%s\' for file `%s\'\n",pcVar1,docname);
  }
  return ctemplate;
}



HTList * HTAA_parseArgList(char *str)

{
  char *pcVar1;
  HTAssocList *alist;
  char *c_1;
  char *c;
  int n;
  char *name;
  char *cur;
  HTAssocList *assoc_list;
  
  alist = HTAssocList_new();
  name = (char *)0x0;
  n = 0;
  if (str != (char *)0x0) {
    while (*str != '\0') {
      while ((*str == ' ' || (*str == '\t'))) {
        str = str + 1;
      }
      cur = str;
      n = n + 1;
      while (((c = cur, *cur != '\0' && (*cur != '=')) && (*cur != ','))) {
        cur = cur + 1;
      }
      while ((c = c + -1, *c == ' ' || (*c == '\t'))) {
        *c = '\0';
      }
      if (*cur == '=') {
        *cur = '\0';
        HTSACopy(&name,str);
        do {
          do {
            pcVar1 = cur;
            cur = pcVar1 + 1;
          } while (*cur == ' ');
        } while (*cur == '\t');
        str = cur;
        if (*cur == '\"') {
          str = pcVar1 + 2;
          cur = str;
          while ((*cur != '\0' && (*cur != '\"'))) {
            cur = cur + 1;
          }
          if (*cur == '\"') {
            *cur = '\0';
            cur = cur + 1;
          }
          while ((*cur == ' ' || (*cur == '\t'))) {
            cur = cur + 1;
          }
          if (*cur == ',') {
            cur = cur + 1;
          }
        }
        else {
          while ((c_1 = cur, *cur != '\0' && (*cur != ','))) {
            cur = cur + 1;
          }
          while ((c_1 = c_1 + -1, *c_1 == ' ' || (*c_1 == '\t'))) {
            *c_1 = '\0';
          }
          if (*cur == ',') {
            *cur = '\0';
            cur = cur + 1;
          }
        }
      }
      else {
        if (*cur == ',') {
          *cur = '\0';
          cur = cur + 1;
        }
        HTSprintf0(&name,"%d",n);
      }
      HTAssocList_add(alist,name,str);
      str = cur;
    }
    if (name != (char *)0x0) {
      free(name);
    }
  }
  return (HTList *)alist;
}



void HTAA_setupReader(char *start_of_headers,int length,int soc)

{
  if (start_of_headers == (char *)0x0) {
    length = 0;
  }
  if (buffer == (char *)0x0) {
    buffer_length = length;
    if ((uint)length < 0x400) {
      buffer_length = 0x400;
    }
    buffer = (char *)malloc(buffer_length + 1);
  }
  else {
    if ((int)buffer_length < length) {
      buffer_length = length;
      buffer = (char *)realloc(buffer,length + 1);
    }
  }
  if (buffer == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAAUtil.c","HTAA_setupReader");
  }
  start_pointer = buffer;
  if (start_of_headers == (char *)0x0) {
    *buffer = '\0';
    end_pointer = start_pointer;
  }
  else {
    strncpy(buffer,start_of_headers,length);
    buffer[length] = '\0';
    end_pointer = buffer + length;
  }
  in_soc = soc;
  return;
}



char * HTAA_getUnfoldedLine(void)

{
  bool bVar1;
  FILE *__stream;
  int iVar2;
  int count;
  char *cur;
  char *line;
  BOOLEAN peek_for_folding;
  
  line = (char *)0x0;
  bVar1 = false;
  if (in_soc < 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s %s\n","HTAA_getUnfoldedLine: buffer not initialized",
              "with function HTAA_setupReader()");
    }
    return (char *)0x0;
  }
  do {
    if (end_pointer <= start_pointer) {
      iVar2 = HTDoRead(in_soc,buffer,0x400);
      if (iVar2 < 1) {
        in_soc = -1;
        return line;
      }
      start_pointer = buffer;
      end_pointer = buffer + iVar2;
      *end_pointer = '\0';
    }
    cur = start_pointer;
    if (bVar1) {
      if ((*start_pointer != ' ') && (*start_pointer != '\t')) {
        return line;
      }
      bVar1 = false;
    }
    while ((cur < end_pointer && (*cur != '\n'))) {
      cur = cur + 1;
    }
    if (cur < end_pointer) {
      *cur = '\0';
      if (cur[-1] == '\r') {
        cur[-1] = '\0';
      }
      bVar1 = true;
    }
    if (line == (char *)0x0) {
      HTSACopy(&line,start_pointer);
    }
    else {
      HTSACat(&line,start_pointer);
    }
    start_pointer = cur + 1;
  } while( true );
}



void syntax_error(FILE *fp,char *msg,LexItem lex_item)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int in_GS_OFFSET;
  int ch;
  int cnt;
  char buffer [41];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  cnt = 0;
  while( true ) {
    iVar1 = _IO_getc((_IO_FILE *)fp);
    if ((iVar1 == -1) || (iVar1 == 10)) break;
    if (cnt < 0x28) {
      buffer[cnt] = (char)iVar1;
      cnt = cnt + 1;
    }
  }
  buffer[cnt] = '\0';
  if (WWW_TraceFlag != '\0') {
    pcVar2 = lex_verbose(lex_item);
    iVar1 = HTlex_line;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"%s %d before: \'%s\'\nHTGroup.c: %s (got %s)\n",
            "HTGroup.c: Syntax error in rule file at line",iVar1,buffer,msg,pcVar2);
  }
  HTlex_line = HTlex_line + 1;
  if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



AddressDefList * parse_address_part(FILE *fp)

{
  bool bVar1;
  HTList *me;
  char **dest;
  Ref *ref;
  LexItem lex_item;
  AddressDefList *address_def_list;
  BOOLEAN only_one;
  
  bVar1 = false;
  lex_item = lex(fp);
  if ((lex_item == LEX_ALPH_STR) || (lex_item == LEX_TMPL_STR)) {
    bVar1 = true;
  }
  else {
    if ((lex_item != LEX_OPEN_PAREN) ||
       ((lex_item = lex(fp), lex_item != LEX_ALPH_STR && (lex_item != LEX_TMPL_STR)))) {
      syntax_error(fp,"Expecting a single address or \'(\' beginning list",lex_item);
      return (AddressDefList *)0x0;
    }
  }
  me = HTList_new();
  while( true ) {
    dest = (char **)calloc(1,8);
    if (dest == (char **)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","parse_address_part");
    }
    *dest = (char *)0x0;
    dest[1] = (char *)0x0;
    HTSACopy(dest,HTlex_buffer);
    HTList_addObject(me,dest);
    if ((bVar1) || (lex_item = lex(fp), lex_item != LEX_ITEM_SEP)) break;
    do {
      lex_item = lex(fp);
    } while (lex_item == LEX_REC_SEP);
    if ((lex_item != LEX_ALPH_STR) && (lex_item != LEX_TMPL_STR)) {
      syntax_error(fp,"Expecting an address template",lex_item);
      HTList_delete(me);
      return (AddressDefList *)0x0;
    }
  }
  if (bVar1) {
    return (AddressDefList *)me;
  }
  if (lex_item == LEX_CLOSE_PAREN) {
    return (AddressDefList *)me;
  }
  HTList_delete(me);
  syntax_error(fp,"Expecting \')\' closing address list",lex_item);
  return (AddressDefList *)0x0;
}



UserDefList * parse_user_part(FILE *fp)

{
  bool bVar1;
  HTList *me;
  char **dest;
  Ref *ref;
  LexItem lex_item;
  UserDefList *user_def_list;
  BOOLEAN only_one;
  
  bVar1 = false;
  lex_item = lex(fp);
  if (lex_item == LEX_ALPH_STR) {
    bVar1 = true;
  }
  else {
    if ((lex_item != LEX_OPEN_PAREN) || (lex_item = lex(fp), lex_item != LEX_ALPH_STR)) {
      syntax_error(fp,"Expecting a single name or \'(\' beginning list",lex_item);
      return (UserDefList *)0x0;
    }
  }
  me = HTList_new();
  while( true ) {
    dest = (char **)calloc(1,8);
    if (dest == (char **)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","parse_user_part");
    }
    *dest = (char *)0x0;
    dest[1] = (char *)0x0;
    HTSACopy(dest,HTlex_buffer);
    HTList_addObject(me,dest);
    if ((bVar1) || (lex_item = lex(fp), lex_item != LEX_ITEM_SEP)) break;
    do {
      lex_item = lex(fp);
    } while (lex_item == LEX_REC_SEP);
    if (lex_item != LEX_ALPH_STR) {
      syntax_error(fp,"Expecting user or group name",lex_item);
      HTList_delete(me);
      return (UserDefList *)0x0;
    }
  }
  if (bVar1) {
    return (UserDefList *)me;
  }
  if (lex_item == LEX_CLOSE_PAREN) {
    return (UserDefList *)me;
  }
  HTList_delete(me);
  syntax_error(fp,"Expecting \')\' closing user/group list",lex_item);
  return (UserDefList *)0x0;
}



Item * parse_item(FILE *fp)

{
  Item *local_18;
  LexItem lex_item;
  AddressDefList *address_def_list;
  UserDefList *user_def_list;
  Item *item;
  
  user_def_list = (UserDefList *)0x0;
  address_def_list = (AddressDefList *)0x0;
  lex_item = lex(fp);
  if ((lex_item == LEX_ALPH_STR) || (lex_item == LEX_OPEN_PAREN)) {
    unlex(lex_item);
    user_def_list = parse_user_part(fp);
    lex_item = lex(fp);
  }
  if (lex_item == LEX_AT_SIGN) {
    lex_item = lex(fp);
    if (((lex_item != LEX_ALPH_STR) && (lex_item != LEX_TMPL_STR)) && (lex_item != LEX_OPEN_PAREN))
    {
      if (user_def_list != (UserDefList *)0x0) {
        HTList_delete((HTList *)user_def_list);
      }
      syntax_error(fp,"Expected address part (single address or list)",lex_item);
      return (Item *)0x0;
    }
    unlex(lex_item);
    address_def_list = parse_address_part(fp);
  }
  else {
    unlex(lex_item);
  }
  if ((user_def_list == (UserDefList *)0x0) && (address_def_list == (AddressDefList *)0x0)) {
    syntax_error(fp,"Empty item not allowed",lex_item);
    local_18 = (Item *)0x0;
  }
  else {
    local_18 = (Item *)calloc(1,8);
    if (local_18 == (Item *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","parse_item");
    }
    local_18->user_def_list = user_def_list;
    local_18->address_def_list = address_def_list;
  }
  return local_18;
}



ItemList * parse_item_list(FILE *fp)

{
  HTList *me;
  Item *newObject;
  LexItem lex_item_00;
  LexItem lex_item;
  Item *item;
  ItemList *item_list;
  
  me = HTList_new();
  while( true ) {
    newObject = parse_item(fp);
    if (newObject == (Item *)0x0) {
      HTList_delete(me);
      return (ItemList *)0x0;
    }
    HTList_addObject(me,newObject);
    lex_item_00 = lex(fp);
    if (lex_item_00 != LEX_ITEM_SEP) break;
    do {
      lex_item_00 = lex(fp);
    } while (lex_item_00 == LEX_REC_SEP);
    unlex(lex_item_00);
  }
  unlex(lex_item_00);
  return (ItemList *)me;
}



GroupDef * HTAA_parseGroupDef(FILE *fp)

{
  ItemList *pIVar1;
  LexItem lex_item_00;
  GroupDef *local_18;
  LexItem lex_item;
  GroupDef *group_def;
  ItemList *item_list;
  
  pIVar1 = parse_item_list(fp);
  if (pIVar1 == (ItemList *)0x0) {
    local_18 = (GroupDef *)0x0;
  }
  else {
    local_18 = (GroupDef *)calloc(1,8);
    if (local_18 == (GroupDef *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","HTAA_parseGroupDef");
    }
    local_18->group_name = (char *)0x0;
    local_18->item_list = pIVar1;
    lex_item_00 = lex(fp);
    if (lex_item_00 != LEX_REC_SEP) {
      syntax_error(fp,"Garbage after group definition",lex_item_00);
    }
  }
  return local_18;
}



void print_item(Item *item)

{
  undefined4 uVar1;
  FILE *__s;
  undefined4 *local_30;
  undefined4 *local_2c;
  char *local_28;
  char *local_24;
  undefined4 *local_20;
  undefined4 *local_1c;
  Ref *addr_ref;
  Ref *user_ref;
  AddressDefList *cur2;
  UserDefList *cur1;
  
  if (item == (Item *)0x0) {
    __s = TraceFP();
    fwrite("\tNULL-ITEM\n",1,0xb,(FILE *)__s);
  }
  else {
    cur1 = item->user_def_list;
    cur2 = item->address_def_list;
    if ((cur1 == (UserDefList *)0x0) ||
       (cur1 = (UserDefList *)cur1->next, cur1 == (UserDefList *)0x0)) {
      local_30 = (undefined4 *)0x0;
    }
    else {
      local_30 = (undefined4 *)((HTList *)cur1)->object;
    }
    if ((cur2 == (AddressDefList *)0x0) ||
       (cur2 = (AddressDefList *)cur2->next, cur2 == (AddressDefList *)0x0)) {
      local_2c = (undefined4 *)0x0;
    }
    else {
      local_2c = (undefined4 *)((HTList *)cur2)->object;
    }
    if (local_30 == (undefined4 *)0x0) {
      __s = TraceFP();
      fwrite("\tANYBODY ",1,9,(FILE *)__s);
    }
    else {
      if (local_30[1] == 0) {
        local_28 = "";
      }
      else {
        local_28 = "*REF*";
      }
      uVar1 = *local_30;
      __s = TraceFP();
      fprintf((FILE *)__s,"\t[%s%s",uVar1,local_28);
      while( true ) {
        if ((cur1 == (UserDefList *)0x0) ||
           (cur1 = (UserDefList *)cur1->next, cur1 == (UserDefList *)0x0)) {
          local_20 = (undefined4 *)0x0;
        }
        else {
          local_20 = (undefined4 *)((HTList *)cur1)->object;
        }
        if (local_20 == (undefined4 *)0x0) break;
        if (local_20[1] == 0) {
          local_24 = "";
        }
        else {
          local_24 = "*REF*";
        }
        uVar1 = *local_20;
        __s = TraceFP();
        fprintf((FILE *)__s,"; %s%s",uVar1,local_24);
      }
      __s = TraceFP();
      fwrite(&DAT_08192010,1,2,(FILE *)__s);
    }
    if (local_2c == (undefined4 *)0x0) {
      __s = TraceFP();
      fwrite("@ ANYADDRESS\n",1,0xd,(FILE *)__s);
    }
    else {
      uVar1 = *local_2c;
      __s = TraceFP();
      fprintf((FILE *)__s,"@ [%s",uVar1);
      while( true ) {
        if ((cur2 == (AddressDefList *)0x0) ||
           (cur2 = (AddressDefList *)cur2->next, cur2 == (AddressDefList *)0x0)) {
          local_1c = (undefined4 *)0x0;
        }
        else {
          local_1c = (undefined4 *)((HTList *)cur2)->object;
        }
        if (local_1c == (undefined4 *)0x0) break;
        uVar1 = *local_1c;
        __s = TraceFP();
        fprintf((FILE *)__s,"; %s",uVar1);
      }
      __s = TraceFP();
      fwrite(&DAT_08192028,1,2,(FILE *)__s);
    }
  }
  return;
}



void print_item_list(ItemList *item_list)

{
  FILE *__s;
  Item *local_18;
  Item *item;
  ItemList *cur;
  
  cur = item_list;
  if (item_list == (ItemList *)0x0) {
    __s = TraceFP();
    fwrite("EMPTY",1,5,(FILE *)__s);
  }
  else {
    while( true ) {
      if ((cur == (ItemList *)0x0) || (cur = (ItemList *)cur->next, cur == (ItemList *)0x0)) {
        local_18 = (Item *)0x0;
      }
      else {
        local_18 = (Item *)((HTList *)cur)->object;
      }
      if (local_18 == (Item *)0x0) break;
      print_item(local_18);
    }
  }
  return;
}



void HTAA_printGroupDef(GroupDef *group_def)

{
  FILE *__stream;
  char *local_8;
  
  if (group_def == (GroupDef *)0x0) {
    __stream = TraceFP();
    fwrite("\nNULL RECORD\n",1,0xd,(FILE *)__stream);
  }
  else {
    if (group_def->group_name == (char *)0x0) {
      local_8 = "NULL";
    }
    else {
      local_8 = group_def->group_name;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nGroup %s:\n",local_8);
    print_item_list(group_def->item_list);
    __stream = TraceFP();
    fputc(10,(FILE *)__stream);
  }
  return;
}



undefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  int iVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  uint local_20;
  uint local_18;
  byte local_14;
  
  local_20 = 0;
  if ((int)param_2 < 0) {
    bVar9 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar9);
    local_20 = 0xffffffff;
  }
  if ((int)param_4 < 0) {
    local_20 = ~local_20;
    bVar9 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(param_4 + bVar9);
  }
  if (param_4 == 0) {
    if (param_2 < param_3) {
      uVar8 = 0;
      iVar5 = (int)(CONCAT44(param_2,param_1) / (ulonglong)param_3);
    }
    else {
      local_18 = param_3;
      if (param_3 == 0) {
        local_18 = (uint)(1 / 0);
      }
      uVar8 = param_2 / local_18;
      iVar5 = (int)(((ulonglong)param_2 % (ulonglong)local_18 << 0x20 | (ulonglong)param_1) /
                   (ulonglong)local_18);
    }
    goto LAB_081495c5;
  }
  if (param_4 <= param_2) {
    uVar8 = 0x1f;
    if (param_4 != 0) {
      while (param_4 >> uVar8 == 0) {
        uVar8 = uVar8 - 1;
      }
    }
    if ((uVar8 ^ 0x1f) != 0) {
      local_14 = (byte)(uVar8 ^ 0x1f);
      bVar6 = 0x20 - local_14;
      uVar1 = (ulonglong)(param_3 >> (bVar6 & 0x1f) | param_4 << (local_14 & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar6 & 0x1f),
                       param_1 >> (bVar6 & 0x1f) | param_2 << (local_14 & 0x1f));
      uVar3 = uVar2 / uVar1;
      iVar5 = (int)uVar3;
      uVar8 = (uint)(uVar2 % uVar1);
      lVar4 = (ulonglong)(param_3 << (local_14 & 0x1f)) * (uVar3 & 0xffffffff);
      uVar7 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar8 < uVar7) || ((uVar8 == uVar7 && (param_1 << (local_14 & 0x1f) < (uint)lVar4)))) {
        uVar8 = 0;
        iVar5 = iVar5 + -1;
      }
      else {
        uVar8 = 0;
      }
      goto LAB_081495c5;
    }
    if ((param_4 < param_2) || (param_3 <= param_1)) {
      iVar5 = 1;
      uVar8 = 0;
      goto LAB_081495c5;
    }
  }
  iVar5 = 0;
  uVar8 = 0;
LAB_081495c5:
  if (local_20 != 0) {
    bVar9 = iVar5 != 0;
    iVar5 = -iVar5;
    uVar8 = -(uVar8 + bVar9);
  }
  return CONCAT44(uVar8,iVar5);
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x0814972e)
// WARNING: Removing unreachable block (ram,0x08149730)

void __libc_csu_init(void)

{
  EVP_PKEY_CTX *local_1c;
  
  _init(local_1c);
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int stat64(char *__file,stat64 *__buf)

{
  int iVar1;
  
  iVar1 = __xstat64(3,__file,__buf);
  return iVar1;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int lstat64(char *__file,stat64 *__buf)

{
  int iVar1;
  
  iVar1 = __lxstat64(3,__file,__buf);
  return iVar1;
}



void __do_global_ctors_aux(void)

{
  code *pcVar1;
  code **ppcVar2;
  
  if (__CTOR_LIST__ != (code *)0xffffffff) {
    ppcVar2 = (code **)&__CTOR_LIST__;
    pcVar1 = __CTOR_LIST__;
    do {
      ppcVar2 = ppcVar2 + -1;
      (*pcVar1)();
      pcVar1 = *ppcVar2;
    } while (pcVar1 != (code *)0xffffffff);
  }
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


