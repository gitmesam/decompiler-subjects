// Generated by Rec Studio 4 - build Sep 23 2015

_init()
{// addr = 0x080487E4
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 55300 - 8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    return _t3;
}

L080487F0()
{
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 55300 - 8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return _t3;
}

abort()
{// addr = 0x08048824
    goto __imp__abort;
}

srand()
{// addr = 0x08048834
    goto __imp__srand;
}

__cxa_atexit()
{// addr = 0x08048844
    goto __imp____cxa_atexit;
}

__gmon_start__()
{// addr = 0x08048854
    goto __imp____gmon_start__;
}

realloc()
{// addr = 0x08048864
    goto __imp__realloc;
}

getenv()
{// addr = 0x08048874
    goto __imp__getenv;
}

calloc()
{// addr = 0x08048884
    goto __imp__calloc;
}

putchar()
{// addr = 0x08048894
    goto __imp__putchar;
}

pow()
{// addr = 0x080488A4
    goto __imp__pow;
}

__libc_start_main()
{// addr = 0x080488B4
    goto __imp____libc_start_main;
}

perror()
{// addr = 0x080488C4
    goto __imp__perror;
}

free()
{// addr = 0x080488D4
    goto __imp__free;
}

fflush()
{// addr = 0x080488E4
    goto __imp__fflush;
}

sqrt()
{// addr = 0x080488F4
    goto __imp__sqrt;
}

fclose()
{// addr = 0x08048904
    goto __imp__fclose;
}

memcpy()
{// addr = 0x08048914
    goto __imp__memcpy;
}

fopen()
{// addr = 0x08048924
    goto __imp__fopen;
}

cos()
{// addr = 0x08048934
    goto __imp__cos;
}

fgetc()
{// addr = 0x08048944
    goto __imp__fgetc;
}

feof()
{// addr = 0x08048954
    goto __imp__feof;
}

printf()
{// addr = 0x08048964
    goto __imp__printf;
}

atoi()
{// addr = 0x08048974
    goto __imp__atoi;
}

fwrite()
{// addr = 0x08048984
    goto __imp__fwrite;
}

fprintf()
{// addr = 0x08048994
    goto __imp__fprintf;
}

time()
{// addr = 0x080489A4
    goto __imp__time;
}

malloc()
{// addr = 0x080489B4
    goto __imp__malloc;
}

__stack_chk_fail()
{// addr = 0x080489C4
    goto __imp____stack_chk_fail;
}

log()
{// addr = 0x080489D4
    goto __imp__log;
}

puts()
{// addr = 0x080489E4
    goto __imp__puts;
}

rand()
{// addr = 0x080489F4
    goto __imp__rand;
}

fread()
{// addr = 0x08048A04
    goto __imp__fread;
}

sin()
{// addr = 0x08048A14
    goto __imp__sin;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08048A30
    signed int __ebx;                      // r1
    signed int _t9;                        // _t9

    _t5 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & -16;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(__esi);
    _push(main);
    __libc_start_main();
    asm("hlt");
    0;
    0;
    _push(0);
    _push(__ebx);
    __esp = __esp - 4;
    if(completed.6635 == 0) {
        _t9 = dtor_idx.6637;
        _t5 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        while(_t9 < __ebx) {
            _t5 = _t9 + 1;
            dtor_idx.6637 = _t5;
             *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
            _t9 = dtor_idx.6637;
        }
        completed.6635 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
}

__do_global_dtors_aux()
{// addr = 0x08048A60
    signed int __ebx;                      // r1
    _unknown_ _t5;                         // _t5

    if(completed.6635 == 0) {
        __edx = dtor_idx.6637;
        _t8 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(__edx >= __ebx) {
L4:
            completed.6635 = 1;
            return;
        }
        do {
            _t8 = __edx + 1;
            dtor_idx.6637 = _t8;
             *((intOrPtr*)(_t8 * 4 +  &__DTOR_LIST__))();
            __edx = dtor_idx.6637;
        } while(__edx < __ebx);
        goto L4;
    }
}

frame_dummy()
{// addr = 0x08048AC0
    if(__JCR_LIST__ == 0 || 0 == 0) {
        return;
    } else {
         *__esp =  &__JCR_LIST__;
         *0();
        return;
    }
}

int quantum_ipow(int a, int b)
{// addr = 0x08048AE4  --  defined in 'classic.c' at line 30
    int i;                                 // _cfa_fffffff8
    int r;                                 // _cfa_fffffff4

    r = 1;
    i = 0;
    while(i < b) {
        r = r * a;
        i = i + 1;
    }
    return r;
}

int quantum_gcd(int u, int v)
{// addr = 0x08048B15  --  defined in 'classic.c' at line 44
    int r;                                 // _cfa_fffffff8

    while(v != 0) {
        r = u % v;
        u = v;
        v = r;
    }
    return u;
}

void quantum_frac_approx(int* a, int* b, int width)
{// addr = 0x08048B42  --  defined in 'classic.c' at line 60
    float f;                               // _cfa_fffffff8
    float g;                               // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    int num2;                              // _cfa_ffffffec
    int den2;                              // _cfa_ffffffe8
    int num1;                              // _cfa_ffffffe4
    int den1;                              // _cfa_ffffffe0
    int num;                               // _cfa_ffffffdc
    int den;                               // _cfa_ffffffd8
    _unknown_ _v58;                        // _cfa_ffffffc6
    short _v60;                            // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    signed long long _t85;                 // _t85

    _push( *a);
    asm("fild dword [esp]");
    _push( *b);
    asm("fild dword [esp]");
    asm("fdivp st1, st0");
    f = __fp0;
    g = f;
    num2 = 0;
    den2 = 1;
    num1 = 1;
    den1 = 0;
    num = 0;
    den = 0;
    asm("fnstcw word [ebp-0x36]");
    _v60 = 12;
    while(1) {
        asm("faddp st1, st0");
        asm("fldcw word [ebp-0x38]");
        asm("fistp dword [ebp-0xc]");
        asm("fldcw word [ebp-0x36]");
        asm("fild dword [ebp-0xc]");
        _t85 =  *134562424;
        asm("fsubp st1, st0");
        asm("fsubp st1, st0");
        g = _t85;
        asm("fld1");
        g = _t85 / g;
        if(i * den1 + den2 > 1 << width) {
            break;
        }
        num = i * num1 + num2;
        den = i * den1 + den2;
        num2 = num1;
        den2 = den1;
        num1 = num;
        den1 = den;
        asm("fild dword [ebp-0x20]");
        asm("fild dword [ebp-0x24]");
        asm("fdivp st1, st0");
        asm("fsubp st1, st0");
        asm("fabs");
        _push(2 << width);
        asm("fild dword [esp]");
        asm("fld1");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(2 > 0) {
            continue;
        }
        break;
    }
     *a = num;
     *b = den;
}

int quantum_getwidth(int n)
{// addr = 0x08048C63  --  defined in 'classic.c' at line 95
    int i;                                 // _cfa_fffffff8

    i = 1;
    while(1 << __cl < n) {
        i = i + 1;
    }
    return i;
}

int quantum_inverse_mod(int n, int c)
{// addr = 0x08048C8A  --  defined in 'classic.c' at line 107
    int i;                                 // _cfa_fffffff8

    i = 1;
    while(i * c % n != 1) {
        i = i + 1;
    }
    return i;
}

complex float quantum_conj(complex float a)
{// addr = 0x08048CBC  --  defined in 'complex.c' at line 33
    float r;                               // _cfa_ffffffec
    float i;                               // _cfa_ffffffe8
    complex float _v36;                    // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    complex float _t33;                    // _t33
    complex float _t50;                    // _t50

     *__esp = a;
    _v56 = _a8;
    quantum_real();
    r = __fp0;
     *__esp = a;
    _v56 = _a8;
    quantum_imag();
    i = __fp0;
    _t33 = __mulsc3(i, 0, -2147483648, -1082130432);
    _v36 = r;
    _v36 = 0;
    _v36 = _t33;
    _v36 = 0;
    _t50 = _v36;
    asm("fxch st0, st1");
    asm("faddp st3, st0");
    asm("faddp st1, st0");
    asm("fxch st0, st1");
    _v36 = _t50;
    _v36 = _t50;
    return _v36;
}

float quantum_real(complex float a)
{// addr = 0x08048D63  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

float quantum_imag(complex float a)
{// addr = 0x08048D7C  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

float quantum_prob(complex float a)
{// addr = 0x08048D98  --  defined in 'complex.c' at line 46
    float _v8;                             // _cfa_fffffff8
    intOrPtr _v24;                         // _cfa_ffffffe8
    float _t10;                            // _t10

     *__esp = a;
    _v24 = _a8;
    quantum_prob_inline();
    _v8 = __fp0;
    _t10 = _v8;
    _v8 = _t10;
    return _t10;
}

float quantum_prob_inline(complex float a)
{// addr = 0x08048DBE  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    float _t16;                            // _t16

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    r = __fp0;
     *__esp = a;
    _t16 = _a8;
    _v24 = _t16;
    quantum_imag();
    i = __fp0;
    asm("faddp st1, st0");
    return _t16;
}

complex float quantum_cexp(float phi)
{// addr = 0x08048DFE  --  defined in 'complex.c' at line 53
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v20;                        // _cfa_ffffffec
    char _v28;                             // _cfa_ffffffe4
    complex float _v32;                    // _cfa_ffffffe0
    long long _v44;                        // _cfa_ffffffd4
    long long _v52;                        // _cfa_ffffffcc
    complex float _v56;                    // _cfa_ffffffc8
    long long _v80;                        // _cfa_ffffffb0
    long long _v88;                        // _cfa_ffffffa8
    long long _v96;                        // _cfa_ffffffa0
    long long _v104;                       // _cfa_ffffff98
    long long _t32;                        // _t32
    long long _t33;                        // _t33
    complex float _t39;                    // _t39

    _push(__ebx);
    __esp = __esp - 100;
    _t32 = phi;
     *__esp = _t32;
    cos();
    _v44 = _t32;
    asm("fldz");
    _v52 = _t32;
    _t33 = phi;
     *__esp = _t33;
    sin();
    asm("fldz");
    asm("fld1");
    _v80 = _t33;
    asm("fldz");
    _v88 = _t33;
    _v96 = _t33;
    _v104 = _t33;
     *__esp =  &_v28;
    __muldc3();
    __esp = __esp - 4;
    asm("fxch st0, st3");
    asm("faddp st1, st0");
    asm("fxch st0, st1");
    asm("faddp st2, st0");
    _v32 = _v52;
    asm("fxch st0, st1");
    _v32 = _v32;
    _t39 = _v32;
    asm("fxch st0, st1");
    _v56 = _t39;
    _v56 = _t39;
    return _v56;
}

float quantum_get_decoherence()
{// addr = 0x08048E84  --  defined in 'decoherence.c' at line 46
    float _v8;                             // _cfa_fffffff8

    __eax = quantum_lambda;
    _v8 = __eax;
    return __eax;
}

void quantum_set_decoherence(float l)
{// addr = 0x08048E97  --  defined in 'decoherence.c' at line 55
    asm("fldz");
    asm("fxch st0, st1");
    asm("fucompp");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags != 0 || __eflags != 0) {
        quantum_status = 1;
        quantum_lambda = l;
        return;
    } else {
        quantum_status = 0;
        return;
    }
}

void quantum_decohere(quantum_reg* reg)
{// addr = 0x08048ECA  --  defined in 'decoherence.c' at line 71
    float u;                               // _cfa_ffffffe8
    float v;                               // _cfa_ffffffe4
    float s;                               // _cfa_ffffffe0
    float x;                               // _cfa_ffffffdc
    float* nrands;                         // _cfa_ffffffd8
    float angle;                           // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd0
    int j;                                 // _cfa_ffffffcc
    intOrPtr _v60;                         // _cfa_ffffffc4
    signed long long _v68;                 // _cfa_ffffffbc
    signed long long _v76;                 // _cfa_ffffffb4
    signed long long _v84;                 // _cfa_ffffffac
    signed long long _v100;                // _cfa_ffffff9c
    _unknown_ _v112;                       // _cfa_ffffff90 (outparam)
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    intOrPtr _v120;                        // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    float* _t93;                           // _t93
    _unknown_ _t111;                       // _t111
    signed int _t113;                      // _t113
    signed char _t143;                     // _t143
    unsigned int _t148;                    // _t148
    signed int _t149;                      // _t149
    complex float _t153;                   // _t153
    signed long long _t174;                // _t174
    signed long long _t179;                // _t179

    quantum_gate_counter(1);
    if(quantum_status == 0) {
        return;
    }
    _t93 = reg->width;
    _v120 = 4;
     *__esp = _t93;
    calloc();
    nrands = _t93;
    if(nrands == 0) {
        quantum_error(2);
    }
    quantum_memman(reg->width << 2);
    i = 0;
    while(reg->width > i) {
        do {
            quantum_frand();
            asm("faddp st1, st0");
            asm("fld1");
            asm("fsubp st1, st0");
            u = st0;
            quantum_frand();
            asm("faddp st1, st0");
            asm("fld1");
            asm("fsubp st1, st0");
            v = st0;
            asm("faddp st1, st0");
            s = v * v;
            asm("fld1");
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
        } while(__eflags >= 0);
        _v84 = u;
         *__esp = s;
        log();
        asm("fmulp st1, st0");
        asm("fdivp st1, st0");
        _v76 = s;
        asm("fsqrt");
        _v100 = _v76;
        asm("fucomp st0");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags != 0 || __eflags != 0) {
            _t174 = _v76;
             *__esp = _t174;
            sqrt();
            _v100 = _t174;
        }
        x = _v100 * _v84;
        _v68 = x;
        _t179 = quantum_lambda + st0;
         *__esp = _t179;
        sqrt();
        x = _t179 * _v68;
        asm("fdivp st1, st0");
        nrands[i] =  *134562440;
        i = i + 1;
        __eflags = i;
    }
    i = 0;
    while(reg->size > i) {
        angle = 0;
        j = 0;
        while(1) {
            __eflags = reg->width - j;
            if(reg->width <= j) {
                break;
            }
            _t111 = reg->node + (i << 4);
            _t148 =  *(_t111 + 12);
            _t143 = j;
            _t113 = (_t148 << 32 |  *(_t111 + 8)) >> _t143;
            _t149 = _t148 >> _t143;
            __eflags = _t143 & 32;
            if((_t143 & 32) != 0) {
                _t113 = _t149;
                __eflags = 0;
            }
            __eflags = _t113 & 1;
            if((_t113 & 1) == 0) {
                __eflags =  &(nrands[j]);
                asm("fsubrp st1, st0");
                angle = angle;
            } else {
                asm("faddp st1, st0");
                angle = angle;
            }
            j = j + 1;
            __eflags = j;
        }
        __edi = reg->node + (i << 4);
        _t151 = reg->node;
        _t127 = reg->node + (i << 4);
        _v60 =  *((intOrPtr*)(reg->node + (i << 4) + 4));
        _t153 = quantum_cexp(angle);
         *__edi = __mulsc3( *_t127, _v60, _t153, _t151);
        __edi[1] = _t153;
        i = i + 1;
        __eflags = i;
    }
     *__esp = nrands;
    free();
    quantum_memman( ~(reg->width << 2));
}

quantum_density_op quantum_new_density_op(int num, float* prob, quantum_reg* reg)
{// addr = 0x0804911C  --  defined in 'density.c' at line 38
    int i;                                 // _cfa_fffffff8
    int* phash;                            // _cfa_fffffff4
    int hashw;                             // _cfa_fffffff0
    float* _v20;                           // _cfa_ffffffec
    int* _v24;                             // _cfa_ffffffe8
    quantum_density_op rho;   // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    float* _t89;                           // _t89
    float* _t91;                           // _t91
    float* _t167;                          // _t167
    float* _t169;                          // _t169
    int** _t174;                           // _t174
    int** _t180;                           // _t180

    rho.num = prob;
    _t89 = prob;
    _v40 = 4;
     *__esp = _t89;
    calloc();
    _v24 = _t89;
    if(_v24 == 0) {
        quantum_error(2);
    }
    _t91 = prob;
    _v40 = 20;
     *__esp = _t91;
    calloc();
    _v20 = _t91;
    if(_v20 == 0) {
        quantum_error(2);
    }
    quantum_memman(prob + prob + prob << 3);
     *_v24 = reg->width;
    phash = ( *(__ebp + 20))[4];
    hashw = ( *(__ebp + 20))[2];
    _t167 = _v20;
    _t174 =  *(__ebp + 20);
     *_t167 =  *_t174;
    _t167[1] = _t174[1];
    _t167[2] = _t174[2];
    _t167[3] = _t174[3];
    _t167[4] = _t174[4];
    ( *(__ebp + 20))[1] = 0;
     *( *(__ebp + 20)) = 0;
    ( *(__ebp + 20))[3] = 0;
    ( *(__ebp + 20))[4] = 0;
    i = 1;
    while(i < prob) {
        _v24[i] =  *(reg + (i << 2));
        _t169 =  &(_v20[(i << 2) + i]);
        _t180 =  &(( *(__ebp + 20))[(i << 2) + i]);
         *_t169 =  *_t180;
        _t169[1] = _t180[1];
        _t169[2] = _t180[2];
        _t169[3] = _t180[3];
        _t169[4] = _t180[4];
        ( &(_v20[(i << 2) + i]))[4] = phash;
        ( &(_v20[(i << 2) + i]))[2] = hashw;
        ( &(( *(__ebp + 20))[(i << 2) + i]))[1] = 0;
        ( *(__ebp + 20))[(i << 2) + i] = 0;
        ( &(( *(__ebp + 20))[(i << 2) + i]))[3] = 0;
        ( &(( *(__ebp + 20))[(i << 2) + i]))[4] = 0;
        i = i + 1;
    }
     *num = rho.num;
     *(num + 4) = _v24;
     *(num + 8) = _v20;
    return num;
}

quantum_density_op quantum_qureg2density_op(quantum_reg* reg)
{// addr = 0x08049315  --  defined in 'density.c' at line 93
    _unknown_ _v8;                         // _cfa_fffffff8
    float f;                               // _cfa_fffffff4
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct quantum_density_op_struct _t14;   // _t14

    _push(__ebx);
    __esp = __esp - 36;
    _t14 = reg;
    f = 1065353216;
    _v32 =  *((intOrPtr*)(__ebp + 12));
    quantum_new_density_op(_t14, 1,  &f);
    __esp = __esp - 4;
    return _t14;
}

void quantum_reduced_density_op(int pos, quantum_density_op* rho)
{// addr = 0x08049351  --  defined in 'density.c' at line 105
    _unknown_ _v8;                         // _cfa_fffffff8
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    double p0;                             // _cfa_ffffffe4
    double ptmp;                           // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    long long unsigned int pos2;           // _cfa_ffffffd4
    float _v48;                            // _cfa_ffffffd0
    float _v52;                            // _cfa_ffffffcc
    float _v56;                            // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    quantum_reg rtmp;   // _cfa_ffffffc0
    float _v80;                            // _cfa_ffffffb0
    float _v108;                           // _cfa_ffffff94
    float _v112;                           // _cfa_ffffff90
    float _v116;                           // _cfa_ffffff8c
    float _v120;                           // _cfa_ffffff88
    float _v124;                           // _cfa_ffffff84
    float _v128;                           // _cfa_ffffff80
    float _v132;                           // _cfa_ffffff7c
    float _v136;                           // _cfa_ffffff78
    int _v140;                             // _cfa_ffffff74
    int _v144;                             // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    int _v156;                             // _cfa_ffffff64
    float* _t163;                          // _t163
    quantum_reg* _t173;   // _t173
    long long unsigned int _t185;          // _t185
    float* _t282;                          // _t282
    float* _t283;                          // _t283
    signed char _t285;                     // _t285
    signed int _t300;                      // _t300
    float* _t303;                          // _t303
    quantum_reg** _t311;   // _t311
    double _t325;                          // _t325
    float _t328;                           // _t328

    _push(__ebx);
    __esp = __esp - 148;
    asm("fldz");
    p0 = __fp0;
    _t163 = rho->prob;
    _v152 = rho->num << 3;
     *__esp = _t163;
    realloc();
    rho->prob = _t163;
    if(rho->prob == 0) {
        quantum_error(2);
    }
    _t173 = rho->reg;
    _v152 =  &(rho->num[rho->num]) << 3;
     *__esp = _t173;
    realloc();
    rho->reg = _t173;
    if(rho->reg == 0) {
        quantum_error(2);
    }
    quantum_memman(rho->num + rho->num + rho->num << 3);
    _t285 = pos;
    _t300 = (0 << 32 | 1) << _t285;
    _t185 = 1 << _t285;
    if((_t285 & 32) != 0) {
        _t300 = _t185;
        _t185 = 0;
    }
    pos2 = _t185;
    _v40 = _t300;
    i = 0;
    while(rho->num > i) {
        _t325 = rho->prob[i];
        ptmp = _t325;
        _t303 =  &(rho->reg[(i << 2) + i]);
        rtmp.width =  *_t303;
        _v60 = _t303[1];
        _v56 = _t303[2];
        _v52 = _t303[3];
        _v48 = _t303[4];
        asm("fldz");
        p0 = _t325;
        j = 0;
        while(( &(rho->reg[(i << 2) + i]))[1] > j) {
            if(((( &(rho->reg[(i << 2) + i]))[3] + (j << 4))[2] & pos2 | (( &(rho->reg[(i << 2) + i]))[3] + (j << 4))[3] & _v40) == 0) {
                _t311 = ( &(rho->reg[(i << 2) + i]))[3] + (j << 4);
                 *__esp =  *_t311;
                _v152 = _t311[1];
                quantum_prob_inline();
                asm("faddp st1, st0");
                p0 = p0;
            }
            j = j + 1;
        }
        _v80 = ptmp * p0;
        _t328 = _v80;
        rho->prob[i] = _t328;
        asm("fld1");
        _v80 = (_t328 - p0) * ptmp;
        rho->prob[rho->num + i] = _v80;
        _t282 =  &(rho->reg[(i << 2) + i]);
        _v144 = rtmp.width;
        _v140 = _v60;
        _v136 = _v56;
        _v132 = _v52;
        _v128 = _v48;
        _v148 = 0;
        _v152 = pos;
         *__esp =  &_v124;
        quantum_state_collapse();
        __esp = __esp - 4;
         *_t282 = _v124;
        _t282[1] = _v120;
        _t282[2] = _v116;
        _t282[3] = _v112;
        _t282[4] = _v108;
        _t283 =  &(rho->reg[(rho->num + i << 2) + rho->num + i]);
        _v148 = rtmp.width;
        _v144 = _v60;
        _v140 = _v56;
        _v136 = _v52;
        _v132 = _v48;
        _v152 = 1;
        _v156 = pos;
         *__esp =  &_v124;
        quantum_state_collapse();
        __esp = __esp - 4;
         *_t283 = _v124;
        _t283[1] = _v120;
        _t283[2] = _v116;
        _t283[3] = _v112;
        _t283[4] = _v108;
        quantum_delete_qureg_hashpreserve( &rtmp);
        i = i + 1;
    }
    rho->num = rho->num + rho->num;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0804966A  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    float _t16;                            // _t16

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    r = __fp0;
     *__esp = a;
    _t16 = _a8;
    _v24 = _t16;
    quantum_imag();
    i = __fp0;
    asm("faddp st1, st0");
    return _t16;
}

float quantum_real(complex float a)
{// addr = 0x080496AA  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

float quantum_imag(complex float a)
{// addr = 0x080496C3  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

quantum_matrix quantum_density_matrix(quantum_density_op* rho)
{// addr = 0x080496DF  --  defined in 'density.c' at line 157
    char _v16;                             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int l1;                                // _cfa_ffffffe0
    int l2;                                // _cfa_ffffffdc
    int dim;                               // _cfa_ffffffd8
    quantum_reg* _v44;   // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    quantum_matrix m;   // _cfa_ffffffcc
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c (outparam)
    signed int _v104;                      // _cfa_ffffff98 (outparam)
    signed int _v108;                      // _cfa_ffffff94 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t145;                      // _t145
    signed int _t157;                      // _t157
    intOrPtr* _t172;                       // _t172
    _unknown_ _t188;                       // _t188
    signed int* _t236;                     // _t236
    signed int* _t238;                     // _t238
    intOrPtr _t247;                        // _t247
    signed int* _t251;                     // _t251
    complex float _t253;                   // _t253
    intOrPtr _t265;                        // _t265

    __esp = __esp - 92;
    dim = 1 <<  *( *( *((intOrPtr*)(__ebp + 12)) + 8));
    if(dim < 0) {
        quantum_error(3);
    }
    _v100 = dim;
    quantum_new_matrix( &m, dim);
    __esp = __esp - 4;
    k = 0;
    while( *((intOrPtr*)( *((intOrPtr*)(__ebp + 12)))) > k) {
        quantum_reconstruct_hash( &(( *( *((intOrPtr*)(__ebp + 12)) + 8))[(k << 2) + k]));
        i = 0;
        while(i < dim) {
            j = 0;
            while(j < dim) {
                _t236 =  &(( *( *((intOrPtr*)(__ebp + 12)) + 8))[(k << 2) + k]);
                _t145 = i;
                _v104 =  *_t236;
                _v100 = _t236[1];
                _v96 = _t236[2];
                _v92 = _t236[3];
                _v88 = _t236[4];
                 *__esp = _t145;
                _v108 = _t145 >> 31;
                l1 = quantum_get_state();
                _t238 =  &(( *( *((intOrPtr*)(__ebp + 12)) + 8))[(k << 2) + k]);
                _t157 = j;
                _v104 =  *_t238;
                _v100 = _t238[1];
                _v96 = _t238[2];
                _v92 = _t238[3];
                _v88 = _t238[4];
                 *__esp = _t157;
                _v108 = _t157 >> 31;
                l2 = quantum_get_state();
                if(l1 >= 0 && l2 >= 0) {
                    __edi = _v44 + (_v48 * j + i << 3);
                    _t172 = _v44 + (_v48 * j + i << 3);
                    _v72 =  *_t172;
                    _v76 = _t172[1];
                    _t247 =  *((intOrPtr*)( &(( *( *((intOrPtr*)(__ebp + 12)) + 8))[(k << 2) + k])->node + (l2 << 4)));
                    _t188 = __mulsc3( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 12)) + 4)) + (k << 2))), 0, _t247,  *((intOrPtr*)( &(( *( *((intOrPtr*)(__ebp + 12)) + 8))[(k << 2) + k])->node + (l2 << 4) + 4)));
                    _v68 = _t247;
                    _t251 =  &(( *( *((intOrPtr*)(__ebp + 12)) + 8))[(k << 2) + k])->node + (l1 << 4);
                     *__esp =  *_t251;
                    _v108 = _t251[1];
                    _t253 = quantum_conj();
                    _v80 = __mulsc3(_t188, _v68, _t253, _t251);
                    _v80 = _t253;
                    _t265 = _v80;
                    asm("fxch st0, st1");
                    asm("faddp st3, st0");
                    asm("faddp st1, st0");
                    asm("fxch st0, st1");
                    _v80 = _t265;
                    _v80 = _t265;
                     *__edi = _v80;
                    __edi[1] = _v80;
                }
                j = j + 1;
            }
            i = i + 1;
        }
        k = k + 1;
    }
    rho->num = m.rows;
    rho->prob = _v48;
    rho->reg = _v44;
    __esp =  &_v16;
    return rho;
}

void quantum_reconstruct_hash(quantum_reg* reg)
{// addr = 0x08049996  --  defined in 'qureg.h' at line 159
    int i;                                 // _cfa_fffffff8
    quantum_reg* _v32;   // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ _t40;                        // _t40

    i = 0;
    while(1 << reg->hashw > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t40 = reg->node + (i << 4);
        _v32 = reg;
        _v36 = i;
         *__esp =  *((intOrPtr*)(_t40 + 8));
        _v40 =  *((intOrPtr*)(_t40 + 12));
        quantum_add_hash();
        i = i + 1;
    }
}

void quantum_add_hash(long long unsigned int a, int pos, quantum_reg* reg)
{// addr = 0x08049A19  --  defined in 'qureg.h' at line 131
    int i;                                 // _cfa_fffffff8
    int mark;                              // _cfa_fffffff4
    int _v24;                              // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8

    _v28 = a;
    _v24 = pos;
    mark = 0;
    _v36 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 8));
     *__esp = _v28;
    _v40 = _v24;
    i = quantum_hash64();
    do {
    } while( *( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 16)) + (i << 2)) != 0);
     *( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 16)) + (i << 2)) =  &(reg->width);
}

unsigned int quantum_hash64(long long unsigned int key, int width)
{// addr = 0x08049AB8  --  defined in 'qureg.h' at line 91
    unsigned int k32;                      // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4

    _v28 = key;
    _v24 = width;
    k32 = _v24 ^ _v28;
    k32 = k32 * -1640562687;
    k32 = k32 >> 32 -  *((intOrPtr*)(__ebp + 16));
    return k32;
}

int quantum_get_state(long long unsigned int a, quantum_reg reg)
{// addr = 0x08049AFA  --  defined in 'qureg.h' at line 106
    int i;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0

    _v28 = a;
    _v24 = reg.width;
    if(_a20 != 0) {
        _v44 = _a20;
         *__esp = _v28;
        _v48 = _v24;
        i = quantum_hash64();
        while( *((intOrPtr*)(_a28 + (i << 2))) != 0) {
            if(( *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 8) ^ _v28 |  *0x0000000D ^ _v24) != 0) {
                i = i + 1;
                if(1 << _a20 == i) {
                    i = 0;
                }
                continue;
            }
            _v32 =  *((intOrPtr*)(_a28 + (i << 2))) - 1;
L9:
            return _v32;
        }
        _v32 = -1;
        goto L9;
    }
    _v32 = _v28;
    goto L9;
}

void quantum_print_density_matrix(quantum_density_op* rho)
{// addr = 0x08049BC0  --  defined in 'density.c' at line 192
    quantum_density_op* _v16;   // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    quantum_density_op* _v36;   // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    quantum_density_op* _v56;   // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4

    _v56 = rho;
    quantum_density_matrix( &_v44);
    __esp = __esp - 4;
    m.rows = _v44;
    _v20 = _v40;
    _v16 = _v36;
     *__esp = m.rows;
    _v60 = _v20;
    _v56 = _v16;
    quantum_print_matrix();
    quantum_delete_matrix( &m);
}

void quantum_delete_density_op(quantum_density_op* rho)
{// addr = 0x08049C13  --  defined in 'density.c' at line 205
    int i;                                 // _cfa_fffffff8

    quantum_destroy_hash(rho->reg);
    i = 0;
    while(rho->num > i) {
        quantum_delete_qureg_hashpreserve(rho->reg + ((i << 2) + i << 2));
        i = i + 1;
    }
     *__esp = rho->prob;
    free();
     *__esp = rho->reg;
    free();
    quantum_memman(rho->num * -24);
    rho->prob = 0;
    rho->reg = 0;
}

float quantum_purity(quantum_density_op* rho)
{// addr = 0x08049C9E  --  defined in 'density.c' at line 228
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int l;                                 // _cfa_ffffffe0
    float f;                               // _cfa_ffffffdc
    complex float _v40;                    // _cfa_ffffffd8
    complex float g;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    complex float dp;                      // _cfa_ffffffcc
    float _v68;                            // _cfa_ffffffbc
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0 (outparam)
    intOrPtr _v100;                        // _cfa_ffffff9c (outparam)
    intOrPtr _v104;                        // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t166;                       // _t166
    _unknown_ _t199;                       // _t199
    float _t216;                           // _t216
    intOrPtr* _t233;                       // _t233
    signed int _t246;                      // _t246
    intOrPtr* _t263;                       // _t263
    complex float _t265;                   // _t265

    f = 0;
    i = 0;
    while(rho->num > i) {
        asm("fmulp st1, st0");
        asm("faddp st1, st0");
        f = f;
        i = i + 1;
    }
    i = 0;
    while(rho->num > i) {
        j = 0;
        while(j < i) {
            _t246 = i;
            dp = quantum_dot_product(rho->reg + ((_t246 << 2) + _t246 << 2), rho->reg + ((j << 2) + j << 2));
            _v48 = _t246;
            k = 0;
            while( *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 4)) > k) {
                _t233 = rho->reg + ((j << 2) + j << 2);
                _t166 =  *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 12)) + (k << 4);
                _v100 =  *_t233;
                _v96 = _t233[1];
                _v92 = _t233[2];
                _v88 = _t233[3];
                _v84 = _t233[4];
                 *__esp =  *((intOrPtr*)(_t166 + 8));
                _v104 =  *((intOrPtr*)(_t166 + 12));
                l = quantum_get_state();
                if(l < 0) {
                    g = 0;
                    _v40 = 0;
                } else {
                    asm("fmulp st1, st0");
                    _v68 = rho->prob[j];
                    _t199 = __mulsc3(__mulsc3(_v68, 0, dp, _v48), dp,  *((intOrPtr*)( *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 12)) + (k << 4))),  *((intOrPtr*)( *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 12)) + (k << 4) + 4)));
                    _t263 = rho->reg + ((j << 2) + j << 2)->node + (l << 4);
                     *__esp =  *_t263;
                    _v104 = _t263[1];
                    _t265 = quantum_conj();
                    g = __mulsc3(_t199,  *((intOrPtr*)( *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 12)) + (k << 4))), _t265, _t263);
                    _v40 = _t265;
                }
                 *__esp = g;
                _v104 = _v40;
                quantum_real();
                asm("faddp st1, st0");
                asm("faddp st1, st0");
                f = f;
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    _t216 = f;
    _v68 = _t216;
    return _t216;
}

_Unknown_base* quantum_error_handler(_None* f)
{// addr = 0x08049F64  --  defined in 'error.c' at line 31
    if(f != 0) {
        errfunc = f;
    }
    return errfunc;
}

const char* quantum_strerr(int errno)
{// addr = 0x08049F7C  --  defined in 'error.c' at line 42
    const char* _v8;   // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4

    _v12 = errno;
    if(_v12 == 3) {
        _v8 = "matrix too large";
    } else {
        if(_v12 > 3) {
            if(_v12 == 5) {
                _v8 = "hash table full";
            } else {
                if(_v12 < 5) {
                    _v8 = "wrong matrix size";
                } else {
                    if(_v12 == 65536) {
                        _v8 = "single-column matrix expected";
                    } else {
                        if(_v12 == 65537) {
                            _v8 = "unknown opcode";
                        } else {
                            goto L19;
                        }
                    }
                }
            }
        } else {
            if(_v12 == 1) {
                _v8 = "failure";
            } else {
                if(_v12 > 1) {
                    _v8 = "malloc failed";
                } else {
                    if(_v12 == 0) {
                        _v8 = "success";
                    } else {
L19:
                        _v8 = "unknown error code";
                    }
                }
            }
        }
    }
    return _v8;
}

void quantum_error(int errno)
{// addr = 0x0804A01C  --  defined in 'error.c' at line 68
    signed int _v0;                        // _cfa_0
    _None* p;                              // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    quantum_reg* _v24;   // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    _unknown_ _v96;                        // _cfa_ffffffa0 (outparam)
    _unknown_ _v100;                       // _cfa_ffffff9c (outparam)
    int _t53;                              // _t53
    _unknown_ _t87;                        // _t87

    p = quantum_error_handler(0);
    if(p == 0) {
         *__esp = __imp__stdout;
        fflush();
        _t53 = errno;
        quantum_strerr(_t53);
        _v36 = _t53;
        _v40 = "ERROR: %s\n";
         *__esp = __imp__stderr;
        fprintf();
         *__esp = __imp__stderr;
        fflush();
        abort();
        _push(_t87);
        __esp = __esp - 56;
        quantum_sigma_x(_v28 + 1 + _v28 + 1, _v24);
        _v52 = 1;
        while(_v12 <= _a8) {
            _v20 = errno % _v0;
            _v16 = 1;
            while(_v16 < _v12) {
                _v20 = _v20 * _v20;
                _v20 = _v20 % _v0;
                _v16 = _v16 + 1;
            }
            mul_mod_n(_v0, _v20, _a12 + _a12 + _a12 + 1 + _v12, _a12, _a16);
            _v12 = _v12 + 1;
        }
        return;
    } else {
         *__esp = errno;
         *p();
        return;
    }
}

void quantum_exp_mod_n(int N, int x, int width_input, int width, quantum_reg* reg)
{// addr = 0x0804A088  --  defined in 'expn.c' at line 35
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int f;                                 // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    quantum_sigma_x(width + 1 + width + 1, reg);
    i = 1;
    while(i <= width_input) {
        f = x % N;
        j = 1;
        while(j < i) {
            f = f * f;
            f = f % N;
            j = j + 1;
        }
        mul_mod_n(N, f, width + width + width + 1 + i, width, reg);
        i = i + 1;
    }
}

void quantum_cnot(int control, int target, quantum_reg* reg)
{// addr = 0x0804A130  --  defined in 'gates.c' at line 42
    int i;                                 // _cfa_ffffffe8
    int qec;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    int _v68;                              // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    _unknown_ _t67;                        // _t67
    signed int _t69;                       // _t69
    _unknown_ _t77;                        // _t77
    signed int _t78;                       // _t78
    signed int _t79;                       // _t79
    signed char _t86;                      // _t86
    signed char _t87;                      // _t87
    intOrPtr _t89;                         // _t89
    unsigned int _t91;                     // _t91
    signed int _t92;                       // _t92
    signed int _t97;                       // _t97

    quantum_qec_get_status( &qec, 0);
    if(qec != 0) {
        quantum_cnot_ft(control, target, reg);
        return;
    }
    _v68 = target;
    _v72 = control;
    if(quantum_objcode_put(1) == 0) {
        i = 0;
        while(reg->size > i) {
            _t67 = reg->node + (i << 4);
            _t91 =  *(_t67 + 12);
            _t86 = control;
            _t69 = (_t91 << 32 |  *(_t67 + 8)) >> _t86;
            _t92 = _t91 >> _t86;
            if((_t86 & 32) != 0) {
                _t69 = _t92;
            }
            if((_t69 & 1) != 0) {
                _v40 = reg->node + (i << 4);
                _t77 = reg->node + (i << 4);
                __esi =  *(_t77 + 8);
                __edi =  *(_t77 + 12);
                _t87 = target;
                _v52 = 1;
                _v48 = 0;
                _t78 = _v52;
                _t97 = (_v48 << 32 | _t78) << _t87;
                _t79 = _t78 << _t87;
                if((_t87 & 32) != 0) {
                    _t97 = _t79;
                    _t79 = 0;
                }
                _t89 = _v40;
                 *(_t89 + 8) = __esi ^ _t79;
                 *(_t89 + 12) = __edi ^ _t97;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_toffoli(int control1, int control2, int target, quantum_reg* reg)
{// addr = 0x0804A252  --  defined in 'gates.c' at line 70
    int i;                                 // _cfa_ffffffe8
    int qec;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    int _v64;                              // _cfa_ffffffc0 (outparam)
    int _v68;                              // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    _unknown_ _t85;                        // _t85
    signed int _t87;                       // _t87
    _unknown_ _t92;                        // _t92
    signed int _t94;                       // _t94
    _unknown_ _t102;                       // _t102
    signed int _t103;                      // _t103
    signed int _t104;                      // _t104
    signed char _t112;                     // _t112
    signed char _t113;                     // _t113
    signed char _t114;                     // _t114
    intOrPtr _t116;                        // _t116
    unsigned int _t118;                    // _t118
    signed int _t119;                      // _t119
    unsigned int _t121;                    // _t121
    signed int _t122;                      // _t122
    signed int _t127;                      // _t127

    quantum_qec_get_status( &qec, 0);
    if(qec == 0) {
        _v64 = target;
        _v68 = control2;
        _v72 = control1;
        if(quantum_objcode_put(2) != 0) {
            return;
        }
        i = 0;
        while(reg->size > i) {
            _t85 = reg->node + (i << 4);
            _t118 =  *(_t85 + 12);
            _t112 = control1;
            _t87 = (_t118 << 32 |  *(_t85 + 8)) >> _t112;
            _t119 = _t118 >> _t112;
            if((_t112 & 32) != 0) {
                _t87 = _t119;
            }
            if((_t87 & 1) != 0) {
                _t92 = reg->node + (i << 4);
                _t121 =  *(_t92 + 12);
                _t113 = control2;
                _t94 = (_t121 << 32 |  *(_t92 + 8)) >> _t113;
                _t122 = _t121 >> _t113;
                if((_t113 & 32) != 0) {
                    _t94 = _t122;
                }
                if((_t94 & 1) != 0) {
                    _v40 = reg->node + (i << 4);
                    _t102 = reg->node + (i << 4);
                    __esi =  *(_t102 + 8);
                    __edi =  *(_t102 + 12);
                    _t114 = target;
                    _v52 = 1;
                    _v48 = 0;
                    _t103 = _v52;
                    _t127 = (_v48 << 32 | _t103) << _t114;
                    _t104 = _t103 << _t114;
                    if((_t114 & 32) != 0) {
                        _t127 = _t104;
                        _t104 = 0;
                    }
                    _t116 = _v40;
                     *(_t116 + 8) = __esi ^ _t104;
                     *(_t116 + 12) = __edi ^ _t127;
                }
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    quantum_toffoli_ft(control1, control2, target, reg);
}

void quantum_unbounded_toffoli(int controlling, quantum_reg* reg)
{// addr = 0x0804A3B3  --  defined in 'gates.c' at line 107
    va_list bits;      // _cfa_ffffffe8
    int target;                            // _cfa_ffffffe4
    int* controls;                         // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int j;                                 // _cfa_ffffffd8
    intOrPtr _v56;                         // _cfa_ffffffc8
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    int* _t76;                             // _t76
    _unknown_ _t100;                       // _t100
    signed int _t101;                      // _t101
    signed int _t102;                      // _t102
    _unknown_ _t108;                       // _t108
    signed int _t113;                      // _t113
    signed char _t125;                     // _t125
    intOrPtr _t127;                        // _t127
    signed char _t128;                     // _t128
    int* _t129;                            // _t129
    int* _t130;                            // _t130
    signed int _t135;                      // _t135
    unsigned int _t139;                    // _t139
    signed int _t140;                      // _t140
    signed int _t142;                      // _t142

    _t76 = controlling << 2;
     *__esp = _t76;
    malloc();
    controls = _t76;
    if(controls == 0) {
        quantum_error(2);
    }
    quantum_memman(controlling << 2);
    bits =  &_a12;
    i = 0;
    while(i < controlling) {
        _t129 = bits;
        bits =  &(_t129[1]);
        controls[i] =  *_t129;
        i = i + 1;
    }
    _t130 = bits;
    bits =  &(_t130[1]);
    target =  *_t130;
    i = 0;
    while(reg->size > i) {
        j = 0;
        while(j < controlling) {
            _t108 = reg->node + (i << 4);
            _t128 = controls[j];
            _t139 =  *(_t108 + 12);
            _t113 = (_t139 << 32 |  *(_t108 + 8)) >> _t128;
            _t140 = _t139 >> _t128;
            if((_t128 & 32) != 0) {
                _t113 = _t140;
            }
            if((_t113 & 1) != 0) {
                j = j + 1;
                continue;
            }
            break;
        }
        if(j == controlling) {
            _v56 = reg->node + (i << 4);
            _t100 = reg->node + (i << 4);
            _t142 =  *(_t100 + 8);
            __edi =  *(_t100 + 12);
            _t125 = target;
            _v68 = 1;
            _v64 = 0;
            _t101 = _v68;
            _t135 = (_v64 << 32 | _t101) << _t125;
            _t102 = _t101 << _t125;
            if((_t125 & 32) != 0) {
                _t135 = _t102;
                _t102 = 0;
            }
            _t127 = _v56;
             *(_t127 + 8) = _t142 ^ _t102;
             *(_t127 + 12) = __edi ^ _t135;
        }
        i = i + 1;
    }
     *__esp = controls;
    free();
    quantum_memman( ~(controlling << 2));
    quantum_decohere(reg);
}

void quantum_sigma_x(int target, quantum_reg* reg)
{// addr = 0x0804A535  --  defined in 'gates.c' at line 150
    int i;                                 // _cfa_ffffffe8
    int qec;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8 (outparam)
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    _unknown_ _t52;                        // _t52
    signed int _t53;                       // _t53
    signed int _t54;                       // _t54
    signed char _t60;                      // _t60
    intOrPtr _t62;                         // _t62
    signed int _t67;                       // _t67

    quantum_qec_get_status( &qec, 0);
    if(qec != 0) {
        quantum_sigma_x_ft(target, reg);
        return;
    }
    _v56 = target;
    if(quantum_objcode_put(3) == 0) {
        i = 0;
        while(reg->size > i) {
            _v40 = reg->node + (i << 4);
            _t52 = reg->node + (i << 4);
            __esi =  *(_t52 + 8);
            __edi =  *(_t52 + 12);
            _t60 = target;
            _v52 = 1;
            _v48 = 0;
            _t53 = _v52;
            _t67 = (_v48 << 32 | _t53) << _t60;
            _t54 = _t53 << _t60;
            if((_t60 & 32) != 0) {
                _t67 = _t54;
                _t54 = 0;
            }
            _t62 = _v40;
             *(_t62 + 8) = __esi ^ _t54;
             *(_t62 + 12) = __edi ^ _t67;
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_sigma_y(int target, quantum_reg* reg)
{// addr = 0x0804A615  --  defined in 'gates.c' at line 177
    int i;                                 // _cfa_ffffffe8
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t83;                        // _t83
    signed int _t84;                       // _t84
    signed int _t85;                       // _t85
    _unknown_ _t91;                        // _t91
    signed int _t93;                       // _t93
    signed char _t123;                     // _t123
    intOrPtr _t125;                        // _t125
    signed char _t126;                     // _t126
    signed int _t135;                      // _t135
    unsigned int _t139;                    // _t139
    signed int _t140;                      // _t140
    intOrPtr _t144;                        // _t144
    intOrPtr _t149;                        // _t149
    signed int _t152;                      // _t152
    intOrPtr* _t153;                       // _t153
    intOrPtr* _t154;                       // _t154

    _v72 = target;
    if(quantum_objcode_put(4) == 0) {
        i = 0;
        while(reg->size > i) {
            _v40 = reg->node + (i << 4);
            _t83 = reg->node + (i << 4);
            _t152 =  *(_t83 + 8);
            __edi =  *(_t83 + 12);
            _t123 = target;
            _v52 = 1;
            _v48 = 0;
            _t84 = _v52;
            _t135 = (_v48 << 32 | _t84) << _t123;
            _t85 = _t84 << _t123;
            if((_t123 & 32) != 0) {
                _t135 = _t85;
                _t85 = 0;
            }
            _t125 = _v40;
             *(_t125 + 8) = _t152 ^ _t85;
             *(_t125 + 12) = __edi ^ _t135;
            _t91 = reg->node + (i << 4);
            _t139 =  *(_t91 + 12);
            _t126 = target;
            _t93 = (_t139 << 32 |  *(_t91 + 8)) >> _t126;
            _t140 = _t139 >> _t126;
            if((_t126 & 32) != 0) {
                _t93 = _t140;
            }
            if((_t93 & 1) == 0) {
                _t153 = reg->node + (i << 4);
                _t101 = reg->node + (i << 4);
                _t144 =  *((intOrPtr*)(reg->node + (i << 4) + 4));
                 *_t153 = __mulsc3( *_t101, _t144, 0, -1082130432);
                _t153[1] = _t144;
            } else {
                _t154 = reg->node + (i << 4);
                _t113 = reg->node + (i << 4);
                _t149 =  *((intOrPtr*)(reg->node + (i << 4) + 4));
                 *_t154 = __mulsc3( *_t113, _t149, 0, 1065353216);
                _t154[1] = _t149;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_sigma_z(int target, quantum_reg* reg)
{// addr = 0x0804A79E  --  defined in 'gates.c' at line 203
    int i;                                 // _cfa_fffffff8
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    _unknown_ _t48;                        // _t48
    signed int _t50;                       // _t50
    intOrPtr* _t58;                        // _t58
    signed char _t62;                      // _t62
    intOrPtr* _t63;                        // _t63
    unsigned int _t65;                     // _t65
    signed int _t66;                       // _t66
    intOrPtr _t75;                         // _t75

    _v40 = target;
    if(quantum_objcode_put(5) == 0) {
        i = 0;
        while(reg->size > i) {
            _t48 = reg->node + (i << 4);
            _t65 =  *(_t48 + 12);
            _t62 = target;
            _t50 = (_t65 << 32 |  *(_t48 + 8)) >> _t62;
            _t66 = _t65 >> _t62;
            if((_t62 & 32) != 0) {
                _t50 = _t66;
            }
            if((_t50 & 1) != 0) {
                _t63 = reg->node + (i << 4);
                _t58 = reg->node + (i << 4);
                _v24 =  *_t58;
                _v24 = _t58[1];
                _t75 = _v24;
                asm("fxch st0, st1");
                asm("fchs");
                asm("fxch st0, st1");
                asm("fchs");
                asm("fxch st0, st1");
                _v24 = _t75;
                _v24 = _t75;
                 *_t63 = _v24;
                _t63[1] = _v24;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_swaptheleads(int width, quantum_reg* reg)
{// addr = 0x0804A85F  --  defined in 'gates.c' at line 224
    int i;                                 // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    int pat1;                              // _cfa_ffffffe0
    int pat2;                              // _cfa_ffffffdc
    int qec;                               // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    long long unsigned int l;              // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t114;                      // _t114
    signed int _t125;                      // _t125
    _unknown_ _t131;                       // _t131
    signed int _t153;                      // _t153
    signed int _t154;                      // _t154
    signed char _t156;                     // _t156
    signed char _t157;                     // _t157
    _unknown_ _t161;                       // _t161

    quantum_qec_get_status( &qec, 0);
    if(qec != 0) {
        i = 0;
        while(i < width) {
            quantum_cnot(i, width + i, reg);
            quantum_cnot(width + i, i, reg);
            quantum_cnot(i, width + i, reg);
            i = i + 1;
        }
        return;
    }
    i = 0;
    while(reg->size > i) {
        _v72 = width;
        if(quantum_objcode_put(14) == 0) {
            _t153 =  *(reg->node + (i << 4) + 8);
            _t156 = width;
            _t114 = 1 << _t156;
            if((_t156 & 32) != 0) {
                _t114 = 0;
            }
            pat1 = _t114 - 1 & _t153;
            pat2 = 0;
            j = 0;
            while(j < width) {
                _t154 =  *(reg->node + (i << 4) + 8);
                _t157 = width + j;
                _t125 = 1 << _t157;
                if((_t157 & 32) != 0) {
                    _t125 = 0;
                }
                pat2 = (_t154 & _t125) + pat2;
                j = j + 1;
            }
            _t131 = reg->node + (i << 4);
            asm("sbb edi, edx");
            l =  *((intOrPtr*)(_t131 + 8)) - pat1 + pat2;
            _v48 =  *((intOrPtr*)(_t131 + 12));
            l = l + (pat1 << width);
            asm("adc [ebp-0x2c], edx");
            l = l + (pat2 >> width);
            asm("adc [ebp-0x2c], edx");
            _t161 = reg->node + (i << 4);
             *((intOrPtr*)(_t161 + 8)) = l;
             *((intOrPtr*)(_t161 + 12)) = _v48;
            i = i + 1;
            continue;
        }
        break;
    }
}

void quantum_swaptheleads_omuln_controlled(int control, int width, quantum_reg* reg)
{// addr = 0x0804AA4B  --  defined in 'gates.c' at line 275
    int i;                                 // _cfa_fffffff8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = 0;
    while(i < width) {
        quantum_toffoli(control, width + i, width + width + i + 2, reg);
        quantum_toffoli(control, width + width + i + 2, width + i, reg);
        quantum_toffoli(control, width + i, width + width + i + 2, reg);
        i = i + 1;
    }
}

void quantum_gate1(int target, quantum_matrix m, quantum_reg* reg)
{// addr = 0x0804AAF9  --  defined in 'gates.c' at line 290
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int iset;                              // _cfa_ffffffd4
    int addsize;                           // _cfa_ffffffd0
    int decsize;                           // _cfa_ffffffcc
    int sorted;                            // _cfa_ffffffc8
    float limit;                           // _cfa_ffffffc4
    char* done;                            // _cfa_ffffffc0
    complex float _v68;                    // _cfa_ffffffbc
    complex float t;                       // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    complex float tnot;                    // _cfa_ffffffb0
    long long _v100;                       // _cfa_ffffff9c
    intOrPtr _v108;                        // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    intOrPtr _v160;                        // _cfa_ffffff60
    signed int _v168;                      // _cfa_ffffff58
    signed int _v172;                      // _cfa_ffffff54
    int* _v180;                            // _cfa_ffffff4c
    quantum_reg_node* _v184;   // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    int _v192;                             // _cfa_ffffff40 (outparam)
    int _v196;                             // _cfa_ffffff3c (outparam)
    signed int _v200;                      // _cfa_ffffff38 (outparam)
    char* _v204;                           // _cfa_ffffff34 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t446;                       // _t446
    signed int _t447;                      // _t447
    signed int _t448;                      // _t448
    int _t451;                             // _t451
    _unknown_ _t455;                       // _t455
    _unknown_ _t456;                       // _t456
    quantum_reg_node* _t463;   // _t463
    _unknown_ _t476;                       // _t476
    char* _t486;                           // _t486
    signed int _t496;                      // _t496
    signed int _t508;                      // _t508
    _unknown_ _t515;                       // _t515
    signed int _t516;                      // _t516
    signed int _t517;                      // _t517
    complex float* _t524;                  // _t524
    intOrPtr _t532;                        // _t532
    intOrPtr _t538;                        // _t538
    intOrPtr* _t542;                       // _t542
    intOrPtr* _t549;                       // _t549
    _unknown_ _t561;                       // _t561
    signed int _t562;                      // _t562
    signed int _t563;                      // _t563
    int _t576;                             // _t576
    _unknown_ _t609;                       // _t609
    int _t617;                             // _t617
    intOrPtr* _t618;                       // _t618
    quantum_reg_node* _t626;   // _t626
    intOrPtr _t641;                        // _t641
    intOrPtr _t647;                        // _t647
    intOrPtr _t656;                        // _t656
    intOrPtr _t662;                        // _t662
    intOrPtr _t672;                        // _t672
    intOrPtr _t678;                        // _t678
    int _t683;                             // _t683
    complex float* _t684;                  // _t684
    quantum_reg* _t688;   // _t688
    signed int _t690;                      // _t690
    quantum_reg* _t692;   // _t692
    signed char _t714;                     // _t714
    signed char _t722;                     // _t722
    _unknown_ _t724;                       // _t724
    intOrPtr* _t726;                       // _t726
    signed char _t727;                     // _t727
    signed char _t728;                     // _t728
    signed char _t743;                     // _t743
    intOrPtr _t745;                        // _t745
    signed int _t764;                      // _t764
    int* _t775;                            // _t775
    signed int _t778;                      // _t778
    int _t782;                             // _t782
    signed int _t800;                      // _t800
    complex float _t807;                   // _t807
    complex float _t810;                   // _t810
    signed int _t821;                      // _t821
    complex float _t826;                   // _t826
    complex float _t830;                   // _t830
    complex float _t834;                   // _t834
    complex float _t837;                   // _t837
    complex float _t842;                   // _t842
    complex float _t845;                   // _t845
    complex float _t850;                   // _t850
    complex float _t853;                   // _t853
    signed int _t859;                      // _t859
    signed int _t860;                      // _t860
    signed int _t862;                      // _t862
    signed int _t866;                      // _t866
    signed int _t869;                      // _t869
    intOrPtr* _t870;                       // _t870
    signed int _t871;                      // _t871
    intOrPtr* _t872;                       // _t872
    intOrPtr* _t873;                       // _t873
    intOrPtr* _t874;                       // _t874
    intOrPtr* _t875;                       // _t875
    intOrPtr* _t876;                       // _t876
    intOrPtr _t900;                        // _t900
    intOrPtr _t908;                        // _t908
    intOrPtr _t912;                        // _t912
    intOrPtr _t916;                        // _t916

    addsize = 0;
    decsize = 0;
    sorted = 1;
    tnot = 0;
    _v76 = 0;
    if(reg != 2 || m.rows != 2) {
        quantum_error(4);
    }
    quantum_reconstruct_hash( *(__ebp + 24));
    i = 0;
    while( *(__ebp + 24)->size > i) {
        _t446 =  *(__ebp + 24)->node + (i << 4);
        _t866 =  *(_t446 + 8);
        _t859 =  *(_t446 + 12);
        _t714 = target;
        _v172 = 1;
        _v168 = 0;
        _t447 = _v172;
        _t764 = (_v168 << 32 | _t447) << _t714;
        _t448 = _t447 << _t714;
        __eflags = _t714 & 32;
        if((_t714 & 32) != 0) {
            _t764 = _t448;
            _t448 = 0;
            __eflags = 0;
        }
        _t688 =  *(__ebp + 24);
        _v196 = _t688->width;
        _v192 = _t688->size;
        _v188 = _t688->hashw;
        _v184 = _t688->node;
        _v180 = _t688->hash;
        _v204 = _t866 ^ _t448;
        _v200 = _t859 ^ _t764;
        _t451 = quantum_get_state();
        __eflags = _t451 - -1;
        if(_t451 == -1) {
            addsize = addsize + 1;
            __eflags = addsize;
        }
        i = i + 1;
        __eflags = i;
    }
    _t463 =  *(__ebp + 24)->node;
    _v200 =  *(__ebp + 24)->size + addsize << 4;
    _v204 = _t463;
    realloc();
     *(__ebp + 24)->node = _t463;
    if( *(__ebp + 24)->node == 0) {
        quantum_error(2);
    }
    quantum_memman(addsize << 4);
    i = 0;
    while(i < addsize) {
        _t476 =  *(__ebp + 24)->node + ( *(__ebp + 24)->size + i << 4);
         *(_t476 + 8) = 0;
         *(_t476 + 12) = 0;
        _t775 =  *(__ebp + 24)->node + ( *(__ebp + 24)->size + i << 4);
         *_t775 = 0;
        _t775[1] = 0;
        i = i + 1;
        __eflags = i;
    }
    _t486 =  *(__ebp + 24)->size + addsize;
    _v200 = 1;
    _v204 = _t486;
    calloc();
    done = _t486;
    if(done == 0) {
        quantum_error(2);
    }
    quantum_memman( *(__ebp + 24)->size + addsize);
    k =  *(__ebp + 24)->size;
    _t722 =  *( *(__ebp + 24));
    _t778 = (0 << 32 | 1) << _t722;
    _t496 = 1 << _t722;
    if((_t722 & 32) != 0) {
        _t778 = _t496;
        _t496 = 0;
    }
    _push(_t778);
    _push(_t496);
    asm("fild qword [esp]");
    __esp =  &_v204;
    tword [ebp-0x88] = __fp0;
    if(_t778 < 0) {
        asm("faddp st1, st0");
        tword [ebp-0x88] = tword [ebp-0x88];
    }
    _v100 = tword [ebp-0x88];
    asm("fld1");
    asm("fdivrp st1, st0");
    asm("fmulp st1, st0");
    limit =  *134562624;
    i = 0;
    while( *(__ebp + 24)->size > i) {
        __eflags = done[i] & 255;
        if((done[i] & 255) != 0) {
L51:
            i = i + 1;
            __eflags = i;
            continue;
        }
        _t690 =  *( *(__ebp + 24)->node + (i << 4) + 8);
        _t727 = target;
        _t508 = 1 << _t727;
        __eflags = _t727 & 32;
        if((_t727 & 32) != 0) {
            _t508 = 0;
            __eflags = 0;
        }
        iset = _t508 & _t690;
        tnot = 0;
        _v76 = 0;
        _t515 =  *(__ebp + 24)->node + (i << 4);
        _t869 =  *(_t515 + 8);
        _t860 =  *(_t515 + 12);
        _t728 = target;
        _v172 = 1;
        _v168 = 0;
        _t516 = _v172;
        _t800 = (_v168 << 32 | _t516) << _t728;
        _t517 = _t516 << _t728;
        __eflags = _t728 & 32;
        if((_t728 & 32) != 0) {
            _t800 = _t517;
            _t517 = 0;
            __eflags = 0;
        }
        _t692 =  *(__ebp + 24);
        _v196 = _t692->width;
        _v192 = _t692->size;
        _v188 = _t692->hashw;
        _v184 = _t692->node;
        _v180 = _t692->hash;
        _v204 = _t869 ^ _t517;
        _v200 = _t860 ^ _t800;
        j = quantum_get_state();
        _t524 =  *(__ebp + 24)->node + (i << 4);
        t =  *_t524;
        _v68 = _t524[0];
        __eflags = j;
        if(j >= 0) {
            _t683 = j << 4;
            __eflags = _t683;
            _t684 =  *(__ebp + 24)->node + _t683;
            tnot =  *_t684;
            _v76 = _t684[0];
        }
        __eflags = iset;
        if(iset == 0) {
            _t870 =  *(__ebp + 24)->node + (i << 4);
            _t529 = _a16;
            _t807 = t;
            _t532 = __mulsc3( *_a16,  *((intOrPtr*)(_t529 + 4)), _t807, _v68);
            _v120 = _t807;
            _t535 = _a16 + 8;
            __eflags = _a16 + 8;
            _t810 = tnot;
            _t538 = __mulsc3( *_t535,  *((intOrPtr*)(_t535 + 4)), _t810, _v76);
            _v160 = _t532;
            _v160 = _t538;
            _v160 = _t810;
            _t900 = _v160;
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            _v160 = _t900;
            _v160 = _t900;
             *_t870 = _v160;
            _t870[1] = _v160;
        } else {
            _t876 =  *(__ebp + 24)->node + (i << 4);
            _t669 = _a16 + 16;
            _t850 = tnot;
            _t672 = __mulsc3( *(_a16 + 16),  *((intOrPtr*)(_t669 + 4)), _t850, _v76);
            _v124 = _t850;
            _t675 = _a16 + 24;
            _t853 = t;
            _t678 = __mulsc3( *((intOrPtr*)(_a16 + 24)),  *((intOrPtr*)(_t675 + 4)), _t853, _v68);
            _v160 = _t672;
            _v160 = _t678;
            _v160 = _t853;
            _t908 = _v160;
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            _v160 = _t908;
            _v160 = _t908;
             *_t876 = _v160;
            _t876[1] = _v160;
        }
        __eflags = j;
        if(__eflags < 0) {
            _t542 = _a16 + 8;
            _v160 =  *_t542;
            _v160 = _t542[1];
            asm("fldz");
            asm("fucomp st2");
            asm("fnstsw ax");
            st1 = _v160;
            asm("sahf");
            asm("fldz");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            __eflags = __eflags == 0 & __eflags ?_? 0 & __eflags == 0 & __eflags ?_? 0;
            if(__eflags == 0) {
L41:
                _t549 = _a16 + 16;
                _v160 =  *_t549;
                _v160 = _t549[1];
                asm("fldz");
                asm("fucomp st2");
                asm("fnstsw ax");
                st1 = _v160;
                asm("sahf");
                asm("fldz");
                asm("fucompp");
                asm("fnstsw ax");
                asm("sahf");
                if(i == 0) {
L43:
                    _v108 =  *(__ebp + 24)->node + (k << 4);
                    _t561 =  *(__ebp + 24)->node + (i << 4);
                    _t871 =  *(_t561 + 8);
                    _t862 =  *(_t561 + 12);
                    _t743 = target;
                    _v172 = 1;
                    _v168 = 0;
                    _t562 = _v172;
                    _t821 = (_v168 << 32 | _t562) << _t743;
                    _t563 = _t562 << _t743;
                    __eflags = _t743 & 32;
                    if((_t743 & 32) != 0) {
                        _t821 = _t563;
                        _t563 = 0;
                        __eflags = 0;
                    }
                    _t745 = _v108;
                     *(_t745 + 8) = _t871 ^ _t563;
                     *(_t745 + 12) = _t862 ^ _t821;
                    __eflags = iset;
                    if(iset == 0) {
                        _t872 =  *(__ebp + 24)->node + (k << 4);
                        _t570 = _a16 + 16;
                        __eflags = _a16 + 16;
                        _t826 = t;
                         *_t872 = __mulsc3( *_t570,  *((intOrPtr*)(_t570 + 4)), _t826, _v68);
                        _t872[1] = _t826;
                    } else {
                        _t873 =  *(__ebp + 24)->node + (k << 4);
                        _t581 = _a16 + 8;
                        _t830 = t;
                         *_t873 = __mulsc3( *(_a16 + 8),  *((intOrPtr*)(_t581 + 4)), _t830, _v68);
                        _t873[1] = _t830;
                    }
                    k = k + 1;
                    __eflags = k;
                    goto L49;
                }
                __eflags = iset;
                if(__eflags == 0) {
                    break;
                }
                goto L43;
            }
            __eflags = iset;
            if(__eflags != 0) {
                break;
            }
            goto L41;
        } else {
            __eflags = iset;
            if(iset == 0) {
                _t874 =  *(__ebp + 24)->node + (j << 4);
                _t638 = _a16 + 16;
                _t834 = t;
                _t641 = __mulsc3( *(_a16 + 16),  *((intOrPtr*)(_t638 + 4)), _t834, _v68);
                _v112 = _t834;
                _t644 = _a16 + 24;
                _t837 = tnot;
                _t647 = __mulsc3( *((intOrPtr*)(_a16 + 24)),  *((intOrPtr*)(_t644 + 4)), _t837, _v76);
                _v160 = _t641;
                _v160 = _t647;
                _v160 = _t837;
                _t912 = _v160;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v160 = _t912;
                _v160 = _t912;
                 *_t874 = _v160;
                _t874[1] = _v160;
            } else {
                _t875 =  *(__ebp + 24)->node + (j << 4);
                _t653 = _a16;
                _t842 = tnot;
                _t656 = __mulsc3( *_a16,  *((intOrPtr*)(_t653 + 4)), _t842, _v76);
                _v116 = _t842;
                _t659 = _a16 + 8;
                _t845 = t;
                _t662 = __mulsc3( *(_a16 + 8),  *((intOrPtr*)(_t659 + 4)), _t845, _v68);
                _v160 = _t656;
                _v160 = _t662;
                _v160 = _t845;
                _t916 = _v160;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v160 = _t916;
                _v160 = _t916;
                 *_t875 = _v160;
                _t875[1] = _v160;
            }
L49:
            __eflags = j;
            if(j >= 0) {
                _t576 =  &(done[j]);
                __eflags = _t576;
                 *_t576 = 1;
            }
            goto L51;
        }
    }
     *(__ebp + 24)->size =  *(__ebp + 24)->size + addsize;
    _v204 = done;
    free();
    quantum_memman( ~( *(__ebp + 24)->size));
    if(sorted != 0) {
L65:
        quantum_decohere( *(__ebp + 24));
        return;
    }
    i = 0;
    j = 0;
    while( *(__ebp + 24)->size > i) {
        _t782 =  *(__ebp + 24)->node + (i << 4);
        __eflags = _t782;
        _v204 =  *_t782;
        _v200 =  *(_t782 + 4);
        quantum_prob_inline();
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags <= 0) {
            __eflags = j;
            if(j != 0) {
                _t724 =  *(__ebp + 24)->node + (i - j << 4);
                _t609 =  *(__ebp + 24)->node + (i << 4);
                 *((intOrPtr*)(_t724 + 8)) =  *((intOrPtr*)(_t609 + 8));
                 *((intOrPtr*)(_t724 + 12)) =  *((intOrPtr*)(_t609 + 12));
                _t726 =  *(__ebp + 24)->node + (i - j << 4);
                _t617 = i << 4;
                __eflags = _t617;
                _t618 =  *(__ebp + 24)->node + _t617;
                 *_t726 =  *_t618;
                _t726[1] = _t618[1];
            }
        } else {
            j = j + 1;
            decsize = decsize + 1;
        }
        i = i + 1;
        __eflags = i;
    }
    if(decsize != 0) {
         *(__ebp + 24)->size =  *(__ebp + 24)->size - decsize;
        _t626 =  *(__ebp + 24)->node;
        _v200 =  *(__ebp + 24)->size << 4;
        _v204 = _t626;
        realloc();
         *(__ebp + 24)->node = _t626;
        if( *(__ebp + 24)->node == 0) {
            quantum_error(2);
        }
        quantum_memman( ~(decsize << 4));
    }
    goto L65;
}

void quantum_reconstruct_hash(quantum_reg* reg)
{// addr = 0x0804B509  --  defined in 'qureg.h' at line 159
    int i;                                 // _cfa_fffffff8
    quantum_reg* _v32;   // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ _t40;                        // _t40

    i = 0;
    while(1 << reg->hashw > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t40 = reg->node + (i << 4);
        _v32 = reg;
        _v36 = i;
         *__esp =  *((intOrPtr*)(_t40 + 8));
        _v40 =  *((intOrPtr*)(_t40 + 12));
        quantum_add_hash();
        i = i + 1;
    }
}

void quantum_add_hash(long long unsigned int a, int pos, quantum_reg* reg)
{// addr = 0x0804B58C  --  defined in 'qureg.h' at line 131
    int i;                                 // _cfa_fffffff8
    int mark;                              // _cfa_fffffff4
    int _v24;                              // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8

    _v28 = a;
    _v24 = pos;
    mark = 0;
    _v36 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 8));
     *__esp = _v28;
    _v40 = _v24;
    i = quantum_hash64();
    do {
    } while( *( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 16)) + (i << 2)) != 0);
     *( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 16)) + (i << 2)) =  &(reg->width);
}

unsigned int quantum_hash64(long long unsigned int key, int width)
{// addr = 0x0804B62B  --  defined in 'qureg.h' at line 91
    unsigned int k32;                      // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4

    _v28 = key;
    _v24 = width;
    k32 = _v24 ^ _v28;
    k32 = k32 * -1640562687;
    k32 = k32 >> 32 -  *((intOrPtr*)(__ebp + 16));
    return k32;
}

int quantum_get_state(long long unsigned int a, quantum_reg reg)
{// addr = 0x0804B66D  --  defined in 'qureg.h' at line 106
    int i;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0

    _v28 = a;
    _v24 = reg.width;
    if(_a20 != 0) {
        _v44 = _a20;
         *__esp = _v28;
        _v48 = _v24;
        i = quantum_hash64();
        while( *((intOrPtr*)(_a28 + (i << 2))) != 0) {
            if(( *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 8) ^ _v28 |  *0x0000000D ^ _v24) != 0) {
                i = i + 1;
                if(1 << _a20 == i) {
                    i = 0;
                }
                continue;
            }
            _v32 =  *((intOrPtr*)(_a28 + (i << 2))) - 1;
L9:
            return _v32;
        }
        _v32 = -1;
        goto L9;
    }
    _v32 = _v28;
    goto L9;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0804B733  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    float _t16;                            // _t16

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    r = __fp0;
     *__esp = a;
    _t16 = _a8;
    _v24 = _t16;
    quantum_imag();
    i = __fp0;
    asm("faddp st1, st0");
    return _t16;
}

float quantum_real(complex float a)
{// addr = 0x0804B773  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

float quantum_imag(complex float a)
{// addr = 0x0804B78C  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

void quantum_gate2(int target1, int target2, quantum_matrix m, quantum_reg* reg)
{// addr = 0x0804B7A8  --  defined in 'gates.c' at line 451
    complex float[3] psi_sub;              // _cfa_ffffff8c
    int[3] base;                           // _cfa_ffffffac
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int l;                                 // _cfa_ffffffd4
    int addsize;                           // _cfa_ffffffd0
    int decsize;                           // _cfa_ffffffcc
    float limit;                           // _cfa_ffffffc8
    char* done;                            // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    int[1] bits;                           // _cfa_ffffffbc
    long long _v132;                       // _cfa_ffffff7c
    intOrPtr _v140;                        // _cfa_ffffff74
    intOrPtr _v144;                        // _cfa_ffffff70
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    signed int _v156;                      // _cfa_ffffff64
    intOrPtr _v192;                        // _cfa_ffffff40
    signed int _v200;                      // _cfa_ffffff38
    signed int _v204;                      // _cfa_ffffff34
    signed int _v208;                      // _cfa_ffffff30
    signed int _v212;                      // _cfa_ffffff2c
    signed int _v216;                      // _cfa_ffffff28
    signed int _v220;                      // _cfa_ffffff24
    int* _v228;                            // _cfa_ffffff1c
    quantum_reg_node* _v232;   // _cfa_ffffff18
    int _v236;                             // _cfa_ffffff14
    int[1]* _v240;                         // _cfa_ffffff10 (outparam)
    int _v244;                             // _cfa_ffffff0c (outparam)
    signed int _v248;                      // _cfa_ffffff08 (outparam)
    quantum_reg_node* _v252;   // _cfa_ffffff04 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t471;                       // _t471
    _unknown_ _t479;                       // _t479
    signed int _t480;                      // _t480
    signed int _t481;                      // _t481
    int _t484;                             // _t484
    _unknown_ _t488;                       // _t488
    signed int _t489;                      // _t489
    signed int _t490;                      // _t490
    int _t493;                             // _t493
    quantum_reg_node* _t498;   // _t498
    _unknown_ _t511;                       // _t511
    char* _t521;                           // _t521
    signed int _t531;                      // _t531
    _unknown_ _t542;                       // _t542
    _unknown_ _t550;                       // _t550
    signed int _t551;                      // _t551
    signed int _t552;                      // _t552
    _unknown_ _t560;                       // _t560
    signed int _t561;                      // _t561
    signed int _t562;                      // _t562
    _unknown_ _t570;                       // _t570
    signed int _t571;                      // _t571
    signed int _t572;                      // _t572
    signed int _t574;                      // _t574
    signed int _t581;                      // _t581
    intOrPtr* _t587;                       // _t587
    intOrPtr* _t603;                       // _t603
    _unknown_ _t640;                       // _t640
    int _t648;                             // _t648
    intOrPtr* _t649;                       // _t649
    quantum_reg_node* _t658;   // _t658
    quantum_reg* _t668;   // _t668
    quantum_reg* _t670;   // _t670
    quantum_reg* _t672;   // _t672
    quantum_reg* _t674;   // _t674
    signed int _t676;                      // _t676
    signed int _t677;                      // _t677
    signed char _t684;                     // _t684
    signed char _t691;                     // _t691
    signed char _t698;                     // _t698
    _unknown_ _t700;                       // _t700
    intOrPtr* _t702;                       // _t702
    signed char _t704;                     // _t704
    signed char _t713;                     // _t713
    signed char _t722;                     // _t722
    signed char _t725;                     // _t725
    signed int _t728;                      // _t728
    signed int _t736;                      // _t736
    signed int _t741;                      // _t741
    int* _t749;                            // _t749
    signed int _t752;                      // _t752
    int _t756;                             // _t756
    signed int _t775;                      // _t775
    signed int _t781;                      // _t781
    signed int _t787;                      // _t787
    signed int _t789;                      // _t789
    quantum_reg* _t790;   // _t790
    int* _t795;                            // _t795
    intOrPtr _t800;                        // _t800
    signed int _t803;                      // _t803
    signed int _t804;                      // _t804
    signed int _t805;                      // _t805
    signed int _t806;                      // _t806
    signed int _t807;                      // _t807
    intOrPtr* _t808;                       // _t808
    signed int _t809;                      // _t809
    signed int _t810;                      // _t810
    signed int _t811;                      // _t811
    signed int _t812;                      // _t812
    signed int _t813;                      // _t813
    signed int _t815;                      // _t815
    intOrPtr _t844;                        // _t844

    addsize = 0;
    decsize = 0;
    if(reg != 4 || m.rows != 4) {
        quantum_error(4);
    }
    i = 0;
    while(1 <<  *(__ebp + 28)->hashw > i) {
         *(__ebp + 28)->hash[i] = 0;
        i = i + 1;
        __eflags = i;
    }
    i = 0;
    while( *(__ebp + 28)->size > i) {
        _t471 =  *(__ebp + 28)->node + (i << 4);
        _v240 =  *(__ebp + 28);
        _v244 = i;
        _v252 =  *(_t471 + 8);
        _v248 =  *(_t471 + 12);
        quantum_add_hash();
        i = i + 1;
        __eflags = i;
    }
    i = 0;
    while( *(__ebp + 28)->size > i) {
        _t479 =  *(__ebp + 28)->node + (i << 4);
        _t809 =  *(_t479 + 8);
        _t803 =  *(_t479 + 12);
        _t684 = target1;
        _v212 = 1;
        _v208 = 0;
        _t480 = _v212;
        _t736 = (_v208 << 32 | _t480) << _t684;
        _t481 = _t480 << _t684;
        __eflags = _t684 & 32;
        if((_t684 & 32) != 0) {
            _t736 = _t481;
            _t481 = 0;
            __eflags = 0;
        }
        _t668 =  *(__ebp + 28);
        _v244 =  *_t668;
        _v240 = _t668->size;
        _v236 = _t668->hashw;
        _v232 = _t668->node;
        _v228 = _t668->hash;
        _v252 = _t809 ^ _t481;
        _v248 = _t803 ^ _t736;
        _t484 = quantum_get_state();
        __eflags = _t484 - -1;
        if(_t484 == -1) {
            addsize = addsize + 1;
            __eflags = addsize;
        }
        _t488 =  *(__ebp + 28)->node + (i << 4);
        _t810 =  *(_t488 + 8);
        _t804 =  *(_t488 + 12);
        _t691 = target2;
        _v212 = 1;
        _v208 = 0;
        _t489 = _v212;
        _t741 = (_v208 << 32 | _t489) << _t691;
        _t490 = _t489 << _t691;
        __eflags = _t691 & 32;
        if((_t691 & 32) != 0) {
            _t741 = _t490;
            _t490 = 0;
            __eflags = 0;
        }
        _t670 =  *(__ebp + 28);
        _v244 =  *_t670;
        _v240 = _t670->size;
        _v236 = _t670->hashw;
        _v232 = _t670->node;
        _v228 = _t670->hash;
        _v252 = _t810 ^ _t490;
        _v248 = _t804 ^ _t741;
        _t493 = quantum_get_state();
        __eflags = _t493 - -1;
        if(_t493 == -1) {
            addsize = addsize + 1;
            __eflags = addsize;
        }
        i = i + 1;
        __eflags = i;
    }
    _t498 =  *(__ebp + 28)->node;
    _v248 =  *(__ebp + 28)->size + addsize << 4;
    _v252 = _t498;
    realloc();
     *(__ebp + 28)->node = _t498;
    if( *(__ebp + 28)->node == 0) {
        quantum_error(4);
    }
    quantum_memman(addsize << 4);
    i = 0;
    while(i < addsize) {
        _t511 =  *(__ebp + 28)->node + ( *(__ebp + 28)->size + i << 4);
         *(_t511 + 8) = 0;
         *(_t511 + 12) = 0;
        _t749 =  *(__ebp + 28)->node + ( *(__ebp + 28)->size + i << 4);
         *_t749 = 0;
        _t749[1] = 0;
        i = i + 1;
        __eflags = i;
    }
    _t521 =  *(__ebp + 28)->size + addsize;
    _v248 = 1;
    _v252 = _t521;
    calloc();
    done = _t521;
    if(done == 0) {
        quantum_error(4);
    }
    quantum_memman( *(__ebp + 28)->size + addsize);
    l =  *(__ebp + 28)->size;
    _t698 =  *( *(__ebp + 28));
    _t752 = (0 << 32 | 1) << _t698;
    _t531 = 1 << _t698;
    if((_t698 & 32) != 0) {
        _t752 = _t531;
        _t531 = 0;
    }
    _push(_t752);
    _push(_t531);
    asm("fild qword [esp]");
    __esp =  &_v252;
    tword [ebp-0xa8] = __fp0;
    if(_t752 < 0) {
        asm("faddp st1, st0");
        tword [ebp-0xa8] = tword [ebp-0xa8];
    }
    _v132 = tword [ebp-0xa8];
    asm("fld1");
    asm("fdivrp st1, st0");
    asm("fdivp st1, st0");
    limit =  *134562632;
    bits = target1;
    _v64 = target2;
    i = 0;
    while( *(__ebp + 28)->size > i) {
        __eflags = done[i] & 255;
        if((done[i] & 255) != 0) {
L52:
            i = i + 1;
            __eflags = i;
            continue;
        }
        _t542 =  *(__ebp + 28)->node + (i << 4);
        _v240 =  &bits;
        _v244 = 2;
        _v252 =  *(_t542 + 8);
        _v248 =  *(_t542 + 12);
        j = quantum_bitmask();
         *(__ebp + j * 4 - 80) = i;
        _v156 = j ^ 1;
        _t550 =  *(__ebp + 28)->node + (i << 4);
        _t811 =  *(_t550 + 8);
        _t805 =  *(_t550 + 12);
        _t704 = target2;
        _v212 = 1;
        _v208 = 0;
        _t551 = _v212;
        _t775 = (_v208 << 32 | _t551) << _t704;
        _t552 = _t551 << _t704;
        __eflags = _t704 & 32;
        if((_t704 & 32) != 0) {
            _t775 = _t552;
            _t552 = 0;
            __eflags = 0;
        }
        _t672 =  *(__ebp + 28);
        _v244 =  *_t672;
        _v240 = _t672->size;
        _v236 = _t672->hashw;
        _v232 = _t672->node;
        _v228 = _t672->hash;
        _v252 = _t811 ^ _t552;
        _v248 = _t805 ^ _t775;
         *(__ebp + _v156 * 4 - 80) = quantum_get_state();
        _v152 = j ^ 2;
        _t560 =  *(__ebp + 28)->node + (i << 4);
        _t812 =  *(_t560 + 8);
        _t806 =  *(_t560 + 12);
        _t713 = target1;
        _v212 = 1;
        _v208 = 0;
        _t561 = _v212;
        _t781 = (_v208 << 32 | _t561) << _t713;
        _t562 = _t561 << _t713;
        __eflags = _t713 & 32;
        if((_t713 & 32) != 0) {
            _t781 = _t562;
            _t562 = 0;
            __eflags = 0;
        }
        _t674 =  *(__ebp + 28);
        _v244 =  *_t674;
        _v240 = _t674->size;
        _v236 = _t674->hashw;
        _v232 = _t674->node;
        _v228 = _t674->hash;
        _v252 = _t812 ^ _t562;
        _v248 = _t806 ^ _t781;
         *(__ebp + _v152 * 4 - 80) = quantum_get_state();
        _v148 = j ^ 3;
        _t570 =  *(__ebp + 28)->node + (i << 4);
        _t813 =  *(_t570 + 8);
        _t807 =  *(_t570 + 12);
        _t722 = target1;
        _v212 = 1;
        _v208 = 0;
        _t571 = _v212;
        _t787 = (_v208 << 32 | _t571) << _t722;
        _t572 = _t571 << _t722;
        __eflags = _t722 & 32;
        if((_t722 & 32) != 0) {
            _t787 = _t572;
            _t572 = 0;
            __eflags = 0;
        }
        _t574 = _t813 ^ _t572;
        _t789 = _t807 ^ _t787;
        _v204 = target2;
        _v220 = 1;
        _v216 = 0;
        _t676 = _v220;
        _t725 = _v204 & 255;
        _t815 = (_v216 << 32 | _t676) << _t725;
        _t677 = _t676 << _t725;
        __eflags = _t725 & 32;
        if((_t725 & 32) != 0) {
            _t815 = _t677;
            _t677 = 0;
            __eflags = 0;
        }
        _v204 = _t677;
        _v200 = _t815;
        _t790 =  *(__ebp + 28);
        _v244 =  *_t790;
        _v240 = _t790->size;
        _v236 = _t790->hashw;
        _v232 = _t790->node;
        _v228 = _t790->hash;
        _v252 = _v204 ^ _t574;
        _v248 = _v200 ^ _t789;
         *(__ebp + _v148 * 4 - 80) = quantum_get_state();
        j = 0;
        while(1) {
            __eflags = j - 3;
            if(j > 3) {
                break;
            }
            _t581 = j;
            __eflags =  *((intOrPtr*)(__ebp + _t581 * 4 - 80)) - -1;
            if( *((intOrPtr*)(__ebp + _t581 * 4 - 80)) == -1) {
                 *(__ebp + j * 4 - 80) = l;
                l = l + 1;
                __eflags = l;
            }
            _t728 = j;
            _t587 =  *(__ebp + 28)->node + ( *(__ebp + j * 4 - 80) << 4);
             *((intOrPtr*)(__ebp + _t728 * 8 - 112)) =  *_t587;
             *((intOrPtr*)(__ebp + _t728 * 8 - 108)) = _t587[1];
            j = j + 1;
            __eflags = j;
        }
        j = 0;
        while(1) {
            __eflags = j - 3;
            if(j > 3) {
                goto L52;
            }
            _t795 =  *(__ebp + 28)->node + ( *(__ebp + j * 4 - 80) << 4);
             *_t795 = 0;
            _t795[1] = 0;
            k = 0;
            while(1) {
                __eflags = k - 3;
                if(k > 3) {
                    break;
                }
                _t808 =  *(__ebp + 28)->node + ( *(__ebp + j * 4 - 80) << 4);
                _t603 =  *(__ebp + 28)->node + ( *(__ebp + j * 4 - 80) << 4);
                _v140 =  *_t603;
                _v144 = _t603[1];
                _t608 = _a20 + (reg * j + k << 3);
                _t609 = k;
                _t800 =  *((intOrPtr*)(__ebp + k * 8 - 112));
                _v192 = __mulsc3( *((intOrPtr*)(_a20 + (reg * j + k << 3))),  *((intOrPtr*)(_t608 + 4)), _t800,  *((intOrPtr*)(__ebp + _t609 * 8 - 108)));
                _v192 = _t800;
                _t844 = _v192;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v192 = _t844;
                _v192 = _t844;
                 *_t808 = _v192;
                _t808[1] = _v192;
                k = k + 1;
                __eflags = k;
            }
            done[ *(__ebp + j * 4 - 80)] = 1;
            j = j + 1;
            __eflags = j;
        }
        goto L52;
    }
     *(__ebp + 28)->size =  *(__ebp + 28)->size + addsize;
    _v252 = done;
    free();
    quantum_memman( ~( *(__ebp + 28)->size));
    i = 0;
    j = 0;
    while( *(__ebp + 28)->size > i) {
        _t756 =  *(__ebp + 28)->node + (i << 4);
        __eflags = _t756;
        _v252 =  *_t756;
        _v248 =  *(_t756 + 4);
        quantum_prob_inline();
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags <= 0) {
            __eflags = j;
            if(j != 0) {
                _t700 =  *(__ebp + 28)->node + (i - j << 4);
                _t640 =  *(__ebp + 28)->node + (i << 4);
                 *((intOrPtr*)(_t700 + 8)) =  *((intOrPtr*)(_t640 + 8));
                 *((intOrPtr*)(_t700 + 12)) =  *((intOrPtr*)(_t640 + 12));
                _t702 =  *(__ebp + 28)->node + (i - j << 4);
                _t648 = i << 4;
                __eflags = _t648;
                _t649 =  *(__ebp + 28)->node + _t648;
                 *_t702 =  *_t649;
                _t702[1] = _t649[1];
            }
        } else {
            j = j + 1;
            decsize = decsize + 1;
        }
        i = i + 1;
        __eflags = i;
    }
    if(decsize != 0) {
         *(__ebp + 28)->size =  *(__ebp + 28)->size - decsize;
        _t658 =  *(__ebp + 28)->node;
        _v248 =  *(__ebp + 28)->size << 4;
        _v252 = _t658;
        realloc();
         *(__ebp + 28)->node = _t658;
        if( *(__ebp + 28)->node == 0) {
            quantum_error(2);
        }
        quantum_memman( ~(decsize << 4));
    }
    quantum_decohere( *(__ebp + 28));
}

int quantum_bitmask(long long unsigned int a, int width, int* bits)
{// addr = 0x0804C059  --  defined in 'qureg.h' at line 172
    int i;                                 // _cfa_fffffff8
    int mask;                              // _cfa_fffffff4
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t32;                       // _t32
    signed char _t37;                      // _t37
    unsigned int _t39;                     // _t39
    signed int _t40;                       // _t40

    _v28 = a;
    _v24 = width;
    mask = 0;
    i = 0;
    while(i < bits) {
        _t37 =  *((i << 2) +  *((intOrPtr*)(__ebp + 20)));
        _t39 = _v24;
        _t32 = (_t39 << 32 | _v28) >> _t37;
        _t40 = _t39 >> _t37;
        if((_t37 & 32) != 0) {
            _t32 = _t40;
        }
        if((_t32 & 1) != 0) {
            mask = mask + (1 << i);
        }
        i = i + 1;
    }
    return mask;
}

void quantum_hadamard(int target, quantum_reg* reg)
{// addr = 0x0804C0BF  --  defined in 'gates.c' at line 596
    int _v16;                              // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    quantum_reg* _v64;   // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4 (outparam)
    int _t56;                              // _t56
    intOrPtr* _t57;                        // _t57
    intOrPtr* _t58;                        // _t58
    intOrPtr* _t59;                        // _t59

    _v72 = target;
    if(quantum_objcode_put(6) == 0) {
        _v68 = 2;
        quantum_new_matrix( &_v44, 2);
        __esp = __esp - 4;
        m.rows = _v44;
        _v20 = _v40;
        _v16 = _v36;
        _t56 = _v16;
         *_t56 = 1060439283;
         *((intOrPtr*)(_t56 + 4)) = 0;
        _t57 = _v16 + 8;
         *_t57 = 1060439283;
        _t57[1] = 0;
        _t58 = _v16 + 16;
         *_t58 = 1060439283;
        _t58[1] = 0;
        _t59 = _v16 + 24;
         *_t59 = -1087044365;
        _t59[1] = 0;
        _v64 = reg;
        _v76 = m.rows;
        _v72 = _v20;
        _v68 = _v16;
         *__esp = target;
        quantum_gate1();
        quantum_delete_matrix( &m);
        return;
    }
}

void quantum_walsh(int width, quantum_reg* reg)
{// addr = 0x0804C195  --  defined in 'gates.c' at line 617
    int i;                                 // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    i = 0;
    while(i < width) {
        quantum_hadamard(i, reg);
        i = i + 1;
    }
}

void quantum_r_x(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C1C4  --  defined in 'gates.c' at line 629
    _unknown_ _v8;                         // _cfa_fffffff8
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    intOrPtr* _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    long long _v60;                        // _cfa_ffffffc4
    char _v68;                             // _cfa_ffffffbc
    intOrPtr _v80;                         // _cfa_ffffffb0
    long long _v116;                       // _cfa_ffffff8c
    long long _v120;                       // _cfa_ffffff88
    long long _v124;                       // _cfa_ffffff84
    long long _v128;                       // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    quantum_reg* _v136;   // _cfa_ffffff78
    long long _v140;                       // _cfa_ffffff74
    long long _v144;                       // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    intOrPtr* _t103;                       // _t103
    intOrPtr* _t104;                       // _t104
    intOrPtr* _t105;                       // _t105
    intOrPtr* _t106;                       // _t106
    int _t113;                             // _t113
    int _t116;                             // _t116
    intOrPtr _t120;                        // _t120
    quantum_reg* _t122;   // _t122
    intOrPtr _t126;                        // _t126
    int _t128;                             // _t128

    _push(__ebx);
    __esp = __esp - 132;
    _v132 = gamma;
    _v136 = target;
    if(quantum_objcode_put(7) == 0) {
        _v132 = 2;
        quantum_new_matrix( &_v44, 2);
        __esp = __esp - 4;
        m.rows = _v44;
        _v20 = _v40;
        _v16 = _v36;
        _t103 = _v16;
        _t113 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t113;
        cos();
        _v48 = _t113;
        _v80 = _v48;
         *_t103 = _v80;
        _t103[1] = 0;
        _t104 = _v16 + 8;
        _t116 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t116;
        sin();
        asm("fldz");
        asm("fld1");
        asm("fchs");
        _v116 = _t116;
        asm("fldz");
        _v124 = _t116;
        _v132 = _t116;
        _v140 = _t116;
         *__esp =  &_v68;
        __muldc3();
        __esp = __esp - 4;
        asm("fxch st0, st1");
        _v48 = _v60;
        asm("fxch st0, st1");
        _v48 = _v48;
        _t120 = _v48;
        asm("fxch st0, st1");
        _v80 = _t120;
        _v80 = _t120;
         *_t104 = _v80;
        _t104[1] = _v80;
        _t105 = _v16 + 16;
        _t122 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t122;
        sin();
        asm("fldz");
        asm("fld1");
        asm("fchs");
        _v120 = _t122;
        asm("fldz");
        _v128 = _t122;
        _v136 = _t122;
        _v144 = _t122;
         *__esp =  &_v68;
        __muldc3();
        __esp = __esp - 4;
        asm("fxch st0, st1");
        _v48 = _v60;
        asm("fxch st0, st1");
        _v48 = _v48;
        _t126 = _v48;
        asm("fxch st0, st1");
        _v80 = _t126;
        _v80 = _t126;
         *_t105 = _v80;
        _t105[1] = _v80;
        _t106 = _v16 + 24;
        _t128 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t128;
        cos();
        _v48 = _t128;
        _v80 = _v48;
         *_t106 = _v80;
        _t106[1] = 0;
        _v136 = reg;
        _v148 = m.rows;
        _v144 = _v20;
        _v140 = _v16;
         *__esp = target;
        quantum_gate1();
        quantum_delete_matrix( &m);
    }
}

void quantum_r_y(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C382  --  defined in 'gates.c' at line 650
    _unknown_ _v8;                         // _cfa_fffffff8
    int _v16;                              // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    intOrPtr _v64;                         // _cfa_ffffffc0
    quantum_reg* _v96;   // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94 (outparam)
    int _t77;                              // _t77
    intOrPtr* _t78;                        // _t78
    intOrPtr* _t79;                        // _t79
    intOrPtr* _t80;                        // _t80
    int _t87;                              // _t87
    int _t90;                              // _t90
    int _t93;                              // _t93
    int _t96;                              // _t96

    _push(__ebx);
    __esp = __esp - 100;
    _v100 = gamma;
    _v104 = target;
    if(quantum_objcode_put(8) == 0) {
        _v100 = 2;
        quantum_new_matrix( &_v44, 2);
        __esp = __esp - 4;
        m.rows = _v44;
        _v20 = _v40;
        _v16 = _v36;
        _t77 = _v16;
        _t87 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t87;
        cos();
        _v48 = _t87;
        _v64 = _v48;
         *_t77 = _v64;
         *((intOrPtr*)(_t77 + 4)) = 0;
        _t78 = _v16 + 8;
        _t90 =  *134562644;
        asm("fdivp st1, st0");
         *__esp = _t90;
        sin();
        _v48 = _t90;
        _v64 = _v48;
         *_t78 = _v64;
        _t78[1] = 0;
        _t79 = _v16 + 16;
        _t93 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t93;
        sin();
        _v48 = _t93;
        _v64 = _v48;
         *_t79 = _v64;
        _t79[1] = 0;
        _t80 = _v16 + 24;
        _t96 =  *134562640;
        asm("fdivp st1, st0");
         *__esp = _t96;
        cos();
        _v48 = _t96;
        _v64 = _v48;
         *_t80 = _v64;
        _t80[1] = 0;
        _v96 = reg;
        _v108 = m.rows;
        _v104 = _v20;
        _v100 = _v16;
         *__esp = target;
        quantum_gate1();
        quantum_delete_matrix( &m);
    }
}

void quantum_r_z(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C4CB  --  defined in 'gates.c' at line 671
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    long long _v36;                        // _cfa_ffffffdc (outparam)
    int _v40;                              // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t67;                        // _t67
    signed int _t69;                       // _t69
    signed char _t100;                     // _t100
    unsigned int _t108;                    // _t108
    signed int _t109;                      // _t109
    complex float _t113;                   // _t113
    complex float _t118;                   // _t118
    intOrPtr* _t121;                       // _t121
    intOrPtr* _t122;                       // _t122

    _v36 = gamma;
    _v40 = target;
    if(quantum_objcode_put(9) == 0) {
        asm("fdivp st1, st0");
        z = quantum_cexp( *134562640);
        _v20 = __edx;
        i = 0;
        while(reg->size > i) {
            _t67 = reg->node + (i << 4);
            _t108 =  *(_t67 + 12);
            _t100 = target;
            _t69 = (_t108 << 32 |  *(_t67 + 8)) >> _t100;
            _t109 = _t108 >> _t100;
            if((_t100 & 32) != 0) {
                _t69 = _t109;
            }
            if((_t69 & 1) == 0) {
                _t121 = reg->node + (i << 4);
                _t77 = reg->node + (i << 4);
                _t113 = z;
                 *_t121 = __divsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t77 + 4)), _t113, _v20);
                _t121[1] = _t113;
            } else {
                _t122 = reg->node + (i << 4);
                _t88 = reg->node + (i << 4);
                _t118 = z;
                 *_t122 = __mulsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t88 + 4)), _t118, _v20);
                _t122[1] = _t118;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_phase_scale(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C612  --  defined in 'gates.c' at line 695
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    long long _v36;                        // _cfa_ffffffdc (outparam)
    int _v40;                              // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    complex float _t60;                    // _t60

    _v36 = gamma;
    _v40 = target;
    if(quantum_objcode_put(11) == 0) {
        z = quantum_cexp(gamma);
        _v20 = __edx;
        i = 0;
        while(reg->size > i) {
            __esi = reg->node + (i << 4);
            _t43 = reg->node + (i << 4);
            _t60 = z;
             *__esi = __mulsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t43 + 4)), _t60, _v20);
            __esi[1] = _t60;
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_phase_kick(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C6CD  --  defined in 'gates.c' at line 717
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    long long _v36;                        // _cfa_ffffffdc (outparam)
    int _v40;                              // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ _t53;                        // _t53
    signed int _t55;                       // _t55
    signed char _t73;                      // _t73
    unsigned int _t79;                     // _t79
    signed int _t80;                       // _t80
    complex float _t84;                    // _t84

    _v36 = gamma;
    _v40 = target;
    if(quantum_objcode_put(10) == 0) {
        z = quantum_cexp(gamma);
        _v20 = __edx;
        i = 0;
        while(reg->size > i) {
            _t53 = reg->node + (i << 4);
            _t79 =  *(_t53 + 12);
            _t73 = target;
            _t55 = (_t79 << 32 |  *(_t53 + 8)) >> _t73;
            _t80 = _t79 >> _t73;
            if((_t73 & 32) != 0) {
                _t55 = _t80;
            }
            if((_t55 & 1) != 0) {
                __esi = reg->node + (i << 4);
                _t63 = reg->node + (i << 4);
                _t84 = z;
                 *__esi = __mulsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t63 + 4)), _t84, _v20);
                __esi[1] = _t84;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
}

void quantum_cond_phase(int control, int target, quantum_reg* reg)
{// addr = 0x0804C7B9  --  defined in 'gates.c' at line 739
    int i;                                 // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    long long _v36;                        // _cfa_ffffffdc
    float _v40;                            // _cfa_ffffffd8
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    int _v68;                              // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    char _v76;                             // _cfa_ffffffb4 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    signed int _t73;                       // _t73
    _unknown_ _t81;                        // _t81
    signed int _t83;                       // _t83
    _unknown_ _t88;                        // _t88
    signed int _t90;                       // _t90
    signed char _t108;                     // _t108
    signed char _t110;                     // _t110
    signed char _t111;                     // _t111
    signed int _t116;                      // _t116
    unsigned int _t119;                    // _t119
    signed int _t120;                      // _t120
    unsigned int _t122;                    // _t122
    signed int _t123;                      // _t123
    complex float _t127;                   // _t127

    _v68 = target;
    _v72 = control;
    if(quantum_objcode_put(12) != 0) {
        return;
    }
    _t108 = control - target;
    _t116 = (0 << 32 | 1) << _t108;
    _t73 = 1 << _t108;
    if((_t108 & 32) != 0) {
        _t116 = _t73;
        _t73 = 0;
    }
    _push(_t116);
    _push(_t73);
    asm("fild qword [esp]");
    __esp =  &_v76;
    tword [ebp-0x38] = __fp0;
    if(_t116 < 0) {
        asm("faddp st1, st0");
        tword [ebp-0x38] = tword [ebp-0x38];
    }
    _v36 = tword [ebp-0x38];
    asm("fdivrp st1, st0");
    _v40 =  *134562648;
    z = quantum_cexp(_v40);
    _v20 = _t116;
    i = 0;
    while(reg->size > i) {
        _t81 = reg->node + (i << 4);
        _t119 =  *(_t81 + 12);
        _t110 = control;
        _t83 = (_t119 << 32 |  *(_t81 + 8)) >> _t110;
        _t120 = _t119 >> _t110;
        if((_t110 & 32) != 0) {
            _t83 = _t120;
        }
        if((_t83 & 1) != 0) {
            _t88 = reg->node + (i << 4);
            _t122 =  *(_t88 + 12);
            _t111 = target;
            _t90 = (_t122 << 32 |  *(_t88 + 8)) >> _t111;
            _t123 = _t122 >> _t111;
            if((_t111 & 32) != 0) {
                _t90 = _t123;
            }
            if((_t90 & 1) != 0) {
                __esi = reg->node + (i << 4);
                _t98 = reg->node + (i << 4);
                _t127 = z;
                 *__esi = __mulsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t98 + 4)), _t127, _v20);
                __esi[1] = _t127;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
}

void quantum_cond_phase_inv(int control, int target, quantum_reg* reg)
{// addr = 0x0804C929  --  defined in 'gates.c' at line 763
    int i;                                 // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    long long _v36;                        // _cfa_ffffffdc
    float _v40;                            // _cfa_ffffffd8
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char _v76;                             // _cfa_ffffffb4 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    signed int _t66;                       // _t66
    _unknown_ _t74;                        // _t74
    signed int _t76;                       // _t76
    _unknown_ _t81;                        // _t81
    signed int _t83;                       // _t83
    signed char _t101;                     // _t101
    signed char _t103;                     // _t103
    signed char _t104;                     // _t104
    signed int _t109;                      // _t109
    unsigned int _t112;                    // _t112
    signed int _t113;                      // _t113
    unsigned int _t115;                    // _t115
    signed int _t116;                      // _t116
    complex float _t120;                   // _t120

    _t101 = control - target;
    _t109 = (0 << 32 | 1) << _t101;
    _t66 = 1 << _t101;
    if((_t101 & 32) != 0) {
        _t109 = _t66;
        _t66 = 0;
    }
    _push(_t109);
    _push(_t66);
    asm("fild qword [esp]");
    __esp =  &_v76;
    tword [ebp-0x38] = __fp0;
    if(_t109 < 0) {
        asm("faddp st1, st0");
        tword [ebp-0x38] = tword [ebp-0x38];
    }
    _v36 = tword [ebp-0x38];
    asm("fdivrp st1, st0");
    _v40 =  *134562656;
    z = quantum_cexp(_v40);
    _v20 = _t109;
    i = 0;
    while(reg->size > i) {
        _t74 = reg->node + (i << 4);
        _t112 =  *(_t74 + 12);
        _t103 = control;
        _t76 = (_t112 << 32 |  *(_t74 + 8)) >> _t103;
        _t113 = _t112 >> _t103;
        if((_t103 & 32) != 0) {
            _t76 = _t113;
        }
        if((_t76 & 1) != 0) {
            _t81 = reg->node + (i << 4);
            _t115 =  *(_t81 + 12);
            _t104 = target;
            _t83 = (_t115 << 32 |  *(_t81 + 8)) >> _t104;
            _t116 = _t115 >> _t104;
            if((_t104 & 32) != 0) {
                _t83 = _t116;
            }
            if((_t83 & 1) != 0) {
                __esi = reg->node + (i << 4);
                _t91 = reg->node + (i << 4);
                _t120 = z;
                 *__esi = __mulsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t91 + 4)), _t120, _v20);
                __esi[1] = _t120;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
}

void quantum_cond_phase_kick(int control, int target, float gamma, quantum_reg* reg)
{// addr = 0x0804CA77  --  defined in 'gates.c' at line 784
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    long long _v48;                        // _cfa_ffffffd0 (outparam)
    int _v52;                              // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ _t69;                        // _t69
    signed int _t71;                       // _t71
    _unknown_ _t76;                        // _t76
    signed int _t78;                       // _t78
    signed char _t96;                      // _t96
    signed char _t97;                      // _t97
    unsigned int _t103;                    // _t103
    signed int _t104;                      // _t104
    unsigned int _t106;                    // _t106
    signed int _t107;                      // _t107
    complex float _t111;                   // _t111

    _v48 = gamma;
    _v52 = target;
    _v56 = control;
    if(quantum_objcode_put(12) != 0) {
        return;
    }
    z = quantum_cexp(gamma);
    _v20 = __edx;
    i = 0;
    while(reg->size > i) {
        _t69 = reg->node + (i << 4);
        _t103 =  *(_t69 + 12);
        _t96 = control;
        _t71 = (_t103 << 32 |  *(_t69 + 8)) >> _t96;
        _t104 = _t103 >> _t96;
        if((_t96 & 32) != 0) {
            _t71 = _t104;
        }
        if((_t71 & 1) != 0) {
            _t76 = reg->node + (i << 4);
            _t106 =  *(_t76 + 12);
            _t97 = target;
            _t78 = (_t106 << 32 |  *(_t76 + 8)) >> _t97;
            _t107 = _t106 >> _t97;
            if((_t97 & 32) != 0) {
                _t78 = _t107;
            }
            if((_t78 & 1) != 0) {
                __esi = reg->node + (i << 4);
                _t86 = reg->node + (i << 4);
                _t111 = z;
                 *__esi = __mulsc3( *((intOrPtr*)(reg->node + (i << 4))),  *((intOrPtr*)(_t86 + 4)), _t111, _v20);
                __esi[1] = _t111;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
}

int quantum_gate_counter(int inc)
{// addr = 0x0804CB9A  --  defined in 'gates.c' at line 810
    if(inc <= 0) {
        if(inc < 0) {
            counter = 0;
        }
    } else {
        counter = counter + inc;
    }
    return counter;
}

long unsigned int quantum_memman(long int change)
{// addr = 0x0804CBCC  --  defined in 'matrix.c' at line 35
    mem = mem + change;
    if(mem > max) {
        max = mem;
    }
    return mem;
}

quantum_matrix quantum_new_matrix(int cols, int rows)
{// addr = 0x0804CBFC  --  defined in 'matrix.c' at line 50
    signed int _v8;                        // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4
    quantum_matrix m;   // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _t24;                       // _t24

    m.rows =  *(__ebp + 16);
    _v12 = rows;
    _t24 = rows *  *(__ebp + 16);
    _v24 = 8;
     *__esp = _t24;
    calloc();
    _v8 = _t24;
    if(_v8 == 0) {
        quantum_error(2);
    }
    quantum_memman( *(__ebp + 16) * rows << 3);
     *cols = m.rows;
     *(cols + 4) = _v12;
     *(cols + 8) = _v8;
    return cols;
}

void quantum_delete_matrix(quantum_matrix* m)
{// addr = 0x0804CC70  --  defined in 'matrix.c' at line 74
     *__esp = m->t;
    free();
    quantum_memman( ~(m->rows * m->cols << 3));
    m->t = 0;
}

void quantum_print_matrix(quantum_matrix m)
{// addr = 0x0804CCAD  --  defined in 'matrix.c' at line 90
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int z;                                 // _cfa_fffffff0
    long long _v28;                        // _cfa_ffffffe4
    long long _v48;                        // _cfa_ffffffd0
    long long _v56;                        // _cfa_ffffffc8
    intOrPtr* _t54;                        // _t54
    intOrPtr* _t56;                        // _t56

    __fp0 = __fp0;
    z = 0;
    do {
        __ecx = z;
        z = z + 1;
    } while(1 << __cl - m.rows < 0);
    z = z - 1;
    i = 0;
    while(m.rows > i) {
        j = 0;
        while(_a8 > j) {
            _t54 = _a12 + (_a8 * i + j << 3);
             *__esp =  *_t54;
            _v56 = _t54[1];
            quantum_imag();
            _v28 = __fp0;
            _t56 = _a12 + (_a8 * i + j << 3);
             *__esp =  *_t56;
            _v56 = _t56[1];
            quantum_real();
            __fp0 = _v28;
            _v48 = __fp0;
            _v56 = __fp0;
             *__esp = "%g %+gi ";
            printf();
            j = j + 1;
        }
         *__esp = 10;
        putchar();
        i = i + 1;
    }
     *__esp = 10;
    putchar();
}

float quantum_imag(complex float a)
{// addr = 0x0804CD85  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

float quantum_real(complex float a)
{// addr = 0x0804CDA1  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

quantum_matrix quantum_mmult(quantum_matrix A, quantum_matrix B)
{// addr = 0x0804CDBA  --  defined in 'matrix.c' at line 117
    char _v16;                             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    quantum_matrix C;   // _cfa_ffffffd8
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    int _v68;                              // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    intOrPtr* _t87;                        // _t87
    intOrPtr _t99;                         // _t99
    intOrPtr _t118;                        // _t118
    intOrPtr _t131;                        // _t131

    __esp = __esp - 60;
    if(_a12 !=  *((intOrPtr*)(__ebp + 24))) {
        quantum_error(4);
    }
    _v68 = B.rows;
    quantum_new_matrix( &C, _a24);
    __esp = __esp - 4;
    i = 0;
    while(_a24 > i) {
        j = 0;
        while(B.rows > j) {
            k = 0;
            while( *((intOrPtr*)(__ebp + 24)) > k) {
                __esi = _v32 + (_v36 * j + i << 3);
                _t87 = _v32 + (_v36 * j + i << 3);
                _v52 = _t87[1];
                _t92 = _a16 + (_a12 * j + k << 3);
                _t97 = _a28 + (_a24 * k + i << 3);
                _t118 =  *((intOrPtr*)(_a28 + (_a24 * k + i << 3)));
                _v56 =  *((intOrPtr*)(_a16 + (_a12 * j + k << 3) + 4));
                _t99 = __mulsc3( *_t92, _v56, _t118,  *((intOrPtr*)(_t97 + 4)));
                _v56 =  *_t87;
                _v56 = _t99;
                _v56 = _t118;
                _t131 = _v56;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v56 = _t131;
                _v56 = _t131;
                 *__esi = _v56;
                __esi[1] = _v56;
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
     *(A.rows) = C.rows;
     *(A.rows + 4) = _v36;
     *((intOrPtr*)(A.rows + 8)) = _v32;
    __esp =  &_v16;
    return A.rows;
}

double quantum_frand()
{// addr = 0x0804CF20  --  defined in 'measure.c' at line 42
    _unknown_ _v12;                        // _cfa_fffffff4

    __eax = __eax;
    rand();
    _push(__eax);
    asm("fild dword [esp]");
    asm("fdivp st1, st0");
    return __eax;
}

long long unsigned int quantum_measure(quantum_reg reg)
{// addr = 0x0804CF3D  --  defined in 'measure.c' at line 50
    int i;                                 // _cfa_fffffff8
    double r;                              // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _t27;                              // _t27
    _unknown_ _t35;                        // _t35
    int _t38;                              // _t38

    _t27 = quantum_objcode_put(128);
    __eflags = _t27;
    if(_t27 == 0) {
        quantum_frand();
        r = __fp0;
        i = 0;
        while(1) {
            __eflags = _a8 - i;
            if(_a8 <= i) {
                break;
            }
            _t38 = _a16 + (i << 4);
            __eflags = _t38;
             *__esp =  *_t38;
            _v40 =  *((intOrPtr*)(_t38 + 4));
            quantum_prob_inline();
            asm("fsubrp st1, st0");
            r = r;
            asm("fldz");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags < 0) {
                i = i + 1;
                __eflags = i;
                continue;
            } else {
                _t35 = _a16 + (i << 4);
                _v28 =  *(_t35 + 8);
                _v24 =  *(_t35 + 12);
            }
            goto L8;
        }
        _v28 = -1;
        _v24 = -1;
    } else {
        _v28 = 0;
        _v24 = 0;
    }
L8:
    return _v28;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0804CFE0  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    float _t16;                            // _t16

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    r = __fp0;
     *__esp = a;
    _t16 = _a8;
    _v24 = _t16;
    quantum_imag();
    i = __fp0;
    asm("faddp st1, st0");
    return _t16;
}

float quantum_real(complex float a)
{// addr = 0x0804D020  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

float quantum_imag(complex float a)
{// addr = 0x0804D039  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

int quantum_bmeasure(int pos, quantum_reg* reg)
{// addr = 0x0804D055  --  defined in 'measure.c' at line 87
    _unknown_ _v8;                         // _cfa_fffffff8
    int i;                                 // _cfa_fffffff0
    int result;                            // _cfa_ffffffec
    double pa;                             // _cfa_ffffffe4
    double r;                              // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    long long unsigned int pos2;           // _cfa_ffffffd4
    int* _v48;                             // _cfa_ffffffd0
    quantum_reg_node* _v52;   // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    quantum_reg out;   // _cfa_ffffffc0
    int _v80;                              // _cfa_ffffffb0
    int* _v96;                             // _cfa_ffffffa0
    quantum_reg_node* _v100;   // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    int _v112;                             // _cfa_ffffff90
    int _v116;                             // _cfa_ffffff8c
    int _v120;                             // _cfa_ffffff88
    int _t71;                              // _t71
    long long unsigned int _t73;           // _t73
    _unknown_ _t79;                        // _t79
    signed char _t106;                     // _t106
    signed int _t110;                      // _t110
    quantum_reg* _t114;   // _t114
    quantum_reg* _t115;   // _t115
    int _t117;                             // _t117
    double _t118;                          // _t118

    _t118 = __fp0;
    _push(__ebx);
    __esp = __esp - 116;
    result = 0;
    asm("fldz");
    pa = __fp0;
    _v120 = pos;
    _t71 = quantum_objcode_put(129);
    __eflags = _t71;
    if(_t71 == 0) {
        _t106 = pos;
        _t110 = (0 << 32 | 1) << _t106;
        _t73 = 1 << _t106;
        __eflags = _t106 & 32;
        if((_t106 & 32) != 0) {
            _t110 = _t73;
            _t73 = 0;
            __eflags = 0;
        }
        pos2 = _t73;
        _v40 = _t110;
        i = 0;
        while(1) {
            __eflags = reg->size - i;
            if(__eflags <= 0) {
                break;
            }
            _t79 = reg->node + (i << 4);
            __eflags =  *(_t79 + 8) & pos2 |  *(_t79 + 12) & _v40;
            if(( *(_t79 + 8) & pos2 |  *(_t79 + 12) & _v40) == 0) {
                _t117 = reg->node + (i << 4);
                __eflags = _t117;
                 *__esp =  *_t117;
                _v120 =  *(_t117 + 4);
                quantum_prob_inline();
                _t118 = pa;
                asm("faddp st1, st0");
                pa = _t118;
            }
            i = i + 1;
            __eflags = i;
        }
        quantum_frand();
        r = _t118;
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags > 0) {
            result = 1;
        }
        _t114 = reg;
        _v112 = _t114->width;
        _v108 = _t114->size;
        _v104 = _t114->hashw;
        _v100 = _t114->node;
        _v96 = _t114->hash;
        _v116 = result;
        _v120 = pos;
         *__esp =  &out;
        quantum_state_collapse();
        __esp = __esp - 4;
        quantum_delete_qureg_hashpreserve(reg);
        _t115 = reg;
         *_t115 = out.width;
        _t115->size = _v60;
        _t115->hashw = _v56;
        _t115->node = _v52;
        _t115->hash = _v48;
        _v80 = result;
    } else {
        _v80 = 0;
    }
    return _v80;
}

int quantum_bmeasure_bitpreserve(int pos, quantum_reg* reg)
{// addr = 0x0804D1A8  --  defined in 'measure.c' at line 128
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int size;                              // _cfa_ffffffe8
    int result;                            // _cfa_ffffffe4
    double d;                              // _cfa_ffffffdc
    double pa;                             // _cfa_ffffffd4
    double r;                              // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    long long unsigned int pos2;           // _cfa_ffffffc4
    int* _v64;                             // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    quantum_reg out;   // _cfa_ffffffb0
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr* _v108;                       // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    int _v116;                             // _cfa_ffffff8c
    double _v132;                          // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    _unknown_ _v144;                       // _cfa_ffffff70 (outparam)
    _unknown_ _v148;                       // _cfa_ffffff6c (outparam)
    int _v152;                             // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    int _t171;                             // _t171
    long long unsigned int _t173;          // _t173
    _unknown_ _t179;                       // _t179
    quantum_reg* _t188;   // _t188
    _unknown_ _t193;                       // _t193
    int _t218;                             // _t218
    quantum_reg* _t229;   // _t229
    int _t233;                             // _t233
    intOrPtr* _t234;                       // _t234
    _unknown_ _t241;                       // _t241
    int _t247;                             // _t247
    intOrPtr* _t248;                       // _t248
    signed char _t265;                     // _t265
    _unknown_ _t268;                       // _t268
    signed int _t274;                      // _t274
    double* _t282;                         // _t282
    intOrPtr _t291;                        // _t291
    quantum_reg* _t293;   // _t293
    int* _t295;                            // _t295
    double* _t297;                         // _t297
    int* _t299;                            // _t299
    int _t301;                             // _t301
    double _t302;                          // _t302
    double _t311;                          // _t311

    _t302 = __fp0;
    size = 0;
    result = 0;
    asm("fldz");
    d = __fp0;
    asm("fldz");
    pa = __fp0;
    _v152 = pos;
    _t171 = quantum_objcode_put(130);
    __eflags = _t171;
    if(_t171 == 0) {
        _t265 = pos;
        _t274 = (0 << 32 | 1) << _t265;
        _t173 = 1 << _t265;
        __eflags = _t265 & 32;
        if((_t265 & 32) != 0) {
            _t274 = _t173;
            _t173 = 0;
            __eflags = 0;
        }
        pos2 = _t173;
        _v56 = _t274;
        i = 0;
        while(1) {
            __eflags = reg->size - i;
            if(__eflags <= 0) {
                break;
            }
            _t179 = reg->node + (i << 4);
            __eflags =  *(_t179 + 8) & pos2 |  *(_t179 + 12) & _v56;
            if(( *(_t179 + 8) & pos2 |  *(_t179 + 12) & _v56) == 0) {
                _t301 = reg->node + (i << 4);
                __eflags = _t301;
                 *__esp =  *_t301;
                _v152 =  *(_t301 + 4);
                quantum_prob_inline();
                _t302 = pa;
                asm("faddp st1, st0");
                pa = _t302;
            }
            i = i + 1;
            __eflags = i;
        }
        quantum_frand();
        r = _t302;
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags > 0) {
            result = 1;
        }
        i = 0;
        while(1) {
            _t188 = reg;
            __eflags = _t188->size - i;
            if(_t188->size <= i) {
                break;
            }
            _t193 = reg->node + (i << 4);
            __eflags =  *(_t193 + 8) & pos2 |  *(_t193 + 12) & _v56;
            if(( *(_t193 + 8) & pos2 |  *(_t193 + 12) & _v56) == 0) {
                __eflags = result;
                if(result == 0) {
                    _t282 = reg->node + (i << 4);
                     *__esp =  *_t282;
                    _v152 = _t282[0];
                    quantum_prob_inline();
                    asm("faddp st1, st0");
                    d = d;
                    size = size + 1;
                    __eflags = size;
                } else {
                    _t295 = reg->node + (i << 4);
                     *_t295 = 0;
                    _t295[1] = 0;
                }
            } else {
                __eflags = result;
                if(result != 0) {
                    _t297 = reg->node + (i << 4);
                     *__esp =  *_t297;
                    _v152 = _t297[0];
                    quantum_prob_inline();
                    asm("faddp st1, st0");
                    d = d;
                    size = size + 1;
                } else {
                    _t299 = reg->node + (i << 4);
                     *_t299 = 0;
                    _t299[1] = 0;
                }
            }
            i = i + 1;
            __eflags = i;
        }
        _v76 = size;
        _t218 = size;
        _v152 = 16;
         *__esp = _t218;
        calloc();
        _v68 = _t218;
        __eflags = _v68;
        if(_v68 == 0) {
            quantum_error(2);
        }
        quantum_memman(size << 4);
        _v72 = reg->hashw;
        _v64 = reg->hash;
        out.width = reg->width;
        i = 0;
        j = 0;
        while(1) {
            _t229 = reg;
            __eflags = _t229->size - i;
            if(_t229->size <= i) {
                break;
            }
            _t233 = i << 4;
            __eflags = _t233;
            _t234 = reg->node + _t233;
            _v112 = _t234[1];
            _v136 =  *_t234;
            asm("fldz");
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0 || __eflags != 0) {
L28:
                _t268 = _v68 + (j << 4);
                _t241 = reg->node + (i << 4);
                 *((intOrPtr*)(_t268 + 8)) =  *((intOrPtr*)(_t241 + 8));
                 *((intOrPtr*)(_t268 + 12)) =  *((intOrPtr*)(_t241 + 12));
                _v108 = _v68 + (j << 4);
                _t247 = i << 4;
                __eflags = _t247;
                _t248 = reg->node + _t247;
                _v100 =  *_t248;
                _v104 = _t248[1];
                asm("fsqrt");
                _v132 = d;
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    _t311 = d;
                     *__esp = _t311;
                    sqrt();
                    _v132 = _t311;
                }
                _v96 = _v132;
                _v136 = _v96;
                _t291 = _v136;
                 *_v108 = __divsc3(_v100, _v104, _t291, 0);
                 *((intOrPtr*)(_v108 + 4)) = _t291;
                j = j + 1;
                __eflags = j;
                goto L32;
            } else {
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucompp");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    goto L28;
                } else {
L32:
                    i = i + 1;
                    __eflags = i;
                    continue;
                }
            }
        }
        quantum_delete_qureg_hashpreserve(reg);
        _t293 = reg;
         *_t293 = out.width;
        _t293->size = _v76;
        _t293->hashw = _v72;
        _t293->node = _v68;
        _t293->hash = _v64;
        _v116 = result;
        goto L35;
    } else {
        _v116 = 0;
L35:
        return _v116;
    }
}

void test_sum(int compare, int width, quantum_reg* reg)
{// addr = 0x0804D538  --  defined in 'oaddn.c' at line 42
    int i;                                 // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __esi;                       // r5
    signed int _t185;                      // _t185
    signed int _t188;                      // _t188
    signed char _t284;                     // _t284
    unsigned int _t299;                    // _t299
    signed int _t300;                      // _t300

    _t185 = compare;
    _t284 = width - 1;
    _t299 = _t185 >> 31;
    _t188 = (_t299 << 32 | _t185) >> _t284;
    _t300 = _t299 >> _t284;
    if((_t284 & 32) != 0) {
        _t188 = _t300;
    }
    if((_t188 & 1) == 0) {
        quantum_sigma_x(width + width - 1, reg);
        quantum_cnot(width + width - 1, width - 1, reg);
    } else {
        quantum_cnot(width + width - 1, width - 1, reg);
        quantum_sigma_x(width + width - 1, reg);
        quantum_cnot(width + width - 1, 0, reg);
    }
    i = width - 2;
    while(i > 0) {
        if((compare >> i & 1) == 0) {
            quantum_sigma_x(width + i, reg);
            quantum_toffoli(i + 1, width + i, i, reg);
        } else {
            quantum_toffoli(i + 1, width + i, i, reg);
            quantum_sigma_x(width + i, reg);
            quantum_toffoli(i + 1, width + i, 0, reg);
        }
        i = i - 1;
    }
    if((compare & 1) != 0) {
        quantum_sigma_x(width, reg);
        quantum_toffoli(width, 1, 0, reg);
    }
    quantum_toffoli(width + width + 1, 0, width + width, reg);
    if((compare & 1) != 0) {
        quantum_toffoli(width, 1, 0, reg);
        quantum_sigma_x(width, reg);
    }
    i = 1;
    while(width - 2 >= i) {
        if((compare >> i & 1) == 0) {
            quantum_toffoli(i + 1, width + i, i, reg);
            quantum_sigma_x(width + i, reg);
        } else {
            quantum_toffoli(i + 1, width + i, 0, reg);
            quantum_sigma_x(width + i, reg);
            quantum_toffoli(i + 1, width + i, i, reg);
        }
        i = i + 1;
    }
    if((compare >> width - 1 & 1) == 0) {
        quantum_cnot(width + width - 1, width - 1, reg);
        quantum_sigma_x(width + width - 1, reg);
        return;
    }
    quantum_cnot(width + width - 1, 0, reg);
    quantum_sigma_x(width + width - 1, reg);
    quantum_cnot(width + width - 1, width - 1, reg);
}

void muxfa(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804D8FE  --  defined in 'oaddn.c' at line 117
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(a == 0) {
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 3) {
        quantum_toffoli(L, c_in, c_out, reg);
        quantum_cnot(L, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 1) {
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
}

void muxfa_inv(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804DBA7  --  defined in 'oaddn.c' at line 158
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(a == 0) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
    }
    if(a == 3) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(L, c_in, reg);
        quantum_toffoli(L, c_in, c_out, reg);
    }
    if(a == 1) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
}

void muxha(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804DE50  --  defined in 'oaddn.c' at line 201
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(a == 0) {
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 3) {
        quantum_cnot(L, c_in, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 1) {
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
}

void muxha_inv(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804DF51  --  defined in 'oaddn.c' at line 229
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(a == 0) {
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 3) {
        quantum_cnot(b_in, c_in, reg);
        quantum_cnot(L, c_in, reg);
    }
    if(a == 1) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
}

void madd(int a, int a_inv, int width, quantum_reg* reg)
{// addr = 0x0804E052  --  defined in 'oaddn.c' at line 256
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int total;                             // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    total = width + width + 1 + width + width + 1;
    i = 0;
    while(width - 1 > i) {
        if((a >> i & 1) == 0) {
            j = 0;
        } else {
            j = 2;
        }
        if((a_inv >> i & 1) != 0) {
            j = j + 1;
        }
        muxfa(j, width + i, i, i + 1, width + width, width + width + 1, total, reg);
        i = i + 1;
    }
    j = 0;
    if((a >> width - 1 & 1) != 0) {
        j = 2;
    }
    if((a_inv >> width - 1 & 1) != 0) {
        j = j + 1;
    }
    muxha(j, width + width - 1, width - 1, width + width, width + width + 1, total, reg);
}

void madd_inv(int a, int a_inv, int width, quantum_reg* reg)
{// addr = 0x0804E187  --  defined in 'oaddn.c' at line 272
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int total;                             // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    total = width + width + 1 + width + width + 1;
    j = 0;
    if((a >> width - 1 & 1) != 0) {
        j = 2;
    }
    if((a_inv >> width - 1 & 1) != 0) {
        j = j + 1;
    }
    muxha_inv(j, width - 1, width + width - 1, width + width, width + width + 1, total, reg);
    i = width - 2;
    while(i >= 0) {
        if((a >> i & 1) == 0) {
            j = 0;
        } else {
            j = 2;
        }
        if((a_inv >> i & 1) != 0) {
            j = j + 1;
        }
        muxfa_inv(j, i, width + i, width + 1 + i, width + width, width + width + 1, total, reg);
        i = i - 1;
    }
}

void addn(int N, int a, int width, quantum_reg* reg)
{// addr = 0x0804E2BE  --  defined in 'oaddn.c' at line 290
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    test_sum(N - a, width, reg);
    madd((1 << width) + a - N, a, width, reg);
}

void addn_inv(int N, int a, int width, quantum_reg* reg)
{// addr = 0x0804E317  --  defined in 'oaddn.c' at line 297
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    quantum_cnot(width + width + 1, width + width, reg);
    madd_inv((1 << width) - a, N - a, width, reg);
    quantum_swaptheleads(width, reg);
    test_sum(a, width, reg);
}

void add_mod_n(int N, int a, int width, quantum_reg* reg)
{// addr = 0x0804E3A0  --  defined in 'oaddn.c' at line 307
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    addn(N, a, width, reg);
    addn_inv(N, a, width, reg);
}

void quantum_mu2char(long long unsigned int mu, unsigned char* buf)
{// addr = 0x0804E3E8  --  defined in 'objcode.c' at line 61
    int i;                                 // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    signed int _t45;                       // _t45
    signed int _t50;                       // _t50
    char* _t53;                            // _t53
    signed char _t54;                      // _t54
    signed char _t55;                      // _t55
    unsigned int _t57;                     // _t57
    unsigned int _t58;                     // _t58
    signed int _t61;                       // _t61

    _v36 = mu;
    _v32 = buf;
    size = 8;
    i = 0;
    while(i < size) {
        _t53 = i +  *((intOrPtr*)(__ebp + 16));
        _t54 =  !(i - size) * 8;
        _t57 = _v32;
        _t45 = (_t57 << 32 | _v36) >> _t54;
        _t58 = _t57 >> _t54;
        if((_t54 & 32) != 0) {
            _t45 = _t58;
        }
         *_t53 = _t45;
        _t55 =  !(i - size) * 8;
        _t61 = (0 << 32 | 1) << _t55;
        _t50 = 1 << _t55;
        if((_t55 & 32) != 0) {
            _t61 = _t50;
            _t50 = 0;
        }
        asm("adc edx, 0xffffffff");
        _v36 = _v36 & _t50 + -1;
        _v32 = _v32 & _t61;
        i = i + 1;
    }
}

void quantum_int2char(int j, unsigned char* buf)
{// addr = 0x0804E481  --  defined in 'objcode.c' at line 77
    int i;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1

    size = 4;
    i = 0;
    while(i < size) {
        _v40 = j;
        buf[i] = _v40 / (1 <<  !(i - size) * 8);
        _v36 = 1 <<  !(i - size) * 8;
        j = j % _v36;
        i = i + 1;
    }
}

void quantum_double2char(double d, unsigned char* buf)
{// addr = 0x0804E509  --  defined in 'objcode.c' at line 93
    int i;                                 // _cfa_fffffff8
    unsigned char* p;                      // _cfa_fffffff4
    unsigned char* _v24;                   // _cfa_ffffffe8
    char _v28;                             // _cfa_ffffffe4

    _v28 = d;
    _v24 = buf;
    p =  &_v28;
    i = 0;
    while(i <= 7) {
         *((char*)(i +  *((intOrPtr*)(__ebp + 16)))) = p[i] & 255;
        i = i + 1;
    }
}

long long unsigned int quantum_char2mu(unsigned char* buf)
{// addr = 0x0804E54B  --  defined in 'objcode.c' at line 102
    int i;                                 // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    long long unsigned int _v24;           // _cfa_ffffffe8
    long long unsigned int mu;             // _cfa_ffffffe4
    signed int _t34;                       // _t34

    mu = 0;
    _v24 = 0;
    size = 8;
    i = size - 1;
    while(i >= 0) {
        _t34 = (buf[i] & 0xff) << __cl;
        if((__cl & 32) != 0) {
            _t34 = 0;
        }
        mu = mu + _t34;
        asm("adc [ebp-0x14], edx");
        i = i - 1;
    }
    return mu;
}

int quantum_char2int(unsigned char* buf)
{// addr = 0x0804E5C6  --  defined in 'objcode.c' at line 115
    int i;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec

    j = 0;
    size = 4;
    i = size - 1;
    while(i >= 0) {
        j = j + ((buf[i] & 0xff) << __cl);
        i = i - 1;
    }
    return j;
}

double quantum_char2double(unsigned char* buf)
{// addr = 0x0804E61D  --  defined in 'objcode.c' at line 128
    double* d;                             // _cfa_fffffff8

    d = buf;
    return d;
}

void quantum_objcode_start()
{// addr = 0x0804E630  --  defined in 'objcode.c' at line 139
    opstatus = 1;
    allocated = 1;
     *__esp = 65536;
    malloc();
    objcode = __eax;
    if(objcode == 0) {
        quantum_error(2);
    }
    quantum_memman(65536);
}

void quantum_objcode_stop()
{// addr = 0x0804E67E  --  defined in 'objcode.c' at line 154
    opstatus = 0;
     *__esp = objcode;
    free();
    objcode = 0;
    quantum_memman( ~(allocated << 16));
    allocated = 0;
}

int quantum_objcode_put(unsigned char operation)
{// addr = 0x0804E6C3  --  defined in 'objcode.c' at line 166
    signed int _v8;                        // _cfa_fffffff8
    unsigned char[79] buf;                 // _cfa_ffffffa8
    int i;                                 // _cfa_ffffffa4
    int size;                              // _cfa_ffffffa0
    va_list args;      // _cfa_ffffff9c
    double d;                              // _cfa_ffffff94
    unsigned char* _v112;                  // _cfa_ffffff90
    long long unsigned int mu;             // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    int _v128;                             // _cfa_ffffff80
    intOrPtr _v148;                        // _cfa_ffffff6c (outparam)
    unsigned char* _v152;                  // _cfa_ffffff68 (outparam)
    int _t150;                             // _t150
    unsigned char* _t154;                  // _t154
    long long unsigned int* _t220;         // _t220
    int* _t234;                            // _t234
    int* _t235;                            // _t235
    int* _t236;                            // _t236
    double* _t237;                         // _t237
    int* _t238;                            // _t238
    int* _t239;                            // _t239
    int* _t240;                            // _t240
    double* _t241;                         // _t241
    int* _t242;                            // _t242
    int* _t243;                            // _t243
    int* _t244;                            // _t244
    long long unsigned int* _t245;         // _t245

    _v120 = operation;
    _v8 =  *gs:0x14];
    size = 0;
    if(opstatus != 0) {
        args =  &_a8;
        buf = _v120 & 255;
        _v124 = _v120 & 255;
        if(_v124 > 11) {
            if(_v124 == 128) {
L24:
                size = 1;
            } else {
                if(_v124 > 128) {
                    if(_v124 <= 130) {
                        goto L21;
                    } else {
                        if(_v124 == 255) {
                            goto L24;
                        } else {
                            goto L25;
                        }
                    }
                } else {
                    if(_v124 == 13) {
                        _t235 = args;
                        args =  &(_t235[1]);
                        i =  *_t235;
                        quantum_int2char(i,  &buf + 1);
                        _t236 = args;
                        args =  &(_t236[1]);
                        i =  *_t236;
                        quantum_int2char(i,  &buf + 5);
                        _t237 = args;
                        args =  &(_t237[1]);
                        d =  *_t237;
                        quantum_double2char(d,  &buf + 9);
                        size = 17;
                    } else {
                        if(_v124 < 13) {
                            goto L19;
                        } else {
                            if(_v124 == 14) {
                                goto L21;
                            } else {
                                goto L25;
                            }
                        }
                    }
                }
            }
        } else {
            if(_v124 >= 7) {
                _t240 = args;
                args =  &(_t240[1]);
                i =  *_t240;
                _t241 = args;
                args =  &(_t241[1]);
                d =  *_t241;
                quantum_int2char(i,  &buf + 1);
                quantum_double2char(d,  &buf + 5);
                size = 13;
            } else {
                if(_v124 == 2) {
                    _t242 = args;
                    args =  &(_t242[1]);
                    i =  *_t242;
                    quantum_int2char(i,  &buf + 1);
                    _t243 = args;
                    args =  &(_t243[1]);
                    i =  *_t243;
                    quantum_int2char(i,  &buf + 5);
                    _t244 = args;
                    args =  &(_t244[1]);
                    i =  *_t244;
                    quantum_int2char(i,  &buf + 9);
                    size = 13;
                } else {
                    if(_v124 > 2) {
L21:
                        _t234 = args;
                        args =  &(_t234[1]);
                        i =  *_t234;
                        quantum_int2char(i,  &buf + 1);
                        size = 5;
                    } else {
                        if(_v124 == 0) {
                            _t245 = args;
                            args =  &(_t245[1]);
                            _t220 = _t245;
                            mu =  *_t220;
                            _v112 = _t220[0];
                            _v148 =  &buf + 1;
                             *__esp = mu;
                            _v152 = _v112;
                            quantum_mu2char();
                            size = 9;
                        } else {
                            if(_v124 == 1) {
L19:
                                _t238 = args;
                                args =  &(_t238[1]);
                                i =  *_t238;
                                quantum_int2char(i,  &buf + 1);
                                _t239 = args;
                                args =  &(_t239[1]);
                                i =  *_t239;
                                quantum_int2char(i,  &buf + 5);
                                size = 9;
                            } else {
L25:
                                quantum_error(65537);
                            }
                        }
                    }
                }
            }
        }
        if(position + size >> 16 > position >> 16) {
            allocated = allocated + 1;
            _t154 = allocated << 16;
            _v152 = _t154;
             *__esp = objcode;
            realloc();
            objcode = _t154;
            if(objcode == 0) {
                quantum_error(2);
            }
            quantum_memman(65536);
        }
        i = 0;
        while(i < size) {
            objcode[position] =  *(__ebp + i - 84) & 255;
            position = position + 1;
            i = i + 1;
        }
        _v128 = 1;
    } else {
        _v128 = 0;
    }
    _t150 = _v128;
    if((_v8 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t150;
    }
    return _t150;
}

int quantum_objcode_write(char* file)
{// addr = 0x0804EA7D  --  defined in 'objcode.c' at line 267
    FILE* fhd;            // _cfa_fffffff8
    int _v24;                              // _cfa_ffffffe8
    int _v32;                              // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    long unsigned int _v40;                // _cfa_ffffffd8
    FILE* _t20;           // _t20

    if(opstatus != 0) {
        if(file == 0) {
            file = globalfile;
        }
        _v40 = L"wr";
        _t20 = file;
         *__esp = _t20;
        fopen();
        fhd = _t20;
        if(fhd != 0) {
            _v32 = fhd;
            _v36 = 1;
            _v40 = position;
             *__esp = objcode;
            fwrite();
             *__esp = fhd;
            fclose();
            _v24 = 0;
        } else {
            _v24 = -1;
        }
    } else {
        _v32 = __imp__stderr;
        _v36 = 73;
        _v40 = 1;
         *__esp = "Object code generation not active! Forgot to call quantum_objcode_start?\n";
        fwrite();
        _v24 = 1;
    }
    return _v24;
}

void quantum_objcode_file(char* file)
{// addr = 0x0804EB2B  --  defined in 'objcode.c' at line 295
    globalfile = file;
}

void quantum_objcode_exit(char* file)
{// addr = 0x0804EB38  --  defined in 'objcode.c' at line 304
    quantum_objcode_write(0);
    quantum_objcode_stop();
}

void quantum_objcode_run(char* file, quantum_reg* reg)
{// addr = 0x0804EB51  --  defined in 'objcode.c' at line 313
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    unsigned char[79] buf;                 // _cfa_ffffffa0
    unsigned char operation;               // _cfa_ffffff9f
    int i;                                 // _cfa_ffffff98
    int j;                                 // _cfa_ffffff94
    int k;                                 // _cfa_ffffff90
    int l;                                 // _cfa_ffffff8c
    FILE* fhd;            // _cfa_ffffff88
    int _v128;                             // _cfa_ffffff80
    long long unsigned int mu;             // _cfa_ffffff7c
    double d;                              // _cfa_ffffff74
    FILE* _v144;          // _cfa_ffffff70
    quantum_reg* _v148;   // _cfa_ffffff6c
    int* _v172;                            // _cfa_ffffff54
    quantum_reg_node* _v176;   // _cfa_ffffff50
    int _v180;                             // _cfa_ffffff4c
    int _v184;                             // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    intOrPtr _v192;                        // _cfa_ffffff40
    signed int _v196;                      // _cfa_ffffff3c
    signed int _v200;                      // _cfa_ffffff38
    signed int _v204;                      // _cfa_ffffff34
    signed int _v208;                      // _cfa_ffffff30
    int* _v236;                            // _cfa_ffffff14
    FILE* _v240;          // _cfa_ffffff10 (outparam)
    int _v244;                             // _cfa_ffffff0c (outparam)
    int _v248;                             // _cfa_ffffff08 (outparam)
    FILE* _t230;          // _t230
    FILE* _t231;          // _t231
    unsigned char _t233;                   // _t233
    quantum_reg* _t333;   // _t333
    signed int _t334;                      // _t334
    quantum_reg* _t335;   // _t335
    double _t343;                          // _t343

    _t343 = __fp0;
    _push(__ebx);
    __esp = __esp - 244;
    _v144 = file;
    _v148 = reg;
    _v16 =  *gs:0x14];
    _v248 = 134562764;
    _t230 = _v144;
     *__esp = _t230;
    fopen();
    fhd = _t230;
    if(fhd != 0) {
        i = 0;
        while(1) {
            _t231 = fhd;
             *__esp = _t231;
            feof();
            if(_t231 == 0) {
                j = 0;
                goto L5;
            } else {
                break;
            }
            do {
L5:
            } while(j <= 79);
            _t233 = fhd;
             *__esp = _t233;
            fgetc();
            operation = _t233;
            _t334 = operation & 255;
            _v204 = _t334;
            if(_v204 > 11) {
                if(_v204 == 128) {
                    _t335 = _v148;
                     *__esp =  *_t335;
                    _v248 = _t335->size;
                    _v244 = _t335->hashw;
                    _v240 = _t335->node;
                    _v236 = _t335->hash;
                    quantum_measure();
L51:
                    i = i + 1;
                    continue;
                }
                if(_v204 > 128) {
                    if(_v204 <= 130) {
L29:
                        _v240 = fhd;
                        _v244 = 1;
                        _v248 = 4;
                         *__esp =  &buf;
                        fread();
                        j = quantum_char2int( &buf);
                        _v196 = operation & 255;
                        if(_v196 == 6) {
                            quantum_hadamard(j, _v148);
                        } else {
                            if(_v196 > 6) {
                                if(_v196 == 129) {
                                    quantum_bmeasure(j, _v148);
                                } else {
                                    if(_v196 == 130) {
                                        quantum_bmeasure_bitpreserve(j, _v148);
                                    } else {
                                        if(_v196 == 14) {
                                            quantum_swaptheleads(j, _v148);
                                        }
                                    }
                                }
                            } else {
                                if(_v196 == 4) {
                                    quantum_sigma_y(j, _v148);
                                } else {
                                    if(_v196 > 4) {
                                        quantum_sigma_z(j, _v148);
                                    } else {
                                        if(_v196 == 3) {
                                            quantum_sigma_x(j, _v148);
                                        }
                                    }
                                }
                            }
                        }
                        goto L51;
                    }
                    if(_v204 == 255) {
                        goto L51;
                    } else {
L50:
                        _v240 = operation & 255;
                        _v244 = i;
                        _v248 = "%i: Unknown opcode 0x(%X)!\n";
                         *__esp = __imp__stderr;
                        fprintf();
                        goto L54;
                    }
                }
                if(_v204 == 13) {
                    _v240 = fhd;
                    _v244 = 1;
                    _v248 = 4;
                     *__esp =  &buf;
                    fread();
                    j = quantum_char2int( &buf);
                    _v240 = fhd;
                    _v244 = 1;
                    _v248 = 4;
                     *__esp =  &buf;
                    fread();
                    k = quantum_char2int( &buf);
                    _v240 = fhd;
                    _v244 = 1;
                    _v248 = 8;
                     *__esp =  &buf;
                    fread();
                    __eax = quantum_char2double( &buf);
                    d = _t343;
                    _v192 = d;
                    _t343 = _v192;
                    quantum_cond_phase_kick(j, k, _t343, _v148);
                    goto L51;
                }
                if(_v204 < 13) {
L23:
                    _v240 = fhd;
                    _v244 = 1;
                    _v248 = 4;
                     *__esp =  &buf;
                    fread();
                    j = quantum_char2int( &buf);
                    _v240 = fhd;
                    _v244 = 1;
                    _v248 = 4;
                     *__esp =  &buf;
                    fread();
                    k = quantum_char2int( &buf);
                    _v200 = operation & 255;
                    if(_v200 == 1) {
                        quantum_cnot(j, k, _v148);
                    } else {
                        if(_v200 == 12) {
                            quantum_cond_phase(j, k, _v148);
                        }
                    }
                    goto L51;
                }
                if(_v204 == 14) {
                    goto L29;
                } else {
                    goto L50;
                }
            }
            if(_v204 >= 7) {
                _v240 = fhd;
                _v244 = 1;
                _v248 = 4;
                 *__esp =  &buf;
                fread();
                j = quantum_char2int( &buf);
                _v240 = fhd;
                _v244 = 1;
                _v248 = 8;
                 *__esp =  &buf;
                fread();
                __eax = quantum_char2double( &buf);
                d = _t343;
                _v208 = (operation & 255) - 7;
                if(_v208 > 4) {
                    goto L51;
                }
                goto __eax;
            }
            if(_v204 == 2) {
                _v240 = fhd;
                _v244 = 1;
                _v248 = 4;
                 *__esp =  &buf;
                fread();
                j = quantum_char2int( &buf);
                _v240 = fhd;
                _v244 = 1;
                _v248 = 4;
                 *__esp =  &buf;
                fread();
                k = quantum_char2int( &buf);
                _v240 = fhd;
                _v244 = 1;
                _v248 = 4;
                 *__esp =  &buf;
                fread();
                l = quantum_char2int( &buf);
                quantum_toffoli(j, k, l, _v148);
                goto L51;
            }
            if(_v204 > 2) {
                goto L29;
            }
            if(_v204 == 0) {
                _v240 = fhd;
                _v244 = 1;
                _v248 = 8;
                 *__esp =  &buf;
                fread();
                mu = quantum_char2mu( &buf);
                _v128 = _t334;
                _t333 = _v148;
                _v240 = 12;
                _v248 = mu;
                _v244 = _v128;
                 *__esp =  &_v188;
                quantum_new_qureg();
                __esp = __esp - 4;
                _t333->width = _v188;
                _t333->size = _v184;
                _t333->hashw = _v180;
                _t333->node = _v176;
                _t333->hash = _v172;
                goto L51;
            }
            if(_v204 == 1) {
                goto L23;
            } else {
                goto L50;
            }
        }
         *__esp = fhd;
        fclose();
        goto L54;
    } else {
        _v244 = _v144;
        _v248 = "quantum_objcode_run: Could not open %s: ";
         *__esp = __imp__stderr;
        fprintf();
         *__esp = 0;
        perror();
L54:
        if((_v16 ^  *gs:0x14]) != 0) {
            __stack_chk_fail();
        }
        return;
    }
}

void emul(int a, int L, int width, quantum_reg* reg)
{// addr = 0x0804F2F4  --  defined in 'omuln.c' at line 30
    int i;                                 // _cfa_fffffff8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = width - 1;
    while(i >= 0) {
        if((a >> i & 1) != 0) {
            quantum_toffoli(width + 1 + width + 1, L, width + i, reg);
        }
        i = i - 1;
    }
}

void muln(int N, int a, int ctl, int width, quantum_reg* reg)
{// addr = 0x0804F34C  --  defined in 'omuln.c' at line 38
    int i;                                 // _cfa_fffffff8
    int L;                                 // _cfa_fffffff4
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    L = width + width + 1;
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    emul(a % N, L, width, reg);
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    i = 1;
    while(i < width) {
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        add_mod_n(N, (a << __cl) % N, width, reg);
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        i = i + 1;
    }
}

void muln_inv(int N, int a, int ctl, int width, quantum_reg* reg)
{// addr = 0x0804F472  --  defined in 'omuln.c' at line 57
    int i;                                 // _cfa_fffffff8
    int L;                                 // _cfa_fffffff4
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    L = width + width + 1;
    a = quantum_inverse_mod(N, a);
    i = width - 1;
    while(i > 0) {
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        add_mod_n(N, N - (a << i) % N, width, reg);
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        i = i - 1;
    }
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    emul(a % N, L, width, reg);
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
}

void mul_mod_n(int N, int a, int ctl, int width, quantum_reg* reg)
{// addr = 0x0804F5B6  --  defined in 'omuln.c' at line 76
    _unknown_ _v12;                        // _cfa_fffffff4 (outparam)
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    muln(N, a, ctl, width, reg);
    quantum_swaptheleads_omuln_controlled(ctl, width, reg);
    muln_inv(N, a, ctl, width, reg);
}

void quantum_qec_set_status(int stype, int swidth)
{// addr = 0x0804F628  --  defined in 'qec.c' at line 48
    type = stype;
    width = swidth;
}

void quantum_qec_get_status(int* ptype, int* pwidth)
{// addr = 0x0804F63D  --  defined in 'qec.c' at line 57
    if(ptype != 0) {
         *ptype = type;
    }
    if(pwidth != 0) {
         *pwidth = width;
        return;
    }
}

void quantum_qec_encode(int type, int width, quantum_reg* reg)
{// addr = 0x0804F664  --  defined in 'qec.c' at line 69
    int i;                                 // _cfa_fffffff8
    float lambda;                          // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    __fp0 = __fp0;
    quantum_get_decoherence();
    lambda = __fp0;
    quantum_set_decoherence(0);
    i = 0;
    while(reg->width > i) {
        if(reg->width - 1 == i) {
            quantum_set_decoherence(lambda);
        }
        if(i >= width) {
            quantum_cnot(i, reg->width + i, reg);
            quantum_cnot(i, reg->width + reg->width + i, reg);
        } else {
            quantum_hadamard(reg->width + i, reg);
            quantum_hadamard(reg->width + reg->width + i, reg);
            quantum_cnot(reg->width + i, i, reg);
            quantum_cnot(reg->width + reg->width + i, i, reg);
        }
        i = i + 1;
    }
    quantum_qec_set_status(1, reg->width);
    reg->width = reg->width + reg->width + _t100;
}

void quantum_qec_decode(int type, int width, quantum_reg* reg)
{// addr = 0x0804F79F  --  defined in 'qec.c' at line 107
    int i;                                 // _cfa_fffffff8
    int a;                                 // _cfa_fffffff4
    int b;                                 // _cfa_fffffff0
    int swidth;                            // _cfa_ffffffec
    float lambda;                          // _cfa_ffffffe8
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    __fp0 = __fp0;
    quantum_get_decoherence();
    lambda = __fp0;
    quantum_set_decoherence(0);
    _v40 = reg->width;
    _v44 = 1431655766;
    swidth = (_v44 * _v40 >> 32) - (_v40 >> 31);
    quantum_qec_set_status(0, 0);
    _v40 = reg->width;
    _v44 = 1431655766;
    i = (_v44 * _v40 >> 32) - (_v40 >> 31) - 1;
    while(i >= 0) {
        if(i == 0) {
            quantum_set_decoherence(lambda);
        }
        if(i >= width) {
            quantum_cnot(i, swidth + swidth + i, reg);
            quantum_cnot(i, swidth + i, reg);
        } else {
            quantum_cnot(swidth + swidth + i, i, reg);
            quantum_cnot(swidth + i, i, reg);
            quantum_hadamard(swidth + swidth + i, reg);
            quantum_hadamard(swidth + i, reg);
        }
        i = i - 1;
    }
    i = 1;
    while(i <= swidth) {
        a = quantum_bmeasure(swidth, reg);
        b = quantum_bmeasure(swidth + swidth - i, reg);
        if(a == 1 && b == 1 && i - 1 < width) {
            quantum_sigma_z(i - 1, reg);
        }
        i = i + 1;
    }
}

int quantum_qec_counter(int inc, int frequency, quantum_reg* reg)
{// addr = 0x0804F96E  --  defined in 'qec.c' at line 153
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(inc <= 0) {
        if(inc < 0) {
            counter.2126 = 0;
        }
    } else {
        counter.2126 = counter.2126 + inc;
    }
    if(frequency > 0) {
        freq = frequency;
    }
    if(counter.2126 >= freq) {
        counter.2126 = 0;
        quantum_qec_decode(type, width, reg);
        quantum_qec_encode(type, width, reg);
    }
    return counter.2126;
}

void quantum_sigma_x_ft(int target, quantum_reg* reg)
{// addr = 0x0804FA05  --  defined in 'qec.c' at line 179
    int tmp;                               // _cfa_fffffff8
    float lambda;                          // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    __fp0 = __fp0;
    tmp = type;
    type = 0;
    quantum_get_decoherence();
    lambda = __fp0;
    quantum_set_decoherence(0);
    quantum_sigma_x(target, reg);
    quantum_sigma_x(width + target, reg);
    quantum_set_decoherence(lambda);
    quantum_sigma_x(width + width + target, reg);
    quantum_qec_counter(1, 0, reg);
    type = tmp;
}

void quantum_cnot_ft(int control, int target, quantum_reg* reg)
{// addr = 0x0804FAA8  --  defined in 'qec.c' at line 205
    int tmp;                               // _cfa_fffffff8
    float lambda;                          // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    __fp0 = __fp0;
    tmp = type;
    type = 0;
    quantum_get_decoherence();
    lambda = __fp0;
    quantum_set_decoherence(0);
    quantum_cnot(control, target, reg);
    quantum_cnot(width + control, width + target, reg);
    quantum_set_decoherence(lambda);
    quantum_cnot(width + width + control, width + width + target, reg);
    quantum_qec_counter(1, 0, reg);
    type = tmp;
}

void quantum_toffoli_ft(int control1, int control2, int target, quantum_reg* reg)
{// addr = 0x0804FB70  --  defined in 'qec.c' at line 232
    int i;                                 // _cfa_fffffff0
    int c1;                                // _cfa_ffffffec
    int c2;                                // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    long long unsigned int mask;           // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t143;                      // _t143
    signed int _t147;                      // _t147
    _unknown_ _t154;                       // _t154
    signed int _t156;                      // _t156
    _unknown_ _t161;                       // _t161
    signed int _t164;                      // _t164
    _unknown_ _t169;                       // _t169
    signed int _t173;                      // _t173
    _unknown_ _t178;                       // _t178
    signed int _t180;                      // _t180
    _unknown_ _t185;                       // _t185
    signed int _t188;                      // _t188
    _unknown_ _t193;                       // _t193
    signed int _t197;                      // _t197
    _unknown_ _t205;                       // _t205
    signed int _t212;                      // _t212
    _unknown_ _t213;                       // _t213
    signed char _t219;                     // _t219
    signed char _t221;                     // _t221
    signed char _t223;                     // _t223
    signed char _t224;                     // _t224
    signed char _t226;                     // _t226
    signed char _t228;                     // _t228
    signed char _t229;                     // _t229
    signed char _t231;                     // _t231
    signed char _t233;                     // _t233
    signed int _t239;                      // _t239
    unsigned int _t241;                    // _t241
    signed int _t242;                      // _t242
    unsigned int _t244;                    // _t244
    signed int _t245;                      // _t245
    unsigned int _t247;                    // _t247
    signed int _t248;                      // _t248
    unsigned int _t250;                    // _t250
    signed int _t251;                      // _t251
    unsigned int _t253;                    // _t253
    signed int _t254;                      // _t254
    unsigned int _t256;                    // _t256
    signed int _t257;                      // _t257
    _unknown_ _t275;                       // _t275

    _t219 = target;
    _t212 = 1 << _t219;
    if((_t219 & 32) != 0) {
        _t212 = 0;
    }
    _t221 = width + target;
    _t143 = 1 << _t221;
    if((_t221 & 32) != 0) {
        _t143 = 0;
    }
    _t213 = _t212 + _t143;
    asm("adc esi, edx");
    _t223 = width + width + target;
    _t239 = (0 << 32 | 1) << _t223;
    _t147 = 1 << _t223;
    if((_t223 & 32) != 0) {
        _t239 = _t147;
        _t147 = 0;
    }
    asm("adc edx, esi");
    mask = _t147 + _t213;
    _v32 = _t239;
    i = 0;
    while(reg->size > i) {
        c1 = 0;
        c2 = 0;
        _t154 = reg->node + (i << 4);
        _t241 =  *(_t154 + 12);
        _t224 = control1;
        _t156 = (_t241 << 32 |  *(_t154 + 8)) >> _t224;
        _t242 = _t241 >> _t224;
        if((_t224 & 32) != 0) {
            _t156 = _t242;
        }
        if((_t156 & 1) != 0) {
            c1 = 1;
        }
        _t161 = reg->node + (i << 4);
        _t226 = width + control1;
        _t244 =  *(_t161 + 12);
        _t164 = (_t244 << 32 |  *(_t161 + 8)) >> _t226;
        _t245 = _t244 >> _t226;
        if((_t226 & 32) != 0) {
            _t164 = _t245;
        }
        if((_t164 & 1) != 0) {
            c1 = c1 ^ 1;
        }
        _t169 = reg->node + (i << 4);
        _t228 = width + width + control1;
        _t247 =  *(_t169 + 12);
        _t173 = (_t247 << 32 |  *(_t169 + 8)) >> _t228;
        _t248 = _t247 >> _t228;
        if((_t228 & 32) != 0) {
            _t173 = _t248;
        }
        if((_t173 & 1) != 0) {
            c1 = c1 ^ 1;
        }
        _t178 = reg->node + (i << 4);
        _t250 =  *(_t178 + 12);
        _t229 = control2;
        _t180 = (_t250 << 32 |  *(_t178 + 8)) >> _t229;
        _t251 = _t250 >> _t229;
        if((_t229 & 32) != 0) {
            _t180 = _t251;
        }
        if((_t180 & 1) != 0) {
            c2 = 1;
        }
        _t185 = reg->node + (i << 4);
        _t231 = width + control2;
        _t253 =  *(_t185 + 12);
        _t188 = (_t253 << 32 |  *(_t185 + 8)) >> _t231;
        _t254 = _t253 >> _t231;
        if((_t231 & 32) != 0) {
            _t188 = _t254;
        }
        if((_t188 & 1) != 0) {
            c2 = c2 ^ 1;
        }
        _t193 = reg->node + (i << 4);
        _t233 = width + width + control2;
        _t256 =  *(_t193 + 12);
        _t197 = (_t256 << 32 |  *(_t193 + 8)) >> _t233;
        _t257 = _t256 >> _t233;
        if((_t233 & 32) != 0) {
            _t197 = _t257;
        }
        if((_t197 & 1) != 0) {
            c2 = c2 ^ 1;
        }
        if(c1 == 1 && c2 == 1) {
            _t275 = reg->node + (i << 4);
            _t205 = reg->node + (i << 4);
             *(_t275 + 8) =  *(_t205 + 8) ^ mask;
             *(_t275 + 12) =  *(_t205 + 12) ^ _v32;
        }
        i = i + 1;
    }
    quantum_decohere(reg);
    quantum_qec_counter(1, 0, reg);
}

void quantum_qft(int width, quantum_reg* reg)
{// addr = 0x0804FDE4  --  defined in 'qft.c' at line 32
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = width - 1;
    while(i >= 0) {
        j = width - 1;
        while(j > i) {
            quantum_cond_phase(j, i, reg);
            j = j - 1;
        }
        quantum_hadamard(i, reg);
        i = i - 1;
    }
}

void quantum_qft_inv(int width, quantum_reg* reg)
{// addr = 0x0804FE43  --  defined in 'qft.c' at line 47
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    i = 0;
    while(i < width) {
        quantum_hadamard(i, reg);
        j = i + 1;
        while(j < width) {
            quantum_cond_phase_inv(j, i, reg);
            j = j + 1;
        }
        i = i + 1;
    }
}

void quantum_rk4(quantum_reg* reg, double t, double dt, _None* H)
{// addr = 0x0804FEA4  --  defined in 'qtime.c' at line 38
    int i;                                 // _cfa_fffffff0
    _Unknown_base* hash;                   // _cfa_ffffffec
    int hashw;                             // _cfa_ffffffe8
    double r;                              // _cfa_ffffffdc
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    quantum_reg_node* _v44;   // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    quantum_reg k;   // _cfa_ffffffc8
    _Unknown_base* _v60;                   // _cfa_ffffffc4
    quantum_reg_node* _v64;   // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    quantum_reg out;   // _cfa_ffffffb4
    _Unknown_base* _v80;                   // _cfa_ffffffb0
    quantum_reg_node* _v84;   // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    int _v92;                              // _cfa_ffffffa4
    quantum_reg tmp;   // _cfa_ffffffa0
    intOrPtr _v112;                        // _cfa_ffffff90
    quantum_reg* _v116;   // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _None* _v124;                          // _cfa_ffffff84
    _Unknown_base* _v140;                  // _cfa_ffffff74
    quantum_reg_node* _v144;   // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    struct quantum_reg_struct* _v164;   // _cfa_ffffff5c
    char _v172;                            // _cfa_ffffff54
    struct quantum_reg_struct* _v176;   // _cfa_ffffff50
    struct quantum_reg_struct* _v192;   // _cfa_ffffff40
    long long _v228;                       // _cfa_ffffff1c
    long long _v232;                       // _cfa_ffffff18
    quantum_reg* _v236;   // _cfa_ffffff14
    long long _v240;                       // _cfa_ffffff10 (outparam)
    long long _v244;                       // _cfa_ffffff0c (outparam)
    long long _v248;                       // _cfa_ffffff08 (outparam)
    long long _v252;                       // _cfa_ffffff04 (outparam)
    struct quantum_reg_struct* _v256;   // _cfa_ffffff00
    struct quantum_reg_struct* _v260;   // _cfa_fffffefc
    quantum_reg* _v264;   // _cfa_fffffef8
    long long _v268;                       // _cfa_fffffef4
    struct quantum_reg_struct* _v272;   // _cfa_fffffef0
    struct quantum_reg_struct* _v276;   // _cfa_fffffeec
    struct quantum_reg_struct* _v280;   // _cfa_fffffee8
    struct quantum_reg_struct* _v284;   // _cfa_fffffee4
    struct quantum_reg_struct* _v288;   // _cfa_fffffee0
    struct quantum_reg_struct* _v292;   // _cfa_fffffedc
    struct quantum_reg_struct* _v296;   // _cfa_fffffed8
    long long _v300;                       // _cfa_fffffed4
    struct quantum_reg_struct* _v304;   // _cfa_fffffed0
    struct quantum_reg_struct* _v308;   // _cfa_fffffecc
    struct quantum_reg_struct** _t439;   // _t439
    quantum_reg* _t440;   // _t440
    quantum_reg* _t443;   // _t443
    struct quantum_reg_struct* _t446;   // _t446
    struct quantum_reg_struct* _t450;   // _t450
    struct quantum_reg_struct* _t454;   // _t454
    struct quantum_reg_struct* _t457;   // _t457
    struct quantum_reg_struct* _t461;   // _t461
    struct quantum_reg_struct* _t465;   // _t465
    struct quantum_reg_struct* _t469;   // _t469
    struct quantum_reg_struct* _t472;   // _t472
    struct quantum_reg_struct* _t475;   // _t475
    struct quantum_reg_struct* _t479;   // _t479

    _v116 = t;
    _v112 = dt;
    _v124 = H;
    _v120 = _a20;
    asm("fldz");
    r = __fp0;
    hash = reg->hash;
    reg->hash = 0;
    hashw = reg->hashw;
    reg->hashw = 0;
    _v236 = reg;
    quantum_matrix_qureg( &_v156,  *(__ebp + 28), _v116);
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    _t443 = _v124;
    asm("fldz");
    asm("fld1");
    asm("fchs");
    _v228 = _t443;
    asm("fldz");
    _v236 = _t443;
    _v244 = _t443;
    _v252 = _t443;
     *__esp =  &_v172;
    __muldc3();
    __esp = __esp - 4;
    asm("fldz");
    _v232 = _v164;
    _t446 =  *134562864;
    _v240 = _t446;
    _v248 = _t446;
    _v256 = _t446;
     *__esp =  &_v172;
    __divdc3( &_v156);
    __esp = __esp - 4;
    asm("fxch st0, st1");
    _v176 = _v164;
    asm("fxch st0, st1");
    _v176 = _v176;
    _t450 = _v176;
    asm("fxch st0, st1");
    _v192 = _t450;
    _v192 = _t450;
    _v256 =  &k;
     *__esp = _v192;
    _v260 = _v192;
    quantum_scalar_qureg();
    _v256 =  &k;
    _v260 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    tmp.width = _v156;
    _v92 = _v152;
    _v88 = _v148;
    _v84 = _v144;
    _v80 = _v140;
    _v260 =  &k;
     *__esp = 1051372203;
    _v264 = 0;
    quantum_scalar_qureg();
    _v260 =  &k;
    _v264 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    out.width = _v156;
    _v72 = _v152;
    _v68 = _v148;
    _v64 = _v144;
    _v60 = _v140;
    quantum_delete_qureg( &k);
    asm("fdivp st1, st0");
    _v256 =  &tmp;
    _v264 =  *134562864 + _v116;
    _v268 =  *(__ebp + 28);
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    quantum_delete_qureg( &tmp);
    _t454 = _v124;
    asm("fldz");
    asm("fld1");
    asm("fchs");
    _v248 = _t454;
    asm("fldz");
    _v256 = _t454;
    _v264 = _t454;
    _v272 = _t454;
     *__esp =  &_v172;
    __muldc3();
    __esp = __esp - 4;
    asm("fldz");
    _v252 = _v164;
    _t457 =  *134562864;
    _v260 = _t457;
    _v268 = _t457;
    _v276 = _t457;
     *__esp =  &_v172;
    __divdc3( &_v156);
    __esp = __esp - 4;
    asm("fxch st0, st1");
    _v176 = _v164;
    asm("fxch st0, st1");
    _v176 = _v176;
    _t461 = _v176;
    asm("fxch st0, st1");
    _v192 = _t461;
    _v192 = _t461;
    _v276 =  &k;
     *__esp = _v192;
    _v280 = _v192;
    quantum_scalar_qureg();
    _v276 =  &k;
    _v280 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    tmp.width = _v156;
    _v92 = _v152;
    _v88 = _v148;
    _v84 = _v144;
    _v80 = _v140;
    _v280 =  &k;
     *__esp = 1059760811;
    _v284 = 0;
    quantum_scalar_qureg();
    _v284 =  &k;
     *__esp =  &out;
    quantum_vectoradd_inplace();
    quantum_delete_qureg( &k);
    asm("fdivp st1, st0");
    _v272 =  &tmp;
    _v280 = _v116 +  *134562864;
    _v284 =  *(__ebp + 28);
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    quantum_delete_qureg( &tmp);
    _t465 = _v124;
    asm("fldz");
    asm("fld1");
    asm("fchs");
    _v264 = _t465;
    asm("fldz");
    _v272 = _t465;
    _v280 = _t465;
    _v288 = _t465;
     *__esp =  &_v172;
    __muldc3();
    __esp = __esp - 4;
    asm("fxch st0, st1");
    _v176 = _v164;
    asm("fxch st0, st1");
    _v176 = _v176;
    _t469 = _v176;
    asm("fxch st0, st1");
    _v192 = _t469;
    _v192 = _t469;
    _v288 =  &k;
     *__esp = _v192;
    _v292 = _v192;
    quantum_scalar_qureg();
    _v288 =  &k;
    _v292 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    tmp.width = _v156;
    _v92 = _v152;
    _v88 = _v148;
    _v84 = _v144;
    _v80 = _v140;
    _v292 =  &k;
     *__esp = 1051372203;
    _v296 = 0;
    quantum_scalar_qureg();
    _v296 =  &k;
     *__esp =  &out;
    quantum_vectoradd_inplace();
    quantum_delete_qureg( &k);
    _v284 =  &tmp;
    _v292 = _v116 + _v124;
    _v296 =  *(__ebp + 28);
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    quantum_delete_qureg( &tmp);
    _t472 = _v124;
    asm("fldz");
    asm("fld1");
    asm("fchs");
    _v276 = _t472;
    asm("fldz");
    _v284 = _t472;
    _v292 = _t472;
    _v300 = _t472;
     *__esp =  &_v172;
    __muldc3();
    __esp = __esp - 4;
    asm("fldz");
    _v280 = _v164;
    _t475 =  *134562872;
    _v288 = _t475;
    _v296 = _t475;
    _v304 = _t475;
     *__esp =  &_v172;
    __divdc3( &_v156);
    __esp = __esp - 4;
    asm("fxch st0, st1");
    _v176 = _v164;
    asm("fxch st0, st1");
    _v176 = _v176;
    _t479 = _v176;
    asm("fxch st0, st1");
    _v192 = _t479;
    _v192 = _t479;
    _v304 =  &k;
     *__esp = _v192;
    _v308 = _v192;
    quantum_scalar_qureg();
    _v308 =  &k;
     *__esp =  &out;
    quantum_vectoradd_inplace();
    quantum_delete_qureg( &k);
    quantum_delete_qureg(reg);
    i = 0;
    while(_v72 > i) {
        _t439 = _v64 + (i << 4);
         *__esp =  *_t439;
        _v84 = _t439[1];
        quantum_prob();
        asm("faddp st1, st0");
        r = r;
        i = i + 1;
    }
    _v60 = hash;
    _v68 = hashw;
    _t440 = reg;
     *_t440 = out.width;
    _t440->size = _v72;
    _t440->hashw = _v68;
    _t440->node = _v64;
    _t440->hash = _v60;
}

double quantum_rk4a(quantum_reg* reg, double t, double* dt, double epsilon, _None* H)
{// addr = 0x0805057C  --  defined in 'qtime.c' at line 106
    int i;                                 // _cfa_fffffff0
    _Unknown_base* hash;                   // _cfa_ffffffec
    int hashw;                             // _cfa_ffffffe8
    double delta;                          // _cfa_ffffffdc
    double r;                              // _cfa_ffffffd4
    double dtused;                         // _cfa_ffffffcc
    signed long long _v60;                 // _cfa_ffffffc4
    quantum_reg reg2;   // _cfa_ffffffb8
    int* _v76;                             // _cfa_ffffffb4
    signed long long _v80;                 // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    quantum_reg old;   // _cfa_ffffffa4
    int* _v96;                             // _cfa_ffffffa0
    quantum_reg_node* _v100;   // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    quantum_reg tmp;   // _cfa_ffffff90
    double* _v128;                         // _cfa_ffffff80
    double _v132;                          // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    _None* _v140;                          // _cfa_ffffff74
    signed long long _v148;                // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    quantum_reg_node* _v176;   // _cfa_ffffff50
    _None* _v184;                          // _cfa_ffffff48 (outparam)
    double _v192;                          // _cfa_ffffff40 (outparam)
    signed int _v196;                      // _cfa_ffffff3c (outparam)
    quantum_reg_node* _v200;   // _cfa_ffffff38 (outparam)
    _unknown_ __ebx;                       // r1
    quantum_reg_node** _t287;   // _t287
    quantum_reg_node** _t290;   // _t290
    quantum_reg_node** _t296;   // _t296
    int _t298;                             // _t298
    quantum_reg_node** _t299;   // _t299
    quantum_reg_node** _t305;   // _t305
    quantum_reg_node** _t308;   // _t308
    quantum_reg_node** _t314;   // _t314
    int _t316;                             // _t316
    quantum_reg_node** _t317;   // _t317
    quantum_reg_node** _t323;   // _t323
    quantum_reg_node** _t326;   // _t326
    quantum_reg_node** _t332;   // _t332
    quantum_reg_node** _t335;   // _t335
    double _t342;                          // _t342
    signed int _t379;                      // _t379
    quantum_reg* _t398;   // _t398
    quantum_reg* _t399;   // _t399
    _unknown_ _t412;                       // _t412
    signed int _t413;                      // _t413
    double _t421;                          // _t421
    quantum_reg_node* _t425;   // _t425
    quantum_reg_node* _t429;   // _t429
    quantum_reg_node* _t434;   // _t434
    double _t439;                          // _t439
    signed long long _t446;                // _t446
    quantum_reg_node* _t457;   // _t457
    double _t462;                          // _t462

    _v132 = t;
    _v128 = dt;
    _v140 = H;
    _v136 = _a24;
    hash = reg->hash;
    reg->hash = 0;
    hashw = reg->hashw;
    reg->hashw = 0;
    quantum_copy_qureg(reg,  &old);
    quantum_copy_qureg(reg,  &reg2);
    do {
        quantum_rk4(reg, _v132,  *epsilon,  *(__ebp + 32));
        asm("fdivp st1, st0");
        quantum_rk4( &reg2, _v132,  *134562864,  *(__ebp + 32));
        asm("fdivp st1, st0");
        _v184 =  *(__ebp + 32);
        _v192 =  *134562864;
        _t421 = _v132;
        _v200 = _t421;
         *__esp =  &reg2;
        quantum_rk4();
        asm("fldz");
        delta = _t421;
        i = 0;
        while(1) {
            _t412 = reg->size - i;
            if(_t412 <= 0) {
                goto L9;
            }
            _t287 = reg->node + (i << 4);
            _t290 = _v60 + (i << 4);
            _v176 =  *_t287;
            _v176 = _t287[1];
            _v176 =  *_t290;
            _v176 = _t290[1];
            _t425 = _v176;
            asm("fxch st0, st1");
            asm("fsubp st3, st0");
            asm("fsubp st1, st0");
            asm("fxch st0, st1");
            _v176 = _t425;
            _v176 = _t425;
             *__esp = _v176;
            _v200 = _v176;
            quantum_real();
            _v160 = _t425;
            _t296 = reg->node + (i << 4);
            _t298 = i << 4;
            __eflags = _t298;
            _t299 = _v60 + _t298;
            _v176 =  *_t296;
            _v176 = _t296[1];
            _v176 =  *_t299;
            _v176 = _t299[1];
            _t429 = _v176;
            asm("fxch st0, st1");
            asm("fsubp st3, st0");
            asm("fsubp st1, st0");
            asm("fxch st0, st1");
            _v176 = _t429;
            _v176 = _t429;
             *__esp = _v176;
            _v200 = _v176;
            quantum_imag();
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags <= 0) {
                _t305 = reg->node + (i << 4);
                _t308 = _v60 + (i << 4);
                _v176 =  *_t305;
                _v176 = _t305[1];
                _v176 =  *_t308;
                _v176 = _t308[1];
                _t434 = _v176;
                asm("fxch st0, st1");
                asm("fsubp st3, st0");
                asm("fsubp st1, st0");
                asm("fxch st0, st1");
                _v176 = _t434;
                _v176 = _t434;
                 *__esp = _v176;
                _v200 = _v176;
                quantum_imag();
                asm("faddp st1, st0");
                _v152 = st0;
                _t314 = reg->node + (i << 4);
                _t316 = i << 4;
                __eflags = _t316;
                _t317 = _v60 + _t316;
                _v176 =  *_t314;
                _v176 = _t314[1];
                _v176 =  *_t317;
                _v176 = _t317[1];
                _t439 = _v176;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v176 = _t439;
                _v176 = _t439;
                 *__esp = _v176;
                _v200 = _v176;
                quantum_imag();
                asm("fdivr dword [ebp-0x94]");
                r = _t439;
            } else {
                _t323 = reg->node + (i << 4);
                _t326 = _v60 + (i << 4);
                _v176 =  *_t323;
                _v176 = _t323[1];
                _v176 =  *_t326;
                _v176 = _t326[1];
                _t457 = _v176;
                asm("fxch st0, st1");
                asm("fsubp st3, st0");
                asm("fsubp st1, st0");
                asm("fxch st0, st1");
                _v176 = _t457;
                _v176 = _t457;
                 *__esp = _v176;
                _v200 = _v176;
                quantum_real();
                asm("faddp st1, st0");
                _v156 = st0;
                _t332 = reg->node + (i << 4);
                _t335 = _v60 + (i << 4);
                _v176 =  *_t332;
                _v176 = _t332[1];
                _v176 =  *_t335;
                _v176 = _t335[1];
                _t462 = _v176;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v176 = _t462;
                _v176 = _t462;
                 *__esp = _v176;
                _v200 = _v176;
                quantum_real();
                asm("fdivr dword [ebp-0x98]");
                r = _t462;
            }
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags > 0) {
                delta = r;
            }
            i = i + 1;
            __eflags = i;
        }
L9:
        dtused =  *epsilon;
        _v148 =  *epsilon;
        _t446 =  *134562880;
        _v196 = _t446;
         *__esp = _t446;
        pow();
         *epsilon = _t446 * _v148;
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(_t412 > 0) {
            _t398 = reg;
            tmp.width =  *_t398;
            _v108 = _t398->size;
            _v104 = _t398->hashw;
            _v100 = _t398->node;
            _v96 = _t398->hash;
            _t399 = reg;
             *_t399 = old.width;
            _t399->size = _v88;
            _t399->hashw = _v84;
            _t399->node = _v80;
            _t399->hash = _v76;
            old.width = tmp.width;
            _v88 = _v108;
            _v84 = _v104;
            _v80 = _v100;
            _v76 = _v96;
            _v196 = reg->size << 4;
            _v200 = reg->node;
             *__esp = _v60;
            memcpy();
            _t379 = reg->size << 4;
            _t413 = _t379;
            _v196 = _t379;
            _v200 = reg->node;
             *__esp = _v80;
            memcpy();
        }
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
    } while(_t413 > 0);
    reg->hash = hash;
    _t342 = hashw;
    reg->hashw = _t342;
    return _t342;
}

float quantum_real(complex float a)
{// addr = 0x08050B0E  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

float quantum_imag(complex float a)
{// addr = 0x08050B27  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

quantum_reg quantum_matrix2qureg(quantum_matrix* m, int width)
{// addr = 0x08050B44  --  defined in 'qureg.c' at line 40
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    quantum_reg reg;   // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v56;                         // _cfa_ffffffc8
    int _t90;                              // _t90
    intOrPtr* _t91;                        // _t91
    int _t96;                              // _t96
    int _t111;                             // _t111
    intOrPtr* _t112;                       // _t112
    signed int _t116;                      // _t116
    intOrPtr* _t122;                       // _t122
    _unknown_ _t132;                       // _t132
    intOrPtr* _t133;                       // _t133

    size = 0;
    if( *((intOrPtr*)(width + 4)) != 1) {
        quantum_error(65536);
    }
    reg.width =  *(__ebp + 16);
    i = 0;
L9:
L9:
    if( *width > i) {
        goto L3;
    } else {
        _v32 = size;
        _v28 =  *(__ebp + 16) + 2;
        _t96 = size;
        _v56 = 16;
         *__esp = _t96;
        calloc();
        _v24 = _t96;
        if(_v24 == 0) {
            quantum_error(2);
        }
    }
    quantum_memman(size << 4);
    _v56 = 4;
     *__esp = 1;
    calloc();
    _v20 = 1 << _v28;
    if(_v20 == 0) {
        quantum_error(2);
    }
    quantum_memman(4 << _v28);
    i = 0;
    j = 0;
    while( *width > i) {
        _t111 = i << 3;
        __eflags = _t111;
        _t112 =  *((intOrPtr*)(width + 8)) + _t111;
        _v40 = _t112[1];
        _v48 =  *_t112;
        asm("fldz");
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags != 0 || __eflags != 0) {
L19:
            _t132 = _v24 + (j << 4);
            _t116 = i;
             *(_t132 + 8) = _t116;
             *(_t132 + 12) = _t116 >> 31;
            _t133 = _v24 + (j << 4);
            _t122 =  *((intOrPtr*)(width + 8)) + (i << 3);
             *_t133 =  *_t122;
            _t133[1] = _t122[1];
            j = j + 1;
            __eflags = j;
            goto L20;
        } else {
            asm("fldz");
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0 || __eflags != 0) {
                goto L19;
            } else {
L20:
                i = i + 1;
                __eflags = i;
                continue;
            }
        }
    }
    m->rows = reg.width;
    m->cols = _v32;
    m->t = _v28;
     *(m + 12) = _v24;
     *(m + 16) = _v20;
    return m;
L3:
    _t90 = i << 3;
    __eflags = _t90;
    _t91 =  *((intOrPtr*)(width + 8)) + _t90;
    _v44 = _t91[1];
    _v48 =  *_t91;
    asm("fldz");
    asm("fxch st0, st1");
    asm("fucompp");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags != 0 || __eflags != 0) {
L7:
        size = size + 1;
        __eflags = size;
        goto L8;
    } else {
        asm("fldz");
        asm("fxch st0, st1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags != 0 || __eflags != 0) {
            goto L7;
        } else {
L8:
            i = i + 1;
            __eflags = i;
            goto L9;
        }
    }
}

quantum_reg quantum_new_qureg(long long unsigned int initval, int width)
{// addr = 0x08050D20  --  defined in 'qureg.c' at line 98
    char* c;                               // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    quantum_reg reg;   // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    intOrPtr _v52;                         // _cfa_ffffffcc
    long int _v56;                         // _cfa_ffffffc8
    signed int _t51;                       // _t51
    signed int _t76;                       // _t76
    signed int _t78;                       // _t78

    _v44 = width;
    _v40 = _a12;
    reg.width =  *(__ebp + 20);
    _v24 = 1;
    _t51 =  *(__ebp + 20) + 2;
    _v20 = _t51;
    _v56 = 16;
     *__esp = 1;
    calloc();
    _v16 = _t51;
    if(_v16 == 0) {
        quantum_error(2);
    }
    quantum_memman(16);
    _v56 = 4;
     *__esp = 1;
    calloc();
    _v12 = 1 << _v20;
    if(_v12 == 0) {
        quantum_error(2);
    }
    quantum_memman(4 << _v20);
    _t76 = _v16;
     *(_t76 + 8) = _v44;
     *((intOrPtr*)(_t76 + 12)) = _v40;
    _t78 = _v16;
     *_t78 = 1065353216;
     *((intOrPtr*)(_t78 + 4)) = 0;
     *__esp = "QUOBFILE";
    getenv();
    c = 0;
    if(c != 0) {
        quantum_objcode_start();
        quantum_objcode_file(c);
        atexit(quantum_objcode_exit);
    }
    _v56 = _v44;
    _v52 = _v40;
    quantum_objcode_put(0);
     *initval = reg.width;
     *((intOrPtr*)(initval + 4)) = _v24;
     *(initval + 8) = _v20;
     *(initval + 12) = _v16;
     *(initval + 16) = _v12;
    return initval;
}

quantum_reg quantum_new_qureg_size(int n, int width)
{// addr = 0x08050E60  --  defined in 'qureg.c' at line 151
    intOrPtr _v8;                          // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    quantum_reg reg;   // _cfa_ffffffe8
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _t29;                              // _t29

    reg.width =  *(__ebp + 16);
    _v20 = width;
    _v16 = 0;
    _v8 = 0;
    _t29 = width;
    _v40 = 16;
     *__esp = _t29;
    calloc();
    _v12 = _t29;
    if(_v12 == 0) {
        quantum_error(2);
    }
    quantum_memman(width << 4);
     *n = reg.width;
     *(n + 4) = _v20;
     *((intOrPtr*)(n + 8)) = _v16;
     *(n + 12) = _v12;
     *((intOrPtr*)(n + 16)) = _v8;
    return n;
}

quantum_matrix quantum_qureg2matrix(quantum_reg reg)
{// addr = 0x08050EEA  --  defined in 'qureg.c' at line 175
    int i;                                 // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    quantum_matrix m;   // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    intOrPtr* _t40;                        // _t40
    intOrPtr* _t48;                        // _t48

    _v36 = 1 <<  *(__ebp + 12);
    quantum_new_matrix( &m, 1);
    __esp = __esp - 4;
    i = 0;
    while(_a12 > i) {
        _t48 = _v12 + ( *(_a20 + (i << 4) + 8) << 3);
        _t40 = _a20 + (i << 4);
         *_t48 =  *_t40;
        _t48[1] = _t40[1];
        i = i + 1;
    }
     *(reg.width) = m.rows;
     *((intOrPtr*)(reg.width + 4)) = _v16;
     *((intOrPtr*)(reg.width + 8)) = _v12;
    return reg.width;
}

void quantum_destroy_hash(quantum_reg* reg)
{// addr = 0x08050F7A  --  defined in 'qureg.c' at line 191
     *__esp = reg->hash;
    free();
    quantum_memman(-4 << reg->hashw);
    reg->hash = 0;
}

void quantum_delete_qureg(quantum_reg* reg)
{// addr = 0x08050FAF  --  defined in 'qureg.c' at line 201
    if(reg->hashw != 0 && reg->hash != 0) {
        quantum_destroy_hash(reg);
    }
     *__esp = reg->node;
    free();
    quantum_memman( ~(reg->size << 4));
    reg->node = 0;
}

void quantum_delete_qureg_hashpreserve(quantum_reg* reg)
{// addr = 0x08051001  --  defined in 'qureg.c' at line 213
     *__esp = reg->node;
    free();
    quantum_memman( ~(reg->size << 4));
    reg->node = 0;
}

void quantum_copy_qureg(quantum_reg* src, quantum_reg* dst)
{// addr = 0x08051034  --  defined in 'qureg.c' at line 223
    signed int _v20;                       // _cfa_ffffffec
    quantum_reg_node* _v24;   // _cfa_ffffffe8
    quantum_reg_node* _t45;   // _t45
    quantum_reg* _t70;   // _t70
    quantum_reg* _t74;   // _t74

    _t70 = dst;
    _t74 = src;
    _t70->width = _t74->width;
    _t70->size = _t74->size;
    _t70->hashw = _t74->hashw;
    _t70->node = _t74->node;
    _t70->hash = _t74->hash;
    _t45 = dst->size;
    _v24 = 16;
     *__esp = _t45;
    calloc();
    dst->node = _t45;
    if(dst->node == 0) {
        quantum_error(2);
    }
    quantum_memman(dst->size << 4);
    if(dst->hashw != 0) {
        _v24 = 4;
         *__esp = 1;
        calloc();
        dst->hash = 1 << dst->hashw;
        if(dst->hash == 0) {
            quantum_error(2);
        }
        quantum_memman(4 << dst->hashw);
    }
    _v20 = src->size << 4;
    _v24 = src->node;
     *__esp = dst->node;
    memcpy();
}

void quantum_print_qureg(quantum_reg reg)
{// addr = 0x08051124  --  defined in 'qureg.c' at line 255
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    long long _v44;                        // _cfa_ffffffd4
    long long _v64;                        // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    long long _v80;                        // _cfa_ffffffb0
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ _t59;                        // _t59
    _unknown_ _t77;                        // _t77
    signed int _t79;                       // _t79
    signed char _t83;                      // _t83
    intOrPtr* _t85;                        // _t85
    intOrPtr* _t88;                        // _t88
    intOrPtr* _t90;                        // _t90
    unsigned int _t93;                     // _t93
    signed int _t94;                       // _t94
    signed int _t96;                       // _t96

    _t96 = __fp0;
    i = 0;
    while(_a8 > i) {
        _t85 = _a16 + (i << 4);
         *__esp =  *_t85;
        _v88 =  *(_t85 + 4);
        quantum_prob_inline();
        _v44 = _t96;
        _t59 = _a16 + (i << 4);
        _t88 = _a16 + (i << 4);
         *__esp =  *_t88;
        _v88 =  *(_t88 + 4);
        quantum_imag();
        _v36 = _t96;
        _t90 = _a16 + (i << 4);
         *__esp =  *_t90;
        _v88 =  *(_t90 + 4);
        quantum_real();
        _v64 = _v44;
        _v72 =  *((intOrPtr*)(_t59 + 8));
        _v68 =  *((intOrPtr*)(_t59 + 12));
        _t96 = _v36;
        _v80 = _t96;
        _v88 = _t96;
         *__esp = "% f %+fi|%lli> (%e) (|";
        printf();
        j = reg.width - 1;
        while(j >= 0) {
            if((j + (j >> 31 >> 30) & 3) - (j >> 31 >> 30) == 3) {
                 *__esp = 32;
                putchar();
            }
            _t77 = _a16 + (i << 4);
            _t93 =  *(_t77 + 12);
            _t83 = j;
            _t79 = (_t93 << 32 |  *(_t77 + 8)) >> _t83;
            _t94 = _t93 >> _t83;
            if((_t83 & 32) != 0) {
                _t79 = _t94;
            }
            _v88 = _t79 & 1;
             *__esp = "%i";
            printf();
            j = j - 1;
        }
         *__esp = ">)";
        puts();
        i = i + 1;
    }
     *__esp = 10;
    putchar();
}

float quantum_prob_inline(complex float a)
{// addr = 0x0805126A  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    float _t16;                            // _t16

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    r = __fp0;
     *__esp = a;
    _t16 = _a8;
    _v24 = _t16;
    quantum_imag();
    i = __fp0;
    asm("faddp st1, st0");
    return _t16;
}

float quantum_imag(complex float a)
{// addr = 0x080512AA  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t9;                             // _t9

    p =  &a;
    _t9 = p[1];
    _v24 = _t9;
    return _t9;
}

float quantum_real(complex float a)
{// addr = 0x080512C6  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    float _t8;                             // _t8

    p =  &a;
    _t8 =  *p;
    _v24 = _t8;
    return _t8;
}

void quantum_print_expn(quantum_reg reg)
{// addr = 0x080512DF  --  defined in 'qureg.c' at line 280
    int i;                                 // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __esi;                       // r5
    _unknown_ _t24;                        // _t24

    i = 0;
    while(_a8 > i) {
        _t24 = _a16 + (i << 4);
        _v36 =  *((intOrPtr*)(_t24 + 8));
        _v32 =  *((intOrPtr*)(_t24 + 12));
        asm("sbb ebx, edx");
        _v52 = _v36 - (i << (reg.width >> 31) + reg.width >> 1);
        _v48 = _v32;
        _v56 = i;
         *__esp = "%i: %lli\n";
        printf();
        i = i + 1;
    }
}

void quantum_addscratch(int bits, quantum_reg* reg)
{// addr = 0x0805135C  --  defined in 'qureg.c' at line 294
    int i;                                 // _cfa_fffffff8
    int oldwidth;                          // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    long long unsigned int l;              // _cfa_ffffffec
    _unknown_ _t45;                        // _t45
    signed int _t46;                       // _t46
    long long unsigned int _t47;           // _t47
    signed char _t52;                      // _t52
    _unknown_ _t53;                        // _t53
    signed int _t58;                       // _t58

    oldwidth = reg->width;
    reg->width = reg->width + bits;
    i = 0;
    while(reg->size > i) {
        _t45 = reg->node + (i << 4);
        _t46 =  *(_t45 + 8);
        _t52 = bits;
        _t58 = ( *(_t45 + 12) << 32 | _t46) << _t52;
        _t47 = _t46 << _t52;
        if((_t52 & 32) != 0) {
            _t58 = _t47;
            _t47 = 0;
        }
        l = _t47;
        _v16 = _t58;
        _t53 = reg->node + (i << 4);
         *((intOrPtr*)(_t53 + 8)) = l;
         *(_t53 + 12) = _v16;
        i = i + 1;
    }
}

void quantum_print_hash(quantum_reg reg)
{// addr = 0x080513DA  --  defined in 'qureg.c' at line 314
    int i;                                 // _cfa_fffffff4
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8

    i = 0;
    while(1 << _a12 > i) {
        if(i != 0) {
            _v32 =  *((intOrPtr*)(9));
            _v28 =  *((intOrPtr*)(_a16 +  ~(1 -  *((intOrPtr*)(_a20 + (i << 2))) << 4) + 12));
            _v36 =  *((intOrPtr*)(_a20 + (i << 2))) - 1;
            _v40 = i;
             *__esp = "%i: %i %llu\n";
            printf();
        }
        i = i + 1;
    }
}

quantum_reg quantum_kronecker(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x08051461  --  defined in 'qureg.c' at line 330
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int* _v28;                             // _cfa_ffffffe4
    quantum_reg_node* _v32;   // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    quantum_reg reg;   // _cfa_ffffffd4
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr _v72;                         // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    quantum_reg_node* _t113;   // _t113
    _unknown_ _t136;                       // _t136
    _unknown_ _t141;                       // _t141
    signed char _t172;                     // _t172
    intOrPtr _t174;                        // _t174
    intOrPtr _t192;                        // _t192
    signed int _t198;                      // _t198
    intOrPtr* _t199;                       // _t199
    signed int _t201;                      // _t201
    signed int _t202;                      // _t202

    reg.width = reg2->width +  *( *(__ebp + 16));
    _v40 = ( *(__ebp + 16))[4] * reg2->size;
    _v36 = ( *(__ebp + 16))[4] * reg2->size + 2;
    _t113 = _v40;
    _v72 = 16;
     *__esp = _t113;
    calloc();
    _v32 = _t113;
    if(_v32 == 0) {
        quantum_error(2);
    }
    quantum_memman(_v40 << 4);
    _v72 = 4;
     *__esp = 1;
    calloc();
    _v28 = 1 << _v36;
    if(_v28 == 0) {
        quantum_error(2);
    }
    quantum_memman(4 << _v36);
    i = 0;
    while(reg2->size > i) {
        j = 0;
        while(( *(__ebp + 16))[4] > j) {
            _v52 = _v32 + (( *(__ebp + 16))[4] * i + j << 4);
            _t136 = reg2->node + (i << 4);
            _t172 =  *( *(__ebp + 16));
            _t201 =  *(_t136 + 8);
            _t198 = ( *(_t136 + 12) << 32 | _t201) << _t172;
            _t202 = _t201 << _t172;
            if((_t172 & 32) != 0) {
                _t198 = _t202;
                _t202 = 0;
            }
            _t141 = ( *(__ebp + 16))[0xc] + (j << 4);
            _t174 = _v52;
             *(_t174 + 8) = _t202 |  *(_t141 + 8);
             *(_t174 + 12) = _t198 |  *(_t141 + 12);
            _t199 = _v32 + (( *(__ebp + 16))[4] * i + j << 4);
            _t152 = reg2->node + (i << 4);
            _t156 = ( *(__ebp + 16))[0xc] + (j << 4);
            _t192 =  *((intOrPtr*)(( *(__ebp + 16))[0xc] + (j << 4)));
             *_t199 = __mulsc3( *((intOrPtr*)(reg2->node + (i << 4))),  *((intOrPtr*)(_t152 + 4)), _t192,  *((intOrPtr*)(_t156 + 4)));
            _t199[1] = _t192;
            j = 1 + j;
        }
        i = 1 + i;
    }
    reg1->width = reg.width;
    reg1->size = _v40;
    reg1->hashw = _v36;
    reg1->node = _v32;
    reg1->hash = _v28;
    return reg1;
}

quantum_reg quantum_state_collapse(int pos, int value, quantum_reg reg)
{// addr = 0x0805165E  --  defined in 'qureg.c' at line 376
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int size;                              // _cfa_ffffffe4
    double d;                              // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    long long unsigned int lpat;           // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    long long unsigned int rpat;           // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    long long unsigned int pos2;           // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    quantum_reg out;   // _cfa_ffffffb0
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr* _v108;                       // _cfa_ffffff94
    double _v116;                          // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ _v128;                       // _cfa_ffffff80 (outparam)
    _unknown_ _v132;                       // _cfa_ffffff7c (outparam)
    intOrPtr _v136;                        // _cfa_ffffff78 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    long long unsigned int _t188;          // _t188
    _unknown_ _t192;                       // _t192
    _unknown_ _t198;                       // _t198
    int _t209;                             // _t209
    _unknown_ _t219;                       // _t219
    _unknown_ _t225;                       // _t225
    signed int _t231;                      // _t231
    _unknown_ _t234;                       // _t234
    signed int _t238;                      // _t238
    _unknown_ _t241;                       // _t241
    int _t251;                             // _t251
    intOrPtr* _t252;                       // _t252
    unsigned int _t268;                    // _t268
    signed char _t272;                     // _t272
    signed char _t279;                     // _t279
    signed char _t280;                     // _t280
    signed int _t287;                      // _t287
    intOrPtr _t318;                        // _t318
    double* _t323;                         // _t323
    _unknown_ _t324;                       // _t324
    double _t336;                          // _t336

    size = 0;
    asm("fldz");
    d = __fp0;
    lpat = 0;
    _v40 = 0;
    rpat = 0;
    _v48 = 0;
    _t272 = value;
    _t287 = (0 << 32 | 1) << _t272;
    _t188 = 1 << _t272;
    if((_t272 & 32) != 0) {
        _t287 = _t188;
        _t188 = 0;
    }
    pos2 = _t188;
    _v56 = _t287;
    i = 0;
    while(_a20 > i) {
        _t192 = _a28 + (i << 4);
        __eflags =  *(_t192 + 8) & pos2 |  *(_t192 + 12) & _v56;
        if(( *(_t192 + 8) & pos2 |  *(_t192 + 12) & _v56) == 0) {
L5:
            _t198 = _a28 + (i << 4);
            __eflags =  *(_t198 + 8) & pos2 |  *(_t198 + 12) & _v56;
            if(( *(_t198 + 8) & pos2 |  *(_t198 + 12) & _v56) != 0) {
L8:
                i = i + 1;
                __eflags = i;
                continue;
            }
            __eflags = reg.width;
            if(reg.width != 0) {
                goto L8;
            }
L7:
            _t323 = _a28 + (i << 4);
             *__esp =  *_t323;
            _v136 = _t323[0];
            quantum_prob_inline();
            asm("faddp st1, st0");
            d = d;
            size = size + 1;
            __eflags = size;
            goto L8;
        }
        __eflags = reg.width;
        if(reg.width != 0) {
            goto L7;
        }
        goto L5;
    }
    out.width =  *((intOrPtr*)(__ebp + 20)) - 1;
    _v76 = size;
    _t209 = size;
    _v136 = 16;
     *__esp = _t209;
    calloc();
    _v68 = _t209;
    if(_v68 == 0) {
        quantum_error(2);
    }
    quantum_memman(size << 4);
    _v72 = _a24;
    _v64 = _a32;
    i = 0;
    j = 0;
    while(_a20 > i) {
        _t219 = _a28 + (i << 4);
        __eflags =  *(_t219 + 8) & pos2 |  *(_t219 + 12) & _v56;
        if(( *(_t219 + 8) & pos2 |  *(_t219 + 12) & _v56) == 0) {
L15:
            _t225 = _a28 + (i << 4);
            __eflags =  *(_t225 + 8) & pos2 |  *(_t225 + 12) & _v56;
            if(( *(_t225 + 8) & pos2 |  *(_t225 + 12) & _v56) != 0) {
L31:
                i = i + 1;
                __eflags = i;
                continue;
            }
            __eflags = reg.width;
            if(reg.width != 0) {
                goto L31;
            }
L17:
            k = 0;
            rpat = 0;
            _v48 = 0;
            while(1) {
                __eflags = k - value;
                if(k >= value) {
                    break;
                }
                _t279 = k;
                _t231 = 1 << _t279;
                __eflags = _t279 & 32;
                if((_t279 & 32) != 0) {
                    _t231 = 0;
                    __eflags = 0;
                }
                rpat = rpat + _t231;
                asm("adc [ebp-0x2c], edx");
                k = k + 1;
                __eflags = k;
            }
            _t234 = _a28 + (i << 4);
            rpat = rpat &  *(_t234 + 8);
            _v48 = _v48 &  *(_t234 + 12);
            k = 63;
            lpat = 0;
            _v40 = 0;
            while(1) {
                __eflags = k - value;
                if(k <= value) {
                    break;
                }
                _t280 = k;
                _t238 = 1 << _t280;
                __eflags = _t280 & 32;
                if((_t280 & 32) != 0) {
                    _t238 = 0;
                    __eflags = 0;
                }
                lpat = lpat + _t238;
                asm("adc [ebp-0x24], edx");
                k = k - 1;
                __eflags = k;
            }
            _t241 = _a28 + (i << 4);
            lpat = lpat &  *(_t241 + 8);
            _v40 = _v40 &  *(_t241 + 12);
            _t324 = _v68 + (j << 4);
            _t268 = _v40;
             *(_t324 + 8) = (_t268 << 32 | lpat) >> 1 | rpat;
             *(_t324 + 12) = _t268 >> 1 | _v48;
            _v108 = _v68 + (j << 4);
            _t251 = i << 4;
            __eflags = _t251;
            _t252 = _a28 + _t251;
            _v100 =  *_t252;
            _v104 = _t252[1];
            asm("fsqrt");
            _v116 = d;
            asm("fucomp st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0 || __eflags != 0) {
                _t336 = d;
                 *__esp = _t336;
                sqrt();
                _v116 = _t336;
            }
            _v96 = _v116;
            _v120 = _v96;
            _t318 = _v120;
             *_v108 = __divsc3(_v100, _v104, _t318, 0);
             *((intOrPtr*)(_v108 + 4)) = _t318;
            j = j + 1;
            __eflags = j;
            goto L31;
        }
        __eflags = reg.width;
        if(reg.width != 0) {
            goto L17;
        }
        goto L15;
    }
     *pos = out.width;
     *(pos + 4) = _v76;
     *((intOrPtr*)(pos + 8)) = _v72;
     *(pos + 12) = _v68;
     *((intOrPtr*)(pos + 16)) = _v64;
    return pos;
}

complex float quantum_dot_product(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x080519B9  --  defined in 'qureg.c' at line 444
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    complex float f;                       // _cfa_ffffffe4
    complex float _v32;                    // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    quantum_reg_node* _v40;   // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0 (outparam)
    int _v52;                              // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t67;                        // _t67
    complex float _t79;                    // _t79
    quantum_reg* _t104;   // _t104
    intOrPtr* _t108;                       // _t108
    complex float _t111;                   // _t111
    complex float _t119;                   // _t119

    f = 0;
    _v24 = 0;
    if(reg2->hashw != 0) {
        quantum_reconstruct_hash(reg2);
    }
    i = 0;
    while(reg1->size > i) {
        _t67 = reg1->node + (i << 4);
        _t104 = reg2;
        _v52 = _t104->width;
        _v48 = _t104->size;
        _v44 = _t104->hashw;
        _v40 = _t104->node;
        _v36 = _t104->hash;
         *__esp =  *((intOrPtr*)(_t67 + 8));
        _v56 =  *((intOrPtr*)(_t67 + 12));
        j = quantum_get_state();
        if(j >= 0) {
            _t108 = reg1->node + (i << 4);
             *__esp =  *_t108;
            _v56 = _t108[1];
            _t79 = quantum_conj();
            _t84 = reg2->node + (j << 4);
            _t111 =  *(reg2->node + (j << 4));
            _v32 = __mulsc3(_t79, _t108, _t111, _t84[0]);
            _v32 = _t111;
            _t119 = _v24;
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            _v32 = _t119;
            _v32 = _t119;
            f = _v32;
            _v24 = _v32;
        }
        i = i + 1;
    }
    return f;
}

void quantum_reconstruct_hash(quantum_reg* reg)
{// addr = 0x08051AF8  --  defined in 'qureg.h' at line 159
    int i;                                 // _cfa_fffffff8
    quantum_reg* _v32;   // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ _t40;                        // _t40

    i = 0;
    while(1 << reg->hashw > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t40 = reg->node + (i << 4);
        _v32 = reg;
        _v36 = i;
         *__esp =  *((intOrPtr*)(_t40 + 8));
        _v40 =  *((intOrPtr*)(_t40 + 12));
        quantum_add_hash();
        i = i + 1;
    }
}

void quantum_add_hash(long long unsigned int a, int pos, quantum_reg* reg)
{// addr = 0x08051B7B  --  defined in 'qureg.h' at line 131
    int i;                                 // _cfa_fffffff8
    int mark;                              // _cfa_fffffff4
    int _v24;                              // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8

    _v28 = a;
    _v24 = pos;
    mark = 0;
    _v36 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 8));
     *__esp = _v28;
    _v40 = _v24;
    i = quantum_hash64();
    do {
    } while( *( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 16)) + (i << 2)) != 0);
     *( *((intOrPtr*)( *((intOrPtr*)(__ebp + 20)) + 16)) + (i << 2)) =  &(reg->width);
}

unsigned int quantum_hash64(long long unsigned int key, int width)
{// addr = 0x08051C1A  --  defined in 'qureg.h' at line 91
    unsigned int k32;                      // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4

    _v28 = key;
    _v24 = width;
    k32 = _v24 ^ _v28;
    k32 = k32 * -1640562687;
    k32 = k32 >> 32 -  *((intOrPtr*)(__ebp + 16));
    return k32;
}

int quantum_get_state(long long unsigned int a, quantum_reg reg)
{// addr = 0x08051C5C  --  defined in 'qureg.h' at line 106
    int i;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0

    _v28 = a;
    _v24 = reg.width;
    if(_a20 != 0) {
        _v44 = _a20;
         *__esp = _v28;
        _v48 = _v24;
        i = quantum_hash64();
        while( *((intOrPtr*)(_a28 + (i << 2))) != 0) {
            if(( *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 8) ^ _v28 |  *0x0000000D ^ _v24) != 0) {
                i = i + 1;
                if(1 << _a20 == i) {
                    i = 0;
                }
                continue;
            }
            _v32 =  *((intOrPtr*)(_a28 + (i << 2))) - 1;
L9:
            return _v32;
        }
        _v32 = -1;
        goto L9;
    }
    _v32 = _v28;
    goto L9;
}

complex float quantum_dot_product_noconj(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x08051D22  --  defined in 'qureg.c' at line 469
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    complex float f;                       // _cfa_ffffffe4
    complex float _v32;                    // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    quantum_reg_node* _v40;   // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0 (outparam)
    int _v52;                              // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t67;                        // _t67
    quantum_reg* _t99;   // _t99
    complex float _t104;                   // _t104
    complex float _t112;                   // _t112

    f = 0;
    _v24 = 0;
    if(reg2->hashw != 0) {
        quantum_reconstruct_hash(reg2);
    }
    i = 0;
    while(reg1->size > i) {
        _t67 = reg1->node + (i << 4);
        _t99 = reg2;
        _v52 = _t99->width;
        _v48 = _t99->size;
        _v44 = _t99->hashw;
        _v40 = _t99->node;
        _v36 = _t99->hash;
         *__esp =  *((intOrPtr*)(_t67 + 8));
        _v56 =  *((intOrPtr*)(_t67 + 12));
        j = quantum_get_state();
        if(j >= 0) {
            _t77 = reg1->node + (i << 4);
            _t81 = reg2->node + (j << 4);
            _t104 =  *(reg2->node + (j << 4));
            _v32 = __mulsc3( *((intOrPtr*)(reg1->node + (i << 4))),  *((intOrPtr*)(_t77 + 4)), _t104, _t81[0]);
            _v32 = _t104;
            _t112 = _v24;
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            _v32 = _t112;
            _v32 = _t112;
            f = _v32;
            _v24 = _v32;
        }
        i = i + 1;
    }
    return f;
}

quantum_reg quantum_vectoradd(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x08051E46  --  defined in 'qureg.c' at line 497
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int addsize;                           // _cfa_ffffffe4
    int* _v32;                             // _cfa_ffffffe0
    quantum_reg_node* _v36;   // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    quantum_reg reg;   // _cfa_ffffffd0
    intOrPtr _v64;                         // _cfa_ffffffc0
    int* _v68;                             // _cfa_ffffffbc
    quantum_reg_node* _v72;   // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    int _v80;                              // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ _t149;                       // _t149
    signed int _t159;                      // _t159
    _unknown_ _t171;                       // _t171
    _unknown_ _t183;                       // _t183
    intOrPtr* _t190;                       // _t190
    intOrPtr* _t196;                       // _t196
    intOrPtr* _t200;                       // _t200
    _unknown_ _t216;                       // _t216
    intOrPtr* _t217;                       // _t217
    quantum_reg* _t220;   // _t220
    quantum_reg* _t223;   // _t223
    intOrPtr _t248;                        // _t248

    addsize = 0;
    quantum_copy_qureg(reg2,  &reg);
    if(reg2->hashw != 0 ||  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 8)) != 0) {
        quantum_reconstruct_hash(reg2);
        quantum_copy_qureg(reg2,  &reg);
        i = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 4)) > i) {
            _t149 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
            _t220 = reg2;
            _v84 = _t220->width;
            _v80 = _t220->size;
            _v76 = _t220->hashw;
            _v72 = _t220->node;
            _v68 = _t220->hash;
             *__esp =  *(_t149 + 8);
            _v88 =  *(_t149 + 12);
            if(quantum_get_state() == -1) {
                addsize = addsize + 1;
            }
            i = i + 1;
        }
        goto L7;
    } else {
L7:
        _v44 = _v44 + addsize;
        _t159 = _v44 << 4;
        _v88 = _t159;
         *__esp = _v36;
        realloc();
        _v36 = _t159;
        if(_v36 == 0) {
            quantum_error(2);
        }
        quantum_memman(addsize << 4);
        k = reg2->size;
        i = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 4)) > i) {
            _t171 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
            _t223 = reg2;
            _v84 = _t223->width;
            _v80 = _t223->size;
            _v76 = _t223->hashw;
            _v72 = _t223->node;
            _v68 = _t223->hash;
             *__esp =  *(_t171 + 8);
            _v88 =  *(_t171 + 12);
            j = quantum_get_state();
            if(j < 0) {
                _t216 = _v36 + (k << 4);
                _t183 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
                 *((intOrPtr*)(_t216 + 8)) =  *((intOrPtr*)(_t183 + 8));
                 *((intOrPtr*)(_t216 + 12)) =  *((intOrPtr*)(_t183 + 12));
                _t217 = _v36 + (k << 4);
                _t190 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
                 *_t217 =  *_t190;
                _t217[1] = _t190[1];
                k = k + 1;
            } else {
                __esi = _v36 + (j << 4);
                _t196 = _v36 + (j << 4);
                _t200 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
                _v64 =  *_t196;
                _v64 = _t196[1];
                _v64 =  *_t200;
                _v64 = _t200[1];
                _t248 = _v64;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v64 = _t248;
                _v64 = _t248;
                 *__esi = _v64;
                __esi[1] = _v64;
            }
            i = i + 1;
        }
        reg1->width = reg.width;
        reg1->size = _v44;
        reg1->hashw = _v40;
        reg1->node = _v36;
        reg1->hash = _v32;
        return reg1;
    }
}

void quantum_vectoradd_inplace(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x080520A8  --  defined in 'qureg.c' at line 550
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int addsize;                           // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    quantum_reg_node* _v40;   // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ _t135;                       // _t135
    quantum_reg_node* _t146;   // _t146
    _unknown_ _t160;                       // _t160
    _unknown_ _t173;                       // _t173
    intOrPtr* _t181;                       // _t181
    intOrPtr* _t189;                       // _t189
    intOrPtr* _t193;                       // _t193
    _unknown_ _t206;                       // _t206
    intOrPtr* _t207;                       // _t207
    quantum_reg* _t210;   // _t210
    quantum_reg* _t215;   // _t215
    intOrPtr _t238;                        // _t238

    addsize = 0;
    if(reg1->hashw != 0 || reg2->hashw != 0) {
        quantum_reconstruct_hash(reg1);
        i = 0;
        while(reg2->size > i) {
            _t135 = reg2->node + (i << 4);
            _t210 = reg1;
            _v52 = _t210->width;
            _v48 = _t210->size;
            _v44 = _t210->hashw;
            _v40 = _t210->node;
            _v36 = _t210->hash;
             *__esp =  *(_t135 + 8);
            _v56 =  *(_t135 + 12);
            if(quantum_get_state() == -1) {
                addsize = addsize + 1;
            }
            i = i + 1;
        }
        goto L7;
    } else {
L7:
        _t146 = reg1->node;
        _v56 = reg1->size + addsize << 4;
         *__esp = _t146;
        realloc();
        reg1->node = _t146;
        if(reg1->node == 0) {
            quantum_error(2);
        }
        quantum_memman(addsize << 4);
        k = reg1->size;
        i = 0;
        while(reg2->size > i) {
            _t160 = reg2->node + (i << 4);
            _t215 = reg1;
            _v52 = _t215->width;
            _v48 = _t215->size;
            _v44 = _t215->hashw;
            _v40 = _t215->node;
            _v36 = _t215->hash;
             *__esp =  *(_t160 + 8);
            _v56 =  *(_t160 + 12);
            j = quantum_get_state();
            if(j < 0) {
                _t206 = reg1->node + (k << 4);
                _t173 = reg2->node + (i << 4);
                 *((intOrPtr*)(_t206 + 8)) =  *((intOrPtr*)(_t173 + 8));
                 *((intOrPtr*)(_t206 + 12)) =  *((intOrPtr*)(_t173 + 12));
                _t207 = reg1->node + (k << 4);
                _t181 = reg2->node + (i << 4);
                 *_t207 =  *_t181;
                _t207[1] = _t181[1];
                k = k + 1;
            } else {
                __esi = reg1->node + (j << 4);
                _t189 = reg1->node + (j << 4);
                _t193 = reg2->node + (i << 4);
                _v32 =  *_t189;
                _v32 = _t189[1];
                _v32 =  *_t193;
                _v32 = _t193[1];
                _t238 = _v32;
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                _v32 = _t238;
                _v32 = _t238;
                 *__esi = _v32;
                __esi[1] = _v32;
            }
            i = i + 1;
        }
        reg1->size = reg1->size + addsize;
        return;
    }
}

quantum_reg quantum_matrix_qureg(_None* A, double t, quantum_reg* reg)
{// addr = 0x080522D8  --  defined in 'qureg.c' at line 609
    _unknown_ _v12;                        // _cfa_fffffff4
    long long unsigned int _v16;           // _cfa_fffffff0
    long long unsigned int i;              // _cfa_ffffffec
    long long unsigned int _v24;           // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    long long unsigned int _v32;           // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    quantum_reg reg2;   // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    quantum_reg tmp;   // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    quantum_reg* _v68;   // _cfa_ffffffbc
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    long long _v144;                       // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    long long unsigned int _v152;          // _cfa_ffffff68
    _unknown_ _v156;                       // _cfa_ffffff64 (outparam)
    struct quantum_reg_struct** __esi;   // r5
    signed int _t84;                       // _t84
    _unknown_ _t118;                       // _t118
    struct quantum_reg_struct* _t126;   // _t126

    _v68 = reg;
    _v64 = _a16;
    reg2.width =  *( *(__ebp + 24));
    _v36 = 1 << reg2.width;
    _v32 = 0;
    _v24 = 0;
    _t84 = _v36;
    _v152 = 16;
     *__esp = _t84;
    calloc();
    _v28 = _t84;
    if(_v28 == 0) {
        quantum_error(2);
    }
    quantum_memman(_v36 << 4);
    i = 0;
    _v16 = 0;
    while(1) {
        _v116 = 1;
        _v112 = 1 <<  *( *(__ebp + 24)) >> 31;
        if(_v112 <= _v16 && (_v112 < _v16 || _v116 <= i)) {
            break;
        }
        _t118 = _v28 + (i << 4);
         *((intOrPtr*)(_t118 + 8)) = i;
         *((intOrPtr*)(_t118 + 12)) = _v16;
        _v144 = _v68;
        _v152 = i;
        _v148 = _v16;
         *__esp =  &_v108;
         *t();
        __esp = __esp - 4;
        tmp.width = _v108;
        _v56 = _v104;
        _v52 = _v100;
        _v48 = _v96;
        _v44 = _v92;
        _t126 = _v28;
        __esi = _t126 + (i << 4);
        quantum_dot_product_noconj( &tmp,  *(__ebp + 24));
         *__esi =  &tmp;
        __esi[1] = _t126;
        quantum_delete_qureg( &tmp);
        i = i + 1;
        asm("adc dword [ebp-0xc], 0x0");
    }
     *A = reg2.width;
     *(A + 4) = _v36;
     *((intOrPtr*)(A + 8)) = _v32;
     *(A + 12) = _v28;
     *((intOrPtr*)(A + 16)) = _v24;
    return A;
}

void quantum_scalar_qureg(complex float r, quantum_reg* reg)
{// addr = 0x08052462  --  defined in 'qureg.c' at line 644
    int i;                                 // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    complex float _t42;                    // _t42

    i = 0;
    while( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 4)) > i) {
        __esi =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
        _t30 =  *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4);
        _t42 = r;
         *__esi = __mulsc3( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebp + 16)) + 12)) + (i << 4))),  *((intOrPtr*)(_t30 + 4)), _t42, reg);
        __esi[1] = _t42;
        i = i + 1;
    }
}

void quantum_print_timeop(int width, _None* f)
{// addr = 0x080524D7  --  defined in 'qureg.c' at line 655
    _unknown_ _v8;                         // _cfa_fffffff8
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    quantum_matrix m;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    quantum_reg tmp;   // _cfa_ffffffcc
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    int _v116;                             // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    signed int _t70;                       // _t70
    intOrPtr* _t90;                        // _t90
    intOrPtr* _t108;                       // _t108

    _push(__ebx);
    __esp = __esp - 116;
    _v116 = 1 << width;
    quantum_new_matrix( &_v76, 1 << width);
    __esp = __esp - 4;
    m.rows = _v76;
    _v28 = _v72;
    _v24 = _v68;
    i = 0;
    while(1 << width > i) {
        _t70 = i;
        _v116 = width;
        _v124 = _t70;
        _v120 = _t70 >> 31;
         *__esp =  &_v108;
        quantum_new_qureg();
        __esp = __esp - 4;
        tmp.width = _v108;
        _v48 = _v104;
        _v44 = _v100;
        _v40 = _v96;
        _v36 = _v92;
         *__esp =  &tmp;
         *f();
        j = 0;
        while(_v48 > j) {
            _t108 = _v24 + ( *((intOrPtr*)(_v40 + (j << 4) + 8)) + _v28 * i << 3);
            _t90 = _v40 + (j << 4);
             *_t108 =  *_t90;
            _t108[1] = _t90[1];
            j = j + 1;
        }
        quantum_delete_qureg( &tmp);
        i = i + 1;
    }
     *__esp = m.rows;
    _v124 = _v28;
    _v120 = _v24;
    quantum_print_matrix();
    quantum_delete_matrix( &m);
}

int main(int argc, char** argv)
{// addr = 0x08052614  --  defined in 'shor.c' at line 31
    int i;                                 // _cfa_fffffff0
    intOrPtr _v12;                         // _cfa_fffffff4
    int width;                             // _cfa_ffffffec
    int swidth;                            // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    int N;                                 // _cfa_ffffffe0
    int c;                                 // _cfa_ffffffdc
    int q;                                 // _cfa_ffffffd8
    int a;                                 // _cfa_ffffffd4
    int b;                                 // _cfa_ffffffd0
    int factor;                            // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    quantum_reg qr;   // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    struct quantum_reg_struct _v112;   // _cfa_ffffff90
    int _v116;                             // _cfa_ffffff8c
    int* _v120;                            // _cfa_ffffff88
    signed int _v148;                      // _cfa_ffffff6c
    int _v180;                             // _cfa_ffffff4c (outparam)
    int _v184;                             // _cfa_ffffff48 (outparam)
    int _v188;                             // _cfa_ffffff44 (outparam)
    int _v192;                             // _cfa_ffffff40 (outparam)
    int _v196;                             // _cfa_ffffff3c (outparam)
    int _t217;                             // _t217
    signed int _t232;                      // _t232
    int _t350;                             // _t350
    _unknown_ _t395;                       // _t395
    signed int _t396;                      // _t396

    __fp0 = __fp0;
    __esp = __esp & -16;
    _push( *((intOrPtr*)( &argc - 4)));
    _push(_t395);
    _t396 = __esp;
    _push( &argc);
    __esp = __esp - 180;
    _v120 =  &argc;
    N = 0;
     *__esp = 0;
    time();
     *__esp = __eax;
    srand();
    if( *_v120 != 1) {
        _t217 =  *(_v120[1] + 4);
         *__esp = _t217;
        atoi();
        c = _t217;
        if(c > 14) {
            swidth = quantum_getwidth(c * c);
            x = quantum_getwidth(c);
            _v184 = x + x + x + swidth + 2;
            _v188 = c;
             *__esp = "N = %i, %i qubits required\n";
            printf();
            if( *_v120 > 2) {
                _t350 =  *(_v120[1] + 8);
                 *__esp = _t350;
                atoi();
                N = _t350;
            }
            goto L7;
            do {
            } while();
L11:
            while(width < swidth) {
                quantum_hadamard(width,  &_v76);
                width = width + 1;
            }
            quantum_addscratch(x + x + x + 2,  &_v76);
            quantum_exp_mod_n(c, N, swidth, x,  &_v76);
            width = 0;
            while(x + x + x + 2 > width) {
                quantum_bmeasure(0,  &_v76);
                width = width + 1;
            }
            quantum_qft(swidth,  &_v76);
            width = 0;
            while((swidth >> 31) + swidth >> 1 > width) {
                quantum_cnot(width, swidth - width - 1,  &_v76);
                quantum_cnot(swidth - width - 1, width,  &_v76);
                quantum_cnot(width, swidth - width - 1,  &_v76);
                width = width + 1;
            }
             *__esp = _v76;
            _v192 = qr.width;
            _v188 = _v68;
            _v184 = _v64;
            _v180 = _v60;
            q = quantum_measure();
            if(q != -1) {
                if(q != 0) {
                    a = 1 << swidth;
                    _push(q);
                    asm("fild dword [esp]");
                    __esp =  &_v196;
                    _push(a);
                    asm("fild dword [esp]");
                    __esp =  &(((char*)( &_v196))[1]);
                    asm("fdivp st1, st0");
                    _v192 = __fp0;
                    _v196 = q;
                     *__esp = "Measured %i (%f), ";
                    printf();
                    quantum_frac_approx( &q,  &a, swidth);
                    _v192 = a;
                    _v196 = q;
                     *__esp = "fractional approximation is %i/%i.\n";
                    printf();
                    if((a + (a >> 31 >> 31) & 1) - (a >> 31 >> 31) == 1 && a + a < 1 << swidth) {
                         *__esp = "Odd denominator, trying to expand by 2.";
                        puts();
                        a = a + a;
                    }
                    if((a + (a >> 31 >> 31) & 1) - (a >> 31 >> 31) != 1) {
                        _v192 = a;
                         *__esp = "Possible period is %i.\n";
                        printf();
                        b = quantum_ipow(N, (a >> 31) + a >> 1) + 1 % c;
                        factor = quantum_ipow(N, (a >> 31) + a >> 1) - 1 % c;
                        b = quantum_gcd(c, b);
                        factor = quantum_gcd(c, factor);
                        if(b <= factor) {
                            _v56 = factor;
                        } else {
                            _v56 = b;
                        }
                        if(_v56 >= c || _v56 <= 1) {
                             *__esp = "Unable to determine factors, try again.";
                            puts();
                            _v116 = 2;
                        } else {
                            _v148 = c;
                            _v184 = _v148 / _v56;
                            _v188 = _v56;
                            _v192 = c;
                             *__esp = "%i = %i * %i\n";
                            printf();
                            quantum_delete_qureg( &_v76);
                            _v116 = 0;
                        }
                    } else {
                         *__esp = "Odd period, try again.";
                        puts();
                        _v116 = 2;
                    }
                } else {
                     *__esp = "Measured zero, try again.";
                    puts();
                    _v116 = 2;
                }
            } else {
                 *__esp = "Impossible Measurement!";
                puts();
                _v116 = 1;
            }
            goto L34;
L7:
            _t232 = quantum_gcd(c, N);
            if(_t232 > 1 || N <= 1) {
                rand();
                N = _t232 % c;
                goto L7;
            } else {
                _v188 = N;
                 *__esp = "Random seed: %i\n";
                printf();
                _v180 = swidth;
                _v188 = 0;
                _v184 = 0;
                 *__esp =  &_v112;
                quantum_new_qureg();
                __esp = __esp - 4;
                _v76 = _v112;
                qr.width = _v112.size;
                _v68 = _v112.hashw;
                _v64 = _v112.node;
                _v60 = _v112.hash;
                width = 0;
            }
            goto L11;
        } else {
             *__esp = "Invalid number\n";
            puts();
            _v116 = 3;
            goto L34;
        }
    } else {
         *__esp = "Usage: shor [number]\n";
        puts();
        _v116 = 3;
L34:
        __esp = _t396;
        _pop(__ebp);
        __esp = _v12 - 4;
        return _v116;
    }
}

const _None* quantum_get_version()
{// addr = 0x08052B30  --  defined in 'version.c' at line 28
    return 134563284;
}

__mulsc3(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    _unknown_ _a16                         // _cfa_10
)
{// addr = 0x08052B40
    signed long long _v8;                  // _cfa_fffffff8
    signed long long _v12;                 // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed long long _v20;                 // _cfa_ffffffec
    signed long long _v28;                 // _cfa_ffffffe4
    signed int _v44;                       // _cfa_ffffffd4
    signed long long _v56;                 // _cfa_ffffffc8
    signed long long _v60;                 // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    _unknown_ _t54;                        // _t54
    signed char _t55;                      // _t55
    _unknown_ _t57;                        // _t57
    signed int _t58;                       // _t58
    signed int _t59;                       // _t59
    signed int _t79;                       // _t79
    signed long long _t80;                 // _t80
    signed int _t82;                       // _t82
    signed int _t84;                       // _t84
    signed int _t86;                       // _t86
    signed int _t88;                       // _t88
    signed int _t95;                       // _t95
    signed int _t97;                       // _t97
    signed int _t100;                      // _t100
    signed int _t104;                      // _t104

    _t55 = __i686.get_pc_thunk.cx(_t54);
    _t58 = _t57 + 13465;
    __eflags = _t58;
    _v8 = st3 * st2;
    _v12 = st2 * st1;
    _v16 = st3 * st1;
    _v20 = st2 * st2;
    _v64 = _v16;
    asm("fst dword [ebp-0x34]");
    _t79 = _v20 + _v64;
    _v28 = _t79;
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags != 0) {
L8:
        _t80 = _v28;
        asm("fucomp st0");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags != 0) {
L10:
            _t82 = st6 - st7;
            asm("fst dword [ebp-0x30]");
            asm("fxch st0, st7");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0) {
                st7 = _t82;
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
L128:
                _t84 = st6 - st7;
                asm("fst dword [ebp-0x2c]");
                asm("fxch st0, st7");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0) {
                    st7 = _t84;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
L139:
                    _t59 = 0;
L35:
                    _t86 = st6 - st7;
                    asm("fst dword [ebp-0x24]");
                    asm("fxch st0, st7");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        st7 = _t86;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
L66:
                        _t88 = st6 - st7;
                        asm("fst dword [ebp-0x20]");
                        asm("fxch st0, st7");
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            st7 = _t88;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
L76:
                            __eflags = _t59;
                            if(__eflags != 0) {
                                st6 = _t88;
                                st3 = _t88;
                                st3 = _t88;
                                asm("fxch st0, st3");
L62:
                                asm("fsubp st1, st0");
                                _t80 =  *(_t58 - 6680) * st0;
                                asm("fxch st0, st5");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st3");
                                asm("fmulp st2, st0");
                                asm("faddp st1, st0");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st1");
                                _v28 = _t80;
L7:
                                _v60 = _t80;
                                return _v60;
                            }
                            _t95 = st6 - st7;
                            asm("fst dword [ebp-0x1c]");
                            asm("fxch st0, st7");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                st6 = _t95;
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st4");
                                asm("fxch st0, st5");
L84:
                                _t97 = st5 - st6;
                                asm("fxch st0, st6");
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st5 = _t97;
                                    asm("fxch st0, st1");
                                    asm("fxch st0, st2");
                                    asm("fxch st0, st3");
                                    asm("fxch st0, st4");
L91:
                                    _t100 = _v64;
                                    asm("fucomp st0");
                                    asm("fnstsw ax");
                                    asm("sahf");
                                    if(__eflags != 0) {
                                        st0 = _t100;
L98:
                                        _t80 = _v56;
                                        asm("fucomp st0");
                                        asm("fnstsw ax");
                                        asm("sahf");
                                        if(__eflags != 0) {
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            goto L7;
                                        }
                                        if(__eflags != 0) {
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            goto L7;
                                        }
                                        asm("fucomp st0");
                                        asm("fnstsw ax");
                                        asm("sahf");
                                        if(__eflags != 0) {
                                            st4 = _t80;
                                            asm("fxch st0, st2");
L110:
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t80;
                                                __eflags = _t55 & 2;
                                                asm("fldz");
                                                if(__eflags != 0) {
                                                    st0 = _t80;
                                                    asm("fldz");
                                                    asm("fchs");
                                                }
                                                asm("fxch st0, st1");
                                            } else {
                                                asm("fxch st0, st1");
                                            }
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t80;
                                                __eflags = _t55 & 2;
                                                asm("fldz");
                                                if(__eflags != 0) {
                                                    st0 = _t80;
                                                    asm("fldz");
                                                    asm("fchs");
                                                }
                                                asm("fxch st0, st2");
                                            } else {
                                                asm("fxch st0, st2");
                                            }
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t80;
                                                __eflags = _t55 & 2;
                                                asm("fldz");
                                                if(__eflags != 0) {
                                                    st0 = _t80;
                                                    asm("fldz");
                                                    asm("fchs");
                                                }
                                                asm("fxch st0, st3");
                                            } else {
                                                asm("fxch st0, st3");
                                            }
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t80;
                                                __eflags = _t55 & 2;
                                                asm("fldz");
                                                if((_t55 & 2) == 0) {
                                                    asm("fxch st0, st1");
                                                    asm("fxch st0, st2");
                                                    asm("fxch st0, st3");
                                                    asm("fxch st0, st1");
L59:
                                                    asm("fxch st0, st2");
                                                    asm("fxch st0, st3");
                                                    asm("fxch st0, st2");
                                                    goto L62;
                                                }
                                                st0 = _t80;
                                                asm("fldz");
                                                asm("fxch st0, st1");
                                                asm("fxch st0, st2");
                                                asm("fxch st0, st3");
                                                asm("fxch st0, st1");
L123:
                                                asm("fchs");
                                                goto L59;
                                            } else {
                                                asm("fxch st0, st1");
                                                asm("fxch st0, st3");
                                                asm("fxch st0, st1");
                                                goto L62;
                                            }
                                        }
                                        if(__eflags == 0) {
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            st0 = _t80;
                                            goto L7;
                                        }
                                        st4 = _t80;
                                        asm("fxch st0, st2");
                                        goto L110;
                                    }
                                    if(__eflags != 0) {
                                        st0 = _t100;
                                        goto L98;
                                    }
                                    asm("fucomp st0");
                                    asm("fnstsw ax");
                                    asm("sahf");
                                    if(__eflags != 0) {
                                        st4 = _t100;
                                        asm("fxch st0, st2");
                                        goto L110;
                                    }
                                    if(__eflags != 0) {
                                        goto L98;
                                    }
                                    st4 = _t100;
                                    asm("fxch st0, st2");
                                    goto L110;
                                }
                                if(__eflags != 0) {
                                    st5 = _t97;
                                    asm("fxch st0, st1");
                                    asm("fxch st0, st2");
                                    asm("fxch st0, st3");
                                    asm("fxch st0, st4");
                                    goto L91;
                                }
                                asm("fxch st0, st5");
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st3 = _t97;
                                    asm("fxch st0, st1");
                                    goto L110;
                                }
                                if(__eflags != 0) {
                                    st3 = _t97;
                                    asm("fxch st0, st1");
                                    goto L110;
                                }
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st4");
                                goto L91;
                            }
                            if(__eflags != 0) {
                                st6 = _t95;
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st4");
                                asm("fxch st0, st5");
                                goto L84;
                            }
                            asm("fxch st0, st6");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                st4 = _t95;
                                st2 = _t95;
                                goto L110;
                            }
                            if(__eflags != 0) {
                                st4 = _t95;
                                st2 = _t95;
                                goto L110;
                            }
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            goto L84;
                        }
                        if(__eflags != 0) {
                            st7 = _t88;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            goto L76;
                        }
                        asm("fxch st0, st7");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            st3 = _t88;
                            st3 = _t88;
                            st3 = _t88;
L72:
                            asm("fld1");
                            asm("fldz");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st2");
                            asm("fxch st0, st5");
                            asm("fxch st0, st2");
L48:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t88;
                                __eflags = _t55 & 2;
                                asm("fldz");
                                if(__eflags != 0) {
                                    st0 = _t88;
                                    asm("fldz");
                                    asm("fchs");
                                }
                                asm("fxch st0, st4");
                            } else {
                                asm("fxch st0, st4");
                            }
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t88;
                                __eflags = _t55 & 2;
                                asm("fldz");
                                if((_t55 & 2) != 0) {
                                    st0 = _t88;
                                    asm("fldz");
                                    asm("fchs");
                                }
                                asm("fxch st0, st5");
                            } else {
                                asm("fxch st0, st5");
                            }
                            asm("fxam");
                            asm("fnstsw ax");
                            st0 = _t88;
                            asm("fxch st0, st2");
                            __eflags = _t55 & 2;
                            asm("fabs");
                            if((_t55 & 2) != 0) {
                                asm("fchs");
                            }
                            asm("fxch st0, st1");
                            asm("fxam");
                            asm("fnstsw ax");
                            st0 = _t88;
                            asm("fxch st0, st1");
                            __eflags = _t55 & 2;
                            asm("fabs");
                            if((_t55 & 2) != 0) {
                                goto L123;
                            } else {
                                goto L59;
                            }
                        }
                        if(__eflags == 0) {
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            goto L76;
                        }
                        st3 = _t88;
                        st3 = _t88;
                        st3 = _t88;
                        goto L72;
                    }
                    if(__eflags != 0) {
                        st7 = _t86;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L66;
                    }
                    asm("fxch st0, st7");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        st3 = _t86;
                        st3 = _t86;
                        st0 = _t86;
L41:
                        _t88 = st2 - st3;
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            asm("fxch st0, st2");
L45:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                asm("fxch st0, st2");
L162:
                                asm("fldz");
                                asm("fld1");
                                asm("fxch st0, st3");
                                asm("fxch st0, st2");
                                asm("fxch st0, st4");
                                asm("fxch st0, st2");
                                goto L48;
                            }
                            if(__eflags != 0) {
                                asm("fxch st0, st2");
                                goto L162;
                            }
                            asm("fld1");
                            _t88 = st0;
                            asm("fxch st0, st3");
                            goto L48;
                        }
                        if(__eflags == 0) {
                            goto L162;
                        }
                        asm("fxch st0, st2");
                        goto L45;
                    }
                    if(__eflags == 0) {
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L66;
                    }
                    st3 = _t86;
                    st3 = _t86;
                    st0 = _t86;
                    goto L41;
                }
                if(__eflags != 0) {
                    st7 = _t84;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L139;
                }
                asm("fxch st0, st7");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags == 0) {
                    if(__eflags != 0) {
                        goto L131;
                    }
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L139;
                }
L131:
                asm("fxam");
                asm("fnstsw ax");
                st0 = _t84;
                __eflags = _t55 & 2;
                asm("fldz");
                if((_t55 & 2) == 0) {
                    asm("fxch st0, st1");
                    asm("fxch st0, st6");
                    asm("fxch st0, st5");
                    asm("fxch st0, st4");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                } else {
                    st0 = _t84;
                    asm("fldz");
                    asm("fchs");
                    asm("fxch st0, st1");
                    asm("fxch st0, st6");
                    asm("fxch st0, st5");
                    asm("fxch st0, st4");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                }
L134:
                asm("fld1");
                _v44 = _t84;
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
L25:
                asm("fxam");
                asm("fnstsw ax");
                st0 = _t84;
                _t104 = _v44;
                __eflags = _t55 & 2;
                asm("fabs");
                if(__eflags == 0) {
                    asm("fxch st0, st5");
                } else {
                    asm("fchs");
                    asm("fxch st0, st5");
                }
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    asm("fxam");
                    asm("fnstsw ax");
                    st0 = _t104;
                    __eflags = _t55 & 2;
                    asm("fldz");
                    if(__eflags == 0) {
                        asm("fxch st0, st4");
                    } else {
                        st0 = _t104;
                        asm("fldz");
                        asm("fchs");
                        asm("fxch st0, st4");
                    }
                } else {
                    asm("fxch st0, st4");
                }
                asm("fucom st0");
                asm("fnstsw ax");
                _t59 = 1;
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    asm("fxam");
                    asm("fnstsw ax");
                    st0 = _t104;
                    __eflags = _t55 & 2;
                    asm("fldz");
                    if(__eflags != 0) {
                        st0 = _t104;
                        asm("fldz");
                        asm("fchs");
                    }
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                    _t59 = 1;
                } else {
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                }
                goto L35;
            }
            if(__eflags != 0) {
                st7 = _t82;
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
                goto L128;
            }
            asm("fxch st0, st7");
            asm("fucomp st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags == 0) {
                if(__eflags != 0) {
                    asm("fxch st0, st6");
                    goto L15;
                }
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
                goto L128;
            } else {
                asm("fxch st0, st6");
L15:
                asm("fxam");
                asm("fnstsw ax");
                st0 = _t82;
                __eflags = _t55 & 2;
                asm("fld1");
                if(__eflags != 0) {
                    st0 = _t82;
                    asm("fld1");
                    asm("fchs");
                }
                _t84 = st5 - st6;
                asm("fst dword [ebp-0x14]");
                asm("fxch st0, st6");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0) {
                    st6 = _t84;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
L24:
                    asm("fldz");
                    _v44 = _t84;
                    goto L25;
                }
                if(__eflags != 0) {
                    st6 = _t84;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L24;
                }
                asm("fxch st0, st6");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    goto L134;
                } else {
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L24;
                }
            }
        }
        if(__eflags == 0) {
            st5 = _t80;
            st0 = _t80;
            st0 = _t80;
            st0 = _t80;
            st0 = _t80;
            st1 = _t80;
            goto L7;
        }
        goto L10;
    }
    if(__eflags != 0) {
        goto L8;
    } else {
        st5 = _t79;
        st0 = _t79;
        st0 = _t79;
        st0 = _t79;
        st0 = _t79;
        st1 = _t79;
        goto L7;
    }
}

__i686.get_pc_thunk.cx(
    _unknown_ __eax                        // r0
)
{// addr = 0x080531D5
    __eax = __eax;
    return __eax;
}

signed long long* __muldc3(
    signed long long* _a4,                 // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a16,                        // _cfa_10
    _unknown_ _a24,                        // _cfa_18
    _unknown_ _a32                         // _cfa_20
)
{// addr = 0x080531E0
    signed long long _v20;                 // _cfa_ffffffec
    signed long long _v28;                 // _cfa_ffffffe4
    signed long long _v36;                 // _cfa_ffffffdc
    signed long long _v44;                 // _cfa_ffffffd4
    long long _v84;                        // _cfa_ffffffac
    signed long long _v108;                // _cfa_ffffff94
    long long _v116;                       // _cfa_ffffff8c
    long long _v124;                       // _cfa_ffffff84
    _unknown_ __ebx;                       // r1
    _unknown_ _t50;                        // _t50
    signed char _t51;                      // _t51
    _unknown_ _t53;                        // _t53
    signed int _t54;                       // _t54
    signed long long _t70;                 // _t70
    signed int _t72;                       // _t72
    long long _t74;                        // _t74
    signed int _t76;                       // _t76
    signed int _t78;                       // _t78
    signed int _t85;                       // _t85
    signed int _t88;                       // _t88
    signed int _t91;                       // _t91
    signed int _t95;                       // _t95

    __edx = _a4;
    _t51 = __i686.get_pc_thunk.bx(_t50);
    _t54 = _t53 + 11765;
    __eflags = _t54;
    _v20 = st3 * st2;
    _v28 = st2 * st1;
    _v36 = st3 * st1;
    _v44 = st2 * st2;
    asm("fst qword [ebp-0x78]");
    asm("fsubr st0, st1");
    asm("fst qword [ebp-0x70]");
    _t70 = _v44;
    asm("fst qword [ebp-0x68]");
    asm("faddp st1, st0");
    asm("fxch st0, st1");
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags != 0) {
        asm("fxch st0, st1");
L10:
        asm("fucom st0");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags != 0) {
L12:
            _t72 = st6 - st7;
            asm("fst qword [ebp-0x60]");
            asm("fxch st0, st7");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0) {
                st7 = _t72;
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
L130:
                _t74 = st6 - st7;
                asm("fst qword [ebp-0x58]");
                asm("fxch st0, st7");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0) {
                    st7 = _t74;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
L141:
                    __ecx = 0;
L37:
                    _t76 = st6 - st7;
                    asm("fst qword [ebp-0x48]");
                    asm("fxch st0, st7");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        st7 = _t76;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
L68:
                        _t78 = st6 - st7;
                        asm("fst qword [ebp-0x40]");
                        asm("fxch st0, st7");
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            st7 = _t78;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
L78:
                            __eflags = __cl;
                            if(__eflags != 0) {
                                st6 = _t78;
                                st3 = _t78;
                                st3 = _t78;
                                asm("fxch st0, st3");
L64:
                                asm("fsubp st1, st0");
                                _t70 =  *(_t54 - 6680) * st0;
                                asm("fxch st0, st5");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st3");
                                asm("fmulp st2, st0");
                                asm("faddp st1, st0");
                                asm("fmulp st2, st0");
L7:
                                 *__edx = _t70;
                                __edx[1] = _t70;
                                return __edx;
                            }
                            _t85 = st6 - st7;
                            asm("fst qword [ebp-0x38]");
                            asm("fxch st0, st7");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                st6 = _t85;
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st4");
                                asm("fxch st0, st5");
L86:
                                _t88 = _v124;
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st0 = _t88;
L93:
                                    _t91 = _v116;
                                    asm("fucomp st0");
                                    asm("fnstsw ax");
                                    asm("sahf");
                                    if(__eflags != 0) {
                                        st0 = _t91;
L100:
                                        _t70 = _v108;
                                        asm("fucomp st0");
                                        asm("fnstsw ax");
                                        asm("sahf");
                                        if(__eflags != 0) {
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            asm("fxch st0, st1");
                                            goto L7;
                                        }
                                        if(__eflags != 0) {
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            asm("fxch st0, st1");
                                            goto L7;
                                        }
                                        asm("fucomp st0");
                                        asm("fnstsw ax");
                                        asm("sahf");
                                        if(__eflags != 0) {
                                            st5 = _t70;
                                            st3 = _t70;
                                            asm("fxch st0, st1");
L112:
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t70;
                                                __eflags = _t51 & 2;
                                                asm("fldz");
                                                if(__eflags != 0) {
                                                    st0 = _t70;
                                                    asm("fldz");
                                                    asm("fchs");
                                                }
                                                asm("fxch st0, st1");
                                            } else {
                                                asm("fxch st0, st1");
                                            }
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t70;
                                                __eflags = _t51 & 2;
                                                asm("fldz");
                                                if(__eflags != 0) {
                                                    st0 = _t70;
                                                    asm("fldz");
                                                    asm("fchs");
                                                }
                                                asm("fxch st0, st2");
                                            } else {
                                                asm("fxch st0, st2");
                                            }
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t70;
                                                __eflags = _t51 & 2;
                                                asm("fldz");
                                                if(__eflags != 0) {
                                                    st0 = _t70;
                                                    asm("fldz");
                                                    asm("fchs");
                                                }
                                                asm("fxch st0, st3");
                                            } else {
                                                asm("fxch st0, st3");
                                            }
                                            asm("fucom st0");
                                            asm("fnstsw ax");
                                            asm("sahf");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fxam");
                                                asm("fnstsw ax");
                                                st0 = _t70;
                                                __eflags = _t51 & 2;
                                                asm("fldz");
                                                if((_t51 & 2) == 0) {
                                                    asm("fxch st0, st1");
                                                    asm("fxch st0, st2");
                                                    asm("fxch st0, st3");
                                                    asm("fxch st0, st1");
L61:
                                                    asm("fxch st0, st2");
                                                    asm("fxch st0, st3");
                                                    asm("fxch st0, st2");
                                                    goto L64;
                                                }
                                                st0 = _t70;
                                                asm("fldz");
                                                asm("fxch st0, st1");
                                                asm("fxch st0, st2");
                                                asm("fxch st0, st3");
                                                asm("fxch st0, st1");
L125:
                                                asm("fchs");
                                                goto L61;
                                            } else {
                                                asm("fxch st0, st1");
                                                asm("fxch st0, st3");
                                                asm("fxch st0, st1");
                                                goto L64;
                                            }
                                        }
                                        if(__eflags == 0) {
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            st0 = _t70;
                                            asm("fxch st0, st1");
                                            goto L7;
                                        }
                                        st5 = _t70;
                                        st3 = _t70;
                                        asm("fxch st0, st1");
                                        goto L112;
                                    }
                                    if(__eflags != 0) {
                                        st0 = _t91;
                                        goto L100;
                                    }
                                    asm("fucomp st0");
                                    asm("fnstsw ax");
                                    asm("sahf");
                                    if(__eflags != 0) {
                                        st5 = _t91;
                                        st3 = _t91;
                                        asm("fxch st0, st1");
                                        goto L112;
                                    }
                                    if(__eflags != 0) {
                                        goto L100;
                                    }
                                    st5 = _t91;
                                    st3 = _t91;
                                    asm("fxch st0, st1");
                                    goto L112;
                                }
                                if(__eflags != 0) {
                                    st0 = _t88;
                                    goto L93;
                                }
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st5 = _t88;
                                    st3 = _t88;
                                    asm("fxch st0, st1");
                                    goto L112;
                                }
                                if(__eflags != 0) {
                                    goto L93;
                                }
                                st5 = _t88;
                                st3 = _t88;
                                asm("fxch st0, st1");
                                goto L112;
                            }
                            if(__eflags != 0) {
                                st6 = _t85;
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st4");
                                asm("fxch st0, st5");
                                goto L86;
                            }
                            asm("fxch st0, st6");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                st4 = _t85;
                                st2 = _t85;
                                goto L112;
                            }
                            if(__eflags != 0) {
                                st4 = _t85;
                                st2 = _t85;
                                goto L112;
                            }
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            goto L86;
                        }
                        if(__eflags != 0) {
                            st7 = _t78;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            goto L78;
                        }
                        asm("fxch st0, st7");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            st3 = _t78;
                            st3 = _t78;
                            st3 = _t78;
L74:
                            asm("fld1");
                            asm("fldz");
                            asm("fxch st0, st1");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st2");
                            asm("fxch st0, st5");
                            asm("fxch st0, st2");
L50:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t78;
                                __eflags = _t51 & 2;
                                asm("fldz");
                                if(__eflags != 0) {
                                    st0 = _t78;
                                    asm("fldz");
                                    asm("fchs");
                                }
                                asm("fxch st0, st4");
                            } else {
                                asm("fxch st0, st4");
                            }
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t78;
                                __eflags = _t51 & 2;
                                asm("fldz");
                                if((_t51 & 2) != 0) {
                                    st0 = _t78;
                                    asm("fldz");
                                    asm("fchs");
                                }
                                asm("fxch st0, st5");
                            } else {
                                asm("fxch st0, st5");
                            }
                            asm("fxam");
                            asm("fnstsw ax");
                            st0 = _t78;
                            __eflags = _t51 & 2;
                            asm("fabs");
                            if((_t51 & 2) != 0) {
                                asm("fchs");
                            }
                            asm("fxch st0, st1");
                            asm("fxam");
                            asm("fnstsw ax");
                            st0 = _t78;
                            asm("fxch st0, st1");
                            __eflags = _t51 & 2;
                            asm("fabs");
                            if((_t51 & 2) != 0) {
                                goto L125;
                            } else {
                                goto L61;
                            }
                        }
                        if(__eflags == 0) {
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            goto L78;
                        }
                        st3 = _t78;
                        st3 = _t78;
                        st3 = _t78;
                        goto L74;
                    }
                    if(__eflags != 0) {
                        st7 = _t76;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L68;
                    }
                    asm("fxch st0, st7");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        st3 = _t76;
                        st3 = _t76;
                        st0 = _t76;
L43:
                        _t78 = st2 - st3;
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            asm("fxch st0, st2");
L47:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                asm("fxch st0, st2");
L164:
                                asm("fldz");
                                asm("fld1");
                                asm("fxch st0, st1");
                                asm("fxch st0, st3");
                                asm("fxch st0, st2");
                                asm("fxch st0, st4");
                                asm("fxch st0, st2");
                                goto L50;
                            }
                            if(__eflags != 0) {
                                asm("fxch st0, st2");
                                goto L164;
                            }
                            asm("fld1");
                            _t78 = st0;
                            asm("fxch st0, st3");
                            goto L50;
                        }
                        if(__eflags == 0) {
                            goto L164;
                        }
                        asm("fxch st0, st2");
                        goto L47;
                    }
                    if(__eflags == 0) {
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L68;
                    }
                    st3 = _t76;
                    st3 = _t76;
                    st0 = _t76;
                    goto L43;
                }
                if(__eflags != 0) {
                    st7 = _t74;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L141;
                }
                asm("fxch st0, st7");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags == 0) {
                    if(__eflags != 0) {
                        goto L133;
                    }
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L141;
                }
L133:
                asm("fxam");
                asm("fnstsw ax");
                st0 = _t74;
                __eflags = _t51 & 2;
                asm("fldz");
                if((_t51 & 2) == 0) {
                    asm("fxch st0, st1");
                    asm("fxch st0, st6");
                    asm("fxch st0, st5");
                    asm("fxch st0, st4");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                } else {
                    st0 = _t74;
                    asm("fldz");
                    asm("fchs");
                    asm("fxch st0, st1");
                    asm("fxch st0, st6");
                    asm("fxch st0, st5");
                    asm("fxch st0, st4");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                }
L136:
                asm("fld1");
                _v84 = _t74;
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
L27:
                asm("fxam");
                asm("fnstsw ax");
                st0 = _t74;
                _t95 = _v84;
                __eflags = _t51 & 2;
                asm("fabs");
                if(__eflags == 0) {
                    asm("fxch st0, st5");
                } else {
                    asm("fchs");
                    asm("fxch st0, st5");
                }
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    asm("fxam");
                    asm("fnstsw ax");
                    st0 = _t95;
                    __eflags = _t51 & 2;
                    asm("fldz");
                    if(__eflags == 0) {
                        asm("fxch st0, st4");
                    } else {
                        st0 = _t95;
                        asm("fldz");
                        asm("fchs");
                        asm("fxch st0, st4");
                    }
                } else {
                    asm("fxch st0, st4");
                }
                asm("fucom st0");
                asm("fnstsw ax");
                __ecx = 1;
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    asm("fxam");
                    asm("fnstsw ax");
                    st0 = _t95;
                    __eflags = _t51 & 2;
                    asm("fldz");
                    if(__eflags != 0) {
                        st0 = _t95;
                        asm("fldz");
                        asm("fchs");
                    }
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                    __ecx = 1;
                } else {
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                }
                goto L37;
            }
            if(__eflags != 0) {
                st7 = _t72;
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
                goto L130;
            }
            asm("fxch st0, st7");
            asm("fucomp st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags == 0) {
                if(__eflags != 0) {
                    asm("fxch st0, st6");
                    goto L17;
                }
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
                goto L130;
            } else {
                asm("fxch st0, st6");
L17:
                asm("fxam");
                asm("fnstsw ax");
                st0 = _t72;
                __eflags = _t51 & 2;
                asm("fld1");
                if(__eflags != 0) {
                    st0 = _t72;
                    asm("fld1");
                    asm("fchs");
                }
                _t74 = st5 - st6;
                asm("fst qword [ebp-0x30]");
                asm("fxch st0, st6");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0) {
                    st6 = _t74;
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L26;
                } else {
                    if(__eflags != 0) {
                        st6 = _t74;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
L26:
                        asm("fldz");
                        _v84 = _t74;
                        goto L27;
                    }
                    asm("fxch st0, st6");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0 || __eflags != 0) {
                        goto L136;
                    } else {
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        goto L26;
                    }
                }
            }
        }
        if(__eflags == 0) {
            st6 = _t70;
            st4 = _t70;
            st0 = _t70;
            st0 = _t70;
            st0 = _t70;
            goto L7;
        }
        goto L12;
    }
    if(__eflags != 0) {
        asm("fxch st0, st1");
        goto L10;
    } else {
        st5 = _t70;
        st5 = _t70;
        st0 = _t70;
        st0 = _t70;
        st0 = _t70;
        goto L7;
    }
}

__i686.get_pc_thunk.bx(
    _unknown_ __eax                        // r0
)
{// addr = 0x08053887
    __eax = __eax;
    return __eax;
}

__divsc3(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    _unknown_ _a16                         // _cfa_10
)
{// addr = 0x08053890
    signed long long _v8;                  // _cfa_fffffff8
    signed long long _v12;                 // _cfa_fffffff4
    _unknown_ _t24;                        // _t24
    signed char _t25;                      // _t25
    signed char _t26;                      // _t26
    signed char _t27;                      // _t27
    _unknown_ _t29;                        // _t29
    signed int _t30;                       // _t30
    signed int _t32;                       // _t32
    signed int _t34;                       // _t34
    signed long long _t52;                 // _t52
    signed int _t59;                       // _t59
    signed int _t66;                       // _t66
    signed int _t68;                       // _t68
    signed long long _t75;                 // _t75
    signed int _t82;                       // _t82

    asm("fabs");
    asm("fabs");
    asm("fucompp");
    asm("fnstsw ax");
    _t25 = __i686.get_pc_thunk.cx(_t24);
    _t30 = _t29 + 10049;
    __eflags = _t30;
    asm("sahf");
    if(__eflags <= 0) {
        asm("fxch st0, st2");
        _t52 = st5;
        asm("fsubrp st1, st0");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    } else {
        asm("fmulp st3, st0");
        asm("fxch st0, st2");
        _t52 = st5 - st6;
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    }
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags != 0) {
        asm("fxch st0, st1");
        goto L17;
    } else {
        if(__eflags != 0) {
            asm("fxch st0, st1");
L17:
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0) {
L19:
                asm("fldz");
                asm("fxch st0, st4");
                asm("fucom st4");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0) {
                    st4 = _t52;
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
L25:
                    asm("fst dword [ebp-0x4]");
                    asm("fxch st0, st6");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("fxch st0, st6");
                    asm("sahf");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    _t26 = __eflags ?_? 0;
                    _t32 = __eflags ?_? 0 & _t26;
                    __eflags = _t32;
                    if(__eflags != 0) {
L30:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
L55:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("fxch st0, st4");
                            asm("sahf");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            _t27 = __eflags ?_? 0;
                            _t34 = __eflags ?_? 0 & _t27;
                            __eflags = _t34;
                            if(__eflags != 0) {
L60:
                                _t52 = _v8;
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st0 = _t52;
                                    st4 = _t52;
                                    st2 = _t52;
                                    st0 = _t52;
                                    goto L13;
                                }
                                if(__eflags != 0) {
                                    st0 = _t52;
                                    st4 = _t52;
                                    st2 = _t52;
                                    st0 = _t52;
                                    goto L13;
                                }
                                _t52 = st0 - st1;
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st0 = _t52;
                                    st4 = _t52;
                                    st2 = _t52;
                                    st0 = _t52;
                                    goto L13;
                                }
                                if(__eflags != 0) {
                                    st0 = _t52;
                                    st4 = _t52;
                                    st2 = _t52;
                                    st0 = _t52;
                                    goto L13;
                                }
                                st2 = _t52;
                                st0 = _t52;
                                __eflags = _t34;
                                if(_t34 != 0) {
                                    asm("fld1");
                                    asm("fxch st0, st2");
                                } else {
                                    asm("fldz");
                                    asm("fxch st0, st2");
                                }
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t52;
                                asm("fxch st0, st1");
                                __eflags = _t27 & 2;
                                asm("fabs");
                                if(__eflags != 0) {
                                    asm("fchs");
                                }
                                _t59 = st2 - st3;
                                asm("fxch st0, st3");
                                asm("fucom st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st3 = _t59;
                                    asm("fxch st0, st1");
                                    asm("fxch st0, st2");
                                    goto L91;
                                } else {
                                    if(__eflags != 0) {
                                        st3 = _t59;
                                        asm("fxch st0, st1");
                                        asm("fxch st0, st2");
L91:
                                        asm("fldz");
                                        asm("fxch st0, st3");
                                        asm("fxch st0, st2");
                                        asm("fxch st0, st1");
L73:
                                        asm("fxam");
                                        asm("fnstsw ax");
                                        st0 = _t59;
                                        asm("fxch st0, st2");
                                        __eflags = _t27 & 2;
                                        asm("fabs");
                                        if((_t27 & 2) != 0) {
                                            asm("fchs");
                                        }
                                        asm("faddp st1, st0");
                                        asm("fldz");
                                        _t52 = st2 * st2 * st0;
                                        asm("fxch st0, st4");
                                        asm("fmulp st3, st0");
                                        asm("fxch st0, st4");
                                        asm("fmulp st1, st0");
                                        asm("fsubp st1, st0");
                                        asm("fmulp st1, st0");
                                        asm("fxch st0, st1");
                                        goto L13;
                                    }
                                    asm("fxch st0, st3");
                                    asm("fucomp st0");
                                    asm("fnstsw ax");
                                    asm("sahf");
                                    if(__eflags != 0 || __eflags != 0) {
                                        asm("fld1");
                                        asm("fxch st0, st3");
                                        goto L73;
                                    } else {
                                        asm("fxch st0, st1");
                                        asm("fxch st0, st2");
                                        goto L91;
                                    }
                                }
                            }
                            _t52 = st4 - st5;
                            asm("fxch st0, st5");
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                st0 = _t52;
                                st0 = _t52;
                                st4 = _t52;
                                st2 = _t52;
                                st0 = _t52;
                                goto L13;
                            }
                            if(__eflags != 0) {
                                st0 = _t52;
                                st0 = _t52;
                                st4 = _t52;
                                st2 = _t52;
                                st0 = _t52;
                                goto L13;
                            }
                            asm("fxch st0, st5");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                goto L60;
                            } else {
                                st0 = _t52;
                                st4 = _t52;
                                st2 = _t52;
                                st0 = _t52;
                                goto L13;
                            }
                        }
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        }
                        _t66 = st4 - st5;
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        }
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        }
                        st0 = _t66;
                        st0 = _t66;
                        st0 = _t66;
                        __eflags = _t32;
                        if(_t32 != 0) {
                            asm("fld1");
                            asm("fxch st0, st4");
                        } else {
                            asm("fldz");
                            asm("fxch st0, st4");
                        }
                        asm("fxam");
                        asm("fnstsw ax");
                        st0 = _t66;
                        asm("fxch st0, st3");
                        __eflags = _t26 & 2;
                        asm("fabs");
                        if(__eflags != 0) {
                            asm("fchs");
                        }
                        _t68 = st2 - st3;
                        asm("fxch st0, st3");
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            st3 = _t68;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            goto L96;
                        } else {
                            if(__eflags != 0) {
                                st3 = _t68;
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
L96:
                                asm("fldz");
                                asm("fxch st0, st3");
                                asm("fxch st0, st2");
                                asm("fxch st0, st1");
L43:
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t68;
                                asm("fxch st0, st2");
                                __eflags = _t26 & 2;
                                asm("fabs");
                                if((_t26 & 2) != 0) {
                                    asm("fchs");
                                }
                                asm("faddp st1, st0");
                                _t52 =  *(_t30 - 6680) * st0;
                                asm("fxch st0, st2");
                                asm("fmulp st5, st0");
                                asm("fxch st0, st3");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st3");
                                asm("fsubrp st1, st0");
                                asm("fmulp st2, st0");
                                goto L13;
                            }
                            asm("fxch st0, st3");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fld1");
                                asm("fxch st0, st3");
                                goto L43;
                            } else {
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                goto L96;
                            }
                        }
                    }
                    _t75 = st4 - st5;
                    asm("fxch st0, st5");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        st5 = _t75;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
L79:
                        asm("fxch st0, st4");
                        goto L55;
                    }
                    if(__eflags != 0) {
                        st5 = _t75;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        goto L79;
                    }
                    asm("fxch st0, st5");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0 || __eflags != 0) {
                        goto L30;
                    } else {
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        goto L79;
                    }
                }
                if(__eflags != 0) {
                    st4 = _t52;
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    goto L25;
                }
                asm("fxch st0, st3");
                asm("fucom st4");
                asm("fnstsw ax");
                st4 = _t52;
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    goto L25;
                } else {
                    asm("fxch st0, st5");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        asm("fxch st0, st4");
L48:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0 || __eflags == 0) {
                            _v8 = st4 - st5;
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        } else {
                            st3 = _t52;
                            st0 = _t52;
                            st3 = _t52;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
L85:
                            asm("fxam");
                            asm("fnstsw ax");
                            st0 = _t52;
                            __eflags = _t25 & 2;
                            _t82 =  *(_t30 - 6680);
                            if((_t25 & 2) != 0) {
                                st0 = _t82;
                            }
                            _t52 = st0;
                            asm("fmulp st3, st0");
                            asm("fmulp st1, st0");
                            asm("fxch st0, st1");
                            goto L13;
                        }
                    }
                    if(__eflags != 0) {
                        asm("fxch st0, st4");
                        goto L48;
                    }
                    st5 = _t52;
                    st0 = _t52;
                    st1 = _t52;
                    goto L85;
                }
            }
            if(__eflags == 0) {
                st5 = _t52;
                st3 = _t52;
                st0 = _t52;
                st0 = _t52;
                goto L13;
            }
            goto L19;
        } else {
            st4 = _t52;
            st4 = _t52;
            st0 = _t52;
            st0 = _t52;
L13:
            _v12 = _t52;
            _v12 = _t52;
            return _v12;
        }
    }
}

signed long long* __divdc3(
    _unknown_ __edx,                       // r3
    signed long long* _a4,                 // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a16,                        // _cfa_10
    _unknown_ _a24,                        // _cfa_18
    _unknown_ _a32                         // _cfa_20
)
{// addr = 0x08053D00
    signed long long _v20;                 // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ _t22;                        // _t22
    signed char _t23;                      // _t23
    signed char _t24;                      // _t24
    signed char _t25;                      // _t25
    _unknown_ _t27;                        // _t27
    signed int _t28;                       // _t28
    signed int _t31;                       // _t31
    signed int _t33;                       // _t33
    signed long long _t50;                 // _t50
    signed int _t57;                       // _t57
    signed int _t64;                       // _t64
    signed int _t66;                       // _t66
    signed long long _t73;                 // _t73
    signed int _t80;                       // _t80

    __ecx = _a4;
    asm("fabs");
    asm("fabs");
    asm("fucompp");
    asm("fnstsw ax");
    _t23 = __i686.get_pc_thunk.bx(_t22);
    _t28 = _t27 + 8909;
    __eflags = _t28;
    asm("sahf");
    if(__eflags <= 0) {
        asm("fxch st0, st2");
        _t50 = st5;
        asm("fsubrp st1, st0");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    } else {
        asm("fmulp st3, st0");
        asm("fxch st0, st2");
        _t50 = st5 - st6;
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    }
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags != 0) {
        asm("fxch st0, st1");
        goto L17;
    } else {
        if(__eflags != 0) {
            asm("fxch st0, st1");
L17:
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags != 0) {
L19:
                asm("fldz");
                asm("fxch st0, st4");
                asm("fucom st4");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags != 0) {
                    st4 = _t50;
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
L25:
                    asm("fst qword [ebp-0x10]");
                    asm("fxch st0, st6");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("fxch st0, st6");
                    asm("sahf");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    _t24 = __eflags ?_? 0;
                    _t31 = __eflags ?_? 0 & _t24;
                    __eflags = _t31;
                    if(__eflags != 0) {
L30:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
L55:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("fxch st0, st4");
                            asm("sahf");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            _t25 = __eflags ?_? 0;
                            _t33 = __eflags ?_? 0 & _t25;
                            __eflags = _t33;
                            if(__eflags != 0) {
L60:
                                _t50 = _v20;
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st0 = _t50;
                                    st4 = _t50;
                                    st2 = _t50;
                                    st0 = _t50;
                                    goto L13;
                                }
                                if(__eflags != 0) {
                                    st0 = _t50;
                                    st4 = _t50;
                                    st2 = _t50;
                                    st0 = _t50;
                                    goto L13;
                                }
                                _t50 = st0 - st1;
                                asm("fucomp st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st0 = _t50;
                                    st4 = _t50;
                                    st2 = _t50;
                                    st0 = _t50;
                                    goto L13;
                                }
                                if(__eflags != 0) {
                                    st0 = _t50;
                                    st4 = _t50;
                                    st2 = _t50;
                                    st0 = _t50;
                                    goto L13;
                                }
                                st2 = _t50;
                                st0 = _t50;
                                __eflags = _t33;
                                if(_t33 != 0) {
                                    asm("fld1");
                                    asm("fxch st0, st2");
                                } else {
                                    asm("fldz");
                                    asm("fxch st0, st2");
                                }
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t50;
                                asm("fxch st0, st1");
                                __eflags = _t25 & 2;
                                asm("fabs");
                                if(__eflags != 0) {
                                    asm("fchs");
                                }
                                _t57 = st2 - st3;
                                asm("fxch st0, st3");
                                asm("fucom st0");
                                asm("fnstsw ax");
                                asm("sahf");
                                if(__eflags != 0) {
                                    st3 = _t57;
                                    asm("fxch st0, st1");
                                    asm("fxch st0, st2");
                                    goto L91;
                                } else {
                                    if(__eflags != 0) {
                                        st3 = _t57;
                                        asm("fxch st0, st1");
                                        asm("fxch st0, st2");
L91:
                                        asm("fldz");
                                        asm("fxch st0, st3");
                                        asm("fxch st0, st2");
                                        asm("fxch st0, st1");
L73:
                                        asm("fxam");
                                        asm("fnstsw ax");
                                        st0 = _t57;
                                        asm("fxch st0, st2");
                                        __eflags = _t25 & 2;
                                        asm("fabs");
                                        if((_t25 & 2) != 0) {
                                            asm("fchs");
                                        }
                                        asm("faddp st1, st0");
                                        asm("fldz");
                                        _t50 = st2 * st2 * st0;
                                        asm("fxch st0, st4");
                                        asm("fmulp st3, st0");
                                        asm("fxch st0, st4");
                                        asm("fmulp st1, st0");
                                        asm("fsubp st1, st0");
                                        asm("fmulp st1, st0");
                                        asm("fxch st0, st1");
                                        goto L13;
                                    }
                                    asm("fxch st0, st3");
                                    asm("fucomp st0");
                                    asm("fnstsw ax");
                                    asm("sahf");
                                    if(__eflags != 0 || __eflags != 0) {
                                        asm("fld1");
                                        asm("fxch st0, st3");
                                        goto L73;
                                    } else {
                                        asm("fxch st0, st1");
                                        asm("fxch st0, st2");
                                        goto L91;
                                    }
                                }
                            }
                            _t50 = st4 - st5;
                            asm("fxch st0, st5");
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0) {
                                st0 = _t50;
                                st0 = _t50;
                                st4 = _t50;
                                st2 = _t50;
                                st0 = _t50;
                                goto L13;
                            }
                            if(__eflags != 0) {
                                st0 = _t50;
                                st0 = _t50;
                                st4 = _t50;
                                st2 = _t50;
                                st0 = _t50;
                                goto L13;
                            }
                            asm("fxch st0, st5");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                goto L60;
                            } else {
                                st0 = _t50;
                                st4 = _t50;
                                st2 = _t50;
                                st0 = _t50;
                                goto L13;
                            }
                        }
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        }
                        _t64 = st4 - st5;
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        }
                        if(__eflags != 0) {
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        }
                        st0 = _t64;
                        st0 = _t64;
                        st0 = _t64;
                        __eflags = _t31;
                        if(_t31 != 0) {
                            asm("fld1");
                            asm("fxch st0, st4");
                        } else {
                            asm("fldz");
                            asm("fxch st0, st4");
                        }
                        asm("fxam");
                        asm("fnstsw ax");
                        st0 = _t64;
                        asm("fxch st0, st3");
                        __eflags = _t24 & 2;
                        asm("fabs");
                        if(__eflags != 0) {
                            asm("fchs");
                        }
                        _t66 = st2 - st3;
                        asm("fxch st0, st3");
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0) {
                            st3 = _t66;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            goto L96;
                        } else {
                            if(__eflags != 0) {
                                st3 = _t66;
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
L96:
                                asm("fldz");
                                asm("fxch st0, st3");
                                asm("fxch st0, st2");
                                asm("fxch st0, st1");
L43:
                                asm("fxam");
                                asm("fnstsw ax");
                                st0 = _t66;
                                asm("fxch st0, st2");
                                __eflags = _t24 & 2;
                                asm("fabs");
                                if((_t24 & 2) != 0) {
                                    asm("fchs");
                                }
                                asm("faddp st1, st0");
                                _t50 =  *(_t28 - 6680) * st0;
                                asm("fxch st0, st2");
                                asm("fmulp st5, st0");
                                asm("fxch st0, st3");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st3");
                                asm("fsubrp st1, st0");
                                asm("fmulp st2, st0");
                                goto L13;
                            }
                            asm("fxch st0, st3");
                            asm("fucomp st0");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fld1");
                                asm("fxch st0, st3");
                                goto L43;
                            } else {
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                goto L96;
                            }
                        }
                    }
                    _t73 = st4 - st5;
                    asm("fxch st0, st5");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        st5 = _t73;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
L79:
                        asm("fxch st0, st4");
                        goto L55;
                    }
                    if(__eflags != 0) {
                        st5 = _t73;
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        goto L79;
                    }
                    asm("fxch st0, st5");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0 || __eflags != 0) {
                        goto L30;
                    } else {
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        goto L79;
                    }
                }
                if(__eflags != 0) {
                    st4 = _t50;
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    goto L25;
                }
                asm("fxch st0, st3");
                asm("fucom st4");
                asm("fnstsw ax");
                st4 = _t50;
                asm("sahf");
                if(__eflags != 0 || __eflags != 0) {
                    goto L25;
                } else {
                    asm("fxch st0, st5");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags != 0) {
                        asm("fxch st0, st4");
L48:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags != 0 || __eflags == 0) {
                            _v20 = st4 - st5;
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            goto L55;
                        } else {
                            st3 = _t50;
                            st0 = _t50;
                            st3 = _t50;
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
L85:
                            asm("fxam");
                            asm("fnstsw ax");
                            st0 = _t50;
                            __eflags = _t23 & 2;
                            _t80 =  *(_t28 - 6680);
                            if((_t23 & 2) != 0) {
                                st0 = _t80;
                            }
                            _t50 = st0;
                            asm("fmulp st3, st0");
                            asm("fmulp st1, st0");
                            asm("fxch st0, st1");
                            goto L13;
                        }
                    }
                    if(__eflags != 0) {
                        asm("fxch st0, st4");
                        goto L48;
                    }
                    st5 = _t50;
                    st0 = _t50;
                    st1 = _t50;
                    goto L85;
                }
            }
            if(__eflags == 0) {
                st5 = _t50;
                st3 = _t50;
                st0 = _t50;
                st0 = _t50;
                goto L13;
            }
            goto L19;
        } else {
            st4 = _t50;
            st4 = _t50;
            st0 = _t50;
            st0 = _t50;
L13:
             *__ecx = _t50;
            __ecx[1] = _t50;
            return __ecx;
        }
    }
}

__libc_csu_fini(
    _unknown_ __eax                        // r0
)
{// addr = 0x08054170
    __eax = __eax;
    return __eax;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08054180
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ _t11;                        // _t11
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    __i686.get_pc_thunk.bx(_t11);
    _t18 = _t17 + 7785;
    __esp = __esp - 12;
    _init();
    _t21 = _t18 - 244 - _t18 - 244 >> 2;
    if(_t21 != 0) {
        __esi = 0;
        do {
            _v20 = _a12;
            _v24 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t18 + __esi * 4 - 244))();
            __esi = __esi + 1;
        } while(__esi < _t21);
    }
    __esp = __esp + 12;
}

atexit(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080541E0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(0);
    __esp = __esp - 12;
    __edx =  *((intOrPtr*)(_t8 + 7689 - 4));
    if(__edx != 0) {
        _t6 =  *__edx;
    }
    _v12 = _t6;
    _t7 = _a4;
    _v16 = 0;
     *__esp = _t7;
    __cxa_atexit();
    __esp = __esp + 12;
    return _t7;
}

__do_global_ctors_aux()
{// addr = 0x08054220
    intOrPtr* __ebx;                       // r1

    __eax = __CTOR_LIST__;
    if(__eax != -1) {
        __ebx =  &__CTOR_LIST__;
        do {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
        } while(__eax != -1);
    }
}

_fini()
{// addr = 0x0805424C
    _unknown_ __ebx;                       // r1
    _unknown_ _t1;                         // _t1

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    return __eax;
}

L08054258()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

L08054258()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = @rec __do_global_dtors_aux@__do_global_dtors_aux@();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

// Statistics:
//    1188 Register nodes
//    2741 Temporaries nodes
//     209 Casts
//    1651 Statements
//     244 Labels
//     220 Gotos
//     195 Blocks
//   26088 Nodes
//    1554 Assembly nodes
//     307 Unknown Types


Total time: 2 seconds.
