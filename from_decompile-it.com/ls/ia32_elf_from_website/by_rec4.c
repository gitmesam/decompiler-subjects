// Generated by Rec Studio 4 - build Sep 23 2015

_init()
{// addr = 0x0804947C
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 109420 - 8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    return _t3;
}

L08049488()
{
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 109420 - 8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return _t3;
}

abort()
{// addr = 0x080494BC
    goto __imp__abort;
}

__errno_location()
{// addr = 0x080494CC
    goto __imp____errno_location;
}

putc_unlocked()
{// addr = 0x080494DC
    goto __imp__putc_unlocked;
}

sigemptyset()
{// addr = 0x080494EC
    goto __imp__sigemptyset;
}

sprintf()
{// addr = 0x080494FC
    goto __imp__sprintf;
}

localeconv()
{// addr = 0x0804950C
    goto __imp__localeconv;
}

dirfd()
{// addr = 0x0804951C
    goto __imp__dirfd;
}

__cxa_atexit()
{// addr = 0x0804952C
    goto __imp____cxa_atexit;
}

strcoll()
{// addr = 0x0804953C
    goto __imp__strcoll;
}

memcmp()
{// addr = 0x0804954C
    goto __imp__memcmp;
}

fputs_unlocked()
{// addr = 0x0804955C
    goto __imp__fputs_unlocked;
}

__ctype_get_mb_cur_max()
{// addr = 0x0804956C
    goto __imp____ctype_get_mb_cur_max;
}

signal()
{// addr = 0x0804957C
    goto __imp__signal;
}

sigismember()
{// addr = 0x0804958C
    goto __imp__sigismember;
}

__gmon_start__()
{// addr = 0x0804959C
    goto __imp____gmon_start__;
}

realloc()
{// addr = 0x080495AC
    goto __imp__realloc;
}

__xstat64()
{// addr = 0x080495BC
    goto __imp____xstat64;
}

localtime()
{// addr = 0x080495CC
    goto __imp__localtime;
}

getgrnam()
{// addr = 0x080495DC
    goto __imp__getgrnam;
}

strchr()
{// addr = 0x080495EC
    goto __imp__strchr;
}

getenv()
{// addr = 0x080495FC
    goto __imp__getenv;
}

calloc()
{// addr = 0x0804960C
    goto __imp__calloc;
}

strncpy()
{// addr = 0x0804961C
    goto __imp__strncpy;
}

gnu_dev_minor()
{// addr = 0x0804962C
    goto __imp__gnu_dev_minor;
}

toupper()
{// addr = 0x0804963C
    goto __imp__toupper;
}

memset()
{// addr = 0x0804964C
    goto __imp__memset;
}

__libc_start_main()
{// addr = 0x0804965C
    goto __imp____libc_start_main;
}

mempcpy()
{// addr = 0x0804966C
    goto __imp__mempcpy;
}

_obstack_begin()
{// addr = 0x0804967C
    goto __imp___obstack_begin;
}

ferror_unlocked()
{// addr = 0x0804968C
    goto __imp__ferror_unlocked;
}

_exit()
{// addr = 0x0804969C
    goto __imp___exit;
}

strrchr()
{// addr = 0x080496AC
    goto __imp__strrchr;
}

__assert_fail()
{// addr = 0x080496BC
    goto __imp____assert_fail;
}

bindtextdomain()
{// addr = 0x080496CC
    goto __imp__bindtextdomain;
}

mbrtowc()
{// addr = 0x080496DC
    goto __imp__mbrtowc;
}

gettext()
{// addr = 0x080496EC
    goto __imp__gettext;
}

gettimeofday()
{// addr = 0x080496FC
    goto __imp__gettimeofday;
}

free()
{// addr = 0x0804970C
    goto __imp__free;
}

__lxstat64()
{// addr = 0x0804971C
    goto __imp____lxstat64;
}

strtoumax()
{// addr = 0x0804972C
    goto __imp__strtoumax;
}

_obstack_newchunk()
{// addr = 0x0804973C
    goto __imp___obstack_newchunk;
}

dcgettext()
{// addr = 0x0804974C
    goto __imp__dcgettext;
}

sigaction()
{// addr = 0x0804975C
    goto __imp__sigaction;
}

strverscmp()
{// addr = 0x0804976C
    goto __imp__strverscmp;
}

opendir()
{// addr = 0x0804977C
    goto __imp__opendir;
}

getopt_long()
{// addr = 0x0804978C
    goto __imp__getopt_long;
}

ioctl()
{// addr = 0x0804979C
    goto __imp__ioctl;
}

__ctype_b_loc()
{// addr = 0x080497AC
    goto __imp____ctype_b_loc;
}

iswcntrl()
{// addr = 0x080497BC
    goto __imp__iswcntrl;
}

isatty()
{// addr = 0x080497CC
    goto __imp__isatty;
}

fclose()
{// addr = 0x080497DC
    goto __imp__fclose;
}

mbsinit()
{// addr = 0x080497EC
    goto __imp__mbsinit;
}

_setjmp()
{// addr = 0x080497FC
    goto __imp___setjmp;
}

tcgetpgrp()
{// addr = 0x0804980C
    goto __imp__tcgetpgrp;
}

readdir64()
{// addr = 0x0804982C
    goto __imp__readdir64;
}

memcpy()
{// addr = 0x0804983C
    goto __imp__memcpy;
}

strtoul()
{// addr = 0x0804984C
    goto __imp__strtoul;
}

strlen()
{// addr = 0x0804985C
    goto __imp__strlen;
}

getpwuid()
{// addr = 0x0804986C
    goto __imp__getpwuid;
}

setlocale()
{// addr = 0x0804987C
    goto __imp__setlocale;
}

strcpy()
{// addr = 0x0804988C
    goto __imp__strcpy;
}

longjmp()
{// addr = 0x0804989C
    goto __imp__longjmp;
}

printf()
{// addr = 0x080498AC
    goto __imp__printf;
}

raise()
{// addr = 0x080498BC
    goto __imp__raise;
}

mbrlen()
{// addr = 0x080498CC
    goto __imp__mbrlen;
}

fwrite_unlocked()
{// addr = 0x080498DC
    goto __imp__fwrite_unlocked;
}

__signbitl()
{// addr = 0x080498EC
    goto __imp____signbitl;
}

clock_gettime()
{// addr = 0x080498FC
    goto __imp__clock_gettime;
}

closedir()
{// addr = 0x0804990C
    goto __imp__closedir;
}

fwrite()
{// addr = 0x0804991C
    goto __imp__fwrite;
}

fprintf()
{// addr = 0x0804992C
    goto __imp__fprintf;
}

malloc()
{// addr = 0x0804993C
    goto __imp__malloc;
}

sigprocmask()
{// addr = 0x0804994C
    goto __imp__sigprocmask;
}

__stack_chk_fail()
{// addr = 0x0804995C
    goto __imp____stack_chk_fail;
}

__fpending()
{// addr = 0x0804996C
    goto __imp____fpending;
}

error()
{// addr = 0x0804997C
    goto __imp__error;
}

getgrgid()
{// addr = 0x0804998C
    goto __imp__getgrgid;
}

sigaddset()
{// addr = 0x0804999C
    goto __imp__sigaddset;
}

readlink()
{// addr = 0x080499AC
    goto __imp__readlink;
}

memmove()
{// addr = 0x080499BC
    goto __imp__memmove;
}

strndup()
{// addr = 0x080499CC
    goto __imp__strndup;
}

textdomain()
{// addr = 0x080499DC
    goto __imp__textdomain;
}

__fxstat64()
{// addr = 0x080499EC
    goto __imp____fxstat64;
}

gnu_dev_major()
{// addr = 0x080499FC
    goto __imp__gnu_dev_major;
}

fnmatch()
{// addr = 0x08049A0C
    goto __imp__fnmatch;
}

strncmp()
{// addr = 0x08049A1C
    goto __imp__strncmp;
}

fflush_unlocked()
{// addr = 0x08049A2C
    goto __imp__fflush_unlocked;
}

wcwidth()
{// addr = 0x08049A5C
    goto __imp__wcwidth;
}

iswprint()
{// addr = 0x08049A6C
    goto __imp__iswprint;
}

getpwnam()
{// addr = 0x08049A7C
    goto __imp__getpwnam;
}

tolower()
{// addr = 0x08049A8C
    goto __imp__tolower;
}

strcmp()
{// addr = 0x08049A9C
    goto __imp__strcmp;
}

exit()
{// addr = 0x08049AAC
    goto __imp__exit;
}

putchar_unlocked()
{// addr = 0x08049ABC
    goto __imp__putchar_unlocked;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08049AD0
    signed int __ebx;                      // r1
    signed int _t9;                        // _t9

    _t5 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & -16;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(__esi);
    _push(main);
    __libc_start_main();
    asm("hlt");
    0;
    0;
    _push(0);
    _push(__ebx);
    __esp = __esp - 4;
    if(completed.6635 == 0) {
        _t9 = dtor_idx.6637;
        _t5 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        while(_t9 < __ebx) {
            _t5 = _t9 + 1;
            dtor_idx.6637 = _t5;
             *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
            _t9 = dtor_idx.6637;
        }
        completed.6635 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
}

__do_global_dtors_aux()
{// addr = 0x08049B00
    signed int __ebx;                      // r1
    _unknown_ _t5;                         // _t5

    if(completed.6635 == 0) {
        __edx = dtor_idx.6637;
        _t8 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(__edx >= __ebx) {
L4:
            completed.6635 = 1;
            return;
        }
        do {
            _t8 = __edx + 1;
            dtor_idx.6637 = _t8;
             *((intOrPtr*)(_t8 * 4 +  &__DTOR_LIST__))();
            __edx = dtor_idx.6637;
        } while(__edx < __ebx);
        goto L4;
    }
}

frame_dummy()
{// addr = 0x08049B60
    if(__JCR_LIST__ == 0 || 0 == 0) {
        return;
    } else {
         *__esp =  &__JCR_LIST__;
         *0();
        return;
    }
}

struct dev_ino dev_ino_pop()
{// addr = 0x08049B84  --  defined in 'ls.c' at line 917
    int __len;                             // _cfa_fffffff8
    struct obstack* __o;   // _cfa_fffffff4
    const struct obstack* __o;   // _cfa_fffffff0
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8

    __o =  &dev_ino_obstack;
    if(__o->next_free - __o->object_base <= 15) {
        _v32 = "dev_ino_pop";
        _v36 = 918;
        _v40 = "ls.c";
         *__esp = "sizeof (struct dev_ino) <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (unsigned) (__o->next_free - __o->object_base); })";
        __assert_fail();
    }
    __o =  &dev_ino_obstack;
    __len = -16;
    if(__o->chunk_limit - __o->next_free < __len) {
        _v40 = __len;
         *__esp = __o;
        _obstack_newchunk();
    }
    __o->next_free =  &(__o->next_free[__len]);
    _v36 = 16;
    _v40 = dev_ino_obstack.next_free;
     *__esp = _a4.st_ino;
    memmove();
    return _a4;
}

void dired_dump_obstack(const char* prefix, struct obstack* os)
{// addr = 0x08049C3B  --  defined in 'ls.c' at line 940
    _Unknown_base* __value;                // _cfa_fffffff4
    struct obstack* __o1;   // _cfa_fffffff0
    size_t* pos;        // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    const struct obstack* __o;   // _cfa_ffffffe4
    size_t n_pos;       // _cfa_ffffffe0
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1

    __o = os;
    n_pos = __o->next_free - __o->object_base >> 2;
    if(n_pos != 0) {
        __o1 = os;
        __value = __o1->object_base;
        if(__o1->next_free == __value) {
            __o1->use_extra_arg = __o1->use_extra_arg & 255 | 2;
        }
        __o1->next_free =  !(__o1->alignment_mask) &  &(__o1->next_free[__o1->alignment_mask]);
        if(__o1->next_free - __o1->chunk > __o1->chunk_limit - __o1->chunk) {
            __o1->next_free = __o1->chunk_limit;
        }
        __o1->object_base = __o1->next_free;
        pos = __value;
        _v56 = __imp__stdout;
         *__esp = prefix;
        fputs_unlocked();
        i = 0;
        while(i < n_pos) {
            _v56 =  *((intOrPtr*)(pos + (i << 2)));
             *__esp = " %lu";
            printf();
            i = i + 1;
        }
         *__esp = 10;
        putchar_unlocked();
        return;
    }
}

size_t dev_ino_hash(* x, size_t table_size)
{// addr = 0x08049D54  --  defined in 'ls.c' at line 959
    const struct dev_ino* p;   // _cfa_fffffff4
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = x;
    return __umoddi3(p->st_ino,  *((intOrPtr*)(_t10 + 4)), table_size, 0);
}

_Bool dev_ino_compare(* x, * y)
{// addr = 0x08049D8B  --  defined in 'ls.c' at line 966
    const struct dev_ino* b;   // _cfa_fffffff0
    const struct dev_ino* a;   // _cfa_ffffffec
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5

    a = x;
    b = y;
    _t20 = a;
    if((b->st_ino ^ a->st_ino | _t20->st_ino ^ b->st_ino) != 0) {
L3:
        _v32 = 0;
    } else {
        _t26 = a;
        if((b->st_dev ^ a->st_dev | _t26->st_dev ^ b->st_dev) != 0) {
            goto L3;
        } else {
            _v32 = 1;
        }
    }
    return _v32 & 255;
}

void dev_ino_free(_Unknown_base* x)
{// addr = 0x08049DF4  --  defined in 'ls.c' at line 974
     *__esp = x;
    free();
}

_Bool visit_dir(dev_t dev, ino_t ino)
{// addr = 0x08049E07  --  defined in 'ls.c' at line 984
    _Bool found_match;                     // _cfa_fffffffb
    struct dev_ino* ent_from_table;   // _cfa_fffffff4
    struct dev_ino* ent;   // _cfa_fffffff0
    long long unsigned int _v24;           // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    long long unsigned int _v32;           // _cfa_ffffffe0
    long long unsigned int _v36;           // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct dev_ino* _t42;   // _t42
    struct dev_ino* _t43;   // _t43

    _v28 = dev;
    _v24 = ino;
    _v36 = _a12;
    _v32 = _a16;
    ent = xmalloc(16);
    _t42 = ent;
    _t42->st_ino = _v36;
    _t42->st_ino = _v32;
    _t43 = ent;
    _t43->st_dev = _v28;
    _t43->st_dev = _v24;
    ent_from_table = hash_insert(active_dir_set, ent);
    if(ent_from_table == 0) {
        xalloc_die();
    }
    found_match = ent_from_table != ent;
    if(found_match != 0) {
         *__esp = ent;
        free();
    }
    return found_match & 255;
}

void free_pending_ent(struct pending* p)
{// addr = 0x08049E97  --  defined in 'ls.c' at line 1015
     *__esp = p->name;
    free();
     *__esp = p->realname;
    free();
     *__esp = p;
    free();
}

_Bool is_colored(union indicator_no type)
{// addr = 0x08049EC5  --  defined in 'ls.c' at line 1023
    const char* s;   // _cfa_fffffff8
    size_t len;         // _cfa_fffffff4
    signed char _v24;                      // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    const char* _t24;   // _t24

    len =  *( &color_indicator + type * 8);
    s =  *(134627812 + type * 8);
    if(len == 0 || len == 1 && ( *s & 255) == ( *134604345 & 255)) {
L6:
        _v24 = 0;
        goto L7;
    } else {
        if(len != 2) {
L5:
            _v24 = 1;
L7:
            return _v24 & 255;
        }
        _v36 = 2;
        _v40 = "00";
        _t24 = s;
         *__esp = _t24;
        strncmp();
        if(_t24 == 0) {
            goto L6;
        }
        goto L5;
    }
}

void restore_default_color()
{// addr = 0x08049F3E  --  defined in 'ls.c' at line 1033
    put_indicator( &color_indicator);
    put_indicator(134627816);
}

void sighandler(int sig)
{// addr = 0x08049F5E  --  defined in 'ls.c' at line 1042
    if(interrupt_signal == 0) {
        interrupt_signal = sig;
        return;
    }
}

void stophandler(int sig)
{// addr = 0x08049F74  --  defined in 'ls.c' at line 1053
    if(interrupt_signal == 0) {
        stop_signal_count = stop_signal_count + 1;
        return;
    }
}

void process_signals()
{// addr = 0x08049F8F  --  defined in 'ls.c' at line 1068
    int stops;                             // _cfa_fffffff8
    int sig;                               // _cfa_fffffff4
    sigset_t oldset;   // _cfa_ffffff74
    struct * _v164;           // _cfa_ffffff5c
    struct * _v168;           // _cfa_ffffff58

    while((interrupt_signal | stop_signal_count) != 0) {
        restore_default_color();
         *__esp = __imp__stdout;
        fflush_unlocked();
        _v164 =  &oldset;
        _v168 =  &caught_signals;
         *__esp = 0;
        sigprocmask();
        sig = interrupt_signal;
        stops = stop_signal_count;
        if(stops == 0) {
            _v168 = 0;
             *__esp = sig;
            signal();
        } else {
            stop_signal_count = stops - 1;
            sig = 19;
        }
         *__esp = sig;
        raise();
        _v164 = 0;
        _v168 =  &oldset;
         *__esp = 2;
        sigprocmask();
    }
}

int main(int argc, char** argv)
{// addr = 0x0804A04A  --  defined in 'ls.c' at line 1107
    struct dev_ino di;   // _cfa_ffffffc8
    int j;                                 // _cfa_ffffffec
    int _v4;                               // _cfa_fffffffc
    struct dev_ino* found;   // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    int n_files;                           // _cfa_ffffffe0
    struct pending* thispend;   // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    _unknown_ _v60;                        // _cfa_ffffffc4
    intOrPtr _v68;                         // _cfa_ffffffbc
    struct sigaction act;   // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    signed char _v216;                     // _cfa_ffffff28
    signed char _v220;                     // _cfa_ffffff24
    union Dereference_symlink _v224;   // _cfa_ffffff20
    _unknown_ _v228;                       // _cfa_ffffff1c
    int* _v232;                            // _cfa_ffffff18
    union * _v236;                         // _cfa_ffffff14
    struct * _v240;           // _cfa_ffffff10
    signed int _v244;                      // _cfa_ffffff0c
    int _v252;                             // _cfa_ffffff04
    _Bool _v256;                           // _cfa_ffffff00 (outparam)
    int _v260;                             // _cfa_fffffefc (outparam)
    char* _v264;                           // _cfa_fffffef8 (outparam)
    int _v268;                             // _cfa_fffffef4 (outparam)
    char* _v272;                           // _cfa_fffffef0 (outparam)
    int _t210;                             // _t210
    int _t219;                             // _t219
    signed int _t251;                      // _t251
    _unknown_ _t256;                       // _t256
    _unknown_ _t290;                       // _t290
    signed int _t291;                      // _t291

    __esp = __esp & -16;
    _push( *((intOrPtr*)( &argc - 4)));
    _push(_t290);
    _t291 = __esp;
    _push(__edi);
    _push(__esi);
    _push( &argc);
    __esp = __esp - 252;
    _v232 =  &argc;
    program_name =  *(_v232[1]);
    _v268 = 134606192;
     *__esp = 6;
    setlocale();
    _v268 = "/usr/local/share/locale";
     *__esp = "coreutils";
    bindtextdomain();
     *__esp = "coreutils";
    textdomain();
     *__esp = 2;
    L91();
    atexit(close_stdout);
    exit_status = 0;
    print_dir_name = 1;
    pending_dirs = 0;
    _v44 = decode_switches( *_v232, _v232[1]);
    if((print_with_color & 255) != 0) {
        parse_ls_color();
    }
    if((print_with_color & 255) == 0) {
L24:
        if(dereference == 1) {
            if((immediate_dirs & 255) != 0 || indicator_style == 3 || format == 0) {
                _v224 = 2;
            } else {
                _v224 = 4;
            }
            dereference = _v224;
        }
        if((recursive & 255) != 0) {
            active_dir_set = hash_initialize(30, 0, dev_ino_hash, dev_ino_compare, dev_ino_free);
            if(active_dir_set == 0) {
                xalloc_die();
            }
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &dev_ino_obstack;
            _obstack_begin();
        }
        if(sort_type == 4 || sort_type == 2 || format == 0 || (print_scontext & 255) != 0 || (print_block_size & 255) != 0) {
            _v220 = 1;
        } else {
            _v220 = 0;
        }
        format_needs_stat = _v220 & 255;
        if((format_needs_stat & 255 ^ 0) != 0 || (recursive & 255) == 0 && (print_with_color & 255) == 0 && indicator_style == 0 && (directories_first & 255) == 0) {
            _v216 = 0;
        } else {
            _v216 = 1;
        }
        format_needs_type = _v216 & 255;
        if((dired & 255) != 0) {
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &dired_obstack;
            _obstack_begin();
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &subdired_obstack;
            _obstack_begin();
        }
        cwd_n_alloc = 100;
        cwd_file = xnmalloc(cwd_n_alloc, 120);
        cwd_n_used = 0;
        clear_files();
        thispend =  *_v232 - _v44;
        if(thispend > 0) {
            do {
                _v44 = _v44 + 1;
                _v252 = 134606192;
                _v256 = 1;
                _v264 = 0;
                _v260 = 0;
                _v268 = 0;
                 *__esp = _v232[1][_v44];
                gobble_file();
            } while(_v44 <  *_v232);
            goto L56;
        } else {
            if((immediate_dirs & 255) == 0) {
                queue_directory(134606227, 0, 1);
            } else {
                _v252 = 134606192;
                _v256 = 1;
                _v264 = 0;
                _v260 = 0;
                _v268 = 3;
                 *__esp = 134606227;
                gobble_file();
            }
L56:
            if(cwd_n_used != 0) {
                sort_files();
                if((immediate_dirs & 255 ^ 1) != 0) {
                    extract_dirs_from_files(0, 1);
                }
            }
            if(cwd_n_used == 0) {
                if(thispend <= 1 && pending_dirs != 0 && pending_dirs->next == 0) {
                    print_dir_name = 0;
                }
            } else {
                print_current_files();
                if(pending_dirs != 0) {
                     *__esp = 10;
                    putchar_unlocked();
                    dired_pos = dired_pos + 1;
                }
            }
            while(pending_dirs != 0) {
                i = pending_dirs;
                pending_dirs = pending_dirs->next;
                if(active_dir_set == 0 ||  *i != 0) {
                    print_dir( *i,  *(i + 4),  *(i + 8) & 0xff);
                    free_pending_ent(i);
                    print_dir_name = 1;
                } else {
                     *__esp =  &(act.sa_restorer);
                    dev_ino_pop();
                    __esp = __esp - 4;
                    j = hash_delete(active_dir_set,  &(act.sa_restorer));
                    if(j == 0) {
                        _v264 = "main";
                        _v268 = 1310;
                        _v272 = "ls.c";
                         *__esp = 134606229;
                        __assert_fail();
                    }
                    dev_ino_free(j);
                    free_pending_ent(i);
                }
            }
            if((print_with_color & 255) == 0) {
L84:
                if((dired & 255) != 0) {
                    dired_dump_obstack("//DIRED//",  &dired_obstack);
                    dired_dump_obstack("//SUBDIRED//",  &subdired_obstack);
                    _v268 =  *( &quoting_style_args + get_quoting_style(filename_quoting_options) * 4);
                     *__esp = "//DIRED-OPTIONS// --quoting-style=%s\n";
                    printf();
                }
                if(active_dir_set != 0) {
                    if(hash_get_n_entries(active_dir_set) != 0) {
                        _v260 = "main";
                        _v264 = 1364;
                        _v268 = "ls.c";
                         *__esp = "hash_get_n_entries (active_dir_set) == 0";
                        __assert_fail();
                    }
                    hash_free(active_dir_set);
                }
                _t210 = exit_status;
                 *__esp = _t210;
                exit();
                _push(_t291);
                if(_v268 != 1) {
                    _t210 = _v4;
                    exit_failure = _t210;
                }
                _pop(__ebp);
                return _t210;
            }
            restore_default_color();
             *__esp = __imp__stdout;
            fflush_unlocked();
            found = 0;
            while(found <= 11) {
                _t219 =  *(found * 4 +  &sig.6258);
                _v268 = _t219;
                 *__esp =  &caught_signals;
                sigismember();
                if(_t219 != 0) {
                    _v268 = 0;
                     *__esp =  *(found * 4 +  &sig.6258);
                    signal();
                }
                found =  &(found->st_ino);
            }
            found = stop_signal_count;
            while(found != 0) {
                 *__esp = 19;
                raise();
                found = found - 1;
            }
            found = interrupt_signal;
            if(found != 0) {
                 *__esp = found;
                raise();
            }
            goto L84;
        }
    }
    _t251 = is_colored(12);
    if(_t251 != 0) {
L8:
        check_symlink_color = 1;
L9:
         *__esp = 1;
        tcgetpgrp();
        if(_t251 < 0) {
L23:
            prep_non_filename_text();
            goto L24;
        } else {
             *__esp =  &caught_signals;
            sigemptyset();
            n_files = 0;
            goto L14;
            do {
            } while();
            do {
                goto L22;
            } while(n_files <= 11);
            goto L23;
L14:
            if(n_files <= 11) {
                _v264 =  &_v200;
                _v268 = 0;
                 *__esp =  *(n_files * 4 +  &sig.6258);
                sigaction();
                if(_v200 != 1) {
                    _v268 =  *(n_files * 4 +  &sig.6258);
                     *__esp =  &caught_signals;
                    sigaddset();
                }
                n_files = n_files + 1;
                goto L14;
            } else {
                _v236 =  &(act.__sigaction_handler);
                _v240 =  &caught_signals;
                _v244 = 32;
                _push(_v244 << 2);
                _push(_v240);
                _push(_v236);
                memcpy();
                __esp = __esp + 12;
                _v68 = 268435456;
                n_files = 0;
            }
L22:
        }
    }
    if((is_colored(13) ^ 1) != 0) {
L6:
        _t251 = is_colored(11) ^ 1;
        if(_t251 != 0) {
            goto L9;
        }
        _t251 = format;
        if(_t251 != 0) {
            goto L9;
        }
        goto L8;
    }
    _t251 = color_symlink_as_referent & 255;
    if(_t251 != 0) {
        goto L8;
    }
    goto L6;
}

void initialize_exit_failure(int status)
{// addr = 0x0804A844  --  defined in 'system.h' at line 131
    if(status != 1) {
        exit_failure = status;
        return;
    }
}

int decode_switches(int argc, char** argv)
{// addr = 0x0804A857  --  defined in 'ls.c' at line 1376
    long unsigned int tmp_ulong;           // _cfa_ffffff9c
    long unsigned int tmp_ulong;           // _cfa_ffffff98
    struct ignore_pattern* hide;   // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd8
    union strtol_error e;   // _cfa_ffffffdc
    const char* locale_format;   // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    char* p1;                              // _cfa_ffffffec
    char* p0;                              // _cfa_ffffffe8
    char* style;                           // _cfa_ffffffe4
    const char* p;   // _cfa_ffffffe0
    int c;                                 // _cfa_ffffffd0
    const char* p;   // _cfa_ffffffcc
    const char* p;   // _cfa_ffffffc8
    const char* ls_block_size;   // _cfa_ffffffc4
    int i;                                 // _cfa_ffffffc0
    const char* q_style;   // _cfa_ffffffbc
    _Bool sort_type_specified;             // _cfa_ffffffbb
    char* time_style_option;               // _cfa_ffffffb4
    long unsigned int tmp_ulong;           // _cfa_ffffffb0
    _unknown_ _v86;                        // _cfa_ffffffaa
    struct winsize ws;   // _cfa_ffffffa8
    long unsigned int tmp_ulong;           // _cfa_ffffffa4
    int oi;                                // _cfa_ffffffa0
    intOrPtr _v108;                        // _cfa_ffffff94
    int _v112;                             // _cfa_ffffff90
    unsigned int _v116;                    // _cfa_ffffff8c
    const char* _v136;   // _cfa_ffffff78
    intOrPtr _v140;                        // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    _unknown_ _v152;                       // _cfa_ffffff68 (outparam)
    int* _v156;                            // _cfa_ffffff64 (outparam)
    struct option[41]* _v160;   // _cfa_ffffff60 (outparam)
    char* _v164;                           // _cfa_ffffff5c (outparam)
    const char* _v168;   // _cfa_ffffff58 (outparam)
    _unknown_ __ebx;                       // r1
    const char* _t165;   // _t165
    const char* _t167;   // _t167
    const char* _t168;   // _t168
    int _t171;                             // _t171
    char* _t186;                           // _t186
    char* _t187;                           // _t187
    const char* _t201;   // _t201
    char* _t207;                           // _t207
    char* _t209;                           // _t209
    char* _t214;                           // _t214
    char* _t242;                           // _t242
    char* _t251;                           // _t251

    time_style_option = 0;
    sort_type_specified = 0;
    qmark_funny_chars = 0;
    _t165 = ls_mode;
    _v136 = _t165;
    if(_v136 == 2) {
        format = 2;
        set_quoting_style(0, 4);
    } else {
        if(_v136 == 3) {
            format = 0;
            set_quoting_style(0, 4);
        } else {
            if(_v136 == 1) {
                 *__esp = 1;
                isatty();
                if(_t165 == 0) {
                    format = 1;
                    qmark_funny_chars = 0;
                } else {
                    format = 2;
                    qmark_funny_chars = 1;
                }
            } else {
                abort();
            }
        }
    }
    time_type = 0;
    sort_type = 0;
    sort_reverse = 0;
    numeric_ids = 0;
    print_block_size = 0;
    indicator_style = 0;
    print_inode = 0;
    dereference = 1;
    recursive = 0;
    immediate_dirs = 0;
    ignore_mode = 0;
    ignore_patterns = 0;
    hide_patterns = 0;
    print_scontext = 0;
     *__esp = "QUOTING_STYLE";
    getenv();
    q_style = _t165;
    if(q_style != 0) {
        i = argmatch(q_style,  &quoting_style_args,  &quoting_style_vals, 4);
        if(i < 0) {
            _t165 = quotearg(q_style);
             *__esp = "ignoring invalid value of environment variable QUOTING_STYLE: %s";
            gettext();
            _v160 = _t165;
            _v164 = _t165;
            _v168 = 0;
             *__esp = 0;
            error();
        } else {
            _t165 =  *( &quoting_style_vals + i * 4);
            set_quoting_style(0, _t165);
        }
    }
     *__esp = "LS_BLOCK_SIZE";
    getenv();
    ls_block_size = _t165;
    _t167 = human_options(ls_block_size,  &human_output_opts,  &output_block_size);
    if(ls_block_size != 0) {
L16:
        _t167 = output_block_size;
        file_output_block_size = _t167;
         *134627796 =  *134628524;
L17:
        line_length = 80;
         *__esp = "COLUMNS";
        getenv();
        p = _t167;
        if(p != 0 && ( *p & 255) != 0) {
            if(xstrtoul(p, 0, 0,  &tmp_ulong, 0) != 0 || tmp_ulong == 0) {
                _t251 = quotearg(p);
                 *__esp = "ignoring invalid width in environment variable COLUMNS: %s";
                gettext();
                _v160 = _t251;
                _v164 = _t251;
                _v168 = 0;
                 *__esp = 0;
                error();
            } else {
                line_length = tmp_ulong;
            }
        }
        _t168 =  &(ws.ws_row);
        _v164 = _t168;
        _v168 = 21523;
         *__esp = 1;
        ioctl();
        if(_t168 != -1) {
            _t168 = ws.ws_col & 65535;
            if(_t168 != 0) {
                _t168 = ws.ws_col & 0xffff;
                line_length = _t168;
            }
        }
         *__esp = "TABSIZE";
        getenv();
        p = _t168;
        tabsize = 8;
        if(p != 0) {
            if(xstrtoul(p, 0, 0,  &tmp_ulong, 0) != 0) {
                _t242 = quotearg(p);
                 *__esp = "ignoring invalid tab size in environment variable TABSIZE: %s";
                gettext();
                _v160 = _t242;
                _v164 = _t242;
                _v168 = 0;
                 *__esp = 0;
                error();
            } else {
                tabsize = tmp_ulong;
            }
        }
        while(1) {
            oi = -1;
            _v156 =  &oi;
            _v160 =  &long_options;
            _v164 = "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1";
            _v168 = argv;
            _t171 = argc;
             *__esp = _t171;
            getopt_long();
            c = _t171;
            if(c == -1) {
                break;
            }
            _v140 = c + 131;
            if(_v140 > 274) {
                usage(2);
                continue;
            }
            goto __eax;
        }
        if(line_length <= 2) {
            _v116 = 1;
        } else {
            _v144 = line_length;
            _v116 = _v144 * -1431655765 >> 32 >> 1;
        }
        max_idx = _v116;
        filename_quoting_options = clone_quoting_options(0);
        if(get_quoting_style(filename_quoting_options) == 4) {
            set_char_quoting(filename_quoting_options, 32, 1);
        }
        if(indicator_style <= 1) {
L43:
            dirname_quoting_options = clone_quoting_options(0);
            set_char_quoting(dirname_quoting_options, 58, 1);
            if((dired & 255) != 0 && format != 0) {
                dired = 0;
            }
            if(time_type == 1 || time_type == 2) {
                if((sort_type_specified & 255 ^ 1) != 0 && format != 0) {
                    sort_type = 4;
                }
            }
            if(format != 0) {
L79:
                _v112 = __imp__optind;
                goto L80;
            } else {
                _t186 = time_style_option;
                style = _t186;
                if(style == 0) {
                     *__esp = "TIME_STYLE";
                    getenv();
                    style = _t186;
                    if(style == 0) {
                        style = "locale";
                    }
                }
                while(1) {
                    _v164 = 6;
                    _v168 = "posix-";
                    _t187 = style;
                     *__esp = _t187;
                    strncmp();
                    if(_t187 != 0) {
                        break;
                    }
                    if((hard_locale(2) ^ 1) == 0) {
                        style =  &(style[6]);
                        continue;
                    }
                    _v112 = __imp__optind;
L80:
                    return _v112;
                }
                if(( *style & 255) != 43) {
                    _v108 =  *((intOrPtr*)( &time_style_types + __xargmatch_internal("time style", style,  &time_style_args,  &time_style_types, 4, argmatch_die) * 4));
                    if(_v108 == 1) {
L72:
                         *134627972 = "%Y-%m-%d %H:%M";
                        long_time_format =  *134627972;
                        goto L79;
                    }
                    if(_v108 < 1) {
                         *134627972 = "%Y-%m-%d %H:%M:%S.%N %z";
                        long_time_format =  *134627972;
                        goto L79;
                    }
                    if(_v108 == 2) {
                        long_time_format = "%Y-%m-%d ";
                         *134627972 = "%m-%d %H:%M";
                        goto L79;
                    }
                    if(_v108 == 3) {
                        if(hard_locale(2) == 0) {
                            goto L79;
                        }
                        i = 0;
                        while(i <= 1) {
                            _t201 = ( &long_time_format)[i];
                            _v164 = 2;
                            _v168 = _t201;
                             *__esp = 0;
                            dcgettext();
                            locale_format = _t201;
                            if(( &long_time_format)[i] == locale_format) {
                                goto L72;
                            }
                            ( &long_time_format)[i] = locale_format;
                            i = i + 1;
                        }
                        goto L79;
                    }
                    goto L79;
                }
                p0 =  &(style[1]);
                _v168 = 10;
                _t207 = p0;
                 *__esp = _t207;
                strchr();
                p1 = _t207;
                if(p1 != 0) {
                    _t209 =  &(p1[1]);
                    _v168 = 10;
                     *__esp = _t209;
                    strchr();
                    if(_t209 != 0) {
                        _t214 = quote(p0);
                         *__esp = "invalid time style format %s";
                        gettext();
                        _v160 = _t214;
                        _v164 = _t214;
                        _v168 = 0;
                         *__esp = 2;
                        error();
                    }
                     *p1 = 0;
                    p1 =  &(p1[1]);
                } else {
                    p1 = p0;
                }
                long_time_format = p0;
                 *134627972 = p1;
                goto L79;
            }
        } else {
            p =  &(("*=>|")[indicator_style - 2]);
            while(( *p & 255) != 0) {
                set_char_quoting(filename_quoting_options,  *p & 255, 1);
                p =  &(p[1]);
            }
            goto L43;
        }
    }
     *__esp = "BLOCK_SIZE";
    getenv();
    if(_t167 == 0) {
        goto L17;
    }
    goto L16;
}

_Bool get_funky_string(char** dest, const char** src, _Bool equals_end, size_t* output_count)
{// addr = 0x0804B7D9  --  defined in 'ls.c' at line 1950
    char* q;                               // _cfa_fffffff8
    const char* p;   // _cfa_fffffff4
    union  state;                          // _cfa_fffffff0
    size_t count;       // _cfa_ffffffec
    char num;                              // _cfa_ffffffeb
    char _v40;                             // _cfa_ffffffd8

    _v40 = equals_end;
    p =  *src;
    q =  *dest;
    count = 0;
    num = 0;
    state = 0;
    while(state <= 4) {
        if(state <= 4) {
            goto __eax;
        }
        abort();
    }
     *dest = q;
     *src = p;
     *output_count = count;
    return state != 6;
}

void parse_ls_color()
{// addr = 0x0804BAE2  --  defined in 'ls.c' at line 2144
    struct color_ext_type* e2;   // _cfa_fffffff4
    struct color_ext_type* e;   // _cfa_fffffff0
    struct color_ext_type* ext;   // _cfa_ffffffec
    int ind_no;                            // _cfa_ffffffe8
    int state;                             // _cfa_ffffffe4
    const char* p;   // _cfa_ffffffe0
    char* buf;                             // _cfa_ffffffdc
    char _v38;                             // _cfa_ffffffda
    char[2] label;                         // _cfa_ffffffd9
    const char* _v44;   // _cfa_ffffffd4
    const char* _v48;   // _cfa_ffffffd0
    const char* _v52;   // _cfa_ffffffcc
    const char* _v56;   // _cfa_ffffffc8
    const char* _v60;   // _cfa_ffffffc4
    const char* _v64;   // _cfa_ffffffc0 (outparam)
    const char* _v68;   // _cfa_ffffffbc (outparam)
    int _v72;                              // _cfa_ffffffb8 (outparam)
    const char* _t128;   // _t128
    struct color_ext_type* _t131;   // _t131
    const char* _t138;   // _t138
    const char* _t172;   // _t172
    const char* _t177;   // _t177
    const char* _t178;   // _t178

     *__esp = "LS_COLORS";
    getenv();
    p = __eax;
    if(p == 0 || ( *p & 255) == 0) {
L50:
        return;
    } else {
        ext = 0;
        _v68 = 3;
        _v72 = "??";
         *__esp =  &label;
        memcpy();
        color_buf = xstrdup(p);
        buf = color_buf;
        state = 1;
        while(state > 0) {
            _t128 = state;
            _v60 = _t128;
            if(_v60 == 2) {
                _t128 =  *p & 255;
                if(_t128 == 0) {
                    state = -1;
                } else {
                    _t138 = p;
                    _v38 =  *_t138 & 255;
                    _t128 =  &(_t138[1]);
                    p = _t128;
                    state = 3;
                }
                continue;
            }
            if(_v60 > 2) {
                if(_v60 == 3) {
                    state = -1;
                    _t177 = p;
                    _t128 =  &(_t177[1]);
                    p = _t128;
                    if(( *_t177 & 255) == 61) {
                        continue;
                    }
                    ind_no = 0;
                    while(1) {
                        _t128 =  *( &indicator_name + ind_no * 4);
                        if(_t128 == 0) {
                            break;
                        }
                        _v72 =  *( &indicator_name + ind_no * 4);
                         *__esp =  &label;
                        strcmp();
                        if( &label != 0) {
                            ind_no = ind_no + 1;
                            continue;
                        }
                         *(134627812 + ind_no * 8) = buf;
                        if(get_funky_string( &buf,  &p, 0,  &color_indicator + (ind_no << 3)) == 0) {
                            _v48 = -1;
                        } else {
                            _v48 = 1;
                        }
                        _t128 = _v48;
                        state = _t128;
                        break;
                    }
                    if(state == -1) {
                        _t128 = quotearg( &label);
                         *__esp = "unrecognized prefix: %s";
                        gettext();
                        _v64 = _t128;
                        _v68 = _t128;
                        _v72 = 0;
                         *__esp = 0;
                        error();
                    }
                } else {
                    if(_v60 == 4) {
                        _t178 = p;
                        _t128 =  &(_t178[1]);
                        p = _t128;
                        if(( *_t178 & 255) == 61) {
                            state = -1;
                        } else {
                            ext->seq.string = buf;
                            if(get_funky_string( &buf,  &p, 0,  &(ext->seq)) == 0) {
                                _v44 = -1;
                            } else {
                                _v44 = 1;
                            }
                            _t128 = _v44;
                            state = _t128;
                        }
                    }
                }
                continue;
            }
            if(_v60 == 1) {
                _t128 =  *p & 255;
                _v56 = _t128;
                if(_v56 == 42) {
                    ext = xmalloc(20);
                    ext->next = color_ext_list;
                    color_ext_list = ext;
                    p =  &(p[1]);
                    ext->ext.string = buf;
                    if(get_funky_string( &buf,  &p, 1, ext) == 0) {
                        _v52 = -1;
                    } else {
                        _v52 = 4;
                    }
                    _t128 = _v52;
                    state = _t128;
                } else {
                    if(_v56 == 58) {
                        _t128 =  &(p[1]);
                        p = _t128;
                    } else {
                        if(_v56 == 0) {
                            state = 0;
                        } else {
                            _t172 = p;
                            label =  *_t172 & 255;
                            _t128 =  &(_t172[1]);
                            p = _t128;
                            state = 2;
                        }
                    }
                }
            }
        }
        if(state >= 0) {
L47:
            if( *134627856 != 6) {
                goto L50;
            }
            _t131 =  *134627860;
            _v68 = 6;
            _v72 = "target";
             *__esp = _t131;
            strncmp();
            if(_t131 != 0) {
                goto L50;
            }
            color_symlink_as_referent = 1;
            return;
        }
         *__esp = "unparsable value for LS_COLORS environment variable";
        gettext();
        _v68 = _t128;
        _v72 = 0;
         *__esp = 0;
        error();
         *__esp = color_buf;
        free();
        e = color_ext_list;
        while(e != 0) {
            e2 = e;
            e = e->next;
             *__esp = e2;
            free();
        }
        print_with_color = 0;
        goto L47;
    }
}

void set_exit_status(_Bool serious)
{// addr = 0x0804BE91  --  defined in 'ls.c' at line 2274
    char _v8;                              // _cfa_fffffff8

    _v8 = serious;
    if(_v8 != 0) {
        exit_status = 2;
        return;
    }
    if(exit_status == 0) {
        exit_status = 1;
        return;
    }
}

void file_failure(_Bool serious, const char* message, const char* file)
{// addr = 0x0804BEC4  --  defined in 'ls.c' at line 2287
    signed char _v12;                      // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    const char* _v20;   // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _t11;                        // _t11

    _v12 = serious;
    _t11 = quotearg_colon(file);
    __errno_location();
    _v16 = _t11;
    _v20 = message;
    _v24 =  *_t11;
     *__esp = 0;
    error();
    set_exit_status(_v12 & 255);
}

void queue_directory(const char* name, const char* realname, _Bool command_line_arg)
{// addr = 0x0804BF12  --  defined in 'ls.c' at line 2304
    struct pending* new;   // _cfa_fffffff8
    signed char _v24;                      // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0

    _v24 = command_line_arg;
    new = xmalloc(16);
    if(realname == 0) {
        _v32 = 0;
    } else {
        _v32 = xstrdup(realname);
    }
    new->realname = _v32;
    if(name == 0) {
        _v28 = 0;
    } else {
        _v28 = xstrdup(name);
    }
    new->name = _v28;
    new->command_line_arg = _v24 & 255;
    new->next = pending_dirs;
    pending_dirs = new;
}

void print_dir(const char* name, const char* realname, _Bool command_line_arg)
{// addr = 0x0804BF98  --  defined in 'ls.c' at line 2320
    char[651] buf;                         // _cfa_fffffd30
    const char* p;   // _cfa_fffffff0
    int __len;                             // _cfa_ffffffec
    struct obstack* __o;   // _cfa_ffffffe8
    int __len;                             // _cfa_ffffffe4
    struct obstack* __o;   // _cfa_ffffffe0
    union filetype type;   // _cfa_ffffffdc
    int __len;                             // _cfa_ffffffd8
    struct obstack* __o;   // _cfa_ffffffd4
    struct dev_ino* di;   // _cfa_ffffffd0
    int fd;                                // _cfa_ffffffcc
    size_t* _v56;       // _cfa_ffffffc8
    uintmax_t total_blocks;   // _cfa_ffffffc4
    struct dirent* next;   // _cfa_ffffffc0
    DIR* dirp;             // _cfa_ffffffbc
    _unknown_ _v628;                       // _cfa_fffffd8c
    _unknown_ _v632;                       // _cfa_fffffd88
    _unknown_ _v716;                       // _cfa_fffffd34
    struct stat dir_stat;   // _cfa_fffffd30
    signed int _v736;                      // _cfa_fffffd20
    const char* _v740;   // _cfa_fffffd1c
    const struct quoting_options* _v744;   // _cfa_fffffd18
    signed int _v748;                      // _cfa_fffffd14
    char _v749;                            // _cfa_fffffd13
    intOrPtr _v768;                        // _cfa_fffffd00
    long long unsigned int _v772;          // _cfa_fffffcfc
    const char* _v776;   // _cfa_fffffcf8
    size_t* _v780;      // _cfa_fffffcf4
    int _v784;                             // _cfa_fffffcf0 (outparam)
    long long unsigned int* _v788;         // _cfa_fffffcec (outparam)
    int _v792;                             // _cfa_fffffce8 (outparam)
    _unknown_ __ebx;                       // r1
    signed char _t184;                     // _t184
    const char* _t185;   // _t185
    signed int _t186;                      // _t186
    struct dirent* _t187;   // _t187
    const char* _t188;   // _t188
    const char* _t189;   // _t189
    const char* _t196;   // _t196
    const char* _t199;   // _t199
    const char* _t210;   // _t210
    const char* _t261;   // _t261
    struct dirent* _t268;   // _t268
    int _t273;                             // _t273
    const char* _t277;   // _t277
    long long unsigned int* _t294;         // _t294
    struct dev_ino* _t313;   // _t313
    struct dev_ino* _t314;   // _t314

    _t184 = command_line_arg;
    _v736 = _t184;
    total_blocks = 0;
    _v56 = 0;
    __errno_location();
     *_t184 = 0;
    _t185 = name;
     *__esp = _t185;
    opendir();
    dirp = _t185;
    if(dirp != 0) {
        _t186 = active_dir_set;
        if(_t186 == 0) {
L13:
            clear_files();
            while(1) {
L14:
                __errno_location();
                 *_t186 = 0;
                _t187 = dirp;
                 *__esp = _t187;
                readdir64();
                next = _t187;
                if(next == 0) {
                    break;
                }
                _t186 = file_ignored( &(next->d_name)) ^ 1;
                if(_t186 == 0) {
                    continue;
                }
                type = 0;
                _v748 = next->d_type & 0xff;
                if(_v748 > 14) {
                    _t268 = next;
                    _v776 = name;
                    _v780 = 0;
                    _v788 = _t268->d_ino;
                    _v784 = _t268->d_ino;
                    _v792 = type;
                     *__esp =  &(next->d_name);
                    _t186 = gobble_file();
                    total_blocks = total_blocks + _t186;
                    asm("adc [ebp-0x34], edx");
                    continue;
                }
                goto __eax;
            }
            __errno_location();
            _t188 =  *_t187;
            if(_t188 == 0) {
L21:
                _t189 = dirp;
                 *__esp = _t189;
                closedir();
                if(_t189 != 0) {
                     *__esp = "closing directory %s";
                    gettext();
                    file_failure(_v736 & 255, _t189, name);
                }
                sort_files();
                if((recursive & 255) != 0) {
                    extract_dirs_from_files(name, _v736 & 255);
                }
                if((print_dir_name & 0xff | recursive & 0xff) != 0) {
                    if((first & 255 ^ 1) != 0) {
                         *__esp = 10;
                        putchar_unlocked();
                        dired_pos = dired_pos + 1;
                    }
                    first = 0;
                    if((dired & 255) != 0) {
                        _v784 = __imp__stdout;
                        _v788 = 2;
                        _v792 = 1;
                         *__esp = "  ";
                        fwrite_unlocked();
                        dired_pos = 2 + dired_pos;
                    }
                    if((dired & 255) != 0) {
                        __o =  &subdired_obstack;
                        __len = 4;
                        if( &(__o->next_free[__len]) > __o->chunk_limit) {
                            _v792 = __len;
                             *__esp = __o;
                            _obstack_newchunk();
                        }
                        _v788 = __len;
                        _v792 =  &dired_pos;
                         *__esp = __o->next_free;
                        memcpy();
                        __o->next_free =  &(__o->next_free[__len]);
                    }
                    _v744 = dirname_quoting_options;
                    if(realname == 0) {
                        _v740 = name;
                    } else {
                        _v740 = realname;
                    }
                    dired_pos = quote_name(__imp__stdout, _v740, _v744, 0) + dired_pos;
                    if((dired & 255) != 0) {
                        __o =  &subdired_obstack;
                        __len = 4;
                        if( &(__o->next_free[__len]) > __o->chunk_limit) {
                            _v792 = __len;
                             *__esp = __o;
                            _obstack_newchunk();
                        }
                        _v788 = __len;
                        _v792 =  &dired_pos;
                         *__esp = __o->next_free;
                        memcpy();
                        __o->next_free =  &(__o->next_free[__len]);
                    }
                    _v784 = __imp__stdout;
                    _v788 = 2;
                    _v792 = 1;
                     *__esp = ":\n";
                    fwrite_unlocked();
                    dired_pos = 2 + dired_pos;
                }
                if(format == 0 || (print_block_size & 255) != 0) {
                    _t196 = dired & 255;
                    if(_t196 != 0) {
                        _v784 = __imp__stdout;
                        _v788 = 2;
                        _v792 = 1;
                         *__esp = "  ";
                        fwrite_unlocked();
                        _t196 = 2 + dired_pos;
                        dired_pos = _t196;
                    }
                     *__esp = "total";
                    gettext();
                    p = _t196;
                    _v792 = __imp__stdout;
                     *__esp = p;
                    fputs_unlocked();
                    _t199 = p;
                     *__esp = _t199;
                    strlen();
                    dired_pos = _t199 + dired_pos;
                     *__esp = 32;
                    putchar_unlocked();
                    dired_pos = dired_pos + 1;
                    _v772 = output_block_size;
                    _v768 =  *134628524;
                    _v780 = 512;
                    _v776 = 0;
                    _v784 = human_output_opts;
                    _v788 =  &(dir_stat.st_dev);
                     *__esp = total_blocks;
                    _v792 = _v56;
                    p = human_readable();
                    _v792 = __imp__stdout;
                     *__esp = p;
                    fputs_unlocked();
                    _t210 = p;
                     *__esp = _t210;
                    strlen();
                    dired_pos = _t210 + dired_pos;
                     *__esp = 10;
                    putchar_unlocked();
                    dired_pos = dired_pos + 1;
                }
                if(cwd_n_used == 0) {
                    return;
                } else {
                    print_current_files();
                    return;
                }
            }
             *__esp = "reading directory %s";
            gettext();
            _t261 = name;
            file_failure(_v736 & 255, _t188, _t261);
            __errno_location();
            _t186 =  *_t261;
            if(_t186 == 75) {
                goto L14;
            }
            goto L21;
        }
        _t273 = dirp;
         *__esp = _t273;
        dirfd();
        fd = _t273;
        if(fd < 0) {
            _t277 = stat64(name,  &(dir_stat.st_dev)) >> 31;
            _v749 = _t277;
        } else {
            _t277 = fstat64(fd,  &(dir_stat.st_dev)) >> 31;
            _v749 = _t277;
        }
        if(_v749 == 0) {
            _v788 = dir_stat.st_ino;
            _v784 = dir_stat.st_ino;
             *__esp = dir_stat.st_dev;
            _v792 = dir_stat.st_dev;
            if(visit_dir() == 0) {
                __o =  &dev_ino_obstack;
                __len = 16;
                if(__o->chunk_limit - __o->next_free < __len) {
                    _v792 = __len;
                     *__esp = __o;
                    _obstack_newchunk();
                }
                __o->next_free =  &(__o->next_free[__len]);
                di = dev_ino_obstack.next_free - 16;
                _t313 = di;
                _t313->st_dev = dir_stat.st_dev;
                _t313->st_dev = dir_stat.st_dev;
                _t186 = dir_stat.st_ino;
                _t314 = di;
                _t314->st_ino = _t186;
                _t314->st_ino = dir_stat.st_ino;
                goto L13;
            }
            _t294 = quotearg_colon(name);
             *__esp = "%s: not listing already-listed directory";
            gettext();
            _v784 = _t294;
            _v788 = _t294;
            _v792 = 0;
             *__esp = 0;
            error();
             *__esp = dirp;
            closedir();
            return;
        } else {
             *__esp = "cannot determine device and inode of %s";
            gettext();
            file_failure(_v736 & 255, _t277, name);
             *__esp = dirp;
            closedir();
            return;
        }
    }
     *__esp = "cannot open directory %s";
    gettext();
    file_failure(_v736 & 255, _t185, name);
}

void add_ignore_pattern(const char* pattern)
{// addr = 0x0804C66F  --  defined in 'ls.c' at line 2461
    struct ignore_pattern* ignore;   // _cfa_fffffff8

    ignore = xmalloc(8);
    ignore->pattern = pattern;
    ignore->next = ignore_patterns;
    ignore_patterns = ignore;
}

_Bool patterns_match(const struct ignore_pattern* patterns, const char* file)
{// addr = 0x0804C6A2  --  defined in 'ls.c' at line 2475
    const struct ignore_pattern* p;   // _cfa_fffffff8
    signed int _v21;                       // _cfa_ffffffeb
    intOrPtr _v36;                         // _cfa_ffffffdc
    const char* _v40;   // _cfa_ffffffd8
    const char* _t16;   // _t16

    p = patterns;
    while(p != 0) {
        _v36 = 4;
        _t16 = file;
        _v40 = _t16;
         *__esp = p->pattern;
        fnmatch();
        if(_t16 != 0) {
            p = p->next;
            continue;
        } else {
            _v21 = 1;
        }
L6:
        return _v21 & 255;
    }
    _v21 = 0;
    goto L6;
}

_Bool file_ignored(const char* name)
{// addr = 0x0804C6EF  --  defined in 'ls.c' at line 2487
    signed char _v8;                       // _cfa_fffffff8
    signed char _v12;                      // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(ignore_mode == 2 || ( *name & 255) != 46) {
L7:
        if(ignore_mode != 0 || patterns_match(hide_patterns, name) == 0) {
            if(patterns_match(ignore_patterns, name) == 0) {
                _v12 = 0;
                goto L12;
            }
        }
        goto L10;
    } else {
        if(ignore_mode == 0) {
L10:
            _v12 = 1;
L12:
            return _v12 & 255;
        }
        if((name[1] & 255) != 46) {
            _v8 = 1;
        } else {
            _v8 = 2;
        }
        if(( *(name + _v8) & 255) == 0) {
            goto L10;
        } else {
            goto L7;
        }
    }
}

uintmax_t unsigned_file_size(off_t size)
{// addr = 0x0804C78B  --  defined in 'ls.c' at line 2502
    intOrPtr _v8;                          // _cfa_fffffff8
    long long unsigned int _v12;           // _cfa_fffffff4

    _v12 = size;
    _v8 = _a8;
    return _v12;
}

void clear_files()
{// addr = 0x0804C7A5  --  defined in 'ls.c' at line 2512
    struct fileinfo* f;   // _cfa_fffffff8
    size_t i;           // _cfa_fffffff4

    i = 0;
    while(i < cwd_n_used) {
        f = sorted_file[i];
         *__esp = f->name;
        free();
         *__esp = f->linkname;
        free();
        if(f->scontext !=  &UNKNOWN_SECURITY_CONTEXT) {
            freecon(f->scontext);
        }
        i = i + 1;
    }
    cwd_n_used = 0;
    any_has_acl = 0;
    inode_number_width = 0;
    block_size_width = 0;
    nlink_width = 0;
    owner_width = 0;
    group_width = 0;
    author_width = 0;
    scontext_width = 0;
    major_device_number_width = 0;
    minor_device_number_width = 0;
    file_size_width = 0;
}

void freecon(char* con)
{// addr = 0x0804C883  --  defined in 'selinux.h' at line 21

}

uintmax_t gobble_file(const char* name, union filetype type, ino_t inode, _Bool command_line_arg, const char* dirname)
{// addr = 0x0804C888  --  defined in 'ls.c' at line 2545
    char[651] buf;                         // _cfa_fffffcd0
    char[651] buf;                         // _cfa_fffffcd0
    _unknown_ _v8;                         // _cfa_fffffff8
    int len;                               // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    uintmax_t size;   // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    int b_len;                             // _cfa_ffffffdc
    int len;                               // _cfa_ffffffd8
    int len;                               // _cfa_ffffffd4
    int len;                               // _cfa_ffffffd0
    int len;                               // _cfa_ffffffcc
    int len;                               // _cfa_ffffffc8
    char* linkname;                        // _cfa_ffffffc4
    int n;                                 // _cfa_ffffffc0
    int attr_len;                          // _cfa_ffffffbc
    _Bool have_acl;                        // _cfa_ffffffbb
    _Bool need_lstat;                      // _cfa_ffffffba
    int err;                               // _cfa_ffffffb4
    _Bool do_deref;                        // _cfa_ffffffb3
    char* absolute_name;                   // _cfa_ffffffac
    struct fileinfo* f;   // _cfa_ffffffa8
    int _v96;                              // _cfa_ffffffa0
    uintmax_t blocks;   // _cfa_ffffff9c
    char[20] b;                            // _cfa_ffffff87
    char[20] buf;                          // _cfa_ffffff72
    char[20] buf;                          // _cfa_ffffff5d
    _unknown_ _v800;                       // _cfa_fffffce0
    struct stat linkstats;   // _cfa_fffffcd0
    signed int _v832;                      // _cfa_fffffcc0
    signed int _v836;                      // _cfa_fffffcbc
    signed int _v840;                      // _cfa_fffffcb8
    int _v844;                             // _cfa_fffffcb4
    int _v848;                             // _cfa_fffffcb0
    long long unsigned int _v852;          // _cfa_fffffcac
    signed char _v853;                     // _cfa_fffffcab
    union Dereference_symlink _v860;   // _cfa_fffffca4
    char* _v864;                           // _cfa_fffffca0
    char _v876;                            // _cfa_fffffc94
    intOrPtr _v880;                        // _cfa_fffffc90
    long long unsigned int _v884;          // _cfa_fffffc8c
    int _v888;                             // _cfa_fffffc88
    _Bool _v892;                           // _cfa_fffffc84
    int _v896;                             // _cfa_fffffc80
    char[20]* _v900;                       // _cfa_fffffc7c (outparam)
    int _v904;                             // _cfa_fffffc78 (outparam)
    int _t314;                             // _t314
    struct fileinfo* _t324;   // _t324
    char* _t325;                           // _t325
    struct fileinfo* _t344;   // _t344
    struct fileinfo* _t364;   // _t364
    int _t366;                             // _t366
    int _t372;                             // _t372
    struct fileinfo* _t377;   // _t377
    int _t378;                             // _t378
    int _t380;                             // _t380
    struct fileinfo* _t382;   // _t382
    int _t383;                             // _t383
    int _t385;                             // _t385
    struct fileinfo* _t397;   // _t397
    int _t409;                             // _t409
    int _t465;                             // _t465
    int _t479;                             // _t479
    const char* _t505;   // _t505
    int _t506;                             // _t506
    struct fileinfo* _t552;   // _t552
    int _t581;                             // _t581

    _push(__ebx);
    __esp = __esp - 900;
    _v836 = inode;
    _v832 = command_line_arg;
    _v840 = dirname;
    blocks = 0;
    _v96 = 0;
    if(_v840 != 0) {
        if((_v836 | _v832) != 0) {
            _v896 = "gobble_file";
            _v900 = 2551;
            _v904 = "ls.c";
             *__esp = "! command_line_arg || inode == NOT_AN_INODE_NUMBER";
            __assert_fail();
        }
    }
    if(cwd_n_used == cwd_n_alloc) {
        cwd_file = xnrealloc(cwd_file, cwd_n_alloc, 240);
        cwd_n_alloc = cwd_n_alloc + cwd_n_alloc;
    }
    f = cwd_file + (cwd_n_used * 8 << 4) - cwd_n_used * 8;
    _v900 = 120;
    _v904 = 0;
     *__esp = f;
    memset();
    _t552 = f;
    _t552->stat.st_ino = _v836;
    _t552->stat.st_ino = _v832;
    f->filetype.st_dev = type;
    if(_v840 != 0 || (format_needs_stat & 255) != 0 || type == 3 && (print_with_color & 255) != 0) {
L27:
        if(( *name & 255) == 47) {
L29:
            absolute_name = name;
L31:
            _v860 = dereference;
            if(_v860 < 3) {
L41:
                _t314 = lstat64(absolute_name,  &(f->stat));
                err = _t314;
                do_deref = 0;
L42:
                if(err == 0) {
                    f->stat_ok.st_dev = 1;
                    if(format == 0 || (print_scontext & 255) != 0) {
                        have_acl = 0;
                        if(do_deref == 0) {
                            _v844 = lgetfilecon(absolute_name,  &(f->scontext));
                        } else {
                            _v844 = getfilecon(absolute_name,  &(f->scontext));
                        }
                        attr_len = _v844;
                        err = attr_len >> 31;
                        if(err != 0) {
                            _t324 = f;
                            _t324->scontext =  &UNKNOWN_SECURITY_CONTEXT;
                            __errno_location();
                            _t325 = _t324->name;
                            if(_t325 == 95) {
L55:
                                err = 0;
                                goto L56;
                            }
                            __errno_location();
                            if( *_t325 != 61) {
                                goto L56;
                            }
                            goto L55;
                        } else {
                            _t479 = f->scontext.st_dev;
                            _v904 = _t479;
                             *__esp = "unlabeled";
                            strcmp();
                            have_acl = _t479 != 0;
L56:
                            if(err == 0 && (have_acl & 255 ^ 1) != 0 && format == 0) {
                                n = file_has_acl(absolute_name,  &(f->stat));
                                err = n >> 31;
                                have_acl = n > 0;
                            }
                            f->have_acl.st_dev = have_acl & 255;
                            any_has_acl = (have_acl & 255 | any_has_acl & 0xff) != 0;
                            if(err != 0) {
                                _t465 = quotearg_colon(absolute_name);
                                __errno_location();
                                _v896 = _t465;
                                _v900 = "%s";
                                _v904 =  *_t465;
                                 *__esp = 0;
                                error();
                            }
                            goto L62;
                        }
                    } else {
L62:
                        if((f->stat.st_mode & 61440) == 40960 && (format == 0 || (check_symlink_color & 255) != 0)) {
                            get_link_name(absolute_name, f, _v840 & 255);
                            linkname = make_link_name(absolute_name, f->linkname.st_dev);
                            if(linkname != 0 && (indicator_style > 1 || (check_symlink_color & 255) != 0)) {
                                if(stat64(linkname,  &(linkstats.st_dev)) == 0) {
                                    f->linkok.st_dev = 1;
                                    if((_v840 & 255 ^ 1) != 0 || format == 0 || (linkstats.st_mode & 61440) != 16384) {
                                        f->linkmode.st_dev = linkstats.st_mode;
                                    }
                                }
                            }
                             *__esp = linkname;
                            free();
                        }
                        if((f->stat.st_mode & 61440) == 40960 && (check_symlink_color & 255 ^ 1) != 0) {
                            f->linkok.st_dev = 1;
                        }
                        if((f->stat.st_mode & 61440) != 40960) {
                            if((f->stat.st_mode & 61440) != 16384) {
                                f->filetype.st_dev = 5;
                            } else {
                                if(((immediate_dirs & 255 ^ 1) & 255 & _v840 & 255) == 0) {
                                    f->filetype.st_dev = 3;
                                } else {
                                    f->filetype.st_dev = 9;
                                }
                            }
                        } else {
                            f->filetype.st_dev = 6;
                        }
                        _t344 = f;
                        blocks = _t344->stat.st_blocks;
                        _v96 = _t344->stat.st_blocks;
                        if(format == 0 || (print_block_size & 255) != 0) {
                            _v884 = output_block_size;
                            _v880 =  *134628524;
                            _v892 = 512;
                            _v888 = 0;
                            _v896 = human_output_opts;
                            _v900 =  &(linkstats.st_dev);
                             *__esp = blocks;
                            _v904 = _v96;
                            len = gnu_mbswidth(human_readable(), 0);
                            if(block_size_width < len) {
                                block_size_width = len;
                            }
                        }
                        if(format == 0) {
                            if((print_owner & 255) != 0) {
                                len = format_user_width(f->stat.st_uid);
                                if(owner_width < len) {
                                    owner_width = len;
                                }
                            }
                            if((print_group & 255) != 0) {
                                len = format_group_width(f->stat.st_gid);
                                if(group_width < len) {
                                    group_width = len;
                                }
                            }
                            if((print_author & 255) != 0) {
                                len = format_user_width(f->stat.st_uid);
                                if(author_width < len) {
                                    author_width = len;
                                }
                            }
                        }
                        if((print_scontext & 255) != 0) {
                            _t409 = f->scontext.st_dev;
                             *__esp = _t409;
                            strlen();
                            len = _t409;
                            if(scontext_width < len) {
                                scontext_width = len;
                            }
                        }
                        if(format == 0) {
                            _v900 =  &b;
                             *__esp = f->stat.st_nlink;
                            _v904 = 0;
                            _t372 = umaxtostr();
                             *__esp = _t372;
                            strlen();
                            b_len = _t372;
                            if(nlink_width < b_len) {
                                nlink_width = b_len;
                            }
                            if((f->stat.st_mode & 61440) == 8192 || (f->stat.st_mode & 61440) == 24576) {
                                _t377 = f;
                                _t378 = _t377->stat.st_rdev;
                                 *__esp = _t378;
                                _v904 = _t377->stat.st_rdev;
                                gnu_dev_major();
                                _v900 =  &buf;
                                 *__esp = _t378;
                                _v904 = 0;
                                _t380 = umaxtostr();
                                 *__esp = _t380;
                                strlen();
                                len = _t380;
                                if(major_device_number_width < len) {
                                    major_device_number_width = len;
                                }
                                _t382 = f;
                                _t383 = _t382->stat.st_rdev;
                                 *__esp = _t383;
                                _v904 = _t382->stat.st_rdev;
                                gnu_dev_minor();
                                _v900 =  &buf;
                                 *__esp = _t383;
                                _v904 = 0;
                                _t385 = umaxtostr();
                                 *__esp = _t385;
                                strlen();
                                len = _t385;
                                if(minor_device_number_width < len) {
                                    minor_device_number_width = len;
                                }
                                len = major_device_number_width + 2 + minor_device_number_width;
                                if(file_size_width < len) {
                                    file_size_width = len;
                                }
                            } else {
                                _t397 = f;
                                _t581 = _t397->stat.st_size;
                                 *__esp = _t397->stat.st_size;
                                _v904 = _t581;
                                size = unsigned_file_size();
                                _v24 = _t581;
                                _v884 = file_output_block_size;
                                _v880 =  *134627796;
                                _v892 = 1;
                                _v888 = 0;
                                _v896 = human_output_opts;
                                _v900 =  &(linkstats.st_dev);
                                 *__esp = size;
                                _v904 = _v24;
                                len = gnu_mbswidth(human_readable(), 0);
                                if(file_size_width < len) {
                                    file_size_width = len;
                                }
                            }
                        }
                        goto L114;
                    }
                } else {
                     *__esp = "cannot access %s";
                    gettext();
                    file_failure(_v840 & 255, _t314, absolute_name);
                    if(_v840 == 0) {
                        f->name = xstrdup(name);
                        cwd_n_used = cwd_n_used + 1;
                        _v852 = 0;
                        _v848 = 0;
                    } else {
                        _v852 = 0;
                        _v848 = 0;
                    }
                    goto L118;
                }
            }
            if(_v860 <= 4) {
                if(_v840 == 0) {
                    goto L41;
                }
                err = stat64(absolute_name,  &(f->stat));
                do_deref = 1;
                _t314 = dereference;
                if(_t314 == 3) {
                    goto L42;
                } else {
                    if(err >= 0) {
                        _v853 = (f->stat.st_mode & 61440) != 16384;
                    } else {
                        __errno_location();
                        _v853 =  *_t314 == 2;
                    }
                    need_lstat = _v853 & 255;
                    _t314 = need_lstat & 255 ^ 1;
                    if(_t314 != 0) {
                        goto L42;
                    }
                    goto L41;
                }
            }
            if(_v860 != 5) {
                goto L41;
            } else {
                _t314 = stat64(absolute_name,  &(f->stat));
                err = _t314;
                do_deref = 1;
                goto L42;
            }
        }
        if(( *( *(__ebp + 28)) & 255) != 0) {
            _t505 = name;
             *__esp = _t505;
            strlen();
            _t506 =  *(__ebp + 28);
             *__esp = _t506;
            strlen();
            __esp = __esp - (_t505 + _t506 + 0x20 >> 4 << 4);
            _v864 =  &_v876;
            _v864 =  &(_v864[0xf]) >> 4 << 4;
            absolute_name = _v864;
            attach(absolute_name,  *(__ebp + 28), name);
            goto L31;
        }
        goto L29;
    } else {
        if((print_inode & 255) != 0 || (format_needs_type & 255) != 0) {
            if(type == 6 || type == 0) {
                if(dereference == 5 || (_v840 & 255 ^ 1) == 0 && dereference != 2 || (color_symlink_as_referent & 255) != 0 || (check_symlink_color & 255) != 0) {
                    goto L27;
                } else {
                    goto L18;
                }
            } else {
                goto L18;
            }
        } else {
L18:
            if((print_inode & 255 ^ 1) != 0 || (_v836 | _v832) != 0) {
                if((format_needs_type & 255 ^ 1) != 0 || type != 0 && _v840 == 0 && (type != 5 || indicator_style != 3 && ((print_with_color & 255 ^ 1) != 0 || is_colored(13) == 0))) {
L114:
                    if((print_inode & 255) != 0) {
                        _t364 = f;
                        _v900 =  &buf;
                         *__esp = _t364->stat.st_ino;
                        _v904 = _t364->stat.st_ino;
                        _t366 = umaxtostr();
                         *__esp = _t366;
                        strlen();
                        len = _t366;
                        if(inode_number_width < len) {
                            inode_number_width = len;
                        }
                    }
                    f->name = xstrdup(name);
                    cwd_n_used = cwd_n_used + 1;
                    _v852 = blocks;
                    _v848 = _v96;
L118:
                    return _v852;
                } else {
                    goto L27;
                }
            } else {
                goto L27;
            }
        }
    }
}

int getfilecon(const char* s, char** con)
{// addr = 0x0804D30D  --  defined in 'selinux.h' at line 33
    __errno_location();
     *__eax = 95;
    return -1;
}

int lgetfilecon(const char* s, char** con)
{// addr = 0x0804D325  --  defined in 'selinux.h' at line 35
    __errno_location();
     *__eax = 95;
    return -1;
}

_Bool is_directory(const struct fileinfo* f)
{// addr = 0x0804D33D  --  defined in 'ls.c' at line 2839
    signed char _v8;                       // _cfa_fffffff8

    if(f->filetype == 3 || f->filetype == 9) {
        _v8 = 1;
    } else {
        _v8 = 0;
    }
    return _v8 & 255;
}

void get_link_name(const char* filename, struct fileinfo* f, _Bool command_line_arg)
{// addr = 0x0804D36F  --  defined in 'ls.c' at line 2849
    signed char _v8;                       // _cfa_fffffff8
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    const char* _t23;   // _t23

    _v8 = command_line_arg;
    f->linkname = areadlink_with_size(filename, f->stat.st_size);
    _t23 = f->linkname;
    if(_t23 == 0) {
         *__esp = "cannot read symbolic link %s";
        gettext();
        file_failure(_v8 & 255, _t23, filename);
        return;
    }
}

char* make_link_name(const char* name, const char* linkname)
{// addr = 0x0804D3CA  --  defined in 'ls.c' at line 2863
    size_t bufsiz;      // _cfa_fffffff8
    char* linkbuf;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    const char* _v40;   // _cfa_ffffffd8
    char* _t33;                            // _t33
    const char* _t37;   // _t37

    if(linkname != 0) {
        if(( *linkname & 255) != 47) {
            _v40 = 47;
            _t33 = name;
             *__esp = _t33;
            strrchr();
            linkbuf = _t33;
            if(linkbuf != 0) {
                bufsiz = linkbuf - name + 1;
                _t37 = linkname;
                 *__esp = _t37;
                strlen();
                linkbuf = xmalloc(_t37 + bufsiz + 1);
                _v36 = bufsiz;
                _v40 = name;
                 *__esp = linkbuf;
                strncpy();
                _v40 = linkname;
                 *__esp =  &(linkbuf[bufsiz]);
                strcpy();
                _v24 = linkbuf;
            } else {
                _v24 = xstrdup(linkname);
            }
        } else {
            _v24 = xstrdup(linkname);
        }
    } else {
        _v24 = 0;
    }
    return _v24;
}

_Bool basename_is_dot_or_dotdot(const char* name)
{// addr = 0x0804D495  --  defined in 'ls.c' at line 2891
    const char* base;   // _cfa_fffffff8

    base = last_component(name);
    return dot_or_dotdot(base);
}

_Bool dot_or_dotdot(const char* file_name)
{// addr = 0x0804D4B6  --  defined in 'system.h' at line 365
    char sep;                              // _cfa_fffffffb
    signed char _v24;                      // _cfa_ffffffe8
    signed char _v25;                      // _cfa_ffffffe7
    signed char _v32;                      // _cfa_ffffffe0

    if(( *file_name & 255) != 46) {
        _v25 = 0;
    } else {
        if((file_name[1] & 255) != 46) {
            _v32 = 1;
        } else {
            _v32 = 2;
        }
        sep =  *(file_name + _v32) & 255;
        if(sep == 0 || sep == 47) {
            _v24 = 1;
        } else {
            _v24 = 0;
        }
        _v25 = _v24 & 255;
    }
    return _v25 & 255;
}

void extract_dirs_from_files(const char* dirname, _Bool command_line_arg)
{// addr = 0x0804D51E  --  defined in 'ls.c' at line 2906
    struct fileinfo* f;   // _cfa_fffffff8
    char* name;                            // _cfa_fffffff4
    struct fileinfo* f;   // _cfa_fffffff0
    _Bool ignore_dot_and_dot_dot;          // _cfa_ffffffef
    size_t j;           // _cfa_ffffffe8
    size_t i;           // _cfa_ffffffe4
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v40 = command_line_arg;
    ignore_dot_and_dot_dot = dirname != 0;
    if(dirname != 0) {
        if(active_dir_set != 0) {
            queue_directory(0, dirname, 0);
        }
    }
    i = cwd_n_used;
    while(1) {
        i = i - 1;
        if(i == 0) {
            break;
        }
        f = sorted_file[i];
        if(is_directory(f) != 0 && ((ignore_dot_and_dot_dot & 255 ^ 1) != 0 || (basename_is_dot_or_dotdot(f->name) ^ 1) != 0)) {
            if(dirname == 0 || (f & 255) == 47) {
                queue_directory(f->name, f->linkname, _v40 & 255);
            } else {
                name = file_name_concat(dirname, f->name, 0);
                queue_directory(name, f->linkname, _v40 & 255);
                 *__esp = name;
                free();
            }
            if(f->filetype == 9) {
                 *__esp = f->name;
                free();
            }
        }
    }
    i = 0;
    j = 0;
    while(i < cwd_n_used) {
        f = sorted_file[i];
        sorted_file[j] = f;
        j = j + (f->filetype != 9 & 255);
        i = i + 1;
    }
    cwd_n_used = j;
}

int xstrcoll(const char* a, const char* b)
{// addr = 0x0804D6BB  --  defined in 'ls.c' at line 2961
    int diff;                              // _cfa_ffffffec
    intOrPtr _v44;                         // _cfa_ffffffd4
    const char** _v48;   // _cfa_ffffffd0
    const char** _v52;   // _cfa_ffffffcc
    const char* _v56;   // _cfa_ffffffc8 (outparam)
    int _t17;                              // _t17
    const _None* _t21;   // _t21
    const char** _t23;   // _t23

    __errno_location();
     *__eax = 0;
    _v56 = b;
    _t17 = a;
     *__esp = _t17;
    strcoll();
    diff = _t17;
    __errno_location();
    if( *_t17 != 0) {
        _t21 = quote_n(1, b);
        _t23 = quote_n(0, a);
         *__esp = "cannot compare file names %s and %s";
        gettext();
        __errno_location();
        _v44 = _t21;
        _v48 = _t23;
        _v52 = _t23;
        _v56 =  *_t23;
         *__esp = 0;
        error();
        set_exit_status(0);
        _v56 = 1;
         *__esp =  &failed_strcoll;
        longjmp();
    }
    return diff;
}

int xstrcoll_ctime(V a, V b)
{// addr = 0x0804D775  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_ctime(a, b, xstrcoll);
}

int cmp_ctime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804D797  --  defined in 'ls.c' at line 3028
    int diff;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    struct stat* _v20;    // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    struct stat* _v56;    // _cfa_ffffffc8
    struct stat* _v60;    // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0 (outparam)
    _None* _t36;                           // _t36

    _v56 =  &(a->stat);
    get_stat_ctime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_ctime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    diff = timespec_cmp();
    if(diff != 0) {
        _v40 = diff;
    } else {
        _v64 = b->name;
         *__esp = a->name;
        _t36 = cmp;
         *_t36();
        _v40 = _t36;
    }
    return _v40;
}

struct timespec get_stat_ctime(const struct stat* st)
{// addr = 0x0804D81C  --  defined in 'stat-time.h' at line 117
    intOrPtr _t6;                          // _t6

    __ecx = st;
    _t6 =  *((intOrPtr*)(__ebp + 12));
     *__ecx =  *((intOrPtr*)(_t6 + 80));
     *((intOrPtr*)(__ecx + 4)) =  *((intOrPtr*)(_t6 + 84));
    return __ecx;
}

int timespec_cmp(struct timespec a, struct timespec b)
{// addr = 0x0804D836  --  defined in 'timespec.h' at line 27
    long int _v8;                          // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4

    if(a.tv_sec < b.tv_nsec) {
        _v12 = -1;
    } else {
        if(a.tv_sec > b.tv_nsec) {
            _v8 = 1;
        } else {
            _v8 = b.tv_sec - _a16;
        }
        _v12 = _v8;
    }
    return _v12;
}

int strcmp_ctime(V a, V b)
{// addr = 0x0804D87A  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_ctime(a, b, strcmp);
}

int rev_xstrcoll_ctime(V a, V b)
{// addr = 0x0804D89C  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_ctime(b, a, xstrcoll);
}

int rev_strcmp_ctime(V a, V b)
{// addr = 0x0804D8BE  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_ctime(b, a, strcmp);
}

int xstrcoll_df_ctime(V a, V b)
{// addr = 0x0804D8E0  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_ctime(V a, V b)
{// addr = 0x0804D958  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_ctime(V a, V b)
{// addr = 0x0804D9D0  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_ctime(V a, V b)
{// addr = 0x0804DA48  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_mtime(V a, V b)
{// addr = 0x0804DAC0  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_mtime(a, b, xstrcoll);
}

int cmp_mtime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804DAE2  --  defined in 'ls.c' at line 3037
    int diff;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    struct stat* _v20;    // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    struct stat* _v56;    // _cfa_ffffffc8
    struct stat* _v60;    // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0 (outparam)
    _None* _t36;                           // _t36

    _v56 =  &(a->stat);
    get_stat_mtime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_mtime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    diff = timespec_cmp();
    if(diff != 0) {
        _v40 = diff;
    } else {
        _v64 = b->name;
         *__esp = a->name;
        _t36 = cmp;
         *_t36();
        _v40 = _t36;
    }
    return _v40;
}

struct timespec get_stat_mtime(const struct stat* st)
{// addr = 0x0804DB67  --  defined in 'stat-time.h' at line 131
    intOrPtr _t6;                          // _t6

    __ecx = st;
    _t6 =  *((intOrPtr*)(__ebp + 12));
     *__ecx =  *((intOrPtr*)(_t6 + 72));
     *((intOrPtr*)(__ecx + 4)) =  *((intOrPtr*)(_t6 + 76));
    return __ecx;
}

int strcmp_mtime(V a, V b)
{// addr = 0x0804DB81  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_mtime(a, b, strcmp);
}

int rev_xstrcoll_mtime(V a, V b)
{// addr = 0x0804DBA3  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_mtime(b, a, xstrcoll);
}

int rev_strcmp_mtime(V a, V b)
{// addr = 0x0804DBC5  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_mtime(b, a, strcmp);
}

int xstrcoll_df_mtime(V a, V b)
{// addr = 0x0804DBE7  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_mtime(V a, V b)
{// addr = 0x0804DC5F  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_mtime(V a, V b)
{// addr = 0x0804DCD7  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_mtime(V a, V b)
{// addr = 0x0804DD4F  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_atime(V a, V b)
{// addr = 0x0804DDC7  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_atime(a, b, xstrcoll);
}

int cmp_atime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804DDE9  --  defined in 'ls.c' at line 3046
    int diff;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    struct stat* _v20;    // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    struct stat* _v56;    // _cfa_ffffffc8
    struct stat* _v60;    // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0 (outparam)
    _None* _t36;                           // _t36

    _v56 =  &(a->stat);
    get_stat_atime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_atime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    diff = timespec_cmp();
    if(diff != 0) {
        _v40 = diff;
    } else {
        _v64 = b->name;
         *__esp = a->name;
        _t36 = cmp;
         *_t36();
        _v40 = _t36;
    }
    return _v40;
}

struct timespec get_stat_atime(const struct stat* st)
{// addr = 0x0804DE6E  --  defined in 'stat-time.h' at line 103
    intOrPtr _t6;                          // _t6

    __ecx = st;
    _t6 =  *((intOrPtr*)(__ebp + 12));
     *__ecx =  *((intOrPtr*)(_t6 + 64));
     *((intOrPtr*)(__ecx + 4)) =  *((intOrPtr*)(_t6 + 68));
    return __ecx;
}

int strcmp_atime(V a, V b)
{// addr = 0x0804DE88  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_atime(a, b, strcmp);
}

int rev_xstrcoll_atime(V a, V b)
{// addr = 0x0804DEAA  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_atime(b, a, xstrcoll);
}

int rev_strcmp_atime(V a, V b)
{// addr = 0x0804DECC  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_atime(b, a, strcmp);
}

int xstrcoll_df_atime(V a, V b)
{// addr = 0x0804DEEE  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_atime(V a, V b)
{// addr = 0x0804DF66  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_atime(V a, V b)
{// addr = 0x0804DFDE  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_atime(V a, V b)
{// addr = 0x0804E056  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_size(V a, V b)
{// addr = 0x0804E0CE  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_size(a, b, xstrcoll);
}

int cmp_size(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E0F0  --  defined in 'ls.c' at line 3055
    int diff;                              // _cfa_fffffff8
    int _v24;                              // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    char* _v72;                            // _cfa_ffffffb8
    const struct fileinfo* _t47;   // _t47
    const struct fileinfo* _t48;   // _t48
    _None* _t54;                           // _t54
    const struct fileinfo* _t56;   // _t56
    const struct fileinfo* _t57;   // _t57

    _t47 = b;
    _v60 = _t47->stat.st_size;
    _v56 = _t47->stat.st_size;
    _t48 = a;
    _v52 = _t48->stat.st_size;
    _v48 = _t48->stat.st_size;
    if(_v56 < _v48) {
L7:
        _v64 = -1;
L8:
        diff = _v64;
        if(diff != 0) {
            _v24 = diff;
        } else {
            _v72 = b->name;
             *__esp = a->name;
            _t54 = cmp;
             *_t54();
            _v24 = _t54;
        }
        return _v24;
    }
    if(_v56 > _v48 || _v60 >= _v52) {
        _t56 = b;
        _v44 = _t56->stat.st_size;
        _v40 = _t56->stat.st_size;
        _t57 = a;
        _v36 = _t57->stat.st_size;
        _v32 = _t57->stat.st_size;
        _v64 = 1;
        if(_v40 <= _v32 && (_v40 < _v32 || _v44 <= _v36)) {
            _v64 = 0;
        }
        goto L8;
    } else {
        goto L7;
    }
}

int strcmp_size(V a, V b)
{// addr = 0x0804E1AB  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_size(a, b, strcmp);
}

int rev_xstrcoll_size(V a, V b)
{// addr = 0x0804E1CD  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_size(b, a, xstrcoll);
}

int rev_strcmp_size(V a, V b)
{// addr = 0x0804E1EF  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_size(b, a, strcmp);
}

int xstrcoll_df_size(V a, V b)
{// addr = 0x0804E211  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_size(V a, V b)
{// addr = 0x0804E289  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_size(V a, V b)
{// addr = 0x0804E301  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_size(V a, V b)
{// addr = 0x0804E379  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_name(V a, V b)
{// addr = 0x0804E3F1  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_name(a, b, xstrcoll);
}

int cmp_name(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E413  --  defined in 'ls.c' at line 3063
    char* _v8;                             // _cfa_fffffff8
    int _t8;                               // _t8

    _v8 = b->name;
     *__esp = a->name;
    _t8 = cmp;
     *_t8();
    return _t8;
}

int strcmp_name(V a, V b)
{// addr = 0x0804E431  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_name(a, b, strcmp);
}

int rev_xstrcoll_name(V a, V b)
{// addr = 0x0804E453  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_name(b, a, xstrcoll);
}

int rev_strcmp_name(V a, V b)
{// addr = 0x0804E475  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_name(b, a, strcmp);
}

int xstrcoll_df_name(V a, V b)
{// addr = 0x0804E497  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_name(V a, V b)
{// addr = 0x0804E50F  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_name(V a, V b)
{// addr = 0x0804E587  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_name(V a, V b)
{// addr = 0x0804E5FF  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_extension(V a, V b)
{// addr = 0x0804E677  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_extension(a, b, xstrcoll);
}

int cmp_extension(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E699  --  defined in 'ls.c' at line 3073
    int diff;                              // _cfa_fffffff8
    const char* base2;   // _cfa_fffffff4
    const char* base1;   // _cfa_fffffff0
    int _v24;                              // _cfa_ffffffe8
    const char* _v28;   // _cfa_ffffffe4
    const char* _v32;   // _cfa_ffffffe0
    char* _v40;                            // _cfa_ffffffd8
    const char* _t30;   // _t30
    const char* _t32;   // _t32
    int _t35;                              // _t35
    _None* _t41;                           // _t41

    _t30 = a->name;
    _v40 = 46;
     *__esp = _t30;
    strrchr();
    base1 = _t30;
    _t32 = b->name;
    _v40 = 46;
     *__esp = _t32;
    strrchr();
    base2 = _t32;
    if(base2 == 0) {
        _v32 = 134606192;
    } else {
        _v32 = base2;
    }
    if(base1 == 0) {
        _v28 = 134606192;
    } else {
        _v28 = base1;
    }
    _v40 = _v32;
     *__esp = _v28;
    _t35 = cmp;
     *_t35();
    diff = _t35;
    if(diff != 0) {
        _v24 = diff;
    } else {
        _v40 = b->name;
         *__esp = a->name;
        _t41 = cmp;
         *_t41();
        _v24 = _t41;
    }
    return _v24;
}

int strcmp_extension(V a, V b)
{// addr = 0x0804E73A  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_extension(a, b, strcmp);
}

int rev_xstrcoll_extension(V a, V b)
{// addr = 0x0804E75C  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_extension(b, a, xstrcoll);
}

int rev_strcmp_extension(V a, V b)
{// addr = 0x0804E77E  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return cmp_extension(b, a, strcmp);
}

int xstrcoll_df_extension(V a, V b)
{// addr = 0x0804E7A0  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_extension(V a, V b)
{// addr = 0x0804E818  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_extension(V a, V b)
{// addr = 0x0804E890  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_extension(V a, V b)
{// addr = 0x0804E908  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_version(V a, V b)
{// addr = 0x0804E980  --  defined in 'ls.c' at line 3103
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return cmp_version(a, b);
}

int cmp_version(const struct fileinfo* a, const struct fileinfo* b)
{// addr = 0x0804E99A  --  defined in 'ls.c' at line 3098
    char* _v8;                             // _cfa_fffffff8
    int _t6;                               // _t6

    _t6 = a->name;
    _v8 = b->name;
     *__esp = _t6;
    strverscmp();
    return _t6;
}

int rev_xstrcoll_version(V a, V b)
{// addr = 0x0804E9B8  --  defined in 'ls.c' at line 3105
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return cmp_version(b, a);
}

int xstrcoll_df_version(V a, V b)
{// addr = 0x0804E9D2  --  defined in 'ls.c' at line 3107
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_version(a, b);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_version(V a, V b)
{// addr = 0x0804EA42  --  defined in 'ls.c' at line 3109
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    a_is_dir = is_directory(a);
    b_is_dir = is_directory(b);
    if(a_is_dir == 0 || (b_is_dir & 255 ^ 1) == 0) {
        if((a_is_dir & 255 ^ 1) == 0 || b_is_dir == 0) {
            _v24 = cmp_version(b, a);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

void initialize_ordering_vector()
{// addr = 0x0804EAB2  --  defined in 'ls.c' at line 3177
    size_t i;           // _cfa_fffffff4

    i = 0;
    while(i < cwd_n_used) {
        sorted_file[i] = cwd_file + (i * 8 << 4) - i * 8;
        i = i + 1;
    }
}

void sort_files()
{// addr = 0x0804EB01  --  defined in 'ls.c' at line 3187
    _Bool use_strcmp;                      // _cfa_fffffff3
    union time_type _v32;   // _cfa_ffffffe0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    char* _v56;                            // _cfa_ffffffc8 (outparam)
    union sort_type _t19;   // _t19

    if((cwd_n_used >> 1) + cwd_n_used > sorted_file_alloc) {
         *__esp = sorted_file;
        free();
        sorted_file = xnmalloc(cwd_n_used, 12);
        sorted_file_alloc = cwd_n_used + cwd_n_used + cwd_n_used;
    }
    initialize_ordering_vector();
    _t19 = sort_type;
    if(_t19 != -1) {
         *__esp =  &failed_strcoll;
        _setjmp();
        if(_t19 != 0) {
            use_strcmp = 1;
            __eflags = sort_type - 3;
            if(__eflags == 0) {
                _v48 = "sort_files";
                _v52 = 3212;
                _v56 = "ls.c";
                 *__esp = "sort_type != sort_version";
                __assert_fail();
            }
            initialize_ordering_vector();
        } else {
            use_strcmp = 0;
        }
        if(sort_type != 4) {
            _v32 = 0;
        } else {
            _v32 = time_type;
        }
        mpsort(sorted_file, cwd_n_used,  *( &sort_functions + (_v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + _v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + (sort_reverse & 0xff) + _v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + _v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + (sort_reverse & 0xff) + (directories_first & 0xff)) * 4));
        return;
    }
}

void print_current_files()
{// addr = 0x0804EC2E  --  defined in 'ls.c' at line 3227
    size_t i;           // _cfa_fffffff8
    union format _v24;   // _cfa_ffffffe8

    _v24 = format;
    if(_v24 <= 4) {
        goto __eax;
    }
}

int long_time_expected_width()
{// addr = 0x0804ECF0  --  defined in 'ls.c' at line 3267
    size_t len;         // _cfa_fffffff8
    const struct tm* tm;   // _cfa_fffffff4
    time_t epoch;       // _cfa_fffffff0
    char[1000] buf;                        // _cfa_fffffc07
    _unknown_ _v1032;                      // _cfa_fffffbf8 (outparam)
    _unknown_ _v1036;                      // _cfa_fffffbf4 (outparam)
    _unknown_ _v1040;                      // _cfa_fffffbf0 (outparam)
    _unknown_ _v1044;                      // _cfa_fffffbec (outparam)
    _unknown_ _v1048;                      // _cfa_fffffbe8 (outparam)

    if(width >= 0) {
L6:
        return width;
    }
    epoch = 0;
     *__esp =  &epoch;
    localtime();
    tm =  &epoch;
    if(tm != 0) {
        len = nstrftime( &buf, 1001, long_time_format, tm, 0, 0);
        if(len != 0) {
            width = mbsnwidth( &buf, len, 0);
        }
    }
    if(width < 0) {
        width = 0;
    }
    goto L6;
}

void get_current_time()
{// addr = 0x0804ED9D  --  defined in 'ls.c' at line 3302
    _unknown_ _v8;                         // _cfa_fffffff8
    struct timespec timespec;   // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    struct timeval timeval;   // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    int _t9;                               // _t9
    int _t14;                              // _t14

    _t9 =  &(timespec.tv_sec);
    _v24 = _t9;
     *__esp = 0;
    clock_gettime();
    __eflags = _t9;
    if(__eflags != 0) {
        _v24 = 0;
         *__esp =  &(timeval.tv_sec);
        gettimeofday();
        current_time = timeval.tv_sec;
        _t14 = 999 + timeval.tv_usec * 1000;
        __eflags = _t14;
        current_time_ns = _t14;
        return;
    }
    current_time = timespec.tv_sec;
    current_time_ns = timespec.tv_nsec;
}

void format_user_or_group(const char* name, long unsigned int id, int width)
{// addr = 0x0804EDFC  --  defined in 'ls.c' at line 3339
    int pad;                               // _cfa_fffffff8
    int width_gap;                         // _cfa_fffffff4
    size_t len;         // _cfa_fffffff0
    long unsigned int _v36;                // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8 (outparam)
    const char* _t41;   // _t41

    if(name == 0) {
        _v36 = id;
        _v40 = width;
         *__esp = 134609304;
        printf();
        len = width;
    } else {
        width_gap = width - gnu_mbswidth(name, 0);
        pad =  !(width_gap >> 31) & width_gap;
        _v40 = __imp__stdout;
         *__esp = name;
        fputs_unlocked();
        _t41 = name;
         *__esp = _t41;
        strlen();
        len = _t41 + pad;
        do {
             *__esp = 32;
            putchar_unlocked();
            pad = pad - 1;
        } while(pad != 0);
    }
    dired_pos = dired_pos + len + 1;
}

void format_user(uid_t u, int width, _Bool stat_ok)
{// addr = 0x0804EEAC  --  defined in 'ls.c' at line 3367
    char _v8;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    const char* _v16;   // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _v8 = stat_ok;
    if(_v8 == 0) {
        _v16 = 134609310;
    } else {
        if((numeric_ids & 255) == 0) {
            _v12 = getuser(u);
        } else {
            _v12 = 0;
        }
        _v16 = _v12;
    }
    format_user_or_group(_v16, u, width);
}

void format_group(gid_t g, int width, _Bool stat_ok)
{// addr = 0x0804EF0A  --  defined in 'ls.c' at line 3376
    char _v8;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    const char* _v16;   // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _v8 = stat_ok;
    if(_v8 == 0) {
        _v16 = 134609310;
    } else {
        if((numeric_ids & 255) == 0) {
            _v12 = getgroup(g);
        } else {
            _v12 = 0;
        }
        _v16 = _v12;
    }
    format_user_or_group(_v16, g, width);
}

int format_user_or_group_width(const char* name, long unsigned int id)
{// addr = 0x0804EF68  --  defined in 'ls.c' at line 3385
    int len;                               // _cfa_fffffff8
    char[10] buf;                          // _cfa_ffffffed
    int _v24;                              // _cfa_ffffffe8
    long unsigned int _v36;                // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)

    if(name == 0) {
        _v36 = id;
        _v40 = 134609312;
         *__esp =  &buf;
        sprintf();
         *__esp =  &buf;
        strlen();
        _v24 =  &buf;
    } else {
        len = gnu_mbswidth(name, 0);
        _v24 = len &  !(len >> 31);
    }
    return _v24;
}

int format_user_width(uid_t u)
{// addr = 0x0804EFC9  --  defined in 'ls.c' at line 3403
    const char* _v8;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((numeric_ids & 255) == 0) {
        _v8 = getuser(u);
    } else {
        _v8 = 0;
    }
    return format_user_or_group_width(_v8, u);
}

int format_group_width(gid_t g)
{// addr = 0x0804F005  --  defined in 'ls.c' at line 3411
    const char* _v8;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if((numeric_ids & 255) == 0) {
        _v8 = getgroup(g);
    } else {
        _v8 = 0;
    }
    return format_user_or_group_width(_v8, g);
}

void print_long_format(const struct fileinfo* f)
{// addr = 0x0804F041  --  defined in 'ls.c' at line 3420
    char[651] hbuf;                        // _cfa_ffffee73
    char _v16;                             // _cfa_fffffff0
    const char* fmt;   // _cfa_ffffffe8
    _Bool recent;                          // _cfa_ffffffe7
    time_t six_months_ago;   // _cfa_ffffffe0
    int pad;                               // _cfa_ffffffdc
    const char* size;   // _cfa_ffffffd8
    int blanks_width;                      // _cfa_ffffffd4
    int pad;                               // _cfa_ffffffd0
    const char* blocks;   // _cfa_ffffffcc
    struct tm* when_local;   // _cfa_ffffffc8
    int when_ns;                           // _cfa_ffffffc4
    time_t when;        // _cfa_ffffffc0
    char* p;                               // _cfa_ffffffbc
    size_t s;           // _cfa_ffffffb8
    char _v73;                             // _cfa_ffffffb7
    char _v74;                             // _cfa_ffffffb6
    char[11] modebuf;                      // _cfa_ffffffac
    char[3642] buf;                        // _cfa_fffff171
    _unknown_ _v3732;                      // _cfa_fffff16c
    struct timespec when_timespec;   // _cfa_fffff168
    char[20] hbuf;                         // _cfa_fffff153
    char[20] hbuf;                         // _cfa_fffff13e
    char[20] majorbuf;                     // _cfa_fffff129
    char[20] minorbuf;                     // _cfa_fffff114
    char[20] hbuf;                         // _cfa_fffff0ff
    char[651] hbuf;                        // _cfa_ffffee73
    long int _v4504;                       // _cfa_ffffee68
    long int _v4508;                       // _cfa_ffffee64
    unsigned int _v4512;                   // _cfa_ffffee60
    int _v4516;                            // _cfa_ffffee5c
    _Bool _v4520;                          // _cfa_ffffee58
    union filetype _v4524;   // _cfa_ffffee54
    char* _v4528;                          // _cfa_ffffee50
    signed char _v4532;                    // _cfa_ffffee4c
    const char* _v4536;   // _cfa_ffffee48
    char* _v4540;                          // _cfa_ffffee44
    int _v4544;                            // _cfa_ffffee40
    const char* _v4548;   // _cfa_ffffee3c
    char* _v4552;                          // _cfa_ffffee38
    union time_type _v4556;   // _cfa_ffffee34
    intOrPtr _v4564;                       // _cfa_ffffee2c
    long long unsigned int _v4568;         // _cfa_ffffee28
    int _v4572;                            // _cfa_ffffee24 (outparam)
    int _v4576;                            // _cfa_ffffee20 (outparam)
    char* _v4580;                          // _cfa_ffffee1c (outparam)
    char[651]* _v4584;                     // _cfa_ffffee18 (outparam)
    _Bool _v4588;                          // _cfa_ffffee14 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t376;                      // _t376
    struct tm* _t403;       // _t403
    char[651]* _t464;                      // _t464
    signed int _t466;                      // _t466
    signed int _t467;                      // _t467
    const struct fileinfo* _t486;   // _t486
    char[3642]* _t488;                     // _t488
    const struct fileinfo* _t498;   // _t498
    char[3642]* _t499;                     // _t499
    int _t501;                             // _t501
    const struct fileinfo* _t502;   // _t502
    char[3642]* _t503;                     // _t503
    intOrPtr _t505;                        // _t505
    const struct fileinfo* _t562;   // _t562
    signed int _t571;                      // _t571
    const struct fileinfo* _t572;   // _t572
    intOrPtr _t631;                        // _t631

    __esp = __esp - 4572;
    if((f->stat_ok & 255) == 0) {
        modebuf =  *(f->filetype + "?pcdb-lswd") & 255;
        _v4580 = 10;
        _v4584 = 63;
         *__esp =  &modebuf + 1;
        memset();
        _v73 = 0;
    } else {
        filemodestring( &(f->stat),  &modebuf);
    }
    if((any_has_acl & 255 ^ 1) == 0) {
        if((f->have_acl & 255) != 0) {
            _v74 = 43;
        }
    } else {
        _v74 = 0;
    }
    _v4556 = time_type;
    if(_v4556 != 1) {
        if(_v4556 < 1) {
            _v4584 =  &(f->stat);
            get_stat_mtime( &_v4508);
            __esp = __esp - 4;
            when_timespec.tv_sec = _v4508;
            when_timespec.tv_nsec = _v4504;
        } else {
            if(_v4556 == 2) {
                _v4584 =  &(f->stat);
                get_stat_atime( &_v4508);
                __esp = __esp - 4;
                when_timespec.tv_sec = _v4508;
                when_timespec.tv_nsec = _v4504;
            } else {
                abort();
            }
        }
    } else {
        _v4584 =  &(f->stat);
        get_stat_ctime( &_v4508);
        __esp = __esp - 4;
        when_timespec.tv_sec = _v4508;
        when_timespec.tv_nsec = _v4504;
    }
    when = when_timespec.tv_sec;
    when_ns = when_timespec.tv_nsec;
    p =  &buf;
    if((print_inode & 255) != 0) {
        if((f->stat.st_ino | f->stat.st_ino) == 0) {
            _v4552 = 134609310;
        } else {
            _t572 = f;
            _v4584 =  &hbuf;
             *__esp = _t572->stat.st_ino;
            _v4588 = _t572->stat.st_ino;
            _v4552 = umaxtostr();
        }
        _v4580 = _v4552;
        _v4584 = inode_number_width;
        _v4588 = 134609316;
         *__esp = p;
        sprintf();
        _t571 = p;
         *__esp = _t571;
        strlen();
        p =  &(p[_t571]);
    }
    if((print_block_size & 255) == 0) {
L29:
        if((f->stat_ok & 255) == 0) {
            _v4540 = 134609310;
        } else {
            _v4584 =  &hbuf;
             *__esp = f->stat.st_nlink;
            _v4588 = 0;
            _v4540 = umaxtostr();
        }
        _v4576 = _v4540;
        _v4580 = nlink_width;
        _v4584 =  &modebuf;
        _v4588 = "%s %*s ";
         *__esp = p;
        sprintf();
        _t376 = p;
         *__esp = _t376;
        strlen();
        p =  &(p[_t376]);
        if((dired & 255) != 0) {
            _v4580 = __imp__stdout;
            _v4584 = 2;
            _v4588 = 1;
             *__esp = "  ";
            fwrite_unlocked();
            dired_pos = 2 + dired_pos;
        }
        if((print_scontext & 0xff | print_owner & 0xff | print_group & 0xff | print_author & 0xff) != 0) {
            _v4588 = __imp__stdout;
             *__esp =  &buf;
            fputs_unlocked();
            dired_pos = p -  &buf + dired_pos;
            if((print_owner & 255) != 0) {
                format_user(f->stat.st_uid, owner_width, f->stat_ok & 0xff);
            }
            if((print_group & 255) != 0) {
                format_group(f->stat.st_gid, group_width, f->stat_ok & 0xff);
            }
            if((print_author & 255) != 0) {
                format_user(f->stat.st_uid, author_width, f->stat_ok & 0xff);
            }
            if((print_scontext & 255) != 0) {
                format_user_or_group(f->scontext, 0, scontext_width);
            }
            p =  &buf;
        }
        if((f->stat_ok & 255 ^ 1) != 0 || (f->stat.st_mode & 61440) != 8192 && (f->stat.st_mode & 61440) != 24576) {
            if((f->stat_ok & 255) == 0) {
                _v4536 = 134609310;
            } else {
                _t486 = f;
                _t631 = _t486->stat.st_size;
                 *__esp = _t486->stat.st_size;
                _v4588 = _t631;
                _t488 = unsigned_file_size();
                _v4568 = file_output_block_size;
                _v4564 =  *134627796;
                _v4576 = 1;
                _v4572 = 0;
                _v4580 = human_output_opts;
                _v4584 =  &hbuf;
                 *__esp = _t488;
                _v4588 = _t631;
                _v4536 = human_readable();
            }
            size = _v4536;
            pad = file_size_width - gnu_mbswidth(size, 0);
            while(pad > 0) {
                 *p = 32;
                p =  &(p[1]);
                pad = pad - 1;
            }
            do {
                 *p =  *size & 255;
                p =  &(p[1]);
                size =  &(size[1]);
            } while(( *p & 255) != 0);
             *((char*)(p - 1)) = 32;
            goto L56;
        } else {
            blanks_width = -2 - major_device_number_width - minor_device_number_width + file_size_width;
            _t498 = f;
            _t499 = _t498->stat.st_rdev;
             *__esp = _t499;
            _v4588 = _t498->stat.st_rdev;
            gnu_dev_minor();
            _v4584 =  &minorbuf;
             *__esp = _t499;
            _v4588 = 0;
            _t501 = umaxtostr();
            _t502 = f;
            _t503 = _t502->stat.st_rdev;
             *__esp = _t503;
            _v4588 = _t502->stat.st_rdev;
            gnu_dev_major();
            _v4584 =  &majorbuf;
             *__esp = _t503;
            _v4588 = 0;
            _t505 = umaxtostr();
            _v4572 = _t501;
            _v4576 = minor_device_number_width;
            _v4580 = _t505;
            _v4584 = ( !(blanks_width >> 31) & blanks_width) + major_device_number_width;
            _v4588 = "%*s, %*s ";
             *__esp = p;
            sprintf();
            p =  &(p[file_size_width + 1]);
L56:
            _t403 =  &(when_timespec.tv_sec);
             *__esp = _t403;
            localtime();
            when_local = _t403;
            s = 0;
             *p = 1;
            if((f->stat_ok & 255) != 0 && when_local != 0) {
                if(current_time < when || current_time == when && current_time_ns < when_ns) {
                    get_current_time();
                }
                six_months_ago = current_time - 15778476;
                if(six_months_ago > when || when >= current_time && (when != current_time || when_ns > current_time_ns)) {
                    _v4532 = 0;
                } else {
                    _v4532 = 1;
                }
                recent = _v4532 & 255;
                fmt = ( &long_time_format)[recent & 255];
                s = nstrftime(p, 1001, fmt, when_local, 0, when_ns);
            }
            if(s != 0 || ( *p & 255) == 0) {
                p =  &(p[s]);
                 *p = 32;
                p =  &(p[1]);
                 *p = 0;
            } else {
                if((f->stat_ok & 255) == 0) {
                    _v4528 = 134609310;
                } else {
                    _t467 = when;
                    _v4584 =  &hbuf;
                     *__esp = _t467;
                    _v4588 = _t467 >> 31;
                    _v4528 = imaxtostr();
                }
                _t464 = long_time_expected_width();
                _v4580 = _v4528;
                _v4584 = _t464;
                _v4588 = 134609316;
                 *__esp = p;
                sprintf();
                _t466 = p;
                 *__esp = _t466;
                strlen();
                p =  &(p[_t466]);
            }
            _v4588 = __imp__stdout;
             *__esp =  &buf;
            fputs_unlocked();
            dired_pos = p -  &buf + dired_pos;
            _v4524 = f->filetype;
            _v4520 = f->stat_ok & 0xff;
            _v4516 = f->linkok & 0xff;
            if((f->linkok & 0xff & color_symlink_as_referent & 0xff) == 0) {
                _v4512 = f->stat.st_mode;
            } else {
                _v4512 = f->linkmode;
            }
            print_name_with_quoting(f->name, _v4512, _v4516, _v4520, _v4524,  &dired_obstack);
            if(f->filetype != 6) {
                if(indicator_style != 0) {
                    print_type_indicator(f->stat_ok & 0xff, f->stat.st_mode, f->filetype);
                }
            } else {
                if(f->linkname != 0) {
                    _v4580 = __imp__stdout;
                    _v4584 = 4;
                    _v4588 = 1;
                     *__esp = " -> ";
                    fwrite_unlocked();
                    dired_pos = 4 + dired_pos;
                    print_name_with_quoting(f->linkname, f->linkmode, (f->linkok & 0xff) - 1, f->stat_ok & 0xff, f->filetype, 0);
                    if(indicator_style != 0) {
                        print_type_indicator(1, f->linkmode, 0);
                    }
                }
            }
            __esp =  &_v16;
            return;
        }
    } else {
        if((f->stat_ok & 255) == 0) {
            _v4548 = 134609310;
        } else {
            _v4544 = human_output_opts;
            _t562 = f;
            _v4568 = output_block_size;
            _v4564 =  *134628524;
            _v4576 = 512;
            _v4572 = 0;
            _v4580 = _v4544;
            _v4584 =  &hbuf;
             *__esp = _t562->stat.st_blocks;
            _v4588 = _t562->stat.st_blocks;
            _v4548 = human_readable();
        }
        blocks = _v4548;
        pad = block_size_width - gnu_mbswidth(blocks, 0);
        while(pad > 0) {
             *p = 32;
            p =  &(p[1]);
            pad = pad - 1;
        }
        do {
             *p =  *blocks & 255;
            p =  &(p[1]);
            blocks =  &(blocks[1]);
        } while(( *p & 255) != 0);
         *((char*)(p - 1)) = 32;
        goto L29;
    }
}

size_t quote_name(FILE* out, const char* name, const struct quoting_options* options, size_t* width)
{// addr = 0x0804FA54  --  defined in 'ls.c' at line 3652
    _unknown_ _v8;                         // _cfa_fffffff8
    const char* plimit;   // _cfa_fffffff4
    const char* p;   // _cfa_fffffff0
    const char* plimit;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int w;                                 // _cfa_ffffffe4
    size_t bytes;       // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    const char* plimit;   // _cfa_ffffffd8
    const char* p;   // _cfa_ffffffd4
    size_t displayed_width;   // _cfa_ffffffd0
    char* buf;                             // _cfa_ffffffcc
    size_t len;         // _cfa_ffffffc8
    char[8191] smallbuf;                   // _cfa_ffffdfc8
    intOrPtr _v8252;                       // _cfa_ffffdfc4
    mbstate_t mbstate;   // _cfa_ffffdfc0
    wchar_t wc;        // _cfa_ffffdfbc
    signed int _v8268;                     // _cfa_ffffdfb4
    char* _v8272;                          // _cfa_ffffdfb0
    char _v8280;                           // _cfa_ffffdfa8
    _unknown_ _v8284;                      // _cfa_ffffdfa4 (outparam)
    FILE* _v8288;         // _cfa_ffffdfa0 (outparam)
    signed int _v8292;                     // _cfa_ffffdf9c (outparam)
    const char* _v8296;   // _cfa_ffffdf98 (outparam)
    signed int _t176;                      // _t176
    const char* _t185;   // _t185
    char* _t202;                           // _t202
    int _t230;                             // _t230

    _push(__ebx);
    __esp = __esp - 8292;
    len = quotearg_buffer( &smallbuf, 8192, name, -1, options);
    if(len > 8191) {
        __esp = __esp - (len + 0x1f >> 4 << 4);
        _v8272 =  &_v8280;
        _v8272 =  &(_v8272[0xf]) >> 4 << 4;
        buf = _v8272;
        quotearg_buffer(buf, len + 1, name, -1, options);
    } else {
        buf =  &smallbuf;
    }
    _t176 = qmark_funny_chars & 255;
    if(_t176 == 0) {
        if(width != 0) {
            __ctype_get_mb_cur_max();
            if(_t176 <= 1) {
                p = buf;
                plimit =  &(buf[len]);
                displayed_width = 0;
                while(1) {
                    _t185 = p;
                    if(_t185 >= plimit) {
                        goto L44;
                    }
                    __ctype_b_loc();
                    if(( *( *_t185 + (to_uchar( *p & 255) & 255) + (to_uchar( *p & 255) & 255)) & 0x4000) != 0) {
                        displayed_width = displayed_width + 1;
                    }
                    p =  &(p[1]);
                }
            } else {
                displayed_width = mbsnwidth(buf, len, 0);
            }
        }
    } else {
        __ctype_get_mb_cur_max();
        if(_t176 <= 1) {
            p = buf;
            plimit =  &(buf[len]);
            while(1) {
                _t202 = p;
                if(_t202 >= plimit) {
                    break;
                }
                __ctype_b_loc();
                if(( *( *_t202 + (to_uchar( *p & 255) & 255) + (to_uchar( *p & 255) & 255)) & 0x4000) == 0) {
                     *p = 63;
                }
                p =  &(p[1]);
            }
            displayed_width = len;
        } else {
            p = buf;
            plimit =  &(buf[len]);
            q = buf;
            displayed_width = 0;
L28:
            while(p < plimit) {
                _v8268 =  *p & 255;
                if(_v8268 > 95) {
                    if(_v8268 - 97 > 29) {
                        goto L14;
                    } else {
                        goto L13;
                    }
                } else {
                    if(_v8268 >= 65) {
L13:
                         *q =  *p & 255;
                        q =  &(q[1]);
                        p =  &(p[1]);
                        displayed_width = displayed_width + 1;
                    } else {
                        if(_v8268 < 32) {
L14:
                            mbstate.__val = 0;
                            _v8252 = 0;
                            while(1) {
                                _v8288 =  &mbstate;
                                _v8292 = plimit - p;
                                _v8296 = p;
                                 *__esp =  &wc;
                                mbrtowc();
                                bytes =  &wc;
                                if(bytes == -1) {
                                    break;
                                }
                                if(bytes != -2) {
                                    if(bytes == 0) {
                                        bytes = 1;
                                    }
                                    _t230 = wc;
                                     *__esp = _t230;
                                    wcwidth();
                                    w = _t230;
                                    if(w < 0) {
                                        p = p + bytes;
                                         *q = 63;
                                        q =  &(q[1]);
                                        displayed_width = displayed_width + 1;
                                    } else {
                                        while(bytes != 0) {
                                             *q =  *p & 255;
                                            q =  &(q[1]);
                                            p =  &(p[1]);
                                            bytes = bytes - 1;
                                        }
                                        displayed_width = displayed_width + w;
                                    }
                                     *__esp =  &mbstate;
                                    mbsinit();
                                    if( &mbstate == 0) {
                                        continue;
                                    }
                                } else {
                                    p = plimit;
                                     *q = 63;
                                    q =  &(q[1]);
                                    displayed_width = displayed_width + 1;
                                }
                                goto L28;
                            }
                            p =  &(p[1]);
                             *q = 63;
                            q =  &(q[1]);
                            displayed_width = displayed_width + 1;
                        } else {
                            if(_v8268 <= 35) {
                                goto L13;
                            } else {
                                if(_v8268 - 37 > 26) {
                                    goto L14;
                                } else {
                                    goto L13;
                                }
                            }
                        }
                    }
                }
            }
            len = q - buf;
        }
    }
L44:
    if(out != 0) {
        _v8288 = out;
        _v8292 = len;
        _v8296 = 1;
         *__esp = buf;
        fwrite_unlocked();
    }
    if(width != 0) {
         *width = displayed_width;
    }
    return len;
}

unsigned char to_uchar(char ch)
{// addr = 0x0804FDEF  --  defined in 'system.h' at line 263
    signed char _v8;                       // _cfa_fffffff8

    _v8 = ch;
    return _v8 & 255;
}

void print_name_with_quoting(const char* p, mode_t mode, int linkok, _Bool stat_ok, union filetype type, struct obstack* stack)
{// addr = 0x0804FE01  --  defined in 'ls.c' at line 3817
    int __len;                             // _cfa_fffffff8
    struct obstack* __o;   // _cfa_fffffff4
    int __len;                             // _cfa_fffffff0
    struct obstack* __o;   // _cfa_ffffffec
    signed char _v24;                      // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    int _v36;                              // _cfa_ffffffdc (outparam)
    unsigned int* _v40;                    // _cfa_ffffffd8 (outparam)

    _v24 = stat_ok;
    if((print_with_color & 255) != 0) {
        print_color_indicator(p, mode, linkok, _v24 & 255, type);
    }
    if(stack != 0 && (dired & 255) != 0) {
        __o = stack;
        __len = 4;
        if( &(__o->next_free[__len]) > __o->chunk_limit) {
            _v40 = __len;
             *__esp = __o;
            _obstack_newchunk();
        }
        _v36 = __len;
        _v40 =  &dired_pos;
         *__esp = __o->next_free;
        memcpy();
        __o->next_free =  &(__o->next_free[__len]);
    }
    dired_pos = quote_name(__imp__stdout, p, filename_quoting_options, 0) + dired_pos;
    if(stack != 0 && (dired & 255) != 0) {
        __o = stack;
        __len = 4;
        if( &(__o->next_free[__len]) > __o->chunk_limit) {
            _v40 = __len;
             *__esp = __o;
            _obstack_newchunk();
        }
        _v36 = __len;
        _v40 =  &dired_pos;
         *__esp = __o->next_free;
        memcpy();
        __o->next_free =  &(__o->next_free[__len]);
    }
    if((print_with_color & 255) == 0) {
        return;
    } else {
        process_signals();
        prep_non_filename_text();
        return;
    }
}

void prep_non_filename_text()
{// addr = 0x0804FF72  --  defined in 'ls.c' at line 3838
    if( *134627828 == 0) {
        put_indicator( &color_indicator);
        put_indicator(134627832);
        put_indicator(134627816);
        return;
    }
    put_indicator(134627824);
}

void print_file_name_and_frills(const struct fileinfo* f)
{// addr = 0x0804FFB5  --  defined in 'ls.c' at line 3855
    char[651] buf;                         // _cfa_fffffd64
    unsigned int _v676;                    // _cfa_fffffd5c
    int _v680;                             // _cfa_fffffd58
    _Bool _v684;                           // _cfa_fffffd54
    union filetype _v688;   // _cfa_fffffd50
    int _v692;                             // _cfa_fffffd4c
    char* _v696;                           // _cfa_fffffd48
    int _v700;                             // _cfa_fffffd44
    char* _v704;                           // _cfa_fffffd40
    int _v708;                             // _cfa_fffffd3c
    int _v712;                             // _cfa_fffffd38
    char* _v716;                           // _cfa_fffffd34
    intOrPtr _v720;                        // _cfa_fffffd30
    long long unsigned int _v724;          // _cfa_fffffd2c
    struct obstack* _v728;   // _cfa_fffffd28 (outparam)
    intOrPtr _v732;                        // _cfa_fffffd24 (outparam)
    int _v736;                             // _cfa_fffffd20 (outparam)
    char[651]* _v740;                      // _cfa_fffffd1c (outparam)
    int _v744;                             // _cfa_fffffd18 (outparam)
    const struct fileinfo* _t111;   // _t111
    const struct fileinfo* _t118;   // _t118

    if((print_inode & 255) != 0) {
        _t118 = f;
        _v740 =  &buf;
         *__esp = _t118->stat.st_ino;
        _v744 = _t118->stat.st_ino;
        _v716 = umaxtostr();
        if(format == 4) {
            _v712 = 0;
        } else {
            _v712 = inode_number_width;
        }
        _v740 = _v716;
        _v744 = _v712;
         *__esp = 134609316;
        printf();
    }
    if((print_block_size & 255) != 0) {
        _v708 = human_output_opts;
        _t111 = f;
        _v724 = output_block_size;
        _v720 =  *134628524;
        _v732 = 512;
        _v728 = 0;
        _v736 = _v708;
        _v740 =  &buf;
         *__esp = _t111->stat.st_blocks;
        _v744 = _t111->stat.st_blocks;
        _v704 = human_readable();
        if(format == 4) {
            _v700 = 0;
        } else {
            _v700 = block_size_width;
        }
        _v740 = _v704;
        _v744 = _v700;
         *__esp = 134609316;
        printf();
    }
    if((print_scontext & 255) != 0) {
        _v696 = f->scontext;
        if(format == 4) {
            _v692 = 0;
        } else {
            _v692 = scontext_width;
        }
        _v740 = _v696;
        _v744 = _v692;
         *__esp = 134609316;
        printf();
    }
    _v688 = f->filetype;
    _v684 = f->stat_ok & 0xff;
    _v680 = f->linkok & 0xff;
    if((f->linkok & 0xff & color_symlink_as_referent & 0xff) == 0) {
        _v676 = f->stat.st_mode;
    } else {
        _v676 = f->linkmode;
    }
    print_name_with_quoting(f->name, _v676, _v680, _v684, _v688, 0);
    if(indicator_style != 0) {
        print_type_indicator(f->stat_ok & 0xff, f->stat.st_mode, f->filetype);
        return;
    }
}

char get_type_indicator(_Bool stat_ok, mode_t mode, union filetype type)
{// addr = 0x08050215  --  defined in 'ls.c' at line 3881
    char c;                                // _cfa_fffffffb
    signed char _v24;                      // _cfa_ffffffe8
    char _v25;                             // _cfa_ffffffe7
    char _v26;                             // _cfa_ffffffe6
    char _v27;                             // _cfa_ffffffe5
    signed char _v32;                      // _cfa_ffffffe0
    char _v33;                             // _cfa_ffffffdf
    char _v34;                             // _cfa_ffffffde

    _v24 = stat_ok;
    if(_v24 == 0) {
        _v34 = type == 5;
    } else {
        _v34 = (mode & 61440) == 32768;
    }
    if(_v34 == 0) {
        if(_v24 == 0) {
            if(type == 3 || type == 9) {
                _v32 = 1;
            } else {
                _v32 = 0;
            }
            _v33 = _v32 & 255;
        } else {
            _v33 = (mode & 61440) == 16384;
        }
        if(_v33 == 0) {
            if(indicator_style != 1) {
                if(_v24 == 0) {
                    _v27 = type == 6;
                } else {
                    _v27 = (mode & 61440) == 40960;
                }
                if(_v27 == 0) {
                    if(_v24 == 0) {
                        _v26 = type == 1;
                    } else {
                        _v26 = (mode & 61440) == 4096;
                    }
                    if(_v26 == 0) {
                        if(_v24 == 0) {
                            _v25 = type == 7;
                        } else {
                            _v25 = (mode & 61440) == 49152;
                        }
                        if(_v25 == 0) {
                            c = 0;
                        } else {
                            c = 61;
                        }
                    } else {
                        c = 124;
                    }
                } else {
                    c = 64;
                }
            } else {
                c = 0;
            }
        } else {
            c = 47;
        }
    } else {
        if((_v24 & 255 ^ 1) != 0 || indicator_style != 3 || (mode & 73) == 0) {
            c = 0;
        } else {
            c = 42;
        }
    }
    return c & 255;
}

void print_type_indicator(_Bool stat_ok, mode_t mode, union filetype type)
{// addr = 0x08050368  --  defined in 'ls.c' at line 3913
    char c;                                // _cfa_fffffffb
    signed char _v24;                      // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v24 = stat_ok;
    c = get_type_indicator(_v24 & 255, mode, type);
    if(c != 0) {
         *__esp = c;
        putchar_unlocked();
        dired_pos = dired_pos + 1;
        return;
    }
}

void print_color_indicator(const char* name, mode_t mode, int linkok, _Bool stat_ok, union filetype filetype)
{// addr = 0x080503B2  --  defined in 'ls.c' at line 3922
    size_t len;         // _cfa_fffffff8
    struct color_ext_type* ext;   // _cfa_fffffff4
    int type;                              // _cfa_fffffff0
    signed char _v24;                      // _cfa_ffffffe8
    const struct bin_str* _v28;   // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    const char* _v40;   // _cfa_ffffffd8
    const struct bin_str* _t88;   // _t88
    unsigned int _t92;                     // _t92
    signed int _t104;                      // _t104

    _v24 = stat_ok;
    if(linkok != -1 ||  *134627900 == 0) {
        __eflags = _v24 & 255 ^ 1;
        if(__eflags == 0) {
            __eflags = (mode & 61440) - 32768;
            if((mode & 61440) != 32768) {
                __eflags = (mode & 61440) - 16384;
                if((mode & 61440) != 16384) {
                    __eflags = (mode & 61440) - 40960;
                    if((mode & 61440) != 40960) {
                        __eflags = (mode & 61440) - 4096;
                        if(__eflags != 0) {
                            __eflags = (mode & 61440) - 49152;
                            if(__eflags != 0) {
                                __eflags = (mode & 61440) - 24576;
                                if(__eflags != 0) {
                                    __eflags = (mode & 61440) - 8192;
                                    if(__eflags != 0) {
                                        type = 12;
                                    } else {
                                        type = 10;
                                    }
                                } else {
                                    type = 9;
                                }
                            } else {
                                type = 8;
                            }
                        } else {
                            type = 7;
                        }
                        goto L36;
                    }
                    __eflags = linkok;
                    if(__eflags != 0) {
L25:
                        _v32 = 6;
L26:
                        type = _v32;
                        goto L36;
                    }
                    __eflags =  *134627908;
                    if(__eflags == 0) {
                        goto L25;
                    } else {
                        _v32 = 12;
                        goto L26;
                    }
                }
                __eflags = mode & 512;
                if((mode & 512) == 0) {
L16:
                    __eflags = mode & 2;
                    if(__eflags == 0) {
                        __eflags = mode & 512;
                        if(__eflags == 0) {
                            type = 5;
                        } else {
                            type = 17;
                        }
                    } else {
                        type = 18;
                    }
                    goto L36;
                }
                __eflags = mode & 2;
                if(__eflags == 0) {
                    goto L16;
                } else {
                    type = 19;
                    goto L36;
                }
            } else {
                type = 4;
                __eflags = mode & 2048;
                if(__eflags == 0) {
                    __eflags = mode & 1024;
                    if(__eflags == 0) {
                        __eflags = mode & 73;
                        if(__eflags != 0) {
                            type = 13;
                        }
                    } else {
                        type = 16;
                    }
                } else {
                    type = 15;
                }
                goto L36;
            }
        } else {
            type =  *( &filetype_indicator + filetype * 4);
            goto L36;
        }
    } else {
        type = 11;
L36:
        ext = 0;
        if(type != 4) {
L42:
            put_indicator( &color_indicator);
            if(ext == 0) {
                _t88 =  &color_indicator + (type << 3);
                __eflags = _t88;
                _v28 = _t88;
            } else {
                _v28 =  &(ext->seq);
            }
            put_indicator(_v28);
            put_indicator(134627816);
            return;
        }
        _t92 = name;
         *__esp = _t92;
        strlen();
        len = _t92;
        name = name + len;
        ext = color_ext_list;
        while(ext != 0) {
            __eflags = ext->ext - len;
            if(__eflags > 0) {
L40:
                ext = ext->next;
                continue;
            }
            _t104 = name +  ~(ext->ext);
            _v36 = ext->ext;
            _v40 = ext->ext.string;
             *__esp = _t104;
            strncmp();
            __eflags = _t104;
            if(__eflags == 0) {
                goto L42;
            }
            goto L40;
        }
        goto L42;
    }
}

void put_indicator(const struct bin_str* ind)
{// addr = 0x0805060F  --  defined in 'ls.c' at line 4004
    const char* p;   // _cfa_fffffff8
    size_t i;           // _cfa_fffffff4

    p = ind->string;
    i = ind->len;
    while(i != 0) {
        p =  &(p[1]);
         *__esp =  *p & 255;
        putchar_unlocked();
        i = i - 1;
    }
}

size_t length_of_file_name_and_frills(const struct fileinfo* f)
{// addr = 0x08050649  --  defined in 'ls.c' at line 4016
    char c;                                // _cfa_ffffffef
    size_t len;         // _cfa_ffffffe8
    size_t name_width;   // _cfa_ffffffe4
    char[651] buf;                         // _cfa_fffffd58
    char* _v692;                           // _cfa_fffffd4c
    int _v696;                             // _cfa_fffffd48
    char* _v700;                           // _cfa_fffffd44
    char* _v704;                           // _cfa_fffffd40
    intOrPtr _v720;                        // _cfa_fffffd30
    long long unsigned int _v724;          // _cfa_fffffd2c
    FILE* _v728;          // _cfa_fffffd28
    intOrPtr _v732;                        // _cfa_fffffd24
    int _v736;                             // _cfa_fffffd20 (outparam)
    char[651]* _v740;                      // _cfa_fffffd1c (outparam)
    intOrPtr _v744;                        // _cfa_fffffd18 (outparam)
    char* _t81;                            // _t81
    const struct fileinfo* _t88;   // _t88
    char* _t92;                            // _t92
    const struct fileinfo* _t98;   // _t98
    char* _t100;                           // _t100

    len = 0;
    if((print_inode & 255) != 0) {
        if(format != 4) {
            _v704 = inode_number_width + 1;
        } else {
            _t98 = f;
            _v740 =  &buf;
             *__esp = _t98->stat.st_ino;
            _v744 = _t98->stat.st_ino;
            _t100 = umaxtostr();
             *__esp = _t100;
            strlen();
            _v704 =  &(_t100[1]);
        }
        len =  &(_v704[len]);
    }
    if((print_block_size & 255) != 0) {
        if(format != 4) {
            _v700 = block_size_width + 1;
        } else {
            _v696 = human_output_opts;
            _t88 = f;
            _v724 = output_block_size;
            _v720 =  *134628524;
            _v732 = 512;
            _v728 = 0;
            _v736 = _v696;
            _v740 =  &buf;
             *__esp = _t88->stat.st_blocks;
            _v744 = _t88->stat.st_blocks;
            _t92 = human_readable();
             *__esp = _t92;
            strlen();
            _v700 =  &(_t92[1]);
        }
        len =  &(_v700[len]);
    }
    if((print_scontext & 255) != 0) {
        if(format != 4) {
            _v692 = scontext_width + 1;
        } else {
            _t81 = f->scontext;
             *__esp = _t81;
            strlen();
            _v692 =  &(_t81[1]);
        }
        len =  &(_v692[len]);
    }
    quote_name(0, f->name, filename_quoting_options,  &name_width);
    len = len + name_width;
    if(indicator_style != 0) {
        c = get_type_indicator(f->stat_ok & 0xff, f->stat.st_mode, f->filetype);
        len = len + (c != 0 & 255);
    }
    return len;
}

void print_many_per_line()
{// addr = 0x08050817  --  defined in 'ls.c' at line 4050
    size_t max_name_length;   // _cfa_fffffff8
    size_t name_length;   // _cfa_fffffff4
    const struct fileinfo* f;   // _cfa_fffffff0
    size_t pos;         // _cfa_ffffffec
    size_t filesno;     // _cfa_ffffffe8
    size_t col;         // _cfa_ffffffe4
    size_t rows;        // _cfa_ffffffe0
    const struct column_info* line_fmt;   // _cfa_ffffffdc
    size_t cols;        // _cfa_ffffffd8
    size_t row;         // _cfa_ffffffd4
    signed int _v64;                       // _cfa_ffffffc0
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    cols = calculate_columns(1);
    line_fmt = column_info + (cols + cols + _t95 << 2) - 12;
    _v64 = cwd_n_used;
    rows = cwd_n_used / cols + (_v64 % cols != 0 & 255);
    row = 0;
    while(row < rows) {
        col = 0;
        filesno = row;
        pos = 0;
        while(1) {
            f = sorted_file[filesno];
            name_length = length_of_file_name_and_frills(f);
            max_name_length =  *(line_fmt->col_arr + (col << 2));
            col = col + 1;
            print_file_name_and_frills(f);
            filesno = filesno + rows;
            if(filesno >= cwd_n_used) {
                break;
            }
            indent(pos + name_length, pos + max_name_length);
            pos = pos + max_name_length;
        }
         *__esp = 10;
        putchar_unlocked();
        row = row + 1;
    }
}

void print_horizontal()
{// addr = 0x08050931  --  defined in 'ls.c' at line 4086
    size_t col;         // _cfa_fffffff8
    size_t max_name_length;   // _cfa_fffffff4
    size_t name_length;   // _cfa_fffffff0
    const struct fileinfo* f;   // _cfa_ffffffec
    const struct column_info* line_fmt;   // _cfa_ffffffe8
    size_t cols;        // _cfa_ffffffe4
    size_t pos;         // _cfa_ffffffe0
    size_t filesno;     // _cfa_ffffffdc
    signed int _v44;                       // _cfa_ffffffd4
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    pos = 0;
    cols = calculate_columns(0);
    line_fmt = column_info + (cols + cols + _t86 << 2) - 12;
    f =  *sorted_file;
    name_length = length_of_file_name_and_frills(f);
    max_name_length = line_fmt;
    print_file_name_and_frills(f);
    filesno = 1;
    while(filesno < cwd_n_used) {
        _v44 = filesno;
        col = _v44 % cols;
        if(col != 0) {
            indent(pos + name_length, pos + max_name_length);
            pos = pos + max_name_length;
        } else {
             *__esp = 10;
            putchar_unlocked();
            pos = 0;
        }
        f = sorted_file[filesno];
        print_file_name_and_frills(f);
        name_length = length_of_file_name_and_frills(f);
        max_name_length =  *(line_fmt->col_arr + (col << 2));
        filesno = filesno + 1;
    }
     *__esp = 10;
    putchar_unlocked();
}

void print_with_commas()
{// addr = 0x08050A55  --  defined in 'ls.c' at line 4125
    char separator;                        // _cfa_fffffffb
    size_t len;         // _cfa_fffffff4
    const struct fileinfo* f;   // _cfa_fffffff0
    size_t pos;         // _cfa_ffffffec
    size_t filesno;     // _cfa_ffffffe8

    pos = 0;
    filesno = 0;
    while(filesno < cwd_n_used) {
        f = sorted_file[filesno];
        len = length_of_file_name_and_frills(f);
        if(filesno != 0) {
            if(pos + len + 2 >= line_length) {
                pos = 0;
                separator = 10;
            } else {
                pos = pos + 2;
                separator = 32;
            }
             *__esp = 44;
            putchar_unlocked();
             *__esp = separator;
            putchar_unlocked();
        }
        print_file_name_and_frills(f);
        pos = pos + len;
        filesno = filesno + 1;
    }
     *__esp = 10;
    putchar_unlocked();
}

void indent(size_t from, size_t to)
{// addr = 0x08050B05  --  defined in 'ls.c' at line 4164
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebx;                       // r1

    while(from < to) {
        if(tabsize == 0) {
L4:
             *__esp = 32;
            putchar_unlocked();
            from = from + 1;
        } else {
            _v28 = tabsize;
            _v28 = from + 1;
            _v24 = tabsize;
            _v24 = _v28 / _v24;
            if(to / _v28 <= _v24) {
                goto L4;
            } else {
                 *__esp = 9;
                putchar_unlocked();
                _v24 = from;
                from = from + tabsize - _v24 % tabsize;
            }
        }
    }
}

void attach(char* dest, const char* dirname, const char* name)
{// addr = 0x08050BAF  --  defined in 'ls.c' at line 4186
    const char* dirnamep;   // _cfa_fffffff8

    dirnamep = dirname;
    if(( *dirname & 255) != 46 || (dirname[1] & 255) != 0) {
        do {
        } while(( *dirnamep & 255) != 0);
        if(dirnamep > dirname && ( *(dirnamep - 1) & 255) != 47) {
             *dest = 47;
            dest =  &(dest[1]);
        }
        goto L9;
    } else {
L9:
        while(( *name & 255) != 0) {
             *dest =  *name & 255;
            dest =  &(dest[1]);
            name =  &(name[1]);
        }
         *dest = 0;
        return;
    }
}

void init_column_info()
{// addr = 0x08050C37  --  defined in 'ls.c' at line 4209
    size_t j;           // _cfa_fffffff8
    size_t t;           // _cfa_fffffff4
    size_t s;           // _cfa_fffffff0
    size_t column_info_growth;   // _cfa_ffffffec
    size_t* p;          // _cfa_ffffffe8
    size_t new_column_info_alloc;   // _cfa_ffffffe4
    size_t max_cols;    // _cfa_ffffffe0
    size_t i;           // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)

    _v40 = max_idx;
    _v44 = cwd_n_used;
    if(_v44 > _v40) {
        _v44 = _v40;
    }
    max_cols = _v44;
    if(column_info_alloc >= max_cols) {
L13:
        i = 0;
        while(i < max_cols) {
             *((char*)(column_info + (i + i + _t139 << 2))) = 1;
            _t140 = i;
             *((intOrPtr*)(column_info + (i + _t140 + _t140 << 2) + 4)) = i + 1 + i + 1 + _t141;
            j = 0;
            while(j <= i) {
                 *((intOrPtr*)( *((intOrPtr*)(column_info + (i + i + _t142 << 2) + 8)) + (j << 2))) = 3;
                j = j + 1;
            }
            i = i + 1;
        }
        return;
    } else {
        if(max_idx >> 1 <= max_cols) {
            column_info = xnrealloc(column_info, max_idx, 12);
            new_column_info_alloc = max_idx;
        } else {
            column_info = xnrealloc(column_info, max_cols, 24);
            new_column_info_alloc = max_cols + max_cols;
        }
        column_info_growth = new_column_info_alloc - column_info_alloc;
        s = column_info_alloc + new_column_info_alloc + 1;
        t = s * column_info_growth;
        if(s < new_column_info_alloc || t / column_info_growth != s) {
            xalloc_die();
        }
        p = xnmalloc(t >> 1, 4);
        i = column_info_alloc;
        while(i < new_column_info_alloc) {
             *(column_info + (i + i + _t146 << 2) + 8) = p;
            p = p + (i + 1 << 2);
            i = i + 1;
        }
        column_info_alloc = new_column_info_alloc;
        goto L13;
    }
}

size_t calculate_columns(_Bool by_columns)
{// addr = 0x08050E06  --  defined in 'ls.c' at line 4277
    size_t real_length;   // _cfa_fffffff0
    size_t idx;         // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    size_t name_length;   // _cfa_ffffffe4
    const struct fileinfo* f;   // _cfa_ffffffe0
    size_t max_cols;    // _cfa_ffffffdc
    size_t cols;        // _cfa_ffffffd8
    size_t filesno;     // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    unsigned int _v60;                     // _cfa_ffffffc4
    unsigned int _v64;                     // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    _unknown_ __ebx;                       // r1

    _v48 = by_columns;
    _v60 = max_idx;
    _v64 = cwd_n_used;
    if(_v64 > _v60) {
        _v64 = _v60;
    }
    max_cols = _v64;
    init_column_info();
    filesno = 0;
    while(filesno < cwd_n_used) {
        f = sorted_file[filesno];
        name_length = length_of_file_name_and_frills(f);
        i = 0;
        while(i < max_cols) {
            if(( *(column_info + (i + i + _t214 << 2)) & 255) != 0) {
                if(_v48 == 0) {
                    _v84 = filesno;
                    _v56 = _v84 % (i + 1);
                } else {
                    _v80 = i + cwd_n_used;
                    _v84 = i + 1;
                    _v84 = _v80 / _v84;
                    _v80 = _v84;
                    _v56 = filesno / _v80;
                }
                idx = _v56;
                if(idx != i) {
                    _v52 = 2;
                } else {
                    _v52 = 0;
                }
                real_length = _v52 + name_length;
                if( *((intOrPtr*)( *((intOrPtr*)(column_info + (i + i + _t219 << 2) + 8)) + (idx << 2))) < real_length) {
                    _t221 = i;
                    _t222 = i;
                     *((intOrPtr*)(column_info + (i + _t221 + _t221 << 2) + 4)) =  *((intOrPtr*)(column_info + (i + _t222 + _t222 << 2) + 4)) + real_length -  *((intOrPtr*)( *((intOrPtr*)(column_info + (i + i + _t223 << 2) + 8)) + (idx << 2)));
                     *( *((intOrPtr*)(column_info + (i + i + _t226 << 2) + 8)) + (idx << 2)) = real_length;
                    _t229 = i;
                     *((char*)(column_info + (i + _t229 + _t229 << 2))) =  *((intOrPtr*)(column_info + (i + i + _t230 << 2) + 4)) - line_length > 0;
                }
            }
            i = i + 1;
        }
        filesno = filesno + 1;
    }
    cols = max_cols;
    while(cols > 1) {
        if(( *(column_info + (cols + cols + _t215 << 2) - 12) & 255) != 0) {
            break;
        }
        cols = cols - 1;
    }
    return cols;
}

void usage(int status)
{// addr = 0x0805105C  --  defined in 'ls.c' at line 4328
    char* _v20;                            // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    int _t33;                              // _t33
    _unknown_ _t62;                        // _t62

    _push(__ebx);
    __esp = __esp - 20;
    if(status == 0) {
         *__esp = "Usage: %s [OPTION]... [FILE]...\n";
        gettext();
        _v24 = program_name;
         *__esp = __eax;
        printf();
         *__esp = "List information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort.\n\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "Mandatory arguments to long options are mandatory for short options too.\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print octal escapes for nongraphic characters\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "      --block-size=SIZE      use SIZE-byte blocks\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information)\n                               with -l: show ctime and sort by name\n                               otherwise: sort by ctime\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -C                         list entries by columns\n      --color[=WHEN]         control whether color is used to distinguish file\n                               types.  WHEN may be `never', `always', or `auto'\n  -d, --directory            list directory entries instead of contents,\n                               and do not dereference symbolic links\n  -D, --dired                generate output designed for Emacs' dired mode\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=>|) to entries\n      --file-type            likewise, except do not append `*'\n      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n                               single-column -1, verbose -l, vertical -C\n      --full-time            like -l --time-style=full-iso\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -g                         like -l, but do not list owner\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "      --group-directories-first\n                             group directories before files\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -G, --no-group             in a long listing, don't print group names\n  -h, --human-readable       with -l, print sizes in human readable format\n                               (e.g., 1K 234M 2G)\n      --si                   likewise, but use powers of 1000 not 1024\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -H, --dereference-command-line\n                             follow symbolic links listed on the command line\n      --dereference-command-line-symlink-to-dir\n                             follow each command line symbolic link\n                             that points to a directory\n      --hide=PATTERN         do not list implied entries matching shell PATTERN\n                               (overridden by -a or -A)\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "      --indicator-style=WORD  append indicator with style WORD to entry names:\n                               none (default), slash (-p),\n                               file-type (--file-type), classify (-F)\n  -i, --inode                print the index number of each file\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n  -k                         like --block-size=1K\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -l                         use a long listing format\n  -L, --dereference          when showing file information for a symbolic\n                               link, show information for the file the link\n                               references rather than for the link itself\n  -m                         fill width with a comma separated list of entries\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n  -N, --literal              print raw entry names (don't treat e.g. control\n                               characters specially)\n  -o                         like -l, but do not list group information\n  -p, --indicator-style=slash\n                             append / indicator to directories\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -q, --hide-control-chars   print ? instead of non graphic characters\n      --show-control-chars   show non graphic characters as-is (default\n                             unless program is `ls' and output is a terminal)\n  -Q, --quote-name           enclose entry names in double quotes\n      --quoting-style=WORD   use quoting style WORD for entry names:\n                               literal, locale, shell, shell-always, c, escape\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -r, --reverse              reverse order while sorting\n  -R, --recursive            list subdirectories recursively\n  -s, --size                 print the size of each file, in blocks\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -S                         sort by file size\n      --sort=WORD            sort by WORD instead of name: none -U,\n                             extension -X, size -S, time -t, version -v\n      --time=WORD            with -l, show time as WORD instead of modification\n                             time: atime -u, access -u, use -u, ctime -c,\n                             or status -c; use specified time as sort key\n                             if --sort=time\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "      --time-style=STYLE     with -l, show times using style STYLE:\n                             full-iso, long-iso, iso, locale, +FORMAT.\n                             FORMAT is interpreted like `date'; if FORMAT is\n                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n                             non-recent files and FORMAT2 to recent files;\n                             if STYLE is prefixed with `posix-', STYLE\n                             takes effect only outside the POSIX locale\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -t                         sort by modification time\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -u                         with -lt: sort by, and show, access time\n                               with -l: show access time and sort by name\n                               otherwise: sort by access time\n  -U                         do not sort; list entries in directory order\n  -v                         sort by version\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "  -w, --width=COLS           assume screen width instead of current value\n  -x                         list entries by lines instead of by columns\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any SELinux security context of each file\n  -1                         list one file per line\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "      --help     display this help and exit\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "      --version  output version information and exit\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "\nSIZE may be (or may be an integer optionally followed by) one of following:\nkB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "\nBy default, color is not used to distinguish types of files.  That is\nequivalent to using --color=none.  Using the --color option without the\noptional WHEN argument is equivalent to using --color=always.  With\n--color=auto, color codes are output only if standard output is connected\nto a terminal (tty).  The environment variable LS_COLORS can influence the\ncolors, and can be set easily by the dircolors command.\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
         *__esp = "\nExit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n";
        gettext();
        _v24 = __imp__stdout;
         *__esp = __eax;
        fputs_unlocked();
        L4();
    } else {
         *__esp = "Try `%s --help' for more information.\n";
        gettext();
        _v20 = program_name;
        _v24 = __eax;
         *__esp = __imp__stderr;
        fprintf();
    }
    _t33 = status;
     *__esp = _t33;
    exit();
    _push(_t62);
    __esp = __esp - 8;
     *__esp = "\nReport bugs to <%s>.\n";
    gettext();
    _v36 = "bug-coreutilsgnu.org";
     *__esp = _t33;
    printf();
}

void emit_bug_reporting_address()
{// addr = 0x080513B2  --  defined in 'system.h' at line 575
    char* _v8;                             // _cfa_fffffff8

    __eax = __eax;
     *__esp = "\nReport bugs to <%s>.\n";
    gettext();
    _v8 = "bug-coreutilsgnu.org";
     *__esp = __eax;
    printf();
}

char* areadlink_with_size(const char* file, size_t size)
{// addr = 0x080513D8  --  defined in 'areadlink-with-size.c' at line 57
    size_t symlink_max;   // _cfa_fffffff8
    size_t INITIAL_LIMIT_BOUND;   // _cfa_fffffff4
    size_t initial_limit;   // _cfa_fffffff0
    size_t buf_size;    // _cfa_ffffffec
    ssize_t r;         // _cfa_ffffffe8
    size_t link_length;   // _cfa_ffffffe4
    char* buffer;                          // _cfa_ffffffe0
    int saved_errno;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _t57;                            // _t57
    int _t60;                              // _t60
    unsigned int _t61;                     // _t61
    char* _t63;                            // _t63
    int* _t68;                             // _t68
    char* _t70;                            // _t70

    symlink_max = 1024;
    INITIAL_LIMIT_BOUND = 8192;
    if(symlink_max >= INITIAL_LIMIT_BOUND) {
        _v48 = INITIAL_LIMIT_BOUND;
    } else {
        _v48 = symlink_max + 1;
    }
    initial_limit = _v48;
    if(size >= initial_limit) {
        _v44 = initial_limit;
    } else {
        _v44 = size + 1;
    }
    buf_size = _v44;
    while(1) {
        _t57 = buf_size;
         *__esp = _t57;
        malloc();
        buffer = _t57;
        if(buffer == 0) {
            break;
        }
        _v52 = buf_size;
        _v56 = buffer;
        _t60 = file;
         *__esp = _t60;
        readlink();
        r = _t60;
        _t61 = r;
        link_length = _t61;
        if(r >= 0) {
L12:
            if(link_length >= buf_size) {
                _t63 = buffer;
                 *__esp = _t63;
                free();
                if(buf_size > 1073741823) {
                    if(buf_size > 2147483646) {
                        __errno_location();
                         *_t63 = 12;
                        _v40 = 0;
                    } else {
                        buf_size = 2147483647;
                        continue;
                    }
                } else {
                    buf_size = buf_size << 1;
                    continue;
                }
            } else {
                buffer[link_length] = 0;
                _v40 = buffer;
            }
        } else {
            __errno_location();
            _t68 =  *_t61;
            if(_t68 == 34) {
                goto L12;
            } else {
                __errno_location();
                saved_errno =  *_t68;
                _t70 = buffer;
                 *__esp = _t70;
                free();
                __errno_location();
                 *_t70 = saved_errno;
                _v40 = 0;
            }
        }
L19:
        return _v40;
    }
    _v40 = 0;
    goto L19;
}

int gnu_mbswidth(const _None* string, int flags)
{// addr = 0x0805150C  --  defined in 'mbswidth.c' at line 52
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    unsigned int _t6;                      // _t6

    _t6 = string;
     *__esp = _t6;
    strlen();
    return mbsnwidth(string, _t6, flags);
}

int mbsnwidth(const _None* string, size_t nbytes, int flags)
{// addr = 0x08051537  --  defined in 'mbswidth.c' at line 63
    unsigned char c;                       // _cfa_fffffffb
    const _None* p;   // _cfa_fffffff4
    const _None* plimit;   // _cfa_fffffff0
    int width;                             // _cfa_ffffffec
    wchar_t wc;        // _cfa_ffffffe8
    size_t bytes;       // _cfa_ffffffe4
    int w;                                 // _cfa_ffffffe0
    mbstate_t mbstate;   // _cfa_ffffffd8
    int _v56;                              // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    struct * _v64;            // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    const _None* _v72;   // _cfa_ffffffb8
    const _None* _t87;   // _t87
    unsigned char _t90;                    // _t90
    signed int _t98;                       // _t98
    int _t120;                             // _t120
    int _t123;                             // _t123

    p = string;
    _t87 = p + nbytes;
    plimit = _t87;
    width = 0;
    __ctype_get_mb_cur_max();
    if(_t87 <= 1) {
        while(p < plimit) {
            _t90 =  *p & 255;
            c = _t90;
            p =  &(p[1]);
            __ctype_b_loc();
            if(( *( *_t90 + (c & 255) + (c & 255)) & 0x4000) == 0) {
                _t98 = flags & 2;
                if(_t98 != 0) {
                    _v56 = -1;
                } else {
                    __ctype_b_loc();
                    width = width + (( *( *_t98 + (c & 255) + (c & 255)) & 2) == 0 & 255);
                    continue;
                }
            } else {
                width = width + 1;
                continue;
            }
            goto L36;
        }
        _v56 = width;
    } else {
L27:
        while(p < plimit) {
            _v60 =  *p & 255;
            if(_v60 > 95) {
                if(_v60 - 97 > 29) {
                    goto L10;
                } else {
                    goto L9;
                }
            } else {
                if(_v60 >= 65) {
L9:
                    p =  &(p[1]);
                    width = width + 1;
                    continue;
                } else {
                    if(_v60 < 32) {
L10:
                        _v68 = 8;
                        _v72 = 0;
                         *__esp =  &mbstate;
                        memset();
                        while(1) {
                            _v64 =  &mbstate;
                            _v68 = plimit - p;
                            _v72 = p;
                             *__esp =  &wc;
                            mbrtowc();
                            bytes =  &wc;
                            if(bytes == -1) {
                                break;
                            }
                            if(bytes != -2) {
                                if(bytes == 0) {
                                    bytes = 1;
                                }
                                _t120 = wc;
                                 *__esp = _t120;
                                wcwidth();
                                w = _t120;
                                if(w < 0) {
                                    if((flags & 2) != 0) {
                                        _v56 = -1;
                                    } else {
                                        _t123 = wc;
                                         *__esp = _t123;
                                        iswcntrl();
                                        width = width + (_t123 == 0 & 255);
                                        goto L26;
                                    }
                                } else {
                                    width = width + w;
L26:
                                    p = p + bytes;
                                     *__esp =  &mbstate;
                                    mbsinit();
                                    if( &mbstate == 0) {
                                        continue;
                                    } else {
                                        goto L27;
                                    }
                                }
                            } else {
                                if((flags & 1) != 0) {
                                    _v56 = -1;
                                } else {
                                    p = plimit;
                                    width = width + 1;
                                    goto L27;
                                }
                            }
                            goto L36;
                        }
                        if((flags & 1) != 0) {
                            _v56 = -1;
                        } else {
                            p =  &(p[1]);
                            width = width + 1;
                            continue;
                        }
                    } else {
                        if(_v60 <= 35) {
                            goto L9;
                        } else {
                            if(_v60 - 37 > 26) {
                                goto L10;
                            } else {
                                goto L9;
                            }
                        }
                    }
                }
            }
            goto L36;
        }
        _v56 = width;
    }
L36:
    return _v56;
}

void version_etc_va(FILE* stream, const char* command_name, const char* package, const char* version, va_list authors)
{// addr = 0x08051750  --  defined in 'version-etc.c' at line 43
    size_t n_authors;   // _cfa_fffffff4
    va_list tmp_authors;   // _cfa_fffffff0
    const char* _v28;   // _cfa_ffffffe4
    const char* _v32;   // _cfa_ffffffe0
    const char* _v36;   // _cfa_ffffffdc (outparam)
    const char* _v40;   // _cfa_ffffffd8 (outparam)
    FILE* _t43;           // _t43
    FILE* _t44;           // _t44
    const char* _t45;   // _t45
    intOrPtr* _t53;                        // _t53

    tmp_authors = authors;
    n_authors = 0;
    while(1) {
        _t53 = tmp_authors;
        tmp_authors = _t53 + 4;
        if( *_t53 == 0) {
            break;
        }
        n_authors = n_authors + 1;
    }
    if(command_name == 0) {
        _v32 = version;
        _v36 = package;
        _v40 = "%s %s\n";
        _t43 = stream;
         *__esp = _t43;
        fprintf();
    } else {
        _v28 = version;
        _v32 = package;
        _v36 = command_name;
        _v40 = "%s (%s) %s\n";
        _t43 = stream;
         *__esp = _t43;
        fprintf();
    }
     *__esp = "(C)";
    gettext();
    _v32 = 2008;
    _v36 = _t43;
    _v40 = "Copyright %s %d Free Software Foundation, Inc.";
    _t44 = stream;
     *__esp = _t44;
    fprintf();
     *__esp = "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n";
    gettext();
    _t45 = stream;
    _v40 = _t45;
     *__esp = _t44;
    fputs_unlocked();
    if(n_authors <= 9) {
        _t45 =  *((n_authors << 2) + 134616936);
        goto __eax;
    }
     *__esp = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
    gettext();
    rpl_vfprintf(stream, _t45, authors);
}

void version_etc(FILE* stream, const char* command_name, const char* package, const char* version)
{// addr = 0x080519AF  --  defined in 'version-etc.c' at line 167
    va_list authors;   // _cfa_fffffff8
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    authors =  &_a20;
    version_etc_va(stream, command_name, package, version, authors);
}

void xalloc_die()
{// addr = 0x080519E4  --  defined in 'xalloc-die.c' at line 33
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t4;                         // _t4

    __eax = __eax;
     *__esp = "memory exhausted";
    gettext();
    _v16 = __eax;
    _v20 = "%s";
    _v24 = 0;
     *__esp = exit_failure;
    error();
    abort();
    _push(_t4);
    __esp = __esp - 8;
    usage(1);
}

void __argmatch_die()
{// addr = 0x08051A20  --  defined in 'argmatch.c' at line 62
    usage(1);
}

ptrdiff_t argmatch(const char* arg, const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051A34  --  defined in 'argmatch.c' at line 85
    _Bool ambiguous;                       // _cfa_fffffffb
    size_t i;           // _cfa_fffffff4
    size_t arglen;      // _cfa_fffffff0
    ptrdiff_t matchind;   // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    unsigned int _v36;                     // _cfa_ffffffdc
    const char* _v40;   // _cfa_ffffffd8
    unsigned int _t40;                     // _t40
    const char* _t49;   // _t49
    unsigned int _t53;                     // _t53
    unsigned int _t58;                     // _t58

    matchind = -1;
    ambiguous = 0;
    _t40 = arg;
     *__esp = _t40;
    strlen();
    arglen = _t40;
    i = 0;
    while( *(arglist + (i << 2)) != 0) {
        _v36 = arglen;
        _t49 = arg;
        _v40 = _t49;
         *__esp =  *(arglist + (i << 2));
        strncmp();
        if(_t49 != 0) {
L9:
            i = i + 1;
            continue;
        }
        _t53 =  *(arglist + (i << 2));
         *__esp = _t53;
        strlen();
        if(_t53 != arglen) {
            if(matchind != -1) {
                if(vallist == 0) {
L8:
                    ambiguous = 1;
                    goto L9;
                }
                _t58 = valsize;
                _v36 = _t58;
                _v40 = vallist + valsize * i;
                 *__esp = vallist + matchind * valsize;
                memcmp();
                if(_t58 == 0) {
                    goto L9;
                }
                goto L8;
            }
            matchind = i;
            goto L9;
        }
        _v24 = i;
L14:
        return _v24;
    }
    if(ambiguous == 0) {
        _v24 = matchind;
    } else {
        _v24 = -2;
    }
    goto L14;
}

void argmatch_invalid(const char* context, const char* value, ptrdiff_t problem)
{// addr = 0x08051B1C  --  defined in 'argmatch.c' at line 131
    const char* format;   // _cfa_fffffff4
    const char* _v28;   // _cfa_ffffffe4
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    const char* _v52;   // _cfa_ffffffcc (outparam)
    int _v56;                              // _cfa_ffffffc8 (outparam)
    const _None* _t19;   // _t19
    char* _t21;                            // _t21

    if(problem != -1) {
         *__esp = "ambiguous argument %s for %s";
        gettext();
        _v28 = __eax;
    } else {
         *__esp = "invalid argument %s for %s";
        gettext();
        _v28 = __eax;
    }
    format = _v28;
    _t19 = quote_n(1, context);
    _t21 = quotearg_n_style(0, 5, value);
    _v44 = _t19;
    _v48 = _t21;
    _v52 = format;
    _v56 = 0;
     *__esp = 0;
    error();
}

void argmatch_valid(const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051BA8  --  defined in 'argmatch.c' at line 147
    size_t i;           // _cfa_fffffff8
    const char* last_val;   // _cfa_fffffff4
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    const char* _t44;   // _t44

    last_val = 0;
     *__esp = "Valid arguments are:";
    gettext();
    _v40 = __eax;
     *__esp = __imp__stderr;
    fprintf();
    i = 0;
    while( *((intOrPtr*)(arglist + (i << 2))) != 0) {
        if(i == 0) {
L3:
            _v36 =  *((intOrPtr*)(arglist + (i << 2)));
            _v40 = "\n  - `%s'";
             *__esp = __imp__stderr;
            fprintf();
            last_val = vallist + valsize * i;
        } else {
            _v36 = valsize;
            _v40 = vallist + valsize * i;
            _t44 = last_val;
             *__esp = _t44;
            memcmp();
            if(_t44 == 0) {
                _v36 =  *((intOrPtr*)(arglist + (i << 2)));
                _v40 = ", `%s'";
                 *__esp = __imp__stderr;
                fprintf();
            } else {
                goto L3;
            }
        }
        i = i + 1;
    }
    _v40 = __imp__stderr;
     *__esp = 10;
    putc_unlocked();
}

ptrdiff_t __xargmatch_internal(const char* context, const char* arg, const const char** arglist, const char* vallist, size_t valsize, argmatch_exit_fn exit_fn)
{// addr = 0x08051C92  --  defined in 'argmatch.c' at line 179
    ptrdiff_t res;   // _cfa_fffffff8
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    res = argmatch(arg, arglist, vallist, valsize);
    if(res < 0) {
        argmatch_invalid(context, arg, res);
        argmatch_valid(arglist, vallist, valsize);
         *exit_fn();
        _v24 = -1;
    } else {
        _v24 = res;
    }
    return _v24;
}

const char* argmatch_to_argument(const char* value, const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051D0C  --  defined in 'argmatch.c' at line 199
    size_t i;           // _cfa_fffffff8
    const char* _v24;   // _cfa_ffffffe8
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    const char* _t25;   // _t25

    i = 0;
    while( *(arglist + (i << 2)) != 0) {
        _v36 = valsize;
        _v40 = vallist + valsize * i;
        _t25 = value;
         *__esp = _t25;
        memcmp();
        if(_t25 != 0) {
            i = i + 1;
            continue;
        } else {
            _v24 =  *(arglist + (i << 2));
        }
L6:
        return _v24;
    }
    _v24 = 0;
    goto L6;
}

char* last_component(const _None* name)
{// addr = 0x08051D70  --  defined in 'basename.c' at line 33
    _Bool saw_slash;                       // _cfa_fffffffb
    const _None* base;   // _cfa_fffffff4
    const _None* p;   // _cfa_fffffff0

    base = name;
    saw_slash = 0;
    while(( *base & 255) == 47) {
        base =  &(base[1]);
    }
    p = base;
    while(( *p & 255) != 0) {
        if(( *p & 255) != 47) {
            if(saw_slash != 0) {
                base = p;
                saw_slash = 0;
            }
        } else {
            saw_slash = 1;
        }
        p =  &(p[1]);
    }
    return base;
}

char* base_name(const _None* name)
{// addr = 0x08051DCB  --  defined in 'basename.c' at line 75
    const _None* base;   // _cfa_fffffff8
    size_t length;      // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    base = last_component(name);
    if(( *base & 255) != 0) {
        length = base_len(base);
        if(( *(base + length) & 255) == 47) {
            length = length + 1;
        }
        _v24 = xstrndup(base, length);
    } else {
        _v24 = xstrndup(name, base_len(name));
    }
    return _v24;
}

size_t base_len(const _None* name)
{// addr = 0x08051E43  --  defined in 'basename.c' at line 112
    size_t len;         // _cfa_fffffff8
    size_t prefix_len;   // _cfa_fffffff4
    unsigned int _t10;                     // _t10

    prefix_len = 0;
    _t10 = name;
     *__esp = _t10;
    strlen();
    len = _t10;
    while(len > 1 && ( *(name + len - 1) & 255) == 47) {
        len = len - 1;
    }
    return len;
}

void close_stdout_set_file_name(const char* file)
{// addr = 0x08051E80  --  defined in 'closeout.c' at line 41
    file_name = file;
}

void close_stdout()
{// addr = 0x08051E8D  --  defined in 'closeout.c' at line 70
    const char* write_error;   // _cfa_fffffff4
    const char* _v28;   // _cfa_ffffffe4
    const char* _v32;   // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    const char* _t12;   // _t12
    const char* _t16;   // _t16
    const char* _t20;   // _t20

    _t12 = close_stream(__imp__stdout);
    if(_t12 != 0) {
         *__esp = "write error";
        gettext();
        write_error = _t12;
        _t16 = file_name;
        if(_t16 == 0) {
            __errno_location();
            _v32 = write_error;
            _v36 = "%s";
            _v40 =  *_t16;
             *__esp = 0;
            error();
        } else {
            _t20 = quotearg_colon(file_name);
            __errno_location();
            _v28 = write_error;
            _v32 = _t20;
            _v36 = "%s: %s";
            _v40 =  *_t20;
             *__esp = 0;
            error();
        }
         *__esp = exit_failure;
        _exit();
    }
    if(close_stream(__imp__stderr) != 0) {
         *__esp = exit_failure;
        _exit();
        return;
    }
}

int file_has_acl(const char* name, const struct stat* sb)
{// addr = 0x08051F54  --  defined in 'file-has-acl.c' at line 32
    return 0;
}

char ftypelet(mode_t bits)
{// addr = 0x08051F60  --  defined in 'filemode.c' at line 55
    signed char _v5;                       // _cfa_fffffffb

    if((bits & 61440) != 32768) {
        if((bits & 61440) != 16384) {
            if((bits & 61440) != 24576) {
                if((bits & 61440) != 8192) {
                    if((bits & 61440) != 40960) {
                        if((bits & 61440) != 4096) {
                            if((bits & 61440) != 49152) {
                                _v5 = 63;
                            } else {
                                _v5 = 115;
                            }
                        } else {
                            _v5 = 112;
                        }
                    } else {
                        _v5 = 108;
                    }
                } else {
                    _v5 = 99;
                }
            } else {
                _v5 = 98;
            }
        } else {
            _v5 = 100;
        }
    } else {
        _v5 = 45;
    }
    return _v5 & 255;
}

void strmode(mode_t mode, char* str)
{// addr = 0x08052006  --  defined in 'filemode.c' at line 97
    signed char _v5;                       // _cfa_fffffffb
    signed char _v6;                       // _cfa_fffffffa
    signed char _v7;                       // _cfa_fffffff9
    char* _v12;                            // _cfa_fffffff4
    signed char _v13;                      // _cfa_fffffff3
    char* _v20;                            // _cfa_ffffffec
    signed char _v21;                      // _cfa_ffffffeb
    char* _v28;                            // _cfa_ffffffe4
    signed char _v29;                      // _cfa_ffffffe3
    signed char _v30;                      // _cfa_ffffffe2
    signed char _v31;                      // _cfa_ffffffe1
    char* _v36;                            // _cfa_ffffffdc
    signed char _v37;                      // _cfa_ffffffdb
    char* _v44;                            // _cfa_ffffffd4
    signed char _v45;                      // _cfa_ffffffd3
    char* _v52;                            // _cfa_ffffffcc
    signed char _v53;                      // _cfa_ffffffcb
    signed char _v54;                      // _cfa_ffffffca
    signed char _v55;                      // _cfa_ffffffc9
    char* _v60;                            // _cfa_ffffffc4
    signed char _v61;                      // _cfa_ffffffc3
    char* _v68;                            // _cfa_ffffffbc
    signed char _v69;                      // _cfa_ffffffbb
    char* _v76;                            // _cfa_ffffffb4

     *str = ftypelet(mode);
    _v76 =  &(str[1]);
    if((mode & 256) == 0) {
        _v69 = 45;
    } else {
        _v69 = 114;
    }
     *_v76 = _v69 & 255;
    _v68 =  &(str[2]);
    if((mode & 128) == 0) {
        _v61 = 45;
    } else {
        _v61 = 119;
    }
     *_v68 = _v61 & 255;
    _v60 =  &(str[3]);
    if((mode & 2048) == 0) {
        __eflags = mode & 64;
        if(__eflags == 0) {
            _v53 = 45;
        } else {
            _v53 = 120;
        }
        _v55 = _v53 & 255;
    } else {
        if((mode & 64) == 0) {
            _v54 = 83;
        } else {
            _v54 = 115;
        }
        _v55 = _v54 & 255;
    }
     *_v60 = _v55 & 255;
    _v52 =  &(str[4]);
    if((mode & 32) == 0) {
        _v45 = 45;
    } else {
        _v45 = 114;
    }
     *_v52 = _v45 & 255;
    _v44 =  &(str[5]);
    if((mode & 16) == 0) {
        _v37 = 45;
    } else {
        _v37 = 119;
    }
     *_v44 = _v37 & 255;
    _v36 =  &(str[6]);
    if((mode & 1024) == 0) {
        __eflags = mode & 8;
        if(__eflags == 0) {
            _v29 = 45;
        } else {
            _v29 = 120;
        }
        _v31 = _v29 & 255;
    } else {
        if((mode & 8) == 0) {
            _v30 = 83;
        } else {
            _v30 = 115;
        }
        _v31 = _v30 & 255;
    }
     *_v36 = _v31 & 255;
    _v28 =  &(str[7]);
    if((mode & 4) == 0) {
        _v21 = 45;
    } else {
        _v21 = 114;
    }
     *_v28 = _v21 & 255;
    _v20 =  &(str[8]);
    if((mode & 2) == 0) {
        _v13 = 45;
    } else {
        _v13 = 119;
    }
     *_v20 = _v13 & 255;
    _v12 =  &(str[9]);
    if((mode & 512) == 0) {
        __eflags = mode & 1;
        if(__eflags == 0) {
            _v5 = 45;
        } else {
            _v5 = 120;
        }
        _v7 = _v5 & 255;
    } else {
        if((mode & 1) == 0) {
            _v6 = 84;
        } else {
            _v6 = 116;
        }
        _v7 = _v6 & 255;
    }
     *_v12 = _v7 & 255;
    str[0xa] = 32;
    str[0xb] = 0;
}

void filemodestring(const struct stat* statp, char* str)
{// addr = 0x0805221C  --  defined in 'filemode.c' at line 167
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    strmode(statp->st_mode, str);
}

const _None* longest_relative_suffix(const _None* f)
{// addr = 0x0805223C  --  defined in 'filenamecat.c' at line 40
    while(( *f & 255) == 47) {
        f =  &(f[1]);
    }
    return f;
}

char* mfile_name_concat(const _None* dir, const _None* abase, char** base_in_result)
{// addr = 0x08052254  --  defined in 'filenamecat.c' at line 63
    const _None* dirbase;   // _cfa_fffffff8
    size_t dirbaselen;   // _cfa_fffffff4
    size_t dirlen;      // _cfa_fffffff0
    size_t needs_separator;   // _cfa_ffffffec
    const _None* base;   // _cfa_ffffffe8
    size_t baselen;     // _cfa_ffffffe4
    char* p_concat;                        // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    unsigned int _v52;                     // _cfa_ffffffcc
    const _None* _v56;   // _cfa_ffffffc8
    unsigned int _t60;                     // _t60
    char* _t64;                            // _t64
    char* _t67;                            // _t67
    char* _t72;                            // _t72

    dirbase = last_component(dir);
    dirbaselen = base_len(dirbase);
    dirlen = dirbase - dir + dirbaselen;
    if(dirbaselen == 0 || ( *(dirbase + dirbaselen - 1) & 255) == 47) {
        _v44 = 0;
    } else {
        _v44 = 1;
    }
    needs_separator = _v44;
    base = longest_relative_suffix(abase);
    _t60 = base;
     *__esp = _t60;
    strlen();
    baselen = _t60;
    _t64 = dirlen + needs_separator + baselen + 1;
     *__esp = _t64;
    malloc();
    p_concat = _t64;
    if(p_concat != 0) {
        _v52 = dirlen;
        _v56 = dir;
        _t67 = p_concat;
         *__esp = _t67;
        mempcpy();
        p = _t67;
         *p = 47;
        p =  &(p[needs_separator]);
        if(base_in_result != 0) {
             *base_in_result =  &(p[ ~(( *abase & 255) == 47 & 255)]);
        }
        _v52 = baselen;
        _v56 = base;
        _t72 = p;
         *__esp = _t72;
        mempcpy();
        p = _t72;
         *p = 0;
        _v40 = p_concat;
    } else {
        _v40 = 0;
    }
    return _v40;
}

char* file_name_concat(const _None* dir, const _None* abase, char** base_in_result)
{// addr = 0x0805236D  --  defined in 'filenamecat.c' at line 97
    char* p;                               // _cfa_fffffff8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    p = mfile_name_concat(dir, abase, base_in_result);
    if(p == 0) {
        xalloc_die();
    }
    return p;
}

_Bool hard_locale(int category)
{// addr = 0x080523A0  --  defined in 'hard-locale.c' at line 37
    _Bool hard;                            // _cfa_fffffffb
    const char* p;   // _cfa_fffffff4
    _Bool _v24;                            // _cfa_ffffffe8
    const char* _t12;   // _t12
    const char* _t14;   // _t14
    const char* _t15;   // _t15

    hard = 1;
    _v24 = 0;
    _t12 = category;
     *__esp = _t12;
    setlocale();
    p = _t12;
    if(p != 0) {
        _v24 = 134617175;
        _t14 = p;
         *__esp = _t14;
        strcmp();
        if(_t14 == 0) {
L3:
            hard = 0;
        } else {
            _v24 = 134617177;
            _t15 = p;
             *__esp = _t15;
            strcmp();
            if(_t15 == 0) {
                goto L3;
            }
        }
    }
    return hard & 255;
}

size_t hash_get_n_buckets(const Hash_table* table)
{// addr = 0x08052400  --  defined in 'hash.c' at line 148
    return table->n_buckets;
}

size_t hash_get_n_buckets_used(const Hash_table* table)
{// addr = 0x0805240B  --  defined in 'hash.c' at line 156
    return table->n_buckets_used;
}

size_t hash_get_n_entries(const Hash_table* table)
{// addr = 0x08052416  --  defined in 'hash.c' at line 164
    return table->n_entries;
}

size_t hash_get_max_bucket_length(const Hash_table* table)
{// addr = 0x08052421  --  defined in 'hash.c' at line 172
    const struct hash_entry* bucket;   // _cfa_fffffff8
    size_t max_bucket_length;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    size_t bucket_length;   // _cfa_ffffffec

    max_bucket_length = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L7:
            bucket = bucket + 8;
            continue;
        }
        cursor = bucket;
        bucket_length = 1;
        while(1) {
            cursor = cursor->next;
            if(cursor == 0) {
                break;
            }
            bucket_length = bucket_length + 1;
        }
        if(bucket_length > max_bucket_length) {
            max_bucket_length = bucket_length;
        }
        goto L7;
    }
    return max_bucket_length;
}

_Bool hash_table_ok(const Hash_table* table)
{// addr = 0x08052485  --  defined in 'hash.c' at line 199
    const struct hash_entry* bucket;   // _cfa_fffffff8
    size_t n_buckets_used;   // _cfa_fffffff4
    size_t n_entries;   // _cfa_fffffff0
    const struct hash_entry* cursor;   // _cfa_ffffffec
    signed char _v21;                      // _cfa_ffffffeb

    n_buckets_used = 0;
    n_entries = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L5:
            bucket = bucket + 8;
            continue;
        }
        cursor = bucket;
        n_buckets_used = n_buckets_used + 1;
        n_entries = n_entries + 1;
        while(1) {
            cursor = cursor->next;
            if(cursor == 0) {
                goto L5;
            }
            n_entries = n_entries + 1;
        }
        goto L5;
    }
    if(table->n_buckets_used != n_buckets_used || table->n_entries != n_entries) {
        _v21 = 0;
    } else {
        _v21 = 1;
    }
    return _v21 & 255;
}

void hash_print_statistics(const Hash_table* table, FILE* stream)
{// addr = 0x08052504  --  defined in 'hash.c' at line 228
    size_t n_entries;   // _cfa_fffffff8
    size_t n_buckets;   // _cfa_fffffff4
    size_t n_buckets_used;   // _cfa_fffffff0
    size_t max_bucket_length;   // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    long long _v40;                        // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4 (outparam)

    n_entries = hash_get_n_entries(table);
    n_buckets = hash_get_n_buckets(table);
    n_buckets_used = hash_get_n_buckets_used(table);
    max_bucket_length = hash_get_max_bucket_length(table);
    _v36 = n_entries;
    _v40 = "# entries:         %lu\n";
     *__esp = stream;
    fprintf();
    _v36 = n_buckets;
    _v40 = "# buckets:         %lu\n";
     *__esp = stream;
    fprintf();
    _push(0);
    _push(n_buckets_used);
    asm("fild qword [esp]");
    __esp =  &_v44;
    asm("fmulp st1, st0");
    _push(0);
    _push(n_buckets);
    asm("fild qword [esp]");
    __esp =  &(((char*)( &_v44))[2]);
    asm("fdivp st1, st0");
    _v40 =  *134617312;
    _v44 = n_buckets_used;
    __esp[1] = "# buckets used:    %lu (%.2f%%)\n";
     *__esp = stream;
    fprintf();
    _v44 = max_bucket_length;
    __esp[1] = "max bucket length: %lu\n";
     *__esp = stream;
    fprintf();
}

_Unknown_base* hash_lookup(const Hash_table* table, * entry)
{// addr = 0x080525DC  --  defined in 'hash.c' at line 248
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    _Unknown_base* _v28;                   // _cfa_ffffffe4
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    signed int _t34;                       // _t34
    * _t45;                   // _t45

    _v40 = table->n_buckets;
    _t34 = entry;
     *__esp = _t34;
     *(table->hasher)();
    bucket = table->bucket + (_t34 << 3);
    if(table->bucket_limit <= bucket) {
        abort();
    }
    if(bucket->data != 0) {
        cursor = bucket;
        while(cursor != 0) {
            _v40 = cursor->data;
            _t45 = entry;
             *__esp = _t45;
             *(table->comparator)();
            if(_t45 == 0) {
                cursor = cursor->next;
                continue;
            } else {
                _v28 = cursor->data;
            }
            goto L10;
        }
        _v28 = 0;
    } else {
        _v28 = 0;
    }
L10:
    return _v28;
}

_Unknown_base* hash_get_first(const Hash_table* table)
{// addr = 0x08052677  --  defined in 'hash.c' at line 277
    const struct hash_entry* bucket;   // _cfa_fffffff8
    _Unknown_base* _v24;                   // _cfa_ffffffe8

    if(table->n_entries != 0) {
        bucket = table->bucket;
L3:
L3:
        if(table->bucket_limit <= bucket) {
            abort();
        }
        if(bucket->data == 0) {
            goto L7;
        }
        _v24 = bucket->data;
        goto L8;
L7:
        bucket = bucket + 8;
        goto L3;
    } else {
        _v24 = 0;
    }
L8:
    return _v24;
}

_Unknown_base* hash_get_next(const Hash_table* table, * entry)
{// addr = 0x080526C6  --  defined in 'hash.c' at line 296
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    _Unknown_base* _v28;                   // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _t40;                       // _t40

    _v40 = table->n_buckets;
    _t40 = entry;
     *__esp = _t40;
     *(table->hasher)();
    bucket = table->bucket + (_t40 << 3);
    if(table->bucket_limit <= bucket) {
        abort();
    }
    cursor = bucket;
    while(cursor != 0) {
        if(cursor->data != entry || cursor->next == 0) {
            cursor = cursor->next;
            continue;
        } else {
            _v28 = cursor->next->data;
L13:
            return _v28;
        }
    }
    while(1) {
        bucket = bucket + 8;
        if(bucket >= table->bucket_limit) {
            break;
        }
        if(bucket->data == 0) {
            continue;
        }
        _v28 = bucket->data;
        goto L13;
    }
    _v28 = 0;
    goto L13;
}

size_t hash_get_entries(const Hash_table* table, _Unknown_base** buffer, size_t buffer_size)
{// addr = 0x0805276F  --  defined in 'hash.c' at line 325
    size_t counter;     // _cfa_fffffff8
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    unsigned int _v24;                     // _cfa_ffffffe8

    counter = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L7:
            bucket = bucket + 8;
            continue;
        } else {
            cursor = bucket;
            while(cursor != 0) {
                if(counter < buffer_size) {
                    buffer[counter] = cursor->data;
                    counter = counter + 1;
                    cursor = cursor->next;
                    continue;
                } else {
                    _v24 = counter;
                }
                goto L10;
            }
            goto L7;
        }
L10:
        return _v24;
    }
    _v24 = counter;
    goto L10;
}

size_t hash_do_for_each(const Hash_table* table, Hash_processor processor, _Unknown_base* processor_data)
{// addr = 0x080527E6  --  defined in 'hash.c' at line 357
    size_t counter;     // _cfa_fffffff8
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    unsigned int _v24;                     // _cfa_ffffffe8
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    signed int _t36;                       // _t36

    counter = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L7:
            bucket = bucket + 8;
            continue;
        } else {
            cursor = bucket;
            while(cursor != 0) {
                _v40 = processor_data;
                 *__esp = cursor->data;
                _t36 = processor;
                 *_t36();
                if((_t36 ^ 1) == 0) {
                    counter = counter + 1;
                    cursor = cursor->next;
                    continue;
                } else {
                    _v24 = counter;
                }
                goto L10;
            }
            goto L7;
        }
L10:
        return _v24;
    }
    _v24 = counter;
    goto L10;
}

size_t hash_string(const char* string, size_t n_buckets)
{// addr = 0x0805285E  --  defined in 'hash.c' at line 419
    unsigned char ch;                      // _cfa_fffffffb
    size_t value;       // _cfa_fffffff4
    signed int _v28;                       // _cfa_ffffffe4

    value = 0;
    while(1) {
        ch =  *string & 255;
        if(ch == 0) {
            break;
        }
        _v28 = (value << 5) - value + (ch & 255);
        value = _v28 % n_buckets;
        string =  &(string[1]);
    }
    return value;
}

_Bool is_prime(size_t candidate)
{// addr = 0x080528AA  --  defined in 'hash.c' at line 435
    size_t divisor;     // _cfa_fffffff8
    size_t square;      // _cfa_fffffff4
    signed int _v32;                       // _cfa_ffffffe0

    divisor = 3;
    square = divisor * divisor;
    while(square < candidate) {
        _v32 = candidate;
        if(_v32 % divisor != 0) {
            divisor = divisor + 1;
            square = square + (divisor << 2);
            divisor = divisor + 1;
            continue;
        }
        break;
    }
    _v32 = candidate;
    return _v32 % divisor != 0;
}

size_t next_prime(size_t candidate)
{// addr = 0x0805290D  --  defined in 'hash.c' at line 454
    if(candidate <= 9) {
        candidate = 10;
    }
    candidate = candidate | 1;
    while((is_prime(candidate) ^ 1) != 0) {
        candidate = candidate + 2;
    }
    return candidate;
}

void hash_reset_tuning(Hash_tuning* tuning)
{// addr = 0x08052941  --  defined in 'hash.c' at line 470
    tuning->shrink_threshold = 0;
    tuning->shrink_factor = 1065353216;
    tuning->growth_threshold = 1061997773;
    tuning->growth_factor = 1068826100;
    tuning->is_n_buckets = 0;
}

_Bool check_tuning(Hash_table* table)
{// addr = 0x08052978  --  defined in 'hash.c' at line 482
    const Hash_tuning* tuning;   // _cfa_fffffff8
    float epsilon;                         // _cfa_fffffff4
    signed char _v21;                      // _cfa_ffffffeb

    tuning = table->tuning;
    epsilon = 1036831949;
    asm("fxch st0, st1");
    asm("fucompp");
    asm("fnstsw ax");
    asm("sahf");
    if(__eflags <= 0) {
L8:
        table->tuning =  &default_tuning;
        _v21 = 0;
    } else {
        asm("fld1");
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(__eflags <= 0) {
            goto L8;
        } else {
            asm("fld1");
            asm("faddp st1, st0");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags <= 0) {
                goto L8;
            } else {
                asm("fldz");
                asm("fxch st0, st1");
                asm("fucompp");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags < 0) {
                    goto L8;
                } else {
                    asm("fucompp");
                    asm("fnstsw ax");
                    asm("sahf");
                    if(__eflags <= 0) {
                        goto L8;
                    } else {
                        asm("fld1");
                        asm("fucompp");
                        asm("fnstsw ax");
                        asm("sahf");
                        if(__eflags < 0) {
                            goto L8;
                        } else {
                            asm("fucompp");
                            asm("fnstsw ax");
                            asm("sahf");
                            if(__eflags <= 0) {
                                goto L8;
                            } else {
                                _v21 = 1;
                            }
                        }
                    }
                }
            }
        }
    }
    return _v21 & 255;
}

Hash_table* hash_initialize(size_t candidate, const Hash_tuning* tuning, Hash_hasher hasher, Hash_comparator comparator, Hash_data_freer data_freer)
{// addr = 0x08052A2A  --  defined in 'hash.c' at line 540
    Hash_table* table;   // _cfa_fffffff8
    float new_candidate;                   // _cfa_fffffff4
    _unknown_ _v22;                        // _cfa_ffffffea
    short _v24;                            // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    Hash_table* _v40;   // _cfa_ffffffd8
    intOrPtr _v56;                         // _cfa_ffffffc8
    struct hash_entry* _v60;   // _cfa_ffffffc4 (outparam)
    Hash_table* _t63;   // _t63
    signed int _t67;                       // _t67
    Hash_table* _t76;   // _t76
    struct hash_entry* _t79;   // _t79

    if(hasher == 0 || comparator == 0) {
        _v40 = 0;
    } else {
        _v60 = 40;
        malloc();
        table = _t63;
        __eflags = table;
        if(table != 0) {
            __eflags = tuning;
            if(tuning == 0) {
                tuning =  &default_tuning;
            }
            table->tuning = tuning;
            _t67 = check_tuning(table);
            __eflags = _t67 ^ 1;
            if((_t67 ^ 1) != 0) {
L15:
                _v60 = table;
                free();
                _v40 = 0;
                goto L16;
            } else {
                __eflags = tuning->is_n_buckets & 255 ^ 1;
                if(__eflags == 0) {
L11:
                    __eflags = candidate - 536870911;
                    if(candidate > 536870911) {
                        goto L15;
                    }
                    table->n_buckets = next_prime(candidate);
                    _t76 = table;
                    __eflags = _t76->n_buckets - 536870911;
                    if(_t76->n_buckets > 536870911) {
                        goto L15;
                    }
                    _t79 = table->n_buckets;
                    _v56 = 8;
                    _v60 = _t79;
                    calloc();
                    table->bucket = _t79;
                    __eflags = table->bucket;
                    if(table->bucket == 0) {
                        goto L15;
                    }
                    table->bucket_limit = table->bucket + (table->n_buckets << 3);
                    table->n_buckets_used = 0;
                    table->n_entries = 0;
                    table->hasher = hasher;
                    table->comparator = comparator;
                    table->data_freer = data_freer;
                    table->free_entry_list = 0;
                    _v40 = table;
L16:
                    return _v40;
                }
                _push(0);
                _push(candidate);
                asm("fild qword [esp]");
                asm("fdivp st1, st0");
                new_candidate = tuning->growth_threshold;
                asm("fxch st0, st1");
                asm("fucompp");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags >= 0) {
                    goto L15;
                }
                asm("fnstcw word [ebp-0x12]");
                _v24 = 12;
                asm("fldcw word [ebp-0x14]");
                asm("fistp qword [ebp-0x20]");
                asm("fldcw word [ebp-0x12]");
                candidate = _v36;
                goto L11;
            }
        }
        _v40 = 0;
    }
}

void hash_clear(Hash_table* table)
{// addr = 0x08052BB8  --  defined in 'hash.c' at line 605
    struct hash_entry* bucket;   // _cfa_fffffff8
    struct hash_entry* cursor;   // _cfa_fffffff4
    struct hash_entry* next;   // _cfa_fffffff0

    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data != 0) {
            cursor = bucket->next;
            while(cursor != 0) {
                if(table->data_freer != 0) {
                     *__esp = cursor->data;
                    table->data_freer->data();
                }
                cursor->data = 0;
                next = cursor->next;
                cursor->next = table->free_entry_list;
                table->free_entry_list = cursor;
                cursor = next;
            }
            if(table->data_freer != 0) {
                 *__esp = bucket->data;
                table->data_freer->data();
            }
            bucket->data = 0;
            bucket->next = 0;
        }
        bucket = bucket + 8;
    }
    table->n_buckets_used = 0;
    table->n_entries = 0;
}

void hash_free(Hash_table* table)
{// addr = 0x08052C86  --  defined in 'hash.c' at line 648
    struct hash_entry* bucket;   // _cfa_fffffff8
    struct hash_entry* cursor;   // _cfa_fffffff4
    struct hash_entry* next;   // _cfa_fffffff0

    if(table->data_freer == 0 || table->n_entries == 0) {
L9:
        bucket = table->bucket;
        while(table->bucket_limit > bucket) {
            cursor = bucket->next;
            while(cursor != 0) {
                next = cursor->next;
                 *__esp = cursor;
                free();
                cursor = next;
            }
            bucket = bucket + 8;
        }
        cursor = table->free_entry_list;
        while(cursor != 0) {
            next = cursor->next;
             *__esp = cursor;
            free();
            cursor = next;
        }
         *__esp = table->bucket;
        free();
         *__esp = table;
        free();
        return;
    } else {
        bucket = table->bucket;
        while(table->bucket_limit > bucket) {
            if(bucket->data == 0) {
L7:
                bucket = bucket + 8;
                continue;
            }
            cursor = bucket;
            while(cursor != 0) {
                 *__esp = cursor->data;
                 *(table->data_freer)();
                cursor = cursor->next;
            }
            goto L7;
        }
        goto L9;
    }
}

struct hash_entry* allocate_entry(Hash_table* table)
{// addr = 0x08052D72  --  defined in 'hash.c' at line 705
    struct hash_entry* new;   // _cfa_fffffff8
    struct hash_entry* _t13;   // _t13

    _t13 = table->free_entry_list;
    if(_t13 == 0) {
         *__esp = 8;
        malloc();
        new = _t13;
    } else {
        new = table->free_entry_list;
        table->free_entry_list = new->next;
    }
    return new;
}

void free_entry(Hash_table* table, struct hash_entry* entry)
{// addr = 0x08052DAD  --  defined in 'hash.c' at line 730
    entry->data = 0;
    entry->next = table->free_entry_list;
    table->free_entry_list = entry;
}

_Unknown_base* hash_find_entry(Hash_table* table, * entry, struct hash_entry** bucket_head, _Bool delete)
{// addr = 0x08052DD0  --  defined in 'hash.c' at line 745
    struct hash_entry* bucket;   // _cfa_fffffff4
    struct hash_entry* cursor;   // _cfa_fffffff0
    _Unknown_base* data;                   // _cfa_ffffffec
    struct hash_entry* next;   // _cfa_ffffffe8
    _Unknown_base* data;                   // _cfa_ffffffe4
    struct hash_entry* next;   // _cfa_ffffffe0
    char _v44;                             // _cfa_ffffffd4
    _Unknown_base* _v48;                   // _cfa_ffffffd0
    _Unknown_base* _v56;                   // _cfa_ffffffc8 (outparam)
    signed int _t78;                       // _t78
    * _t89;                   // _t89
    * _t97;                   // _t97
    struct hash_entry* _t119;   // _t119

    _v44 = delete;
    _v56 = table->n_buckets;
    _t78 = entry;
     *__esp = _t78;
     *(table->hasher)();
    bucket = table->bucket + (_t78 << 3);
    if(table->bucket_limit <= bucket) {
        abort();
    }
     *bucket_head = bucket;
    if(bucket->data != 0) {
        _v56 = bucket->data;
        _t89 = entry;
         *__esp = _t89;
         *(table->comparator)();
        if(_t89 == 0) {
            cursor = bucket;
            while(cursor->next != 0) {
                _v56 = cursor->next->data;
                _t97 = entry;
                 *__esp = _t97;
                 *(table->comparator)();
                if(_t97 == 0) {
                    cursor = cursor->next;
                    continue;
                }
                data = cursor->next->data;
                if(_v44 != 0) {
                    next = cursor->next;
                    cursor->next = next->next;
                    free_entry(table, next);
                }
                _v48 = data;
                goto L18;
            }
            _v48 = 0;
            goto L18;
        }
        data = bucket->data;
        if(_v44 != 0) {
            if(bucket->next == 0) {
                bucket->data = 0;
            } else {
                next = bucket->next;
                _t119 = next;
                __ecx = bucket;
                __ecx->data = _t119->data;
                __ecx->next = _t119->next;
                free_entry(table, next);
            }
        }
        _v48 = data;
        goto L18;
    } else {
        _v48 = 0;
L18:
        return _v48;
    }
}

_Bool hash_rehash(Hash_table* table, size_t candidate)
{// addr = 0x08052F2D  --  defined in 'hash.c' at line 819
    Hash_table* new_table;   // _cfa_fffffff4
    struct hash_entry* bucket;   // _cfa_fffffff0
    struct hash_entry* cursor;   // _cfa_ffffffec
    struct hash_entry* next;   // _cfa_ffffffe8
    _Unknown_base* data;                   // _cfa_ffffffe4
    struct hash_entry* new_bucket;   // _cfa_ffffffe0
    struct hash_entry* new_entry;   // _cfa_ffffffdc
    signed int _v41;                       // _cfa_ffffffd7
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr _v72;                         // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int _t130;                      // _t130
    struct hash_entry* _t151;   // _t151

    new_table = hash_initialize(candidate, table->tuning, table->hasher, table->comparator, table->data_freer);
    if(new_table != 0) {
        new_table->free_entry_list = table->free_entry_list;
        bucket = table->bucket;
        while(table->bucket_limit > bucket) {
            if(bucket->data == 0) {
L17:
                bucket = bucket + 8;
                continue;
            }
            cursor = bucket;
            while(cursor != 0) {
                data = cursor->data;
                _v72 = new_table->n_buckets;
                _t130 = data;
                 *__esp = _t130;
                new_table->hasher->data();
                new_bucket =  &(new_table->bucket[_t130]);
                if(new_table->bucket_limit <= new_bucket) {
                    abort();
                }
                next = cursor->next;
                if(new_bucket->data == 0) {
                    new_bucket->data = data;
                    new_table->n_buckets_used =  &(new_table->n_buckets_used->data);
                    if(cursor != bucket) {
                        free_entry(new_table, cursor);
                    }
                    goto L15;
                } else {
                    if(cursor != bucket) {
                        cursor->next = new_bucket->next;
                        new_bucket->next = cursor;
L15:
                        cursor = next;
                        continue;
                    }
                    _t151 = new_table;
                    allocate_entry(_t151);
                    new_entry = _t151;
                    if(new_entry != 0) {
                        new_entry->data = data;
                        new_entry->next = new_bucket->next;
                        new_bucket->next = new_entry;
                        goto L15;
                    }
                    _v41 = 0;
L20:
                    return _v41 & 255;
                }
            }
            goto L17;
        }
         *__esp = table->bucket;
        free();
        table->bucket = new_table->bucket;
        table->bucket_limit = new_table->bucket_limit;
        table->n_buckets = new_table->n_buckets;
        table->n_buckets_used = new_table->n_buckets_used;
        table->free_entry_list = new_table->free_entry_list;
         *__esp = new_table;
        free();
        _v41 = 1;
        goto L20;
    }
    _v41 = 0;
    goto L20;
}

_Unknown_base* hash_insert(Hash_table* table, * entry)
{// addr = 0x08053109  --  defined in 'hash.c' at line 908
    _Unknown_base* data;                   // _cfa_fffffff8
    struct hash_entry* bucket;   // _cfa_fffffff4
    struct hash_entry* new_entry;   // _cfa_fffffff0
    const Hash_tuning* tuning;   // _cfa_ffffffec
    float candidate;                       // _cfa_ffffffe8
    _unknown_ _v38;                        // _cfa_ffffffda
    short _v40;                            // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    float _v56;                            // _cfa_ffffffc8
    _Unknown_base* _v60;                   // _cfa_ffffffc4
    _unknown_ _v80;                        // _cfa_ffffffb0 (outparam)
    _unknown_ _v84;                        // _cfa_ffffffac (outparam)
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ _v92;                        // _cfa_ffffffa4 (outparam)
    signed int _t139;                      // _t139

    if(entry == 0) {
        abort();
    }
    data = hash_find_entry(table, entry,  &bucket, 0);
    if(data == 0) {
        __eflags = bucket->data;
        if(__eflags == 0) {
            bucket->data = entry;
            table->n_entries = table->n_entries + 1;
            table->n_buckets_used = table->n_buckets_used + 1;
            _push(0);
            _push(table->n_buckets_used);
            asm("fild qword [esp]");
            _push(0);
            _push(table->n_buckets);
            asm("fild qword [esp]");
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags <= 0) {
L17:
                _v60 = entry;
L18:
                return _v60;
            }
            check_tuning(table);
            _push(0);
            _push(table->n_buckets_used);
            asm("fild qword [esp]");
            _push(0);
            _push(table->n_buckets);
            asm("fild qword [esp]");
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags <= 0) {
                goto L17;
            }
            tuning = table->tuning;
            __eflags = tuning->is_n_buckets & 255;
            if(__eflags == 0) {
                _push(0);
                _push(table->n_buckets);
                asm("fild qword [esp]");
                asm("fmulp st1, st0");
                asm("fmulp st1, st0");
                _v56 = tuning->growth_threshold;
            } else {
                _push(0);
                _push(table->n_buckets);
                asm("fild qword [esp]");
                asm("fmulp st1, st0");
                _v56 = tuning->growth_factor;
            }
            candidate = _v56;
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags < 0) {
                asm("fnstcw word [ebp-0x22]");
                _v40 = 12;
                asm("fldcw word [ebp-0x24]");
                asm("fistp qword [ebp-0x30]");
                asm("fldcw word [ebp-0x22]");
                _t139 = hash_rehash(table, _v52);
                __eflags = _t139 ^ 1;
                if((_t139 ^ 1) != 0) {
                    entry = 0;
                }
                goto L17;
            } else {
                _v60 = 0;
                goto L18;
            }
        }
        new_entry = allocate_entry(table);
        __eflags = new_entry;
        if(new_entry != 0) {
            new_entry->data = entry;
            new_entry->next = bucket->next;
            bucket->next = new_entry;
            table->n_entries = table->n_entries + 1;
            _v60 = entry;
        } else {
            _v60 = 0;
        }
        goto L18;
    }
    _v60 = data;
    goto L18;
}

_Unknown_base* hash_delete(Hash_table* table, * entry)
{// addr = 0x08053324  --  defined in 'hash.c' at line 983
    _Unknown_base* data;                   // _cfa_fffffff8
    struct hash_entry* bucket;   // _cfa_fffffff4
    const Hash_tuning* tuning;   // _cfa_fffffff0
    size_t candidate;   // _cfa_ffffffec
    _unknown_ _v22;                        // _cfa_ffffffea
    short _v24;                            // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _Unknown_base* _v44;                   // _cfa_ffffffd4
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)
    const Hash_tuning* _t103;   // _t103

    data = hash_find_entry(table, entry,  &bucket, 1);
    __eflags = data;
    if(data != 0) {
        table->n_entries = table->n_entries - 1;
        __eflags = bucket->data;
        if(__eflags == 0) {
            table->n_buckets_used = table->n_buckets_used - 1;
            _push(0);
            _push(table->n_buckets_used);
            asm("fild qword [esp]");
            _push(0);
            _push(table->n_buckets);
            asm("fild qword [esp]");
            asm("fmulp st1, st0");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(__eflags > 0) {
                check_tuning(table);
                _push(0);
                _push(table->n_buckets_used);
                asm("fild qword [esp]");
                _push(0);
                _push(table->n_buckets);
                asm("fild qword [esp]");
                asm("fmulp st1, st0");
                asm("fucompp");
                asm("fnstsw ax");
                asm("sahf");
                if(__eflags > 0) {
                    tuning = table->tuning;
                    _t103 = tuning;
                    __eflags = _t103->is_n_buckets & 255;
                    if((_t103->is_n_buckets & 255) == 0) {
                        _push(0);
                        _push(table->n_buckets);
                        asm("fild qword [esp]");
                        asm("fmulp st1, st0");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x12]");
                        _v24 = 12;
                        asm("fldcw word [ebp-0x14]");
                        asm("fistp qword [ebp-0x20]");
                        asm("fldcw word [ebp-0x12]");
                        _v40 = _v36;
                    } else {
                        _push(0);
                        _push(table->n_buckets);
                        asm("fild qword [esp]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x12]");
                        _v24 = 12;
                        asm("fldcw word [ebp-0x14]");
                        asm("fistp qword [ebp-0x20]");
                        asm("fldcw word [ebp-0x12]");
                        _v40 = _v36;
                    }
                    candidate = _v40;
                    hash_rehash(table, candidate);
                }
            }
        }
        _v44 = data;
    } else {
        _v44 = 0;
    }
    return _v44;
}

long double adjust_value(int inexact_style, long double value)
{// addr = 0x080534C8  --  defined in 'human.c' at line 56
    signed int _v16;                       // _cfa_fffffff0
    uintmax_t u;     // _cfa_ffffffec
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    _unknown_ _v108;                       // _cfa_ffffff94
    long double _t31;                      // _t31
    signed int _t37;                       // _t37
    signed int _t53;                       // _t53
    _unknown_ _t55;                        // _t55
    signed int _t57;                       // _t57
    _unknown_ _t66;                        // _t66

    _t55 = inexact_style - 1;
    if(_t55 != 0) {
        asm("fucompp");
        asm("fnstsw ax");
        asm("sahf");
        if(_t55 > 0) {
            asm("fxch st0, st1");
            asm("fucompp");
            asm("fnstsw ax");
            asm("sahf");
            if(_t55 >= 0) {
                _t66 = tword [0x8061980];
                asm("fsubp st1, st0");
                asm("fnstcw word [ebp-0x1a]");
                _v32 = 12;
                asm("fldcw word [ebp-0x1c]");
                asm("fistp qword [ebp-0x10]");
                asm("fldcw word [ebp-0x1a]");
                u = u ^ 0;
                _v16 = _v16 ^ -2147483648;
            } else {
                _t66 = tword [ebp+0xc];
                asm("fnstcw word [ebp-0x1a]");
                _v32 = 12;
                asm("fldcw word [ebp-0x1c]");
                asm("fistp qword [ebp-0x10]");
                asm("fldcw word [ebp-0x1a]");
            }
            u = u;
            _v16 = _v16;
            if(inexact_style != 0) {
L10:
                _v48 = 0;
            } else {
                asm("fild qword [ebp-0x10]");
                tword [ebp-0x28] = _t66;
                _t57 = _v16;
                if(_t57 < 0) {
                    asm("faddp st1, st0");
                    tword [ebp-0x28] = tword [ebp-0x28];
                }
                _t66 = tword [ebp-0x28];
                asm("fucompp");
                asm("fnstsw ax");
                asm("sahf");
                if(((_t57 != 0 | _t57 ?_? 0) ^ 1) != 0) {
                    goto L10;
                } else {
                    _v48 = 1;
                }
            }
            _t37 = _v48;
            _v100 = _t37;
            _v96 = _t37 >> 31;
            _t53 = _v96;
            asm("adc edx, [ebp-0xc]");
            _push(_t53);
            _push(_v100 + u);
            asm("fild qword [esp]");
            tword [ebp-0x48] = _t66;
            if(_t53 < 0) {
                asm("faddp st1, st0");
                tword [ebp-0x48] = tword [ebp-0x48];
            }
            tword [ebp+0xc] = tword [ebp-0x48];
        }
    }
    _t31 = value;
    _v92 = _t31;
    _v88 = _a12;
    _v84 = _a16;
    return _t31;
}

char* group_number(char* number, size_t numberlen, const char* grouping, const char* thousands_sep)
{// addr = 0x08053603  --  defined in 'human.c' at line 82
    char* d;                               // r5+4294967216
    signed int _v8;                        // _cfa_fffffff8
    char[40] buf;                          // _cfa_ffffffcf
    unsigned char g;                       // _cfa_ffffffce
    size_t grouplen;    // _cfa_ffffffc8
    size_t thousands_seplen;   // _cfa_ffffffc4
    size_t i;           // _cfa_ffffffc0
    char* _v72;                            // _cfa_ffffffb8
    const char* _v76;   // _cfa_ffffffb4
    unsigned int _v80;                     // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _v100;                    // _cfa_ffffff9c
    unsigned int _v104;                    // _cfa_ffffff98
    unsigned int _t65;                     // _t65
    char* _t86;                            // _t86

    _v72 = number;
    _v76 = grouping;
    _v80 = thousands_sep;
    _v8 =  *gs:0x14];
    grouplen = -1;
    _t65 = _v80;
     *__esp = _t65;
    strlen();
    thousands_seplen = _t65;
    i = numberlen;
    _v100 = numberlen;
    _v104 = _v72;
     *__esp =  &buf;
    memcpy();
    _v84 =  &(_v72[numberlen]);
    while(1) {
        g =  *_v76 & 255;
        if(g != 0) {
            if(g > 126) {
                _v88 = i;
            } else {
                _v88 = g & 255;
            }
            grouplen = _v88;
            _v76 =  &(_v76[1]);
        }
        if(i < grouplen) {
            grouplen = i;
        }
        _v84 =  &(_v84[ ~grouplen]);
        i = i - grouplen;
        _v100 = grouplen;
        _v104 =  &buf + i;
         *__esp = _v84;
        memcpy();
        if(i == 0) {
            break;
        }
        _v84 =  &(_v84[ ~thousands_seplen]);
        _v100 = thousands_seplen;
        _v104 = _v80;
         *__esp = _v84;
        memcpy();
    }
    _t86 = _v84;
    if((_v8 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t86;
    }
    return _t86;
}

char* human_readable(uintmax_t n, char* buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size)
{// addr = 0x0805370F  --  defined in 'human.c' at line 156
    long double dto_block_size;            // _cfa_ffffff54
    int inexact_style;                     // _cfa_ffffffe0
    unsigned int base;                     // _cfa_ffffffdc
    int tenths;                            // _cfa_ffffffd8
    int exponent;                          // _cfa_ffffffd4
    int exponent_max;                      // _cfa_ffffffd0
    char* p;                               // _cfa_ffffffcc
    char* psuffix;                         // _cfa_ffffffc8
    const char* integerlim;   // _cfa_ffffffc4
    int rounding;                          // _cfa_ffffffc0
    const char* decimal_point;   // _cfa_ffffffbc
    size_t decimal_pointlen;   // _cfa_ffffffb8
    const char* grouping;   // _cfa_ffffffb4
    const char* thousands_sep;   // _cfa_ffffffb0
    const struct lconv* l;   // _cfa_ffffffac
    size_t pointlen;    // _cfa_ffffffa8
    size_t buflen;      // _cfa_ffffffa4
    size_t nonintegerlen;   // _cfa_ffffffa0
    unsigned int r10;                      // _cfa_ffffff9c
    unsigned int r2;                       // _cfa_ffffff98
    int digit;                             // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    uintmax_t amt;   // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    uintmax_t multiplier;   // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    uintmax_t divisor;   // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    uintmax_t r10;   // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    uintmax_t r2;    // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    uintmax_t power;   // _cfa_ffffff64
    int _v180;                             // _cfa_ffffff4c
    unsigned int _v184;                    // _cfa_ffffff48
    long double damt;                      // _cfa_ffffff44
    intOrPtr _v196;                        // _cfa_ffffff3c
    intOrPtr _v200;                        // _cfa_ffffff38
    long double e;                         // _cfa_ffffff34
    signed int _v208;                      // _cfa_ffffff30
    signed int _v212;                      // _cfa_ffffff2c
    signed int _v216;                      // _cfa_ffffff28
    signed int _v220;                      // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    unsigned int _v228;                    // _cfa_ffffff1c
    signed char _v229;                     // _cfa_ffffff1b
    signed char _v236;                     // _cfa_ffffff14
    char _v237;                            // _cfa_ffffff13
    _unknown_ _v244;                       // _cfa_ffffff0c
    _unknown_ _v245;                       // _cfa_ffffff0b
    int _v256;                             // _cfa_ffffff00
    unsigned int _v260;                    // _cfa_fffffefc
    signed int _v264;                      // _cfa_fffffef8
    signed int _v268;                      // _cfa_fffffef4
    int _v272;                             // _cfa_fffffef0
    unsigned int _v276;                    // _cfa_fffffeec
    signed int _v320;                      // _cfa_fffffec0
    signed int _v324;                      // _cfa_fffffebc
    const struct lconv* _v328;   // _cfa_fffffeb8
    signed int _v336;                      // _cfa_fffffeb0
    unsigned int _v340;                    // _cfa_fffffeac
    signed int _v344;                      // _cfa_fffffea8
    intOrPtr _v348;                        // _cfa_fffffea4
    signed int _v352;                      // _cfa_fffffea0
    intOrPtr _v356;                        // _cfa_fffffe9c
    signed int _v392;                      // _cfa_fffffe78
    intOrPtr _v396;                        // _cfa_fffffe74
    signed int _v400;                      // _cfa_fffffe70
    int _v432;                             // _cfa_fffffe50 (outparam)
    unsigned int _v436;                    // _cfa_fffffe4c (outparam)
    const char* _v440;   // _cfa_fffffe48 (outparam)
    char _v444;                            // _cfa_fffffe44 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    const struct lconv* _t519;   // _t519
    unsigned int _t521;                    // _t521
    char* _t525;                           // _t525
    signed char _t535;                     // _t535
    unsigned int _t541;                    // _t541
    unsigned int _t552;                    // _t552
    signed int _t587;                      // _t587
    long long unsigned int _t588;          // _t588
    unsigned int _t606;                    // _t606
    signed int _t614;                      // _t614
    long long unsigned int _t615;          // _t615
    signed int _t617;                      // _t617
    signed int _t722;                      // _t722
    long long unsigned int _t723;          // _t723
    signed int _t799;                      // _t799
    signed int _t803;                      // _t803
    signed int _t805;                      // _t805
    signed int _t806;                      // _t806
    intOrPtr _t808;                        // _t808
    signed int _t809;                      // _t809
    signed int _t812;                      // _t812
    signed int _t820;                      // _t820
    signed int _t837;                      // _t837
    signed int _t845;                      // _t845
    signed int _t847;                      // _t847
    signed int _t849;                      // _t849
    signed int _t851;                      // _t851
    _unknown_ _t918;                       // _t918
    _unknown_ _t921;                       // _t921
    _unknown_ _t926;                       // _t926

    _v212 = n;
    _v208 = buf;
    _v220 = to_block_size;
    _v216 = _a24;
    _v228 = _a28;
    _v224 = _a32;
    inexact_style = from_block_size & 3;
    if((from_block_size & 32) == 0) {
        _v328 = 1000;
    } else {
        _v328 = 1024;
    }
    _t519 = _v328;
    base = _t519;
    exponent = -1;
    exponent_max = 8;
    decimal_point = 134617337;
    decimal_pointlen = 1;
    grouping = 134617339;
    thousands_sep = 134617339;
    localeconv();
    l = _t519;
    _t521 = l->decimal_point;
     *__esp = _t521;
    strlen();
    pointlen = _t521;
    if(pointlen != 0) {
        if(pointlen <= 16) {
            decimal_point = l->decimal_point;
            decimal_pointlen = pointlen;
        }
    }
    grouping = l->grouping;
    _t525 = l->thousands_sep;
     *__esp = _t525;
    strlen();
    if(_t525 <= 16) {
        thousands_sep = l->thousands_sep;
    }
    psuffix = opts + 648;
    p = psuffix;
    _v340 = _v228;
    _v336 = _v224;
    if(_v336 > _v216 || _v336 >= _v216 && _v340 > _v220) {
        if((_v220 | _v216) == 0) {
            goto L27;
        }
        _t803 = _v216;
        if((__umoddi3(_v228, _v224, _v220, _t803) | _t803) != 0) {
            goto L27;
        }
        _v436 = _v220;
        _v432 = _v216;
        _t805 = _v224;
         *__esp = _v228;
        _v440 = _t805;
        divisor = __udivdi3();
        _v128 = _t805;
        _t806 = _v128;
        _t614 = __umoddi3(_v212, _v208, divisor, _t806);
        _t615 = _t614 * 10;
        _t808 = _t806 * 10 + _t614 * 0 + (_t614 * 10 >> 32);
        r10 = _t615;
        _v136 = _t808;
        r10 = _t615;
        _v136 = _t808;
        _t809 = _v128;
        _t617 = __umoddi3(r10, _v136, divisor, _t809);
        r2 = _t617 + _t617;
        _v144 = (_t809 << 32 | _t617) << 1;
        _v436 = divisor;
        _v432 = _v128;
        _t812 = _v208;
         *__esp = _v212;
        _v440 = _t812;
        amt = __udivdi3();
        _v112 = _t812;
        tenths = __udivdi3(r10, _v136, divisor, _v128);
        _v348 = r2;
        _v344 = _v144;
        if(_v344 > _v128) {
L20:
            _v356 = divisor;
            _v352 = _v128;
            if(_v352 > _v144) {
L24:
                _v320 = 2;
L25:
                _v324 = _v320;
L26:
                rounding = _v324;
                goto L43;
            }
            if(_v352 < _v144 || _v356 < r2) {
                _v320 = 3;
                goto L25;
            } else {
                goto L24;
            }
        }
        if(_v344 < _v128 || _v348 < divisor) {
            _v324 = (r2 | _v144) != 0 & 255;
            goto L26;
        } else {
            goto L20;
        }
    } else {
        _t845 = _v224;
        if((__umoddi3(_v220, _v216, _v228, _t845) | _t845) != 0) {
L27:
            asm("fild qword [ebp-0xe0]");
            tword [ebp-0x178] = __fp0;
            if(_v224 < 0) {
                asm("faddp st1, st0");
                tword [ebp-0x178] = tword [ebp-0x178];
            }
            _t918 = tword [ebp-0x178];
            tword [ebp-0xa8] = _t918;
            asm("fild qword [ebp-0xd0]");
            tword [ebp-0x138] = _t918;
            if(_v208 < 0) {
                _t918 = tword [ebp-0x138];
                asm("faddp st1, st0");
                tword [ebp-0x138] = _t918;
            }
            asm("fild qword [ebp-0xd8]");
            tword [ebp-0x128] = _t918;
            if(_v216 < 0) {
                asm("faddp st1, st0");
                tword [ebp-0x128] = tword [ebp-0x128];
            }
            asm("fdivrp st1, st0");
            _t921 = tword [ebp-0x138];
            asm("fmulp st1, st0");
            tword [ebp-0xb8] = _t921;
            if((from_block_size & 16) != 0) {
                e = 0;
                _v200 = -2147483648;
                _v196 = 16383;
                exponent = 0;
                goto L36;
                do {
                } while();
                goto L42;
L36:
                _push(0);
                _push(base);
                asm("fild qword [esp]");
                __esp =  &_v444;
                asm("fmulp st1, st0");
                tword [ebp-0xc8] = tword [ebp-0xc8];
                exponent = exponent + 1;
                _t535 = base;
                _push(0);
                _push(_t535);
                asm("fild qword [esp]");
                __esp =  &_v444 + 8;
                asm("fmulp st1, st0");
                asm("fucompp");
                asm("fnstsw ax");
                if(((_t535 & 5) == 0 ^ 1) != 0 || exponent >= exponent_max) {
                    _t926 = tword [ebp-0xc8];
                    asm("fdivp st1, st0");
                    tword [ebp-0xb8] = _t926;
                    _v440 = damt;
                    _v436 = _v184;
                    _v432 = _v180;
                     *__esp = inexact_style;
                    adjust_value();
                    tword [esp+0x8] = _t926;
                    _v440 = 134617346;
                     *__esp = opts;
                    sprintf();
                    _t541 = opts;
                     *__esp = _t541;
                    strlen();
                    buflen = _t541;
                    nonintegerlen = decimal_pointlen + 1;
                    if(((from_block_size & 32) == 0 & 255) + nonintegerlen + 1 < buflen || (from_block_size & 8) != 0 && ( *(buflen - 1 + opts) & 255) == 48) {
                        asm("fmulp st1, st0");
                        tword [esp+0x4] = tword [0x80619a0];
                         *__esp = inexact_style;
                        adjust_value();
                        asm("fdivp st1, st0");
                        tword [esp+0x8] = tword [0x80619a0];
                        _v440 = 134617340;
                         *__esp = opts;
                        sprintf();
                        _t552 = opts;
                         *__esp = _t552;
                        strlen();
                        buflen = _t552;
                        nonintegerlen = 0;
                    }
                } else {
                    goto L36;
                }
                goto L42;
            } else {
                _v440 = damt;
                _v436 = _v184;
                _v432 = _v180;
                 *__esp = inexact_style;
                adjust_value();
                tword [esp+0x8] = _t921;
                _v440 = 134617340;
                 *__esp = opts;
                sprintf();
                _t606 = opts;
                 *__esp = _t606;
                strlen();
                buflen = _t606;
                nonintegerlen = 0;
L42:
                p =  &(psuffix[ ~buflen]);
                _v436 = buflen;
                _v440 = opts;
                 *__esp = p;
                memmove();
                integerlim =  &(p[buflen - nonintegerlen]);
L92:
                if((from_block_size & 4) != 0) {
                    p = group_number(p, integerlim - p, grouping, thousands_sep);
                }
                if((from_block_size & 128) == 0) {
L116:
                     *psuffix = 0;
                    return p;
                } else {
                    if(exponent >= 0) {
L102:
                        if((from_block_size & 256 | exponent) != 0 && (from_block_size & 64) != 0) {
                             *psuffix = 32;
                            psuffix =  &(psuffix[1]);
                        }
                        if(exponent != 0) {
                            if((from_block_size & 32) != 0 || exponent != 1) {
                                _v229 =  *( &power_letter + exponent) & 255;
                            } else {
                                _v229 = 107;
                            }
                             *psuffix = _v229 & 255;
                            psuffix =  &(psuffix[1]);
                        }
                        if((from_block_size & 256) != 0) {
                            if((from_block_size & 32) != 0 && exponent != 0) {
                                 *psuffix = 105;
                                psuffix =  &(psuffix[1]);
                            }
                             *psuffix = 66;
                            psuffix =  &(psuffix[1]);
                        }
                        goto L116;
                    }
                    exponent = 0;
                    power = 1;
                    _v152 = 0;
                    while(1) {
                        _v396 = power;
                        _v392 = _v152;
                        if(_v392 >= _v224 && (_v392 > _v224 || _v396 >= _v228)) {
                            goto L102;
                        }
                        exponent = exponent + 1;
                        if(exponent == exponent_max) {
                            goto L102;
                        }
                        _t587 = base;
                        _t588 = _t587 * power;
                        _t799 = _v152 * _t587 + power * 0 + (_t587 * power >> 32);
                        power = _t588;
                        _v152 = _t799;
                        power = _t588;
                        _v152 = _t799;
                    }
                    goto L102;
                }
            }
        }
        _v436 = _v228;
        _v432 = _v224;
        _t847 = _v216;
         *__esp = _v220;
        _v440 = _t847;
        multiplier = __udivdi3();
        _v120 = _t847;
        _t722 = multiplier;
        _t723 = _t722 * _v212;
        _t849 = _v208 * multiplier + _v120 * _v212 + (_t722 * _v212 >> 32);
        amt = _t723;
        _v112 = _t849;
        amt = _t723;
        _v112 = _t849;
        _v436 = multiplier;
        _v432 = _v120;
        _t851 = _v112;
         *__esp = amt;
        _v440 = _t851;
        if((__udivdi3() ^ _v212 | _t851 ^ _v208) != 0) {
            goto L27;
        } else {
            tenths = 0;
            rounding = 0;
L43:
            if((from_block_size & 16) == 0) {
L76:
                if(inexact_style != 1) {
                    if(inexact_style != 0 || tenths + rounding <= 0) {
                        _v236 = 0;
                    } else {
                        _v236 = 1;
                    }
                    _v237 = _v236 & 255;
                } else {
                    asm("adc edx, edi");
                    _v237 = ((amt & 1) + rounding != 0 & 255) + tenths - 5 > 0;
                }
                if(_v237 != 0) {
                    amt = amt + 1;
                    asm("adc dword [ebp-0x6c], 0x0");
                    if((from_block_size & 16) != 0 && (base ^ amt | 0 ^ _v112) == 0 && exponent < exponent_max) {
                        exponent = exponent + 1;
                        if((from_block_size & 8) == 0) {
                            p = p - 1;
                             *p = 48;
                            p =  &(p[ ~decimal_pointlen]);
                            _v436 = decimal_pointlen;
                            _v440 = decimal_point;
                             *__esp = p;
                            memcpy();
                        }
                        amt = 1;
                        _v112 = 0;
                    }
                }
                integerlim = p;
                do {
                    digit = __umoddi3(amt, _v112, 10, 0);
                    p = p - 1;
                     *p = digit + 48;
                    _t820 = _v112;
                    amt = __udivdi3(amt, _t820, 10, 0);
                    _v112 = _t820;
                } while((_v112 | amt) != 0);
                goto L92;
            }
            exponent = 0;
            _v276 = base;
            _v272 = 0;
            if(_v272 > _v112 || _v272 >= _v112 && _v276 > amt) {
                goto L76;
            } else {
                goto L47;
                do {
L53:
                    rounding = _v268;
                    exponent = exponent + 1;
                    _v260 = base;
                    _v256 = 0;
                    if(_v256 > _v112 || _v256 >= _v112 && _v260 > amt || exponent >= exponent_max) {
                        if(_v112 <= 0 && (_v112 < 0 || amt <= 9)) {
                            if(_v112 <= 0 && (_v112 < 0 || amt <= 9) && (tenths != 0 || (from_block_size & 8) == 0)) {
                                p = p - 1;
                                 *p = tenths + 48;
                                p =  &(p[ ~decimal_pointlen]);
                                _v436 = decimal_pointlen;
                                _v440 = decimal_point;
                                 *__esp = p;
                                memcpy();
                                rounding = 0;
                                tenths = rounding;
                            }
                        }
                        goto L76;
                    } else {
L47:
                        r10 = __umoddi3(amt, _v112, base, 0) * 10 + tenths;
                        _v400 = r10;
                        r2 = _v400 % base + _v400 % base + (rounding >> 1);
                        _v436 = base;
                        _v432 = 0;
                        _t837 = _v112;
                         *__esp = amt;
                        _v440 = _t837;
                        amt = __udivdi3();
                        _v112 = _t837;
                        tenths = r10 / base;
                        if(r2 >= base) {
                            if(rounding + r2 <= base) {
                                _v264 = 2;
                            } else {
                                _v264 = 3;
                            }
                            _v268 = _v264;
                        } else {
                            _v268 = rounding + r2 != 0 & 255;
                        }
                        continue;
                    }
                } while();
                goto L53;
            }
        }
    }
}

uintmax_t default_block_size()
{// addr = 0x08054394  --  defined in 'human.c' at line 407
    intOrPtr _v8;                          // _cfa_fffffff8
    long long unsigned int _v12;           // _cfa_fffffff4

     *__esp = "POSIXLY_CORRECT";
    getenv();
    if(__eax == 0) {
        _v12 = 1024;
        _v8 = 0;
    } else {
        _v12 = 512;
        _v8 = 0;
    }
    return _v12;
}

strtol_error humblock(const char* spec, uintmax_t* block_size, int* options)
{// addr = 0x080543D0  --  defined in 'human.c' at line 413
    int i;                                 // _cfa_fffffff8
    int opts;                              // _cfa_fffffff4
    char* ptr;                             // _cfa_fffffff0
    strtol_error e;   // _cfa_ffffffec
    union strtol_error _v24;   // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    uintmax_t* _t88;   // _t88
    long long unsigned int _t89;           // _t89

    opts = 0;
    if(spec != 0) {
L4:
        if(( *spec & 255) == 39) {
            opts = opts | 4;
            spec =  &(spec[1]);
        }
        i = argmatch(spec,  &block_size_args,  &block_size_opts, 4);
        if(i < 0) {
            e = xstrtoumax(spec,  &ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
            if(e == 0) {
                while(( *spec & 255) <= 47 || ( *spec & 255) > 57) {
                    if(spec != ptr) {
                        spec =  &(spec[1]);
                        continue;
                    }
                    opts = opts | 128;
                    if(( *(ptr - 1) & 255) == 66) {
                        opts = opts | 256;
                    }
                    if(( *(ptr - 1) & 255) != 66 || ( *(ptr - 2) & 255) == 105) {
                        opts = opts | 32;
                    }
                    break;
                }
L19:
                 *options = opts;
                _v24 = 0;
L20:
                return _v24;
            }
             *options = 0;
            _v24 = e;
            goto L20;
        }
        opts = opts | ( &block_size_opts)[i];
        _t88 = block_size;
         *_t88 = 1;
        _t88[0] = 0;
        goto L19;
    }
     *__esp = "BLOCK_SIZE";
    getenv();
    spec = __eax;
    if(spec != 0) {
        goto L4;
    }
     *__esp = "BLOCKSIZE";
    getenv();
    spec = __eax;
    if(spec != 0) {
        goto L4;
    } else {
        _t89 = default_block_size();
        __ecx = block_size;
         *__ecx = _t89;
        __ecx[0] = __edx;
        goto L19;
    }
}

union strtol_error human_options(const char* spec, int* opts, uintmax_t* block_size)
{// addr = 0x08054532  --  defined in 'human.c' at line 463
    strtol_error e;   // _cfa_fffffff8
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    uintmax_t* _t17;   // _t17
    long long unsigned int _t21;           // _t21

    e = humblock(spec, block_size, opts);
    _t17 = block_size;
    __edx = _t17[0];
    if(( *_t17 | __edx) == 0) {
        _t21 = default_block_size();
        __ecx = block_size;
         *__ecx = _t21;
        __ecx[0] = __edx;
        e = 4;
    }
    return e;
}

char* getuser(uid_t uid)
{// addr = 0x0805457C  --  defined in 'idcache.c' at line 69
    struct userid* tail;   // _cfa_fffffff8
    struct userid* match;   // _cfa_fffffff4
    struct passwd* pwent;   // _cfa_fffffff0
    const char* name;   // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    const char* _v28;   // _cfa_ffffffe4
    const char* _v40;   // _cfa_ffffffd8
    struct passwd* _t47;   // _t47
    const char* _t49;   // _t49

    match = 0;
    tail = user_alist;
    while(tail != 0) {
        if(tail->id != uid) {
            tail = tail->next;
            continue;
        } else {
            match = tail;
        }
        break;
    }
    if(match == 0) {
        _t47 = uid;
         *__esp = _t47;
        getpwuid();
        pwent = _t47;
        if(pwent == 0) {
            _v28 = 134617516;
        } else {
            _v28 = pwent->pw_name;
        }
        name = _v28;
        _t49 = name;
         *__esp = _t49;
        strlen();
        match = xmalloc( &(_t49[9]));
        match->id = uid;
        _v40 = name;
         *__esp =  &(match->name);
        strcpy();
        match->next = user_alist;
        user_alist = match;
    }
    if((match->name & 255) == 0) {
        _v24 = 0;
    } else {
        _v24 =  &(match->name);
    }
    return _v24;
}

uid_t* getuidbyname(const char* user)
{// addr = 0x08054651  --  defined in 'idcache.c' at line 105
    struct userid* tail;   // _cfa_fffffff8
    struct passwd* pwent;   // _cfa_fffffff4
    uid_t* _v24;         // _cfa_ffffffe8
    const char* _v40;   // _cfa_ffffffd8
    struct passwd* _t62;   // _t62
    const char* _t63;   // _t63
    const char* _t77;   // _t77
    const char* _t79;   // _t79

    tail = user_alist;
    while(tail != 0) {
        if((tail->name & 255) != ( *user & 255)) {
L4:
            tail = tail->next;
            continue;
        }
        _t79 = user;
        _v40 = _t79;
         *__esp =  &(tail->name);
        strcmp();
        if(_t79 != 0) {
            goto L4;
        }
        _v24 = tail;
L15:
        return _v24;
    }
    tail = nouser_alist;
    while(tail != 0) {
        if((tail->name & 255) != ( *user & 255)) {
L10:
            tail = tail->next;
            continue;
        }
        _t77 = user;
        _v40 = _t77;
         *__esp =  &(tail->name);
        strcmp();
        if(_t77 != 0) {
            goto L10;
        }
        _v24 = 0;
        goto L15;
    }
    _t62 = user;
     *__esp = _t62;
    getpwnam();
    pwent = _t62;
    _t63 = user;
     *__esp = _t63;
    strlen();
    tail = xmalloc( &(_t63[9]));
    _v40 = user;
     *__esp =  &(tail->name);
    strcpy();
    if(pwent == 0) {
        tail->next = nouser_alist;
        nouser_alist = tail;
        _v24 = 0;
    } else {
        tail->id = pwent->pw_uid;
        tail->next = user_alist;
        user_alist = tail;
        _v24 = tail;
    }
    goto L15;
}

char* getgroup(gid_t gid)
{// addr = 0x0805477C  --  defined in 'idcache.c' at line 151
    struct userid* tail;   // _cfa_fffffff8
    struct userid* match;   // _cfa_fffffff4
    struct group* grent;   // _cfa_fffffff0
    const char* name;   // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    const char* _v28;   // _cfa_ffffffe4
    const char* _v40;   // _cfa_ffffffd8
    struct group* _t47;   // _t47
    const char* _t49;   // _t49

    match = 0;
    tail = group_alist;
    while(tail != 0) {
        if(tail->id != gid) {
            tail = tail->next;
            continue;
        } else {
            match = tail;
        }
        break;
    }
    if(match == 0) {
        _t47 = gid;
         *__esp = _t47;
        getgrgid();
        grent = _t47;
        if(grent == 0) {
            _v28 = 134617516;
        } else {
            _v28 = grent->gr_name;
        }
        name = _v28;
        _t49 = name;
         *__esp = _t49;
        strlen();
        match = xmalloc( &(_t49[9]));
        match->id = gid;
        _v40 = name;
         *__esp =  &(match->name);
        strcpy();
        match->next = group_alist;
        group_alist = match;
    }
    if((match->name & 255) == 0) {
        _v24 = 0;
    } else {
        _v24 =  &(match->name);
    }
    return _v24;
}

gid_t* getgidbyname(const char* group)
{// addr = 0x08054851  --  defined in 'idcache.c' at line 187
    struct userid* tail;   // _cfa_fffffff8
    struct group* grent;   // _cfa_fffffff4
    gid_t* _v24;         // _cfa_ffffffe8
    const char* _v40;   // _cfa_ffffffd8
    struct group* _t62;   // _t62
    const char* _t63;   // _t63
    const char* _t77;   // _t77
    const char* _t79;   // _t79

    tail = group_alist;
    while(tail != 0) {
        if((tail->name & 255) != ( *group & 255)) {
L4:
            tail = tail->next;
            continue;
        }
        _t79 = group;
        _v40 = _t79;
         *__esp =  &(tail->name);
        strcmp();
        if(_t79 != 0) {
            goto L4;
        }
        _v24 = tail;
L15:
        return _v24;
    }
    tail = nogroup_alist;
    while(tail != 0) {
        if((tail->name & 255) != ( *group & 255)) {
L10:
            tail = tail->next;
            continue;
        }
        _t77 = group;
        _v40 = _t77;
         *__esp =  &(tail->name);
        strcmp();
        if(_t77 != 0) {
            goto L10;
        }
        _v24 = 0;
        goto L15;
    }
    _t62 = group;
     *__esp = _t62;
    getgrnam();
    grent = _t62;
    _t63 = group;
     *__esp = _t63;
    strlen();
    tail = xmalloc( &(_t63[9]));
    _v40 = group;
     *__esp =  &(tail->name);
    strcpy();
    if(grent == 0) {
        tail->next = nogroup_alist;
        nogroup_alist = tail;
        _v24 = 0;
    } else {
        tail->id = grent->gr_gid;
        tail->next = group_alist;
        group_alist = tail;
        _v24 = tail;
    }
    goto L15;
}

char* imaxtostr(intmax_t i, char* buf)
{// addr = 0x0805497C  --  defined in 'inttostr.c' at line 30
    char* p;                               // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t73;                       // _t73
    signed int _t78;                       // _t78

    _v28 = i;
    _v24 = buf;
    p =  *((intOrPtr*)(__ebp + 16)) + 20;
     *p = 0;
    if(_v24 >= 0) {
        do {
            p = p - 1;
             *p = __moddi3(_v28, _v24, 10, 0) + 48;
            _t73 = _v24;
            _v28 = __divdi3(_v28, _t73, 10, 0);
            _v24 = _t73;
        } while((_v24 | _v28) != 0);
    } else {
        do {
            p = p - 1;
             *p = 48 - __moddi3(_v28, _v24, 10, 0);
            _t78 = _v24;
            _v28 = __divdi3(_v28, _t78, 10, 0);
            _v24 = _t78;
        } while((_v24 | _v28) != 0);
        p = p - 1;
         *p = 45;
    }
    return p;
}

void mpsort_into_tmp(** base, size_t n, ** tmp, comparison_function cmp)
{// addr = 0x08054A84  --  defined in 'mpsort.c' at line 40
    size_t n1;          // _cfa_fffffff8
    size_t n2;          // _cfa_fffffff4
    size_t a;           // _cfa_fffffff0
    size_t alim;        // _cfa_ffffffec
    size_t b;           // _cfa_ffffffe8
    size_t blim;        // _cfa_ffffffe4
    * ba;                     // _cfa_ffffffe0
    * bb;                     // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    signed int _v52;                       // _cfa_ffffffcc (outparam)
    ** _v56;                  // _cfa_ffffffc8 (outparam)
    _None* _t98;                           // _t98

    n1 = n >> 1;
    n2 = n - n1;
    a = 0;
    alim = n1;
    b = n1;
    blim = n;
    mpsort_with_tmp( &(base[n1]), n2, tmp, cmp);
    mpsort_with_tmp(base, n1, tmp, cmp);
    ba = base[a];
    bb = base[b];
    while(1) {
L1:
        _v56 = bb;
         *__esp = ba;
        _t98 = cmp;
         *_t98();
        if(_t98 > 0) {
            break;
        }
         *tmp = ba;
        tmp =  &(tmp[1]);
        a = a + 1;
        if(a != alim) {
            ba = base[a];
            continue;
        } else {
            a = b;
            alim = blim;
        }
L7:
        _v52 = (alim - a) * 4;
        _v56 =  &(base[a]);
         *__esp = tmp;
        memcpy();
        return;
    }
     *tmp = bb;
    tmp =  &(tmp[1]);
    b = b + 1;
    __eflags = b - blim;
    if(__eflags != 0) {
        bb = base[b];
        goto L1;
    }
    goto L7;
}

void mpsort_with_tmp(** base, size_t n, ** tmp, comparison_function cmp)
{// addr = 0x08054BBB  --  defined in 'mpsort.c' at line 89
    * p0;                     // _cfa_fffffff8
    * p1;                     // _cfa_fffffff4
    size_t n1;          // _cfa_fffffff0
    size_t n2;          // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    size_t t;           // _cfa_ffffffe4
    size_t tlim;        // _cfa_ffffffe0
    size_t b;           // _cfa_ffffffdc
    size_t blim;        // _cfa_ffffffd8
    * bb;                     // _cfa_ffffffd4
    * tt;                     // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    signed int _v68;                       // _cfa_ffffffbc (outparam)
    * _v72;                   // _cfa_ffffffb8 (outparam)
    intOrPtr* _t116;                       // _t116
    _None* _t149;                          // _t149

    if(n > 2) {
        n1 = n >> 1;
        n2 = n - n1;
        t = 0;
        tlim = n1;
        b = n1;
        blim = n;
        mpsort_with_tmp( &(base[n1]), n2, tmp, cmp);
        if(n1 > 1) {
            mpsort_into_tmp(base, n1, tmp, cmp);
        } else {
             *tmp =  *base;
        }
        tt = tmp[t];
        bb = base[b];
        i = 0;
        while(1) {
L8:
            _v72 = bb;
             *__esp = tt;
            _t116 = cmp;
             *_t116();
            if(_t116 > 0) {
                break;
            }
            base[i] = tt;
            i = i + 1;
            t = t + 1;
            if(t != tlim) {
                tt = tmp[t];
                continue;
            }
            goto L14;
        }
        base[i] = bb;
        i = i + 1;
        b = b + 1;
        if(b == blim) {
            _v68 = (tlim - t) * 4;
            _v72 =  &(tmp[t]);
             *__esp =  &(base[i]);
            memcpy();
            return;
        }
        bb = base[b];
        goto L8;
    } else {
        if(n == 2) {
            p0 =  *base;
            p1 = base[1];
            _v72 = p1;
             *__esp = p0;
            _t149 = cmp;
             *_t149();
            if(_t149 > 0) {
                 *base = p1;
                base[1] = p0;
                return;
            }
        }
    }
L14:
}

void mpsort(** base, size_t n, comparison_function cmp)
{// addr = 0x08054D6F  --  defined in 'mpsort.c' at line 154
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    mpsort_with_tmp(base, n,  &(base[n]), cmp);
}

const _None* quote_n(int n, const _None* name)
{// addr = 0x08054DA0  --  defined in 'quote.c' at line 30
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return quotearg_n_style(n, 5, name);
}

const _None* quote(const _None* name)
{// addr = 0x08054DC2  --  defined in 'quote.c' at line 38
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return quote_n(0, name);
}

struct quoting_options* clone_quoting_options(struct quoting_options* o)
{// addr = 0x08054DE0  --  defined in 'quotearg.c' at line 106
    int e;                                 // _cfa_fffffff8
    struct quoting_options* p;   // _cfa_fffffff4
    * _v24;                   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    struct quoting_options* _t14;   // _t14

    __errno_location();
    e =  *__eax;
    if(o == 0) {
        _v24 =  &default_quoting_options;
    } else {
        _v24 = o;
    }
    _t14 = xmemdup(_v24, 36);
    p = _t14;
    __errno_location();
     *_t14 = e;
    return p;
}

union quoting_style get_quoting_style(struct quoting_options* o)
{// addr = 0x08054E2C  --  defined in 'quotearg.c' at line 117
    struct quoting_options* _v8;   // _cfa_fffffff8

    if(o == 0) {
        _v8 =  &default_quoting_options;
    } else {
        _v8 = o;
    }
    return  *_v8;
}

void set_quoting_style(struct quoting_options* o, union quoting_style s)
{// addr = 0x08054E4E  --  defined in 'quotearg.c' at line 125
    struct quoting_options* _v8;   // _cfa_fffffff8

    if(o == 0) {
        _v8 =  &default_quoting_options;
    } else {
        _v8 = o;
    }
     *_v8 = s;
}

int set_char_quoting(struct quoting_options* o, char c, int i)
{// addr = 0x08054E73  --  defined in 'quotearg.c' at line 136
    unsigned char uc;                      // _cfa_fffffffb
    unsigned int* p;                       // _cfa_fffffff4
    int shift;                             // _cfa_fffffff0
    int r;                                 // _cfa_ffffffec
    signed char _v24;                      // _cfa_ffffffe8
    struct quoting_options* _v28;   // _cfa_ffffffe4

    _v24 = c;
    uc = _v24 & 255;
    if(o == 0) {
        _v28 =  &default_quoting_options;
    } else {
        _v28 = o;
    }
    p =  &(( &(_v28->quote_these_too))[(uc & 255) >> 5 & 255]);
    shift = uc & 0x1f;
    r =  *p >> shift & 1;
     *p =  *p ^ (i & 1 ^ r) << shift;
    return r;
}

const char* gettext_quote(const char* msgid, union quoting_style s)
{// addr = 0x08054EED  --  defined in 'quotearg.c' at line 150
    const char* translation;   // _cfa_fffffff8
    const char* _t8;   // _t8

    _t8 = msgid;
     *__esp = _t8;
    gettext();
    translation = _t8;
    if(translation == msgid && s == 6) {
        translation = 134617660;
    }
    return translation;
}

size_t quotearg_buffer_restyled(char* buffer, size_t buffersize, const char* arg, size_t argsize, union quoting_style quoting_style, const struct quoting_options* o)
{// addr = 0x08054F1B  --  defined in 'quotearg.c' at line 175
    const char* left;   // _cfa_ffffffe0
    const char* right;   // _cfa_ffffffdc
    unsigned char esc;                     // _cfa_fffffff8
    _Bool backslash_escapes;               // _cfa_fffffffb
    _Bool unibyte_locale;                  // _cfa_fffffffa
    unsigned char c;                       // _cfa_fffffff9
    _Bool printable;                       // _cfa_fffffff7
    size_t i;           // _cfa_fffffff0
    size_t len;         // _cfa_ffffffec
    const char* quote_string;   // _cfa_ffffffe8
    size_t quote_string_len;   // _cfa_ffffffe4
    size_t m;           // _cfa_ffffffd8
    wchar_t w;         // _cfa_ffffffd4
    size_t bytes;       // _cfa_ffffffd0
    size_t j;           // _cfa_ffffffcc
    size_t ilim;        // _cfa_ffffffc8
    mbstate_t mbstate;   // _cfa_ffffffc0
    unsigned int _v72;                     // _cfa_ffffffb8
    char _v73;                             // _cfa_ffffffb7
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v96;                       // _cfa_ffffffa0
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    _unknown_ _v108;                       // _cfa_ffffff94 (outparam)
    struct * _v112;           // _cfa_ffffff90 (outparam)
    unsigned int _v116;                    // _cfa_ffffff8c (outparam)
    unsigned int _v120;                    // _cfa_ffffff88 (outparam)
    signed int _t220;                      // _t220
    const char* _t240;   // _t240
    int _t303;                             // _t303
    unsigned int _t321;                    // _t321

    len = 0;
    quote_string = 0;
    quote_string_len = 0;
    backslash_escapes = 0;
    __ctype_get_mb_cur_max();
    unibyte_locale = __eax == 1;
    if(quoting_style <= 6) {
        goto __eax;
    }
    i = 0;
L59:
L59:
    if(argsize != -1) {
        _v73 = i != argsize;
    } else {
        _v73 = ( *(arg + i) & 255) != 0;
    }
    if(_v73 != 0) {
        if(backslash_escapes != 0 && quote_string_len != 0 && i + quote_string_len <= argsize) {
            _v116 = quote_string_len;
            _t240 = quote_string;
            _v120 = _t240;
             *__esp = arg + i;
            memcmp();
            if(_t240 == 0) {
                if(len < buffersize) {
                    buffer[len] = 92;
                }
                len = len + 1;
            }
        }
    } else {
        goto L63;
    }
    c =  *(arg + i) & 255;
    _t220 = c & 255;
    _v80 = _t220;
    if(_v80 <= 126) {
        _t220 =  *(134617696 + _v80 * 4);
        goto __eax;
    }
    if(unibyte_locale == 0) {
        _v116 = 8;
        _v120 = 0;
         *__esp =  &mbstate;
        memset();
        m = 0;
        printable = 1;
        if(argsize == -1) {
            _t321 = arg;
             *__esp = _t321;
            strlen();
            argsize = _t321;
        }
        while(1) {
            _v112 =  &mbstate;
            _v116 = argsize - i + m;
            _v120 = arg + i + m;
             *__esp =  &w;
            mbrtowc();
            bytes =  &w;
            if(bytes == 0) {
                break;
            }
            if(bytes != -1) {
                if(bytes != -2) {
                    if(quoting_style != 1) {
L31:
                        _t303 = w;
                         *__esp = _t303;
                        iswprint();
                        if(_t303 == 0) {
                            printable = 0;
                        }
                        m = m + bytes;
                         *__esp =  &mbstate;
                        mbsinit();
                        if( &mbstate == 0) {
                            continue;
                        } else {
                            break;
                        }
                    }
                    j = 1;
                    while(j < bytes) {
                        _v96 = ( *(arg + i + m + j) & 255) - 91;
                        if(_v96 > 33) {
                            j = j + 1;
                            continue;
                        }
                        goto __eax;
                    }
                    goto L31;
                }
                printable = 0;
                while(i + m < argsize) {
                    if(( *((signed char*)(arg + i + m)) & 255) != 0) {
                        m = m + 1;
                        continue;
                    }
                    goto L34;
                }
                break;
            }
            printable = 0;
            break;
        }
L34:
        if(m > 1 || (backslash_escapes & 255 ^ 1) == 0 && (printable & 255 ^ 1) != 0) {
            ilim = i + m;
L38:
L38:
            if(backslash_escapes != 0 && (printable & 255 ^ 1) != 0) {
                if(len < buffersize) {
                    buffer[len] = 92;
                }
                len = len + 1;
                if(len < buffersize) {
                    buffer[len] = ((c & 255) >> 6) + 48;
                }
                len = len + 1;
                if(len < buffersize) {
                    buffer[len] = ((c & 255) >> 3 & 7) + 48;
                }
                len = len + 1;
                c = (c & 7) + 48;
            }
            if(i + 1 >= ilim) {
                goto L56;
            }
            if(len < buffersize) {
                buffer[len] = c & 255;
            }
            len = len + 1;
            i = i + 1;
            c =  *((signed char*)(arg + i)) & 255;
            goto L38;
        } else {
            if((backslash_escapes & 255 ^ 1) == 0 && (1 << (c & 0x1f) &  *(o->quote_these_too + ((c & 255) >> 5 & 255) * 4)) != 0) {
                if(len < buffersize) {
                    buffer[len] = 92;
                }
                len = len + 1;
            }
L56:
            if(len < buffersize) {
                buffer[len] = c & 255;
            }
            len = len + 1;
            i = i + 1;
            goto L59;
        }
    }
    m = 1;
    __ctype_b_loc();
    printable = ( *( *_t220 + (c & 255) + (c & 255)) & 0x4000) != 0;
    goto L34;
L63:
    if(i != 0 || quoting_style != 1) {
        if(quote_string == 0) {
L71:
            if(len < buffersize) {
                buffer[len] = 0;
            }
            _v72 = len;
            goto L75;
        }
        while(( *quote_string & 255) != 0) {
            if(len < buffersize) {
                buffer[len] =  *quote_string & 255;
            }
            len = len + 1;
            quote_string =  &(quote_string[1]);
        }
        goto L71;
    } else {
        _v72 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, 2, o);
L75:
        return _v72;
    }
}

size_t quotearg_buffer(char* buffer, size_t buffersize, const char* arg, size_t argsize, const struct quoting_options* o)
{// addr = 0x08055667  --  defined in 'quotearg.c' at line 523
    const struct quoting_options* p;   // _cfa_fffffff8
    int e;                                 // _cfa_fffffff4
    size_t r;           // _cfa_fffffff0
    const struct quoting_options* _v24;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _v44;                        // _cfa_ffffffd4 (outparam)
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    const struct quoting_options* _t22;   // _t22
    unsigned int _t30;                     // _t30

    if(o == 0) {
        _v24 =  &default_quoting_options;
    } else {
        _v24 = o;
    }
    _t22 = _v24;
    p = _t22;
    __errno_location();
    e =  *_t22;
    _t30 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, p->style, p);
    r = _t30;
    __errno_location();
     *_t30 = e;
    return r;
}

char* quotearg_alloc(const char* arg, size_t argsize, const struct quoting_options* o)
{// addr = 0x080556D6  --  defined in 'quotearg.c' at line 537
    int e;                                 // _cfa_fffffff8
    size_t bufsize;     // _cfa_fffffff4
    char* buf;                             // _cfa_fffffff0
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    int* _t37;                             // _t37

    __errno_location();
    e =  *__eax;
    bufsize = quotearg_buffer(0, 0, arg, argsize, o) + 1;
    buf = xcharalloc(bufsize);
    _t37 = quotearg_buffer(buf, bufsize, arg, argsize, o);
    __errno_location();
     *_t37 = e;
    return buf;
}

void quotearg_free()
{// addr = 0x0805575B  --  defined in 'quotearg.c' at line 562
    struct slotvec* sv;   // _cfa_fffffff8
    unsigned int i;                        // _cfa_fffffff4

    sv = slotvec;
    i = 1;
    while(i < nslots) {
         *__esp =  &(sv[i])->val;
        free();
        i = i + 1;
    }
    if(sv->val !=  &slot0) {
         *__esp = sv->val;
        free();
        slotvec0.size = 256;
        slotvec0.val =  &slot0;
    }
    if(sv !=  &slotvec0) {
         *__esp = sv;
        free();
        slotvec =  &slotvec0;
    }
    nslots = 1;
}

char* quotearg_n_options(int n, const char* arg, size_t argsize, const struct quoting_options* options)
{// addr = 0x080557ED  --  defined in 'quotearg.c' at line 592
    _Bool preallocated;                    // _cfa_fffffff7
    int e;                                 // _cfa_fffffff0
    unsigned int n0;                       // _cfa_ffffffec
    struct slotvec* sv;   // _cfa_ffffffe8
    size_t n1;          // _cfa_ffffffe4
    size_t size;        // _cfa_ffffffe0
    char* val;                             // _cfa_ffffffdc
    size_t qsize;       // _cfa_ffffffd8
    _Unknown_base* _v44;                   // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    signed int _v68;                       // _cfa_ffffffbc (outparam)
    _Unknown_base* _v72;                   // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    int* _t94;                             // _t94

    __errno_location();
    e =  *__eax;
    n0 = n;
    sv = slotvec;
    if(n < 0) {
        abort();
    }
    if(nslots <= n0) {
        n1 = n0 + 1;
        preallocated = sv ==  &slotvec0;
        if(n1 > 536870911) {
            xalloc_die();
        }
        _v48 = n1 << 3;
        if(preallocated == 0) {
            _v44 = sv;
        } else {
            _v44 = 0;
        }
        sv = xrealloc(_v44, _v48);
        slotvec = sv;
        if(preallocated != 0) {
            __ecx = sv;
             *__ecx = slotvec0.size;
            __ecx->val = slotvec0.val;
        }
        _v68 = (n1 - nslots) * 8;
        _v72 = 0;
         *__esp =  &(sv[nslots]);
        memset();
        nslots = n1;
    }
    size = sv[n].size;
    val =  &(sv[n])->val;
    qsize = quotearg_buffer(val, size, arg, argsize, options);
    _t94 = size;
    if(_t94 <= qsize) {
        size = qsize + 1;
        sv[n].size = size;
        if(val !=  &slot0) {
             *__esp = val;
            free();
        }
        val = xcharalloc(size);
         &(sv[n])->val = val;
        _t94 = quotearg_buffer(val, size, arg, argsize, options);
    }
    __errno_location();
     *_t94 = e;
    return val;
}

char* quotearg_n(int n, const char* arg)
{// addr = 0x080559AD  --  defined in 'quotearg.c' at line 642
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return quotearg_n_options(n, arg, -1,  &default_quoting_options);
}

char* quotearg(const char* arg)
{// addr = 0x080559D7  --  defined in 'quotearg.c' at line 648
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return quotearg_n(0, arg);
}

struct quoting_options quoting_options_from_style(union quoting_style style)
{// addr = 0x080559F2  --  defined in 'quotearg.c' at line 655
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    struct quoting_options o;   // _cfa_ffffffd4
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    struct quoting_options __ebx;   // r1

    __ebx = style;
    o.style =  *((intOrPtr*)(__ebp + 12));
    _v68 = 32;
    _v72 = 0;
     *__esp =  &(( &(o.style))[1]);
    memset();
     *__ebx = o.style;
     *((intOrPtr*)(__ebx + 4)) = _v40;
     *((intOrPtr*)(__ebx + 8)) = o.quote_these_too[0];
     *((intOrPtr*)(__ebx + 12)) = o.quote_these_too[1];
     *((intOrPtr*)(__ebx + 16)) = o.quote_these_too[2];
     *((intOrPtr*)(__ebx + 20)) = o.quote_these_too[3];
     *((intOrPtr*)(__ebx + 24)) = o.quote_these_too[4];
     *((intOrPtr*)(__ebx + 28)) = o.quote_these_too[5];
     *((intOrPtr*)(__ebx + 32)) = _v12;
    return __ebx;
}

char* quotearg_n_style(int n, union quoting_style s, const char* arg)
{// addr = 0x08055A5F  --  defined in 'quotearg.c' at line 664
    const struct quoting_options o;   // _cfa_ffffffd8
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    union quoting_style _v72;   // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)

    _v72 = s;
    quoting_options_from_style( &o);
    __esp = __esp - 4;
    return quotearg_n_options(n, arg, -1,  &o);
}

char* quotearg_n_style_mem(int n, union quoting_style s, const char* arg, size_t argsize)
{// addr = 0x08055A9D  --  defined in 'quotearg.c' at line 672
    const struct quoting_options o;   // _cfa_ffffffd8
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    union quoting_style _v72;   // _cfa_ffffffb8 (outparam)
    _unknown_ _v76;                        // _cfa_ffffffb4 (outparam)

    _v72 = s;
    quoting_options_from_style( &o);
    __esp = __esp - 4;
    return quotearg_n_options(n, arg, argsize,  &o);
}

char* quotearg_style(union quoting_style s, const char* arg)
{// addr = 0x08055ADA  --  defined in 'quotearg.c' at line 679
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return quotearg_n_style(0, s, arg);
}

char* quotearg_char(const char* arg, char ch)
{// addr = 0x08055AFC  --  defined in 'quotearg.c' at line 685
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    struct quoting_options options;   // _cfa_ffffffd8
    char _v56;                             // _cfa_ffffffc8
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)

    _v56 = ch;
    options.style = default_quoting_options.style;
    _v36 = default_quoting_options.quote_these_too;
    options.quote_these_too[0] =  *134629160;
    options.quote_these_too[1] =  *134629164;
    options.quote_these_too[2] =  *134629168;
    options.quote_these_too[3] =  *134629172;
    options.quote_these_too[4] =  *134629176;
    options.quote_these_too[5] =  *134629180;
    _v8 =  *134629184;
    set_char_quoting( &(options.style), _v56, 1);
    return quotearg_n_options(0, arg, -1,  &(options.style));
}

char* quotearg_colon(const char* arg)
{// addr = 0x08055B8F  --  defined in 'quotearg.c' at line 694
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return quotearg_char(arg, 58);
}

char* memcpy_lowcase(char* dest, const char* src, size_t len)
{// addr = 0x08055BAC  --  defined in 'strftime.c' at line 314
    char _t16;                             // _t16

    while(1) {
        len = len - 1;
        if(len == 0) {
            break;
        }
        _t16 =  *(src + len) & 0xff;
         *__esp = _t16;
        tolower();
        dest[len] = _t16;
    }
    return dest;
}

char* memcpy_uppcase(char* dest, const char* src, size_t len)
{// addr = 0x08055BEE  --  defined in 'strftime.c' at line 323
    char _t16;                             // _t16

    while(1) {
        len = len - 1;
        if(len == 0) {
            break;
        }
        _t16 =  *(src + len) & 0xff;
         *__esp = _t16;
        toupper();
        dest[len] = _t16;
    }
    return dest;
}

size_t strftime_case_(_Bool upcase, char* s, size_t maxsize, const char* format, const struct tm* tp, int ut, int ns)
{// addr = 0x08055C30  --  defined in 'strftime.c' at line 420
    int number_value;                      // _cfa_fffffbb4
    unsigned int u_number_value;           // _cfa_fffffbb0
    _Bool negative_number;                 // _cfa_fffffbe1
    _Bool always_output_a_sign;            // _cfa_fffffbe0
    int tz_colon_mask;                     // _cfa_fffffbac
    const char* subfmt;   // _cfa_fffffba8
    char sign_char;                        // _cfa_fffffbdf
    char* bufp;                            // _cfa_fffffba4
    char[13] buf;                          // _cfa_ffffffe2
    size_t colons;      // _cfa_fffffb9c
    int _n;                                // _cfa_fffffb70
    int _delta;                            // _cfa_fffffb6c
    int _incr;                             // _cfa_fffffb68
    size_t len;         // _cfa_fffffb64
    int _n;                                // _cfa_fffffb60
    int _delta;                            // _cfa_fffffb5c
    int _incr;                             // _cfa_fffffb58
    char[4] ufmt;                          // _cfa_fffffa6c
    char* u;                               // _cfa_fffffb54
    char[1023] ubuf;                       // _cfa_fffffbe2
    size_t len;         // _cfa_fffffb50
    int _n;                                // _cfa_fffffb4c
    int _delta;                            // _cfa_fffffb48
    int _incr;                             // _cfa_fffffb44
    int century;                           // _cfa_fffffb40
    int _n;                                // _cfa_fffffb3c
    int _delta;                            // _cfa_fffffb38
    int _incr;                             // _cfa_fffffb34
    int padding;                           // _cfa_fffffb30
    int _n;                                // _cfa_fffffb2c
    int _delta;                            // _cfa_fffffb28
    int _incr;                             // _cfa_fffffb24
    int _n;                                // _cfa_fffffb20
    int _delta;                            // _cfa_fffffb1c
    int _incr;                             // _cfa_fffffb18
    int _n;                                // _cfa_fffffb14
    int _delta;                            // _cfa_fffffb10
    int _incr;                             // _cfa_fffffb0c
    int _n;                                // _cfa_fffffb08
    int _delta;                            // _cfa_fffffb04
    int _incr;                             // _cfa_fffffb00
    int j;                                 // _cfa_fffffafc
    int _n;                                // _cfa_fffffaf8
    int _delta;                            // _cfa_fffffaf4
    int _incr;                             // _cfa_fffffaf0
    struct tm ltm;          // _cfa_fffffa6c
    time_t t;           // _cfa_fffffaec
    int d;                                 // _cfa_fffffae8
    int _n;                                // _cfa_fffffae4
    int _delta;                            // _cfa_fffffae0
    int _incr;                             // _cfa_fffffadc
    int year;                              // _cfa_fffffad8
    int year_adjust;                       // _cfa_fffffad4
    int days;                              // _cfa_fffffad0
    int d;                                 // _cfa_fffffacc
    int yy;                                // _cfa_fffffac8
    int yy;                                // _cfa_fffffac4
    int _n;                                // _cfa_fffffac0
    int _delta;                            // _cfa_fffffabc
    int _incr;                             // _cfa_fffffab8
    int diff;                              // _cfa_fffffab4
    int hour_diff;                         // _cfa_fffffab0
    int min_diff;                          // _cfa_fffffaac
    int sec_diff;                          // _cfa_fffffaa8
    signed int _v16;                       // _cfa_fffffff0
    _Bool to_lowcase;                      // _cfa_fffffbde
    _Bool to_uppcase;                      // _cfa_fffffbdd
    _Bool change_case;                     // _cfa_fffffbdc
    int hour12;                            // _cfa_fffffbd8
    const char* zone;   // _cfa_fffffbd4
    size_t i;           // _cfa_fffffbd0
    char* p;                               // _cfa_fffffbcc
    const char* f;   // _cfa_fffffbc8
    const char* format_end;   // _cfa_fffffbc4
    int pad;                               // _cfa_fffffbc0
    int modifier;                          // _cfa_fffffbbc
    int digits;                            // _cfa_fffffbb8
    int width;                             // _cfa_fffffba0
    int format_char;                       // _cfa_fffffb98
    int _n;                                // _cfa_fffffb94
    int _delta;                            // _cfa_fffffb90
    int _incr;                             // _cfa_fffffb8c
    size_t len;         // _cfa_fffffb88
    size_t fsize;       // _cfa_fffffb84
    size_t bytes;       // _cfa_fffffb80
    int _n;                                // _cfa_fffffb7c
    int _delta;                            // _cfa_fffffb78
    int _incr;                             // _cfa_fffffb74
    int flen;                              // _cfa_fffffaa4
    int _n;                                // _cfa_fffffaa0
    int _delta;                            // _cfa_fffffa9c
    int _incr;                             // _cfa_fffffa98
    intOrPtr _v1424;                       // _cfa_fffffa70
    mbstate_t mbstate;   // _cfa_fffffa6c
    signed char _v1440;                    // _cfa_fffffa60
    char* _v1444;                          // _cfa_fffffa5c
    const char* _v1448;   // _cfa_fffffa58
    const struct tm* _v1452;   // _cfa_fffffa54
    signed int _v1556;                     // _cfa_fffff9ec
    signed int _v1560;                     // _cfa_fffff9e8
    unsigned int _v1564;                   // _cfa_fffff9e4
    signed int _v1568;                     // _cfa_fffff9e0
    int _v1604;                            // _cfa_fffff9bc (outparam)
    const char* _v1608;   // _cfa_fffff9b8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    unsigned int _t342;                    // _t342
    char* _t346;                           // _t346
    const char* _t347;   // _t347

    _v1440 = upcase;
    _v1444 = s;
    _v1448 = format;
    _v1452 = tp;
    _v16 =  *gs:0x14];
    hour12 = _v1452->tm_hour;
    i = 0;
    p = _v1444;
    format_end = 0;
    zone = 0;
    zone = _v1452->tm_zone;
    if(hour12 <= 12) {
        if(hour12 == 0) {
            hour12 = 12;
        }
    } else {
        hour12 = hour12 - 12;
    }
    f = _v1448;
    while(( *f & 255) != 0) {
        pad = 0;
        digits = 0;
        width = -1;
        to_lowcase = 0;
        to_uppcase = _v1440 & 255;
        change_case = 0;
        _v1568 =  *f & 255;
        if(_v1568 > 63) {
            if(_v1568 < 65 || _v1568 > 95 && _v1568 - 97 > 29) {
L26:
                mbstate.__val = mbstate_zero.__val;
                _v1424 =  *134629476;
                len = 0;
                if(format_end == 0) {
                    _t347 = f;
                     *__esp = _t347;
                    strlen();
                    format_end = f +  &(_t347[1]);
                }
                fsize = format_end - f;
                while(1) {
                    _v1604 =  &mbstate;
                    _v1608 = fsize - len;
                     *__esp = f + len;
                    mbrlen();
                    bytes =  &mbstate;
                    if(bytes == 0) {
                        break;
                    }
                    if(bytes != -2) {
                        if(bytes != -1) {
                            len = len + bytes;
                             *__esp =  &mbstate;
                            mbsinit();
                            if( &mbstate == 0) {
                                continue;
                            }
                            break;
                        }
                        len = len + 1;
                        break;
                    }
                    _t346 = f + len;
                     *__esp = _t346;
                    strlen();
                    len =  &(_t346[len]);
                    break;
                }
                _n = len;
                _delta = width - _n;
                _incr = ( !(_delta >> 31) & _delta) + _n;
                if(_incr < maxsize - i) {
                    if(p != 0) {
                        if(digits == 0 && _delta > 0) {
                            if(pad != 48) {
                                _v1604 = _delta;
                                _v1608 = 32;
                                 *__esp = p;
                                memset();
                                p =  &(p[_delta]);
                            } else {
                                _v1604 = _delta;
                                _v1608 = 48;
                                 *__esp = p;
                                memset();
                                p =  &(p[_delta]);
                            }
                        }
                        if(to_lowcase == 0) {
                            if(to_uppcase == 0) {
                                _v1604 = _n;
                                _v1608 = f;
                                 *__esp = p;
                                memcpy();
                            } else {
                                memcpy_uppcase(p, f, _n);
                            }
                        } else {
                            memcpy_lowcase(p, f, _n);
                        }
                        p =  &(p[_n]);
                    }
                    i = i + _incr;
                    f = f + len - 1;
                    goto L92;
                }
                _v1564 = 0;
                goto L98;
            } else {
L16:
                _n = 1;
                _delta = width - _n;
                _incr = ( !(_delta >> 31) & _delta) + _n;
                if(_incr < maxsize - i) {
                    if(p != 0) {
                        if(digits == 0 && _delta > 0) {
                            if(pad != 48) {
                                _v1604 = _delta;
                                _v1608 = 32;
                                 *__esp = p;
                                memset();
                                p =  &(p[_delta]);
                            } else {
                                _v1604 = _delta;
                                _v1608 = 48;
                                 *__esp = p;
                                memset();
                                p =  &(p[_delta]);
                            }
                        }
                         *p =  *f & 255;
                        p =  &(p[_n]);
                    }
                    i = i + _incr;
L92:
                    f =  &(f[1]);
                    continue;
                } else {
                    _v1564 = 0;
L98:
                    _t342 = _v1564;
                    if((_v16 ^  *gs:0x14]) == 0) {
                        return _t342;
                    }
                    __stack_chk_fail();
                    return _t342;
                }
            }
        }
        if(_v1568 >= 38) {
            goto L16;
        }
        if(_v1568 > 35) {
            if(_v1568 == 37) {
                while(1) {
                    f =  &(f[1]);
                    _v1560 =  *f & 255;
                    if(_v1560 == 48) {
                        goto L57;
                    }
L51:
                    if(_v1560 > 48) {
                        if(_v1560 == 94) {
                            to_uppcase = 1;
                            while(1) {
                                f =  &(f[1]);
                                _v1560 =  *f & 255;
                                if(_v1560 == 48) {
                                    goto L57;
                                }
                                goto L51;
                            }
                            goto L57;
                        }
                        if(_v1560 != 95) {
L60:
                            if(( *f & 255) - 48 > 9) {
L68:
                                _v1556 =  *f & 255;
                                if(_v1556 == 69 || _v1556 == 79) {
                                    modifier =  *f & 255;
                                    f =  &(f[1]);
                                } else {
                                    modifier = 0;
                                }
                                format_char =  *f & 255;
                                if(format_char > 122) {
                                    flen = 1;
                                    while(1 != 37) {
                                        flen = flen + 1;
                                    }
                                    _n = flen;
                                    _delta = width - _n;
                                    _incr = ( !(_delta >> 31) & _delta) + _n;
                                    if(_incr < maxsize - i) {
                                        if(p != 0) {
                                            if(digits == 0 && _delta > 0) {
                                                if(pad != 48) {
                                                    _v1604 = _delta;
                                                    _v1608 = 32;
                                                     *__esp = p;
                                                    memset();
                                                    p =  &(p[_delta]);
                                                } else {
                                                    _v1604 = _delta;
                                                    _v1608 = 48;
                                                     *__esp = p;
                                                    memset();
                                                    p =  &(p[_delta]);
                                                }
                                            }
                                            if(to_lowcase == 0) {
                                                if(to_uppcase == 0) {
                                                    _v1604 = _n;
                                                    _v1608 = f + 1 - flen;
                                                     *__esp = p;
                                                    memcpy();
                                                } else {
                                                    memcpy_uppcase(p, f + 1 - flen, _n);
                                                }
                                            } else {
                                                memcpy_lowcase(p, f + 1 - flen, _n);
                                            }
                                            p =  &(p[_n]);
                                        }
                                        i = i + _incr;
                                        goto L92;
                                    }
                                    _v1564 = 0;
                                    goto L98;
                                } else {
                                    goto __eax;
                                }
                            }
                            width = 0;
                            do {
                                if(width > 214748364 || width == 214748364 && ( *f & 255) - 48 > 7) {
                                    width = 2147483647;
                                } else {
                                    width = (width << 2) + width + (width << 2) + width;
                                    width = width + ( *f & 255) - 48;
                                }
                                f =  &(f[1]);
                            } while(( *f & 255) - 48 <= 9);
                            goto L68;
                        }
                        goto L57;
                    }
                    if(_v1560 == 35) {
                        change_case = 1;
                        continue;
                    }
                    if(_v1560 == 45) {
                        goto L57;
                    }
                    goto L60;
L57:
                    pad =  *f & 255;
                }
            } else {
                goto L26;
            }
        }
        if(_v1568 >= 32 || _v1568 - 8 <= 5) {
            goto L16;
        } else {
            goto L26;
        }
    }
    if(p != 0 && maxsize != 0) {
         *p = 0;
    }
    _v1564 = i;
    goto L98;
}

int iso_week_days(int yday, int wday)
{// addr = 0x0805865E  --  defined in 'strftime.c' at line 371
    int big_enough_multiple_of_7;          // _cfa_fffffff4
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    signed int _t35;                       // _t35

    big_enough_multiple_of_7 = 378;
    _t35 = yday - wday + 4 + big_enough_multiple_of_7;
    _v32 = -1840700269;
    _v28 = ((_v32 * _t35 >> 32) + _t35 >> 2) - (_t35 >> 31);
    _v28 = _t35 - (_v28 << 3) - _v28;
    return yday - _v28 + 3;
}

size_t nstrftime(char* s, size_t maxsize, const char* format, const struct tm* tp, int ut, int ns)
{// addr = 0x080586BB  --  defined in 'strftime.c' at line 1442
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    return strftime_case_(0, s, maxsize, format, tp, ut, ns);
}

char* umaxtostr(uintmax_t i, char* buf)
{// addr = 0x080586FC  --  defined in 'inttostr.c' at line 30
    char* p;                               // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t42;                       // _t42

    _v28 = i;
    _v24 = buf;
    p =  *((intOrPtr*)(__ebp + 16)) + 20;
     *p = 0;
    do {
        p = p - 1;
         *p = __umoddi3(_v28, _v24, 10, 0) + 48;
        _t42 = _v24;
        _v28 = __udivdi3(_v28, _t42, 10, 0);
        _v24 = _t42;
    } while((_v24 | _v28) != 0);
    return p;
}

int rpl_vfprintf(FILE* fp, const char* format, va_list args)
{// addr = 0x08058788  --  defined in 'vfprintf.c' at line 44
    signed int _v8;                        // _cfa_fffffff8
    char[1999] buf;                        // _cfa_fffff828
    char* output;                          // _cfa_fffff824
    size_t len;         // _cfa_fffff820
    size_t lenbuf;      // _cfa_fffff81c
    int saved_errno;                       // _cfa_fffff818
    FILE* _v2040;         // _cfa_fffff808
    const char* _v2044;   // _cfa_fffff804
    char* _v2048;                          // _cfa_fffff800
    int _v2052;                            // _cfa_fffff7fc
    FILE* _v2064;         // _cfa_fffff7f0 (outparam)
    intOrPtr _v2068;                       // _cfa_fffff7ec (outparam)
    intOrPtr _v2072;                       // _cfa_fffff7e8 (outparam)
    char* _t55;                            // _t55
    intOrPtr* _t56;                        // _t56
    int _t57;                              // _t57
    char* _t61;                            // _t61

    _v2040 = fp;
    _v2044 = format;
    _v2048 = args;
    _v8 =  *gs:0x14];
    lenbuf = 2000;
    output = vasnprintf( &buf,  &lenbuf, _v2044, _v2048);
    len = lenbuf;
    if(output != 0) {
        _v2064 = _v2040;
        _v2068 = len;
        _v2072 = 1;
        _t55 = output;
         *__esp = _t55;
        fwrite();
        if(_t55 >= len) {
            _t56 = len;
            if(_t56 >= 0) {
                _v2052 = len;
            } else {
                __errno_location();
                 *_t56 = 75;
                fseterr(_v2040);
                _v2052 = -1;
            }
        } else {
            if(output !=  &buf) {
                __errno_location();
                saved_errno = buf;
                _t61 = output;
                 *__esp = _t61;
                free();
                __errno_location();
                 *_t61 = saved_errno;
            }
            _v2052 = -1;
        }
    } else {
        fseterr(_v2040);
        _v2052 = -1;
    }
    _t57 = _v2052;
    if((_v8 ^  *gs:0x14]) == 0) {
        return _t57;
    } else {
        __stack_chk_fail();
        return _t57;
    }
}

_Unknown_base* xnmalloc(size_t n, size_t s)
{// addr = 0x080588F0  --  defined in 'xalloc.h' at line 113
    if(-1 / s < n) {
        xalloc_die();
    }
    return xmalloc(n * s);
}

_Unknown_base* xnrealloc(_Unknown_base* p, size_t n, size_t s)
{// addr = 0x0805891E  --  defined in 'xalloc.h' at line 124
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    if(-1 / s < n) {
        xalloc_die();
    }
    return xrealloc(p, n * s);
}

_Unknown_base* x2nrealloc(_Unknown_base* p, size_t* pn, size_t s)
{// addr = 0x08058953  --  defined in 'xalloc.h' at line 187
    size_t n;           // _cfa_fffffff8
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    n =  *pn;
    if(p != 0) {
        if(-1431655766 / s <= n) {
            xalloc_die();
        }
        n = n + (n + 1 >> 1);
    } else {
        if(n == 0) {
            n = 64 / s;
            n = n + (n == 0 & 255);
        }
    }
     *pn = n;
    return xrealloc(p, n * s);
}

char* xcharalloc(size_t n)
{// addr = 0x080589CE  --  defined in 'xalloc.h' at line 224
    return xmalloc(n);
}

_Unknown_base* xmalloc(size_t n)
{// addr = 0x080589E1  --  defined in 'xmalloc.c' at line 48
    _Unknown_base* p;                      // _cfa_fffffff8
    _Unknown_base* _t6;                    // _t6

    _t6 = n;
     *__esp = _t6;
    malloc();
    p = _t6;
    if(p == 0 && n != 0) {
        xalloc_die();
    }
    return p;
}

_Unknown_base* xrealloc(_Unknown_base* p, size_t n)
{// addr = 0x08058A0B  --  defined in 'xmalloc.c' at line 60
    unsigned int _v8;                      // _cfa_fffffff8
    _Unknown_base* _t9;                    // _t9

    _v8 = n;
    _t9 = p;
     *__esp = _t9;
    realloc();
    p = _t9;
    if(p == 0 && n != 0) {
        xalloc_die();
    }
    return p;
}

_Unknown_base* x2realloc(_Unknown_base* p, size_t* pn)
{// addr = 0x08058A3C  --  defined in 'xmalloc.c' at line 75
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return x2nrealloc(p, pn, 1);
}

_Unknown_base* xzalloc(size_t s)
{// addr = 0x08058A5E  --  defined in 'xmalloc.c' at line 85
    _Unknown_base* _v20;                   // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _Unknown_base* _t6;                    // _t6
    _Unknown_base* _t7;                    // _t7

    _t6 = xmalloc(s);
    _t7 = s;
    _v20 = _t7;
    _v24 = 0;
     *__esp = _t6;
    memset();
    return _t7;
}

_Unknown_base* xcalloc(size_t n, size_t s)
{// addr = 0x08058A8A  --  defined in 'xmalloc.c' at line 94
    _Unknown_base* p;                      // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    _Unknown_base* _t8;                    // _t8

    _v24 = s;
    _t8 = n;
     *__esp = _t8;
    calloc();
    p = _t8;
    if(p == 0) {
        xalloc_die();
    }
    return p;
}

_Unknown_base* xmemdup(* p, size_t s)
{// addr = 0x08058AB5  --  defined in 'xmalloc.c' at line 112
    unsigned int _v20;                     // _cfa_ffffffec
    _Unknown_base* _v24;                   // _cfa_ffffffe8
    _Unknown_base* _t7;                    // _t7
    _Unknown_base* _t9;                    // _t9

    _t7 = xmalloc(s);
    _v20 = s;
    _t9 = p;
    _v24 = _t9;
     *__esp = _t7;
    memcpy();
    return _t9;
}

char* xstrdup(const char* string)
{// addr = 0x08058AE0  --  defined in 'xmalloc.c' at line 120
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)
    const char* _t4;   // _t4

    _t4 = string;
     *__esp = _t4;
    strlen();
    return xmemdup(string,  &(_t4[1]));
}

void xstrtol_error(union strtol_error err, int opt_idx, char c, const struct option* long_options, const char* arg, int exit_status)
{// addr = 0x08058B08  --  defined in 'xstrtol-error.c' at line 51
    char _v5;                              // _cfa_fffffffb
    char[1] option_buffer;                 // _cfa_fffffffa
    const char* hyphens;   // _cfa_fffffff4
    const char* msgid;   // _cfa_fffffff0
    const char* option;   // _cfa_ffffffec
    signed char _v24;                      // _cfa_ffffffe8
    union strtol_error _v28;   // _cfa_ffffffe4
    const char* _v40;   // _cfa_ffffffd8
    const char* _v44;   // _cfa_ffffffd4
    const char* _v48;   // _cfa_ffffffd0
    const char* _v52;   // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    const char** _t38;   // _t38
    const char* _t40;   // _t40

    _v24 = c;
    hyphens = 134618868;
    _v28 = err;
    if(_v28 > 3) {
        __eflags = _v28 - 4;
        if(__eflags != 0) {
            goto L5;
        }
        goto L6;
    } else {
        if(_v28 >= 2) {
            msgid = "invalid suffix in %s%s argument `%s'";
        } else {
            if(_v28 == 1) {
                msgid = "%s%s argument `%s' too large";
            } else {
L5:
                abort();
L6:
                msgid = "invalid %s%s argument `%s'";
            }
        }
    }
    if(opt_idx >= 0) {
        _t38 = long_options + (opt_idx << 4);
        __eflags = _t38;
        option =  *_t38;
    } else {
        hyphens = hyphens +  ~opt_idx;
        option_buffer = _v24 & 255;
        _v5 = 0;
        option =  &option_buffer;
    }
    _t40 = msgid;
     *__esp = _t40;
    gettext();
    _v40 = arg;
    _v44 = option;
    _v48 = hyphens;
    _v52 = _t40;
    _v56 = 0;
     *__esp = exit_failure;
    error();
}

void xstrtol_fatal(union strtol_error err, int opt_idx, char c, const struct option* long_options, const char* arg)
{// addr = 0x08058BC6  --  defined in 'xstrtol-error.c' at line 95
    signed int* _v0;                       // _cfa_0
    char _v8;                              // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    signed int _v36;                       // _cfa_ffffffdc (outparam)
    intOrPtr* _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _v60;                       // _cfa_ffffffc4
    signed int _t50;                       // _t50
    _unknown_ _t51;                        // _t51

    _v8 = c;
    xstrtol_error(err, opt_idx, _v8, long_options, arg, exit_failure);
    abort();
    _push(_t51);
    __esp = __esp - 12;
    _v60 = _v36;
    __eflags = -1 / _v60 -  *_v40;
    if(__eflags >= 0) {
        _t50 =  *_v0 * err;
        __eflags = _t50;
         *_v0 = _t50;
        _v12 = 0;
    } else {
         *_v0 = -1;
        _v12 = 1;
    }
}

strtol_error bkm_scale(long unsigned int* x, int scale_factor)
{// addr = 0x08058C08  --  defined in 'xstrtol.c' at line 48
    union strtol_error _v8;   // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0

    _v16 = scale_factor;
    if(-1 / _v16 >=  *x) {
         *x =  *x * scale_factor;
        _v8 = 0;
    } else {
         *x = -1;
        _v8 = 1;
    }
    return _v8;
}

strtol_error bkm_scale_by_power(long unsigned int* x, int base, int power)
{// addr = 0x08058C5A  --  defined in 'xstrtol.c' at line 65
    strtol_error err;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    err = 0;
    while(1) {
        power = power - 1;
        if(power == 0) {
            break;
        }
        err = err | bkm_scale(x, base);
    }
    return err;
}

strtol_error xstrtoul(const char* s, char** ptr, int strtol_base, long unsigned int* val, const char* valid_suffixes)
{// addr = 0x08058C92  --  defined in 'xstrtol.c' at line 77
    strtol_error overflow;   // _cfa_ffffffd8
    unsigned char ch;                      // _cfa_fffffffb
    char* t_ptr;                           // _cfa_fffffff4
    char** p;                              // _cfa_fffffff0
    long unsigned int tmp;                 // _cfa_ffffffec
    strtol_error err;   // _cfa_ffffffe8
    const char* q;   // _cfa_ffffffe4
    int base;                              // _cfa_ffffffe0
    int suffixes;                          // _cfa_ffffffdc
    signed int _v56;                       // _cfa_ffffffc8
    union strtol_error _v60;   // _cfa_ffffffc4
    char** _v64;                           // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v80;                            // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    unsigned char _t89;                    // _t89
    signed int _t95;                       // _t95
    long unsigned int _t99;                // _t99
    char* _t101;                           // _t101
    intOrPtr* _t102;                       // _t102
    const char* _t113;   // _t113
    const char* _t114;   // _t114
    const char* _t143;   // _t143

    err = 0;
    if(strtol_base < 0 || strtol_base > 36) {
        _v80 = "xstrtoul";
        _v84 = 83;
        _v88 = "xstrtol.c";
         *__esp = "0 <= strtol_base && strtol_base <= 36";
        __assert_fail();
    }
    if(ptr != 0) {
        _v64 = ptr;
    } else {
        _v64 =  &t_ptr;
    }
    p = _v64;
    q = s;
    _t89 =  *q & 255;
    ch = _t89;
    do {
        __ctype_b_loc();
        _t95 =  *( *_t89 + (ch & 255) + (ch & 255)) & 0x2000;
    } while(_t95 != 0);
    if(ch != 45) {
        __errno_location();
         *_t95 = 0;
        _v84 = strtol_base;
        _v88 = p;
        _t99 = s;
         *__esp = _t99;
        strtoul();
        tmp = _t99;
        _t101 =  *p;
        if(_t101 != s) {
            __errno_location();
            _t102 =  *_t101;
            if(_t102 == 0) {
L21:
                if(valid_suffixes != 0) {
                    if(( *( *p) & 255) == 0) {
                         *val = tmp;
                        _v60 = err;
L38:
                        return _v60;
                    }
                    base = 1024;
                    suffixes = 1;
                    _v88 =  *( *p) & 255;
                    _t113 = valid_suffixes;
                     *__esp = _t113;
                    strchr();
                    if(_t113 != 0) {
                        _v88 = 48;
                        _t114 = valid_suffixes;
                         *__esp = _t114;
                        strchr();
                        if(_t114 == 0) {
L34:
                            _v68 = ( *( *p) & 255) - 66;
                            if(_v68 > 53) {
                                 *val = tmp;
                                _v60 = err | 2;
                                goto L38;
                            }
                            goto __eax;
                        }
                        _v56 = ( *p)[1] & 255;
                        if(_v56 == 68) {
L33:
                            base = 1000;
                            suffixes = suffixes + 1;
                            goto L34;
                        }
                        if(_v56 == 105) {
                            if((( *p)[2] & 255) == 66) {
                                suffixes = suffixes + 2;
                            }
                            goto L34;
                        }
                        if(_v56 == 66) {
                            goto L33;
                        }
                        goto L34;
                    }
                     *val = tmp;
                    _v60 = err | 2;
                    goto L38;
                }
                 *val = tmp;
                _v60 = err;
                goto L38;
            }
            __errno_location();
            if( *_t102 == 34) {
                err = 1;
                goto L21;
            }
            _v60 = 4;
            goto L38;
        }
        if(valid_suffixes == 0 || ( *( *p) & 255) == 0) {
L16:
            _v60 = 4;
            goto L38;
        } else {
            _v88 =  *( *p) & 255;
            _t143 = valid_suffixes;
             *__esp = _t143;
            strchr();
            if(_t143 == 0) {
                goto L16;
            }
            tmp = 1;
            goto L21;
        }
    }
    _v60 = 4;
    goto L38;
}

void fseterr(FILE* fp)
{// addr = 0x08059078  --  defined in 'fseterr.c' at line 26
    fp->_flags = fp->_flags | 32;
}

char* xstrndup(const _None* string, size_t n)
{// addr = 0x0805908C  --  defined in 'xstrndup.c' at line 31
    char* s;                               // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    char* _t8;                             // _t8

    _v24 = n;
    _t8 = string;
     *__esp = _t8;
    strndup();
    s = _t8;
    if(s == 0) {
        xalloc_die();
    }
    return s;
}

strtol_error bkm_scale(uintmax_t* x, int scale_factor)
{// addr = 0x080590B8  --  defined in 'xstrtol.c' at line 48
    long long unsigned int _v24;           // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    union strtol_error _v40;   // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    uintmax_t* _t33;   // _t33
    uintmax_t* _t34;   // _t34
    signed int _t35;                       // _t35
    uintmax_t* _t39;   // _t39
    signed int _t42;                       // _t42
    uintmax_t* _t43;   // _t43
    signed int _t45;                       // _t45

    _t31 = scale_factor;
    _t45 = scale_factor >> 31;
    _v36 = __udivdi3(-1, -1, _t31, _t45);
    _v32 = _t45;
    _t33 = x;
    _v28 =  *_t33;
    _v24 = _t33[0];
    if(_v32 > _v24 || _v32 >= _v24 && _v36 >= _v28) {
        _t34 = x;
        _t42 =  *_t34;
        _t35 = scale_factor;
        _t43 = x;
         *_t43 = _t35 * _t42;
        _t43[0] = _t34[0] * _t35 + (_t35 >> 31) * _t42 + (_t35 * _t42 >> 32);
        _v40 = 0;
    } else {
        _t39 = x;
         *_t39 = -1;
        _t39[0] = -1;
        _v40 = 1;
    }
    return _v40;
}

strtol_error bkm_scale_by_power(uintmax_t* x, int base, int power)
{// addr = 0x08059166  --  defined in 'xstrtol.c' at line 65
    strtol_error err;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    err = 0;
    while(1) {
        power = power - 1;
        if(power == 0) {
            break;
        }
        err = err | bkm_scale(x, base);
    }
    return err;
}

strtol_error xstrtoumax(const char* s, char** ptr, int strtol_base, uintmax_t* val, const char* valid_suffixes)
{// addr = 0x0805919E  --  defined in 'xstrtol.c' at line 77
    strtol_error overflow;   // _cfa_ffffffdc
    unsigned char ch;                      // _cfa_fffffffb
    char* t_ptr;                           // _cfa_fffffff4
    char** p;                              // _cfa_fffffff0
    strtol_error err;   // _cfa_ffffffec
    const char* q;   // _cfa_ffffffe8
    int base;                              // _cfa_ffffffe4
    int suffixes;                          // _cfa_ffffffe0
    union strtol_error _v40;   // _cfa_ffffffd8
    uintmax_t tmp;   // _cfa_ffffffd4
    signed int _v56;                       // _cfa_ffffffc8
    union strtol_error _v60;   // _cfa_ffffffc4
    char** _v64;                           // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v80;                            // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    unsigned char _t99;                    // _t99
    signed int _t105;                      // _t105
    long long unsigned int _t109;          // _t109
    char* _t111;                           // _t111
    intOrPtr* _t112;                       // _t112
    const char* _t123;   // _t123
    const char* _t124;   // _t124
    const char* _t153;   // _t153
    uintmax_t* _t155;   // _t155
    uintmax_t* _t156;   // _t156
    uintmax_t* _t157;   // _t157
    uintmax_t* _t158;   // _t158
    union strtol_error _t160;   // _t160

    err = 0;
    if(strtol_base < 0 || strtol_base > 36) {
        _v80 = "xstrtoumax";
        _v84 = 83;
        _v88 = "xstrtol.c";
         *__esp = "0 <= strtol_base && strtol_base <= 36";
        __assert_fail();
    }
    if(ptr != 0) {
        _v64 = ptr;
    } else {
        _v64 =  &t_ptr;
    }
    p = _v64;
    q = s;
    _t99 =  *q & 255;
    ch = _t99;
    do {
        __ctype_b_loc();
        _t160 =  *_t99;
        _t105 =  *(_t160 + (ch & 255) + (ch & 255)) & 0x2000;
    } while(_t105 != 0);
    if(ch != 45) {
        __errno_location();
         *_t105 = 0;
        _v84 = strtol_base;
        _v88 = p;
        _t109 = s;
         *__esp = _t109;
        strtoumax();
        tmp = _t109;
        _v40 = _t160;
        _t111 =  *p;
        if(_t111 != s) {
            __errno_location();
            _t112 =  *_t111;
            if(_t112 == 0) {
L21:
                if(valid_suffixes != 0) {
                    if(( *( *p) & 255) == 0) {
                        _t155 = val;
                         *_t155 = tmp;
                        _t155[0] = _v40;
                        _v60 = err;
L38:
                        return _v60;
                    }
                    base = 1024;
                    suffixes = 1;
                    _v88 =  *( *p) & 255;
                    _t123 = valid_suffixes;
                     *__esp = _t123;
                    strchr();
                    if(_t123 != 0) {
                        _v88 = 48;
                        _t124 = valid_suffixes;
                         *__esp = _t124;
                        strchr();
                        if(_t124 == 0) {
L34:
                            _v68 = ( *( *p) & 255) - 66;
                            if(_v68 > 53) {
                                _t156 = val;
                                 *_t156 = tmp;
                                _t156[0] = _v40;
                                _v60 = err | 2;
                                goto L38;
                            }
                            goto __eax;
                        }
                        _v56 = ( *p)[1] & 255;
                        if(_v56 == 68) {
L33:
                            base = 1000;
                            suffixes = suffixes + 1;
                            goto L34;
                        }
                        if(_v56 == 105) {
                            if((( *p)[2] & 255) == 66) {
                                suffixes = suffixes + 2;
                            }
                            goto L34;
                        }
                        if(_v56 == 66) {
                            goto L33;
                        }
                        goto L34;
                    }
                    _t157 = val;
                     *_t157 = tmp;
                    _t157[0] = _v40;
                    _v60 = err | 2;
                    goto L38;
                }
                _t158 = val;
                 *_t158 = tmp;
                _t158[0] = _v40;
                _v60 = err;
                goto L38;
            }
            __errno_location();
            if( *_t112 == 34) {
                err = 1;
                goto L21;
            }
            _v60 = 4;
            goto L38;
        }
        if(valid_suffixes == 0 || ( *( *p) & 255) == 0) {
L16:
            _v60 = 4;
            goto L38;
        } else {
            _v88 =  *( *p) & 255;
            _t153 = valid_suffixes;
             *__esp = _t153;
            strchr();
            if(_t153 == 0) {
                goto L16;
            }
            tmp = 1;
            _v40 = 0;
            goto L21;
        }
    }
    _v60 = 4;
    goto L38;
}

int close_stream(FILE* stream)
{// addr = 0x080595A4  --  defined in 'close-stream.c' at line 54
    _Bool some_pending;                    // _cfa_fffffffb
    _Bool prev_fail;                       // _cfa_fffffffa
    _Bool fclose_fail;                     // _cfa_fffffff9
    int _v24;                              // _cfa_ffffffe8
    FILE* _t14;           // _t14
    FILE* _t16;           // _t16
    FILE* _t18;           // _t18
    signed int _t21;                       // _t21
    signed int _t24;                       // _t24

    _t14 = stream;
     *__esp = _t14;
    __fpending();
    some_pending = _t14 != 0;
    _t16 = stream;
     *__esp = _t16;
    ferror_unlocked();
    prev_fail = _t16 != 0;
    _t18 = stream;
     *__esp = _t18;
    fclose();
    fclose_fail = _t18 != 0;
    if(prev_fail != 0) {
L4:
        _t21 = fclose_fail & 255 ^ 1;
        if(_t21 != 0) {
            __errno_location();
             *_t21 = 0;
        }
        _v24 = -1;
    } else {
        _t24 = fclose_fail & 255 ^ 1;
        if(_t24 != 0) {
L7:
            _v24 = 0;
        } else {
            if(some_pending != 0) {
                goto L4;
            } else {
                __errno_location();
                if( *_t24 == 9) {
                    goto L7;
                } else {
                    goto L4;
                }
            }
        }
    }
    return _v24;
}

int is_infinitel(long double x)
{// addr = 0x08059634  --  defined in 'vasnprintf.c' at line 251
    int _v8;                               // _cfa_fffffff8
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _t17;                              // _t17
    signed int _t18;                       // _t18

     *__esp = x;
    _v24 = _a8;
    _v20 = _a12;
    _t17 = rpl_isnanl();
    if(_t17 != 0) {
L4:
        _v8 = 1;
L6:
        return _v8;
    }
    asm("faddp st1, st0");
    asm("fucompp");
    asm("fnstsw ax");
    asm("sahf");
    _t18 = _t17 == 0 & _t17 ?_? 0 ^ 1;
    if(_t18 != 0) {
L5:
        _v8 = 0;
        goto L6;
    }
    asm("fldz");
    asm("fxch st0, st1");
    asm("fucompp");
    asm("fnstsw ax");
    asm("sahf");
    if(_t18 != 0 || _t18 != 0) {
        goto L4;
    } else {
        goto L5;
    }
}

char* vasnprintf(char* resultbuf, size_t* lengthp, const char* format, va_list args)
{// addr = 0x0805969A  --  defined in 'vasnprintf.c' at line 1419
    fpucw_t _ncw;      // _cfa_fffffc54
    fpucw_t _ncw;      // _cfa_fffffc54
    int[1] prefixes;                       // _cfa_fffffbe4
    int count;                             // _cfa_fffffc54
    int arg;                               // _cfa_fffffc48
    unsigned int arg;                      // _cfa_fffffc44
    int arg;                               // _cfa_fffffc40
    unsigned int arg;                      // _cfa_fffffc3c
    int arg;                               // _cfa_fffffc38
    unsigned int arg;                      // _cfa_fffffc34
    long int arg;                          // _cfa_fffffc30
    long unsigned int arg;                 // _cfa_fffffc2c
    long long int arg;                     // _cfa_fffffbdc
    long long unsigned int arg;            // _cfa_fffffbd4
    double arg;                            // _cfa_fffffbcc
    long double arg;                       // _cfa_fffffba4
    int arg;                               // _cfa_fffffc28
    wint_t arg;         // _cfa_fffffc24
    const char* arg;   // _cfa_fffffc20
    const wchar_t* arg;   // _cfa_fffffc1c
    _Unknown_base* arg;                    // _cfa_fffffc18
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    char[699] tmpbuf;                      // _cfa_fffffd24
    fpucw_t oldcw;     // _cfa_fffffd22
    size_t buf_neededlength;   // _cfa_fffffd1c
    char* buf;                             // _cfa_fffffd18
    char* buf_malloced;                    // _cfa_fffffd14
    const char* cp;   // _cfa_fffffd10
    size_t i;           // _cfa_fffffd0c
    char_directive* dp;   // _cfa_fffffd08
    char* result;                          // _cfa_fffffd04
    size_t allocated;   // _cfa_fffffd00
    size_t length;      // _cfa_fffffcfc
    size_t buf_memsize;   // _cfa_fffffcf8
    size_t n;           // _cfa_fffffcf4
    size_t augmented_length;   // _cfa_fffffcf0
    size_t memory_size;   // _cfa_fffffcec
    char* memory;                          // _cfa_fffffce8
    size_t augmented_length;   // _cfa_fffffce4
    size_t memory_size;   // _cfa_fffffce0
    char* memory;                          // _cfa_fffffcdc
    int flags;                             // _cfa_fffffcd8
    int has_width;                         // _cfa_fffffcd4
    size_t width;       // _cfa_fffffcd0
    int has_precision;                     // _cfa_fffffccc
    size_t precision;   // _cfa_fffffcc8
    size_t tmp_length;   // _cfa_fffffcc4
    char* tmp;                             // _cfa_fffffcc0
    char* pad_ptr;                         // _cfa_fffffcbc
    char* p;                               // _cfa_fffffcb8
    int arg;                               // _cfa_fffffcb4
    const char* digitp;   // _cfa_fffffcb0
    int arg;                               // _cfa_fffffcac
    const char* digitp;   // _cfa_fffffca8
    size_t tmp_memsize;   // _cfa_fffffca4
    int sign;                              // _cfa_fffffca0
    size_t pad;         // _cfa_fffffc9c
    char* end;                             // _cfa_fffffc98
    char* q;                               // _cfa_fffffc94
    char* q;                               // _cfa_fffffc90
    size_t count;       // _cfa_fffffc8c
    size_t n;           // _cfa_fffffc88
    size_t memory_size;   // _cfa_fffffc84
    char* memory;                          // _cfa_fffffc80
    arg_type type;    // _cfa_fffffc7c
    int flags;                             // _cfa_fffffc78
    char* fbp;                             // _cfa_fffffc74
    unsigned int prefix_count;             // _cfa_fffffc70
    size_t n;           // _cfa_fffffc6c
    size_t n;           // _cfa_fffffc64
    size_t memory_size;   // _cfa_fffffc5c
    char* memory;                          // _cfa_fffffc58
    fpucw_t _cw;       // _cfa_fffffc54
    int retcount;                          // _cfa_fffffc50
    size_t maxlen;      // _cfa_fffffc4c
    size_t bigger_need;   // _cfa_fffffc14
    size_t memory_size;   // _cfa_fffffc10
    char* memory;                          // _cfa_fffffc0c
    size_t n;           // _cfa_fffffc08
    size_t memory_size;   // _cfa_fffffc04
    char* memory;                          // _cfa_fffffc00
    size_t memory_size;   // _cfa_fffffbfc
    char* memory;                          // _cfa_fffffbf8
    char* memory;                          // _cfa_fffffbf4
    char* _v1040;                          // _cfa_fffffbf0
    arguments a;     // _cfa_fffffbec
    unsigned int _v1092;                   // _cfa_fffffbbc
    unsigned int _v1096;                   // _cfa_fffffbb8
    long double arg;                       // _cfa_fffffbb4
    unsigned int _v1120;                   // _cfa_fffffba0
    unsigned int _v1124;                   // _cfa_fffffb9c
    char_directive* _v1128;   // _cfa_fffffb98
    char_directives d;   // _cfa_fffffb94
    char* _v1136;                          // _cfa_fffffb90
    size_t* _v1140;     // _cfa_fffffb8c
    const char* _v1144;   // _cfa_fffffb88
    char* _v1148;                          // _cfa_fffffb84
    int _v1152;                            // _cfa_fffffb80
    unsigned int _v1156;                   // _cfa_fffffb7c
    int _v1160;                            // _cfa_fffffb78
    unsigned int _v1164;                   // _cfa_fffffb74
    unsigned int _v1168;                   // _cfa_fffffb70
    int _v1172;                            // _cfa_fffffb6c
    unsigned int _v1176;                   // _cfa_fffffb68
    unsigned int _v1180;                   // _cfa_fffffb64
    int _v1184;                            // _cfa_fffffb60
    unsigned int _v1188;                   // _cfa_fffffb5c
    unsigned int _v1192;                   // _cfa_fffffb58
    unsigned int _v1196;                   // _cfa_fffffb54
    unsigned int _v1200;                   // _cfa_fffffb50
    unsigned int _v1204;                   // _cfa_fffffb4c
    unsigned int _v1208;                   // _cfa_fffffb48
    unsigned int _v1212;                   // _cfa_fffffb44
    unsigned int _v1216;                   // _cfa_fffffb40
    unsigned int _v1220;                   // _cfa_fffffb3c
    int _v1224;                            // _cfa_fffffb38
    unsigned int _v1228;                   // _cfa_fffffb34
    char* _v1232;                          // _cfa_fffffb30
    char* _v1236;                          // _cfa_fffffb2c
    union  _v1240;                         // _cfa_fffffb28
    signed int _v1248;                     // _cfa_fffffb20
    char _v1336;                           // _cfa_fffffac8
    _unknown_ _v1360;                      // _cfa_fffffab0 (outparam)
    unsigned int _v1364;                   // _cfa_fffffaac (outparam)
    unsigned int _v1368;                   // _cfa_fffffaa8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    char* _t947;                           // _t947
    char* _t952;                           // _t952
    char* _t953;                           // _t953
    char* _t954;                           // _t954
    unsigned int _t962;                    // _t962
    char* _t976;                           // _t976
    unsigned int _t979;                    // _t979
    char* _t985;                           // _t985
    char* _t992;                           // _t992
    char_directive* _t998;   // _t998
    char_directive* _t1000;   // _t1000
    char_directive* _t1002;   // _t1002
    char_directive* _t1004;   // _t1004
    signed int _t1008;                     // _t1008
    char_directive* _t1032;   // _t1032
    char_directive* _t1033;   // _t1033
    char_directive* _t1035;   // _t1035
    char_directive* _t1036;   // _t1036
    char_directive* _t1042;   // _t1042
    char_directive* _t1044;   // _t1044
    unsigned int _t1047;                   // _t1047
    char* _t1066;                          // _t1066
    char* _t1080;                          // _t1080
    char* _t1087;                          // _t1087
    char* _t1096;                          // _t1096
    char* _t1106;                          // _t1106
    char* _t1113;                          // _t1113
    unsigned int _t1134;                   // _t1134
    char* _t1137;                          // _t1137
    char* _t1144;                          // _t1144
    signed int _t1152;                     // _t1152
    signed int _t1162;                     // _t1162
    _unknown_ _t1207;                      // _t1207
    char* _t1209;                          // _t1209
    char_directive* _t1212;   // _t1212
    char_directive* _t1213;   // _t1213
    char_directive* _t1215;   // _t1215
    char_directive* _t1216;   // _t1216
    char* _t1225;                          // _t1225
    _unknown_ _t1230;                      // _t1230
    char* _t1233;                          // _t1233
    char* _t1237;                          // _t1237
    char* _t1262;                          // _t1262
    char* _t1269;                          // _t1269
    char_directive* _t1301;   // _t1301
    char_directive* _t1307;   // _t1307
    char_directive* _t1315;   // _t1315
    char_directive* _t1320;   // _t1320
    char_directive* _t1328;   // _t1328
    char_directive* _t1333;   // _t1333
    signed int _t1344;                     // _t1344
    char_directive* _t1353;   // _t1353
    char_directive* _t1363;   // _t1363
    signed int _t1369;                     // _t1369
    char_directive* _t1380;   // _t1380
    char_directive* _t1382;   // _t1382
    char_directive* _t1384;   // _t1384
    char_directive* _t1386;   // _t1386
    char_directive* _t1388;   // _t1388
    char_directive* _t1390;   // _t1390
    char_directive* _t1392;   // _t1392
    char_directive* _t1401;   // _t1401
    char* _t1413;                          // _t1413
    char* _t1420;                          // _t1420
    char* _t1440;                          // _t1440
    char* _t1447;                          // _t1447
    char* _t1466;                          // _t1466
    char* _t1502;                          // _t1502
    char* _t1518;                          // _t1518
    char* _t1520;                          // _t1520
    char* _t1551;                          // _t1551
    char* _t1556;                          // _t1556

    _v1136 = resultbuf;
    _v1140 = lengthp;
    _v1144 = format;
    _v1148 = args;
    _v32 =  *gs:0x14];
    if(printf_parse(_v1144,  &d,  &a) >= 0) {
        _t947 = printf_fetchargs(_v1148,  &a);
        __eflags = _t947;
        if(_t947 >= 0) {
            buf_neededlength = xsum4(7, _v1124, _v1120, 6);
            __eflags = buf_neededlength - 3999;
            if(buf_neededlength > 3999) {
                buf_memsize = buf_neededlength;
                __eflags = buf_memsize - -1;
                if(buf_memsize == -1) {
                    goto L344;
                }
                _t954 = buf_memsize;
                 *__esp = _t954;
                malloc();
                buf = _t954;
                __eflags = buf;
                if(buf == 0) {
                    goto L344;
                } else {
                    buf_malloced = buf;
                    goto L11;
                }
            } else {
                __esp = __esp - (buf_neededlength + 0x1e >> 4 << 4);
                _v1232 =  &_v1336;
                _v1232 =  &(_v1232[0xf]) >> 4 << 4;
                buf = _v1232;
                buf_malloced = 0;
L11:
                __eflags = _v1136;
                if(_v1136 == 0) {
                    result = 0;
                    allocated = 0;
                } else {
                    result = _v1136;
                    allocated =  *_v1140;
                }
                length = 0;
                cp = _v1144;
                i = 0;
                dp = _v1128;
                while(1) {
                    __eflags = dp->dir_start - cp;
                    if(dp->dir_start == cp) {
                        goto L36;
                    }
                    n = dp->dir_start - cp;
                    augmented_length = xsum(length, n);
                    __eflags = augmented_length - allocated;
                    if(augmented_length <= allocated) {
L35:
                        _v1364 = n;
                        _v1368 = cp;
                         *__esp =  &(result[length]);
                        memcpy();
                        length = augmented_length;
                    } else {
                        __eflags = allocated;
                        if(allocated == 0) {
                            _v1228 = 12;
                        } else {
                            __eflags = allocated;
                            if(allocated < 0) {
                                _v1224 = -1;
                            } else {
                                _v1224 = allocated + allocated;
                            }
                            _v1228 = _v1224;
                        }
                        allocated = _v1228;
                        __eflags = augmented_length - allocated;
                        if(augmented_length > allocated) {
                            allocated = augmented_length;
                        }
                        memory_size = allocated;
                        __eflags = memory_size - -1;
                        if(memory_size == -1) {
L339:
                            __eflags = result - _v1136;
                            if(result != _v1136) {
                                __eflags = result;
                                if(result != 0) {
                                     *__esp = result;
                                    free();
                                }
                            }
                            __eflags = buf_malloced;
                            if(buf_malloced != 0) {
                                 *__esp = buf_malloced;
                                free();
                            }
L344:
                             *__esp = _v1128;
                            free();
                            _t952 = _v1040;
                            __eflags = _t952;
                            if(_t952 != 0) {
                                _t952 = _v1040;
                                 *__esp = _t952;
                                free();
                            }
                            __errno_location();
                             *_t952 = 12;
                            _v1236 = 0;
                            goto L347;
                        }
                        __eflags = result - _v1136;
                        if(result == _v1136) {
L28:
                            _t1440 = memory_size;
                             *__esp = _t1440;
                            malloc();
                            memory = _t1440;
L30:
                            __eflags = memory;
                            if(memory == 0) {
                                goto L339;
                            } else {
                                __eflags = result - _v1136;
                                if(result == _v1136) {
                                    __eflags = length;
                                    if(length != 0) {
                                        _v1364 = length;
                                        _v1368 = result;
                                         *__esp = memory;
                                        memcpy();
                                    }
                                }
                                result = memory;
                                goto L35;
                            }
                        }
                        __eflags = result;
                        if(result != 0) {
                            _v1368 = memory_size;
                            _t1447 = result;
                             *__esp = _t1447;
                            realloc();
                            memory = _t1447;
                            goto L30;
                        }
                        goto L28;
                    }
L36:
                    __eflags = d.__val - i;
                    if(d.__val == i) {
                        _t962 = xsum(length, 1);
                        __eflags = _t962 - allocated;
                        if(_t962 <= allocated) {
L322:
                            result[length] = 0;
                            __eflags = result - _v1136;
                            if(result != _v1136) {
                                __eflags = length + 1 - allocated;
                                if(length + 1 < allocated) {
                                    _v1368 = length + 1;
                                    _t976 = result;
                                     *__esp = _t976;
                                    realloc();
                                    memory = _t976;
                                    __eflags = memory;
                                    if(memory != 0) {
                                        result = memory;
                                    }
                                }
                            }
                            __eflags = buf_malloced;
                            if(buf_malloced != 0) {
                                 *__esp = buf_malloced;
                                free();
                            }
                             *__esp = _v1128;
                            free();
                            __eflags = _v1040;
                            if(_v1040 != 0) {
                                 *__esp = _v1040;
                                free();
                            }
                             *_v1140 = length;
                            _v1236 = result;
                            goto L347;
                        }
                        __eflags = allocated;
                        if(allocated == 0) {
                            _v1156 = 12;
                        } else {
                            __eflags = allocated;
                            if(allocated < 0) {
                                _v1152 = -1;
                            } else {
                                _v1152 = allocated + allocated;
                            }
                            _v1156 = _v1152;
                        }
                        allocated = _v1156;
                        _t979 = xsum(length, 1);
                        __eflags = _t979 - allocated;
                        if(_t979 > allocated) {
                            allocated = xsum(length, 1);
                        }
                        memory_size = allocated;
                        __eflags = memory_size - -1;
                        if(memory_size == -1) {
                            goto L339;
                        } else {
                            __eflags = result - _v1136;
                            if(result == _v1136) {
L315:
                                _t985 = memory_size;
                                 *__esp = _t985;
                                malloc();
                                memory = _t985;
L317:
                                __eflags = memory;
                                if(memory == 0) {
                                    goto L339;
                                }
                                __eflags = result - _v1136;
                                if(result == _v1136) {
                                    __eflags = length;
                                    if(length != 0) {
                                        _v1364 = length;
                                        _v1368 = result;
                                         *__esp = memory;
                                        memcpy();
                                    }
                                }
                                result = memory;
                                goto L322;
                            }
                            __eflags = result;
                            if(result != 0) {
                                _v1368 = memory_size;
                                _t992 = result;
                                 *__esp = _t992;
                                realloc();
                                memory = _t992;
                                goto L317;
                            }
                            goto L315;
                        }
                    }
                    _t998 = dp;
                    __eflags = (_t998->conversion & 255) - 37;
                    if((_t998->conversion & 255) != 37) {
                        _t1000 = dp;
                        __eflags = _t1000->arg_index - -1;
                        if(_t1000->arg_index == -1) {
                            abort();
                        }
                        _t1002 = dp;
                        __eflags = (_t1002->conversion & 255) - 110;
                        if((_t1002->conversion & 255) != 110) {
L66:
                            _t1004 = dp;
                            __eflags = (_t1004->conversion & 255) - 102;
                            if((_t1004->conversion & 255) == 102) {
L74:
                                _t1502 = _v1040;
                                _t1008 = dp->arg_index << 4;
                                __eflags = _t1502[_t1008] - 12;
                                if(_t1502[_t1008] != 12) {
L181:
                                    type =  *(_v1040 + (dp->arg_index << 4));
                                    flags = dp->flags;
                                    fbp = buf;
                                     *fbp = 37;
                                    fbp =  &(fbp[1]);
                                    __eflags = flags & 1;
                                    if((flags & 1) != 0) {
                                         *fbp = 39;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                    }
                                    __eflags = flags & 2;
                                    if((flags & 2) != 0) {
                                         *fbp = 45;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                    }
                                    __eflags = flags & 4;
                                    if((flags & 4) != 0) {
                                         *fbp = 43;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                    }
                                    __eflags = flags & 8;
                                    if((flags & 8) != 0) {
                                         *fbp = 32;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                    }
                                    __eflags = flags & 16;
                                    if((flags & 16) != 0) {
                                         *fbp = 35;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                    }
                                    __eflags = flags & 32;
                                    if((flags & 32) != 0) {
                                         *fbp = 48;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                    }
                                    _t1032 = dp;
                                    _t1033 = dp;
                                    __eflags = _t1032->width_start - _t1033->width_end;
                                    if(_t1032->width_start != _t1033->width_end) {
                                        n = dp->width_end - dp->width_start;
                                        _v1364 = n;
                                        _v1368 = dp->width_start;
                                         *__esp = fbp;
                                        memcpy();
                                        fbp =  &(fbp[n]);
                                        __eflags = fbp;
                                    }
                                    _t1035 = dp;
                                    _t1036 = dp;
                                    __eflags = _t1035->precision_start - _t1036->precision_end;
                                    if(_t1035->precision_start != _t1036->precision_end) {
                                        n = dp->precision_end - dp->precision_start;
                                        _v1364 = n;
                                        _v1368 = dp->precision_start;
                                         *__esp = fbp;
                                        memcpy();
                                        fbp =  &(fbp[n]);
                                        __eflags = fbp;
                                    }
                                    __eflags = type - 16;
                                    if(type > 16) {
L204:
                                         *fbp = dp->conversion & 255;
                                        fbp[1] = 0;
                                        prefix_count = 0;
                                        _t1042 = dp;
                                        __eflags = _t1042->width_arg_index - -1;
                                        if(_t1042->width_arg_index != -1) {
                                            _t1520 = _v1040;
                                            _t1162 = dp->width_arg_index << 4;
                                            __eflags = _t1520[_t1162] - 5;
                                            if(_t1520[_t1162] != 5) {
                                                abort();
                                            }
                                             *(__ebp + prefix_count * 4 - 1048) = (_v1040 + (dp->width_arg_index << 4))[1];
                                            prefix_count = prefix_count + 1;
                                            __eflags = prefix_count;
                                        }
                                        _t1044 = dp;
                                        __eflags = _t1044->precision_arg_index - -1;
                                        if(_t1044->precision_arg_index != -1) {
                                            _t1518 = _v1040;
                                            _t1152 = dp->precision_arg_index << 4;
                                            __eflags = _t1518[_t1152] - 5;
                                            if(_t1518[_t1152] != 5) {
                                                abort();
                                            }
                                             *(__ebp + prefix_count * 4 - 1048) = (_v1040 + (dp->precision_arg_index << 4))[1];
                                            prefix_count = prefix_count + 1;
                                            __eflags = prefix_count;
                                        }
                                        _t1047 = xsum(length, 2);
                                        __eflags = _t1047 - allocated;
                                        if(_t1047 <= allocated) {
L231:
                                            result[length] = 0;
                                            while(1) {
                                                _cw = -1;
                                                retcount = 0;
                                                maxlen = allocated - length;
                                                __eflags = maxlen;
                                                if(maxlen < 0) {
                                                    maxlen = 2147483647;
                                                }
                                                __eflags = type - 17;
                                                if(type <= 17) {
                                                    break;
                                                }
                                                abort();
                                                __eflags = _cw;
                                                if(_cw < 0) {
                                                    __eflags = fbp[1] & 255;
                                                    if((fbp[1] & 255) == 0) {
                                                        __eflags = retcount;
                                                        if(retcount >= 0) {
                                                            _cw = retcount;
L268:
                                                            __eflags = _cw;
                                                            if(_cw >= 0) {
                                                                __eflags = _cw + 1 - maxlen;
                                                                if(_cw + 1 < maxlen) {
                                                                    length = length + _cw;
                                                                    __eflags = length;
                                                                    goto L302;
                                                                }
                                                                __eflags = maxlen - 2147483647;
                                                                if(maxlen == 2147483647) {
                                                                    __eflags = result - _v1136;
                                                                    if(result != _v1136) {
                                                                        __eflags = result;
                                                                        if(result != 0) {
                                                                             *__esp = result;
                                                                            free();
                                                                        }
                                                                    }
                                                                    __eflags = buf_malloced;
                                                                    if(buf_malloced != 0) {
                                                                         *__esp = buf_malloced;
                                                                        free();
                                                                    }
                                                                     *__esp = _v1128;
                                                                    free();
                                                                    _t1066 = _v1040;
                                                                    __eflags = _t1066;
                                                                    if(_t1066 != 0) {
                                                                        _t1066 = _v1040;
                                                                         *__esp = _t1066;
                                                                        free();
                                                                    }
                                                                    __errno_location();
                                                                     *_t1066 = 75;
                                                                    _v1236 = 0;
                                                                    goto L347;
                                                                }
                                                                __eflags = allocated;
                                                                if(allocated < 0) {
                                                                    _v1168 = -1;
                                                                } else {
                                                                    _v1168 = allocated + allocated;
                                                                }
                                                                n = xmax(xsum(length, _cw + 2), _v1168);
                                                                __eflags = n - allocated;
                                                                if(n <= allocated) {
                                                                    continue;
                                                                } else {
                                                                    __eflags = allocated;
                                                                    if(allocated == 0) {
                                                                        _v1164 = 12;
                                                                    } else {
                                                                        __eflags = allocated;
                                                                        if(allocated < 0) {
                                                                            _v1160 = -1;
                                                                        } else {
                                                                            _v1160 = allocated + allocated;
                                                                        }
                                                                        _v1164 = _v1160;
                                                                    }
                                                                    allocated = _v1164;
                                                                    __eflags = n - allocated;
                                                                    if(n > allocated) {
                                                                        allocated = n;
                                                                    }
                                                                    memory_size = allocated;
                                                                    __eflags = memory_size - -1;
                                                                    if(memory_size == -1) {
                                                                        goto L339;
                                                                    } else {
                                                                        __eflags = result - _v1136;
                                                                        if(result == _v1136) {
L294:
                                                                            _t1080 = memory_size;
                                                                             *__esp = _t1080;
                                                                            malloc();
                                                                            memory = _t1080;
L296:
                                                                            __eflags = memory;
                                                                            if(memory == 0) {
                                                                                goto L339;
                                                                            }
                                                                            __eflags = result - _v1136;
                                                                            if(result == _v1136) {
                                                                                __eflags = length;
                                                                                if(length != 0) {
                                                                                    _v1364 = length;
                                                                                    _v1368 = result;
                                                                                     *__esp = memory;
                                                                                    memcpy();
                                                                                }
                                                                            }
                                                                            result = memory;
                                                                            continue;
                                                                        }
                                                                        __eflags = result;
                                                                        if(result != 0) {
                                                                            _v1368 = memory_size;
                                                                            _t1087 = result;
                                                                             *__esp = _t1087;
                                                                            realloc();
                                                                            memory = _t1087;
                                                                            goto L296;
                                                                        }
                                                                        goto L294;
                                                                    }
                                                                }
                                                            }
                                                            __eflags = result - _v1136;
                                                            if(result != _v1136) {
                                                                __eflags = result;
                                                                if(result != 0) {
                                                                     *__esp = result;
                                                                    free();
                                                                }
                                                            }
                                                            __eflags = buf_malloced;
                                                            if(buf_malloced != 0) {
                                                                 *__esp = buf_malloced;
                                                                free();
                                                            }
                                                             *__esp = _v1128;
                                                            free();
                                                            _t1096 = _v1040;
                                                            __eflags = _t1096;
                                                            if(_t1096 != 0) {
                                                                _t1096 = _v1040;
                                                                 *__esp = _t1096;
                                                                free();
                                                            }
                                                            __errno_location();
                                                             *_t1096 = 22;
                                                            _v1236 = 0;
                                                            goto L347;
                                                        }
                                                        __eflags = allocated;
                                                        if(allocated < 0) {
                                                            _v1180 = -1;
                                                        } else {
                                                            _v1180 = allocated + allocated;
                                                        }
                                                        bigger_need = xsum(_v1180, 12);
                                                        __eflags = bigger_need - allocated;
                                                        if(bigger_need <= allocated) {
                                                            continue;
                                                        } else {
                                                            __eflags = allocated;
                                                            if(allocated == 0) {
                                                                _v1176 = 12;
                                                            } else {
                                                                __eflags = allocated;
                                                                if(allocated < 0) {
                                                                    _v1172 = -1;
                                                                } else {
                                                                    _v1172 = allocated + allocated;
                                                                }
                                                                _v1176 = _v1172;
                                                            }
                                                            allocated = _v1176;
                                                            __eflags = bigger_need - allocated;
                                                            if(bigger_need > allocated) {
                                                                allocated = bigger_need;
                                                            }
                                                            memory_size = allocated;
                                                            __eflags = memory_size - -1;
                                                            if(memory_size == -1) {
                                                                goto L339;
                                                            } else {
                                                                __eflags = result - _v1136;
                                                                if(result == _v1136) {
L260:
                                                                    _t1106 = memory_size;
                                                                     *__esp = _t1106;
                                                                    malloc();
                                                                    memory = _t1106;
L262:
                                                                    __eflags = memory;
                                                                    if(memory == 0) {
                                                                        goto L339;
                                                                    }
                                                                    __eflags = result - _v1136;
                                                                    if(result == _v1136) {
                                                                        __eflags = length;
                                                                        if(length != 0) {
                                                                            _v1364 = length;
                                                                            _v1368 = result;
                                                                             *__esp = memory;
                                                                            memcpy();
                                                                        }
                                                                    }
                                                                    result = memory;
                                                                    continue;
                                                                }
                                                                __eflags = result;
                                                                if(result != 0) {
                                                                    _v1368 = memory_size;
                                                                    _t1113 = result;
                                                                     *__esp = _t1113;
                                                                    realloc();
                                                                    memory = _t1113;
                                                                    goto L262;
                                                                }
                                                                goto L260;
                                                            }
                                                        }
                                                    }
                                                    fbp[1] = 0;
                                                    continue;
                                                }
                                                __eflags = _cw - maxlen;
                                                if(_cw < maxlen) {
                                                    __eflags = result[_cw + length] & 255;
                                                    if((result[_cw + length] & 255) != 0) {
                                                        abort();
                                                    }
                                                }
                                                __eflags = retcount - _cw;
                                                if(retcount > _cw) {
                                                    _cw = retcount;
                                                }
                                                goto L268;
                                            }
                                            goto __eax;
                                        } else {
                                            __eflags = allocated;
                                            if(allocated == 0) {
                                                _v1188 = 12;
                                            } else {
                                                __eflags = allocated;
                                                if(allocated < 0) {
                                                    _v1184 = -1;
                                                } else {
                                                    _v1184 = allocated + allocated;
                                                }
                                                _v1188 = _v1184;
                                            }
                                            allocated = _v1188;
                                            _t1134 = xsum(length, 2);
                                            __eflags = _t1134 - allocated;
                                            if(_t1134 > allocated) {
                                                allocated = xsum(length, 2);
                                            }
                                            memory_size = allocated;
                                            __eflags = memory_size - -1;
                                            if(memory_size == -1) {
                                                goto L339;
                                            } else {
                                                __eflags = result - _v1136;
                                                if(result == _v1136) {
L224:
                                                    _t1137 = memory_size;
                                                     *__esp = _t1137;
                                                    malloc();
                                                    memory = _t1137;
L226:
                                                    __eflags = memory;
                                                    if(memory == 0) {
                                                        goto L339;
                                                    }
                                                    __eflags = result - _v1136;
                                                    if(result == _v1136) {
                                                        __eflags = length;
                                                        if(length != 0) {
                                                            _v1364 = length;
                                                            _v1368 = result;
                                                             *__esp = memory;
                                                            memcpy();
                                                        }
                                                    }
                                                    result = memory;
                                                    goto L231;
                                                }
                                                __eflags = result;
                                                if(result != 0) {
                                                    _v1368 = memory_size;
                                                    _t1144 = result;
                                                     *__esp = _t1144;
                                                    realloc();
                                                    memory = _t1144;
                                                    goto L226;
                                                }
                                                goto L224;
                                            }
                                        }
                                    } else {
                                        _v1248 = 1 << type;
                                        __eflags = _v1248 & 82304;
                                        if((_v1248 & 82304) != 0) {
L202:
                                             *fbp = 108;
                                            fbp =  &(fbp[1]);
                                            goto L204;
                                        }
                                        __eflags = _v1248 & 4096;
                                        if((_v1248 & 4096) != 0) {
                                             *fbp = 76;
                                            fbp =  &(fbp[1]);
                                            __eflags = fbp;
                                            goto L204;
                                        }
                                        __eflags = _v1248 & 1536;
                                        if((_v1248 & 1536) == 0) {
                                            goto L204;
                                        }
                                         *fbp = 108;
                                        fbp =  &(fbp[1]);
                                        __eflags = fbp;
                                        goto L202;
                                    }
                                }
                                _t1207 = _v1040 + (dp->arg_index << 4);
                                 *__esp =  *(_t1207 + 4);
                                _v1368 =  *(_t1207 + 8);
                                _v1364 =  *(_t1207 + 12);
                                _t1209 = is_infinitel();
                                __eflags = _t1209;
                                if(_t1209 == 0) {
                                    goto L181;
                                }
                                flags = dp->flags;
                                has_width = 0;
                                width = 0;
                                _t1212 = dp;
                                _t1213 = dp;
                                __eflags = _t1212->width_start - _t1213->width_end;
                                if(_t1212->width_start == _t1213->width_end) {
L89:
                                    has_precision = 0;
                                    precision = 0;
                                    _t1215 = dp;
                                    _t1216 = dp;
                                    __eflags = _t1215->precision_start - _t1216->precision_end;
                                    if(_t1215->precision_start == _t1216->precision_end) {
L102:
                                        __eflags = has_precision;
                                        if(has_precision == 0) {
                                            precision = 6;
                                        }
                                        tmp_length = 0;
                                        __eflags = tmp_length - precision;
                                        if(tmp_length < precision) {
                                            tmp_length = precision;
                                        }
                                        tmp_length = xsum(tmp_length, 12);
                                        __eflags = tmp_length - width;
                                        if(tmp_length < width) {
                                            tmp_length = width;
                                        }
                                        tmp_length = xsum(tmp_length, 1);
                                        __eflags = tmp_length - 700;
                                        if(tmp_length > 700) {
                                            tmp_memsize = tmp_length;
                                            __eflags = tmp_memsize - -1;
                                            if(tmp_memsize == -1) {
                                                goto L339;
                                            }
                                            _t1225 = tmp_memsize;
                                             *__esp = _t1225;
                                            malloc();
                                            tmp = _t1225;
                                            __eflags = tmp;
                                            if(tmp == 0) {
                                                goto L339;
                                            }
                                            goto L112;
                                        } else {
                                            tmp =  &tmpbuf;
L112:
                                            pad_ptr = 0;
                                            p = tmp;
                                            _t1230 = _v1040 + (dp->arg_index << 4);
                                            arg =  *(_t1230 + 4);
                                            _v1096 =  *(_t1230 + 8);
                                            _v1092 =  *(_t1230 + 12);
                                             *__esp = arg;
                                            _v1368 = _v1096;
                                            _v1364 = _v1092;
                                            _t1233 = rpl_isnanl();
                                            __eflags = _t1233;
                                            if(_t1233 == 0) {
                                                sign = 0;
                                                asm("fnstcw word [ebp-0x3a8]");
                                                oldcw = _cw & 65535;
                                                _cw = oldcw & 65535 | 3;
                                                asm("fldcw word [ebp-0x3a8]");
                                                _t1237 = arg;
                                                 *__esp = _t1237;
                                                _v1368 = _v1096;
                                                _v1364 = _v1092;
                                                __signbitl();
                                                __eflags = _t1237;
                                                if(_t1237 != 0) {
                                                    sign = -1;
                                                    asm("fchs");
                                                    tword [ebp-0x448] = tword [ebp-0x448];
                                                }
                                                __eflags = sign;
                                                if(__eflags >= 0) {
                                                    __eflags = flags & 4;
                                                    if(__eflags == 0) {
                                                        __eflags = flags & 8;
                                                        if(__eflags != 0) {
                                                             *p = 32;
                                                            p =  &(p[1]);
                                                            __eflags = p;
                                                        }
                                                    } else {
                                                         *p = 43;
                                                        p =  &(p[1]);
                                                    }
                                                } else {
                                                     *p = 45;
                                                    p =  &(p[1]);
                                                }
                                                asm("fldz");
                                                asm("fxch st0, st1");
                                                asm("fucompp");
                                                asm("fnstsw ax");
                                                asm("sahf");
                                                __eflags = __eflags > 0 ^ 1;
                                                if(__eflags != 0) {
L132:
                                                    abort();
                                                    goto L133;
                                                } else {
                                                    asm("faddp st1, st0");
                                                    asm("fucompp");
                                                    asm("fnstsw ax");
                                                    asm("sahf");
                                                    if(__eflags != 0) {
                                                        goto L132;
                                                    }
                                                    _t1301 = dp;
                                                    __eflags = (_t1301->conversion & 255) - 64;
                                                    if((_t1301->conversion & 255) <= 64) {
L130:
                                                         *p = 105;
                                                        p =  &(p[1]);
                                                         *p = 110;
                                                        p =  &(p[1]);
                                                         *p = 102;
                                                        p =  &(p[1]);
                                                        __eflags = p;
L131:
                                                        _cw = oldcw & 65535;
                                                        asm("fldcw word [ebp-0x3a8]");
L133:
                                                        __eflags = has_width;
                                                        if(has_width == 0) {
L156:
                                                            count = p - tmp;
                                                            __eflags = count - tmp_length;
                                                            if(count >= tmp_length) {
                                                                abort();
                                                            }
                                                            __eflags = allocated - length - count;
                                                            if(allocated - length > count) {
L178:
                                                                _v1364 = count;
                                                                _v1368 = tmp;
                                                                 *__esp =  &(result[length]);
                                                                memcpy();
                                                                __eflags = tmp -  &tmpbuf;
                                                                if(tmp !=  &tmpbuf) {
                                                                     *__esp = tmp;
                                                                    free();
                                                                }
                                                                length = length + count;
                                                                goto L302;
                                                            } else {
                                                                n = xsum(length, count);
                                                                __eflags = n - allocated;
                                                                if(n <= allocated) {
                                                                    goto L178;
                                                                }
                                                                __eflags = allocated;
                                                                if(allocated == 0) {
                                                                    _v1196 = 12;
                                                                } else {
                                                                    __eflags = allocated;
                                                                    if(allocated < 0) {
                                                                        _v1192 = -1;
                                                                    } else {
                                                                        _v1192 = allocated + allocated;
                                                                    }
                                                                    _v1196 = _v1192;
                                                                }
                                                                allocated = _v1196;
                                                                __eflags = n - allocated;
                                                                if(n > allocated) {
                                                                    allocated = n;
                                                                }
                                                                memory_size = allocated;
                                                                __eflags = memory_size - -1;
                                                                if(memory_size == -1) {
                                                                    goto L339;
                                                                } else {
                                                                    __eflags = result - _v1136;
                                                                    if(result == _v1136) {
L171:
                                                                        _t1262 = memory_size;
                                                                         *__esp = _t1262;
                                                                        malloc();
                                                                        memory = _t1262;
L173:
                                                                        __eflags = memory;
                                                                        if(memory == 0) {
                                                                            goto L339;
                                                                        }
                                                                        __eflags = result - _v1136;
                                                                        if(result == _v1136) {
                                                                            __eflags = length;
                                                                            if(length != 0) {
                                                                                _v1364 = length;
                                                                                _v1368 = result;
                                                                                 *__esp = memory;
                                                                                memcpy();
                                                                            }
                                                                        }
                                                                        result = memory;
                                                                        goto L178;
                                                                    }
                                                                    __eflags = result;
                                                                    if(result != 0) {
                                                                        _v1368 = memory_size;
                                                                        _t1269 = result;
                                                                         *__esp = _t1269;
                                                                        realloc();
                                                                        memory = _t1269;
                                                                        goto L173;
                                                                    }
                                                                    goto L171;
                                                                }
                                                            }
                                                        }
                                                        __eflags = p - tmp - width;
                                                        if(p - tmp >= width) {
                                                            goto L156;
                                                        }
                                                        pad = tmp - p + width;
                                                        end =  &(p[pad]);
                                                        __eflags = flags & 2;
                                                        if((flags & 2) == 0) {
                                                            __eflags = flags & 32;
                                                            if((flags & 32) == 0) {
L149:
                                                                q = end;
                                                                while(1) {
                                                                    __eflags = p - tmp;
                                                                    if(p <= tmp) {
                                                                        break;
                                                                    }
                                                                    q = q - 1;
                                                                    p = p - 1;
                                                                    __eflags = p;
                                                                     *q =  *p & 255;
                                                                }
                                                                while(1) {
                                                                    __eflags = pad;
                                                                    if(pad == 0) {
                                                                        break;
                                                                    }
                                                                     *p = 32;
                                                                    p =  &(p[1]);
                                                                    pad = pad - 1;
                                                                    __eflags = pad;
                                                                }
L155:
                                                                p = end;
                                                                goto L156;
                                                            }
                                                            __eflags = pad_ptr;
                                                            if(pad_ptr == 0) {
                                                                goto L149;
                                                            }
                                                            q = end;
                                                            while(1) {
                                                                __eflags = p - pad_ptr;
                                                                if(p <= pad_ptr) {
                                                                    break;
                                                                }
                                                                q = q - 1;
                                                                p = p - 1;
                                                                __eflags = p;
                                                                 *q =  *p & 255;
                                                            }
                                                            while(1) {
                                                                __eflags = pad;
                                                                if(pad == 0) {
                                                                    break;
                                                                }
                                                                 *p = 48;
                                                                p =  &(p[1]);
                                                                pad = pad - 1;
                                                                __eflags = pad;
                                                            }
                                                            goto L155;
                                                        }
                                                        while(1) {
                                                            __eflags = pad;
                                                            if(pad == 0) {
                                                                break;
                                                            }
                                                             *p = 32;
                                                            p =  &(p[1]);
                                                            pad = pad - 1;
                                                            __eflags = pad;
                                                        }
                                                        goto L155;
                                                    }
                                                    _t1307 = dp;
                                                    __eflags = (_t1307->conversion & 255) - 90;
                                                    if((_t1307->conversion & 255) > 90) {
                                                        goto L130;
                                                    }
                                                     *p = 73;
                                                    p =  &(p[1]);
                                                     *p = 78;
                                                    p =  &(p[1]);
                                                     *p = 70;
                                                    p =  &(p[1]);
                                                    goto L131;
                                                }
                                            }
                                            _t1315 = dp;
                                            __eflags = (_t1315->conversion & 255) - 64;
                                            if((_t1315->conversion & 255) <= 64) {
L116:
                                                 *p = 110;
                                                p =  &(p[1]);
                                                 *p = 97;
                                                p =  &(p[1]);
                                                 *p = 110;
                                                p =  &(p[1]);
                                                goto L133;
                                            }
                                            _t1320 = dp;
                                            __eflags = (_t1320->conversion & 255) - 90;
                                            if((_t1320->conversion & 255) > 90) {
                                                goto L116;
                                            }
                                             *p = 78;
                                            p =  &(p[1]);
                                             *p = 65;
                                            p =  &(p[1]);
                                             *p = 78;
                                            p =  &(p[1]);
                                            goto L133;
                                        }
                                    }
                                    _t1328 = dp;
                                    __eflags = _t1328->precision_arg_index - -1;
                                    if(_t1328->precision_arg_index == -1) {
                                        digitp =  &(dp->precision_start[1]);
                                        precision = 0;
                                        while(1) {
                                            _t1333 = dp;
                                            __eflags = _t1333->precision_end - digitp;
                                            if(_t1333->precision_end == digitp) {
                                                break;
                                            }
                                            _v1204 = ( *digitp & 255) - 48;
                                            digitp =  &(digitp[1]);
                                            __eflags = precision - 429496729;
                                            if(precision > 429496729) {
                                                _v1200 = -1;
                                            } else {
                                                _v1200 = (precision << 2) + precision + (precision << 2) + precision;
                                            }
                                            precision = xsum(_v1200, _v1204);
                                        }
                                        has_precision = 1;
                                        goto L102;
                                    }
                                    _t1551 = _v1040;
                                    _t1344 = dp->precision_arg_index << 4;
                                    __eflags = _t1551[_t1344] - 5;
                                    if(_t1551[_t1344] != 5) {
                                        abort();
                                    }
                                    arg = (_v1040 + (dp->precision_arg_index << 4))[1];
                                    __eflags = arg;
                                    if(arg >= 0) {
                                        precision = arg;
                                        has_precision = 1;
                                    }
                                    goto L102;
                                }
                                _t1353 = dp;
                                __eflags = _t1353->width_arg_index - -1;
                                if(_t1353->width_arg_index == -1) {
                                    digitp = dp->width_start;
                                    do {
                                        _v1212 = ( *digitp & 255) - 48;
                                        digitp =  &(digitp[1]);
                                        __eflags = width - 429496729;
                                        if(width > 429496729) {
                                            _v1208 = -1;
                                        } else {
                                            _v1208 = (width << 2) + width + (width << 2) + width;
                                        }
                                        width = xsum(_v1208, _v1212);
                                        _t1363 = dp;
                                        __eflags = _t1363->width_end - digitp;
                                    } while(_t1363->width_end != digitp);
L88:
                                    has_width = 1;
                                    goto L89;
                                }
                                _t1556 = _v1040;
                                _t1369 = dp->width_arg_index << 4;
                                __eflags = _t1556[_t1369] - 5;
                                if(_t1556[_t1369] != 5) {
                                    abort();
                                }
                                arg = (_v1040 + (dp->width_arg_index << 4))[1];
                                __eflags = arg;
                                if(arg >= 0) {
                                    width = arg;
                                } else {
                                    flags = flags | 2;
                                    width =  ~arg;
                                }
                                goto L88;
                            }
                            _t1380 = dp;
                            __eflags = (_t1380->conversion & 255) - 70;
                            if((_t1380->conversion & 255) == 70) {
                                goto L74;
                            }
                            _t1382 = dp;
                            __eflags = (_t1382->conversion & 255) - 101;
                            if((_t1382->conversion & 255) == 101) {
                                goto L74;
                            }
                            _t1384 = dp;
                            __eflags = (_t1384->conversion & 255) - 69;
                            if((_t1384->conversion & 255) == 69) {
                                goto L74;
                            }
                            _t1386 = dp;
                            __eflags = (_t1386->conversion & 255) - 103;
                            if((_t1386->conversion & 255) == 103) {
                                goto L74;
                            }
                            _t1388 = dp;
                            __eflags = (_t1388->conversion & 255) - 71;
                            if((_t1388->conversion & 255) == 71) {
                                goto L74;
                            }
                            _t1390 = dp;
                            __eflags = (_t1390->conversion & 255) - 97;
                            if((_t1390->conversion & 255) == 97) {
                                goto L74;
                            }
                            _t1392 = dp;
                            __eflags = (_t1392->conversion & 255) - 65;
                            if((_t1392->conversion & 255) != 65) {
                                goto L181;
                            }
                            goto L74;
                        } else {
                            _v1240 =  *(_v1040 + (dp->arg_index << 4)) - 18;
                            __eflags = _v1240 - 4;
                            if(_v1240 > 4) {
                                abort();
                                goto L66;
                            }
                            goto __eax;
                        }
                    } else {
                        _t1401 = dp;
                        __eflags = _t1401->arg_index - -1;
                        if(_t1401->arg_index != -1) {
                            abort();
                        }
                        augmented_length = xsum(length, 1);
                        __eflags = augmented_length - allocated;
                        if(augmented_length <= allocated) {
L59:
                            result[length] = 37;
                            length = augmented_length;
L302:
                            cp = dp->dir_end;
                            i = i + 1;
                            dp = dp + 44;
                            continue;
                        }
                        __eflags = allocated;
                        if(allocated == 0) {
                            _v1220 = 12;
                        } else {
                            __eflags = allocated;
                            if(allocated < 0) {
                                _v1216 = -1;
                            } else {
                                _v1216 = allocated + allocated;
                            }
                            _v1220 = _v1216;
                        }
                        allocated = _v1220;
                        __eflags = augmented_length - allocated;
                        if(augmented_length > allocated) {
                            allocated = augmented_length;
                        }
                        memory_size = allocated;
                        __eflags = memory_size - -1;
                        if(memory_size == -1) {
                            goto L339;
                        } else {
                            __eflags = result - _v1136;
                            if(result == _v1136) {
L52:
                                _t1413 = memory_size;
                                 *__esp = _t1413;
                                malloc();
                                memory = _t1413;
L54:
                                __eflags = memory;
                                if(memory == 0) {
                                    goto L339;
                                }
                                __eflags = result - _v1136;
                                if(result == _v1136) {
                                    __eflags = length;
                                    if(length != 0) {
                                        _v1364 = length;
                                        _v1368 = result;
                                         *__esp = memory;
                                        memcpy();
                                    }
                                }
                                result = memory;
                                goto L59;
                            }
                            __eflags = result;
                            if(result != 0) {
                                _v1368 = memory_size;
                                _t1420 = result;
                                 *__esp = _t1420;
                                realloc();
                                memory = _t1420;
                                goto L54;
                            }
                            goto L52;
                        }
                    }
                }
            }
        } else {
             *__esp = _v1128;
            free();
            _t1466 = _v1040;
            __eflags = _t1466;
            if(_t1466 != 0) {
                _t1466 = _v1040;
                 *__esp = _t1466;
                free();
            }
            __errno_location();
             *_t1466 = 22;
            _v1236 = 0;
            goto L347;
        }
    } else {
        _v1236 = 0;
L347:
        _t953 = _v1236;
        if((_v32 ^  *gs:0x14]) != 0) {
            __stack_chk_fail();
        }
        return _t953;
    }
}

size_t xsum4(size_t size1, size_t size2, size_t size3, size_t size4)
{// addr = 0x0805CAD5  --  defined in 'xsize.h' at line 80
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return xsum(xsum(xsum(size1, size2), size3), size4);
}

size_t xmax(size_t size1, size_t size2)
{// addr = 0x0805CB11  --  defined in 'xsize.h' at line 90
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4

    _v12 = size2;
    _v8 = size1;
    if(_v8 < _v12) {
        _v8 = _v12;
    }
    return _v8;
}

size_t xsum(size_t size1, size_t size2)
{// addr = 0x0805CB36  --  defined in 'xsize.h' at line 59
    size_t sum;         // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8

    sum = size1 + size2;
    if(sum < size1) {
        _v24 = -1;
    } else {
        _v24 = sum;
    }
    return _v24;
}

int rpl_isnanl(long double x)
{// addr = 0x0805CB64  --  defined in 'isnan.c' at line 72
    unsigned int exponent;                 // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    memory_double m;   // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0

    m = x;
    _v24 = _a8;
    _v20 = _a12;
    exponent = _v20 & 32767;
    if(exponent != 0) {
        if(exponent != 32767) {
            _v32 = _v24 >> 31 ^ 1;
        } else {
            _v32 = (m | _v24 ^ -2147483648) != 0 & 255;
        }
    } else {
        _v32 = _v24 >> 31;
    }
    return _v32;
}

int printf_fetchargs(va_list args, arguments* a)
{// addr = 0x0805CBD0  --  defined in 'printf-args.c' at line 39
    size_t i;           // _cfa_fffffff4
    argument* ap;     // _cfa_fffffff0
    int _v28;                              // _cfa_ffffffe4
    union  _v32;                           // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1

    i = 0;
    ap = a->arg;
    if(a->count > i) {
        _v32 = ap->type;
        if(_v32 <= 22) {
            goto __eax;
        }
        _v28 = -1;
    } else {
        _v28 = 0;
    }
    return _v28;
}

int printf_parse(const char* format, char_directives* d, arguments* a)
{// addr = 0x0805CE8C  --  defined in 'printf-parse.c' at line 84
    arg_type type;    // _cfa_ffffff9c
    size_t n;           // _cfa_ffffff94
    size_t memory_size;   // _cfa_ffffff90
    argument* memory;   // _cfa_ffffff8c
    size_t memory_size;   // _cfa_ffffff88
    char_directive* memory;   // _cfa_ffffff84
    char c;                                // _cfa_fffffffb
    const char* cp;   // _cfa_fffffff4
    size_t arg_posn;    // _cfa_fffffff0
    size_t d_allocated;   // _cfa_ffffffec
    size_t a_allocated;   // _cfa_ffffffe8
    size_t max_width_length;   // _cfa_ffffffe4
    size_t max_precision_length;   // _cfa_ffffffe0
    size_t arg_index;   // _cfa_ffffffdc
    char_directive* dp;   // _cfa_ffffffd8
    const char* np;   // _cfa_ffffffd4
    size_t n;           // _cfa_ffffffd0
    const char* np;   // _cfa_ffffffcc
    size_t n;           // _cfa_ffffffc8
    size_t n;           // _cfa_ffffffc4
    size_t memory_size;   // _cfa_ffffffc0
    argument* memory;   // _cfa_ffffffbc
    size_t width_length;   // _cfa_ffffffb8
    const char* np;   // _cfa_ffffffb4
    size_t n;           // _cfa_ffffffb0
    size_t n;           // _cfa_ffffffac
    size_t memory_size;   // _cfa_ffffffa8
    argument* memory;   // _cfa_ffffffa4
    size_t precision_length;   // _cfa_ffffffa0
    int flags;                             // _cfa_ffffff98
    int _v136;                             // _cfa_ffffff78
    argument* _v160;   // _cfa_ffffff60
    unsigned int _v164;                    // _cfa_ffffff5c
    unsigned int _v168;                    // _cfa_ffffff58
    unsigned int _v172;                    // _cfa_ffffff54
    unsigned int _v176;                    // _cfa_ffffff50
    argument* _v180;   // _cfa_ffffff4c
    unsigned int _v184;                    // _cfa_ffffff48
    unsigned int _v188;                    // _cfa_ffffff44
    unsigned int _v192;                    // _cfa_ffffff40
    unsigned int _v196;                    // _cfa_ffffff3c
    unsigned int _v200;                    // _cfa_ffffff38
    unsigned int _v204;                    // _cfa_ffffff34
    char _v208;                            // _cfa_ffffff30
    unsigned int _v216;                    // _cfa_ffffff28 (outparam)
    char_directive* _t464;   // _t464
    char_directive* _t467;   // _t467
    char_directive* _t531;   // _t531
    argument* _t597;   // _t597
    unsigned int _t601;                    // _t601
    argument* _t687;   // _t687
    unsigned int _t690;                    // _t690
    signed int _t802;                      // _t802
    signed int _t822;                      // _t822

    cp = format;
    arg_posn = 0;
    max_width_length = 0;
    max_precision_length = 0;
    d->count = 0;
    d_allocated = 1;
    _t464 = d_allocated * 44;
     *__esp = _t464;
    malloc();
    d->dir = _t464;
    _t467 = d->dir;
    if(_t467 == 0) {
L160:
        __errno_location();
        _t467->dir_start = 12;
        _v136 = -1;
    } else {
        a->count = 0;
        a_allocated = 0;
        a->arg = 0;
        while(( *cp & 255) != 0) {
            c =  *cp & 255;
            cp =  &(cp[1]);
            if(c != 37) {
                continue;
            }
            arg_index = -1;
            dp = d->dir + d->count * 44;
            dp->dir_start = cp - 1;
            dp->flags = 0;
            dp->width_start = 0;
            dp->width_end = 0;
            dp->width_arg_index = -1;
            dp->precision_start = 0;
            dp->precision_end = 0;
            dp->precision_arg_index = -1;
            dp->arg_index = -1;
            if(( *cp & 255) <= 47) {
L20:
                while(1) {
                    do {
                        do {
                            do {
                                do {
                                    do {
L20:
                                    } while(( *cp & 255) == 39);
                                } while(( *cp & 255) == 45);
                            } while(( *cp & 255) == 43);
                        } while(( *cp & 255) == 32);
                    } while(( *cp & 255) == 35);
                    if(( *cp & 255) != 48) {
                        if(( *cp & 255) != 42) {
                            if(( *cp & 255) <= 47 || ( *cp & 255) > 57) {
L83:
                                if(( *cp & 255) != 46) {
L133:
                                    flags = 0;
L134:
                                    while(( *cp & 255) != 104) {
                                        if(( *cp & 255) != 76) {
                                            if(( *cp & 255) != 108) {
                                                if(( *cp & 255) != 106) {
                                                    if(( *cp & 255) == 122 || ( *cp & 255) == 90) {
                                                        cp =  &(cp[1]);
                                                    } else {
                                                        if(( *cp & 255) != 116) {
                                                            c =  *cp & 255;
                                                            cp =  &(cp[1]);
                                                            _v208 = c - 37;
                                                            if(_v208 > 83) {
L151:
                                                                if(a->arg != 0) {
                                                                     *__esp = a->arg;
                                                                    free();
                                                                }
                                                                _t531 = d->dir;
                                                                if(_t531 != 0) {
                                                                    _t531 = d->dir;
                                                                     *__esp = _t531;
                                                                    free();
                                                                }
                                                                __errno_location();
                                                                _t531->dir_start = 22;
                                                                _v136 = -1;
L161:
                                                                return _v136;
                                                            }
                                                            goto __eax;
                                                        }
                                                        cp =  &(cp[1]);
                                                    }
                                                    continue;
                                                }
                                                flags = flags + 16;
                                                cp =  &(cp[1]);
                                                continue;
                                            }
                                            flags = flags + 8;
                                            cp =  &(cp[1]);
                                            continue;
                                        }
                                        flags = flags | 4;
                                        cp =  &(cp[1]);
                                    }
                                    flags = flags | 1 << (flags & 1);
                                    cp =  &(cp[1]);
                                    goto L134;
                                }
                                cp =  &(cp[1]);
                                if(( *cp & 255) != 42) {
                                    dp->precision_start = cp - 1;
                                    while(( *cp & 255) > 47 && ( *cp & 255) <= 57) {
                                        cp =  &(cp[1]);
                                    }
                                    dp->precision_end = cp;
                                    precision_length = dp->precision_end - dp->precision_start;
                                    if(max_precision_length < precision_length) {
                                        max_precision_length = precision_length;
                                    }
                                    goto L133;
                                }
                                dp->precision_start = cp - 1;
                                cp =  &(cp[1]);
                                dp->precision_end = cp;
                                if(max_precision_length <= 1) {
                                    max_precision_length = 2;
                                }
                                if(( *cp & 255) <= 47 || ( *cp & 255) > 57) {
L104:
                                    if(dp->precision_arg_index != -1) {
L106:
                                        n = dp->precision_arg_index;
                                        if(n < a_allocated) {
L122:
                                            while(a->count <= n) {
                                                _t802 = a->count;
                                                 *(a->arg + (_t802 << 4)) = 0;
                                                a->count = _t802 + 1;
                                            }
                                            if( *((intOrPtr*)(a->arg + (n << 4))) != 0) {
                                                if( *((intOrPtr*)(a->arg + (n << 4))) != 5) {
                                                    goto L151;
                                                }
                                                goto L133;
                                            }
                                             *((intOrPtr*)(a->arg + (n << 4))) = 5;
                                            goto L133;
                                        }
                                        if(a_allocated < 0) {
                                            _v168 = -1;
                                        } else {
                                            _v168 = a_allocated + a_allocated;
                                        }
                                        a_allocated = _v168;
                                        if(a_allocated <= n) {
                                            a_allocated = xsum(n, 1);
                                        }
                                        if(a_allocated > 268435455) {
                                            _v164 = -1;
                                        } else {
                                            _v164 = a_allocated << 4;
                                        }
                                        memory_size = _v164;
                                        if(memory_size == -1) {
L156:
                                            if(a->arg != 0) {
                                                 *__esp = a->arg;
                                                free();
                                            }
                                            _t467 = d->dir;
                                            if(_t467 != 0) {
                                                _t467 = d->dir;
                                                 *__esp = _t467;
                                                free();
                                            }
                                            goto L160;
                                        } else {
                                            if(a->arg == 0) {
                                                _t597 = memory_size;
                                                 *__esp = _t597;
                                                malloc();
                                                _v160 = _t597;
                                            } else {
                                                _t601 = memory_size;
                                                _v216 = _t601;
                                                 *__esp = a->arg;
                                                realloc();
                                                _v160 = _t601;
                                            }
                                            memory = _v160;
                                            if(memory == 0) {
                                                goto L156;
                                            } else {
                                                a->arg = memory;
                                                goto L122;
                                            }
                                        }
                                    }
                                    dp->precision_arg_index = arg_posn;
                                    arg_posn = arg_posn + 1;
                                    if(dp->precision_arg_index == -1) {
                                        goto L151;
                                    }
                                    goto L106;
                                } else {
                                    np = cp;
                                    while(( *np & 255) > 47 && ( *np & 255) <= 57) {
                                        np =  &(np[1]);
                                    }
                                    if(( *np & 255) != 36) {
                                        goto L104;
                                    }
                                    n = 0;
                                    np = cp;
                                    while(( *np & 255) > 47 && ( *np & 255) <= 57) {
                                        _v176 = ( *np & 255) - 48;
                                        if(n > 429496729) {
                                            _v172 = -1;
                                        } else {
                                            _v172 = (n << 2) + n + (n << 2) + n;
                                        }
                                        n = xsum(_v172, _v176);
                                        np =  &(np[1]);
                                    }
                                    if(n == 0 || n == -1) {
                                        goto L151;
                                    } else {
                                        dp->precision_arg_index = n - 1;
                                        cp =  &(np[1]);
                                        goto L104;
                                    }
                                }
                            } else {
                                dp->width_start = cp;
                                while(( *cp & 255) > 47 && ( *cp & 255) <= 57) {
                                    cp =  &(cp[1]);
                                }
                                dp->width_end = cp;
                                width_length = dp->width_end - dp->width_start;
                                if(max_width_length < width_length) {
                                    max_width_length = width_length;
                                }
                                goto L83;
                            }
                        }
                        dp->width_start = cp;
                        cp =  &(cp[1]);
                        dp->width_end = cp;
                        if(max_width_length == 0) {
                            max_width_length = 1;
                        }
                        if(( *cp & 255) <= 47 || ( *cp & 255) > 57) {
L52:
                            if(dp->width_arg_index != -1) {
L54:
                                n = dp->width_arg_index;
                                if(n < a_allocated) {
L70:
                                    while(a->count <= n) {
                                        _t822 = a->count;
                                         *(a->arg + (_t822 << 4)) = 0;
                                        a->count = _t822 + 1;
                                    }
                                    if( *((intOrPtr*)(a->arg + (n << 4))) != 0) {
                                        if( *((intOrPtr*)(a->arg + (n << 4))) != 5) {
                                            goto L151;
                                        }
                                        goto L83;
                                    }
                                     *((intOrPtr*)(a->arg + (n << 4))) = 5;
                                    goto L83;
                                }
                                if(a_allocated < 0) {
                                    _v188 = -1;
                                } else {
                                    _v188 = a_allocated + a_allocated;
                                }
                                a_allocated = _v188;
                                if(a_allocated <= n) {
                                    a_allocated = xsum(n, 1);
                                }
                                if(a_allocated > 268435455) {
                                    _v184 = -1;
                                } else {
                                    _v184 = a_allocated << 4;
                                }
                                memory_size = _v184;
                                if(memory_size == -1) {
                                    goto L156;
                                } else {
                                    if(a->arg == 0) {
                                        _t687 = memory_size;
                                         *__esp = _t687;
                                        malloc();
                                        _v180 = _t687;
                                    } else {
                                        _t690 = memory_size;
                                        _v216 = _t690;
                                         *__esp = a->arg;
                                        realloc();
                                        _v180 = _t690;
                                    }
                                    memory = _v180;
                                    if(memory == 0) {
                                        goto L156;
                                    } else {
                                        a->arg = memory;
                                        goto L70;
                                    }
                                }
                            }
                            dp->width_arg_index = arg_posn;
                            arg_posn = arg_posn + 1;
                            if(dp->width_arg_index == -1) {
                                goto L151;
                            }
                            goto L54;
                        } else {
                            np = cp;
                            while(( *np & 255) > 47 && ( *np & 255) <= 57) {
                                np =  &(np[1]);
                            }
                            if(( *np & 255) != 36) {
                                goto L52;
                            }
                            n = 0;
                            np = cp;
                            while(( *np & 255) > 47 && ( *np & 255) <= 57) {
                                _v196 = ( *np & 255) - 48;
                                if(n > 429496729) {
                                    _v192 = -1;
                                } else {
                                    _v192 = (n << 2) + n + (n << 2) + n;
                                }
                                n = xsum(_v192, _v196);
                                np =  &(np[1]);
                            }
                            if(n == 0 || n == -1) {
                                goto L151;
                            } else {
                                dp->width_arg_index = n - 1;
                                cp =  &(np[1]);
                                goto L52;
                            }
                        }
                    }
                    dp->flags = dp->flags | 32;
                    cp =  &(cp[1]);
                }
            }
            if(( *cp & 255) > 57) {
                goto L20;
            } else {
                np = cp;
                while(( *np & 255) > 47) {
                    if(( *np & 255) <= 57) {
                        np =  &(np[1]);
                        continue;
                    }
                    break;
                }
                if(( *np & 255) != 36) {
                    goto L20;
                } else {
                    n = 0;
                    np = cp;
                    while(( *np & 255) > 47) {
                        if(( *np & 255) <= 57) {
                            _v204 = ( *np & 255) - 48;
                            if(n > 429496729) {
                                _v200 = -1;
                            } else {
                                _v200 = (n << 2) + n + (n << 2) + n;
                            }
                            n = xsum(_v200, _v204);
                            np =  &(np[1]);
                            continue;
                        }
                        break;
                    }
                    if(n == 0) {
                        goto L151;
                    }
                    if(n == -1) {
                        goto L151;
                    } else {
                        arg_index = n - 1;
                        cp =  &(np[1]);
                        goto L20;
                    }
                }
            }
        }
         *(d->dir + d->count * 44) = cp;
        d->max_width_length = max_width_length;
        d->max_precision_length = max_precision_length;
        _v136 = 0;
    }
}

size_t xsum(size_t size1, size_t size2)
{// addr = 0x0805DCED  --  defined in 'xsize.h' at line 59
    size_t sum;         // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8

    sum = size1 + size2;
    if(sum < size1) {
        _v24 = -1;
    } else {
        _v24 = sum;
    }
    return _v24;
}

signed int __divdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805DD20
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t82;                       // _t82
    signed int _t83;                       // _t83
    signed int _t89;                       // _t89
    signed int _t91;                       // _t91
    signed int _t93;                       // _t93
    signed int _t115;                      // _t115
    signed int _t122;                      // _t122
    signed int _t123;                      // _t123
    signed int _t139;                      // _t139
    signed int _t142;                      // _t142
    signed int _t143;                      // _t143
    signed int _t144;                      // _t144

    _t139 = _a8;
    _t82 = _a12;
    _t122 = _a16;
    _t144 = _a4;
    _v44 = _t82;
    _v40 = _t122;
    _v32 = 0;
    if(_t139 < 0) {
        _t144 =  ~_t144;
        asm("adc edi, 0x0");
        _t139 =  ~_t139;
        _v32 = -1;
        __eflags = _v40;
        if(_v40 >= 0) {
L2:
            _v24 = _t82;
            _t83 = _t122;
            _v28 = _t144;
            _v52 = _t139;
            if(_t122 != 0) {
                __eflags = _t122 - _v52;
                if(_t122 <= _v52) {
                    asm("bsr edx, edx");
                    _t123 = _t122 ^ 31;
                    __eflags = _t123;
                    _v20 = _t123;
                    if(_t123 != 0) {
                        _v48 = 32 - _v20;
                        _t142 = _v24 >> 32 | _t83 << (_v20 & 255);
                        _v16 = _v24 << (_v20 & 255);
                        _t89 = _v28 >> (_v48 & 255) | _v52 << (_v20 & 255);
                        _v48 = _t89 / _t142;
                        _t91 = _v16;
                        __eflags = _t89 % _t142 - _t91 * _v48 >> 32;
                        _t143 = _t91 * _v48;
                        if(__eflags < 0) {
L24:
                            _t115 = _v48 - 1;
L7:
                            _t93 = _t115;
                            if(_v32 == 0) {
                                return _t93;
                            }
                            asm("adc edx, 0x0");
                            return  ~_t93;
                        }
                        if(__eflags == 0) {
                            __eflags = _v28 << (_v20 & 255) - _t143;
                            if(_v28 << (_v20 & 255) >= _t143) {
                                goto L21;
                            }
                            goto L24;
                        }
L21:
                        _t115 = _v48;
                        goto L7;
                    }
                    __eflags = _t83 - _v52;
                    if(_t83 < _v52) {
L18:
                        _t115 = 1;
                        goto L7;
                    }
                    __eflags = _v24 - _v28;
                    if(_v24 > _v28) {
                        goto L6;
                    }
                    goto L18;
                }
L6:
                _t115 = 0;
                __eflags = 0;
                goto L7;
            }
            if(_v24 <= _t139) {
                __eflags = _v24;
                if(_v24 == 0) {
                    __eflags = 1 % _v24;
                    _v24 = 1 / _v24;
                }
                _t115 = _v28 / _v24;
                goto L7;
            }
            _t115 = _t144 / _v24;
            goto L7;
        }
L14:
        _v32 =  !_v32;
        _t82 =  ~_v44;
        asm("adc edx, 0x0");
        _t122 =  ~_v40;
        goto L2;
    }
    if(_v40 < 0) {
        goto L14;
    }
    goto L2;
}

signed int __moddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805DEB0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t100;                      // _t100
    signed int _t101;                      // _t101
    signed int _t111;                      // _t111
    signed int _t112;                      // _t112
    signed int _t113;                      // _t113
    unsigned int _t127;                    // _t127
    char* _t139;                           // _t139
    signed int _t142;                      // _t142
    signed int _t156;                      // _t156
    signed int _t159;                      // _t159
    signed int _t164;                      // _t164
    signed int _t165;                      // _t165
    signed int* _t167;                     // _t167
    signed int _t171;                      // _t171
    signed int _t173;                      // _t173
    signed int* _t175;                     // _t175
    signed int* _t176;                     // _t176

    _v52 = 0;
    _v80 = _a16;
    _t142 = _a8;
    _v84 = _a12;
    _t100 = _a4;
    _v64 = _v80;
    _v68 = _v84;
    if(_t142 < 0) {
        _t100 =  ~_t100;
        asm("adc edx, 0x0");
        _t142 =  ~_t142;
        _v52 = -1;
        __eflags = _v80;
        if(_v80 >= 0) {
L2:
            _t127 = _v64;
            _t171 = _t142;
            _v56 =  &_v20;
            _t164 = _v68;
            _v40 = _t100;
            _v36 = _t100;
            _v72 = _t127;
            if(_t127 != 0) {
                __eflags = _v72 - _t142;
                if(_v72 <= _t142) {
                    asm("bsr eax, [ebp-0x44]");
                    _t101 = _t100 ^ 31;
                    __eflags = _t101;
                    _v44 = _t101;
                    if(_t101 != 0) {
                        _v48 = 32 - _v44;
                        _v32 = _t164 >> (_v48 & 255) | _v72 << (_v44 & 255);
                        _t165 = _t164 << (_v44 & 255);
                        _v72 = _t171 >> (_v48 & 255);
                        _t111 = _v40 >> (_v48 & 255) | _t171 << (_v44 & 255);
                        _t112 = _t111 / _v32;
                        _v72 = _t111 % _v32;
                        _t173 = _v40 << (_v44 & 255);
                        _t113 = _t112 * _t165;
                        __eflags = _v72 - _t112 * _t165 >> 32;
                        if(__eflags >= 0) {
                            if(__eflags != 0) {
L23:
                                asm("sbb ecx, edx");
                                _v72 = _v72;
                                _t175 = _v56;
                                 *_t175 = _t173 - _t113 >> (_v44 & 255) | _v72 << (_v48 & 255);
                                _t175[1] = _v72 >> (_v44 & 255);
L8:
                                if(_v52 != 0) {
                                    _v20 =  ~_v20;
                                    asm("adc dword [ebp-0xc], 0x0");
                                    _v16 =  ~_v16;
                                }
                                return _v20;
                            }
                            __eflags = _t173 - _t113;
                            if(_t173 >= _t113) {
                                goto L23;
                            }
                        }
                        _t113 = _t113 - _t165;
                        asm("sbb edx, [ebp-0x1c]");
                        goto L23;
                    }
                    __eflags = _v72 - _t142;
                    if(_v72 < _t142) {
L19:
                        _t156 = _v36 - _t164;
                        __eflags = _t156;
                        asm("sbb esi, [ebp-0x44]");
                        _v36 = _t156;
L20:
                        _t139 = _v56;
                        _t139[4] = _t171;
                         *_t139 = _v36;
                        goto L8;
                    }
                    __eflags = _t164 - _v36;
                    if(_t164 > _v36) {
                        goto L20;
                    }
                    goto L19;
                }
                _t167 = _v56;
                 *_t167 = _t100;
                _t167[1] = _t142;
                goto L8;
            }
            if(_t164 <= _t142) {
                __eflags = _t164;
                if(_t164 == 0) {
                    __eflags = 1 % _t164;
                    _t164 = 1 / _t164;
                }
                _t159 = _v36 % _t164;
L5:
                _t176 = _v56;
                 *_t176 = _t159;
                _t176[1] = 0;
                goto L8;
            }
            _t159 = _t100 % _t164;
            goto L5;
        }
L15:
        asm("adc edi, 0x0");
        _v68 =  ~_v84;
        _v64 =  ~_v80;
        goto L2;
    }
    if(_v80 < 0) {
        goto L15;
    }
    goto L2;
}

signed int __udivdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805E090
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t57;                       // _t57
    signed int _t62;                       // _t62
    signed int _t64;                       // _t64
    signed int _t79;                       // _t79
    signed int _t88;                       // _t88
    signed int _t95;                       // _t95
    signed int _t113;                      // _t113
    signed int _t114;                      // _t114
    signed int _t117;                      // _t117

    _t95 = _a4;
    _t79 = _a8;
    _t117 = _a12;
    _t57 = _a16;
    _v24 = _t95;
    _v40 = _t79;
    if(_t57 != 0) {
        __eflags = _t57 - _v40;
        if(_t57 <= _v40) {
            asm("bsr edi, eax");
            _t114 = _t113 ^ 31;
            __eflags = _t114;
            if(_t114 != 0) {
                _v36 = 32 - _t114;
                _v16 = _t117 << _t114;
                _v20 = _t57 << _t114 | _t117 >> 32;
                _t62 = _v24 >> (_v36 & 255) | _v40 << _t114;
                _v36 = _t62 / _v20;
                _t64 = _v16;
                __eflags = _t62 % _v20 - _t64 * _v36 >> 32;
                _v28 = _t64 * _v36;
                if(__eflags < 0) {
L18:
                    _t88 = _v36 - 1;
                } else {
                    if(__eflags == 0) {
                        __eflags = _v24 << _t114 - _v28;
                        if(_v24 << _t114 >= _v28) {
                            goto L15;
                        } else {
                            goto L18;
                        }
                    } else {
L15:
                        _t88 = _v36;
                    }
                }
            } else {
                __eflags = _t57 - _v40;
                if(_t57 < _v40) {
L12:
                    _t88 = 1;
                } else {
                    __eflags = _t117 - _v24;
                    if(_t117 > _v24) {
                        goto L6;
                    } else {
                        goto L12;
                    }
                }
            }
        } else {
L6:
            _t88 = 0;
            __eflags = 0;
        }
        return _t88;
    } else {
        if(_t117 > _t79) {
            __eflags = 0;
            return _t95 / _t117;
        } else {
            if(_t117 == 0) {
                _t117 = 1 / _t117;
            }
            return _v24 / _t117;
        }
    }
}

signed int __umoddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805E1C0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t61;                       // _t61
    signed int _t71;                       // _t71
    signed int _t72;                       // _t72
    signed int _t73;                       // _t73
    signed int _t88;                       // _t88
    signed int _t100;                      // _t100
    signed int _t101;                      // _t101
    signed int _t102;                      // _t102
    signed int _t118;                      // _t118
    signed int _t123;                      // _t123
    signed int _t126;                      // _t126
    signed int _t128;                      // _t128
    signed int _t130;                      // _t130

    _t88 = _a4;
    _t128 = _a8;
    _t123 = _a12;
    _t61 = _a16;
    _v28 = _t88;
    _v24 = _t88;
    if(_t61 != 0) {
        __eflags = _t61 - _t128;
        if(_t61 <= _t128) {
            asm("bsr edx, eax");
            _t102 = _t101 ^ 31;
            __eflags = _t102;
            _v32 = _t102;
            if(_t102 != 0) {
                _v36 = 32 - _v32;
                _v20 = _t123 >> (_v36 & 255) | _t61 << (_v32 & 255);
                _v16 = _t123 << (_v32 & 255);
                _v40 = _t128 >> (_v36 & 255);
                _t71 = _v28 >> (_v36 & 255) | _t128 << (_v32 & 255);
                _t72 = _t71 / _v20;
                _t130 = _t71 % _v20;
                _t126 = _v28 << (_v32 & 255);
                _t73 = _t72 * _v16;
                __eflags = _t130 - _t72 * _v16 >> 32;
                if(__eflags >= 0) {
                    if(__eflags != 0) {
L16:
                        asm("sbb esi, edx");
                        return _t130 << (_v36 & 255) | _t126 - _t73 >> (_v32 & 255);
                    }
                    __eflags = _t126 - _t73;
                    if(_t126 >= _t73) {
                        goto L16;
                    }
                }
                _t73 = _t73 - _v16;
                asm("sbb edx, [ebp-0x10]");
                goto L16;
            }
            __eflags = _t61 - _t128;
            if(_t61 >= _t128) {
                __eflags = _t123 - _v24;
                if(_t123 > _v24) {
L13:
                    return _v24;
                }
            }
            _t100 = _v24 - _t123;
            __eflags = _t100;
            asm("sbb esi, eax");
            _v24 = _t100;
            goto L13;
        }
        return _t88;
    }
    if(_t123 <= _t128) {
        __eflags = _t123;
        if(_t123 == 0) {
            __eflags = 1 % _t123;
            _t123 = 1 / _t123;
        }
        _t118 = _v24 % _t123;
    } else {
        _t118 = _t88 % _t123;
    }
    return _t118;
}

__libc_csu_fini(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805E310
    __eax = __eax;
    return __eax;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805E320
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ _t11;                        // _t11
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    __i686.get_pc_thunk.bx(_t11);
    _t18 = _t17 + 23753;
    __esp = __esp - 12;
    _init();
    _t21 = _t18 - 244 - _t18 - 244 >> 2;
    if(_t21 != 0) {
        __esi = 0;
        do {
            _v20 = _a12;
            _v24 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t18 + __esi * 4 - 244))();
            __esi = __esi + 1;
        } while(__esi < _t21);
    }
    __esp = __esp + 12;
}

__i686.get_pc_thunk.bx(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805E37A
    __eax = __eax;
    return __eax;
}

atexit(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805E380
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(0);
    __esp = __esp - 12;
    __edx =  *((intOrPtr*)(_t8 + 23657 - 4));
    if(__edx != 0) {
        _t6 =  *__edx;
    }
    _v12 = _t6;
    _t7 = _a4;
    _v16 = 0;
     *__esp = _t7;
    __cxa_atexit();
    __esp = __esp + 12;
    return _t7;
}

stat64(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805E3C0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __xstat64();
    return _t7;
}

fstat64(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805E400
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __fxstat64();
    return _t7;
}

lstat64(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805E440
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __lxstat64();
    return _t7;
}

__do_global_ctors_aux()
{// addr = 0x0805E480
    intOrPtr* __ebx;                       // r1

    __eax = __CTOR_LIST__;
    if(__eax != -1) {
        __ebx =  &__CTOR_LIST__;
        do {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
        } while(__eax != -1);
    }
}

_fini()
{// addr = 0x0805E4AC
    _unknown_ __ebx;                       // r1
    _unknown_ _t1;                         // _t1

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    return __eax;
}

L0805E4B8()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

L0805E4B8()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = @rec __do_global_dtors_aux@__do_global_dtors_aux@();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

// Statistics:
//    1104 Register nodes
//    1577 Temporaries nodes
//      60 Casts
//    1689 Statements
//     472 Labels
//     386 Gotos
//     366 Blocks
//   29667 Nodes
//     177 Assembly nodes
//     327 Unknown Types


Total time: 4 seconds.
