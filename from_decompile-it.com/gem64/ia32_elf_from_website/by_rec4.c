// Generated by Rec Studio 4 - build Sep 23 2015

_init()
{// addr = 0x08048A44
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 66980 - 8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    return _t3;
}

L08048A50()
{
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 66980 - 8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return _t3;
}

fputs()
{// addr = 0x08048A84
    goto __imp__fputs;
}

__errno_location()
{// addr = 0x08048A94
    goto __imp____errno_location;
}

sprintf()
{// addr = 0x08048AA4
    goto __imp__sprintf;
}

srand()
{// addr = 0x08048AB4
    goto __imp__srand;
}

open()
{// addr = 0x08048AC4
    goto __imp__open;
}

strerror()
{// addr = 0x08048AD4
    goto __imp__strerror;
}

__cxa_atexit()
{// addr = 0x08048AE4
    goto __imp____cxa_atexit;
}

__isoc99_fscanf()
{// addr = 0x08048AF4
    goto __imp____isoc99_fscanf;
}

__xstat()
{// addr = 0x08048B04
    goto __imp____xstat;
}

__gmon_start__()
{// addr = 0x08048B14
    goto __imp____gmon_start__;
}

rewind()
{// addr = 0x08048B24
    goto __imp__rewind;
}

__isoc99_sscanf()
{// addr = 0x08048B34
    goto __imp____isoc99_sscanf;
}

vsprintf()
{// addr = 0x08048B44
    goto __imp__vsprintf;
}

strchr()
{// addr = 0x08048B54
    goto __imp__strchr;
}

getenv()
{// addr = 0x08048B64
    goto __imp__getenv;
}

calloc()
{// addr = 0x08048B74
    goto __imp__calloc;
}

system()
{// addr = 0x08048B84
    goto __imp__system;
}

strncpy()
{// addr = 0x08048B94
    goto __imp__strncpy;
}

fgets()
{// addr = 0x08048BA4
    goto __imp__fgets;
}

__libc_start_main()
{// addr = 0x08048BB4
    goto __imp____libc_start_main;
}

strrchr()
{// addr = 0x08048BC4
    goto __imp__strrchr;
}

readdir()
{// addr = 0x08048BD4
    goto __imp__readdir;
}

strtol()
{// addr = 0x08048BE4
    goto __imp__strtol;
}

free()
{// addr = 0x08048BF4
    goto __imp__free;
}

fflush()
{// addr = 0x08048C04
    goto __imp__fflush;
}

mkstemp()
{// addr = 0x08048C14
    goto __imp__mkstemp;
}

opendir()
{// addr = 0x08048C24
    goto __imp__opendir;
}

getopt_long()
{// addr = 0x08048C34
    goto __imp__getopt_long;
}

fclose()
{// addr = 0x08048C44
    goto __imp__fclose;
}

memcpy()
{// addr = 0x08048C54
    goto __imp__memcpy;
}

strlen()
{// addr = 0x08048C64
    goto __imp__strlen;
}

fopen()
{// addr = 0x08048C74
    goto __imp__fopen;
}

strcpy()
{// addr = 0x08048C84
    goto __imp__strcpy;
}

chdir()
{// addr = 0x08048C94
    goto __imp__chdir;
}

putenv()
{// addr = 0x08048CA4
    goto __imp__putenv;
}

closedir()
{// addr = 0x08048CB4
    goto __imp__closedir;
}

close()
{// addr = 0x08048CC4
    goto __imp__close;
}

fwrite()
{// addr = 0x08048CD4
    goto __imp__fwrite;
}

fprintf()
{// addr = 0x08048CE4
    goto __imp__fprintf;
}

strstr()
{// addr = 0x08048CF4
    goto __imp__strstr;
}

setvbuf()
{// addr = 0x08048D04
    goto __imp__setvbuf;
}

remove()
{// addr = 0x08048D14
    goto __imp__remove;
}

malloc()
{// addr = 0x08048D24
    goto __imp__malloc;
}

__stack_chk_fail()
{// addr = 0x08048D34
    goto __imp____stack_chk_fail;
}

fputc()
{// addr = 0x08048D44
    goto __imp__fputc;
}

strtok()
{// addr = 0x08048D54
    goto __imp__strtok;
}

strcat()
{// addr = 0x08048D64
    goto __imp__strcat;
}

getcwd()
{// addr = 0x08048D74
    goto __imp__getcwd;
}

rand()
{// addr = 0x08048D84
    goto __imp__rand;
}

strdup()
{// addr = 0x08048D94
    goto __imp__strdup;
}

strcmp()
{// addr = 0x08048DA4
    goto __imp__strcmp;
}

exit()
{// addr = 0x08048DB4
    goto __imp__exit;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08048DD0
    _unknown_ __ebx;                       // r1
    signed int _t4;                        // _t4
    signed int _t5;                        // _t5

    __edx = __edx;
    _t3 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & -16;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(__esi);
    _push(main);
    __libc_start_main();
    asm("hlt");
    0;
    0;
    _push(0);
    _push(_t5);
    __esp = __esp - 4;
    if(completed.7065 == 0) {
        _t3 = dtor_idx.7067;
        _t5 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t3 <  &__DTOR_END__) {
            do {
                _t4 = _t3 + 1;
                dtor_idx.7067 = _t4;
                 *((intOrPtr*)(_t4 * 4 +  &__DTOR_LIST__))();
                _t3 = dtor_idx.7067;
            } while(_t3 < _t5);
        }
        completed.7065 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
}

__do_global_dtors_aux()
{// addr = 0x08048E00
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    signed int _t4;                        // _t4
    signed int _t5;                        // _t5
    signed int _t9;                        // _t9

    if(completed.7065 == 0) {
        _t4 = dtor_idx.7067;
        _t9 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t4 >=  &__DTOR_END__) {
L4:
            completed.7065 = 1;
            return;
        }
        do {
            _t5 = _t4 + 1;
            dtor_idx.7067 = _t5;
             *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
            _t4 = dtor_idx.7067;
        } while(_t4 < _t9);
        goto L4;
    }
}

frame_dummy()
{// addr = 0x08048E60
    if(__JCR_LIST__ == 0 || 0 == 0) {
        return;
    } else {
         *__esp =  &__JCR_LIST__;
         *0();
        return;
    }
}

void exit_env()
{// addr = 0x08048E84  --  defined in 'at_exit_funcs.c' at line 29

}

void exit_tmp()
{// addr = 0x08048E89  --  defined in 'at_exit_funcs.c' at line 62
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    DIR* dir;              // _cfa_fffff7e8
    intOrPtr _v2080;                       // _cfa_fffff7e0
    char[2047]* _v2084;                    // _cfa_fffff7dc
    char[2047]* _v2088;                    // _cfa_fffff7d8

    _v16 =  *gs:0x14];
    if((TMPDIR & 255) != 0) {
        if(TMPCLEAN == 0) {
             *__esp =  &CWD;
            chdir();
            _v2084 =  &TMPDIR;
            _v2088 = "rm -rf %s/*";
             *__esp =  &tmp;
            sprintf();
            if(VERBOSE != 0) {
                _v2080 = __imp__stdout;
                _v2084 = 37;
                _v2088 = 1;
                 *__esp = "Removing temporary extension files...";
                fwrite();
            }
             *__esp =  &tmp;
            system();
            error =  &tmp;
            _v2084 =  &TMPDIR;
            _v2088 = "rmdir %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
             *__esp =  &TMPDIR;
            opendir();
            dir =  &tmp;
            if(dir != 0) {
                _v2088 =  &TMPDIR;
                print_warning("could not remove temporary directory %s.\nPlease remove manually.\n");
            }
            if(VERBOSE != 0) {
                print_done();
            }
            TMPCLEAN = 1;
        }
    } else {
        TMPCLEAN = 1;
    }
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void exit_db()
{// addr = 0x08048FC2  --  defined in 'at_exit_funcs.c' at line 106
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    intOrPtr _v2080;                       // _cfa_fffff7e0
    char[2047]* _v2084;                    // _cfa_fffff7dc
    char[2047]* _v2088;                    // _cfa_fffff7d8

    _v16 =  *gs:0x14];
    if(TMPDBCLEAN != 0) {
L34:
        if((_v16 ^  *gs:0x14]) == 0) {
            return;
        }
        __stack_chk_fail();
        return;
    } else {
         *__esp =  &CWD;
        chdir();
        if(VERBOSE != 0) {
            _v2080 = __imp__stdout;
            _v2084 = 40;
            _v2088 = 1;
             *__esp = "Removing temporary registration files...";
            fwrite();
        }
        if( &TMPDB != 0) {
            _v2084 =  &TMPDB;
            _v2088 = "rm -rf %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMPDB;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_GISMAN != 0) {
            _v2084 =  &TMP_GISMAN;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_GISMAN;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_DESCR != 0) {
            _v2084 =  &TMP_DESCR;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_DESCR;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_INFO != 0) {
            _v2084 =  &TMP_INFO;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_DEPS != 0) {
            _v2084 =  &TMP_DEPS;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_BUGS != 0) {
            _v2084 =  &TMP_BUGS;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_AUTHORS != 0) {
            _v2084 =  &TMP_AUTHORS;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if( &TMP_HTML != 0) {
            _v2084 =  &TMP_HTML;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_HTML;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if(VERBOSE == 0 && (TMP_NULL & 255) != 0) {
            _v2084 =  &TMP_NULL;
            _v2088 = "rm -f %s";
             *__esp =  &tmp;
            sprintf();
             *__esp =  &tmp;
            system();
            error =  &tmp;
            if(error != 0) {
                _v2088 =  &TMP_NULL;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if(VERBOSE != 0) {
            print_done();
        }
        TMPDBCLEAN = 1;
        goto L34;
    }
}

void exit_msg()
{// addr = 0x08049390  --  defined in 'at_exit_funcs.c' at line 221
    intOrPtr _v16;                         // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8

    if(ERROR < 0) {
        _v20 = ERROR;
        _v24 = "Program exited with an error (code %i). Operation aborted.\n";
         *__esp = __imp__stdout;
        fprintf();
        return;
    }
    if(WARNINGS == 1) {
        _v16 = __imp__stdout;
        _v20 = 50;
        _v24 = 1;
         *__esp = "Job done but there was one warning. Please check.\n";
        fwrite();
    }
    if(WARNINGS > 1) {
        _v20 = WARNINGS;
        _v24 = "Job done but there were %i warnings. Please check.\n";
         *__esp = __imp__stdout;
        fprintf();
        return;
    }
}

void print_error(int err_code, char* msg)
{// addr = 0x08049420  --  defined in 'error.c' at line 32
    signed int _v16;                       // _cfa_fffffff0
    char[2047] buffer;                     // _cfa_fffff7f0
    va_list ap;        // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    char _v2100;                           // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8
    signed int _v2124;                     // _cfa_fffff7b4
    char _v4172;                           // _cfa_ffffefb4
    char* _v4176;                          // _cfa_ffffefb0
    char* _v4188;                          // _cfa_ffffefa4
    char* _v4208;                          // _cfa_ffffef90
    char* _v4212;                          // _cfa_ffffef8c
    _unknown_ _t56;                        // _t56

    _v2080 = msg;
    _v16 =  *gs:0x14];
    ap =  &_a12;
    _v2100 = ap;
    _v2104 = _v2080;
     *__esp =  &buffer;
    vsprintf();
    _v2100 =  &buffer;
    _v2104 = 134564288;
     *__esp = __imp__stderr;
    fprintf();
    ERROR = err_code;
     *__esp = err_code;
    exit();
    _push(_t56);
    __esp = __esp - 2104;
    _v4188 = _v2104;
    _v2124 =  *gs:0x14];
    _v4176 =  &_v2100;
    _v4208 = _v4176;
    _v4212 = _v4188;
     *__esp =  &_v4172;
    vsprintf();
    _v4208 =  &_v4172;
    _v4212 = 134564310;
     *__esp = __imp__stderr;
    fprintf();
    WARNINGS = WARNINGS + 1;
    if((_v2124 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void print_warning(char* msg)
{// addr = 0x0804949B  --  defined in 'error.c' at line 52
    signed int _v16;                       // _cfa_fffffff0
    char[2047] buffer;                     // _cfa_fffff7f0
    va_list ap;        // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8

    _v2080 = msg;
    _v16 =  *gs:0x14];
    ap =  &_a8;
    _v2100 = ap;
    _v2104 = _v2080;
     *__esp =  &buffer;
    vsprintf();
    _v2100 =  &buffer;
    _v2104 = 134564310;
     *__esp = __imp__stderr;
    fprintf();
    WARNINGS = WARNINGS + 1;
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void print_done()
{// addr = 0x08049523  --  defined in 'error.c' at line 70
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    _v16 = __imp__stdout;
    _v20 = 17;
    _v24 = 1;
     *__esp = 134564334;
    fwrite();
}

char* basename(char* path)
{// addr = 0x08049554  --  defined in 'tools.c' at line 33
    char* copy;                            // _cfa_fffffff0
    char* element;                         // _cfa_ffffffec
    char* backup;                          // _cfa_ffffffe8
    char* _v40;                            // _cfa_ffffffd8
    char* _t25;                            // _t25
    char* _t27;                            // _t27
    char* _t28;                            // _t28
    char* _t34;                            // _t34

    _t25 = path;
     *__esp = _t25;
    strdup();
    copy = _t25;
    backup = 0;
    _v40 = 134564352;
    _t27 = copy;
     *__esp = _t27;
    strtok();
    element = _t27;
    if(element != 0) {
        _t28 = element;
         *__esp = _t28;
        strdup();
        backup = _t28;
        while(element != 0) {
            _v40 = 134564352;
             *__esp = 0;
            strtok();
            element = 134564352;
            if(backup != 0 && element != 0) {
                 *__esp = backup;
                free();
            }
            if(element != 0 && ( *element & 255) != 0) {
                _t34 = element;
                 *__esp = _t34;
                strdup();
                backup = _t34;
            }
        }
        if(copy != 0) {
             *__esp = copy;
            free();
        }
        return backup;
    } else {
        if(copy != 0) {
             *__esp = copy;
            free();
        }
        return 0;
    }
}

void mkdir_s(char* pathname, char* mode)
{// addr = 0x0804961D  --  defined in 'tools.c' at line 73
    signed int _v16;                       // _cfa_fffffff0
    char[4999] tmp;                        // _cfa_ffffec68
    char* _v5024;                          // _cfa_ffffec60
    char* _v5028;                          // _cfa_ffffec5c
    char* _v5040;                          // _cfa_ffffec50
    char* _v5044;                          // _cfa_ffffec4c
    char* _v5048;                          // _cfa_ffffec48

    _v5024 = pathname;
    _v5028 = mode;
    _v16 =  *gs:0x14];
    _v5040 = _v5028;
    _v5044 = _v5024;
    _v5048 = "mkdir %s --mode=%s -p";
     *__esp =  &tmp;
    sprintf();
     *__esp =  &tmp;
    system();
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

int chop(char* string)
{// addr = 0x0804968F  --  defined in 'tools.c' at line 86
    int i;                                 // _cfa_fffffff0
    int chopped;                           // _cfa_ffffffec
    int stop;                              // _cfa_ffffffe8
    char* _t27;                            // _t27
    char* _t32;                            // _t32

    stop = 0;
    chopped = 0;
    _t27 = string;
     *__esp = _t27;
    strlen();
    i = _t27 - 1;
    while(i >= 0) {
        stop = 1;
        if((string[i] & 255) == 10 || (string[i] & 255) == 9 || (string[i] & 255) == 32 || (string[i] & 255) == 12 || (string[i] & 255) == 13) {
            chopped = chopped + 1;
            stop = 0;
        }
        if(stop == 1) {
            break;
        } else {
            i = i - 1;
            continue;
        }
    }
    _t32 = string;
     *__esp = _t32;
    strlen();
    string[_t32 - chopped] = 0;
    return chopped;
}

int insert_str(char* str, int pos, char** strarr)
{// addr = 0x08049737  --  defined in 'tools.c' at line 125
    signed int _v16;                       // _cfa_fffffff0
    char[2047] save;                       // _cfa_fffff7f0
    char[2047] insert;                     // _cfa_ffffeff0
    char[2047] last;                       // _cfa_ffffe7f0
    int n;                                 // _cfa_ffffe7ec
    int j;                                 // _cfa_ffffe7e8
    int len;                               // _cfa_ffffe7e4
    char* _v6176;                          // _cfa_ffffe7e0
    char** _v6180;                         // _cfa_ffffe7dc
    int _v6196;                            // _cfa_ffffe7cc
    char[2047]* _v6200;                    // _cfa_ffffe7c8 (outparam)
    _unknown_ __ebx;                       // r1
    char[2047]* _t114;                     // _t114
    char* _t115;                           // _t115
    int _t139;                             // _t139
    char* _t150;                           // _t150
    int _t159;                             // _t159
    char[2047]* _t160;                     // _t160
    int _t164;                             // _t164

    _v6176 = str;
    _v6180 = strarr;
    _v16 =  *gs:0x14];
    n = 0;
    while(_v6180[n] != 0) {
        n = n + 1;
    }
    if(pos < 0 || pos > n) {
        _v6196 = pos;
        print_error(-21, "insert: invalid line number %i.\n");
    }
    if(pos != n) {
        _v6200 = _v6180[n - 1];
         *__esp =  &last;
        strcpy();
        _v6200 = _v6180[pos];
         *__esp =  &insert;
        strcpy();
         *__esp = _v6180[pos];
        free();
        _t114 = _v6176;
         *__esp = _t114;
        strlen();
        _t115 = _t114 + 1;
         *__esp = _t115;
        malloc();
        _v6180[pos] = _t115;
        _v6200 = _v6176;
         *__esp = _v6180[pos];
        strcpy();
        j = pos;
        while(n - 1 > j) {
            _v6200 = _v6180[j + 1];
             *__esp =  &save;
            strcpy();
             *__esp = _v6180[j + 1];
            free();
             *__esp =  &insert;
            strlen();
            len =  &insert + 1;
            _t139 = len;
             *__esp = _t139;
            malloc();
            _v6180[j + 1] = _t139;
            _v6200 =  &insert;
             *__esp = _v6180[j + 1];
            strcpy();
            _v6200 =  &save;
             *__esp =  &insert;
            strcpy();
            j = j + 1;
        }
         *__esp =  &last;
        strlen();
        _t150 =  &last + 1;
         *__esp = _t150;
        malloc();
        _v6180[n] = _t150;
        _v6200 =  &last;
         *__esp = _v6180[n];
        strcpy();
        n = n + 2;
        _v6180[n - 1] = 0;
        _t159 = n;
        goto L12;
    } else {
        _t160 = _v6176;
         *__esp = _t160;
        strlen();
        len = _t160 + 1;
        _t164 = len;
         *__esp = _t164;
        malloc();
        _v6180[n] = _t164;
        _v6200 = _v6176;
         *__esp = _v6180[n];
        strcpy();
        n = n + 2;
        _v6180[n - 1] = 0;
        _t159 = n;
L12:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t159;
        }
        __stack_chk_fail();
        return _t159;
    }
}

int delete_str(int pos, char** strarr)
{// addr = 0x08049A5E  --  defined in 'tools.c' at line 190
    int i;                                 // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    char* _t61;                            // _t61
    char* _t62;                            // _t62

    i = 0;
    while(strarr[i] != 0) {
        i = i + 1;
    }
    if(pos < 0 || pos > i) {
        _v36 = pos;
        print_error(-21, "delete: invalid line number %i.\n");
    }
    i = pos;
    while(strarr[i] != 0) {
         *__esp = strarr[i];
        free();
        if(strarr[i + 1] != 0) {
            _t61 = strarr[i + 1];
             *__esp = _t61;
            strlen();
            _t62 =  &(_t61[1]);
             *__esp = _t62;
            malloc();
            strarr[i] = _t62;
            _v40 = strarr[i + 1];
             *__esp = strarr[i];
            strcpy();
        }
        i = i + 1;
    }
    i = i - 1;
    strarr[i] = 0;
    return i;
}

int find_pos(char* str, char** strarr, int start)
{// addr = 0x08049B5F  --  defined in 'tools.c' at line 230
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    char* _t29;                            // _t29

    i = 0;
    while(strarr[i] != 0) {
        i = i + 1;
    }
    if(start < 0 || start > i) {
         *__esp = -21;
        exit();
    }
    j = start;
    while(j < i) {
        _t29 = strarr[j];
        _v40 = str;
         *__esp = _t29;
        strstr();
        if(_t29 == 0) {
            j = j + 1;
            continue;
        }
        return j;
    }
    return -1;
}

void dump_str(FILE* f, char** strarr)
{// addr = 0x08049BD9  --  defined in 'tools.c' at line 258
    int i;                                 // _cfa_fffffff0
    char* _v32;                            // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8

    i = 0;
    while(strarr[i] != 0) {
        _v32 = strarr[i];
        _v36 = i;
        _v40 = "%i: %s";
         *__esp = f;
        fprintf();
        i = i + 1;
    }
}

void get_package_name(char* path, char* name)
{// addr = 0x08049C27  --  defined in 'tools.c' at line 273
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] tmp;                        // _cfa_ffffeff0
    FILE* f;              // _cfa_ffffefec
    char* _v4128;                          // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char* _v4148;                          // _cfa_ffffefcc (outparam)
    char[2047]* _v4152;                    // _cfa_ffffefc8 (outparam)

    _v4128 = path;
    _v4132 = name;
    _v16 =  *gs:0x14];
    _v4144 = "name";
    _v4148 = _v4128;
    _v4152 = "%s/%s";
     *__esp =  &file;
    sprintf();
    _v4152 = 134564463;
     *__esp =  &file;
    fopen();
    f =  &file;
    if(f != 0) {
        if(nc_fgets_nb( &tmp, 2048, f) != 0) {
            chop( &tmp);
            _v4152 =  &tmp;
             *__esp = _v4132;
            strcpy();
        } else {
             *__esp = f;
            fclose();
            print_error(-6, "invalid or missing extension name.\n");
        }
    } else {
        print_error(-6, "'name' file not readable.\n");
    }
     *__esp = f;
    fclose();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

char* nc_fgets(char* s, int size, FILE* stream)
{// addr = 0x08049D41  --  defined in 'tools.c' at line 307
    char* hashmark;                        // _cfa_fffffff0
    char* tmp;                             // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t32;                            // _t32
    char* _t33;                            // _t33
    char* _t35;                            // _t35
    char* _t39;                            // _t39

    _v36 = stream;
    _v40 = size;
    _t32 = s;
     *__esp = _t32;
    fgets();
    if(_t32 != 0) {
        _v40 = 35;
        _t33 = s;
         *__esp = _t33;
        strchr();
        hashmark = _t33;
        if(hashmark == 0) {
L6:
            return s;
        }
        _t35 = s;
        if(_t35 != hashmark) {
             *__esp = 2048;
            malloc();
            tmp = _t35;
            _v40 = s;
             *__esp = tmp;
            strcpy();
            _v40 = 134564528;
            _t39 = tmp;
             *__esp = _t39;
            strtok();
            tmp = _t39;
            _v36 = tmp;
            _v40 = 134564530;
             *__esp = s;
            sprintf();
             *__esp = tmp;
            free();
            goto L6;
        }
        return nc_fgets(s, size, stream);
    }
    return 0;
}

char* nc_fgets_html(char* s, int size, FILE* stream)
{// addr = 0x08049E14  --  defined in 'tools.c' at line 339
    char* hashmark;                        // _cfa_fffffff0
    char* tmp;                             // _cfa_ffffffec
    char* tag;                             // _cfa_ffffffe8
    char* tag_2;                           // _cfa_ffffffe4
    char* tag_insert;                      // _cfa_ffffffe0
    char* tag_content;                     // _cfa_ffffffdc
    char* pos;                             // _cfa_ffffffd8
    char* insert;                          // _cfa_ffffffd4
    int space;                             // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc (outparam)
    char* _v72;                            // _cfa_ffffffb8 (outparam)
    char* _t128;                           // _t128
    char* _t129;                           // _t129
    char* _t130;                           // _t130
    char* _t131;                           // _t131
    char* _t132;                           // _t132
    char* _t164;                           // _t164
    char* _t165;                           // _t165
    char* _t166;                           // _t166
    char* _t167;                           // _t167
    char* _t201;                           // _t201
    char* _t203;                           // _t203
    char* _t207;                           // _t207

    _v68 = stream;
    _v72 = size;
    _t128 = s;
     *__esp = _t128;
    fgets();
    if(_t128 == 0) {
        return 0;
    }
    _t129 = s;
     *__esp = _t129;
    strlen();
    _t130 =  &(_t129[1]);
     *__esp = _t130;
    malloc();
    tmp = _t130;
    _t131 = s;
     *__esp = _t131;
    strlen();
    _t132 =  &(_t131[1]);
     *__esp = _t132;
    malloc();
    tag_content = _t132;
    insert = tmp;
    pos = s;
    while(( *pos & 255) != 0) {
        if(( *pos & 255) != 60) {
L33:
            if(( *pos & 255) != 62) {
                 *insert =  *pos & 255;
                insert =  &(insert[1]);
            }
            pos =  &(pos[1]);
            continue;
        } else {
            tag = pos;
            tag_insert = tag_content;
            pos = pos - 1;
            if(pos >= s) {
                if(( *pos & 255) != 32) {
                    space = 0;
                } else {
                    space = 1;
                }
            }
            while(( *tag & 255) != 0) {
                 *tag_insert =  *tag & 255;
                 *tag_insert = ( *tag_insert & 255) + 1;
                if(( *tag & 255) != 62) {
                    tag =  &(tag[1]);
                    continue;
                }
                 *tag_insert = 0;
                tag_2 = tag;
                tag_2 =  &(tag_2[1]);
                if(( *tag_2 & 255) != 10) {
                    _v72 = 134564534;
                    _t164 = tag_content;
                     *__esp = _t164;
                    strstr();
                    if(_t164 != 0 && insert > tmp) {
                         *insert = 10;
                         *insert = ( *insert & 255) + 1;
                    }
                    _v72 = 134564539;
                    _t165 = tag_content;
                     *__esp = _t165;
                    strstr();
                    if(_t165 != 0 && insert > tmp) {
                         *insert = 10;
                         *insert = ( *insert & 255) + 1;
                    }
                    _v72 = 134564544;
                    _t166 = tag_content;
                     *__esp = _t166;
                    strstr();
                    if(_t166 != 0) {
                        if(insert > tmp) {
                             *insert = 10;
                             *insert = ( *insert & 255) + 1;
                        }
                         *insert = 10;
                         *insert = ( *insert & 255) + 1;
                    }
                    _v72 = 134564548;
                    _t167 = tag_content;
                     *__esp = _t167;
                    strstr();
                    if(_t167 != 0) {
                        if(insert > tmp) {
                             *insert = 10;
                             *insert = ( *insert & 255) + 1;
                        }
                         *insert = 10;
                         *insert = ( *insert & 255) + 1;
                    }
                }
                pos = tag;
                if(( *pos & 255) == 32) {
                    if(space == 1) {
                        pos =  &(pos[1]);
                        space = 0;
                    }
                }
                goto L33;
            }
            goto L33;
        }
    }
     *insert = 0;
    _v72 = tmp;
     *__esp = s;
    strcpy();
     *__esp = tmp;
    free();
     *__esp = tag_content;
    free();
    _v72 = 35;
    _t201 = s;
     *__esp = _t201;
    strchr();
    hashmark = _t201;
    if(hashmark == 0) {
L41:
        return s;
    }
    _t203 = s;
    if(_t203 != hashmark) {
         *__esp = 2048;
        malloc();
        tmp = _t203;
        _v72 = s;
         *__esp = tmp;
        strcpy();
        _v72 = 134564528;
        _t207 = tmp;
         *__esp = _t207;
        strtok();
        tmp = _t207;
        _v68 = tmp;
        _v72 = 134564530;
         *__esp = s;
        sprintf();
         *__esp = tmp;
        free();
        goto L41;
    }
    return nc_fgets_html(s, size, stream);
}

int is_text(char* s)
{// addr = 0x0804A146  --  defined in 'tools.c' at line 474
    int i;                                 // _cfa_fffffff0
    int nonws;                             // _cfa_ffffffec
    char* _t20;                            // _t20

    nonws = 0;
    _t20 = s;
     *__esp = _t20;
    strlen();
    i = _t20 - 1;
    while(i >= 0) {
        if((s[i] & 255) == 32 || (s[i] & 255) == 9) {
L6:
            nonws = 0;
            i = i - 1;
            continue;
        } else {
            if((s[i] & 255) == 10 || (s[i] & 255) == 12 || (s[i] & 255) == 13) {
                goto L6;
            } else {
                nonws = 1;
                break;
            }
        }
    }
    return nonws;
}

char* nc_fgets_nb(char* s, int size, FILE* stream)
{// addr = 0x0804A1C8  --  defined in 'tools.c' at line 500
    char* hashmark;                        // _cfa_fffffff0
    char* tmp;                             // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc (outparam)
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    char* _t38;                            // _t38
    char* _t41;                            // _t41
    char* _t43;                            // _t43
    char* _t47;                            // _t47

    _v36 = stream;
    _v40 = size;
    _t38 = s;
     *__esp = _t38;
    fgets();
    if(_t38 != 0) {
        if(is_text(s) != 0) {
            _v40 = 35;
            _t41 = s;
             *__esp = _t41;
            strchr();
            hashmark = _t41;
            if(hashmark == 0) {
L8:
                return s;
            }
            _t43 = s;
            if(_t43 != hashmark) {
                 *__esp = 2048;
                malloc();
                tmp = _t43;
                _v40 = s;
                 *__esp = tmp;
                strcpy();
                _v40 = 134564528;
                _t47 = tmp;
                 *__esp = _t47;
                strtok();
                tmp = _t47;
                _v36 = tmp;
                _v40 = 134564530;
                 *__esp = s;
                sprintf();
                 *__esp = tmp;
                free();
                goto L8;
            }
            return nc_fgets_nb(s, size, stream);
        }
        return nc_fgets_nb(s, size, stream);
    }
    return 0;
}

void dump_ascii(char* file, char* heading)
{// addr = 0x0804A2C8  --  defined in 'tools.c' at line 539
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    FILE* f;              // _cfa_fffff7ec
    FILE* _v2080;         // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    intOrPtr _v2096;                       // _cfa_fffff7d0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    intOrPtr _v2104;                       // _cfa_fffff7c8
    FILE* _t31;           // _t31

    _v2080 = file;
    _v2084 = heading;
    _v16 =  *gs:0x14];
    _v2100 = _v2084;
    _v2104 = 134564530;
     *__esp = __imp__stdout;
    fprintf();
    _t31 = _v2080;
    _v2104 = 134564463;
     *__esp = _t31;
    fopen();
    f = _t31;
    if(f != 0) {
        while(1) {
            __eax = f;
            _v2100 = f;
            _v2104 = 2048;
            __eax =  &tmp;
             *__esp =  &tmp;
            if(nc_fgets_html() == 0) {
                break;
            }
            __eax = __imp__stdout;
            _v2100 =  &tmp;
            _v2104 = "  %s";
             *__esp = __imp__stdout;
            fprintf();
        }
        __eax = __imp__stdout;
        _v2104 = __imp__stdout;
         *__esp = 10;
        fputc();
        __eax = f;
         *__esp = f;
        fclose();
    } else {
        _v2096 = __imp__stdout;
        _v2100 = 28;
        _v2104 = 1;
         *__esp = "  No information available.\n";
        fwrite();
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void dump_plain(char* file, char* tmpfile)
{// addr = 0x0804A3DB  --  defined in 'tools.c' at line 563
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    FILE* f_in;           // _cfa_fffff7ec
    FILE* f_out;          // _cfa_fffff7e8
    FILE* _v2080;         // _cfa_fffff7e0
    FILE* _v2084;         // _cfa_fffff7dc
    FILE* _v2096;         // _cfa_fffff7d0
    FILE* _v2100;         // _cfa_fffff7cc (outparam)
    char[2047]* _v2104;                    // _cfa_fffff7c8 (outparam)
    FILE* _t38;           // _t38
    FILE* _t40;           // _t40
    FILE* _t50;           // _t50

    _v2080 = file;
    _v2084 = tmpfile;
    _v16 =  *gs:0x14];
    _v2100 = 32;
    _v2104 = "/tmp/grass.extensions.db.XXXXXX";
     *__esp = _v2084;
    memcpy();
     *__esp = _v2084;
    mkstemp();
    _t38 = _v2084;
    _v2104 = "w+";
     *__esp = _t38;
    fopen();
    f_out = _t38;
    if(f_out == 0) {
        __errno_location();
        _t50 = _t38->_flags;
         *__esp = _t50;
        strerror();
        _v2096 = _t50;
        _v2100 = _v2084;
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
    }
    atexit(exit_db);
    _t40 = _v2080;
    _v2104 = 134564463;
     *__esp = _t40;
    fopen();
    f_in = _t40;
    while(nc_fgets( &tmp, 2048, f_in) != 0) {
        _v2104 =  &tmp;
         *__esp = f_out;
        fprintf();
    }
     *__esp = f_in;
    fclose();
     *__esp = f_out;
    fclose();
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void dump_html(char* file, char* tmpfile)
{// addr = 0x0804A51B  --  defined in 'tools.c' at line 597
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] line;                       // _cfa_ffffeff0
    FILE* f_in;           // _cfa_ffffefec
    FILE* f_out;          // _cfa_ffffefe8
    int fd;                                // _cfa_ffffefe4
    FILE* _v4128;         // _cfa_ffffefe0
    FILE* _v4132;         // _cfa_ffffefdc
    FILE* _v4144;         // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc (outparam)
    char[2047]* _v4152;                    // _cfa_ffffefc8 (outparam)
    FILE* _t49;           // _t49
    FILE* _t51;           // _t51
    FILE* _t69;           // _t69

    _v4128 = file;
    _v4132 = tmpfile;
    _v16 =  *gs:0x14];
    _v4148 = 32;
    _v4152 = "/tmp/grass.extensions.db.XXXXXX";
     *__esp = _v4132;
    memcpy();
     *__esp = _v4132;
    mkstemp();
    _t49 = _v4132;
    _v4152 = "w+";
     *__esp = _t49;
    fopen();
    f_out = _t49;
    if(f_out == 0) {
        __errno_location();
        _t69 = _t49->_flags;
         *__esp = _t69;
        strerror();
        _v4144 = _t69;
        _v4148 = _v4132;
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
    }
    atexit(exit_db);
    _t51 = _v4128;
    _v4152 = 134564463;
     *__esp = _t51;
    fopen();
    f_in = _t51;
    while(nc_fgets( &line, 2048, f_in) != 0) {
        chop( &line);
        if(is_text( &line) != 0) {
            _v4148 =  &line;
            _v4152 = "%s <br>\n";
             *__esp =  &tmp;
            sprintf();
            _v4152 =  &tmp;
             *__esp = f_out;
            fprintf();
        } else {
            _v4144 = f_out;
            _v4148 = 4;
            _v4152 = 1;
             *__esp = "<p>\n";
            fwrite();
        }
    }
     *__esp = f_in;
    fclose();
     *__esp = f_out;
    fclose();
     *__esp = fd;
    close();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    }
    __stack_chk_fail();
}

void list_binaries(char* package)
{// addr = 0x0804A6DA  --  defined in 'tools.c' at line 642
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    DIR* dir;              // _cfa_fffff7ec
    struct dirent* dir_entry;   // _cfa_fffff7e8
    int n_dirs;                            // _cfa_fffff7e4
    _unknown_ _v2148;                      // _cfa_fffff79c
    struct stat buf;      // _cfa_fffff78c
    DIR* _v2176;           // _cfa_fffff780
    intOrPtr _v2192;                       // _cfa_fffff770
    char** _v2196;                         // _cfa_fffff76c
    char* _v2200;                          // _cfa_fffff768 (outparam)
    DIR* _t60;             // _t60
    struct dirent* _t61;   // _t61
    char** _t63;                           // _t63
    struct dirent* _t64;   // _t64
    char** _t72;                           // _t72
    char** _t74;                           // _t74

    _v2176 = package;
    _v16 =  *gs:0x14];
    n_dirs = 0;
    _v2192 = __imp__stdout;
    _v2196 = 26;
    _v2200 = 1;
     *__esp = "Binary installation files\n";
    fwrite();
    _t60 = _v2176;
     *__esp = _t60;
    opendir();
    dir = _t60;
    if(dir != 0) {
        _t61 = dir;
         *__esp = _t61;
        readdir();
        dir_entry = _t61;
        while(dir_entry != 0) {
            _t63 =  &(dir_entry->d_name);
            _v2200 = 134564798;
             *__esp = _t63;
            strcmp();
            if(_t63 != 0) {
                _t72 =  &(dir_entry->d_name);
                _v2200 = 134564800;
                 *__esp = _t72;
                strcmp();
                if(_t72 != 0) {
                    _t74 =  &(dir_entry->d_name);
                    _v2200 = 134564803;
                     *__esp = _t74;
                    strcmp();
                    if(_t74 != 0) {
                        _v2192 =  &(dir_entry->d_name);
                        _v2196 = _v2176;
                        _v2200 = "%s/%s";
                         *__esp =  &tmp;
                        sprintf();
                        __stat( &tmp,  &(buf.st_dev));
                        if((buf.st_mode & 61440) == 16384) {
                            if(n_dirs != 0) {
                                _v2196 =  &(dir_entry->d_name);
                                _v2200 = 134564807;
                                 *__esp = __imp__stdout;
                                fprintf();
                            } else {
                                _v2196 =  &(dir_entry->d_name);
                                _v2200 = "  %s";
                                 *__esp = __imp__stdout;
                                fprintf();
                            }
                            n_dirs = n_dirs + 1;
                        }
                    }
                }
            }
            _t64 = dir;
             *__esp = _t64;
            readdir();
            dir_entry = _t64;
        }
        if(n_dirs == 0) {
            _v2192 = __imp__stdout;
            _v2196 = 7;
            _v2200 = 1;
             *__esp = "  None.";
            fwrite();
        }
        _v2192 = __imp__stdout;
        _v2196 = 2;
        _v2200 = 1;
         *__esp = "\n\n";
        fwrite();
        goto L16;
    } else {
        _v2192 = __imp__stdout;
        _v2196 = 9;
        _v2200 = 1;
         *__esp = "  None.\n\n";
        fwrite();
L16:
        if((_v16 ^  *gs:0x14]) == 0) {
            return;
        }
        __stack_chk_fail();
        return;
    }
}

int binaries_exist(char* package, char* binaries)
{// addr = 0x0804A92C  --  defined in 'tools.c' at line 690
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    DIR* dir;              // _cfa_fffff7ec
    struct dirent* dir_entry;   // _cfa_fffff7e8
    _unknown_ _v2144;                      // _cfa_fffff7a0
    struct stat buf;      // _cfa_fffff790
    DIR* _v2176;           // _cfa_fffff780
    char* _v2180;                          // _cfa_fffff77c
    char** _v2192;                         // _cfa_fffff770
    DIR* _v2196;           // _cfa_fffff76c
    char* _v2200;                          // _cfa_fffff768 (outparam)
    DIR* _t40;             // _t40
    struct dirent* _t41;   // _t41
    char** _t43;                           // _t43
    struct dirent* _t44;   // _t44
    int _t45;                              // _t45
    char** _t47;                           // _t47
    char** _t49;                           // _t49
    char* _t58;                            // _t58

    _v2176 = package;
    _v2180 = binaries;
    _v16 =  *gs:0x14];
    _t40 = _v2176;
     *__esp = _t40;
    opendir();
    dir = _t40;
    if(dir != 0) {
        _t41 = dir;
         *__esp = _t41;
        readdir();
        dir_entry = _t41;
        while(dir_entry != 0) {
            _t43 =  &(dir_entry->d_name);
            _v2200 = 134564798;
             *__esp = _t43;
            strcmp();
            if(_t43 == 0) {
L9:
                _t44 = dir;
                 *__esp = _t44;
                readdir();
                dir_entry = _t44;
                continue;
            } else {
                _t47 =  &(dir_entry->d_name);
                _v2200 = 134564800;
                 *__esp = _t47;
                strcmp();
                if(_t47 == 0) {
                    goto L9;
                } else {
                    _t49 =  &(dir_entry->d_name);
                    _v2200 = 134564803;
                     *__esp = _t49;
                    strcmp();
                    if(_t49 == 0) {
                        goto L9;
                    } else {
                        _v2192 =  &(dir_entry->d_name);
                        _v2196 = _v2176;
                        _v2200 = "%s/%s";
                         *__esp =  &tmp;
                        sprintf();
                        __stat( &tmp,  &(buf.st_dev));
                        if((buf.st_mode & 61440) != 16384) {
                            goto L9;
                        } else {
                            _t58 = _v2180;
                            _v2200 = _t58;
                             *__esp =  &(dir_entry->d_name);
                            strcmp();
                            if(_t58 != 0) {
                                goto L9;
                            } else {
                                _t45 = 1;
                            }
                        }
                    }
                }
            }
            goto L12;
        }
        _t45 = 0;
    } else {
        _t45 = 0;
    }
L12:
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t45;
    }
    return _t45;
}

int check_filetype(char* myfile)
{// addr = 0x0804AAA8  --  defined in 'tools.c' at line 737
    char* _v24;                            // _cfa_ffffffe8
    char* _t13;                            // _t13
    char* _t14;                            // _t14
    char* _t15;                            // _t15
    char* _t16;                            // _t16
    char* _t17;                            // _t17
    char* _t18;                            // _t18

    _v24 = ".tar.gz";
    _t13 = myfile;
     *__esp = _t13;
    strstr();
    if(_t13 == 0) {
        _v24 = ".tgz";
        _t14 = myfile;
         *__esp = _t14;
        strstr();
        if(_t14 == 0) {
            _v24 = ".tar.bz2";
            _t15 = myfile;
             *__esp = _t15;
            strstr();
            if(_t15 == 0) {
                _v24 = ".tbz";
                _t16 = myfile;
                 *__esp = _t16;
                strstr();
                if(_t16 == 0) {
                    _v24 = ".zip";
                    _t17 = myfile;
                     *__esp = _t17;
                    strstr();
                    if(_t17 == 0) {
                        _v24 = ".tar";
                        _t18 = myfile;
                         *__esp = _t18;
                        strstr();
                        if(_t18 == 0) {
                            return 0;
                        }
                        return 4;
                    }
                    return 3;
                }
                return 2;
            }
            return 2;
        }
        return 1;
    }
    return 1;
}

void wget_extension(char* url)
{// addr = 0x0804AB6C  --  defined in 'tools.c' at line 766
    signed int _v16;                       // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    intOrPtr _v2096;                       // _cfa_fffff7d0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8 (outparam)

    _v2080 = url;
    _v16 =  *gs:0x14];
    _v2096 = __imp__stdout;
    _v2100 = 14;
    _v2104 = 1;
     *__esp = "Downloading...";
    fwrite();
    if(VERBOSE == 0) {
        _v2100 = _v2080;
        _v2104 = "wget -N -q %s";
         *__esp =  &str;
        sprintf();
    } else {
        _v2100 = _v2080;
        _v2104 = "wget -N %s";
         *__esp =  &str;
        sprintf();
    }
     *__esp =  &str;
    system();
    error =  &str;
    if(error == -1) {
        print_error(-20, "could not run 'wget' to download extension. Is it installed?\n");
    }
    if(error > 0) {
        _v2100 =  &str;
        print_error(-20, "running command '%s'.\n");
    }
    print_done();
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void su(char* gisbase, char* cmd)
{// addr = 0x0804AC6E  --  defined in 'tools.c' at line 796
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmpfile;                    // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    FILE* f;              // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    int _v2084;                            // _cfa_fffff7dc
    long unsigned int _v2096;              // _cfa_fffff7d0
    int _v2100;                            // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8 (outparam)
    long unsigned int _t34;                // _t34
    int _t41;                              // _t41

    _v2080 = gisbase;
    _v2084 = cmd;
    _v16 =  *gs:0x14];
    next = 54321 + next * 1103515245;
    next = next >> 16 & 32767;
    _t34 = next;
     *__esp = _t34;
    srand();
    rand();
    _v2096 = _t34;
    _v2100 = _v2080;
    _v2104 = "%s/gem.test.%i";
     *__esp =  &tmpfile;
    sprintf();
    _v2104 = "w+";
     *__esp =  &tmpfile;
    fopen();
    f =  &tmpfile;
    __errno_location();
    if(tmpfile != 13) {
         *__esp =  &tmpfile;
        remove();
         *__esp = f;
        fclose();
        _t41 = _v2084;
         *__esp = _t41;
        system();
        error = _t41;
        if(error != 0) {
            _v2100 = _v2084;
            print_error(-9, "could not run '%s'.\n");
        }
    } else {
        print_error(-5, "You don't have write access to your local GRASS installation.\nPlease consult your system administrator.\n");
    }
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

int vercmp(int major, int minor, int revision, int major2, int minor2, int revision2)
{// addr = 0x0804AD9B  --  defined in 'tools.c' at line 832
    if(major == major2 && minor == minor2 && revision == revision2) {
        return 0;
    }
    if(major2 <= major) {
        if(major2 >= major) {
            if(minor2 <= minor) {
                if(minor2 >= minor) {
                    if(revision2 <= revision) {
                        if(revision2 >= revision) {
                            return 0;
                        }
                        return 1;
                    }
                    return -1;
                }
                return 1;
            }
            return -1;
        }
        return 1;
    }
    return -1;
}

char* depstr(char* package, char* gisbase)
{// addr = 0x0804AE20  --  defined in 'reg_deps.c' at line 32
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] line;                       // _cfa_ffffeff0
    char[2047] short_name;                 // _cfa_ffffe7f0
    char* str;                             // _cfa_ffffe7ec
    int first;                             // _cfa_ffffe7e8
    int error;                             // _cfa_ffffe7e4
    FILE* f_deps;         // _cfa_ffffe7e0
    char* _v6192;                          // _cfa_ffffe7d0
    char* _v6196;                          // _cfa_ffffe7cc
    FILE* _v6208;         // _cfa_ffffe7c0
    char[2047]* _v6212;                    // _cfa_ffffe7bc (outparam)
    char* _v6216;                          // _cfa_ffffe7b8 (outparam)
    char* _t70;                            // _t70
    FILE** _t71;          // _t71
    FILE* _t72;           // _t72

    _v6192 = package;
    _v6196 = gisbase;
    _v16 =  *gs:0x14];
    _v6212 = 11;
    _v6216 = "../depends";
     *__esp =  &file;
    memcpy();
    _v6216 = 134565139;
     *__esp =  &file;
    fopen();
    f_deps =  &file;
    if(f_deps != 0) {
L4:
        first = 1;
         *__esp = 2048;
        malloc();
        str =  &file;
        do {
        } while(nc_fgets_nb( &line, 2048, f_deps) != 0);
         *__esp = f_deps;
        fclose();
        _t70 = str;
L13:
        if((_v16 ^  *gs:0x14]) == 0) {
            return _t70;
        }
        __stack_chk_fail();
        return _t70;
    }
    __errno_location();
    _t71 = file;
    if(_t71 != 2) {
        __errno_location();
        _t72 =  *_t71;
         *__esp = _t72;
        strerror();
        _v6208 = _t72;
        _v6212 =  &file;
        print_error(-17, "checking for file '%s': %s\n");
        goto L4;
    } else {
        _t70 = 134565141;
        goto L13;
    }
}

void register_extension(char* gisbase, char* bins, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision)
{// addr = 0x0804B014  --  defined in 'reg_deps.c' at line 87
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] short_name;                 // _cfa_ffffe7f0
    char[2047] inst_bins;                  // _cfa_ffffdff0
    char[2047] deps;                       // _cfa_ffffd7f0
    int n_lines;                           // _cfa_ffffd7ec
    int error;                             // _cfa_ffffd7e8
    int db_exists;                         // _cfa_ffffd7e4
    int must_register;                     // _cfa_ffffd7e0
    int copy_thru;                         // _cfa_ffffd7dc
    int ext_exists;                        // _cfa_ffffd7d8
    FILE* f_in;           // _cfa_ffffd7d4
    FILE* f_out;          // _cfa_ffffd7d0
    int major;                             // _cfa_ffffd7cc
    int minor;                             // _cfa_ffffd7c8
    int revision;                          // _cfa_ffffd7c4
    char* _v10304;                         // _cfa_ffffd7c0
    char* _v10308;                         // _cfa_ffffd7bc
    char* _v10312;                         // _cfa_ffffd7b8
    char[2047]* _v10320;                   // _cfa_ffffd7b0
    char[2047]* _v10324;                   // _cfa_ffffd7ac
    int _v10328;                           // _cfa_ffffd7a8 (outparam)
    int _v10332;                           // _cfa_ffffd7a4 (outparam)
    int _v10336;                           // _cfa_ffffd7a0 (outparam)
    char[2047]* _v10340;                   // _cfa_ffffd79c (outparam)
    char* _v10344;                         // _cfa_ffffd798 (outparam)
    _unknown_ __ebx;                       // r1
    FILE* _t232;          // _t232
    int _t233;                             // _t233

    _v10304 = gisbase;
    _v10308 = bins;
    _v10312 = pkg_short_name;
    _v16 =  *gs:0x14];
    db_exists = 1;
    _v10340 = _v10304;
    _v10344 = "%s/etc/extensions.db";
     *__esp =  &file;
    sprintf();
    _v10344 = 134565139;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in == 0) {
        __errno_location();
        if(file != 2) {
            _t232 = f_in;
             *__esp = _t232;
            fclose();
            __errno_location();
            _t233 = _t232->_flags;
             *__esp = _t233;
            strerror();
            _v10336 = _t233;
            _v10340 =  &file;
            print_error(-15, "checking for file '%s': %s\n");
        } else {
            db_exists = 0;
        }
    }
    if(db_exists == 0) {
L25:
        if(n_lines == 0 || db_exists == 0) {
            _v10340 = 32;
            _v10344 = "/tmp/grass.extensions.db.XXXXXX";
             *__esp =  &TMPDB;
            memcpy();
             *__esp =  &TMPDB;
            mkstemp();
            _v10344 = "w+";
             *__esp =  &TMPDB;
            fopen();
            f_out =  &TMPDB;
            if(f_out == 0) {
                __errno_location();
                 *__esp =  &TMPDB;
                strerror();
                _v10336 = TMPDB;
                _v10340 =  &file;
                print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            }
            atexit(exit_db);
            _v10344 = depstr(_v10312, _v10304);
             *__esp =  &deps;
            strcpy();
            _v10320 =  &deps;
            _v10324 = _v10308;
            _v10328 = pkg_revision;
            _v10332 = pkg_minor;
            _v10336 = pkg_major;
            _v10340 = _v10312;
            _v10344 = "%s\t%i.%i.%i\t%s\t%s\n";
             *__esp = f_out;
            fprintf();
             *__esp = f_out;
            fclose();
        }
        if((_v16 ^  *gs:0x14]) == 0) {
            return;
        } else {
            __stack_chk_fail();
            return;
        }
    } else {
        _v10340 = 32;
        _v10344 = "/tmp/grass.extensions.db.XXXXXX";
         *__esp =  &TMPDB;
        memcpy();
         *__esp =  &TMPDB;
        mkstemp();
        _v10344 = "w+";
         *__esp =  &TMPDB;
        fopen();
        f_out =  &TMPDB;
        if(f_out == 0) {
            __errno_location();
             *__esp =  &TMPDB;
            strerror();
            _v10336 = TMPDB;
            _v10340 =  &TMPDB;
            print_error(-15, "could not create temp file '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        n_lines = 0;
        must_register = 1;
        ext_exists = 0;
        while(nc_fgets_nb( &str, 2048, f_in) != 0) {
            n_lines = n_lines + 1;
            copy_thru = 1;
            _v10320 =  &deps;
            _v10324 =  &inst_bins;
            _v10328 =  &revision;
            _v10332 =  &minor;
            _v10336 =  &major;
            _v10340 =  &short_name;
            _v10344 = "%s\t%i.%i.%i\t%s\t%s";
             *__esp =  &str;
            __isoc99_sscanf();
            _v10344 = _v10312;
             *__esp =  &short_name;
            strcmp();
            if( &short_name == 0) {
                ext_exists = 1;
                error = vercmp(major, minor, revision, pkg_major, pkg_minor, pkg_revision);
                if(FORCE == 0) {
                    if(error >= 0) {
                        _v10328 = revision;
                        _v10332 = minor;
                        _v10336 = major;
                        _v10340 = _v10312;
                        print_error(-16, "Extension '%s' with same or higher version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n");
                    } else {
                        _v10328 = revision;
                        _v10332 = minor;
                        _v10336 = major;
                        _v10340 = _v10312;
                        print_error(-16, "Extension '%s' with lower version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n");
                    }
                }
                if(FORCE != 0) {
                    if(error != 0) {
                        must_register = 1;
                        copy_thru = 0;
                    } else {
                        must_register = 0;
                    }
                }
            }
            if(copy_thru != 0) {
                _v10344 =  &str;
                 *__esp = f_out;
                fprintf();
                 *__esp = f_out;
                fflush();
            }
        }
        if(must_register != 0) {
            if(ext_exists != 0) {
                _v10344 = depstr(_v10312, _v10304);
                 *__esp =  &deps;
                strcpy();
                _v10320 =  &deps;
                _v10324 =  &inst_bins;
                _v10328 = pkg_revision;
                _v10332 = pkg_minor;
                _v10336 = pkg_major;
                _v10340 =  &short_name;
                _v10344 = "%s\t%i.%i.%i\t%s\t%s\n";
                 *__esp = f_out;
                fprintf();
            } else {
                _v10344 = depstr(_v10312, _v10304);
                 *__esp =  &deps;
                strcpy();
                _v10320 =  &deps;
                _v10324 = _v10308;
                _v10328 = pkg_revision;
                _v10332 = pkg_minor;
                _v10336 = pkg_major;
                _v10340 = _v10312;
                _v10344 = "%s\t%i.%i.%i\t%s\t%s\n";
                 *__esp = f_out;
                fprintf();
            }
        }
         *__esp = f_out;
        fclose();
         *__esp = f_in;
        fclose();
        goto L25;
    }
}

void deregister_extension(char* package, char* pkg_short_name, char* gisbase)
{// addr = 0x0804B5E3  --  defined in 'reg_deps.c' at line 235
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] short_name;                 // _cfa_ffffe7f0
    char[2047] inst_bins;                  // _cfa_ffffdff0
    char[2047] deps;                       // _cfa_ffffd7f0
    int error;                             // _cfa_ffffd7ec
    int db_exists;                         // _cfa_ffffd7e8
    int copy_thru;                         // _cfa_ffffd7e4
    FILE* f_in;           // _cfa_ffffd7e0
    FILE* f_out;          // _cfa_ffffd7dc
    int found_ext;                         // _cfa_ffffd7d8
    int major;                             // _cfa_ffffd7d4
    int minor;                             // _cfa_ffffd7d0
    int revision;                          // _cfa_ffffd7cc
    char* _v10304;                         // _cfa_ffffd7c0
    char* _v10308;                         // _cfa_ffffd7bc
    char* _v10312;                         // _cfa_ffffd7b8
    _unknown_ _v10320;                     // _cfa_ffffd7b0
    _unknown_ _v10324;                     // _cfa_ffffd7ac
    _unknown_ _v10328;                     // _cfa_ffffd7a8
    _unknown_ _v10332;                     // _cfa_ffffd7a4
    char* _v10336;                         // _cfa_ffffd7a0
    char[2047]* _v10340;                   // _cfa_ffffd79c (outparam)
    char* _v10344;                         // _cfa_ffffd798 (outparam)
    _unknown_ _t101;                       // _t101
    int _t116;                             // _t116
    char[2047]* _t117;                     // _t117
    FILE* _t121;          // _t121
    char[2047]* _t122;                     // _t122

    _v10304 = package;
    _v10308 = pkg_short_name;
    _v10312 = gisbase;
    _v16 =  *gs:0x14];
    db_exists = 0;
    _v10340 = _v10312;
    _v10344 = "%s/etc/extensions.db";
     *__esp =  &file;
    sprintf();
    _v10344 = 134565139;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in != 0) {
        db_exists = 1;
    } else {
        __errno_location();
        if(file != 2 || FORCE != 0) {
            if(FORCE == 0) {
                _t121 = f_in;
                 *__esp = _t121;
                fclose();
                __errno_location();
                _t122 = _t121->_flags;
                 *__esp = _t122;
                strerror();
                _v10336 = _t122;
                _v10340 =  &file;
                print_error(-19, "checking for file '%s': %s\n");
            }
        } else {
             *__esp = f_in;
            fclose();
            print_error(-19, "could not deregister: no extensions installed\n");
        }
    }
    if(db_exists == 0) {
L13:
        if(db_exists == 0) {
L27:
            if((_v16 ^  *gs:0x14]) == 0) {
                return;
            }
            __stack_chk_fail();
            return;
        } else {
            found_ext = 0;
            do {
            } while(nc_fgets_nb( &str, 2048, f_in) != 0);
            if(found_ext == 0) {
                _v10336 = _v10312;
                _v10340 = _v10308;
                print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
            }
             *__esp = f_in;
            fclose();
             *__esp = f_out;
            fclose();
            goto L27;
        }
    }
    db_exists = 0;
    _v10340 = 32;
    _v10344 = "/tmp/grass.extensions.db.XXXXXX";
     *__esp =  &TMPDB;
    memcpy();
     *__esp =  &TMPDB;
    mkstemp();
    _v10344 = "w+";
     *__esp =  &TMPDB;
    fopen();
    f_out =  &TMPDB;
    if(f_out != 0) {
L12:
        db_exists = 1;
        atexit(exit_db);
        goto L13;
    }
    _t116 = FORCE;
    if(_t116 != 0) {
        goto L12;
    } else {
        __errno_location();
        _t117 =  *_t116;
         *__esp = _t117;
        strerror();
        _v10336 = _t117;
        _v10340 =  &file;
        print_error(-19, "could not create temp db '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        goto L13;
    }
}

void check_dependencies(char* package, char* gisbase, char* grass_version)
{// addr = 0x0804B961  --  defined in 'reg_deps.c' at line 340
    signed int _v32;                       // _cfa_ffffffe0
    char[2047] file;                       // _cfa_fffff7e0
    char[2047] str;                        // _cfa_ffffefe0
    char[2047] dbstr;                      // _cfa_ffffe7e0
    char[2047] short_name;                 // _cfa_ffffdfe0
    char[2047] dep_short_name;             // _cfa_ffffd7e0
    int error;                             // _cfa_ffffd7dc
    int db_exists;                         // _cfa_ffffd7d8
    int satisfied;                         // _cfa_ffffd7d4
    FILE* f_deps;         // _cfa_ffffd7d0
    FILE* f_db;           // _cfa_ffffd7cc
    int major;                             // _cfa_ffffd7c8
    int minor;                             // _cfa_ffffd7c4
    int revision;                          // _cfa_ffffd7c0
    int dep_major;                         // _cfa_ffffd7bc
    int dep_minor;                         // _cfa_ffffd7b8
    int dep_revision;                      // _cfa_ffffd7b4
    char* _v10320;                         // _cfa_ffffd7b0
    char* _v10324;                         // _cfa_ffffd7ac
    char* _v10328;                         // _cfa_ffffd7a8
    int _v10348;                           // _cfa_ffffd794
    int _v10352;                           // _cfa_ffffd790
    int _v10356;                           // _cfa_ffffd78c
    int _v10360;                           // _cfa_ffffd788 (outparam)
    int _v10364;                           // _cfa_ffffd784 (outparam)
    int _v10368;                           // _cfa_ffffd780 (outparam)
    char[2047]* _v10372;                   // _cfa_ffffd77c (outparam)
    char* _v10376;                         // _cfa_ffffd778 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    FILE* _t156;          // _t156
    FILE* _t187;          // _t187
    int _t188;                             // _t188
    FILE* _t191;          // _t191
    int _t192;                             // _t192

    _v10320 = package;
    _v10324 = gisbase;
    _v10328 = grass_version;
    _v32 =  *gs:0x14];
    if(FORCE != 0) {
L30:
        if((_v32 ^  *gs:0x14]) == 0) {
            return;
        }
        __stack_chk_fail();
        return;
    }
    _t156 = "../depends";
    _v10376 = 134565139;
     *__esp = _t156;
    fopen();
    f_deps = _t156;
    if(f_deps != 0) {
L5:
        db_exists = 1;
        _v10372 = _v10324;
        _v10376 = "%s/etc/extensions.db";
         *__esp =  &file;
        sprintf();
        _v10376 = 134565139;
         *__esp =  &file;
        fopen();
        f_db =  &file;
        if(f_db == 0) {
            __errno_location();
            if(file != 2) {
                _t187 = f_db;
                 *__esp = _t187;
                fclose();
                __errno_location();
                _t188 = _t187->_flags;
                 *__esp = _t188;
                strerror();
                _v10368 = _t188;
                _v10372 =  &file;
                print_error(-17, "checking for file '%s': %s\n");
            } else {
                db_exists = 0;
            }
        }
        satisfied = 0;
        while(nc_fgets_nb( &str, 2048, f_deps) != 0) {
            major = 0;
            minor = 0;
            revision = 0;
            dep_major = 0;
            dep_minor = 0;
            dep_revision = 0;
            _v10360 =  &dep_revision;
            _v10364 =  &dep_minor;
            _v10368 =  &dep_major;
            _v10372 =  &dep_short_name;
            _v10376 = "%s\t%i.%i.%i";
             *__esp =  &str;
            __isoc99_sscanf();
            error =  &str;
            if(error <= 0) {
                continue;
            }
            _v10376 = "GRASS";
             *__esp =  &dep_short_name;
            strcmp();
            if( &dep_short_name != 0) {
                if(db_exists == 0) {
                    continue;
                }
                satisfied = 0;
                 *__esp = f_db;
                rewind();
                while(nc_fgets_nb( &dbstr, 2048, f_db) != 0) {
                    major = 0;
                    minor = 0;
                    revision = 0;
                    _v10360 =  &revision;
                    _v10364 =  &minor;
                    _v10368 =  &major;
                    _v10372 =  &short_name;
                    _v10376 = "%s\t%i.%i.%i";
                     *__esp =  &dbstr;
                    __isoc99_sscanf();
                    error =  &dbstr;
                    if(error > 0) {
                        _v10376 =  &dep_short_name;
                         *__esp =  &short_name;
                        strcmp();
                        if( &short_name == 0) {
                            if(vercmp(major, minor, revision, dep_major, dep_minor, dep_revision) < 0) {
                                _v10348 = dep_revision;
                                _v10352 = dep_minor;
                                _v10356 = dep_major;
                                _v10360 =  &dep_short_name;
                                _v10364 = revision;
                                _v10368 = minor;
                                _v10372 = major;
                                print_error(-18, "installed version %i.%i.%i of required extension '%s' is too low.\n \t\t\t\t\t\t\t\t\t\t\t\t\tRequired version is %i.%i.%i\n");
                            }
                            satisfied = 1;
                        }
                    }
                }
                if(satisfied == 0) {
                    _v10368 = _v10324;
                    _v10372 =  &dep_short_name;
                    print_error(-18, "required extension '%s' not found in '%s'.\n");
                }
                continue;
            }
            _v10364 =  &revision;
            _v10368 =  &minor;
            _v10372 =  &major;
            _v10376 = "%i.%i.%i";
             *__esp = _v10328;
            __isoc99_sscanf();
            if(vercmp(major, minor, revision, dep_major, dep_minor, dep_revision) < 0) {
                _v10360 = dep_revision;
                _v10364 = dep_minor;
                _v10368 = dep_major;
                _v10372 = _v10328;
                print_error(-18, "installed version (%s) of GRASS is too low. Required version is %i.%i.%i\n");
            }
            satisfied = 1;
        }
        if(db_exists != 0) {
             *__esp = f_db;
            fclose();
        }
         *__esp = f_deps;
        fclose();
        goto L30;
    }
    __errno_location();
    if(_t156->_flags != 2) {
        _t191 = f_deps;
         *__esp = _t191;
        fclose();
        __errno_location();
        _t192 = _t191->_flags;
         *__esp = _t192;
        strerror();
        _v10368 = _t192;
        _v10372 =  &file;
        print_error(-17, "checking for file '%s': %s\n");
        goto L5;
    } else {
        _v10372 = _v10320;
        _v10376 = "\n%s/depends ENOENT\n";
         *__esp = __imp__stderr;
        fprintf();
        goto L30;
    }
}

int is_submenu(char* item)
{// addr = 0x0804BE84  --  defined in 'reg_entries.c' at line 36
    intOrPtr _v24;                         // _cfa_ffffffe8
    char* _t9;                             // _t9
    char* _t10;                            // _t10
    char* _t11;                            // _t11
    char* _t12;                            // _t12

    _v24 = 91;
    _t9 = item;
     *__esp = _t9;
    strchr();
    if(_t9 != 0) {
        _v24 = 93;
        _t10 = item;
         *__esp = _t10;
        strrchr();
        if(_t10 != 0) {
            _v24 = 91;
            _t11 = item;
             *__esp = _t11;
            strchr();
            _v24 = 93;
            _t12 = item;
             *__esp = _t12;
            strrchr();
            if(_t11 <= _t12) {
                return 1;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

int check_ext_menu(char** tcl_lines)
{// addr = 0x0804BF05  --  defined in 'reg_entries.c' at line 57
    int idx;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    idx = find_pos(""&Xtns" all options 1", tcl_lines, 0);
    if(idx != -1) {
L6:
        return idx;
    }
    idx = find_pos(""&Help" all options", tcl_lines, 0);
    if(idx != -1) {
        insert_str(" "&Xtns" all options 1 {\n", idx, tcl_lines);
        idx = idx + 1;
        insert_str(" }\n", idx, tcl_lines);
        goto L6;
    }
    idx = find_pos("}]", tcl_lines, 0);
    if(idx == -1) {
        print_error(-21, "could not parse 'menu.tcl'.\n");
    }
    insert_str(" "&Xtns" all options 1 {\n", idx, tcl_lines);
    idx = idx + 1;
    insert_str(" }\n", idx, tcl_lines);
    return idx;
}

int new_submenu(char* pkg_short_name, char* menu, char** tcl_lines)
{// addr = 0x0804C009  --  defined in 'reg_entries.c' at line 90
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] tmp2;                       // _cfa_ffffeff0
    char[2047] searchstr;                  // _cfa_ffffe7f0
    int idx;                               // _cfa_ffffe7ec
    int idx2;                              // _cfa_ffffe7e8
    int insert_here;                       // _cfa_ffffe7e4
    int last;                              // _cfa_ffffe7e0
    char* first_quote;                     // _cfa_ffffe7dc
    char* second_quote;                    // _cfa_ffffe7d8
    int len;                               // _cfa_ffffe7d4
    int terminator;                        // _cfa_ffffe7d0
    char* _v6208;                          // _cfa_ffffe7c0
    char* _v6212;                          // _cfa_ffffe7bc
    char** _v6216;                         // _cfa_ffffe7b8
    char[2047]* _v6224;                    // _cfa_ffffe7b0
    char[2047]* _v6228;                    // _cfa_ffffe7ac (outparam)
    char[2047]* _v6232;                    // _cfa_ffffe7a8 (outparam)
    _unknown_ __ebx;                       // r1
    char[2047]* _t138;                     // _t138
    char[2047]* _t139;                     // _t139
    char[2047]* _t141;                     // _t141
    int _t175;                             // _t175
    char* _t180;                           // _t180
    char* _t182;                           // _t182

    _v6208 = pkg_short_name;
    _v6212 = menu;
    _v6216 = tcl_lines;
    _v16 =  *gs:0x14];
    idx = find_pos(""&Xtns" all options", _v6216, 0);
    last = find_pos("" all options", _v6216, idx + 1) - 1;
    if(last == -1) {
        last = find_pos("}]", _v6216, 0);
    }
    if(is_submenu(_v6212) != 0) {
        _v6232 = 93;
        _t138 = _v6212;
         *__esp = _t138;
        strrchr();
        _v6232 = 91;
        _t139 = _v6212;
         *__esp = _t139;
        strchr();
        len = _t138 - _t139;
        _v6232 = 91;
        _t141 = _v6212;
         *__esp = _t141;
        strchr();
        _v6228 = len;
        _v6232 = _t141 + 1;
         *__esp =  &tmp;
        strncpy();
         *((char*)(__ebp + len - 0xfffffffffffff7f5)) = 0;
        _v6228 =  &tmp;
        _v6232 = "{cascad "%s"";
         *__esp =  &searchstr;
        sprintf();
        idx2 = find_pos( &searchstr, _v6216, idx);
        if(idx2 == -1 || idx2 >= last) {
            insert_here = idx + 1;
            idx2 = find_pos("{cascad ", _v6216, idx);
            while(idx2 != -1 && idx2 < last) {
                _t180 = _v6216[idx2];
                _v6232 = 34;
                 *__esp = _t180;
                strchr();
                first_quote = _t180;
                _t182 =  &(first_quote[1]);
                _v6232 = 34;
                 *__esp = _t182;
                strchr();
                second_quote = _t182;
                len = second_quote - first_quote;
                _v6228 = len;
                _v6232 =  &(first_quote[1]);
                 *__esp =  &tmp2;
                strncpy();
                 *((char*)(__ebp + len - 0xffffffffffffeff5)) = 0;
                _v6232 =  &tmp2;
                 *__esp =  &tmp;
                strcmp();
                if( &tmp >= 0) {
                    idx = idx + 1;
                    idx2 = find_pos("{cascad ", _v6216, idx);
                    continue;
                }
                insert_here = idx2;
                break;
            }
            _v6228 =  &searchstr;
            _v6232 = " \t\t\t%s {} "" 1 {\n";
             *__esp =  &tmp;
            sprintf();
            insert_str( &tmp, insert_here, _v6216);
            insert_str(" \t\t\t}}\n", insert_here + 1, _v6216);
            terminator = find_pos("}]", _v6216, 0);
            _v6224 =  &searchstr;
            _v6228 = _v6208;
            _v6232 = "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} "" 1 {\n";
             *__esp =  &tmp;
            sprintf();
            insert_str( &tmp, terminator + 1, _v6216);
            _t175 = insert_here + 1;
            goto L14;
        } else {
            _v6232 =  &tmp;
            print_warning("submenu '%s' exists in GIS Manager's Xtns menu.\n");
            _t175 = -1;
L14:
            if((_v16 ^  *gs:0x14]) == 0) {
                return _t175;
            }
            __stack_chk_fail();
            return _t175;
        }
    }
    print_warning("first line not a submenu specifier in 'entries-gisman'.\n");
    _t175 = -1;
    goto L14;
}

int new_item(char* item, char* menu, char** tcl_lines, int line_no)
{// addr = 0x0804C41B  --  defined in 'reg_entries.c' at line 173
    signed int _v16;                       // _cfa_fffffff0
    char[2047] entry;                      // _cfa_fffff7f0
    char[2047] command;                    // _cfa_ffffeff0
    char[2047] tmp;                        // _cfa_ffffe7f0
    char* token;                           // _cfa_ffffe7ec
    int num_tokens;                        // _cfa_ffffe7e8
    char* _v6176;                          // _cfa_ffffe7e0
    char* _v6180;                          // _cfa_ffffe7dc
    char** _v6184;                         // _cfa_ffffe7d8
    char[2047]* _v6204;                    // _cfa_ffffe7c4
    char[2047]* _v6208;                    // _cfa_ffffe7c0
    char[2047]* _v6212;                    // _cfa_ffffe7bc (outparam)
    int _v6216;                            // _cfa_ffffe7b8 (outparam)
    char* _t61;                            // _t61
    int _t72;                              // _t72

    _v6176 = item;
    _v6180 = menu;
    _v6184 = tcl_lines;
    _v16 =  *gs:0x14];
    chop(_v6176);
    _v6216 = 134566721;
    _t61 = _v6176;
     *__esp = _t61;
    strtok();
    token = _t61;
    if(token != 0) {
        _v6216 = token;
         *__esp =  &entry;
        strcpy();
        num_tokens = 0;
        while(token != 0) {
            _v6216 = 134566721;
             *__esp = 0;
            strtok();
            token = 134566721;
            if(token != 0) {
                _v6216 = token;
                 *__esp =  &command;
                strcpy();
            }
            num_tokens = num_tokens + 1;
        }
        if(num_tokens <= 2) {
            _v6216 = 134566812;
             *__esp =  &entry;
            strcmp();
            if( &entry != 0) {
L12:
                _v6204 =  &command;
                _v6208 =  &command;
                _v6212 =  &entry;
                _v6216 = " \t\t\t {command "%s" {} "%s" {} -command {%s }}\n";
                 *__esp =  &tmp;
                sprintf();
            } else {
                _v6216 = 134566812;
                 *__esp =  &entry;
                strcmp();
                if( &entry != 0) {
                    goto L12;
                } else {
                    _v6212 = 18;
                    _v6216 = " \t\t\t {separator}\n";
                     *__esp =  &tmp;
                    memcpy();
                }
            }
            insert_str( &tmp, line_no, _v6184);
            line_no = line_no + 1;
            _t72 = line_no;
        } else {
            _v6216 = num_tokens;
            print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n");
            _t72 = -1;
        }
    } else {
        print_warning("invalid token in 'entries-gisman'.\n");
        _t72 = -1;
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t72;
    }
    return _t72;
}

void register_entries_gisman(char* pkg_short_name, char* gisbase)
{// addr = 0x0804C5F0  --  defined in 'reg_entries.c' at line 232
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] menu;                       // _cfa_ffffe7f0
    int len;                               // _cfa_ffffe7ec
    char** line;                           // _cfa_ffffe7e8
    int n_entries;                         // _cfa_ffffe7e4
    int n_lines;                           // _cfa_ffffe7e0
    int i;                                 // _cfa_ffffe7dc
    int n_lines_org;                       // _cfa_ffffe7d8
    int n_lines_new;                       // _cfa_ffffe7d4
    int line_no;                           // _cfa_ffffe7d0
    FILE* f_gisman;       // _cfa_ffffe7cc
    FILE* f_in;           // _cfa_ffffe7c8
    FILE* f_out;          // _cfa_ffffe7c4
    char* _v6208;                          // _cfa_ffffe7c0
    char* _v6212;                          // _cfa_ffffe7bc
    char[2047]* _v6228;                    // _cfa_ffffe7ac
    char* _v6232;                          // _cfa_ffffe7a8
    char[2047]* _v6236;                    // _cfa_ffffe7a4
    char* _v6240;                          // _cfa_ffffe7a0
    char[2047]* _v6244;                    // _cfa_ffffe79c
    char[2047]* _v6248;                    // _cfa_ffffe798
    char* _v6252;                          // _cfa_ffffe794
    char[2047]* _v6256;                    // _cfa_ffffe790
    char[2047]* _v6260;                    // _cfa_ffffe78c
    char* _v6264;                          // _cfa_ffffe788
    char* _v6268;                          // _cfa_ffffe784
    char[2047]* _v6272;                    // _cfa_ffffe780 (outparam)
    char[2047]* _v6276;                    // _cfa_ffffe77c (outparam)
    char* _v6280;                          // _cfa_ffffe778 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t232;                          // _t232
    char* _t245;                           // _t245
    FILE* _t303;          // _t303
    char[2047]* _t304;                     // _t304
    FILE* _t307;          // _t307
    char[2047]* _t308;                     // _t308

    _v6208 = pkg_short_name;
    _v6212 = gisbase;
    _v16 =  *gs:0x14];
    _v6276 = 18;
    _v6280 = "../entries-gisman";
     *__esp =  &file;
    memcpy();
    _v6280 = 134566897;
     *__esp =  &file;
    fopen();
    f_gisman =  &file;
    if(f_gisman != 0) {
L3:
        _v6276 = _v6212;
        _v6280 = "%s/etc/dm/menu.tcl";
         *__esp =  &file;
        sprintf();
        _v6280 = 134566897;
         *__esp =  &file;
        fopen();
        f_in =  &file;
        if(f_in != 0) {
L6:
            _v6276 = 32;
            _v6280 = "/tmp/grass.extensions.db.XXXXXX";
             *__esp =  &TMP_GISMAN;
            memcpy();
             *__esp =  &TMP_GISMAN;
            mkstemp();
            _v6280 = "w+";
             *__esp =  &TMP_GISMAN;
            fopen();
            f_out =  &TMP_GISMAN;
            if(f_out == 0) {
                __errno_location();
                 *__esp =  &TMP_GISMAN;
                strerror();
                _v6272 = TMP_GISMAN;
                _v6276 =  &TMP_GISMAN;
                print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            }
            atexit(exit_db);
            if(VERBOSE == 0) {
                _v6228 =  &TMP_NULL;
                _v6232 = _v6212;
                _v6236 =  &TMP_NULL;
                _v6240 = _v6212;
                _v6244 =  &TMP_GISMAN;
                _v6248 =  &TMP_NULL;
                _v6252 = _v6212;
                _v6256 = _v6212;
                _v6260 =  &TMP_NULL;
                _v6264 = _v6208;
                _v6268 = _v6212;
                _v6272 =  &TMP_NULL;
                _v6276 = _v6212;
                _v6280 = "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;";
                 *__esp =  &str;
                sprintf();
            } else {
                _v6248 = _v6212;
                _v6252 = _v6212;
                _v6256 =  &TMP_GISMAN;
                _v6260 = _v6212;
                _v6264 = _v6212;
                _v6268 = _v6208;
                _v6272 = _v6212;
                _v6276 = _v6212;
                _v6280 = "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;";
                 *__esp =  &str;
                sprintf();
            }
            _v6280 =  &str;
             *__esp =  &GISMAN_CMD;
            strcpy();
            n_entries = 0;
            while(1) {
                _v6276 = f_gisman;
                _v6280 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                n_entries = n_entries + 1;
            }
            if(n_entries == 0) {
L51:
                if((_v16 ^  *gs:0x14]) == 0) {
                    return;
                }
                __stack_chk_fail();
                return;
            }
             *__esp = f_gisman;
            rewind();
            n_lines = 0;
            while(1) {
                _v6276 = f_in;
                _v6280 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                n_lines = n_lines + 1;
            }
            if(n_lines == 0) {
                goto L51;
            }
            n_lines_org = n_lines;
             *__esp = f_in;
            rewind();
            _t232 = n_entries + n_entries + n_lines + 6;
            _v6280 = 4;
             *__esp = _t232;
            calloc();
            line = _t232;
            i = 0;
            while(n_entries + n_entries + n_lines + 6 > i) {
                line[i] = 0;
                i = i + 1;
            }
            i = 0;
            while(1) {
                _v6276 = f_in;
                _v6280 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                 *__esp =  &str;
                strlen();
                _t245 =  &str + 1;
                 *__esp = _t245;
                malloc();
                line[i] = _t245;
                _v6280 =  &str;
                 *__esp = line[i];
                strcpy();
                i = i + 1;
            }
            check_ext_menu(line);
            i = 1;
            while(nc_fgets_nb( &str, 2048, f_gisman) != 0) {
                if(i != 1) {
                    line_no = new_item( &str,  &menu, line, line_no);
                    if(line_no >= 0) {
                        i = i + 1;
                        continue;
                    }
                    print_warning("error creating GIS Manager menu entries.\n");
                    break;
                }
                _v6280 = 93;
                 *__esp =  &str;
                strrchr();
                _v6280 = 91;
                 *__esp =  &str;
                strchr();
                len =  &str -  &str;
                _v6280 = 91;
                 *__esp =  &str;
                strchr();
                _v6276 = len;
                _v6280 =  &str + 1;
                 *__esp =  &menu;
                strncpy();
                 *((char*)(__ebp + len - 0xffffffffffffe7f5)) = 0;
                line_no = new_submenu(_v6208,  &str, line);
                if(line_no >= 0) {
                    i = i + 1;
                    continue;
                }
                print_warning("no GIS Manager menu entries created.\n");
                break;
            }
            i = 0;
            while(line[i] != 0) {
                _v6280 = line[i];
                 *__esp = f_out;
                fprintf();
                i = i + 1;
            }
             *__esp = f_out;
            fflush();
             *__esp = f_out;
            rewind();
            n_lines_new = 0;
            while(1) {
                _v6276 = f_out;
                _v6280 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                n_lines_new = n_lines_new + 1;
            }
            if(n_lines_new == 0 || n_lines_new < n_lines_org) {
                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                _v6276 = 1;
                _v6280 = 134567714;
                 *__esp =  &GISMAN_CMD;
                memcpy();
            }
             *__esp = f_in;
            fclose();
             *__esp = f_gisman;
            fclose();
             *__esp = f_out;
            fclose();
            i = 0;
            while(n_entries + n_entries + n_lines + 6 > i) {
                 *__esp = line[i];
                free();
                i = i + 1;
            }
             *__esp = line;
            free();
            goto L51;
        }
        __errno_location();
        if(file == 2) {
            goto L51;
        }
        _t303 = f_in;
         *__esp = _t303;
        fclose();
        __errno_location();
        _t304 = _t303->_flags;
         *__esp = _t304;
        strerror();
        _v6272 = _t304;
        _v6276 =  &file;
        print_error(-21, "checking for file '%s': %s\n");
        goto L6;
    }
    __errno_location();
    if(file == 2) {
        goto L51;
    }
    _t307 = f_gisman;
     *__esp = _t307;
    fclose();
    __errno_location();
    _t308 = _t307->_flags;
     *__esp = _t308;
    strerror();
    _v6272 = _t308;
    _v6276 =  &file;
    print_error(-21, "checking for file '%s': %s\n");
    goto L3;
}

void register_entries_gisman2(char* pkg_short_name, char* gisbase)
{// addr = 0x0804CD6C  --  defined in 'reg_entries.c' at line 415
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    FILE* f_gisman2;      // _cfa_ffffefec
    char* _v4128;                          // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    char* _v4156;                          // _cfa_ffffefc4
    char* _v4160;                          // _cfa_ffffefc0
    char[2047]* _v4164;                    // _cfa_ffffefbc
    char[2047]* _v4168;                    // _cfa_ffffefb8 (outparam)
    FILE* _t53;           // _t53
    char[2047]* _t54;                      // _t54

    _v4128 = pkg_short_name;
    _v4132 = gisbase;
    _v16 =  *gs:0x14];
    _v4164 = 19;
    _v4168 = "../entries-gisman2";
     *__esp =  &file;
    memcpy();
    _v4168 = 134566897;
     *__esp =  &file;
    fopen();
    f_gisman2 =  &file;
    if(f_gisman2 != 0) {
L3:
        if(VERBOSE == 0) {
            _v4156 = _v4128;
            _v4160 = _v4132;
            _v4164 = _v4132;
            _v4168 = "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ";
             *__esp =  &str;
            sprintf();
        } else {
            _v4156 = _v4128;
            _v4160 = _v4132;
            _v4164 = _v4132;
            _v4168 = "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ";
             *__esp =  &str;
            sprintf();
        }
        _v4168 =  &str;
         *__esp =  &GISMAN2_CMD;
        strcpy();
    } else {
        __errno_location();
        if(file != 2) {
            _t53 = f_gisman2;
             *__esp = _t53;
            fclose();
            __errno_location();
            _t54 = _t53->_flags;
             *__esp = _t54;
            strerror();
            _v4160 = _t54;
            _v4164 =  &file;
            print_error(-32, "checking for file '%s': %s\n");
            goto L3;
        }
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

int deregister_entries_gisman(char* pkg_short_name, char* gisbase)
{// addr = 0x0804CEC7  --  defined in 'reg_entries.c' at line 461
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] tmp;                        // _cfa_ffffe7f0
    char** line;                           // _cfa_ffffe7ec
    int n_lines;                           // _cfa_ffffe7e8
    int i;                                 // _cfa_ffffe7e4
    int n_lines_org;                       // _cfa_ffffe7e0
    int n_lines_new;                       // _cfa_ffffe7dc
    FILE* f_in;           // _cfa_ffffe7d8
    FILE* f_out;          // _cfa_ffffe7d4
    int pos;                               // _cfa_ffffe7d0
    int start;                             // _cfa_ffffe7cc
    int end;                               // _cfa_ffffe7c8
    int start_sub;                         // _cfa_ffffe7c4
    int end_sub;                           // _cfa_ffffe7c0
    char* lq;                              // _cfa_ffffe7bc
    char* rq;                              // _cfa_ffffe7b8
    int num_removed;                       // _cfa_ffffe7b4
    char* _v6224;                          // _cfa_ffffe7b0
    char* _v6228;                          // _cfa_ffffe7ac
    char[2047]* _v6248;                    // _cfa_ffffe798
    char* _v6252;                          // _cfa_ffffe794
    char[2047]* _v6256;                    // _cfa_ffffe790
    char* _v6260;                          // _cfa_ffffe78c
    char[2047]* _v6264;                    // _cfa_ffffe788
    char[2047]* _v6268;                    // _cfa_ffffe784
    char* _v6272;                          // _cfa_ffffe780
    char[2047]* _v6276;                    // _cfa_ffffe77c (outparam)
    char* _v6280;                          // _cfa_ffffe778 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t255;                          // _t255
    char* _t266;                           // _t266
    char* _t279;                           // _t279
    char* _t280;                           // _t280
    int _t299;                             // _t299
    FILE* _t364;          // _t364
    char** _t365;                          // _t365

    _v6224 = pkg_short_name;
    _v6228 = gisbase;
    _v16 =  *gs:0x14];
    _v6276 = _v6228;
    _v6280 = "%s/etc/dm/menu.tcl";
     *__esp =  &file;
    sprintf();
    _v6280 = 134566897;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in != 0) {
L4:
        _v6276 = 32;
        _v6280 = "/tmp/grass.extensions.db.XXXXXX";
         *__esp =  &TMP_GISMAN;
        memcpy();
         *__esp =  &TMP_GISMAN;
        mkstemp();
        _v6280 = "w+";
         *__esp =  &TMP_GISMAN;
        fopen();
        f_out =  &TMP_GISMAN;
        if(f_out == 0) {
            __errno_location();
             *__esp =  &TMP_GISMAN;
            strerror();
            _v6272 = TMP_GISMAN;
            _v6276 =  &TMP_GISMAN;
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v6248 =  &TMP_NULL;
            _v6252 = _v6228;
            _v6256 =  &TMP_NULL;
            _v6260 = _v6228;
            _v6264 =  &TMP_GISMAN;
            _v6268 =  &TMP_NULL;
            _v6272 = _v6228;
            _v6276 = _v6228;
            _v6280 = "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;";
             *__esp =  &str;
            sprintf();
        } else {
            _v6260 = _v6228;
            _v6264 = _v6228;
            _v6268 =  &TMP_GISMAN;
            _v6272 = _v6228;
            _v6276 = _v6228;
            _v6280 = "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;";
             *__esp =  &str;
            sprintf();
        }
        _v6280 =  &str;
         *__esp =  &GISMAN_CMD;
        strcpy();
        n_lines = 0;
        while(1) {
            _v6276 = f_in;
            _v6280 = 2048;
             *__esp =  &str;
            fgets();
            if( &str == 0) {
                break;
            }
            n_lines = 1 + n_lines;
        }
        if(n_lines != 0) {
             *__esp = f_in;
            rewind();
            n_lines_org = n_lines;
            _t255 = 1 + n_lines;
            _v6280 = 4;
             *__esp = _t255;
            calloc();
            line = _t255;
            i = 0;
            while(1 + n_lines > i) {
                line[i] = 0;
                i = 1 + i;
            }
            i = 0;
            while(1) {
                _v6276 = f_in;
                _v6280 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                 *__esp =  &str;
                strlen();
                _t266 =  &str + 1;
                 *__esp = _t266;
                malloc();
                line[i] = _t266;
                _v6280 =  &str;
                 *__esp = line[i];
                strcpy();
                i = 1 + i;
            }
            _v6276 = _v6224;
            _v6280 = "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad";
             *__esp =  &str;
            sprintf();
            pos = find_pos( &str, line, 0);
            if(pos != -1) {
                _t279 = line[pos];
                _v6280 = 34;
                 *__esp = _t279;
                strchr();
                lq = _t279;
                lq =  &(lq[1]);
                _v6280 = 34;
                _t280 = lq;
                 *__esp = _t280;
                strchr();
                rq = _t280;
                _v6280 = lq;
                 *__esp =  &tmp;
                strcpy();
                 *((char*)(__ebp + rq - lq - 6156)) = 0;
                start = find_pos(""&Xtns" all options 1", line, 0);
                end = find_pos("" all options", line, 1 + start) - 1;
                if(end == -1) {
                    end = find_pos("}]", line, 0);
                }
                if(start != -1) {
                    _v6276 =  &tmp;
                    _v6280 = "{cascad "%s"";
                     *__esp =  &str;
                    sprintf();
                    start_sub = find_pos( &str, line, start);
                    if(start_sub == -1 || start_sub > end) {
                        _v6280 =  &tmp;
                        print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                        _t299 = -1;
                        goto L51;
                    } else {
                        end_sub = find_pos(" \t\t\t}}", line, start_sub);
                        if(end_sub == -1 || end_sub > end) {
                            _v6280 =  &tmp;
                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                            _t299 = -1;
                            goto L51;
                        } else {
                            num_removed = 0;
                            i = 0;
                            while(1 + end_sub - start_sub > i) {
                                delete_str(start_sub, line);
                                num_removed = 1 + num_removed;
                                i = 1 + i;
                            }
                            _v6276 = _v6224;
                            _v6280 = "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad";
                             *__esp =  &str;
                            sprintf();
                            pos = find_pos( &str, line, 0);
                            delete_str(pos, line);
                            num_removed = 1 + num_removed;
                            start = find_pos(""&Xtns" all options 1", line, 0);
                            end = find_pos("" all options", line, 1 + start) - 1;
                            if(end - start > 2) {
L39:
                                i = 0;
                                while(line[i] != 0) {
                                    _v6280 = line[i];
                                     *__esp = f_out;
                                    fprintf();
                                    i = 1 + i;
                                }
                                 *__esp = f_out;
                                fflush();
                                 *__esp = f_out;
                                rewind();
                                n_lines_new = 0;
                                while(1) {
                                    _v6276 = f_out;
                                    _v6280 = 2048;
                                     *__esp =  &str;
                                    fgets();
                                    if( &str == 0) {
                                        break;
                                    }
                                    n_lines_new = 1 + n_lines_new;
                                }
                                if(n_lines_new == 0) {
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    _v6276 = 1;
                                    _v6280 = 134567714;
                                     *__esp =  &GISMAN_CMD;
                                    memcpy();
                                }
                                 *__esp = f_in;
                                fclose();
                                 *__esp = f_out;
                                fclose();
                                i = 0;
                                while(1 + n_lines > i) {
                                     *__esp = line[i];
                                    free();
                                    i = 1 + i;
                                }
                                 *__esp = line;
                                free();
                                _t299 = num_removed;
                                goto L51;
                            }
                            i = 0;
                            while(1 + end - start > i) {
                                delete_str(start, line);
                                num_removed = 1 + num_removed;
                                i = 1 + i;
                            }
                            goto L39;
                        }
                    }
                } else {
                    print_warning("menu 'Xtns' does not exist.\n");
                    _t299 = -1;
L51:
                    if((_v16 ^  *gs:0x14]) == 0) {
                        return _t299;
                    }
                    __stack_chk_fail();
                    return _t299;
                }
            }
            print_warning("could not find uninstall information in 'menu.tcl'.\n");
            _t299 = -1;
            goto L51;
        }
        _t299 = -1;
        goto L51;
    }
    __errno_location();
    if(file != 2) {
        _t364 = f_in;
         *__esp = _t364;
        fclose();
        __errno_location();
        _t365 = _t364->_flags;
         *__esp = _t365;
        strerror();
        _v6272 = _t365;
        _v6276 =  &file;
        print_error(-22, "checking for file '%s': %s\n");
        goto L4;
    } else {
        _t299 = 0;
        goto L51;
    }
}

void deregister_entries_gisman2(char* pkg_short_name, char* gisbase)
{// addr = 0x0804D743  --  defined in 'reg_entries.c' at line 653
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    FILE* f_gisman2;      // _cfa_ffffefec
    char* _v4128;                          // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    char[2047]* _v4152;                    // _cfa_ffffefc8 (outparam)
    FILE* _t52;           // _t52
    char[2047]* _t53;                      // _t53

    _v4128 = pkg_short_name;
    _v4132 = gisbase;
    _v16 =  *gs:0x14];
    _v4144 = _v4128;
    _v4148 = _v4132;
    _v4152 = "%s/etc/gm/Xtns/%s.gem";
     *__esp =  &file;
    sprintf();
    _v4152 = 134566897;
     *__esp =  &file;
    fopen();
    f_gisman2 =  &file;
    if(f_gisman2 != 0) {
L3:
        if(VERBOSE == 0) {
            _v4144 = _v4128;
            _v4148 = _v4132;
            _v4152 = "rm -f %s/etc/gm/Xtns/%s.gem ; ";
             *__esp =  &str;
            sprintf();
        } else {
            _v4144 = _v4128;
            _v4148 = _v4132;
            _v4152 = "rm -vf %s/etc/gm/Xtns/%s.gem ; ";
             *__esp =  &str;
            sprintf();
        }
        _v4152 =  &str;
         *__esp =  &GISMAN_CMD;
        strcpy();
    } else {
        __errno_location();
        if(file != 2) {
            _t52 = f_gisman2;
             *__esp = _t52;
            fclose();
            __errno_location();
            _t53 = _t52->_flags;
             *__esp = _t53;
            strerror();
            _v4144 = _t53;
            _v4148 =  &file;
            print_error(-33, "checking for file '%s': %s\n");
            goto L3;
        }
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

int restore_entries_gisman(char* gisbase)
{// addr = 0x0804D896  --  defined in 'reg_entries.c' at line 692
    signed int _v16;                       // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    char[2047] menu;                       // _cfa_ffffeff0
    char[2047] file;                       // _cfa_ffffe7f0
    char[2047] dir;                        // _cfa_ffffdff0
    char[2047] pkg_short_name;             // _cfa_ffffd7f0
    int len;                               // _cfa_ffffd7ec
    char** line;                           // _cfa_ffffd7e8
    int n_entries;                         // _cfa_ffffd7e4
    int n_lines;                           // _cfa_ffffd7e0
    int i;                                 // _cfa_ffffd7dc
    int line_no;                           // _cfa_ffffd7d8
    FILE* f_gisman;       // _cfa_ffffd7d4
    FILE* f_in;           // _cfa_ffffd7d0
    FILE* f_out;          // _cfa_ffffd7cc
    DIR* dirp;             // _cfa_ffffd7c8
    struct dirent* ep;   // _cfa_ffffd7c4
    int num_restored;                      // _cfa_ffffd7c0
    int n_files;                           // _cfa_ffffd7bc
    char* _v10320;                         // _cfa_ffffd7b0
    char[2047]* _v10344;                   // _cfa_ffffd798
    char* _v10348;                         // _cfa_ffffd794
    char[2047]* _v10352;                   // _cfa_ffffd790
    char* _v10356;                         // _cfa_ffffd78c
    char[2047]* _v10360;                   // _cfa_ffffd788
    char[2047]* _v10364;                   // _cfa_ffffd784
    char** _v10368;                        // _cfa_ffffd780 (outparam)
    char[2047]* _v10372;                   // _cfa_ffffd77c (outparam)
    char* _v10376;                         // _cfa_ffffd778 (outparam)
    _unknown_ __ebx;                       // r1
    struct dirent* _t244;   // _t244
    char** _t250;                          // _t250
    char** _t253;                          // _t253
    char** _t265;                          // _t265
    char* _t281;                           // _t281
    struct dirent* _t292;   // _t292
    char** _t297;                          // _t297
    char** _t299;                          // _t299
    int _t347;                             // _t347
    FILE* _t352;          // _t352
    char** _t353;                          // _t353

    _v10320 = gisbase;
    _v16 =  *gs:0x14];
    _v10372 = _v10320;
    _v10376 = "%s/etc/dm/menu.tcl";
     *__esp =  &file;
    sprintf();
    _v10376 = 134566897;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in != 0) {
L4:
        _v10372 = 32;
        _v10376 = "/tmp/grass.extensions.db.XXXXXX";
         *__esp =  &TMP_GISMAN;
        memcpy();
         *__esp =  &TMP_GISMAN;
        mkstemp();
        _v10376 = "w+";
         *__esp =  &TMP_GISMAN;
        fopen();
        f_out =  &TMP_GISMAN;
        if(f_out == 0) {
            __errno_location();
             *__esp =  &TMP_GISMAN;
            strerror();
            _v10368 = TMP_GISMAN;
            _v10372 =  &TMP_GISMAN;
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v10344 =  &TMP_NULL;
            _v10348 = _v10320;
            _v10352 =  &TMP_NULL;
            _v10356 = _v10320;
            _v10360 =  &TMP_GISMAN;
            _v10364 =  &TMP_NULL;
            _v10368 = _v10320;
            _v10372 = _v10320;
            _v10376 = "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;";
             *__esp =  &str;
            sprintf();
        } else {
            _v10356 = _v10320;
            _v10360 = _v10320;
            _v10364 =  &TMP_GISMAN;
            _v10368 = _v10320;
            _v10372 = _v10320;
            _v10376 = "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;";
             *__esp =  &str;
            sprintf();
        }
        _v10376 =  &str;
         *__esp =  &GISMAN_CMD;
        strcpy();
        _v10372 = _v10320;
        _v10376 = "%s/etc/dm/gem-entries";
         *__esp =  &dir;
        sprintf();
         *__esp =  &dir;
        opendir();
        dirp =  &dir;
        if(dirp != 0) {
            n_entries = 0;
            n_files = 0;
            while(1) {
                _t244 = dirp;
                 *__esp = _t244;
                readdir();
                ep = _t244;
                if(ep == 0) {
                    break;
                }
                _v10368 =  &(ep->d_name);
                _v10372 =  &dir;
                _v10376 = "%s/%s";
                 *__esp =  &file;
                sprintf();
                _v10376 = 134566897;
                 *__esp =  &file;
                fopen();
                f_gisman =  &file;
                _t250 =  &(ep->d_name);
                _v10376 = 134568527;
                 *__esp = _t250;
                strcmp();
                if(_t250 == 0) {
L14:
                     *__esp = f_gisman;
                    fclose();
                } else {
                    _t253 =  &(ep->d_name);
                    _v10376 = 134568529;
                     *__esp = _t253;
                    strcmp();
                    if(_t253 != 0) {
                        if(f_gisman != 0) {
                            while(1) {
                                _v10372 = f_gisman;
                                _v10376 = 2048;
                                 *__esp =  &str;
                                fgets();
                                if( &str == 0) {
                                    break;
                                }
                                n_entries = n_entries + 1;
                            }
                            n_files = n_files + 1;
                             *__esp = f_gisman;
                            fclose();
                        } else {
                             *__esp = f_gisman;
                            fclose();
                        }
                    } else {
                        goto L14;
                    }
                }
            }
             *__esp = dirp;
            closedir();
            n_lines = 0;
            while(1) {
                _v10372 = f_in;
                _v10376 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                n_lines = n_lines + 1;
            }
            if(n_lines != 0) {
                 *__esp = f_in;
                rewind();
                _t265 = n_entries + n_entries + (n_files << 2) + n_files + n_lines + 1;
                _v10376 = 4;
                 *__esp = _t265;
                calloc();
                line = _t265;
                i = 0;
                while(n_entries + n_entries + (n_files << 2) + n_files + n_lines + 1 > i) {
                    line[i] = 0;
                    i = i + 1;
                }
                i = 0;
                while(1) {
                    _v10372 = f_in;
                    _v10376 = 2048;
                     *__esp =  &str;
                    fgets();
                    if( &str == 0) {
                        break;
                    }
                     *__esp =  &str;
                    strlen();
                    _t281 =  &str + 1;
                     *__esp = _t281;
                    malloc();
                    line[i] = _t281;
                    _v10376 =  &str;
                     *__esp = line[i];
                    strcpy();
                    i = i + 1;
                }
                line[i] = 0;
                check_ext_menu(line);
                 *__esp =  &dir;
                opendir();
                dirp =  &dir;
                num_restored = 0;
                while(1) {
L51:
                    _t292 = dirp;
                     *__esp = _t292;
                    readdir();
                    ep = _t292;
                    if(ep == 0) {
                        break;
                    }
                    _v10368 =  &(ep->d_name);
                    _v10372 =  &dir;
                    _v10376 = "%s/%s";
                     *__esp =  &file;
                    sprintf();
                    _t297 =  &(ep->d_name);
                    _v10376 = 134568527;
                     *__esp = _t297;
                    strcmp();
                    if(_t297 == 0) {
                    } else {
                        _t299 =  &(ep->d_name);
                        _v10376 = 134568529;
                         *__esp = _t299;
                        strcmp();
                        if(_t299 == 0) {
                        } else {
                            _v10376 = 134566897;
                             *__esp =  &file;
                            fopen();
                            f_gisman =  &file;
                            if(f_gisman != 0) {
                                i = 1;
                                while(nc_fgets_nb( &str, 2048, f_gisman) != 0) {
                                    if(i != 1) {
                                        line_no = new_item( &str,  &menu, line, line_no);
                                        if(line_no >= 0) {
                                            i = i + 1;
                                            num_restored = num_restored + 1;
                                            continue;
                                        }
                                    } else {
                                        _v10376 = 93;
                                         *__esp =  &str;
                                        strrchr();
                                        _v10376 = 91;
                                         *__esp =  &str;
                                        strchr();
                                        len =  &str -  &str;
                                        _v10376 = 91;
                                         *__esp =  &str;
                                        strchr();
                                        _v10372 = len;
                                        _v10376 =  &str + 1;
                                         *__esp =  &menu;
                                        strncpy();
                                         *((char*)(__ebp + len - 0xffffffffffffeff5)) = 0;
                                        line_no = new_submenu( &pkg_short_name,  &str, line);
                                        if(line_no >= 0) {
                                            i = i + 1;
                                            num_restored = num_restored + 1;
                                            continue;
                                        }
                                    }
L47:
                                     *__esp = f_gisman;
                                    fclose();
                                    goto L51;
                                }
                                goto L47;
                            }
                        }
                    }
                }
                 *__esp = dirp;
                closedir();
                i = 0;
                while(line[i] != 0) {
                    _v10376 = line[i];
                     *__esp = f_out;
                    fprintf();
                    i = i + 1;
                }
                 *__esp = f_out;
                fflush();
                 *__esp = f_in;
                fclose();
                 *__esp = f_out;
                fclose();
                i = 0;
                while(n_entries + n_entries + (n_files << 2) + n_files + n_lines + 1 > i) {
                     *__esp = line[i];
                    free();
                    i = i + 1;
                }
                 *__esp = line;
                free();
                _t347 = num_restored;
            } else {
                _t347 = 0;
            }
        } else {
            _t347 = 0;
        }
    } else {
        __errno_location();
        if(file != 2) {
            _t352 = f_in;
             *__esp = _t352;
            fclose();
            __errno_location();
            _t353 = _t352->_flags;
             *__esp = _t353;
            strerror();
            _v10368 = _t353;
            _v10372 =  &file;
            print_error(-21, "checking for file '%s': %s\n");
            goto L4;
        } else {
            _t347 = 0;
        }
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return _t347;
    }
    return _t347;
}

void new_ext_html(char* ext, char* gisbase, char** html, int major, int minor, int revision)
{// addr = 0x0804E100  --  defined in 'reg_html.c' at line 29
    signed int _v16;                       // _cfa_fffffff0
    char[2047] item;                       // _cfa_fffff7f0
    int pos1;                              // _cfa_fffff7ec
    int pos2;                              // _cfa_fffff7e8
    int pos3;                              // _cfa_fffff7e4
    int start;                             // _cfa_fffff7e0
    int end;                               // _cfa_fffff7dc
    int insert_here;                       // _cfa_fffff7d8
    char* first_char;                      // _cfa_fffff7d4
    char* last_char;                       // _cfa_fffff7d0
    int len;                               // _cfa_fffff7cc
    char* _v2112;                          // _cfa_fffff7c0
    char* _v2116;                          // _cfa_fffff7bc
    char** _v2120;                         // _cfa_fffff7b8
    int _v2132;                            // _cfa_fffff7ac
    int _v2136;                            // _cfa_fffff7a8
    int _v2140;                            // _cfa_fffff7a4
    char* _v2144;                          // _cfa_fffff7a0
    int _v2148;                            // _cfa_fffff79c (outparam)
    char[2047]* _v2152;                    // _cfa_fffff798 (outparam)
    char* _t186;                           // _t186
    char* _t190;                           // _t190
    char* _t198;                           // _t198

    _v2112 = ext;
    _v2116 = gisbase;
    _v2120 = html;
    _v16 =  *gs:0x14];
    pos1 = find_pos("<b>Drivers sections:</b>", _v2120, 0);
    if(pos1 >= 0) {
L3:
        pos2 = find_pos("<hr>", _v2120, pos1);
        if(find_pos("<h3>Installed extensions:</h3>", _v2120, pos1) == -1) {
            insert_str("<h3>Installed extensions:</h3>\n", pos2, _v2120);
            insert_str("<ul>\n", pos2 + 1, _v2120);
            insert_str("</ul>\n", pos2 + 2, _v2120);
            insert_str("<p>\n", pos2 + 3, _v2120);
        }
        start = find_pos("<h3>Installed extensions:</h3>", _v2120, pos1);
        end = find_pos("</ul>", _v2120, start);
        insert_here = start + 2;
        _v2148 = _v2112;
        _v2152 = "">%s";
         *__esp =  &item;
        sprintf();
        pos3 = find_pos( &item, _v2120, insert_here);
        if(pos3 == -1) {
            pos3 = find_pos("<li><a href=", _v2120, start);
            while(pos3 != -1 && pos3 < end) {
                _t186 = _v2120[pos3];
                _v2152 = 34;
                 *__esp = _t186;
                strrchr();
                first_char = _t186;
                _t190 = _v2120[pos3];
                _v2152 = 60;
                 *__esp = _t190;
                strrchr();
                last_char = _t190;
                len = last_char - first_char;
                _v2148 = len;
                _v2152 =  &(first_char[2]);
                 *__esp =  &item;
                strncpy();
                 *((char*)(__ebp + len - 0xfffffffffffff7f5)) = 0;
                _v2152 =  &item;
                _t198 = _v2112;
                 *__esp = _t198;
                strcmp();
                if(_t198 >= 0) {
                    start = start + 1;
                    pos3 = find_pos("<li><a href=", _v2120, start);
                    continue;
                }
                insert_here = pos3;
                break;
            }
            _v2132 = revision;
            _v2136 = minor;
            _v2140 = major;
            _v2144 = _v2112;
            _v2148 = _v2112;
            _v2152 = "<li><a href="../extensions/%s/index.html">%s (%i.%i.%i)</a>\n";
             *__esp =  &item;
            sprintf();
            insert_str( &item, insert_here, _v2120);
            goto L18;
        } else {
            _v2152 = _v2112;
            print_warning("list item '%s' exists in index.html.\n");
            if(FORCE != 0) {
                if(UPGRADE != 0) {
                    _v2132 = revision;
                    _v2136 = minor;
                    _v2140 = major;
                    _v2144 = _v2112;
                    _v2148 = _v2112;
                    _v2152 = "<li><a href="../extensions/%s/index.html">%s (%i.%i.%i)</a>\n";
                     *__esp =  &item;
                    sprintf();
                    _v2152 =  &item;
                     *__esp = _v2120[pos3];
                    strcpy();
                }
            }
L18:
            if((_v16 ^  *gs:0x14]) == 0) {
                return;
            }
            __stack_chk_fail();
            return;
        }
    }
    pos1 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", _v2120, 0);
    if(pos1 >= 0) {
        goto L3;
    } else {
        print_warning("Unknown format of index.html. Unable to register HTML man pages.\n");
        goto L18;
    }
}

void delete_ext_html(char* ext, char* gisbase, char** html)
{// addr = 0x0804E56F  --  defined in 'reg_html.c' at line 110
    signed int _v16;                       // _cfa_fffffff0
    char[2047] item;                       // _cfa_fffff7f0
    int pos1;                              // _cfa_fffff7ec
    int pos2;                              // _cfa_fffff7e8
    int pos3;                              // _cfa_fffff7e4
    int start;                             // _cfa_fffff7e0
    int end;                               // _cfa_fffff7dc
    int found;                             // _cfa_fffff7d8
    int i;                                 // _cfa_fffff7d4
    char* _v2096;                          // _cfa_fffff7d0
    char* _v2100;                          // _cfa_fffff7cc
    char** _v2104;                         // _cfa_fffff7c8
    char* _v2116;                          // _cfa_fffff7bc (outparam)
    char* _v2120;                          // _cfa_fffff7b8 (outparam)

    _v2096 = ext;
    _v2100 = gisbase;
    _v2104 = html;
    _v16 =  *gs:0x14];
    pos1 = find_pos("<b>Drivers sections:</b>", _v2104, 0);
    if(pos1 >= 0) {
L3:
        pos2 = find_pos("<hr>", _v2104, pos1);
        if(find_pos("<h3>Installed extensions:</h3>", _v2104, pos1) != -1) {
            start = find_pos("<h3>Installed extensions:</h3>", _v2104, pos1);
            end = find_pos("</ul>", _v2104, start);
            found = 0;
            _v2116 = _v2096;
            _v2120 = "">%s";
             *__esp =  &item;
            sprintf();
            pos3 = find_pos( &item, _v2104, start);
            if(pos3 != -1) {
                if(pos3 < end) {
                    delete_str(pos3, _v2104);
                }
                end = end - 1;
                pos3 = find_pos("<ul>", _v2104, start);
                if(pos3 == -1 || end <= pos3 || end - pos3 > 1) {
L15:
                    if((_v16 ^  *gs:0x14]) == 0) {
                        return;
                    }
                    __stack_chk_fail();
                    return;
                } else {
                    i = 0;
                    while(i <= 3) {
                        delete_str(pos3 - 1, _v2104);
                        i = i + 1;
                    }
                    goto L15;
                }
            }
            _v2120 = _v2096;
            print_warning("extension '%s' not listed in index.html.\n");
            goto L15;
        }
        print_warning("no extensions section found in index.html.\n");
        goto L15;
    }
    pos1 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", _v2104, 0);
    if(pos1 >= 0) {
        goto L3;
    } else {
        print_warning("Unknown format of index.html. Unable to de-register HTML man pages.\n");
        goto L15;
    }
}

void register_html(char* pkg_short_name, char* gisbase, int major, int minor, int revision)
{// addr = 0x0804E7F3  --  defined in 'reg_html.c' at line 169
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char** line;                           // _cfa_ffffefec
    int n_lines;                           // _cfa_ffffefe8
    int i;                                 // _cfa_ffffefe4
    FILE* f_in;           // _cfa_ffffefe0
    FILE* f_out;          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char* _v4148;                          // _cfa_ffffefcc
    char[2047]* _v4164;                    // _cfa_ffffefbc
    char* _v4168;                          // _cfa_ffffefb8 (outparam)
    char[2047]* _v4172;                    // _cfa_ffffefb4 (outparam)
    char* _v4176;                          // _cfa_ffffefb0 (outparam)
    char[2047]* _v4180;                    // _cfa_ffffefac (outparam)
    char* _v4184;                          // _cfa_ffffefa8 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t128;                          // _t128
    char* _t139;                           // _t139
    FILE* _t175;          // _t175
    char** _t176;                          // _t176

    _v4144 = pkg_short_name;
    _v4148 = gisbase;
    _v16 =  *gs:0x14];
    _v4180 = _v4148;
    _v4184 = "%s/docs/html/index.html";
     *__esp =  &file;
    sprintf();
    _v4184 = 134569107;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in != 0) {
L3:
        _v4180 = 32;
        _v4184 = "/tmp/grass.extensions.db.XXXXXX";
         *__esp =  &TMP_HTML;
        memcpy();
         *__esp =  &TMP_HTML;
        mkstemp();
        _v4184 = "w+";
         *__esp =  &TMP_HTML;
        fopen();
        f_out =  &TMP_HTML;
        if(f_out == 0) {
            __errno_location();
             *__esp =  &TMP_HTML;
            strerror();
            _v4176 = TMP_HTML;
            _v4180 =  &TMP_HTML;
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v4164 =  &TMP_NULL;
            _v4168 = _v4148;
            _v4172 =  &TMP_NULL;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            _v4184 = "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;";
             *__esp =  &str;
            sprintf();
        } else {
            _v4172 = _v4148;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            _v4184 = "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;";
             *__esp =  &str;
            sprintf();
        }
        _v4184 =  &str;
         *__esp =  &HTML_CMD;
        strcpy();
        n_lines = 0;
        while(1) {
            _v4180 = f_in;
            _v4184 = 2048;
             *__esp =  &str;
            fgets();
            if( &str == 0) {
                break;
            }
            n_lines = n_lines + 1;
        }
        if(n_lines == 0) {
        } else {
             *__esp = f_in;
            rewind();
            _t128 = n_lines + 10;
            _v4184 = 4;
             *__esp = _t128;
            calloc();
            line = _t128;
            i = 0;
            while(n_lines + 10 > i) {
                line[i] = 0;
                i = i + 1;
            }
            i = 0;
            while(1) {
                _v4180 = f_in;
                _v4184 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                 *__esp =  &str;
                strlen();
                _t139 =  &str + 1;
                 *__esp = _t139;
                malloc();
                line[i] = _t139;
                _v4184 =  &str;
                 *__esp = line[i];
                strcpy();
                i = i + 1;
            }
            new_ext_html(_v4144, _v4148, line, major, minor, revision);
            i = 0;
            while(line[i] != 0) {
                _v4184 = line[i];
                 *__esp = f_out;
                fprintf();
                i = i + 1;
            }
             *__esp = f_out;
            fflush();
             *__esp = f_in;
            fclose();
             *__esp = f_out;
            fclose();
            i = 0;
            while(n_lines + 10 > i) {
                 *__esp = line[i];
                free();
                i = i + 1;
            }
             *__esp = line;
            free();
        }
    } else {
        __errno_location();
        if(file != 2) {
            _t175 = f_in;
             *__esp = _t175;
            fclose();
            __errno_location();
            _t176 = _t175->_flags;
             *__esp = _t176;
            strerror();
            _v4176 = _t176;
            _v4180 =  &file;
            print_error(-24, "checking for file '%s': %s\n");
            goto L3;
        }
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void deregister_html(char* pkg_short_name, char* gisbase)
{// addr = 0x0804EC17  --  defined in 'reg_html.c' at line 271
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char** line;                           // _cfa_ffffefec
    int n_lines;                           // _cfa_ffffefe8
    int i;                                 // _cfa_ffffefe4
    FILE* f_in;           // _cfa_ffffefe0
    FILE* f_out;          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char* _v4148;                          // _cfa_ffffefcc
    char[2047]* _v4164;                    // _cfa_ffffefbc
    char* _v4168;                          // _cfa_ffffefb8
    char[2047]* _v4172;                    // _cfa_ffffefb4
    char* _v4176;                          // _cfa_ffffefb0
    char[2047]* _v4180;                    // _cfa_ffffefac (outparam)
    char* _v4184;                          // _cfa_ffffefa8 (outparam)
    _unknown_ __ebx;                       // r1
    char** _t122;                          // _t122
    char* _t133;                           // _t133
    FILE* _t166;          // _t166
    char** _t167;                          // _t167

    _v4144 = pkg_short_name;
    _v4148 = gisbase;
    _v16 =  *gs:0x14];
    _v4180 = _v4148;
    _v4184 = "%s/docs/html/index.html";
     *__esp =  &file;
    sprintf();
    _v4184 = 134569107;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in != 0) {
L3:
        _v4180 = 32;
        _v4184 = "/tmp/grass.extensions.db.XXXXXX";
         *__esp =  &TMP_HTML;
        memcpy();
         *__esp =  &TMP_HTML;
        mkstemp();
        _v4184 = "w+";
         *__esp =  &TMP_HTML;
        fopen();
        f_out =  &TMP_HTML;
        if(f_out == 0) {
            __errno_location();
             *__esp =  &TMP_HTML;
            strerror();
            _v4176 = TMP_HTML;
            _v4180 =  &TMP_HTML;
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v4164 =  &TMP_NULL;
            _v4168 = _v4148;
            _v4172 =  &TMP_NULL;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            _v4184 = "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;";
             *__esp =  &str;
            sprintf();
        } else {
            _v4172 = _v4148;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            _v4184 = "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;";
             *__esp =  &str;
            sprintf();
        }
        _v4184 =  &str;
         *__esp =  &HTML_CMD;
        strcpy();
        n_lines = 0;
        while(1) {
            _v4180 = f_in;
            _v4184 = 2048;
             *__esp =  &str;
            fgets();
            if( &str == 0) {
                break;
            }
            n_lines = n_lines + 1;
        }
        if(n_lines == 0) {
        } else {
             *__esp = f_in;
            rewind();
            _t122 = n_lines + 1;
            _v4184 = 4;
             *__esp = _t122;
            calloc();
            line = _t122;
            i = 0;
            while(n_lines + 1 > i) {
                line[i] = 0;
                i = i + 1;
            }
            i = 0;
            while(1) {
                _v4180 = f_in;
                _v4184 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                 *__esp =  &str;
                strlen();
                _t133 =  &str + 1;
                 *__esp = _t133;
                malloc();
                line[i] = _t133;
                _v4184 =  &str;
                 *__esp = line[i];
                strcpy();
                i = i + 1;
            }
            delete_ext_html(_v4144, _v4148, line);
            i = 0;
            while(line[i] != 0) {
                _v4184 = line[i];
                 *__esp = f_out;
                fprintf();
                i = i + 1;
            }
             *__esp = f_out;
            fflush();
             *__esp = f_in;
            fclose();
             *__esp = f_out;
            fclose();
            i = 0;
            while(n_lines + 1 > i) {
                 *__esp = line[i];
                free();
                i = i + 1;
            }
             *__esp = line;
            free();
        }
    } else {
        __errno_location();
        if(file != 2) {
            _t166 = f_in;
             *__esp = _t166;
            fclose();
            __errno_location();
            _t167 = _t166->_flags;
             *__esp = _t167;
            strerror();
            _v4176 = _t167;
            _v4180 =  &file;
            print_error(-24, "checking for file '%s': %s\n");
            goto L3;
        }
    }
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

int restore_html(char* gisbase)
{// addr = 0x0804F026  --  defined in 'reg_html.c' at line 374
    signed int _v16;                       // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    char[2047] idx;                        // _cfa_ffffeff0
    char[2047] ext_idx;                    // _cfa_ffffe7f0
    char[2047] dir;                        // _cfa_ffffdff0
    char[2047] subdir;                     // _cfa_ffffd7f0
    char** line;                           // _cfa_ffffd7ec
    int n_entries;                         // _cfa_ffffd7e8
    int n_lines;                           // _cfa_ffffd7e4
    int i;                                 // _cfa_ffffd7e0
    FILE* f_in;           // _cfa_ffffd7dc
    FILE* f_out;          // _cfa_ffffd7d8
    FILE* f_ext;          // _cfa_ffffd7d4
    DIR* dirp;             // _cfa_ffffd7d0
    DIR* subdirp;          // _cfa_ffffd7cc
    struct dirent* ep;   // _cfa_ffffd7c8
    int num_restored;                      // _cfa_ffffd7c4
    int n_subdirs;                         // _cfa_ffffd7c0
    int major;                             // _cfa_ffffd7bc
    int minor;                             // _cfa_ffffd7b8
    int revision;                          // _cfa_ffffd7b4
    char* _v10320;                         // _cfa_ffffd7b0
    char[2047]* _v10340;                   // _cfa_ffffd79c
    char* _v10344;                         // _cfa_ffffd798 (outparam)
    int* _v10348;                          // _cfa_ffffd794 (outparam)
    int* _v10352;                          // _cfa_ffffd790 (outparam)
    char[2047]* _v10356;                   // _cfa_ffffd78c (outparam)
    char* _v10360;                         // _cfa_ffffd788 (outparam)
    _unknown_ __ebx;                       // r1
    struct dirent* _t218;   // _t218
    char** _t223;                          // _t223
    char** _t225;                          // _t225
    char** _t234;                          // _t234
    char* _t246;                           // _t246
    struct dirent* _t255;   // _t255
    char** _t260;                          // _t260
    char** _t262;                          // _t262
    int _t300;                             // _t300
    FILE* _t305;          // _t305
    int* _t306;                            // _t306

    _v10320 = gisbase;
    _v16 =  *gs:0x14];
    _v10356 = _v10320;
    _v10360 = "%s/docs/html/index.html";
     *__esp =  &idx;
    sprintf();
    _v10360 = 134569107;
     *__esp =  &idx;
    fopen();
    f_in =  &idx;
    if(f_in != 0) {
L4:
        _v10356 = 32;
        _v10360 = "/tmp/grass.extensions.db.XXXXXX";
         *__esp =  &TMP_HTML;
        memcpy();
         *__esp =  &TMP_HTML;
        mkstemp();
        _v10360 = "w+";
         *__esp =  &TMP_HTML;
        fopen();
        f_out =  &TMP_HTML;
        if(f_out == 0) {
            __errno_location();
             *__esp =  &TMP_HTML;
            strerror();
            _v10352 = TMP_HTML;
            _v10356 =  &TMP_HTML;
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        if(VERBOSE == 0) {
            _v10340 =  &TMP_NULL;
            _v10344 = _v10320;
            _v10348 =  &TMP_NULL;
            _v10352 = _v10320;
            _v10356 =  &TMP_HTML;
            _v10360 = "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;";
             *__esp =  &str;
            sprintf();
        } else {
            _v10348 = _v10320;
            _v10352 = _v10320;
            _v10356 =  &TMP_HTML;
            _v10360 = "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;";
             *__esp =  &str;
            sprintf();
        }
        _v10360 =  &str;
         *__esp =  &HTML_CMD;
        strcpy();
        atexit(exit_db);
        _v10356 = _v10320;
        _v10360 = "%s/docs/extensions";
         *__esp =  &dir;
        sprintf();
         *__esp =  &dir;
        opendir();
        dirp =  &dir;
        if(dirp != 0) {
            n_entries = 0;
            n_subdirs = 0;
            while(1) {
                _t218 = dirp;
                 *__esp = _t218;
                readdir();
                ep = _t218;
                if(ep == 0) {
                    break;
                }
                _v10352 =  &(ep->d_name);
                _v10356 =  &dir;
                _v10360 = "%s/%s";
                 *__esp =  &subdir;
                sprintf();
                _t223 =  &(ep->d_name);
                _v10360 = 134569482;
                 *__esp = _t223;
                strcmp();
                if(_t223 != 0) {
                    _t225 =  &(ep->d_name);
                    _v10360 = 134569484;
                     *__esp = _t225;
                    strcmp();
                    if(_t225 != 0) {
                         *__esp =  &subdir;
                        opendir();
                        subdirp =  &subdir;
                        if(subdirp != 0) {
                            n_subdirs = n_subdirs + 1;
                             *__esp = subdirp;
                            closedir();
                        }
                    }
                }
            }
             *__esp = dirp;
            closedir();
            n_lines = 0;
            while(1) {
                _v10356 = f_in;
                _v10360 = 2048;
                 *__esp =  &str;
                fgets();
                if( &str == 0) {
                    break;
                }
                n_lines = n_lines + 1;
            }
            if(n_lines != 0) {
                 *__esp = f_in;
                rewind();
                _t234 = n_lines + n_subdirs + 10;
                _v10360 = 4;
                 *__esp = _t234;
                calloc();
                line = _t234;
                i = 0;
                while(n_lines + n_subdirs + 10 > i) {
                    line[i] = 0;
                    i = i + 1;
                }
                i = 0;
                while(1) {
                    _v10356 = f_in;
                    _v10360 = 2048;
                     *__esp =  &str;
                    fgets();
                    if( &str == 0) {
                        break;
                    }
                     *__esp =  &str;
                    strlen();
                    _t246 =  &str + 1;
                     *__esp = _t246;
                    malloc();
                    line[i] = _t246;
                    _v10360 =  &str;
                     *__esp = line[i];
                    strcpy();
                    i = i + 1;
                }
                line[i] = 0;
                 *__esp =  &dir;
                opendir();
                dirp =  &dir;
                num_restored = 0;
                while(1) {
                    _t255 = dirp;
                     *__esp = _t255;
                    readdir();
                    ep = _t255;
                    if(ep == 0) {
                        break;
                    }
                    _v10352 =  &(ep->d_name);
                    _v10356 =  &dir;
                    _v10360 = "%s/%s";
                     *__esp =  &subdir;
                    sprintf();
                    _t260 =  &(ep->d_name);
                    _v10360 = 134569482;
                     *__esp = _t260;
                    strcmp();
                    if(_t260 == 0) {
                        continue;
                    }
                    _t262 =  &(ep->d_name);
                    _v10360 = 134569484;
                     *__esp = _t262;
                    strcmp();
                    if(_t262 == 0) {
                        continue;
                    }
                     *__esp =  &subdir;
                    opendir();
                    subdirp =  &subdir;
                    if(subdirp == 0) {
                        continue;
                    }
                     *__esp = subdirp;
                    closedir();
                    _v10356 =  &subdir;
                    _v10360 = "%s/index.html";
                     *__esp =  &ext_idx;
                    sprintf();
                    _v10360 = 134569107;
                     *__esp =  &ext_idx;
                    fopen();
                    f_ext =  &ext_idx;
                    if(f_ext == 0) {
                        continue;
                    }
                    major = 0;
                    minor = 0;
                    revision = 0;
                    i = 0;
                    while(1) {
                        _v10356 = f_ext;
                        _v10360 = 2048;
                         *__esp =  &str;
                        fgets();
                        if( &str == 0) {
                            break;
                        }
                        _v10360 = "<title>";
                         *__esp =  &str;
                        strstr();
                        if( &str == 0) {
                            continue;
                        }
                        i = 1;
                        break;
                    }
                    if(i != 0) {
                        _v10360 = 40;
                         *__esp =  &str;
                        strchr();
                        _v10348 =  &revision;
                        _v10352 =  &minor;
                        _v10356 =  &major;
                        _v10360 = "%i.%i.%i";
                         *__esp =  &str + 1;
                        __isoc99_sscanf();
                        new_ext_html( &(ep->d_name), _v10320, line, major, minor, revision);
                        num_restored = num_restored + 1;
                         *__esp = f_ext;
                        fclose();
                    }
                }
                 *__esp = dirp;
                closedir();
                i = 0;
                while(line[i] != 0) {
                    _v10360 = line[i];
                     *__esp = f_out;
                    fprintf();
                    i = i + 1;
                }
                 *__esp = f_out;
                fflush();
                 *__esp = f_in;
                fclose();
                 *__esp = f_out;
                fclose();
                i = 0;
                while(n_lines + n_subdirs + 10 > i) {
                     *__esp = line[i];
                    free();
                    i = i + 1;
                }
                 *__esp = line;
                free();
                _t300 = num_restored;
                goto L55;
            }
            _t300 = 0;
            goto L55;
        } else {
            _t300 = 0;
L55:
            if((_v16 ^  *gs:0x14]) == 0) {
                return _t300;
            }
            __stack_chk_fail();
            return _t300;
        }
    }
    __errno_location();
    if(idx != 2) {
        _t305 = f_in;
         *__esp = _t305;
        fclose();
        __errno_location();
        _t306 = _t305->_flags;
         *__esp = _t306;
        strerror();
        _v10352 = _t306;
        _v10356 =  &idx;
        print_error(-24, "checking for file '%s': %s\n");
        goto L4;
    } else {
        _t300 = 0;
        goto L55;
    }
}

void check_extension(char* package, char* name, int* major, int* minor, int* revision)
{// addr = 0x0804F7E8  --  defined in 'actions.c' at line 29
    signed int _v16;                       // _cfa_fffffff0
    char _v2060;                           // _cfa_fffff7f4
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    FILE* f;              // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    int* _v2088;                           // _cfa_fffff7d8
    int* _v2092;                           // _cfa_fffff7d4
    int* _v2096;                           // _cfa_fffff7d0
    int* _v2124;                           // _cfa_fffff7b4
    intOrPtr _v2128;                       // _cfa_fffff7b0
    char[2047]* _v2132;                    // _cfa_fffff7ac (outparam)
    char* _v2136;                          // _cfa_fffff7a8 (outparam)
    _unknown_ __edi;                       // r4
    FILE* _t86;           // _t86
    intOrPtr _t98;                         // _t98

    _v2080 = package;
    _v2084 = name;
    _v2088 = major;
    _v2092 = minor;
    _v2096 = revision;
    _v16 =  *gs:0x14];
    tmp = 0;
    _push(511 << 2);
    _push(0);
    _push( &_v2060);
    memset();
    __esp =  &(__esp[3]);
    _v2128 = __imp__stdout;
    _v2132 = 22;
    _v2136 = 1;
     *__esp = "Checking extension ...";
    fwrite();
    _v2136 = _v2080;
     *__esp =  &tmp;
    strcpy();
     *__esp =  &tmp;
    chdir();
    error =  &tmp;
    if(error < 0) {
        __errno_location();
        _t98 = tmp;
         *__esp = _t98;
        strerror();
        _v2128 = _t98;
        _v2132 = _v2080;
        print_error(-2, "extension '%s' not accessible: %s\n");
    }
    _v2136 = 134569579;
     *__esp = 134569581;
    fopen();
    f = 134569581;
    if(f != 0) {
        _v2132 =  &tmp;
        _v2136 = "%[<GRASS extension package>] ";
         *__esp = f;
        __isoc99_fscanf();
        _v2136 =  &tmp;
         *__esp = "<GRASS extension package>";
        strcmp();
        if( &tmp != 0) {
             *__esp = f;
            fclose();
            print_error(-6, "unknown file identifier.\n");
        }
    } else {
        print_error(-6, "'id' file not readable.\n");
    }
     *__esp = f;
    fclose();
    get_package_name(134569691, _v2084);
    _t86 = "version";
    _v2136 = 134569579;
     *__esp = _t86;
    fopen();
    f = _t86;
    if(f != 0) {
        nc_fgets_nb( &tmp, 2048, f);
         *_v2092 = 0;
         *_v2096 = 0;
        _v2124 = _v2096;
        _v2128 = _v2092;
        _v2132 = _v2088;
        _v2136 = "%i.%i.%i";
         *__esp =  &tmp;
        __isoc99_sscanf();
        error =  &tmp;
        if(error <= 0) {
             *__esp = f;
            fclose();
            print_error(-6, "invalid or missing version information.\n");
        }
    } else {
        print_error(-6, "'version' file not readable.\n");
    }
    print_done();
     *__esp = "..";
    chdir();
     *__esp = f;
    fclose();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void unpack_extension(char* package)
{// addr = 0x0804FAAB  --  defined in 'actions.c' at line 88
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    int fd;                                // _cfa_fffff7e8
    int ftype;                             // _cfa_fffff7e4
    char* _v2080;                          // _cfa_fffff7e0
    char[2047]* _v2108;                    // _cfa_fffff7c4
    char[2047]* _v2112;                    // _cfa_fffff7c0
    char[2047]* _v2116;                    // _cfa_fffff7bc
    char* _v2120;                          // _cfa_fffff7b8 (outparam)
    int _t105;                             // _t105
    char[2047]* _t122;                     // _t122
    char[2047]* _t125;                     // _t125
    char[2047]* _t129;                     // _t129
    char[2047]* _t132;                     // _t132
    char[2047]* _t136;                     // _t136
    char[2047]* _t139;                     // _t139
    char[2047]* _t143;                     // _t143
    char[2047]* _t146;                     // _t146
    char[2047]* _t149;                     // _t149

    _v2080 = package;
    _v16 =  *gs:0x14];
    _v2112 = __imp__stdout;
    _v2116 = 22;
    _v2120 = 1;
     *__esp = "Uncompressing files...";
    fwrite();
    _t105 = "/tmp/grass.extension.XXXXXX";
    _v2116 = 28;
    _v2120 = _t105;
     *__esp =  &TMPDIR;
    memcpy();
     *__esp =  &TMPDIR;
    mkstemp();
    _v2116 = 511;
    _v2120 = 64;
     *__esp =  &TMPDIR;
    open();
    fd = _t105;
    if(fd == -1) {
        __errno_location();
        _t149 =  *_t105;
         *__esp = _t149;
        strerror();
        _v2116 = _t149;
        print_error(-7, "could not create temp directory name: %s");
         *__esp = -7;
        exit();
    }
    if(VERBOSE != 0) {
        _v2116 =  &TMPDIR;
        _v2120 = "\nUncompressing to: %s.\n";
         *__esp = __imp__stdout;
        fprintf();
    }
     *__esp = fd;
    close();
     *__esp =  &TMPDIR;
    remove();
    mkdir_s( &TMPDIR, "0700");
    atexit(exit_tmp);
    _v2112 =  &TMPDIR;
    _v2116 = _v2080;
    _v2120 = "cp %s %s";
     *__esp =  &tmp;
    sprintf();
     *__esp =  &tmp;
    system();
    error =  &tmp;
    if(error < 0) {
        print_error(-7, "could not copy extension files to temp dir.\n");
         *__esp = -7;
        exit();
    }
    ftype = check_filetype(_v2080);
    if(ftype == 0) {
        print_warning("file name not '.tar.gz', '.tgz', '.tar.bz2', '.tbz' or '.zip'. Assuming '.tgz'.\n");
        ftype = 1;
    }
    if(ftype == 1) {
        if(VERBOSE == 0) {
            _t143 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t143;
            _v2116 =  &TMPDIR;
            _v2120 = "tar -xzf %s/%s -C %s";
             *__esp =  &tmp;
            sprintf();
        } else {
            _t146 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t146;
            _v2116 =  &TMPDIR;
            _v2120 = "tar -xzvf %s/%s -C %s";
             *__esp =  &tmp;
            sprintf();
        }
    }
    if(ftype == 2) {
        if(VERBOSE == 0) {
            _t136 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t136;
            _v2116 =  &TMPDIR;
            _v2120 = "tar -xjvf %s/%s -C %s";
             *__esp =  &tmp;
            sprintf();
        } else {
            _t139 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t139;
            _v2116 =  &TMPDIR;
            _v2120 = "tar -xjvf %s/%s -C %s";
             *__esp =  &tmp;
            sprintf();
        }
    }
    if(ftype == 3) {
        if(VERBOSE == 0) {
            _t129 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t129;
            _v2116 =  &TMPDIR;
            _v2120 = "unzip -qq %s/%s -d %s";
             *__esp =  &tmp;
            sprintf();
        } else {
            _t132 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t132;
            _v2116 =  &TMPDIR;
            _v2120 = "unzip %s/%s -d %s";
             *__esp =  &tmp;
            sprintf();
        }
    }
    if(ftype == 4) {
        if(VERBOSE == 0) {
            _t122 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t122;
            _v2116 =  &TMPDIR;
            _v2120 = "tar -xf %s/%s -C %s";
             *__esp =  &tmp;
            sprintf();
        } else {
            _t125 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t125;
            _v2116 =  &TMPDIR;
            _v2120 = "tar -xvf %s/%s -C %s";
             *__esp =  &tmp;
            sprintf();
        }
    }
     *__esp =  &tmp;
    system();
    error =  &tmp;
    if(error < 0) {
        if(ftype == 1) {
            _v2116 = _v2080;
            print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
        }
        if(ftype == 2) {
            _v2116 = _v2080;
            print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
        }
        if(ftype == 3) {
            _v2116 = _v2080;
            print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
        }
         *__esp = -7;
        exit();
    }
    print_done();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void query_extension(char* package, char* name, int major, int minor, int revision, char* short_name, char* invocation, char* org_name)
{// addr = 0x0804FF43  --  defined in 'actions.c' at line 201
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    intOrPtr _v2072;                       // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    char* _v2088;                          // _cfa_fffff7d8
    char* _v2092;                          // _cfa_fffff7d4
    char* _v2096;                          // _cfa_fffff7d0
    int _v2120;                            // _cfa_fffff7b8
    int _v2124;                            // _cfa_fffff7b4
    int _v2128;                            // _cfa_fffff7b0
    char* _v2132;                          // _cfa_fffff7ac
    char* _v2136;                          // _cfa_fffff7a8 (outparam)
    signed int _v2156;                     // _cfa_fffff794
    int* _v4208;                           // _cfa_ffffef90
    intOrPtr _v4220;                       // _cfa_ffffef84
    intOrPtr _v4224;                       // _cfa_ffffef80
    intOrPtr _v4228;                       // _cfa_ffffef7c
    int* _t87;                             // _t87
    int _t97;                              // _t97
    _unknown_ _t113;                       // _t113

    _v2080 = package;
    _v2084 = name;
    _v2088 = short_name;
    _v2092 = invocation;
    _v2096 = org_name;
    _v16 =  *gs:0x14];
    _v2136 = basename(_v2080);
     *__esp =  &tmp;
    strcpy();
     *__esp =  &tmp;
    chdir();
    error =  &tmp;
    if(error < 0) {
        __errno_location();
        _t97 = tmp;
         *__esp = _t97;
        strerror();
        _v2128 = _t97;
        _v2132 = _v2080;
        print_error(-2, "extension '%s' not accessible: %s\n");
    }
    _v2120 = revision;
    _v2124 = minor;
    _v2128 = major;
    _v2132 = _v2084;
    _v2136 = "\nExtension '%s', version %i.%i.%i\n\n";
     *__esp = __imp__stdout;
    fprintf();
    dump_ascii("description", "Description");
    dump_ascii("commands", "Commands provided");
    dump_ascii("libs", "Libraries provided");
    dump_ascii("headers", "Header files provided");
    dump_ascii("depends", "Dependencies");
    dump_ascii("bugs", "Bugs");
    _v2132 = _v2080;
    _v2136 = "../%s";
     *__esp =  &tmp;
    sprintf();
    list_binaries( &tmp);
    dump_ascii("authors", "Author(s)");
    _v2128 = _v2096;
    _v2132 = _v2092;
    _v2136 = "Type '%s -d %s' to see more detailed information.\n";
     *__esp = __imp__stdout;
    fprintf();
    _v2128 = _v2096;
    _v2132 = _v2092;
    _v2136 = "Type '%s -l %s' to see copyright information.\n";
     *__esp = __imp__stdout;
    fprintf();
     *__esp = "sh post";
    system();
     *__esp = 0;
    exit();
    _push(_t113);
    __esp = __esp - 2088;
    _v2156 =  *gs:0x14];
    _t87 = "config.msg";
    _v4228 = 134569579;
     *__esp = _t87;
    fopen();
    _v4208 = _t87;
    if(_v4208 != 0) {
        _v4220 = __imp__stdout;
        _v4224 = 27;
        _v4228 = 1;
         *__esp = "\nResult of configuration: \n";
        fwrite();
        while(1) {
            _v4224 = _v2072;
            _v4228 = 2048;
             *__esp =  &error;
            fgets();
            if( &error == 0) {
                break;
            }
            _v4228 = __imp__stdout;
             *__esp =  &error;
            fputs();
        }
        _v4228 = __imp__stdout;
         *__esp = 10;
        fputc();
    }
     *__esp = "config.msg";
    remove();
    if((_v20 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void print_cfg()
{// addr = 0x0805014E  --  defined in 'actions.c' at line 242
    signed int _v16;                       // _cfa_fffffff0
    char[2047] line;                       // _cfa_fffff7f0
    FILE* fp;             // _cfa_fffff7ec
    intOrPtr _v2080;                       // _cfa_fffff7e0
    FILE* _v2084;         // _cfa_fffff7dc
    intOrPtr _v2088;                       // _cfa_fffff7d8
    FILE* _t18;           // _t18

    _v16 =  *gs:0x14];
    _t18 = "config.msg";
    _v2088 = 134569579;
     *__esp = _t18;
    fopen();
    fp = _t18;
    if(fp != 0) {
        _v2080 = __imp__stdout;
        _v2084 = 27;
        _v2088 = 1;
         *__esp = "\nResult of configuration: \n";
        fwrite();
        while(1) {
            _v2084 = fp;
            _v2088 = 2048;
             *__esp =  &line;
            fgets();
            if( &line == 0) {
                break;
            }
            _v2088 = __imp__stdout;
             *__esp =  &line;
            fputs();
        }
        _v2088 = __imp__stdout;
         *__esp = 10;
        fputc();
    }
     *__esp = "config.msg";
    remove();
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void source_install(char* package, char* gisbase, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char* grass_version)
{// addr = 0x08050220  --  defined in 'actions.c' at line 263
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] dir;                        // _cfa_ffffeff0
    char[2047] install_cmd;                // _cfa_ffffe7f0
    char[2047] post_cmd;                   // _cfa_ffffdff0
    char[2047] sysstr;                     // _cfa_ffffd7f0
    int error;                             // _cfa_ffffd7ec
    FILE* f;              // _cfa_ffffd7e8
    char* verstr;                          // _cfa_ffffd7e4
    char* grass_major;                     // _cfa_ffffd7e0
    char* grass_minor;                     // _cfa_ffffd7dc
    char* grass_revision;                  // _cfa_ffffd7d8
    int major;                             // _cfa_ffffd7d4
    int minor;                             // _cfa_ffffd7d0
    int revision;                          // _cfa_ffffd7cc
    struct stat buf;      // _cfa_ffffd774
    char* _v10384;                         // _cfa_ffffd770
    char* _v10388;                         // _cfa_ffffd76c
    char* _v10392;                         // _cfa_ffffd768
    char* _v10396;                         // _cfa_ffffd764
    char[2047]* _v10412;                   // _cfa_ffffd754
    char[2047]* _v10416;                   // _cfa_ffffd750
    char[2047]* _v10420;                   // _cfa_ffffd74c
    char[2047]* _v10424;                   // _cfa_ffffd748 (outparam)
    char[2047]* _v10428;                   // _cfa_ffffd744 (outparam)
    char[2047]* _v10432;                   // _cfa_ffffd740 (outparam)
    char[2047]* _v10436;                   // _cfa_ffffd73c (outparam)
    char[2047]* _v10440;                   // _cfa_ffffd738 (outparam)
    int _t253;                             // _t253
    char* _t262;                           // _t262
    char* _t264;                           // _t264
    int _t267;                             // _t267
    int _t268;                             // _t268
    int _t269;                             // _t269
    FILE* _t298;          // _t298
    char[2047]* _t341;                     // _t341
    char[2047]* _t358;                     // _t358
    char[2047]* _t360;                     // _t360

    _v10384 = package;
    _v10388 = gisbase;
    _v10392 = pkg_short_name;
    _v10396 = grass_version;
    _v16 =  *gs:0x14];
    _t253 = __stat(_v10388,  &(buf.st_dev));
    error = _t253;
    if(error < 0) {
        __errno_location();
        _t360 =  *_t253;
         *__esp = _t360;
        strerror();
        _v10436 = _t360;
        print_error(-5, "installation directory invalid: %s\n");
    }
    _v10436 = _v10388;
    _v10440 = "GINSTALL_DST=%s";
     *__esp =  &GINSTALL_DST;
    sprintf();
     *__esp =  &GINSTALL_DST;
    putenv();
    _v10436 = _v10388;
    _v10440 = "%s/include";
     *__esp =  &tmp;
    sprintf();
    _v10436 =  &tmp;
    _v10440 = "GINSTALL_INC=%s";
     *__esp =  &GINSTALL_INC;
    sprintf();
     *__esp =  &GINSTALL_INC;
    putenv();
    _v10436 = _v10388;
    _v10440 = "%s/lib";
     *__esp =  &tmp;
    sprintf();
    _v10436 =  &tmp;
    _v10440 = "GINSTALL_LIB=%s";
     *__esp =  &GINSTALL_LIB;
    sprintf();
     *__esp =  &GINSTALL_LIB;
    putenv();
    _v10436 = _v10388;
    _v10440 = "GEM_GRASS_DIR=%s";
     *__esp =  &GEM_GRASS_DIR;
    sprintf();
     *__esp =  &GEM_GRASS_DIR;
    putenv();
    _t262 = _v10396;
     *__esp = _t262;
    strdup();
    verstr = _t262;
    _v10440 = 134569691;
    _t264 = verstr;
     *__esp = _t264;
    strtok();
    grass_major = _t264;
    _v10440 = 134569691;
     *__esp = 0;
    strtok();
    grass_minor = 134569691;
    _v10440 = 134569691;
     *__esp = 0;
    strtok();
    grass_revision = 134569691;
    _t267 = grass_major;
    _v10436 = 10;
    _v10440 = 0;
     *__esp = _t267;
    strtol();
    major = _t267;
    _t268 = grass_minor;
    _v10436 = 10;
    _v10440 = 0;
     *__esp = _t268;
    strtol();
    minor = _t268;
    _t269 = grass_revision;
    _v10436 = 10;
    _v10440 = 0;
     *__esp = _t269;
    strtol();
    revision = _t269;
     *__esp = verstr;
    free();
    atexit(exit_tmp);
    _v10436 = basename(_v10384);
    _v10440 = "%s/src";
     *__esp =  &dir;
    sprintf();
     *__esp =  &dir;
    chdir();
    error =  &dir;
    if(error < 0) {
        __errno_location();
        _t358 = dir;
         *__esp = _t358;
        strerror();
        _v10432 = _t358;
        _v10436 = _v10384;
        print_error(-2, "extension files in '%s' not accessible: %s\n");
    }
    if(SKIP_CFG == 0) {
        if(VERBOSE == 0) {
            _v10432 = __imp__stdout;
            _v10436 = 14;
            _v10440 = 1;
             *__esp = "Configuring...";
            fwrite();
            _v10428 =  &TMP_NULL;
            _v10432 =  &CONFIG_OPTS;
            _v10436 =  &CONFIG_CMD;
            _v10440 = "sh %s %s --quiet &> %s";
             *__esp =  &sysstr;
            sprintf();
             *__esp =  &sysstr;
            system();
            error =  &sysstr;
        } else {
            _v10432 = __imp__stdout;
            _v10436 = 26;
            _v10440 = 1;
             *__esp = "Running configure script:\n";
            fwrite();
            _v10432 =  &CONFIG_OPTS;
            _v10436 =  &CONFIG_CMD;
            _v10440 = "sh %s %s";
             *__esp =  &sysstr;
            sprintf();
             *__esp =  &sysstr;
            system();
            error =  &sysstr;
        }
        if(error == -1) {
            print_error(-27, "could not run configure script.\n");
        }
        if(error > 0) {
            print_error(-3, "system configuration failed.\n");
        }
        print_done();
        print_cfg();
    }
    _v10436 = _v10392;
    _v10440 = "GEM_EXT_NAME=%s";
     *__esp =  &GEM_EXT_NAME;
    sprintf();
     *__esp =  &GEM_EXT_NAME;
    putenv();
    _v10428 = pkg_revision;
    _v10432 = pkg_minor;
    _v10436 = pkg_major;
    _v10440 = "%i.%i.%i";
     *__esp =  &tmp;
    sprintf();
    _v10436 =  &tmp;
    _v10440 = "GEM_EXT_VERSION=%s";
     *__esp =  &GEM_EXT_VERSION;
    sprintf();
     *__esp =  &GEM_EXT_VERSION;
    putenv();
    dump_html("../description",  &TMP_DESCR);
    dump_html("../info",  &TMP_INFO);
    dump_html("../depends",  &TMP_DEPS);
    dump_html("../bugs",  &TMP_BUGS);
    dump_html("../authors",  &TMP_AUTHORS);
    _v10436 =  &TMP_DESCR;
    _v10440 = "GEM_EXT_DESCR=%s";
     *__esp =  &GEM_EXT_DESCR;
    sprintf();
     *__esp =  &GEM_EXT_DESCR;
    putenv();
    _v10436 =  &TMP_INFO;
    _v10440 = "GEM_EXT_INFO=%s";
     *__esp =  &GEM_EXT_INFO;
    sprintf();
     *__esp =  &GEM_EXT_INFO;
    putenv();
    _v10436 =  &TMP_DEPS;
    _v10440 = "GEM_EXT_DEPS=%s";
     *__esp =  &GEM_EXT_DEPS;
    sprintf();
     *__esp =  &GEM_EXT_DEPS;
    putenv();
    _v10436 =  &TMP_BUGS;
    _v10440 = "GEM_EXT_BUGS=%s";
     *__esp =  &GEM_EXT_BUGS;
    sprintf();
     *__esp =  &GEM_EXT_BUGS;
    putenv();
    _v10436 =  &TMP_AUTHORS;
    _v10440 = "GEM_EXT_AUTHORS=%s";
     *__esp =  &GEM_EXT_AUTHORS;
    sprintf();
     *__esp =  &GEM_EXT_AUTHORS;
    putenv();
    atexit(exit_tmp);
    check_dependencies(_v10384, _v10388, _v10396);
    if(VERBOSE == 0) {
        _v10432 = __imp__stdout;
        _v10436 = 12;
        _v10440 = 1;
         *__esp = "Compiling...";
        fwrite();
        _v10432 =  &TMP_NULL;
        _v10436 =  &MAKE_CMD;
        _v10440 = "%s -f Makefile &> %s";
         *__esp =  &sysstr;
        sprintf();
         *__esp =  &sysstr;
        system();
        error =  &sysstr;
    } else {
        _v10436 =  &MAKE_CMD;
        _v10440 = "Running '%s':\n";
         *__esp = __imp__stdout;
        fprintf();
        _v10436 =  &MAKE_CMD;
        _v10440 = "%s -f Makefile";
         *__esp =  &sysstr;
        sprintf();
         *__esp =  &sysstr;
        system();
        error =  &sysstr;
    }
    if(error == -1 && VERBOSE == 0) {
        _v10436 =  &MAKE_CMD;
        print_error(-9, "could not run '%s' do you have make tools installed?\n");
    }
    if(error > 0) {
        print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
    }
    print_done();
    _v10432 = __imp__stdout;
    _v10436 = 13;
    _v10440 = 1;
     *__esp = "Installing...";
    fwrite();
    _t298 = "../uninstall";
    _v10440 = 134569579;
     *__esp = _t298;
    fopen();
    f = _t298;
    if(f != 0) {
        if(VERBOSE == 0) {
            _v10428 =  &TMP_NULL;
            _v10432 = _v10392;
            _v10436 = _v10388;
            _v10440 = "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;";
             *__esp =  &tmp;
            sprintf();
            _v10440 =  &tmp;
             *__esp =  &UNINSTALL_CMD;
            strcpy();
        } else {
            _v10432 = _v10392;
            _v10436 = _v10388;
            _v10440 = "cp -vf ../uninstall %s/etc/uninstall.%s ;";
             *__esp =  &tmp;
            sprintf();
            _v10440 =  &tmp;
             *__esp =  &UNINSTALL_CMD;
            strcpy();
        }
         *__esp = f;
        fclose();
    } else {
        __errno_location();
        _t341 = _t298->_flags;
         *__esp = _t341;
        strerror();
        _v10440 = _t341;
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    register_extension(_v10388, "src", _v10392, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(_v10384, _v10388, _v10396);
    if(major == 6 && minor <= 0) {
        register_entries_gisman(_v10392, _v10388);
    }
    register_entries_gisman2(_v10392, _v10388);
    register_html(_v10392, _v10388, pkg_major, pkg_minor, pkg_revision);
    if(VERBOSE == 0) {
        _v10412 =  &TMP_NULL;
        _v10416 = _v10388;
        _v10420 =  &TMP_NULL;
        _v10424 = _v10388;
        _v10428 =  &TMPDB;
        _v10432 =  &TMP_NULL;
        _v10436 =  &MAKE_CMD;
        _v10440 = "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;";
         *__esp =  &install_cmd;
        sprintf();
    } else {
        _v10436 =  &MAKE_CMD;
        _v10440 = "Running '%s install':\n";
         *__esp = __imp__stdout;
        fprintf();
        _v10424 = _v10388;
        _v10428 = _v10388;
        _v10432 =  &TMPDB;
        _v10436 =  &MAKE_CMD;
        _v10440 = "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;";
         *__esp =  &install_cmd;
        sprintf();
    }
    if(VERBOSE == 0) {
        _v10436 =  &TMP_NULL;
        _v10440 = "sh ../post &> %s";
         *__esp =  &post_cmd;
        sprintf();
    } else {
        _v10436 = 11;
        _v10440 = "sh ../post";
         *__esp =  &post_cmd;
        memcpy();
    }
    _v10416 =  &post_cmd;
    _v10420 =  &HTML_CMD;
    _v10424 =  &GISMAN2_CMD;
    _v10428 =  &GISMAN_CMD;
    _v10432 =  &UNINSTALL_CMD;
    _v10436 =  &install_cmd;
    _v10440 = "%s %s %s %s %s %s";
     *__esp =  &tmp;
    sprintf();
    su(_v10388,  &tmp);
    print_done();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void bin_install(char* package, char* gisbase, char* bins, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char* grass_version)
{// addr = 0x08050C67  --  defined in 'actions.c' at line 475
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] dir;                        // _cfa_ffffeff0
    char[2047] install_cmd;                // _cfa_ffffe7f0
    char[2047] post_cmd;                   // _cfa_ffffdff0
    int error;                             // _cfa_ffffdfec
    FILE* f;              // _cfa_ffffdfe8
    char* verstr;                          // _cfa_ffffdfe4
    char* grass_major;                     // _cfa_ffffdfe0
    char* grass_minor;                     // _cfa_ffffdfdc
    char* grass_revision;                  // _cfa_ffffdfd8
    int major;                             // _cfa_ffffdfd4
    int minor;                             // _cfa_ffffdfd0
    int revision;                          // _cfa_ffffdfcc
    struct stat buf;      // _cfa_ffffdf74
    char* _v8336;                          // _cfa_ffffdf70
    char* _v8340;                          // _cfa_ffffdf6c
    char* _v8344;                          // _cfa_ffffdf68
    char* _v8348;                          // _cfa_ffffdf64
    char* _v8352;                          // _cfa_ffffdf60
    char[2047]* _v8380;                    // _cfa_ffffdf44
    char[2047]* _v8384;                    // _cfa_ffffdf40
    char[2047]* _v8388;                    // _cfa_ffffdf3c
    char[2047]* _v8392;                    // _cfa_ffffdf38 (outparam)
    char[2047]* _v8396;                    // _cfa_ffffdf34 (outparam)
    char[2047]* _v8400;                    // _cfa_ffffdf30 (outparam)
    char[2047]* _v8404;                    // _cfa_ffffdf2c (outparam)
    char[2047]* _v8408;                    // _cfa_ffffdf28 (outparam)
    int _t215;                             // _t215
    char* _t224;                           // _t224
    char* _t226;                           // _t226
    int _t229;                             // _t229
    int _t230;                             // _t230
    int _t231;                             // _t231
    char[2047]* _t235;                     // _t235
    FILE* _t253;          // _t253
    char[2047]* _t297;                     // _t297
    char[2047]* _t298;                     // _t298
    char[2047]* _t300;                     // _t300

    _v8336 = package;
    _v8340 = gisbase;
    _v8344 = bins;
    _v8348 = pkg_short_name;
    _v8352 = grass_version;
    _v16 =  *gs:0x14];
    _t215 = __stat(_v8340,  &(buf.st_dev));
    error = _t215;
    if(error < 0) {
        __errno_location();
        _t300 =  *_t215;
         *__esp = _t300;
        strerror();
        _v8404 = _t300;
        print_error(-5, "installation directory invalid: %s\n");
    }
    _v8404 = _v8340;
    _v8408 = "GINSTALL_DST=%s";
     *__esp =  &GINSTALL_DST;
    sprintf();
     *__esp =  &GINSTALL_DST;
    putenv();
    _v8404 = _v8340;
    _v8408 = "%s/include";
     *__esp =  &tmp;
    sprintf();
    _v8404 =  &tmp;
    _v8408 = "GINSTALL_INC=%s";
     *__esp =  &GINSTALL_INC;
    sprintf();
     *__esp =  &GINSTALL_INC;
    putenv();
    _v8404 = _v8340;
    _v8408 = "%s/lib";
     *__esp =  &tmp;
    sprintf();
    _v8404 =  &tmp;
    _v8408 = "GINSTALL_LIB=%s";
     *__esp =  &GINSTALL_LIB;
    sprintf();
     *__esp =  &GINSTALL_LIB;
    putenv();
    _v8404 = _v8340;
    _v8408 = "GEM_GRASS_DIR=%s";
     *__esp =  &GEM_GRASS_DIR;
    sprintf();
     *__esp =  &GEM_GRASS_DIR;
    putenv();
    _t224 = _v8352;
     *__esp = _t224;
    strdup();
    verstr = _t224;
    _v8408 = 134569691;
    _t226 = verstr;
     *__esp = _t226;
    strtok();
    grass_major = _t226;
    _v8408 = 134569691;
     *__esp = 0;
    strtok();
    grass_minor = 134569691;
    _v8408 = 134569691;
     *__esp = 0;
    strtok();
    grass_revision = 134569691;
    _t229 = grass_major;
    _v8404 = 10;
    _v8408 = 0;
     *__esp = _t229;
    strtol();
    major = _t229;
    _t230 = grass_minor;
    _v8404 = 10;
    _v8408 = 0;
     *__esp = _t230;
    strtol();
    minor = _t230;
    _t231 = grass_revision;
    _v8404 = 10;
    _v8408 = 0;
     *__esp = _t231;
    strtol();
    revision = _t231;
     *__esp = verstr;
    free();
    atexit(exit_tmp);
    _t235 = basename(_v8336);
    _v8400 = _v8344;
    _v8404 = _t235;
    _v8408 = "%s/%s";
     *__esp =  &dir;
    sprintf();
     *__esp =  &dir;
    chdir();
    error =  &dir;
    if(error < 0) {
        __errno_location();
        _t298 = dir;
         *__esp = _t298;
        strerror();
        _v8400 = _t298;
        _v8404 = _v8336;
        print_error(-2, "extension file binaries in '%s' not accessible: %s\n");
    }
    _v8404 = _v8348;
    _v8408 = "GEM_EXT_NAME=%s";
     *__esp =  &GEM_EXT_NAME;
    sprintf();
     *__esp =  &GEM_EXT_NAME;
    putenv();
    _v8396 = pkg_revision;
    _v8400 = pkg_minor;
    _v8404 = pkg_major;
    _v8408 = "%i.%i.%i";
     *__esp =  &tmp;
    sprintf();
    _v8404 =  &tmp;
    _v8408 = "GEM_EXT_VERSION=%s";
     *__esp =  &GEM_EXT_VERSION;
    sprintf();
     *__esp =  &GEM_EXT_VERSION;
    putenv();
    dump_html("../description",  &TMP_DESCR);
    dump_html("../info",  &TMP_INFO);
    dump_html("../depends",  &TMP_DEPS);
    dump_html("../bugs",  &TMP_BUGS);
    dump_html("../authors",  &TMP_AUTHORS);
    _v8404 =  &TMP_DESCR;
    _v8408 = "GEM_EXT_DESCR=%s";
     *__esp =  &GEM_EXT_DESCR;
    sprintf();
     *__esp =  &GEM_EXT_DESCR;
    putenv();
    _v8404 =  &TMP_INFO;
    _v8408 = "GEM_EXT_INFO=%s";
     *__esp =  &GEM_EXT_INFO;
    sprintf();
     *__esp =  &GEM_EXT_INFO;
    putenv();
    _v8404 =  &TMP_DEPS;
    _v8408 = "GEM_EXT_DEPS=%s";
     *__esp =  &GEM_EXT_DEPS;
    sprintf();
     *__esp =  &GEM_EXT_DEPS;
    putenv();
    _v8404 =  &TMP_BUGS;
    _v8408 = "GEM_EXT_BUGS=%s";
     *__esp =  &GEM_EXT_BUGS;
    sprintf();
     *__esp =  &GEM_EXT_BUGS;
    putenv();
    _v8404 =  &TMP_AUTHORS;
    _v8408 = "GEM_EXT_AUTHORS=%s";
     *__esp =  &GEM_EXT_AUTHORS;
    sprintf();
     *__esp =  &GEM_EXT_AUTHORS;
    putenv();
    atexit(exit_tmp);
    check_dependencies(_v8336, _v8340, _v8352);
    _v8400 = __imp__stdout;
    _v8404 = 13;
    _v8408 = 1;
     *__esp = "Installing...";
    fwrite();
    _t253 = "../uninstall";
    _v8408 = 134569579;
     *__esp = _t253;
    fopen();
    f = _t253;
    if(f != 0) {
        if(VERBOSE == 0) {
            _v8396 =  &TMP_NULL;
            _v8400 = _v8348;
            _v8404 = _v8340;
            _v8408 = "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;";
             *__esp =  &tmp;
            sprintf();
            _v8408 =  &tmp;
             *__esp =  &UNINSTALL_CMD;
            strcpy();
        } else {
            _v8400 = _v8348;
            _v8404 = _v8340;
            _v8408 = "cp -vf ../uninstall %s/etc/uninstall.%s ;";
             *__esp =  &tmp;
            sprintf();
            _v8408 =  &tmp;
             *__esp =  &UNINSTALL_CMD;
            strcpy();
        }
         *__esp = f;
        fclose();
    } else {
        __errno_location();
        _t297 = _t253->_flags;
         *__esp = _t297;
        strerror();
        _v8408 = _t297;
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    register_extension(_v8340, _v8344, _v8348, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(_v8336, _v8340, _v8352);
    if(major == 6 && minor <= 0) {
        register_entries_gisman(_v8348, _v8340);
    }
    register_entries_gisman2(_v8348, _v8340);
    register_html(_v8348, _v8340, pkg_major, pkg_minor, pkg_revision);
    if(VERBOSE == 0) {
        _v8380 =  &TMP_NULL;
        _v8384 = _v8340;
        _v8388 =  &TMP_NULL;
        _v8392 = _v8340;
        _v8396 =  &TMPDB;
        _v8400 =  &TMP_NULL;
        _v8404 =  &MAKE_CMD;
        _v8408 = "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;";
         *__esp =  &install_cmd;
        sprintf();
    } else {
        _v8404 =  &MAKE_CMD;
        _v8408 = "Running '%s install':\n";
         *__esp = __imp__stdout;
        fprintf();
        _v8392 = _v8340;
        _v8396 = _v8340;
        _v8400 =  &TMPDB;
        _v8404 =  &MAKE_CMD;
        _v8408 = "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;";
         *__esp =  &install_cmd;
        sprintf();
    }
    if(VERBOSE == 0) {
        _v8404 =  &TMP_NULL;
        _v8408 = "sh ../post &> %s";
         *__esp =  &post_cmd;
        sprintf();
    } else {
        _v8404 = 11;
        _v8408 = "sh ../post";
         *__esp =  &post_cmd;
        memcpy();
    }
    _v8384 =  &post_cmd;
    _v8388 =  &HTML_CMD;
    _v8392 =  &GISMAN2_CMD;
    _v8396 =  &GISMAN_CMD;
    _v8400 =  &UNINSTALL_CMD;
    _v8404 =  &install_cmd;
    _v8408 = "%s %s %s %s %s %s";
     *__esp =  &tmp;
    sprintf();
    su(_v8340,  &tmp);
    print_done();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void test_install(char* package, char* gisbase, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char* grass_version)
{// addr = 0x0805148A  --  defined in 'actions.c' at line 636
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] dir;                        // _cfa_ffffeff0
    char[2047] sysstr;                     // _cfa_ffffe7f0
    int error;                             // _cfa_ffffe7ec
    FILE* f;              // _cfa_ffffe7e8
    char* verstr;                          // _cfa_ffffe7e4
    char* grass_major;                     // _cfa_ffffe7e0
    char* grass_minor;                     // _cfa_ffffe7dc
    char* grass_revision;                  // _cfa_ffffe7d8
    int major;                             // _cfa_ffffe7d4
    int minor;                             // _cfa_ffffe7d0
    int revision;                          // _cfa_ffffe7cc
    struct stat buf;      // _cfa_ffffe774
    char* _v6288;                          // _cfa_ffffe770
    char* _v6292;                          // _cfa_ffffe76c
    char* _v6296;                          // _cfa_ffffe768
    char* _v6300;                          // _cfa_ffffe764
    _unknown_ _v6312;                      // _cfa_ffffe758 (outparam)
    int _v6316;                            // _cfa_ffffe754 (outparam)
    char[2047]* _v6320;                    // _cfa_ffffe750 (outparam)
    char[2047]* _v6324;                    // _cfa_ffffe74c (outparam)
    char* _v6328;                          // _cfa_ffffe748 (outparam)
    int _t198;                             // _t198
    char* _t207;                           // _t207
    char* _t209;                           // _t209
    int _t212;                             // _t212
    int _t213;                             // _t213
    int _t214;                             // _t214
    FILE* _t243;          // _t243
    char* _t265;                           // _t265
    intOrPtr _t282;                        // _t282
    char[2047]* _t284;                     // _t284

    _v6288 = package;
    _v6292 = gisbase;
    _v6296 = pkg_short_name;
    _v6300 = grass_version;
    _v16 =  *gs:0x14];
    _t198 = __stat(_v6292,  &(buf.st_dev));
    error = _t198;
    if(error < 0) {
        __errno_location();
        _t284 =  *_t198;
         *__esp = _t284;
        strerror();
        _v6324 = _t284;
        print_error(-5, "installation directory invalid: %s\n");
    }
    _v6324 = _v6292;
    _v6328 = "GINSTALL_DST=%s";
     *__esp =  &GINSTALL_DST;
    sprintf();
     *__esp =  &GINSTALL_DST;
    putenv();
    _v6324 = _v6292;
    _v6328 = "%s/include";
     *__esp =  &tmp;
    sprintf();
    _v6324 =  &tmp;
    _v6328 = "GINSTALL_INC=%s";
     *__esp =  &GINSTALL_INC;
    sprintf();
     *__esp =  &GINSTALL_INC;
    putenv();
    _v6324 = _v6292;
    _v6328 = "%s/lib";
     *__esp =  &tmp;
    sprintf();
    _v6324 =  &tmp;
    _v6328 = "GINSTALL_LIB=%s";
     *__esp =  &GINSTALL_LIB;
    sprintf();
     *__esp =  &GINSTALL_LIB;
    putenv();
    _v6324 = _v6292;
    _v6328 = "GEM_GRASS_DIR=%s";
     *__esp =  &GEM_GRASS_DIR;
    sprintf();
     *__esp =  &GEM_GRASS_DIR;
    putenv();
    _t207 = _v6300;
     *__esp = _t207;
    strdup();
    verstr = _t207;
    _v6328 = 134569691;
    _t209 = verstr;
     *__esp = _t209;
    strtok();
    grass_major = _t209;
    _v6328 = 134569691;
     *__esp = 0;
    strtok();
    grass_minor = 134569691;
    _v6328 = 134569691;
     *__esp = 0;
    strtok();
    grass_revision = 134569691;
    _t212 = grass_major;
    _v6324 = 10;
    _v6328 = 0;
     *__esp = _t212;
    strtol();
    major = _t212;
    _t213 = grass_minor;
    _v6324 = 10;
    _v6328 = 0;
     *__esp = _t213;
    strtol();
    minor = _t213;
    _t214 = grass_revision;
    _v6324 = 10;
    _v6328 = 0;
     *__esp = _t214;
    strtol();
    revision = _t214;
     *__esp = verstr;
    free();
    atexit(exit_tmp);
    _v6324 = basename(_v6288);
    _v6328 = "%s/src";
     *__esp =  &dir;
    sprintf();
     *__esp =  &dir;
    chdir();
    error =  &dir;
    if(error < 0) {
        __errno_location();
        _t282 = dir;
         *__esp = _t282;
        strerror();
        _v6320 = _t282;
        _v6324 = _v6288;
        print_error(-2, "extension files in '%s' not accessible: %s\n");
    }
    if(SKIP_CFG == 0) {
        if(VERBOSE == 0) {
            _v6320 = __imp__stdout;
            _v6324 = 14;
            _v6328 = 1;
             *__esp = "Configuring...";
            fwrite();
            _v6316 =  &TMP_NULL;
            _v6320 =  &CONFIG_OPTS;
            _v6324 =  &CONFIG_CMD;
            _v6328 = "sh %s %s --quiet &> %s";
             *__esp =  &sysstr;
            sprintf();
             *__esp =  &sysstr;
            system();
            error =  &sysstr;
        } else {
            _v6320 = __imp__stdout;
            _v6324 = 26;
            _v6328 = 1;
             *__esp = "Running configure script:\n";
            fwrite();
            _v6320 =  &CONFIG_OPTS;
            _v6324 =  &CONFIG_CMD;
            _v6328 = "sh %s %s";
             *__esp =  &sysstr;
            sprintf();
             *__esp =  &sysstr;
            system();
            error =  &sysstr;
        }
        if(error == -1) {
            print_error(-27, "could not run configure script.\n");
        }
        if(error > 0) {
            print_error(-3, "system configuration failed.\n");
        }
        print_done();
        print_cfg();
    }
    _v6324 = _v6296;
    _v6328 = "GEM_EXT_NAME=%s";
     *__esp =  &GEM_EXT_NAME;
    sprintf();
     *__esp =  &GEM_EXT_NAME;
    putenv();
    _v6316 = pkg_revision;
    _v6320 = pkg_minor;
    _v6324 = pkg_major;
    _v6328 = "%i.%i.%i";
     *__esp =  &tmp;
    sprintf();
    _v6324 =  &tmp;
    _v6328 = "GEM_EXT_VERSION=%s";
     *__esp =  &GEM_EXT_VERSION;
    sprintf();
     *__esp =  &GEM_EXT_VERSION;
    putenv();
    dump_plain("../description",  &TMP_DESCR);
    dump_plain("../info",  &TMP_INFO);
    dump_plain("../depends",  &TMP_DEPS);
    dump_plain("../bugs",  &TMP_BUGS);
    dump_plain("../authors",  &TMP_AUTHORS);
    _v6324 =  &TMP_DESCR;
    _v6328 = "GEM_EXT_DESCR=%s";
     *__esp =  &GEM_EXT_DESCR;
    sprintf();
     *__esp =  &GEM_EXT_DESCR;
    putenv();
    _v6324 =  &TMP_INFO;
    _v6328 = "GEM_EXT_INFO=%s";
     *__esp =  &GEM_EXT_INFO;
    sprintf();
     *__esp =  &GEM_EXT_INFO;
    putenv();
    _v6324 =  &TMP_DEPS;
    _v6328 = "GEM_EXT_DEPS=%s";
     *__esp =  &GEM_EXT_DEPS;
    sprintf();
     *__esp =  &GEM_EXT_DEPS;
    putenv();
    _v6324 =  &TMP_BUGS;
    _v6328 = "GEM_EXT_BUGS=%s";
     *__esp =  &GEM_EXT_BUGS;
    sprintf();
     *__esp =  &GEM_EXT_BUGS;
    putenv();
    _v6324 =  &TMP_AUTHORS;
    _v6328 = "GEM_EXT_AUTHORS=%s";
     *__esp =  &GEM_EXT_AUTHORS;
    sprintf();
     *__esp =  &GEM_EXT_AUTHORS;
    putenv();
    atexit(exit_tmp);
    check_dependencies(_v6288, _v6292, _v6300);
    if(VERBOSE == 0) {
        _v6320 = __imp__stdout;
        _v6324 = 12;
        _v6328 = 1;
         *__esp = "Compiling...";
        fwrite();
        _v6320 =  &TMP_NULL;
        _v6324 =  &MAKE_CMD;
        _v6328 = "%s -f Makefile &> %s";
         *__esp =  &sysstr;
        sprintf();
         *__esp =  &sysstr;
        system();
        error =  &sysstr;
    } else {
        _v6324 =  &MAKE_CMD;
        _v6328 = "Running '%s':\n";
         *__esp = __imp__stdout;
        fprintf();
        _v6324 =  &MAKE_CMD;
        _v6328 = "%s -f Makefile";
         *__esp =  &sysstr;
        sprintf();
         *__esp =  &sysstr;
        system();
        error =  &sysstr;
    }
    if(error == -1 && VERBOSE == 0) {
        _v6324 =  &MAKE_CMD;
        print_error(-9, "could not run '%s' do you have make tools installed?\n");
    }
    if(error > 0) {
        print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
    }
    print_done();
    _v6320 = __imp__stdout;
    _v6324 = 13;
    _v6328 = 1;
     *__esp = "Installing...";
    fwrite();
    _t243 = "../uninstall";
    _v6328 = 134569579;
     *__esp = _t243;
    fopen();
    f = _t243;
    if(f != 0) {
         *__esp = f;
        fclose();
    } else {
        __errno_location();
        _t265 = _t243->_flags;
         *__esp = _t265;
        strerror();
        _v6328 = _t265;
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    register_extension(_v6292, "src", _v6296, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(_v6288, _v6292, _v6300);
    if(major == 6 && minor <= 0) {
        register_entries_gisman(_v6296, _v6292);
    }
    register_entries_gisman2(_v6296, _v6292);
    register_html(_v6296, _v6292, pkg_major, pkg_minor, pkg_revision);
    _v6324 =  &MAKE_CMD;
    _v6328 = "(skipping '%s install')...";
     *__esp = __imp__stdout;
    fprintf();
    print_done();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void uninstall(char* package, char* pkg_short_name, char* gisbase, char* grass_version)
{// addr = 0x08051CF4  --  defined in 'actions.c' at line 812
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] script;                     // _cfa_ffffeff0
    int error;                             // _cfa_ffffefec
    int no_script;                         // _cfa_ffffefe8
    char* verstr;                          // _cfa_ffffefe4
    char* grass_major;                     // _cfa_ffffefe0
    char* grass_minor;                     // _cfa_ffffefdc
    char* grass_revision;                  // _cfa_ffffefd8
    int major;                             // _cfa_ffffefd4
    int minor;                             // _cfa_ffffefd0
    int revision;                          // _cfa_ffffefcc
    struct stat buf;      // _cfa_ffffef74
    char* _v4240;                          // _cfa_ffffef70
    char* _v4244;                          // _cfa_ffffef6c
    char* _v4248;                          // _cfa_ffffef68
    char* _v4252;                          // _cfa_ffffef64
    char[2047]* _v4268;                    // _cfa_ffffef54
    char* _v4272;                          // _cfa_ffffef50
    char[2047]* _v4276;                    // _cfa_ffffef4c
    char* _v4280;                          // _cfa_ffffef48
    char[2047]* _v4284;                    // _cfa_ffffef44
    char[2047]* _v4288;                    // _cfa_ffffef40
    char* _v4292;                          // _cfa_ffffef3c
    char* _v4296;                          // _cfa_ffffef38
    char[2047]* _v4300;                    // _cfa_ffffef34
    char* _v4304;                          // _cfa_ffffef30
    char* _v4308;                          // _cfa_ffffef2c
    char[2047]* _v4312;                    // _cfa_ffffef28
    char[2047]* _v4316;                    // _cfa_ffffef24
    char[2047]* _v4320;                    // _cfa_ffffef20
    char[2047]* _v4324;                    // _cfa_ffffef1c (outparam)
    char[2047]* _v4328;                    // _cfa_ffffef18 (outparam)
    char* _t142;                           // _t142
    char* _t144;                           // _t144
    int _t147;                             // _t147
    int _t148;                             // _t148
    int _t149;                             // _t149
    int _t162;                             // _t162
    char[2047]* _t176;                     // _t176

    _v4240 = package;
    _v4244 = pkg_short_name;
    _v4248 = gisbase;
    _v4252 = grass_version;
    _v16 =  *gs:0x14];
    _v4320 = __imp__stdout;
    _v4324 = 16;
    _v4328 = 1;
     *__esp = "Un-installing...";
    fwrite();
    _v4324 = _v4248;
    _v4328 = "UNINSTALL_BASE=%s";
     *__esp =  &UNINSTALL_BASE;
    sprintf();
     *__esp =  &UNINSTALL_BASE;
    putenv();
    _t142 = _v4252;
     *__esp = _t142;
    strdup();
    verstr = _t142;
    _v4328 = 134569691;
    _t144 = verstr;
     *__esp = _t144;
    strtok();
    grass_major = _t144;
    _v4328 = 134569691;
     *__esp = 0;
    strtok();
    grass_minor = 134569691;
    _v4328 = 134569691;
     *__esp = 0;
    strtok();
    grass_revision = 134569691;
    _t147 = grass_major;
    _v4324 = 10;
    _v4328 = 0;
     *__esp = _t147;
    strtol();
    major = _t147;
    _t148 = grass_minor;
    _v4324 = 10;
    _v4328 = 0;
     *__esp = _t148;
    strtol();
    minor = _t148;
    _t149 = grass_revision;
    _v4324 = 10;
    _v4328 = 0;
     *__esp = _t149;
    strtol();
    revision = _t149;
     *__esp = verstr;
    free();
    atexit(exit_tmp);
    deregister_extension(_v4240, _v4244, _v4248);
    if(major == 6 && minor <= 0) {
        if(error == 0) {
            print_warning("no entries found to remove from GIS Manager.\n");
            _v4324 = 1;
            _v4328 = 134572428;
             *__esp =  &GISMAN_CMD;
            memcpy();
        }
    }
    deregister_entries_gisman2(_v4244, _v4248);
    deregister_html(_v4244, _v4248);
    _v4320 = _v4244;
    _v4324 = _v4248;
    _v4328 = "%s/etc/uninstall.%s";
     *__esp =  &script;
    sprintf();
    no_script = 0;
    _t162 = __stat( &script,  &(buf.st_dev));
    error = _t162;
    if(error < 0) {
        print_warning("no uninstall script available for this extension.\n \t\t\tUnneeded files may have been left on your system.\n");
        no_script = 1;
    }
    if(no_script == 0) {
        if(VERBOSE == 0) {
            _v4268 =  &TMP_NULL;
            _v4272 = _v4248;
            _v4276 =  &TMP_NULL;
            _v4280 = _v4248;
            _v4284 =  &TMPDB;
            _v4288 =  &TMP_NULL;
            _v4292 = _v4244;
            _v4296 = _v4248;
            _v4300 =  &TMP_NULL;
            _v4304 = _v4244;
            _v4308 = _v4248;
            _v4312 =  &TMP_NULL;
            _v4316 =  &script;
            _v4320 =  &TMP_NULL;
            _v4324 =  &script;
            _v4328 = "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;";
             *__esp =  &tmp;
            sprintf();
            _v4328 =  &tmp;
             *__esp =  &UNINSTALL_CMD;
            strcpy();
        } else {
            _v4292 = _v4248;
            _v4296 = _v4248;
            _v4300 =  &TMPDB;
            _v4304 = _v4244;
            _v4308 = _v4248;
            _v4312 = _v4244;
            _v4316 = _v4248;
            _v4320 =  &script;
            _v4324 =  &script;
            _v4328 = "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;";
             *__esp =  &tmp;
            sprintf();
            _v4328 =  &tmp;
             *__esp =  &UNINSTALL_CMD;
            strcpy();
        }
    } else {
        __errno_location();
        _t176 =  *_t162;
         *__esp = _t176;
        strerror();
        _v4328 = _t176;
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    _v4316 =  &HTML_CMD;
    _v4320 =  &GISMAN_CMD;
    _v4324 =  &UNINSTALL_CMD;
    _v4328 = "%s %s %s";
     *__esp =  &tmp;
    sprintf();
    su(_v4248,  &tmp);
    print_done();
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

int source_clean(char* package)
{// addr = 0x080521A4  --  defined in 'actions.c' at line 907
    signed int _v16;                       // _cfa_fffffff0
    char[2047] dir;                        // _cfa_fffff7f0
    char[2047] sysstr;                     // _cfa_ffffeff0
    int error;                             // _cfa_ffffefec
    char* _v4128;                          // _cfa_ffffefe0
    char[2047]* _v4144;                    // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    char* _v4152;                          // _cfa_ffffefc8 (outparam)

    _v4128 = package;
    _v16 =  *gs:0x14];
    _v4148 = basename(_v4128);
    _v4152 = "%s/src";
     *__esp =  &dir;
    sprintf();
     *__esp =  &dir;
    chdir();
    error =  &dir;
    if(error < 0) {
        _v4148 = _v4128;
        print_error(-2, "extension '%s' not accessible: ");
    }
    if(VERBOSE == 0) {
        _v4144 = __imp__stdout;
        _v4148 = 14;
        _v4152 = 1;
         *__esp = "Cleaning up...";
        fwrite();
        _v4144 =  &TMP_NULL;
        _v4148 =  &MAKE_CMD;
        _v4152 = "%s -f Makefile -s clean &> %s";
         *__esp =  &sysstr;
        sprintf();
         *__esp =  &sysstr;
        system();
        error =  &sysstr;
    } else {
        _v4148 =  &MAKE_CMD;
        _v4152 = "Running '%s clean':\n";
         *__esp = __imp__stdout;
        fprintf();
        _v4148 =  &MAKE_CMD;
        _v4152 = "%s -f Makefile clean";
         *__esp =  &sysstr;
        sprintf();
         *__esp =  &sysstr;
        system();
        error =  &sysstr;
    }
    if(error != -1) {
        print_done();
    } else {
        _v4148 =  &MAKE_CMD;
        print_error(-9, "could not run '%s clean' do you have make tools installed?\n");
    }
     *__esp = "sh ../post";
    system();
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return 0;
    }
    return 0;
}

void restore(char* gisbase, char* grass_version)
{// addr = 0x08052334  --  defined in 'actions.c' at line 952
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int num_restored;                      // _cfa_fffff7ec
    char* verstr;                          // _cfa_fffff7e8
    char* grass_major;                     // _cfa_fffff7e4
    char* grass_minor;                     // _cfa_fffff7e0
    char* grass_revision;                  // _cfa_fffff7dc
    int major;                             // _cfa_fffff7d8
    int minor;                             // _cfa_fffff7d4
    int revision;                          // _cfa_fffff7d0
    char* _v2112;                          // _cfa_fffff7c0
    char* _v2116;                          // _cfa_fffff7bc
    char* _v2140;                          // _cfa_fffff7a4
    char* _v2144;                          // _cfa_fffff7a0
    char[2047]* _v2148;                    // _cfa_fffff79c
    char[2047]* _v2152;                    // _cfa_fffff798
    char* _v2156;                          // _cfa_fffff794
    intOrPtr _v2160;                       // _cfa_fffff790
    char[2047]* _v2164;                    // _cfa_fffff78c
    char* _v2168;                          // _cfa_fffff788 (outparam)
    char* _t79;                            // _t79
    char* _t81;                            // _t81
    int _t84;                              // _t84
    int _t85;                              // _t85
    int _t86;                              // _t86

    _v2112 = gisbase;
    _v2116 = grass_version;
    _v16 =  *gs:0x14];
    _t79 = _v2116;
     *__esp = _t79;
    strdup();
    verstr = _t79;
    _v2168 = 134569691;
    _t81 = verstr;
     *__esp = _t81;
    strtok();
    grass_major = _t81;
    _v2168 = 134569691;
     *__esp = 0;
    strtok();
    grass_minor = 134569691;
    _v2168 = 134569691;
     *__esp = 0;
    strtok();
    grass_revision = 134569691;
    _t84 = grass_major;
    _v2164 = 10;
    _v2168 = 0;
     *__esp = _t84;
    strtol();
    major = _t84;
    _t85 = grass_minor;
    _v2164 = 10;
    _v2168 = 0;
     *__esp = _t85;
    strtol();
    minor = _t85;
    _t86 = grass_revision;
    _v2164 = 10;
    _v2168 = 0;
     *__esp = _t86;
    strtol();
    revision = _t86;
     *__esp = verstr;
    free();
    _v2160 = __imp__stdout;
    _v2164 = 12;
    _v2168 = 1;
     *__esp = "Restoring...";
    fwrite();
    if(major == 6 && minor <= 0) {
        num_restored = restore_entries_gisman(_v2112);
        if(VERBOSE != 0) {
            _v2164 = num_restored;
            _v2168 = "\nRestored entries for GIS Manager: %i\n";
             *__esp = __imp__stdout;
            fprintf();
        }
    }
    num_restored = restore_html(_v2112);
    if(VERBOSE != 0) {
        _v2164 = num_restored;
        _v2168 = "\nRestored links in index.hml: %i\n";
         *__esp = __imp__stdout;
        fprintf();
    }
    if(num_restored > 0) {
        if(VERBOSE == 0) {
            _v2140 = _v2112;
            _v2144 = _v2112;
            _v2148 =  &TMP_HTML;
            _v2152 =  &TMP_NULL;
            _v2156 = _v2112;
            _v2160 = _v2112;
            _v2164 =  &TMP_GISMAN;
            _v2168 = "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html";
             *__esp =  &tmp;
            sprintf();
        } else {
            _v2144 = _v2112;
            _v2148 = _v2112;
            _v2152 =  &TMP_HTML;
            _v2156 = _v2112;
            _v2160 = _v2112;
            _v2164 =  &TMP_GISMAN;
            _v2168 = "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html";
             *__esp =  &tmp;
            sprintf();
        }
        su(_v2112,  &tmp);
    }
    if(num_restored != 0) {
        print_done();
    } else {
        print_error(-26, "could not find anything to restore.\n");
    }
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void list_extensions(char* gisbase)
{// addr = 0x080525FC  --  defined in 'actions.c' at line 1022
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    FILE* f_in;           // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    int _v2096;                            // _cfa_fffff7d0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8 (outparam)
    FILE* _t40;           // _t40
    int _t41;                              // _t41

    _v2080 = gisbase;
    _v16 =  *gs:0x14];
    _v2100 = _v2080;
    _v2104 = "\nExtensions in '%s' (name, version, type, depends):\n";
     *__esp = __imp__stdout;
    fprintf();
    _v2100 = _v2080;
    _v2104 = "%s/etc/extensions.db";
     *__esp =  &file;
    sprintf();
    _v2104 = 134569579;
     *__esp =  &file;
    fopen();
    f_in =  &file;
    if(f_in == 0) {
        __errno_location();
        if(file == 2) {
            _v2096 = __imp__stderr;
            _v2100 = 6;
            _v2104 = 1;
             *__esp = "NONE.\n";
            fwrite();
             *__esp = f_in;
            fclose();
             *__esp = 0;
            exit();
        }
        _t40 = f_in;
         *__esp = _t40;
        fclose();
        __errno_location();
        _t41 = _t40->_flags;
         *__esp = _t41;
        strerror();
        _v2096 = _t41;
        _v2100 =  &file;
        print_error(-29, "checking for file '%s': %s\n");
    }
     *__esp = f_in;
    fclose();
    dump_ascii( &file, 134572428);
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void run_post(char* package, int action, char* bins, char* gisbase)
{// addr = 0x08052748  --  defined in 'actions.c' at line 1057
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] tmp2;                       // _cfa_ffffeff0
    char* _v4128;                          // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    char* _v4136;                          // _cfa_ffffefd8
    char* _v4144;                          // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    char* _v4152;                          // _cfa_ffffefc8

    _v4128 = package;
    _v4132 = bins;
    _v4136 = gisbase;
    _v16 =  *gs:0x14];
    if(action - 3 <= 6) {
        goto __eax;
    }
     *__esp =  &GEM_ACTION;
    putenv();
    if(_v4136 == 0) {
        _v4148 = 23;
        _v4152 = "INSTALL_BASE=UNDEFINED";
         *__esp =  &INSTALL_BASE;
        memcpy();
    } else {
        _v4148 = _v4136;
        _v4152 = "INSTALL_BASE=%s";
         *__esp =  &INSTALL_BASE;
        sprintf();
    }
     *__esp =  &INSTALL_BASE;
    putenv();
    _v4152 = 2048;
     *__esp =  &tmp;
    getcwd();
    _v4144 = basename(_v4128);
    _v4148 =  &tmp;
    _v4152 = "%s/%s/src";
     *__esp =  &tmp2;
    sprintf();
    _v4148 =  &tmp2;
    _v4152 = "EXT_BASE=%s";
     *__esp =  &EXT_BASE;
    sprintf();
     *__esp =  &EXT_BASE;
    putenv();
    if(_v4132 != 0) {
        _v4148 = _v4132;
        _v4152 = "INSTALL_TYPE=%s";
         *__esp =  &INSTALL_TYPE;
        sprintf();
    } else {
        _v4148 = 17;
        _v4152 = "INSTALL_TYPE=src";
         *__esp =  &INSTALL_TYPE;
        memcpy();
    }
     *__esp =  &INSTALL_TYPE;
    putenv();
    _v4148 = FORCE;
    _v4152 = "%i";
     *__esp =  &tmp;
    sprintf();
    _v4148 =  &tmp;
    _v4152 = "GEM_FORCE=%s";
     *__esp =  &GEM_FORCE;
    sprintf();
     *__esp =  &GEM_FORCE;
    putenv();
    _v4148 = VERBOSE;
    _v4152 = "%i";
     *__esp =  &tmp;
    sprintf();
    _v4148 =  &tmp;
    _v4152 = "GEM_VERBOSE=%s";
     *__esp =  &GEM_VERBOSE;
    sprintf();
     *__esp =  &GEM_VERBOSE;
    putenv();
    _v4148 = 10;
    _v4152 = "GEM_GUI=0";
     *__esp =  &GEM_GUI;
    memcpy();
     *__esp =  &GEM_GUI;
    putenv();
    atexit(exit_tmp);
    if((_v16 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void show_help()
{// addr = 0x08052A50  --  defined in 'main.c' at line 148
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    char _v2080;                           // _cfa_fffff7e0
    FILE* _v2084;         // _cfa_fffff7dc
    intOrPtr _v2088;                       // _cfa_fffff7d8
    char[2047]* _v2092;                    // _cfa_fffff7d4
    char* _v2096;                          // _cfa_fffff7d0
    char* _v2108;                          // _cfa_fffff7c4
    char[2047]* _v2124;                    // _cfa_fffff7b4
    FILE* _v2128;         // _cfa_fffff7b0
    char* _v2132;                          // _cfa_fffff7ac
    signed int _v2152;                     // _cfa_fffff798
    char[2047]* _v4200;                    // _cfa_ffffef98
    char* _v4204;                          // _cfa_ffffef94
    char* _v4216;                          // _cfa_ffffef88
    char[2047]* _v4232;                    // _cfa_ffffef78
    intOrPtr _v4236;                       // _cfa_ffffef74
    char* _v4240;                          // _cfa_ffffef70
    intOrPtr _v4260;                       // _cfa_ffffef5c
    long long _v4264;                      // _cfa_ffffef58
    char* _v4268;                          // _cfa_ffffef54
    signed int _v4288;                     // _cfa_ffffef40
    char* _v6352;                          // _cfa_ffffe730
    char* _v6372;                          // _cfa_ffffe71c (outparam)
    char* _v6376;                          // _cfa_ffffe718 (outparam)
    char[2047]* _t281;                     // _t281
    char[2047]* _t283;                     // _t283
    _unknown_ _t328;                       // _t328
    char[2047]** _t329;                    // _t329
    char[2047]** _t330;                    // _t330
    char[2047]** _t331;                    // _t331

    _v16 = __imp__stdout;
    _v20 = 42;
    _v24 = 1;
     *__esp = "Usage: gem64 [OPTION] [ACTION] [FILE|DIR]\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 44;
    _v24 = 1;
     *__esp = "Install a GRASS extension from FILE or DIR.\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 39;
    _v24 = 1;
     *__esp = "Manage (installed) GRASS extension(s).\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 23;
    _v24 = 1;
     *__esp = "\nPossible ACTIONs are:\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 46;
    _v24 = 1;
     *__esp = "  -i, --install=EXT\tinstall a GRASS extension\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 53;
    _v24 = 1;
     *__esp = "  -u, --uninstall=EXT\tremove an extension from GRASS\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 69;
    _v24 = 1;
     *__esp = "  -q, --query=EXT\tdisplay information about extension/list installed\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 66;
    _v24 = 1;
     *__esp = "  -d, --details=EXT\tdisplay additional details about an extension\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 60;
    _v24 = 1;
     *__esp = "  -c, --clean=EXT\tclean extension's source code directories\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 68;
    _v24 = 1;
     *__esp = "  -t, --test=EXT\tconfigure and compile extension, but don't install\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 64;
    _v24 = 1;
     *__esp = "  -l, --license=EXT\tshow copyright information for an extension\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 61;
    _v24 = 1;
     *__esp = "  -r, --restore\t\trecreate HTML links and GIS Manager entries\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 41;
    _v24 = 1;
     *__esp = "  -h, --help\t\tdisplay this help and exit\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 54;
    _v24 = 1;
     *__esp = "  -V, --version\t\toutput version information and exit\n\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 23;
    _v24 = 1;
     *__esp = "\nPossible OPTIONs are:\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 50;
    _v24 = 1;
     *__esp = "  -g, --grass=PATH\tpath to GRASS installation dir\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 69;
    _v24 = 1;
     *__esp = "  -b, --binary=NAME\tno compilation: use binary files for system NAME\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 56;
    _v24 = 1;
     *__esp = "  -f, --force\t\tforce action, regardless of dependencies\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 53;
    _v24 = 1;
     *__esp = "  -v, --verbose\t\tdisplay detailed status information\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 42;
    _v24 = 1;
     *__esp = "  -s, --skip-config\tskip configure script\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 55;
    _v24 = 1;
     *__esp = "  -x, --config-opts=OPTS\tpass OPTS to configure script\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 62;
    _v24 = 1;
     *__esp = "  -o, --options=OPTS\toptions to pass to the C compiler/linker\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 77;
    _v24 = 1;
     *__esp = "  -C, --config-cmd=CMD\tDefine custom 'configure' command (default=configure)\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 65;
    _v24 = 1;
     *__esp = "  -m, --make-cmd=CMD\tDefine custom 'make' command (default=make)\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 71;
    _v24 = 1;
     *__esp = "\nWhen run from within a GRASS session, locations of libs, header files\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 73;
    _v24 = 1;
     *__esp = "and installation target dir will be assumed to match those of the active\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 15;
    _v24 = 1;
     *__esp = "GRASS version. ";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 74;
    _v24 = 1;
     *__esp = "Option -g can be used to override these or install extensions\nfrom outside";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 20;
    _v24 = 1;
     *__esp = "of a GRASS session.\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 73;
    _v24 = 1;
     *__esp = "Per default, extensions will be compiled from source and then installed.\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 76;
    _v24 = 1;
     *__esp = "If the exension package contains binaries for the user's platform, they can\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 42;
    _v24 = 1;
     *__esp = "be installed instead using the -b option. ";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 75;
    _v24 = 1;
     *__esp = "For installation from source code, a C compiler and make tools are needed.\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 10;
    _v24 = 1;
     *__esp = "\nExample:\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 63;
    _v24 = 1;
     *__esp = "\tgem64 -b macosx --grass=/usr/local/grass-6.4.0 -i myExtension\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 75;
    _v24 = 1;
     *__esp = "Installs the MacOS X binaries for 'myExtension' in /usr/local/grass-6.4.0.\n";
    fwrite();
     *__esp = 0;
    exit();
    _push(_t328);
    _t329 = __esp;
    __esp = __esp - 2104;
    _v2108 = _v24;
    _v44 =  *gs:0x14];
    _v2132 = basename(_v2108);
     *__esp =  &_v2092;
    strcpy();
     *__esp =  &_v2092;
    chdir();
    _v2096 =  &_v2092;
    if(_v2096 < 0) {
        __errno_location();
        _t283 = _v2092;
         *__esp = _t283;
        strerror();
        _v2124 = _t283;
        _v2128 = _v2084;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("info", "Detailed information");
     *__esp = "sh post";
    system();
     *__esp = 0;
    exit();
    _push(_t329);
    _t330 = __esp;
    __esp = __esp - 2104;
    _v4216 = _v2132;
    _v2152 =  *gs:0x14];
    _v4240 = basename(_v4216);
     *__esp =  &_v4200;
    strcpy();
     *__esp =  &_v4200;
    chdir();
    _v4204 =  &_v4200;
    if(_v4204 < 0) {
        __errno_location();
        _t281 = _v4200;
         *__esp = _t281;
        strerror();
        _v4232 = _t281;
        _v4236 = _v2088;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("license", "Detailed information");
     *__esp = "sh post";
    system();
     *__esp = 0;
    exit();
    _push(_t330);
    _t331 = __esp;
    __esp = __esp - 24;
    _v4264 =  *134577728;
    _v4268 = "gem64 (GRASS extensions manager) %.2f\n";
     *__esp = __imp__stdout;
    fprintf();
    _v4260 = __imp__stdout;
    _v4264 = 26;
    _v4268 = 1;
     *__esp = "Written by Benjamin Ducke\n";
    fwrite();
    _v4260 = __imp__stdout;
    _v4264 = 35;
    _v4268 = 1;
     *__esp = "\nCopyright (C) 2005 Benjamin Ducke\n";
    fwrite();
    _v4260 = __imp__stdout;
    _v4264 = 75;
    _v4268 = 1;
     *__esp = "This is free software; see the source for copying conditions.  There is NO\n";
    fwrite();
    _v4260 = __imp__stdout;
    _v4264 = 76;
    _v4268 = 1;
     *__esp = "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    fwrite();
     *__esp = 0;
    exit();
    _push(_t331);
    __esp = __esp - 2104;
    _v6352 = _v4268;
    _v4288 =  *gs:0x14];
    if((CONFIG_OPTS & 255) == 0) {
        _v6372 = _v2096;
        _v6376 = "%s/etc/config.system";
         *__esp =  &_v2080;
        sprintf();
        _v6376 = 134576350;
         *__esp =  &_v2080;
        fopen();
        _v2084 =  &_v2080;
        if(_v2084 != 0) {
            if(nc_fgets_nb( &_v2080, 2048, _v2084) != 0) {
                _v6376 =  &_v2080;
                 *__esp =  &CONFIG_OPTS;
                strcpy();
            }
        } else {
            _v6376 =  &_v2080;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    if((_v32 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void show_details(char* package)
{// addr = 0x08053002  --  defined in 'main.c' at line 213
    signed int _v16;                       // _cfa_fffffff0
    signed int _v28;                       // _cfa_ffffffe4
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    char _v2076;                           // _cfa_fffff7e4
    char* _v2080;                          // _cfa_fffff7e0
    intOrPtr _v2084;                       // _cfa_fffff7dc
    intOrPtr _v2092;                       // _cfa_fffff7d4
    char[2047]* _v2096;                    // _cfa_fffff7d0
    FILE* _v2100;         // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8
    signed int _v2124;                     // _cfa_fffff7b4
    char[2047]* _v4172;                    // _cfa_ffffefb4
    char* _v4176;                          // _cfa_ffffefb0
    char* _v4188;                          // _cfa_ffffefa4
    char[2047]* _v4204;                    // _cfa_ffffef94
    intOrPtr _v4208;                       // _cfa_ffffef90
    char* _v4212;                          // _cfa_ffffef8c
    intOrPtr _v4232;                       // _cfa_ffffef78
    long long _v4236;                      // _cfa_ffffef74
    char* _v4240;                          // _cfa_ffffef70
    signed int _v4260;                     // _cfa_ffffef5c
    char* _v6324;                          // _cfa_ffffe74c
    intOrPtr _v6344;                       // _cfa_ffffe738 (outparam)
    char* _v6348;                          // _cfa_ffffe734 (outparam)
    char[2047]* _t101;                     // _t101
    char[2047]* _t103;                     // _t103
    _unknown_ _t112;                       // _t112
    char[2047]** _t113;                    // _t113
    char[2047]** _t114;                    // _t114

    _v2080 = package;
    _v16 =  *gs:0x14];
    _v2104 = basename(_v2080);
     *__esp =  &tmp;
    strcpy();
     *__esp =  &tmp;
    chdir();
    error =  &tmp;
    if(error < 0) {
        __errno_location();
        _t103 = tmp;
         *__esp = _t103;
        strerror();
        _v2096 = _t103;
        _v2100 = _v2080;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("info", "Detailed information");
     *__esp = "sh post";
    system();
     *__esp = 0;
    exit();
    _push(_t112);
    _t113 = __esp;
    __esp = __esp - 2104;
    _v4188 = _v2104;
    _v2124 =  *gs:0x14];
    _v4212 = basename(_v4188);
     *__esp =  &_v4172;
    strcpy();
     *__esp =  &_v4172;
    chdir();
    _v4176 =  &_v4172;
    if(_v4176 < 0) {
        __errno_location();
        _t101 = _v4172;
         *__esp = _t101;
        strerror();
        _v4204 = _t101;
        _v4208 = _v2084;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("license", "Detailed information");
     *__esp = "sh post";
    system();
     *__esp = 0;
    exit();
    _push(_t113);
    _t114 = __esp;
    __esp = __esp - 24;
    _v4236 =  *134577728;
    _v4240 = "gem64 (GRASS extensions manager) %.2f\n";
     *__esp = __imp__stdout;
    fprintf();
    _v4232 = __imp__stdout;
    _v4236 = 26;
    _v4240 = 1;
     *__esp = "Written by Benjamin Ducke\n";
    fwrite();
    _v4232 = __imp__stdout;
    _v4236 = 35;
    _v4240 = 1;
     *__esp = "\nCopyright (C) 2005 Benjamin Ducke\n";
    fwrite();
    _v4232 = __imp__stdout;
    _v4236 = 75;
    _v4240 = 1;
     *__esp = "This is free software; see the source for copying conditions.  There is NO\n";
    fwrite();
    _v4232 = __imp__stdout;
    _v4236 = 76;
    _v4240 = 1;
     *__esp = "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    fwrite();
     *__esp = 0;
    exit();
    _push(_t114);
    __esp = __esp - 2104;
    _v6324 = _v4240;
    _v4260 =  *gs:0x14];
    if((CONFIG_OPTS & 255) == 0) {
        _v6344 = _v2092;
        _v6348 = "%s/etc/config.system";
         *__esp =  &_v2076;
        sprintf();
        _v6348 = 134576350;
         *__esp =  &_v2076;
        fopen();
        _v2080 =  &_v2076;
        if(_v2080 != 0) {
            if(nc_fgets_nb( &_v2076, 2048, _v2080) != 0) {
                _v6348 =  &_v2076;
                 *__esp =  &CONFIG_OPTS;
                strcpy();
            }
        } else {
            _v6348 =  &_v2076;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    if((_v28 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void show_license(char* package)
{// addr = 0x080530B9  --  defined in 'main.c' at line 236
    signed int _v16;                       // _cfa_fffffff0
    signed int _v24;                       // _cfa_ffffffe8
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    char _v2072;                           // _cfa_fffff7e8
    FILE* _v2076;         // _cfa_fffff7e4
    char* _v2080;                          // _cfa_fffff7e0
    intOrPtr _v2088;                       // _cfa_fffff7d8
    char[2047]* _v2096;                    // _cfa_fffff7d0
    char* _v2100;                          // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8
    intOrPtr _v2124;                       // _cfa_fffff7b4
    long long _v2128;                      // _cfa_fffff7b0
    char* _v2132;                          // _cfa_fffff7ac
    signed int _v2152;                     // _cfa_fffff798
    char* _v4216;                          // _cfa_ffffef88
    intOrPtr _v4236;                       // _cfa_ffffef74 (outparam)
    char* _v4240;                          // _cfa_ffffef70 (outparam)
    char[2047]* _t80;                      // _t80
    _unknown_ _t89;                        // _t89
    char[2047]** _t90;                     // _t90

    _v2080 = package;
    _v16 =  *gs:0x14];
    _v2104 = basename(_v2080);
     *__esp =  &tmp;
    strcpy();
     *__esp =  &tmp;
    chdir();
    error =  &tmp;
    if(error < 0) {
        __errno_location();
        _t80 = tmp;
         *__esp = _t80;
        strerror();
        _v2096 = _t80;
        _v2100 = _v2080;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("license", "Detailed information");
     *__esp = "sh post";
    system();
     *__esp = 0;
    exit();
    _push(_t89);
    _t90 = __esp;
    __esp = __esp - 24;
    _v2128 =  *134577728;
    _v2132 = "gem64 (GRASS extensions manager) %.2f\n";
     *__esp = __imp__stdout;
    fprintf();
    _v2124 = __imp__stdout;
    _v2128 = 26;
    _v2132 = 1;
     *__esp = "Written by Benjamin Ducke\n";
    fwrite();
    _v2124 = __imp__stdout;
    _v2128 = 35;
    _v2132 = 1;
     *__esp = "\nCopyright (C) 2005 Benjamin Ducke\n";
    fwrite();
    _v2124 = __imp__stdout;
    _v2128 = 75;
    _v2132 = 1;
     *__esp = "This is free software; see the source for copying conditions.  There is NO\n";
    fwrite();
    _v2124 = __imp__stdout;
    _v2128 = 76;
    _v2132 = 1;
     *__esp = "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    fwrite();
     *__esp = 0;
    exit();
    _push(_t90);
    __esp = __esp - 2104;
    _v4216 = _v2132;
    _v2152 =  *gs:0x14];
    if((CONFIG_OPTS & 255) == 0) {
        _v4236 = _v2088;
        _v4240 = "%s/etc/config.system";
         *__esp =  &_v2072;
        sprintf();
        _v4240 = 134576350;
         *__esp =  &_v2072;
        fopen();
        _v2076 =  &_v2072;
        if(_v2076 != 0) {
            if(nc_fgets_nb( &_v2072, 2048, _v2076) != 0) {
                _v4240 =  &_v2072;
                 *__esp =  &CONFIG_OPTS;
                strcpy();
            }
        } else {
            _v4240 =  &_v2072;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    if((_v24 ^  *gs:0x14]) != 0) {
        __stack_chk_fail();
        return;
    }
}

void show_version()
{// addr = 0x08053170  --  defined in 'main.c' at line 258
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    signed int _v44;                       // _cfa_ffffffd4
    char _v2068;                           // _cfa_fffff7ec
    FILE* _v2072;         // _cfa_fffff7e8
    intOrPtr _v2084;                       // _cfa_fffff7dc
    char* _v2108;                          // _cfa_fffff7c4
    intOrPtr _v2128;                       // _cfa_fffff7b0 (outparam)
    char* _v2132;                          // _cfa_fffff7ac (outparam)
    _unknown_ _t66;                        // _t66

    _v20 =  *134577728;
    _v24 = "gem64 (GRASS extensions manager) %.2f\n";
     *__esp = __imp__stdout;
    fprintf();
    _v16 = __imp__stdout;
    _v20 = 26;
    _v24 = 1;
     *__esp = "Written by Benjamin Ducke\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 35;
    _v24 = 1;
     *__esp = "\nCopyright (C) 2005 Benjamin Ducke\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 75;
    _v24 = 1;
     *__esp = "This is free software; see the source for copying conditions.  There is NO\n";
    fwrite();
    _v16 = __imp__stdout;
    _v20 = 76;
    _v24 = 1;
     *__esp = "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    fwrite();
     *__esp = 0;
    exit();
    _push(_t66);
    __esp = __esp - 2104;
    _v2108 = _v24;
    _v44 =  *gs:0x14];
    if((CONFIG_OPTS & 255) == 0) {
        _v2128 = _v2084;
        _v2132 = "%s/etc/config.system";
         *__esp =  &_v2068;
        sprintf();
        _v2132 = 134576350;
         *__esp =  &_v2068;
        fopen();
        _v2072 =  &_v2068;
        if(_v2072 != 0) {
            if(nc_fgets_nb( &_v2068, 2048, _v2072) != 0) {
                _v2132 =  &_v2068;
                 *__esp =  &CONFIG_OPTS;
                strcpy();
            }
        } else {
            _v2132 =  &_v2068;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    if((_v20 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

void get_configure_options(char* gisbase)
{// addr = 0x08053242  --  defined in 'main.c' at line 274
    signed int _v16;                       // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    FILE* fp;             // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2100;                          // _cfa_fffff7cc (outparam)
    char[2047]* _v2104;                    // _cfa_fffff7c8 (outparam)

    _v2080 = gisbase;
    _v16 =  *gs:0x14];
    if((CONFIG_OPTS & 255) == 0) {
        _v2100 = _v2080;
        _v2104 = "%s/etc/config.system";
         *__esp =  &str;
        sprintf();
        _v2104 = 134576350;
         *__esp =  &str;
        fopen();
        fp =  &str;
        if(fp != 0) {
            if(nc_fgets_nb( &str, 2048, fp) != 0) {
                _v2104 =  &str;
                 *__esp =  &CONFIG_OPTS;
                strcpy();
            }
        } else {
            _v2104 =  &str;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    if((_v16 ^  *gs:0x14]) == 0) {
        return;
    } else {
        __stack_chk_fail();
        return;
    }
}

int main(int argc, char** argv)
{// addr = 0x0805331E  --  defined in 'main.c' at line 302
    char* gisbase;                         // r4+328
    char* grass_version;                   // r4+324
    char* grass_major;                     // r4+320
    char* grass_minor;                     // r4+316
    char* grass_revision;                  // r4+312
    char* tmp;                             // r4+308
    char* url;                             // r4+304
    char* filepart;                        // r4+300
    char[2047] version_file;               // r4+12620
    char[2047] package;                    // r4+10572
    char[2047] orgname;                    // r4+8524
    char[2047] pkg_name;                   // r4+6476
    char* bins;                            // r4+296
    int pkg_major;                         // r4+292
    int pkg_minor;                         // r4+288
    int pkg_revision;                      // r4+284
    FILE* f;              // r4+280
    int fd;                                // r4+276
    char[2047] pkg_short_name;             // r4+4428
    char[2047] invocation;                 // r4+2380
    char[2047] coptions;                   // r4+332
    int major;                             // r4+272
    int minor;                             // r4+268
    int revision;                          // r4+264
    int option;                            // r4+260
    int action;                            // r4+256
    int valid;                             // r4+252
    struct stat buf;      // r4+140
    struct stat buf2;     // r4+52
    int error;                             // r4+248
    int is_directory;                      // r4+244
    DIR* dir;              // r4+240
    struct dirent* dir_entry;   // r4+236
    int dir_found;                         // r4+232
    int option_index;                      // r4+228
    intOrPtr _v24;                         // _cfa_ffffffe8
    char _v2072;                           // _cfa_fffff7e8
    char _v4120;                           // _cfa_ffffefe8
    char _v6168;                           // _cfa_ffffe7e8
    char _v8216;                           // _cfa_ffffdfe8
    char _v10264;                          // _cfa_ffffd7e8
    char _v12312;                          // _cfa_ffffcfe8
    char _v14360;                          // _cfa_ffffc7e8
    char* _v14364;                         // _cfa_ffffc7e4
    char* _v14368;                         // _cfa_ffffc7e0
    char[2047]* _v14372;                   // _cfa_ffffc7dc
    char* _v14376;                         // _cfa_ffffc7d8
    char* _v14380;                         // _cfa_ffffc7d4
    char* _v14384;                         // _cfa_ffffc7d0
    char* _v14388;                         // _cfa_ffffc7cc
    char* _v14392;                         // _cfa_ffffc7c8
    char* _v14396;                         // _cfa_ffffc7c4
    int _v14400;                           // _cfa_ffffc7c0
    int _v14404;                           // _cfa_ffffc7bc
    int _v14408;                           // _cfa_ffffc7b8
    intOrPtr* _v14412;                     // _cfa_ffffc7b4
    char* _v14416;                         // _cfa_ffffc7b0
    char[2047]* _v14420;                   // _cfa_ffffc7ac
    intOrPtr _v14424;                      // _cfa_ffffc7a8
    char* _v14428;                         // _cfa_ffffc7a4
    int _v14432;                           // _cfa_ffffc7a0
    int _v14436;                           // _cfa_ffffc79c
    int _v14440;                           // _cfa_ffffc798
    intOrPtr* _v14444;                     // _cfa_ffffc794
    int _v14448;                           // _cfa_ffffc790
    char* _v14452;                         // _cfa_ffffc78c
    char* _v14456;                         // _cfa_ffffc788
    int _v14460;                           // _cfa_ffffc784
    char _v14464;                          // _cfa_ffffc780
    signed int _v14536;                    // _cfa_ffffc738
    char _v14552;                          // _cfa_ffffc728
    signed int _v14624;                    // _cfa_ffffc6e0
    char _v14640;                          // _cfa_ffffc6d0
    char** _v14648;                        // _cfa_ffffc6c8
    char* _v14664;                         // _cfa_ffffc6b8 (outparam)
    char* _v14668;                         // _cfa_ffffc6b4 (outparam)
    char* _v14672;                         // _cfa_ffffc6b0 (outparam)
    int _v14676;                           // _cfa_ffffc6ac (outparam)
    char* _v14680;                         // _cfa_ffffc6a8 (outparam)
    char[2047]* _v14684;                   // _cfa_ffffc6a4 (outparam)
    char* _v14688;                         // _cfa_ffffc6a0 (outparam)
    int _t435;                             // _t435
    int _t441;                             // _t441
    char* _t447;                           // _t447
    int _t448;                             // _t448
    char* _t451;                           // _t451
    char* _t452;                           // _t452
    char* _t461;                           // _t461
    char* _t466;                           // _t466
    char* _t472;                           // _t472
    char* _t473;                           // _t473
    intOrPtr _t474;                        // _t474
    int _t476;                             // _t476
    char* _t494;                           // _t494
    char* _t496;                           // _t496
    char[2047]* _t499;                     // _t499
    intOrPtr _t500;                        // _t500
    char* _t501;                           // _t501
    intOrPtr* _t510;                       // _t510
    intOrPtr* _t525;                       // _t525
    char* _t530;                           // _t530
    char* _t532;                           // _t532
    char* _t533;                           // _t533
    char* _t537;                           // _t537
    intOrPtr _t550;                        // _t550
    _unknown_ _t612;                       // _t612

    __esp = __esp & -16;
    _push(__ebx);
    __esp = __esp - 14684;
    _v14648 = argv;
    _v24 =  *gs:0x14];
    _v14448 = 0;
    _v14464 = 0;
    VERBOSE = 0;
    TMPCLEAN = 0;
    TMPDBCLEAN = 0;
    FORCE = 0;
    UPGRADE = 0;
    ERROR = 0;
    WARNINGS = 0;
    SKIP_CFG = 0;
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &GISMAN_CMD;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &GISMAN2_CMD;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &QGIS_CMD;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &UNINSTALL_CMD;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &HTML_CMD;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMPDIR;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMPDB;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_GISMAN;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_DESCR;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_INFO;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_DEPS;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_BUGS;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_AUTHORS;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_HTML;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &TMP_NULL;
    memcpy();
    _v14684 = 1;
    _v14688 = 134576421;
     *__esp =  &CONFIG_OPTS;
    memcpy();
    _v14684 = 10;
    _v14688 = "configure";
     *__esp =  &CONFIG_CMD;
    memcpy();
    _v14684 = 5;
    _v14688 = "make";
     *__esp =  &MAKE_CMD;
    memcpy();
    _v14688 = 2048;
     *__esp =  &CWD;
    getcwd();
    _v14680 = __imp__stdout;
    _v14684 = 4;
    _v14688 = 1;
     *__esp = 134576437;
    fwrite();
     *__esp = 2048;
    malloc();
    _v14384 = 134576437;
    _v14688 =  *_v14648;
     *__esp =  &_v12312;
    strcpy();
    _v14680 = 0;
    _v14684 = 2;
    _v14688 = 0;
     *__esp = __imp__stdout;
    setvbuf();
    if(argc == 1) {
        show_help();
         *__esp = 0;
        exit();
    }
    atexit(exit_msg);
    _v14440 = 0;
    _v14396 = 0;
    _v14364 = 0;
    __imp__opterr = 0;
    _v14676 =  &_v14464;
    _v14680 =  &long_options;
    _v14684 = ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs";
    _v14688 = _v14648;
    _t435 = argc;
     *__esp = _t435;
    getopt_long();
    _v14432 = _t435;
    while(_v14432 != -1) {
        if(_v14432 != 58) {
L22:
            if(_v14432 == 105 || _v14432 == 117 || _v14432 == 113 || _v14432 == 100 || _v14432 == 99 || _v14432 == 116 || _v14432 == 108 || _v14432 == 114 || _v14432 == 104 || _v14432 == 86) {
                _v14440 = _v14440 + 1;
                if(_v14432 - 86 <= 31) {
                    goto __eax;
                }
                if(__imp__optarg != 0) {
                    _v14688 = __imp__optarg;
                     *__esp =  &_v4120;
                    strcpy();
                    _v14688 = __imp__optarg;
                     *__esp =  &_v6168;
                    strcpy();
                }
            }
            if(_v14432 == 103) {
                _t451 = __imp__optarg;
                 *__esp = _t451;
                strlen();
                _t452 =  &(_t451[1]);
                 *__esp = _t452;
                malloc();
                _v14364 = _t452;
                _v14688 = __imp__optarg;
                 *__esp = _v14364;
                strcpy();
            }
            if(_v14432 == 98) {
                _t447 = __imp__optarg;
                 *__esp = _t447;
                strlen();
                _t448 =  &(_t447[1]);
                 *__esp = _t448;
                malloc();
                _v14396 = _t448;
                _v14688 = __imp__optarg;
                 *__esp = _v14396;
                strcpy();
                _v14436 = 4;
            }
            if(_v14432 == 120) {
                _v14688 = __imp__optarg;
                 *__esp =  &CONFIG_OPTS;
                strcpy();
            }
            if(_v14432 == 102) {
                FORCE = 1;
            }
            if(_v14432 == 118) {
                VERBOSE = 1;
            }
            if(_v14432 == 115) {
                SKIP_CFG = 1;
            }
            if(_v14432 == 111) {
                _v14688 = __imp__optarg;
                 *__esp =  &_v14360;
                strcat();
            }
            if(_v14432 == 67) {
                _v14688 = __imp__optarg;
                 *__esp =  &CONFIG_CMD;
                strcpy();
            }
            if(_v14432 == 109) {
                _v14688 = __imp__optarg;
                 *__esp =  &MAKE_CMD;
                strcpy();
            }
            _v14676 =  &_v14464;
            _v14680 =  &long_options;
            _v14684 = ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs";
            _v14688 = _v14648;
            _t441 = argc;
             *__esp = _t441;
            getopt_long();
            _v14432 = _t441;
            continue;
        } else {
            if(__imp__optopt == 105 || __imp__optopt == 117 || __imp__optopt == 100 || __imp__optopt == 99 || __imp__optopt == 116 || __imp__optopt == 108 || __imp__optopt == 114) {
                print_error(-1, "missing file or directory name.\n");
            }
            if(__imp__optopt == 103) {
                print_error(-1, "missing path to GRASS 6.\n");
            }
            if(__imp__optopt == 98) {
                print_error(-1, "missing name of binary architecture.\n");
            }
            if(__imp__optopt == 98) {
                print_error(-1, "missing configure options.\n");
            }
            if(__imp__optopt != 113) {
                goto L22;
            } else {
                _v14436 = 12;
                _v14440 = _v14440 + 1;
                break;
            }
        }
    }
    if(_v14440 <= 0) {
        print_error(-1, "please specify a valid action.\n");
    }
    if(_v14440 > 1) {
        print_error(-1, "please specify only one action.\n");
    }
    _v14684 =  &_v14360;
    _v14688 = "GEM_C_OPTS=%s";
     *__esp =  &GEM_C_OPTS;
    sprintf();
     *__esp =  &GEM_C_OPTS;
    putenv();
    if(_v14436 == 1) {
        show_help();
         *__esp = 0;
        exit();
    }
    if(_v14436 == 2) {
        show_version();
         *__esp = 0;
        exit();
    }
    _t461 = VERBOSE;
    if(_t461 == 0) {
        _t461 = "/tmp/grass.extension.log.XXXXXX";
        _v14684 = 32;
        _v14688 = _t461;
         *__esp =  &TMP_NULL;
        memcpy();
         *__esp =  &TMP_NULL;
        mkstemp();
        _v14684 = 511;
        _v14688 = 64;
         *__esp =  &TMP_NULL;
        open();
        _v14416 = _t461;
        if(_v14416 == -1) {
            __errno_location();
            _t461 =  *_t461;
             *__esp = _t461;
            strerror();
            _v14684 = _t461;
            print_error(-30, "could not create temp file: %s");
             *__esp = -30;
            exit();
        }
    }
    if(_v14436 == 11) {
        if(_v14364 == 0) {
             *__esp = "GISBASE";
            getenv();
            _v14364 = _t461;
            if(_v14364 == 0) {
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
            }
        }
        if(VERBOSE != 0) {
            _v14684 = _v14364;
            _v14688 = "Path to GRASS is %s.\n";
             *__esp = __imp__stdout;
            fprintf();
        }
        _v14688 = _v14368;
        _t461 = _v14364;
         *__esp = _t461;
        restore();
         *__esp = 0;
        exit();
    }
    if(_v14436 == 12) {
        if(_v14364 == 0) {
             *__esp = "GISBASE";
            getenv();
            _v14364 = _t461;
            if(_v14364 == 0) {
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
            }
        }
        if(VERBOSE != 0) {
            _v14684 = _v14364;
            _v14688 = "Path to GRASS is %s.\n";
             *__esp = __imp__stdout;
            fprintf();
        }
        list_extensions(_v14364);
         *__esp = 0;
        exit();
    }
    _v14688 = "http://";
     *__esp =  &_v4120;
    strstr();
    if( &_v4120 != 0) {
L83:
        wget_extension( &_v4120);
         *__esp = 2048;
        malloc();
        _v14388 =  &_v4120;
        _v14688 =  &_v4120;
         *__esp = _v14388;
        strcpy();
        _v14688 = 47;
        _t466 = _v14388;
         *__esp = _t466;
        strrchr();
        _v14392 = _t466;
        _v14392 =  &(_v14392[1]);
        _v14688 = _v14392;
         *__esp =  &_v4120;
        strcpy();
         *__esp = _v14388;
        free();
        goto L84;
    } else {
        _v14688 = "ftp://";
         *__esp =  &_v4120;
        strstr();
        if( &_v4120 == 0) {
L84:
            if(VERBOSE != 0) {
                _v14684 =  &_v4120;
                _v14688 = "Extension location is '%s'.\n";
                 *__esp = __imp__stdout;
                fprintf();
            }
            if(_v14436 == 10) {
L103:
                if(_v14436 != 10) {
                    _v14688 =  &_v10264;
                    _t472 =  &_v4120;
                     *__esp =  &_v4120;
                    get_package_name();
                } else {
                    _v14688 =  &_v4120;
                    _t472 =  &_v10264;
                     *__esp =  &_v10264;
                    strcpy();
                }
                if(_v14440 > 0) {
                    if(_v14364 == 0) {
                         *__esp = "GISBASE";
                        getenv();
                        _v14364 = _t472;
                    }
                    run_post( &_v4120, _v14436, _v14396, _v14364);
                }
                _t473 = VERBOSE;
                if(_t473 != 0) {
                    _t473 = __imp__stdout;
                    _v14684 =  &_v4120;
                    _v14688 = "Extension will be installed from '%s'\n";
                     *__esp = _t473;
                    fprintf();
                }
                if(_v14436 != 10) {
                    _v14676 =  &_v14408;
                    _v14680 =  &_v14404;
                    _v14684 =  &_v14400;
                    _v14688 =  &_v8216;
                    _t473 =  &_v4120;
                     *__esp =  &_v4120;
                    check_extension();
                }
                if(_v14436 == 5) {
                    _v14664 =  &_v6168;
                    _v14668 =  &_v12312;
                    _v14672 =  &_v10264;
                    _v14676 = _v14408;
                    _v14680 = _v14404;
                    _v14684 = _v14400;
                    _v14688 =  &_v8216;
                    _t473 =  &_v4120;
                     *__esp =  &_v4120;
                    query_extension();
                     *__esp = 0;
                    exit();
                }
                if(_v14436 == 9) {
                    _t473 =  &_v4120;
                    show_details( &_v4120);
                     *__esp = 0;
                    exit();
                }
                if(_v14436 == 7) {
                    _t473 =  &_v4120;
                    show_license( &_v4120);
                     *__esp = 0;
                    exit();
                }
                if(_v14436 == 6) {
                    _t473 = source_clean( &_v4120);
                     *__esp = 0;
                    exit();
                }
                if(_v14364 == 0) {
                     *__esp = "GISBASE";
                    getenv();
                    _v14364 = _t473;
                    if(_v14364 == 0) {
                        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                    }
                }
                _t474 = VERBOSE;
                if(_t474 != 0) {
                    _t474 = __imp__stdout;
                    _v14684 = _v14364;
                    _v14688 = "Path to GRASS is %s.\n";
                     *__esp = _t474;
                    fprintf();
                }
                 *__esp = "GRASS_VERSION";
                getenv();
                _v14368 = _t474;
                if(_v14368 == 0) {
                    _v14684 = _v14364;
                    _v14688 = "%s/etc/VERSIONNUMBER";
                     *__esp =  &_v2072;
                    sprintf();
                    _v14688 = 134576350;
                     *__esp =  &_v2072;
                    fopen();
                    _v14412 =  &_v2072;
                    if(_v14412 != 0) {
                         *__esp = 16;
                        malloc();
                        _v14368 =  &_v2072;
                        _v14684 = _v14368;
                        _v14688 = "%s";
                        _t510 = _v14412;
                         *__esp = _t510;
                        __isoc99_fscanf();
                        _v14444 = _t510;
                         *__esp = _v14412;
                        fclose();
                        if(_v14444 <= 0) {
                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                        }
                    } else {
                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                    }
                }
                if(_v14368 != 0) {
                    _t494 = _v14368;
                     *__esp = _t494;
                    strdup();
                    _v14384 = _t494;
                    _v14688 = 134577087;
                    _t496 = _v14384;
                     *__esp = _t496;
                    strtok();
                    _v14372 = _t496;
                    _v14688 = 134577087;
                     *__esp = 0;
                    strtok();
                    _v14376 = 134577087;
                    _v14688 = 134577087;
                     *__esp = 0;
                    strtok();
                    _v14380 = 134577087;
                    _t499 = _v14372;
                    _v14684 = 10;
                    _v14688 = 0;
                     *__esp = _t499;
                    strtol();
                    _v14420 = _t499;
                    _t500 = _v14376;
                    _v14684 = 10;
                    _v14688 = 0;
                     *__esp = _t500;
                    strtol();
                    _v14424 = _t500;
                    _t501 = _v14380;
                    _v14684 = 10;
                    _v14688 = 0;
                     *__esp = _t501;
                    strtol();
                    _v14428 = _t501;
                     *__esp = 2048;
                    malloc();
                    _v14368 = _t501;
                    _v14676 = _v14428;
                    _v14680 = _v14424;
                    _v14684 = _v14420;
                    _v14688 = "%i.%i.%i";
                     *__esp = _v14368;
                    sprintf();
                    if(VERBOSE != 0) {
                        _v14684 = _v14368;
                        _v14688 = "GRASS version is %s.\n";
                         *__esp = __imp__stdout;
                        fprintf();
                    }
                    if(_v14420 <= 5) {
                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                    }
                }
                _v14684 = _v14364;
                _v14688 = "-L%s/lib -I/usr/local/grasslib/include/ ";
                _t476 =  &_v14360;
                 *__esp =  &_v14360;
                sprintf();
                if(_v14436 == 3) {
                    _v14668 = _v14368;
                    _v14672 = _v14408;
                    _v14676 = _v14404;
                    _v14680 = _v14400;
                    _v14684 =  &_v10264;
                    _v14688 = _v14364;
                    _t476 =  &_v4120;
                     *__esp =  &_v4120;
                    source_install();
                     *__esp = 0;
                    exit();
                }
                if(_v14436 == 10) {
                    _v14680 = _v14368;
                    _v14684 = _v14364;
                    _v14688 =  &_v10264;
                    _t476 =  &_v4120;
                     *__esp =  &_v4120;
                    uninstall();
                     *__esp = 0;
                    exit();
                }
                if(_v14436 == 8) {
                    _v14668 = _v14368;
                    _v14672 = _v14408;
                    _v14676 = _v14404;
                    _v14680 = _v14400;
                    _v14684 =  &_v10264;
                    _v14688 = _v14364;
                    _t476 =  &_v4120;
                     *__esp =  &_v4120;
                    test_install();
                     *__esp = 0;
                    exit();
                }
                if(_v14436 == 4) {
                    if(binaries_exist( &_v4120, _v14396) != 0) {
                        bin_install( &_v4120, _v14364, _v14396,  &_v10264, _v14400, _v14404, _v14408, _v14368);
                         *__esp = 0;
                        exit();
                    }
                    _t476 = _v14396;
                    _v14684 = _t476;
                    print_error(-12, "no binaries for system '%s'\n");
                }
                 *__esp = 0;
                exit();
                _push(_t612);
                return _t476;
            } else {
                _t525 = __stat( &_v4120,  &_v14552);
                _v14444 = _t525;
                if(_v14444 < 0) {
                    __errno_location();
                    _t550 =  *_t525;
                     *__esp = _t550;
                    strerror();
                    _v14680 = _t550;
                    _v14684 =  &_v4120;
                    print_error(-2, "extension FILE or DIR '%s' invalid: %s\n");
                }
                if((_v14536 & 61440) != 16384) {
                    if(VERBOSE != 0) {
                        _v14680 = __imp__stdout;
                        _v14684 = 42;
                        _v14688 = 1;
                         *__esp = "Extension files stored in a package file.\n";
                        fwrite();
                    }
                    unpack_extension( &_v4120);
                     *__esp =  &TMPDIR;
                    opendir();
                    _v14452 =  &_v4120;
                    _t530 = _v14452;
                     *__esp = _t530;
                    readdir();
                    _v14456 = _t530;
                    _v14460 = 0;
                    while(_v14456 != 0) {
                        _t532 =  &(_v14456[0xb]);
                        _v14688 = 134577087;
                         *__esp = _t532;
                        strcmp();
                        if(_t532 == 0) {
L99:
                            _t533 = _v14452;
                             *__esp = _t533;
                            readdir();
                            _v14456 = _t533;
                            continue;
                        }
                        _t537 =  &(_v14456[0xb]);
                        _v14688 = 134577089;
                         *__esp = _t537;
                        strcmp();
                        if(_t537 == 0) {
                            goto L99;
                        }
                        _v14680 =  &(_v14456[0xb]);
                        _v14684 =  &TMPDIR;
                        _v14688 = 134577092;
                         *__esp = _v14384;
                        sprintf();
                        __stat(_v14384,  &_v14640);
                        if((_v14624 & 61440) != 16384) {
                            goto L99;
                        }
                        _v14460 = 1;
                        break;
                    }
                    _v14688 = _v14384;
                     *__esp =  &_v4120;
                    strcpy();
                    if(_v14460 == 0) {
                        print_error(-7, "no top-level directory found in extension package.\n");
                    }
                } else {
                    _v14448 = 1;
                    if(VERBOSE != 0) {
                        _v14680 = __imp__stdout;
                        _v14684 = 39;
                        _v14688 = 1;
                         *__esp = "Extension files stored in a directory.\n";
                        fwrite();
                    }
                }
                goto L103;
            }
        }
        goto L83;
    }
}

__libc_csu_fini(
    _unknown_ __eax                        // r0
)
{// addr = 0x080546E0
    __eax = __eax;
    return __eax;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080546F0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ _t11;                        // _t11
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    __i686.get_pc_thunk.bx(_t11);
    _t18 = _t17 + 18681;
    __esp = __esp - 28;
    _init();
    _t21 = _t18 - 228 - _t18 - 228 >> 2;
    if(_t21 != 0) {
        __esi = 0;
        do {
            _v36 = _a12;
            _v40 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t18 + __esi * 4 - 228))();
            __esi = __esi + 1;
        } while(__esi < _t21);
    }
    __esp = __esp + 28;
}

__i686.get_pc_thunk.bx(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805474A
    __eax = __eax;
    return __eax;
}

atexit(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08054750
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ _t5;                         // _t5
    intOrPtr* _t7;                         // _t7
    intOrPtr _t8;                          // _t8
    _unknown_ _t9;                         // _t9

    __i686.get_pc_thunk.bx(_t5);
    __esp = __esp - 12;
    _t7 =  *((intOrPtr*)(_t9 + 18587 - 4));
    if(_t7 != 0) {
        _t7 =  *_t7;
    }
    _v12 = _t7;
    _t8 = _a4;
    _v16 = 0;
     *__esp = _t8;
    __cxa_atexit();
    __esp = __esp + 12;
    return _t8;
}

__stat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08054790
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _t6 = __i686.get_pc_thunk.bx(_a8);
     *__esp = 3;
    _v12 = _t6;
    _t7 = _a4;
    _v16 = _t7;
    __xstat();
    return _t7;
}

__do_global_ctors_aux()
{// addr = 0x080547D0
    intOrPtr* __ebx;                       // r1

    __eax = __CTOR_LIST__;
    if(__eax != -1) {
        __ebx =  &__CTOR_LIST__;
        do {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
        } while(__eax != -1);
    }
}

_fini()
{// addr = 0x080547FC
    _unknown_ __ebx;                       // r1
    _unknown_ _t1;                         // _t1

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    return __eax;
}

L08054808()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

L08054808()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = @rec __do_global_dtors_aux@__do_global_dtors_aux@();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

// Statistics:
//    1123 Register nodes
//     806 Temporaries nodes
//      12 Casts
//    2151 Statements
//      94 Labels
//      69 Gotos
//     129 Blocks
//   20916 Nodes
//       1 Assembly nodes
//      55 Unknown Types


Total time: 2 seconds.
