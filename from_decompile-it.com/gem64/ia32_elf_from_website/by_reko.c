// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_fini.h"

// 080547FC: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_init.h"

// 08048A44: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	if (g_dw8058FFC != 0x00)
		__gmon_start__();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_plt.h"

// 08048A84: void fputs()
void fputs()
{
}

// 08048A94: void __errno_location()
void __errno_location()
{
}

// 08048AA4: void sprintf()
void sprintf()
{
}

// 08048AB4: void srand()
void srand()
{
}

// 08048AC4: void open()
void open()
{
}

// 08048AD4: void strerror()
void strerror()
{
}

// 08048AE4: void __cxa_atexit()
void __cxa_atexit()
{
}

// 08048AF4: void __isoc99_fscanf()
void __isoc99_fscanf()
{
}

// 08048B04: void __xstat()
void __xstat()
{
}

// 08048B14: void __gmon_start__()
void __gmon_start__()
{
}

// 08048B24: void rewind()
void rewind()
{
}

// 08048B34: void __isoc99_sscanf()
void __isoc99_sscanf()
{
}

// 08048B44: void vsprintf()
void vsprintf()
{
}

// 08048B54: void strchr()
void strchr()
{
}

// 08048B64: void getenv()
void getenv()
{
}

// 08048B74: void calloc()
void calloc()
{
}

// 08048B84: void system()
void system()
{
}

// 08048B94: void strncpy()
void strncpy()
{
}

// 08048BA4: void fgets()
void fgets()
{
}

// 08048BB4: void __libc_start_main()
void __libc_start_main()
{
}

// 08048BC4: void strrchr()
void strrchr()
{
}

// 08048BD4: void readdir()
void readdir()
{
}

// 08048BE4: void strtol()
void strtol()
{
}

// 08048BF4: void free()
void free()
{
}

// 08048C04: void fflush()
void fflush()
{
}

// 08048C14: void mkstemp()
void mkstemp()
{
}

// 08048C24: void opendir()
void opendir()
{
}

// 08048C34: void getopt_long()
void getopt_long()
{
}

// 08048C44: void fclose()
void fclose()
{
}

// 08048C54: void memcpy()
void memcpy()
{
}

// 08048C64: void strlen()
void strlen()
{
}

// 08048C74: void fopen()
void fopen()
{
}

// 08048C84: void strcpy()
void strcpy()
{
}

// 08048C94: void chdir()
void chdir()
{
}

// 08048CA4: void putenv()
void putenv()
{
}

// 08048CB4: void closedir()
void closedir()
{
}

// 08048CC4: void close()
void close()
{
}

// 08048CD4: void fwrite()
void fwrite()
{
}

// 08048CE4: void fprintf()
void fprintf()
{
}

// 08048CF4: void strstr()
void strstr()
{
}

// 08048D04: void setvbuf()
void setvbuf()
{
}

// 08048D14: void remove()
void remove()
{
}

// 08048D24: void malloc()
void malloc()
{
}

// 08048D34: void __stack_chk_fail()
void __stack_chk_fail()
{
}

// 08048D44: void fputc()
void fputc()
{
}

// 08048D54: void strtok()
void strtok()
{
}

// 08048D64: void strcat()
void strcat()
{
}

// 08048D74: void getcwd()
void getcwd()
{
}

// 08048D84: void rand()
void rand()
{
}

// 08048D94: void strdup()
void strdup()
{
}

// 08048DA4: void strcmp()
void strcmp()
{
}

// 08048DB4: void exit()
void exit()
{
}

// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 08048DD0: void _start(Register (ptr32 Eq_14) edx, Stack int32 dwArg00)
void _start(void (* edx)(), int32 dwArg00)
{
	__align((char *) fp + 4);
	__libc_start_main(&g_t805331E, dwArg00, (char *) fp + 4, &g_t80546F0, &g_t80546E0, edx, fp);
	__hlt();
}

// 08048E00: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b8059284 == 0x00)
	{
		uint32 eax_14 = g_dw8059288;
		while (eax_14 < 0x00)
		{
			uint32 eax_24 = eax_14 + 0x01;
			g_dw8059288 = eax_24;
			(*((char *) g_a8058F18 + eax_24 * 0x04))();
			eax_14 = g_dw8059288;
		}
		g_b8059284 = 0x01;
	}
}

// 08048E60: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
	if (g_dw8058F20 != 0x00 && 0x00 != 0x00)
		fn00000000();
}

// 08048E84: void exit_env()
void exit_env()
{
}

// 08048E89: void exit_tmp(Register (ptr32 Eq_74) gs)
void exit_tmp(struct Eq_74 * gs)
{
	word32 eax_10 = gs->dw0014;
	if ((byte) (word32) g_b80632C0 == 0x00)
		g_dw80682C0 = 0x01;
	else if (g_dw80682C0 == 0x00)
	{
		word32 edx_25;
		word32 ecx_112;
		chdir();
		sprintf(fp + ~0x080F, "rm -rf %s/*", 0x00);
		if (g_dw80632A0 != 0x00)
			fwrite(&g_v805482C, 0x01, 0x25, g_ptr8059260);
		word32 eax_51;
		system();
		sprintf(fp + ~0x080F, "rmdir %s", 0x00);
		word32 edx_64;
		word32 ecx_127;
		system();
		if (opendir(&g_b80632C0) != null)
			print_warning(gs, 0x0805485C);
		if (g_dw80632A0 != 0x00)
			print_done();
		g_dw80682C0 = 0x01;
	}
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08048FC2: void exit_db(Register (ptr32 Eq_74) gs)
void exit_db(struct Eq_74 * gs)
{
	word32 eax_10 = gs->dw0014;
	if (g_dw80682C4 == 0x00)
	{
		word32 edx_19;
		word32 ecx_381;
		chdir();
		if (g_dw80632A0 != 0x00)
			fwrite(&g_v80548A0, 0x01, 0x28, g_ptr8059260);
		if ((byte) (word32) g_b8063AC0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -rf %s", 0x00);
			word32 eax_52;
			word32 edx_53;
			word32 ecx_390;
			system();
			if (eax_52 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b80642C0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_86;
			word32 edx_87;
			word32 ecx_88;
			system();
			if (eax_86 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b8064AC0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_121;
			word32 edx_122;
			word32 ecx_123;
			system();
			if (eax_121 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b80652C0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_156;
			word32 edx_157;
			word32 ecx_158;
			system();
			if (eax_156 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b8065AC0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_191;
			word32 edx_192;
			word32 ecx_193;
			system();
			if (eax_191 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b80662C0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_226;
			word32 edx_227;
			word32 ecx_228;
			system();
			if (eax_226 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b8066AC0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_261;
			word32 edx_262;
			word32 ecx_263;
			system();
			if (eax_261 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if ((byte) (word32) g_b8067AC0 != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_296;
			word32 edx_297;
			word32 ecx_298;
			system();
			if (eax_296 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_dw80632A0 == 0x00 && (byte) ((word32) g_b80672C0) != 0x00)
		{
			sprintf(fp + ~0x080F, "rm -f %s", 0x00);
			word32 eax_335;
			word32 edx_336;
			word32 ecx_337;
			system();
			if (eax_335 != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_dw80632A0 != 0x00)
			print_done();
		g_dw80682C4 = 0x01;
	}
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08049390: void exit_msg()
void exit_msg()
{
	if (g_dw806CAE0 < 0x00)
		fprintf(g_ptr8059260, 134564124, g_dw806CAE0);
	else
	{
		if (g_dw806CAE4 == 0x01)
			fwrite(&g_v8054958, 0x01, 0x32, g_ptr8059260);
		if (g_dw806CAE4 > 0x01)
			fprintf(g_ptr8059260, 0x0805498C, g_dw806CAE4);
	}
}

// 08049420: void print_error(Register (ptr32 Eq_74) gs, Stack int32 dwArg04, Stack word32 dwArg08)
// Called from:
//      insert_str
//      delete_str
//      get_package_name
//      dump_plain
//      dump_html
//      wget_extension
//      su
//      depstr
//      register_extension
//      deregister_extension
//      check_dependencies
//      check_ext_menu
//      register_entries_gisman
//      register_entries_gisman2
//      deregister_entries_gisman
//      deregister_entries_gisman2
//      restore_entries_gisman
//      register_html
//      deregister_html
//      restore_html
//      check_extension
//      unpack_extension
//      query_extension
//      source_install
//      bin_install
//      test_install
//      source_clean
//      restore
//      list_extensions
//      show_details
//      show_license
//      main
void print_error(struct Eq_74 * gs, int32 dwArg04, word32 dwArg08)
{
	vsprintf();
	fprintf(g_ptr8059244, 0x080549C0, fp + ~0x080F);
	g_dw806CAE0 = dwArg04;
	exit(dwArg04);
}

// 0804949B: void print_warning(Register (ptr32 Eq_74) gs, Stack word32 dwArg04)
// Called from:
//      exit_tmp
//      exit_db
//      new_submenu
//      new_item
//      register_entries_gisman
//      deregister_entries_gisman
//      new_ext_html
//      delete_ext_html
//      unpack_extension
//      source_install
//      bin_install
//      test_install
//      uninstall
//      get_configure_options
void print_warning(struct Eq_74 * gs, word32 dwArg04)
{
	word32 eax_12 = gs->dw0014;
	vsprintf();
	fprintf(g_ptr8059244, 134564310, fp + ~0x080F);
	++g_dw806CAE4;
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08049523: void print_done()
// Called from:
//      exit_tmp
//      exit_db
//      wget_extension
//      check_extension
//      unpack_extension
//      source_install
//      bin_install
//      test_install
//      uninstall
//      source_clean
//      restore
void print_done()
{
	fwrite(&g_v80549EE, 0x01, 0x11, g_ptr8059260);
}

// 08049554: Register Eq_102 basename(Stack Eq_102 dwArg04)
// Called from:
//      unpack_extension
//      query_extension
//      source_install
//      bin_install
//      test_install
//      source_clean
//      run_post
//      show_details
//      show_license
Eq_102 basename(Eq_102 dwArg04)
{
	Eq_102 eax_111;
	Eq_102 eax_11 = strdup(dwArg04);
	Eq_102 eax_18 = strtok(eax_11, "/");
	Eq_102 dwLoc14_83 = eax_18;
	if (eax_18 == 0x00)
	{
		if (eax_11 != 0x00)
			free(eax_11);
		eax_111.u0 = 0x00;
	}
	else
	{
		Eq_102 dwLoc18_85 = strdup(eax_18);
		while (dwLoc14_83 != 0x00)
		{
			Eq_102 eax_34 = strtok(0x00, "/");
			dwLoc14_83 = eax_34;
			if (dwLoc18_85 != 0x00 && eax_34 != 0x00)
				free(dwLoc18_85);
			if (eax_34 != 0x00 && (byte) ((word32) (*eax_34)) != 0x00)
				dwLoc18_85 = strdup(eax_34);
		}
		if (eax_11 != 0x00)
			free(eax_11);
		eax_111 = dwLoc18_85;
	}
	return eax_111;
}

// 0804961D: void mkdir_s(Register (ptr32 Eq_74) gs, Stack word32 dwArg04, Stack word32 dwArg08)
// Called from:
//      unpack_extension
void mkdir_s(struct Eq_74 * gs, word32 dwArg04, word32 dwArg08)
{
	word32 eax_14 = gs->dw0014;
	sprintf(fp + ~0x1397, "mkdir %s --mode=%s -p", 0x00);
	system();
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804968F: void chop(Stack Eq_102 dwArg04)
// Called from:
//      get_package_name
//      dump_html
//      new_item
void chop(Eq_102 dwArg04)
{
	Eq_581 dwLoc14_104 = 0x00;
	Eq_583 dwLoc10_88;
	for (dwLoc10_88 = strlen(dwArg04) - 0x01; dwLoc10_88 >= null; --dwLoc10_88)
	{
		word32 dwLoc18_90 = 0x01;
		if (SLICE((word32) Mem21[dwLoc10_88 + dwArg04:byte], byte, 0) == 0x0A || (SLICE((word32) Mem21[dwLoc10_88 + dwArg04:byte], byte, 0) == 0x09 || (SLICE((word32) Mem21[dwLoc10_88 + dwArg04:byte], byte, 0) == 0x20 || (SLICE((word32) Mem21[dwLoc10_88 + dwArg04:byte], byte, 0) == 0x0C || SLICE((word32) Mem21[dwLoc10_88 + dwArg04:byte], byte, 0) == 0x0D))))
		{
			++dwLoc14_104;
			dwLoc18_90 = 0x00;
		}
		if (dwLoc18_90 == 0x01)
			break;
	}
	Mem78[strlen(dwArg04) - dwLoc14_104 + dwArg04:byte] = 0x00;
}

// 08049737: void insert_str(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack int32 dwArg08, Stack Eq_102 dwArg0C)
// Called from:
//      check_ext_menu
//      new_submenu
//      new_item
//      new_ext_html
void insert_str(struct Eq_74 * gs, Eq_102 dwArg04, int32 dwArg08, Eq_102 dwArg0C)
{
	word32 eax_17 = gs->dw0014;
	int32 dwLoc1814_231 = 0x00;
	while (*((word32) dwArg0C + dwLoc1814_231 * 0x04) != 0x00)
		++dwLoc1814_231;
	if (dwArg08 < 0x00 || dwArg08 > dwLoc1814_231)
		print_error(gs, ~0x14, 0x08054A18);
	else
	{
		if (dwArg08 == dwLoc1814_231)
		{
			dwArg0C[dwLoc1814_231 * 0x04] = malloc(strlen(dwArg04) + 0x01);
			strcpy(*((word32) dwArg0C + dwLoc1814_231 * 0x04), dwArg04);
			((word32) dwArg0C + (dwLoc1814_231 + 0x01) * 0x04)->u0 = 0x00;
		}
		else
		{
			strcpy(fp + ~0x180F, *((word32) dwArg0C + (dwLoc1814_231 - 0x01) * 0x04));
			strcpy(fp + ~0x100F, *((word32) dwArg0C + dwArg08 * 0x04));
			free(*((word32) dwArg0C + dwArg08 * 0x04));
			dwArg0C[dwArg08 * 0x04] = malloc(strlen(dwArg04) + 0x01);
			strcpy(*((word32) dwArg0C + dwArg08 * 0x04), dwArg04);
			int32 dwLoc1818_247;
			for (dwLoc1818_247 = dwArg08; dwLoc1814_231 - 0x01 > dwLoc1818_247; ++dwLoc1818_247)
			{
				strcpy(fp + ~0x080F, *((word32) dwArg0C + (dwLoc1818_247 + 0x01) * 0x04));
				free(*((word32) dwArg0C + (dwLoc1818_247 + 0x01) * 0x04));
				dwArg0C[(dwLoc1818_247 + 0x01) * 0x04] = malloc(strlen(fp + ~0x100F) + 0x01);
				strcpy(*((word32) dwArg0C + (dwLoc1818_247 + 0x01) * 0x04), fp + ~0x100F);
				strcpy(fp + ~0x100F, fp + ~0x080F);
			}
			dwArg0C[dwLoc1814_231 * 0x04] = malloc(strlen(fp + ~0x180F) + 0x01);
			strcpy(*((word32) dwArg0C + dwLoc1814_231 * 0x04), fp + ~0x180F);
			((word32) dwArg0C + (dwLoc1814_231 + 0x01) * 0x04)->u0 = 0x00;
		}
		if ((eax_17 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
}

// 08049A5E: void delete_str(Register (ptr32 Eq_74) gs, Stack int32 dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      deregister_entries_gisman
//      delete_ext_html
void delete_str(struct Eq_74 * gs, int32 dwArg04, Eq_102 dwArg08)
{
	int32 dwLoc10_117 = 0x00;
	while (*((word32) dwArg08 + dwLoc10_117 * 0x04) != 0x00)
		++dwLoc10_117;
	if (dwArg04 < 0x00 || dwArg04 > dwLoc10_117)
		print_error(gs, ~0x14, 134564412);
	else
	{
		int32 dwLoc10_123 = dwArg04;
		while (*((word32) dwArg08 + dwLoc10_123 * 0x04) != 0x00)
		{
			free(*((word32) dwArg08 + dwLoc10_123 * 0x04));
			if (*((word32) dwArg08 + (dwLoc10_123 + 0x01) * 0x04) != 0x00)
			{
				dwArg08[dwLoc10_123 * 0x04] = malloc(strlen(*((word32) dwArg08 + (dwLoc10_123 + 0x01) * 0x04)) + 0x01);
				strcpy(*((word32) dwArg08 + dwLoc10_123 * 0x04), *((word32) dwArg08 + (dwLoc10_123 + 0x01) * 0x04));
			}
			++dwLoc10_123;
		}
		((word32) dwArg08 + (dwLoc10_123 - 0x01) * 0x04)->u0 = 0x00;
	}
}

// 08049B5F: Register int32 find_pos(Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack int32 dwArg0C)
// Called from:
//      check_ext_menu
//      new_submenu
//      deregister_entries_gisman
//      new_ext_html
//      delete_ext_html
int32 find_pos(Eq_102 dwArg04, Eq_102 dwArg08, int32 dwArg0C)
{
	int32 dwLoc10_61 = 0x00;
	while (*((word32) dwArg08 + dwLoc10_61 * 0x04) != 0x00)
		++dwLoc10_61;
	if (dwArg0C < 0x00 || dwArg0C > dwLoc10_61)
		exit(~0x14);
	else
	{
		int32 dwLoc14_67 = dwArg0C;
		while (true)
		{
			int32 eax_50;
			if (dwLoc14_67 >= dwLoc10_61)
				break;
			if (strstr(*((word32) dwArg08 + dwLoc14_67 * 0x04), dwArg04) != null)
			{
				eax_50 = dwLoc14_67;
				return eax_50;
			}
			++dwLoc14_67;
		}
		eax_50 = ~0x00;
		return eax_50;
	}
}

// 08049BD9: void dump_str(Stack (ptr32 Eq_139) dwArg04, Stack (arr (ptr32 char)) dwArg08)
void dump_str(FILE * dwArg04, char * dwArg08[])
{
	int32 dwLoc10_40 = 0x00;
	while (dwArg08[dwLoc10_40] != null)
	{
		fprintf(dwArg04, 134564445, dwLoc10_40, dwArg08[dwLoc10_40]);
		++dwLoc10_40;
	}
}

// 08049C27: void get_package_name(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg08)
// Called from:
//      check_extension
//      main
void get_package_name(struct Eq_74 * gs, Eq_102 dwArg08)
{
	word32 eax_14 = gs->dw0014;
	sprintf(fp + ~0x080F, "%s/%s", 0x00);
	FILE * eax_29 = fopen(fp + ~0x080F, "r");
	if (eax_29 != null)
	{
		if (nc_fgets_nb(fp + ~0x100F, 0x0800, eax_29) != 0x00)
		{
			chop(fp + ~0x100F);
			strcpy(dwArg08, fp + ~0x100F);
			fclose(eax_29);
			if ((eax_14 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
		{
			fclose(eax_29);
			print_error(gs, ~0x05, 0x08054A8C);
		}
	}
	else
		print_error(gs, ~0x05, 134564465);
}

// 08049D41: Register Eq_102 nc_fgets(Stack Eq_102 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_139) dwArg0C)
// Called from:
//      nc_fgets
//      dump_plain
//      dump_html
Eq_102 nc_fgets(Eq_102 dwArg04, int32 dwArg08, FILE * dwArg0C)
{
	Eq_102 eax_103;
	if (fgets(dwArg04, dwArg08, dwArg0C) != null)
	{
		Eq_102 eax_22 = strchr(dwArg04, '#');
		if (eax_22 != 0x00)
		{
			if (dwArg04 == eax_22)
			{
				eax_103 = nc_fgets(dwArg04, dwArg08, dwArg0C);
				return eax_103;
			}
			Eq_102 eax_30 = malloc(0x0800);
			strcpy(eax_30, dwArg04);
			Eq_102 eax_41 = strtok(eax_30, "#");
			sprintf(dwArg04, "%s\n", 0x00);
			free(eax_41);
		}
		eax_103 = dwArg04;
		return eax_103;
	}
	else
	{
		eax_103.u0 = 0x00;
		return eax_103;
	}
}

// 08049E14: Register Eq_102 nc_fgets_html(Stack Eq_102 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_139) dwArg0C)
// Called from:
//      nc_fgets_html
//      dump_ascii
Eq_102 nc_fgets_html(Eq_102 dwArg04, int32 dwArg08, FILE * dwArg0C)
{
	Eq_102 eax_287;
	if (fgets(dwArg04, dwArg08, dwArg0C) != null)
	{
		word32 eax_24 = malloc(strlen(dwArg04) + 0x01);
		word32 eax_32 = malloc(strlen(dwArg04) + 0x01);
		Eq_102 dwLoc2C_330 = eax_24;
		Eq_102 dwLoc28_331 = dwArg04;
		while ((byte) (word32) *dwLoc28_331 != 0x00)
		{
			if ((byte) (word32) *dwLoc28_331 == 0x3C)
			{
				Eq_102 v10_55 = dwLoc28_331 - 0x01;
				Eq_102 dwLoc18_333 = dwLoc28_331;
				dwLoc28_331 = v10_55;
				if (v10_55 >= dwArg04)
				{
					if ((byte) (word32) *v10_55 == 0x20)
						dwLoc30 = 0x01;
					else
						dwLoc30 = 0x00;
				}
				while ((byte) (word32) *dwLoc18_333 != 0x00)
				{
					*eax_32 = (byte) (word32) *dwLoc18_333;
					*eax_32 = (byte) ((word32) *eax_32 + 0x01);
					if ((byte) (word32) *dwLoc18_333 == 0x3E)
					{
						*eax_32 = 0x00;
						if ((byte) (word32) *((word32) dwLoc18_333 + 1) != 0x0A)
						{
							if (strstr(eax_32, 134564534) != null && dwLoc2C_330 > eax_24)
							{
								*dwLoc2C_330 = 0x0A;
								*dwLoc2C_330 = (byte) ((word32) *dwLoc2C_330 + 0x01);
							}
							if (strstr(eax_32, 0x08054ABB) != null && dwLoc2C_330 > eax_24)
							{
								*dwLoc2C_330 = 0x0A;
								*dwLoc2C_330 = (byte) ((word32) *dwLoc2C_330 + 0x01);
							}
							if (strstr(eax_32, 134564544) != null)
							{
								if (dwLoc2C_330 > eax_24)
								{
									*dwLoc2C_330 = 0x0A;
									*dwLoc2C_330 = (byte) ((word32) *dwLoc2C_330 + 0x01);
								}
								*dwLoc2C_330 = 0x0A;
								*dwLoc2C_330 = (byte) ((word32) *dwLoc2C_330 + 0x01);
							}
							if (strstr(eax_32, 134564548) != null)
							{
								if (dwLoc2C_330 > eax_24)
								{
									*dwLoc2C_330 = 0x0A;
									*dwLoc2C_330 = (byte) ((word32) *dwLoc2C_330 + 0x01);
								}
								*dwLoc2C_330 = 0x0A;
								*dwLoc2C_330 = (byte) ((word32) *dwLoc2C_330 + 0x01);
							}
						}
						dwLoc28_331 = dwLoc18_333;
						if ((byte) (word32) *dwLoc18_333 == 0x20 && dwLoc30 == 0x01)
						{
							dwLoc28_331 = (word32) dwLoc18_333 + 1;
							dwLoc30 = 0x00;
						}
						break;
					}
					dwLoc18_333 = (word32) dwLoc18_333 + 1;
				}
			}
			if ((byte) (word32) *dwLoc28_331 != 0x3E)
			{
				*dwLoc2C_330 = (byte) (word32) *dwLoc28_331;
				dwLoc2C_330 = (word32) dwLoc2C_330 + 1;
			}
			dwLoc28_331 = (word32) dwLoc28_331 + 1;
		}
		*dwLoc2C_330 = 0x00;
		strcpy(dwArg04, eax_24);
		free(eax_24);
		free(eax_32);
		Eq_102 eax_255 = strchr(dwArg04, '#');
		if (eax_255 != 0x00)
		{
			if (dwArg04 == eax_255)
			{
				eax_287 = nc_fgets_html(dwArg04, dwArg08, dwArg0C);
				return eax_287;
			}
			Eq_102 eax_263 = malloc(0x0800);
			strcpy(eax_263, dwArg04);
			Eq_102 eax_274 = strtok(eax_263, "#");
			sprintf(dwArg04, "%s\n", 0x00);
			free(eax_274);
		}
		eax_287 = dwArg04;
		return eax_287;
	}
	else
	{
		eax_287.u0 = 0x00;
		return eax_287;
	}
}

// 0804A146: Register word32 is_text(Stack Eq_102 dwArg04)
// Called from:
//      nc_fgets_nb
//      dump_html
word32 is_text(Eq_102 dwArg04)
{
	Eq_1312 dwLoc10_66 = strlen(dwArg04) - 0x01;
	while (true)
	{
		word32 dwLoc14_69 = 0x00;
		if (dwLoc10_66 < null)
			break;
		if (SLICE((word32) Mem17[dwLoc10_66 + dwArg04:byte], byte, 0) != 0x20 && (SLICE((word32) Mem17[dwLoc10_66 + dwArg04:byte], byte, 0) != 0x09 && (SLICE((word32) Mem17[dwLoc10_66 + dwArg04:byte], byte, 0) != 0x0A && (SLICE((word32) Mem17[dwLoc10_66 + dwArg04:byte], byte, 0) != 0x0C && SLICE((word32) Mem17[dwLoc10_66 + dwArg04:byte], byte, 0) != 0x0D))))
		{
			dwLoc14_69 = 0x01;
			return dwLoc14_69;
		}
		dwLoc10_66 -= (char *) 0x01;
	}
	return dwLoc14_69;
}

// 0804A1C8: Register Eq_102 nc_fgets_nb(Stack Eq_102 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_139) dwArg0C)
// Called from:
//      get_package_name
//      nc_fgets_nb
//      depstr
//      register_extension
//      deregister_extension
//      check_dependencies
//      register_entries_gisman
//      restore_entries_gisman
//      check_extension
//      get_configure_options
Eq_102 nc_fgets_nb(Eq_102 dwArg04, int32 dwArg08, FILE * dwArg0C)
{
	Eq_102 eax_127;
	if (fgets(dwArg04, dwArg08, dwArg0C) != null)
	{
		if (is_text(dwArg04) != 0x00)
		{
			Eq_102 eax_32 = strchr(dwArg04, '#');
			if (eax_32 != 0x00)
			{
				if (dwArg04 == eax_32)
				{
					eax_127 = nc_fgets_nb(dwArg04, dwArg08, dwArg0C);
					return eax_127;
				}
				Eq_102 eax_40 = malloc(0x0800);
				strcpy(eax_40, dwArg04);
				Eq_102 eax_51 = strtok(eax_40, "#");
				sprintf(dwArg04, "%s\n", 0x00);
				free(eax_51);
			}
			eax_127 = dwArg04;
			return eax_127;
		}
		else
		{
			eax_127 = nc_fgets_nb(dwArg04, dwArg08, dwArg0C);
			return eax_127;
		}
	}
	else
	{
		eax_127.u0 = 0x00;
		return eax_127;
	}
}

// 0804A2C8: void dump_ascii(Register (ptr32 Eq_74) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      query_extension
//      list_extensions
//      show_details
//      show_license
void dump_ascii(struct Eq_74 * gs, char * dwArg04, char * dwArg08)
{
	word32 eax_14 = gs->dw0014;
	fprintf(g_ptr8059260, 134564530, dwArg08);
	FILE * eax_28 = fopen(dwArg04, "r");
	if (eax_28 == null)
		fwrite(&g_v8054AC8, 0x01, 0x1C, g_ptr8059260);
	else
	{
		while (nc_fgets_html(fp + ~0x080F, 0x0800, eax_28) != 0x00)
			fprintf(g_ptr8059260, 0x08054AE5, fp + ~0x080F);
		fputc(0x0A, g_ptr8059260);
		fclose(eax_28);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804A3DB: void dump_plain(Register (ptr32 Eq_74) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      test_install
void dump_plain(struct Eq_74 * gs, char * dwArg04, char * dwArg08)
{
	word32 eax_14 = gs->dw0014;
	memcpy(dwArg08, &g_v8054AEC, 0x20);
	mkstemp();
	FILE * eax_34 = fopen(dwArg08, "w+");
	if (eax_34 != null)
	{
		atexit(&g_t8048FC2);
		FILE * eax_57 = fopen(dwArg04, "r");
		while (nc_fgets(fp + ~0x080F, 0x0800, eax_57) != 0x00)
			fprintf(eax_34, fp + ~0x080F, 0x00);
		fclose(eax_57);
		fclose(eax_34);
		if ((eax_14 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x16, 0x08054B10);
	}
}

// 0804A51B: void dump_html(Register (ptr32 Eq_74) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      source_install
//      bin_install
void dump_html(struct Eq_74 * gs, char * dwArg04, char * dwArg08)
{
	word32 eax_14 = gs->dw0014;
	memcpy(dwArg08, &g_v8054AEC, 0x20);
	mkstemp();
	FILE * eax_34 = fopen(dwArg08, "w+");
	if (eax_34 != null)
	{
		atexit(&g_t8048FC2);
		FILE * eax_57 = fopen(dwArg04, "r");
		while (nc_fgets(fp + ~0x100F, 0x0800, eax_57) != 0x00)
		{
			chop(fp + ~0x100F);
			if (is_text(fp + ~0x100F) == 0x00)
				fwrite(&g_v8054B8B, 0x01, 0x04, eax_34);
			else
			{
				sprintf(fp + ~0x080F, "%s <br>\n", 0x00);
				fprintf(eax_34, fp + ~0x080F, 0x00);
			}
		}
		fclose(eax_57);
		fclose(eax_34);
		close(dwLoc101C);
		if ((eax_14 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x16, 0x08054B10);
	}
}

// 0804A6DA: void list_binaries(Register (ptr32 Eq_74) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      query_extension
void list_binaries(struct Eq_74 * gs, char * dwArg04)
{
	word32 eax_12 = gs->dw0014;
	fwrite(&g_v8054B99, 0x01, 0x1A, g_ptr8059260);
	word32 dwLoc081C_165 = 0x00;
	DIR * eax_26 = opendir(dwArg04);
	if (eax_26 == null)
		fwrite(&g_v8054BB4, 0x01, 0x09, g_ptr8059260);
	else
	{
		struct dirent * dwLoc0818_173 = readdir(eax_26);
		while (dwLoc0818_173 != null)
		{
			if (strcmp((char *) dwLoc0818_173 + 11, 0x08054BBE) != 0x00 && (strcmp((char *) dwLoc0818_173 + 11, 0x08054BC0) != 0x00 && strcmp((char *) dwLoc0818_173 + 11, 0x08054BC3) != 0x00))
			{
				sprintf(fp + ~0x080F, "%s/%s", 0x00);
				stat(fp + ~0x080F, fp + ~0x0873);
				if ((dwLoc0864 & 0xF000) == 0x4000)
				{
					if (dwLoc081C_165 == 0x00)
						fprintf(g_ptr8059260, 0x08054AE5, (char *) dwLoc0818_173 + 11);
					else
						fprintf(g_ptr8059260, 0x08054BC7, (char *) dwLoc0818_173 + 11);
					++dwLoc081C_165;
				}
			}
			dwLoc0818_173 = readdir(eax_26);
		}
		if (dwLoc081C_165 == 0x00)
			fwrite(&g_v8054BCC, 0x01, 0x07, g_ptr8059260);
		fwrite(&g_v8054BD4, 0x01, 0x02, g_ptr8059260);
	}
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804A92C: Register word32 binaries_exist(Register (ptr32 Eq_74) gs, Stack (ptr32 char) dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      main
word32 binaries_exist(struct Eq_74 * gs, char * dwArg04, Eq_102 dwArg08)
{
	word32 eax_153;
	word32 eax_14 = gs->dw0014;
	DIR * eax_19 = opendir(dwArg04);
	if (eax_19 == null)
		eax_153 = 0x00;
	else
	{
		struct dirent * dwLoc0818_120 = readdir(eax_19);
		while (dwLoc0818_120 != null)
		{
			if (strcmp((char *) dwLoc0818_120 + 11, 0x08054BBE) != 0x00 && (strcmp((char *) dwLoc0818_120 + 11, 0x08054BC0) != 0x00 && strcmp((char *) dwLoc0818_120 + 11, 0x08054BC3) != 0x00))
			{
				sprintf(fp + ~0x080F, "%s/%s", 0x00);
				stat(fp + ~0x080F, fp + ~0x086F);
				if ((dwLoc0860 & 0xF000) == 0x4000 && strcmp((char *) dwLoc0818_120 + 11, dwArg08) == 0x00)
				{
					eax_153 = 0x01;
					goto l0804AA95;
				}
			}
			dwLoc0818_120 = readdir(eax_19);
		}
		eax_153 = 0x00;
	}
l0804AA95:
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return eax_153;
	__stack_chk_fail();
}

// 0804AAA8: Register word32 check_filetype(Stack Eq_102 dwArg04)
// Called from:
//      unpack_extension
word32 check_filetype(Eq_102 dwArg04)
{
	word32 eax_51;
	if (strstr(dwArg04, 0x08054BD7) != null)
		eax_51 = 0x01;
	else if (strstr(dwArg04, 134564831) != null)
		eax_51 = 0x01;
	else if (strstr(dwArg04, 0x08054BE4) != null)
		eax_51 = 0x02;
	else if (strstr(dwArg04, 134564845) != null)
		eax_51 = 0x02;
	else if (strstr(dwArg04, 0x08054BF2) != null)
		eax_51 = 0x03;
	else if (strstr(dwArg04, 134564855) != null)
		eax_51 = 0x04;
	else
		eax_51 = 0x00;
	return eax_51;
}

// 0804AB6C: void wget_extension(Register (ptr32 Eq_74) gs, Stack ptr32 dwArg04)
// Called from:
//      main
void wget_extension(struct Eq_74 * gs, ptr32 dwArg04)
{
	word32 eax_12 = gs->dw0014;
	fwrite(&g_v8054BFC, 0x01, 0x0E, g_ptr8059260);
	if (g_dw80632A0 != 0x00)
		sprintf(fp + ~0x080F, "wget -N %s", 0x00);
	else
		sprintf(fp + ~0x080F, "wget -N -q %s", 0x00);
	int32 eax_47;
	system();
	if (eax_47 != ~0x00)
	{
		if (eax_47 <= 0x00)
		{
			print_done();
			if ((eax_12 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
			print_error(gs, ~0x13, 0x08054C62);
	}
	else
		print_error(gs, ~0x13, 0x08054C24);
}

// 0804AC6E: void su(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      source_install
//      bin_install
//      uninstall
//      restore
void su(struct Eq_74 * gs, Eq_102 dwArg04, ptr32 dwArg08)
{
	word32 eax_14 = gs->dw0014;
	g_t805928C = g_t805928C *s 1103515245 + 0xD431;
	g_t805928C = g_t805928C >> 0x10 & 0x7FFF;
	srand(g_t805928C);
	rand();
	sprintf(fp + ~0x080F, "%s/gem.test.%i", 0x00);
	FILE * eax_40 = fopen(fp + ~0x080F, "w+");
	if (*__errno_location() != 0x0D)
	{
		remove();
		fclose(eax_40);
		word32 eax_56;
		system();
		if (eax_56 == 0x00)
		{
			if ((eax_14 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
			print_error(gs, ~0x08, 134565105);
	}
	else
		print_error(gs, ~0x04, 0x08054C88);
}

// 0804AD9B: Register word32 vercmp(Stack int32 dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18)
// Called from:
//      register_extension
//      check_dependencies
word32 vercmp(int32 dwArg04, int32 dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18)
{
	word32 eax_37;
	if (dwArg04 == dwArg10 && (dwArg08 == dwArg14 && dwArg0C == dwArg18))
		eax_37 = 0x00;
	else if (dwArg10 > dwArg04)
		eax_37 = ~0x00;
	else if (dwArg10 < dwArg04)
		eax_37 = 0x01;
	else if (dwArg14 > dwArg08)
		eax_37 = ~0x00;
	else if (dwArg14 < dwArg08)
		eax_37 = 0x01;
	else if (dwArg18 > dwArg0C)
		eax_37 = ~0x00;
	else if (dwArg18 < dwArg0C)
		eax_37 = 0x01;
	else
		eax_37 = 0x00;
	return eax_37;
}

// 0804AE20: void depstr(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      register_extension
void depstr(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08)
{
	word32 eax_14 = gs->dw0014;
	memcpy(fp + ~0x080F, &g_v8054D08, 11);
	FILE * eax_27 = fopen(fp + ~0x080F, "r");
	if (eax_27 == null)
	{
		if (*__errno_location() != 0x02)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x10, 134565142);
		}
	}
	else
	{
		word32 dwLoc1818_144 = 0x01;
		char * eax_46 = malloc(0x0800);
		while (nc_fgets_nb(fp + ~0x100F, 0x0800, eax_27) != 0x00)
		{
			if ((byte) (word32) bLoc1010 != 0x00)
			{
				int32 eax_79;
				__isoc99_sscanf();
				if (eax_79 > 0x00 && strcmp(0x08054D35, fp + ~0x180F) != 0x00)
				{
					if (dwLoc1818_144 != 0x00)
					{
						strcat(eax_46, 0x08054D3B);
						strcat(eax_46, fp + ~0x180F);
						dwLoc1818_144 = 0x00;
					}
					else
					{
						strcat(eax_46, 0x08054D3D);
						strcat(eax_46, fp + ~0x180F);
					}
				}
			}
		}
		fclose(eax_27);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B014: void register_extension(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_extension(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18)
{
	word32 eax_19 = gs->dw0014;
	sprintf(fp + ~0x080F, "%s/etc/extensions.db", 0x00);
	word32 dwLoc281C_401 = 0x01;
	FILE * eax_34 = fopen(fp + ~0x080F, "r");
	if (eax_34 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_34);
			strerror(*__errno_location());
			print_error(gs, ~0x0E, 134565142);
		}
		dwLoc281C_401 = 0x00;
	}
	if (dwLoc281C_401 != 0x00)
	{
		word32 ecx_71;
		mkstemp();
		FILE * eax_77 = fopen(&g_b8063AC0, "w+");
		if (eax_77 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x0E, 0x08054D78);
		}
		atexit(&g_t8048FC2);
		dwLoc2814 = 0x00;
		word32 dwLoc2820_428 = 0x01;
		word32 dwLoc2828_429 = 0x00;
		while (nc_fgets_nb(fp + ~0x100F, 0x0800, eax_34) != 0x00)
		{
			word32 v12_115 = dwLoc2814 + 0x01;
			__isoc99_sscanf();
			dwLoc2814 = v12_115;
			word32 dwLoc2824_436 = 0x01;
			if (strcmp(fp + ~0x180F, dwArg0C) == 0x00)
			{
				int32 eax_163 = vercmp(dwLoc2834, dwLoc2838, dwLoc283C, dwArg10, dwArg14, dwArg18);
				dwLoc2828_429 = 0x01;
				if (g_dw80682C8 == 0x00)
				{
					if (eax_163 >= 0x00)
						print_error(gs, ~0x0F, 0x08054E98);
					else
						print_error(gs, ~0x0F, 0x08054E0C);
				}
				if (g_dw80682C8 != 0x00)
				{
					if (eax_163 == 0x00)
						dwLoc2820_428 = 0x00;
					else
					{
						dwLoc2820_428 = 0x01;
						dwLoc2824_436 = 0x00;
					}
				}
			}
			if (dwLoc2824_436 != 0x00)
			{
				fprintf(eax_77, fp + ~0x100F, 0x00);
				fflush(eax_77);
			}
		}
		if (dwLoc2820_428 != 0x00)
		{
			if (dwLoc2828_429 == 0x00)
			{
				depstr(gs, dwArg0C, dwArg04);
				strcpy(fp + ~0x280F, dwArg0C);
				fprintf(eax_77, 134565676, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg08, fp + ~0x280F);
			}
			else
			{
				depstr(gs, dwArg0C, dwArg04);
				strcpy(fp + ~0x280F, dwArg0C);
				fprintf(eax_77, 134565676, fp + ~0x180F, dwArg10, dwArg14, dwArg18, fp + ~0x200F, fp + ~0x280F);
			}
		}
		fclose(eax_77);
		fclose(eax_34);
	}
	if (dwLoc2814 == 0x00 || dwLoc281C_401 == 0x00)
	{
		word32 ecx_316;
		mkstemp();
		FILE * eax_322 = fopen(&g_b8063AC0, "w+");
		if (eax_322 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x0E, 0x08054F40);
		}
		atexit(&g_t8048FC2);
		depstr(gs, dwArg0C, dwArg04);
		strcpy(fp + ~0x280F, dwArg0C);
		fprintf(eax_322, 134565676, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg08, fp + ~0x280F);
		fclose(eax_322);
	}
	if ((eax_19 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B5E3: void deregister_extension(Register (ptr32 Eq_74) gs, Stack ptr32 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C)
// Called from:
//      uninstall
void deregister_extension(struct Eq_74 * gs, ptr32 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C)
{
	word32 eax_16 = gs->dw0014;
	sprintf(fp + ~0x080F, "%s/etc/extensions.db", 0x00);
	word32 dwLoc2818_248 = 0x00;
	FILE * eax_31 = fopen(fp + ~0x080F, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() == 0x02 && g_dw80682C8 == 0x00)
		{
			fclose(eax_31);
			print_error(gs, ~0x12, 0x08054FBC);
		}
		if (g_dw80682C8 == 0x00)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x12, 134565142);
		}
	}
	else
		dwLoc2818_248 = 0x01;
	if (dwLoc2818_248 != 0x00)
	{
		word32 ecx_86;
		mkstemp();
		FILE * eax_92 = fopen(&g_b8063AC0, "w+");
		dwLoc2824 = eax_92;
		if (eax_92 == null && g_dw80682C8 == 0x00)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x12, 134565868);
		}
		atexit(&g_t8048FC2);
		dwLoc2818_248 = 0x01;
	}
	if (dwLoc2818_248 != 0x00)
	{
		word32 dwLoc2828_275 = 0x00;
		while (nc_fgets_nb(fp + ~0x100F, 0x0800, eax_31) != 0x00)
		{
			int32 eax_158;
			__isoc99_sscanf();
			if (eax_158 <= 0x00)
				continue;
			word32 dwLoc281C_292 = 0x01;
			if (strcmp(dwArg08, fp + ~0x180F) == 0x00)
			{
				dwLoc281C_292 = 0x00;
				dwLoc2828_275 = 0x01;
			}
			if (dwLoc281C_292 == 0x00)
				continue;
			if (strstr(fp + ~0x280F, dwArg08) != null && g_dw80682C8 == 0x00)
				print_error(gs, ~0x12, 0x0805506C);
			fprintf(dwLoc2824, fp + ~0x100F, 0x00);
		}
		if (dwLoc2828_275 == 0x00)
			print_error(gs, ~0x12, 0x080550A4);
		fclose(eax_31);
		fclose(dwLoc2824);
	}
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B961: void check_dependencies(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C)
// Called from:
//      source_install
//      bin_install
//      test_install
void check_dependencies(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C)
{
	word32 eax_25 = gs->dw0014;
	if (g_dw80682C8 == 0x00)
	{
		FILE * eax_36 = fopen("../depends", "r");
		if (eax_36 != null)
		{
			sprintf(fp + ~0x081F, "%s/etc/extensions.db", 0x00);
			word32 dwLoc2828_354 = 0x01;
			FILE * eax_68 = fopen(fp + ~0x081F, "r");
			if (eax_68 == null)
			{
				if (*__errno_location() != 0x02)
				{
					fclose(eax_68);
					strerror(*__errno_location());
					print_error(gs, ~0x10, 134565142);
				}
				dwLoc2828_354 = 0x00;
			}
			do
			{
				if (nc_fgets_nb(fp + ~0x101F, 0x0800, eax_36) == 0x00)
				{
					if (dwLoc2828_354 != 0x00)
						fclose(eax_68);
					fclose(eax_36);
					goto l0804BE67;
				}
				int32 eax_131;
				__isoc99_sscanf();
				if (eax_131 <= 0x00)
					continue;
				if (strcmp(fp + ~0x281F, 0x08054D35) != 0x00)
				{
					if (dwLoc2828_354 == 0x00)
						continue;
					word32 edx_151;
					word32 ecx_152;
					rewind();
					word32 dwLoc282C_392 = 0x00;
					while (nc_fgets_nb(fp + ~0x181F, 0x0800, eax_68) != 0x00)
					{
						int32 eax_191;
						__isoc99_sscanf();
						if (eax_191 <= 0x00 || strcmp(fp + ~0x201F, fp + ~0x281F) != 0x00)
							continue;
						if (vercmp(0x00, 0x00, 0x00, 0x00, 0x00, 0x00) < 0x00)
							print_error(gs, ~0x11, 0x0805514C);
						dwLoc282C_392 = 0x01;
					}
					if (dwLoc282C_392 != 0x00)
						continue;
					print_error(gs, ~0x11, 0x080551BC);
				}
				__isoc99_sscanf();
			} while (vercmp(0x00, 0x00, 0x00, 0x00, 0x00, 0x00) >= 0x00);
			print_error(gs, ~0x11, 0x08055100);
		}
		if (*__errno_location() != 0x02)
		{
			fclose(eax_36);
			strerror(*__errno_location());
			print_error(gs, ~0x10, 134565142);
		}
		fprintf(g_ptr8059244, 0x080550D5, dwArg04);
	}
l0804BE67:
	if ((eax_25 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804BE84: Register word32 is_submenu(Stack Eq_102 dwArg04)
// Called from:
//      new_submenu
word32 is_submenu(Eq_102 dwArg04)
{
	word32 eax_37;
	if (strchr(dwArg04, '[') == 0x00)
		eax_37 = 0x00;
	else if (strrchr(dwArg04, ']') == 0x00)
		eax_37 = 0x00;
	else if (strchr(dwArg04, '[') > strrchr(dwArg04, ']'))
		eax_37 = 0x00;
	else
		eax_37 = 0x01;
	return eax_37;
}

// 0804BF05: void check_ext_menu(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      register_entries_gisman
//      restore_entries_gisman
void check_ext_menu(struct Eq_74 * gs, Eq_102 dwArg04)
{
	if (find_pos(0x080551E8, dwArg04, 0x00) != ~0x00)
		return;
	int32 eax_27 = find_pos(0x080551FE, dwArg04, 0x00);
	if (eax_27 != ~0x00)
	{
		insert_str(gs, 0x08055232, eax_27, dwArg04);
		insert_str(gs, 0x0805524C, eax_27 + 0x01, dwArg04);
	}
	else
	{
		int32 eax_69 = find_pos(0x08055212, dwArg04, 0x00);
		if (eax_69 != ~0x00)
		{
			insert_str(gs, 0x08055232, eax_69, dwArg04);
			insert_str(gs, 0x0805524C, eax_69 + 0x01, dwArg04);
		}
		else
			print_error(gs, ~0x14, 0x08055215);
	}
}

// 0804C009: Register word32 new_submenu(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C)
// Called from:
//      register_entries_gisman
//      restore_entries_gisman
word32 new_submenu(struct Eq_74 * gs, Eq_102 dwArg08, Eq_102 dwArg0C)
{
	word32 eax_19 = gs->dw0014;
	int32 eax_28 = find_pos(0x08055250, dwArg0C, 0x00);
	int32 eax_42 = find_pos(0x08055264, dwArg0C, eax_28 + 0x01);
	int32 dwLoc1814_332 = eax_28;
	int32 dwLoc1820_336 = eax_42 - 0x01;
	if (eax_42 == 0x00)
		dwLoc1820_336 = find_pos(0x08055212, dwArg0C, 0x00);
	word32 eax_283;
	if (is_submenu(dwArg08) == 0x00)
	{
		print_warning(gs, 134566516);
		eax_283 = ~0x00;
	}
	else
	{
		int32 edx_86 = strrchr(dwArg08, ']') - strchr(dwArg08, '[');
		strncpy(fp->aFFFFF7F0, (word32) strchr(dwArg08, '[') + 1, edx_86);
		fp->aFFFFF7F0[edx_86 - 0x01] = 0x00;
		sprintf((char *) fp - 6160, "{cascad \"%s\"", 0x00);
		int32 eax_117 = find_pos((char *) fp - 6160, dwArg0C, eax_28);
		if (eax_117 != ~0x00 && eax_117 < dwLoc1820_336)
		{
			print_warning(gs, 0x080552BC);
			eax_283 = ~0x00;
		}
		else
		{
			int32 dwLoc181C_367 = eax_28 + 0x01;
			int32 dwLoc1818_372 = find_pos(0x080552ED, dwArg0C, eax_28);
			while (dwLoc1818_372 != ~0x00 && dwLoc1818_372 < dwLoc1820_336)
			{
				Eq_102 eax_162 = strchr(*((word32) dwArg0C + dwLoc1818_372 * 0x04), '"');
				int32 ecx_173 = strchr((word32) eax_162 + 1, '"') - eax_162;
				strncpy(fp->aFFFFEFF0, (word32) eax_162 + 1, ecx_173);
				fp->aFFFFEFF0[ecx_173 - 0x01] = 0x00;
				if (strcmp(fp->aFFFFF7F0, fp->aFFFFEFF0) < 0x00)
				{
					dwLoc181C_367 = dwLoc1818_372;
					break;
				}
				int32 v15_195 = dwLoc1814_332 + 0x01;
				dwLoc1814_332 = v15_195;
				dwLoc1818_372 = find_pos(0x080552ED, dwArg0C, v15_195);
			}
			sprintf(fp->aFFFFF7F0, " \t\t\t%s {} \"\" 1 {\n", 0x00);
			insert_str(gs, fp->aFFFFF7F0, dwLoc181C_367, dwArg0C);
			insert_str(gs, 0x08055308, dwLoc181C_367 + 0x01, dwArg0C);
			int32 eax_253 = find_pos(0x08055212, dwArg0C, 0x00);
			sprintf(fp->aFFFFF7F0, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", 0x00);
			insert_str(gs, fp->aFFFFF7F0, eax_253 + 0x01, dwArg0C);
			eax_283 = dwLoc181C_367 + 0x01;
		}
	}
	if ((eax_19 ^ gs->dw0014) == 0x00)
		return eax_283;
	__stack_chk_fail();
}

// 0804C41B: Register word32 new_item(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg0C, Stack int32 dwArg10)
// Called from:
//      register_entries_gisman
//      restore_entries_gisman
word32 new_item(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg0C, int32 dwArg10)
{
	word32 eax_122;
	word32 eax_16 = gs->dw0014;
	chop(dwArg04);
	Eq_102 eax_33 = strtok(dwArg04, ";");
	Eq_102 dwLoc1814_166 = eax_33;
	if (eax_33 == 0x00)
	{
		print_warning(gs, 0x08055344);
		eax_122 = ~0x00;
	}
	else
	{
		strcpy(fp + ~0x080F, eax_33);
		int32 dwLoc1818_169 = 0x00;
		while (dwLoc1814_166 != 0x00)
		{
			Eq_102 eax_51 = strtok(0x00, ";");
			dwLoc1814_166 = eax_51;
			if (eax_51 != 0x00)
				strcpy(fp + ~0x100F, eax_51);
			++dwLoc1818_169;
		}
		if (dwLoc1818_169 > 0x02)
		{
			print_warning(gs, 0x08055368);
			eax_122 = ~0x00;
		}
		else
		{
			if (strcmp(fp + ~0x080F, 0x0805539C) == 0x00 && strcmp(fp + ~0x080F, 0x0805539C) == 0x00)
				memcpy(fp + ~0x180F, &g_v805539E, 0x12);
			else
				sprintf(fp + ~0x180F, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", 0x00);
			insert_str(gs, fp + ~0x180F, dwArg10, dwArg0C);
			eax_122 = dwArg10 + 0x01;
		}
	}
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return eax_122;
	__stack_chk_fail();
}

// 0804C5F0: void register_entries_gisman(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_entries_gisman(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08)
{
	word32 eax_17 = gs->dw0014;
	memcpy(fp->aFFFFE7F0 + 0x00001000, &g_v80553DF, 0x12);
	FILE * eax_30 = fopen(fp->aFFFFE7F0 + 0x00001000, "r");
	if (eax_30 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_30);
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x080553F3);
		}
	}
	else
	{
		sprintf(fp->aFFFFE7F0 + 0x00001000, "%s/etc/dm/menu.tcl", 0x00);
		FILE * eax_61 = fopen(fp->aFFFFE7F0 + 0x00001000, "r");
		if (eax_61 == null)
		{
			if (*__errno_location() != 0x02)
			{
				fclose(eax_61);
				strerror(*__errno_location());
				print_error(gs, ~0x14, 0x080553F3);
			}
		}
		else
		{
			word32 ecx_553;
			mkstemp();
			FILE * eax_94 = fopen(&g_b80642C0, "w+");
			if (eax_94 == null)
			{
				strerror(*__errno_location());
				print_error(gs, ~0x14, 0x08055448);
			}
			atexit(&g_t8048FC2);
			if (g_dw80632A0 != 0x00)
				sprintf(fp->aFFFFE7F0 + 0x0800, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", 0x00);
			else
				sprintf(fp->aFFFFE7F0 + 0x0800, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", 0x00);
			strcpy(134644448, fp->aFFFFE7F0 + 0x0800);
			ui32 dwLoc181C_585 = 0x00;
			while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_30) != null)
				++dwLoc181C_585;
			if (dwLoc181C_585 != 0x00)
			{
				word32 ecx_597;
				rewind();
				int32 dwLoc1820_598 = 0x00;
				while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_61) != null)
					++dwLoc1820_598;
				if (dwLoc1820_598 != 0x00)
				{
					word32 ecx_609;
					rewind();
					Eq_102 eax_231 = calloc(dwLoc181C_585 * 0x02 + dwLoc1820_598 + 0x06, 0x04);
					int32 dwLoc1824_614;
					for (dwLoc1824_614 = 0x00; dwLoc181C_585 * 0x02 + dwLoc1820_598 + 0x06 > dwLoc1824_614; ++dwLoc1824_614)
						((word32) eax_231 + dwLoc1824_614 * 0x04)->u0 = 0x00;
					ui32 dwLoc1824_620 = 0x00;
					while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_61) != null)
					{
						eax_231[dwLoc1824_620 * 0x04] = malloc(strlen(fp->aFFFFE7F0 + 0x0800) + 0x01);
						strcpy(*((word32) eax_231 + dwLoc1824_620 * 0x04), fp->aFFFFE7F0 + 0x0800);
						++dwLoc1824_620;
					}
					check_ext_menu(gs, eax_231);
					word32 dwLoc1824_633 = 0x01;
					while (nc_fgets_nb(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_30) != 0x00)
					{
						if (dwLoc1824_633 != 0x01)
						{
							int32 eax_323 = new_item(gs, fp->aFFFFE7F0 + 0x0800, eax_231, dwLoc1830);
							dwLoc1830 = eax_323;
							if (eax_323 >= 0x00)
							{
								++dwLoc1824_633;
								continue;
							}
							else
							{
								print_warning(gs, 0x080556B8);
								break;
							}
						}
						int32 edx_353 = strrchr(fp->aFFFFE7F0 + 0x0800, ']') - strchr(fp->aFFFFE7F0 + 0x0800, '[');
						strncpy(fp->aFFFFE7F0, (word32) strchr(fp->aFFFFE7F0 + 0x0800, '[') + 1, edx_353);
						fp->aFFFFE7F0[edx_353 - 0x01] = 0x00;
						int32 eax_377 = new_submenu(gs, fp->aFFFFE7F0 + 0x0800, eax_231);
						dwLoc1830 = eax_377;
						if (eax_377 < 0x00)
						{
							print_warning(gs, 0x08055690);
							break;
						}
						++dwLoc1824_633;
					}
					ui32 dwLoc1824_668 = 0x00;
					while (*((word32) eax_231 + dwLoc1824_668 * 0x04) != 0x00)
					{
						fprintf(eax_94, *((word32) eax_231 + dwLoc1824_668 * 0x04), 0x00);
						++dwLoc1824_668;
					}
					fflush(eax_94);
					word32 ecx_439;
					rewind();
					int32 dwLoc182C_687 = 0x00;
					while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_94) != null)
						++dwLoc182C_687;
					if (dwLoc182C_687 == 0x00 || dwLoc182C_687 < dwLoc1820_598)
					{
						print_warning(gs, 0x080556E4);
						memcpy(&g_b80682E0, &g_v8055722, 0x01);
					}
					fclose(eax_61);
					fclose(eax_30);
					fclose(eax_94);
					int32 dwLoc1824_720;
					for (dwLoc1824_720 = 0x00; dwLoc181C_585 * 0x02 + dwLoc1820_598 + 0x06 > dwLoc1824_720; ++dwLoc1824_720)
						free(*((word32) eax_231 + dwLoc1824_720 * 0x04));
					free(eax_231);
				}
			}
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804CD6C: void register_entries_gisman2(Register (ptr32 Eq_74) gs)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_entries_gisman2(struct Eq_74 * gs)
{
	word32 eax_14 = gs->dw0014;
	memcpy(fp + ~0x080F, &g_v8055723, 0x13);
	FILE * eax_27 = fopen(fp + ~0x080F, "r");
	if (eax_27 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_27);
			strerror(*__errno_location());
			print_error(gs, ~0x1F, 0x080553F3);
		}
	}
	else
	{
		if (g_dw80632A0 != 0x00)
			sprintf(fp + ~0x100F, "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", 0x00);
		else
			sprintf(fp + ~0x100F, "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", 0x00);
		strcpy(0x08068AE0, fp + ~0x100F);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804CEC7: Register word32 deregister_entries_gisman(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      uninstall
word32 deregister_entries_gisman(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08)
{
	word32 eax_575;
	word32 eax_17 = gs->dw0014;
	sprintf(fp->aFFFFE7F0 + 0x00001000, "%s/etc/dm/menu.tcl", 0x00);
	FILE * eax_31 = fopen(fp->aFFFFE7F0 + 0x00001000, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x15, 0x080553F3);
		}
		eax_575 = 0x00;
	}
	else
	{
		word32 ecx_59;
		mkstemp();
		FILE * eax_65 = fopen(&g_b80642C0, "w+");
		if (eax_65 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x08055448);
		}
		atexit(&g_t8048FC2);
		if (g_dw80632A0 != 0x00)
			sprintf(fp->aFFFFE7F0 + 0x0800, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", 0x00);
		else
			sprintf(fp->aFFFFE7F0 + 0x0800, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", 0x00);
		strcpy(134644448, fp->aFFFFE7F0 + 0x0800);
		word32 dwLoc1818_686 = 0x00;
		while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_31) != null)
			++dwLoc1818_686;
		if (dwLoc1818_686 == 0x00)
			eax_575 = ~0x00;
		else
		{
			word32 ecx_152;
			rewind();
			Eq_102 eax_161 = calloc(dwLoc1818_686 + 0x01, 0x04);
			int32 dwLoc181C_702;
			for (dwLoc181C_702 = 0x00; dwLoc1818_686 + 0x01 > dwLoc181C_702; ++dwLoc181C_702)
				((word32) eax_161 + dwLoc181C_702 * 0x04)->u0 = 0x00;
			ui32 dwLoc181C_707 = 0x00;
			while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_31) != null)
			{
				eax_161[dwLoc181C_707 * 0x04] = malloc(strlen(fp->aFFFFE7F0 + 0x0800) + 0x01);
				strcpy(*((word32) eax_161 + dwLoc181C_707 * 0x04), fp->aFFFFE7F0 + 0x0800);
				++dwLoc181C_707;
			}
			sprintf(fp->aFFFFE7F0 + 0x0800, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", 0x00);
			int32 eax_224 = find_pos(fp->aFFFFE7F0 + 0x0800, eax_161, 0x00);
			if (eax_224 == ~0x00)
			{
				print_warning(gs, 0x08055914);
				eax_575 = ~0x00;
			}
			else
			{
				Eq_102 eax_239 = strchr(*((word32) eax_161 + eax_224 * 0x04), '"');
				Eq_102 eax_246 = strchr((word32) eax_239 + 1, '"');
				strcpy(fp->aFFFFE7F0, (word32) eax_239 + 1);
				fp->aFFFFE7F0[eax_246 - ((word32) eax_239 + 1)] = 0x00;
				int32 eax_264 = find_pos(0x080551E8, eax_161, 0x00);
				int32 eax_278 = find_pos(0x08055264, eax_161, eax_264 + 0x01);
				int32 dwLoc1838_748 = eax_278 - 0x01;
				if (eax_278 == 0x00)
					dwLoc1838_748 = find_pos(0x08055212, eax_161, 0x00);
				if (eax_264 == ~0x00)
				{
					print_warning(gs, 0x08055949);
					eax_575 = ~0x00;
				}
				else
				{
					sprintf(fp->aFFFFE7F0 + 0x0800, "{cascad \"%s\"", 0x00);
					int32 eax_317 = find_pos(fp->aFFFFE7F0 + 0x0800, eax_161, eax_264);
					if (eax_317 != ~0x00 && eax_317 <= dwLoc1838_748)
					{
						int32 eax_334 = find_pos(0x0805599A, eax_161, eax_317);
						if (eax_334 != ~0x00 && eax_334 <= dwLoc1838_748)
						{
							word32 dwLoc184C_767 = 0x01;
							int32 dwLoc181C_768;
							for (dwLoc181C_768 = 0x00; eax_334 - eax_317 + 0x01 > dwLoc181C_768; ++dwLoc181C_768)
							{
								delete_str(gs, eax_317, eax_161);
								++dwLoc184C_767;
							}
							sprintf(fp->aFFFFE7F0 + 0x0800, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", 0x00);
							delete_str(gs, find_pos(fp->aFFFFE7F0 + 0x0800, eax_161, 0x00), eax_161);
							int32 eax_411 = find_pos(0x080551E8, eax_161, 0x00);
							int32 eax_425 = find_pos(0x08055264, eax_161, eax_411 + 0x01);
							word32 dwLoc184C_789 = dwLoc184C_767 + 0x00;
							if (eax_425 - 0x01 - eax_411 <= 0x02)
							{
								int32 dwLoc181C_798;
								for (dwLoc181C_798 = 0x00; eax_425 - 0x01 - eax_411 + 0x01 > dwLoc181C_798; ++dwLoc181C_798)
								{
									delete_str(gs, eax_411, eax_161);
									++dwLoc184C_789;
								}
							}
							ui32 dwLoc181C_808 = 0x00;
							while (*((word32) eax_161 + dwLoc181C_808 * 0x04) != 0x00)
							{
								fprintf(eax_65, *((word32) eax_161 + dwLoc181C_808 * 0x04), 0x00);
								++dwLoc181C_808;
							}
							fflush(eax_65);
							word32 ecx_514;
							rewind();
							word32 dwLoc1824_831 = 0x00;
							while (fgets(fp->aFFFFE7F0 + 0x0800, 0x0800, eax_65) != null)
								++dwLoc1824_831;
							if (dwLoc1824_831 == 0x00)
							{
								print_warning(gs, 0x080556E4);
								memcpy(&g_b80682E0, &g_v8055722, 0x01);
							}
							fclose(eax_31);
							fclose(eax_65);
							int32 dwLoc181C_852;
							for (dwLoc181C_852 = 0x00; dwLoc1818_686 + 0x01 > dwLoc181C_852; ++dwLoc181C_852)
								free(*((word32) eax_161 + dwLoc181C_852 * 0x04));
							free(eax_161);
							eax_575 = dwLoc184C_789;
						}
						else
						{
							print_warning(gs, 0x080559A4);
							eax_575 = ~0x00;
						}
					}
					else
					{
						print_warning(gs, 0x08055968);
						eax_575 = ~0x00;
					}
				}
			}
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return eax_575;
	__stack_chk_fail();
}

// 0804D743: void deregister_entries_gisman2(Register (ptr32 Eq_74) gs)
// Called from:
//      uninstall
void deregister_entries_gisman2(struct Eq_74 * gs)
{
	word32 eax_14 = gs->dw0014;
	sprintf(fp + ~0x080F, "%s/etc/gm/Xtns/%s.gem", 0x00);
	FILE * eax_30 = fopen(fp + ~0x080F, "r");
	if (eax_30 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_30);
			strerror(*__errno_location());
			print_error(gs, ~0x20, 0x080553F3);
		}
	}
	else
	{
		if (g_dw80632A0 != 0x00)
			sprintf(fp + ~0x100F, "rm -vf %s/etc/gm/Xtns/%s.gem ; ", 0x00);
		else
			sprintf(fp + ~0x100F, "rm -f %s/etc/gm/Xtns/%s.gem ; ", 0x00);
		strcpy(134644448, fp + ~0x100F);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804D896: Register word32 restore_entries_gisman(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      restore
word32 restore_entries_gisman(struct Eq_74 * gs, Eq_102 dwArg04)
{
	word32 eax_541;
	word32 eax_15 = gs->dw0014;
	sprintf((char *) fp - 6160, "%s/etc/dm/menu.tcl", 0x00);
	FILE * eax_29 = fopen((char *) fp - 6160, "r");
	if (eax_29 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_29);
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x080553F3);
		}
		eax_541 = 0x00;
	}
	else
	{
		word32 ecx_57;
		mkstemp();
		FILE * eax_63 = fopen(&g_b80642C0, "w+");
		if (eax_63 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x08055448);
		}
		atexit(&g_t8048FC2);
		if (g_dw80632A0 != 0x00)
			sprintf(fp->aFFFFEFF0 + 0x0800, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", 0x00);
		else
			sprintf(fp->aFFFFEFF0 + 0x0800, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", 0x00);
		strcpy(134644448, fp->aFFFFEFF0 + 0x0800);
		sprintf((char *) fp - 8208, "%s/etc/dm/gem-entries", 0x00);
		DIR * eax_131 = opendir((char *) fp - 8208);
		if (eax_131 == null)
			eax_541 = 0x00;
		else
		{
			ui32 dwLoc281C_609 = 0x00;
			ui32 dwLoc2844_610 = 0x00;
			while (true)
			{
				struct dirent * eax_142 = readdir(eax_131);
				if (eax_142 == null)
					break;
				sprintf((char *) fp - 6160, "%s/%s", 0x00);
				FILE * eax_160 = fopen((char *) fp - 6160, "r");
				if (strcmp((char *) eax_142 + 11, 0x08055A4F) != 0x00 && strcmp((char *) eax_142 + 11, 0x08055A51) != 0x00)
				{
					if (eax_160 == null)
						fclose(eax_160);
					else
					{
						while (fgets(fp->aFFFFEFF0 + 0x0800, 0x0800, eax_160) != null)
							++dwLoc281C_609;
						fclose(eax_160);
						++dwLoc2844_610;
					}
				}
				else
					fclose(eax_160);
			}
			closedir(eax_131);
			word32 dwLoc2820_639 = 0x00;
			while (fgets(fp->aFFFFEFF0 + 0x0800, 0x0800, eax_29) != null)
				++dwLoc2820_639;
			if (dwLoc2820_639 == 0x00)
				eax_541 = 0x00;
			else
			{
				rewind();
				ui32 ecx_253 = dwLoc281C_609 * 0x02;
				Eq_102 eax_264 = calloc(dwLoc281C_609 * 0x02 + dwLoc2844_610 * 0x05 + dwLoc2820_639 + 0x01, 0x04);
				int32 dwLoc2824_659;
				for (dwLoc2824_659 = 0x00; dwLoc281C_609 * 0x02 + dwLoc2844_610 * 0x05 + dwLoc2820_639 + 0x01 > dwLoc2824_659; ++dwLoc2824_659)
					((word32) eax_264 + dwLoc2824_659 * 0x04)->u0 = 0x00;
				ui32 dwLoc2824_666 = 0x00;
				while (fgets(fp->aFFFFEFF0 + 0x0800, 0x0800, eax_29) != null)
				{
					eax_264[dwLoc2824_666 * 0x04] = malloc(strlen(fp->aFFFFEFF0 + 0x0800) + 0x01);
					strcpy(*((word32) eax_264 + dwLoc2824_666 * 0x04), fp->aFFFFEFF0 + 0x0800);
					++dwLoc2824_666;
				}
				((word32) eax_264 + dwLoc2824_666 * 0x04)->u0 = 0x00;
				check_ext_menu(gs, eax_264);
				DIR * eax_339 = opendir((char *) fp - 8208);
				word32 dwLoc2840_681 = 0x00;
				while (true)
				{
					struct dirent * eax_347 = readdir(eax_339);
					if (eax_347 == null)
						break;
					sprintf((char *) fp - 6160, "%s/%s", 0x00);
					if (strcmp((char *) eax_347 + 11, 0x08055A4F) != 0x00 && strcmp((char *) eax_347 + 11, 0x08055A51) != 0x00)
					{
						FILE * eax_381 = fopen((char *) fp - 6160, "r");
						if (eax_381 != null)
						{
							word32 dwLoc2824_696 = 0x01;
							while (nc_fgets_nb(fp->aFFFFEFF0 + 0x0800, 0x0800, eax_381) != 0x00)
							{
								if (dwLoc2824_696 != 0x01)
								{
									int32 eax_414 = new_item(gs, fp->aFFFFEFF0 + 0x0800, eax_264, dwLoc2828);
									dwLoc2828 = eax_414;
									if (eax_414 < 0x00)
										break;
									++dwLoc2824_696;
									++dwLoc2840_681;
									continue;
								}
								int32 edx_438 = strrchr(fp->aFFFFEFF0 + 0x0800, ']') - strchr(fp->aFFFFEFF0 + 0x0800, '[');
								strncpy(fp->aFFFFEFF0, (word32) strchr(fp->aFFFFEFF0 + 0x0800, '[') + 1, edx_438);
								fp->aFFFFEFF0[edx_438 - 0x01] = 0x00;
								int32 eax_462 = new_submenu(gs, fp->aFFFFEFF0 + 0x0800, eax_264);
								dwLoc2828 = eax_462;
								if (eax_462 < 0x00)
									break;
								++dwLoc2824_696;
								++dwLoc2840_681;
							}
							fclose(eax_381);
						}
					}
				}
				closedir(eax_339);
				ui32 dwLoc2824_734 = 0x00;
				while (*((word32) eax_264 + dwLoc2824_734 * 0x04) != 0x00)
				{
					fprintf(eax_63, *((word32) eax_264 + dwLoc2824_734 * 0x04), 0x00);
					++dwLoc2824_734;
				}
				fflush(eax_63);
				fclose(eax_29);
				fclose(eax_63);
				int32 dwLoc2824_748;
				for (dwLoc2824_748 = 0x00; dwLoc281C_609 * 0x02 + dwLoc2844_610 * 0x05 + dwLoc2820_639 + 0x01 > dwLoc2824_748; ++dwLoc2824_748)
					free(*((word32) eax_264 + dwLoc2824_748 * 0x04));
				free(eax_264);
				eax_541 = dwLoc2840_681;
			}
		}
	}
	if ((eax_15 ^ gs->dw0014) == 0x00)
		return eax_541;
	__stack_chk_fail();
}

// 0804E100: void new_ext_html(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg0C)
// Called from:
//      register_html
//      restore_html
void new_ext_html(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg0C)
{
	word32 eax_16 = gs->dw0014;
	int32 eax_25 = find_pos(0x08055A54, dwArg0C, 0x00);
	int32 dwLoc0814_359 = eax_25;
	if (eax_25 < 0x00)
	{
		int32 eax_38 = find_pos(0x08055A70, dwArg0C, 0x00);
		dwLoc0814_359 = eax_38;
		if (eax_38 < 0x00)
		{
			print_warning(gs, 134568636);
			goto l0804E55C;
		}
	}
	int32 eax_55 = find_pos(0x08055AFE, dwArg0C, dwLoc0814_359);
	if (find_pos(0x08055B04, dwArg0C, dwLoc0814_359) == ~0x00)
	{
		insert_str(gs, 0x08055B24, eax_55, dwArg0C);
		insert_str(gs, 0x08055B44, eax_55 + 0x01, dwArg0C);
		insert_str(gs, 0x08055B4A, eax_55 + 0x02, dwArg0C);
		insert_str(gs, 0x08055B51, eax_55 + 0x03, dwArg0C);
	}
	int32 eax_131 = find_pos(0x08055B04, dwArg0C, dwLoc0814_359);
	int32 eax_143 = find_pos(0x08055B56, dwArg0C, eax_131);
	sprintf(fp->aFFFFF7F0, "\">%s", 0x00);
	int32 dwLoc0820_390 = eax_131;
	int32 dwLoc0828_395 = eax_131 + 0x02;
	int32 eax_167 = find_pos(fp->aFFFFF7F0, dwArg0C, eax_131 + 0x02);
	if (eax_167 != ~0x00)
	{
		print_warning(gs, 0x08055B64);
		if (g_dw80682C8 != 0x00 && g_dw80682CC != 0x00)
		{
			sprintf(fp->aFFFFF7F0, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", 0x00);
			strcpy(*((word32) dwArg0C + eax_167 * 0x04), fp->aFFFFF7F0);
		}
	}
	else
	{
		int32 dwLoc081C_408 = find_pos(0x08055BC9, dwArg0C, eax_131);
		while (dwLoc081C_408 != ~0x00 && dwLoc081C_408 < eax_143)
		{
			Eq_102 eax_202 = strrchr(*((word32) dwArg0C + dwLoc081C_408 * 0x04), '"');
			int32 ecx_215 = strrchr(*((word32) dwArg0C + dwLoc081C_408 * 0x04), '<') - eax_202;
			strncpy(fp->aFFFFF7F0, (word32) eax_202 + 2, ecx_215);
			fp->aFFFFF7F0[ecx_215 - 0x01] = 0x00;
			if (strcmp(dwArg04, fp->aFFFFF7F0) < 0x00)
			{
				dwLoc0828_395 = dwLoc081C_408;
				break;
			}
			int32 v14_237 = dwLoc0820_390 + 0x01;
			dwLoc0820_390 = v14_237;
			dwLoc081C_408 = find_pos(0x08055BC9, dwArg0C, v14_237);
		}
		sprintf(fp->aFFFFF7F0, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", 0x00);
		insert_str(gs, fp->aFFFFF7F0, dwLoc0828_395, dwArg0C);
	}
l0804E55C:
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804E56F: void delete_ext_html(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg0C)
// Called from:
//      deregister_html
void delete_ext_html(struct Eq_74 * gs, Eq_102 dwArg0C)
{
	word32 eax_16 = gs->dw0014;
	int32 eax_25 = find_pos(0x08055A54, dwArg0C, 0x00);
	int32 dwLoc0814_236 = eax_25;
	if (eax_25 < 0x00)
	{
		int32 eax_38 = find_pos(0x08055A70, dwArg0C, 0x00);
		dwLoc0814_236 = eax_38;
		if (eax_38 < 0x00)
		{
			print_warning(gs, 0x08055BD8);
			goto l0804E7E0;
		}
	}
	find_pos(0x08055AFE, dwArg0C, dwLoc0814_236);
	if (find_pos(0x08055B04, dwArg0C, dwLoc0814_236) == ~0x00)
		print_warning(gs, 0x08055C20);
	else
	{
		int32 eax_80 = find_pos(0x08055B04, dwArg0C, dwLoc0814_236);
		int32 eax_92 = find_pos(0x08055B56, dwArg0C, eax_80);
		sprintf(fp + ~0x080F, "\">%s", 0x00);
		int32 eax_113 = find_pos(fp + ~0x080F, dwArg0C, eax_80);
		if (eax_113 == ~0x00)
			print_warning(gs, 0x08055C4C);
		else
		{
			if (eax_113 < eax_92)
				delete_str(gs, eax_113, dwArg0C);
			int32 eax_147 = find_pos(0x08055C76, dwArg0C, eax_80);
			if (eax_147 != ~0x00 && (eax_92 - 0x01 > eax_147 && (eax_92 - 0x01) - eax_147 <= 0x01))
			{
				int32 dwLoc082C_277;
				for (dwLoc082C_277 = 0x00; dwLoc082C_277 <= 0x03; ++dwLoc082C_277)
					delete_str(gs, eax_147 - 0x01, dwArg0C);
			}
		}
	}
l0804E7E0:
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804E7F3: void register_html(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_html(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14)
{
	word32 eax_17 = gs->dw0014;
	sprintf(fp + ~0x080F, "%s/docs/html/index.html", 0x00);
	FILE * eax_31 = fopen(fp + ~0x080F, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055C95);
		}
	}
	else
	{
		mkstemp();
		FILE * eax_64 = fopen(&g_b8067AC0, "w+");
		if (eax_64 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055CD8);
		}
		atexit(&g_t8048FC2);
		if (g_dw80632A0 != 0x00)
			sprintf(fp + ~0x100F, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", 0x00);
		else
			sprintf(fp + ~0x100F, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", 0x00);
		strcpy(0x080692E0, fp + ~0x100F);
		word32 dwLoc1018_321 = 0x00;
		while (fgets(fp + ~0x100F, 0x0800, eax_31) != null)
			++dwLoc1018_321;
		if (dwLoc1018_321 != 0x00)
		{
			rewind();
			Eq_102 eax_148 = calloc(dwLoc1018_321 + 0x0A, 0x04);
			int32 dwLoc101C_336;
			for (dwLoc101C_336 = 0x00; dwLoc1018_321 + 0x0A > dwLoc101C_336; ++dwLoc101C_336)
				((word32) eax_148 + dwLoc101C_336 * 0x04)->u0 = 0x00;
			ui32 dwLoc101C_341 = 0x00;
			while (fgets(fp + ~0x100F, 0x0800, eax_31) != null)
			{
				eax_148[dwLoc101C_341 * 0x04] = malloc(strlen(fp + ~0x100F) + 0x01);
				strcpy(*((word32) eax_148 + dwLoc101C_341 * 0x04), fp + ~0x100F);
				++dwLoc101C_341;
			}
			new_ext_html(gs, dwArg04, eax_148);
			ui32 dwLoc101C_382 = 0x00;
			while (*((word32) eax_148 + dwLoc101C_382 * 0x04) != 0x00)
			{
				fprintf(eax_64, *((word32) eax_148 + dwLoc101C_382 * 0x04), 0x00);
				++dwLoc101C_382;
			}
			fflush(eax_64);
			fclose(eax_31);
			fclose(eax_64);
			int32 dwLoc101C_393;
			for (dwLoc101C_393 = 0x00; dwLoc1018_321 + 0x0A > dwLoc101C_393; ++dwLoc101C_393)
				free(*((word32) eax_148 + dwLoc101C_393 * 0x04));
			free(eax_148);
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804EC17: void deregister_html(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      uninstall
void deregister_html(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08)
{
	word32 eax_17 = gs->dw0014;
	sprintf(fp + ~0x080F, "%s/docs/html/index.html", 0x00);
	FILE * eax_31 = fopen(fp + ~0x080F, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055C95);
		}
	}
	else
	{
		mkstemp();
		FILE * eax_64 = fopen(&g_b8067AC0, "w+");
		if (eax_64 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055CD8);
		}
		atexit(&g_t8048FC2);
		if (g_dw80632A0 != 0x00)
			sprintf(fp + ~0x100F, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", 0x00);
		else
			sprintf(fp + ~0x100F, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", 0x00);
		strcpy(0x080692E0, fp + ~0x100F);
		word32 dwLoc1018_315 = 0x00;
		while (fgets(fp + ~0x100F, 0x0800, eax_31) != null)
			++dwLoc1018_315;
		if (dwLoc1018_315 != 0x00)
		{
			rewind();
			Eq_102 eax_148 = calloc(dwLoc1018_315 + 0x01, 0x04);
			int32 dwLoc101C_330;
			for (dwLoc101C_330 = 0x00; dwLoc1018_315 + 0x01 > dwLoc101C_330; ++dwLoc101C_330)
				((word32) eax_148 + dwLoc101C_330 * 0x04)->u0 = 0x00;
			ui32 dwLoc101C_335 = 0x00;
			while (fgets(fp + ~0x100F, 0x0800, eax_31) != null)
			{
				eax_148[dwLoc101C_335 * 0x04] = malloc(strlen(fp + ~0x100F) + 0x01);
				strcpy(*((word32) eax_148 + dwLoc101C_335 * 0x04), fp + ~0x100F);
				++dwLoc101C_335;
			}
			delete_ext_html(gs, eax_148);
			ui32 dwLoc101C_358 = 0x00;
			while (*((word32) eax_148 + dwLoc101C_358 * 0x04) != 0x00)
			{
				fprintf(eax_64, *((word32) eax_148 + dwLoc101C_358 * 0x04), 0x00);
				++dwLoc101C_358;
			}
			fflush(eax_64);
			fclose(eax_31);
			fclose(eax_64);
			int32 dwLoc101C_369;
			for (dwLoc101C_369 = 0x00; dwLoc1018_315 + 0x01 > dwLoc101C_369; ++dwLoc101C_369)
				free(*((word32) eax_148 + dwLoc101C_369 * 0x04));
			free(eax_148);
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804F026: Register word32 restore_html(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      restore
word32 restore_html(struct Eq_74 * gs, Eq_102 dwArg04)
{
	word32 eax_473;
	word32 eax_15 = gs->dw0014;
	sprintf(fp + ~0x100F, "%s/docs/html/index.html", 0x00);
	FILE * eax_29 = fopen(fp + ~0x100F, "r");
	if (eax_29 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_29);
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055C95);
		}
		eax_473 = 0x00;
	}
	else
	{
		word32 ecx_57;
		mkstemp();
		FILE * eax_63 = fopen(&g_b8067AC0, "w+");
		if (eax_63 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055CD8);
		}
		if (g_dw80632A0 != 0x00)
			sprintf(fp + ~0x080F, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", 0x00);
		else
			sprintf(fp + ~0x080F, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", 0x00);
		strcpy(0x080692E0, fp + ~0x080F);
		atexit(&g_t8048FC2);
		sprintf(fp + ~0x200F, "%s/docs/extensions", 0x00);
		DIR * eax_122 = opendir(fp + ~0x200F);
		if (eax_122 == null)
			eax_473 = 0x00;
		else
		{
			word32 dwLoc2840_539 = 0x00;
			while (true)
			{
				struct dirent * eax_133 = readdir(eax_122);
				if (eax_133 == null)
					break;
				sprintf(fp + ~0x280F, "%s/%s", 0x00);
				if (strcmp((char *) eax_133 + 11, 0x08055E0A) != 0x00 && strcmp((char *) eax_133 + 11, 0x08055E0C) != 0x00)
				{
					DIR * eax_165 = opendir(fp + ~0x280F);
					if (eax_165 != null)
					{
						closedir(eax_165);
						++dwLoc2840_539;
					}
				}
			}
			closedir(eax_122);
			word32 dwLoc281C_557 = 0x00;
			while (fgets(fp + ~0x080F, 0x0800, eax_29) != null)
				++dwLoc281C_557;
			if (dwLoc281C_557 == 0x00)
				eax_473 = 0x00;
			else
			{
				word32 ecx_209;
				rewind();
				Eq_102 eax_218 = calloc(dwLoc281C_557 + dwLoc2840_539 + 0x0A, 0x04);
				int32 dwLoc2820_572;
				for (dwLoc2820_572 = 0x00; dwLoc281C_557 + dwLoc2840_539 + 0x0A > dwLoc2820_572; ++dwLoc2820_572)
					((word32) eax_218 + dwLoc2820_572 * 0x04)->u0 = 0x00;
				ui32 dwLoc2820_578 = 0x00;
				while (fgets(fp + ~0x080F, 0x0800, eax_29) != null)
				{
					eax_218[dwLoc2820_578 * 0x04] = malloc(strlen(fp + ~0x080F) + 0x01);
					strcpy(*((word32) eax_218 + dwLoc2820_578 * 0x04), fp + ~0x080F);
					++dwLoc2820_578;
				}
				((word32) eax_218 + dwLoc2820_578 * 0x04)->u0 = 0x00;
				DIR * eax_278 = opendir(fp + ~0x200F);
				word32 dwLoc283C_592 = 0x00;
				while (true)
				{
					struct dirent * eax_286 = readdir(eax_278);
					if (eax_286 == null)
						break;
					sprintf(fp + ~0x280F, "%s/%s", 0x00);
					if (strcmp((char *) eax_286 + 11, 0x08055E0A) != 0x00 && strcmp((char *) eax_286 + 11, 0x08055E0C) != 0x00)
					{
						DIR * eax_318 = opendir(fp + ~0x280F);
						if (eax_318 != null)
						{
							closedir(eax_318);
							sprintf(fp + ~0x180F, "%s/index.html", 0x00);
							FILE * eax_336 = fopen(fp + ~0x180F, "r");
							if (eax_336 != null)
							{
								word32 dwLoc2820_616 = 0x00;
								do
								{
									if (fgets(fp + ~0x080F, 0x0800, eax_336) == null)
										goto l0804F611;
								} while (strstr(fp + ~0x080F, 0x08055E1D) == null);
								dwLoc2820_616 = 0x01;
l0804F611:
								if (dwLoc2820_616 != 0x00)
								{
									Eq_102 eax_373 = strchr(fp + ~0x080F, '(');
									__isoc99_sscanf();
									new_ext_html(gs, (char *) eax_286 + 11, eax_218);
									fclose(eax_336);
									++dwLoc283C_592;
								}
							}
						}
					}
				}
				closedir(eax_278);
				ui32 dwLoc2820_664 = 0x00;
				while (*((word32) eax_218 + dwLoc2820_664 * 0x04) != 0x00)
				{
					fprintf(eax_63, *((word32) eax_218 + dwLoc2820_664 * 0x04), 0x00);
					++dwLoc2820_664;
				}
				fflush(eax_63);
				fclose(eax_29);
				fclose(eax_63);
				int32 dwLoc2820_678;
				for (dwLoc2820_678 = 0x00; dwLoc281C_557 + dwLoc2840_539 + 0x0A > dwLoc2820_678; ++dwLoc2820_678)
					free(*((word32) eax_218 + dwLoc2820_678 * 0x04));
				free(eax_218);
				eax_473 = dwLoc283C_592;
			}
		}
	}
	if ((eax_15 ^ gs->dw0014) == 0x00)
		return eax_473;
	__stack_chk_fail();
}

// 0804F7E8: void check_extension(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack ptr32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      main
void check_extension(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, ptr32 dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	word32 eax_26 = gs->dw0014;
	word32 * edi_196 = fp + ~0x080B;
	word32 ecx_197;
	for (ecx_197 = 0x01FF; ecx_197 != 0x00; --ecx_197)
	{
		*edi_196 = 0x00;
		++edi_196;
	}
	FILE * eax_39 = g_ptr8059260;
	fwrite(&g_v8055E30, 0x01, 22, eax_39);
	strcpy(fp + ~0x080F, dwArg04);
	int32 eax_60;
	chdir();
	if (eax_60 >= 0x00)
	{
		FILE * eax_80 = fopen("id", "r");
		if (eax_80 != null)
		{
			__isoc99_fscanf();
			if (strcmp(0x08055EA7, fp + ~0x080F) == 0x00)
			{
				fclose(eax_80);
				get_package_name(gs, dwArg08);
				FILE * eax_124 = fopen("version", "r");
				if (eax_124 != null)
				{
					nc_fgets_nb(fp + ~0x080F, 0x0800, eax_124);
					*dwArg10 = 0x00;
					*dwArg14 = 0x00;
					int32 eax_153;
					__isoc99_sscanf();
					if (eax_153 > 0x00)
					{
						print_done();
						chdir();
						fclose(eax_124);
						if ((eax_26 ^ gs->dw0014) == 0x00)
							return;
						__stack_chk_fail();
					}
					else
					{
						fclose(eax_124);
						print_error(gs, ~0x05, 0x08055F0C);
					}
				}
				else
					print_error(gs, ~0x05, 0x08055EE5);
			}
			else
			{
				fclose(eax_80);
				print_error(gs, ~0x05, 0x08055EC1);
			}
		}
		else
			print_error(gs, ~0x05, 0x08055E70);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08055E48);
	}
}

// 0804FAAB: void unpack_extension(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      main
void unpack_extension(struct Eq_74 * gs, Eq_102 dwArg04)
{
	word32 eax_12 = gs->dw0014;
	FILE * eax_17 = g_ptr8059260;
	fwrite(&g_v8055F38, 0x01, 22, eax_17);
	mkstemp();
	int32 eax_37 = open(&g_b80632C0, 0x40);
	if (eax_37 != ~0x00)
	{
		if (g_dw80632A0 != 0x00)
			fprintf(g_ptr8059260, 0x08055F95, &g_b80632C0);
		remove();
		mkdir_s(gs, 0x080632C0, 0x08055FAD);
		atexit(&g_t8048E89);
		sprintf(fp + ~0x080F, "cp %s %s", 0x00);
		int32 eax_87;
		system();
		if (eax_87 >= 0x00)
		{
			word32 eax_95 = check_filetype(dwArg04);
			word32 dwLoc081C_368 = eax_95;
			if (eax_95 == 0x00)
			{
				print_warning(gs, 0x08055FEC);
				dwLoc081C_368 = 0x01;
			}
			if (dwLoc081C_368 == 0x01)
			{
				if (g_dw80632A0 != 0x00)
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "tar -xzvf %s/%s -C %s", 0x00);
				}
				else
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "tar -xzf %s/%s -C %s", 0x00);
				}
			}
			if (dwLoc081C_368 == 0x02)
			{
				if (g_dw80632A0 != 0x00)
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "tar -xjvf %s/%s -C %s", 0x00);
				}
				else
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "tar -xjvf %s/%s -C %s", 0x00);
				}
			}
			if (dwLoc081C_368 == 0x03)
			{
				if (g_dw80632A0 != 0x00)
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "unzip %s/%s -d %s", 0x00);
				}
				else
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "unzip -qq %s/%s -d %s", 0x00);
				}
			}
			if (dwLoc081C_368 == 0x04)
			{
				if (g_dw80632A0 != 0x00)
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "tar -xvf %s/%s -C %s", 0x00);
				}
				else
				{
					basename(dwArg04);
					sprintf(fp + ~0x080F, "tar -xf %s/%s -C %s", 0x00);
				}
			}
			int32 eax_282;
			system();
			if (eax_282 >= 0x00)
			{
				print_done();
				if ((eax_12 ^ gs->dw0014) == 0x00)
					return;
				__stack_chk_fail();
			}
			else if (dwLoc081C_368 != 0x01)
			{
				if (dwLoc081C_368 != 0x02)
				{
					if (dwLoc081C_368 != 0x03)
						exit(~0x06);
					else
						print_error(gs, ~0x06, 0x08056190);
				}
				else
					print_error(gs, ~0x06, 0x08056130);
			}
			else
				print_error(gs, ~0x06, 0x080560D0);
		}
		else
			print_error(gs, ~0x06, 0x08055FBC);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x06, 0x08055F6C);
	}
}

// 0804FF43: void query_extension(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack (ptr32 char) dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack ptr32 dwArg18, Stack (ptr32 char) dwArg1C, Stack (ptr32 char) dwArg20)
// Called from:
//      main
void query_extension(struct Eq_74 * gs, Eq_102 dwArg04, char * dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14, ptr32 dwArg18, char * dwArg1C, char * dwArg20)
{
	Eq_102 eax_27 = basename(dwArg04);
	strcpy(fp + ~0x080F, eax_27);
	int32 eax_38;
	chdir();
	if (eax_38 >= 0x00)
	{
		fprintf(g_ptr8059260, 0x080561E0, dwArg08, dwArg0C, dwArg10, dwArg14);
		dump_ascii(gs, "description", "Description");
		dump_ascii(gs, "commands", "Commands provided");
		dump_ascii(gs, "libs", "Libraries provided");
		dump_ascii(gs, "headers", "Header files provided");
		dump_ascii(gs, "depends", "Dependencies");
		dump_ascii(gs, "bugs", "Bugs");
		sprintf(fp + ~0x080F, "../%s", 0x00);
		list_binaries(gs, fp + ~0x080F);
		dump_ascii(gs, "authors", "Author(s)");
		fprintf(g_ptr8059260, 0x080562A4, dwArg1C, dwArg20);
		system();
		exit(0x00);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08055E48);
	}
}

// 0805014E: void print_cfg(Register (ptr32 Eq_74) gs)
// Called from:
//      source_install
//      test_install
void print_cfg(struct Eq_74 * gs)
{
	word32 eax_10 = gs->dw0014;
	FILE * eax_17 = fopen("config.msg", "r");
	if (eax_17 != null)
	{
		fwrite(&g_v805631A, 0x01, 0x1B, g_ptr8059260);
		while (fgets(fp + ~0x080F, 0x0800, eax_17) != null)
			fputs(fp + ~0x080F, g_ptr8059260);
		fputc(0x0A, g_ptr8059260);
	}
	remove();
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08050220: void source_install(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18, Stack Eq_102 dwArg1C)
// Called from:
//      main
void source_install(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18, Eq_102 dwArg1C)
{
	word32 eax_18 = gs->dw0014;
	if (stat(dwArg08, fp + ~0x288B) >= 0x00)
	{
		putenv();
		sprintf(fp + ~0x080F, "%s/include", 0x00);
		putenv();
		sprintf(fp + ~0x080F, "%s/lib", 0x00);
		putenv();
		putenv();
		Eq_102 eax_98 = strdup(dwArg1C);
		Eq_102 eax_104 = strtok(eax_98, ".");
		Eq_102 eax_109 = strtok(0x00, ".");
		Eq_102 eax_114 = strtok(0x00, ".");
		int32 eax_120 = strtol(eax_104);
		int32 eax_126 = strtol(eax_109);
		strtol(eax_114);
		free(eax_98);
		atexit(&g_t8048E89);
		Eq_102 eax_144 = basename(dwArg04);
		sprintf(fp + ~0x100F, "%s/src", 0x00);
		int32 eax_157;
		chdir();
		if (eax_157 >= 0x00)
		{
			if (g_dw80682D0 == 0x00)
			{
				int32 dwLoc2814_776;
				if (g_dw80632A0 != 0x00)
				{
					FILE * eax_202 = g_ptr8059260;
					fwrite(&g_v80563E4, 0x01, 0x1A, eax_202);
					sprintf(fp + ~0x280F, "sh %s %s", 0x00);
					int32 eax_219;
					system();
					dwLoc2814_776 = eax_219;
				}
				else
				{
					FILE * eax_180 = g_ptr8059260;
					fwrite(&g_v8056408, 0x01, 0x0E, eax_180);
					sprintf(fp + ~0x280F, "sh %s %s --quiet &> %s", 0x00);
					int32 eax_198;
					system();
					dwLoc2814_776 = eax_198;
				}
				if (dwLoc2814_776 == ~0x00)
					print_error(gs, ~0x1A, 0x08056430);
				if (dwLoc2814_776 > 0x00)
					print_error(gs, ~0x02, 0x08056451);
				print_done();
				print_cfg(gs);
			}
			int32 dwLoc2814_878;
			putenv();
			sprintf(fp + ~0x080F, "%i.%i.%i", 0x00);
			putenv();
			dump_html(gs, "../description", &g_b8064AC0);
			dump_html(gs, "../info", &g_b80652C0);
			dump_html(gs, "../depends", &g_b8065AC0);
			dump_html(gs, "../bugs", &g_b80662C0);
			dump_html(gs, "../authors", &g_b8066AC0);
			putenv();
			putenv();
			putenv();
			putenv();
			putenv();
			atexit(&g_t8048E89);
			check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
			if (g_dw80632A0 != 0x00)
			{
				fprintf(g_ptr8059260, 0x0805651B, &g_b806BAE0);
				sprintf(fp + ~0x280F, "%s -f Makefile", 0x00);
				int32 eax_425;
				system();
				dwLoc2814_878 = eax_425;
			}
			else
			{
				FILE * eax_390 = g_ptr8059260;
				fwrite(&g_v8056539, 0x01, 0x0C, eax_390);
				sprintf(fp + ~0x280F, "%s -f Makefile &> %s", 0x00);
				int32 eax_407;
				system();
				dwLoc2814_878 = eax_407;
			}
			if (dwLoc2814_878 != ~0x00 || g_dw80632A0 != 0x00)
			{
				if (dwLoc2814_878 <= 0x00)
				{
					print_done();
					fwrite(&g_v80565F5, 0x01, 0x0D, g_ptr8059260);
					FILE * eax_468 = fopen("../uninstall", "r");
					if (eax_468 == null)
					{
						strerror(*__errno_location());
						print_warning(gs, 0x08056610);
					}
					else
					{
						if (g_dw80632A0 != 0x00)
						{
							sprintf(fp + ~0x080F, "cp -vf ../uninstall %s/etc/uninstall.%s ;", 0x00);
							strcpy(0x0806A2E0, fp + ~0x080F);
						}
						else
						{
							sprintf(fp + ~0x080F, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", 0x00);
							strcpy(0x0806A2E0, fp + ~0x080F);
						}
						fclose(eax_468);
					}
					register_extension(gs, dwArg08, 134571743, dwArg0C, dwArg10, dwArg14, dwArg18);
					check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
					if (eax_120 == 0x06 && eax_126 <= 0x00)
						register_entries_gisman(gs, dwArg0C, dwArg08);
					register_entries_gisman2(gs);
					register_html(gs, dwArg0C, dwArg08, dwArg10, dwArg14, dwArg18);
					if (g_dw80632A0 != 0x00)
					{
						fprintf(g_ptr8059260, 134571747, &g_b806BAE0);
						sprintf(fp + ~0x180F, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", 0x00);
					}
					else
						sprintf(fp + ~0x180F, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", 0x00);
					if (g_dw80632A0 != 0x00)
						memcpy(fp + ~0x200F, &g_v80567D4, 11);
					else
						sprintf(fp + ~0x200F, "sh ../post &> %s", 0x00);
					sprintf(fp + ~0x080F, "%s %s %s %s %s %s", 0x00);
					su(gs, dwArg08, fp + ~0x080F);
					print_done();
					if ((eax_18 ^ gs->dw0014) == 0x00)
						return;
					__stack_chk_fail();
				}
				else
					print_error(gs, ~0x03, 0x08056594);
			}
			else
				print_error(gs, ~0x08, 0x0805655C);
		}
		else
		{
			strerror(*__errno_location());
			print_error(gs, ~0x01, 0x080563B8);
		}
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x04, 0x08056338);
	}
}

// 08050C67: void bin_install(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C, Stack Eq_102 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18, Stack int32 dwArg1C, Stack Eq_102 dwArg20)
// Called from:
//      main
void bin_install(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C, Eq_102 dwArg10, int32 dwArg14, int32 dwArg18, int32 dwArg1C, Eq_102 dwArg20)
{
	word32 eax_20 = gs->dw0014;
	if (stat(dwArg08, fp + ~0x208B) >= 0x00)
	{
		putenv();
		sprintf(fp + ~0x080F, "%s/include", 0x00);
		putenv();
		sprintf(fp + ~0x080F, "%s/lib", 0x00);
		putenv();
		putenv();
		Eq_102 eax_104 = strdup(dwArg20);
		Eq_102 eax_110 = strtok(eax_104, ".");
		Eq_102 eax_115 = strtok(0x00, ".");
		Eq_102 eax_120 = strtok(0x00, ".");
		int32 eax_126 = strtol(eax_110);
		int32 eax_132 = strtol(eax_115);
		strtol(eax_120);
		free(eax_104);
		atexit(&g_t8048E89);
		Eq_102 eax_150 = basename(dwArg04);
		sprintf(fp + ~0x100F, "%s/%s", 0x00);
		int32 eax_165;
		chdir();
		if (eax_165 >= 0x00)
		{
			putenv();
			sprintf(fp + ~0x080F, "%i.%i.%i", 0x00);
			putenv();
			dump_html(gs, "../description", &g_b8064AC0);
			dump_html(gs, "../info", &g_b80652C0);
			dump_html(gs, "../depends", &g_b8065AC0);
			dump_html(gs, "../bugs", &g_b80662C0);
			dump_html(gs, "../authors", &g_b8066AC0);
			putenv();
			putenv();
			putenv();
			putenv();
			putenv();
			atexit(&g_t8048E89);
			check_dependencies(gs, dwArg04, dwArg08, dwArg20);
			fwrite(&g_v80565F5, 0x01, 0x0D, g_ptr8059260);
			FILE * eax_333 = fopen("../uninstall", "r");
			if (eax_333 == null)
			{
				strerror(*__errno_location());
				print_warning(gs, 0x08056610);
			}
			else
			{
				if (g_dw80632A0 != 0x00)
				{
					sprintf(fp + ~0x080F, "cp -vf ../uninstall %s/etc/uninstall.%s ;", 0x00);
					strcpy(0x0806A2E0, fp + ~0x080F);
				}
				else
				{
					sprintf(fp + ~0x080F, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", 0x00);
					strcpy(0x0806A2E0, fp + ~0x080F);
				}
				fclose(eax_333);
			}
			register_extension(gs, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C);
			check_dependencies(gs, dwArg04, dwArg08, dwArg20);
			if (eax_126 == 0x06 && eax_132 <= 0x00)
				register_entries_gisman(gs, dwArg10, dwArg08);
			register_entries_gisman2(gs);
			register_html(gs, dwArg10, dwArg08, dwArg14, dwArg18, dwArg1C);
			if (g_dw80632A0 != 0x00)
			{
				fprintf(g_ptr8059260, 134571747, &g_b806BAE0);
				sprintf(fp + ~0x180F, "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", 0x00);
			}
			else
				sprintf(fp + ~0x180F, "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", 0x00);
			if (g_dw80632A0 != 0x00)
				memcpy(fp + ~0x200F, &g_v80567D4, 11);
			else
				sprintf(fp + ~0x200F, "sh ../post &> %s", 0x00);
			sprintf(fp + ~0x080F, "%s %s %s %s %s %s", 0x00);
			su(gs, dwArg08, fp + ~0x080F);
			print_done();
			if ((eax_20 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
		{
			strerror(*__errno_location());
			print_error(gs, ~0x01, 0x08056808);
		}
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x04, 0x08056338);
	}
}

// 0805148A: void test_install(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18, Stack Eq_102 dwArg1C)
// Called from:
//      main
void test_install(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18, Eq_102 dwArg1C)
{
	word32 eax_18 = gs->dw0014;
	if (stat(dwArg08, fp + ~0x188B) >= 0x00)
	{
		putenv();
		sprintf(fp + ~0x080F, "%s/include", 0x00);
		putenv();
		sprintf(fp + ~0x080F, "%s/lib", 0x00);
		putenv();
		putenv();
		Eq_102 eax_98 = strdup(dwArg1C);
		Eq_102 eax_104 = strtok(eax_98, ".");
		Eq_102 eax_109 = strtok(0x00, ".");
		Eq_102 eax_114 = strtok(0x00, ".");
		int32 eax_120 = strtol(eax_104);
		int32 eax_126 = strtol(eax_109);
		strtol(eax_114);
		free(eax_98);
		atexit(&g_t8048E89);
		Eq_102 eax_144 = basename(dwArg04);
		sprintf(fp + ~0x100F, "%s/src", 0x00);
		int32 eax_157;
		chdir();
		if (eax_157 >= 0x00)
		{
			if (g_dw80682D0 == 0x00)
			{
				int32 dwLoc1814_666;
				if (g_dw80632A0 != 0x00)
				{
					FILE * eax_202 = g_ptr8059260;
					fwrite(&g_v80563E4, 0x01, 0x1A, eax_202);
					sprintf(fp + ~0x180F, "sh %s %s", 0x00);
					int32 eax_219;
					system();
					dwLoc1814_666 = eax_219;
				}
				else
				{
					FILE * eax_180 = g_ptr8059260;
					fwrite(&g_v8056408, 0x01, 0x0E, eax_180);
					sprintf(fp + ~0x180F, "sh %s %s --quiet &> %s", 0x00);
					int32 eax_198;
					system();
					dwLoc1814_666 = eax_198;
				}
				if (dwLoc1814_666 == ~0x00)
					print_error(gs, ~0x1A, 0x08056430);
				if (dwLoc1814_666 > 0x00)
					print_error(gs, ~0x02, 0x08056451);
				print_done();
				print_cfg(gs);
			}
			int32 dwLoc1814_768;
			putenv();
			sprintf(fp + ~0x080F, "%i.%i.%i", 0x00);
			putenv();
			dump_plain(gs, "../description", &g_b8064AC0);
			dump_plain(gs, "../info", &g_b80652C0);
			dump_plain(gs, "../depends", &g_b8065AC0);
			dump_plain(gs, "../bugs", &g_b80662C0);
			dump_plain(gs, "../authors", &g_b8066AC0);
			putenv();
			putenv();
			putenv();
			putenv();
			putenv();
			atexit(&g_t8048E89);
			check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
			if (g_dw80632A0 != 0x00)
			{
				fprintf(g_ptr8059260, 0x0805651B, &g_b806BAE0);
				sprintf(fp + ~0x180F, "%s -f Makefile", 0x00);
				int32 eax_425;
				system();
				dwLoc1814_768 = eax_425;
			}
			else
			{
				FILE * eax_390 = g_ptr8059260;
				fwrite(&g_v8056539, 0x01, 0x0C, eax_390);
				sprintf(fp + ~0x180F, "%s -f Makefile &> %s", 0x00);
				int32 eax_407;
				system();
				dwLoc1814_768 = eax_407;
			}
			if (dwLoc1814_768 != ~0x00 || g_dw80632A0 != 0x00)
			{
				if (dwLoc1814_768 <= 0x00)
				{
					print_done();
					fwrite(&g_v80565F5, 0x01, 0x0D, g_ptr8059260);
					FILE * eax_468 = fopen("../uninstall", "r");
					if (eax_468 == null)
					{
						strerror(*__errno_location());
						print_warning(gs, 0x08056610);
					}
					else
						fclose(eax_468);
					register_extension(gs, dwArg08, 134571743, dwArg0C, dwArg10, dwArg14, dwArg18);
					check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
					if (eax_120 == 0x06 && eax_126 <= 0x00)
						register_entries_gisman(gs, dwArg0C, dwArg08);
					register_entries_gisman2(gs);
					register_html(gs, dwArg0C, dwArg08, dwArg10, dwArg14, dwArg18);
					fprintf(g_ptr8059260, 0x0805691C, &g_b806BAE0);
					print_done();
					if ((eax_18 ^ gs->dw0014) == 0x00)
						return;
					__stack_chk_fail();
				}
				else
					print_error(gs, ~0x03, 0x08056594);
			}
			else
				print_error(gs, ~0x08, 0x0805655C);
		}
		else
		{
			strerror(*__errno_location());
			print_error(gs, ~0x01, 0x080563B8);
		}
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x04, 0x08056338);
	}
}

// 08051CF4: void uninstall(Register (ptr32 Eq_74) gs, Stack ptr32 dwArg04, Stack Eq_102 dwArg08, Stack Eq_102 dwArg0C, Stack Eq_102 dwArg10)
// Called from:
//      main
void uninstall(struct Eq_74 * gs, ptr32 dwArg04, Eq_102 dwArg08, Eq_102 dwArg0C, Eq_102 dwArg10)
{
	word32 eax_18 = gs->dw0014;
	FILE * eax_23 = g_ptr8059260;
	fwrite(&g_v8056937, 0x01, 0x10, eax_23);
	putenv();
	Eq_102 eax_43 = strdup(dwArg10);
	Eq_102 eax_49 = strtok(eax_43, ".");
	Eq_102 eax_54 = strtok(0x00, ".");
	Eq_102 eax_59 = strtok(0x00, ".");
	int32 eax_65 = strtol(eax_49);
	int32 eax_71 = strtol(eax_54);
	strtol(eax_59);
	free(eax_43);
	atexit(&g_t8048E89);
	deregister_extension(gs, dwArg04, dwArg08, dwArg0C);
	if (eax_65 == 0x06 && eax_71 <= 0x00)
	{
		word32 eax_107 = deregister_entries_gisman(gs, dwArg08, dwArg0C);
		if (eax_107 == ~0x00)
		{
			print_warning(gs, 0x0805695C);
			memcpy(&g_b80682E0, &g_v805698C, 0x01);
		}
		if (eax_107 == 0x00)
		{
			print_warning(gs, 0x08056990);
			memcpy(&g_b80682E0, &g_v805698C, 0x01);
		}
	}
	deregister_entries_gisman2(gs);
	deregister_html(gs, dwArg08, dwArg0C);
	sprintf(fp + ~0x100F, "%s/etc/uninstall.%s", 0x00);
	word32 dwLoc1018_391 = 0x00;
	if (stat(fp + ~0x100F, fp + ~0x108B) < 0x00)
	{
		print_warning(gs, 0x080569D4);
		dwLoc1018_391 = 0x01;
	}
	if (dwLoc1018_391 != 0x00)
	{
		strerror(*__errno_location());
		print_warning(gs, 0x08056610);
	}
	else if (g_dw80632A0 != 0x00)
	{
		sprintf(fp + ~0x080F, "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", 0x00);
		strcpy(0x0806A2E0, fp + ~0x080F);
	}
	else
	{
		sprintf(fp + ~0x080F, "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;", 0x00);
		strcpy(0x0806A2E0, fp + ~0x080F);
	}
	sprintf(fp + ~0x080F, "%s %s %s", 0x00);
	su(gs, dwArg0C, fp + ~0x080F);
	print_done();
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 080521A4: void source_clean(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      main
void source_clean(struct Eq_74 * gs, Eq_102 dwArg04)
{
	word32 eax_12 = gs->dw0014;
	Eq_102 eax_19 = basename(dwArg04);
	sprintf(fp + ~0x080F, "%s/src", 0x00);
	int32 eax_32;
	chdir();
	if (eax_32 >= 0x00)
	{
		word32 dwLoc1014_133;
		if (g_dw80632A0 != 0x00)
		{
			fprintf(g_ptr8059260, 0x08056BE4, &g_b806BAE0);
			sprintf(fp + ~0x100F, "%s -f Makefile clean", 0x00);
			word32 eax_81;
			system();
			dwLoc1014_133 = eax_81;
		}
		else
		{
			FILE * eax_46 = g_ptr8059260;
			fwrite(&g_v8056C0E, 0x01, 0x0E, eax_46);
			sprintf(fp + ~0x100F, "%s -f Makefile -s clean &> %s", 0x00);
			word32 eax_63;
			system();
			dwLoc1014_133 = eax_63;
		}
		if (dwLoc1014_133 != ~0x00)
		{
			print_done();
			system();
			if ((eax_12 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
			print_error(gs, ~0x08, 0x08056C3C);
	}
	else
		print_error(gs, ~0x01, 0x08056BC4);
}

// 08052334: void restore(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack Eq_102 dwArg08)
// Called from:
//      main
void restore(struct Eq_74 * gs, Eq_102 dwArg04, Eq_102 dwArg08)
{
	word32 eax_14 = gs->dw0014;
	Eq_102 eax_19 = strdup(dwArg08);
	Eq_102 eax_25 = strtok(eax_19, ".");
	Eq_102 eax_30 = strtok(0x00, ".");
	Eq_102 eax_35 = strtok(0x00, ".");
	int32 eax_41 = strtol(eax_25);
	int32 eax_47 = strtol(eax_30);
	strtol(eax_35);
	free(eax_19);
	fwrite(&g_v8056C78, 0x01, 0x0C, g_ptr8059260);
	if (eax_41 == 0x06 && eax_47 <= 0x00)
	{
		int32 eax_71 = restore_entries_gisman(gs, dwArg04);
		if (g_dw80632A0 != 0x00)
			fprintf(g_ptr8059260, 0x08056C88, eax_71);
	}
	int32 eax_96 = restore_html(gs, dwArg04);
	if (g_dw80632A0 != 0x00)
		fprintf(g_ptr8059260, 0x08056CB0, eax_96);
	if (eax_96 > 0x00)
	{
		if (g_dw80632A0 != 0x00)
			sprintf(fp + ~0x080F, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", 0x00);
		else
			sprintf(fp + ~0x080F, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", 0x00);
		su(gs, dwArg04, fp + ~0x080F);
	}
	if (eax_96 != 0x00)
	{
		print_done();
		if ((eax_14 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else
		print_error(gs, ~0x19, 0x08056DF0);
}

// 080525FC: void list_extensions(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      main
void list_extensions(struct Eq_74 * gs, Eq_102 dwArg04)
{
	word32 eax_12 = gs->dw0014;
	fprintf(g_ptr8059260, 0x08056E18, dwArg04);
	sprintf(fp + ~0x080F, "%s/etc/extensions.db", 0x00);
	FILE * eax_33 = fopen(fp + ~0x080F, "r");
	if (eax_33 != null)
	{
		fclose(eax_33);
		dump_ascii(gs, fp + ~0x080F, "");
		if ((eax_12 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else if (*__errno_location() != 0x02)
	{
		fclose(eax_33);
		strerror(*__errno_location());
		print_error(gs, ~0x1C, 0x08056E69);
	}
	else
	{
		fwrite(&g_v8056E62, 0x01, 0x06, g_ptr8059244);
		fclose(eax_33);
		exit(0x00);
	}
}

// 08052748: void run_post(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04, Stack uint32 dwArg08, Stack Eq_102 dwArg0C, Stack Eq_102 dwArg10)
// Called from:
//      main
void run_post(struct Eq_74 * gs, Eq_102 dwArg04, uint32 dwArg08, Eq_102 dwArg0C, Eq_102 dwArg10)
{
	word32 eax_16 = gs->dw0014;
	if (dwArg08 > 0x09)
		goto l0805284A;
	switch (g_a8056F68[(dwArg08 - 0x03) * 0x04])
	{
	case 0x00:
		memcpy(&g_b805F2A0, &g_v8056E85, 0x13);
		goto l0805284A;
	case 0x01:
		memcpy(&g_b805F2A0, &g_v8056E85, 0x13);
		goto l0805284A;
	case 0x02:
		memcpy(&g_b805F2A0, &g_v8056E98, 0x11);
		goto l0805284A;
	case 0x03:
		memcpy(&g_b805F2A0, &g_v8056EA9, 0x11);
		goto l0805284A;
	case 0x04:
		memcpy(&g_b805F2A0, &g_v8056EBA, 0x13);
		goto l0805284A;
	case 0x05:
l0805284A:
		putenv();
		if (dwArg10 != 0x00)
			sprintf(0x0805FAA0, "INSTALL_BASE=%s", 0x00);
		else
			memcpy(&g_b805FAA0, &g_v8056EF0, 0x17);
		putenv();
		getcwd(fp + ~0x080F, 0x0800);
		Eq_102 eax_89 = basename(dwArg04);
		sprintf(fp + ~0x100F, "%s/%s/src", 0x00);
		putenv();
		if (dwArg0C == 0x00)
			memcpy(&g_b80602A0, &g_v8056F1D, 0x11);
		else
			sprintf(134611616, "INSTALL_TYPE=%s", 0x00);
		putenv();
		sprintf(fp + ~0x080F, "%i", 0x00);
		putenv();
		sprintf(fp + ~0x080F, "%i", 0x00);
		putenv();
		putenv();
		atexit(&g_t8048E89);
		if ((eax_16 ^ gs->dw0014) == 0x00)
			return;
		else
			__stack_chk_fail();
	case 0x06:
		memcpy(&g_b805F2A0, &g_v8056ECD, 0x13);
		goto l0805284A;
	}
}

// 08052A50: void show_help()
// Called from:
//      main
void show_help()
{
	fwrite(&g_v8056F88, 0x01, 0x2A, g_ptr8059260);
	fwrite(&g_v8056FB4, 0x01, 44, g_ptr8059260);
	fwrite(&g_v8056FE4, 0x01, 0x27, g_ptr8059260);
	fwrite(&g_v805700C, 0x01, 0x17, g_ptr8059260);
	fwrite(&g_v8057024, 0x01, 0x2E, g_ptr8059260);
	fwrite(&g_v8057054, 0x01, 0x35, g_ptr8059260);
	fwrite(&g_v805708C, 0x01, 0x45, g_ptr8059260);
	fwrite(&g_v80570D4, 0x01, 66, g_ptr8059260);
	fwrite(&g_v8057118, 0x01, 0x3C, g_ptr8059260);
	fwrite(&g_v8057158, 0x01, 0x44, g_ptr8059260);
	fwrite(&g_v80571A0, 0x01, 0x40, g_ptr8059260);
	fwrite(&g_v80571E4, 0x01, 0x3D, g_ptr8059260);
	fwrite(&g_v8057224, 0x01, 0x29, g_ptr8059260);
	fwrite(&g_v8057250, 0x01, 0x36, g_ptr8059260);
	fwrite(&g_v8057287, 0x01, 0x17, g_ptr8059260);
	fwrite(&g_v80572A0, 0x01, 0x32, g_ptr8059260);
	fwrite(&g_v80572D4, 0x01, 0x45, g_ptr8059260);
	fwrite(&g_v805731C, 0x01, 0x38, g_ptr8059260);
	fwrite(&g_v8057358, 0x01, 0x35, g_ptr8059260);
	fwrite(&g_v8057390, 0x01, 0x2A, g_ptr8059260);
	fwrite(&g_v80573BC, 0x01, 55, g_ptr8059260);
	fwrite(&g_v80573F4, 0x01, 0x3E, g_ptr8059260);
	fwrite(&g_v8057434, 0x01, 77, g_ptr8059260);
	fwrite(&g_v8057484, 0x01, 0x41, g_ptr8059260);
	fwrite(&g_v80574C8, 0x01, 0x47, g_ptr8059260);
	fwrite(&g_v8057510, 0x01, 0x49, g_ptr8059260);
	fwrite(&g_v805755A, 0x01, 0x0F, g_ptr8059260);
	fwrite(&g_v805756C, 0x01, 0x4A, g_ptr8059260);
	fwrite(&g_v80575B7, 0x01, 0x14, g_ptr8059260);
	fwrite(&g_v80575CC, 0x01, 0x49, g_ptr8059260);
	fwrite(&g_v8057618, 0x01, 0x4C, g_ptr8059260);
	fwrite(&g_v8057668, 0x01, 0x2A, g_ptr8059260);
	fwrite(&g_v8057694, 0x01, 0x4B, g_ptr8059260);
	fwrite(&g_v80576E0, 0x01, 0x0A, g_ptr8059260);
	fwrite(&g_v80576EC, 0x01, 0x3F, g_ptr8059260);
	fwrite(&g_v805772C, 0x01, 0x4B, g_ptr8059260);
	exit(0x00);
}

// 08053002: void show_details(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      main
void show_details(struct Eq_74 * gs, Eq_102 dwArg04)
{
	Eq_102 eax_19 = basename(dwArg04);
	strcpy(fp + ~0x080F, eax_19);
	int32 eax_30;
	chdir();
	if (eax_30 >= 0x00)
	{
		dump_ascii(gs, "info", "Detailed information");
		system();
		exit(0x00);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08057778);
	}
}

// 080530B9: void show_license(Register (ptr32 Eq_74) gs, Stack Eq_102 dwArg04)
// Called from:
//      main
void show_license(struct Eq_74 * gs, Eq_102 dwArg04)
{
	Eq_102 eax_19 = basename(dwArg04);
	strcpy(fp + ~0x080F, eax_19);
	int32 eax_30;
	chdir();
	if (eax_30 >= 0x00)
	{
		dump_ascii(gs, "license", "Detailed information");
		system();
		exit(0x00);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08057778);
	}
}

// 08053170: void show_version()
// Called from:
//      main
void show_version()
{
	fprintf(g_ptr8059260, 0x080577C8, g_r8057E40);
	fwrite(&g_v80577EF, 0x01, 0x1A, g_ptr8059260);
	fwrite(&g_v805780C, 0x01, 0x23, g_ptr8059260);
	fwrite(&g_v8057830, 0x01, 0x4B, g_ptr8059260);
	fwrite(&g_v805787C, 0x01, 0x4C, g_ptr8059260);
	exit(0x00);
}

// 08053242: void get_configure_options(Register (ptr32 Eq_74) gs)
void get_configure_options(struct Eq_74 * gs)
{
	word32 eax_12 = gs->dw0014;
	if ((byte) (word32) g_b806AAE0 == 0x00)
	{
		sprintf(fp + ~0x080F, "%s/etc/config.system", 0x00);
		FILE * eax_32 = fopen(fp + ~0x080F, "r");
		if (eax_32 == null)
			print_warning(gs, 0x080578E0);
		else if (nc_fgets_nb(fp + ~0x080F, 0x0800, eax_32) != 0x00)
			strcpy(0x0806AAE0, fp + ~0x080F);
	}
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0805331E: void main(Register (ptr32 Eq_74) gs, Stack int32 dwArg04, Stack (ptr32 (ptr32 char)) dwArg08)
void main(struct Eq_74 * gs, int32 dwArg04, char ** dwArg08)
{
	__align(fp - 4);
	g_dw80632A0 = 0x00;
	g_dw80682C0 = 0x00;
	g_dw80682C4 = 0x00;
	g_dw80682C8 = 0x00;
	g_dw80682CC = 0x00;
	g_dw806CAE0 = 0x00;
	g_dw806CAE4 = 0x00;
	g_dw80682D0 = 0x00;
	memcpy(&g_b80682E0, &g_v8057925, 0x01);
	memcpy(&g_b8068AE0, &g_v8057925, 0x01);
	memcpy(&g_b8069AE0, &g_v8057925, 0x01);
	memcpy(&g_b806A2E0, &g_v8057925, 0x01);
	memcpy(&g_b80692E0, &g_v8057925, 0x01);
	memcpy(&g_b80632C0, &g_v8057925, 0x01);
	memcpy(&g_b8063AC0, &g_v8057925, 0x01);
	memcpy(&g_b80642C0, &g_v8057925, 0x01);
	memcpy(&g_b8064AC0, &g_v8057925, 0x01);
	memcpy(&g_b80652C0, &g_v8057925, 0x01);
	memcpy(&g_b8065AC0, &g_v8057925, 0x01);
	memcpy(&g_b80662C0, &g_v8057925, 0x01);
	memcpy(&g_b8066AC0, &g_v8057925, 0x01);
	memcpy(&g_b8067AC0, &g_v8057925, 0x01);
	memcpy(&g_b80672C0, &g_v8057925, 0x01);
	memcpy(&g_b806AAE0, &g_v8057925, 0x01);
	memcpy(&g_b806B2E0, &g_v8057926, 0x0A);
	memcpy(&g_b806BAE0, &g_v8057930, 0x05);
	getcwd(&g_b806C2E0, 0x0800);
	fwrite(&g_v8057935, 0x01, 0x04, g_ptr8059260);
	Eq_102 eax_130 = malloc(0x0800);
	strcpy(fp - 12312, *dwArg08);
	setvbuf(g_ptr8059260, null, 0x02, 0x00);
	if (dwArg04 != 0x01)
	{
		atexit(&g_t8049390);
		g_dw8059264 = 0x00;
		int32 dwLoc3868_1279 = 0x00;
		Eq_102 dwLoc383C_1280 = 0x00;
		Eq_102 dwLoc381C_1281 = 0x00;
		Eq_7885 dwLoc3860_1287 = getopt_long(dwArg04, dwArg08, ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs", &g_t8059100, fp - 14464);
		while (dwLoc3860_1287 != ~0x00)
		{
			if (dwLoc3860_1287 == 0x3F)
				print_error(gs, ~0x00, 0x08057960);
			if (dwLoc3860_1287 == 0x3A)
			{
				if (g_dw8059240 == 0x69 || (g_dw8059240 == 117 || (g_dw8059240 == 100 || (g_dw8059240 == 99 || (g_dw8059240 == 116 || (g_dw8059240 == 0x6C || g_dw8059240 == 114))))))
					print_error(gs, ~0x00, 0x08057988);
				if (g_dw8059240 == 0x67)
					print_error(gs, ~0x00, 0x080579A9);
				if (g_dw8059240 == 0x62)
					print_error(gs, ~0x00, 0x080579C4);
				if (g_dw8059240 == 0x62)
					print_error(gs, ~0x00, 0x080579EA);
				if (g_dw8059240 == 113)
				{
					dwLoc3864 = 0x0C;
					++dwLoc3868_1279;
					break;
				}
			}
			if (dwLoc3860_1287 == 0x69 || (dwLoc3860_1287 == 117 || (dwLoc3860_1287 == 113 || (dwLoc3860_1287 == 100 || (dwLoc3860_1287 == 99 || (dwLoc3860_1287 == 116 || (dwLoc3860_1287 == 0x6C || (dwLoc3860_1287 == 114 || (dwLoc3860_1287 == 0x68 || dwLoc3860_1287 == 0x56)))))))))
			{
				++dwLoc3868_1279;
				if (dwLoc3860_1287 > 117)
					goto l080538E5;
				switch (g_a8057D30[(dwLoc3860_1287 - 0x56) * 0x04])
				{
				case 0x00:
					dwLoc3864 = 0x02;
					goto l080538E5;
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 11:
				case 0x0C:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x14:
				case 0x15:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1D:
l080538E5:
					if (g_t8059280 != 0x00)
					{
						strcpy(fp - 0x1018, g_t8059280);
						strcpy(fp - 0x1818, g_t8059280);
					}
					break;
				case 0x0D:
					dwLoc3864 = 0x06;
					goto l080538E5;
				case 0x0E:
					dwLoc3864 = 0x09;
					goto l080538E5;
				case 0x12:
					dwLoc3864 = 0x01;
					goto l080538E5;
				case 0x13:
					if (dwLoc3864 != 0x04)
						dwLoc3864 = 0x03;
					goto l080538E5;
				case 22:
					dwLoc3864 = 0x07;
					goto l080538E5;
				case 0x1B:
					dwLoc3864 = 0x05;
					goto l080538E5;
				case 0x1C:
					dwLoc3864 = 11;
					goto l080538E5;
				case 0x1E:
					dwLoc3864 = 0x08;
					goto l080538E5;
				case 0x1F:
					dwLoc3864 = 0x0A;
					goto l080538E5;
				}
			}
			if (dwLoc3860_1287 == 0x67)
			{
				word32 eax_289 = malloc(strlen(g_t8059280) + 0x01);
				strcpy(eax_289, g_t8059280);
				dwLoc381C_1281 = eax_289;
			}
			if (dwLoc3860_1287 == 0x62)
			{
				word32 eax_306 = malloc(strlen(g_t8059280) + 0x01);
				strcpy(eax_306, g_t8059280);
				dwLoc383C_1280 = eax_306;
				dwLoc3864 = 0x04;
			}
			if (dwLoc3860_1287 == 0x78)
				strcpy(0x0806AAE0, g_t8059280);
			if (dwLoc3860_1287 == 0x66)
				g_dw80682C8 = 0x01;
			if (dwLoc3860_1287 == 118)
				g_dw80632A0 = 0x01;
			if (dwLoc3860_1287 == 115)
				g_dw80682D0 = 0x01;
			if (dwLoc3860_1287 == 111)
				strcat(fp - 0x3818, g_t8059280);
			if (dwLoc3860_1287 == 0x43)
				strcpy(0x0806B2E0, g_t8059280);
			if (dwLoc3860_1287 == 0x6D)
				strcpy(0x0806BAE0, g_t8059280);
			dwLoc3860_1287 = getopt_long(dwArg04, dwArg08, ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs", &g_t8059100, fp - 14464);
		}
		if (dwLoc3868_1279 > 0x00)
		{
			if (dwLoc3868_1279 <= 0x01)
			{
				putenv();
				if (dwLoc3864 != 0x01)
				{
					if (dwLoc3864 != 0x02)
					{
						if (g_dw80632A0 == 0x00)
						{
							mkstemp();
							if (open(&g_b80672C0, 0x40) == ~0x00)
							{
								strerror(*__errno_location());
								print_error(gs, ~0x1D, 0x08057A94);
							}
						}
						if (dwLoc3864 != 11)
						{
							if (dwLoc3864 != 0x0C)
							{
								if (strstr(fp - 0x1018, 0x08057B15) != null || strstr(fp - 0x1018, 0x08057B1D) != null)
								{
									wget_extension(gs, fp - 0x1018);
									Eq_102 eax_501 = malloc(0x0800);
									strcpy(eax_501, fp - 0x1018);
									strcpy(fp - 0x1018, (word32) strrchr(eax_501, '/') + 1);
									free(eax_501);
								}
								if (g_dw80632A0 != 0x00)
									fprintf(g_ptr8059260, 0x08057B24, fp - 0x1018);
								if (dwLoc3864 != 0x0A)
								{
									if (stat(fp - 0x1018, fp - 0x38D8) < 0x00)
									{
										strerror(*__errno_location());
										print_error(gs, ~0x01, 0x08057B44);
									}
									if ((dwLoc38C8 & 0xF000) == 0x4000)
									{
										if (g_dw80632A0 != 0x00)
											fwrite(&g_v8057B6C, 0x01, 0x27, g_ptr8059260);
									}
									else
									{
										if (g_dw80632A0 != 0x00)
											fwrite(&g_v8057B94, 0x01, 0x2A, g_ptr8059260);
										unpack_extension(gs, fp - 0x1018);
										DIR * eax_591 = opendir(&g_b80632C0);
										struct dirent * dwLoc3878_1472 = readdir(eax_591);
										word32 dwLoc387C_1473 = 0x00;
										while (dwLoc3878_1472 != null)
										{
											if (strcmp((char *) dwLoc3878_1472 + 11, 0x08057BBF) != 0x00 && strcmp((char *) dwLoc3878_1472 + 11, 0x08057BC1) != 0x00)
											{
												sprintf(eax_130, "%s/%s", 0x00);
												stat(eax_130, fp - 0x3930);
												if ((dwLoc3920 & 0xF000) == 0x4000)
												{
													dwLoc387C_1473 = 0x01;
													break;
												}
											}
											dwLoc3878_1472 = readdir(eax_591);
										}
										strcpy(fp - 0x1018, eax_130);
										if (dwLoc387C_1473 == 0x00)
											print_error(gs, ~0x06, 0x08057BCC);
									}
								}
								if (dwLoc3864 == 0x0A)
									strcpy(fp - 0x2818, fp - 0x1018);
								else
									get_package_name(gs, fp - 0x2818);
								if (dwLoc3868_1279 > 0x00)
								{
									if (dwLoc381C_1281 == 0x00)
										dwLoc381C_1281 = getenv("GISBASE");
									run_post(gs, fp - 0x1018, dwLoc3864, dwLoc383C_1280, dwLoc381C_1281);
								}
								if (g_dw80632A0 != 0x00)
									fprintf(g_ptr8059260, 0x08057C00, fp - 0x1018);
								if (dwLoc3864 != 0x0A)
									check_extension(gs, fp - 0x1018, fp - 0x2018, fp - 14400, fp - 14404, fp - 0x3848);
								if (dwLoc3864 != 0x05)
								{
									if (dwLoc3864 != 0x09)
									{
										if (dwLoc3864 != 0x07)
										{
											if (dwLoc3864 != 0x06)
											{
												if (dwLoc381C_1281 == 0x00)
												{
													Eq_102 eax_770 = getenv("GISBASE");
													dwLoc381C_1281 = eax_770;
													if (eax_770 == 0x00)
														print_error(gs, ~0x00, 0x08057ABC);
												}
												if (g_dw80632A0 != 0x00)
													fprintf(g_ptr8059260, 0x08057AFF, dwLoc381C_1281);
												Eq_102 eax_792 = getenv("GRASS_VERSION");
												Eq_102 dwLoc3820_1605 = eax_792;
												if (eax_792 == 0x00)
												{
													sprintf(fp - 0x0818, "%s/etc/VERSIONNUMBER", 0x00);
													FILE * eax_807 = fopen(fp - 0x0818, "r");
													if (eax_807 == null)
														print_error(gs, ~0x0A, 0x08057C4C);
													Eq_102 eax_812 = malloc(0x10);
													int32 eax_870;
													__isoc99_fscanf();
													fclose(eax_807);
													dwLoc3820_1605 = eax_812;
													if (eax_870 <= 0x00)
														print_error(gs, ~0x0A, 0x08057C4C);
												}
												if (dwLoc3820_1605 != 0x00)
												{
													Eq_102 eax_896 = strtok(strdup(dwLoc3820_1605), ".");
													Eq_102 eax_901 = strtok(0x00, ".");
													Eq_102 eax_906 = strtok(0x00, ".");
													int32 eax_912 = strtol(eax_896);
													strtol(eax_901);
													strtol(eax_906);
													Eq_102 eax_927 = malloc(0x0800);
													sprintf(eax_927, "%i.%i.%i", 0x00);
													dwLoc3820_1605 = eax_927;
													if (g_dw80632A0 != 0x00)
														fprintf(g_ptr8059260, 0x08057C97, eax_927);
													if (eax_912 <= 0x05)
														print_error(gs, ~0x0A, 0x08057CB0);
												}
												sprintf(fp - 0x3818, "-L%s/lib -I/usr/local/grasslib/include/ ", 0x00);
												if (dwLoc3864 != 0x03)
												{
													if (dwLoc3864 != 0x0A)
													{
														if (dwLoc3864 != 0x08)
														{
															if (dwLoc3864 != 0x04)
																exit(0x00);
															else if (binaries_exist(gs, fp - 0x1018, dwLoc383C_1280) == 0x00)
																print_error(gs, ~0x0B, 0x08057D11);
															else
															{
																bin_install(gs, fp - 0x1018, dwLoc381C_1281, dwLoc383C_1280, fp - 0x2818, dwLoc3840, dwLoc3844, dwLoc3848, dwLoc3820_1605);
																exit(0x00);
															}
														}
														else
														{
															test_install(gs, fp - 0x1018, dwLoc381C_1281, fp - 0x2818, dwLoc3840, dwLoc3844, dwLoc3848, dwLoc3820_1605);
															exit(0x00);
														}
													}
													else
													{
														uninstall(gs, fp - 0x1018, fp - 0x2818, dwLoc381C_1281, dwLoc3820_1605);
														exit(0x00);
													}
												}
												else
												{
													source_install(gs, fp - 0x1018, dwLoc381C_1281, fp - 0x2818, dwLoc3840, dwLoc3844, dwLoc3848, dwLoc3820_1605);
													exit(0x00);
												}
											}
											else
											{
												source_clean(gs, fp - 0x1018);
												exit(0x00);
											}
										}
										else
											show_license(gs, fp - 0x1018);
									}
									else
										show_details(gs, fp - 0x1018);
								}
								else
									query_extension(gs, fp - 0x1018, fp - 0x2018, dwLoc3840, dwLoc3844, dwLoc3848, fp - 0x2818, fp - 12312, fp - 0x1818);
							}
							else
							{
								if (dwLoc381C_1281 == 0x00)
								{
									Eq_102 eax_1111 = getenv("GISBASE");
									dwLoc381C_1281 = eax_1111;
									if (eax_1111 == 0x00)
										print_error(gs, ~0x00, 0x08057ABC);
								}
								if (g_dw80632A0 != 0x00)
									fprintf(g_ptr8059260, 0x08057AFF, dwLoc381C_1281);
								list_extensions(gs, dwLoc381C_1281);
								exit(0x00);
							}
						}
						else
						{
							if (dwLoc381C_1281 == 0x00)
							{
								Eq_102 eax_1147 = getenv("GISBASE");
								dwLoc381C_1281 = eax_1147;
								if (eax_1147 == 0x00)
									print_error(gs, ~0x00, 0x08057ABC);
							}
							if (g_dw80632A0 != 0x00)
								fprintf(g_ptr8059260, 0x08057AFF, dwLoc381C_1281);
							restore(gs, dwLoc381C_1281, dwLoc3820);
							exit(0x00);
						}
					}
					else
						show_version();
				}
				else
					show_help();
			}
			else
				print_error(gs, ~0x00, 0x08057A44);
		}
		else
			print_error(gs, ~0x00, 134576676);
	}
	else
		show_help();
}

// 080546E0: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 080546F0: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	_init();
	int32 edi_29 = 0x080590D8 - 0x080590D8;
	if (edi_29 >> 0x02 != 0x00)
	{
		Eq_8669 esi_34 = 0x00;
		do
		{
			((<anonymous> *[]) 0x080590D8)[esi_34]();
			esi_34 = (word32) esi_34.u1 + 1;
		} while (esi_34 < edi_29 >> 0x02);
	}
}

// 0805474A: void __i686.get_pc_thunk.bx()
void __i686.get_pc_thunk.bx()
{
}

// 08054750: void atexit(Stack (ptr32 Eq_1477) dwArg04)
// Called from:
//      dump_plain
//      dump_html
//      register_extension
//      deregister_extension
//      register_entries_gisman
//      deregister_entries_gisman
//      restore_entries_gisman
//      register_html
//      deregister_html
//      restore_html
//      unpack_extension
//      source_install
//      bin_install
//      test_install
//      uninstall
//      run_post
//      main
void atexit(void (* dwArg04)(void * ptrArg04))
{
	struct Eq_8679 * eax_14 = g_ptr8058FF8;
	if (eax_14 != null)
		eax_14 = eax_14->ptr0000;
	__cxa_atexit(dwArg04, null, eax_14);
}

// 08054790: Register int32 stat(Stack Eq_102 dwArg04, Stack (ptr32 Eq_1701) dwArg08)
// Called from:
//      list_binaries
//      binaries_exist
//      source_install
//      bin_install
//      test_install
//      uninstall
//      main
int32 stat(Eq_102 dwArg04, struct stat * dwArg08)
{
	return __xstat(0x03, dwArg04, dwArg08);
}

// 080547D0: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * eax_12 = g_ptr8058F10;
	if (eax_12 != (<anonymous> *) ~0x00)
	{
		word32 * ebx_15 = &g_ptr8058F10;
		do
		{
			eax_12();
			ebx_15 -= 0x04;
			eax_12 = *ebx_15;
		} while (eax_12 != (<anonymous> *) ~0x00);
	}
}

