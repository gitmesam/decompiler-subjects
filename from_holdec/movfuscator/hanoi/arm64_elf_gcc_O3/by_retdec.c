//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int64_t add_disk(void);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(int64_t a1);
int64_t frame_dummy(void);
int64_t function_860(int64_t a1);
int32_t function_870(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int64_t * function_880(int32_t nmemb, int32_t size);
int64_t function_890(int64_t a1);
void function_8a0(void);
int32_t function_8b0(char * s);
int32_t function_8c0(char * nptr, char ** endptr, int32_t base);
int32_t function_8d0(struct _IO_FILE * stream);
int32_t function_8e0(int32_t useconds);
int32_t function_8f0(char * format, ...);
int64_t function_c20(int64_t a1, int64_t a2);
void move(uint32_t n, uint32_t from, int32_t to, uint32_t via);
int64_t new_tower(int64_t a1);
int64_t register_tm_clones(int64_t * a1, int64_t a2);
int64_t remove_disk(void);
int64_t text(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[%d;%dH"; // 0x1060
char * g2 = "\x1b[H\x1b[J"; // 0x1088
int64_t g3 = 10; // 0x1090
int64_t g4 = 3056; // 0x11d90
int64_t g5 = 2984; // 0x11d98
int64_t g6 = 0; // 0x11da0
void (*g7)() = (void (*)())0x1040; // 0x11f90
int64_t g8 = 0; // 0x11f98
int64_t g9 = 0; // 0x11fa0
int64_t g11 = 0; // 0x11fb0
int32_t g12 = 0; // 0x11fb1
int64_t g13 = 0; // 0x11fb8
void (*g14)() = (void (*)())4040; // 0x11fc0
int64_t g15 = 2304; // 0x11fc8
int32_t g16 = 0x12080; // 0x11fd0
int32_t g17 = 0; // 0x11fd4
int64_t g18 = 0; // 0x11fd8
int64_t g19 = 2112; // 0x12000
int64_t g20 = 0; // 0x12060
int64_t g21 = 0; // 0x12067
int64_t t = 0; // 0x12068
int32_t g22;
int64_t * g10 = &t; // 0x11fa8

// ------------------------ Functions -------------------------

// Address range: 0x820 - 0x834
int64_t _init(int64_t a1) {
    // 0x820
    return call_weak_fn();
}

// Address range: 0x860 - 0x870
int64_t function_860(int64_t a1) {
    // 0x860
    return __cxa_finalize();
}

// Address range: 0x870 - 0x880
int32_t function_870(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x870
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x880 - 0x890
int64_t * function_880(int32_t nmemb, int32_t size) {
    // 0x880
    return calloc(nmemb, size);
}

// Address range: 0x890 - 0x8a0
int64_t function_890(int64_t a1) {
    // 0x890
    return __gmon_start__();
}

// Address range: 0x8a0 - 0x8b0
void function_8a0(void) {
    // 0x8a0
    abort();
}

// Address range: 0x8b0 - 0x8c0
int32_t function_8b0(char * s) {
    // 0x8b0
    return puts(s);
}

// Address range: 0x8c0 - 0x8d0
int32_t function_8c0(char * nptr, char ** endptr, int32_t base) {
    // 0x8c0
    return strtol(nptr, endptr, base);
}

// Address range: 0x8d0 - 0x8e0
int32_t function_8d0(struct _IO_FILE * stream) {
    // 0x8d0
    return fflush(stream);
}

// Address range: 0x8e0 - 0x8f0
int32_t function_8e0(int32_t useconds) {
    // 0x8e0
    return usleep(useconds);
}

// Address range: 0x8f0 - 0x900
int32_t function_8f0(char * format, ...) {
    // 0x8f0
    return printf(format);
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x900 - 0xae4
// Line range:    49 - 30
int main(int c, char ** v) {
    // 0x900
    puts((char *)&g2);
    if (c < 2) {
        // 0xab4
        *(int32_t *)(int64_t)(uint32_t)g16 = 8;
        goto lab_0x964;
    } else {
        int32_t str_as_l = strtol((char *)*(int64_t *)((int64_t)v + 8), NULL, 10); // 0x950
        *(int32_t *)(int64_t)g16 = str_as_l;
        if (str_as_l < 1) {
            // 0xab4
            *(int32_t *)(int64_t)g16 = 8;
            goto lab_0x964;
        } else {
            goto lab_0x964;
        }
    }
  lab_0x964:;
    int64_t v1 = 0; // 0x984
    int64_t * mem = calloc(1, (int32_t)(4 * (int64_t)&g17)); // 0x990
    int64_t v2 = (int64_t)mem; // 0x990
    *(int64_t *)(v1 + (int64_t)g10) = v2;
    int64_t v3 = v1 + 8; // 0x998
    *mem = v2 + 16;
    v1 = v3;
    while (v3 != 24) {
        // 0x988
        mem = calloc(1, (int32_t)(4 * (int64_t)&g17));
        v2 = (int64_t)mem;
        *(int64_t *)(v1 + (int64_t)g10) = v2;
        v3 = v1 + 8;
        *mem = v2 + 16;
        v1 = v3;
    }
    if (g16 == 0) {
        // 0xa58
        move(g16, 0, 2, 1);
        text(1, 0, 1, &g3);
        return 0;
    }
    int32_t v4 = g11; // 0x9d8
    int64_t v5 = g16; // 0x9d8
    while (true) {
        int64_t v6 = v5;
        *(int32_t *)&g11 = (int32_t)&g12;
        *(int32_t *)((int64_t)g10 + (int64_t)(4 * v4)) = (int32_t)v6;
        printf((char *)&g1);
        int64_t v7 = v6; // 0xa14
        int64_t v8; // 0x900
        if (v6 == 0) {
            // 0xac8
            usleep(0x186a0);
            fflush((struct _IO_FILE *)*(int64_t *)g11);
            v8 = 0xffffffff;
        } else {
            int64_t v9 = v7;
            printf("%s", "==");
            v7 = v9 + 0xffffffff & 0xffffffff;
            while ((int32_t)v9 != 1) {
                // 0xa28
                v9 = v7;
                printf("%s", "==");
                v7 = v9 + 0xffffffff & 0xffffffff;
            }
            // 0xa3c
            usleep(0x186a0);
            fflush((struct _IO_FILE *)*(int64_t *)g11);
            v8 = v6 + 0xffffffff & 0xffffffff;
            if (v6 == 1) {
                // break -> 0xa58
                break;
            }
        }
        // 0x9dc
        v4 = *(int32_t *)&g11;
        v5 = v8;
    }
    // 0xa58
    move(g16, 0, 2, 1);
    text(1, 0, 1, &g3);
    return 0;
}

// Address range: 0xae4 - 0xb1c
int64_t _start(int64_t a1) {
    // 0xae4
    int64_t v1; // 0xae4
    int64_t v2; // 0xae4
    __libc_start_main(g15, (int32_t)a1, (char **)&v1, g14, g7, (void (*)())v2);
    abort();
    return &g22;
}

// Address range: 0xb1c - 0xb30
int64_t call_weak_fn(void) {
    // 0xb1c
    if (g13 == 0) {
        // 0xb2c
        return 0;
    }
    // 0xb28
    return function_890(g13);
}

// Address range: 0xb30 - 0xb64
int64_t deregister_tm_clones(int64_t a1) {
    if ((int64_t)&g21 - (int64_t)&g20 == 14 || (uint64_t)((int64_t)&g21 - (int64_t)&g20) < 14 || g8 == 0) {
        // 0xb60
        return &g20;
    }
    // 0xb5c
    return _ITM_deregisterTMCloneTable(&g20, g8);
}

// Address range: 0xb68 - 0xba4
int64_t register_tm_clones(int64_t * a1, int64_t a2) {
    // 0xb68
    return &g20;
}

// Address range: 0xba8 - 0xbf0
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g20; // 0xbb8
    if (result != 0) {
        // 0xbe4
        return result;
    }
    int64_t v1 = 0; // 0xbc8
    if (g9 != 0) {
        // 0xbcc
        v1 = function_860(*(int64_t *)((int64_t)&g19 + 88));
    }
    // 0xbd8
    deregister_tm_clones(v1);
    *(char *)&g20 = 1;
    // 0xbe4
    return 1;
}

// Address range: 0xbf0 - 0xc20
int64_t frame_dummy(void) {
    // 0xbf0
    if (g6 == 0 || g18 == 0) {
        // 0xc00
        return register_tm_clones(&g6, 0);
    }
    // 0xc14
    return _Jv_RegisterClasses(&g6, g18);
}

// Address range: 0xc20 - 0xc28
int64_t function_c20(int64_t a1, int64_t a2) {
    // 0xc20
    int64_t v1; // 0xc20
    return register_tm_clones((int64_t *)v1, v1);
}

// Address range: 0xc28 - 0xc54
int64_t new_tower(int64_t a1) {
    // 0xc28
    int64_t v1; // 0xc28
    int64_t * mem = calloc(1, 4 * (int32_t)v1 + 16); // 0xc40
    int64_t result = (int64_t)mem; // 0xc40
    *mem = result + 16;
    return result;
}

// Address range: 0xc58 - 0xcd0
int64_t text(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    int32_t chars_printed = printf((char *)&g1); // 0xc9c
    if ((int32_t)a3 == 0) {
        // 0xcc0
        return chars_printed;
    }
    int64_t v1 = a3;
    int64_t v2 = (v1 & 0xffffffff) + 0xffffffff; // 0xcbc
    int32_t chars_printed2 = printf("%s", a4); // 0xcbc
    while ((int32_t)v1 != 1) {
        // 0xcac
        v1 = v2;
        v2 = (v1 & 0xffffffff) + 0xffffffff;
        chars_printed2 = printf("%s", a4);
    }
    // 0xcc0
    return chars_printed2;
}

// Address range: 0xcd0 - 0xd8c
int64_t add_disk(void) {
    // 0xcd0
    int64_t v1; // 0xcd0
    int64_t v2 = *(int64_t *)((8 * v1 & 0xfffffff8) + (int64_t)g10); // 0xd00
    int32_t * v3 = (int32_t *)(v2 + 8); // 0xd04
    int32_t v4 = *v3; // 0xd04
    *v3 = v4 + 1;
    int32_t v5 = v1; // 0xd18
    *(int32_t *)(*(int64_t *)v2 + (int64_t)(4 * v4)) = v5;
    printf((char *)&g1);
    if (v5 == 0) {
        // 0xd64
        usleep(0x186a0);
        return fflush((struct _IO_FILE *)*(int64_t *)g11);
    }
    int64_t v6; // 0xcd0
    int64_t v7 = v6;
    printf("%s", "==");
    v6 = (v7 & 0xffffffff) + 0xffffffff;
    while ((int32_t)v7 != 1) {
        // 0xd50
        v7 = v6;
        printf("%s", "==");
        v6 = (v7 & 0xffffffff) + 0xffffffff;
    }
    // 0xd64
    usleep(0x186a0);
    return fflush((struct _IO_FILE *)*(int64_t *)g11);
}

// Address range: 0xd90 - 0xe34
int64_t remove_disk(void) {
    // 0xd90
    int64_t v1; // 0xd90
    int64_t v2 = *(int64_t *)((8 * v1 & 0xfffffff8) + (int64_t)g10); // 0xdc0
    int32_t * v3 = (int32_t *)(v2 + 8); // 0xdcc
    int32_t v4 = *v3 - 1; // 0xdd8
    *v3 = v4;
    uint32_t v5 = *(int32_t *)(*(int64_t *)v2 + (int64_t)(4 * v4)); // 0xde8
    int64_t result = v5; // 0xde8
    printf((char *)&g1);
    if (v5 == 0) {
        // 0xe20
        return result;
    }
    int64_t v6 = result; // 0xdf4
    printf("%s", "  ");
    while (v6 != 1) {
        // 0xe0c
        v6 = v6 + 0xffffffff & 0xffffffff;
        printf("%s", "  ");
    }
    // 0xe20
    return result;
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0xe38 - 0xfc4
// Line range:    40 - 47
void move(uint32_t n, uint32_t from, int32_t to, uint32_t via) {
    if (n == 0) {
        // 0xfa8
        return;
    }
    int64_t v1 = via;
    int64_t v2 = from;
    int64_t v3 = (int64_t)n + 0xffffffff; // 0xe98
    int32_t v4 = v3; // 0xea4
    move(v4, (int32_t)v2, (int32_t)v1, to);
    int64_t v5 = *(int64_t *)((8 * v2 & 0xfffffff8) + (int64_t)g10); // 0xec0
    int32_t * v6 = (int32_t *)(v5 + 8); // 0xec8
    int32_t v7 = *v6 - 1; // 0xed8
    *v6 = v7;
    uint32_t v8 = *(int32_t *)(*(int64_t *)v5 + (int64_t)(4 * v7)); // 0xee8
    int64_t v9 = v8; // 0xee8
    printf((char *)&g1);
    int64_t v10 = v9; // 0xef8
    int64_t v11; // 0xe38
    if (v8 != 0) {
        v11 = v10;
        printf("%s", "  ");
        v10 = v11 + 0xffffffff & 0xffffffff;
        while (v11 != 1) {
            // 0xefc
            v11 = v10;
            printf("%s", "  ");
            v10 = v11 + 0xffffffff & 0xffffffff;
        }
    }
    int64_t v12 = *(int64_t *)(8 * (int64_t)to + (int64_t)g10); // 0xf2c
    int32_t * v13 = (int32_t *)(v12 + 8); // 0xf30
    int32_t v14 = *v13; // 0xf30
    *v13 = v14 + 1;
    *(int32_t *)(*(int64_t *)v12 + (int64_t)(4 * v14)) = v8;
    printf((char *)&g1);
    int64_t v15 = v9; // 0xf60
    int64_t v16; // 0xe38
    if (v8 != 0) {
        v16 = v15;
        printf("%s", "==");
        v15 = v16 + 0xffffffff & 0xffffffff;
        while (v16 != 1) {
            // 0xf64
            v16 = v15;
            printf("%s", "==");
            v15 = v16 + 0xffffffff & 0xffffffff;
        }
    }
    // 0xf78
    usleep(0x186a0);
    fflush((struct _IO_FILE *)*(int64_t *)g11);
    int64_t v17 = v1 & 0xffffffff; // 0xf9c
    int64_t v18 = v3 & 0xffffffff; // 0xf9c
    while (v4 != 0) {
        // 0xe94
        v1 = v2;
        v2 = v17;
        v3 = v18 + 0xffffffff;
        v4 = v3;
        move(v4, (int32_t)v2, (int32_t)v1, to);
        v5 = *(int64_t *)((8 * v2 & 0xfffffff8) + (int64_t)g10);
        v6 = (int32_t *)(v5 + 8);
        v7 = *v6 - 1;
        *v6 = v7;
        v8 = *(int32_t *)(*(int64_t *)v5 + (int64_t)(4 * v7));
        v9 = v8;
        printf((char *)&g1);
        v10 = v9;
        if (v8 != 0) {
            v11 = v10;
            printf("%s", "  ");
            v10 = v11 + 0xffffffff & 0xffffffff;
            while (v11 != 1) {
                // 0xefc
                v11 = v10;
                printf("%s", "  ");
                v10 = v11 + 0xffffffff & 0xffffffff;
            }
        }
        // 0xf10
        v12 = *(int64_t *)(8 * (int64_t)to + (int64_t)g10);
        v13 = (int32_t *)(v12 + 8);
        v14 = *v13;
        *v13 = v14 + 1;
        *(int32_t *)(*(int64_t *)v12 + (int64_t)(4 * v14)) = v8;
        printf((char *)&g1);
        v15 = v9;
        if (v8 != 0) {
            v16 = v15;
            printf("%s", "==");
            v15 = v16 + 0xffffffff & 0xffffffff;
            while (v16 != 1) {
                // 0xf64
                v16 = v15;
                printf("%s", "==");
                v15 = v16 + 0xffffffff & 0xffffffff;
            }
        }
        // 0xf78
        usleep(0x186a0);
        fflush((struct _IO_FILE *)*(int64_t *)g11);
        v17 = v1 & 0xffffffff;
        v18 = v3 & 0xffffffff;
    }
}

// Address range: 0xfc8 - 0x1040
int64_t __libc_csu_init(void) {
    // 0xfc8
    int64_t v1; // 0xfc8
    int64_t result = _init(v1); // 0xffc
    if ((int64_t)&g5 - (int64_t)&g4 >> 3 == 0) {
        // 0x102c
        return result;
    }
    // 0x100c
    return v1 & 0xffffffff;
}

// Address range: 0x1040 - 0x1044
int64_t __libc_csu_fini(void) {
    // 0x1040
    int64_t result; // 0x1040
    return result;
}

// Address range: 0x1044 - 0x1054
int64_t _fini(int64_t a1) {
    // 0x1044
    int64_t result; // 0x1044
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// int fflush(FILE * stream);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// int usleep(__useconds_t useconds);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 27

