//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

void add_disk(uint32_t i, int32_t d);
void move(int32_t n, uint32_t from, int32_t to, int32_t via);
int64_t new_tower(int32_t cap);
int32_t remove_disk(uint32_t i);
void text(int32_t y, int32_t i, uint32_t d, char * s);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[%d;%dH"; // 0x400af0
char * g2 = "\x1b[H\x1b[J"; // 0x400b02
struct _IO_FILE * g3 = NULL; // 0x411058
int32_t height = 0; // 0x411080
int64_t t = 0; // 0x411068

// ------------------------ Functions -------------------------

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x4007b0 - 0x4007d8
// Line range:    8 - 12
int64_t new_tower(int32_t cap) {
    // 0x4007b0
    int64_t v1; // 0x4007b0
    int64_t * mem = calloc(1, (int32_t)__asm_sbfiz(v1, (int64_t)cap, 2, 32) + 16); // 0x4007c4
    int64_t result = (int64_t)mem; // 0x4007c4
    *mem = result + 16;
    return result;
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x4007d8 - 0x400850
// Line range:    18 - 22
void text(int32_t y, int32_t i, uint32_t d, char * s) {
    // 0x4007d8
    __asm_bfi(1, i, 1, 31);
    printf((char *)&g1);
    if (d == 0) {
        // 0x400840
        return;
    }
    int64_t v1 = d; // 0x400828
    printf("%s", s);
    while ((int32_t)v1 != 0) {
        // 0x40082c
        v1 &= 0xffffffff;
        printf("%s", s);
    }
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x400850 - 0x4008c0
// Line range:    24 - 30
void add_disk(uint32_t i, int32_t d) {
    // 0x400850
    int64_t v1; // 0x400850
    int64_t * v2 = (int64_t *)(__asm_sbfiz(v1, (int64_t)i, 3, 32) + (int64_t)&t); // 0x400868
    int32_t * v3 = (int32_t *)(*v2 + 8); // 0x400874
    int32_t v4 = *v3; // 0x400874
    *v3 = v4 + 1;
    *(int32_t *)(*(int64_t *)*v2 + 4 * (int64_t)v4) = d;
    text(*(int32_t *)(*v2 + 8), i, d, "==");
    usleep(0x186a0);
    fflush(g3);
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x4008c0 - 0x400924
// Line range:    33 - 37
int32_t remove_disk(uint32_t i) {
    // 0x4008c0
    int64_t v1; // 0x4008c0
    int64_t * v2 = (int64_t *)(__asm_sbfiz(v1, (int64_t)i, 3, 32) + (int64_t)&t); // 0x4008dc
    int32_t * v3 = (int32_t *)(*v2 + 8); // 0x4008ec
    int64_t v4 = (int64_t)*v3 - 1; // 0x4008f0
    *v3 = (int32_t)v4;
    int64_t v5 = *v2; // 0x4008f8
    int32_t result = *(int32_t *)(*(int64_t *)v5 + 4 * v4); // 0x400904
    text(*(int32_t *)(v5 + 8) + 1, i, result, "  ");
    return result;
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x400924 - 0x400994
// Line range:    40 - 47
void move(int32_t n, uint32_t from, int32_t to, int32_t via) {
    if (n == 0) {
        // 0x400984
        return;
    }
    int64_t v1 = from; // 0x400940
    int64_t v2 = n - 1; // 0x400940
    int64_t v3 = via;
    int32_t v4 = v1; // 0x40094c
    move((int32_t)v2, v4, (int32_t)v3, to);
    add_disk(to, remove_disk(v4));
    int64_t v5 = v2 + 0xffffffff; // 0x400970
    int64_t v6 = v1; // 0x400980
    v1 = v3 & 0xffffffff;
    v2 = v5 & 0xffffffff;
    while ((int32_t)v5 != -1) {
        // 0x400944
        v3 = v6;
        v4 = v1;
        move((int32_t)v2, v4, (int32_t)v3, to);
        add_disk(to, remove_disk(v4));
        v5 = v2 + 0xffffffff;
        v6 = v1;
        v1 = v3 & 0xffffffff;
        v2 = v5 & 0xffffffff;
    }
}

// From module:   /mnt/from_holdec/./movfuscator/hanoi/source.c
// Address range: 0x400994 - 0x400a60
// Line range:    49 - 61
int main(int c, char ** v) {
    // 0x400994
    puts((char *)&g2);
    int64_t v1; // 0x400994
    if (c < 2) {
        // 0x4009d4
        v1 = 8;
        goto lab_0x4009d8;
    } else {
        int32_t str_as_i = atoi((char *)*(int64_t *)((int64_t)v + 8)); // 0x4009c4
        v1 = str_as_i;
        if (str_as_i > 0) {
            goto lab_0x4009d8;
        } else {
            // 0x4009d4
            v1 = 8;
            goto lab_0x4009d8;
        }
    }
  lab_0x4009d8:
    // 0x4009d8
    height = v1;
    int64_t v2 = 0; // 0x4009e8
    int64_t v3 = new_tower((int32_t)v1); // 0x4009f0
    int64_t v4 = height; // 0x4009f4
    *(int64_t *)(v2 + (int64_t)&t) = v3;
    int64_t v5 = v2 + 8; // 0x4009fc
    int64_t v6 = v4; // 0x400a04
    v2 = v5;
    while (v5 != 24) {
        // 0x4009ec
        v3 = new_tower((int32_t)v6);
        v4 = height;
        *(int64_t *)(v2 + (int64_t)&t) = v3;
        v5 = v2 + 8;
        v6 = v4;
        v2 = v5;
    }
    // 0x400a08
    if (height == 0) {
        // 0x400a20
        move(0, 0, 2, 1);
        text(1, 0, 1, (char *)0x400b09);
        return 0;
    }
    add_disk(0, (int32_t)v4);
    int64_t v7 = v4 + 0xffffffff; // 0x400a18
    int64_t v8 = v7 & 0xffffffff; // 0x400a1c
    while ((int32_t)v7 != 0) {
        // 0x400a0c
        add_disk(0, (int32_t)v8);
        v7 = v8 + 0xffffffff;
        v8 = v7 & 0xffffffff;
    }
    // 0x400a20
    move(height, 0, 2, 1);
    text(1, 0, 1, (char *)0x400b09);
    return 0;
}

// --------------- Dynamically Linked Functions ---------------

// int atoi(const char * nptr);
// void * calloc(size_t nmemb, size_t size);
// int fflush(FILE * stream);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// int usleep(__useconds_t useconds);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (3.8.1)
// Detected functions: 6

