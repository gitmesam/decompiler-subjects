//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int32_t aa(int32_t s, int32_t a);
int32_t ab(int32_t s);
int32_t ac(void);
int32_t ad(int32_t d, int32_t a);
int32_t ae(int32_t s);
int32_t am(void);
int64_t an(void);
int32_t ao(int32_t a);
int32_t ap(int32_t a, uint32_t z);
int32_t aq(int32_t a);
int32_t ar(int32_t s);
int32_t au(int32_t F);
int32_t av(void);
int32_t aw(int32_t d);
int32_t ax(int32_t d);
int32_t B(void);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(void);
int32_t E(int32_t a, uint32_t d);
int64_t frame_dummy(void);
int64_t function_1120(int64_t a1, int64_t a2);
int64_t * function_d80(int64_t * dest, int64_t * src, int32_t n);
int64_t function_d90(int64_t a1);
int32_t function_da0(struct _IO_FILE * stream);
struct _IO_FILE * function_db0(char * filename, char * modes);
int32_t function_dc0(int32_t c);
int32_t function_dd0(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_de0(struct _IO_FILE * stream);
int64_t * function_df0(int32_t nmemb, int32_t size);
int64_t function_e00(int64_t a1);
void function_e10(void);
int32_t function_e20(char * s);
int32_t function_e30(char * nptr, char ** endptr, int32_t base);
int32_t function_e40(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * function_e50(char * dest, char * src);
char * function_e60(char * haystack, char * needle);
int32_t function_e70(int32_t c);
int32_t H(int32_t a);
int32_t I(int32_t a);
int32_t L(int32_t a);
int32_t M(int32_t a);
int64_t register_tm_clones(void);
int32_t S(int32_t s);
int64_t w(void);
int64_t W(int64_t a1);
int32_t X(int32_t s);
int32_t x(int32_t d, int32_t a);

// --------------------- Global Variables ---------------------

int32_t R = 0; // 0x130a8
int32_t Z = 0; // 0x130ac
int32_t ak = 0; // 0x130b4
int32_t al = 0; // 0x130dc
int64_t g1 = 0x10f0; // 0x12d00
int64_t g2 = 0x10a8; // 0x12d08
int64_t g3 = 0; // 0x12d10
void (*g4)() = (void (*)())0x26e8; // 0x12f10
int64_t g5 = 0; // 0x12f18
int32_t * g6 = (int32_t *)0x13094; // 0x12f20
int32_t g7 = 304; // 0x12f21
int32_t g8 = 0x13098; // 0x12f28
int32_t g9 = 0x1309c; // 0x12f30
int32_t g10 = 0x130a0; // 0x12f38
int32_t g11 = 0; // 0x12f3c
int32_t * g12 = (int32_t *)0x130a4; // 0x12f40
int64_t g14 = 0; // 0x12f50
int32_t g16 = 0x130b0; // 0x12f60
int32_t g17 = 304; // 0x12f61
int32_t g18 = 0; // 0x12f64
int64_t g19 = 0; // 0x12f68
int32_t g21 = 304; // 0x12f71
void (*g22)() = (void (*)())0x2670; // 0x12f78
int32_t g23 = 0x130b8; // 0x12f80
int64_t g24; // 0x12f88
int64_t g25; // 0x12f90
int32_t g26 = 0x130c4; // 0x12f98
char * g27 = "\xc8\x30\x01"; // 0x12fa0
int32_t g28 = 0x130cc; // 0x12fa8
int32_t * g29 = (int32_t *)0x130d000000000; // 0x12fac
char * g30 = "\xd0\x30\x01"; // 0x12fb0
int32_t g31 = 304; // 0x12fb1
int32_t g32 = 0; // 0x12fb3
int32_t g33 = 0; // 0x12fb4
int32_t g34 = 0x130d4; // 0x12fb8
int32_t g36 = 3712; // 0x12fc8
int64_t g37 = 0; // 0x12fd0
int64_t g39 = 3424; // 0x13000
int64_t g40 = 0; // 0x13090
int64_t g41 = 0; // 0x13097
int32_t * g42 = (int32_t *)-0x1811f59bc6e29751; // 0x250
int32_t g43 = 0x6d232b2b; // 0x2700
int32_t g44;
int32_t y = 0; // 0x130d8
int32_t * g13 = &R; // 0x12f48
int32_t * g15 = &Z; // 0x12f58
int32_t * g20 = &ak; // 0x12f70
int32_t * g35 = &y; // 0x12fc0
int32_t * g38 = &al; // 0x12fe0

// ------------------------ Functions -------------------------

// Address range: 0xd40 - 0xd54
int64_t _init(int64_t a1) {
    // 0xd40
    return call_weak_fn();
}

// Address range: 0xd80 - 0xd90
int64_t * function_d80(int64_t * dest, int64_t * src, int32_t n) {
    // 0xd80
    return memcpy(dest, src, n);
}

// Address range: 0xd90 - 0xda0
int64_t function_d90(int64_t a1) {
    // 0xd90
    return __cxa_finalize();
}

// Address range: 0xda0 - 0xdb0
int32_t function_da0(struct _IO_FILE * stream) {
    // 0xda0
    return fclose(stream);
}

// Address range: 0xdb0 - 0xdc0
struct _IO_FILE * function_db0(char * filename, char * modes) {
    // 0xdb0
    return fopen(filename, modes);
}

// Address range: 0xdc0 - 0xdd0
int32_t function_dc0(int32_t c) {
    // 0xdc0
    return isspace(c);
}

// Address range: 0xdd0 - 0xde0
int32_t function_dd0(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xdd0
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xde0 - 0xdf0
int32_t function_de0(struct _IO_FILE * stream) {
    // 0xde0
    return fgetc(stream);
}

// Address range: 0xdf0 - 0xe00
int64_t * function_df0(int32_t nmemb, int32_t size) {
    // 0xdf0
    return calloc(nmemb, size);
}

// Address range: 0xe00 - 0xe10
int64_t function_e00(int64_t a1) {
    // 0xe00
    return __gmon_start__();
}

// Address range: 0xe10 - 0xe20
void function_e10(void) {
    // 0xe10
    abort();
}

// Address range: 0xe20 - 0xe30
int32_t function_e20(char * s) {
    // 0xe20
    return puts(s);
}

// Address range: 0xe30 - 0xe40
int32_t function_e30(char * nptr, char ** endptr, int32_t base) {
    // 0xe30
    return strtol(nptr, endptr, base);
}

// Address range: 0xe40 - 0xe50
int32_t function_e40(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0xe40
    return fwrite(ptr, size, n, s);
}

// Address range: 0xe50 - 0xe60
char * function_e50(char * dest, char * src) {
    // 0xe50
    return strcpy(dest, src);
}

// Address range: 0xe60 - 0xe70
char * function_e60(char * haystack, char * needle) {
    // 0xe60
    return strstr(haystack, needle);
}

// Address range: 0xe70 - 0xe80
int32_t function_e70(int32_t c) {
    // 0xe70
    return isalnum(c);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0xe80 - 0xfe0
// Line range:    596 - 615
int main(int d, char ** a) {
    if (d > 2) {
        int64_t * mem = calloc(1, 0x1869f); // 0xed0
        *(int32_t *)*(int64_t *)0x12fa0 = (int32_t)(int64_t)mem;
        char * dest_str = strcpy((char *)mem, " int if else while break return for define main "); // 0xef0
        *(int32_t *)*(int64_t *)0x12f20 = (int32_t)(int64_t)dest_str + 48;
        int32_t mem2 = (int64_t)calloc(1, 0x1869f); // 0xf24
        int32_t * v1 = (int32_t *)*(int64_t *)0x12fb0; // 0xf24
        *v1 = mem2;
        int32_t * v2 = (int32_t *)*(int64_t *)0x12f88; // 0xf28
        *v2 = mem2;
        int32_t * v3 = (int32_t *)(int64_t)g16; // 0xf34
        int32_t mem3 = (int64_t)calloc(1, 0x1869f); // 0xf40
        *v3 = mem3;
        *(int32_t *)*(int64_t *)0x12f90 = mem3;
        int64_t * mem4 = calloc(1, 0x1869f); // 0xf54
        *(int32_t *)*(int64_t *)0x12f30 = (int32_t)(int64_t)mem4;
        int64_t v4 = 0x100000000 * (int64_t)a; // 0xf64
        int32_t file_path = *(int32_t *)(v4 + 0x400000000 >> 32); // 0xf7c
        struct _IO_FILE * file = fopen((char *)(int64_t)file_path, (char *)0x27f7); // 0xf80
        *g20 = (int32_t)(int64_t)file;
        *g35 = 0x8048000 - *v2;
        *v1 = *v1 + 252;
        *v3 = (int32_t)&g21;
        w();
        av();
        ar(0);
        au(*(int32_t *)(v4 + 0x800000000 >> 32));
    } else {
        // 0xe98
        puts("usage: otccelf file.c outfile");
    }
    // 0xea4
    return 0;
}

// Address range: 0xfe0 - 0x1018
int64_t _start(int64_t a1) {
    // 0xfe0
    int64_t v1; // 0xfe0
    int64_t v2; // 0xfe0
    __libc_start_main((int64_t)g36, (int32_t)a1, (char **)&v1, g22, g4, (void (*)())v2);
    abort();
    return &g44;
}

// Address range: 0x1018 - 0x102c
int64_t call_weak_fn(void) {
    // 0x1018
    if (g19 == 0) {
        // 0x1028
        return 0;
    }
    // 0x1024
    return function_e00(g19);
}

// Address range: 0x1030 - 0x1064
int64_t deregister_tm_clones(void) {
    if ((int64_t)&g41 - (int64_t)&g40 == 14 || (uint64_t)((int64_t)&g41 - (int64_t)&g40) < 14 || g5 == 0) {
        // 0x1060
        return &g40;
    }
    // 0x105c
    return _ITM_deregisterTMCloneTable(&g40, g5);
}

// Address range: 0x1068 - 0x10a4
int64_t register_tm_clones(void) {
    // 0x1068
    return &g40;
}

// Address range: 0x10a8 - 0x10f0
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g40; // 0x10b8
    if (result != 0) {
        // 0x10e4
        return result;
    }
    // 0x10c0
    if (g14 != 0) {
        // 0x10cc
        function_d90(*(int64_t *)((int64_t)&g39 + 136));
    }
    // 0x10d8
    deregister_tm_clones();
    *(char *)&g40 = 1;
    // 0x10e4
    return 1;
}

// Address range: 0x10f0 - 0x1120
int64_t frame_dummy(void) {
    // 0x10f0
    if (g3 == 0 || g37 == 0) {
        // 0x1100
        return register_tm_clones();
    }
    // 0x1114
    return _Jv_RegisterClasses(&g3, g37);
}

// Address range: 0x1120 - 0x1128
int64_t function_1120(int64_t a1, int64_t a2) {
    // 0x1120
    return register_tm_clones();
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1128 - 0x1148
// Line range:    20 - 22
int32_t L(int32_t a) {
    // 0x1128
    *g6 = (int32_t)&g7;
    *(char *)(0x100000000 * (int64_t)g6 >> 32) = (char)a;
    return a;
}

// Address range: 0x1148 - 0x11c0
// Demangled:     wchar_t
int64_t w(void) {
    int64_t result = *(int64_t *)0x12f40; // 0x1154
    int32_t * v1 = (int32_t *)result; // 0x1158
    int32_t v2 = *v1; // 0x1158
    int32_t * v3; // 0x1148
    int64_t c; // 0x1148
    if (v2 == 0) {
        int32_t stream = *(int32_t *)&g20; // 0x11b0
        v3 = (int32_t *)(int64_t)g34;
        c = fgetc((struct _IO_FILE *)(int64_t)stream);
    } else {
        // 0x1168
        *v1 = v2 + 1;
        int32_t * v4 = (int32_t *)(int64_t)g34;
        unsigned char v5 = *(char *)(int64_t)v2; // 0x1178
        *v4 = (int32_t)v5;
        if (v5 != 2) {
            // 0x119c
            return result;
        }
        // 0x1188
        *v1 = 0;
        v3 = v4;
        c = (int64_t)*(int32_t *)&g38;
    }
    // 0x1198
    *v3 = (int32_t)c;
    // 0x119c
    return c;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x11c0 - 0x11f8
// Line range:    33 - 35
int32_t am(void) {
    int32_t c = g34; // 0x11d4
    return isalnum(c) | (int32_t)(c == 95);
}

// Address range: 0x11f8 - 0x123c
int64_t an(void) {
    uint32_t v1 = g34;
    int64_t result = v1;
    if (v1 != 92) {
        // 0x1230
        return result;
    }
    // 0x1218
    w();
    int64_t result2 = g34; // 0x1224
    if (g34 == 110) {
        // 0x1228
        *(int32_t *)result = 10;
        result2 = 10;
    }
    // 0x1230
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x123c - 0x158c
// Line range:    42 - 116
int32_t av(void) {
    int32_t * v1; // 0x123c
    int32_t * v2; // 0x123c
    int32_t * v3; // 0x123c
    int64_t result; // 0x123c
    int64_t v4; // 0x123c
    while (true) {
        // 0x1264
        if ((isspace(g34) || (int32_t)(g34 == 35)) != 0) {
            int32_t v5; // 0x1358
            if (g34 == 35) {
                // 0x1324
                w();
                av();
                if (g28 == (int32_t)".1") {
                    // 0x1338
                    av();
                    L(32);
                    *(int32_t *)(int64_t)g28 = 1;
                    v5 = *(int32_t *)&g6;
                    *(int32_t *)(int64_t)(int32_t)&g29 = v5;
                }
                // 0x136c
                L(g34);
                if (g34 != 10) {
                    w();
                    L(g34);
                    while (g34 != 10) {
                        // 0x138c
                        w();
                        L(g34);
                    }
                }
                // 0x1378
                L(2);
            }
            // 0x1384
            w();
            while ((isspace(g34) || (int32_t)(g34 == 35)) != 0) {
                // 0x1320
                if (g34 == 35) {
                    // 0x1324
                    w();
                    av();
                    if (g28 == (int32_t)".1") {
                        // 0x1338
                        av();
                        L(32);
                        *(int32_t *)(int64_t)g28 = 1;
                        v5 = *(int32_t *)&g6;
                        *(int32_t *)(int64_t)(int32_t)&g29 = v5;
                    }
                    // 0x136c
                    L(g34);
                    if (g34 != 10) {
                        w();
                        L(g34);
                        while (g34 != 10) {
                            // 0x138c
                            w();
                            L(g34);
                        }
                    }
                    // 0x1378
                    L(2);
                }
                // 0x1384
                w();
            }
        }
        // 0x1284
        v2 = (int32_t *)(int64_t)g28;
        v3 = (int32_t *)(int64_t)g8;
        *v2 = g34;
        *v3 = 0;
        if (am() == 0) {
            // 0x145c
            w();
            if (g28 == 39) {
                // break -> 0x146c
                break;
            }
            // 0x14a4
            if (g28 == 47 != (g34 == 42)) {
                // 0x14f8
                v1 = (int32_t *)(int64_t)g23;
                v4 = &g43;
                goto lab_0x1510;
            }
            // 0x14b8
            w();
            if (g34 != 0) {
                w();
                // 0x14d4
                while (g34 != 42) {
                    // 0x14d4
                    w();
                }
                // 0x14e0
                if (g34 == 47) {
                    // 0x14f0
                    *(int32_t *)(int64_t)g34 = 0;
                }
                // 0x14d4
                while (g34 != 0) {
                    w();
                    // 0x14d4
                    while (g34 != 42) {
                        // 0x14d4
                        w();
                    }
                    // 0x14e0
                    if (g34 == 47) {
                        // 0x14f0
                        *(int32_t *)(int64_t)g34 = 0;
                    }
                }
            }
        } else {
            // 0x12a0
            L(32);
            *g15 = *(int32_t *)&g6;
            if (am() != 0) {
                L(g34);
                w();
                while (am() != 0) {
                    // 0x1398
                    L(g34);
                    w();
                }
            }
            uint32_t v6 = g28;
            int64_t v7 = v6;
            if (v6 >= 57 != v6 != 57) {
                int32_t str_as_l = strtol((char *)(int64_t)*(int32_t *)&g15, NULL, 0); // 0x12f0
                *(int32_t *)(int64_t)g23 = str_as_l;
                *(int32_t *)v7 = 2;
                result = 2;
                return result;
            }
            // 0x13a8
            *(char *)(int64_t)*(int32_t *)&g6 = 32;
            int32_t v8 = *(int32_t *)&g15; // 0x13c0
            int32_t str = *(int32_t *)&g27; // 0x13d0
            char * substr_pos = strstr((char *)(int64_t)str, (char *)(int64_t)(v8 - 1)); // 0x13d8
            int32_t * v9 = (int32_t *)v7; // 0x13e0
            *v9 = (int32_t)(int64_t)substr_pos - str;
            *(char *)(int64_t)*(int32_t *)&g6 = 0;
            *v9 = 8 * (int32_t)&g36;
            result = (int64_t)(8 * (int32_t)&g36);
            if (8 * (int32_t)&g36 <= (int32_t)".1") {
              lab_0x1308:
                // 0x1308
                return result;
            }
            int32_t v10 = g9 + 8 * (int32_t)&g36; // 0x1410
            int64_t v11 = v10; // 0x1410
            *v9 = v10;
            result = v11;
            if (*(int32_t *)(int64_t)v10 != 1) {
                // 0x1308
                return result;
            }
            // 0x1428
            *g12 = *(int32_t *)(0x100000000 * v11 + 0x400000000 >> 32);
            *g38 = g34;
        }
        // 0x1454
        w();
    }
    // 0x146c
    *v2 = 2;
    an();
    *(int32_t *)(int64_t)g23 = g34;
    w();
    return w();
  lab_0x1510:;
    int64_t v12 = 0x100000000 * v4;
    unsigned char v13 = *(char *)(v12 >> 32); // 0x1518
    result = v4;
    int64_t v14; // 0x123c
    int32_t v15; // 0x123c
    unsigned char v16; // 0x152c
    int64_t v17; // 0x123c
    if (v13 == 0) {
        return result;
    } else {
        int64_t v18 = v12 + 0x300000000 >> 32; // 0x1528
        v16 = *(char *)(v12 + 0x100000000 >> 32);
        *v1 = 0;
        int32_t v19 = (int32_t)*(char *)(v18 - 1) - 98; // 0x1540
        *v3 = v19;
        v14 = v18;
        v15 = v19;
        v17 = v18;
        if (v19 < 0) {
            goto lab_0x1578;
        } else {
            goto lab_0x154c;
        }
    }
  lab_0x1578:;
    int64_t v20 = v17 + 1; // 0x153c
    *v1 = v15 + 64 + 64 * g23;
    int32_t v21 = (int32_t)*(char *)v17 - 98; // 0x1540
    *v3 = v21;
    v14 = v20;
    v15 = v21;
    v17 = v20;
    if (v21 < 0) {
        goto lab_0x1578;
    } else {
        goto lab_0x154c;
    }
  lab_0x154c:;
    int64_t v22 = v14 & 0xffffffff;
    v4 = v22;
    if (g28 == (int32_t)v13 == (v16 == 64 || g34 == (int32_t)v16)) {
        // 0x155c
        result = v22;
        if ((int64_t)g34 == (int64_t)v16) {
            // 0x1564
            w();
            *(int32_t *)(int64_t)g28 = 1;
            result = 1;
            return result;
        } else {
            return result;
        }
    } else {
        goto lab_0x1510;
    }
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x158c - 0x15c0
// Line range:    128 - 131
int32_t aw(int32_t d) {
    // 0x158c
    if (d != -1 != d != 0) {
        // 0x15a0
        return d;
    }
    int32_t * v1 = (int32_t *)(int64_t)g16; // 0x15b0
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)d;
    int32_t result = d >> 8; // 0x15b8
    if (result != -1 != result != 0) {
        // 0x15a0
        return result;
    }
    int32_t result2 = result; // 0x159c
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)result2;
    result2 >>= 8;
    while (result2 != -1 == (result2 != 0)) {
        // 0x15a4
        *v1 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)result2;
        result2 >>= 8;
    }
    // 0x15a0
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x15c0 - 0x15fc
// Line range:    134 - 139
int32_t E(int32_t a, uint32_t d) {
    // 0x15c0
    *(char *)(int64_t)a = (char)d;
    *(char *)(int64_t)(a + 1) = (char)(d / 256);
    int32_t result = a + 3; // 0x15dc
    *(char *)(int64_t)(a + 2) = (char)(d / 0x10000);
    *(char *)(int64_t)result = (char)(d / 0x1000000);
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x15fc - 0x163c
// Line range:    140 - 143
int32_t ao(int32_t a) {
    unsigned char v1 = *(char *)(int64_t)(a + 1); // 0x1604
    unsigned char v2 = *(char *)(int64_t)(a + 2); // 0x1610
    unsigned char v3 = *(char *)(int64_t)(a + 3); // 0x162c
    int64_t v4; // 0x15fc
    return 256 * (int32_t)v1 | (int32_t)v4 % 256 | 0x10000 * (int32_t)v2 | 0x1000000 * (int32_t)v3;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x163c - 0x1700
// Line range:    144 - 157
int32_t ap(int32_t a, uint32_t z) {
    // 0x163c
    if (a == 0) {
        // 0x165c
        return 0;
    }
    int32_t v1 = ao(a); // 0x16a0
    int32_t v2; // 0x167c
    int32_t v3; // 0x163c
    if (*(char *)(0x100000000 * (int64_t)a - 0x100000000 >> 32) == 5) {
        // 0x16bc
        if (*(int32_t *)&g24 <= z == *(int32_t *)&g30 > z) {
            // 0x16dc
            v3 = *(int32_t *)&g35 + z;
        } else {
            // 0x1660
            v2 = *(int32_t *)&g35;
            v3 = z - *(int32_t *)&g25 + *(int32_t *)&g13 + v2;
        }
    } else {
        // 0x1688
        v3 = z - 4 - a;
    }
    int32_t result = E(a, v3); // 0x16f4
    while (v1 != 0) {
        uint32_t v4 = v1;
        v1 = ao(v4);
        if (*(char *)(0x100000000 * (int64_t)v4 - 0x100000000 >> 32) == 5) {
            // 0x16bc
            if (*(int32_t *)&g24 <= z == *(int32_t *)&g30 > z) {
                // 0x16dc
                v3 = *(int32_t *)&g35 + z;
            } else {
                // 0x1660
                v2 = *(int32_t *)&g35;
                v3 = z - *(int32_t *)&g25 + *(int32_t *)&g13 + v2;
            }
        } else {
            // 0x1688
            v3 = z - 4 - v4;
        }
        // 0x16e8
        result = E(v4, v3);
    }
    // 0x165c
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1700 - 0x1710
// Line range:    158 - 159
int32_t H(int32_t a) {
    // 0x1700
    return ap(a, g16);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1710 - 0x1748
// Line range:    161 - 167
// Demangled:     long long
int32_t x(int32_t d, int32_t a) {
    // 0x1710
    aw(d);
    uint32_t v1 = g16;
    E(v1, a);
    *(int32_t *)(int64_t)v1 = (int32_t)&g18;
    return g16;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1748 - 0x1754
// Line range:    168 - 169
int32_t M(int32_t a) {
    // 0x1748
    return x(184, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1754 - 0x1760
// Line range:    171 - 172
int32_t I(int32_t a) {
    // 0x1754
    return x(233, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1760 - 0x178c
// Line range:    174 - 176
int32_t aa(int32_t s, int32_t a) {
    // 0x1760
    aw(0xfc085);
    return x(s + 132, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x178c - 0x17c4
// Line range:    178 - 183
int32_t aq(int32_t a) {
    // 0x178c
    aw(0xc139);
    M(0);
    aw(15);
    aw(a + 144);
    return aw(192);
}

// Address range: 0x17c4 - 0x1818
int64_t W(int64_t a1) {
    // 0x17c4
    int64_t v1; // 0x17c4
    aw((int32_t)v1 + 131);
    int32_t v2 = v1;
    if (v2 == 0 || v2 > 511) {
        int32_t * v3 = (int32_t *)(0x100000000 * v1 + 0x400000000 >> 32); // 0x1804
        int32_t result = x(5, *v3); // 0x1808
        *v3 = result;
        return result;
    }
    // 0x17ec
    return x(133, v2);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1818 - 0x1820
// Line range:    336 - 337
int32_t B(void) {
    // 0x1818
    return X(11);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1820 - 0x1b68
// Line range:    195 - 299
int32_t ab(int32_t s) {
    uint32_t v1 = g28; // 0x1840
    int64_t v2 = v1; // 0x1840
    int32_t v3; // 0x1820
    int64_t v4; // 0x1820
    int64_t v5; // 0x1820
    int64_t v6; // 0x1820
    int64_t v7; // 0x1820
    int64_t v8; // 0x1820
    if (v1 == 34) {
        // 0x184c
        M(*(int32_t *)&g35 + (int32_t)(int64_t)g30);
        if (g34 != 34) {
            an();
            int32_t v9 = *(int32_t *)&g30; // 0x18ac
            *(int32_t *)g30 = (int32_t)&g31;
            *(char *)(int64_t)v9 = (char)g34;
            w();
            while (g34 != 34) {
                // 0x18a8
                an();
                v9 = *(int32_t *)&g30;
                *(int32_t *)g30 = (int32_t)&g31;
                *(char *)(int64_t)v9 = (char)g34;
                w();
            }
        }
        // 0x1880
        *(char *)(0x100000000 * (int64_t)g30 >> 32) = 0;
        *(int32_t *)g30 = (int32_t)&g33;
        w();
        goto lab_0x18a0;
    } else {
        // 0x18cc
        av();
        if (v1 == 2) {
            // 0x18f4
            M(g23);
            v4 = 2;
            v7 = 1;
            goto lab_0x1900;
        } else {
            if (g8 == 2) {
                // 0x199c
                ab(0);
                x(185, 0);
                v3 = g23;
                v6 = v2;
                if (v1 == 33) {
                    // 0x19bc
                    aq(g23);
                    v4 = 33;
                    v7 = 1;
                    goto lab_0x1900;
                } else {
                    goto lab_0x1a4c;
                }
            } else {
                switch (v1) {
                    case 40: {
                        // 0x19cc
                        B();
                        goto lab_0x18a0;
                    }
                    case 42: {
                        // 0x19dc
                        av();
                        av();
                        av();
                        int64_t v10 = g28; // 0x19f4
                        if (g28 == 42) {
                            // 0x19f8
                            av();
                            av();
                            av();
                            av();
                            v10 = 0;
                        }
                        // 0x1a0c
                        av();
                        ab(0);
                        if (g28 == 61) {
                            // 0x1a28
                            av();
                            aw(80);
                            B();
                            aw(89);
                            v3 = v10 == 256 ? 393 : 392;
                            v6 = v10;
                            goto lab_0x1a4c;
                        } else {
                            int32_t v11 = v10; // 0x1a58
                            v5 = v10;
                            v8 = 1;
                            if (v11 == 0) {
                                goto lab_0x1900_2;
                            } else {
                                // 0x1a5c
                                aw(v11 == 256 ? 139 : 0xbe0f);
                                *(int32_t *)(int64_t)g16 = (int32_t)&g17;
                                v4 = v10;
                                v7 = 1;
                                goto lab_0x1900;
                            }
                        }
                    }
                    case 38: {
                        // 0x1a90
                        W((int64_t)&g44);
                        goto lab_0x18a0;
                    }
                    default: {
                        // 0x1aa0
                        if (((int32_t)(g28 == 61) & s) == 0) {
                            // 0x1ad0
                            v4 = v2;
                            v7 = 0;
                            if (g28 != 40) {
                                // 0x1ad8
                                W((int64_t)&g44);
                                v4 = v2;
                                v7 = 0;
                                if (g8 == 11) {
                                    // 0x1af0
                                    W((int64_t)&g44);
                                    aw(g23);
                                    av();
                                    v4 = v2;
                                    v7 = 0;
                                }
                            }
                        } else {
                            // 0x1ab4
                            av();
                            B();
                            W((int64_t)&g44);
                            v4 = v2;
                            v7 = 0;
                        }
                        goto lab_0x1900;
                    }
                }
            }
        }
    }
  lab_0x18a0:
    // 0x18a0
    av();
    v4 = v2;
    v7 = 1;
    goto lab_0x1900;
  lab_0x1900:
    // 0x1900
    v5 = v4;
    v8 = v7;
    goto lab_0x1900_2;
  lab_0x1900_2:
    // 0x1900
    if (g28 != 40) {
        // 0x1b50
        return g28;
    }
    // 0x1910
    if (v8 != 0) {
        // 0x1914
        aw(80);
    }
    int32_t v12 = x(0xec81, 0); // 0x192c
    av();
    int64_t v13 = 0; // 0x1948
    int64_t v14 = 0; // 0x1948
    if (g28 != 41) {
        B();
        x(0x248489, (int32_t)v14);
        if (g28 == 44) {
            // 0x1b28
            av();
        }
        int64_t v15 = v14 + 4 & 0xffffffff; // 0x1b2c
        v13 = v15;
        v14 = v15;
        while (g28 != 41) {
            // 0x1b0c
            B();
            x(0x248489, (int32_t)v14);
            if (g28 == 44) {
                // 0x1b28
                av();
            }
            // 0x1b2c
            v15 = v14 + 4 & 0xffffffff;
            v13 = v15;
            v14 = v15;
        }
    }
    int32_t v16 = v13;
    E(v12, v16);
    av();
    if (v8 != 0) {
        // 0x1960
        x(0x2494ff, v16);
        // 0x1974
        return x(0xc481, v16 + 4);
    }
    int32_t * v17 = (int32_t *)(0x100000000 * v5 + 0x400000000 >> 32); // 0x1b40
    int32_t result = x(232, *v17); // 0x1b44
    *v17 = result;
    if (v13 == 0) {
        // 0x1b50
        return result;
    }
    // 0x1974
    return x(0xc481, v16);
  lab_0x1a4c:
    // 0x1a4c
    aw(v3);
    v4 = v6;
    v7 = 1;
    goto lab_0x1900;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1b68 - 0x1ca0
// Line range:    300 - 335
int32_t X(int32_t s) {
    if (s == 1) {
        // 0x1b70
        return ab(1);
    }
    uint32_t v1 = s - 1; // 0x1b80
    X(v1);
    if (g8 != v1) {
        // 0x1c88
        return g8;
    }
    int64_t v2 = 0;
    av();
    int64_t v3; // 0x1b68
    while (v1 < 9) {
        // 0x1c40
        aw(80);
        X(v1);
        aw(89);
        if (v1 != 4 == (v1 != 5)) {
            // 0x1c70
            aw(g23);
            if (g28 == 37) {
                // 0x1c7c
                aw(146);
            }
        } else {
            // 0x1c68
            aq(g23);
        }
        // 0x1bb4
        v3 = v2;
        if (g8 != v1) {
            // break (via goto) -> 0x1bc0
            goto lab_0x1bc0;
        }
        av();
    }
    int64_t v4 = aa(g23, (int32_t)v2); // 0x1c30
    X(v1);
    v3 = v4;
    while (g8 == v1) {
        // 0x1c10
        v2 = v4;
        av();
        while (v1 < 9) {
            // 0x1c40
            aw(80);
            X(v1);
            aw(89);
            if (v1 != 4 == (v1 != 5)) {
                // 0x1c70
                aw(g23);
                if (g28 == 37) {
                    // 0x1c7c
                    aw(146);
                }
            } else {
                // 0x1c68
                aq(g23);
            }
            // 0x1bb4
            v3 = v2;
            if (g8 != v1) {
                // break (via goto) -> 0x1bc0
                goto lab_0x1bc0;
            }
            av();
        }
        // 0x1c24
        v4 = aa(g23, (int32_t)v2);
        X(v1);
        v3 = v4;
    }
  lab_0x1bc0:
    // 0x1bc0
    if (v3 == 0) {
        // 0x1c88
        return g8;
    }
    int32_t v5 = s - 9; // 0x1bc4
    if (v5 == 0 || v5 < 0 != (8 - s & v1) < 0) {
        // 0x1c88
        return g8;
    }
    int32_t v6 = aa(g23, (int32_t)v3); // 0x1bd4
    M(g23 ^ 1);
    I(5);
    H(v6);
    return M(g23);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1ca0 - 0x1cbc
// Line range:    339 - 341
int32_t ac(void) {
    // 0x1ca0
    B();
    return aa(0, 0);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1cbc - 0x1e44
// Line range:    410 - 438
int32_t ar(int32_t s) {
    int32_t result = g28; // 0x1cf4
    if (result != 256 && s == 0 != result != -1) {
        // 0x1d04
        return result;
    }
    // 0x1d18
    int64_t v1; // 0x1e28
    int64_t v2; // 0x1d44
    int32_t v3; // 0x1df0
    int64_t v4; // 0x1cbc
    int64_t v5; // 0x1cbc
    if (result == 256) {
        // 0x1d20
        av();
        while (true) {
            if (g28 == 59) {
                // break (via goto) -> 0x1d3c
                goto lab_0x1d3c;
            }
            // 0x1d44
            v2 = g28;
            if (s == 0) {
                // 0x1d80
                *(int32_t *)v2 = *(int32_t *)&g30;
                *(int32_t *)g30 = (int32_t)&g33;
            } else {
                // 0x1d4c
                *(int32_t *)(int64_t)g10 = (int32_t)&g11;
                *(int32_t *)v2 = -4 - g10;
            }
            // 0x1d64
            av();
            // 0x1d2c
            while (g28 != 44) {
                // 0x1d30
                if (g28 == 59) {
                    // break (via goto) -> 0x1d3c
                    goto lab_0x1d3c;
                }
                // 0x1d44
                v2 = g28;
                if (s == 0) {
                    // 0x1d80
                    *(int32_t *)v2 = *(int32_t *)&g30;
                    *(int32_t *)g30 = (int32_t)&g33;
                } else {
                    // 0x1d4c
                    *(int32_t *)(int64_t)g10 = (int32_t)&g11;
                    *(int32_t *)v2 = -4 - g10;
                }
                // 0x1d64
                av();
            }
            // 0x1d78
            av();
        }
        // 0x1d3c
        av();
    } else {
        // 0x1d98
        *(int32_t *)(int64_t)result = g16;
        av();
        av();
        v4 = 8;
        while (true) {
            // 0x1db8
            if (g28 == 41) {
                // break (via goto) -> 0x1dc4
                goto lab_0x1dc4;
            }
            // 0x1e20
            *(int32_t *)(int64_t)g28 = (int32_t)v4;
            v1 = v4 + 4 & 0xffffffff;
            av();
            v5 = v1;
            while (g28 != 44) {
                // 0x1db8
                if (g28 == 41) {
                    // break (via goto) -> 0x1dc4
                    goto lab_0x1dc4;
                }
                // 0x1e20
                *(int32_t *)(int64_t)g28 = (int32_t)v5;
                v1 = v5 + 4 & 0xffffffff;
                av();
                v5 = v1;
            }
            // 0x1e3c
            av();
            v4 = v1;
        }
        // 0x1dc4
        av();
        *(int32_t *)(int64_t)g10 = 0;
        *(int32_t *)(int64_t)g26 = 0;
        aw(0xe58955);
        v3 = x(0xec81, 0);
        S(0);
        H(g26);
        aw(0xc3c9);
        E(v3, g10);
    }
    int32_t v6 = g28; // 0x1cf4
    int32_t result2 = v6; // 0x1d00
    bool v7 = v6 == 256; // 0x1d00
    int32_t v8 = v6; // 0x1d00
    while (v6 == 256 || s == 0 == (v6 != -1)) {
        // 0x1d18
        if (v7) {
            // 0x1d20
            av();
            while (true) {
                if (g28 == 59) {
                    // break (via goto) -> 0x1d3c
                    goto lab_0x1d3c;
                }
                // 0x1d44
                v2 = g28;
                if (s == 0) {
                    // 0x1d80
                    *(int32_t *)v2 = *(int32_t *)&g30;
                    *(int32_t *)g30 = (int32_t)&g33;
                } else {
                    // 0x1d4c
                    *(int32_t *)(int64_t)g10 = (int32_t)&g11;
                    *(int32_t *)v2 = -4 - g10;
                }
                // 0x1d64
                av();
                // 0x1d2c
                while (g28 != 44) {
                    // 0x1d30
                    if (g28 == 59) {
                        // break (via goto) -> 0x1d3c
                        goto lab_0x1d3c;
                    }
                    // 0x1d44
                    v2 = g28;
                    if (s == 0) {
                        // 0x1d80
                        *(int32_t *)v2 = *(int32_t *)&g30;
                        *(int32_t *)g30 = (int32_t)&g33;
                    } else {
                        // 0x1d4c
                        *(int32_t *)(int64_t)g10 = (int32_t)&g11;
                        *(int32_t *)v2 = -4 - g10;
                    }
                    // 0x1d64
                    av();
                }
                // 0x1d78
                av();
            }
            // 0x1d3c
            av();
        } else {
            // 0x1d98
            *(int32_t *)(int64_t)v8 = g16;
            av();
            av();
            v4 = 8;
            while (true) {
                // 0x1db8
                v5 = v4;
                if (g28 == 41) {
                    // break (via goto) -> 0x1dc4
                    goto lab_0x1dc4;
                }
                // 0x1e20
                *(int32_t *)(int64_t)g28 = (int32_t)v5;
                v1 = v5 + 4 & 0xffffffff;
                av();
                v5 = v1;
                while (g28 != 44) {
                    // 0x1db8
                    if (g28 == 41) {
                        // break (via goto) -> 0x1dc4
                        goto lab_0x1dc4;
                    }
                    // 0x1e20
                    *(int32_t *)(int64_t)g28 = (int32_t)v5;
                    v1 = v5 + 4 & 0xffffffff;
                    av();
                    v5 = v1;
                }
                // 0x1e3c
                av();
                v4 = v1;
            }
            // 0x1dc4
            av();
            *(int32_t *)(int64_t)g10 = 0;
            *(int32_t *)(int64_t)g26 = 0;
            aw(0xe58955);
            v3 = x(0xec81, 0);
            S(0);
            H(g26);
            aw(0xc3c9);
            E(v3, g10);
        }
        // 0x1ce4
        v6 = g28;
        result2 = v6;
        v7 = v6 == 256;
        v8 = v6;
    }
    // 0x1d04
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1e44 - 0x2044
// Line range:    343 - 406
int32_t S(int32_t s) {
    // 0x1e44
    int32_t v1; // 0x1e44
    switch (g28) {
        case 288: {
            // 0x1e70
            av();
            av();
            v1 = ac();
            av();
            S(s);
            if (g28 == 312) {
                // 0x1e98
                av();
                int32_t v2 = I(0); // 0x1ea0
                H(v1);
                S(s);
                // 0x1ec0
                return H(v2);
            }
            // break -> 0x1f28
            break;
        }
        case 504: {
        }
        case 352: {
            // 0x1ee4
            av();
            av();
            int32_t v3; // 0x1e44
            if (g28 == 352) {
                // 0x1ef8
                v1 = ac();
                v3 = g16;
            } else {
                // 0x1f30
                if (g28 != 59) {
                    // 0x1f3c
                    B();
                }
                // 0x1f40
                av();
                v1 = 0;
                if (g28 != 59) {
                    // 0x1f60
                    v1 = ac();
                }
                // 0x1f68
                av();
                v3 = g16;
                if (g28 != 41) {
                    int32_t v4 = I(0); // 0x1f80
                    B();
                    I(g16 - 5 - g16);
                    H(v4);
                    v3 = v4 + 4;
                }
            }
            // 0x1f08
            av();
            S((int32_t)(int64_t)&v1);
            I(v3 - 5 - g16);
            // break -> 0x1f28
            break;
        }
        case 123: {
            // 0x1fb8
            av();
            ar(1);
            if (g28 != 125) {
                S(s);
                while (g28 != 125) {
                    // 0x1fd8
                    S(s);
                }
            }
            // 0x1ec0
            return av();
        }
        case 448: {
            // 0x1fec
            av();
            if (g28 != 59) {
                // 0x1ffc
                B();
            }
            uint32_t v5 = g26;
            *(int32_t *)(int64_t)v5 = I(v5);
            // 0x1ec0
            return av();
        }
        case 400: {
            // 0x2020
            av();
            int64_t v6; // 0x1e44
            *(int32_t *)(int64_t)s = I((int32_t)v6);
            // 0x1ec0
            return av();
        }
        case 59: {
            // 0x1ec0
            return av();
        }
        default: {
            // 0x203c
            B();
            // 0x1ec0
            return av();
        }
    }
    // 0x1ec0
    return H(v1);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2044 - 0x2074
// Line range:    451 - 454
int32_t ax(int32_t d) {
    // 0x2044
    E((int32_t)(int64_t)g30, d);
    *(int32_t *)g30 = (int32_t)&g33;
    return &g33;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2074 - 0x20b8
// Line range:    455 - 461
int32_t ad(int32_t d, int32_t a) {
    // 0x2074
    ax(d);
    int32_t v1 = d + 0x8048000; // 0x2090
    ax(v1);
    ax(v1);
    ax(a);
    return ax(a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x20b8 - 0x2298
// Line range:    463 - 501
int32_t ae(int32_t s) {
    // 0x20b8
    int64_t result; // 0x20b8
    while (true) {
        int64_t v1 = (int64_t)*(int32_t *)&g27 + 1; // 0x2100
        int64_t v2 = (int64_t)*(int32_t *)&g6; // 0x2104
        int64_t v3 = 0x100000000 * v1 >> 32; // 0x2108
        result = v3;
        int64_t v4 = result + 1; // 0x211c
        while (result < v2 == (*(char *)result != 32)) {
            // 0x2110
            result = v4;
            v4 = result + 1;
        }
        int64_t v5 = result & 0xffffffff; // 0x2114
        while (v5 != v2) {
            int32_t v6 = v1; // 0x2160
            int32_t v7 = 8 * (v6 - *(int32_t *)&g27) + g9; // 0x2164
            int32_t v8 = v7 + 248; // 0x2168
            *(int32_t *)(int64_t)(uint32_t)g28 = v8;
            int32_t v9 = *(int32_t *)(int64_t)(v7 + 252); // 0x217c
            int32_t v10 = *(int32_t *)(int64_t)v8; // 0x2180
            if (v9 != 0 && v10 != 1) {
                if (v10 == 0) {
                    if (s != 0) {
                        // break -> 0x21cc
                        break;
                    }
                    int32_t v11 = result; // 0x219c
                    memcpy((int64_t *)(0x100000000 * (int64_t)g30 >> 32), (int64_t *)v3, v11 - v6);
                    *(int32_t *)g30 = 1 - v6 + v11 + *(int32_t *)&g30;
                } else {
                    if (s == 0) {
                        // 0x228c
                        ap(v9, v10);
                    }
                }
            }
            v1 = v5 + 1;
            v2 = (int64_t)*(int32_t *)&g6;
            v3 = 0x100000000 * v1 >> 32;
            result = v3;
            v4 = result + 1;
            while (result < v2 == (*(char *)result != 32)) {
                // 0x2110
                result = v4;
                v4 = result + 1;
            }
            // 0x2120
            v5 = result & 0xffffffff;
        }
        return result;
    }
    // 0x2128
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2298 - 0x266c
// Line range:    506 - 538
int32_t au(int32_t F) {
    // 0x2298
    *g13 = (int32_t)(int64_t)g30;
    int32_t v1 = *(int32_t *)&g25; // 0x22e4
    *(int32_t *)(int64_t)g16 = v1;
    int32_t v2 = g16 - v1; // 0x22ec
    aw(0x505458);
    int32_t v3 = *(int32_t *)(int64_t)(g9 + (int32_t)&g42); // 0x2310
    x(232, v3 - 5 - g16);
    aw(0xc389);
    M(1);
    aw(0x80cd);
    int32_t v4 = *(int32_t *)&g30 + v2; // 0x2348
    char * dest_str = strcpy((char *)(0x100000000 * (int64_t)strcpy((char *)(int64_t)(v4 + 1), "libc.so.6") + 0xa00000000 >> 32), "libdl.so.2"); // 0x236c
    *(int32_t *)g30 = (int32_t)(int64_t)dest_str + 11;
    ae(0);
    *(int32_t *)g30 = (int32_t)&g32;
    ax(0);
    ax(0);
    ax(0);
    ax(0);
    ae(1);
    int32_t v5 = *(int32_t *)&g30; // 0x23bc
    uint32_t v6 = (v5 - (int32_t)&g32) / 16; // 0x23c8
    ax(1);
    ax(v6);
    ax(1);
    ax(0);
    int64_t v7 = 2; // 0x23f4
    if (v6 > 2) {
        ax((int32_t)v7);
        v7 = v7 + 1 & 0xffffffff;
        while (v7 < (int64_t)v6) {
            // 0x265c
            ax((int32_t)v7);
            v7 = v7 + 1 & 0xffffffff;
        }
    }
    // 0x23f8
    ax(0);
    int32_t v8 = (int64_t)g30;
    ae(2);
    int32_t v9 = *(int32_t *)&g13; // 0x2424
    int32_t v10 = *(int32_t *)&g25; // 0x2428
    memcpy((int64_t *)(int64_t)v9, (int64_t *)(int64_t)v10, v2);
    int32_t v11 = *(int32_t *)&g30; // 0x2430
    *(int32_t *)g30 = *(int32_t *)&g24;
    ax(0x464c457f);
    ax(0x10101);
    ax(0);
    ax(0);
    ax(0x30002);
    ax(1);
    ax(*(int32_t *)&g13 + *(int32_t *)&g35);
    ax(48);
    ax(0);
    ax(0);
    ax(0x200034);
    ax(3);
    ax(3);
    ad(144, 19);
    ax(4);
    ax(1);
    ax(1);
    ad(0, v11 - *(int32_t *)&g24);
    ax(7);
    ax(0x1000);
    ax(2);
    ad(164, 88);
    ax(6);
    ax(4);
    int32_t str = *(int32_t *)&g30; // 0x2534
    char * dest_str2 = strcpy((char *)(int64_t)str, "/lib/ld-linux.so.2"); // 0x2540
    *(int32_t *)g30 = (int32_t)(int64_t)dest_str2 + 20;
    ax(1);
    ax(1);
    ax(1);
    ax(11);
    ax(4);
    ax(*(int32_t *)&g35 + v5);
    ax(6);
    ax(*(int32_t *)&g35 + (int32_t)&g32);
    ax(5);
    ax(*(int32_t *)&g35 + v4);
    ax(10);
    ax(*(int32_t *)&g30 - v4);
    ax(11);
    ax(16);
    ax(17);
    ax(*(int32_t *)&g35 + v8);
    ax(18);
    ax(v11 - v8);
    ax(19);
    ax(8);
    ax(0);
    ax(0);
    struct _IO_FILE * file = fopen((char *)(int64_t)F, "w"); // 0x2618
    int32_t data = *(int32_t *)&g24; // 0x2620
    fwrite((int64_t *)(int64_t)data, 1, v11 - data, file);
    return fclose(file);
}

// Address range: 0x2670 - 0x26e8
int64_t __libc_csu_init(void) {
    // 0x2670
    int64_t v1; // 0x2670
    int64_t result = _init(v1); // 0x26a4
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x26d4
        return result;
    }
    // 0x26b4
    return v1 & 0xffffffff;
}

// Address range: 0x26e8 - 0x26ec
int64_t __libc_csu_fini(void) {
    // 0x26e8
    int64_t result; // 0x26e8
    return result;
}

// Address range: 0x26ec - 0x26fc
int64_t _fini(int64_t a1) {
    // 0x26ec
    int64_t result; // 0x26ec
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// int fclose(FILE * stream);
// int fgetc(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// int isalnum(int c);
// int isspace(int c);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int puts(const char * s);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 54

