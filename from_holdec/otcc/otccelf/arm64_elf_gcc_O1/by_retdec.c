//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int32_t aa(int32_t s, int32_t a);
int32_t ab(int32_t s);
int32_t ac(void);
int32_t ad(int32_t d, int32_t a);
int32_t ae(int32_t s);
int32_t am(void);
int32_t an(void);
int32_t ao(int32_t a);
int32_t ap(int32_t a, uint32_t z);
int32_t aq(int32_t a);
int32_t ar(int32_t s);
int32_t au(int32_t F);
int32_t av(void);
int32_t aw(int32_t d);
int32_t ax(int32_t d);
int32_t B(void);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(void);
int32_t E(int32_t a, uint32_t d);
int64_t frame_dummy(void);
int64_t function_400001418(void);
int64_t function_400001464(void);
int64_t * function_d40(int64_t * dest, int64_t * src, int32_t n);
int64_t function_d50(int64_t a1);
int32_t function_d60(struct _IO_FILE * stream);
struct _IO_FILE * function_d70(char * filename, char * modes);
int32_t function_d80(int32_t c);
int32_t function_d90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_da0(struct _IO_FILE * stream);
int64_t * function_db0(int32_t nmemb, int32_t size);
int64_t function_dc0(int64_t a1);
void function_dd0(void);
int32_t function_de0(char * s);
int32_t function_df0(char * nptr, char ** endptr, int32_t base);
int32_t function_e00(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * function_e10(char * haystack, char * needle);
int32_t function_e20(int32_t c);
int64_t function_f70(int64_t a1, int64_t a2);
int32_t H(int32_t a);
int32_t I(int32_t a);
int32_t L(int32_t a);
int32_t M(int32_t a);
int64_t register_tm_clones(void);
int32_t S(int32_t s);
int32_t w(void);
int32_t W(int32_t s, uint32_t a);
int32_t X(int32_t s);
int32_t x(int32_t d, int32_t a);

// --------------------- Global Variables ---------------------

int32_t Q = 0; // 0x130c0
int32_t R = 0; // 0x130a0
int32_t ak = 0; // 0x130ac
int32_t al = 0; // 0x130d4
int64_t g1 = 3904; // 0x12d00
int64_t g2 = 3832; // 0x12d08
int64_t g3 = 0; // 0x12d10
void (*g4)() = (void (*)())0x2a98; // 0x12f10
int64_t g5 = 0; // 0x12f18
int32_t g6 = 0x1308c; // 0x12f20
int32_t g7 = 0x13090; // 0x12f28
int32_t * g8 = (int32_t *)0x13094; // 0x12f30
int32_t g9 = 0x13098; // 0x12f38
int32_t g10 = 0; // 0x12f3c
int32_t * g11 = (int32_t *)0x1309c; // 0x12f40
int64_t g13 = 0; // 0x12f50
char * g14 = "\xa4\x30\x01"; // 0x12f58
int32_t g15 = 0x130a8; // 0x12f60
int32_t g16 = 304; // 0x12f61
int32_t g17 = 0; // 0x12f64
int64_t g18 = 0; // 0x12f68
int32_t g20 = 304; // 0x12f71
void (*g21)() = (void (*)())0x2a20; // 0x12f78
int32_t g22 = 0x130b0; // 0x12f80
int64_t g23; // 0x12f88
int64_t g24; // 0x12f90
int32_t g25 = 0x130bc; // 0x12f98
int32_t g27 = 0x130c4; // 0x12fa8
int32_t * g28 = (int32_t *)0x130c800000000; // 0x12fac
int32_t g30 = 304; // 0x12fb1
int32_t g31 = 0; // 0x12fb3
int32_t g32 = 0; // 0x12fb4
int32_t g33 = 0x130cc; // 0x12fb8
int64_t g34 = 0x130d000; // 0x12fbf
int32_t g36 = 0; // 0x12fc4
int32_t g37 = 0x28a4; // 0x12fc8
int64_t g38 = 0; // 0x12fd0
int64_t g40 = 3360; // 0x13000
int64_t g41 = 0; // 0x13088
int64_t g42 = 0; // 0x1308f
int32_t * g43 = (int32_t *)-0x43e542ed270adc75; // 0x250
int64_t g44 = -0x29a0fc3fc6ffffe0; // 0xf90
int32_t i = 0; // 0x130c8
int32_t g45;
int32_t y = 0; // 0x130d0
int32_t * g12 = &R; // 0x12f48
int32_t * g19 = &ak; // 0x12f70
int32_t * g26 = &Q; // 0x12fa0
int32_t * g29 = &i; // 0x12fb0
int32_t * g35 = &y; // 0x12fc0
int32_t * g39 = &al; // 0x12fe0

// ------------------------ Functions -------------------------

// Address range: 0xd08 - 0xd1c
int64_t _init(int64_t a1) {
    // 0xd08
    return call_weak_fn();
}

// Address range: 0xd40 - 0xd50
int64_t * function_d40(int64_t * dest, int64_t * src, int32_t n) {
    // 0xd40
    return memcpy(dest, src, n);
}

// Address range: 0xd50 - 0xd60
int64_t function_d50(int64_t a1) {
    // 0xd50
    return __cxa_finalize();
}

// Address range: 0xd60 - 0xd70
int32_t function_d60(struct _IO_FILE * stream) {
    // 0xd60
    return fclose(stream);
}

// Address range: 0xd70 - 0xd80
struct _IO_FILE * function_d70(char * filename, char * modes) {
    // 0xd70
    return fopen(filename, modes);
}

// Address range: 0xd80 - 0xd90
int32_t function_d80(int32_t c) {
    // 0xd80
    return isspace(c);
}

// Address range: 0xd90 - 0xda0
int32_t function_d90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xd90
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xda0 - 0xdb0
int32_t function_da0(struct _IO_FILE * stream) {
    // 0xda0
    return fgetc(stream);
}

// Address range: 0xdb0 - 0xdc0
int64_t * function_db0(int32_t nmemb, int32_t size) {
    // 0xdb0
    return calloc(nmemb, size);
}

// Address range: 0xdc0 - 0xdd0
int64_t function_dc0(int64_t a1) {
    // 0xdc0
    return __gmon_start__();
}

// Address range: 0xdd0 - 0xde0
void function_dd0(void) {
    // 0xdd0
    abort();
}

// Address range: 0xde0 - 0xdf0
int32_t function_de0(char * s) {
    // 0xde0
    return puts(s);
}

// Address range: 0xdf0 - 0xe00
int32_t function_df0(char * nptr, char ** endptr, int32_t base) {
    // 0xdf0
    return strtol(nptr, endptr, base);
}

// Address range: 0xe00 - 0xe10
int32_t function_e00(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0xe00
    return fwrite(ptr, size, n, s);
}

// Address range: 0xe10 - 0xe20
char * function_e10(char * haystack, char * needle) {
    // 0xe10
    return strstr(haystack, needle);
}

// Address range: 0xe20 - 0xe30
int32_t function_e20(int32_t c) {
    // 0xe20
    return isalnum(c);
}

// Address range: 0xe30 - 0xe68
int64_t _start(int64_t a1) {
    // 0xe30
    int64_t v1; // 0xe30
    int64_t v2; // 0xe30
    __libc_start_main((int64_t)g37, (int32_t)a1, (char **)&v1, g21, g4, (void (*)())v2);
    abort();
    return &g45;
}

// Address range: 0xe68 - 0xe7c
int64_t call_weak_fn(void) {
    // 0xe68
    if (g18 == 0) {
        // 0xe78
        return 0;
    }
    // 0xe74
    return function_dc0(g18);
}

// Address range: 0xe80 - 0xeb4
int64_t deregister_tm_clones(void) {
    if ((int64_t)&g42 - (int64_t)&g41 == 14 || (uint64_t)((int64_t)&g42 - (int64_t)&g41) < 14 || g5 == 0) {
        // 0xeb0
        return &g41;
    }
    // 0xeac
    return _ITM_deregisterTMCloneTable(&g41, g5);
}

// Address range: 0xeb8 - 0xef4
int64_t register_tm_clones(void) {
    // 0xeb8
    return &g41;
}

// Address range: 0xef8 - 0xf40
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g41; // 0xf08
    if (result != 0) {
        // 0xf34
        return result;
    }
    // 0xf10
    if (g13 != 0) {
        // 0xf1c
        function_d50(*(int64_t *)((int64_t)&g40 + 128));
    }
    // 0xf28
    deregister_tm_clones();
    *(char *)&g41 = 1;
    // 0xf34
    return 1;
}

// Address range: 0xf40 - 0xf70
int64_t frame_dummy(void) {
    // 0xf40
    if (g3 == 0 || g38 == 0) {
        // 0xf50
        return register_tm_clones();
    }
    // 0xf64
    return _Jv_RegisterClasses(&g3, g38);
}

// Address range: 0xf70 - 0xf78
int64_t function_f70(int64_t a1, int64_t a2) {
    // 0xf70
    return register_tm_clones();
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0xf78 - 0xf98
// Line range:    20 - 22
int32_t L(int32_t a) {
    int32_t * v1 = (int32_t *)*(int64_t *)0x12f20; // 0xf80
    int32_t v2 = *v1; // 0xf80
    *v1 = v2 + 1;
    *(char *)(int64_t)v2 = (char)a;
    return a;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0xf98 - 0x102c
// Line range:    23 - 32
// Demangled:     wchar_t
int32_t w(void) {
    int32_t v1 = *(int32_t *)*(int64_t *)0x12f40; // 0xfa0
    if (v1 == 0) {
        int32_t c = fgetc((struct _IO_FILE *)(int64_t)*(int32_t *)&g19); // 0x1014
        *(int32_t *)(int64_t)g33 = c;
        return c;
    }
    // 0xfa8
    *g11 = v1 + 1;
    unsigned char v2 = *(char *)(int64_t)v1; // 0xfbc
    int64_t result = *(int64_t *)0x12fb8; // 0xfc4
    *(int32_t *)result = (int32_t)v2;
    if (v2 != 2) {
        // 0xfd4
        return result;
    }
    // 0xfd8
    *g11 = 0;
    *(int32_t *)(int64_t)g33 = *(int32_t *)&g39;
    return g33;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x102c - 0x1064
// Line range:    33 - 35
int32_t am(void) {
    int32_t c = g33; // 0x1040
    return isalnum(c) | (int32_t)(c == 95);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1064 - 0x10b8
// Line range:    36 - 39
int32_t an(void) {
    // 0x1064
    if (g33 != 92) {
        // 0x1078
        return g33;
    }
    // 0x107c
    w();
    int32_t result = g33; // 0x1098
    if (g33 == 110) {
        // 0x10a4
        *(int32_t *)110 = 10;
        result = 110;
    }
    // 0x1078
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x10b8 - 0x14b4
// Line range:    42 - 120
int32_t av(void) {
    // 0x10b8
    if ((isspace(g33) || (int32_t)(g33 == 35)) != 0) {
        int32_t v1; // 0x10b8
        if (g33 == 35) {
            // 0x1144
            w();
            av();
            if (*(int32_t *)*(int64_t *)0x12fa8 == (int32_t)".1") {
                // 0x1158
                av();
                L(32);
                *(int32_t *)(int64_t)g27 = 1;
                *(int32_t *)(int64_t)(int32_t)&g28 = g6;
            }
            // 0x10e8
            if (g33 != 10) {
                L(g33);
                w();
                v1 = g33;
                while (g33 != 10) {
                    // 0x10fc
                    L(v1);
                    w();
                    v1 = g33;
                }
            }
            // 0x1110
            L(10);
            L(2);
        }
        // 0x1120
        w();
        // 0x1140
        while ((isspace(g33) || (int32_t)(g33 == 35)) != 0) {
            // 0x1140
            if (g33 == 35) {
                // 0x1144
                w();
                av();
                if (*(int32_t *)*(int64_t *)0x12fa8 == (int32_t)".1") {
                    // 0x1158
                    av();
                    L(32);
                    *(int32_t *)(int64_t)g27 = 1;
                    *(int32_t *)(int64_t)(int32_t)&g28 = g6;
                }
                // 0x10e8
                if (g33 != 10) {
                    L(g33);
                    w();
                    v1 = g33;
                    while (g33 != 10) {
                        // 0x10fc
                        L(v1);
                        w();
                        v1 = g33;
                    }
                }
                // 0x1110
                L(10);
                L(2);
            }
            // 0x1120
            w();
        }
    }
    // 0x118c
    *(int32_t *)*(int64_t *)0x12f28 = 0;
    *(int32_t *)(int64_t)g27 = g33;
    int64_t result2; // 0x10b8
    if (am() != 0) {
        // 0x11ac
        L(32);
        *(int32_t *)*(int64_t *)0x12f58 = g6;
        if (am() != 0) {
            L(g33);
            w();
            while (am() != 0) {
                // 0x11d8
                L(g33);
                w();
            }
        }
        int32_t v2 = g27; // 0x11f4
        if (v2 == 57 || v2 < 57) {
            int32_t str_as_l = strtol((char *)(int64_t)*(int32_t *)&g14, NULL, 0); // 0x12c4
            *(int32_t *)*(int64_t *)0x12f80 = str_as_l;
            int64_t result = g27; // 0x12dc
            *(int32_t *)result = 2;
            // 0x129c
            return result;
        }
        // 0x1204
        *(char *)(int64_t)g6 = 32;
        int32_t v3 = *(int32_t *)&g14; // 0x1220
        int32_t str = *(int32_t *)&g26; // 0x1230
        char * substr_pos = strstr((char *)(int64_t)str, (char *)(int64_t)(v3 - 1)); // 0x123c
        int32_t * v4 = (int32_t *)(int64_t)g27; // 0x124c
        *v4 = (int32_t)(int64_t)substr_pos - str;
        *(char *)(int64_t)g6 = 0;
        *v4 = 8 * (int32_t)&g37;
        if (8 * (int32_t)&g37 <= (int32_t)".1") {
            // 0x129c
            return (int64_t)(8 * (int32_t)&g37);
        }
        int32_t v5 = *(int32_t *)*(int64_t *)0x12f30 + 8 * (int32_t)&g37; // 0x127c
        int64_t v6 = v5; // 0x127c
        *(int32_t *)(int64_t)g27 = v5;
        result2 = v6;
        if (*(int32_t *)(int64_t)v5 == 1) {
            // 0x12e8
            *g11 = *(int32_t *)(0x100000000 * v6 + 0x400000000 >> 32);
            *g39 = g33;
            w();
            result2 = av();
        }
        // 0x129c
        return result2;
    }
    // 0x1324
    w();
    if (g27 == 39) {
        // 0x137c
        *(int32_t *)39 = 2;
        an();
        *(int32_t *)(int64_t)g22 = g33;
        w();
        // 0x129c
        return w();
    }
    // 0x133c
    if (g27 == 47 == g33 == 42) {
        // 0x13b4
        w();
        while (true) {
            // 0x13c4
            while (true) {
              lab_0x13ec:
                // 0x13ec
                switch (g33) {
                    case 0: {
                        goto lab_0x140c;
                    }
                    case 42: {
                        goto lab_0x13dc;
                    }
                    default: {
                        w();
                        while (g33 != 42) {
                            // 0x13cc
                            w();
                        }
                        goto lab_0x13dc;
                    }
                }
            }
          lab_0x1400:
            // 0x1400
            *(int32_t *)47 = 0;
        }
      lab_0x140c:
        // 0x140c
        w();
        // 0x129c
        return av();
    }
    int32_t * v7 = (int32_t *)(int64_t)g22;
    int32_t * v8 = (int32_t *)(int64_t)g7;
    int64_t v9 = (int64_t)"++#m--%am*@R<^1c/@%[_[H3c%@%[_[H3c+@.B#d-@%:_^BKd<<Z/03e>>`/03e<=0f>=/f<@.f>@1f==&g!='g&&k||#l&@.BCh^@.BSi|@.B+j~@/%Yd!@&d*@b"; // 0x1378
    int64_t v10 = v9 + 1; // 0x142c
    int64_t v11 = 0x100000000 * v9;
    unsigned char v12 = *(char *)(v11 >> 32); // 0x1434
    while (v12 != 0) {
        unsigned char v13 = *(char *)(0x100000000 * v10 >> 32); // 0x1440
        *v7 = 0;
        int64_t v14 = (int64_t)*(char *)(v11 + 0x200000000 >> 32) + 0xffffff9e; // 0x1458
        int32_t v15 = v14; // 0x145c
        *v8 = v15;
        int64_t v16 = v14 & 0xffffffff; // 0x1460
        if (v15 > -1) {
            v16 = function_400001418();
        }
        // 0x1464
        *v7 = (int32_t)v16 + 64 + 64 * g22;
        int64_t v17 = (int64_t)*(char *)(v11 + 0x300000000 >> 32) + 0xffffff9e; // 0x1480
        int32_t v18 = v17; // 0x1484
        *v8 = v18;
        int64_t v19 = v17 & 0xffffffff; // 0x148c
        if (v18 < 0) {
            v19 = function_400001464();
        }
        // 0x1490
        v9 = v9 + 4 & 0xffffffff;
        if (g27 == (int32_t)v12 == (v13 == 64 || g33 == (int32_t)v13)) {
            // 0x1494
            result2 = v19;
            if ((int64_t)g33 == (int64_t)v13) {
                // 0x149c
                w();
                int64_t v20 = g27; // 0x14a8
                *(int32_t *)v20 = 1;
                result2 = v20;
                return result2;
            } else {
                return result2;
            }
        }
        v10 = v9 + 1;
        v11 = 0x100000000 * v9;
        v12 = *(char *)(v11 >> 32);
    }
    // 0x129c
    result2 = v10 & 0xffffffff;
  lab_0x129c:
    // 0x129c
    return result2;
  lab_0x13dc:
    // 0x13dc
    w();
    if (g33 == 47) {
        // break -> 0x1400
        goto lab_0x1400;
    }
    goto lab_0x13ec;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x14b4 - 0x14f0
// Line range:    128 - 133
int32_t aw(int32_t d) {
    // 0x14b4
    if (d == 0 || d == -1) {
        // 0x14ec
        return d;
    }
    int32_t * v1 = (int32_t *)(int64_t)g15; // 0x14d0
    *v1 = (int32_t)&g16;
    *(char *)(int64_t)g15 = (char)d;
    int32_t result = d >> 8; // 0x14dc
    if (result != -1 != result != 0) {
        // 0x14ec
        return result;
    }
    int32_t result2 = result; // 0x14e8
    *v1 = (int32_t)&g16;
    *(char *)(int64_t)g15 = (char)result2;
    result2 >>= 8;
    while (result2 != -1 == (result2 != 0)) {
        // 0x14c8
        *v1 = (int32_t)&g16;
        *(char *)(int64_t)g15 = (char)result2;
        result2 >>= 8;
    }
    // 0x14ec
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x14f0 - 0x152c
// Line range:    134 - 139
int32_t E(int32_t a, uint32_t d) {
    // 0x14f0
    *(char *)(int64_t)a = (char)d;
    *(char *)(int64_t)(a + 1) = (char)(d / 256);
    *(char *)(int64_t)(a + 2) = (char)(d / 0x10000);
    int32_t result = a + 3; // 0x1518
    *(char *)(int64_t)result = (char)(d / 0x1000000);
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x152c - 0x156c
// Line range:    140 - 143
int32_t ao(int32_t a) {
    unsigned char v1 = *(char *)(int64_t)(a + 1); // 0x1534
    unsigned char v2 = *(char *)(int64_t)(a + 2); // 0x1540
    unsigned char v3 = *(char *)(int64_t)(a + 3); // 0x1554
    int64_t v4; // 0x152c
    return 256 * (int32_t)v1 | (int32_t)v4 % 256 | 0x10000 * (int32_t)v2 | 0x1000000 * (int32_t)v3;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x156c - 0x1660
// Line range:    144 - 157
int32_t ap(int32_t a, uint32_t z) {
    // 0x156c
    if (a == 0) {
        // 0x1648
        return 0;
    }
    int32_t * v1 = (int32_t *)*(int64_t *)((int64_t)&g44 + 0x12000);
    int64_t v2 = a; // 0x15a0
    int32_t v3 = v2; // 0x15f8
    uint32_t v4 = ao(v3); // 0x15fc
    int32_t v5; // 0x15e0
    uint32_t v6; // 0x15a4
    int32_t result; // 0x156c
    if (*(char *)(0x100000000 * v2 - 0x100000000 >> 32) == 5) {
        // 0x15a4
        v6 = *(int32_t *)*(int64_t *)0x12f88;
        if (v6 <= z == *(int32_t *)&g29 > z) {
            // 0x162c
            result = E(v3, *(int32_t *)&g35 + z);
        } else {
            // 0x15c4
            v5 = *(int32_t *)&g35;
            result = E(v3, z - *v1 + *(int32_t *)&g12 + v5);
        }
    } else {
        // 0x1618
        result = E(v3, z - 4 - v3);
    }
    // 0x15f0
    v2 = v4;
    while (v4 != 0) {
        // 0x15f8
        v3 = v2;
        v4 = ao(v3);
        if (*(char *)(0x100000000 * v2 - 0x100000000 >> 32) == 5) {
            // 0x15a4
            v6 = *(int32_t *)*(int64_t *)0x12f88;
            if (v6 <= z == *(int32_t *)&g29 > z) {
                // 0x162c
                result = E(v3, *(int32_t *)&g35 + z);
            } else {
                // 0x15c4
                v5 = *(int32_t *)&g35;
                result = E(v3, z - *v1 + *(int32_t *)&g12 + v5);
            }
        } else {
            // 0x1618
            result = E(v3, z - 4 - v3);
        }
        // 0x15f0
        v2 = v4;
    }
    // 0x1648
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1660 - 0x1680
// Line range:    158 - 160
int32_t H(int32_t a) {
    // 0x1660
    return ap(a, g15);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1680 - 0x16c0
// Line range:    161 - 167
// Demangled:     long long
int32_t x(int32_t d, int32_t a) {
    // 0x1680
    aw(d);
    uint32_t v1 = g15;
    E(v1, a);
    *(int32_t *)(int64_t)v1 = (int32_t)&g17;
    return g15;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x16c0 - 0x16dc
// Line range:    168 - 170
int32_t M(int32_t a) {
    // 0x16c0
    return x(184, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x16dc - 0x16f8
// Line range:    171 - 173
int32_t I(int32_t a) {
    // 0x16dc
    return x(233, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x16f8 - 0x1730
// Line range:    174 - 177
int32_t aa(int32_t s, int32_t a) {
    // 0x16f8
    aw(0xfc085);
    return x(s + 132, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1730 - 0x1774
// Line range:    178 - 184
int32_t aq(int32_t a) {
    // 0x1730
    aw(0xc139);
    M(0);
    aw(15);
    aw(a + 144);
    return aw(192);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1774 - 0x17d0
// Line range:    185 - 189
int32_t W(int32_t s, uint32_t a) {
    // 0x1774
    aw(s + 131);
    int64_t v1; // 0x1774
    int32_t v2 = v1;
    int32_t result; // 0x1774
    if (v2 == 0 || v2 > 511) {
        int32_t * v3 = (int32_t *)(0x100000000 * (int64_t)a + 0x400000000 >> 32); // 0x17a8
        int32_t v4 = x(5, *v3); // 0x17b0
        *v3 = v4;
        result = v4;
    } else {
        // 0x17c4
        result = x(133, v2);
    }
    // 0x17b8
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x17d0 - 0x17e8
// Line range:    336 - 338
int32_t B(void) {
    // 0x17d0
    return X(11);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x17e8 - 0x1c9c
// Line range:    195 - 297
int32_t ab(int32_t s) {
    uint32_t v1 = g27; // 0x180c
    int64_t v2 = v1; // 0x180c
    int32_t v3; // 0x17e8
    int64_t v4; // 0x1a1c
    int64_t v5; // 0x17e8
    int64_t v6; // 0x17e8
    int64_t v7; // 0x17e8
    int64_t v8; // 0x17e8
    int64_t v9; // 0x17e8
    int64_t v10; // 0x17e8
    int32_t v11; // 0x17e8
    int32_t v12; // 0x17e8
    if (v1 == 34) {
        // 0x18fc
        M(*(int32_t *)&g35 + *(int32_t *)&g29);
        if (g33 != 34) {
            an();
            *g29 = (int32_t)&g30;
            *(char *)(int64_t)*(int32_t *)&g29 = (char)g33;
            w();
            // 0x1930
            while (g33 != 34) {
                // 0x1940
                an();
                *g29 = (int32_t)&g30;
                *(char *)(int64_t)*(int32_t *)&g29 = (char)g33;
                w();
            }
        }
        // 0x196c
        *(char *)(0x100000000 * (int64_t)g29 >> 32) = 0;
        *g29 = (int32_t)&g32;
        w();
        av();
        v7 = v2;
        goto lab_0x1994;
    } else {
        // 0x1818
        av();
        if (v1 == 2) {
            // 0x19c4
            M(g22);
            v7 = 2;
            goto lab_0x1994;
        } else {
            if (g7 == 2) {
                // 0x19d0
                ab(0);
                x(185, 0);
                if (v1 == 33) {
                    // 0x19f8
                    aq(g22);
                    v7 = 33;
                } else {
                    // 0x19ec
                    aw(g22);
                    v7 = v2;
                }
                goto lab_0x1994;
            } else {
                switch (v1) {
                    case 40: {
                        // 0x1a04
                        B();
                        av();
                        v7 = 40;
                        goto lab_0x1994;
                    }
                    case 42: {
                        // 0x1a10
                        av();
                        av();
                        av();
                        av();
                        if (g27 == 42) {
                            // 0x1a80
                            av();
                            av();
                            av();
                            av();
                            ab(0);
                            v8 = 0;
                            if (g27 == 61) {
                                // 0x1be4
                                av();
                                aw(80);
                                B();
                                aw(89);
                                v9 = 0;
                                v3 = 392;
                                goto lab_0x1adc;
                            } else {
                                goto lab_0x1994_2;
                            }
                        } else {
                            // 0x1a34
                            v4 = g27;
                            ab(0);
                            if (g27 == 61) {
                                // 0x1ab8
                                av();
                                aw(80);
                                B();
                                aw(89);
                                v9 = v4;
                                v3 = g27 == 256 ? 393 : 392;
                                goto lab_0x1adc;
                            } else {
                                // 0x1a54
                                v8 = 0;
                                switch (g27) {
                                    case 0: {
                                        goto lab_0x1994_2;
                                    }
                                    case 256: {
                                        // 0x1ae4
                                        aw(139);
                                        goto lab_0x1a68;
                                    }
                                    default: {
                                        // 0x1a60
                                        aw(0xbe0f);
                                        goto lab_0x1a68;
                                    }
                                }
                            }
                        }
                    }
                    default: {
                        // 0x1854
                        if (v1 == 38) {
                            // 0x1af0
                            W(10, g27);
                            av();
                            v7 = 38;
                            goto lab_0x1994;
                        } else {
                            if (((int32_t)(g27 == 61) & s) == 0) {
                                if (g27 == 40) {
                                    int32_t v13 = x(0xec81, 0); // 0x1c10
                                    av();
                                    v6 = v2;
                                    v11 = 0;
                                    v12 = v13;
                                    if (g27 == 41) {
                                        // 0x1c30
                                        E(v13, 0);
                                        av();
                                        v5 = 0;
                                        v10 = v2;
                                        goto lab_0x1bc8;
                                    } else {
                                        goto lab_0x18e0;
                                    }
                                } else {
                                    // 0x1880
                                    W(8, v1);
                                    if (g7 == 11) {
                                        // 0x1b24
                                        W(0, v1);
                                        aw(g22);
                                        av();
                                    }
                                    goto lab_0x18a0;
                                }
                            } else {
                                // 0x1b0c
                                av();
                                B();
                                W(6, v1);
                                goto lab_0x18a0;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x1994:
    // 0x1994
    v8 = v7;
    goto lab_0x1994_2;
  lab_0x1994_2:
    // 0x1994
    if (g27 != 40) {
        // 0x19a8
        return 0;
    }
    // 0x1b48
    aw(80);
    int32_t v14 = x(0xec81, 0); // 0x1b58
    av();
    v6 = v8;
    v11 = 1;
    v12 = v14;
    int64_t v15; // 0x17e8
    if (g27 == 41) {
        // 0x1c60
        E(v14, 0);
        av();
        v15 = 0;
        goto lab_0x1c74;
    } else {
        goto lab_0x18e0;
    }
  lab_0x18e0:;
    int64_t v16 = 0; // 0x18f8
    B();
    x(0x248489, (int32_t)v16);
    if (g27 == 44) {
        // 0x1bac
        av();
    }
    int64_t v17 = v16 + 4; // 0x1b80
    int64_t v18 = v17 & 0xffffffff; // 0x1b80
    v16 = v18;
    while (g27 != 41) {
        // 0x1b90
        B();
        x(0x248489, (int32_t)v16);
        if (g27 == 44) {
            // 0x1bac
            av();
        }
        // 0x1b80
        v17 = v16 + 4;
        v18 = v17 & 0xffffffff;
        v16 = v18;
    }
    // 0x1bb4
    E(v12, (int32_t)v17);
    av();
    v5 = v18;
    v10 = v6;
    v15 = v18;
    if (v11 == 0) {
        goto lab_0x1bc8;
    } else {
        goto lab_0x1c74;
    }
  lab_0x1c74:
    // 0x1c74
    x(0x2494ff, (int32_t)v15);
    int64_t v19 = v15 + 4 & 0xffffffff; // 0x1c84
    goto lab_0x1c88;
  lab_0x1bc8:;
    int32_t * v22 = (int32_t *)(0x100000000 * v10 + 0x400000000 >> 32); // 0x1bd0
    *v22 = x(232, *v22);
    v19 = v5;
    goto lab_0x1c88;
  lab_0x1c88:
    // 0x1c88
    if ((int32_t)v19 != 0) {
        // 0x1c8c
        int32_t v20; // 0x1c88
        x(0xc481, v20);
    }
    // 0x19a8
    return 0;
  lab_0x18a0:
    // 0x18a0
    if (g27 != 40) {
        // 0x19a8
        return 0;
    }
    int32_t v21 = x(0xec81, 0); // 0x18bc
    av();
    v6 = v2;
    v11 = 0;
    v12 = v21;
    if (g27 == 41) {
        // 0x1c48
        E(v21, 0);
        av();
        v5 = 0;
        v10 = v2;
        goto lab_0x1bc8;
    } else {
        goto lab_0x18e0;
    }
  lab_0x1adc:
    // 0x1adc
    aw(v3);
    v7 = v9;
    goto lab_0x1994;
  lab_0x1a68:
    // 0x1a68
    *(int32_t *)(int64_t)g15 = (int32_t)&g16;
    v7 = v4;
    goto lab_0x1994;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1c9c - 0x1dd0
// Line range:    300 - 332
int32_t X(int32_t s) {
    if (s == 1) {
        // 0x1d84
        return ab(1);
    }
    uint32_t v1 = s - 1; // 0x1cbc
    X(v1);
    if (g7 != v1) {
        // 0x1d84
        return g7;
    }
    int64_t v2 = 0;
    av();
    int64_t v3; // 0x1c9c
    while (v1 < 9) {
        // 0x1cf0
        aw(80);
        X(v1);
        aw(89);
        if (v1 == 5 || v1 == 4) {
            // 0x1d60
            aq(g22);
        } else {
            // 0x1d14
            aw(g22);
            if (g27 == 37) {
                // 0x1d6c
                aw(146);
            }
        }
        // 0x1d24
        v3 = v2;
        if (g7 != v1) {
            // break (via goto) -> 0x1d78
            goto lab_0x1d78;
        }
        av();
    }
    int64_t v4 = aa(g22, (int32_t)v2); // 0x1d50
    X(v1);
    v3 = v4;
    while (g7 == v1) {
        // 0x1d30
        v2 = v4;
        av();
        while (v1 < 9) {
            // 0x1cf0
            aw(80);
            X(v1);
            aw(89);
            if (v1 == 5 || v1 == 4) {
                // 0x1d60
                aq(g22);
            } else {
                // 0x1d14
                aw(g22);
                if (g27 == 37) {
                    // 0x1d6c
                    aw(146);
                }
            }
            // 0x1d24
            v3 = v2;
            if (g7 != v1) {
                // break (via goto) -> 0x1d78
                goto lab_0x1d78;
            }
            av();
        }
        // 0x1d44
        v4 = aa(g22, (int32_t)v2);
        X(v1);
        v3 = v4;
    }
  lab_0x1d78:
    // 0x1d78
    if (v3 == 0) {
        // 0x1d84
        return g7;
    }
    int32_t v5 = s - 9; // 0x1d7c
    int32_t result = g7; // 0x1d80
    if (v5 != 0 && v5 < 0 == (8 - s & v1) < 0) {
        int32_t v6 = aa(g22, (int32_t)v3); // 0x1da4
        M(g22 ^ 1);
        I(5);
        H(v6);
        result = M(g22);
    }
    // 0x1d84
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1dd0 - 0x1df0
// Line range:    339 - 342
int32_t ac(void) {
    // 0x1dd0
    B();
    return aa(0, 0);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1df0 - 0x1f8c
// Line range:    410 - 450
int32_t ar(int32_t s) {
    int32_t result = g27; // 0x1efc
    if (result != 256 && s == 0 != result != -1) {
        // 0x1f74
        return result;
    }
    int64_t v1; // 0x1f58
    int32_t v2; // 0x1ed0
    int64_t v3; // 0x1df0
    int64_t v4; // 0x1df0
    if (result == 256) {
        // 0x1e20
        av();
        while (true) {
            if (g27 == 59) {
                // break (via goto) -> 0x1e98
                goto lab_0x1e98;
            }
            if (s == 0) {
                // 0x1e34
                *(int32_t *)(int64_t)g27 = *(int32_t *)&g29;
                *g29 = (int32_t)&g32;
            } else {
                // 0x1e70
                *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                *(int32_t *)(int64_t)g27 = -4 - g9;
            }
            // 0x1e4c
            av();
            // 0x1e28
            while (g27 != 44) {
                // 0x1e60
                if (g27 == 59) {
                    // break (via goto) -> 0x1e98
                    goto lab_0x1e98;
                }
                if (s == 0) {
                    // 0x1e34
                    *(int32_t *)(int64_t)g27 = *(int32_t *)&g29;
                    *g29 = (int32_t)&g32;
                } else {
                    // 0x1e70
                    *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                    *(int32_t *)(int64_t)g27 = -4 - g9;
                }
                // 0x1e4c
                av();
            }
            // 0x1e90
            av();
        }
        // 0x1e98
        av();
    } else {
        // 0x1f1c
        *(int32_t *)(int64_t)result = g15;
        av();
        av();
        v3 = 8;
        while (true) {
            // 0x1f44
            if (g27 == 41) {
                // break (via goto) -> 0x1ea0
                goto lab_0x1ea0;
            }
            // 0x1f50
            *(int32_t *)(int64_t)g27 = (int32_t)v3;
            v1 = v3 + 4 & 0xffffffff;
            av();
            v4 = v1;
            while (g27 != 44) {
                // 0x1f44
                if (g27 == 41) {
                    // break (via goto) -> 0x1ea0
                    goto lab_0x1ea0;
                }
                // 0x1f50
                *(int32_t *)(int64_t)g27 = (int32_t)v4;
                v1 = v4 + 4 & 0xffffffff;
                av();
                v4 = v1;
            }
            // 0x1f6c
            av();
            v3 = v1;
        }
        // 0x1ea0
        av();
        *(int32_t *)(int64_t)g9 = 0;
        *(int32_t *)(int64_t)g25 = 0;
        aw(0xe58955);
        v2 = x(0xec81, 0);
        S(0);
        H(g25);
        aw(0xc3c9);
        E(v2, g9);
    }
    int32_t v5 = g27; // 0x1efc
    bool v6 = v5 == 256; // 0x1f10
    int32_t v7 = v5; // 0x1f10
    int32_t result2 = v5; // 0x1f10
    while (v5 == 256 || s == 0 == (v5 != -1)) {
        // 0x1f14
        if (v6) {
            // 0x1e20
            av();
            while (true) {
                if (g27 == 59) {
                    // break (via goto) -> 0x1e98
                    goto lab_0x1e98;
                }
                if (s == 0) {
                    // 0x1e34
                    *(int32_t *)(int64_t)g27 = *(int32_t *)&g29;
                    *g29 = (int32_t)&g32;
                } else {
                    // 0x1e70
                    *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                    *(int32_t *)(int64_t)g27 = -4 - g9;
                }
                // 0x1e4c
                av();
                // 0x1e28
                while (g27 != 44) {
                    // 0x1e60
                    if (g27 == 59) {
                        // break (via goto) -> 0x1e98
                        goto lab_0x1e98;
                    }
                    if (s == 0) {
                        // 0x1e34
                        *(int32_t *)(int64_t)g27 = *(int32_t *)&g29;
                        *g29 = (int32_t)&g32;
                    } else {
                        // 0x1e70
                        *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                        *(int32_t *)(int64_t)g27 = -4 - g9;
                    }
                    // 0x1e4c
                    av();
                }
                // 0x1e90
                av();
            }
            // 0x1e98
            av();
        } else {
            // 0x1f1c
            *(int32_t *)(int64_t)v7 = g15;
            av();
            av();
            v3 = 8;
            while (true) {
                // 0x1f44
                v4 = v3;
                if (g27 == 41) {
                    // break (via goto) -> 0x1ea0
                    goto lab_0x1ea0;
                }
                // 0x1f50
                *(int32_t *)(int64_t)g27 = (int32_t)v4;
                v1 = v4 + 4 & 0xffffffff;
                av();
                v4 = v1;
                while (g27 != 44) {
                    // 0x1f44
                    if (g27 == 41) {
                        // break (via goto) -> 0x1ea0
                        goto lab_0x1ea0;
                    }
                    // 0x1f50
                    *(int32_t *)(int64_t)g27 = (int32_t)v4;
                    v1 = v4 + 4 & 0xffffffff;
                    av();
                    v4 = v1;
                }
                // 0x1f6c
                av();
                v3 = v1;
            }
            // 0x1ea0
            av();
            *(int32_t *)(int64_t)g9 = 0;
            *(int32_t *)(int64_t)g25 = 0;
            aw(0xe58955);
            v2 = x(0xec81, 0);
            S(0);
            H(g25);
            aw(0xc3c9);
            E(v2, g9);
        }
        // 0x1efc
        v5 = g27;
        v6 = v5 == 256;
        v7 = v5;
        result2 = v5;
    }
    // 0x1f74
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1f8c - 0x21d8
// Line range:    343 - 404
int32_t S(int32_t s) {
    // 0x1f8c
    int32_t v1; // 0x1f8c
    int32_t v2; // 0x1f8c
    switch (g27) {
        case 288: {
            // 0x1ff4
            av();
            av();
            v1 = ac();
            av();
            S(s);
            int32_t result; // 0x1f8c
            if (g27 == 312) {
                // 0x2030
                av();
                int32_t v3 = I(0); // 0x2038
                H(v1);
                S(s);
                result = H(v3);
            } else {
                // 0x2024
                result = H(v1);
            }
            // 0x1fe8
            return result;
        }
        case 504: {
        }
        case 352: {
            // 0x205c
            av();
            av();
            if (g27 == 352) {
                // 0x2130
                v1 = ac();
                v2 = g15;
            } else {
                // 0x206c
                if (g27 != 59) {
                    // 0x2080
                    B();
                }
                // 0x2084
                av();
                v1 = 0;
                if (g27 != 59) {
                    // 0x20ac
                    v1 = ac();
                }
                // 0x20b4
                av();
                v2 = g15;
                if (g27 != 41) {
                    int32_t v4 = I(0); // 0x20d0
                    B();
                    I(g15 - 5 - g15);
                    H(v4);
                    v2 = v4 + 4;
                }
            }
            // break -> 0x2100
            break;
        }
        case 123: {
            // 0x2148
            av();
            ar(1);
            if (g27 != 125) {
                S(s);
                while (g27 != 125) {
                    // 0x2170
                    S(s);
                }
            }
            // 0x1fe8
            return av();
        }
        case 448: {
            // 0x218c
            av();
            if (g27 != 59) {
                // 0x21a4
                B();
            }
            uint32_t v5 = g25;
            *(int32_t *)(int64_t)v5 = I(v5);
            // 0x1fe8
            return av();
        }
        case 400: {
            // 0x21c0
            av();
            int64_t v6; // 0x1f8c
            *(int32_t *)(int64_t)s = I((int32_t)v6);
            // 0x1fe8
            return av();
        }
        case 59: {
            // 0x1fe8
            return av();
        }
        default: {
            // 0x1fe0
            B();
            // 0x1fe8
            return av();
        }
    }
    // 0x2100
    av();
    S((int32_t)(int64_t)&v1);
    I(v2 - 5 - g15);
    // 0x1fe8
    return H(v1);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x21d8 - 0x2210
// Line range:    451 - 454
int32_t ax(int32_t d) {
    // 0x21d8
    E((int32_t)(int64_t)g29, d);
    *g29 = (int32_t)&g32;
    return &g32;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2210 - 0x2260
// Line range:    455 - 462
int32_t ad(int32_t d, int32_t a) {
    // 0x2210
    ax(d);
    int32_t v1 = d + 0x8048000; // 0x2230
    ax(v1);
    ax(v1);
    ax(a);
    return ax(a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2260 - 0x2498
// Line range:    463 - 505
int32_t ae(int32_t s) {
    // 0x2260
    while (true) {
        int64_t v1 = (int64_t)*(int32_t *)&g26 + 1; // 0x2330
        int64_t v2 = v1 & 0xffffffff; // 0x2330
        int64_t v3 = 0x100000000 * v1 >> 32; // 0x2334
        int64_t v4 = v2; // 0x2340
        int64_t v5; // 0x2358
        int64_t v6; // 0x2358
        uint64_t v7; // 0x2348
        int64_t v8; // 0x2260
        if (*(char *)v3 != 32) {
            // 0x2344
            v7 = (int64_t)g6;
            v8 = v2;
            v4 = v2;
            if (v2 < v7) {
                v5 = v8 + 1;
                v6 = v5 & 0xffffffff;
                v4 = v6;
                while (*(char *)(0x100000000 * v5 >> 32) != 32 == v6 < v7) {
                    // 0x2358
                    v5 = v6 + 1;
                    v6 = v5 & 0xffffffff;
                    v4 = v6;
                }
            }
        }
        int64_t v9 = v4;
        int32_t v10 = v9;
        while (g6 != v10) {
            int32_t v11 = v1; // 0x2384
            int32_t v12 = 8 * (v11 - *(int32_t *)&g26) + *(int32_t *)&g8; // 0x2394
            int32_t v13 = v12 + 248; // 0x2398
            *(int32_t *)(int64_t)g27 = v13;
            int32_t v14 = *(int32_t *)(int64_t)v13; // 0x23ac
            int32_t v15 = *(int32_t *)(int64_t)(v12 + 252); // 0x23b8
            if (v14 != 1 && v15 != 0) {
                if (v14 == 0) {
                    if (s != 0) {
                        // break -> 0x23d4
                        break;
                    }
                    // 0x22bc
                    memcpy((int64_t *)(0x100000000 * (int64_t)g29 >> 32), (int64_t *)v3, v10 - v11);
                    *g29 = 1 - v11 + v10 + *(int32_t *)&g29;
                } else {
                    if (s == 0) {
                        // 0x2470
                        ap(v15, v14);
                    }
                }
            }
            v1 = v9 + 1;
            v2 = v1 & 0xffffffff;
            v3 = 0x100000000 * v1 >> 32;
            v4 = v2;
            if (*(char *)v3 != 32) {
                // 0x2344
                v7 = (int64_t)g6;
                v8 = v2;
                v4 = v2;
                if (v2 < v7) {
                    v5 = v8 + 1;
                    v6 = v5 & 0xffffffff;
                    v4 = v6;
                    while (*(char *)(0x100000000 * v5 >> 32) != 32 == v6 < v7) {
                        // 0x2358
                        v5 = v6 + 1;
                        v6 = v5 & 0xffffffff;
                        v4 = v6;
                    }
                }
            }
            // 0x2374
            v9 = v4;
            v10 = v9;
        }
        return g6;
    }
    // 0x247c
    uint32_t result; // 0x2260
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2498 - 0x28a4
// Line range:    506 - 595
int32_t au(int32_t F) {
    // 0x2498
    *g12 = (int32_t)(int64_t)g29;
    int32_t v1 = *(int32_t *)&g24; // 0x24d8
    int32_t v2 = g15 - v1; // 0x24e8
    *(int32_t *)(int64_t)g15 = v1;
    aw(0x505458);
    int32_t v3 = *(int32_t *)&g8; // 0x2504
    int32_t v4 = *(int32_t *)(int64_t)(v3 + (int32_t)&g43); // 0x2510
    x(232, v4 - 5 - g15);
    aw(0xc389);
    M(1);
    aw(0x80cd);
    int32_t v5 = *(int32_t *)&g29 + v2; // 0x2544
    int64_t v6 = v5 + 1; // 0x254c
    *(int64_t *)v6 = 0x2e6f732e6362696c;
    *(int16_t *)(v6 + 8) = 54;
    int64_t v7 = v5 + 11; // 0x256c
    *(int64_t *)v7 = 0x6f732e6c6462696c;
    *(int32_t *)(v7 + 7) = 0x322e6f;
    *g29 = v5 + 22;
    ae(0);
    *g29 = (int32_t)&g31;
    ax(0);
    ax(0);
    ax(0);
    ax(0);
    ae(1);
    int32_t v8 = *(int32_t *)&g29; // 0x25d4
    int32_t v9 = (v8 - (int32_t)&g31) / 0x8000; // 0x25e8
    ax(1);
    ax(v9);
    ax(1);
    ax(0);
    int64_t v10 = 2; // 0x2610
    int64_t v11 = v10 + 1; // 0x2618
    ax((int32_t)v10);
    v10 = v11 & 0xffffffff;
    while (v9 != (int32_t)v11) {
        // 0x2618
        v11 = v10 + 1;
        ax((int32_t)v10);
        v10 = v11 & 0xffffffff;
    }
    // 0x262c
    ax(0);
    int32_t v12 = (int64_t)g29;
    ae(2);
    int32_t v13 = *(int32_t *)&g24; // 0x265c
    int32_t v14 = *(int32_t *)&g12; // 0x2660
    memcpy((int64_t *)(int64_t)v14, (int64_t *)(int64_t)v13, v2);
    int32_t v15 = *(int32_t *)&g29; // 0x2668
    *g29 = *(int32_t *)&g23;
    ax(0x464c457f);
    ax(0x10101);
    ax(0);
    ax(0);
    ax(0x30002);
    ax(1);
    ax(*(int32_t *)&g35 + *(int32_t *)&g12);
    ax(48);
    ax(0);
    ax(0);
    ax(0x200034);
    ax(3);
    ax(3);
    ad(144, 19);
    ax(4);
    ax(1);
    ax(1);
    ad(0, v15 - *(int32_t *)&g23);
    ax(7);
    ax(0x1000);
    ax(2);
    ad(164, 88);
    ax(6);
    ax(4);
    *(int64_t *)(int64_t)*(int32_t *)&g29 = 0x2d646c2f62696c2f;
    g33 = 0x756e696c;
    *(int32_t *)&g34 = 0x322e6f;
    *g29 = (int32_t)&g36;
    ax(1);
    ax(1);
    ax(1);
    ax(11);
    ax(4);
    ax(*(int32_t *)&g35 + v8);
    ax(6);
    ax(*(int32_t *)&g35 + (int32_t)&g31);
    ax(5);
    ax(*(int32_t *)&g35 + v5);
    ax(10);
    ax(*(int32_t *)&g29 - v5);
    ax(11);
    ax(16);
    ax(17);
    ax(*(int32_t *)&g35 + v12);
    ax(18);
    ax(v15 - v12);
    ax(19);
    ax(8);
    ax(0);
    ax(0);
    struct _IO_FILE * file = fopen((char *)(int64_t)F, "w"); // 0x285c
    int32_t data = *(int32_t *)&g23; // 0x2860
    fwrite((int64_t *)(int64_t)data, 1, v15 - data, file);
    return fclose(file);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x28a4 - 0x2a1c
// Line range:    596 - 599
int main(int d, char ** a) {
    if (d < 3) {
        // 0x2a0c
        puts("usage: otccelf file.c outfile");
    } else {
        int64_t * mem = calloc(1, 0x1869f); // 0x28d4
        int64_t v1 = (int64_t)mem; // 0x28d4
        *g26 = (int32_t)v1;
        int64_t v2 = 0x100000000 * v1 >> 32; // 0x28e4
        *mem = 0x20666920746e6920;
        *(int64_t *)(v2 + 8) = 0x6968772065736c65;
        *(int64_t *)(v2 + 16) = 0x6b6165726220656c;
        *(int64_t *)(v2 + 24) = 0x206e727574657220;
        *(int64_t *)(v2 + 32) = 0x6966656420726f66;
        *(int64_t *)(v2 + 40) = 0x206e69616d20656e;
        int64_t v3 = v2 + 48; // 0x290c
        *(char *)v3 = 0;
        *(int32_t *)(int64_t)g6 = (int32_t)v3;
        int32_t mem2 = (int64_t)calloc(1, 0x1869f); // 0x2930
        *(int32_t *)g23 = mem2;
        *g29 = mem2;
        int32_t mem3 = (int64_t)calloc(1, 0x1869f); // 0x2954
        *(int32_t *)g24 = mem3;
        int32_t * v4 = (int32_t *)(int64_t)g15; // 0x295c
        *v4 = mem3;
        *g8 = (int32_t)(int64_t)calloc(1, 0x1869f);
        int64_t v5 = 0x100000000 * (int64_t)a; // 0x297c
        struct _IO_FILE * file = fopen((char *)(int64_t)*(int32_t *)(v5 + 0x400000000 >> 32), "r"); // 0x2990
        *g19 = (int32_t)(int64_t)file;
        *g35 = 0x8048000 - *(int32_t *)&g23;
        *g29 = (int32_t)&ak;
        *v4 = (int32_t)&g20;
        w();
        av();
        ar(0);
        au(*(int32_t *)(v5 + 0x800000000 >> 32));
    }
    // 0x29f4
    return 0;
}

// Address range: 0x2a20 - 0x2a98
int64_t __libc_csu_init(void) {
    // 0x2a20
    int64_t v1; // 0x2a20
    int64_t result = _init(v1); // 0x2a54
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x2a84
        return result;
    }
    // 0x2a64
    return v1 & 0xffffffff;
}

// Address range: 0x2a98 - 0x2a9c
int64_t __libc_csu_fini(void) {
    // 0x2a98
    int64_t result; // 0x2a98
    return result;
}

// Address range: 0x2a9c - 0x2aac
int64_t _fini(int64_t a1) {
    // 0x2a9c
    int64_t result; // 0x2a9c
    return result;
}

// Address range: 0x400001418 - 0x400001419
int64_t function_400001418(void) {
    // 0x400001418
    int64_t result; // 0x400001418
    return result;
}

// Address range: 0x400001464 - 0x400001465
int64_t function_400001464(void) {
    // 0x400001464
    int64_t result; // 0x400001464
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// int fclose(FILE * stream);
// int fgetc(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// int isalnum(int c);
// int isspace(int c);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int puts(const char * s);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 55

