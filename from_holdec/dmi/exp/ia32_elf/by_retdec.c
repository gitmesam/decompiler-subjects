//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t advanced_1_boolean_minization(int32_t a1, int32_t a2, int32_t a3);
int32_t intermediate_1_cmp_with_are_constant(int32_t a1);
int32_t intermediate_2_cmp_with_extra(int32_t a1);
int32_t intermediate_3_division_by_multiplication(int64_t a1);
int32_t intermediate_4_swap_with_xor(int32_t c2, int32_t c);

// ------------------------ Functions -------------------------

// Address range: 0x8048370 - 0x80483f7
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // 0x8048384
    int32_t v2 = intermediate_1_cmp_with_are_constant(v1); // 0x804838a
    int32_t v3 = v2 + intermediate_2_cmp_with_extra(v1); // 0x8048399
    int32_t v4 = v3 + intermediate_3_division_by_multiplication(0); // 0x80483a3
    int32_t v5 = v4 + intermediate_4_swap_with_xor(48, 97); // ebx
    int32_t v6 = v5 + advanced_1_boolean_minization((int32_t)(argv == NULL), v1 % 2 ^ 1, (int32_t)(v1 % 3 == 0)); // 0x80483e8
    exit((int32_t)*(char *)*(int32_t *)0 + v6);
    int32_t * v7;
    return (int32_t)&v7;
}

// Address range: 0x80484eb - 0x8048551
int32_t intermediate_1_cmp_with_are_constant(int32_t a1) {
    // 0x80484eb
    if (a1 != 1) {
        // 0x8048548
        return 0;
    }
    // 0x80484f5
    if (a1 == 2) {
        // 0x80484fc
        puts("not reached");
        // branch -> 0x8048513
    }
    // 0x8048513
    if (a1 > 2) {
        // 0x804852a
        puts("not reached");
        // branch -> 0x8048548
    }
    // 0x8048548
    return 0;
}

// Address range: 0x8048551 - 0x80485be
int32_t intermediate_2_cmp_with_extra(int32_t a1) {
    // 0x8048551
    if (a1 <= 19 && a1 > 10) {
        // 0x8048562
        puts("!=30 is always true");
        // branch -> 0x8048579
    }
    // 0x8048579
    if (a1 != 2 && a1 == 1) {
        // 0x8048587
        puts("!=2 is always true");
        // branch -> 0x8048597
    }
    // 0x8048597
    if (a1 > 10) {
        // 0x804859e
        puts(">9 is always true");
        // branch -> 0x80485b5
    }
    // 0x80485b5
    return 0;
}

// Address range: 0x80485be - 0x80485e4
int32_t intermediate_3_division_by_multiplication(int64_t a1) {
    int32_t v1 = a1; // 0x80485c6
    putchar(((int32_t)(-0x6db6db6d * a1 / 0x100000000) + v1) / 4 - (v1 >> 31));
    return 0;
}

// Address range: 0x80485e4 - 0x804861a
int32_t intermediate_4_swap_with_xor(int32_t c2, int32_t c) {
    // 0x80485e4
    putchar(c);
    putchar(c2);
    return 0;
}

// Address range: 0x804861a - 0x804865f
int32_t advanced_1_boolean_minization(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804861a
    int32_t result;
    if (a1 == 0) {
        // 0x8048621
        if (a3 == 0) {
            // 0x8048659
            result = 0;
            // branch -> 0x804865e
        } else {
            result = 1;
        }
        // 0x804865e
        return result;
    }
    // 0x804864b
    if (a2 != 0) {
        // 0x8048659
        result = 0;
        // branch -> 0x804865e
    } else {
        result = 1;
    }
    // 0x804865e
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// void exit(int status);
// int putchar(int c);
// int puts(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.4.1)
// Detected functions: 6
// Decompilation date: 2018-09-10 17:11:49
