//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

// ------------------- Function Prototypes --------------------

int32_t __divdi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __moddi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __udivdi3(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4);
int32_t __umoddi3(uint32_t result2, uint32_t a2, uint32_t a3, uint32_t a4);
int32_t advanced_1_unrolled_loop(void);
int32_t basic_1_ternary_simple(int32_t a1);
int32_t basic_2_ternary_other(int32_t a1);
int32_t intermediate_10_double_word_signed_math(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, uint32_t a5, uint32_t a6);
int32_t intermediate_10_double_word_unsigned_math(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, uint32_t a5, uint32_t a6);
int32_t intermediate_1_ternary_blocks(int32_t a1);
int32_t intermediate_2_other_in_blocks(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------------------------ Functions -------------------------

// Address range: 0x8048340 - 0x80483c8
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // 0x8048354
    int32_t v2 = v1 >> 31; // 0x804835f
    int32_t v3 = basic_1_ternary_simple(v1); // 0x8048362
    int32_t v4 = basic_2_ternary_other(v1); // 0x804836c
    int32_t v5 = intermediate_1_ternary_blocks(v1); // 0x8048377
    int32_t v6 = intermediate_2_other_in_blocks(v1); // 0x8048381
    int32_t v7 = intermediate_10_double_word_signed_math(v1, v2, v1, v2, v1, v2); // 0x8048390
    int32_t v8 = intermediate_10_double_word_unsigned_math(v1, v2, v1, v2, v1, v2); // 0x80483a0
    int32_t v9 = advanced_1_unrolled_loop(); // 0x80483aa
    int32_t v10; // 0x8048340
    char v11 = *(char *)*(int32_t *)v10; // 0x80483b6
    return v4 + v3 + v5 + v6 + v7 + v8 + v9 + (int32_t)v11;
}

// Address range: 0x80484c0 - 0x80484cb
int32_t basic_1_ternary_simple(int32_t a1) {
    // 0x80484c0
    return (bool)(a1 != 42);
}

// Address range: 0x80484d0 - 0x80484e3
int32_t basic_2_ternary_other(int32_t a1) {
    // 0x80484d0
    return a1 != 42 ? 201 : 100;
}

// Address range: 0x80484f0 - 0x804867a
int32_t intermediate_10_double_word_signed_math(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, uint32_t a5, uint32_t a6) {
    uint32_t v1 = a3 + a1; // 0x8048513
    int32_t v2 = a4 + a2 + (int32_t)(v1 < a3); // 0x8048519
    if (v2 >= a6) {
        if (v2 > a6) {
            // 0x8048525
            puts("add");
        } else {
            if (v1 > a5) {
                // 0x80485f8
                puts("add");
            }
        }
    }
    int32_t v3 = a2 - a4 + (int32_t)(a1 < a3); // 0x8048540
    if (v3 >= a6) {
        if (v3 > a6) {
            // 0x804854e
            puts("sub");
        } else {
            if (a1 - a3 > a5) {
                // 0x8048638
                puts("sub");
            }
        }
    }
    // 0x8048560
    int32_t v4; // bp-44, 0x80484f0
    int32_t v5 = &v4; // 0x80484f4
    int32_t * v6 = (int32_t *)(v5 + 8); // 0x8048560
    uint32_t v7 = *v6; // 0x8048560
    int32_t * v8 = (int32_t *)(v5 + 12); // 0x8048564
    uint64_t v9 = (int64_t)v7 * (int64_t)a1; // 0x8048578
    int32_t v10 = *v8 * a1 + v7 * a2 + (int32_t)(v9 / 0x100000000); // 0x804857a
    if (v10 >= a6) {
        if (v10 > a6) {
            // 0x8048586
            *(int32_t *)(v5 - 16) = (int32_t)"mult";
            puts((char *)&g1);
        } else {
            if ((int32_t)v9 > a5) {
                // 0x8048614
                *(int32_t *)(v5 - 16) = (int32_t)"mult";
                puts((char *)&g1);
            }
        }
    }
    int32_t * v11 = (int32_t *)(v5 - 4); // 0x80485a0
    *v11 = *v8;
    int32_t * v12 = (int32_t *)(v5 - 8); // 0x80485a4
    *v12 = *v6;
    int32_t * v13 = (int32_t *)(v5 - 12); // 0x80485a8
    *v13 = a2;
    int32_t * v14 = (int32_t *)(v5 - 16); // 0x80485a9
    *v14 = a1;
    uint32_t v15 = __divdi3((int32_t)&g1, (int32_t)&g1, (int32_t)&g1, (int32_t)&g1); // 0x80485aa
    if (v10 >= a6) {
        if (v10 <= a6 != v15 <= a5) {
            // 0x80485bc
            *v14 = (int32_t)"diff";
            puts((char *)&g1);
        }
    }
    // 0x80485cc
    *v11 = *v8;
    *v12 = *v6;
    *v13 = a2;
    *v14 = a1;
    int32_t v16 = __moddi3((int32_t)&g1, (int32_t)&g1, (int32_t)&g1, (int32_t)&g1); // 0x80485d6
    if (v10 == a6 != (v16 == a5)) {
        // 0x80485e6
        return 0;
    }
    // 0x8048660
    *v14 = (int32_t)"modulo";
    puts((char *)&g1);
    return 0;
}

// Address range: 0x8048680 - 0x804880a
int32_t intermediate_10_double_word_unsigned_math(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, uint32_t a5, uint32_t a6) {
    uint32_t v1 = a3 + a1; // 0x80486a3
    uint32_t v2 = a4 + a2 + (int32_t)(v1 < a3); // 0x80486a9
    if (v2 >= a6) {
        if (v2 > a6) {
            // 0x80486b5
            puts("add");
        } else {
            if (v1 > a5) {
                // 0x8048788
                puts("add");
            }
        }
    }
    uint32_t v3 = a2 - a4 + (int32_t)(a1 < a3); // 0x80486d0
    if (v3 >= a6) {
        if (v3 <= a6) {
            if (a1 - a3 > a5) {
                // 0x80487c8
                puts("sub");
            }
        } else {
            // 0x80486de
            puts("sub");
        }
    }
    // 0x80486f0
    int32_t v4; // bp-44, 0x8048680
    int32_t v5 = &v4; // 0x8048684
    int32_t * v6 = (int32_t *)(v5 + 8); // 0x80486f0
    uint32_t v7 = *v6; // 0x80486f0
    int32_t * v8 = (int32_t *)(v5 + 12); // 0x80486f4
    uint64_t v9 = (int64_t)v7 * (int64_t)a1; // 0x8048708
    uint32_t v10 = *v8 * a1 + v7 * a2 + (int32_t)(v9 / 0x100000000); // 0x804870a
    if (v10 >= a6) {
        if (v10 <= a6) {
            if ((int32_t)v9 > a5) {
                // 0x80487a4
                *(int32_t *)(v5 - 16) = (int32_t)"mult";
                puts((char *)&g1);
            }
        } else {
            // 0x8048716
            *(int32_t *)(v5 - 16) = (int32_t)"mult";
            puts((char *)&g1);
        }
    }
    int32_t * v11 = (int32_t *)(v5 - 4); // 0x8048730
    *v11 = *v8;
    int32_t * v12 = (int32_t *)(v5 - 8); // 0x8048734
    *v12 = *v6;
    int32_t * v13 = (int32_t *)(v5 - 12); // 0x8048738
    *v13 = a2;
    int32_t * v14 = (int32_t *)(v5 - 16); // 0x8048739
    *v14 = a1;
    uint32_t v15 = __udivdi3((int32_t)&g1, (int32_t)&g1, (int32_t)&g1, (int32_t)&g1); // 0x804873a
    if (v10 >= a6) {
        if (v10 > a6 || v15 > a5) {
            // 0x804874c
            *v14 = (int32_t)"diff";
            puts((char *)&g1);
        }
    }
    // 0x804875c
    *v11 = *v8;
    *v12 = *v6;
    *v13 = a2;
    *v14 = a1;
    int32_t v16 = __umoddi3((int32_t)&g1, (int32_t)&g1, (int32_t)&g1, (int32_t)&g1); // 0x8048766
    if (v10 == a6 != (v16 == a5)) {
        // 0x8048776
        return 0;
    }
    // 0x80487f0
    *v14 = (int32_t)"modulo";
    puts((char *)&g1);
    return 0;
}

// Address range: 0x8048810 - 0x8048904
int32_t advanced_1_unrolled_loop(void) {
    // 0x8048810
    puts("basic");
    int32_t v1; // bp-12, 0x8048810
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16);
    int32_t v3 = 48; // 0x8048829
    *v2 = v3;
    v3++;
    putchar((int32_t)&g1);
    while (v3 != 58) {
        // 0x8048830
        *v2 = v3;
        v3++;
        putchar((int32_t)&g1);
    }
    // 0x8048844
    *v2 = (int32_t)"partial unrolled";
    puts((char *)&g1);
    for (int32_t i = 48; i < 57; i += 2) {
        // 0x8048859
        *v2 = i;
        putchar((int32_t)&g1);
        *v2 = i | 1;
        putchar((int32_t)&g1);
    }
    // 0x8048878
    *v2 = (int32_t)"fully unrolled";
    puts((char *)&g1);
    *v2 = 48;
    putchar((int32_t)&g1);
    *v2 = 49;
    putchar((int32_t)&g1);
    *v2 = 50;
    putchar((int32_t)&g1);
    *v2 = 51;
    putchar((int32_t)&g1);
    *v2 = 52;
    putchar((int32_t)&g1);
    *v2 = 53;
    putchar((int32_t)&g1);
    *v2 = 54;
    putchar((int32_t)&g1);
    *v2 = 55;
    putchar((int32_t)&g1);
    *v2 = 56;
    putchar((int32_t)&g1);
    *v2 = 57;
    putchar((int32_t)&g1);
    return 0;
}

// Address range: 0x8048904 - 0x804891b
int32_t intermediate_1_ternary_blocks(int32_t a1) {
    // 0x8048904
    return (bool)(a1 != 42);
}

// Address range: 0x804891b - 0x8048932
int32_t intermediate_2_other_in_blocks(int32_t a1) {
    // 0x804891b
    return a1 != 42 ? 201 : 100;
}

// Address range: 0x8048940 - 0x8048aaa
int32_t __divdi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // 0x804896a
    int32_t v2 = a1; // 0x804896a
    int32_t v3 = a2; // 0x804896a
    if (a2 < 0) {
        // 0x8048a28
        v1 = -1;
        v2 = -a1;
        v3 = -(((int32_t)(a1 != 0) + a2));
    }
    uint32_t v4 = v3;
    int32_t v5 = a3; // 0x8048972
    int32_t v6 = v1; // 0x8048972
    int32_t v7 = a4; // 0x8048972
    if (a4 < 0) {
        // 0x8048a10
        v5 = -a3;
        v6 = -1 - v1;
        v7 = -(((int32_t)(a3 != 0) + a4));
    }
    uint32_t v8 = v5;
    int32_t v9; // 0x8048940
    int32_t v10; // 0x8048940
    if (v7 == 0) {
        if (v8 > v4) {
            // 0x8048994
            v9 = (0x100000000 * (int64_t)v4 | (int64_t)v2) / (int64_t)v8;
        } else {
            uint32_t v11 = v8 != 0 ? v8 : (int32_t)(v8 == 1);
            v9 = (0x100000000 * (int64_t)(v4 % v11) | (int64_t)v2) / (int64_t)v11;
        }
        // 0x80489a8
        v10 = v9;
        return v6 == 0 ? v10 : -v10;
    }
    // 0x80489a0
    if (v7 > v4) {
        // 0x80489a8
        v10 = 0;
        return v6 == 0 ? v10 : -v10;
    }
    uint32_t v12 = llvm_ctlz_i32(v7, true); // 0x80489c8
    if (v12 == 0) {
        // 0x80489d0
        v9 = v8 <= v2 | v7 < v4;
        // 0x80489a8
        v10 = v9;
        return v6 == 0 ? v10 : -v10;
    }
    uint32_t v13 = -v12 % 32; // 0x8048a4f
    uint64_t v14 = 0x100000000 * (int64_t)(v4 >> v13) | (int64_t)(v2 >> v13 | v4 << v12); // 0x8048a72
    uint64_t v15 = (int64_t)(v8 >> v13 | v7 << v12); // 0x8048a72
    uint64_t v16 = v14 / v15; // 0x8048a72
    int32_t v17 = v16; // 0x8048a72
    uint32_t v18 = (int32_t)(v14 % v15); // 0x8048a72
    uint64_t v19 = (v16 & 0xffffffff) * (int64_t)(v8 << v12); // 0x8048a79
    uint32_t v20 = (int32_t)(v19 / 0x100000000); // 0x8048a79
    if (v18 < v20 || v2 << v12 < (int32_t)v19 == v18 == v20) {
        // 0x80489a8
        v10 = v17 - 1;
        return v6 == 0 ? v10 : -v10;
    }
    // 0x80489a8
    v10 = v17;
    return v6 == 0 ? v10 : -v10;
}

// Address range: 0x8048ab0 - 0x8048c88
int32_t __moddi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // 0x8048ada
    int32_t v2 = a1; // 0x8048ada
    int32_t v3 = a2; // 0x8048ada
    if (a2 < 0) {
        // 0x8048bb8
        v1 = -1;
        v2 = -a1;
        v3 = -(((int32_t)(a1 != 0) + a2));
    }
    uint32_t v4 = v3;
    int32_t v5 = a3; // 0x8048ae2
    int32_t v6 = a4; // 0x8048ae2
    if (a4 < 0) {
        // 0x8048ba0
        v5 = -a3;
        v6 = -(((int32_t)(a3 != 0) + a4));
    }
    uint32_t v7 = v5;
    int32_t v8; // 0x8048ab0
    int32_t v9; // 0x8048ab0
    if (v6 == 0) {
        if (v7 > v4) {
            // 0x8048b0f
            v8 = (0x100000000 * (int64_t)v4 | (int64_t)v2) % (int64_t)v7;
        } else {
            uint32_t v10 = v7 != 0 ? v7 : (int32_t)(v7 == 1);
            v8 = (0x100000000 * (int64_t)(v4 % v10) | (int64_t)v2) % (int64_t)v10;
        }
        // 0x8048b2c
        v9 = v8;
        return v1 == 0 ? v9 : -v9;
    }
    // 0x8048b20
    if (v6 > v4) {
        // 0x8048b2c
        v9 = v2;
        return v1 == 0 ? v9 : -v9;
    }
    uint32_t v11 = llvm_ctlz_i32(v6, true); // 0x8048b48
    if (v11 == 0) {
        int32_t v12 = v2 < v7 == v6 >= v4 ? 0 : v7;
        // 0x8048b2c
        v9 = v2 - v12;
        return v1 == 0 ? v9 : -v9;
    }
    uint32_t v13 = -v11 % 32; // 0x8048bed
    uint32_t v14 = v7 >> v13 | v6 << v11; // 0x8048bf7
    uint32_t v15 = v7 << v11;
    uint32_t v16 = v2 << v11;
    uint64_t v17 = 0x100000000 * (int64_t)(v4 >> v13) | (int64_t)(v2 >> v13 | v4 << v11); // 0x8048c28
    uint64_t v18 = (int64_t)v14; // 0x8048c28
    uint32_t v19 = (int32_t)(v17 % v18); // 0x8048c28
    uint64_t v20 = (v17 / v18 & 0xffffffff) * (int64_t)v15; // 0x8048c2d
    uint32_t v21 = (int32_t)v20; // 0x8048c2d
    int32_t v22 = v20 / 0x100000000; // 0x8048c2d
    int32_t v23; // 0x8048ab0
    int32_t v24; // 0x8048ab0
    if (v19 < v22) {
        // 0x8048c3d
        v23 = v22 - v14 + (int32_t)(v15 > v21);
        v24 = v21 - v15;
        goto lab_0x8048c46;
    } else {
        // 0x8048c37
        v23 = v22;
        v24 = v21;
        if (v16 < v21 == v19 == v22) {
            // 0x8048c3d
            v23 = v22 - v14 + (int32_t)(v15 > v21);
            v24 = v21 - v15;
            goto lab_0x8048c46;
        } else {
            goto lab_0x8048c46;
        }
    }
  lab_0x8048c46:;
    uint32_t v25 = v24;
    v8 = v19 - v23 + (int32_t)(v16 < v25) << v13 | v16 - v25 >> v11;
    // 0x8048b2c
    v9 = v8;
    return v1 == 0 ? v9 : -v9;
}

// Address range: 0x8048c90 - 0x8048db2
int32_t __udivdi3(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4) {
    if (a4 == 0) {
        if (a3 > a2) {
            // 0x8048d80
            return (uint64_t)(0x100000000 * (int64_t)a2 | (int64_t)a1) / (uint64_t)(int64_t)a3;
        }
        uint32_t v1 = a3 != 0 ? a3 : (int32_t)(bool)(a3 == 1);
        int32_t result = (0x100000000 * (int64_t)(a2 % v1) | (int64_t)a1) / (int64_t)v1; // 0x8048cda
        // 0x8048cdc
        return result;
    }
    // 0x8048cf0
    if (a4 > a2) {
        // 0x8048cdc
        return 0;
    }
    uint32_t v2 = llvm_ctlz_i32(a4, true); // 0x8048cf4
    if (v2 == 0) {
        // 0x8048d98
        return a3 <= a1 | a4 < a2;
    }
    uint32_t v3 = -v2 % 32; // 0x8048d0f
    uint64_t v4 = 0x100000000 * (int64_t)(a2 >> v3) | (int64_t)(a1 >> v3 | a2 << v2); // 0x8048d33
    uint64_t v5 = (int64_t)(a3 >> v3 | a4 << v2); // 0x8048d33
    uint64_t v6 = v4 / v5; // 0x8048d33
    int32_t result2 = v6; // 0x8048d33
    uint32_t v7 = (int32_t)(v4 % v5); // 0x8048d33
    uint64_t v8 = (v6 & 0xffffffff) * (int64_t)(a3 << v2); // 0x8048d39
    uint32_t v9 = (int32_t)(v8 / 0x100000000); // 0x8048d39
    if (v7 >= v9) {
        // 0x8048d41
        if (a1 << v2 < (int32_t)v8 != (v7 == v9)) {
            // 0x8048cdc
            return result2;
        }
    }
    // 0x8048cdc
    return result2 - 1;
}

// Address range: 0x8048dc0 - 0x8048f01
int32_t __umoddi3(uint32_t result2, uint32_t a2, uint32_t a3, uint32_t a4) {
    if (a4 == 0) {
        int32_t result; // 0x8048dc0
        if (a3 > a2) {
            // 0x8048df0
            result = (uint64_t)(0x100000000 * (int64_t)a2 | (int64_t)result2) % (uint64_t)(int64_t)a3;
        } else {
            uint32_t v1 = a3 != 0 ? a3 : (int32_t)(bool)(a3 == 1);
            result = (0x100000000 * (int64_t)(a2 % v1) | (int64_t)result2) % (int64_t)v1;
        }
        // 0x8048df4
        return result;
    }
    // 0x8048e00
    if (a4 > a2) {
        // 0x8048df4
        return result2;
    }
    uint32_t v2 = llvm_ctlz_i32(a4, true); // 0x8048e06
    if (v2 == 0) {
        // 0x8048df4
        return result2 - (result2 < a3 == a4 >= a2 ? 0 : a3);
    }
    uint32_t v3 = -v2 % 32; // 0x8048e72
    uint32_t v4 = a3 >> v3 | a4 << v2; // 0x8048e76
    uint32_t v5 = a3 << v2;
    uint64_t v6 = 0x100000000 * (int64_t)(a2 >> v3) | (int64_t)(result2 >> v3 | a2 << v2); // 0x8048ea1
    uint64_t v7 = (int64_t)v4; // 0x8048ea1
    uint32_t v8 = (int32_t)(v6 % v7); // 0x8048ea1
    uint32_t v9 = result2 << v2;
    uint64_t v10 = (v6 / v7 & 0xffffffff) * (int64_t)v5; // 0x8048ea8
    uint32_t v11 = (int32_t)v10; // 0x8048ea8
    int32_t v12 = v10 / 0x100000000; // 0x8048ea8
    uint32_t v13; // 0x8048dc0
    if (v8 >= v12) {
        // 0x8048eb8
        if (v9 < v11 != (v8 == v12)) {
            // 0x8048ecb
            v13 = v11;
            return v8 - v12 + (int32_t)(v9 < v13) << v3 | v9 - v13 >> v2;
        }
    }
    // 0x8048ecb
    v13 = v11 - v5;
    int32_t v14 = v12 - v4 + (int32_t)(v5 > v11);
    return v8 - v14 + (int32_t)(v9 < v13) << v3 | v9 - v13 >> v2;
}

// --------------- Dynamically Linked Functions ---------------

// int putchar(int c);
// int puts(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.4.1)
// Detected functions: 12

