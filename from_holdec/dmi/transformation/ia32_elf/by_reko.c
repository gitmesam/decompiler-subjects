// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080482CC: void _init()
void _init()
{
	if (__x86.get_pc_thunk.bx(dwLoc10)->dw2D27 != 0x00)
		fn08048330();
}

// 08048330: void fn08048330()
void fn08048330()
{
	word32 esp_3;
	globals->ptr804AFFC();
}

// 08048340: void main(Stack word32 dwArg00, Stack Eq_19 dwArg04, Stack word32 dwArg08)
void main(word32 dwArg00, Eq_19 dwArg04, word32 dwArg08)
{
	__align(fp);
	basic_1_ternary_simple(dwArg04);
	basic_2_ternary_other(dwArg04);
	intermediate_1_ternary_blocks(dwArg04);
	intermediate_2_other_in_blocks(dwArg04);
	intermediate_10_double_word_signed_math(dwArg04, dwArg04 >> 0x1F, dwArg04, dwArg04 >> 0x1F, dwArg04, dwArg04 >> 0x1F);
	intermediate_10_double_word_unsigned_math(dwArg04, dwArg04 >> 0x1F, dwArg04, dwArg04 >> 0x1F, dwArg04, dwArg04 >> 0x1F);
	advanced_1_unrolled_loop(dwArg04, dwArg04 >> 0x1F);
}

// 080483C8: void _start(Register (ptr32 Eq_73) edx, Stack int32 dwArg00)
void _start( * edx, int32 dwArg00)
{
	__align((char *) fp + 0x04);
	__libc_start_main(&globals->t8048340, dwArg00, (char *) fp + 0x04, &globals->t8048F10, &globals->t8048F70, edx, fp);
	__hlt();
}

// 080483F0: Register word32 __x86.get_pc_thunk.bx(Stack word32 dwArg00)
word32 __x86.get_pc_thunk.bx(word32 dwArg00)
{
	return dwArg00;
}

// 08048400: void deregister_tm_clones()
void deregister_tm_clones()
{
	if (true && 0x00 != 0x00)
	{
		word32 esp_33;
		word32 eax_34;
		byte SCZO_35;
		byte CZ_36;
		byte SZO_37;
		bool C_38;
		bool Z_39;
		word32 ebp_40;
		fn00000000();
	}
}

// 08048430: void register_tm_clones()
void register_tm_clones()
{
	if (0x00 != 0x00 && 0x00 != 0x00)
	{
		word32 esp_41;
		word32 eax_42;
		byte SCZO_43;
		word32 edx_44;
		bool Z_45;
		byte SZO_46;
		bool C_47;
		word32 ebp_48;
		fn00000000();
	}
}

// 08048470: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if (globals->b804B01C == 0x00)
	{
		deregister_tm_clones();
		globals->b804B01C = 0x01;
	}
}

// 08048490: void frame_dummy()
void frame_dummy()
{
	if (globals->dw804AF10 != 0x00 && 0x00 != 0x00)
	{
		word32 esp_37;
		word32 eax_38;
		word32 edx_39;
		byte SZO_40;
		bool C_41;
		bool Z_42;
		word32 ebp_43;
		byte SCZO_44;
		fn00000000();
		register_tm_clones();
	}
	else
		register_tm_clones();
}

// 080484C0: Register word32 basic_1_ternary_simple(Stack Eq_19 dwArg04)
word32 basic_1_ternary_simple(Eq_19 dwArg04)
{
	return (word32) (dwArg04 != 0x2A);
}

// 080484D0: Register word32 basic_2_ternary_other(Stack Eq_19 dwArg04)
word32 basic_2_ternary_other(Eq_19 dwArg04)
{
	word32 eax_6 = 100;
	if (dwArg04 != 0x2A)
		eax_6 = 0xC9;
	return eax_6;
}

// 080484F0: Register word32 intermediate_10_double_word_signed_math(Stack Eq_19 dwArg04, Stack Eq_19 dwArg08, Stack Eq_19 dwArg0C, Stack Eq_19 dwArg10, Stack Eq_19 dwArg14, Stack int32 dwArg18)
word32 intermediate_10_double_word_signed_math(Eq_19 dwArg04, Eq_19 dwArg08, Eq_19 dwArg0C, Eq_19 dwArg10, Eq_19 dwArg14, int32 dwArg18)
{
	word64 edx_eax_33 = SEQ(dwArg10, dwArg0C + dwArg04) + SEQ(dwArg08, dwArg04);
	Eq_19 eax_34 = (word32) edx_eax_33;
	int32 edx_35 = SLICE(edx_eax_33, word32, 32);
	if (edx_35 >= dwArg18)
	{
		if (edx_35 > dwArg18)
			puts("add");
		else if (eax_34 > dwArg14)
			puts("add");
	}
	ui64 edx_eax_53 = SEQ(dwArg08, dwArg04 - dwArg0C) - _;
	Eq_19 eax_54 = (word32) edx_eax_53;
	int32 edx_55 = SLICE(edx_eax_53, word32, 32);
	if (dwArg18 <= edx_55)
	{
		if (dwArg18 < edx_55)
			puts("sub");
		else if (dwArg14 < eax_54)
			puts("sub");
	}
	uint64 edx_eax_72 = dwArg04 * dwArg0C;
	Eq_19 eax_73 = (word32) edx_eax_72;
	int32 edx_75 = SLICE(edx_eax_72, word32, 32) + (dwArg0C *s dwArg08 + dwArg10 *s dwArg04);
	if (dwArg18 <= edx_75)
	{
		if (dwArg18 < edx_75)
			puts("mult");
		else if (dwArg14 < eax_73)
			puts("mult");
	}
	int32 edx_96;
	Eq_19 eax_97 = __divdi3(dwArg04, dwArg08, dwArg0C, dwArg10, out edx_96);
	if (dwArg18 <= edx_96 && (dwArg18 < edx_96 || dwArg14 < eax_97))
		puts("diff");
	word32 edx_117;
	if ((dwArg18 ^ edx_117 | dwArg14 ^ __moddi3(dwArg04, dwArg08, dwArg0C, dwArg10, out edx_117)) != 0x00)
		return 0x00;
	puts("modulo");
	return 0x00;
}

// 08048680: Register word32 intermediate_10_double_word_unsigned_math(Stack Eq_19 dwArg04, Stack Eq_19 dwArg08, Stack Eq_19 dwArg0C, Stack Eq_19 dwArg10, Stack Eq_19 dwArg14, Stack Eq_62 dwArg18)
word32 intermediate_10_double_word_unsigned_math(Eq_19 dwArg04, Eq_19 dwArg08, Eq_19 dwArg0C, Eq_19 dwArg10, Eq_19 dwArg14, Eq_62 dwArg18)
{
	word64 edx_eax_33 = SEQ(dwArg10, dwArg0C + dwArg04) + SEQ(dwArg08, dwArg04);
	Eq_19 eax_34 = (word32) edx_eax_33;
	Eq_62 edx_35 = SLICE(edx_eax_33, word32, 32);
	if (edx_35 >= dwArg18)
	{
		if (edx_35 > dwArg18)
			puts("add");
		else if (eax_34 > dwArg14)
			puts("add");
	}
	ui64 edx_eax_52 = SEQ(dwArg08, dwArg04 - dwArg0C) - _;
	Eq_19 eax_53 = (word32) edx_eax_52;
	Eq_62 edx_54 = SLICE(edx_eax_52, word32, 32);
	if (dwArg18 <= edx_54)
	{
		if (dwArg18 < edx_54)
			puts("sub");
		else if (dwArg14 < eax_53)
			puts("sub");
	}
	uint64 edx_eax_70 = dwArg04 * dwArg0C;
	Eq_19 eax_71 = (word32) edx_eax_70;
	Eq_62 edx_73 = SLICE(edx_eax_70, word32, 32) + (dwArg0C *s dwArg08 + dwArg10 *s dwArg04);
	if (dwArg18 <= edx_73)
	{
		if (dwArg18 < edx_73)
			puts("mult");
		else if (dwArg14 < eax_71)
			puts("mult");
	}
	Eq_62 edx_93;
	Eq_19 eax_94 = __udivdi3(dwArg04, dwArg08, dwArg0C, dwArg10, out edx_93);
	if (dwArg18 <= edx_93 && (dwArg18 < edx_93 || dwArg14 < eax_94))
		puts("diff");
	word32 edx_113;
	if ((dwArg18 ^ edx_113 | dwArg14 ^ __umoddi3(dwArg04, dwArg08, dwArg0C, dwArg10, out edx_113)) != 0x00)
		return 0x00;
	puts("modulo");
	return 0x00;
}

// 08048810: Register word32 advanced_1_unrolled_loop(Register Eq_19 esi, Register int32 edi)
word32 advanced_1_unrolled_loop(Eq_19 esi, int32 edi)
{
	puts("basic");
	int32 ebx_16 = 0x30;
	do
	{
		putchar(ebx_16);
		ebx_16 = ebx_16 + 0x01;
	} while (ebx_16 != 0x3A);
	puts("partial unrolled");
	int32 ebx_26 = 0x31;
	do
	{
		putchar(ebx_26);
		putchar(ebx_26 + 0x00);
		ebx_26 = ebx_26 + 0x02;
	} while (ebx_26 != 0x39);
	puts("fully unrolled");
	putchar(0x30);
	putchar(0x31);
	putchar(0x32);
	putchar(0x33);
	putchar(0x34);
	putchar(0x35);
	putchar(0x36);
	putchar(55);
	putchar(0x38);
	putchar(0x39);
	return 0x00;
}

// 08048904: Register word32 intermediate_1_ternary_blocks(Stack Eq_19 dwArg04)
word32 intermediate_1_ternary_blocks(Eq_19 dwArg04)
{
	word32 eax_12;
	if (dwArg04 == 0x2A)
		eax_12 = 0x00;
	else
		eax_12 = 0x01;
	return eax_12;
}

// 0804891B: Register word32 intermediate_2_other_in_blocks(Stack Eq_19 dwArg04)
word32 intermediate_2_other_in_blocks(Eq_19 dwArg04)
{
	word32 eax_12;
	if (dwArg04 == 0x2A)
		eax_12 = 100;
	else
		eax_12 = 0xC9;
	return eax_12;
}

// 08048940: Register uint32 __divdi3(Stack Eq_19 dwArg04, Stack Eq_19 dwArg08, Stack Eq_19 dwArg0C, Stack Eq_19 dwArg10, Register out ptr32 edxOut)
uint32 __divdi3(Eq_19 dwArg04, Eq_19 dwArg08, Eq_19 dwArg0C, Eq_19 dwArg10, ptr32 & edxOut)
{
	Eq_19 edx_16 = dwArg08;
	Eq_19 eax_22 = dwArg04;
	Eq_436 edx_eax_23 = SEQ(dwArg08, dwArg04);
	word32 dwLoc24_221 = 0x00;
	Eq_19 dwLoc28_225 = dwArg10;
	Eq_19 dwLoc2C_218 = dwArg0C;
	if (dwArg08 < 0x00)
	{
		eax_22 = -dwArg04;
		edx_16 = -((word32) dwArg08.u0 + (eax_22 == 0x00));
		dwLoc24_221 = ~0x00;
		edx_eax_23 = SEQ(edx_16, eax_22);
	}
	if (dwArg10 < 0x00)
	{
		dwLoc2C_218 = -*(fp - 44);
		dwLoc24_221 = ~*(fp - 0x24);
		dwLoc28_225 = -*(fp - 0x28);
	}
	uint32 ebp_116;
	uint32 ecx_101;
	Eq_19 ecx_106 = dwLoc2C_218;
	if (dwLoc28_225 == 0x00)
	{
		if (dwLoc2C_218 > edx_16)
		{
			ebp_116 = 0x00;
			ecx_101 = (uint32) (edx_eax_23 /u dwLoc2C_218);
		}
		else
		{
			if (dwLoc2C_218 == 0x00)
				ecx_106 = (uint32) (0x01 /u dwLoc2C_218);
			uint64 edx_eax_109 = (uint64) (uint32) edx_16;
			ebp_116 = (uint32) (edx_eax_109 /u ecx_106);
			ecx_101 = (uint32) (SEQ((uint32) (edx_eax_109 % ecx_106), eax_22) /u ecx_106);
		}
	}
	else
	{
		if (dwLoc28_225 > edx_16)
		{
			ebp_116 = 0x00;
			ecx_101 = 0x00;
			goto l080489A8;
		}
		word32 ebp_139 = __bsr(dwLoc28_225);
		ebp_116 = ebp_139 ^ 0x1F;
		if ((ebp_139 ^ 0x1F) == 0x00)
		{
			if (dwLoc28_225 >= edx_16)
			{
				ecx_101 = 0x00;
				if (dwLoc2C_218 > eax_22)
					goto l080489A8;
			}
			ecx_101 = 0x01;
			goto l080489A8;
		}
		word32 eax_158 = 0x20 - (ebp_139 ^ 0x1F);
		uint32 edx_165 = dwLoc2C_218 >> (byte) eax_158 | dwLoc28_225 << (byte) (ebp_139 ^ 0x1F);
		uint64 edx_eax_182 = SEQ(edx_16 >> (byte) eax_158, edx_16 << (byte) (ebp_139 ^ 0x1F) | eax_22 >> (byte) eax_158);
		uint32 eax_185 = (uint32) (edx_eax_182 /u edx_165);
		uint64 edx_eax_188 = (dwLoc2C_218 << (byte) (ebp_139 ^ 0x1F)) * eax_185;
		uint32 edx_184 = (uint32) (edx_eax_182 % edx_165);
		uint32 edx_189 = SLICE(edx_eax_188, word32, 32);
		uint32 eax_190 = (word32) edx_eax_188;
		if (edx_184 >= edx_189 && (eax_22 << (byte) (ebp_139 ^ 0x1F) >= eax_190 || edx_184 != edx_189))
		{
			ecx_101 = eax_185;
			ebp_116 = 0x00;
		}
		else
		{
			ecx_101 = eax_185 - 0x01;
			ebp_116 = 0x00;
		}
	}
l080489A8:
	uint32 eax_64 = ecx_101;
	word32 edx_66;
	*edxOut = ebp_116;
	if (dwLoc24_221 != 0x00)
	{
		eax_64 = -ecx_101;
		word32 edx_89;
		*edxOut = -((bool) (eax_64 == 0x00) + ebp_116);
	}
	return eax_64;
}

// 08048AB0: Register Eq_19 __moddi3(Stack Eq_19 dwArg04, Stack Eq_19 dwArg08, Stack Eq_19 dwArg0C, Stack Eq_19 dwArg10, Register out ptr32 edxOut)
Eq_19 __moddi3(Eq_19 dwArg04, Eq_19 dwArg08, Eq_19 dwArg0C, Eq_19 dwArg10, ptr32 & edxOut)
{
	Eq_19 edi_16 = dwArg08;
	Eq_19 esi_22 = dwArg04;
	word32 dwLoc30_25 = 0x00;
	Eq_19 dwLoc3C_29 = dwArg0C;
	Eq_19 dwLoc38_31 = dwArg10;
	if (dwArg08 < 0x00)
	{
		esi_22 = -dwArg04;
		dwLoc30_25 = ~0x00;
		edi_16 = -((word32) dwArg08.u0 + (esi_22 == 0x00));
	}
	if (dwArg10 < 0x00)
	{
		dwLoc3C_29 = -*(fp - 0x3C);
		dwLoc38_31 = -*(fp - 0x38);
	}
	Eq_19 eax_105;
	word32 edx_124;
	int64 edx_eax_53 = SEQ(edi_16, esi_22);
	Eq_19 dwLoc28_180 = esi_22;
	Eq_19 ecx_140 = dwLoc3C_29;
	ui64 ebx_ecx_64 = SEQ(dwLoc38_31, dwLoc3C_29);
	Eq_19 dwLoc3C_182 = edi_16;
	if (dwLoc38_31 == 0x00)
	{
		Eq_19 dwLoc3C_118;
		if (dwLoc3C_29 > edi_16)
			dwLoc3C_118 = (uint32) (edx_eax_53 % dwLoc3C_29);
		else
		{
			if (dwLoc3C_29 == 0x00)
				ecx_140 = (uint32) (0x01 /u dwLoc3C_29);
			dwLoc3C_118 = (uint32) (SEQ((uint32) ((uint64) (uint32) edi_16 % ecx_140), esi_22) % ecx_140);
		}
		eax_105 = dwLoc3C_118;
		*edxOut = 0x00;
	}
	else if (dwLoc38_31 > edi_16)
	{
		eax_105 = esi_22;
		*edxOut = edi_16;
	}
	else
	{
		word32 edi_172 = __bsr(dwLoc38_31);
		if ((edi_172 ^ 0x1F) == 0x00)
		{
			if (dwLoc38_31 < edi_16 || dwLoc3C_29 <= esi_22)
			{
				word64 edx_eax_194 = SEQ(edi_16, esi_22 - dwLoc3C_29) - ebx_ecx_64;
				dwLoc3C_182 = SLICE(edx_eax_194, word32, 32);
				dwLoc28_180 = (word32) edx_eax_194;
			}
			eax_105 = dwLoc28_180;
			*edxOut = dwLoc3C_182;
		}
		else
		{
			word32 edx_205 = 0x20 - (edi_172 ^ 0x1F);
			uint32 ecx_218 = dwLoc3C_29 >> (byte) edx_205 | dwLoc38_31 << (byte) (edi_172 ^ 0x1F);
			uint32 edx_222 = dwLoc3C_29 << (byte) (edi_172 ^ 0x1F);
			uint64 edx_eax_246 = SEQ(edi_16 >> (byte) edx_205, edi_16 << (byte) ((word32) bLoc20) | esi_22 >> (byte) edx_205);
			uint64 edx_eax_252 = edx_222 * (uint32) (edx_eax_246 /u ecx_218);
			uint32 eax_253 = (word32) edx_eax_252;
			uint32 edx_254 = SLICE(edx_eax_252, word32, 32);
			uint64 _edi_231 = SEQ(ecx_218, edx_222);
			uint32 eax_243 = esi_22 << (byte) ((word32) bLoc20);
			uint32 edx_248 = (uint32) (edx_eax_246 % ecx_218);
			uint32 esi_261 = eax_253;
			uint64 ecx_esi_263 = SEQ(edx_254, eax_253);
			if (edx_248 < edx_254 || edx_248 == edx_254 && eax_243 < eax_253)
			{
				uint64 edx_eax_301 = SEQ(edx_254, eax_253 - edx_222) - _edi_231;
				uint32 eax_302 = (word32) edx_eax_301;
				esi_261 = eax_302;
				ecx_esi_263 = SEQ(SLICE(edx_eax_301, word32, 32), eax_302);
			}
			uint64 ebx_eax_275 = SEQ(edx_248, eax_243 - esi_261) - ecx_esi_263;
			uint32 ebx_276 = SLICE(ebx_eax_275, word32, 32);
			eax_105 = ebx_276 << (byte) ((word32) bLoc28) | (word32) ebx_eax_275 >> (byte) (edi_172 ^ 0x1F);
			*edxOut = ebx_276 >> (byte) (edi_172 ^ 0x1F);
		}
	}
	if (dwLoc30_25 != 0x00)
	{
		eax_105 = -eax_105;
		word32 edx_109;
		*edxOut = -((bool) (eax_105 == 0x00) + edx_124);
	}
	return eax_105;
}

// 08048C90: Register uint32 __udivdi3(Stack Eq_19 dwArg04, Stack Eq_19 dwArg08, Stack Eq_19 dwArg0C, Stack Eq_19 dwArg10, Register out ptr32 edxOut)
uint32 __udivdi3(Eq_19 dwArg04, Eq_19 dwArg08, Eq_19 dwArg0C, Eq_19 dwArg10, ptr32 & edxOut)
{
	uint32 edi_121;
	uint32 ebx_202;
	if (dwArg10 != 0x00)
	{
		if (dwArg10 > dwArg08)
		{
			word32 edx_209;
			*edxOut = 0x00;
			return 0x00;
		}
		word32 edi_120 = __bsr(dwArg10);
		edi_121 = edi_120 ^ 0x1F;
		if ((edi_120 ^ 0x1F) != 0x00)
		{
			word32 ebx_129 = 0x20 - (edi_120 ^ 0x1F);
			uint32 esi_137 = dwArg10 << (byte) (edi_120 ^ 0x1F) | dwArg0C >> (byte) ebx_129;
			uint64 edx_eax_153 = SEQ(dwArg08 >> (byte) ebx_129, dwArg08 << (byte) (edi_120 ^ 0x1F) | dwArg04 >> (byte) ebx_129);
			uint32 eax_156 = (uint32) (edx_eax_153 /u esi_137);
			uint64 edx_eax_159 = (dwArg0C << (byte) (edi_120 ^ 0x1F)) * eax_156;
			uint32 edx_155 = (uint32) (edx_eax_153 % esi_137);
			uint32 ebx_158 = eax_156;
			uint32 edx_160 = SLICE(edx_eax_159, word32, 32);
			uint32 eax_161 = (word32) edx_eax_159;
			if (edx_155 < edx_160 || dwArg04 << (byte) (edi_120 ^ 0x1F) < eax_161 && edx_155 == edx_160)
				ebx_158 = eax_156 - 0x01;
			word32 edx_171;
			*edxOut = 0x00;
			return ebx_158;
		}
		if (dwArg10 >= dwArg08)
		{
			ebx_202 = 0x00;
			if (dwArg0C > dwArg04)
				goto l08048CDC;
		}
		ebx_202 = 0x01;
		goto l08048CDC;
	}
	else
	{
		if (dwArg0C > dwArg08)
		{
			word32 edx_106;
			*edxOut = 0x00;
			return (uint32) (SEQ(dwArg08, dwArg04) /u dwArg0C);
		}
		Eq_19 ebp_74 = dwArg0C;
		if (dwArg0C == 0x00)
			ebp_74 = (uint32) (0x01 /u dwArg0C);
		uint64 edx_eax_78 = (uint64) (uint32) dwArg08;
		edi_121 = (uint32) (edx_eax_78 /u ebp_74);
		ebx_202 = (uint32) (SEQ((uint32) (edx_eax_78 % ebp_74), dwArg04) /u ebp_74);
l08048CDC:
		word32 edx_56;
		*edxOut = edi_121;
		return ebx_202;
	}
}

// 08048DC0: Register Eq_19 __umoddi3(Stack Eq_19 dwArg04, Stack Eq_19 dwArg08, Stack Eq_19 dwArg0C, Stack Eq_19 dwArg10, Register out ptr32 edxOut)
Eq_19 __umoddi3(Eq_19 dwArg04, Eq_19 dwArg08, Eq_19 dwArg0C, Eq_19 dwArg10, ptr32 & edxOut)
{
	uint64 _edi_29 = SEQ(dwArg10, dwArg0C);
	Eq_19 dwLoc28_131 = dwArg04;
	word32 edx_33;
	*edxOut = dwArg08;
	if (dwArg10 != 0x00)
	{
		if (dwArg10 > dwArg08)
		{
			word32 edx_270;
			*edxOut = dwArg08;
			return dwArg04;
		}
		else
		{
			word32 ebp_123 = __bsr(dwArg10);
			if ((ebp_123 ^ 0x1F) != 0x00)
			{
				word32 edi_166 = 0x20 - (ebp_123 ^ 0x1F);
				uint32 edx_174 = dwArg0C >> (byte) edi_166 | dwArg10 << (byte) (ebp_123 ^ 0x1F);
				uint64 edx_eax_197 = SEQ(dwArg08 >> (byte) edi_166, dwArg04 >> (byte) edi_166 | dwArg08 << (byte) (ebp_123 ^ 0x1F));
				uint32 edx_178 = dwArg0C << (byte) (ebp_123 ^ 0x1F);
				uint64 edx_eax_204 = edx_178 * (uint32) (edx_eax_197 /u edx_174);
				uint32 eax_205 = (word32) edx_eax_204;
				uint32 edx_206 = SLICE(edx_eax_204, word32, 32);
				uint32 edx_199 = (uint32) (edx_eax_197 % edx_174);
				uint32 ebx_203 = dwArg04 << (byte) (ebp_123 ^ 0x1F);
				uint32 ebx_216 = eax_205;
				uint64 ecx_ebx_217 = SEQ(edx_206, eax_205);
				if (edx_199 < edx_206 || edx_199 == edx_206 && ebx_203 < eax_205)
				{
					uint64 edx_eax_258 = SEQ(edx_206, eax_205 - edx_178) - _;
					uint32 eax_259 = (word32) edx_eax_258;
					ebx_216 = eax_259;
					ecx_ebx_217 = SEQ(SLICE(edx_eax_258, word32, 32), eax_259);
				}
				uint64 esi_edx_225 = SEQ(edx_199, ebx_203 - ebx_216) - ecx_ebx_217;
				uint32 esi_226 = SLICE(esi_edx_225, word32, 32);
				word32 edx_239;
				*edxOut = esi_226 >> (byte) (ebp_123 ^ 0x1F);
				return esi_226 << (byte) edi_166 | (word32) esi_edx_225 >> (byte) (ebp_123 ^ 0x1F);
			}
			else
			{
				if (dwArg10 < dwArg08 || dwArg0C <= dwArg04)
				{
					uint64 edx_ecx_155 = SEQ(dwArg08, dwArg04 - dwArg0C) - _edi_29;
					word32 edx_157;
					*edxOut = SLICE(edx_ecx_155, word32, 32);
					dwLoc28_131 = (word32) edx_ecx_155;
				}
				return dwLoc28_131;
			}
		}
	}
	else
	{
		Eq_19 edx_103;
		if (dwArg0C > dwArg08)
			edx_103 = (uint32) (SEQ(dwArg08, dwArg04) % dwArg0C);
		else
		{
			Eq_19 ebp_118 = dwArg0C;
			if (dwArg0C == 0x00)
				ebp_118 = (uint32) (0x01 /u dwArg0C);
			edx_103 = (uint32) (SEQ((uint32) ((uint64) (uint32) dwArg08 % ebp_118), dwArg04) % ebp_118);
		}
		word32 edx_66;
		*edxOut = 0x00;
		return edx_103;
	}
}

// 08048F10: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_6 * ebx_15 = __x86.get_pc_thunk.bx(dwLoc14);
	_init();
	if ((char *) &ebx_15->ptr1FEF + 0x04 - &ebx_15->ptr1FEF >> 0x02 != 0x00)
	{
		do
		{
			word32 esp_66;
			word32 ebp_67;
			word32 edi_68;
			word32 esi_69;
			word32 ebx_70;
			byte SCZO_71;
			word32 eax_72;
			byte SZO_73;
			bool C_74;
			bool Z_75;
			ebx_15->ptr1FEF();
		} while (esi_69 != edi_68 + 0x01);
	}
}

// 08048F70: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 08048F74: void _fini()
void _fini()
{
	__x86.get_pc_thunk.bx(dwLoc10);
}

