//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int32_t advanced_10_irreducible(int32_t a1);
int32_t advanced_11_nested_loops_complex_condition(int32_t a1);
int32_t advanced_12_nested_if_in_loop(int32_t a1);
int32_t advanced_1_loop_with_multiple_entries(int32_t a1);
int32_t advanced_20_jump_table_on_stack(uint32_t result);
int32_t advanced_21_computed_jumps(uint32_t a1, int32_t a2);
int32_t advanced_2_loop_with_multiple_exits(int32_t a1);
int32_t basic_1_if(int32_t a1);
int32_t basic_2_if_else(int32_t a1);
int32_t basic_3_if_elseif(int32_t a1);
int32_t basic_4_if_elseif_else(int32_t a1);
int32_t basic_5_head_controlled_loop(int32_t a1);
int32_t basic_6_tail_controlled_loop(int32_t a1);
int32_t basic_7_for_loop(void);
int32_t basic_8_forever_loop(int32_t a1);
int32_t basic_9_dead_block(void);
int32_t intermediate_10_loop_with_one_break(int32_t a1);
int32_t intermediate_11_loop_with_two_breaks(int32_t a1);
int32_t intermediate_12_loop_with_break_and_block(int32_t a1);
int32_t intermediate_13_loop_with_one_continue(int32_t a1);
int32_t intermediate_14_loop_with_two_continues(int32_t a1);
int32_t intermediate_15_loop_with_continue_and_block(int32_t a1);
int32_t intermediate_16_loop_with_breaks_and_continues(int32_t a1);
int32_t intermediate_17_forever_loop_with_extra_statement(void);
int32_t intermediate_1_short_circuit_and(int32_t a1, int32_t a2);
int32_t intermediate_20_nested_loops(int32_t a1);
int32_t intermediate_2_short_circuit_or(int32_t a1, int32_t a2);
int32_t intermediate_30_switch_case(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x680cec83; // 0x8049098
int32_t g2 = 0x680cec83; // 0x80490b0
int32_t g3 = 0x680cec83; // 0x80490d0
int32_t g4;
int32_t g5;

// ------------------------ Functions -------------------------

// Address range: 0x80483a0 - 0x80484bb
int main(int argc, char ** argv) {
    uint32_t v1 = (int32_t)argv; // 0x80483b4
    basic_1_if(v1);
    int32_t v2 = v1 % 2 ^ 1; // 0x80483c6
    basic_2_if_else(v1);
    basic_3_if_elseif(v1);
    basic_4_if_elseif_else(v1);
    basic_5_head_controlled_loop(v1);
    basic_6_tail_controlled_loop(v1);
    basic_7_for_loop();
    basic_8_forever_loop(v1);
    basic_9_dead_block();
    int32_t v3 = v1 - 4; // 0x8048406
    int32_t v4 = v3 < 0 == (3 - v1 & v1) < 0 == (v3 != 0); // 0x804840a
    intermediate_1_short_circuit_and(v4, v2);
    intermediate_2_short_circuit_or(v4, v2);
    intermediate_10_loop_with_one_break(v1);
    intermediate_11_loop_with_two_breaks(v1);
    intermediate_12_loop_with_break_and_block(v1);
    intermediate_13_loop_with_one_continue(v1);
    intermediate_14_loop_with_two_continues(v1);
    intermediate_15_loop_with_continue_and_block(v1);
    intermediate_16_loop_with_breaks_and_continues(v1);
    intermediate_17_forever_loop_with_extra_statement();
    intermediate_20_nested_loops(v1);
    intermediate_30_switch_case(v1);
    advanced_1_loop_with_multiple_entries(v1);
    advanced_2_loop_with_multiple_exits(v1);
    advanced_10_irreducible(v1);
    advanced_11_nested_loops_complex_condition(v1);
    advanced_12_nested_if_in_loop(v1);
    advanced_20_jump_table_on_stack(v1);
    advanced_21_computed_jumps(v1, (int32_t)&g5);
    int32_t v5; // 0x80483a0
    return (int32_t)*(char *)*(int32_t *)v5;
}

// Address range: 0x80485b0 - 0x80485d6
int32_t basic_1_if(int32_t a1) {
    if (a1 != 42) {
        // 0x80485ba
        return 0;
    }
    // 0x80485c0
    puts("if block");
    return 0;
}

// Address range: 0x80485e0 - 0x8048616
int32_t basic_2_if_else(int32_t a1) {
    if (a1 == 42) {
        // 0x8048600
        puts("if block");
        return 0;
    }
    // 0x80485ea
    puts("else block");
    return 0;
}

// Address range: 0x8048620 - 0x8048672
int32_t basic_3_if_elseif(int32_t a1) {
    switch (a1) {
        case 42: {
            // 0x8048660
            puts("if block");
            // break -> 0x8048631
            break;
        }
        case 43: {
            // 0x8048640
            puts("else-if block");
            return 0;
        }
    }
    // 0x8048631
    return 0;
}

// Address range: 0x8048680 - 0x80486e2
int32_t basic_4_if_elseif_else(int32_t a1) {
    switch (a1) {
        case 42: {
            // 0x80486d0
            puts("if block");
            // break -> 0x80486a1
            break;
        }
        case 43: {
            // 0x80486b0
            puts("else-if block");
            return 0;
        }
        default: {
            // 0x8048691
            puts("else block");
            // break -> 0x80486a1
            break;
        }
    }
    // 0x80486a1
    return 0;
}

// Address range: 0x80486f0 - 0x804871b
int32_t basic_7_for_loop(void) {
    int32_t v1 = 48; // 0x80486f9
    int32_t v2; // bp-12, 0x80486f0
    *(int32_t *)((int32_t)&v2 - 16) = v1;
    v1++;
    putchar((int32_t)&g5);
    while (v1 != 58) {
        // 0x8048700
        *(int32_t *)((int32_t)&v2 - 16) = v1;
        v1++;
        putchar((int32_t)&g5);
    }
    // 0x8048714
    return 0;
}

// Address range: 0x8048720 - 0x804874c
int32_t intermediate_1_short_circuit_and(int32_t a1, int32_t a2) {
    // 0x8048720
    if (!((a1 == 0 | rand() != a2))) {
        // 0x8048736
        puts("both true");
    }
    // 0x8048746
    return 0;
}

// Address range: 0x8048750 - 0x8048786
int32_t intermediate_2_short_circuit_or(int32_t a1, int32_t a2) {
    // 0x8048750
    if (a1 != 0 | rand() == a2) {
        // 0x8048770
        puts("at least one is true");
        return 0;
    }
    // 0x8048766
    return 0;
}

// Address range: 0x8048790 - 0x80487d7
int32_t intermediate_10_loop_with_one_break(int32_t a1) {
    // 0x8048790
    int32_t v1; // bp-12, 0x8048790
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x80487b3
    *v2 = (int32_t)"head";
    puts((char *)&g5);
    *v2 = 0;
    if (time(&g5) == a1) {
        // 0x80487d0
        return 0;
    }
    *v2 = (int32_t)"tail";
    puts((char *)&g5);
    *v2 = (int32_t)"head";
    puts((char *)&g5);
    *v2 = 0;
    while (time(&g5) != a1) {
        // 0x80487a0
        *v2 = (int32_t)"tail";
        puts((char *)&g5);
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
    }
    // 0x80487d0
    return 0;
}

// Address range: 0x80487e0 - 0x804882c
int32_t intermediate_11_loop_with_two_breaks(int32_t a1) {
    if (a1 >= 0 != a1 != 0) {
        // 0x8048825
        return 0;
    }
    // 0x8048805
    int32_t v1; // bp-12, 0x80487e0
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x8048808
    int32_t v3 = a1; // 0x8048800
    *v2 = (int32_t)"head";
    puts((char *)&g5);
    *v2 = 0;
    while (time(&g5) != v3) {
        // 0x80487f0
        *v2 = (int32_t)"tail";
        puts((char *)&g5);
        v3--;
        if (v3 == 0) {
            // break -> 0x8048825
            break;
        }
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
    }
    // 0x8048825
    return 0;
}

// Address range: 0x8048830 - 0x80488a0
int32_t intermediate_12_loop_with_break_and_block(int32_t a1) {
    // 0x8048830
    int32_t v1; // bp-12, 0x8048830
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x804886c
    *v2 = (int32_t)"head";
    puts((char *)&g5);
    *v2 = 0;
    if (time(&g5) == a1) {
      lab_0x8048889:
        // 0x8048889
        *v2 = (int32_t)"will break";
        puts((char *)&g5);
        // 0x8048899
        return 0;
    }
    *v2 = (int32_t)"barrier";
    puts((char *)&g5);
    while (rand() != a1) {
        // 0x8048859
        *v2 = (int32_t)"tail";
        puts((char *)&g5);
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) == a1) {
            goto lab_0x8048889;
        }
        *v2 = (int32_t)"barrier";
        puts((char *)&g5);
    }
    // 0x8048899
    return 0;
}

// Address range: 0x80488a0 - 0x80488e9
int32_t intermediate_13_loop_with_one_continue(int32_t a1) {
    if (a1 < 124) {
        // 0x80488e2
        return 0;
    }
    // 0x80488b0
    int32_t v1; // bp-12, 0x80488a0
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x80488b3
    while (true) {
        // 0x80488b0
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) != a1) {
            // 0x80488d0
            *v2 = (int32_t)"tail";
            puts((char *)&g5);
        }
    }
}

// Address range: 0x80488f0 - 0x8048952
int32_t intermediate_14_loop_with_two_continues(int32_t a1) {
    if (a1 < 124) {
        // 0x804894b
        return 0;
    }
    // 0x8048900
    int32_t v1; // bp-12, 0x80488f0
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x8048903
    while (true) {
        // 0x8048900
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) != a1) {
            // 0x8048920
            *v2 = (int32_t)"barrier";
            puts((char *)&g5);
            if (rand() != a1) {
                // 0x8048939
                *v2 = (int32_t)"tail";
                puts((char *)&g5);
            }
        }
    }
}

// Address range: 0x8048960 - 0x80489d9
int32_t intermediate_15_loop_with_continue_and_block(int32_t a1) {
    if (a1 < 124) {
        // 0x80489d2
        return 0;
    }
    // 0x8048970
    int32_t v1; // bp-12, 0x8048960
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x8048973
    while (true) {
        // 0x8048970
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) == a1) {
            // 0x80489c0
            *v2 = (int32_t)"will continue";
            puts((char *)&g5);
        } else {
            // 0x8048990
            *v2 = (int32_t)"barrier";
            puts((char *)&g5);
            if (rand() != a1) {
                // 0x80489a9
                *v2 = (int32_t)"tail";
                puts((char *)&g5);
            }
        }
    }
}

// Address range: 0x80489e0 - 0x8048a9f
int32_t intermediate_16_loop_with_breaks_and_continues(int32_t a1) {
    // 0x80489e0
    int32_t v1; // bp-12, 0x80489e0
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16); // 0x80489f3
    while (true) {
        // 0x80489f0
        *v2 = (int32_t)"head";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) + 1 != a1) {
            // 0x8048a13
            *v2 = (int32_t)"after first continue";
            puts((char *)&g5);
            *v2 = 0;
            if (time(&g5) + 2 == a1) {
                // break -> 0x8048a98
                break;
            }
            // 0x8048a36
            *v2 = (int32_t)"after first break";
            puts((char *)&g5);
            *v2 = 0;
            if (time(&g5) + 3 != a1) {
                // 0x8048a59
                *v2 = (int32_t)"after second continue";
                puts((char *)&g5);
                *v2 = 0;
                if (time(&g5) + 4 == a1) {
                    // break -> 0x8048a98
                    break;
                }
                // 0x8048a7c
                *v2 = (int32_t)"after second break; tail";
                puts((char *)&g5);
            }
        }
    }
    // 0x8048a98
    return 0;
}

// Address range: 0x8048aa0 - 0x8048b0d
int32_t intermediate_20_nested_loops(int32_t a1) {
    // 0x8048aa0
    puts("before");
    int32_t v1; // bp-12, 0x8048aa0
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16);
    *v2 = (int32_t)"outer loop";
    puts((char *)&g5);
    *v2 = (int32_t)"inner loop";
    puts((char *)&g5);
    *v2 = 0;
    while (time(&g5) != a1) {
        // 0x8048ad0
        *v2 = (int32_t)"inner loop";
        puts((char *)&g5);
        *v2 = 0;
    }
    while (rand() != a1) {
        // 0x8048ab8
        *v2 = (int32_t)"outer loop";
        puts((char *)&g5);
        *v2 = (int32_t)"inner loop";
        puts((char *)&g5);
        *v2 = 0;
        while (time(&g5) != a1) {
            // 0x8048ad0
            *v2 = (int32_t)"inner loop";
            puts((char *)&g5);
            *v2 = 0;
        }
    }
    // 0x8048af9
    *v2 = (int32_t)"after";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x8048b10 - 0x8048c25
int32_t intermediate_30_switch_case(int32_t a1) {
    // 0x8048b10
    g4 = a1;
    switch (a1) {
        case 0: {
            // 0x8048b80
            puts("0");
            // break -> 0x8048b50
            break;
        }
        case 1: {
            // 0x8048b98
            puts("1");
            // break -> 0x8048b50
            break;
        }
        case 2: {
        }
        case 3: {
            // 0x8048bb0
            puts("2 or 3");
            // break -> 0x8048b50
            break;
        }
        case 4: {
            // 0x8048bc8
            puts("4");
            // break -> 0x8048b50
            break;
        }
        case 5: {
            // 0x8048be0
            puts("5");
            // break -> 0x8048b50
            break;
        }
        case 6: {
            // 0x8048bf8
            puts("6");
            // break -> 0x8048b50
            break;
        }
        case 7: {
            // 0x8048b30
            puts("7 with fall through");
        }
        case 8: {
            // 0x8048b40
            puts("8");
            // break -> 0x8048b50
            break;
        }
        case 9: {
            // 0x8048b68
            puts("9");
            // break -> 0x8048b50
            break;
        }
        default: {
            // 0x8048c10
            puts("some other value");
            // break -> 0x8048b50
            break;
        }
    }
    // 0x8048b50
    int32_t v1; // bp-12, 0x8048b10
    *(int32_t *)((int32_t)&v1 - 16) = (int32_t)"common exit";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x8048c30 - 0x8048c77
int32_t advanced_1_loop_with_multiple_entries(int32_t a1) {
    // 0x8048c30
    int32_t v1; // bp-12, 0x8048c30
    int32_t v2 = &v1; // 0x8048c31
    int32_t v3; // 0x8048c30
    int32_t * v4; // 0x8048c30
    int32_t v5; // 0x8048c30
    int32_t v6; // 0x8048c30
    int32_t v7; // 0x8048c30
    if (a1 == 42) {
        // 0x8048c30
        v5 = v2 - 16;
        v7 = 41;
        goto lab_0x8048c54;
    } else {
        if (a1 < 1) {
            // 0x8048c68
            return 0;
        }
        int32_t v8 = v2 - 16;
        v4 = (int32_t *)v8;
        v3 = v8;
        v6 = a1;
        goto lab_0x8048c41;
    }
  lab_0x8048c54:;
    int32_t v9 = v7;
    int32_t * v10 = (int32_t *)v5;
    *v10 = (int32_t)"body 2";
    puts((char *)&g5);
    v4 = v10;
    v3 = v5;
    v6 = v9;
    if (v9 >= 0 != v9 != 0) {
        // 0x8048c68
        return 0;
    }
    goto lab_0x8048c41;
  lab_0x8048c41:
    // 0x8048c41
    *v4 = (int32_t)"body 1";
    puts((char *)&g5);
    v5 = v3;
    v7 = v6 - 1;
    goto lab_0x8048c54;
}

// Address range: 0x8048c80 - 0x8048d27
int32_t advanced_2_loop_with_multiple_exits(int32_t a1) {
    // 0x8048c80
    int32_t v1; // bp-12, 0x8048c80
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16);
    int32_t v3 = a1; // 0x8048c8a
    if (a1 >= 0 != a1 != 0) {
        // 0x8048cf0
        *v2 = (int32_t)"normal exit";
        puts((char *)&g5);
        return 0;
    }
    *v2 = (int32_t)"body 1";
    puts((char *)&g5);
    *v2 = 0;
    while (time(&g5) != 1) {
        // 0x8048c90
        *v2 = (int32_t)"body 2";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) == 2) {
            // 0x8048d10
            *v2 = (int32_t)"took exit 2";
            puts((char *)&g5);
            return 0;
        }
        // 0x8048cb1
        v3--;
        if (v3 == 0) {
            // 0x8048cf0
            *v2 = (int32_t)"normal exit";
            puts((char *)&g5);
            return 0;
        }
        *v2 = (int32_t)"body 1";
        puts((char *)&g5);
        *v2 = 0;
    }
    // 0x8048cd7
    *v2 = (int32_t)"took exit 1";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x8048d30 - 0x8048db2
int32_t advanced_10_irreducible(int32_t a1) {
    // 0x8048d30
    puts("b1");
    if (time(NULL) == a1) {
        // 0x8048d78
        puts("b3");
        // 0x8048d88
        puts("b5");
        return 0;
    }
    // 0x8048d55
    puts("b2");
    if (time(NULL) != a1 + 1) {
        // 0x8048d78
        puts("b3");
        // 0x8048d88
        puts("b5");
        return 0;
    }
    // 0x8048da0
    puts("b4");
    // 0x8048d88
    puts("b5");
    return 0;
}

// Address range: 0x8048dc0 - 0x8048e79
int32_t advanced_11_nested_loops_complex_condition(int32_t a1) {
    // 0x8048dc0
    puts("b0");
    int32_t time_val = time(NULL); // 0x8048dd7
    int32_t v1; // bp-12, 0x8048dc0
    int32_t v2 = &v1; // 0x8048ddc
    int32_t * v3; // 0x8048dc0
    if (time_val != a1) {
        // 0x8048dc0
        v3 = (int32_t *)(v2 - 16);
      lab_0x8048de5:
        // 0x8048de5
        *v3 = (int32_t)"b9";
        puts((char *)&g5);
        return 0;
    }
    int32_t * v4 = (int32_t *)(v2 - 16);
    *v4 = (int32_t)"b2";
    puts((char *)&g5);
    *v4 = (int32_t)"b3";
    puts((char *)&g5);
    *v4 = 0;
    int32_t time_val2; // 0x8048e25
    while (time(&g5) != a1 + 2) {
        // 0x8048e20
        *v4 = 0;
        time_val2 = time(&g5);
        v3 = v4;
        if (time_val2 != a1 + 3) {
            // break (via goto) -> 0x8048de5
            goto lab_0x8048de5;
        }
        *v4 = (int32_t)"b3";
        puts((char *)&g5);
        *v4 = 0;
    }
    // 0x8048e51
    *v4 = (int32_t)"b1";
    puts((char *)&g5);
    *v4 = 0;
    while (time(&g5) == a1 + 1) {
        // 0x8048e08
        *v4 = (int32_t)"b2";
        puts((char *)&g5);
        *v4 = (int32_t)"b3";
        puts((char *)&g5);
        *v4 = 0;
        while (time(&g5) != a1 + 2) {
            // 0x8048e20
            *v4 = 0;
            time_val2 = time(&g5);
            v3 = v4;
            if (time_val2 != a1 + 3) {
                // break (via goto) -> 0x8048de5
                goto lab_0x8048de5;
            }
            *v4 = (int32_t)"b3";
            puts((char *)&g5);
            *v4 = 0;
        }
        // 0x8048e51
        *v4 = (int32_t)"b1";
        puts((char *)&g5);
        *v4 = 0;
    }
    // 0x8048de5
    *v4 = (int32_t)"b9";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x8048e80 - 0x8048f22
int32_t advanced_12_nested_if_in_loop(int32_t a1) {
    // 0x8048e80
    puts("b0");
    int32_t v1; // bp-12, 0x8048e80
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16);
    while (true) {
        // 0x8048ea0
        *v2 = (int32_t)"b1";
        puts((char *)&g5);
        *v2 = 0;
        if (time(&g5) == a1) {
            // 0x8048f00
            *v2 = (int32_t)"b2";
            puts((char *)&g5);
            *v2 = 0;
            if (time(&g5) != a1 + 1) {
                // break -> 0x8048ee0
                break;
            }
        } else {
            // 0x8048ec0
            *v2 = (int32_t)"b3";
            puts((char *)&g5);
            *v2 = 0;
            if (time(&g5) != a1 + 2) {
                // break -> 0x8048ee0
                break;
            }
        }
    }
    // 0x8048ee0
    *v2 = (int32_t)"b4";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x8048f30 - 0x8048f86
int32_t advanced_20_jump_table_on_stack(uint32_t result) {
    if (result < 6) {
        // 0x8048f6c
        return result;
    }
    // 0x8048f70
    puts("is something else");
    return 0;
}

// Address range: 0x8049050 - 0x8049107
int32_t advanced_21_computed_jumps(uint32_t a1, int32_t a2) {
    // 0x8049050
    puts("start");
    if (a1 >= 3) {
        // 0x80490f0
        puts("is something else");
        return 0;
    }
    if (a1 == 0) {
        // 0x8049098
        puts("is 0");
        return 0;
    }
    int32_t result = a1 != 2 ? (int32_t)&g2 - (int32_t)&g1 + (int32_t)&g1 : (int32_t)&g2 - (int32_t)&g1 + (int32_t)&g3 - (int32_t)&g2 + (int32_t)&g1; // 0x804908b
    return result;
}

// Address range: 0x8049110 - 0x8049153
int32_t basic_5_head_controlled_loop(int32_t a1) {
    // 0x8049110
    puts("before");
    int32_t v1; // bp-12, 0x8049110
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16);
    int32_t v3 = a1; // 0x8049128
    if (a1 == 42) {
        // 0x804913f
        *v2 = (int32_t)"after";
        puts((char *)&g5);
        return 0;
    }
    v3++;
    *v2 = (int32_t)"body";
    puts((char *)&g5);
    while (v3 != 42) {
        // 0x804912a
        v3++;
        *v2 = (int32_t)"body";
        puts((char *)&g5);
    }
    // 0x804913f
    *v2 = (int32_t)"after";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x8049160 - 0x80491a1
int32_t basic_6_tail_controlled_loop(int32_t a1) {
    // 0x8049160
    puts("before");
    int32_t v1; // bp-12, 0x8049160
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 16);
    int32_t v3 = a1; // 0x8049172
    *v2 = (int32_t)"body";
    puts((char *)&g5);
    while (v3 != 41) {
        // 0x8049175
        v3++;
        *v2 = (int32_t)"body";
        puts((char *)&g5);
    }
    // 0x804918d
    *v2 = (int32_t)"after";
    puts((char *)&g5);
    return 0;
}

// Address range: 0x80491b0 - 0x80491d2
int32_t basic_8_forever_loop(int32_t a1) {
    if (a1 != 42) {
        // 0x80491ba
        return 0;
    }
    // 0x80491c0
    while (true) {
        // 0x80491c0
        int32_t v1; // bp-12, 0x80491b0
        *(int32_t *)((int32_t)&v1 - 16) = (int32_t)"loop body";
        puts((char *)&g5);
    }
}

// Address range: 0x80491d2 - 0x8049211
int32_t basic_9_dead_block(void) {
    // 0x80491d2
    puts("entry");
    puts("exit");
    return 0;
}

// Address range: 0x8049211 - 0x8049216
int32_t intermediate_17_forever_loop_with_extra_statement(void) {
    while (true) {
        // continue -> 0x8049214
    }
}

// --------------- Dynamically Linked Functions ---------------

// int putchar(int c);
// int puts(const char * s);
// int rand(void);
// time_t time(time_t * timer);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.4.1)
// Detected functions: 29

