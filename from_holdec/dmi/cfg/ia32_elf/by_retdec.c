//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int32_t advanced_10_irreducible(int32_t a1);
int32_t advanced_11_nested_loops_complex_condition(int32_t a1);
int32_t advanced_12_nested_if_in_loop(int32_t a1);
int32_t advanced_1_loop_with_multiple_entries(int32_t a1);
int32_t advanced_20_jump_table_on_stack(uint32_t result);
int32_t advanced_21_computed_jumps(uint32_t a1);
int32_t advanced_2_loop_with_multiple_exits(int32_t a1);
int32_t basic_1_if(int32_t a1);
int32_t basic_2_if_else(int32_t a1);
int32_t basic_3_if_elseif(int32_t a1);
int32_t basic_4_if_elseif_else(int32_t a1);
int32_t basic_5_head_controlled_loop(int32_t a1);
int32_t basic_6_tail_controlled_loop(int32_t a1);
int32_t basic_7_for_loop(void);
int32_t basic_8_forever_loop(int32_t a1);
int32_t basic_9_dead_block(void);
int32_t intermediate_10_loop_with_one_break(int32_t a1);
int32_t intermediate_11_loop_with_two_breaks(int32_t a1);
int32_t intermediate_12_loop_with_break_and_block(int32_t a1);
int32_t intermediate_13_loop_with_one_continue(uint32_t a1);
int32_t intermediate_14_loop_with_two_continues(uint32_t a1);
int32_t intermediate_15_loop_with_continue_and_block(uint32_t a1);
int32_t intermediate_16_loop_with_breaks_and_continues(int32_t a1);
int32_t intermediate_17_forever_loop_with_extra_statement(void);
int32_t intermediate_1_short_circuit_and(int32_t a1, int32_t a2);
int32_t intermediate_20_nested_loops(int32_t a1);
int32_t intermediate_2_short_circuit_or(int32_t a1, int32_t a2);
int32_t intermediate_30_switch_case(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // ebx
int32_t g2 = 0; // esp
int32_t g3 = 0x680cec83;
int32_t g4 = 0x680cec83;
int32_t g5 = 0x680cec83;

// ------------------------ Functions -------------------------

// Address range: 0x80483a0 - 0x80484bb
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // 0x80483b4
    basic_1_if(v1);
    int32_t v2 = (-1 - v1) % 2; // esi
    basic_2_if_else(v1);
    basic_3_if_elseif(v1);
    basic_4_if_elseif_else(v1);
    basic_5_head_controlled_loop(v1);
    basic_6_tail_controlled_loop(g1);
    basic_7_for_loop();
    basic_8_forever_loop(g1);
    basic_9_dead_block();
    int32_t v3 = g1; // 0x8048406
    int32_t v4 = v3 - 4; // 0x8048406
    int32_t v5 = v4 < 0 == (3 - v3 & v3) < 0 == (v4 != 0); // 0x804840a
    intermediate_1_short_circuit_and(v5, v2);
    intermediate_2_short_circuit_or(v5, v2);
    intermediate_10_loop_with_one_break(g1);
    intermediate_11_loop_with_two_breaks(g1);
    intermediate_12_loop_with_break_and_block(g1);
    intermediate_13_loop_with_one_continue(g1);
    intermediate_14_loop_with_two_continues(g1);
    intermediate_15_loop_with_continue_and_block(g1);
    intermediate_16_loop_with_breaks_and_continues(g1);
    intermediate_17_forever_loop_with_extra_statement();
    intermediate_20_nested_loops(g1);
    intermediate_30_switch_case(g1);
    advanced_1_loop_with_multiple_entries(g1);
    advanced_2_loop_with_multiple_exits(g1);
    advanced_10_irreducible(g1);
    advanced_11_nested_loops_complex_condition(g1);
    advanced_12_nested_if_in_loop(g1);
    advanced_20_jump_table_on_stack(g1);
    advanced_21_computed_jumps(g1);
    int32_t v6;
    return (int32_t)*(char *)*(int32_t *)v6;
}

// Address range: 0x80485b0 - 0x80485d6
int32_t basic_1_if(int32_t a1) {
    // 0x80485b0
    if (a1 == 42) {
        // 0x80485c0
        puts("if block");
    }
    // 0x80485ba
    return 0;
}

// Address range: 0x80485e0 - 0x8048616
int32_t basic_2_if_else(int32_t a1) {
    // 0x80485e0
    if (a1 == 42) {
        // 0x8048600
        puts("if block");
        return 0;
    }
    // 0x80485ea
    puts("else block");
    return 0;
}

// Address range: 0x8048620 - 0x8048672
int32_t basic_3_if_elseif(int32_t a1) {
    // 0x8048620
    switch (a1) {
        case 42: {
            // 0x8048660
            puts("if block");
            // branch -> 0x8048631
        }
        default: {
            // 0x8048631
            return 0;
        }
        case 43: {
            // 0x8048640
            puts("else-if block");
            return 0;
        }
    }
}

// Address range: 0x8048680 - 0x80486e2
int32_t basic_4_if_elseif_else(int32_t a1) {
    // 0x8048680
    if (a1 == 42) {
        // 0x80486d0
        puts("if block");
        // branch -> 0x80486a1
    } else {
        // 0x804868c
        if (a1 == 43) {
            // 0x80486b0
            puts("else-if block");
            return 0;
        }
        // 0x8048691
        puts("else block");
        // branch -> 0x80486a1
    }
    // 0x80486a1
    return 0;
}

// Address range: 0x80486f0 - 0x804871b
int32_t basic_7_for_loop(void) {
    // 0x80486f0
    int32_t v1; // bp-12
    *(int32_t *)((int32_t)&v1 - 16) = 48;
    int32_t v2 = 49; // 0x8048704
    putchar(g1);
    // branch -> 0x8048700
    while (v2 != 58) {
        // 0x8048700
        *(int32_t *)g2 = v2;
        v2++;
        putchar(g1);
        // continue -> 0x8048700
    }
    // 0x8048714
    g1 = *(int32_t *)(g2 + 24);
    return 0;
}

// Address range: 0x8048720 - 0x804874c
int32_t intermediate_1_short_circuit_and(int32_t a1, int32_t a2) {
    // 0x8048720
    if (!((a1 == 0 | rand() != a2))) {
        // 0x8048736
        puts("both true");
        // branch -> 0x8048746
    }
    // 0x8048746
    return 0;
}

// Address range: 0x8048750 - 0x8048786
int32_t intermediate_2_short_circuit_or(int32_t a1, int32_t a2) {
    // 0x8048750
    if (a1 != 0 | rand() == a2) {
        // 0x8048770
        puts("at least one is true");
    }
    // 0x8048766
    return 0;
}

// Address range: 0x8048790 - 0x80487d7
int32_t intermediate_10_loop_with_one_break(int32_t a1) {
    char * str = (char *)g1; // bp-4
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x80487b0
    // branch -> 0x80487b0
    while (true) {
        // 0x80487b0
        *(int32_t *)(v2 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        if (time((int32_t *)str) == a1) {
            // 0x80487d0
            g1 = *(int32_t *)(g2 + 24);
            return 0;
        }
        // 0x80487a0
        *(int32_t *)g2 = (int32_t)"tail";
        puts(str);
        v2 = g2 + 16;
        // branch -> 0x80487b0
    }
}

// Address range: 0x80487e0 - 0x804882c
int32_t intermediate_11_loop_with_two_breaks(int32_t a1) {
    char * str = (char *)g1; // 0x80487e0
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x80487e1
    int32_t v3 = a1; // ebx
    if (a1 >= 0 != a1 != 0) {
        // 0x8048825
        g1 = *(int32_t *)(v2 + 8);
        return 0;
    }
    int32_t v4 = v2; // 0x8048805
    // branch -> 0x8048805
    int32_t v5; // 0x8048825
    while (true) {
        // 0x8048805
        *(int32_t *)(v4 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        if (time((int32_t *)g1) != v3) {
            // 0x80487f0
            *(int32_t *)g2 = (int32_t)"tail";
            puts(str);
            int32_t v6 = g2 + 16; // 0x80487fd
            int32_t v7 = v3 - 1; // 0x8048800
            v3 = v7;
            if (v7 == 0) {
                v5 = v6;
                // break -> 0x8048825
                break;
            }
            v4 = v6;
            // continue -> 0x8048805
            continue;
        } else {
            v5 = g2 + 16;
        }
    }
    // 0x8048825
    g1 = *(int32_t *)(v5 + 8);
    return 0;
}

// Address range: 0x8048830 - 0x80488a0
int32_t intermediate_12_loop_with_break_and_block(int32_t a1) {
    char * str = (char *)g1; // bp-4
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8048869
    // branch -> 0x8048869
    while (true) {
        // 0x8048869
        *(int32_t *)(v2 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        int32_t * v3 = (int32_t *)g2; // 0x8048843
        if (time((int32_t *)str) == a1) {
            // 0x8048889
            *v3 = (int32_t)"will break";
            puts(str);
            // branch -> 0x8048899
            // 0x8048899
            g1 = *(int32_t *)(g2 + 24);
            return 0;
        }
        // 0x8048840
        *v3 = (int32_t)"barrier";
        puts(str);
        if (a1 != rand()) {
            // 0x8048859
            *(int32_t *)g2 = (int32_t)"tail";
            puts(str);
            v2 = g2 + 16;
            // branch -> 0x8048869
            continue;
        }
        // 0x8048899
        g1 = *(int32_t *)(g2 + 24);
        return 0;
    }
}

// Address range: 0x80488a0 - 0x80488e9
int32_t intermediate_13_loop_with_one_continue(uint32_t a1) {
    int32_t t = g1; // 0x80488a0
    char * str = (char *)t; // 0x80488a0
    if (a1 <= 123) {
        // 0x80488e2
        g1 = t;
        return 0;
    }
    // 0x80488b0
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x80488b0
    // branch -> 0x80488b0
    while (true) {
      lab_0x80488b0:
        // 0x80488b0
        *(int32_t *)(v2 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        if (a1 != time((int32_t *)t)) {
            // break -> 0x80488d0
            break;
        }
        v2 = g2 + 16;
        // continue -> 0x80488b0
    }
    // 0x80488d0
    *(int32_t *)g2 = (int32_t)"tail";
    puts(str);
    v2 = g2 + 16;
    // branch -> 0x80488b0
    goto lab_0x80488b0;
}

// Address range: 0x80488f0 - 0x8048952
int32_t intermediate_14_loop_with_two_continues(uint32_t a1) {
    int32_t t = g1; // 0x80488f0
    char * str = (char *)t; // 0x80488f0
    if (a1 <= 123) {
        // 0x804894b
        g1 = t;
        return 0;
    }
    // 0x8048900
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8048900
    // branch -> 0x8048900
  lab_0x8048900_2:
    while (true) {
        // 0x8048900
        *(int32_t *)(v2 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        if (a1 != time((int32_t *)t)) {
            // break -> 0x8048920
            break;
        }
        v2 = g2 + 16;
        // continue -> 0x8048900
    }
    // 0x8048920
    *(int32_t *)g2 = (int32_t)"barrier";
    puts(str);
    if (a1 != rand()) {
        // break (via goto) -> 0x8048939
        goto lab_0x8048939;
    }
    v2 = g2 + 16;
    // continue (via goto) -> 0x8048900
    goto lab_0x8048900_2;
  lab_0x8048939:
    // 0x8048939
    *(int32_t *)g2 = (int32_t)"tail";
    puts(str);
    v2 = g2 + 16;
    // branch -> 0x8048900
    goto lab_0x8048900_2;
}

// Address range: 0x8048960 - 0x80489d9
int32_t intermediate_15_loop_with_continue_and_block(uint32_t a1) {
    int32_t t = g1; // 0x8048960
    char * str = (char *)t; // 0x8048960
    if (a1 <= 123) {
        // 0x80489d2
        g1 = t;
        return 0;
    }
    // 0x8048970
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8048970
    // branch -> 0x8048970
    while (true) {
      lab_0x8048970:
        // 0x8048970
        *(int32_t *)(v2 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        int32_t * v3 = (int32_t *)g2; // 0x80489c3
        if (a1 == time((int32_t *)t)) {
            // 0x80489c0
            *v3 = (int32_t)"will continue";
            puts(str);
            v2 = g2 + 16;
            // branch -> 0x8048970
            continue;
        } else {
            // 0x8048990
            *v3 = (int32_t)"barrier";
            puts(str);
            if (a1 != rand()) {
                // break -> 0x80489a9
                break;
            }
            v2 = g2 + 16;
            // continue -> 0x8048970
            continue;
        }
    }
    // 0x80489a9
    *(int32_t *)g2 = (int32_t)"tail";
    puts(str);
    v2 = g2 + 16;
    // branch -> 0x8048970
    goto lab_0x8048970;
}

// Address range: 0x80489e0 - 0x8048a9f
int32_t intermediate_16_loop_with_breaks_and_continues(int32_t a1) {
    char * str = (char *)g1; // bp-4
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x80489f0
    // branch -> 0x80489f0
  lab_0x80489f0_2:
    while (true) {
        // 0x80489f0
        *(int32_t *)(v2 - 16) = (int32_t)"head";
        puts(str);
        *(int32_t *)g2 = 0;
        if (time((int32_t *)str) + 1 != a1) {
            // break -> 0x8048a13
            break;
        }
        v2 = g2 + 16;
        // continue -> 0x80489f0
    }
    // 0x8048a13
    *(int32_t *)g2 = (int32_t)"after first continue";
    puts(str);
    *(int32_t *)g2 = 0;
    if (a1 == time((int32_t *)str) + 2) {
        // 0x8048a98
        return 0;
    }
    // 0x8048a36
    *(int32_t *)g2 = (int32_t)"after first break";
    puts(str);
    *(int32_t *)g2 = 0;
    if (a1 != time((int32_t *)str) + 3) {
        // break (via goto) -> 0x8048a59
        goto lab_0x8048a59;
    }
    v2 = g2 + 16;
    // continue (via goto) -> 0x80489f0
    goto lab_0x80489f0_2;
  lab_0x8048a59:
    // 0x8048a59
    *(int32_t *)g2 = (int32_t)"after second continue";
    puts(str);
    *(int32_t *)g2 = 0;
    if (a1 == time((int32_t *)str) + 4) {
        // 0x8048a98
        return 0;
    }
    // 0x8048a7c
    *(int32_t *)g2 = (int32_t)"after second break; tail";
    puts(str);
    v2 = g2 + 16;
    // branch -> 0x80489f0
    goto lab_0x80489f0_2;
}

// Address range: 0x8048aa0 - 0x8048b0d
int32_t intermediate_20_nested_loops(int32_t a1) {
    char * str = "before"; // bp-28
    puts("before");
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8048ab8
    // branch -> 0x8048ab8
    while (true) {
        // 0x8048ab8
        *(int32_t *)(v2 - 16) = (int32_t)"outer loop";
        puts(str);
        *(int32_t *)g2 = (int32_t)"inner loop";
        puts(str);
        *(int32_t *)g2 = 0;
        // branch -> 0x8048ad0
        while (time((int32_t *)str) != a1) {
            // 0x8048ad0
            *(int32_t *)g2 = (int32_t)"inner loop";
            puts(str);
            *(int32_t *)g2 = 0;
            // continue -> 0x8048ad0
        }
        // 0x8048af0
        if (a1 == rand()) {
            // break -> 0x8048af9
            break;
        }
        v2 = g2;
        // continue -> 0x8048ab8
    }
    // 0x8048af9
    *(int32_t *)(g2 - 16) = (int32_t)"after";
    puts(str);
    g1 = *(int32_t *)(g2 + 24);
    return 0;
}

// Address range: 0x8048b10 - 0x8048c25
int32_t intermediate_30_switch_case(int32_t a1) {
    // 0x8048b10
    char * str; // bp-28
    switch (a1) {
        default: {
            // 0x8048c10
            str = "some other value";
            puts("some other value");
            // branch -> 0x8048b50
            break;
        }
        case 0: {
            // 0x8048b80
            str = "0";
            puts("0");
            // branch -> 0x8048b50
            break;
        }
        case 1: {
            // 0x8048b98
            str = "1";
            puts("1");
            // branch -> 0x8048b50
            break;
        }
        case 2: {
            // 0x8048bb0
            str = "2 or 3";
            puts("2 or 3");
            // branch -> 0x8048b50
            break;
        }
        case 3: {
            // 0x8048bb0
            str = "2 or 3";
            puts("2 or 3");
            // branch -> 0x8048b50
            break;
        }
        case 4: {
            // 0x8048bc8
            str = "4";
            puts("4");
            // branch -> 0x8048b50
            break;
        }
        case 5: {
            // 0x8048be0
            str = "5";
            puts("5");
            // branch -> 0x8048b50
            break;
        }
        case 6: {
            // 0x8048bf8
            str = "6";
            puts("6");
            // branch -> 0x8048b50
            break;
        }
        case 7: {
            // 0x8048b30
            puts("7 with fall through");
            // branch -> 0x8048b40
            // 0x8048b40
            str = "8";
            puts("8");
            // branch -> 0x8048b50
            break;
        }
        case 8: {
            // 0x8048b10
            // branch -> 0x8048b40
            // 0x8048b40
            str = "8";
            puts("8");
            // branch -> 0x8048b50
            break;
        }
        case 9: {
            // 0x8048b68
            str = "9";
            puts("9");
            // branch -> 0x8048b50
            break;
        }
    }
    // 0x8048b50
    int32_t v1; // bp-12
    *(int32_t *)((int32_t)&v1 - 16) = (int32_t)"common exit";
    puts(str);
    return 0;
}

// Address range: 0x8048c30 - 0x8048c77
int32_t advanced_1_loop_with_multiple_entries(int32_t a1) {
    char * str = (char *)g1; // 0x8048c30
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8048c31
    int32_t v3; // ebx
    int32_t v4; // 0x8048c54
    if (a1 == 42) {
        // 0x8048c70
        v3 = 41;
        v4 = v2;
        // branch -> 0x8048c54
      lab_0x8048c54_2:
        // 0x8048c54
        *(int32_t *)(v4 - 16) = (int32_t)"body 2";
        puts(str);
        int32_t v5 = g2 + 16; // 0x8048c61
        int32_t v6 = v3; // 0x8048c64
        if (v6 >= 0 != v6 != 0) {
            // 0x8048c68
            g1 = *(int32_t *)(v5 + 8);
            return 0;
        }
        // 0x8048c41
        v3 = v6 - 1;
        *(int32_t *)(v5 - 16) = (int32_t)"body 1";
        puts(str);
        v4 = g2 + 16;
        // branch -> 0x8048c54
        goto lab_0x8048c54_2;
    } else {
        // 0x8048c3d
        if (a1 < 1) {
            // 0x8048c68
            g1 = *(int32_t *)(v2 + 8);
            return 0;
        }
    }
    // 0x8048c41
    v3 = a1 - 1;
    *(int32_t *)(v2 - 16) = (int32_t)"body 1";
    puts(str);
    v4 = g2 + 16;
    // branch -> 0x8048c54
    goto lab_0x8048c54_2;
}

// Address range: 0x8048c80 - 0x8048d27
int32_t advanced_2_loop_with_multiple_exits(int32_t a1) {
    char * str = (char *)g1; // 0x8048c80
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8048c81
    int32_t v3 = a1; // ebx
    if (a1 >= 0 != a1 != 0) {
        // 0x8048cf0
        *(int32_t *)(v2 - 16) = (int32_t)"normal exit";
        puts(str);
        g1 = *(int32_t *)(g2 + 24);
        return 0;
    }
    int32_t * t = (int32_t *)g1;
    int32_t v4 = v2; // 0x8048cb6
    // branch -> 0x8048cb6
    int32_t v5; // 0x8048ca9
    while (true) {
        // 0x8048cb6
        *(int32_t *)(v4 - 16) = (int32_t)"body 1";
        puts(str);
        *(int32_t *)g2 = 0;
        int32_t * v6 = (int32_t *)g2; // 0x8048c93
        if (time(t) == 1) {
            // 0x8048cd7
            *v6 = (int32_t)"took exit 1";
            puts(str);
            g1 = *(int32_t *)(g2 + 24);
            return 0;
        }
        // 0x8048c90
        *v6 = (int32_t)"body 2";
        puts(str);
        *(int32_t *)g2 = 0;
        v5 = g2 + 16;
        if (time(t) == 2) {
            // 0x8048d10
            *(int32_t *)g2 = (int32_t)"took exit 2";
            puts(str);
            g1 = *(int32_t *)(g2 + 24);
            return 0;
        }
        int32_t v7 = v3 - 1; // 0x8048cb1
        v3 = v7;
        if (v7 == 0) {
            // break -> 0x8048cf0
            break;
        }
        v4 = v5;
        // continue -> 0x8048cb6
    }
    // 0x8048cf0
    *(int32_t *)(v5 - 16) = (int32_t)"normal exit";
    puts(str);
    g1 = *(int32_t *)(g2 + 24);
    return 0;
}

// Address range: 0x8048d30 - 0x8048db2
int32_t advanced_10_irreducible(int32_t a1) {
    // 0x8048d30
    puts("b1");
    if (time(NULL) != a1) {
        // 0x8048d55
        puts("b2");
        if (time(NULL) == a1 + 1) {
            // 0x8048da0
            puts("b4");
            // branch -> 0x8048d88
            // 0x8048d88
            puts("b5");
            return 0;
        }
    }
    // 0x8048d78
    puts("b3");
    // branch -> 0x8048d88
    // 0x8048d88
    puts("b5");
    return 0;
}

// Address range: 0x8048dc0 - 0x8048e79
int32_t advanced_11_nested_loops_complex_condition(int32_t a1) {
    int32_t v1 = g1; // bp-12
    int32_t v2 = &v1; // 0x8048dc2
    puts("b0");
    char * str = NULL; // bp-28
    if (time(NULL) == a1) {
        // branch -> 0x8048e08
      lab_0x8048e08:
        while (true) {
            // 0x8048e08
            *(int32_t *)(v2 - 16) = (int32_t)"b2";
            puts(str);
            int32_t v3 = g2 + 16; // 0x8048e31
            // branch -> 0x8048e31
            int32_t v4; // 0x8048e2a
            while (true) {
                // 0x8048e31
                *(int32_t *)(v3 - 16) = (int32_t)"b3";
                puts(str);
                *(int32_t *)g2 = 0;
                int32_t * v5 = (int32_t *)g2; // 0x8048e23
                if (time((int32_t *)str) != a1 + 2) {
                    // 0x8048e20
                    *v5 = 0;
                    v4 = g2 + 16;
                    if (time((int32_t *)str) != a1 + 3) {
                        // break -> 0x8048de5
                        break;
                    }
                    v3 = v4;
                    // continue -> 0x8048e31
                    continue;
                } else {
                    // 0x8048e51
                    *v5 = (int32_t)"b1";
                    puts(str);
                    *(int32_t *)g2 = 0;
                    int32_t v6 = g2 + 16; // 0x8048e6d
                    if (time((int32_t *)str) != a1 + 1) {
                        v2 = v6;
                        // break (via goto) -> 0x8048de5
                        goto lab_0x8048de5;
                    }
                    v2 = v6;
                    // continue (via goto) -> 0x8048e08
                    goto lab_0x8048e08;
                }
                // 0x8048de5
                *(int32_t *)(v2 - 16) = (int32_t)"b9";
                char * str2 = str; // 0x8048ded
                puts(str2);
                int32_t v7 = g2; // 0x8048df2
                int32_t v8 = *(int32_t *)(v7 + 16); // 0x8048df7
                g1 = v8;
                return 0;
            }
            // 0x8048de5
            *(int32_t *)(v4 - 16) = (int32_t)"b9";
            puts(str);
            g1 = *(int32_t *)(g2 + 16);
            return 0;
        }
    }
  lab_0x8048de5:
    // 0x8048de5
    *(int32_t *)(v2 - 16) = (int32_t)"b9";
    puts(str);
    g1 = *(int32_t *)(g2 + 16);
    return 0;
}

// Address range: 0x8048e80 - 0x8048f22
int32_t advanced_12_nested_if_in_loop(int32_t a1) {
    int32_t v1 = g1; // bp-12
    char * str = "b0"; // bp-28
    puts("b0");
    int32_t v2 = &v1; // 0x8048ea0
    // branch -> 0x8048ea0
    int32_t v3; // 0x8048ee0
    while (true) {
        // 0x8048ea0
        *(int32_t *)(v2 - 16) = (int32_t)"b1";
        puts(str);
        *(int32_t *)g2 = 0;
        int32_t * v4 = (int32_t *)g2; // 0x8048f03
        if (time((int32_t *)str) == a1) {
            // 0x8048f00
            *v4 = (int32_t)"b2";
            puts(str);
            *(int32_t *)g2 = 0;
            int32_t v5 = g2 + 16; // 0x8048f19
            if (time((int32_t *)str) != a1 + 1) {
                v3 = v5;
                // break -> 0x8048ee0
                break;
            }
            v2 = v5;
            // continue -> 0x8048ea0
            continue;
        } else {
            // 0x8048ec0
            *v4 = (int32_t)"b3";
            puts(str);
            *(int32_t *)g2 = 0;
            int32_t v6 = g2 + 16; // 0x8048ed9
            if (time((int32_t *)str) != a1 + 2) {
                v3 = v6;
                // break -> 0x8048ee0
                break;
            }
            v2 = v6;
            // continue -> 0x8048ea0
            continue;
        }
    }
    // 0x8048ee0
    *(int32_t *)(v3 - 16) = (int32_t)"b4";
    puts(str);
    g1 = *(int32_t *)(g2 + 16);
    return 0;
}

// Address range: 0x8048f30 - 0x8048f86
int32_t advanced_20_jump_table_on_stack(uint32_t result) {
    // 0x8048f30
    if (result < 6) {
        // 0x8048f6c
        return result;
    }
    // 0x8048f70
    puts("is something else");
    return 0;
}

// Address range: 0x8049050 - 0x8049107
int32_t advanced_21_computed_jumps(uint32_t a1) {
    // 0x8049050
    puts("start");
    if (a1 >= 3) {
        // 0x80490f0
        puts("is something else");
        return 0;
    }
    // 0x804906e
    if (a1 == 0) {
        // 0x8049098
        puts("is 0");
        return 0;
    }
    int32_t v1 = a1 != 2 ? (int32_t)&g4 - (int32_t)&g3 : (int32_t)&g4 - (int32_t)&g3 + (int32_t)&g5 - (int32_t)&g4;
    return v1 + (int32_t)&g3;
}

// Address range: 0x8049110 - 0x8049153
int32_t basic_5_head_controlled_loop(int32_t a1) {
    char * str = "before"; // bp-28
    puts("before");
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x8049122
    if (a1 == 42) {
        // 0x804913f
        *(int32_t *)(v2 - 16) = (int32_t)"after";
        puts(str);
        g1 = *(int32_t *)(g2 + 24);
        return 0;
    }
    *(int32_t *)(v2 - 16) = (int32_t)"body";
    puts(str);
    int32_t v3 = g2 + 16; // 0x804913a
    while (a1 != 41) {
        // 0x804912a
        a1++;
        *(int32_t *)(v3 - 16) = (int32_t)"body";
        puts(str);
        v3 = g2 + 16;
        // continue -> 0x804912a
    }
    // 0x804913f
    *(int32_t *)(v3 - 16) = (int32_t)"after";
    puts(str);
    g1 = *(int32_t *)(g2 + 24);
    return 0;
}

// Address range: 0x8049160 - 0x80491a1
int32_t basic_6_tail_controlled_loop(int32_t a1) {
    char * str = "before"; // bp-28
    puts("before");
    int32_t v1; // bp-12
    *(int32_t *)((int32_t)&v1 - 16) = (int32_t)"body";
    puts(str);
    // branch -> 0x8049175
    while (a1 != 41) {
        // 0x8049175
        a1++;
        *(int32_t *)g2 = (int32_t)"body";
        puts(str);
        // continue -> 0x8049175
    }
    // 0x804918d
    *(int32_t *)g2 = (int32_t)"after";
    puts(str);
    g1 = *(int32_t *)(g2 + 24);
    return 0;
}

// Address range: 0x80491b0 - 0x80491d2
int32_t basic_8_forever_loop(int32_t a1) {
    // 0x80491b0
    if (a1 != 42) {
        // 0x80491ba
        return 0;
    }
    int32_t v1; // bp-12
    int32_t v2 = &v1; // 0x80491c0
    while (true) {
        // 0x80491c0
        *(int32_t *)(v2 - 16) = (int32_t)"loop body";
        int32_t * str;
        puts((char *)&str);
        v2 = g2 + 16;
        // branch -> 0x80491c0
    }
}

// Address range: 0x80491d2 - 0x8049211
int32_t basic_9_dead_block(void) {
    // 0x80491d2
    puts("entry");
    puts("exit");
    return 0;
}

// Address range: 0x8049211 - 0x8049216
int32_t intermediate_17_forever_loop_with_extra_statement(void) {
    // 0x8049211
    // branch -> 0x8049214
    while (true) {
        // 0x8049214
        // branch -> 0x8049214
    }
}

// --------------- Dynamically Linked Functions ---------------

// int putchar(int c);
// int puts(const char * s);
// int rand(void);
// time_t time(time_t * timer);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.4.1)
// Detected functions: 29
// Decompilation date: 2018-09-10 17:11:41
