// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048308: void _init()
void _init()
{
	if (__x86.get_pc_thunk.bx(dwLoc10)->dw2CEB != 0x00)
		fn08048390();
}

// 08048340: void time()
void time()
{
}

// 08048350: void puts()
void puts()
{
}

// 08048360: void __libc_start_main()
void __libc_start_main()
{
}

// 08048370: void putchar()
void putchar()
{
}

// 08048380: void rand()
void rand()
{
}

// 08048390: void fn08048390()
void fn08048390()
{
	word32 esp_3;
	globals->ptr804AFFC();
}

// 080483A0: void main(Stack up32 dwArg00, Stack Eq_19 dwArg04, Stack word32 dwArg08)
void main(up32 dwArg00, Eq_19 dwArg04, word32 dwArg08)
{
	__align(fp);
	basic_1_if(dwArg04);
	basic_2_if_else(dwArg04);
	basic_3_if_elseif(dwArg04);
	basic_4_if_elseif_else(dwArg04);
	basic_5_head_controlled_loop(dwArg04);
	basic_6_tail_controlled_loop(dwArg04);
	ui32 esi_32 = ~dwArg04;
	basic_7_for_loop(esi_32 & 0x01);
	basic_8_forever_loop(dwArg04);
	basic_9_dead_block();
	word32 eax_51 = (word32) (dwArg04 > 0x04);
	intermediate_1_short_circuit_and(eax_51, esi_32 & 0x01);
	intermediate_2_short_circuit_or(eax_51, esi_32 & 0x01);
	intermediate_10_loop_with_one_break(dwArg04);
	intermediate_11_loop_with_two_breaks(dwArg04);
	intermediate_12_loop_with_break_and_block(dwArg04);
	intermediate_13_loop_with_one_continue(esi_32 & 0x01, dwArg04);
	intermediate_14_loop_with_two_continues(esi_32 & 0x01, dwArg04);
	intermediate_15_loop_with_continue_and_block(esi_32 & 0x01, dwArg04);
	intermediate_16_loop_with_breaks_and_continues(esi_32 & 0x01, dwArg04);
	intermediate_17_forever_loop_with_extra_statement();
	intermediate_20_nested_loops(esi_32 & 0x01, dwArg04);
	intermediate_30_switch_case(dwArg04);
	advanced_1_loop_with_multiple_entries(dwArg04);
	advanced_2_loop_with_multiple_exits(dwArg04);
	advanced_10_irreducible(dwArg04);
	advanced_11_nested_loops_complex_condition(dwArg04);
	advanced_12_nested_if_in_loop(dwArg04);
	*advanced_20_jump_table_on_stack(dwArg04) = (union Eq_19 *) dwArg04;
	advanced_21_computed_jumps(dwArg00);
}

// 080484BB: void _start(Register (ptr32 Eq_161) edx, Stack int32 dwArg00)
void _start( * edx, int32 dwArg00)
{
	__align((char *) fp + 0x04);
	__libc_start_main(&globals->t80483A0, dwArg00, (char *) fp + 0x04, &globals->t8049230, &globals->t8049290, edx, fp);
	__hlt();
}

// 080484E0: Register word32 __x86.get_pc_thunk.bx(Stack word32 dwArg00)
word32 __x86.get_pc_thunk.bx(word32 dwArg00)
{
	return dwArg00;
}

// 080484F0: void deregister_tm_clones()
void deregister_tm_clones()
{
	if (true && 0x00 != 0x00)
	{
		word32 esp_33;
		word32 eax_34;
		byte SCZO_35;
		byte CZ_36;
		byte SZO_37;
		bool C_38;
		bool Z_39;
		word32 ebp_40;
		fn00000000();
	}
}

// 08048520: void register_tm_clones()
void register_tm_clones()
{
	if (0x00 != 0x00 && 0x00 != 0x00)
	{
		word32 esp_41;
		word32 eax_42;
		byte SCZO_43;
		word32 edx_44;
		bool Z_45;
		byte SZO_46;
		bool C_47;
		word32 ebp_48;
		fn00000000();
	}
}

// 08048560: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if (globals->b804B024 == 0x00)
	{
		deregister_tm_clones();
		globals->b804B024 = 0x01;
	}
}

// 08048580: void frame_dummy()
void frame_dummy()
{
	if (globals->dw804AF10 != 0x00 && 0x00 != 0x00)
	{
		word32 esp_37;
		word32 eax_38;
		word32 edx_39;
		byte SZO_40;
		bool C_41;
		bool Z_42;
		word32 ebp_43;
		byte SCZO_44;
		fn00000000();
		register_tm_clones();
	}
	else
		register_tm_clones();
}

// 080485B0: void basic_1_if(Stack Eq_19 dwArg04)
void basic_1_if(Eq_19 dwArg04)
{
	if (dwArg04 != 0x2A)
		return;
	puts("if block");
}

// 080485E0: void basic_2_if_else(Stack Eq_19 dwArg04)
void basic_2_if_else(Eq_19 dwArg04)
{
	if (dwArg04 == 0x2A)
		puts("if block");
	else
		puts("else block");
}

// 08048620: void basic_3_if_elseif(Stack Eq_19 dwArg04)
void basic_3_if_elseif(Eq_19 dwArg04)
{
	if (dwArg04 == 0x2A)
		puts("if block");
	else
	{
		if (dwArg04 != 0x2B)
			return;
		puts("else-if block");
	}
}

// 08048680: void basic_4_if_elseif_else(Stack Eq_19 dwArg04)
void basic_4_if_elseif_else(Eq_19 dwArg04)
{
	if (dwArg04 == 0x2A)
		puts("if block");
	else if (dwArg04 == 0x2B)
		puts("else-if block");
	else
		puts("else block");
}

// 080486F0: void basic_7_for_loop(Register ui32 esi)
void basic_7_for_loop(ui32 esi)
{
	int32 ebx_10 = 0x30;
	do
	{
		putchar(ebx_10);
		ebx_10 = ebx_10 + 0x01;
	} while (ebx_10 != 0x3A);
}

// 08048720: void intermediate_1_short_circuit_and(Stack word32 dwArg04, Stack Eq_19 dwArg08)
void intermediate_1_short_circuit_and(word32 dwArg04, Eq_19 dwArg08)
{
	Eq_19 eax_3 = rand();
	if (dwArg04 != 0x00 && eax_3 == dwArg08)
		puts("both true");
}

// 08048750: void intermediate_2_short_circuit_or(Stack word32 dwArg04, Stack Eq_19 dwArg08)
void intermediate_2_short_circuit_or(word32 dwArg04, Eq_19 dwArg08)
{
	Eq_19 eax_3 = rand();
	if (dwArg04 == 0x00 && eax_3 != dwArg08)
		return;
	puts("at least one is true");
}

// 08048790: void intermediate_10_loop_with_one_break(Stack Eq_19 dwArg04)
void intermediate_10_loop_with_one_break(Eq_19 dwArg04)
{
	while (true)
	{
		puts("head");
		if (time(null) == dwArg04)
			break;
		puts("tail");
	}
}

// 080487E0: void intermediate_11_loop_with_two_breaks(Stack Eq_19 dwArg04)
void intermediate_11_loop_with_two_breaks(Eq_19 dwArg04)
{
	Eq_19 ebx_22 = dwArg04;
	if (dwArg04 > 0x00)
	{
		do
		{
			puts("head");
			if (time(null) == ebx_22)
				return;
			puts("tail");
			ebx_22 = ebx_22 - 0x01;
		} while (ebx_22 != 0x00);
	}
}

// 08048830: void intermediate_12_loop_with_break_and_block(Stack Eq_19 dwArg04)
void intermediate_12_loop_with_break_and_block(Eq_19 dwArg04)
{
	while (true)
	{
		puts("head");
		if (time(null) == dwArg04)
			break;
		puts("barrier");
		if (dwArg04 == rand())
			return;
		puts("tail");
	}
	puts("will break");
}

// 080488A0: void intermediate_13_loop_with_one_continue(Register ui32 esi, Stack Eq_19 dwArg04)
void intermediate_13_loop_with_one_continue(ui32 esi, Eq_19 dwArg04)
{
	if (dwArg04 <= 0x7B)
		return;
	while (true)
	{
		puts("head");
		if (dwArg04 != time(null))
			puts("tail");
	}
}

// 080488F0: void intermediate_14_loop_with_two_continues(Register ui32 esi, Stack Eq_19 dwArg04)
void intermediate_14_loop_with_two_continues(ui32 esi, Eq_19 dwArg04)
{
	if (dwArg04 <= 0x7B)
		return;
	while (true)
	{
		puts("head");
		if (dwArg04 != time(null))
		{
			puts("barrier");
			if (dwArg04 != rand())
				puts("tail");
		}
	}
}

// 08048960: void intermediate_15_loop_with_continue_and_block(Register ui32 esi, Stack Eq_19 dwArg04)
void intermediate_15_loop_with_continue_and_block(ui32 esi, Eq_19 dwArg04)
{
	if (dwArg04 <= 0x7B)
		return;
	while (true)
	{
		puts("head");
		if (dwArg04 != time(null))
		{
			puts("barrier");
			if (dwArg04 != rand())
				puts("tail");
		}
		else
			puts("will continue");
	}
}

// 080489E0: void intermediate_16_loop_with_breaks_and_continues(Register ui32 esi, Stack Eq_19 dwArg04)
void intermediate_16_loop_with_breaks_and_continues(ui32 esi, Eq_19 dwArg04)
{
	while (true)
	{
		do
			puts("head");
		while (time(null) + 0x01 == dwArg04);
		puts("after first continue");
		if (dwArg04 == time(null) + 0x02)
			break;
		puts("after first break");
		if (dwArg04 == time(null) + 0x03)
			continue;
		puts("after second continue");
		if (dwArg04 == time(null) + 0x04)
			return;
		puts("after second break; tail");
	}
}

// 08048AA0: void intermediate_20_nested_loops(Register ui32 esi, Stack Eq_19 dwArg04)
void intermediate_20_nested_loops(ui32 esi, Eq_19 dwArg04)
{
	puts("before");
	do
	{
		puts("outer loop");
		do
			puts("inner loop");
		while (time(null) != dwArg04);
	} while (dwArg04 != rand());
	puts("after");
}

// 08048B10: void intermediate_30_switch_case(Stack Eq_19 dwArg04)
void intermediate_30_switch_case(Eq_19 dwArg04)
{
	if (dwArg04 <= 0x09)
	{
		switch (dwArg04)
		{
		case 0x00:
			puts("0");
			break;
		case 0x01:
			puts("1");
			break;
		case 0x02:
		case 0x03:
			puts("2 or 3");
			break;
		case 0x04:
			puts("4");
			break;
		case 0x05:
			puts("5");
			break;
		case 0x06:
			puts("6");
			break;
		case 0x07:
			puts("7 with fall through");
			goto l08048B40;
		case 0x08:
l08048B40:
			puts("8");
			break;
		case 0x09:
			puts("9");
			break;
		}
	}
	else
		puts("some other value");
	puts("common exit");
}

// 08048C30: void advanced_1_loop_with_multiple_entries(Stack Eq_19 dwArg04)
void advanced_1_loop_with_multiple_entries(Eq_19 dwArg04)
{
	Eq_19 ebx_19 = dwArg04;
	if (dwArg04 != 0x2A)
	{
		if (dwArg04 <= 0x00)
			return;
l08048C41:
		puts("body 1");
		ebx_19 = ebx_19 - 0x01;
	}
	else
		ebx_19.u0 = 0x29;
	puts("body 2");
	if (ebx_19 <= 0x00)
		return;
	goto l08048C41;
}

// 08048C80: void advanced_2_loop_with_multiple_exits(Stack Eq_19 dwArg04)
void advanced_2_loop_with_multiple_exits(Eq_19 dwArg04)
{
	Eq_19 ebx_28 = dwArg04;
	if (dwArg04 > 0x00)
	{
		do
		{
			puts("body 1");
			if (time(null) == 0x01)
			{
				puts("took exit 1");
				return;
			}
			puts("body 2");
			if (time(null) == 0x02)
			{
				puts("took exit 2");
				return;
			}
			ebx_28 = ebx_28 - 0x01;
		} while (ebx_28 != 0x00);
	}
	puts("normal exit");
}

// 08048D30: void advanced_10_irreducible(Stack Eq_19 dwArg04)
void advanced_10_irreducible(Eq_19 dwArg04)
{
	puts("b1");
	if (time(null) != dwArg04)
	{
		puts("b2");
		if (time(null) == (word32) dwArg04 + 0x01)
		{
			puts("b4");
l08048D88:
			puts("b5");
			return;
		}
	}
	puts("b3");
	goto l08048D88;
}

// 08048DC0: void advanced_11_nested_loops_complex_condition(Stack Eq_19 dwArg04)
void advanced_11_nested_loops_complex_condition(Eq_19 dwArg04)
{
	puts("b0");
	Eq_19 eax_16 = time(null);
	if (eax_16 == dwArg04)
	{
l08048E08:
		puts("b2");
		do
		{
			puts("b3");
			if (time(null) == eax_16 + 0x02)
			{
				puts("b1");
				if (time(null) != eax_16 + 0x01)
					break;
				goto l08048E08;
			}
		} while (time(null) == eax_16 + 0x03);
	}
	puts("b9");
}

// 08048E80: void advanced_12_nested_if_in_loop(Stack Eq_19 dwArg04)
void advanced_12_nested_if_in_loop(Eq_19 dwArg04)
{
	puts("b0");
	do
	{
		puts("b1");
		if (time(null) != dwArg04)
		{
			puts("b3");
			if (time(null) != (word32) dwArg04 + 0x02)
				break;
			continue;
		}
		puts("b2");
	} while (time(null) == (word32) dwArg04 + 0x01);
	puts("b4");
}

// 08048F30: Register ptr32 advanced_20_jump_table_on_stack(Stack Eq_19 dwArg04)
ptr32 advanced_20_jump_table_on_stack(Eq_19 dwArg04)
{
	if (dwArg04 > 0x05)
	{
		puts("is something else");
		return fp;
	}
	else
	{
		ptr32 esp_24;
		byte SCZO_25;
		word32 eax_26;
		byte CZ_27;
		byte SZO_28;
		bool C_29;
		(fp - 0x24)[dwArg04]();
		return esp_24;
	}
}

// 08049050: void advanced_21_computed_jumps(Stack up32 dwArg04)
void advanced_21_computed_jumps(up32 dwArg04)
{
	puts("start");
	if (dwArg04 > 0x02)
		puts("is something else");
	else if (dwArg04 == 0x00)
		puts("is 0");
	else
	{
		word32 eax_27 = 0x18;
		if (dwArg04 == 0x02)
			eax_27 = 0x38;
		<anonymous> * eax_31 = eax_27 + 0x08049098;
		word32 esp_33;
		word32 ebx_34;
		byte SCZO_35;
		word32 eax_36;
		byte CZ_37;
		byte SZO_38;
		bool C_39;
		bool Z_40;
		eax_31();
	}
}

// 08049110: void basic_5_head_controlled_loop(Stack Eq_19 dwArg04)
void basic_5_head_controlled_loop(Eq_19 dwArg04)
{
	puts("before");
	Eq_19 ebx_13 = dwArg04;
	while (ebx_13 != 0x2A)
	{
		puts("body");
		ebx_13 = (word32) ebx_13 + 0x01;
	}
	puts("after");
}

// 08049160: void basic_6_tail_controlled_loop(Stack Eq_19 dwArg04)
void basic_6_tail_controlled_loop(Eq_19 dwArg04)
{
	puts("before");
	Eq_19 ebx_13 = dwArg04;
	do
	{
		puts("body");
		ebx_13 = (word32) ebx_13 + 0x01;
	} while (ebx_13 != 0x2A);
	puts("after");
}

// 080491B0: void basic_8_forever_loop(Stack Eq_19 dwArg04)
void basic_8_forever_loop(Eq_19 dwArg04)
{
	if (dwArg04 != 0x2A)
		return;
	while (true)
		puts("loop body");
}

// 080491D2: void basic_9_dead_block()
void basic_9_dead_block()
{
	puts("entry");
	puts("exit");
}

// 08049211: void intermediate_17_forever_loop_with_extra_statement()
void intermediate_17_forever_loop_with_extra_statement()
{
	while (true)
		;
}

// 08049230: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_6 * ebx_15 = __x86.get_pc_thunk.bx(dwLoc14);
	_init();
	if ((char *) &ebx_15->ptr1CCF + 0x04 - &ebx_15->ptr1CCF >> 0x02 != 0x00)
	{
		do
		{
			word32 esp_66;
			word32 ebp_67;
			word32 edi_68;
			word32 esi_69;
			word32 ebx_70;
			byte SCZO_71;
			word32 eax_72;
			byte SZO_73;
			bool C_74;
			bool Z_75;
			ebx_15->ptr1CCF();
		} while (esi_69 != edi_68 + 0x01);
	}
}

// 08049290: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 08049294: void _fini()
void _fini()
{
	__x86.get_pc_thunk.bx(dwLoc10);
}

